/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a910 */
#include <stdint.h>
 
void entry0 (void) {
    /* [13] -r-x section size 178524 named .text */
    ebp = 0;
    ecx = esp;
    return libc_start_main (main, esi, ecx, sym.__libc_csu_init, sym.__libc_csu_fini, edx, esp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a0b4 */
#include <stdint.h>
 
void libc_start_main (void) {
    libc_start_main ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a940 */
#include <stdint.h>
 
int32_t do_global_dtors_aux (void) {
    if (*(obj.completed.5978) != 0) {
        goto label_0;
    }
    eax = *(obj.dtor_idx.5980);
    ebx = obj.__DTOR_END__;
    ebx -= obj.__DTOR_LIST__;
    ebx >>= 2;
    ebx--;
    if (eax >= ebx) {
        goto label_1;
    }
    do {
        eax++;
        *(obj.dtor_idx.5980) = eax;
        uint32_t (*eax*4 + obj.__DTOR_LIST__)() ();
        eax = *(obj.dtor_idx.5980);
    } while (eax < ebx);
label_1:
    *(obj.completed.5978) = 1;
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a9a0 */
#include <stdint.h>
 
int32_t frame_dummy (void) {
    eax = *(obj.__JCR_LIST__);
    if (eax != 0) {
        eax = 0;
        if (eax == 0) {
            goto label_0;
        }
        void (*eax)(uint32_t) (obj.__JCR_LIST__);
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8076240 */
#include <stdint.h>
 
int32_t do_global_ctors_aux (void) {
    eax = .ctors;
    if (eax == -1) {
        goto label_0;
    }
    ebx = .ctors;
    do {
        ebx -= 4;
        void (*eax)() ();
        eax = *(ebx);
    } while (eax != -1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062940 */
#include <stdint.h>
 
uint32_t alloc_group_entry (void) {
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x15fbe;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x44)) = eax;
    eax = ebp - 0x44;
    *(edi) = eax;
    *((ebp - 0x3c)) = 1;
    *((ebp - 0x40)) = 3;
    eax = ebp - 0x1c;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string (eax);
    *((ebp - 0x20)) = eax;
    eax = *((esi + 0xc));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x24)) = eax;
    caml_alloc_small (4, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((ebp - 0x24));
    *((eax + 0xc)) = edx;
    edx = *((ebp - 0x44));
    *(edi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061a1e */
#include <stdint.h>
 
void i686_get_pc_thunk_bx (void) {
    ebx = *(esp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a734 */
#include <stdint.h>
 
int32_t caml_copy_string (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = *((ebp + 8));
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ebx = ecx - 1;
    eax = caml_alloc_string (ebx);
    esi = eax;
    eax = *((ebp + 8));
    memmove (esi, eax, ebx);
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a68a */
#include <stdint.h>
 
int32_t caml_alloc_string (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    ebx = esi + 4;
    ebx >>= 2;
    if (ebx <= 0x100) {
        edx = ebx*4 + 4;
        edi = edx;
        edi = -edi;
        eax = edi;
        eax += *(obj.caml_young_ptr);
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            eax += edx;
            *(obj.caml_young_ptr) = eax;
            caml_minor_collection ();
            *(obj.caml_young_ptr) += edi;
        }
        edx = ebx;
        edx <<= 0xa;
        edx += 0x3fc;
        eax = caml_young_ptr;
        *(eax) = edx;
        eax = caml_young_ptr;
        eax += 4;
    } else {
        eax = caml_alloc_shr (ebx, 0xfc);
        caml_check_urgent_gc (eax);
    }
    ebx <<= 2;
    *((eax + ebx - 4)) = 0;
    ebx--;
    edx = ebx;
    ecx = esi;
    dl -= cl;
    *((eax + ebx)) = dl;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a684 */
#include <stdint.h>
 
void memmove (void) {
    memmove ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a96a */
#include <stdint.h>
 
int32_t caml_copy_string_array (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    caml_alloc_array (sym.caml_copy_string, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a8a6 */
#include <stdint.h>
 
int32_t caml_alloc_array (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4ch;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    esi = *((ebp + 0xc));
    eax = caml_local_roots;
    *((ebp - 0x4c)) = eax;
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x40;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 2;
    eax = ebp - 0x1c;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x30)) = eax;
    if (*(esi) == 0) {
        goto label_0;
    }
    ebx = 0;
    do {
        ebx++;
    } while (*((esi + ebx*4)) != 0);
    if (ebx == 0) {
label_0:
        eax = 0x808b124;
        edx = *((ebp - 0x4c));
        *(obj.caml_local_roots) = edx;
        goto label_1;
    }
    eax = caml_alloc (ebx, 0);
    *((ebp - 0x20)) = eax;
    edi = 0;
    do {
        eax = *(esi);
        eax = uint32_t (*ebp + 8)(uint32_t) (eax);
        *((ebp - 0x1c)) = eax;
        eax = edi*4;
        eax += *((ebp - 0x20));
        caml_modify (eax, eax);
        edi++;
        esi += 4;
    } while (edi < ebx);
    eax = *((ebp - 0x4c));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x20));
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a621 */
#include <stdint.h>
 
int32_t caml_alloc_small (int32_t arg_8h, fd_set * arg_ch) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = *((ebp + 8));
    edx = esi*4 + 4;
    ebx = edx;
    ebx = -ebx;
    eax = ebx;
    eax += *(obj.caml_young_ptr);
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        eax += edx;
        *(obj.caml_young_ptr) = eax;
        caml_minor_collection ();
        *(obj.caml_young_ptr) += ebx;
    }
    esi <<= 0xa;
    eax = *((ebp + 0xc));
    edx = eax + esi + 0x300;
    eax = caml_young_ptr;
    *(eax) = edx;
    eax = caml_young_ptr;
    eax += 4;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069b33 */
#include <stdint.h>
 
int32_t caml_minor_collection (void) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = caml_allocated_words;
    caml_empty_minor_heap ();
    eax = caml_allocated_words;
    eax -= ebx;
    esi = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = esi;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] += *(obj.caml_stat_promoted_words);
    *(obj.caml_stat_promoted_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_stat_minor_collections)++;
    caml_major_collection_slice (0);
    *(obj.caml_force_major_slice) = 0;
    caml_final_do_calls ();
    caml_empty_minor_heap ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80699e9 */
#include <stdint.h>
 
int32_t caml_empty_minor_heap (void) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    eax = caml_young_ptr;
    if (eax == *(obj.caml_young_end)) {
        goto label_0;
    }
    *(obj.caml_in_minor_collection) = 1;
    caml_gc_message (2, 0x8076adc, 0);
    caml_oldify_local_roots ();
    ebx = caml_ref_table;
    if (ebx >= *(0x8087aa8)) {
        goto label_1;
    }
    esi = 0x8087aa8;
    do {
        eax = *(ebx);
        eax = *(eax);
        caml_oldify_one (eax, eax);
        ebx += 4;
    } while (*(esi) > ebx);
label_1:
    caml_oldify_mopup ();
    eax = caml_weak_ref_table;
    if (eax >= *(0x8087ac4)) {
        goto label_2;
    }
    ebx = 0x8087ac4;
    do {
        ecx = *(eax);
        edx = *(ecx);
        if ((dl & 1) == 0) {
            if (edx >= *(obj.caml_young_end)) {
                goto label_3;
            }
            if (edx <= *(obj.caml_young_start)) {
                goto label_3;
            }
            if (*((edx - 4)) == 0) {
                edx = *(edx);
                *(ecx) = edx;
            } else {
                edx = caml_weak_none;
                *(ecx) = edx;
            }
        }
label_3:
        eax += 4;
    } while (*(ebx) > eax);
label_2:
    eax = caml_young_start;
    edx = caml_young_ptr;
    if (*(obj.caml_young_ptr) < eax) {
        edx = eax;
    }
    eax = caml_young_end;
    ecx = caml_young_end;
    ecx -= edx;
    edx = ecx;
    edx >>= 2;
    ecx = 0;
    *((ebp - 0x10)) = edx;
    *((ebp - 0xc)) = ecx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *(obj.caml_stat_minor_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_young_ptr) = eax;
    eax = caml_young_start;
    *(obj.caml_young_limit) = eax;
    eax = caml_ref_table;
    clear_table ();
    eax = caml_weak_ref_table;
    clear_table ();
    caml_gc_message (2, 0x8077147, 0);
    *(obj.caml_in_minor_collection) = 0;
label_0:
    caml_final_empty_young ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80694d8 */
#include <stdint.h>
 
int32_t caml_major_collection_slice (int32_t arg_8h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_22h;
    int32_t var_20h;
    int32_t var_1ch;
    char * var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    if (*(obj.caml_gc_phase) == 2) {
        start_cycle ();
    }
    eax = caml_allocated_words;
    edx = caml_percent_free;
    esi = edx + 0x64;
    edi = 0;
    *((ebp - 0x20)) = esi;
    *((ebp - 0x1c)) = edi;
    *(fp_stack--) = *((ebp - 0x20));
    ecx = 0;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x1c)) = ecx;
    *(fp_stack--) = *((ebp - 0x20));
    ecx = 0;
    *((ebp - 0x20)) = eax;
    *((ebp - 0x1c)) = ecx;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] *= *(0x8076acc);
    fp_stack[0] *= fp_stack[2];
    edx = caml_stat_heap_size;
    edx >>= 2;
    ecx = 0;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x1c)) = ecx;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    fp_stack[0] /= fp_stack[1];
    fp_stack[0] *= *(0x8076ad0);
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    edx = caml_dependent_size;
    if (edx == 0) {
        fp_stack++;
        fp_stack++;
        *(fp_stack--) = 0.0;
    } else {
        esi = caml_dependent_allocated;
        edi = 0;
        *((ebp - 0x20)) = esi;
        *((ebp - 0x1c)) = edi;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] *= fp_stack[2];
        fp_stack++;
        ecx = 0;
        *((ebp - 0x20)) = edx;
        *((ebp - 0x1c)) = ecx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] /= fp_stack[2];
        fp_stack++;
        fp_stack[0] /= fp_stack[1];
        fp_stack++;
    }
    *(fp_stack--) = *((ebp - 0x30));
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    __asm ("fcmovbe st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_extra_heap_resources);
    __asm ("fcmovbe st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    caml_gc_message (0x40, "allocated_words = %lu\n", eax);
    *(fp_stack--) = *(0x80766f0);
    fp_stack[0] *= *(obj.caml_extra_heap_resources);
    eax = *((ebp - 0x22));
    ah = 0xc;
    *((ebp - 0x24)) = ax;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x20));
    caml_gc_message (0x40, "extra_heap_resources = %luu\n", eax);
    *(fp_stack--) = *(0x80766f0);
    fp_stack[0] *= *((ebp - 0x30));
    eax = *((ebp - 0x22));
    ah = 0xc;
    *((ebp - 0x24)) = ax;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x20));
    caml_gc_message (0x40, "amount of work to do = %luu\n", eax);
    if (*(obj.caml_gc_phase) == 0) {
        eax = caml_stat_heap_size;
        eax >>= 2;
        edx = 0;
        *((ebp - 0x20)) = eax;
        *((ebp - 0x1c)) = edx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] *= *((ebp - 0x30));
        fp_stack[0] *= *(0x8076ad4);
        eax = caml_percent_free;
        eax += 0x64;
        edx = 0;
        *((ebp - 0x20)) = eax;
        *((ebp - 0x1c)) = edx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] /= fp_stack[1];
        fp_stack++;
        eax = *((ebp - 0x22));
        ah = 0xc;
        *((ebp - 0x24)) = ax;
        *((ebp - 0x28)) = fp_stack[0];
        fp_stack--;
        esi = *((ebp - 0x28));
    } else {
        eax = caml_stat_heap_size;
        eax >>= 2;
        edx = 0;
        *((ebp - 0x20)) = eax;
        *((ebp - 0x1c)) = edx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] *= *((ebp - 0x30));
        fp_stack[0] *= *(0x8076ad8);
        fp_stack[0] /= *(0x8076acc);
        eax = *((ebp - 0x22));
        ah = 0xc;
        *((ebp - 0x24)) = ax;
        *((ebp - 0x28)) = fp_stack[0];
        fp_stack--;
        esi = *((ebp - 0x28));
    }
    caml_gc_message (0x40, "ordered work = %ld words\n", ebx);
    caml_gc_message (0x40, "computed work = %ld words\n", esi);
    if (ebx == 0) {
        ebx = esi;
    }
    if (*(obj.caml_gc_phase) == 0) {
        eax = ebx;
        mark_slice ();
        caml_gc_message (2, 0x8076ac5, 0);
    } else {
        eax = ebx;
        sweep_slice ();
        caml_gc_message (2, 0x8076ac7, 0);
    }
    if (*(obj.caml_gc_phase) == 2) {
        caml_compact_heap_maybe ();
    }
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x20)) = eax;
    *((ebp - 0x1c)) = edx;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *(obj.caml_stat_major_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_allocated_words) = 0;
    *(obj.caml_dependent_allocated) = 0;
    *(fp_stack--) = 0.0;
    *(obj.caml_extra_heap_resources) = fp_stack[0];
    fp_stack--;
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8074df9 */
#include <stdint.h>
 
uint32_t caml_final_do_calls (void) {
    char * var_4h;
    int32_t var_8h;
    if (*(obj.running_finalisation_function) != 0) {
        goto label_1;
    }
    if (*(obj.to_do_hd) == 0) {
        goto label_1;
    }
    eax = caml_gc_message (0x80, "Calling finalisation functions.\n", 0);
    while (edx == 0) {
        ebx = *(eax);
        free (eax);
        *(obj.to_do_hd) = ebx;
        if (ebx == 0) {
            *(obj.to_do_tl) = 0;
        }
label_0:
        eax = to_do_hd;
        if (eax == 0) {
            goto label_2;
        }
        edx = *((eax + 4));
    }
    edx--;
    *((eax + 4)) = edx;
    edx *= 3;
    eax = eax + edx*4;
    edx = *((eax + 8));
    ecx = *((eax + 0x10));
    eax = *((eax + 0xc));
    *(obj.running_finalisation_function) = 1;
    eax += ecx;
    eax = caml_callback_exn (edx, eax);
    *(obj.running_finalisation_function) = 0;
    edx = eax;
    edx &= 3;
    if (edx != 2) {
        goto label_0;
    }
    eax &= 0xfffffffc;
    caml_raise (eax);
label_2:
    caml_gc_message (0x80, "Done calling finalisation functions.\n", 0);
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806832f */
#include <stdint.h>
 
int32_t caml_gc_message (int32_t arg_8h, char * arg_ch, size_t arg_10h) {
    char * format;
    size_t var_8h;
    eax = *((ebp + 8));
    if (eax >= 0) {
        if ((*(obj.caml_verb_gc) & eax) == 0) {
            goto label_0;
        }
    }
    eax = *((ebp + 0x10));
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax = stderr;
    fprintf (eax, eax);
    eax = stderr;
    fflush (eax);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a1a4 */
#include <stdint.h>
 
void free (void) {
    free ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075cd8 */
#include <stdint.h>
 
int32_t loc_caml_callback_exn (int32_t arg_14h, int32_t arg_18h) {
    do {
        *(obj.caml_exception_pointer) = esp;
        void (*esi)(uint32_t*, uint32_t, uint32_t*, uint32_t*, uint32_t*) (*(obj.caml_exception_pointer), 0x8075c4e, *(obj.caml_bottom_of_stack), *(obj.caml_last_return_address), *(obj.caml_gc_regs));
        return;
        ebx = *((esp + 0x14));
        eax = *((esp + 0x18));
        esi = *(ebx);
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066dd0 */
#include <stdint.h>
 
int32_t caml_raise (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = caml_channel_mutex_unlock_exn;
    if (eax != 0) {
        void (*eax)() ();
    }
    edx = caml_exception_pointer;
    if (edx != 0) {
        eax = caml_local_roots;
        if (eax == 0) {
            goto label_0;
        }
        if (eax < edx) {
            goto label_1;
        }
        goto label_0;
    }
    eax = caml_fatal_uncaught_exception (ebx);
    do {
label_1:
        eax = *(eax);
        *(obj.caml_local_roots) = eax;
        if (eax == 0) {
            goto label_0;
        }
    } while (edx > eax);
label_0:
    return caml_raise_exception (ebx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062ae4 */
#include <stdint.h>
 
uint32_t alloc_host_entry (void) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x15e1b;
    esi = eax;
    *((ebp - 0xc)) = 1;
    *((ebp - 0x10)) = 1;
    *((ebp - 0x14)) = 1;
    *((ebp - 0x18)) = 1;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x38)) = edx;
    edx = ebp - 0x38;
    *(eax) = edx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp - 0xc;
    *((ebp - 0x2c)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x28)) = eax;
    eax = ebp - 0x14;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x18;
    *((ebp - 0x20)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0xc)) = eax;
    eax = *((esi + 4));
    if (eax != 0) {
        eax = caml_copy_string_array (eax);
        *((ebp - 0x10)) = eax;
    } else {
        eax = *((ebx - 4));
        eax = eax + 4;
        *((ebp - 0x10)) = eax;
    }
    eax = *((esi + 0xc));
    *((ebx + 0xbe80)) = eax;
    eax = *((esi + 0x10));
    eax = ebx - 0x15c6a;
    eax = caml_alloc_array (eax, eax);
    *((ebp - 0x14)) = eax;
    caml_alloc_small (4, 0);
    edx = *((ebp - 0xc));
    *(eax) = edx;
    edx = eax;
    ecx = *((ebp - 0x10));
    *((eax + 4)) = ecx;
    ecx = *((esi + 8));
    if (ecx != 1) {
        cl = (ecx != 2) ? 1 : 0;
        ecx = (int32_t) cl;
        ecx = ecx + ecx + 3;
        *((eax + 8)) = ecx;
    } else {
        *((eax + 8)) = 1;
    }
    ecx = *((ebp - 0x14));
    *((edx + 0xc)) = ecx;
    ecx = *((ebp - 0x38));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062ca2 */
#include <stdint.h>
 
int32_t alloc_one_addr (int32_t arg_8h) {
    void * s1;
    void * var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15c59;
    eax = *((ebp + 8));
    if (*((ebx + 0xbe80)) == 0x10) {
        esi = ebp - 0x1c;
        memmove (esi, eax, 0x10);
        eax = alloc_inet6_addr (esi);
    } else {
        esi = ebp - 0xc;
        memmove (esi, eax, 4);
        alloc_inet_addr (esi);
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063040 */
#include <stdint.h>
 
uint32_t alloc_proto_entry (void) {
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x158b8;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x40;
    *(edi) = eax;
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 2;
    eax = ebp - 0x1c;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x20)) = eax;
    caml_alloc_small (3, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((ebp - 0x40));
    *(edi) = edx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063150 */
#include <stdint.h>
 
uint32_t alloc_passwd_entry (void) {
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x157ae;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    *((ebp - 0x28)) = 1;
    *((ebp - 0x2c)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(edi) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 5;
    eax = ebp - 0x1c;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x2c;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string (eax);
    *((ebp - 0x20)) = eax;
    eax = *((esi + 0x10));
    eax = caml_copy_string (eax);
    *((ebp - 0x24)) = eax;
    eax = *((esi + 0x14));
    eax = caml_copy_string (eax);
    *((ebp - 0x28)) = eax;
    eax = *((esi + 0x18));
    eax = caml_copy_string (eax);
    *((ebp - 0x2c)) = eax;
    caml_alloc_small (7, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((esi + 0xc));
    edx = edx + edx + 1;
    *((eax + 0xc)) = edx;
    edx = *((ebp - 0x24));
    *((eax + 0x10)) = edx;
    edx = *((ebp - 0x28));
    *((eax + 0x14)) = edx;
    edx = *((ebp - 0x2c));
    *((eax + 0x18)) = edx;
    edx = *((ebp - 0x4c));
    *(edi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063320 */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
uint32_t alloc_service_entry (void) {
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x155de;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x44)) = eax;
    eax = ebp - 0x44;
    *(edi) = eax;
    *((ebp - 0x3c)) = 1;
    *((ebp - 0x40)) = 3;
    eax = ebp - 0x1c;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x20)) = eax;
    eax = *((esi + 0xc));
    eax = caml_copy_string (eax);
    *((ebp - 0x24)) = eax;
    caml_alloc_small (4, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    dx = rotate_right16 (dx, 8);
    edx = (int32_t) dx;
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((ebp - 0x24));
    *((eax + 0xc)) = edx;
    edx = *((ebp - 0x44));
    *(edi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063500 */
#include <stdint.h>
 
uint32_t alloc_tm (void) {
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x153ff;
    esi = eax;
    caml_alloc_small (9, 0);
    edx = *(esi);
    edx = edx + edx + 1;
    *(eax) = edx;
    edx = *((esi + 4));
    edx = edx + edx + 1;
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((esi + 0xc));
    edx = edx + edx + 1;
    *((eax + 0xc)) = edx;
    edx = *((esi + 0x10));
    edx = edx + edx + 1;
    *((eax + 0x10)) = edx;
    edx = *((esi + 0x14));
    edx = edx + edx + 1;
    *((eax + 0x14)) = edx;
    edx = *((esi + 0x18));
    edx = edx + edx + 1;
    *((eax + 0x18)) = edx;
    edx = *((esi + 0x1c));
    edx = edx + edx + 1;
    *((eax + 0x1c)) = edx;
    edx -= edx;
    edx &= 0xfffffffe;
    edx += 3;
    *((eax + 0x20)) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80637e4 */
#include <stdint.h>
 
uint32_t unix_convert_itimer (void) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x15117;
    esi = eax;
    eax = caml_alloc_small (4, 0xfe);
    *(fp_stack--) = *(esi);
    *(fp_stack--) = *((esi + 4));
    *(fp_stack--) = *((ebx - 0x2564));
    fp_stack[1] /= fp_stack[0];
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack[0] += fp_stack[2];
    fp_stack++;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    *(eax) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((esi + 8));
    *(fp_stack--) = *((esi + 0xc));
    fp_stack[2] /= fp_stack[0];
    fp_stack++;
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063893 */
#include <stdint.h>
 
uint32_t unix_set_timeval (void) {
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_2ah;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x15065;
    esi = eax;
    eax = ebp - 0x20;
    *(fp_stack--) = *((ebp + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    modf (eax);
    eax = *((ebp - 0x2a));
    ah = 0xc;
    *((ebp - 0x2c)) = ax;
    *(fp_stack--) = *((ebp - 0x20));
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    edi = *((ebp - 0x30));
    *(esi) = edi;
    fp_stack[0] *= *((ebx - 0x2564));
    *(esp) = fp_stack[0];
    fp_stack--;
    ceil ();
    eax = *((ebp - 0x2a));
    ah = 0xc;
    *((ebp - 0x2c)) = ax;
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x30));
    *((esi + 4)) = eax;
    if (eax > 0xf423f) {
        edi++;
        *(esi) = edi;
        *((esi + 4)) = 0;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a0e4 */
#include <stdint.h>
 
void modf (void) {
    modf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a8e4 */
#include <stdint.h>
 
void ceil (void) {
    ceil ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806439c */
#include <stdint.h>
 
int32_t fdlist_to_fdset (int32_t arg_8h) {
    int32_t var_ch;
    esi = eax;
    *((ebp - 0xc)) = edx;
    ecx = 0x20;
    edi = edx;
    eax = 0;
    memset (edi, eax, ecx);
    if (esi == 1) {
        goto label_0;
    }
    edx = esi;
    do {
        edi = *(edx);
        eax = *(edx);
        eax >>= 1;
        esi = eax + 0x1f;
        __asm ("cmovns esi, eax");
        esi >>= 5;
        edi >>= 0x1f;
        edi >>= 0x1b;
        ecx = eax + edi;
        ecx &= 0x1f;
        ecx -= edi;
        edi = 1;
        edi <<= cl;
        ecx = edi;
        edi = *((ebp - 0xc));
        *((edi + esi*4)) |= ecx;
        ecx = *((ebp + 8));
        if (eax > *(ecx)) {
            *(ecx) = eax;
        }
        edx = *((edx + 4));
    } while (edx != 1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064405 */
#include <stdint.h>
 
uint32_t fdset_to_fdlist (void) {
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x144f9;
    edi = edx;
    *((ebp - 0x20)) = 1;
    edx = *((ebx - 0x18));
    ecx = *(edx);
    *((ebp - 0x40)) = ecx;
    ecx = ebp - 0x40;
    *(edx) = ecx;
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 2;
    edx = ebp - 0x1c;
    *((ebp - 0x34)) = edx;
    edx = ebp - 0x20;
    *((ebp - 0x30)) = edx;
    if (eax == 1) {
        goto label_0;
    }
    *((ebp - 0x1c)) = eax;
    do {
        eax = *(eax);
        esi = *(eax);
        esi >>= 1;
        edx = esi + 0x1f;
        __asm ("cmovns edx, esi");
        edx >>= 5;
        eax >>= 0x1f;
        eax >>= 0x1b;
        ecx = esi + eax;
        ecx &= 0x1f;
        ecx -= eax;
        edx = *((edi + edx*4));
        if (((edx >> ecx) & 1) < 0) {
            caml_alloc_small (2, 0);
            edx = esi + esi + 1;
            *(eax) = edx;
            edx = *((ebp - 0x20));
            *((eax + 4)) = edx;
            *((ebp - 0x20)) = eax;
        }
        eax = *((ebp - 0x1c));
        eax = *((eax + 4));
        if (eax == 1) {
            goto label_0;
        }
        *((ebp - 0x1c)) = eax;
    } while (1);
label_0:
    edx = *((ebp - 0x40));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = *((ebp - 0x20));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064ca0 */
#include <stdint.h>
 
uint32_t decode_sigset (void) {
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x13c5e;
    esi = eax;
    edi = edx;
    *(esp) = edx;
    sigemptyset ();
    if (esi == 1) {
        goto label_0;
    }
    do {
        eax = *(esi);
        eax >>= 1;
        eax = caml_convert_signal_number (eax);
        *((esp + 4)) = eax;
        *(esp) = edi;
        sigaddset ();
        esi = *((esi + 4));
    } while (esi != 1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064d5f */
#include <stdint.h>
 
uint32_t encode_sigset (void) {
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x13b9f;
    *((ebp - 0x4c)) = eax;
    *((ebp - 0x1c)) = 1;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x3c)) = edx;
    edx = ebp - 0x3c;
    *(eax) = edx;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    esi = 1;
    do {
        *((esp + 4)) = esi;
        eax = *((ebp - 0x4c));
        *(esp) = eax;
        eax = sigismember ();
        if (eax > 0) {
            eax = caml_alloc_small (2, 0);
            edi = eax;
            caml_rev_convert_signal_number (esi);
            eax = eax + eax + 1;
            *(edi) = eax;
            eax = *((ebp - 0x1c));
            *((edi + 4)) = eax;
            *((ebp - 0x1c)) = edi;
        }
        esi++;
    } while (esi != 0x41);
    edx = *((ebp - 0x3c));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80656bc */
#include <stdint.h>
 
uint32_t stat_aux (void) {
    uint32_t var_5ch;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x13242;
    *((ebp - 0x5c)) = eax;
    esi = edx;
    eax = *((ebx - 0x18));
    edi = *(eax);
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x28)) = 0;
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x4c)) = edi;
    edx = ebp - 0x4c;
    *(eax) = edx;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 5;
    eax = ebp - 0x1c;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x2c;
    *((ebp - 0x30)) = eax;
    *(fp_stack--) = *((esi + 0x40));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x1c)) = eax;
    *(fp_stack--) = *((esi + 0x48));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x20)) = eax;
    *(fp_stack--) = *((esi + 0x50));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x24)) = eax;
    if (*((ebp - 0x5c)) != 0) {
        eax = *((esi + 0x2c));
        edx = *((esi + 0x30));
        caml_copy_int64 (eax, edx);
    } else {
        eax = *((esi + 0x2c));
        eax = eax + eax + 1;
    }
    *((ebp - 0x28)) = eax;
    eax = caml_alloc_small (0xc, 0);
    *((ebp - 0x2c)) = eax;
    edx = *(esi);
    edx = edx + edx + 1;
    *(eax) = edx;
    eax = *((esi + 0x58));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 4)) = edx;
    eax = *((ebp - 0x2c));
    eax += 8;
    *((ebp - 0x5c)) = eax;
    eax = ebx + 0xb9e4;
    eax = *((esi + 0x10));
    eax &= 0xf000;
    eax = cst_to_constr (0, eax, 7);
    edx = *((ebp - 0x5c));
    *(edx) = eax;
    eax = *((esi + 0x10));
    eax &= 0xfff;
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0xc)) = edx;
    eax = *((esi + 0x14));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x10)) = edx;
    eax = *((esi + 0x18));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x14)) = edx;
    eax = *((esi + 0x1c));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x18)) = edx;
    eax = *((esi + 0x20));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x1c)) = edx;
    edx = *((ebp - 0x28));
    eax = *((ebp - 0x2c));
    *((eax + 0x20)) = edx;
    edx = *((ebp - 0x1c));
    eax = *((ebp - 0x2c));
    *((eax + 0x24)) = edx;
    edx = *((ebp - 0x20));
    eax = *((ebp - 0x2c));
    *((eax + 0x28)) = edx;
    edx = *((ebp - 0x24));
    eax = *((ebp - 0x2c));
    *((eax + 0x2c)) = edx;
    eax = *((ebx - 0x18));
    *(eax) = edi;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806657c */
#include <stdint.h>
 
uint32_t alloc_process_status (void) {
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x1237c;
    edi = eax;
    esi = edx;
    eax = edx;
    eax &= 0x7f;
    *((ebp - 0x4c)) = eax;
    if (eax == 0) {
        eax = caml_alloc_small (1, 0);
        *((ebp - 0x1c)) = eax;
        edx = esi;
        esi = (int32_t) dh;
        edx = esi + esi + 1;
        *(eax) = edx;
    } else {
        if (dl == 0x7f) {
            eax = caml_alloc_small (1, 2);
            *((ebp - 0x4c)) = eax;
            *((ebp - 0x1c)) = eax;
            edx = esi;
            esi = (int32_t) dh;
            caml_rev_convert_signal_number (esi);
            eax = eax + eax + 1;
            edx = *((ebp - 0x4c));
            *(edx) = eax;
        } else {
            eax = caml_alloc_small (1, 1);
            esi = eax;
            *((ebp - 0x1c)) = eax;
            eax = *((ebp - 0x4c));
            caml_rev_convert_signal_number (eax);
            eax = eax + eax + 1;
            *(esi) = eax;
        }
    }
    esi = *((ebx - 0x18));
    eax = *(esi);
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x3c;
    *(esi) = eax;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    caml_alloc_small (2, 0);
    edx = edi + edi + 1;
    *(eax) = edx;
    edx = *((ebp - 0x1c));
    *((eax + 4)) = edx;
    edx = *((ebp - 0x3c));
    *(esi) = edx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066a30 */
#include <stdint.h>
 
uint32_t scanmult (void) {
    int32_t var_2ch;
    int32_t var_20h;
    int32_t var_19h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * format;
    uint32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = eax;
    *((ebp - 0x2c)) = edx;
    *((ebp - 0x19)) = 0x20;
    ebx = ebp - 0x19;
    esi = ebp - 0x20;
    isoc99_sscanf (ebx, "=%u%c", esi);
    isoc99_sscanf (ebx, "=0x%x%c", esi);
    eax = *((ebp - 0x19));
    if (al != 0x4d) {
        if (al != 0x6b) {
            if (al != 0x47) {
                goto label_0;
            }
            eax = *((ebp - 0x20));
            eax <<= 0xa;
            edx = *((ebp - 0x2c));
            *(edx) = eax;
        } else {
        } else {
            eax = *((ebp - 0x20));
            eax <<= 0x14;
            edx = *((ebp - 0x2c));
            *(edx) = eax;
            goto label_1;
        }
        eax = *((ebp - 0x20));
        eax <<= 0x1e;
        edx = *((ebp - 0x2c));
        *(edx) = eax;
        goto label_1;
label_0:
        eax = *((ebp - 0x20));
        edx = *((ebp - 0x2c));
        *(edx) = eax;
    }
label_1:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067232 */
#include <stdint.h>
 
int32_t cons (void) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = eax;
    esi = edx;
    caml_stat_alloc (8);
    *(eax) = ebx;
    *((eax + 4)) = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069f3a */
#include <stdint.h>
 
uint32_t caml_stat_alloc (size_t size) {
    ebx = *((ebp + 8));
    eax = malloc (ebx);
    if (eax == 0) {
        if (ebx == 0) {
            goto label_0;
        }
        caml_raise_out_of_memory ();
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a5c4 */
#include <stdint.h>
 
void malloc (void) {
    malloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066ea9 */
#include <stdint.h>
 
void caml_raise_out_of_memory (void) {
    return caml_raise (loc.caml_bucket_Out_of_memory);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80677c0 */
#include <stdint.h>
 
int32_t caml_iterate_global_roots (void) {
    int32_t var_4h;
    esi = eax;
    ebx = *((edx + 4));
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = *(ebx);
        eax = *(eax);
        void (*esi)(uint32_t, uint32_t) (eax, eax);
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067820 */
#include <stdint.h>
 
int32_t caml_insert_global_root (void) {
    int32_t var_70h;
    int32_t var_6ch;
    int32_t var_5ch;
    *((ebp - 0x70)) = eax;
    ebx = edx;
    edi = eax;
    eax = *((eax + 0x48));
    *((ebp - 0x6c)) = eax;
    ecx = eax;
    edx = edi;
    if (eax < 0) {
        goto label_1;
    }
    esi = ebp - 0x5c;
    do {
label_0:
        eax = *((edx + ecx*4 + 4));
        if (eax == 0) {
            goto label_2;
        }
        if (*(eax) >= ebx) {
            goto label_2;
        }
        edx = eax;
    } while (1);
label_2:
    *((esi + ecx*4)) = edx;
    ecx--;
    if (ecx != -1) {
        goto label_0;
    }
label_1:
    eax = *((edx + 4));
    if (eax != 0) {
        if (*(eax) == ebx) {
            goto label_3;
        }
    }
    eax = *(obj.random_seed) * 0x10dcd;
    eax += 0x6255;
    *(obj.random_seed) = eax;
    edx = eax;
    edx &= 0xc0000000;
    esi = 0;
    if (edx != 0xc0000000) {
        goto label_4;
    }
    do {
        esi++;
        eax <<= 2;
        edx = eax;
        edx &= 0xc0000000;
    } while (edx == 0xc0000000);
label_4:
    if (*((ebp - 0x6c)) >= esi) {
        goto label_5;
    }
    eax = *((ebp - 0x6c));
    eax++;
    if (eax > esi) {
        goto label_6;
    }
    edx = ebp - 0x5c;
    do {
        *((edx + eax*4)) = edi;
        eax++;
    } while (eax <= esi);
label_6:
    eax = *((ebp - 0x70));
    *((eax + 0x48)) = esi;
label_5:
    eax = esi*4 + 8;
    caml_stat_alloc (eax);
    *(eax) = ebx;
    if (esi < 0) {
        goto label_3;
    }
    edx = 0;
    edi = ebp - 0x5c;
    do {
        ecx = *((edi + edx*4));
        ebx = *((ecx + edx*4 + 4));
        *((eax + edx*4 + 4)) = ebx;
        *((ecx + edx*4 + 4)) = eax;
        edx++;
    } while (edx <= esi);
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80679fc */
#include <stdint.h>
 
int32_t caml_delete_global_root (void) {
    int32_t var_6ch;
    int32_t var_5ch;
    ebx = eax;
    ecx = eax;
    eax = *((eax + 0x48));
    *((ebp - 0x6c)) = eax;
    if (eax < 0) {
        goto label_1;
    }
    esi = eax;
    edi = ebp - 0x5c;
    do {
label_0:
        eax = *((ecx + esi*4 + 4));
        if (eax == 0) {
            goto label_2;
        }
        if (*(eax) >= edx) {
            goto label_2;
        }
        ecx = eax;
    } while (1);
label_2:
    *((edi + esi*4)) = ecx;
    esi--;
    if (esi != -1) {
        goto label_0;
    }
label_1:
    ecx = *((ecx + 4));
    if (ecx == 0) {
        goto label_3;
    }
    if (*(ecx) != edx) {
        goto label_3;
    }
    if (*((ebp - 0x6c)) < 0) {
        goto label_4;
    }
    eax = 0;
    edi = ebp - 0x5c;
    do {
        edx = *((edi + eax*4));
        if (*((edx + eax*4 + 4)) == ecx) {
            esi = *((ecx + eax*4 + 4));
            *((edx + eax*4 + 4)) = esi;
        }
        eax++;
    } while (*((ebx + 0x48)) >= eax);
label_4:
    caml_stat_free (ecx);
    eax = *((ebx + 0x48));
    if (eax <= 0) {
        goto label_3;
    }
    if (*((ebx + eax*4 + 4)) != 0) {
        goto label_3;
    }
    do {
        eax--;
        if (eax <= 0) {
            goto label_5;
        }
    } while (*((ebx + eax*4 + 4)) == 0);
    *((ebx + 0x48)) = eax;
    goto label_3;
label_5:
    *((ebx + 0x48)) = eax;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067c37 */
#include <stdint.h>
 
void caml_enter_blocking_section_default (void) {
    *(obj.caml_async_signal_mode) = 1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067c46 */
#include <stdint.h>
 
void caml_leave_blocking_section_default (void) {
    *(obj.caml_async_signal_mode) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067c55 */
#include <stdint.h>
 
int32_t caml_try_leave_blocking_section_default (void) {
    eax = 0;
    tmp_0 = obj.caml_async_signal_mode;
    obj.caml_async_signal_mode = eax;
    eax = tmp_0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80680af */
#include <stdint.h>
 
uint32_t segv_handler (int32_t arg_60h) {
    int32_t var_a4h;
    int32_t var_a0h;
    int32_t var_20h;
    int32_t var_18h;
    struct sigaction * act;
    struct sigaction * oldact;
    ebx = *((ebp + 0x60));
    if ((bl & 3) == 0) {
        eax = ebp - 0x18;
        *((esp + 4)) = eax;
        *(esp) = 3;
        eax = getrlimit64 ();
        if (eax != 0) {
            goto label_0;
        }
        eax = system_stack_top;
        if (ebx >= eax) {
            goto label_0;
        }
        eax -= *((ebp - 0x18));
        eax = eax - 0x2000;
        if (ebx < eax) {
            goto label_0;
        }
        caml_raise_stack_overflow ();
    }
label_0:
    *((ebp - 0xa4)) = 0;
    *((ebp - 0x20)) = 0;
    ebx = ebp - 0xa4;
    eax = ebp - 0xa0;
    *(esp) = eax;
    sigemptyset ();
    sigaction (0xb, ebx, 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a754 */
#include <stdint.h>
 
void getrlimit64 (void) {
    getrlimit64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066e97 */
#include <stdint.h>
 
void caml_raise_stack_overflow (void) {
    return caml_raise (loc.caml_bucket_Stack_overflow);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049e04 */
#include <stdint.h>
 
void sigemptyset (void) {
    sigemptyset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a234 */
#include <stdint.h>
 
void sigaction (void) {
    sigaction ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068139 */
#include <stdint.h>
 
uint32_t handle_signal (int32_t arg_8h) {
    int32_t var_4h;
    ebx = *((ebp + 8));
    if (ebx <= 0x40) {
        eax = uint32_t (*caml_try_leave_blocking_section_hook)() ();
        if (eax != 0) {
            caml_execute_signal (ebx, 1);
            uint32_t (*caml_enter_blocking_section_hook)() ();
        } else {
            caml_record_signal (ebx);
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068370 */
#include <stdint.h>
 
uint32_t allocate_block (int32_t arg_8h) {
    uint32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    *((ebp - 0x10)) = edx;
    edx = *((ebp + 8));
    esi = edx - 4;
    ebx = *(esi);
    ebx >>= 0xa;
    edi = eax + 1;
    if (ebx < edi) {
        edi = ebx;
        edi = ~edi;
        *(obj.caml_fl_cur_size) += edi;
        edi = *(edx);
        *(ecx) = edi;
        edi = caml_fl_merge;
        if (*(obj.caml_fl_merge) == edx) {
            edi = ecx;
        }
        *(obj.caml_fl_merge) = edi;
        *(esi) = 0;
        if (*(obj.caml_allocation_policy) == 1) {
            edi = *((ebp - 0x10));
            edi++;
            esi = flp_size;
            if (edi < esi) {
                if (*((edi*4 + obj.flp)) != edx) {
                    goto label_0;
                }
                *((edi*4 + obj.flp)) = ecx;
                goto label_1;
            }
label_0:
            esi--;
            if (esi != *((ebp - 0x10))) {
                goto label_2;
            }
            edi = 0;
            if (ecx == 0x8084668) {
                ecx = edi;
            }
            *(obj.beyond) = ecx;
            *(obj.flp_size) = esi;
        } else {
            *(obj.caml_fl_cur_size) -= eax;
            edi = ebx;
            edi -= eax;
            edi <<= 0xa;
            edi += 0x200;
            *(esi) = edi;
        }
label_2:
        if (*(obj.caml_allocation_policy) != 0) {
            goto label_1;
        }
        *(obj.fl_prev) = "hF\b\b";
    }
label_1:
    ebx -= eax;
    eax = edx + ebx*4;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806845b */
#include <stdint.h>
 
void truncate_flp (void) {
    if (eax != 0x8084668) {
        edx = flp_size;
        if (edx <= 0) {
            goto label_0;
        }
        edx--;
        ecx = *((edx*4 + obj.flp));
        esi = flp;
        if (eax <= *(ecx)) {
            goto label_1;
        }
        goto label_0;
    }
    *(obj.flp_size) = 0;
    *(obj.beyond) = 0;
    goto label_2;
    do {
        edx = ecx;
label_1:
        if (edx <= 0) {
            goto label_3;
        }
        ecx = edx - 1;
        ebx = *((esi + ecx*4));
    } while (eax <= *(ebx));
    *(obj.flp_size) = edx;
    goto label_0;
label_3:
    *(obj.flp_size) = edx;
label_0:
    if (eax <= *(obj.beyond)) {
        *(obj.beyond) = 0;
    }
label_2:
    esi = ebx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068c40 */
#include <stdint.h>
 
int32_t clip_heap_chunk_size (void) {
    edx = 0x2000;
    if (eax <= 0x1fff) {
        eax = edx;
    }
    eax += 0xfff;
    eax &= 0xfffff000;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068d87 */
#include <stdint.h>
 
void start_cycle (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (1, "Starting new major GC cycle\n", 0);
    caml_darken_all_roots ();
    *(obj.caml_gc_phase) = 0;
    *(obj.caml_gc_subphase) = 0xa;
    *(obj.markhp) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067526 */
#include <stdint.h>
 
void caml_darken_all_roots (void) {
    caml_do_roots (sym.caml_darken);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067405 */
#include <stdint.h>
 
uint32_t caml_do_roots (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    edi = caml_globals;
    if (edi == 0) {
        goto label_3;
    }
    *((ebp - 0x1c)) = 0;
    goto label_4;
    do {
label_0:
        eax = edi + eax*4;
        eax = *(eax);
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (ebx < edx);
label_1:
    *((ebp - 0x1c))++;
    eax = *((ebp - 0x1c));
    edx = caml_globals;
    edi = *((edx + eax*4));
    if (edi == 0) {
        goto label_3;
    }
label_4:
    esi = edi - 4;
    edx = *(esi);
    edx >>= 0xa;
    eax = 0;
    ebx = 0;
    if (edx != 0) {
        goto label_0;
    }
    goto label_1;
label_3:
    eax = caml_dyn_globals;
    *((ebp - 0x1c)) = eax;
    if (eax == 0) {
        goto label_5;
    }
label_2:
    edx = *((ebp - 0x1c));
    edi = *(edx);
    esi = edi - 4;
    eax = *(esi);
    eax >>= 0xa;
    if (eax == 0) {
        goto label_6;
    }
    eax = 0;
    ebx = 0;
    do {
        eax = edi + eax*4;
        eax = *(eax);
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (edx > ebx);
label_6:
    eax = *((ebp - 0x1c));
    eax = *((eax + 4));
    *((ebp - 0x1c)) = eax;
    if (eax != 0) {
        goto label_2;
    }
label_5:
    if (*(obj.caml_frame_descriptors) == 0) {
        caml_init_frame_descriptors ();
    }
    eax = caml_local_roots;
    eax = caml_gc_regs;
    eax = caml_last_return_address;
    eax = caml_bottom_of_stack;
    edx = *((ebp + 8));
    caml_do_local_roots (eax, eax, eax);
    eax = *((ebp + 8));
    caml_scan_global_roots (eax);
    edx = *((ebp + 8));
    caml_final_do_strong_roots (edx);
    eax = caml_scan_roots_hook;
    if (eax != 0) {
        edx = *((ebp + 8));
        void (*eax)(uint32_t) (edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068dce */
#include <stdint.h>
 
int32_t realloc_gray_vals (void) {
    char * size;
    int32_t var_8h;
    edx = gray_vals_size;
    eax = caml_stat_heap_size;
    ecx = eax + 0x7f;
    __asm ("cmovs eax, ecx");
    eax >>= 7;
    if (eax > edx) {
        edx <<= 2;
        edx >>= 9;
        caml_gc_message (8, "Growing gray_vals to %luk bytes\n", edx);
        eax = gray_vals_size;
        eax <<= 3;
        eax = gray_vals;
        eax = realloc (eax, eax);
        if (eax == 0) {
            caml_gc_message (8, "No room for growing gray_vals\n", 0);
            eax = gray_vals;
            *(obj.gray_vals_cur) = eax;
            *(obj.heap_is_pure) = 0;
        } else {
            *(obj.gray_vals) = eax;
        }
        edx = gray_vals_size;
        ecx = eax + edx*4;
        *(obj.gray_vals_cur) = ecx;
        ecx = edx + edx;
        *(obj.gray_vals_size) = ecx;
        eax = eax + edx*8;
        *(obj.gray_vals_end) = eax;
    } else {
        edx >>= 1;
        edx <<= 2;
        edx += *(obj.gray_vals);
        *(obj.gray_vals_cur) = edx;
        *(obj.heap_is_pure) = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068ea3 */
#include <stdint.h>
 
int32_t mark_slice (void) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    uint32_t var_1ch;
    char * var_4h;
    int32_t var_8h;
    *((ebp - 0x24)) = eax;
    caml_gc_message (ebx, esi, edi);
    eax = caml_gc_subphase;
    caml_gc_message (0x40, "Subphase = %ld\n", eax);
    esi = gray_vals_cur;
    if (*((ebp - 0x24)) <= 0) {
        goto label_2;
    }
label_1:
    if (*(obj.gray_vals) >= esi) {
        goto label_3;
    }
    esi -= 4;
    edi = *(esi);
    edx = edi - 4;
    eax = *(edx);
    ecx = *(edx);
    ch |= 3;
    *(edx) = ecx;
    edx = eax;
    edx >>= 0xa;
    *((ebp - 0x1c)) = edx;
    if (al > 0xfa) {
        goto label_4;
    }
    if (edx == 0) {
        goto label_4;
    }
    ebx = 0;
    *((ebp - 0x34)) = esi;
    do {
        eax = *((edi + ebx*4));
        if ((al & 1) == 0) {
            esi = eax;
            ecx = eax;
            ecx >>= 0x17;
            edx = eax;
            edx >>= 0xc;
            edx &= 0x7ff;
            ecx = *((ecx*4 + obj.caml_page_table));
            if ((*((ecx + edx)) & 1) == 0) {
                goto label_5;
            }
            edx = *((eax - 4));
            ecx = (int32_t) dl;
            if (ecx == 0xfa) {
                ecx = *(eax);
                *((ebp - 0x20)) = ecx;
                if ((cl & 1) == 0) {
                    *((ebp - 0x2c)) = ecx;
                    esi = ecx;
                    esi >>= 0x17;
                    ecx >>= 0xc;
                    ecx &= 0x7ff;
                    esi = *((esi*4 + obj.caml_page_table));
                    if ((*((esi + ecx)) & 7) == 0) {
                        goto label_6;
                    }
                    ecx = *((ebp - 0x2c));
                    esi = *((ecx - 4));
                    ecx = esi;
                    if (cl == 0xfa) {
                        goto label_6;
                    }
                    if (cl == 0xf6) {
                        goto label_6;
                    }
                    if (cl == 0xfd) {
                        goto label_6;
                    }
                }
                esi = *((ebp - 0x20));
                *((edi + ebx*4)) = esi;
            } else {
                if (ecx != 0xf9) {
                    goto label_6;
                }
                edx >>= 0xa;
                eax = edx*4;
                esi -= eax;
                eax = esi;
                edx = *((esi - 4));
            }
label_6:
            if ((dh & 3) != 0) {
                goto label_5;
            }
            dh &= 0xfc;
            dh |= 1;
            *((eax - 4)) = edx;
            edx = *((ebp - 0x34));
            *(edx) = eax;
            edx += 4;
            *((ebp - 0x34)) = edx;
            if (edx < *(obj.gray_vals_end)) {
                goto label_5;
            }
            *(obj.gray_vals_cur) = edx;
            realloc_gray_vals ();
            ecx = gray_vals_cur;
            *((ebp - 0x34)) = ecx;
        }
label_5:
        ebx++;
    } while (*((ebp - 0x1c)) > ebx);
    esi = *((ebp - 0x34));
label_4:
    eax = *((ebp - 0x1c));
    eax = ~eax;
    *((ebp - 0x24)) += eax;
    goto label_7;
label_3:
    eax = markhp;
    if (eax != 0) {
        if (eax == *(obj.limit)) {
            eax = chunk;
            eax = *((eax - 4));
            *(obj.chunk) = eax;
            if (eax == 0) {
                *(obj.markhp) = 0;
                goto label_7;
            }
            *(obj.markhp) = eax;
            eax += *((eax - 8));
            *(obj.limit) = eax;
            goto label_7;
        }
        edx = *(eax);
        edx &= 0x300;
        if (edx == 0x100) {
            eax += 4;
            *(esi) = eax;
            esi += 4;
        }
        eax = markhp;
        edx = *(eax);
        edx >>= 0xa;
        eax = eax + edx*4 + 4;
        *(obj.markhp) = eax;
        goto label_7;
    }
    if (*(obj.heap_is_pure) == 0) {
        *(obj.heap_is_pure) = 1;
        eax = caml_heap_start;
        *(obj.chunk) = eax;
        *(obj.markhp) = eax;
        eax += *((eax - 8));
        *(obj.limit) = eax;
        goto label_7;
    }
    eax = caml_gc_subphase;
    if (eax != 0xb) {
        if (eax <= 0xb) {
            if (eax != 0xa) {
                goto label_7;
            }
        } else {
            if (eax == 0xc) {
                goto label_8;
            }
            if (eax != 0xd) {
                goto label_7;
            }
            goto label_9;
        }
        *(obj.caml_gc_subphase) = 0xb;
        *(obj.weak_prev) = 0x808b014;
        goto label_7;
    }
    eax = weak_prev;
    eax = *(eax);
    *((ebp - 0x34)) = eax;
    if (eax == 0) {
        goto label_10;
    }
    *((ebp - 0x28)) = eax;
    eax = *((eax - 4));
    eax >>= 0xa;
    *((ebp - 0x30)) = eax;
    if (eax <= 1) {
        goto label_11;
    }
    *((ebp - 0x20)) = 1;
    *((ebp - 0x38)) = esi;
label_0:
    edx = *((ebp - 0x20));
    ecx = *((ebp - 0x28));
    eax = *((ecx + edx*4));
    edi = caml_weak_none;
    if (eax == edi) {
        goto label_12;
    }
    if ((al & 1) != 0) {
        goto label_12;
    }
    ecx = eax;
    ecx >>= 0x17;
    edx = eax;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 1) == 0) {
        goto label_12;
    }
    edx = eax - 4;
    if (*(edx) != 0xfa) {
        goto label_13;
    }
    eax = *(eax);
    if ((al & 1) == 0) {
        goto label_14;
    }
    goto label_13;
    do {
        if ((al & 1) != 0) {
            goto label_12;
        }
        ecx = *((esi*4 + obj.caml_page_table));
        if ((*((ecx + ebx)) & 1) == 0) {
            goto label_12;
        }
        esi = *((ebp - 0x1c));
        if (*(esi) != 0xfa) {
            goto label_13;
        }
        eax = *(eax);
        if ((al & 1) != 0) {
            goto label_13;
        }
label_14:
        *((ebp - 0x2c)) = edx;
        edx = eax;
        esi = eax;
        esi >>= 0x17;
        ebx = eax;
        ebx >>= 0xc;
        ebx &= 0x7ff;
        ecx = *((esi*4 + obj.caml_page_table));
        if ((*((ecx + ebx)) & 7) == 0) {
            goto label_15;
        }
        edx -= 4;
        *((ebp - 0x1c)) = edx;
        ecx = *(edx);
        if (cl == 0xfa) {
            goto label_15;
        }
        if (cl == 0xf6) {
            goto label_15;
        }
        if (cl == 0xfd) {
            goto label_15;
        }
        edi = *((ebp - 0x20));
        ecx = *((ebp - 0x28));
        *((ecx + edi*4)) = eax;
        edi = caml_weak_none;
    } while (eax != edi);
    goto label_12;
label_15:
    edx = *((ebp - 0x2c));
label_13:
    if ((*(edx) & 0x300) == 0) {
        esi = *((ebp - 0x20));
        eax = *((ebp - 0x28));
        *((eax + esi*4)) = edi;
    }
label_12:
    *((ebp - 0x20))++;
    edx = *((ebp - 0x30));
    if (*((ebp - 0x20)) != edx) {
        goto label_0;
    }
    esi = *((ebp - 0x38));
label_11:
    ecx = *((ebp - 0x34));
    *(obj.weak_prev) = ecx;
    eax = *((ebp - 0x30));
    eax = ~eax;
    *((ebp - 0x24)) += eax;
    goto label_7;
label_10:
    *(obj.caml_gc_subphase) = 0xc;
    *(obj.weak_prev) = 0x808b014;
    goto label_7;
label_8:
    edx = weak_prev;
    eax = *(edx);
    if (eax != 0) {
        if ((*((eax - 4)) & 0x300) == 0) {
            eax = *(eax);
            *(edx) = eax;
        } else {
            *(obj.weak_prev) = eax;
        }
        *((ebp - 0x24))--;
    } else {
        *(obj.gray_vals_cur) = esi;
        caml_final_update ();
        esi = gray_vals_cur;
        *(obj.caml_gc_subphase) = 0xd;
        goto label_7;
label_9:
        *(obj.gray_vals_cur) = esi;
        eax = caml_heap_start;
        *(obj.caml_gc_sweep_hp) = eax;
        caml_fl_init_merge ();
        *(obj.caml_gc_phase) = 1;
        eax = caml_heap_start;
        *(obj.chunk) = eax;
        *(obj.caml_gc_sweep_hp) = eax;
        eax += *((eax - 8));
        *(obj.limit) = eax;
        eax = caml_fl_cur_size;
        *(obj.caml_fl_size_at_phase_change) = eax;
        goto label_2;
    }
label_7:
    if (*((ebp - 0x24)) > 0) {
        goto label_1;
    }
label_2:
    *(obj.gray_vals_cur) = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069380 */
#include <stdint.h>
 
int32_t sweep_slice (void) {
    char * var_4h;
    int32_t var_8h;
    esi = eax;
    caml_gc_message (ebx, esi, edi);
    if (esi <= 0) {
        goto label_0;
    }
    do {
        ebx = caml_gc_sweep_hp;
        if (ebx < *(obj.limit)) {
            ecx = ebx;
            eax = *(ebx);
            edx = *(ebx);
            edx >>= 0xa;
            edi = edx;
            edi = ~edi;
            esi += edi;
            edx = ebx + edx*4 + 4;
            *(obj.caml_gc_sweep_hp) = edx;
            edx = eax;
            edx &= 0x300;
            if (edx != 0) {
                if (edx != 0x200) {
                    goto label_1;
                }
            } else {
                if (al == 0xff) {
                    eax = *((ebx + 4));
                    eax = *((eax + 4));
                    if (eax == 0) {
                        goto label_2;
                    }
                    ecx += 4;
                    void (*eax)(uint32_t) (ecx);
                }
label_2:
                ebx += 4;
                eax = caml_fl_merge_block (ebx);
                *(obj.caml_gc_sweep_hp) = eax;
                goto label_3;
            }
            ebx += 4;
            *(obj.caml_fl_merge) = ebx;
            goto label_3;
label_1:
            ah &= 0xfc;
            *(ebx) = eax;
        } else {
            eax = chunk;
            eax = *((eax - 4));
            *(obj.chunk) = eax;
            if (eax == 0) {
                *(obj.caml_stat_major_collections)++;
                *(obj.caml_gc_phase) = 2;
                goto label_0;
            }
            *(obj.caml_gc_sweep_hp) = eax;
            eax += *((eax - 8));
            *(obj.limit) = eax;
        }
label_3:
    } while (esi > 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80697ac */
#include <stdint.h>
 
void clear_table (void) {
    edx = *(eax);
    *((eax + 0xc)) = edx;
    edx = *((eax + 8));
    *((eax + 0x10)) = edx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069be5 */
#include <stdint.h>
 
int32_t reset_table (void) {
    ebx = eax;
    *((eax + 0x14)) = 0;
    *((eax + 0x18)) = 0;
    eax = *(eax);
    if (eax != 0) {
        caml_stat_free (eax);
    }
    *((ebx + 4)) = 0;
    *((ebx + 0x10)) = 0;
    *((ebx + 8)) = 0;
    *((ebx + 0xc)) = 0;
    *(ebx) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069f11 */
#include <stdint.h>
 
int32_t caml_stat_free (void * ptr) {
    eax = *((ebp + 8));
    free (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a157 */
#include <stdint.h>
 
uint32_t caml_page_table_modify (void) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    size_t size;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = eax;
    edi = edx;
    *((ebp - 0x1c)) = ecx;
    esi = eax;
    esi >>= 0x17;
    if (*((esi*4 + obj.caml_page_table)) == 0x8087ae0) {
        eax = calloc (0x800, 1);
        edx = eax;
        eax = 0xffffffff;
        if (edx == 0) {
            goto label_0;
        }
        *((esi*4 + obj.caml_page_table)) = edx;
    }
    ebx >>= 0xc;
    ebx &= 0x7ff;
    ebx += *((esi*4 + obj.caml_page_table));
    eax = edi;
    eax = ~eax;
    al &= *(ebx);
    al |= *((ebp - 0x1c));
    *(ebx) = al;
    eax = 0;
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049fd4 */
#include <stdint.h>
 
void calloc (void) {
    calloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a9a0 */
#include <stdint.h>
 
int32_t compare_free_stack (void) {
    eax = compare_stack;
    if (eax != obj.compare_stack_init) {
        free (eax);
        *(obj.compare_stack) = 0x80882e0;
        *(obj.compare_stack_limit) = 0x8088ee0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a9d0 */
#include <stdint.h>
 
void compare_stack_overflow (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (4, "Stack overflow in structural comparison\n", 0);
    compare_free_stack ();
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a9fc */
#include <stdint.h>
 
int32_t compare_val (void) {
    int32_t var_3ch;
    size_t size;
    uint32_t var_34h;
    void * var_30h;
    int32_t var_2ch;
    uint32_t var_28h;
    uint32_t var_24h;
    int32_t var_20h;
    void * s1;
    char * s2;
    size_t n;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x24)) = ecx;
    ebx = compare_stack;
    do {
label_0:
        eax = *((ebp - 0x20));
        al = (*((ebp - 0x1c)) == eax) ? 1 : 0;
        if (*((ebp - 0x1c)) == eax) {
            if (*((ebp - 0x24)) != 0) {
                goto label_1;
            }
        }
        if ((*((ebp - 0x1c)) & 1) == 0) {
            goto label_2;
        }
        if (al != 0) {
            goto label_1;
        }
        if ((*((ebp - 0x20)) & 1) != 0) {
            eax = *((ebp - 0x1c));
            eax >>= 1;
            ecx = *((ebp - 0x20));
            ecx >>= 1;
            eax -= ecx;
            goto label_3;
        }
        ecx = *((ebp - 0x20));
        edx = *((ebp - 0x20));
        edx >>= 0x17;
        eax = ecx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 7) == 0) {
            goto label_4;
        }
        eax = *((ecx - 4));
        if (al != 0xfa) {
            if (al != 0xff) {
                goto label_4;
            }
        } else {
            edx = *((ebp - 0x20));
            edx = *(edx);
            *((ebp - 0x20)) = edx;
        } while (1);
    }
    ecx = *((ebp - 0x20));
    eax = *(ecx);
    eax = *((eax + 0x18));
    if (eax == 0) {
        goto label_4;
    }
    *(obj.caml_compare_unordered) = 0;
    edx = *((ebp - 0x1c));
    eax = void (*eax)(uint32_t, uint32_t) (edx, ecx);
    if (*(obj.caml_compare_unordered) != 0) {
        if (*((ebp - 0x24)) == 0) {
            goto label_5;
        }
    }
    if (eax == 0) {
        goto label_1;
    }
    goto label_3;
label_2:
    if ((*((ebp - 0x20)) & 1) != 0) {
        ecx = *((ebp - 0x1c));
        edx = *((ebp - 0x1c));
        edx >>= 0x17;
        eax = ecx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 7) == 0) {
            goto label_6;
        }
        eax = *((ecx - 4));
        if (al != 0xfa) {
            if (al != 0xff) {
                goto label_6;
            }
        } else {
            ecx = *((ebp - 0x1c));
            ecx = *(ecx);
            *((ebp - 0x1c)) = ecx;
            goto label_0;
        }
        edx = *((ebp - 0x1c));
        eax = *(edx);
        eax = *((eax + 0x18));
        if (eax == 0) {
            goto label_6;
        }
        *(obj.caml_compare_unordered) = 0;
        ecx = *((ebp - 0x20));
        eax = void (*eax)(uint32_t, uint32_t) (edx, ecx);
        if (*(obj.caml_compare_unordered) != 0) {
            if (*((ebp - 0x24)) == 0) {
                goto label_5;
            }
        }
        if (eax == 0) {
            goto label_1;
        }
        goto label_3;
    }
    edx = *((ebp - 0x1c));
    *((ebp - 0x28)) = edx;
    ecx = edx;
    ecx >>= 0x17;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 7) != 0) {
        ecx = *((ebp - 0x20));
        *((ebp - 0x2c)) = ecx;
        ecx >>= 0x17;
        edx = *((ebp - 0x20));
        edx >>= 0xc;
        edx &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
        if ((*((ecx + edx)) & 7) != 0) {
            goto label_7;
        }
    }
    if (al != 0) {
        goto label_1;
    }
    edx = *((ebp - 0x1c));
    edx >>= 1;
    eax = *((ebp - 0x20));
    eax >>= 1;
    edx -= eax;
    eax = edx;
    goto label_3;
label_7:
    edi = *((ebp - 0x28));
    edi -= 4;
    esi = *(edi);
    ecx = esi;
    edx = (int32_t) cl;
    ecx = *((ebp - 0x2c));
    ecx -= 4;
    *((ebp - 0x30)) = ecx;
    ecx = *(ecx);
    *((ebp - 0x34)) = cl;
    if (edx == 0xfa) {
        eax = *((ebp - 0x1c));
        eax = *(eax);
        *((ebp - 0x1c)) = eax;
        goto label_0;
    }
    ecx = *((ebp - 0x34));
    if (ecx == 0xfa) {
        edx = *((ebp - 0x20));
        edx = *(edx);
        *((ebp - 0x20)) = edx;
        goto label_0;
    }
    if (edx != ecx) {
        edx -= ecx;
        eax = edx;
        goto label_3;
    }
    edx = esi + 9;
    if (dl > 8) {
        goto label_8;
    }
    edx = (int32_t) dl;
    /* switch table (9 cases) at 0x8076c0c */
    if (al != 0) {
        goto label_1;
    }
    ecx = *((ebp - 0x1c));
    eax = caml_string_length (ecx);
    esi = eax;
    eax = *((ebp - 0x20));
    eax = caml_string_length (eax);
    edi = eax;
    eax = esi;
    if (eax <= esi) {
        eax = edi;
    }
    edx = *((ebp - 0x20));
    ecx = *((ebp - 0x1c));
    eax = memcmp (ecx, edx, eax);
    if (eax < 0) {
        goto label_4;
    }
    if (eax > 0) {
        goto label_6;
    }
    if (esi == edi) {
        goto label_1;
    }
    eax = esi;
    eax -= edi;
    goto label_3;
    eax = *((ebp - 0x1c));
    *(fp_stack--) = *(eax);
    edx = *((ebp - 0x20));
    *(fp_stack--) = *(edx);
    if (fp_stack[0] > fp_stack[1]) {
        goto label_9;
    }
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_10;
    }
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_11;
        }
    }
    if (*((ebp - 0x24)) == 0) {
        goto label_12;
    }
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_13;
        }
    }
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        goto label_1;
    }
    if (fp_stack[0] != fp_stack[0]) {
        goto label_4;
    }
    goto label_1;
    edx = *(edi);
    edx >>= 0xb;
    ecx = *((ebp - 0x30));
    eax = *(ecx);
    eax >>= 0xb;
    if (edx == eax) {
        if (edx == 0) {
            goto label_1;
        }
        eax = *((ebp - 0x28));
        *(fp_stack--) = *(eax);
        ecx = *((ebp - 0x2c));
        *(fp_stack--) = *(ecx);
        if (fp_stack[0] > fp_stack[1]) {
            goto label_14;
        }
        fp_tmp_1 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
        if (fp_stack[0] > fp_stack[1]) {
            goto label_15;
        }
        eax = 0;
        esi = *((ebp - 0x28));
        goto label_16;
    }
    edx -= eax;
    eax = edx;
    goto label_3;
    do {
        *(fp_stack--) = *((esi + eax*8));
        *(fp_stack--) = *((ecx + eax*8));
        if (fp_stack[0] > fp_stack[1]) {
            goto label_17;
        }
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
        if (fp_stack[0] > fp_stack[1]) {
            goto label_18;
        }
label_16:
        if (fp_stack[0] != fp_stack[1]) {
            if (fp_stack[0] == fp_stack[1]) {
                goto label_19;
            }
        }
        if (*((ebp - 0x24)) == 0) {
            goto label_20;
        }
        fp_stack--;
        if (fp_stack[0] != fp_stack[0]) {
            if (fp_stack[0] == fp_stack[0]) {
                goto label_21;
            }
        }
        fp_stack--;
        if (fp_stack[0] != fp_stack[0]) {
            if (fp_stack[0] == fp_stack[0]) {
                goto label_4;
            }
            goto label_22;
label_19:
            fp_stack++;
            fp_stack++;
        }
label_22:
        eax++;
    } while (edx > eax);
    goto label_1;
    compare_free_stack ();
    caml_invalid_argument ("equal: abstract value");
    compare_free_stack ();
    caml_invalid_argument ("equal: functional value");
    eax = *((ebp - 0x28));
    edx = *((eax + 4));
    edx >>= 1;
    ecx = *((ebp - 0x2c));
    eax = *((ecx + 4));
    eax >>= 1;
    if (edx != eax) {
        edx -= eax;
        eax = edx;
        goto label_3;
        eax = *((ebp - 0x1c));
        ecx = *(eax);
        edx = *((ebp - 0x20));
        eax = *(edx);
        edx = *((eax + 8));
        if (edx != *((ecx + 8))) {
            edx = *(ecx);
            eax = *(eax);
            eax = strcmp (edx, eax);
            if (eax >= 0) {
                goto label_6;
            }
            goto label_4;
        }
        if (edx == 0) {
            compare_free_stack ();
            caml_invalid_argument ("equal: abstract value");
        }
        *(obj.caml_compare_unordered) = 0;
        ecx = *((ebp - 0x20));
        eax = *((ebp - 0x1c));
        eax = void (*edx)(uint32_t, uint32_t) (eax, ecx);
        if (*(obj.caml_compare_unordered) != 0) {
            if (*((ebp - 0x24)) == 0) {
                goto label_5;
            }
        }
        if (eax == 0) {
            goto label_1;
        }
        goto label_3;
label_8:
        eax = *(edi);
        eax >>= 0xa;
        *((ebp - 0x34)) = eax;
        edx = *((ebp - 0x30));
        eax = *(edx);
        eax >>= 0xa;
        if (*((ebp - 0x34)) != eax) {
            ecx = *((ebp - 0x34));
            ecx -= eax;
            eax = ecx;
            goto label_3;
        }
        if (*((ebp - 0x34)) == 0) {
            goto label_1;
        }
        if (*((ebp - 0x34)) > 1) {
            ebx += 0xc;
            eax = compare_stack_limit;
            if (ebx >= eax) {
                edx = compare_stack;
                *((ebp - 0x3c)) = edx;
                eax -= edx;
                eax >>= 2;
                eax *= 0xaaaaaaab;
                eax += eax;
                *((ebp - 0x38)) = eax;
                if (eax > 0xfffff) {
                    eax = compare_stack_overflow ();
                }
                edx = compare_stack;
                if (edx == obj.compare_stack_init) {
                    eax = *((ebp - 0x38)) * 0xc;
                    eax = malloc (eax);
                    *((ebp - 0x30)) = eax;
                    if (eax == 0) {
                        eax = compare_stack_overflow ();
                    }
                    ecx = 0x300;
                    edi = *((ebp - 0x30));
                    esi = compare_stack_init;
                    *(es:edi) = *(esi);
                    ecx--;
                    esi += 4;
                    es:edi += 4;
                } else {
                    eax = *((ebp - 0x38)) * 0xc;
                    eax = realloc (edx, eax);
                    *((ebp - 0x30)) = eax;
                    if (eax != 0) {
                        goto label_23;
                    }
                    eax = compare_stack_overflow ();
                }
label_23:
                ecx = *((ebp - 0x30));
                *(obj.compare_stack) = ecx;
                eax = *((ebp - 0x38)) * 0xc;
                eax += ecx;
                *(obj.compare_stack_limit) = eax;
                ebx -= *((ebp - 0x3c));
                ebx &= 0xfffffffc;
                ebx += ecx;
            }
            eax = *((ebp - 0x28));
            eax += 4;
            *(ebx) = eax;
            eax = *((ebp - 0x2c));
            eax += 4;
            *((ebx + 4)) = eax;
            eax = *((ebp - 0x34));
            eax--;
            *((ebx + 8)) = eax;
        }
        eax = *((ebp - 0x1c));
        eax = *(eax);
        *((ebp - 0x1c)) = eax;
        edx = *((ebp - 0x20));
        edx = *(edx);
        *((ebp - 0x20)) = edx;
        goto label_0;
label_11:
        fp_stack++;
        fp_stack++;
    }
label_1:
    if (ebx == *(obj.compare_stack)) {
        eax = 0;
    } else {
        eax = *(ebx);
        ecx = *(eax);
        *((ebp - 0x1c)) = ecx;
        eax += 4;
        *(ebx) = eax;
        eax = *((ebx + 4));
        edx = *(eax);
        *((ebp - 0x20)) = edx;
        eax += 4;
        *((ebx + 4)) = eax;
        eax = *((ebx + 8));
        eax--;
        *((ebx + 8)) = eax;
        edx = ebx - 0xc;
        if (eax == 0) {
            ebx = edx;
        }
        goto label_0;
label_12:
        fp_stack++;
        fp_stack++;
        goto label_5;
label_20:
        fp_stack++;
        fp_stack++;
label_5:
        eax = 0x80000000;
        goto label_3;
label_9:
        fp_stack++;
        fp_stack++;
        goto label_4;
label_14:
        fp_stack++;
        fp_stack++;
        goto label_4;
label_17:
        fp_stack++;
        fp_stack++;
label_4:
        eax = 0xffffffff;
        goto label_3;
label_10:
        fp_stack++;
        fp_stack++;
        goto label_6;
label_13:
        fp_stack++;
        goto label_6;
label_15:
        fp_stack++;
        fp_stack++;
        goto label_6;
label_18:
        fp_stack++;
        fp_stack++;
        goto label_6;
label_21:
        fp_stack++;
label_6:
        eax = 1;
    }
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b1b0 */
#include <stdint.h>
 
int32_t parse_sign_and_base (void) {
    *(ecx) = 1;
    if (*(eax) == 0x2d) {
        *(ecx) = 0xffffffff;
        eax++;
    }
    *(edx) = 0xa;
    if (*(eax) == 0x30) {
        ecx = *((eax + 1));
        ecx -= 0x42;
        if (cl > 0x36) {
            goto label_0;
        }
        ecx = (int32_t) cl;
        /* switch table (55 cases) at 0x8076c30 */
        *(edx) = 0x10;
        eax += 2;
        goto label_0;
        *(edx) = 8;
        eax += 2;
        goto label_0;
        *(edx) = 2;
        eax += 2;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b209 */
#include <stdint.h>
 
uint32_t parse_digit (void) {
    edx = eax;
    ecx = edx - 0x30;
    if (cl <= 9) {
        edx = (int32_t) al;
        eax = edx - 0x30;
    } else {
        ecx = eax - 0x41;
        if (cl <= 5) {
            edx = (int32_t) al;
            eax = edx - 0x37;
        } else {
            ecx = eax - 0x61;
            eax = 0xffffffff;
            if (cl > 5) {
                goto label_0;
            }
            eax = (int32_t) dl;
            eax -= 0x57;
        }
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b266 */
#include <stdint.h>
 
int32_t int32_cmp (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    eax = *((ebp + 0xc));
    edx = *((eax + 4));
    al = (ecx > edx) ? 1 : 0;
    eax = (int32_t) al;
    dl = (ecx < edx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b289 */
#include <stdint.h>
 
int32_t int32_hash (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b2cc */
#include <stdint.h>
 
int32_t int64_cmp (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    esi = *((edx + 4));
    ecx = *((edx + 8));
    edi = *((eax + 4));
    edx = *((eax + 8));
    eax = 1;
    if (ecx <= edx) {
        if (ecx >= edx) {
            if (esi > edi) {
                goto label_0;
            }
        }
        eax = 0;
    }
label_0:
    ebx = 1;
    if (ecx >= edx) {
        if (ecx <= edx) {
            if (esi < edi) {
                goto label_1;
            }
        }
        ebx = 0;
    }
label_1:
    eax -= ebx;
    ebx = *(esp);
    esi = *((esp + 4));
    edi = *((esp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b328 */
#include <stdint.h>
 
int32_t int64_hash (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b3a2 */
#include <stdint.h>
 
int32_t nativeint_cmp (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    eax = *((ebp + 0xc));
    edx = *((eax + 4));
    al = (ecx > edx) ? 1 : 0;
    eax = (int32_t) al;
    dl = (ecx < edx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b3c5 */
#include <stdint.h>
 
int32_t nativeint_hash (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b408 */
#include <stdint.h>
 
uint32_t int32_deserialize (int32_t arg_8h) {
    eax = caml_deserialize_sint_4 ();
    edx = *((ebp + 8));
    *(edx) = eax;
    eax = 4;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fa4e */
#include <stdint.h>
 
uint32_t caml_deserialize_sint_4 (void) {
    ecx = intern_src;
    edx = ecx + 4;
    *(obj.intern_src) = edx;
    ebx = *((edx - 1));
    eax = *(ecx);
    eax <<= 0x18;
    eax = ebx + eax;
    ecx = *((edx - 3));
    ecx <<= 0x10;
    eax += ecx;
    edx = *((edx - 2));
    edx <<= 8;
    eax += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b41f */
#include <stdint.h>
 
uint32_t nativeint_deserialize (int32_t arg_8h) {
    eax = caml_deserialize_uint_1 ();
    if (eax != 1) {
        if (eax != 2) {
            goto label_0;
        }
    } else {
        eax = caml_deserialize_sint_4 ();
        edx = *((ebp + 8));
        *(edx) = eax;
        goto label_1;
    }
    caml_deserialize_error (0x8076d0c);
label_0:
    caml_deserialize_error ("input_value: ill-formed native integer");
label_1:
    eax = 4;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b463 */
#include <stdint.h>
 
int32_t nativeint_serialize (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    caml_serialize_int_1 (ebx);
    caml_serialize_int_4 (ebx);
    eax = *((ebp + 0xc));
    *(eax) = 4;
    eax = *((ebp + 0x10));
    *(eax) = 8;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ee94 */
#include <stdint.h>
 
int32_t caml_serialize_int_1 (int32_t arg_8h) {
    eax = extern_ptr;
    eax++;
    if (*(obj.extern_limit) < eax) {
        eax = 1;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = *((ebp + 8));
    *(eax) = dl;
    eax++;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806eaf6 */
#include <stdint.h>
 
uint32_t grow_extern_output (void) {
    if (*(obj.extern_userprovided_output) != 0) {
        extern_replay_trail ();
        eax = caml_failwith ("Marshal.to_buffer: buffer overflow");
    }
    ecx = extern_ptr;
    edx = extern_output_block;
    *((edx + 4)) = ecx;
    esi = 0;
    if (eax >= 0xfd3) {
        esi = eax;
    }
    eax = esi + 0x1fac;
    eax = malloc (eax);
    ebx = eax;
    if (eax == 0) {
        extern_out_of_memory ();
    }
    eax = extern_output_block;
    *(eax) = ebx;
    *(obj.extern_output_block) = ebx;
    *(ebx) = 0;
    eax = ebx + 8;
    *(obj.extern_ptr) = eax;
    eax = ebx + esi + 0x1fac;
    *(obj.extern_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ee02 */
#include <stdint.h>
 
int32_t caml_serialize_int_4 (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = extern_ptr;
    eax += 4;
    if (*(obj.extern_limit) < eax) {
        eax = 4;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = ebx;
    edx >>= 0x18;
    *(eax) = dl;
    edx = ebx;
    edx >>= 0x10;
    *((eax + 1)) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 2)) = dl;
    *((eax + 3)) = bl;
    eax += 4;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b49c */
#include <stdint.h>
 
int32_t int32_serialize (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_serialize_int_4 (eax);
    eax = *((ebp + 0x10));
    *(eax) = 4;
    eax = *((ebp + 0xc));
    *(eax) = 4;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b4c4 */
#include <stdint.h>
 
uint32_t int64_deserialize (int32_t arg_8h) {
    eax = caml_deserialize_sint_8 (ebx);
    ecx = eax;
    ebx = edx;
    edx = *((ebp + 8));
    *(edx) = ecx;
    *((edx + 4)) = ebx;
    eax = 8;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fbe4 */
#include <stdint.h>
 
uint32_t caml_deserialize_sint_8 (void) {
    int32_t var_8h;
    int32_t var_bp_4h;
    int32_t var_4h;
    eax = ebp - 8;
    caml_deserialize_block_8 (eax, 1);
    eax = *((ebp - 8));
    edx = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fb5c */
#include <stdint.h>
 
int32_t caml_deserialize_block_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_14h;
    int32_t var_10h;
    edi = intern_src;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    edx = *((ebp + 8));
    eax = edi;
    ecx = *((ebp + 0xc));
    *((ebp - 0x14)) = ecx;
    *((ebp - 0x10)) = edi;
    do {
        esi = *(eax);
        ebx = *((eax + 1));
        edi = *((eax + 7));
        ecx = edi;
        *(edx) = cl;
        edi = *((eax + 6));
        ecx = edi;
        *((edx + 1)) = cl;
        ecx = esi;
        *((edx + 7)) = cl;
        *((edx + 6)) = bl;
        esi = *((eax + 2));
        ebx = *((eax + 3));
        edi = *((eax + 5));
        ecx = edi;
        *((edx + 2)) = cl;
        edi = *((eax + 4));
        ecx = edi;
        *((edx + 3)) = cl;
        ecx = esi;
        *((edx + 5)) = cl;
        *((edx + 4)) = bl;
        eax += 8;
        edx += 8;
        *((ebp - 0x14))--;
    } while (*((ebp - 0x14)) != 0);
    edi = *((ebp - 0x10));
    eax = *((ebp + 0xc));
    edi = edi + eax*8;
label_0:
    *(obj.intern_src) = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b4e7 */
#include <stdint.h>
 
int32_t int64_serialize (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    caml_serialize_int_8 (eax, edx);
    eax = *((ebp + 0x10));
    *(eax) = 8;
    eax = *((ebp + 0xc));
    *(eax) = 8;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ec8d */
#include <stdint.h>
 
int32_t caml_serialize_int_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    eax = *((ebp + 8));
    *((ebp - 0x10)) = eax;
    eax = *((ebp + 0xc));
    *((ebp - 0xc)) = eax;
    eax = ebp - 0x10;
    caml_serialize_block_8 (eax, 1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ebea */
#include <stdint.h>
 
int32_t caml_serialize_block_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_2ch;
    int32_t var_1ch;
    eax = *((ebp + 0xc));
    eax <<= 3;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    edi = extern_ptr;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    edx = *((ebp + 8));
    eax = edi;
    ecx = *((ebp + 0xc));
    *((ebp - 0x2c)) = ecx;
    *((ebp - 0x1c)) = edi;
    do {
        esi = *(edx);
        ebx = *((edx + 1));
        edi = *((edx + 7));
        ecx = edi;
        *(eax) = cl;
        edi = *((edx + 6));
        ecx = edi;
        *((eax + 1)) = cl;
        ecx = esi;
        *((eax + 7)) = cl;
        *((eax + 6)) = bl;
        esi = *((edx + 2));
        ebx = *((edx + 3));
        edi = *((edx + 5));
        ecx = edi;
        *((eax + 2)) = cl;
        edi = *((edx + 4));
        ecx = edi;
        *((eax + 3)) = cl;
        ecx = esi;
        *((eax + 5)) = cl;
        *((eax + 4)) = bl;
        edx += 8;
        eax += 8;
        *((ebp - 0x2c))--;
    } while (*((ebp - 0x2c)) != 0);
    edi = *((ebp - 0x1c));
    eax = *((ebp + 0xc));
    edi = edi + eax*8;
label_0:
    *(obj.extern_ptr) = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b516 */
#include <stdint.h>
 
uint32_t parse_intnat (void) {
    uint32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    uint32_t var_2ch;
    uint32_t var_20h;
    int32_t var_1ch;
    *((ebp - 0x34)) = eax;
    *((ebp - 0x38)) = edx;
    ecx = ebp - 0x1c;
    edx = ebp - 0x20;
    eax = parse_sign_and_base (ebx, esi, edi);
    ebx = eax;
    edi = *((ebp - 0x20));
    *((ebp - 0x30)) = edi;
    eax = 0xffffffff;
    edx = 0;
    eax = edx:eax / edi;
    edx = edx:eax % edi;
    *((ebp - 0x2c)) = eax;
    eax = *(ebx);
    eax = parse_digit ();
    if (eax >= 0) {
        if (edi > eax) {
            goto label_0;
        }
    }
    eax = caml_failwith ("int_of_string");
label_0:
    ebx++;
    esi = eax;
    do {
        eax = *(ebx);
        if (al != 0x5f) {
            eax = (int32_t) al;
            eax = parse_digit ();
            if (eax < 0) {
                goto label_1;
            }
            if (edi <= eax) {
                goto label_1;
            }
            if (esi > *((ebp - 0x2c))) {
                caml_failwith ("int_of_string");
            }
            esi *= *((ebp - 0x30));
            esi += eax;
            if (esi >= 0) {
                goto label_2;
            }
            caml_failwith ("int_of_string");
        }
label_2:
        ebx++;
    } while (1);
label_1:
    eax = *((ebp - 0x34));
    eax = caml_string_length (eax);
    eax += *((ebp - 0x34));
    if (ebx != eax) {
        caml_failwith ("int_of_string");
    }
    if (*((ebp - 0x20)) == 0xa) {
        if (*((ebp - 0x1c)) >= 0) {
            ecx = *((ebp - 0x38));
            ecx--;
            eax = 1;
            eax <<= cl;
            if (eax > esi) {
                goto label_3;
            }
            caml_failwith ("int_of_string");
        }
        ecx = *((ebp - 0x38));
        ecx--;
        eax = 1;
        eax <<= cl;
        if (eax >= esi) {
            goto label_4;
        }
        caml_failwith ("int_of_string");
    }
    if (*((ebp - 0x38)) <= 0x1f) {
        eax = 1;
        ecx = *((ebp - 0x38));
        eax <<= cl;
        if (eax > esi) {
            goto label_5;
        }
        caml_failwith ("int_of_string");
    }
label_5:
    if (*((ebp - 0x1c)) < 0) {
label_4:
        eax = esi;
        eax = -eax;
    } else {
label_3:
        eax = esi;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b65d */
#include <stdint.h>
 
uint32_t parse_format (int32_t arg_8h, int32_t arg_ch) {
    void * s1;
    int32_t var_20h;
    int32_t var_1ch;
    char * * endptr;
    size_t base;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x24)) = ecx;
    eax = caml_string_length (ebx, esi, edi);
    ebx = eax;
    edi = *((ebp - 0x20));
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    esi = ecx - 1;
    eax = esi + ebx + 1;
    if (eax > 0x1f) {
        caml_invalid_argument ("format_int: format too long");
    }
    eax = *((ebp - 0x1c));
    edx = *((ebp - 0x24));
    memmove (edx, eax, ebx);
    ecx = *((ebp - 0x24));
    ebx = ecx + ebx - 1;
    edi = *(ebx);
    edx = ebx - 1;
    eax = *(edx);
    if (al != 0x6c) {
        if (al == 0x6e) {
            goto label_0;
        }
        if (al != 0x4c) {
            goto label_1;
        }
    }
label_0:
    ebx = edx;
label_1:
    eax = *((ebp - 0x20));
    memmove (ebx, eax, esi);
    ebx += esi;
    edx = edi;
    *(ebx) = dl;
    *((ebx + 1)) = 0;
    eax = *((ebp - 0x1c));
    edx = *(eax);
    if (dl == 0) {
        goto label_2;
    }
    edx -= 0x30;
    if (dl > 9) {
        goto label_3;
    }
    while (dl != 0) {
        edx -= 0x30;
        if (dl <= 9) {
            eax = strtol (eax, 0, 0xa);
            eax += 5;
            ecx = edi;
            edx = *((ebp + 0xc));
            *(edx) = cl;
            if (eax > 0x1f) {
                goto label_4;
            }
            goto label_5;
        }
label_3:
        eax++;
        edx = *(eax);
    }
    goto label_2;
label_4:
    eax++;
    eax = caml_stat_alloc (eax);
    *((ebp + 8)) = eax;
    do {
label_5:
        eax = *((ebp + 8));
        return eax;
label_2:
        ecx = edi;
        eax = *((ebp + 0xc));
        *(eax) = cl;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d640 */
#include <stdint.h>
 
int32_t unlink_channel (void) {
    edx = *((eax + 0x20));
    if (edx == 0) {
        eax = caml_all_opened_channels;
        eax = *((eax + 0x1c));
        *(obj.caml_all_opened_channels) = eax;
        if (eax == 0) {
            goto label_0;
        }
        *((eax + 0x20)) = 0;
    } else {
        ecx = *((eax + 0x1c));
        *((edx + 0x1c)) = ecx;
        edx = *((eax + 0x1c));
        if (edx == 0) {
            goto label_0;
        }
        eax = *((eax + 0x20));
        *((edx + 0x20)) = eax;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d6d6 */
#include <stdint.h>
 
int32_t compare_channel (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    eax = *((ebp + 0xc));
    edx = *((eax + 4));
    eax = 0;
    if (ecx != edx) {
        eax -= eax;
        eax |= 1;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e1ec */
#include <stdint.h>
 
int32_t do_write (void) {
    int32_t var_1ch;
    char * ptr;
    size_t nbytes;
    edi = eax;
    *((ebp - 0x1c)) = edx;
    esi = ecx;
    do {
label_0:
        caml_enter_blocking_section (ebx, esi, edi);
        eax = *((ebp - 0x1c));
        eax = write (edi, eax, esi);
        ebx = eax;
        caml_leave_blocking_section ();
        if (ebx != -1) {
            goto label_1;
        }
        eax = errno_location ();
        eax = *(eax);
    } while (eax == 4);
    if (eax == 0xb) {
        if (esi <= 1) {
            goto label_2;
        }
        esi = 1;
        goto label_0;
    }
label_2:
    caml_sys_io_error (1);
label_1:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ea20 */
#include <stdint.h>
 
int32_t extern_replay_trail (void) {
    void ** ptr;
    eax = extern_trail_block;
    *((ebp - 0x1c)) = eax;
    edi = extern_trail_cur;
label_0:
    eax = *((ebp - 0x1c));
    eax += 4;
    if (edi <= eax) {
        goto label_1;
    }
    do {
        ebx = *(eax);
        edx = *(eax);
        edx &= 0xfffffffc;
        ecx = edx - 4;
        esi = *(ecx);
        esi &= 0xfffffcff;
        ebx &= 3;
        ebx <<= 8;
        ebx |= esi;
        *(ecx) = ebx;
        ecx = *((eax + 4));
        *(edx) = ecx;
        eax += 8;
    } while (edi > eax);
label_1:
    if (*((ebp - 0x1c)) != obj.extern_trail_first) {
        eax = *((ebp - 0x1c));
        ebx = *(eax);
        free (eax);
        edi = ebx + 0x200c;
        *((ebp - 0x1c)) = ebx;
        goto label_0;
    }
    *(obj.extern_trail_block) = 0x8088f20;
    *(obj.extern_trail_cur) = 0x8088f24;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806eaa6 */
#include <stdint.h>
 
int32_t free_extern_output (void) {
    if (*(obj.extern_userprovided_output) != 0) {
        goto label_0;
    }
    eax = extern_output_first;
    if (eax == 0) {
        goto label_1;
    }
    do {
        ebx = *(eax);
        free (eax);
        if (ebx == 0) {
            goto label_1;
        }
        eax = ebx;
    } while (1);
label_1:
    *(obj.extern_output_first) = 0;
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806eae1 */
#include <stdint.h>
 
void extern_out_of_memory (void) {
    extern_replay_trail ();
    free_extern_output ();
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806eec8 */
#include <stdint.h>
 
int32_t writecode16 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = eax;
    ebx = edx;
    eax = extern_ptr;
    eax += 3;
    if (*(obj.extern_limit) < eax) {
        eax = 3;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = esi;
    *(eax) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 1)) = dl;
    *((eax + 2)) = bl;
    eax += 3;
    *(obj.extern_ptr) = eax;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ef1a */
#include <stdint.h>
 
int32_t writecode8 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    ebx = eax;
    esi = edx;
    eax = extern_ptr;
    eax += 2;
    if (*(obj.extern_limit) < eax) {
        eax = 2;
        grow_extern_output ();
    }
    eax = extern_ptr;
    *(eax) = bl;
    edx = esi;
    *((eax + 1)) = dl;
    eax += 2;
    *(obj.extern_ptr) = eax;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ef64 */
#include <stdint.h>
 
int32_t writecode32 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = eax;
    ebx = edx;
    eax = extern_ptr;
    eax += 5;
    if (*(obj.extern_limit) < eax) {
        eax = 5;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = esi;
    *(eax) = dl;
    edx = ebx;
    edx >>= 0x18;
    *((eax + 1)) = dl;
    edx = ebx;
    edx >>= 0x10;
    *((eax + 2)) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 3)) = dl;
    *((eax + 4)) = bl;
    eax += 5;
    *(obj.extern_ptr) = eax;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806efc6 */
#include <stdint.h>
 
int32_t writeblock (void) {
    int32_t var_8h;
    int32_t var_4h;
    void ** s2;
    size_t * n;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = eax;
    ebx = edx;
    eax = edx;
    eax += *(obj.extern_ptr);
    if (*(obj.extern_limit) < eax) {
        eax = edx;
        grow_extern_output ();
    }
    eax = extern_ptr;
    memmove (eax, esi, ebx);
    *(obj.extern_ptr) += ebx;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f012 */
#include <stdint.h>
 
int32_t write32 (void) {
    ebx = eax;
    eax = extern_ptr;
    eax += 4;
    if (*(obj.extern_limit) < eax) {
        eax = 4;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = ebx;
    edx >>= 0x18;
    *(eax) = dl;
    edx = ebx;
    edx >>= 0x10;
    *((eax + 1)) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 2)) = dl;
    *((eax + 3)) = bl;
    eax += 4;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f062 */
#include <stdint.h>
 
int32_t extern_record_location (void) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = eax;
    if (*(obj.extern_ignore_sharing) == 0) {
        eax = extern_trail_cur;
        if (eax == *(obj.extern_trail_limit)) {
            eax = malloc (0x200c);
            esi = eax;
            if (eax == 0) {
                extern_out_of_memory ();
            }
            eax = extern_trail_block;
            *(esi) = eax;
            *(obj.extern_trail_block) = esi;
            eax = esi + 4;
            *(obj.extern_trail_cur) = eax;
            esi += 0x200c;
            *(obj.extern_trail_limit) = esi;
        }
        edx = ebx - 4;
        ecx = *(edx);
        eax = extern_trail_cur;
        esi = ecx;
        esi >>= 8;
        esi &= 3;
        esi |= ebx;
        *(eax) = esi;
        esi = *(ebx);
        *((eax + 4)) = esi;
        eax += 8;
        *(obj.extern_trail_cur) = eax;
        ch &= 0xfc;
        ch |= 2;
        *(edx) = ecx;
        eax = obj_counter;
        *(ebx) = eax;
        eax++;
        *(obj.obj_counter) = eax;
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f102 */
#include <stdint.h>
 
uint32_t init_extern_output (void) {
    *(obj.extern_userprovided_output) = 0;
    eax = malloc (0x1fac);
    *(obj.extern_output_first) = eax;
    if (eax == 0) {
        eax = caml_raise_out_of_memory ();
    }
    *(obj.extern_output_block) = eax;
    *(eax) = 0;
    edx = eax + 8;
    *(obj.extern_ptr) = edx;
    eax += 0x1fac;
    *(obj.extern_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f14c */
#include <stdint.h>
 
void extern_invalid_argument (void) {
    ebx = eax;
    extern_replay_trail (ebx);
    free_extern_output ();
    return caml_invalid_argument (ebx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f167 */
#include <stdint.h>
 
int32_t extern_rec (void) {
    int32_t var_4ch;
    int32_t var_30h;
    uint32_t var_2ch;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
label_1:
    ebx = eax;
    while ((al & 1) != 0) {
label_0:
        ebx = *((ebp - 0x4c));
label_2:
        if ((bl & 1) != 0) {
            ebx >>= 1;
            eax = ebx;
            if (ebx <= 0x3f) {
                eax = extern_ptr;
                if (eax >= *(obj.extern_limit)) {
                    eax = 1;
                    grow_extern_output ();
                }
                eax = extern_ptr;
                ebx += 0x40;
                *(eax) = bl;
                eax++;
                *(obj.extern_ptr) = eax;
                goto label_3;
            }
            edx = ebx + 0x80;
            if (edx <= 0xff) {
                edx = ebx;
                eax = 0;
                eax = writecode8 ();
                goto label_3;
            }
            eax += 0x8000;
            if (eax <= 0xffff) {
                edx = ebx;
                eax = 1;
                writecode16 ();
                goto label_3;
            }
            edx = ebx;
            eax = 2;
            writecode32 ();
            goto label_3;
        }
        esi = ebx;
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 7) == 0) {
            goto label_4;
        }
        edx = *((ebx - 4));
        edi = (int32_t) dl;
        if (edi != 0xfa) {
            goto label_5;
        }
        eax = *(ebx);
        *((ebp - 0x4c)) = eax;
    }
    *((ebp - 0x30)) = eax;
    eax >>= 0x17;
    ecx = *((ebp - 0x4c));
    ecx >>= 0xc;
    ecx &= 0x7ff;
    eax = *((eax*4 + obj.caml_page_table));
    if ((*((eax + ecx)) & 7) == 0) {
        goto label_5;
    }
    eax = *((ebp - 0x30));
    eax = *((eax - 4));
    *((ebp - 0x2c)) = al;
    if (al == 0xfa) {
        goto label_5;
    }
    if (al == 0xf6) {
        goto label_5;
    }
    if (al != 0xfd) {
        goto label_0;
    }
label_5:
    ecx = edx;
    ecx >>= 0xa;
    *((ebp - 0x2c)) = ecx;
    if (ecx == 0) {
        if (edi <= 0xf) {
            eax = extern_ptr;
            if (eax >= *(obj.extern_limit)) {
                eax = 1;
                grow_extern_output ();
            }
            eax = extern_ptr;
            edx = edi - 0x80;
            *(eax) = dl;
            eax++;
            *(obj.extern_ptr) = eax;
            goto label_3;
        }
        eax = 8;
        writecode32 ();
        goto label_3;
    }
    eax = edx;
    eax &= 0x300;
    if (eax == 0x200) {
        edx = obj_counter;
        edx -= *(ebx);
        if (edx <= 0xff) {
            ax = 4;
            writecode8 ();
            goto label_3;
        }
        if (edx <= 0xffff) {
            eax = 5;
            writecode16 ();
            goto label_3;
        }
        eax = 6;
        writecode32 ();
        goto label_3;
    }
    eax = edi - 0xf9;
    if (eax <= 6) {
        /* switch table (7 cases) at 0x8076f0c */
        eax = caml_string_length (ebx);
        esi = eax;
        if (eax <= 0x1f) {
            eax = extern_ptr;
            if (eax >= *(obj.extern_limit)) {
                eax = 1;
                grow_extern_output ();
            }
            eax = extern_ptr;
            edx = esi + 0x20;
            *(eax) = dl;
            eax++;
            *(obj.extern_ptr) = eax;
        } else {
            if (eax <= 0xff) {
                edx = eax;
                eax = 9;
                eax = writecode8 ();
            } else {
                edx = eax;
                eax = 0xa;
                writecode32 ();
            }
        }
        edx = esi;
        eax = ebx;
        writeblock ();
        eax = esi + 4;
        eax >>= 2;
        edx = size_32;
        eax = edx + eax + 1;
        *(obj.size_32) = eax;
        esi += 8;
        esi >>= 3;
        eax = size_64;
        eax = eax + esi + 1;
        *(obj.size_64) = eax;
        eax = ebx;
        extern_record_location ();
        goto label_3;
        eax = extern_ptr;
        if (eax >= *(obj.extern_limit)) {
            eax = 1;
            grow_extern_output ();
        }
        eax = extern_ptr;
        *(eax) = 0xc;
        eax++;
        *(obj.extern_ptr) = eax;
        edx = 8;
        eax = ebx;
        writeblock ();
        *(obj.size_32) += 3;
        *(obj.size_64) += 2;
        eax = ebx;
        extern_record_location ();
        goto label_3;
        esi = *((ebp - 0x2c));
        esi >>= 1;
        if (esi <= 0xff) {
            edx = esi;
            eax = 0xe;
            writecode8 ();
        } else {
            edx = esi;
            eax = 7;
            writecode32 ();
        }
        edx = esi*8;
        eax = ebx;
        writeblock ();
        eax = size_32;
        eax = eax + esi*2 + 1;
        *(obj.size_32) = eax;
        eax = size_64;
        eax = esi + eax + 1;
        *(obj.size_64) = eax;
        eax = ebx;
        extern_record_location ();
        goto label_3;
        eax = "output_value: abstract value (Abstract)";
        extern_invalid_argument ();
        ebx = *((ebp - 0x2c));
        ebx <<= 2;
        edx = ebx;
        eax = 0x11;
        writecode32 ();
        eax = esi;
        eax -= ebx;
        extern_rec ();
        goto label_1;
        goto label_3;
        *((ebp - 0x2c)) = ebx;
        eax = *(ebx);
        esi = *(eax);
        if (*((eax + 0x10)) == 0) {
            eax = "output_value: abstract value (Custom)";
            extern_invalid_argument ();
        }
        eax = extern_ptr;
        if (eax >= *(obj.extern_limit)) {
            eax = 1;
            grow_extern_output ();
        }
        eax = extern_ptr;
        *(eax) = 0x12;
        eax++;
        *(obj.extern_ptr) = eax;
        edi = esi;
        eax = 0;
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        edx = ecx;
        edx = ~edx;
        eax = esi;
        writeblock ();
        edx = *((ebp - 0x2c));
        eax = *(edx);
        edx = ebp - 0x20;
        edx = ebp - 0x1c;
        uint32_t (*eax + 0x10)(uint32_t, uint32_t, uint32_t) (ebx, edx, edx);
        eax = *((ebp - 0x1c));
        eax += 3;
        eax >>= 2;
        edx = size_32;
        eax = edx + eax + 2;
        *(obj.size_32) = eax;
        eax = *((ebp - 0x20));
        eax += 7;
        eax >>= 3;
        edx = size_64;
        eax = edx + eax + 2;
        *(obj.size_64) = eax;
        eax = ebx;
        extern_record_location ();
        goto label_3;
    }
    if (edi <= 0xf) {
        if (*((ebp - 0x2c)) <= 7) {
            eax = extern_ptr;
            if (eax >= *(obj.extern_limit)) {
                eax = 1;
                grow_extern_output ();
            }
            eax = extern_ptr;
            edx = *((ebp - 0x2c));
            edx <<= 4;
            edx = edx + edi - 0x80;
            *(eax) = dl;
            eax++;
            *(obj.extern_ptr) = eax;
        }
    } else {
        dh &= 0xfc;
        eax = 8;
        writecode32 ();
    }
    eax = size_32;
    ecx = *((ebp - 0x2c));
    eax = ecx + eax + 1;
    *(obj.size_32) = eax;
    eax = size_64;
    eax = ecx + eax + 1;
    *(obj.size_64) = eax;
    edi = *(ebx);
    eax = ebx;
    extern_record_location ();
    ebx = edi;
    if (*((ebp - 0x2c)) == 1) {
        goto label_2;
    }
    eax = edi;
    extern_rec ();
    goto label_1;
    edi = *((ebp - 0x2c));
    edi--;
    ebx = 1;
    if (edi > 1) {
        goto label_6;
    }
    edi = 1;
    goto label_7;
    do {
label_6:
        eax = *((esi + ebx*4));
        extern_rec ();
        goto label_1;
        ebx++;
    } while (edi > ebx);
label_7:
    ebx = *((esi + edi*4));
    goto label_2;
label_4:
    if (ebx >= *(obj.caml_code_area_start)) {
        if (ebx < *(obj.caml_code_area_end)) {
            if (*(obj.extern_closures) == 0) {
                eax = "output_value: functional value";
                extern_invalid_argument ();
            }
            edx = ebx;
            edx -= *(obj.caml_code_area_start);
            eax = 0x10;
            writecode32 ();
            caml_code_checksum ();
            edx = 0x10;
            writeblock ();
        }
    } else {
        eax = "output_value: abstract value (outside heap)";
        extern_invalid_argument ();
    }
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f65d */
#include <stdint.h>
 
uint32_t extern_value (void) {
    int32_t var_4h;
    ebx = eax;
    eax = caml_convert_flag_list (ebx, 0x80846ec);
    edx = eax;
    edx &= 1;
    *(obj.extern_ignore_sharing) = edx;
    eax &= 2;
    *(obj.extern_closures) = eax;
    *(obj.extern_trail_block) = 0x8088f20;
    *(obj.extern_trail_cur) = 0x8088f24;
    *(obj.extern_trail_limit) = 0x808af2c;
    *(obj.obj_counter) = 0;
    *(obj.size_32) = 0;
    *(obj.size_64) = 0;
    eax = 0x8495a6be;
    write32 ();
    *(obj.extern_ptr) += 0x10;
    eax = ebx;
    extern_rec ();
    if (*(obj.extern_userprovided_output) == 0) {
        edx = extern_ptr;
        eax = extern_output_block;
        *((eax + 4)) = edx;
    }
    extern_replay_trail ();
    eax = extern_userprovided_output;
    if (eax != 0) {
        ebx = extern_ptr;
        ebx -= eax;
        eax += 4;
        *(obj.extern_ptr) = eax;
        goto label_0;
    }
    ecx = extern_output_first;
    ebx = 0;
    if (ecx == 0) {
        goto label_1;
    }
    eax = ecx;
    do {
        edx = *((eax + 4));
        edx -= eax;
        ebx = edx + ebx - 8;
        eax = *(eax);
    } while (eax != 0);
    while (1) {
label_0:
        eax = ebx - 0x14;
        write32 ();
        eax = obj_counter;
        write32 ();
        eax = size_32;
        write32 ();
        eax = size_64;
        write32 ();
        eax = ebx;
        return eax;
label_1:
        eax = ecx + 0xc;
        *(obj.extern_ptr) = eax;
        ecx += 0x1fac;
        *(obj.extern_limit) = ecx;
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fca7 */
#include <stdint.h>
 
int32_t intern_cleanup (void) {
    if (*(obj.intern_input_malloced) != 0) {
        eax = intern_input;
        caml_stat_free (eax);
    }
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    eax = intern_extra_block;
    if (eax != 0) {
        caml_free_for_heap (eax);
    } else {
        eax = intern_block;
        if (eax == 0) {
            goto label_0;
        }
        edx = intern_header;
        *((eax - 4)) = edx;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fdeb */
#include <stdint.h>
 
uint32_t intern_alloc (void) {
    int32_t var_4h;
    ebx = edx;
    if (eax == 0) {
        *(obj.intern_obj_table) = 0;
        *(obj.intern_extra_block) = 0;
        *(obj.intern_block) = 0;
    } else {
        edx = eax - 1;
        if (edx > 0x3fffff) {
            eax = eax*4 + 0xfff;
            eax &= 0xfffff000;
            eax = caml_alloc_for_heap (eax);
            *(obj.intern_extra_block) = eax;
            if (eax == 0) {
                eax = caml_raise_out_of_memory ();
            }
            eax = caml_allocation_color (eax);
            *(obj.intern_color) = eax;
            eax = intern_extra_block;
            *(obj.intern_dest) = eax;
        } else {
            if (edx == 0) {
                *(obj.intern_block) = 0x808b514;
            } else {
                if (edx <= 0x100) {
                    eax = caml_alloc_small (edx, 0xfc);
                    *(obj.intern_block) = eax;
                } else {
                    eax = caml_alloc_shr (edx, 0xfc);
                    *(obj.intern_block) = eax;
                }
            }
            eax = intern_block;
            eax -= 4;
            edx = *(eax);
            *(obj.intern_header) = edx;
            edx &= 0x300;
            *(obj.intern_color) = edx;
            *(obj.intern_dest) = eax;
            *(obj.intern_extra_block) = 0;
        }
        *(obj.obj_counter_1) = 0;
        if (ebx != 0) {
            ebx <<= 2;
            eax = caml_stat_alloc (ebx);
            *(obj.intern_obj_table) = eax;
        } else {
            *(obj.intern_obj_table) = 0;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ff00 */
#include <stdint.h>
 
int32_t intern_rec (void) {
    int32_t var_40h;
    int32_t var_3ch;
    void * s2;
    size_t * n;
label_0:
    *((ebp - 0x3c)) = eax;
    esi = 0x80770c4;
    do {
label_1:
        eax = intern_src;
        edx = *(eax);
        ebx = (int32_t) dl;
        eax++;
        *(obj.intern_src) = eax;
        if (ebx <= 0x3f) {
            goto label_2;
        }
        if (ebx <= 0x7f) {
            goto label_3;
        }
        edx = ebx;
        edx &= 0xf;
        ebx >>= 4;
        ebx &= 7;
        if (ebx == 0) {
            esi = edx*4 + 0x808b124;
            goto label_4;
        }
        ecx = intern_dest;
        ecx += 4;
        eax = *((ebp - 0x3c));
        *(eax) = ecx;
        eax = intern_obj_table;
        if (eax != 0) {
            edi = obj_counter;
            *((eax + edi*4)) = ecx;
            edi++;
            *(obj.obj_counter_1) = edi;
        }
        eax = intern_dest;
        ecx = eax + 4;
        *((ebp - 0x3c)) = ecx;
        edx += *(obj.intern_color);
        ecx = ebx;
        ecx <<= 0xa;
        edx += ecx;
        *(eax) = edx;
        eax = ebx*4 + 4;
        *(obj.intern_dest) += eax;
    } while (ebx <= 1);
    edi = ebx;
    eax = *((ebp - 0x3c));
    *((ebp - 0x40)) = eax;
    do {
        eax = *((ebp - 0x40));
        intern_rec ();
        goto label_0;
        edi--;
        *((ebp - 0x40)) += 4;
    } while (edi > 1);
    edx = *((ebp - 0x3c));
    edx = edx + ebx*4 - 4;
    *((ebp - 0x3c)) = edx;
    goto label_1;
label_3:
    ebx &= 0x3f;
    esi = ebx + ebx + 1;
    goto label_4;
label_2:
    if (ebx > 0x1f) {
        ebx &= 0x1f;
        eax = ebx + 4;
        eax >>= 2;
        edi = intern_dest;
        edi += 4;
        esi = edi;
        edx = intern_obj_table;
        if (edx != 0) {
            ecx = obj_counter;
            *((edx + ecx*4)) = edi;
            ecx++;
            *(obj.obj_counter_1) = ecx;
        }
        edx = eax;
        edx <<= 0xa;
        ecx = intern_color;
        ecx = ecx + edx + 0xfc;
        edx = intern_dest;
        *(edx) = ecx;
        edx = eax*4 + 4;
        *(obj.intern_dest) += edx;
        eax <<= 2;
        *((esi + eax - 4)) = 0;
        eax--;
        edx = eax;
        dl -= bl;
        *((eax + esi)) = dl;
        eax = intern_src;
        memmove (edi, eax, ebx);
        *(obj.intern_src) += ebx;
    } else {
        if (dl <= 0x13) {
            edx = (int32_t) dl;
            uint32_t (*esi + edx*4)() ();
        }
        intern_cleanup ();
        caml_failwith ("input_value: ill-formed message");
    }
label_4:
    ecx = *((ebp - 0x3c));
    *(ecx) = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070566 */
#include <stdint.h>
 
uint32_t intern_add_to_heap (void) {
    int32_t var_4h;
    int32_t var_8h;
    edx = intern_extra_block;
    if (edx != 0) {
        eax = eax*4 + 0xfff;
        eax &= 0xfffff000;
        edx += eax;
        eax = intern_dest;
        if (edx > eax) {
            edx -= eax;
            edx >>= 2;
            caml_make_free_blocks (eax, edx, 0);
        }
        eax = intern_extra_block;
        edx = intern_dest;
        edx -= eax;
        edx >>= 2;
        *(obj.caml_allocated_words) += edx;
        caml_add_to_heap (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068739 */
#include <stdint.h>
 
uint32_t caml_make_free_blocks (int32_t arg_8h, char * arg_ch, size_t arg_10h) {
    esi = *((ebp + 8));
    edi = *((ebp + 0xc));
    if (edi == 0) {
        goto label_0;
    }
    do {
        ebx = 0x400000;
        if (edi <= 0x400000) {
            ebx = edi;
        }
        eax = ebx - 1;
        eax <<= 0xa;
        *(esi) = eax;
        if (*((ebp + 0x10)) != 0) {
            eax = esi + 4;
            caml_fl_merge_block (eax);
        }
        edi -= ebx;
        if (edi == 0) {
            goto label_0;
        }
        esi = esi + ebx*4;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a306 */
#include <stdint.h>
 
int32_t caml_add_to_heap (int32_t arg_8h) {
    char * var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    esi = ebx - 0x10;
    eax = caml_stat_heap_size;
    eax += *((esi + 8));
    eax >>= 0xa;
    caml_gc_message (ebx, esi, eax);
    eax = ebx;
    eax += *((esi + 8));
    eax = caml_page_table_add (1, ebx, eax);
    edx = eax;
    eax = 0xffffffff;
    if (edx != 0) {
        goto label_0;
    }
    eax = caml_heap_start;
    if (eax != 0) {
        if (ebx > eax) {
            goto label_1;
        }
    }
    edx = caml_heap_start;
    goto label_2;
    do {
label_1:
        edx = eax - 4;
        eax = *((eax - 4));
        if (eax == 0) {
            goto label_2;
        }
    } while (ebx > eax);
label_2:
    *((esi + 0xc)) = eax;
    *(edx) = ebx;
    *(obj.caml_stat_heap_chunks)++;
    edx = caml_stat_heap_size;
    edx += *((esi + 8));
    *(obj.caml_stat_heap_size) = edx;
    eax = 0;
    if (edx > *(obj.caml_stat_top_heap_size)) {
        *(obj.caml_stat_top_heap_size) = edx;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80705c6 */
#include <stdint.h>
 
int32_t input_val_from_block (void) {
    int32_t var_ch;
    eax = intern_src;
    ecx = eax + 4;
    ebx = *((ecx - 1));
    edx = *(eax);
    edx <<= 0x18;
    edx = ebx + edx;
    ebx = *((ecx - 3));
    ebx <<= 0x10;
    edx += ebx;
    ecx = *((ecx - 2));
    ecx <<= 8;
    edx += ecx;
    ecx = eax + 8;
    ebx = *((ecx - 4));
    ebx <<= 0x18;
    esi = *((ecx - 1));
    ebx += esi;
    esi = *((ecx - 3));
    esi <<= 0x10;
    ebx += esi;
    ecx = *((ecx - 2));
    ecx <<= 8;
    ebx += ecx;
    eax += 0xc;
    *(obj.intern_src) = eax;
    eax = ebx;
    intern_alloc (ebx, esi);
    eax = ebp - 0xc;
    intern_rec ();
    eax = ebx;
    intern_add_to_heap ();
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070a3b */
#include <stdint.h>
 
int32_t hash_aux (void) {
    uint32_t var_1ch;
label_1:
    esi = eax;
    edx = hash_univ_limit;
    edx--;
    *(obj.hash_univ_limit) = edx;
    eax = hash_univ_count;
    if (eax < 0) {
        goto label_4;
    }
    if (edx < 0) {
        goto label_4;
    }
    if ((esi & 1) == 0) {
        ebx = esi;
        ecx = esi;
        ecx >>= 0x17;
        edx = esi;
        edx >>= 0xc;
        edx &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
        if ((*((ecx + edx)) & 7) != 0) {
            goto label_5;
        }
        goto label_6;
    }
label_3:
    eax--;
    *(obj.hash_univ_count) = eax;
    esi >>= 1;
    eax = *(obj.hash_accu) * 0x1003f;
    eax = esi + eax;
    *(obj.hash_accu) = eax;
    goto label_4;
label_2:
    ebx = esi;
    ecx = esi;
    ecx >>= 0x17;
    edx = esi;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 7) == 0) {
        goto label_6;
    }
label_5:
    ecx = ebx - 4;
    edx = *(ecx);
    edi = (int32_t) dl;
    *((ebp - 0x1c)) = edi;
    edx += 8;
    if (dl > 7) {
        goto label_7;
    }
    edx = (int32_t) dl;
    /* switch table (8 cases) at 0x8077114 */
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = caml_string_length (esi);
    if (eax == 0) {
        goto label_4;
    }
    edx = hash_accu;
    do {
        ecx = edx * 9;
        ecx = edx + ecx*2;
        edx = *(esi);
        edx = ecx + edx;
        esi++;
        eax--;
    } while (eax != 0);
    *(obj.hash_accu) = edx;
    goto label_4;
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = hash_accu;
    ecx = esi + 8;
    do {
        edx = eax * 9;
        edx = eax + edx*2;
        eax = *(esi);
        eax = edx + eax;
        esi++;
    } while (esi != ecx);
    *(obj.hash_accu) = eax;
    goto label_4;
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = *(ecx);
    eax >>= 0xa;
    eax <<= 2;
    *((ebp - 0x1c)) = eax;
    if (eax == 0) {
        goto label_4;
    }
    edx = hash_accu;
    esi = 0;
label_0:
    eax = ebx;
    ebx += 8;
    ecx = ebx;
    do {
        edi = edx * 9;
        edi = edx + edi*2;
        edx = *(eax);
        edx = edi + edx;
        eax++;
    } while (ecx != eax);
    esi += 8;
    if (esi < *((ebp - 0x1c))) {
        goto label_0;
    }
    *(obj.hash_accu) = edx;
    goto label_4;
    eax = *(ecx);
    eax >>= 0xa;
    eax <<= 2;
    ebx -= eax;
    eax = ebx;
    eax = hash_aux ();
    goto label_1;
    goto label_4;
    esi = *(esi);
    if ((esi & 1) == 0) {
        goto label_2;
    }
    goto label_3;
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = *((ebx + 4));
    eax >>= 1;
    edx = *(obj.hash_accu) * 0x1003f;
    eax += edx;
    *(obj.hash_accu) = eax;
    goto label_4;
    edx = *(esi);
    edx = *((edx + 0xc));
    if (edx == 0) {
        goto label_4;
    }
    eax--;
    *(obj.hash_univ_count) = eax;
    ebx = *(obj.hash_accu) * 0x1003f;
    eax = void (*edx)(uint32_t) (esi);
    ebx = eax + ebx;
    *(obj.hash_accu) = ebx;
    goto label_4;
label_7:
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = hash_accu;
    edx = eax * 9;
    eax = eax + edx*2;
    eax += *((ebp - 0x1c));
    *(obj.hash_accu) = eax;
    esi = *(ecx);
    esi >>= 0xa;
    if (esi == 0) {
        goto label_4;
    }
    do {
        esi--;
        eax = *((ebx + esi*4));
        eax = hash_aux ();
        goto label_1;
    } while (esi != 0);
    goto label_4;
label_6:
    eax = *(obj.hash_accu) * 0x1003f;
    ebx += eax;
    *(obj.hash_accu) = ebx;
label_4:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80713b3 */
#include <stdint.h>
 
int32_t token_name (void) {
    ebx = eax;
    if (edx <= 0) {
        goto label_0;
    }
    esi = 0xffffffff;
    eax = 0;
    if (*(ebx) != 0) {
        goto label_1;
    }
    goto label_2;
    do {
        if (*(ebx) == 0) {
            goto label_2;
        }
label_1:
        edi = ebx;
        ecx = esi;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        ebx += ecx;
        edx--;
    } while (edx > 0);
    goto label_0;
label_2:
    ebx = "<unknown token>";
label_0:
    eax = "<unknown token>";
    esi = ebx;
    edi = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071a60 */
#include <stdint.h>
 
int32_t norm_pfree (void) {
    edx = 1;
    if (eax == 0) {
        eax = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071a6f */
#include <stdint.h>
 
void norm_pmax (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071a74 */
#include <stdint.h>
 
int32_t norm_heapincr (void) {
    eax += 0x3ff;
    eax &= 0xfffffc00;
    edx = 0x800;
    if (eax <= 0x7ff) {
        eax = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071a90 */
#include <stdint.h>
 
int32_t norm_minsize (void) {
    edx = 0x1000;
    if (eax <= 0xfff) {
        eax = edx;
    }
    edx = 0x10000000;
    if (eax > 0x10000000) {
        eax = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071c31 */
#include <stdint.h>
 
int32_t test_and_compact (void) {
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_18h;
    int32_t var_14h;
    char * var_4h;
    int32_t var_8h;
    eax = caml_fl_cur_size;
    ecx = 0;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = ecx;
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[0] *= *(0x807747c);
    edx = caml_stat_heap_size;
    edx >>= 2;
    edx -= eax;
    eax = edx;
    edx = 0;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = edx;
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(0x8077480);
    *(fp_stack--) = *((ebp - 0x20));
    __asm ("fcmovnbe st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *((ebp - 0x20)) = fp_stack[0];
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0x18)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x18));
    caml_gc_message (0x200, "Estimated overhead (lower bound) = %lu%%\n", eax);
    eax = caml_percent_max;
    edx = 0;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = edx;
    *(fp_stack--) = *((ebp - 0x18));
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        if (*(obj.caml_stat_heap_chunks) <= 1) {
            goto label_0;
        }
        caml_gc_message (0x200, "Automatic compaction triggered.\n", 0);
        caml_compact_heap ();
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8074520 */
#include <stdint.h>
 
int32_t caml_compact_heap (void) {
    int32_t var_2ch;
    uint32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    int32_t var_1ch;
    char * s2;
    size_t n;
    caml_gc_message (ebx, esi, edi);
    eax = caml_heap_start;
    if (eax == 0) {
        goto label_9;
    }
label_0:
    edi = eax - 0x10;
    esi = eax;
    esi += *((edi + 8));
    if (esi <= eax) {
        goto label_10;
    }
    do {
        edx = *(eax);
        ecx = *(eax);
        ecx >>= 0xa;
        ebx = edx;
        ebx &= 0x300;
        if (ebx == 0x200) {
            edx = ecx;
            edx <<= 0xa;
            edx |= 0x3f3;
            *(eax) = edx;
        } else {
            ebx = ecx;
            ebx <<= 0xa;
            edx &= 0xff;
            edx <<= 2;
            edx |= ebx;
            edx |= 3;
            *(eax) = edx;
        }
        eax = eax + ecx*4 + 4;
    } while (esi > eax);
label_10:
    eax = *((edi + 0xc));
    if (eax != 0) {
        goto label_0;
    }
label_9:
    caml_do_roots (sym.invert_root);
    caml_final_do_weak_roots (sym.invert_root);
    eax = caml_heap_start;
    if (eax == 0) {
        goto label_11;
    }
label_2:
    *((ebp - 0x1c)) = eax;
    eax -= 0x10;
    *((ebp - 0x24)) = eax;
    edx = *((ebp - 0x1c));
    edx += *((eax + 8));
    *((ebp - 0x20)) = edx;
    ecx = *((ebp - 0x1c));
    if (edx <= ecx) {
        goto label_12;
    }
label_1:
    edx = *((ebp - 0x1c));
    eax = *(edx);
    if ((al & 3) != 0) {
        goto label_13;
    }
    do {
        eax = *(eax);
    } while ((al & 3) == 0);
label_13:
    edi = eax;
    edi >>= 0xa;
    edi++;
    eax >>= 2;
    eax &= 0xff;
    if (eax != 0xf9) {
        goto label_14;
    }
    ecx = *((ebp - 0x1c));
    eax = *((ecx + edi*4));
    edx = *((ecx + edi*4));
    edx &= 3;
    if (edx == 3) {
        goto label_15;
    }
    do {
        eax &= 0xfffffffc;
        eax = *(eax);
        edx = *(eax);
        edx &= 3;
    } while (edx != 3);
label_15:
    edi = eax;
    edi >>= 0xa;
    edi++;
    eax >>= 2;
    eax &= 0xff;
label_14:
    if (eax > 0xfa) {
        goto label_16;
    }
    if (edi <= 1) {
        goto label_16;
    }
    ebx = *((ebp - 0x1c));
    ebx += 4;
    esi = 1;
    do {
        eax = ebx;
        invert_pointer_at ();
        esi++;
        ebx += 4;
    } while (edi > esi);
label_16:
    eax = *((ebp - 0x1c));
    eax = eax + edi*4;
    *((ebp - 0x1c)) = eax;
    if (*((ebp - 0x20)) > eax) {
        goto label_1;
    }
label_12:
    edx = *((ebp - 0x24));
    eax = *((edx + 0xc));
    if (eax != 0) {
        goto label_2;
    }
label_11:
    ecx = caml_weak_list_head;
    *((ebp - 0x1c)) = ecx;
    if (ecx == 0) {
        goto label_17;
    }
    *((ebp - 0x20)) = obj.caml_weak_list_head;
label_3:
    ebx = *((ebp - 0x1c));
    edi = *((ebx - 4));
    if ((edi & 3) != 0) {
        goto label_18;
    }
    do {
        edi = *(edi);
    } while ((edi & 3) == 0);
label_18:
    edi >>= 0xa;
    if (edi <= 1) {
        goto label_19;
    }
    ebx += 4;
    esi = 1;
    do {
        eax = *(ebx);
        if (eax != *(obj.caml_weak_none)) {
            eax = ebx;
            invert_pointer_at ();
        }
        esi++;
        ebx += 4;
    } while (edi > esi);
label_19:
    eax = *((ebp - 0x20));
    invert_pointer_at ();
    eax = *((ebp - 0x1c));
    *((ebp - 0x20)) = eax;
    edx = *(eax);
    *((ebp - 0x1c)) = edx;
    if (edx != 0) {
        goto label_3;
    }
label_17:
    init_compact_allocate ();
    ebx = caml_heap_start;
    if (ebx == 0) {
        goto label_20;
    }
label_6:
    ecx = ebx - 0x10;
    *((ebp - 0x2c)) = ecx;
    eax = *((ecx + 8));
    eax += ebx;
    *((ebp - 0x28)) = eax;
    goto label_21;
label_5:
    eax = *(ebx);
    if ((al & 3) == 0) {
        goto label_22;
    }
    edx = eax;
    edx >>= 2;
    edx &= 0xff;
    if (edx != 0xf9) {
        goto label_23;
    }
    goto label_24;
    do {
label_22:
        eax = *(eax);
    } while ((al & 3) == 0);
    esi = eax;
    esi >>= 0xa;
    esi++;
    eax >>= 2;
    eax &= 0xff;
    *((ebp - 0x24)) = eax;
    *((ebp - 0x20)) = 0;
    if (eax != 0xf9) {
        goto label_25;
    }
label_8:
    esi = ebx + esi*4;
    *((ebp - 0x20)) = esi;
    eax = *(esi);
    edx = *(esi);
    edx &= 3;
    if (edx == 3) {
        goto label_26;
    }
    do {
        eax &= 0xfffffffc;
        eax = *(eax);
        edx = *(eax);
        edx &= 3;
    } while (edx != 3);
label_26:
    esi = eax;
    esi >>= 0xa;
    esi++;
    eax >>= 2;
    eax &= 0xff;
    *((ebp - 0x24)) = eax;
label_25:
    edx = esi*4;
    *((ebp - 0x1c)) = edx;
    eax = edx;
    eax = compact_allocate ();
    edx = *(ebx);
    if ((dl & 3) != 0) {
        goto label_27;
    }
    edi = eax + 4;
    do {
        ecx = *(edx);
        *(edx) = edi;
        if ((cl & 3) != 0) {
            goto label_27;
        }
        edx = ecx;
    } while (1);
label_27:
    esi <<= 0xa;
    ecx = *((ebp - 0x24));
    edx = esi + ecx - 0x400;
    *(ebx) = edx;
    if (*((ebp - 0x20)) == 0) {
        goto label_28;
    }
    ecx = *((ebp - 0x20));
    edx = *((ebp - 0x20));
    edx &= 3;
    if (edx == 3) {
        goto label_28;
    }
label_4:
    edi = ecx;
    edi &= 0xfffffffc;
    ecx = *(edi);
    edx = *(edi);
    edx &= 3;
    if (edx != 2) {
        goto label_29;
    }
    edx = edi;
    edx -= ebx;
    edx >>= 2;
    esi = eax + edx*4 + 4;
    do {
        edx = ecx;
        edx &= 0xfffffffc;
        ecx = *(edx);
        *(edx) = esi;
        edx = ecx;
        edx &= 3;
    } while (edx == 2);
label_29:
    edx = edi;
    edx -= ebx;
    edx >>= 2;
    edx <<= 0xa;
    edx += 0xf9;
    *(edi) = edx;
    edx = ecx;
    edx &= 3;
    if (edx != 3) {
        goto label_4;
    }
label_28:
    ebx += *((ebp - 0x1c));
    goto label_21;
label_23:
    ecx = eax;
    ecx &= 0xfffffc00;
    edx = edx + ecx + 0x200;
    *(ebx) = edx;
    eax >>= 0xa;
    ebx = ebx + eax*4 + 4;
label_21:
    if (*((ebp - 0x28)) > ebx) {
        goto label_5;
    }
    eax = *((ebp - 0x2c));
    ebx = *((eax + 0xc));
    if (ebx != 0) {
        goto label_6;
    }
label_20:
    init_compact_allocate ();
    ebx = caml_heap_start;
    if (ebx == 0) {
        goto label_30;
    }
label_7:
    edx = ebx - 0x10;
    *((ebp - 0x1c)) = edx;
    esi = ebx;
    esi += *((edx + 8));
    while (esi > ebx) {
        eax = *(ebx);
        if ((ah & 3) == 0) {
            eax >>= 0xa;
            edi = eax*4 + 4;
            eax = edi;
            eax = compact_allocate ();
            eax = memmove (eax, ebx, edi);
            ebx += edi;
        } else {
            eax >>= 0xa;
            ebx = ebx + eax*4 + 4;
        }
    }
    ecx = *((ebp - 0x1c));
    ebx = *((ecx + 0xc));
    if (ebx != 0) {
        goto label_7;
    }
    ecx = caml_heap_start;
    if (ecx == 0) {
        goto label_30;
    }
    edx = ecx;
    eax = 0;
    do {
        edx -= 0x10;
        esi = *((edx + 4));
        if (esi != 0) {
            edi = esi;
            edi >>= 2;
            eax += edi;
            edi = *((edx + 8));
            edi -= esi;
            esi = edi;
            esi >>= 2;
            ebx += esi;
        }
        edx = *((edx + 0xc));
    } while (edx != 0);
    esi = 0x64;
    edx = 0;
    eax = edx:eax / esi;
    edx = edx:eax % esi;
    eax++;
    edi = eax;
    edi *= *(obj.caml_percent_free);
    do {
        eax = ecx - 0x10;
        esi = *((eax + 0xc));
        if (*((eax + 4)) == 0) {
            if (edi > ebx) {
                eax = *((eax + 8));
                eax >>= 2;
                ebx += eax;
            } else {
                caml_shrink_heap (ecx);
            }
        }
        if (esi == 0) {
            goto label_31;
        }
        ecx = esi;
    } while (1);
label_31:
    ebx = caml_heap_start;
    caml_fl_reset ();
    if (ebx == 0) {
        goto label_32;
    }
    do {
        esi = ebx - 0x10;
        edx = *((esi + 8));
        eax = *((esi + 4));
        if (edx > eax) {
            edx -= eax;
            edx >>= 2;
            eax = ebx + eax;
            caml_make_free_blocks (eax, edx, 1);
        }
        ebx = *((esi + 0xc));
    } while (ebx != 0);
    do {
label_32:
        *(obj.caml_stat_compactions)++;
        caml_gc_message (0x10, "done.\n", 0);
        return eax;
label_30:
        eax = caml_fl_reset ();
    } while (1);
label_24:
    eax >>= 0xa;
    esi = eax + 1;
    goto label_8;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073744 */
#include <stdint.h>
 
int32_t add_char (void) {
    ecx = *(eax);
    if (ecx < *((eax + 4))) {
        *(ecx) = dl;
        ecx++;
        *(eax) = ecx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073757 */
#include <stdint.h>
 
int32_t add_string (void) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = eax;
    edi = edx;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ebx = ecx - 1;
    eax = *(esi);
    ecx = eax + ebx;
    edi = *((esi + 4));
    edi -= eax;
    if (*((esi + 4)) < ecx) {
        ebx = edi;
    }
    if (ebx > 0) {
        memmove (eax, edx, ebx);
    }
    *(esi) += ebx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80739f0 */
#include <stdint.h>
 
int32_t hash_value_name (void) {
    edx = *(eax);
    ecx = 0;
    if (dl == 0) {
        goto label_0;
    }
    do {
        ebx = ecx * 9;
        ebx = ecx + ebx*2;
        ecx = (int32_t) dl;
        ecx += ebx;
        eax++;
        edx = *(eax);
    } while (dl != 0);
label_0:
    edx = 0x4ec4ec4f;
    eax = ecx;
    edx:eax = eax * edx;
    eax = edx;
    eax >>= 2;
    edx = eax * 3;
    eax = eax + edx*4;
    ecx -= eax;
    eax = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073d8e */
#include <stdint.h>
 
int32_t do_set (void) {
    if ((cl & 1) == 0) {
        if (ecx < *(obj.caml_young_end)) {
            if (ecx <= *(obj.caml_young_start)) {
                goto label_0;
            }
            ebx = eax + edx*4;
            eax = *(ebx);
            *(ebx) = ecx;
            if ((al & 1) == 0) {
                if (eax >= *(obj.caml_young_end)) {
                    goto label_1;
                }
                if (eax > *(obj.caml_young_start)) {
                    goto label_2;
                }
            }
label_1:
            eax = .comment;
            if (eax >= *(0x8087ac8)) {
                caml_realloc_ref_table (obj.caml_weak_ref_table);
            }
            eax = 0x8087ac4;
            edx = *(eax);
            *(edx) = ebx;
            edx += 4;
            *(eax) = edx;
        }
    } else {
label_0:
        *((eax + edx*4)) = ecx;
    }
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8074380 */
#include <stdint.h>
 
int32_t invert_pointer_at (void) {
    int32_t var_14h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ecx = *(eax);
    if ((cl & 3) != 0) {
        goto label_0;
    }
    ebx = ecx;
    ebx >>= 0x17;
    edx = ecx;
    edx >>= 0xc;
    edx &= 0x7ff;
    ebx = *((ebx*4 + obj.caml_page_table));
    if ((*((ebx + edx)) & 1) == 0) {
        goto label_0;
    }
    esi = ecx - 4;
    edi = *(esi);
    edx = *(esi);
    edx &= 3;
    if (edx != 1) {
        if (edx >= 1) {
            if (edx == 2) {
                goto label_1;
            }
            if (edx != 3) {
                goto label_0;
            }
        }
        *(eax) = edi;
        *(esi) = eax;
        goto label_0;
    }
    edi >>= 0xa;
    edi <<= 2;
    edx = ecx;
    edx -= edi;
    edi = edx;
    ebx = edx - 4;
    *((ebp - 0x14)) = ebx;
    edx = *(ebx);
    if ((dl & 3) != 0) {
        goto label_2;
    }
    do {
        ebx = edx;
        edx = *(edx);
    } while ((dl & 3) == 0);
    *((ebp - 0x14)) = ebx;
label_2:
    ebx = edx;
    ebx >>= 2;
    if (bl == 0xf7) {
        *(eax) = edx;
        eax |= 2;
        *(esi) = eax;
        ecx -= edi;
        ecx >>= 2;
        eax = ecx - 1;
        eax <<= 0xa;
        eax |= 0x3e7;
        edx = *((ebp - 0x14));
        *(edx) = eax;
    } else {
        edx >>= 0xa;
        edx = edi + edx*4;
        edx |= 1;
        *(eax) = edx;
        eax |= 2;
        *(esi) = eax;
        ecx -= edi;
        ecx >>= 2;
        eax = ecx - 1;
        eax <<= 0xa;
        eax |= 0x3e7;
        ebx = *((ebp - 0x14));
        *(ebx) = eax;
        goto label_0;
label_1:
        *(eax) = edi;
        eax |= 2;
        *(esi) = eax;
    }
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807446f */
#include <stdint.h>
 
int32_t invert_root (int32_t arg_ch) {
    eax = *((ebp + 0xc));
    invert_pointer_at ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807447c */
#include <stdint.h>
 
int32_t init_compact_allocate (void) {
    eax = caml_heap_start;
    if (eax == 0) {
        goto label_0;
    }
    do {
        eax -= 0x10;
        *((eax + 4)) = 0;
        eax = *((eax + 0xc));
    } while (eax != 0);
label_0:
    eax = caml_heap_start;
    *(obj.compact_fl) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80744a5 */
#include <stdint.h>
 
uint32_t compact_allocate (void) {
    ecx = compact_fl;
    edx = ecx - 0x10;
    ebx = *((edx + 8));
    ebx -= *((edx + 4));
    if (ebx > 0x10) {
        goto label_1;
    }
    esi = *((edx + 0xc));
    edx = esi - 0x10;
    ebx = *((edx + 8));
    ebx -= *((edx + 4));
    if (ebx <= 0x10) {
        goto label_2;
    }
    goto label_1;
    do {
        esi = ebx;
        ecx = ebx;
label_0:
        ebx = *((edx + 0xc));
        edx = ebx - 0x10;
        edi = *((edx + 8));
        edi -= *((edx + 4));
    } while (edi <= 0x10);
    *(obj.compact_fl) = esi;
label_1:
    edx = ecx - 0x10;
    ebx = *((edx + 4));
    esi = *((edx + 8));
    esi -= ebx;
    if (eax <= esi) {
        goto label_3;
    }
    do {
        ecx = *((edx + 0xc));
        edx = ecx - 0x10;
        ebx = *((edx + 4));
        esi = *((edx + 8));
        esi -= ebx;
    } while (esi < eax);
label_3:
    eax = ebx + eax;
    *((edx + 4)) = eax;
    eax = ecx + ebx;
    esi = ebx;
    edi = ebx;
    return eax;
label_2:
    ecx = esi;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075704 */
#include <stdint.h>
 
int32_t extract_location_info (void) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    if ((*((eax + 4)) & 1) == 0) {
        *(edx) = 0;
        *((edx + 4)) = 1;
    } else {
        ecx = *((eax + 6));
        ebx = eax + ecx*2 + 0xb;
        ebx &= 0xfffffffc;
        edi = *(ebx);
        ecx = *((ebx + 4));
        *(edx) = 1;
        al = ((edi & 3) != 0) ? 1 : 0;
        esi = eax;
        esi &= 0xff;
        *((edx + 4)) = esi;
        esi = edi;
        esi &= 0x3fffffc;
        ebx = esi + ebx;
        *((edx + 8)) = ebx;
        ebx = ecx;
        ebx >>= 0xc;
        *((edx + 0xc)) = ebx;
        ebx = ecx;
        ebx >>= 4;
        ebx &= 0xff;
        *((edx + 0x10)) = ebx;
        ecx &= 0xf;
        ecx <<= 6;
        eax = edi;
        eax >>= 0x1a;
        eax |= ecx;
        *((edx + 0x14)) = eax;
    }
    ebx = *(esp);
    esi = *((esp + 4));
    edi = *((esp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d679 */
#include <stdint.h>
 
int32_t caml_channel_binary_mode (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c640 */
#include <stdint.h>
 
int32_t camlUnix_fun_2782 (void) {
    eax = unix_error_message;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075be8 */
#include <stdint.h>
 
void loc_caml_c_call (int32_t arg_4h) {
    edx = *(esp);
    *(obj.caml_last_return_address) = edx;
    edx = esp + 4;
    *(obj.caml_bottom_of_stack) = edx;
    return void (*eax)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e7ac */
#include <stdint.h>
 
int32_t caml_seek_out (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    edi = *((ebp + 0x10));
    caml_flush (ebx);
    caml_enter_blocking_section ();
    *((esp + 0xc)) = 0;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    eax = *(ebx);
    *(esp) = eax;
    eax = lseek64 ();
    edx ^= edi;
    eax ^= esi;
    edx |= eax;
    if (edx != 0) {
        caml_leave_blocking_section ();
        caml_sys_error (1);
    }
    caml_leave_blocking_section ();
    *((ebx + 4)) = esi;
    *((ebx + 8)) = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e71a */
#include <stdint.h>
 
uint32_t caml_flush (int32_t arg_8h) {
    ebx = *((ebp + 8));
    do {
        eax = caml_flush_partial (ebx);
    } while (eax == 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e477 */
#include <stdint.h>
 
uint32_t caml_flush_partial (int32_t arg_8h) {
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    eax = ebx + 0x34;
    *((ebp - 0x1c)) = eax;
    esi = *((ebx + 0x10));
    esi -= eax;
    if (esi > 0) {
        edx = eax;
        ecx = esi;
        eax = *(ebx);
        eax = do_write ();
        edi = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebx + 4)) += eax;
        *((ebx + 8)) += edx;
        if (esi > edi) {
            esi -= edi;
            eax = *((ebp - 0x1c));
            eax += edi;
            eax = *((ebp - 0x1c));
            memmove (eax, eax, esi);
        }
        *((ebx + 0x10)) -= edi;
    }
    eax = ebx + 0x34;
    al = (*((ebx + 0x10)) == eax) ? 1 : 0;
    eax = (int32_t) al;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067f4d */
#include <stdint.h>
 
int32_t caml_enter_blocking_section (void) {
    do {
        caml_process_pending_signals ();
        uint32_t (*caml_enter_blocking_section_hook)() ();
        eax = caml_signals_are_pending;
        if (eax == 0) {
            goto label_0;
        }
        uint32_t (*caml_leave_blocking_section_hook)() ();
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a844 */
#include <stdint.h>
 
void lseek64 (void) {
    lseek64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067f3a */
#include <stdint.h>
 
void caml_leave_blocking_section (void) {
    uint32_t (*caml_leave_blocking_section_hook)() ();
    caml_process_pending_signals ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067d9c */
#include <stdint.h>
 
int32_t caml_process_pending_signals (void) {
    int32_t var_4h;
    eax = caml_signals_are_pending;
    if (eax == 0) {
        goto label_0;
    }
    *(obj.caml_signals_are_pending) = 0;
    ebx = 0;
    esi = caml_pending_signals;
    do {
        eax = *((esi + ebx*4));
        if (eax != 0) {
            *((esi + ebx*4)) = 0;
            caml_execute_signal (ebx, 0);
        }
        ebx++;
    } while (ebx != 0x41);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070f0b */
#include <stdint.h>
 
int32_t caml_sys_error (int32_t arg_8h) {
    int32_t var_3ch_2;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    void * s2;
    size_t n;
    eax = caml_local_roots;
    *((ebp - 0x38)) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    eax = ebp - 0x3c;
    *((ebp - 0x50)) = eax;
    eax = errno_location ();
    eax = *(eax);
    eax = strerror (eax);
    esi = eax;
    edx = *((ebp + 8));
    if (edx == 1) {
        eax = caml_copy_string (eax);
        *((ebp - 0x3c)) = eax;
    } else {
        edi = eax;
        eax = 0;
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        edi = ecx - 1;
        eax = caml_string_length (edx);
        ebx = eax;
        eax = eax + edi + 2;
        eax = caml_alloc_string (eax);
        *((ebp - 0x3c)) = eax;
        edx = *((ebp + 8));
        memmove (eax, edx, ebx);
        eax = ebx;
        eax += *((ebp - 0x3c));
        *(eax) = 0x203a;
        eax = *((ebp - 0x3c));
        eax = ebx + eax + 2;
        memmove (eax, esi, edi);
    }
    eax = *((ebp - 0x3c));
    return caml_raise_sys_error (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050bc0 */
#include <stdint.h>
 
int32_t camlArray_find_init_1077 (void) {
    do {
        ebx = eax;
        if (ebx == 1) {
            goto label_1;
        }
        eax = *((ebx + 4));
        ecx = *(ebx);
        edx = *((ecx - 4));
        esi = *((ecx - 4));
        esi &= 0xff;
        if (esi != 0xfe) {
            edx >>= 9;
        } else {
            edx >>= 0xa;
        }
        edx |= 1;
        if (edx > 1) {
            eax = *((ecx - 4));
            if (eax != 0xfe) {
                eax = *(ecx);
            } else {
label_0:
                eax = caml_young_ptr;
                eax -= 0xc;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_2;
                }
                eax = eax + 4;
                *((eax - 4)) = 0x8fd;
                *(fp_stack--) = *(ecx);
                *(eax) = fp_stack[0];
                fp_stack--;
            }
            void (*0x8052230)() ();
        }
    } while (1);
label_1:
    eax = camlArray__36;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c0f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2630 (void) {
    eax = unix_getegid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b294 */
#include <stdint.h>
 
int32_t caml_int32_to_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c049 */
#include <stdint.h>
 
int32_t caml_int64_mul (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 8));
    ecx *= *((eax + 4));
    ebx = *((eax + 8));
    ebx *= *((edx + 4));
    ecx += ebx;
    eax = *((eax + 4));
    edx:eax = eax * *((edx + 4));
    edx = ecx + edx;
    caml_copy_int64 (ebx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bc02 */
#include <stdint.h>
 
void caml_copy_int64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_ch;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    caml_alloc_custom (1, 8, 0);
    *((eax + 4)) = ebx;
    *((eax + 8)) = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807521a */
#include <stdint.h>
 
int32_t caml_alloc_custom (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax += 3;
    eax >>= 2;
    eax++;
    if (*((ebx + 4)) == 0) {
        if (eax <= 0x100) {
            caml_alloc_small (eax, 0xff);
            *(eax) = ebx;
        }
    } else {
        eax = caml_alloc_shr (eax, 0xff);
        esi = eax;
        *(eax) = ebx;
        eax = *((ebp + 0x14));
        eax = *((ebp + 0x10));
        caml_adjust_gc_speed (eax, eax);
        caml_check_urgent_gc (esi);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f811 */
#include <stdint.h>
 
int32_t caml_output_value_to_buffer (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    *(obj.extern_userprovided_output) = eax;
    *(obj.extern_ptr) = eax;
    edx = *((ebp + 0x10));
    edx >>= 1;
    eax += edx;
    *(obj.extern_limit) = eax;
    edx = *((ebp + 0x18));
    eax = *((ebp + 0x14));
    extern_value ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067f80 */
#include <stdint.h>
 
uint32_t caml_init_signals (void) {
    int32_t var_a0h;
    int32_t var_9ch;
    int32_t var_1ch;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    struct sigaction * act;
    struct sigaction * oldact;
    *((ebp - 0x14)) = 0x8084a80;
    *((ebp - 0xc)) = 0x2000;
    *((ebp - 0x10)) = 0;
    *((ebp - 0xa0)) = 0x80680af;
    *((ebp - 0x1c)) = 0x48000000;
    ebx = ebp - 0xa0;
    eax = ebp - 0x9c;
    *(esp) = eax;
    sigemptyset ();
    *(obj.system_stack_top) = ebx;
    *((esp + 4)) = 0;
    eax = ebp - 0x14;
    *(esp) = eax;
    eax = sigaltstack ();
    if (eax == 0) {
        sigaction (0xb, ebx, 0);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a134 */
#include <stdint.h>
 
void sigaltstack (void) {
    sigaltstack ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e91d */
#include <stdint.h>
 
uint32_t caml_open_descriptor_in (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    esi = *((ebp + 8));
    eax = caml_stat_alloc (ebx, esi);
    ebx = eax;
    *(eax) = esi;
    caml_enter_blocking_section ();
    *((esp + 0xc)) = 1;
    *((esp + 4)) = 0;
    *((esp + 8)) = 0;
    *(esp) = esi;
    eax = lseek64 ();
    *((ebx + 4)) = eax;
    *((ebx + 8)) = edx;
    caml_leave_blocking_section ();
    eax = ebx + 0x34;
    *((ebx + 0x14)) = eax;
    *((ebx + 0x10)) = eax;
    eax = ebx + 0x1034;
    *((ebx + 0xc)) = eax;
    *((ebx + 0x18)) = 0;
    *((ebx + 0x24)) = 0;
    *((ebx + 0x28)) = 0;
    *((ebx + 0x2c)) = 0;
    *((ebx + 0x30)) = 0;
    eax = caml_all_opened_channels;
    *((ebx + 0x1c)) = eax;
    *((ebx + 0x20)) = 0;
    eax = caml_all_opened_channels;
    if (eax != 0) {
        *((eax + 0x20)) = ebx;
    }
    *(obj.caml_all_opened_channels) = ebx;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050130 */
#include <stdint.h>
 
uint32_t camlPervasives_prerr_int_1281 (void) {
    eax = camlPervasives_string_of_int_1130 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fb20 */
#include <stdint.h>
 
int32_t camlPervasives_string_of_int_1130 (void) {
    eax = caml_format_int;
    caml_c_call (loc.camlPervasives__96);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ef70 */
#include <stdint.h>
 
void camlCamlinternalOO_fun_1830 (void) {
    edx = *((ebx + 8));
    ecx = *(eax);
    ecx = *((ecx + edx*2 - 2));
    ebx = *((ebx + 0xc));
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d5e0 */
#include <stdint.h>
 
int32_t camlPrintf_index_of_literal_position_1044 (void) {
    eax += 0xfffffffe;
    return camlPrintf_index_of_int_1037 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075c54 */
#include <stdint.h>
 
int32_t loc_caml_raise_exn (int32_t arg_4h) {
    if ((*(obj.caml_backtrace_active) & 1) == 0) {
        esp = caml_exception_pointer;
        return;
    }
    esi = eax;
    edi = caml_exception_pointer;
    eax = *(esp);
    edx = esp + 4;
    caml_stash_backtrace (esi, eax, edx, edi);
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80759a9 */
#include <stdint.h>
 
int32_t caml_stash_backtrace (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h) {
    eax = *((ebp + 8));
    ebx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    if (eax != *(obj.caml_backtrace_last_exn)) {
        *(obj.caml_backtrace_pos) = 0;
        *(obj.caml_backtrace_last_exn) = eax;
    }
    if (*(obj.caml_backtrace_buffer) == 0) {
        eax = malloc (0x1000);
        *(obj.caml_backtrace_buffer) = eax;
        if (eax == 0) {
            goto label_1;
        }
    }
    if (*(obj.caml_frame_descriptors) == 0) {
        caml_init_frame_descriptors ();
    }
label_0:
    edi = caml_frame_descriptors_mask;
    edx = ebx;
    edx >>= 3;
    edx &= edi;
    ecx = caml_frame_descriptors;
    eax = *((ecx + edx*4));
    if (eax == 0) {
        goto label_1;
    }
    if (*(eax) != ebx) {
        goto label_2;
    }
    goto label_3;
    do {
        if (*(eax) == ebx) {
            goto label_3;
        }
label_2:
        edx++;
        edx &= edi;
        eax = *((ecx + edx*4));
    } while (eax != 0);
    goto label_1;
label_3:
    if (*((eax + 4)) != 0xffff) {
        edx = caml_backtrace_pos;
        if (edx > 0x3ff) {
            goto label_1;
        }
        ecx = caml_backtrace_buffer;
        *((ecx + edx*4)) = eax;
        edx++;
        *(obj.caml_backtrace_pos) = edx;
        eax = *((eax + 4));
        eax &= 0xfffc;
        esi += eax;
        ebx = *((esi - 4));
    } else {
        eax = esi + 8;
        esi = *(eax);
        ebx = *((eax + 4));
        if (esi == 0) {
            goto label_1;
        }
    }
    if (esi <= *((ebp + 0x14))) {
        goto label_0;
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075adc */
#include <stdint.h>
 
int32_t loc_caml_call_gc (int32_t arg_4h) {
    eax = *(esp);
    *(obj.caml_last_return_address) = eax;
    eax = esp + 4;
    *(obj.caml_bottom_of_stack) = eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806817b */
#include <stdint.h>
 
int32_t caml_garbage_collection (void) {
    eax = caml_young_start;
    *(obj.caml_young_limit) = eax;
    if (eax <= *(obj.caml_young_ptr)) {
        eax = caml_force_major_slice;
        if (eax == 0) {
            goto label_0;
        }
    }
    caml_minor_collection ();
label_0:
    caml_process_pending_signals ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f9f0 */
#include <stdint.h>
 
uint32_t camlPervasives_5e_1112 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
    *((esp + 4)) = edx;
    *((esp + 0xc)) = ebx;
    ecx = *((edx - 4));
    ecx >>= 0xa;
    eax = ecx*4 - 1;
    ecx = *((edx + eax));
    eax -= ecx;
    eax = eax + eax + 1;
    *(esp) = eax;
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    ebx = *((ebx + ecx));
    ecx -= ebx;
    ebx = ecx + ecx + 1;
    *((esp + 8)) = ebx;
    eax = caml_create_string;
    eax = caml_c_call (eax + ebx - 1);
    ebx = eax;
    esi = *(esp);
    eax = *((esp + 0x14));
    caml_blit_string (eax, 1, ebx, 1, esi);
    eax = *((esp + 8));
    eax = *((esp + 0x1c));
    caml_blit_string (eax, 1, ebx, esi, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ce1b */
#include <stdint.h>
 
int32_t caml_blit_string (int32_t arg_8h, int32_t arg_ch, void * s1, int32_t arg_14h, int32_t arg_18h) {
    void * s2;
    size_t n;
    eax = *((ebp + 0x18));
    eax >>= 1;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    eax = *((ebp + 0x14));
    eax >>= 1;
    eax += *((ebp + 0x10));
    memmove (eax, eax, eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806328f */
#include <stdint.h>
 
int32_t unix_getpwnam (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15671;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getpwnam ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_passwd_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a834 */
#include <stdint.h>
 
void getpwnam (void) {
    getpwnam ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80670a7 */
#include <stdint.h>
 
void caml_raise_not_found (void) {
    return caml_raise_constant (loc.caml_exn_Not_found);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075ad6 */
#include <stdint.h>
 
void caml_debugger_cleanup_fork (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b3d0 */
#include <stdint.h>
 
int32_t caml_nativeint_to_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cd9d */
#include <stdint.h>
 
uint32_t caml_is_printable (int32_t arg_8h) {
    char * locale;
    if (*(obj.locale_is_set.2848) == 0) {
        setlocale (0, 0x8077448);
        *(obj.locale_is_set.2848) = 1;
    }
    eax = ctype_b_loc ();
    edx = *((ebp + 8));
    edx >>= 1;
    eax = *(eax);
    eax = *((eax + edx*2));
    eax &= 0x4000;
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a424 */
#include <stdint.h>
 
void setlocale (void) {
    setlocale ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a2d4 */
#include <stdint.h>
 
void ctype_b_loc (void) {
    ctype_b_loc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054a90 */
#include <stdint.h>
 
int32_t camlList_exists_1141 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t) (edx, eax);
        if (eax != 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c130 */
#include <stdint.h>
 
int32_t camlUnix_fun_2638 (void) {
    eax = unix_getuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e4ea */
#include <stdint.h>
 
uint32_t caml_ml_output_char (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebx + 0x10));
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = *((ebp + 0xc));
    edx >>= 1;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d1a0 */
#include <stdint.h>
 
int32_t camlUnix_getnameinfo_emulation_1772 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = *((eax - 4));
    if (ecx != 0) {
        *((esp + 8)) = ebx;
        ecx = *((eax + 4));
        *((esp + 4)) = ecx;
        eax = *(eax);
        eax = fcn_0804d250 (eax);
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 5;
            ebx = *((esp + 8));
            eax = camlList_mem_1161 ();
            if (eax != 1) {
label_2:
                eax = caml_young_ptr;
                eax -= 8;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_3;
                }
                eax = eax + 4;
                *((eax - 4)) = 0x400;
                *(eax) = loc.caml_exn_Not_found;
                caml_raise_exn ();
            }
            eax = *(esp);
            eax = unix_string_of_inet_addr;
            caml_c_call (eax);
        } else {
            eax = caml_raise_exn ();
        }
        *(esp) = eax;
        eax = void (*0x804d300)() ();
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            eax = *((esp + 4));
            eax = camlPervasives_string_of_int_1130 ();
            ecx = eax;
        } else {
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            eax = 7;
            ebx = *((esp + 0x10));
            eax = camlList_mem_1161 (*(obj.caml_exception_pointer));
            if (eax != 1) {
label_1:
                eax = caml_young_ptr;
                eax -= 8;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_4;
                }
                eax = eax + 4;
                *((eax - 4)) = 0x400;
                *(eax) = loc.caml_exn_Not_found;
                caml_raise_exn ();
            }
            eax = 9;
            ebx = *((esp + 0x10));
            eax = camlList_mem_1161 ();
            if (eax != 1) {
                eax = loc.camlUnix__194;
            } else {
                eax = loc.camlUnix__193;
            }
            eax = *((esp + 0x10));
            eax = unix_getservbyport;
            eax = caml_c_call (eax);
            ecx = *(eax);
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        *((eax + 4)) = ecx;
        return eax;
    }
    ebx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.camlUnix__192;
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ae00 */
#include <stdint.h>
 
int32_t caml_curry7_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b380 */
#include <stdint.h>
 
int32_t caml_curry3_2 (void) {
    ecx = eax;
    eax = *((ebx + 0xc));
    edx = *((eax + 0xc));
    ebx = *((ebx + 8));
    eax = *((eax + 8));
    esi = *((edx + 8));
    return void (*esi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b580 */
#include <stdint.h>
 
uint32_t caml_apply3 (void) {
    int32_t var_4h;
    esi = *((edx + 4));
    if (esi == 7) {
        esi = *((edx + 8));
        void (*esi)() ();
    }
    ecx = *(edx);
    ebx = edx;
    eax = void (*ecx)(uint32_t, uint32_t) (ebx, ecx);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 4));
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80620e8 */
#include <stdint.h>
 
int32_t unix_fchown (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16818;
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = fchown ();
    if (eax == -1) {
        eax = ebx - 0x25f1;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049ff4 */
#include <stdint.h>
 
void fchown (void) {
    fchown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806647c */
#include <stdint.h>
 
uint32_t uerror (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12484;
    eax = errno_location ();
    edx = *((ebp + 0xc));
    edx = *((ebp + 8));
    eax = *(eax);
    return unix_error (eax, edx, edx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049df4 */
#include <stdint.h>
 
void errno_location (void) {
    errno_location ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806637f */
#include <stdint.h>
 
int32_t unix_error (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_34h_2;
    int32_t var_14h_2;
    int32_t var_10h_2;
    int32_t var_ch_3;
    int32_t var_bp_8h;
    int32_t var_bp_4h;
    int32_t var_ch_2;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h_2;
    int32_t var_8h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12581;
    eax = *((ebp + 0x10));
    *((ebp - 0xc)) = 1;
    *((ebp - 0x10)) = 1;
    *((ebp - 0x14)) = 1;
    edx = *((ebx - 0x18));
    ecx = *(edx);
    *((ebp - 0x34)) = ecx;
    ecx = ebp - 0x34;
    *(edx) = ecx;
    *((ebp - 0x2c)) = 1;
    *((ebp - 0x30)) = 3;
    edx = ebp - 0xc;
    *((ebp - 0x28)) = edx;
    edx = ebp - 0x10;
    *((ebp - 0x24)) = edx;
    edx = ebp - 0x14;
    *((ebp - 0x20)) = edx;
    if (eax == 0) {
        eax = ebx - 0x14c4;
        eax = caml_copy_string (eax);
    }
    *((ebp - 0x14)) = eax;
    eax = *((ebp + 0xc));
    eax = caml_copy_string (eax);
    *((ebp - 0xc)) = eax;
    eax = *((ebp + 8));
    eax = unix_error_of_code (eax);
    *((ebp - 0x10)) = eax;
    if (*((ebx + 0xbed0)) == 0) {
        eax = ebx - 0x2214;
        eax = caml_named_value (eax);
        *((ebx + 0xbed0)) = eax;
        if (eax != 0) {
            goto label_0;
        }
        eax = ebx - 0x2204;
        caml_invalid_argument (eax);
    }
label_0:
    caml_alloc_small (4, 0);
    edx = *((ebx + 0xbed0));
    edx = *(edx);
    *(eax) = edx;
    edx = *((ebp - 0x10));
    *((eax + 4)) = edx;
    edx = *((ebp - 0xc));
    *((eax + 8)) = edx;
    edx = *((ebp - 0x14));
    *((eax + 0xc)) = edx;
    ecx = *((ebp - 0x34));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a3e4 */
#include <stdint.h>
 
void unlink (void) {
    unlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065ab1 */
#include <stdint.h>
 
uint32_t unix_stat (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x12e4e;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = xstat64 ();
    if (eax == -1) {
        eax = ebx - 0x2365;
        uerror (eax, esi);
    }
    if (*((ebp - 0x38)) >= 0) {
        if (*((ebp - 0x38)) <= 0) {
            if (*((ebp - 0x3c)) <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = *((ebp - 0x58));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        eax = ebx - 0x2365;
        unix_error (0x4b, eax, esi);
    }
label_0:
    edx = ebp - 0x68;
    eax = 0;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fbc0 */
#include <stdint.h>
 
int32_t camlPervasives_40_1143 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        edx = *((eax + 4));
        ecx = *(eax);
        eax = edx;
        eax = camlPervasives_$40_1143 (ecx);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *(esp);
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c3a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2710 (void) {
    eax = unix_dup;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804e1e0 */
#include <stdint.h>
 
int32_t camlUnix_close_process_full_2013 (int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = ecx;
    esi = ebx;
    *((esp + 0xc)) = esi;
    edx = eax;
    *(esp) = edx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc03;
            *(ebx) = edx;
            *((ebx + 4)) = esi;
            *((ebx + 8)) = ecx;
            eax = "close_process_full";
            eax = camlUnix_find_proc_id_1997 ();
            *((esp + 8)) = eax;
            eax = *(esp);
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = void (*0x804e260)() ();
            ecx = loc.caml_exn_Sys_error;
            ebx = *(eax);
            if (ebx != ecx) {
                caml_raise_exn ();
                *(obj.caml_exception_pointer) = esp;
                eax = *((esp + 0x14));
                camlPervasives_close_out_1209 (*(obj.caml_exception_pointer));
            }
            eax = *((esp + 4));
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = *((esp + 8));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804df30 */
#include <stdint.h>
 
uint32_t camlUnix_find_proc_id_1997 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = void (*0x804dfa0)(uint32_t, uint32_t) (eax, ebx);
    ecx = loc.caml_exn_Not_found;
    ebx = *(eax);
    while (1) {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1000;
            ebx = camlUnix;
            *(eax) = ebx;
            *((eax + 4)) = 7;
            ebx = *((esp + 4));
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = 0x807a45c;
            caml_raise_exn ();
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            eax = .comment;
            eax = camlHashtbl_find_1093 (*(obj.caml_exception_pointer));
            eax = .comment;
            ebx = *((esp + 0x10));
            camlHashtbl_remove_1080 (eax);
            eax = *(esp);
            return eax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8057b30 */
#include <stdint.h>
 
int32_t camlHashtbl_find_1093 (void) {
    int32_t var_4h_6;
    int32_t var_8h_5;
    edi = eax;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = caml_hash_univ_param (0x15, 0xc9, ebx);
        eax >>= 1;
        ecx = esi;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    ecx = *((edi + 4));
    eax = *((ecx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    ecx = *((ecx + edx*2 - 2));
    if (ecx == 1) {
        goto label_3;
    }
    *((esp + 4)) = ebx;
    eax = *((ecx + 8));
    *(esp) = eax;
    eax = *((ecx + 4));
    *((esp + 8)) = eax;
    eax = *(ecx);
    eax = caml_compare;
    eax = caml_c_call (ebx);
    if (eax == 1) {
        eax = *((esp + 8));
        return eax;
    }
    eax = *(esp);
    if (eax != 1) {
        ebx = *((eax + 8));
        *(esp) = ebx;
        ebx = *((eax + 4));
        *((esp + 8)) = ebx;
        eax = *(eax);
        eax = *((esp + 8));
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        if (eax != 1) {
            ebx = *((eax + 8));
            *(esp) = ebx;
            ebx = *((eax + 4));
            *((esp + 8)) = ebx;
            eax = *(eax);
            eax = *((esp + 8));
            eax = caml_compare;
            eax = caml_c_call (eax);
            if (eax == 1) {
                eax = *((esp + 8));
                return eax;
            }
            eax = *((esp + 4));
            ebx = *(esp);
            void (*0x8057aa0)() ();
        }
label_1:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x400;
        *(eax) = loc.caml_exn_Not_found;
        caml_raise_exn ();
    }
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = loc.caml_exn_Not_found;
    caml_raise_exn ();
    do {
label_3:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80579c0 */
#include <stdint.h>
 
int32_t camlHashtbl_remove_1080 (void) {
    int32_t var_8h;
    int32_t var_ch;
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.camlHashtbl__remove_bucket_1083;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = edi;
            *((ebx + 0xc)) = ecx;
            eax = *((edi + 4));
            esi = *((eax - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = caml_hash_univ_param (0x15, 0xc9, ecx);
                eax >>= 1;
                ecx = esi;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            *((esp + 4)) = edx;
            eax = *((edi + 4));
            *(esp) = eax;
            eax = *((eax - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            ecx = *((edi + 4));
            eax = *((ecx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_1;
            }
            eax = *((ecx + edx*2 - 2));
            eax = camlHashtbl_remove_bucket_1083 ();
            ebx = *((esp + 4));
            eax = *((esp + 8));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fd40 */
#include <stdint.h>
 
int32_t camlPervasives_close_out_1209 (void) {
    *(esp) = eax;
    eax = caml_ml_flush;
    caml_c_call (eax);
    eax = *(esp);
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804dff0 */
#include <stdint.h>
 
uint32_t camlUnix_waitpid_non_intr_2001 (void) {
    do {
        eax = void (*0x804e030)(uint32_t) (eax);
        ecx = camlUnix;
        ebx = *(eax);
        if (ebx != ecx) {
            goto label_0;
        }
        ebx = *((eax + 4));
        if ((ebx & 1) == 0) {
            goto label_0;
        }
        if (ebx != 0x17) {
            goto label_0;
        }
        eax = *(esp);
    } while (1);
label_0:
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_waitpid;
    caml_c_call (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d830 */
#include <stdint.h>
 
int32_t camlUnix_open_proc_1949 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    ebx = esi;
    eax = .comment;
    eax = camlList_for_all_1137 (ebx, eax, ebx);
    *(esp) = eax;
    eax = unix_fork;
    eax = caml_c_call (1);
    ecx = eax;
    if (ecx != 1) {
        eax = .comment;
        ebx = *((esp + 0x14));
        void (*0x80578d0)() ();
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        *((esp + 0x10)) = eax;
        eax = unix_dup2;
        caml_c_call (eax);
        eax = *((esp + 0x10));
        eax = unix_close;
        caml_c_call (eax);
    }
    eax = *((esp + 0xc));
    if (eax != 3) {
        *((esp + 0xc)) = eax;
        eax = unix_dup2;
        caml_c_call (eax);
        eax = *((esp + 0xc));
        eax = unix_close;
        caml_c_call (eax);
    }
    eax = *(esp);
    if (eax == 1) {
        eax = loc.camlUnix__188;
        ebx = *((esp + 8));
        camlList_iter_1074 ();
    }
    fcn_0804d910 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f010 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1846 (void) {
    ecx = eax;
    eax = *((ebx + 0xc));
    edx = *((ebx + 0x10));
    ecx = *(ecx);
    ecx = ecx + edx*2 - 2;
    ebx = *((ebx + 8));
    return caml_send0 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c110 */
#include <stdint.h>
 
int32_t camlUnix_fun_2634 (void) {
    eax = unix_setuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068679 */
#include <stdint.h>
 
int32_t caml_fl_add_blocks (int32_t arg_8h) {
    eax = *((ebp + 8));
    edx = *((eax - 4));
    edx >>= 0xa;
    ecx = caml_fl_cur_size;
    edx = ecx + edx + 1;
    *(obj.caml_fl_cur_size) = edx;
    edx = fl_last;
    if (eax > edx) {
        *(edx) = eax;
        if (edx == *(obj.caml_fl_merge)) {
            if (eax >= *(obj.caml_gc_sweep_hp)) {
                goto label_0;
            }
            eax = *((eax + 4));
            *(obj.caml_fl_merge) = eax;
        }
label_0:
        if (*(obj.caml_allocation_policy) != 1) {
            goto label_1;
        }
        eax = flp_size;
        if (eax > 0x3e7) {
            goto label_1;
        }
        *((eax*4 + obj.flp)) = edx;
        eax++;
        *(obj.flp_size) = eax;
        goto label_1;
    }
    ecx = .comment;
    if (ecx != 0) {
        if (eax > ecx) {
            goto label_2;
        }
    }
    ebx = 0x8084668;
    goto label_3;
    do {
        ecx = edx;
label_2:
        edx = *(ecx);
        if (edx == 0) {
            goto label_4;
        }
    } while (eax > edx);
label_4:
    ebx = ecx;
    ecx = edx;
label_3:
    edx = eax + 4;
    esi = *(edx);
    *(esi) = ecx;
    *(ebx) = eax;
    if (ebx == *(obj.caml_fl_merge)) {
        if (eax >= *(obj.caml_gc_sweep_hp)) {
            goto label_5;
        }
        edx = *(edx);
        *(obj.caml_fl_merge) = edx;
    }
label_5:
    if (*(obj.caml_allocation_policy) == 1) {
        truncate_flp ();
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8072759 */
#include <stdint.h>
 
uint32_t rotate_right32 (uint32_t value, uint32_t count) {
    const uint32_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
int32_t caml_MD5Transform (void * arg_8h, void * arg_ch) {
    int32_t var_64h;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    edx = *(edx);
    *((ebp - 0x5c)) = edx;
    ecx = *((ebp + 8));
    ecx += 4;
    *((ebp - 0x54)) = ecx;
    esi = *(ecx);
    ebx = *((ebp + 8));
    ebx += 8;
    *((ebp - 0x50)) = ebx;
    ecx = *(ebx);
    edi = *((ebp + 8));
    edi += 0xc;
    *((ebp - 0x4c)) = edi;
    edx = *(edi);
    ebx = *(eax);
    *((ebp - 0x48)) = ebx;
    edi = *((ebp - 0x5c));
    edi = edi + ebx - 0x28955b88;
    ebx = edx;
    ebx ^= ecx;
    ebx &= esi;
    ebx ^= edx;
    ebx += edi;
    ebx = rotate_right32 (ebx, 0x19);
    ebx += esi;
    edi = *((eax + 4));
    *((ebp - 0x44)) = edi;
    edx = edx + edi - 0x173848aa;
    *((ebp - 0x10)) = edx;
    edx = ecx;
    edx ^= esi;
    edx &= ebx;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += ebx;
    edi = *((eax + 8));
    *((ebp - 0x40)) = edi;
    ecx = ecx + edi + 0x242070db;
    *((ebp - 0x10)) = ecx;
    ecx = ebx;
    ecx ^= esi;
    ecx &= edx;
    ecx ^= esi;
    ecx += *((ebp - 0x10));
    ecx = rotate_right32 (ecx, 0xf);
    ecx += edx;
    edi = *((eax + 0xc));
    *((ebp - 0x3c)) = edi;
    esi = esi + edi - 0x3e423112;
    *((ebp - 0x10)) = esi;
    esi = edx;
    esi ^= ebx;
    esi &= ecx;
    esi ^= ebx;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0xa);
    esi += ecx;
    edi = *((eax + 0x10));
    *((ebp - 0x38)) = edi;
    ebx = ebx + edi - 0xa83f051;
    *((ebp - 0x10)) = ebx;
    ebx = ecx;
    ebx ^= edx;
    ebx &= esi;
    ebx ^= edx;
    ebx += *((ebp - 0x10));
    ebx = rotate_right32 (ebx, 0x19);
    ebx += esi;
    edi = *((eax + 0x14));
    *((ebp - 0x34)) = edi;
    edx = edx + edi + 0x4787c62a;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx ^= ecx;
    edx &= ebx;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += ebx;
    edi = *((eax + 0x18));
    *((ebp - 0x30)) = edi;
    ecx = ecx + edi - 0x57cfb9ed;
    *((ebp - 0x10)) = ecx;
    ecx = ebx;
    ecx ^= esi;
    ecx &= edx;
    ecx ^= esi;
    ecx += *((ebp - 0x10));
    ecx = rotate_right32 (ecx, 0xf);
    ecx += edx;
    edi = *((eax + 0x1c));
    *((ebp - 0x2c)) = edi;
    esi = esi + edi - 0x2b96aff;
    *((ebp - 0x10)) = esi;
    esi = edx;
    esi ^= ebx;
    esi &= ecx;
    esi ^= ebx;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0xa);
    esi += ecx;
    edi = *((eax + 0x20));
    *((ebp - 0x28)) = edi;
    ebx = ebx + edi + 0x698098d8;
    *((ebp - 0x10)) = ebx;
    ebx = ecx;
    ebx ^= edx;
    ebx &= esi;
    ebx ^= edx;
    ebx += *((ebp - 0x10));
    ebx = rotate_right32 (ebx, 0x19);
    ebx += esi;
    edi = *((eax + 0x24));
    *((ebp - 0x24)) = edi;
    edx = edx + edi - 0x74bb0851;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx ^= ecx;
    edx &= ebx;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += ebx;
    edi = *((eax + 0x28));
    *((ebp - 0x20)) = edi;
    ecx = ecx + edi - 0xa44f;
    *((ebp - 0x10)) = ecx;
    ecx = ebx;
    ecx ^= esi;
    ecx &= edx;
    ecx ^= esi;
    ecx += *((ebp - 0x10));
    ecx = rotate_right32 (ecx, 0xf);
    ecx += edx;
    edi = *((eax + 0x2c));
    *((ebp - 0x1c)) = edi;
    esi = esi + edi - 0x76a32842;
    *((ebp - 0x10)) = esi;
    esi = edx;
    esi ^= ebx;
    esi &= ecx;
    esi ^= ebx;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0xa);
    esi += ecx;
    edi = *((eax + 0x30));
    *((ebp - 0x18)) = edi;
    ebx = ebx + edi + 0x6b901122;
    edi = ecx;
    edi ^= edx;
    edi &= esi;
    edi ^= edx;
    edi = ebx + edi;
    edi = rotate_right32 (edi, 0x19);
    edi += esi;
    ebx = *((eax + 0x34));
    *((ebp - 0x14)) = ebx;
    edx = edx + ebx - 0x2678e6d;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx ^= ecx;
    edx &= edi;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += edi;
    ebx = *((eax + 0x38));
    *((ebp - 0x10)) = ebx;
    ecx = ecx + ebx - 0x5986bc72;
    ebx = edi;
    ebx ^= esi;
    ebx &= edx;
    ebx ^= esi;
    ebx = ecx + ebx;
    ebx = rotate_right32 (ebx, 0xf);
    ebx += edx;
    ecx = *((eax + 0x3c));
    eax = esi + ecx + 0x49b40821;
    esi = edx;
    esi ^= edi;
    esi &= ebx;
    esi ^= edi;
    esi = eax + esi;
    esi = rotate_right32 (esi, 0xa);
    esi += ebx;
    eax = *((ebp - 0x44));
    edi = edi + eax - 0x9e1da9e;
    eax = esi;
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax = edi + eax;
    eax = rotate_right32 (eax, 0x1b);
    eax += esi;
    edi = *((ebp - 0x30));
    edx = edx + edi - 0x3fbf4cc0;
    *((ebp - 0x58)) = edx;
    edx = eax;
    edx ^= esi;
    edx &= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    edi = *((ebp - 0x1c));
    ebx = ebx + edi + 0x265e5a51;
    *((ebp - 0x58)) = ebx;
    ebx = edx;
    ebx ^= eax;
    ebx &= esi;
    ebx ^= eax;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = *((ebp - 0x48));
    esi = esi + edi - 0x16493856;
    *((ebp - 0x58)) = esi;
    esi = ebx;
    esi ^= edx;
    esi &= eax;
    esi ^= edx;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0xc);
    esi += ebx;
    edi = *((ebp - 0x34));
    eax = eax + edi - 0x29d0efa3;
    *((ebp - 0x58)) = eax;
    eax = esi;
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax += *((ebp - 0x58));
    eax = rotate_right32 (eax, 0x1b);
    eax += esi;
    edi = *((ebp - 0x20));
    edx = edx + edi + 0x2441453;
    *((ebp - 0x58)) = edx;
    edx = eax;
    edx ^= esi;
    edx &= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    edi = ebx + ecx - 0x275e197f;
    ebx = edx;
    ebx ^= eax;
    ebx &= esi;
    ebx ^= eax;
    ebx = edi + ebx;
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = *((ebp - 0x38));
    esi = esi + edi - 0x182c0438;
    *((ebp - 0x58)) = esi;
    esi = ebx;
    esi ^= edx;
    esi &= eax;
    esi ^= edx;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0xc);
    esi += ebx;
    edi = *((ebp - 0x24));
    eax = eax + edi + 0x21e1cde6;
    *((ebp - 0x58)) = eax;
    eax = esi;
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax += *((ebp - 0x58));
    eax = rotate_right32 (eax, 0x1b);
    eax += esi;
    edi = *((ebp - 0x10));
    edx = edx + edi - 0x3cc8f82a;
    *((ebp - 0x58)) = edx;
    edx = eax;
    edx ^= esi;
    edx &= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    edi = *((ebp - 0x3c));
    ebx = ebx + edi - 0xb2af279;
    *((ebp - 0x58)) = ebx;
    ebx = edx;
    ebx ^= eax;
    ebx &= esi;
    ebx ^= eax;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = *((ebp - 0x28));
    esi = esi + edi + 0x455a14ed;
    edi = ebx;
    edi ^= edx;
    edi &= eax;
    edi ^= edx;
    edi = esi + edi;
    edi = rotate_right32 (edi, 0xc);
    edi += ebx;
    *((ebp - 0x58)) = edi;
    esi = *((ebp - 0x14));
    edi = eax + esi - 0x561c16fb;
    eax = *((ebp - 0x58));
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax = edi + eax;
    eax = rotate_right32 (eax, 0x1b);
    eax += *((ebp - 0x58));
    *((ebp - 0x60)) = eax;
    edi = *((ebp - 0x40));
    eax = edx + edi - 0x3105c08;
    edx = *((ebp - 0x60));
    edx ^= *((ebp - 0x58));
    edx &= ebx;
    edx ^= *((ebp - 0x58));
    edx = eax + edx;
    edx = rotate_right32 (edx, 0x17);
    edx += *((ebp - 0x60));
    esi = *((ebp - 0x2c));
    eax = ebx + esi + 0x676f02d9;
    ebx = *((ebp - 0x60));
    ebx ^= edx;
    ebx &= *((ebp - 0x58));
    ebx ^= *((ebp - 0x60));
    ebx = eax + ebx;
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = ebx;
    edi ^= edx;
    *((ebp - 0x64)) = edi;
    edi = *((ebp - 0x58));
    eax = *((ebp - 0x18));
    esi = edi + eax - 0x72d5b376;
    eax = *((ebp - 0x60));
    eax &= *((ebp - 0x64));
    eax ^= edx;
    edi = esi + eax;
    edi = rotate_right32 (edi, 0xc);
    edi += ebx;
    eax = *((ebp - 0x60));
    esi = *((ebp - 0x34));
    esi = eax + esi - 0x5c6be;
    *((ebp - 0x58)) = esi;
    esi = *((ebp - 0x64));
    esi ^= edi;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0x1c);
    esi += edi;
    eax = *((ebp - 0x28));
    edx = edx + eax - 0x788e097f;
    *((ebp - 0x58)) = edx;
    edx = edi;
    edx ^= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x15);
    edx += esi;
    eax = *((ebp - 0x1c));
    ebx = ebx + eax + 0x6d9d6122;
    *((ebp - 0x58)) = ebx;
    ebx = esi;
    ebx ^= edi;
    ebx ^= edx;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x10);
    ebx += edx;
    eax = *((ebp - 0x10));
    edi = edi + eax - 0x21ac7f4;
    *((ebp - 0x58)) = edi;
    edi = edx;
    edi ^= esi;
    edi ^= ebx;
    edi += *((ebp - 0x58));
    edi = rotate_right32 (edi, 9);
    edi += ebx;
    eax = *((ebp - 0x44));
    esi = esi + eax - 0x5b4115bc;
    eax = ebx;
    eax ^= edx;
    eax ^= edi;
    eax = esi + eax;
    eax = rotate_right32 (eax, 0x1c);
    eax += edi;
    esi = *((ebp - 0x38));
    edx = edx + esi + 0x4bdecfa9;
    esi = edi;
    esi ^= ebx;
    esi ^= eax;
    esi = edx + esi;
    esi = rotate_right32 (esi, 0x15);
    esi += eax;
    edx = *((ebp - 0x2c));
    ebx = ebx + edx - 0x944b4a0;
    *((ebp - 0x58)) = ebx;
    ebx = eax;
    ebx ^= edi;
    ebx ^= esi;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x10);
    ebx += esi;
    edx = *((ebp - 0x20));
    edi = edi + edx - 0x41404390;
    edx = esi;
    edx ^= eax;
    edx ^= ebx;
    edx = edi + edx;
    edx = rotate_right32 (edx, 9);
    edx += ebx;
    edi = *((ebp - 0x14));
    eax = eax + edi + 0x289b7ec6;
    edi = ebx;
    edi ^= esi;
    edi ^= edx;
    edi = eax + edi;
    edi = rotate_right32 (edi, 0x1c);
    edi += edx;
    eax = *((ebp - 0x48));
    esi = esi + eax - 0x155ed806;
    *((ebp - 0x58)) = esi;
    esi = edx;
    esi ^= ebx;
    esi ^= edi;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0x15);
    esi += edi;
    eax = *((ebp - 0x3c));
    ebx = ebx + eax - 0x2b10cf7b;
    eax = edi;
    eax ^= edx;
    eax ^= esi;
    eax = ebx + eax;
    eax = rotate_right32 (eax, 0x10);
    eax += esi;
    ebx = *((ebp - 0x30));
    edx = edx + ebx + 0x4881d05;
    ebx = esi;
    ebx ^= edi;
    ebx ^= eax;
    ebx = edx + ebx;
    ebx = rotate_right32 (ebx, 9);
    ebx += eax;
    edx = *((ebp - 0x24));
    edi = edi + edx - 0x262b2fc7;
    *((ebp - 0x58)) = edi;
    edi = eax;
    edi ^= esi;
    edi ^= ebx;
    edi += *((ebp - 0x58));
    edi = rotate_right32 (edi, 0x1c);
    edi += ebx;
    edx = *((ebp - 0x18));
    esi = esi + edx - 0x1924661b;
    edx = ebx;
    edx ^= eax;
    edx ^= edi;
    edx = esi + edx;
    edx = rotate_right32 (edx, 0x15);
    edx += edi;
    eax = eax + ecx + 0x1fa27cf8;
    esi = edi;
    esi ^= ebx;
    esi ^= edx;
    esi = eax + esi;
    esi = rotate_right32 (esi, 0x10);
    esi += edx;
    eax = *((ebp - 0x40));
    ebx = ebx + eax - 0x3b53a99b;
    *((ebp - 0x58)) = ebx;
    ebx = edx;
    ebx ^= edi;
    ebx ^= esi;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 9);
    ebx += esi;
    eax = *((ebp - 0x48));
    edi = edi + eax - 0xbd6ddbc;
    eax = edx;
    eax = ~eax;
    eax |= ebx;
    eax ^= esi;
    eax = edi + eax;
    eax = rotate_right32 (eax, 0x1a);
    eax += ebx;
    edi = *((ebp - 0x2c));
    edx = edx + edi + 0x432aff97;
    *((ebp - 0x2c)) = edx;
    edx = esi;
    edx = ~edx;
    edx |= eax;
    edx ^= ebx;
    edx += *((ebp - 0x2c));
    edx = rotate_right32 (edx, 0x16);
    edx += eax;
    edi = *((ebp - 0x10));
    esi = esi + edi - 0x546bdc59;
    *((ebp - 0x10)) = esi;
    esi = ebx;
    esi = ~esi;
    esi |= edx;
    esi ^= eax;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0x11);
    esi += edx;
    edi = *((ebp - 0x34));
    ebx = ebx + edi - 0x36c5fc7;
    *((ebp - 0x10)) = ebx;
    ebx = eax;
    ebx = ~ebx;
    ebx |= esi;
    ebx ^= edx;
    ebx += *((ebp - 0x10));
    ebx = rotate_right32 (ebx, 0xb);
    ebx += esi;
    edi = *((ebp - 0x18));
    eax = eax + edi + 0x655b59c3;
    edi = edx;
    edi = ~edi;
    edi |= ebx;
    edi ^= esi;
    edi = eax + edi;
    edi = rotate_right32 (edi, 0x1a);
    edi += ebx;
    eax = *((ebp - 0x3c));
    edx = edx + eax - 0x70f3336e;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx = ~edx;
    edx |= edi;
    edx ^= ebx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x16);
    edx += edi;
    eax = *((ebp - 0x20));
    esi = esi + eax - 0x100b83;
    *((ebp - 0x10)) = esi;
    esi = ebx;
    esi = ~esi;
    esi |= edx;
    esi ^= edi;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0x11);
    esi += edx;
    eax = *((ebp - 0x44));
    ebx = ebx + eax - 0x7a7ba22f;
    eax = edi;
    eax = ~eax;
    eax |= esi;
    eax ^= edx;
    eax = ebx + eax;
    eax = rotate_right32 (eax, 0xb);
    eax += esi;
    ebx = *((ebp - 0x28));
    edi = edi + ebx + 0x6fa87e4f;
    ebx = edx;
    ebx = ~ebx;
    ebx |= eax;
    ebx ^= esi;
    ebx = edi + ebx;
    ebx = rotate_right32 (ebx, 0x1a);
    ebx += eax;
    ecx = edx + ecx - 0x1d31920;
    edx = esi;
    edx = ~edx;
    edx |= ebx;
    edx ^= eax;
    edx = ecx + edx;
    edx = rotate_right32 (edx, 0x16);
    edx += ebx;
    edi = *((ebp - 0x30));
    esi = esi + edi - 0x5cfebcec;
    ecx = eax;
    ecx = ~ecx;
    ecx |= edx;
    ecx ^= ebx;
    ecx = esi + ecx;
    ecx = rotate_right32 (ecx, 0x11);
    ecx += edx;
    edi = *((ebp - 0x14));
    esi = eax + edi + 0x4e0811a1;
    eax = ebx;
    eax = ~eax;
    eax |= ecx;
    eax ^= edx;
    eax = esi + eax;
    eax = rotate_right32 (eax, 0xb);
    eax += ecx;
    edi = *((ebp - 0x38));
    esi = ebx + edi - 0x8ac817e;
    ebx = edx;
    ebx = ~ebx;
    ebx |= eax;
    ebx ^= ecx;
    ebx = esi + ebx;
    ebx = rotate_right32 (ebx, 0x1a);
    ebx += eax;
    edi = *((ebp - 0x1c));
    esi = edx + edi - 0x42c50dcb;
    edx = ecx;
    edx = ~edx;
    edx |= ebx;
    edx ^= eax;
    edx = esi + edx;
    edx = rotate_right32 (edx, 0x16);
    edx += ebx;
    edi = *((ebp - 0x40));
    esi = ecx + edi + 0x2ad7d2bb;
    ecx = eax;
    ecx = ~ecx;
    ecx |= edx;
    ecx ^= ebx;
    ecx = esi + ecx;
    ecx = rotate_right32 (ecx, 0x11);
    ecx += edx;
    edi = *((ebp - 0x24));
    esi = eax + edi - 0x14792c6f;
    eax = ebx;
    eax = ~eax;
    eax |= ecx;
    eax ^= edx;
    eax = esi + eax;
    ebx += *((ebp - 0x5c));
    esi = *((ebp + 8));
    *(esi) = ebx;
    ebx = ecx;
    edi = *((ebp - 0x54));
    ebx += *(edi);
    eax = rotate_right32 (eax, 0xb);
    eax = ebx + eax;
    *(edi) = eax;
    eax = *((ebp - 0x50));
    *(eax) += ecx;
    ecx = *((ebp - 0x4c));
    *(ecx) += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c3ee */
#include <stdint.h>
 
int32_t caml_le_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80560e0 */
#include <stdint.h>
 
int32_t camlString_uncapitalize_1106 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_apply1_1100 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80558a0 */
#include <stdint.h>
 
uint32_t camlString_copy_1042 (void) {
    int32_t var_4h;
    ecx = eax;
    *((esp + 4)) = ecx;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    *(esp) = eax;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    eax = *((esp + 0x14));
    caml_blit_string (eax, 1, ebx, 1, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056150 */
#include <stdint.h>
 
void camlString_index_1113 (void) {
    edx = ebx;
    ecx = 1;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    esi = *((eax + ebx));
    ebx -= esi;
    ebx = ebx + ebx + 1;
    return camlString_index_rec_1108 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061a24 */
#include <stdint.h>
 
uint32_t unix_access (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t mode;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16ed7;
    esi = *((ebp + 8));
    eax = ebx + 0xb894;
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, eax);
    eax = access (esi, eax);
    if (eax == -1) {
        eax = ebx - 0x2659;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a554 */
#include <stdint.h>
 
int32_t caml_convert_flag_list (int32_t arg_8h, char * arg_ch) {
    edx = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = 0;
    if (edx == 1) {
        goto label_0;
    }
    do {
        ecx = *(edx);
        ecx >>= 1;
        eax |= *((ebx + ecx*4));
        edx = *((edx + 4));
    } while (edx != 1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a204 */
#include <stdint.h>
 
void access (void) {
    access ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058590 */
#include <stdint.h>
 
int32_t camlMarshal_entry (void) {
    *(0x807f940) = loc.camlMarshal__6;
    *(loc.camlMarshal) = 0x807f998;
    eax = loc.camlMarshal__4;
    *(0x807f93c) = eax;
    *(0x807f948) = 0x29;
    eax = loc.camlMarshal__3;
    *(0x807f94c) = eax;
    eax = loc.camlMarshal__2;
    *(0x807f950) = eax;
    eax = camlMarshal__1;
    *(0x807f944) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070d59 */
#include <stdint.h>
 
uint32_t caml_sys_get_argv (void) {
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x10)) = 0;
    *((ebp - 0x14)) = 0;
    *((ebp - 0x34)) = ebx;
    eax = ebp - 0x34;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x2c)) = 1;
    *((ebp - 0x30)) = 3;
    eax = ebp - 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x14;
    *((ebp - 0x20)) = eax;
    eax = caml_exe_name;
    eax = caml_copy_string (ebx);
    *((ebp - 0xc)) = eax;
    eax = caml_main_argv;
    eax = caml_copy_string_array (eax);
    *((ebp - 0x10)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0x14)) = eax;
    edx = *((ebp - 0xc));
    *(eax) = edx;
    edx = *((ebp - 0x10));
    eax = *((ebp - 0x14));
    *((eax + 4)) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x14));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fc80 */
#include <stdint.h>
 
int32_t camlPervasives_flush_all_1185 (void) {
    eax = loc.camlPervasives__92;
    eax = caml_ml_out_channels_list;
    caml_c_call (1);
    return camlPervasives_iter_1186 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e4c0 */
#include <stdint.h>
 
int32_t camlPrintf_kbprintf_1397 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlPrintf__fun_1694;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            ebp = .comment;
            esi = loc.camlPrintf__42;
            edx = .comment;
            ecx = .comment;
            eax = 1;
            *(loc.caml_extra_params) = ebp;
            void (*0x804b470)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056ac0 */
#include <stdint.h>
 
int32_t camlHashtbl_remove_bucket_1083 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        *((esp + 8)) = ebx;
        ecx = *((eax + 8));
        *((esp + 0xc)) = ecx;
        ecx = *((eax + 4));
        *((esp + 4)) = ecx;
        eax = *(eax);
        *(esp) = eax;
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = *((esp + 8));
            eax = *((eax + 8));
            *(eax) += 0xfffffffe;
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_remove_bucket_1083 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            *((eax + 8)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070cd5 */
#include <stdint.h>
 
uint32_t caml_sys_get_config (void) {
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x10)) = 0;
    *((ebp - 0x30)) = ebx;
    eax = ebp - 0x30;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x28)) = 1;
    *((ebp - 0x2c)) = 2;
    eax = ebp - 0xc;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x20)) = eax;
    eax = caml_copy_string (ebx);
    *((ebp - 0x10)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0xc)) = eax;
    edx = *((ebp - 0x10));
    *(eax) = edx;
    eax = *((ebp - 0xc));
    *((eax + 4)) = 0x41;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071be1 */
#include <stdint.h>
 
int32_t caml_gc_compaction (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (0x10, "Heap compaction requested\n", 0);
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    caml_final_do_calls ();
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    caml_compact_heap ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069461 */
#include <stdint.h>
 
int32_t caml_finish_major_cycle (void) {
    int32_t var_10h;
    int32_t var_ch;
    if (*(obj.caml_gc_phase) == 2) {
        start_cycle ();
    }
    if (*(obj.caml_gc_phase) != 0) {
        goto label_0;
    }
    do {
        eax = 0x7fffffff;
        mark_slice ();
    } while (*(obj.caml_gc_phase) == 0);
label_0:
    if (*(obj.caml_gc_phase) != 1) {
        goto label_1;
    }
    do {
        eax = 0x7fffffff;
        sweep_slice ();
    } while (*(obj.caml_gc_phase) == 1);
label_1:
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *(obj.caml_stat_major_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_allocated_words) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050170 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_endline_1285 (void) {
    ebx = eax;
    eax = .comment;
    camlPervasives_output_string_1191 ();
    eax = caml_ml_output_char;
    caml_c_call (*(0x807c030));
    eax = caml_ml_flush;
    caml_c_call (*(0x807c030));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fca0 */
#include <stdint.h>
 
int32_t camlPervasives_output_string_1191 (void) {
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx + 1;
    eax = caml_ml_output;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804faa0 */
#include <stdint.h>
 
int32_t camlPervasives_string_of_bool_1127 (void) {
    if (eax != 1) {
        eax = "true";
        return eax;
    }
    eax = "false";
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c3f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2718 (void) {
    eax = unix_chown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80672ae */
#include <stdint.h>
 
int32_t caml_init_frame_descriptors (void) {
    int32_t var_20h;
    uint32_t var_1ch;
    if (*(obj.inited.3139) != 0) {
        goto label_3;
    }
    eax = caml_frametable;
    if (eax == 0) {
        goto label_4;
    }
    ebx = 0;
    esi = caml_frametable;
    do {
        caml_register_frametable (eax);
        ebx++;
        eax = *((esi + ebx*4));
    } while (eax != 0);
label_4:
    *(obj.inited.3139) = 1;
label_3:
    eax = frametables;
    if (eax == 0) {
        goto label_5;
    }
    edx = 0;
    do {
        ecx = *(eax);
        edx += *(ecx);
        eax = *((eax + 4));
    } while (eax != 0);
    edx += edx;
    if (edx <= 4) {
        goto label_5;
    }
    ebx = 4;
    do {
        ebx += ebx;
    } while (ebx < edx);
    eax = ebx*4;
    eax = caml_stat_alloc (eax);
    *(obj.caml_frame_descriptors) = eax;
    if (ebx > 0) {
        goto label_6;
    }
    goto label_7;
    do {
label_2:
        edx = caml_frame_descriptors;
        *((edx + eax*4)) = 0;
        eax++;
    } while (eax < ebx);
label_7:
    ebx--;
    *(obj.caml_frame_descriptors_mask) = ebx;
    eax = frametables;
    *((ebp - 0x20)) = eax;
    if (eax == 0) {
        goto label_8;
    }
label_1:
    eax = *((ebp - 0x20));
    esi = *(eax);
    eax = *(esi);
    *((ebp - 0x1c)) = eax;
    if (eax <= 0) {
        goto label_9;
    }
    esi += 4;
    edi = 0;
label_0:
    ebx = caml_frame_descriptors_mask;
    eax = *(esi);
    eax >>= 3;
    eax &= ebx;
    ecx = caml_frame_descriptors;
    edx = ecx + eax*4;
    if (*(edx) == 0) {
        goto label_10;
    }
    do {
        eax++;
        eax &= ebx;
        edx = ecx + eax*4;
    } while (*(edx) != 0);
label_10:
    *(edx) = esi;
    eax = *((esi + 6));
    eax = esi + eax*2 + 0xb;
    eax &= 0xfffffffc;
    edx = eax + 8;
    if ((*((esi + 4)) & 1) != 0) {
        eax = edx;
    }
    edi++;
    if (edi != *((ebp - 0x1c))) {
        esi = eax;
        goto label_0;
    }
label_9:
    eax = *((ebp - 0x20));
    eax = *((eax + 4));
    *((ebp - 0x20)) = eax;
    if (eax != 0) {
        goto label_1;
    }
    goto label_8;
label_5:
    eax = caml_stat_alloc (0x10);
    *(obj.caml_frame_descriptors) = eax;
    ebx = 4;
label_6:
    eax = 0;
    goto label_2;
label_8:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80647d9 */
#include <stdint.h>
 
uint32_t unix_send (int32_t flags, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, void * buffer, size_t length) {
    int32_t var_401ch;
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1411c;
    eax = ebx + 0xb904;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x401c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    edi = ebp - 0x4018;
    memmove (edi, eax, esi);
    caml_enter_blocking_section ();
    eax = *((ebp - 0x401c));
    eax = *((ebp + 8));
    eax >>= 1;
    eax = send (eax, edi, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x2486;
        uerror (eax, 0);
    }
    eax = esi + esi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a6c4 */
#include <stdint.h>
 
void send (void) {
    send ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804e420 */
#include <stdint.h>
 
int32_t camlUnix_establish_server_2026 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = ebx;
    eax = camlUnix_domain_of_sockaddr_1529 (eax, eax);
    eax = unix_socket;
    eax = caml_c_call (eax);
    ecx = 3;
    ebx = 5;
    camlUnix_setsockopt_1646 (eax);
    eax = *(esp);
    eax = *((esp + 8));
    eax = unix_bind;
    caml_c_call (eax);
    eax = *((esp + 8));
    eax = unix_listen;
    caml_c_call (eax);
    do {
label_0:
        eax = *((esp + 4));
        eax = camlUnix_accept_non_intr_2024 ();
        eax = *(eax);
        *((esp + 0xc)) = eax;
        eax = unix_fork;
        eax = caml_c_call (1);
        *(esp) = eax;
        if (eax == 1) {
            goto label_1;
        }
        eax = *((esp + 0xc));
        eax = unix_close;
        caml_c_call (eax);
        eax = *(esp);
        camlUnix_waitpid_non_intr_2001 ();
    } while (1);
label_1:
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        eax = 1;
        camlPervasives_exit_1326 ();
    }
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    camlUnix_try_set_close_on_exec_1366 ();
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    ecx = *((esp + 8));
    caml_apply2 ();
    eax = 1;
    camlPervasives_exit_1326 ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d8a1 */
#include <stdint.h>
 
uint32_t caml_ml_out_channels_list (void) {
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    esi = caml_local_roots;
    eax = ebp - 0x34;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0xc)) = 1;
    ebx = caml_all_opened_channels;
    if (ebx == 0) {
        goto label_0;
    }
    *((ebp - 0x10)) = 0;
    *((ebp - 0x14)) = 0;
    *((ebp - 0x34)) = esi;
    *((ebp - 0x2c)) = 1;
    *((ebp - 0x30)) = 3;
    eax = ebp - 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x14;
    *((ebp - 0x20)) = eax;
    do {
        if (*((ebx + 0x14)) == 0) {
            eax = caml_alloc_channel (ebx);
            *((ebp - 0x14)) = eax;
            eax = *((ebp - 0xc));
            *((ebp - 0x10)) = eax;
            eax = caml_alloc_small (2, 0);
            *((ebp - 0xc)) = eax;
            edx = *((ebp - 0x14));
            *(eax) = edx;
            edx = *((ebp - 0x10));
            eax = *((ebp - 0xc));
            *((eax + 4)) = edx;
        }
        ebx = *((ebx + 0x1c));
    } while (ebx != 0);
label_0:
    *(obj.caml_local_roots) = esi;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807567c */
#include <stdint.h>
 
uint32_t caml_search_exe_in_path (int32_t arg_8h) {
    int32_t var_24h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = ebp - 0x24;
    caml_ext_table_init (ebx, 8);
    eax = getenv ("PATH");
    eax = caml_decompose_path (ebx, eax);
    esi = eax;
    eax = *((ebp + 8));
    eax = caml_search_in_path (ebx, eax);
    edi = eax;
    caml_stat_free (esi);
    caml_ext_table_free (ebx, 0);
    eax = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806822a */
#include <stdint.h>
 
int32_t caml_ext_table_init (int32_t arg_8h, int32_t arg_ch) {
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    *(ebx) = 0;
    *((ebx + 4)) = eax;
    eax <<= 2;
    eax = caml_stat_alloc (ebx);
    *((ebx + 8)) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049fc4 */
#include <stdint.h>
 
void getenv (void) {
    getenv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80752fe */
#include <stdint.h>
 
int32_t caml_decompose_path (int32_t arg_8h, char * arg_ch) {
    char * src;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    edi = 0;
    if (ebx == 0) {
        goto label_1;
    }
    edi = ebx;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = caml_stat_alloc (ecx);
    edi = eax;
    strcpy (eax, ebx);
    ecx = edi;
label_0:
    eax = *(ecx);
    if (al != 0) {
        if (al != 0x3a) {
            goto label_2;
        }
    }
    ebx = ecx;
    goto label_3;
label_2:
    eax = ecx + 1;
    do {
        ebx = eax;
        edx = *(eax);
        eax++;
        if (dl == 0) {
            goto label_3;
        }
    } while (dl != 0x3a);
label_3:
    caml_ext_table_add (esi, ecx);
    if (*(ebx) != 0) {
        *(ebx) = 0;
        ecx = ebx + 1;
        goto label_0;
    }
label_1:
    eax = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80754c8 */
#include <stdint.h>
 
int32_t caml_search_in_path (int32_t arg_8h, char * arg_ch) {
    int32_t var_80h;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_68h;
    char * src;
    int32_t var_8h;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *(eax);
    if (dl == 0) {
        goto label_0;
    }
    if (dl != 0x2f) {
        goto label_1;
    }
    goto label_2;
    do {
        if (dl == 0x2f) {
            goto label_2;
        }
label_1:
        eax++;
        edx = *(eax);
    } while (dl != 0);
label_0:
    if (*(esi) <= 0) {
        goto label_2;
    }
    *((ebp - 0x7c)) = 0;
    do {
        edx = *((ebp - 0x7c));
        edx <<= 2;
        *((ebp - 0x80)) = edx;
        eax = *((esi + 8));
        edi = *((eax + edx));
        eax = 0;
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        edx = ecx;
        edx = ~edx;
        edi = *((ebp + 0xc));
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        edx += ecx;
        eax = caml_stat_alloc (edx);
        ebx = eax;
        eax = *((esi + 8));
        edx = *((ebp - 0x80));
        eax = *((eax + edx));
        strcpy (ebx, eax);
        if (*(ebx) != 0) {
            edi = ebx;
            eax = 0;
            ecx = 0xffffffff;
            __asm ("repne scasb al, byte es:[edi]");
            ecx = ~ecx;
            *((ebx + ecx - 1)) = 0x2f;
        }
        eax = *((ebp + 0xc));
        strcat (ebx, eax);
        edx = ebp - 0x78;
        *((esp + 8)) = edx;
        *((esp + 4)) = ebx;
        *(esp) = 3;
        eax = xstat64 ();
        if (eax == 0) {
            eax = *((ebp - 0x68));
            eax &= 0xf000;
            if (eax == 0x8000) {
                goto label_3;
            }
        }
        caml_stat_free (ebx);
        *((ebp - 0x7c))++;
        eax = *((ebp - 0x7c));
    } while (*(esi) > eax);
label_2:
    edi = *((ebp + 0xc));
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = caml_stat_alloc (ecx);
    ebx = eax;
    edx = *((ebp + 0xc));
    strcpy (eax, edx);
label_3:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80681a8 */
#include <stdint.h>
 
int32_t caml_ext_table_free (int32_t arg_8h, char * arg_ch) {
    esi = *((ebp + 8));
    if (*((ebp + 0xc)) == 0) {
        goto label_0;
    }
    if (*(esi) <= 0) {
        goto label_0;
    }
    ebx = 0;
    do {
        eax = *((esi + 8));
        eax = *((eax + ebx*4));
        caml_stat_free (eax);
        ebx++;
    } while (*(esi) > ebx);
label_0:
    eax = *((esi + 8));
    caml_stat_free (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8051410 */
#include <stdint.h>
 
uint32_t camlArray_bubbledown_1170 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        ecx = *((ecx + 0x10));
        eax = camlArray_maxson_1155 (ecx, eax, ebx);
        ebx = eax;
        esi = *(esp);
        ecx = *((esi + 0xc));
        eax = *((ecx - 4));
        edx = *((ecx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            eax >>= 9;
            if (eax <= ebx) {
                goto label_1;
            }
            edx = *((ecx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_2;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi + 0xc));
        edi = *((eax - 4));
        ecx = *((eax - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            edi >>= 9;
            ecx = *((esp + 8));
            if (edi <= ecx) {
                goto label_4;
            }
            caml_modify (eax + ecx*2 - 2, edx);
        } else {
            edi >>= 0xa;
            ecx = *((esp + 8));
            if (edi <= ecx) {
                goto label_5;
            }
            *(fp_stack--) = *(edx);
            *((eax + ecx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 4));
        ecx = esi;
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c3c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2714 (void) {
    eax = unix_umask;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067278 */
#include <stdint.h>
 
int32_t caml_register_frametable (int32_t arg_8h) {
    edx = frametables;
    eax = *((ebp + 8));
    eax = cons ();
    *(obj.frametables) = eax;
    eax = caml_frame_descriptors;
    if (eax != 0) {
        caml_stat_free (eax);
        *(obj.caml_frame_descriptors) = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f9e0 */
#include <stdint.h>
 
int32_t camlPervasives_lnot_1049 (void) {
    eax ^= 0xffffffff;
    eax |= 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f190 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_copy_1037 (void) {
    eax = caml_obj_dup;
    eax = caml_c_call (eax);
    ebx = .comment;
    camlCamlinternalOO_set_id_1033 (eax);
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f170 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_set_id_1033 (void) {
    ecx = eax;
    eax = *(ebx);
    *((ecx + 4)) = eax;
    eax += 2;
    *(ebx) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071236 */
#include <stdint.h>
 
uint32_t caml_sys_is_directory (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = ebx;
    *(esp) = 3;
    eax = xstat64 ();
    if (eax == -1) {
        caml_sys_error (ebx);
    }
    eax = *((ebp - 0x58));
    eax &= 0xf000;
    al = (eax == 0x4000) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049f54 */
#include <stdint.h>
 
void xstat64 (void) {
    xstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80749b5 */
#include <stdint.h>
 
int32_t caml_compact_heap_maybe (void) {
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_18h;
    int32_t var_14h;
    char * var_4h;
    int32_t var_8h;
    if (*(obj.caml_percent_max) <= 0xf423f) {
        if (*(obj.caml_stat_major_collections) <= 2) {
            goto label_0;
        }
        if (*(obj.caml_stat_heap_chunks) <= 2) {
            goto label_0;
        }
        edx = caml_fl_cur_size;
        eax = caml_fl_size_at_phase_change;
        ebx = 0;
        *((ebp - 0x18)) = edx;
        *((ebp - 0x14)) = ebx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_stack[0] *= *(0x8076acc);
        ebx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = ebx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_stack[0] *= *(0x807759c);
        fp_stack[0] += fp_stack[1];
        fp_stack++;
        *((ebp - 0xc)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0xc));
        *(fp_stack--) = 0.0;
        fp_stack--;
        if (fp_stack[0] > fp_stack[1]) {
            fp_stack++;
            ecx = 0;
            *((ebp - 0x18)) = edx;
            *((ebp - 0x14)) = ecx;
            *(fp_stack--) = *((ebp - 0x18));
        }
        edx = caml_stat_heap_size;
        edx >>= 2;
        ecx = 0;
        *((ebp - 0x18)) = edx;
        *((ebp - 0x14)) = ecx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        if (fp_stack[0] >= fp_stack[1]) {
            fp_stack++;
            fp_stack++;
            *(fp_stack--) = *(0x80763a8);
            *((ebp - 0x20)) = fp_stack[0];
            fp_stack--;
        } else {
            *(fp_stack--) = fp_stack[0];
            fp_stack[0] *= *(0x807747c);
            fp_tmp_1 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_1;
            fp_stack[0] -= fp_stack[2];
            fp_stack++;
            fp_stack[1] /= fp_stack[0];
            fp_stack++;
            *((ebp - 0x20)) = fp_stack[0];
            fp_stack--;
            *(fp_stack--) = *(0x80763a8);
            *(fp_stack--) = *((ebp - 0x20));
            __asm ("fcmovnbe st(0), st(1)");
            fp_stack[1] = fp_stack[0];
            fp_stack--;
            *((ebp - 0x20)) = fp_stack[0];
            fp_stack--;
        }
        caml_gc_message (0x200, "FL size at phase change = %lu\n", eax);
        eax = *((ebp - 0x1a));
        ah = 0xc;
        *((ebp - 0x1c)) = ax;
        *(fp_stack--) = *((ebp - 0x20));
        *((ebp - 0x18)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x18));
        caml_gc_message (0x200, "Estimated overhead = %lu%%\n", eax);
        eax = caml_percent_max;
        edx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = edx;
        *(fp_stack--) = *((ebp - 0x18));
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] < fp_stack[1]) {
            goto label_0;
        }
        caml_gc_message (0x200, "Automatic compaction triggered.\n", 0);
        caml_finish_major_cycle ();
        eax = caml_fl_cur_size;
        edx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = edx;
        *(fp_stack--) = *((ebp - 0x18));
        *(fp_stack--) = fp_stack[0];
        fp_stack[0] *= *(0x807747c);
        eax = caml_stat_heap_size;
        eax >>= 2;
        edx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = edx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_stack[2] -= fp_stack[0];
        fp_stack++;
        fp_stack[1] /= fp_stack[0];
        fp_stack++;
        *((ebp - 0xc)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0xc));
        eax = *((ebp - 0x1a));
        ah = 0xc;
        *((ebp - 0x1c)) = ax;
        *((ebp - 0x18)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x18));
        caml_gc_message (0x200, "Measured overhead: %lu%%\n", eax);
        caml_compact_heap ();
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c93e */
#include <stdint.h>
 
int32_t caml_log_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    log (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a6e4 */
#include <stdint.h>
 
void log (void) {
    log ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c63a */
#include <stdint.h>
 
uint32_t caml_copy_double (void) {
    *(fp_stack--) = *((ebp + 8));
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    edx = caml_young_ptr;
    eax = edx - 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        *(obj.caml_young_ptr) = edx;
        caml_minor_collection ();
        *(obj.caml_young_ptr) -= 0xc;
    }
    eax = caml_young_ptr;
    *(eax) = 0xbfd;
    eax = caml_young_ptr;
    eax += 4;
    *(fp_stack--) = *((ebp - 0x10));
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e081 */
#include <stdint.h>
 
uint32_t caml_ml_input_char (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebx + 0x10));
    if (eax >= *((ebx + 0x14))) {
        eax = caml_refill (ebx);
        edi = eax;
    } else {
        edi = *(eax);
        eax++;
        *((ebx + 0x10)) = eax;
    }
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    edi &= 0xff;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f7e0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_to_list_1202 (void) {
    if (eax == 1) {
        eax = 1;
        return eax;
    }
    return camlArray_to_list_1121 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050a90 */
#include <stdint.h>
 
int32_t camlArray_fill_1070 (void) {
    int32_t var_4h;
    int32_t var_8h;
label_0:
    edi = ecx;
    if (ebx == 1) {
        goto label_2;
    }
    *((esp + 8)) = eax;
    eax = *((ebx + 4));
    *(esp) = eax;
    eax = *(ebx);
    *((esp + 4)) = eax;
    ebx = 1;
    esi = *((eax - 4));
    eax = *((eax - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        esi >>= 9;
    } else {
        esi >>= 0xa;
    }
    esi |= 1;
    esi += 0xfffffffe;
    if (ebx > esi) {
        goto label_3;
    }
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            eax = *((ecx + ebx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((esp + 8));
        ebp = ecx + ebx - 1;
        edx = *((edi + 0xc));
        ecx = *((edx - 4));
        if (ecx != 0xfe) {
            eax = caml_modify (edx + ebp*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            *((edx + ebp*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = ebx;
        ebx += 2;
    } while (eax != esi);
label_3:
    eax = *((esp + 4));
    ebx = *((eax - 4));
    eax = *((eax - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        ebx >>= 9;
    } else {
        ebx >>= 0xa;
    }
    ebx |= 1;
    eax = *((esp + 8));
    eax += ebx;
    eax--;
    ebx = *(esp);
    ecx = edi;
    goto label_0;
label_2:
    eax = 1;
    return eax;
label_4:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d560 */
#include <stdint.h>
 
int32_t camlUnix_safe_dup_1894 (void) {
    int32_t var_4h;
    do {
        *(esp) = eax;
        eax = unix_dup;
        eax = caml_c_call (eax);
        if (eax >= 7) {
            return eax;
        }
        eax = *(esp);
        eax = camlUnix_safe_dup_1894 (eax);
    } while (1);
    *(esp) = eax;
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070cc0 */
#include <stdint.h>
 
int32_t caml_sys_init (int32_t arg_8h, char ** arg_ch) {
    eax = *((ebp + 8));
    *(obj.caml_exe_name) = eax;
    eax = *((ebp + 0xc));
    *(obj.caml_main_argv) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c144 */
#include <stdint.h>
 
int32_t caml_nativeint_to_int32 (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c112 */
#include <stdint.h>
 
void caml_copy_int32 (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    caml_alloc_custom (1, 4, 0);
    edx = *((ebp + 8));
    *((eax + 4)) = edx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ccd0 */
#include <stdint.h>
 
int32_t caml_string_length (uint32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    edx = *((eax + edx));
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c409 */
#include <stdint.h>
 
int32_t caml_lt_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] > fp_stack[1]) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054cf0 */
#include <stdint.h>
 
int32_t camlList_assq_1174 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        esi = *((ebx + 4));
        ecx = *(ebx);
        edx = *((ecx + 4));
        ecx = *(ecx);
        if (ecx == eax) {
            eax = edx;
            return eax;
        }
        ebx = esi;
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b16b */
#include <stdint.h>
 
int32_t caml_compare (int32_t arg_8h, int32_t arg_ch) {
    ecx = 1;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80882e0) {
        compare_free_stack ();
    }
    eax = 0xffffffff;
    if (ebx >= 0) {
        al = (ebx > 0) ? 1 : 0;
        eax = (int32_t) al;
        eax = eax + eax + 1;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054f00 */
#include <stdint.h>
 
int32_t camlList_find_1201 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, eax);
        if (eax != 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056d20 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_in_bucket_1125 (void) {
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        *((esp + 4)) = ebx;
        ecx = *((eax + 8));
        *(esp) = ecx;
        eax = *(eax);
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e9a0 */
#include <stdint.h>
 
uint32_t camlCamlinternalOO_fun_1706 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((edx + 0xc));
    eax = camlList_mem_1161 (eax, ebx, ecx);
    if (eax != 1) {
        eax = .comment;
        edx = *((eax + 0xc));
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        void (*0x8058ec0)() ();
    }
    eax = *((esp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b5d0 */
#include <stdint.h>
 
uint32_t caml_apply2 (void) {
    edx = *((ecx + 4));
    if (edx == 5) {
        edx = *((ecx + 8));
        void (*edx)() ();
    }
    edx = *(ecx);
    ebx = ecx;
    eax = void (*edx)(uint32_t) (ebx);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054bc0 */
#include <stdint.h>
 
int32_t camlList_mem_1161 (void) {
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 4)) = ecx;
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059290 */
#include <stdint.h>
 
int32_t camlMap_merge_1155 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    if (eax != 1) {
        if (ebx != 1) {
            eax = ebx;
            eax = camlMap_min_binding_1131 (ebx, eax);
            ebx = *((eax + 4));
            eax = *(eax);
            eax = *(esp);
            eax = camlMap_remove_min_binding_1147 (ebx, eax);
            edx = eax;
            eax = *((esp + 4));
            ebx = *((esp + 8));
            ecx = *((esp + 0xc));
            void (*0x8058c00)() ();
        }
        return eax;
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d745 */
#include <stdint.h>
 
int32_t caml_ml_pos_in (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_in (ebx);
    ebx = eax;
    if (edx >= 0) {
        if (edx <= 0) {
            if (eax <= 0x3fffffff) {
                goto label_0;
            }
        }
        errno_location ();
        *(eax) = 0x4b;
        caml_sys_error (1);
    }
label_0:
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f846 */
#include <stdint.h>
 
int32_t caml_output_value_to_string (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_1ch;
    void * s2;
    size_t n;
    init_extern_output (ebx, esi, edi);
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = extern_value ();
    ebx = extern_output_first;
    eax = caml_alloc_string (eax);
    *((ebp - 0x1c)) = eax;
    if (ebx == 0) {
        goto label_0;
    }
    edi = 0;
    do {
        eax = ebx + 8;
        esi = *((ebx + 4));
        esi -= eax;
        eax = *((ebp - 0x1c));
        eax = edi + eax;
        memmove (eax, eax, esi);
        edi += esi;
        esi = *(ebx);
        free (ebx);
        if (esi == 0) {
            goto label_0;
        }
        ebx = esi;
    } while (1);
label_0:
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bf10 */
#include <stdint.h>
 
int32_t camlUnix_fun_2574 (void) {
    eax = unix_tcgetattr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ae70 */
#include <stdint.h>
 
int32_t camlBuffer_advance_to_closing_1098 (void) {
    edi = edx;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x18f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x805a5d0;
            *((edx + 0xc)) = ebp;
            *((edx + 0x10)) = ebx;
            *((edx + 0x14)) = edi;
            eax = *((edi - 4));
            eax >>= 0xa;
            eax = eax*4 - 1;
            ebx = *((edi + eax));
            eax -= ebx;
            edi = eax + eax + 1;
            eax = ecx;
            ebx = esi;
            ecx = edi;
            void (*0x805a5d0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cd77 */
#include <stdint.h>
 
int32_t caml_bitvect_test (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax >>= 4;
    edx = *((ebp + 8));
    eax = *((eax + edx));
    ecx &= 7;
    edx = 1;
    edx <<= cl;
    eax &= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ee80 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1802 (void) {
    eax = ebx;
    ecx = *((eax + 8));
    ebx = *((eax + 0x10));
    eax = *((eax + 0xc));
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804aaf0 */
#include <stdint.h>
 
int32_t caml_curry9_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805a030 */
#include <stdint.h>
 
int32_t camlMap_Make_1355 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    int32_t var_20h;
    int32_t var_24h;
    int32_t var_28h;
    int32_t var_2ch;
    int32_t var_30h;
    int32_t var_34h;
    int32_t var_38h;
    int32_t var_3ch;
    int32_t var_40h;
    int32_t var_44h;
    int32_t var_48h;
    int32_t var_4ch;
    int32_t var_50h;
    int32_t var_54h;
    int32_t var_58h;
    int32_t var_5ch;
    int32_t var_60h;
    int32_t var_64h;
    int32_t var_68h;
    int32_t var_6ch;
    ebx = eax;
    *((esp + 4)) = ebx;
    esi = loc.camlMap__15;
    *((esp + 0xc)) = esi;
    do {
        eax = caml_young_ptr;
        eax -= 0x22c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *(esp) = eax;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry4;
            *((eax + 4)) = 9;
            *((eax + 8)) = 0x8058b40;
            *((eax + 0xc)) = esi;
            ecx = loc.camlMap__14;
            *((esp + 0x10)) = ecx;
            edx = eax + 0x14;
            *((esp + 0x14)) = edx;
            *((edx - 4)) = 0x14f7;
            *(edx) = sym.caml_curry4;
            *((edx + 4)) = 9;
            *((edx + 8)) = 0x8058c00;
            *((edx + 0xc)) = esi;
            *((edx + 0x10)) = eax;
            ecx = loc.camlMap__13;
            *((esp + 0x18)) = ecx;
            ecx = eax + 0x2c;
            *((esp + 0x1c)) = ecx;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry3;
            *((ecx + 4)) = 7;
            *((ecx + 8)) = 0x8058ec0;
            *((ecx + 0xc)) = ebx;
            *((ecx + 0x10)) = edx;
            ecx = eax + 0x44;
            *((esp + 0x20)) = ecx;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8059010;
            *((ecx + 0xc)) = ebx;
            ecx = eax + 0x58;
            *((esp + 0x24)) = ecx;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80590b0;
            *((ecx + 0xc)) = ebx;
            esi = loc.camlMap__12;
            *((esp + 8)) = esi;
            ebx = loc.camlMap__11;
            *((esp + 0x28)) = ebx;
            ecx = eax + 0x6c;
            *((esp + 0x2c)) = ecx;
            *((ecx - 4)) = 0xcf7;
            *(ecx) = sym.camlMap__remove_min_binding_1147;
            *((ecx + 4)) = 3;
            ebx = *((esp + 0x14));
            *((ecx + 8)) = ebx;
            edx = eax + 0x7c;
            *((esp + 0x30)) = edx;
            *((edx - 4)) = 0x18f7;
            *(edx) = sym.caml_curry2;
            *((edx + 4)) = 5;
            *((edx + 8)) = 0x8059290;
            *((edx + 0xc)) = ebx;
            *((edx + 0x10)) = esi;
            *((edx + 0x14)) = ecx;
            ecx = eax + 0x98;
            *((esp + 0x34)) = ecx;
            *((ecx - 4)) = 0x18f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8059300;
            eax = *((esp + 4));
            *((ecx + 0xc)) = eax;
            *((ecx + 0x10)) = ebx;
            *((ecx + 0x14)) = edx;
            eax = loc.camlMap__10;
            *((esp + 0x38)) = eax;
            eax = loc.camlMap__9;
            *((esp + 0x3c)) = eax;
            eax = loc.camlMap__8;
            *((esp + 0x40)) = eax;
            eax = loc.camlMap__7;
            *((esp + 0x44)) = eax;
            eax = loc.camlMap__6;
            *((esp + 0x48)) = eax;
            eax = loc.camlMap__5;
            *((esp + 0x4c)) = eax;
            ecx = *(esp);
            eax = ecx + 0xb4;
            *(esp) = eax;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x80596e0;
            edx = *((esp + 0x1c));
            *((eax + 0xc)) = edx;
            eax = ecx + 0xc8;
            *((esp + 0x50)) = eax;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x8059740;
            *((eax + 0xc)) = edx;
            eax = ecx + 0xdc;
            *((esp + 0x54)) = eax;
            *((eax - 4)) = 0x18f7;
            *(eax) = sym.caml_curry4;
            *((eax + 4)) = 9;
            *((eax + 8)) = 0x80597a0;
            *((eax + 0xc)) = ecx;
            ebx = *((esp + 0x14));
            *((eax + 0x10)) = ebx;
            *((eax + 0x14)) = edx;
            edx = ecx + 0xf8;
            *((esp + 0x58)) = edx;
            *((edx - 4)) = 0x18f7;
            *(edx) = sym.caml_curry2;
            *((edx + 4)) = 5;
            *((edx + 8)) = 0x80598e0;
            ebx = *((esp + 8));
            *((edx + 0xc)) = ebx;
            ebx = *((esp + 0x2c));
            *((edx + 0x10)) = ebx;
            *((edx + 0x14)) = eax;
            ebx = ecx + 0x114;
            *((esp + 0x5c)) = ebx;
            *((ebx - 4)) = 0x14f7;
            *(ebx) = sym.caml_curry4;
            *((ebx + 4)) = 9;
            *((ebx + 8)) = 0x8059960;
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = edx;
            esi = ecx + 0x12c;
            *((esp + 0x60)) = esi;
            *((esi - 4)) = 0x14f7;
            *(esi) = sym.caml_curry2;
            *((esi + 4)) = 5;
            *((esi + 8)) = 0x8059980;
            edx = *((esp + 4));
            *((esi + 0xc)) = edx;
            *((esi + 0x10)) = eax;
            edx = ecx + 0x144;
            *((esp + 0x64)) = edx;
            *((edx - 4)) = 0x18f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x8059b30;
            eax = *((esp + 0xc));
            *((edx + 0xc)) = eax;
            *((edx + 0x10)) = ebx;
            *((edx + 0x14)) = esi;
            edx = loc.camlMap__4;
            *((esp + 0x68)) = edx;
            ebx = ecx + 0x160;
            *((esp + 0x6c)) = ebx;
            *((ebx - 4)) = 0x14f7;
            *(ebx) = sym.caml_curry3;
            *((ebx + 4)) = 7;
            *((ebx + 8)) = 0x8059e40;
            eax = *((esp + 4));
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = edx;
            ebx = ecx + 0x178;
            *((ebx - 4)) = 0x14f7;
            *(ebx) = sym.caml_curry3;
            *((ebx + 4)) = 7;
            *((ebx + 8)) = 0x8059ed0;
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = edx;
            edi = loc.camlMap__2;
            esi = ecx + 0x190;
            *((esi - 4)) = 0xcf7;
            *(esi) = sym.camlMap__bindings_1352;
            *((esi + 4)) = 3;
            *((esi + 8)) = edi;
            edx = *((esp + 8));
            eax = ecx + 0x1a0;
            *((eax - 4)) = 0x8800;
            ebx = *((esp + 0xc));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            ebx = *((esp + 0x10));
            *((eax + 8)) = ebx;
            ebx = *((esp + 0x14));
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = 1;
            ebx = *((esp + 0x18));
            *((eax + 0x14)) = ebx;
            ebx = *((esp + 0x1c));
            *((eax + 0x18)) = ebx;
            ebx = *((esp + 0x20));
            *((eax + 0x1c)) = ebx;
            ebx = *((esp + 0x24));
            *((eax + 0x20)) = ebx;
            *((eax + 0x24)) = edx;
            ebx = *((esp + 0x28));
            *((eax + 0x28)) = ebx;
            ebx = *((esp + 0x2c));
            *((eax + 0x2c)) = ebx;
            ebx = *((esp + 0x30));
            *((eax + 0x30)) = ebx;
            ebx = *((esp + 0x34));
            *((eax + 0x34)) = ebx;
            ebx = *((esp + 0x38));
            *((eax + 0x38)) = ebx;
            ebx = *((esp + 0x3c));
            *((eax + 0x3c)) = ebx;
            ebx = *((esp + 0x40));
            *((eax + 0x40)) = ebx;
            ebx = *((esp + 0x44));
            *((eax + 0x44)) = ebx;
            ebx = *((esp + 0x48));
            *((eax + 0x48)) = ebx;
            ebx = *((esp + 0x4c));
            *((eax + 0x4c)) = ebx;
            ebx = *(esp);
            *((eax + 0x50)) = ebx;
            ebx = *((esp + 0x50));
            *((eax + 0x54)) = ebx;
            ebx = *((esp + 0x54));
            *((eax + 0x58)) = ebx;
            ebx = *((esp + 0x58));
            *((eax + 0x5c)) = ebx;
            ebx = *((esp + 0x5c));
            *((eax + 0x60)) = ebx;
            ebx = *((esp + 0x60));
            *((eax + 0x64)) = ebx;
            ebx = *((esp + 0x64));
            *((eax + 0x68)) = ebx;
            ebx = *((esp + 0x68));
            *((eax + 0x6c)) = ebx;
            ebx = *((esp + 0x6c));
            *((eax + 0x70)) = ebx;
            ebx = *((esp + 4));
            *((eax + 0x74)) = ebx;
            *((eax + 0x78)) = ebp;
            *((eax + 0x7c)) = edi;
            *((eax + 0x80)) = esi;
            *((eax + 0x84)) = edx;
            return eax;
        }
        caml_call_gc (ebx);
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805bee0 */
#include <stdint.h>
 
int32_t camlPrintf_incr_ac_1187 (void) {
    if (ebx == 0xc3) {
        edx = 5;
    } else {
        edx = 3;
    }
    if (ebx == 0xe5) {
        ebx = *((ecx + 0xc));
        *((ebx + 8)) += 2;
    }
    if (eax != 1) {
        ebx = *((ecx + 0xc));
        eax = *((ecx + 0xc));
        eax = *((eax + 4));
        eax = eax + edx - 1;
        *((ebx + 4)) = eax;
        eax = 1;
        return eax;
    }
    ebx = *((ecx + 0xc));
    eax = *((ecx + 0xc));
    eax = *(eax);
    eax = eax + edx - 1;
    *(ebx) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ae10 */
#include <stdint.h>
 
int32_t camlBuffer_closing_1097 (void) {
    if (eax == 0x51) {
        goto label_0;
    }
    while (1) {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Assert_failure;
            *((eax + 4)) = 0x80807a4;
            caml_raise_exn ();
            eax = 0xfb;
            return eax;
label_0:
            eax = 0x53;
            return eax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061e58 */
#include <stdint.h>
 
int32_t unix_dup2 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16aa8;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = dup2 ();
    if (eax == -1) {
        eax = ebx - 0x2611;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a2c4 */
#include <stdint.h>
 
void dup2 (void) {
    dup2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fd42 */
#include <stdint.h>
 
uint32_t caml_deserialize_float_8 (void) {
    int32_t var_10h;
    int32_t var_4h;
    eax = ebp - 0x10;
    caml_deserialize_block_float_8 (eax, 1);
    *(fp_stack--) = *((ebp - 0x10));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fd11 */
#include <stdint.h>
 
int32_t caml_deserialize_block_float_8 (void * s1, int32_t arg_ch) {
    void * s2;
    size_t * n;
    ebx = *((ebp + 0xc));
    ebx <<= 3;
    eax = intern_src;
    eax = *((ebp + 8));
    memmove (eax, eax, ebx);
    *(obj.intern_src) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bf30 */
#include <stdint.h>
 
int32_t camlUnix_fun_2578 (void) {
    eax = unix_getservbyname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071ee3 */
#include <stdint.h>
 
uint32_t caml_gc_get (void) {
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x2c)) = ebx;
    eax = ebp - 0x2c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x24)) = 1;
    *((ebp - 0x28)) = 1;
    eax = ebp - 0xc;
    *((ebp - 0x20)) = eax;
    eax = caml_alloc_tuple (ebx);
    *((ebp - 0xc)) = eax;
    edx = caml_minor_heap_size;
    edx >>= 2;
    edx = edx + edx + 1;
    caml_modify (eax, edx);
    eax = caml_major_heap_increment;
    eax >>= 2;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 4;
    caml_modify (eax, eax);
    eax = caml_percent_free;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 8;
    caml_modify (eax, eax);
    eax = caml_verb_gc;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 0xc;
    caml_modify (eax, eax);
    eax = caml_percent_max;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 0x10;
    caml_modify (eax, eax);
    eax = *((ebp - 0xc));
    eax += 0x14;
    caml_modify (eax, 1);
    eax = caml_allocation_policy;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 0x18;
    caml_modify (eax, eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a985 */
#include <stdint.h>
 
int32_t caml_alloc_tuple (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    caml_alloc (eax, 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a783 */
#include <stdint.h>
 
uint32_t caml_alloc (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t c;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    eax = esi*4 + 0x808b124;
    if (ebx == 0) {
        goto label_0;
    }
    if (ebx > 0x100) {
        goto label_1;
    }
    edx = ebx*4 + 4;
    edi = edx;
    edi = -edi;
    eax = edi;
    eax += *(obj.caml_young_ptr);
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        eax += edx;
        *(obj.caml_young_ptr) = eax;
        caml_minor_collection ();
        *(obj.caml_young_ptr) += edi;
    }
    eax = ebx;
    eax <<= 0xa;
    edx = esi + eax + 0x300;
    eax = caml_young_ptr;
    *(eax) = edx;
    ecx = caml_young_ptr;
    eax = ecx + 4;
    if (esi > 0xfa) {
        goto label_0;
    }
    edx = 0;
    do {
        *((ecx + edx*4 + 4)) = 0;
        edx++;
    } while (edx != ebx);
    goto label_0;
label_1:
    eax = caml_alloc_shr (ebx, esi);
    edi = eax;
    if (esi <= 0xfa) {
        ebx <<= 2;
        memset (eax, 0, ebx);
    }
    caml_check_urgent_gc (edi);
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069f5f */
#include <stdint.h>
 
int32_t caml_modify (uint32_t arg_8h, char * arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    edi = *(ebx);
    *(ebx) = esi;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) != 0) {
        if (*(obj.caml_gc_phase) == 0) {
            caml_darken (edi, 0);
        }
        if ((esi & 1) != 0) {
            goto label_0;
        }
        eax = caml_young_end;
        if (esi >= eax) {
            goto label_0;
        }
        edx = caml_young_start;
        if (esi <= edx) {
            goto label_0;
        }
        if ((edi & 1) == 0) {
            if (eax <= edi) {
                goto label_1;
            }
            if (edx < edi) {
                goto label_0;
            }
        }
label_1:
        eax = .comment;
        if (eax >= *(0x8087aac)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x8087aa8;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804aff0 */
#include <stdint.h>
 
int32_t caml_curry6_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065bd4 */
#include <stdint.h>
 
int32_t unix_symlink (char * path1, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    char * path2;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x12d27;
    esi = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = symlink (eax, esi);
    if (eax == -1) {
        eax = ebx - 0x2346;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a2a4 */
#include <stdint.h>
 
void symlink (void) {
    symlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80761d0 */
#include <stdint.h>
 
void libc_csu_fini (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f9fa */
#include <stdint.h>
 
int32_t caml_deserialize_sint_2 (void) {
    eax = intern_src;
    edx = eax + 2;
    *(obj.intern_src) = edx;
    eax = *(eax);
    eax <<= 8;
    edx = *((edx - 1));
    eax += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056310 */
#include <stdint.h>
 
void camlString_contains_1137 (void) {
    ecx = ebx;
    ebx = 1;
    return camlString_contains_from_1132 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80560f0 */
#include <stdint.h>
 
int32_t camlString_index_rec_1108 (void) {
    do {
        if (ecx >= ebx) {
label_0:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_1;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        esi = ecx;
        esi >>= 1;
        esi = *((eax + esi));
        esi = esi + esi + 1;
        if (esi == edx) {
            eax = ecx;
            return eax;
        }
        ecx += 2;
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f900 */
#include <stdint.h>
 
int32_t camlPervasives_invalid_arg_1012 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Invalid_argument;
            *((eax + 4)) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d380 */
#include <stdint.h>
 
int32_t camlPrintf_scan_positional_1291 (void) {
    esi = eax;
    edi = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x18f7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x805b520;
            eax = edx;
            eax += 0x10;
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = esi;
            *((ebx + 0x14)) = edi;
            eax = *((edx + 0x2c));
            ecx = esi;
            edx = ebp;
            void (*0x805e0b0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bee0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2570 (void) {
    eax = unix_tcsendbreak;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cb80 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_1643 (void) {
    eax = unix_getsockopt;
    caml_c_call (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c210 */
#include <stdint.h>
 
int32_t camlUnix_fun_2664 (void) {
    eax = unix_sigpending;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c020 */
#include <stdint.h>
 
int32_t camlUnix_fun_2606 (void) {
    eax = unix_socket;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061f10 */
#include <stdint.h>
 
int32_t unix_execv (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x169e8;
    edi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    esi = eax;
    *((esp + 4)) = eax;
    *(esp) = edi;
    execv ();
    caml_stat_free (esi);
    eax = ebx - 0x260c;
    return uerror (eax, edi);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80669c8 */
#include <stdint.h>
 
uint32_t cstringvect (int32_t arg_8h) {
    int32_t var_1ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x11f36;
    esi = *((ebp + 8));
    edi = *((esi - 4));
    edi >>= 0xa;
    eax = edi*4 + 4;
    eax = caml_stat_alloc (eax);
    *((ebp - 0x1c)) = eax;
    if (edi == 0) {
        goto label_0;
    }
    edx = 0;
    do {
        ecx = *((esi + edx*4));
        *((eax + edx*4)) = ecx;
        edx++;
    } while (edi > edx);
label_0:
    eax = *((ebp - 0x1c));
    *((eax + edi*4)) = 0;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a3a4 */
#include <stdint.h>
 
void execv (void) {
    execv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a5a4 */
#include <stdint.h>
 
void execve (void) {
    execve ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a3b4 */
#include <stdint.h>
 
void execvp (void) {
    execvp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a8b4 */
#include <stdint.h>
 
void fchmod (void) {
    fchmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b2a0 */
#include <stdint.h>
 
int32_t caml_curry4_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry4_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b3a0 */
#include <stdint.h>
 
int32_t caml_curry2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d723 */
#include <stdint.h>
 
int32_t caml_ml_pos_out_64 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_out (eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d683 */
#include <stdint.h>
 
int32_t caml_pos_out (int32_t arg_8h) {
    edx = *((ebp + 8));
    ebx = edx + 0x34;
    ecx = *((edx + 0x10));
    ecx -= ebx;
    ebx = ecx;
    ebx >>= 0x1f;
    eax = *((edx + 4));
    edx = *((edx + 8));
    eax += ecx;
    edx += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b9e4 */
#include <stdint.h>
 
int32_t caml_nativeint_of_string (int32_t arg_8h) {
    edx = 0x20;
    eax = *((ebp + 8));
    eax = parse_intnat ();
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b9b2 */
#include <stdint.h>
 
void caml_copy_nativeint (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    caml_alloc_custom (1, 4, 0);
    edx = *((ebp + 8));
    *((eax + 4)) = edx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ee90 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1806 (void) {
    esi = ebx;
    ecx = *((esi + 8));
    edx = *((esi + 0x10));
    ebx = *((eax + edx*2 - 2));
    eax = *((esi + 0xc));
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80637b4 */
#include <stdint.h>
 
int32_t unix_isatty (int32_t fd) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1514c;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = isatty (eax);
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a2e4 */
#include <stdint.h>
 
void isatty (void) {
    isatty ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804e3b0 */
#include <stdint.h>
 
uint32_t camlUnix_accept_non_intr_2024 (void) {
    do {
        eax = void (*0x804e3f0)(uint32_t) (eax);
        ecx = camlUnix;
        ebx = *(eax);
        if (ebx != ecx) {
            goto label_0;
        }
        ebx = *((eax + 4));
        if ((ebx & 1) == 0) {
            goto label_0;
        }
        if (ebx != 0x17) {
            goto label_0;
        }
        eax = *(esp);
    } while (1);
label_0:
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = camlCamlinternalOO__code_end;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c349 */
#include <stdint.h>
 
int32_t caml_int32_add (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax += *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e480 */
#include <stdint.h>
 
int32_t camlPrintf_printf_1393 (void) {
    eax = .comment;
    eax = camlPrintf_fprintf_1391 (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c507 */
#include <stdint.h>
 
void caml_expm1 (void) {
    *(fp_stack--) = *((ebp + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    expm1 (ebp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a174 */
#include <stdint.h>
 
void expm1 (void) {
    expm1 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a2b1 */
#include <stdint.h>
 
int32_t caml_page_table_add (int32_t arg_8h, char * arg_ch, int32_t arg_10h) {
    edi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx &= 0xfffff000;
    esi = *((ebp + 0x10));
    esi--;
    esi &= 0xfffff000;
    if (ebx > esi) {
        goto label_0;
    }
    do {
        ecx = edi;
        edx = 0;
        eax = ebx;
        eax = caml_page_table_modify ();
        if (eax != 0) {
            eax = 0xffffffff;
            goto label_1;
        }
        ebx += 0x1000;
    } while (esi >= ebx);
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c590 */
#include <stdint.h>
 
int32_t camlUnix_fun_2764 (void) {
    eax = unix_wait;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80609f0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_app_meth_const_1419 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlCamlinternalOO__fun_1818;
            *((eax + 4)) = 3;
            *((eax + 8)) = edx;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055780 */
#include <stdint.h>
 
uint32_t camlString_fun_1160 (void) {
    ecx = *((ebx + 8));
    *(ecx) += 2;
    ecx = *((ebx + 0xc));
    edx = *((eax - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    eax = *((eax + edx));
    edx -= eax;
    eax = *((ebx + 0xc));
    eax = *(eax);
    eax = eax + edx*2;
    *(ecx) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d5b0 */
#include <stdint.h>
 
uint32_t camlUnix_safe_close_1898 (void) {
    eax = void (*0x804d5e0)() ();
    ecx = camlUnix;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = 1;
        return eax;
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804af70 */
#include <stdint.h>
 
int32_t caml_curry6 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d110 */
#include <stdint.h>
 
uint32_t camlUnix_getaddrinfo_1751 (void) {
    int32_t var_4h;
    int32_t var_8h;
    eax = void (*0x804d160)(uint32_t, uint32_t, uint32_t) (eax, ebx, ecx);
    ecx = loc.caml_exn_Invalid_argument;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        void (*0x804cca0)() ();
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_getaddrinfo;
    caml_c_call (eax);
    ebx = 1;
    camlList_rev_append_1051 ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804aab0 */
#include <stdint.h>
 
int32_t caml_curry9 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c380 */
#include <stdint.h>
 
int32_t camlUnix_fun_2706 (void) {
    eax = unix_set_nonblock;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c230 */
#include <stdint.h>
 
int32_t camlUnix_fun_2668 (void) {
    eax = unix_kill;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064ee4 */
#include <stdint.h>
 
int32_t unix_sleep (int32_t s) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13a1c;
    caml_enter_blocking_section ();
    eax = *((ebp + 8));
    eax >>= 1;
    sleep (eax);
    caml_leave_blocking_section ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a654 */
#include <stdint.h>
 
void sleep (void) {
    sleep ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805a4d0 */
#include <stdint.h>
 
uint32_t camlMap_fun_1920 (void) {
    eax = camlMap_Make_1355 ();
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x64;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x6000;
            *(eax) = 1;
            ecx = *((ebx + 0x14));
            *((eax + 4)) = ecx;
            ecx = *((ebx + 0x20));
            *((eax + 8)) = ecx;
            ecx = *((ebx + 0x18));
            *((eax + 0xc)) = ecx;
            ecx = *((ebx + 8));
            *((eax + 0x10)) = ecx;
            ecx = *((ebx + 0x34));
            *((eax + 0x14)) = ecx;
            ecx = *((ebx + 0x68));
            *((eax + 0x18)) = ecx;
            ecx = *((ebx + 0x70));
            *((eax + 0x1c)) = ecx;
            ecx = *((ebx + 0x74));
            *((eax + 0x20)) = ecx;
            ecx = *((ebx + 0x38));
            *((eax + 0x24)) = ecx;
            ecx = *((ebx + 0x44));
            *((eax + 0x28)) = ecx;
            ecx = *((ebx + 0x48));
            *((eax + 0x2c)) = ecx;
            ecx = *((ebx + 0x4c));
            *((eax + 0x30)) = ecx;
            ecx = *((ebx + 0x50));
            *((eax + 0x34)) = ecx;
            ecx = *((ebx + 0x54));
            *((eax + 0x38)) = ecx;
            ecx = *((ebx + 0x78));
            *((eax + 0x3c)) = ecx;
            ecx = *((ebx + 0x80));
            *((eax + 0x40)) = ecx;
            ecx = *((ebx + 0x24));
            *((eax + 0x44)) = ecx;
            ecx = *((ebx + 0x28));
            *((eax + 0x48)) = ecx;
            ecx = *((ebx + 0x84));
            *((eax + 0x4c)) = ecx;
            ecx = *((ebx + 0x64));
            *((eax + 0x50)) = ecx;
            ecx = *((ebx + 0x1c));
            *((eax + 0x54)) = ecx;
            ecx = *((ebx + 0x3c));
            *((eax + 0x58)) = ecx;
            ebx = *((ebx + 0x40));
            *((eax + 0x5c)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80547f0 */
#include <stdint.h>
 
uint32_t camlList_fold_right_1084 (void) {
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        esi = *((ebx + 4));
        edx = *(ebx);
        ebx = esi;
        eax = camlList_fold_right_1084 (edx, eax);
    } while (1);
    ebx = eax;
    eax = *(esp);
    ecx = *((esp + 4));
    void (*0x804b5d0)() ();
label_0:
    eax = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80687bc */
#include <stdint.h>
 
int32_t caml_fl_allocate (int32_t arg_8h) {
    int32_t var_fc8h;
    int32_t var_fc4h;
    int32_t var_fc0h;
    int32_t var_fbch;
    int32_t var_fb8h;
    void * s2;
    size_t n;
    eax = *((ebp + 8));
    edx = caml_allocation_policy;
    if (edx != 0) {
        if (edx != 1) {
            goto label_0;
        }
        edx = flp_size;
        *((ebp - 0xfbc)) = edx;
        if (edx <= 0) {
            goto label_1;
        }
        ecx = flp;
        edx = *(ecx);
        esi = *((edx - 4));
        esi >>= 0xa;
        ebx = 0;
        edi = flp;
        if (eax > esi) {
            goto label_2;
        }
        goto label_3;
    }
    ecx = "hF\b\b";
    edx = *(ecx);
    if (edx == 0) {
        goto label_4;
    }
    ebx = *((edx - 4));
    ebx >>= 0xa;
    if (eax > ebx) {
        goto label_5;
    }
    while (edx != 0) {
        ebx = *((edx - 4));
        ebx >>= 0xa;
        if (ebx >= eax) {
            eax++;
            edx = 0;
            eax = allocate_block (edx);
            edi = eax;
            goto label_6;
        }
label_5:
        ecx = edx;
        edx = *(edx);
    }
label_4:
    *(obj.fl_last) = ecx;
    ecx = 0x8084668;
    edx = *(ecx);
    esi = "hF\b\b";
    if (ecx == esi) {
        goto label_0;
    }
    ebx = *((edx - 4));
    ebx >>= 0xa;
    if (eax > ebx) {
        goto label_7;
    }
    while (esi != ecx) {
        ebx = *((edx - 4));
        ebx >>= 0xa;
        if (eax <= ebx) {
            eax++;
            edx = 0;
            eax = allocate_block (edx);
            edi = eax;
            goto label_6;
        }
label_7:
        ecx = edx;
        edx = *(edx);
    }
    goto label_0;
    do {
        ecx = *((edi + ebx*4));
        edx = *(ecx);
        esi = *((edx - 4));
        esi >>= 0xa;
        if (eax <= esi) {
label_3:
            eax++;
            edx = ebx;
            eax = allocate_block (edx);
            edi = eax;
            goto label_8;
        }
label_2:
        ebx++;
    } while (ebx < *((ebp - 0xfbc)));
label_1:
    if (*((ebp - 0xfbc)) != 0) {
        goto label_9;
    }
    ecx = 0x8084668;
    edi = 0;
    do {
        edx = 0;
        goto label_10;
label_9:
        ecx = *((ebp - 0xfbc));
        edx = *((ecx*4 + 0x8086abc));
        ecx = *(edx);
        edi = *((ecx - 4));
        edi >>= 0xa;
        edx = beyond;
        if (edx != 0) {
            ecx = edx;
        }
    } while (1);
    do {
        edx = *(ecx);
        if (edx == 0) {
            *(obj.fl_last) = ecx;
            eax = 0;
            if (ecx == 0x8084668) {
                ecx = eax;
            }
            *(obj.beyond) = ecx;
            edi = 0;
            goto label_6;
        }
        esi = *((edx - 4));
        esi >>= 0xa;
        if (edi < esi) {
            *((ebx*4 + obj.flp)) = ecx;
            ebx = flp_size;
            edi = ebx + 1;
            *(obj.flp_size) = edi;
            if (eax <= esi) {
                *(obj.beyond) = edx;
                eax++;
                edx = ebx;
                eax = allocate_block (edx);
                edi = eax;
                goto label_8;
            }
            edi = esi;
        }
        ecx = edx;
label_10:
        ebx = flp_size;
    } while (ebx <= 0x3e7);
    *(obj.beyond) = edx;
    ecx = edx;
    if (edx == 0) {
        ecx = *((ebx*4 + 0x8086abc));
    }
    edx = .comment;
    edx = *(edx);
    esi = *((edx - 4));
    esi >>= 0xa;
    edx = *(ecx);
    if (edx == 0) {
        goto label_11;
    }
    do {
        ebx = *((edx - 4));
        ebx >>= 0xa;
        if (esi > ebx) {
            *(obj.beyond) = edx;
        } else {
            if (eax > ebx) {
                goto label_12;
            }
            eax++;
            edx = flp_size;
            eax = allocate_block (edx);
            edi = eax;
            goto label_6;
        }
label_12:
        ebx = *(edx);
        if (ebx == 0) {
            goto label_13;
        }
        ecx = edx;
        edx = ebx;
    } while (1);
label_13:
    ecx = edx;
label_11:
    *(obj.fl_last) = ecx;
    edi = 0;
    goto label_6;
label_8:
    eax = flp_size;
    if (ebx >= eax) {
        goto label_6;
    }
    ecx = 0;
    if (ebx > 0) {
        edx = *((ebx*4 + 0x8086abc));
        edx = *(edx);
        edx = *((edx - 4));
        ecx = *((edx - 4));
        ecx >>= 0xa;
    }
    eax--;
    if (eax == ebx) {
        eax = *((eax*4 + obj.flp));
        eax = *(eax);
        edx = *((eax - 4));
        edx >>= 0xa;
        if (ecx >= edx) {
            *(obj.beyond) = eax;
            *(obj.flp_size)--;
            goto label_6;
        }
        *(obj.beyond) = 0;
        goto label_6;
    }
    edx = flp;
    eax = *((edx + ebx*4));
    edx = *((edx + ebx*4 + 4));
    *((ebp - 0xfc0)) = 0;
    *((ebp - 0xfbc)) = esi;
    esi = ecx;
    *((ebp - 0xfc4)) = ebx;
    ebx = 0;
    *((ebp - 0xfc8)) = edi;
    edi = edx;
    while (edi != eax) {
        edx = *(eax);
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (esi < ecx) {
            *((ebp + ebx*4 - 0xfb8)) = eax;
            ebx++;
            if (*((ebp - 0xfbc)) <= ecx) {
                goto label_14;
            }
            esi = ecx;
        }
        eax = edx;
    }
label_14:
    *((ebp - 0xfc0)) = ebx;
    ebx = *((ebp - 0xfc4));
    edi = *((ebp - 0xfc8));
    eax = flp_size;
    eax--;
    edx = *((ebp - 0xfc0));
    edx = eax + edx;
    if (edx <= 0x3e8) {
        if (*((ebp - 0xfc0)) != 1) {
            eax -= ebx;
            eax <<= 2;
            eax = ebx*4 + 0x8086ac4;
            eax = *((ebp - 0xfc0));
            eax += ebx;
            eax = eax*4 + obj_flp;
            memmove (eax, eax, eax);
            if (*((ebp - 0xfc0)) <= 0) {
                goto label_15;
            }
        }
        eax = *((ebp - 0xfc0));
        eax <<= 2;
        eax = ebp - 0xfb8;
        eax = ebx*4 + obj_flp;
        memmove (eax, eax, eax);
label_15:
        eax = flp_size;
        edx = *((ebp - 0xfc0));
        eax = edx + eax - 1;
        *(obj.flp_size) = eax;
    } else {
        eax = *((ebp - 0xfc0));
        eax += ebx;
        if (eax <= 0x3e7) {
            if (*((ebp - 0xfc0)) != 1) {
                edx = 0x3e8;
                edx -= ebx;
                edx -= *((ebp - 0xfc0));
                edx <<= 2;
                edx = ebx*4 + 0x8086ac4;
                eax = eax*4 + obj_flp;
                memmove (eax, edx, edx);
                if (*((ebp - 0xfc0)) <= 0) {
                    goto label_16;
                }
            }
            eax = *((ebp - 0xfc0));
            eax <<= 2;
            eax = ebp - 0xfb8;
            eax = ebx*4 + obj_flp;
            memmove (eax, eax, eax);
        } else {
            if (ebx == 0x3e8) {
                goto label_16;
            }
            eax = 0x3e8;
            eax -= ebx;
            eax <<= 2;
            eax = ebp - 0xfb8;
            eax = ebx*4 + obj_flp;
            memmove (eax, eax, eax);
        }
label_16:
        *(obj.flp_size) = 0x3e7;
        eax = .comment;
        eax = *(eax);
        *(obj.beyond) = eax;
        goto label_6;
label_0:
        edi = 0;
    }
label_6:
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8051cc0 */
#include <stdint.h>
 
uint32_t camlArray_sortto_1217 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    do {
label_0:
        if (edx <= 0xb) {
            esi = *((esi + 0x14));
            void (*0x80519c0)() ();
        }
        *(esp) = esi;
        *((esp + 8)) = ecx;
        *((esp + 0x14)) = ebx;
        *((esp + 0x10)) = eax;
        esi = edx;
        esi >>= 1;
        if (esi < 0) {
            esi++;
        }
        esi >>= 1;
        esi = esi + esi + 1;
        edx -= esi;
        edx++;
        ecx = ecx + esi - 1;
        eax = eax + esi - 1;
        edx = *((esp + 0xc));
        esi = *(esp);
        camlArray_sortto_1217 (edx, esi);
    } while (1);
    ebx = *((esp + 0xc));
    eax = *((esp + 0x10));
    ecx = eax + ebx - 1;
    esi = *(esp);
    ebx = *((esi + 0xc));
    edx = *((esp + 4));
    camlArray_sortto_1217 ();
    goto label_0;
    eax = *(esp);
    eax = *((eax + 0x10));
    *(esp) = eax;
    ebx = *((esp + 4));
    ebp = *((esp + 8));
    edx = ebp + ebx - 1;
    esi = *((esp + 0xc));
    eax = *((esp + 0x10));
    eax = eax + esi - 1;
    ecx = *((esp + 0x14));
    edi = *((esp + 0x14));
    *(loc.caml_extra_params) = ebp;
    ebp = *(esp);
    *(0x8084740) = ebp;
    return camlArray_merge_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bc20 */
#include <stdint.h>
 
uint32_t camlUnix_get_port_1739 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    esi = eax;
    edi = ecx;
    eax = caml_string_equal (*((edi + 0xc)), loc.camlUnix__215);
    if (eax != 1) {
label_1:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        *(ebx) = esi;
        *((ebx + 4)) = 1;
        eax = ebx + 0xc;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        *((eax + 4)) = 1;
        return eax;
    }
    eax = void (*0x804bd60)(uint32_t, uint32_t, uint32_t) (ebx, edi, esi);
    ecx = caml_exn_Failure;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = void (*0x804bcd0)() ();
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 1;
            return eax;
        }
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = *((esp + 8));
        eax = *((esp + 0x10));
        eax = unix_getservbyname;
        eax = caml_c_call (*((eax + 0xc)));
        eax += 8;
        ecx = *(eax);
label_0:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        eax = *((esp + 0x10));
        *(ebx) = eax;
        *((ebx + 4)) = ecx;
        eax = ebx + 0xc;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        *((eax + 4)) = 1;
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = caml_int_of_string;
    eax = caml_c_call (*((edi + 0xc)));
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 0x10));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx + 0xc;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            *((eax + 4)) = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cd0a */
#include <stdint.h>
 
int32_t caml_string_equal (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 8));
    edx = *((ebp + 0xc));
    if (ecx == edx) {
        goto label_0;
    }
    eax = *((ecx - 4));
    eax >>= 0xa;
    ebx = *((edx - 4));
    ebx >>= 0xa;
    if (eax != ebx) {
        goto label_1;
    }
    if (eax == 0) {
        goto label_0;
    }
    ebx = *(ecx);
    if (ebx == *(edx)) {
        goto label_2;
    }
    goto label_1;
    do {
        ecx += 4;
        edx += 4;
        ebx = *(ecx);
        if (ebx != *(edx)) {
            goto label_1;
        }
label_2:
        eax--;
    } while (eax != 0);
label_0:
    eax = 3;
    goto label_3;
label_1:
    eax = 1;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ed35 */
#include <stdint.h>
 
uint32_t caml_serialize_float_4 (int32_t arg_8h) {
    int32_t var_4h;
    eax = ebp + 8;
    caml_serialize_block_4 (eax, 1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ecb4 */
#include <stdint.h>
 
int32_t caml_serialize_block_4 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_1ch;
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax <<= 2;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    edx = extern_ptr;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    ecx = *((ebp + 0xc));
    eax = 0;
    *((ebp - 0x1c)) = ecx;
    do {
        edi = *((ebx + eax));
        esi = *((ebx + eax + 1));
        ecx = *((ebx + eax + 3));
        *((edx + eax)) = cl;
        ecx = *((ebx + eax + 2));
        *((edx + eax + 1)) = cl;
        ecx = edi;
        *((edx + eax + 3)) = cl;
        ecx = esi;
        *((edx + eax + 2)) = cl;
        eax += 4;
        *((ebp - 0x1c))--;
    } while (*((ebp - 0x1c)) != 0);
    eax = *((ebp + 0xc));
    edx = edx + eax*4;
label_0:
    *(obj.extern_ptr) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805bda0 */
#include <stdint.h>
 
void camlPrintf_scan_flags_1142 (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071d4c */
#include <stdint.h>
 
int32_t caml_gc_major (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (1, "Major GC cycle requested\n", 0);
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    test_and_compact ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805bf80 */
#include <stdint.h>
 
int32_t camlPrintf_loop_1204 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 4));
        ebx = *(ebx);
        if (edx == 1) {
            goto label_1;
        }
        ecx = *((ecx + 0xc));
        caml_apply2 (eax, edx, ecx);
        eax = *(esp);
        eax += 2;
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_1:
    ecx = *((ecx + 0xc));
    void (*0x804b5d0)() ();
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80529a0 */
#include <stdint.h>
 
uint32_t camlArray_iteri_1111 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = 1;
    edx = *((ebx - 4));
    esi = *((ebx - 4));
    esi &= 0xff;
    if (esi != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    edx += 0xfffffffe;
    if (ecx > edx) {
        goto label_1;
    }
    *((esp + 0xc)) = edx;
    *((esp + 8)) = ecx;
    *(esp) = ebx;
    *((esp + 4)) = eax;
    do {
        edx = *(esp);
        eax = *((edx - 4));
        if (eax != 0xfe) {
            ebx = *((edx + ecx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ecx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = ecx;
        ecx = *((esp + 4));
        caml_apply2 ();
        ecx = *((esp + 8));
        ebx = *((esp + 8));
        ecx += 2;
        *((esp + 8)) = ecx;
        eax = *((esp + 0xc));
    } while (ebx != eax);
label_1:
    eax = 1;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b540 */
#include <stdint.h>
 
int32_t camlPrintf_cont_m_1365 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = ebx;
    eax = camlPrintf_ac_of_format_1184 (eax, ecx, eax);
    ebx = *(eax);
    eax = *((esp + 8));
    eax = ebx + eax - 1;
    eax = camlPrintf_index_of_int_1037 ();
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = loc.camlPrintf__code_begin;
            *((eax + 4)) = 3;
            ecx = *(esp);
            ebx = *(esp);
            ebx += 0xffffffb0;
            *((eax + 8)) = ebx;
            ebx = *((esp + 4));
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = edx;
            esi = *((ecx + 0x20));
            edx = *((ecx + 0x2c));
            ebx = *((esp + 8));
            ecx = *((esp + 0xc));
            void (*0x805d3e0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075918 */
#include <stdint.h>
 
int32_t caml_print_exception_backtrace (void) {
    uint32_t var_30h;
    uint32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    char * format;
    char ** var_8h;
    char ** var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    if (*(obj.caml_backtrace_pos) <= 0) {
        goto label_0;
    }
    ebx = 0;
    esi = ebp - 0x30;
    edi = "Re-raised at";
    do {
        eax = caml_backtrace_buffer;
        eax = *((eax + ebx*4));
        edx = esi;
        extract_location_info ();
        if (*((ebp - 0x30)) != 0) {
            eax = "Raised at";
            if (ebx != 0) {
                eax = "Called from";
                if (*((ebp - 0x2c)) == 0) {
                    eax = edi;
                    goto label_1;
                }
            }
label_1:
            edx = *((ebp - 0x1c));
            *((esp + 0x18)) = edx;
            edx = *((ebp - 0x20));
            *((esp + 0x14)) = edx;
            edx = *((ebp - 0x24));
            *((esp + 0x10)) = edx;
            edx = *((ebp - 0x28));
            *((esp + 0xc)) = edx;
            *((esp + 8)) = eax;
            eax = stderr;
            fprintf (eax, "%s file \"%s\", line %d, characters %d-%d\n");
        }
        ebx++;
    } while (*(obj.caml_backtrace_pos) > ebx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c5b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2768 (void) {
    eax = unix_execvpe;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052480 */
#include <stdint.h>
 
int32_t camlArray_fill_1087 (void) {
    esi = eax;
    edi = edx;
    if (ebx < 1) {
        goto label_0;
    }
    if (ecx < 1) {
        goto label_0;
    }
    edx = *((esi - 4));
    eax = *((esi - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = edx;
        eax >>= 9;
    } else {
        eax = edx;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= ecx;
    eax++;
    if (ebx > eax) {
        goto label_0;
    }
    ebx = ebx + ecx - 3;
    if (ebp > ebx) {
        goto label_1;
    }
    do {
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebp*2 - 2, edi);
        } else {
            *(fp_stack--) = *(edi);
            *((esi + ebp*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebp;
        eax = ebp;
        eax += 2;
    } while (ecx != ebx);
label_1:
    eax = 1;
    return eax;
label_0:
    eax = "Array.fill";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f830 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1408 (void) {
    eax = caml_ml_input_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ebc3 */
#include <stdint.h>
 
int32_t caml_serialize_float_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    eax = *((ebp + 8));
    *((ebp - 0x10)) = eax;
    eax = *((ebp + 0xc));
    *((ebp - 0xc)) = eax;
    eax = ebp - 0x10;
    caml_serialize_block_float_8 (eax, 1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806eb7b */
#include <stdint.h>
 
int32_t caml_serialize_block_float_8 (int32_t arg_8h, int32_t arg_ch) {
    void ** s2;
    size_t * n;
    eax = *((ebp + 0xc));
    eax <<= 3;
    ebx = eax;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    eax = *((ebp + 8));
    eax = extern_ptr;
    memmove (eax, eax, ebx);
    *(obj.extern_ptr) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fe50 */
#include <stdint.h>
 
int32_t camlPervasives_input_1224 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = caml_ml_input;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "input";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060b90 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_meth_app_meth_1449 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlCamlinternalOO__fun_1842;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806369e */
#include <stdint.h>
 
int32_t unix_localtime (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_1ah;
    time_t * timer;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15262;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0xc)) = fp_stack[0];
    fp_stack--;
    eax = ebp - 0xc;
    eax = localtime (eax);
    if (eax == 0) {
        eax = ebx - 0x254d;
        unix_error (0x16, eax, 0);
    }
    alloc_tm ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049f64 */
#include <stdint.h>
 
void localtime (void) {
    localtime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075104 */
#include <stdint.h>
 
int32_t caml_final_custom_operations (int32_t arg_8h) {
    esi = *((ebp + 8));
    eax = custom_ops_final_table;
    if (eax == 0) {
        goto label_0;
    }
    ebx = *(eax);
    if (*((ebx + 4)) != esi) {
        goto label_1;
    }
    goto label_2;
    do {
        ebx = *(eax);
        if (*((ebx + 4)) == esi) {
            goto label_2;
        }
label_1:
        eax = *((eax + 4));
    } while (eax != 0);
label_0:
    eax = caml_stat_alloc (0x1c);
    ebx = eax;
    *(eax) = "_final";
    *((eax + 4)) = esi;
    *((eax + 8)) = 0;
    *((eax + 0xc)) = 0;
    *((eax + 0x10)) = 0;
    *((eax + 0x14)) = 0;
    caml_stat_alloc (8);
    *(eax) = ebx;
    edx = custom_ops_final_table;
    *((eax + 4)) = edx;
    *(obj.custom_ops_final_table) = eax;
label_2:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806286c */
#include <stdint.h>
 
uint32_t unix_getcwd (void) {
    int32_t var_1008h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16091;
    *((esp + 4)) = 0x1000;
    eax = ebp - 0x1008;
    *(esp) = eax;
    eax = getcwd ();
    if (eax == 0) {
        eax = ebx - 0x2599;
        uerror (eax, 0);
    }
    eax = ebp - 0x1008;
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a6d4 */
#include <stdint.h>
 
void getcwd (void) {
    getcwd ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806df31 */
#include <stdint.h>
 
int32_t caml_getblock (int32_t arg_8h, void * s1, int32_t arg_10h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *((ebp + 0x10));
    eax = *((ebx + 0x10));
    esi = *((ebx + 0x14));
    esi -= eax;
    if (edi <= esi) {
        eax = *((ebp + 0xc));
        eax = memmove (eax, eax, edi);
        *((ebx + 0x10)) += edi;
        esi = edi;
    } else {
        if (esi > 0) {
            eax = *((ebp + 0xc));
            memmove (eax, eax, esi);
            *((ebx + 0x10)) += esi;
        } else {
            eax = ebx + 0x34;
            *((ebp - 0x1c)) = eax;
            eax = *((ebx + 0xc));
            eax -= *((ebp - 0x1c));
            eax = *((ebp - 0x1c));
            eax = *(ebx);
            eax = caml_do_read (eax, eax, eax);
            ecx = eax;
            ecx >>= 0x1f;
            *((ebx + 4)) += eax;
            *((ebx + 8)) += ecx;
            edx = ebx + eax + 0x34;
            *((ebx + 0x14)) = edx;
            esi = edi;
            if (eax <= edi) {
                esi = eax;
            }
            eax = *((ebp - 0x1c));
            eax = *((ebp + 0xc));
            memmove (eax, eax, esi);
            eax = ebx + esi + 0x34;
            *((ebx + 0x10)) = eax;
        }
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c365 */
#include <stdint.h>
 
int32_t caml_int32_neg (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = -eax;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069b9c */
#include <stdint.h>
 
uint32_t caml_check_urgent_gc (int32_t arg_8h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    ebx = caml_local_roots;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    eax = caml_force_major_slice;
    if (eax != 0) {
        *((ebp - 0x28)) = ebx;
        *((ebp - 0x20)) = 1;
        *((ebp - 0x24)) = 1;
        eax = ebp + 8;
        *((ebp - 0x1c)) = eax;
        caml_minor_collection ();
    }
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805dae0 */
#include <stdint.h>
 
int32_t camlPrintf_sub_format_1117 (void) {
    *(esp) = eax;
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((edx + eax));
    eax -= ecx;
    edi = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x1cf7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x805ba50;
            eax = *(esp);
            *((ecx + 0xc)) = eax;
            *((ecx + 0x10)) = ebx;
            *((ecx + 0x14)) = edx;
            *((ecx + 0x18)) = edi;
            eax = ebp;
            ebx = esi;
            void (*0x805ba50)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075ad1 */
#include <stdint.h>
 
void caml_debugger (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c1e5 */
#include <stdint.h>
 
int32_t caml_int32_shift_right_unsigned (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fea0 */
#include <stdint.h>
 
int32_t camlPervasives_unsafe_really_input_1229 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (edx <= 1) {
            eax = 1;
            return eax;
        }
        *(esp) = edx;
        *((esp + 4)) = ecx;
        *((esp + 0xc)) = ebx;
        *((esp + 8)) = eax;
        eax = caml_ml_input;
        eax = caml_c_call (eax);
        if (eax == 1) {
label_0:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_1;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_End_of_file;
            eax = caml_raise_exn ();
        }
        edx = *(esp);
        edx -= eax;
        edx++;
        ebx = *((esp + 4));
        ecx = ebx + eax - 1;
        eax = *((esp + 8));
        ebx = *((esp + 0xc));
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80634dc */
#include <stdint.h>
 
uint32_t unix_getuid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15424;
    getuid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a4d4 */
#include <stdint.h>
 
void getuid (void) {
    getuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f810 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1404 (void) {
    eax = caml_ml_input_int;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e111 */
#include <stdint.h>
 
uint32_t caml_getword (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = caml_channel_binary_mode (ebx, esi, edi);
    if (eax == 0) {
        caml_failwith ("input_binary_int: not a binary channel");
    }
    edi = 0;
    esi = 0;
    do {
        edx = *((ebx + 0x10));
        if (edx >= *((ebx + 0x14))) {
            al = caml_refill (ebx);
            eax = (int32_t) al;
        } else {
            eax = *(edx);
            edx++;
            *((ebx + 0x10)) = edx;
        }
        edi <<= 8;
        edi = eax + edi;
        esi++;
    } while (esi != 4);
    eax = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cb60 */
#include <stdint.h>
 
int32_t camlUnix_fun_2814 (void) {
    eax = unix_getsockopt;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8051d80 */
#include <stdint.h>
 
int32_t camlArray_init_1037 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    if (eax == 1) {
        eax = loc.camlArray__34;
        return eax;
    }
    eax = 1;
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t, uint32_t) (eax, ebx);
    eax = *((esp + 4));
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    esi = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (esi > eax) {
        goto label_0;
    }
    do {
        ebx = *((esp + 4));
        ecx = *(ebx);
        eax = esi;
        eax = void (*ecx)(uint32_t, uint32_t) (esi, eax);
        ebx = *(esp);
        ecx = *((ebx - 4));
        if (ecx != 0xfe) {
            esi = *((esp + 0x10));
            eax = caml_modify (ebx + esi*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            esi = *((esp + 0xc));
            *((ebx + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = esi;
        esi += 2;
        *((esp + 0xc)) = esi;
        eax = *((esp + 8));
    } while (ecx != eax);
label_0:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b3f0 */
#include <stdint.h>
 
int32_t caml_tuplify2 (void) {
    ecx = ebx;
    ebx = *((eax + 4));
    eax = *(eax);
    edx = *((ecx + 8));
    return void (*edx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d5a0 */
#include <stdint.h>
 
uint32_t camlPrintf_index_of_int_1037 (void) {
    if (eax >= 1) {
        return;
    }
    eax = camlPervasives_string_of_int_1130 ();
    ebx = eax;
    eax = "Sformat.index_of_int: negative argument ";
    camlPervasives_$5e_1112 ();
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073b10 */
#include <stdint.h>
 
int32_t caml_callback3 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = *((ebp + 0x14));
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = loc_caml_callback3_exn (eax, eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075d08 */
#include <stdint.h>
 
int32_t loc_caml_callback3_exn (int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, int32_t arg_20h) {
    edx = *((esp + 0x14));
    eax = *((esp + 0x18));
    ebx = *((esp + 0x1c));
    ecx = *((esp + 0x20));
    esi = caml_apply3;
    return void (*0x8075c09)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056f30 */
#include <stdint.h>
 
int32_t camlHashtbl_remove_1185 (void) {
    int32_t var_4h_3;
    int32_t var_4h_2;
    int32_t var_8h;
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = loc.camlHashtbl__code_begin;
            *((eax + 4)) = 3;
            esi = *((ecx + 0xc));
            *((eax + 8)) = esi;
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = ebx;
            esi = *((edx + 4));
            esi = *((esi - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = *((ecx + 0x10));
                eax = *((eax + 8));
                edx = *((eax + 4));
                ecx = *(edx);
                eax = ebx;
                ebx = edx;
                eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, esi);
                ebx = 0x7fffffff;
                eax &= ebx;
                eax >>= 1;
                ecx = *((esp + 8));
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            *((esp + 8)) = edx;
            eax = *(esp);
            ebx = *((eax + 4));
            *(esp) = ebx;
            ebx = *((ebx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_0;
            }
            ebx = *((eax + 4));
            eax = *((ebx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_1;
            }
            eax = *((ebx + edx*2 - 2));
            ebx = *((esp + 4));
            eax = camlHashtbl_code_begin ();
            ebx = *((esp + 4));
            eax = *((esp + 0xc));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c1f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2660 (void) {
    eax = unix_time;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8057670 */
#include <stdint.h>
 
void camlHashtbl_hash_1031 (void) {
    caml_hash_univ_param (0x15, 0xc9, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070c7f */
#include <stdint.h>
 
int32_t caml_hash_univ_param (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    *(obj.hash_univ_limit) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(obj.hash_univ_count) = eax;
    *(obj.hash_accu) = 0;
    eax = *((ebp + 0x10));
    hash_aux ();
    eax = hash_accu;
    eax &= 0x3fffffff;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fad8 */
#include <stdint.h>
 
int32_t caml_deserialize_block_4 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    ecx = *((ebp + 8));
    edx = intern_src;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    ebx = *((ebp + 0xc));
    eax = 0;
    *((ebp - 0x10)) = ebx;
    do {
        edi = *((edx + eax));
        esi = *((edx + eax + 1));
        ebx = *((edx + eax + 3));
        *((ecx + eax)) = bl;
        ebx = *((edx + eax + 2));
        *((ecx + eax + 1)) = bl;
        ebx = edi;
        *((ecx + eax + 3)) = bl;
        ebx = esi;
        *((ecx + eax + 2)) = bl;
        eax += 4;
        *((ebp - 0x10))--;
    } while (*((ebp - 0x10)) != 0);
    eax = *((ebp + 0xc));
    edx = edx + eax*4;
label_0:
    *(obj.intern_src) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80556f0 */
#include <stdint.h>
 
int32_t camlChar_uppercase_1045 (void) {
    if (eax >= 0xc3) {
        if (eax <= 0xf5) {
            goto label_0;
        }
    }
    if (eax >= 0x1c1) {
        if (eax <= 0x1ed) {
            goto label_0;
        }
    }
    if (eax >= 0x1f1) {
        if (eax <= 0x1fd) {
            goto label_0;
        }
    }
    return;
label_0:
    eax += 0xffffffc0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c570 */
#include <stdint.h>
 
int32_t camlUnix_fun_2760 (void) {
    eax = unix_getpid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b6f0 */
#include <stdint.h>
 
int32_t camlPrintf_doprn_1360 (void) {
    int32_t var_8h;
    int32_t var_ch;
    do {
        edx = ebx;
        eax = *((ecx + 0x80));
        if (edx >= eax) {
            ebx = *((ecx + 0x74));
            eax = *((ecx + 0x6c));
            ecx = *(ebx);
            void (*ecx)() ();
        }
        ebx = edx;
        ebx >>= 1;
        eax = *((ecx + 0x78));
        eax = *((eax + ebx));
        ebx = eax + eax + 1;
        if (ebx == 0x4b) {
            goto label_0;
        }
        edx = *((ecx + 0x60));
        eax = *((ecx + 0x6c));
        ecx = edx;
        caml_apply2 (edx, ebp, ecx);
        ebx = *(esp);
        ebx += 2;
        eax = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_0:
    eax = ecx;
    eax += 0x50;
    *((esp + 4)) = eax;
    eax = ecx;
    eax += 0x40;
    *(esp) = eax;
    *((esp + 8)) = ecx;
    edi = ecx;
    edi += 0x20;
    esi = ecx;
    esi += 0x10;
    ebx = *((ecx + 0x7c));
    eax = *((ecx + 0x78));
    ecx = ebp;
    ebp = *((esp + 8));
    *(loc.caml_extra_params) = ebp;
    ebp = *(esp);
    *(0x8084740) = ebp;
    ebp = *((esp + 4));
    *(0x8084744) = ebp;
    return camlPrintf_scan_format_1278 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b630 */
#include <stdint.h>
 
void camlSource_method_activate_1091 (void) {
    edx = *((ebx + 8));
    ebx = *((ebx + 8));
    ecx = *((eax + ebx*2 - 2));
    ebx = 4;
    ebx -= ecx;
    *((eax + edx*2 - 2)) = ebx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c330 */
#include <stdint.h>
 
int32_t camlUnix_fun_2696 (void) {
    eax = unix_rmdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b342 */
#include <stdint.h>
 
int32_t caml_int64_compare (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    ebx = *((edx + 4));
    edx = *((edx + 8));
    esi = *((eax + 4));
    eax = *((eax + 8));
    edi = 1;
    if (edx <= eax) {
        if (edx >= eax) {
            if (ebx > esi) {
                goto label_0;
            }
        }
        edi = 0;
    }
label_0:
    ecx = 1;
    if (edx >= eax) {
        if (edx <= eax) {
            if (ebx < esi) {
                goto label_1;
            }
        }
        ecx = 0;
    }
label_1:
    edi -= ecx;
    eax = edi + edi + 1;
    ebx = *(esp);
    esi = *((esp + 4));
    edi = *((esp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f7f0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1400 (void) {
    eax = caml_ml_seek_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80564f0 */
#include <stdint.h>
 
int32_t camlSys_set_signal_1057 (void) {
    eax = caml_install_signal_handler;
    caml_c_call (eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805fd10 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_new_methods_variables_1248 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    eax = ebx;
    eax = camlCamlinternalOO_to_array_1246 (eax, ecx);
    *((esp + 0xc)) = eax;
    ebx = *((eax - 4));
    ebx >>= 9;
    ebx |= 1;
    *((esp + 4)) = ebx;
    eax = *((esp + 8));
    eax = *((eax - 4));
    eax >>= 9;
    eax |= 1;
    *(esp) = eax;
    eax = caml_make_vect;
    eax = caml_c_call (ebx + eax - 1);
    ecx = eax;
    ebx = 1;
    eax = *((esp + 4));
    eax += 0xfffffffe;
    if (ebx > eax) {
        goto label_0;
    }
    *((esp + 0x1c)) = eax;
    *((esp + 0x10)) = ebx;
    *((esp + 0x18)) = ecx;
    do {
        eax = *((ecx - 4));
        eax >>= 9;
        if (eax <= ebx) {
            goto label_1;
        }
        eax = *((esp + 0xc));
        ecx = *((eax - 4));
        ecx >>= 9;
        if (ecx <= ebx) {
            goto label_2;
        }
        ebx = *((eax + ebx*2 - 2));
        eax = *((esp + 0x14));
        eax = camlCamlinternalOO_get_method_label_1188 ();
        ebx = *((esp + 0x10));
        ecx = *((esp + 0x18));
        *((ecx + ebx*2 - 2)) = eax;
        edx = ebx;
        ebx += 2;
        *((esp + 0x10)) = ebx;
        eax = *((esp + 0x1c));
    } while (edx != eax);
label_0:
    ebx = 1;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ebx > eax) {
        goto label_3;
    }
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = ebx;
    *((esp + 0x18)) = ecx;
    do {
        eax = *((esp + 4));
        edx = ebx + eax - 1;
        *(esp) = edx;
        eax = *((ecx - 4));
        eax >>= 9;
        if (eax <= edx) {
            goto label_4;
        }
        eax = *((esp + 8));
        ecx = *((eax - 4));
        ecx >>= 9;
        if (ecx <= ebx) {
            goto label_5;
        }
        ebx = *((eax + ebx*2 - 2));
        eax = *((esp + 0x14));
        eax = camlCamlinternalOO_new_variable_1242 ();
        ebx = *(esp);
        ecx = *((esp + 0x18));
        *((ecx + ebx*2 - 2)) = eax;
        ebx = *((esp + 0xc));
        edx = *((esp + 0xc));
        ebx += 2;
        *((esp + 0xc)) = ebx;
        eax = *((esp + 0x10));
    } while (edx != eax);
label_3:
    eax = ecx;
    return eax;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ba54 */
#include <stdint.h>
 
int32_t caml_nativeint_shift_right_unsigned (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b944 */
#include <stdint.h>
 
int32_t caml_nativeint_to_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073bb2 */
#include <stdint.h>
 
int32_t caml_callbackN_exn (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8ch;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_74h;
    int32_t var_70h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edi = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    eax = caml_local_roots;
    *((ebp - 0x8c)) = eax;
    eax = ebp - 0x7c;
    *(obj.caml_local_roots) = eax;
    eax = *((ebp + 8));
    *((ebp - 0x5c)) = eax;
    if (edi <= 0) {
        goto label_0;
    }
    edx = *((ebp - 0x8c));
    *((ebp - 0x38)) = edx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp - 0x38;
    *((ebp - 0x58)) = eax;
    *((ebp - 0x50)) = edi;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x4c)) = esi;
    eax = ebp - 0x58;
    *((ebp - 0x7c)) = eax;
    *((ebp - 0x74)) = 1;
    *((ebp - 0x78)) = 1;
    eax = ebp - 0x5c;
    *((ebp - 0x70)) = eax;
    ebx = 0;
    do {
        eax = edi;
        eax -= ebx;
        if (eax != 1) {
            if (eax != 2) {
                goto label_1;
            }
        } else {
            eax = *((esi + ebx*4));
            eax = *((ebp - 0x5c));
            eax = caml_callback_exn (eax, eax);
            edx = eax;
            edx &= 3;
            if (edx == 2) {
                edx = *((ebp - 0x8c));
                *(obj.caml_local_roots) = edx;
                goto label_2;
            }
            *((ebp - 0x5c)) = eax;
            ebx++;
            goto label_3;
        }
        eax = *((esi + ebx*4 + 4));
        eax = *((esi + ebx*4));
        eax = *((ebp - 0x5c));
        eax = caml_callback2_exn (eax, eax, eax);
        edx = eax;
        edx &= 3;
        if (edx == 2) {
            edx = *((ebp - 0x8c));
            *(obj.caml_local_roots) = edx;
            goto label_2;
        }
        *((ebp - 0x5c)) = eax;
        ebx += 2;
        goto label_3;
label_1:
        eax = *((esi + ebx*4 + 8));
        eax = *((esi + ebx*4 + 4));
        eax = *((esi + ebx*4));
        eax = *((ebp - 0x5c));
        eax = loc_caml_callback3_exn (eax, eax, eax);
        edx = eax;
        edx &= 3;
        if (edx == 2) {
            edx = *((ebp - 0x8c));
            *(obj.caml_local_roots) = edx;
            goto label_2;
        }
        *((ebp - 0x5c)) = eax;
        ebx += 3;
label_3:
    } while (edi > ebx);
label_0:
    eax = *((ebp - 0x8c));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x5c));
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e9c7 */
#include <stdint.h>
 
int32_t caml_ml_open_descriptor_in (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    eax = caml_open_descriptor_in (eax);
    caml_alloc_channel (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d866 */
#include <stdint.h>
 
void caml_alloc_channel (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ebx = *((ebp + 8));
    *((ebx + 0x2c))++;
    caml_alloc_custom (ebx, 4, 1);
    *((eax + 4)) = ebx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fd8e */
#include <stdint.h>
 
int32_t caml_code_checksum (void) {
    int32_t var_60h;
    int32_t var_4h;
    int32_t var_8h;
    if (*(obj.checksum_computed.3405) == 0) {
        ebx = ebp - 0x60;
        caml_MD5Init (ebx);
        eax = caml_code_area_start;
        edx = caml_code_area_end;
        edx -= eax;
        caml_MD5Update (ebx, eax, edx);
        caml_MD5Final (obj.checksum.3404, ebx);
        *(obj.checksum_computed.3405) = 1;
    }
    eax = checksum.3404;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8072728 */
#include <stdint.h>
 
int32_t caml_MD5Init (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(eax) = 0x67452301;
    *((eax + 4)) = 0xefcdab89;
    *((eax + 8)) = 0x98badcfe;
    *((eax + 0xc)) = 0x10325476;
    *((eax + 0x10)) = 0;
    *((eax + 0x14)) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8072fa6 */
#include <stdint.h>
 
int32_t caml_MD5Update (void * s1, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_20h;
    int32_t var_1ch;
    void * s2;
    size_t n;
    edi = *((ebp + 0x10));
    eax = *((ebp + 8));
    ebx = *((eax + 0x10));
    eax = ebx + edi*8;
    edx = *((ebp + 8));
    *((edx + 0x10)) = eax;
    if (ebx > eax) {
        *((edx + 0x14))++;
    }
    eax = edi;
    eax >>= 0x1d;
    edx = *((ebp + 8));
    *((edx + 0x14)) += eax;
    ebx >>= 3;
    ebx &= 0x3f;
    if (ebx != 0) {
        eax = edx + ebx + 0x18;
        edx = 0x40;
        edx -= ebx;
        ebx = edx;
        if (edi < edx) {
            edx = *((ebp + 0xc));
            eax = memcpy (eax, edx, edi);
            goto label_0;
        }
        edx = *((ebp + 0xc));
        memcpy (eax, edx, edx);
        eax = *((ebp + 8));
        eax += 0x18;
        eax = *((ebp + 8));
        caml_MD5Transform (eax, eax);
        *((ebp + 0xc)) += ebx;
        edi -= ebx;
    }
    if (edi <= 0x3f) {
        goto label_1;
    }
    ebx = *((ebp + 8));
    ebx += 0x18;
    *((ebp - 0x20)) = ebx;
    edx = *((ebp + 8));
    *((ebp - 0x1c)) = edx;
    esi = 0;
    do {
        eax = *((ebp + 0xc));
        eax += esi;
        edx = *(eax);
        *(ebx) = edx;
        edx = *((eax + 4));
        *((ebx + 4)) = edx;
        edx = *((eax + 8));
        *((ebx + 8)) = edx;
        edx = *((eax + 0xc));
        *((ebx + 0xc)) = edx;
        edx = *((eax + 0x10));
        *((ebx + 0x10)) = edx;
        edx = *((eax + 0x14));
        *((ebx + 0x14)) = edx;
        edx = *((eax + 0x18));
        *((ebx + 0x18)) = edx;
        edx = *((eax + 0x1c));
        *((ebx + 0x1c)) = edx;
        edx = *((eax + 0x20));
        *((ebx + 0x20)) = edx;
        edx = *((eax + 0x24));
        *((ebx + 0x24)) = edx;
        edx = *((eax + 0x28));
        *((ebx + 0x28)) = edx;
        edx = *((eax + 0x2c));
        *((ebx + 0x2c)) = edx;
        edx = *((eax + 0x30));
        *((ebx + 0x30)) = edx;
        edx = *((eax + 0x34));
        *((ebx + 0x34)) = edx;
        edx = *((eax + 0x38));
        *((ebx + 0x38)) = edx;
        eax = *((eax + 0x3c));
        *((ebx + 0x3c)) = eax;
        eax = *((ebp - 0x20));
        edx = *((ebp - 0x1c));
        caml_MD5Transform (edx, eax);
        esi += 0x40;
        eax = edi;
        eax -= esi;
    } while (eax > 0x3f);
    edi -= 0x40;
    eax = edi;
    eax &= 0xffffffc0;
    edx = *((ebp + 0xc));
    edx = edx + eax + 0x40;
    *((ebp + 0xc)) = edx;
    edi &= 0x3f;
label_1:
    eax = *((ebp + 8));
    eax += 0x18;
    edx = *((ebp + 0xc));
    memcpy (eax, edx, edi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8072eb8 */
#include <stdint.h>
 
int32_t caml_MD5Final (int32_t arg_8h, int32_t arg_ch) {
    int32_t c;
    size_t n;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = *((ebx + 0x10));
    eax >>= 3;
    eax &= 0x3f;
    *((ebx + eax + 0x18)) = 0x80;
    edx = ebx + eax + 0x19;
    ecx = 0x3f;
    ecx -= eax;
    eax = ecx;
    if (ecx <= 7) {
        memset (edx, 0, ecx);
        edi = ebx + 0x18;
        caml_MD5Transform (ebx, edi);
        edx = 0x38;
        eax = 0;
        if ((edi & 1) != 0) {
            *(edi) = al;
            edi++;
            edx--;
        }
        if ((edi & 2) != 0) {
            *(edi) = ax;
            edi += 2;
            edx -= 2;
        }
        ecx = edx;
        ecx >>= 2;
        memset (edi, eax, ecx);
        if ((dl & 2) != 0) {
            *(edi) = ax;
            edi += 2;
        }
        if ((dl & 1) == 0) {
            goto label_0;
        }
        *(edi) = al;
    } else {
        eax -= 8;
        memset (edx, 0, eax);
    }
label_0:
    eax = ebx + 0x18;
    edx = *((ebx + 0x10));
    *((eax + 0x38)) = edx;
    edx = *((ebx + 0x14));
    *((eax + 0x3c)) = edx;
    caml_MD5Transform (ebx, eax);
    eax = *(ebx);
    *(esi) = eax;
    eax = *((ebx + 4));
    *((esi + 4)) = eax;
    eax = *((ebx + 8));
    *((esi + 8)) = eax;
    eax = *((ebx + 0xc));
    *((esi + 0xc)) = eax;
    *(ebx) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062ff0 */
#include <stdint.h>
 
uint32_t unix_getpid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15910;
    getpid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049e64 */
#include <stdint.h>
 
void getpid (void) {
    getpid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065c30 */
#include <stdint.h>
 
int32_t unix_tcflow (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12cd0;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x22ec));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcflow ();
    if (eax == -1) {
        eax = ebx - 0x233e;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049e34 */
#include <stdint.h>
 
void tcflow (void) {
    tcflow ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d2c0 */
#include <stdint.h>
 
int32_t camlPrintf_scan_flags_1292 (void) {
    edi = eax;
    ebx = edx;
    ebx >>= 1;
    eax = *((esi + 0x1c));
    eax = *((eax + ebx));
    eax = eax + eax + 1;
    eax += 0xffffffc0;
    if (eax > 0x33) {
        void (*0x805d350)() ();
    }
    eax >>= 1;
    /* switch table (38 cases) at 0x8081674 */
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805cb70 */
#include <stdint.h>
 
int32_t case_0x805bba7_217 (void) {
    ecx = *((esi + 0x20));
    edx += 2;
    eax = ebx;
    ebx = edx;
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805cb90 */
#include <stdint.h>
 
int32_t case_0x805bba7_221 (void) {
    esi = *((esi + 0x14));
    ecx = edx;
    ecx += 2;
    edi = loc.camlPrintf__59;
    eax = ebx;
    ebx = edi;
    edx = esi;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805cbb0 */
#include <stdint.h>
 
int32_t case_0x805bba7_225 (void) {
    esi = *((esi + 0x14));
    ecx = edx;
    ecx += 2;
    edi = loc.camlPrintf__60;
    eax = ebx;
    ebx = edi;
    edx = esi;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805cbd0 */
#include <stdint.h>
 
int32_t case_0x805bba7_228 (void) {
    esi = *((esi + 0x14));
    ecx = edx;
    ecx += 2;
    edi = loc.camlPrintf__61;
    eax = ebx;
    ebx = edi;
    edx = esi;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805cd70 */
#include <stdint.h>
 
int32_t case_0x805bd3a_235 (void) {
    eax = *((esi + 0xc));
    ebx = edx;
    return camlPrintf_bad_conversion_format_1061 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ce40 */
#include <stdint.h>
 
uint32_t case_0x805bba7_251 (int32_t arg_ch_5, int32_t arg_10h_2, int32_t arg_14h_2, int32_t arg_18h_2) {
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx);
    ebx = eax;
    eax = *(esp);
    if (eax == 0xc7) {
        eax = 3;
        eax = camlString_make_1038 ();
        *(esp) = eax;
    } else {
        eax = ebx;
        camlChar_escaped_1038 ();
        ebx = loc.camlPrintf__56;
        eax = camlPervasives_$5e_1112 ();
        ebx = eax;
        eax = camlPrintf__55;
        eax = camlPervasives_$5e_1112 ();
        *(esp) = eax;
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805cfd0 */
#include <stdint.h>
 
uint32_t case_0x805bba7_250 (int32_t arg_ch_5, int32_t arg_10h_2, int32_t arg_14h_2, int32_t arg_18h_2) {
    ecx = *((esi + 0x28));
    camlPrintf_get_arg_1288 ();
    eax = camlPervasives_string_of_bool_1127 ();
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d1f0 */
#include <stdint.h>
 
uint32_t case_0x805bba7_224 (int32_t arg_4h_3, int32_t arg_8h_2, int32_t arg_ch_4, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx);
    eax = *((esp + 0xc));
    eax += 2;
    eax = *((esp + 4));
    eax = camlPrintf_sub_format_for_printf_1135 (eax, eax);
    ecx = eax;
    eax = *((esp + 0x18));
    eax = *((eax + 0xc));
    ebx = *(esp);
    eax = caml_apply2 ();
    *((esp + 0xc)) = eax;
    eax = *((esp + 4));
    if (eax == 0xf7) {
        eax = *((esp + 8));
        eax = camlPrintf_summarize_format_type_1162 ();
        *(esp) = eax;
        eax = *((esp + 0x10));
        if (eax != 1) {
            eax = *((esp + 0x14));
        } else {
            eax = .comment;
            ebx = *((eax + 8));
            ecx = *(ebx);
            eax = *((esp + 0x14));
            void (*ecx)() ();
        }
        ebx = *((esp + 0x18));
        edx = *((ebx + 0x14));
        ebx = *(esp);
        ecx = *((esp + 0xc));
        void (*0x804b580)() ();
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x24));
    ebx = *((esp + 8));
    ecx = *((esp + 0xc));
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805caa0 */
#include <stdint.h>
 
int32_t camlPrintf_get_arg_1288 (void) {
    if (eax != 1) {
        ebx = *(eax);
    }
    ecx = *((ecx + 0xc));
    eax = *((ecx - 4));
    edx = *((ecx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
        if (eax <= ebx) {
            goto label_0;
        }
        eax = *((ecx + ebx*2 - 2));
        return eax;
    }
    eax >>= 0xa;
    if (eax <= ebx) {
        goto label_1;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fba0 */
#include <stdint.h>
 
int32_t camlPervasives_string_of_float_1140 (void) {
    eax = caml_format_float;
    caml_c_call ("%.12g");
    return camlPervasives_valid_float_lexem_1135 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805da60 */
#include <stdint.h>
 
int32_t camlPrintf_extract_format_float_1110 (void) {
    eax = ebx;
    ebx = ecx;
    ecx = edx;
    edx = esi;
    camlPrintf_extract_format_1085 (eax);
    ebx = *(esp);
    if (ebx != 0x8d) {
        return eax;
    }
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx - 1;
    ebx >>= 1;
    ecx = *((eax - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((eax + ecx));
    ecx -= edx;
    if (ecx > ebx) {
        edx = 0x67;
        *((eax + ebx)) = dl;
        return eax;
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d8d0 */
#include <stdint.h>
 
int32_t camlPrintf_extract_format_1085 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    esi = eax;
    *(esp) = esi;
    *((esp + 4)) = ecx;
    *((esp + 0xc)) = edx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0xcf7;
    *(ecx) = sym.camlPrintf__skip_positional_spec_1090;
    *((ecx + 4)) = 3;
    *((ecx + 8)) = esi;
    eax = ebx;
    eax += 2;
    ebx = ecx;
    eax = camlPrintf_skip_positional_spec_1090 (ecx);
    ebx = eax;
    eax = *((esp + 4));
    eax -= ebx;
    eax += 0x15;
    eax = camlBuffer_create_1039 (ebx);
    ebx = 0x4b;
    camlBuffer_add_char_1072 (eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x1cf7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x805b960;
            eax = *(esp);
            *((ebx + 0xc)) = eax;
            eax = *((esp + 4));
            *((ebx + 0x10)) = eax;
            eax = *((esp + 8));
            *((ebx + 0x14)) = eax;
            eax = *((esp + 0x18));
            *((ebx + 0x18)) = eax;
            ebx = 1;
            eax = *((esp + 0xc));
            eax = camlList_rev_append_1051 (ebx);
            ebx = eax;
            eax = *((esp + 0x10));
            ecx = *((esp + 0x14));
            camlPrintf_fill_format_1096 ();
            eax = *((esp + 0x18));
            ecx = *((eax + 4));
            ebx = 1;
            eax = *(eax);
            void (*0x80558f0)() ();
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b8f0 */
#include <stdint.h>
 
int32_t camlPrintf_skip_positional_spec_1090 (void) {
    ecx = eax;
    edx = eax;
    edx >>= 1;
    eax = *((ebx + 8));
    eax = *((eax + edx));
    eax = eax + eax + 1;
    eax += 0xffffffa0;
    if (eax <= 0x13) {
        goto label_0;
    }
    eax = ecx;
    return eax;
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.camlPrintf__skip_int_literal_1092;
            *((edx + 4)) = 3;
            eax = *((ebx + 8));
            *((edx + 8)) = eax;
            *((edx + 0xc)) = ecx;
            eax = ecx;
            eax += 2;
            ebx = edx;
            void (*0x805b210)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805a910 */
#include <stdint.h>
 
int32_t camlBuffer_create_1039 (void) {
    if (eax < 3) {
        eax = 3;
    }
    ebx = .comment;
    if (eax > ebx) {
        eax = .comment;
        *(esp) = eax;
    } else {
        *(esp) = eax;
    }
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1000;
            *(eax) = ecx;
            *((eax + 4)) = 1;
            ebx = *(esp);
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ac00 */
#include <stdint.h>
 
int32_t camlBuffer_add_char_1072 (void) {
    int32_t var_4h_2;
    int32_t var_8h;
    *(esp) = eax;
    *((esp + 8)) = ebx;
    ecx = *((eax + 4));
    *((esp + 4)) = ecx;
    ebx = *((eax + 8));
    if (ecx >= ebx) {
        ebx = 3;
        camlBuffer_resize_1066 ();
    }
    esi = *(esp);
    ebx = *(esi);
    ecx = *((esp + 4));
    eax = *((esp + 4));
    eax >>= 1;
    edx = *((ebx - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    edi = *((ebx + edx));
    edx -= edi;
    if (edx > eax) {
        edx = *((esp + 8));
        edx >>= 1;
        *((ebx + eax)) = dl;
        ecx += 2;
        *((esi + 4)) = ecx;
        eax = 1;
        return eax;
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054610 */
#include <stdint.h>
 
int32_t camlList_rev_append_1051 (void) {
    do {
        if (eax == 1) {
            goto label_1;
        }
        esi = *((eax + 4));
        edx = *(eax);
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x800;
        *(ecx) = edx;
        *((ecx + 4)) = ebx;
        eax = esi;
        ebx = ecx;
    } while (1);
label_1:
    eax = ebx;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b960 */
#include <stdint.h>
 
int32_t camlPrintf_fill_format_1096 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
label_0:
        edx = *((ecx + 0x10));
        if (eax > edx) {
            goto label_1;
        }
        esi = eax;
        esi >>= 1;
        edx = *((ecx + 0xc));
        edx = *((edx + esi));
        edx = edx + edx + 1;
        if (edx == 0x55) {
            goto label_2;
        }
        eax = *((ecx + 0x18));
        ebx = edx;
        camlBuffer_add_char_1072 (ebx, eax, ecx);
        eax = *((esp + 4));
        eax += 2;
        ebx = *(esp);
        ecx = *((esp + 8));
    } while (1);
label_2:
    if (ebx == 1) {
        goto label_3;
    }
    eax = *((ebx + 4));
    eax = *(ebx);
    eax = camlPervasives_string_of_int_1130 (eax, eax, ecx);
    ebx = eax;
    eax = *((esp + 8));
    eax = *((eax + 0x18));
    camlBuffer_add_string_1082 ();
    eax = *((esp + 8));
    ebx = *((eax + 0x14));
    eax = *((esp + 4));
    eax += 2;
    camlPrintf_skip_positional_spec_1090 ();
    ebx = *(esp);
    ecx = *((esp + 8));
    goto label_0;
    do {
label_3:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Assert_failure;
            *((eax + 4)) = 0x8081100;
            caml_raise_exn ();
label_1:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075d28 */
#include <stdint.h>
 
void loc_caml_ml_array_bound_error (int32_t arg_4h) {
    edx = *(esp);
    *(obj.caml_last_return_address) = edx;
    edx = esp + 4;
    *(obj.caml_bottom_of_stack) = edx;
    return caml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e1e0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1600 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    eax = caml_format_float;
    eax = caml_c_call (eax);
    *((esp + 4)) = eax;
    eax = *(esp);
    eax = caml_classify_float;
    eax = caml_c_call (eax);
    if (eax >= 7) {
        eax = *((esp + 4));
        return eax;
    }
    eax = *((esp + 4));
    return camlPrintf_make_valid_float_lexeme_1270 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055c20 */
#include <stdint.h>
 
int32_t camlString_escaped_1080 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    edx = eax;
    *((esp + 0x10)) = edx;
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x400;
    *(ebx) = 1;
    eax = 1;
    ecx = *((edx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((edx + ecx));
    ecx -= edx;
    ecx = ecx + ecx - 1;
    if (eax > ecx) {
        goto label_2;
    }
    *((esp + 4)) = ecx;
    *(esp) = eax;
    *((esp + 0x14)) = ebx;
    do {
        eax >>= 1;
        ebx = *((esp + 0x10));
        eax = *((ebx + eax));
        eax = eax + eax + 1;
        if (eax >= 0x1d) {
            if (eax == 0x45) {
                goto label_3;
            }
            if (eax == 0xb9) {
                goto label_3;
            }
        } else {
            if (eax >= 0x17) {
                if (eax >= 0x1b) {
                    goto label_3;
                }
            } else {
                if (eax >= 0x11) {
                    goto label_3;
                }
            }
        }
        eax = caml_is_printable;
        eax = caml_c_call (eax);
        if (eax != 1) {
            ecx = 3;
        } else {
            ecx = 9;
            goto label_4;
label_3:
            ecx = 5;
        }
label_4:
        ebx = *((esp + 0x14));
        eax = *(ebx);
        eax += ecx;
        eax--;
        *(ebx) = eax;
        eax = *(esp);
        edx = *(esp);
        eax += 2;
        *(esp) = eax;
        ecx = *((esp + 4));
    } while (edx != ecx);
label_2:
    eax = *((esp + 0x10));
    ecx = *((eax - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((eax + ecx));
    ecx -= edx;
    edx = ecx + ecx + 1;
    ecx = *(ebx);
    if (ecx == edx) {
        return eax;
    }
    *((esp + 0x14)) = ebx;
    *((esp + 0x10)) = eax;
    eax = caml_create_string;
    eax = caml_c_call (*(ebx));
    esi = *((esp + 0x14));
    *(esi) = 1;
    eax = 1;
    ebx = *((esp + 0x10));
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx - 1;
    if (eax > ecx) {
        goto label_5;
    }
    *((esp + 8)) = ecx;
    *((esp + 4)) = eax;
    *((esp + 0xc)) = ebp;
    *((esp + 0x14)) = esi;
    *((esp + 0x10)) = ebx;
    do {
        eax >>= 1;
        ebx = *((esp + 0x10));
        eax = *((ebx + eax));
        eax = eax + eax + 1;
        ebx = eax;
        ebx += 0xffffffbc;
        if (ebx > 0x75) {
            if (ebx >= 0xffffffd9) {
                goto label_6;
            }
            ebx += 0x44;
            ebx >>= 1;
        }
        ebx += 0xfffffffe;
        if (ebx > 0x71) {
            ebx = *(esi);
            ebx >>= 1;
            edx = 0x5c;
            *((ebp + ebx)) = dl;
            *(esi) += 2;
            ebx = *(esi);
            ebx >>= 1;
            eax >>= 1;
            edx = eax;
            *((ebp + ebx)) = dl;
        } else {
label_6:
            *(esp) = eax;
            eax = caml_is_printable;
            eax = caml_c_call (eax);
            if (eax != 1) {
                esi = *((esp + 0x14));
                eax = *(esi);
                eax >>= 1;
                edx = *(esp);
                edx >>= 1;
                ebp = *((esp + 0xc));
                *((ebp + eax)) = dl;
            } else {
                edi = *(esp);
                esi = *((esp + 0x14));
                eax = *(esi);
                eax >>= 1;
                edx = 0x5c;
                ebp = *((esp + 0xc));
                *((ebp + eax)) = dl;
                *(esi) += 2;
                ebx = *(esi);
                ebx >>= 1;
                ecx = 0x64;
                eax = edi;
                eax >>= 1;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                edx = eax + eax + 0x61;
                edx >>= 1;
                *((ebp + ebx)) = dl;
                *(esi) += 2;
                ebx = *(esi);
                ebx >>= 1;
                eax = 0xa;
                *(esp) = eax;
                ecx = 0xa;
                eax = edi;
                eax >>= 1;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                ecx = *(esp);
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                edx = edx + edx + 0x61;
                edx >>= 1;
                *((ebp + ebx)) = dl;
                *(esi) += 2;
                ebx = *(esi);
                ebx >>= 1;
                ecx = 0xa;
                eax = edi;
                eax >>= 1;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                edx = edx + edx + 0x61;
                edx >>= 1;
                *((ebp + ebx)) = dl;
            }
        }
        *(esi) += 2;
        eax = *((esp + 4));
        ecx = *((esp + 4));
        eax += 2;
        *((esp + 4)) = eax;
        ebx = *((esp + 8));
    } while (ecx != ebx);
label_5:
    eax = ebp;
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d890 */
#include <stdint.h>
 
uint32_t camlPrintf_format_string_1080 (void) {
    eax = camlPrintf_parse_string_conversion_1067 (ebx);
    ecx = *((eax + 4));
    ebx = *(eax);
    edx = *(esp);
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    esi = *((edx + eax));
    eax -= esi;
    edi = eax + eax + 1;
    esi = 1;
    eax = 0x41;
    return camlPrintf_pad_string_1072 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80558f0 */
#include <stdint.h>
 
int32_t camlString_sub_1046 (void) {
    int32_t var_14h;
    int32_t var_18h;
    if (ebx >= 1) {
        if (ecx < 1) {
            goto label_0;
        }
        edx = *((eax - 4));
        edx >>= 0xa;
        edx = edx*4 - 1;
        esi = *((eax + edx));
        edx -= esi;
        edx <<= 1;
        edx -= ecx;
        edx += 2;
        if (ebx > edx) {
            goto label_0;
        }
        *(esp) = ecx;
        *((esp + 4)) = ebx;
        *((esp + 8)) = eax;
        eax = caml_create_string;
        eax = caml_c_call (ecx);
        ebx = eax;
        eax = *(esp);
        eax = *((esp + 0x10));
        eax = *((esp + 0x18));
        caml_blit_string (eax, eax, ebx, 1, eax);
        eax = ebx;
        return eax;
    }
label_0:
    eax = "String.sub";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055860 */
#include <stdint.h>
 
int32_t camlString_make_1038 (void) {
    int32_t var_4h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    eax = *((esp + 8));
    caml_fill_string (ebx, 1, eax, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cdec */
#include <stdint.h>
 
int32_t caml_fill_string (void * s, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t c;
    size_t n;
    ecx = *((ebp + 0x10));
    ecx >>= 1;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    edx = *((ebp + 0x14));
    edx >>= 1;
    memset (eax, edx, ecx);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a074 */
#include <stdint.h>
 
void memset (void) {
    memset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80559c0 */
#include <stdint.h>
 
int32_t camlString_blit_1056 (void) {
    if (esi >= 1) {
        if (ebx < 1) {
            goto label_0;
        }
        edi = *((eax - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((eax + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= esi;
        ebp += 2;
        if (ebx > ebp) {
            goto label_0;
        }
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ecx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ecx + ebp));
        ebp -= edi;
        edi = ebp;
        edi <<= 1;
        edi -= esi;
        edi += 2;
        if (edx > edi) {
            goto label_0;
        }
        caml_blit_string (eax, ebx, ecx, edx, esi);
        return;
    }
label_0:
    eax = "String.blit";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d720 */
#include <stdint.h>
 
int32_t camlPrintf_parse_string_conversion_1067 (void) {
    ebx = eax;
    *(esp) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x805b7c0;
            *((ecx + 0xc)) = ebx;
            eax = void (*0x805d7a0)() ();
            ecx = caml_exn_Failure;
            ebx = *(eax);
            if (ebx == ecx) {
                ecx = 0xe7;
                ebx = 1;
                eax = *(esp);
                void (*0x805d630)() ();
            }
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            ebx = 3;
            eax = 1;
            camlPrintf_parse_1069 (*(obj.caml_exception_pointer));
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d9e0 */
#include <stdint.h>
 
int32_t camlPrintf_extract_format_int_1103 (void) {
    eax = ebx;
    ebx = ecx;
    ecx = edx;
    edx = esi;
    camlPrintf_extract_format_1085 (eax);
    ebx = *(esp);
    if (ebx != 0x9d) {
        if (ebx == 0xdd) {
            goto label_0;
        }
        return eax;
    }
label_0:
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx - 1;
    ebx >>= 1;
    ecx = *((eax - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((eax + ecx));
    ecx -= edx;
    if (ecx > ebx) {
        edx = 0x75;
        *((eax + ebx)) = dl;
        return eax;
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e0b0 */
#include <stdint.h>
 
int32_t camlPrintf_scan_positional_spec_1252 (void) {
    esi = eax;
    edi = ebx;
    ebx = edx;
    eax = edx;
    eax >>= 1;
    eax = *((esi + eax));
    edx = eax + eax + 1;
    eax = edx;
    eax += 0xffffffa0;
    if (eax <= 0x13) {
        goto label_0;
    }
    eax = 1;
    ecx = edi;
    void (*0x804b5d0)() ();
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x18f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x805c960;
            *((ecx + 0xc)) = esi;
            *((ecx + 0x10)) = edi;
            *((ecx + 0x14)) = ebx;
            ebx += 2;
            eax = edx;
            eax += 0xffffffa0;
            void (*0x805c960)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049e24 */
#include <stdint.h>
 
void sprintf (void) {
    sprintf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a184 */
#include <stdint.h>
 
void strtol (void) {
    strtol ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050380 */
#include <stdint.h>
 
int32_t camlPervasives_exit_1326 (void) {
    eax = .comment;
    ebx = *(eax);
    eax = 1;
    ecx = *(ebx);
    void (*ecx)(uint32_t) (eax);
    eax = *(esp);
    eax = caml_sys_exit;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055560 */
#include <stdint.h>
 
int32_t camlChar_chr_1032 (void) {
    if (eax >= 1) {
        if (eax > 0x1ff) {
            goto label_0;
        }
        return;
    }
label_0:
    eax = "Char.chr";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c070 */
#include <stdint.h>
 
int32_t camlUnix_fun_2614 (void) {
    eax = unix_getpwuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805c530 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1581 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = ebx;
    *((esp + 8)) = ecx;
    *((esp + 4)) = edx;
    *(esp) = esi;
    eax = caml_make_vect;
    eax = caml_c_call (9);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0x10));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0x10));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 0xc));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 7) {
            goto label_6;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 0xc;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 7) {
            goto label_7;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x18)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b5d0)() ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c610 */
#include <stdint.h>
 
int32_t camlUnix_fun_2776 (void) {
    eax = unix_putenv;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8053600 */
#include <stdint.h>
 
int32_t camlArray_entry (void) {
    eax = loc.camlArray__21;
    *(loc.camlArray) = eax;
    eax = loc.camlArray__20;
    *(0x807ce1c) = eax;
    eax = .comment;
    *(0x807ce20) = eax;
    eax = loc.camlArray__19;
    *(0x807ce30) = eax;
    eax = loc.camlArray__18;
    *(0x807ce24) = eax;
    eax = loc.camlArray__17;
    *(0x807ce68) = eax;
    eax = loc.camlArray__16;
    *(0x807ce28) = eax;
    eax = loc.camlArray__15;
    *(0x807ce2c) = eax;
    eax = loc.camlArray__14;
    *(0x807ce34) = eax;
    eax = loc.camlArray__13;
    *(0x807ce38) = eax;
    eax = loc.camlArray__12;
    *(0x807ce44) = eax;
    eax = loc.camlArray__11;
    *(0x807ce48) = eax;
    eax = loc.camlArray__10;
    *(0x807ce4c) = eax;
    eax = loc.camlArray__9;
    *(0x807ce50) = eax;
    eax = loc.camlArray__8;
    *(0x807ce3c) = eax;
    eax = loc.camlArray__7;
    *(0x807ce6c) = eax;
    eax = loc.camlArray__6;
    *(0x807ce40) = eax;
    eax = loc.camlArray__5;
    *(0x807ce54) = eax;
    eax = loc.camlArray__4;
    *(0x807ce58) = eax;
    caml_alloc1 ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = "Array.Bottom";
    *(0x807ce70) = eax;
    eax = loc.camlArray__2;
    *(0x807ce5c) = eax;
    *(0x807ce74) = 0xb;
    eax = camlArray__1;
    *(0x807ce60) = eax;
    eax = .comment;
    *(0x807ce64) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075b08 */
#include <stdint.h>
 
int32_t loc_caml_alloc1 (int32_t arg_4h) {
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            return eax;
        }
        eax = *(esp);
        *(obj.caml_last_return_address) = eax;
        eax = esp + 4;
        *(obj.caml_bottom_of_stack) = eax;
        fcn_08075aed ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075aed */
#include <stdint.h>
 
void fcn_08075aed (void) {
    *(obj.caml_gc_regs) = esp;
    caml_garbage_collection (eax, ebx, ecx, edx, esi, edi);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ca70 */
#include <stdint.h>
 
int32_t caml_floor_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    floor (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a0d4 */
#include <stdint.h>
 
void floor (void) {
    floor ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f780 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1500 (void) {
    ebx = *((ebx + 8));
    eax = 1;
    ecx = *(ebx);
    void (*ecx)(uint32_t) (ebx);
    eax = *(esp);
    ebx = *((eax + 0xc));
    eax = 1;
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a11b */
#include <stdint.h>
 
uint32_t caml_alloc_for_heap (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = ebp - 0xc;
    eax = ebx + 0x10;
    eax = caml_aligned_malloc (ebx, 0x10, eax);
    if (eax != 0) {
        eax += 0x10;
        edx = eax - 0x10;
        *((edx + 8)) = ebx;
        ecx = *((ebp - 0xc));
        *(edx) = ecx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068254 */
#include <stdint.h>
 
int32_t caml_aligned_malloc (size_t size, int32_t arg_ch, void ** arg_10h) {
    ebx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax += 0x1000;
    eax = malloc (eax);
    edx = eax;
    eax = 0;
    if (edx != 0) {
        eax = *((ebp + 0x10));
        *(eax) = edx;
        edx += ebx;
        edx &= 0xfffff000;
        eax = edx + 0x1000;
        eax -= ebx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806db92 */
#include <stdint.h>
 
int32_t caml_channel_size (int32_t arg_8h) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    ebx = *(eax);
    edx = *((eax + 4));
    *((ebp - 0x1c)) = edx;
    eax = *((eax + 8));
    *((ebp - 0x20)) = eax;
    caml_enter_blocking_section ();
    *((esp + 0xc)) = 2;
    *((esp + 4)) = 0;
    *((esp + 8)) = 0;
    *(esp) = ebx;
    eax = lseek64 ();
    esi = eax;
    edi = edx;
    eax &= edx;
    if (eax != -1) {
        *((esp + 0xc)) = 0;
        eax = *((ebp - 0x1c));
        *((esp + 4)) = eax;
        edx = *((ebp - 0x20));
        *((esp + 8)) = edx;
        *(esp) = ebx;
        eax = lseek64 ();
        edx ^= *((ebp - 0x20));
        eax ^= *((ebp - 0x1c));
        edx |= eax;
        if (edx == 0) {
            goto label_0;
        }
    }
    caml_leave_blocking_section ();
    caml_sys_error (1);
label_0:
    caml_leave_blocking_section ();
    eax = esi;
    edx = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80623fa */
#include <stdint.h>
 
int32_t unix_ftruncate (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16506;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((esp + 8)) = edx;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = ftruncate64 ();
    if (eax == -1) {
        eax = ebx - 0x25a3;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a5b4 */
#include <stdint.h>
 
void ftruncate64 (void) {
    ftruncate64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050260 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1491 (void) {
    eax = caml_ml_seek_in_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c050 */
#include <stdint.h>
 
int32_t camlUnix_fun_2610 (void) {
    eax = unix_inet_addr_of_string;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061ea8 */
#include <stdint.h>
 
int32_t unix_environment (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16a58;
    eax = *((ebx - 0x14));
    eax = *(eax);
    caml_copy_string_array (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060da0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_method_impl_1529 (void) {
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 0xc)) = eax;
    edx = ebx;
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        void (*0x80613f4)() ();
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x10f7;
    *(ebx) = sym.camlCamlinternalOO__next_1533;
    *((ebx + 4)) = 3;
    *((ebx + 8)) = edx;
    *((ebx + 0xc)) = ecx;
    eax = 1;
    eax = camlCamlinternalOO_next_1533 (ebx);
    if ((eax & 1) == 0) {
        void (*0x80613f0)() ();
    }
    eax >>= 1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f0c0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_next_1533 (void) {
    eax = *((ebx + 8));
    *(eax) += 2;
    eax = *((ebx + 8));
    ecx = *(eax);
    ebx = *((ebx + 0xc));
    eax = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
        if (eax <= ecx) {
            goto label_0;
        }
        eax = *((ebx + ecx*2 - 2));
        return eax;
    }
    eax >>= 0xa;
    if (eax <= ecx) {
        goto label_1;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bb40 */
#include <stdint.h>
 
int32_t loc_camlUnix_code_begin (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x801;
            *(edx) = esi;
            eax = *((ecx + 0x14));
            *((edx + 4)) = eax;
            eax = edx + 0xc;
            *((eax - 4)) = 0x1400;
            *(eax) = 3;
            esi = *((ecx + 0x10));
            *((eax + 4)) = esi;
            ecx = *((ecx + 0xc));
            ecx = *(ecx);
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058420 */
#include <stdint.h>
 
int32_t camlMarshal_fun_1064 (void) {
    eax = caml_input_value;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b970 */
#include <stdint.h>
 
int32_t caml_int64_to_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a1d2 */
#include <stdint.h>
 
int32_t caml_page_table_remove (int32_t arg_8h, char * arg_ch, int32_t arg_10h) {
    edi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx &= 0xfffff000;
    esi = *((ebp + 0x10));
    esi--;
    esi &= 0xfffff000;
    if (ebx > esi) {
        goto label_0;
    }
    do {
        ecx = 0;
        edx = edi;
        eax = ebx;
        eax = caml_page_table_modify ();
        if (eax != 0) {
            eax = 0xffffffff;
            goto label_1;
        }
        ebx += 0x1000;
    } while (esi >= ebx);
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f290 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_compare_1139 (void) {
    eax = caml_compare;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e980 */
#include <stdint.h>
 
int32_t camlCallback_entry (void) {
    eax = loc.camlCallback__2;
    *(loc.camlCallback) = eax;
    eax = camlCallback__1;
    *(0x80829a0) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067c7b */
#include <stdint.h>
 
int32_t caml_convert_signal_number (int32_t arg_8h) {
    eax = *((ebp + 8));
    if (eax < 0) {
        if (eax <= 0xffffffea) {
            goto label_0;
        }
        eax = ~eax;
        eax = *((eax*4 + obj.posix_signals));
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8074cf4 */
#include <stdint.h>
 
int32_t caml_final_release (void) {
    *(obj.running_finalisation_function) = 0;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f760 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_get_method_1199 (void) {
    int32_t var_4h;
    ecx = eax;
    eax = ebx;
    eax = void (*0x805f7b0)(uint32_t, uint32_t) (ecx, eax);
    ecx = loc.caml_exn_Not_found;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *(esp);
        ecx = *((eax + 4));
        ebx = *((ecx - 4));
        ebx >>= 9;
        eax = *((esp + 4));
        if (ebx <= eax) {
            goto label_0;
        }
        eax = *((ecx + eax*2 - 2));
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ebx = *((ecx + 0x14));
    camlList_assoc_1169 (*(obj.caml_exception_pointer));
    return eax;
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054c60 */
#include <stdint.h>
 
int32_t camlList_assoc_1169 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 4)) = ecx;
        ecx = *(ebx);
        ebx = *((ecx + 4));
        *((esp + 8)) = ebx;
        ebx = *(ecx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073a30 */
#include <stdint.h>
 
int32_t caml_named_value (int32_t arg_8h) {
    char * s2;
    esi = *((ebp + 8));
    eax = *((ebp + 8));
    hash_value_name (ebx, esi);
    ebx = *((eax*4 + obj.named_value_table));
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        eax = strcmp (esi, eax);
        if (eax == 0) {
            eax = ebx;
            goto label_1;
        }
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807431b */
#include <stdint.h>
 
int32_t caml_weak_create (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax >>= 1;
    ebx = eax + 1;
    if (eax > 0x3ffffe) {
        caml_invalid_argument ("Weak.create");
    }
    caml_alloc_shr (ebx, 0xfb);
    if (ebx <= 1) {
        goto label_0;
    }
    edx = 1;
    do {
        ecx = caml_weak_none;
        *((eax + edx*4)) = ecx;
        edx++;
    } while (ebx > edx);
label_0:
    edx = caml_weak_list_head;
    *(eax) = edx;
    *(obj.caml_weak_list_head) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bf68 */
#include <stdint.h>
 
int32_t caml_int64_mod (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    ebx = *((edx + 4));
    ecx = *((edx + 8));
    edx = *((eax + 4));
    eax = *((eax + 8));
    esi = *((eax + 8));
    esi |= edx;
    if (esi == 0) {
        eax = caml_raise_zero_divide ();
    }
    esi = ecx - 0x80000000;
    esi |= ebx;
    if (esi == 0) {
        esi = edx;
        esi &= eax;
        if (esi == -1) {
            eax = caml_copy_int64 (0, 0);
        }
    } else {
        eax = _moddi3 (eax, ecx, edx);
        caml_copy_int64 (eax, edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065fa1 */
#include <stdint.h>
 
uint32_t unix_tcgetattr (int32_t arg_8h) {
    int32_t var_3ch;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x1295d;
    eax = ebx + 0xbe94;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcgetattr ();
    if (eax == -1) {
        eax = ebx - 0x2311;
        uerror (eax, 0);
    }
    eax = caml_alloc_tuple (0x26);
    *((ebp - 0x28)) = eax;
    eax = *((ebx + 0xba14));
    if (eax == 4) {
        goto label_1;
    }
    edi = *((ebp - 0x28));
    edx = ebx + 0xba14;
    ecx = 0xffffdd54;
    *((ebp - 0x2c)) = ecx;
    ecx = ebx + 0xbe94;
    *((ebp - 0x30)) = ecx;
label_0:
    esi = edx + 4;
    if (eax != 1) {
        if (eax <= 1) {
            if (eax == 0) {
                goto label_2;
            }
            goto label_3;
        }
        if (eax == 2) {
            goto label_4;
        }
        if (eax != 3) {
            goto label_3;
        }
        goto label_5;
label_2:
        edx = esi + 4;
        eax = *(esi);
        eax = *(eax);
        eax &= *(edx);
        eax -= eax;
        eax &= 0xfffffffe;
        eax += 3;
        esi = edx + 4;
        *(edi) = eax;
        goto label_3;
    }
    eax = *(esi);
    *((ebp - 0x20)) = eax;
    ecx = *((esi + 4));
    *((ebp - 0x24)) = ecx;
    ecx = *((esi + 8));
    eax = *((esi + 0xc));
    *((ebp - 0x3c)) = eax;
    esi += 0x10;
    *((ebp - 0x1c)) = esi;
    if (ecx <= 0) {
        goto label_6;
    }
    esi = eax;
    eax = *((ebp - 0x20));
    esi &= *(eax);
    *((ebp - 0x20)) = 0;
    eax = *((ebp - 0x1c));
    if (esi != *(eax)) {
        goto label_7;
    }
    while (ecx > eax) {
        if (*((edx + eax*4 + 0x14)) == esi) {
            *((ebp - 0x20)) = eax;
            eax = *((ebp - 0x20));
            eax += *((ebp - 0x24));
            eax = eax + eax + 1;
            *(edi) = eax;
            goto label_6;
label_7:
            eax = *((ebp - 0x20));
        }
        eax++;
    }
label_6:
    eax = *((ebp - 0x1c));
    esi = eax + ecx*4;
    goto label_3;
label_4:
    edx = *(esi);
    esi += 4;
    *(edi) = 0x4b01;
    if (edx != 0) {
        eax = 0;
        if (edx != 1) {
            goto label_8;
        }
        ecx = *((ebp - 0x30));
        *(esp) = ecx;
        cfgetospeed ();
    } else {
        eax = *((ebp - 0x30));
        *(esp) = eax;
        eax = cfgetispeed ();
    }
label_8:
    edx = 1;
    ecx = *((ebp - 0x2c));
    if (*((ebx + ecx)) != eax) {
        goto label_9;
    }
    dl = 0;
    while (edx != 0x12) {
label_9:
        if (*((ebx + edx*8 - 0x22ac)) == eax) {
            eax = *((ebx + edx*8 - 0x22a8));
            eax = eax + eax + 1;
            *(edi) = eax;
            goto label_3;
        }
        edx++;
    }
    goto label_3;
label_5:
    eax = *(esi);
    esi += 4;
    eax = *((ebx + eax + 0xbea5));
    eax = eax + eax + 1;
    *(edi) = eax;
label_3:
    eax = *(esi);
    if (eax != 4) {
        edi += 4;
        edx = esi;
        goto label_0;
    }
label_1:
    eax = *((ebp - 0x28));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f8b6 */
#include <stdint.h>
 
uint32_t caml_output_val (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    eax = caml_channel_binary_mode (ebx, esi, edi);
    if (eax == 0) {
        caml_failwith ("output_value: not a binary channel");
    }
    init_extern_output ();
    edx = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    extern_value ();
    ebx = extern_output_first;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        edx = *((ebx + 4));
        edx -= eax;
        caml_really_putblock (edi, eax, edx);
        esi = *(ebx);
        free (ebx);
        if (esi == 0) {
            goto label_0;
        }
        ebx = esi;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fc20 */
#include <stdint.h>
 
int32_t camlPervasives_open_out_gen_1175 (void) {
    eax = caml_sys_open;
    eax = caml_c_call (ecx);
    eax = caml_ml_open_descriptor_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b210 */
#include <stdint.h>
 
int32_t camlPrintf_skip_int_literal_1092 (void) {
    do {
        edx = eax;
        edx >>= 1;
        ecx = *((ebx + 8));
        ecx = *((ecx + edx));
        ecx = ecx + ecx + 1;
        if (ecx < 0x61) {
            goto label_0;
        }
        if (ecx >= 0x75) {
            goto label_1;
        }
        eax += 2;
    } while (1);
label_0:
    if (ecx == 0x49) {
        eax += 2;
        return eax;
    }
label_1:
    eax = *((ebx + 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075ed0 */
#include <stdint.h>
 
int32_t moddi3 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    uint32_t var_28h;
    uint32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_10h;
    int32_t var_ch;
    ecx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    edi = *((ebp + 0x14));
    edx = *((ebp + 8));
    *((ebp - 0x20)) = esi;
    *((ebp - 0x1c)) = edi;
    *((ebp - 0x2c)) = 0;
    if (ecx < 0) {
        goto label_5;
    }
label_3:
    esi = *((ebp - 0x1c));
    if (esi < 0) {
        goto label_6;
    }
label_2:
    eax = *((ebp - 0x1c));
    esi = ebp - 0x10;
    edi = *((ebp - 0x20));
    *((ebp - 0x30)) = edx;
    *((ebp - 0x28)) = edx;
    *((ebp - 0x24)) = edi;
    edi = ecx;
    if (eax != 0) {
        goto label_7;
    }
    if (*((ebp - 0x24)) <= ecx) {
        goto label_8;
    }
    eax = edx;
    edx = ecx;
    eax = *(edx:eax) / ebp - 0x24;
    edx = *(edx:eax) % ebp - 0x24;
label_1:
    eax = *((ebp - 0x2c));
    *(esi) = edx;
    *((esi + 4)) = 0;
    if (eax != 0) {
        goto label_9;
    }
    do {
        eax = *((ebp - 0x10));
        edx = *((ebp - 0xc));
        return eax;
label_7:
        if (eax <= ecx) {
            goto label_10;
        }
        *(esi) = edx;
        *((esi + 4)) = ecx;
label_0:
        eax = *((ebp - 0x2c));
    } while (eax == 0);
label_9:
    eax = *((ebp - 0x10));
    edx = *((ebp - 0xc));
    eax = -eax;
    edx += 0;
    edx = -edx;
    return eax;
label_10:
    __asm ("bsr edx, eax");
    edx ^= 0x1f;
    *((ebp - 0x20)) = edx;
    if (edx != 0) {
        goto label_11;
    }
    ecx = *((ebp - 0x28));
    if (*((ebp - 0x24)) <= ecx) {
        goto label_12;
    }
    while (1) {
        ecx = *((ebp - 0x28));
        *((esi + 4)) = edi;
        *(esi) = ecx;
        goto label_0;
label_8:
        edx = *((ebp - 0x24));
        if (edx == 0) {
            eax = 1;
            edx = 0;
            eax = *(edx:eax) / ebp - 0x24;
            edx = *(edx:eax) % ebp - 0x24;
            *((ebp - 0x24)) = eax;
        }
        eax = edi;
        edx = 0;
        eax = *(edx:eax) / ebp - 0x24;
        edx = *(edx:eax) % ebp - 0x24;
        eax = *((ebp - 0x28));
        eax = *(edx:eax) / ebp - 0x24;
        edx = *(edx:eax) % ebp - 0x24;
        goto label_1;
label_6:
        ebp - 0x20 = -ebp - 0x20;
        *((ebp - 0x1c)) += 0;
        ebp - 0x1c = -ebp - 0x1c;
        goto label_2;
label_5:
        edx = -edx;
        ecx += 0;
        ecx = -ecx;
        *((ebp - 0x2c)) = 0xffffffff;
        goto label_3;
label_11:
        ecx = *((ebp - 0x20));
        edx = eax;
        eax = 0x20;
        eax -= *((ebp - 0x20));
        edx <<= cl;
        *((ebp - 0x28)) = eax;
        eax = *((ebp - 0x24));
        ecx = *((ebp - 0x28));
        eax >>= cl;
        ecx = *((ebp - 0x20));
        eax |= edx;
        edx = edi;
        *((ebp - 0x38)) = eax;
        eax = *((ebp - 0x24));
        eax <<= cl;
        ecx = *((ebp - 0x28));
        *((ebp - 0x34)) = eax;
        eax = *((ebp - 0x30));
        edx >>= cl;
        ecx = *((ebp - 0x20));
        edi <<= cl;
        ecx = *((ebp - 0x28));
        eax >>= cl;
        ecx = *((ebp - 0x20));
        eax |= edi;
        edi = *((ebp - 0x30));
        eax = *(edx:eax) / ebp - 0x38;
        edx = *(edx:eax) % ebp - 0x38;
        edi <<= cl;
        *((ebp - 0x24)) = edi;
        edi = edx;
        edx:eax = eax * *((ebp - 0x34));
        if (edi < edx) {
            goto label_13;
        }
        if (*((ebp - 0x24)) < eax) {
            goto label_14;
        }
label_4:
        ecx = *((ebp - 0x24));
        ecx -= eax;
        edi -= edx;
        edx = ecx;
        ecx = *((ebp - 0x20));
        eax = edi;
        edx >>= cl;
        ecx = *((ebp - 0x28));
        eax <<= cl;
        ecx = *((ebp - 0x20));
        eax |= edx;
        *(esi) = eax;
        edi >>= cl;
        *((esi + 4)) = edi;
        goto label_0;
label_12:
        edx = *((ebp - 0x28));
        edx -= *((ebp - 0x24));
        edi -= eax;
        *((ebp - 0x28)) = edx;
    }
label_14:
    if (edi != edx) {
        goto label_4;
    }
label_13:
    eax -= *((ebp - 0x34));
    edx -= *((ebp - 0x38));
    goto label_4;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056320 */
#include <stdint.h>
 
uint32_t camlString_rcontains_from_1140 (void) {
    if (ebx >= 1) {
        edx = *((eax - 4));
        edx >>= 0xa;
        edx = edx*4 - 1;
        esi = *((eax + edx));
        edx -= esi;
        edx = edx + edx + 1;
        if (ebx >= edx) {
            goto label_0;
        }
        eax = void (*0x8056370)() ();
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 1;
            return eax;
        }
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        camlString_rindex_rec_1121 (*(obj.caml_exception_pointer));
        eax = 3;
        return eax;
    }
label_0:
    eax = "String.rcontains_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80561c0 */
#include <stdint.h>
 
int32_t camlString_rindex_rec_1121 (void) {
    do {
        if (ebx < 1) {
label_0:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_1;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        edx = ebx;
        edx >>= 1;
        edx = *((eax + edx));
        edx = edx + edx + 1;
        if (edx == ecx) {
            eax = ebx;
            return eax;
        }
        ebx += 0xfffffffe;
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804abf0 */
#include <stdint.h>
 
int32_t caml_curry9_5 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_6;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bba0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2828 (void) {
    if ((eax & 1) != 0) {
        eax >>= 1;
        if (eax < 2) {
            goto label_0;
        }
        eax = *((ebx + 0x10));
        *(eax) = 3;
        eax = 1;
        return eax;
    }
    ecx = *((eax - 4));
    if (ecx < 1) {
        goto label_0;
    }
    if (ecx > 1) {
        goto label_1;
    }
    ecx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = ecx;
            caml_modify (*((ebx + 8)), eax);
            eax = 1;
            return eax;
label_1:
            ecx = *(eax);
            eax = *((ebx + 0xc));
            *(eax) = ecx;
            eax = 1;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064f18 */
#include <stdint.h>
 
int32_t unix_socket (int32_t domain, int32_t arg_ch, int32_t arg_10h) {
    int32_t type;
    int32_t protocol;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x139e8;
    eax = *((ebp + 0x10));
    eax >>= 1;
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebx - 0x1c));
    eax = *((eax + edx*4));
    edx = *((ebp + 8));
    edx >>= 1;
    eax = *((ebx - 0x20));
    eax = *((eax + edx*4));
    eax = socket (eax, eax, eax);
    if (eax == -1) {
        eax = ebx - 0x2414;
        uerror (eax, 0);
    }
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a2b4 */
#include <stdint.h>
 
void socket (void) {
    socket ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060490 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_run_initializers_1316 (void) {
    ebx = *((ebx + 0x1c));
    if (ebx != 1) {
        void (*0x8060450)() ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d560 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1694 (void) {
    eax = *((ebx + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8051ec0 */
#include <stdint.h>
 
int32_t camlArray_copy_1049 (void) {
    int32_t var_4h;
    ebx = eax;
    ecx = *((ebx - 4));
    eax = *((ebx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        ecx >>= 9;
    } else {
        ecx >>= 0xa;
    }
    ecx |= 1;
    if (ecx == 1) {
        eax = loc.camlArray__32;
        return eax;
    }
    *(esp) = ecx;
    *((esp + 4)) = ebx;
    eax = *((ebx - 4));
    if (eax != 0xfe) {
        eax = *(ebx);
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(eax) = fp_stack[0];
        fp_stack--;
    }
    eax = caml_make_vect;
    eax = caml_c_call (ecx);
    esi = eax;
    ebx = 3;
    edi = *(esp);
    edi += 0xfffffffe;
    if (ebx > edi) {
        goto label_3;
    }
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            edx = *((ecx + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebx*2 - 2, edx);
        } else {
            *(fp_stack--) = *(edx);
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = ebx;
        ebx += 2;
    } while (eax != edi);
label_3:
    eax = esi;
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d701 */
#include <stdint.h>
 
int32_t caml_ml_pos_in_64 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_in (eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d6a4 */
#include <stdint.h>
 
int32_t caml_pos_in (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    eax = *((ebp + 8));
    edx = *((eax + 0x14));
    edx -= *((eax + 0x10));
    ecx = edx;
    ecx >>= 0x1f;
    ebx = *((eax + 4));
    esi = *((eax + 8));
    ebx -= edx;
    esi -= ecx;
    eax = ebx;
    edx = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061d94 */
#include <stdint.h>
 
uint32_t unix_connect (int32_t socket, int32_t arg_ch) {
    int32_t var_7ch;
    int32_t var_78h;
    void * addr;
    size_t addrlen;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x16b68;
    eax = ebp - 0x7c;
    esi = ebp - 0x78;
    eax = *((ebp + 0xc));
    get_sockaddr (eax, esi, eax);
    caml_enter_blocking_section ();
    eax = *((ebp - 0x7c));
    eax = *((ebp + 8));
    eax >>= 1;
    eax = connect (eax, esi, eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x261d;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064f80 */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
int32_t get_sockaddr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13978;
    eax = *((ebp + 8));
    esi = *((ebp + 0xc));
    edi = eax;
    edx = *((eax - 4));
    if (dl != 0) {
        if (dl != 1) {
            goto label_0;
        }
    } else {
        eax = *(eax);
        *((ebp - 0x1c)) = eax;
        eax = caml_string_length (eax);
        edi = eax;
        *(esi) = 1;
        if (eax > 0x6b) {
            eax = *((ebp - 0x1c));
            eax = ebx - 0x14c4;
            unix_error (0x24, eax, eax);
        }
        eax = eax + 1;
        edx = *((ebp - 0x1c));
        esi += 2;
        memmove (esi, edx, eax);
        edi += 2;
        eax = *((ebp + 0x10));
        *(eax) = edi;
        goto label_0;
    }
    *((ebp - 0x1c)) = eax;
    eax = *(eax);
    eax = caml_string_length (eax);
    if (eax != 0x10) {
        goto label_1;
    }
    edx = esi;
    ecx = 0;
    al = 0;
    do {
        *((edx + eax)) = ecx;
        eax += 4;
    } while (eax < 0x1c);
    *(esi) = 0xa;
    edx = *((ebp - 0x1c));
    eax = *(edx);
    edx = *(eax);
    *((esi + 8)) = edx;
    edx = *((eax + 4));
    *((esi + 0xc)) = edx;
    edx = *((eax + 8));
    *((esi + 0x10)) = edx;
    eax = *((eax + 0xc));
    *((esi + 0x14)) = eax;
    eax = *((edi + 4));
    eax >>= 1;
    ax = rotate_right16 (ax, 8);
    *((esi + 2)) = ax;
    eax = *((ebp + 0x10));
    *(eax) = 0x1c;
    goto label_0;
label_1:
    *(esi) = 0;
    *((esi + 4)) = 0;
    *((esi + 8)) = 0;
    *((esi + 0xc)) = 0;
    *(esi) = 2;
    edx = *((ebp - 0x1c));
    eax = *(edx);
    eax = *(eax);
    *((esi + 4)) = eax;
    eax = *((edi + 4));
    eax >>= 1;
    ax = rotate_right16 (ax, 8);
    *((esi + 2)) = ax;
    eax = *((ebp + 0x10));
    *(eax) = 0x10;
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049e44 */
#include <stdint.h>
 
void connect (void) {
    connect ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806dced */
#include <stdint.h>
 
uint32_t caml_ml_input (int32_t arg_8h, void * s1, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    void * s2;
    size_t n;
    edi = caml_local_roots;
    *((ebp - 0x38)) = edi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp + 0x14;
    *((ebp - 0x20)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebp - 0x40)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    *((ebp - 0x3c)) = esi;
    eax = *((ebx + 0x10));
    esi = *((ebx + 0x14));
    esi -= eax;
    if (*((ebp - 0x3c)) <= esi) {
        edx = *((ebp - 0x3c));
        eax = *((ebp - 0x40));
        eax += *((ebp + 0xc));
        memmove (eax, eax, edx);
        eax = *((ebp - 0x3c));
        *((ebx + 0x10)) += eax;
        esi = eax;
    } else {
        if (esi > 0) {
            eax = *((ebp - 0x40));
            eax += *((ebp + 0xc));
            memmove (eax, eax, esi);
            *((ebx + 0x10)) += esi;
        } else {
            edx = ebx + 0x34;
            *((ebp - 0x44)) = edx;
            eax = *((ebx + 0xc));
            eax -= edx;
            eax = *(ebx);
            eax = caml_do_read (eax, edx, eax);
            esi = eax;
            edx = eax;
            edx >>= 0x1f;
            *((ebx + 4)) += eax;
            *((ebx + 8)) += edx;
            eax = ebx + esi + 0x34;
            *((ebx + 0x14)) = eax;
            if (esi > *((ebp - 0x3c))) {
                esi = *((ebp - 0x3c));
            }
            eax = *((ebp - 0x44));
            eax = *((ebp - 0x40));
            eax += *((ebp + 0xc));
            memmove (eax, eax, esi);
            eax = ebx + esi + 0x34;
            *((ebx + 0x10)) = eax;
        }
    }
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = edi;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80549e0 */
#include <stdint.h>
 
uint32_t camlList_fold_right2_1128 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        esi = *((ecx + 4));
        ecx = *(ecx);
        edi = *((ebx + 4));
        ecx = *(ebx);
        ebx = edi;
        ecx = esi;
        eax = camlList_fold_right2_1128 (ecx, ecx, eax);
    } while (1);
    ecx = eax;
    eax = *(esp);
    ebx = *((esp + 4));
    edx = *((esp + 8));
    void (*0x804b580)() ();
label_0:
    if (ecx == 1) {
        eax = edx;
        return eax;
    }
label_1:
    eax = "List.fold_right2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054a40 */
#include <stdint.h>
 
int32_t camlList_for_all_1137 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t) (edx, eax);
        if (eax == 1) {
            goto label_1;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_1:
    eax = 1;
    return eax;
label_0:
    eax = 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d454 */
#include <stdint.h>
 
int32_t caml_array_set_float (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xb;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    ecx = *((ebp + 0x10));
    *(fp_stack--) = *(ecx);
    *((edx + eax*8)) = fp_stack[0];
    fp_stack--;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805dde0 */
#include <stdint.h>
 
int32_t camlPrintf_kapr_1209 (void) {
    int32_t var_4h;
    eax = ebx;
    eax = camlPrintf_ac_of_format_1184 (eax, eax);
    ebx = *(eax);
    while (1) {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x18f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x805bfe0;
            eax = *(esp);
            *((ecx + 0xc)) = eax;
            eax = *((esp + 4));
            *((ecx + 0x10)) = eax;
            *((ecx + 0x14)) = ebx;
            ebx = 1;
            eax = 1;
            void (*0x805bfe0)() ();
            ebx >>= 1;
            /* switch table (12 cases) at 0x80816dc */
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d6e0 */
#include <stdint.h>
 
int32_t camlUnix_create_process_1907 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = ebx;
    *(esp) = ecx;
    *((esp + 4)) = edx;
    *((esp + 8)) = esi;
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        return eax;
    }
    fcn_0804d730 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d730 */
#include <stdint.h>
 
int32_t fcn_0804d730 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_1ch) {
    *(obj.caml_exception_pointer) = esp;
    eax = *((esp + 8));
    ebx = *((esp + 0xc));
    ecx = *((esp + 0x10));
    camlUnix_perform_redirections_1900 (*(obj.caml_exception_pointer));
    eax = *((esp + 0x14));
    eax = *((esp + 0x1c));
    eax = unix_execvp;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d610 */
#include <stdint.h>
 
uint32_t camlUnix_perform_redirections_1900 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    eax = camlUnix_safe_dup_1894 (eax, ebx, ecx);
    eax = *((esp + 4));
    eax = camlUnix_safe_dup_1894 (eax);
    eax = *((esp + 8));
    eax = camlUnix_safe_dup_1894 (eax);
    eax = *(esp);
    camlUnix_safe_close_1898 (eax);
    eax = *((esp + 4));
    camlUnix_safe_close_1898 ();
    eax = *((esp + 8));
    camlUnix_safe_close_1898 ();
    eax = *((esp + 0x10));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x14));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 0x10));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x18));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 0x14));
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bfa0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2592 (void) {
    eax = unix_getsockname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805c6d0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1578 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = ebx;
    *((esp + 4)) = ecx;
    *(esp) = edx;
    eax = caml_make_vect;
    eax = caml_c_call (7);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0xc));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b5d0)() ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c796 */
#include <stdint.h>
 
int32_t caml_cosh_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    cosh (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a7d4 */
#include <stdint.h>
 
void cosh (void) {
    cosh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cceb */
#include <stdint.h>
 
int32_t caml_ml_string_length (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    edx = *((eax + edx));
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d580 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1707 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071394 */
#include <stdint.h>
 
int32_t caml_set_parser_trace (int32_t arg_8h) {
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    edx = *((ebp + 8));
    edx >>= 1;
    *(obj.caml_parser_trace) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065d1f */
#include <stdint.h>
 
int32_t unix_tcsendbreak (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12be1;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcsendbreak ();
    if (eax == -1) {
        eax = ebx - 0x2327;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a814 */
#include <stdint.h>
 
void tcsendbreak (void) {
    tcsendbreak ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068514 */
#include <stdint.h>
 
uint32_t caml_fl_merge_block (int32_t arg_8h) {
    int32_t var_20h;
    uint32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    edi = *((ebp + 8));
    eax = edi - 4;
    *((ebp - 0x10)) = eax;
    esi = *(eax);
    eax = *(eax);
    eax >>= 0xa;
    edx = caml_fl_cur_size;
    eax = edx + eax + 1;
    *(obj.caml_fl_cur_size) = eax;
    ebx = caml_fl_merge;
    *((ebp - 0x18)) = ebx;
    ecx = *(ebx);
    *((ebp - 0x14)) = ecx;
    if (*(obj.caml_allocation_policy) == 1) {
        eax = ebx;
        truncate_flp ();
    }
    edx = edi - 4;
    if (edx == *(obj.last_fragment)) {
        ecx = *((ebp - 0x10));
        eax = *(ecx);
        eax >>= 0xa;
        eax++;
        if (eax <= 0x3fffff) {
            esi = eax;
            esi <<= 0xa;
            *((edx - 4)) = esi;
            *(obj.caml_fl_cur_size)++;
        }
    } else {
        edx = edi;
    }
    edi = esi;
    edi >>= 0xa;
    ecx = edx + edi*4;
    eax = *((ebp - 0x14));
    eax -= 4;
    if (eax != ecx) {
        eax = ecx;
    } else {
        ecx = *((ebp - 0x14));
        ecx = *(ecx);
        *((ebp - 0x10)) = ecx;
        ecx = *((ebp - 0x14));
        ecx = *((ecx - 4));
        *((ebp - 0x20)) = ecx;
        ecx >>= 0xa;
        ecx = edi + ecx + 1;
        if (ecx > 0x3fffff) {
            goto label_0;
        }
        edi = *((ebp - 0x10));
        esi = *((ebp - 0x18));
        *(esi) = edi;
        if (*(obj.caml_allocation_policy) == 0) {
            eax = *((ebp - 0x14));
            eax = "hF\b\b";
            if (*(obj.fl_prev) == eax) {
                eax = ebx;
            }
            *(obj.fl_prev) = "hF\b\b";
        }
        esi = ecx;
        esi <<= 0xa;
        esi += 0x200;
        *((edx - 4)) = esi;
        eax = esi;
        eax >>= 0xa;
        eax = edx + eax*4;
        ecx = *((ebp - 0x10));
        *((ebp - 0x14)) = ecx;
    }
label_0:
    ecx = ebx - 4;
    edi = *(ecx);
    edi >>= 0xa;
    *((ebp - 0x10)) = edi;
    ebx = ebx + edi*4;
    *((ebp - 0x1c)) = ebx;
    ebx = edx - 4;
    if (*((ebp - 0x1c)) == ebx) {
        ebx = esi;
        ebx >>= 0xa;
        ebx = edi + ebx + 1;
        if (ebx <= 0x3ffffe) {
            ebx <<= 0xa;
            ebx += 0x200;
            *(ecx) = ebx;
        }
    } else {
        ecx = esi;
        ecx >>= 0xa;
        if (ecx != 0) {
            esi &= 0xfffffcff;
            esi |= 0x200;
            *((edx - 4)) = esi;
            esi = *((ebp - 0x14));
            *(edx) = esi;
            edi = *((ebp - 0x18));
            *(edi) = edx;
            *(obj.caml_fl_merge) = edx;
        } else {
            *(obj.last_fragment) = edx;
            *(obj.caml_fl_cur_size)--;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807626c */
#include <stdint.h>
 
void fini (void) {
    /* [14] -r-x section size 28 named .fini */
    void (*0x8076278)(uint32_t) (ebx);
    ebx += 0x2694;
    _do_global_dtors_aux ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059960 */
#include <stdint.h>
 
void camlMap_concat_or_join_1258 (void) {
    if (ecx != 1) {
        ecx = *(ecx);
        esi = *((esi + 0xc));
        void (*0x80597a0)() ();
    }
    ecx = *((esi + 0x10));
    ebx = edx;
    return camlMap_concat_1251 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c310 */
#include <stdint.h>
 
int32_t camlUnix_fun_2692 (void) {
    eax = unix_getcwd;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056050 */
#include <stdint.h>
 
int32_t camlString_lowercase_1098 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_map_1090 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805a780 */
#include <stdint.h>
 
int32_t camlBuffer_subst_1127 (void) {
    int32_t var_4h_2;
    int32_t var_8h;
    do {
label_0:
        edi = eax;
        eax = *((ecx + 0x18));
        if (ebx >= eax) {
            goto label_1;
        }
        edx = *((ecx + 0x14));
        eax = ebx;
        eax >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        ebp = esi*4 - 1;
        esi = *((edx + ebp));
        ebp -= esi;
        if (ebp <= eax) {
            goto label_2;
        }
        eax = *((edx + eax));
        edx = eax + eax + 1;
        if (edx == 0x49) {
            goto label_3;
        }
        if (edi != 0xb9) {
            goto label_4;
        }
        ebx = 0xb9;
        eax = *((ecx + 0xc));
        camlBuffer_add_char_1072 (edx, ebx, ecx);
        eax = *((esp + 8));
        eax = *((eax + 0xc));
        ebx = *(esp);
        camlBuffer_add_char_1072 ();
        ebx = *((esp + 4));
        ebx += 2;
        eax = 0x41;
        ecx = *((esp + 8));
    } while (1);
label_4:
    if (edx != 0xb9) {
        ebx = edx;
        eax = *((ecx + 0xc));
        camlBuffer_add_char_1072 (ebx, ebx, ecx);
        eax = *((esp + 4));
        ebx = *((esp + 4));
        ebx += 2;
        eax = *(esp);
        ecx = *((esp + 8));
        goto label_0;
    }
    eax = edx;
    ebx += 2;
    goto label_0;
label_3:
    *((esp + 8)) = ecx;
    if (edi == 0xb9) {
        eax = *((ecx + 0xc));
        ebx = edx;
        camlBuffer_add_char_1072 (ebx);
        ebx = *((esp + 4));
        ebx += 2;
        eax = 0x41;
        ecx = *((esp + 8));
        goto label_0;
    }
    ebx += 2;
    edx = *((ecx + 0x18));
    eax = *((ecx + 0x14));
    ecx = edx;
    eax = camlBuffer_find_ident_1114 ();
    ebx = eax;
    eax = *((ebx + 4));
    edx = *(ebx);
    eax = *((esp + 8));
    ebx = *((eax + 0x10));
    ecx = *(ebx);
    eax = edx;
    eax = void (*ecx)(uint32_t) (eax);
    ebx = eax;
    eax = *((esp + 8));
    eax = *((eax + 0xc));
    camlBuffer_add_string_1082 ();
    eax = 0x41;
    ebx = *(esp);
    ecx = *((esp + 8));
    goto label_0;
label_1:
    if (edi == 0xb9) {
        eax = *((ecx + 0xc));
        ebx = edi;
        void (*0x805ac00)() ();
    }
    eax = 1;
    return eax;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bfc0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2596 (void) {
    eax = unix_listen;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059df0 */
#include <stdint.h>
 
int32_t camlMap_cons_enum_1304 (void) {
    do {
        if (eax == 1) {
            goto label_1;
        }
        esi = *((eax + 0xc));
        edx = *((eax + 8));
        ecx = *((eax + 4));
        ebp = *(eax);
label_0:
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        edi = eax + 4;
        *((edi - 4)) = 0x1000;
        *(edi) = ecx;
        *((edi + 4)) = edx;
        *((edi + 8)) = esi;
        *((edi + 0xc)) = ebx;
        eax = ebp;
        ebx = edi;
    } while (1);
label_1:
    eax = ebx;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80593c0 */
#include <stdint.h>
 
int32_t camlMap_iter_1170 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
label_0:
        if (ebx == 1) {
            goto label_1;
        }
        ecx = *((ebx + 0xc));
        ecx = *((ebx + 8));
        ecx = *((ebx + 4));
        ebx = *(ebx);
        camlMap_iter_1170 (ecx, ecx, eax);
    } while (1);
    eax = *(esp);
    ebx = *((esp + 4));
    ecx = *((esp + 8));
    caml_apply2 ();
    eax = *((esp + 8));
    ebx = *((esp + 0xc));
    goto label_0;
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c9f0 */
#include <stdint.h>
 
int32_t camlUnix_recv_1558 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ebx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ebx + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = unix_recv;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.recv";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062f78 */
#include <stdint.h>
 
uint32_t unix_getpeername (int32_t arg_8h) {
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15985;
    *((ebp - 0x7c)) = 0x70;
    eax = ebp - 0x7c;
    *((esp + 8)) = eax;
    eax = ebp - 0x78;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getpeername ();
    if (eax == -1) {
        eax = ebx - 0x257f;
        uerror (eax, 0);
    }
    eax = *((ebp - 0x7c));
    eax = ebp - 0x78;
    alloc_sockaddr (eax, eax, 0xffffffff);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a804 */
#include <stdint.h>
 
void getpeername (void) {
    getpeername ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806512e */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
uint32_t alloc_sockaddr (void * arg_8h, void * arg_10h) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x137ca;
    esi = *((ebp + 8));
    edx = *((ebp + 0x10));
    eax = *(esi);
    if (ax != 2) {
        if (ax != 0xa) {
            if (ax == 1) {
                esi += 2;
                eax = caml_copy_string (esi);
                *((ebp - 0x1c)) = eax;
                esi = *((ebx - 0x18));
                eax = *(esi);
                *((ebp - 0x3c)) = eax;
                eax = ebp - 0x3c;
                *(esi) = eax;
                *((ebp - 0x34)) = 1;
                *((ebp - 0x38)) = 1;
                eax = ebp - 0x1c;
                *((ebp - 0x30)) = eax;
                caml_alloc_small (1, 0);
                edx = *((ebp - 0x1c));
                *(eax) = edx;
                edx = *((ebp - 0x3c));
                *(esi) = edx;
            } else {
                eax = esi + 4;
                eax = alloc_inet_addr (eax);
                *((ebp - 0x1c)) = eax;
                edi = *((ebx - 0x18));
                eax = *(edi);
                *((ebp - 0x3c)) = eax;
                eax = ebp - 0x3c;
                *(edi) = eax;
                *((ebp - 0x34)) = 1;
                *((ebp - 0x38)) = 1;
                eax = ebp - 0x1c;
                *((ebp - 0x30)) = eax;
                caml_alloc_small (2, 1);
                edx = *((ebp - 0x1c));
                *(eax) = edx;
                edx = *((esi + 2));
                dx = rotate_right16 (dx, 8);
                edx = (int32_t) dx;
                edx = edx + edx + 1;
                *((eax + 4)) = edx;
                edx = *((ebp - 0x3c));
                *(edi) = edx;
            } else {
                eax = esi + 8;
            }
            eax = alloc_inet6_addr (eax);
            *((ebp - 0x1c)) = eax;
            edi = *((ebx - 0x18));
            eax = *(edi);
            *((ebp - 0x3c)) = eax;
            eax = ebp - 0x3c;
            *(edi) = eax;
            *((ebp - 0x34)) = 1;
            *((ebp - 0x38)) = 1;
            eax = ebp - 0x1c;
            *((ebp - 0x30)) = eax;
            caml_alloc_small (2, 1);
            edx = *((ebp - 0x1c));
            *(eax) = edx;
            edx = *((esi + 2));
            dx = rotate_right16 (dx, 8);
            edx = (int32_t) dx;
            edx = edx + edx + 1;
            *((eax + 4)) = edx;
            edx = *((ebp - 0x3c));
            *(edi) = edx;
        } else {
        }
        if (edx != -1) {
            close (edx);
        }
        eax = ebx - 0x14c4;
        unix_error (0x61, eax, 0);
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073df7 */
#include <stdint.h>
 
int32_t caml_weak_blit (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    int32_t var_4ch;
    int32_t var_30h;
    int32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    uint32_t var_1ch;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((ebp - 0x28)) = eax;
    esi = eax;
    esi++;
    if (esi != 0) {
        eax = *((ebp + 0x18));
        eax >>= 1;
        *((ebp - 0x1c)) = eax;
        edi = *((ebp + 8));
        edx = eax;
        edx += esi;
        eax = *((edi - 4));
        eax >>= 0xa;
        if (edx <= eax) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.blit");
label_0:
    eax = *((ebp + 0x14));
    eax >>= 1;
    *((ebp - 0x24)) = eax;
    eax++;
    *((ebp - 0x20)) = eax;
    if (eax != 0) {
        eax = *((ebp - 0x1c));
        eax += *((ebp - 0x20));
        ecx = *((ebp + 0x10));
        edx = *((ecx - 4));
        edx >>= 0xa;
        if (eax <= edx) {
            goto label_1;
        }
    }
    caml_invalid_argument ("Weak.blit");
label_1:
    if (*(obj.caml_gc_phase) != 0) {
        goto label_2;
    }
    if (*(obj.caml_gc_subphase) != 0xb) {
        goto label_2;
    }
    if (*((ebp - 0x1c)) == 0) {
        goto label_2;
    }
    edx = 0;
    eax = 0;
    *((ebp - 0x4c)) = esi;
    do {
        edx += *((ebp - 0x4c));
        edx = edi + edx*4;
        ebx = *(edx);
        ecx = caml_weak_none;
        if (ebx != ecx) {
            if ((bl & 1) != 0) {
                goto label_3;
            }
            *((ebp - 0x30)) = ebx;
            esi = ebx;
            esi >>= 0x17;
            ebx >>= 0xc;
            ebx &= 0x7ff;
            esi = *((esi*4 + obj.caml_page_table));
            if ((*((esi + ebx)) & 1) == 0) {
                goto label_3;
            }
            ebx = *((ebp - 0x30));
            if ((*((ebx - 4)) & 0x300) != 0) {
                goto label_3;
            }
            *(edx) = ecx;
        }
label_3:
        eax++;
        edx = eax;
    } while (*((ebp - 0x1c)) > eax);
    esi = *((ebp - 0x4c));
label_2:
    if (esi <= *((ebp - 0x20))) {
        goto label_4;
    }
    if (*((ebp - 0x1c)) == 0) {
        goto label_5;
    }
    edx = 0;
    ebx = 0;
    do {
        eax = edx + esi;
        ecx = *((edi + eax*4));
        edx += *((ebp - 0x20));
        eax = *((ebp + 0x10));
        do_set ();
        ebx++;
        edx = ebx;
    } while (*((ebp - 0x1c)) > ebx);
    goto label_5;
label_4:
    esi = *((ebp - 0x1c));
    esi--;
    *((ebp - 0x20)) = esi;
    if (esi < 0) {
        goto label_5;
    }
    eax = *((ebp - 0x1c));
    eax += *((ebp - 0x28));
    ebx = edi + eax*4;
    esi = *((ebp - 0x1c));
    esi += *((ebp - 0x24));
    edi = *((ebp - 0x20));
    do {
        ecx = *(ebx);
        edx = esi;
        eax = *((ebp + 0x10));
        do_set ();
        ebx -= 4;
        esi--;
        edi--;
    } while (edi >= 0);
label_5:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806be65 */
#include <stdint.h>
 
int32_t caml_int64_shift_right_unsigned (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    __asm ("shrd eax, edx, cl");
    edx >>= cl;
    if ((cl & 0x20) != 0) {
        eax = edx;
        edx = 0;
    }
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050240 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1495 (void) {
    eax = caml_ml_channel_size_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d162 */
#include <stdint.h>
 
int32_t caml_array_unsafe_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    if (*((eax - 4)) == 0xfe) {
        caml_array_unsafe_get_float (eax, edx);
    } else {
        edx >>= 1;
        eax = *((eax + edx*4));
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d780 */
#include <stdint.h>
 
int32_t camlUnix_create_process_env_1914 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = ebx;
    *((esp + 0xc)) = ecx;
    *(esp) = edx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        return eax;
    }
    fcn_0804d7e0 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d7e0 */
#include <stdint.h>
 
int32_t fcn_0804d7e0 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_1ch, int32_t arg_24h) {
    *(obj.caml_exception_pointer) = esp;
    eax = *((esp + 8));
    ebx = *((esp + 0xc));
    ecx = *((esp + 0x10));
    camlUnix_perform_redirections_1900 (*(obj.caml_exception_pointer));
    eax = *((esp + 0x14));
    eax = *((esp + 0x1c));
    eax = *((esp + 0x24));
    eax = unix_execvpe;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e340 */
#include <stdint.h>
 
int32_t camlPrintf_mkprintf_1345 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    eax = caml_extra_params;
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (eax, ecx, edx);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x20f7;
            *(ebx) = sym.caml_curry4;
            *((ebx + 4)) = 9;
            *((ebx + 8)) = 0x805d3e0;
            eax = *(esp);
            *((ebx + 0xc)) = eax;
            eax = *((esp + 4));
            *((ebx + 0x10)) = eax;
            eax = *((esp + 8));
            *((ebx + 0x14)) = eax;
            eax = *((esp + 0xc));
            *((ebx + 0x18)) = eax;
            *((ebx + 0x1c)) = ecx;
            eax = 1;
            eax = camlPrintf_index_of_int_1037 (ebx);
            ebx = eax;
            eax = *((esp + 0x10));
            ecx = *((esp + 0x14));
            caml_apply2 ();
            ebx = *((esp + 0x18));
            void (*0x805dde0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80622ae */
#include <stdint.h>
 
uint32_t unix_set_nonblock (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1664d;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 3;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        ah |= 8;
        *((esp + 8)) = eax;
        *((esp + 4)) = 4;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x25b5;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80519c0 */
#include <stdint.h>
 
int32_t camlArray_isortto_1209 (void) {
    int32_t var_4h_3;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h_2;
    int32_t var_14h_2;
    int32_t var_18h;
    int32_t var_1ch;
    edi = 1;
    edx += 0xfffffffe;
    if (edi > edx) {
        goto label_5;
    }
    *((esp + 0x10)) = edx;
    *((esp + 0xc)) = edi;
    *((esp + 0x18)) = esi;
    *((esp + 0x14)) = ecx;
    *((esp + 0x1c)) = ebx;
    *(esp) = eax;
label_0:
    eax = *(esp);
    eax = eax + edi - 1;
    *((esp + 4)) = eax;
    ecx = *((esp + 0x18));
    ecx = *((ecx + 0x10));
    edx = *((ecx - 4));
    *((esp + 8)) = edx;
    edx = *((esp + 8));
    edx &= 0xff;
    if (edx != 0xfe) {
        edx = *((esp + 8));
        edx >>= 9;
        if (edx <= eax) {
            goto label_6;
        }
        edx = *((ecx + eax*2 - 2));
        *((esp + 4)) = edx;
    } else {
        edx = *((esp + 8));
        edx >>= 0xa;
        if (edx <= eax) {
            goto label_7;
        }
label_4:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_8;
        }
        edx = eax + 4;
        *((edx - 4)) = 0x8fd;
        eax = *((esp + 4));
        *(fp_stack--) = *((ecx + eax*4 - 4));
        *(edx) = fp_stack[0];
        fp_stack--;
        *((esp + 4)) = edx;
    }
label_3:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_9;
    }
    esi = eax + 4;
    *((esp + 8)) = esi;
    *((esi - 4)) = 0x400;
    eax = *((esp + 0x14));
    eax = eax + edi - 3;
    *(esi) = eax;
    do {
        ecx = *(esi);
        eax = *((esp + 0x14));
        if (ecx < eax) {
            goto label_10;
        }
        ecx = *(esi);
        eax = *((ebx - 4));
        edx = *((ebx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_11;
            }
            eax = *((ebx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_12;
            }
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_13;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 0x18));
        ecx = *((ebx + 0xc));
        ebx = *((esp + 4));
        eax = caml_apply2 ();
        if (eax <= 1) {
            goto label_10;
        }
        esi = *((esp + 8));
        ecx = *(esi);
        ebx = *((esp + 0x1c));
        eax = *((ebx - 4));
        edx = *((ebx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_14;
            }
            edx = *((ebx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_15;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_16;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *(esi);
        eax += 2;
        ecx = *((ebx - 4));
        edi = *((ebx - 4));
        edi &= 0xff;
        if (edi != 0xfe) {
            ecx >>= 9;
            if (ecx <= eax) {
                goto label_17;
            }
            eax = caml_modify (ebx + eax*2 - 2, edx);
        } else {
            ecx >>= 0xa;
            if (ecx <= eax) {
                goto label_18;
            }
            *(fp_stack--) = *(edx);
            *((ebx + eax*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        *(esi) += 0xfffffffe;
    } while (1);
label_10:
    eax = *((esp + 8));
    eax = *(eax);
    eax += 2;
    ebx = *((esp + 0x1c));
    ecx = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_19;
        }
        ecx = *((esp + 4));
        eax = caml_modify (ebx + eax*2 - 2, ecx);
    } else {
        ecx >>= 0xa;
        if (ecx <= eax) {
            goto label_20;
        }
        ecx = *((esp + 4));
        *(fp_stack--) = *(ecx);
        *((ebx + eax*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    edi = *((esp + 0xc));
    ecx = *((esp + 0xc));
    edi += 2;
    *((esp + 0xc)) = edi;
    eax = *((esp + 0x10));
    if (ecx != eax) {
        goto label_0;
    }
label_5:
    eax = 1;
    return eax;
label_16:
    caml_call_gc ();
    goto label_1;
label_13:
    caml_call_gc ();
    goto label_2;
label_9:
    caml_call_gc ();
    goto label_3;
label_8:
    caml_call_gc ();
    goto label_4;
label_20:
    caml_ml_array_bound_error ();
label_19:
    caml_ml_array_bound_error ();
label_18:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065b48 */
#include <stdint.h>
 
uint32_t unix_string_of_inet_addr (int32_t arg_8h) {
    int32_t var_48h;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x12db7;
    esi = *((ebp + 8));
    eax = caml_string_length (esi);
    if (eax == 0x10) {
        *((esp + 0xc)) = 0x40;
        eax = ebp - 0x48;
        *((esp + 8)) = eax;
        *((esp + 4)) = esi;
        *(esp) = 0xa;
        inet_ntop ();
    } else {
        *((esp + 0xc)) = 0x40;
        eax = ebp - 0x48;
        *((esp + 8)) = eax;
        *((esp + 4)) = esi;
        *(esp) = 2;
        eax = inet_ntop ();
    }
    if (eax == 0) {
        eax = ebx - 0x235a;
        eax = uerror (eax, 0);
    }
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e175 */
#include <stdint.h>
 
uint32_t caml_ml_input_int (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = caml_getword (ebx);
    edi = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c290 */
#include <stdint.h>
 
int32_t caml_int32_mod (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    ecx = *((eax + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            caml_copy_int32 (0);
        }
    } else {
        eax = edx;
        edx >>= 0x1f;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        caml_copy_int32 (edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c150 */
#include <stdint.h>
 
int32_t camlUnix_fun_2642 (void) {
    eax = unix_getitimer;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b200 */
#include <stdint.h>
 
int32_t caml_curry5_4 (void) {
    esi = eax;
    ecx = *((ebx + 0xc));
    eax = *((ecx + 0xc));
    ebp = *((eax + 0xc));
    edi = *((ebp + 0xc));
    edx = *((ebx + 8));
    ecx = *((ecx + 8));
    ebx = *((eax + 8));
    eax = *((ebp + 8));
    ebp = *((edi + 8));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071daa */
#include <stdint.h>
 
int32_t caml_gc_minor (void) {
    caml_minor_collection ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c3cc */
#include <stdint.h>
 
int32_t caml_neq_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] != fp_stack[1]) ? 1 : 0;
    __asm ("setp dl");
    eax |= edx;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c5e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2772 (void) {
    eax = unix_execve;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ca40 */
#include <stdint.h>
 
int32_t camlUnix_recvfrom_1564 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ebx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ebx + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = unix_recvfrom;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.recvfrom";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bbd4 */
#include <stdint.h>
 
int32_t caml_nativeint_neg (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = -eax;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8053710 */
#include <stdint.h>
 
int32_t camlList_nth_aux_1045 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 4));
        eax = *(eax);
        if (ebx == 1) {
            return eax;
        }
        ebx += 0xfffffffe;
        eax = ecx;
    } while (1);
label_0:
    eax = loc.camlList__53;
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f8c0 */
#include <stdint.h>
 
int32_t camlPervasives_failwith_1010 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Failure;
            *((eax + 4)) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062da8 */
#include <stdint.h>
 
void unix_gethostname (void) {
    int32_t var_48h;
    int32_t var_9h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15b53;
    *((esp + 4)) = 0x40;
    esi = ebp - 0x48;
    *(esp) = esi;
    gethostname ();
    *((ebp - 9)) = 0;
    caml_copy_string (esi);
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a5f4 */
#include <stdint.h>
 
void gethostname (void) {
    gethostname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067c10 */
#include <stdint.h>
 
int32_t caml_record_signal (int32_t arg_8h) {
    eax = *((ebp + 8));
    *((eax*4 + obj.caml_pending_signals)) = 1;
    *(obj.caml_signals_are_pending) = 1;
    eax = caml_young_end;
    *(obj.caml_young_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8057690 */
#include <stdint.h>
 
int32_t camlHashtbl_create_1051 (void) {
    ebx = eax;
    eax = 3;
    camlPervasives_max_1025 ();
    ebx = .comment;
    eax = camlPervasives_min_1022 ();
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = 1;
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f980 */
#include <stdint.h>
 
int32_t camlPervasives_max_1025 (void) {
    int32_t var_4h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_greaterequal;
    eax = caml_c_call (eax);
    if (eax != 1) {
        eax = *((esp + 4));
        return eax;
    }
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f940 */
#include <stdint.h>
 
int32_t camlPervasives_min_1022 (void) {
    int32_t var_4h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_lessequal;
    eax = caml_c_call (eax);
    if (eax != 1) {
        eax = *((esp + 4));
        return eax;
    }
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b986 */
#include <stdint.h>
 
int32_t caml_int32_float_of_bits (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c950 */
#include <stdint.h>
 
int32_t camlUnix_pause_1408 (void) {
    eax = unix_sigprocmask;
    eax = caml_c_call (3);
    eax = unix_sigsuspend;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cfd7 */
#include <stdint.h>
 
int32_t caml_create_string (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    if (eax > 0xfffffb) {
        eax = caml_invalid_argument ("String.create");
    }
    caml_alloc_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066ff1 */
#include <stdint.h>
 
int32_t caml_invalid_argument (void) {
    int32_t var_4h_5;
    int32_t var_4h_4;
    eax = *((ebp + 8));
    return caml_raise_with_string (loc.caml_exn_Invalid_argument, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071372 */
#include <stdint.h>
 
uint32_t caml_sys_io_error (int32_t arg_8h) {
    eax = errno_location ();
    if (*(eax) == 0xb) {
        caml_raise_sys_blocked_io ();
    }
    eax = *((ebp + 8));
    return caml_sys_error (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067095 */
#include <stdint.h>
 
void caml_raise_sys_blocked_io (void) {
    return caml_raise_constant (loc.caml_exn_Sys_blocked_io);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e4a0 */
#include <stdint.h>
 
int32_t camlPrintf_eprintf_1395 (void) {
    eax = .comment;
    eax = camlPrintf_fprintf_1391 (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c722 */
#include <stdint.h>
 
int32_t caml_acos_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    acos (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a364 */
#include <stdint.h>
 
void acos (void) {
    acos ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c790 */
#include <stdint.h>
 
int32_t camlUnix_read_1237 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = unix_read;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.read";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80632c0 */
#include <stdint.h>
 
uint32_t unix_gettimeofday (void) {
    int32_t var_10h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15640;
    *((esp + 4)) = 0;
    eax = ebp - 0x10;
    *(esp) = eax;
    eax = gettimeofday ();
    if (eax == -1) {
        eax = ebx - 0x2573;
        uerror (eax, 0);
    }
    *(fp_stack--) = *((ebp - 0x10));
    *(fp_stack--) = *((ebp - 0xc));
    fp_stack[0] /= *((ebx - 0x2564));
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a164 */
#include <stdint.h>
 
void gettimeofday (void) {
    gettimeofday ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b130 */
#include <stdint.h>
 
int32_t camlBuffer_entry (void) {
    eax = loc.camlBuffer__20;
    *(loc.camlBuffer) = eax;
    eax = loc.camlBuffer__19;
    *(0x808062c) = eax;
    eax = loc.camlBuffer__18;
    *(0x8080630) = eax;
    eax = loc.camlBuffer__17;
    *(0x8080634) = eax;
    eax = loc.camlBuffer__16;
    *(0x8080638) = eax;
    eax = loc.camlBuffer__15;
    *(0x808063c) = eax;
    eax = loc.camlBuffer__14;
    *(0x8080640) = eax;
    eax = loc.camlBuffer__13;
    *(0x8080644) = eax;
    eax = loc.camlBuffer__12;
    *(0x8080664) = eax;
    eax = loc.camlBuffer__11;
    *(0x8080648) = eax;
    eax = loc.camlBuffer__10;
    *(0x8080650) = eax;
    eax = loc.camlBuffer__9;
    *(0x808064c) = eax;
    eax = loc.camlBuffer__8;
    *(0x8080658) = eax;
    eax = loc.camlBuffer__7;
    *(0x808065c) = eax;
    eax = loc.camlBuffer__6;
    *(0x8080660) = eax;
    eax = loc.camlBuffer__5;
    *(0x8080668) = eax;
    eax = loc.camlBuffer__4;
    *(0x808066c) = eax;
    eax = loc.camlBuffer__3;
    *(0x8080670) = eax;
    eax = loc.camlBuffer__2;
    *(0x8080674) = eax;
    eax = camlBuffer__1;
    *(0x8080654) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f590 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_new_method_1185 (void) {
    ebx = *((eax + 4));
    ebx = *((ebx - 4));
    ebx >>= 9;
    ebx |= 1;
    ebx += 2;
    camlCamlinternalOO_resize_1173 (ebx);
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f4c0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_resize_1173 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = *((eax + 4));
    ecx = *((ecx - 4));
    ecx >>= 9;
    ecx |= 1;
    if (ebx > ecx) {
        *(esp) = ecx;
        *((esp + 8)) = eax;
        eax = caml_make_vect;
        eax = caml_c_call (ebx);
        ecx = eax;
        edx = 1;
        ebx = 1;
        eax = *((esp + 8));
        eax = *((eax + 4));
        esi = *(esp);
        camlArray_blit_1093 (ecx);
        eax = *((esp + 4));
        eax = *((esp + 0xc));
        eax += 4;
        caml_modify (eax, eax);
        eax = 1;
        return eax;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052520 */
#include <stdint.h>
 
int32_t camlArray_blit_1093 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edi = eax;
    *((esp + 8)) = ecx;
    if (esi < 1) {
        goto label_2;
    }
    if (ebx < 1) {
        goto label_2;
    }
    ecx = *((edi - 4));
    eax = *((edi - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = ecx;
        eax >>= 9;
    } else {
        eax = ecx;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= esi;
    eax++;
    if (ebx > eax) {
        goto label_2;
    }
    if (ebp < 1) {
        goto label_2;
    }
    eax = *((esp + 8));
    ecx = *((eax - 4));
    eax = *((eax - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = ecx;
        eax >>= 9;
    } else {
        eax = ecx;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= esi;
    eax++;
    if (ebp > eax) {
        goto label_2;
    }
    if (ebx >= ebp) {
        goto label_3;
    }
    esi += 0xfffffffe;
    if (esi < 1) {
        goto label_4;
    }
    *((esp + 4)) = ebx;
    do {
        eax = *((esp + 4));
        ebx = eax + esi - 1;
        eax = *((edi - 4));
        if (eax != 0xfe) {
            ebx = *((edi + ebx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edi + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            ebx = eax;
        }
        eax = ebp;
        eax = eax + esi - 1;
        ecx = *((esp + 8));
        ecx = *((ecx - 4));
        if (ecx != 0xfe) {
            ebx = *((esp + 0xc));
            caml_modify (ebx + eax*2 - 2, ebx);
        } else {
            *(fp_stack--) = *(ebx);
            ebx = *((esp + 8));
            *((ebx + eax*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ebx = esi;
        eax = esi;
        eax -= 2;
        esi = eax;
    } while (ebx != 1);
label_4:
    eax = 1;
    return eax;
label_3:
    eax = 1;
    *((esp + 0xc)) = eax;
    esi += 0xfffffffe;
    if (*((esp + 0xc)) > esi) {
        goto label_6;
    }
    *((esp + 4)) = ebx;
    *(esp) = edi;
    do {
        ebx = *((esp + 4));
        eax = *((esp + 0xc));
        ebx = ebx + eax - 1;
        eax = *(esp);
        ecx = *((eax - 4));
        if (ecx != 0xfe) {
            ebx = *((eax + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_7;
            }
            ecx = eax + 4;
            *((ecx - 4)) = 0x8fd;
            eax = *(esp);
            *(fp_stack--) = *((eax + ebx*4 - 4));
            *(ecx) = fp_stack[0];
            fp_stack--;
            ebx = ecx;
        }
        ecx = *((esp + 0xc));
        eax = ebp;
        eax = eax + ecx - 1;
        ecx = *((esp + 8));
        ecx = *((ecx - 4));
        if (ecx != 0xfe) {
            ebx = *((esp + 0xc));
            caml_modify (ebx + eax*2 - 2, ebx);
        } else {
            *(fp_stack--) = *(ebx);
            ebx = *((esp + 8));
            *((ebx + eax*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 0xc));
        eax = *((esp + 0xc));
        eax += 2;
        *((esp + 0xc)) = eax;
    } while (ebx != esi);
label_6:
    eax = 1;
    return eax;
label_2:
    eax = "Array.blit";
    void (*0x804f900)() ();
label_7:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c32d */
#include <stdint.h>
 
int32_t caml_int32_sub (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = *((ebp + 0xc));
    eax -= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ef90 */
#include <stdint.h>
 
void camlCamlinternalOO_fun_1834 (void) {
    edx = *((ebx + 8));
    ecx = *(eax);
    ecx = *((ecx + edx*2 - 2));
    ebx = *((ebx + 0xc));
    ebx = *((eax + ebx*2 - 2));
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c4c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2742 (void) {
    eax = unix_lseek;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d41b */
#include <stdint.h>
 
int32_t caml_array_unsafe_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((ebp + 0x10));
    if (*((eax - 4)) == 0xfe) {
        eax = caml_array_unsafe_set_float (eax, edx, ecx);
    } else {
        caml_array_unsafe_set_addr (eax, edx, ecx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c180 */
#include <stdint.h>
 
int32_t camlUnix_fun_2646 (void) {
    eax = unix_times;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064791 */
#include <stdint.h>
 
int32_t unix_sendto (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1416f;
    eax = *((ebp + 8));
    edx = *((eax + 0x14));
    edx = *((eax + 0x10));
    edx = *((eax + 0xc));
    edx = *((eax + 8));
    edx = *((eax + 4));
    eax = *(eax);
    unix_sendto_native (edx, edx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80646a0 */
#include <stdint.h>
 
uint32_t unix_sendto_native (int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, int32_t arg_sp_10h, int32_t arg_sp_14h) {
    int32_t var_40a0h;
    int32_t var_409ch;
    int32_t var_408ch;
    int32_t var_4088h;
    void * s1;
    void * s2;
    size_t n;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x1425b;
    eax = ebx + 0xb904;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x40a0)) = eax;
    eax = ebp - 0x408c;
    esi = ebp - 0x4088;
    eax = *((ebp + 0x1c));
    get_sockaddr (eax, esi, eax);
    edi = *((ebp + 0x14));
    edi >>= 1;
    eax = 0x4000;
    if (edi > 0x4000) {
        edi = eax;
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    eax = ebp - 0x4018;
    *((ebp - 0x409c)) = eax;
    memmove (eax, eax, edi);
    caml_enter_blocking_section ();
    eax = *((ebp - 0x408c));
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = esi;
    eax = *((ebp - 0x40a0));
    *((esp + 0xc)) = eax;
    *((esp + 8)) = edi;
    eax = *((ebp - 0x409c));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = sendto ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x248d;
        uerror (eax, 0);
    }
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a014 */
#include <stdint.h>
 
void sendto (void) {
    sendto ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8057740 */
#include <stdint.h>
 
int32_t camlHashtbl_copy_1057 (void) {
    eax = *((eax + 4));
    eax = camlArray_copy_1049 (eax);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *(esp);
            ebx = *(ebx);
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cd54 */
#include <stdint.h>
 
int32_t caml_string_notequal (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_equal (eax, eax);
    edx = 4;
    edx -= eax;
    eax = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805aaa0 */
#include <stdint.h>
 
int32_t camlBuffer_length_1060 (void) {
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80545b0 */
#include <stdint.h>
 
int32_t camlList_hd_1036 (void) {
    if (eax != 1) {
        eax = *(eax);
        return eax;
    }
    eax = loc.camlList__51;
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062a00 */
#include <stdint.h>
 
int32_t unix_getgrgid (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15f00;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getgrgid ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_group_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a644 */
#include <stdint.h>
 
void getgrgid (void) {
    getgrgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8074c39 */
#include <stdint.h>
 
int32_t caml_final_do_weak_roots (int32_t arg_8h) {
    int32_t var_4h;
    edi = *((ebp + 8));
    if (*(obj.old) == 0) {
        goto label_0;
    }
    ebx = 0;
    esi = 0;
    do {
        eax = ebx;
        eax += *(obj.final_table);
        edx = eax + 4;
        eax = *((eax + 4));
        void (*edi)(uint32_t, uint32_t) (eax, edx);
        esi++;
        ebx += 0xc;
    } while (*(obj.old) > esi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80537b0 */
#include <stdint.h>
 
int32_t camlList_rmap2_f_1103 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (ebx == 1) {
            goto label_1;
        }
        if (ecx == 1) {
            goto label_2;
        }
        eax = *((ecx + 4));
        esi = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *((edx + 0xc));
        ebx = esi;
        eax = caml_apply2 (edx, eax, eax);
        ebx = eax;
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        ebx = *(esp);
        *((eax + 4)) = ebx;
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        edx = *((esp + 0xc));
    } while (1);
label_1:
    if (ecx == 1) {
        return eax;
    }
label_2:
    eax = "List.rev_map2";
    void (*0x804f900)() ();
label_3:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c4f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2746 (void) {
    eax = caml_channel_descriptor;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063e00 */
#include <stdint.h>
 
int32_t unix_mkfifo (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14afb;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = mkfifo ();
    if (eax == -1) {
        eax = ebx - 0x24e6;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a4a4 */
#include <stdint.h>
 
void mkfifo (void) {
    mkfifo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061e14 */
#include <stdint.h>
 
int32_t unix_dup (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16aec;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = dup ();
    if (eax == -1) {
        eax = ebx - 0x2615;
        uerror (eax, 0);
    }
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a334 */
#include <stdint.h>
 
void dup (void) {
    dup ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80670e0 */
#include <stdint.h>
 
int32_t caml_do_local_roots (void) {
    int32_t var_24h_4;
    int32_t var_20h_4;
    uint32_t var_1ch_4;
    int32_t var_8h_2;
    int32_t var_ch_4;
    int32_t var_10h_2;
    int32_t var_14h;
    uint32_t var_18h_2;
    int32_t var_4h_8;
    eax = *((ebp + 0xc));
    if (eax != 0) {
        edx = *((ebp + 0x14));
        *((ebp - 0x20)) = edx;
        edx = *((ebp + 0x10));
        *((ebp - 0x1c)) = eax;
    } else {
label_1:
        if (*((ebp + 0x18)) == 0) {
            goto label_6;
        }
        esi = *((ebp + 0x18));
        *((ebp - 0x1c)) = 0;
        goto label_7;
    }
label_0:
    esi = caml_frame_descriptors_mask;
    eax = edx;
    eax >>= 3;
    eax &= esi;
    ecx = caml_frame_descriptors;
    ebx = *((ecx + eax*4));
    if (*(ebx) == edx) {
        goto label_8;
    }
    do {
        eax++;
        eax &= esi;
        ebx = *((ecx + eax*4));
    } while (*(ebx) != edx);
label_8:
    if (*((ebx + 4)) == 0xffff) {
        goto label_9;
    }
    esi = *((ebx + 6));
    if (esi <= 0) {
        goto label_10;
    }
    edi = ebx + 8;
    *((ebp - 0x24)) = ebx;
    ebx = *((ebp + 8));
    do {
        eax = *(edi);
        if ((al & 1) != 0) {
            eax >>= 1;
            edx = *((ebp - 0x20));
            eax = edx + eax*4;
        } else {
            eax += *((ebp - 0x1c));
        }
        eax = *(eax);
        void (*ebx)(uint32_t, uint32_t) (eax, eax);
        esi--;
        if (esi <= 0) {
            goto label_11;
        }
        edi += 2;
    } while (1);
label_11:
    ebx = *((ebp - 0x24));
label_10:
    eax = *((ebx + 4));
    eax &= 0xfffc;
    *((ebp - 0x1c)) += eax;
    eax = *((ebp - 0x1c));
    edx = *((eax - 4));
    goto label_0;
label_9:
    eax = *((ebp - 0x1c));
    eax += 8;
    edx = *(eax);
    *((ebp - 0x1c)) = edx;
    edx = *((eax + 4));
    eax = *((eax + 8));
    *((ebp - 0x20)) = eax;
    if (*((ebp - 0x1c)) != 0) {
        goto label_0;
    }
    goto label_1;
    do {
label_2:
        eax = ebx*4;
        eax += *((esi + edi*4 + 0xc));
        eax = *(eax);
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        ebx++;
    } while (*((esi + 8)) > ebx);
label_3:
    edi++;
    if (*((esi + 4)) <= edi) {
        goto label_5;
    }
label_4:
    ebx = *((ebp - 0x1c));
    if (*((esi + 8)) > 0) {
        goto label_2;
    }
    goto label_3;
label_5:
    esi = *(esi);
    if (esi == 0) {
        goto label_6;
    }
label_7:
    edi = 0;
    if (*((esi + 4)) > 0) {
        goto label_4;
    }
    goto label_5;
label_6:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cb5b */
#include <stdint.h>
 
uint32_t caml_float_of_string (int32_t arg_8h) {
    int32_t var_8h_2;
    uint32_t var_5ch_2;
    int32_t var_58h_2;
    char * * endptr;
    int32_t var_58h;
    esi = *((ebp + 8));
    eax = caml_string_length (ebx, esi, edi);
    ebx = eax;
    edi = ebp - 0x58;
    if (eax > 0x3f) {
        eax = eax + 1;
        eax = caml_stat_alloc (eax);
        edi = eax;
    }
    eax = esi;
    esi = edi;
    while (ebx != 0) {
        edx = *(eax);
        if (dl != 0x5f) {
            *(esi) = dl;
            esi++;
        }
        eax++;
        ebx--;
    }
    *(esi) = 0;
    if (esi != edi) {
        eax = ebp - 0x5c;
        strtod (edi, eax);
        *((ebp - 0x70)) = fp_stack[0];
        fp_stack--;
        if (*((ebp - 0x5c)) != esi) {
            goto label_0;
        }
        eax = ebp - 0x58;
        if (edi != eax) {
            caml_stat_free (edi);
        }
        *(fp_stack--) = *((ebp - 0x70));
        *(esp) = fp_stack[0];
        fp_stack--;
        caml_copy_double ();
        return eax;
    }
label_0:
    eax = ebp - 0x58;
    if (edi != eax) {
        caml_stat_free (edi);
    }
    return caml_failwith ("float_of_string");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056510 */
#include <stdint.h>
 
int32_t camlSys_catch_break_1082 (void) {
    while (1) {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x400;
            *(ebx) = loc.camlSys__5;
            eax = 0xfffffff5;
            void (*0x80564f0)() ();
            ebx = 1;
            eax = 0xfffffff5;
            void (*0x80564f0)() ();
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805eab0 */
#include <stdint.h>
 
uint32_t camlCamlinternalOO_fun_1712 (void) {
    int32_t var_4h;
    edx = .comment;
    edx = *((edx + 0xc));
    ecx = *((ecx + 0xc));
    ecx = *(ecx);
    eax = camlMap_add_1108 (ebx, ecx);
    ebx = *((esp + 8));
    caml_modify (*((ebx + 0xc)), eax);
    eax = .comment;
    edx = *((eax + 0xc));
    eax = *((ebx + 0x10));
    ecx = *(eax);
    ebx = 1;
    eax = *(esp);
    eax = camlMap_add_1108 ();
    eax = *((esp + 8));
    caml_modify (*((eax + 0x10)), eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058ec0 */
#include <stdint.h>
 
int32_t camlMap_add_1108 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_4h;
    int32_t var_8h;
    do {
label_0:
        esi = eax;
        if (ecx == 1) {
            goto label_2;
        }
        eax = *((ecx + 0x10));
        eax = *((ecx + 0xc));
        eax = *((ecx + 8));
        ebx = *((ecx + 4));
        eax = *(ecx);
        eax = *((edx + 0xc));
        ecx = *(eax);
        eax = *((esp + 0x10));
        eax = caml_apply2 (edx, ebx, eax);
        if (eax == 1) {
label_1:
            eax = caml_young_ptr;
            eax -= 0x18;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x1400;
            ebx = *((esp + 0xc));
            *(eax) = ebx;
            ebx = *((esp + 0x10));
            *((eax + 4)) = ebx;
            ebx = *((esp + 0x14));
            *((eax + 8)) = ebx;
            ebx = *((esp + 0x18));
            *((eax + 0xc)) = ebx;
            ebx = *((esp + 0x1c));
            *((eax + 0x10)) = ebx;
            return eax;
        }
        if (eax >= 1) {
            goto label_4;
        }
        eax = *((esp + 0x10));
        ebx = *((esp + 0x14));
        ecx = *((esp + 0xc));
        edx = *(esp);
        camlMap_add_1108 ();
    } while (1);
    ebx = *((esp + 4));
    ecx = *((esp + 8));
    edx = *((esp + 0x18));
    void (*0x8058c00)() ();
label_4:
    eax = *((esp + 0x10));
    ebx = *((esp + 0x14));
    ecx = *((esp + 0x18));
    edx = *(esp);
    eax = camlMap_add_1108 ();
    goto label_0;
    edx = eax;
    eax = *((esp + 0xc));
    ebx = *((esp + 4));
    ecx = *((esp + 8));
    void (*0x8058c00)() ();
    do {
label_2:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1400;
            *(eax) = 1;
            *((eax + 4)) = esi;
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = 1;
            *((eax + 0x10)) = 3;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f580 */
#include <stdint.h>
 
int32_t camlPervasives_scan_1249 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
        *((esp + 0x10)) = eax;
        *((esp + 0xc)) = ebx;
        *((esp + 4)) = ecx;
        eax = caml_ml_input_scan_line;
        eax = caml_c_call (*((ecx + 0xc)));
        if (eax == 1) {
            eax = *((esp + 0x10));
            if (eax != 1) {
                *((esp + 0x10)) = eax;
                eax = *((esp + 0xc));
                eax = caml_create_string;
                caml_c_call (eax);
                ebx = *((esp + 0xc));
                ecx = *((esp + 0x10));
                void (*0x804f530)() ();
            }
label_2:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_End_of_file;
            eax = caml_raise_exn ();
        }
        *((esp + 8)) = eax;
        if (eax > 1) {
            eax += 0xfffffffe;
            eax = caml_create_string;
            eax = caml_c_call (eax);
            *(esp) = eax;
            ebx = *((esp + 8));
            ebx += 0xfffffffe;
            eax = *((esp + 0x10));
            eax = caml_ml_input;
            caml_c_call (*((eax + 0xc)));
            eax = *((esp + 4));
            eax = caml_ml_input_char;
            caml_c_call (*((eax + 0xc)));
            ecx = *((esp + 0x10));
            if (ecx != 1) {
                ebx = *((esp + 8));
                eax = *((esp + 0xc));
                edx = eax + ebx - 3;
                *((esp + 4)) = edx;
label_1:
                eax = caml_young_ptr;
                eax -= 0xc;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_4;
                }
                ebx = eax + 4;
                *((esp + 8)) = ebx;
                *((ebx - 4)) = 0x800;
                eax = *(esp);
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = caml_create_string;
                caml_c_call (edx);
                ebx = *((esp + 4));
                ecx = *((esp + 8));
                void (*0x804f530)() ();
            }
            eax = *(esp);
            return eax;
        }
        ebx = 2;
        ebx -= eax;
        eax = caml_create_string;
        eax = caml_c_call (ebx);
        *(esp) = eax;
        ecx = 2;
        ebx = *((esp + 8));
        ecx -= ebx;
        eax = *((esp + 0x10));
        eax = caml_ml_input;
        caml_c_call (*((eax + 0xc)));
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        ebx = *((esp + 0x10));
        *((eax + 4)) = ebx;
        ebx = *((esp + 0xc));
        ecx = *((esp + 8));
        ebx -= ecx;
        ebx++;
        ecx = *((esp + 4));
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061f60 */
#include <stdint.h>
 
int32_t unix_execve (void) {
    int32_t var_ch_2;
    int32_t var_8h_2;
    int32_t var_4h_2;
    int32_t var_ch_3;
    int32_t var_10h;
    int32_t var_sp_8h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16998;
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    esi = eax;
    eax = *((ebp + 0x10));
    eax = cstringvect (eax);
    edi = eax;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    eax = *((ebp + 8));
    *(esp) = eax;
    execve ();
    caml_stat_free (esi);
    caml_stat_free (edi);
    eax = *((ebp + 8));
    eax = ebx - 0x2606;
    return uerror (eax, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069e84 */
#include <stdint.h>
 
int32_t caml_allocation_color (int32_t arg_8h) {
    eax = caml_gc_phase;
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
        eax = *((ebp + 8));
        if (eax < *(obj.caml_gc_sweep_hp)) {
            goto label_0;
        }
    }
    eax = 0x300;
    goto label_1;
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e540 */
#include <stdint.h>
 
uint32_t camlPrintf_get_buff_1402 (void) {
    ecx = eax;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax*4 + 1;
    return camlBuffer_create_1039 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c081 */
#include <stdint.h>
 
int32_t caml_int64_sub (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    ebx = *((eax + 8));
    edx = *((ebp + 0xc));
    esi = ecx;
    edi = ebx;
    esi -= *((edx + 4));
    edi -= *((edx + 8));
    caml_copy_int64 (esi, edi);
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e130 */
#include <stdint.h>
 
int32_t camlPrintf_next_index_1262 (void) {
    if (eax != 1) {
        eax = ebx;
        return eax;
    }
    edx = *((ecx + 8));
    ecx = *(edx);
    eax = ebx;
    ebx = edx;
    return void (*0x8080cd8)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bea0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2562 (void) {
    eax = unix_setsid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071cfb */
#include <stdint.h>
 
int32_t caml_gc_full_major (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (1, "Full major GC cycle requested\n", 0);
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    caml_final_do_calls ();
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    test_and_compact ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059010 */
#include <stdint.h>
 
uint32_t camlMap_find_1117 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 0xc));
        edx = *((ebx + 8));
        edx = *((ebx + 4));
        ebx = *(ebx);
        ebx = *((ecx + 0xc));
        ecx = *(ebx);
        ebx = edx;
        eax = caml_apply2 (eax, ecx, edx);
        if (eax == 1) {
            eax = *((esp + 0x10));
            return eax;
        }
        if (eax < 1) {
            ebx = *((esp + 0xc));
        } else {
            ebx = *((esp + 8));
        }
        eax = *(esp);
        ecx = *((esp + 4));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f530 */
#include <stdint.h>
 
int32_t camlPervasives_build_result_1243 (void) {
    do {
        edi = eax;
        if (ecx == 1) {
            goto label_0;
        }
        ebp = *((ecx + 4));
        eax = *(ecx);
        ecx = *((eax - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edx = *((eax + ecx));
        ecx -= edx;
        ecx = ebx;
        ecx -= esi;
        ecx++;
        caml_blit_string (eax, 1, edi, ecx, ecx + ecx + 1);
        ebx -= esi;
        ebx++;
        eax = edi;
        ecx = ebp;
    } while (1);
label_0:
    eax = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80760a0 */
#include <stdint.h>
 
int32_t udivdi3 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_18h;
    uint32_t var_14h;
    uint32_t var_10h;
    uint32_t var_ch;
    eax = *((ebp + 0x14));
    edx = *((ebp + 8));
    esi = *((ebp + 0x10));
    edi = *((ebp + 0xc));
    *((ebp - 0x10)) = edx;
    if (eax == 0) {
        if (esi > edi) {
            goto label_1;
        }
        if (esi == 0) {
            eax = 1;
            edx = 0;
            eax = edx:eax / esi;
            edx = edx:eax % esi;
            esi = eax;
        }
        ecx = *((ebp - 0x10));
        edx = 0;
        eax = edi;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        edi = eax;
        eax = ecx;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
        edx = edi;
        eax = ecx;
        return eax;
    }
    if (eax <= edi) {
        __asm ("bsr edx, eax");
        edx ^= 0x1f;
        *((ebp - 0xc)) = edx;
        if (eax != edi) {
            goto label_2;
        }
        if (esi <= *((ebp - 0x10))) {
            goto label_3;
        }
        if (eax < edi) {
            goto label_3;
        }
    }
    edi = 0;
    ecx = 0;
    do {
label_0:
        eax = ecx;
        edx = edi;
        return eax;
label_1:
        ecx = edx;
        edx = edi;
        eax = ecx;
        edi = 0;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
        edx = edi;
        eax = ecx;
        return eax;
label_2:
        ecx = *((ebp - 0xc));
        edx = esi;
        eax <<= cl;
        *((ebp - 0x14)) = eax;
        eax = 0x20;
        eax -= *((ebp - 0xc));
        ecx = eax;
        edx >>= cl;
        ecx = *((ebp - 0xc));
        edx |= *((ebp - 0x14));
        esi <<= cl;
        ecx = eax;
        *((ebp - 0x18)) = esi;
        esi = edi;
        esi >>= cl;
        ecx = *((ebp - 0xc));
        *((ebp - 0x14)) = edx;
        edx = *((ebp - 0x10));
        edi <<= cl;
        ecx = eax;
        edx >>= cl;
        edi |= edx;
        edx = esi;
        eax = edi;
        eax = *(edx:eax) / ebp - 0x14;
        edx = *(edx:eax) % ebp - 0x14;
        esi = edx;
        edi = eax;
        edx:eax = eax * *((ebp - 0x18));
        *((ebp - 0x14)) = edx;
        if (esi < edx) {
            goto label_4;
        }
        edx = *((ebp - 0x10));
        ecx = *((ebp - 0xc));
        edx <<= cl;
        if (edx < eax) {
            if (esi == *((ebp - 0x14))) {
                goto label_4;
            }
        }
        ecx = edi;
        edi = 0;
    } while (1);
label_3:
    edi = 0;
    ecx = 1;
    goto label_0;
label_4:
    ecx = edi - 1;
    edi = 0;
    eax = ecx;
    edx = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058680 */
#include <stdint.h>
 
uint32_t camlObj_unmarshal_1054 (void) {
    int32_t var_4h;
    eax = camlMarshal_data_size_1048 (ebx, eax);
    ecx = eax;
    ebx = *(esp);
    eax = *(esp);
    eax += ecx;
    eax += 0x27;
    eax = *((esp + 4));
    eax = camlMarshal_from_string_1054 (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *(esp);
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80584a0 */
#include <stdint.h>
 
int32_t camlMarshal_data_size_1048 (void) {
    if (ebx >= 1) {
        ecx = *((eax - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edx = *((eax + ecx));
        ecx -= edx;
        ecx = ecx + ecx - 0x27;
        if (ebx > ecx) {
            goto label_0;
        }
        eax = caml_marshal_data_size;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Marshal.data_size";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80584f0 */
#include <stdint.h>
 
int32_t camlMarshal_from_string_1054 (void) {
    int32_t var_4h;
    if (ebx >= 1) {
        ecx = *((eax - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edx = *((eax + ecx));
        ecx -= edx;
        ecx = ecx + ecx - 0x27;
        if (ebx > ecx) {
            goto label_0;
        }
        *((esp + 4)) = ebx;
        *(esp) = eax;
        eax = caml_marshal_data_size;
        eax = caml_c_call (eax);
        ebx = *(esp);
        ecx = *((ebx - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edx = *((ebx + ecx));
        ecx -= edx;
        ecx <<= 1;
        ecx -= eax;
        ecx += 0xffffffda;
        eax = *((esp + 4));
        if (eax > ecx) {
            eax = "Marshal.from_string";
            void (*0x804f900)() ();
        }
        eax = caml_input_value_from_string;
        caml_c_call (ebx);
        return eax;
    }
label_0:
    eax = "Marshal.from_size";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80697bc */
#include <stdint.h>
 
uint32_t caml_oldify_one (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_24h;
    uint32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
label_0:
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    do {
label_1:
        if ((bl & 1) != 0) {
            goto label_2;
        }
        if (ebx >= *(obj.caml_young_end)) {
            goto label_2;
        }
        if (ebx <= *(obj.caml_young_start)) {
            goto label_2;
        }
        esi = ebx;
        eax = ebx - 4;
        *((ebp - 0x1c)) = eax;
        edx = *(eax);
        if (edx == 0) {
            eax = *(ebx);
            *(edi) = eax;
            goto label_3;
        }
        eax = (int32_t) dl;
        if (eax > 0xf8) {
            goto label_4;
        }
        esi = edx;
        esi >>= 0xa;
        eax = caml_alloc_shr (esi, eax);
        *(edi) = eax;
        edx = *(ebx);
        ecx = *((ebp - 0x1c));
        *(ecx) = 0;
        *(ebx) = eax;
        if (esi > 1) {
            *(eax) = edx;
            edx = oldify_todo_list;
            *((eax + 4)) = edx;
            *(obj.oldify_todo_list) = ebx;
            goto label_3;
        }
        edi = eax;
        ebx = edx;
    } while (1);
label_4:
    if (eax <= 0xfa) {
        goto label_5;
    }
    edx >>= 0xa;
    *((ebp - 0x20)) = edx;
    eax = caml_alloc_shr (edx, eax);
    if (*((ebp - 0x20)) == 0) {
        goto label_6;
    }
    edx = 0;
    *((ebp - 0x24)) = ebx;
    ebx = *((ebp - 0x20));
    do {
        ecx = *((esi + edx*4));
        *((eax + edx*4)) = ecx;
        edx++;
    } while (ebx > edx);
    ebx = *((ebp - 0x24));
label_6:
    edx = *((ebp - 0x1c));
    *(edx) = 0;
    *(ebx) = eax;
    *(edi) = eax;
    goto label_3;
label_5:
    if (eax == 0xf9) {
        edx >>= 0xa;
        ebx = edx*4;
        esi -= ebx;
        caml_oldify_one (esi, edi);
        goto label_0;
        *(edi) += ebx;
        goto label_3;
    }
    esi = ebx;
    ebx = *(ebx);
    if ((bl & 1) != 0) {
        goto label_1;
    }
    ecx = ebx;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 7) == 0) {
        goto label_7;
    }
    ecx -= 4;
    eax = ecx;
    if (*(ecx) == 0) {
        eax = *(ebx);
        eax -= 4;
    }
    eax = *(eax);
    if (eax == 0xfa) {
        goto label_7;
    }
    if (eax == 0xf6) {
        goto label_7;
    }
    if (eax != 0xfd) {
        goto label_1;
    }
label_7:
    eax = caml_alloc_shr (1, 0xfa);
    *(edi) = eax;
    ecx = *((ebp - 0x1c));
    *(ecx) = 0;
    *(esi) = eax;
    edi = eax;
    goto label_1;
label_2:
    *(edi) = ebx;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052230 */
#include <stdint.h>
 
int32_t camlArray_concat_aux_1062 (void) {
    int32_t var_4h;
    eax = loc.camlArray__30;
    eax = 1;
    eax = camlArray_size_1065 (eax, ebx);
    ebx = *(esp);
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    *(esp) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8050a90;
            *((ecx + 0xc)) = ebx;
            eax = 1;
            ebx = *((esp + 4));
            camlArray_fill_1070 ();
            eax = *(esp);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80732d6 */
#include <stdint.h>
 
int32_t caml_obj_tag (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = 0x7d1;
    if ((dl & 1) == 0) {
        al = 0xd5;
        if ((dl & 3) != 0) {
            goto label_0;
        }
        eax = edx;
        eax >>= 0x17;
        ecx = edx;
        ecx >>= 0xc;
        ecx &= 0x7ff;
        ebx = *((eax*4 + obj.caml_page_table));
        eax = 0x7d3;
        if ((*((ebx + ecx)) & 7) == 0) {
            goto label_0;
        }
        eax = *((edx - 4));
        eax = eax + eax + 1;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e2ff */
#include <stdint.h>
 
int32_t caml_ml_output (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_4h;
    int32_t var_8h;
    eax = caml_local_roots;
    *((ebp - 0x3c)) = eax;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp + 0x14;
    *((ebp - 0x20)) = eax;
    eax = *((ebp + 8));
    edi = *((eax + 4));
    esi = *((ebp + 0x10));
    ebx = *((ebp + 0x14));
    ebx >>= 1;
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (edi);
    }
    if (ebx <= 0) {
        goto label_0;
    }
    esi >>= 1;
    do {
        eax = esi;
        eax += *((ebp + 0xc));
        eax = caml_putblock (edi, eax, ebx);
        esi += eax;
        ebx -= eax;
    } while (ebx > 0);
label_0:
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (edi);
    }
    eax = *((ebp - 0x3c));
    *(obj.caml_local_roots) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067c62 */
#include <stdint.h>
 
int32_t caml_urge_major_slice (void) {
    *(obj.caml_force_major_slice) = 1;
    eax = caml_young_end;
    *(obj.caml_young_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059660 */
#include <stdint.h>
 
int32_t camlMap_exists_1210 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
label_0:
        ecx = eax;
        if (ebx == 1) {
            goto label_1;
        }
        eax = *((ebx + 0xc));
        esi = *((ebx + 8));
        eax = *((ebx + 4));
        edx = *(ebx);
        ebx = esi;
        eax = caml_apply2 (edx, ecx, eax);
        if (eax != 1) {
            eax = 3;
            return eax;
        }
        eax = *((esp + 4));
        ebx = *(esp);
        eax = camlMap_exists_1210 ();
    } while (1);
    if (eax != 1) {
        eax = 3;
        return eax;
    }
    eax = *((esp + 4));
    ebx = *((esp + 8));
    goto label_0;
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073330 */
#include <stdint.h>
 
int32_t caml_obj_add_offset (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax += *((edx + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806683d */
#include <stdint.h>
 
int32_t unix_write (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t fd;
    void * s1;
    int32_t var_4040h;
    int32_t var_403ch;
    int32_t var_4038h;
    int32_t var_4034h;
    int32_t var_4030h;
    int32_t var_402ch;
    int32_t var_4018h;
    char * ptr;
    size_t nbytes;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x120be;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4038)) = edx;
    edx = ebp - 0x4038;
    *(eax) = edx;
    *((ebp - 0x4030)) = 1;
    *((ebp - 0x4034)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x402c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    if (esi <= 0) {
        goto label_0;
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebp - 0x403c)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *((ebp - 0x4048)) = eax;
    *((ebp - 0x4040)) = 0;
    eax = ebp - 0x4018;
    *((ebp - 0x4044)) = eax;
    do {
        edi = 0x4000;
        if (esi <= 0x4000) {
            edi = esi;
        }
        eax = *((ebp - 0x403c));
        eax += *((ebp + 0xc));
        edx = *((ebp - 0x4044));
        memmove (edx, eax, edi);
        caml_enter_blocking_section ();
        eax = *((ebp - 0x4044));
        edx = *((ebp - 0x4048));
        eax = write (edx, eax, edi);
        edi = eax;
        caml_leave_blocking_section ();
        if (edi == -1) {
            esi = *((ebp - 0x4040));
            eax = errno_location ();
            if (*(eax) == 0xb) {
                if (esi > 0) {
                    goto label_1;
                }
            }
            eax = ebx - 0x21a2;
            uerror (eax, 0);
        }
        *((ebp - 0x4040)) += edi;
        esi -= edi;
        if (esi <= 0) {
            goto label_1;
        }
        *((ebp - 0x403c)) += edi;
    } while (1);
label_0:
    *((ebp - 0x4040)) = 0;
label_1:
    edx = *((ebp - 0x4038));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    edx = *((ebp - 0x4040));
    eax = edx + edx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80587b0 */
#include <stdint.h>
 
int32_t camlMap_filt_1219 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    do {
label_0:
        if (ebx == 1) {
            goto label_1;
        }
        eax = *((ebx + 0xc));
        esi = *((ebx + 8));
        eax = *((ebx + 4));
        edx = *(ebx);
        ecx = *((ecx + 0x10));
        ebx = esi;
        eax = caml_apply2 (eax, eax, ecx);
        if (eax != 1) {
            eax = *((esp + 8));
            edx = *((eax + 0xc));
            eax = *((esp + 0xc));
            ebx = *((esp + 0x10));
            ecx = *((esp + 0x14));
            camlMap_add_1108 ();
        } else {
            eax = *((esp + 0x14));
        }
        ebx = *(esp);
        ecx = *((esp + 8));
        camlMap_filt_1219 ();
    } while (1);
    ebx = *((esp + 4));
    ecx = *((esp + 8));
    goto label_0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c830 */
#include <stdint.h>
 
int32_t camlUnix_single_write_1247 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = unix_single_write;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.single_write";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058bb0 */
#include <stdint.h>
 
int32_t camlMap_singleton_1078 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1400;
            *(eax) = 1;
            *((eax + 4)) = ecx;
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = 1;
            *((eax + 0x10)) = 3;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054e90 */
#include <stdint.h>
 
int32_t camlList_remove_assq_1195 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        esi = *((ebx + 4));
        edx = *(ebx);
        ecx = *(edx);
        if (ecx == eax) {
            eax = esi;
            return eax;
        }
        ebx = esi;
        eax = camlList_remove_assq_1195 (edx);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *(esp);
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f890 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1420 (void) {
    eax = caml_ml_output_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054580 */
#include <stdint.h>
 
int32_t camlList_length_aux_1030 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        ebx = *((ebx + 4));
        eax += 2;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069d5a */
#include <stdint.h>
 
int32_t caml_realloc_ref_table (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * size;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *(ebx);
    if (edi == 0) {
        eax = caml_minor_heap_size;
        eax >>= 5;
        caml_alloc_table (ebx, eax, 0x100);
    } else {
        eax = *((ebx + 0x10));
        if (eax == *((ebx + 8))) {
            caml_gc_message (8, "ref_table threshold crossed\n", 0);
            eax = *((ebx + 4));
            *((ebx + 0x10)) = eax;
            caml_urge_major_slice ();
        } else {
            eax = *((ebx + 0xc));
            *((ebp - 0x1c)) = eax;
            esi = *((ebx + 0x14));
            esi += esi;
            *((ebx + 0x14)) = esi;
            esi += *((ebx + 0x18));
            esi <<= 2;
            eax = esi + 0x3ff;
            __asm ("cmovns eax, esi");
            eax >>= 0xa;
            caml_gc_message (8, "Growing ref_table to %ldk bytes\n", eax);
            eax = *(ebx);
            eax = realloc (eax, esi);
            *(ebx) = eax;
            if (eax == 0) {
                eax = caml_fatal_error ("Fatal error: ref_table overflow\n");
            }
            ecx = *((ebx + 0x14));
            edx = *((ebx + 0x18));
            edx += ecx;
            edx = eax + edx*4;
            *((ebx + 4)) = edx;
            ecx = eax + ecx*4;
            *((ebx + 8)) = ecx;
            ecx = *((ebp - 0x1c));
            ecx -= edi;
            edi = ecx;
            edi &= 0xfffffffc;
            eax += edi;
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = edx;
        }
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073955 */
#include <stdint.h>
 
int32_t caml_fatal_uncaught_exception (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * format;
    char ** var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    eax = caml_format_exception (eax);
    ebx = eax;
    esi = caml_backtrace_active;
    edi = caml_backtrace_pos;
    *(obj.caml_backtrace_active) = 0;
    eax = caml_named_value ("Pervasives.do_at_exit");
    if (eax != 0) {
        eax = *(eax);
        caml_callback_exn (eax, 1);
    }
    *(obj.caml_backtrace_active) = esi;
    *(obj.caml_backtrace_pos) = edi;
    *((esp + 8)) = ebx;
    eax = stderr;
    fprintf (eax, "Fatal error: exception %s\n");
    free (ebx);
    if (*(obj.caml_backtrace_active) != 0) {
        caml_print_exception_backtrace ();
    }
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055730 */
#include <stdint.h>
 
int32_t camlChar_compare_1048 (void) {
    eax -= ebx;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80570c0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_1198 (void) {
    int32_t var_4h_5;
    int32_t var_8h_3;
    int32_t var_ch_2;
    edx = *((eax + 4));
    edx = *((edx - 4));
    edx >>= 0xa;
    if (edx != 0) {
        eax = *((ecx + 0x10));
        eax = *((eax + 8));
        edx = *((eax + 4));
        ecx = *(edx);
        eax = ebx;
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, ecx, ebx);
        ebx = 0x7fffffff;
        eax &= ebx;
        eax >>= 1;
        ecx = *((esp + 0xc));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    eax = *(esp);
    ebx = *((eax + 4));
    eax = *((ebx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    ebx = *((ebx + edx*2 - 2));
    if (ebx == 1) {
        goto label_3;
    }
    eax = *((ebx + 8));
    eax = *((ebx + 4));
    ebx = *(ebx);
    eax = *((esp + 4));
    eax = *((eax + 0xc));
    ecx = *(eax);
    eax = *((esp + 8));
    eax = caml_apply2 (eax);
    if (eax != 1) {
        eax = *((esp + 0xc));
        return eax;
    }
    eax = *(esp);
    if (eax != 1) {
        ebx = *((eax + 8));
        ebx = *((eax + 4));
        ebx = *(eax);
        eax = *((esp + 4));
        eax = *((eax + 0xc));
        ecx = *(eax);
        eax = *((esp + 8));
        eax = caml_apply2 (ebx);
        if (eax != 1) {
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *(esp);
        if (eax != 1) {
            ebx = *((eax + 8));
            ebx = *((eax + 4));
            ebx = *(eax);
            eax = *((esp + 4));
            eax = *((eax + 0xc));
            ecx = *(eax);
            eax = *((esp + 8));
            eax = caml_apply2 (ebx);
            if (eax != 1) {
                eax = *((esp + 0xc));
                return eax;
            }
            eax = *((esp + 4));
            ecx = *((eax + 0x14));
            eax = *((esp + 8));
            ebx = *(esp);
            void (*0x8057030)() ();
        }
label_1:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x400;
        *(eax) = loc.caml_exn_Not_found;
        caml_raise_exn ();
    }
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = loc.caml_exn_Not_found;
    caml_raise_exn ();
    do {
label_3:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80578d0 */
#include <stdint.h>
 
int32_t camlHashtbl_add_1074 (void) {
    edi = eax;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = caml_hash_univ_param (ecx, 0xc9, ebx);
        eax >>= 1;
        ecx = esi;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            *(eax) = ebx;
            ebx = *(esp);
            *((eax + 4)) = ebx;
            ecx = *((edi + 4));
            ebx = *((ecx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_0;
            }
            ebx = *((ecx + edx*2 - 2));
            *((eax + 8)) = ebx;
            ecx = *((edi + 4));
            ebx = *((ecx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_1;
            }
            caml_modify (ecx + edx*2 - 2, eax);
            *(edi) += 2;
            eax = *((edi + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ebx = eax + eax - 1;
            eax = *(edi);
            if (eax > ebx) {
                eax = .comment;
                ebx = edi;
                void (*0x80577a0)() ();
            }
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80564b0 */
#include <stdint.h>
 
int32_t loc_camlSys_code_begin (void) {
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            ebx = .comment;
            *(eax) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063c68 */
#include <stdint.h>
 
int32_t unix_lseek_64 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14c90;
    eax = *((ebp + 0xc));
    esi = *((eax + 4));
    edi = *((eax + 8));
    caml_enter_blocking_section ();
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x24f8));
    *((esp + 0xc)) = eax;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = lseek64 ();
    esi = eax;
    edi = edx;
    caml_leave_blocking_section ();
    eax = esi;
    eax &= edi;
    if (eax == -1) {
        eax = ebx - 0x24fe;
        uerror (eax, 0);
    }
    caml_copy_int64 (esi, edi);
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807544d */
#include <stdint.h>
 
void caml_dlerror (void) {
    dlerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a634 */
#include <stdint.h>
 
void dlerror (void) {
    dlerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805fab0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_widen_1226 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    eax = *((eax + 0x10));
    eax = camlList_hd_1036 (eax);
    ebx = *((eax + 0x14));
    ebx = *((eax + 0x10));
    ebx = *((eax + 0xc));
    ebx = *((eax + 8));
    ebx = *((eax + 4));
    eax = *(eax);
    eax = *((esp + 0x18));
    eax = *((eax + 0x10));
    eax = camlList_tl_1039 (ebx, ebx, eax);
    ebx = *((esp + 0x1c));
    eax = *((esp + 0x1c));
    eax += 0x10;
    caml_modify (eax, eax);
label_0:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x805eb80;
    *((eax + 0xc)) = ebx;
    ebx = *(esp);
    ecx = *((esp + 4));
    eax = camlList_fold_left_1078 ();
    ebx = *((esp + 0x1c));
    eax = *((esp + 0x1c));
    eax += 0x18;
    caml_modify (eax, eax);
    eax = *((esp + 8));
    eax = ebx;
    eax += 8;
    caml_modify (eax, eax);
    eax = *((esp + 0xc));
    eax = ebx;
    eax += 0xc;
    caml_modify (eax, eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x805ebc0;
            ecx = *((esp + 0x10));
            *((eax + 0xc)) = ecx;
            ebx = *((ebx + 0x14));
            ecx = *((esp + 0x14));
            eax = camlList_fold_right_1084 ();
            eax = *((esp + 0x1c));
            eax += 0x14;
            caml_modify (eax, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80545d0 */
#include <stdint.h>
 
int32_t camlList_tl_1039 (void) {
    if (eax != 1) {
        eax = *((eax + 4));
        return eax;
    }
    eax = loc.camlList__50;
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80547b0 */
#include <stdint.h>
 
int32_t camlList_fold_left_1078 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        eax = ebx;
        if (ecx == 1) {
            goto label_0;
        }
        esi = *((ecx + 4));
        ecx = *(ecx);
        ebx = *(ecx);
        ecx = edx;
        eax = caml_apply2 (edx, esi);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c462 */
#include <stdint.h>
 
int32_t caml_float_compare (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_0;
        }
        fp_tmp_1 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
    } else {
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
    }
    if (fp_stack[0] <= fp_stack[1]) {
        fp_tmp_3 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_3;
        if (fp_stack[0] <= fp_stack[1]) {
            fp_stack--;
            if (fp_stack[0] != fp_stack[0]) {
                if (fp_stack[0] == fp_stack[0]) {
                    goto label_1;
                }
            }
            fp_stack--;
            if (fp_stack[0] != fp_stack[0]) {
                if (fp_stack[0] == fp_stack[0]) {
                    goto label_2;
                }
                goto label_3;
label_0:
                fp_stack++;
                fp_stack++;
            }
label_3:
            eax = 1;
            fp_stack++;
            fp_stack++;
label_2:
            eax = 0xffffffff;
        } else {
        } else {
            fp_stack++;
            fp_stack++;
            goto label_4;
label_1:
            fp_stack++;
label_4:
            eax = 3;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c080 */
#include <stdint.h>
 
int32_t camlUnix_fun_2616 (void) {
    eax = unix_getgrnam;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80607f0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_app_const_1382 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlCamlinternalOO__fun_1786;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c280 */
#include <stdint.h>
 
int32_t camlUnix_fun_2674 (void) {
    eax = unix_readlink;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e570 */
#include <stdint.h>
 
int32_t camlPrintf_get_contents_1405 (void) {
    ecx = *((eax + 4));
    ebx = 1;
    eax = *(eax);
    camlString_sub_1046 (eax);
    ebx = *(esp);
    *((ebx + 4)) = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80580d0 */
#include <stdint.h>
 
int32_t camlHashtbl_fold_1138 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h;
    esi = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x1c;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x10f7;
    *(edx) = sym.caml_curry2;
    *((edx + 4)) = 5;
    *((edx + 8)) = 0x8056dc0;
    *((edx + 0xc)) = esi;
    esi = *((ebx + 4));
    ebx = edx + 0x14;
    *((ebx - 4)) = 0x400;
    *(ebx) = ecx;
    eax = 1;
    ecx = *((esi - 4));
    ecx >>= 9;
    ecx |= 1;
    ecx += 0xfffffffe;
    if (eax > ecx) {
        goto label_2;
    }
    *((esp + 0x10)) = ecx;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = ebx;
    *(esp) = esi;
    *((esp + 4)) = edx;
    do {
        ebx = *(ebx);
        ecx = *(esp);
        edx = *((ecx - 4));
        edx >>= 9;
        if (edx <= eax) {
            goto label_3;
        }
        eax = *((ecx + eax*2 - 2));
        ecx = *((esp + 4));
        eax = camlHashtbl_do_bucket_1142 ();
        ebx = *((esp + 0xc));
        caml_modify (ebx, eax);
        eax = *((esp + 0xc));
        edx = *((esp + 0xc));
        eax += 2;
        *((esp + 0xc)) = eax;
        ecx = *((esp + 0x10));
    } while (edx != ecx);
label_2:
    eax = *(ebx);
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bc48 */
#include <stdint.h>
 
int32_t caml_int64_bits_of_float (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *(eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065668 */
#include <stdint.h>
 
int32_t unix_getsockopt (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13298;
    eax = *((ebp + 8));
    eax >>= 1;
    edx = *((ebp + 0x10));
    edx >>= 1;
    edx <<= 3;
    edx += *((ebx + eax*4 - 0x138));
    ecx = *((ebp + 0xc));
    ecx = *((edx + 4));
    edx = *(edx);
    eax = *((ebx + eax*4 - 0x110));
    return unix_getsockopt_aux (ecx, eax, edx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80654b5 */
#include <stdint.h>
 
int32_t unix_getsockopt_aux (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t sockfd) {
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t level;
    int32_t optname;
    void * optval;
    socklen_t * optlen;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13443;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    if (esi <= 4) {
        eax = ebx;
        eax -= *((ebx + esi*4 - 0x13424));
        void (*eax)() ();
    }
    return unix_error (0x16, edi, 0);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064354 */
#include <stdint.h>
 
uint32_t unix_rmdir (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x145a7;
    esi = *((ebp + 8));
    *(esp) = esi;
    eax = rmdir ();
    if (eax == -1) {
        eax = ebx - 0x249a;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a624 */
#include <stdint.h>
 
void rmdir (void) {
    rmdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f8b0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1424 (void) {
    eax = caml_ml_flush;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d54d */
#include <stdint.h>
 
int32_t caml_array_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((ebp + 0x10));
    if (*((eax - 4)) == 0xfe) {
        eax = caml_array_set_float (eax, edx, ecx);
    } else {
        caml_array_set_addr (eax, edx, ecx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bec0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2566 (void) {
    eax = unix_tcflush;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804dd70 */
#include <stdint.h>
 
int32_t camlUnix_open_process_full_1985 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    int32_t var_20h;
    int32_t var_24h;
    int32_t var_28h;
    *((esp + 0xc)) = eax;
    *((esp + 0x10)) = ebx;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 0x18)) = ebx;
    eax = *(eax);
    *((esp + 8)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 4)) = ebx;
    eax = *(eax);
    *((esp + 0x14)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 0x1c)) = ebx;
    eax = *(eax);
    *(esp) = eax;
    eax = *((esp + 8));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    *((esp + 0x20)) = eax;
    eax = *((esp + 4));
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    *((esp + 0x24)) = eax;
    eax = *(esp);
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    ebx = eax;
    *((esp + 0x28)) = ebx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x34;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x800;
    eax = *(esp);
    *(esi) = eax;
    *((esi + 4)) = 1;
    edx = esi + 0xc;
    *((edx - 4)) = 0x800;
    eax = *((esp + 4));
    *(edx) = eax;
    *((edx + 4)) = esi;
    ecx = esi + 0x18;
    *((ecx - 4)) = 0x800;
    eax = *((esp + 8));
    *(ecx) = eax;
    *((ecx + 4)) = edx;
    ecx = esi + 0x24;
    *((ecx - 4)) = 0xc03;
    eax = *((esp + 0x20));
    *(ecx) = eax;
    eax = *((esp + 0x24));
    *((ecx + 4)) = eax;
    *((ecx + 8)) = ebx;
    eax = *((esp + 0xc));
    ebx = *((esp + 0x10));
    edx = *((esp + 0x14));
    esi = *((esp + 0x18));
    edi = *((esp + 0x1c));
    ebp = *(esp);
    *(loc.caml_extra_params) = ebp;
    camlUnix_open_proc_full_1975 (ecx);
    eax = *((esp + 0x14));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x18));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x1c));
    eax = unix_close;
    caml_c_call (eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *((esp + 0x20));
            *(eax) = ebx;
            ebx = *((esp + 0x24));
            *((eax + 4)) = ebx;
            ebx = *((esp + 0x28));
            *((eax + 8)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804dc00 */
#include <stdint.h>
 
int32_t camlUnix_open_proc_full_1975 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    ebx = caml_extra_params;
    eax = .comment;
    eax = camlList_for_all_1137 (eax, esi, edi);
    *((esp + 0xc)) = eax;
    eax = unix_fork;
    eax = caml_c_call (1);
    ecx = eax;
    if (ecx != 1) {
        eax = .comment;
        ebx = *((esp + 0x1c));
        void (*0x80578d0)() ();
    }
    eax = *((esp + 4));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *(esp);
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 8));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 8));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    if (eax == 1) {
        eax = loc.camlUnix__184;
        ebx = *((esp + 0x18));
        camlList_iter_1074 ();
    }
    fcn_0804dd00 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807331b */
#include <stdint.h>
 
int32_t caml_obj_set_tag (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebp + 8));
    *((eax - 4)) = dl;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ae40 */
#include <stdint.h>
 
int32_t caml_curry7_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b3f0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1565 (void) {
    edx = eax;
    eax = *((ecx + 0xc));
    eax -= edx;
    eax -= 3;
    eax += 2;
    esi = *((ecx + 0x10));
    ecx = *((esi - 4));
    edx = *((esi - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_0;
        }
        eax = caml_modify (esi + eax*2 - 2, ebx);
    } else {
        ecx >>= 0xa;
        if (ecx <= eax) {
            goto label_1;
        }
        *(fp_stack--) = *(ebx);
        *((esi + eax*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b843 */
#include <stdint.h>
 
uint32_t caml_int32_format (void) {
    char * format;
    int32_t var_8h_4;
    int32_t var_4h_3;
    int32_t var_8h_3;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = ebp - 0x38;
    eax = ebp - 0x59;
    edi = ebp - 0x58;
    ecx = esi;
    edx = 0x8077448;
    eax = *((ebp + 8));
    eax = parse_format (edi, eax);
    ebx = eax;
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    sprintf (ebx, esi, eax);
    eax = caml_copy_string (ebx);
    esi = eax;
    if (ebx != edi) {
        caml_stat_free (ebx);
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b520 */
#include <stdint.h>
 
uint32_t caml_apply4 (void) {
    int32_t var_14h;
    int32_t var_18h;
    edi = *((esi + 4));
    if (edi == 9) {
        edi = *((esi + 8));
        void (*edi)() ();
    }
    ecx = *(esi);
    ebx = esi;
    eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (ebx, ecx, edx);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 4));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 8));
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073d14 */
#include <stdint.h>
 
int32_t caml_callbackN (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_callbackN_exn (eax, eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060660 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_lookup_tables_1361 (void) {
    ecx = eax;
    eax = *((ecx + 4));
    if (eax != 1) {
        edx = .comment;
        ecx = *((ecx + 4));
        eax = *((ebx - 4));
        eax >>= 9;
        eax |= 1;
        eax += 0xfffffffe;
        void (*0x80605f0)() ();
    }
    eax = *((ebx - 4));
    eax >>= 9;
    eax |= 1;
    eax += 0xfffffffe;
    return camlCamlinternalOO_build_path_1346 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80503b0 */
#include <stdint.h>
 
int32_t camlPervasives_entry (void) {
    *(0x807c0f0) = loc.camlPervasives__84;
    *(0x807c0e8) = 0x807c4d4;
    *(0x807c0e4) = 0x807c4c8;
    *(0x807c0e0) = 0x807c4bc;
    *(0x807c0dc) = 0x807c4ac;
    *(0x807c0d8) = 0x807c4a0;
    *(0x807c0d4) = 0x807c494;
    *(0x807c0d0) = 0x807c488;
    *(0x807c0c0) = 0x807c47c;
    *(0x807c0b0) = 0x807c46c;
    *(0x807c0a4) = 0x807c460;
    *(0x807c0a0) = 0x807c454;
    *(0x807c09c) = 0x807c444;
    *(0x807c094) = 0x807c434;
    *(0x807c090) = 0x807c424;
    *(0x807c084) = 0x807c414;
    *(0x807c07c) = 0x807c408;
    eax = loc.camlPervasives__67;
    *(0x807bfd4) = eax;
    eax = loc.camlPervasives__66;
    *(loc.camlPervasives) = eax;
    caml_alloc1 ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = "Pervasives.Exit";
    *(0x807bfd8) = eax;
    eax = loc.camlPervasives__64;
    *(0x807bfdc) = eax;
    eax = loc.camlPervasives__63;
    *(0x807bfe0) = eax;
    eax = loc.camlPervasives__62;
    *(0x807bfe4) = eax;
    eax = loc.camlPervasives__61;
    *(0x807bff0) = eax;
    eax = 0x80000001;
    *(0x807bfec) = 0x80000001;
    *(0x807bfe8) = 0x7fffffff;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__60);
    *(0x807bff4) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__59);
    *(0x807bff8) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__58);
    *(0x807bffc) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__57);
    *(0x807c000) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__56);
    *(0x807c004) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__55);
    *(0x807c008) = eax;
    eax = loc.camlPervasives__54;
    *(0x807c00c) = eax;
    eax = loc.camlPervasives__53;
    *(0x807c010) = eax;
    eax = loc.camlPervasives__52;
    *(0x807c014) = eax;
    eax = loc.camlPervasives__51;
    *(0x807c018) = eax;
    eax = loc.camlPervasives__50;
    *(0x807c01c) = eax;
    eax = loc.camlPervasives__49;
    *(0x807c114) = eax;
    eax = loc.camlPervasives__48;
    *(0x807c108) = eax;
    eax = loc.camlPervasives__47;
    *(0x807c020) = eax;
    eax = loc.camlPervasives__46;
    *(0x807c024) = eax;
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (1);
    *(0x807c028) = eax;
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (3);
    *(0x807c02c) = eax;
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (5);
    *(0x807c030) = eax;
    eax = loc.camlPervasives__45;
    *(0x807c078) = eax;
    eax = loc.camlPervasives__44;
    *(0x807c070) = eax;
    eax = loc.camlPervasives__43;
    *(0x807c074) = eax;
    eax = loc.camlPervasives__42;
    *(0x807c080) = eax;
    eax = loc.camlPervasives__41;
    *(0x807c088) = eax;
    eax = loc.camlPervasives__40;
    *(0x807c08c) = eax;
    eax = loc.camlPervasives__39;
    *(0x807c098) = eax;
    eax = loc.camlPervasives__38;
    *(0x807c0a8) = eax;
    eax = loc.camlPervasives__37;
    *(0x807c0ac) = eax;
    eax = loc.camlPervasives__36;
    *(0x807c0bc) = eax;
    eax = loc.camlPervasives__35;
    *(0x807c0b4) = eax;
    eax = loc.camlPervasives__34;
    *(0x807c0b8) = eax;
    eax = loc.camlPervasives__33;
    *(0x807c0c8) = eax;
    eax = loc.camlPervasives__32;
    *(0x807c10c) = eax;
    eax = loc.camlPervasives__31;
    *(0x807c0cc) = eax;
    eax = loc.camlPervasives__30;
    *(0x807c0c4) = eax;
    eax = loc.camlPervasives__29;
    *(0x807c0ec) = eax;
    eax = loc.camlPervasives__28;
    *(0x807c034) = eax;
    eax = loc.camlPervasives__27;
    *(0x807c038) = eax;
    eax = loc.camlPervasives__26;
    *(0x807c03c) = eax;
    eax = loc.camlPervasives__25;
    *(0x807c040) = eax;
    eax = loc.camlPervasives__24;
    *(0x807c044) = eax;
    eax = loc.camlPervasives__23;
    *(0x807c048) = eax;
    eax = loc.camlPervasives__22;
    *(0x807c04c) = eax;
    eax = loc.camlPervasives__21;
    *(0x807c050) = eax;
    eax = loc.camlPervasives__20;
    *(0x807c054) = eax;
    eax = loc.camlPervasives__19;
    *(0x807c058) = eax;
    eax = loc.camlPervasives__18;
    *(0x807c05c) = eax;
    eax = loc.camlPervasives__17;
    *(0x807c060) = eax;
    eax = loc.camlPervasives__16;
    *(0x807c064) = eax;
    eax = loc.camlPervasives__15;
    *(0x807c068) = eax;
    eax = loc.camlPervasives__14;
    *(0x807c06c) = eax;
    eax = loc.camlPervasives__13;
    eax = 0x24;
    caml_allocN ();
    ebx = eax + 4;
    *((ebx - 4)) = 0x1800;
    *(ebx) = loc.camlPervasives__7;
    *((ebx + 4)) = 0x807c170;
    *((ebx + 8)) = 0x807c17c;
    *((ebx + 0xc)) = 0x807c188;
    *((ebx + 0x10)) = 0x807c198;
    *((ebx + 0x14)) = 0x807c1a4;
    *(0x807c0f4) = ebx;
    eax = loc.camlPervasives__6;
    *(0x807c0fc) = eax;
    eax = loc.camlPervasives__5;
    *(0x807c0f8) = eax;
    ebx += 0x1c;
    *((ebx - 4)) = 0x400;
    eax = .comment;
    *(ebx) = eax;
    *(0x807c118) = ebx;
    eax = loc.camlPervasives__4;
    *(0x807c104) = eax;
    eax = loc.camlPervasives__3;
    *(0x807c110) = eax;
    eax = camlPervasives__2;
    *(0x807c100) = eax;
    eax = caml_register_named_value;
    caml_c_call ("Pervasives.do_at_exit");
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075ba4 */
#include <stdint.h>
 
void loc_caml_allocN (int32_t arg_4h, int32_t arg_8h) {
    do {
        eax -= *(obj.caml_young_ptr);
        eax = -eax;
        if (eax >= *(obj.caml_young_limit)) {
            *(obj.caml_young_ptr) = eax;
            return eax;
        }
        eax -= *(obj.caml_young_ptr);
        eax = -eax;
        *(obj.caml_young_ptr) -= eax;
        eax = *((esp + 4));
        *(obj.caml_last_return_address) = eax;
        eax = esp + 8;
        *(obj.caml_bottom_of_stack) = eax;
        fcn_08075aed ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062234 */
#include <stdint.h>
 
uint32_t unix_clear_nonblock (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x166c7;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 3;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        ah &= 0xf7;
        *((esp + 8)) = eax;
        *((esp + 4)) = 4;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x25c4;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80567d0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_in_bucket_1213 (void) {
    int32_t var_4h_4;
    int32_t var_8h_2;
    do {
label_0:
        if (eax == 1) {
            goto label_1;
        }
        ecx = *((eax + 8));
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0xc));
        eax = caml_apply2 (ecx, ebx, ecx);
        if (eax == 1) {
            goto label_2;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        eax = camlHashtbl_find_in_bucket_1213 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 8));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_2:
            eax = *(esp);
            ebx = *((esp + 4));
            goto label_0;
label_1:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c779 */
#include <stdint.h>
 
int32_t caml_tan_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    tan (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a7a4 */
#include <stdint.h>
 
void tan (void) {
    tan ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806caf8 */
#include <stdint.h>
 
int32_t caml_add_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] += *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c530 */
#include <stdint.h>
 
int32_t camlUnix_fun_2754 (void) {
    eax = unix_open;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80641ec */
#include <stdint.h>
 
int32_t unix_readdir (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14714;
    eax = *((ebp + 8));
    eax = *(eax);
    if (eax == 0) {
        eax = ebx - 0x24bc;
        eax = unix_error (9, eax, 0);
    }
    *(esp) = eax;
    eax = readdir64 ();
    if (eax == 0) {
        eax = caml_raise_end_of_file ();
    }
    eax += 0x13;
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056b70 */
#include <stdint.h>
 
int32_t camlHashtbl_find_in_bucket_1108 (void) {
    int32_t var_18h_3;
    int32_t var_18h;
    do {
label_0:
        if (eax == 1) {
            goto label_1;
        }
        *((esp + 4)) = ebx;
        ecx = *((eax + 8));
        *(esp) = ecx;
        ecx = *((eax + 4));
        *((esp + 8)) = ecx;
        eax = *(eax);
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax != 1) {
            goto label_2;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        eax = camlHashtbl_find_in_bucket_1108 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 8));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_2:
            eax = *(esp);
            ebx = *((esp + 4));
            goto label_0;
label_1:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e81c */
#include <stdint.h>
 
uint32_t caml_ml_seek_out_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    caml_seek_out (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805a9a0 */
#include <stdint.h>
 
int32_t camlBuffer_sub_1046 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    if (ebx >= 1) {
        if (ecx < 1) {
            goto label_0;
        }
        edx = *((eax + 4));
        edx -= ecx;
        edx++;
        if (ebx > edx) {
            goto label_0;
        }
        *((esp + 8)) = ecx;
        *((esp + 4)) = ebx;
        *(esp) = eax;
        eax = caml_create_string;
        eax = caml_c_call (ecx);
        ecx = eax;
        edx = 1;
        eax = *(esp);
        eax = *(eax);
        ebx = *((esp + 4));
        esi = *((esp + 8));
        camlString_blit_1056 (ecx);
        eax = *((esp + 0xc));
        return eax;
    }
label_0:
    eax = "Buffer.sub";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073fa9 */
#include <stdint.h>
 
uint32_t caml_weak_get_copy (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_78h;
    int32_t var_74h;
    int32_t var_70h;
    int32_t var_6ch;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    void * var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    void * s2;
    size_t n;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    eax = ebp - 0x38;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    edx = ebp + 8;
    *((ebp - 0x2c)) = edx;
    edx = ebp + 0xc;
    *((ebp - 0x28)) = edx;
    esi = *((ebp + 0xc));
    esi >>= 1;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x40)) = 0;
    *((ebp - 0x60)) = eax;
    eax = ebp - 0x60;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x58)) = 1;
    *((ebp - 0x5c)) = 2;
    eax = ebp - 0x3c;
    *((ebp - 0x54)) = eax;
    eax = ebp - 0x40;
    *((ebp - 0x50)) = eax;
    esi++;
    if (esi != 0) {
        eax = *((ebp + 8));
        edx = *((eax - 4));
        edx >>= 0xa;
        if (esi < edx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.get");
label_0:
    esi <<= 2;
    eax = *((esi + eax));
    if (eax == *(obj.caml_weak_none)) {
        *(obj.caml_local_roots) = ebx;
        eax = 1;
        goto label_1;
    }
    if ((al & 1) != 0) {
        goto label_2;
    }
    edi = eax;
    ecx = eax;
    ecx >>= 0x17;
    edx = eax;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 3) == 0) {
        goto label_2;
    }
    edi -= 4;
    eax = *(edi);
    eax = *(edi);
    eax >>= 0xa;
    eax = caml_alloc (eax, eax);
    *((ebp - 0x40)) = eax;
    edx = *((ebp + 8));
    edx = *((esi + edx));
    if (edx == *(obj.caml_weak_none)) {
        *(obj.caml_local_roots) = ebx;
        eax = 1;
        goto label_1;
    }
    *((ebp - 0x74)) = edx;
    ecx = edx - 4;
    if (*(ecx) > 0xfa) {
        goto label_3;
    }
    *((ebp - 0x70)) = ecx;
    eax = *(ecx);
    eax >>= 0xa;
    if (eax == 0) {
        goto label_4;
    }
    esi = 0;
    *((ebp - 0x78)) = ebx;
    do {
        edi = esi*4;
        eax = *((ebp - 0x74));
        ebx = *((eax + esi*4));
        if (*(obj.caml_gc_phase) == 0) {
            if ((bl & 1) != 0) {
                goto label_5;
            }
            edx = ebx;
            edx >>= 0x17;
            eax = ebx;
            eax >>= 0xc;
            eax &= 0x7ff;
            edx = *((edx*4 + obj.caml_page_table));
            if ((*((edx + eax)) & 1) == 0) {
                goto label_5;
            }
            caml_darken (ebx, 0);
        }
label_5:
        eax = edi;
        eax += *((ebp - 0x40));
        edx = *(eax);
        *((ebp - 0x6c)) = edx;
        *(eax) = ebx;
        eax = edi;
        eax += *((ebp - 0x40));
        edx = eax;
        edx >>= 0x17;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 1) != 0) {
            if (*(obj.caml_gc_phase) == 0) {
                eax = *((ebp - 0x6c));
                caml_darken (eax, 0);
            }
            if ((bl & 1) != 0) {
                goto label_6;
            }
            eax = caml_young_end;
            if (ebx >= eax) {
                goto label_6;
            }
            edx = caml_young_start;
            if (ebx <= edx) {
                goto label_6;
            }
            if ((*((ebp - 0x6c)) & 1) == 0) {
                ecx = *((ebp - 0x6c));
                if (eax <= ecx) {
                    goto label_7;
                }
                if (edx < ecx) {
                    goto label_6;
                }
            }
label_7:
            edx = 0x8087aa8;
            eax = *(edx);
            if (eax >= *(0x8087aac)) {
                caml_realloc_ref_table (obj.caml_ref_table);
            }
            edx = 0x8087aa8;
            eax = *(edx);
            edi += *((ebp - 0x40));
            *(eax) = edi;
            eax += 4;
            *(edx) = eax;
        }
label_6:
        esi++;
        edx = *((ebp - 0x70));
        eax = *(edx);
        eax >>= 0xa;
    } while (eax > esi);
    ebx = *((ebp - 0x78));
    goto label_4;
label_3:
    ecx = *(ecx);
    ecx >>= 0xa;
    ecx <<= 2;
    eax = memmove (eax, edx, ecx);
    goto label_4;
label_2:
    *((ebp - 0x40)) = eax;
label_4:
    eax = caml_alloc_small (1, 0);
    *((ebp - 0x3c)) = eax;
    edx = *((ebp - 0x40));
    *(eax) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x3c));
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068002 */
#include <stdint.h>
 
int32_t caml_set_signal_action (int32_t signum, int32_t arg_ch) {
    int32_t var_120h;
    int32_t var_94h;
    int32_t var_90h;
    int32_t var_10h;
    struct sigaction * act;
    struct sigaction * oldact;
    eax = *((ebp + 0xc));
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
    } else {
        *((ebp - 0x94)) = 0;
        *((ebp - 0x10)) = 0;
        goto label_1;
    }
    *((ebp - 0x94)) = 1;
    *((ebp - 0x10)) = 0;
    goto label_1;
label_0:
    *((ebp - 0x94)) = sym.handle_signal;
    *((ebp - 0x10)) = 0;
label_1:
    ebx = ebp - 0x94;
    eax = ebp - 0x90;
    *(esp) = eax;
    sigemptyset ();
    eax = ebp - 0x120;
    eax = *((ebp + 8));
    eax = sigaction (eax, ebx, eax);
    edx = eax;
    eax = 0xffffffff;
    if (edx != -1) {
        edx = *((ebp - 0x120));
        eax = 2;
        if (edx == sym.handle_signal) {
            goto label_2;
        }
        al = (edx == 1) ? 1 : 0;
        eax = (int32_t) al;
    }
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c2a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2678 (void) {
    eax = unix_mkfifo;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807325d */
#include <stdint.h>
 
int32_t caml_md5_string (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_60h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = ebp - 0x60;
    caml_MD5Init (ebx);
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    caml_MD5Update (ebx, eax, eax);
    eax = caml_alloc_string (0x10);
    esi = eax;
    caml_MD5Final (eax, ebx);
    eax = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807372c */
#include <stdint.h>
 
int32_t caml_static_alloc (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    caml_stat_alloc (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8051830 */
#include <stdint.h>
 
int32_t camlArray_merge_1191 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    uint32_t var_8h;
    uint32_t var_ch;
    int32_t var_10h;
    *(esp) = eax;
    *((esp + 4)) = ecx;
    *((esp + 0x10)) = edx;
    *((esp + 8)) = edi;
    eax = caml_extra_params;
    *((esp + 0xc)) = eax;
    ebp = .comment;
    ecx = *(esp);
    edx = ecx + ebx - 1;
    eax = *((esp + 0x10));
    esi = eax + esi - 1;
label_1:
    eax = caml_young_ptr;
    eax -= 0x28;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    edi = eax + 4;
    *((edi - 4)) = 0x24f7;
    *(edi) = sym.caml_curry5;
    *((edi + 4)) = 0xb;
    *((edi + 8)) = 0x80507e0;
    eax = *((ebp + 0xc));
    *((edi + 0xc)) = eax;
    eax = *((ebp + 0x10));
    *((edi + 0x10)) = eax;
    ebx = *((esp + 4));
    *((edi + 0x14)) = ebx;
    eax = *((esp + 8));
    *((edi + 0x18)) = eax;
    *((edi + 0x1c)) = edx;
    *((edi + 0x20)) = esi;
    eax = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
        if (eax <= *((esp + 0x10))) {
            goto label_3;
        }
        eax = *((esp + 0x10));
        edx = *((ebx + eax*2 - 2));
    } else {
        eax >>= 0xa;
        if (eax <= *((esp + 0x10))) {
            goto label_4;
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        edx = eax + 4;
        *((edx - 4)) = 0x8fd;
        eax = *((esp + 0x10));
        *(fp_stack--) = *((ebx + eax*4 - 4));
        *(edx) = fp_stack[0];
        fp_stack--;
    }
    esi = *((ebp + 0x10));
    eax = *((esi - 4));
    ebx = *((esi - 4));
    ebx &= 0xff;
    if (ebx != 0xfe) {
        eax >>= 9;
        if (eax <= ecx) {
            goto label_6;
        }
        ebx = *((esi + ecx*2 - 2));
        goto label_7;
    }
    eax >>= 0xa;
    if (eax <= ecx) {
        goto label_8;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((esi + ecx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
label_7:
            eax = ecx;
            ecx = *((esp + 0x10));
            esi = *((esp + 0xc));
            void (*0x80507e0)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
label_8:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e3a3 */
#include <stdint.h>
 
uint32_t caml_ml_output_partial (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp + 0x14;
    *((ebp - 0x20)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0x14));
    eax >>= 1;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    eax = caml_putblock (ebx, eax, eax);
    edi = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067c95 */
#include <stdint.h>
 
int32_t caml_rev_convert_signal_number (int32_t arg_8h) {
    eax = *((ebp + 8));
    edx = 1;
    ecx = posix_signals;
    if (eax != 6) {
        goto label_0;
    }
    dl = 0;
    while (edx != 0x15) {
label_0:
        if (*((ecx + edx*4)) == eax) {
            eax = edx;
            eax = ~eax;
        } else {
            edx++;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b7f0 */
#include <stdint.h>
 
uint32_t camlSource_nth_toggle_init_1119 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ecx = loc.camlSource__6;
    ebx = loc.camlSource__5;
    eax = camlCamlinternalOO_new_methods_variables_1248 (eax);
    ebx = *(eax);
    ebx = *((eax + 4));
    eax = *((eax + 8));
    edi = 3;
    esi = camlSource;
    eax = *(esp);
    edx = *((eax + 0xc));
    ecx = 1;
    ebx = *((eax + 8));
    eax = *((esp + 0x10));
    eax = camlCamlinternalOO_inherits_1276 (eax, ebx, ebx);
    ebx = *(eax);
    *(esp) = ebx;
    ebx = *((eax + 4));
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x14f7;
    *(ecx) = sym.camlSource__method_activate_1113;
    *((ecx + 4)) = 3;
    *((ecx + 8)) = ebx;
    eax = *((esp + 8));
    *((ecx + 0xc)) = eax;
    eax = *((esp + 0xc));
    *((ecx + 0x10)) = eax;
    eax = *((esp + 0x10));
    ebx = *((esp + 4));
    camlCamlinternalOO_set_method_1195 ();
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1cf7;
            *(eax) = sym.caml_curry4;
            *((eax + 4)) = 9;
            *((eax + 8)) = 0x804b6c0;
            ebx = *((esp + 8));
            *((eax + 0xc)) = ebx;
            ebx = *((esp + 0xc));
            *((eax + 0x10)) = ebx;
            ebx = *((esp + 0x10));
            *((eax + 0x14)) = ebx;
            ebx = *(esp);
            *((eax + 0x18)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060080 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_inherits_1276 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    ebx = *((esi + 0xc));
    ebx = *((esi + 4));
    ebx = *((esp + 0xc));
    ecx = *(esp);
    edx = *((esp + 8));
    camlCamlinternalOO_narrow_1204 (eax, edi, edx);
    eax = *((esp + 4));
    if (eax != 1) {
        eax = *((esp + 0x14));
        ebx = *((esp + 0x10));
        ecx = *((esp + 0x18));
        eax = caml_apply2 ();
        *((esp + 0x10)) = eax;
    } else {
        ebx = *((esp + 0x18));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        eax = void (*ecx)() ();
    }
    eax = *((esp + 0x14));
    camlCamlinternalOO_widen_1226 (eax);
    eax = *((esp + 8));
    eax = camlCamlinternalOO_to_array_1246 ();
    ebx = eax;
label_2:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_3;
    }
    eax = eax + 4;
    *((eax - 4)) = 0xcf7;
    *(eax) = sym.camlCamlinternalOO__fun_1739;
    *((eax + 4)) = 3;
    ecx = *((esp + 0x14));
    *((eax + 8)) = ecx;
    eax = camlArray_map_1105 ();
    ebx = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_4;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x800;
    *(eax) = ebx;
    *((eax + 4)) = 1;
    eax = *((esp + 0xc));
    eax = camlCamlinternalOO_to_array_1246 (eax);
    ebx = .comment;
    ecx = *(ebx);
    eax = *((esp + 0x14));
    void (*ecx)(uint32_t) (eax);
    ebx = *(esp);
    eax = camlArray_map_1105 ();
    ecx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    ebx = eax + 4;
    *(esp) = ebx;
    *((ebx - 4)) = 0x800;
    *(ebx) = ecx;
    eax = *((esp + 4));
    *((ebx + 4)) = eax;
    ebx += 0xc;
    *((ebx - 4)) = 0x400;
    eax = *((esp + 0x10));
    *(ebx) = eax;
    eax = caml_make_array;
    eax = caml_c_call (ebx);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *(esp);
            *((eax + 4)) = ebx;
            void (*0x80522c0)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f6b0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_set_method_1195 (void) {
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = ebx;
    ebx = .comment;
    *(ebx) += 2;
    ebx = .comment;
    ecx = *((ebx + 0x54));
    ebx = *((edx + 0xc));
    eax = camlMap_find_1117 (edx, eax, ecx);
    if (eax == 1) {
        goto label_0;
    }
    eax = *(esp);
    ebx = *((esp + 4));
    ecx = *((esp + 8));
    void (*0x805f540)() ();
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            eax = *((esp + 8));
            *((ebx + 4)) = eax;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            *(ecx) = ebx;
            eax = *(esp);
            ebx = *((eax + 0x14));
            *((ecx + 4)) = ebx;
            eax += 0x14;
            caml_modify (eax, ecx);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f450 */
#include <stdint.h>
 
int32_t loc_camlPervasives_code_begin (void) {
    do {
        ecx = *((ebx + 0xc));
        if (eax >= ecx) {
            ecx = loc.camlPervasives__103;
            eax = *((ebx + 8));
            ebx = ecx;
            void (*0x804f9f0)() ();
        }
        edx = *((ebx + 8));
        ecx = eax;
        ecx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ecx) {
            goto label_0;
        }
        ecx = *((edx + ecx));
        ecx = ecx + ecx + 1;
        if (ecx >= 0x61) {
            if (ecx < 0x75) {
                goto label_1;
            }
        } else {
            if (ecx == 0x5b) {
                goto label_1;
            }
        }
        eax = *((ebx + 8));
        return eax;
label_1:
        eax += 2;
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059230 */
#include <stdint.h>
 
int32_t camlMap_remove_min_binding_1147 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *(eax);
        if (ecx == 1) {
            goto label_1;
        }
        ebx = *((eax + 0xc));
        ebx = *((eax + 8));
        ebx = *((eax + 4));
        eax = ecx;
        camlMap_remove_min_binding_1147 (ebx, ebx, ebx);
    } while (1);
    ebx = *(esp);
    ecx = *((esp + 4));
    edx = *((esp + 8));
    void (*0x8058c00)() ();
label_1:
    eax = *((eax + 0xc));
    return eax;
label_0:
    eax = "Map.remove_min_elt";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b610 */
#include <stdint.h>
 
int32_t camlStd_exit_entry (void) {
    eax = .comment;
    ebx = *(eax);
    eax = 1;
    ecx = *(ebx);
    void (*ecx)() ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067207 */
#include <stdint.h>
 
int32_t caml_stack_usage (void) {
    ebx = caml_top_of_stack;
    ebx -= *(obj.caml_bottom_of_stack);
    ebx >>= 2;
    eax = caml_stack_usage_hook;
    if (eax != 0) {
        eax = void (*eax)() ();
        ebx += eax;
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80711b5 */
#include <stdint.h>
 
uint32_t caml_sys_chdir (int32_t arg_8h) {
    ebx = *((ebp + 8));
    *(esp) = ebx;
    eax = chdir ();
    if (eax != 0) {
        caml_sys_error (ebx);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a4b4 */
#include <stdint.h>
 
void chdir (void) {
    chdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805be80 */
#include <stdint.h>
 
int32_t camlPrintf_add_conv_1169 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *((esp + 8)) = ebx;
    *((esp + 4)) = ecx;
    *(esp) = edx;
    if (eax != 1) {
        ebx = camlPrintf__64;
        eax = *((edx + 0xc));
        camlBuffer_add_string_1082 ();
    } else {
        ebx = 0x4b;
        eax = *((edx + 0xc));
        camlBuffer_add_char_1072 ();
    }
    eax = *(esp);
    eax = *((eax + 0x10));
    eax = *((eax + 0xc));
    ebx = *((esp + 4));
    camlBuffer_add_char_1072 ();
    eax = *((esp + 8));
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fac0 */
#include <stdint.h>
 
uint32_t camlPervasives_bool_of_string_1129 (void) {
    ebx = eax;
    eax = caml_string_notequal (ebx, "false");
    if (eax != 1) {
        eax = caml_string_notequal (ebx, "true");
        if (eax != 1) {
            eax = "bool_of_string";
            void (*0x804f900)() ();
        }
        eax = 3;
        return eax;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c95b */
#include <stdint.h>
 
int32_t caml_ldexp_float (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    ldexp (ebp, eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049dc4 */
#include <stdint.h>
 
void ldexp (void) {
    ldexp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050020 */
#include <stdint.h>
 
int32_t camlPervasives_print_char_1266 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x807c02c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804e560 */
#include <stdint.h>
 
int32_t camlUnix_entry (void) {
    *(0x8079a4c) = loc.camlUnix__175;
    *(0x8079a48) = 0x807a364;
    *(0x8079a44) = 0x807a354;
    *(0x8079a40) = 0x807a348;
    *(0x8079a3c) = 0x807a338;
    *(0x8079a38) = 0x807a328;
    *(0x8079a34) = 0x807a31c;
    *(0x8079a28) = 0x807a30c;
    *(0x8079a24) = 0x807a2fc;
    *(0x8079a20) = 0x807a2f0;
    *(0x8079a1c) = 0x807a2e4;
    *(0x8079a18) = 0x807a2d8;
    *(0x8079a14) = 0x807a2cc;
    *(0x8079a10) = 0x807a2c0;
    *(0x80799cc) = 0x807a2b4;
    *(0x80799c8) = 0x807a2a8;
    *(0x80799c4) = 0x807a298;
    *(0x80799c0) = 0x807a288;
    *(0x80799bc) = 0x807a278;
    *(0x80799b8) = 0x807a268;
    *(0x80799b4) = 0x807a25c;
    *(0x80799b0) = 0x807a24c;
    *(0x80799a8) = 0x807a23c;
    *(0x8079994) = 0x807a230;
    *(0x8079990) = 0x807a224;
    *(0x807998c) = 0x807a218;
    *(0x8079988) = 0x807a20c;
    *(0x8079984) = 0x807a200;
    *(0x8079980) = 0x807a1f4;
    *(0x807997c) = 0x807a1e8;
    *(0x8079978) = 0x807a1d8;
    *(0x8079974) = 0x807a1cc;
    *(0x8079970) = 0x807a1c0;
    *(0x807996c) = 0x807a1b4;
    *(0x8079968) = 0x807a1a8;
    *(0x8079964) = 0x807a19c;
    *(0x8079960) = 0x807a190;
    *(0x807995c) = 0x807a184;
    *(0x8079958) = 0x807a178;
    *(0x8079954) = 0x807a168;
    *(0x8079950) = 0x807a15c;
    *(0x807994c) = 0x807a14c;
    *(0x8079948) = 0x807a140;
    *(0x8079944) = 0x807a134;
    *(0x8079940) = 0x807a128;
    *(0x807993c) = 0x807a11c;
    *(0x8079938) = 0x807a110;
    *(0x8079934) = 0x807a104;
    *(0x8079930) = 0x807a0f8;
    *(0x807992c) = 0x807a0ec;
    *(0x8079924) = 0x807a0e0;
    *(0x8079920) = 0x807a0d4;
    *(0x807991c) = 0x807a0c4;
    *(0x8079918) = 0x807a0b4;
    *(0x8079914) = 0x807a0a4;
    *(0x8079910) = 0x807a094;
    *(0x807990c) = 0x807a088;
    *(0x8079908) = 0x807a078;
    *(0x80798dc) = 0x807a068;
    *(0x80798d8) = 0x807a05c;
    *(0x80798d4) = 0x807a050;
    *(0x80798d0) = 0x807a044;
    *(0x80798cc) = 0x807a038;
    *(0x80798c8) = 0x807a02c;
    *(0x80798c4) = 0x807a020;
    *(0x80798c0) = 0x807a014;
    *(0x80798bc) = 0x807a008;
    *(0x80798b8) = 0x8079ffc;
    *(0x80798b4) = 0x8079fec;
    *(0x80798b0) = 0x8079fe0;
    *(0x80798ac) = 0x8079fd4;
    *(0x80798a8) = 0x8079fc8;
    *(0x80798a4) = 0x8079fbc;
    *(0x80798a0) = 0x8079fac;
    *(0x807989c) = 0x8079fa0;
    *(0x8079898) = 0x8079f90;
    *(0x8079894) = 0x8079f84;
    *(0x8079890) = 0x8079f74;
    *(0x807988c) = 0x8079f64;
    *(0x8079888) = 0x8079f54;
    *(0x8079884) = 0x8079f44;
    *(0x8079880) = 0x8079f34;
    *(0x807987c) = 0x8079f24;
    *(0x8079878) = 0x8079f18;
    *(0x8079870) = 0x8079f0c;
    *(0x807986c) = 0x8079f00;
    *(0x8079868) = 0x8079ef4;
    *(0x8079864) = 0x8079ee8;
    *(0x8079860) = 0x8079ed8;
    *(0x807985c) = 0x8079ec8;
    *(0x8079858) = 0x8079eb8;
    *(0x8079854) = 0x8079eac;
    *(0x8079850) = 0x8079ea0;
    *(0x807984c) = 0x8079e94;
    *(0x8079848) = 0x8079e88;
    *(0x8079838) = 0x8079e7c;
    *(0x8079834) = 0x8079e6c;
    *(0x8079824) = 0x8079e60;
    *(0x8079820) = 0x8079e54;
    *(0x807981c) = 0x8079e48;
    *(0x8079814) = 0x8079e38;
    *(0x8079810) = 0x8079e2c;
    *(0x807980c) = 0x8079e20;
    *(0x8079808) = 0x8079e10;
    *(0x8079804) = 0x8079e00;
    *(0x8079800) = 0x8079df0;
    *(0x80797fc) = 0x8079de0;
    *(0x80797f8) = 0x8079dd0;
    *(0x80797f4) = 0x8079dc4;
    *(0x80797f0) = 0x8079db8;
    *(0x80797e8) = 0x8079dac;
    eax = 0x1c;
    caml_allocN ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = "Unix.Unix_error";
    *(loc.camlUnix) = eax;
    ebx = eax + 8;
    *((ebx - 4)) = 0x1000;
    eax = camlUnix;
    *(ebx) = eax;
    *((ebx + 4)) = 1;
    *((ebx + 8)) = 0x807a3dc;
    *((ebx + 0xc)) = 0x807a3e4;
    eax = "Unix.Unix_error";
    camlCallback_register_exception_1034 ();
    eax = loc.camlUnix__60;
    *(0x80797ec) = eax;
    *(0x8079828) = 1;
    *(0x807982c) = 3;
    *(0x8079830) = 5;
    eax = loc.camlUnix__59;
    *(0x807983c) = eax;
    eax = loc.camlUnix__58;
    *(0x8079840) = eax;
    eax = loc.camlUnix__57;
    *(0x8079844) = eax;
    eax = loc.camlUnix__56;
    eax = 0x1c;
    caml_allocN ();
    eax = eax + 4;
    *((eax - 4)) = 0x1800;
    *(eax) = loc.camlUnix__50;
    *((eax + 4)) = 0x8079d28;
    *((eax + 8)) = 0x8079d38;
    *((eax + 0xc)) = 0x8079d48;
    *((eax + 0x10)) = 0x8079d54;
    *((eax + 0x14)) = 0x8079d60;
    *(0x8079874) = eax;
    eax = loc.camlUnix__49;
    *(0x8079a50) = eax;
    eax = loc.camlUnix__48;
    *(0x8079928) = eax;
    eax = loc.camlUnix__47;
    *(0x8079a54) = eax;
    eax = unix_inet_addr_of_string;
    eax = caml_c_call ("0.0.0.0");
    *(0x8079998) = eax;
    eax = unix_inet_addr_of_string;
    eax = caml_c_call ("127.0.0.1");
    *(0x807999c) = eax;
    eax = void (*0x804eafa)() ();
    ecx = caml_exn_Failure;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = .comment;
    } else {
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = unix_inet_addr_of_string;
        eax = caml_c_call (loc.camlUnix__44);
    }
    *(0x80799a0) = eax;
    eax = void (*0x804eb42)() ();
    ecx = caml_exn_Failure;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = .comment;
    } else {
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = unix_inet_addr_of_string;
        eax = caml_c_call (loc.camlUnix__43);
    }
    *(0x80799a4) = eax;
    eax = loc.camlUnix__42;
    *(0x80799ac) = eax;
    eax = loc.camlUnix__41;
    *(0x80799d0) = eax;
    eax = loc.camlUnix__40;
    *(0x80799d4) = eax;
    eax = loc.camlUnix__39;
    *(0x80799d8) = eax;
    eax = loc.camlUnix__38;
    *(0x80799dc) = eax;
    eax = 0x20;
    caml_allocN ();
    eax = eax + 4;
    *((eax - 4)) = 0x1c00;
    *(eax) = 1;
    *((eax + 4)) = 3;
    *((eax + 8)) = 5;
    *((eax + 0xc)) = 7;
    *((eax + 0x10)) = 9;
    *((eax + 0x14)) = 0x8079c88;
    *((eax + 0x18)) = 0x8079c98;
    *(0x8079a58) = eax;
    eax = loc.camlUnix__35;
    *(0x80799e0) = eax;
    eax = loc.camlUnix__34;
    *(0x80799e4) = eax;
    eax = loc.camlUnix__33;
    *(0x80799e8) = eax;
    eax = loc.camlUnix__32;
    *(0x80799ec) = eax;
    eax = loc.camlUnix__31;
    *(0x80799f0) = eax;
    eax = loc.camlUnix__30;
    *(0x80799f4) = eax;
    eax = loc.camlUnix__29;
    *(0x80799f8) = eax;
    eax = loc.camlUnix__28;
    *(0x80799fc) = eax;
    eax = loc.camlUnix__27;
    *(0x8079a00) = eax;
    eax = loc.camlUnix__26;
    *(0x8079a5c) = eax;
    eax = loc.camlUnix__25;
    *(0x8079a2c) = eax;
    eax = loc.camlUnix__24;
    *(0x8079a60) = eax;
    eax = loc.camlUnix__23;
    *(0x8079a30) = eax;
    eax = loc.camlUnix__22;
    *(0x8079818) = eax;
    eax = loc.camlUnix__21;
    *(0x8079a64) = eax;
    eax = loc.camlUnix__20;
    *(0x8079a68) = eax;
    eax = loc.camlUnix__19;
    *(0x8079a6c) = eax;
    eax = loc.camlUnix__18;
    *(0x80798e0) = eax;
    eax = loc.camlUnix__17;
    *(0x80798e4) = eax;
    eax = 0xf;
    eax = camlHashtbl_create_1051 ();
    *(0x8079a70) = eax;
    eax = loc.camlUnix__16;
    *(0x8079a74) = eax;
    eax = loc.camlUnix__15;
    *(0x80798e8) = eax;
    eax = loc.camlUnix__14;
    *(0x80798ec) = eax;
    eax = loc.camlUnix__13;
    *(0x80798f0) = eax;
    eax = loc.camlUnix__12;
    *(0x8079a78) = eax;
    eax = loc.camlUnix__11;
    *(0x80798f4) = eax;
    eax = loc.camlUnix__10;
    *(0x8079a7c) = eax;
    eax = loc.camlUnix__9;
    *(0x8079a80) = eax;
    eax = loc.camlUnix__8;
    *(0x80798f8) = eax;
    eax = loc.camlUnix__7;
    *(0x80798fc) = eax;
    eax = loc.camlUnix__6;
    *(0x8079900) = eax;
    eax = loc.camlUnix__5;
    *(0x8079904) = eax;
    eax = loc.camlUnix__4;
    *(0x8079a04) = eax;
    eax = loc.camlUnix__3;
    *(0x8079a08) = eax;
    eax = loc.camlUnix__2;
    *(0x8079a84) = eax;
    eax = camlUnix__1;
    *(0x8079a0c) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b260 */
#include <stdint.h>
 
int32_t caml_curry4_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry4_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cc80 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_error_1671 (void) {
    eax = unix_getsockopt;
    caml_c_call (9);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ad80 */
#include <stdint.h>
 
int32_t camlBuffer_add_channel_1090 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    *((esp + 8)) = ecx;
    if (ecx >= 1) {
        eax = .comment;
        if (ecx <= eax) {
            goto label_0;
        }
    }
    eax = "Buffer.add_channel";
    camlPervasives_invalid_arg_1012 ();
label_0:
    eax = *((esp + 4));
    edx = *((eax + 8));
    ecx = *((eax + 4));
    ebx = *((esp + 8));
    ecx = ecx + ebx - 1;
    if (ecx > edx) {
        camlBuffer_resize_1066 ();
    }
    eax = *((esp + 4));
    ecx = *((eax + 4));
    ebx = *(eax);
    eax = *(esp);
    edx = *((esp + 8));
    camlPervasives_really_input_1235 ();
    ebx = *((esp + 4));
    ecx = *((ebx + 4));
    eax = *((esp + 8));
    eax = ecx + eax - 1;
    *((ebx + 4)) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c560 */
#include <stdint.h>
 
int32_t camlUnix_fun_2758 (void) {
    eax = unix_getppid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f9c3 */
#include <stdint.h>
 
int32_t caml_deserialize_sint_1 (void) {
    edx = intern_src;
    eax = *(edx);
    edx++;
    *(obj.intern_src) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80550b0 */
#include <stdint.h>
 
int32_t camlList_combine_1226 (void) {
    int32_t var_4h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        if (ebx == 1) {
            goto label_1;
        }
        esi = *((ebx + 4));
        ecx = *(ebx);
        edx = *((eax + 4));
        ecx = *(eax);
        eax = edx;
        ebx = esi;
        eax = camlList_combine_1226 (ecx, ecx);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            eax = *((esp + 4));
            *((ebx + 4)) = eax;
            eax = ebx + 0xc;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            if (ebx == 1) {
                eax = 1;
                return eax;
            }
label_1:
            eax = "List.combine";
            void (*0x804f900)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064c3c */
#include <stdint.h>
 
int32_t unix_shutdown (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13cc4;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x2450));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = shutdown ();
    if (eax == -1) {
        eax = ebx - 0x245b;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049ee4 */
#include <stdint.h>
 
void shutdown (void) {
    shutdown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063ff8 */
#include <stdint.h>
 
uint32_t unix_pipe (void) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14908;
    eax = ebp - 0x10;
    *(esp) = eax;
    eax = pipe ();
    if (eax == -1) {
        eax = ebx - 0x24cd;
        uerror (eax, 0);
    }
    caml_alloc_small (2, 0);
    edx = *((ebp - 0x10));
    edx = edx + edx + 1;
    *(eax) = edx;
    edx = *((ebp - 0xc));
    edx = edx + edx + 1;
    *((eax + 4)) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a794 */
#include <stdint.h>
 
void pipe (void) {
    pipe ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805fc10 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_new_variable_1242 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = ebx;
    eax = void (*0x805fca0)(uint32_t, uint32_t) (eax, edx);
    ecx = loc.caml_exn_Not_found;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *((esp + 8));
        eax = camlCamlinternalOO_new_slot_1239 ();
        ebx = eax;
        esi = *((esp + 4));
        eax = caml_string_notequal (esi, ebx);
        if (eax != 1) {
            eax = .comment;
            edx = *((eax + 0xc));
            eax = *((esp + 8));
            ecx = *((eax + 0x18));
            eax = esi;
            eax = camlMap_add_1108 ();
            eax = *((esp + 0xc));
            eax += 0x18;
            caml_modify (eax, eax);
        }
        eax = *((esp + 4));
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ecx = .comment;
    ecx = *((ecx + 0x54));
    ebx = *((edx + 0x18));
    camlMap_find_1117 (*(obj.caml_exception_pointer));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805fc00 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_new_slot_1239 (void) {
    ecx = eax;
    eax = *(ecx);
    ebx = *(ecx);
    ebx += 2;
    *(ecx) = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061400 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_set_methods_1591 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 8)) = eax;
    *((esp + 4)) = ebx;
    eax = *((ebx - 4));
    eax >>= 9;
    eax |= 1;
    *(esp) = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ebx = eax + 4;
    *((esp + 0x10)) = ebx;
    *((ebx - 4)) = 0x400;
    *(ebx) = 1;
    do {
        ecx = *(ebx);
        eax = *(esp);
        if (ecx >= eax) {
            goto label_2;
        }
        edx = *(ebx);
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        eax >>= 9;
        if (eax <= edx) {
            goto label_3;
        }
        eax = *((ecx + edx*2 - 2));
        eax = *((esp + 8));
        eax = camlCamlinternalOO_method_impl_1529 (eax);
        ecx = eax;
        eax = *((esp + 8));
        ebx = *((esp + 0xc));
        camlCamlinternalOO_set_method_1195 ();
        ebx = *((esp + 0x10));
        *(ebx) += 2;
    } while (1);
label_2:
    eax = 1;
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060ca0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_send_meth_1469 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlCamlinternalOO__fun_1858;
            *((eax + 4)) = 3;
            *((eax + 8)) = edx;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064114 */
#include <stdint.h>
 
int32_t unix_read (int32_t fildes, void * s1, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4028h;
    int32_t var_4024h;
    int32_t var_4020h;
    int32_t var_401ch;
    int32_t var_4008h;
    void * buf;
    size_t nbyte;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x147e8;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4028)) = edx;
    edx = ebp - 0x4028;
    *(eax) = edx;
    *((ebp - 0x4020)) = 1;
    *((ebp - 0x4024)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x401c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    caml_enter_blocking_section ();
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    eax = ebp - 0x4008;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = read (eax, eax, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x24c1;
        uerror (eax, 0);
    }
    eax = ebp - 0x4008;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    memmove (eax, eax, esi);
    edx = *((ebp - 0x4028));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a114 */
#include <stdint.h>
 
void read (void) {
    read ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f77a */
#include <stdint.h>
 
int32_t caml_output_value_to_block (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    eax = *((ebp + 0x10));
    *(obj.extern_userprovided_output) = eax;
    *(obj.extern_ptr) = eax;
    eax += *((ebp + 0x14));
    *(obj.extern_limit) = eax;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    extern_value ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8053740 */
#include <stdint.h>
 
int32_t camlList_rmap_f_1070 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_1;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = *((ecx + 0xc));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (eax, eax, ecx);
        ebx = eax;
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        ebx = *(esp);
        *((eax + 4)) = ebx;
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_1:
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e253 */
#include <stdint.h>
 
int32_t caml_putblock (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_20h;
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edx = *((ebp + 0xc));
    edi = *((ebp + 0x10));
    eax = *((ebx + 0x10));
    esi = *((ebx + 0xc));
    esi -= eax;
    if (edi < esi) {
        memmove (eax, edx, edi);
        *((ebx + 0x10)) += edi;
        eax = edi;
    } else {
        memmove (eax, edx, esi);
        eax = ebx + 0x34;
        *((ebp - 0x1c)) = eax;
        eax = *((ebx + 0xc));
        eax -= *((ebp - 0x1c));
        *((ebp - 0x20)) = eax;
        ecx = eax;
        edx = *((ebp - 0x1c));
        eax = *(ebx);
        eax = do_write ();
        edi = eax;
        if (*((ebp - 0x20)) > eax) {
            eax = *((ebp - 0x20));
            eax -= edi;
            eax = *((ebp - 0x1c));
            eax += edi;
            eax = *((ebp - 0x1c));
            memmove (eax, eax, eax);
        }
        edx = edi;
        edx >>= 0x1f;
        *((ebx + 4)) += edi;
        *((ebx + 8)) += edx;
        edi = -edi;
        edi += *((ebx + 0xc));
        *((ebx + 0x10)) = edi;
        eax = esi;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bbec */
#include <stdint.h>
 
int32_t caml_int64_to_nativeint (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e920 */
#include <stdint.h>
 
uint32_t camlCallback_register_exception_1034 (void) {
    ecx = eax;
    eax = *((ebx - 4));
    if (eax == 0xfe) {
        goto label_0;
    }
    eax = *(ebx);
    while (1) {
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(eax) = fp_stack[0];
            fp_stack--;
            eax = caml_register_named_value;
            caml_c_call (ecx);
            return eax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806deba */
#include <stdint.h>
 
uint32_t caml_ml_input_scan_line (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = caml_input_scan_line (ebx);
    edi = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806caaa */
#include <stdint.h>
 
int32_t caml_div_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] /= *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c240 */
#include <stdint.h>
 
int32_t camlUnix_fun_2670 (void) {
    eax = unix_lockf;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ab30 */
#include <stdint.h>
 
int32_t caml_curry9_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064e56 */
#include <stdint.h>
 
int32_t unix_sigprocmask (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_118h;
    int32_t var_98h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13a9f;
    eax = *((ebp + 8));
    eax >>= 1;
    edi = *((ebx + eax*4 - 0x2420));
    esi = ebp - 0x98;
    edx = esi;
    eax = *((ebp + 0xc));
    decode_sigset ();
    caml_enter_blocking_section ();
    eax = ebp - 0x118;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = edi;
    eax = sigprocmask ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x242e;
        uerror (eax, 0);
    }
    eax = ebp - 0x118;
    encode_sigset ();
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a5d4 */
#include <stdint.h>
 
void sigprocmask (void) {
    sigprocmask ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806545b */
#include <stdint.h>
 
int32_t unix_setsockopt (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x134a5;
    eax = *((ebp + 8));
    eax >>= 1;
    edx = *((ebp + 0x10));
    edx >>= 1;
    edx <<= 3;
    edx += *((ebx + eax*4 - 0x138));
    ecx = *((ebp + 0x14));
    ecx = *((ebp + 0xc));
    ecx = *((edx + 4));
    edx = *(edx);
    eax = *((ebx + eax*4 - 0x124));
    unix_setsockopt_aux (ecx, eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065360 */
#include <stdint.h>
 
int32_t unix_setsockopt_aux (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t sockfd, int32_t arg_1ch) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_10h;
    int32_t var_bp_ch;
    int32_t level;
    int32_t optname;
    void * optval;
    socklen_t optlen;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x1359f;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *((ebp + 0x1c));
    if (eax != 2) {
        if (eax >= 2) {
            if (eax != 3) {
                goto label_0;
            }
            edx >>= 1;
            *((ebp - 0x10)) = edx;
            eax = 4;
        } else {
        } else {
            ecx = edx;
            ecx ^= 1;
            ecx &= 1;
            *((ebp - 0x10)) = ecx;
            eax = 8;
            if (ecx == 0) {
                goto label_1;
            }
            eax = *(edx);
            eax >>= 1;
            *((ebp - 0xc)) = eax;
            eax = 8;
            goto label_1;
        }
        *(fp_stack--) = *(edx);
        eax = *((ebp - 0x1a));
        ah = 0xc;
        *((ebp - 0x1c)) = ax;
        *((ebp - 0x20)) = fp_stack[0];
        eax = *((ebp - 0x20));
        *((ebp - 0x10)) = eax;
        *((ebp - 0x20)) = eax;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] -= fp_stack[1];
        fp_stack++;
        fp_stack[0] *= *((ebx - 0x2564));
        *((ebp - 0xc)) = fp_stack[0];
        fp_stack--;
        eax = 8;
        goto label_1;
label_0:
        eax = unix_error (0x16, esi, 0);
    }
label_1:
    eax = ebp - 0x10;
    eax = *((ebp + 0x14));
    eax = *((ebp + 0x10));
    eax = *((ebp + 0x18));
    eax >>= 1;
    eax = setsockopt (eax, eax, eax);
    if (eax == -1) {
        uerror (esi, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056720 */
#include <stdint.h>
 
int32_t loc_camlHashtbl_code_begin (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 8));
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0x10));
        eax = caml_apply2 (ecx, ecx, ebx);
        if (eax != 1) {
            eax = *((esp + 8));
            eax = *((eax + 0xc));
            *(eax) += 0xfffffffe;
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_code_begin ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            *((eax + 8)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068784 */
#include <stdint.h>
 
int32_t caml_set_allocation_policy (int32_t arg_8h) {
    eax = *((ebp + 8));
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
    } else {
        *(obj.fl_prev) = "hF\b\b";
        goto label_0;
    }
    *(obj.flp_size) = 0;
    *(obj.beyond) = 0;
label_0:
    *(obj.caml_allocation_policy) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ca90 */
#include <stdint.h>
 
int32_t camlUnix_send_1570 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ebx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ebx + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = unix_send;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.send";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c310 */
#include <stdint.h>
 
int32_t caml_int32_mul (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax *= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ad00 */
#include <stdint.h>
 
int32_t camlBuffer_add_string_1082 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 0xc)) = eax;
    edx = ebx;
    *(esp) = edx;
    ecx = *((edx - 4));
    ecx >>= 0xa;
    ebx = ecx*4 - 1;
    ecx = *((edx + ebx));
    ebx -= ecx;
    ebx = ebx + ebx + 1;
    *((esp + 4)) = ebx;
    ecx = *((eax + 4));
    edx = ecx + ebx - 1;
    *((esp + 8)) = edx;
    ecx = *((eax + 8));
    if (edx > ecx) {
        camlBuffer_resize_1066 ();
    }
    eax = *((esp + 0xc));
    edx = *((eax + 4));
    ecx = *(eax);
    ebx = 1;
    eax = *(esp);
    esi = *((esp + 4));
    camlString_blit_1056 ();
    ebx = *((esp + 8));
    eax = *((esp + 0xc));
    *((eax + 4)) = ebx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ab00 */
#include <stdint.h>
 
int32_t camlBuffer_resize_1066 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = eax;
    *((esp + 4)) = ecx;
    edx = *((ecx + 8));
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    eax = eax + 4;
    *((esp + 8)) = eax;
    *((eax - 4)) = 0x400;
    *(eax) = edx;
    do {
        esi = *(eax);
        edx = *((ecx + 4));
        edx = edx + ebx - 1;
        if (edx <= esi) {
            goto label_2;
        }
        edx = *(eax);
        edx >>= 1;
        edx = edx*4 + 1;
        *(eax) = edx;
    } while (1);
label_2:
    esi = .comment;
    edx = *(eax);
    if (edx > esi) {
        edx = .comment;
        ecx = *((ecx + 4));
        ebx = ecx + ebx - 1;
        if (ebx <= edx) {
            ebx = .comment;
            *(eax) = ebx;
        } else {
            eax = "Buffer.add: cannot grow buffer";
            camlPervasives_failwith_1010 ();
        }
    }
    eax = *((esp + 8));
    eax = caml_create_string;
    eax = caml_c_call (*(eax));
    ecx = eax;
    eax = *((esp + 4));
    esi = *((eax + 4));
    edx = 1;
    ebx = 1;
    eax = *(eax);
    camlString_blit_1056 (ecx);
    eax = *(esp);
    ebx = *((esp + 8));
    caml_modify (ebx, eax);
    eax = *((esp + 8));
    eax = *(eax);
    *((ebx + 8)) = eax;
    eax = 1;
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bde1 */
#include <stdint.h>
 
int32_t caml_int64_of_nativeint (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = eax;
    edx >>= 0x1f;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065cda */
#include <stdint.h>
 
int32_t unix_tcdrain (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12c26;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcdrain ();
    if (eax == -1) {
        eax = ebx - 0x232f;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a124 */
#include <stdint.h>
 
void tcdrain (void) {
    tcdrain ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069f24 */
#include <stdint.h>
 
int32_t caml_free_for_heap (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax - 0x10));
    free (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066190 */
#include <stdint.h>
 
uint32_t unix_times (void) {
    int32_t var_60h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x12768;
    eax = caml_alloc_small (8, 0xfe);
    esi = eax;
    edi = ebp - 0x60;
    *((esp + 4)) = edi;
    *(esp) = 0;
    getrusage ();
    *(fp_stack--) = *((ebp - 0x60));
    *(fp_stack--) = *((ebp - 0x5c));
    eax = ebx - 0x221c;
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(esi) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x58));
    *(fp_stack--) = *((ebp - 0x54));
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((esi + 8)) = fp_stack[0];
    fp_stack--;
    *((esp + 4)) = edi;
    *(esp) = 0xffffffff;
    getrusage ();
    *(fp_stack--) = *((ebp - 0x60));
    *(fp_stack--) = *((ebp - 0x5c));
    eax = ebx - 0x221c;
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((esi + 0x10)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x58));
    *(fp_stack--) = *((ebp - 0x54));
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((esi + 0x18)) = fp_stack[0];
    fp_stack--;
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a154 */
#include <stdint.h>
 
void getrusage (void) {
    getrusage ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062460 */
#include <stdint.h>
 
int32_t unix_getaddrinfo (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_138h;
    int32_t var_134h;
    void * s1;
    uint32_t var_12ch;
    int32_t var_124h;
    int32_t var_b4h;
    int32_t var_b0h;
    int32_t var_ach;
    int32_t var_a8h;
    int32_t var_a4h;
    int32_t var_a0h;
    int32_t var_94h;
    int32_t var_90h;
    int32_t var_8ch;
    int32_t var_88h;
    int32_t var_84h;
    int32_t var_80h;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_64h;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    char * src;
    size_t n;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x1649b;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x138)) = edx;
    *((ebp - 0x38)) = edx;
    edx = ebp - 0x38;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 3;
    ecx = ebp + 8;
    *((ebp - 0x2c)) = ecx;
    ecx = ebp + 0xc;
    *((ebp - 0x28)) = ecx;
    ecx = ebp + 0x10;
    *((ebp - 0x24)) = ecx;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x40)) = 0;
    *((ebp - 0x44)) = 0;
    *((ebp - 0x64)) = edx;
    edx = ebp - 0x64;
    *(eax) = edx;
    *((ebp - 0x5c)) = 1;
    *((ebp - 0x60)) = 3;
    eax = ebp - 0x3c;
    *((ebp - 0x58)) = eax;
    eax = ebp - 0x40;
    *((ebp - 0x54)) = eax;
    eax = ebp - 0x44;
    *((ebp - 0x50)) = eax;
    eax = *((ebp + 8));
    eax = caml_string_length (eax);
    esi = 0;
    if (eax != 0) {
        eax++;
        eax = caml_stat_alloc (eax);
        esi = eax;
        eax = *((ebp + 8));
        strcpy (esi, eax);
    }
    eax = *((ebp + 0xc));
    eax = caml_string_length (eax);
    edi = 0;
    if (eax != 0) {
        eax++;
        eax = caml_stat_alloc (eax);
        edi = eax;
        eax = *((ebp + 0xc));
        strcpy (edi, eax);
    }
    ecx = ebp - 0x84;
    edx = 0;
    eax = 0;
    do {
        *((ecx + eax)) = edx;
        eax += 4;
    } while (eax < 0x20);
    *((ebp - 0x80)) = 0;
    eax = *((ebp + 0x10));
    if ((al & 1) != 0) {
        goto label_0;
    }
    ecx = *((ebx - 0x1c));
    do {
        eax = *(eax);
        *((ebp - 0x40)) = eax;
        if ((al & 1) == 0) {
            edx = *((eax - 4));
            if (dl != 1) {
                if (dl >= 1) {
                    if (dl != 2) {
                        goto label_1;
                    }
                    eax = *(eax);
                    eax >>= 1;
                    edx = *((ebx - 0x20));
                    eax = *((edx + eax*4));
                    *((ebp - 0x80)) = eax;
                } else {
                } else {
                    eax = *(eax);
                    eax >>= 1;
                    eax = *((ecx + eax*4));
                    *((ebp - 0x7c)) = eax;
                    goto label_1;
                }
            }
            eax = *(eax);
            eax >>= 1;
            *((ebp - 0x78)) = eax;
        } else {
            eax >>= 1;
            if (eax != 1) {
                if (eax != 2) {
                    if (eax != 0) {
                        goto label_1;
                    }
                    *((ebp - 0x84)) |= 4;
                    *((ebp - 0x84)) |= 2;
                } else {
                } else {
                    *((ebp - 0x84)) |= 1;
                }
            }
        }
label_1:
        eax = *((ebp + 0x10));
        eax = *((eax + 4));
        *((ebp + 0x10)) = eax;
    } while ((al & 1) == 0);
label_0:
    caml_enter_blocking_section ();
    eax = ebp - 0x88;
    *((esp + 0xc)) = eax;
    eax = ebp - 0x84;
    *((esp + 8)) = eax;
    *((esp + 4)) = edi;
    *(esp) = esi;
    eax = getaddrinfo ();
    *((ebp - 0x12c)) = eax;
    caml_leave_blocking_section ();
    if (esi != 0) {
        caml_stat_free (esi);
    }
    if (edi != 0) {
        caml_stat_free (edi);
    }
    *((ebp - 0x3c)) = 1;
    if (*((ebp - 0x12c)) != 0) {
        goto label_2;
    }
    esi = *((ebp - 0x88));
    if (esi == 0) {
        goto label_3;
    }
    ecx = ebp - 0xb4;
    *((ebp - 0x134)) = ecx;
    do {
        eax = *((ebx - 0x18));
        eax = *(eax);
        *((ebp - 0x12c)) = eax;
        *((ebp - 0x8c)) = 0;
        *((ebp - 0x90)) = 0;
        *((ebp - 0x94)) = 0;
        *((ebp - 0xb4)) = eax;
        ecx = *((ebp - 0x134));
        edx = *((ebx - 0x18));
        *(edx) = ecx;
        *((ebp - 0xac)) = 1;
        *((ebp - 0xb0)) = 3;
        eax = ebp - 0x8c;
        *((ebp - 0xa8)) = eax;
        eax = ebp - 0x90;
        *((ebp - 0xa4)) = eax;
        eax = ebp - 0x94;
        *((ebp - 0xa0)) = eax;
        eax = *((esi + 0x10));
        edi = 0x70;
        if (eax <= 0x70) {
            edi = eax;
        }
        eax = ebp - 0x124;
        *((ebp - 0x130)) = eax;
        eax = *((esi + 0x14));
        edx = *((ebp - 0x130));
        memcpy (edx, eax, edi);
        ecx = *((ebp - 0x130));
        eax = alloc_sockaddr (ecx, edi, 0xffffffff);
        *((ebp - 0x90)) = eax;
        eax = *((esi + 0x18));
        edx = ebx - 0x14c4;
        if (eax == 0) {
            eax = edx;
        }
        eax = caml_copy_string (eax);
        *((ebp - 0x94)) = eax;
        eax = caml_alloc_small (5, 0);
        edi = eax;
        *((ebp - 0x8c)) = eax;
        eax = *((ebx - 0x20));
        eax = *((esi + 4));
        eax = cst_to_constr (0, eax, 3);
        *(edi) = eax;
        edi = *((ebp - 0x8c));
        edi += 4;
        edx = *((ebx - 0x1c));
        eax = *((esi + 8));
        eax = cst_to_constr (0, edx, 4);
        *(edi) = eax;
        eax = *((esi + 0xc));
        edx = eax + eax + 1;
        eax = *((ebp - 0x8c));
        *((eax + 8)) = edx;
        edx = *((ebp - 0x90));
        eax = *((ebp - 0x8c));
        *((eax + 0xc)) = edx;
        edx = *((ebp - 0x94));
        eax = *((ebp - 0x8c));
        *((eax + 0x10)) = edx;
        eax = *((ebx - 0x18));
        ecx = *((ebp - 0x12c));
        *(eax) = ecx;
        eax = *((ebp - 0x8c));
        *((ebp - 0x44)) = eax;
        eax = caml_alloc_small (2, 0);
        *((ebp - 0x40)) = eax;
        edx = *((ebp - 0x44));
        *(eax) = edx;
        edx = *((ebp - 0x3c));
        eax = *((ebp - 0x40));
        *((eax + 4)) = edx;
        eax = *((ebp - 0x40));
        *((ebp - 0x3c)) = eax;
        esi = *((esi + 0x1c));
    } while (esi != 0);
label_3:
    eax = *((ebp - 0x88));
    *(esp) = eax;
    freeaddrinfo ();
label_2:
    eax = *((ebx - 0x18));
    edx = *((ebp - 0x138));
    *(eax) = edx;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061bf8 */
#include <stdint.h>
 
int32_t unix_chmod (char * path, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t mode;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16d03;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = chmod (esi, eax);
    if (eax == -1) {
        eax = ebx - 0x25f7;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a104 */
#include <stdint.h>
 
void chmod (void) {
    chmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ed20 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_lookup_key_1358 (void) {
    do {
        ecx = eax;
        edx = *((ebx + 0x14));
        eax = *(ecx);
        if (eax == edx) {
            edx = *((ebx + 8));
            ecx = *((ecx + 4));
            esi = *((ebx + 0x10));
            eax = *((ebx + 0xc));
            eax += 0xfffffffe;
            ebx = esi;
            void (*0x80605f0)() ();
        }
        eax = *((ecx + 8));
        if (eax == 1) {
            goto label_0;
        }
        eax = *((ecx + 8));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0xc00;
            eax = *((ebx + 0x14));
            *(esi) = eax;
            *((esi + 4)) = 1;
            *((esi + 8)) = 1;
            ecx += 8;
            caml_modify (ecx, esi);
            ecx = *((ebx + 0x10));
            eax = *((ebx + 0xc));
            eax += 0xfffffffe;
            ebx = ecx;
            ecx = esi;
            void (*0x8060510)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80681ea */
#include <stdint.h>
 
int32_t caml_ext_table_add (int32_t arg_8h, char * arg_ch) {
    int32_t var_4h;
    ebx = *((ebp + 8));
    eax = *((ebx + 4));
    if (*(ebx) >= eax) {
        edx = eax + eax;
        *((ebx + 4)) = edx;
        eax <<= 3;
        eax = *((ebx + 8));
        eax = caml_stat_resize (eax, eax);
        *((ebx + 8)) = eax;
    }
    eax = *(ebx);
    edx = *((ebx + 8));
    ecx = *((ebp + 0xc));
    *((edx + eax*4)) = ecx;
    *(ebx)++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069eee */
#include <stdint.h>
 
int32_t caml_stat_resize (void * ptr, int32_t arg_ch) {
    size_t size;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = realloc (eax, eax);
    if (eax == 0) {
        caml_raise_out_of_memory ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049f24 */
#include <stdint.h>
 
void realloc (void) {
    realloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ba17 */
#include <stdint.h>
 
int32_t caml_nativeint_of_float (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_ah;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0xa));
    ah = 0xc;
    *((ebp - 0xc)) = ax;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_nativeint ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b600 */
#include <stdint.h>
 
int32_t camlPrintf_cont_t_1363 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = eax;
    *((esp + 4)) = ecx;
    *((esp + 8)) = edx;
    eax = *((edx + 0x2c));
    if (eax != 1) {
        eax = 1;
        ecx = *(ebx);
        eax = void (*ecx)() ();
        ebx = eax;
        eax = *((esp + 8));
        ecx = *((eax + 0x34));
        eax = *((eax + 0x3c));
        caml_apply2 ();
    } else {
        eax = *((edx + 0x3c));
        ecx = *(ebx);
        void (*ecx)() ();
    }
    ecx = *((esp + 8));
    ecx += 0xffffffd0;
    eax = *(esp);
    ebx = *((esp + 4));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c0a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2620 (void) {
    eax = unix_getlogin;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066ebb */
#include <stdint.h>
 
int32_t caml_raise_with_args (void) {
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_4h;
    esi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    eax = caml_local_roots;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x48)) = eax;
    eax = ebp - 0x48;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x40)) = esi;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x3c)) = ebx;
    eax = esi + 1;
    caml_alloc_small (ebx, esi);
    edx = *((ebp + 8));
    *(eax) = edx;
    if (esi <= 0) {
        goto label_0;
    }
    edx = 0;
    do {
        ecx = *((ebx + edx*4));
        *((eax + edx*4 + 4)) = ecx;
        edx++;
    } while (edx != esi);
label_0:
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063703 */
#include <stdint.h>
 
int32_t unix_gmtime (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_1ah;
    time_t * timer;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x151fd;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0xc)) = fp_stack[0];
    fp_stack--;
    eax = ebp - 0xc;
    eax = gmtime (eax);
    if (eax == 0) {
        eax = ebx - 0x2543;
        unix_error (0x16, eax, 0);
    }
    alloc_tm ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a764 */
#include <stdint.h>
 
void gmtime (void) {
    gmtime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071281 */
#include <stdint.h>
 
uint32_t caml_sys_open (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    char * src;
    int32_t var_8h;
    edi = caml_local_roots;
    *((ebp - 0x38)) = edi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 3;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = *((ebp + 8));
    eax = caml_string_length (ebx, esi, edi);
    eax++;
    eax = caml_stat_alloc (eax);
    ebx = eax;
    eax = *((ebp + 8));
    strcpy (ebx, eax);
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, 0x8084700);
    esi = eax;
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebp - 0x3c)) = eax;
    caml_enter_blocking_section ();
    eax = *((ebp - 0x3c));
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = open64 ();
    esi = eax;
    if (eax != -1) {
        *((esp + 8)) = 1;
        *((esp + 4)) = 2;
        *(esp) = eax;
        fcntl ();
        caml_leave_blocking_section ();
        caml_stat_free (ebx);
    } else {
        caml_leave_blocking_section ();
        caml_stat_free (ebx);
        eax = *((ebp + 8));
        caml_sys_error (eax);
    }
    *(obj.caml_local_roots) = edi;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80569d0 */
#include <stdint.h>
 
int32_t camlHashtbl_insert_bucket_1068 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        edx = *((eax + 8));
        ecx = *((eax + 4));
        ecx = *(eax);
        eax = edx;
        camlHashtbl_insert_bucket_1068 (ebx, ecx, ecx);
    } while (1);
    eax = *(esp);
    ebx = *((eax + 0xc));
    ebx >>= 1;
    if (ebx != 0) {
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 8));
        eax = void (*ecx)(uint32_t) (ebx);
        eax >>= 1;
        ecx = *((esp + 0xc));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    ebx = *(esp);
    ecx = *((ebx + 0x10));
    eax = *((ecx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_1;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            esi = *((esp + 8));
            *(eax) = esi;
            esi = *((esp + 4));
            *((eax + 4)) = esi;
            esi = *((ebx + 0x10));
            ebx = *((esi - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_2;
            }
            ebx = *((esi + edx*2 - 2));
            *((eax + 8)) = ebx;
            caml_modify (ecx + edx*2 - 2, eax);
            eax = 1;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_ml_array_bound_error ();
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054fd0 */
#include <stdint.h>
 
int32_t camlList_partition_1212 (void) {
    esi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x80538e0;
            *((edx + 0xc)) = esi;
            ebx = 1;
            eax = 1;
            void (*0x80538e0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804afb0 */
#include <stdint.h>
 
int32_t caml_curry6_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c510 */
#include <stdint.h>
 
int32_t camlUnix_fun_2750 (void) {
    eax = caml_ml_open_descriptor_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b95a */
#include <stdint.h>
 
int32_t caml_int64_float_of_bits (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052830 */
#include <stdint.h>
 
int32_t camlArray_map_1105 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ecx = eax;
    eax = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    if (eax == 1) {
        eax = loc.camlArray__24;
        return eax;
    }
    *(esp) = eax;
    *((esp + 4)) = ebx;
    *((esp + 8)) = ecx;
    eax = *((ebx - 4));
    if (eax != 0xfe) {
        eax = *(ebx);
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(eax) = fp_stack[0];
        fp_stack--;
    }
    edx = *(ecx);
    ebx = ecx;
    eax = void (*edx)() ();
    eax = *((esp + 4));
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    esi = eax;
    ebx = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ebx > eax) {
        goto label_3;
    }
    *((esp + 0xc)) = eax;
    *((esp + 0x10)) = ebx;
    *(esp) = esi;
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            eax = *((ecx + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 8));
        ecx = *(ebx);
        eax = void (*ecx)() ();
        esi = *(esp);
        ebx = *((esi - 4));
        if (ebx != 0xfe) {
            ebx = *((esp + 0x14));
            eax = caml_modify (esi + ebx*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            ebx = *((esp + 0x10));
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebx;
        ebx += 2;
        *((esp + 0x10)) = ebx;
        eax = *((esp + 0xc));
    } while (ecx != eax);
label_3:
    eax = esi;
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060a30 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_app_const_env_1424 (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x18f7;
            *(eax) = sym.camlCamlinternalOO__fun_1822;
            *((eax + 4)) = 3;
            *((eax + 8)) = esi;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            *((eax + 0x14)) = edx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ff80 */
#include <stdint.h>
 
int32_t camlPervasives_input_line_1241 (void) {
    edx = eax;
    ebx = loc.camlPervasives__86;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x804f580;
            *((ecx + 0xc)) = edx;
            *((ecx + 0x10)) = ebx;
            ebx = 1;
            eax = 1;
            void (*0x804f580)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b100 */
#include <stdint.h>
 
int32_t caml_curry5 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069e60 */
#include <stdint.h>
 
int32_t caml_page_table_initialize (void) {
    eax = 0;
    edx = caml_page_table;
    do {
        *((edx + eax*4)) = obj.caml_page_table_empty;
        eax++;
    } while (eax != 0x200);
    ax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c0e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2628 (void) {
    eax = unix_setgid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067dee */
#include <stdint.h>
 
uint32_t caml_install_signal_handler (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    eax = ebp - 0x3c;
    *((ebp - 0x50)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = caml_convert_signal_number (ebx, esi, edi);
    esi = eax;
    if (eax > 0x40) {
        eax = caml_invalid_argument (0x8076868);
    }
    ecx = *((ebp + 0xc));
    edi = ecx - 1;
    edx = 2;
    if (edi <= 2) {
        edx = *((ecx*4 + 0x80768f0));
    }
    eax = caml_set_signal_action (eax, edx);
    if (eax != 1) {
        if (eax != 2) {
            if (eax == 0) {
                *((ebp - 0x3c)) = 1;
            } else {
                *((ebp - 0x3c)) = 3;
            } else {
            }
            eax = caml_alloc_small (1, 0);
            *((ebp - 0x3c)) = eax;
            edx = caml_signal_handlers;
            edx = *((edx + esi*4));
            *(eax) = edx;
        } else {
        }
        caml_sys_error (1);
    }
    if ((*((ebp + 0xc)) & 1) == 0) {
        if (*(obj.caml_signal_handlers) == 0) {
            eax = caml_alloc (0x41, 0);
            *(obj.caml_signal_handlers) = eax;
            caml_register_global_root (obj.caml_signal_handlers);
        }
        eax = *((ebp + 0xc));
        eax = *(eax);
        esi <<= 2;
        esi += *(obj.caml_signal_handlers);
        caml_modify (esi, eax);
    }
    caml_process_pending_signals ();
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b130 */
#include <stdint.h>
 
int32_t caml_equal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80882e0) {
        eax = compare_free_stack ();
    }
    eax -= eax;
    eax &= 2;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806aff2 */
#include <stdint.h>
 
int32_t caml_greaterequal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80882e0) {
        compare_free_stack ();
    }
    eax = ebx;
    eax >>= 0x1f;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b0b0 */
#include <stdint.h>
 
int32_t caml_curry6_5 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *(esp) = eax;
    eax = *((ebx + 0xc));
    ecx = *((eax + 0xc));
    edi = *((ecx + 0xc));
    ebp = *((edi + 0xc));
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    ebx = *((ebx + 8));
    *((esp + 0xc)) = ebx;
    esi = *((eax + 8));
    ecx = *((ecx + 8));
    ebx = *((edi + 8));
    eax = *((ebp + 8));
    edx = *((edx + 8));
    *((esp + 8)) = edx;
    edx = esi;
    esi = *((esp + 0xc));
    edi = *(esp);
    ebp = *((esp + 4));
    *(loc.caml_extra_params) = ebp;
    ebp = *((esp + 8));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cae0 */
#include <stdint.h>
 
int32_t camlUnix_sendto_1576 (void) {
    int32_t var_14h;
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        *(esp) = eax;
        eax = *((ebx - 4));
        eax >>= 0xa;
        ebp = eax*4 - 1;
        eax = *((ebx + ebp));
        ebp -= eax;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = *((esp + 0x14));
        eax = unix_sendto_native;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.sendto";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c410 */
#include <stdint.h>
 
int32_t camlUnix_fun_2720 (void) {
    eax = unix_fchmod;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bc64 */
#include <stdint.h>
 
int32_t caml_int64_of_string (int32_t arg_8h) {
    int32_t var_60h;
    uint32_t var_5ch;
    int32_t var_50h;
    int32_t var_4ch;
    uint32_t var_3ch;
    int32_t var_38h;
    uint32_t var_34h;
    uint32_t var_30h;
    uint32_t var_2ch;
    uint32_t var_20h;
    uint32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = ebp - 0x1c;
    edx = ebp - 0x20;
    eax = *((ebp + 8));
    eax = parse_sign_and_base (ebx, esi, edi);
    edi = eax;
    eax = *((ebp - 0x20));
    *((ebp - 0x38)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((ebp - 0x30)) = eax;
    *((ebp - 0x2c)) = edx;
    eax = _udivdi3 (edx, 0xffffffff, eax);
    *((ebp - 0x3c)) = eax;
    *((ebp - 0x34)) = edx;
    eax = *(edi);
    eax = parse_digit ();
    ebx = eax;
    if (eax >= 0) {
        if (*((ebp - 0x38)) > eax) {
            goto label_0;
        }
    }
    eax = caml_failwith ("int_of_string");
label_0:
    esi = eax;
    esi >>= 0x1f;
    edi++;
    do {
        eax = *(edi);
        if (al != 0x5f) {
            eax = (int32_t) al;
            eax = parse_digit ();
            *((ebp - 0x4c)) = eax;
            if (eax < 0) {
                goto label_1;
            }
            if (*((ebp - 0x38)) <= eax) {
                goto label_1;
            }
            if (esi >= *((ebp - 0x34))) {
                if (esi <= *((ebp - 0x34))) {
                    if (ebx <= *((ebp - 0x3c))) {
                        goto label_2;
                    }
                }
                caml_failwith ("int_of_string");
            }
label_2:
            edx = *((ebp - 0x30));
            edx *= esi;
            ecx = *((ebp - 0x2c));
            ecx *= ebx;
            edx += ecx;
            *((ebp - 0x50)) = edx;
            eax = *((ebp - 0x30));
            edx:eax = eax * ebx;
            ebx = eax;
            esi = edx;
            esi += *((ebp - 0x50));
            eax = *((ebp - 0x4c));
            edx = *((ebp - 0x4c));
            edx >>= 0x1f;
            *((ebp - 0x60)) = eax;
            *((ebp - 0x5c)) = edx;
            ebx += eax;
            esi += edx;
            if (edx < esi) {
                goto label_3;
            }
            if (*((ebp - 0x5c)) <= esi) {
                if (eax <= ebx) {
                    goto label_3;
                }
            }
            caml_failwith ("int_of_string");
        }
label_3:
        edi++;
    } while (1);
label_1:
    *((ebp - 0x30)) = ebx;
    *((ebp - 0x2c)) = esi;
    edx = *((ebp + 8));
    eax = caml_string_length (edx);
    eax += *((ebp + 8));
    if (edi != eax) {
        caml_failwith ("int_of_string");
    }
    if (*((ebp - 0x20)) == 0xa) {
        eax = 0xffffffff;
        edx = 0x7fffffff;
        if (*((ebp - 0x1c)) < 0) {
            eax = 0;
            edx = 0x80000000;
        }
        if (edx > *((ebp - 0x2c))) {
            goto label_4;
        }
        if (edx >= *((ebp - 0x2c))) {
            if (eax >= *((ebp - 0x30))) {
                goto label_4;
            }
        }
        caml_failwith ("int_of_string");
    }
label_4:
    if (*((ebp - 0x1c)) < 0) {
        ebx = *((ebp - 0x30));
        esi = *((ebp - 0x2c));
        ebx = -ebx;
        esi += 0;
        esi = -esi;
    }
    caml_copy_int64 (ebx, esi);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e530 */
#include <stdint.h>
 
int32_t camlPrintf_bprintf_1400 (void) {
    ebx = eax;
    eax = loc.camlPrintf__41;
    return camlPrintf_kbprintf_1397 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c0c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2624 (void) {
    eax = unix_setgroups;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806358d */
#include <stdint.h>
 
int32_t unix_mktime (int32_t arg_8h) {
    int32_t var_6ch;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    tm * timeptr;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15372;
    eax = *((ebp + 8));
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 1;
    edx = *((ebx - 0x18));
    ecx = *(edx);
    *((ebp - 0x5c)) = ecx;
    ecx = ebp - 0x5c;
    *(edx) = ecx;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 2;
    edx = ebp - 0x38;
    *((ebp - 0x50)) = edx;
    edx = ebp - 0x3c;
    *((ebp - 0x4c)) = edx;
    edx = *(eax);
    edx >>= 1;
    *((ebp - 0x34)) = edx;
    edx = *((eax + 4));
    edx >>= 1;
    *((ebp - 0x30)) = edx;
    edx = *((eax + 8));
    edx >>= 1;
    *((ebp - 0x2c)) = edx;
    edx = *((eax + 0xc));
    edx >>= 1;
    *((ebp - 0x28)) = edx;
    edx = *((eax + 0x10));
    edx >>= 1;
    *((ebp - 0x24)) = edx;
    edx = *((eax + 0x14));
    edx >>= 1;
    *((ebp - 0x20)) = edx;
    edx = *((eax + 0x18));
    edx >>= 1;
    *((ebp - 0x1c)) = edx;
    eax = *((eax + 0x1c));
    eax >>= 1;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = 0xffffffff;
    eax = ebp - 0x34;
    eax = mktime (eax);
    esi = eax;
    if (eax == -1) {
        eax = ebx - 0x2554;
        unix_error (0x22, eax, 0);
    }
    eax = ebp - 0x34;
    eax = alloc_tm ();
    *((ebp - 0x38)) = eax;
    *((ebp - 0x6c)) = esi;
    *(fp_stack--) = *((ebp - 0x6c));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x3c)) = eax;
    caml_alloc_small (2, 0);
    edx = *((ebp - 0x3c));
    *(eax) = edx;
    edx = *((ebp - 0x38));
    *((eax + 4)) = edx;
    ecx = *((ebp - 0x5c));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a344 */
#include <stdint.h>
 
void mktime (void) {
    mktime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061c4c */
#include <stdint.h>
 
int32_t unix_chown (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16caf;
    esi = *((ebp + 8));
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = chown ();
    if (eax == -1) {
        eax = ebx - 0x25f0;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a5e4 */
#include <stdint.h>
 
void chown (void) {
    chown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805c330 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1584 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = ebx;
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = edx;
    *((esp + 4)) = esi;
    *(esp) = edi;
    eax = caml_make_vect;
    eax = caml_c_call (0xb);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0x14));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0x14));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 0x10));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 0x10));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 0xc));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 7) {
            goto label_6;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 0xc;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 7) {
            goto label_7;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 0x18)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 9) {
            goto label_8;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 0x10;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 9) {
            goto label_9;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x20)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b5d0)() ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062de8 */
#include <stdint.h>
 
uint32_t unix_getlogin (void) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15b18;
    eax = getlogin ();
    if (eax == 0) {
        eax = ebx - 0x2588;
        eax = unix_error (2, eax, 0);
    }
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a064 */
#include <stdint.h>
 
void getlogin (void) {
    getlogin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054e00 */
#include <stdint.h>
 
int32_t camlList_remove_assoc_1189 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 8)) = ecx;
        ebx = *(ebx);
        *((esp + 4)) = ebx;
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 8));
        eax = camlList_remove_assoc_1189 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 4));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806dc31 */
#include <stdint.h>
 
int32_t caml_ml_channel_size_64 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_channel_size (eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c450 */
#include <stdint.h>
 
int32_t camlUnix_fun_2728 (void) {
    eax = unix_unlink;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806994b */
#include <stdint.h>
 
int32_t caml_oldify_mopup (void) {
    uint32_t var_1ch;
    int32_t var_4h;
    goto label_1;
label_0:
    ebx = *(edi);
    esi = ebx + 4;
    eax = *(esi);
    *(obj.oldify_todo_list) = eax;
    eax = *(ebx);
    if ((al & 1) == 0) {
        if (eax >= *(obj.caml_young_end)) {
            goto label_2;
        }
        if (eax <= *(obj.caml_young_start)) {
            goto label_2;
        }
        caml_oldify_one (eax, ebx);
    }
label_2:
    ebx -= 4;
    eax = *(ebx);
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_1;
    }
    *((ebp - 0x1c)) = 1;
    do {
        edx = *((ebp - 0x1c));
        eax = *((edi + edx*4));
        if ((al & 1) == 0) {
            if (eax < *(obj.caml_young_end)) {
                if (eax <= *(obj.caml_young_start)) {
                    goto label_3;
                }
                eax = caml_oldify_one (eax, esi);
            }
        } else {
label_3:
            *(esi) = eax;
        }
        *((ebp - 0x1c))++;
        esi += 4;
        eax = *(ebx);
        eax >>= 0xa;
    } while (eax > *((ebp - 0x1c)));
label_1:
    edi = oldify_todo_list;
    if (edi != 0) {
        goto label_0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fd20 */
#include <stdint.h>
 
int32_t camlPervasives_output_value_1202 (void) {
    eax = caml_output_value;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80733c9 */
#include <stdint.h>
 
uint32_t caml_lazy_make_forward (int32_t arg_8h) {
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0x28)) = ebx;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x2c)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    eax = caml_alloc_small (ebx, esi);
    *((ebp - 0x2c)) = eax;
    esi = *(eax);
    edx = *((ebp + 8));
    *(eax) = edx;
    eax = *((ebp - 0x2c));
    edx = *((ebp - 0x2c));
    edx >>= 0x17;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) != 0) {
        if (*(obj.caml_gc_phase) == 0) {
            caml_darken (esi, 0);
        }
        eax = *((ebp + 8));
        if ((al & 1) != 0) {
            goto label_0;
        }
        edx = caml_young_end;
        if (eax >= edx) {
            goto label_0;
        }
        ecx = caml_young_start;
        if (eax <= ecx) {
            goto label_0;
        }
        if ((esi & 1) == 0) {
            if (edx <= esi) {
                goto label_1;
            }
            if (ecx < esi) {
                goto label_0;
            }
        }
label_1:
        eax = .comment;
        if (eax >= *(0x8087aac)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x8087aa8;
        edx = *(eax);
        ecx = *((ebp - 0x2c));
        *(edx) = ecx;
        edx += 4;
        *(eax) = edx;
    }
label_0:
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056280 */
#include <stdint.h>
 
uint32_t camlString_contains_from_1132 (void) {
    esi = ebx;
    edx = ecx;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx + 1;
    if (esi >= 1) {
        if (esi > ebx) {
            goto label_0;
        }
        eax = void (*0x80562d0)() ();
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 1;
            return eax;
        }
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        ecx = esi;
        camlString_index_rec_1108 (*(obj.caml_exception_pointer));
        eax = 3;
        return eax;
    }
label_0:
    eax = "String.contains_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805edf0 */
#include <stdint.h>
 
void camlCamlinternalOO_fun_1778 (void) {
    ecx = *((ebx + 8));
    ebx = *(eax);
    ebx = *((ebx + ecx*2 - 2));
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807120d */
#include <stdint.h>
 
uint32_t caml_sys_remove (char * path) {
    ebx = *((ebp + 8));
    eax = unlink (ebx);
    if (eax != 0) {
        caml_sys_error (ebx);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80548d0 */
#include <stdint.h>
 
int32_t camlList_rev_map2_1099 (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x80537b0;
            *((edx + 0xc)) = esi;
            eax = 1;
            void (*0x80537b0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cb40 */
#include <stdint.h>
 
int32_t caml_float_of_int (int32_t arg_8h) {
    int32_t var_ch;
    eax = *((ebp + 8));
    eax >>= 1;
    *((ebp - 0xc)) = eax;
    *(fp_stack--) = *((ebp - 0xc));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056220 */
#include <stdint.h>
 
void camlString_rindex_1125 (void) {
    ecx = ebx;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    edx = *((eax + ebx));
    ebx -= edx;
    ebx = ebx + ebx - 1;
    return camlString_rindex_rec_1121 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c921 */
#include <stdint.h>
 
int32_t caml_log10_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    log10 (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a594 */
#include <stdint.h>
 
void log10 (void) {
    log10 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80662e8 */
#include <stdint.h>
 
int32_t unix_umask (int32_t m) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12618;
    eax = *((ebp + 8));
    eax >>= 1;
    umask (eax);
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a304 */
#include <stdint.h>
 
void umask (void) {
    umask ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075384 */
#include <stdint.h>
 
int32_t caml_read_directory (int32_t arg_8h, int32_t arg_ch) {
    uint32_t var_1ch;
    char * src;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = opendir ();
    *((ebp - 0x1c)) = eax;
    eax = 0xffffffff;
    if (*((ebp - 0x1c)) == 0) {
        goto label_1;
    }
    esi = 0x807761d;
    do {
label_0:
        eax = *((ebp - 0x1c));
        *(esp) = eax;
        eax = readdir64 ();
        if (eax == 0) {
            goto label_2;
        }
        ebx = eax + 0x13;
        edi = ebx;
        edx = *(ebx);
        ecx = *(esi);
        if (edx != ecx) {
            goto label_3;
        }
        ecx = *((ebx + 1));
    } while (cl == *((esi + 1)));
label_3:
    ecx = 0x807761c;
    ecx = *(ecx);
    if (edx != ecx) {
        goto label_4;
    }
    edx = *((edi + 1));
    if (dl != *(0x807761d)) {
        goto label_4;
    }
    edx = *((edi + 2));
    if (dl == *(0x807761e)) {
        goto label_0;
    }
label_4:
    edi = eax + 0x13;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = caml_stat_alloc (ecx);
    edi = eax;
    strcpy (eax, ebx);
    eax = *((ebp + 0xc));
    caml_ext_table_add (eax, edi);
    goto label_0;
label_2:
    ecx = *((ebp - 0x1c));
    *(esp) = ecx;
    closedir ();
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805aee0 */
#include <stdint.h>
 
int32_t camlBuffer_advance_to_non_alpha_1108 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x805a6e0;
            *((ecx + 0xc)) = edx;
            eax = *((edx - 4));
            eax >>= 0xa;
            eax = eax*4 - 1;
            edx = *((edx + eax));
            eax -= edx;
            edx = eax + eax + 1;
            eax = ebx;
            ebx = edx;
            void (*0x805a6e0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c430 */
#include <stdint.h>
 
int32_t camlUnix_fun_2724 (void) {
    eax = unix_link;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d530 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1684 (void) {
    eax = loc.camlPrintf__54;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063cf6 */
#include <stdint.h>
 
int32_t unix_lseek (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14c02;
    caml_enter_blocking_section ();
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x24f8));
    *((esp + 0xc)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((esp + 8)) = edx;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = lseek64 ();
    edi = eax;
    esi = edx;
    caml_leave_blocking_section ();
    eax = edi;
    eax &= esi;
    if (eax == -1) {
        eax = ebx - 0x24fe;
        uerror (eax, 0);
    }
    if (esi >= 0) {
        if (esi <= 0) {
            if (edi <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = ebx - 0x24fe;
        unix_error (0x4b, eax, 0);
    }
label_0:
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d5ed */
#include <stdint.h>
 
int32_t caml_array_get_addr (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    eax = *((edx + eax*4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b400 */
#include <stdint.h>
 
int32_t caml_tuplify3 (void) {
    edx = ebx;
    ecx = *((eax + 8));
    ebx = *((eax + 4));
    eax = *(eax);
    esi = *((edx + 8));
    return void (*esi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d3e0 */
#include <stdint.h>
 
int32_t camlPrintf_pr_1354 (void) {
    *(esp) = eax;
    edi = ecx;
    eax = *((edi - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((edi + eax));
    eax -= ecx;
    ebp = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x88;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x84f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x805b6f0;
            *((ecx + 0xc)) = 0x10f9;
            *((ecx + 0x10)) = 0x804b300;
            *((ecx + 0x14)) = 7;
            *((ecx + 0x18)) = 0x805b6c0;
            *((ecx + 0x1c)) = 0x20f9;
            *((ecx + 0x20)) = 0x804b220;
            *((ecx + 0x24)) = 9;
            *((ecx + 0x28)) = 0x805b660;
            *((ecx + 0x2c)) = 0x30f9;
            *((ecx + 0x30)) = 0x804b300;
            *((ecx + 0x34)) = 7;
            *((ecx + 0x38)) = 0x805b600;
            *((ecx + 0x3c)) = 0x40f9;
            *((ecx + 0x40)) = 0x804b3a0;
            *((ecx + 0x44)) = 5;
            *((ecx + 0x48)) = 0x805b5d0;
            *((ecx + 0x4c)) = 0x50f9;
            *((ecx + 0x50)) = 0x804b300;
            *((ecx + 0x54)) = 7;
            *((ecx + 0x58)) = 0x805b540;
            eax = *((esi + 0xc));
            *((ecx + 0x5c)) = eax;
            eax = *((esi + 0x10));
            *((ecx + 0x60)) = eax;
            eax = *((esi + 0x14));
            *((ecx + 0x64)) = eax;
            eax = *((esi + 0x18));
            *((ecx + 0x68)) = eax;
            eax = *((esi + 0x1c));
            *((ecx + 0x6c)) = eax;
            *((ecx + 0x70)) = esi;
            eax = *(esp);
            *((ecx + 0x74)) = eax;
            *((ecx + 0x78)) = edi;
            *((ecx + 0x7c)) = edx;
            *((ecx + 0x80)) = ebp;
            edx = 1;
            eax = ebx;
            ebx = edx;
            void (*0x805b6f0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f7c0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1394 (void) {
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80545f0 */
#include <stdint.h>
 
int32_t camlList_nth_1042 (void) {
    if (ebx < 1) {
        eax = "List.nth";
        void (*0x804f900)() ();
    }
    ecx = loc.camlList__48;
    return camlList_nth_aux_1045 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058370 */
#include <stdint.h>
 
int32_t camlHashtbl_entry (void) {
    eax = loc.camlHashtbl__16;
    *(0x807ef8c) = eax;
    eax = loc.camlHashtbl__15;
    *(loc.camlHashtbl) = eax;
    eax = loc.camlHashtbl__14;
    *(0x807ef5c) = eax;
    eax = loc.camlHashtbl__13;
    *(0x807ef64) = eax;
    eax = loc.camlHashtbl__12;
    *(0x807ef84) = eax;
    eax = loc.camlHashtbl__11;
    *(0x807ef90) = eax;
    eax = loc.camlHashtbl__10;
    *(0x807ef60) = eax;
    eax = loc.camlHashtbl__9;
    *(0x807ef74) = eax;
    eax = loc.camlHashtbl__8;
    *(0x807ef94) = eax;
    eax = loc.camlHashtbl__7;
    *(0x807ef68) = eax;
    eax = loc.camlHashtbl__6;
    *(0x807ef6c) = eax;
    eax = loc.camlHashtbl__5;
    *(0x807ef78) = eax;
    eax = loc.camlHashtbl__4;
    *(0x807ef70) = eax;
    eax = loc.camlHashtbl__3;
    *(0x807ef7c) = eax;
    eax = loc.camlHashtbl__2;
    *(0x807ef80) = eax;
    eax = camlHashtbl__1;
    *(0x807ef88) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805db80 */
#include <stdint.h>
 
int32_t camlPrintf_iter_on_format_args_1137 (void) {
    edx = eax;
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    esi = *((edx + eax));
    eax -= esi;
    esi = eax + eax - 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x3c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x38f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x805bda0;
            *((eax + 0xc)) = 0x10f9;
            *((eax + 0x10)) = 0x804b3a0;
            *((eax + 0x14)) = 5;
            *((eax + 0x18)) = 0x805bb60;
            *((eax + 0x1c)) = 0x20f9;
            *((eax + 0x20)) = 0x805bae0;
            *((eax + 0x24)) = 3;
            *((eax + 0x28)) = edx;
            *((eax + 0x2c)) = ebx;
            *((eax + 0x30)) = ecx;
            *((eax + 0x34)) = esi;
            ebx = eax;
            ebx += 0x20;
            eax = 1;
            camlPrintf_scan_fmt_1144 ();
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805bae0 */
#include <stdint.h>
 
int32_t camlPrintf_scan_fmt_1144 (void) {
    do {
label_0:
        ecx = *((ebx + 0x14));
        if (eax >= ecx) {
            goto label_1;
        }
        esi = *((ebx + 8));
        edx = eax;
        edx >>= 1;
        ecx = *((esi - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edi = *((esi + ecx));
        ecx -= edi;
        if (ecx <= edx) {
            goto label_2;
        }
        ecx = *((esi + edx));
        ecx = ecx + ecx + 1;
        if (ecx != 0x4b) {
            goto label_3;
        }
        ecx = ebx;
        ecx += 0xffffffe0;
        ebx = eax;
        ebx += 2;
        eax = 1;
        eax = camlPrintf_scan_flags_1142 (ebx);
        ebx = *(esp);
    } while (1);
label_3:
    eax += 2;
    goto label_0;
label_1:
    return eax;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80576f0 */
#include <stdint.h>
 
int32_t camlHashtbl_clear_1054 (void) {
    edi = eax;
    ebx = 1;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 9;
    esi |= 1;
    esi += 0xfffffffe;
    if (ebx > esi) {
        goto label_0;
    }
    do {
        ecx = *((edi + 4));
        eax = *((ecx - 4));
        eax >>= 9;
        if (eax <= ebx) {
            goto label_1;
        }
        caml_modify (ecx + ebx*2 - 2, 1);
        eax = ebx;
        ebx += 2;
    } while (eax != esi);
label_0:
    *(edi) = 1;
    eax = 1;
    return eax;
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054670 */
#include <stdint.h>
 
int32_t camlList_flatten_1058 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 4));
        ebx = *(eax);
        eax = ecx;
        eax = camlList_flatten_1058 (ebx);
    } while (1);
    ebx = eax;
    eax = *(esp);
    void (*0x804fbc0)() ();
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bf40 */
#include <stdint.h>
 
int32_t camlUnix_fun_2580 (void) {
    eax = unix_getprotobynumber;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061cf0 */
#include <stdint.h>
 
int32_t unix_close (int32_t fildes) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16c10;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = close (eax);
    if (eax == -1) {
        eax = ebx - 0x262c;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a524 */
#include <stdint.h>
 
void close (void) {
    close ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059ed0 */
#include <stdint.h>
 
int32_t camlMap_equal_1328 (void) {
    int32_t var_4h;
    int32_t var_8h;
    esi = eax;
    *(esp) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x18f7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x8058a30;
            eax = *((edx + 0xc));
            *((ebx + 0xc)) = eax;
            eax = *((edx + 0x10));
            *((ebx + 0x10)) = eax;
            *((ebx + 0x14)) = esi;
            ebx = 1;
            eax = ecx;
            eax = camlMap_cons_enum_1304 (ebx);
            ebx = 1;
            eax = *(esp);
            camlMap_cons_enum_1304 (eax);
            ebx = *((esp + 4));
            ecx = *((esp + 8));
            void (*0x8058a30)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d361 */
#include <stdint.h>
 
int32_t caml_array_unsafe_set_addr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 0x10));
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    ebx <<= 2;
    ebx += *((ebp + 8));
    edi = *(ebx);
    *(ebx) = esi;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) != 0) {
        if (*(obj.caml_gc_phase) == 0) {
            caml_darken (edi, 0);
        }
        if ((esi & 1) != 0) {
            goto label_0;
        }
        eax = caml_young_end;
        if (esi >= eax) {
            goto label_0;
        }
        edx = caml_young_start;
        if (esi <= edx) {
            goto label_0;
        }
        if ((edi & 1) == 0) {
            if (eax <= edi) {
                goto label_1;
            }
            if (edx < edi) {
                goto label_0;
            }
        }
label_1:
        eax = .comment;
        if (eax >= *(0x8087aac)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x8087aa8;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_0:
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806de18 */
#include <stdint.h>
 
int32_t caml_input_scan_line (int32_t arg_8h) {
    void * s1;
    int32_t var_1ch;
    void * s2;
    size_t n;
    ebx = *((ebp + 8));
    esi = *((ebx + 0x10));
    edi = ebx + 0x34;
    *((ebp - 0x20)) = edi;
    *((ebp - 0x1c)) = edi;
    do {
        eax = *((ebx + 0x14));
        if (esi >= eax) {
            edx = *((ebx + 0x10));
            if (edx > edi) {
                eax -= edx;
                eax = *((ebp - 0x20));
                memmove (eax, edx, eax);
                eax = *((ebp - 0x1c));
                eax -= *((ebx + 0x10));
                edx = *((ebp - 0x1c));
                *((ebx + 0x10)) = edx;
                *((ebx + 0x14)) += eax;
                esi += eax;
            }
            edx = *((ebx + 0x14));
            eax = *((ebx + 0xc));
            if (edx >= eax) {
                eax = *((ebx + 0x10));
                eax -= edx;
                goto label_0;
            }
            eax -= edx;
            eax = *(ebx);
            eax = caml_do_read (eax, edx, eax);
            if (eax == 0) {
                eax = *((ebx + 0x10));
                eax -= *((ebx + 0x14));
                goto label_0;
            }
            ecx = eax;
            ecx >>= 0x1f;
            *((ebx + 4)) += eax;
            *((ebx + 8)) += ecx;
            *((ebx + 0x14)) += eax;
        }
        eax = *(esi);
        esi++;
    } while (al != 0xa);
    eax = esi;
    eax -= *((ebx + 0x10));
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f7e0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1398 (void) {
    eax = caml_ml_pos_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c1a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2650 (void) {
    eax = unix_alarm;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805bf40 */
#include <stdint.h>
 
int32_t camlPrintf_add_conv_1191 (void) {
    *(esp) = ebx;
    if (ecx != 0x53) {
        if (ecx == 0xfb) {
            goto label_0;
        }
        edx = *((edx + 0xc));
        ebx = ecx;
        ecx = edx;
        camlPrintf_incr_ac_1187 ();
    }
label_0:
    eax = *(esp);
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805eee0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1814 (void) {
    edx = ebx;
    ecx = *((edx + 8));
    ebx = *((edx + 0x10));
    edx = *((edx + 0xc));
    eax = *((eax + edx*2 - 2));
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80710bb */
#include <stdint.h>
 
uint32_t caml_sys_system_command (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = caml_local_roots;
    *((ebp - 0x38)) = edi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    caml_string_length (eax);
    esi = eax + 1;
    eax = caml_stat_alloc (esi);
    ebx = eax;
    eax = *((ebp + 8));
    memmove (ebx, eax, esi);
    caml_enter_blocking_section ();
    eax = system (ebx);
    esi = eax;
    caml_leave_blocking_section ();
    caml_stat_free (ebx);
    if (esi == -1) {
        eax = *((ebp + 8));
        caml_sys_error (eax);
    }
    eax = 0xff;
    if ((esi & 0x7f) == 0) {
        edx = esi;
        eax = (int32_t) dh;
    }
    *(obj.caml_local_roots) = edi;
    eax = eax + eax + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80642b8 */
#include <stdint.h>
 
int32_t unix_rename (char * oldpath, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    char * newpath;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14643;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax = rename (esi, eax);
    if (eax == -1) {
        eax = ebx - 0x24ab;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a054 */
#include <stdint.h>
 
void rename (void) {
    rename ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c1c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2654 (void) {
    eax = unix_localtime;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b5d0 */
#include <stdint.h>
 
int32_t camlPrintf_cont_f_1364 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ecx + 0x28));
    eax = *((ecx + 0x2c));
    ecx = *(ebx);
    void (*ecx)(uint32_t, uint32_t, uint32_t) (ecx, eax, ebx);
    ecx = *(esp);
    ecx += 0xffffffc0;
    eax = *((esp + 4));
    ebx = *((esp + 8));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80560d0 */
#include <stdint.h>
 
int32_t camlString_capitalize_1104 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_apply1_1100 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b720 */
#include <stdint.h>
 
uint32_t camlSource_toggle_init_1097 (void) {
    int32_t var_4h;
    ecx = *((ebx + 8));
    ebx = camlSource__7;
    eax = camlCamlinternalOO_new_methods_variables_1248 (eax);
    edx = *(eax);
    ecx = *((eax + 4));
    esi = *((eax + 8));
    *(esp) = esi;
label_0:
    eax = caml_young_ptr;
    eax -= 0x28;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    eax = eax + 4;
    *((eax - 4)) = 0xcf7;
    *(eax) = sym.camlSource__method_activate_1091;
    *((eax + 4)) = 3;
    *((eax + 8)) = esi;
    ebx = eax + 0x10;
    *((ebx - 4)) = 0x1400;
    *(ebx) = edx;
    *((ebx + 4)) = 3;
    *((ebx + 8)) = esi;
    *((ebx + 0xc)) = ecx;
    *((ebx + 0x10)) = eax;
    eax = *((esp + 4));
    camlCamlinternalOO_set_methods_1591 ();
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.caml_curry3;
            *((eax + 4)) = 7;
            *((eax + 8)) = 0x804b650;
            ebx = *(esp);
            *((eax + 0xc)) = ebx;
            ebx = *((esp + 4));
            *((eax + 0x10)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806667f */
#include <stdint.h>
 
uint32_t unix_waitpid (int32_t arg_8h, pid_t pid) {
    int32_t var_ch;
    int32_t wstatus;
    int32_t options;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x12280;
    eax = ebx + 0xbd04;
    eax = *((ebp + 8));
    eax = caml_convert_flag_list (eax, eax);
    esi = eax;
    caml_enter_blocking_section ();
    eax = ebp - 0xc;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = waitpid (eax, eax, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x21b6;
        uerror (eax, 0);
    }
    edx = *((ebp - 0xc));
    eax = esi;
    alloc_process_status ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a434 */
#include <stdint.h>
 
void waitpid (void) {
    waitpid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805a020 */
#include <stdint.h>
 
int32_t camlMap_bindings_1352 (void) {
    ebx = eax;
    eax = 1;
    return camlMap_bindings_aux_1346 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fdf0 */
#include <stdint.h>
 
int32_t camlPervasives_open_in_gen_1214 (void) {
    eax = caml_sys_open;
    eax = caml_c_call (ecx);
    eax = caml_ml_open_descriptor_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054720 */
#include <stdint.h>
 
int32_t camlList_rev_map_1067 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8053740;
            *((ecx + 0xc)) = edx;
            eax = 1;
            void (*0x8053740)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d600 */
#include <stdint.h>
 
void camlPrintf_to_string_1054 (void) {
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ecx = ebx + ebx + 1;
    ebx = 1;
    return camlString_sub_1046 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059980 */
#include <stdint.h>
 
uint32_t camlMap_split_1264 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    do {
label_0:
        if (ebx == 1) {
            goto label_3;
        }
        edx = *((ebx + 0xc));
        edx = *((ebx + 8));
        edx = *((ebx + 4));
        ebx = *(ebx);
        ebx = *((ecx + 0xc));
        ecx = *(ebx);
        ebx = edx;
        eax = caml_apply2 (eax, ecx);
        if (eax == 1) {
label_2:
            eax = caml_young_ptr;
            eax -= 0x18;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            ecx = eax + 4;
            *((ecx - 4)) = 0x400;
            eax = *((esp + 0x10));
            *(ecx) = eax;
            eax = ecx + 8;
            *((eax - 4)) = 0xc00;
            ebx = *((esp + 0x14));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            ebx = *((esp + 0x18));
            *((eax + 8)) = ebx;
            return eax;
        }
        if (eax >= 1) {
            goto label_5;
        }
        eax = *(esp);
        ebx = *((esp + 0x14));
        ecx = *((esp + 8));
        eax = camlMap_split_1264 ();
    } while (1);
    ecx = eax;
    ebx = *((ecx + 8));
    eax = *((ecx + 4));
    eax = *(ecx);
    eax = *((esp + 8));
    esi = *((eax + 0x10));
    eax = ebx;
    ebx = *((esp + 0xc));
    ecx = *((esp + 0x10));
    edx = *((esp + 0x18));
    eax = camlMap_join_1236 (eax, eax);
    ecx = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_6;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0xc00;
    eax = *(esp);
    *(ebx) = eax;
    eax = *((esp + 4));
    *((ebx + 4)) = eax;
    *((ebx + 8)) = ecx;
    eax = ebx;
    return eax;
label_5:
    eax = *(esp);
    ebx = *((esp + 0x18));
    ecx = *((esp + 8));
    eax = camlMap_split_1264 ();
    goto label_0;
    ebx = eax;
    eax = *((ebx + 8));
    eax = *((ebx + 4));
    edx = *(ebx);
    eax = *((esp + 8));
    esi = *((eax + 0x10));
    eax = *((esp + 0x14));
    ebx = *((esp + 0xc));
    ecx = *((esp + 0x10));
    eax = camlMap_join_1236 (eax, eax);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = ecx;
            eax = *(esp);
            *((ebx + 4)) = eax;
            eax = *((esp + 4));
            *((ebx + 8)) = eax;
            eax = ebx;
            return eax;
label_3:
            eax = loc.camlMap__17;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_6:
    caml_call_gc ();
    goto label_1;
label_4:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80597a0 */
#include <stdint.h>
 
int32_t camlMap_join_1236 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h_2;
    int32_t var_14h;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
label_0:
        edi = eax;
        if (edi == 1) {
            goto label_1;
        }
        if (edx == 1) {
            goto label_2;
        }
        *((esp + 0x24)) = esi;
        *((esp + 0x20)) = edx;
        *((esp + 0x1c)) = ecx;
        *((esp + 0x18)) = ebx;
        *((esp + 4)) = edi;
        eax = *((edx + 0x10));
        *(esp) = eax;
        eax = *((edx + 0xc));
        *((esp + 0x14)) = eax;
        eax = *((edx + 8));
        *((esp + 0x10)) = eax;
        eax = *((edx + 4));
        *((esp + 0xc)) = eax;
        eax = *(edx);
        *((esp + 8)) = eax;
        ebx = *((edi + 0x10));
        esi = *((edi + 0xc));
        edx = *((edi + 8));
        ecx = *((edi + 4));
        ebp = *(edi);
        eax = *(esp);
        edi = *(esp);
        edi += 4;
        if (ebx <= edi) {
            goto label_3;
        }
        eax = esi;
        ebx = *((esp + 0x18));
        ecx = *((esp + 0x1c));
        edx = *((esp + 0x20));
        esi = *((esp + 0x24));
        eax = camlMap_join_1236 (ebp, ecx, edx);
    } while (1);
    edx = eax;
    eax = *(esp);
    ebx = *((esp + 4));
    ecx = *((esp + 8));
    void (*0x8058c00)() ();
label_3:
    ebx += 4;
    if (eax > ebx) {
        eax = *((esp + 4));
        ebx = *((esp + 0x18));
        ecx = *((esp + 0x1c));
        edx = *((esp + 8));
        esi = *((esp + 0x24));
        camlMap_join_1236 ();
        goto label_0;
        ebx = *((esp + 0xc));
        ecx = *((esp + 0x10));
        edx = *((esp + 0x14));
        void (*0x8058c00)() ();
    }
    eax = *((esp + 4));
    ebx = *((esp + 0x18));
    ecx = *((esp + 0x1c));
    edx = *((esp + 0x20));
    void (*0x8058b40)() ();
label_2:
    edx = *((esi + 0x14));
    eax = ebx;
    ebx = ecx;
    ecx = edi;
    void (*0x8058ec0)() ();
label_1:
    esi = *((esi + 0x14));
    eax = ebx;
    ebx = ecx;
    ecx = edx;
    edx = esi;
    return camlMap_add_1108 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055250 */
#include <stdint.h>
 
int32_t camlList_chop_1243 (void) {
    do {
        if (eax == 1) {
            eax = ebx;
            return eax;
        }
        if (ebx == 1) {
            goto label_0;
        }
        ebx = *((ebx + 4));
        eax += 0xfffffffe;
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Assert_failure;
            *((eax + 4)) = 0x807dfd4;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f7a2 */
#include <stdint.h>
 
int32_t caml_output_value_to_malloc (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    void * s2;
    size_t n;
    init_extern_output (ebx, esi, edi);
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = extern_value ();
    ebx = eax;
    eax = malloc (eax);
    esi = eax;
    if (eax == 0) {
        extern_out_of_memory ();
    }
    eax = *((ebp + 0x10));
    *(eax) = esi;
    eax = *((ebp + 0x14));
    *(eax) = ebx;
    ebx = extern_output_first;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        edi = *((ebx + 4));
        edi -= eax;
        memmove (esi, eax, edi);
        esi += edi;
        ebx = *(ebx);
    } while (ebx != 0);
label_0:
    free_extern_output ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f9da */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_2 (void) {
    edx = intern_src;
    eax = edx + 2;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    eax = *(edx);
    eax <<= 8;
    eax = ecx + eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8053c00 */
#include <stdint.h>
 
int32_t camlList_rev_sort_1272 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    if (eax != 5) {
        *((esp + 0x10)) = ecx;
        if (eax != 7) {
            goto label_7;
        }
        if (ebx == 1) {
            goto label_7;
        }
        esi = *((ebx + 4));
        if (esi == 1) {
            goto label_7;
        }
        edx = *((esi + 4));
        if (edx == 1) {
            goto label_7;
        }
        eax = *(edx);
        edx = *(esi);
        eax = *(ebx);
        ecx = *((ecx + 0xc));
        ebx = edx;
        eax = caml_apply2 (eax, edx, eax);
        if (eax > 1) {
            eax = *((esp + 0x10));
            ecx = *((eax + 0xc));
            eax = *((esp + 4));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax > 1) {
label_6:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_8;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *(esp);
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
            eax = *((esp + 0x10));
            ecx = *((eax + 0xc));
            eax = *((esp + 8));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax > 1) {
label_5:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_9;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *(esp);
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
label_4:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0xc));
        eax = *((esp + 8));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax > 1) {
label_3:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_11;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0xc));
        eax = *((esp + 4));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax > 1) {
label_2:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_12;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_13;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        eax = *((esp + 8));
        *(ebx) = eax;
        *((ebx + 4)) = 1;
        ecx = ebx + 0xc;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 4));
        *(ecx) = eax;
        *((ecx + 4)) = ebx;
        ebx += 0x18;
        *((ebx - 4)) = 0x800;
        eax = *(esp);
        *(ebx) = eax;
        *((ebx + 4)) = ecx;
        eax = ebx;
        return eax;
    }
    if (ebx == 1) {
        goto label_14;
    }
    edx = *((ebx + 4));
    if (edx == 1) {
        goto label_15;
    }
    edx = *(edx);
    eax = *(ebx);
    ecx = *((ecx + 0xc));
    ebx = edx;
    eax = caml_apply2 (edx, eax);
    if (eax <= 1) {
        goto label_16;
    }
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_17;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x800;
    eax = *(esp);
    *(ecx) = eax;
    *((ecx + 4)) = 1;
    ebx = ecx + 0xc;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 4));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = ebx;
    return eax;
    do {
label_16:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ecx) = eax;
            *((ecx + 4)) = 1;
            ebx = ecx + 0xc;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
label_15:
            *((esp + 0x10)) = ecx;
            goto label_7;
label_14:
label_7:
            ecx = eax;
            ecx >>= 1;
            ecx |= 1;
            eax -= ecx;
            eax++;
            eax = ecx;
            eax = camlList_chop_1243 (ecx, ebx, eax);
            ecx = *((esp + 0x10));
            ecx += 0xfffffff0;
            eax = *(esp);
            ebx = *((esp + 4));
            eax = camlList_sort_1271 (eax);
            ecx = *((esp + 0x10));
            ecx += 0xfffffff0;
            eax = *((esp + 8));
            ebx = *((esp + 0xc));
            eax = camlList_sort_1271 (eax);
            ebx = eax;
            eax = *((esp + 0x10));
            edx = *((eax + 0x10));
            ecx = 1;
            eax = *(esp);
            void (*0x8053a00)() ();
        }
        caml_call_gc ();
    } while (1);
label_17:
    caml_call_gc ();
    goto label_0;
label_13:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_call_gc ();
    goto label_2;
label_11:
    caml_call_gc ();
    goto label_3;
label_10:
    caml_call_gc ();
    goto label_4;
label_9:
    caml_call_gc ();
    goto label_5;
label_8:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80540c0 */
#include <stdint.h>
 
int32_t camlList_sort_1271 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    if (eax != 5) {
        *((esp + 0x10)) = ecx;
        if (eax != 7) {
            goto label_7;
        }
        if (ebx == 1) {
            goto label_7;
        }
        esi = *((ebx + 4));
        if (esi == 1) {
            goto label_7;
        }
        edx = *((esi + 4));
        if (edx == 1) {
            goto label_7;
        }
        eax = *(edx);
        edx = *(esi);
        eax = *(ebx);
        ecx = *((ecx + 0x1c));
        ebx = edx;
        eax = caml_apply2 (eax, edx, eax);
        if (eax <= 1) {
            eax = *((esp + 0x10));
            ecx = *((eax + 0x1c));
            eax = *((esp + 4));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax <= 1) {
label_6:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_8;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *(esp);
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
            eax = *((esp + 0x10));
            ecx = *((eax + 0x1c));
            eax = *((esp + 8));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax <= 1) {
label_5:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_9;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *(esp);
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
label_4:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0x1c));
        eax = *((esp + 8));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax <= 1) {
label_3:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_11;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0x1c));
        eax = *((esp + 4));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax <= 1) {
label_2:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_12;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_13;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        eax = *((esp + 8));
        *(ebx) = eax;
        *((ebx + 4)) = 1;
        ecx = ebx + 0xc;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 4));
        *(ecx) = eax;
        *((ecx + 4)) = ebx;
        ebx += 0x18;
        *((ebx - 4)) = 0x800;
        eax = *(esp);
        *(ebx) = eax;
        *((ebx + 4)) = ecx;
        eax = ebx;
        return eax;
    }
    if (ebx == 1) {
        goto label_14;
    }
    edx = *((ebx + 4));
    if (edx == 1) {
        goto label_15;
    }
    edx = *(edx);
    eax = *(ebx);
    ecx = *((ecx + 0x1c));
    ebx = edx;
    eax = caml_apply2 (edx, eax);
    if (eax > 1) {
        goto label_16;
    }
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_17;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x800;
    eax = *(esp);
    *(ecx) = eax;
    *((ecx + 4)) = 1;
    ebx = ecx + 0xc;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 4));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = ebx;
    return eax;
    do {
label_16:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ecx) = eax;
            *((ecx + 4)) = 1;
            ebx = ecx + 0xc;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
label_15:
            *((esp + 0x10)) = ecx;
            goto label_7;
label_14:
label_7:
            ecx = eax;
            ecx >>= 1;
            ecx |= 1;
            eax -= ecx;
            eax++;
            eax = ecx;
            eax = camlList_chop_1243 (ecx, ebx, eax);
            ecx = *((esp + 0x10));
            ecx += 0x10;
            eax = *(esp);
            ebx = *((esp + 4));
            eax = camlList_rev_sort_1272 (eax);
            ecx = *((esp + 0x10));
            ecx += 0x10;
            eax = *((esp + 8));
            ebx = *((esp + 0xc));
            eax = camlList_rev_sort_1272 (eax);
            ebx = eax;
            eax = *((esp + 0x10));
            edx = *((eax + 0x24));
            ecx = 1;
            eax = *(esp);
            void (*0x8053b00)() ();
        }
        caml_call_gc ();
    } while (1);
label_17:
    caml_call_gc ();
    goto label_0;
label_13:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_call_gc ();
    goto label_2;
label_11:
    caml_call_gc ();
    goto label_3;
label_10:
    caml_call_gc ();
    goto label_4;
label_9:
    caml_call_gc ();
    goto label_5;
label_8:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ef00 */
#include <stdint.h>
 
void camlCamlinternalOO_fun_1818 (void) {
    ecx = *((ebx + 0xc));
    ebx = *(eax);
    ebx = *((ebx + ecx*2 - 2));
    ecx = *(ebx);
    void (*ecx)(uint32_t) (ebx);
    ebx = *(esp);
    ecx = *((ebx + 8));
    ebx = *((ebx + 0x10));
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061b0c */
#include <stdint.h>
 
int32_t unix_alarm (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16df4;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    alarm ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a3d4 */
#include <stdint.h>
 
void alarm (void) {
    alarm ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806700a */
#include <stdint.h>
 
int32_t caml_failwith (void) {
    int32_t var_4h_6;
    int32_t var_4h_5;
    eax = *((ebp + 8));
    return caml_raise_with_string (loc.caml_exn_Failure, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bf60 */
#include <stdint.h>
 
int32_t camlUnix_fun_2584 (void) {
    eax = unix_gethostbyaddr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b250 */
#include <stdint.h>
 
int32_t camlPrintf_sub_sub_1129 (void) {
    ecx = *((ebx + 0x14));
    if (eax >= ecx) {
        edx = *((ebx + 8));
        eax = *((ebx + 0x10));
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)() ();
    }
    edx = *((ebx + 0x10));
    ecx = eax;
    ecx >>= 1;
    esi = *((edx - 4));
    esi >>= 0xa;
    esi = esi*4 - 1;
    edi = *((edx + esi));
    esi -= edi;
    if (esi > ecx) {
        ecx = *((edx + ecx));
        edx = ecx + ecx + 1;
        ecx = edx;
        ecx += 0xffffffb0;
        if (ecx > 3) {
            ecx += 0xffffff5a;
            if (ecx > 5) {
                goto label_0;
            }
            *(esp) = ebx;
            ecx >>= 1;
            if (ecx < 1) {
                goto label_1;
            }
            if (ecx == 1) {
                goto label_0;
            }
            if (ecx > 1) {
                goto label_2;
            }
        }
        if (ecx == 1) {
            *(esp) = ebx;
            goto label_1;
label_0:
            ebx += 0xfffffff4;
            eax += 2;
            void (*0x805b330)() ();
label_1:
            ecx = *((ebx + 0x18));
            ebx = eax;
            ebx += 2;
            eax = edx;
            eax = camlPrintf_sub_fmt_1124 ();
            ebx = *(esp);
            ebx += 0xfffffff4;
            eax += 2;
            void (*0x805b330)() ();
        }
label_2:
        ecx = *((ebx + 0x20));
        if (edx == ecx) {
            eax += 2;
            return eax;
        }
        esi = *((ebx + 0xc));
        ecx = *((ebx + 0x1c));
        eax = *((ebx + 0x10));
        ebx = ecx;
        ecx = edx;
        edx = esi;
        void (*0x804b580)() ();
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070e8d */
#include <stdint.h>
 
int32_t caml_sys_getenv (char * name) {
    eax = *((ebp + 8));
    eax = getenv (eax);
    if (eax == 0) {
        eax = caml_raise_not_found ();
    }
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050280 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1487 (void) {
    eax = caml_ml_pos_out_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c460 */
#include <stdint.h>
 
int32_t camlUnix_fun_2730 (void) {
    eax = unix_isatty;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c480 */
#include <stdint.h>
 
int32_t camlUnix_fun_2734 (void) {
    eax = unix_lstat;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068442 */
#include <stdint.h>
 
void caml_fl_init_merge (void) {
    *(obj.last_fragment) = 0;
    *(obj.caml_fl_merge) = 0x8084668;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80650bd */
#include <stdint.h>
 
int32_t alloc_inet6_addr (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1383e;
    esi = *((ebp + 8));
    caml_alloc_string (0x10);
    edx = *(esi);
    *(eax) = edx;
    edx = *((esi + 4));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    *((eax + 8)) = edx;
    edx = *((esi + 0xc));
    *((eax + 0xc)) = edx;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805dce0 */
#include <stdint.h>
 
int32_t camlPrintf_ac_of_format_1184 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x38;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = 1;
            *((ebx + 4)) = 1;
            *((ebx + 8)) = 1;
            eax = ebx + 0x10;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x805bee0;
            *((eax + 0xc)) = ebx;
            ebx += 0x24;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.caml_curry3;
            *((ebx + 4)) = 7;
            *((ebx + 8)) = 0x805bf40;
            *((ebx + 0xc)) = eax;
            ecx = loc.camlPrintf__46;
            eax = edx;
            camlPrintf_iter_on_format_args_1137 (ebx);
            eax = *(esp);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f2a0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_compare_1143 (void) {
    eax = caml_compare;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80621ba */
#include <stdint.h>
 
uint32_t unix_set_close_on_exec (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16741;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 1;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        eax |= 1;
        *((esp + 8)) = eax;
        *((esp + 4)) = 2;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x25d6;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806baab */
#include <stdint.h>
 
int32_t caml_nativeint_xor (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax ^= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056dc0 */
#include <stdint.h>
 
int32_t camlHashtbl_do_bucket_1142 (void) {
    int32_t var_4h;
    do {
        esi = ebx;
        if (eax == 1) {
            goto label_0;
        }
        ebx = *((eax + 8));
        ebx = *((eax + 4));
        eax = *(eax);
        edx = *((ecx + 0xc));
        ecx = esi;
        eax = caml_apply3 (ebx, ecx);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
    } while (1);
label_0:
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c3aa */
#include <stdint.h>
 
int32_t caml_eq_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] == fp_stack[1]) ? 1 : 0;
    __asm ("setnp dl");
    eax &= edx;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055970 */
#include <stdint.h>
 
int32_t camlString_fill_1051 (void) {
    if (ebx >= 1) {
        if (ecx < 1) {
            goto label_0;
        }
        esi = *((eax - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((eax + esi));
        esi -= edi;
        esi <<= 1;
        esi -= ecx;
        esi += 2;
        if (ebx > esi) {
            goto label_0;
        }
        caml_fill_string (eax, ebx, ecx, edx);
        return;
    }
label_0:
    eax = "String.fill";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f9c0 */
#include <stdint.h>
 
int32_t camlPervasives_abs_1044 (void) {
    if (eax >= 1) {
        return;
    }
    ebx = 2;
    ebx -= eax;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c1e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2658 (void) {
    eax = unix_gettimeofday;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c8d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2794 (void) {
    eax = unix_lseek_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059300 */
#include <stdint.h>
 
uint32_t camlMap_remove_1162 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    do {
label_0:
        if (ebx == 1) {
            goto label_1;
        }
        edx = *((ebx + 0xc));
        edx = *((ebx + 8));
        edx = *((ebx + 4));
        ebx = *(ebx);
        ebx = *((ecx + 0xc));
        ecx = *(ebx);
        ebx = edx;
        eax = caml_apply2 (eax, ecx, edx);
        if (eax == 1) {
            eax = *((esp + 0x10));
            ebx = *((esp + 0x14));
            void (*0x8059290)() ();
        }
        if (eax >= 1) {
            goto label_2;
        }
        eax = *(esp);
        ebx = *((esp + 0x10));
        ecx = *((esp + 4));
        camlMap_remove_1162 ();
    } while (1);
    ebx = *((esp + 8));
    ecx = *((esp + 0xc));
    edx = *((esp + 0x14));
    void (*0x8058c00)() ();
label_2:
    eax = *(esp);
    ebx = *((esp + 0x14));
    ecx = *((esp + 4));
    eax = camlMap_remove_1162 ();
    goto label_0;
    edx = eax;
    eax = *((esp + 0x10));
    ebx = *((esp + 8));
    ecx = *((esp + 0xc));
    void (*0x8058c00)() ();
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062a33 */
#include <stdint.h>
 
int32_t unix_getgrnam (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15ecd;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getgrnam ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_group_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049f84 */
#include <stdint.h>
 
void getgrnam (void) {
    getgrnam ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c8b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2798 (void) {
    eax = unix_ftruncate_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066fb8 */
#include <stdint.h>
 
int32_t caml_raise_sys_error (void) {
    int32_t var_4h_3;
    int32_t var_4h_2;
    eax = *((ebp + 8));
    return caml_raise_with_arg (loc.caml_exn_Sys_error, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ba50 */
#include <stdint.h>
 
int32_t camlPrintf_sub_fmt_1124 (void) {
    edx = ebx;
    if (eax == 0x51) {
        esi = 0x53;
    } else {
        esi = 0xfb;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x34;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x30f7;
            *(ebx) = sym.camlPrintf__sub_1128;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = 0xcf9;
            *((ebx + 0xc)) = 0x805b250;
            *((ebx + 0x10)) = 3;
            eax = *((ecx + 0xc));
            *((ebx + 0x14)) = eax;
            eax = *((ecx + 0x10));
            *((ebx + 0x18)) = eax;
            eax = *((ecx + 0x14));
            *((ebx + 0x1c)) = eax;
            eax = *((ecx + 0x18));
            *((ebx + 0x20)) = eax;
            *((ebx + 0x24)) = ecx;
            *((ebx + 0x28)) = edx;
            *((ebx + 0x2c)) = esi;
            eax = edx;
            void (*0x805b330)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bf80 */
#include <stdint.h>
 
int32_t camlUnix_fun_2588 (void) {
    eax = unix_gethostname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c4c7 */
#include <stdint.h>
 
void caml_init_ieee_floats (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b02d */
#include <stdint.h>
 
int32_t caml_greaterthan (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80882e0) {
        compare_free_stack ();
    }
    al = (ebx > 0) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e032 */
#include <stdint.h>
 
uint32_t caml_refill (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = ebx + 0x34;
    edx = *((ebx + 0xc));
    edx -= eax;
    eax = *(ebx);
    eax = caml_do_read (ebx, eax, edx);
    if (eax == 0) {
        eax = caml_raise_end_of_file ();
    }
    ecx = eax;
    ecx >>= 0x1f;
    *((ebx + 4)) += eax;
    *((ebx + 8)) += ecx;
    eax = ebx + eax + 0x34;
    *((ebx + 0x14)) = eax;
    eax = ebx + 0x35;
    *((ebx + 0x10)) = eax;
    eax = *((ebx + 0x34));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806dc9a */
#include <stdint.h>
 
int32_t caml_do_read (int32_t arg_8h, void * arg_ch, size_t arg_10h) {
    void * buf;
    size_t nbyte;
    esi = *((ebp + 8));
    edi = *((ebp + 0xc));
    do {
        caml_enter_blocking_section (ebx, esi, edi);
        eax = *((ebp + 0x10));
        eax = read (esi, edi, eax);
        ebx = eax;
        caml_leave_blocking_section ();
        if (ebx != -1) {
            goto label_0;
        }
        eax = errno_location ();
    } while (*(eax) == 4);
    caml_sys_io_error (1);
label_0:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80670cb */
#include <stdint.h>
 
void caml_raise_end_of_file (void) {
    return caml_raise_constant (loc.caml_exn_End_of_file);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cc40 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_float_1664 (void) {
    eax = unix_getsockopt;
    caml_c_call (7);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e5d0 */
#include <stdint.h>
 
uint32_t camlPrintf_ksprintf_1411 (void) {
    ebx = .comment;
    ecx = *(ebx);
    eax = void (*ecx)() ();
    edi = eax;
    ebp = .comment;
    esi = loc.camlPrintf__40;
    edx = .comment;
    ecx = .comment;
    ebx = .comment;
    eax = 3;
    *(loc.caml_extra_params) = ebp;
    return caml_apply6 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d520 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1680 (void) {
    eax = *((ebx + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c4a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2738 (void) {
    eax = unix_ftruncate;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063464 */
#include <stdint.h>
 
uint32_t unix_getsockname (int32_t sockfd) {
    int32_t var_7ch;
    int32_t var_78h;
    struct sockaddr * addr;
    socklen_t * addrlen;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15499;
    *((ebp - 0x7c)) = 0x70;
    eax = ebp - 0x7c;
    eax = ebp - 0x78;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = getsockname (eax, eax, eax);
    if (eax == -1) {
        eax = ebx - 0x2560;
        uerror (eax, 0);
    }
    eax = *((ebp - 0x7c));
    eax = ebp - 0x78;
    alloc_sockaddr (eax, eax, 0xffffffff);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049e94 */
#include <stdint.h>
 
void getsockname (void) {
    getsockname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8053a00 */
#include <stdint.h>
 
int32_t camlList_rev_merge_1251 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
label_0:
        if (eax == 1) {
            goto label_2;
        }
        if (ebx == 1) {
            goto label_3;
        }
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((edx + 0xc));
        eax = caml_apply2 (edx, eax, ecx);
        if (eax > 1) {
            goto label_4;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 0xc));
        *(ecx) = eax;
        eax = *((esp + 0x10));
        *((ecx + 4)) = eax;
        eax = *((esp + 0x14));
        ebx = *((esp + 0x18));
        edx = *((esp + 0x1c));
    } while (1);
    do {
label_4:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            eax = *((esp + 0x10));
            *((ecx + 4)) = eax;
            eax = *((esp + 4));
            ebx = *((esp + 8));
            edx = *((esp + 0x1c));
            goto label_0;
label_3:
            ebx = ecx;
            void (*0x8054610)() ();
label_2:
            eax = ebx;
            ebx = ecx;
            void (*0x8054610)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bef6 */
#include <stdint.h>
 
int32_t caml_int64_xor (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 4));
    ecx ^= *((eax + 4));
    edx = *((edx + 8));
    edx ^= *((eax + 8));
    caml_copy_int64 (ecx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056040 */
#include <stdint.h>
 
int32_t camlString_uppercase_1096 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_map_1090 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f2b0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fit_size_1166 (void) {
    do {
        if (eax <= 5) {
            return;
        }
        eax += 2;
        eax >>= 1;
        if (eax < 0) {
            eax++;
        }
        eax >>= 1;
        eax = eax + eax + 1;
        eax = camlCamlinternalOO_fit_size_1166 ();
    } while (1);
    eax--;
    eax <<= 1;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056e20 */
#include <stdint.h>
 
int32_t camlHashtbl_add_1179 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    esi = *((eax + 4));
    esi = *((esi - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = *((edx + 0xc));
        eax = *((eax + 8));
        edx = *((eax + 4));
        ecx = *(edx);
        eax = ebx;
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (esi, ecx, eax);
        ebx = 0x7fffffff;
        eax &= ebx;
        eax >>= 1;
        ecx = *((esp + 0x10));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            ebx = *((esp + 8));
            esi = *((ebx + 4));
            ecx = *((esi - 4));
            ecx >>= 9;
            if (ecx <= edx) {
                goto label_0;
            }
            ecx = *((esi + edx*2 - 2));
            *((eax + 8)) = ecx;
            esi = *((ebx + 4));
            ecx = *((esi - 4));
            ecx >>= 9;
            if (ecx <= edx) {
                goto label_1;
            }
            caml_modify (esi + edx*2 - 2, eax);
            *(ebx) += 2;
            eax = *((ebx + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ecx = eax + eax - 1;
            eax = *(ebx);
            if (eax > ecx) {
                eax = *((esp + 0xc));
                eax = *((eax + 0xc));
                void (*0x80577a0)() ();
            }
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80501b0 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_newline_1287 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x807c030));
    eax = caml_ml_flush;
    caml_c_call (*(0x807c030));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805a5a0 */
#include <stdint.h>
 
uint32_t camlMap_entry (void) {
    ebx = camlMap__1;
    caml_alloc3 ();
    eax = eax + 4;
    *((eax - 4)) = 0xcf7;
    *(eax) = sym.camlMap__fun_1920;
    *((eax + 4)) = 3;
    *((eax + 8)) = ebx;
    *(loc.camlMap) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075b70 */
#include <stdint.h>
 
int32_t loc_caml_alloc3 (int32_t arg_4h) {
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            return eax;
        }
        eax = *(esp);
        *(obj.caml_last_return_address) = eax;
        eax = esp + 4;
        *(obj.caml_bottom_of_stack) = eax;
        fcn_08075aed ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064bf4 */
#include <stdint.h>
 
int32_t unix_setuid (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13d0c;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = setuid ();
    if (eax == -1) {
        eax = ebx - 0x2462;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a324 */
#include <stdint.h>
 
void setuid (void) {
    setuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c688 */
#include <stdint.h>
 
int32_t caml_log1p_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_log1p ();
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c4f4 */
#include <stdint.h>
 
void caml_log1p (void) {
    *(fp_stack--) = *((ebp + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    log1p (ebp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049eb4 */
#include <stdint.h>
 
void log1p (void) {
    log1p ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cc60 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_float_1667 (void) {
    eax = unix_setsockopt;
    caml_c_call (7);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ac30 */
#include <stdint.h>
 
int32_t caml_curry9_6 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_7;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d78c */
#include <stdint.h>
 
int32_t caml_ml_pos_out (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_out (ebx);
    ebx = eax;
    if (edx >= 0) {
        if (edx <= 0) {
            if (eax <= 0x3fffffff) {
                goto label_0;
            }
        }
        errno_location ();
        *(eax) = 0x4b;
        caml_sys_error (1);
    }
label_0:
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fc60 */
#include <stdint.h>
 
int32_t camlPervasives_open_out_bin_1181 (void) {
    ecx = eax;
    ebx = 0x36d;
    eax = loc.camlPervasives__93;
    return camlPervasives_open_out_gen_1175 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8074ed4 */
#include <stdint.h>
 
int32_t caml_final_update (void) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    uint32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    esi = old;
    if (esi == 0) {
        goto label_2;
    }
    edx = final_table;
    ebx = 0;
    eax = 0;
    do {
        ecx = *((edx + 4));
        ecx = *((ecx - 4));
        ecx &= 0x300;
        ebx += 0;
        eax++;
        edx += 0xc;
    } while (eax < esi);
    if (ebx == 0) {
        goto label_2;
    }
    eax = ebx * 3;
    eax = eax*4 + 0x14;
    eax = malloc (eax);
    if (eax == 0) {
        caml_fatal_error ("out of memory");
    }
    *(eax) = 0;
    *((eax + 4)) = ebx;
    edx = to_do_tl;
    if (edx == 0) {
        *(obj.to_do_hd) = eax;
        *(obj.to_do_tl) = eax;
    } else {
        *(edx) = eax;
        *(obj.to_do_tl) = eax;
    }
    eax = old;
    *((ebp - 0x30)) = eax;
    if (eax == 0) {
        goto label_3;
    }
    edx = final_table;
    *((ebp - 0x38)) = edx;
    ecx = to_do_tl;
    *((ebp - 0x2c)) = ecx;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x34)) = 0;
    *((ebp - 0x28)) = 0;
    edi = caml_page_table;
    do {
        *((ebp - 0x3c)) = edx;
label_0:
        ecx = *((edx + 4));
        eax = ecx - 4;
        if ((*(eax) & 0x300) == 0) {
            if (*(eax) == 0xfa) {
                eax = *(ecx);
                if ((al & 1) == 0) {
                    *((ebp - 0x20)) = eax;
                    ebx = eax;
                    ebx >>= 0x17;
                    ecx = eax;
                    ecx >>= 0xc;
                    ecx &= 0x7ff;
                    *((ebp - 0x1c)) = ecx;
                    esi = *((edi + ebx*4));
                    if ((*((esi + ecx)) & 7) != 0) {
                        ecx = *((eax - 4));
                        if (cl != 0xfa) {
                            if (cl != 0xf6) {
                                if (cl != 0xfd) {
                                    goto label_4;
                                }
                                esi = *((ebp - 0x3c));
                                esi = *((ebp - 0x3c));
                                *((esi + 4)) = eax;
                                esi = *((ebp - 0x3c));
                                esi = *((ebp - 0x3c));
                                esi = *((ebp - 0x3c));
                            } else {
                            } else {
                            } else {
                            } else {
                            } else {
                                esi = *((ebp - 0x3c));
                            }
                        }
                    }
                }
            }
label_1:
            ebx = *((ebp - 0x24));
            eax = ebx * 3;
            eax <<= 2;
            ecx = *(esi);
            ebx = *((ebp - 0x2c));
            *((eax + ebx + 8)) = ecx;
            ecx = *((esi + 4));
            *((eax + ebx + 0xc)) = ecx;
            ecx = *((esi + 8));
            *((eax + ebx + 0x10)) = ecx;
            *((ebp - 0x24))++;
        } else {
            esi = *((ebp - 0x3c));
            ecx = *((ebp - 0x34));
            eax = ecx * 3;
            eax <<= 2;
            ecx = *(esi);
            ebx = *((ebp - 0x38));
            *((eax + ebx)) = ecx;
            ecx = *((esi + 4));
            *((eax + ebx + 4)) = ecx;
            ecx = *((esi + 8));
            *((eax + ebx + 8)) = ecx;
            *((ebp - 0x34))++;
        }
        *((ebp - 0x28))++;
        edx += 0xc;
        esi = *((ebp - 0x28));
    } while (*((ebp - 0x30)) > esi);
    eax = *((ebp - 0x34));
    *(obj.old) = eax;
    *(obj.young) = eax;
    ecx = *((ebp - 0x24));
    edx = *((ebp - 0x2c));
    *((edx + 4)) = ecx;
    if (ecx == 0) {
        goto label_2;
    }
    ebx = 0;
    esi = ecx;
    do {
        eax = ebx * 3;
        eax <<= 2;
        eax += *(obj.to_do_tl);
        eax = *((eax + 0xc));
        eax = caml_darken (eax, 0);
        ebx++;
    } while (ebx < esi);
    goto label_2;
label_4:
    *((edx + 4)) = eax;
    eax = *((edi + ebx*4));
    ebx = *((ebp - 0x1c));
    if ((*((eax + ebx)) & 1) != 0) {
        goto label_0;
    }
    esi = *((ebp - 0x3c));
    goto label_1;
label_3:
    *(obj.old) = 0;
    *(obj.young) = 0;
    eax = to_do_tl;
    *((eax + 4)) = 0;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fd70 */
#include <stdint.h>
 
void camlPervasives_close_out_noerr_1211 (void) {
    *(esp) = eax;
    fcn_0804fd80 ();
    return void (*0x804fda3)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fd80 */
#include <stdint.h>
 
int32_t fcn_0804fd80 (void) {
    *(obj.caml_exception_pointer) = esp;
    eax = caml_ml_flush;
    caml_c_call (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fdc0 */
#include <stdint.h>
 
int32_t fcn_0804fdc0 (int32_t arg_8h) {
    *(obj.caml_exception_pointer) = esp;
    eax = *((esp + 8));
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fda3 */
#include <stdint.h>
 
int32_t fcn_0804fda3 (void) {
    fcn_0804fdc0 ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f150 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_new_id_1031 (void) {
    eax = .comment;
    eax = *(eax);
    ebx = .comment;
    *(ebx) += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070650 */
#include <stdint.h>
 
uint32_t caml_input_value_from_block (int32_t arg_8h, uint32_t arg_ch) {
    edx = *((ebp + 8));
    *(obj.intern_input) = edx;
    *(obj.intern_input_malloced) = 0;
    eax = edx + 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *(edx);
    edx <<= 0x18;
    edx = ecx + edx;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    edx += ecx;
    ecx = *((eax - 2));
    ecx <<= 8;
    edx += ecx;
    if (edx != 0x8495a6be) {
        eax = caml_failwith ("input_value_from_block: bad object");
    }
    eax += 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *((eax - 4));
    edx <<= 0x18;
    edx = ecx + edx + 0x14;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    ecx = edx + ecx;
    edx = *((eax - 2));
    edx <<= 8;
    eax = ecx + edx;
    if (eax > *((ebp + 0xc))) {
        caml_failwith ("input_value_from_block: bad block length");
    }
    input_val_from_block ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050090 */
#include <stdint.h>
 
int32_t camlPervasives_print_endline_1274 (void) {
    ebx = eax;
    eax = .comment;
    camlPervasives_output_string_1191 ();
    eax = caml_ml_output_char;
    caml_c_call (*(0x807c02c));
    eax = caml_ml_flush;
    caml_c_call (*(0x807c02c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b140 */
#include <stdint.h>
 
int32_t caml_curry5_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ee20 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1786 (void) {
    eax = ebx;
    ebx = *((eax + 8));
    eax = *((eax + 0xc));
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d10c */
#include <stdint.h>
 
int32_t caml_array_unsafe_get_float (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + edx*8));
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    edx = caml_young_ptr;
    eax = edx - 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        *(obj.caml_young_ptr) = edx;
        caml_minor_collection ();
        *(obj.caml_young_ptr) -= 0xc;
    }
    eax = caml_young_ptr;
    *(eax) = 0xbfd;
    eax = caml_young_ptr;
    eax += 4;
    *(fp_stack--) = *((ebp - 0x10));
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806795a */
#include <stdint.h>
 
int32_t caml_register_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = caml_global_roots;
    caml_insert_global_root ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f880 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1418 (void) {
    eax = caml_ml_output_int;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c2d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2684 (void) {
    eax = unix_rewinddir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067ba6 */
#include <stdint.h>
 
int32_t caml_remove_generational_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *(edx);
    if ((al & 1) != 0) {
        goto label_0;
    }
    if (eax >= *(obj.caml_young_end)) {
        goto label_1;
    }
    if (eax <= *(obj.caml_young_start)) {
        goto label_1;
    }
    eax = caml_global_roots_young;
    caml_delete_global_root ();
    goto label_0;
    do {
        eax = caml_global_roots_old;
        eax = caml_delete_global_root ();
        goto label_0;
label_1:
        ecx = eax;
        ecx >>= 0x17;
        eax >>= 0xc;
        eax &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
    } while ((*((ecx + eax)) & 1) != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c890 */
#include <stdint.h>
 
int32_t camlUnix_fun_2802 (void) {
    eax = unix_lstat_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054830 */
#include <stdint.h>
 
int32_t camlList_map2_1090 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        eax = caml_apply2 (edx, eax, eax);
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        eax = camlList_map2_1090 (eax);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 0xc));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            if (ecx == 1) {
                eax = 1;
                return eax;
            }
label_1:
            eax = "List.map2";
            void (*0x804f900)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062098 */
#include <stdint.h>
 
int32_t unix_fchmod (void) {
    int32_t fd;
    int32_t mode;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16868;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = fchmod (eax, eax);
    if (eax == -1) {
        eax = ebx - 0x25f8;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c0bf */
#include <stdint.h>
 
int32_t caml_int64_add (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    ecx = *((eax + 4));
    ebx = *((eax + 8));
    edx = *((ebp + 8));
    eax = *((edx + 4));
    edx = *((edx + 8));
    eax += ecx;
    edx += ebx;
    caml_copy_int64 (ebx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c2f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2688 (void) {
    eax = unix_opendir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80603e0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_create_object_opt_1308 (void) {
    int32_t var_4h;
    if (eax != 1) {
        return;
    }
    *(esp) = ebx;
    eax = caml_obj_block;
    eax = caml_c_call (0x1f1);
    esi = eax;
    *((esp + 4)) = esi;
    eax = *(esp);
    ebx = *((eax + 4));
    eax = *((esi - 4));
    if (eax != 0xfe) {
        caml_modify (esi, ebx);
    } else {
        *(fp_stack--) = *(ebx);
        *(esi) = fp_stack[0];
        fp_stack--;
    }
    ebx = .comment;
    eax = esi;
    camlCamlinternalOO_set_id_1033 ();
    eax = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805a5d0 */
#include <stdint.h>
 
int32_t camlBuffer_advance_1104 (void) {
    int32_t var_4h;
    do {
label_0:
        if (ebx >= ecx) {
label_1:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            eax = caml_raise_exn ();
        }
        *((esp + 4)) = ecx;
        *(esp) = eax;
        edi = *((edx + 0xc));
        ecx = *((edx + 0x14));
        eax = ebx;
        eax >>= 1;
        esi = *((ecx - 4));
        esi >>= 0xa;
        ebp = esi*4 - 1;
        esi = *((ecx + ebp));
        ebp -= esi;
        if (ebp <= eax) {
            goto label_3;
        }
        eax = *((ecx + eax));
        eax = eax + eax + 1;
        if (eax != edi) {
            goto label_4;
        }
        ebx += 2;
        eax = *(esp);
        eax += 2;
        ecx = *((esp + 4));
    } while (1);
label_4:
    edi = *((edx + 0x10));
    ecx = *((edx + 0x14));
    eax = ebx;
    eax >>= 1;
    esi = *((ecx - 4));
    esi >>= 0xa;
    ebp = esi*4 - 1;
    esi = *((ecx + ebp));
    ebp -= esi;
    if (ebp > eax) {
        eax = *((ecx + eax));
        eax = eax + eax + 1;
        if (eax == edi) {
            eax = *(esp);
            if (eax == 1) {
                eax = ebx;
                return eax;
            }
            ebx += 2;
            eax += 0xfffffffe;
            ecx = *((esp + 4));
            goto label_0;
        }
        ebx += 2;
        eax = *(esp);
        ecx = *((esp + 4));
        goto label_0;
label_2:
        caml_call_gc ();
        goto label_1;
    }
    caml_ml_array_bound_error ();
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050040 */
#include <stdint.h>
 
int32_t camlPervasives_print_string_1268 (void) {
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070ef8 */
#include <stdint.h>
 
int32_t caml_sys_exit (int32_t status) {
    eax = *((ebp + 8));
    eax >>= 1;
    return exit (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a894 */
#include <stdint.h>
 
void exit (void) {
    exit ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c2b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2680 (void) {
    eax = unix_pipe;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f840 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1410 (void) {
    eax = caml_ml_set_binary_mode;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056240 */
#include <stdint.h>
 
int32_t camlString_rindex_from_1128 (void) {
    if (ebx >= -1) {
        edx = *((eax - 4));
        edx >>= 0xa;
        edx = edx*4 - 1;
        esi = *((eax + edx));
        edx -= esi;
        edx = edx + edx + 1;
        if (ebx >= edx) {
            goto label_0;
        }
        void (*0x80561c0)() ();
    }
label_0:
    eax = "String.rindex_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059580 */
#include <stdint.h>
 
uint32_t camlMap_fold_1196 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
label_0:
        if (ebx == 1) {
            goto label_1;
        }
        edx = *((ebx + 0xc));
        edx = *((ebx + 8));
        edx = *((ebx + 4));
        ebx = *(ebx);
        eax = camlMap_fold_1196 (edx, edx, eax);
    } while (1);
    ecx = eax;
    eax = *(esp);
    ebx = *((esp + 4));
    edx = *((esp + 8));
    eax = caml_apply3 ();
    ecx = eax;
    eax = *((esp + 8));
    ebx = *((esp + 0xc));
    goto label_0;
label_1:
    eax = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d5f0 */
#include <stdint.h>
 
void camlPrintf_sub_1050 (void) {
    return camlString_sub_1046 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b410 */
#include <stdint.h>
 
int32_t caml_send0 (void) {
    *(esp) = eax;
    esi = *(eax);
    edx = *((esi + 4));
    eax = *(ecx);
    eax &= edx;
    edx = *((eax + esi + 0xb));
    if (edx == ebx) {
        goto label_0;
    }
    edx = 3;
    eax = *(esi);
    do {
        edi = edx;
        edi += eax;
        edi >>= 1;
        edi |= 1;
        ebp = *((esi + edi*4));
        if (ebx < ebp) {
            edi -= 2;
            eax = edi;
        } else {
            edx = edi;
        }
    } while (edx < eax);
    eax = edx*4 - 0xb;
    *(ecx) = eax;
label_0:
    ebx = *((eax + esi + 7));
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073591 */
#include <stdint.h>
 
uint32_t caml_obj_block (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    ebx = *((ebp + 0xc));
    edx = *((ebp + 8));
    edx >>= 1;
    eax = edx*4 + 0x808b124;
    ebx >>= 1;
    if (ebx == 0) {
        goto label_0;
    }
    caml_alloc (ebx, edx);
    edx = 0;
    do {
        *((eax + edx*4)) = 1;
        edx++;
    } while (ebx > edx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ad70 */
#include <stdint.h>
 
void camlBuffer_add_buffer_1087 (void) {
    edx = *((ebx + 4));
    ecx = 1;
    ebx = *(ebx);
    return camlBuffer_add_substring_1076 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052df0 */
#include <stdint.h>
 
int32_t camlArray_fold_right_1145 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x400;
    *(esi) = ecx;
    ecx = *((ebx - 4));
    eax = *((ebx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        ecx >>= 9;
    } else {
        ecx >>= 0xa;
    }
    ecx |= 1;
    ecx += 0xfffffffe;
    if (ecx < 1) {
        goto label_3;
    }
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = esi;
    *(esp) = ebx;
    *((esp + 4)) = edx;
    do {
        ebx = *(esp);
        eax = *((ebx - 4));
        if (eax != 0xfe) {
            eax = *((ebx + ecx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *(esi);
        ecx = *((esp + 4));
        eax = caml_apply2 ();
        esi = *((esp + 0xc));
        caml_modify (esi, eax);
        ecx = *((esp + 0xc));
        eax = *((esp + 0xc));
        ecx -= 2;
        *((esp + 0xc)) = ecx;
    } while (eax != 1);
label_3:
    eax = *(esi);
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060b10 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_meth_app_var_1440 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlCamlinternalOO__fun_1834;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80633e7 */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
int32_t unix_getservbyport (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15519;
    eax = *((ebp + 8));
    eax >>= 1;
    ax = rotate_right16 (ax, 8);
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    eax = (int32_t) ax;
    *(esp) = eax;
    eax = getservbyport ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_service_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a194 */
#include <stdint.h>
 
void getservbyport (void) {
    getservbyport ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f2e0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_new_table_1168 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    *((esp + 8)) = eax;
    ebx = .comment;
    *(ebx) += 2;
    eax = *((eax - 4));
    ebx = *((eax - 4));
    ebx &= 0xff;
    if (ebx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    *((esp + 4)) = eax;
    eax = caml_make_vect;
    eax = caml_c_call (eax + eax + 3);
    esi = eax;
    *(esp) = esi;
    eax = *((esi - 4));
    eax >>= 9;
    if (eax <= 1) {
        goto label_1;
    }
    ebx = *((esp + 4));
    caml_modify (esi, ebx);
    eax = *((esi - 4));
    eax >>= 9;
    if (eax <= 3) {
        goto label_2;
    }
    eax = ebx;
    eax = camlCamlinternalOO_fit_size_1166 ();
    eax--;
    ebx = .comment;
    ebx >>= 1;
    eax *= ebx;
    eax++;
    eax >>= 1;
    if (eax < 0) {
        eax += 7;
    }
    eax >>= 3;
    eax <<= 1;
    eax -= 3;
    eax += 2;
    esi = *((esp + 4));
    eax = *((esp + 4));
    eax += 4;
    caml_modify (eax, eax);
    ebx = 1;
    edi = *((esp + 4));
    edi += 0xfffffffe;
    if (ebx > edi) {
        goto label_3;
    }
    do {
        edx = ebx + ebx + 5;
        eax = *((esi - 4));
        eax >>= 9;
        if (eax <= edx) {
            goto label_4;
        }
        ecx = *((esp + 8));
        eax = *((ecx - 4));
        ebp &= 0xff;
        if (ebp != 0xfe) {
            eax >>= 9;
            if (eax <= ebx) {
                goto label_5;
            }
            eax = *((ecx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_6;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_7;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        caml_modify (esi + edx*2 - 2, eax);
        eax = ebx;
        ebx += 2;
    } while (eax != edi);
    do {
label_3:
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x2000;
            *(eax) = 5;
            *((eax + 4)) = esi;
            *((eax + 8)) = 1;
            *((eax + 0xc)) = 1;
            *((eax + 0x10)) = 1;
            *((eax + 0x14)) = 1;
            *((eax + 0x18)) = 1;
            *((eax + 0x1c)) = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_7:
    caml_call_gc ();
    goto label_0;
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8051140 */
#include <stdint.h>
 
uint32_t camlArray_trickledown_1160 (void) {
    int32_t var_4h_3;
    int32_t var_8h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
        ecx = *((edx + 0x14));
        eax = camlArray_maxson_1155 (ebx, eax, ecx);
        ebx = eax;
        *((esp + 0x10)) = ebx;
        edx = *(esp);
        ecx = *((edx + 0x10));
        eax = *((ecx - 4));
        esi = *((ecx - 4));
        esi &= 0xff;
        if (esi != 0xfe) {
            eax >>= 9;
            if (eax <= ebx) {
                goto label_2;
            }
            eax = *((ecx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_3;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((edx + 0xc));
        ebx = *((esp + 8));
        eax = caml_apply2 ();
        if (eax <= 1) {
            goto label_5;
        }
        esi = *(esp);
        ecx = *((esi + 0x10));
        eax = *((ecx - 4));
        ebx = *((ecx - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            eax >>= 9;
            ebx = *((esp + 0x10));
            if (eax <= ebx) {
                goto label_6;
            }
            edx = *((ecx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            ebx = *((esp + 0x10));
            if (eax <= ebx) {
                goto label_7;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_8;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi + 0x10));
        edi = *((eax - 4));
        ecx = *((eax - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            edi >>= 9;
            ecx = *((esp + 0xc));
            if (edi <= ecx) {
                goto label_9;
            }
            caml_modify (eax + ecx*2 - 2, edx);
        } else {
            edi >>= 0xa;
            ecx = *((esp + 0xc));
            if (edi <= ecx) {
                goto label_10;
            }
            *(fp_stack--) = *(edx);
            *((eax + ecx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 4));
        ecx = *((esp + 8));
        edx = esi;
    } while (1);
label_5:
    eax = *(esp);
    eax = *((eax + 0x10));
    ebx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        ebx >>= 9;
        ecx = *((esp + 0xc));
        if (ebx <= ecx) {
            goto label_11;
        }
        ebx = *((esp + 8));
        caml_modify (eax + ecx*2 - 2, ebx);
    } else {
        ebx >>= 0xa;
        ecx = *((esp + 0xc));
        if (ebx <= ecx) {
            goto label_12;
        }
        ebx = *((esp + 8));
        *(fp_stack--) = *(ebx);
        *((eax + ecx*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_8:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c21f */
#include <stdint.h>
 
int32_t caml_int32_shift_left (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax <<= cl;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f860 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1414 (void) {
    eax = caml_ml_pos_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a9d0 */
#include <stdint.h>
 
int32_t loc_caml_startup_code_begin (void) {
    camlPervasives_entry ();
    *(obj.caml_globals_inited)++;
    camlArray_entry ();
    *(obj.caml_globals_inited)++;
    camlList_entry ();
    *(obj.caml_globals_inited)++;
    camlChar_entry ();
    *(obj.caml_globals_inited)++;
    camlString_entry ();
    *(obj.caml_globals_inited)++;
    camlSys_entry ();
    *(obj.caml_globals_inited)++;
    camlHashtbl_entry ();
    *(obj.caml_globals_inited)++;
    camlMarshal_entry ();
    *(obj.caml_globals_inited)++;
    camlObj_entry ();
    *(obj.caml_globals_inited)++;
    camlMap_entry ();
    *(obj.caml_globals_inited)++;
    camlBuffer_entry ();
    *(obj.caml_globals_inited)++;
    camlPrintf_entry ();
    *(obj.caml_globals_inited)++;
    camlCallback_entry ();
    *(obj.caml_globals_inited)++;
    camlCamlinternalOO_entry ();
    *(obj.caml_globals_inited)++;
    camlUnix_entry ();
    *(obj.caml_globals_inited)++;
    camlUnixLabels_code_begin ();
    *(obj.caml_globals_inited)++;
    camlSource_entry ();
    *(obj.caml_globals_inited)++;
    camlStd_exit_entry ();
    *(obj.caml_globals_inited)++;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80553a0 */
#include <stdint.h>
 
int32_t camlList_entry (void) {
    eax = loc.camlList__38;
    *(0x807dd74) = eax;
    eax = loc.camlList__37;
    *(loc.camlList) = eax;
    eax = loc.camlList__36;
    *(0x807dcd4) = eax;
    eax = loc.camlList__35;
    *(0x807dcd8) = eax;
    eax = loc.camlList__34;
    *(0x807dcdc) = eax;
    eax = .comment;
    *(0x807dce4) = eax;
    eax = loc.camlList__33;
    *(0x807dce8) = eax;
    eax = loc.camlList__32;
    *(0x807dce0) = eax;
    eax = loc.camlList__31;
    *(0x807dcf0) = eax;
    eax = .comment;
    *(0x807dcec) = eax;
    eax = loc.camlList__30;
    *(0x807dcf8) = eax;
    eax = loc.camlList__29;
    *(0x807dcfc) = eax;
    eax = loc.camlList__28;
    *(0x807dcf4) = eax;
    eax = loc.camlList__27;
    *(0x807dd00) = eax;
    eax = loc.camlList__26;
    *(0x807dd04) = eax;
    eax = loc.camlList__25;
    *(0x807dd0c) = eax;
    eax = loc.camlList__24;
    *(0x807dd10) = eax;
    eax = loc.camlList__23;
    *(0x807dd08) = eax;
    eax = loc.camlList__22;
    *(0x807dd14) = eax;
    eax = loc.camlList__21;
    *(0x807dd18) = eax;
    eax = loc.camlList__20;
    *(0x807dd1c) = eax;
    eax = loc.camlList__19;
    *(0x807dd20) = eax;
    eax = loc.camlList__18;
    *(0x807dd24) = eax;
    eax = loc.camlList__17;
    *(0x807dd28) = eax;
    eax = loc.camlList__16;
    *(0x807dd2c) = eax;
    eax = loc.camlList__15;
    *(0x807dd30) = eax;
    eax = loc.camlList__14;
    *(0x807dd44) = eax;
    eax = loc.camlList__13;
    *(0x807dd48) = eax;
    eax = loc.camlList__12;
    *(0x807dd4c) = eax;
    eax = loc.camlList__11;
    *(0x807dd50) = eax;
    eax = loc.camlList__10;
    *(0x807dd54) = eax;
    eax = loc.camlList__9;
    *(0x807dd58) = eax;
    eax = loc.camlList__8;
    *(0x807dd34) = eax;
    eax = loc.camlList__7;
    *(0x807dd3c) = eax;
    eax = .comment;
    *(0x807dd38) = eax;
    eax = loc.camlList__6;
    *(0x807dd40) = eax;
    eax = loc.camlList__5;
    *(0x807dd5c) = eax;
    eax = loc.camlList__4;
    *(0x807dd60) = eax;
    eax = loc.camlList__3;
    *(0x807dd70) = eax;
    eax = loc.camlList__2;
    *(0x807dd78) = eax;
    eax = camlList__1;
    *(0x807dd68) = eax;
    eax = .comment;
    *(0x807dd64) = eax;
    eax = .comment;
    *(0x807dd6c) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055740 */
#include <stdint.h>
 
int32_t camlChar_entry (void) {
    eax = loc.camlChar__5;
    *(loc.camlChar) = eax;
    eax = loc.camlChar__4;
    *(0x807e84c) = eax;
    eax = loc.camlChar__3;
    *(0x807e850) = eax;
    eax = loc.camlChar__2;
    *(0x807e854) = eax;
    eax = camlChar__1;
    *(0x807e858) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80563b0 */
#include <stdint.h>
 
int32_t camlString_entry (void) {
    eax = loc.camlString__24;
    *(loc.camlString) = eax;
    eax = loc.camlString__23;
    *(0x807e970) = eax;
    eax = loc.camlString__22;
    *(0x807e974) = eax;
    eax = loc.camlString__21;
    *(0x807e978) = eax;
    eax = loc.camlString__20;
    *(0x807e97c) = eax;
    eax = loc.camlString__19;
    *(0x807e984) = eax;
    eax = loc.camlString__18;
    *(0x807e980) = eax;
    eax = loc.camlString__17;
    *(0x807e988) = eax;
    eax = loc.camlString__16;
    *(0x807e9bc) = eax;
    eax = loc.camlString__15;
    *(0x807e9a8) = eax;
    eax = loc.camlString__14;
    *(0x807e9ac) = eax;
    eax = loc.camlString__13;
    *(0x807e9c0) = eax;
    eax = loc.camlString__12;
    *(0x807e9b0) = eax;
    eax = loc.camlString__11;
    *(0x807e9b4) = eax;
    eax = loc.camlString__10;
    *(0x807e9c4) = eax;
    eax = loc.camlString__9;
    *(0x807e98c) = eax;
    eax = loc.camlString__8;
    *(0x807e994) = eax;
    eax = loc.camlString__7;
    *(0x807e9c8) = eax;
    eax = loc.camlString__6;
    *(0x807e990) = eax;
    eax = loc.camlString__5;
    *(0x807e998) = eax;
    eax = loc.camlString__4;
    *(0x807e9a0) = eax;
    eax = loc.camlString__3;
    *(0x807e99c) = eax;
    eax = loc.camlString__2;
    *(0x807e9a4) = eax;
    eax = camlString__1;
    *(0x807e9b8) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056570 */
#include <stdint.h>
 
int32_t camlSys_entry (void) {
    eax = caml_sys_get_argv;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    eax = *(eax);
    *(0x807edf8) = eax;
    *(loc.camlSys) = ebx;
    eax = caml_sys_get_config;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    eax = *(eax);
    *(0x807ee00) = eax;
    *(0x807ee04) = ebx;
    ecx = .comment;
    ecx += 0xffffffec;
    ecx >>= 1;
    eax = 2;
    eax <<= cl;
    eax -= 3;
    eax += 2;
    *(0x807ee0c) = eax;
    ebx = .comment;
    ebx >>= 1;
    eax = .comment;
    eax >>= 1;
    if (eax < 0) {
        eax += 7;
    }
    eax >>= 3;
    eax <<= 1;
    eax *= ebx;
    eax -= 3;
    eax += 2;
    *(0x807ee08) = eax;
    caml_alloc3 ();
    ebx = eax + 4;
    *((ebx - 4)) = 0x400;
    *(ebx) = 1;
    *(0x807edfc) = ebx;
    eax = loc.camlSys__4;
    *(0x807ee10) = eax;
    *(0x807ee14) = 0xffffffff;
    *(0x807ee18) = 0xfffffffd;
    *(0x807ee1c) = 0xfffffffb;
    *(0x807ee20) = 0xfffffff9;
    *(0x807ee24) = 0xfffffff7;
    *(0x807ee28) = 0xfffffff5;
    *(0x807ee2c) = 0xfffffff3;
    *(0x807ee30) = 0xfffffff1;
    *(0x807ee34) = 0xffffffef;
    *(0x807ee38) = 0xffffffed;
    *(0x807ee3c) = 0xffffffeb;
    *(0x807ee40) = 0xffffffe9;
    *(0x807ee44) = 0xffffffe7;
    *(0x807ee48) = 0xffffffe5;
    *(0x807ee4c) = 0xffffffe3;
    *(0x807ee50) = 0xffffffe1;
    *(0x807ee54) = 0xffffffdf;
    *(0x807ee58) = 0xffffffdd;
    *(0x807ee5c) = 0xffffffdb;
    *(0x807ee60) = 0xffffffd9;
    *(0x807ee64) = 0xffffffd7;
    eax = ebx + 8;
    *((eax - 4)) = 0x400;
    *(eax) = "Sys.Break";
    *(0x807ee68) = eax;
    eax = camlSys__2;
    *(0x807ee6c) = eax;
    eax = "3.12.1";
    *(0x807ee70) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80586e0 */
#include <stdint.h>
 
int32_t camlObj_entry (void) {
    eax = loc.camlObj__4;
    *(loc.camlObj) = eax;
    eax = loc.camlObj__3;
    *(0x807fac0) = eax;
    eax = loc.camlObj__2;
    *(0x807fb00) = eax;
    eax = camlObj__1;
    *(0x807fb04) = eax;
    *(0x807fac4) = 0x1ed;
    *(0x807fac8) = 0x1ef;
    *(0x807facc) = 0x1f1;
    *(0x807fad0) = 0x1f3;
    *(0x807fad4) = 0x1f5;
    *(0x807fad8) = 0x1f7;
    *(0x807fadc) = 0x1f7;
    *(0x807fae0) = 0x1f9;
    *(0x807fae4) = 0x1fb;
    *(0x807fae8) = 0x1fd;
    *(0x807faec) = 0x1ff;
    *(0x807faf0) = 0x1ff;
    *(0x807faf4) = 0x7d1;
    *(0x807faf8) = 0x7d3;
    *(0x807fafc) = 0x7d5;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e630 */
#include <stdint.h>
 
int32_t camlPrintf_entry (void) {
    int32_t var_4h;
    ecx = loc.camlPrintf__38;
    eax = 0x14;
    caml_allocN (ecx);
    ebx = eax + 4;
    *((ebx - 4)) = 0x10f7;
    *(ebx) = sym.caml_curry2;
    *((ebx + 4)) = 5;
    *((ebx + 8)) = 0x805d5d0;
    *((ebx + 0xc)) = ecx;
    eax = 3;
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t) (ebx);
    ebx = eax;
    eax = 0x94;
    caml_allocN ();
    ecx = eax + 4;
    *((ecx - 4)) = 0xcf7;
    *(ecx) = sym.camlPrintf__index_of_literal_position_1044;
    *((ecx + 4)) = 3;
    eax = *(esp);
    *((ecx + 8)) = eax;
    edi = loc.camlPrintf__37;
    esi = ecx + 0x10;
    *((esi - 4)) = 0xcf7;
    *(esi) = sym.camlPrintf__to_string_1054;
    *((esi + 4)) = 3;
    *((esi + 8)) = edi;
    edx = ecx + 0x20;
    *((edx - 4)) = 0x1800;
    *(edx) = eax;
    eax = *((esp + 4));
    *((edx + 4)) = eax;
    *((edx + 8)) = ebx;
    *((edx + 0xc)) = ecx;
    *((edx + 0x10)) = edi;
    *((edx + 0x14)) = esi;
    *(0x8080cd8) = edx;
    eax = loc.camlPrintf__36;
    *(0x8080cdc) = eax;
    eax = loc.camlPrintf__35;
    *(0x8080ce0) = eax;
    eax = loc.camlPrintf__34;
    *(0x8080ce4) = eax;
    eax = loc.camlPrintf__33;
    *(0x8080ce8) = eax;
    eax = loc.camlPrintf__32;
    *(0x8080cec) = eax;
    eax = loc.camlPrintf__31;
    *(0x8080cf0) = eax;
    eax = loc.camlPrintf__30;
    *(0x8080cf4) = eax;
    eax = loc.camlPrintf__29;
    *(0x8080cf8) = eax;
    eax = loc.camlPrintf__28;
    *(0x8080cfc) = eax;
    eax = loc.camlPrintf__27;
    *(0x8080d00) = eax;
    eax = loc.camlPrintf__26;
    *(0x8080d04) = eax;
    eax = loc.camlPrintf__25;
    *(0x8080d08) = eax;
    eax = loc.camlPrintf__24;
    *(0x8080d0c) = eax;
    eax = loc.camlPrintf__23;
    *(0x8080d10) = eax;
    eax = loc.camlPrintf__22;
    *(0x8080d14) = eax;
    eax = loc.camlPrintf__21;
    *(0x8080d18) = eax;
    eax = loc.camlPrintf__20;
    *(0x8080d1c) = eax;
    eax = loc.camlPrintf__19;
    *(0x8080d20) = eax;
    eax = loc.camlPrintf__18;
    *(0x8080d24) = eax;
    eax = loc.camlPrintf__17;
    *(0x8080d28) = eax;
    eax = loc.camlPrintf__16;
    *(0x8080d2c) = eax;
    ebx = loc.camlPrintf__15;
    eax = ecx + 0x3c;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x805e1e0;
    *((eax + 0xc)) = ebx;
    *(0x8080d30) = eax;
    eax = loc.camlPrintf__14;
    *(0x8080d34) = eax;
    eax = loc.camlPrintf__13;
    *(0x8080d38) = eax;
    eax = loc.camlPrintf__12;
    *(0x8080cc4) = eax;
    eax = loc.camlPrintf__11;
    *(0x8080cb8) = eax;
    eax = loc.camlPrintf__10;
    *(loc.camlPrintf) = eax;
    eax = loc.camlPrintf__9;
    *(0x8080cb0) = eax;
    eax = loc.camlPrintf__8;
    *(0x8080cb4) = eax;
    eax = loc.camlPrintf__7;
    *(0x8080ccc) = eax;
    eax = loc.camlPrintf__6;
    *(0x8080cc0) = eax;
    eax = loc.camlPrintf__5;
    *(0x8080d3c) = eax;
    eax = loc.camlPrintf__4;
    *(0x8080d40) = eax;
    eax = loc.camlPrintf__3;
    *(0x8080d44) = eax;
    eax = loc.camlPrintf__2;
    *(0x8080cc8) = eax;
    eax = camlPrintf__1;
    *(0x8080cbc) = eax;
    eax = .comment;
    *(0x8080cd0) = eax;
    eax = .comment;
    *(esp) = eax;
    ebp = .comment;
    edi = .comment;
    esi = .comment;
    edx = .comment;
    ebx = .comment;
    eax = ecx + 0x50;
    *((eax - 4)) = 0x1400;
    *(eax) = ebp;
    *((eax + 4)) = edi;
    *((eax + 8)) = esi;
    *((eax + 0xc)) = edx;
    *((eax + 0x10)) = ebx;
    ebx = ecx + 0x68;
    *((ebx - 4)) = 0x800;
    edx = *(esp);
    *(ebx) = edx;
    *((ebx + 4)) = eax;
    esi = *(ebx);
    eax = ecx + 0x74;
    *((eax - 4)) = 0x1000;
    edx = *(esi);
    *(eax) = edx;
    edx = *((esi + 8));
    *((eax + 4)) = edx;
    edx = *((esi + 0x10));
    *((eax + 8)) = edx;
    edx = *((esi + 0x14));
    *((eax + 0xc)) = edx;
    ecx += 0x88;
    *((ecx - 4)) = 0x800;
    *(ecx) = eax;
    eax = *((ebx + 4));
    *((ecx + 4)) = eax;
    *(0x8080cd4) = ecx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061500 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_entry (void) {
    eax = 0x28;
    caml_allocN ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = 1;
    *(0x8082a84) = eax;
    ebx = loc.camlCamlinternalOO__69;
    *(0x8082a88) = ebx;
    ebx = loc.camlCamlinternalOO__68;
    *(0x8082a8c) = ebx;
    ebx = loc.camlCamlinternalOO__67;
    *(0x8082a60) = ebx;
    ebx = eax + 8;
    *((ebx - 4)) = 0x1400;
    *(ebx) = 3;
    *((ebx + 4)) = 3;
    *((ebx + 8)) = 3;
    *((ebx + 0xc)) = 7;
    *((ebx + 0x10)) = 0x21;
    *(0x8082a7c) = ebx;
    ebx = .comment;
    ebx >>= 1;
    if (ebx < 0) {
        ebx += 0xf;
    }
    ebx >>= 4;
    ebx = ebx + ebx + 1;
    *(0x8082a90) = ebx;
    *(0x8082a94) = 5;
    *(0x8082a98) = 1;
    ebx = loc.camlCamlinternalOO__66;
    *(loc.camlCamlinternalOO) = ebx;
    ebx = loc.camlCamlinternalOO__65;
    eax += 0x20;
    *((eax - 4)) = 0x400;
    *(eax) = ebx;
    eax = camlMap_fun_1920 ();
    *(0x8082a9c) = eax;
    ebx = loc.camlCamlinternalOO__64;
    caml_alloc1 ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = ebx;
    eax = camlMap_fun_1920 ();
    *(0x8082aa0) = eax;
    ebx = loc.camlCamlinternalOO__63;
    caml_alloc1 ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = ebx;
    eax = camlMap_fun_1920 ();
    *(0x8082aa4) = eax;
    eax = 0x34;
    caml_allocN ();
    ebx = eax + 4;
    *((ebx - 4)) = 0x400;
    *(ebx) = 1;
    eax = ebx + 8;
    *((eax - 4)) = 0x2000;
    *(eax) = 1;
    *((eax + 4)) = ebx;
    *((eax + 8)) = 1;
    *((eax + 0xc)) = 1;
    *((eax + 0x10)) = 1;
    *((eax + 0x14)) = 1;
    *((eax + 0x18)) = 1;
    *((eax + 0x1c)) = 1;
    *(0x8082a44) = eax;
    eax = ebx + 0x2c;
    *((eax - 4)) = 0x400;
    *(eax) = 1;
    *(0x8082aa8) = eax;
    eax = caml_obj_block;
    eax = caml_c_call (1);
    *(0x8082aac) = eax;
    eax = loc.camlCamlinternalOO__62;
    *(0x8082ab0) = eax;
    eax = loc.camlCamlinternalOO__61;
    *(0x8082ab4) = eax;
    eax = loc.camlCamlinternalOO__60;
    *(0x8082ab8) = eax;
    eax = loc.camlCamlinternalOO__59;
    *(0x8082abc) = eax;
    caml_alloc3 ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = 1;
    *(0x8082ac0) = eax;
    eax += 8;
    *((eax - 4)) = 0x400;
    *(eax) = 1;
    *(0x8082ac4) = eax;
    eax = loc.camlCamlinternalOO__58;
    *(0x8082a10) = eax;
    eax = loc.camlCamlinternalOO__57;
    *(0x8082a24) = eax;
    eax = loc.camlCamlinternalOO__56;
    *(0x8082a28) = eax;
    eax = loc.camlCamlinternalOO__55;
    *(0x8082a30) = eax;
    eax = loc.camlCamlinternalOO__54;
    *(0x8082a2c) = eax;
    eax = loc.camlCamlinternalOO__53;
    *(0x8082ac8) = eax;
    eax = loc.camlCamlinternalOO__52;
    *(0x8082a38) = eax;
    eax = loc.camlCamlinternalOO__51;
    *(0x8082a3c) = eax;
    eax = loc.camlCamlinternalOO__50;
    *(0x8082acc) = eax;
    eax = loc.camlCamlinternalOO__49;
    *(0x8082a14) = eax;
    eax = loc.camlCamlinternalOO__48;
    *(0x8082ad0) = eax;
    eax = loc.camlCamlinternalOO__47;
    *(0x8082a18) = eax;
    eax = loc.camlCamlinternalOO__46;
    *(0x8082a1c) = eax;
    eax = loc.camlCamlinternalOO__45;
    *(0x8082a20) = eax;
    eax = loc.camlCamlinternalOO__44;
    *(0x8082a40) = eax;
    eax = loc.camlCamlinternalOO__43;
    *(0x8082a48) = eax;
    eax = loc.camlCamlinternalOO__42;
    *(0x8082a4c) = eax;
    eax = loc.camlCamlinternalOO__41;
    *(0x8082a50) = eax;
    eax = loc.camlCamlinternalOO__40;
    *(0x8082a54) = eax;
    eax = loc.camlCamlinternalOO__39;
    *(0x8082a58) = eax;
    eax = loc.camlCamlinternalOO__38;
    *(0x8082a5c) = eax;
    eax = loc.camlCamlinternalOO__37;
    *(0x8082a64) = eax;
    eax = loc.camlCamlinternalOO__36;
    *(0x8082a68) = eax;
    eax = loc.camlCamlinternalOO__35;
    *(0x8082ad4) = eax;
    eax = loc.camlCamlinternalOO__34;
    *(0x8082a6c) = eax;
    eax = loc.camlCamlinternalOO__33;
    *(0x8082a70) = eax;
    eax = loc.camlCamlinternalOO__32;
    *(0x8082a74) = eax;
    eax = loc.camlCamlinternalOO__31;
    *(0x8082ad8) = eax;
    eax = loc.camlCamlinternalOO__30;
    *(0x8082adc) = eax;
    eax = loc.camlCamlinternalOO__29;
    *(0x8082a78) = eax;
    eax = loc.camlCamlinternalOO__28;
    *(0x8082ae0) = eax;
    eax = loc.camlCamlinternalOO__27;
    *(0x8082ae4) = eax;
    eax = loc.camlCamlinternalOO__26;
    *(0x8082ae8) = eax;
    eax = loc.camlCamlinternalOO__25;
    *(0x8082aec) = eax;
    eax = loc.camlCamlinternalOO__24;
    *(0x8082af0) = eax;
    eax = loc.camlCamlinternalOO__23;
    *(0x8082af4) = eax;
    eax = loc.camlCamlinternalOO__22;
    *(0x8082af8) = eax;
    eax = loc.camlCamlinternalOO__21;
    *(0x8082afc) = eax;
    eax = loc.camlCamlinternalOO__20;
    *(0x8082b00) = eax;
    eax = loc.camlCamlinternalOO__19;
    *(0x8082b04) = eax;
    eax = loc.camlCamlinternalOO__18;
    *(0x8082b08) = eax;
    eax = loc.camlCamlinternalOO__17;
    *(0x8082b0c) = eax;
    eax = loc.camlCamlinternalOO__16;
    *(0x8082b10) = eax;
    eax = loc.camlCamlinternalOO__15;
    *(0x8082b14) = eax;
    eax = loc.camlCamlinternalOO__14;
    *(0x8082b18) = eax;
    eax = loc.camlCamlinternalOO__13;
    *(0x8082b1c) = eax;
    eax = loc.camlCamlinternalOO__12;
    *(0x8082b20) = eax;
    eax = loc.camlCamlinternalOO__11;
    *(0x8082b24) = eax;
    eax = loc.camlCamlinternalOO__10;
    *(0x8082b28) = eax;
    eax = loc.camlCamlinternalOO__9;
    *(0x8082b2c) = eax;
    eax = loc.camlCamlinternalOO__8;
    *(0x8082b30) = eax;
    eax = loc.camlCamlinternalOO__7;
    *(0x8082b34) = eax;
    eax = loc.camlCamlinternalOO__6;
    *(0x8082b38) = eax;
    eax = loc.camlCamlinternalOO__5;
    *(0x8082b3c) = eax;
    eax = loc.camlCamlinternalOO__4;
    *(0x8082b40) = eax;
    eax = loc.camlCamlinternalOO__3;
    *(0x8082b44) = eax;
    eax = loc.camlCamlinternalOO__2;
    *(0x8082a34) = eax;
    eax = camlCamlinternalOO__1;
    *(0x8082a80) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ed60 */
#include <stdint.h>
 
int32_t loc_camlUnixLabels_code_begin (void) {
    eax = camlUnix;
    ebx = *(eax);
    *(loc.camlUnixLabels) = ebx;
    ebx = *((eax + 4));
    *(0x807bd5c) = ebx;
    ebx = *((eax + 8));
    *(0x807bd60) = ebx;
    ebx = *((eax + 0xc));
    *(0x807bd64) = ebx;
    ebx = *((eax + 0x10));
    *(0x807bd68) = ebx;
    ebx = *((eax + 0x14));
    *(0x807bd6c) = ebx;
    ebx = *((eax + 0x18));
    *(0x807bd70) = ebx;
    ebx = *((eax + 0x1c));
    *(0x807bd74) = ebx;
    ebx = *((eax + 0x20));
    *(0x807bd78) = ebx;
    ebx = *((eax + 0x24));
    *(0x807bd7c) = ebx;
    ebx = *((eax + 0x28));
    *(0x807bd80) = ebx;
    ebx = *((eax + 0x2c));
    *(0x807bd84) = ebx;
    ebx = *((eax + 0x30));
    *(0x807bd88) = ebx;
    ebx = *((eax + 0x34));
    *(0x807bd8c) = ebx;
    ebx = *((eax + 0x38));
    *(0x807bd90) = ebx;
    ebx = *((eax + 0x3c));
    *(0x807bd94) = ebx;
    ebx = *((eax + 0x40));
    *(0x807bd98) = ebx;
    *(0x807bd9c) = 1;
    *(0x807bda0) = 3;
    *(0x807bda4) = 5;
    ebx = *((eax + 0x50));
    *(0x807bda8) = ebx;
    ebx = *((eax + 0x54));
    *(0x807bdac) = ebx;
    ebx = *((eax + 0x58));
    *(0x807bdb0) = ebx;
    ebx = *((eax + 0x5c));
    *(0x807bdb4) = ebx;
    ebx = *((eax + 0x60));
    *(0x807bdb8) = ebx;
    ebx = *((eax + 0x64));
    *(0x807bdbc) = ebx;
    ebx = *((eax + 0x68));
    *(0x807bdc0) = ebx;
    ebx = *((eax + 0x6c));
    *(0x807bdc4) = ebx;
    ebx = *((eax + 0x70));
    *(0x807bdc8) = ebx;
    ebx = *((eax + 0x74));
    *(0x807bdcc) = ebx;
    ebx = *((eax + 0x78));
    *(0x807bdd0) = ebx;
    ebx = *((eax + 0x7c));
    *(0x807bdd4) = ebx;
    ebx = *((eax + 0x80));
    *(0x807bdd8) = ebx;
    ebx = *((eax + 0x84));
    *(0x807bddc) = ebx;
    ebx = *((eax + 0x88));
    *(0x807bde0) = ebx;
    ebx = *((eax + 0x8c));
    *(0x807bde4) = ebx;
    ebx = *((eax + 0x90));
    *(0x807bde8) = ebx;
    ebx = *((eax + 0x94));
    *(0x807bdec) = ebx;
    ebx = *((eax + 0x98));
    *(0x807bdf0) = ebx;
    ebx = *((eax + 0x9c));
    *(0x807bdf4) = ebx;
    ebx = *((eax + 0xa0));
    *(0x807bdf8) = ebx;
    ebx = *((eax + 0xa4));
    *(0x807bdfc) = ebx;
    ebx = *((eax + 0xa8));
    *(0x807be00) = ebx;
    ebx = *((eax + 0xac));
    *(0x807be04) = ebx;
    ebx = *((eax + 0xb0));
    *(0x807be08) = ebx;
    ebx = *((eax + 0xb4));
    *(0x807be0c) = ebx;
    ebx = *((eax + 0xb8));
    *(0x807be10) = ebx;
    ebx = *((eax + 0xbc));
    *(0x807be14) = ebx;
    ebx = *((eax + 0xc0));
    *(0x807be18) = ebx;
    ebx = *((eax + 0xc4));
    *(0x807be1c) = ebx;
    ebx = *((eax + 0xc8));
    *(0x807be20) = ebx;
    ebx = *((eax + 0xcc));
    *(0x807be24) = ebx;
    ebx = *((eax + 0xd0));
    *(0x807be28) = ebx;
    ebx = *((eax + 0xd4));
    *(0x807be2c) = ebx;
    ebx = *((eax + 0xd8));
    *(0x807be30) = ebx;
    ebx = *((eax + 0xdc));
    *(0x807be34) = ebx;
    ebx = *((eax + 0xe0));
    *(0x807be38) = ebx;
    ebx = *((eax + 0xe4));
    *(0x807be3c) = ebx;
    ebx = *((eax + 0xe8));
    *(0x807be40) = ebx;
    ebx = *((eax + 0xec));
    *(0x807be44) = ebx;
    ebx = *((eax + 0xf0));
    *(0x807be48) = ebx;
    ebx = *((eax + 0xf4));
    *(0x807be4c) = ebx;
    ebx = *((eax + 0xf8));
    *(0x807be50) = ebx;
    ebx = *((eax + 0xfc));
    *(0x807be54) = ebx;
    ebx = *((eax + 0x100));
    *(0x807be58) = ebx;
    ebx = *((eax + 0x104));
    *(0x807be5c) = ebx;
    ebx = *((eax + 0x108));
    *(0x807be60) = ebx;
    ebx = *((eax + 0x10c));
    *(0x807be64) = ebx;
    ebx = *((eax + 0x110));
    *(0x807be68) = ebx;
    ebx = *((eax + 0x114));
    *(0x807be6c) = ebx;
    ebx = *((eax + 0x118));
    *(0x807be70) = ebx;
    ebx = *((eax + 0x11c));
    *(0x807be74) = ebx;
    ebx = *((eax + 0x120));
    *(0x807be78) = ebx;
    ebx = *((eax + 0x124));
    *(0x807be7c) = ebx;
    ebx = *((eax + 0x128));
    *(0x807be80) = ebx;
    ebx = *((eax + 0x12c));
    *(0x807be84) = ebx;
    ebx = *((eax + 0x130));
    *(0x807be88) = ebx;
    ebx = *((eax + 0x134));
    *(0x807be8c) = ebx;
    ebx = *((eax + 0x138));
    *(0x807be90) = ebx;
    ebx = *((eax + 0x13c));
    *(0x807be94) = ebx;
    ebx = *((eax + 0x140));
    *(0x807be98) = ebx;
    ebx = *((eax + 0x144));
    *(0x807be9c) = ebx;
    ebx = *((eax + 0x148));
    *(0x807bea0) = ebx;
    ebx = *((eax + 0x14c));
    *(0x807bea4) = ebx;
    ebx = *((eax + 0x150));
    *(0x807bea8) = ebx;
    ebx = *((eax + 0x154));
    *(0x807beac) = ebx;
    ebx = *((eax + 0x158));
    *(0x807beb0) = ebx;
    ebx = *((eax + 0x15c));
    *(0x807beb4) = ebx;
    ebx = *((eax + 0x160));
    *(0x807beb8) = ebx;
    ebx = *((eax + 0x164));
    *(0x807bebc) = ebx;
    ebx = *((eax + 0x168));
    *(0x807bec0) = ebx;
    ebx = *((eax + 0x16c));
    *(0x807bec4) = ebx;
    ebx = *((eax + 0x170));
    *(0x807bec8) = ebx;
    ebx = *((eax + 0x174));
    *(0x807becc) = ebx;
    ebx = *((eax + 0x178));
    *(0x807bed0) = ebx;
    ebx = *((eax + 0x17c));
    *(0x807bed4) = ebx;
    ebx = *((eax + 0x180));
    *(0x807bed8) = ebx;
    ebx = *((eax + 0x184));
    *(0x807bedc) = ebx;
    ebx = *((eax + 0x188));
    *(0x807bee0) = ebx;
    ebx = *((eax + 0x18c));
    *(0x807bee4) = ebx;
    ebx = *((eax + 0x190));
    *(0x807bee8) = ebx;
    ebx = *((eax + 0x194));
    *(0x807beec) = ebx;
    ebx = *((eax + 0x198));
    *(0x807bef0) = ebx;
    ebx = *((eax + 0x19c));
    *(0x807bef4) = ebx;
    ebx = *((eax + 0x1a0));
    *(0x807bef8) = ebx;
    ebx = *((eax + 0x1a4));
    *(0x807befc) = ebx;
    ebx = *((eax + 0x1a8));
    *(0x807bf00) = ebx;
    ebx = *((eax + 0x1ac));
    *(0x807bf04) = ebx;
    ebx = *((eax + 0x1b0));
    *(0x807bf08) = ebx;
    ebx = *((eax + 0x1b4));
    *(0x807bf0c) = ebx;
    ebx = *((eax + 0x1b8));
    *(0x807bf10) = ebx;
    ebx = *((eax + 0x1bc));
    *(0x807bf14) = ebx;
    ebx = *((eax + 0x1c0));
    *(0x807bf18) = ebx;
    ebx = *((eax + 0x1c4));
    *(0x807bf1c) = ebx;
    ebx = *((eax + 0x1c8));
    *(0x807bf20) = ebx;
    ebx = *((eax + 0x1cc));
    *(0x807bf24) = ebx;
    ebx = *((eax + 0x1d0));
    *(0x807bf28) = ebx;
    ebx = *((eax + 0x1d4));
    *(0x807bf2c) = ebx;
    ebx = *((eax + 0x1d8));
    *(0x807bf30) = ebx;
    ebx = *((eax + 0x1dc));
    *(0x807bf34) = ebx;
    ebx = *((eax + 0x1e0));
    *(0x807bf38) = ebx;
    ebx = *((eax + 0x1e4));
    *(0x807bf3c) = ebx;
    ebx = *((eax + 0x1e8));
    *(0x807bf40) = ebx;
    ebx = *((eax + 0x1ec));
    *(0x807bf44) = ebx;
    ebx = *((eax + 0x1f0));
    *(0x807bf48) = ebx;
    ebx = *((eax + 0x1f4));
    *(0x807bf4c) = ebx;
    ebx = *((eax + 0x1f8));
    *(0x807bf50) = ebx;
    ebx = *((eax + 0x1fc));
    *(0x807bf54) = ebx;
    ebx = *((eax + 0x200));
    *(0x807bf58) = ebx;
    ebx = *((eax + 0x204));
    *(0x807bf5c) = ebx;
    ebx = *((eax + 0x208));
    *(0x807bf60) = ebx;
    ebx = *((eax + 0x20c));
    *(0x807bf64) = ebx;
    ebx = *((eax + 0x210));
    *(0x807bf68) = ebx;
    ebx = *((eax + 0x214));
    *(0x807bf6c) = ebx;
    ebx = *((eax + 0x218));
    *(0x807bf70) = ebx;
    ebx = *((eax + 0x21c));
    *(0x807bf74) = ebx;
    ebx = *((eax + 0x220));
    *(0x807bf78) = ebx;
    ebx = *((eax + 0x224));
    *(0x807bf7c) = ebx;
    ebx = *((eax + 0x228));
    *(0x807bf80) = ebx;
    ebx = *((eax + 0x22c));
    *(0x807bf84) = ebx;
    ebx = *((eax + 0x230));
    *(0x807bf88) = ebx;
    ebx = *((eax + 0x234));
    *(0x807bf8c) = ebx;
    ebx = *((eax + 0x238));
    *(0x807bf90) = ebx;
    ebx = *((eax + 0x23c));
    *(0x807bf94) = ebx;
    ebx = *((eax + 0x240));
    *(0x807bf98) = ebx;
    ebx = *((eax + 0x244));
    *(0x807bf9c) = ebx;
    ebx = *((eax + 0x248));
    *(0x807bfa0) = ebx;
    ebx = *((eax + 0x24c));
    *(0x807bfa4) = ebx;
    ebx = *((eax + 0x250));
    *(0x807bfa8) = ebx;
    ebx = *((eax + 0x254));
    *(0x807bfac) = ebx;
    ebx = *((eax + 0x258));
    *(0x807bfb0) = ebx;
    ebx = *((eax + 0x25c));
    *(0x807bfb4) = ebx;
    ebx = *((eax + 0x260));
    *(0x807bfb8) = ebx;
    ebx = *((eax + 0x264));
    *(0x807bfbc) = ebx;
    eax = *((eax + 0x268));
    *(0x807bfc0) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b900 */
#include <stdint.h>
 
int32_t camlSource_entry (void) {
    int32_t var_4h;
    int32_t var_8h;
    eax = loc.camlSource__4;
    *((esp + 4)) = eax;
    eax = loc.camlSource__3;
    *(esp) = eax;
    eax = caml_make_vect;
    eax = caml_c_call (0xb);
    *(0x80795c4) = eax;
    eax = 0;
    caml_alloc3 ();
    ebx = eax + 4;
    *((ebx - 4)) = 0xcf7;
    *(ebx) = sym.camlSource__toggle_init_1097;
    *((ebx + 4)) = 3;
    eax = *(esp);
    *((ebx + 8)) = eax;
    eax = *((esp + 4));
    eax = camlCamlinternalOO_make_class_1286 ();
    *(loc.camlSource) = eax;
    eax = 0;
    eax = 0x14;
    caml_allocN ();
    ebx = eax + 4;
    *((ebx - 4)) = 0x10f7;
    *(ebx) = sym.camlSource__nth_toggle_init_1119;
    *((ebx + 4)) = 3;
    eax = *(esp);
    *((ebx + 8)) = eax;
    eax = *((esp + 4));
    *((ebx + 0xc)) = eax;
    eax = camlCamlinternalOO_make_class_1286 ();
    *(0x80795b8) = eax;
    eax = *(loc.camlSys);
    eax = *((eax - 4));
    eax >>= 9;
    eax |= 1;
    if (eax > 3) {
        eax = *(loc.camlSys);
        eax = caml_int_of_string;
        caml_c_call (*((eax + 4)));
    } else {
        eax = 3;
    }
    *(0x80795bc) = eax;
    eax = camlSource;
    ecx = *(eax);
    ebx = 3;
    eax = 1;
    eax = caml_apply2 ();
    *(0x80795c0) = eax;
    ebx = 5;
    eax = .comment;
    if (ebx > eax) {
        goto label_0;
    }
    do {
        eax = .comment;
        ecx = .comment;
        ecx += 8;
        ebx = 0xcb583767;
        caml_send0 (ebx, eax);
        ecx = .comment;
        ecx += 0x10;
        ebx = 0x6370fee3;
        caml_send0 ();
        eax = *(esp);
        ebx = *(esp);
        eax += 2;
        *(esp) = eax;
        eax = *((esp + 4));
    } while (ebx != eax);
label_0:
    eax = loc.camlSource__2;
    eax = camlPrintf_printf_1393 ();
    eax = .comment;
    ecx = .comment;
    ecx += 8;
    ebx = 0xcb583767;
    caml_send0 (eax);
    ecx += 0xc;
    ebx = 0x6370fee3;
    caml_send0 ();
    ebx = *(esp);
    ecx = *(ebx);
    void (*0x80795c4)() ();
    eax = .comment;
    edx = *(eax);
    ecx = 7;
    ebx = 3;
    eax = 1;
    eax = caml_apply3 ();
    *((esp + 4)) = eax;
    ebx = 5;
    eax = .comment;
    if (ebx > eax) {
        goto label_1;
    }
    do {
        ecx = .comment;
        ebx = 0xcb583767;
        eax = *((esp + 4));
        caml_send0 (ebx, eax);
        ecx = .comment;
        ecx += 4;
        ebx = 0x6370fee3;
        caml_send0 ();
        eax = *(esp);
        ebx = *(esp);
        eax += 2;
        *(esp) = eax;
        eax = *((esp + 8));
    } while (ebx != eax);
label_1:
    eax = camlSource__1;
    eax = camlPrintf_printf_1393 ();
    esi = *((esp + 8));
    eax = caml_get_public_method (eax, 0xcb583767);
    ebx = eax;
    ecx = *(ebx);
    eax = esi;
    eax = void (*ecx)() ();
    esi = eax;
    eax = caml_get_public_method (esi, 0x6370fee3);
    ebx = eax;
    ecx = *(ebx);
    eax = esi;
    void (*ecx)() ();
    ebx = *(esp);
    ecx = *(ebx);
    void (*ecx)() ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c630 */
#include <stdint.h>
 
int32_t camlUnix_fun_2780 (void) {
    eax = unix_environment;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070e4c */
#include <stdint.h>
 
uint32_t caml_sys_time (void) {
    int32_t var_50h;
    int32_t var_4h;
    eax = ebp - 0x50;
    *((esp + 4)) = eax;
    *(esp) = 0;
    getrusage ();
    *(fp_stack--) = *((ebp - 0x50));
    *(fp_stack--) = *((ebp - 0x4c));
    *(fp_stack--) = *(0x80763a8);
    fp_stack[1] /= fp_stack[0];
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack[0] += fp_stack[2];
    fp_stack++;
    *(fp_stack--) = *((ebp - 0x48));
    fp_stack[0] += fp_stack[2];
    fp_stack++;
    *(fp_stack--) = *((ebp - 0x44));
    fp_stack[1] /= fp_stack[0];
    fp_stack++;
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067a99 */
#include <stdint.h>
 
int32_t caml_modify_generational_global_root (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = *(esi);
    edx = ebx;
    edx &= 1;
    if (edx == 0) {
        if (ebx < *(obj.caml_young_end)) {
            if (ebx <= *(obj.caml_young_start)) {
                goto label_3;
            }
            if ((al & 1) != 0) {
                goto label_4;
            }
            edx = eax;
            edx >>= 0x17;
            eax >>= 0xc;
            eax &= 0x7ff;
            edx = *((edx*4 + obj.caml_page_table));
            if ((*((edx + eax)) & 1) == 0) {
                goto label_1;
            }
            edx = esi;
            eax = caml_global_roots_old;
            caml_delete_global_root ();
            edx = esi;
            eax = caml_global_roots_young;
            al = caml_insert_global_root ();
        }
    } else {
label_3:
        if ((al & 1) != 0) {
            if (edx != 0) {
                goto label_1;
            }
label_4:
            if (ebx >= *(obj.caml_young_end)) {
                goto label_5;
            }
            if (ebx <= *(obj.caml_young_start)) {
                goto label_5;
            }
            edx = esi;
            eax = caml_global_roots_young;
            caml_insert_global_root ();
            goto label_1;
label_0:
            edx = esi;
            eax = caml_global_roots_old;
            eax = caml_insert_global_root ();
        } else {
            if (edx == 0) {
                goto label_1;
            }
            if (eax >= *(obj.caml_young_end)) {
                goto label_6;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_6;
            }
            edx = esi;
            eax = caml_global_roots_young;
            caml_delete_global_root ();
            goto label_1;
label_2:
            edx = esi;
            eax = caml_global_roots_old;
            caml_delete_global_root ();
        }
    }
    do {
label_1:
        *(esi) = ebx;
        ebx = *(esp);
        esi = *((esp + 4));
        return eax;
label_5:
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
    } while ((*((edx + eax)) & 1) == 0);
    goto label_0;
label_6:
    edx = eax;
    edx >>= 0x17;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) == 0) {
        goto label_1;
    }
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061ca8 */
#include <stdint.h>
 
uint32_t unix_chroot (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16c53;
    esi = *((ebp + 8));
    *(esp) = esi;
    eax = chroot ();
    if (eax == -1) {
        eax = ebx - 0x2633;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a474 */
#include <stdint.h>
 
void chroot (void) {
    chroot ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ece0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_undef_1304 (void) {
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Undefined_recursive_module;
            ebx = *((ebx + 8));
            *((eax + 4)) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
        camlCamlinternalOO_undef_1304 ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066ace */
#include <stdint.h>
 
uint32_t caml_main (char ** arg_8h) {
    int32_t var_20h;
    int32_t var_19h;
    char ** var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    caml_init_ieee_floats (ebx, esi, edi);
    caml_init_custom_operations ();
    eax = ebp - 0x19;
    *(obj.caml_top_of_stack) = eax;
    eax = getenv ("OCAMLRUNPARAM");
    ebx = eax;
    if (eax != 0) {
        goto label_0;
    }
    eax = getenv (0x807677f);
    ebx = eax;
    if (eax == 0) {
        goto label_1;
    }
    while (al != 0) {
        ebx++;
        eax -= 0x4f;
        if (al <= 0x27) {
            eax = (int32_t) al;
            uint32_t (*esi + eax*4)() ();
label_0:
            esi = 0x80767c8;
            edi = ebp - 0x20;
        }
        eax = *(ebx);
    }
label_1:
    eax = max_percent_free_init;
    eax = percent_free_init;
    eax = heap_chunk_init;
    eax = heap_size_init;
    eax = minor_heap_init;
    caml_init_gc (eax, eax, eax);
    eax = 0;
    edx = caml_atom_table;
    do {
        *((edx + eax*4)) = eax;
        eax++;
    } while (eax != 0x100);
    eax = caml_page_table_add (4, 0x808b120, obj.caml_frame_descriptors_mask);
    if (eax == 0) {
        eax = caml_data_segments;
        ebx = 0;
        esi = 0x8079174;
        edi = caml_data_segments;
        if (eax != 0) {
            goto label_2;
        }
        goto label_3;
    }
    eax = caml_fatal_error ("Fatal error: not enough memory for the initial page table");
    do {
label_2:
        edx = *((esi + ebx*8));
        eax = caml_page_table_add (4, eax, edx);
        if (eax != 0) {
            caml_fatal_error ("Fatal error: not enough memory for the initial page table");
        }
        ebx++;
        eax = *((edi + ebx*8));
    } while (eax != 0);
label_3:
    eax = caml_code_segments;
    *(obj.caml_code_area_start) = eax;
    ecx = *(loc.caml_startup__code_end);
    *(obj.caml_code_area_end) = ecx;
    eax = *(loc.camlPervasives__code_begin);
    if (eax == 0) {
        goto label_4;
    }
    ebx = caml_code_area_start;
    edx = 1;
    edi = 0x8079210;
    esi = caml_code_segments;
    do {
        if (ebx > eax) {
            ebx = eax;
        }
        eax = *((edi + edx*8));
        if (ecx < eax) {
            ecx = eax;
        }
        edx++;
        eax = *((esi + edx*8));
    } while (eax != 0);
    *(obj.caml_code_area_start) = ebx;
    *(obj.caml_code_area_end) = ecx;
label_4:
    caml_init_signals ();
    caml_debugger_init ();
    eax = *((ebp + 8));
    ebx = *(eax);
    eax = 0x8077448;
    if (ebx == 0) {
        ebx = eax;
    }
    eax = caml_executable_name (obj.proc_self_exe.2949, 0x100);
    edx = proc_self_exe.2949;
    if (eax != 0) {
        eax = caml_search_exe_in_path (ebx);
        edx = eax;
    }
    eax = *((ebp + 8));
    caml_sys_init (edx, eax);
    *((esp + 4)) = 0;
    *(esp) = obj.caml_termination_jmpbuf;
    eax = sigsetjmp ();
    if (eax != 0) {
        eax = caml_termination_hook;
        if (eax == 0) {
            goto label_5;
        }
        void (*eax)(uint32_t) (0);
    } else {
        eax = loc_caml_start_program ();
        edx = eax;
        edx &= 3;
        if (edx != 2) {
            goto label_5;
        }
        eax &= 0xfffffffc;
        caml_fatal_uncaught_exception (eax);
    }
label_5:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bff0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2602 (void) {
    eax = camlCamlinternalOO__code_end;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069d04 */
#include <stdint.h>
 
int32_t caml_alloc_table (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *((ebp + 0x10));
    *((ebx + 0x14)) = eax;
    *((ebx + 0x18)) = edx;
    eax = edx + eax;
    eax <<= 2;
    eax = caml_stat_alloc (ebx, esi);
    esi = eax;
    eax = *(ebx);
    if (eax != 0) {
        caml_stat_free (eax);
    }
    *(ebx) = esi;
    *((ebx + 0xc)) = esi;
    eax = *((ebx + 0x14));
    edx = esi + eax*4;
    *((ebx + 8)) = edx;
    *((ebx + 0x10)) = edx;
    eax += *((ebx + 0x18));
    eax = esi + eax*4;
    *((ebx + 4)) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805efb0 */
#include <stdint.h>
 
void camlCamlinternalOO_fun_1838 (void) {
    edx = *((ebx + 8));
    ecx = *(eax);
    ecx = *((ecx + edx*2 - 2));
    edx = *((ebx + 0x10));
    ebx = *((ebx + 0xc));
    ebx = *((eax + ebx*2 - 2));
    ebx = *((ebx + edx*2 - 2));
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80608b0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_app_meth_1395 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlCamlinternalOO__fun_1798;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80658bf */
#include <stdint.h>
 
uint32_t unix_lstat_64 (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1303c;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = lxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x2360;
        uerror (eax, esi);
    }
    edx = ebp - 0x68;
    eax = 1;
    stat_aux ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a1c4 */
#include <stdint.h>
 
void lxstat64 (void) {
    lxstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d611 */
#include <stdint.h>
 
int32_t caml_array_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    if (*((eax - 4)) == 0xfe) {
        eax = caml_array_get_float (eax, edx);
    } else {
        caml_array_get_addr (eax, edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805db60 */
#include <stdint.h>
 
int32_t camlPrintf_sub_format_for_printf_1135 (void) {
    ecx = eax;
    edx = .comment;
    ebx = .comment;
    eax = .comment;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807421b */
#include <stdint.h>
 
uint32_t caml_weak_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0x28)) = ebx;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x30)) = 0;
    edx = ebp - 0x28;
    *((ebp - 0x50)) = edx;
    edx = ebp - 0x50;
    *(obj.caml_local_roots) = edx;
    *((ebp - 0x48)) = 1;
    *((ebp - 0x4c)) = 2;
    edx = ebp - 0x2c;
    *((ebp - 0x44)) = edx;
    edx = ebp - 0x30;
    *((ebp - 0x40)) = edx;
    eax++;
    if (eax != 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.get");
label_0:
    eax = *((edx + eax*4));
    if (eax == *(obj.caml_weak_none)) {
        *((ebp - 0x2c)) = 1;
    } else {
        *((ebp - 0x30)) = eax;
        if (*(obj.caml_gc_phase) == 0) {
            if ((al & 1) != 0) {
                goto label_1;
            }
            ecx = eax;
            ecx >>= 0x17;
            edx = eax;
            edx >>= 0xc;
            edx &= 0x7ff;
            ecx = *((ecx*4 + obj.caml_page_table));
            if ((*((ecx + edx)) & 1) == 0) {
                goto label_1;
            }
            caml_darken (eax, 0);
        }
label_1:
        eax = caml_alloc_small (1, 0);
        *((ebp - 0x2c)) = eax;
        edx = *((ebp - 0x30));
        *(eax) = edx;
    }
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8074b90 */
#include <stdint.h>
 
int32_t caml_final_do_strong_roots (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    if (*(obj.old) == 0) {
        goto label_2;
    }
    ebx = 0;
    esi = 0;
    edi = *((ebp + 8));
    do {
        eax = ebx;
        eax += *(obj.final_table);
        eax = *(eax);
        void (*edi)(uint32_t, uint32_t) (eax, eax);
        esi++;
        ebx += 0xc;
    } while (*(obj.old) > esi);
label_2:
    eax = to_do_hd;
    *((ebp - 0x1c)) = eax;
    if (eax != 0) {
        goto label_3;
    }
    goto label_4;
    do {
label_0:
        eax = esi * 3;
        edx = *((ebp - 0x1c));
        edi = edx + eax*4;
        eax = edi + 8;
        eax = *((ebx + 8));
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        edi += 0xc;
        eax = *((ebx + 0xc));
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, edi);
        esi++;
        ebx += 0xc;
        eax = *((ebp - 0x1c));
    } while (*((eax + 4)) > esi);
label_1:
    edx = *((ebp - 0x1c));
    edx = *(edx);
    *((ebp - 0x1c)) = edx;
    if (edx == 0) {
        goto label_4;
    }
label_3:
    ebx = *((ebp - 0x1c));
    esi = 0;
    if (*((ebx + 4)) != 0) {
        goto label_0;
    }
    goto label_1;
label_4:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80666f9 */
#include <stdint.h>
 
uint32_t unix_wait (void) {
    int32_t wstatus;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x12202;
    caml_enter_blocking_section ();
    eax = ebp - 0xc;
    eax = wait (eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x21ae;
        uerror (eax, 0);
    }
    edx = *((ebp - 0xc));
    eax = esi;
    alloc_process_status ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a0c4 */
#include <stdint.h>
 
void wait (void) {
    wait ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068d5f */
#include <stdint.h>
 
int32_t caml_round_heap_chunk_size (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = caml_major_heap_increment;
    if (ebx >= eax) {
        eax = ebx;
    }
    eax = clip_heap_chunk_size ();
    if (ebx > eax) {
        caml_raise_out_of_memory ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ae80 */
#include <stdint.h>
 
int32_t caml_curry7_4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_5;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805aa60 */
#include <stdint.h>
 
int32_t camlBuffer_nth_1057 (void) {
    if (ebx >= 1) {
        ecx = *((eax + 4));
        if (ebx >= ecx) {
            goto label_0;
        }
        eax = *(eax);
        ebx >>= 1;
        ecx = *((eax - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edx = *((eax + ecx));
        ecx -= edx;
        if (ecx <= ebx) {
            goto label_1;
        }
        eax = *((eax + ebx));
        eax = eax + eax + 1;
        return eax;
    }
label_0:
    eax = "Buffer.nth";
    void (*0x804f900)() ();
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80502c0 */
#include <stdint.h>
 
uint32_t camlPervasives_string_of_format_1315 (void) {
    int32_t var_4h;
    ecx = eax;
    *((esp + 4)) = ecx;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    *(esp) = eax;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    eax = *((esp + 0x14));
    caml_blit_string (eax, 1, ebx, 1, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c443 */
#include <stdint.h>
 
int32_t caml_gt_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] > fp_stack[1]) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071d8c */
#include <stdint.h>
 
int32_t caml_gc_major_slice (int32_t arg_8h) {
    caml_empty_minor_heap ();
    eax = *((ebp + 8));
    eax >>= 1;
    caml_major_collection_slice (eax);
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805dd90 */
#include <stdint.h>
 
int32_t camlPrintf_list_iter_i_1201 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x805bf80;
            *((ecx + 0xc)) = edx;
            eax = 1;
            void (*0x805bf80)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c360 */
#include <stdint.h>
 
int32_t camlUnix_fun_2702 (void) {
    eax = unix_set_close_on_exec;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070a10 */
#include <stdint.h>
 
int32_t caml_hash_variant (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = 1;
    if (*(edx) == 0) {
        goto label_0;
    }
    do {
        eax >>= 1;
        eax *= 0xdf;
        ecx = *(edx);
        eax += ecx;
        eax = eax + eax + 1;
        edx++;
    } while (*(edx) != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cbc0 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_int_1650 (void) {
    eax = unix_getsockopt;
    caml_c_call (3);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e230 */
#include <stdint.h>
 
int32_t camlPrintf_scan_format_1278 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = edx;
    *((esp + 0x14)) = edi;
    eax = caml_extra_params;
    *((esp + 0x10)) = eax;
    edi = .comment;
    ebp = .comment;
    do {
        eax = caml_young_ptr;
        eax -= 0x64;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x805caa0;
            ebx = *(esp);
            *((eax + 0xc)) = ebx;
            edx = eax + 0x14;
            *((edx - 4)) = 0x4cf7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x805d380;
            *((edx + 0xc)) = 0x10f9;
            *((edx + 0x10)) = 0x804b220;
            *((edx + 0x14)) = 9;
            *((edx + 0x18)) = 0x805d2c0;
            *((edx + 0x1c)) = 0x20f9;
            *((edx + 0x20)) = 0x804b220;
            *((edx + 0x24)) = 9;
            *((edx + 0x28)) = 0x805cb20;
            ebx = *((esp + 4));
            *((edx + 0x2c)) = ebx;
            ecx = *((esp + 8));
            *((edx + 0x30)) = ecx;
            *((edx + 0x34)) = esi;
            ebx = *((esp + 0x14));
            *((edx + 0x38)) = ebx;
            ebx = *((esp + 0x10));
            *((edx + 0x3c)) = ebx;
            *((edx + 0x40)) = edi;
            *((edx + 0x44)) = ebp;
            *((edx + 0x48)) = eax;
            ecx += 2;
            ebx = 1;
            eax = *((esp + 0xc));
            void (*0x805d380)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80677ec */
#include <stdint.h>
 
int32_t caml_scan_global_roots (int32_t arg_8h) {
    ebx = *((ebp + 8));
    edx = caml_global_roots;
    eax = ebx;
    caml_iterate_global_roots (ebx);
    edx = caml_global_roots_young;
    eax = ebx;
    caml_iterate_global_roots ();
    edx = caml_global_roots_old;
    eax = ebx;
    caml_iterate_global_roots ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8051510 */
#include <stdint.h>
 
uint32_t camlArray_bubble_1174 (void) {
    eax = void (*0x8051540)() ();
    ecx = .comment;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *((eax + 4));
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ecx = *((ecx + 0xc));
    return camlArray_bubbledown_1170 (*(obj.caml_exception_pointer));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80596e0 */
#include <stdint.h>
 
int32_t camlMap_filter_1216 (void) {
    edx = eax;
    esi = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80587b0;
            eax = *((esi + 0xc));
            *((ecx + 0xc)) = eax;
            *((ecx + 0x10)) = edx;
            eax = 1;
            void (*0x80587b0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059e40 */
#include <stdint.h>
 
int32_t camlMap_compare_1311 (void) {
    int32_t var_4h;
    int32_t var_8h;
    esi = eax;
    *(esp) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x18f7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x8058950;
            eax = *((edx + 0xc));
            *((ebx + 0xc)) = eax;
            eax = *((edx + 0x10));
            *((ebx + 0x10)) = eax;
            *((ebx + 0x14)) = esi;
            ebx = 1;
            eax = ecx;
            eax = camlMap_cons_enum_1304 (ebx);
            ebx = 1;
            eax = *(esp);
            camlMap_cons_enum_1304 (eax);
            ebx = *((esp + 4));
            ecx = *((esp + 8));
            void (*0x8058950)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805a990 */
#include <stdint.h>
 
int32_t camlBuffer_contents_1044 (void) {
    ecx = *((eax + 4));
    ebx = 1;
    eax = *(eax);
    return camlString_sub_1046 ();
}


r2dec has crashed (info: SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8057790).
Please report the bug at https://github.com/radareorg/r2dec-js/issues
Use the option '--issue' or the command 'pddi' to generate 
the needed data for the issue.
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80500d0 */
#include <stdint.h>
 
int32_t camlPervasives_print_newline_1276 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x807c02c));
    eax = caml_ml_flush;
    caml_c_call (*(0x807c02c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804e060 */
#include <stdint.h>
 
int32_t camlUnix_close_process_in_2003 (void) {
    int32_t var_4h;
    ecx = eax;
    *(esp) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x401;
            *(ebx) = ecx;
            eax = "close_process_in";
            eax = camlUnix_find_proc_id_1997 ();
            *((esp + 4)) = eax;
            eax = *(esp);
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = *((esp + 4));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058b20 */
#include <stdint.h>
 
int32_t camlMap_height_1069 (void) {
    if (eax != 1) {
        eax = *((eax + 0x10));
        return eax;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805eb10 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1715 (void) {
    int32_t var_4h;
    eax = *(eax);
    ebx = *((ecx + 0xc));
    eax = camlList_mem_1161 (eax, ebx);
    if (eax == 1) {
        goto label_0;
    }
    eax = *((esp + 4));
    return eax;
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054b50 */
#include <stdint.h>
 
int32_t camlList_exists2_1153 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        eax = caml_apply2 (edx, eax, eax);
        if (eax != 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_0:
    if (ecx == 1) {
        eax = 1;
        return eax;
    }
label_1:
    eax = "List.exists2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060730 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_get_env_1371 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlCamlinternalOO__fun_1774;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a5ee */
#include <stdint.h>
 
int32_t caml_alloc_final (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = *((ebp + 0xc));
    eax = caml_final_custom_operations (eax);
    edx = *((ebp + 0x14));
    edx = *((ebp + 0x10));
    edx = *((ebp + 8));
    edx <<= 2;
    caml_alloc_custom (edx, edx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cf60 */
#include <stdint.h>
 
uint32_t caml_string_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    if (ebx >= 0) {
        eax = caml_string_length (esi);
        if (ebx < eax) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebx + esi)) = al;
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060380 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_create_object_1305 (void) {
    int32_t var_4h;
    *(esp) = eax;
    eax = caml_obj_block;
    eax = caml_c_call (0x1f1);
    esi = eax;
    *((esp + 4)) = esi;
    eax = *(esp);
    ebx = *((eax + 4));
    eax = *((esi - 4));
    if (eax != 0xfe) {
        caml_modify (esi, ebx);
    } else {
        *(fp_stack--) = *(ebx);
        *(esi) = fp_stack[0];
        fp_stack--;
    }
    ebx = .comment;
    eax = esi;
    camlCamlinternalOO_set_id_1033 ();
    eax = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066f37 */
#include <stdint.h>
 
int32_t caml_raise_with_arg (void) {
    int32_t var_4ch;
    int32_t var_48h_2;
    int32_t var_44h_2;
    int32_t var_40h_2;
    int32_t var_2ch;
    int32_t var_28h_2;
    int32_t var_24h_2;
    int32_t var_20h_2;
    int32_t var_1ch_2;
    int32_t var_18h;
    int32_t var_ch_2;
    int32_t var_4h_2;
    int32_t var_4h;
    eax = caml_local_roots;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x2c)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0x2c)) = eax;
    edx = *((ebp + 8));
    *(eax) = edx;
    edx = *((ebp + 0xc));
    eax = *((ebp - 0x2c));
    *((eax + 4)) = edx;
    eax = *((ebp - 0x2c));
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054f80 */
#include <stdint.h>
 
int32_t camlList_find_all_1205 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x8053850;
            *((ebx + 0xc)) = ecx;
            eax = 1;
            ecx = *(ebx);
            void (*ecx)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80602c0 */
#include <stdint.h>
 
uint32_t camlCamlinternalOO_make_class_store_1296 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = camlCamlinternalOO_create_table_1267 (ebx, ecx);
    ebx = *((esp + 4));
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t) (eax);
    eax = *(esp);
    camlCamlinternalOO_init_class_1274 (eax);
    eax = *((esp + 4));
    ebx = *((esp + 0xc));
    eax = *((esp + 0xc));
    eax += 4;
    caml_modify (eax, eax);
    eax = *((esp + 0xc));
    caml_modify (ebx, eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ff50 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_create_table_1267 (void) {
    int32_t var_4h;
    ebx = eax;
    if (ebx == 1) {
        eax = loc.camlCamlinternalOO__70;
        void (*0x805f2e0)() ();
    }
    eax = *(loc.camlCamlinternalOO);
    camlArray_map_1105 (ebx);
    eax = camlCamlinternalOO_new_table_1168 ();
    ebx = eax;
    *((esp + 4)) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x805ec30;
            *((eax + 0xc)) = ebx;
            ebx = *(esp);
            camlArray_iteri_1111 ();
            eax = *((esp + 4));
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ffe0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_init_class_1274 (void) {
    int32_t var_4h_2;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_4h;
    edx = .comment;
    ecx = *(eax);
    ebx = .comment;
    ebx = *(ebx);
    ebx = ebx + ecx - 3;
    *(edx) = ebx;
    eax = *((eax + 0x1c));
    ebx = 1;
    eax = camlList_rev_append_1051 (eax);
    esi = *((esp + 4));
    eax = *((esp + 4));
    eax += 0x1c;
    caml_modify (eax, eax);
    ecx = .comment;
    ecx >>= 1;
    if (ecx != 0) {
        ebx = *((esi + 4));
        eax = *((ebx - 4));
        eax >>= 9;
        if (eax <= 3) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax--;
        eax <<= 4;
        eax++;
        eax >>= 1;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        ebx = eax;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    ebx <<= 1;
    ebx += 7;
    eax = esi;
    void (*0x805f4c0)() ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075290 */
#include <stdint.h>
 
uint32_t caml_executable_name (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_68h;
    int32_t var_58h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    *((esp + 8)) = esi;
    *((esp + 4)) = ebx;
    *(esp) = "/proc/self/exe";
    eax = readlink ();
    if (eax != -1) {
        if (esi <= eax) {
            goto label_0;
        }
        *((ebx + eax)) = 0;
        eax = ebp - 0x68;
        *((esp + 8)) = eax;
        *((esp + 4)) = ebx;
        *(esp) = 3;
        eax = xstat64 ();
        if (eax != 0) {
            goto label_0;
        }
        edx = *((ebp - 0x58));
        edx &= 0xf000;
        if (edx == 0x8000) {
            goto label_1;
        }
    }
label_0:
    eax = 0xffffffff;
label_1:
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070763 */
#include <stdint.h>
 
uint32_t caml_input_val_from_string (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_6ch;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    esi = ebp - 0x3c;
    *((ebp - 0x50)) = esi;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    eax = edx + eax + 8;
    *(obj.intern_input_malloced) = 0;
    ecx = eax + 4;
    edi = *((ecx - 1));
    edx = *(eax);
    edx <<= 0x18;
    edx = edi + edx;
    edi = *((ecx - 3));
    edi <<= 0x10;
    edi = edx + edi;
    edx = *((ecx - 2));
    edx <<= 8;
    edx = edi + edx;
    ecx = eax + 8;
    edi = *((ecx - 4));
    edi <<= 0x18;
    *((ebp - 0x6c)) = edi;
    edi = *((ecx - 1));
    edi += *((ebp - 0x6c));
    *((ebp - 0x6c)) = edi;
    edi = *((ecx - 3));
    edi <<= 0x10;
    edi += *((ebp - 0x6c));
    ecx = *((ecx - 2));
    ecx <<= 8;
    edi += ecx;
    eax += 0xc;
    *(obj.intern_src) = eax;
    eax = edi;
    intern_alloc (ebx, esi, edi);
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    eax = edx + eax + 0x14;
    *(obj.intern_src) = eax;
    eax = esi;
    intern_rec ();
    eax = edi;
    intern_add_to_heap ();
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050310 */
#include <stdint.h>
 
int32_t camlPervasives_at_exit_1322 (void) {
    ecx = eax;
    eax = .comment;
    ebx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlPervasives__fun_1500;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            caml_modify (*(0x807c118), eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b0f5 */
#include <stdint.h>
 
int32_t caml_notequal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80882e0) {
        eax = compare_free_stack ();
    }
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806be47 */
#include <stdint.h>
 
int32_t caml_int64_of_int (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax >>= 1;
    edx = eax;
    edx >>= 0x1f;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80608f0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_app_const_const_1399 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlCamlinternalOO__fun_1802;
            *((eax + 4)) = 3;
            *((eax + 8)) = edx;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054770 */
#include <stdint.h>
 
int32_t camlList_iter_1074 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        void (*ecx)(uint32_t, uint32_t) (edx, eax);
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c170 */
#include <stdint.h>
 
int32_t caml_int32_bits_of_float (int32_t arg_8h) {
    int32_t var_10h;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x10));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80545a0 */
#include <stdint.h>
 
int32_t camlList_length_1034 (void) {
    ebx = eax;
    eax = 1;
    return camlList_length_aux_1030 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071dbc */
#include <stdint.h>
 
int32_t caml_gc_set (int32_t arg_8h) {
    char * var_4h;
    int32_t var_8h;
    esi = *((ebp + 8));
    ebx = *((ebp + 8));
    eax = *((esi + 0xc));
    eax >>= 1;
    *(obj.caml_verb_gc) = eax;
    eax = *((esi + 8));
    eax >>= 1;
    eax = norm_pfree (ebx, esi);
    if (eax != *(obj.caml_percent_free)) {
        *(obj.caml_percent_free) = eax;
        caml_gc_message (0x20, "New space overhead: %d%%\n", eax);
    }
    eax = *((ebx + 0x10));
    eax >>= 1;
    eax = norm_pmax ();
    if (eax != *(obj.caml_percent_max)) {
        *(obj.caml_percent_max) = eax;
        caml_gc_message (0x20, "New max overhead: %d%%\n", eax);
    }
    eax = *((ebx + 4));
    eax >>= 1;
    eax = norm_heapincr ();
    eax <<= 2;
    if (eax != *(obj.caml_major_heap_increment)) {
        *(obj.caml_major_heap_increment) = eax;
        eax >>= 0xa;
        caml_gc_message (0x20, "New heap increment size: %luk bytes\n", eax);
    }
    ebx = *((ebx + 0x18));
    ebx >>= 1;
    eax = 1;
    if (ebx >= 2) {
        ebx = eax;
    }
    if (ebx != *(obj.caml_allocation_policy)) {
        caml_gc_message (0x20, "New allocation policy: %d\n", ebx);
        caml_set_allocation_policy (ebx);
    }
    eax = *(esi);
    eax >>= 1;
    eax <<= 2;
    eax = norm_minsize ();
    ebx = eax;
    if (eax != *(obj.caml_minor_heap_size)) {
        eax >>= 0xa;
        caml_gc_message (0x20, "New minor heap size: %luk bytes\n", eax);
        caml_set_minor_heap_size (ebx);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806796f */
#include <stdint.h>
 
int32_t caml_scan_global_young_roots (int32_t arg_8h) {
    ebx = *((ebp + 8));
    edx = caml_global_roots;
    eax = ebx;
    caml_iterate_global_roots (ebx);
    edx = caml_global_roots_young;
    eax = ebx;
    caml_iterate_global_roots ();
    ebx = .comment;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        edx = *(ebx);
        eax = caml_global_roots_old;
        caml_insert_global_root ();
        ebx = *((ebx + 4));
    } while (ebx != 0);
    eax = .comment;
    if (eax == 0) {
        goto label_0;
    }
    do {
        ebx = *((eax + 4));
        caml_stat_free (eax);
        if (ebx == 0) {
            goto label_0;
        }
        eax = ebx;
    } while (1);
label_0:
    edx = .comment;
    if (edx < 0) {
        goto label_1;
    }
    eax = 0;
    ecx = 0x80849a4;
    do {
        *((ecx + eax*4)) = 0;
        eax++;
    } while (eax <= edx);
label_1:
    *(0x80849e8) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056d80 */
#include <stdint.h>
 
int32_t camlHashtbl_do_bucket_1132 (void) {
    int32_t var_4h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 8));
        edx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ebx = edx;
        caml_apply2 (ecx, ebx);
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ce4d */
#include <stdint.h>
 
uint32_t caml_string_compare (int32_t arg_8h, int32_t arg_ch) {
    uint32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    if (ebx != edi) {
        eax = caml_string_length (ebx);
        *((ebp - 0x10)) = eax;
        eax = caml_string_length (edi);
        edx = eax;
        eax = *((ebp - 0x10));
        if (eax <= *((ebp - 0x10))) {
            eax = edx;
        }
        esi = ebx;
        ecx = eax;
        __asm ("repe cmpsb byte [esi], byte ptr es:[edi]");
        al = (eax > eax) ? 1 : 0;
        cl = (eax < eax) ? 1 : 0;
        al -= cl;
        eax = (int32_t) al;
        if (eax < 0) {
            goto label_0;
        }
        if (eax > 0) {
            goto label_1;
        }
        if (*((ebp - 0x10)) < edx) {
            goto label_0;
        }
        if (*((ebp - 0x10)) > edx) {
            goto label_1;
        }
    }
    eax = 1;
    goto label_2;
label_0:
    eax = 0xffffffff;
    goto label_2;
label_1:
    eax = 3;
label_2:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c100 */
#include <stdint.h>
 
int32_t camlUnix_fun_2632 (void) {
    eax = unix_getgid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80606f0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_get_var_1368 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xcf7;
            *(eax) = sym.camlCamlinternalOO__fun_1770;
            *((eax + 4)) = 3;
            *((eax + 8)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060ce0 */
#include <stdint.h>
 
uint32_t camlCamlinternalOO_new_cache_1474 (void) {
    eax = camlCamlinternalOO_new_method_1185 (eax);
    ebx = eax;
    edx = eax;
    edx >>= 1;
    eax = edx;
    if (eax < 0) {
        eax++;
    }
    eax &= 0xfffffffe;
    edx -= eax;
    eax = edx + edx + 1;
    if (eax != 1) {
        ecx = .comment;
        ecx >>= 1;
        if (ecx != 0) {
            esi = *(esp);
            edx = *((esi + 4));
            eax = *((edx - 4));
            eax >>= 9;
            if (eax <= 3) {
                goto label_0;
            }
            eax = *((edx + 4));
            eax--;
            eax <<= 4;
            eax++;
            eax >>= 1;
            edx:eax = (int64_t) eax;
            eax = edx:eax / ecx;
            edx = edx:eax % ecx;
        } else {
            eax = caml_bucket_Division_by_zero;
            eax = caml_raise_exn ();
        }
        eax <<= 1;
        eax += 5;
        if (ebx > eax) {
            goto label_1;
        }
        eax = esi;
        eax = camlCamlinternalOO_new_method_1185 ();
        ebx = eax;
    }
label_1:
    eax = *(esp);
    ecx = *((eax + 4));
    eax = *((ecx - 4));
    eax >>= 9;
    if (eax > ebx) {
        caml_modify (ecx + ebx*2 - 2, 1);
        eax = ebx;
        return eax;
    }
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b8ae */
#include <stdint.h>
 
uint32_t caml_format_int (void) {
    char * format;
    int32_t var_8h_5;
    int32_t var_4h_4;
    int32_t var_8h_4;
    esi = *((ebp + 0xc));
    ecx = ebp - 0x28;
    eax = ebp - 0x49;
    eax = ebp - 0x48;
    edx = 0x807760b;
    eax = *((ebp + 8));
    eax = parse_format (ebx, esi);
    ebx = eax;
    eax = *((ebp - 0x49));
    if (al != 0x6f) {
        if (al <= 0x6f) {
            if (al != 0x58) {
                goto label_0;
            }
        } else {
            if (al == 0x75) {
                goto label_1;
            }
            if (al != 0x78) {
                goto label_0;
            }
        }
    }
label_1:
    esi >>= 1;
    eax = ebp - 0x28;
    sprintf (ebx, eax, esi);
    goto label_2;
label_0:
    esi >>= 1;
    eax = ebp - 0x28;
    sprintf (ebx, eax, esi);
label_2:
    eax = caml_copy_string (ebx);
    esi = eax;
    eax = ebp - 0x48;
    if (ebx != eax) {
        caml_stat_free (ebx);
    }
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bb7f */
#include <stdint.h>
 
int32_t caml_nativeint_mul (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax *= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8057d00 */
#include <stdint.h>
 
int32_t camlHashtbl_find_all_1105 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlHashtbl__find_in_bucket_1108;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            eax = *((edi + 4));
            esi = *((eax - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = caml_hash_univ_param (0x15, 0xc9, ecx);
                eax >>= 1;
                ecx = esi;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            ecx = *((edi + 4));
            eax = *((ecx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ecx + edx*2 - 2));
            void (*0x8056b70)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c258 */
#include <stdint.h>
 
int32_t caml_int32_or (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax |= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063aac */
#include <stdint.h>
 
int32_t unix_lockf (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_1eh;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x14e53;
    eax = *((ebp + 0x10));
    esi = *((ebp + 8));
    esi >>= 1;
    *((ebp - 0x1e)) = 1;
    eax >>= 1;
    if (eax < 0) {
        *((ebp - 0x1c)) = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebp - 0x18)) = edx;
        eax = -eax;
        *((ebp - 0x14)) = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebp - 0x10)) = edx;
    } else {
        *((ebp - 0x1c)) = 0;
        *((ebp - 0x18)) = 0;
        *((ebp - 0x14)) = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebp - 0x10)) = edx;
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax <= 5) {
        edx = ebx;
        edx -= *((ebx + eax*4 - 0x14dec));
        void (*edx)() ();
    }
    errno_location ();
    *(eax) = 0x16;
    eax = ebx - 0x2504;
    return uerror (eax, 0);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80614b0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_stats_1605 (void) {
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = .comment;
            ebx = *(ebx);
            *(eax) = ebx;
            ebx = .comment;
            ebx = *(ebx);
            *((eax + 4)) = ebx;
            ebx = .comment;
            ebx = *(ebx);
            *((eax + 8)) = ebx;
            return eax;
        }
        caml_call_gc ();
        camlCamlinternalOO_stats_1605 ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a85d */
#include <stdint.h>
 
int32_t caml_alloc_dummy_float (int32_t arg_8h) {
    int32_t var_4h;
    edx = *((ebp + 8));
    eax = 0x808b124;
    edx &= 0xfffffffe;
    if (edx != 0) {
        caml_alloc (edx, 0);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e9f0 */
#include <stdint.h>
 
uint32_t camlCamlinternalOO_fun_1709 (int32_t arg_ch) {
    int32_t var_4h_2;
    int32_t var_4h;
    edx = .comment;
    edx = *((edx + 0xc));
    ecx = *((ecx + 0x10));
    ecx = *(ecx);
    eax = camlMap_add_1108 (ecx, ebx);
    ebx = *((esp + 4));
    caml_modify (*((ebx + 0x10)), eax);
    eax = void (*0x805ea50)() ();
    ecx = loc.caml_exn_Not_found;
    ebx = *(eax);
    if (ebx == ecx) {
        ebx = 3;
    } else {
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = .comment;
        ecx = *((eax + 0x54));
        eax = *((ebx + 0xc));
        ebx = *((eax + 0xc));
        eax = *((esp + 0xc));
        eax = camlMap_find_1117 (*(obj.caml_exception_pointer));
        ebx = eax;
    }
    eax = .comment;
    edx = *((eax + 0xc));
    eax = *(esp);
    eax = *((eax + 0x14));
    ecx = *(eax);
    eax = *((esp + 4));
    eax = camlMap_add_1108 ();
    eax = *((esp + 4));
    caml_modify (*((eax + 0x14)), eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c0ee */
#include <stdint.h>
 
int32_t caml_int64_neg (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    eax = -eax;
    edx += 0;
    edx = -edx;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ff40 */
#include <stdint.h>
 
int32_t camlPervasives_really_input_1235 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        void (*0x804fea0)() ();
    }
label_0:
    eax = "really_input";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064248 */
#include <stdint.h>
 
uint32_t unix_readlink (int32_t arg_8h) {
    int32_t var_1008h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x146b0;
    esi = *((ebp + 8));
    *((esp + 8)) = 0xfff;
    eax = ebp - 0x1008;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = readlink ();
    if (eax == -1) {
        eax = ebx - 0x24b4;
        uerror (eax, esi);
    }
    *((ebp + eax - 0x1008)) = 0;
    eax = ebp - 0x1008;
    caml_copy_string (eax);
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a674 */
#include <stdint.h>
 
void readlink (void) {
    readlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c23c */
#include <stdint.h>
 
int32_t caml_int32_xor (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax ^= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ba3f */
#include <stdint.h>
 
int32_t caml_nativeint_of_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050370 */
#include <stdint.h>
 
int32_t camlPervasives_do_at_exit_1325 (void) {
    eax = .comment;
    ebx = *(eax);
    eax = 1;
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c202 */
#include <stdint.h>
 
int32_t caml_int32_shift_right (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c3b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2712 (void) {
    eax = unix_access;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b680 */
#include <stdint.h>
 
void camlSource_method_activate_1113 (void) {
    ecx = *((ebx + 0x10));
    *((eax + ecx*2 - 2)) += 2;
    ecx = *((ebx + 0xc));
    edx = *((eax + ecx*2 - 2));
    ecx = *((ebx + 0x10));
    ecx = *((eax + ecx*2 - 2));
    if (ecx >= edx) {
        esi = *((ebx + 8));
        ecx = *((ebx + 8));
        edx = *((eax + ecx*2 - 2));
        ecx = 4;
        ecx -= edx;
        *((eax + esi*2 - 2)) = ecx;
        ebx = *((ebx + 0x10));
        *((eax + ebx*2 - 2)) = 1;
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061fcc */
#include <stdint.h>
 
int32_t unix_execvpe (void) {
    int32_t var_1ch;
    int32_t var_ch_4;
    int32_t var_8h_3;
    int32_t var_4h_3;
    int32_t var_8h_4;
    int32_t var_10h_2;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1692c;
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    edi = eax;
    esi = *((ebx - 0x14));
    eax = *(esi);
    *((ebp - 0x1c)) = eax;
    eax = *((ebp + 0x10));
    eax = cstringvect (eax);
    *(esi) = eax;
    *((esp + 4)) = edi;
    eax = *((ebp + 8));
    *(esp) = eax;
    execvp ();
    caml_stat_free (edi);
    eax = *(esi);
    caml_stat_free (eax);
    eax = *((ebp - 0x1c));
    *(esi) = eax;
    eax = *((ebp + 8));
    eax = ebx - 0x25ff;
    return uerror (eax, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b644 */
#include <stdint.h>
 
int32_t caml_int_of_string (int32_t arg_8h) {
    edx = 0x1f;
    eax = *((ebp + 8));
    parse_intnat ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052cf0 */
#include <stdint.h>
 
int32_t camlArray_fold_left_1139 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    edi = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x400;
    *(esi) = ebx;
    edx = 1;
    eax = *((ecx - 4));
    ebx = *((ecx - 4));
    ebx &= 0xff;
    if (ebx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    eax += 0xfffffffe;
    if (edx > eax) {
        goto label_3;
    }
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = esi;
    *(esp) = ecx;
    *((esp + 4)) = edi;
    do {
        ecx = *(esp);
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            ebx = *((ecx + edx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + edx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = *(esi);
        ecx = *((esp + 4));
        eax = caml_apply2 ();
        esi = *((esp + 0xc));
        caml_modify (esi, eax);
        edx = *((esp + 0xc));
        ebx = *((esp + 0xc));
        edx += 2;
        *((esp + 0xc)) = edx;
        eax = *((esp + 0x10));
    } while (ebx != eax);
label_3:
    eax = *(esi);
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80734d0 */
#include <stdint.h>
 
int32_t caml_obj_truncate (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    uint32_t var_24h;
    int32_t var_20h;
    uint32_t var_1ch;
    uint32_t var_4h;
    edi = *((ebp + 0xc));
    edi >>= 1;
    eax = *((ebp + 8));
    *((ebp - 0x28)) = eax;
    eax -= 4;
    *((ebp - 0x2c)) = eax;
    edx = *(eax);
    *((ebp - 0x20)) = edx;
    eax = (int32_t) dl;
    *((ebp - 0x24)) = eax;
    edx >>= 0xa;
    *((ebp - 0x1c)) = edx;
    eax = edi + edi;
    if (*((ebp - 0x24)) == 0xfe) {
        edi = eax;
    }
    if (edi != 0) {
        if (edi <= edx) {
            goto label_0;
        }
    }
    caml_invalid_argument (0x8077484);
label_0:
    if (edi == *((ebp - 0x1c))) {
        goto label_1;
    }
    if (*((ebp - 0x24)) > 0xfa) {
        goto label_2;
    }
    if (edi >= *((ebp - 0x1c))) {
        goto label_2;
    }
    edx = *((ebp - 0x28));
    ebx = edx + edi*4;
    esi = edi;
    *((ebp - 0x30)) = edi;
    edi = *((ebp - 0x1c));
    do {
        caml_modify (ebx, 1);
        esi++;
        ebx += 4;
    } while (edi > esi);
    edi = *((ebp - 0x30));
label_2:
    eax = *((ebp - 0x1c));
    eax--;
    eax -= edi;
    eax <<= 0xa;
    eax++;
    edx = *((ebp - 0x28));
    *((edx + edi*4)) = eax;
    eax = *((ebp - 0x20));
    eax &= 0x300;
    eax += *((ebp - 0x24));
    edi <<= 0xa;
    edi = eax + edi;
    eax = *((ebp - 0x2c));
    *(eax) = edi;
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060970 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_app_const_meth_1409 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlCamlinternalOO__fun_1810;
            *((eax + 4)) = 3;
            *((eax + 8)) = edx;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073714 */
#include <stdint.h>
 
int32_t caml_static_free (int32_t arg_8h) {
    eax = *((ebp + 8));
    caml_stat_free (eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b450 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1568 (void) {
    ecx = eax;
    edx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            eax = *((edx + 0x10));
            *((ebx + 4)) = eax;
            ecx = *((edx + 8));
            eax = *((edx + 0xc));
            eax += 2;
            void (*0x805bfe0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068309 */
#include <stdint.h>
 
int32_t caml_fatal_error (char * s) {
    FILE * stream;
    eax = stderr;
    eax = *((ebp + 8));
    fputs (eax, eax);
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049dd4 */
#include <stdint.h>
 
void fputs (void) {
    fputs ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061a88 */
#include <stdint.h>
 
uint32_t unix_inet_addr_of_string (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16e73;
    esi = *((ebp + 8));
    eax = ebp - 0xc;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 2;
    eax = inet_pton ();
    if (eax > 0) {
        eax = ebp - 0xc;
        alloc_inet_addr (eax);
    } else {
        eax = ebp - 0x1c;
        *((esp + 8)) = eax;
        *((esp + 4)) = esi;
        *(esp) = 0xa;
        eax = inet_pton ();
        if (eax > 0) {
            eax = ebp - 0x1c;
            alloc_inet6_addr (eax);
        } else {
            eax = ebx - 0x2652;
            caml_failwith (eax);
        }
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bae3 */
#include <stdint.h>
 
int32_t caml_nativeint_and (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax &= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054920 */
#include <stdint.h>
 
int32_t camlList_iter2_1111 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        caml_apply2 (edx, eax, eax);
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_0:
    if (ecx == 1) {
        eax = 1;
        return eax;
    }
label_1:
    eax = "List.iter2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c120 */
#include <stdint.h>
 
int32_t camlUnix_fun_2636 (void) {
    eax = unix_geteuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80606b0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_get_const_1365 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xcf7;
            *(eax) = sym.camlCamlinternalOO__fun_1766;
            *((eax + 4)) = 3;
            *((eax + 8)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e470 */
#include <stdint.h>
 
int32_t camlPrintf_fprintf_1391 (void) {
    ebx = eax;
    eax = loc.camlPrintf__43;
    return camlPrintf_kfprintf_1386 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80572d0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_all_1210 (void) {
    int32_t var_4h_4;
    int32_t var_8h_2;
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlHashtbl__find_in_bucket_1213;
            *((eax + 4)) = 3;
            esi = *((ecx + 0xc));
            *((eax + 8)) = esi;
            *((eax + 0xc)) = ebx;
            esi = *((edx + 4));
            esi = *((esi - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = *((ecx + 0x10));
                eax = *((eax + 8));
                edx = *((eax + 4));
                ecx = *(edx);
                eax = ebx;
                ebx = edx;
                eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, esi);
                ebx = 0x7fffffff;
                eax &= ebx;
                eax >>= 1;
                ecx = *((esp + 8));
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            eax = *(esp);
            ebx = *((eax + 4));
            eax = *((ebx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ebx + edx*2 - 2));
            ebx = *((esp + 4));
            void (*0x80567d0)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80538e0 */
#include <stdint.h>
 
int32_t camlList_part_1215 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
label_0:
        *((esp + 4)) = eax;
        if (ecx == 1) {
            goto label_3;
        }
        eax = *((ecx + 4));
        eax = *(ecx);
        ebx = *((edx + 0xc));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t, uint32_t) (edx, ebx);
        if (eax == 1) {
            goto label_1;
        }
label_2:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        ebx = *((esp + 4));
        *((eax + 4)) = ebx;
        ebx = *((esp + 8));
        ecx = *((esp + 0xc));
        edx = *((esp + 0x10));
    } while (1);
label_1:
    eax = caml_young_ptr;
    eax -= 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x800;
    eax = *(esp);
    *(ebx) = eax;
    eax = *((esp + 8));
    *((ebx + 4)) = eax;
    eax = *((esp + 4));
    ecx = *((esp + 0xc));
    edx = *((esp + 0x10));
    goto label_0;
label_3:
    ecx = 1;
    eax = ebx;
    ebx = ecx;
    eax = camlList_rev_append_1051 ();
    ebx = 1;
    eax = *((esp + 4));
    eax = camlList_rev_append_1051 (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *(esp);
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
label_4:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804e2b0 */
#include <stdint.h>
 
uint32_t camlUnix_open_connection_2018 (int32_t arg_ch) {
    int32_t var_4h;
    eax = camlUnix_domain_of_sockaddr_1529 (eax);
    eax = unix_socket;
    eax = caml_c_call (eax);
    eax = void (*0x804e300)(uint32_t) (eax);
    *(esp) = eax;
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *(esp);
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ebx = *((esp + 8));
    eax = unix_connect;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    camlUnix_try_set_close_on_exec_1366 ();
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    *((esp + 8)) = eax;
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *((esp + 8));
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c9a0 */
#include <stdint.h>
 
int32_t camlUnix_domain_of_sockaddr_1529 (void) {
    ebx = *((eax - 4));
    if (ebx != 0) {
        ebx = *(eax);
        eax = *((ebx - 4));
        eax >>= 0xa;
        eax = eax*4 - 1;
        ebx = *((ebx + eax));
        eax -= ebx;
        eax = eax + eax + 1;
        if (eax == 0x21) {
            eax = 5;
            return eax;
        }
        eax = 3;
        return eax;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c8f0 */
#include <stdint.h>
 
uint32_t camlUnix_try_set_close_on_exec_1366 (void) {
    eax = void (*0x804c920)() ();
    ecx = loc.caml_exn_Invalid_argument;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = 1;
        return eax;
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_set_close_on_exec;
    caml_c_call (eax);
    eax = 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806edbd */
#include <stdint.h>
 
int32_t caml_serialize_block_1 (int32_t arg_8h, int32_t arg_ch) {
    void ** s2;
    size_t * n;
    eax = *((ebp + 0xc));
    ebx = *((ebp + 0xc));
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    eax = *((ebp + 8));
    eax = extern_ptr;
    memmove (eax, eax, ebx);
    *(obj.extern_ptr) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bb9c */
#include <stdint.h>
 
int32_t caml_nativeint_sub (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = *((ebp + 0xc));
    eax -= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073371 */
#include <stdint.h>
 
int32_t caml_get_public_method (int32_t arg_8h, int32_t arg_ch) {
    ebx = *((ebp + 0xc));
    eax = *((ebp + 8));
    edi = *(eax);
    ecx = *(edi);
    edx = 3;
    esi = edi;
    goto label_2;
    do {
        eax = edx + ecx;
        eax >>= 1;
        eax |= 1;
        if (*((esi + eax*4)) > ebx) {
            goto label_1;
        }
label_0:
        edx = eax;
    } while (ecx > eax);
    goto label_3;
label_1:
    ecx = eax - 2;
label_2:
    if (edx >= ecx) {
        goto label_3;
    }
    eax = ecx + edx;
    eax >>= 1;
    eax |= 1;
    if (ebx >= *((edi + eax*4))) {
        goto label_0;
    }
    goto label_1;
label_3:
    edx = edi + edx*4;
    eax = 0;
    if (*(edx) == ebx) {
        eax = *((edx - 4));
    }
    esi = ebx;
    edi = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804be90 */
#include <stdint.h>
 
int32_t camlUnix_fun_2863 (void) {
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065863 */
#include <stdint.h>
 
uint32_t unix_fstat_64 (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1309d;
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = 3;
    eax = fxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x2366;
        uerror (eax, 0);
    }
    edx = ebp - 0x68;
    eax = 1;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a714 */
#include <stdint.h>
 
void fxstat64 (void) {
    fxstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c3d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2716 (void) {
    eax = unix_fchown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80754a2 */
#include <stdint.h>
 
int32_t caml_dlopen (int32_t arg_8h, int32_t arg_10h) {
    int32_t var_4h;
    eax = *((ebp + 0x10));
    eax -= eax;
    al = 0;
    eax += 0x1102;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    dlopen ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a494 */
#include <stdint.h>
 
void dlopen (void) {
    dlopen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80552b0 */
#include <stdint.h>
 
int32_t camlList_stable_sort_1248 (void) {
    int32_t var_4h;
    esi = eax;
    *((esp + 4)) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x54;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x8053a00;
            *((edx + 0xc)) = esi;
            ecx = edx + 0x14;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry3;
            *((ecx + 4)) = 7;
            *((ecx + 8)) = 0x8053b00;
            *((ecx + 0xc)) = esi;
            eax = edx + 0x28;
            *((eax - 4)) = 0x28f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x80540c0;
            *((eax + 0xc)) = 0x10f9;
            *((eax + 0x10)) = 0x804b3a0;
            *((eax + 0x14)) = 5;
            *((eax + 0x18)) = 0x8053c00;
            *((eax + 0x1c)) = esi;
            *((eax + 0x20)) = edx;
            *((eax + 0x24)) = ecx;
            eax = 1;
            eax = camlList_length_aux_1030 (eax);
            if (eax < 5) {
                eax = *((esp + 4));
                return eax;
            }
            ebx = *((esp + 4));
            ecx = *(esp);
            void (*0x80540c0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805edc0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1766 (void) {
    eax = *((ebx + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059f60 */
#include <stdint.h>
 
int32_t camlMap_cardinal_1343 (void) {
    int32_t var_4h;
    do {
label_0:
        if (eax == 1) {
            goto label_1;
        }
        ecx = *((eax + 0xc));
        ebx = *(eax);
        eax = ecx;
        eax = camlMap_cardinal_1343 (ebx);
    } while (1);
    eax = *(esp);
    eax = camlMap_cardinal_1343 (eax);
    goto label_0;
    ebx = *((esp + 4));
    eax += ebx;
    eax++;
    return eax;
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064308 */
#include <stdint.h>
 
int32_t unix_rewinddir (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x145f8;
    eax = *((ebp + 8));
    eax = *(eax);
    if (eax == 0) {
        eax = ebx - 0x24a4;
        eax = unix_error (9, eax, 0);
    }
    *(esp) = eax;
    rewinddir ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a544 */
#include <stdint.h>
 
void rewinddir (void) {
    rewinddir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070eb1 */
#include <stdint.h>
 
uint32_t caml_sys_file_exists (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_4h;
    int32_t var_8h;
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    *((esp + 4)) = eax;
    *(esp) = 3;
    eax = xstat64 ();
    eax -= eax;
    eax &= 2;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c18b */
#include <stdint.h>
 
int32_t caml_int32_of_string (int32_t arg_8h) {
    edx = 0x20;
    eax = *((ebp + 8));
    eax = parse_intnat ();
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ee00 */
#include <stdint.h>
 
uint32_t camlCamlinternalOO_fun_1782 (void) {
    ebx = *((ecx + 0xc));
    caml_modify (eax + ebx*2 - 2, ebx);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063a5c */
#include <stdint.h>
 
int32_t unix_listen (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14ea4;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = listen (eax, eax);
    if (eax == -1) {
        eax = ebx - 0x250b;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a034 */
#include <stdint.h>
 
void listen (void) {
    listen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059740 */
#include <stdint.h>
 
int32_t camlMap_partition_1225 (void) {
    edx = eax;
    esi = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8058840;
            eax = *((esi + 0xc));
            *((ecx + 0xc)) = eax;
            *((ecx + 0x10)) = edx;
            eax = loc.camlMap__18;
            void (*0x8058840)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80761e0 */
#include <stdint.h>
 
uint32_t libc_csu_init (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x2721;
    _init ();
    edi = ebx - 0x14c;
    eax = ebx - 0x14c;
    edi -= eax;
    edi >>= 2;
    if (edi == 0) {
        goto label_0;
    }
    esi = 0;
    do {
        eax = *((ebp + 0x10));
        eax = *((ebp + 0xc));
        eax = *((ebp + 8));
        uint32_t (*ebx + esi*4 - 0x14c)(uint32_t, uint32_t, uint32_t) (eax, eax, eax);
        esi++;
    } while (esi < edi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055a30 */
#include <stdint.h>
 
int32_t camlString_iter_1062 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = 1;
    edx = *((ebx - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    esi = *((ebx + edx));
    edx -= esi;
    edx = edx + edx - 1;
    if (ecx > edx) {
        goto label_0;
    }
    do {
        ecx >>= 1;
        eax = *(esp);
        eax = *((eax + ecx));
        eax = eax + eax + 1;
        ebx = *((esp + 4));
        ecx = *(ebx);
        void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, ecx);
        ecx = *((esp + 8));
        ebx = *((esp + 8));
        ecx += 2;
        *((esp + 8)) = ecx;
        eax = *((esp + 0xc));
    } while (ebx != eax);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062e30 */
#include <stdint.h>
 
int32_t unix_getnameinfo (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_14bch;
    int32_t var_14b8h;
    int32_t var_10b8h;
    int32_t var_b8h;
    int32_t var_b4h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x15acb;
    eax = *((ebx - 0x18));
    edi = *(eax);
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x44)) = edi;
    edx = ebp - 0x44;
    *(eax) = edx;
    *((ebp - 0x3c)) = 1;
    *((ebp - 0x40)) = 3;
    eax = ebp - 0x1c;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x30)) = eax;
    eax = ebp - 0xb8;
    esi = ebp - 0xb4;
    eax = *((ebp + 8));
    get_sockaddr (eax, esi, eax);
    eax = ebx + 0xb8a4;
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x14bc)) = eax;
    caml_enter_blocking_section ();
    eax = *((ebp - 0x14bc));
    *((esp + 0x18)) = eax;
    *((esp + 0x14)) = 0x400;
    eax = ebp - 0x14b8;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = 0x1000;
    eax = ebp - 0x10b8;
    *((esp + 8)) = eax;
    eax = *((ebp - 0xb8));
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = getnameinfo ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi != 0) {
        caml_raise_not_found ();
    }
    eax = ebp - 0x10b8;
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = ebp - 0x14b8;
    eax = caml_copy_string (eax);
    *((ebp - 0x20)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0x24)) = eax;
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    eax = *((ebp - 0x24));
    *((eax + 4)) = edx;
    eax = *((ebx - 0x18));
    *(eax) = edi;
    eax = *((ebp - 0x24));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a6a4 */
#include <stdint.h>
 
void getnameinfo (void) {
    getnameinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bef0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2572 (void) {
    eax = unix_tcsetattr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050070 */
#include <stdint.h>
 
uint32_t camlPervasives_print_float_1272 (void) {
    eax = camlPervasives_string_of_float_1140 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060930 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_app_const_var_1404 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlCamlinternalOO__fun_1806;
            *((eax + 4)) = 3;
            *((eax + 8)) = edx;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073a77 */
#include <stdint.h>
 
int32_t caml_register_named_value (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_1ch;
    char * src;
    esi = *((ebp + 8));
    eax = *((ebp + 8));
    eax = hash_value_name (ebx, esi, edi);
    *((ebp - 0x1c)) = eax;
    ebx = *((eax*4 + obj.named_value_table));
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        eax = strcmp (esi, eax);
        if (eax == 0) {
            eax = *((ebp + 0xc));
            *(ebx) = eax;
            goto label_1;
        }
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    edi = esi;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ecx += 0xb;
    eax = caml_stat_alloc (ecx);
    ebx = eax;
    eax = eax + 8;
    strcpy (eax, esi);
    edx = *((ebp + 0xc));
    *(ebx) = edx;
    eax = named_value_table;
    ecx = *((ebp - 0x1c));
    edx = *((eax + ecx*4));
    *((ebx + 4)) = edx;
    *((eax + ecx*4)) = ebx;
    caml_register_global_root (ebx);
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c200 */
#include <stdint.h>
 
int32_t camlUnix_fun_2662 (void) {
    eax = unix_sigsuspend;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bb46 */
#include <stdint.h>
 
int32_t caml_nativeint_div (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    ecx = *((ebp + 0xc));
    ecx = *((ecx + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            goto label_0;
        }
    }
    eax = edx;
    edx >>= 0x1f;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    caml_copy_nativeint (eax);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050d50 */
#include <stdint.h>
 
int32_t camlArray_maxson_1155 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = ebx;
    eax += ebx;
    esi = eax + ebx + 3;
    esi += 0xfffffffd;
    *((esp + 8)) = esi;
label_6:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_7;
    }
    edi = eax + 4;
    *((edi - 4)) = 0x400;
    *(edi) = esi;
    eax = esi;
    eax += 4;
    if (eax < edx) {
        *((esp + 4)) = edi;
        *(esp) = ecx;
        edx = esi;
        edx += 2;
        edi = *((ecx + 0x10));
        eax = *((edi - 4));
        ebx = *((edi - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            eax >>= 9;
            if (eax <= edx) {
                goto label_8;
            }
            ebx = *((edi + edx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= edx) {
                goto label_9;
            }
label_5:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((edi + edx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        edx = *((ecx + 0x10));
        eax = *((edx - 4));
        edi = *((edx - 4));
        edi &= 0xff;
        if (edi != 0xfe) {
            eax >>= 9;
            if (eax <= esi) {
                goto label_11;
            }
            eax = *((edx + esi*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_12;
            }
label_4:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_13;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + esi*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((ecx + 0xc));
        eax = caml_apply2 ();
        if (eax < 1) {
            ebx = *((esp + 8));
            ebx += 2;
            eax = *((esp + 4));
            *(eax) = ebx;
        }
        ecx = *((esp + 8));
        ecx += 4;
        esi = *(esp);
        edx = *((esi + 0x10));
        eax = *((edx - 4));
        ebx = *((edx - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_14;
            }
            ebx = *((edx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_15;
            }
label_3:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_16;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ecx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 4));
        edx = *(eax);
        ecx = *((esi + 0x10));
        eax = *((ecx - 4));
        edi = *((ecx - 4));
        edi &= 0xff;
        if (edi != 0xfe) {
            eax >>= 9;
            if (eax <= edx) {
                goto label_17;
            }
            eax = *((ecx + edx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= edx) {
                goto label_18;
            }
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_19;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + edx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((esi + 0xc));
        eax = caml_apply2 ();
        if (eax < 1) {
            ebx = *((esp + 8));
            ebx += 4;
            eax = *((esp + 4));
            *(eax) = ebx;
        }
        eax = *((esp + 4));
        eax = *(eax);
        return eax;
    }
    *((esp + 4)) = ebx;
    *(esp) = edx;
    eax = esi;
    eax += 2;
    if (eax < edx) {
        ebx = esi;
        ebx += 2;
        edx = *((ecx + 0x10));
        edi = *((edx - 4));
        eax = *((edx - 4));
        eax &= 0xff;
        if (eax != 0xfe) {
            eax = edi;
            eax >>= 9;
            if (eax <= ebx) {
                goto label_20;
            }
            ebx = *((edx + ebx*2 - 2));
        } else {
            eax = edi;
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_21;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_22;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            ebx = eax;
        }
        edx = *((ecx + 0x10));
        edi = *((edx - 4));
        eax = *((edx - 4));
        eax &= 0xff;
        if (eax != 0xfe) {
            eax = edi;
            eax >>= 9;
            if (eax <= esi) {
                goto label_23;
            }
            eax = *((edx + esi*2 - 2));
        } else {
            eax = edi;
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_24;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_25;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + esi*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((ecx + 0xc));
        eax = caml_apply2 ();
        if (eax >= 1) {
            goto label_26;
        }
        eax = *((esp + 8));
        eax += 2;
        return eax;
    }
label_26:
    eax = *((esp + 8));
    ebx = *(esp);
    if (eax >= ebx) {
        goto label_27;
    }
    return eax;
    do {
label_27:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = .comment;
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_25:
    caml_call_gc ();
    goto label_0;
label_22:
    caml_call_gc ();
    goto label_1;
label_19:
    caml_call_gc ();
    goto label_2;
label_16:
    caml_call_gc ();
    goto label_3;
label_13:
    caml_call_gc ();
    goto label_4;
label_10:
    caml_call_gc ();
    goto label_5;
label_7:
    caml_call_gc ();
    goto label_6;
label_24:
    caml_ml_array_bound_error ();
label_23:
    caml_ml_array_bound_error ();
label_21:
    caml_ml_array_bound_error ();
label_20:
    caml_ml_array_bound_error ();
label_18:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064a07 */
#include <stdint.h>
 
uint32_t unix_recv (int32_t socket, void * s1, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    int32_t var_4038h;
    int32_t var_4034h;
    int32_t var_4030h;
    int32_t var_402ch;
    int32_t var_4018h;
    void * buffer;
    size_t length;
    int32_t flags;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x13ef4;
    eax = ebx + 0xb904;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    edi = eax;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4038)) = edx;
    edx = ebp - 0x4038;
    *(eax) = edx;
    *((ebp - 0x4030)) = 1;
    *((ebp - 0x4034)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x402c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    caml_enter_blocking_section ();
    *((esp + 0xc)) = edi;
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    *((esp + 8)) = esi;
    eax = ebp - 0x4018;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = recv (eax, eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x2478;
        uerror (eax, 0);
    }
    eax = ebp - 0x4018;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    memmove (eax, eax, esi);
    edx = *((ebp - 0x4038));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049fb4 */
#include <stdint.h>
 
void recv (void) {
    recv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a57a */
#include <stdint.h>
 
uint32_t caml_update_dummy (int32_t arg_8h, int32_t arg_ch) {
    uint32_t var_1ch;
    int32_t var_4h;
    edi = *((ebp + 0xc));
    eax = edi - 4;
    ecx = *(eax);
    edx = *(eax);
    esi = *((ebp + 8));
    *((esi - 4)) = dl;
    if (dl != 0xfe) {
        ecx >>= 0xa;
        *((ebp - 0x1c)) = ecx;
        ebx = 0;
        if (ecx != 0) {
            goto label_0;
        }
        goto label_1;
    }
    edx = *(eax);
    edx >>= 0xb;
    if (edx == 0) {
        goto label_1;
    }
    eax = 0;
    do {
        *(fp_stack--) = *((edi + eax*8));
        *((esi + eax*8)) = fp_stack[0];
        fp_stack--;
        eax++;
    } while (edx > eax);
    goto label_1;
    do {
label_0:
        eax = *((edi + ebx*4));
        caml_modify (esi, eax);
        ebx++;
        esi += 4;
    } while (*((ebp - 0x1c)) > ebx);
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064060 */
#include <stdint.h>
 
int32_t unix_putenv (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14898;
    eax = *((ebp + 8));
    eax = caml_string_length (eax);
    edi = eax;
    eax = *((ebp + 0xc));
    eax = caml_string_length (eax);
    *((ebp - 0x1c)) = eax;
    eax += edi;
    *((ebp - 0x20)) = eax;
    eax += 2;
    eax = caml_stat_alloc (eax);
    esi = eax;
    eax = *((ebp + 8));
    memmove (esi, eax, edi);
    *((esi + edi)) = 0x3d;
    eax = *((ebp - 0x1c));
    eax = *((ebp + 0xc));
    eax = esi + edi + 1;
    memmove (eax, eax, eax);
    eax = *((ebp - 0x20));
    *((esi + eax + 1)) = 0;
    *(esp) = esi;
    eax = putenv ();
    if (eax == -1) {
        eax = *((ebp + 8));
        eax = ebx - 0x24c8;
        uerror (eax, eax);
    }
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a4e4 */
#include <stdint.h>
 
void putenv (void) {
    putenv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a882 */
#include <stdint.h>
 
int32_t caml_alloc_dummy (int32_t arg_8h) {
    int32_t var_4h;
    edx = *((ebp + 8));
    eax = 0x808b124;
    edx >>= 1;
    if (edx != 0) {
        caml_alloc (edx, 0);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805c0d0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1587 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h_2;
    int32_t var_14h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    *((esp + 0x18)) = eax;
    *((esp + 0x14)) = ebx;
    *((esp + 0x10)) = ecx;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = esi;
    *((esp + 4)) = edi;
    eax = caml_extra_params;
    *(esp) = eax;
    eax = caml_make_vect;
    eax = caml_c_call (0xd);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0x18));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0x18));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 0x14));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 0x14));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 0x10));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 0x10));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 7) {
            goto label_6;
        }
        eax = *((esp + 0xc));
        eax = ebx;
        eax += 0xc;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 7) {
            goto label_7;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *((ebx + 0x18)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 9) {
            goto label_8;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 0x10;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 9) {
            goto label_9;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 0x20)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 0xb) {
            goto label_10;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 0x14;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 0xb) {
            goto label_11;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x28)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b5d0)() ();
label_11:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050a40 */
#include <stdint.h>
 
int32_t camlArray_size_1065 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ebx = *((ebx - 4));
        edx = *((ebx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            ebx >>= 9;
        } else {
            ebx >>= 0xa;
        }
        ebx |= 1;
        eax += ebx;
        eax--;
        ebx = ecx;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069eae */
#include <stdint.h>
 
int32_t caml_alloc_dependent_memory (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 2;
    *(obj.caml_dependent_size) += eax;
    *(obj.caml_dependent_allocated) += eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a078 */
#include <stdint.h>
 
int32_t caml_adjust_gc_speed (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    int32_t var_ch;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    ecx = 1;
    if (eax == 0) {
        eax = ecx;
    }
    if (eax <= edx) {
        edx = eax;
    }
    ecx = 0;
    *((ebp - 0x10)) = edx;
    *((ebp - 0xc)) = ecx;
    *(fp_stack--) = *((ebp - 0x10));
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    fp_stack[0] += *(obj.caml_extra_heap_resources);
    *(obj.caml_extra_heap_resources) = fp_stack[0];
    *(fp_stack--) = 1.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        *(fp_stack--) = 1.0;
        *(obj.caml_extra_heap_resources) = fp_stack[0];
        fp_stack--;
        caml_urge_major_slice ();
    }
    eax = caml_minor_heap_size;
    eax >>= 2;
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] *= *(0x8076ad0);
    eax = caml_stat_heap_size;
    eax >>= 2;
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    *(fp_stack--) = *(obj.caml_extra_heap_resources);
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        caml_urge_major_slice ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c220 */
#include <stdint.h>
 
int32_t camlUnix_fun_2666 (void) {
    eax = unix_sigprocmask;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80623a4 */
#include <stdint.h>
 
int32_t unix_ftruncate_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1655c;
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    *((esp + 4)) = eax;
    *((esp + 8)) = edx;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = ftruncate64 ();
    if (eax == -1) {
        eax = ebx - 0x25a3;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ab70 */
#include <stdint.h>
 
int32_t caml_curry9_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d630 */
#include <stdint.h>
 
uint32_t camlPrintf_bad_conversion_1057 (void) {
    ebx = loc.camlPrintf__52;
    eax = camlPervasives_$5e_1112 (ebx, ecx);
    ebx = eax;
    eax = " in format string ``";
    eax = camlPervasives_$5e_1112 ();
    eax = *(esp);
    camlPervasives_string_of_int_1130 (eax);
    ebx = *((esp + 4));
    eax = camlPervasives_$5e_1112 ();
    ebx = eax;
    eax = ", at char number ";
    eax = camlPervasives_$5e_1112 ();
    eax = 3;
    ebx = *((esp + 8));
    camlString_make_1038 (eax);
    ebx = *(esp);
    eax = camlPervasives_$5e_1112 ();
    ebx = eax;
    eax = "Printf: bad conversion %";
    camlPervasives_$5e_1112 ();
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c580 */
#include <stdint.h>
 
int32_t camlUnix_fun_2762 (void) {
    eax = unix_waitpid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80735d0 */
#include <stdint.h>
 
uint32_t caml_obj_dup (int32_t arg_8h) {
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    void * s2;
    size_t n;
    edi = caml_local_roots;
    *((ebp - 0x38)) = edi;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    eax = ebp - 0x3c;
    *((ebp - 0x50)) = eax;
    eax = *((ebp + 8));
    edx = eax - 4;
    esi = *(edx);
    esi >>= 0xa;
    if (esi == 0) {
        *(obj.caml_local_roots) = edi;
        goto label_0;
    }
    eax = *(edx);
    if (eax > 0xfa) {
        eax = caml_alloc (esi, eax);
        *((ebp - 0x3c)) = eax;
        esi <<= 2;
        edx = *((ebp + 8));
        eax = memcpy (eax, edx, esi);
        goto label_1;
    }
    if (esi > 0x100) {
        goto label_2;
    }
    eax = caml_alloc_small (esi, eax);
    *((ebp - 0x3c)) = eax;
    esi <<= 2;
    eax = 0;
    do {
        edx = *((ebp + 8));
        ecx = *((edx + eax));
        edx = *((ebp - 0x3c));
        *((edx + eax)) = ecx;
        eax += 4;
    } while (eax != esi);
    goto label_1;
label_2:
    eax = caml_alloc_shr (esi, eax);
    *((ebp - 0x3c)) = eax;
    ebx = 0;
    do {
        eax = ebx*4;
        edx = *((ebp + 8));
        edx = *((eax + edx));
        eax += *((ebp - 0x3c));
        caml_initialize (eax, edx);
        ebx++;
    } while (esi > ebx);
label_1:
    *(obj.caml_local_roots) = edi;
    eax = *((ebp - 0x3c));
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067907 */
#include <stdint.h>
 
int32_t caml_register_generational_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *(edx);
    if ((al & 1) != 0) {
        goto label_0;
    }
    if (eax >= *(obj.caml_young_end)) {
        goto label_1;
    }
    if (eax <= *(obj.caml_young_start)) {
        goto label_1;
    }
    eax = caml_global_roots_young;
    caml_insert_global_root ();
    goto label_0;
    do {
        eax = caml_global_roots_old;
        eax = caml_insert_global_root ();
        goto label_0;
label_1:
        ecx = eax;
        ecx >>= 0x17;
        eax >>= 0xc;
        eax &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
    } while ((*((ecx + eax)) & 1) != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80604b0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_run_initializers_opt_1320 (void) {
    if (eax != 1) {
        eax = ebx;
        return eax;
    }
    *(esp) = ebx;
    ecx = *((ecx + 0x1c));
    if (ecx != 1) {
        eax = ebx;
        ebx = ecx;
        camlCamlinternalOO_iter_f_1312 ();
    }
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060450 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_iter_f_1312 (void) {
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *(ebx);
        void (*ecx)(uint32_t, uint32_t) (eax, ecx);
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c5a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2766 (void) {
    eax = unix_fork;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ede0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1774 (void) {
    ecx = *((ebx + 0xc));
    ebx = *((ebx + 8));
    eax = *((eax + ebx*2 - 2));
    eax = *((eax + ecx*2 - 2));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bf42 */
#include <stdint.h>
 
int32_t caml_int64_and (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 4));
    ecx &= *((eax + 4));
    edx = *((edx + 8));
    edx &= *((eax + 8));
    caml_copy_int64 (ecx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806725d */
#include <stdint.h>
 
int32_t caml_register_dyn_global (int32_t arg_8h) {
    edx = caml_dyn_globals;
    eax = *((ebp + 8));
    eax = cons ();
    *(obj.caml_dyn_globals) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c040 */
#include <stdint.h>
 
int32_t camlUnix_fun_2608 (void) {
    eax = unix_string_of_inet_addr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80557b0 */
#include <stdint.h>
 
int32_t camlString_fun_1163 (void) {
    esi = eax;
    ecx = *((ebx + 8));
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((ecx + eax));
    eax -= ecx;
    eax = *((ebx + 0x10));
    caml_blit_string (*((ebx + 8)), 1, *((ebx + 0xc)), *(eax), eax + eax + 1);
    eax = *((ebx + 0x10));
    edi = *((ebx + 8));
    ecx = *((edi - 4));
    ecx >>= 0xa;
    edx = ecx*4 - 1;
    ecx = *((edi + edx));
    edx -= ecx;
    ecx = *((ebx + 0x10));
    ecx = *(ecx);
    ecx = ecx + edx*2;
    *(eax) = ecx;
    eax = *((esi - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((esi + eax));
    eax -= ecx;
    eax = *((ebx + 0x10));
    caml_blit_string (esi, 1, *((ebx + 0xc)), *(eax), eax + eax + 1);
    eax = *((ebx + 0x10));
    ecx = *((esi - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((esi + ecx));
    ecx -= edx;
    ebx = *((ebx + 0x10));
    ebx = *(ebx);
    ebx = ebx + ecx*2;
    *(eax) = ebx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bf20 */
#include <stdint.h>
 
int32_t camlUnix_fun_2576 (void) {
    eax = unix_getservbyport;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8053850 */
#include <stdint.h>
 
int32_t camlList_find_1207 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
label_0:
        if (ebx == 1) {
            goto label_2;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = *((ecx + 0xc));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (ecx, eax, eax);
        if (eax == 1) {
            goto label_3;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        ebx = *((esp + 4));
        *((eax + 4)) = ebx;
        ebx = *((esp + 8));
        ecx = *((esp + 0xc));
    } while (1);
label_3:
    eax = *((esp + 4));
    ebx = *((esp + 8));
    ecx = *((esp + 0xc));
    goto label_0;
label_2:
    ebx = 1;
    void (*0x8054610)() ();
label_4:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d000 */
#include <stdint.h>
 
int32_t caml_array_unsafe_set_float (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebp + 0x10));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 8));
    *((eax + edx*8)) = fp_stack[0];
    fp_stack--;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b220 */
#include <stdint.h>
 
int32_t caml_curry4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry4_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80502a0 */
#include <stdint.h>
 
int32_t camlPervasives_5e_5e_1312 (void) {
    eax = loc.camlPervasives__85;
    eax = camlPervasives_$5e_1112 (eax);
    ebx = eax;
    eax = *(esp);
    return camlPervasives_5e_1112 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c15a */
#include <stdint.h>
 
int32_t caml_int64_to_int32 (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d94c */
#include <stdint.h>
 
int32_t caml_finalize_channel (int32_t arg_8h) {
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = *((ebx + 0x2c));
    eax--;
    *((ebx + 0x2c)) = eax;
    if (eax <= 0) {
        eax = caml_channel_mutex_free;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        eax = ebx;
        unlink_channel ();
        caml_stat_free (ebx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052a50 */
#include <stdint.h>
 
int32_t camlArray_mapi_1115 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ecx = eax;
    eax = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    if (eax == 1) {
        eax = loc.camlArray__23;
        return eax;
    }
    *(esp) = eax;
    *((esp + 4)) = ebx;
    *((esp + 8)) = ecx;
    eax = *((ebx - 4));
    if (eax != 0xfe) {
        ebx = *(ebx);
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        edx = eax + 4;
        *((edx - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(edx) = fp_stack[0];
        fp_stack--;
        ebx = edx;
    }
    eax = 1;
    eax = caml_apply2 ();
    eax = *((esp + 4));
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    esi = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (esi > eax) {
        goto label_3;
    }
    *((esp + 0xc)) = eax;
    *((esp + 0x10)) = esi;
    *(esp) = ebx;
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            ebx = *((ecx + esi*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + esi*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = esi;
        ecx = *((esp + 8));
        eax = caml_apply2 ();
        ebx = *(esp);
        ecx = *((ebx - 4));
        if (ecx != 0xfe) {
            esi = *((esp + 0x14));
            eax = caml_modify (ebx + esi*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            esi = *((esp + 0x10));
            *((ebx + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = esi;
        esi += 2;
        *((esp + 0x10)) = esi;
        eax = *((esp + 0xc));
    } while (ecx != eax);
label_3:
    eax = ebx;
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80607b0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_set_var_1378 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x805ee00;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055fa0 */
#include <stdint.h>
 
int32_t camlString_map_1090 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx + 1;
    if (ecx == 1) {
        eax = ebx;
        return eax;
    }
    *(esp) = ecx;
    *((esp + 4)) = ebx;
    *((esp + 8)) = eax;
    eax = caml_create_string;
    eax = caml_c_call (ecx);
    ebx = 1;
    ecx = *(esp);
    ecx += 0xfffffffe;
    if (ebx > ecx) {
        goto label_0;
    }
    do {
        ebx >>= 1;
        eax = *((esp + 4));
        eax = *((eax + ebx));
        eax = eax + eax + 1;
        ebx = *((esp + 8));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t) (ecx);
        eax >>= 1;
        ebx = *(esp);
        ecx = *(esp);
        ecx >>= 1;
        edx = eax;
        eax = *((esp + 0xc));
        *((eax + ecx)) = dl;
        edx = ebx;
        ebx += 2;
        *(esp) = ebx;
        ecx = *((esp + 0x10));
    } while (edx != ecx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805bb60 */
#include <stdint.h>
 
int32_t camlPrintf_scan_conv_1143 (int32_t arg_ch, int32_t arg_ch_2, int32_t arg_4h, int32_t arg_4h_2, int32_t arg_8h, int32_t arg_ch_3) {
    int32_t var_4h_2;
    int32_t var_4h;
label_2:
    do {
        edx = ecx;
        ecx = *((edx + 0x24));
        if (ebx > ecx) {
            eax = *((edx + 0x18));
            void (*0x805d6e0)() ();
        }
        esi = ebx;
        esi >>= 1;
        ecx = *((edx + 0x18));
        ecx = *((ecx + esi));
        ecx = ecx + ecx + 1;
        if (ecx >= 0xfd) {
            goto label_3;
        }
        esi = ecx;
        esi >>= 1;
        /* switch table (254 cases) at 0x808111c */
        edx = *((edx + 0x1c));
        caml_apply3 (edx, eax);
        ebx = *((esp + 0xc));
        ebx += 0x10;
        void (*0x805bae0)() ();
        edx = *((edx + 0x1c));
        eax = caml_apply3 (ecx);
        eax = *(esp);
        eax = camlPrintf_sub_format_for_printf_1135 (eax);
        ecx = eax;
        eax = *((esp + 0xc));
        eax = *((eax + 0x18));
        ebx = *((esp + 4));
        eax = caml_apply2 ();
        edx = eax;
        *(esp) = edx;
label_0:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x14f7;
        *(ecx) = sym.camlPrintf__loop_1159;
        *((ecx + 4)) = 3;
        eax = *((esp + 0xc));
        ebx = *((eax + 0x18));
        *((ecx + 8)) = ebx;
        eax = *((eax + 0x20));
        *((ecx + 0xc)) = eax;
        *((ecx + 0x10)) = edx;
        eax = *((esp + 4));
        ebx = ecx;
        camlPrintf_loop_1159 ();
        ebx = *(esp);
        ebx += 0xfffffffe;
        eax = *((esp + 8));
        ecx = *((esp + 0xc));
    } while (1);
label_3:
    eax = *((edx + 0x18));
    void (*0x805d6a0)() ();
    eax = ebx;
    eax += 2;
    return eax;
    edx = *((edx + 0x1c));
    ecx = 0xe7;
    void (*0x804b580)() ();
    edx = *((edx + 0x1c));
    ecx = 0xc7;
    void (*0x804b580)() ();
    edx = *((edx + 0x1c));
    ecx = 0xd3;
    void (*0x804b580)() ();
    edx = *((edx + 0x1c));
    ecx = 0xcd;
    void (*0x804b580)() ();
    edx = *((edx + 0x1c));
    ecx = 0x85;
    void (*0x804b580)() ();
    edx = *((edx + 0x1c));
    void (*0x804b580)() ();
    edi = ebx;
    edi += 2;
    esi = *((edx + 0x24));
    if (edi > esi) {
        edx = *((edx + 0x1c));
        ecx = 0xd3;
        void (*0x804b580)() ();
    }
    *(esp) = ecx;
    esi = *((edx + 0x18));
    ecx = edi;
    ecx >>= 1;
    edi = *((esi - 4));
    edi >>= 0xa;
    ebp = edi*4 - 1;
    edi = *((esi + ebp));
    ebp -= edi;
    if (ebp > ecx) {
        ecx = *((esi + ecx));
        ecx = ecx + ecx + 1;
        ecx += 0xffffff50;
        if (ecx <= 0x41) {
            *((esp + 0xc)) = edx;
            ecx >>= 1;
            /* switch table (66 cases) at 0x8081314 */
        }
        edx = *((edx + 0x1c));
        ecx = 0xd3;
        void (*0x804b580)() ();
        edx = *((edx + 0x1c));
        ecx = *(esp);
        caml_apply3 ();
        ebx = *((esp + 0xc));
        ecx = *((ebx + 0x20));
        ebx = 0xd3;
        void (*0x804b5d0)() ();
        edx = *((edx + 0x1c));
        void (*0x804b580)() ();
label_4:
        caml_call_gc ();
        goto label_0;
    }
    caml_ml_array_bound_error ();
    do {
label_1:
        edx = *((ecx + 0x34));
        if (ebx > edx) {
            eax = *((ecx + 0x28));
            void (*0x805d6e0)() ();
        }
        esi = ebx;
        esi >>= 1;
        edx = *((ecx + 0x28));
        edx = *((edx + esi));
        edx = edx + edx + 1;
        if (edx < 0x75) {
            goto label_5;
        }
        if (edx != 0xbf) {
            goto label_6;
        }
        ebx += 2;
        eax = 3;
    } while (1);
label_5:
    if (edx >= 0x41) {
        edx += 0xffffffc0;
        edx >>= 1;
        /* switch table (66 cases) at 0x8081398 */
        edx = *((ecx + 0x2c));
        ecx = 0xd3;
        eax = caml_apply3 (eax, ecx);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
        goto label_1;
    }
label_6:
    ecx += 0x10;
    goto label_2;
    ebx += 2;
    goto label_1;
    ebx += 2;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8072331 */
#include <stdint.h>
 
int32_t caml_gc_stat (void) {
    int32_t var_94h;
    int32_t var_90h;
    uint32_t var_8ch;
    int32_t var_88h;
    int32_t var_84h;
    uint32_t var_80h;
    uint32_t var_78h;
    int32_t var_70h;
    int32_t var_6ch;
    int32_t var_68h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = caml_local_roots;
    *((ebp - 0x84)) = eax;
    eax = caml_heap_start;
    if (eax == 0) {
        *((ebp - 0x6c)) = 0;
        esi = 0;
        *((ebp - 0x5c)) = 0;
        *((ebp - 0x58)) = 0;
        *((ebp - 0x54)) = 0;
        ebx = 0;
        *((ebp - 0x70)) = 0;
        goto label_1;
    }
    edx = caml_gc_phase;
    *((ebp - 0x78)) = edx;
    ecx = caml_gc_sweep_hp;
    *((ebp - 0x80)) = ecx;
    *((ebp - 0x6c)) = 0;
    esi = 0;
    *((ebp - 0x5c)) = 0;
    *((ebp - 0x58)) = 0;
    *((ebp - 0x54)) = 0;
    ebx = 0;
    *((ebp - 0x70)) = 0;
label_0:
    *((ebp - 0x70))++;
    edi = eax - 0x10;
    *((ebp - 0x68)) = edi;
    edi = eax;
    edx = *((ebp - 0x68));
    edi += *((edx + 8));
    if (edi <= eax) {
        goto label_2;
    }
    *((ebp - 0x8c)) = edi;
    do {
        edx = *(eax);
        ecx = *(eax);
        ecx &= 0x300;
        if (ecx != 0x100) {
            if (ecx <= 0x100) {
                if (ecx != 0) {
                } else {
                }
                if (ecx == 0x200) {
                    goto label_3;
                }
                if (ecx != 0x300) {
                    goto label_4;
                }
            } else {
                ecx = edx;
                ecx >>= 0xa;
                *((ebp - 0x88)) = ecx;
                if (ecx == 0) {
                    *((ebp - 0x6c))++;
                    goto label_4;
                }
                if (*((ebp - 0x78)) == 1) {
                    if (*((ebp - 0x80)) > eax) {
                        goto label_5;
                    }
                    *((ebp - 0x5c))++;
                    ecx = *((ebp - 0x88));
                    edi = *((ebp - 0x58));
                    edi = ecx + edi + 1;
                    *((ebp - 0x58)) = edi;
                    ecx++;
                    if (ecx > esi) {
                        esi = ecx;
                    }
                    goto label_4;
                }
label_5:
                *((ebp - 0x54))++;
                ecx = *((ebp - 0x88));
                ebx = ecx + ebx + 1;
            }
        } else {
            *((ebp - 0x54))++;
            ecx = edx;
            ecx >>= 0xa;
            ebx = ebx + ecx + 1;
            goto label_4;
label_3:
            *((ebp - 0x5c))++;
            edi = edx;
            edi >>= 0xa;
            ecx = *((ebp - 0x58));
            ecx = edi + ecx + 1;
            *((ebp - 0x58)) = ecx;
            ecx = edi;
            ecx++;
            if (ecx <= esi) {
                esi = ecx;
                goto label_4;
            }
        }
label_4:
        edx >>= 0xa;
        eax = eax + edx*4 + 4;
    } while (*((ebp - 0x8c)) > eax);
label_2:
    edi = *((ebp - 0x68));
    eax = *((edi + 0xc));
    if (eax != 0) {
        goto label_0;
    }
label_1:
    *((ebp - 0x1c)) = 0;
    eax = *((ebp - 0x84));
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x3c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    eax = caml_young_end;
    eax -= *(obj.caml_young_ptr);
    eax >>= 2;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *((ebp - 0x68)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_stat_promoted_words);
    *((ebp - 0x78)) = fp_stack[0];
    fp_stack--;
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *((ebp - 0x80)) = fp_stack[0];
    fp_stack--;
    edi = caml_stat_minor_collections;
    eax = caml_stat_major_collections;
    *((ebp - 0x88)) = eax;
    eax = caml_stat_heap_size;
    eax >>= 2;
    *((ebp - 0x8c)) = eax;
    edx = caml_stat_compactions;
    *((ebp - 0x90)) = edx;
    eax = caml_stat_top_heap_size;
    eax >>= 2;
    *((ebp - 0x94)) = eax;
    eax = caml_alloc_tuple (0x10);
    *((ebp - 0x1c)) = eax;
    *(fp_stack--) = *((ebp - 0x68));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x78));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 4;
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x80));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 8;
    caml_modify (eax, eax);
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0xc;
    caml_modify (eax, eax);
    edx = *((ebp - 0x88));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x10;
    caml_modify (eax, eax);
    ecx = *((ebp - 0x8c));
    eax = ecx + ecx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x14;
    caml_modify (eax, eax);
    edi = *((ebp - 0x70));
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x18;
    caml_modify (eax, eax);
    eax = ebx + ebx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x1c;
    caml_modify (eax, eax);
    edx = *((ebp - 0x54));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x20;
    caml_modify (eax, eax);
    ecx = *((ebp - 0x58));
    eax = ecx + ecx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x24;
    caml_modify (eax, eax);
    edi = *((ebp - 0x5c));
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x28;
    caml_modify (eax, eax);
    eax = esi + esi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x2c;
    caml_modify (eax, eax);
    edx = *((ebp - 0x6c));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x30;
    caml_modify (eax, eax);
    ecx = *((ebp - 0x90));
    eax = ecx + ecx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x34;
    caml_modify (eax, eax);
    edi = *((ebp - 0x94));
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x38;
    caml_modify (eax, eax);
    caml_stack_usage ();
    eax = eax + eax + 1;
    eax = *((ebp - 0x1c));
    eax += 0x3c;
    caml_modify (eax, eax);
    eax = *((ebp - 0x84));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bbb8 */
#include <stdint.h>
 
int32_t caml_nativeint_add (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax += *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8051ff0 */
#include <stdint.h>
 
int32_t camlArray_append_1054 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    ecx = *((ebx - 4));
    esi = *((ebx - 4));
    esi &= 0xff;
    if (esi != 0xfe) {
        ecx >>= 9;
    } else {
        ecx >>= 0xa;
    }
    ecx |= 1;
    if (edx == 1) {
        if (ecx == 1) {
            eax = loc.camlArray__31;
            return eax;
        }
        *(esp) = ecx;
        *((esp + 8)) = edx;
        *((esp + 4)) = ebx;
        *((esp + 0xc)) = eax;
    } else {
        *(esp) = ecx;
        *((esp + 8)) = edx;
        *((esp + 4)) = ebx;
        *((esp + 0xc)) = eax;
    }
    if (edx > 1) {
        ebx = eax;
    }
    esi = *((ebx - 4));
    if (esi != 0xfe) {
        esi = *(ebx);
    } else {
label_2:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        esi = eax + 4;
        *((esi - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(esi) = fp_stack[0];
        fp_stack--;
    }
    eax = caml_make_vect;
    eax = caml_c_call (edx + ecx - 1);
    esi = eax;
    ebx = 1;
    edi = *((esp + 8));
    edi += 0xfffffffe;
    if (ebx > edi) {
        goto label_4;
    }
    do {
        ecx = *((esp + 0xc));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            edx = *((ecx + ebx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebx*2 - 2, edx);
        } else {
            *(fp_stack--) = *(edx);
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = ebx;
        ebx += 2;
    } while (eax != edi);
label_4:
    ebx = 1;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ebx > eax) {
        goto label_6;
    }
    *(esp) = eax;
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            edx = *((ecx + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_7;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 8));
        ecx = ebx + eax - 1;
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ecx*2 - 2, edx);
        } else {
            *(fp_stack--) = *(edx);
            *((esi + ecx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebx;
        ebx += 2;
        eax = *(esp);
    } while (ecx != eax);
label_6:
    eax = esi;
    return eax;
label_7:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c1a8 */
#include <stdint.h>
 
int32_t caml_int32_of_float (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_ah;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0xa));
    ah = 0xc;
    *((ebp - 0xc)) = ax;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_int32 ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804dac0 */
#include <stdint.h>
 
int32_t camlUnix_open_process_1967 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    *((esp + 8)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 0x10)) = ebx;
    eax = *(eax);
    *((esp + 4)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *(esp) = ebx;
    eax = *(eax);
    *((esp + 0xc)) = eax;
    eax = *((esp + 4));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    *((esp + 0x14)) = eax;
    eax = *(esp);
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    ecx = eax;
    *((esp + 0x18)) = ecx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x24;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x800;
    eax = *(esp);
    *(edx) = eax;
    *((edx + 4)) = 1;
    ebx = edx + 0xc;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 4));
    *(ebx) = eax;
    *((ebx + 4)) = edx;
    ebx = edx + 0x18;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 0x14));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = *((esp + 8));
    ecx = *((esp + 0xc));
    edx = *((esp + 0x10));
    esi = *(esp);
    camlUnix_open_proc_1949 (ebx);
    eax = *((esp + 0xc));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x10));
    eax = unix_close;
    caml_c_call (eax);
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 0x14));
            *(eax) = ebx;
            ebx = *((esp + 0x18));
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c7d0 */
#include <stdint.h>
 
int32_t caml_sinh_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    sinh (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049f34 */
#include <stdint.h>
 
void sinh (void) {
    sinh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cc20 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_optint_1660 (void) {
    eax = unix_setsockopt;
    caml_c_call (5);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075474 */
#include <stdint.h>
 
int32_t caml_globalsym (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    caml_dlsym (0, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807545a */
#include <stdint.h>
 
int32_t caml_dlsym (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    dlsym ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a214 */
#include <stdint.h>
 
void dlsym (void) {
    dlsym ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c390 */
#include <stdint.h>
 
int32_t camlUnix_fun_2708 (void) {
    eax = unix_dup2;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807548f */
#include <stdint.h>
 
int32_t caml_dlclose (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(esp) = eax;
    dlclose ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a044 */
#include <stdint.h>
 
void dlclose (void) {
    dlclose ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c7ed */
#include <stdint.h>
 
int32_t caml_sin_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    sin (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a7f4 */
#include <stdint.h>
 
void sin (void) {
    sin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b2a3 */
#include <stdint.h>
 
int32_t caml_int32_compare (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    cl = (edx > eax) ? 1 : 0;
    ecx = (int32_t) cl;
    dl = (edx < eax) ? 1 : 0;
    edx = (int32_t) dl;
    eax = ecx;
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075a84 */
#include <stdint.h>
 
int32_t caml_record_backtrace (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    if (eax != *(obj.caml_backtrace_active)) {
        *(obj.caml_backtrace_active) = eax;
        *(obj.caml_backtrace_pos) = 0;
        if (eax != 0) {
            caml_register_global_root (obj.caml_backtrace_last_exn);
        } else {
            caml_remove_global_root (obj.caml_backtrace_last_exn);
        }
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d189 */
#include <stdint.h>
 
uint32_t caml_make_vect (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_70h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_4h;
    edi = caml_local_roots;
    eax = ebp - 0x38;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    eax = ebp - 0x3c;
    *((ebp - 0x50)) = eax;
    esi = *((ebp + 8));
    esi >>= 1;
    if (esi == 0) {
        *((ebp - 0x3c)) = 0x808b124;
        goto label_0;
    }
    *((ebp - 0x38)) = edi;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = *((ebp + 0xc));
    edx = *((ebp + 0xc));
    edx &= 1;
    if (edx != 0) {
        goto label_1;
    }
    *((ebp - 0x70)) = eax;
    ebx = eax;
    ebx >>= 0x17;
    ecx = eax;
    ecx >>= 0xc;
    ecx &= 0x7ff;
    ebx = *((ebx*4 + obj.caml_page_table));
    if ((*((ebx + ecx)) & 7) == 0) {
        goto label_1;
    }
    if (*((eax - 4)) != 0xfd) {
        goto label_1;
    }
    *(fp_stack--) = *(eax);
    *((ebp - 0x70)) = fp_stack[0];
    fp_stack--;
    eax = esi + esi;
    if (eax > 0x3fffff) {
        eax = caml_invalid_argument ("Array.make");
    }
    eax = caml_alloc (eax, 0xfe);
    *((ebp - 0x3c)) = eax;
    eax = 0;
    do {
        edx = *((ebp - 0x3c));
        *(fp_stack--) = *((ebp - 0x70));
        *((edx + eax*8)) = fp_stack[0];
        fp_stack--;
        eax++;
    } while (esi > eax);
    goto label_0;
label_1:
    if (esi > 0x3fffff) {
        caml_invalid_argument ("Array.make");
    }
    if (esi > 0xff) {
        goto label_2;
    }
    eax = caml_alloc_small (esi, 0);
    *((ebp - 0x3c)) = eax;
    esi <<= 2;
    eax = 0;
    do {
        ecx = *((ebp + 0xc));
        edx = *((ebp - 0x3c));
        *((eax + edx)) = ecx;
        eax += 4;
    } while (eax != esi);
    goto label_0;
label_2:
    if (edx != 0) {
        goto label_3;
    }
    if (eax >= *(obj.caml_young_end)) {
        goto label_3;
    }
    if (eax <= *(obj.caml_young_start)) {
        goto label_3;
    }
    caml_minor_collection ();
    eax = caml_alloc_shr (esi, 0);
    *((ebp - 0x3c)) = eax;
    esi <<= 2;
    eax = 0;
    do {
        ecx = *((ebp + 0xc));
        edx = *((ebp - 0x3c));
        *((edx + eax)) = ecx;
        eax += 4;
    } while (eax != esi);
    eax = *((ebp - 0x3c));
    eax = caml_check_urgent_gc (eax);
    *((ebp - 0x3c)) = eax;
    goto label_0;
label_3:
    eax = caml_alloc_shr (esi, 0);
    *((ebp - 0x3c)) = eax;
    ebx = 0;
    do {
        eax = *((ebp + 0xc));
        eax = ebx*4;
        eax += *((ebp - 0x3c));
        caml_initialize (eax, eax);
        ebx++;
    } while (esi > ebx);
    eax = *((ebp - 0x3c));
    eax = caml_check_urgent_gc (eax);
    *((ebp - 0x3c)) = eax;
label_0:
    *(obj.caml_local_roots) = edi;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a227 */
#include <stdint.h>
 
int32_t caml_shrink_heap (int32_t arg_8h) {
    char * var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    if (ebx == *(obj.caml_heap_start)) {
        goto label_0;
    }
    esi = ebx - 0x10;
    eax = caml_stat_heap_size;
    eax -= *((esi + 8));
    *(obj.caml_stat_heap_size) = eax;
    eax >>= 0xa;
    caml_gc_message (4, "Shrinking heap to %luk bytes\n", eax);
    *(obj.caml_stat_heap_chunks)--;
    eax = caml_heap_start;
    edx = caml_heap_start;
    if (ebx == eax) {
        goto label_1;
    }
    do {
        edx = eax - 4;
        eax = *((eax - 4));
    } while (ebx != eax);
label_1:
    eax = *((esi + 0xc));
    *(edx) = eax;
    eax = ebx;
    eax += *((esi + 8));
    caml_page_table_remove (1, ebx, eax);
    caml_free_for_heap (ebx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b200 */
#include <stdint.h>
 
int32_t loc_camlPrintf_code_begin (void) {
    eax = ebx;
    ecx = *((eax + 8));
    ebx = *((eax + 0xc));
    eax = *((eax + 0x10));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a00c */
#include <stdint.h>
 
int32_t caml_initialize (int32_t arg_8h, void * arg_ch) {
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    *(ebx) = eax;
    if ((al & 1) == 0) {
        if (eax >= *(obj.caml_young_end)) {
            goto label_0;
        }
        if (eax <= *(obj.caml_young_start)) {
            goto label_0;
        }
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 1) == 0) {
            goto label_0;
        }
        eax = .comment;
        if (eax >= *(0x8087aac)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x8087aa8;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cc00 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_optint_1657 (void) {
    eax = unix_getsockopt;
    caml_c_call (5);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ceec */
#include <stdint.h>
 
int32_t caml_string_greaterthan (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax > 1) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f1c0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_public_method_label_1074 (void) {
    edx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x400;
    *(esi) = 1;
    ecx = 1;
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ebx = *((edx + eax));
    eax -= ebx;
    edi = eax + eax - 1;
    if (ecx > edi) {
        goto label_2;
    }
    do {
        eax = ecx;
        eax >>= 1;
        ebx = *((edx - 4));
        ebx >>= 0xa;
        ebp = ebx*4 - 1;
        ebx = *((edx + ebp));
        ebp -= ebx;
        if (ebp <= eax) {
            goto label_3;
        }
        eax = *((edx + eax));
        ebx = *(esi);
        ebx >>= 1;
        ebx *= 0x1be;
        eax = ebx + eax*2 + 1;
        *(esi) = eax;
        eax = ecx;
        ecx += 2;
    } while (eax != edi);
label_2:
    eax = *(esi);
    eax &= 0xffffffff;
    *(esi) = eax;
    ebx = 0x7fffffff;
    eax = *(esi);
    if (eax > ebx) {
        eax = *(esi);
    } else {
        eax = *(esi);
    }
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b300 */
#include <stdint.h>
 
int32_t caml_curry3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry3_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065d6d */
#include <stdint.h>
 
int32_t unix_tcsetattr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x12b91;
    eax = *((ebp + 8));
    eax >>= 1;
    *((ebp - 0x28)) = eax;
    eax = ebx + 0xbe94;
    *((esp + 4)) = eax;
    eax = *((ebp - 0x28));
    *(esp) = eax;
    eax = tcgetattr ();
    if (eax == -1) {
        eax = ebx - 0x231b;
        uerror (eax, 0);
    }
    eax = *((ebx + 0xba14));
    if (eax == 4) {
        goto label_1;
    }
    edi = *((ebp + 0x10));
    esi = ebx + 0xba14;
    edx = ebx - 0x22ac;
    *((ebp - 0x24)) = edx;
    ecx = ebx + 0xbe94;
    *((ebp - 0x2c)) = ecx;
label_0:
    esi += 4;
    if (eax != 1) {
        if (eax <= 1) {
            if (eax == 0) {
                goto label_2;
            }
            goto label_3;
        }
        if (eax == 2) {
            goto label_4;
        }
        if (eax != 3) {
            goto label_3;
        }
        goto label_5;
label_2:
        eax = *(esi);
        ecx = *((esi + 4));
        esi += 8;
        edx = *(edi);
        edx >>= 1;
        if (edx != 0) {
            *(eax) |= ecx;
            goto label_3;
        }
        ecx = ~ecx;
        *(eax) &= ecx;
        goto label_3;
    }
    eax = *(esi);
    edx = *((esi + 8));
    *((ebp - 0x1c)) = edx;
    edx = esi + 0xc;
    ecx = *(edx);
    *((ebp - 0x20)) = ecx;
    ecx = *(edi);
    ecx >>= 1;
    ecx -= *((esi + 4));
    if (ecx >= 0) {
        if (*((ebp - 0x1c)) <= ecx) {
            goto label_6;
        }
        edx += 4;
        esi = *((ebp - 0x20));
        esi = ~esi;
        esi &= *(eax);
        esi |= *((edx + ecx*4));
        *(eax) = esi;
        eax = *((ebp - 0x1c));
        esi = edx + eax*4;
        goto label_3;
    }
label_6:
    eax = ebx - 0x231b;
    unix_error (0x16, eax, 0);
label_4:
    ecx = *(esi);
    edx = *(edi);
    edx >>= 1;
    eax = 1;
    if (edx == *((ebx - 0x22a8))) {
        al = 0;
        goto label_7;
    }
    *((ebp - 0x1c)) = esi;
    esi = *((ebp - 0x24));
    do {
        if (edx == *((esi + eax*8 + 4))) {
            esi = *((ebp - 0x1c));
label_7:
            if (ecx != 0) {
                edx = 0;
                if (ecx != 1) {
                    goto label_8;
                }
                eax = *((ebx + eax*8 - 0x22ac));
                *((esp + 4)) = eax;
                edx = *((ebp - 0x2c));
                *(esp) = edx;
                eax = cfsetospeed ();
                edx = eax;
            } else {
                eax = *((ebx + eax*8 - 0x22ac));
                *((esp + 4)) = eax;
                ecx = *((ebp - 0x2c));
                *(esp) = ecx;
                eax = cfsetispeed ();
                edx = eax;
            }
label_8:
            if (edx != -1) {
                esi += 4;
                goto label_3;
            }
            eax = ebx - 0x231b;
            eax = uerror (eax, 0);
        }
        eax++;
    } while (eax != 0x12);
    eax = ebx - 0x231b;
    unix_error (0x16, eax, 0);
label_5:
    eax = *(esi);
    esi += 4;
    edx = *(edi);
    edx >>= 1;
    *((ebx + eax + 0xbea5)) = dl;
label_3:
    eax = *(esi);
    if (eax != 4) {
        edi += 4;
        goto label_0;
    }
label_1:
    eax = ebx + 0xbe94;
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x22d0));
    *((esp + 4)) = eax;
    eax = *((ebp - 0x28));
    *(esp) = eax;
    eax = tcsetattr ();
    if (eax == -1) {
        eax = ebx - 0x231b;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b070 */
#include <stdint.h>
 
int32_t caml_curry6_4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_5;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058630 */
#include <stdint.h>
 
int32_t camlObj_set_double_field_1044 (void) {
    edx = *((eax - 4));
    edx >>= 0xa;
    if (edx > ebx) {
        *(fp_stack--) = *(ecx);
        *((eax + ebx*4 - 4)) = fp_stack[0];
        fp_stack--;
        eax = 1;
        return eax;
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068294 */
#include <stdint.h>
 
int32_t caml_fatal_error_arg2 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    char ** format;
    int32_t var_8h;
    eax = *((ebp + 0xc));
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax = stderr;
    fprintf (eax, eax);
    eax = *((ebp + 0x14));
    *((esp + 8)) = eax;
    eax = *((ebp + 0x10));
    eax = stderr;
    fprintf (eax, eax);
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a574 */
#include <stdint.h>
 
void fprintf (void) {
    fprintf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066d89 */
#include <stdint.h>
 
int32_t caml_startup (int32_t arg_8h) {
    eax = *((ebp + 8));
    caml_main (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804be80 */
#include <stdint.h>
 
int32_t camlUnix_fun_2857 (void) {
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f820 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1406 (void) {
    eax = caml_ml_input_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806a3b2 */
#include <stdint.h>
 
uint32_t caml_alloc_shr (int32_t arg_8h, void * arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    if (esi > 0x3fffff) {
        caml_raise_out_of_memory ();
    }
    eax = caml_fl_allocate (esi);
    ebx = eax;
    if (eax != 0) {
        goto label_0;
    }
    edx = 0x51eb851f;
    eax = esi;
    edx:eax = eax * edx;
    edx >>= 5;
    edx *= *(obj.caml_percent_free);
    eax = esi + edx + 1;
    eax <<= 2;
    eax = caml_round_heap_chunk_size (eax);
    ebx = eax;
    eax = caml_alloc_for_heap (eax);
    edi = eax;
    if (eax != 0) {
        edx = ebx;
        edx >>= 2;
        edx--;
        ecx = eax;
        if (edx > 0x3fffff) {
            goto label_1;
        }
        goto label_2;
    }
    eax = caml_gc_message (4, "No room for growing heap\n", 0);
    goto label_3;
    do {
        ecx = eax;
label_1:
        *(eax) = 0xfffffe00;
        eax += 0x1000000;
        ebx -= 0x1000000;
        edx = eax + 4;
        *((ecx + 4)) = edx;
        *((edi + 8)) = edx;
        edx = ebx;
        edx >>= 2;
        edx--;
    } while (edx > 0x3fffff);
    ecx = eax;
label_2:
    if (ebx > 1) {
        edx <<= 0xa;
        edx += 0x200;
        *(eax) = edx;
        ecx += 4;
        *((edi + 8)) = ecx;
        *(ecx) = 0;
    } else {
        *((ecx + 4)) = 0;
        if (ebx != 1) {
            goto label_4;
        }
        *(eax) = 0;
    }
label_4:
    eax = caml_add_to_heap (edi);
    if (eax != 0) {
        caml_free_for_heap (edi);
    } else {
        edi += 4;
        if (edi != 0) {
            goto label_5;
        }
    }
label_3:
    if (*(obj.caml_in_minor_collection) != 0) {
        caml_fatal_error ("Fatal error: out of memory.\n");
    }
    caml_raise_out_of_memory ();
label_5:
    caml_fl_add_blocks (edi);
    eax = caml_fl_allocate (esi);
    ebx = eax;
label_0:
    eax = caml_gc_phase;
    if (eax != 0) {
        if (eax != 1) {
            goto label_6;
        }
        if (ebx < *(obj.caml_gc_sweep_hp)) {
            goto label_6;
        }
    }
    eax = esi;
    eax <<= 0xa;
    edx = *((ebp + 0xc));
    eax = edx + eax + 0x300;
    *(ebx) = eax;
    goto label_7;
label_6:
    eax = esi;
    eax <<= 0xa;
    eax += *((ebp + 0xc));
    *(ebx) = eax;
label_7:
    eax = caml_allocated_words;
    eax = esi + eax + 1;
    *(obj.caml_allocated_words) = eax;
    edx = caml_minor_heap_size;
    edx >>= 2;
    if (eax > edx) {
        caml_urge_major_slice ();
    }
    eax = ebx + 4;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050cf0 */
#include <stdint.h>
 
uint32_t camlArray_fill_1135 (void) {
    do {
        edi = eax;
        esi = ecx;
        if (ebx == 1) {
            goto label_0;
        }
        ebp = *((ebx + 4));
        ecx = *(ebx);
        ebx = *((esi + 0xc));
        eax = *((ebx - 4));
        if (eax != 0xfe) {
            caml_modify (ebx + edi*2 - 2, ecx);
        } else {
            *(fp_stack--) = *(ecx);
            *((ebx + edi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = edi;
        eax += 2;
        ebx = ebp;
        ecx = esi;
    } while (1);
label_0:
    eax = *((esi + 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805fee0 */
#include <stdint.h>
 
void camlCamlinternalOO_get_variables_1261 (void) {
    ebx = .comment;
    ecx = *(ebx);
    void (*ecx)(uint32_t) (ebx);
    ebx = *(esp);
    return camlArray_map_1105 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060ad0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_meth_app_const_1436 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlCamlinternalOO__fun_1830;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806615c */
#include <stdint.h>
 
uint32_t unix_time (void) {
    time_t var_ch;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x127a4;
    eax = time (0);
    *((ebp - 0xc)) = eax;
    *(fp_stack--) = *((ebp - 0xc));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a584 */
#include <stdint.h>
 
void time (void) {
    time ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805eeb0 */
#include <stdint.h>
 
uint32_t camlCamlinternalOO_fun_1810 (void) {
    ecx = *((ebx + 0x10));
    ebx = *(eax);
    ebx = *((ebx + ecx*2 - 2));
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t) (ebx);
    ebx = eax;
    eax = *(esp);
    ecx = *((eax + 8));
    eax = *((eax + 0xc));
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059120 */
#include <stdint.h>
 
int32_t camlMap_min_binding_1131 (void) {
    do {
        if (eax == 1) {
            goto label_1;
        }
        ebx = *(eax);
        if (ebx == 1) {
            goto label_2;
        }
        eax = ebx;
    } while (1);
label_2:
    ecx = *((eax + 8));
    ebx = *((eax + 4));
label_0:
    eax = caml_young_ptr;
    eax -= 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_3;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x800;
    *(eax) = ebx;
    *((eax + 4)) = ecx;
    return eax;
    do {
label_1:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050100 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_char_1277 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x807c030));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cb40 */
#include <stdint.h>
 
int32_t camlUnix_fun_2816 (void) {
    eax = unix_setsockopt;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d540 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1689 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805edd0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1770 (void) {
    ebx = *((ebx + 8));
    eax = *((eax + ebx*2 - 2));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062bf3 */
#include <stdint.h>
 
uint32_t unix_gethostbyname (int32_t arg_8h, char * src, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_2740h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15d02;
    edi = *((ebp + 8));
    eax = caml_string_length (edi);
    eax++;
    eax = caml_stat_alloc (eax);
    esi = eax;
    strcpy (eax, edi);
    caml_enter_blocking_section ();
    eax = h_errno_location ();
    *((esp + 0x14)) = eax;
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = 0x2710;
    eax = ebp - 0x2740;
    *((esp + 8)) = eax;
    eax = ebp - 0x30;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = gethostbyname_r ();
    edi = eax;
    caml_leave_blocking_section ();
    if (edi != 0) {
        *((ebp - 0x1c)) = 0;
    }
    caml_stat_free (esi);
    eax = *((ebp - 0x1c));
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_host_entry ();
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058020 */
#include <stdint.h>
 
int32_t camlHashtbl_iter_1129 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0xcf7;
    *(ecx) = sym.camlHashtbl__do_bucket_1132;
    *((ecx + 4)) = 3;
    *((ecx + 8)) = edx;
    edx = *((ebx + 4));
    eax = 1;
    ebx = *((edx - 4));
    ebx >>= 9;
    ebx |= 1;
    ebx += 0xfffffffe;
    if (eax > ebx) {
        goto label_2;
    }
    *((esp + 0xc)) = ebx;
    *((esp + 8)) = eax;
    *(esp) = edx;
    *((esp + 4)) = ecx;
    do {
        ebx = *(esp);
        ecx = *((ebx - 4));
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_3;
        }
        eax = *((ebx + eax*2 - 2));
        ebx = *((esp + 4));
        camlHashtbl_do_bucket_1132 ();
        eax = *((esp + 8));
        ecx = *((esp + 8));
        eax += 2;
        *((esp + 8)) = eax;
        ebx = *((esp + 0xc));
    } while (ecx != ebx);
label_2:
    eax = 1;
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063f98 */
#include <stdint.h>
 
uint32_t unix_opendir (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14960;
    edi = *((ebp + 8));
    *(esp) = edi;
    eax = opendir ();
    esi = eax;
    if (eax == 0) {
        eax = ebx - 0x24d5;
        uerror (eax, edi);
    }
    caml_alloc_small (1, 0xfb);
    *(eax) = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a264 */
#include <stdint.h>
 
void opendir (void) {
    opendir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f800 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1402 (void) {
    eax = caml_input_value;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8057aa0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_rec_1088 (void) {
    int32_t var_4h_5;
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 8));
        *((esp + 4)) = ecx;
        ecx = *((ebx + 4));
        *((esp + 8)) = ecx;
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8053b00 */
#include <stdint.h>
 
int32_t camlList_rev_merge_rev_1261 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
label_0:
        if (eax == 1) {
            goto label_2;
        }
        if (ebx == 1) {
            goto label_3;
        }
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((edx + 0xc));
        eax = caml_apply2 (edx, eax, ecx);
        if (eax <= 1) {
            goto label_4;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 0xc));
        *(ecx) = eax;
        eax = *((esp + 0x10));
        *((ecx + 4)) = eax;
        eax = *((esp + 0x14));
        ebx = *((esp + 0x18));
        edx = *((esp + 0x1c));
    } while (1);
    do {
label_4:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            eax = *((esp + 0x10));
            *((ecx + 4)) = eax;
            eax = *((esp + 4));
            ebx = *((esp + 8));
            edx = *((esp + 0x1c));
            goto label_0;
label_3:
            ebx = ecx;
            void (*0x8054610)() ();
label_2:
            eax = ebx;
            ebx = ecx;
            void (*0x8054610)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80732c0 */
#include <stdint.h>
 
int32_t caml_obj_is_block (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax &= 1;
    eax -= eax;
    eax &= 2;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b766 */
#include <stdint.h>
 
uint32_t caml_nativeint_format (void) {
    char * format;
    int32_t var_8h_3;
    int32_t var_4h_2;
    int32_t var_8h_2;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = ebp - 0x38;
    eax = ebp - 0x59;
    edi = ebp - 0x58;
    ecx = esi;
    edx = 0x807760b;
    eax = *((ebp + 8));
    eax = parse_format (edi, eax);
    ebx = eax;
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    sprintf (ebx, esi, eax);
    eax = caml_copy_string (ebx);
    esi = eax;
    if (ebx != edi) {
        caml_stat_free (ebx);
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c320 */
#include <stdint.h>
 
int32_t camlUnix_fun_2694 (void) {
    eax = unix_chdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d7e0 */
#include <stdint.h>
 
int32_t camlPrintf_pad_string_1072 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    if (ebx == edi) {
        if (esi != 1) {
            goto label_0;
        }
        eax = edx;
        return eax;
    }
label_0:
    if (ebx <= edi) {
        eax = edx;
        ebx = esi;
        ecx = edi;
        void (*0x80558f0)() ();
    }
    eax = ebx;
    ebx = ebp;
    eax = camlString_make_1038 (edi, ebx);
    ecx = eax;
    *((esp + 4)) = ecx;
    eax = *(esp);
    if (eax != 1) {
        edx = 1;
        eax = *((esp + 0xc));
        ebx = *((esp + 0x10));
        esi = *((esp + 0x14));
        camlString_blit_1056 ();
    } else {
        edx = *((esp + 8));
        esi = *((esp + 0x14));
        edx -= esi;
        edx++;
        eax = *((esp + 0xc));
        ebx = *((esp + 0x10));
        camlString_blit_1056 ();
    }
    eax = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806753a */
#include <stdint.h>
 
int32_t caml_oldify_local_roots (void) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = caml_globals_scanned;
    *((ebp - 0x1c)) = eax;
    eax = caml_globals_inited;
    if (*((ebp - 0x1c)) > eax) {
        goto label_8;
    }
    edx = *((ebp - 0x1c));
    edi = *((edx*4 + loc.caml_globals));
    if (edi != 0) {
        goto label_9;
    }
    goto label_8;
    do {
label_0:
        edx = edi + eax*4;
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_10;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_10;
            }
            caml_oldify_one (eax, edx);
        }
label_10:
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (ebx < edx);
label_1:
    *((ebp - 0x1c))++;
    eax = caml_globals_inited;
    if (eax < *((ebp - 0x1c))) {
        goto label_8;
    }
    ecx = *((ebp - 0x1c));
    edx = caml_globals;
    edi = *((edx + ecx*4));
    if (edi == 0) {
        goto label_8;
    }
label_9:
    esi = edi - 4;
    edx = *(esi);
    edx >>= 0xa;
    eax = 0;
    ebx = 0;
    if (edx != 0) {
        goto label_0;
    }
    goto label_1;
label_8:
    *(obj.caml_globals_scanned) = eax;
    ecx = caml_dyn_globals;
    *((ebp - 0x1c)) = ecx;
    if (ecx == 0) {
        goto label_11;
    }
label_2:
    eax = *((ebp - 0x1c));
    edi = *(eax);
    esi = edi - 4;
    eax = *(esi);
    eax >>= 0xa;
    if (eax == 0) {
        goto label_12;
    }
    eax = 0;
    ebx = 0;
    do {
        edx = edi + eax*4;
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_13;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_13;
            }
            caml_oldify_one (eax, edx);
        }
label_13:
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (ebx < edx);
label_12:
    edx = *((ebp - 0x1c));
    edx = *((edx + 4));
    *((ebp - 0x1c)) = edx;
    if (edx != 0) {
        goto label_2;
    }
label_11:
    if (*(obj.caml_frame_descriptors) == 0) {
        caml_init_frame_descriptors ();
    }
    ecx = caml_bottom_of_stack;
    *((ebp - 0x1c)) = ecx;
    edx = caml_last_return_address;
    eax = caml_gc_regs;
    *((ebp - 0x20)) = eax;
    if (ecx == 0) {
        goto label_14;
    }
label_3:
    esi = caml_frame_descriptors_mask;
    eax = edx;
    eax >>= 3;
    eax &= esi;
    ecx = caml_frame_descriptors;
    ebx = *((ecx + eax*4));
    if (*(ebx) == edx) {
        goto label_15;
    }
    do {
        eax++;
        eax &= esi;
        ebx = *((ecx + eax*4));
    } while (*(ebx) != edx);
label_15:
    if (*((ebx + 4)) == 0xffff) {
        goto label_16;
    }
    esi = *((ebx + 6));
    if (esi <= 0) {
        goto label_17;
    }
    edi = ebx + 8;
    do {
        edx = *(edi);
        if ((dl & 1) != 0) {
            edx >>= 1;
            ecx = *((ebp - 0x20));
            edx = ecx + edx*4;
        } else {
            edx += *((ebp - 0x1c));
        }
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_18;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_18;
            }
            caml_oldify_one (eax, edx);
        }
label_18:
        esi--;
        if (esi <= 0) {
            goto label_17;
        }
        edi += 2;
    } while (1);
label_17:
    eax = *((ebx + 4));
    eax &= 0xfffc;
    *((ebp - 0x1c)) += eax;
    eax = *((ebp - 0x1c));
    edx = *((eax - 4));
    goto label_3;
label_16:
    eax = *((ebp - 0x1c));
    eax += 8;
    edx = *(eax);
    *((ebp - 0x1c)) = edx;
    edx = *((eax + 4));
    eax = *((eax + 8));
    *((ebp - 0x20)) = eax;
    if (*((ebp - 0x1c)) != 0) {
        goto label_3;
    }
label_14:
    esi = caml_local_roots;
    *((ebp - 0x1c)) = 0;
    if (esi != 0) {
        goto label_19;
    }
    goto label_20;
    do {
label_4:
        edx = ebx*4;
        edx += *((esi + edi*4 + 0xc));
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_21;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_21;
            }
            caml_oldify_one (eax, edx);
        }
label_21:
        ebx++;
    } while (*((esi + 8)) > ebx);
label_5:
    edi++;
    if (*((esi + 4)) <= edi) {
        goto label_7;
    }
label_6:
    ebx = *((ebp - 0x1c));
    if (*((esi + 8)) > 0) {
        goto label_4;
    }
    goto label_5;
label_7:
    esi = *(esi);
    if (esi == 0) {
        goto label_20;
    }
label_19:
    edi = 0;
    if (*((esi + 4)) > 0) {
        goto label_6;
    }
    goto label_7;
label_20:
    caml_scan_global_young_roots (sym.caml_oldify_one);
    caml_final_do_young_roots (sym.caml_oldify_one);
    eax = caml_scan_roots_hook;
    if (eax != 0) {
        void (*eax)(uint32_t) (sym.caml_oldify_one);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c340 */
#include <stdint.h>
 
int32_t camlUnix_fun_2698 (void) {
    eax = unix_mkdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80546b0 */
#include <stdint.h>
 
int32_t camlList_map_1062 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t) (edx, eax);
        eax = *(esp);
        ebx = *((esp + 4));
        eax = camlList_map_1062 (eax);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 8));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e601 */
#include <stdint.h>
 
uint32_t caml_putword (int32_t arg_8h, int32_t arg_ch) {
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    eax = caml_channel_binary_mode (ebx, esi);
    if (eax == 0) {
        caml_failwith ("output_binary_int: not a binary channel");
    }
    eax = *((ebx + 0x10));
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    edx >>= 0x18;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    edx >>= 0x10;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    edx >>= 8;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073702 */
#include <stdint.h>
 
void caml_static_release_bytecode (void) {
    int32_t var_8h;
    return caml_failwith ("Meta.static_release_bytecode impossible with native code");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073d50 */
#include <stdint.h>
 
int32_t caml_weak_check (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax++;
    if (eax != 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.get");
label_0:
    eax = *((edx + eax*4));
    al = (eax != *(obj.caml_weak_none)) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80670b9 */
#include <stdint.h>
 
void caml_raise_zero_divide (void) {
    return caml_raise_constant (loc.caml_exn_Division_by_zero);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806baff */
#include <stdint.h>
 
int32_t caml_nativeint_mod (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    ecx = *((eax + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            caml_copy_nativeint (0);
        }
    } else {
        eax = edx;
        edx >>= 0x1f;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        caml_copy_nativeint (edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c861 */
#include <stdint.h>
 
uint32_t caml_modf_float (int32_t arg_8h) {
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_10h;
    int32_t var_8h;
    ebx = caml_local_roots;
    *((ebp - 0x30)) = ebx;
    *((ebp - 0x28)) = 1;
    *((ebp - 0x2c)) = 1;
    eax = ebp + 8;
    *((ebp - 0x24)) = eax;
    *((ebp - 0x34)) = 0;
    *((ebp - 0x38)) = 0;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x30;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 3;
    eax = ebp - 0x34;
    *((ebp - 0x50)) = eax;
    eax = ebp - 0x38;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x3c;
    *((ebp - 0x48)) = eax;
    eax = ebp - 0x10;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    modf (ebx, eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x38)) = eax;
    *(fp_stack--) = *((ebp - 0x10));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x3c)) = eax;
    eax = caml_alloc_tuple (2);
    *((ebp - 0x34)) = eax;
    edx = *((ebp - 0x38));
    *(eax) = edx;
    edx = *((ebp - 0x3c));
    eax = *((ebp - 0x34));
    *((eax + 4)) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x34));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c600 */
#include <stdint.h>
 
int32_t camlUnix_fun_2774 (void) {
    eax = unix_execv;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80581a0 */
#include <stdint.h>
 
int32_t camlHashtbl_Make_1251 (void) {
    int32_t var_4h_3;
    int32_t var_8h_3;
    int32_t var_ch_3;
    int32_t var_10h_2;
    int32_t var_14h;
    int32_t var_18h_2;
    ebx = eax;
    eax = camlHashtbl;
    *(esp) = eax;
    eax = .comment;
    *((esp + 4)) = eax;
    eax = .comment;
    *((esp + 8)) = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xe8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xcf7;
            *(eax) = sym.camlHashtbl__safehash_1177;
            *((eax + 4)) = 3;
            *((eax + 8)) = ebx;
            ecx = eax + 0x10;
            *((esp + 0xc)) = ecx;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry3;
            *((ecx + 4)) = 7;
            *((ecx + 8)) = 0x8056e20;
            *((ecx + 0xc)) = eax;
            ecx = eax + 0x24;
            *((esp + 0x10)) = ecx;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8056f30;
            *((ecx + 0xc)) = ebx;
            *((ecx + 0x10)) = eax;
            edx = eax + 0x3c;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry2;
            *((edx + 4)) = 5;
            *((edx + 8)) = 0x8057030;
            *((edx + 0xc)) = ebx;
            ecx = eax + 0x50;
            *((esp + 0x14)) = ecx;
            *((ecx - 4)) = 0x18f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80570c0;
            *((ecx + 0xc)) = ebx;
            *((ecx + 0x10)) = eax;
            *((ecx + 0x14)) = edx;
            esi = eax + 0x6c;
            *((esi - 4)) = 0x14f7;
            *(esi) = sym.caml_curry2;
            *((esi + 4)) = 5;
            *((esi + 8)) = 0x80572d0;
            *((esi + 0xc)) = ebx;
            *((esi + 0x10)) = eax;
            edx = eax + 0x84;
            *((edx - 4)) = 0x14f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x80573a0;
            *((edx + 0xc)) = ebx;
            *((edx + 0x10)) = eax;
            ecx = eax + 0x9c;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80575a0;
            *((ecx + 0xc)) = ebx;
            *((ecx + 0x10)) = eax;
            ebx = .comment;
            ebp = .comment;
            edi = .comment;
            eax += 0xb4;
            *((eax - 4)) = 0x3000;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            ebx = *((esp + 8));
            *((eax + 8)) = ebx;
            ebx = *((esp + 0xc));
            *((eax + 0xc)) = ebx;
            ebx = *((esp + 0x10));
            *((eax + 0x10)) = ebx;
            ebx = *((esp + 0x14));
            *((eax + 0x14)) = ebx;
            *((eax + 0x18)) = esi;
            *((eax + 0x1c)) = edx;
            *((eax + 0x20)) = ecx;
            ebx = *((esp + 0x18));
            *((eax + 0x24)) = ebx;
            *((eax + 0x28)) = ebp;
            *((eax + 0x2c)) = edi;
            return eax;
        }
        caml_call_gc (ebx);
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c300 */
#include <stdint.h>
 
int32_t camlUnix_fun_2690 (void) {
    eax = unix_chroot;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f030 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1850 (void) {
    esi = eax;
    ecx = *((ebx + 0xc));
    eax = *((esi + ecx*2 - 2));
    edx = *((ebx + 0x10));
    ecx = *(esi);
    ecx = ecx + edx*2 - 2;
    ebx = *((ebx + 8));
    return caml_send0 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fa83 */
#include <stdint.h>
 
int32_t caml_deserialize_block_2 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_14h;
    int32_t var_10h;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    ecx = intern_src;
    if (edi <= 0) {
        goto label_0;
    }
    eax = 0;
    *((ebp - 0x14)) = edi;
    *((ebp - 0x10)) = edi;
    do {
        esi = *((ecx + eax));
        edi = *((ecx + eax + 1));
        edx = edi;
        *((ebx + eax)) = dl;
        edx = esi;
        *((ebx + eax + 1)) = dl;
        eax += 2;
        *((ebp - 0x14))--;
    } while (*((ebp - 0x14)) != 0);
    edi = *((ebp - 0x10));
    ecx = ecx + edi*2;
label_0:
    *(obj.intern_src) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063e54 */
#include <stdint.h>
 
uint32_t unix_nice (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14aa7;
    eax = errno_location ();
    esi = eax;
    *(eax) = 0;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = nice ();
    if (eax == -1) {
        if (*(esi) == 0) {
            goto label_0;
        }
        eax = ebx - 0x24df;
        uerror (eax, 0);
    }
label_0:
    eax = eax + eax + 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a404 */
#include <stdint.h>
 
void nice (void) {
    nice ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060b50 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_meth_app_env_1444 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlCamlinternalOO__fun_1838;
            *((eax + 4)) = 3;
            *((eax + 8)) = edx;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f9ac */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_1 (void) {
    edx = intern_src;
    eax = *(edx);
    edx++;
    *(obj.intern_src) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c620 */
#include <stdint.h>
 
int32_t camlUnix_fun_2778 (void) {
    eax = caml_sys_getenv;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e736 */
#include <stdint.h>
 
uint32_t caml_ml_flush (int32_t arg_8h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    if (*(ebx) == -1) {
        *(obj.caml_local_roots) = esi;
    } else {
        eax = caml_channel_mutex_lock;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        caml_flush (ebx);
        eax = caml_channel_mutex_unlock;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        *(obj.caml_local_roots) = esi;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806311d */
#include <stdint.h>
 
int32_t unix_getprotobyname (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x157e3;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getprotobyname ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_proto_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a0a4 */
#include <stdint.h>
 
void getprotobyname (void) {
    getprotobyname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80664ac */
#include <stdint.h>
 
uint32_t unix_unlink (void) {
    int32_t var_bp_8h;
    int32_t var_bp_4h;
    int32_t var_4h_2;
    char * path;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1244f;
    esi = *((ebp + 8));
    eax = unlink (esi);
    if (eax == -1) {
        eax = ebx - 0x21c4;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c5d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2770 (void) {
    eax = unix_execvp;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065a1b */
#include <stdint.h>
 
uint32_t unix_lstat (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x12ee4;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = lxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x2360;
        uerror (eax, esi);
    }
    if (*((ebp - 0x38)) >= 0) {
        if (*((ebp - 0x38)) <= 0) {
            if (*((ebp - 0x3c)) <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = *((ebp - 0x58));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        eax = ebx - 0x2360;
        unix_error (0x4b, eax, esi);
    }
label_0:
    edx = ebp - 0x68;
    eax = 0;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056180 */
#include <stdint.h>
 
int32_t camlString_index_from_1116 (void) {
    esi = ebx;
    edx = ecx;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx + 1;
    if (esi >= 1) {
        if (esi > ebx) {
            goto label_0;
        }
        ecx = esi;
        void (*0x80560f0)() ();
    }
label_0:
    eax = "String.index_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064ced */
#include <stdint.h>
 
int32_t unix_sigsuspend (int32_t arg_8h) {
    int32_t var_88h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13c0b;
    esi = ebp - 0x88;
    edx = esi;
    eax = *((ebp + 8));
    decode_sigset ();
    caml_enter_blocking_section ();
    *(esp) = esi;
    eax = sigsuspend ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = errno_location ();
        if (*(eax) == 4) {
            goto label_0;
        }
        eax = ebx - 0x2444;
        uerror (eax, 0);
    }
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a8c4 */
#include <stdint.h>
 
void sigsuspend (void) {
    sigsuspend ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c060 */
#include <stdint.h>
 
int32_t camlUnix_fun_2612 (void) {
    eax = unix_getgrgid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050250 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1493 (void) {
    eax = caml_ml_pos_in_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805c8e0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1572 (void) {
    int32_t var_4h_4;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_make_vect;
    eax = caml_c_call (3);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 4));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 8));
    eax = *((eax + 0xc));
    void (*0x804b5d0)() ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d490 */
#include <stdint.h>
 
int32_t camlUnix_system_1891 (void) {
    *(esp) = eax;
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        eax = unix_waitpid;
        eax = caml_c_call (1);
        eax += 4;
        eax = *(eax);
        return eax;
    }
    fcn_0804d4f0 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d4f0 */
#include <stdint.h>
 
int32_t fcn_0804d4f0 (int32_t arg_8h) {
    *(obj.caml_exception_pointer) = esp;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = "/bin/sh";
            *((ebx + 4)) = 0x807a4bc;
            eax = *((esp + 8));
            *((ebx + 8)) = eax;
            eax = unix_execv;
            caml_c_call ("/bin/sh");
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056060 */
#include <stdint.h>
 
int32_t camlString_apply1_1100 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx + 1;
    if (ecx == 1) {
        eax = ebx;
        return eax;
    }
    eax = ebx;
    eax = camlString_copy_1042 (ebx, eax);
    eax = *(esp);
    eax = *(eax);
    eax = eax + eax + 1;
    ebx = *((esp + 4));
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t) (eax);
    eax >>= 1;
    edx = eax;
    eax = *((esp + 8));
    *(eax) = dl;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e610 */
#include <stdint.h>
 
int32_t camlPrintf_sprintf_1413 (void) {
    eax = loc.camlPrintf__39;
    eax = camlPrintf_ksprintf_1411 (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806dfee */
#include <stdint.h>
 
uint32_t caml_really_getblock (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    if (ebx <= 0) {
        goto label_0;
    }
    do {
        eax = caml_getblock (edi, esi, ebx);
        if (eax == 0) {
            goto label_0;
        }
        ebx -= eax;
        if (ebx <= 0) {
            goto label_0;
        }
        esi += eax;
    } while (1);
label_0:
    al = (ebx == 0) ? 1 : 0;
    eax = (int32_t) al;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807310a */
#include <stdint.h>
 
int32_t caml_md5_chan (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10a0h;
    int32_t var_109ch;
    int32_t var_1090h;
    int32_t var_90h;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_4h;
    int32_t var_8h;
    eax = caml_local_roots;
    *((ebp - 0x10a0)) = eax;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    edx = ebp + 8;
    *((ebp - 0x2c)) = edx;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    *((ebp - 0x109c)) = eax;
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        edx = *((ebp - 0x109c));
        void (*eax)(uint32_t) (edx);
    }
    eax = ebp - 0x90;
    caml_MD5Init (eax);
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    if (ebx >= 0) {
        edi = ebp - 0x1090;
        if (ebx > 0) {
            goto label_0;
        }
        goto label_1;
    }
    ebx = ebp - 0x1090;
    esi = ebp - 0x90;
    do {
        eax = *((ebp - 0x109c));
        eax = caml_getblock (eax, ebx, 0x1000);
        if (eax == 0) {
            goto label_1;
        }
        caml_MD5Update (esi, ebx, eax);
    } while (1);
    do {
label_0:
        eax = 0x1000;
        if (ebx <= 0x1000) {
            eax = ebx;
        }
        edx = *((ebp - 0x109c));
        eax = caml_getblock (edx, edi, eax);
        esi = eax;
        if (eax == 0) {
            eax = caml_raise_end_of_file ();
        }
        eax = ebp - 0x90;
        caml_MD5Update (eax, edi, eax);
        ebx -= esi;
    } while (ebx > 0);
label_1:
    eax = caml_alloc_string (0x10);
    ebx = eax;
    eax = ebp - 0x90;
    caml_MD5Final (ebx, eax);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        edx = *((ebp - 0x109c));
        void (*eax)(uint32_t) (edx);
    }
    eax = *((ebp - 0x10a0));
    *(obj.caml_local_roots) = eax;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80577a0 */
#include <stdint.h>
 
int32_t camlHashtbl_resize_1061 (void) {
    int32_t var_18h_3;
    eax = *((ebx + 4));
    eax = *((eax - 4));
    eax >>= 9;
    eax |= 1;
    ebx = .comment;
    eax >>= 1;
    eax = eax*4 + 3;
    eax = camlPervasives_min_1022 (eax, eax);
    ebx = *((esp + 8));
    if (eax == ebx) {
        goto label_1;
    }
    *((esp + 4)) = eax;
    *((esp + 8)) = ebx;
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    *((esp + 0xc)) = ebx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x14f7;
    *(ecx) = sym.camlHashtbl__insert_bucket_1068;
    *((ecx + 4)) = 3;
    eax = *(esp);
    *((ecx + 8)) = eax;
    eax = *((esp + 4));
    *((ecx + 0xc)) = eax;
    *((ecx + 0x10)) = ebx;
    eax = 1;
    ebx = *((esp + 8));
    ebx += 0xfffffffe;
    if (eax > ebx) {
        goto label_3;
    }
    *((esp + 8)) = ebx;
    *((esp + 4)) = eax;
    *(esp) = ecx;
    do {
        ebx = *((esp + 0x14));
        ecx = *((ebx - 4));
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_4;
        }
        eax = *((ebx + eax*2 - 2));
        ebx = *(esp);
        camlHashtbl_insert_bucket_1068 ();
        eax = *((esp + 4));
        ecx = *((esp + 4));
        eax += 2;
        *((esp + 4)) = eax;
        ebx = *((esp + 8));
    } while (ecx != ebx);
label_3:
    eax = *((esp + 0xc));
    eax = *((esp + 0x14));
    eax += 4;
    caml_modify (eax, eax);
    eax = 1;
    return eax;
label_1:
    eax = 1;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
label_4:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fe10 */
#include <stdint.h>
 
int32_t camlPervasives_open_in_1218 (void) {
    ecx = eax;
    ebx = 1;
    eax = loc.camlPervasives__90;
    return camlPervasives_open_in_gen_1214 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d586 */
#include <stdint.h>
 
int32_t caml_array_get_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xb;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    *(fp_stack--) = *((edx + eax*8));
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    edx = caml_young_ptr;
    eax = edx - 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        *(obj.caml_young_ptr) = edx;
        caml_minor_collection ();
        *(obj.caml_young_ptr) -= 0xc;
    }
    eax = caml_young_ptr;
    *(eax) = 0xbfd;
    eax = caml_young_ptr;
    eax += 4;
    *(fp_stack--) = *((ebp - 0x10));
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b3e0 */
#include <stdint.h>
 
int32_t caml_curry2_1 (void) {
    esi = eax;
    ecx = *((ebx + 0xc));
    eax = *((ebx + 8));
    edx = *((ecx + 8));
    ebx = esi;
    return void (*edx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054980 */
#include <stdint.h>
 
int32_t camlList_fold_left2_1119 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        esi = eax;
        if (ecx == 1) {
            goto label_0;
        }
        if (edx == 1) {
            goto label_1;
        }
        eax = *((edx + 4));
        edx = *(edx);
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = ebx;
        ebx = ecx;
        ecx = edx;
        edx = esi;
        eax = caml_apply3 (esi, eax, eax);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
        edx = *((esp + 8));
    } while (1);
label_0:
    if (edx == 1) {
        eax = ebx;
        return eax;
    }
label_1:
    eax = "List.fold_left2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cf3a */
#include <stdint.h>
 
int32_t caml_string_lessthan (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax <= 0) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806be00 */
#include <stdint.h>
 
int32_t caml_int64_of_int32 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = eax;
    edx >>= 0x1f;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f690 */
#include <stdint.h>
 
void camlCamlinternalOO_get_method_labels_1192 (void) {
    ebx = .comment;
    ecx = *(ebx);
    void (*ecx)(uint32_t) (ebx);
    ebx = *(esp);
    return camlArray_map_1105 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064bd0 */
#include <stdint.h>
 
uint32_t unix_setsid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13d30;
    setsid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a094 */
#include <stdint.h>
 
void setsid (void) {
    setsid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066234 */
#include <stdint.h>
 
int32_t unix_truncate_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x126c7;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    *((esp + 4)) = eax;
    *((esp + 8)) = edx;
    *(esp) = esi;
    eax = truncate64 ();
    if (eax == -1) {
        eax = ebx - 0x1484;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a224 */
#include <stdint.h>
 
void truncate64 (void) {
    truncate64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c75c */
#include <stdint.h>
 
int32_t caml_tanh_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    tanh (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a314 */
#include <stdint.h>
 
void tanh (void) {
    tanh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bf90 */
#include <stdint.h>
 
int32_t camlUnix_fun_2590 (void) {
    eax = unix_getpeername;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058a30 */
#include <stdint.h>
 
int32_t camlMap_equal_aux_1332 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        if (ebx == 1) {
            goto label_1;
        }
        ecx = *((ebx + 0xc));
        ecx = *((ebx + 8));
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *((eax + 0xc));
        ecx = *((eax + 8));
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((esp + 0x18));
        ecx = *((ecx + 0xc));
        ecx = *(ecx);
        eax = caml_apply2 (ecx, ecx, ecx);
        if (eax != 1) {
            goto label_2;
        }
        eax = *((esp + 0x18));
        ecx = *((eax + 0x14));
        eax = *(esp);
        ebx = *((esp + 4));
        eax = caml_apply2 ();
        if (eax == 1) {
            goto label_3;
        }
        eax = *((esp + 8));
        ebx = *((esp + 0xc));
        eax = camlMap_cons_enum_1304 ();
        eax = *((esp + 0x10));
        ebx = *((esp + 0x14));
        camlMap_cons_enum_1304 (eax);
        ebx = *(esp);
        ecx = *((esp + 0x18));
    } while (1);
label_3:
    eax = 1;
    return eax;
label_2:
    eax = 1;
    return eax;
label_1:
    eax = 1;
    return eax;
label_0:
    if (ebx != 1) {
        eax = 1;
        return eax;
    }
    eax = 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fc40 */
#include <stdint.h>
 
int32_t camlPervasives_open_out_1179 (void) {
    ecx = eax;
    ebx = 0x36d;
    eax = camlPervasives__94;
    return camlPervasives_open_out_gen_1175 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063014 */
#include <stdint.h>
 
uint32_t unix_getppid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x158ec;
    getppid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a414 */
#include <stdint.h>
 
void getppid (void) {
    getppid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cbe0 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_int_1653 (void) {
    eax = unix_setsockopt;
    caml_c_call (3);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ac70 */
#include <stdint.h>
 
int32_t caml_curry9_7 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_8;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073b83 */
#include <stdint.h>
 
int32_t caml_callback (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_callback_exn (eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b180 */
#include <stdint.h>
 
int32_t caml_curry5_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f540 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_put_1178 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ebx += 2;
    camlCamlinternalOO_resize_1173 (eax, ebx, ecx);
    eax = *(esp);
    ecx = *((eax + 4));
    eax = *((ecx - 4));
    eax >>= 9;
    ebx = *((esp + 4));
    if (eax > ebx) {
        eax = *((esp + 8));
        caml_modify (ecx + ebx*2 - 2, eax);
        eax = 1;
        return eax;
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8057f80 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_1122 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlHashtbl__mem_in_bucket_1125;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            eax = *((edi + 4));
            esi = *((eax - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = caml_hash_univ_param (0x15, 0xc9, ecx);
                eax >>= 1;
                ecx = esi;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            ecx = *((edi + 4));
            eax = *((ecx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ecx + edx*2 - 2));
            void (*0x8056d20)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80522d0 */
#include <stdint.h>
 
int32_t camlArray_sub_1081 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
    if (ebx < 1) {
        goto label_2;
    }
    if (ecx < 1) {
        goto label_2;
    }
    esi = *((edx - 4));
    eax = *((edx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = esi;
        eax >>= 9;
    } else {
        eax = esi;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= ecx;
    eax++;
    if (ebx > eax) {
        goto label_2;
    }
    if (ecx == 1) {
        eax = loc.camlArray__28;
        return eax;
    }
    *(esp) = ecx;
    *((esp + 4)) = ebx;
    *((esp + 8)) = edx;
    eax = *((edx - 4));
    if (eax != 0xfe) {
        eax = *((edx + ebx*2 - 2));
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x8fd;
        *(fp_stack--) = *((edx + ebx*4 - 4));
        *(eax) = fp_stack[0];
        fp_stack--;
    }
    eax = caml_make_vect;
    eax = caml_c_call (ecx);
    esi = eax;
    ebx = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ebx > eax) {
        goto label_4;
    }
    *((esp + 0xc)) = eax;
    *(esp) = esi;
    do {
        eax = *((esp + 4));
        edx = eax + ebx - 1;
        ecx = *((esp + 8));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            ecx = *((ecx + edx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + edx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            ecx = eax;
        }
        esi = *(esp);
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebx*2 - 2, ecx);
        } else {
            *(fp_stack--) = *(ecx);
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebx;
        eax = ebx;
        eax += 2;
        ebx = eax;
        eax = *((esp + 0xc));
    } while (ecx != eax);
label_4:
    eax = esi;
    return eax;
label_2:
    eax = "Array.sub";
    void (*0x804f900)() ();
label_5:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80664f4 */
#include <stdint.h>
 
int32_t unix_utimes (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x1240b;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x20));
    *((ebp - 0x10)) = eax;
    edx = *((ebp + 0x10));
    *(fp_stack--) = *(edx);
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    edx = *((ebp - 0x20));
    if (eax == 0) {
        if (edx == 0) {
            goto label_0;
        }
    }
    eax = ebp - 0x10;
label_0:
    *((ebp - 0xc)) = edx;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = utime ();
    if (eax == -1) {
        eax = ebx - 0x21bd;
        uerror (eax, esi);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070862 */
#include <stdint.h>
 
int32_t caml_input_value_from_string (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    caml_input_val_from_string (eax, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b520 */
#include <stdint.h>
 
void camlPrintf_got_spec_1297 (void) {
    edx = ebx;
    ebx = ecx;
    esi = *((ebx + 0xc));
    ecx = *((ebx + 0x14));
    ebx = *((ebx + 0x10));
    return camlPrintf_scan_flags_1292 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c140 */
#include <stdint.h>
 
int32_t camlUnix_fun_2640 (void) {
    eax = unix_setitimer;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063eb4 */
#include <stdint.h>
 
int32_t unix_open (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    char * src;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x14a4a;
    eax = *((ebx - 0x18));
    edi = *(eax);
    *((ebp - 0x38)) = edi;
    edx = ebp - 0x38;
    *(eax) = edx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 3;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebx + 0xb8d4;
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x3c)) = eax;
    eax = *((ebp + 8));
    eax = caml_string_length (eax);
    eax++;
    eax = caml_stat_alloc (eax);
    esi = eax;
    eax = *((ebp + 8));
    strcpy (esi, eax);
    caml_enter_blocking_section ();
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    edx = *((ebp - 0x3c));
    *((esp + 4)) = edx;
    *(esp) = esi;
    eax = open64 ();
    *((ebp - 0x3c)) = eax;
    caml_leave_blocking_section ();
    caml_stat_free (esi);
    if (*((ebp - 0x3c)) == -1) {
        eax = *((ebp + 8));
        eax = ebx - 0x24da;
        uerror (eax, eax);
    }
    eax = *((ebx - 0x18));
    *(eax) = edi;
    edx = *((ebp - 0x3c));
    eax = edx + edx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a464 */
#include <stdint.h>
 
void strcpy (void) {
    strcpy ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049ef4 */
#include <stdint.h>
 
void open64 (void) {
    open64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c160 */
#include <stdint.h>
 
int32_t camlUnix_fun_2644 (void) {
    eax = unix_utimes;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060c50 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_send_env_1463 (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x18f7;
            *(eax) = sym.camlCamlinternalOO__fun_1854;
            *((eax + 4)) = 3;
            *((eax + 8)) = esi;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            *((eax + 0x14)) = edx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fcfb */
#include <stdint.h>
 
int32_t caml_deserialize_error (int32_t arg_8h) {
    int32_t var_bp_8h;
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    intern_cleanup ();
    eax = *((ebp + 8));
    return caml_failwith (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cac4 */
#include <stdint.h>
 
int32_t caml_mul_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] *= *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806f926 */
#include <stdint.h>
 
uint32_t caml_output_value (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 3;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x14)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    caml_output_val (ebx, eax, eax);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806383d */
#include <stdint.h>
 
uint32_t unix_getitimer (int32_t arg_8h) {
    int32_t var_18h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x150c3;
    eax = ebp - 0x18;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x251c));
    *(esp) = eax;
    eax = getitimer ();
    if (eax == -1) {
        eax = ebx - 0x2531;
        uerror (eax, 0);
    }
    eax = ebp - 0x18;
    unix_convert_itimer ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a854 */
#include <stdint.h>
 
void getitimer (void) {
    getitimer ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062330 */
#include <stdint.h>
 
uint32_t unix_fork (void) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x165cb;
    eax = fork ();
    esi = eax;
    if (eax == -1) {
        eax = ebx - 0x25a8;
        uerror (eax, 0);
    }
    eax = *((ebx - 0x10));
    if (*(eax) != 0) {
        eax = *((ebx - 0xc));
        eax = *(eax);
        if (eax != 0) {
            if (esi == 0) {
                goto label_0;
            }
        }
        if (eax != 0) {
            goto label_1;
        }
        if (esi == 0) {
            goto label_1;
        }
label_0:
        caml_debugger_cleanup_fork ();
    }
label_1:
    eax = esi + esi + 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062a64 */
#include <stdint.h>
 
uint32_t unix_getgroups (void) {
    int32_t var_40018h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x15e97;
    eax = ebp - 0x40018;
    *((esp + 4)) = eax;
    *(esp) = 0x10000;
    eax = getgroups ();
    esi = eax;
    if (eax == -1) {
        eax = ebx - 0x2592;
        eax = uerror (eax, 0);
    }
    caml_alloc_tuple (eax);
    if (esi <= 0) {
        goto label_0;
    }
    edx = 0;
    edi = ebp - 0x40018;
    do {
        ecx = *((edi + edx*4));
        ecx = ecx + ecx + 1;
        *((eax + edx*4)) = ecx;
        edx++;
    } while (edx != esi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e89c */
#include <stdint.h>
 
uint32_t caml_ml_seek_out (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    edx = eax;
    edx >>= 0x1f;
    caml_seek_out (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805c960 */
#include <stdint.h>
 
int32_t camlPrintf_get_int_literal_1258 (void) {
    int32_t var_4h;
    do {
        esi = ebx;
        esi >>= 1;
        edx = *((ecx + 0xc));
        edx = *((edx + esi));
        edx = edx + edx + 1;
        if (edx < 0x61) {
            goto label_0;
        }
        if (edx >= 0x75) {
            goto label_1;
        }
        ebx += 2;
        eax >>= 1;
        eax *= 0x14;
        eax = eax + edx - 0x60;
    } while (1);
label_0:
    if (edx != 0x49) {
        goto label_1;
    }
    if (eax == 1) {
        eax = "printf: bad positional specification (0).";
        void (*0x804f8c0)() ();
    }
    eax += 0xfffffffe;
    eax = camlPrintf_index_of_int_1037 (ecx, ebx);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x400;
            *(edx) = ebx;
            eax = *(esp);
            ecx = *((eax + 0x10));
            ebx = *((esp + 4));
            ebx += 2;
            eax = edx;
            void (*0x804b5d0)() ();
label_1:
            edx = *((ecx + 0x10));
            ebx = *((ecx + 0x14));
            eax = 1;
            ecx = edx;
            void (*0x804b5d0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bfb0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2594 (void) {
    eax = unix_shutdown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075187 */
#include <stdint.h>
 
int32_t caml_register_custom_operations (int32_t arg_8h) {
    caml_stat_alloc (8);
    edx = *((ebp + 8));
    *(eax) = edx;
    edx = custom_ops_table;
    *((eax + 4)) = edx;
    *(obj.custom_ops_table) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805eb80 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1719 (void) {
    int32_t var_4h;
    eax = ebx;
    esi = ecx;
    edx = .comment;
    ecx = *((edx + 0x54));
    edx = *((esi + 0xc));
    ebx = *((edx + 0x18));
    eax = camlMap_find_1117 (eax, eax);
    ebx = eax;
    eax = .comment;
    edx = *((eax + 0xc));
    eax = *(esp);
    ecx = *((esp + 4));
    return camlMap_add_1108 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c4b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2740 (void) {
    eax = unix_truncate;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8074d08 */
#include <stdint.h>
 
int32_t caml_final_register (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 0xc));
    if ((bl & 1) == 0) {
        esi = ebx;
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 3) != 0) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Gc.finalise");
label_0:
    eax = size;
    if (*(obj.young) >= eax) {
        edx = final_table;
        if (edx == 0) {
            eax = caml_stat_alloc (0x168);
            *(obj.final_table) = eax;
            *(obj.size) = 0x1e;
        } else {
            edi = eax + eax;
            eax = edi + eax*4;
            eax <<= 2;
            eax = caml_stat_resize (edx, eax);
            *(obj.final_table) = eax;
            *(obj.size) = edi;
        }
    }
    eax = young;
    edx = eax * 3;
    edx <<= 2;
    edx += *(obj.final_table);
    ecx = *((ebp + 8));
    *(edx) = ecx;
    ecx = esi - 4;
    if (*(ecx) == 0xf9) {
        ebx = *(ecx);
        ebx >>= 0xa;
        ebx <<= 2;
        *((edx + 8)) = ebx;
        ecx = *(ecx);
        ecx >>= 0xa;
        ecx <<= 2;
        esi -= ecx;
        *((edx + 4)) = esi;
    } else {
        *((edx + 8)) = 0;
        *((edx + 4)) = ebx;
    }
    eax++;
    *(obj.young) = eax;
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b6c0 */
#include <stdint.h>
 
int32_t camlPrintf_cont_s_1361 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = *((edx + 0x54));
    eax = *((edx + 0x5c));
    caml_apply2 (edx, eax, ecx);
    ecx = *(esp);
    ecx += 0xfffffff0;
    eax = *((esp + 4));
    ebx = *((esp + 8));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c4e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2744 (void) {
    eax = caml_channel_descriptor;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e180 */
#include <stdint.h>
 
int32_t camlPrintf_make_valid_float_lexeme_1270 (void) {
    ecx = eax;
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    edx = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.camlPrintf__valid_float_loop_1273;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            *((ebx + 0xc)) = edx;
            eax = 1;
            void (*0x805ca20)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073f4b */
#include <stdint.h>
 
int32_t caml_weak_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    eax = *((ebp + 8));
    ecx = *((ebp + 0x10));
    edx = *((ebp + 0xc));
    edx >>= 1;
    edx++;
    if (edx != 0) {
        esi = eax;
        ebx = *((eax - 4));
        ebx >>= 0xa;
        if (edx < ebx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.set");
label_0:
    if (ecx != 1) {
        if ((cl & 1) == 0) {
            ecx = *(ecx);
            do_set ();
        }
    } else {
        eax = caml_weak_none;
        *((esi + edx*4)) = eax;
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80692f0 */
#include <stdint.h>
 
int32_t caml_darken (int32_t arg_8h) {
    eax = *((ebp + 8));
    if ((al & 1) == 0) {
        ebx = eax;
        ecx = eax;
        ecx >>= 0x17;
        edx = eax;
        edx >>= 0xc;
        edx &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
        if ((*((ecx + edx)) & 1) == 0) {
            goto label_0;
        }
        edx = *((eax - 4));
        ecx = (int32_t) dl;
        if (ecx == 0xf9) {
            edx >>= 0xa;
            eax = edx*4;
            ebx -= eax;
            eax = ebx;
            edx = *((ebx - 4));
            ecx = (int32_t) dl;
        }
        if ((dh & 3) != 0) {
            goto label_0;
        }
        if (ecx <= 0xfa) {
            dh &= 0xfc;
            dh |= 1;
            *((eax - 4)) = edx;
            edx = gray_vals_cur;
            *(edx) = eax;
            eax = edx + 4;
            *(obj.gray_vals_cur) = eax;
            if (eax < *(obj.gray_vals_end)) {
                goto label_0;
            }
            realloc_gray_vals ();
        } else {
            dh |= 3;
            *((eax - 4)) = edx;
        }
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050200 */
#include <stdint.h>
 
int32_t camlPervasives_read_int_1289 (void) {
    eax = 1;
    eax = camlPervasives_read_line_1288 ();
    eax = caml_int_of_string;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80501e0 */
#include <stdint.h>
 
int32_t camlPervasives_read_line_1288 (void) {
    eax = caml_ml_flush;
    caml_c_call (*(0x807c02c));
    eax = .comment;
    return camlPervasives_input_line_1241 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8057030 */
#include <stdint.h>
 
uint32_t camlHashtbl_find_rec_1193 (void) {
    int32_t var_4h;
    int32_t var_8h_2;
    int32_t var_ch;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 8));
        edx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *((ecx + 0xc));
        ecx = *(ecx);
        eax = caml_apply2 (eax, edx, ecx);
        if (eax != 1) {
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c190 */
#include <stdint.h>
 
int32_t camlUnix_fun_2648 (void) {
    eax = unix_sleep;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80585e0 */
#include <stdint.h>
 
int32_t loc_camlObj_code_begin (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            ecx = *((edx - 4));
            ecx >>= 0xa;
            if (ecx <= ebx) {
                goto label_0;
            }
            *(fp_stack--) = *((edx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059420 */
#include <stdint.h>
 
uint32_t camlMap_map_1176 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    do {
label_0:
        if (ebx == 1) {
            goto label_1;
        }
        ecx = *((ebx + 0x10));
        ecx = *((ebx + 0xc));
        ecx = *((ebx + 8));
        ecx = *((ebx + 4));
        ebx = *(ebx);
        eax = camlMap_map_1176 (ecx, eax, ecx);
    } while (1);
    ebx = *((esp + 4));
    ecx = *(ebx);
    eax = *(esp);
    eax = void (*ecx)(uint32_t) (eax);
    eax = *((esp + 4));
    ebx = *((esp + 8));
    eax = camlMap_map_1176 (eax);
    goto label_0;
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1400;
            ebx = *((esp + 0xc));
            *(eax) = ebx;
            ebx = *((esp + 0x10));
            *((eax + 4)) = ebx;
            ebx = *(esp);
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = ecx;
            ebx = *((esp + 0x14));
            *((eax + 0x10)) = ebx;
            return eax;
label_1:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80737ae */
#include <stdint.h>
 
uint32_t caml_format_exception (int32_t arg_8h) {
    int32_t var_170h;
    uint32_t var_16ch;
    char * s;
    int32_t var_120h;
    int32_t var_11ch;
    int32_t var_118h;
    int32_t var_19h;
    int32_t var_18h;
    char * format;
    size_t n;
    ebx = *((ebp + 8));
    eax = ebp - 0x120;
    edx = ebp - 0x118;
    *((ebp - 0x120)) = edx;
    edx = ebp - 0x19;
    *((ebp - 0x11c)) = edx;
    edx = *(ebx);
    edx = *(edx);
    add_string (ebx, esi, edi);
    eax = *((ebx - 4));
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_0;
    }
    if (eax == 2) {
        esi = *((ebx + 4));
        if ((esi & 1) != 0) {
            goto label_1;
        }
        *((ebp - 0x16c)) = 0;
        if (*((esi - 4)) == 0) {
            goto label_2;
        }
    }
label_1:
    esi = ebx;
    *((ebp - 0x16c)) = 1;
label_2:
    eax = ebp - 0x120;
    edx = 0x28;
    add_char ();
    *((ebp - 0x170)) = esi;
    edi = esi;
    edi -= 4;
    eax = *(edi);
    eax >>= 0xa;
    if (*((ebp - 0x16c)) >= eax) {
        goto label_3;
    }
    esi = *((ebp - 0x16c));
    while (eax > esi) {
        if (*((ebp - 0x16c)) < esi) {
            edx = 0x80774cd;
            eax = ebp - 0x120;
            add_string ();
        }
        eax = *((ebp - 0x170));
        ebx = *((eax + esi*4));
        if ((bl & 1) != 0) {
            ebx >>= 1;
            edx = ebp - 0x160;
            sprintf (edx, 0x807717b, ebx);
            edx = ebp - 0x160;
            eax = ebp - 0x120;
            add_string ();
        } else {
            if (*((ebx - 4)) == 0xfc) {
                edx = 0x22;
                eax = ebp - 0x120;
                add_char ();
                edx = ebx;
                eax = ebp - 0x120;
                add_string ();
                edx = 0x22;
                eax = ebp - 0x120;
                add_char ();
            } else {
                edx = 0x5f;
                eax = ebp - 0x120;
                add_char ();
            }
        }
        esi++;
        eax = *(edi);
        eax >>= 0xa;
    }
label_3:
    eax = ebp - 0x120;
    edx = 0x29;
    add_char ();
label_0:
    eax = *((ebp - 0x120));
    *(eax) = 0;
    eax = *((ebp - 0x120));
    edx = ebp - 0x18;
    eax -= edx;
    esi = eax + 0x101;
    eax = malloc (esi);
    ebx = eax;
    if (eax != 0) {
        eax = ebp - 0x118;
        memmove (ebx, eax, esi);
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fe30 */
#include <stdint.h>
 
int32_t camlPervasives_open_in_bin_1220 (void) {
    ecx = eax;
    ebx = 1;
    eax = loc.camlPervasives__89;
    return camlPervasives_open_in_gen_1214 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fa80 */
#include <stdint.h>
 
int32_t camlPervasives_char_of_int_1120 (void) {
    if (eax >= 1) {
        if (eax > 0x1ff) {
            goto label_0;
        }
        return;
    }
label_0:
    eax = "char_of_int";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805fe50 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_get_variable_1258 (void) {
    edx = eax;
    eax = ebx;
    eax = void (*0x805feb0)() ();
    ecx = loc.caml_exn_Not_found;
    ebx = *(eax);
    while (1) {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Assert_failure;
            *((eax + 4)) = "`/\b\b9";
            caml_raise_exn ();
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            ecx = .comment;
            ecx = *((ecx + 0x54));
            ebx = *((edx + 0x18));
            camlMap_find_1117 (*(obj.caml_exception_pointer));
            return eax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bfd0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2598 (void) {
    eax = unix_connect;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b243 */
#include <stdint.h>
 
int32_t caml_int_compare (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    cl = (edx > eax) ? 1 : 0;
    ecx = (int32_t) cl;
    dl = (edx < eax) ? 1 : 0;
    edx = (int32_t) dl;
    eax = ecx;
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80711de */
#include <stdint.h>
 
int32_t caml_sys_rename (char * oldpath, int32_t arg_ch) {
    char * newpath;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = rename (eax, eax);
    if (eax != 0) {
        caml_sys_error (1);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062d0f */
#include <stdint.h>
 
int32_t unix_gethostbyaddr (int32_t arg_8h, int32_t arg_ch, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch) {
    int32_t var_2738h;
    int32_t var_2734h;
    int32_t var_24h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x15bed;
    eax = *((ebp + 8));
    eax = *(eax);
    *((ebp - 0xc)) = eax;
    caml_enter_blocking_section ();
    eax = ebp - 0x2738;
    *((esp + 0x1c)) = eax;
    eax = ebp - 0x10;
    *((esp + 0x18)) = eax;
    *((esp + 0x14)) = 0x2710;
    eax = ebp - 0x2734;
    *((esp + 0x10)) = eax;
    eax = ebp - 0x24;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = 2;
    *((esp + 4)) = 4;
    eax = ebp - 0xc;
    *(esp) = eax;
    eax = gethostbyaddr_r ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi != 0) {
        *((ebp - 0x10)) = 0;
    } else {
        eax = *((ebp - 0x10));
        if (eax != 0) {
            goto label_0;
        }
    }
    caml_raise_not_found ();
label_0:
    alloc_host_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b333 */
#include <stdint.h>
 
int32_t caml_int64_to_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ac70 */
#include <stdint.h>
 
int32_t camlBuffer_add_substring_1076 (void) {
    int32_t var_4h_3;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 0x10)) = eax;
    *(esp) = ebx;
    *((esp + 4)) = ecx;
    *((esp + 8)) = edx;
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        eax = *((ebx - 4));
        eax >>= 0xa;
        eax = eax*4 - 1;
        ebx = *((ebx + eax));
        eax -= ebx;
        eax <<= 1;
        eax -= edx;
        eax += 2;
        if (ecx <= eax) {
            goto label_1;
        }
    }
label_0:
    eax = "Buffer.add_substring";
    camlPervasives_invalid_arg_1012 ();
label_1:
    eax = *((esp + 0x10));
    ecx = *((eax + 4));
    ebx = *((esp + 8));
    edx = ecx + ebx - 1;
    *((esp + 0xc)) = edx;
    ecx = *((eax + 8));
    if (edx > ecx) {
        camlBuffer_resize_1066 ();
    }
    eax = *((esp + 0x10));
    edx = *((eax + 4));
    ecx = *(eax);
    eax = *(esp);
    ebx = *((esp + 4));
    esi = *((esp + 8));
    camlString_blit_1056 ();
    ebx = *((esp + 0xc));
    eax = *((esp + 0x10));
    *((eax + 4)) = ebx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058840 */
#include <stdint.h>
 
int32_t camlMap_part_1228 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    do {
label_0:
        esi = *((eax + 4));
        edx = *(eax);
        if (ebx == 1) {
            goto label_3;
        }
        eax = *((ebx + 0xc));
        esi = *((ebx + 8));
        eax = *((ebx + 4));
        edx = *(ebx);
        ecx = *((ecx + 0x10));
        ebx = esi;
        eax = caml_apply2 (edx, eax, ecx);
        if (eax != 1) {
            eax = *((esp + 8));
            edx = *((eax + 0xc));
            eax = *((esp + 0xc));
            ebx = *((esp + 0x10));
            ecx = *((esp + 0x14));
            eax = camlMap_add_1108 ();
            ebx = eax;
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *((esp + 0x18));
            *((eax + 4)) = ebx;
        } else {
            eax = *((esp + 8));
            edx = *((eax + 0xc));
            eax = *((esp + 0xc));
            ebx = *((esp + 0x10));
            ecx = *((esp + 0x18));
            eax = camlMap_add_1108 ();
            ecx = eax;
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 0x14));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
        }
        ebx = *(esp);
        ecx = *((esp + 8));
        camlMap_part_1228 ();
    } while (1);
    ebx = *((esp + 4));
    ecx = *((esp + 8));
    goto label_0;
label_3:
    return eax;
label_5:
    caml_call_gc ();
    goto label_1;
label_4:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066fd1 */
#include <stdint.h>
 
int32_t caml_raise_with_string (void) {
    int32_t var_ch_3;
    int32_t var_4h_4;
    int32_t var_4h_3;
    eax = *((ebp + 0xc));
    eax = caml_copy_string (eax);
    eax = *((ebp + 8));
    return caml_raise_with_arg (eax, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055aa0 */
#include <stdint.h>
 
int32_t camlString_concat_1066 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    if (ebx == 1) {
        goto label_1;
    }
    *((esp + 0xc)) = eax;
    eax = *((ebx + 4));
    *((esp + 0x10)) = eax;
    eax = *(ebx);
    *((esp + 8)) = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x24;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x400;
    *(edx) = 1;
    ecx = edx + 8;
    *((ecx - 4)) = 0x400;
    *(ecx) = 1;
    eax = edx + 0x10;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.camlString__fun_1160;
    *((eax + 4)) = 3;
    *((eax + 8)) = edx;
    *((eax + 0xc)) = ecx;
    camlList_iter_1074 (edx, ecx);
    eax = *(esp);
    eax = *(eax);
    eax += 0xfffffffe;
    eax >>= 1;
    ebx = *((esp + 0xc));
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    ebx = *((ebx + ecx));
    ecx -= ebx;
    ecx <<= 1;
    ecx *= eax;
    eax = *((esp + 4));
    eax = *(eax);
    eax += ecx;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    edi = eax;
    esi = *((esp + 8));
    eax = *((esi - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ebx = *((esi + eax));
    eax -= ebx;
    caml_blit_string (edi, 1, edi, 1, eax + eax + 1);
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x400;
            eax = *((esi - 4));
            eax >>= 0xa;
            eax = eax*4 - 1;
            ecx = *((esi + eax));
            eax -= ecx;
            eax = eax + eax + 1;
            *(ebx) = eax;
            eax = ebx + 8;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlString__fun_1163;
            *((eax + 4)) = 3;
            ecx = *((esp + 0xc));
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = edi;
            *((eax + 0x10)) = ebx;
            ebx = *((esp + 0x10));
            camlList_iter_1074 ();
            eax = *(esp);
            return eax;
label_1:
            eax = loc.camlString__29;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804aec0 */
#include <stdint.h>
 
int32_t caml_curry7_5 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_6;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c500 */
#include <stdint.h>
 
int32_t camlUnix_fun_2748 (void) {
    eax = caml_ml_open_descriptor_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050c60 */
#include <stdint.h>
 
int32_t camlArray_tolist_1123 (void) {
    do {
        edx = eax;
        if (edx < 1) {
            eax = ebx;
            return eax;
        }
        esi = *((ecx + 0xc));
        eax = *((esi - 4));
        if (eax != 0xfe) {
            edi = *((esi + edx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            edi = eax + 4;
            *((edi - 4)) = 0x8fd;
            *(fp_stack--) = *((esi + edx*4 - 4));
            *(edi) = fp_stack[0];
            fp_stack--;
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        esi = eax + 4;
        *((esi - 4)) = 0x800;
        *(esi) = edi;
        *((esi + 4)) = ebx;
        eax = edx;
        eax += 0xfffffffe;
        ebx = esi;
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064899 */
#include <stdint.h>
 
uint32_t unix_recvfrom (void * s1, int32_t arg_bp_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_10h, int32_t arg_sp_14h) {
    int32_t var_40b0h;
    int32_t var_40ach;
    int32_t var_40a8h;
    int32_t var_40a4h;
    int32_t var_40a0h;
    int32_t var_4090h;
    int32_t var_408ch;
    int32_t var_401ch;
    int32_t var_4018h;
    void * s2;
    size_t n;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x14062;
    *((ebp - 0x401c)) = 1;
    eax = ebx + 0xb904;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    edi = eax;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x40b0)) = edx;
    edx = ebp - 0x40b0;
    *(eax) = edx;
    *((ebp - 0x40a8)) = 1;
    *((ebp - 0x40ac)) = 2;
    eax = ebp + 0xc;
    *((ebp - 0x40a4)) = eax;
    eax = ebp - 0x401c;
    *((ebp - 0x40a0)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    *((ebp - 0x4090)) = 0x70;
    caml_enter_blocking_section ();
    eax = ebp - 0x4090;
    *((esp + 0x14)) = eax;
    eax = ebp - 0x408c;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = edi;
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    eax = ebp - 0x4018;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = recvfrom (eax, eax, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x2481;
        uerror (eax, 0);
    }
    eax = ebp - 0x4018;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    memmove (eax, eax, esi);
    eax = *((ebp - 0x4090));
    eax = ebp - 0x408c;
    eax = alloc_sockaddr (eax, eax, 0xffffffff);
    *((ebp - 0x401c)) = eax;
    caml_alloc_small (2, 0);
    edx = esi + esi + 1;
    *(eax) = edx;
    edx = *((ebp - 0x401c));
    *((eax + 4)) = edx;
    ecx = *((ebp - 0x40b0));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a824 */
#include <stdint.h>
 
void recvfrom (void) {
    recvfrom ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056c00 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_bucket_1116 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_2;
        }
        *((esp + 8)) = ebx;
        ecx = *((eax + 8));
        *((esp + 0xc)) = ecx;
        ecx = *((eax + 4));
        *(esp) = ecx;
        eax = *(eax);
        *((esp + 4)) = eax;
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
label_1:
            eax = caml_young_ptr;
            eax -= 0x10;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *((esp + 4));
            *(eax) = ebx;
            ebx = *((esp + 8));
            ebx = *((ebx + 0xc));
            *((eax + 4)) = ebx;
            ebx = *((esp + 0xc));
            *((eax + 8)) = ebx;
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_replace_bucket_1116 ();
    } while (1);
    ecx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_4;
    }
    eax = eax + 4;
    *((eax - 4)) = 0xc00;
    ebx = *((esp + 4));
    *(eax) = ebx;
    ebx = *(esp);
    *((eax + 4)) = ebx;
    *((eax + 8)) = ecx;
    return eax;
    do {
label_2:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80639b4 */
#include <stdint.h>
 
int32_t unix_kill (pid_t pid, int32_t arg_ch) {
    int32_t sig;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14f4c;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = caml_convert_signal_number (eax);
    eax = *((ebp + 8));
    eax >>= 1;
    eax = kill (eax, eax);
    if (eax == -1) {
        eax = ebx - 0x2510;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a7e4 */
#include <stdint.h>
 
void kill (void) {
    kill ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ee30 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1790 (void) {
    ecx = ebx;
    ebx = *((ecx + 8));
    ecx = *((ecx + 0xc));
    eax = *((eax + ecx*2 - 2));
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80684d0 */
#include <stdint.h>
 
int32_t caml_fl_reset (void) {
    *(0x8084668) = 0;
    eax = caml_allocation_policy;
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
    } else {
        *(obj.fl_prev) = "hF\b\b";
        goto label_0;
    }
    eax = 0x8084668;
    truncate_flp ();
label_0:
    *(obj.caml_fl_cur_size) = 0;
    caml_fl_init_merge ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e6a2 */
#include <stdint.h>
 
uint32_t caml_ml_output_int (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    caml_putword (ebx, eax);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c650 */
#include <stdint.h>
 
int32_t camlUnix_handle_unix_error_1171 (void) {
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = ebx;
    eax = void (*0x804c760)() ();
    ecx = camlUnix;
    ebx = *(eax);
    if (ebx == ecx) {
        ebx = *((eax + 0xc));
        *((esp + 8)) = ebx;
        ebx = *((eax + 8));
        *(esp) = ebx;
        eax = *((eax + 4));
        *((esp + 4)) = eax;
        ebx = *(loc.camlSys);
        eax = *((ebx - 4));
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        ebx = *(ebx);
        eax = .comment;
        camlPervasives_output_string_1191 ();
        ebx = loc.camlUnix__214;
        eax = .comment;
        camlPervasives_output_string_1191 ();
        eax = .comment;
        ebx = *(esp);
        camlPervasives_output_string_1191 ();
        ebx = "\" failed";
        eax = .comment;
        camlPervasives_output_string_1191 ();
        eax = *((esp + 8));
        ebx = *((eax - 4));
        ebx >>= 0xa;
        ebx = ebx*4 - 1;
        ecx = *((eax + ebx));
        ebx -= ecx;
        ebx = ebx + ebx + 1;
        if (ebx > 1) {
            ebx = " on \";
            eax = .comment;
            camlPervasives_output_string_1191 (eax);
            eax = .comment;
            ebx = *((esp + 8));
            camlPervasives_output_string_1191 ();
            ebx = loc.camlUnix__211;
            eax = .comment;
            camlPervasives_output_string_1191 ();
        }
        ebx = loc.camlUnix__210;
        eax = .comment;
        camlPervasives_output_string_1191 ();
        eax = *((esp + 4));
        eax = unix_error_message;
        caml_c_call (eax);
        camlPervasives_prerr_endline_1285 ();
        eax = 5;
        void (*0x8050380)() ();
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ecx = *(edx);
    ebx = edx;
    void (*ecx)(uint32_t*) (*(obj.caml_exception_pointer));
    return eax;
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070dfa */
#include <stdint.h>
 
uint32_t caml_sys_random_seed (void) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    *((esp + 4)) = 0;
    eax = ebp - 0x20;
    *(esp) = eax;
    gettimeofday ();
    esi = *((ebp - 0x20));
    ebx = *((ebp - 0x1c));
    eax = getppid ();
    edi = eax;
    eax = getpid ();
    ebx ^= esi;
    ebx ^= eax;
    edx = edi;
    edx <<= 0x10;
    edi = ebx;
    edi ^= edx;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d5d0 */
#include <stdint.h>
 
uint32_t camlPrintf_add_int_index_1040 (void) {
    eax = eax + ebx - 1;
    return camlPrintf_index_of_int_1037 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80682dc */
#include <stdint.h>
 
int32_t caml_fatal_error_arg (int32_t arg_8h, int32_t arg_ch) {
    char ** format;
    int32_t var_8h;
    eax = *((ebp + 0xc));
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax = stderr;
    fprintf (eax, eax);
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ba8e */
#include <stdint.h>
 
int32_t caml_nativeint_shift_left (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax <<= cl;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c970 */
#include <stdint.h>
 
uint32_t camlUnix_is_inet6_addr_1500 (void) {
    ecx = eax;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    al = (eax == 0x21) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065c85 */
#include <stdint.h>
 
int32_t unix_tcflush (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12c7b;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x22dc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcflush ();
    if (eax == -1) {
        eax = ebx - 0x2337;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a294 */
#include <stdint.h>
 
void tcflush (void) {
    tcflush ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050150 */
#include <stdint.h>
 
uint32_t camlPervasives_prerr_float_1283 (void) {
    eax = camlPervasives_string_of_float_1140 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cca0 */
#include <stdint.h>
 
int32_t camlUnix_getaddrinfo_emulation_1730 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_4h;
    int32_t var_8h;
    *((esp + 0xc)) = eax;
    *(esp) = ebx;
    ebx = ecx;
    *((esp + 0x10)) = ebx;
label_6:
    eax = caml_young_ptr;
    eax -= 0x30;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_7;
    }
    edi = eax + 4;
    *((edi - 4)) = 0x400;
    *(edi) = 1;
    esi = edi + 8;
    *((esi - 4)) = 0x400;
    *(esi) = 1;
    edx = edi + 0x10;
    *((edx - 4)) = 0x400;
    *(edx) = 1;
    eax = edi + 0x18;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.camlUnix__fun_2828;
    *((eax + 4)) = 3;
    *((eax + 8)) = edi;
    *((eax + 0xc)) = esi;
    *((eax + 0x10)) = edx;
    camlList_iter_1074 (edi, esi);
label_5:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_8;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x10f7;
    *(ecx) = sym.caml_curry2;
    *((ecx + 4)) = 5;
    *((ecx + 8)) = 0x804bc20;
    edx = *(esp);
    *((ecx + 0xc)) = edx;
    eax = *((esp + 4));
    eax = *(eax);
    if (eax != 1) {
        ebx = *(eax);
        if (ebx != 3) {
            if (ebx != 1) {
                eax = caml_string_equal (edx, loc.camlUnix__202);
                if (eax != 1) {
label_4:
                    eax = caml_young_ptr;
                    eax -= 0x18;
                    *(obj.caml_young_ptr) = eax;
                    if (eax < *(obj.caml_young_limit)) {
                        goto label_9;
                    }
                    ecx = eax + 4;
                    *((ecx - 4)) = 0x800;
                    *(ecx) = ebx;
                    *((ecx + 4)) = 1;
                    eax = ecx + 0xc;
                    *(esp) = eax;
                    *((eax - 4)) = 0x800;
                    *(eax) = ecx;
                    *((eax + 4)) = 1;
                    eax = 1;
                    *(esp) = eax;
                    ebx = loc.camlUnix__201;
                    eax = 1;
                    eax = camlUnix_get_port_1739 ();
                    *(esp) = eax;
                    ebx = loc.camlUnix__200;
                    eax = 3;
                    eax = camlUnix_get_port_1739 ();
                    *(esp) = eax;
                } else {
                } else {
                } else {
                } else {
                    ebx = loc.camlUnix__199;
                    eax = 3;
                    eax = camlUnix_get_port_1739 (ecx);
                    ebx = loc.camlUnix__198;
                    eax = 1;
                    ecx = *(esp);
                    camlUnix_get_port_1739 (eax);
                    ebx = *((esp + 4));
                    eax = camlPervasives_$40_1143 ();
                }
            }
        }
    }
    ebx = *((esp + 0x10));
    eax = caml_string_equal (eax, loc.camlUnix__197);
    if (eax != 1) {
        eax = 5;
        ebx = *((esp + 0x10));
        eax = camlList_mem_1161 ();
        if (eax != 1) {
label_3:
            eax = caml_young_ptr;
            eax -= 0x18;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = .comment;
            *(ebx) = eax;
            *((ebx + 4)) = "0.0.0.0";
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            *(ecx) = ebx;
            *((ecx + 4)) = 1;
label_2:
            eax = caml_young_ptr;
            eax -= 0x18;
            *(obj.caml_young_ptr) = eax;
        } else {
        } else {
        }
    }
    if (eax < *(obj.caml_young_limit)) {
        goto label_11;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x800;
    eax = .comment;
    *(ebx) = eax;
    *((ebx + 4)) = "127.0.0.1";
    ecx = ebx + 0xc;
    *((ecx - 4)) = 0x800;
    *(ecx) = ebx;
    *((ecx + 4)) = 1;
    eax = void (*0x804d010)(uint32_t) (ebx);
    ecx = caml_exn_Failure;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = void (*0x804cf80)() ();
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            ecx = 1;
        } else {
            caml_raise_exn ();
        }
        *(obj.caml_exception_pointer) = esp;
        eax = *((esp + 0x14));
        eax = unix_gethostbyname;
        eax = caml_c_call (eax);
        eax = *((eax + 0xc));
        eax = camlArray_to_list_1121 (eax);
        ebx = eax;
label_1:
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_12;
        }
        eax = eax + 4;
        *((eax - 4)) = 0xcf7;
        *(eax) = sym.camlUnix__fun_2833;
        *((eax + 4)) = 3;
        ecx = *((esp + 0xc));
        *((eax + 8)) = ecx;
        eax = camlList_map_1062 ();
        ecx = eax;
    } else {
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = unix_inet_addr_of_string;
        eax = caml_c_call (ebx);
        ecx = eax;
label_0:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_13;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        *(ebx) = ecx;
        eax = *((esp + 0x14));
        *((ebx + 4)) = eax;
        ecx = ebx + 0xc;
        *((ecx - 4)) = 0x800;
        *(ecx) = ebx;
        *((ecx + 4)) = 1;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.caml_tuplify2;
            *((eax + 4)) = 0xfffffffd;
            *((eax + 8)) = 0x804be30;
            ebx = *((esp + 8));
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            ebx = *(esp);
            camlList_map_1062 ();
            void (*0x8054670)() ();
        }
        caml_call_gc ();
    } while (1);
label_13:
    caml_call_gc ();
    goto label_0;
label_12:
    caml_call_gc ();
    goto label_1;
label_11:
    caml_call_gc ();
    goto label_2;
label_10:
    caml_call_gc ();
    goto label_3;
label_9:
    caml_call_gc ();
    goto label_4;
label_8:
    caml_call_gc ();
    goto label_5;
label_7:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806dc53 */
#include <stdint.h>
 
int32_t caml_ml_channel_size (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_channel_size (ebx);
    ebx = eax;
    if (edx >= 0) {
        if (edx <= 0) {
            if (eax <= 0x3fffffff) {
                goto label_0;
            }
        }
        errno_location ();
        *(eax) = 0x4b;
        caml_sys_error (1);
    }
label_0:
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c4cc */
#include <stdint.h>
 
int32_t caml_classify_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = fpclassify ();
    edx = eax;
    eax = 1;
    if (edx <= 3) {
        eax = *((edx*4 + obj.CSWTCH.118));
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a1e4 */
#include <stdint.h>
 
void fpclassify (void) {
    fpclassify ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80609b0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_app_var_const_1414 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlCamlinternalOO__fun_1814;
            *((eax + 4)) = 3;
            *((eax + 8)) = edx;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ee40 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1794 (void) {
    ecx = ebx;
    ebx = *((ecx + 8));
    edx = *((ecx + 0x10));
    ecx = *((ecx + 0xc));
    eax = *((eax + ecx*2 - 2));
    eax = *((eax + edx*2 - 2));
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c260 */
#include <stdint.h>
 
int32_t camlUnix_fun_2672 (void) {
    eax = unix_select;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f8a0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1422 (void) {
    eax = caml_ml_output_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d989 */
#include <stdint.h>
 
int32_t caml_close_channel (int32_t fildes) {
    ebx = *((ebp + 8));
    eax = *(ebx);
    close (eax);
    if (*((ebx + 0x2c)) <= 0) {
        eax = caml_channel_mutex_free;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        eax = ebx;
        unlink_channel ();
        caml_stat_free (ebx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c290 */
#include <stdint.h>
 
int32_t camlUnix_fun_2676 (void) {
    eax = unix_symlink;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c73f */
#include <stdint.h>
 
int32_t caml_asin_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    asin (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049ed4 */
#include <stdint.h>
 
void asin (void) {
    asin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804beb0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2564 (void) {
    eax = unix_tcflow;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bed0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2568 (void) {
    eax = unix_tcdrain;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805af40 */
#include <stdint.h>
 
int32_t camlBuffer_find_ident_1114 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    if (ebx >= ecx) {
label_1:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x400;
        *(eax) = loc.caml_exn_Not_found;
        eax = caml_raise_exn ();
    }
    *((esp + 8)) = ebx;
    *((esp + 0xc)) = eax;
    ecx = ebx;
    ecx >>= 1;
    edx = *((eax - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    esi = *((eax + edx));
    edx -= esi;
    if (edx <= ecx) {
        goto label_3;
    }
    ecx = *((eax + ecx));
    ecx = ecx + ecx + 1;
    if (ecx != 0x51) {
        if (ecx != 0xf7) {
            ebx += 2;
            eax = camlBuffer_advance_to_non_alpha_1108 ();
            ebx = *((esp + 8));
            eax -= ebx;
            ecx = eax;
            ecx++;
            eax = *((esp + 0xc));
            eax = camlString_sub_1046 (eax);
            ecx = eax;
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            eax = *(esp);
            *((ebx + 4)) = eax;
            eax = ebx;
            return eax;
        }
        *(esp) = ecx;
    } else {
    }
    ebx += 2;
    eax = ecx;
    eax = camlBuffer_closing_1097 (ecx, ebx);
    ebx = eax;
    ecx = 1;
    eax = *(esp);
    edx = *((esp + 0xc));
    esi = *((esp + 4));
    eax = camlBuffer_advance_to_closing_1098 ();
    ebx = *((esp + 8));
    eax -= ebx;
    eax -= 3;
    ecx = eax;
    ecx += 2;
    eax = *((esp + 0xc));
    ebx = *((esp + 4));
    eax = camlString_sub_1046 (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *(esp);
            ebx += 2;
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80736e6 */
#include <stdint.h>
 
int32_t caml_static_resize (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    caml_stat_resize (eax, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b6c0 */
#include <stdint.h>
 
int32_t camlSource_fun_1143 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    eax = ebx;
    ebx = *((esi + 0x14));
    eax = camlCamlinternalOO_create_object_opt_1308 (eax, esi);
    ebx = *((esp + 4));
    ecx = *((ebx + 0x18));
    ebx = *(esp);
    caml_apply2 (eax);
    ecx = *((esp + 4));
    edx = *((ecx + 0xc));
    ebx = *((esp + 8));
    eax = *((esp + 0xc));
    *((ebx + edx*2 - 2)) = eax;
    eax = *((ecx + 0x10));
    *((ebx + eax*2 - 2)) = 1;
    ecx = *((ecx + 0x14));
    eax = *((esp + 0x10));
    return camlCamlinternalOO_run_initializers_opt_1320 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d01a */
#include <stdint.h>
 
uint32_t caml_make_array (int32_t arg_8h) {
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x40)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x60)) = eax;
    eax = ebp - 0x60;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x58)) = 1;
    *((ebp - 0x5c)) = 2;
    eax = ebp - 0x3c;
    *((ebp - 0x54)) = eax;
    eax = ebp - 0x40;
    *((ebp - 0x50)) = eax;
    eax = *((ebp + 8));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi == 0) {
        *(obj.caml_local_roots) = ebx;
        goto label_0;
    }
    edx = *(eax);
    if ((dl & 1) == 0) {
        *((ebp - 0x3c)) = edx;
        edi = edx;
        edi >>= 0x17;
        ecx = edx;
        ecx >>= 0xc;
        ecx &= 0x7ff;
        edi = *((edi*4 + obj.caml_page_table));
        if ((*((edi + ecx)) & 7) == 0) {
            goto label_1;
        }
        if (*((edx - 4)) == 0xfd) {
            goto label_2;
        }
    }
label_1:
    *(obj.caml_local_roots) = ebx;
    goto label_0;
label_2:
    eax = esi + esi;
    eax = caml_alloc_small (eax, 0xfe);
    *((ebp - 0x40)) = eax;
    eax = 0;
    do {
        edx = *((ebp + 8));
        edx = *((edx + eax*4));
        *(fp_stack--) = *(edx);
        edx = *((ebp - 0x40));
        *((edx + eax*8)) = fp_stack[0];
        fp_stack--;
        eax++;
    } while (esi > eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x40));
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c520 */
#include <stdint.h>
 
int32_t camlUnix_fun_2752 (void) {
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060a80 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_app_env_const_1430 (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x18f7;
            *(eax) = sym.camlCamlinternalOO__fun_1826;
            *((eax + 4)) = 3;
            *((eax + 8)) = esi;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            *((eax + 0x14)) = edx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e9fe */
#include <stdint.h>
 
int32_t caml_ml_open_descriptor_out (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    eax = caml_open_descriptor_out (eax);
    caml_alloc_channel (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e9e4 */
#include <stdint.h>
 
int32_t caml_open_descriptor_out (int32_t arg_8h) {
    eax = *((ebp + 8));
    caml_open_descriptor_in (eax);
    *((eax + 0x14)) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e3f0 */
#include <stdint.h>
 
int32_t camlPrintf_kfprintf_1386 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlPrintf__fun_1680;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            ebp = .comment;
            esi = .comment;
            edx = .comment;
            ecx = .comment;
            eax = 1;
            *(loc.caml_extra_params) = ebp;
            void (*0x804b470)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c090 */
#include <stdint.h>
 
int32_t camlUnix_fun_2618 (void) {
    eax = unix_getpwnam;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806325c */
#include <stdint.h>
 
int32_t unix_getpwuid (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x156a4;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getpwuid ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_passwd_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a3f4 */
#include <stdint.h>
 
void getpwuid (void) {
    getpwuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80644c4 */
#include <stdint.h>
 
int32_t unix_select (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_1c0h;
    int32_t var_1bch;
    int32_t var_1bah;
    int32_t var_1b4h;
    int32_t var_1b0h;
    int32_t var_1ach;
    int32_t var_1a8h;
    int32_t var_1a4h;
    int32_t var_1a0h;
    int32_t var_194h;
    int32_t nfds;
    int32_t var_188h;
    int32_t var_108h;
    int32_t var_88h;
    fd_set * readfds;
    fd_set * writefds;
    fd_set * exceptfds;
    struct timeval * timeout;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x14438;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x1b4)) = edx;
    edx = ebp - 0x1b4;
    *(eax) = edx;
    *((ebp - 0x1ac)) = 1;
    *((ebp - 0x1b0)) = 3;
    eax = ebp + 8;
    *((ebp - 0x1a8)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x1a4)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x1a0)) = eax;
    *((ebp - 0x18c)) = 0xffffffff;
    edx = ebp - 0x88;
    esi = ebp - 0x18c;
    eax = *((ebp + 8));
    fdlist_to_fdset (esi);
    edx = ebp - 0x108;
    eax = *((ebp + 0xc));
    fdlist_to_fdset (esi);
    edx = ebp - 0x188;
    eax = *((ebp + 0x10));
    fdlist_to_fdset (esi);
    eax = *((ebp + 0x14));
    *(fp_stack--) = *(eax);
    esi = 0;
    *(fp_stack--) = 0.0;
    fp_stack--;
    if (fp_stack[0] <= fp_stack[1]) {
        eax = *((ebp - 0x1ba));
        ah = 0xc;
        *((ebp - 0x1bc)) = ax;
        *((ebp - 0x1c0)) = fp_stack[0];
        eax = *((ebp - 0x1c0));
        *((ebp - 0x194)) = eax;
        *((ebp - 0x1c0)) = eax;
        *(fp_stack--) = *((ebp - 0x1c0));
        fp_stack[0] -= fp_stack[1];
        fp_stack++;
        fp_stack[0] *= *((ebx - 0x2564));
        *((ebp - 0x190)) = fp_stack[0];
        fp_stack--;
        esi = ebp - 0x194;
    } else {
        fp_stack++;
    }
    caml_enter_blocking_section ();
    eax = ebp - 0x188;
    eax = ebp - 0x108;
    eax = ebp - 0x88;
    eax = *((ebp - 0x18c));
    eax++;
    eax = select (esi, eax, eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x2494;
        uerror (eax, 0);
    }
    edx = ebp - 0x88;
    eax = *((ebp + 8));
    eax = fdset_to_fdlist ();
    *((ebp + 8)) = eax;
    edx = ebp - 0x108;
    eax = *((ebp + 0xc));
    eax = fdset_to_fdlist ();
    *((ebp + 0xc)) = eax;
    edx = ebp - 0x188;
    eax = *((ebp + 0x10));
    eax = fdset_to_fdlist ();
    *((ebp + 0x10)) = eax;
    caml_alloc_small (3, 0);
    edx = *((ebp + 8));
    *(eax) = edx;
    edx = *((ebp + 0xc));
    *((eax + 4)) = edx;
    edx = *((ebp + 0x10));
    *((eax + 8)) = edx;
    ecx = *((ebp - 0x1b4));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b470 */
#include <stdint.h>
 
int32_t caml_apply6 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    *((esp + 4)) = eax;
    *((esp + 8)) = ebx;
    *((esp + 0xc)) = ecx;
    *((esp + 0x10)) = edx;
    *((esp + 0x14)) = esi;
    *((esp + 0x18)) = edi;
    ebx = caml_extra_params;
    eax = *((ebx + 4));
    if (eax == 0xd) {
        *(esp) = ebx;
        eax = *((ebx + 8));
        *((esp + 0x1c)) = eax;
        eax = *((esp + 4));
        ebx = *((esp + 8));
        ecx = *((esp + 0xc));
        edx = *((esp + 0x10));
        esi = *((esp + 0x14));
        edi = *((esp + 0x18));
        ebp = *(esp);
        *(loc.caml_extra_params) = ebp;
        ebp = *((esp + 0x1c));
        void (*ebp)() ();
    }
    eax = *(ebx);
    eax = *((esp + 4));
    ecx = *(esp);
    eax = void (*ecx)(uint32_t) (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 8));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0xc));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0x10));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0x14));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0x18));
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c550 */
#include <stdint.h>
 
int32_t camlUnix_fun_2756 (void) {
    eax = unix_nice;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d6f7 */
#include <stdint.h>
 
int32_t caml_ml_set_binary_mode (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c830 */
#include <stdint.h>
 
int32_t caml_sqrt_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(fp_stack--) = fp_stack[0];
    fp_stack[0] = sqrt(fp_stack[0]);
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_0;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(esp) = fp_stack[0];
    fp_stack--;
    sqrt ();
    goto label_1;
label_0:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_1:
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804adc0 */
#include <stdint.h>
 
int32_t caml_curry7_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060510 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_build_path_1346 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    *(esp) = ecx;
label_1:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    eax = eax + 4;
    *((esp + 4)) = eax;
    *((eax - 4)) = 0xc00;
    *(eax) = 1;
    *((eax + 4)) = 1;
    *((eax + 8)) = 1;
    edi = eax + 0x10;
    *((edi - 4)) = 0x400;
    *(edi) = eax;
    esi = 1;
    if (esi > ebp) {
        goto label_3;
    }
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0xc00;
        ecx = *((ebx - 4));
        ecx >>= 9;
        if (ecx <= esi) {
            goto label_5;
        }
        ecx = *((ebx + esi*2 - 2));
        *(eax) = ecx;
        ecx = *(edi);
        *((eax + 4)) = ecx;
        *((eax + 8)) = 1;
        caml_modify (edi, eax);
        eax = esi;
        esi += 2;
    } while (eax != ebp);
label_3:
    eax = *((esp + 4));
    eax += 4;
    caml_modify (eax, *(edi));
    eax = *((esp + 4));
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
label_5:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060320 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_dummy_class_1302 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlCamlinternalOO__undef_1304;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            eax = ebx + 0x10;
            *((eax - 4)) = 0x1000;
            *(eax) = ebx;
            *((eax + 4)) = ebx;
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062910 */
#include <stdint.h>
 
uint32_t unix_getgid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15ff0;
    getgid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a8d4 */
#include <stdint.h>
 
void getgid (void) {
    getgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071aaf */
#include <stdint.h>
 
int32_t caml_init_gc (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    char * var_4h;
    int32_t var_8h;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    norm_heapincr (ebx, esi);
    ebx = eax*4;
    eax = ebx + esi*4;
    eax = caml_page_table_initialize (eax);
    if (eax != 0) {
        caml_fatal_error (0x807723c);
    }
    eax = esi;
    eax = norm_minsize ();
    eax <<= 2;
    caml_set_minor_heap_size (eax);
    eax = *((ebp + 0x10));
    eax = norm_heapincr ();
    eax <<= 2;
    *(obj.caml_major_heap_increment) = eax;
    eax = *((ebp + 0x14));
    eax = norm_pfree ();
    *(obj.caml_percent_free) = eax;
    eax = *((ebp + 0x18));
    eax = norm_pmax ();
    *(obj.caml_percent_max) = eax;
    caml_init_major_heap (ebx);
    eax = caml_minor_heap_size;
    eax >>= 0xa;
    caml_gc_message (0x20, "Initial minor heap size: %luk bytes\n", eax);
    ebx >>= 0xa;
    caml_gc_message (0x20, "Initial major heap size: %luk bytes\n", ebx);
    eax = caml_percent_free;
    caml_gc_message (0x20, "Initial space overhead: %lu%%\n", eax);
    eax = caml_percent_max;
    caml_gc_message (0x20, "Initial max overhead: %lu%%\n", eax);
    eax = caml_major_heap_increment;
    eax >>= 0xa;
    caml_gc_message (0x20, "Initial heap increment: %luk bytes\n", eax);
    eax = caml_allocation_policy;
    caml_gc_message (0x20, "Initial allocation policy: %d\n", eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069c32 */
#include <stdint.h>
 
int32_t caml_set_minor_heap_size (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    eax = caml_young_ptr;
    if (eax != *(obj.caml_young_end)) {
        caml_minor_collection ();
    }
    eax = ebp - 0x1c;
    eax = caml_aligned_malloc (edi, 0, eax);
    ebx = eax;
    if (eax == 0) {
        eax = caml_raise_out_of_memory ();
    }
    esi = eax + edi;
    eax = caml_page_table_add (2, eax, esi);
    if (eax != 0) {
        caml_raise_out_of_memory ();
    }
    eax = caml_young_start;
    if (eax != 0) {
        edx = caml_young_end;
        caml_page_table_remove (2, eax, edx);
        eax = caml_young_base;
        free (eax);
    }
    eax = *((ebp - 0x1c));
    *(obj.caml_young_base) = eax;
    *(obj.caml_young_start) = ebx;
    *(obj.caml_young_end) = esi;
    *(obj.caml_young_limit) = ebx;
    *(obj.caml_young_ptr) = esi;
    *(obj.caml_minor_heap_size) = edi;
    eax = caml_ref_table;
    reset_table ();
    eax = caml_weak_ref_table;
    reset_table ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8068c5c */
#include <stdint.h>
 
int32_t caml_init_major_heap (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 8));
    eax = clip_heap_chunk_size ();
    *(obj.caml_stat_heap_size) = eax;
    *(obj.caml_stat_top_heap_size) = eax;
    eax = caml_alloc_for_heap (eax);
    *(obj.caml_heap_start) = eax;
    if (eax == 0) {
        caml_fatal_error ("Fatal error: not enough memory for the initial heap.\n");
    }
    *((eax - 4)) = 0;
    *(obj.caml_stat_heap_chunks) = 1;
    eax = caml_heap_start;
    edx = caml_heap_start;
    edx += *(obj.caml_stat_heap_size);
    eax = caml_page_table_add (1, eax, edx);
    if (eax != 0) {
        caml_fatal_error ("Fatal error: not enough memory for the initial page table.\n");
    }
    caml_fl_init_merge ();
    eax = caml_stat_heap_size;
    eax >>= 2;
    eax = caml_heap_start;
    caml_make_free_blocks (eax, eax, 1);
    *(obj.caml_gc_phase) = 2;
    *(obj.gray_vals_size) = 0x800;
    eax = malloc (0x2000);
    *(obj.gray_vals) = eax;
    if (eax == 0) {
        eax = caml_fatal_error ("Fatal error: not enough memory for the gray cache.\n");
    }
    *(obj.gray_vals_cur) = eax;
    edx = gray_vals_size;
    eax = eax + edx*4;
    *(obj.gray_vals_end) = eax;
    *(obj.heap_is_pure) = 1;
    *(obj.caml_allocated_words) = 0;
    *(fp_stack--) = 0.0;
    *(obj.caml_extra_heap_resources) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80575a0 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_1227 (void) {
    int32_t var_4h;
    int32_t var_4h_2;
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlHashtbl__mem_in_bucket_1230;
            *((eax + 4)) = 3;
            esi = *((ecx + 0xc));
            *((eax + 8)) = esi;
            *((eax + 0xc)) = ebx;
            esi = *((edx + 4));
            esi = *((esi - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = *((ecx + 0x10));
                eax = *((eax + 8));
                edx = *((eax + 4));
                ecx = *(edx);
                eax = ebx;
                ebx = edx;
                eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, esi);
                ebx = 0x7fffffff;
                eax &= ebx;
                eax >>= 1;
                ecx = *((esp + 8));
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            eax = *(esp);
            ebx = *((eax + 4));
            eax = *((ebx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ebx + edx*2 - 2));
            ebx = *((esp + 4));
            void (*0x8056980)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80595e0 */
#include <stdint.h>
 
int32_t camlMap_for_all_1204 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
label_0:
        ecx = eax;
        if (ebx == 1) {
            goto label_1;
        }
        eax = *((ebx + 0xc));
        esi = *((ebx + 8));
        eax = *((ebx + 4));
        edx = *(ebx);
        ebx = esi;
        eax = caml_apply2 (edx, ecx, eax);
        if (eax == 1) {
            goto label_2;
        }
        eax = *((esp + 4));
        ebx = *(esp);
        eax = camlMap_for_all_1204 ();
    } while (1);
    if (eax != 1) {
        eax = *((esp + 4));
        ebx = *((esp + 8));
        goto label_0;
    }
    eax = 1;
    return eax;
label_2:
    eax = 1;
    return eax;
label_1:
    eax = 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80751ae */
#include <stdint.h>
 
void caml_init_custom_operations (void) {
    caml_register_custom_operations (obj.caml_int32_ops);
    caml_register_custom_operations (obj.caml_nativeint_ops);
    caml_register_custom_operations (obj.caml_int64_ops);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058ea0 */
#include <stdint.h>
 
int32_t camlMap_is_empty_1107 (void) {
    if (eax != 1) {
        eax = 1;
        return eax;
    }
    eax = 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052c60 */
#include <stdint.h>
 
int32_t camlArray_of_list_1130 (void) {
    int32_t var_4h;
    ebx = eax;
    if (ebx == 1) {
        goto label_0;
    }
    eax = *((ebx + 4));
    eax = *(ebx);
    eax = 1;
    eax = camlArray_list_length_1126 (eax, eax);
    ebx = *(esp);
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8050cf0;
            *((ecx + 0xc)) = ebx;
            eax = 3;
            ebx = *((esp + 4));
            void (*0x8050cf0)() ();
label_0:
            eax = loc.camlArray__22;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e5a0 */
#include <stdint.h>
 
int32_t camlPrintf_get_cont_1408 (void) {
    int32_t var_4h;
    eax = ebx;
    ecx = *((eax + 4));
    ebx = 1;
    eax = *(eax);
    camlString_sub_1046 (eax, eax);
    ebx = *(esp);
    *((ebx + 4)) = 1;
    ebx = *((esp + 4));
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060830 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_app_var_1386 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlCamlinternalOO__fun_1790;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b340 */
#include <stdint.h>
 
int32_t caml_curry3_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry3_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c51a */
#include <stdint.h>
 
uint32_t caml_format_float (void) {
    char * * format;
    int32_t base;
    int32_t var_4h_5;
    int32_t var_8h_5;
    edi = *((ebp + 8));
    ebx = *((ebp + 8));
    eax = *(edi);
    if (al == 0) {
        goto label_0;
    }
    eax -= 0x30;
    if (al > 9) {
        goto label_1;
    }
    while (al != 0) {
        eax -= 0x30;
        if (al <= 9) {
            strtol (ebx, 0, 0xa);
            esi = eax + 0x15e;
            eax = 0x15e;
            if (esi < 0x15e) {
                esi = eax;
            }
            eax = *(ebx);
            if (al == 0) {
                goto label_2;
            }
            if (al != 0x2e) {
                goto label_3;
            }
            goto label_4;
        }
label_1:
        ebx++;
        eax = *(ebx);
    }
    goto label_0;
    do {
        if (al == 0x2e) {
label_4:
            ebx++;
            eax = strtol (ebx, 0, 0xa);
            eax += 0x15e;
            if (esi < eax) {
                esi = eax;
            }
        } else {
label_3:
            ebx++;
            eax = *(ebx);
        }
    } while (al != 0);
label_2:
    if (esi <= 0x171) {
        goto label_0;
    }
    eax = caml_stat_alloc (esi);
    esi = eax;
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    sprintf (esi, edi);
    eax = caml_copy_string (esi);
    ebx = eax;
    eax = ebp - 0x18a;
    if (esi == eax) {
        goto label_5;
    }
    caml_stat_free (esi);
    do {
label_5:
        eax = ebx;
        return eax;
label_0:
        eax = *((ebp + 0xc));
        *(fp_stack--) = *(eax);
        *((esp + 8)) = fp_stack[0];
        fp_stack--;
        ebx = ebp - 0x18a;
        sprintf (ebx, edi);
        eax = caml_copy_string (ebx);
        ebx = eax;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ef50 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1826 (void) {
    edx = ebx;
    ecx = *((edx + 8));
    ebx = *((edx + 0x14));
    esi = *((edx + 0x10));
    edx = *((edx + 0xc));
    eax = *((eax + edx*2 - 2));
    eax = *((eax + esi*2 - 2));
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b330 */
#include <stdint.h>
 
int32_t camlPrintf_sub_1128 (void) {
    do {
        ecx = *((ebx + 0x20));
        if (eax >= ecx) {
            edx = *((ebx + 0x14));
            eax = *((ebx + 0x1c));
            ecx = *(edx);
            ebx = edx;
            eax = void (*ecx)() ();
        }
        edx = *((ebx + 0x1c));
        ecx = eax;
        ecx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ecx) {
            goto label_0;
        }
        ecx = *((edx + ecx));
        ecx = ecx + ecx + 1;
        if (ecx == 0x4b) {
            goto label_1;
        }
        eax += 2;
    } while (1);
label_1:
    ebx += 0xc;
    eax += 2;
    void (*0x805b250)() ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806db11 */
#include <stdint.h>
 
uint32_t caml_ml_seek_in (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    edx = eax;
    edx >>= 0x1f;
    caml_seek_in (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055580 */
#include <stdint.h>
 
int32_t camlChar_escaped_1038 (void) {
    if (eax != 0x4f) {
        if (eax != 0xb9) {
            *(esp) = eax;
            if (eax >= 0x1d) {
                goto label_0;
            }
            ebx = eax;
            ebx >>= 1;
            /* switch table (16 cases) at 0x807e8dc */
            eax = loc.camlChar__8;
            return eax;
            eax = loc.camlChar__9;
            return eax;
            eax = loc.camlChar__10;
            return eax;
            eax = loc.camlChar__11;
            return eax;
        }
        eax = loc.camlChar__7;
        return eax;
    }
    eax = loc.camlChar__6;
    return eax;
label_0:
    eax = caml_is_printable;
    eax = caml_c_call (eax);
    if (eax != 1) {
        eax = caml_create_string;
        caml_c_call (3);
        edx = *(esp);
        edx >>= 1;
        *(eax) = dl;
        return eax;
    }
    eax = *(esp);
    *(esp) = eax;
    eax = caml_create_string;
    eax = caml_c_call (9);
    ebx = eax;
    edx = 0x5c;
    *(ebx) = dl;
    ecx = 0x64;
    edi = *(esp);
    eax = *(esp);
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    edx = eax + eax + 0x61;
    edx >>= 1;
    *((ebx + 1)) = dl;
    esi = 0xa;
    ecx = 0xa;
    eax = edi;
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    ecx = esi;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    edx = edx + edx + 0x61;
    edx >>= 1;
    *((ebx + 2)) = dl;
    ecx = 0xa;
    eax = edi;
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    edx = edx + edx + 0x61;
    edx >>= 1;
    *((ebx + 3)) = dl;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80604e0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_create_object_and_run_initializers_1325 (void) {
    int32_t var_4h;
    if (eax != 1) {
        return;
    }
    eax = ebx;
    eax = camlCamlinternalOO_create_object_1305 (ebx);
    ebx = *(esp);
    camlCamlinternalOO_run_initializers_1316 (eax);
    eax = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052780 */
#include <stdint.h>
 
uint32_t camlArray_iter_1101 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = 1;
    edx = *((ebx - 4));
    esi = *((ebx - 4));
    esi &= 0xff;
    if (esi != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    edx += 0xfffffffe;
    if (ecx > edx) {
        goto label_1;
    }
    *((esp + 0xc)) = edx;
    *((esp + 8)) = ecx;
    *(esp) = ebx;
    *((esp + 4)) = eax;
    do {
        ebx = *(esp);
        eax = *((ebx - 4));
        if (eax != 0xfe) {
            eax = *((ebx + ecx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 4));
        ecx = *(ebx);
        void (*ecx)() ();
        ecx = *((esp + 8));
        ebx = *((esp + 8));
        ecx += 2;
        *((esp + 8)) = ecx;
        eax = *((esp + 0xc));
    } while (ebx != eax);
label_1:
    eax = 1;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055020 */
#include <stdint.h>
 
int32_t camlList_split_1220 (void) {
    int32_t var_4h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        edx = *((eax + 4));
        ecx = *(eax);
        ebx = *((ecx + 4));
        ebx = *(ecx);
        eax = edx;
        eax = camlList_split_1220 (ebx, ebx);
    } while (1);
    ebx = *((eax + 4));
    edx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx = ecx + 0xc;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = edx;
            eax = ecx + 0x18;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = loc.camlList__41;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075d50 */
#include <stdint.h>
 
int32_t divdi3 (int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_4h) {
    int32_t var_20h;
    uint32_t var_1ch;
    uint32_t var_18h;
    int32_t var_14h;
    uint32_t var_10h;
    int32_t var_ch;
    ecx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    edi = *((ebp + 0x14));
    edx = *((ebp + 8));
    *((ebp - 0x10)) = esi;
    *((ebp - 0xc)) = edi;
    *((ebp - 0x14)) = 0;
    if (ecx < 0) {
        goto label_3;
    }
    esi = *((ebp - 0xc));
    if (esi < 0) {
        goto label_4;
    }
label_2:
    eax = *((ebp - 0xc));
    edi = ecx;
    esi = *((ebp - 0x10));
    *((ebp - 0x10)) = edx;
    if (eax == 0) {
        if (esi <= ecx) {
            goto label_5;
        }
        ecx = edx;
        edx = edi;
        eax = ecx;
        edi = 0;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
    } else {
        if (eax <= ecx) {
            goto label_6;
        }
label_0:
        edi = 0;
        ecx = 0;
    }
    do {
label_1:
        eax = ecx;
        ecx = *((ebp - 0x14));
        edx = edi;
        if (ecx != 0) {
            eax = -eax;
            edx += 0;
            edx = -edx;
        }
        return eax;
label_5:
        if (esi == 0) {
            eax = 1;
            edx = 0;
            eax = edx:eax / esi;
            edx = edx:eax % esi;
            esi = eax;
        }
        ecx = *((ebp - 0x10));
        eax = edi;
        edx = 0;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        edi = eax;
        eax = ecx;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
    } while (1);
label_6:
    __asm ("bsr edx, eax");
    edx ^= 0x1f;
    *((ebp - 0x18)) = edx;
    if (esi != 0) {
        goto label_7;
    }
    if (esi <= *((ebp - 0x10))) {
        goto label_8;
    }
    if (eax >= ecx) {
        goto label_0;
    }
label_8:
    edi = 0;
    ecx = 1;
    goto label_1;
label_3:
    esi = *((ebp - 0xc));
    edx = -edx;
    ecx += 0;
    ecx = -ecx;
    *((ebp - 0x14)) = 0xffffffff;
    if (esi >= 0) {
        goto label_2;
    }
label_4:
    ebp - 0x10 = -ebp - 0x10;
    *((ebp - 0xc)) += 0;
    ebp - 0x14 = ~ebp - 0x14;
    ebp - 0xc = -ebp - 0xc;
    goto label_2;
label_7:
    ecx = *((ebp - 0x18));
    edx = esi;
    eax <<= cl;
    *((ebp - 0x1c)) = eax;
    eax = 0x20;
    eax -= *((ebp - 0x18));
    ecx = eax;
    edx >>= cl;
    ecx = *((ebp - 0x18));
    edx |= *((ebp - 0x1c));
    esi <<= cl;
    ecx = eax;
    *((ebp - 0x20)) = esi;
    esi = edi;
    esi >>= cl;
    ecx = *((ebp - 0x18));
    *((ebp - 0x1c)) = edx;
    edx = *((ebp - 0x10));
    edi <<= cl;
    ecx = eax;
    edx >>= cl;
    edi |= edx;
    edx = esi;
    eax = edi;
    eax = *(edx:eax) / ebp - 0x1c;
    edx = *(edx:eax) % ebp - 0x1c;
    esi = edx;
    edi = eax;
    edx:eax = eax * *((ebp - 0x20));
    *((ebp - 0x1c)) = edx;
    if (esi >= edx) {
        edx = *((ebp - 0x10));
        ecx = *((ebp - 0x18));
        edx <<= cl;
        if (edx < eax) {
            if (esi == *((ebp - 0x1c))) {
                goto label_9;
            }
        }
        ecx = edi;
        edi = 0;
        goto label_1;
    }
label_9:
    ecx = edi - 1;
    edi = 0;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8074c85 */
#include <stdint.h>
 
int32_t caml_final_do_young_roots (int32_t arg_8h) {
    int32_t var_4h;
    edi = *((ebp + 8));
    esi = old;
    if (esi >= *(obj.young)) {
        goto label_0;
    }
    ebx = esi * 3;
    ebx <<= 2;
    do {
        eax = ebx;
        eax += *(obj.final_table);
        eax = *(eax);
        void (*edi)(uint32_t, uint32_t) (eax, eax);
        eax = ebx;
        eax += *(obj.final_table);
        edx = eax + 4;
        eax = *((eax + 4));
        void (*edi)(uint32_t, uint32_t) (eax, edx);
        esi++;
        ebx += 0xc;
    } while (*(obj.young) > esi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cb12 */
#include <stdint.h>
 
int32_t caml_abs_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    fp_stack[0] = abs(fp_stack[0]);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fc26 */
#include <stdint.h>
 
uint32_t caml_marshal_data_size (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 0xc));
    edx >>= 1;
    edx += *((ebp + 8));
    *(obj.intern_input_malloced) = 0;
    eax = edx + 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *(edx);
    edx <<= 0x18;
    edx = ecx + edx;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    edx += ecx;
    ecx = *((eax - 2));
    ecx <<= 8;
    edx += ecx;
    if (edx != 0x8495a6be) {
        eax = caml_failwith (0x8076f28);
    }
    eax += 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 4));
    ecx <<= 0x18;
    edx = *((eax - 1));
    ecx += edx;
    edx = *((eax - 3));
    edx <<= 0x10;
    ecx += edx;
    edx = *((eax - 2));
    edx <<= 8;
    eax = ecx + edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804e130 */
#include <stdint.h>
 
int32_t camlUnix_close_process_2009 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edx = ebx;
    *((esp + 8)) = edx;
    ecx = eax;
    *(esp) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            *((ebx + 4)) = edx;
            eax = "close_process";
            eax = camlUnix_find_proc_id_1997 ();
            *((esp + 4)) = eax;
            eax = *(esp);
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = void (*0x804e1a0)() ();
            ecx = loc.caml_exn_Sys_error;
            ebx = *(eax);
            if (ebx != ecx) {
                caml_raise_exn ();
                *(obj.caml_exception_pointer) = esp;
                eax = *((esp + 0x10));
                camlPervasives_close_out_1209 (*(obj.caml_exception_pointer));
            }
            eax = *((esp + 4));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ee53 */
#include <stdint.h>
 
int32_t caml_serialize_int_2 (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = extern_ptr;
    eax += 2;
    if (*(obj.extern_limit) < eax) {
        eax = 2;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = ebx;
    edx >>= 8;
    *(eax) = dl;
    *((eax + 1)) = bl;
    eax += 2;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8055150 */
#include <stdint.h>
 
int32_t camlList_merge_1233 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    do {
label_0:
        if (ebx == 1) {
            goto label_2;
        }
        if (ecx == 1) {
            goto label_3;
        }
        edx = *((ecx + 4));
        edx = *(ecx);
        ecx = *((ebx + 4));
        eax = *(ebx);
        ebx = edx;
        ecx = *((esp + 0xc));
        eax = caml_apply2 (ecx, edx, edx);
        if (eax > 1) {
            goto label_4;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 0x10));
        ecx = *((esp + 0x14));
        eax = camlList_merge_1233 ();
    } while (1);
    ecx = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 0x18));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = ebx;
    return eax;
label_4:
    eax = *((esp + 0xc));
    ebx = *(esp);
    ecx = *((esp + 4));
    eax = camlList_merge_1233 ();
    goto label_0;
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
label_3:
            eax = ebx;
            return eax;
label_2:
            eax = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804acb0 */
#include <stdint.h>
 
int32_t caml_curry9_8 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    int32_t var_20h;
    int32_t var_24h;
    int32_t var_28h;
    *((esp + 0x24)) = eax;
    *(esp) = ebx;
    eax = *((ebx + 0xc));
    *((esp + 4)) = eax;
    eax = *((eax + 0xc));
    *((esp + 8)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0xc)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x10)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x14)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x18)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x1c)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x28)) = eax;
    eax = *(esp);
    eax = *((eax + 8));
    *((esp + 0x20)) = eax;
    eax = *((esp + 4));
    eax = *((eax + 8));
    *((esp + 4)) = eax;
    eax = *((esp + 8));
    eax = *((eax + 8));
    *(esp) = eax;
    eax = *((esp + 0xc));
    esi = *((eax + 8));
    eax = *((esp + 0x10));
    edx = *((eax + 8));
    eax = *((esp + 0x14));
    ecx = *((eax + 8));
    eax = *((esp + 0x18));
    ebx = *((eax + 8));
    eax = *((esp + 0x1c));
    eax = *((eax + 8));
    edi = *((esp + 0x28));
    edi = *((edi + 8));
    *((esp + 8)) = edi;
    edi = *(esp);
    ebp = *((esp + 4));
    *(loc.caml_extra_params) = ebp;
    ebp = *((esp + 0x20));
    *(0x8084740) = ebp;
    ebp = *((esp + 0x24));
    *(0x8084744) = ebp;
    ebp = *((esp + 0x28));
    *(0x8084748) = ebp;
    ebp = *((esp + 8));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f800 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_narrow_1204 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    eax = ebx;
    eax = camlCamlinternalOO_to_list_1202 (eax, edx);
    eax = *(esp);
    eax = camlCamlinternalOO_to_list_1202 (eax);
    eax = *((esp + 4));
    eax = camlCamlinternalOO_to_list_1202 (eax);
    ebx = .comment;
    ecx = *(ebx);
    eax = *((esp + 0x18));
    void (*ecx)(uint32_t) (eax);
    ebx = *((esp + 0xc));
    eax = camlList_map_1062 ();
    ebx = .comment;
    ecx = *(ebx);
    eax = *((esp + 0x18));
    void (*ecx)(uint32_t) (eax);
    ebx = *(esp);
    eax = camlList_map_1062 ();
    *((esp + 4)) = eax;
label_3:
    eax = caml_young_ptr;
    eax -= 0x28;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_4;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x1800;
    ebx = *((esp + 0x18));
    ecx = *((ebx + 8));
    *(eax) = ecx;
    ecx = *((ebx + 0xc));
    *((eax + 4)) = ecx;
    ecx = *((ebx + 0x14));
    *((eax + 8)) = ecx;
    ecx = *((ebx + 0x18));
    *((eax + 0xc)) = ecx;
    ecx = *((esp + 0x14));
    *((eax + 0x10)) = ecx;
    esi = *((esp + 8));
    *((eax + 0x14)) = esi;
    ecx = eax + 0x1c;
    *((ecx - 4)) = 0x800;
    *(ecx) = eax;
    eax = *((ebx + 0x10));
    *((ecx + 4)) = eax;
    eax = ebx;
    eax += 0x10;
    caml_modify (eax, ecx);
label_2:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.caml_curry3;
    *((eax + 4)) = 7;
    *((eax + 8)) = 0x805e9a0;
    *((eax + 0xc)) = esi;
    ecx = 1;
    ebx = *((ebx + 0x18));
    eax = camlMap_fold_1196 ();
    ebx = *((esp + 0x1c));
    eax = *((esp + 0x1c));
    eax += 0x18;
    caml_modify (eax, eax);
label_1:
    eax = caml_young_ptr;
    eax -= 0x2c;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_6;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x400;
    *(edx) = 1;
    ecx = edx + 8;
    *((ecx - 4)) = 0x400;
    *(ecx) = 1;
    eax = edx + 0x10;
    *((eax - 4)) = 0x18f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x805e9f0;
    *((eax + 0xc)) = ebx;
    *((eax + 0x10)) = edx;
    *((eax + 0x14)) = ecx;
    ebx = *(esp);
    ecx = *((esp + 4));
    camlList_iter2_1111 (ecx, edx);
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_7;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x805eab0;
    ebx = *((esp + 8));
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 0x10));
    *((eax + 0x10)) = ebx;
    ebx = *((esp + 0xc));
    ecx = *((esp + 0x14));
    camlList_iter2_1111 ();
    eax = *((esp + 8));
    ebx = *((esp + 0x1c));
    eax = *((esp + 0x1c));
    eax += 8;
    caml_modify (eax, *(eax));
    eax = *((esp + 0x10));
    eax = ebx;
    eax += 0xc;
    caml_modify (eax, *(eax));
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x805eb10;
            ecx = *((esp + 0x14));
            *((eax + 0xc)) = ecx;
            ecx = 1;
            ebx = *((ebx + 0x14));
            eax = camlList_fold_right_1084 ();
            eax = *((esp + 0x1c));
            eax += 0x14;
            caml_modify (eax, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_7:
    caml_call_gc ();
    goto label_0;
label_6:
    caml_call_gc ();
    goto label_1;
label_5:
    caml_call_gc ();
    goto label_2;
label_4:
    caml_call_gc ();
    goto label_3;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80590b0 */
#include <stdint.h>
 
uint32_t camlMap_mem_1124 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 0xc));
        edx = *((ebx + 4));
        ebx = *(ebx);
        ebx = *((ecx + 0xc));
        ecx = *(ebx);
        ebx = edx;
        eax = caml_apply2 (eax, ecx, edx);
        if (eax == 1) {
            eax = 3;
            return eax;
        }
        if (eax < 1) {
            ebx = *((esp + 0xc));
        } else {
            ebx = *((esp + 8));
        }
        eax = *(esp);
        ecx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058660 */
#include <stdint.h>
 
int32_t camlObj_marshal_1052 (void) {
    eax = caml_output_value_to_string;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b650 */
#include <stdint.h>
 
int32_t camlSource_fun_1131 (void) {
    int32_t var_4h;
    eax = ebx;
    ebx = *((edx + 0x10));
    camlCamlinternalOO_create_object_opt_1308 (edx, ecx);
    ebx = *(esp);
    ecx = *((ebx + 0xc));
    ebx = *((esp + 4));
    *((eax + ecx*2 - 2)) = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cade */
#include <stdint.h>
 
int32_t caml_sub_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] -= *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060bd0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_send_const_1453 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlCamlinternalOO__fun_1846;
            *((eax + 4)) = 3;
            *((eax + 8)) = edx;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d420 */
#include <stdint.h>
 
uint32_t camlUnix_getnameinfo_1781 (void) {
    int32_t var_4h;
    eax = void (*0x804d460)(uint32_t, uint32_t) (eax, ebx);
    ecx = loc.caml_exn_Invalid_argument;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *(esp);
        ebx = *((esp + 4));
        void (*0x804d1a0)() ();
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_getnameinfo;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b2e0 */
#include <stdint.h>
 
int32_t caml_curry4_3 (void) {
    edx = eax;
    edi = *((ebx + 0xc));
    eax = *((edi + 0xc));
    esi = *((eax + 0xc));
    ecx = *((ebx + 8));
    ebx = *((edi + 8));
    eax = *((eax + 8));
    edi = *((esi + 8));
    return void (*edi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b99c */
#include <stdint.h>
 
int32_t caml_int32_to_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ed50 */
#include <stdint.h>
 
uint32_t caml_serialize_block_2 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_2ch;
    int32_t var_1ch;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    eax = edi + edi;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    ecx = extern_ptr;
    if (edi <= 0) {
        goto label_0;
    }
    eax = 0;
    *((ebp - 0x2c)) = edi;
    *((ebp - 0x1c)) = edi;
    do {
        esi = *((ebx + eax));
        edi = *((ebx + eax + 1));
        edx = edi;
        *((ecx + eax)) = dl;
        edx = esi;
        *((ecx + eax + 1)) = dl;
        eax += 2;
        *((ebp - 0x2c))--;
    } while (*((ebp - 0x2c)) != 0);
    edi = *((ebp - 0x1c));
    ecx = ecx + edi*2;
label_0:
    *(obj.extern_ptr) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d9c6 */
#include <stdint.h>
 
int32_t caml_seek_in (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    uint32_t var_30h;
    int32_t var_2ch;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    eax = *((ebx + 4));
    edx = *((ebx + 8));
    *((ebp - 0x30)) = eax;
    *((ebp - 0x2c)) = edx;
    edx = *((ebx + 0x14));
    *((ebp - 0x24)) = edx;
    eax = ebx + 0x34;
    edx -= eax;
    *((ebp - 0x20)) = edx;
    ecx = edx;
    ecx >>= 0x1f;
    *((ebp - 0x1c)) = ecx;
    eax = *((ebp - 0x30));
    edx = *((ebp - 0x2c));
    eax -= *((ebp - 0x20));
    edx -= *((ebp - 0x1c));
    *((ebp - 0x20)) = eax;
    *((ebp - 0x1c)) = edx;
    if (edx <= esi) {
        if (*((ebp - 0x1c)) >= esi) {
            if (eax > edi) {
                goto label_0;
            }
        }
        if (*((ebp - 0x2c)) >= esi) {
            if (*((ebp - 0x2c)) <= esi) {
                if (*((ebp - 0x30)) < edi) {
                    goto label_0;
                }
            }
            eax = edi;
            eax -= *((ebp - 0x30));
            eax += *((ebp - 0x24));
            *((ebx + 0x10)) = eax;
        }
    } else {
label_0:
        caml_enter_blocking_section ();
        *((esp + 0xc)) = 0;
        *((esp + 4)) = edi;
        *((esp + 8)) = esi;
        eax = *(ebx);
        *(esp) = eax;
        eax = lseek64 ();
        edx ^= esi;
        eax ^= edi;
        edx |= eax;
        if (edx != 0) {
            caml_leave_blocking_section ();
            caml_sys_error (1);
        }
        caml_leave_blocking_section ();
        *((ebx + 4)) = edi;
        *((ebx + 8)) = esi;
        eax = ebx + 0x34;
        *((ebx + 0x14)) = eax;
        *((ebx + 0x10)) = eax;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806628d */
#include <stdint.h>
 
int32_t unix_truncate (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1266e;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((esp + 8)) = edx;
    *(esp) = esi;
    eax = truncate64 ();
    if (eax == -1) {
        eax = ebx - 0x1484;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80755ff */
#include <stdint.h>
 
int32_t caml_search_dll_in_path (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * src;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = 0xffffffff;
    edi = *((ebp + 0xc));
    ecx = esi;
    eax = 0;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ecx += 3;
    eax = caml_stat_alloc (ecx);
    ebx = eax;
    ecx = *((ebp + 0xc));
    strcpy (eax, ecx);
    edi = ebx;
    ecx = esi;
    eax = 0;
    __asm ("repne scasb al, byte es:[edi]");
    esi = ecx;
    esi = ~esi;
    *((ebx + esi - 1)) = 0x6f732e;
    eax = *((ebp + 8));
    eax = caml_search_in_path (eax, ebx);
    esi = eax;
    caml_stat_free (ebx);
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c0b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2622 (void) {
    eax = unix_initgroups;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061b38 */
#include <stdint.h>
 
uint32_t unix_bind (int32_t socket, int32_t arg_ch) {
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_8h;
    int32_t var_4h;
    struct sockaddr* address;
    socklen_t address_len;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16dc0;
    eax = ebp - 0x7c;
    esi = ebp - 0x78;
    eax = *((ebp + 0xc));
    get_sockaddr (eax, esi, eax);
    eax = *((ebp - 0x7c));
    eax = *((ebp + 8));
    eax >>= 1;
    eax = bind (eax, esi, eax);
    if (eax == -1) {
        eax = ebx - 0x263e;
        uerror (eax, 0);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a4c4 */
#include <stdint.h>
 
void bind (void) {
    bind ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804cba0 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_1646 (void) {
    eax = unix_setsockopt;
    caml_c_call (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062140 */
#include <stdint.h>
 
uint32_t unix_clear_close_on_exec (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x167bb;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 1;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        eax &= 0xfffffffe;
        *((esp + 8)) = eax;
        *((esp + 4)) = 2;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x25ea;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d808 */
#include <stdint.h>
 
int32_t caml_ml_close_channel (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    ebx = *(eax);
    if (ebx == -1) {
        goto label_0;
    }
    *(eax) = 0xffffffff;
    edx = *((eax + 0xc));
    *((eax + 0x14)) = edx;
    *((eax + 0x10)) = edx;
    caml_enter_blocking_section ();
    eax = close (ebx);
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx != -1) {
        goto label_1;
    }
    caml_sys_error (1);
    do {
label_1:
        eax = 1;
        return eax;
label_0:
        edx = *((eax + 0xc));
        *((eax + 0x14)) = edx;
        *((eax + 0x10)) = edx;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064e04 */
#include <stdint.h>
 
uint32_t unix_sigpending (void) {
    int32_t var_88h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13af9;
    eax = ebp - 0x88;
    *(esp) = eax;
    eax = sigpending ();
    if (eax == -1) {
        eax = ebx - 0x2439;
        uerror (eax, 0);
    }
    eax = ebp - 0x88;
    encode_sigset ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a4f4 */
#include <stdint.h>
 
void sigpending (void) {
    sigpending ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805efd0 */
#include <stdint.h>
 
uint32_t camlCamlinternalOO_fun_1842 (void) {
    int32_t var_4h;
    edx = *((ebx + 8));
    ecx = *(eax);
    ecx = *((ecx + edx*2 - 2));
    ecx = *((ebx + 0xc));
    ebx = *(eax);
    ebx = *((ebx + ecx*2 - 2));
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t, uint32_t) (eax, ecx);
    ebx = eax;
    eax = *(esp);
    ecx = *((esp + 4));
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056e00 */
#include <stdint.h>
 
uint32_t camlHashtbl_safehash_1177 (void) {
    ebx = *((ebx + 8));
    ebx = *((ebx + 4));
    ecx = *(ebx);
    eax = void (*ecx)() ();
    ebx = 0x7fffffff;
    eax &= ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b030 */
#include <stdint.h>
 
int32_t caml_curry6_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bf1c */
#include <stdint.h>
 
int32_t caml_int64_or (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 4));
    ecx |= *((eax + 4));
    edx = *((edx + 8));
    edx |= *((eax + 8));
    caml_copy_int64 (ecx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80628c8 */
#include <stdint.h>
 
uint32_t unix_getegid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16038;
    getegid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a484 */
#include <stdint.h>
 
void getegid (void) {
    getegid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8069ec5 */
#include <stdint.h>
 
int32_t caml_free_dependent_memory (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 2;
    edx = caml_dependent_size;
    if (eax > edx) {
        *(obj.caml_dependent_size) = 0;
    } else {
        edx -= eax;
        *(obj.caml_dependent_size) = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054660 */
#include <stdint.h>
 
void camlList_rev_1056 (void) {
    ebx = 1;
    return camlList_rev_append_1051 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ae00 */
#include <stdint.h>
 
void camlBuffer_output_buffer_1094 (void) {
    edx = *((ebx + 4));
    ecx = 1;
    ebx = *(ebx);
    return camlPervasives_output_1194 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b7b0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1686 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075acc */
#include <stdint.h>
 
void caml_debugger_init (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80584e0 */
#include <stdint.h>
 
uint32_t camlMarshal_total_size_1051 (void) {
    eax = camlMarshal_data_size_1048 ();
    eax += 0x28;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b0c0 */
#include <stdint.h>
 
int32_t camlBuffer_add_substitute_1122 (void) {
    esi = eax;
    edx = ecx;
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((edx + eax));
    eax -= ecx;
    edi = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x1cf7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x805a780;
            *((ecx + 0xc)) = esi;
            *((ecx + 0x10)) = ebx;
            *((ecx + 0x14)) = edx;
            *((ecx + 0x18)) = edi;
            ebx = 1;
            eax = 0x41;
            void (*0x805a780)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c420 */
#include <stdint.h>
 
int32_t camlUnix_fun_2722 (void) {
    eax = unix_chmod;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058450 */
#include <stdint.h>
 
int32_t camlMarshal_to_buffer_1038 (void) {
    if (ebx >= 1) {
        if (ecx < 1) {
            goto label_0;
        }
        edi = *((eax - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((eax + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= ecx;
        ebp += 2;
        if (ebx > ebp) {
            goto label_0;
        }
        eax = caml_output_value_to_buffer;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Marshal.to_buffer: substring out of bounds";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ad80 */
#include <stdint.h>
 
int32_t caml_curry7 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80522c0 */
#include <stdint.h>
 
void camlArray_concat_1075 (void) {
    ebx = loc.camlArray__29;
    return camlArray_find_init_1077 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f080 */
#include <stdint.h>
 
void camlCamlinternalOO_fun_1858 (void) {
    int32_t var_4h;
    ecx = *((ebx + 0xc));
    ebx = *(eax);
    ebx = *((ebx + ecx*2 - 2));
    ecx = *(ebx);
    void (*ecx)(uint32_t, uint32_t) (ebx, eax);
    edx = *(esp);
    ecx = *((edx + 0x10));
    ebx = *((esp + 4));
    ebx = *(ebx);
    ecx = ebx + ecx*2 - 2;
    ebx = *((edx + 8));
    return caml_send0 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c0d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2626 (void) {
    eax = unix_getgroups;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c7e0 */
#include <stdint.h>
 
int32_t camlUnix_write_1242 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = unix_write;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.write";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80594d0 */
#include <stdint.h>
 
uint32_t camlMap_mapi_1186 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    do {
label_0:
        if (ebx == 1) {
            goto label_1;
        }
        ecx = *((ebx + 0x10));
        ecx = *((ebx + 0xc));
        ecx = *((ebx + 8));
        ecx = *((ebx + 4));
        ebx = *(ebx);
        eax = camlMap_mapi_1186 (ecx, eax, ecx);
    } while (1);
    eax = *((esp + 0x10));
    ebx = *(esp);
    ecx = *((esp + 4));
    eax = caml_apply2 (eax);
    eax = *((esp + 4));
    ebx = *((esp + 8));
    eax = camlMap_mapi_1186 (eax);
    goto label_0;
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1400;
            ebx = *((esp + 0xc));
            *(eax) = ebx;
            ebx = *((esp + 0x10));
            *((eax + 4)) = ebx;
            ebx = *(esp);
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = ecx;
            ebx = *((esp + 0x14));
            *((eax + 0x10)) = ebx;
            return eax;
label_1:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058c00 */
#include <stdint.h>
 
int32_t camlMap_bal_1081 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h_2;
    int32_t var_14h;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    if (ebp != 1) {
        edi = *((ebp + 0x10));
    } else {
        edi = 1;
    }
    if (edx != 1) {
        esi = *((edx + 0x10));
    } else {
        esi = 1;
    }
    eax = 1;
    eax += 4;
    if (edi > eax) {
        if (ebp != 1) {
            *((esp + 0x1c)) = ecx;
            *((esp + 0x18)) = ebx;
            ebx = *((ebp + 0xc));
            edi = *((ebp + 8));
            esi = *((ebp + 4));
            eax = *(ebp);
            if (ebx != 1) {
                ecx = *((ebx + 0x10));
            } else {
                ecx = 1;
            }
            if (eax != 1) {
                ebp = *((eax + 0x10));
            } else {
            }
            if (ebp >= ecx) {
                eax = ebx;
                ebx = *((esp + 0x18));
                ecx = *((esp + 0x1c));
                eax = camlMap_create_1071 (eax);
                edx = eax;
                eax = *((esp + 0x14));
                ebx = *((esp + 0x20));
                ecx = *((esp + 0x24));
                void (*0x8058b40)() ();
            }
            if (ebx != 1) {
                eax = *((ebx + 0xc));
                eax = *((ebx + 8));
                eax = *((ebx + 4));
                eax = *(ebx);
                eax = *(esp);
                ebx = *((esp + 0x18));
                ecx = *((esp + 0x1c));
                edx = *((esp + 4));
                eax = camlMap_create_1071 (eax, edx, eax);
                eax = *((esp + 0x14));
                ebx = *((esp + 0x20));
                ecx = *((esp + 0x24));
                edx = *((esp + 8));
                camlMap_create_1071 (eax);
                ebx = *((esp + 0xc));
                ecx = *((esp + 0x10));
                edx = *(esp);
                void (*0x8058b40)() ();
            }
            eax = "Map.bal";
            void (*0x804f900)() ();
        }
        eax = "Map.bal";
        void (*0x804f900)() ();
    }
    eax = edi;
    eax += 4;
    if (esi > eax) {
        if (edx != 1) {
            *((esp + 0x10)) = ebp;
            esi = *((edx + 0xc));
            eax = *((edx + 8));
            *((esp + 0x14)) = eax;
            edi = *((edx + 4));
            edx = *(edx);
            if (edx != 1) {
                eax = *((edx + 0x10));
            } else {
                eax = 1;
            }
            if (esi != 1) {
                ebp = *((esi + 0x10));
            } else {
            }
            if (ebp >= eax) {
                eax = *((esp + 0x10));
                camlMap_create_1071 (edi, esi);
                ebx = *(esp);
                ecx = *((esp + 0x14));
                edx = *((esp + 4));
                void (*0x8058b40)() ();
            }
            if (edx != 1) {
                eax = *((edx + 0xc));
                eax = *((edx + 8));
                eax = *((edx + 4));
                eax = *(edx);
                eax = *(esp);
                ebx = edi;
                ecx = *((esp + 0x14));
                edx = esi;
                eax = camlMap_create_1071 (ecx, eax, eax);
                eax = *((esp + 0x10));
                ebx = *((esp + 0x18));
                ecx = *((esp + 0x1c));
                edx = *((esp + 4));
                camlMap_create_1071 (eax);
                ebx = *((esp + 8));
                ecx = *((esp + 0xc));
                edx = *(esp);
                void (*0x8058b40)() ();
            }
            eax = "Map.bal";
            void (*0x804f900)() ();
        }
        eax = "Map.bal";
        void (*0x804f900)() ();
    }
    if (edi >= esi) {
        esi = edi;
        esi += 2;
    } else {
        esi += 2;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1400;
            *(eax) = ebp;
            *((eax + 4)) = ebx;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = esi;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060240 */
#include <stdint.h>
 
uint32_t camlCamlinternalOO_make_class_1286 (void) {
    int32_t var_4h;
    int32_t var_8h;
    eax = camlCamlinternalOO_create_table_1267 (ebx);
    ebx = *((esp + 4));
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t) (eax);
    eax = *(esp);
    camlCamlinternalOO_init_class_1274 (eax);
    eax = 1;
    ebx = *((esp + 8));
    ecx = *(ebx);
    eax = void (*ecx)() ();
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1000;
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            ebx = *((esp + 8));
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061930 */
#include <stdint.h>
 
uint32_t loc_camlCamlinternalOO_code_end (int32_t arg_8h) {
    int32_t var_b0h;
    int32_t var_ach;
    int32_t var_a8h;
    int32_t var_a4h;
    int32_t var_90h;
    int32_t var_8ch;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x16fcb;
    *((ebp - 0x90)) = 0x70;
    caml_enter_blocking_section ();
    eax = ebp - 0x90;
    eax = ebp - 0x8c;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = accept (eax, eax, eax);
    edi = eax;
    caml_leave_blocking_section ();
    if (edi == -1) {
        eax = ebx - 0x2660;
        uerror (eax, 0);
    }
    eax = *((ebp - 0x90));
    eax = ebp - 0x8c;
    eax = alloc_sockaddr (eax, eax, edi);
    *((ebp - 0x1c)) = eax;
    esi = *((ebx - 0x18));
    eax = *(esi);
    *((ebp - 0xb0)) = eax;
    eax = ebp - 0xb0;
    *(esi) = eax;
    *((ebp - 0xa8)) = 1;
    *((ebp - 0xac)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0xa4)) = eax;
    caml_alloc_small (2, 0);
    edx = edi + edi + 1;
    *(eax) = edx;
    edx = *((ebp - 0x1c));
    *((eax + 4)) = edx;
    edx = *((ebp - 0xb0));
    *(esi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a284 */
#include <stdint.h>
 
void accept (void) {
    accept ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8074ce5 */
#include <stdint.h>
 
int32_t caml_final_empty_young (void) {
    eax = young;
    *(obj.old) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ec30 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1733 (void) {
    int32_t var_4h;
    edx = eax;
    eax = ebx;
    ebx = edx + edx + 3;
    edx = .comment;
    edx = *((edx + 0xc));
    ecx = *((ecx + 0xc));
    ecx = *((ecx + 8));
    eax = camlMap_add_1108 (ebx, ecx);
    ebx = *((esp + 8));
    eax = *((ebx + 0xc));
    eax += 8;
    caml_modify (eax, eax);
    eax = .comment;
    edx = *((eax + 0xc));
    eax = *((ebx + 0xc));
    ecx = *((eax + 0xc));
    ebx = 3;
    eax = *(esp);
    eax = camlMap_add_1108 ();
    eax = *((esp + 8));
    eax = *((eax + 0xc));
    eax += 0xc;
    caml_modify (eax, eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805bfe0 */
#include <stdint.h>
 
int32_t camlPrintf_loop_1240 (void) {
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = *((ecx + 0x14));
    if (edx < eax) {
        goto label_1;
    }
    *((esp + 4)) = ecx;
    *(esp) = ebx;
    eax = caml_make_vect;
    eax = caml_c_call (*((ecx + 0x14)));
    ecx = eax;
    *((esp + 8)) = ecx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x805b3f0;
    ebx = *((esp + 4));
    ebx = *((ebx + 0x14));
    *((eax + 0xc)) = ebx;
    *((eax + 0x10)) = ecx;
    ebx = *(esp);
    camlPrintf_list_iter_i_1201 ();
    eax = *((esp + 4));
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    ebx = *((esp + 8));
    void (*0x804b5d0)() ();
    do {
label_1:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlPrintf__fun_1568;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80556b0 */
#include <stdint.h>
 
int32_t camlChar_lowercase_1043 (void) {
    if (eax >= 0x83) {
        if (eax <= 0xb5) {
            goto label_0;
        }
    }
    if (eax >= 0x181) {
        if (eax <= 0x1ad) {
            goto label_0;
        }
    }
    if (eax >= 0x1b1) {
        if (eax <= 0x1bd) {
            goto label_0;
        }
    }
    return;
label_0:
    eax += 0x40;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f050 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1854 (void) {
    edx = *((ebx + 0x10));
    ecx = *((ebx + 0xc));
    ecx = *((eax + ecx*2 - 2));
    esi = *((ecx + edx*2 - 2));
    edx = *((ebx + 0x14));
    ecx = *(eax);
    ecx = ecx + edx*2 - 2;
    ebx = *((ebx + 8));
    eax = esi;
    return caml_send0 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807333e */
#include <stdint.h>
 
int32_t caml_lazy_follow_forward (int32_t arg_8h) {
    eax = *((ebp + 8));
    if ((al & 1) == 0) {
        ecx = eax;
        ecx >>= 0x17;
        edx = eax;
        edx >>= 0xc;
        edx &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
        if ((*((ecx + edx)) & 7) == 0) {
            goto label_0;
        }
        if (*((eax - 4)) != 0xfa) {
            goto label_0;
        }
        eax = *(eax);
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066314 */
#include <stdint.h>
 
int32_t unix_error_of_code (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_ch;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x125e7;
    esi = *((ebp + 8));
    eax = *((ebx - 8));
    eax = cst_to_constr (0xffffffff, eax, 0x44);
    edx = eax;
    if (eax == -1) {
        eax = caml_alloc_small (1, 0);
        edx = eax;
        eax = esi + esi + 1;
        *(edx) = eax;
    }
    eax = edx;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066990 */
#include <stdint.h>
 
int32_t cst_to_constr (int32_t arg_8h, char * arg_ch, size_t arg_10h, int32_t arg_14h) {
    ecx = *((ebp + 8));
    esi = *((ebp + 0xc));
    edx = *((ebp + 0x10));
    if (edx <= 0) {
        goto label_0;
    }
    eax = 0;
    if (*(esi) != ecx) {
        goto label_1;
    }
    while (edx > eax) {
        if (*((esi + eax*4)) == ecx) {
            eax = eax + eax + 1;
            goto label_2;
        }
label_1:
        eax++;
    }
label_0:
    eax = *((ebp + 0x14));
    eax = eax + eax + 1;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067bf9 */
#include <stdint.h>
 
int32_t caml_remove_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = caml_global_roots;
    caml_delete_global_root ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806da91 */
#include <stdint.h>
 
uint32_t caml_ml_seek_in_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    caml_seek_in (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805aab0 */
#include <stdint.h>
 
int32_t camlBuffer_clear_1062 (void) {
    *((eax + 4)) = 1;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805dc30 */
#include <stdint.h>
 
uint32_t camlPrintf_summarize_format_type_1162 (void) {
    int32_t var_4h;
    ecx = eax;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    eax = camlBuffer_create_1039 (ecx);
    edx = eax;
    *((esp + 4)) = edx;
    do {
        eax = caml_young_ptr;
        eax -= 0x2c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x805be60;
            *((ecx + 0xc)) = edx;
            ebx = ecx + 0x14;
            *((ebx - 4)) = 0x14f7;
            *(ebx) = sym.caml_curry3;
            *((ebx + 4)) = 7;
            *((ebx + 8)) = 0x805be80;
            *((ebx + 0xc)) = edx;
            *((ebx + 0x10)) = ecx;
            eax = *(esp);
            camlPrintf_iter_on_format_args_1137 ();
            eax = *((esp + 4));
            ecx = *((eax + 4));
            ebx = 1;
            eax = *(eax);
            void (*0x80558f0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056860 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_bucket_1221 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_2;
        }
        ecx = *((eax + 8));
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0xc));
        eax = caml_apply2 (ecx, eax, ebx);
        if (eax != 1) {
label_1:
            eax = caml_young_ptr;
            eax -= 0x10;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *((esp + 4));
            *(eax) = ebx;
            ebx = *((esp + 8));
            ebx = *((ebx + 0x10));
            *((eax + 4)) = ebx;
            ebx = *((esp + 0xc));
            *((eax + 8)) = ebx;
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_replace_bucket_1221 ();
    } while (1);
    ecx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_4;
    }
    eax = eax + 4;
    *((eax - 4)) = 0xc00;
    ebx = *((esp + 4));
    *(eax) = ebx;
    ebx = *(esp);
    *((eax + 4)) = ebx;
    *((eax + 8)) = ecx;
    return eax;
    do {
label_2:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060870 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_app_env_1390 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlCamlinternalOO__fun_1794;
            *((eax + 4)) = 3;
            *((eax + 8)) = edx;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8065103 */
#include <stdint.h>
 
int32_t alloc_inet_addr (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x137fd;
    caml_alloc_string (4);
    edx = *((ebp + 8));
    edx = *(edx);
    *(eax) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d482 */
#include <stdint.h>
 
int32_t caml_array_set_addr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    ebx = edx + eax*4;
    edi = *(ebx);
    *(ebx) = esi;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) != 0) {
        if (*(obj.caml_gc_phase) == 0) {
            caml_darken (edi, 0);
        }
        if ((esi & 1) != 0) {
            goto label_1;
        }
        eax = caml_young_end;
        if (esi >= eax) {
            goto label_1;
        }
        edx = caml_young_start;
        if (esi <= edx) {
            goto label_1;
        }
        if ((edi & 1) == 0) {
            if (eax <= edi) {
                goto label_2;
            }
            if (edx < edi) {
                goto label_1;
            }
        }
label_2:
        eax = .comment;
        if (eax >= *(0x8087aac)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x8087aa8;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_1:
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e160 */
#include <stdint.h>
 
int32_t camlPrintf_get_index_1265 (void) {
    if (eax != 1) {
        eax = *(eax);
        return eax;
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bfdd */
#include <stdint.h>
 
int32_t caml_int64_div (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    esi = *((eax + 4));
    ebx = *((eax + 8));
    ecx = *((edx + 4));
    edx = *((edx + 8));
    edi = *((edx + 8));
    edi |= ecx;
    if (edi == 0) {
        caml_raise_zero_divide ();
    }
    edi = ebx - 0x80000000;
    edi |= esi;
    if (edi == 0) {
        edi = ecx;
        edi &= edx;
        if (edi == -1) {
            goto label_0;
        }
    }
    eax = _divdi3 (edx, ebx, ecx);
    caml_copy_int64 (eax, edx);
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fb3e */
#include <stdint.h>
 
uint32_t caml_deserialize_float_4 (void) {
    int32_t var_bp_4h;
    int32_t var_4h;
    eax = ebp - 4;
    caml_deserialize_block_4 (eax, 1);
    *(fp_stack--) = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804be30 */
#include <stdint.h>
 
int32_t camlUnix_fun_2836 (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x18f7;
            *(eax) = sym.caml_tuplify2;
            *((eax + 4)) = 0xfffffffd;
            *((eax + 8)) = 0x804bb40;
            edx = *((ecx + 0xc));
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = esi;
            *((eax + 0x14)) = ebx;
            ebx = *((ecx + 0x10));
            void (*0x80546b0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061d38 */
#include <stdint.h>
 
int32_t unix_closedir (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16bc3;
    esi = *((ebp + 8));
    eax = *(esi);
    if (eax == 0) {
        eax = ebx - 0x2626;
        eax = unix_error (9, eax, 0);
    }
    *(esp) = eax;
    closedir ();
    *(esi) = 0;
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a514 */
#include <stdint.h>
 
void closedir (void) {
    closedir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c440 */
#include <stdint.h>
 
int32_t camlUnix_fun_2726 (void) {
    eax = unix_rename;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80598e0 */
#include <stdint.h>
 
int32_t camlMap_concat_1251 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    if (eax != 1) {
        if (ebx != 1) {
            eax = ebx;
            eax = camlMap_min_binding_1131 (ebx, ecx, eax);
            ebx = *((eax + 4));
            eax = *(eax);
            eax = *(esp);
            eax = camlMap_remove_min_binding_1147 (ebx);
            edx = eax;
            eax = *((esp + 4));
            esi = *((eax + 0x14));
            eax = *((esp + 8));
            ebx = *((esp + 0xc));
            ecx = *((esp + 0x10));
            void (*0x80597a0)() ();
        }
        return eax;
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b490 */
#include <stdint.h>
 
uint32_t camlPrintf_got_spec_1304 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ebx = ecx;
    ecx = *((ebx + 0xc));
    ebx = *((ebx + 0x18));
    eax = camlPrintf_get_arg_1288 (eax, ebx);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((esp + 8)) = ecx;
            *((ecx - 4)) = 0x800;
            *(ecx) = ebx;
            eax = *((esp + 4));
            ebx = *((eax + 0x1c));
            *((ecx + 4)) = ebx;
            eax = *((eax + 0x18));
            ecx = *(esp);
            if (ecx != 1) {
                ebx = eax;
            } else {
                ebx = *((ecx + 8));
                ecx = *(ebx);
                eax = void (*0x8080cd8)() ();
                ebx = eax;
            }
            ecx = *((esp + 4));
            esi = *((ecx + 0x10));
            eax = *((ecx + 0x14));
            ecx = *((esp + 8));
            edx = *((esp + 0xc));
            void (*0x805d2c0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8073b4d */
#include <stdint.h>
 
int32_t caml_callback2 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_callback2_exn (eax, eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075cec */
#include <stdint.h>
 
int32_t loc_caml_callback2_exn (int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch) {
    ecx = *((esp + 0x14));
    eax = *((esp + 0x18));
    ebx = *((esp + 0x1c));
    esi = caml_apply2;
    return void (*0x8075c09)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cf9e */
#include <stdint.h>
 
uint32_t caml_string_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    if (ebx >= 0) {
        eax = caml_string_length (esi);
        if (ebx < eax) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    eax = *((ebx + esi));
    eax = eax + eax + 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070971 */
#include <stdint.h>
 
uint32_t caml_input_value (int32_t arg_8h) {
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    edx = ebp + 8;
    *((ebp - 0x1c)) = edx;
    edx = *((ebp + 8));
    ebx = *((edx + 4));
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = caml_input_val (ebx);
    *((ebp - 0x2c)) = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cf13 */
#include <stdint.h>
 
int32_t caml_string_lessequal (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax < 2) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c2d7 */
#include <stdint.h>
 
int32_t caml_int32_div (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    ecx = *((ebp + 0xc));
    ecx = *((ecx + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            goto label_0;
        }
    }
    eax = edx;
    edx >>= 0x1f;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    caml_copy_int32 (eax);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058950 */
#include <stdint.h>
 
int32_t camlMap_compare_aux_1315 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        if (ebx == 1) {
            goto label_1;
        }
        ecx = *((ebx + 0xc));
        ecx = *((ebx + 8));
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *((eax + 0xc));
        ecx = *((eax + 8));
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((esp + 0x18));
        ecx = *((ecx + 0xc));
        ecx = *(ecx);
        eax = caml_apply2 (ecx, ecx, ecx);
        if (eax != 1) {
            return eax;
        }
        eax = *((esp + 0x18));
        ecx = *((eax + 0x14));
        eax = *(esp);
        ebx = *((esp + 4));
        eax = caml_apply2 ();
        if (eax != 1) {
            return eax;
        }
        eax = *((esp + 8));
        ebx = *((esp + 0xc));
        eax = camlMap_cons_enum_1304 ();
        eax = *((esp + 0x10));
        ebx = *((esp + 0x14));
        camlMap_cons_enum_1304 (eax);
        ebx = *(esp);
        ecx = *((esp + 0x18));
    } while (1);
label_1:
    eax = 3;
    return eax;
label_0:
    if (ebx != 1) {
        eax = 0xffffffff;
        return eax;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x807087e */
#include <stdint.h>
 
uint32_t caml_input_val (int32_t arg_8h) {
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = caml_channel_binary_mode (ebx, esi, edi);
    if (eax == 0) {
        caml_failwith ("input_value: not a binary channel");
    }
    eax = caml_getword (ebx);
    if (eax != 0x8495a6be) {
        caml_failwith ("input_value: bad object");
    }
    eax = caml_getword (ebx);
    edi = eax;
    eax = caml_getword (ebx);
    *((ebp - 0x30)) = eax;
    eax = caml_getword (ebx);
    *((ebp - 0x2c)) = eax;
    caml_getword (ebx);
    eax = caml_stat_alloc (edi);
    esi = eax;
    eax = caml_really_getblock (ebx, eax, edi);
    if (eax == 0) {
        caml_stat_free (esi);
        caml_failwith ("input_value: truncated object");
    }
    *(obj.intern_input) = esi;
    *(obj.intern_input_malloced) = 1;
    *(obj.intern_src) = esi;
    edx = *((ebp - 0x30));
    eax = *((ebp - 0x2c));
    intern_alloc ();
    eax = ebp - 0x1c;
    intern_rec ();
    eax = *((ebp - 0x2c));
    intern_add_to_heap ();
    eax = intern_input;
    caml_stat_free (eax);
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f280 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_compare_1080 (void) {
    eax = caml_compare;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805a6e0 */
#include <stdint.h>
 
int32_t camlBuffer_advance_1111 (void) {
    do {
        if (eax >= ebx) {
            eax = ebx;
            return eax;
        }
        esi = *((ecx + 0xc));
        edx = eax;
        edx >>= 1;
        edi = *((esi - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((esi + ebp));
        ebp -= edi;
        if (ebp <= edx) {
            goto label_0;
        }
        edx = *((esi + edx));
        edx = edx + edx + 1;
        if (edx < 0xbf) {
            if (edx >= 0x75) {
                edx += 0xffffff7e;
                if (edx <= 0x33) {
                    goto label_1;
                }
            } else {
            } else {
            }
        }
        if (edx >= 0x61) {
            goto label_1;
        }
        if (edx >= 0xf7) {
            if (edx < 0x181) {
                goto label_2;
            }
            edx += 0xfffffe80;
            edx >>= 1;
            /* switch table (64 cases) at 0x8080848 */
        }
        if (edx != 0xc1) {
            goto label_1;
        }
label_2:
        return eax;
label_1:
        eax += 2;
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f7b0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1392 (void) {
    eax = caml_ml_set_binary_mode;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80713f4 */
#include <stdint.h>
 
int32_t caml_parse_engine (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_2ch;
    uint32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    uint32_t var_1ch;
    char * format;
    size_t nitems;
    char ** stream;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = *((ebp + 0x10));
    eax >>= 1;
    if (eax > 5) {
        goto label_1;
    }
    /* switch table (6 cases) at 0x8077224 */
    edi = *((ebx + 0x34));
    edi >>= 1;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x20)) = 0;
label_0:
    eax = *((esi + 0x14));
    edx = *((ebp - 0x20));
    eax = *((eax + edx*2));
    *((ebp - 0x1c)) = eax;
    if (eax != 0) {
        goto label_2;
    }
    if (*((ebx + 0x18)) < 0) {
        eax = edi + edi + 1;
        *((ebx + 0x34)) = eax;
        eax = edx + edx + 1;
        *((ebx + 0x38)) = eax;
        ecx = *((ebp - 0x24));
        eax = ecx + ecx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 1;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        *((ebp - 0x20)) = eax;
        eax = *((ebx + 0x3c));
        eax >>= 1;
        *((ebp - 0x24)) = eax;
        eax = *((ebp + 0x14));
        eax &= 1;
        *((ebp - 0x28)) = eax;
        if (eax == 0) {
            ecx = *((ebp + 0x14));
            edx = *((ecx - 4));
            eax = *((esi + 8));
            eax = *((eax + edx*4));
            *((ebx + 0x18)) = eax;
            eax = *(ecx);
            eax = ebx + 0x1c;
            caml_modify (eax, eax);
        } else {
            edx = *((ebp + 0x14));
            edx >>= 1;
            eax = *((esi + 4));
            eax = *((eax + edx*4));
            *((ebx + 0x18)) = eax;
            eax = ebx + 0x1c;
            caml_modify (eax, 1);
        }
        if (*(obj.caml_parser_trace) == 0) {
            goto label_4;
        }
        if (*((ebp - 0x28)) != 0) {
            edx = *((ebp + 0x14));
            edx >>= 1;
            eax = *((esi + 0x38));
            eax = token_name ();
            *((esp + 0xc)) = eax;
            eax = *((ebp - 0x20));
            *((esp + 8)) = eax;
            eax = stderr;
            fprintf (eax, "State %d: read token %s\n");
        } else {
            ecx = *((ebp + 0x14));
            edx = *((ecx - 4));
            eax = *((esi + 0x3c));
            eax = token_name ();
            *((esp + 0xc)) = eax;
            eax = *((ebp - 0x20));
            *((esp + 8)) = eax;
            eax = stderr;
            fprintf (eax, "State %d: read token %s(");
            edx = *((ebp + 0x14));
            eax = *(edx);
            if ((al & 1) != 0) {
                eax >>= 1;
                *((esp + 8)) = eax;
                eax = stderr;
                eax = fprintf (eax, 0x807717b);
            } else {
                edx = *((eax - 4));
                if (dl == 0xfc) {
                    edx = stderr;
                    eax = fputs (eax, edx);
                } else {
                    if (dl == 0xfd) {
                        *(fp_stack--) = *(eax);
                        *((esp + 8)) = fp_stack[0];
                        fp_stack--;
                        eax = stderr;
                        fprintf (eax, 0x807717f);
                    } else {
                        eax = stderr;
                        fputc (0x5f, eax);
                    }
                }
            }
            eax = stderr;
            fwrite (eax, 1, 2);
        }
    }
label_4:
    ecx = *((ebp - 0x20));
    ecx += ecx;
    *((ebp - 0x28)) = ecx;
    eax = *((esi + 0x1c));
    eax = *((eax + ecx));
    ecx = *((ebx + 0x18));
    ecx >>= 1;
    edx = eax + ecx;
    *((ebp - 0x1c)) = edx;
    if (eax != 0) {
        if (edx < 0) {
            goto label_5;
        }
        eax = *((esi + 0x28));
        eax >>= 1;
        if (edx > eax) {
            goto label_5;
        }
        eax = *((esi + 0x30));
        eax = *((eax + edx*2));
        if (ecx == eax) {
            goto label_6;
        }
    }
label_5:
    eax = *((esi + 0x20));
    edx = *((ebp - 0x28));
    eax = *((eax + edx));
    edx = eax + ecx;
    if (eax != 0) {
        if (edx < 0) {
            goto label_7;
        }
        eax = *((esi + 0x28));
        eax >>= 1;
        if (edx > eax) {
            goto label_7;
        }
        edx += edx;
        eax = *((esi + 0x30));
        eax = *((eax + edx));
        if (ecx != eax) {
            goto label_7;
        }
        eax = *((esi + 0x2c));
        eax = *((eax + edx));
        *((ebp - 0x1c)) = eax;
        goto label_2;
    }
label_7:
    if (*((ebp - 0x24)) <= 0) {
        eax = edi + edi + 1;
        *((ebx + 0x34)) = eax;
        ecx = *((ebp - 0x20));
        eax = ecx + ecx + 1;
        *((ebx + 0x38)) = eax;
        edx = *((ebp - 0x24));
        eax = edx + edx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 0xb;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        *((ebp - 0x20)) = eax;
        eax = *((ebx + 0x3c));
        eax >>= 1;
        *((ebp - 0x24)) = eax;
    }
    if (*((ebp - 0x24)) > 2) {
        goto label_8;
    }
    do {
        eax = *(ebx);
        edx = *((eax + edi*4));
        edx >>= 1;
        eax = *((esi + 0x1c));
        eax = *((eax + edx*2));
        ecx = eax + 0x100;
        if (eax != 0) {
            if (ecx < 0) {
                goto label_9;
            }
            eax = *((esi + 0x28));
            eax >>= 1;
            if (ecx > eax) {
                goto label_9;
            }
            eax = *((esi + 0x30));
            if (*((eax + ecx*2)) != 0x100) {
                goto label_9;
            }
            *((ebp - 0x1c)) = ecx;
            *((ebp - 0x24)) = 3;
            if (*(obj.caml_parser_trace) == 0) {
                goto label_10;
            }
            *((esp + 8)) = edx;
            eax = stderr;
            fprintf (eax, "Recovering in state %d\n");
            *((ebp - 0x24)) = 3;
            goto label_11;
        }
label_9:
        if (*(obj.caml_parser_trace) != 0) {
            *((esp + 8)) = edx;
            eax = stderr;
            fprintf (eax, "Discarding state %d\n");
        }
        eax = *((ebx + 0x14));
        eax >>= 1;
        if (edi <= eax) {
            if (*(obj.caml_parser_trace) == 0) {
                goto label_1;
            }
            eax = stderr;
            fwrite (eax, 1, 0x1a);
            eax = 3;
            goto label_3;
        }
        edi--;
    } while (1);
label_8:
    eax = *((ebx + 0x18));
    eax >>= 1;
    if (eax == 0) {
        goto label_1;
    }
    if (*(obj.caml_parser_trace) != 0) {
        eax = stderr;
        fwrite (eax, 1, 0x1b);
    }
    *((ebx + 0x18)) = 0xffffffff;
    goto label_0;
label_6:
    *((ebx + 0x18)) = 0xffffffff;
    al = (*((ebp - 0x24)) > 0) ? 1 : 0;
    eax = (int32_t) al;
    *((ebp - 0x24)) -= eax;
label_11:
    if (*(obj.caml_parser_trace) != 0) {
        eax = *((esi + 0x2c));
        ecx = *((ebp - 0x1c));
        eax = *((eax + ecx*2));
        *((esp + 0xc)) = eax;
        eax = *((ebp - 0x20));
        *((esp + 8)) = eax;
        eax = stderr;
        fprintf (eax, "State %d: shift to state %d\n");
    }
label_10:
    eax = *((esi + 0x2c));
    edx = *((ebp - 0x1c));
    eax = *((eax + edx*2));
    *((ebp - 0x20)) = eax;
    edi++;
    eax = *((ebx + 0x10));
    eax >>= 1;
    if (edi >= eax) {
        eax = edi + edi + 1;
        *((ebx + 0x34)) = eax;
        ecx = *((ebp - 0x20));
        eax = ecx + ecx + 1;
        *((ebx + 0x38)) = eax;
        edx = *((ebp - 0x24));
        eax = edx + edx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 5;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        *((ebp - 0x20)) = eax;
        eax = *((ebx + 0x3c));
        eax >>= 1;
        *((ebp - 0x24)) = eax;
    }
    ecx = edi*4;
    *((ebp - 0x1c)) = ecx;
    edx = *(ebx);
    ecx = *((ebp - 0x20));
    eax = ecx + ecx + 1;
    ecx = *((ebp - 0x1c));
    *((ecx + edx)) = eax;
    eax = *((ebx + 0x1c));
    eax = ecx;
    eax += *((ebx + 4));
    caml_modify (eax, eax);
    eax = *((ebx + 0x20));
    eax = *((ebp - 0x1c));
    eax += *((ebx + 8));
    caml_modify (eax, eax);
    eax = *((ebx + 0x24));
    eax = *((ebp - 0x1c));
    eax += *((ebx + 0xc));
    caml_modify (eax, eax);
    goto label_0;
label_2:
    if (*(obj.caml_parser_trace) != 0) {
        eax = *((ebp - 0x1c));
        *((esp + 0xc)) = eax;
        edx = *((ebp - 0x20));
        *((esp + 8)) = edx;
        eax = stderr;
        fprintf (eax, "State %d: reduce by rule %d\n");
    }
    eax = *((ebp - 0x1c));
    eax += eax;
    edx = *((esi + 0x10));
    edx = *((edx + eax));
    ecx = edi + edi + 1;
    *((ebx + 0x28)) = ecx;
    ecx = eax + 1;
    *((ebx + 0x30)) = ecx;
    ecx = edx + edx + 1;
    *((ebx + 0x2c)) = ecx;
    edi++;
    edi -= edx;
    edx = *(ebx);
    edx = *((edx + edi*4 - 4));
    edx >>= 1;
    *((ebp - 0x20)) = edx;
    edx = *((esi + 0xc));
    edx = *((edx + eax));
    edx += edx;
    eax = *((esi + 0x24));
    eax = *((eax + edx));
    ecx = *((ebp - 0x20));
    ecx += eax;
    if (eax != 0) {
        if (ecx >= 0) {
            eax = *((esi + 0x28));
            eax >>= 1;
            if (ecx > eax) {
                goto label_12;
            }
            ecx += ecx;
            eax = *((esi + 0x30));
            eax = *((eax + ecx));
            if (eax != *((ebp - 0x20))) {
                goto label_12;
            }
            eax = *((esi + 0x2c));
            eax = *((eax + ecx));
        }
    } else {
label_12:
        eax = *((esi + 0x18));
        eax = *((eax + edx));
    }
    edx = *((ebx + 0x10));
    edx >>= 1;
    if (edi >= edx) {
        edx = edi + edi + 1;
        *((ebx + 0x34)) = edx;
        eax = eax + eax + 1;
        *((ebx + 0x38)) = eax;
        ecx = *((ebp - 0x24));
        eax = ecx + ecx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 7;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        edx = *((ebx + 0x3c));
        edx >>= 1;
        *((ebp - 0x24)) = edx;
    }
    edx = edi + edi + 1;
    *((ebx + 0x34)) = edx;
    eax = eax + eax + 1;
    *((ebx + 0x38)) = eax;
    edx = *((ebp - 0x24));
    eax = edx + edx + 1;
    *((ebx + 0x3c)) = eax;
    eax = 9;
    goto label_3;
    edi = *((ebx + 0x34));
    edi >>= 1;
    eax = *((ebx + 0x38));
    eax >>= 1;
    *((ebp - 0x20)) = eax;
    eax = *((ebx + 0x3c));
    eax >>= 1;
    *((ebp - 0x24)) = eax;
    ecx = edi*4;
    *((ebp - 0x28)) = ecx;
    edx = *(ebx);
    ecx = *((ebp - 0x20));
    eax = ecx + ecx + 1;
    ecx = *((ebp - 0x28));
    *((ecx + edx)) = eax;
    eax = *((ebp + 0x14));
    eax = ecx;
    eax += *((ebx + 4));
    caml_modify (eax, eax);
    eax = *((ebx + 0x28));
    eax >>= 1;
    *((ebp - 0x1c)) = eax;
    eax <<= 2;
    *((ebp - 0x2c)) = eax;
    eax = *((ebx + 0xc));
    ecx = *((ebp - 0x2c));
    edx = *((ecx + eax));
    eax += *((ebp - 0x28));
    caml_modify (eax, edx);
    if (edi <= *((ebp - 0x1c))) {
        goto label_0;
    }
    eax = *((ebx + 0xc));
    edx = *((ebp - 0x2c));
    eax = *((edx + eax));
    eax = *((ebp - 0x28));
    eax += *((ebx + 8));
    caml_modify (eax, eax);
    goto label_0;
label_1:
    eax = 3;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a614 */
#include <stdint.h>
 
void fputc (void) {
    fputc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a534 */
#include <stdint.h>
 
void fwrite (void) {
    fwrite ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fc05 */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_8 (void) {
    int32_t var_8h;
    int32_t var_bp_4h;
    int32_t var_4h;
    eax = ebp - 8;
    caml_deserialize_block_8 (eax, 1);
    eax = *((ebp - 8));
    edx = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806be1f */
#include <stdint.h>
 
int32_t caml_int64_of_float (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_ah;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0xa));
    ah = 0xc;
    *((ebp - 0xc)) = ax;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_int64 ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ba71 */
#include <stdint.h>
 
int32_t caml_nativeint_shift_right (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ecb0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1739 (void) {
    ecx = eax;
    eax = *((ebx + 8));
    ebx = ecx;
    eax = camlCamlinternalOO_get_method_label_1188 (ebx);
    ebx = eax;
    eax = *(esp);
    eax = *((eax + 8));
    return camlCamlinternalOO_get_method_1199 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cec6 */
#include <stdint.h>
 
int32_t caml_string_greaterequal (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax > 0) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806342b */
#include <stdint.h>
 
int32_t unix_getservbyname (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x154d5;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getservbyname ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_service_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a884 */
#include <stdint.h>
 
void getservbyname (void) {
    getservbyname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050290 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1485 (void) {
    eax = caml_ml_seek_out_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f7d0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1396 (void) {
    eax = caml_ml_channel_size;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806d7d3 */
#include <stdint.h>
 
int32_t caml_channel_descriptor (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    ebx = *(eax);
    if (ebx == -1) {
        errno_location ();
        *(eax) = 9;
        caml_sys_error (1);
    }
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bf50 */
#include <stdint.h>
 
int32_t camlUnix_fun_2582 (void) {
    eax = unix_getprotobyname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067023 */
#include <stdint.h>
 
int32_t caml_raise_constant (void) {
    int32_t var_4ch_2;
    int32_t var_48h_3;
    int32_t var_44h_3;
    int32_t var_40h_3;
    int32_t var_2ch_2;
    int32_t var_28h_3;
    int32_t var_24h_3;
    int32_t var_20h_3;
    int32_t var_1ch_3;
    int32_t var_4h_7;
    int32_t var_4h_6;
    eax = caml_local_roots;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x2c)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    eax = caml_alloc_small (1, 0);
    *((ebp - 0x2c)) = eax;
    edx = *((ebp + 8));
    *(eax) = edx;
    eax = *((ebp - 0x2c));
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d590 */
#include <stdint.h>
 
void camlPrintf_fun_1710 (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bf70 */
#include <stdint.h>
 
int32_t camlUnix_fun_2586 (void) {
    eax = unix_gethostbyname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805c810 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1575 (void) {
    int32_t var_4h_3;
    int32_t var_8h_3;
    *((esp + 8)) = eax;
    *((esp + 4)) = ebx;
    *(esp) = ecx;
    eax = caml_make_vect;
    eax = caml_c_call (5);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 8));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b5d0)() ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fd60 */
#include <stdint.h>
 
int32_t caml_deserialize_block_1 (void * s1, int32_t arg_ch) {
    void * s2;
    size_t * n;
    ebx = *((ebp + 0xc));
    eax = intern_src;
    eax = *((ebp + 8));
    memmove (eax, eax, ebx);
    *(obj.intern_src) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050270 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1489 (void) {
    eax = caml_ml_channel_size_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c1b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2652 (void) {
    eax = unix_mktime;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c274 */
#include <stdint.h>
 
int32_t caml_int32_and (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax &= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bac7 */
#include <stdint.h>
 
int32_t caml_nativeint_or (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax |= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066e1d */
#include <stdint.h>
 
void caml_array_bound_error (void) {
    int32_t var_4h_9;
    int32_t var_sp_8h;
    if (*(obj.array_bound_error_bucket_inited) == 0) {
        *(obj.array_bound_error_msg) = 0x14fc;
        *(0x8084647) = 0;
        *(obj.array_bound_error_bucket) = 0x800;
        *(0x808490c) = 0x8078c68;
        *(0x8084910) = 0x8084634;
        *(obj.array_bound_error_bucket_inited) = 1;
        caml_page_table_add (4, 0x8084630, 0x808464c);
        *(obj.array_bound_error_bucket_inited) = 1;
    }
    return caml_raise (0x808490c);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806fa19 */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_4 (void) {
    ecx = intern_src;
    edx = ecx + 4;
    *(obj.intern_src) = edx;
    ebx = *((edx - 1));
    eax = *(ecx);
    eax <<= 0x18;
    eax = ebx + eax;
    ecx = *((edx - 3));
    ecx <<= 0x10;
    eax += ecx;
    edx = *((edx - 2));
    edx <<= 8;
    eax += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050050 */
#include <stdint.h>
 
uint32_t camlPervasives_print_int_1270 (void) {
    eax = camlPervasives_string_of_int_1130 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806591e */
#include <stdint.h>
 
uint32_t unix_stat_64 (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x12fdd;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = xstat64 ();
    if (eax == -1) {
        eax = ebx - 0x2365;
        uerror (eax, esi);
    }
    edx = ebp - 0x68;
    eax = 1;
    stat_aux ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d550 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1697 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064b44 */
#include <stdint.h>
 
uint32_t unix_setgroups (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x13dba;
    esi = *((ebp + 8));
    edi = *((esi - 4));
    edi >>= 0xa;
    eax = edi*4;
    eax = caml_stat_alloc (eax);
    *((ebp - 0x1c)) = eax;
    if (edi == 0) {
        goto label_0;
    }
    edx = 0;
    do {
        ecx = *((esi + edx*4));
        ecx >>= 1;
        *((eax + edx*4)) = ecx;
        edx++;
    } while (edi > edx);
label_0:
    eax = *((ebp - 0x1c));
    *((esp + 4)) = eax;
    *(esp) = edi;
    eax = setgroups ();
    esi = eax;
    eax = *((ebp - 0x1c));
    caml_stat_free (eax);
    if (esi == -1) {
        eax = ebx - 0x246c;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cb29 */
#include <stdint.h>
 
int32_t caml_neg_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    fp_stack[0] = -fp_stack[0];
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e571 */
#include <stdint.h>
 
uint32_t caml_ml_flush_partial (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    if (*(ebx) == -1) {
        *(obj.caml_local_roots) = esi;
        eax = 3;
    } else {
        eax = caml_channel_mutex_lock;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        eax = caml_flush_partial (ebx);
        edi = eax;
        eax = caml_channel_mutex_unlock;
        if (eax != 0) {
            eax = void (*eax)(uint32_t) (ebx);
        }
        eax -= eax;
        eax &= 0xfffffffe;
        *(obj.caml_local_roots) = esi;
        eax = eax + 3;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d6a0 */
#include <stdint.h>
 
void camlPrintf_bad_conversion_format_1061 (void) {
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ecx = ebx + ebx + 1;
    ebx = 1;
    camlString_sub_1046 (ebx, ecx);
    ebx = *(esp);
    ecx = *((esp + 4));
    return camlPrintf_bad_conversion_1057 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805dd80 */
#include <stdint.h>
 
uint32_t camlPrintf_count_arguments_of_format_1198 (void) {
    eax = camlPrintf_ac_of_format_1184 ();
    eax = *(eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8062046 */
#include <stdint.h>
 
int32_t unix_execvp (void) {
    int32_t var_ch_5;
    int32_t var_8h_5;
    int32_t var_4h_4;
    int32_t var_8h_6;
    int32_t var_ch_6;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x168b2;
    edi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    esi = eax;
    *((esp + 4)) = eax;
    *(esp) = edi;
    execvp ();
    caml_stat_free (esi);
    eax = ebx - 0x25ff;
    return uerror (eax, edi);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c470 */
#include <stdint.h>
 
int32_t camlUnix_fun_2732 (void) {
    eax = unix_fstat;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c1d0 */
#include <stdint.h>
 
int32_t caml_int32_of_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ff00 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_add_initializer_1264 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x800;
            *(edx) = ebx;
            eax = *((ecx + 0x1c));
            *((edx + 4)) = eax;
            ecx += 0x1c;
            caml_modify (ecx, edx);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071176 */
#include <stdint.h>
 
uint32_t caml_sys_getcwd (void) {
    int32_t var_1008h;
    int32_t var_4h;
    *((esp + 4)) = 0x1000;
    eax = ebp - 0x1008;
    *(esp) = eax;
    eax = getcwd ();
    if (eax == 0) {
        caml_sys_error (1);
    }
    eax = ebp - 0x1008;
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c1d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2656 (void) {
    eax = unix_gmtime;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b7d1 */
#include <stdint.h>
 
uint32_t caml_int64_format (void) {
    char * format;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_4h;
    int32_t var_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = ebp - 0x38;
    eax = ebp - 0x59;
    edi = ebp - 0x58;
    ecx = esi;
    edx = 0x80763fe;
    eax = *((ebp + 8));
    eax = parse_format (edi, eax);
    ebx = eax;
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    *((esp + 8)) = eax;
    sprintf (edx, esi);
    eax = caml_copy_string (ebx);
    esi = eax;
    if (ebx != edi) {
        caml_stat_free (ebx);
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054c20 */
#include <stdint.h>
 
int32_t camlList_memq_1165 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 4));
        ecx = *(ebx);
        if (ecx == eax) {
            eax = 3;
            return eax;
        }
        ebx = edx;
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ebc0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1722 (void) {
    int32_t var_4h;
    eax = *(eax);
    ebx = *((ecx + 0xc));
    eax = camlList_mem_1161 (eax, ebx);
    if (eax == 1) {
        goto label_0;
    }
    eax = *((esp + 4));
    return eax;
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b390 */
#include <stdint.h>
 
int32_t camlPrintf_loop_1159 (void) {
    do {
        ecx = *((ebx + 0x10));
        ecx += 0xfffffffc;
        if (eax >= ecx) {
            goto label_0;
        }
        *(esp) = ebx;
        ecx = *((ebx + 0xc));
        edx = *((ebx + 8));
        ebx = eax;
        ebx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ebx) {
            goto label_1;
        }
        ebx = *((edx + ebx));
        ebx = ebx + ebx + 1;
        caml_apply2 ();
        ebx = *(esp);
    } while (1);
label_0:
    eax = 1;
    return eax;
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c8a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2800 (void) {
    eax = unix_stat_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806bec6 */
#include <stdint.h>
 
int32_t caml_int64_shift_left (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    __asm ("shld edx, eax, cl");
    eax <<= cl;
    if ((cl & 0x20) != 0) {
        edx = eax;
        eax = 0;
    }
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e460 */
#include <stdint.h>
 
int32_t camlPrintf_ifprintf_1389 (void) {
    ebx = .comment;
    eax = loc.camlPrintf__44;
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804e390 */
#include <stdint.h>
 
int32_t camlUnix_shutdown_connection_2022 (void) {
    eax = caml_channel_descriptor;
    eax = caml_c_call (eax);
    eax = unix_shutdown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c80a */
#include <stdint.h>
 
int32_t caml_power_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    pow (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a024 */
#include <stdint.h>
 
void pow (void) {
    pow ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c8c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2796 (void) {
    eax = unix_truncate_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80507e0 */
#include <stdint.h>
 
int32_t loc_camlArray_code_begin (void) {
    int32_t var_4h_4;
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
label_0:
        eax = ebx;
        ecx = *((edi + 0xc));
        ebx = edx;
        eax = caml_apply2 (eax, eax, ecx);
        if (eax > 1) {
            goto label_2;
        }
        edi = *(esp);
        eax = *((edi + 0x18));
        ebx = *((eax - 4));
        ecx = *((eax - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            ebx >>= 9;
            esi = *((esp + 0x10));
            if (ebx <= esi) {
                goto label_3;
            }
            ebx = *((esp + 0x14));
            caml_modify (eax + esi*2 - 2, ebx);
        } else {
            ebx >>= 0xa;
            esi = *((esp + 0x10));
            if (ebx <= esi) {
                goto label_4;
            }
            ebx = *((esp + 0x14));
            *(fp_stack--) = *(ebx);
            *((eax + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((esp + 4));
        ecx += 2;
        eax = *((edi + 0x1c));
        if (ecx >= eax) {
            goto label_5;
        }
        ebx = *((edi + 0x10));
        edx = *((ebx - 4));
        eax = *((ebx - 4));
        eax &= 0xff;
        if (eax != 0xfe) {
            eax = edx;
            eax >>= 9;
            if (eax <= ecx) {
                goto label_6;
            }
            ebx = *((ebx + ecx*2 - 2));
        } else {
            eax = edx;
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_7;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_8;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
            ebx = edx;
        }
        esi += 2;
        eax = ecx;
        ecx = *((esp + 8));
        edx = *((esp + 0xc));
    } while (1);
label_5:
    ebp = *((edi + 0x20));
    ebx = *((esp + 8));
    ebp -= ebx;
    ebp++;
    esi += 2;
    ecx = *((edi + 0x18));
    eax = *((edi + 0x14));
    edx = esi;
    esi = ebp;
    void (*0x8052520)() ();
label_2:
    edi = *(esp);
    eax = *((edi + 0x18));
    ebx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        ebx >>= 9;
        esi = *((esp + 0x10));
        if (ebx <= esi) {
            goto label_9;
        }
        ebx = *((esp + 0xc));
        caml_modify (eax + esi*2 - 2, ebx);
    } else {
        ebx >>= 0xa;
        esi = *((esp + 0x10));
        if (ebx <= esi) {
            goto label_10;
        }
        ebx = *((esp + 0xc));
        *(fp_stack--) = *(ebx);
        *((eax + esi*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    ecx = *((esp + 8));
    ecx += 2;
    eax = *((edi + 0x20));
    if (ecx >= eax) {
        goto label_11;
    }
    ebx = *((edi + 0x14));
    edx = *((ebx - 4));
    eax = *((ebx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = edx;
        eax >>= 9;
        if (eax <= ecx) {
            goto label_12;
        }
        edx = *((ebx + ecx*2 - 2));
        goto label_13;
    }
    eax = edx;
    eax >>= 0xa;
    if (eax <= ecx) {
        goto label_14;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
label_13:
            esi += 2;
            eax = *((esp + 4));
            ebx = *((esp + 0x14));
            goto label_0;
label_11:
            ebp = *((edi + 0x1c));
            ebx = *((esp + 4));
            ebp -= ebx;
            ebp++;
            esi += 2;
            ecx = *((edi + 0x18));
            eax = *((edi + 0x10));
            edx = esi;
            esi = ebp;
            void (*0x8052520)() ();
        }
        caml_call_gc ();
    } while (1);
label_8:
    caml_call_gc ();
    goto label_1;
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ca8d */
#include <stdint.h>
 
int32_t caml_exp_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    exp (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a144 */
#include <stdint.h>
 
void exp (void) {
    exp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c380 */
#include <stdint.h>
 
int32_t caml_int_of_float (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_2h;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 2));
    ah = 0xc;
    *((ebp - 4)) = ax;
    *((ebp - 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 8));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804abb0 */
#include <stdint.h>
 
int32_t caml_curry9_4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_5;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805cb20 */
#include <stdint.h>
 
uint32_t camlPrintf_scan_conv_1293 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
label_0:
    edi = ecx;
    ebp >>= 1;
    ecx = *((esi + 0xc));
    ecx = *((ecx + ebp));
    ecx = ecx + ecx + 1;
    if (ecx >= 0xf9) {
        void (*0x805cd70)() ();
    }
    edi = ecx;
    edi >>= 1;
    /* switch table (195 cases) at 0x8081400 */
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx, edi);
    *((esp + 4)) = eax;
    esi = *((esp + 8));
    if (esi == 1) {
        eax = camlPervasives_string_of_float_1140 ();
        *(esp) = eax;
    } else {
        eax = *((esp + 0x18));
        ecx = *((eax + 0x10));
        ebx = *((eax + 0xc));
        eax = *(esp);
        edx = *((esp + 0xc));
        camlPrintf_extract_format_float_1110 ();
        ebx = *((esp + 4));
        eax = camlPrintf_fun_1600 ();
        *(esp) = eax;
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b580)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    *(esp) = eax;
    eax = .comment;
    ebx = *((eax + 8));
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *(eax);
    } else {
        eax = *((esp + 0x14));
    }
    ecx = *(ebx);
    eax = void (*ecx)() ();
    ebx = eax;
    eax = *((esp + 0x18));
    ecx = *((eax + 0x28));
    eax = 1;
    eax = camlPrintf_get_arg_1288 (ebx);
    *((esp + 4)) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 8));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 8));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    esi = *((ebx + 0x18));
    edx = *((esp + 0xc));
    edx += 2;
    ebx = *(esp);
    ecx = *((esp + 4));
    void (*0x804b520)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x1c));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b580)() ();
    ecx = *((esi + 0x28));
    camlPrintf_get_arg_1288 ();
    ebx = *(esp);
    if (ebx == 0xe7) {
    } else {
        camlString_escaped_1080 ();
        ebx = loc.camlPrintf__58;
        eax = camlPervasives_$5e_1112 ();
        ebx = eax;
        eax = loc.camlPrintf__57;
        eax = camlPervasives_$5e_1112 ();
    }
    edx = *((esp + 0x18));
    ebx = *((edx + 0x10));
    ebx += 2;
    ecx = *((esp + 0xc));
    if (ecx == ebx) {
        *(esp) = eax;
    } else {
        ebx = *((edx + 0x10));
        eax = *((edx + 0xc));
        edx = *((esp + 8));
        camlPrintf_extract_format_1085 (eax);
        ebx = *(esp);
        eax = camlPrintf_format_string_1080 ();
        *(esp) = eax;
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b580)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx);
    eax = *((esp + 0x18));
    ecx = *((eax + 0x10));
    ebx = *((eax + 0xc));
    eax = *(esp);
    edx = *((esp + 0xc));
    esi = *((esp + 8));
    eax = camlPrintf_extract_format_int_1103 (eax);
    ebx = *((esp + 4));
    eax = caml_format_int;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b580)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    eax = *((esp + 0x18));
    ebx = *((eax + 0x10));
    eax = *((eax + 0xc));
    ecx = *((esp + 0xc));
    edx = *((esp + 8));
    eax = camlPrintf_extract_format_1085 (eax);
    ebx = *(esp);
    eax = caml_format_float;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b580)() ();
    ebp += 2;
    ebp >>= 1;
    edi = *((esi + 0xc));
    edi = *((edi + ebp));
    edi = edi + edi + 1;
    edi += 0xffffff50;
    if (edi <= 0x41) {
        edi >>= 1;
        /* switch table (66 cases) at 0x80815f0 */
    }
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    eax = *((esp + 0x18));
    ecx = *((eax + 0x10));
    ebx = *((eax + 0xc));
    eax = 0xdd;
    edx = *((esp + 0xc));
    esi = *((esp + 8));
    eax = camlPrintf_extract_format_int_1103 (eax);
    ebx = *(esp);
    eax = caml_format_int;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b580)() ();
    edx += 2;
    *((esp + 4)) = edx;
    ecx += 0xffffff28;
    if (ecx <= 5) {
        ecx >>= 1;
        if (ecx != 1) {
            if (ecx <= 1) {
                ecx = *((esi + 0x28));
                eax = camlPrintf_get_arg_1288 ();
                eax = *((esp + 0x18));
                ebx = *((eax + 0x10));
                eax = *((eax + 0xc));
                ecx = *((esp + 4));
                edx = *((esp + 8));
                eax = camlPrintf_extract_format_1085 (eax);
                ebx = *(esp);
                eax = caml_int32_format;
                eax = caml_c_call (eax);
                *(esp) = eax;
                goto label_6;
            }
            ecx = *((esi + 0x28));
            eax = camlPrintf_get_arg_1288 ();
            eax = *((esp + 0x18));
            ebx = *((eax + 0x10));
            eax = *((eax + 0xc));
            ecx = *((esp + 4));
            edx = *((esp + 8));
            eax = camlPrintf_extract_format_1085 (eax);
            ebx = *(esp);
            eax = caml_nativeint_format;
            eax = caml_c_call (eax);
            *(esp) = eax;
        }
    } else {
        ecx = *((esi + 0x28));
        eax = camlPrintf_get_arg_1288 ();
        eax = *((esp + 0x18));
        ebx = *((eax + 0x10));
        eax = *((eax + 0xc));
        ecx = *((esp + 4));
        edx = *((esp + 8));
        eax = camlPrintf_extract_format_1085 (eax);
        ebx = *(esp);
        eax = caml_int64_format;
        eax = caml_c_call (eax);
        *(esp) = eax;
    }
label_6:
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 4));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b580)() ();
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x20f7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x805b490;
            eax = *((esi + 0x38));
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = esi;
            *((ebx + 0x14)) = edi;
            *((ebx + 0x18)) = ebp;
            *((ebx + 0x1c)) = ecx;
            edx += 2;
            eax = *((esi + 0x1c));
            ecx = ebp;
            void (*0x805e0b0)() ();
            esi += 0x10;
            eax = edi;
            ebx = ebp;
            goto label_0;
            edx += 2;
            eax = edi;
            ebx = ebp;
            void (*0x805d2c0)() ();
        }
        caml_call_gc ();
    } while (1);
    ebx = loc.camlPrintf__45;
    eax = *((esp + 4));
    ecx = *(esp);
    void (*0x804b5d0)() ();
label_5:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_7;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.camlPrintf__fun_1572;
    *((eax + 4)) = 3;
    ebx = *(esp);
    *((eax + 8)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0xc)) = ebx;
    return eax;
label_4:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_8;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x805c810;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
label_3:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_9;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry3;
    *((eax + 4)) = 7;
    *((eax + 8)) = 0x805c6d0;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
label_2:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_10;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry4;
    *((eax + 4)) = 9;
    *((eax + 8)) = 0x805c530;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
label_1:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_11;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry5;
    *((eax + 4)) = 0xb;
    *((eax + 8)) = 0x805c330;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.caml_curry6;
            *((eax + 4)) = 0xd;
            *((eax + 8)) = 0x805c0d0;
            ebx = *(esp);
            *((eax + 0xc)) = ebx;
            ebx = *((esp + 4));
            *((eax + 0x10)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_11:
    caml_call_gc ();
    goto label_1;
label_10:
    caml_call_gc ();
    goto label_2;
label_9:
    caml_call_gc ();
    goto label_3;
label_8:
    caml_call_gc ();
    goto label_4;
label_7:
    caml_call_gc ();
    goto label_5;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060770 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_get_meth_1375 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xcf7;
            *(eax) = sym.camlCamlinternalOO__fun_1778;
            *((eax + 4)) = 3;
            *((eax + 8)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c981 */
#include <stdint.h>
 
uint32_t caml_frexp_float (int32_t arg_8h) {
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_8h;
    ebx = caml_local_roots;
    *((ebp - 0x28)) = ebx;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x30)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x50)) = eax;
    eax = ebp - 0x50;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x48)) = 1;
    *((ebp - 0x4c)) = 2;
    eax = ebp - 0x2c;
    *((ebp - 0x44)) = eax;
    eax = ebp - 0x30;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x54;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    frexp (ebx, eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x30)) = eax;
    eax = caml_alloc_tuple (2);
    *((ebp - 0x2c)) = eax;
    edx = *((ebp - 0x30));
    *(eax) = edx;
    eax = *((ebp - 0x54));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 4)) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a554 */
#include <stdint.h>
 
void frexp (void) {
    frexp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ef30 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_fun_1822 (void) {
    edi = ebx;
    ecx = *((edi + 8));
    esi = *((edi + 0x14));
    edx = *((edi + 0x10));
    eax = *((eax + edx*2 - 2));
    ebx = *((eax + esi*2 - 2));
    eax = *((edi + 0xc));
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80563a0 */
#include <stdint.h>
 
void camlString_compare_1145 (void) {
    caml_string_compare (eax, ebx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c490 */
#include <stdint.h>
 
int32_t camlUnix_fun_2736 (void) {
    eax = unix_stat;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c6a5 */
#include <stdint.h>
 
int32_t caml_expm1_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_expm1 ();
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b3df */
#include <stdint.h>
 
int32_t caml_nativeint_compare (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    cl = (edx > eax) ? 1 : 0;
    ecx = (int32_t) cl;
    dl = (edx < eax) ? 1 : 0;
    edx = (int32_t) dl;
    eax = ecx;
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80573a0 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_1217 (void) {
    int32_t var_4h_3;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_18h_2;
    int32_t var_18h;
    int32_t var_24h;
    esi = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.camlHashtbl__replace_bucket_1221;
    *((eax + 4)) = 3;
    edi = *((edx + 0xc));
    *((eax + 8)) = edi;
    *((eax + 0xc)) = ebx;
    *((eax + 0x10)) = ecx;
    edi = *((esi + 4));
    edi = *((edi - 4));
    edi >>= 0xa;
    if (edi != 0) {
        eax = *((edx + 0x10));
        eax = *((eax + 8));
        ebx = *((eax + 4));
        ecx = *(ebx);
        eax = *((esp + 0x1c));
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (eax, ecx, edi);
        ebx = 0x7fffffff;
        eax &= ebx;
        eax >>= 1;
        ecx = *((esp + 8));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    *((esp + 0x18)) = edx;
    ebx = *(esp);
    ecx = *((ebx + 4));
    eax = *((ecx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    eax = *((ecx + edx*2 - 2));
    eax = void (*0x8057520)(uint32_t) (eax);
    ecx = loc.caml_exn_Not_found;
    ebx = *(eax);
    if (ebx != ecx) {
        goto label_3;
    }
    ebx = *(esp);
    edx = *((ebx + 4));
    eax = *((edx - 4));
    eax >>= 9;
    ecx = *((esp + 0x18));
    if (eax <= ecx) {
        goto label_4;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0xc00;
            eax = *((esp + 0x1c));
            *(esi) = eax;
            eax = *((esp + 4));
            *((esi + 4)) = eax;
            eax = *((esp + 8));
            *((esi + 8)) = eax;
            caml_modify (edx + ecx*2 - 2, esi);
            *(ebx) += 2;
            eax = *((ebx + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ecx = eax + eax - 1;
            eax = *(ebx);
            if (eax > ecx) {
                eax = *((esp + 0xc));
                eax = *((eax + 0x10));
                void (*0x80577a0)() ();
            }
            eax = 1;
            return eax;
label_3:
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            ebx = *((ebx + 4));
            *((esp + 0x1c)) = ebx;
            ebx = *((ebx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_5;
            }
            ebx = *((esp + 0x18));
            eax = camlHashtbl_replace_bucket_1221 ();
            ebx = *((esp + 0x20));
            eax = *((esp + 0x24));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804ffe0 */
#include <stdint.h>
 
int32_t camlPervasives_close_in_noerr_1263 (void) {
    fcn_0804fff0 ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fff0 */
#include <stdint.h>
 
int32_t fcn_0804fff0 (void) {
    *(obj.caml_exception_pointer) = esp;
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054dc0 */
#include <stdint.h>
 
int32_t camlList_mem_assq_1184 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 4));
        ecx = *(ebx);
        ecx = *(ecx);
        if (ecx == eax) {
            eax = 3;
            return eax;
        }
        ebx = edx;
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061ed0 */
#include <stdint.h>
 
int32_t unix_error_message (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16a30;
    eax = *((ebp + 8));
    if ((al & 1) == 0) {
        eax = *(eax);
        eax >>= 1;
    } else {
        eax >>= 1;
        edx = *((ebx - 8));
        eax = *((edx + eax*4));
    }
    eax = strerror (eax);
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ba01 */
#include <stdint.h>
 
int32_t caml_nativeint_of_int32 (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052bd0 */
#include <stdint.h>
 
int32_t camlArray_to_list_1121 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8050c60;
            *((ecx + 0xc)) = ebx;
            eax = *((ebx - 4));
            ebx = *((ebx - 4));
            ebx &= 0xff;
            if (ebx != 0xfe) {
                eax >>= 9;
            } else {
                eax >>= 0xa;
            }
            eax |= 1;
            eax += 0xfffffffe;
            ebx = 1;
            void (*0x8050c60)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052ee0 */
#include <stdint.h>
 
int32_t camlArray_sort_1152 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch_2;
    int32_t var_10h;
    int32_t var_14h;
    ecx = eax;
    *((esp + 0x10)) = ebx;
label_4:
    eax = caml_young_ptr;
    eax -= 0x90;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x14f7;
    *(esi) = sym.caml_curry2;
    *((esi + 4)) = 5;
    *((esi + 8)) = 0x8050d50;
    *((esi + 0xc)) = ecx;
    *((esi + 0x10)) = ebx;
    edx = esi + 0x18;
    *((edx - 4)) = 0x18f7;
    *(edx) = sym.caml_curry3;
    *((edx + 4)) = 7;
    *((edx + 8)) = 0x8051140;
    *((edx + 0xc)) = ecx;
    *((edx + 0x10)) = ebx;
    *((edx + 0x14)) = esi;
    eax = esi + 0x34;
    *((esp + 4)) = eax;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry3;
    *((eax + 4)) = 7;
    *((eax + 8)) = 0x8051350;
    *((eax + 0xc)) = ebx;
    *((eax + 0x10)) = edx;
    edx = esi + 0x4c;
    *((edx - 4)) = 0x14f7;
    *(edx) = sym.caml_curry2;
    *((edx + 4)) = 5;
    *((edx + 8)) = 0x8051410;
    *((edx + 0xc)) = ebx;
    *((edx + 0x10)) = esi;
    eax = esi + 0x64;
    *(esp) = eax;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x8051510;
    *((eax + 0xc)) = edx;
    eax = esi + 0x78;
    *((esp + 8)) = eax;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x8051560;
    *((eax + 0xc)) = ecx;
    *((eax + 0x10)) = ebx;
    eax = *((ebx - 4));
    ebx = *((ebx - 4));
    ebx &= 0xff;
    if (ebx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    *((esp + 0x14)) = eax;
    ecx = 3;
    eax += 2;
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    ebx = eax + eax - 1;
    if (ebx < 1) {
        goto label_6;
    }
    *((esp + 0xc)) = ebx;
    do {
        edx = *((esp + 0x10));
        eax = *((edx - 4));
        ecx = *((edx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= ebx) {
                goto label_7;
            }
            ecx = *((edx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_8;
            }
label_3:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_9;
            }
            ecx = eax + 4;
            *((ecx - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ebx*4 - 4));
            *(ecx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 0x14));
        edx = *((esp + 4));
        camlArray_trickle_1165 ();
        ebx = *((esp + 0xc));
        eax = *((esp + 0xc));
        ebx -= 2;
        *((esp + 0xc)) = ebx;
    } while (eax != 1);
label_6:
    esi = *((esp + 0x14));
    esi += 0xfffffffe;
    if (esi < 5) {
        goto label_10;
    }
    *((esp + 0xc)) = esi;
    do {
        ebx = *((esp + 0x10));
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= esi) {
                goto label_11;
            }
            eax = *((ebx + esi*2 - 2));
            *((esp + 4)) = eax;
        } else {
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_12;
            }
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_13;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + esi*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            *((esp + 4)) = eax;
        }
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= 1) {
                goto label_14;
            }
            edx = *(ebx);
        } else {
            eax >>= 0xa;
            if (eax <= 1) {
                goto label_15;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_16;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= esi) {
                goto label_17;
            }
            eax = caml_modify (ebx + esi*2 - 2, edx);
        } else {
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_18;
            }
            *(fp_stack--) = *(edx);
            *((ebx + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ebx = 1;
        eax = esi;
        ecx = *(esp);
        camlArray_bubble_1174 ();
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        camlArray_trickleup_1178 ();
        esi = *((esp + 0xc));
        eax = *((esp + 0xc));
        esi -= 2;
        *((esp + 0xc)) = esi;
    } while (eax != 5);
label_10:
    eax = *((esp + 0x14));
    if (eax <= 3) {
        goto label_19;
    }
    ebx = *((esp + 0x10));
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_20;
        }
        esi = *((ebx + 4));
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_21;
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_22;
        }
        esi = eax + 4;
        *((esi - 4)) = 0x8fd;
        *(fp_stack--) = *((ebx + 8));
        *(esi) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_23;
        }
        edx = *(ebx);
        goto label_24;
    }
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_25;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(edx) = fp_stack[0];
            fp_stack--;
label_24:
            eax = *((ebx - 4));
            ecx = *((ebx - 4));
            ecx &= 0xff;
            if (ecx != 0xfe) {
                eax >>= 9;
                if (eax <= 3) {
                    goto label_26;
                }
                eax = ebx;
                eax += 4;
                eax = caml_modify (eax, edx);
            } else {
                eax >>= 0xa;
                if (eax <= 3) {
                    goto label_27;
                }
                *(fp_stack--) = *(edx);
                *((ebx + 8)) = fp_stack[0];
                fp_stack--;
            }
            eax = *((ebx - 4));
            ecx = *((ebx - 4));
            ecx &= 0xff;
            if (ecx != 0xfe) {
                eax >>= 9;
                if (eax <= 1) {
                    goto label_28;
                }
                eax = caml_modify (ebx, esi);
            } else {
                eax >>= 0xa;
                if (eax <= 1) {
                    goto label_29;
                }
                *(fp_stack--) = *(esi);
                *(ebx) = fp_stack[0];
                fp_stack--;
            }
            eax = 1;
            return eax;
label_19:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_22:
    caml_call_gc ();
    goto label_0;
label_16:
    caml_call_gc ();
    goto label_1;
label_13:
    caml_call_gc ();
    goto label_2;
label_9:
    caml_call_gc ();
    goto label_3;
label_5:
    caml_call_gc ();
    goto label_4;
label_29:
    caml_ml_array_bound_error ();
label_28:
    caml_ml_array_bound_error ();
label_27:
    caml_ml_array_bound_error ();
label_26:
    caml_ml_array_bound_error ();
label_25:
    caml_ml_array_bound_error ();
label_23:
    caml_ml_array_bound_error ();
label_21:
    caml_ml_array_bound_error ();
label_20:
    caml_ml_array_bound_error ();
label_18:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_7:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c880 */
#include <stdint.h>
 
int32_t camlUnix_fun_2804 (void) {
    eax = unix_fstat_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050120 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_string_1279 (void) {
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8060c10 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_send_var_1458 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlCamlinternalOO__fun_1850;
            *((eax + 4)) = 3;
            *((eax + 8)) = edx;
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805bf70 */
#include <stdint.h>
 
int32_t camlPrintf_add_char_1192 (void) {
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8052c40 */
#include <stdint.h>
 
int32_t camlArray_list_length_1126 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        ebx = *((ebx + 4));
        eax += 2;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063929 */
#include <stdint.h>
 
int32_t unix_setitimer (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_38h;
    int32_t var_28h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14fcf;
    esi = *((ebp + 0xc));
    edi = ebp - 0x28;
    *(fp_stack--) = *(esi);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = edi;
    unix_set_timeval ();
    eax = ebp - 0x20;
    *(fp_stack--) = *((esi + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    unix_set_timeval ();
    eax = ebp - 0x38;
    *((esp + 8)) = eax;
    *((esp + 4)) = edi;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x251c));
    *(esp) = eax;
    eax = setitimer ();
    if (eax == -1) {
        eax = ebx - 0x2527;
        uerror (eax, 0);
    }
    eax = ebp - 0x38;
    unix_convert_itimer ();
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a084 */
#include <stdint.h>
 
void setitimer (void) {
    setitimer ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8056980 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_in_bucket_1230 (void) {
    int32_t var_4h_2;
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 8));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0xc));
        eax = caml_apply2 (ecx, ebx);
        if (eax != 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f850 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1412 (void) {
    eax = caml_ml_channel_size;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070fea */
#include <stdint.h>
 
uint32_t caml_sys_read_directory (void) {
    int32_t var_58h_2;
    int32_t var_50h_2;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_2ch_2;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h_2;
    int32_t var_4h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x2c)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    ebx = ebp - 0x58;
    caml_ext_table_init (ebx, esi);
    eax = *((ebp + 8));
    eax = caml_read_directory (eax, ebx);
    if (eax == -1) {
        caml_ext_table_free (ebx, 1);
        eax = *((ebp + 8));
        caml_sys_error (eax);
    }
    ebx = ebp - 0x58;
    caml_ext_table_add (ebx, 0);
    eax = *((ebp - 0x50));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x2c)) = eax;
    caml_ext_table_free (ebx, 1);
    *(obj.caml_local_roots) = esi;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054d60 */
#include <stdint.h>
 
int32_t camlList_mem_assoc_1179 (void) {
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 4)) = ecx;
        ebx = *(ebx);
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058430 */
#include <stdint.h>
 
int32_t camlMarshal_fun_1066 (void) {
    eax = caml_output_value;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ca20 */
#include <stdint.h>
 
int32_t camlPrintf_valid_float_loop_1273 (void) {
    do {
        ecx = *((ebx + 0xc));
        if (eax >= ecx) {
            ecx = loc.camlPrintf__62;
            eax = *((ebx + 8));
            ebx = ecx;
            void (*0x804f9f0)() ();
        }
        edx = *((ebx + 8));
        ecx = eax;
        ecx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ecx) {
            goto label_0;
        }
        ecx = *((edx + ecx));
        ecx = ecx + ecx + 1;
        ecx += 0xffffffa4;
        if (ecx > 0x2f) {
            if (ecx == 0x6f) {
                goto label_1;
            }
        } else {
            ecx += 0xfffffffe;
            if (ecx > 0x2b) {
                goto label_1;
            }
        }
        eax += 2;
    } while (1);
label_1:
    eax = *((ebx + 8));
    return eax;
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059fa0 */
#include <stdint.h>
 
uint32_t camlMap_bindings_aux_1346 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
label_0:
        if (ebx == 1) {
            goto label_1;
        }
        edx = *((ebx + 0xc));
        ecx = *((ebx + 8));
        ecx = *((ebx + 4));
        ecx = *(ebx);
        ebx = edx;
        eax = camlMap_bindings_aux_1346 (ecx, ecx, ecx);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            eax = *((esp + 4));
            *((ebx + 4)) = eax;
            eax = ebx + 0xc;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            ebx = *((esp + 8));
            goto label_0;
label_1:
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d570 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1700 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806be95 */
#include <stdint.h>
 
int32_t caml_int64_shift_right (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    __asm ("shrd eax, edx, cl");
    edx >>= cl;
    if ((cl & 0x20) != 0) {
        eax = edx;
        edx >>= 0x1f;
    }
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f4d0 */
#include <stdint.h>
 
int32_t camlPervasives_iter_1186 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        ebx = *((eax + 4));
        *(esp) = ebx;
        eax = *(eax);
        fcn_0804f4f0 ();
        eax = *(esp);
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805ee60 */
#include <stdint.h>
 
void camlCamlinternalOO_fun_1798 (void) {
    ecx = *((ebx + 8));
    ecx = *((ebx + 0xc));
    ebx = *(eax);
    ebx = *((ebx + ecx*2 - 2));
    ecx = *(ebx);
    void (*ecx)(uint32_t) (ecx);
    ebx = *(esp);
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f870 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1416 (void) {
    eax = caml_ml_seek_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804e0d0 */
#include <stdint.h>
 
int32_t camlUnix_close_process_out_2006 (void) {
    int32_t var_4h;
    ecx = eax;
    *(esp) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x402;
            *(ebx) = ecx;
            eax = "close_process_out";
            eax = camlUnix_find_proc_id_1997 ();
            eax = *(esp);
            camlPervasives_close_out_1209 (eax);
            eax = *((esp + 4));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8057da0 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_1112 (void) {
    int32_t var_4h_4;
    int32_t var_8h_4;
    int32_t var_ch_4;
    int32_t var_ch_5;
    int32_t var_18h;
    int32_t var_24h;
    edi = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x10f7;
    *(edx) = sym.camlHashtbl__replace_bucket_1116;
    *((edx + 4)) = 3;
    *((edx + 8)) = ebx;
    *((edx + 0xc)) = ecx;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = caml_hash_univ_param (edx, ebx, ecx);
        eax >>= 1;
        ecx = esi;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    *((esp + 0x18)) = edx;
    ebx = *((edi + 4));
    eax = *((ebx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    eax = *((ebx + edx*2 - 2));
    eax = void (*0x8057f00)(uint32_t) (eax);
    ecx = loc.caml_exn_Not_found;
    ebx = *(eax);
    if (ebx != ecx) {
        goto label_3;
    }
    ebx = *(esp);
    edx = *((ebx + 4));
    eax = *((edx - 4));
    eax >>= 9;
    ecx = *((esp + 0x18));
    if (eax <= ecx) {
        goto label_4;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0xc00;
            eax = *((esp + 4));
            *(esi) = eax;
            eax = *((esp + 8));
            *((esi + 4)) = eax;
            eax = *((esp + 0xc));
            *((esi + 8)) = eax;
            caml_modify (edx + ecx*2 - 2, esi);
            *(ebx) += 2;
            eax = *((ebx + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ecx = eax + eax - 1;
            eax = *(ebx);
            if (eax > ecx) {
                eax = .comment;
                void (*0x80577a0)() ();
            }
            eax = 1;
            return eax;
label_3:
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            ebx = *((edi + 4));
            *((esp + 0x1c)) = ebx;
            ebx = *((ebx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_5;
            }
            ebx = *((esp + 0x18));
            eax = camlHashtbl_replace_bucket_1116 ();
            ebx = *((esp + 0x20));
            eax = *((esp + 0x24));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80605f0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_lookup_keys_1353 (void) {
    esi = eax;
    if (esi < 1) {
        eax = ecx;
        return eax;
    }
    eax = *((ebx - 4));
    eax >>= 9;
    if (eax <= esi) {
        goto label_0;
    }
    ebp = *((ebx + esi*2 - 2));
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edi = eax + 4;
            *((edi - 4)) = 0x18f7;
            *(edi) = sym.camlCamlinternalOO__lookup_key_1358;
            *((edi + 4)) = 3;
            *((edi + 8)) = edx;
            *((edi + 0xc)) = esi;
            *((edi + 0x10)) = ebx;
            *((edi + 0x14)) = ebp;
            eax = ecx;
            ebx = edi;
            void (*0x805ed20)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806cbfe */
#include <stdint.h>
 
int32_t caml_float_of_substring (void) {
    uint32_t var_5ch;
    int32_t var_58h_3;
    char * * endptr;
    int32_t var_10h;
    int32_t var_58h_2;
    int32_t var_8h;
    int32_t var_ch;
    esi = *((ebp + 0xc));
    esi >>= 1;
    eax = *((ebp + 8));
    eax = caml_string_length (ebx, esi, edi);
    if (esi >= 0) {
        if (eax > esi) {
            ebx = *((ebp + 0x10));
            ebx >>= 1;
            if (ebx <= 0) {
                goto label_0;
            }
            eax -= esi;
            if (ebx > eax) {
                goto label_0;
            }
            if (ebx <= 0x3f) {
                edi = ebp - 0x58;
                goto label_1;
            }
            eax = ebx + 1;
            eax = caml_stat_alloc (eax);
            edi = eax;
        }
    } else {
label_0:
        ebx = 0;
        edi = ebp - 0x58;
    }
label_1:
    eax = *((ebp + 8));
    eax = esi + eax;
    esi = edi;
    while (ebx != 0) {
        edx = *(eax);
        if (dl != 0x5f) {
            *(esi) = dl;
            esi++;
        }
        eax++;
        ebx--;
    }
    *(esi) = 0;
    if (esi != edi) {
        eax = ebp - 0x5c;
        strtod (edi, eax);
        *((ebp - 0x70)) = fp_stack[0];
        fp_stack--;
        if (*((ebp - 0x5c)) != esi) {
            goto label_2;
        }
        eax = ebp - 0x58;
        if (edi != eax) {
            caml_stat_free (edi);
        }
        *(fp_stack--) = *((ebp - 0x70));
        *(esp) = fp_stack[0];
        fp_stack--;
        caml_copy_double ();
        return eax;
    }
label_2:
    eax = ebp - 0x58;
    if (edi != eax) {
        caml_stat_free (edi);
    }
    return caml_failwith ("float_of_string");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c6df */
#include <stdint.h>
 
int32_t caml_atan2_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    atan2 (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a604 */
#include <stdint.h>
 
void atan2 (void) {
    atan2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c2e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2686 (void) {
    eax = unix_readdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80591a0 */
#include <stdint.h>
 
int32_t camlMap_max_binding_1139 (void) {
    do {
        if (eax == 1) {
            goto label_1;
        }
        edx = *((eax + 0xc));
        ecx = *((eax + 8));
        ebx = *((eax + 4));
        if (edx == 1) {
            goto label_0;
        }
        eax = edx;
    } while (1);
label_0:
    eax = caml_young_ptr;
    eax -= 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x800;
    *(eax) = ebx;
    *((eax + 4)) = ecx;
    return eax;
    do {
label_1:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b7c0 */
#include <stdint.h>
 
int32_t camlPrintf_parse_1069 (void) {
    do {
label_0:
        edx = eax;
        esi = *((ecx + 0xc));
        eax = *((esi - 4));
        eax >>= 0xa;
        eax = eax*4 - 1;
        esi = *((esi + eax));
        eax -= esi;
        eax = eax + eax + 1;
        if (ebx >= eax) {
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = 1;
            *((eax + 4)) = edx;
            return eax;
        }
        esi = ebx;
        esi >>= 1;
        eax = *((ecx + 0xc));
        eax = *((eax + esi));
        eax = eax + eax + 1;
        if (eax >= 0x63) {
            if (eax >= 0x75) {
                goto label_4;
            }
            esi = *((ecx + 0xc));
            eax = *((esi - 4));
            eax >>= 0xa;
            edx = eax*4 - 1;
            eax = *((esi + edx));
            edx -= eax;
            edx <<= 1;
            edx -= ebx;
            edx -= 3;
            edx += 3;
            eax = *((ecx + 0xc));
            ecx = edx;
            eax = camlString_sub_1046 (edx);
            eax = caml_int_of_string;
            eax = caml_c_call (eax);
            ecx = eax;
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            eax = *(esp);
            *((ebx + 4)) = eax;
            eax = ebx;
            return eax;
        }
        if (eax != 0x5b) {
            goto label_4;
        }
        ebx += 2;
        eax = 3;
    } while (1);
label_4:
    ebx += 2;
    eax = edx;
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8061bb0 */
#include <stdint.h>
 
uint32_t unix_chdir (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16d4b;
    esi = *((ebp + 8));
    *(esp) = esi;
    eax = chdir ();
    if (eax == -1) {
        eax = ebx - 0x2639;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b069 */
#include <stdint.h>
 
int32_t caml_lessequal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80882e0) {
        compare_free_stack ();
    }
    dl = (ebx <= 0) ? 1 : 0;
    al = (ebx != 0x80000000) ? 1 : 0;
    eax = (int32_t) al;
    eax &= edx;
    eax += eax;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8070ede */
#include <stdint.h>
 
int32_t caml_sys_close (int32_t fildes) {
    eax = *((ebp + 8));
    eax >>= 1;
    close (eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8059b30 */
#include <stdint.h>
 
int32_t camlMap_merge_1277 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    int32_t var_20h;
    int32_t var_24h;
    do {
label_0:
        if (ebx == 1) {
            goto label_3;
        }
        *(esp) = ecx;
        *((esp + 0x24)) = edx;
        *((esp + 4)) = ebx;
        *((esp + 0x20)) = eax;
        edx = *((ebx + 0x10));
        edi = *((ebx + 0xc));
        esi = *((ebx + 8));
        eax = *((ebx + 4));
        ebx = *(ebx);
        if (ecx != 1) {
            ebp = *((ecx + 0x10));
        } else {
        }
        if (edx < ebp) {
            goto label_4;
        }
        ebx = *((esp + 0x24));
        edx = *((ebx + 0x14));
        ebx = ecx;
        ecx = edx;
        eax = camlMap_split_1264 (ebx, esi);
        ebx = *((eax + 8));
        ebx = *((eax + 4));
        eax = *(eax);
        edx = *((esp + 0x24));
        eax = *((edx + 0x10));
        eax = *((esp + 0x20));
        ebx = *(esp);
        ecx = *((esp + 4));
        eax = camlMap_merge_1277 (ebx, ebx);
    } while (1);
    *((esp + 4)) = eax;
label_2:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x400;
    eax = *((esp + 8));
    *(ebx) = eax;
    eax = *((esp + 0x1c));
    ecx = *((esp + 0xc));
    edx = *((esp + 0x20));
    eax = caml_apply3 ();
    eax = *((esp + 0x20));
    ebx = *((esp + 0x10));
    ecx = *((esp + 0x14));
    edx = *((esp + 0x24));
    eax = camlMap_merge_1277 (eax);
    goto label_0;
    ebx = *(esp);
    if (ebx != 1) {
        ecx = *(ebx);
        ebx = *((esp + 0x18));
        esi = *((ebx + 0xc));
        ebx = *((esp + 0x1c));
        edx = *((esp + 4));
        void (*0x80597a0)() ();
    }
    ebx = *((esp + 0x18));
    ecx = *((ebx + 0x10));
    ebx = *((esp + 4));
    void (*0x80598e0)() ();
label_3:
    if (ecx != 1) {
        *(esp) = ecx;
        *((esp + 0x24)) = edx;
        *((esp + 4)) = ebx;
        *((esp + 0x20)) = eax;
    } else {
        eax = 1;
        return eax;
    }
label_4:
    ebx = *(esp);
    if (ebx == 1) {
        goto label_6;
    }
    eax = *((ebx + 0xc));
    eax = *((ebx + 8));
    eax = *((ebx + 4));
    ebx = *(ebx);
    ebx = *((esp + 0x24));
    ecx = *((ebx + 0x14));
    ebx = *((esp + 4));
    eax = camlMap_split_1264 (eax, eax);
    ebx = *((eax + 8));
    ecx = *((eax + 4));
    eax = *(eax);
    edx = *((esp + 0x24));
    eax = *((edx + 0x10));
    eax = *((esp + 0x20));
    ecx = *(esp);
    eax = camlMap_merge_1277 (eax, ecx);
    goto label_0;
    *((esp + 0x1c)) = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_7;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x400;
    eax = *((esp + 8));
    *(ecx) = eax;
    eax = *((esp + 0x18));
    ebx = *((esp + 4));
    edx = *((esp + 0x20));
    eax = caml_apply3 ();
    eax = *((esp + 0x20));
    ebx = *((esp + 0xc));
    ecx = *((esp + 0x10));
    edx = *((esp + 0x24));
    camlMap_merge_1277 (eax);
    goto label_0;
    ebx = *(esp);
    if (ebx != 1) {
        ecx = *(ebx);
        ebx = *((esp + 0x14));
        esi = *((ebx + 0xc));
        ebx = *((esp + 0x18));
        edx = *((esp + 0x1c));
        void (*0x80597a0)() ();
    }
    ebx = *((esp + 0x14));
    ecx = *((ebx + 0x10));
    ebx = *((esp + 0x1c));
    void (*0x80598e0)() ();
    do {
label_6:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Assert_failure;
            *((eax + 4)) = 0x807fccc;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_7:
    caml_call_gc ();
    goto label_1;
label_5:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c000 */
#include <stdint.h>
 
int32_t camlUnix_fun_2604 (void) {
    eax = unix_socketpair;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8058b40 */
#include <stdint.h>
 
int32_t camlMap_create_1071 (void) {
    esi = eax;
    if (esi != 1) {
        eax = *((esi + 0x10));
    } else {
        eax = 1;
    }
    if (edx != 1) {
        edi = *((edx + 0x10));
    } else {
        edi = 1;
    }
    if (eax >= edi) {
        edi = eax;
        edi += 2;
    } else {
        edi += 2;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1400;
            *(eax) = esi;
            *((eax + 4)) = ebx;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = edi;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8054ae0 */
#include <stdint.h>
 
int32_t camlList_for_all2_1145 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        eax = caml_apply2 (edx, eax, eax);
        if (eax == 1) {
            goto label_2;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_2:
    eax = 1;
    return eax;
label_0:
    if (ecx == 1) {
        eax = 3;
        return eax;
    }
label_1:
    eax = "List.for_all2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063a0c */
#include <stdint.h>
 
int32_t unix_link (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14eef;
    esi = *((ebp + 0xc));
    *((esp + 4)) = esi;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = link ();
    if (eax == -1) {
        eax = ebx - 0x24b0;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a784 */
#include <stdint.h>
 
void link (void) {
    link ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066758 */
#include <stdint.h>
 
int32_t unix_single_write (int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, char * ptr, size_t nbytes) {
    int32_t var_4038h;
    int32_t var_4034h;
    int32_t var_4030h;
    int32_t var_402ch;
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1219d;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4038)) = edx;
    edx = ebp - 0x4038;
    *(eax) = edx;
    *((ebp - 0x4030)) = 1;
    *((ebp - 0x4034)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x402c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    if (esi > 0) {
        eax = 0x4000;
        if (esi > 0x4000) {
            esi = eax;
        }
        eax = *((ebp + 0x10));
        eax >>= 1;
        eax += *((ebp + 0xc));
        edi = ebp - 0x4018;
        memmove (edi, eax, esi);
        caml_enter_blocking_section ();
        eax = *((ebp + 8));
        eax >>= 1;
        eax = write (eax, edi, esi);
        esi = eax;
        caml_leave_blocking_section ();
        if (esi != -1) {
            goto label_0;
        }
        eax = ebx - 0x21a9;
        uerror (eax, 0);
    }
    esi = 0;
label_0:
    edx = *((ebp - 0x4038));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = esi + esi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a004 */
#include <stdint.h>
 
void write (void) {
    write ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80652c4 */
#include <stdint.h>
 
uint32_t unix_socketpair (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_10h;
    int32_t var_bp_ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1363c;
    eax = ebp - 0x10;
    *((esp + 0xc)) = eax;
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebx - 0x1c));
    eax = *((eax + edx*4));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    edx >>= 1;
    eax = *((ebx - 0x20));
    eax = *((eax + edx*4));
    *(esp) = eax;
    eax = socketpair ();
    if (eax == -1) {
        eax = ebx - 0x240d;
        uerror (eax, 0);
    }
    caml_alloc_small (2, 0);
    edx = *((ebp - 0x10));
    edx = edx + edx + 1;
    *(eax) = edx;
    edx = *((ebp - 0xc));
    edx = edx + edx + 1;
    *((eax + 4)) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049fa4 */
#include <stdint.h>
 
void socketpair (void) {
    socketpair ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063dac */
#include <stdint.h>
 
int32_t unix_mkdir (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14b4f;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = mkdir ();
    if (eax == -1) {
        eax = ebx - 0x24ec;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049e74 */
#include <stdint.h>
 
void mkdir (void) {
    mkdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8071fed */
#include <stdint.h>
 
uint32_t caml_gc_counters (void) {
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x2c)) = ebx;
    eax = ebp - 0x2c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x24)) = 1;
    *((ebp - 0x28)) = 1;
    eax = ebp - 0xc;
    *((ebp - 0x20)) = eax;
    eax = caml_young_end;
    eax -= *(obj.caml_young_ptr);
    eax >>= 2;
    edx = 0;
    *((ebp - 0x40)) = eax;
    *((ebp - 0x3c)) = edx;
    *(fp_stack--) = *((ebp - 0x40));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *((ebp - 0x58)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_stat_promoted_words);
    *((ebp - 0x50)) = fp_stack[0];
    fp_stack--;
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x40)) = eax;
    *((ebp - 0x3c)) = edx;
    *(fp_stack--) = *((ebp - 0x40));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *((ebp - 0x48)) = fp_stack[0];
    fp_stack--;
    eax = caml_alloc_tuple (ebx);
    *((ebp - 0xc)) = eax;
    *(fp_stack--) = *((ebp - 0x58));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0xc));
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x50));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0xc));
    eax += 4;
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x48));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0xc));
    eax += 8;
    caml_modify (eax, eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805aac0 */
#include <stdint.h>
 
int32_t camlBuffer_reset_1064 (void) {
    ebx = eax;
    *((ebx + 4)) = 1;
    caml_modify (ebx, *((ebx + 0xc)));
    ecx = *(ebx);
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((ecx + eax));
    eax -= ecx;
    eax = eax + eax + 1;
    *((ebx + 8)) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8063768 */
#include <stdint.h>
 
int32_t unix_initgroups (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15198;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = initgroups ();
    if (eax == -1) {
        eax = ebx - 0x253c;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a564 */
#include <stdint.h>
 
void initgroups (void) {
    initgroups ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805e910 */
#include <stdint.h>
 
int32_t loc_camlCallback_code_begin (void) {
    eax = caml_register_named_value;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8051350 */
#include <stdint.h>
 
uint32_t camlArray_trickle_1165 (void) {
    int32_t var_4h_2;
    eax = void (*0x80513e0)(uint32_t, uint32_t) (edx, ecx);
    ecx = .comment;
    ebx = *(eax);
    if (ebx == ecx) {
        ebx = *((eax + 4));
        eax = *(esp);
        eax = *((eax + 0xc));
        ecx = *((eax - 4));
        edx = *((eax - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            ecx >>= 9;
            if (ecx <= ebx) {
                goto label_0;
            }
            ecx = *((esp + 4));
            caml_modify (eax + ebx*2 - 2, ecx);
        } else {
            ecx >>= 0xa;
            if (ecx <= ebx) {
                goto label_1;
            }
            ecx = *((esp + 4));
            *(fp_stack--) = *(ecx);
            *((eax + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = 1;
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    edx = *((edx + 0x10));
    camlArray_trickledown_1160 (*(obj.caml_exception_pointer));
    return eax;
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bfe0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2600 (void) {
    eax = unix_bind;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804da20 */
#include <stdint.h>
 
int32_t camlUnix_open_process_out_1962 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *(esp) = ebx;
    eax = *(eax);
    *((esp + 8)) = eax;
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (ebx);
    ecx = eax;
    *((esp + 0xc)) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0x800;
            eax = *(esp);
            *(esi) = eax;
            *((esi + 4)) = 1;
            ebx = esi + 0xc;
            *((ebx - 4)) = 0x402;
            *(ebx) = ecx;
            edx = 3;
            eax = *((esp + 4));
            ecx = *((esp + 8));
            camlUnix_open_proc_1949 ();
            eax = *((esp + 8));
            eax = unix_close;
            caml_c_call (eax);
            eax = *((esp + 0xc));
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c705 */
#include <stdint.h>
 
int32_t caml_atan_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    atan (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a1d4 */
#include <stdint.h>
 
void atan (void) {
    atan ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80720dc */
#include <stdint.h>
 
uint32_t caml_gc_quick_stat (void) {
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x3c)) = ebx;
    eax = ebp - 0x3c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    eax = caml_young_end;
    eax -= *(obj.caml_young_ptr);
    eax >>= 2;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *((ebp - 0x78)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_stat_promoted_words);
    *((ebp - 0x70)) = fp_stack[0];
    fp_stack--;
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *((ebp - 0x68)) = fp_stack[0];
    fp_stack--;
    esi = caml_stat_minor_collections;
    edi = caml_stat_major_collections;
    eax = caml_stat_heap_size;
    eax >>= 2;
    *((ebp - 0x60)) = eax;
    eax = caml_stat_top_heap_size;
    eax >>= 2;
    *((ebp - 0x5c)) = eax;
    eax = caml_stat_compactions;
    *((ebp - 0x58)) = eax;
    edx = caml_stat_heap_chunks;
    *((ebp - 0x54)) = edx;
    eax = caml_alloc_tuple (ebx, esi, edi);
    *((ebp - 0x1c)) = eax;
    *(fp_stack--) = *((ebp - 0x78));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x70));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 4;
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x68));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 8;
    caml_modify (eax, eax);
    eax = esi + esi + 1;
    eax = *((ebp - 0x1c));
    eax += 0xc;
    caml_modify (eax, eax);
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x10;
    caml_modify (eax, eax);
    edx = *((ebp - 0x60));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x14;
    caml_modify (eax, eax);
    edx = *((ebp - 0x54));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x18;
    caml_modify (eax, eax);
    eax = *((ebp - 0x1c));
    eax += 0x1c;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x20;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x24;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x28;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x2c;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x30;
    caml_modify (eax, 1);
    edx = *((ebp - 0x58));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x34;
    caml_modify (eax, eax);
    edx = *((ebp - 0x5c));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x38;
    caml_modify (eax, eax);
    caml_stack_usage ();
    eax = eax + eax + 1;
    eax = *((ebp - 0x1c));
    eax += 0x3c;
    caml_modify (eax, eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804b1c0 */
#include <stdint.h>
 
int32_t caml_curry5_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d980 */
#include <stdint.h>
 
int32_t camlUnix_open_process_in_1957 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 8)) = ebx;
    eax = *(eax);
    *(esp) = eax;
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    ecx = eax;
    *((esp + 0xc)) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0x800;
            eax = *(esp);
            *(esi) = eax;
            *((esi + 4)) = 1;
            ebx = esi + 0xc;
            *((ebx - 4)) = 0x401;
            *(ebx) = ecx;
            ecx = 1;
            eax = *((esp + 4));
            edx = *((esp + 8));
            camlUnix_open_proc_1949 ();
            eax = *((esp + 8));
            eax = unix_close;
            caml_c_call (eax);
            eax = *((esp + 0xc));
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8050220 */
#include <stdint.h>
 
int32_t camlPervasives_read_float_1290 (void) {
    eax = 1;
    eax = camlPervasives_read_line_1288 ();
    eax = caml_float_of_string;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c6c2 */
#include <stdint.h>
 
int32_t caml_ceil_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    ceil (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8051560 */
#include <stdint.h>
 
int32_t camlArray_trickleup_1178 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    do {
        esi = eax;
        edi = ecx;
        ecx = 3;
        eax = esi;
        eax += 0xfffffffe;
        eax >>= 1;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        ecx = eax + eax + 1;
        if (esi != ecx) {
            *((esp + 0xc)) = ecx;
            *(esp) = edi;
            *((esp + 4)) = ebx;
            *((esp + 8)) = esi;
        } else {
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.caml_exn_Assert_failure;
            *((eax + 4)) = 0x807d02c;
            caml_raise_exn ();
        }
        edx = *((edi + 0x10));
        eax = *((edx - 4));
        esi = *((edx - 4));
        esi &= 0xff;
        if (esi != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_4;
            }
            eax = *((edx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_5;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_6;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((edi + 0xc));
        eax = caml_apply2 ();
        if (eax >= 1) {
            goto label_7;
        }
        edi = *(esp);
        ebx = *((edi + 0x10));
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            esi = *((esp + 0xc));
            if (eax <= esi) {
                goto label_8;
            }
            ecx = *((ebx + esi*2 - 2));
        } else {
            eax >>= 0xa;
            esi = *((esp + 0xc));
            if (eax <= esi) {
                goto label_9;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ecx = eax + 4;
            *((ecx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + esi*4 - 4));
            *(ecx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((edi + 0x10));
        edx = *((eax - 4));
        ebx = *((eax - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            edx >>= 9;
            ebx = *((esp + 8));
            if (edx <= ebx) {
                goto label_11;
            }
            caml_modify (eax + ebx*2 - 2, ecx);
        } else {
            edx >>= 0xa;
            ebx = *((esp + 8));
            if (edx <= ebx) {
                goto label_12;
            }
            *(fp_stack--) = *(ecx);
            *((eax + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        if (esi <= 1) {
            goto label_13;
        }
        eax = esi;
        ebx = *((esp + 4));
        ecx = edi;
    } while (1);
label_13:
    ecx = *((edi + 0x10));
    ebx = *((ecx - 4));
    eax = *((ecx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = ebx;
        eax >>= 9;
        if (eax <= 1) {
            goto label_14;
        }
        eax = *((esp + 4));
        caml_modify (ecx, eax);
    } else {
        eax = ebx;
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_15;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *(ecx) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_7:
    eax = *(esp);
    eax = *((eax + 0x10));
    ebx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        ebx >>= 9;
        ecx = *((esp + 8));
        if (ebx <= ecx) {
            goto label_16;
        }
        ebx = *((esp + 4));
        caml_modify (eax + ecx*2 - 2, ebx);
    } else {
        ebx >>= 0xa;
        ecx = *((esp + 8));
        if (ebx <= ecx) {
            goto label_17;
        }
        ebx = *((esp + 4));
        *(fp_stack--) = *(ebx);
        *((eax + ecx*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_10:
    caml_call_gc ();
    goto label_0;
label_6:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
label_17:
    caml_ml_array_bound_error ();
label_16:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8067cc3 */
#include <stdint.h>
 
uint32_t caml_execute_signal (int32_t arg_8h, uint32_t arg_ch) {
    int32_t var_98h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = ebp - 0x98;
    *(esp) = esi;
    sigemptyset ();
    *((esp + 4)) = ebx;
    *(esp) = esi;
    sigaddset ();
    *((esp + 8)) = esi;
    *((esp + 4)) = esi;
    *(esp) = 0;
    sigprocmask ();
    caml_rev_convert_signal_number (ebx);
    eax = eax + eax + 1;
    eax = caml_signal_handlers;
    eax = *((eax + ebx*4));
    eax = caml_callback_exn (eax, eax);
    edi = eax;
    if (*((ebp + 0xc)) == 0) {
        *((esp + 8)) = 0;
        *((esp + 4)) = esi;
        *(esp) = 2;
        sigprocmask ();
        eax = edi;
        eax &= 3;
        if (eax != 2) {
            goto label_0;
        }
    } else {
        eax &= 3;
        if (eax != 2) {
            goto label_0;
        }
        *((esp + 4)) = ebx;
        eax = ebp - 0x98;
        *(esp) = eax;
        sigdelset ();
        *((esp + 8)) = 0;
        *((esp + 4)) = esi;
        *(esp) = 2;
        sigprocmask ();
    }
    edi &= 0xfffffffc;
    caml_raise (edi);
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c370 */
#include <stdint.h>
 
int32_t camlUnix_fun_2704 (void) {
    eax = unix_clear_nonblock;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804af00 */
#include <stdint.h>
 
int32_t caml_curry7_6 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 4)) = eax;
    esi = ebx;
    eax = *((esi + 0xc));
    ecx = *((eax + 0xc));
    edi = *((ecx + 0xc));
    ebp = *((edi + 0xc));
    ebx = *((ebp + 0xc));
    edx = *((ebx + 0xc));
    *((esp + 8)) = edx;
    esi = *((esi + 8));
    *(esp) = esi;
    eax = *((eax + 8));
    *((esp + 0x10)) = eax;
    esi = *((ecx + 8));
    ecx = *((edi + 8));
    edi = *((ebp + 8));
    eax = *((ebx + 8));
    ebx = *((edx + 8));
    *((esp + 0xc)) = ebx;
    ebx = edi;
    edx = esi;
    esi = *((esp + 0x10));
    edi = *(esp);
    ebp = *((esp + 4));
    *(loc.caml_extra_params) = ebp;
    ebp = *((esp + 8));
    *(0x8084740) = ebp;
    ebp = *((esp + 0xc));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806e441 */
#include <stdint.h>
 
uint32_t caml_really_putblock (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    if (ebx <= 0) {
        goto label_0;
    }
    do {
        eax = caml_putblock (edi, esi, ebx);
        esi += eax;
        ebx -= eax;
    } while (ebx > 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80628ec */
#include <stdint.h>
 
uint32_t unix_geteuid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16014;
    geteuid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a8f4 */
#include <stdint.h>
 
void geteuid (void) {
    geteuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c426 */
#include <stdint.h>
 
int32_t caml_ge_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80706e7 */
#include <stdint.h>
 
uint32_t caml_input_value_from_malloc (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 8));
    *(obj.intern_input) = edx;
    edx += *((ebp + 0xc));
    *(obj.intern_input_malloced) = 1;
    eax = edx + 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *(edx);
    edx <<= 0x18;
    edx = ecx + edx;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    edx += ecx;
    ecx = *((eax - 2));
    ecx <<= 8;
    edx += ecx;
    if (edx != 0x8495a6be) {
        eax = caml_failwith ("input_value_from_malloc: bad object");
    }
    eax += 4;
    *(obj.intern_src) = eax;
    eax = input_val_from_block ();
    ebx = eax;
    eax = intern_input;
    caml_stat_free (eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fb40 */
#include <stdint.h>
 
int32_t camlPervasives_valid_float_lexem_1135 (void) {
    ecx = eax;
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    edx = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = loc.camlPervasives__code_begin;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            *((ebx + 0xc)) = edx;
            eax = 1;
            void (*0x804f450)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c350 */
#include <stdint.h>
 
int32_t camlUnix_fun_2700 (void) {
    eax = unix_clear_close_on_exec;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805aa10 */
#include <stdint.h>
 
int32_t camlBuffer_blit_1051 (void) {
    if (esi >= 1) {
        if (ebx < 1) {
            goto label_0;
        }
        edi = *((eax + 4));
        edi -= esi;
        edi++;
        if (ebx > edi) {
            goto label_0;
        }
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ecx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ecx + ebp));
        ebp -= edi;
        edi = ebp;
        edi <<= 1;
        edi -= esi;
        edi += 2;
        if (edx > edi) {
            goto label_0;
        }
        eax = *(eax);
        void (*0x80559c0)() ();
    }
label_0:
    eax = "Buffer.blit";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805d6e0 */
#include <stdint.h>
 
uint32_t camlPrintf_incomplete_format_1065 (void) {
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ecx = ebx + ebx + 1;
    ebx = 1;
    camlString_sub_1046 ();
    ebx = camlPrintf__48;
    eax = camlPervasives_$5e_1112 ();
    ebx = eax;
    eax = "Printf: premature end of format string ``";
    camlPervasives_$5e_1112 ();
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805fcd0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_to_array_1246 (void) {
    *(esp) = eax;
    eax = caml_equal;
    eax = caml_c_call (eax);
    if (eax != 1) {
        eax = camlCamlinternalOO__72;
        return eax;
    }
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80751da */
#include <stdint.h>
 
int32_t caml_find_custom_operations (int32_t arg_8h) {
    char * s2;
    edi = *((ebp + 8));
    ebx = custom_ops_table;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        esi = *(ebx);
        eax = *(esi);
        eax = strcmp (eax, edi);
        if (eax == 0) {
            goto label_1;
        }
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    esi = 0;
label_1:
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8066d9c */
#include <stdint.h>
 
int32_t main (char ** envp) {
    eax = *((ebp + 0xc));
    caml_main (eax);
    return caml_sys_exit (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806597d */
#include <stdint.h>
 
uint32_t unix_fstat (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12f83;
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = 3;
    eax = fxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x2366;
        uerror (eax, 0);
    }
    if (*((ebp - 0x38)) >= 0) {
        if (*((ebp - 0x38)) <= 0) {
            if (*((ebp - 0x3c)) <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = *((ebp - 0x58));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        eax = ebx - 0x2366;
        unix_error (0x4b, eax, 0);
    }
label_0:
    edx = ebp - 0x68;
    eax = 0;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049d84 */
#include <stdint.h>
 
void init (void) {
    /* [11] -r-x section size 48 named .init */
    void (*0x8049d90)(uint32_t) (ebx);
    ebx += 0x2eb7c;
    edx = *((ebx - 0x24));
    if (edx != 0) {
        gmon_start_ ();
    }
    frame_dummy ();
    _do_global_ctors_aux ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049f14 */
#include <stdint.h>
 
void loc_imp_gmon_start_ (void) {
    gmon_start_ ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806c7b3 */
#include <stdint.h>
 
int32_t caml_cos_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    cos (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a3c4 */
#include <stdint.h>
 
void cos (void) {
    cos ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804bdf0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2833 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ecx;
            ebx = *((ebx + 8));
            ebx = *(ebx);
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8051e40 */
#include <stdint.h>
 
int32_t camlArray_make_matrix_1042 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *(esp) = eax;
    *((esp + 8)) = ebx;
    *((esp + 4)) = ecx;
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    ecx = 1;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ecx > eax) {
        goto label_0;
    }
    *((esp + 0x10)) = eax;
    *(esp) = ecx;
    *((esp + 0xc)) = ebx;
    do {
        eax = *((esp + 4));
        eax = *((esp + 0xc));
        eax = caml_make_vect;
        eax = caml_c_call (eax);
        esi = *((esp + 4));
        ebx = *((esp + 0x10));
        caml_modify (ebx + esi*2 - 2, eax);
        ecx = esi;
        esi += 2;
        *(esp) = esi;
        eax = *((esp + 0x10));
    } while (ecx != eax);
label_0:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075797 */
#include <stdint.h>
 
int32_t caml_get_exception_backtrace (void) {
    int32_t var_6ch;
    uint32_t var_60h;
    uint32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = caml_local_roots;
    *((ebp - 0x6c)) = eax;
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x28)) = 0;
    *((ebp - 0x48)) = eax;
    eax = ebp - 0x48;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x40)) = 1;
    *((ebp - 0x44)) = 4;
    eax = ebp - 0x1c;
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x30)) = eax;
    eax = caml_backtrace_pos;
    eax = caml_alloc (ebx, esi, edi);
    *((ebp - 0x20)) = eax;
    if (*(obj.caml_backtrace_pos) <= 0) {
        goto label_0;
    }
    ebx = 0;
    edi = ebp - 0x60;
    do {
        esi = ebx*4;
        eax = caml_backtrace_buffer;
        eax = *((eax + esi));
        edx = edi;
        extract_location_info ();
        if (*((ebp - 0x60)) != 0) {
            eax = *((ebp - 0x58));
            eax = caml_copy_string (eax);
            *((ebp - 0x28)) = eax;
            eax = caml_alloc_small (5, 0);
            edx -= edx;
            edx &= 0xfffffffe;
            edx += 3;
            *((ebp - 0x24)) = eax;
            *(eax) = edx;
            edx = *((ebp - 0x28));
            eax = *((ebp - 0x24));
            *((eax + 4)) = edx;
            eax = *((ebp - 0x54));
            edx = eax + eax + 1;
            eax = *((ebp - 0x24));
            *((eax + 8)) = edx;
            eax = *((ebp - 0x50));
            edx = eax + eax + 1;
            eax = *((ebp - 0x24));
            *((eax + 0xc)) = edx;
            eax = *((ebp - 0x4c));
            edx = eax + eax + 1;
            eax = *((ebp - 0x24));
            *((eax + 0x10)) = edx;
        } else {
            eax = caml_alloc_small (1, 1);
            edx -= edx;
            edx &= 0xfffffffe;
            edx += 3;
            *((ebp - 0x24)) = eax;
            *(eax) = edx;
        }
        eax = *((ebp - 0x24));
        esi += *((ebp - 0x20));
        caml_modify (esi, eax);
        ebx++;
    } while (*(obj.caml_backtrace_pos) > ebx);
label_0:
    eax = caml_alloc_small (1, 0);
    *((ebp - 0x1c)) = eax;
    edx = *((ebp - 0x20));
    *(eax) = edx;
    eax = *((ebp - 0x6c));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805be60 */
#include <stdint.h>
 
int32_t camlPrintf_add_char_1166 (void) {
    eax = *((ecx + 0xc));
    camlBuffer_add_char_1072 (eax);
    eax = *(esp);
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805f5c0 */
#include <stdint.h>
 
int32_t camlCamlinternalOO_get_method_label_1188 (void) {
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = ebx;
    eax = void (*0x805f660)(uint32_t, uint32_t) (eax, edx);
    ecx = loc.caml_exn_Not_found;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *((esp + 4));
        eax = camlCamlinternalOO_new_method_1185 ();
        ebx = eax;
        eax = .comment;
        edx = *((eax + 0xc));
        eax = *((esp + 4));
        ecx = *((eax + 8));
        eax = *(esp);
        eax = camlMap_add_1108 (ebx);
        ebx = *((esp + 8));
        eax = *((esp + 8));
        eax += 8;
        caml_modify (eax, eax);
        eax = .comment;
        edx = *((eax + 0xc));
        ecx = *((ebx + 0xc));
        ebx = 3;
        eax = *((esp + 8));
        eax = camlMap_add_1108 ();
        eax = *((esp + 8));
        eax += 0xc;
        caml_modify (eax, eax);
        eax = *((esp + 8));
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ecx = .comment;
    ecx = *((ecx + 0x54));
    ebx = *((edx + 8));
    camlMap_find_1117 (*(obj.caml_exception_pointer));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x805b660 */
#include <stdint.h>
 
int32_t camlPrintf_cont_a_1362 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = eax;
    edi = ebx;
    ebx = ecx;
    *((esp + 4)) = edx;
    *((esp + 8)) = esi;
    eax = *((esi + 0x3c));
    if (eax != 1) {
        eax = 1;
        ecx = edi;
        eax = caml_apply2 ();
        ebx = eax;
        eax = *((esp + 8));
        ecx = *((eax + 0x44));
        eax = *((eax + 0x4c));
        caml_apply2 ();
    } else {
        eax = *((esi + 0x4c));
        ecx = edi;
        caml_apply2 ();
    }
    ecx = *((esp + 8));
    ecx += 0xffffffe0;
    eax = *(esp);
    ebx = *((esp + 4));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804fcd0 */
#include <stdint.h>
 
int32_t camlPervasives_output_1194 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = caml_ml_output;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "output";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80756f0 */
#include <stdint.h>
 
int32_t caml_backtrace_status (void) {
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804c2c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2682 (void) {
    eax = unix_closedir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80630ea */
#include <stdint.h>
 
int32_t unix_getprotobynumber (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15816;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getprotobynumber ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_proto_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a1f4 */
#include <stdint.h>
 
void getprotobynumber (void) {
    getprotobynumber ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8064afc */
#include <stdint.h>
 
int32_t unix_setgid (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13e04;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = setgid ();
    if (eax == -1) {
        eax = ebx - 0x2473;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a7c4 */
#include <stdint.h>
 
void setgid (void) {
    setgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8053410 */
#include <stdint.h>
 
int32_t camlArray_stable_sort_1188 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h_2;
    int32_t var_14h_2;
    ecx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x4c;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry7;
    *((eax + 4)) = 0xf;
    *((eax + 8)) = 0x8051830;
    *((eax + 0xc)) = ecx;
    *((eax + 0x10)) = ebx;
    esi = eax + 0x18;
    *((esi - 4)) = 0x14f7;
    *(esi) = sym.caml_curry4;
    *((esi + 4)) = 9;
    *((esi + 8)) = 0x80519c0;
    *((esi + 0xc)) = ecx;
    *((esi + 0x10)) = ebx;
    ecx = eax + 0x30;
    *((ecx - 4)) = 0x18f7;
    *(ecx) = sym.caml_curry4;
    *((ecx + 4)) = 9;
    *((ecx + 8)) = 0x8051cc0;
    *((ecx + 0xc)) = ebx;
    *((ecx + 0x10)) = eax;
    *((ecx + 0x14)) = esi;
    edx = *((ebx - 4));
    edi = *((ebx - 4));
    edi &= 0xff;
    if (edi != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    if (edx <= 0xb) {
        ecx = 1;
        eax = 1;
        void (*0x80519c0)() ();
    }
    *(esp) = ecx;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = ebx;
    eax = edx;
    eax >>= 1;
    if (eax < 0) {
        eax++;
    }
    eax >>= 1;
    eax = eax + eax + 1;
    *((esp + 8)) = eax;
    edx -= eax;
    edx++;
    *((esp + 4)) = edx;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_2;
        }
        eax = *(ebx);
        goto label_3;
    }
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_4;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(eax) = fp_stack[0];
            fp_stack--;
label_3:
            eax = caml_make_vect;
            eax = caml_c_call (edx);
            ebx = eax;
            ecx = 1;
            eax = *((esp + 8));
            edx = *((esp + 4));
            esi = *(esp);
            camlArray_sortto_1217 (ebx);
            eax = 1;
            ebx = *((esp + 0x10));
            ecx = *((esp + 4));
            edx = *((esp + 8));
            esi = *(esp);
            camlArray_sortto_1217 ();
            edx = 1;
            eax = *((esp + 4));
            ebx = *((esp + 8));
            ecx = *((esp + 0xc));
            esi = eax;
            edi = *((esp + 0x10));
            *(loc.caml_extra_params) = ebp;
            ebp = *((esp + 0x14));
            *(0x8084740) = ebp;
            void (*0x8051830)() ();
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806b0b1 */
#include <stdint.h>
 
int32_t caml_lessthan (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80882e0) {
        eax = compare_free_stack ();
    }
    ebx += 0x7fffffff;
    eax -= eax;
    eax &= 2;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x806ca2a */
#include <stdint.h>
 
int32_t caml_fmod_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *(fp_stack--) = fp_stack[0];
    *(fp_stack--) = fp_stack[2];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (? == ?);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_0;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_1;
label_0:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_1:
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049e14 */
#include <stdint.h>
 
void inet_ntop (void) {
    inet_ntop ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049e54 */
#include <stdint.h>
 
void setgroups (void) {
    setgroups ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049e84 */
#include <stdint.h>
 
void strerror (void) {
    strerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049ea4 */
#include <stdint.h>
 
void memcmp (void) {
    memcmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049ec4 */
#include <stdint.h>
 
void freeaddrinfo (void) {
    freeaddrinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049f04 */
#include <stdint.h>
 
void sigismember (void) {
    sigismember ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049f44 */
#include <stdint.h>
 
void isoc99_sscanf (void) {
    isoc99_sscanf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049f74 */
#include <stdint.h>
 
void cfgetispeed (void) {
    cfgetispeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049f94 */
#include <stdint.h>
 
void strtod (void) {
    strtod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049fe4 */
#include <stdint.h>
 
void system (void) {
    system ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a0f4 */
#include <stdint.h>
 
void tcgetattr (void) {
    tcgetattr ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a1b4 */
#include <stdint.h>
 
void inet_pton (void) {
    inet_pton ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a244 */
#include <stdint.h>
 
void fflush (void) {
    fflush ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a274 */
#include <stdint.h>
 
void gethostbyaddr_r (void) {
    gethostbyaddr_r ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a2f4 */
#include <stdint.h>
 
void getaddrinfo (void) {
    getaddrinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a354 */
#include <stdint.h>
 
void readdir64 (void) {
    readdir64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a374 */
#include <stdint.h>
 
void memcpy (void) {
    memcpy ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a384 */
#include <stdint.h>
 
void cfsetospeed (void) {
    cfsetospeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a394 */
#include <stdint.h>
 
void utime (void) {
    utime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a444 */
#include <stdint.h>
 
void sigdelset (void) {
    sigdelset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a454 */
#include <stdint.h>
 
void h_errno_location (void) {
    h_errno_location ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a504 */
#include <stdint.h>
 
void select (void) {
    select ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a664 */
#include <stdint.h>
 
void sigaddset (void) {
    sigaddset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a694 */
#include <stdint.h>
 
void cfgetospeed (void) {
    cfgetospeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a6b4 */
#include <stdint.h>
 
void strcat (void) {
    strcat ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a6f4 */
#include <stdint.h>
 
void gethostbyname_r (void) {
    gethostbyname_r ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a704 */
#include <stdint.h>
 
void fork (void) {
    fork ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a724 */
#include <stdint.h>
 
void setsockopt (void) {
    setsockopt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a734 */
#include <stdint.h>
 
void tcsetattr (void) {
    tcsetattr ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a744 */
#include <stdint.h>
 
void fcntl (void) {
    fcntl ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a774 */
#include <stdint.h>
 
void getgroups (void) {
    getgroups ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a7b4 */
#include <stdint.h>
 
void getsockopt (void) {
    getsockopt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a864 */
#include <stdint.h>
 
void strcmp (void) {
    strcmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a874 */
#include <stdint.h>
 
void sigsetjmp (void) {
    sigsetjmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a8a4 */
#include <stdint.h>
 
void cfsetispeed (void) {
    cfsetispeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8049de4 */
#include <stdint.h>
 
void fmod (void) {
    fmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804a254 */
#include <stdint.h>
 
void sqrt (void) {
    sqrt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x80487c5 */
#include <stdint.h>
 
void fcn_080487c5 (int32_t arg_2h) {
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edx) += bl;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 4)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    al -= 4;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    edx = 1;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + eax)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    dh += ch;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 2)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(ecx) -= al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    edx = 4;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edx) += dl;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((esi + 5)) += dh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    bh += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 4)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(es:edi) = al;
    es:edi++;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((esi + 5)) += ch;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    ah += cl;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebp + 2)) += bh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 4)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("in al, dx");
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax -= 5;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    al += cl;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edx + 1)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(ecx) += bh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + 4)) += bh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(fp_stack--) = *(ecx);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax = *(ecx);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("aam 4");
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 4)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(gs:eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebx + eax)) += cl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("scasb al, byte es:[edi]");
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + 3)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebx + 3)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    bh = 2;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    edi = 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    bl += ch;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) &= eax;
    *(eax) += al;
    tmp_0 = eax;
    eax = esi;
    esi = tmp_0;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edi) += dl;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax += *(es:eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 4)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax = (int32_t) ax;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    es = *(edx);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("in eax, 2");
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    tmp_1 = eax;
    eax = ebx;
    ebx = tmp_1;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 2)) += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    if (*(eax) >= 0) {
        *(eax) += al;
        *(eax) += al;
    }
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edx) += dl;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + 3)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    dl += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebp + eax)) += cl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edx + 5)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("lar eax, word [eax]");
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(esi) += dh;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    dl += ch;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += eax;
    *(eax) += al;
    ebx--;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edi) += dh;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    cl += dh;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 5)) += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    cl += bh;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 3)) += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edx + 2)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    ch += ah;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 2)) += cl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("int3");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d250 */
#include <stdint.h>
 
int32_t fcn_0804d250 (int32_t arg_8h) {
    *(obj.caml_exception_pointer) = esp;
    eax = 3;
    eax = camlList_mem_1161 (*(obj.caml_exception_pointer));
    while (1) {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
            eax = *((esp + 8));
            eax = unix_gethostbyaddr;
            eax = caml_c_call (eax);
            eax = *(eax);
        }
        caml_call_gc (eax);
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804d910 */
#include <stdint.h>
 
int32_t fcn_0804d910 (int32_t arg_ch) {
    *(obj.caml_exception_pointer) = esp;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = "/bin/sh";
            *((ebx + 4)) = 0x807a49c;
            eax = *((esp + 0xc));
            *((ebx + 8)) = eax;
            eax = unix_execv;
            caml_c_call ("/bin/sh");
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804dd00 */
#include <stdint.h>
 
int32_t fcn_0804dd00 (int32_t arg_18h, int32_t arg_1ch) {
    *(obj.caml_exception_pointer) = esp;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = "/bin/sh";
            *((ebx + 4)) = 0x807a47c;
            eax = *((esp + 0x18));
            *((ebx + 8)) = eax;
            eax = *((esp + 0x1c));
            eax = unix_execve;
            caml_c_call ("/bin/sh");
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x804f4f0 */
#include <stdint.h>
 
int32_t fcn_0804f4f0 (void) {
    *(obj.caml_exception_pointer) = esp;
    eax = caml_ml_flush;
    caml_c_call (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075c00 */
#include <stdint.h>
 
void loc_caml_start_program (void) {
    esi = caml_startup__code_begin;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/methcall_ocaml/ia32_elf/subject.exe @ 0x8075c90 */
#include <stdint.h>
 
int32_t loc_caml_raise_exception (int32_t arg_4h) {
    if ((*(obj.caml_backtrace_active) & 1) == 0) {
        eax = *((esp + 4));
        esp = caml_exception_pointer;
        return eax;
    }
    esi = *((esp + 4));
    caml_stash_backtrace (esi, *(obj.caml_last_return_address), *(obj.caml_bottom_of_stack), *(obj.caml_exception_pointer));
    eax = esi;
    esp = caml_exception_pointer;
    return eax;
}
