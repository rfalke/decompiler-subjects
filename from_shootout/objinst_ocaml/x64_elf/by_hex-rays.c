/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_40A278(); // weak
// double log10(double x);
// int chmod(const char *file, __mode_t mode);
// int symlink(const char *from, const char *to);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// double exp(double x);
// int chdir(const char *path);
// int dup2(int fd, int fd2);
// double atan2(double y, double x);
// double frexp(double x, int *exponent);
// int execv(const char *path, char *const argv[]);
// double tanh(double x);
// time_t mktime(struct tm *tp);
// void *memset(void *s, int c, size_t n);
// __gid_t getgid(void);
// struct group *getgrnam(const char *name);
// __pid_t setsid(void);
// int shutdown(int fd, int how);
// int truncate64(const char *file, __off64_t length);
// int inet_pton(int af, const char *cp, void *buf);
// int close(int fd);
// __pid_t wait(__WAIT_STATUS stat_loc);
// double ceil(double x);
// int utime(const char *file, const struct utimbuf *file_times);
// int *__h_errno_location(void);
// char *getlogin(void);
// double tan(double x);
// double ldexp(double x, int exponent);
// __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...); weak
// int getrusage(__rusage_who_t who, struct rusage *usage);
// int isatty(int fd);
// __int64 __isoc99_sscanf(_QWORD, const char *, ...); weak
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int execvp(const char *file, char *const argv[]);
// int getpeername(int fd, struct sockaddr *addr, socklen_t *len);
// void __noreturn exit(int status);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void *malloc(size_t size);
// int tcsendbreak(int fd, int duration);
// int setitimer(__itimer_which_t which, const struct itimerval *new, struct itimerval *old);
// int dup(int fd);
// int system(const char *command);
// int unlink(const char *name);
// int rmdir(const char *path);
// int getgroups(int size, __gid_t list[]);
// int sigismember(const sigset_t *set, int signo);
// __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// double cos(double x);
// struct tm *gmtime(const time_t *timer);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// __pid_t getpid(void);
// int __fxstat64(int ver, int fildes, struct stat64 *stat_buf);
// int gethostbyaddr_r(const void *addr, __socklen_t len, int type, struct hostent *result_buf, char *buf, size_t buflen, struct hostent **result, int *h_errnop);
// struct passwd *getpwuid(__uid_t uid);
// __uid_t geteuid(void);
// int setuid(__uid_t uid);
// double fmod(double x, double y);
// int sigsuspend(const sigset_t *set);
// void freeaddrinfo(struct addrinfo *ai);
// int __fpclassify(double value);
// int tcflush(int fd, int queue_selector);
// void free(void *ptr);
// double atan(double x);
// size_t strlen(const char *s);
// int nice(int inc);
// DIR *opendir(const char *name);
// int tcdrain(int fd);
// double cosh(double x);
// __int64 __fastcall __recv_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// struct protoent *getprotobyname(const char *name);
// int listen(int fd, int n);
// const unsigned __int16 **__ctype_b_loc(void);
// int cfsetospeed(struct termios *termios_p, speed_t speed);
// int sigpending(sigset_t *set);
// __int64 __fastcall __read_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int link(const char *from, const char *to);
// double asin(double x);
// int pipe(int pipedes[2]);
// unsigned int sleep(unsigned int seconds);
// double pow(double x, double y);
// __gid_t getegid(void);
// int kill(__pid_t pid, int sig);
// char *strerror(int errnum);
// int open64(const char *file, int oflag, ...);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// speed_t cfgetispeed(const struct termios *termios_p);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int socketpair(int domain, int type, int protocol, int fds[2]);
// char *strcat(char *dest, const char *src);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// __int64 strtol(const char *nptr, char **endptr, int base);
// int ftruncate64(int fd, __off64_t length);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int gethostname(char *name, size_t len);
// int gethostbyname_r(const char *name, struct hostent *result_buf, char *buf, size_t buflen, struct hostent **result, int *h_errnop);
// int execve(const char *path, char *const argv[], char *const envp[]);
// int fchmod(int fd, __mode_t mode);
// int tcgetattr(int fd, struct termios *termios_p);
// void *memcpy(void *dest, const void *src, size_t n);
// int putenv(char *string);
// void *memmove(void *dest, const void *src, size_t n);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int __lxstat64(int ver, const char *filename, struct stat64 *stat_buf);
// int socket(int domain, int type, int protocol);
// void rewinddir(DIR *dirp);
// int getrlimit64(__rlimit_resource_t resource, struct rlimit64 *rlimits);
// char *getenv(const char *name);
// unsigned int alarm(unsigned int seconds);
// speed_t cfgetospeed(const struct termios *termios_p);
// __int64 __fastcall __recvfrom_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int tcflow(int fd, int action);
// int *__errno_location(void);
// int sigaddset(sigset_t *set, int signo);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, int flags);
// int strcmp(const char *s1, const char *s2);
// int cfsetispeed(struct termios *termios_p, speed_t speed);
// char *getcwd(char *buf, size_t size);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// struct group *getgrgid(__gid_t gid);
// double acos(double x);
// char *strcpy(char *dest, const char *src);
// int chroot(const char *path);
// int chown(const char *file, __uid_t owner, __gid_t group);
// struct protoent *getprotobynumber(int proto);
// __uid_t getuid(void);
// struct servent *getservbyport(int port, const char *proto);
// void *calloc(size_t nmemb, size_t size);
// void *dlopen(const char *file, int mode);
// int __xstat64(int ver, const char *filename, struct stat64 *stat_buf);
// __off64_t lseek64(int fd, __off64_t offset, int whence);
// int closedir(DIR *dirp);
// int mkfifo(const char *path, __mode_t mode);
// __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int access(const char *name, int type);
// __pid_t fork(void);
// int sigemptyset(sigset_t *set);
// double modf(double x, double *iptr);
// __pid_t getppid(void);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int sigdelset(sigset_t *set, int signo);
// void *realloc(void *ptr, size_t size);
// char *setlocale(int category, const char *locale);
// double floor(double x);
// int __sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int getitimer(__itimer_which_t which, struct itimerval *value);
// __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// struct tm *localtime(const time_t *timer);
// int setgid(__gid_t gid);
// ssize_t write(int fd, const void *buf, size_t n);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// double sqrt(double x);
// int sigaltstack(const struct sigaltstack *ss, struct sigaltstack *oss);
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
// __mode_t umask(__mode_t mask);
// int fcntl(int fd, int cmd, ...);
// int fchown(int fd, __uid_t owner, __gid_t group);
// struct passwd *getpwnam(const char *name);
// double sin(double x);
// double log(double x);
// int rename(const char *old, const char *new);
// double strtod(const char *nptr, char **endptr);
// struct dirent64 *readdir64(DIR *dirp);
// int mkdir(const char *path, __mode_t mode);
// time_t time(time_t *timer);
// int fflush(FILE *stream);
// double sinh(double x);
// struct servent *getservbyname(const char *name, const char *proto);
__int64 __fastcall caml_startup__code_begin(__int64, unsigned __int64, __int64, __int64, __int64, __int64, double);
_QWORD *__fastcall caml_curry9(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry9_1(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry9_2(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry9_3(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry9_4(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry9_5(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry9_6(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry9_7(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall caml_curry9_8(); // weak
_QWORD *__fastcall caml_curry7(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry7_1(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry7_2(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry7_3(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry7_4(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry7_5(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall caml_curry7_6(); // weak
_QWORD *__fastcall caml_curry6(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry6_1(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry6_2(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry6_3(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry6_4(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall caml_curry6_5(); // weak
_QWORD *__fastcall caml_curry5(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry5_1(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry5_2(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry5_3(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall caml_curry5_4(); // weak
_QWORD *__fastcall caml_curry4(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry4_1(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry4_2(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall caml_curry4_3(); // weak
_QWORD *__fastcall caml_curry3(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall caml_curry3_1(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall caml_curry3_2(); // weak
_QWORD *__fastcall caml_curry2(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall caml_curry2_1(); // weak
__int64 __fastcall caml_tuplify2(); // weak
__int64 __fastcall caml_tuplify3(); // weak
__int64 __fastcall caml_send0(__int64 *);
__int64 __fastcall caml_apply6(__int64, __int64, __int64, __int64, __int64);
__int64 __fastcall caml_apply4(__int64, __int64, __int64);
__int64 __fastcall caml_apply3(__int64, __int64);
__int64 __fastcall caml_apply2(__int64);
__int64 camlStd_exit__code_begin();
__int64 __fastcall camlSource__code_begin(); // weak
unsigned __int64 *__fastcall camlSource__fun_161(unsigned __int64, __int64);
__int64 __fastcall camlSource__method_activate_143(); // weak
__int64 __fastcall camlSource__fun_173(__int64, unsigned __int64, _QWORD *);
_QWORD *__fastcall camlSource__toggle_init_127();
_QWORD *__fastcall camlSource__nth_toggle_init_149(double);
__int64 __fastcall camlSource__entry(double);
_QWORD *__fastcall camlSource__code_end(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlUnix__fun_1847(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlUnix__get_port_765(__int64);
_QWORD *__fastcall sub_40C4B8();
_QWORD *__fastcall sub_40C534(__int64, unsigned __int64);
_QWORD *__fastcall camlUnix__fun_1852(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlUnix__fun_1855(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlUnix__fun_1876(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1882(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1585(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1587();
void __fastcall camlUnix__fun_1589();
void __fastcall camlUnix__fun_1591(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1593();
void __fastcall camlUnix__fun_1595();
void __fastcall camlUnix__fun_1597(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1599();
void __fastcall camlUnix__fun_1601();
void __fastcall camlUnix__fun_1603(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1605(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1607(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1609(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1611(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1613(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1615(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1617();
void __fastcall camlUnix__fun_1619();
void __fastcall camlUnix__fun_1621();
void __fastcall camlUnix__fun_1623();
void __fastcall camlUnix__fun_1625(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1627();
void __fastcall camlUnix__fun_1629();
void __fastcall camlUnix__fun_1631(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1633(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1635(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1637(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1639(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1641(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1643(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1645(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1647(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1649(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1651(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1653(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1655(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1657(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1659();
void __fastcall camlUnix__fun_1661(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1663();
void __fastcall camlUnix__fun_1665(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1667(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1669(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1671(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1673(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1675(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1677(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1679(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1681(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1683(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1685();
void __fastcall camlUnix__fun_1687();
void __fastcall camlUnix__fun_1689();
void __fastcall camlUnix__fun_1691();
void __fastcall camlUnix__fun_1693(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1695();
void __fastcall camlUnix__fun_1697();
void __fastcall camlUnix__fun_1699(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1701(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1703(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1705(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1707(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1709(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1711(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1713(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1715(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1717();
void __fastcall camlUnix__fun_1719(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1721(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1723(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1725(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1727();
void __fastcall camlUnix__fun_1729(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1731();
void __fastcall camlUnix__fun_1733(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1735();
void __fastcall camlUnix__fun_1737();
void __fastcall camlUnix__fun_1739();
void __fastcall camlUnix__fun_1741();
void __fastcall camlUnix__fun_1743();
void __fastcall camlUnix__fun_1745();
void __fastcall camlUnix__fun_1747(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1749(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1751(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1753(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1755(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1757();
void __fastcall camlUnix__fun_1759();
void __fastcall camlUnix__fun_1761();
void __fastcall camlUnix__fun_1763(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1765(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1767(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1769(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1771(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1773();
void __fastcall camlUnix__fun_1775(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1777(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1779(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1781();
void __fastcall camlUnix__fun_1783(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1785(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1787();
void __fastcall camlUnix__fun_1789();
void __fastcall camlUnix__fun_1791();
void __fastcall camlUnix__fun_1793();
void __fastcall camlUnix__fun_1795();
void __fastcall camlUnix__fun_1797(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1799(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1801(__int64, unsigned __int64);
void __fastcall camlUnix__handle_unix_error_199(__int64);
__int64 __fastcall sub_40D5E0(__int64, __int64 (**)(void));
void __fastcall camlUnix__read_265(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlUnix__write_270(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlUnix__single_write_275(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlUnix__fun_1823(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1821(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1819(__int64, unsigned __int64);
void __fastcall camlUnix__fun_1817();
void __fastcall camlUnix__fun_1815();
void __fastcall camlUnix__fun_1813();
__int64 __fastcall camlUnix__try_set_close_on_exec_394(__int64, unsigned __int64);
__int64 __fastcall sub_40D83C(__int64, unsigned __int64);
void camlUnix__pause_436();
__int64 __fastcall camlUnix__is_inet6_addr_526(); // weak
__int64 __fastcall camlUnix__domain_of_sockaddr_555();
void __fastcall camlUnix__recv_584(__int64, __int64, __int64);
void __fastcall camlUnix__recvfrom_590(__int64, __int64, __int64);
void __fastcall camlUnix__send_596(__int64, __int64, __int64);
void __fastcall camlUnix__sendto_602(__int64, __int64, __int64, __int64);
void __fastcall camlUnix__fun_1835();
void __fastcall camlUnix__fun_1833();
void __fastcall camlUnix__getsockopt_669();
void __fastcall camlUnix__setsockopt_672();
void __fastcall camlUnix__getsockopt_int_676();
void __fastcall camlUnix__setsockopt_int_679();
void __fastcall camlUnix__getsockopt_optint_683();
void __fastcall camlUnix__setsockopt_optint_686();
void __fastcall camlUnix__getsockopt_float_690();
void __fastcall camlUnix__setsockopt_float_693();
void __fastcall camlUnix__getsockopt_error_697();
void __fastcall camlUnix__getaddrinfo_emulation_756(__int64, __int64, __int64, __int64, __int64, __int64, int, __int64, __int64);
void __fastcall sub_40E030(__int64, unsigned __int64, __int64, __int64, __int64, __int64, int, __int64, __int64);
__int64 __fastcall sub_40E0AC(__int64, unsigned __int64);
void __fastcall camlUnix__getaddrinfo_777(__int64, __int64, __int64, __int64, __int64, __int64, int, __int64, __int64);
_QWORD *__fastcall sub_40E208();
void __fastcall camlUnix__getnameinfo_emulation_798(__int64, unsigned __int64);
_QWORD *__fastcall sub_40E2E8(__int64, unsigned __int64);
_QWORD *__fastcall sub_40E380(__int64, __int64);
void __fastcall camlUnix__getnameinfo_807(__int64, unsigned __int64);
void __fastcall sub_40E4DC();
void __fastcall camlUnix__system_917(__int64, unsigned __int64);
void __fastcall sub_40E55C(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlUnix__safe_dup_920(__int64, unsigned __int64);
void __fastcall camlUnix__safe_close_924(__int64, unsigned __int64);
void __fastcall sub_40E640(__int64, unsigned __int64);
void __fastcall camlUnix__perform_redirections_926(__int64, unsigned __int64);
void __fastcall camlUnix__create_process_933(__int64, unsigned __int64);
void __fastcall sub_40E794(__int64, unsigned __int64);
void __fastcall camlUnix__create_process_env_940(__int64, unsigned __int64);
void __fastcall sub_40E828(__int64, unsigned __int64);
void __fastcall camlUnix__open_proc_975(__int64, __int64);
void __fastcall sub_40E978(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlUnix__open_process_in_983(__int64, unsigned __int64);
__int64 __fastcall camlUnix__open_process_out_988(__int64, unsigned __int64);
_QWORD *__fastcall camlUnix__open_process_993(__int64, unsigned __int64);
void __fastcall camlUnix__open_proc_full_1001(__int64, unsigned __int64, __int64, __int64);
void __fastcall sub_40EDE8(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlUnix__open_process_full_1011(__int64, unsigned __int64);
__int64 __fastcall camlUnix__find_proc_id_1023(__int64 a1, __int64 a2);
__int64 __fastcall sub_40F0B8(__int64 a1, __int64 a2);
void __fastcall camlUnix__waitpid_non_intr_1027();
void __fastcall sub_40F14C();
__int64 __fastcall camlUnix__close_process_in_1029(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlUnix__close_process_out_1032(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlUnix__close_process_1035(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_40F2D0(__int64, unsigned __int64);
__int64 __fastcall camlUnix__close_process_full_1039(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_40F390(__int64, unsigned __int64);
_QWORD *__fastcall camlUnix__open_connection_1044();
_QWORD *__fastcall sub_40F434();
void __fastcall camlUnix__shutdown_connection_1048(__int64, unsigned __int64);
void __fastcall camlUnix__accept_non_intr_1050(__int64, unsigned __int64);
void __fastcall sub_40F52C(__int64, unsigned __int64);
void __fastcall __noreturn camlUnix__establish_server_1052(); // weak
__int64 __fastcall camlUnix__entry(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_41018C(__int64, unsigned __int64);
__int64 __fastcall sub_4101E1(__int64, unsigned __int64);
__int64 camlUnixLabels__code_begin();
__int64 __fastcall camlPervasives__code_begin();
__int64 __fastcall camlPervasives__iter_210(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
void __fastcall sub_4112BC(__int64, unsigned __int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPervasives__build_result_267(__int64 *);
unsigned __int64 __fastcall camlPervasives__scan_273(__int64 a1, unsigned __int64 a2);
__int64 __fastcall camlPervasives__fun_524(); // weak
void __fastcall camlPervasives__fun_416();
void __fastcall camlPervasives__fun_418(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_420(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_422(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_424();
void __fastcall camlPervasives__fun_426(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_428(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_430(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_432(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_434();
void __fastcall camlPervasives__fun_436(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_438(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_440();
void __fastcall camlPervasives__fun_442();
void __fastcall camlPervasives__fun_444();
void __fastcall camlPervasives__fun_446();
void __fastcall camlPervasives__fun_448(__int64, unsigned __int64);
void __fastcall __noreturn camlPervasives__failwith_38(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall __noreturn camlPervasives__invalid_arg_40(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlPervasives__min_50();
void __fastcall camlPervasives__max_53();
__int64 __fastcall camlPervasives__abs_71(); // weak
__int64 __fastcall camlPervasives__lnot_76(); // weak
__int64 __fastcall camlPervasives___5e_136();
__int64 __fastcall camlPervasives__char_of_int_144(__int64, __int64, __int64, __int64, __int64, __int64);
char *__fastcall camlPervasives__string_of_bool_151();
__int64 __fastcall camlPervasives__bool_of_string_153(); // weak
void __fastcall camlPervasives__string_of_int_154();
__int64 __fastcall camlPervasives__valid_float_lexem_159(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPervasives__string_of_float_164();
_QWORD *__fastcall camlPervasives___40_167();
void __fastcall camlPervasives__open_out_gen_199(__int64);
void __fastcall camlPervasives__open_out_203();
void __fastcall camlPervasives__open_out_bin_205();
__int64 __fastcall camlPervasives__flush_all_209(__int64, unsigned __int64);
void __fastcall camlPervasives__output_string_215();
void __fastcall camlPervasives__output_218(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlPervasives__output_value_226();
void __fastcall camlPervasives__close_out_233(__int64, unsigned __int64);
void __fastcall camlPervasives__close_out_noerr_235(__int64, unsigned __int64);
__int64 __fastcall sub_411D40(__int64, unsigned __int64);
void __fastcall sub_411D6C(__int64, unsigned __int64);
void __fastcall camlPervasives__open_in_gen_238(__int64);
void __fastcall camlPervasives__open_in_242();
void __fastcall camlPervasives__open_in_bin_244();
void __fastcall camlPervasives__input_248(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPervasives__unsafe_really_input_253(__int64, __int64);
__int64 __fastcall camlPervasives__really_input_259(__int64, __int64, __int64, __int64, __int64, __int64);
unsigned __int64 __fastcall camlPervasives__input_line_265(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall camlPervasives__close_in_noerr_287(__int64, unsigned __int64);
void __fastcall sub_411FE8(__int64, unsigned __int64);
void __fastcall camlPervasives__print_char_290();
void camlPervasives__print_string_292();
void camlPervasives__print_int_294();
void camlPervasives__print_float_296();
void camlPervasives__print_endline_298();
void camlPervasives__print_newline_300();
void __fastcall camlPervasives__prerr_char_301();
void camlPervasives__prerr_string_303();
void camlPervasives__prerr_int_305();
void camlPervasives__prerr_float_307();
void camlPervasives__prerr_endline_309();
void camlPervasives__prerr_newline_311();
unsigned __int64 __fastcall camlPervasives__read_line_312(__int64 a1, unsigned __int64 a2);
void __fastcall camlPervasives__read_int_313(__int64, unsigned __int64);
void __fastcall camlPervasives__read_float_314(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_519(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_517(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_515();
void __fastcall camlPervasives__fun_513(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_511(__int64, unsigned __int64);
void __fastcall camlPervasives__fun_509();
__int64 __fastcall camlPervasives___5e_5e_336(); // weak
__int64 __fastcall camlPervasives__string_of_format_339(__int64, unsigned __int64);
__int64 __fastcall camlPervasives__at_exit_346(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPervasives__do_at_exit_349(); // weak
void __fastcall camlPervasives__exit_350(__int64, unsigned __int64);
__int64 __fastcall camlPervasives__entry(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__code_begin(unsigned __int64, double *, unsigned __int64, __int64);
__int64 __fastcall camlArray__size_93();
__int64 __fastcall camlArray__fill_98(float, __int64, double *, __int64, __int64, __int64, __int64);
__int64 (__fastcall **__fastcall camlArray__find_init_105(double, __int64, __int64, __int64, __int64, __int64, __int64))();
unsigned __int64 __fastcall camlArray__tolist_150(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__fill_162(__int64);
__int64 __fastcall camlArray__maxson_182(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall camlArray__trickledown_187(double *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__trickle_192(double *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_413A14(double *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__bubbledown_197(__int64, double *, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__bubble_201(__int64, double *, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_413B70(__int64, double *, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__trickleup_205(unsigned __int64 *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__merge_218(__int64, unsigned __int64, __int64, __int64, unsigned __int64, __int64);
__int64 __fastcall camlArray__isortto_236(signed __int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__sortto_244(unsigned __int64, __int64, __int64, __int64, __int64, __int64);
void *__fastcall camlArray__init_65();
__int64 __fastcall camlArray__make_matrix_70(unsigned __int64);
void *__fastcall camlArray__copy_77(__int64, __int64, __int64, __int64, __int64, __int64);
void *__fastcall camlArray__append_82(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__concat_aux_90(float);
__int64 (__fastcall **__fastcall camlArray__concat_103(double, __int64, __int64, __int64, __int64, __int64, __int64))();
void *__fastcall camlArray__sub_108(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__fill_114(__int64, double *, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__blit_120(unsigned __int64 *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__iter_128(__int64, __int64, __int64, __int64, __int64, __int64);
void *__fastcall camlArray__map_132(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__iteri_138(__int64, __int64, __int64, __int64, __int64, __int64);
void *__fastcall camlArray__mapi_142(__int64, __int64, __int64, __int64, __int64, __int64);
unsigned __int64 __fastcall camlArray__to_list_148(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__list_length_153();
void *__fastcall camlArray__of_list_157();
unsigned __int64 __fastcall camlArray__fold_left_166(__int64, __int64, __int64, __int64, __int64, __int64);
unsigned __int64 __fastcall camlArray__fold_right_172(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__sort_179(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__stable_sort_215(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlArray__entry(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__code_begin(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlList__rmap_f_98(__int64, __int64);
_QWORD *__fastcall camlList__rmap2_f_131(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlList__find_235(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlList__part_243(__int64 *, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlList__rev_merge_279(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlList__rev_merge_rev_289(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlList__rev_sort_300(__int64, __int64 *, __int64 *, __int64, __int64, __int64);
_QWORD *__fastcall camlList__sort_299(__int64, __int64 *, __int64 *, __int64, __int64, __int64);
__int64 __fastcall camlList__length_aux_58();
__int64 __fastcall camlList__length_62(); // weak
__int64 __fastcall camlList__hd_64(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__tl_67(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__nth_70(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlList__rev_append_79(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlList__rev_84(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__flatten_86();
__int64 __fastcall camlList__map_90();
_QWORD *__fastcall camlList__rev_map_95(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__iter_102();
__int64 __fastcall camlList__fold_left_106(__int64);
__int64 __fastcall camlList__fold_right_112(__int64);
__int64 __fastcall camlList__map2_118(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlList__rev_map2_127(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__iter2_139(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__fold_left2_147(__int64, __int64 *, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__fold_right2_156(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__for_all_165();
__int64 __fastcall camlList__exists_169(); // weak
__int64 __fastcall camlList__for_all2_173(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__exists2_181(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__mem_189();
__int64 __fastcall camlList__memq_193(); // weak
__int64 __fastcall camlList__assoc_197(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__assq_202(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__mem_assoc_207(); // weak
__int64 __fastcall camlList__mem_assq_212(); // weak
__int64 __fastcall camlList__remove_assoc_217();
__int64 __fastcall camlList__remove_assq_223();
__int64 __fastcall camlList__find_229(__int64 (*)(void), __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlList__find_all_233(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlList__partition_240(__int64, __int64, __int64, __int64, __int64, __int64);
void *__fastcall camlList__split_248();
__int64 __fastcall camlList__combine_254(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 *__fastcall camlList__merge_261(__int64 *);
__int64 __fastcall camlList__chop_271(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlList__stable_sort_276(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 camlList__entry();
__int64 __fastcall camlChar__code_begin(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlChar__escaped_66(__int64, unsigned __int64);
__int64 __fastcall camlChar__lowercase_71(); // weak
__int64 __fastcall camlChar__uppercase_73(); // weak
__int64 __fastcall camlChar__compare_76(); // weak
__int64 camlChar__entry();
__int64 __fastcall camlString__code_begin(); // weak
__int64 __fastcall camlString__fun_191(); // weak
__int64 __fastcall camlString__make_66(__int64, unsigned __int64);
__int64 __fastcall camlString__copy_70(__int64, unsigned __int64);
__int64 __fastcall camlString__sub_74(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__fill_79(float, __int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__blit_84(__int64, __int64, __int64);
__int64 __fastcall camlString__iter_90(); // weak
void *__fastcall camlString__concat_94(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__escaped_108(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__map_118();
__int64 __fastcall camlString__uppercase_124(); // weak
__int64 __fastcall camlString__lowercase_126(); // weak
_BYTE *__fastcall camlString__apply1_128();
_BYTE *camlString__capitalize_132();
_BYTE *camlString__uncapitalize_134();
__int64 __fastcall camlString__index_rec_136(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__index_141(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__index_from_144(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__rindex_rec_149(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__rindex_153(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__rindex_from_156(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__contains_from_160(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_4191CC(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__contains_165(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlString__rcontains_from_168(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_419264(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlString__compare_173();
__int64 camlString__entry();
void __fastcall __noreturn camlSys__code_begin(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlSys__set_signal_85();
__int64 __fastcall camlSys__catch_break_110(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlSys__entry(__int64, unsigned __int64);
__int64 __fastcall camlHashtbl__code_begin(__int64, __int64);
__int64 __fastcall camlHashtbl__find_in_bucket_241(__int64, __int64);
_QWORD *__fastcall camlHashtbl__replace_bucket_249(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlHashtbl__mem_in_bucket_258();
__int64 __fastcall camlHashtbl__insert_bucket_96();
__int64 __fastcall camlHashtbl__remove_bucket_111();
__int64 __fastcall camlHashtbl__find_in_bucket_136();
_QWORD *__fastcall camlHashtbl__replace_bucket_144(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlHashtbl__mem_in_bucket_153();
__int64 __fastcall camlHashtbl__do_bucket_160();
__int64 __fastcall camlHashtbl__do_bucket_170(__int64);
__int64 __fastcall camlHashtbl__safehash_205(); // weak
__int64 __fastcall camlHashtbl__add_207(__int64 (*)(void), __int64 (**)(void));
__int64 __fastcall camlHashtbl__remove_213(__int64 (*)(void), __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlHashtbl__find_rec_221(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlHashtbl__find_226(__int64 (*)(void));
__int64 __fastcall camlHashtbl__find_all_238(__int64 (*)(void), __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlHashtbl__replace_245(__int64, unsigned __int64);
__int64 __fastcall sub_41A778(__int64 (*a1)(void), unsigned __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall camlHashtbl__mem_255(__int64 (*)(void), __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlHashtbl__hash_59();
_QWORD *__fastcall camlHashtbl__create_79();
__int64 __fastcall camlHashtbl__clear_82(__int64, unsigned __int64);
_QWORD *__fastcall camlHashtbl__copy_85(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlHashtbl__length_87(); // weak
__int64 __fastcall camlHashtbl__resize_89();
__int64 __fastcall camlHashtbl__add_102(__int64, __int64);
unsigned __int64 __fastcall camlHashtbl__remove_108(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall camlHashtbl__find_rec_116(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlHashtbl__find_121(__int64, __int64);
__int64 __fastcall camlHashtbl__find_all_133(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlHashtbl__replace_140(__int64);
__int64 __fastcall sub_41B288(__int64, unsigned __int64, unsigned __int64, __int64, __int64, __int64);
__int64 __fastcall camlHashtbl__mem_150(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall camlHashtbl__iter_157(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlHashtbl__fold_166(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlHashtbl__Make_279(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 camlHashtbl__entry();
void __fastcall camlMarshal__code_begin(__int64, unsigned __int64);
void __fastcall camlMarshal__fun_94();
void __fastcall camlMarshal__to_buffer_66(__int64, __int64, __int64);
void __fastcall camlMarshal__data_size_76(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlMarshal__total_size_79(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlMarshal__from_string_82(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 camlMarshal__entry();
void __fastcall camlObj__code_begin(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlObj__set_double_field_72(double *);
void __fastcall camlObj__marshal_80();
_QWORD *__fastcall camlObj__unmarshal_82(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 camlObj__entry();
__int64 __fastcall camlMap__code_begin(__int64);
__int64 __fastcall camlMap__equal_aux_238(__int64);
__int64 __fastcall camlMap__height_85(); // weak
_QWORD *__fastcall camlMap__create_87(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlMap__bal_94(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlMap__is_empty_120(); // weak
_QWORD *__fastcall camlMap__add_121(__int64 *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlMap__find_130(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlMap__mem_137(__int64);
_QWORD *__fastcall camlMap__min_binding_144(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlMap__remove_min_binding_152(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlMap__merge_160(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlMap__remove_167(__int64);
__int64 __fastcall camlMap__iter_175();
__int64 __fastcall camlMap__map_181();
__int64 __fastcall camlMap__mapi_188();
__int64 __fastcall camlMap__fold_195(__int64);
_QWORD *__fastcall camlMap__cons_enum_210(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlMap__compare_217(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlMap__equal_234(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlMap__Make_249(__int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlMap__fun_473(__int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlMap__entry(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__code_begin(__int64, _QWORD *, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__advance_139(__int64);
__int64 __fastcall camlBuffer__subst_155(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlBuffer__create_67(__int64, unsigned __int64);
__int64 __fastcall camlBuffer__contents_72(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__sub_74(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__blit_79(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__nth_85(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__length_88();
__int64 __fastcall camlBuffer__clear_90(); // weak
__int64 __fastcall camlBuffer__reset_92(); // weak
__int64 __fastcall camlBuffer__resize_94(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__add_char_100(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__add_substring_104(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__add_string_110(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__add_buffer_115(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__add_channel_118(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlBuffer__output_buffer_122(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__closing_125(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__advance_to_closing_126(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__advance_to_non_alpha_136(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlBuffer__find_ident_142(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlBuffer__add_substitute_150(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 camlBuffer__entry();
__int64 __fastcall camlPrintf__code_begin(); // weak
__int64 __fastcall camlPrintf__skip_int_literal_120();
__int64 __fastcall camlPrintf__sub_sub_157(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__sub_156(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__loop_187();
__int64 __fastcall camlPrintf__fun_594(__int64);
_QWORD *__fastcall camlPrintf__fun_597(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__got_spec_336(_QWORD *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__got_spec_329(__int64);
__int64 __fastcall camlPrintf__cont_m_397(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__cont_f_396(__int64);
__int64 __fastcall camlPrintf__cont_t_395(__int64, __int64);
__int64 __fastcall camlPrintf__cont_a_394(__int64, __int64, __int64);
__int64 __fastcall camlPrintf__cont_s_393(__int64, __int64);
__int64 __fastcall camlPrintf__doprn_392(__int64);
__int64 __fastcall camlPrintf__fun_716(); // weak
_QWORD *__fastcall camlPrintf__parse_97(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__skip_positional_spec_118(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__fill_format_124(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__sub_fmt_152(_QWORD *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__scan_fmt_172(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__scan_conv_171(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__scan_flags_170(_QWORD *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__add_char_194(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__add_conv_197(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__incr_ac_215(__int64);
__int64 __fastcall camlPrintf__add_conv_219(__int64, __int64);
__int64 __fastcall camlPrintf__add_char_220(); // weak
__int64 __fastcall camlPrintf__loop_232(__int64);
_QWORD *__fastcall camlPrintf__loop_268(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__fun_616(double *, double *, double *, double *, __int64);
__int64 __fastcall camlPrintf__fun_613(double *, double *, double *, __int64);
__int64 __fastcall camlPrintf__fun_610(double *, double *, __int64);
__int64 __fastcall camlPrintf__fun_607(double *, __int64);
__int64 __fastcall camlPrintf__fun_604(__int64);
__int64 __fastcall camlPrintf__fun_601();
__int64 __fastcall camlPrintf__get_int_literal_286(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 camlPrintf__add_dot_302();
__int64 __fastcall camlPrintf__loop_305();
__int64 __fastcall camlPrintf__get_arg_320(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__scan_conv_325(__int64, __int64, __int64 *);
__int64 __fastcall camlPrintf__scan_flags_324(__int64, __int64, __int64);
__int64 __fastcall camlPrintf__scan_positional_323(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__pr_386(__int64, __int64, _QWORD *);
__int64 __fastcall camlPrintf__fun_710(); // weak
__int64 (__fastcall **camlPrintf__fun_714())();
__int64 __fastcall camlPrintf__fun_719(); // weak
__int64 __fastcall camlPrintf__fun_727(); // weak
__int64 __fastcall camlPrintf__fun_724(); // weak
__int64 __fastcall camlPrintf__fun_730(); // weak
__int64 __fastcall camlPrintf__fun_737(); // weak
__int64 __fastcall camlPrintf__index_of_int_65(__int64, __int64);
__int64 __fastcall camlPrintf__add_int_index_68(__int64, __int64);
__int64 __fastcall camlPrintf__index_of_literal_position_72(__int64, __int64);
__int64 __fastcall camlPrintf__to_string_82(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall __noreturn camlPrintf__bad_conversion_85(__int64, unsigned __int64);
void __fastcall __noreturn camlPrintf__bad_conversion_format_89(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
void __fastcall __noreturn camlPrintf__incomplete_format_93(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlPrintf__parse_string_conversion_95(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall sub_420A44(__int64, __int64, __int64, __int64, __int64, __int64);
unsigned __int64 __fastcall camlPrintf__pad_string_100(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall camlPrintf__format_string_108(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall camlPrintf__extract_format_113(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__extract_format_int_131(__int64, __int64, unsigned __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__extract_format_float_138(__int64, __int64, unsigned __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__sub_format_145(__int64, __int64, __int64);
__int64 __fastcall camlPrintf__sub_format_for_printf_163();
__int64 __fastcall camlPrintf__iter_on_format_args_165(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__summarize_format_type_190(__int64, unsigned __int64);
_QWORD *__fastcall camlPrintf__ac_of_format_212(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__count_arguments_of_format_226(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__list_iter_i_229(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlPrintf__kapr_237(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__scan_positional_spec_280(__int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__next_index_290(); // weak
__int64 __fastcall camlPrintf__get_index_293(); // weak
void *__fastcall camlPrintf__valid_float_lexeme_298(__int64, __int64, __int64, __int64, __int64, __int64);
void *__fastcall camlPrintf__fun_630();
__int64 __fastcall camlPrintf__scan_format_310(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlPrintf__mkprintf_377(__int64, __int64, __int64);
__int64 __fastcall camlPrintf__kfprintf_418(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__ifprintf_421(); // weak
__int64 __fastcall camlPrintf__fprintf_423(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__printf_425(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__eprintf_427(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__kbprintf_429(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__bprintf_432(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlPrintf__get_buff_434(__int64, unsigned __int64);
__int64 __fastcall camlPrintf__get_contents_437(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlPrintf__get_cont_440(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 camlPrintf__ksprintf_443();
__int64 __fastcall camlPrintf__sprintf_446(); // weak
__int64 __fastcall camlPrintf__entry(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlCallback__code_begin();
void __fastcall camlCallback__register_exception_62(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 camlCallback__entry();
__int64 *__fastcall camlCamlinternalOO__code_begin(__int64 *);
__int64 __fastcall camlCamlinternalOO__fun_727(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_4221B0(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlCamlinternalOO__fun_730(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__fun_733(__int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__fun_737(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__fun_740(__int64, __int64);
__int64 __fastcall camlCamlinternalOO__fun_751(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlCamlinternalOO__fun_757(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
void __fastcall __noreturn camlCamlinternalOO__undef_322(char **, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__lookup_key_376(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlCamlinternalOO__fun_784(); // weak
__int64 __fastcall camlCamlinternalOO__fun_788(); // weak
__int64 __fastcall camlCamlinternalOO__fun_792(); // weak
__int64 __fastcall camlCamlinternalOO__fun_796(); // weak
__int64 __fastcall camlCamlinternalOO__fun_800(__int64);
__int64 __fastcall camlCamlinternalOO__fun_804(); // weak
__int64 __fastcall camlCamlinternalOO__fun_808(); // weak
__int64 __fastcall camlCamlinternalOO__fun_812(); // weak
__int64 __fastcall camlCamlinternalOO__fun_816(); // weak
__int64 __fastcall camlCamlinternalOO__fun_820(); // weak
__int64 __fastcall camlCamlinternalOO__fun_824(); // weak
__int64 __fastcall camlCamlinternalOO__fun_828(); // weak
__int64 __fastcall camlCamlinternalOO__fun_832(); // weak
__int64 __fastcall camlCamlinternalOO__fun_836(); // weak
__int64 __fastcall camlCamlinternalOO__fun_840(); // weak
__int64 __fastcall camlCamlinternalOO__fun_844(); // weak
__int64 __fastcall camlCamlinternalOO__fun_848(); // weak
__int64 __fastcall camlCamlinternalOO__fun_852(); // weak
__int64 __fastcall camlCamlinternalOO__fun_856(); // weak
__int64 __fastcall camlCamlinternalOO__fun_860(); // weak
__int64 __fastcall camlCamlinternalOO__fun_864(); // weak
__int64 __fastcall camlCamlinternalOO__fun_868(); // weak
__int64 __fastcall camlCamlinternalOO__fun_872(); // weak
__int64 __fastcall camlCamlinternalOO__fun_876(); // weak
__int64 __fastcall camlCamlinternalOO__next_551(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 camlCamlinternalOO__new_id_59();
__int64 __fastcall camlCamlinternalOO__set_id_61();
__int64 __fastcall camlCamlinternalOO__copy_65(__int64, unsigned __int64);
void __fastcall camlCamlinternalOO__public_method_label_102(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall camlCamlinternalOO__compare_139();
void __fastcall camlCamlinternalOO__compare_157();
void __fastcall camlCamlinternalOO__compare_161();
__int64 __fastcall camlCamlinternalOO__fit_size_184();
__int64 __fastcall camlCamlinternalOO__new_table_186();
__int64 __fastcall camlCamlinternalOO__resize_191();
__int64 __fastcall camlCamlinternalOO__put_196(unsigned __int64, unsigned __int64);
__int64 __fastcall camlCamlinternalOO__new_method_203();
__int64 __fastcall camlCamlinternalOO__get_method_label_206(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_423040(__int64, __int64, __int64, __int64, __int64, __int64);
void *__fastcall camlCamlinternalOO__get_method_labels_210(__int64, __int64);
__int64 __fastcall camlCamlinternalOO__set_method_213(unsigned __int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlCamlinternalOO__get_method_217(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_4231C4(__int64, __int64, __int64, __int64, __int64, __int64);
unsigned __int64 __fastcall camlCamlinternalOO__to_list_220(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlCamlinternalOO__narrow_222(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlCamlinternalOO__widen_244(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlCamlinternalOO__new_slot_257();
__int64 __fastcall camlCamlinternalOO__new_variable_260(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_423748(__int64, __int64, __int64, __int64, __int64, __int64);
void *__fastcall camlCamlinternalOO__to_array_264();
__int64 __fastcall camlCamlinternalOO__new_methods_variables_266(__int64);
__int64 __fastcall camlCamlinternalOO__get_variable_276(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_42399C(__int64, __int64, __int64, __int64, __int64, __int64);
void *__fastcall camlCamlinternalOO__get_variables_279(__int64, __int64);
__int64 __fastcall camlCamlinternalOO__add_initializer_282(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlCamlinternalOO__create_table_285(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 (__fastcall **__fastcall camlCamlinternalOO__init_class_292(__int64, __int64, __int64, __int64, __int64, __int64, double))();
__int64 (__fastcall **__fastcall camlCamlinternalOO__inherits_294(__int64, unsigned __int64, __int64, __int64, __int64, __int64, double))();
_QWORD *__fastcall camlCamlinternalOO__make_class_304(__int64, __int64, __int64, __int64, __int64, __int64, double);
__int64 __fastcall camlCamlinternalOO__make_class_store_314(unsigned __int64 *, __int64, __int64, __int64, __int64, __int64, double);
_QWORD *__fastcall camlCamlinternalOO__dummy_class_320(__int64, __int64, __int64, __int64, __int64, __int64);
unsigned __int64 *__fastcall camlCamlinternalOO__create_object_323();
unsigned __int64 *__fastcall camlCamlinternalOO__create_object_opt_326();
__int64 __fastcall camlCamlinternalOO__iter_f_330();
__int64 __fastcall camlCamlinternalOO__run_initializers_334();
__int64 __fastcall camlCamlinternalOO__run_initializers_opt_338(__int64);
unsigned __int64 *__fastcall camlCamlinternalOO__create_object_and_run_initializers_343();
_QWORD *__fastcall camlCamlinternalOO__build_path_364(__int64, _QWORD *, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__lookup_keys_371(__int64, unsigned __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__lookup_tables_379(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__get_const_383(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__get_var_386(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__get_env_389(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__get_meth_393(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__set_var_396(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__app_const_400(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__app_var_404(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__app_env_408(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__app_meth_413(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__app_const_const_417(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__app_const_var_422(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__app_const_meth_427(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__app_var_const_432(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__app_meth_const_437(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__app_const_env_442(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__app_env_const_448(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__meth_app_const_454(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__meth_app_var_458(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__meth_app_env_462(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__meth_app_meth_467(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__send_const_471(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__send_var_476(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__send_env_481(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__send_meth_487(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlCamlinternalOO__new_cache_492(__int64, unsigned __int64);
__int64 __fastcall camlCamlinternalOO__method_impl_547(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlCamlinternalOO__set_methods_609(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall camlCamlinternalOO__stats_623(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall camlCamlinternalOO__entry(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall unix_accept(__int64);
__int64 __fastcall unix_access(char *name, __int64 *);
_QWORD *__fastcall unix_inet_addr_of_string(char *cp);
__int64 __fastcall unix_alarm(__int64);
__int64 __fastcall unix_bind(__int64, __int64 *);
__int64 __fastcall unix_chdir(void *);
__int64 __fastcall unix_chmod(void *, __int64);
__int64 __fastcall unix_chown(void *, __int64, __int64);
__int64 __fastcall unix_chroot(void *);
__int64 __fastcall unix_close(__int64);
__int64 __fastcall unix_closedir(DIR **);
__int64 __fastcall unix_connect(__int64, __int64 *);
__int64 __fastcall unix_dup(__int64);
__int64 __fastcall unix_dup2(__int64, __int64);
char *unix_environment();
_QWORD *__fastcall unix_error_message(__int64 a1);
void __fastcall __noreturn unix_execv(char *path, __int64);
void __fastcall __noreturn unix_execve(char *path, __int64, __int64);
void __fastcall __noreturn unix_execvpe(char *file, __int64, __int64);
void __fastcall __noreturn unix_execvp(char *file, __int64);
__int64 __fastcall unix_fchmod(__int64, __int64);
__int64 __fastcall unix_fchown(__int64, __int64, __int64);
__int64 __fastcall unix_clear_close_on_exec(__int64);
__int64 __fastcall unix_set_close_on_exec(__int64);
__int64 __fastcall unix_clear_nonblock(__int64);
__int64 __fastcall unix_set_nonblock(__int64);
__int64 __fastcall unix_fork(); // weak
__int64 __fastcall unix_ftruncate_64(__int64, __int64);
__int64 __fastcall unix_ftruncate(__int64, __int64);
__int64 __fastcall unix_getaddrinfo(char *, char *, __int64);
_QWORD *unix_getcwd();
__int64 __fastcall unix_getegid(); // weak
__int64 __fastcall unix_geteuid(); // weak
__int64 __fastcall unix_getgid(); // weak
_QWORD *__fastcall alloc_group_entry(__int64);
_QWORD *__fastcall unix_getgrgid(__int64);
_QWORD *__fastcall unix_getgrnam(const char *);
char *unix_getgroups();
_QWORD *__fastcall alloc_host_entry(__int64);
_QWORD *__fastcall unix_gethostbyname(char *src);
_QWORD *__fastcall unix_gethostbyaddr(int *);
_QWORD *__fastcall alloc_one_addr(void *src);
_QWORD *unix_gethostname();
_QWORD *unix_getlogin();
_QWORD *__fastcall unix_getnameinfo(__int64 *, __int64 *);
_QWORD *__fastcall unix_getpeername(__int64);
__int64 __fastcall unix_getpid(); // weak
__int64 __fastcall unix_getppid(); // weak
_QWORD *__fastcall alloc_proto_entry(__int64);
_QWORD *__fastcall unix_getprotobynumber(__int64);
_QWORD *__fastcall unix_getprotobyname(const char *);
_QWORD *__fastcall alloc_passwd_entry(__int64);
_QWORD *__fastcall unix_getpwuid(__int64);
_QWORD *__fastcall unix_getpwnam(const char *);
__int64 __fastcall unix_gettimeofday(); // weak
_QWORD *__fastcall alloc_service_entry(__int64);
_QWORD *__fastcall unix_getservbyport(__int64, const char *);
_QWORD *__fastcall unix_getservbyname(const char *, const char *);
_QWORD *__fastcall unix_getsockname(__int64);
__int64 __fastcall unix_getuid(); // weak
_QWORD *__fastcall alloc_tm(int *);
_QWORD *__fastcall unix_mktime(__int64 *);
_QWORD *__fastcall unix_localtime(double *);
_QWORD *__fastcall unix_gmtime(double *);
unsigned __int64 __fastcall unix_isatty(__int64);
double *__fastcall unix_convert_itimer(_QWORD *);
double *__fastcall unix_getitimer(__int64);
unsigned __int64 __fastcall unix_set_timeval(_QWORD *, double);
double *__fastcall unix_setitimer(__int64, double *);
__int64 __fastcall unix_kill(__int64, __int64);
__int64 __fastcall unix_link(const char *, void *);
__int64 __fastcall unix_listen(__int64, __int64);
__int64 __fastcall unix_lockf(unsigned __int64, __int64, __int64);
_QWORD *__fastcall unix_lseek_64(__int64, __int64, __int64);
__off64_t __fastcall unix_lseek(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall unix_mkdir(void *, __int64);
__int64 __fastcall unix_mkfifo(void *, __int64);
__int64 __fastcall unix_nice(__int64);
__int64 __fastcall unix_open(char *, __int64 *, __int64);
_QWORD *__fastcall unix_opendir(char *);
_QWORD *unix_pipe();
__int64 __fastcall unix_putenv(void *src, void *); // idb
__int64 __fastcall unix_read(__int64, __int64, __int64, __int64);
_QWORD *__fastcall unix_readdir(DIR **a1);
_QWORD *__fastcall unix_readlink(char *a1);
__int64 __fastcall unix_rename(void *, const char *);
__int64 __fastcall unix_rewinddir(DIR **);
__int64 __fastcall unix_rmdir(void *);
__int64 __fastcall fdlist_to_fdset(_QWORD *, void *, _DWORD *);
__int64 __fastcall fdset_to_fdlist(_QWORD *, __int64);
_QWORD *__fastcall unix_select(_QWORD *, _QWORD *, _QWORD *, double *);
__int64 __fastcall unix_sendto_native(__int64, __int64, __int64, __int64, __int64 *, __int64 *);
__int64 __fastcall unix_sendto(__int64);
__int64 __fastcall unix_send(__int64, __int64, __int64, __int64, __int64 *);
_QWORD *__fastcall unix_recvfrom(__int64, __int64, __int64, __int64, __int64 *);
__int64 __fastcall unix_recv(__int64, __int64, __int64, __int64, __int64 *);
__int64 __fastcall unix_setgid(__int64);
__int64 __fastcall unix_setsid(); // weak
__int64 __fastcall unix_setuid(__int64);
__int64 __fastcall unix_shutdown(__int64, __int64);
int __fastcall decode_sigset(__int64 *, sigset_t *);
__int64 __fastcall unix_sigsuspend(__int64 *);
__int64 __fastcall encode_sigset(sigset_t *set); // idb
__int64 __fastcall unix_sigpending(); // weak
__int64 __fastcall unix_sigprocmask(__int64, __int64 *);
__int64 __fastcall unix_sleep(__int64);
__int64 __fastcall unix_socket(__int64, __int64, __int64);
unsigned __int16 __fastcall get_sockaddr(__int64 *, __int64, _DWORD *);
_QWORD *__fastcall alloc_inet6_addr(_QWORD *);
_DWORD *__fastcall alloc_inet_addr(_DWORD *);
_QWORD *__fastcall alloc_sockaddr(__int16 *, __int64, int);
_QWORD *__fastcall unix_socketpair(__int64, __int64, __int64);
__int64 __fastcall unix_setsockopt_aux(void *, unsigned int, int, int, __int64, double *);
__int64 __fastcall unix_setsockopt(__int64, __int64, __int64, double *);
__int64 __fastcall unix_getsockopt_aux(void *, int, int, int, __int64);
__int64 __fastcall unix_getsockopt(__int64, __int64, __int64);
_QWORD *__fastcall stat_aux(int, __int64);
_QWORD *__fastcall unix_fstat_64(__int64);
_QWORD *__fastcall unix_lstat_64(char *filename);
_QWORD *__fastcall unix_stat_64(char *filename);
_QWORD *__fastcall unix_fstat(__int64);
_QWORD *__fastcall unix_lstat(char *filename);
_QWORD *__fastcall unix_stat(char *filename);
_QWORD *__fastcall unix_string_of_inet_addr(void *cp);
__int64 __fastcall unix_symlink(const char *, void *);
__int64 __fastcall unix_tcflow(__int64, __int64);
__int64 __fastcall unix_tcflush(__int64, __int64);
__int64 __fastcall unix_tcdrain(__int64);
__int64 __fastcall unix_tcsendbreak(__int64, __int64);
__int64 __fastcall unix_tcsetattr(__int64, __int64, __int64 *);
char *__fastcall unix_tcgetattr(__int64);
__int64 __fastcall unix_time(); // weak
double *unix_times();
__int64 __fastcall unix_truncate_64(void *, __int64);
__int64 __fastcall unix_truncate(void *, __int64);
__int64 __fastcall unix_umask(__int64);
_QWORD *__fastcall unix_error_of_code(int);
void __fastcall __noreturn unix_error(int, void *, void *);
void __fastcall __noreturn uerror(void *, void *);
__int64 __fastcall unix_unlink(void *);
__int64 __fastcall unix_utimes(char *file, double *, double *);
_QWORD *__fastcall alloc_process_status(int, __int16);
_QWORD *__fastcall unix_waitpid(__int64 *, __int64);
_QWORD *unix_wait();
__int64 __fastcall unix_single_write(__int64, __int64, __int64, __int64);
__int64 __fastcall unix_write(unsigned __int64, __int64, __int64, __int64);
__int64 __fastcall cst_to_constr(int, _DWORD *, int, int);
_QWORD *__fastcall cstringvect(__int64);
__int64 __fastcall scanmult(__int64, __int64 *);
__int64 __fastcall caml_main(const char **, double);
int __cdecl main(int argc, const char **argv, const char **envp);
void __fastcall __noreturn caml_raise(__int64);
void __noreturn caml_array_bound_error();
void __noreturn caml_raise_stack_overflow();
void __noreturn caml_raise_out_of_memory();
void __fastcall __noreturn caml_raise_with_args(__int64, int, __int64);
void __fastcall __noreturn caml_raise_with_arg(__int64, __int64);
void __fastcall __noreturn caml_raise_sys_error(__int64);
void __fastcall __noreturn caml_raise_with_string(__int64, void *);
void __fastcall __noreturn caml_invalid_argument(void *);
void __fastcall __noreturn caml_failwith(void *);
void __fastcall __noreturn caml_raise_constant(__int64);
void __noreturn caml_raise_sys_blocked_io();
void __noreturn caml_raise_not_found();
void __noreturn caml_raise_zero_divide();
void __noreturn caml_raise_end_of_file();
void __fastcall caml_do_local_roots(void (__fastcall *)(_QWORD, _QWORD *), __int64, unsigned __int64, __int64, _QWORD *);
_QWORD *__fastcall caml_register_dyn_global(__int64);
void __fastcall caml_register_frametable(__int64);
char *caml_init_frame_descriptors();
__int64 (__fastcall *__fastcall caml_do_roots(void (__fastcall *)(__int64, __int64 *)))(_QWORD);
__int64 (__fastcall *caml_darken_all_roots())(_QWORD);
__int64 (__fastcall *caml_oldify_local_roots())(_QWORD);
__int64 __fastcall caml_iterate_global_roots(__int64 (__fastcall *)(_QWORD, _QWORD), __int64);
__int64 __fastcall caml_scan_global_roots(__int64 (__fastcall *)(_QWORD, _QWORD));
_QWORD *__fastcall caml_insert_global_root(__int64, unsigned __int64);
_QWORD *__fastcall caml_register_global_root(unsigned __int64);
void __fastcall caml_scan_global_young_roots(__int64 (__fastcall *)(_QWORD, _QWORD));
void __fastcall caml_delete_global_root(__int64, unsigned __int64);
void __fastcall caml_remove_global_root(unsigned __int64);
void __fastcall caml_modify_generational_global_root(unsigned __int64 *, unsigned __int64);
void __fastcall caml_remove_generational_global_root(unsigned __int64 *);
void __fastcall caml_register_generational_global_root(unsigned __int64 *);
__int64 __fastcall caml_record_signal(int);
void caml_enter_blocking_section_default();
void caml_leave_blocking_section_default();
__int64 __fastcall caml_try_leave_blocking_section_default(); // weak
__int64 caml_urge_major_slice();
__int64 __fastcall caml_convert_signal_number(unsigned int);
__int64 __fastcall caml_rev_convert_signal_number(unsigned int);
__int64 __fastcall caml_execute_signal(int signo, int);
__int64 caml_process_pending_signals();
__int64 __fastcall caml_install_signal_handler(__int64, __int64);
__int64 caml_leave_blocking_section();
__int64 caml_enter_blocking_section();
int caml_init_signals();
int __fastcall caml_set_signal_action(int sig, int);
int __fastcall segv_handler(__int64, __int64, _QWORD *);
void __fastcall handle_signal(unsigned int);
__int64 caml_garbage_collection();
void __fastcall caml_ext_table_free(__int64, int);
__int64 __fastcall caml_ext_table_add(void **, __int64);
void *__fastcall caml_ext_table_init(__int64, int);
unsigned __int64 __fastcall caml_aligned_malloc(__int64, int, _QWORD *);
void __fastcall __noreturn caml_fatal_error_arg2(const char *a1, __int64 a2, const char *a3, __int64 a4);
void __fastcall __noreturn caml_fatal_error_arg(const char *a1, __int64 a2);
void __fastcall __noreturn caml_fatal_error(const char *a1);
int __fastcall caml_gc_message(int a1, const char *a2, __int64 a3);
__int64 *__fastcall allocate_block(__int64, int, __int64 *, __int64 *);
void caml_fl_init_merge();
__int64 caml_fl_reset();
__int64 *__fastcall caml_fl_merge_block(__int64 *);
__int64 __fastcall caml_fl_add_blocks(__int64 *);
__int64 *__fastcall caml_make_free_blocks(__int64 **, unsigned __int64, int);
void __fastcall caml_set_allocation_policy(__int64);
__int64 *__fastcall caml_fl_allocate(unsigned __int64);
__int64 __fastcall caml_init_major_heap(unsigned __int64);
unsigned __int64 __fastcall caml_round_heap_chunk_size(unsigned __int64);
__int64 (__fastcall *start_cycle())(_QWORD);
__int64 realloc_gray_vals();
void __fastcall mark_slice(__int64);
void __fastcall caml_darken(unsigned __int64);
int __fastcall sweep_slice(__int64);
__int64 caml_finish_major_cycle();
__int64 __fastcall caml_major_collection_slice(__int64);
void __fastcall caml_oldify_one(unsigned __int64, _QWORD *);
unsigned __int64 caml_oldify_mopup();
__int64 caml_empty_minor_heap();
__int64 caml_minor_collection();
__int64 __fastcall caml_check_urgent_gc(__int64);
void __fastcall caml_set_minor_heap_size(__int64);
char *__fastcall caml_alloc_table(__int64, __int64, __int64);
char *__fastcall caml_realloc_ref_table(__int64);
__int64 __fastcall caml_page_table_lookup(unsigned __int64);
__int64 __fastcall caml_allocation_color(unsigned __int64);
void __fastcall caml_alloc_dependent_memory(unsigned __int64);
unsigned __int64 __fastcall caml_free_dependent_memory(unsigned __int64 a1);
void *__fastcall caml_stat_resize(void *, size_t);
void caml_stat_free(void *ptr);
void __fastcall caml_free_for_heap(__int64);
void *__fastcall caml_stat_alloc(size_t);
void __fastcall caml_modify(unsigned __int64 *, unsigned __int64);
void __fastcall caml_initialize(unsigned __int64 *, unsigned __int64);
__int64 __fastcall caml_adjust_gc_speed(unsigned __int64, unsigned __int64);
unsigned __int64 __fastcall caml_alloc_for_heap(__int64);
__int64 __fastcall caml_page_table_modify(unsigned __int64, int, int);
__int64 __fastcall caml_page_table_remove(int, __int64, __int64);
void __fastcall caml_shrink_heap(_QWORD *);
__int64 __fastcall caml_page_table_add(int, __int64, __int64);
__int64 __fastcall caml_add_to_heap(unsigned __int64);
__int64 *__fastcall caml_alloc_shr(unsigned __int64, unsigned int);
__int64 __fastcall caml_page_table_initialize(unsigned __int64);
__int64 __fastcall caml_convert_flag_list(__int64 *, __int64);
__int64 __fastcall caml_update_dummy(unsigned __int64 *, __int64);
_QWORD *__fastcall caml_alloc_final(__int64, __int64, unsigned __int64, unsigned __int64);
_QWORD *__fastcall caml_alloc_small(__int64, unsigned int);
_QWORD *__fastcall caml_alloc_string(__int64 a1);
_QWORD *__fastcall caml_copy_string(void *src);
char *__fastcall caml_alloc(unsigned __int64, unsigned int);
char *__fastcall caml_alloc_dummy_float(__int64);
char *__fastcall caml_alloc_dummy(__int64);
char *__fastcall caml_alloc_array(__int64 (__fastcall *)(_QWORD), _QWORD *);
char *__fastcall caml_copy_string_array(_QWORD *);
char *__fastcall caml_alloc_tuple(unsigned __int64);
void compare_free_stack();
void __noreturn compare_stack_overflow();
unsigned __int64 __fastcall compare_val(__int64, __int64, int);
unsigned __int64 __fastcall caml_greaterequal(__int64, __int64);
__int64 __fastcall caml_greaterthan(__int64, __int64);
__int64 __fastcall caml_lessequal(__int64, __int64);
unsigned __int64 __fastcall caml_lessthan(__int64, __int64);
unsigned __int64 __fastcall caml_notequal(__int64, __int64);
__int64 __fastcall caml_equal(__int64, __int64);
unsigned __int64 __fastcall caml_compare(__int64, __int64);
__int64 __fastcall caml_int_compare(__int64, __int64);
__int64 __fastcall int32_cmp(__int64, __int64);
__int64 __fastcall int32_hash(__int64);
__int64 __fastcall caml_int32_to_int(__int64);
__int64 __fastcall caml_int32_compare(__int64, __int64);
__int64 __fastcall int64_cmp(__int64, __int64);
__int64 __fastcall int64_hash(__int64);
__int64 __fastcall caml_int64_to_int(__int64);
__int64 __fastcall caml_int64_compare(__int64, __int64);
__int64 __fastcall nativeint_cmp(__int64, __int64);
__int64 __fastcall nativeint_hash(__int64);
__int64 __fastcall caml_nativeint_to_int(__int64);
__int64 __fastcall caml_nativeint_compare(__int64, __int64);
__int64 __fastcall int32_deserialize(_DWORD *);
__int64 __fastcall int64_deserialize(_QWORD *);
__int64 __fastcall nativeint_deserialize(__int64 *);
_BYTE *__fastcall int32_serialize(__int64, _QWORD *, _QWORD *);
_BYTE *__fastcall nativeint_serialize(__int64, _QWORD *, _QWORD *);
char *__fastcall int64_serialize(__int64, _QWORD *, _QWORD *);
unsigned __int64 __fastcall parse_intnat(char *, unsigned int);
unsigned __int64 __fastcall caml_int_of_string(char *);
void *__fastcall parse_format(char *nptr, void *src, void *dest, __int64, unsigned __int8 *);
_QWORD *__fastcall caml_nativeint_format(char *a1, __int64 a2);
_QWORD *__fastcall caml_int64_format(char *a1, __int64 a2);
_QWORD *__fastcall caml_int32_format(char *a1, __int64 a2);
_QWORD *__fastcall caml_format_int(char *a1, __int64 a2);
__int64 __fastcall caml_nativeint_to_float(__int64);
__int64 __fastcall caml_int64_float_of_bits(__int64);
__int64 __fastcall caml_int64_to_float(__int64);
__int64 __fastcall caml_int32_float_of_bits(__int64);
__int64 __fastcall caml_int32_to_float(__int64);
_QWORD *__fastcall caml_copy_nativeint(__int64);
_QWORD *__fastcall caml_nativeint_of_string(char *);
_QWORD *__fastcall caml_nativeint_of_int32(__int64);
_QWORD *__fastcall caml_nativeint_of_float(double *);
_QWORD *__fastcall caml_nativeint_of_int(__int64);
_QWORD *__fastcall caml_nativeint_shift_right_unsigned(__int64, unsigned __int64);
_QWORD *__fastcall caml_nativeint_shift_right(__int64, unsigned __int64);
_QWORD *__fastcall caml_nativeint_shift_left(__int64, unsigned __int64);
_QWORD *__fastcall caml_nativeint_xor(__int64, __int64);
_QWORD *__fastcall caml_nativeint_or(__int64, __int64);
_QWORD *__fastcall caml_nativeint_and(__int64, __int64);
_QWORD *__fastcall caml_nativeint_mod(__int64, __int64);
_QWORD *__fastcall caml_nativeint_div(__int64, __int64);
_QWORD *__fastcall caml_nativeint_mul(__int64, __int64);
_QWORD *__fastcall caml_nativeint_sub(__int64, __int64);
_QWORD *__fastcall caml_nativeint_add(__int64, __int64);
_QWORD *__fastcall caml_nativeint_neg(__int64);
_QWORD *__fastcall caml_int64_to_nativeint(__int64);
_QWORD *__fastcall caml_copy_int64(__int64);
_QWORD *__fastcall caml_int64_bits_of_float(__int64 *);
_QWORD *__fastcall caml_int64_of_string(char *);
_QWORD *__fastcall caml_int64_of_nativeint(__int64);
_QWORD *__fastcall caml_int64_of_int32(__int64);
_QWORD *__fastcall caml_int64_of_float(double *);
_QWORD *__fastcall caml_int64_of_int(__int64);
_QWORD *__fastcall caml_int64_shift_right_unsigned(__int64, unsigned __int64);
_QWORD *__fastcall caml_int64_shift_right(__int64, unsigned __int64);
_QWORD *__fastcall caml_int64_shift_left(__int64, unsigned __int64);
_QWORD *__fastcall caml_int64_xor(__int64, __int64);
_QWORD *__fastcall caml_int64_or(__int64, __int64);
_QWORD *__fastcall caml_int64_and(__int64, __int64);
_QWORD *__fastcall caml_int64_mod(__int64, __int64);
_QWORD *__fastcall caml_int64_div(__int64, __int64);
_QWORD *__fastcall caml_int64_mul(__int64, __int64);
_QWORD *__fastcall caml_int64_sub(__int64, __int64);
_QWORD *__fastcall caml_int64_add(__int64, __int64);
_QWORD *__fastcall caml_int64_neg(__int64);
_QWORD *__fastcall caml_copy_int32(int);
_QWORD *__fastcall caml_nativeint_to_int32(__int64);
_QWORD *__fastcall caml_int64_to_int32(__int64);
_QWORD *__fastcall caml_int32_bits_of_float(double *);
_QWORD *__fastcall caml_int32_of_string(char *);
_QWORD *__fastcall caml_int32_of_float(double *);
_QWORD *__fastcall caml_int32_of_int(__int64);
_QWORD *__fastcall caml_int32_shift_right_unsigned(__int64, unsigned __int64);
_QWORD *__fastcall caml_int32_shift_right(__int64, unsigned __int64);
_QWORD *__fastcall caml_int32_shift_left(__int64, unsigned __int64);
_QWORD *__fastcall caml_int32_xor(__int64, __int64);
_QWORD *__fastcall caml_int32_or(__int64, __int64);
_QWORD *__fastcall caml_int32_and(__int64, __int64);
_QWORD *__fastcall caml_int32_mod(__int64, __int64);
_QWORD *__fastcall caml_int32_div(__int64, __int64);
_QWORD *__fastcall caml_int32_mul(__int64, __int64);
_QWORD *__fastcall caml_int32_sub(__int64, __int64);
_QWORD *__fastcall caml_int32_add(__int64, __int64);
_QWORD *__fastcall caml_int32_neg(__int64);
__int64 __fastcall caml_int_of_float(double *);
__int64 __fastcall caml_eq_float(double *, double *);
__int64 __fastcall caml_neq_float(double *, double *);
unsigned __int64 __fastcall caml_le_float(double *, double *);
__int64 __fastcall caml_lt_float(double *, double *);
unsigned __int64 __fastcall caml_ge_float(double *, double *);
__int64 __fastcall caml_gt_float(double *, double *);
__int64 __fastcall caml_float_compare(double *, double *);
__int64 __fastcall caml_init_ieee_floats(double); // weak
__int64 __fastcall caml_classify_float(double *);
_QWORD *__fastcall caml_format_float(char *nptr, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall caml_copy_double(double);
__int64 __fastcall caml_ceil_float(double *);
__int64 __fastcall caml_atan2_float(double *, double *);
__int64 __fastcall caml_atan_float(double *);
__int64 __fastcall caml_acos_float(double *);
__int64 __fastcall caml_asin_float(double *);
__int64 __fastcall caml_tanh_float(double *);
__int64 __fastcall caml_tan_float(double *);
__int64 __fastcall caml_cosh_float(double *);
__int64 __fastcall caml_cos_float(double *);
__int64 __fastcall caml_sinh_float(double *);
__int64 __fastcall caml_sin_float(double *);
__int64 __fastcall caml_power_float(double *, double *);
__int64 __fastcall caml_sqrt_float(double *);
char *__fastcall caml_modf_float(double *);
__int64 __fastcall caml_log10_float(double *);
__int64 __fastcall caml_log_float(double *);
__int64 __fastcall caml_ldexp_float(double *, __int64);
char *__fastcall caml_frexp_float(double *);
__int64 __fastcall caml_fmod_float(double *, double *);
__int64 __fastcall caml_floor_float(double *);
__int64 __fastcall caml_exp_float(double *);
__int64 __fastcall caml_div_float(double *, double *);
__int64 __fastcall caml_mul_float(double *, double *);
__int64 __fastcall caml_sub_float(double *, double *);
__int64 __fastcall caml_add_float(double *, double *);
__int64 __fastcall caml_abs_float(double *);
__int64 __fastcall caml_neg_float(double *);
__int64 __fastcall caml_float_of_int(__int64);
__int64 __fastcall caml_float_of_string(__int64);
__int64 __fastcall caml_float_of_substring(__int64, __int64, __int64);
__int64 __fastcall caml_string_length(__int64);
__int64 __fastcall caml_ml_string_length(__int64);
__int64 __fastcall caml_string_equal(_QWORD *, _QWORD *);
__int64 __fastcall caml_string_notequal(_QWORD *, _QWORD *);
__int64 __fastcall caml_bitvect_test(__int64, unsigned __int64);
unsigned __int64 __fastcall caml_is_printable(__int64);
__int64 __fastcall caml_fill_string(__int64, __int64, __int64, __int64);
__int64 __fastcall caml_blit_string(__int64, __int64, __int64, __int64, __int64);
__int64 __fastcall caml_string_compare(_QWORD *, _QWORD *);
__int64 __fastcall caml_string_greaterequal(_QWORD *, _QWORD *);
__int64 __fastcall caml_string_greaterthan(_QWORD *, _QWORD *);
__int64 __fastcall caml_string_lessequal(_QWORD *, _QWORD *);
__int64 __fastcall caml_string_lessthan(_QWORD *, _QWORD *);
__int64 __fastcall caml_string_set(__int64, __int64, __int64);
__int64 __fastcall caml_string_get(__int64, __int64);
_QWORD *__fastcall caml_create_string(__int64 a1);
__int64 __fastcall caml_array_unsafe_set_float(__int64, __int64, _QWORD *);
unsigned __int64 *__fastcall caml_make_array(unsigned __int64 *);
_QWORD *__fastcall caml_array_unsafe_get_float(__int64, __int64);
_QWORD *__fastcall caml_array_unsafe_get(__int64, __int64);
_QWORD *__fastcall caml_make_vect(__int64, unsigned __int64);
__int64 __fastcall caml_array_unsafe_set_addr(__int64, __int64, unsigned __int64);
__int64 __fastcall caml_array_unsafe_set(__int64, __int64, _QWORD *);
__int64 __fastcall caml_array_set_float(__int64, __int64, _QWORD *);
__int64 __fastcall caml_array_set_addr(__int64, __int64, unsigned __int64);
__int64 __fastcall caml_array_set(__int64 a1, __int64 a2, _QWORD *a3);
_QWORD *__fastcall caml_array_get_float(__int64, __int64);
__int64 __fastcall caml_array_get_addr(__int64, __int64);
_QWORD *__fastcall caml_array_get(__int64, __int64);
__int64 caml_channel_binary_mode();
__int64 __fastcall caml_pos_out(__int64);
__int64 __fastcall caml_pos_in(_QWORD *);
__int64 __fastcall compare_channel(__int64, __int64);
__int64 __fastcall caml_ml_set_binary_mode(); // weak
_QWORD *__fastcall caml_ml_pos_in_64(__int64);
_QWORD *__fastcall caml_ml_pos_out_64(__int64);
__int64 __fastcall caml_ml_pos_in(__int64);
__int64 __fastcall caml_ml_pos_out(__int64);
__int64 __fastcall caml_channel_descriptor(__int64);
__int64 __fastcall caml_ml_close_channel(__int64);
_QWORD *__fastcall caml_alloc_channel(__int64);
__int64 __fastcall caml_ml_out_channels_list(); // weak
void __fastcall caml_finalize_channel(__int64);
void __fastcall caml_close_channel(void *ptr);
__off64_t __fastcall caml_seek_in(__int64, __off64_t);
__int64 __fastcall caml_ml_seek_in_64(__int64, __int64);
__int64 __fastcall caml_ml_seek_in(__int64, __int64);
__off64_t __fastcall caml_channel_size(__int64);
_QWORD *__fastcall caml_ml_channel_size_64(__int64);
__off64_t __fastcall caml_ml_channel_size(__int64 a1);
__int64 __fastcall caml_do_read(int fd, void *buf, size_t nbytes); // idb
__int64 __fastcall caml_ml_input(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
signed __int64 __fastcall caml_input_scan_line(__int64);
__int64 __fastcall caml_ml_input_scan_line(__int64);
__int64 __fastcall caml_getblock(__int64, void *, __int64);
_BOOL8 __fastcall caml_really_getblock(__int64, char *, __int64);
__int64 __fastcall caml_refill(__int64);
__int64 __fastcall caml_ml_input_char(__int64);
__int64 __fastcall caml_getword(__int64);
__int64 __fastcall caml_ml_input_int(__int64);
__int64 __fastcall do_write(int fd, void *buf, int);
__int64 __fastcall caml_putblock(__int64, const void *, __int64);
__int64 __fastcall caml_ml_output(__int64, __int64, __int64, __int64);
__int64 __fastcall caml_ml_output_partial(__int64, __int64, __int64, __int64);
void __fastcall caml_really_putblock(__int64, char *, __int64);
_BOOL8 __fastcall caml_flush_partial(__int64);
__int64 __fastcall caml_ml_output_char(__int64, __int64);
unsigned __int64 __fastcall caml_ml_flush_partial(__int64);
_BYTE *__fastcall caml_putword(__int64, int);
__int64 __fastcall caml_ml_output_int(__int64, __int64);
_BOOL8 __fastcall caml_flush(__int64);
__int64 __fastcall caml_ml_flush(__int64);
__off64_t __fastcall caml_seek_out(__int64, __off64_t);
__int64 __fastcall caml_ml_seek_out_64(__int64, __int64);
__int64 __fastcall caml_ml_seek_out(__int64, __int64);
_QWORD *__fastcall caml_open_descriptor_in(int fd);
_QWORD *__fastcall caml_ml_open_descriptor_in(__int64);
_QWORD *__fastcall caml_open_descriptor_out(int);
_QWORD *__fastcall caml_ml_open_descriptor_out(__int64);
void extern_replay_trail();
void free_extern_output();
void __noreturn extern_out_of_memory();
__int64 __fastcall grow_extern_output(__int64);
char *__fastcall caml_serialize_block_8(char *, __int64);
char *__fastcall caml_serialize_int_8(__int64);
char *__fastcall caml_serialize_block_4(__int64, __int64);
char *__fastcall caml_serialize_float_4(float);
char *__fastcall caml_serialize_block_2(__int64, __int64);
_BYTE *__fastcall caml_serialize_int_4(int);
_BYTE *__fastcall caml_serialize_int_2(__int16);
_BYTE *__fastcall caml_serialize_int_1(char);
_BYTE *__fastcall writecode8(char, char);
_BYTE *__fastcall writecode32(char, int);
_BYTE *__fastcall write32(int);
__int64 __fastcall extern_record_location(unsigned __int64);
__int64 init_extern_output();
void *__fastcall caml_serialize_block_float_8(void *src, __int64);
void *__fastcall caml_serialize_float_8(double);
void *__fastcall caml_serialize_block_1(void *src, size_t n);
void *__fastcall writeblock(void *src, size_t n);
void __fastcall __noreturn extern_invalid_argument(void *);
_BYTE *__fastcall extern_rec(__int64);
__int64 __fastcall extern_value(__int64, __int64 *);
__int64 __fastcall caml_output_value_to_block(__int64, __int64 *, void *, __int64);
void __fastcall caml_output_value_to_malloc(__int64, __int64 *, char **, __int64 *);
__int64 __fastcall caml_output_value_to_buffer(__int64, __int64, __int64, __int64, __int64 *);
_QWORD *__fastcall caml_output_value_to_string(__int64 a1, __int64 *a2);
void __fastcall caml_output_val(__int64, __int64, __int64 *);
__int64 __fastcall caml_output_value(__int64, __int64, __int64 *);
__int64 caml_deserialize_uint_1();
__int64 __fastcall caml_deserialize_sint_1(); // weak
__int64 __fastcall caml_deserialize_uint_2(); // weak
__int64 __fastcall caml_deserialize_sint_2(); // weak
unsigned __int64 caml_deserialize_uint_4();
__int64 caml_deserialize_sint_4();
void __fastcall caml_deserialize_block_2(__int64, __int64);
void __fastcall caml_deserialize_block_4(__int64, __int64);
float caml_deserialize_float_4();
void __fastcall caml_deserialize_block_8(_BYTE *, __int64);
__int64 caml_deserialize_sint_8();
__int64 __fastcall caml_deserialize_uint_8(); // weak
unsigned __int64 __fastcall caml_marshal_data_size(__int64, __int64);
void intern_cleanup();
void __fastcall __noreturn caml_deserialize_error(void *);
void *__fastcall caml_deserialize_block_float_8(void *, __int64);
double caml_deserialize_float_8();
void *__fastcall caml_deserialize_block_1(void *, size_t);
_QWORD *caml_code_checksum();
void __fastcall intern_alloc(__int64, __int64);
__int64 __fastcall intern_add_to_heap(__int64);
unsigned __int64 __fastcall intern_rec(const char ****);
const char ***input_val_from_block();
const char ***__fastcall caml_input_value_from_block(unsigned __int8 *, unsigned __int64);
const char ***__fastcall caml_input_value_from_malloc(char *, __int64);
const char ***__fastcall caml_input_val_from_string(__int64, __int64);
const char ***__fastcall caml_input_value_from_string(__int64, __int64);
const char ***__fastcall caml_input_val(__int64);
const char ***__fastcall caml_input_value(__int64);
__int64 __fastcall caml_hash_variant(_BYTE *);
__int64 __fastcall hash_aux(__int64);
__int64 __fastcall caml_hash_univ_param(__int64, __int64, __int64);
void __fastcall caml_sys_init(void *, __int64);
_QWORD *caml_sys_get_config();
_QWORD *caml_sys_get_argv();
__int64 __fastcall caml_sys_random_seed(); // weak
__int64 __fastcall caml_sys_time(); // weak
_QWORD *__fastcall caml_sys_getenv(const char *a1);
__int64 __fastcall caml_sys_file_exists(char *filename); // idb
__int64 __fastcall caml_sys_close(__int64);
void __fastcall __noreturn caml_sys_exit(__int64);
void __fastcall __noreturn caml_sys_error(void *);
char *__fastcall caml_sys_read_directory(void *);
__int64 __fastcall caml_sys_system_command(void *);
_QWORD *caml_sys_getcwd();
__int64 __fastcall caml_sys_chdir(void *);
__int64 __fastcall caml_sys_rename(const char *, const char *);
__int64 __fastcall caml_sys_remove(void *);
__int64 __fastcall caml_sys_is_directory(char *filename); // idb
__int64 __fastcall caml_sys_open(char *, __int64 *, __int64);
void __fastcall __noreturn caml_sys_io_error(void *);
unsigned __int64 __fastcall caml_set_parser_trace(__int64);
__int64 __fastcall caml_parse_engine(_QWORD *, _QWORD *, __int64, signed __int64, __int64, __int64);
int __fastcall caml_init_gc(__int64, __int64, __int64, __int64, __int64);
int __fastcall test_and_compact(__m128d);
__int64 __fastcall caml_gc_compaction(); // weak
__int64 __fastcall caml_gc_full_major(__m128d);
__int64 __fastcall caml_gc_major(__m128d);
__int64 __fastcall caml_gc_major_slice(__int64);
__int64 __fastcall caml_gc_minor(); // weak
__int64 __fastcall caml_gc_set(__int64 *);
unsigned __int64 *caml_gc_get();
unsigned __int64 *caml_gc_counters();
unsigned __int64 *caml_gc_quick_stat();
unsigned __int64 *caml_gc_stat();
void __fastcall caml_MD5Init(_DWORD *);
__int64 __fastcall caml_MD5Transform(_DWORD *, int *);
void *__fastcall caml_MD5Update(__int64, char *, size_t);
__int64 __fastcall caml_MD5Final(_QWORD *, __int64);
_QWORD *__fastcall caml_md5_chan(__int64, __int64);
_QWORD *__fastcall caml_md5_string(__int64, __int64, __int64);
__int64 __fastcall caml_obj_is_block(char);
__int64 __fastcall caml_obj_set_tag(__int64, __int64);
__int64 __fastcall caml_obj_add_offset(__int64, __int64);
__int64 __fastcall caml_get_public_method(int **, __int64);
unsigned __int64 __fastcall caml_lazy_follow_forward(unsigned __int64);
char __fastcall caml_obj_tag(unsigned __int64);
unsigned __int64 *__fastcall caml_lazy_make_forward(__int64);
__int64 __fastcall caml_obj_truncate(__int64, __int64);
char *__fastcall caml_obj_block(__int64, __int64);
char *__fastcall caml_obj_dup(char *);
void *__fastcall caml_static_resize(void *, __int64);
void __fastcall __noreturn caml_static_release_bytecode(); // weak
__int64 __fastcall caml_static_free(void *);
void *__fastcall caml_static_alloc(__int64);
size_t __fastcall add_string(char **, const char *);
void *__fastcall caml_format_exception(__int64);
void __fastcall __noreturn caml_fatal_uncaught_exception(__int64);
__int64 __fastcall caml_named_value(char *s1); // idb
__int64 __fastcall caml_register_named_value(char *src, __int64);
void caml_callback3();
void caml_callback2();
void caml_callback();
void __fastcall caml_callbackN_exn(__int64, int, __int64);
void __fastcall caml_callbackN(__int64, int, __int64);
__int64 __fastcall caml_weak_check(__int64, __int64);
void __fastcall do_set(__int64, __int64, unsigned __int64);
__int64 __fastcall caml_weak_blit(__int64, __int64, __int64, __int64, __int64);
__int64 __fastcall caml_weak_set(__int64, __int64, unsigned __int64 *);
__int64 __fastcall caml_weak_get(__int64, __int64);
__int64 __fastcall caml_weak_get_copy(__int64, __int64);
__int64 *__fastcall caml_weak_create(__int64);
void __fastcall invert_pointer_at(__int64);
void __fastcall invert_root(__int64, __int64);
int caml_compact_heap();
int __fastcall caml_compact_heap_maybe(__m128d, double, __m128);
unsigned __int64 __fastcall caml_final_do_strong_roots(__int64 (__fastcall *)(void *, void **));
__int64 __fastcall caml_final_do_weak_roots(__int64 (__fastcall *)(_QWORD, __int64));
__int64 __fastcall caml_final_do_young_roots(void (__fastcall *)(_QWORD, __int64));
__int64 caml_final_empty_young();
__int64 __fastcall caml_final_release(); // weak
__int64 __fastcall caml_final_register(__int64, unsigned __int64);
void caml_final_do_calls();
void caml_final_update();
_QWORD *__fastcall caml_final_custom_operations(__int64);
_QWORD *__fastcall caml_register_custom_operations(__int64);
_QWORD *caml_init_custom_operations();
const char **__fastcall caml_find_custom_operations(char *s2);
_QWORD *__fastcall caml_alloc_custom(__int64, __int64, unsigned __int64, unsigned __int64);
int __fastcall caml_executable_name(char *filename, int);
__int64 __fastcall caml_read_directory(const char *, void **);
char *__fastcall caml_decompose_path(void **, const char *);
void *caml_dlsym(void *handle, const char *name);
void *__fastcall caml_globalsym(char *name);
void *__fastcall caml_dlopen(const char *, __int64, int);
char *__fastcall caml_search_in_path(__int64, const char *);
char *__fastcall caml_search_dll_in_path(__int64, const char *);
char *__fastcall caml_search_exe_in_path(const char *);
unsigned __int64 caml_backtrace_status();
_QWORD *caml_get_exception_backtrace();
void caml_print_exception_backtrace();
unsigned __int64 __fastcall caml_stash_backtrace(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
__int64 __fastcall caml_record_backtrace(__int64);
void __fastcall caml_call_gc(__int64, __int64, __int64, __int64, __int64, __int64, char);
void __fastcall sub_43BF5B(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall caml_alloc1(__int64, __int64, __int64, __int64, __int64, __int64, char);
void __fastcall caml_alloc2(__int64, __int64, __int64, __int64, __int64, __int64, char);
void __fastcall caml_alloc3(__int64, __int64, __int64, __int64, __int64, __int64, char);
__int64 __fastcall caml_allocN(__int64, __int64, __int64, __int64, __int64, __int64, char);
void __fastcall caml_c_call(__int64, unsigned __int64);
__int64 __fastcall caml_start_program(__int64, unsigned __int64, __int64, __int64, __int64, __int64, double);
void sub_43C211();
__int64 __fastcall caml_raise_exn();
__int64 __fastcall caml_raise_exception(__int64);
void caml_callback_exn();
void caml_callback2_exn();
void caml_callback3_exn();
void __fastcall caml_ml_array_bound_error(__int64, unsigned __int64);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_43CE98; // weak
_UNKNOWN unk_43CE9F; // weak
__itimer_which_t itimers[3] = { ITIMER_REAL, ITIMER_VIRTUAL, ITIMER_PROF }; // weak
_DWORD seek_command_table[3] = { 0, 1, 2 }; // weak
_UNKNOWN unk_43CFF4; // weak
_DWORD shutdown_command_table[3] = { 0, 1, 2 }; // weak
_DWORD sigprocmask_cmd[3] = { 2, 0, 1 }; // weak
_DWORD action_flag_table[4] = { 0, 1, 2, 3 }; // weak
_DWORD queue_flag_table[3] = { 0, 1, 2 }; // weak
_DWORD when_flag_table[9] = { 0, 1, 2, 0, 0, 0, 0, 0, 0 }; // weak
_UNKNOWN speedtable; // weak
_UNKNOWN unk_43D228; // weak
_UNKNOWN unk_43D22C; // weak
int posix_signals[] = { 6 }; // weak
_UNKNOWN unk_43D504; // weak
int CSWTCH_33[3] = { 0, 2, 1 }; // weak
__int64 CSWTCH_118[4] = { 9LL, 7LL, 5LL, 3LL }; // weak
void *__ptr32 off_43DDF7 = (void *__ptr32)0x646C25LL; // weak
_UNKNOWN unk_43E0E8; // weak
void *sockopt_table = &sockopt_bool; // weak
char *setsockopt_fun_name[5] =
{
  "setsockopt",
  "setsockopt_int",
  "setsockopt_optint",
  "setsockopt_float",
  "setsockopt_error"
}; // weak
char *getsockopt_fun_name = "getsockopt"; // weak
__int64 (*qword_647478)(void) = NULL; // weak
char **caml_bucket_Out_of_memory = &caml_exn_Out_of_memory; // weak
char *caml_exn_Sys_error = "Sys_error"; // weak
char *caml_exn_Failure = "Failure"; // weak
char *caml_exn_Invalid_argument = "Invalid_argument"; // weak
char *caml_exn_End_of_file = "End_of_file"; // weak
char *caml_exn_Division_by_zero = "Division_by_zero"; // weak
char *caml_exn_Not_found = "Not_found"; // weak
char **caml_bucket_Stack_overflow = &caml_exn_Stack_overflow; // weak
char *caml_exn_Sys_blocked_io = "Sys_blocked_io"; // weak
char *caml_exn_Assert_failure = "Assert_failure"; // weak
char *caml_exn_Undefined_recursive_module = "Undefined_recursive_module"; // weak
__int64 (*caml_globals)[84] = &camlPervasives; // weak
void *caml_data_segments = &caml_startup__data_begin; // weak
void *off_6480D8 = &caml_startup__data_end; // weak
__int64 (__fastcall *caml_code_segments)() = &caml_startup__code_begin; // weak
char (*off_648210)[12] = &caml_startup__code_end; // weak
__int64 (__fastcall *off_648218)() = &camlPervasives__code_begin; // weak
void *caml_frametable = &caml_startup__frametable; // weak
_UNKNOWN camlSource; // weak
char *camlSource__3 = "state"; // weak
char *camlSource__4[2] = { "activate", "value" }; // weak
char *camlSource__6[2] = { "count_max", "counter" }; // weak
_QWORD camlUnix[168] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  3319LL
}; // weak
__int64 (__fastcall *camlUnix__1)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__2)() = &camlUnix__accept_non_intr_1050; // weak
__int64 (__fastcall *camlUnix__3)() = &camlUnix__shutdown_connection_1048; // weak
__int64 (__fastcall *camlUnix__4)() = &camlUnix__open_connection_1044; // weak
__int64 (__fastcall *camlUnix__5)() = &caml_tuplify3; // weak
__int64 (__fastcall *camlUnix__6)() = &caml_tuplify2; // weak
__int64 (__fastcall *camlUnix__7)() = &camlUnix__close_process_out_1032; // weak
__int64 (__fastcall *camlUnix__8)() = &camlUnix__close_process_in_1029; // weak
__int64 (__fastcall *camlUnix__9)() = &camlUnix__waitpid_non_intr_1027; // weak
__int64 (__fastcall *camlUnix__10)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__11)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__12)() = &caml_curry7; // weak
__int64 (__fastcall *camlUnix__13)() = &camlUnix__open_process_993; // weak
__int64 (__fastcall *camlUnix__14)() = &camlUnix__open_process_out_988; // weak
__int64 (__fastcall *camlUnix__15)() = &camlUnix__open_process_in_983; // weak
__int64 (__fastcall *camlUnix__16)() = &caml_curry5; // weak
__int64 (__fastcall *camlUnix__17)() = &caml_curry6; // weak
__int64 (__fastcall *camlUnix__18)() = &caml_curry5; // weak
__int64 (__fastcall *camlUnix__19)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__20)() = &camlUnix__safe_close_924; // weak
__int64 (__fastcall *camlUnix__21)() = &camlUnix__safe_dup_920; // weak
__int64 (__fastcall *camlUnix__22)() = &camlUnix__system_917; // weak
__int64 (__fastcall *camlUnix__23)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__24)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__25)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__26)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__27)() = &camlUnix__getsockopt_error_697; // weak
__int64 (__fastcall *camlUnix__28)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__29)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__30)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__31)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__32)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__33)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__34)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__35)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__36)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__37)() = &caml_curry4; // weak
__int64 (__fastcall *camlUnix__38)() = &caml_curry6; // weak
__int64 (__fastcall *camlUnix__39)() = &caml_curry5; // weak
__int64 (__fastcall *camlUnix__40)() = &caml_curry5; // weak
__int64 (__fastcall *camlUnix__41)() = &caml_curry5; // weak
__int64 (__fastcall *camlUnix__42)() = &camlUnix__domain_of_sockaddr_555; // weak
__int64 (__fastcall *camlUnix__47)() = &camlUnix__is_inet6_addr_526; // weak
__int64 (__fastcall *camlUnix__48)() = &camlUnix__pause_436; // weak
__int64 (__fastcall *camlUnix__49)() = &camlUnix__try_set_close_on_exec_394; // weak
__int64 (__fastcall *camlUnix__50)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__51)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__52)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__53)() = &camlUnix__fun_1819; // weak
__int64 (__fastcall *camlUnix__54)() = &camlUnix__fun_1821; // weak
__int64 (__fastcall *camlUnix__55)() = &camlUnix__fun_1823; // weak
__int64 (__fastcall *camlUnix__57)() = &caml_curry4; // weak
__int64 (__fastcall *camlUnix__58)() = &caml_curry4; // weak
__int64 (__fastcall *camlUnix__59)() = &caml_curry4; // weak
__int64 (__fastcall *camlUnix__60)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__65)() = &camlUnix__fun_1801; // weak
__int64 (__fastcall *camlUnix__66)() = &camlUnix__fun_1799; // weak
__int64 (__fastcall *camlUnix__67)() = &camlUnix__fun_1797; // weak
__int64 (__fastcall *camlUnix__68)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__69)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__70)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__71)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__72)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__73)() = &camlUnix__fun_1785; // weak
__int64 (__fastcall *camlUnix__74)() = &camlUnix__fun_1783; // weak
__int64 (__fastcall *camlUnix__75)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__76)() = &camlUnix__fun_1779; // weak
__int64 (__fastcall *camlUnix__77)() = &camlUnix__fun_1777; // weak
__int64 (__fastcall *camlUnix__78)() = &camlUnix__fun_1775; // weak
__int64 (__fastcall *camlUnix__79)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__80)() = &camlUnix__fun_1771; // weak
__int64 (__fastcall *camlUnix__81)() = &camlUnix__fun_1769; // weak
__int64 (__fastcall *camlUnix__82)() = &camlUnix__fun_1767; // weak
__int64 (__fastcall *camlUnix__83)() = &camlUnix__fun_1765; // weak
__int64 (__fastcall *camlUnix__84)() = &camlUnix__fun_1763; // weak
__int64 (__fastcall *camlUnix__85)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__86)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__87)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__88)() = &camlUnix__fun_1755; // weak
__int64 (__fastcall *camlUnix__89)() = &camlUnix__fun_1753; // weak
__int64 (__fastcall *camlUnix__90)() = &camlUnix__fun_1751; // weak
__int64 (__fastcall *camlUnix__91)() = &camlUnix__fun_1749; // weak
__int64 (__fastcall *camlUnix__92)() = &camlUnix__fun_1747; // weak
__int64 (__fastcall *camlUnix__93)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__94)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__95)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__96)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__97)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__98)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__99)() = &camlUnix__fun_1733; // weak
__int64 (__fastcall *camlUnix__100)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__101)() = &camlUnix__fun_1729; // weak
__int64 (__fastcall *camlUnix__102)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__103)() = &camlUnix__fun_1725; // weak
__int64 (__fastcall *camlUnix__104)() = &camlUnix__fun_1723; // weak
__int64 (__fastcall *camlUnix__105)() = &camlUnix__fun_1721; // weak
__int64 (__fastcall *camlUnix__106)() = &camlUnix__fun_1719; // weak
__int64 (__fastcall *camlUnix__107)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__108)() = &camlUnix__fun_1715; // weak
__int64 (__fastcall *camlUnix__109)() = &camlUnix__fun_1713; // weak
__int64 (__fastcall *camlUnix__110)() = &camlUnix__fun_1711; // weak
__int64 (__fastcall *camlUnix__111)() = &camlUnix__fun_1709; // weak
__int64 (__fastcall *camlUnix__112)() = &camlUnix__fun_1707; // weak
__int64 (__fastcall *camlUnix__113)() = &camlUnix__fun_1705; // weak
__int64 (__fastcall *camlUnix__114)() = &camlUnix__fun_1703; // weak
__int64 (__fastcall *camlUnix__115)() = &camlUnix__fun_1701; // weak
__int64 (__fastcall *camlUnix__116)() = &camlUnix__fun_1699; // weak
__int64 (__fastcall *camlUnix__117)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__118)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__119)() = &camlUnix__fun_1693; // weak
__int64 (__fastcall *camlUnix__120)() = &caml_curry4; // weak
__int64 (__fastcall *camlUnix__121)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__122)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__123)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__124)() = &camlUnix__fun_1683; // weak
__int64 (__fastcall *camlUnix__125)() = &camlUnix__fun_1681; // weak
__int64 (__fastcall *camlUnix__126)() = &camlUnix__fun_1679; // weak
__int64 (__fastcall *camlUnix__127)() = &camlUnix__fun_1677; // weak
__int64 (__fastcall *camlUnix__128)() = &camlUnix__fun_1675; // weak
__int64 (__fastcall *camlUnix__129)() = &camlUnix__fun_1673; // weak
__int64 (__fastcall *camlUnix__130)() = &camlUnix__fun_1671; // weak
__int64 (__fastcall *camlUnix__131)() = &camlUnix__fun_1669; // weak
__int64 (__fastcall *camlUnix__132)() = &camlUnix__fun_1667; // weak
__int64 (__fastcall *camlUnix__133)() = &camlUnix__fun_1665; // weak
__int64 (__fastcall *camlUnix__134)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__135)() = &camlUnix__fun_1661; // weak
__int64 (__fastcall *camlUnix__136)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__137)() = &camlUnix__fun_1657; // weak
__int64 (__fastcall *camlUnix__138)() = &camlUnix__fun_1655; // weak
__int64 (__fastcall *camlUnix__139)() = &camlUnix__fun_1653; // weak
__int64 (__fastcall *camlUnix__140)() = &camlUnix__fun_1651; // weak
__int64 (__fastcall *camlUnix__141)() = &camlUnix__fun_1649; // weak
__int64 (__fastcall *camlUnix__142)() = &camlUnix__fun_1647; // weak
__int64 (__fastcall *camlUnix__143)() = &camlUnix__fun_1645; // weak
__int64 (__fastcall *camlUnix__144)() = &camlUnix__fun_1643; // weak
__int64 (__fastcall *camlUnix__145)() = &camlUnix__fun_1641; // weak
__int64 (__fastcall *camlUnix__146)() = &camlUnix__fun_1639; // weak
__int64 (__fastcall *camlUnix__147)() = &camlUnix__fun_1637; // weak
__int64 (__fastcall *camlUnix__148)() = &camlUnix__fun_1635; // weak
__int64 (__fastcall *camlUnix__149)() = &camlUnix__fun_1633; // weak
__int64 (__fastcall *camlUnix__150)() = &camlUnix__fun_1631; // weak
__int64 (__fastcall *camlUnix__151)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__152)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__153)() = &camlUnix__fun_1625; // weak
__int64 (__fastcall *camlUnix__154)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__155)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__156)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__157)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__158)() = &camlUnix__fun_1615; // weak
__int64 (__fastcall *camlUnix__159)() = &camlUnix__fun_1613; // weak
__int64 (__fastcall *camlUnix__160)() = &camlUnix__fun_1611; // weak
__int64 (__fastcall *camlUnix__161)() = &camlUnix__fun_1609; // weak
__int64 (__fastcall *camlUnix__162)() = &camlUnix__fun_1607; // weak
__int64 (__fastcall *camlUnix__163)() = &camlUnix__fun_1605; // weak
__int64 (__fastcall *camlUnix__164)() = &camlUnix__fun_1603; // weak
__int64 (__fastcall *camlUnix__165)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__166)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__167)() = &camlUnix__fun_1597; // weak
__int64 (__fastcall *camlUnix__168)() = &caml_curry3; // weak
__int64 (__fastcall *camlUnix__169)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__170)() = &camlUnix__fun_1591; // weak
__int64 (__fastcall *camlUnix__171)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__172)() = &caml_curry2; // weak
__int64 (__fastcall *camlUnix__173)() = &camlUnix__fun_1585; // weak
_UNKNOWN camlUnix__43; // weak
_UNKNOWN camlUnix__44; // weak
char camlUnix__45[10] = "127.0.0.1"; // weak
char camlUnix__46[8] = "0.0.0.0"; // weak
_UNKNOWN camlUnix__62; // weak
_UNKNOWN camlUnix__63; // weak
char camlUnix__64[16] = "Unix.Unix_error"; // weak
_UNKNOWN camlUnix__178; // weak
char camlUnix__179[8] = "/bin/sh"; // weak
char camlUnix__180[8] = "/bin/sh"; // weak
_UNKNOWN camlUnix__181; // weak
char camlUnix__183[8] = "/bin/sh"; // weak
char camlUnix__184[8] = "/bin/sh"; // weak
_UNKNOWN camlUnix__185; // weak
char camlUnix__187[8] = "/bin/sh"; // weak
char camlUnix__188[8] = "/bin/sh"; // weak
_UNKNOWN camlUnix__189; // weak
_UNKNOWN camlUnix__191; // weak
_UNKNOWN camlUnix__192; // weak
char camlUnix__193[10] = "127.0.0.1"; // weak
char camlUnix__194[8] = "0.0.0.0"; // weak
_QWORD camlUnix__195[2] = { 504403158265495552LL, 1276LL }; // weak
_QWORD camlUnix__200[2] = { 504403158265495552LL, 2300LL }; // weak
_QWORD camlUnix__213[127] =
{
  504403158265495552LL,
  4360272LL,
  4363792LL,
  4363852LL,
  4363912LL,
  4363956LL,
  4364003LL,
  4364557LL,
  4353456LL,
  4350720LL,
  4354903LL,
  4354945LL,
  4354163LL,
  4354198LL,
  4353041LL,
  4352859LL,
  4353328LL,
  4362053LL,
  4362489LL,
  4358920LL,
  4359270LL,
  4359528LL,
  4359906LL,
  4353816LL,
  4354980LL,
  4360340LL,
  4356228LL,
  4349464LL,
  4349080LL,
  4348632LL,
  4361740LL,
  4360908LL,
  4363616LL,
  4348928LL,
  4352372LL,
  4354540LL,
  4352407LL,
  4354575LL,
  4353404LL,
  4352440LL,
  4360228LL,
  4352088LL,
  4352136LL,
  4360296LL,
  4352112LL,
  4355108LL,
  4356001LL,
  4355841LL,
  4365756LL,
  4365052LL,
  4360876LL,
  4349056LL,
  4355274LL,
  4355600LL,
  4355664LL,
  4354608LL,
  4365020LL,
  4360464LL,
  4360712LL,
  4360765LL,
  4356136LL,
  4356276LL,
  4358442LL,
  4356848LL,
  4357888LL,
  4363752LL,
  4357304LL,
  4349412LL,
  4358036LL,
  4357824LL,
  4357224LL,
  4349332LL,
  4351984LL,
  4349212LL,
  4358084LL,
  4356808LL,
  4350244LL,
  4350326LL,
  4350408LL,
  4350490LL,
  4349656LL,
  4349608LL,
  4348868LL,
  4365320LL,
  4350192LL,
  4349288LL,
  4350144LL,
  4349248LL,
  4363039LL,
  4363108LL,
  4363177LL,
  4350616LL,
  4365240LL,
  4356636LL,
  4356192LL,
  4358000LL,
  4365720LL,
  4355728LL,
  4363246LL,
  4363370LL,
  4363492LL,
  4350664LL,
  4365280LL,
  4356704LL,
  4399600LL,
  4399600LL,
  4405024LL,
  4404960LL,
  4366272LL,
  4366535LL,
  4357568LL,
  4349368LL,
  4356980LL,
  4356888LL,
  4353968LL,
  4353944LL,
  4366103LL,
  4366195LL,
  4350572LL,
  4349952LL,
  4350074LL,
  4349848LL,
  4349780LL,
  4357384LL,
  4416768LL,
  4349704LL,
  4349728LL
}; // weak
_QWORD camlUnixLabels[153] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL
}; // weak
_QWORD camlPervasives[84] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  2295LL
}; // weak
__int64 (__fastcall *camlPervasives__2)() = &camlPervasives__exit_350; // weak
__int64 (__fastcall *camlPervasives__3)() = &camlPervasives__do_at_exit_349; // weak
__int64 (__fastcall *camlPervasives__4)() = &camlPervasives__at_exit_346; // weak
__int64 (__fastcall *camlPervasives__5)() = &camlPervasives__string_of_format_339; // weak
__int64 (__fastcall *camlPervasives__6)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__7)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__8)() = &camlPervasives__fun_511; // weak
__int64 (__fastcall *camlPervasives__9)() = &camlPervasives__fun_513; // weak
__int64 (__fastcall *camlPervasives__10)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__11)() = &camlPervasives__fun_517; // weak
__int64 (__fastcall *camlPervasives__12)() = &camlPervasives__fun_519; // weak
__int64 (__fastcall *camlPervasives__14)() = &camlPervasives__read_float_314; // weak
__int64 (__fastcall *camlPervasives__15)() = &camlPervasives__read_int_313; // weak
__int64 (__fastcall *camlPervasives__16)() = &camlPervasives__read_line_312; // weak
__int64 (__fastcall *camlPervasives__17)() = &camlPervasives__prerr_newline_311; // weak
__int64 (__fastcall *camlPervasives__18)() = &camlPervasives__prerr_endline_309; // weak
__int64 (__fastcall *camlPervasives__19)() = &camlPervasives__prerr_float_307; // weak
__int64 (__fastcall *camlPervasives__20)() = &camlPervasives__prerr_int_305; // weak
__int64 (__fastcall *camlPervasives__21)() = &camlPervasives__prerr_string_303; // weak
__int64 (__fastcall *camlPervasives__22)() = &camlPervasives__prerr_char_301; // weak
__int64 (__fastcall *camlPervasives__23)() = &camlPervasives__print_newline_300; // weak
__int64 (__fastcall *camlPervasives__24)() = &camlPervasives__print_endline_298; // weak
__int64 (__fastcall *camlPervasives__25)() = &camlPervasives__print_float_296; // weak
__int64 (__fastcall *camlPervasives__26)() = &camlPervasives__print_int_294; // weak
__int64 (__fastcall *camlPervasives__27)() = &camlPervasives__print_string_292; // weak
__int64 (__fastcall *camlPervasives__28)() = &camlPervasives__print_char_290; // weak
__int64 (__fastcall *camlPervasives__29)() = &camlPervasives__close_in_noerr_287; // weak
__int64 (__fastcall *camlPervasives__30)() = &camlPervasives__input_line_265; // weak
__int64 (__fastcall *camlPervasives__31)() = &caml_curry4; // weak
__int64 (__fastcall *camlPervasives__32)() = &caml_curry4; // weak
__int64 (__fastcall *camlPervasives__33)() = &caml_curry4; // weak
__int64 (__fastcall *camlPervasives__34)() = &camlPervasives__open_in_bin_244; // weak
__int64 (__fastcall *camlPervasives__35)() = &camlPervasives__open_in_242; // weak
__int64 (__fastcall *camlPervasives__36)() = &caml_curry3; // weak
__int64 (__fastcall *camlPervasives__37)() = &camlPervasives__close_out_noerr_235; // weak
__int64 (__fastcall *camlPervasives__38)() = &camlPervasives__close_out_233; // weak
__int64 (__fastcall *camlPervasives__39)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__40)() = &caml_curry4; // weak
__int64 (__fastcall *camlPervasives__41)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__42)() = &camlPervasives__flush_all_209; // weak
__int64 (__fastcall *camlPervasives__43)() = &camlPervasives__open_out_bin_205; // weak
__int64 (__fastcall *camlPervasives__44)() = &camlPervasives__open_out_203; // weak
__int64 (__fastcall *camlPervasives__45)() = &caml_curry3; // weak
__int64 (__fastcall *camlPervasives__46)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__47)() = &camlPervasives__string_of_float_164; // weak
__int64 (__fastcall *camlPervasives__48)() = &camlPervasives__valid_float_lexem_159; // weak
__int64 (__fastcall *camlPervasives__50)() = &camlPervasives__string_of_int_154; // weak
__int64 (__fastcall *camlPervasives__51)() = &camlPervasives__bool_of_string_153; // weak
__int64 (__fastcall *camlPervasives__52)() = &camlPervasives__string_of_bool_151; // weak
__int64 (__fastcall *camlPervasives__53)() = &camlPervasives__char_of_int_144; // weak
__int64 (__fastcall *camlPervasives__54)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__61)() = &camlPervasives__lnot_76; // weak
__int64 (__fastcall *camlPervasives__62)() = &camlPervasives__abs_71; // weak
__int64 (__fastcall *camlPervasives__63)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__64)() = &caml_curry2; // weak
void (__fastcall __noreturn *camlPervasives__66)() = &camlPervasives__invalid_arg_40; // weak
void (__fastcall __noreturn *camlPervasives__67)() = &camlPervasives__failwith_38; // weak
__int64 (__fastcall *camlPervasives__68)() = &camlPervasives__fun_448; // weak
__int64 (__fastcall *camlPervasives__69)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__70)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__71)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__72)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__73)() = &camlPervasives__fun_438; // weak
__int64 (__fastcall *camlPervasives__74)() = &camlPervasives__fun_436; // weak
__int64 (__fastcall *camlPervasives__75)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__76)() = &camlPervasives__fun_432; // weak
__int64 (__fastcall *camlPervasives__77)() = &camlPervasives__fun_430; // weak
__int64 (__fastcall *camlPervasives__78)() = &camlPervasives__fun_428; // weak
__int64 (__fastcall *camlPervasives__79)() = &camlPervasives__fun_426; // weak
__int64 (__fastcall *camlPervasives__80)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__81)() = &camlPervasives__fun_422; // weak
__int64 (__fastcall *camlPervasives__82)() = &camlPervasives__fun_420; // weak
__int64 (__fastcall *camlPervasives__83)() = &camlPervasives__fun_418; // weak
__int64 (__fastcall *camlPervasives__84)() = &caml_curry2; // weak
__int64 (__fastcall *camlPervasives__86)() = &caml_curry3; // weak
char camlPervasives__1[22] = "Pervasives.do_at_exit"; // weak
_UNKNOWN camlPervasives__49; // weak
char **camlPervasives__55 = &caml_int64_ops; // weak
char **camlPervasives__56 = &caml_int64_ops; // weak
char **camlPervasives__57 = &caml_int64_ops; // weak
char **camlPervasives__58 = &caml_int64_ops; // weak
char **camlPervasives__59 = &caml_int64_ops; // weak
char **camlPervasives__60 = &caml_int64_ops; // weak
char camlPervasives__65[16] = "Pervasives.Exit"; // weak
char camlPervasives__95[6] = "%.12g"; // weak
_UNKNOWN camlPervasives__96; // weak
char camlPervasives__98[5] = "true"; // weak
char camlPervasives__99[6] = "false"; // weak
char camlPervasives__100[6] = "false"; // weak
char camlPervasives__101[5] = "true"; // weak
_QWORD camlArray[25] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  3319LL
}; // weak
__int64 (__fastcall *camlArray__1)() = &caml_curry2; // weak
__int64 (__fastcall *camlArray__2)() = &caml_curry2; // weak
__int64 (__fastcall *camlArray__4)() = &caml_curry3; // weak
__int64 (__fastcall *camlArray__5)() = &caml_curry3; // weak
__int64 (__fastcall *camlArray__6)() = &camlArray__of_list_157; // weak
__int64 (__fastcall *camlArray__7)() = &caml_curry2; // weak
__int64 (__fastcall *camlArray__8)() = &camlArray__to_list_148; // weak
__int64 (__fastcall *camlArray__9)() = &caml_curry2; // weak
__int64 (__fastcall *camlArray__10)() = &caml_curry2; // weak
__int64 (__fastcall *camlArray__11)() = &caml_curry2; // weak
__int64 (__fastcall *camlArray__12)() = &caml_curry2; // weak
__int64 (__fastcall *camlArray__13)() = &caml_curry5; // weak
__int64 (__fastcall *camlArray__14)() = &caml_curry4; // weak
__int64 (__fastcall *camlArray__15)() = &caml_curry3; // weak
__int64 (__fastcall *camlArray__16)() = &camlArray__concat_103; // weak
__int64 (__fastcall *camlArray__17)() = &caml_curry2; // weak
__int64 (__fastcall *camlArray__18)() = &caml_curry2; // weak
__int64 (__fastcall *camlArray__19)() = &camlArray__copy_77; // weak
__int64 (__fastcall *camlArray__20)() = &caml_curry3; // weak
__int64 (__fastcall *camlArray__21)() = &caml_curry2; // weak
char camlArray__3[13] = "Array.Bottom"; // weak
_UNKNOWN camlArray__22; // weak
_UNKNOWN camlArray__23; // weak
_UNKNOWN camlArray__24; // weak
_UNKNOWN camlArray__28; // weak
_UNKNOWN camlArray__30; // weak
_UNKNOWN camlArray__31; // weak
_UNKNOWN camlArray__32; // weak
_UNKNOWN camlArray__33; // weak
char *camlArray__34 = "array.ml"; // weak
__int64 (__fastcall *camlArray__35[2])() = { &caml_make_vect, &caml_make_vect }; // weak
_QWORD camlList[44] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  3319LL
}; // weak
__int64 (__fastcall *camlList__1)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__2)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__3)() = &caml_curry3; // weak
__int64 (__fastcall *camlList__4)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__5)() = &camlList__split_248; // weak
__int64 (__fastcall *camlList__6)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__7)() = &camlList__find_all_233; // weak
__int64 (__fastcall *camlList__8)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__9)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__10)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__11)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__12)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__13)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__14)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__15)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__16)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__17)() = &caml_curry3; // weak
__int64 (__fastcall *camlList__18)() = &caml_curry3; // weak
__int64 (__fastcall *camlList__19)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__20)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__21)() = &caml_curry4; // weak
__int64 (__fastcall *camlList__22)() = &caml_curry4; // weak
__int64 (__fastcall *camlList__23)() = &caml_curry3; // weak
__int64 (__fastcall *camlList__24)() = &caml_curry3; // weak
__int64 (__fastcall *camlList__25)() = &caml_curry3; // weak
__int64 (__fastcall *camlList__26)() = &caml_curry3; // weak
__int64 (__fastcall *camlList__27)() = &caml_curry3; // weak
__int64 (__fastcall *camlList__28)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__29)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__30)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__31)() = &camlList__flatten_86; // weak
__int64 (__fastcall *camlList__32)() = &camlList__rev_84; // weak
__int64 (__fastcall *camlList__33)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__34)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__35)() = &camlList__tl_67; // weak
__int64 (__fastcall *camlList__36)() = &camlList__hd_64; // weak
__int64 (__fastcall *camlList__37)() = &camlList__length_62; // weak
__int64 (__fastcall *camlList__38)() = &caml_curry2; // weak
__int64 (__fastcall *camlList__48)() = &caml_curry2; // weak
char *camlList__39 = "list.ml"; // weak
_UNKNOWN camlList__41; // weak
_QWORD camlChar[6] = { 0LL, 0LL, 0LL, 0LL, 0LL, 3319LL }; // weak
__int64 (__fastcall *camlChar__1)() = &caml_curry2; // weak
__int64 (__fastcall *camlChar__2)() = &camlChar__uppercase_73; // weak
__int64 (__fastcall *camlChar__3)() = &camlChar__lowercase_71; // weak
__int64 (__fastcall *camlChar__4)() = &camlChar__escaped_66; // weak
__int64 (__fastcall *camlChar__5)() = &camlChar__code_begin; // weak
_QWORD camlString[25] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  3319LL
}; // weak
__int64 (__fastcall *camlString__1)() = &caml_curry2; // weak
__int64 (__fastcall *camlString__2)() = &caml_curry3; // weak
__int64 (__fastcall *camlString__3)() = &caml_curry2; // weak
__int64 (__fastcall *camlString__4)() = &caml_curry3; // weak
__int64 (__fastcall *camlString__5)() = &caml_curry3; // weak
__int64 (__fastcall *camlString__6)() = &caml_curry2; // weak
__int64 (__fastcall *camlString__7)() = &caml_curry3; // weak
__int64 (__fastcall *camlString__8)() = &caml_curry3; // weak
__int64 (__fastcall *camlString__9)() = &caml_curry2; // weak
__int64 (__fastcall *camlString__10)() = &caml_curry4; // weak
__int64 (__fastcall *camlString__11)() = &camlString__uncapitalize_134; // weak
__int64 (__fastcall *camlString__12)() = &camlString__capitalize_132; // weak
__int64 (__fastcall *camlString__13)() = &caml_curry2; // weak
__int64 (__fastcall *camlString__14)() = &camlString__lowercase_126; // weak
__int64 (__fastcall *camlString__15)() = &camlString__uppercase_124; // weak
__int64 (__fastcall *camlString__16)() = &caml_curry2; // weak
__int64 (__fastcall *camlString__17)() = &camlString__escaped_108; // weak
__int64 (__fastcall *camlString__18)() = &caml_curry2; // weak
__int64 (__fastcall *camlString__19)() = &caml_curry2; // weak
__int64 (__fastcall *camlString__20)() = &caml_curry5; // weak
__int64 (__fastcall *camlString__21)() = &caml_curry4; // weak
__int64 (__fastcall *camlString__22)() = &caml_curry3; // weak
__int64 (__fastcall *camlString__23)() = &camlString__copy_70; // weak
__int64 (__fastcall *camlString__24)() = &caml_curry2; // weak
_UNKNOWN camlString__29; // weak
__int64 camlSys[33] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  2295LL
}; // weak
__int64 (__fastcall *camlSys__2)() = &camlSys__catch_break_110; // weak
__int64 (__fastcall *camlSys__4)() = &caml_curry2; // weak
void (__fastcall __noreturn *camlSys__5)() = &camlSys__code_begin; // weak
char camlSys__1[7] = "3.11.2"; // weak
char camlSys__3[10] = "Sys.Break"; // weak
_QWORD camlHashtbl[17] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  2295LL
}; // weak
__int64 (__fastcall *camlHashtbl__1)() = &camlHashtbl__Make_279; // weak
__int64 (__fastcall *camlHashtbl__2)() = &caml_curry3; // weak
__int64 (__fastcall *camlHashtbl__3)() = &caml_curry2; // weak
__int64 (__fastcall *camlHashtbl__4)() = &caml_curry2; // weak
__int64 (__fastcall *camlHashtbl__5)() = &caml_curry3; // weak
__int64 (__fastcall *camlHashtbl__6)() = &caml_curry2; // weak
__int64 (__fastcall *camlHashtbl__7)() = &caml_curry2; // weak
__int64 (__fastcall *camlHashtbl__8)() = &caml_curry2; // weak
__int64 (__fastcall *camlHashtbl__9)() = &caml_curry2; // weak
__int64 (__fastcall *camlHashtbl__10)() = &caml_curry3; // weak
__int64 (__fastcall *camlHashtbl__11)() = &caml_curry2; // weak
__int64 (__fastcall *camlHashtbl__12)() = &camlHashtbl__length_87; // weak
__int64 (__fastcall *camlHashtbl__13)() = &camlHashtbl__copy_85; // weak
__int64 (__fastcall *camlHashtbl__14)() = &camlHashtbl__clear_82; // weak
__int64 (__fastcall *camlHashtbl__15)() = &camlHashtbl__create_79; // weak
__int64 (__fastcall *camlHashtbl__16)() = &camlHashtbl__hash_59; // weak
_QWORD camlMarshal[8] = { 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 3319LL }; // weak
__int64 (__fastcall *camlMarshal__1)() = &caml_curry2; // weak
__int64 (__fastcall *camlMarshal__2)() = &caml_curry2; // weak
__int64 (__fastcall *camlMarshal__3)() = &caml_curry2; // weak
__int64 (__fastcall *camlMarshal__4)() = &caml_curry5; // weak
__int64 (__fastcall *camlMarshal__5)() = &caml_curry3; // weak
__int64 (__fastcall *camlMarshal__6)() = &camlMarshal__code_begin; // weak
_QWORD camlObj[20] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  3319LL
}; // weak
__int64 (__fastcall *camlObj__1)() = &caml_curry2; // weak
__int64 (__fastcall *camlObj__2)() = &camlObj__marshal_80; // weak
__int64 (__fastcall *camlObj__3)() = &caml_curry3; // weak
__int64 (__fastcall *camlObj__4)() = &caml_curry2; // weak
_UNKNOWN camlMap; // weak
__int64 (__fastcall *camlMap__1)() = &camlMap__Make_249; // weak
__int64 (__fastcall *camlMap__2)() = &caml_curry2; // weak
__int64 (__fastcall *camlMap__3)() = &caml_curry3; // weak
__int64 (__fastcall *camlMap__4)() = &caml_curry2; // weak
__int64 (__fastcall *camlMap__5)() = &caml_curry2; // weak
__int64 (__fastcall *camlMap__6)() = &caml_curry2; // weak
__int64 (__fastcall *camlMap__7)() = &camlMap__min_binding_144; // weak
__int64 (__fastcall *camlMap__8)() = &camlMap__is_empty_120; // weak
__int64 (__fastcall *camlMap__9)() = &camlMap__height_85; // weak
_QWORD camlBuffer[21] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  3319LL
}; // weak
__int64 (__fastcall *camlBuffer__1)() = &caml_curry3; // weak
__int64 (__fastcall *camlBuffer__2)() = &caml_curry3; // weak
__int64 (__fastcall *camlBuffer__3)() = &caml_curry2; // weak
__int64 (__fastcall *camlBuffer__4)() = &caml_curry5; // weak
__int64 (__fastcall *camlBuffer__5)() = &camlBuffer__closing_125; // weak
__int64 (__fastcall *camlBuffer__6)() = &caml_curry2; // weak
__int64 (__fastcall *camlBuffer__7)() = &caml_curry3; // weak
__int64 (__fastcall *camlBuffer__8)() = &caml_curry2; // weak
__int64 (__fastcall *camlBuffer__9)() = &caml_curry2; // weak
__int64 (__fastcall *camlBuffer__10)() = &caml_curry4; // weak
__int64 (__fastcall *camlBuffer__11)() = &caml_curry2; // weak
__int64 (__fastcall *camlBuffer__12)() = &caml_curry2; // weak
__int64 (__fastcall *camlBuffer__13)() = &camlBuffer__reset_92; // weak
__int64 (__fastcall *camlBuffer__14)() = &camlBuffer__clear_90; // weak
__int64 (__fastcall *camlBuffer__15)() = &camlBuffer__length_88; // weak
__int64 (__fastcall *camlBuffer__16)() = &caml_curry2; // weak
__int64 (__fastcall *camlBuffer__17)() = &caml_curry5; // weak
__int64 (__fastcall *camlBuffer__18)() = &caml_curry3; // weak
__int64 (__fastcall *camlBuffer__19)() = &camlBuffer__contents_72; // weak
__int64 (__fastcall *camlBuffer__20)() = &camlBuffer__create_67; // weak
char *camlBuffer__21 = "buffer.ml"; // weak
_QWORD camlPrintf[40] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  2295LL
}; // weak
__int64 (__fastcall *camlPrintf__1)() = &camlPrintf__sprintf_446; // weak
__int64 (__fastcall *camlPrintf__2)() = &camlPrintf__ksprintf_443; // weak
__int64 (__fastcall *camlPrintf__3)() = &caml_curry2; // weak
__int64 (__fastcall *camlPrintf__4)() = &camlPrintf__get_contents_437; // weak
__int64 (__fastcall *camlPrintf__5)() = &camlPrintf__get_buff_434; // weak
__int64 (__fastcall *camlPrintf__6)() = &camlPrintf__bprintf_432; // weak
__int64 (__fastcall *camlPrintf__7)() = &caml_curry2; // weak
__int64 (__fastcall *camlPrintf__8)() = &camlPrintf__eprintf_427; // weak
__int64 (__fastcall *camlPrintf__9)() = &camlPrintf__printf_425; // weak
__int64 (__fastcall *camlPrintf__10)() = &camlPrintf__fprintf_423; // weak
__int64 (__fastcall *camlPrintf__11)() = &camlPrintf__ifprintf_421; // weak
__int64 (__fastcall *camlPrintf__12)() = &caml_curry2; // weak
__int64 (__fastcall *camlPrintf__13)() = &caml_curry7; // weak
__int64 (__fastcall *camlPrintf__14)() = &caml_curry9; // weak
__int64 (__fastcall *camlPrintf__15)() = &caml_curry2; // weak
__int64 (__fastcall *camlPrintf__16)() = &caml_curry2; // weak
__int64 (__fastcall *camlPrintf__17)() = &caml_curry2; // weak
__int64 (__fastcall *camlPrintf__18)() = &caml_curry4; // weak
__int64 (__fastcall *camlPrintf__19)() = &caml_curry2; // weak
__int64 (__fastcall *camlPrintf__20)() = &caml_curry2; // weak
__int64 (__fastcall *camlPrintf__21)() = &camlPrintf__count_arguments_of_format_226; // weak
__int64 (__fastcall *camlPrintf__22)() = &camlPrintf__ac_of_format_212; // weak
__int64 (__fastcall *camlPrintf__24)() = &camlPrintf__summarize_format_type_190; // weak
__int64 (__fastcall *camlPrintf__25)() = &caml_curry3; // weak
__int64 (__fastcall *camlPrintf__26)() = &camlPrintf__sub_format_for_printf_163; // weak
__int64 (__fastcall *camlPrintf__27)() = &caml_curry5; // weak
__int64 (__fastcall *camlPrintf__28)() = &caml_curry5; // weak
__int64 (__fastcall *camlPrintf__29)() = &caml_curry5; // weak
__int64 (__fastcall *camlPrintf__30)() = &caml_curry4; // weak
__int64 (__fastcall *camlPrintf__31)() = &caml_curry2; // weak
__int64 (__fastcall *camlPrintf__32)() = &caml_curry6; // weak
__int64 (__fastcall *camlPrintf__33)() = &camlPrintf__parse_string_conversion_95; // weak
void (__fastcall __noreturn *camlPrintf__34)() = &camlPrintf__incomplete_format_93; // weak
__int64 (__fastcall *camlPrintf__35)() = &caml_curry3; // weak
__int64 (__fastcall *camlPrintf__36)() = &caml_curry3; // weak
__int64 (__fastcall *camlPrintf__37)() = &caml_curry3; // weak
__int64 (__fastcall *camlPrintf__38)() = &camlPrintf__index_of_int_65; // weak
__int64 (__fastcall *camlPrintf__40)() = &camlPrintf__fun_737; // weak
__int64 (__fastcall *camlPrintf__42)() = &camlPrintf__fun_727; // weak
__int64 (__fastcall *camlPrintf__45)() = &caml_curry2; // weak
__int64 (__fastcall *camlPrintf__48)() = &caml_curry2; // weak
__int64 (__fastcall *camlPrintf__56)() = &camlPrintf__fun_716; // weak
_UNKNOWN camlPrintf__23; // weak
_UNKNOWN camlPrintf__46; // weak
char *camlPrintf__67 = "printf.ml"; // weak
_QWORD camlCallback[3] = { 0LL, 0LL, 3319LL }; // weak
__int64 (__fastcall *camlCallback__1)() = &caml_curry2; // weak
__int64 (__fastcall *camlCallback__2)() = &caml_curry2; // weak
_QWORD camlCamlinternalOO[80] =
{
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  2295LL
}; // weak
__int64 (__fastcall *camlCamlinternalOO__1)() = &camlCamlinternalOO__stats_623; // weak
__int64 (__fastcall *camlCamlinternalOO__2)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__3)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__4)() = &camlCamlinternalOO__new_cache_492; // weak
__int64 (__fastcall *camlCamlinternalOO__5)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__6)() = &caml_curry4; // weak
__int64 (__fastcall *camlCamlinternalOO__7)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__8)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__9)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__10)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__11)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__12)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__13)() = &caml_curry4; // weak
__int64 (__fastcall *camlCamlinternalOO__14)() = &caml_curry4; // weak
__int64 (__fastcall *camlCamlinternalOO__15)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__16)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__17)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__18)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__19)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__20)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__21)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__22)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__23)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__24)() = &camlCamlinternalOO__set_var_396; // weak
__int64 (__fastcall *camlCamlinternalOO__25)() = &camlCamlinternalOO__get_meth_393; // weak
__int64 (__fastcall *camlCamlinternalOO__26)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__27)() = &camlCamlinternalOO__get_var_386; // weak
__int64 (__fastcall *camlCamlinternalOO__28)() = &camlCamlinternalOO__get_const_383; // weak
__int64 (__fastcall *camlCamlinternalOO__29)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__30)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__31)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__32)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__33)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__34)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__35)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__36)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__37)() = &camlCamlinternalOO__create_object_323; // weak
__int64 (__fastcall *camlCamlinternalOO__38)() = &camlCamlinternalOO__dummy_class_320; // weak
__int64 (__fastcall *camlCamlinternalOO__39)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__40)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__41)() = &caml_curry6; // weak
__int64 (__fastcall *camlCamlinternalOO__42)() = &camlCamlinternalOO__init_class_292; // weak
__int64 (__fastcall *camlCamlinternalOO__43)() = &camlCamlinternalOO__create_table_285; // weak
__int64 (__fastcall *camlCamlinternalOO__44)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__45)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__46)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__47)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__48)() = &camlCamlinternalOO__to_array_264; // weak
__int64 (__fastcall *camlCamlinternalOO__49)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__50)() = &camlCamlinternalOO__new_slot_257; // weak
__int64 (__fastcall *camlCamlinternalOO__51)() = &camlCamlinternalOO__widen_244; // weak
__int64 (__fastcall *camlCamlinternalOO__52)() = &caml_curry4; // weak
__int64 (__fastcall *camlCamlinternalOO__53)() = &camlCamlinternalOO__to_list_220; // weak
__int64 (__fastcall *camlCamlinternalOO__54)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__55)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__56)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__57)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__58)() = &camlCamlinternalOO__new_method_203; // weak
__int64 (__fastcall *camlCamlinternalOO__59)() = &caml_curry3; // weak
__int64 (__fastcall *camlCamlinternalOO__60)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__61)() = &camlCamlinternalOO__new_table_186; // weak
__int64 (__fastcall *camlCamlinternalOO__62)() = &camlCamlinternalOO__fit_size_184; // weak
__int64 (__fastcall *camlCamlinternalOO__63)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__64)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__65)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__66)() = &camlCamlinternalOO__public_method_label_102; // weak
__int64 (__fastcall *camlCamlinternalOO__67)() = &camlCamlinternalOO__copy_65; // weak
__int64 (__fastcall *camlCamlinternalOO__68)() = &caml_curry2; // weak
__int64 (__fastcall *camlCamlinternalOO__69)() = &camlCamlinternalOO__new_id_59; // weak
char *camlCamlinternalOO__71 = "camlinternalOO.ml"; // weak
_UNKNOWN camlCamlinternalOO__72; // weak
_QWORD camlCamlinternalOO__73[2] = { 504403158265495552LL, 4427680LL }; // weak
_UNKNOWN access_permission_table; // weak
_UNKNOWN getnameinfo_flag_table; // weak
_UNKNOWN open_flag_table; // weak
_UNKNOWN msg_flag_table; // weak
_DWORD socket_domain_table[4] = { 1, 2, 10, 0 }; // weak
_DWORD socket_type_table[4] = { 1, 2, 3, 5 }; // weak
_DWORD file_kind_table[8] = { 32768, 16384, 8192, 24576, 40960, 4096, 49152, 0 }; // weak
__int64 terminal_io_descr = 0LL; // weak
_DWORD error_table[68] =
{
  7,
  13,
  11,
  9,
  16,
  10,
  35,
  33,
  17,
  14,
  27,
  4,
  22,
  5,
  21,
  24,
  31,
  36,
  23,
  19,
  2,
  8,
  37,
  12,
  28,
  38,
  20,
  39,
  25,
  6,
  1,
  32,
  34,
  30,
  29,
  3,
  18,
  11,
  115,
  114,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  40,
  75
}; // weak
_UNKNOWN wait_flag_table; // weak
__int64 max_percent_free_init = 500LL; // weak
__int64 percent_free_init = 80LL; // weak
__int64 heap_chunk_init = 126976LL; // weak
__int64 heap_size_init = 126976LL; // weak
__int64 minor_heap_init = 32768LL; // weak
__int64 array_bound_error_msg = 0LL; // weak
char aIndexOutOfBoun[20] = "index out of bounds"; // weak
char byte_65869F = '\0'; // weak
__int64 caml_last_return_address = 1LL; // weak
__int64 (*caml_enter_blocking_section_hook)(void) = &caml_enter_blocking_section_default; // weak
__int64 (*caml_leave_blocking_section_hook)(void) = &caml_leave_blocking_section_default; // weak
__int64 (*caml_try_leave_blocking_section_hook)(void) = &caml_try_leave_blocking_section_default; // weak
__int64 *caml_fl_merge = &qword_658710; // weak
__int64 qword_658710 = 0LL; // weak
__int64 *fl_prev = &qword_658710; // weak
void *compare_stack = &compare_stack_init; // idb
int *compare_stack_limit = &locale_is_set_3458; // weak
char *caml_int32_ops = "_i"; // weak
char *caml_int64_ops = "_j"; // weak
char *caml_nativeint_ops = "_n"; // weak
char *channel_operations = "_chan"; // weak
_UNKNOWN extern_flags; // weak
_UNKNOWN sys_open_flags; // weak
void *caml_weak_none = &weak_dummy; // weak
__int64 caml_backtrace_last_exn = 1LL; // weak
FILE *stderr; // idb
int entry_h_length; // weak
struct termios terminal_status; // idb
__int64 unix_error_exn; // weak
__int64 (__fastcall *caml_termination_hook)(_QWORD); // weak
char proc_self_exe_3682[256]; // idb
__int64 caml_exception_pointer; // weak
int array_bound_error_bucket_inited; // weak
__int64 array_bound_error_bucket; // weak
__int64 qword_658A58; // weak
__int64 qword_658A60; // weak
__int64 caml_local_roots; // weak
__int64 (__fastcall *caml_scan_roots_hook)(_QWORD); // weak
void *caml_frame_descriptors; // idb
__int64 caml_bottom_of_stack; // weak
__int64 caml_globals_inited; // weak
__int64 caml_dyn_globals; // weak
__int64 caml_globals_scanned; // weak
__int64 frametables; // weak
int inited_3995; // weak
_UNKNOWN caml_global_roots; // weak
_UNKNOWN caml_global_roots_young; // weak
__int64 qword_658B68; // weak
int dword_658BF0; // weak
_UNKNOWN caml_global_roots_old; // weak
int random_seed; // weak
__int64 caml_signals_are_pending; // weak
int caml_force_major_slice; // weak
__int64 caml_async_signal_mode; // weak
__int64 caml_signal_handlers; // weak
__int64 system_stack_top; // weak
_UNKNOWN sig_alt_stack; // weak
__int64 caml_verb_gc; // weak
__int64 caml_fl_cur_size; // weak
__int64 caml_allocation_policy; // weak
int flp_size; // weak
__int64 beyond; // weak
__int64 fl_last; // weak
__int64 flp[]; // weak
_UNKNOWN unk_65AD48; // weak
__int64 qword_65CC78; // weak
__int64 last_fragment; // weak
__int64 caml_fl_size_at_phase_change; // weak
void *gray_vals; // idb
__int64 gray_vals_cur; // weak
__int64 gray_vals_end; // weak
__int64 gray_vals_size; // weak
int heap_is_pure; // weak
__int64 markhp; // weak
__int64 chunk; // weak
__int64 limit; // weak
__int64 weak_prev; // weak
__int64 caml_young_start; // weak
__int64 caml_young_end; // weak
__int64 caml_young_ptr; // weak
__int64 caml_young_limit; // weak
void *caml_ref_table; // idb
__int64 qword_65CD08; // weak
__int64 qword_65CD10; // weak
__int64 qword_65CD18; // weak
__int64 qword_65CD20; // weak
__int64 qword_65CD28; // weak
__int64 qword_65CD30; // weak
void *caml_weak_ref_table; // idb
__int64 qword_65CD48; // weak
__int64 qword_65CD50; // weak
__int64 qword_65CD58; // weak
__int64 qword_65CD60; // weak
__int64 qword_65CD68; // weak
__int64 qword_65CD70; // weak
int caml_in_minor_collection; // weak
__int64 oldify_todo_list; // weak
void *caml_young_base; // idb
size_t caml_page_table; // idb
int dword_65CDA8; // weak
__int64 qword_65CDB0; // weak
__int64 qword_65CDB8; // weak
void *ptr; // idb
_UNKNOWN compare_stack_init; // weak
int locale_is_set_3458; // weak
__int64 (__fastcall *caml_channel_mutex_free)(_QWORD); // weak
__int64 (__fastcall *caml_channel_mutex_lock)(_QWORD); // weak
__int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD); // weak
__int64 (*caml_channel_mutex_unlock_exn)(void); // weak
__int64 caml_all_opened_channels; // weak
__int64 obj_counter; // weak
__int64 size_32; // weak
__int64 size_64; // weak
int extern_ignore_sharing; // weak
int extern_closures; // weak
_UNKNOWN extern_trail_first; // weak
_UNKNOWN unk_65E648; // weak
void *extern_trail_block; // idb
__int64 extern_trail_cur; // weak
__int64 extern_trail_limit; // weak
__int64 extern_userprovided_output; // weak
void *extern_ptr; // idb
__int64 extern_limit; // weak
void *extern_output_first; // idb
__int64 extern_output_block; // weak
int checksum_computed_4045; // weak
_QWORD checksum_4044[2]; // weak
void *intern_src; // idb
void *intern_input; // idb
int intern_input_malloced; // weak
__int64 intern_dest; // weak
__int64 intern_extra_block; // weak
__int64 obj_counter_0; // weak
void *intern_obj_table; // idb
int intern_color; // weak
__int64 intern_header; // weak
__int64 intern_block; // weak
__int64 hash_accu; // weak
__int64 hash_univ_limit; // weak
__int64 hash_univ_count; // weak
__int64 caml_main_argv; // weak
int caml_parser_trace; // weak
__int64 caml_stat_minor_words; // weak
__int64 caml_stat_promoted_words; // weak
__int64 caml_stat_major_words; // weak
__int64 caml_stat_minor_collections; // weak
__int64 caml_stat_major_collections; // weak
__int64 caml_stat_heap_size; // weak
__int64 caml_stat_top_heap_size; // weak
__int64 caml_stat_compactions; // weak
__int64 caml_stat_heap_chunks; // weak
__int64 named_value_table[13]; // weak
__int64 caml_weak_list_head; // weak
__int64 compact_fl; // weak
int running_finalisation_function; // weak
__int64 young; // weak
__int64 size; // weak
__int64 final_table; // weak
__int64 old; // weak
void *to_do_hd; // idb
__int64 to_do_tl; // weak
__int64 custom_ops_final_table; // weak
__int64 custom_ops_table; // weak
int caml_backtrace_active; // weak
int caml_backtrace_pos; // weak
__int64 caml_backtrace_buffer; // weak
__int64 caml_code_area_start; // weak
struct __jmp_buf_tag caml_termination_jmpbuf; // idb
__int64 caml_code_area_end; // weak
_QWORD caml_atom_table[1]; // weak
_UNKNOWN unk_662968; // weak
_UNKNOWN unk_663148; // weak
int caml_frame_descriptors_mask; // weak
__int64 caml_gc_regs; // weak
__int64 caml_pending_signals[65]; // weak
int caml_gc_subphase; // weak
__int64 caml_gc_sweep_hp; // weak
__int64 caml_percent_free; // weak
__int64 caml_dependent_size; // weak
void *caml_heap_start; // idb
int caml_gc_phase; // weak
__int64 caml_extra_heap_resources; // weak
__int64 caml_allocated_words; // weak
__int64 caml_major_heap_increment; // weak
__int64 caml_dependent_allocated; // weak
__int64 caml_minor_heap_size; // weak
int caml_compare_unordered; // weak
void *caml_exe_name; // idb
__int64 caml_percent_max; // weak
// extern char **environ;


//----- (000000000040A278) ----------------------------------------------------
__int64 sub_40A278()
{
  return qword_647478();
}
// 40A278: using guessed type __int64 __fastcall sub_40A278();
// 647478: using guessed type __int64 (*qword_647478)(void);

//----- (000000000040AE80) ----------------------------------------------------
__int64 __fastcall caml_startup__code_begin(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        double a7)
{
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // r9

  camlPervasives__entry(a1, a2, a3, a4, a5, a6);
  ++caml_globals_inited;
  camlArray__entry(a1, a2, v7, v8, v9, v10);
  ++caml_globals_inited;
  camlList__entry();
  ++caml_globals_inited;
  camlChar__entry();
  ++caml_globals_inited;
  camlString__entry();
  ++caml_globals_inited;
  camlSys__entry(a1, a2);
  ++caml_globals_inited;
  camlHashtbl__entry();
  ++caml_globals_inited;
  camlMarshal__entry();
  ++caml_globals_inited;
  camlObj__entry();
  ++caml_globals_inited;
  camlMap__entry(a1, a2, v11, v12, v13, v14);
  ++caml_globals_inited;
  camlBuffer__entry();
  ++caml_globals_inited;
  camlPrintf__entry(a1, a2, v15, v16, v17, v18);
  ++caml_globals_inited;
  camlCallback__entry();
  ++caml_globals_inited;
  camlCamlinternalOO__entry(a1, a2, v19, v20, v21, v22);
  ++caml_globals_inited;
  camlUnix__entry(a1, a2, v23, v24, v25, v26);
  ++caml_globals_inited;
  camlUnixLabels__code_begin();
  ++caml_globals_inited;
  camlSource__entry(a7);
  ++caml_globals_inited;
  camlStd_exit__code_begin();
  ++caml_globals_inited;
  return 1LL;
}
// 40AE94: variable 'v7' is possibly undefined
// 40AE94: variable 'v8' is possibly undefined
// 40AE94: variable 'v9' is possibly undefined
// 40AE94: variable 'v10' is possibly undefined
// 40AF14: variable 'v11' is possibly undefined
// 40AF14: variable 'v12' is possibly undefined
// 40AF14: variable 'v13' is possibly undefined
// 40AF14: variable 'v14' is possibly undefined
// 40AF34: variable 'v15' is possibly undefined
// 40AF34: variable 'v16' is possibly undefined
// 40AF34: variable 'v17' is possibly undefined
// 40AF34: variable 'v18' is possibly undefined
// 40AF54: variable 'v19' is possibly undefined
// 40AF54: variable 'v20' is possibly undefined
// 40AF54: variable 'v21' is possibly undefined
// 40AF54: variable 'v22' is possibly undefined
// 40AF64: variable 'v23' is possibly undefined
// 40AF64: variable 'v24' is possibly undefined
// 40AF64: variable 'v25' is possibly undefined
// 40AF64: variable 'v26' is possibly undefined
// 658A88: using guessed type __int64 caml_globals_inited;

//----- (000000000040AFB0) ----------------------------------------------------
_QWORD *__fastcall caml_curry9(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry9_1;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40AFB4: variable 'v6' is possibly undefined
// 40AFB7: variable 'v8' is possibly undefined
// 40AFE9: variable 'v7' is possibly undefined
// 40AFF2: variable 'a3' is possibly undefined
// 40AFF2: variable 'a4' is possibly undefined
// 40AFF2: variable 'a5' is possibly undefined
// 40AFF2: variable 'a6' is possibly undefined
// 40AFF2: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B000) ----------------------------------------------------
_QWORD *__fastcall caml_curry9_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry9_2;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B004: variable 'v6' is possibly undefined
// 40B007: variable 'v8' is possibly undefined
// 40B039: variable 'v7' is possibly undefined
// 40B042: variable 'a3' is possibly undefined
// 40B042: variable 'a4' is possibly undefined
// 40B042: variable 'a5' is possibly undefined
// 40B042: variable 'a6' is possibly undefined
// 40B042: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B050) ----------------------------------------------------
_QWORD *__fastcall caml_curry9_2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry9_3;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B054: variable 'v6' is possibly undefined
// 40B057: variable 'v8' is possibly undefined
// 40B089: variable 'v7' is possibly undefined
// 40B092: variable 'a3' is possibly undefined
// 40B092: variable 'a4' is possibly undefined
// 40B092: variable 'a5' is possibly undefined
// 40B092: variable 'a6' is possibly undefined
// 40B092: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B0A0) ----------------------------------------------------
_QWORD *__fastcall caml_curry9_3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry9_4;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B0A4: variable 'v6' is possibly undefined
// 40B0A7: variable 'v8' is possibly undefined
// 40B0D9: variable 'v7' is possibly undefined
// 40B0E2: variable 'a3' is possibly undefined
// 40B0E2: variable 'a4' is possibly undefined
// 40B0E2: variable 'a5' is possibly undefined
// 40B0E2: variable 'a6' is possibly undefined
// 40B0E2: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B0F0) ----------------------------------------------------
_QWORD *__fastcall caml_curry9_4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry9_5;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B0F4: variable 'v6' is possibly undefined
// 40B0F7: variable 'v8' is possibly undefined
// 40B129: variable 'v7' is possibly undefined
// 40B132: variable 'a3' is possibly undefined
// 40B132: variable 'a4' is possibly undefined
// 40B132: variable 'a5' is possibly undefined
// 40B132: variable 'a6' is possibly undefined
// 40B132: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B140) ----------------------------------------------------
_QWORD *__fastcall caml_curry9_5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry9_6;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B144: variable 'v6' is possibly undefined
// 40B147: variable 'v8' is possibly undefined
// 40B179: variable 'v7' is possibly undefined
// 40B182: variable 'a3' is possibly undefined
// 40B182: variable 'a4' is possibly undefined
// 40B182: variable 'a5' is possibly undefined
// 40B182: variable 'a6' is possibly undefined
// 40B182: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B190) ----------------------------------------------------
_QWORD *__fastcall caml_curry9_6(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry9_7;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B194: variable 'v6' is possibly undefined
// 40B197: variable 'v8' is possibly undefined
// 40B1C9: variable 'v7' is possibly undefined
// 40B1D2: variable 'a3' is possibly undefined
// 40B1D2: variable 'a4' is possibly undefined
// 40B1D2: variable 'a5' is possibly undefined
// 40B1D2: variable 'a6' is possibly undefined
// 40B1D2: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B1E0) ----------------------------------------------------
_QWORD *__fastcall caml_curry9_7(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry9_8;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B1E4: variable 'v6' is possibly undefined
// 40B1E7: variable 'v8' is possibly undefined
// 40B219: variable 'v7' is possibly undefined
// 40B222: variable 'a3' is possibly undefined
// 40B222: variable 'a4' is possibly undefined
// 40B222: variable 'a5' is possibly undefined
// 40B222: variable 'a6' is possibly undefined
// 40B222: variable 'v11' is possibly undefined
// 40B230: using guessed type __int64 __fastcall caml_curry9_8();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B230) ----------------------------------------------------
__int64 __fastcall caml_curry9_8()
{
  __int64 v0; // rbx
  __int64 v1; // rcx
  __int64 v2; // rdx
  __int64 v3; // rsi

  v1 = *(_QWORD *)(v0 + 24);
  v2 = *(_QWORD *)(v1 + 24);
  v3 = *(_QWORD *)(v2 + 24);
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 24LL) + 24LL) + 24LL)
                                                                                               + 24LL)
                                                                                   + 16LL))(
           *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 24LL) + 16LL),
           *(_QWORD *)(*(_QWORD *)(v3 + 24) + 16LL),
           *(_QWORD *)(v3 + 16),
           *(_QWORD *)(v2 + 16),
           *(_QWORD *)(v1 + 16),
           *(_QWORD *)(v0 + 16));
}
// 40B233: variable 'v0' is possibly undefined
// 40B230: using guessed type __int64 __fastcall caml_curry9_8();

//----- (000000000040B280) ----------------------------------------------------
_QWORD *__fastcall caml_curry7(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry7_1;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B284: variable 'v6' is possibly undefined
// 40B287: variable 'v8' is possibly undefined
// 40B2B9: variable 'v7' is possibly undefined
// 40B2C2: variable 'a3' is possibly undefined
// 40B2C2: variable 'a4' is possibly undefined
// 40B2C2: variable 'a5' is possibly undefined
// 40B2C2: variable 'a6' is possibly undefined
// 40B2C2: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B2D0) ----------------------------------------------------
_QWORD *__fastcall caml_curry7_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry7_2;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B2D4: variable 'v6' is possibly undefined
// 40B2D7: variable 'v8' is possibly undefined
// 40B309: variable 'v7' is possibly undefined
// 40B312: variable 'a3' is possibly undefined
// 40B312: variable 'a4' is possibly undefined
// 40B312: variable 'a5' is possibly undefined
// 40B312: variable 'a6' is possibly undefined
// 40B312: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B320) ----------------------------------------------------
_QWORD *__fastcall caml_curry7_2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry7_3;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B324: variable 'v6' is possibly undefined
// 40B327: variable 'v8' is possibly undefined
// 40B359: variable 'v7' is possibly undefined
// 40B362: variable 'a3' is possibly undefined
// 40B362: variable 'a4' is possibly undefined
// 40B362: variable 'a5' is possibly undefined
// 40B362: variable 'a6' is possibly undefined
// 40B362: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B370) ----------------------------------------------------
_QWORD *__fastcall caml_curry7_3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry7_4;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B374: variable 'v6' is possibly undefined
// 40B377: variable 'v8' is possibly undefined
// 40B3A9: variable 'v7' is possibly undefined
// 40B3B2: variable 'a3' is possibly undefined
// 40B3B2: variable 'a4' is possibly undefined
// 40B3B2: variable 'a5' is possibly undefined
// 40B3B2: variable 'a6' is possibly undefined
// 40B3B2: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B3C0) ----------------------------------------------------
_QWORD *__fastcall caml_curry7_4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry7_5;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B3C4: variable 'v6' is possibly undefined
// 40B3C7: variable 'v8' is possibly undefined
// 40B3F9: variable 'v7' is possibly undefined
// 40B402: variable 'a3' is possibly undefined
// 40B402: variable 'a4' is possibly undefined
// 40B402: variable 'a5' is possibly undefined
// 40B402: variable 'a6' is possibly undefined
// 40B402: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B410) ----------------------------------------------------
_QWORD *__fastcall caml_curry7_5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry7_6;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B414: variable 'v6' is possibly undefined
// 40B417: variable 'v8' is possibly undefined
// 40B449: variable 'v7' is possibly undefined
// 40B452: variable 'a3' is possibly undefined
// 40B452: variable 'a4' is possibly undefined
// 40B452: variable 'a5' is possibly undefined
// 40B452: variable 'a6' is possibly undefined
// 40B452: variable 'v11' is possibly undefined
// 40B460: using guessed type __int64 __fastcall caml_curry7_6();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B460) ----------------------------------------------------
__int64 __fastcall caml_curry7_6()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v2; // rdx

  v2 = *(_QWORD *)(v1 + 24);
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 24) + 24LL) + 24LL) + 24LL)
                                                                                        + 24LL)
                                                                            + 16LL))(
           *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 24) + 24LL) + 16LL),
           *(_QWORD *)(*(_QWORD *)(v2 + 24) + 16LL),
           *(_QWORD *)(v2 + 16),
           *(_QWORD *)(v1 + 16),
           v0);
}
// 40B463: variable 'v1' is possibly undefined
// 40B497: variable 'v0' is possibly undefined
// 40B460: using guessed type __int64 __fastcall caml_curry7_6();

//----- (000000000040B4A0) ----------------------------------------------------
_QWORD *__fastcall caml_curry6(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry6_1;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B4A4: variable 'v6' is possibly undefined
// 40B4A7: variable 'v8' is possibly undefined
// 40B4D9: variable 'v7' is possibly undefined
// 40B4E2: variable 'a3' is possibly undefined
// 40B4E2: variable 'a4' is possibly undefined
// 40B4E2: variable 'a5' is possibly undefined
// 40B4E2: variable 'a6' is possibly undefined
// 40B4E2: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B4F0) ----------------------------------------------------
_QWORD *__fastcall caml_curry6_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry6_2;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B4F4: variable 'v6' is possibly undefined
// 40B4F7: variable 'v8' is possibly undefined
// 40B529: variable 'v7' is possibly undefined
// 40B532: variable 'a3' is possibly undefined
// 40B532: variable 'a4' is possibly undefined
// 40B532: variable 'a5' is possibly undefined
// 40B532: variable 'a6' is possibly undefined
// 40B532: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B540) ----------------------------------------------------
_QWORD *__fastcall caml_curry6_2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry6_3;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B544: variable 'v6' is possibly undefined
// 40B547: variable 'v8' is possibly undefined
// 40B579: variable 'v7' is possibly undefined
// 40B582: variable 'a3' is possibly undefined
// 40B582: variable 'a4' is possibly undefined
// 40B582: variable 'a5' is possibly undefined
// 40B582: variable 'a6' is possibly undefined
// 40B582: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B590) ----------------------------------------------------
_QWORD *__fastcall caml_curry6_3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry6_4;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B594: variable 'v6' is possibly undefined
// 40B597: variable 'v8' is possibly undefined
// 40B5C9: variable 'v7' is possibly undefined
// 40B5D2: variable 'a3' is possibly undefined
// 40B5D2: variable 'a4' is possibly undefined
// 40B5D2: variable 'a5' is possibly undefined
// 40B5D2: variable 'a6' is possibly undefined
// 40B5D2: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B5E0) ----------------------------------------------------
_QWORD *__fastcall caml_curry6_4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry6_5;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B5E4: variable 'v6' is possibly undefined
// 40B5E7: variable 'v8' is possibly undefined
// 40B619: variable 'v7' is possibly undefined
// 40B622: variable 'a3' is possibly undefined
// 40B622: variable 'a4' is possibly undefined
// 40B622: variable 'a5' is possibly undefined
// 40B622: variable 'a6' is possibly undefined
// 40B622: variable 'v11' is possibly undefined
// 40B630: using guessed type __int64 __fastcall caml_curry6_5();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B630) ----------------------------------------------------
__int64 __fastcall caml_curry6_5()
{
  __int64 v0; // rax
  __int64 v1; // rbx

  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 24) + 24LL) + 24LL)
                                                                                            + 24LL)
                                                                                + 24LL)
                                                                    + 16LL))(
           *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 24) + 24LL) + 16LL),
           *(_QWORD *)(*(_QWORD *)(v1 + 24) + 16LL),
           *(_QWORD *)(v1 + 16),
           v0);
}
// 40B633: variable 'v1' is possibly undefined
// 40B65F: variable 'v0' is possibly undefined
// 40B630: using guessed type __int64 __fastcall caml_curry6_5();

//----- (000000000040B670) ----------------------------------------------------
_QWORD *__fastcall caml_curry5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry5_1;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B674: variable 'v6' is possibly undefined
// 40B677: variable 'v8' is possibly undefined
// 40B6A9: variable 'v7' is possibly undefined
// 40B6B2: variable 'a3' is possibly undefined
// 40B6B2: variable 'a4' is possibly undefined
// 40B6B2: variable 'a5' is possibly undefined
// 40B6B2: variable 'a6' is possibly undefined
// 40B6B2: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B6C0) ----------------------------------------------------
_QWORD *__fastcall caml_curry5_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry5_2;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B6C4: variable 'v6' is possibly undefined
// 40B6C7: variable 'v8' is possibly undefined
// 40B6F9: variable 'v7' is possibly undefined
// 40B702: variable 'a3' is possibly undefined
// 40B702: variable 'a4' is possibly undefined
// 40B702: variable 'a5' is possibly undefined
// 40B702: variable 'a6' is possibly undefined
// 40B702: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B710) ----------------------------------------------------
_QWORD *__fastcall caml_curry5_2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry5_3;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B714: variable 'v6' is possibly undefined
// 40B717: variable 'v8' is possibly undefined
// 40B749: variable 'v7' is possibly undefined
// 40B752: variable 'a3' is possibly undefined
// 40B752: variable 'a4' is possibly undefined
// 40B752: variable 'a5' is possibly undefined
// 40B752: variable 'a6' is possibly undefined
// 40B752: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B760) ----------------------------------------------------
_QWORD *__fastcall caml_curry5_3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry5_4;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B764: variable 'v6' is possibly undefined
// 40B767: variable 'v8' is possibly undefined
// 40B799: variable 'v7' is possibly undefined
// 40B7A2: variable 'a3' is possibly undefined
// 40B7A2: variable 'a4' is possibly undefined
// 40B7A2: variable 'a5' is possibly undefined
// 40B7A2: variable 'a6' is possibly undefined
// 40B7A2: variable 'v11' is possibly undefined
// 40B7B0: using guessed type __int64 __fastcall caml_curry5_4();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B7B0) ----------------------------------------------------
__int64 __fastcall caml_curry5_4()
{
  __int64 v0; // rax
  __int64 v1; // rbx

  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 24)
                                                                                                + 24LL)
                                                                                    + 24LL)
                                                                        + 24LL)
                                                            + 16LL))(
           *(_QWORD *)(*(_QWORD *)(v1 + 24) + 16LL),
           *(_QWORD *)(v1 + 16),
           v0);
}
// 40B7B3: variable 'v1' is possibly undefined
// 40B7D7: variable 'v0' is possibly undefined
// 40B7B0: using guessed type __int64 __fastcall caml_curry5_4();

//----- (000000000040B7E0) ----------------------------------------------------
_QWORD *__fastcall caml_curry4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry4_1;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B7E4: variable 'v6' is possibly undefined
// 40B7E7: variable 'v8' is possibly undefined
// 40B819: variable 'v7' is possibly undefined
// 40B822: variable 'a3' is possibly undefined
// 40B822: variable 'a4' is possibly undefined
// 40B822: variable 'a5' is possibly undefined
// 40B822: variable 'a6' is possibly undefined
// 40B822: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B830) ----------------------------------------------------
_QWORD *__fastcall caml_curry4_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry4_2;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B834: variable 'v6' is possibly undefined
// 40B837: variable 'v8' is possibly undefined
// 40B869: variable 'v7' is possibly undefined
// 40B872: variable 'a3' is possibly undefined
// 40B872: variable 'a4' is possibly undefined
// 40B872: variable 'a5' is possibly undefined
// 40B872: variable 'a6' is possibly undefined
// 40B872: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B880) ----------------------------------------------------
_QWORD *__fastcall caml_curry4_2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry4_3;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B884: variable 'v6' is possibly undefined
// 40B887: variable 'v8' is possibly undefined
// 40B8B9: variable 'v7' is possibly undefined
// 40B8C2: variable 'a3' is possibly undefined
// 40B8C2: variable 'a4' is possibly undefined
// 40B8C2: variable 'a5' is possibly undefined
// 40B8C2: variable 'a6' is possibly undefined
// 40B8C2: variable 'v11' is possibly undefined
// 40B8D0: using guessed type __int64 __fastcall caml_curry4_3();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B8D0) ----------------------------------------------------
__int64 __fastcall caml_curry4_3()
{
  __int64 v0; // rax
  __int64 v1; // rbx

  return (*(__int64 (__fastcall **)(_QWORD, __int64))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 24) + 24LL) + 24LL) + 16LL))(
           *(_QWORD *)(v1 + 16),
           v0);
}
// 40B8D3: variable 'v1' is possibly undefined
// 40B8EF: variable 'v0' is possibly undefined
// 40B8D0: using guessed type __int64 __fastcall caml_curry4_3();

//----- (000000000040B900) ----------------------------------------------------
_QWORD *__fastcall caml_curry3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry3_1;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B904: variable 'v6' is possibly undefined
// 40B907: variable 'v8' is possibly undefined
// 40B939: variable 'v7' is possibly undefined
// 40B942: variable 'a3' is possibly undefined
// 40B942: variable 'a4' is possibly undefined
// 40B942: variable 'a5' is possibly undefined
// 40B942: variable 'a6' is possibly undefined
// 40B942: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B950) ----------------------------------------------------
_QWORD *__fastcall caml_curry3_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry3_2;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B954: variable 'v6' is possibly undefined
// 40B957: variable 'v8' is possibly undefined
// 40B989: variable 'v7' is possibly undefined
// 40B992: variable 'a3' is possibly undefined
// 40B992: variable 'a4' is possibly undefined
// 40B992: variable 'a5' is possibly undefined
// 40B992: variable 'a6' is possibly undefined
// 40B992: variable 'v11' is possibly undefined
// 40B9A0: using guessed type __int64 __fastcall caml_curry3_2();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040B9A0) ----------------------------------------------------
__int64 __fastcall caml_curry3_2()
{
  __int64 v0; // rax
  __int64 v1; // rbx

  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(v1 + 24) + 24LL) + 16LL))(v0);
}
// 40B9A3: variable 'v1' is possibly undefined
// 40B9B7: variable 'v0' is possibly undefined
// 40B9A0: using guessed type __int64 __fastcall caml_curry3_2();

//----- (000000000040B9C0) ----------------------------------------------------
_QWORD *__fastcall caml_curry2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = caml_curry2_1;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 40B9C4: variable 'v6' is possibly undefined
// 40B9C7: variable 'v8' is possibly undefined
// 40B9F9: variable 'v7' is possibly undefined
// 40BA02: variable 'a3' is possibly undefined
// 40BA02: variable 'a4' is possibly undefined
// 40BA02: variable 'a5' is possibly undefined
// 40BA02: variable 'a6' is possibly undefined
// 40BA02: variable 'v11' is possibly undefined
// 40BA10: using guessed type __int64 __fastcall caml_curry2_1();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040BA10) ----------------------------------------------------
__int64 __fastcall caml_curry2_1()
{
  __int64 v0; // rbx

  return (*(__int64 (**)(void))(*(_QWORD *)(v0 + 24) + 16LL))();
}
// 40BA13: variable 'v0' is possibly undefined
// 40BA10: using guessed type __int64 __fastcall caml_curry2_1();

//----- (000000000040BA30) ----------------------------------------------------
__int64 __fastcall caml_tuplify2()
{
  __int64 v0; // rbx

  return (*(__int64 (**)(void))(v0 + 16))();
}
// 40BA3A: variable 'v0' is possibly undefined
// 40BA30: using guessed type __int64 __fastcall caml_tuplify2();

//----- (000000000040BA40) ----------------------------------------------------
__int64 __fastcall caml_tuplify3()
{
  __int64 v0; // rax
  __int64 v1; // rbx

  return (*(__int64 (__fastcall **)(_QWORD))(v1 + 16))(*(_QWORD *)(v0 + 16));
}
// 40BA4E: variable 'v1' is possibly undefined
// 40BA43: variable 'v0' is possibly undefined
// 40BA40: using guessed type __int64 __fastcall caml_tuplify3();

//----- (000000000040BA60) ----------------------------------------------------
__int64 __fastcall caml_send0(__int64 *a1)
{
  __int64 **v1; // rax
  __int64 v2; // rbx
  __int64 *v3; // rsi
  __int64 v4; // rdx
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // rdx

  v3 = *v1;
  v4 = (*v1)[1] & *a1;
  if ( *(__int64 *)((char *)*v1 + v4 + 23) != v2 )
  {
    v5 = 3LL;
    v6 = *v3;
    do
    {
      v7 = ((unsigned __int64)(v6 + v5) >> 1) | 1;
      if ( v2 >= v3[v7] )
        v5 = ((unsigned __int64)(v6 + v5) >> 1) | 1;
      else
        v6 = v7 - 2;
    }
    while ( v5 < v6 );
    v4 = 8 * v5 - 23;
    *a1 = v4;
  }
  return (**(__int64 (***)(void))((char *)v3 + v4 + 15))();
}
// 40BA60: variable 'v1' is possibly undefined
// 40BA75: variable 'v2' is possibly undefined

//----- (000000000040BAC0) ----------------------------------------------------
__int64 __fastcall caml_apply6(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 (**v6)(void); // rax
  __int64 (**v7)(void); // rax
  __int64 (**v8)(void); // rax
  __int64 (**v9)(void); // rax
  __int64 (**v10)(void); // rbx

  if ( *(_QWORD *)(a5 + 8) == 13LL )
    return (*(__int64 (**)(void))(a5 + 16))();
  v6 = (__int64 (**)(void))(*(__int64 (**)(void))a5)();
  v7 = (__int64 (**)(void))(*v6)();
  v8 = (__int64 (**)(void))(*v7)();
  v9 = (__int64 (**)(void))(*v8)();
  v10 = (__int64 (**)(void))(*v9)();
  return (*v10)();
}

//----- (000000000040BB40) ----------------------------------------------------
__int64 __fastcall caml_apply4(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (**v4)(void); // rax
  __int64 (**v5)(void); // rax
  __int64 (**v6)(void); // rbx

  if ( *(_QWORD *)(a3 + 8) == 9LL )
    return (*(__int64 (**)(void))(a3 + 16))();
  v4 = (__int64 (**)(void))(*(__int64 (**)(void))a3)();
  v5 = (__int64 (**)(void))(*v4)();
  v6 = (__int64 (**)(void))(*v5)();
  return (*v6)();
}

//----- (000000000040BBA0) ----------------------------------------------------
__int64 __fastcall caml_apply3(__int64 a1, __int64 a2)
{
  __int64 (**v3)(void); // rax
  __int64 (**v4)(void); // rbx

  if ( *(_QWORD *)(a2 + 8) == 7LL )
    return (*(__int64 (**)(void))(a2 + 16))();
  v3 = (__int64 (**)(void))(*(__int64 (**)(void))a2)();
  v4 = (__int64 (**)(void))(*v3)();
  return (*v4)();
}

//----- (000000000040BBF0) ----------------------------------------------------
__int64 __fastcall caml_apply2(__int64 a1)
{
  __int64 (**v2)(void); // rbx

  if ( *(_QWORD *)(a1 + 8) == 5LL )
    return (*(__int64 (**)(void))(a1 + 16))();
  v2 = (__int64 (**)(void))(*(__int64 (**)(void))a1)();
  return (*v2)();
}

//----- (000000000040BC30) ----------------------------------------------------
__int64 camlStd_exit__code_begin()
{
  (**(void (***)(void))camlPervasives[82])();
  return 1LL;
}
// 64CDA0: using guessed type _QWORD camlPervasives[84];

//----- (000000000040BC60) ----------------------------------------------------
__int64 __fastcall camlSource__code_begin()
{
  __int64 result; // rax
  __int64 v1; // rbx

  *(_QWORD *)(result + 4LL * *(_QWORD *)(v1 + 16) - 4) = 4LL - *(_QWORD *)(result + 4LL * *(_QWORD *)(v1 + 16) - 4);
  return result;
}
// 40BC68: variable 'result' is possibly undefined
// 40BC64: variable 'v1' is possibly undefined
// 40BC60: using guessed type __int64 __fastcall camlSource__code_begin();

//----- (000000000040BC80) ----------------------------------------------------
unsigned __int64 *__fastcall camlSource__fun_161(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 *result; // rax

  result = camlCamlinternalOO__create_object_opt_326();
  *(unsigned __int64 *)((char *)result + 4 * *(_QWORD *)(a2 + 24) - 4) = a1;
  return result;
}
// 40BC80: could not find valid save-restore pair for rbx

//----- (000000000040BCB0) ----------------------------------------------------
__int64 __fastcall camlSource__method_activate_143()
{
  __int64 result; // rax
  _QWORD *v1; // rbx

  *(_QWORD *)(result + 4LL * v1[4] - 4) += 2LL;
  if ( *(_QWORD *)(result + 4LL * v1[4] - 4) >= *(_QWORD *)(result + 4LL * v1[3] - 4) )
  {
    *(_QWORD *)(result + 4LL * v1[2] - 4) = 4LL - *(_QWORD *)(result + 4LL * v1[2] - 4);
    *(_QWORD *)(result + 4LL * v1[4] - 4) = 1LL;
  }
  return result;
}
// 40BCB4: variable 'result' is possibly undefined
// 40BCB0: variable 'v1' is possibly undefined
// 40BCB0: using guessed type __int64 __fastcall camlSource__method_activate_143();

//----- (000000000040BD00) ----------------------------------------------------
__int64 __fastcall camlSource__fun_173(__int64 a1, unsigned __int64 a2, _QWORD *a3)
{
  unsigned __int64 *object_opt_326; // [rsp+10h] [rbp-18h]

  object_opt_326 = camlCamlinternalOO__create_object_opt_326();
  caml_apply2(a3[6]);
  *(unsigned __int64 *)((char *)object_opt_326 + 4 * a3[3] - 4) = a2;
  *(unsigned __int64 *)((char *)object_opt_326 + 4 * a3[4] - 4) = 1LL;
  return camlCamlinternalOO__run_initializers_opt_338(a3[5]);
}
// 40BD00: could not find valid save-restore pair for rbx

//----- (000000000040BD80) ----------------------------------------------------
_QWORD *__fastcall camlSource__toggle_init_127()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  _QWORD *v2; // r15
  __int64 *v3; // rax
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rdx
  __int64 v8; // rsi
  __int64 v9; // rdi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  _QWORD *result; // rax
  __int64 i; // [rsp+0h] [rbp-18h]
  __int64 v16; // [rsp+8h] [rbp-10h]

  v16 = v0;
  v3 = (__int64 *)camlCamlinternalOO__new_methods_variables_266(*(_QWORD *)(v1 + 16));
  v7 = *v3;
  v8 = v3[1];
  v9 = v3[2];
  for ( i = v9; ; caml_call_gc(v9, v8, v7, v4, v5, v6, i) )
  {
    v2 -= 10;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
  }
  *v2 = 3319LL;
  v2[1] = camlSource__code_begin;
  v2[2] = 3LL;
  v2[3] = v9;
  v2[4] = 5120LL;
  v2[5] = v7;
  v2[6] = 3LL;
  v2[7] = v9;
  v2[8] = v8;
  v2[9] = v2 + 1;
  camlCamlinternalOO__set_methods_609(v9, v8, v7, v4, v5, v6);
  while ( 1 )
  {
    v2 -= 6;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
    caml_call_gc(v9, v8, v10, v11, v12, v13, i);
  }
  result = v2 + 1;
  *v2 = 5367LL;
  v2[1] = caml_curry3;
  v2[2] = 7LL;
  v2[3] = camlSource__fun_161;
  v2[4] = i;
  v2[5] = v16;
  return result;
}
// 40BD84: variable 'v0' is possibly undefined
// 40BD89: variable 'v1' is possibly undefined
// 40BDA8: variable 'v2' is possibly undefined
// 40BDEA: variable 'v7' is possibly undefined
// 40BE06: variable 'v4' is possibly undefined
// 40BE06: variable 'v5' is possibly undefined
// 40BE06: variable 'v6' is possibly undefined
// 40BE48: variable 'i' is possibly undefined
// 40BE5A: variable 'v10' is possibly undefined
// 40BE5A: variable 'v11' is possibly undefined
// 40BE5A: variable 'v12' is possibly undefined
// 40BE5A: variable 'v13' is possibly undefined
// 40BC60: using guessed type __int64 __fastcall camlSource__code_begin();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040BE70) ----------------------------------------------------
_QWORD *__fastcall camlSource__nth_toggle_init_149(double a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  _QWORD *v3; // r15
  __int64 v4; // rax
  unsigned __int64 v5; // rsi
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 (__fastcall **v8)(); // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 (__fastcall *v13)(); // rbx
  __int64 v14; // rdi
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  _QWORD *result; // rax
  __int64 (__fastcall *v20)(); // [rsp+0h] [rbp-28h]
  __int64 v21; // [rsp+10h] [rbp-18h]
  __int64 v22; // [rsp+18h] [rbp-10h]
  __int64 v23; // [rsp+20h] [rbp-8h]

  v23 = v1;
  v4 = camlCamlinternalOO__new_methods_variables_266((__int64)camlSource__6);
  v21 = *(_QWORD *)(v4 + 8);
  v22 = *(_QWORD *)(v4 + 16);
  v5 = *(_QWORD *)(v2 + 24);
  v8 = camlCamlinternalOO__inherits_294(1LL, v5, camlSource, 3LL, v6, v7, a1);
  v20 = *v8;
  v13 = v8[1];
  while ( 1 )
  {
    v3 -= 6;
    if ( (unsigned __int64)v3 >= caml_young_limit )
      break;
    caml_call_gc(1LL, v5, v9, v10, v11, v12, (char)v20);
  }
  v14 = (__int64)(v3 + 1);
  *v3 = 5367LL;
  v3[1] = camlSource__method_activate_143;
  v3[2] = 3LL;
  v3[3] = v13;
  v3[4] = v21;
  v3[5] = v22;
  camlCamlinternalOO__set_method_213((unsigned __int64)(v3 + 1), v5, v9, v10, v11, v12);
  while ( 1 )
  {
    v3 -= 8;
    if ( (unsigned __int64)v3 >= caml_young_limit )
      break;
    caml_call_gc(v14, v5, v15, v16, v17, v18, (char)v20);
  }
  result = v3 + 1;
  *v3 = 7415LL;
  v3[1] = caml_curry4;
  v3[2] = 9LL;
  v3[3] = camlSource__fun_173;
  v3[4] = v21;
  v3[5] = v22;
  v3[6] = v23;
  v3[7] = v20;
  return result;
}
// 40BE70: could not find valid save-restore pair for rbx
// 40BE74: variable 'v1' is possibly undefined
// 40BEBF: variable 'v2' is possibly undefined
// 40BED3: variable 'v6' is possibly undefined
// 40BED3: variable 'v7' is possibly undefined
// 40BEE3: variable 'v3' is possibly undefined
// 40BF35: variable 'v9' is possibly undefined
// 40BF35: variable 'v10' is possibly undefined
// 40BF35: variable 'v11' is possibly undefined
// 40BF35: variable 'v12' is possibly undefined
// 40BF92: variable 'v20' is possibly undefined
// 40BF9B: variable 'v15' is possibly undefined
// 40BF9B: variable 'v16' is possibly undefined
// 40BF9B: variable 'v17' is possibly undefined
// 40BF9B: variable 'v18' is possibly undefined
// 40BCB0: using guessed type __int64 __fastcall camlSource__method_activate_143();
// 648890: using guessed type char *camlSource__6[2];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040BFB0) ----------------------------------------------------
__int64 __fastcall camlSource__entry(double a1)
{
  _QWORD *v1; // r15
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rax
  void (*v20)(void); // rdi
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // rbx
  __int64 v26; // rbx
  __int64 v27; // rsi
  __int64 v28; // rdi
  __int64 v29; // rdx
  __int64 v30; // rcx
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 v33; // rbx
  __int64 v34; // rbx
  __int64 v36; // [rsp+0h] [rbp-18h]
  __int64 v37; // [rsp+0h] [rbp-18h]
  void (**v38)(void); // [rsp+0h] [rbp-18h]
  __int64 v39; // [rsp+0h] [rbp-18h]
  __int64 v40; // [rsp+0h] [rbp-18h]
  __int64 v41; // [rsp+8h] [rbp-10h]
  __int64 v42; // [rsp+8h] [rbp-10h]
  __int64 *v43; // [rsp+8h] [rbp-10h]
  __int64 v44; // [rsp+8h] [rbp-10h]
  __int64 v45; // [rsp+10h] [rbp-8h]

  caml_c_call(9LL, 1uLL);
  *((_QWORD *)&camlSource + 4) = v2;
  caml_alloc3(9LL, 1LL, v3, v4, v5, v6, (char)&camlSource__3);
  *v1 = 3319LL;
  v1[1] = camlSource__toggle_init_127;
  v1[2] = 3LL;
  v1[3] = v36;
  camlSource = camlCamlinternalOO__make_class_304(9LL, 1LL, v7, v8, v9, v10, a1);
  caml_allocN(9LL, 1LL, v11, v12, v13, v14, v36);
  *v1 = 4343LL;
  v1[1] = camlSource__nth_toggle_init_149;
  v1[2] = 3LL;
  v1[3] = v37;
  v1[4] = camlSource__4;
  *((_QWORD *)&camlSource + 1) = camlCamlinternalOO__make_class_304(9LL, 1LL, v15, v16, v17, v18, a1);
  if ( ((*(_QWORD *)(camlSys[0] - 8) >> 9) | 1LL) <= 3 )
    v19 = 3LL;
  else
    caml_c_call(*(_QWORD *)(camlSys[0] + 8), 1uLL);
  *((_QWORD *)&camlSource + 2) = v19;
  v20 = (void (*)(void))*camlSource;
  *((_QWORD *)&camlSource + 3) = caml_apply2(*camlSource);
  v41 = 3LL;
  do
  {
    v38 = (void (**)(void))camlPrintf__printf_425((__int64)v20, 1LL, v21, v22, v23, v24);
    caml_send0((__int64 *)(*((_QWORD *)&camlSource + 4) + 16LL));
    caml_send0((__int64 *)(*((_QWORD *)&camlSource + 4) + 24LL));
    v20 = *v38;
    (*v38)();
    v25 = v41;
    v41 += 2LL;
  }
  while ( v25 != 11 );
  if ( *((__int64 *)&camlSource + 2) >= 3 )
  {
    v42 = *((_QWORD *)&camlSource + 2);
    v39 = 3LL;
    do
    {
      caml_apply2(*camlSource);
      v26 = v39;
      v39 += 2LL;
    }
    while ( v26 != v42 );
  }
  camlPervasives__print_newline_300();
  v27 = **((_QWORD **)&camlSource + 1);
  v28 = 7LL;
  v45 = 3LL;
  caml_apply3(7LL, v27);
  do
  {
    v43 = (__int64 *)camlPrintf__printf_425(v28, v27, v29, v30, v31, v32);
    caml_send0(*((__int64 **)&camlSource + 4));
    caml_send0((__int64 *)(*((_QWORD *)&camlSource + 4) + 8LL));
    v28 = *v43;
    ((void (*)(void))*v43)();
    v33 = v45;
    v45 += 2LL;
  }
  while ( v33 != 17 );
  if ( *((__int64 *)&camlSource + 2) >= 3 )
  {
    v44 = *((_QWORD *)&camlSource + 2);
    v40 = 3LL;
    do
    {
      caml_apply3(7LL, **((_QWORD **)&camlSource + 1));
      v34 = v40;
      v40 += 2LL;
    }
    while ( v34 != v44 );
  }
  return 1LL;
}
// 40BFEC: variable 'v2' is possibly undefined
// 40BFF3: variable 'v3' is possibly undefined
// 40BFF3: variable 'v4' is possibly undefined
// 40BFF3: variable 'v5' is possibly undefined
// 40BFF3: variable 'v6' is possibly undefined
// 40BFFC: variable 'v1' is possibly undefined
// 40C01A: variable 'v36' is possibly undefined
// 40C023: variable 'v7' is possibly undefined
// 40C023: variable 'v8' is possibly undefined
// 40C023: variable 'v9' is possibly undefined
// 40C023: variable 'v10' is possibly undefined
// 40C03C: variable 'v11' is possibly undefined
// 40C03C: variable 'v12' is possibly undefined
// 40C03C: variable 'v13' is possibly undefined
// 40C03C: variable 'v14' is possibly undefined
// 40C063: variable 'v37' is possibly undefined
// 40C070: variable 'v15' is possibly undefined
// 40C070: variable 'v16' is possibly undefined
// 40C070: variable 'v17' is possibly undefined
// 40C070: variable 'v18' is possibly undefined
// 40C0C6: variable 'v19' is possibly undefined
// 40C10E: variable 'v21' is possibly undefined
// 40C10E: variable 'v22' is possibly undefined
// 40C10E: variable 'v23' is possibly undefined
// 40C10E: variable 'v24' is possibly undefined
// 40C222: variable 'v29' is possibly undefined
// 40C222: variable 'v30' is possibly undefined
// 40C222: variable 'v31' is possibly undefined
// 40C222: variable 'v32' is possibly undefined
// 648848: using guessed type char *camlSource__3;
// 648868: using guessed type char *camlSource__4[2];
// 6515D0: using guessed type __int64 camlSys[33];

//----- (000000000040C2F0) ----------------------------------------------------
_QWORD *__fastcall camlSource__code_end(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 9;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 2049LL;
  v8[1] = i;
  v8[2] = *(_QWORD *)(a1 + 40);
  result = v8 + 4;
  v8[3] = 5120LL;
  v8[4] = 3LL;
  v8[5] = *(_QWORD *)(a1 + 32);
  v8[6] = **(_QWORD **)(a1 + 24);
  v8[7] = v8 + 1;
  v8[8] = v7;
  return result;
}
// 40C2F4: variable 'v6' is possibly undefined
// 40C2F7: variable 'v8' is possibly undefined
// 40C348: variable 'v7' is possibly undefined
// 40C351: variable 'a3' is possibly undefined
// 40C351: variable 'a4' is possibly undefined
// 40C351: variable 'a5' is possibly undefined
// 40C351: variable 'a6' is possibly undefined
// 40C351: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040C360) ----------------------------------------------------
__int64 __fastcall camlUnix__fun_1847(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 **v7; // rbx
  _QWORD *v8; // r15
  _QWORD *v9; // rdi
  __int64 v11; // rax
  __int64 i; // rdi
  char v13; // [rsp+0h] [rbp-8h]

  v9 = (_QWORD *)v6;
  if ( (v6 & 1) != 0 )
  {
    if ( v6 >> 1 >= 2 )
    {
      *v7[4] = 3LL;
      return 1LL;
    }
    return 1LL;
  }
  v11 = *(unsigned __int8 *)(v6 - 8);
  if ( !*((_BYTE *)v9 - 8) )
    return 1LL;
  if ( v11 > 1 )
  {
    *v7[3] = *v9;
    return 1LL;
  }
  else
  {
    for ( i = *v9; ; caml_call_gc(i, a2, a3, a4, a5, a6, v13) )
    {
      v8 -= 2;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
    }
    *v8 = 1024LL;
    v8[1] = i;
    caml_modify(v7[2], (unsigned __int64)(v8 + 1));
    return 1LL;
  }
}
// 40C364: variable 'v6' is possibly undefined
// 40C376: variable 'v7' is possibly undefined
// 40C3A0: variable 'v8' is possibly undefined
// 40C3F8: variable 'a3' is possibly undefined
// 40C3F8: variable 'a4' is possibly undefined
// 40C3F8: variable 'a5' is possibly undefined
// 40C3F8: variable 'a6' is possibly undefined
// 40C3F8: variable 'v13' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040C400) ----------------------------------------------------
__int64 __fastcall camlUnix__get_port_765(__int64 a1)
{
  __int64 v1; // rax
  _QWORD *v2; // r15
  __int64 v3; // r12
  _QWORD *v4; // rdi
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 result; // rax
  char v10; // [rsp+0h] [rbp-18h]

  v3 = v1;
  v4 = *(_QWORD **)(a1 + 24);
  if ( caml_string_equal(v4, camlUnix__213) == 1 )
  {
    if ( (char **)*sub_40C534((__int64)v4, (unsigned __int64)camlUnix__213) == &caml_exn_Failure )
    {
      if ( (char **)*sub_40C4B8() == &caml_exn_Not_found )
      {
        return 1LL;
      }
      else
      {
        caml_raise_exn();
        return (__int64)sub_40C4B8();
      }
    }
    else
    {
      caml_raise_exn();
      return (__int64)sub_40C534((__int64)&caml_exn_Failure, (unsigned __int64)camlUnix__213);
    }
  }
  else
  {
    while ( 1 )
    {
      v2 -= 6;
      if ( (unsigned __int64)v2 >= caml_young_limit )
        break;
      caml_call_gc((__int64)v4, (__int64)camlUnix__213, v5, v6, v7, v8, v10);
    }
    *v2 = 2048LL;
    v2[1] = v3;
    v2[2] = 1LL;
    result = (__int64)(v2 + 4);
    v2[3] = 2048LL;
    v2[4] = v2 + 1;
    v2[5] = 1LL;
  }
  return result;
}
// 40C404: variable 'v1' is possibly undefined
// 40C420: variable 'v2' is possibly undefined
// 40C5A7: variable 'v5' is possibly undefined
// 40C5A7: variable 'v6' is possibly undefined
// 40C5A7: variable 'v7' is possibly undefined
// 40C5A7: variable 'v8' is possibly undefined
// 40C5A7: variable 'v10' is possibly undefined
// 647A80: using guessed type char *caml_exn_Failure;
// 647B68: using guessed type char *caml_exn_Not_found;
// 64A5E0: using guessed type _QWORD camlUnix__213[127];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040C4B8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_QWORD *__fastcall sub_40C4B8()
{
  _QWORD *v0; // r15
  __int64 v1; // rdx
  __int64 v2; // rcx
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // rax
  __int64 i; // rdi
  _QWORD *result; // rax
  char v8; // [rsp-20h] [rbp-28h]
  __int64 v9; // [rsp-10h] [rbp-18h]
  unsigned __int64 v10; // [rsp-8h] [rbp-10h]
  __int64 v11; // [rsp+0h] [rbp-8h]

  caml_c_call(*(_QWORD *)(v9 + 24), v10);
  for ( i = *(_QWORD *)(v5 + 16); ; caml_call_gc(i, v10, v1, v2, v3, v4, v8) )
  {
    v0 -= 6;
    if ( (unsigned __int64)v0 >= caml_young_limit )
      break;
  }
  *v0 = 2048LL;
  v0[1] = v11;
  v0[2] = i;
  result = v0 + 4;
  v0[3] = 2048LL;
  v0[4] = v0 + 1;
  v0[5] = 1LL;
  return result;
}
// 40C52B: positive sp value 20 has been found
// 40C4C2: variable 'v9' is possibly undefined
// 40C4D2: variable 'v10' is possibly undefined
// 40C4D7: variable 'v5' is possibly undefined
// 40C4DE: variable 'v0' is possibly undefined
// 40C503: variable 'v11' is possibly undefined
// 40C59D: variable 'v1' is possibly undefined
// 40C59D: variable 'v2' is possibly undefined
// 40C59D: variable 'v3' is possibly undefined
// 40C59D: variable 'v4' is possibly undefined
// 40C59D: variable 'v8' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040C534) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_QWORD *__fastcall sub_40C534(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rbp
  _QWORD *v3; // r15
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rax
  __int64 i; // rdi
  _QWORD *result; // rax
  char v11; // [rsp-20h] [rbp-28h]
  __int64 v12; // [rsp+0h] [rbp-8h]

  caml_c_call(*(_QWORD *)(v2 + 24), a2);
  for ( i = v8; ; caml_call_gc(i, a2, v4, v5, v6, v7, v11) )
  {
    v3 -= 6;
    if ( (unsigned __int64)v3 >= caml_young_limit )
      break;
  }
  *v3 = 2048LL;
  v3[1] = v12;
  v3[2] = i;
  result = v3 + 4;
  v3[3] = 2048LL;
  v3[4] = v3 + 1;
  v3[5] = 1LL;
  return result;
}
// 40C595: positive sp value 20 has been found
// 40C539: variable 'v2' is possibly undefined
// 40C549: variable 'v8' is possibly undefined
// 40C54C: variable 'v3' is possibly undefined
// 40C56D: variable 'v12' is possibly undefined
// 40C596: variable 'v4' is possibly undefined
// 40C596: variable 'v5' is possibly undefined
// 40C596: variable 'v6' is possibly undefined
// 40C596: variable 'v7' is possibly undefined
// 40C596: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040C5C0) ----------------------------------------------------
_QWORD *__fastcall camlUnix__fun_1852(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v11) )
  {
    v8 -= 3;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 2048LL;
  v8[1] = i;
  v8[2] = **(_QWORD **)(v7 + 16);
  return result;
}
// 40C5C4: variable 'v6' is possibly undefined
// 40C5C7: variable 'v8' is possibly undefined
// 40C5E6: variable 'v7' is possibly undefined
// 40C5F6: variable 'a3' is possibly undefined
// 40C5F6: variable 'a4' is possibly undefined
// 40C5F6: variable 'a5' is possibly undefined
// 40C5F6: variable 'a6' is possibly undefined
// 40C5F6: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040C600) ----------------------------------------------------
__int64 __fastcall camlUnix__fun_1855(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 7;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 6391LL;
  v8[1] = caml_tuplify2;
  v8[2] = -3LL;
  v8[3] = camlSource__code_end;
  v8[4] = *(_QWORD *)(a1 + 24);
  v8[5] = i;
  v8[6] = v7;
  return camlList__map_90();
}
// 40C604: variable 'v6' is possibly undefined
// 40C607: variable 'v8' is possibly undefined
// 40C648: variable 'i' is possibly undefined
// 40C64C: variable 'v7' is possibly undefined
// 40C65D: variable 'a4' is possibly undefined
// 40C65D: variable 'a5' is possibly undefined
// 40C65D: variable 'a6' is possibly undefined
// 40C65D: variable 'v11' is possibly undefined
// 40BA30: using guessed type __int64 __fastcall caml_tuplify2();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040C670) ----------------------------------------------------
void __fastcall camlUnix__fun_1876(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C67E: variable 'v2' is possibly undefined

//----- (000000000040C690) ----------------------------------------------------
void __fastcall camlUnix__fun_1882(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C69E: variable 'v2' is possibly undefined

//----- (000000000040C6B0) ----------------------------------------------------
void __fastcall camlUnix__fun_1585(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C6BE: variable 'v2' is possibly undefined

//----- (000000000040C6D0) ----------------------------------------------------
void __fastcall camlUnix__fun_1587()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C6E1: variable 'v0' is possibly undefined
// 40C6E1: variable 'v1' is possibly undefined

//----- (000000000040C6F0) ----------------------------------------------------
void __fastcall camlUnix__fun_1589()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C701: variable 'v0' is possibly undefined
// 40C701: variable 'v1' is possibly undefined

//----- (000000000040C710) ----------------------------------------------------
void __fastcall camlUnix__fun_1591(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C71E: variable 'v2' is possibly undefined

//----- (000000000040C730) ----------------------------------------------------
void __fastcall camlUnix__fun_1593()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C741: variable 'v0' is possibly undefined
// 40C741: variable 'v1' is possibly undefined

//----- (000000000040C750) ----------------------------------------------------
void __fastcall camlUnix__fun_1595()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C764: variable 'v0' is possibly undefined
// 40C764: variable 'v1' is possibly undefined

//----- (000000000040C770) ----------------------------------------------------
void __fastcall camlUnix__fun_1597(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C77E: variable 'v2' is possibly undefined

//----- (000000000040C790) ----------------------------------------------------
void __fastcall camlUnix__fun_1599()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C7A1: variable 'v0' is possibly undefined
// 40C7A1: variable 'v1' is possibly undefined

//----- (000000000040C7B0) ----------------------------------------------------
void __fastcall camlUnix__fun_1601()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C7C1: variable 'v0' is possibly undefined
// 40C7C1: variable 'v1' is possibly undefined

//----- (000000000040C7D0) ----------------------------------------------------
void __fastcall camlUnix__fun_1603(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C7DE: variable 'v2' is possibly undefined

//----- (000000000040C7F0) ----------------------------------------------------
void __fastcall camlUnix__fun_1605(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C7FE: variable 'v2' is possibly undefined

//----- (000000000040C810) ----------------------------------------------------
void __fastcall camlUnix__fun_1607(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C81E: variable 'v2' is possibly undefined

//----- (000000000040C830) ----------------------------------------------------
void __fastcall camlUnix__fun_1609(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C83E: variable 'v2' is possibly undefined

//----- (000000000040C850) ----------------------------------------------------
void __fastcall camlUnix__fun_1611(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C85E: variable 'v2' is possibly undefined

//----- (000000000040C870) ----------------------------------------------------
void __fastcall camlUnix__fun_1613(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C87E: variable 'v2' is possibly undefined

//----- (000000000040C890) ----------------------------------------------------
void __fastcall camlUnix__fun_1615(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C89E: variable 'v2' is possibly undefined

//----- (000000000040C8B0) ----------------------------------------------------
void __fastcall camlUnix__fun_1617()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C8C1: variable 'v0' is possibly undefined
// 40C8C1: variable 'v1' is possibly undefined

//----- (000000000040C8D0) ----------------------------------------------------
void __fastcall camlUnix__fun_1619()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C8E1: variable 'v0' is possibly undefined
// 40C8E1: variable 'v1' is possibly undefined

//----- (000000000040C8F0) ----------------------------------------------------
void __fastcall camlUnix__fun_1621()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C901: variable 'v0' is possibly undefined
// 40C901: variable 'v1' is possibly undefined

//----- (000000000040C910) ----------------------------------------------------
void __fastcall camlUnix__fun_1623()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C921: variable 'v0' is possibly undefined
// 40C921: variable 'v1' is possibly undefined

//----- (000000000040C930) ----------------------------------------------------
void __fastcall camlUnix__fun_1625(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C93E: variable 'v2' is possibly undefined

//----- (000000000040C950) ----------------------------------------------------
void __fastcall camlUnix__fun_1627()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C964: variable 'v0' is possibly undefined
// 40C964: variable 'v1' is possibly undefined

//----- (000000000040C970) ----------------------------------------------------
void __fastcall camlUnix__fun_1629()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40C984: variable 'v0' is possibly undefined
// 40C984: variable 'v1' is possibly undefined

//----- (000000000040C990) ----------------------------------------------------
void __fastcall camlUnix__fun_1631(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C99E: variable 'v2' is possibly undefined

//----- (000000000040C9B0) ----------------------------------------------------
void __fastcall camlUnix__fun_1633(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C9BE: variable 'v2' is possibly undefined

//----- (000000000040C9D0) ----------------------------------------------------
void __fastcall camlUnix__fun_1635(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C9DE: variable 'v2' is possibly undefined

//----- (000000000040C9F0) ----------------------------------------------------
void __fastcall camlUnix__fun_1637(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40C9FE: variable 'v2' is possibly undefined

//----- (000000000040CA10) ----------------------------------------------------
void __fastcall camlUnix__fun_1639(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CA1E: variable 'v2' is possibly undefined

//----- (000000000040CA30) ----------------------------------------------------
void __fastcall camlUnix__fun_1641(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CA3E: variable 'v2' is possibly undefined

//----- (000000000040CA50) ----------------------------------------------------
void __fastcall camlUnix__fun_1643(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CA5E: variable 'v2' is possibly undefined

//----- (000000000040CA70) ----------------------------------------------------
void __fastcall camlUnix__fun_1645(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CA7E: variable 'v2' is possibly undefined

//----- (000000000040CA90) ----------------------------------------------------
void __fastcall camlUnix__fun_1647(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CA9E: variable 'v2' is possibly undefined

//----- (000000000040CAB0) ----------------------------------------------------
void __fastcall camlUnix__fun_1649(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CABE: variable 'v2' is possibly undefined

//----- (000000000040CAD0) ----------------------------------------------------
void __fastcall camlUnix__fun_1651(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CADE: variable 'v2' is possibly undefined

//----- (000000000040CAF0) ----------------------------------------------------
void __fastcall camlUnix__fun_1653(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CAFE: variable 'v2' is possibly undefined

//----- (000000000040CB10) ----------------------------------------------------
void __fastcall camlUnix__fun_1655(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CB1E: variable 'v2' is possibly undefined

//----- (000000000040CB30) ----------------------------------------------------
void __fastcall camlUnix__fun_1657(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CB3E: variable 'v2' is possibly undefined

//----- (000000000040CB50) ----------------------------------------------------
void __fastcall camlUnix__fun_1659()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40CB61: variable 'v0' is possibly undefined
// 40CB61: variable 'v1' is possibly undefined

//----- (000000000040CB70) ----------------------------------------------------
void __fastcall camlUnix__fun_1661(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CB7E: variable 'v2' is possibly undefined

//----- (000000000040CB90) ----------------------------------------------------
void __fastcall camlUnix__fun_1663()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40CBA4: variable 'v0' is possibly undefined
// 40CBA4: variable 'v1' is possibly undefined

//----- (000000000040CBB0) ----------------------------------------------------
void __fastcall camlUnix__fun_1665(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CBBE: variable 'v2' is possibly undefined

//----- (000000000040CBD0) ----------------------------------------------------
void __fastcall camlUnix__fun_1667(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CBDE: variable 'v2' is possibly undefined

//----- (000000000040CBF0) ----------------------------------------------------
void __fastcall camlUnix__fun_1669(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CBFE: variable 'v2' is possibly undefined

//----- (000000000040CC10) ----------------------------------------------------
void __fastcall camlUnix__fun_1671(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CC1E: variable 'v2' is possibly undefined

//----- (000000000040CC30) ----------------------------------------------------
void __fastcall camlUnix__fun_1673(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CC3E: variable 'v2' is possibly undefined

//----- (000000000040CC50) ----------------------------------------------------
void __fastcall camlUnix__fun_1675(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CC5E: variable 'v2' is possibly undefined

//----- (000000000040CC70) ----------------------------------------------------
void __fastcall camlUnix__fun_1677(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CC7E: variable 'v2' is possibly undefined

//----- (000000000040CC90) ----------------------------------------------------
void __fastcall camlUnix__fun_1679(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CC9E: variable 'v2' is possibly undefined

//----- (000000000040CCB0) ----------------------------------------------------
void __fastcall camlUnix__fun_1681(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CCBE: variable 'v2' is possibly undefined

//----- (000000000040CCD0) ----------------------------------------------------
void __fastcall camlUnix__fun_1683(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CCDE: variable 'v2' is possibly undefined

//----- (000000000040CCF0) ----------------------------------------------------
void __fastcall camlUnix__fun_1685()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40CD01: variable 'v0' is possibly undefined
// 40CD01: variable 'v1' is possibly undefined

//----- (000000000040CD10) ----------------------------------------------------
void __fastcall camlUnix__fun_1687()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40CD21: variable 'v0' is possibly undefined
// 40CD21: variable 'v1' is possibly undefined

//----- (000000000040CD30) ----------------------------------------------------
void __fastcall camlUnix__fun_1689()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40CD44: variable 'v0' is possibly undefined
// 40CD44: variable 'v1' is possibly undefined

//----- (000000000040CD50) ----------------------------------------------------
void __fastcall camlUnix__fun_1691()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40CD67: variable 'v0' is possibly undefined
// 40CD67: variable 'v1' is possibly undefined

//----- (000000000040CD80) ----------------------------------------------------
void __fastcall camlUnix__fun_1693(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CD8E: variable 'v2' is possibly undefined

//----- (000000000040CDA0) ----------------------------------------------------
void __fastcall camlUnix__fun_1695()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40CDB1: variable 'v0' is possibly undefined
// 40CDB1: variable 'v1' is possibly undefined

//----- (000000000040CDC0) ----------------------------------------------------
void __fastcall camlUnix__fun_1697()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40CDD1: variable 'v0' is possibly undefined
// 40CDD1: variable 'v1' is possibly undefined

//----- (000000000040CDE0) ----------------------------------------------------
void __fastcall camlUnix__fun_1699(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CDEE: variable 'v2' is possibly undefined

//----- (000000000040CE00) ----------------------------------------------------
void __fastcall camlUnix__fun_1701(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CE0E: variable 'v2' is possibly undefined

//----- (000000000040CE20) ----------------------------------------------------
void __fastcall camlUnix__fun_1703(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CE2E: variable 'v2' is possibly undefined

//----- (000000000040CE40) ----------------------------------------------------
void __fastcall camlUnix__fun_1705(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CE4E: variable 'v2' is possibly undefined

//----- (000000000040CE60) ----------------------------------------------------
void __fastcall camlUnix__fun_1707(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CE6E: variable 'v2' is possibly undefined

//----- (000000000040CE80) ----------------------------------------------------
void __fastcall camlUnix__fun_1709(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CE8E: variable 'v2' is possibly undefined

//----- (000000000040CEA0) ----------------------------------------------------
void __fastcall camlUnix__fun_1711(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CEAE: variable 'v2' is possibly undefined

//----- (000000000040CEC0) ----------------------------------------------------
void __fastcall camlUnix__fun_1713(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CECE: variable 'v2' is possibly undefined

//----- (000000000040CEE0) ----------------------------------------------------
void __fastcall camlUnix__fun_1715(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CEEE: variable 'v2' is possibly undefined

//----- (000000000040CF00) ----------------------------------------------------
void __fastcall camlUnix__fun_1717()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40CF11: variable 'v0' is possibly undefined
// 40CF11: variable 'v1' is possibly undefined

//----- (000000000040CF20) ----------------------------------------------------
void __fastcall camlUnix__fun_1719(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CF2E: variable 'v2' is possibly undefined

//----- (000000000040CF40) ----------------------------------------------------
void __fastcall camlUnix__fun_1721(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CF4E: variable 'v2' is possibly undefined

//----- (000000000040CF60) ----------------------------------------------------
void __fastcall camlUnix__fun_1723(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CF6E: variable 'v2' is possibly undefined

//----- (000000000040CF80) ----------------------------------------------------
void __fastcall camlUnix__fun_1725(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CF8E: variable 'v2' is possibly undefined

//----- (000000000040CFA0) ----------------------------------------------------
void __fastcall camlUnix__fun_1727()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40CFB1: variable 'v0' is possibly undefined
// 40CFB1: variable 'v1' is possibly undefined

//----- (000000000040CFC0) ----------------------------------------------------
void __fastcall camlUnix__fun_1729(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40CFCE: variable 'v2' is possibly undefined

//----- (000000000040CFE0) ----------------------------------------------------
void __fastcall camlUnix__fun_1731()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40CFF1: variable 'v0' is possibly undefined
// 40CFF1: variable 'v1' is possibly undefined

//----- (000000000040D000) ----------------------------------------------------
void __fastcall camlUnix__fun_1733(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D00E: variable 'v2' is possibly undefined

//----- (000000000040D020) ----------------------------------------------------
void __fastcall camlUnix__fun_1735()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D034: variable 'v0' is possibly undefined
// 40D034: variable 'v1' is possibly undefined

//----- (000000000040D040) ----------------------------------------------------
void __fastcall camlUnix__fun_1737()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D054: variable 'v0' is possibly undefined
// 40D054: variable 'v1' is possibly undefined

//----- (000000000040D060) ----------------------------------------------------
void __fastcall camlUnix__fun_1739()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D071: variable 'v0' is possibly undefined
// 40D071: variable 'v1' is possibly undefined

//----- (000000000040D080) ----------------------------------------------------
void __fastcall camlUnix__fun_1741()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D091: variable 'v0' is possibly undefined
// 40D091: variable 'v1' is possibly undefined

//----- (000000000040D0A0) ----------------------------------------------------
void __fastcall camlUnix__fun_1743()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D0B1: variable 'v0' is possibly undefined
// 40D0B1: variable 'v1' is possibly undefined

//----- (000000000040D0C0) ----------------------------------------------------
void __fastcall camlUnix__fun_1745()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D0D1: variable 'v0' is possibly undefined
// 40D0D1: variable 'v1' is possibly undefined

//----- (000000000040D0E0) ----------------------------------------------------
void __fastcall camlUnix__fun_1747(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D0EE: variable 'v2' is possibly undefined

//----- (000000000040D100) ----------------------------------------------------
void __fastcall camlUnix__fun_1749(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D10E: variable 'v2' is possibly undefined

//----- (000000000040D120) ----------------------------------------------------
void __fastcall camlUnix__fun_1751(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D12E: variable 'v2' is possibly undefined

//----- (000000000040D140) ----------------------------------------------------
void __fastcall camlUnix__fun_1753(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D14E: variable 'v2' is possibly undefined

//----- (000000000040D160) ----------------------------------------------------
void __fastcall camlUnix__fun_1755(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D16E: variable 'v2' is possibly undefined

//----- (000000000040D180) ----------------------------------------------------
void __fastcall camlUnix__fun_1757()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D191: variable 'v0' is possibly undefined
// 40D191: variable 'v1' is possibly undefined

//----- (000000000040D1A0) ----------------------------------------------------
void __fastcall camlUnix__fun_1759()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D1B1: variable 'v0' is possibly undefined
// 40D1B1: variable 'v1' is possibly undefined

//----- (000000000040D1C0) ----------------------------------------------------
void __fastcall camlUnix__fun_1761()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D1D4: variable 'v0' is possibly undefined
// 40D1D4: variable 'v1' is possibly undefined

//----- (000000000040D1E0) ----------------------------------------------------
void __fastcall camlUnix__fun_1763(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D1EE: variable 'v2' is possibly undefined

//----- (000000000040D200) ----------------------------------------------------
void __fastcall camlUnix__fun_1765(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D20E: variable 'v2' is possibly undefined

//----- (000000000040D220) ----------------------------------------------------
void __fastcall camlUnix__fun_1767(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D22E: variable 'v2' is possibly undefined

//----- (000000000040D240) ----------------------------------------------------
void __fastcall camlUnix__fun_1769(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D24E: variable 'v2' is possibly undefined

//----- (000000000040D260) ----------------------------------------------------
void __fastcall camlUnix__fun_1771(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D26E: variable 'v2' is possibly undefined

//----- (000000000040D280) ----------------------------------------------------
void __fastcall camlUnix__fun_1773()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D294: variable 'v0' is possibly undefined
// 40D294: variable 'v1' is possibly undefined

//----- (000000000040D2A0) ----------------------------------------------------
void __fastcall camlUnix__fun_1775(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D2AE: variable 'v2' is possibly undefined

//----- (000000000040D2C0) ----------------------------------------------------
void __fastcall camlUnix__fun_1777(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D2CE: variable 'v2' is possibly undefined

//----- (000000000040D2E0) ----------------------------------------------------
void __fastcall camlUnix__fun_1779(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D2EE: variable 'v2' is possibly undefined

//----- (000000000040D300) ----------------------------------------------------
void __fastcall camlUnix__fun_1781()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D311: variable 'v0' is possibly undefined
// 40D311: variable 'v1' is possibly undefined

//----- (000000000040D320) ----------------------------------------------------
void __fastcall camlUnix__fun_1783(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D32E: variable 'v2' is possibly undefined

//----- (000000000040D340) ----------------------------------------------------
void __fastcall camlUnix__fun_1785(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D34E: variable 'v2' is possibly undefined

//----- (000000000040D360) ----------------------------------------------------
void __fastcall camlUnix__fun_1787()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D374: variable 'v0' is possibly undefined
// 40D374: variable 'v1' is possibly undefined

//----- (000000000040D380) ----------------------------------------------------
void __fastcall camlUnix__fun_1789()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D391: variable 'v0' is possibly undefined
// 40D391: variable 'v1' is possibly undefined

//----- (000000000040D3A0) ----------------------------------------------------
void __fastcall camlUnix__fun_1791()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D3B4: variable 'v0' is possibly undefined
// 40D3B4: variable 'v1' is possibly undefined

//----- (000000000040D3C0) ----------------------------------------------------
void __fastcall camlUnix__fun_1793()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D3D1: variable 'v0' is possibly undefined
// 40D3D1: variable 'v1' is possibly undefined

//----- (000000000040D3E0) ----------------------------------------------------
void __fastcall camlUnix__fun_1795()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D3F1: variable 'v0' is possibly undefined
// 40D3F1: variable 'v1' is possibly undefined

//----- (000000000040D400) ----------------------------------------------------
void __fastcall camlUnix__fun_1797(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D40E: variable 'v2' is possibly undefined

//----- (000000000040D420) ----------------------------------------------------
void __fastcall camlUnix__fun_1799(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D42E: variable 'v2' is possibly undefined

//----- (000000000040D440) ----------------------------------------------------
void __fastcall camlUnix__fun_1801(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D44E: variable 'v2' is possibly undefined

//----- (000000000040D460) ----------------------------------------------------
void __fastcall camlUnix__handle_unix_error_199(__int64 a1)
{
  __int64 (**v1)(void); // rax
  __int64 (**v2)(void); // rsi
  _QWORD *v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rbx
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // [rsp+8h] [rbp-10h]
  __int64 v11; // [rsp+10h] [rbp-8h]

  v2 = v1;
  v3 = (_QWORD *)sub_40D5E0(a1, v1);
  v4 = camlUnix[0];
  if ( *v3 == camlUnix[0] )
  {
    v11 = v3[3];
    v10 = v3[1];
    if ( *(_QWORD *)(camlSys[0] - 8) >> 9 <= 1uLL )
    {
      caml_ml_array_bound_error(camlUnix[0], (unsigned __int64)v2);
      camlUnix__read_265(v4, (__int64)v2, v6, v7, v8, v9);
    }
    else
    {
      camlPervasives__output_string_215();
      camlPervasives__output_string_215();
      camlPervasives__output_string_215();
      camlPervasives__output_string_215();
      v5 = 8LL * (*(_QWORD *)(v11 - 8) >> 10) - 1;
      if ( 2 * (v5 - *(unsigned __int8 *)(v11 + v5)) + 1 > 1 )
      {
        camlPervasives__output_string_215();
        camlPervasives__output_string_215();
        camlPervasives__output_string_215();
      }
      camlPervasives__output_string_215();
      caml_c_call(v10, (unsigned __int64)v2);
      camlPervasives__prerr_endline_309();
      camlPervasives__exit_350(v10, (unsigned __int64)v2);
    }
  }
  else
  {
    caml_raise_exn();
    sub_40D5E0(v4, v2);
  }
}
// 40D464: variable 'v1' is possibly undefined
// 40D5FE: variable 'v6' is possibly undefined
// 40D5FE: variable 'v7' is possibly undefined
// 40D5FE: variable 'v8' is possibly undefined
// 40D5FE: variable 'v9' is possibly undefined
// 648B48: using guessed type _QWORD camlUnix[168];
// 6515D0: using guessed type __int64 camlSys[33];

//----- (000000000040D5E0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_40D5E0(__int64 a1, __int64 (**a2)(void))
{
  return (*a2)();
}
// 40D5F7: positive sp value 20 has been found

//----- (000000000040D600) ----------------------------------------------------
void __fastcall camlUnix__read_265(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdi

  v8 = a1;
  v9 = a2;
  if ( a1 < 1
    || a2 < 1
    || (v10 = 8LL * (*(_QWORD *)(v7 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v7 + v10),
        a1 = 2 * (v10 - a2) - v9 + 2,
        v8 > a1) )
  {
    camlPervasives__invalid_arg_40(a1, a2, v8, v9, a5, a6);
  }
  caml_c_call(v6, v7);
}
// 40D616: variable 'v7' is possibly undefined
// 40D64A: variable 'v6' is possibly undefined

//----- (000000000040D670) ----------------------------------------------------
void __fastcall camlUnix__write_270(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdi

  v8 = a1;
  v9 = a2;
  if ( a1 < 1
    || a2 < 1
    || (v10 = 8LL * (*(_QWORD *)(v7 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v7 + v10),
        a1 = 2 * (v10 - a2) - v9 + 2,
        v8 > a1) )
  {
    camlPervasives__invalid_arg_40(a1, a2, v8, v9, a5, a6);
  }
  caml_c_call(v6, v7);
}
// 40D686: variable 'v7' is possibly undefined
// 40D6BA: variable 'v6' is possibly undefined

//----- (000000000040D6E0) ----------------------------------------------------
void __fastcall camlUnix__single_write_275(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdi

  v8 = a1;
  v9 = a2;
  if ( a1 < 1
    || a2 < 1
    || (v10 = 8LL * (*(_QWORD *)(v7 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v7 + v10),
        a1 = 2 * (v10 - a2) - v9 + 2,
        v8 > a1) )
  {
    camlPervasives__invalid_arg_40(a1, a2, v8, v9, a5, a6);
  }
  caml_c_call(v6, v7);
}
// 40D6F6: variable 'v7' is possibly undefined
// 40D72A: variable 'v6' is possibly undefined

//----- (000000000040D750) ----------------------------------------------------
void __fastcall camlUnix__fun_1823(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D75E: variable 'v2' is possibly undefined

//----- (000000000040D770) ----------------------------------------------------
void __fastcall camlUnix__fun_1821(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D77E: variable 'v2' is possibly undefined

//----- (000000000040D790) ----------------------------------------------------
void __fastcall camlUnix__fun_1819(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40D79E: variable 'v2' is possibly undefined

//----- (000000000040D7B0) ----------------------------------------------------
void __fastcall camlUnix__fun_1817()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D7C1: variable 'v0' is possibly undefined
// 40D7C1: variable 'v1' is possibly undefined

//----- (000000000040D7D0) ----------------------------------------------------
void __fastcall camlUnix__fun_1815()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D7E1: variable 'v0' is possibly undefined
// 40D7E1: variable 'v1' is possibly undefined

//----- (000000000040D7F0) ----------------------------------------------------
void __fastcall camlUnix__fun_1813()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40D804: variable 'v0' is possibly undefined
// 40D804: variable 'v1' is possibly undefined

//----- (000000000040D810) ----------------------------------------------------
__int64 __fastcall camlUnix__try_set_close_on_exec_394(__int64 a1, unsigned __int64 a2)
{
  if ( *(char ***)sub_40D83C(a1, a2) == &caml_exn_Invalid_argument )
    return 1LL;
  caml_raise_exn();
  return sub_40D83C((__int64)&caml_exn_Invalid_argument, a2);
}
// 647AB0: using guessed type char *caml_exn_Invalid_argument;

//----- (000000000040D83C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_40D83C(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
  return 3LL;
}
// 40D861: positive sp value 10 has been found
// 40D84B: variable 'v2' is possibly undefined

//----- (000000000040D870) ----------------------------------------------------
void camlUnix__pause_436()
{
  __int64 v0; // rax

  caml_c_call(3LL, 1uLL);
  caml_c_call(v0, 1uLL);
}
// 40D898: variable 'v0' is possibly undefined

//----- (000000000040D8B0) ----------------------------------------------------
__int64 __fastcall camlUnix__is_inet6_addr_526()
{
  __int64 v0; // rax
  __int64 v1; // rdi
  __int64 v2; // rax

  v1 = v0;
  v2 = 8LL * (*(_QWORD *)(v0 - 8) >> 10) - 1;
  return 2LL * (2 * (v2 - *(unsigned __int8 *)(v1 + v2)) == 32) + 1;
}
// 40D8B0: variable 'v0' is possibly undefined
// 40D8B0: using guessed type __int64 __fastcall camlUnix__is_inet6_addr_526();

//----- (000000000040D8F0) ----------------------------------------------------
__int64 __fastcall camlUnix__domain_of_sockaddr_555()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx
  __int64 v2; // rax

  if ( !*((_BYTE *)v0 - 8) )
    return 1LL;
  v1 = *v0;
  v2 = 8LL * (*(_QWORD *)(*v0 - 8LL) >> 10) - 1;
  if ( 2 * (v2 - *(unsigned __int8 *)(v1 + v2)) == 32 )
    return 5LL;
  else
    return 3LL;
}
// 40D8F0: variable 'v0' is possibly undefined

//----- (000000000040D940) ----------------------------------------------------
void __fastcall camlUnix__recv_584(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  unsigned __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // rdi

  v5 = a1;
  v6 = a2;
  if ( a1 < 1
    || a2 < 1
    || (v7 = 8LL * (*(_QWORD *)(v4 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v4 + v7),
        a1 = 2 * (v7 - a2) - v6 + 2,
        v5 > a1) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, v5, v6, a3);
  }
  caml_c_call(v3, v4);
}
// 40D959: variable 'v4' is possibly undefined
// 40D996: variable 'v3' is possibly undefined

//----- (000000000040D9B0) ----------------------------------------------------
void __fastcall camlUnix__recvfrom_590(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  unsigned __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // rdi

  v5 = a1;
  v6 = a2;
  if ( a1 < 1
    || a2 < 1
    || (v7 = 8LL * (*(_QWORD *)(v4 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v4 + v7),
        a1 = 2 * (v7 - a2) - v6 + 2,
        v5 > a1) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, v5, v6, a3);
  }
  caml_c_call(v3, v4);
}
// 40D9C9: variable 'v4' is possibly undefined
// 40DA06: variable 'v3' is possibly undefined

//----- (000000000040DA20) ----------------------------------------------------
void __fastcall camlUnix__send_596(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  unsigned __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // rdi

  v5 = a1;
  v6 = a2;
  if ( a1 < 1
    || a2 < 1
    || (v7 = 8LL * (*(_QWORD *)(v4 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v4 + v7),
        a1 = 2 * (v7 - a2) - v6 + 2,
        v5 > a1) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, v5, v6, a3);
  }
  caml_c_call(v3, v4);
}
// 40DA39: variable 'v4' is possibly undefined
// 40DA76: variable 'v3' is possibly undefined

//----- (000000000040DA90) ----------------------------------------------------
void __fastcall camlUnix__sendto_602(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  unsigned __int64 v5; // rbx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rdi

  v6 = a1;
  v7 = a2;
  if ( a1 < 1
    || a2 < 1
    || (v8 = 8LL * (*(_QWORD *)(v5 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v5 + v8),
        a1 = 2 * (v8 - a2) - v7 + 2,
        v6 > a1) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, v6, v7);
  }
  caml_c_call(v4, v5);
}
// 40DAAC: variable 'v5' is possibly undefined
// 40DAEC: variable 'v4' is possibly undefined

//----- (000000000040DB10) ----------------------------------------------------
void __fastcall camlUnix__fun_1835()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40DB27: variable 'v0' is possibly undefined
// 40DB27: variable 'v1' is possibly undefined

//----- (000000000040DB40) ----------------------------------------------------
void __fastcall camlUnix__fun_1833()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40DB54: variable 'v0' is possibly undefined
// 40DB54: variable 'v1' is possibly undefined

//----- (000000000040DB60) ----------------------------------------------------
void __fastcall camlUnix__getsockopt_669()
{
  unsigned __int64 v0; // rax

  caml_c_call(1LL, v0);
}
// 40DB78: variable 'v0' is possibly undefined

//----- (000000000040DB90) ----------------------------------------------------
void __fastcall camlUnix__setsockopt_672()
{
  unsigned __int64 v0; // rax

  caml_c_call(1LL, v0);
}
// 40DBAB: variable 'v0' is possibly undefined

//----- (000000000040DBC0) ----------------------------------------------------
void __fastcall camlUnix__getsockopt_int_676()
{
  unsigned __int64 v0; // rax

  caml_c_call(3LL, v0);
}
// 40DBD8: variable 'v0' is possibly undefined

//----- (000000000040DBF0) ----------------------------------------------------
void __fastcall camlUnix__setsockopt_int_679()
{
  unsigned __int64 v0; // rax

  caml_c_call(3LL, v0);
}
// 40DC0B: variable 'v0' is possibly undefined

//----- (000000000040DC20) ----------------------------------------------------
void __fastcall camlUnix__getsockopt_optint_683()
{
  unsigned __int64 v0; // rax

  caml_c_call(5LL, v0);
}
// 40DC38: variable 'v0' is possibly undefined

//----- (000000000040DC50) ----------------------------------------------------
void __fastcall camlUnix__setsockopt_optint_686()
{
  unsigned __int64 v0; // rax

  caml_c_call(5LL, v0);
}
// 40DC6B: variable 'v0' is possibly undefined

//----- (000000000040DC80) ----------------------------------------------------
void __fastcall camlUnix__getsockopt_float_690()
{
  unsigned __int64 v0; // rax

  caml_c_call(7LL, v0);
}
// 40DC98: variable 'v0' is possibly undefined

//----- (000000000040DCB0) ----------------------------------------------------
void __fastcall camlUnix__setsockopt_float_693()
{
  unsigned __int64 v0; // rax

  caml_c_call(7LL, v0);
}
// 40DCCB: variable 'v0' is possibly undefined

//----- (000000000040DCE0) ----------------------------------------------------
void __fastcall camlUnix__getsockopt_error_697()
{
  unsigned __int64 v0; // rax

  caml_c_call(9LL, v0);
}
// 40DCFC: variable 'v0' is possibly undefined

//----- (000000000040DD10) ----------------------------------------------------
void __fastcall camlUnix__getaddrinfo_emulation_756(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        int a7,
        __int64 a8,
        __int64 a9)
{
  _QWORD *v9; // rax
  _QWORD *v10; // rbx
  _QWORD *v11; // r15
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rdi
  __int64 *v17; // rax
  __int64 v18; // rbx
  __int64 v19; // rdi
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // r8
  __int64 v27; // r9
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // r9
  char ***v32; // rax
  __int64 v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // r8
  __int64 v36; // r9
  _QWORD *i; // [rsp+0h] [rbp-28h]
  unsigned int v38; // [rsp+0h] [rbp-28h]
  __int64 **port_765; // [rsp+8h] [rbp-20h]
  __int64 v40; // [rsp+10h] [rbp-18h]
  _QWORD *v41; // [rsp+18h] [rbp-10h]

  v41 = v9;
  for ( i = v10; ; caml_call_gc(a1, a2, a3, a4, a5, a6, (char)i) )
  {
    v11 -= 12;
    if ( (unsigned __int64)v11 >= caml_young_limit )
      break;
  }
  port_765 = (__int64 **)(v11 + 1);
  *v11 = 1024LL;
  v11[1] = 1LL;
  v40 = (__int64)(v11 + 3);
  v11[2] = 1024LL;
  v11[3] = 1LL;
  v11[4] = 1024LL;
  v11[5] = 1LL;
  v11[6] = 5367LL;
  v11[7] = camlUnix__fun_1847;
  v11[8] = 3LL;
  v11[9] = v11 + 1;
  v11[10] = v11 + 3;
  v11[11] = v11 + 5;
  camlList__iter_102();
  while ( 1 )
  {
    v11 -= 5;
    if ( (unsigned __int64)v11 >= caml_young_limit )
      break;
    caml_call_gc(a1, (__int64)camlUnix__fun_1847, v12, v13, v14, v15, (char)i);
  }
  v16 = (__int64)(v11 + 1);
  *v11 = 4343LL;
  v11[1] = caml_curry2;
  v11[2] = 5LL;
  v11[3] = camlUnix__get_port_765;
  v11[4] = i;
  v17 = *port_765;
  if ( *port_765 == (__int64 *)1 )
  {
    port_765 = (__int64 **)camlUnix__get_port_765(v16);
    camlUnix__get_port_765(v16);
    v38 = (unsigned int)camlPervasives___40_167();
  }
  else
  {
    v18 = *v17;
    if ( *v17 == 3 || v18 == 1 )
    {
      v38 = camlUnix__get_port_765(v16);
    }
    else
    {
      v19 = (__int64)i;
      if ( caml_string_equal(i, camlUnix__200) == 1 )
      {
        v38 = 1;
      }
      else
      {
        while ( 1 )
        {
          v11 -= 6;
          if ( (unsigned __int64)v11 >= caml_young_limit )
            break;
          caml_call_gc(v19, (__int64)camlUnix__200, v20, v21, v22, v23, (char)i);
        }
        *v11 = 2048LL;
        v11[1] = v18;
        v11[2] = 1LL;
        v38 = (_DWORD)v11 + 32;
        v11[3] = 2048LL;
        v11[4] = v11 + 1;
        v11[5] = 1LL;
      }
    }
  }
  if ( caml_string_equal(v41, camlUnix__195) != 1 )
  {
    if ( camlList__mem_189() == 1 )
    {
      while ( 1 )
      {
        v11 -= 6;
        if ( (unsigned __int64)v11 >= caml_young_limit )
          break;
        caml_call_gc((__int64)v41, (__int64)camlUnix__195, v24, v25, v26, v27, v38);
      }
      *v11 = 2048LL;
      v11[1] = camlUnix[108];
      v11[2] = camlUnix__193;
      v11[3] = 2048LL;
      v11[4] = v11 + 1;
      v11[5] = 1LL;
    }
    else
    {
      while ( 1 )
      {
        v11 -= 6;
        if ( (unsigned __int64)v11 >= caml_young_limit )
          break;
        caml_call_gc((__int64)v41, (__int64)camlUnix__195, v24, v25, v26, v27, v38);
      }
      *v11 = 2048LL;
      v11[1] = camlUnix[107];
      v11[2] = camlUnix__194;
      v11[3] = 2048LL;
      v11[4] = v11 + 1;
      v11[5] = 1LL;
    }
LABEL_30:
    JUMPOUT(0x40E10CLL);
  }
  if ( *(char ***)sub_40E0AC((__int64)v41, (unsigned __int64)camlUnix__195) == &caml_exn_Failure )
  {
    sub_40E030(
      (__int64)&caml_exn_Failure,
      (unsigned __int64)camlUnix__195,
      v28,
      v29,
      v30,
      v31,
      v38,
      (__int64)port_765,
      v40);
    if ( *v32 == &caml_exn_Not_found )
      goto LABEL_30;
    caml_raise_exn();
    sub_40E030((__int64)&caml_exn_Not_found, (unsigned __int64)camlUnix__195, v33, v34, v35, v36, a7, a8, a9);
  }
  else
  {
    caml_raise_exn();
    sub_40E0AC((__int64)&caml_exn_Failure, (unsigned __int64)camlUnix__195);
  }
}
// 40DF89: control flows out of bounds to 40E10C
// 40DD14: variable 'v9' is possibly undefined
// 40DD19: variable 'v10' is possibly undefined
// 40DD25: variable 'v11' is possibly undefined
// 40DDEC: variable 'i' is possibly undefined
// 40E005: variable 'v28' is possibly undefined
// 40E005: variable 'v29' is possibly undefined
// 40E005: variable 'v30' is possibly undefined
// 40E005: variable 'v31' is possibly undefined
// 40E011: variable 'v32' is possibly undefined
// 40E02E: variable 'v33' is possibly undefined
// 40E02E: variable 'v34' is possibly undefined
// 40E02E: variable 'v35' is possibly undefined
// 40E02E: variable 'v36' is possibly undefined
// 40E17F: variable 'v24' is possibly undefined
// 40E17F: variable 'v25' is possibly undefined
// 40E17F: variable 'v26' is possibly undefined
// 40E17F: variable 'v27' is possibly undefined
// 40E17F: variable 'v38' is possibly undefined
// 40E193: variable 'v20' is possibly undefined
// 40E193: variable 'v21' is possibly undefined
// 40E193: variable 'v22' is possibly undefined
// 40E193: variable 'v23' is possibly undefined
// 40E19D: variable 'v12' is possibly undefined
// 40E19D: variable 'v13' is possibly undefined
// 40E19D: variable 'v14' is possibly undefined
// 40E19D: variable 'v15' is possibly undefined
// 40E1A7: variable 'a3' is possibly undefined
// 40E1A7: variable 'a4' is possibly undefined
// 40E1A7: variable 'a5' is possibly undefined
// 40E1A7: variable 'a6' is possibly undefined
// 647A80: using guessed type char *caml_exn_Failure;
// 647B68: using guessed type char *caml_exn_Not_found;
// 648B48: using guessed type _QWORD camlUnix[168];
// 64A478: using guessed type _QWORD camlUnix__195[2];
// 64A4C8: using guessed type _QWORD camlUnix__200[2];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040E030) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40E030(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        int a7,
        __int64 a8,
        __int64 a9)
{
  _QWORD *v9; // r15
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  char v19; // [rsp-8h] [rbp-10h]
  __int64 v20; // [rsp+10h] [rbp+8h]

  caml_c_call(a9, a2);
  v20 = v10;
  camlArray__to_list_148(a9, a2, v11, v12, v13, v14);
  while ( 1 )
  {
    v9 -= 4;
    if ( (unsigned __int64)v9 >= caml_young_limit )
      break;
    caml_call_gc(a9, a2, v15, v16, v17, v18, v19);
  }
  *v9 = 3319LL;
  v9[1] = camlUnix__fun_1852;
  v9[2] = 3LL;
  v9[3] = v20;
  camlList__map_90();
  JUMPOUT(0x40E10CLL);
}
// 40E0A0: positive sp value 8 has been found
// 40E0A0: control flows out of bounds to 40E10C
// 40E046: variable 'v10' is possibly undefined
// 40E04F: variable 'v11' is possibly undefined
// 40E04F: variable 'v12' is possibly undefined
// 40E04F: variable 'v13' is possibly undefined
// 40E04F: variable 'v14' is possibly undefined
// 40E057: variable 'v9' is possibly undefined
// 40E175: variable 'v15' is possibly undefined
// 40E175: variable 'v16' is possibly undefined
// 40E175: variable 'v17' is possibly undefined
// 40E175: variable 'v18' is possibly undefined
// 40E175: variable 'v19' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040E0AC) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_40E0AC(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // r15
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rax
  __int64 i; // rdi
  __int64 v10; // rdi
  char v12; // [rsp-30h] [rbp-38h]
  char v13; // [rsp-20h] [rbp-28h]
  __int64 v14; // [rsp-10h] [rbp-18h]
  __int64 v15; // [rsp-8h] [rbp-10h]

  caml_c_call(v2, a2);
  for ( i = v8; ; caml_call_gc(i, a2, v4, v5, v6, v7, v12) )
  {
    v3 -= 6;
    if ( (unsigned __int64)v3 >= caml_young_limit )
      break;
  }
  *v3 = 2048LL;
  v3[1] = i;
  v3[2] = v15;
  v10 = (__int64)(v3 + 4);
  v3[3] = 2048LL;
  v3[4] = v3 + 1;
  v3[5] = 1LL;
  while ( 1 )
  {
    v3 -= 6;
    if ( (unsigned __int64)v3 >= caml_young_limit )
      break;
    caml_call_gc(v10, a2, v4, v5, v6, v7, v13);
  }
  *v3 = 5367LL;
  v3[1] = caml_tuplify2;
  v3[2] = -3LL;
  v3[3] = camlUnix__fun_1855;
  v3[4] = v14;
  v3[5] = v10;
  camlList__map_90();
  return camlList__flatten_86();
}
// 40E15F: positive sp value 30 has been found
// 40E0BB: variable 'v2' is possibly undefined
// 40E0C0: variable 'v8' is possibly undefined
// 40E0C3: variable 'v3' is possibly undefined
// 40E0EB: variable 'v15' is possibly undefined
// 40E14A: variable 'v14' is possibly undefined
// 40E164: variable 'v4' is possibly undefined
// 40E164: variable 'v5' is possibly undefined
// 40E164: variable 'v6' is possibly undefined
// 40E164: variable 'v7' is possibly undefined
// 40E164: variable 'v13' is possibly undefined
// 40E16B: variable 'v12' is possibly undefined
// 40BA30: using guessed type __int64 __fastcall caml_tuplify2();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040E1C0) ----------------------------------------------------
void __fastcall camlUnix__getaddrinfo_777(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        int a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9

  if ( (char **)*sub_40E208() == &caml_exn_Invalid_argument )
  {
    camlUnix__getaddrinfo_emulation_756(a1, a2, v9, v10, v11, v12, a7, a8, a9);
  }
  else
  {
    caml_raise_exn();
    sub_40E208();
  }
}
// 40E1FB: variable 'v9' is possibly undefined
// 40E1FB: variable 'v10' is possibly undefined
// 40E1FB: variable 'v11' is possibly undefined
// 40E1FB: variable 'v12' is possibly undefined
// 647AB0: using guessed type char *caml_exn_Invalid_argument;

//----- (000000000040E208) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_QWORD *__fastcall sub_40E208()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9

  v2 = v0;
  caml_c_call(v0, v1);
  return camlList__rev_append_79(v2, v1, v3, v4, v5, v6);
}
// 40E235: positive sp value 20 has been found
// 40E20D: variable 'v0' is possibly undefined
// 40E21A: variable 'v1' is possibly undefined
// 40E226: variable 'v3' is possibly undefined
// 40E226: variable 'v4' is possibly undefined
// 40E226: variable 'v5' is possibly undefined
// 40E226: variable 'v6' is possibly undefined

//----- (000000000040E240) ----------------------------------------------------
void __fastcall camlUnix__getnameinfo_emulation_798(__int64 a1, unsigned __int64 a2)
{
  __int64 *v2; // rax
  _QWORD *v3; // r15
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // [rsp+0h] [rbp-18h]

  if ( *((_BYTE *)v2 - 8) )
  {
    v8 = *v2;
    if ( (char **)*sub_40E2E8(v2[1], a2) == &caml_exn_Not_found )
    {
      if ( camlList__mem_189() != 1 )
      {
        while ( 1 )
        {
          v3 -= 2;
          if ( (unsigned __int64)v3 >= caml_young_limit )
            break;
          caml_call_gc((__int64)&caml_exn_Not_found, a2, v4, v5, v6, v7, v8);
        }
        *v3 = 1024LL;
        v3[1] = &caml_exn_Not_found;
        caml_raise_exn();
      }
      caml_c_call(v8, a2);
    }
    else
    {
      caml_raise_exn();
    }
    JUMPOUT(0x40E34FLL);
  }
  JUMPOUT(0x40E43CLL);
}
// 40E2E4: control flows out of bounds to 40E34F
// 40E24C: control flows out of bounds to 40E43C
// 40E244: variable 'v2' is possibly undefined
// 40E292: variable 'v3' is possibly undefined
// 40E2CF: variable 'v8' is possibly undefined
// 40E490: variable 'v4' is possibly undefined
// 40E490: variable 'v5' is possibly undefined
// 40E490: variable 'v6' is possibly undefined
// 40E490: variable 'v7' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040E2E8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_QWORD *__fastcall sub_40E2E8(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // r15
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rdi
  void **v8; // rax
  char v10; // [rsp-8h] [rbp-10h]
  __int64 retaddr; // [rsp+8h] [rbp+0h]

  if ( camlList__mem_189() != 1 )
  {
    while ( 1 )
    {
      v2 -= 2;
      if ( (unsigned __int64)v2 >= caml_young_limit )
        break;
      caml_call_gc(a1, a2, v3, v4, v5, v6, v10);
    }
    *v2 = 1024LL;
    v2[1] = &caml_exn_Not_found;
    caml_raise_exn();
  }
  v7 = retaddr;
  caml_c_call(retaddr, a2);
  retaddr = (__int64)*v8;
  if ( (char **)*sub_40E380(v7, a2) == &caml_exn_Not_found )
  {
    camlPervasives__string_of_int_154();
    JUMPOUT(0x40E40DLL);
  }
  caml_raise_exn();
  return sub_40E380((__int64)&caml_exn_Not_found, a2);
}
// 40E34F: positive sp value 8 has been found
// 40E370: control flows out of bounds to 40E40D
// 40E2FF: variable 'v2' is possibly undefined
// 40E344: variable 'v8' is possibly undefined
// 40E486: variable 'v3' is possibly undefined
// 40E486: variable 'v4' is possibly undefined
// 40E486: variable 'v5' is possibly undefined
// 40E486: variable 'v6' is possibly undefined
// 40E486: variable 'v10' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040E380) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_QWORD *__fastcall sub_40E380(__int64 a1, __int64 a2)
{
  _QWORD *v2; // r15
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  void *v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 *v12; // rax
  __int64 i; // rdi
  _QWORD *result; // rax
  char v15; // [rsp-20h] [rbp-28h]
  __int64 v16; // [rsp-10h] [rbp-18h]
  __int64 v17; // [rsp-8h] [rbp-10h]

  if ( camlList__mem_189() != 1 )
  {
    while ( 1 )
    {
      v2 -= 2;
      if ( (unsigned __int64)v2 >= caml_young_limit )
        break;
      caml_call_gc(a1, a2, v3, v4, v5, v6, v15);
    }
    *v2 = 1024LL;
    v2[1] = &caml_exn_Not_found;
    caml_raise_exn();
  }
  if ( camlList__mem_189() == 1 )
    v7 = &camlUnix__191;
  else
    v7 = &camlUnix__192;
  caml_c_call(v17, (unsigned __int64)v7);
  for ( i = *v12; ; caml_call_gc(i, (__int64)v7, v8, v9, v10, v11, v16) )
  {
    v2 -= 3;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
  }
  result = v2 + 1;
  *v2 = 2048LL;
  v2[1] = v16;
  v2[2] = i;
  return result;
}
// 40E438: positive sp value 20 has been found
// 40E380: could not find valid save-restore pair for rbx
// 40E39C: variable 'v2' is possibly undefined
// 40E3FF: variable 'v17' is possibly undefined
// 40E404: variable 'v12' is possibly undefined
// 40E42D: variable 'v16' is possibly undefined
// 40E475: variable 'v8' is possibly undefined
// 40E475: variable 'v9' is possibly undefined
// 40E475: variable 'v10' is possibly undefined
// 40E475: variable 'v11' is possibly undefined
// 40E47C: variable 'v3' is possibly undefined
// 40E47C: variable 'v4' is possibly undefined
// 40E47C: variable 'v5' is possibly undefined
// 40E47C: variable 'v6' is possibly undefined
// 40E47C: variable 'v15' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040E4A0) ----------------------------------------------------
void __fastcall camlUnix__getnameinfo_807(__int64 a1, unsigned __int64 a2)
{
  char ***v2; // rax

  sub_40E4DC();
  if ( *v2 == &caml_exn_Invalid_argument )
  {
    camlUnix__getnameinfo_emulation_798((__int64)&caml_exn_Invalid_argument, a2);
  }
  else
  {
    caml_raise_exn();
    sub_40E4DC();
  }
}
// 40E4B9: variable 'v2' is possibly undefined
// 647AB0: using guessed type char *caml_exn_Invalid_argument;

//----- (000000000040E4DC) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40E4DC()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 40E4FD: positive sp value 20 has been found
// 40E4EE: variable 'v0' is possibly undefined
// 40E4EE: variable 'v1' is possibly undefined

//----- (000000000040E500) ----------------------------------------------------
void __fastcall camlUnix__system_917(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9

  caml_c_call(1LL, a2);
  if ( v2 == 1 )
  {
    sub_40E55C(1LL, a2, v3, v4, v5, v6);
    camlPervasives__exit_350(1LL, a2);
  }
  else
  {
    caml_c_call(1LL, v2);
  }
}
// 40E51F: variable 'v2' is possibly undefined
// 40E544: variable 'v3' is possibly undefined
// 40E544: variable 'v4' is possibly undefined
// 40E544: variable 'v5' is possibly undefined
// 40E544: variable 'v6' is possibly undefined

//----- (000000000040E55C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40E55C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // r15
  char v7; // [rsp-10h] [rbp-18h]
  __int64 v8; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    v6 -= 4;
    if ( (unsigned __int64)v6 >= caml_young_limit )
      break;
    caml_call_gc(a1, a2, a3, a4, a5, a6, v7);
  }
  *v6 = 3072LL;
  v6[1] = camlUnix__188;
  v6[2] = &camlUnix__189;
  v6[3] = v8;
  caml_c_call((__int64)camlUnix__187, (unsigned __int64)(v6 + 1));
}
// 40E5B8: positive sp value 10 has been found
// 40E561: variable 'v6' is possibly undefined
// 40E597: variable 'v8' is possibly undefined
// 40E5B9: variable 'a3' is possibly undefined
// 40E5B9: variable 'a4' is possibly undefined
// 40E5B9: variable 'a5' is possibly undefined
// 40E5B9: variable 'a6' is possibly undefined
// 40E5B9: variable 'v7' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040E5C0) ----------------------------------------------------
void __fastcall camlUnix__safe_dup_920(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // [rsp+8h] [rbp-10h]

  v3 = v2;
  caml_c_call(v2, a2);
  if ( v4 < 7 )
  {
    v5 = v4;
    camlUnix__safe_dup_920(v3, a2);
    caml_c_call(v5, a2);
  }
}
// 40E5C8: variable 'v2' is possibly undefined
// 40E5DB: variable 'v4' is possibly undefined

//----- (000000000040E610) ----------------------------------------------------
void __fastcall camlUnix__safe_close_924(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  _QWORD *v3; // rax

  sub_40E640(a1, a2);
  v2 = camlUnix[0];
  if ( *v3 != camlUnix[0] )
  {
    caml_raise_exn();
    sub_40E640(v2, a2);
  }
}
// 40E623: variable 'v3' is possibly undefined
// 648B48: using guessed type _QWORD camlUnix[168];

//----- (000000000040E640) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40E640(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40E65E: positive sp value 10 has been found
// 40E64F: variable 'v2' is possibly undefined

//----- (000000000040E660) ----------------------------------------------------
void __fastcall camlUnix__perform_redirections_926(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // [rsp+18h] [rbp-20h]
  __int64 v6; // [rsp+20h] [rbp-18h]
  __int64 v7; // [rsp+28h] [rbp-10h]

  camlUnix__safe_dup_920(a1, a2);
  v5 = v2;
  camlUnix__safe_dup_920(a1, a2);
  v6 = v3;
  camlUnix__safe_dup_920(a1, a2);
  v7 = v4;
  camlUnix__safe_close_924(a1, a2);
  camlUnix__safe_close_924(a1, a2);
  camlUnix__safe_close_924(a1, a2);
  caml_c_call(v5, 1uLL);
  caml_c_call(v5, 1uLL);
  caml_c_call(v6, 3uLL);
  caml_c_call(v6, 3uLL);
  caml_c_call(v7, 5uLL);
  caml_c_call(v7, 5uLL);
}
// 40E677: variable 'v2' is possibly undefined
// 40E686: variable 'v3' is possibly undefined
// 40E695: variable 'v4' is possibly undefined

//----- (000000000040E740) ----------------------------------------------------
void __fastcall camlUnix__create_process_933(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(1LL, a2);
  if ( v2 == 1 )
  {
    sub_40E794(1LL, a2);
    camlPervasives__exit_350(1LL, a2);
  }
}
// 40E773: variable 'v2' is possibly undefined

//----- (000000000040E794) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40E794(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // [rsp-10h] [rbp-18h]
  __int64 v3; // [rsp-8h] [rbp-10h]
  unsigned __int64 v4; // [rsp+0h] [rbp-8h]

  camlUnix__perform_redirections_926(v2, a2);
  caml_c_call(v3, v4);
}
// 40E7CD: positive sp value 30 has been found
// 40E794: could not find valid save-restore pair for rbx
// 40E7A8: variable 'v2' is possibly undefined
// 40E7BE: variable 'v3' is possibly undefined
// 40E7BE: variable 'v4' is possibly undefined

//----- (000000000040E7D0) ----------------------------------------------------
void __fastcall camlUnix__create_process_env_940(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(1LL, a2);
  if ( v2 == 1 )
  {
    sub_40E828(1LL, a2);
    camlPervasives__exit_350(1LL, a2);
  }
}
// 40E808: variable 'v2' is possibly undefined

//----- (000000000040E828) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40E828(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // [rsp-20h] [rbp-28h]
  __int64 v3; // [rsp-18h] [rbp-20h]
  unsigned __int64 v4; // [rsp-10h] [rbp-18h]

  camlUnix__perform_redirections_926(v2, a2);
  caml_c_call(v3, v4);
}
// 40E866: positive sp value 40 has been found
// 40E828: could not find valid save-restore pair for rbx
// 40E83C: variable 'v2' is possibly undefined
// 40E857: variable 'v3' is possibly undefined
// 40E857: variable 'v4' is possibly undefined

//----- (000000000040E870) ----------------------------------------------------
void __fastcall camlUnix__open_proc_975(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rdi
  __int64 v8; // [rsp+0h] [rbp-38h]
  __int64 v9; // [rsp+18h] [rbp-20h]

  v9 = a2;
  v8 = camlList__for_all_165();
  caml_c_call(1LL, a2);
  if ( v2 == 1 )
  {
    if ( a1 != 1 )
    {
      a2 = 1LL;
      caml_c_call(a1, 1uLL);
      caml_c_call(a1, 1uLL);
    }
    v7 = v9;
    if ( v9 != 3 )
    {
      a2 = 3LL;
      caml_c_call(v9, 3uLL);
      v7 = v9;
      caml_c_call(v9, 3uLL);
    }
    if ( v8 == 1 )
      camlList__iter_102();
    sub_40E978(v7, a2, v3, v4, v5, v6);
    camlPervasives__exit_350(v7, a2);
  }
  else
  {
    camlHashtbl__add_102(v2, a2);
  }
}
// 40E8C1: variable 'v2' is possibly undefined
// 40E963: variable 'v3' is possibly undefined
// 40E963: variable 'v4' is possibly undefined
// 40E963: variable 'v5' is possibly undefined
// 40E963: variable 'v6' is possibly undefined

//----- (000000000040E978) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40E978(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // r15
  char v7; // [rsp-40h] [rbp-48h]
  __int64 v8; // [rsp-28h] [rbp-30h]

  while ( 1 )
  {
    v6 -= 4;
    if ( (unsigned __int64)v6 >= caml_young_limit )
      break;
    caml_call_gc(a1, a2, a3, a4, a5, a6, v7);
  }
  *v6 = 3072LL;
  v6[1] = camlUnix__184;
  v6[2] = &camlUnix__185;
  v6[3] = v8;
  caml_c_call((__int64)camlUnix__183, (unsigned __int64)(v6 + 1));
}
// 40E9D4: positive sp value 40 has been found
// 40E97D: variable 'v6' is possibly undefined
// 40E9B3: variable 'v8' is possibly undefined
// 40E9D5: variable 'a3' is possibly undefined
// 40E9D5: variable 'a4' is possibly undefined
// 40E9D5: variable 'a5' is possibly undefined
// 40E9D5: variable 'a6' is possibly undefined
// 40E9D5: variable 'v7' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040E9E0) ----------------------------------------------------
__int64 __fastcall camlUnix__open_process_in_983(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // r15
  __int64 *v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rax
  __int64 v9; // rdi
  __int64 v11; // [rsp+0h] [rbp-28h]
  unsigned __int64 v12; // [rsp+10h] [rbp-18h]
  __int64 v13; // [rsp+18h] [rbp-10h]

  caml_c_call(1LL, a2);
  v12 = v3[1];
  v11 = *v3;
  caml_c_call(*v3, a2);
  v9 = v8;
  v13 = v8;
  while ( 1 )
  {
    v2 -= 5;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
    caml_call_gc(v9, a2, v4, v5, v6, v7, v11);
  }
  *v2 = 2048LL;
  v2[1] = v11;
  v2[2] = 1LL;
  v2[3] = 1025LL;
  v2[4] = v9;
  camlUnix__open_proc_975(1LL, v12);
  caml_c_call(v12, v12);
  return v13;
}
// 40E9FC: variable 'v3' is possibly undefined
// 40EA18: variable 'v8' is possibly undefined
// 40EA20: variable 'v2' is possibly undefined
// 40EA40: variable 'v11' is possibly undefined
// 40EA8B: variable 'v4' is possibly undefined
// 40EA8B: variable 'v5' is possibly undefined
// 40EA8B: variable 'v6' is possibly undefined
// 40EA8B: variable 'v7' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040EAA0) ----------------------------------------------------
__int64 __fastcall camlUnix__open_process_out_988(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // r15
  __int64 *v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rax
  __int64 v9; // rdi
  __int64 v11; // [rsp+0h] [rbp-28h]
  __int64 v12; // [rsp+10h] [rbp-18h]
  __int64 v13; // [rsp+18h] [rbp-10h]

  caml_c_call(1LL, a2);
  v11 = v3[1];
  v12 = *v3;
  caml_c_call(v11, a2);
  v9 = v8;
  v13 = v8;
  while ( 1 )
  {
    v2 -= 5;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
    caml_call_gc(v9, a2, v4, v5, v6, v7, v11);
  }
  *v2 = 2048LL;
  v2[1] = v11;
  v2[2] = 1LL;
  v2[3] = 1026LL;
  v2[4] = v9;
  camlUnix__open_proc_975(v12, 3LL);
  caml_c_call(v12, 3uLL);
  return v13;
}
// 40EABC: variable 'v3' is possibly undefined
// 40EAD8: variable 'v8' is possibly undefined
// 40EAE0: variable 'v2' is possibly undefined
// 40EB00: variable 'v11' is possibly undefined
// 40EB4B: variable 'v4' is possibly undefined
// 40EB4B: variable 'v5' is possibly undefined
// 40EB4B: variable 'v6' is possibly undefined
// 40EB4B: variable 'v7' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040EB60) ----------------------------------------------------
_QWORD *__fastcall camlUnix__open_process_993(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // r15
  __int64 *v3; // rax
  __int64 *v4; // rax
  __int64 v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rax
  __int64 v11; // rdi
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  _QWORD *result; // rax
  __int64 v17; // [rsp+0h] [rbp-38h]
  __int64 v18; // [rsp+8h] [rbp-30h]
  __int64 v19; // [rsp+18h] [rbp-20h]
  unsigned __int64 v20; // [rsp+20h] [rbp-18h]
  __int64 v21; // [rsp+28h] [rbp-10h]
  __int64 v22; // [rsp+30h] [rbp-8h]

  caml_c_call(1LL, a2);
  v20 = v3[1];
  v18 = *v3;
  caml_c_call(1LL, a2);
  v17 = v4[1];
  v19 = *v4;
  caml_c_call(v18, a2);
  v21 = v5;
  caml_c_call(v17, a2);
  v11 = v10;
  v22 = v10;
  while ( 1 )
  {
    v2 -= 9;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
    caml_call_gc(v11, a2, v6, v7, v8, v9, v17);
  }
  *v2 = 2048LL;
  v2[1] = v17;
  v2[2] = 1LL;
  v2[3] = 2048LL;
  v2[4] = v18;
  v2[5] = v2 + 1;
  v2[6] = 2048LL;
  v2[7] = v21;
  v2[8] = v11;
  camlUnix__open_proc_975(v19, v20);
  caml_c_call(v19, v20);
  caml_c_call(v20, v20);
  while ( 1 )
  {
    v2 -= 3;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
    caml_call_gc(v20, v20, v12, v13, v14, v15, v17);
  }
  result = v2 + 1;
  *v2 = 2048LL;
  v2[1] = v21;
  v2[2] = v22;
  return result;
}
// 40EB60: could not find valid save-restore pair for rbx
// 40EB7C: variable 'v3' is possibly undefined
// 40EBA0: variable 'v4' is possibly undefined
// 40EBC1: variable 'v5' is possibly undefined
// 40EBD6: variable 'v10' is possibly undefined
// 40EBDE: variable 'v2' is possibly undefined
// 40EC02: variable 'v17' is possibly undefined
// 40ECA5: variable 'v12' is possibly undefined
// 40ECA5: variable 'v13' is possibly undefined
// 40ECA5: variable 'v14' is possibly undefined
// 40ECA5: variable 'v15' is possibly undefined
// 40ECAC: variable 'v6' is possibly undefined
// 40ECAC: variable 'v7' is possibly undefined
// 40ECAC: variable 'v8' is possibly undefined
// 40ECAC: variable 'v9' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040ECC0) ----------------------------------------------------
void __fastcall camlUnix__open_proc_full_1001(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v11; // [rsp+18h] [rbp-30h]

  v11 = camlList__for_all_165();
  caml_c_call(1LL, a2);
  if ( v4 == 1 )
  {
    caml_c_call(a2, 1uLL);
    caml_c_call(a2, 1uLL);
    caml_c_call(a3, 3uLL);
    caml_c_call(a3, 3uLL);
    caml_c_call(a4, 5uLL);
    caml_c_call(a4, 5uLL);
    if ( v11 == 1 )
      camlList__iter_102();
    sub_40EDE8(a4, 5LL, v5, v6, v7, v8);
    camlPervasives__exit_350(a4, 5uLL);
  }
  else
  {
    camlHashtbl__add_102(v4, a2);
  }
}
// 40ED1B: variable 'v4' is possibly undefined
// 40EDD1: variable 'v5' is possibly undefined
// 40EDD1: variable 'v6' is possibly undefined
// 40EDD1: variable 'v7' is possibly undefined
// 40EDD1: variable 'v8' is possibly undefined

//----- (000000000040EDE8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40EDE8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // r15
  char v7; // [rsp-50h] [rbp-58h]
  __int64 v8; // [rsp-20h] [rbp-28h]

  while ( 1 )
  {
    v6 -= 4;
    if ( (unsigned __int64)v6 >= caml_young_limit )
      break;
    caml_call_gc(a1, a2, a3, a4, a5, a6, v7);
  }
  *v6 = 3072LL;
  v6[1] = camlUnix__180;
  v6[2] = &camlUnix__181;
  v6[3] = v8;
  caml_c_call((__int64)camlUnix__179, (unsigned __int64)(v6 + 1));
}
// 40EE49: positive sp value 50 has been found
// 40EDED: variable 'v6' is possibly undefined
// 40EE23: variable 'v8' is possibly undefined
// 40EE4A: variable 'a3' is possibly undefined
// 40EE4A: variable 'a4' is possibly undefined
// 40EE4A: variable 'a5' is possibly undefined
// 40EE4A: variable 'a6' is possibly undefined
// 40EE4A: variable 'v7' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040EE60) ----------------------------------------------------
_QWORD *__fastcall camlUnix__open_process_full_1011(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // r15
  __int64 *v3; // rax
  unsigned __int64 *v4; // rax
  __int64 *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rdi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  _QWORD *result; // rax
  __int64 v20; // [rsp+0h] [rbp-58h]
  __int64 v21; // [rsp+8h] [rbp-50h]
  __int64 v22; // [rsp+10h] [rbp-48h]
  unsigned __int64 v23; // [rsp+28h] [rbp-30h]
  __int64 v24; // [rsp+30h] [rbp-28h]
  __int64 v25; // [rsp+38h] [rbp-20h]
  __int64 v26; // [rsp+40h] [rbp-18h]
  __int64 v27; // [rsp+48h] [rbp-10h]
  __int64 v28; // [rsp+50h] [rbp-8h]

  caml_c_call(1LL, a2);
  v24 = v3[1];
  v22 = *v3;
  caml_c_call(1LL, a2);
  v21 = v4[1];
  v23 = *v4;
  caml_c_call(1LL, a2);
  v25 = v5[1];
  v20 = *v5;
  caml_c_call(v22, a2);
  v26 = v6;
  caml_c_call(v21, a2);
  v27 = v7;
  v8 = v20;
  caml_c_call(v20, a2);
  v14 = v13;
  v28 = v13;
  while ( 1 )
  {
    v2 -= 13;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
    caml_call_gc(v8, v14, v9, v10, v11, v12, v20);
  }
  *v2 = 2048LL;
  v2[1] = v20;
  v2[2] = 1LL;
  v2[3] = 2048LL;
  v2[4] = v21;
  v2[5] = v2 + 1;
  v2[6] = 2048LL;
  v2[7] = v22;
  v2[8] = v2 + 4;
  v2[9] = 3075LL;
  v2[10] = v26;
  v2[11] = v27;
  v2[12] = v14;
  camlUnix__open_proc_full_1001((__int64)(v2 + 10), v23, v24, v25);
  caml_c_call(v23, v23);
  caml_c_call(v24, v23);
  caml_c_call(v25, v23);
  while ( 1 )
  {
    v2 -= 4;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
    caml_call_gc(v25, v23, v15, v16, v17, v18, v20);
  }
  result = v2 + 1;
  *v2 = 3072LL;
  v2[1] = v26;
  v2[2] = v27;
  v2[3] = v28;
  return result;
}
// 40EE60: could not find valid save-restore pair for rbx
// 40EE81: variable 'v3' is possibly undefined
// 40EEA5: variable 'v4' is possibly undefined
// 40EEC9: variable 'v5' is possibly undefined
// 40EEEA: variable 'v6' is possibly undefined
// 40EF00: variable 'v7' is possibly undefined
// 40EF15: variable 'v13' is possibly undefined
// 40EF1D: variable 'v2' is possibly undefined
// 40EF41: variable 'v20' is possibly undefined
// 40F029: variable 'v15' is possibly undefined
// 40F029: variable 'v16' is possibly undefined
// 40F029: variable 'v17' is possibly undefined
// 40F029: variable 'v18' is possibly undefined
// 40F030: variable 'v9' is possibly undefined
// 40F030: variable 'v10' is possibly undefined
// 40F030: variable 'v11' is possibly undefined
// 40F030: variable 'v12' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040F040) ----------------------------------------------------
__int64 __fastcall camlUnix__find_proc_id_1023(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  _QWORD *v3; // r15
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  char v9; // [rsp+0h] [rbp-18h]
  __int64 v10; // [rsp+8h] [rbp-10h]

  v10 = v2;
  if ( *(char ***)sub_40F0B8(a1, a2) == &caml_exn_Not_found )
  {
    while ( 1 )
    {
      v3 -= 5;
      if ( (unsigned __int64)v3 >= caml_young_limit )
        break;
      caml_call_gc((__int64)&caml_exn_Not_found, a2, v4, v5, v6, v7, v9);
    }
    *v3 = 4096LL;
    v3[1] = camlUnix[0];
    v3[2] = 7LL;
    v3[3] = v10;
    v3[4] = &camlUnix__178;
    caml_raise_exn();
  }
  caml_raise_exn();
  return sub_40F0B8((__int64)&caml_exn_Not_found, a2);
}
// 40F044: variable 'v2' is possibly undefined
// 40F062: variable 'v3' is possibly undefined
// 40F0FC: variable 'v4' is possibly undefined
// 40F0FC: variable 'v5' is possibly undefined
// 40F0FC: variable 'v6' is possibly undefined
// 40F0FC: variable 'v7' is possibly undefined
// 40F0FC: variable 'v9' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 648B48: using guessed type _QWORD camlUnix[168];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040F0B8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_40F0B8(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 _121; // [rsp-10h] [rbp-18h]

  _121 = camlHashtbl__find_121(a1, a2);
  camlHashtbl__remove_108(a1, a2, v2, v3, v4, v5);
  return _121;
}
// 40F0FB: positive sp value 20 has been found
// 40F0B8: could not find valid save-restore pair for rbx
// 40F0E8: variable 'v2' is possibly undefined
// 40F0E8: variable 'v3' is possibly undefined
// 40F0E8: variable 'v4' is possibly undefined
// 40F0E8: variable 'v5' is possibly undefined

//----- (000000000040F110) ----------------------------------------------------
void __fastcall camlUnix__waitpid_non_intr_1027()
{
  __int64 v0; // rax
  _QWORD *v1; // rax
  __int64 v2; // rbx
  __int64 v3; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    v3 = v0;
    sub_40F14C();
    if ( *v1 != camlUnix[0] )
      break;
    v2 = v1[1];
    if ( (v2 & 1) == 0 || v2 != 23 )
      break;
    v0 = v3;
  }
  caml_raise_exn();
  sub_40F14C();
}
// 40F114: variable 'v0' is possibly undefined
// 40F127: variable 'v1' is possibly undefined
// 648B48: using guessed type _QWORD camlUnix[168];

//----- (000000000040F14C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40F14C()
{
  unsigned __int64 v0; // rax

  caml_c_call(1LL, v0);
}
// 40F171: positive sp value 10 has been found
// 40F162: variable 'v0' is possibly undefined

//----- (000000000040F180) ----------------------------------------------------
__int64 __fastcall camlUnix__close_process_in_1029(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rdi
  __int64 v9; // rax
  __int64 i; // [rsp+0h] [rbp-18h]

  v8 = v6;
  for ( i = v6; ; caml_call_gc(v8, a2, a3, a4, a5, a6, i) )
  {
    v7 -= 2;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 1025LL;
  v7[1] = v8;
  camlUnix__find_proc_id_1023(v8, a2);
  caml_c_call(i, a2);
  camlUnix__waitpid_non_intr_1027();
  return *(_QWORD *)(v9 + 8);
}
// 40F184: variable 'v6' is possibly undefined
// 40F18B: variable 'v7' is possibly undefined
// 40F1C6: variable 'i' is possibly undefined
// 40F1D5: variable 'v9' is possibly undefined
// 40F1E1: variable 'a3' is possibly undefined
// 40F1E1: variable 'a4' is possibly undefined
// 40F1E1: variable 'a5' is possibly undefined
// 40F1E1: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040F1F0) ----------------------------------------------------
__int64 __fastcall camlUnix__close_process_out_1032(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rdi
  __int64 v9; // rax
  char i; // [rsp+0h] [rbp-18h]

  v8 = v6;
  for ( i = v6; ; caml_call_gc(v8, a2, a3, a4, a5, a6, i) )
  {
    v7 -= 2;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 1026LL;
  v7[1] = v8;
  camlUnix__find_proc_id_1023(v8, a2);
  camlPervasives__close_out_233(v8, a2);
  camlUnix__waitpid_non_intr_1027();
  return *(_QWORD *)(v9 + 8);
}
// 40F1F4: variable 'v6' is possibly undefined
// 40F1FB: variable 'v7' is possibly undefined
// 40F23E: variable 'v9' is possibly undefined
// 40F24A: variable 'a3' is possibly undefined
// 40F24A: variable 'a4' is possibly undefined
// 40F24A: variable 'a5' is possibly undefined
// 40F24A: variable 'a6' is possibly undefined
// 40F24A: variable 'i' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040F260) ----------------------------------------------------
__int64 __fastcall camlUnix__close_process_1035(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdi
  __int64 i; // [rsp+0h] [rbp-18h]

  v9 = v6;
  for ( i = v6; ; caml_call_gc(v9, v7, a3, a4, a5, a6, i) )
  {
    v8 -= 3;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 2048LL;
  v8[1] = v9;
  v8[2] = v7;
  camlUnix__find_proc_id_1023(v9, v7);
  caml_c_call(i, v7);
  if ( *(char ***)sub_40F2D0(i, v7) == &caml_exn_Sys_error )
    JUMPOUT(0x40F2E5LL);
  caml_raise_exn();
  return sub_40F2D0((__int64)&caml_exn_Sys_error, v7);
}
// 40F2C9: control flows out of bounds to 40F2E5
// 40F26C: variable 'v6' is possibly undefined
// 40F273: variable 'v8' is possibly undefined
// 40F292: variable 'v7' is possibly undefined
// 40F2B2: variable 'i' is possibly undefined
// 40F2FB: variable 'a3' is possibly undefined
// 40F2FB: variable 'a4' is possibly undefined
// 40F2FB: variable 'a5' is possibly undefined
// 40F2FB: variable 'a6' is possibly undefined
// 647A48: using guessed type char *caml_exn_Sys_error;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040F2D0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_40F2D0(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  camlPervasives__close_out_233(a1, a2);
  camlUnix__waitpid_non_intr_1027();
  return *(_QWORD *)(v2 + 8);
}
// 40F2FA: positive sp value 20 has been found
// 40F2EF: variable 'v2' is possibly undefined

//----- (000000000040F310) ----------------------------------------------------
__int64 __fastcall camlUnix__close_process_full_1039(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdx
  unsigned __int64 v10; // rsi
  __int64 i; // [rsp+0h] [rbp-28h]

  v9 = v7;
  v10 = v6;
  for ( i = v6; ; caml_call_gc(a1, v10, v9, a4, a5, a6, i) )
  {
    v8 -= 4;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 3075LL;
  v8[1] = v10;
  v8[2] = v9;
  v8[3] = a1;
  camlUnix__find_proc_id_1023(a1, v10);
  caml_c_call(i, v10);
  if ( *(char ***)sub_40F390(i, v10) == &caml_exn_Sys_error )
    JUMPOUT(0x40F3A5LL);
  caml_raise_exn();
  return sub_40F390((__int64)&caml_exn_Sys_error, v10);
}
// 40F386: control flows out of bounds to 40F3A5
// 40F319: variable 'v7' is possibly undefined
// 40F321: variable 'v6' is possibly undefined
// 40F328: variable 'v8' is possibly undefined
// 40F34B: variable 'v9' is possibly undefined
// 40F36F: variable 'i' is possibly undefined
// 40F3CC: variable 'a4' is possibly undefined
// 40F3CC: variable 'a5' is possibly undefined
// 40F3CC: variable 'a6' is possibly undefined
// 647A48: using guessed type char *caml_exn_Sys_error;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040F390) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_40F390(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v4; // [rsp-18h] [rbp-20h]

  camlPervasives__close_out_233(a1, a2);
  caml_c_call(v4, a2);
  camlUnix__waitpid_non_intr_1027();
  return *(_QWORD *)(v2 + 8);
}
// 40F3CB: positive sp value 30 has been found
// 40F3B1: variable 'v4' is possibly undefined
// 40F3C0: variable 'v2' is possibly undefined

//----- (000000000040F3E0) ----------------------------------------------------
_QWORD *__fastcall camlUnix__open_connection_1044()
{
  __int64 v0; // rax
  __int64 v1; // rax
  __int64 v3; // [rsp+8h] [rbp-10h]

  v0 = camlUnix__domain_of_sockaddr_555();
  caml_c_call(v0, 1uLL);
  v3 = v1;
  sub_40F434();
  caml_c_call(v3, 1uLL);
  caml_raise_exn();
  return sub_40F434();
}
// 40F40A: variable 'v1' is possibly undefined

//----- (000000000040F434) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_QWORD *__fastcall sub_40F434()
{
  __int64 v0; // rax
  _QWORD *v1; // r15
  __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rax
  __int64 v10; // rbx
  _QWORD *result; // rax
  char v12; // [rsp-20h] [rbp-28h]
  unsigned __int64 v13; // [rsp-10h] [rbp-18h]
  __int64 v14; // [rsp-10h] [rbp-18h]
  __int64 v15; // [rsp-8h] [rbp-10h]

  v2 = v0;
  v3 = v13;
  caml_c_call(v0, v13);
  camlUnix__try_set_close_on_exec_394(v2, v13);
  caml_c_call(v15, v13);
  v14 = v4;
  caml_c_call(v15, v3);
  v10 = v9;
  while ( 1 )
  {
    v1 -= 3;
    if ( (unsigned __int64)v1 >= caml_young_limit )
      break;
    caml_call_gc(v15, v3, v5, v6, v7, v8, v12);
  }
  result = v1 + 1;
  *v1 = 2048LL;
  v1[1] = v10;
  v1[2] = v14;
  return result;
}
// 40F4B3: positive sp value 20 has been found
// 40F434: could not find valid save-restore pair for rbx
// 40F439: variable 'v0' is possibly undefined
// 40F43C: variable 'v13' is possibly undefined
// 40F463: variable 'v15' is possibly undefined
// 40F468: variable 'v4' is possibly undefined
// 40F47E: variable 'v9' is possibly undefined
// 40F481: variable 'v1' is possibly undefined
// 40F4B4: variable 'v5' is possibly undefined
// 40F4B4: variable 'v6' is possibly undefined
// 40F4B4: variable 'v7' is possibly undefined
// 40F4B4: variable 'v8' is possibly undefined
// 40F4B4: variable 'v12' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000040F4C0) ----------------------------------------------------
void __fastcall camlUnix__shutdown_connection_1048(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rax

  caml_c_call(v2, a2);
  caml_c_call(v3, 3uLL);
}
// 40F4CE: variable 'v2' is possibly undefined
// 40F4E4: variable 'v3' is possibly undefined

//----- (000000000040F4F0) ----------------------------------------------------
void __fastcall camlUnix__accept_non_intr_1050(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  _QWORD *v3; // rax
  __int64 v4; // rbx
  __int64 v5; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    v5 = v2;
    sub_40F52C(a1, a2);
    a1 = camlUnix[0];
    if ( *v3 != camlUnix[0] )
      break;
    v4 = v3[1];
    if ( (v4 & 1) == 0 || v4 != 23 )
      break;
    v2 = v5;
  }
  caml_raise_exn();
  sub_40F52C(a1, a2);
}
// 40F4F4: variable 'v2' is possibly undefined
// 40F507: variable 'v3' is possibly undefined
// 648B48: using guessed type _QWORD camlUnix[168];

//----- (000000000040F52C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_40F52C(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 40F54A: positive sp value 10 has been found
// 40F53B: variable 'v2' is possibly undefined

//----- (000000000040F550) ----------------------------------------------------
void __fastcall __noreturn camlUnix__establish_server_1052()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // [rsp+8h] [rbp-20h]
  __int64 v9; // [rsp+10h] [rbp-18h]
  __int64 v10; // [rsp+18h] [rbp-10h]

  v9 = v0;
  v2 = camlUnix__domain_of_sockaddr_555();
  caml_c_call(v2, 1uLL);
  v8 = v3;
  camlUnix__setsockopt_672();
  caml_c_call(v8, v1);
  v4 = v8;
  caml_c_call(v8, 0xBuLL);
  while ( 1 )
  {
    while ( 1 )
    {
      camlUnix__accept_non_intr_1050(v4, 0xBuLL);
      v10 = *v5;
      caml_c_call(1LL, 0xBuLL);
      if ( v6 == 1 )
        break;
      v4 = v10;
      caml_c_call(v10, 0xBuLL);
      camlUnix__waitpid_non_intr_1027();
    }
    caml_c_call(1LL, 0xBuLL);
    if ( v7 != 1 )
      camlPervasives__exit_350(1LL, 0xBuLL);
    caml_c_call(v8, 0xBuLL);
    camlUnix__try_set_close_on_exec_394(v8, 0xBuLL);
    caml_c_call(v10, 0xBuLL);
    caml_c_call(v10, 0xBuLL);
    v4 = v9;
    caml_apply2(v9);
    camlPervasives__exit_350(v9, 0xBuLL);
  }
}
// 40F554: variable 'v0' is possibly undefined
// 40F582: variable 'v3' is possibly undefined
// 40F5AA: variable 'v1' is possibly undefined
// 40F5D4: variable 'v5' is possibly undefined
// 40F5F4: variable 'v6' is possibly undefined
// 40F62B: variable 'v7' is possibly undefined
// 40F550: using guessed type void __fastcall __noreturn camlUnix__establish_server_1052();

//----- (000000000040F6B0) ----------------------------------------------------
__int64 __fastcall camlUnix__entry(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // r15
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rax
  __int64 v16; // rax
  char v18; // [rsp+0h] [rbp-8h]
  char v19; // [rsp+0h] [rbp-8h]

  camlUnix[152] = &camlUnix__173;
  camlUnix[151] = &camlUnix__172;
  camlUnix[150] = &camlUnix__171;
  camlUnix[149] = &camlUnix__170;
  camlUnix[148] = &camlUnix__169;
  camlUnix[147] = &camlUnix__168;
  camlUnix[146] = &camlUnix__167;
  camlUnix[143] = &camlUnix__166;
  camlUnix[142] = &camlUnix__165;
  camlUnix[141] = &camlUnix__164;
  camlUnix[140] = &camlUnix__163;
  camlUnix[139] = &camlUnix__162;
  camlUnix[138] = &camlUnix__161;
  camlUnix[137] = &camlUnix__160;
  camlUnix[120] = &camlUnix__159;
  camlUnix[119] = &camlUnix__158;
  camlUnix[118] = &camlUnix__157;
  camlUnix[117] = &camlUnix__156;
  camlUnix[116] = &camlUnix__155;
  camlUnix[115] = &camlUnix__154;
  camlUnix[114] = &camlUnix__153;
  camlUnix[113] = &camlUnix__152;
  camlUnix[111] = &camlUnix__151;
  camlUnix[106] = &camlUnix__150;
  camlUnix[105] = &camlUnix__149;
  camlUnix[104] = &camlUnix__148;
  camlUnix[103] = &camlUnix__147;
  camlUnix[102] = &camlUnix__146;
  camlUnix[101] = &camlUnix__145;
  camlUnix[100] = &camlUnix__144;
  camlUnix[99] = &camlUnix__143;
  camlUnix[98] = &camlUnix__142;
  camlUnix[97] = &camlUnix__141;
  camlUnix[96] = &camlUnix__140;
  camlUnix[95] = &camlUnix__139;
  camlUnix[94] = &camlUnix__138;
  camlUnix[93] = &camlUnix__137;
  camlUnix[92] = &camlUnix__136;
  camlUnix[91] = &camlUnix__135;
  camlUnix[90] = &camlUnix__134;
  camlUnix[89] = &camlUnix__133;
  camlUnix[88] = &camlUnix__132;
  camlUnix[87] = &camlUnix__131;
  camlUnix[86] = &camlUnix__130;
  camlUnix[85] = &camlUnix__129;
  camlUnix[84] = &camlUnix__128;
  camlUnix[83] = &camlUnix__127;
  camlUnix[82] = &camlUnix__126;
  camlUnix[80] = &camlUnix__125;
  camlUnix[79] = &camlUnix__124;
  camlUnix[78] = &camlUnix__123;
  camlUnix[77] = &camlUnix__122;
  camlUnix[76] = &camlUnix__121;
  camlUnix[75] = &camlUnix__120;
  camlUnix[74] = &camlUnix__119;
  camlUnix[73] = &camlUnix__118;
  camlUnix[62] = &camlUnix__117;
  camlUnix[61] = &camlUnix__116;
  camlUnix[60] = &camlUnix__115;
  camlUnix[59] = &camlUnix__114;
  camlUnix[58] = &camlUnix__113;
  camlUnix[57] = &camlUnix__112;
  camlUnix[56] = &camlUnix__111;
  camlUnix[55] = &camlUnix__110;
  camlUnix[54] = &camlUnix__109;
  camlUnix[53] = &camlUnix__108;
  camlUnix[52] = &camlUnix__107;
  camlUnix[51] = &camlUnix__106;
  camlUnix[50] = &camlUnix__105;
  camlUnix[49] = &camlUnix__104;
  camlUnix[48] = &camlUnix__103;
  camlUnix[47] = &camlUnix__102;
  camlUnix[46] = &camlUnix__101;
  camlUnix[45] = &camlUnix__100;
  camlUnix[44] = &camlUnix__99;
  camlUnix[43] = &camlUnix__98;
  camlUnix[42] = &camlUnix__97;
  camlUnix[41] = &camlUnix__96;
  camlUnix[40] = &camlUnix__95;
  camlUnix[39] = &camlUnix__94;
  camlUnix[38] = &camlUnix__93;
  camlUnix[37] = &camlUnix__92;
  camlUnix[35] = &camlUnix__91;
  camlUnix[34] = &camlUnix__90;
  camlUnix[33] = &camlUnix__89;
  camlUnix[32] = &camlUnix__88;
  camlUnix[31] = &camlUnix__87;
  camlUnix[30] = &camlUnix__86;
  camlUnix[29] = &camlUnix__85;
  camlUnix[28] = &camlUnix__84;
  camlUnix[27] = &camlUnix__83;
  camlUnix[26] = &camlUnix__82;
  camlUnix[25] = &camlUnix__81;
  camlUnix[21] = &camlUnix__80;
  camlUnix[20] = &camlUnix__79;
  camlUnix[16] = &camlUnix__78;
  camlUnix[15] = &camlUnix__77;
  camlUnix[14] = &camlUnix__76;
  camlUnix[12] = &camlUnix__75;
  camlUnix[11] = &camlUnix__74;
  camlUnix[10] = &camlUnix__73;
  camlUnix[9] = &camlUnix__72;
  camlUnix[8] = &camlUnix__71;
  camlUnix[7] = &camlUnix__70;
  camlUnix[6] = &camlUnix__69;
  camlUnix[5] = &camlUnix__68;
  camlUnix[4] = &camlUnix__67;
  camlUnix[3] = &camlUnix__66;
  camlUnix[1] = &camlUnix__65;
  caml_allocN(a1, a2, a3, a4, a5, a6, v18);
  *v6 = 1024LL;
  v6[1] = camlUnix__64;
  camlUnix[0] = v6 + 1;
  v6[2] = 4096LL;
  v6[3] = camlUnix[0];
  v6[4] = 1LL;
  v6[5] = &camlUnix__62;
  v6[6] = &camlUnix__63;
  camlCallback__register_exception_62(a1, a2, v7, v8, v9, v10);
  camlUnix[2] = &camlUnix__60;
  camlUnix[17] = 1LL;
  camlUnix[18] = 3LL;
  camlUnix[19] = 5LL;
  camlUnix[22] = &camlUnix__59;
  camlUnix[23] = &camlUnix__58;
  camlUnix[24] = &camlUnix__57;
  caml_allocN(a1, a2, v11, v12, v13, v14, v19);
  *v6 = 6144LL;
  v6[1] = &camlUnix__50;
  v6[2] = &camlUnix__51;
  v6[3] = &camlUnix__52;
  v6[4] = &camlUnix__53;
  v6[5] = &camlUnix__54;
  v6[6] = &camlUnix__55;
  camlUnix[36] = v6 + 1;
  camlUnix[153] = &camlUnix__49;
  camlUnix[81] = &camlUnix__48;
  camlUnix[154] = &camlUnix__47;
  caml_c_call((__int64)camlUnix__46, a2);
  camlUnix[107] = v15;
  caml_c_call((__int64)camlUnix__45, a2);
  camlUnix[108] = v16;
  if ( *(char ***)sub_41018C((__int64)camlUnix__45, a2) == &caml_exn_Failure )
    JUMPOUT(0x4101AALL);
  caml_raise_exn();
  return sub_41018C((__int64)&caml_exn_Failure, a2);
}
// 410185: control flows out of bounds to 4101AA
// 40FF85: variable 'v18' is possibly undefined
// 40FF8E: variable 'v6' is possibly undefined
// 40FFE8: variable 'v7' is possibly undefined
// 40FFE8: variable 'v8' is possibly undefined
// 40FFE8: variable 'v9' is possibly undefined
// 40FFE8: variable 'v10' is possibly undefined
// 410082: variable 'v11' is possibly undefined
// 410082: variable 'v12' is possibly undefined
// 410082: variable 'v13' is possibly undefined
// 410082: variable 'v14' is possibly undefined
// 410082: variable 'v19' is possibly undefined
// 41013B: variable 'v15' is possibly undefined
// 41015C: variable 'v16' is possibly undefined
// 647A80: using guessed type char *caml_exn_Failure;
// 648B48: using guessed type _QWORD camlUnix[168];
// 649558: using guessed type __int64 (__fastcall *camlUnix__47)();
// 649570: using guessed type __int64 (__fastcall *camlUnix__48)();
// 649588: using guessed type __int64 (__fastcall *camlUnix__49)();
// 6495A0: using guessed type __int64 (__fastcall *camlUnix__50)();
// 6495C0: using guessed type __int64 (__fastcall *camlUnix__51)();
// 6495E0: using guessed type __int64 (__fastcall *camlUnix__52)();
// 649600: using guessed type __int64 (__fastcall *camlUnix__53)();
// 649618: using guessed type __int64 (__fastcall *camlUnix__54)();
// 649630: using guessed type __int64 (__fastcall *camlUnix__55)();
// 649648: using guessed type __int64 (__fastcall *camlUnix__57)();
// 649668: using guessed type __int64 (__fastcall *camlUnix__58)();
// 649688: using guessed type __int64 (__fastcall *camlUnix__59)();
// 6496A8: using guessed type __int64 (__fastcall *camlUnix__60)();
// 6496C8: using guessed type __int64 (__fastcall *camlUnix__65)();
// 6496E0: using guessed type __int64 (__fastcall *camlUnix__66)();
// 6496F8: using guessed type __int64 (__fastcall *camlUnix__67)();
// 649710: using guessed type __int64 (__fastcall *camlUnix__68)();
// 649730: using guessed type __int64 (__fastcall *camlUnix__69)();
// 649750: using guessed type __int64 (__fastcall *camlUnix__70)();
// 649770: using guessed type __int64 (__fastcall *camlUnix__71)();
// 649790: using guessed type __int64 (__fastcall *camlUnix__72)();
// 6497B0: using guessed type __int64 (__fastcall *camlUnix__73)();
// 6497C8: using guessed type __int64 (__fastcall *camlUnix__74)();
// 6497E0: using guessed type __int64 (__fastcall *camlUnix__75)();
// 649800: using guessed type __int64 (__fastcall *camlUnix__76)();
// 649818: using guessed type __int64 (__fastcall *camlUnix__77)();
// 649830: using guessed type __int64 (__fastcall *camlUnix__78)();
// 649848: using guessed type __int64 (__fastcall *camlUnix__79)();
// 649868: using guessed type __int64 (__fastcall *camlUnix__80)();
// 649880: using guessed type __int64 (__fastcall *camlUnix__81)();
// 649898: using guessed type __int64 (__fastcall *camlUnix__82)();
// 6498B0: using guessed type __int64 (__fastcall *camlUnix__83)();
// 6498C8: using guessed type __int64 (__fastcall *camlUnix__84)();
// 6498E0: using guessed type __int64 (__fastcall *camlUnix__85)();
// 649900: using guessed type __int64 (__fastcall *camlUnix__86)();
// 649920: using guessed type __int64 (__fastcall *camlUnix__87)();
// 649940: using guessed type __int64 (__fastcall *camlUnix__88)();
// 649958: using guessed type __int64 (__fastcall *camlUnix__89)();
// 649970: using guessed type __int64 (__fastcall *camlUnix__90)();
// 649988: using guessed type __int64 (__fastcall *camlUnix__91)();
// 6499A0: using guessed type __int64 (__fastcall *camlUnix__92)();
// 6499B8: using guessed type __int64 (__fastcall *camlUnix__93)();
// 6499D8: using guessed type __int64 (__fastcall *camlUnix__94)();
// 6499F8: using guessed type __int64 (__fastcall *camlUnix__95)();
// 649A18: using guessed type __int64 (__fastcall *camlUnix__96)();
// 649A38: using guessed type __int64 (__fastcall *camlUnix__97)();
// 649A58: using guessed type __int64 (__fastcall *camlUnix__98)();
// 649A78: using guessed type __int64 (__fastcall *camlUnix__99)();
// 649A90: using guessed type __int64 (__fastcall *camlUnix__100)();
// 649AB0: using guessed type __int64 (__fastcall *camlUnix__101)();
// 649AC8: using guessed type __int64 (__fastcall *camlUnix__102)();
// 649AE8: using guessed type __int64 (__fastcall *camlUnix__103)();
// 649B00: using guessed type __int64 (__fastcall *camlUnix__104)();
// 649B18: using guessed type __int64 (__fastcall *camlUnix__105)();
// 649B30: using guessed type __int64 (__fastcall *camlUnix__106)();
// 649B48: using guessed type __int64 (__fastcall *camlUnix__107)();
// 649B68: using guessed type __int64 (__fastcall *camlUnix__108)();
// 649B80: using guessed type __int64 (__fastcall *camlUnix__109)();
// 649B98: using guessed type __int64 (__fastcall *camlUnix__110)();
// 649BB0: using guessed type __int64 (__fastcall *camlUnix__111)();
// 649BC8: using guessed type __int64 (__fastcall *camlUnix__112)();
// 649BE0: using guessed type __int64 (__fastcall *camlUnix__113)();
// 649BF8: using guessed type __int64 (__fastcall *camlUnix__114)();
// 649C10: using guessed type __int64 (__fastcall *camlUnix__115)();
// 649C28: using guessed type __int64 (__fastcall *camlUnix__116)();
// 649C40: using guessed type __int64 (__fastcall *camlUnix__117)();
// 649C60: using guessed type __int64 (__fastcall *camlUnix__118)();
// 649C80: using guessed type __int64 (__fastcall *camlUnix__119)();
// 649C98: using guessed type __int64 (__fastcall *camlUnix__120)();
// 649CB8: using guessed type __int64 (__fastcall *camlUnix__121)();
// 649CD8: using guessed type __int64 (__fastcall *camlUnix__122)();
// 649CF8: using guessed type __int64 (__fastcall *camlUnix__123)();
// 649D18: using guessed type __int64 (__fastcall *camlUnix__124)();
// 649D30: using guessed type __int64 (__fastcall *camlUnix__125)();
// 649D48: using guessed type __int64 (__fastcall *camlUnix__126)();
// 649D60: using guessed type __int64 (__fastcall *camlUnix__127)();
// 649D78: using guessed type __int64 (__fastcall *camlUnix__128)();
// 649D90: using guessed type __int64 (__fastcall *camlUnix__129)();
// 649DA8: using guessed type __int64 (__fastcall *camlUnix__130)();
// 649DC0: using guessed type __int64 (__fastcall *camlUnix__131)();
// 649DD8: using guessed type __int64 (__fastcall *camlUnix__132)();
// 649DF0: using guessed type __int64 (__fastcall *camlUnix__133)();
// 649E08: using guessed type __int64 (__fastcall *camlUnix__134)();
// 649E28: using guessed type __int64 (__fastcall *camlUnix__135)();
// 649E40: using guessed type __int64 (__fastcall *camlUnix__136)();
// 649E60: using guessed type __int64 (__fastcall *camlUnix__137)();
// 649E78: using guessed type __int64 (__fastcall *camlUnix__138)();
// 649E90: using guessed type __int64 (__fastcall *camlUnix__139)();
// 649EA8: using guessed type __int64 (__fastcall *camlUnix__140)();
// 649EC0: using guessed type __int64 (__fastcall *camlUnix__141)();
// 649ED8: using guessed type __int64 (__fastcall *camlUnix__142)();
// 649EF0: using guessed type __int64 (__fastcall *camlUnix__143)();
// 649F08: using guessed type __int64 (__fastcall *camlUnix__144)();
// 649F20: using guessed type __int64 (__fastcall *camlUnix__145)();
// 649F38: using guessed type __int64 (__fastcall *camlUnix__146)();
// 649F50: using guessed type __int64 (__fastcall *camlUnix__147)();
// 649F68: using guessed type __int64 (__fastcall *camlUnix__148)();
// 649F80: using guessed type __int64 (__fastcall *camlUnix__149)();
// 649F98: using guessed type __int64 (__fastcall *camlUnix__150)();
// 649FB0: using guessed type __int64 (__fastcall *camlUnix__151)();
// 649FD0: using guessed type __int64 (__fastcall *camlUnix__152)();
// 649FF0: using guessed type __int64 (__fastcall *camlUnix__153)();
// 64A008: using guessed type __int64 (__fastcall *camlUnix__154)();
// 64A028: using guessed type __int64 (__fastcall *camlUnix__155)();
// 64A048: using guessed type __int64 (__fastcall *camlUnix__156)();
// 64A068: using guessed type __int64 (__fastcall *camlUnix__157)();
// 64A088: using guessed type __int64 (__fastcall *camlUnix__158)();
// 64A0A0: using guessed type __int64 (__fastcall *camlUnix__159)();
// 64A0B8: using guessed type __int64 (__fastcall *camlUnix__160)();
// 64A0D0: using guessed type __int64 (__fastcall *camlUnix__161)();
// 64A0E8: using guessed type __int64 (__fastcall *camlUnix__162)();
// 64A100: using guessed type __int64 (__fastcall *camlUnix__163)();
// 64A118: using guessed type __int64 (__fastcall *camlUnix__164)();
// 64A130: using guessed type __int64 (__fastcall *camlUnix__165)();
// 64A150: using guessed type __int64 (__fastcall *camlUnix__166)();
// 64A170: using guessed type __int64 (__fastcall *camlUnix__167)();
// 64A188: using guessed type __int64 (__fastcall *camlUnix__168)();
// 64A1A8: using guessed type __int64 (__fastcall *camlUnix__169)();
// 64A1C8: using guessed type __int64 (__fastcall *camlUnix__170)();
// 64A1E0: using guessed type __int64 (__fastcall *camlUnix__171)();
// 64A200: using guessed type __int64 (__fastcall *camlUnix__172)();
// 64A220: using guessed type __int64 (__fastcall *camlUnix__173)();

//----- (000000000041018C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_41018C(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call((__int64)&camlUnix__44, a2);
  camlUnix[109] = v2;
  if ( *(char ***)sub_4101E1((__int64)&camlUnix__44, a2) == &caml_exn_Failure )
    JUMPOUT(0x4101FFLL);
  caml_raise_exn();
  return sub_4101E1((__int64)&caml_exn_Failure, a2);
}
// 4101AA: positive sp value 8 has been found
// 4101DA: control flows out of bounds to 4101FF
// 4101B1: variable 'v2' is possibly undefined
// 647A80: using guessed type char *caml_exn_Failure;
// 648B48: using guessed type _QWORD camlUnix[168];

//----- (00000000004101E1) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_4101E1(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // r15
  __int64 v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  char v9; // [rsp+0h] [rbp-8h]

  caml_c_call((__int64)&camlUnix__43, a2);
  camlUnix[110] = v3;
  camlUnix[112] = &camlUnix__42;
  camlUnix[121] = &camlUnix__41;
  camlUnix[122] = &camlUnix__40;
  camlUnix[123] = &camlUnix__39;
  camlUnix[124] = &camlUnix__38;
  caml_allocN((__int64)&camlUnix__43, a2, v4, v5, v6, v7, v9);
  *v2 = 7168LL;
  v2[1] = 1LL;
  v2[2] = 3LL;
  v2[3] = 5LL;
  v2[4] = 7LL;
  v2[5] = 9LL;
  v2[6] = &camlUnix__36;
  v2[7] = &camlUnix__37;
  camlUnix[155] = v2 + 1;
  camlUnix[125] = &camlUnix__35;
  camlUnix[126] = &camlUnix__34;
  camlUnix[127] = &camlUnix__33;
  camlUnix[128] = &camlUnix__32;
  camlUnix[129] = &camlUnix__31;
  camlUnix[130] = &camlUnix__30;
  camlUnix[131] = &camlUnix__29;
  camlUnix[132] = &camlUnix__28;
  camlUnix[133] = &camlUnix__27;
  camlUnix[156] = &camlUnix__26;
  camlUnix[144] = &camlUnix__25;
  camlUnix[157] = &camlUnix__24;
  camlUnix[145] = &camlUnix__23;
  camlUnix[13] = &camlUnix__22;
  camlUnix[158] = &camlUnix__21;
  camlUnix[159] = &camlUnix__20;
  camlUnix[160] = &camlUnix__19;
  camlUnix[63] = &camlUnix__18;
  camlUnix[64] = &camlUnix__17;
  camlUnix[161] = camlHashtbl__create_79();
  camlUnix[162] = &camlUnix__16;
  camlUnix[65] = &camlUnix__15;
  camlUnix[66] = &camlUnix__14;
  camlUnix[67] = &camlUnix__13;
  camlUnix[163] = &camlUnix__12;
  camlUnix[68] = &camlUnix__11;
  camlUnix[164] = &camlUnix__10;
  camlUnix[165] = &camlUnix__9;
  camlUnix[69] = &camlUnix__8;
  camlUnix[70] = &camlUnix__7;
  camlUnix[71] = &camlUnix__6;
  camlUnix[72] = &camlUnix__5;
  camlUnix[134] = &camlUnix__4;
  camlUnix[135] = &camlUnix__3;
  camlUnix[166] = &camlUnix__2;
  camlUnix[136] = &camlUnix__1;
  return 1LL;
}
// 4105DA: positive sp value 10 has been found
// 410206: variable 'v3' is possibly undefined
// 41027D: variable 'v4' is possibly undefined
// 41027D: variable 'v5' is possibly undefined
// 41027D: variable 'v6' is possibly undefined
// 41027D: variable 'v7' is possibly undefined
// 41027D: variable 'v9' is possibly undefined
// 410286: variable 'v2' is possibly undefined
// 648B48: using guessed type _QWORD camlUnix[168];
// 649088: using guessed type __int64 (__fastcall *camlUnix__1)();
// 6490A8: using guessed type __int64 (__fastcall *camlUnix__2)();
// 6490C0: using guessed type __int64 (__fastcall *camlUnix__3)();
// 6490D8: using guessed type __int64 (__fastcall *camlUnix__4)();
// 6490F0: using guessed type __int64 (__fastcall *camlUnix__5)();
// 649110: using guessed type __int64 (__fastcall *camlUnix__6)();
// 649130: using guessed type __int64 (__fastcall *camlUnix__7)();
// 649148: using guessed type __int64 (__fastcall *camlUnix__8)();
// 649160: using guessed type __int64 (__fastcall *camlUnix__9)();
// 649178: using guessed type __int64 (__fastcall *camlUnix__10)();
// 649198: using guessed type __int64 (__fastcall *camlUnix__11)();
// 6491B8: using guessed type __int64 (__fastcall *camlUnix__12)();
// 6491D8: using guessed type __int64 (__fastcall *camlUnix__13)();
// 6491F0: using guessed type __int64 (__fastcall *camlUnix__14)();
// 649208: using guessed type __int64 (__fastcall *camlUnix__15)();
// 649220: using guessed type __int64 (__fastcall *camlUnix__16)();
// 649240: using guessed type __int64 (__fastcall *camlUnix__17)();
// 649260: using guessed type __int64 (__fastcall *camlUnix__18)();
// 649280: using guessed type __int64 (__fastcall *camlUnix__19)();
// 6492A0: using guessed type __int64 (__fastcall *camlUnix__20)();
// 6492B8: using guessed type __int64 (__fastcall *camlUnix__21)();
// 6492D0: using guessed type __int64 (__fastcall *camlUnix__22)();
// 6492E8: using guessed type __int64 (__fastcall *camlUnix__23)();
// 649308: using guessed type __int64 (__fastcall *camlUnix__24)();
// 649328: using guessed type __int64 (__fastcall *camlUnix__25)();
// 649348: using guessed type __int64 (__fastcall *camlUnix__26)();
// 649368: using guessed type __int64 (__fastcall *camlUnix__27)();
// 649380: using guessed type __int64 (__fastcall *camlUnix__28)();
// 6493A0: using guessed type __int64 (__fastcall *camlUnix__29)();
// 6493C0: using guessed type __int64 (__fastcall *camlUnix__30)();
// 6493E0: using guessed type __int64 (__fastcall *camlUnix__31)();
// 649400: using guessed type __int64 (__fastcall *camlUnix__32)();
// 649420: using guessed type __int64 (__fastcall *camlUnix__33)();
// 649440: using guessed type __int64 (__fastcall *camlUnix__34)();
// 649460: using guessed type __int64 (__fastcall *camlUnix__35)();
// 649480: using guessed type __int64 (__fastcall *camlUnix__36)();
// 6494A0: using guessed type __int64 (__fastcall *camlUnix__37)();
// 6494C0: using guessed type __int64 (__fastcall *camlUnix__38)();
// 6494E0: using guessed type __int64 (__fastcall *camlUnix__39)();
// 649500: using guessed type __int64 (__fastcall *camlUnix__40)();
// 649520: using guessed type __int64 (__fastcall *camlUnix__41)();
// 649540: using guessed type __int64 (__fastcall *camlUnix__42)();

//----- (00000000004105E0) ----------------------------------------------------
__int64 camlUnixLabels__code_begin()
{
  camlUnixLabels[0] = camlUnix[0];
  camlUnixLabels[1] = camlUnix[1];
  camlUnixLabels[2] = camlUnix[2];
  camlUnixLabels[3] = camlUnix[3];
  camlUnixLabels[4] = camlUnix[4];
  camlUnixLabels[5] = camlUnix[5];
  camlUnixLabels[6] = camlUnix[6];
  camlUnixLabels[7] = camlUnix[7];
  camlUnixLabels[8] = camlUnix[8];
  camlUnixLabels[9] = camlUnix[9];
  camlUnixLabels[10] = camlUnix[10];
  camlUnixLabels[11] = camlUnix[11];
  camlUnixLabels[12] = camlUnix[12];
  camlUnixLabels[13] = camlUnix[13];
  camlUnixLabels[14] = camlUnix[14];
  camlUnixLabels[15] = camlUnix[15];
  camlUnixLabels[16] = camlUnix[16];
  camlUnixLabels[17] = 1LL;
  camlUnixLabels[18] = 3LL;
  camlUnixLabels[19] = 5LL;
  camlUnixLabels[20] = camlUnix[20];
  camlUnixLabels[21] = camlUnix[21];
  camlUnixLabels[22] = camlUnix[22];
  camlUnixLabels[23] = camlUnix[23];
  camlUnixLabels[24] = camlUnix[24];
  camlUnixLabels[25] = camlUnix[25];
  camlUnixLabels[26] = camlUnix[26];
  camlUnixLabels[27] = camlUnix[27];
  camlUnixLabels[28] = camlUnix[28];
  camlUnixLabels[29] = camlUnix[29];
  camlUnixLabels[30] = camlUnix[30];
  camlUnixLabels[31] = camlUnix[31];
  camlUnixLabels[32] = camlUnix[32];
  camlUnixLabels[33] = camlUnix[33];
  camlUnixLabels[34] = camlUnix[34];
  camlUnixLabels[35] = camlUnix[35];
  camlUnixLabels[36] = camlUnix[36];
  camlUnixLabels[37] = camlUnix[37];
  camlUnixLabels[38] = camlUnix[38];
  camlUnixLabels[39] = camlUnix[39];
  camlUnixLabels[40] = camlUnix[40];
  camlUnixLabels[41] = camlUnix[41];
  camlUnixLabels[42] = camlUnix[42];
  camlUnixLabels[43] = camlUnix[43];
  camlUnixLabels[44] = camlUnix[44];
  camlUnixLabels[45] = camlUnix[45];
  camlUnixLabels[46] = camlUnix[46];
  camlUnixLabels[47] = camlUnix[47];
  camlUnixLabels[48] = camlUnix[48];
  camlUnixLabels[49] = camlUnix[49];
  camlUnixLabels[50] = camlUnix[50];
  camlUnixLabels[51] = camlUnix[51];
  camlUnixLabels[52] = camlUnix[52];
  camlUnixLabels[53] = camlUnix[53];
  camlUnixLabels[54] = camlUnix[54];
  camlUnixLabels[55] = camlUnix[55];
  camlUnixLabels[56] = camlUnix[56];
  camlUnixLabels[57] = camlUnix[57];
  camlUnixLabels[58] = camlUnix[58];
  camlUnixLabels[59] = camlUnix[59];
  camlUnixLabels[60] = camlUnix[60];
  camlUnixLabels[61] = camlUnix[61];
  camlUnixLabels[62] = camlUnix[62];
  camlUnixLabels[63] = camlUnix[63];
  camlUnixLabels[64] = camlUnix[64];
  camlUnixLabels[65] = camlUnix[65];
  camlUnixLabels[66] = camlUnix[66];
  camlUnixLabels[67] = camlUnix[67];
  camlUnixLabels[68] = camlUnix[68];
  camlUnixLabels[69] = camlUnix[69];
  camlUnixLabels[70] = camlUnix[70];
  camlUnixLabels[71] = camlUnix[71];
  camlUnixLabels[72] = camlUnix[72];
  camlUnixLabels[73] = camlUnix[73];
  camlUnixLabels[74] = camlUnix[74];
  camlUnixLabels[75] = camlUnix[75];
  camlUnixLabels[76] = camlUnix[76];
  camlUnixLabels[77] = camlUnix[77];
  camlUnixLabels[78] = camlUnix[78];
  camlUnixLabels[79] = camlUnix[79];
  camlUnixLabels[80] = camlUnix[80];
  camlUnixLabels[81] = camlUnix[81];
  camlUnixLabels[82] = camlUnix[82];
  camlUnixLabels[83] = camlUnix[83];
  camlUnixLabels[84] = camlUnix[84];
  camlUnixLabels[85] = camlUnix[85];
  camlUnixLabels[86] = camlUnix[86];
  camlUnixLabels[87] = camlUnix[87];
  camlUnixLabels[88] = camlUnix[88];
  camlUnixLabels[89] = camlUnix[89];
  camlUnixLabels[90] = camlUnix[90];
  camlUnixLabels[91] = camlUnix[91];
  camlUnixLabels[92] = camlUnix[92];
  camlUnixLabels[93] = camlUnix[93];
  camlUnixLabels[94] = camlUnix[94];
  camlUnixLabels[95] = camlUnix[95];
  camlUnixLabels[96] = camlUnix[96];
  camlUnixLabels[97] = camlUnix[97];
  camlUnixLabels[98] = camlUnix[98];
  camlUnixLabels[99] = camlUnix[99];
  camlUnixLabels[100] = camlUnix[100];
  camlUnixLabels[101] = camlUnix[101];
  camlUnixLabels[102] = camlUnix[102];
  camlUnixLabels[103] = camlUnix[103];
  camlUnixLabels[104] = camlUnix[104];
  camlUnixLabels[105] = camlUnix[105];
  camlUnixLabels[106] = camlUnix[106];
  camlUnixLabels[107] = camlUnix[107];
  camlUnixLabels[108] = camlUnix[108];
  camlUnixLabels[109] = camlUnix[109];
  camlUnixLabels[110] = camlUnix[110];
  camlUnixLabels[111] = camlUnix[111];
  camlUnixLabels[112] = camlUnix[112];
  camlUnixLabels[113] = camlUnix[113];
  camlUnixLabels[114] = camlUnix[114];
  camlUnixLabels[115] = camlUnix[115];
  camlUnixLabels[116] = camlUnix[116];
  camlUnixLabels[117] = camlUnix[117];
  camlUnixLabels[118] = camlUnix[118];
  camlUnixLabels[119] = camlUnix[119];
  camlUnixLabels[120] = camlUnix[120];
  camlUnixLabels[121] = camlUnix[121];
  camlUnixLabels[122] = camlUnix[122];
  camlUnixLabels[123] = camlUnix[123];
  camlUnixLabels[124] = camlUnix[124];
  camlUnixLabels[125] = camlUnix[125];
  camlUnixLabels[126] = camlUnix[126];
  camlUnixLabels[127] = camlUnix[127];
  camlUnixLabels[128] = camlUnix[128];
  camlUnixLabels[129] = camlUnix[129];
  camlUnixLabels[130] = camlUnix[130];
  camlUnixLabels[131] = camlUnix[131];
  camlUnixLabels[132] = camlUnix[132];
  camlUnixLabels[133] = camlUnix[133];
  camlUnixLabels[134] = camlUnix[134];
  camlUnixLabels[135] = camlUnix[135];
  camlUnixLabels[136] = camlUnix[136];
  camlUnixLabels[137] = camlUnix[137];
  camlUnixLabels[138] = camlUnix[138];
  camlUnixLabels[139] = camlUnix[139];
  camlUnixLabels[140] = camlUnix[140];
  camlUnixLabels[141] = camlUnix[141];
  camlUnixLabels[142] = camlUnix[142];
  camlUnixLabels[143] = camlUnix[143];
  camlUnixLabels[144] = camlUnix[144];
  camlUnixLabels[145] = camlUnix[145];
  camlUnixLabels[146] = camlUnix[146];
  camlUnixLabels[147] = camlUnix[147];
  camlUnixLabels[148] = camlUnix[148];
  camlUnixLabels[149] = camlUnix[149];
  camlUnixLabels[150] = camlUnix[150];
  camlUnixLabels[151] = camlUnix[151];
  camlUnixLabels[152] = camlUnix[152];
  return 1LL;
}
// 648B48: using guessed type _QWORD camlUnix[168];
// 64C8C0: using guessed type _QWORD camlUnixLabels[153];

//----- (0000000000411220) ----------------------------------------------------
__int64 __fastcall camlPervasives__code_begin()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v3; // rcx
  __int64 v4; // rdx
  __int64 v5; // rdi
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rdi
  __int64 v8; // rdi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9

  while ( 1 )
  {
    if ( v0 >= *(_QWORD *)(v1 + 24) )
      return camlPervasives___5e_136();
    v3 = *(_QWORD *)(v1 + 16);
    v4 = v0 >> 1;
    v5 = 8LL * (*(_QWORD *)(v3 - 8) >> 10) - 1;
    v6 = *(unsigned __int8 *)(v3 + v5);
    v7 = v5 - v6;
    if ( v7 <= v0 >> 1 )
      break;
    v8 = 2LL * *(unsigned __int8 *)(v3 + v4) + 1;
    if ( v8 < 97 )
    {
      if ( 2LL * *(unsigned __int8 *)(v3 + v4) != 90 )
        return *(_QWORD *)(v1 + 16);
    }
    else if ( v8 >= 117 )
    {
      return *(_QWORD *)(v1 + 16);
    }
    v0 += 2LL;
  }
  caml_ml_array_bound_error(v7, v6);
  return camlPervasives__iter_210(v7, v6, v9, v10, v11, v12);
}
// 411227: variable 'v0' is possibly undefined
// 411220: variable 'v1' is possibly undefined
// 411294: variable 'v9' is possibly undefined
// 411294: variable 'v10' is possibly undefined
// 411294: variable 'v11' is possibly undefined
// 411294: variable 'v12' is possibly undefined

//----- (00000000004112A0) ----------------------------------------------------
__int64 __fastcall camlPervasives__iter_210(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 *v6; // rax

  if ( v6 != (__int64 *)1 )
  {
    sub_4112BC(*v6, a2, a3, a4, a5, a6, v6[1]);
    JUMPOUT(0x4112D3LL);
  }
  return 1LL;
}
// 4112BA: control flows out of bounds to 4112D3
// 4112A8: variable 'v6' is possibly undefined

//----- (00000000004112BC) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_4112BC(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  caml_c_call(a1, a2);
  JUMPOUT(0x4112A4LL);
}
// 4112D3: positive sp value 8 has been found
// 4112D7: control flows out of bounds to 4112A4

//----- (00000000004112F0) ----------------------------------------------------
__int64 __fastcall camlPervasives__build_result_267(__int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // rbx
  __int64 v3; // r12
  __int64 *v4; // r13
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rbp

  while ( 1 )
  {
    v3 = result;
    if ( a1 == (__int64 *)1 )
      break;
    v4 = (__int64 *)a1[1];
    v5 = *a1;
    v6 = 8LL * (*(_QWORD *)(v5 - 8) >> 10) - 1;
    v7 = v6 - *(unsigned __int8 *)(v5 + v6);
    v8 = 2 * v7 + 1;
    caml_blit_string(v5, 1LL, v3, v2 - 2 * v7, v8);
    v2 = v2 - v8 + 1;
    result = v3;
    a1 = v4;
  }
  return result;
}
// 4112F4: variable 'result' is possibly undefined
// 411327: variable 'v2' is possibly undefined

//----- (0000000000411360) ----------------------------------------------------
unsigned __int64 __fastcall camlPervasives__scan_273(__int64 a1, unsigned __int64 a2)
{
  __int64 *v2; // rax
  __int64 v3; // rbx
  _QWORD *v4; // r15
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rsi
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 i; // rsi
  unsigned __int64 v19; // rax
  __int64 v20; // rdi
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  unsigned __int64 v25; // [rsp+0h] [rbp-28h]
  unsigned __int64 v26; // [rsp+0h] [rbp-28h]
  __int64 v27; // [rsp+8h] [rbp-20h]
  __int64 v28; // [rsp+10h] [rbp-18h]
  __int64 *v29; // [rsp+20h] [rbp-8h]

  while ( 1 )
  {
    v29 = v2;
    v27 = a1;
    v5 = *(_QWORD *)(a1 + 24);
    caml_c_call(v5, a2);
    if ( v6 == 1 )
    {
      if ( v29 != (__int64 *)1 )
      {
        caml_c_call(v3, a2);
        return camlPervasives__build_result_267(v29);
      }
      while ( 1 )
      {
        v4 -= 2;
        if ( (unsigned __int64)v4 >= caml_young_limit )
          break;
        caml_call_gc(v5, a2, v7, v8, v9, v10, v25);
      }
      *v4 = 1024LL;
      v4[1] = &caml_exn_End_of_file;
      v6 = caml_raise_exn();
    }
    v28 = v6;
    if ( v6 > 1 )
      break;
    caml_c_call(2 - v6, a2);
    v25 = v19;
    v20 = *(_QWORD *)(v27 + 24);
    a2 = v19;
    caml_c_call(v20, v19);
    while ( 1 )
    {
      v4 -= 3;
      if ( (unsigned __int64)v4 >= caml_young_limit )
        break;
      caml_call_gc(v20, a2, v21, v22, v23, v24, v25);
    }
    v2 = v4 + 1;
    *v4 = 2048LL;
    v4[1] = v25;
    v4[2] = v29;
    v3 = v3 - v28 + 1;
    a1 = v27;
  }
  caml_c_call(v6 - 2, a2);
  v26 = v12;
  v13 = v12;
  caml_c_call(*(_QWORD *)(v27 + 24), v12);
  caml_c_call(*(_QWORD *)(v27 + 24), v13);
  if ( v29 == (__int64 *)1 )
    return v26;
  for ( i = v3 + v28 - 3; ; caml_call_gc((__int64)v29, i, v14, v15, v16, v17, v26) )
  {
    v4 -= 3;
    if ( (unsigned __int64)v4 >= caml_young_limit )
      break;
  }
  *v4 = 2048LL;
  v4[1] = v26;
  v4[2] = v29;
  caml_c_call(i, i);
  return camlPervasives__build_result_267(v4 + 1);
}
// 411360: could not find valid save-restore pair for rbx
// 411364: variable 'v2' is possibly undefined
// 411387: variable 'v6' is possibly undefined
// 4113A5: variable 'v3' is possibly undefined
// 4113C0: variable 'v4' is possibly undefined
// 411412: variable 'v12' is possibly undefined
// 41149B: variable 'v26' is possibly undefined
// 4114E6: variable 'v19' is possibly undefined
// 411538: variable 'v25' is possibly undefined
// 41155E: variable 'v21' is possibly undefined
// 41155E: variable 'v22' is possibly undefined
// 41155E: variable 'v23' is possibly undefined
// 41155E: variable 'v24' is possibly undefined
// 411565: variable 'v14' is possibly undefined
// 411565: variable 'v15' is possibly undefined
// 411565: variable 'v16' is possibly undefined
// 411565: variable 'v17' is possibly undefined
// 41156F: variable 'v7' is possibly undefined
// 41156F: variable 'v8' is possibly undefined
// 41156F: variable 'v9' is possibly undefined
// 41156F: variable 'v10' is possibly undefined
// 647AF0: using guessed type char *caml_exn_End_of_file;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000411580) ----------------------------------------------------
__int64 __fastcall camlPervasives__fun_524()
{
  __int64 v0; // rbx

  (**(void (***)(void))(v0 + 16))();
  return (**(__int64 (***)(void))(v0 + 24))();
}
// 411588: variable 'v0' is possibly undefined
// 411580: using guessed type __int64 __fastcall camlPervasives__fun_524();

//----- (00000000004115B0) ----------------------------------------------------
void __fastcall camlPervasives__fun_416()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 4115C1: variable 'v0' is possibly undefined
// 4115C1: variable 'v1' is possibly undefined

//----- (00000000004115D0) ----------------------------------------------------
void __fastcall camlPervasives__fun_418(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 4115DE: variable 'v2' is possibly undefined

//----- (00000000004115F0) ----------------------------------------------------
void __fastcall camlPervasives__fun_420(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 4115FE: variable 'v2' is possibly undefined

//----- (0000000000411610) ----------------------------------------------------
void __fastcall camlPervasives__fun_422(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 41161E: variable 'v2' is possibly undefined

//----- (0000000000411630) ----------------------------------------------------
void __fastcall camlPervasives__fun_424()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 411641: variable 'v0' is possibly undefined
// 411641: variable 'v1' is possibly undefined

//----- (0000000000411650) ----------------------------------------------------
void __fastcall camlPervasives__fun_426(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 41165E: variable 'v2' is possibly undefined

//----- (0000000000411670) ----------------------------------------------------
void __fastcall camlPervasives__fun_428(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 41167E: variable 'v2' is possibly undefined

//----- (0000000000411690) ----------------------------------------------------
void __fastcall camlPervasives__fun_430(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 41169E: variable 'v2' is possibly undefined

//----- (00000000004116B0) ----------------------------------------------------
void __fastcall camlPervasives__fun_432(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 4116BE: variable 'v2' is possibly undefined

//----- (00000000004116D0) ----------------------------------------------------
void __fastcall camlPervasives__fun_434()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 4116E1: variable 'v0' is possibly undefined
// 4116E1: variable 'v1' is possibly undefined

//----- (00000000004116F0) ----------------------------------------------------
void __fastcall camlPervasives__fun_436(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 4116FE: variable 'v2' is possibly undefined

//----- (0000000000411710) ----------------------------------------------------
void __fastcall camlPervasives__fun_438(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 41171E: variable 'v2' is possibly undefined

//----- (0000000000411730) ----------------------------------------------------
void __fastcall camlPervasives__fun_440()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 411741: variable 'v0' is possibly undefined
// 411741: variable 'v1' is possibly undefined

//----- (0000000000411750) ----------------------------------------------------
void __fastcall camlPervasives__fun_442()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 411761: variable 'v0' is possibly undefined
// 411761: variable 'v1' is possibly undefined

//----- (0000000000411770) ----------------------------------------------------
void __fastcall camlPervasives__fun_444()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 411781: variable 'v0' is possibly undefined
// 411781: variable 'v1' is possibly undefined

//----- (0000000000411790) ----------------------------------------------------
void __fastcall camlPervasives__fun_446()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 4117A1: variable 'v0' is possibly undefined
// 4117A1: variable 'v1' is possibly undefined

//----- (00000000004117B0) ----------------------------------------------------
void __fastcall camlPervasives__fun_448(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 4117BE: variable 'v2' is possibly undefined

//----- (00000000004117D0) ----------------------------------------------------
void __fastcall __noreturn camlPervasives__failwith_38(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rdi
  char v9; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v9) )
  {
    v7 -= 3;
    if ( (unsigned __int64)v7 >= caml_young_limit )
    {
      *v7 = 2048LL;
      v7[1] = &caml_exn_Failure;
      v7[2] = i;
      caml_raise_exn();
    }
  }
}
// 4117D4: variable 'v6' is possibly undefined
// 4117D7: variable 'v7' is possibly undefined
// 411806: variable 'a3' is possibly undefined
// 411806: variable 'a4' is possibly undefined
// 411806: variable 'a5' is possibly undefined
// 411806: variable 'a6' is possibly undefined
// 411806: variable 'v9' is possibly undefined
// 647A80: using guessed type char *caml_exn_Failure;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000411810) ----------------------------------------------------
void __fastcall __noreturn camlPervasives__invalid_arg_40(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rdi
  char v9; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v9) )
  {
    v7 -= 3;
    if ( (unsigned __int64)v7 >= caml_young_limit )
    {
      *v7 = 2048LL;
      v7[1] = &caml_exn_Invalid_argument;
      v7[2] = i;
      caml_raise_exn();
    }
  }
}
// 411814: variable 'v6' is possibly undefined
// 411817: variable 'v7' is possibly undefined
// 411846: variable 'a3' is possibly undefined
// 411846: variable 'a4' is possibly undefined
// 411846: variable 'a5' is possibly undefined
// 411846: variable 'a6' is possibly undefined
// 411846: variable 'v9' is possibly undefined
// 647AB0: using guessed type char *caml_exn_Invalid_argument;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000411850) ----------------------------------------------------
void __fastcall camlPervasives__min_50()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 41186A: variable 'v0' is possibly undefined
// 41186A: variable 'v1' is possibly undefined

//----- (0000000000411890) ----------------------------------------------------
void __fastcall camlPervasives__max_53()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 4118AA: variable 'v0' is possibly undefined
// 4118AA: variable 'v1' is possibly undefined

//----- (00000000004118D0) ----------------------------------------------------
__int64 __fastcall camlPervasives__abs_71()
{
  __int64 result; // rax

  if ( result < 1 )
    return 2 - result;
  return result;
}
// 4118D4: variable 'result' is possibly undefined
// 4118D0: using guessed type __int64 __fastcall camlPervasives__abs_71();

//----- (00000000004118F0) ----------------------------------------------------
__int64 __fastcall camlPervasives__lnot_76()
{
  __int64 v0; // rax

  return ~v0 | 1;
}
// 4118F0: variable 'v0' is possibly undefined
// 4118F0: using guessed type __int64 __fastcall camlPervasives__lnot_76();

//----- (0000000000411900) ----------------------------------------------------
__int64 __fastcall camlPervasives___5e_136()
{
  unsigned __int64 v0; // rax
  __int64 v1; // rbx
  unsigned __int64 v2; // rsi
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v9; // [rsp+0h] [rbp-28h]
  __int64 v10; // [rsp+8h] [rbp-20h]
  __int64 v11; // [rsp+10h] [rbp-18h]
  __int64 v12; // [rsp+18h] [rbp-10h]

  v2 = v0;
  v9 = v0;
  v11 = v1;
  v3 = 8LL * (*(_QWORD *)(v0 - 8) >> 10) - 1;
  v10 = 2 * (v3 - *(unsigned __int8 *)(v9 + v3)) + 1;
  v4 = 8LL * (*(_QWORD *)(v1 - 8) >> 10) - 1;
  v5 = v4 - *(unsigned __int8 *)(v1 + v4);
  v12 = 2 * v5 + 1;
  caml_c_call(v10 + 2 * v5, v2);
  v7 = v6;
  caml_blit_string(v9, 1LL, v6, 1LL, v10);
  caml_blit_string(v11, 1LL, v7, v10, v12);
  return v7;
}
// 411900: could not find valid save-restore pair for rbp
// 411904: variable 'v0' is possibly undefined
// 41190B: variable 'v1' is possibly undefined
// 411965: variable 'v6' is possibly undefined

//----- (00000000004119B0) ----------------------------------------------------
__int64 __fastcall camlPervasives__char_of_int_144(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 result; // rax

  if ( result < 1 || result > 511 )
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  return result;
}
// 4119B4: variable 'result' is possibly undefined

//----- (00000000004119D0) ----------------------------------------------------
char *__fastcall camlPervasives__string_of_bool_151()
{
  __int64 v0; // rax

  if ( v0 == 1 )
    return camlPervasives__100;
  else
    return camlPervasives__101;
}
// 4119D4: variable 'v0' is possibly undefined

//----- (00000000004119F0) ----------------------------------------------------
__int64 __fastcall camlPervasives__bool_of_string_153()
{
  _QWORD *v0; // rax
  _QWORD *v1; // rbx
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9

  v1 = v0;
  if ( caml_string_notequal(v0, camlPervasives__99) == 1 )
    return 1LL;
  if ( caml_string_notequal(v1, camlPervasives__98) != 1 )
    camlPervasives__invalid_arg_40((__int64)v1, (__int64)camlPervasives__98, v2, v3, v4, v5);
  return 3LL;
}
// 4119F4: variable 'v0' is possibly undefined
// 411A2C: variable 'v2' is possibly undefined
// 411A2C: variable 'v3' is possibly undefined
// 411A2C: variable 'v4' is possibly undefined
// 411A2C: variable 'v5' is possibly undefined
// 4119F0: using guessed type __int64 __fastcall camlPervasives__bool_of_string_153();

//----- (0000000000411A50) ----------------------------------------------------
void __fastcall camlPervasives__string_of_int_154()
{
  unsigned __int64 v0; // rax

  caml_c_call((__int64)&camlPervasives__96, v0);
}
// 411A65: variable 'v0' is possibly undefined

//----- (0000000000411A70) ----------------------------------------------------
__int64 __fastcall camlPervasives__valid_float_lexem_159(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rsi
  __int64 v9; // rax
  __int64 i; // rdi
  char v12; // [rsp+0h] [rbp-8h]

  v8 = v6;
  v9 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1;
  for ( i = 2 * (v9 - *(unsigned __int8 *)(v8 + v9)) + 1; ; caml_call_gc(i, v8, a3, a4, a5, a6, v12) )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 4343LL;
  v7[1] = camlPervasives__code_begin;
  v7[2] = 3LL;
  v7[3] = v8;
  v7[4] = i;
  return camlPervasives__code_begin();
}
// 411A74: variable 'v6' is possibly undefined
// 411A94: variable 'v7' is possibly undefined
// 411ADA: variable 'a3' is possibly undefined
// 411ADA: variable 'a4' is possibly undefined
// 411ADA: variable 'a5' is possibly undefined
// 411ADA: variable 'a6' is possibly undefined
// 411ADA: variable 'v12' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000411AF0) ----------------------------------------------------
__int64 __fastcall camlPervasives__string_of_float_164()
{
  unsigned __int64 v0; // rax
  __int64 v1; // rsi
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9

  v1 = v0;
  caml_c_call((__int64)camlPervasives__95, v0);
  return camlPervasives__valid_float_lexem_159((__int64)camlPervasives__95, v1, v2, v3, v4, v5);
}
// 411AFB: variable 'v0' is possibly undefined
// 411B0E: variable 'v2' is possibly undefined
// 411B0E: variable 'v3' is possibly undefined
// 411B0E: variable 'v4' is possibly undefined
// 411B0E: variable 'v5' is possibly undefined

//----- (0000000000411B20) ----------------------------------------------------
_QWORD *__fastcall camlPervasives___40_167()
{
  __int64 *v0; // rax
  __int64 v1; // rbx
  _QWORD *v2; // r15
  __int64 v3; // rsi
  __int64 v4; // rdx
  __int64 v5; // rcx
  _QWORD *i; // rdi
  __int64 v7; // r8
  __int64 v8; // r9
  _QWORD *result; // rax
  __int64 v10; // [rsp+0h] [rbp-8h]

  if ( v0 == (__int64 *)1 )
    return (_QWORD *)v1;
  v3 = v0[1];
  v10 = *v0;
  for ( i = camlPervasives___40_167(); ; caml_call_gc((__int64)i, v3, v4, v5, v7, v8, v10) )
  {
    v2 -= 3;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
  }
  result = v2 + 1;
  *v2 = 2048LL;
  v2[1] = v10;
  v2[2] = i;
  return result;
}
// 411B28: variable 'v0' is possibly undefined
// 411B40: variable 'v2' is possibly undefined
// 411B60: variable 'v10' is possibly undefined
// 411B6C: variable 'v1' is possibly undefined
// 411B74: variable 'v4' is possibly undefined
// 411B74: variable 'v5' is possibly undefined
// 411B74: variable 'v7' is possibly undefined
// 411B74: variable 'v8' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000411B80) ----------------------------------------------------
void __fastcall camlPervasives__open_out_gen_199(__int64 a1)
{
  unsigned __int64 v1; // rax
  unsigned __int64 v2; // rsi
  __int64 v3; // rax

  v2 = v1;
  caml_c_call(a1, v1);
  caml_c_call(v3, v2);
}
// 411B84: variable 'v1' is possibly undefined
// 411BA0: variable 'v3' is possibly undefined

//----- (0000000000411BB0) ----------------------------------------------------
void __fastcall camlPervasives__open_out_203()
{
  __int64 v0; // rax

  camlPervasives__open_out_gen_199(v0);
}
// 411BC1: variable 'v0' is possibly undefined

//----- (0000000000411BD0) ----------------------------------------------------
void __fastcall camlPervasives__open_out_bin_205()
{
  __int64 v0; // rax

  camlPervasives__open_out_gen_199(v0);
}
// 411BE1: variable 'v0' is possibly undefined

//----- (0000000000411BF0) ----------------------------------------------------
__int64 __fastcall camlPervasives__flush_all_209(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9

  caml_c_call(1LL, a2);
  return camlPervasives__iter_210(1LL, a2, v2, v3, v4, v5);
}
// 411C12: variable 'v2' is possibly undefined
// 411C12: variable 'v3' is possibly undefined
// 411C12: variable 'v4' is possibly undefined
// 411C12: variable 'v5' is possibly undefined

//----- (0000000000411C20) ----------------------------------------------------
void __fastcall camlPervasives__output_string_215()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 411C55: variable 'v0' is possibly undefined
// 411C55: variable 'v1' is possibly undefined

//----- (0000000000411C60) ----------------------------------------------------
void __fastcall camlPervasives__output_218(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdi

  v8 = a1;
  v9 = a2;
  if ( a1 < 1
    || a2 < 1
    || (v10 = 8LL * (*(_QWORD *)(v7 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v7 + v10),
        a1 = 2 * (v10 - a2) - v9 + 2,
        v8 > a1) )
  {
    camlPervasives__invalid_arg_40(a1, a2, v8, v9, a5, a6);
  }
  caml_c_call(v6, v7);
}
// 411C76: variable 'v7' is possibly undefined
// 411CAA: variable 'v6' is possibly undefined

//----- (0000000000411CD0) ----------------------------------------------------
void __fastcall camlPervasives__output_value_226()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 411CE8: variable 'v0' is possibly undefined
// 411CE8: variable 'v1' is possibly undefined

//----- (0000000000411D00) ----------------------------------------------------
void __fastcall camlPervasives__close_out_233(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // [rsp+0h] [rbp-8h]

  v3 = v2;
  caml_c_call(v2, a2);
  caml_c_call(v3, a2);
}
// 411D04: variable 'v2' is possibly undefined

//----- (0000000000411D30) ----------------------------------------------------
void __fastcall camlPervasives__close_out_noerr_235(__int64 a1, unsigned __int64 a2)
{
  sub_411D40(a1, a2);
  JUMPOUT(0x411D5ALL);
}
// 411D3D: control flows out of bounds to 411D5A

//----- (0000000000411D40) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_411D40(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rdi

  v3 = v2;
  caml_c_call(v2, a2);
  sub_411D6C(v3, a2);
  return 1LL;
}
// 411D6A: positive sp value 10 has been found
// 411D45: variable 'v2' is possibly undefined

//----- (0000000000411D6C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_411D6C(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // [rsp+0h] [rbp-8h]

  caml_c_call(v2, a2);
}
// 411D8C: positive sp value 10 has been found
// 411D7D: variable 'v2' is possibly undefined

//----- (0000000000411D90) ----------------------------------------------------
void __fastcall camlPervasives__open_in_gen_238(__int64 a1)
{
  unsigned __int64 v1; // rax
  unsigned __int64 v2; // rsi
  __int64 v3; // rax

  v2 = v1;
  caml_c_call(a1, v1);
  caml_c_call(v3, v2);
}
// 411D94: variable 'v1' is possibly undefined
// 411DB0: variable 'v3' is possibly undefined

//----- (0000000000411DC0) ----------------------------------------------------
void __fastcall camlPervasives__open_in_242()
{
  __int64 v0; // rax

  camlPervasives__open_in_gen_238(v0);
}
// 411DD1: variable 'v0' is possibly undefined

//----- (0000000000411DE0) ----------------------------------------------------
void __fastcall camlPervasives__open_in_bin_244()
{
  __int64 v0; // rax

  camlPervasives__open_in_gen_238(v0);
}
// 411DF1: variable 'v0' is possibly undefined

//----- (0000000000411E00) ----------------------------------------------------
void __fastcall camlPervasives__input_248(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rdi

  v8 = a1;
  v9 = a2;
  if ( a1 < 1
    || a2 < 1
    || (v10 = 8LL * (*(_QWORD *)(v7 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v7 + v10),
        a1 = 2 * (v10 - a2) - v9 + 2,
        v8 > a1) )
  {
    camlPervasives__invalid_arg_40(a1, a2, v8, v9, a5, a6);
  }
  caml_c_call(v6, v7);
}
// 411E16: variable 'v7' is possibly undefined
// 411E4A: variable 'v6' is possibly undefined

//----- (0000000000411E70) ----------------------------------------------------
__int64 __fastcall camlPervasives__unsafe_really_input_253(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  unsigned __int64 v3; // rbx
  _QWORD *v4; // r15
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // [rsp+0h] [rbp-28h]
  __int64 v13; // [rsp+8h] [rbp-20h]
  __int64 v14; // [rsp+10h] [rbp-18h]

  while ( a2 > 1 )
  {
    v12 = a2;
    v13 = a1;
    v14 = v2;
    v6 = v2;
    caml_c_call(v2, v3);
    if ( v7 == 1 )
    {
      while ( 1 )
      {
        v4 -= 2;
        if ( (unsigned __int64)v4 >= caml_young_limit )
          break;
        caml_call_gc(v6, v3, v8, v9, v10, v11, v12);
      }
      *v4 = 1024LL;
      v4[1] = &caml_exn_End_of_file;
      v7 = caml_raise_exn();
    }
    a2 = v12 - v7 + 1;
    a1 = v13 + v7 - 1;
    v2 = v14;
  }
  return 1LL;
}
// 411E9A: variable 'v2' is possibly undefined
// 411EAC: variable 'v3' is possibly undefined
// 411EB5: variable 'v7' is possibly undefined
// 411EB7: variable 'v4' is possibly undefined
// 411EE8: variable 'v12' is possibly undefined
// 411F07: variable 'v8' is possibly undefined
// 411F07: variable 'v9' is possibly undefined
// 411F07: variable 'v10' is possibly undefined
// 411F07: variable 'v11' is possibly undefined
// 647AF0: using guessed type char *caml_exn_End_of_file;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000411F10) ----------------------------------------------------
__int64 __fastcall camlPervasives__really_input_259(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rbx
  __int64 v7; // rdx

  if ( a1 < 1
    || a2 < 1
    || (v7 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1,
        a4 = *(unsigned __int8 *)(v6 + v7),
        a3 = 2 * (v7 - a4) - a2 + 2,
        a1 > a3) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  }
  return camlPervasives__unsafe_really_input_253(a1, a2);
}
// 411F1C: variable 'v6' is possibly undefined

//----- (0000000000411F60) ----------------------------------------------------
unsigned __int64 __fastcall camlPervasives__input_line_265(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned __int64 v6; // rax
  _QWORD *v7; // r15
  unsigned __int64 i; // rsi
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v10) )
  {
    v7 -= 6;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 5367LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlPervasives__scan_273;
  v7[4] = i;
  v7[5] = &camlPervasives__86;
  return camlPervasives__scan_273((__int64)(v7 + 1), i);
}
// 411F64: variable 'v6' is possibly undefined
// 411F6E: variable 'v7' is possibly undefined
// 411FC6: variable 'a3' is possibly undefined
// 411FC6: variable 'a4' is possibly undefined
// 411FC6: variable 'a5' is possibly undefined
// 411FC6: variable 'a6' is possibly undefined
// 411FC6: variable 'v10' is possibly undefined
// 64D7E0: using guessed type __int64 (__fastcall *camlPervasives__86)();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000411FD0) ----------------------------------------------------
__int64 __fastcall camlPervasives__close_in_noerr_287(__int64 a1, unsigned __int64 a2)
{
  sub_411FE8(a1, a2);
  return 1LL;
}

//----- (0000000000411FE8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_411FE8(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 412006: positive sp value 10 has been found
// 411FF7: variable 'v2' is possibly undefined

//----- (0000000000412010) ----------------------------------------------------
void __fastcall camlPervasives__print_char_290()
{
  unsigned __int64 v0; // rax

  caml_c_call(camlPervasives[23], v0);
}
// 41202C: variable 'v0' is possibly undefined
// 64CDA0: using guessed type _QWORD camlPervasives[84];

//----- (0000000000412040) ----------------------------------------------------
void camlPervasives__print_string_292()
{
  camlPervasives__output_string_215();
}

//----- (0000000000412060) ----------------------------------------------------
void camlPervasives__print_int_294()
{
  camlPervasives__string_of_int_154();
  camlPervasives__output_string_215();
}

//----- (0000000000412090) ----------------------------------------------------
void camlPervasives__print_float_296()
{
  camlPervasives__string_of_float_164();
  camlPervasives__output_string_215();
}

//----- (00000000004120C0) ----------------------------------------------------
void camlPervasives__print_endline_298()
{
  camlPervasives__output_string_215();
  caml_c_call(camlPervasives[23], 0x15uLL);
  caml_c_call(camlPervasives[23], 0x15uLL);
}
// 64CDA0: using guessed type _QWORD camlPervasives[84];

//----- (0000000000412120) ----------------------------------------------------
void camlPervasives__print_newline_300()
{
  caml_c_call(camlPervasives[23], 0x15uLL);
  caml_c_call(camlPervasives[23], 0x15uLL);
}
// 64CDA0: using guessed type _QWORD camlPervasives[84];

//----- (0000000000412170) ----------------------------------------------------
void __fastcall camlPervasives__prerr_char_301()
{
  unsigned __int64 v0; // rax

  caml_c_call(camlPervasives[24], v0);
}
// 41218C: variable 'v0' is possibly undefined
// 64CDA0: using guessed type _QWORD camlPervasives[84];

//----- (00000000004121A0) ----------------------------------------------------
void camlPervasives__prerr_string_303()
{
  camlPervasives__output_string_215();
}

//----- (00000000004121C0) ----------------------------------------------------
void camlPervasives__prerr_int_305()
{
  camlPervasives__string_of_int_154();
  camlPervasives__output_string_215();
}

//----- (00000000004121F0) ----------------------------------------------------
void camlPervasives__prerr_float_307()
{
  camlPervasives__string_of_float_164();
  camlPervasives__output_string_215();
}

//----- (0000000000412220) ----------------------------------------------------
void camlPervasives__prerr_endline_309()
{
  camlPervasives__output_string_215();
  caml_c_call(camlPervasives[24], 0x15uLL);
  caml_c_call(camlPervasives[24], 0x15uLL);
}
// 64CDA0: using guessed type _QWORD camlPervasives[84];

//----- (0000000000412280) ----------------------------------------------------
void camlPervasives__prerr_newline_311()
{
  caml_c_call(camlPervasives[24], 0x15uLL);
  caml_c_call(camlPervasives[24], 0x15uLL);
}
// 64CDA0: using guessed type _QWORD camlPervasives[84];

//----- (00000000004122D0) ----------------------------------------------------
unsigned __int64 __fastcall camlPervasives__read_line_312(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9

  v2 = camlPervasives[23];
  caml_c_call(v2, a2);
  return camlPervasives__input_line_265(v2, a2, v3, v4, v5, v6);
}
// 412300: variable 'v3' is possibly undefined
// 412300: variable 'v4' is possibly undefined
// 412300: variable 'v5' is possibly undefined
// 412300: variable 'v6' is possibly undefined
// 64CDA0: using guessed type _QWORD camlPervasives[84];

//----- (0000000000412310) ----------------------------------------------------
void __fastcall camlPervasives__read_int_313(__int64 a1, unsigned __int64 a2)
{
  __int64 line_312; // rax

  line_312 = camlPervasives__read_line_312(a1, a2);
  caml_c_call(line_312, a2);
}

//----- (0000000000412340) ----------------------------------------------------
void __fastcall camlPervasives__read_float_314(__int64 a1, unsigned __int64 a2)
{
  __int64 line_312; // rax

  line_312 = camlPervasives__read_line_312(a1, a2);
  caml_c_call(line_312, a2);
}

//----- (0000000000412370) ----------------------------------------------------
void __fastcall camlPervasives__fun_519(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 41237E: variable 'v2' is possibly undefined

//----- (0000000000412390) ----------------------------------------------------
void __fastcall camlPervasives__fun_517(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 41239E: variable 'v2' is possibly undefined

//----- (00000000004123B0) ----------------------------------------------------
void __fastcall camlPervasives__fun_515()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 4123C1: variable 'v0' is possibly undefined
// 4123C1: variable 'v1' is possibly undefined

//----- (00000000004123D0) ----------------------------------------------------
void __fastcall camlPervasives__fun_513(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 4123DE: variable 'v2' is possibly undefined

//----- (00000000004123F0) ----------------------------------------------------
void __fastcall camlPervasives__fun_511(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 4123FE: variable 'v2' is possibly undefined

//----- (0000000000412410) ----------------------------------------------------
void __fastcall camlPervasives__fun_509()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 412421: variable 'v0' is possibly undefined
// 412421: variable 'v1' is possibly undefined

//----- (0000000000412430) ----------------------------------------------------
__int64 camlPervasives___5e_5e_336()
{
  camlPervasives___5e_136();
  return camlPervasives___5e_136();
}
// 412430: using guessed type __int64 __fastcall camlPervasives___5e_5e_336();

//----- (0000000000412460) ----------------------------------------------------
__int64 __fastcall camlPervasives__string_of_format_339(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v7; // [rsp+0h] [rbp-18h]
  __int64 v8; // [rsp+8h] [rbp-10h]

  v7 = v2;
  v3 = 8LL * (*(_QWORD *)(v2 - 8) >> 10) - 1;
  v8 = 2 * (v3 - *(unsigned __int8 *)(v7 + v3)) + 1;
  caml_c_call(v8, a2);
  v5 = v4;
  caml_blit_string(v7, 1LL, v4, 1LL, v8);
  return v5;
}
// 412467: variable 'v2' is possibly undefined
// 412499: variable 'v4' is possibly undefined

//----- (00000000004124D0) ----------------------------------------------------
__int64 __fastcall camlPervasives__at_exit_346(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rdi
  __int64 v9; // rbx
  char v11; // [rsp+0h] [rbp-8h]

  v8 = v6;
  v9 = *(_QWORD *)camlPervasives[82];
  while ( 1 )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc(v8, a2, a3, a4, a5, a6, v11);
  }
  *v7 = 4343LL;
  v7[1] = camlPervasives__fun_524;
  v7[2] = 3LL;
  v7[3] = v8;
  v7[4] = v9;
  caml_modify((unsigned __int64 *)camlPervasives[82], (unsigned __int64)(v7 + 1));
  return 1LL;
}
// 4124D4: variable 'v6' is possibly undefined
// 4124E8: variable 'v7' is possibly undefined
// 41253D: variable 'a3' is possibly undefined
// 41253D: variable 'a4' is possibly undefined
// 41253D: variable 'a5' is possibly undefined
// 41253D: variable 'a6' is possibly undefined
// 41253D: variable 'v11' is possibly undefined
// 411580: using guessed type __int64 __fastcall camlPervasives__fun_524();
// 64CDA0: using guessed type _QWORD camlPervasives[84];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000412550) ----------------------------------------------------
__int64 camlPervasives__do_at_exit_349()
{
  return (**(__int64 (***)(void))camlPervasives[82])();
}
// 412550: using guessed type __int64 __fastcall camlPervasives__do_at_exit_349();
// 64CDA0: using guessed type _QWORD camlPervasives[84];

//----- (0000000000412570) ----------------------------------------------------
void __fastcall camlPervasives__exit_350(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // [rsp+0h] [rbp-8h]

  v3 = v2;
  (**(void (***)(void))camlPervasives[82])();
  caml_c_call(v3, a2);
}
// 412574: variable 'v2' is possibly undefined
// 64CDA0: using guessed type _QWORD camlPervasives[84];

//----- (00000000004125B0) ----------------------------------------------------
__int64 __fastcall camlPervasives__entry(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  _QWORD *v6; // r15
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  char v21; // [rsp+0h] [rbp-8h]
  char v22; // [rsp+0h] [rbp-8h]

  camlPervasives[72] = &camlPervasives__84;
  camlPervasives[70] = &camlPervasives__83;
  camlPervasives[69] = &camlPervasives__82;
  camlPervasives[68] = &camlPervasives__81;
  camlPervasives[67] = &camlPervasives__80;
  camlPervasives[66] = &camlPervasives__79;
  camlPervasives[65] = &camlPervasives__78;
  camlPervasives[64] = &camlPervasives__77;
  camlPervasives[60] = &camlPervasives__76;
  camlPervasives[56] = &camlPervasives__75;
  camlPervasives[53] = &camlPervasives__74;
  camlPervasives[52] = &camlPervasives__73;
  camlPervasives[51] = &camlPervasives__72;
  camlPervasives[49] = &camlPervasives__71;
  camlPervasives[48] = &camlPervasives__70;
  camlPervasives[45] = &camlPervasives__69;
  camlPervasives[43] = &camlPervasives__68;
  camlPervasives[1] = &camlPervasives__67;
  camlPervasives[0] = &camlPervasives__66;
  caml_alloc1(a1, a2, a3, a4, a5, a6, v21);
  *v6 = 1024LL;
  v6[1] = camlPervasives__65;
  camlPervasives[2] = v6 + 1;
  camlPervasives[3] = &camlPervasives__64;
  camlPervasives[4] = &camlPervasives__63;
  camlPervasives[5] = &camlPervasives__62;
  camlPervasives[8] = &camlPervasives__61;
  camlPervasives[7] = 0x8000000000000001LL;
  camlPervasives[6] = 0x7FFFFFFFFFFFFFFFLL;
  caml_c_call((__int64)&camlPervasives__60, a2);
  camlPervasives[9] = v7;
  caml_c_call((__int64)&camlPervasives__59, a2);
  camlPervasives[10] = v8;
  caml_c_call((__int64)&camlPervasives__58, a2);
  camlPervasives[11] = v9;
  caml_c_call((__int64)&camlPervasives__57, a2);
  camlPervasives[12] = v10;
  caml_c_call((__int64)&camlPervasives__56, a2);
  camlPervasives[13] = v11;
  caml_c_call((__int64)&camlPervasives__55, a2);
  camlPervasives[14] = v12;
  camlPervasives[15] = &camlPervasives__54;
  camlPervasives[16] = &camlPervasives__53;
  camlPervasives[17] = &camlPervasives__52;
  camlPervasives[18] = &camlPervasives__51;
  camlPervasives[19] = &camlPervasives__50;
  camlPervasives[81] = &camlPervasives__49;
  camlPervasives[78] = &camlPervasives__48;
  camlPervasives[20] = &camlPervasives__47;
  camlPervasives[21] = &camlPervasives__46;
  caml_c_call(1LL, a2);
  camlPervasives[22] = v13;
  caml_c_call(3LL, a2);
  camlPervasives[23] = v14;
  caml_c_call(5LL, a2);
  camlPervasives[24] = v15;
  camlPervasives[42] = &camlPervasives__45;
  camlPervasives[40] = &camlPervasives__44;
  camlPervasives[41] = &camlPervasives__43;
  camlPervasives[44] = &camlPervasives__42;
  camlPervasives[46] = &camlPervasives__41;
  camlPervasives[47] = &camlPervasives__40;
  camlPervasives[50] = &camlPervasives__39;
  camlPervasives[54] = &camlPervasives__38;
  camlPervasives[55] = &camlPervasives__37;
  camlPervasives[59] = &camlPervasives__36;
  camlPervasives[57] = &camlPervasives__35;
  camlPervasives[58] = &camlPervasives__34;
  camlPervasives[62] = &camlPervasives__33;
  camlPervasives[79] = &camlPervasives__32;
  camlPervasives[63] = &camlPervasives__31;
  camlPervasives[61] = &camlPervasives__30;
  camlPervasives[71] = &camlPervasives__29;
  camlPervasives[25] = &camlPervasives__28;
  camlPervasives[26] = &camlPervasives__27;
  camlPervasives[27] = &camlPervasives__26;
  camlPervasives[28] = &camlPervasives__25;
  camlPervasives[29] = &camlPervasives__24;
  camlPervasives[30] = &camlPervasives__23;
  camlPervasives[31] = &camlPervasives__22;
  camlPervasives[32] = &camlPervasives__21;
  camlPervasives[33] = &camlPervasives__20;
  camlPervasives[34] = &camlPervasives__19;
  camlPervasives[35] = &camlPervasives__18;
  camlPervasives[36] = &camlPervasives__17;
  camlPervasives[37] = &camlPervasives__16;
  camlPervasives[38] = &camlPervasives__15;
  camlPervasives[39] = &camlPervasives__14;
  caml_allocN(5LL, a2, v16, v17, v18, v19, v22);
  *v6 = 6144LL;
  v6[1] = &camlPervasives__7;
  v6[2] = &camlPervasives__8;
  v6[3] = &camlPervasives__9;
  v6[4] = &camlPervasives__10;
  v6[5] = &camlPervasives__11;
  v6[6] = &camlPervasives__12;
  camlPervasives[73] = v6 + 1;
  camlPervasives[75] = &camlPervasives__6;
  camlPervasives[74] = &camlPervasives__5;
  v6[7] = 1024LL;
  v6[8] = camlPervasives[44];
  camlPervasives[82] = v6 + 8;
  camlPervasives[77] = &camlPervasives__4;
  camlPervasives[80] = &camlPervasives__3;
  camlPervasives[76] = &camlPervasives__2;
  caml_c_call((__int64)camlPervasives__1, camlPervasives[80]);
  return 1LL;
}
// 41273C: variable 'v21' is possibly undefined
// 412745: variable 'v6' is possibly undefined
// 4127F8: variable 'v7' is possibly undefined
// 412816: variable 'v8' is possibly undefined
// 412834: variable 'v9' is possibly undefined
// 412852: variable 'v10' is possibly undefined
// 412870: variable 'v11' is possibly undefined
// 41288E: variable 'v12' is possibly undefined
// 412966: variable 'v13' is possibly undefined
// 412987: variable 'v14' is possibly undefined
// 4129A8: variable 'v15' is possibly undefined
// 412C5D: variable 'v16' is possibly undefined
// 412C5D: variable 'v17' is possibly undefined
// 412C5D: variable 'v18' is possibly undefined
// 412C5D: variable 'v19' is possibly undefined
// 412C5D: variable 'v22' is possibly undefined
// 64CDA0: using guessed type _QWORD camlPervasives[84];
// 64D040: using guessed type __int64 (__fastcall *camlPervasives__2)();
// 64D058: using guessed type __int64 (__fastcall *camlPervasives__3)();
// 64D070: using guessed type __int64 (__fastcall *camlPervasives__4)();
// 64D088: using guessed type __int64 (__fastcall *camlPervasives__5)();
// 64D0A0: using guessed type __int64 (__fastcall *camlPervasives__6)();
// 64D0C0: using guessed type __int64 (__fastcall *camlPervasives__7)();
// 64D0E0: using guessed type __int64 (__fastcall *camlPervasives__8)();
// 64D0F8: using guessed type __int64 (__fastcall *camlPervasives__9)();
// 64D110: using guessed type __int64 (__fastcall *camlPervasives__10)();
// 64D130: using guessed type __int64 (__fastcall *camlPervasives__11)();
// 64D148: using guessed type __int64 (__fastcall *camlPervasives__12)();
// 64D160: using guessed type __int64 (__fastcall *camlPervasives__14)();
// 64D178: using guessed type __int64 (__fastcall *camlPervasives__15)();
// 64D190: using guessed type __int64 (__fastcall *camlPervasives__16)();
// 64D1A8: using guessed type __int64 (__fastcall *camlPervasives__17)();
// 64D1C0: using guessed type __int64 (__fastcall *camlPervasives__18)();
// 64D1D8: using guessed type __int64 (__fastcall *camlPervasives__19)();
// 64D1F0: using guessed type __int64 (__fastcall *camlPervasives__20)();
// 64D208: using guessed type __int64 (__fastcall *camlPervasives__21)();
// 64D220: using guessed type __int64 (__fastcall *camlPervasives__22)();
// 64D238: using guessed type __int64 (__fastcall *camlPervasives__23)();
// 64D250: using guessed type __int64 (__fastcall *camlPervasives__24)();
// 64D268: using guessed type __int64 (__fastcall *camlPervasives__25)();
// 64D280: using guessed type __int64 (__fastcall *camlPervasives__26)();
// 64D298: using guessed type __int64 (__fastcall *camlPervasives__27)();
// 64D2B0: using guessed type __int64 (__fastcall *camlPervasives__28)();
// 64D2C8: using guessed type __int64 (__fastcall *camlPervasives__29)();
// 64D2E0: using guessed type __int64 (__fastcall *camlPervasives__30)();
// 64D2F8: using guessed type __int64 (__fastcall *camlPervasives__31)();
// 64D318: using guessed type __int64 (__fastcall *camlPervasives__32)();
// 64D338: using guessed type __int64 (__fastcall *camlPervasives__33)();
// 64D358: using guessed type __int64 (__fastcall *camlPervasives__34)();
// 64D370: using guessed type __int64 (__fastcall *camlPervasives__35)();
// 64D388: using guessed type __int64 (__fastcall *camlPervasives__36)();
// 64D3A8: using guessed type __int64 (__fastcall *camlPervasives__37)();
// 64D3C0: using guessed type __int64 (__fastcall *camlPervasives__38)();
// 64D3D8: using guessed type __int64 (__fastcall *camlPervasives__39)();
// 64D3F8: using guessed type __int64 (__fastcall *camlPervasives__40)();
// 64D418: using guessed type __int64 (__fastcall *camlPervasives__41)();
// 64D438: using guessed type __int64 (__fastcall *camlPervasives__42)();
// 64D450: using guessed type __int64 (__fastcall *camlPervasives__43)();
// 64D468: using guessed type __int64 (__fastcall *camlPervasives__44)();
// 64D480: using guessed type __int64 (__fastcall *camlPervasives__45)();
// 64D4A0: using guessed type __int64 (__fastcall *camlPervasives__46)();
// 64D4C0: using guessed type __int64 (__fastcall *camlPervasives__47)();
// 64D4D8: using guessed type __int64 (__fastcall *camlPervasives__48)();
// 64D4F0: using guessed type __int64 (__fastcall *camlPervasives__50)();
// 64D508: using guessed type __int64 (__fastcall *camlPervasives__51)();
// 64D520: using guessed type __int64 (__fastcall *camlPervasives__52)();
// 64D538: using guessed type __int64 (__fastcall *camlPervasives__53)();
// 64D550: using guessed type __int64 (__fastcall *camlPervasives__54)();
// 64D570: using guessed type __int64 (__fastcall *camlPervasives__61)();
// 64D588: using guessed type __int64 (__fastcall *camlPervasives__62)();
// 64D5A0: using guessed type __int64 (__fastcall *camlPervasives__63)();
// 64D5C0: using guessed type __int64 (__fastcall *camlPervasives__64)();
// 64D5E0: using guessed type void (__fastcall __noreturn *camlPervasives__66)();
// 64D5F8: using guessed type void (__fastcall __noreturn *camlPervasives__67)();
// 64D610: using guessed type __int64 (__fastcall *camlPervasives__68)();
// 64D628: using guessed type __int64 (__fastcall *camlPervasives__69)();
// 64D648: using guessed type __int64 (__fastcall *camlPervasives__70)();
// 64D668: using guessed type __int64 (__fastcall *camlPervasives__71)();
// 64D688: using guessed type __int64 (__fastcall *camlPervasives__72)();
// 64D6A8: using guessed type __int64 (__fastcall *camlPervasives__73)();
// 64D6C0: using guessed type __int64 (__fastcall *camlPervasives__74)();
// 64D6D8: using guessed type __int64 (__fastcall *camlPervasives__75)();
// 64D6F8: using guessed type __int64 (__fastcall *camlPervasives__76)();
// 64D710: using guessed type __int64 (__fastcall *camlPervasives__77)();
// 64D728: using guessed type __int64 (__fastcall *camlPervasives__78)();
// 64D740: using guessed type __int64 (__fastcall *camlPervasives__79)();
// 64D758: using guessed type __int64 (__fastcall *camlPervasives__80)();
// 64D778: using guessed type __int64 (__fastcall *camlPervasives__81)();
// 64D790: using guessed type __int64 (__fastcall *camlPervasives__82)();
// 64D7A8: using guessed type __int64 (__fastcall *camlPervasives__83)();
// 64D7C0: using guessed type __int64 (__fastcall *camlPervasives__84)();
// 64D848: using guessed type char **camlPervasives__55;
// 64D860: using guessed type char **camlPervasives__56;
// 64D878: using guessed type char **camlPervasives__57;
// 64D890: using guessed type char **camlPervasives__58;
// 64D8A8: using guessed type char **camlPervasives__59;
// 64D8C0: using guessed type char **camlPervasives__60;

//----- (0000000000412D80) ----------------------------------------------------
__int64 __fastcall camlArray__code_begin(unsigned __int64 a1, double *a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  double *v5; // rbx
  unsigned __int64 v6; // r15
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rbp
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // r12
  unsigned __int64 v14; // rbx
  double *v15; // rdi
  __int64 v17; // rbp
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // r12
  __int64 v20; // rdx
  unsigned __int64 v21; // rbx
  __int64 v22; // [rsp+0h] [rbp-38h]
  __int64 v23; // [rsp+8h] [rbp-30h]
  unsigned __int64 v24; // [rsp+10h] [rbp-28h]
  double *v25; // [rsp+18h] [rbp-20h]
  unsigned __int64 v26; // [rsp+20h] [rbp-18h]
  double *v27; // [rsp+28h] [rbp-10h]

  while ( 1 )
  {
    while ( 1 )
    {
      v23 = v4;
      v27 = v5;
      v24 = a1;
      v25 = a2;
      v26 = a3;
      v22 = a4;
      if ( caml_apply2(*(_QWORD *)(a4 + 24)) > 1 )
        break;
      v11 = v22;
      a1 = *(_QWORD *)(v22 + 48);
      v12 = *(_QWORD *)(a1 - 8);
      if ( (unsigned __int8)v12 == 254LL )
      {
        v13 = v26;
        if ( v12 >> 9 <= v26 )
          goto LABEL_38;
        *(double *)(a1 + 4 * v26 - 4) = *v5;
      }
      else
      {
        v13 = v26;
        if ( v12 >> 9 <= v26 )
          goto LABEL_39;
        caml_modify((unsigned __int64 *)(a1 + 4 * v26 - 4), (unsigned __int64)v5);
      }
      v14 = v23 + 2;
      if ( v23 + 2 >= *(_QWORD *)(v22 + 56) )
        return camlArray__blit_120(
                 *(unsigned __int64 **)(v22 + 48),
                 v13 + 2,
                 *(_QWORD *)(v22 + 64) - v24 + 1,
                 v8,
                 v9,
                 v10);
      a2 = *(double **)(v22 + 32);
      a1 = *((_QWORD *)a2 - 1);
      if ( (unsigned __int8)a1 == 254LL )
      {
        if ( a1 >> 9 <= v14 )
          goto LABEL_36;
        while ( 1 )
        {
          v6 -= 16LL;
          if ( v6 >= caml_young_limit )
            break;
          caml_call_gc(a1, (__int64)a2, v7, v8, v9, v10, v22);
        }
        v15 = (double *)(v6 + 8);
        *(_QWORD *)v6 = 1277LL;
        *(double *)(v6 + 8) = *(double *)((char *)a2 + 4 * v14 - 4);
      }
      else
      {
        if ( a1 >> 9 <= v14 )
          goto LABEL_37;
        v15 = *(double **)((char *)a2 + 4 * v14 - 4);
      }
      a3 = v13 + 2;
      v4 = v23 + 2;
      v5 = v15;
      a1 = v24;
      a2 = v25;
      a4 = v11;
    }
    v17 = v22;
    a1 = *(_QWORD *)(v22 + 48);
    v18 = *(_QWORD *)(a1 - 8);
    if ( (unsigned __int8)v18 == 254LL )
    {
      v19 = v26;
      if ( v18 >> 9 <= v26 )
        goto LABEL_34;
      *(double *)(a1 + 4 * v26 - 4) = *a2;
    }
    else
    {
      v19 = v26;
      if ( v18 >> 9 <= v26 )
        goto LABEL_35;
      caml_modify((unsigned __int64 *)(a1 + 4 * v26 - 4), (unsigned __int64)a2);
    }
    a1 = v24 + 2;
    if ( (signed __int64)(v24 + 2) >= *(_QWORD *)(v22 + 64) )
      return camlArray__blit_120(
               *(unsigned __int64 **)(v22 + 48),
               v19 + 2,
               *(_QWORD *)(v22 + 56) - v23 + 1,
               v8,
               v9,
               v10);
    v20 = *(_QWORD *)(v22 + 40);
    v21 = *(_QWORD *)(v20 - 8);
    if ( (unsigned __int8)v21 == 254LL )
      break;
    if ( v21 >> 9 <= a1 )
      goto LABEL_33;
    a2 = *(double **)(v20 + 4 * a1 - 4);
LABEL_28:
    a3 = v19 + 2;
    v4 = v23;
    v5 = v27;
    a4 = v17;
  }
  if ( v21 >> 9 > a1 )
  {
    while ( 1 )
    {
      v6 -= 16LL;
      if ( v6 >= caml_young_limit )
        break;
      caml_call_gc(a1, (__int64)a2, v20, v8, v9, v10, v22);
    }
    a2 = (double *)(v6 + 8);
    *(_QWORD *)v6 = 1277LL;
    *(double *)(v6 + 8) = *(double *)(v20 + 4 * a1 - 4);
    goto LABEL_28;
  }
  caml_ml_array_bound_error(a1, (unsigned __int64)a2);
LABEL_33:
  caml_ml_array_bound_error(a1, (unsigned __int64)a2);
LABEL_34:
  caml_ml_array_bound_error(a1, (unsigned __int64)a2);
LABEL_35:
  caml_ml_array_bound_error(a1, (unsigned __int64)a2);
LABEL_36:
  caml_ml_array_bound_error(a1, (unsigned __int64)a2);
LABEL_37:
  caml_ml_array_bound_error(a1, (unsigned __int64)a2);
LABEL_38:
  caml_ml_array_bound_error(a1, (unsigned __int64)a2);
LABEL_39:
  caml_ml_array_bound_error(a1, (unsigned __int64)a2);
  return camlArray__size_93();
}
// 412D80: could not find valid save-restore pair for rbp
// 412D80: could not find valid save-restore pair for r12
// 412D84: variable 'v4' is possibly undefined
// 412D8C: variable 'v5' is possibly undefined
// 412E74: variable 'v6' is possibly undefined
// 412EE2: variable 'v8' is possibly undefined
// 412EE2: variable 'v9' is possibly undefined
// 412EE2: variable 'v10' is possibly undefined
// 412FB8: variable 'v20' is possibly undefined
// 413003: variable 'v22' is possibly undefined
// 41300A: variable 'v7' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000413040) ----------------------------------------------------
__int64 __fastcall camlArray__size_93()
{
  __int64 result; // rax
  _QWORD *v1; // rbx

  while ( v1 != (_QWORD *)1 )
  {
    result = result + ((*(_QWORD *)(*v1 - 8LL) >> 9) | 1LL) - 1;
    v1 = (_QWORD *)v1[1];
  }
  return result;
}
// 413044: variable 'v1' is possibly undefined
// 413059: variable 'result' is possibly undefined

//----- (0000000000413070) ----------------------------------------------------
__int64 __fastcall camlArray__fill_98(float a1, __int64 a2, double *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v7; // rax
  __int64 *v8; // rbx
  unsigned __int64 v9; // r15
  __int64 v10; // r12
  __int64 v11; // r13
  __int64 v12; // rbx
  __int64 v13; // rbp
  __int64 v14; // rdi
  __int64 v15; // rax
  __int64 *v17; // [rsp+0h] [rbp-18h]
  __int64 v18; // [rsp+8h] [rbp-10h]

  while ( 1 )
  {
    v10 = v7;
    v11 = a2;
    if ( v8 == (__int64 *)1 )
      break;
    v17 = (__int64 *)v8[1];
    v18 = *v8;
    v12 = 1LL;
    v13 = ((*(_QWORD *)(v18 - 8) >> 9) | 1LL) - 2;
    if ( v13 >= 1 )
    {
      do
      {
        if ( *(unsigned __int8 *)(v18 - 8) == 254LL )
        {
          while ( 1 )
          {
            v9 -= 16LL;
            if ( v9 >= caml_young_limit )
              break;
            caml_call_gc(v18, (__int64)a3, a4, a5, a6, a7, (char)v17);
          }
          a3 = (double *)(v9 + 8);
          *(_QWORD *)v9 = 1277LL;
          *(double *)(v9 + 8) = *(double *)(v18 + 4 * v12 - 4);
        }
        else
        {
          a3 = *(double **)(v18 + 4 * v12 - 4);
        }
        a4 = v10 + v12 - 1;
        v14 = *(_QWORD *)(v11 + 24);
        if ( *(unsigned __int8 *)(v14 - 8) == 254LL )
          *(double *)(v14 + 4 * a4 - 4) = *a3;
        else
          caml_modify((unsigned __int64 *)(v14 + 4 * a4 - 4), (unsigned __int64)a3);
        v15 = v12;
        v12 += 2LL;
      }
      while ( v15 != v13 );
    }
    v7 = v10 + ((*(_QWORD *)(v18 - 8) >> 9) | 1LL) - 1;
    v8 = v17;
    a2 = v11;
  }
  return 1LL;
}
// 413074: variable 'v7' is possibly undefined
// 41307E: variable 'v8' is possibly undefined
// 4130CC: variable 'v9' is possibly undefined
// 413140: variable 'v17' is possibly undefined
// 413158: variable 'a4' is possibly undefined
// 413158: variable 'a5' is possibly undefined
// 413158: variable 'a6' is possibly undefined
// 413158: variable 'a7' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000413170) ----------------------------------------------------
__int64 (__fastcall **__fastcall camlArray__find_init_105(
        double a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7))()
{
  __int64 v7; // rax
  unsigned __int64 v8; // r15
  __int64 v9; // rdx
  double *v10; // rsi
  __int64 v11; // rdi
  char v13; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    if ( v7 == 1 )
      return camlArray__35;
    v9 = *(_QWORD *)(v7 + 8);
    v10 = *(double **)v7;
    v11 = (*(_QWORD *)(*(_QWORD *)v7 - 8LL) >> 9) | 1LL;
    if ( v11 > 1 )
      break;
    v7 = *(_QWORD *)(v7 + 8);
  }
  if ( *((unsigned __int8 *)v10 - 8) == 254LL )
  {
    while ( 1 )
    {
      v8 -= 16LL;
      if ( v8 >= caml_young_limit )
        break;
      caml_call_gc(v11, (__int64)v10, v9, a5, a6, a7, v13);
    }
    *(_QWORD *)v8 = 1277LL;
    a1 = *v10;
    *(double *)(v8 + 8) = a1;
  }
  return (__int64 (__fastcall **)())camlArray__concat_aux_90(*(float *)&a1);
}
// 413178: variable 'v7' is possibly undefined
// 4131A8: variable 'v8' is possibly undefined
// 4131F0: variable 'v9' is possibly undefined
// 4131F0: variable 'a5' is possibly undefined
// 4131F0: variable 'a6' is possibly undefined
// 4131F0: variable 'a7' is possibly undefined
// 4131F0: variable 'v13' is possibly undefined
// 64EA40: using guessed type __int64 (__fastcall *camlArray__35[2])();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000413200) ----------------------------------------------------
unsigned __int64 __fastcall camlArray__tolist_150(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // r8
  __int64 v11; // rcx
  __int64 v12; // rsi
  char v13; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    v9 = v6;
    if ( v6 < 1 )
      break;
    v11 = *(_QWORD *)(a1 + 24);
    v12 = *(unsigned __int8 *)(v11 - 8);
    if ( v12 == 254 )
    {
      while ( 1 )
      {
        v8 -= 16LL;
        if ( v8 >= caml_young_limit )
          break;
        caml_call_gc(a1, v12, a3, v11, v9, a6, v13);
      }
      a3 = v8 + 8;
      *(_QWORD *)v8 = 1277LL;
      *(double *)(v8 + 8) = *(double *)(v11 + 4 * v9 - 4);
    }
    else
    {
      a3 = *(_QWORD *)(v11 + 4 * v6 - 4);
    }
    while ( 1 )
    {
      v8 -= 24LL;
      if ( v8 >= caml_young_limit )
        break;
      caml_call_gc(a1, v12, a3, v11, v9, a6, v13);
    }
    *(_QWORD *)v8 = 2048LL;
    *(_QWORD *)(v8 + 8) = a3;
    *(_QWORD *)(v8 + 16) = v7;
    v6 = v9 - 2;
    v7 = v8 + 8;
  }
  return v7;
}
// 413204: variable 'v6' is possibly undefined
// 41320D: variable 'v7' is possibly undefined
// 413234: variable 'v8' is possibly undefined
// 413250: variable 'v11' is possibly undefined
// 413250: variable 'v9' is possibly undefined
// 413277: variable 'a3' is possibly undefined
// 41328D: variable 'a6' is possibly undefined
// 41328D: variable 'v13' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004132A0) ----------------------------------------------------
__int64 __fastcall camlArray__fill_162(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // r12
  __int64 v4; // r13
  double *v5; // rsi
  __int64 v6; // rbx

  while ( 1 )
  {
    v3 = v1;
    if ( v2 == 1 )
      break;
    v4 = *(_QWORD *)(v2 + 8);
    v5 = *(double **)v2;
    v6 = *(_QWORD *)(a1 + 24);
    if ( *(unsigned __int8 *)(v6 - 8) == 254LL )
      *(double *)(v6 + 4 * v1 - 4) = *v5;
    else
      caml_modify((unsigned __int64 *)(v6 + 4 * v1 - 4), (unsigned __int64)v5);
    v1 = v3 + 2;
    v2 = v4;
  }
  return *(_QWORD *)(a1 + 24);
}
// 4132A4: variable 'v1' is possibly undefined
// 4132AE: variable 'v2' is possibly undefined

//----- (0000000000413300) ----------------------------------------------------
__int64 __fastcall camlArray__maxson_182(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  double *v8; // r15
  __int64 v9; // rcx
  unsigned __int64 v10; // rsi
  __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  __int64 v13; // rdx
  unsigned __int64 v14; // rax
  __int64 v15; // rcx
  unsigned __int64 v16; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  unsigned __int64 v21; // rbx
  __int64 v22; // rdx
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  unsigned __int64 v26; // rax
  __int64 result; // rax
  unsigned __int64 v28; // rcx
  __int64 v29; // rdx
  unsigned __int64 v30; // rbx
  __int64 v31; // rcx
  unsigned __int64 v32; // rdx
  __int64 v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // r8
  __int64 v36; // r9
  char v37; // [rsp+0h] [rbp-18h]
  __int64 v38; // [rsp+0h] [rbp-18h]
  __int64 v39; // [rsp+0h] [rbp-18h]
  unsigned __int64 *v40; // [rsp+8h] [rbp-10h]
  __int64 v41; // [rsp+8h] [rbp-10h]
  __int64 v42; // [rsp+10h] [rbp-8h]

  v9 = v6;
  v10 = 3 * v7;
  v42 = 3 * v7;
  while ( 1 )
  {
    v8 -= 2;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(a1, v10, a3, v9, a5, a6, v37);
  }
  v11 = (__int64)(v8 + 1);
  *(_QWORD *)v8 = 1024LL;
  *((_QWORD *)v8 + 1) = v10;
  if ( (__int64)(v10 + 4) < v9 )
  {
    v40 = (unsigned __int64 *)(v8 + 1);
    v38 = a1;
    v12 = v10 + 2;
    v13 = *(_QWORD *)(a1 + 32);
    v14 = *(_QWORD *)(v13 - 8);
    if ( (unsigned __int8)v14 == 254LL )
    {
      if ( v14 >> 9 <= v12 )
      {
LABEL_69:
        caml_ml_array_bound_error(a1, v10);
        goto LABEL_70;
      }
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(a1, v10, v13, v12, a5, a6, v38);
      }
      *(_QWORD *)v8 = 1277LL;
      v8[1] = *(double *)(v13 + 4 * v12 - 4);
    }
    else if ( v14 >> 9 <= v12 )
    {
LABEL_70:
      caml_ml_array_bound_error(a1, v10);
      return camlArray__trickledown_187((double *)a1, v10, v33, v34, v35, v36);
    }
    v15 = *(_QWORD *)(a1 + 32);
    v16 = *(_QWORD *)(v15 - 8);
    v17 = (unsigned __int8)v16;
    if ( (unsigned __int8)v16 == 254LL )
    {
      if ( v16 >> 9 <= v10 )
      {
LABEL_67:
        caml_ml_array_bound_error(a1, v10);
        goto LABEL_68;
      }
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(a1, v10, v17, v15, a5, a6, v38);
      }
      *(_QWORD *)v8 = 1277LL;
      v8[1] = *(double *)(v15 + 12 * v7 - 4);
    }
    else if ( v16 >> 9 <= v10 )
    {
LABEL_68:
      caml_ml_array_bound_error(a1, v10);
      goto LABEL_69;
    }
    if ( caml_apply2(*(_QWORD *)(a1 + 24)) < 1 )
      *v40 = v42 + 2;
    v21 = v42 + 4;
    a1 = v38;
    v22 = *(_QWORD *)(v38 + 32);
    v23 = *(_QWORD *)(v22 - 8);
    v10 = (unsigned __int8)v23;
    if ( (unsigned __int8)v23 == 254LL )
    {
      if ( v23 >> 9 <= v21 )
      {
LABEL_65:
        caml_ml_array_bound_error(a1, v10);
        goto LABEL_66;
      }
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(a1, 254LL, v22, v18, v19, v20, v38);
      }
      v19 = (__int64)(v8 + 1);
      *(_QWORD *)v8 = 1277LL;
      v8[1] = *(double *)(v22 + 4 * v21 - 4);
    }
    else if ( v23 >> 9 <= v21 )
    {
LABEL_66:
      caml_ml_array_bound_error(a1, v10);
      goto LABEL_67;
    }
    v24 = *v40;
    v25 = *(_QWORD *)(a1 + 32);
    v26 = *(_QWORD *)(v25 - 8);
    v10 = (unsigned __int8)v26;
    if ( (unsigned __int8)v26 != 254LL )
    {
      if ( v26 >> 9 > v24 )
      {
LABEL_30:
        if ( caml_apply2(*(_QWORD *)(a1 + 24)) < 1 )
          *v40 = v42 + 4;
        return *v40;
      }
      goto LABEL_64;
    }
    if ( v26 >> 9 > v24 )
    {
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(a1, 254LL, v25, v24, v19, v20, v38);
      }
      *(_QWORD *)v8 = 1277LL;
      v8[1] = *(double *)(v25 + 4 * v24 - 4);
      goto LABEL_30;
    }
LABEL_63:
    caml_ml_array_bound_error(a1, v10);
LABEL_64:
    caml_ml_array_bound_error(a1, v10);
    goto LABEL_65;
  }
  v41 = v7;
  v39 = v9;
  if ( (__int64)(v10 + 2) < v9 )
  {
    v28 = v10 + 2;
    v29 = *(_QWORD *)(a1 + 32);
    v30 = *(_QWORD *)(v29 - 8);
    if ( (unsigned __int8)v30 == 254LL )
    {
      if ( v30 >> 9 <= v28 )
      {
LABEL_61:
        caml_ml_array_bound_error(a1, v10);
        goto LABEL_62;
      }
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(a1, v10, v29, v28, a5, a6, v39);
      }
      *(_QWORD *)v8 = 1277LL;
      v8[1] = *(double *)(v29 + 4 * v28 - 4);
    }
    else if ( v30 >> 9 <= v28 )
    {
LABEL_62:
      caml_ml_array_bound_error(a1, v10);
      goto LABEL_63;
    }
    v31 = *(_QWORD *)(a1 + 32);
    v32 = *(_QWORD *)(v31 - 8);
    if ( (unsigned __int8)v32 == 254LL )
    {
      if ( v32 >> 9 > v10 )
      {
        while ( 1 )
        {
          v8 -= 2;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(a1, v10, v32, v31, a5, a6, v39);
        }
        *(_QWORD *)v8 = 1277LL;
        v8[1] = *(double *)(v31 + 4 * v10 - 4);
LABEL_46:
        a1 = *(_QWORD *)(a1 + 24);
        if ( caml_apply2(a1) < 1 )
          return v42 + 2;
        goto LABEL_48;
      }
      caml_ml_array_bound_error(a1, v10);
    }
    else if ( v32 >> 9 > v10 )
    {
      goto LABEL_46;
    }
    caml_ml_array_bound_error(a1, v10);
    goto LABEL_61;
  }
LABEL_48:
  result = v42;
  if ( v42 >= v39 )
  {
    while ( 1 )
    {
      v8 -= 3;
      if ( (unsigned __int64)v8 >= caml_young_limit )
      {
        *(_QWORD *)v8 = 2048LL;
        v8[1] = *(double *)&camlArray[22];
        *((_QWORD *)v8 + 2) = v41;
        caml_raise_exn();
      }
      caml_call_gc(a1, v10, v11, v9, a5, a6, v39);
    }
  }
  return result;
}
// 413304: variable 'v6' is possibly undefined
// 413312: variable 'v7' is possibly undefined
// 41331B: variable 'v8' is possibly undefined
// 413348: variable 'v9' is possibly undefined
// 4133BD: variable 'v13' is possibly undefined
// 4133BD: variable 'v12' is possibly undefined
// 413425: variable 'v15' is possibly undefined
// 413458: variable 'v38' is possibly undefined
// 4134B9: variable 'v22' is possibly undefined
// 41352D: variable 'v25' is possibly undefined
// 41352D: variable 'v24' is possibly undefined
// 4135E4: variable 'v29' is possibly undefined
// 4135E4: variable 'v28' is possibly undefined
// 413650: variable 'v31' is possibly undefined
// 413684: variable 'v39' is possibly undefined
// 4136C7: variable 'v11' is possibly undefined
// 4136C7: variable 'a5' is possibly undefined
// 4136C7: variable 'a6' is possibly undefined
// 4136CE: variable 'v32' is possibly undefined
// 4136E2: variable 'v19' is possibly undefined
// 4136E2: variable 'v20' is possibly undefined
// 4136EC: variable 'v18' is possibly undefined
// 4136F6: variable 'v17' is possibly undefined
// 41370A: variable 'a3' is possibly undefined
// 41370A: variable 'v37' is possibly undefined
// 41374C: variable 'v33' is possibly undefined
// 41374C: variable 'v34' is possibly undefined
// 41374C: variable 'v35' is possibly undefined
// 41374C: variable 'v36' is possibly undefined
// 64E620: using guessed type _QWORD camlArray[25];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000413750) ----------------------------------------------------
__int64 __fastcall camlArray__trickledown_187(double *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rbx
  double *v14; // rsi
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rdi
  __int64 v17; // rdx
  __int64 v18; // rbp
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rdi
  unsigned __int64 v21; // rdi
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // [rsp+0h] [rbp-28h]
  __int64 v28; // [rsp+8h] [rbp-20h]
  double *v29; // [rsp+10h] [rbp-18h]
  unsigned __int64 v30; // [rsp+18h] [rbp-10h]
  unsigned __int64 v31; // [rsp+20h] [rbp-8h]

  while ( 1 )
  {
    v28 = v6;
    v30 = v7;
    v29 = a1;
    v27 = a2;
    v9 = camlArray__maxson_182(*(_QWORD *)(a2 + 40), a2, a3, a4, a5, a6);
    v31 = v9;
    v13 = a2;
    v14 = *(double **)(a2 + 32);
    v15 = *((_QWORD *)v14 - 1);
    v16 = (unsigned __int8)v15;
    if ( (unsigned __int8)v15 == 254LL )
    {
      if ( v15 >> 9 <= v9 )
        goto LABEL_34;
      while ( 1 )
      {
        v8 -= 16LL;
        if ( v8 >= caml_young_limit )
          break;
        caml_call_gc(254LL, (__int64)v14, v9, v10, v11, v12, v27);
      }
      *(_QWORD *)v8 = 1277LL;
      *(double *)(v8 + 8) = *(double *)((char *)v14 + 4 * v9 - 4);
    }
    else if ( v15 >> 9 <= v9 )
    {
      goto LABEL_35;
    }
    if ( caml_apply2(*(_QWORD *)(v13 + 24)) <= 1 )
      break;
    v18 = v27;
    v16 = *(_QWORD *)(v27 + 32);
    v19 = *(_QWORD *)(v16 - 8);
    if ( (unsigned __int8)v19 == 254LL )
    {
      v7 = v31;
      if ( v19 >> 9 <= v31 )
        goto LABEL_32;
      while ( 1 )
      {
        v8 -= 16LL;
        if ( v8 >= caml_young_limit )
          break;
        caml_call_gc(v16, (__int64)v14, v17, a4, a5, a6, v27);
      }
      v14 = (double *)(v8 + 8);
      *(_QWORD *)v8 = 1277LL;
      *(double *)(v8 + 8) = *(double *)(v16 + 4 * v31 - 4);
    }
    else
    {
      v7 = v31;
      if ( v19 >> 9 <= v31 )
        goto LABEL_33;
      v14 = *(double **)(v16 + 4 * v31 - 4);
    }
    a3 = *(_QWORD *)(v18 + 32);
    v20 = *(_QWORD *)(a3 - 8);
    if ( (unsigned __int8)v20 == 254LL )
    {
      v16 = v20 >> 9;
      if ( v16 <= v30 )
        goto LABEL_30;
      *(double *)(a3 + 4 * v30 - 4) = *v14;
    }
    else
    {
      v16 = v20 >> 9;
      if ( v16 <= v30 )
        goto LABEL_31;
      caml_modify((unsigned __int64 *)(a3 + 4 * v30 - 4), (unsigned __int64)v14);
    }
    v6 = v28;
    a1 = v29;
    a2 = v18;
  }
  v14 = *(double **)(v27 + 32);
  v21 = *((_QWORD *)v14 - 1);
  if ( (unsigned __int8)v21 == 254LL )
  {
    v16 = v21 >> 9;
    if ( v16 > v30 )
    {
      *(double *)((char *)v14 + 4 * v30 - 4) = *v29;
      return 1LL;
    }
    caml_ml_array_bound_error(v16, (unsigned __int64)v14);
  }
  else
  {
    v16 = v21 >> 9;
    if ( v16 > v30 )
    {
      caml_modify((unsigned __int64 *)((char *)v14 + 4 * v30 - 4), (unsigned __int64)v29);
      return 1LL;
    }
  }
  caml_ml_array_bound_error(v16, (unsigned __int64)v14);
LABEL_30:
  caml_ml_array_bound_error(v16, (unsigned __int64)v14);
LABEL_31:
  caml_ml_array_bound_error(v16, (unsigned __int64)v14);
LABEL_32:
  caml_ml_array_bound_error(v16, (unsigned __int64)v14);
LABEL_33:
  caml_ml_array_bound_error(v16, (unsigned __int64)v14);
LABEL_34:
  caml_ml_array_bound_error(v16, (unsigned __int64)v14);
LABEL_35:
  caml_ml_array_bound_error(v16, (unsigned __int64)v14);
  return camlArray__trickle_192((double *)v16, (__int64)v14, v23, v24, v25, v26);
}
// 413750: could not find valid save-restore pair for rbx
// 413750: could not find valid save-restore pair for rbp
// 413754: variable 'v6' is possibly undefined
// 413759: variable 'v7' is possibly undefined
// 41376B: variable 'a3' is possibly undefined
// 41376B: variable 'a4' is possibly undefined
// 41376B: variable 'a5' is possibly undefined
// 41376B: variable 'a6' is possibly undefined
// 4137B9: variable 'v8' is possibly undefined
// 4137D9: variable 'v9' is possibly undefined
// 4137FB: variable 'v27' is possibly undefined
// 41393D: variable 'v17' is possibly undefined
// 413947: variable 'v10' is possibly undefined
// 413947: variable 'v11' is possibly undefined
// 413947: variable 'v12' is possibly undefined
// 41397A: variable 'v23' is possibly undefined
// 41397A: variable 'v24' is possibly undefined
// 41397A: variable 'v25' is possibly undefined
// 41397A: variable 'v26' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000413980) ----------------------------------------------------
__int64 __fastcall camlArray__trickle_192(double *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  double **v6; // rax
  double *v7; // rdi
  unsigned __int64 v8; // rsi
  __int64 v9; // rdi
  unsigned __int64 v10; // rax
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9

  v6 = (double **)sub_413A14(a1, a2, a3, a4, a5, a6);
  v7 = (double *)camlArray[22];
  if ( *v6 == v7 )
  {
    v8 = (unsigned __int64)v6[1];
    v9 = *(_QWORD *)(a2 + 24);
    v10 = *(_QWORD *)(v9 - 8);
    if ( (unsigned __int8)v10 == 254LL )
    {
      if ( v10 >> 9 > v8 )
      {
        *(double *)(v9 + 4 * v8 - 4) = *a1;
        return 1LL;
      }
      caml_ml_array_bound_error(v9, v8);
    }
    else if ( v10 >> 9 > v8 )
    {
      caml_modify((unsigned __int64 *)(v9 + 4 * v8 - 4), (unsigned __int64)a1);
      return 1LL;
    }
    caml_ml_array_bound_error(v9, v8);
    return camlArray__bubbledown_197(v9, (double *)v8, v16, v17, v18, v19);
  }
  else
  {
    caml_raise_exn();
    return sub_413A14(v7, a2, v12, v13, v14, v15);
  }
}
// 413A12: variable 'v12' is possibly undefined
// 413A12: variable 'v13' is possibly undefined
// 413A12: variable 'v14' is possibly undefined
// 413A12: variable 'v15' is possibly undefined
// 413A38: variable 'v16' is possibly undefined
// 413A38: variable 'v17' is possibly undefined
// 413A38: variable 'v18' is possibly undefined
// 413A38: variable 'v19' is possibly undefined
// 64E620: using guessed type _QWORD camlArray[25];

//----- (0000000000413A14) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_413A14(double *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return camlArray__trickledown_187(a1, *(_QWORD *)(a2 + 32), a3, a4, a5, a6);
}
// 413A2C: positive sp value 20 has been found

//----- (0000000000413A40) ----------------------------------------------------
__int64 __fastcall camlArray__bubbledown_197(__int64 a1, double *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // rbp
  __int64 v10; // rdx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rdi
  unsigned __int64 v13; // rdi
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  char v19; // [rsp+0h] [rbp-18h]
  __int64 v20; // [rsp+8h] [rbp-10h]
  unsigned __int64 v21; // [rsp+10h] [rbp-8h]

  while ( 1 )
  {
    v20 = v6;
    v21 = v7;
    v19 = a1;
    v7 = camlArray__maxson_182(*(_QWORD *)(a1 + 32), (__int64)a2, a3, a4, a5, a6);
    v9 = a1;
    v10 = *(_QWORD *)(a1 + 24);
    v11 = *(_QWORD *)(v10 - 8);
    v12 = (unsigned __int8)v11;
    if ( (unsigned __int8)v11 == 254LL )
    {
      if ( v11 >> 9 <= v7 )
        goto LABEL_16;
      while ( 1 )
      {
        v8 -= 16LL;
        if ( v8 >= caml_young_limit )
          break;
        caml_call_gc(254LL, (__int64)a2, v10, a4, a5, a6, v19);
      }
      a2 = (double *)(v8 + 8);
      *(_QWORD *)v8 = 1277LL;
      *(double *)(v8 + 8) = *(double *)(v10 + 4 * v7 - 4);
    }
    else
    {
      if ( v11 >> 9 <= v7 )
        goto LABEL_17;
      a2 = *(double **)(v10 + 4 * v7 - 4);
    }
    a3 = *(_QWORD *)(v9 + 24);
    v13 = *(_QWORD *)(a3 - 8);
    if ( (unsigned __int8)v13 == 254LL )
      break;
    v12 = v13 >> 9;
    if ( v12 <= v21 )
      goto LABEL_15;
    caml_modify((unsigned __int64 *)(a3 + 4 * v21 - 4), (unsigned __int64)a2);
LABEL_12:
    v6 = v20;
    a1 = v9;
  }
  v12 = v13 >> 9;
  if ( v12 > v21 )
  {
    *(double *)(a3 + 4 * v21 - 4) = *a2;
    goto LABEL_12;
  }
  caml_ml_array_bound_error(v12, (unsigned __int64)a2);
LABEL_15:
  caml_ml_array_bound_error(v12, (unsigned __int64)a2);
LABEL_16:
  caml_ml_array_bound_error(v12, (unsigned __int64)a2);
LABEL_17:
  caml_ml_array_bound_error(v12, (unsigned __int64)a2);
  return camlArray__bubble_201(v12, a2, v14, v15, v16, v17);
}
// 413A40: could not find valid save-restore pair for rbp
// 413A44: variable 'v6' is possibly undefined
// 413A49: variable 'v7' is possibly undefined
// 413A56: variable 'a3' is possibly undefined
// 413A56: variable 'a4' is possibly undefined
// 413A56: variable 'a5' is possibly undefined
// 413A56: variable 'a6' is possibly undefined
// 413AA1: variable 'v8' is possibly undefined
// 413ABD: variable 'v10' is possibly undefined
// 413B21: variable 'v19' is possibly undefined
// 413B3F: variable 'v14' is possibly undefined
// 413B3F: variable 'v15' is possibly undefined
// 413B3F: variable 'v16' is possibly undefined
// 413B3F: variable 'v17' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000413B40) ----------------------------------------------------
__int64 __fastcall camlArray__bubble_201(__int64 a1, double *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  __int64 v7; // rdi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9

  v6 = (_QWORD *)sub_413B70(a1, a2, a3, a4, a5, a6);
  v7 = camlArray[22];
  if ( *v6 == v7 )
    return v6[1];
  caml_raise_exn();
  return sub_413B70(v7, a2, v9, v10, v11, v12);
}
// 413B6E: variable 'v9' is possibly undefined
// 413B6E: variable 'v10' is possibly undefined
// 413B6E: variable 'v11' is possibly undefined
// 413B6E: variable 'v12' is possibly undefined
// 64E620: using guessed type _QWORD camlArray[25];

//----- (0000000000413B70) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_413B70(__int64 a1, double *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return camlArray__bubbledown_197(*(_QWORD *)(a1 + 24), a2, a3, a4, a5, a6);
}
// 413B88: positive sp value 10 has been found

//----- (0000000000413B90) ----------------------------------------------------
__int64 __fastcall camlArray__trickleup_205(
        unsigned __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 *v7; // rbx
  double *v8; // r15
  __int64 v9; // rsi
  __int64 v10; // rax
  __int64 v11; // rdx
  __int128 v12; // rtt
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rsi
  __int64 v17; // rdx
  __int64 v18; // rcx
  unsigned __int64 *v19; // rbp
  unsigned __int64 v20; // rax
  __int64 v21; // rbx
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rdi
  unsigned __int64 v24; // rbx
  unsigned __int64 v26; // rdi
  __int64 v27; // rdx
  __int64 v28; // rcx
  unsigned __int64 v29; // r8
  __int64 v30; // r9
  unsigned __int64 *v31; // [rsp+0h] [rbp-28h]
  unsigned __int64 *v32; // [rsp+8h] [rbp-20h]
  unsigned __int64 v33; // [rsp+10h] [rbp-18h]
  unsigned __int64 v34; // [rsp+18h] [rbp-10h]

  while ( 1 )
  {
    v9 = v6;
    v12 = (v6 - 2) >> 1;
    v10 = ((v6 - 2) >> 1) / 3;
    v11 = v12 % 3;
    v13 = 2 * v10 + 1;
    if ( v9 == v13 )
    {
      while ( 1 )
      {
        v8 -= 3;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc((__int64)a1, v9, v11, v13, a5, a6, (char)v31);
      }
      *(_QWORD *)v8 = 2048LL;
      *((_QWORD *)v8 + 1) = &caml_exn_Assert_failure;
      *((_QWORD *)v8 + 2) = &camlArray__34;
      caml_raise_exn();
    }
    else
    {
      v34 = 2 * v10 + 1;
      v31 = a1;
      v32 = v7;
      v33 = v9;
    }
    v14 = a1[4];
    v15 = *(_QWORD *)(v14 - 8);
    v16 = (unsigned __int8)v15;
    if ( (unsigned __int8)v15 == 254LL )
    {
      if ( v15 >> 9 <= v13 )
        goto LABEL_48;
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc((__int64)a1, 254LL, v14, v13, a5, a6, (char)v31);
      }
      *(_QWORD *)v8 = 1277LL;
      v8[1] = *(double *)(v14 + 4 * v13 - 4);
    }
    else if ( v15 >> 9 <= v13 )
    {
      goto LABEL_49;
    }
    if ( caml_apply2(a1[3]) >= 1 )
    {
      v16 = v31[4];
      v26 = *(_QWORD *)(v16 - 8);
      if ( (unsigned __int8)v26 == 254LL )
      {
        a1 = (unsigned __int64 *)(v26 >> 9);
        if ( (unsigned __int64)a1 > v33 )
        {
          *(double *)(v16 + 4 * v33 - 4) = *(double *)v32;
          return 1LL;
        }
        caml_ml_array_bound_error((__int64)a1, v16);
      }
      else
      {
        a1 = (unsigned __int64 *)(v26 >> 9);
        if ( (unsigned __int64)a1 > v33 )
        {
          caml_modify((unsigned __int64 *)(v16 + 4 * v33 - 4), (unsigned __int64)v32);
          return 1LL;
        }
      }
      caml_ml_array_bound_error((__int64)a1, v16);
      goto LABEL_42;
    }
    v19 = v31;
    a1 = (unsigned __int64 *)v31[4];
    v20 = *(a1 - 1);
    if ( (unsigned __int8)v20 == 254LL )
    {
      v21 = v34;
      if ( v20 >> 9 <= v34 )
        goto LABEL_46;
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc((__int64)a1, v16, v17, v18, a5, a6, (char)v31);
      }
      v16 = (unsigned __int64)(v8 + 1);
      *(_QWORD *)v8 = 1277LL;
      v8[1] = *(double *)((char *)a1 + 4 * v34 - 4);
    }
    else
    {
      v21 = v34;
      if ( v20 >> 9 <= v34 )
        goto LABEL_47;
      v16 = *(unsigned __int64 *)((char *)a1 + 4 * v34 - 4);
    }
    v22 = v19[4];
    v23 = *(_QWORD *)(v22 - 8);
    if ( (unsigned __int8)v23 == 254LL )
    {
      a1 = (unsigned __int64 *)(v23 >> 9);
      if ( (unsigned __int64)a1 <= v33 )
        goto LABEL_44;
      *(double *)(v22 + 4 * v33 - 4) = *(double *)v16;
    }
    else
    {
      a1 = (unsigned __int64 *)(v23 >> 9);
      if ( (unsigned __int64)a1 <= v33 )
        goto LABEL_45;
      caml_modify((unsigned __int64 *)(v22 + 4 * v33 - 4), v16);
    }
    if ( v21 <= 1 )
      break;
    v6 = v21;
    v7 = v32;
    a1 = v19;
  }
  a1 = (unsigned __int64 *)v19[4];
  v24 = *(a1 - 1);
  if ( (unsigned __int8)v24 != 254LL )
  {
    if ( v24 >> 9 > 1 )
    {
      caml_modify(a1, (unsigned __int64)v32);
      return 1LL;
    }
    goto LABEL_43;
  }
  if ( v24 >> 9 > 1 )
  {
    *a1 = *v32;
    return 1LL;
  }
LABEL_42:
  caml_ml_array_bound_error((__int64)a1, v16);
LABEL_43:
  caml_ml_array_bound_error((__int64)a1, v16);
LABEL_44:
  caml_ml_array_bound_error((__int64)a1, v16);
LABEL_45:
  caml_ml_array_bound_error((__int64)a1, v16);
LABEL_46:
  caml_ml_array_bound_error((__int64)a1, v16);
LABEL_47:
  caml_ml_array_bound_error((__int64)a1, v16);
LABEL_48:
  caml_ml_array_bound_error((__int64)a1, v16);
LABEL_49:
  caml_ml_array_bound_error((__int64)a1, v16);
  return camlArray__merge_218((__int64)a1, v16, v27, v28, v29, v30);
}
// 413B90: could not find valid save-restore pair for rbp
// 413B94: variable 'v6' is possibly undefined
// 413BC0: variable 'v7' is possibly undefined
// 413BCC: variable 'v8' is possibly undefined
// 413C2A: variable 'v13' is possibly undefined
// 413C65: variable 'v14' is possibly undefined
// 413C82: variable 'v31' is possibly undefined
// 413CA5: variable 'v34' is possibly undefined
// 413D1D: variable 'v33' is possibly undefined
// 413D55: variable 'v32' is possibly undefined
// 413E2D: variable 'v17' is possibly undefined
// 413E2D: variable 'v18' is possibly undefined
// 413E2D: variable 'a5' is possibly undefined
// 413E2D: variable 'a6' is possibly undefined
// 413E41: variable 'v11' is possibly undefined
// 413E7E: variable 'v27' is possibly undefined
// 413E7E: variable 'v28' is possibly undefined
// 413E7E: variable 'v29' is possibly undefined
// 413E7E: variable 'v30' is possibly undefined
// 647C48: using guessed type char *caml_exn_Assert_failure;
// 64EA08: using guessed type char *camlArray__34;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000413E80) ----------------------------------------------------
__int64 __fastcall camlArray__merge_218(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 a6)
{
  unsigned __int64 v6; // rax
  __int64 v7; // rbx
  double *v8; // r15
  unsigned __int64 v9; // r11
  unsigned __int64 v10; // r10
  double *v12; // rsi
  __int64 v13; // rbx
  __int64 v14; // rcx
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rax
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  char v22; // [rsp+0h] [rbp-8h]

  v9 = v6;
  v10 = a2;
  v12 = (double *)(v6 + v7 - 1);
  v13 = v10 + a3 - 1;
  while ( 1 )
  {
    v8 -= 10;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(a1, (__int64)v12, a3, a4, a5, a6, v22);
  }
  v14 = (__int64)(v8 + 1);
  *(_QWORD *)v8 = 9463LL;
  *((_QWORD *)v8 + 1) = caml_curry5;
  *((_QWORD *)v8 + 2) = 11LL;
  *((_QWORD *)v8 + 3) = camlArray__code_begin;
  v8[4] = *(double *)(a6 + 24);
  v8[5] = *(double *)(a6 + 32);
  *((_QWORD *)v8 + 6) = a1;
  *((_QWORD *)v8 + 7) = a4;
  *((_QWORD *)v8 + 8) = v12;
  *((_QWORD *)v8 + 9) = v13;
  v15 = *(_QWORD *)(a1 - 8);
  if ( (unsigned __int8)v15 == 254LL )
  {
    if ( v15 >> 9 <= v10 )
    {
LABEL_21:
      caml_ml_array_bound_error(a1, (unsigned __int64)v12);
      goto LABEL_22;
    }
    while ( 1 )
    {
      v8 -= 2;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(a1, (__int64)v12, a3, v14, a5, a6, v22);
    }
    v12 = v8 + 1;
    *(_QWORD *)v8 = 1277LL;
    v8[1] = *(double *)(a1 + 4 * v10 - 4);
LABEL_9:
    a1 = *(_QWORD *)(a6 + 32);
    v16 = *(_QWORD *)(a1 - 8);
    if ( (unsigned __int8)v16 == 254LL )
    {
      if ( v16 >> 9 > v9 )
      {
        while ( 1 )
        {
          v8 -= 2;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(a1, (__int64)v12, a3, v14, a5, a6, v22);
        }
        *(_QWORD *)v8 = 1277LL;
        v8[1] = *(double *)(a1 + 4 * v9 - 4);
        return camlArray__code_begin(v10, v12, a5, v14);
      }
      caml_ml_array_bound_error(a1, (unsigned __int64)v12);
    }
    else if ( v16 >> 9 > v9 )
    {
      return camlArray__code_begin(v10, v12, a5, v14);
    }
    caml_ml_array_bound_error(a1, (unsigned __int64)v12);
    goto LABEL_21;
  }
  if ( v15 >> 9 > v10 )
  {
    v12 = *(double **)(a1 + 4 * v10 - 4);
    goto LABEL_9;
  }
LABEL_22:
  caml_ml_array_bound_error(a1, (unsigned __int64)v12);
  return camlArray__isortto_236(a1, (__int64)v12, v18, v19, v20, v21);
}
// 413E84: variable 'v6' is possibly undefined
// 413E8D: variable 'v7' is possibly undefined
// 413E97: variable 'v8' is possibly undefined
// 413ED4: variable 'a6' is possibly undefined
// 413F12: variable 'v10' is possibly undefined
// 413F7A: variable 'v9' is possibly undefined
// 413FC1: variable 'a5' is possibly undefined
// 413FC1: variable 'v14' is possibly undefined
// 413FC6: variable 'a3' is possibly undefined
// 413FC6: variable 'v22' is possibly undefined
// 413FD7: variable 'a4' is possibly undefined
// 413FF6: variable 'v18' is possibly undefined
// 413FF6: variable 'v19' is possibly undefined
// 413FF6: variable 'v20' is possibly undefined
// 413FF6: variable 'v21' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000414000) ----------------------------------------------------
__int64 __fastcall camlArray__isortto_236(
        signed __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // rcx
  __int64 v10; // rsi
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rdi
  unsigned __int64 *v15; // rbp
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rax
  __int64 v21; // rdi
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // [rsp+0h] [rbp-48h]
  __int64 v28; // [rsp+8h] [rbp-40h]
  __int64 v29; // [rsp+10h] [rbp-38h]
  double *v32; // [rsp+28h] [rbp-20h]
  unsigned __int64 *v33; // [rsp+30h] [rbp-18h]
  __int64 v34; // [rsp+38h] [rbp-10h]

  v9 = 1LL;
  v10 = a2 - 2;
  if ( v10 < 1 )
    return 1LL;
  v29 = v10;
  v28 = 1LL;
  v34 = v7;
  v27 = v6;
  while ( 2 )
  {
    v11 = v27 + v9 - 1;
    v12 = *(_QWORD *)(a3 + 32);
    v13 = *(_QWORD *)(v12 - 8);
    v14 = (unsigned __int8)v13;
    if ( (unsigned __int8)v13 == 254LL )
    {
      if ( v13 >> 9 > v11 )
      {
        while ( 1 )
        {
          v8 -= 16LL;
          if ( v8 >= caml_young_limit )
            break;
          caml_call_gc(254LL, v12, v11, v9, a5, a6, v27);
        }
        *(_QWORD *)v8 = 1277LL;
        *(double *)(v8 + 8) = *(double *)(v12 + 4 * v11 - 4);
        v32 = (double *)(v8 + 8);
        goto LABEL_9;
      }
LABEL_50:
      caml_ml_array_bound_error(v14, v12);
    }
    else if ( v13 >> 9 > v11 )
    {
      v32 = *(double **)(v12 + 4 * v11 - 4);
LABEL_9:
      while ( 1 )
      {
        v8 -= 16LL;
        if ( v8 >= caml_young_limit )
          break;
        caml_call_gc(v14, v12, v11, v9, a5, a6, v27);
      }
      v15 = (unsigned __int64 *)(v8 + 8);
      v33 = (unsigned __int64 *)(v8 + 8);
      *(_QWORD *)v8 = 1024LL;
      *(_QWORD *)(v8 + 8) = a1 + v9 - 3;
      while ( (__int64)*v15 >= a1 )
      {
        v12 = *v15;
        v16 = *(_QWORD *)(v7 - 8);
        v14 = (unsigned __int8)v16;
        if ( (unsigned __int8)v16 == 254LL )
        {
          if ( v16 >> 9 <= v12 )
            goto LABEL_48;
          while ( 1 )
          {
            v8 -= 16LL;
            if ( v8 >= caml_young_limit )
              break;
            caml_call_gc(254LL, v12, v11, v9, a5, a6, v27);
          }
          *(_QWORD *)v8 = 1277LL;
          *(double *)(v8 + 8) = *(double *)(v7 + 4 * v12 - 4);
        }
        else if ( v16 >> 9 <= v12 )
        {
          goto LABEL_49;
        }
        if ( caml_apply2(*(_QWORD *)(a3 + 24)) <= 1 )
          break;
        v15 = v33;
        v17 = *v33;
        v7 = v34;
        v18 = *(_QWORD *)(v34 - 8);
        v14 = (unsigned __int8)v18;
        if ( (unsigned __int8)v18 == 254LL )
        {
          if ( v18 >> 9 <= v17 )
            goto LABEL_46;
          while ( 1 )
          {
            v8 -= 16LL;
            if ( v8 >= caml_young_limit )
              break;
            caml_call_gc(254LL, v12, v17, v9, a5, a6, v27);
          }
          v12 = v8 + 8;
          *(_QWORD *)v8 = 1277LL;
          *(double *)(v8 + 8) = *(double *)(v34 + 4 * v17 - 4);
        }
        else
        {
          if ( v18 >> 9 <= v17 )
            goto LABEL_47;
          v12 = *(_QWORD *)(v34 + 4 * v17 - 4);
        }
        v11 = *v33 + 2;
        v19 = *(_QWORD *)(v34 - 8);
        v14 = (unsigned __int8)v19;
        if ( (unsigned __int8)v19 == 254LL )
        {
          if ( v19 >> 9 <= v11 )
            goto LABEL_44;
          *(double *)(v34 + 4 * v11 - 4) = *(double *)v12;
        }
        else
        {
          if ( v19 >> 9 <= v11 )
            goto LABEL_45;
          caml_modify((unsigned __int64 *)(v34 + 4 * v11 - 4), v12);
        }
        *v33 -= 2LL;
      }
      v12 = *v33 + 2;
      v7 = v34;
      v20 = *(_QWORD *)(v34 - 8);
      v14 = (unsigned __int8)v20;
      if ( (unsigned __int8)v20 == 254LL )
      {
        if ( v20 >> 9 > v12 )
        {
          *(double *)(v34 + 4 * v12 - 4) = *v32;
LABEL_36:
          v21 = v28;
          v9 = v28 + 2;
          v28 += 2LL;
          if ( v21 != v29 )
            continue;
          return 1LL;
        }
        caml_ml_array_bound_error(254LL, v12);
      }
      else if ( v20 >> 9 > v12 )
      {
        caml_modify((unsigned __int64 *)(v34 + 4 * v12 - 4), (unsigned __int64)v32);
        goto LABEL_36;
      }
      caml_ml_array_bound_error(v14, v12);
LABEL_44:
      caml_ml_array_bound_error(v14, v12);
LABEL_45:
      caml_ml_array_bound_error(v14, v12);
LABEL_46:
      caml_ml_array_bound_error(v14, v12);
LABEL_47:
      caml_ml_array_bound_error(v14, v12);
LABEL_48:
      caml_ml_array_bound_error(v14, v12);
LABEL_49:
      caml_ml_array_bound_error(v14, v12);
      goto LABEL_50;
    }
    break;
  }
  caml_ml_array_bound_error(v14, v12);
  return camlArray__sortto_244(v14, v12, v23, v24, v25, v26);
}
// 41402C: variable 'v7' is possibly undefined
// 414031: variable 'v6' is possibly undefined
// 414039: variable 'v27' is possibly undefined
// 414085: variable 'v8' is possibly undefined
// 4140A5: variable 'v11' is possibly undefined
// 4140DE: variable 'v9' is possibly undefined
// 4141E5: variable 'v17' is possibly undefined
// 4142D7: variable 'a5' is possibly undefined
// 4142D7: variable 'a6' is possibly undefined
// 414332: variable 'v23' is possibly undefined
// 414332: variable 'v24' is possibly undefined
// 414332: variable 'v25' is possibly undefined
// 414332: variable 'v26' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000414340) ----------------------------------------------------
__int64 __fastcall camlArray__sortto_244(
        unsigned __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v15; // [rsp+8h] [rbp-30h]
  __int64 v16; // [rsp+18h] [rbp-20h]
  __int64 v17; // [rsp+20h] [rbp-18h]

  if ( a2 <= 11 )
    return camlArray__isortto_236(a1, a2, *(_QWORD *)(a3 + 40), a3, v6, a6);
  v17 = v6;
  v10 = (a2 >> 1) + 1;
  if ( a2 >> 1 >= 0 )
    v10 = a2 >> 1;
  v15 = 2 * (v10 >> 1) + 1;
  v16 = a2 - 2 * (v10 >> 1);
  camlArray__sortto_244(a1 + 2 * (v10 >> 1), v16, a3, a3, v6, a6);
  camlArray__sortto_244(v17 + v16 - 1, v15, a3, v11, v12, v13);
  return camlArray__merge_218(v7, a1 + v15 - 1, v16, v7, a1, *(_QWORD *)(a3 + 32));
}
// 414340: could not find valid save-restore pair for rbx
// 41435B: variable 'v6' is possibly undefined
// 4143CD: variable 'v11' is possibly undefined
// 4143CD: variable 'v12' is possibly undefined
// 4143CD: variable 'v13' is possibly undefined
// 414404: variable 'v7' is possibly undefined

//----- (0000000000414410) ----------------------------------------------------
void *__fastcall camlArray__init_65()
{
  __int64 v0; // rax
  __int64 (**v1)(void); // rbx
  unsigned __int64 v3; // rsi
  __int64 v4; // rax
  __int64 v5; // rbx
  double *v6; // rax
  __int64 v7; // rbp
  __int64 v8; // [rsp+0h] [rbp-28h]
  __int64 v9; // [rsp+0h] [rbp-28h]
  __int64 (**v10)(void); // [rsp+8h] [rbp-20h]
  __int64 v11; // [rsp+10h] [rbp-18h]
  __int64 v12; // [rsp+18h] [rbp-10h]

  if ( v0 == 1 )
    return &camlArray__33;
  v10 = v1;
  v8 = v0;
  v3 = (*v1)();
  caml_c_call(v8, v3);
  v5 = v4;
  if ( v8 - 2 >= 3 )
  {
    v11 = v8 - 2;
    v12 = 3LL;
    v9 = v4;
    do
    {
      v6 = (double *)(*v10)();
      v5 = v9;
      v7 = v12;
      if ( *(unsigned __int8 *)(v9 - 8) == 254LL )
        *(double *)(v9 + 4 * v12 - 4) = *v6;
      else
        caml_modify((unsigned __int64 *)(v9 + 4 * v12 - 4), (unsigned __int64)v6);
      v12 += 2LL;
    }
    while ( v7 != v11 );
  }
  return (void *)v5;
}
// 414418: variable 'v0' is possibly undefined
// 414428: variable 'v1' is possibly undefined
// 414450: variable 'v4' is possibly undefined

//----- (00000000004144E0) ----------------------------------------------------
__int64 __fastcall camlArray__make_matrix_70(unsigned __int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 v4; // rbp
  __int64 v5; // rbx
  unsigned __int64 v6; // rax
  __int64 v8; // [rsp+0h] [rbp-28h]
  __int64 v9; // [rsp+0h] [rbp-28h]
  __int64 v10; // [rsp+8h] [rbp-20h]
  __int64 v11; // [rsp+18h] [rbp-10h]
  __int64 v12; // [rsp+20h] [rbp-8h]

  v8 = v1;
  v10 = v2;
  caml_c_call(v1, (unsigned __int64)&camlArray__32);
  v4 = v3;
  if ( v8 - 2 >= 1 )
  {
    v12 = v8 - 2;
    v9 = 1LL;
    v11 = v3;
    do
    {
      caml_c_call(v10, a1);
      v5 = v9;
      v4 = v11;
      caml_modify((unsigned __int64 *)(v11 + 4 * v9 - 4), v6);
      v9 += 2LL;
    }
    while ( v5 != v12 );
  }
  return v4;
}
// 4144E4: variable 'v1' is possibly undefined
// 4144E8: variable 'v2' is possibly undefined
// 414508: variable 'v3' is possibly undefined
// 414554: variable 'v6' is possibly undefined

//----- (0000000000414580) ----------------------------------------------------
void *__fastcall camlArray__copy_77(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  double **v6; // rax
  unsigned __int64 v7; // r15
  double *v8; // rbx
  __int64 v9; // rdi
  double *v11; // rsi
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rax
  __int64 v17; // rbp
  __int64 v18; // rbx
  __int64 v19; // r12
  __int64 v20; // rax
  __int64 v21; // [rsp+0h] [rbp-18h]
  __int64 v22; // [rsp+8h] [rbp-10h]

  v8 = (double *)v6;
  v9 = ((unsigned __int64)*(v6 - 1) >> 9) | 1;
  if ( v9 == 1 )
    return &camlArray__31;
  v21 = ((unsigned __int64)*(v6 - 1) >> 9) | 1;
  v22 = (__int64)v6;
  if ( *((unsigned __int8 *)v6 - 8) == 254LL )
  {
    while ( 1 )
    {
      v7 -= 16LL;
      if ( v7 >= caml_young_limit )
        break;
      caml_call_gc(v9, a2, a3, a4, a5, a6, v21);
    }
    v11 = (double *)(v7 + 8);
    *(_QWORD *)v7 = 1277LL;
    *(double *)(v7 + 8) = *v8;
  }
  else
  {
    v11 = *v6;
  }
  caml_c_call(v9, (unsigned __int64)v11);
  v17 = v16;
  v18 = 3LL;
  v19 = v21 - 2;
  if ( v21 - 2 >= 3 )
  {
    do
    {
      if ( *(unsigned __int8 *)(v22 - 8) == 254LL )
      {
        while ( 1 )
        {
          v7 -= 16LL;
          if ( v7 >= caml_young_limit )
            break;
          caml_call_gc(v22, (__int64)v11, v12, v13, v14, v15, v21);
        }
        v11 = (double *)(v7 + 8);
        *(_QWORD *)v7 = 1277LL;
        *(double *)(v7 + 8) = *(double *)(v22 + 4 * v18 - 4);
      }
      else
      {
        v11 = *(double **)(v22 + 4 * v18 - 4);
      }
      if ( *(unsigned __int8 *)(v17 - 8) == 254LL )
        *(double *)(v17 + 4 * v18 - 4) = *v11;
      else
        caml_modify((unsigned __int64 *)(v17 + 4 * v18 - 4), (unsigned __int64)v11);
      v20 = v18;
      v18 += 2LL;
    }
    while ( v20 != v19 );
  }
  return (void *)v17;
}
// 414584: variable 'v6' is possibly undefined
// 4145C4: variable 'v7' is possibly undefined
// 4145F8: variable 'v16' is possibly undefined
// 414606: variable 'v21' is possibly undefined
// 414686: variable 'v12' is possibly undefined
// 414686: variable 'v13' is possibly undefined
// 414686: variable 'v14' is possibly undefined
// 414686: variable 'v15' is possibly undefined
// 41468D: variable 'a3' is possibly undefined
// 41468D: variable 'a4' is possibly undefined
// 41468D: variable 'a5' is possibly undefined
// 41468D: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004146A0) ----------------------------------------------------
void *__fastcall camlArray__append_82(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  double *v6; // rax
  double *v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v12; // rdi
  double *v13; // rsi
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rax
  __int64 v19; // rbp
  __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rbx
  __int64 v23; // rdi
  __int64 v24; // rdi
  __int64 v25; // [rsp+0h] [rbp-28h]
  __int64 v26; // [rsp+0h] [rbp-28h]
  __int64 v27; // [rsp+8h] [rbp-20h]
  __int64 v28; // [rsp+10h] [rbp-18h]
  __int64 v29; // [rsp+18h] [rbp-10h]

  v9 = (*((_QWORD *)v6 - 1) >> 9) | 1LL;
  v10 = (*((_QWORD *)v7 - 1) >> 9) | 1LL;
  if ( v9 == 1 )
  {
    if ( v10 == 1 )
      return &camlArray__30;
    v25 = (*((_QWORD *)v7 - 1) >> 9) | 1LL;
    v28 = 1LL;
    v27 = (__int64)v7;
    v29 = (__int64)v6;
  }
  else
  {
    v25 = (*((_QWORD *)v7 - 1) >> 9) | 1LL;
    v28 = (*((_QWORD *)v6 - 1) >> 9) | 1LL;
    v27 = (__int64)v7;
    v29 = (__int64)v6;
  }
  if ( v9 > 1 )
    v7 = v6;
  v12 = *((unsigned __int8 *)v7 - 8);
  if ( v12 == 254 )
  {
    while ( 1 )
    {
      v8 -= 16LL;
      if ( v8 >= caml_young_limit )
        break;
      caml_call_gc(v12, a2, v10, v9, a5, a6, v25);
    }
    v13 = (double *)(v8 + 8);
    *(_QWORD *)v8 = 1277LL;
    *(double *)(v8 + 8) = *v7;
  }
  else
  {
    v13 = *(double **)v7;
  }
  caml_c_call(v9 + v10 - 1, (unsigned __int64)v13);
  v19 = v18;
  v20 = 1LL;
  if ( v28 - 2 >= 1 )
  {
    do
    {
      if ( *(unsigned __int8 *)(v29 - 8) == 254LL )
      {
        while ( 1 )
        {
          v8 -= 16LL;
          if ( v8 >= caml_young_limit )
            break;
          caml_call_gc(v29, (__int64)v13, v14, v15, v16, v17, v25);
        }
        v13 = (double *)(v8 + 8);
        *(_QWORD *)v8 = 1277LL;
        *(double *)(v8 + 8) = *(double *)(v29 + 4 * v20 - 4);
      }
      else
      {
        v13 = *(double **)(v29 + 4 * v20 - 4);
      }
      if ( *(unsigned __int8 *)(v19 - 8) == 254LL )
        *(double *)(v19 + 4 * v20 - 4) = *v13;
      else
        caml_modify((unsigned __int64 *)(v19 + 4 * v20 - 4), (unsigned __int64)v13);
      v21 = v20;
      v20 += 2LL;
    }
    while ( v21 != v28 - 2 );
  }
  v22 = 1LL;
  if ( v25 - 2 >= 1 )
  {
    v26 = v25 - 2;
    do
    {
      if ( *(unsigned __int8 *)(v27 - 8) == 254LL )
      {
        while ( 1 )
        {
          v8 -= 16LL;
          if ( v8 >= caml_young_limit )
            break;
          caml_call_gc(v27, (__int64)v13, v14, v15, v16, v17, v26);
        }
        v13 = (double *)(v8 + 8);
        *(_QWORD *)v8 = 1277LL;
        *(double *)(v8 + 8) = *(double *)(v27 + 4 * v22 - 4);
      }
      else
      {
        v13 = *(double **)(v27 + 4 * v22 - 4);
      }
      v23 = v22 + v28 - 1;
      if ( *(unsigned __int8 *)(v19 - 8) == 254LL )
        *(double *)(v19 + 4 * v23 - 4) = *v13;
      else
        caml_modify((unsigned __int64 *)(v19 + 4 * v23 - 4), (unsigned __int64)v13);
      v24 = v22;
      v22 += 2LL;
    }
    while ( v24 != v26 );
  }
  return (void *)v19;
}
// 4146A4: variable 'v6' is possibly undefined
// 4146B0: variable 'v7' is possibly undefined
// 41471C: variable 'v8' is possibly undefined
// 414744: variable 'v9' is possibly undefined
// 414744: variable 'v10' is possibly undefined
// 414755: variable 'v18' is possibly undefined
// 4147ED: variable 'v25' is possibly undefined
// 41487C: variable 'v26' is possibly undefined
// 414886: variable 'v14' is possibly undefined
// 414886: variable 'v15' is possibly undefined
// 414886: variable 'v16' is possibly undefined
// 414886: variable 'v17' is possibly undefined
// 414897: variable 'a5' is possibly undefined
// 414897: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004148B0) ----------------------------------------------------
__int64 __fastcall camlArray__concat_aux_90(float a1)
{
  unsigned __int64 v1; // rax
  _QWORD *v2; // r15
  __int64 v3; // rdi
  double *v4; // rsi
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rax
  __int64 v10; // rbx
  unsigned __int64 v12; // [rsp+0h] [rbp-18h]
  __int64 i; // [rsp+0h] [rbp-18h]

  v12 = v1;
  v3 = camlArray__size_93();
  v4 = (double *)v12;
  caml_c_call(v3, v12);
  v10 = v9;
  for ( i = v9; ; caml_call_gc(v3, (__int64)v4, v5, v6, v7, v8, i) )
  {
    v2 -= 5;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
  }
  *v2 = 4343LL;
  v2[1] = caml_curry2;
  v2[2] = 5LL;
  v2[3] = camlArray__fill_98;
  v2[4] = v10;
  camlArray__fill_98(a1, (__int64)(v2 + 1), v4, v5, v6, v7, v8);
  return i;
}
// 4148B4: variable 'v1' is possibly undefined
// 4148E3: variable 'v9' is possibly undefined
// 4148EA: variable 'v2' is possibly undefined
// 414933: variable 'v5' is possibly undefined
// 414933: variable 'v6' is possibly undefined
// 414933: variable 'v7' is possibly undefined
// 414933: variable 'v8' is possibly undefined
// 414938: variable 'i' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000414950) ----------------------------------------------------
__int64 (__fastcall **__fastcall camlArray__concat_103(
        double a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7))()
{
  __int64 v7; // rax
  _QWORD *v8; // r15
  __int64 i; // rdi
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v7; ; caml_call_gc(i, a3, a4, a5, a6, a7, v11) )
  {
    v8 -= 4;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 3319LL;
  v8[1] = camlArray__find_init_105;
  v8[2] = 3LL;
  v8[3] = i;
  return camlArray__find_init_105(a1, i, a3, a4, a5, a6, a7);
}
// 414954: variable 'v7' is possibly undefined
// 414957: variable 'v8' is possibly undefined
// 414990: variable 'a4' is possibly undefined
// 414990: variable 'a5' is possibly undefined
// 414990: variable 'a6' is possibly undefined
// 414990: variable 'a7' is possibly undefined
// 414995: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004149A0) ----------------------------------------------------
void *__fastcall camlArray__sub_108(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // rsi
  unsigned __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rax
  __int64 v17; // rbp
  __int64 v18; // rbx
  __int64 v19; // rsi
  double *v20; // rsi
  __int64 v21; // rdi
  __int64 v22; // [rsp+0h] [rbp-18h]
  __int64 v23; // [rsp+0h] [rbp-18h]
  __int64 v24; // [rsp+8h] [rbp-10h]
  __int64 v25; // [rsp+10h] [rbp-8h]

  v9 = v6;
  if ( v7 < 1 || a1 < 1 || v7 > ((*(_QWORD *)(v6 - 8) >> 9) | 1LL) - a1 + 1 )
    camlPervasives__invalid_arg_40(a1, v6, a3, a4, a5, a6);
  if ( a1 == 1 )
    return &camlArray__28;
  v22 = a1;
  v24 = v7;
  v25 = v6;
  if ( *(unsigned __int8 *)(v6 - 8) == 254LL )
  {
    while ( 1 )
    {
      v8 -= 16LL;
      if ( v8 >= caml_young_limit )
        break;
      caml_call_gc(a1, v9, a3, a4, a5, a6, v22);
    }
    v11 = v8 + 8;
    *(_QWORD *)v8 = 1277LL;
    *(double *)(v8 + 8) = *(double *)(v9 + 4 * v7 - 4);
  }
  else
  {
    v11 = *(_QWORD *)(v6 + 4 * v7 - 4);
  }
  caml_c_call(a1, v11);
  v17 = v16;
  v18 = 3LL;
  if ( v22 - 2 >= 3 )
  {
    v23 = v22 - 2;
    do
    {
      v19 = v24 + v18 - 1;
      if ( *(unsigned __int8 *)(v25 - 8) == 254LL )
      {
        while ( 1 )
        {
          v8 -= 16LL;
          if ( v8 >= caml_young_limit )
            break;
          caml_call_gc(v25, v19, v12, v13, v14, v15, v23);
        }
        *(_QWORD *)v8 = 1277LL;
        *(double *)(v8 + 8) = *(double *)(v25 + 4 * v19 - 4);
        v20 = (double *)(v8 + 8);
      }
      else
      {
        v20 = *(double **)(v25 + 4 * v19 - 4);
      }
      if ( *(unsigned __int8 *)(v17 - 8) == 254LL )
        *(double *)(v17 + 4 * v18 - 4) = *v20;
      else
        caml_modify((unsigned __int64 *)(v17 + 4 * v18 - 4), (unsigned __int64)v20);
      v21 = v18;
      v18 += 2LL;
    }
    while ( v21 != v23 );
  }
  return (void *)v17;
}
// 4149A4: variable 'v6' is possibly undefined
// 4149AB: variable 'v7' is possibly undefined
// 414A0C: variable 'v8' is possibly undefined
// 414A45: variable 'v16' is possibly undefined
// 414A53: variable 'v22' is possibly undefined
// 414AEE: variable 'v23' is possibly undefined
// 414B0C: variable 'v12' is possibly undefined
// 414B0C: variable 'v13' is possibly undefined
// 414B0C: variable 'v14' is possibly undefined
// 414B0C: variable 'v15' is possibly undefined
// 414B16: variable 'a3' is possibly undefined
// 414B16: variable 'a4' is possibly undefined
// 414B16: variable 'a5' is possibly undefined
// 414B16: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000414B20) ----------------------------------------------------
__int64 __fastcall camlArray__fill_114(__int64 a1, double *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rbp
  __int64 v9; // r13
  __int64 v10; // rbx
  __int64 v11; // rdi

  v8 = v6;
  if ( v7 < 1 || a1 < 1 || v7 > ((*(_QWORD *)(v6 - 8) >> 9) | 1LL) - a1 + 1 )
    camlPervasives__invalid_arg_40(a1, (__int64)a2, a3, a4, a5, a6);
  v9 = v7;
  v10 = v7 + a1 - 3;
  if ( v9 <= v10 )
  {
    do
    {
      if ( *(unsigned __int8 *)(v8 - 8) == 254LL )
        *(double *)(v8 + 4 * v9 - 4) = *a2;
      else
        caml_modify((unsigned __int64 *)(v8 + 4 * v9 - 4), (unsigned __int64)a2);
      v11 = v9;
      v9 += 2LL;
    }
    while ( v11 != v10 );
  }
  return 1LL;
}
// 414B24: variable 'v6' is possibly undefined
// 414B2E: variable 'v7' is possibly undefined

//----- (0000000000414BC0) ----------------------------------------------------
__int64 __fastcall camlArray__blit_120(
        unsigned __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // rbp
  unsigned __int64 *v10; // r13
  __int64 v11; // r12
  __int64 v12; // rbx
  __int64 v13; // rbx
  __int64 v14; // rbx
  __int64 v16; // rdi
  __int64 v17; // rbx
  __int64 v18; // rbx
  __int64 v19; // rbx
  __int64 v20; // [rsp+0h] [rbp-28h]
  __int64 v21; // [rsp+0h] [rbp-28h]
  __int64 v22; // [rsp+8h] [rbp-20h]
  __int64 v23; // [rsp+8h] [rbp-20h]
  __int64 v24; // [rsp+10h] [rbp-18h]
  __int64 v25; // [rsp+18h] [rbp-10h]

  v9 = v6;
  v10 = a1;
  v11 = a2;
  if ( a3 < 1
    || v7 < 1
    || v7 > ((*(_QWORD *)(v6 - 8) >> 9) | 1LL) - a3 + 1
    || a2 < 1
    || a2 > (__int64)(((*(a1 - 1) >> 9) | 1) - a3 + 1) )
  {
    camlPervasives__invalid_arg_40((__int64)a1, a2, a3, a4, a5, a6);
  }
  if ( v7 >= a2 )
  {
    v25 = 1LL;
    v24 = a3 - 2;
    if ( a3 - 2 >= 1 )
    {
      v23 = v7;
      v21 = v6;
      do
      {
        v16 = v23 + v25 - 1;
        v17 = v21;
        if ( *(unsigned __int8 *)(v21 - 8) == 254LL )
        {
          while ( 1 )
          {
            v8 -= 16LL;
            if ( v8 >= caml_young_limit )
              break;
            caml_call_gc(v16, a2, a3, a4, a5, a6, v21);
          }
          *(_QWORD *)v8 = 1277LL;
          *(double *)(v8 + 8) = *(double *)(v17 + 4 * v16 - 4);
          a2 = v8 + 8;
        }
        else
        {
          a2 = *(_QWORD *)(v21 + 4 * v16 - 4);
        }
        v18 = v11 + v25 - 1;
        if ( *((unsigned __int8 *)v10 - 8) == 254LL )
          *(unsigned __int64 *)((char *)v10 + 4 * v18 - 4) = *(unsigned __int64 *)a2;
        else
          caml_modify((unsigned __int64 *)((char *)v10 + 4 * v18 - 4), a2);
        v19 = v25;
        v25 += 2LL;
      }
      while ( v19 != v24 );
    }
    return 1LL;
  }
  else
  {
    v20 = a3 - 2;
    if ( a3 - 2 >= 1 )
    {
      v22 = v7;
      do
      {
        v12 = v22 + v20 - 1;
        if ( *(unsigned __int8 *)(v9 - 8) == 254LL )
        {
          while ( 1 )
          {
            v8 -= 16LL;
            if ( v8 >= caml_young_limit )
              break;
            caml_call_gc((__int64)a1, a2, a3, a4, a5, a6, v20);
          }
          *(_QWORD *)v8 = 1277LL;
          *(double *)(v8 + 8) = *(double *)(v9 + 4 * v12 - 4);
          a2 = v8 + 8;
        }
        else
        {
          a2 = *(_QWORD *)(v9 + 4 * v12 - 4);
        }
        v13 = v11 + v20 - 1;
        if ( *((unsigned __int8 *)v10 - 8) == 254LL )
        {
          *(unsigned __int64 *)((char *)v10 + 4 * v13 - 4) = *(unsigned __int64 *)a2;
        }
        else
        {
          a1 = (unsigned __int64 *)((char *)v10 + 4 * v13 - 4);
          caml_modify(a1, a2);
        }
        v14 = v20;
        v20 -= 2LL;
      }
      while ( v14 != 1 );
    }
    return 1LL;
  }
}
// 414BC4: variable 'v6' is possibly undefined
// 414BDB: variable 'v7' is possibly undefined
// 414C68: variable 'v8' is possibly undefined
// 414C99: variable 'v20' is possibly undefined
// 414D2C: variable 'v21' is possibly undefined
// 414DE0: variable 'a3' is possibly undefined
// 414DE0: variable 'a4' is possibly undefined
// 414DE0: variable 'a5' is possibly undefined
// 414DE0: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000414E00) ----------------------------------------------------
__int64 __fastcall camlArray__iter_128(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  void (**v6)(void); // rax
  __int64 v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // rdi
  __int64 v10; // rsi
  __int64 v11; // rbx
  __int64 v12; // rbx
  __int64 v14; // [rsp+0h] [rbp-28h]
  void (**v15)(void); // [rsp+8h] [rbp-20h]
  __int64 v16; // [rsp+10h] [rbp-18h]
  __int64 v17; // [rsp+18h] [rbp-10h]

  v9 = 1LL;
  v10 = ((*(_QWORD *)(v7 - 8) >> 9) | 1LL) - 2;
  if ( v10 >= 1 )
  {
    v17 = ((*(_QWORD *)(v7 - 8) >> 9) | 1LL) - 2;
    v16 = 1LL;
    v14 = v7;
    v15 = v6;
    do
    {
      v11 = v14;
      if ( *(unsigned __int8 *)(v14 - 8) == 254LL )
      {
        while ( 1 )
        {
          v8 -= 16LL;
          if ( v8 >= caml_young_limit )
            break;
          caml_call_gc(v9, v10, a3, a4, a5, a6, v14);
        }
        *(_QWORD *)v8 = 1277LL;
        *(double *)(v8 + 8) = *(double *)(v11 + 4 * v9 - 4);
      }
      (*v15)();
      v12 = v16;
      v9 = v16 + 2;
      v16 += 2LL;
    }
    while ( v12 != v17 );
  }
  return 1LL;
}
// 414E0B: variable 'v7' is possibly undefined
// 414E2E: variable 'v6' is possibly undefined
// 414E33: variable 'v14' is possibly undefined
// 414E4C: variable 'v8' is possibly undefined
// 414EA3: variable 'a3' is possibly undefined
// 414EA3: variable 'a4' is possibly undefined
// 414EA3: variable 'a5' is possibly undefined
// 414EA3: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000414EB0) ----------------------------------------------------
void *__fastcall camlArray__map_132(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 (**v6)(void); // rax
  double *v7; // rbx
  unsigned __int64 v8; // r15
  __int64 (**v9)(void); // rsi
  __int64 v11; // rsi
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rbp
  __int64 v18; // rbx
  double *v19; // rax
  __int64 v20; // rdi
  __int64 v21; // [rsp+0h] [rbp-28h]
  __int64 v22; // [rsp+0h] [rbp-28h]
  __int64 v23; // [rsp+8h] [rbp-20h]
  __int64 (**v24)(void); // [rsp+10h] [rbp-18h]
  __int64 v25; // [rsp+18h] [rbp-10h]
  __int64 v26; // [rsp+20h] [rbp-8h]

  v9 = v6;
  if ( ((*((_QWORD *)v7 - 1) >> 9) | 1LL) == 1 )
    return &camlArray__24;
  v21 = (*((_QWORD *)v7 - 1) >> 9) | 1LL;
  v23 = (__int64)v7;
  v24 = v6;
  if ( *((unsigned __int8 *)v7 - 8) == 254LL )
  {
    while ( 1 )
    {
      v8 -= 16LL;
      if ( v8 >= caml_young_limit )
        break;
      caml_call_gc(a1, (__int64)v9, a3, a4, a5, a6, v21);
    }
    *(_QWORD *)v8 = 1277LL;
    *(double *)(v8 + 8) = *v7;
  }
  v11 = (*v9)();
  caml_c_call(v21, v11);
  v17 = v12;
  v18 = 3LL;
  if ( v21 - 2 >= 3 )
  {
    v25 = v21 - 2;
    v26 = 3LL;
    v22 = v12;
    do
    {
      if ( *(unsigned __int8 *)(v23 - 8) == 254LL )
      {
        while ( 1 )
        {
          v8 -= 16LL;
          if ( v8 >= caml_young_limit )
            break;
          caml_call_gc(v23, v11, v13, v14, v15, v16, v22);
        }
        *(_QWORD *)v8 = 1277LL;
        *(double *)(v8 + 8) = *(double *)(v23 + 4 * v18 - 4);
      }
      v19 = (double *)(*v24)();
      v17 = v22;
      if ( *(unsigned __int8 *)(v22 - 8) == 254LL )
      {
        *(double *)(v22 + 4 * v26 - 4) = *v19;
      }
      else
      {
        v11 = (__int64)v19;
        caml_modify((unsigned __int64 *)(v22 + 4 * v26 - 4), (unsigned __int64)v19);
      }
      v20 = v26;
      v18 = v26 + 2;
      v26 += 2LL;
    }
    while ( v20 != v25 );
  }
  return (void *)v17;
}
// 414EB4: variable 'v6' is possibly undefined
// 414EB7: variable 'v7' is possibly undefined
// 414EF8: variable 'v8' is possibly undefined
// 414F36: variable 'v21' is possibly undefined
// 414F3B: variable 'v12' is possibly undefined
// 414FB0: variable 'v22' is possibly undefined
// 415009: variable 'v13' is possibly undefined
// 415009: variable 'v14' is possibly undefined
// 415009: variable 'v15' is possibly undefined
// 415009: variable 'v16' is possibly undefined
// 415013: variable 'a3' is possibly undefined
// 415013: variable 'a4' is possibly undefined
// 415013: variable 'a5' is possibly undefined
// 415013: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000415020) ----------------------------------------------------
__int64 __fastcall camlArray__iteri_138(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // rdi
  __int64 v10; // rsi
  __int64 v11; // rbx
  __int64 v13; // [rsp+0h] [rbp-28h]
  __int64 v14; // [rsp+8h] [rbp-20h]
  __int64 v15; // [rsp+10h] [rbp-18h]
  __int64 v16; // [rsp+18h] [rbp-10h]

  v9 = 1LL;
  if ( ((*(_QWORD *)(v7 - 8) >> 9) | 1LL) - 2 >= 1 )
  {
    v16 = ((*(_QWORD *)(v7 - 8) >> 9) | 1LL) - 2;
    v15 = 1LL;
    v13 = v7;
    v14 = v6;
    do
    {
      v10 = v13;
      if ( *(unsigned __int8 *)(v13 - 8) == 254LL )
      {
        while ( 1 )
        {
          v8 -= 16LL;
          if ( v8 >= caml_young_limit )
            break;
          caml_call_gc(v9, v10, a3, a4, a5, a6, v13);
        }
        *(_QWORD *)v8 = 1277LL;
        *(double *)(v8 + 8) = *(double *)(v10 + 4 * v9 - 4);
      }
      caml_apply2(v14);
      v11 = v15;
      v9 = v15 + 2;
      v15 += 2LL;
    }
    while ( v11 != v16 );
  }
  return 1LL;
}
// 41502B: variable 'v7' is possibly undefined
// 41504E: variable 'v6' is possibly undefined
// 415053: variable 'v13' is possibly undefined
// 41506C: variable 'v8' is possibly undefined
// 4150C6: variable 'a3' is possibly undefined
// 4150C6: variable 'a4' is possibly undefined
// 4150C6: variable 'a5' is possibly undefined
// 4150C6: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004150D0) ----------------------------------------------------
void *__fastcall camlArray__mapi_142(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  double *v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // rdi
  __int64 v11; // rsi
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rbx
  __int64 v18; // rbp
  double *v19; // rax
  __int64 v20; // rdi
  __int64 v21; // [rsp+0h] [rbp-28h]
  __int64 v22; // [rsp+0h] [rbp-28h]
  __int64 v23; // [rsp+8h] [rbp-20h]
  __int64 v24; // [rsp+10h] [rbp-18h]
  __int64 v25; // [rsp+18h] [rbp-10h]
  __int64 v26; // [rsp+20h] [rbp-8h]

  v9 = v6;
  if ( ((*((_QWORD *)v7 - 1) >> 9) | 1LL) == 1 )
    return &camlArray__23;
  v21 = (*((_QWORD *)v7 - 1) >> 9) | 1LL;
  v23 = (__int64)v7;
  v24 = v6;
  if ( *((unsigned __int8 *)v7 - 8) == 254LL )
  {
    while ( 1 )
    {
      v8 -= 16LL;
      if ( v8 >= caml_young_limit )
        break;
      caml_call_gc(v9, a2, a3, a4, a5, a6, v21);
    }
    *(_QWORD *)v8 = 1277LL;
    *(double *)(v8 + 8) = *v7;
  }
  v11 = caml_apply2(v9);
  caml_c_call(v21, v11);
  v17 = v12;
  v18 = 3LL;
  if ( v21 - 2 >= 3 )
  {
    v25 = v21 - 2;
    v26 = 3LL;
    v22 = v12;
    do
    {
      if ( *(unsigned __int8 *)(v23 - 8) == 254LL )
      {
        while ( 1 )
        {
          v8 -= 16LL;
          if ( v8 >= caml_young_limit )
            break;
          caml_call_gc(v23, v11, v13, v14, v15, v16, v22);
        }
        *(_QWORD *)v8 = 1277LL;
        *(double *)(v8 + 8) = *(double *)(v23 + 4 * v18 - 4);
      }
      v19 = (double *)caml_apply2(v24);
      v17 = v22;
      if ( *(unsigned __int8 *)(v22 - 8) == 254LL )
      {
        *(double *)(v22 + 4 * v26 - 4) = *v19;
      }
      else
      {
        v11 = (__int64)v19;
        caml_modify((unsigned __int64 *)(v22 + 4 * v26 - 4), (unsigned __int64)v19);
      }
      v20 = v26;
      v18 = v26 + 2;
      v26 += 2LL;
    }
    while ( v20 != v25 );
  }
  return (void *)v17;
}
// 4150D4: variable 'v6' is possibly undefined
// 4150D7: variable 'v7' is possibly undefined
// 415118: variable 'v8' is possibly undefined
// 41515D: variable 'v21' is possibly undefined
// 415162: variable 'v12' is possibly undefined
// 4151D7: variable 'v22' is possibly undefined
// 415231: variable 'v13' is possibly undefined
// 415231: variable 'v14' is possibly undefined
// 415231: variable 'v15' is possibly undefined
// 415231: variable 'v16' is possibly undefined
// 41523B: variable 'a3' is possibly undefined
// 41523B: variable 'a4' is possibly undefined
// 41523B: variable 'a5' is possibly undefined
// 41523B: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000415250) ----------------------------------------------------
unsigned __int64 __fastcall camlArray__to_list_148(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rsi
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v10) )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 4343LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlArray__tolist_150;
  v7[4] = i;
  return camlArray__tolist_150((__int64)(v7 + 1), i, a3, a4, a5, a6);
}
// 415254: variable 'v6' is possibly undefined
// 415257: variable 'v7' is possibly undefined
// 4152AF: variable 'a3' is possibly undefined
// 4152AF: variable 'a4' is possibly undefined
// 4152AF: variable 'a5' is possibly undefined
// 4152AF: variable 'a6' is possibly undefined
// 4152B4: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004152C0) ----------------------------------------------------
__int64 __fastcall camlArray__list_length_153()
{
  __int64 result; // rax
  __int64 v1; // rbx

  while ( v1 != 1 )
  {
    v1 = *(_QWORD *)(v1 + 8);
    result += 2LL;
  }
  return result;
}
// 4152C4: variable 'v1' is possibly undefined
// 4152CA: variable 'result' is possibly undefined

//----- (00000000004152E0) ----------------------------------------------------
void *__fastcall camlArray__of_list_157()
{
  unsigned __int64 *v0; // rax
  _QWORD *v1; // r15
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rax
  __int64 v9; // rbx
  unsigned __int64 v11; // [rsp+0h] [rbp-18h]

  if ( v0 == (unsigned __int64 *)1 )
    return &camlArray__22;
  v11 = *v0;
  v2 = camlArray__list_length_153();
  v3 = v11;
  caml_c_call(v2, v11);
  v9 = v8;
  while ( 1 )
  {
    v1 -= 5;
    if ( (unsigned __int64)v1 >= caml_young_limit )
      break;
    caml_call_gc(v2, v3, v4, v5, v6, v7, v11);
  }
  *v1 = 4343LL;
  v1[1] = caml_curry2;
  v1[2] = 5LL;
  v1[3] = camlArray__fill_162;
  v1[4] = v9;
  return (void *)camlArray__fill_162((__int64)(v1 + 1));
}
// 4152EB: variable 'v0' is possibly undefined
// 415320: variable 'v8' is possibly undefined
// 415323: variable 'v1' is possibly undefined
// 415384: variable 'v4' is possibly undefined
// 415384: variable 'v5' is possibly undefined
// 415384: variable 'v6' is possibly undefined
// 415384: variable 'v7' is possibly undefined
// 415384: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000415390) ----------------------------------------------------
unsigned __int64 __fastcall camlArray__fold_left_166(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  unsigned __int64 *v10; // rbp
  __int64 v11; // rsi
  __int64 v12; // rdi
  __int64 v13; // rax
  __int64 v14; // rbx
  char v16; // [rsp+0h] [rbp-28h]
  __int64 v17; // [rsp+0h] [rbp-28h]
  __int64 v18; // [rsp+8h] [rbp-20h]
  unsigned __int64 *v19; // [rsp+10h] [rbp-18h]
  __int64 v20; // [rsp+18h] [rbp-10h]
  __int64 v21; // [rsp+20h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v16) )
  {
    v8 -= 2;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  v10 = v8 + 1;
  *v8 = 1024LL;
  v8[1] = v7;
  v11 = 1LL;
  if ( ((*(_QWORD *)(a1 - 8) >> 9) | 1LL) - 2 >= 1 )
  {
    v21 = ((*(_QWORD *)(a1 - 8) >> 9) | 1LL) - 2;
    v20 = 1LL;
    v19 = v8 + 1;
    v17 = a1;
    v18 = i;
    do
    {
      v12 = v17;
      if ( *(unsigned __int8 *)(v17 - 8) == 254LL )
      {
        while ( 1 )
        {
          v8 -= 2;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(v12, v11, i, a4, a5, a6, v17);
        }
        *v8 = 1277LL;
        *((double *)v8 + 1) = *(double *)(v12 + 4 * v11 - 4);
      }
      v13 = caml_apply2(v18);
      v10 = v19;
      caml_modify(v19, v13);
      v14 = v20;
      v11 = v20 + 2;
      v20 += 2LL;
    }
    while ( v14 != v21 );
  }
  return *v10;
}
// 415394: variable 'v6' is possibly undefined
// 415397: variable 'v8' is possibly undefined
// 4153B7: variable 'v7' is possibly undefined
// 4153EE: variable 'i' is possibly undefined
// 4153F3: variable 'v17' is possibly undefined
// 415474: variable 'a4' is possibly undefined
// 415474: variable 'a5' is possibly undefined
// 415474: variable 'a6' is possibly undefined
// 41547B: variable 'v16' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000415490) ----------------------------------------------------
unsigned __int64 __fastcall camlArray__fold_right_172(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  unsigned __int64 *v10; // rbp
  __int64 v11; // rdi
  __int64 v12; // rbx
  __int64 v13; // rax
  char v15; // [rsp+0h] [rbp-28h]
  __int64 v16; // [rsp+0h] [rbp-28h]
  __int64 v17; // [rsp+8h] [rbp-20h]
  unsigned __int64 *v18; // [rsp+10h] [rbp-18h]
  __int64 v19; // [rsp+18h] [rbp-10h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v15) )
  {
    v8 -= 2;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  v10 = v8 + 1;
  *v8 = 1024LL;
  v8[1] = a1;
  v11 = ((*(_QWORD *)(v7 - 8) >> 9) | 1LL) - 2;
  if ( v11 >= 1 )
  {
    v19 = ((*(_QWORD *)(v7 - 8) >> 9) | 1LL) - 2;
    v18 = v8 + 1;
    v16 = v7;
    v17 = i;
    do
    {
      v12 = v16;
      if ( *(unsigned __int8 *)(v16 - 8) == 254LL )
      {
        while ( 1 )
        {
          v8 -= 2;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(v11, i, a3, a4, a5, a6, v16);
        }
        *v8 = 1277LL;
        *((double *)v8 + 1) = *(double *)(v12 + 4 * v11 - 4);
      }
      v10 = v18;
      i = caml_apply2(v17);
      caml_modify(v18, i);
      v13 = v19;
      v11 = v19 - 2;
      v19 -= 2LL;
    }
    while ( v13 != 1 );
  }
  return *v10;
}
// 415494: variable 'v6' is possibly undefined
// 415497: variable 'v8' is possibly undefined
// 4154BB: variable 'v7' is possibly undefined
// 4154E8: variable 'v16' is possibly undefined
// 415564: variable 'a3' is possibly undefined
// 415564: variable 'a4' is possibly undefined
// 415564: variable 'a5' is possibly undefined
// 415564: variable 'a6' is possibly undefined
// 41556B: variable 'v15' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000415580) ----------------------------------------------------
__int64 __fastcall camlArray__sort_179(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  double *v6; // rax
  unsigned __int64 *v7; // rbx
  _QWORD *v8; // r15
  double *v9; // rsi
  __int64 v10; // rdi
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rbx
  unsigned __int64 v17; // rax
  __int64 v18; // rdi
  double *v19; // rdi
  __int64 v20; // rax
  unsigned __int64 v21; // rbp
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 v27; // r8
  __int64 v28; // r9
  __int64 v29; // rax
  unsigned __int64 v30; // rax
  double *v31; // rbp
  unsigned __int64 v32; // rax
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // rax
  __int64 v36; // rdx
  __int64 v37; // rcx
  __int64 v38; // r8
  __int64 v39; // r9
  char v40; // [rsp+0h] [rbp-38h]
  __int64 v41; // [rsp+0h] [rbp-38h]
  __int64 v42; // [rsp+8h] [rbp-30h]
  unsigned __int64 *v43; // [rsp+10h] [rbp-28h]
  __int64 v44; // [rsp+18h] [rbp-20h]
  __int64 v45; // [rsp+18h] [rbp-20h]
  unsigned __int64 *v46; // [rsp+20h] [rbp-18h]
  __int64 v47; // [rsp+28h] [rbp-10h]

  v9 = v6;
  v46 = v7;
  while ( 1 )
  {
    v8 -= 30;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(a1, (__int64)v9, a3, a4, a5, a6, v40);
  }
  *v8 = 5367LL;
  v8[1] = caml_curry2;
  v8[2] = 5LL;
  v8[3] = camlArray__maxson_182;
  v8[4] = v9;
  v8[5] = v7;
  v8[6] = 6391LL;
  v8[7] = caml_curry3;
  v8[8] = 7LL;
  v8[9] = camlArray__trickledown_187;
  v8[10] = v9;
  v8[11] = v7;
  v8[12] = v8 + 1;
  v10 = (__int64)(v8 + 14);
  v8[13] = 5367LL;
  v8[14] = caml_curry3;
  v8[15] = 7LL;
  v8[16] = camlArray__trickle_192;
  v8[17] = v7;
  v8[18] = v8 + 7;
  v11 = (__int64)(v8 + 20);
  v8[19] = 5367LL;
  v8[20] = caml_curry2;
  v8[21] = 5LL;
  v8[22] = camlArray__bubbledown_197;
  v8[23] = v7;
  v8[24] = v8 + 1;
  v12 = (__int64)(v8 + 26);
  v41 = (__int64)(v8 + 26);
  v8[25] = 4343LL;
  v8[26] = caml_curry2;
  v8[27] = 5LL;
  v8[28] = camlArray__bubble_201;
  v8[29] = v8 + 20;
  while ( 1 )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(v10, (__int64)v9, v12, v11, a5, a6, v41);
  }
  v43 = v8 + 1;
  *v8 = 5367LL;
  v8[1] = caml_curry2;
  v8[2] = 5LL;
  v8[3] = camlArray__trickleup_205;
  v8[4] = v9;
  v8[5] = v7;
  v47 = (*(v7 - 1) >> 9) | 1;
  v13 = 3LL;
  v14 = ((v47 + 2) >> 1) / 3;
  v15 = ((v47 + 2) >> 1) % 3;
  v16 = 2 * v14 - 1;
  if ( v16 >= 1 )
  {
    v44 = 2 * v14 - 1;
    v42 = v10;
    do
    {
      v9 = (double *)v46;
      v17 = *(v46 - 1);
      v18 = (unsigned __int8)v17;
      if ( (unsigned __int8)v17 == 254LL )
      {
        if ( v17 >> 9 <= v16 )
          goto LABEL_80;
        while ( 1 )
        {
          v8 -= 2;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(254LL, (__int64)v46, v15, v13, a5, a6, v41);
        }
        v19 = (double *)(v8 + 1);
        *v8 = 1277LL;
        *((double *)v8 + 1) = *(double *)((char *)v46 + 4 * v16 - 4);
      }
      else
      {
        if ( v17 >> 9 <= v16 )
          goto LABEL_81;
        v19 = *(double **)((char *)v46 + 4 * v16 - 4);
      }
      v9 = (double *)v42;
      camlArray__trickle_192(v19, v42, v15, v13, a5, a6);
      v20 = v44;
      v16 = v44 - 2;
      v44 -= 2LL;
    }
    while ( v20 != 1 );
  }
  v21 = v47 - 2;
  if ( v47 - 2 >= 5 )
  {
    v45 = v47 - 2;
    do
    {
      v22 = *(v46 - 1);
      v18 = (unsigned __int8)v22;
      if ( (unsigned __int8)v22 == 254LL )
      {
        if ( v22 >> 9 <= v21 )
          goto LABEL_78;
        while ( 1 )
        {
          v8 -= 2;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(254LL, (__int64)v9, v15, v13, a5, a6, v41);
        }
        *v8 = 1277LL;
        *((double *)v8 + 1) = *(double *)((char *)v46 + 4 * v21 - 4);
      }
      else if ( v22 >> 9 <= v21 )
      {
        goto LABEL_79;
      }
      v23 = *(v46 - 1);
      v18 = (unsigned __int8)v23;
      if ( (unsigned __int8)v23 == 254LL )
      {
        if ( v23 >> 9 <= 1 )
          goto LABEL_76;
        while ( 1 )
        {
          v8 -= 2;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(254LL, (__int64)v9, v15, v13, a5, a6, v41);
        }
        v9 = (double *)(v8 + 1);
        *v8 = 1277LL;
        *((double *)v8 + 1) = *(double *)v46;
      }
      else
      {
        if ( v23 >> 9 <= 1 )
          goto LABEL_77;
        v9 = (double *)*v46;
      }
      v24 = *(v46 - 1);
      v18 = (unsigned __int8)v24;
      if ( (unsigned __int8)v24 == 254LL )
      {
        if ( v24 >> 9 <= v21 )
          goto LABEL_74;
        *(unsigned __int64 *)((char *)v46 + 4 * v21 - 4) = *(unsigned __int64 *)v9;
      }
      else
      {
        if ( v24 >> 9 <= v21 )
          goto LABEL_75;
        caml_modify((unsigned __int64 *)((char *)v46 + 4 * v21 - 4), (unsigned __int64)v9);
      }
      camlArray__bubble_201(v41, v9, v15, v13, a5, a6);
      camlArray__trickleup_205(v43, (__int64)v9, v25, v26, v27, v28);
      v29 = v45;
      v21 = v45 - 2;
      v45 -= 2LL;
    }
    while ( v29 != 5 );
  }
  if ( v47 <= 3 )
    return 1LL;
  v30 = *(v46 - 1);
  v18 = (unsigned __int8)v30;
  if ( (unsigned __int8)v30 == 254LL )
  {
    if ( v30 >> 9 <= 3 )
    {
LABEL_72:
      caml_ml_array_bound_error(v18, (unsigned __int64)v9);
      goto LABEL_73;
    }
    while ( 1 )
    {
      v8 -= 2;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(254LL, (__int64)v9, v15, v13, a5, a6, v41);
    }
    v31 = (double *)(v8 + 1);
    *v8 = 1277LL;
    *((double *)v8 + 1) = *((double *)v46 + 1);
LABEL_41:
    v32 = *(v46 - 1);
    v18 = (unsigned __int8)v32;
    if ( (unsigned __int8)v32 == 254LL )
    {
      if ( v32 >> 9 <= 1 )
      {
LABEL_70:
        caml_ml_array_bound_error(v18, (unsigned __int64)v9);
        goto LABEL_71;
      }
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(254LL, (__int64)v9, v15, v13, a5, a6, v41);
      }
      v9 = (double *)(v8 + 1);
      *v8 = 1277LL;
      *((double *)v8 + 1) = *(double *)v46;
    }
    else
    {
      if ( v32 >> 9 <= 1 )
      {
LABEL_71:
        caml_ml_array_bound_error(v18, (unsigned __int64)v9);
        goto LABEL_72;
      }
      v9 = (double *)*v46;
    }
    v33 = *(v46 - 1);
    v18 = (unsigned __int8)v33;
    if ( (unsigned __int8)v33 == 254LL )
    {
      if ( v33 >> 9 <= 3 )
      {
LABEL_68:
        caml_ml_array_bound_error(v18, (unsigned __int64)v9);
        goto LABEL_69;
      }
      v46[1] = *(unsigned __int64 *)v9;
    }
    else
    {
      if ( v33 >> 9 <= 3 )
      {
LABEL_69:
        caml_ml_array_bound_error(v18, (unsigned __int64)v9);
        goto LABEL_70;
      }
      caml_modify(v46 + 1, (unsigned __int64)v9);
    }
    v34 = *(v46 - 1);
    v18 = (unsigned __int8)v34;
    if ( (unsigned __int8)v34 == 254LL )
    {
      if ( v34 >> 9 > 1 )
      {
        *v46 = *(unsigned __int64 *)v31;
        return 1LL;
      }
      caml_ml_array_bound_error(254LL, (unsigned __int64)v9);
    }
    else if ( v34 >> 9 > 1 )
    {
      caml_modify(v46, (unsigned __int64)v31);
      return 1LL;
    }
    caml_ml_array_bound_error(v18, (unsigned __int64)v9);
    goto LABEL_68;
  }
  if ( v30 >> 9 > 3 )
  {
    v31 = (double *)v46[1];
    goto LABEL_41;
  }
LABEL_73:
  caml_ml_array_bound_error(v18, (unsigned __int64)v9);
LABEL_74:
  caml_ml_array_bound_error(v18, (unsigned __int64)v9);
LABEL_75:
  caml_ml_array_bound_error(v18, (unsigned __int64)v9);
LABEL_76:
  caml_ml_array_bound_error(v18, (unsigned __int64)v9);
LABEL_77:
  caml_ml_array_bound_error(v18, (unsigned __int64)v9);
LABEL_78:
  caml_ml_array_bound_error(v18, (unsigned __int64)v9);
LABEL_79:
  caml_ml_array_bound_error(v18, (unsigned __int64)v9);
LABEL_80:
  caml_ml_array_bound_error(v18, (unsigned __int64)v9);
LABEL_81:
  caml_ml_array_bound_error(v18, (unsigned __int64)v9);
  return camlArray__stable_sort_215(v18, (__int64)v9, v36, v37, v38, v39);
}
// 415584: variable 'v6' is possibly undefined
// 415587: variable 'v7' is possibly undefined
// 41558C: variable 'v8' is possibly undefined
// 41579D: variable 'v15' is possibly undefined
// 41579D: variable 'v13' is possibly undefined
// 41579D: variable 'a5' is possibly undefined
// 41579D: variable 'a6' is possibly undefined
// 415901: variable 'v41' is possibly undefined
// 415910: variable 'v25' is possibly undefined
// 415910: variable 'v26' is possibly undefined
// 415910: variable 'v27' is possibly undefined
// 415910: variable 'v28' is possibly undefined
// 415AEA: variable 'v12' is possibly undefined
// 415AEA: variable 'v11' is possibly undefined
// 415AF4: variable 'a3' is possibly undefined
// 415AF4: variable 'a4' is possibly undefined
// 415AF4: variable 'v40' is possibly undefined
// 415B4F: variable 'v36' is possibly undefined
// 415B4F: variable 'v37' is possibly undefined
// 415B4F: variable 'v38' is possibly undefined
// 415B4F: variable 'v39' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000415B50) ----------------------------------------------------
__int64 __fastcall camlArray__stable_sort_215(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  double *v7; // rbx
  double *v8; // r15
  __int64 i; // rsi
  __int64 v10; // rcx
  __int64 v11; // rsi
  __int64 v13; // rdx
  unsigned __int64 v14; // rdi
  unsigned __int64 v15; // rax
  __int64 v16; // rdx
  double v17; // rax
  __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 v27; // r8
  __int64 v28; // r9
  char v29; // [rsp+0h] [rbp-38h]
  __int64 v30; // [rsp+0h] [rbp-38h]
  __int64 v31; // [rsp+10h] [rbp-28h]
  __int64 v32; // [rsp+18h] [rbp-20h]
  __int64 v33; // [rsp+28h] [rbp-10h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v29) )
  {
    v8 -= 19;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *(_QWORD *)v8 = 5367LL;
  *((_QWORD *)v8 + 1) = caml_curry7;
  *((_QWORD *)v8 + 2) = 15LL;
  *((_QWORD *)v8 + 3) = camlArray__merge_218;
  *((_QWORD *)v8 + 4) = i;
  *((_QWORD *)v8 + 5) = v7;
  *((_QWORD *)v8 + 6) = 5367LL;
  *((_QWORD *)v8 + 7) = caml_curry4;
  *((_QWORD *)v8 + 8) = 9LL;
  *((_QWORD *)v8 + 9) = camlArray__isortto_236;
  *((_QWORD *)v8 + 10) = i;
  *((_QWORD *)v8 + 11) = v7;
  v10 = (__int64)(v8 + 13);
  *((_QWORD *)v8 + 12) = 6391LL;
  *((_QWORD *)v8 + 13) = caml_curry4;
  *((_QWORD *)v8 + 14) = 9LL;
  *((_QWORD *)v8 + 15) = camlArray__sortto_244;
  *((_QWORD *)v8 + 16) = v7;
  *((_QWORD *)v8 + 17) = v8 + 1;
  *((_QWORD *)v8 + 18) = v8 + 7;
  v11 = (*((_QWORD *)v7 - 1) >> 9) | 1LL;
  if ( v11 <= 11 )
    return camlArray__isortto_236(1LL, v11, (__int64)(v8 + 7), v10, a5, a6);
  v30 = (__int64)(v8 + 13);
  v33 = (__int64)(v8 + 1);
  v13 = (v11 >> 1) + 1;
  if ( v11 >> 1 >= 0 )
    v13 = v11 >> 1;
  v31 = 2 * (v13 >> 1) + 1;
  v14 = v11 - 2 * (v13 >> 1);
  v15 = *((_QWORD *)v7 - 1);
  v16 = (unsigned __int8)v15;
  if ( (unsigned __int8)v15 == 254LL )
  {
    if ( v15 >> 9 > 1 )
    {
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(v14, v11, v16, v10, a5, a6, v30);
      }
      *(_QWORD *)&v17 = v8 + 1;
      *(_QWORD *)v8 = 1277LL;
      v8[1] = *v7;
      goto LABEL_13;
    }
    caml_ml_array_bound_error(v14, v11);
  }
  else if ( v15 >> 9 > 1 )
  {
    v17 = *v7;
LABEL_13:
    caml_c_call(v14, *(unsigned __int64 *)&v17);
    v32 = v18;
    camlArray__sortto_244(1uLL, v14, v30, v19, v20, v21);
    camlArray__sortto_244(v14, v31, v30, v22, v23, v24);
    return camlArray__merge_218(v32, 1uLL, v14, (__int64)v7, 1uLL, v33);
  }
  caml_ml_array_bound_error(v14, v11);
  return camlArray__entry(v14, v11, v25, v26, v27, v28);
}
// 415B54: variable 'v6' is possibly undefined
// 415B57: variable 'v8' is possibly undefined
// 415B9B: variable 'v7' is possibly undefined
// 415C29: variable 'a5' is possibly undefined
// 415C29: variable 'a6' is possibly undefined
// 415CE0: variable 'v18' is possibly undefined
// 415CFA: variable 'v30' is possibly undefined
// 415CFA: variable 'v19' is possibly undefined
// 415CFA: variable 'v20' is possibly undefined
// 415CFA: variable 'v21' is possibly undefined
// 415D19: variable 'v22' is possibly undefined
// 415D19: variable 'v23' is possibly undefined
// 415D19: variable 'v24' is possibly undefined
// 415D51: variable 'v16' is possibly undefined
// 415D51: variable 'v10' is possibly undefined
// 415D5B: variable 'a3' is possibly undefined
// 415D5B: variable 'a4' is possibly undefined
// 415D5B: variable 'v29' is possibly undefined
// 415D6F: variable 'v25' is possibly undefined
// 415D6F: variable 'v26' is possibly undefined
// 415D6F: variable 'v27' is possibly undefined
// 415D6F: variable 'v28' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000415D70) ----------------------------------------------------
__int64 __fastcall camlArray__entry(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // r15
  char v8; // [rsp+0h] [rbp-8h]

  camlArray[0] = &camlArray__21;
  camlArray[1] = &camlArray__20;
  camlArray[2] = camlArray[1];
  camlArray[6] = &camlArray__19;
  camlArray[3] = &camlArray__18;
  camlArray[20] = &camlArray__17;
  camlArray[4] = &camlArray__16;
  camlArray[5] = &camlArray__15;
  camlArray[7] = &camlArray__14;
  camlArray[8] = &camlArray__13;
  camlArray[11] = &camlArray__12;
  camlArray[12] = &camlArray__11;
  camlArray[13] = &camlArray__10;
  camlArray[14] = &camlArray__9;
  camlArray[9] = &camlArray__8;
  camlArray[21] = &camlArray__7;
  camlArray[10] = &camlArray__6;
  camlArray[15] = &camlArray__5;
  camlArray[16] = &camlArray__4;
  caml_alloc1(a1, a2, a3, a4, a5, a6, v8);
  *v6 = 1024LL;
  v6[1] = camlArray__3;
  camlArray[22] = v6 + 1;
  camlArray[17] = &camlArray__2;
  camlArray[23] = 11LL;
  camlArray[18] = &camlArray__1;
  camlArray[19] = camlArray[18];
  return 1LL;
}
// 415ED6: variable 'v8' is possibly undefined
// 415EDF: variable 'v6' is possibly undefined
// 64E620: using guessed type _QWORD camlArray[25];
// 64E6E8: using guessed type __int64 (__fastcall *camlArray__1)();
// 64E708: using guessed type __int64 (__fastcall *camlArray__2)();
// 64E728: using guessed type __int64 (__fastcall *camlArray__4)();
// 64E748: using guessed type __int64 (__fastcall *camlArray__5)();
// 64E768: using guessed type __int64 (__fastcall *camlArray__6)();
// 64E780: using guessed type __int64 (__fastcall *camlArray__7)();
// 64E7A0: using guessed type __int64 (__fastcall *camlArray__8)();
// 64E7B8: using guessed type __int64 (__fastcall *camlArray__9)();
// 64E7D8: using guessed type __int64 (__fastcall *camlArray__10)();
// 64E7F8: using guessed type __int64 (__fastcall *camlArray__11)();
// 64E818: using guessed type __int64 (__fastcall *camlArray__12)();
// 64E838: using guessed type __int64 (__fastcall *camlArray__13)();
// 64E858: using guessed type __int64 (__fastcall *camlArray__14)();
// 64E878: using guessed type __int64 (__fastcall *camlArray__15)();
// 64E898: using guessed type __int64 (__fastcall *camlArray__16)();
// 64E8B0: using guessed type __int64 (__fastcall *camlArray__17)();
// 64E8D0: using guessed type __int64 (__fastcall *camlArray__18)();
// 64E8F0: using guessed type __int64 (__fastcall *camlArray__19)();
// 64E908: using guessed type __int64 (__fastcall *camlArray__20)();
// 64E928: using guessed type __int64 (__fastcall *camlArray__21)();

//----- (0000000000415F70) ----------------------------------------------------
__int64 __fastcall camlList__code_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 *v6; // rax
  __int64 v7; // rbx
  __int64 result; // rax

  while ( 1 )
  {
    if ( v6 == (__int64 *)1 )
      camlPervasives__failwith_38(a1, a2, a3, a4, a5, a6);
    a1 = v6[1];
    result = *v6;
    if ( v7 == 1 )
      break;
    v7 -= 2LL;
    v6 = (__int64 *)a1;
  }
  return result;
}
// 415F74: variable 'v6' is possibly undefined
// 415F81: variable 'v7' is possibly undefined

//----- (0000000000415FA0) ----------------------------------------------------
_QWORD *__fastcall camlList__rmap_f_98(__int64 a1, __int64 a2)
{
  _QWORD *result; // rax
  __int64 v3; // rbx
  _QWORD *v4; // r15
  __int64 (*v5)(void); // rdi
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // rbx
  __int64 v9; // r8
  __int64 v10; // r9
  _QWORD *v11; // [rsp+0h] [rbp-18h]
  __int64 v12; // [rsp+8h] [rbp-10h]
  __int64 v13; // [rsp+10h] [rbp-8h]

  while ( v3 != 1 )
  {
    v13 = a1;
    v11 = result;
    v12 = *(_QWORD *)(v3 + 8);
    v5 = **(__int64 (***)(void))(a1 + 24);
    v8 = v5();
    while ( 1 )
    {
      v4 -= 3;
      if ( (unsigned __int64)v4 >= caml_young_limit )
        break;
      caml_call_gc((__int64)v5, a2, v6, v7, v9, v10, (char)v11);
    }
    result = v4 + 1;
    *v4 = 2048LL;
    v4[1] = v8;
    v4[2] = v11;
    v3 = v12;
    a1 = v13;
  }
  return result;
}
// 415FA8: variable 'v3' is possibly undefined
// 415FAF: variable 'result' is possibly undefined
// 415FCB: variable 'v4' is possibly undefined
// 415FEE: variable 'v11' is possibly undefined
// 416005: variable 'v6' is possibly undefined
// 416005: variable 'v7' is possibly undefined
// 416005: variable 'v9' is possibly undefined
// 416005: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000416010) ----------------------------------------------------
_QWORD *__fastcall camlList__rmap2_f_131(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *result; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdi
  __int64 v10; // rbx
  _QWORD *v11; // [rsp+0h] [rbp-28h]
  __int64 v12; // [rsp+8h] [rbp-20h]
  __int64 v13; // [rsp+10h] [rbp-18h]

  while ( v7 != 1 )
  {
    if ( a1 == 1 )
      goto LABEL_7;
    v11 = result;
    v13 = *(_QWORD *)(a1 + 8);
    v12 = *(_QWORD *)(v7 + 8);
    v9 = *(_QWORD *)(a2 + 24);
    v10 = caml_apply2(v9);
    while ( 1 )
    {
      v8 -= 3;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(v9, a2, a3, a4, a5, a6, (char)v11);
    }
    result = v8 + 1;
    *v8 = 2048LL;
    v8[1] = v10;
    v8[2] = v11;
    v7 = v12;
    a1 = v13;
  }
  if ( a1 != 1 )
LABEL_7:
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  return result;
}
// 416018: variable 'v7' is possibly undefined
// 416025: variable 'result' is possibly undefined
// 416050: variable 'v8' is possibly undefined
// 416073: variable 'v11' is possibly undefined
// 41609F: variable 'a3' is possibly undefined
// 41609F: variable 'a4' is possibly undefined
// 41609F: variable 'a5' is possibly undefined
// 41609F: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004160B0) ----------------------------------------------------
_QWORD *__fastcall camlList__find_235(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  __int64 *v7; // rbx
  _QWORD *v8; // r15
  __int64 (*v9)(void); // rdi
  __int64 v11; // [rsp+0h] [rbp-28h]
  _QWORD *v12; // [rsp+8h] [rbp-20h]
  __int64 *v13; // [rsp+10h] [rbp-18h]
  __int64 v14; // [rsp+18h] [rbp-10h]

  while ( v7 != (__int64 *)1 )
  {
    v14 = a1;
    v12 = v6;
    v13 = (__int64 *)v7[1];
    v11 = *v7;
    v9 = **(__int64 (***)(void))(a1 + 24);
    if ( v9() == 1 )
    {
      v6 = v12;
      v7 = v13;
      a1 = v14;
    }
    else
    {
      while ( 1 )
      {
        v8 -= 3;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc((__int64)v9, a2, a3, a4, a5, a6, v11);
      }
      v6 = v8 + 1;
      *v8 = 2048LL;
      v8[1] = v11;
      v8[2] = v12;
      v7 = v13;
      a1 = v14;
    }
  }
  return camlList__rev_append_79(a1, a2, a3, a4, a5, a6);
}
// 4160B8: variable 'v7' is possibly undefined
// 4160BF: variable 'v6' is possibly undefined
// 4160E3: variable 'v8' is possibly undefined
// 416103: variable 'v11' is possibly undefined
// 41613B: variable 'a3' is possibly undefined
// 41613B: variable 'a4' is possibly undefined
// 41613B: variable 'a5' is possibly undefined
// 41613B: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000416150) ----------------------------------------------------
_QWORD *__fastcall camlList__part_243(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  _QWORD *v7; // rbx
  _QWORD *v8; // r15
  __int64 (*v9)(void); // rdi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  _QWORD *v16; // rbx
  __int64 v17; // r8
  __int64 v18; // r9
  _QWORD *result; // rax
  __int64 v20; // [rsp+0h] [rbp-28h]
  _QWORD *appended; // [rsp+0h] [rbp-28h]
  _QWORD *v22; // [rsp+8h] [rbp-20h]
  _QWORD *v23; // [rsp+10h] [rbp-18h]
  __int64 *v24; // [rsp+18h] [rbp-10h]

  while ( 1 )
  {
    v22 = v6;
    if ( a1 == (__int64 *)1 )
      break;
    v23 = v7;
    v24 = (__int64 *)a1[1];
    v20 = *a1;
    v9 = **(__int64 (***)(void))(a2 + 24);
    if ( v9() == 1 )
    {
      while ( 1 )
      {
        v8 -= 3;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc((__int64)v9, a2, a3, a4, a5, a6, v20);
      }
      v7 = v8 + 1;
      *v8 = 2048LL;
      v8[1] = v20;
      v8[2] = v23;
      v6 = v22;
      a1 = v24;
    }
    else
    {
      while ( 1 )
      {
        v8 -= 3;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc((__int64)v9, a2, a3, a4, a5, a6, v20);
      }
      v6 = v8 + 1;
      *v8 = 2048LL;
      v8[1] = v20;
      v8[2] = v22;
      a1 = v24;
    }
  }
  appended = camlList__rev_append_79(1LL, a2, a3, a4, a5, a6);
  v16 = camlList__rev_append_79(1LL, a2, v10, v11, v12, v13);
  while ( 1 )
  {
    v8 -= 3;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(1LL, a2, v14, v15, v17, v18, (char)appended);
  }
  result = v8 + 1;
  *v8 = 2048LL;
  v8[1] = v16;
  v8[2] = appended;
  return result;
}
// 416150: could not find valid save-restore pair for rbx
// 416154: variable 'v6' is possibly undefined
// 416168: variable 'v7' is possibly undefined
// 41618C: variable 'v8' is possibly undefined
// 4161B0: variable 'v20' is possibly undefined
// 416221: variable 'a3' is possibly undefined
// 416221: variable 'a4' is possibly undefined
// 416221: variable 'a5' is possibly undefined
// 416221: variable 'a6' is possibly undefined
// 416236: variable 'v10' is possibly undefined
// 416236: variable 'v11' is possibly undefined
// 416236: variable 'v12' is possibly undefined
// 416236: variable 'v13' is possibly undefined
// 416261: variable 'appended' is possibly undefined
// 41626A: variable 'v14' is possibly undefined
// 41626A: variable 'v15' is possibly undefined
// 41626A: variable 'v17' is possibly undefined
// 41626A: variable 'v18' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000416290) ----------------------------------------------------
_QWORD *__fastcall camlList__rev_merge_279(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  __int64 *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdi
  __int64 v11; // [rsp+0h] [rbp-48h]
  _QWORD *v12; // [rsp+8h] [rbp-40h]
  __int64 *v13; // [rsp+10h] [rbp-38h]
  __int64 v14; // [rsp+18h] [rbp-30h]
  __int64 v15; // [rsp+20h] [rbp-28h]
  _QWORD *v16; // [rsp+28h] [rbp-20h]

  while ( v6 != (_QWORD *)1 && v7 != (__int64 *)1 )
  {
    v15 = a1;
    v12 = v6;
    v13 = (__int64 *)v7[1];
    v11 = *v7;
    v16 = (_QWORD *)v6[1];
    v14 = *v6;
    v9 = *(_QWORD *)(a2 + 24);
    if ( caml_apply2(v9) > 1 )
    {
      while ( 1 )
      {
        v8 -= 3;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(v9, a2, a3, a4, a5, a6, v11);
      }
      a1 = (__int64)(v8 + 1);
      *v8 = 2048LL;
      v8[1] = v11;
      v8[2] = v15;
      v6 = v12;
      v7 = v13;
    }
    else
    {
      while ( 1 )
      {
        v8 -= 3;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(v9, a2, a3, a4, a5, a6, v11);
      }
      a1 = (__int64)(v8 + 1);
      *v8 = 2048LL;
      v8[1] = v14;
      v8[2] = v15;
      v6 = v16;
    }
  }
  return camlList__rev_append_79(a1, a2, a3, a4, a5, a6);
}
// 416298: variable 'v6' is possibly undefined
// 4162A2: variable 'v7' is possibly undefined
// 4162EC: variable 'v8' is possibly undefined
// 416354: variable 'v11' is possibly undefined
// 41637B: variable 'a3' is possibly undefined
// 41637B: variable 'a4' is possibly undefined
// 41637B: variable 'a5' is possibly undefined
// 41637B: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004163A0) ----------------------------------------------------
_QWORD *__fastcall camlList__rev_merge_rev_289(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  __int64 *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdi
  __int64 v11; // [rsp+0h] [rbp-48h]
  _QWORD *v12; // [rsp+8h] [rbp-40h]
  __int64 *v13; // [rsp+10h] [rbp-38h]
  __int64 v14; // [rsp+18h] [rbp-30h]
  __int64 v15; // [rsp+20h] [rbp-28h]
  _QWORD *v16; // [rsp+28h] [rbp-20h]

  while ( v6 != (_QWORD *)1 && v7 != (__int64 *)1 )
  {
    v15 = a1;
    v12 = v6;
    v13 = (__int64 *)v7[1];
    v11 = *v7;
    v16 = (_QWORD *)v6[1];
    v14 = *v6;
    v9 = *(_QWORD *)(a2 + 24);
    if ( caml_apply2(v9) <= 1 )
    {
      while ( 1 )
      {
        v8 -= 3;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(v9, a2, a3, a4, a5, a6, v11);
      }
      a1 = (__int64)(v8 + 1);
      *v8 = 2048LL;
      v8[1] = v11;
      v8[2] = v15;
      v6 = v12;
      v7 = v13;
    }
    else
    {
      while ( 1 )
      {
        v8 -= 3;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(v9, a2, a3, a4, a5, a6, v11);
      }
      a1 = (__int64)(v8 + 1);
      *v8 = 2048LL;
      v8[1] = v14;
      v8[2] = v15;
      v6 = v16;
    }
  }
  return camlList__rev_append_79(a1, a2, a3, a4, a5, a6);
}
// 4163A8: variable 'v6' is possibly undefined
// 4163B2: variable 'v7' is possibly undefined
// 4163FC: variable 'v8' is possibly undefined
// 416464: variable 'v11' is possibly undefined
// 41648B: variable 'a3' is possibly undefined
// 41648B: variable 'a4' is possibly undefined
// 41648B: variable 'a5' is possibly undefined
// 41648B: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004164B0) ----------------------------------------------------
_QWORD *__fastcall camlList__rev_sort_300(__int64 a1, __int64 *a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rsi
  __int64 v10; // rdi
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // rdi
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rdi
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rdi
  __int64 v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // rsi
  __int64 v32; // rdi
  __int64 v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // r8
  __int64 v36; // r9
  __int64 *v37; // rdx
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  __int64 *v41; // rdx
  __int64 v42; // rcx
  __int64 v43; // r8
  __int64 v44; // r9
  __int64 v45; // rdx
  __int64 v46; // rcx
  __int64 v47; // r8
  __int64 v48; // r9
  __int64 v49; // [rsp+0h] [rbp-28h]
  __int64 v50; // [rsp+0h] [rbp-28h]
  __int64 v51; // [rsp+8h] [rbp-20h]
  __int64 v52; // [rsp+8h] [rbp-20h]
  __int64 v53; // [rsp+10h] [rbp-18h]
  __int64 v54; // [rsp+20h] [rbp-8h]

  if ( v6 != 5 )
  {
    v54 = a1;
    if ( v6 == 7 && v7 != (__int64 *)1 )
    {
      a3 = (__int64 *)v7[1];
      if ( a3 != (__int64 *)1 )
      {
        a2 = (__int64 *)a3[1];
        if ( a2 != (__int64 *)1 )
        {
          v49 = *a2;
          v9 = *a3;
          v51 = *a3;
          v53 = *v7;
          if ( caml_apply2(*(_QWORD *)(a1 + 24)) <= 1 )
          {
            v21 = *(_QWORD *)(a1 + 24);
            if ( caml_apply2(v21) <= 1 )
            {
              v26 = *(_QWORD *)(v54 + 24);
              if ( caml_apply2(v26) <= 1 )
              {
                while ( 1 )
                {
                  v8 -= 9;
                  if ( (unsigned __int64)v8 >= caml_young_limit )
                    break;
                  caml_call_gc(v26, v9, v27, v28, v29, v30, v49);
                }
                *v8 = 2048LL;
                v8[1] = v53;
                v8[2] = 1LL;
                v8[3] = 2048LL;
                v8[4] = v51;
                v8[5] = v8 + 1;
                v8[6] = 2048LL;
                v8[7] = v49;
                v8[8] = v8 + 4;
                return v8 + 7;
              }
              else
              {
                while ( 1 )
                {
                  v8 -= 9;
                  if ( (unsigned __int64)v8 >= caml_young_limit )
                    break;
                  caml_call_gc(v26, v9, v27, v28, v29, v30, v49);
                }
                *v8 = 2048LL;
                v8[1] = v53;
                v8[2] = 1LL;
                v8[3] = 2048LL;
                v8[4] = v49;
                v8[5] = v8 + 1;
                v8[6] = 2048LL;
                v8[7] = v51;
                v8[8] = v8 + 4;
                return v8 + 7;
              }
            }
            else
            {
              while ( 1 )
              {
                v8 -= 9;
                if ( (unsigned __int64)v8 >= caml_young_limit )
                  break;
                caml_call_gc(v21, v9, v22, v23, v24, v25, v49);
              }
              *v8 = 2048LL;
              v8[1] = v49;
              v8[2] = 1LL;
              v8[3] = 2048LL;
              v8[4] = v53;
              v8[5] = v8 + 1;
              v8[6] = 2048LL;
              v8[7] = v51;
              v8[8] = v8 + 4;
              return v8 + 7;
            }
          }
          else
          {
            v10 = *(_QWORD *)(a1 + 24);
            if ( caml_apply2(v10) <= 1 )
            {
              v16 = *(_QWORD *)(v54 + 24);
              if ( caml_apply2(v16) <= 1 )
              {
                while ( 1 )
                {
                  v8 -= 9;
                  if ( (unsigned __int64)v8 >= caml_young_limit )
                    break;
                  caml_call_gc(v16, v9, v17, v18, v19, v20, v49);
                }
                *v8 = 2048LL;
                v8[1] = v51;
                v8[2] = 1LL;
                v8[3] = 2048LL;
                v8[4] = v53;
                v8[5] = v8 + 1;
                v8[6] = 2048LL;
                v8[7] = v49;
                v8[8] = v8 + 4;
                return v8 + 7;
              }
              else
              {
                while ( 1 )
                {
                  v8 -= 9;
                  if ( (unsigned __int64)v8 >= caml_young_limit )
                    break;
                  caml_call_gc(v16, v9, v17, v18, v19, v20, v49);
                }
                *v8 = 2048LL;
                v8[1] = v51;
                v8[2] = 1LL;
                v8[3] = 2048LL;
                v8[4] = v49;
                v8[5] = v8 + 1;
                v8[6] = 2048LL;
                v8[7] = v53;
                v8[8] = v8 + 4;
                return v8 + 7;
              }
            }
            else
            {
              while ( 1 )
              {
                v8 -= 9;
                if ( (unsigned __int64)v8 >= caml_young_limit )
                  break;
                caml_call_gc(v10, v9, v11, v12, v13, v14, v49);
              }
              *v8 = 2048LL;
              v8[1] = v49;
              v8[2] = 1LL;
              v8[3] = 2048LL;
              v8[4] = v51;
              v8[5] = v8 + 1;
              v8[6] = 2048LL;
              v8[7] = v53;
              v8[8] = v8 + 4;
              return v8 + 7;
            }
          }
        }
      }
    }
LABEL_32:
    camlList__chop_271((v6 >> 1) | 1, (__int64)a2, (__int64)a3, a4, a5, a6);
    camlList__sort_299(v54 - 32, a2, v37, v38, v39, v40);
    camlList__sort_299(v54 - 32, a2, v41, v42, v43, v44);
    return camlList__rev_merge_279(1LL, *(_QWORD *)(v54 + 32), v45, v46, v47, v48);
  }
  if ( v7 == (__int64 *)1 )
  {
    v54 = a1;
    goto LABEL_32;
  }
  a2 = (__int64 *)v7[1];
  if ( a2 == (__int64 *)1 )
  {
    v54 = a1;
    goto LABEL_32;
  }
  v31 = *a2;
  v50 = v31;
  v52 = *v7;
  v32 = *(_QWORD *)(a1 + 24);
  if ( caml_apply2(v32) <= 1 )
  {
    while ( 1 )
    {
      v8 -= 6;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(v32, v31, v33, v34, v35, v36, v50);
    }
    *v8 = 2048LL;
    v8[1] = v52;
    v8[2] = 1LL;
    v8[3] = 2048LL;
    v8[4] = v50;
    v8[5] = v8 + 1;
    return v8 + 4;
  }
  else
  {
    while ( 1 )
    {
      v8 -= 6;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(v32, v31, v33, v34, v35, v36, v50);
    }
    *v8 = 2048LL;
    v8[1] = v50;
    v8[2] = 1LL;
    v8[3] = 2048LL;
    v8[4] = v52;
    v8[5] = v8 + 1;
    return v8 + 4;
  }
}
// 4164B8: variable 'v6' is possibly undefined
// 4164D1: variable 'v7' is possibly undefined
// 41653D: variable 'v8' is possibly undefined
// 416561: variable 'v49' is possibly undefined
// 41685D: variable 'v50' is possibly undefined
// 416922: variable 'v37' is possibly undefined
// 416922: variable 'v38' is possibly undefined
// 416922: variable 'v39' is possibly undefined
// 416922: variable 'v40' is possibly undefined
// 41693E: variable 'v41' is possibly undefined
// 41693E: variable 'v42' is possibly undefined
// 41693E: variable 'v43' is possibly undefined
// 41693E: variable 'v44' is possibly undefined
// 41695E: variable 'v45' is possibly undefined
// 41695E: variable 'v46' is possibly undefined
// 41695E: variable 'v47' is possibly undefined
// 41695E: variable 'v48' is possibly undefined
// 416963: variable 'v33' is possibly undefined
// 416963: variable 'v34' is possibly undefined
// 416963: variable 'v35' is possibly undefined
// 416963: variable 'v36' is possibly undefined
// 416977: variable 'v27' is possibly undefined
// 416977: variable 'v28' is possibly undefined
// 416977: variable 'v29' is possibly undefined
// 416977: variable 'v30' is possibly undefined
// 41698B: variable 'v22' is possibly undefined
// 41698B: variable 'v23' is possibly undefined
// 41698B: variable 'v24' is possibly undefined
// 41698B: variable 'v25' is possibly undefined
// 416995: variable 'v17' is possibly undefined
// 416995: variable 'v18' is possibly undefined
// 416995: variable 'v19' is possibly undefined
// 416995: variable 'v20' is possibly undefined
// 4169A9: variable 'v11' is possibly undefined
// 4169A9: variable 'v12' is possibly undefined
// 4169A9: variable 'v13' is possibly undefined
// 4169A9: variable 'v14' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004169C0) ----------------------------------------------------
_QWORD *__fastcall camlList__sort_299(__int64 a1, __int64 *a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rsi
  __int64 v10; // rdi
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // rdi
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rdi
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rdi
  __int64 v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // rsi
  __int64 v32; // rdi
  __int64 v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // r8
  __int64 v36; // r9
  __int64 *v37; // rdx
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  __int64 *v41; // rdx
  __int64 v42; // rcx
  __int64 v43; // r8
  __int64 v44; // r9
  __int64 v45; // rdx
  __int64 v46; // rcx
  __int64 v47; // r8
  __int64 v48; // r9
  __int64 v49; // [rsp+0h] [rbp-28h]
  __int64 v50; // [rsp+0h] [rbp-28h]
  __int64 v51; // [rsp+8h] [rbp-20h]
  __int64 v52; // [rsp+8h] [rbp-20h]
  __int64 v53; // [rsp+10h] [rbp-18h]
  __int64 v54; // [rsp+20h] [rbp-8h]

  if ( v6 != 5 )
  {
    v54 = a1;
    if ( v6 == 7 && v7 != (__int64 *)1 )
    {
      a3 = (__int64 *)v7[1];
      if ( a3 != (__int64 *)1 )
      {
        a2 = (__int64 *)a3[1];
        if ( a2 != (__int64 *)1 )
        {
          v49 = *a2;
          v9 = *a3;
          v51 = *a3;
          v53 = *v7;
          if ( caml_apply2(*(_QWORD *)(a1 + 56)) > 1 )
          {
            v21 = *(_QWORD *)(a1 + 56);
            if ( caml_apply2(v21) > 1 )
            {
              v26 = *(_QWORD *)(v54 + 56);
              if ( caml_apply2(v26) > 1 )
              {
                while ( 1 )
                {
                  v8 -= 9;
                  if ( (unsigned __int64)v8 >= caml_young_limit )
                    break;
                  caml_call_gc(v26, v9, v27, v28, v29, v30, v49);
                }
                *v8 = 2048LL;
                v8[1] = v53;
                v8[2] = 1LL;
                v8[3] = 2048LL;
                v8[4] = v51;
                v8[5] = v8 + 1;
                v8[6] = 2048LL;
                v8[7] = v49;
                v8[8] = v8 + 4;
                return v8 + 7;
              }
              else
              {
                while ( 1 )
                {
                  v8 -= 9;
                  if ( (unsigned __int64)v8 >= caml_young_limit )
                    break;
                  caml_call_gc(v26, v9, v27, v28, v29, v30, v49);
                }
                *v8 = 2048LL;
                v8[1] = v53;
                v8[2] = 1LL;
                v8[3] = 2048LL;
                v8[4] = v49;
                v8[5] = v8 + 1;
                v8[6] = 2048LL;
                v8[7] = v51;
                v8[8] = v8 + 4;
                return v8 + 7;
              }
            }
            else
            {
              while ( 1 )
              {
                v8 -= 9;
                if ( (unsigned __int64)v8 >= caml_young_limit )
                  break;
                caml_call_gc(v21, v9, v22, v23, v24, v25, v49);
              }
              *v8 = 2048LL;
              v8[1] = v49;
              v8[2] = 1LL;
              v8[3] = 2048LL;
              v8[4] = v53;
              v8[5] = v8 + 1;
              v8[6] = 2048LL;
              v8[7] = v51;
              v8[8] = v8 + 4;
              return v8 + 7;
            }
          }
          else
          {
            v10 = *(_QWORD *)(a1 + 56);
            if ( caml_apply2(v10) > 1 )
            {
              v16 = *(_QWORD *)(v54 + 56);
              if ( caml_apply2(v16) > 1 )
              {
                while ( 1 )
                {
                  v8 -= 9;
                  if ( (unsigned __int64)v8 >= caml_young_limit )
                    break;
                  caml_call_gc(v16, v9, v17, v18, v19, v20, v49);
                }
                *v8 = 2048LL;
                v8[1] = v51;
                v8[2] = 1LL;
                v8[3] = 2048LL;
                v8[4] = v53;
                v8[5] = v8 + 1;
                v8[6] = 2048LL;
                v8[7] = v49;
                v8[8] = v8 + 4;
                return v8 + 7;
              }
              else
              {
                while ( 1 )
                {
                  v8 -= 9;
                  if ( (unsigned __int64)v8 >= caml_young_limit )
                    break;
                  caml_call_gc(v16, v9, v17, v18, v19, v20, v49);
                }
                *v8 = 2048LL;
                v8[1] = v51;
                v8[2] = 1LL;
                v8[3] = 2048LL;
                v8[4] = v49;
                v8[5] = v8 + 1;
                v8[6] = 2048LL;
                v8[7] = v53;
                v8[8] = v8 + 4;
                return v8 + 7;
              }
            }
            else
            {
              while ( 1 )
              {
                v8 -= 9;
                if ( (unsigned __int64)v8 >= caml_young_limit )
                  break;
                caml_call_gc(v10, v9, v11, v12, v13, v14, v49);
              }
              *v8 = 2048LL;
              v8[1] = v49;
              v8[2] = 1LL;
              v8[3] = 2048LL;
              v8[4] = v51;
              v8[5] = v8 + 1;
              v8[6] = 2048LL;
              v8[7] = v53;
              v8[8] = v8 + 4;
              return v8 + 7;
            }
          }
        }
      }
    }
LABEL_32:
    camlList__chop_271((v6 >> 1) | 1, (__int64)a2, (__int64)a3, a4, a5, a6);
    camlList__rev_sort_300(v54 + 32, a2, v37, v38, v39, v40);
    camlList__rev_sort_300(v54 + 32, a2, v41, v42, v43, v44);
    return camlList__rev_merge_rev_289(1LL, *(_QWORD *)(v54 + 72), v45, v46, v47, v48);
  }
  if ( v7 == (__int64 *)1 )
  {
    v54 = a1;
    goto LABEL_32;
  }
  a2 = (__int64 *)v7[1];
  if ( a2 == (__int64 *)1 )
  {
    v54 = a1;
    goto LABEL_32;
  }
  v31 = *a2;
  v50 = v31;
  v52 = *v7;
  v32 = *(_QWORD *)(a1 + 56);
  if ( caml_apply2(v32) > 1 )
  {
    while ( 1 )
    {
      v8 -= 6;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(v32, v31, v33, v34, v35, v36, v50);
    }
    *v8 = 2048LL;
    v8[1] = v52;
    v8[2] = 1LL;
    v8[3] = 2048LL;
    v8[4] = v50;
    v8[5] = v8 + 1;
    return v8 + 4;
  }
  else
  {
    while ( 1 )
    {
      v8 -= 6;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(v32, v31, v33, v34, v35, v36, v50);
    }
    *v8 = 2048LL;
    v8[1] = v50;
    v8[2] = 1LL;
    v8[3] = 2048LL;
    v8[4] = v52;
    v8[5] = v8 + 1;
    return v8 + 4;
  }
}
// 4169C8: variable 'v6' is possibly undefined
// 4169E1: variable 'v7' is possibly undefined
// 416A4D: variable 'v8' is possibly undefined
// 416A71: variable 'v49' is possibly undefined
// 416D6D: variable 'v50' is possibly undefined
// 416E32: variable 'v37' is possibly undefined
// 416E32: variable 'v38' is possibly undefined
// 416E32: variable 'v39' is possibly undefined
// 416E32: variable 'v40' is possibly undefined
// 416E4E: variable 'v41' is possibly undefined
// 416E4E: variable 'v42' is possibly undefined
// 416E4E: variable 'v43' is possibly undefined
// 416E4E: variable 'v44' is possibly undefined
// 416E6E: variable 'v45' is possibly undefined
// 416E6E: variable 'v46' is possibly undefined
// 416E6E: variable 'v47' is possibly undefined
// 416E6E: variable 'v48' is possibly undefined
// 416E73: variable 'v33' is possibly undefined
// 416E73: variable 'v34' is possibly undefined
// 416E73: variable 'v35' is possibly undefined
// 416E73: variable 'v36' is possibly undefined
// 416E87: variable 'v27' is possibly undefined
// 416E87: variable 'v28' is possibly undefined
// 416E87: variable 'v29' is possibly undefined
// 416E87: variable 'v30' is possibly undefined
// 416E9B: variable 'v22' is possibly undefined
// 416E9B: variable 'v23' is possibly undefined
// 416E9B: variable 'v24' is possibly undefined
// 416E9B: variable 'v25' is possibly undefined
// 416EA5: variable 'v17' is possibly undefined
// 416EA5: variable 'v18' is possibly undefined
// 416EA5: variable 'v19' is possibly undefined
// 416EA5: variable 'v20' is possibly undefined
// 416EB9: variable 'v11' is possibly undefined
// 416EB9: variable 'v12' is possibly undefined
// 416EB9: variable 'v13' is possibly undefined
// 416EB9: variable 'v14' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000416ED0) ----------------------------------------------------
__int64 __fastcall camlList__length_aux_58()
{
  __int64 result; // rax
  __int64 v1; // rbx

  while ( v1 != 1 )
  {
    v1 = *(_QWORD *)(v1 + 8);
    result += 2LL;
  }
  return result;
}
// 416ED4: variable 'v1' is possibly undefined
// 416EDA: variable 'result' is possibly undefined

//----- (0000000000416EF0) ----------------------------------------------------
__int64 camlList__length_62()
{
  return camlList__length_aux_58();
}
// 416EF0: using guessed type __int64 __fastcall camlList__length_62();

//----- (0000000000416F00) ----------------------------------------------------
__int64 __fastcall camlList__hd_64(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax

  if ( v6 == 1 )
    camlPervasives__failwith_38(a1, a2, a3, a4, a5, a6);
  return *(_QWORD *)v6;
}
// 416F04: variable 'v6' is possibly undefined

//----- (0000000000416F20) ----------------------------------------------------
__int64 __fastcall camlList__tl_67(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax

  if ( v6 == 1 )
    camlPervasives__failwith_38(a1, a2, a3, a4, a5, a6);
  return *(_QWORD *)(v6 + 8);
}
// 416F24: variable 'v6' is possibly undefined

//----- (0000000000416F40) ----------------------------------------------------
__int64 __fastcall camlList__nth_70(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx

  if ( v6 < 1 )
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  return camlList__code_begin((__int64)&camlList__48, a2, a3, a4, a5, a6);
}
// 416F44: variable 'v6' is possibly undefined
// 6501B8: using guessed type __int64 (__fastcall *camlList__48)();

//----- (0000000000416F60) ----------------------------------------------------
_QWORD *__fastcall camlList__rev_append_79(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 *v6; // rax
  _QWORD *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdx
  __int64 i; // rsi
  char v12; // [rsp+0h] [rbp-8h]

  while ( v6 != (__int64 *)1 )
  {
    v9 = v6[1];
    for ( i = *v6; ; caml_call_gc(a1, i, v9, a4, a5, a6, v12) )
    {
      v8 -= 3;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
    }
    a1 = (__int64)(v8 + 1);
    *v8 = 2048LL;
    v8[1] = i;
    v8[2] = v7;
    v6 = (__int64 *)v9;
    v7 = v8 + 1;
  }
  return v7;
}
// 416F68: variable 'v6' is possibly undefined
// 416F71: variable 'v8' is possibly undefined
// 416F90: variable 'v7' is possibly undefined
// 416F94: variable 'v9' is possibly undefined
// 416FA4: variable 'a4' is possibly undefined
// 416FA4: variable 'a5' is possibly undefined
// 416FA4: variable 'a6' is possibly undefined
// 416FA4: variable 'v12' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000416FB0) ----------------------------------------------------
_QWORD *__fastcall camlList__rev_84(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return camlList__rev_append_79(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000416FC0) ----------------------------------------------------
__int64 __fastcall camlList__flatten_86()
{
  __int64 v0; // rax

  if ( v0 == 1 )
    return 1LL;
  camlList__flatten_86();
  return (__int64)camlPervasives___40_167();
}
// 416FC8: variable 'v0' is possibly undefined

//----- (0000000000417000) ----------------------------------------------------
__int64 __fastcall camlList__map_90()
{
  __int64 (**v0)(void); // rax
  __int64 v1; // rbx
  _QWORD *v2; // r15
  __int64 v3; // rsi
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 i; // rdi
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 result; // rax
  char v10; // [rsp+0h] [rbp-18h]
  __int64 v11; // [rsp+10h] [rbp-8h]

  v3 = (__int64)v0;
  if ( v1 == 1 )
    return 1LL;
  v10 = (char)v0;
  v11 = (*v0)();
  for ( i = camlList__map_90(); ; caml_call_gc(i, v3, v4, v5, v7, v8, v10) )
  {
    v2 -= 3;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
  }
  result = (__int64)(v2 + 1);
  *v2 = 2048LL;
  v2[1] = v11;
  v2[2] = i;
  return result;
}
// 417004: variable 'v0' is possibly undefined
// 41700B: variable 'v1' is possibly undefined
// 41703B: variable 'v2' is possibly undefined
// 417074: variable 'v4' is possibly undefined
// 417074: variable 'v5' is possibly undefined
// 417074: variable 'v7' is possibly undefined
// 417074: variable 'v8' is possibly undefined
// 417074: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417080) ----------------------------------------------------
_QWORD *__fastcall camlList__rev_map_95(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rsi
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v10) )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 4343LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlList__rmap_f_98;
  v7[4] = i;
  return camlList__rmap_f_98((__int64)(v7 + 1), i);
}
// 417084: variable 'v6' is possibly undefined
// 417087: variable 'v7' is possibly undefined
// 4170D4: variable 'a3' is possibly undefined
// 4170D4: variable 'a4' is possibly undefined
// 4170D4: variable 'a5' is possibly undefined
// 4170D4: variable 'a6' is possibly undefined
// 4170D4: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004170E0) ----------------------------------------------------
__int64 __fastcall camlList__iter_102()
{
  void (**v0)(void); // rax
  __int64 v1; // rbx
  void (**v3)(void); // [rsp+0h] [rbp-18h]
  __int64 v4; // [rsp+8h] [rbp-10h]

  while ( v1 != 1 )
  {
    v3 = v0;
    v4 = *(_QWORD *)(v1 + 8);
    (*v0)();
    v0 = v3;
    v1 = v4;
  }
  return 1LL;
}
// 4170EB: variable 'v1' is possibly undefined
// 4170ED: variable 'v0' is possibly undefined

//----- (0000000000417120) ----------------------------------------------------
__int64 __fastcall camlList__fold_left_106(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rdx
  __int64 result; // rax
  __int64 v5; // [rsp+0h] [rbp-18h]
  __int64 v6; // [rsp+8h] [rbp-10h]

  while ( 1 )
  {
    v3 = v1;
    result = v2;
    if ( a1 == 1 )
      break;
    v5 = v3;
    v6 = *(_QWORD *)(a1 + 8);
    v2 = caml_apply2(v3);
    v1 = v5;
    a1 = v6;
  }
  return result;
}
// 417124: variable 'v1' is possibly undefined
// 417127: variable 'v2' is possibly undefined

//----- (0000000000417170) ----------------------------------------------------
__int64 __fastcall camlList__fold_right_112(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v4; // [rsp+8h] [rbp-10h]

  if ( v2 == 1 )
    return a1;
  v4 = v1;
  camlList__fold_right_112(a1);
  return caml_apply2(v4);
}
// 417178: variable 'v2' is possibly undefined
// 41717A: variable 'v1' is possibly undefined

//----- (00000000004171B0) ----------------------------------------------------
__int64 __fastcall camlList__map2_118(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rsi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 i; // rdi
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 result; // rax
  char v20; // [rsp+0h] [rbp-28h]
  __int64 v21; // [rsp+10h] [rbp-18h]
  __int64 v22; // [rsp+18h] [rbp-10h]

  v9 = v6;
  if ( v7 == 1 )
  {
    if ( a1 == 1 )
      return 1LL;
LABEL_8:
    camlPervasives__invalid_arg_40(a1, v6, a3, a4, a5, a6);
  }
  if ( a1 == 1 )
    goto LABEL_8;
  v20 = v6;
  v21 = *(_QWORD *)(a1 + 8);
  v22 = caml_apply2(v6);
  for ( i = camlList__map2_118(v21, v9, v10, v11, v12, v13); ; caml_call_gc(i, v9, v14, v15, v17, v18, v20) )
  {
    v8 -= 3;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = (__int64)(v8 + 1);
  *v8 = 2048LL;
  v8[1] = v22;
  v8[2] = i;
  return result;
}
// 4171B4: variable 'v6' is possibly undefined
// 4171BB: variable 'v7' is possibly undefined
// 417201: variable 'v10' is possibly undefined
// 417201: variable 'v11' is possibly undefined
// 417201: variable 'v12' is possibly undefined
// 417201: variable 'v13' is possibly undefined
// 417209: variable 'v8' is possibly undefined
// 41725C: variable 'v14' is possibly undefined
// 41725C: variable 'v15' is possibly undefined
// 41725C: variable 'v17' is possibly undefined
// 41725C: variable 'v18' is possibly undefined
// 41725C: variable 'v20' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417270) ----------------------------------------------------
_QWORD *__fastcall camlList__rev_map2_127(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rdx
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v10) )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 4343LL;
  v7[1] = caml_curry3;
  v7[2] = 7LL;
  v7[3] = camlList__rmap2_f_131;
  v7[4] = i;
  return camlList__rmap2_f_131(a1, (__int64)(v7 + 1), i, a4, a5, a6);
}
// 417274: variable 'v6' is possibly undefined
// 417277: variable 'v7' is possibly undefined
// 4172B0: variable 'i' is possibly undefined
// 4172BF: variable 'a4' is possibly undefined
// 4172BF: variable 'a5' is possibly undefined
// 4172BF: variable 'a6' is possibly undefined
// 4172C4: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004172D0) ----------------------------------------------------
__int64 __fastcall camlList__iter2_139(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v9; // [rsp+0h] [rbp-18h]
  __int64 v10; // [rsp+8h] [rbp-10h]
  __int64 v11; // [rsp+10h] [rbp-8h]

  while ( v7 != 1 )
  {
    if ( a1 == 1 )
      goto LABEL_6;
    v9 = v6;
    v11 = *(_QWORD *)(a1 + 8);
    v10 = *(_QWORD *)(v7 + 8);
    caml_apply2(v6);
    v6 = v9;
    v7 = v10;
    a1 = v11;
  }
  if ( a1 != 1 )
LABEL_6:
    camlPervasives__invalid_arg_40(a1, v6, a3, a4, a5, a6);
  return 1LL;
}
// 4172DB: variable 'v7' is possibly undefined
// 4172E3: variable 'v6' is possibly undefined
// 41733B: variable 'a3' is possibly undefined
// 41733B: variable 'a4' is possibly undefined
// 41733B: variable 'a5' is possibly undefined
// 41733B: variable 'a6' is possibly undefined

//----- (0000000000417340) ----------------------------------------------------
__int64 __fastcall camlList__fold_left2_147(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v9; // [rsp+0h] [rbp-18h]
  __int64 v10; // [rsp+8h] [rbp-10h]
  __int64 *v11; // [rsp+10h] [rbp-8h]

  while ( a1 != 1 )
  {
    if ( a2 == (__int64 *)1 )
      goto LABEL_6;
    v9 = v6;
    v11 = (__int64 *)a2[1];
    v10 = *(_QWORD *)(a1 + 8);
    v7 = caml_apply3(*a2, v6);
    v6 = v9;
    a1 = v10;
    a2 = v11;
  }
  if ( a2 != (__int64 *)1 )
LABEL_6:
    camlPervasives__invalid_arg_40(a1, (__int64)a2, v6, a4, a5, a6);
  return v7;
}
// 417353: variable 'v6' is possibly undefined
// 41739A: variable 'v7' is possibly undefined
// 4173AF: variable 'a4' is possibly undefined
// 4173AF: variable 'a5' is possibly undefined
// 4173AF: variable 'a6' is possibly undefined

//----- (00000000004173C0) ----------------------------------------------------
__int64 __fastcall camlList__fold_right2_156(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 *v7; // rbx
  __int64 v8; // rax
  __int64 v10; // [rsp+10h] [rbp-8h]

  if ( v7 != (__int64 *)1 )
  {
    if ( a1 != 1 )
    {
      v10 = v6;
      v8 = camlList__fold_right2_156(*(_QWORD *)(a1 + 8), a2, *v7, v7[1], *(_QWORD *)(a1 + 8), a6);
      return caml_apply3(v8, v10);
    }
LABEL_6:
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  }
  if ( a1 != 1 )
    goto LABEL_6;
  return a2;
}
// 4173C8: variable 'v7' is possibly undefined
// 4173D0: variable 'v6' is possibly undefined

//----- (0000000000417440) ----------------------------------------------------
__int64 __fastcall camlList__for_all_165()
{
  __int64 (**v0)(void); // rax
  __int64 v1; // rbx
  __int64 (**v3)(void); // [rsp+0h] [rbp-18h]
  __int64 v4; // [rsp+8h] [rbp-10h]

  while ( v1 != 1 )
  {
    v3 = v0;
    v4 = *(_QWORD *)(v1 + 8);
    if ( (*v0)() == 1 )
      return 1LL;
    v0 = v3;
    v1 = v4;
  }
  return 3LL;
}
// 41744B: variable 'v1' is possibly undefined
// 41744D: variable 'v0' is possibly undefined

//----- (0000000000417490) ----------------------------------------------------
__int64 __fastcall camlList__exists_169()
{
  __int64 (**v0)(void); // rax
  __int64 v1; // rbx
  __int64 (**v3)(void); // [rsp+0h] [rbp-18h]
  __int64 v4; // [rsp+8h] [rbp-10h]

  while ( v1 != 1 )
  {
    v3 = v0;
    v4 = *(_QWORD *)(v1 + 8);
    if ( (*v0)() != 1 )
      return 3LL;
    v0 = v3;
    v1 = v4;
  }
  return 1LL;
}
// 41749B: variable 'v1' is possibly undefined
// 41749D: variable 'v0' is possibly undefined
// 417490: using guessed type __int64 __fastcall camlList__exists_169();

//----- (00000000004174E0) ----------------------------------------------------
__int64 __fastcall camlList__for_all2_173(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v9; // [rsp+0h] [rbp-18h]
  __int64 v10; // [rsp+8h] [rbp-10h]
  __int64 v11; // [rsp+10h] [rbp-8h]

  while ( v7 != 1 )
  {
    if ( a1 == 1 )
      goto LABEL_8;
    v9 = v6;
    v11 = *(_QWORD *)(a1 + 8);
    v10 = *(_QWORD *)(v7 + 8);
    if ( caml_apply2(v6) == 1 )
      return 1LL;
    v6 = v9;
    v7 = v10;
    a1 = v11;
  }
  if ( a1 != 1 )
LABEL_8:
    camlPervasives__invalid_arg_40(a1, v6, a3, a4, a5, a6);
  return 3LL;
}
// 4174EB: variable 'v7' is possibly undefined
// 4174F3: variable 'v6' is possibly undefined
// 41755B: variable 'a3' is possibly undefined
// 41755B: variable 'a4' is possibly undefined
// 41755B: variable 'a5' is possibly undefined
// 41755B: variable 'a6' is possibly undefined

//----- (0000000000417560) ----------------------------------------------------
__int64 __fastcall camlList__exists2_181(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v9; // [rsp+0h] [rbp-18h]
  __int64 v10; // [rsp+8h] [rbp-10h]
  __int64 v11; // [rsp+10h] [rbp-8h]

  while ( v7 != 1 )
  {
    if ( a1 == 1 )
      goto LABEL_8;
    v9 = v6;
    v11 = *(_QWORD *)(a1 + 8);
    v10 = *(_QWORD *)(v7 + 8);
    if ( caml_apply2(v6) != 1 )
      return 3LL;
    v6 = v9;
    v7 = v10;
    a1 = v11;
  }
  if ( a1 != 1 )
LABEL_8:
    camlPervasives__invalid_arg_40(a1, v6, a3, a4, a5, a6);
  return 1LL;
}
// 41756B: variable 'v7' is possibly undefined
// 417573: variable 'v6' is possibly undefined
// 4175DB: variable 'a3' is possibly undefined
// 4175DB: variable 'a4' is possibly undefined
// 4175DB: variable 'a5' is possibly undefined
// 4175DB: variable 'a6' is possibly undefined

//----- (00000000004175E0) ----------------------------------------------------
__int64 __fastcall camlList__mem_189()
{
  unsigned __int64 v0; // rax
  __int64 *v1; // rbx
  __int64 v2; // rax
  unsigned __int64 v4; // [rsp+0h] [rbp-18h]
  __int64 *v5; // [rsp+8h] [rbp-10h]

  while ( v1 != (__int64 *)1 )
  {
    v4 = v0;
    v5 = (__int64 *)v1[1];
    caml_c_call(*v1, v0);
    if ( v2 == 1 )
      return 3LL;
    v0 = v4;
    v1 = v5;
  }
  return 1LL;
}
// 4175E8: variable 'v1' is possibly undefined
// 4175EA: variable 'v0' is possibly undefined
// 41760D: variable 'v2' is possibly undefined

//----- (0000000000417640) ----------------------------------------------------
__int64 __fastcall camlList__memq_193()
{
  __int64 v0; // rax
  _QWORD *v1; // rbx

  while ( v1 != (_QWORD *)1 )
  {
    if ( *v1 == v0 )
      return 3LL;
    v1 = (_QWORD *)v1[1];
  }
  return 1LL;
}
// 417644: variable 'v1' is possibly undefined
// 417650: variable 'v0' is possibly undefined
// 417640: using guessed type __int64 __fastcall camlList__memq_193();

//----- (0000000000417670) ----------------------------------------------------
__int64 __fastcall camlList__assoc_197(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 v6; // rax
  __int64 **v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rax
  unsigned __int64 v11; // [rsp+0h] [rbp-18h]
  __int64 **v12; // [rsp+8h] [rbp-10h]
  __int64 v13; // [rsp+10h] [rbp-8h]

  while ( 1 )
  {
    if ( v7 == (__int64 **)1 )
    {
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
        {
          *v8 = 1024LL;
          v8[1] = &caml_exn_Not_found;
          caml_raise_exn();
        }
        caml_call_gc(a1, a2, a3, a4, a5, a6, v11);
      }
    }
    v11 = v6;
    v12 = (__int64 **)v7[1];
    v13 = (*v7)[1];
    a1 = **v7;
    a2 = v6;
    caml_c_call(a1, v6);
    if ( v9 == 1 )
      break;
    v6 = v11;
    v7 = v12;
  }
  return v13;
}
// 417678: variable 'v7' is possibly undefined
// 41767A: variable 'v6' is possibly undefined
// 4176A9: variable 'v9' is possibly undefined
// 4176C4: variable 'v8' is possibly undefined
// 4176EF: variable 'a3' is possibly undefined
// 4176EF: variable 'a4' is possibly undefined
// 4176EF: variable 'a5' is possibly undefined
// 4176EF: variable 'a6' is possibly undefined
// 4176EF: variable 'v11' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417700) ----------------------------------------------------
__int64 __fastcall camlList__assq_202(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 **v7; // rbx
  _QWORD *v8; // r15
  char v10; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    if ( v7 == (__int64 **)1 )
    {
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
        {
          *v8 = 1024LL;
          v8[1] = &caml_exn_Not_found;
          caml_raise_exn();
        }
        caml_call_gc(a1, a2, a3, a4, a5, a6, v10);
      }
    }
    a3 = (__int64)v7[1];
    a2 = (*v7)[1];
    a1 = **v7;
    if ( a1 == v6 )
      break;
    v7 = (__int64 **)v7[1];
  }
  return (*v7)[1];
}
// 417708: variable 'v7' is possibly undefined
// 41771B: variable 'v6' is possibly undefined
// 417730: variable 'v8' is possibly undefined
// 41775B: variable 'a3' is possibly undefined
// 41775B: variable 'a4' is possibly undefined
// 41775B: variable 'a5' is possibly undefined
// 41775B: variable 'a6' is possibly undefined
// 41775B: variable 'v10' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417770) ----------------------------------------------------
__int64 __fastcall camlList__mem_assoc_207()
{
  unsigned __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v2; // rax
  unsigned __int64 v4; // [rsp+0h] [rbp-18h]
  __int64 v5; // [rsp+8h] [rbp-10h]

  while ( v1 != 1 )
  {
    v4 = v0;
    v5 = *(_QWORD *)(v1 + 8);
    caml_c_call(**(_QWORD **)v1, v0);
    if ( v2 == 1 )
      return 3LL;
    v0 = v4;
    v1 = v5;
  }
  return 1LL;
}
// 417778: variable 'v1' is possibly undefined
// 41777A: variable 'v0' is possibly undefined
// 4177A0: variable 'v2' is possibly undefined
// 417770: using guessed type __int64 __fastcall camlList__mem_assoc_207();

//----- (00000000004177D0) ----------------------------------------------------
__int64 __fastcall camlList__mem_assq_212()
{
  __int64 v0; // rax
  __int64 v1; // rbx

  while ( v1 != 1 )
  {
    if ( **(_QWORD **)v1 == v0 )
      return 3LL;
    v1 = *(_QWORD *)(v1 + 8);
  }
  return 1LL;
}
// 4177D4: variable 'v1' is possibly undefined
// 4177E3: variable 'v0' is possibly undefined
// 4177D0: using guessed type __int64 __fastcall camlList__mem_assq_212();

//----- (0000000000417800) ----------------------------------------------------
__int64 __fastcall camlList__remove_assoc_217()
{
  unsigned __int64 v0; // rax
  __int64 v1; // rbx
  _QWORD *v2; // r15
  __int64 v3; // rsi
  __int64 v4; // rax
  __int64 result; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 i; // rdi
  __int64 v9; // r8
  __int64 v10; // r9
  char v11; // [rsp+0h] [rbp-18h]
  __int64 *v12; // [rsp+8h] [rbp-10h]
  __int64 v13; // [rsp+10h] [rbp-8h]

  if ( v1 == 1 )
    return 1LL;
  v11 = v0;
  v13 = *(_QWORD *)(v1 + 8);
  v12 = *(__int64 **)v1;
  v3 = v0;
  caml_c_call(**(_QWORD **)v1, v0);
  if ( v4 == 1 )
    return v13;
  for ( i = camlList__remove_assoc_217(); ; caml_call_gc(i, v3, v6, v7, v9, v10, v11) )
  {
    v2 -= 3;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
  }
  result = (__int64)(v2 + 1);
  *v2 = 2048LL;
  v2[1] = v12;
  v2[2] = i;
  return result;
}
// 417808: variable 'v1' is possibly undefined
// 41780A: variable 'v0' is possibly undefined
// 417835: variable 'v4' is possibly undefined
// 417855: variable 'v2' is possibly undefined
// 417890: variable 'v6' is possibly undefined
// 417890: variable 'v7' is possibly undefined
// 417890: variable 'v9' is possibly undefined
// 417890: variable 'v10' is possibly undefined
// 417890: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004178A0) ----------------------------------------------------
__int64 __fastcall camlList__remove_assq_223()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  _QWORD *v2; // r15
  _QWORD *v3; // rsi
  __int64 result; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 i; // rdi
  __int64 v8; // r8
  __int64 v9; // r9
  _QWORD *v10; // [rsp+0h] [rbp-8h]

  if ( v1 == 1 )
    return 1LL;
  v3 = *(_QWORD **)v1;
  if ( **(_QWORD **)v1 == v0 )
    return *(_QWORD *)(v1 + 8);
  v10 = *(_QWORD **)v1;
  for ( i = camlList__remove_assq_223(); ; caml_call_gc(i, (__int64)v3, v5, v6, v8, v9, (char)v10) )
  {
    v2 -= 3;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
  }
  result = (__int64)(v2 + 1);
  *v2 = 2048LL;
  v2[1] = v10;
  v2[2] = i;
  return result;
}
// 4178A8: variable 'v1' is possibly undefined
// 4178B7: variable 'v0' is possibly undefined
// 4178D3: variable 'v2' is possibly undefined
// 4178F3: variable 'v10' is possibly undefined
// 41790C: variable 'v5' is possibly undefined
// 41790C: variable 'v6' is possibly undefined
// 41790C: variable 'v8' is possibly undefined
// 41790C: variable 'v9' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417920) ----------------------------------------------------
__int64 __fastcall camlList__find_229(__int64 (*a1)(void), __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 (**v6)(void); // rax
  __int64 *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rsi
  __int64 (**v11)(void); // [rsp+0h] [rbp-18h]
  __int64 *v12; // [rsp+8h] [rbp-10h]
  __int64 v13; // [rsp+10h] [rbp-8h]

  while ( 1 )
  {
    v9 = (__int64)v6;
    if ( v7 == (__int64 *)1 )
    {
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
        {
          *v8 = 1024LL;
          v8[1] = &caml_exn_Not_found;
          caml_raise_exn();
        }
        caml_call_gc((__int64)a1, v9, a3, a4, a5, a6, (char)v11);
      }
    }
    v11 = v6;
    v12 = (__int64 *)v7[1];
    v13 = *v7;
    a1 = *v6;
    if ( (*v6)() != 1 )
      break;
    v6 = v11;
    v7 = v12;
  }
  return v13;
}
// 417924: variable 'v6' is possibly undefined
// 41792B: variable 'v7' is possibly undefined
// 417968: variable 'v8' is possibly undefined
// 417993: variable 'a3' is possibly undefined
// 417993: variable 'a4' is possibly undefined
// 417993: variable 'a5' is possibly undefined
// 417993: variable 'a6' is possibly undefined
// 417993: variable 'v11' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004179A0) ----------------------------------------------------
__int64 __fastcall camlList__find_all_233(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rdi
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v10) )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 4343LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlList__find_235;
  v7[4] = i;
  return ((__int64 (*)(void))v7[1])();
}
// 4179A4: variable 'v6' is possibly undefined
// 4179A7: variable 'v7' is possibly undefined
// 4179F4: variable 'a3' is possibly undefined
// 4179F4: variable 'a4' is possibly undefined
// 4179F4: variable 'a5' is possibly undefined
// 4179F4: variable 'a6' is possibly undefined
// 4179F4: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417A00) ----------------------------------------------------
_QWORD *__fastcall camlList__partition_240(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 *v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc((__int64)v7, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 4343LL;
  v8[1] = caml_curry3;
  v8[2] = 7LL;
  v8[3] = camlList__part_243;
  v8[4] = i;
  return camlList__part_243(v7, (__int64)(v8 + 1), i, a4, a5, a6);
}
// 417A04: variable 'v6' is possibly undefined
// 417A0A: variable 'v8' is possibly undefined
// 417A43: variable 'i' is possibly undefined
// 417A59: variable 'v7' is possibly undefined
// 417A59: variable 'a4' is possibly undefined
// 417A59: variable 'a5' is possibly undefined
// 417A59: variable 'a6' is possibly undefined
// 417A5E: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417A70) ----------------------------------------------------
void *__fastcall camlList__split_248()
{
  __int64 *v0; // rax
  _QWORD *v1; // r15
  __int64 v2; // rdi
  __int64 *v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rbx
  __int64 i; // rsi
  void *result; // rax
  __int64 v11; // [rsp+0h] [rbp-18h]
  __int64 v12; // [rsp+8h] [rbp-10h]

  if ( v0 == (__int64 *)1 )
    return &camlList__41;
  v2 = *v0;
  v11 = *(_QWORD *)(*v0 + 8);
  v12 = *(_QWORD *)*v0;
  v3 = (__int64 *)camlList__split_248();
  v8 = v3[1];
  for ( i = *v3; ; caml_call_gc(v2, i, v4, v5, v6, v7, v11) )
  {
    v1 -= 9;
    if ( (unsigned __int64)v1 >= caml_young_limit )
      break;
  }
  *v1 = 2048LL;
  v1[1] = v11;
  v1[2] = v8;
  v1[3] = 2048LL;
  v1[4] = v12;
  v1[5] = i;
  result = v1 + 7;
  v1[6] = 2048LL;
  v1[7] = v1 + 4;
  v1[8] = v1 + 1;
  return result;
}
// 417A78: variable 'v0' is possibly undefined
// 417AA0: variable 'v1' is possibly undefined
// 417AC0: variable 'v11' is possibly undefined
// 417B04: variable 'v4' is possibly undefined
// 417B04: variable 'v5' is possibly undefined
// 417B04: variable 'v6' is possibly undefined
// 417B04: variable 'v7' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417B10) ----------------------------------------------------
__int64 __fastcall camlList__combine_254(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 *v6; // rax
  __int64 *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rsi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 i; // rdi
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 result; // rax
  __int64 v16; // [rsp+0h] [rbp-18h]
  __int64 v17; // [rsp+8h] [rbp-10h]

  if ( v6 == (__int64 *)1 )
  {
    if ( v7 == (__int64 *)1 )
      return 1LL;
LABEL_8:
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  }
  if ( v7 == (__int64 *)1 )
    goto LABEL_8;
  v17 = *v7;
  v9 = v6[1];
  v16 = *v6;
  for ( i = camlList__combine_254(*v6, v9, v7[1], a4, a5, a6); ; caml_call_gc(i, v9, v10, v11, v13, v14, v16) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 2048LL;
  v8[1] = v16;
  v8[2] = v17;
  result = (__int64)(v8 + 4);
  v8[3] = 2048LL;
  v8[4] = v8 + 1;
  v8[5] = i;
  return result;
}
// 417B18: variable 'v6' is possibly undefined
// 417B1E: variable 'v7' is possibly undefined
// 417B49: variable 'v8' is possibly undefined
// 417B69: variable 'v16' is possibly undefined
// 417BB4: variable 'v10' is possibly undefined
// 417BB4: variable 'v11' is possibly undefined
// 417BB4: variable 'v13' is possibly undefined
// 417BB4: variable 'v14' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417BC0) ----------------------------------------------------
__int64 *__fastcall camlList__merge_261(__int64 *a1)
{
  __int64 v1; // rax
  __int64 *v2; // rbx
  _QWORD *v3; // r15
  __int64 v4; // rsi
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 *j; // rdi
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 *i; // rdi
  __int64 v14; // r8
  __int64 v15; // r9
  char v16; // [rsp+0h] [rbp-38h]
  __int64 *v17; // [rsp+8h] [rbp-30h]
  __int64 v18; // [rsp+10h] [rbp-28h]
  __int64 v19; // [rsp+30h] [rbp-8h]

  if ( v2 == (__int64 *)1 )
    return a1;
  if ( a1 == (__int64 *)1 )
    return v2;
  v16 = (char)v2;
  v17 = (__int64 *)a1[1];
  v4 = *a1;
  v18 = *a1;
  v19 = *v2;
  if ( caml_apply2(v1) > 1 )
  {
    for ( i = camlList__merge_261(v17); ; caml_call_gc((__int64)i, v4, v11, v12, v14, v15, v16) )
    {
      v3 -= 3;
      if ( (unsigned __int64)v3 >= caml_young_limit )
        break;
    }
    *v3 = 2048LL;
    v3[1] = v18;
    v3[2] = i;
    return v3 + 1;
  }
  else
  {
    for ( j = camlList__merge_261(a1); ; caml_call_gc((__int64)j, v4, v5, v6, v8, v9, v16) )
    {
      v3 -= 3;
      if ( (unsigned __int64)v3 >= caml_young_limit )
        break;
    }
    *v3 = 2048LL;
    v3[1] = v19;
    v3[2] = j;
    return v3 + 1;
  }
}
// 417BCB: variable 'v2' is possibly undefined
// 417C11: variable 'v1' is possibly undefined
// 417C33: variable 'v3' is possibly undefined
// 417CC0: variable 'v11' is possibly undefined
// 417CC0: variable 'v12' is possibly undefined
// 417CC0: variable 'v14' is possibly undefined
// 417CC0: variable 'v15' is possibly undefined
// 417CC0: variable 'v16' is possibly undefined
// 417CC7: variable 'v5' is possibly undefined
// 417CC7: variable 'v6' is possibly undefined
// 417CC7: variable 'v8' is possibly undefined
// 417CC7: variable 'v9' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417CE0) ----------------------------------------------------
__int64 __fastcall camlList__chop_271(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  char v10; // [rsp+0h] [rbp-8h]

  while ( v6 != 1 )
  {
    if ( v7 == 1 )
    {
      while ( 1 )
      {
        v8 -= 3;
        if ( (unsigned __int64)v8 >= caml_young_limit )
        {
          *v8 = 2048LL;
          v8[1] = &caml_exn_Assert_failure;
          v8[2] = &camlList__39;
          caml_raise_exn();
        }
        caml_call_gc(a1, a2, a3, a4, a5, a6, v10);
      }
    }
    v7 = *(_QWORD *)(v7 + 8);
    v6 -= 2LL;
  }
  return v7;
}
// 417CE8: variable 'v6' is possibly undefined
// 417CEA: variable 'v7' is possibly undefined
// 417D04: variable 'v8' is possibly undefined
// 417D3A: variable 'a3' is possibly undefined
// 417D3A: variable 'a4' is possibly undefined
// 417D3A: variable 'a5' is possibly undefined
// 417D3A: variable 'a6' is possibly undefined
// 417D3A: variable 'v10' is possibly undefined
// 647C48: using guessed type char *caml_exn_Assert_failure;
// 6501D8: using guessed type char *camlList__39;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417D50) ----------------------------------------------------
_QWORD *__fastcall camlList__stable_sort_276(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rdi
  __int64 *v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  char v14; // [rsp+0h] [rbp-18h]
  __int64 v15; // [rsp+8h] [rbp-10h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v14) )
  {
    v7 -= 21;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 4343LL;
  v7[1] = caml_curry3;
  v7[2] = 7LL;
  v7[3] = camlList__rev_merge_279;
  v7[4] = i;
  v7[5] = 4343LL;
  v7[6] = caml_curry3;
  v7[7] = 7LL;
  v7[8] = camlList__rev_merge_rev_289;
  v7[9] = i;
  v7[10] = 10487LL;
  v7[11] = caml_curry2;
  v7[12] = 5LL;
  v7[13] = camlList__sort_299;
  v7[14] = 4345LL;
  v7[15] = caml_curry2;
  v7[16] = 5LL;
  v7[17] = camlList__rev_sort_300;
  v7[18] = i;
  v7[19] = v7 + 1;
  v7[20] = v7 + 6;
  if ( camlList__length_aux_58() >= 5 )
    return camlList__sort_299((__int64)(v7 + 11), v7 + 11, v9, v10, v11, v12);
  else
    return (_QWORD *)v15;
}
// 417D54: variable 'v6' is possibly undefined
// 417D5C: variable 'v7' is possibly undefined
// 417E3E: variable 'v15' is possibly undefined
// 417E55: variable 'v9' is possibly undefined
// 417E55: variable 'v10' is possibly undefined
// 417E55: variable 'v11' is possibly undefined
// 417E55: variable 'v12' is possibly undefined
// 417E5A: variable 'a3' is possibly undefined
// 417E5A: variable 'a4' is possibly undefined
// 417E5A: variable 'a5' is possibly undefined
// 417E5A: variable 'a6' is possibly undefined
// 417E5A: variable 'v14' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000417E70) ----------------------------------------------------
__int64 camlList__entry()
{
  camlList[41] = &camlList__38;
  camlList[0] = &camlList__37;
  camlList[1] = &camlList__36;
  camlList[2] = &camlList__35;
  camlList[3] = &camlList__34;
  camlList[5] = camlPervasives[21];
  camlList[6] = &camlList__33;
  camlList[4] = &camlList__32;
  camlList[8] = &camlList__31;
  camlList[7] = camlList[8];
  camlList[10] = &camlList__30;
  camlList[11] = &camlList__29;
  camlList[9] = &camlList__28;
  camlList[12] = &camlList__27;
  camlList[13] = &camlList__26;
  camlList[15] = &camlList__25;
  camlList[16] = &camlList__24;
  camlList[14] = &camlList__23;
  camlList[17] = &camlList__22;
  camlList[18] = &camlList__21;
  camlList[19] = &camlList__20;
  camlList[20] = &camlList__19;
  camlList[21] = &camlList__18;
  camlList[22] = &camlList__17;
  camlList[23] = &camlList__16;
  camlList[24] = &camlList__15;
  camlList[29] = &camlList__14;
  camlList[30] = &camlList__13;
  camlList[31] = &camlList__12;
  camlList[32] = &camlList__11;
  camlList[33] = &camlList__10;
  camlList[34] = &camlList__9;
  camlList[25] = &camlList__8;
  camlList[27] = &camlList__7;
  camlList[26] = camlList[27];
  camlList[28] = &camlList__6;
  camlList[35] = &camlList__5;
  camlList[36] = &camlList__4;
  camlList[40] = &camlList__3;
  camlList[42] = &camlList__2;
  camlList[38] = &camlList__1;
  camlList[37] = camlList[38];
  camlList[39] = camlList[38];
  return 1LL;
}
// 64CDA0: using guessed type _QWORD camlPervasives[84];
// 64FBD0: using guessed type _QWORD camlList[44];
// 64FD30: using guessed type __int64 (__fastcall *camlList__1)();
// 64FD50: using guessed type __int64 (__fastcall *camlList__2)();
// 64FD70: using guessed type __int64 (__fastcall *camlList__3)();
// 64FD90: using guessed type __int64 (__fastcall *camlList__4)();
// 64FDB0: using guessed type __int64 (__fastcall *camlList__5)();
// 64FDC8: using guessed type __int64 (__fastcall *camlList__6)();
// 64FDE8: using guessed type __int64 (__fastcall *camlList__7)();
// 64FE00: using guessed type __int64 (__fastcall *camlList__8)();
// 64FE20: using guessed type __int64 (__fastcall *camlList__9)();
// 64FE40: using guessed type __int64 (__fastcall *camlList__10)();
// 64FE60: using guessed type __int64 (__fastcall *camlList__11)();
// 64FE80: using guessed type __int64 (__fastcall *camlList__12)();
// 64FEA0: using guessed type __int64 (__fastcall *camlList__13)();
// 64FEC0: using guessed type __int64 (__fastcall *camlList__14)();
// 64FEE0: using guessed type __int64 (__fastcall *camlList__15)();
// 64FF00: using guessed type __int64 (__fastcall *camlList__16)();
// 64FF20: using guessed type __int64 (__fastcall *camlList__17)();
// 64FF40: using guessed type __int64 (__fastcall *camlList__18)();
// 64FF60: using guessed type __int64 (__fastcall *camlList__19)();
// 64FF80: using guessed type __int64 (__fastcall *camlList__20)();
// 64FFA0: using guessed type __int64 (__fastcall *camlList__21)();
// 64FFC0: using guessed type __int64 (__fastcall *camlList__22)();
// 64FFE0: using guessed type __int64 (__fastcall *camlList__23)();
// 650000: using guessed type __int64 (__fastcall *camlList__24)();
// 650020: using guessed type __int64 (__fastcall *camlList__25)();
// 650040: using guessed type __int64 (__fastcall *camlList__26)();
// 650060: using guessed type __int64 (__fastcall *camlList__27)();
// 650080: using guessed type __int64 (__fastcall *camlList__28)();
// 6500A0: using guessed type __int64 (__fastcall *camlList__29)();
// 6500C0: using guessed type __int64 (__fastcall *camlList__30)();
// 6500E0: using guessed type __int64 (__fastcall *camlList__31)();
// 6500F8: using guessed type __int64 (__fastcall *camlList__32)();
// 650110: using guessed type __int64 (__fastcall *camlList__33)();
// 650130: using guessed type __int64 (__fastcall *camlList__34)();
// 650150: using guessed type __int64 (__fastcall *camlList__35)();
// 650168: using guessed type __int64 (__fastcall *camlList__36)();
// 650180: using guessed type __int64 (__fastcall *camlList__37)();
// 650198: using guessed type __int64 (__fastcall *camlList__38)();

//----- (00000000004181F0) ----------------------------------------------------
__int64 __fastcall camlChar__code_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax

  if ( result < 1 || result > 511 )
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  return result;
}
// 4181F4: variable 'result' is possibly undefined

//----- (0000000000418210) ----------------------------------------------------
void __fastcall camlChar__escaped_66(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  _BYTE *v4; // rax
  _BYTE *v5; // rax
  __int64 v6; // [rsp+0h] [rbp-8h]

  if ( v2 != 79 && v2 != 185 )
  {
    v6 = v2;
    if ( v2 >= 29 )
    {
LABEL_7:
      caml_c_call(v2, a2);
      if ( v3 == 1 )
      {
        caml_c_call(9LL, a2);
        *v5 = 92;
        v5[1] = (2 * ((v6 >> 1) / 100) + 97) >> 1;
        v5[2] = (2 * ((v6 >> 1) / 10 % 10) + 97) >> 1;
        v5[3] = (2 * ((v6 >> 1) % 10) + 97) >> 1;
      }
      else
      {
        caml_c_call(3LL, a2);
        *v4 = v6 >> 1;
      }
    }
    else
    {
      switch ( v2 >> 1 )
      {
        case 0LL:
        case 1LL:
        case 2LL:
        case 3LL:
        case 4LL:
        case 5LL:
        case 6LL:
        case 7LL:
        case 11LL:
        case 12LL:
          goto LABEL_7;
        case 8LL:
        case 9LL:
        case 10LL:
        case 13LL:
          return;
      }
    }
  }
}
// 41821B: variable 'v2' is possibly undefined
// 4182A0: variable 'v3' is possibly undefined
// 4182BC: variable 'v4' is possibly undefined
// 4182E9: variable 'v5' is possibly undefined

//----- (0000000000418360) ----------------------------------------------------
__int64 __fastcall camlChar__lowercase_71()
{
  __int64 result; // rax

  if ( result >= 131 && result <= 181 || result >= 385 && result <= 429 || result >= 433 && result <= 445 )
    result += 64LL;
  return result;
}
// 418366: variable 'result' is possibly undefined
// 418360: using guessed type __int64 __fastcall camlChar__lowercase_71();

//----- (00000000004183A0) ----------------------------------------------------
__int64 __fastcall camlChar__uppercase_73()
{
  __int64 result; // rax

  if ( result >= 195 && result <= 245 || result >= 449 && result <= 493 || result >= 497 && result <= 509 )
    result -= 64LL;
  return result;
}
// 4183A6: variable 'result' is possibly undefined
// 4183A0: using guessed type __int64 __fastcall camlChar__uppercase_73();

//----- (00000000004183E0) ----------------------------------------------------
__int64 __fastcall camlChar__compare_76()
{
  __int64 v0; // rax
  __int64 v1; // rbx

  return v0 - v1 + 1;
}
// 4183E0: variable 'v0' is possibly undefined
// 4183E0: variable 'v1' is possibly undefined
// 4183E0: using guessed type __int64 __fastcall camlChar__compare_76();

//----- (00000000004183F0) ----------------------------------------------------
__int64 camlChar__entry()
{
  camlChar[0] = &camlChar__5;
  camlChar[1] = &camlChar__4;
  camlChar[2] = &camlChar__3;
  camlChar[3] = &camlChar__2;
  camlChar[4] = &camlChar__1;
  return 1LL;
}
// 650D28: using guessed type _QWORD camlChar[6];
// 650D58: using guessed type __int64 (__fastcall *camlChar__1)();
// 650D78: using guessed type __int64 (__fastcall *camlChar__2)();
// 650D90: using guessed type __int64 (__fastcall *camlChar__3)();
// 650DA8: using guessed type __int64 (__fastcall *camlChar__4)();
// 650DC0: using guessed type __int64 (__fastcall *camlChar__5)();

//----- (0000000000418460) ----------------------------------------------------
__int64 __fastcall camlString__code_begin()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v2; // rdi

  **(_QWORD **)(v1 + 16) += 2LL;
  v2 = 8LL * (*(_QWORD *)(v0 - 8) >> 10) - 1;
  **(_QWORD **)(v1 + 24) += 2 * (v2 - *(unsigned __int8 *)(v0 + v2));
  return 1LL;
}
// 418460: variable 'v1' is possibly undefined
// 41846C: variable 'v0' is possibly undefined
// 418460: using guessed type __int64 __fastcall camlString__code_begin();

//----- (00000000004184A0) ----------------------------------------------------
__int64 __fastcall camlString__fun_191()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v2; // rbp
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rsi
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v8; // rdi

  v2 = v0;
  v3 = *(_QWORD *)(v1 + 16);
  v4 = 8LL * (*(_QWORD *)(v3 - 8) >> 10) - 1;
  caml_blit_string(v3, 1LL, *(_QWORD *)(v1 + 24), **(_QWORD **)(v1 + 32), 2 * (v4 - *(unsigned __int8 *)(v3 + v4)) + 1);
  v5 = *(_QWORD *)(v1 + 16);
  v6 = 8LL * (*(_QWORD *)(v5 - 8) >> 10) - 1;
  **(_QWORD **)(v1 + 32) += 2 * (v6 - *(unsigned __int8 *)(v5 + v6));
  v7 = 8LL * (*(_QWORD *)(v2 - 8) >> 10) - 1;
  caml_blit_string(v2, 1LL, *(_QWORD *)(v1 + 24), **(_QWORD **)(v1 + 32), 2 * (v7 - *(unsigned __int8 *)(v2 + v7)) + 1);
  v8 = 8LL * (*(_QWORD *)(v2 - 8) >> 10) - 1;
  **(_QWORD **)(v1 + 32) += 2 * (v8 - *(unsigned __int8 *)(v2 + v8));
  return 1LL;
}
// 4184A4: variable 'v0' is possibly undefined
// 4184A7: variable 'v1' is possibly undefined
// 4184A0: using guessed type __int64 __fastcall camlString__fun_191();

//----- (0000000000418580) ----------------------------------------------------
__int64 __fastcall camlString__make_66(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v7; // [rsp+0h] [rbp-18h]
  __int64 v8; // [rsp+8h] [rbp-10h]

  v7 = v2;
  v8 = v3;
  caml_c_call(v2, a2);
  v5 = v4;
  caml_fill_string(v4, 1LL, v7, v8);
  return v5;
}
// 418584: variable 'v2' is possibly undefined
// 418588: variable 'v3' is possibly undefined
// 41859C: variable 'v4' is possibly undefined

//----- (00000000004185C0) ----------------------------------------------------
__int64 __fastcall camlString__copy_70(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v7; // [rsp+0h] [rbp-18h]
  __int64 v8; // [rsp+8h] [rbp-10h]

  v7 = v2;
  v3 = 8LL * (*(_QWORD *)(v2 - 8) >> 10) - 1;
  v8 = 2 * (v3 - *(unsigned __int8 *)(v7 + v3)) + 1;
  caml_c_call(v8, a2);
  v5 = v4;
  caml_blit_string(v7, 1LL, v4, 1LL, v8);
  return v5;
}
// 4185C7: variable 'v2' is possibly undefined
// 4185F9: variable 'v4' is possibly undefined

//----- (0000000000418630) ----------------------------------------------------
__int64 __fastcall camlString__sub_74(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 v12; // [rsp+0h] [rbp-18h]
  __int64 v13; // [rsp+8h] [rbp-10h]

  if ( v7 < 1
    || a1 < 1
    || (v8 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1,
        a3 = *(unsigned __int8 *)(v6 + v8),
        a2 = 2 * (v8 - a3) - a1 + 2,
        v7 > a2) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  }
  v13 = v7;
  v12 = v6;
  caml_c_call(a1, a2);
  v10 = v9;
  caml_blit_string(v12, v13, v9, 1LL, a1);
  return v10;
}
// 418638: variable 'v7' is possibly undefined
// 418640: variable 'v6' is possibly undefined
// 418681: variable 'v9' is possibly undefined

//----- (00000000004186C0) ----------------------------------------------------
__int64 __fastcall camlString__fill_79(
        float a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7)
{
  __int64 v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rdi

  v9 = a2;
  v10 = a3;
  if ( v8 < 1
    || a2 < 1
    || (v11 = 8LL * (*(_QWORD *)(v7 - 8) >> 10) - 1,
        a3 = *(unsigned __int8 *)(v7 + v11),
        a2 = 2 * (v11 - a3) - v9 + 2,
        v8 > a2) )
  {
    camlPervasives__invalid_arg_40(a2, a3, v9, v10, a6, a7);
  }
  return caml_fill_string(v7, v8, v9, v10);
}
// 4186CE: variable 'v8' is possibly undefined
// 4186D6: variable 'v7' is possibly undefined

//----- (0000000000418720) ----------------------------------------------------
__int64 __fastcall camlString__blit_84(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  __int64 v5; // r9
  __int64 v6; // rcx
  __int64 v7; // rdi
  __int64 v8; // rdi

  v5 = a1;
  v6 = a2;
  if ( a3 < 1
    || v4 < 1
    || (v7 = 8LL * (*(_QWORD *)(v3 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v3 + v7),
        a1 = 2 * (v7 - a2) - a3 + 2,
        v4 > a1)
    || v6 < 1
    || (v8 = 8LL * (*(_QWORD *)(v5 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v5 + v8),
        a1 = 2 * (v8 - a2) - a3 + 2,
        v6 > a1) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, v6, a3, v5);
  }
  return caml_blit_string(v3, v4, v5, v6, a3);
}
// 418737: variable 'v4' is possibly undefined
// 418739: variable 'v3' is possibly undefined

//----- (00000000004187B0) ----------------------------------------------------
__int64 __fastcall camlString__iter_90()
{
  void (**v0)(void); // rax
  __int64 v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rdi
  __int64 v4; // rdi
  void (**v6)(void); // [rsp+8h] [rbp-20h]
  __int64 v7; // [rsp+10h] [rbp-18h]
  __int64 v8; // [rsp+18h] [rbp-10h]

  v2 = 8LL * (*(_QWORD *)(v1 - 8) >> 10) - 1;
  v3 = 2 * (v2 - *(unsigned __int8 *)(v1 + v2)) - 1;
  if ( v3 >= 1 )
  {
    v8 = v3;
    v7 = 1LL;
    v6 = v0;
    do
    {
      (*v6)();
      v4 = v7;
      v7 += 2LL;
    }
    while ( v4 != v8 );
  }
  return 1LL;
}
// 4187BE: variable 'v1' is possibly undefined
// 4187EE: variable 'v0' is possibly undefined
// 4187B0: using guessed type __int64 __fastcall camlString__iter_90();

//----- (0000000000418840) ----------------------------------------------------
void *__fastcall camlString__concat_94(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rbp
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rax
  char v19; // [rsp+0h] [rbp-28h]
  __int64 v20; // [rsp+0h] [rbp-28h]
  __int64 v21; // [rsp+10h] [rbp-18h]
  __int64 v22; // [rsp+18h] [rbp-10h]

  if ( v7 == (__int64 *)1 )
    return &camlString__29;
  v22 = v6;
  v21 = *v7;
  while ( 1 )
  {
    v8 -= 9;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(a1, a2, a3, a4, a5, a6, v19);
  }
  *v8 = 1024LL;
  v8[1] = 1LL;
  v8[2] = 1024LL;
  v8[3] = 1LL;
  v8[4] = 4343LL;
  v8[5] = camlString__code_begin;
  v8[6] = 3LL;
  v8[7] = v8 + 1;
  v8[8] = v8 + 3;
  camlList__iter_102();
  v9 = 8LL * (*(_QWORD *)(v22 - 8) >> 10) - 1;
  caml_c_call(((v8[1] - 2LL) >> 1) * 2 * (v9 - *(unsigned __int8 *)(v22 + v9)) + v8[3], (unsigned __int64)(v8 + 3));
  v11 = v10;
  v20 = v10;
  v12 = 8LL * (*(_QWORD *)(v21 - 8) >> 10) - 1;
  caml_blit_string(v21, 1LL, v20, 1LL, 2 * (v12 - *(unsigned __int8 *)(v21 + v12)) + 1);
  while ( 1 )
  {
    v8 -= 8;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(v21, 1LL, v13, v14, v15, v16, v20);
  }
  *v8 = 1024LL;
  v17 = 8LL * (*(_QWORD *)(v21 - 8) >> 10) - 1;
  v8[1] = 2 * (v17 - *(unsigned __int8 *)(v21 + v17)) + 1;
  v8[2] = 5367LL;
  v8[3] = camlString__fun_191;
  v8[4] = 3LL;
  v8[5] = v22;
  v8[6] = v11;
  v8[7] = v8 + 1;
  camlList__iter_102();
  return (void *)v20;
}
// 418848: variable 'v7' is possibly undefined
// 41884E: variable 'v6' is possibly undefined
// 418864: variable 'v8' is possibly undefined
// 41891B: variable 'v10' is possibly undefined
// 4189D2: variable 'v20' is possibly undefined
// 4189E8: variable 'v13' is possibly undefined
// 4189E8: variable 'v14' is possibly undefined
// 4189E8: variable 'v15' is possibly undefined
// 4189E8: variable 'v16' is possibly undefined
// 4189F2: variable 'a3' is possibly undefined
// 4189F2: variable 'a4' is possibly undefined
// 4189F2: variable 'a5' is possibly undefined
// 4189F2: variable 'a6' is possibly undefined
// 4189F2: variable 'v19' is possibly undefined
// 418460: using guessed type __int64 __fastcall camlString__code_begin();
// 4184A0: using guessed type __int64 __fastcall camlString__fun_191();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000418A00) ----------------------------------------------------
__int64 __fastcall camlString__escaped_108(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rsi
  __int64 *v9; // rbx
  __int64 v10; // rdi
  __int64 v11; // rax
  unsigned __int64 v12; // rsi
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rdi
  __int64 v16; // rax
  __int64 v17; // rdi
  __int64 result; // rax
  __int64 v19; // rdi
  unsigned __int64 v20; // rsi
  __int64 v21; // rax
  __int64 v22; // r8
  __int64 *v23; // rsi
  __int64 v24; // rbx
  __int64 v25; // rdi
  __int64 v26; // rdi
  __int64 v27; // rbx
  __int64 v28; // rdi
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // rdi
  char v32; // [rsp+0h] [rbp-38h]
  __int64 v33; // [rsp+0h] [rbp-38h]
  __int64 v34; // [rsp+0h] [rbp-38h]
  __int64 v35; // [rsp+8h] [rbp-30h]
  __int64 v36; // [rsp+8h] [rbp-30h]
  __int64 v37; // [rsp+10h] [rbp-28h]
  __int64 v38; // [rsp+18h] [rbp-20h]
  __int64 v39; // [rsp+20h] [rbp-18h]
  __int64 *v40; // [rsp+28h] [rbp-10h]

  v8 = v6;
  v39 = v6;
  while ( 1 )
  {
    v7 -= 2;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc(a1, v8, a3, a4, a5, a6, v32);
  }
  v9 = v7 + 1;
  *v7 = 1024LL;
  v7[1] = 1LL;
  v10 = 1LL;
  v11 = 8LL * (*(_QWORD *)(v8 - 8) >> 10) - 1;
  v12 = *(unsigned __int8 *)(v8 + v11);
  v13 = 2 * (v11 - v12) - 1;
  if ( v13 >= 1 )
  {
    v35 = v13;
    v33 = 1LL;
    do
    {
      v14 = *(unsigned __int8 *)(v39 + (v10 >> 1));
      v15 = 2 * v14 + 1;
      if ( v15 < 29 )
      {
        if ( v15 < 23 )
        {
          if ( v15 < 17 )
            goto LABEL_13;
        }
        else if ( v15 < 27 )
        {
          goto LABEL_13;
        }
      }
      else if ( 2 * v14 != 68 && 2 * v14 != 184 )
      {
LABEL_13:
        caml_c_call(v15, v12);
        if ( v16 == 1 )
          v17 = 9LL;
        else
          v17 = 3LL;
        goto LABEL_17;
      }
      v17 = 5LL;
LABEL_17:
      v9 = v7 + 1;
      v7[1] = v17 + v7[1] - 1;
      v12 = v33;
      v10 = v33 + 2;
      v33 += 2LL;
    }
    while ( v12 != v35 );
  }
  result = v39;
  v19 = 8LL * (*(_QWORD *)(v39 - 8) >> 10) - 1;
  v20 = 2 * (v19 - *(unsigned __int8 *)(v39 + v19)) + 1;
  if ( *v9 != v20 )
  {
    caml_c_call(*v9, v20);
    v22 = v21;
    v23 = v9;
    *v9 = 1LL;
    v24 = 1LL;
    v25 = 8LL * (*(_QWORD *)(v39 - 8) >> 10) - 1;
    v26 = 2 * (v25 - *(unsigned __int8 *)(v39 + v25)) - 1;
    if ( v26 >= 1 )
    {
      v36 = v26;
      v34 = 1LL;
      v38 = v21;
      v40 = v23;
      while ( 1 )
      {
        v27 = v24 >> 1;
        v28 = 2LL * *(unsigned __int8 *)(v39 + v27) + 1;
        v29 = 2LL * *(unsigned __int8 *)(v39 + v27) - 67;
        if ( (unsigned __int64)v29 > 0x75 )
          break;
        if ( 2 * (unsigned __int64)*(unsigned __int8 *)(v39 + v27) - 69 <= 0x71 )
          goto LABEL_30;
        *(_BYTE *)(v22 + (*v23 >> 1)) = 92;
        *v23 += 2LL;
        *(_BYTE *)(v22 + (*v23 >> 1)) = v28 >> 1;
LABEL_33:
        *v23 += 2LL;
        v31 = v34;
        v24 = v34 + 2;
        v34 += 2LL;
        if ( v31 == v36 )
          return v22;
      }
      if ( v29 < -39 )
      {
        switch ( (v29 + 68) >> 1 )
        {
          case 0LL:
          case 1LL:
          case 2LL:
          case 3LL:
          case 4LL:
          case 5LL:
          case 6LL:
          case 7LL:
          case 11LL:
          case 12LL:
            goto LABEL_30;
          case 8LL:
            *(_BYTE *)(v22 + (*v23 >> 1)) = 92;
            *v23 += 2LL;
            *(_BYTE *)(v22 + (*v23 >> 1)) = 98;
            break;
          case 9LL:
            *(_BYTE *)(v22 + (*v23 >> 1)) = 92;
            *v23 += 2LL;
            *(_BYTE *)(v22 + (*v23 >> 1)) = 116;
            break;
          case 10LL:
            *(_BYTE *)(v22 + (*v23 >> 1)) = 92;
            *v23 += 2LL;
            *(_BYTE *)(v22 + (*v23 >> 1)) = 110;
            break;
          case 13LL:
            *(_BYTE *)(v22 + (*v23 >> 1)) = 92;
            *v23 += 2LL;
            *(_BYTE *)(v22 + (*v23 >> 1)) = 114;
            break;
        }
        goto LABEL_33;
      }
LABEL_30:
      v37 = 2LL * *(unsigned __int8 *)(v39 + v27) + 1;
      caml_c_call(v28, (unsigned __int64)v23);
      v23 = v40;
      v22 = v38;
      if ( v30 == 1 )
      {
        *(_BYTE *)(v38 + (*v40 >> 1)) = 92;
        *v40 += 2LL;
        *(_BYTE *)(v38 + (*v40 >> 1)) = (2 * ((v37 >> 1) / 100) + 97) >> 1;
        *v40 += 2LL;
        *(_BYTE *)(v38 + (*v40 >> 1)) = (2 * ((v37 >> 1) / 10 % 10) + 97) >> 1;
        *v40 += 2LL;
        *(_BYTE *)(v38 + (*v40 >> 1)) = (2 * ((v37 >> 1) % 10) + 97) >> 1;
      }
      else
      {
        *(_BYTE *)(v38 + (*v40 >> 1)) = v37 >> 1;
      }
      goto LABEL_33;
    }
    return v22;
  }
  return result;
}
// 418A04: variable 'v6' is possibly undefined
// 418A0C: variable 'v7' is possibly undefined
// 418ABE: variable 'v16' is possibly undefined
// 418B55: variable 'v21' is possibly undefined
// 418CED: variable 'v30' is possibly undefined
// 418DE0: variable 'a3' is possibly undefined
// 418DE0: variable 'a4' is possibly undefined
// 418DE0: variable 'a5' is possibly undefined
// 418DE0: variable 'a6' is possibly undefined
// 418DE0: variable 'v32' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000418DF0) ----------------------------------------------------
__int64 __fastcall camlString__map_118()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx
  __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v9; // [rsp+0h] [rbp-28h]
  _QWORD *v10; // [rsp+10h] [rbp-18h]
  __int64 v11; // [rsp+18h] [rbp-10h]

  v2 = 8LL * (*(_QWORD *)(v1 - 8) >> 10) - 1;
  v3 = *(unsigned __int8 *)(v1 + v2);
  v4 = 2 * (v2 - v3) + 1;
  if ( v4 == 1 )
    return v1;
  v10 = v0;
  caml_c_call(v4, v3);
  v7 = v6;
  if ( v4 - 2 >= 1 )
  {
    v9 = 1LL;
    v11 = v6;
    do
    {
      v8 = ((__int64 (__fastcall *)(_QWORD, unsigned __int64, __int64))*v10)(*v10, v3, v7);
      v7 = v11;
      *(_BYTE *)(v11 + (v9 >> 1)) = v8 >> 1;
      v3 = v9;
      v9 += 2LL;
    }
    while ( v3 != v4 - 2 );
  }
  return v7;
}
// 418DF4: variable 'v1' is possibly undefined
// 418E29: variable 'v0' is possibly undefined
// 418E3A: variable 'v6' is possibly undefined

//----- (0000000000418EB0) ----------------------------------------------------
__int64 camlString__uppercase_124()
{
  return camlString__map_118();
}
// 418EB0: using guessed type __int64 __fastcall camlString__uppercase_124();

//----- (0000000000418ED0) ----------------------------------------------------
__int64 camlString__lowercase_126()
{
  return camlString__map_118();
}
// 418ED0: using guessed type __int64 __fastcall camlString__lowercase_126();

//----- (0000000000418EF0) ----------------------------------------------------
_BYTE *__fastcall camlString__apply1_128()
{
  __int64 (**v0)(void); // rax
  __int64 v1; // rbx
  __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 v4; // rdi
  _BYTE *result; // rax
  __int64 v6; // rbx
  __int64 (**v7)(void); // [rsp+8h] [rbp-10h]
  _BYTE *v8; // [rsp+10h] [rbp-8h]

  v2 = 8LL * (*(_QWORD *)(v1 - 8) >> 10) - 1;
  v3 = *(unsigned __int8 *)(v1 + v2);
  v4 = 2 * (v2 - v3) + 1;
  if ( v4 == 1 )
    return (_BYTE *)v1;
  v7 = v0;
  v8 = (_BYTE *)camlString__copy_70(v4, v3);
  v6 = (*v7)() >> 1;
  result = v8;
  *v8 = v6;
  return result;
}
// 418EF4: variable 'v1' is possibly undefined
// 418F24: variable 'v0' is possibly undefined

//----- (0000000000418F60) ----------------------------------------------------
_BYTE *camlString__capitalize_132()
{
  return camlString__apply1_128();
}

//----- (0000000000418F80) ----------------------------------------------------
_BYTE *camlString__uncapitalize_134()
{
  return camlString__apply1_128();
}

//----- (0000000000418FA0) ----------------------------------------------------
__int64 __fastcall camlString__index_rec_136(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  char **v7; // rbx
  _QWORD *v8; // r15
  char v10; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    if ( a1 >= (__int64)v7 )
    {
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(a1, a2, a3, a4, a5, a6, v10);
      }
      *v8 = 1024LL;
      v7 = &caml_exn_Not_found;
      v8[1] = &caml_exn_Not_found;
      v6 = caml_raise_exn();
    }
    a3 = 2LL * *(unsigned __int8 *)(v6 + (a1 >> 1)) + 1;
    if ( a3 == a2 )
      break;
    a1 += 2LL;
  }
  return a1;
}
// 418FA7: variable 'v7' is possibly undefined
// 418FA9: variable 'v8' is possibly undefined
// 418FDA: variable 'v6' is possibly undefined
// 418FFA: variable 'a3' is possibly undefined
// 418FFA: variable 'a4' is possibly undefined
// 418FFA: variable 'a5' is possibly undefined
// 418FFA: variable 'a6' is possibly undefined
// 418FFA: variable 'v10' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000419010) ----------------------------------------------------
__int64 __fastcall camlString__index_141(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx

  return camlString__index_rec_136(
           1LL,
           v7,
           *(unsigned __int8 *)(v6 + 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1),
           a4,
           a5,
           a6);
}
// 419037: variable 'v7' is possibly undefined
// 41902A: variable 'v6' is possibly undefined

//----- (0000000000419040) ----------------------------------------------------
__int64 __fastcall camlString__index_from_144(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v10; // rbx
  __int64 v11; // rdi
  __int64 v12; // rbx

  v8 = v7;
  v10 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1;
  v11 = *(unsigned __int8 *)(v6 + v10);
  v12 = 2 * (v10 - v11) + 1;
  if ( v8 < 1 || v8 > v12 )
    camlPervasives__invalid_arg_40(v11, a1, v8, a4, a5, a6);
  return camlString__index_rec_136(v8, a1, v8, a4, a5, a6);
}
// 419040: variable 'v7' is possibly undefined
// 419046: variable 'v6' is possibly undefined

//----- (0000000000419090) ----------------------------------------------------
__int64 __fastcall camlString__rindex_rec_149(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  char v10; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    if ( v7 < 1 )
    {
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(a1, a2, a3, a4, a5, a6, v10);
      }
      *v8 = 1024LL;
      v7 = (__int64)&caml_exn_Not_found;
      v8[1] = &caml_exn_Not_found;
      v6 = caml_raise_exn();
    }
    a2 = 2LL * *(unsigned __int8 *)(v6 + (v7 >> 1)) + 1;
    if ( a2 == a1 )
      break;
    v7 -= 2LL;
  }
  return v7;
}
// 419098: variable 'v7' is possibly undefined
// 41909A: variable 'v8' is possibly undefined
// 4190CE: variable 'v6' is possibly undefined
// 4190EE: variable 'a3' is possibly undefined
// 4190EE: variable 'a4' is possibly undefined
// 4190EE: variable 'a5' is possibly undefined
// 4190EE: variable 'a6' is possibly undefined
// 4190EE: variable 'v10' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000419100) ----------------------------------------------------
__int64 __fastcall camlString__rindex_153(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx

  return camlString__rindex_rec_149(
           v7,
           *(unsigned __int8 *)(v6 + 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1),
           a3,
           a4,
           a5,
           a6);
}
// 419120: variable 'v7' is possibly undefined
// 419113: variable 'v6' is possibly undefined

//----- (0000000000419130) ----------------------------------------------------
__int64 __fastcall camlString__rindex_from_156(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rsi

  if ( v7 < -1
    || (v8 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1, a3 = *(unsigned __int8 *)(v6 + v8), a2 = 2 * (v8 - a3) + 1, v7 >= a2) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  }
  return camlString__rindex_rec_149(a1, a2, a3, a4, a5, a6);
}
// 419134: variable 'v7' is possibly undefined
// 419136: variable 'v6' is possibly undefined

//----- (0000000000419170) ----------------------------------------------------
__int64 __fastcall camlString__contains_from_160(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v10; // rbx
  __int64 v11; // rdi
  __int64 v12; // rbx
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9

  v8 = v7;
  v10 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1;
  v11 = *(unsigned __int8 *)(v6 + v10);
  v12 = 2 * (v10 - v11) + 1;
  if ( v8 < 1 || v8 > v12 )
    camlPervasives__invalid_arg_40(v11, a1, v8, a4, a5, a6);
  if ( *(char ***)sub_4191CC(v11, a1, v8, a4, a5, a6) == &caml_exn_Not_found )
    return 1LL;
  caml_raise_exn();
  return sub_4191CC((__int64)&caml_exn_Not_found, a1, v14, v15, v16, v17);
}
// 419174: variable 'v7' is possibly undefined
// 41917A: variable 'v6' is possibly undefined
// 4191CA: variable 'v14' is possibly undefined
// 4191CA: variable 'v15' is possibly undefined
// 4191CA: variable 'v16' is possibly undefined
// 4191CA: variable 'v17' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;

//----- (00000000004191CC) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_4191CC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  camlString__index_rec_136(a3, a2, a3, a4, a5, a6);
  return 3LL;
}
// 4191EA: positive sp value 10 has been found

//----- (0000000000419200) ----------------------------------------------------
__int64 __fastcall camlString__contains_165(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx

  return camlString__contains_from_160(v6, a2, a3, a4, a5, a6);
}
// 41920A: variable 'v6' is possibly undefined

//----- (0000000000419210) ----------------------------------------------------
__int64 __fastcall camlString__rcontains_from_168(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rsi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9

  if ( v7 < 1
    || (v8 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1, a3 = *(unsigned __int8 *)(v6 + v8), a2 = 2 * (v8 - a3) + 1, v7 >= a2) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  }
  if ( *(char ***)sub_419264(a1, a2, a3, a4, a5, a6) == &caml_exn_Not_found )
    return 1LL;
  caml_raise_exn();
  return sub_419264((__int64)&caml_exn_Not_found, a2, v10, v11, v12, v13);
}
// 419218: variable 'v7' is possibly undefined
// 41921A: variable 'v6' is possibly undefined
// 419262: variable 'v10' is possibly undefined
// 419262: variable 'v11' is possibly undefined
// 419262: variable 'v12' is possibly undefined
// 419262: variable 'v13' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;

//----- (0000000000419264) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_419264(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  camlString__rindex_rec_149(a1, a2, a3, a4, a5, a6);
  return 3LL;
}
// 41927F: positive sp value 10 has been found

//----- (0000000000419290) ----------------------------------------------------
void __fastcall camlString__compare_173()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 4192A1: variable 'v0' is possibly undefined
// 4192A1: variable 'v1' is possibly undefined

//----- (00000000004192B0) ----------------------------------------------------
__int64 camlString__entry()
{
  camlString[0] = &camlString__24;
  camlString[1] = &camlString__23;
  camlString[2] = &camlString__22;
  camlString[3] = &camlString__21;
  camlString[4] = &camlString__20;
  camlString[6] = &camlString__19;
  camlString[5] = &camlString__18;
  camlString[7] = &camlString__17;
  camlString[20] = &camlString__16;
  camlString[15] = &camlString__15;
  camlString[16] = &camlString__14;
  camlString[21] = &camlString__13;
  camlString[17] = &camlString__12;
  camlString[18] = &camlString__11;
  camlString[22] = &camlString__10;
  camlString[8] = &camlString__9;
  camlString[10] = &camlString__8;
  camlString[23] = &camlString__7;
  camlString[9] = &camlString__6;
  camlString[11] = &camlString__5;
  camlString[13] = &camlString__4;
  camlString[12] = &camlString__3;
  camlString[14] = &camlString__2;
  camlString[19] = &camlString__1;
  return 1LL;
}
// 650EC0: using guessed type _QWORD camlString[25];
// 650F88: using guessed type __int64 (__fastcall *camlString__1)();
// 650FA8: using guessed type __int64 (__fastcall *camlString__2)();
// 650FC8: using guessed type __int64 (__fastcall *camlString__3)();
// 650FE8: using guessed type __int64 (__fastcall *camlString__4)();
// 651008: using guessed type __int64 (__fastcall *camlString__5)();
// 651028: using guessed type __int64 (__fastcall *camlString__6)();
// 651048: using guessed type __int64 (__fastcall *camlString__7)();
// 651068: using guessed type __int64 (__fastcall *camlString__8)();
// 651088: using guessed type __int64 (__fastcall *camlString__9)();
// 6510A8: using guessed type __int64 (__fastcall *camlString__10)();
// 6510C8: using guessed type __int64 (__fastcall *camlString__11)();
// 6510E0: using guessed type __int64 (__fastcall *camlString__12)();
// 6510F8: using guessed type __int64 (__fastcall *camlString__13)();
// 651118: using guessed type __int64 (__fastcall *camlString__14)();
// 651130: using guessed type __int64 (__fastcall *camlString__15)();
// 651148: using guessed type __int64 (__fastcall *camlString__16)();
// 651168: using guessed type __int64 (__fastcall *camlString__17)();
// 651180: using guessed type __int64 (__fastcall *camlString__18)();
// 6511A0: using guessed type __int64 (__fastcall *camlString__19)();
// 6511C0: using guessed type __int64 (__fastcall *camlString__20)();
// 6511E0: using guessed type __int64 (__fastcall *camlString__21)();
// 651200: using guessed type __int64 (__fastcall *camlString__22)();
// 651220: using guessed type __int64 (__fastcall *camlString__23)();
// 651238: using guessed type __int64 (__fastcall *camlString__24)();

//----- (0000000000419480) ----------------------------------------------------
void __fastcall __noreturn camlSys__code_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // r15
  char v7; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    v6 -= 2;
    if ( (unsigned __int64)v6 >= caml_young_limit )
    {
      *v6 = 1024LL;
      v6[1] = camlSys[29];
      caml_raise_exn();
    }
    caml_call_gc(a1, a2, a3, a4, a5, a6, v7);
  }
}
// 419484: variable 'v6' is possibly undefined
// 4194B6: variable 'a3' is possibly undefined
// 4194B6: variable 'a4' is possibly undefined
// 4194B6: variable 'a5' is possibly undefined
// 4194B6: variable 'a6' is possibly undefined
// 4194B6: variable 'v7' is possibly undefined
// 6515D0: using guessed type __int64 camlSys[33];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004194C0) ----------------------------------------------------
__int64 __fastcall camlSys__set_signal_85()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
  return 1LL;
}
// 4194D1: variable 'v0' is possibly undefined
// 4194D1: variable 'v1' is possibly undefined

//----- (00000000004194F0) ----------------------------------------------------
__int64 __fastcall camlSys__catch_break_110(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  char v9; // [rsp+0h] [rbp-8h]

  if ( v6 != 1 )
  {
    while ( 1 )
    {
      v7 -= 2;
      if ( (unsigned __int64)v7 >= caml_young_limit )
        break;
      caml_call_gc(a1, a2, a3, a4, a5, a6, v9);
    }
    *v7 = 1024LL;
    v7[1] = &camlSys__5;
  }
  return camlSys__set_signal_85();
}
// 4194F8: variable 'v6' is possibly undefined
// 4194FA: variable 'v7' is possibly undefined
// 419547: variable 'a3' is possibly undefined
// 419547: variable 'a4' is possibly undefined
// 419547: variable 'a5' is possibly undefined
// 419547: variable 'a6' is possibly undefined
// 419547: variable 'v9' is possibly undefined
// 651710: using guessed type void (__fastcall __noreturn *camlSys__5)();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000419550) ----------------------------------------------------
__int64 __fastcall camlSys__entry(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // r15
  __int64 *v3; // rax
  __int64 v4; // rdi
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 *v7; // rax
  __int64 v8; // rdi
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rdx
  char v14; // [rsp+0h] [rbp-8h]

  caml_c_call(1LL, a2);
  v4 = v3[1];
  camlSys[1] = *v3;
  camlSys[0] = v4;
  caml_c_call(1LL, a2);
  v8 = v7[1];
  camlSys[3] = *v7;
  camlSys[4] = v8;
  v9 = (camlSys[4] - 20) >> 1;
  camlSys[6] = (2LL << v9) - 3 + 2;
  v10 = camlSys[4] >> 1;
  v11 = v10 + 7;
  if ( v10 >= 0 )
    v11 = camlSys[4] >> 1;
  v12 = (camlSys[6] >> 1) * 2 * (v11 >> 3) - 3 + 2;
  camlSys[5] = v12;
  caml_alloc3(v8, a2, v12, v9, v5, v6, v14);
  *v2 = 1024LL;
  v2[1] = 1LL;
  camlSys[2] = (__int64)(v2 + 1);
  camlSys[7] = (__int64)&camlSys__4;
  camlSys[8] = -1LL;
  camlSys[9] = -3LL;
  camlSys[10] = -5LL;
  camlSys[11] = -7LL;
  camlSys[12] = -9LL;
  camlSys[13] = -11LL;
  camlSys[14] = -13LL;
  camlSys[15] = -15LL;
  camlSys[16] = -17LL;
  camlSys[17] = -19LL;
  camlSys[18] = -21LL;
  camlSys[19] = -23LL;
  camlSys[20] = -25LL;
  camlSys[21] = -27LL;
  camlSys[22] = -29LL;
  camlSys[23] = -31LL;
  camlSys[24] = -33LL;
  camlSys[25] = -35LL;
  camlSys[26] = -37LL;
  camlSys[27] = -39LL;
  camlSys[28] = -41LL;
  v2[2] = 1024LL;
  v2[3] = camlSys__3;
  camlSys[29] = (__int64)(v2 + 3);
  camlSys[30] = (__int64)&camlSys__2;
  camlSys[31] = (__int64)camlSys__1;
  return 1LL;
}
// 419567: variable 'v3' is possibly undefined
// 419596: variable 'v7' is possibly undefined
// 41962A: variable 'v5' is possibly undefined
// 41962A: variable 'v6' is possibly undefined
// 41962A: variable 'v14' is possibly undefined
// 419633: variable 'v2' is possibly undefined
// 6515D0: using guessed type __int64 camlSys[33];
// 6516D8: using guessed type __int64 (__fastcall *camlSys__2)();
// 6516F0: using guessed type __int64 (__fastcall *camlSys__4)();

//----- (0000000000419820) ----------------------------------------------------
__int64 __fastcall camlHashtbl__code_begin(__int64 a1, __int64 a2)
{
  __int64 *v2; // rax
  __int64 v3; // rbx
  _QWORD *v4; // r15
  __int64 v5; // rdi
  __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 i; // rdi
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // [rsp+0h] [rbp-28h]
  __int64 v13; // [rsp+8h] [rbp-20h]
  __int64 v14; // [rsp+18h] [rbp-10h]

  if ( v2 == (__int64 *)1 )
    return 1LL;
  v14 = v2[2];
  v13 = v2[1];
  v12 = *v2;
  v5 = **(_QWORD **)(v3 + 16);
  if ( caml_apply2(v5) == 1 )
  {
    for ( i = camlHashtbl__code_begin(v5, a2); ; caml_call_gc(i, a2, v7, v8, v10, v11, v12) )
    {
      v4 -= 4;
      if ( (unsigned __int64)v4 >= caml_young_limit )
        break;
    }
    result = (__int64)(v4 + 1);
    *v4 = 3072LL;
    v4[1] = v12;
    v4[2] = v13;
    v4[3] = i;
  }
  else
  {
    **(_QWORD **)(v3 + 24) -= 2LL;
    return v14;
  }
  return result;
}
// 419828: variable 'v2' is possibly undefined
// 41984C: variable 'v3' is possibly undefined
// 41988E: variable 'v4' is possibly undefined
// 4198AE: variable 'v12' is possibly undefined
// 4198D0: variable 'v7' is possibly undefined
// 4198D0: variable 'v8' is possibly undefined
// 4198D0: variable 'v10' is possibly undefined
// 4198D0: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004198E0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__find_in_bucket_241(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  _QWORD *v4; // r15
  __int64 v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 i; // rdi
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 result; // rax
  __int64 v12; // [rsp+0h] [rbp-18h]
  __int64 v13; // [rsp+10h] [rbp-8h]

  while ( 1 )
  {
    if ( v2 == 1 )
      return 1LL;
    v12 = *(_QWORD *)(v2 + 16);
    v13 = *(_QWORD *)(v2 + 8);
    v5 = **(_QWORD **)(v3 + 16);
    if ( caml_apply2(v5) != 1 )
      break;
    v2 = v12;
  }
  for ( i = camlHashtbl__find_in_bucket_241(v5, a2); ; caml_call_gc(i, a2, v6, v7, v9, v10, v12) )
  {
    v4 -= 3;
    if ( (unsigned __int64)v4 >= caml_young_limit )
      break;
  }
  result = (__int64)(v4 + 1);
  *v4 = 2048LL;
  v4[1] = v13;
  v4[2] = i;
  return result;
}
// 4198E8: variable 'v2' is possibly undefined
// 419903: variable 'v3' is possibly undefined
// 41992A: variable 'v4' is possibly undefined
// 419970: variable 'v6' is possibly undefined
// 419970: variable 'v7' is possibly undefined
// 419970: variable 'v9' is possibly undefined
// 419970: variable 'v10' is possibly undefined
// 419970: variable 'v12' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000419980) ----------------------------------------------------
_QWORD *__fastcall camlHashtbl__replace_bucket_249(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 *v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  _QWORD *result; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  _QWORD *i; // rdi
  __int64 v18; // r8
  __int64 v19; // r9
  char v20; // [rsp+0h] [rbp-28h]
  __int64 v21; // [rsp+0h] [rbp-28h]
  __int64 v22; // [rsp+8h] [rbp-20h]
  __int64 v23; // [rsp+18h] [rbp-10h]

  if ( v6 == (__int64 *)1 )
  {
    while ( 1 )
    {
      v8 -= 2;
      if ( (unsigned __int64)v8 >= caml_young_limit )
      {
        *v8 = 1024LL;
        v8[1] = &caml_exn_Not_found;
        caml_raise_exn();
      }
      caml_call_gc(a1, a2, a3, a4, a5, a6, v20);
    }
  }
  v23 = v6[2];
  v21 = v6[1];
  v22 = *v6;
  v9 = **(_QWORD **)(v7 + 16);
  if ( caml_apply2(v9) == 1 )
  {
    for ( i = camlHashtbl__replace_bucket_249(v9, a2, v10, v11, v12, v13);
          ;
          caml_call_gc((__int64)i, a2, v15, v16, v18, v19, v21) )
    {
      v8 -= 4;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
    }
    result = v8 + 1;
    *v8 = 3072LL;
    v8[1] = v22;
    v8[2] = v21;
    v8[3] = i;
  }
  else
  {
    while ( 1 )
    {
      v8 -= 4;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(v9, a2, v10, v11, v12, v13, v21);
    }
    result = v8 + 1;
    *v8 = 3072LL;
    v8[1] = v22;
    v8[2] = *(_QWORD *)(v7 + 32);
    v8[3] = v23;
  }
  return result;
}
// 419980: could not find valid save-restore pair for rbx
// 419988: variable 'v6' is possibly undefined
// 4199AC: variable 'v7' is possibly undefined
// 4199C2: variable 'v8' is possibly undefined
// 419A12: variable 'v10' is possibly undefined
// 419A12: variable 'v11' is possibly undefined
// 419A12: variable 'v12' is possibly undefined
// 419A12: variable 'v13' is possibly undefined
// 419A42: variable 'v21' is possibly undefined
// 419A7B: variable 'a3' is possibly undefined
// 419A7B: variable 'a4' is possibly undefined
// 419A7B: variable 'a5' is possibly undefined
// 419A7B: variable 'a6' is possibly undefined
// 419A7B: variable 'v20' is possibly undefined
// 419A82: variable 'v15' is possibly undefined
// 419A82: variable 'v16' is possibly undefined
// 419A82: variable 'v18' is possibly undefined
// 419A82: variable 'v19' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000419AA0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__mem_in_bucket_258()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v3; // [rsp+0h] [rbp-18h]

  while ( v0 != 1 )
  {
    v3 = *(_QWORD *)(v0 + 16);
    if ( caml_apply2(**(_QWORD **)(v1 + 16)) != 1 )
      return 3LL;
    v0 = v3;
  }
  return 1LL;
}
// 419AA8: variable 'v0' is possibly undefined
// 419ABA: variable 'v1' is possibly undefined

//----- (0000000000419B00) ----------------------------------------------------
__int64 __fastcall camlHashtbl__insert_bucket_96()
{
  __int64 *v0; // rax
  __int64 v1; // rbx
  _QWORD *v2; // r15
  unsigned __int64 v3; // rsi
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rcx
  __int64 v8; // rdx
  unsigned __int64 v9; // rdx
  __int64 v10; // rdi
  __int64 v11; // rbx
  char v13; // [rsp+0h] [rbp-28h]
  __int64 v14; // [rsp+8h] [rbp-20h]
  __int64 v15; // [rsp+10h] [rbp-18h]
  __int64 v16; // [rsp+18h] [rbp-10h]

  if ( v0 == (__int64 *)1 )
    return 1LL;
  v13 = v1;
  v3 = v0[2];
  v14 = v0[1];
  v15 = *v0;
  camlHashtbl__insert_bucket_96();
  if ( *(__int64 *)(v1 + 24) >> 1 )
  {
    v16 = *(__int64 *)(v1 + 24) >> 1;
    v4 = (**(__int64 (***)(void))(v1 + 16))();
    v7 = v16;
    v8 = (v4 >> 1) % v16;
  }
  else
  {
    caml_raise_exn();
  }
  v9 = 2 * v8 + 1;
  v10 = *(_QWORD *)(v1 + 32);
  if ( *(_QWORD *)(v10 - 8) >> 9 > v9 )
  {
    while ( 1 )
    {
      v2 -= 4;
      if ( (unsigned __int64)v2 >= caml_young_limit )
        break;
      caml_call_gc(v10, v3, v9, v7, v5, v6, v13);
    }
    v3 = (unsigned __int64)(v2 + 1);
    *v2 = 3072LL;
    v2[1] = v15;
    v2[2] = v14;
    v11 = *(_QWORD *)(v1 + 32);
    if ( *(_QWORD *)(v11 - 8) >> 9 > v9 )
    {
      v2[3] = *(_QWORD *)(v11 + 4 * v9 - 4);
      caml_modify((unsigned __int64 *)(v10 + 4 * v9 - 4), v3);
      return 1LL;
    }
    caml_ml_array_bound_error(v10, v3);
  }
  caml_ml_array_bound_error(v10, v3);
  return camlHashtbl__remove_bucket_111();
}
// 419B08: variable 'v0' is possibly undefined
// 419B0E: variable 'v1' is possibly undefined
// 419B74: variable 'v8' is possibly undefined
// 419B8F: variable 'v2' is possibly undefined
// 419BCB: variable 'v9' is possibly undefined
// 419BF8: variable 'v7' is possibly undefined
// 419BF8: variable 'v5' is possibly undefined
// 419BF8: variable 'v6' is possibly undefined
// 419BF8: variable 'v13' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000419C10) ----------------------------------------------------
__int64 __fastcall camlHashtbl__remove_bucket_111()
{
  __int64 *v0; // rax
  __int64 v1; // rbx
  _QWORD *v2; // r15
  unsigned __int64 v3; // rsi
  __int64 v4; // rax
  __int64 result; // rax
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 i; // rdi
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // [rsp+0h] [rbp-28h]
  __int64 v12; // [rsp+8h] [rbp-20h]
  __int64 v13; // [rsp+18h] [rbp-10h]

  if ( v0 == (__int64 *)1 )
    return 1LL;
  v13 = v0[2];
  v12 = v0[1];
  v11 = *v0;
  v3 = *(_QWORD *)(v1 + 24);
  caml_c_call(*v0, v3);
  if ( v4 == 1 )
  {
    **(_QWORD **)(v1 + 16) -= 2LL;
    return v13;
  }
  else
  {
    for ( i = camlHashtbl__remove_bucket_111(); ; caml_call_gc(i, v3, v6, v7, v9, v10, v11) )
    {
      v2 -= 4;
      if ( (unsigned __int64)v2 >= caml_young_limit )
        break;
    }
    result = (__int64)(v2 + 1);
    *v2 = 3072LL;
    v2[1] = v11;
    v2[2] = v12;
    v2[3] = i;
  }
  return result;
}
// 419C10: could not find valid save-restore pair for rbx
// 419C18: variable 'v0' is possibly undefined
// 419C3C: variable 'v1' is possibly undefined
// 419C50: variable 'v4' is possibly undefined
// 419C7E: variable 'v2' is possibly undefined
// 419C9E: variable 'v11' is possibly undefined
// 419CC0: variable 'v6' is possibly undefined
// 419CC0: variable 'v7' is possibly undefined
// 419CC0: variable 'v9' is possibly undefined
// 419CC0: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000419CD0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__find_in_bucket_136()
{
  __int64 *v0; // rax
  __int64 v1; // rbx
  _QWORD *v2; // r15
  unsigned __int64 v3; // rsi
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 i; // rdi
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 result; // rax
  __int64 *v11; // [rsp+0h] [rbp-18h]
  __int64 v12; // [rsp+10h] [rbp-8h]

  while ( 1 )
  {
    if ( v0 == (__int64 *)1 )
      return 1LL;
    v11 = (__int64 *)v0[2];
    v12 = v0[1];
    v3 = *(_QWORD *)(v1 + 16);
    caml_c_call(*v0, v3);
    if ( v4 == 1 )
      break;
    v0 = v11;
  }
  for ( i = camlHashtbl__find_in_bucket_136(); ; caml_call_gc(i, v3, v5, v6, v8, v9, (char)v11) )
  {
    v2 -= 3;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
  }
  result = (__int64)(v2 + 1);
  *v2 = 2048LL;
  v2[1] = v12;
  v2[2] = i;
  return result;
}
// 419CD8: variable 'v0' is possibly undefined
// 419CF3: variable 'v1' is possibly undefined
// 419D07: variable 'v4' is possibly undefined
// 419D1A: variable 'v2' is possibly undefined
// 419D60: variable 'v5' is possibly undefined
// 419D60: variable 'v6' is possibly undefined
// 419D60: variable 'v8' is possibly undefined
// 419D60: variable 'v9' is possibly undefined
// 419D60: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000419D70) ----------------------------------------------------
_QWORD *__fastcall camlHashtbl__replace_bucket_144(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 *v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdi
  unsigned __int64 v10; // rsi
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rax
  _QWORD *result; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  _QWORD *i; // rdi
  __int64 v20; // r8
  __int64 v21; // r9
  char v22; // [rsp+0h] [rbp-28h]
  __int64 v23; // [rsp+0h] [rbp-28h]
  __int64 v24; // [rsp+8h] [rbp-20h]
  __int64 v25; // [rsp+18h] [rbp-10h]

  if ( v6 == (__int64 *)1 )
  {
    while ( 1 )
    {
      v8 -= 2;
      if ( (unsigned __int64)v8 >= caml_young_limit )
      {
        *v8 = 1024LL;
        v8[1] = &caml_exn_Not_found;
        caml_raise_exn();
      }
      caml_call_gc(a1, a2, a3, a4, a5, a6, v22);
    }
  }
  v25 = v6[2];
  v23 = v6[1];
  v9 = *v6;
  v24 = *v6;
  v10 = *(_QWORD *)(v7 + 16);
  caml_c_call(*v6, v10);
  if ( v15 == 1 )
  {
    while ( 1 )
    {
      v8 -= 4;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(v9, v10, v11, v12, v13, v14, v23);
    }
    result = v8 + 1;
    *v8 = 3072LL;
    v8[1] = v24;
    v8[2] = *(_QWORD *)(v7 + 24);
    v8[3] = v25;
  }
  else
  {
    for ( i = camlHashtbl__replace_bucket_144(v9, v10, v11, v12, v13, v14);
          ;
          caml_call_gc((__int64)i, v10, v17, v18, v20, v21, v23) )
    {
      v8 -= 4;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
    }
    result = v8 + 1;
    *v8 = 3072LL;
    v8[1] = v24;
    v8[2] = v23;
    v8[3] = i;
  }
  return result;
}
// 419D70: could not find valid save-restore pair for rbx
// 419D78: variable 'v6' is possibly undefined
// 419D9C: variable 'v7' is possibly undefined
// 419DB0: variable 'v15' is possibly undefined
// 419DB2: variable 'v8' is possibly undefined
// 419E02: variable 'v11' is possibly undefined
// 419E02: variable 'v12' is possibly undefined
// 419E02: variable 'v13' is possibly undefined
// 419E02: variable 'v14' is possibly undefined
// 419E32: variable 'v23' is possibly undefined
// 419E6B: variable 'a3' is possibly undefined
// 419E6B: variable 'a4' is possibly undefined
// 419E6B: variable 'a5' is possibly undefined
// 419E6B: variable 'a6' is possibly undefined
// 419E6B: variable 'v22' is possibly undefined
// 419E72: variable 'v17' is possibly undefined
// 419E72: variable 'v18' is possibly undefined
// 419E72: variable 'v20' is possibly undefined
// 419E72: variable 'v21' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000419E90) ----------------------------------------------------
__int64 __fastcall camlHashtbl__mem_in_bucket_153()
{
  __int64 *v0; // rax
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 *v4; // [rsp+0h] [rbp-18h]

  while ( v0 != (__int64 *)1 )
  {
    v4 = (__int64 *)v0[2];
    caml_c_call(*v0, *(_QWORD *)(v1 + 16));
    if ( v2 == 1 )
      return 3LL;
    v0 = v4;
  }
  return 1LL;
}
// 419E98: variable 'v0' is possibly undefined
// 419EAA: variable 'v1' is possibly undefined
// 419EBE: variable 'v2' is possibly undefined

//----- (0000000000419EF0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__do_bucket_160()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v3; // [rsp+0h] [rbp-18h]

  while ( v0 != 1 )
  {
    v3 = *(_QWORD *)(v0 + 16);
    caml_apply2(*(_QWORD *)(v1 + 16));
    v0 = v3;
  }
  return 1LL;
}
// 419EF8: variable 'v0' is possibly undefined
// 419F0E: variable 'v1' is possibly undefined

//----- (0000000000419F40) ----------------------------------------------------
__int64 __fastcall camlHashtbl__do_bucket_170(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v4; // [rsp+0h] [rbp-18h]

  while ( v1 != 1 )
  {
    v4 = *(_QWORD *)(v1 + 16);
    v2 = caml_apply3(v2, *(_QWORD *)(a1 + 24));
    v1 = v4;
  }
  return v2;
}
// 419F4B: variable 'v1' is possibly undefined
// 419F68: variable 'v2' is possibly undefined

//----- (0000000000419F90) ----------------------------------------------------
__int64 __fastcall camlHashtbl__safehash_205()
{
  __int64 v0; // rbx

  return (**(__int64 (***)(void))(*(_QWORD *)(v0 + 16) + 8LL))() & 0x7FFFFFFFFFFFFFFFLL;
}
// 419F94: variable 'v0' is possibly undefined
// 419F90: using guessed type __int64 __fastcall camlHashtbl__safehash_205();

//----- (0000000000419FC0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__add_207(__int64 (*a1)(void), __int64 (**a2)(void))
{
  _QWORD *v2; // rax
  __int64 v3; // rbx
  _QWORD *v4; // r15
  __int64 v5; // rax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rdx
  unsigned __int64 i; // rdx
  unsigned __int64 v11; // rsi
  __int64 (*v12)(void); // rdi
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // [rsp+0h] [rbp-28h]
  __int64 (*v19)(void); // [rsp+8h] [rbp-20h]
  _QWORD *v20; // [rsp+10h] [rbp-18h]
  __int64 v21; // [rsp+20h] [rbp-8h]

  if ( *(_QWORD *)(v2[1] - 8LL) >> 10 )
  {
    v21 = *(_QWORD *)(v2[1] - 8LL) >> 10;
    v19 = a1;
    v18 = v3;
    v20 = v2;
    a2 = *(__int64 (***)(void))(*((_QWORD *)a2[3] + 2) + 8LL);
    a1 = *a2;
    v5 = (*a2)();
    v8 = v21;
    v9 = ((v5 & 0x7FFFFFFFFFFFFFFFLL) >> 1) % v21;
  }
  else
  {
    caml_raise_exn();
  }
  for ( i = 2 * v9 + 1; ; caml_call_gc((__int64)a1, (__int64)a2, i, v8, v6, v7, v18) )
  {
    v4 -= 4;
    if ( (unsigned __int64)v4 >= caml_young_limit )
      break;
  }
  v11 = (unsigned __int64)(v4 + 1);
  *v4 = 3072LL;
  v4[1] = v18;
  v4[2] = v19;
  v12 = (__int64 (*)(void))v20[1];
  if ( *((_QWORD *)v12 - 1) >> 9 <= i )
    goto LABEL_13;
  v4[3] = *(_QWORD *)((char *)v12 + 4 * i - 4);
  v12 = (__int64 (*)(void))v20[1];
  if ( *((_QWORD *)v12 - 1) >> 9 <= i )
  {
    caml_ml_array_bound_error((__int64)v12, v11);
LABEL_13:
    caml_ml_array_bound_error((__int64)v12, v11);
    return camlHashtbl__remove_213(v12, v11, v14, v15, v16, v17);
  }
  caml_modify((unsigned __int64 *)((char *)v12 + 4 * i - 4), v11);
  *v20 += 2LL;
  if ( *v20 <= 2 * ((*(_QWORD *)(v20[1] - 8LL) >> 9) | 1LL) - 1 )
    return 1LL;
  else
    return camlHashtbl__resize_89();
}
// 419FC0: could not find valid save-restore pair for rbx
// 419FC4: variable 'v2' is possibly undefined
// 419FE4: variable 'v3' is possibly undefined
// 41A02C: variable 'v9' is possibly undefined
// 41A032: variable 'v4' is possibly undefined
// 41A056: variable 'v18' is possibly undefined
// 41A05E: variable 'v19' is possibly undefined
// 41A067: variable 'v20' is possibly undefined
// 41A076: variable 'i' is possibly undefined
// 41A0DC: variable 'v8' is possibly undefined
// 41A0DC: variable 'v6' is possibly undefined
// 41A0DC: variable 'v7' is possibly undefined
// 41A0EC: variable 'v14' is possibly undefined
// 41A0EC: variable 'v15' is possibly undefined
// 41A0EC: variable 'v16' is possibly undefined
// 41A0EC: variable 'v17' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041A0F0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__remove_213(
        __int64 (*a1)(void),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  __int64 (**v10)(void); // rsi
  __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 v20; // [rsp+0h] [rbp-18h]
  __int64 v21; // [rsp+0h] [rbp-18h]
  __int64 v22; // [rsp+10h] [rbp-8h]
  unsigned __int64 v23; // [rsp+10h] [rbp-8h]

  for ( i = v6; ; caml_call_gc((__int64)a1, a2, i, a4, a5, a6, v20) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  v10 = (__int64 (**)(void))(v8 + 1);
  *v8 = 5367LL;
  v8[1] = camlHashtbl__code_begin;
  v8[2] = 3LL;
  v8[3] = *((_QWORD *)a1 + 3);
  v8[4] = i;
  v8[5] = v7;
  if ( *(_QWORD *)(*(_QWORD *)(i + 8) - 8LL) >> 10 )
  {
    v22 = *(_QWORD *)(*(_QWORD *)(i + 8) - 8LL) >> 10;
    v20 = i;
    v10 = *(__int64 (***)(void))(*(_QWORD *)(*((_QWORD *)a1 + 4) + 16LL) + 8LL);
    a1 = *v10;
    v11 = (((*v10)() & 0x7FFFFFFFFFFFFFFFLL) >> 1) % v22;
  }
  else
  {
    caml_raise_exn();
  }
  v12 = 2 * v11 + 1;
  v23 = v12;
  v13 = v20;
  v21 = *(_QWORD *)(v20 + 8);
  if ( *(_QWORD *)(v21 - 8) >> 9 > v12 )
  {
    if ( *(_QWORD *)(*(_QWORD *)(v13 + 8) - 8LL) >> 9 > v12 )
    {
      v14 = camlHashtbl__code_begin((__int64)a1, (__int64)v10);
      caml_modify((unsigned __int64 *)(v21 + 4 * v23 - 4), v14);
      return 1LL;
    }
    caml_ml_array_bound_error((__int64)a1, (unsigned __int64)v10);
  }
  caml_ml_array_bound_error((__int64)a1, (unsigned __int64)v10);
  return camlHashtbl__find_rec_221((__int64)a1, (__int64)v10, v16, v17, v18, v19);
}
// 41A0F4: variable 'v6' is possibly undefined
// 41A0F7: variable 'v8' is possibly undefined
// 41A131: variable 'i' is possibly undefined
// 41A135: variable 'v7' is possibly undefined
// 41A198: variable 'v11' is possibly undefined
// 41A1A3: variable 'v20' is possibly undefined
// 41A1FE: variable 'a4' is possibly undefined
// 41A1FE: variable 'a5' is possibly undefined
// 41A1FE: variable 'a6' is possibly undefined
// 41A213: variable 'v16' is possibly undefined
// 41A213: variable 'v17' is possibly undefined
// 41A213: variable 'v18' is possibly undefined
// 41A213: variable 'v19' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041A220) ----------------------------------------------------
__int64 __fastcall camlHashtbl__find_rec_221(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v10; // [rsp+0h] [rbp-28h]
  __int64 v11; // [rsp+8h] [rbp-20h]

  while ( 1 )
  {
    if ( v7 == 1 )
    {
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
        {
          *v8 = 1024LL;
          v8[1] = &caml_exn_Not_found;
          caml_raise_exn();
        }
        caml_call_gc(a1, a2, a3, a4, a5, a6, v10);
      }
    }
    v10 = v6;
    v11 = *(_QWORD *)(v7 + 16);
    a2 = *(_QWORD *)(v7 + 8);
    if ( caml_apply2(**(_QWORD **)(a1 + 24)) != 1 )
      break;
    v6 = v10;
    v7 = v11;
  }
  return a2;
}
// 41A228: variable 'v7' is possibly undefined
// 41A22F: variable 'v6' is possibly undefined
// 41A274: variable 'v8' is possibly undefined
// 41A29F: variable 'a3' is possibly undefined
// 41A29F: variable 'a4' is possibly undefined
// 41A29F: variable 'a5' is possibly undefined
// 41A29F: variable 'a6' is possibly undefined
// 41A29F: variable 'v10' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041A2B0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__find_226(__int64 (*a1)(void))
{
  __int64 v1; // rax
  _QWORD *v2; // r15
  __int64 (**v3)(void); // rsi
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rcx
  __int64 v8; // rdx
  unsigned __int64 v9; // rdx
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v17; // rax
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rdx
  __int64 v27; // rcx
  __int64 v28; // r8
  __int64 v29; // r9
  __int64 v30; // [rsp+0h] [rbp-28h]
  __int64 (*v31)(void); // [rsp+8h] [rbp-20h]
  __int64 v32; // [rsp+18h] [rbp-10h]
  __int64 v33; // [rsp+18h] [rbp-10h]
  __int64 v34; // [rsp+18h] [rbp-10h]
  __int64 v35; // [rsp+18h] [rbp-10h]

  v3 = (__int64 (**)(void))(*(_QWORD *)(*(_QWORD *)(v1 + 8) - 8LL) >> 10);
  if ( v3 )
  {
    v32 = *(_QWORD *)(*(_QWORD *)(v1 + 8) - 8LL) >> 10;
    v31 = a1;
    v30 = v1;
    v3 = *(__int64 (***)(void))(*(_QWORD *)(*((_QWORD *)a1 + 4) + 16LL) + 8LL);
    a1 = *v3;
    v4 = (*v3)();
    v7 = v32;
    v8 = ((v4 & 0x7FFFFFFFFFFFFFFFLL) >> 1) % v32;
  }
  else
  {
    caml_raise_exn();
  }
  v9 = 2 * v8 + 1;
  v10 = *(_QWORD *)(v30 + 8);
  if ( *(_QWORD *)(v10 - 8) >> 9 <= v9 )
  {
    caml_ml_array_bound_error((__int64)a1, (unsigned __int64)v3);
    return camlHashtbl__find_all_238(a1, (__int64)v3, v26, v27, v28, v29);
  }
  v11 = *(_QWORD *)(v10 + 4 * v9 - 4);
  if ( v11 == 1 )
  {
    while ( 1 )
    {
LABEL_19:
      v2 -= 2;
      if ( (unsigned __int64)v2 >= caml_young_limit )
      {
        *v2 = 1024LL;
        v2[1] = &caml_exn_Not_found;
        caml_raise_exn();
      }
      caml_call_gc((__int64)a1, (__int64)v3, v9, v7, v5, v6, v30);
    }
  }
  v30 = *(_QWORD *)(v11 + 16);
  v33 = *(_QWORD *)(v11 + 8);
  a1 = (__int64 (*)(void))**((_QWORD **)v31 + 3);
  if ( caml_apply2((__int64)a1) != 1 )
    return v33;
  v17 = v30;
  if ( v30 == 1 )
  {
LABEL_17:
    while ( 1 )
    {
      v2 -= 2;
      if ( (unsigned __int64)v2 >= caml_young_limit )
        break;
      caml_call_gc((__int64)a1, (__int64)v3, v12, v13, v14, v15, v30);
    }
    *v2 = 1024LL;
    v2[1] = &caml_exn_Not_found;
    caml_raise_exn();
    goto LABEL_19;
  }
  v30 = *(_QWORD *)(v30 + 16);
  v34 = *(_QWORD *)(v17 + 8);
  a1 = (__int64 (*)(void))**((_QWORD **)v31 + 3);
  if ( caml_apply2((__int64)a1) != 1 )
    return v34;
  if ( v30 == 1 )
  {
    while ( 1 )
    {
      v2 -= 2;
      if ( (unsigned __int64)v2 >= caml_young_limit )
        break;
      caml_call_gc((__int64)a1, (__int64)v3, v18, v19, v20, v21, v30);
    }
    *v2 = 1024LL;
    v2[1] = &caml_exn_Not_found;
    caml_raise_exn();
    goto LABEL_17;
  }
  v35 = *(_QWORD *)(v30 + 8);
  if ( caml_apply2(**((_QWORD **)v31 + 3)) == 1 )
    return camlHashtbl__find_rec_221(*((_QWORD *)v31 + 5), (__int64)v3, v22, v23, v24, v25);
  else
    return v35;
}
// 41A2B4: variable 'v1' is possibly undefined
// 41A318: variable 'v8' is possibly undefined
// 41A322: variable 'v30' is possibly undefined
// 41A35F: variable 'v31' is possibly undefined
// 41A422: variable 'v22' is possibly undefined
// 41A422: variable 'v23' is possibly undefined
// 41A422: variable 'v24' is possibly undefined
// 41A422: variable 'v25' is possibly undefined
// 41A428: variable 'v2' is possibly undefined
// 41A4B7: variable 'v9' is possibly undefined
// 41A4B7: variable 'v7' is possibly undefined
// 41A4B7: variable 'v5' is possibly undefined
// 41A4B7: variable 'v6' is possibly undefined
// 41A4BE: variable 'v12' is possibly undefined
// 41A4BE: variable 'v13' is possibly undefined
// 41A4BE: variable 'v14' is possibly undefined
// 41A4BE: variable 'v15' is possibly undefined
// 41A4C5: variable 'v18' is possibly undefined
// 41A4C5: variable 'v19' is possibly undefined
// 41A4C5: variable 'v20' is possibly undefined
// 41A4C5: variable 'v21' is possibly undefined
// 41A4D5: variable 'v26' is possibly undefined
// 41A4D5: variable 'v27' is possibly undefined
// 41A4D5: variable 'v28' is possibly undefined
// 41A4D5: variable 'v29' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041A4E0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__find_all_238(
        __int64 (*a1)(void),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  __int64 (**v10)(void); // rsi
  __int64 v11; // rdx
  __int64 v13; // [rsp+0h] [rbp-18h]
  __int64 v14; // [rsp+10h] [rbp-8h]

  for ( i = v6; ; caml_call_gc((__int64)a1, a2, i, a4, a5, a6, v13) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  v10 = (__int64 (**)(void))(v8 + 1);
  *v8 = 4343LL;
  v8[1] = camlHashtbl__find_in_bucket_241;
  v8[2] = 3LL;
  v8[3] = *((_QWORD *)a1 + 3);
  v8[4] = v7;
  if ( *(_QWORD *)(*(_QWORD *)(i + 8) - 8LL) >> 10 )
  {
    v14 = *(_QWORD *)(*(_QWORD *)(i + 8) - 8LL) >> 10;
    v13 = i;
    v10 = *(__int64 (***)(void))(*(_QWORD *)(*((_QWORD *)a1 + 4) + 16LL) + 8LL);
    a1 = *v10;
    v11 = (((*v10)() & 0x7FFFFFFFFFFFFFFFLL) >> 1) % v14;
  }
  else
  {
    caml_raise_exn();
  }
  if ( *(_QWORD *)(*(_QWORD *)(v13 + 8) - 8LL) >> 9 > (unsigned __int64)(2 * v11 + 1) )
    return camlHashtbl__find_in_bucket_241((__int64)a1, (__int64)v10);
  caml_ml_array_bound_error((__int64)a1, (unsigned __int64)v10);
  return camlHashtbl__replace_245((__int64)a1, (unsigned __int64)v10);
}
// 41A4E4: variable 'v6' is possibly undefined
// 41A4E7: variable 'v8' is possibly undefined
// 41A521: variable 'v7' is possibly undefined
// 41A525: variable 'i' is possibly undefined
// 41A58E: variable 'v13' is possibly undefined
// 41A584: variable 'v11' is possibly undefined
// 41A5B2: variable 'a4' is possibly undefined
// 41A5B2: variable 'a5' is possibly undefined
// 41A5B2: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041A5D0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__replace_245(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // rax
  __int64 v3; // rbx
  __int64 v4; // r15
  _QWORD *v5; // r15
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rcx
  __int64 v10; // rdx
  unsigned __int64 v11; // rdx
  __int64 (*v12)(void); // rdi
  __int64 v13; // rdx
  _QWORD *v14; // r15
  unsigned __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  _QWORD *v20; // [rsp+0h] [rbp-48h]
  __int64 v21; // [rsp+8h] [rbp-40h]
  __int64 v22; // [rsp+10h] [rbp-38h]
  __int64 v23; // [rsp+18h] [rbp-30h]
  __int64 v24; // [rsp+18h] [rbp-30h]
  unsigned __int64 v25; // [rsp+38h] [rbp-10h]

  v5 = (_QWORD *)(v4 - 48);
  if ( (unsigned __int64)v5 < caml_young_limit )
    JUMPOUT(0x41A7D0LL);
  *v5 = 5367LL;
  v5[1] = camlHashtbl__replace_bucket_249;
  v5[2] = 3LL;
  v5[3] = *(_QWORD *)(a2 + 24);
  v5[4] = v3;
  v5[5] = a1;
  if ( *(_QWORD *)(v2[1] - 8LL) >> 10 )
  {
    v23 = *(_QWORD *)(v2[1] - 8LL) >> 10;
    v22 = a1;
    v21 = v3;
    v20 = v2;
    a2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16LL) + 8LL);
    v6 = (*(__int64 (**)(void))a2)();
    v9 = v23;
    v10 = ((v6 & 0x7FFFFFFFFFFFFFFFLL) >> 1) % v23;
  }
  else
  {
    caml_raise_exn();
  }
  v11 = 2 * v10 + 1;
  v25 = v11;
  v12 = (__int64 (*)(void))v20[1];
  if ( *((_QWORD *)v12 - 1) >> 9 <= v11 )
    JUMPOUT(0x41A7E4LL);
  v24 = *(_QWORD *)((char *)v12 + 4 * v11 - 4);
  if ( *(char ***)sub_41A778(v12, a2, v11, v9, v7, v8) == &caml_exn_Not_found )
  {
    v13 = v20[1];
    if ( *(_QWORD *)(v13 - 8) >> 9 <= v25 )
      JUMPOUT(0x41A7DFLL);
    v14 = v5 - 4;
    if ( (unsigned __int64)v14 < caml_young_limit )
      JUMPOUT(0x41A7C6LL);
    *v14 = 3072LL;
    v14[1] = v21;
    v14[2] = v22;
    v14[3] = v24;
    caml_modify((unsigned __int64 *)(v13 + 4 * v25 - 4), (unsigned __int64)(v14 + 1));
    *v20 += 2LL;
    if ( *v20 <= 2 * ((*(_QWORD *)(v20[1] - 8LL) >> 9) | 1LL) - 1 )
      return 1LL;
    else
      return camlHashtbl__resize_89();
  }
  else
  {
    caml_raise_exn();
    return sub_41A778((__int64 (*)(void))&caml_exn_Not_found, a2, v16, v17, v18, v19);
  }
}
// 41A5E5: control flows out of bounds to 41A7D0
// 41A6A6: control flows out of bounds to 41A7E4
// 41A6E6: control flows out of bounds to 41A7DF
// 41A6FA: control flows out of bounds to 41A7C6
// 41A5D7: variable 'v4' is possibly undefined
// 41A611: variable 'v3' is possibly undefined
// 41A619: variable 'v2' is possibly undefined
// 41A688: variable 'v10' is possibly undefined
// 41A697: variable 'v20' is possibly undefined
// 41A6B6: variable 'v9' is possibly undefined
// 41A6B6: variable 'v7' is possibly undefined
// 41A6B6: variable 'v8' is possibly undefined
// 41A711: variable 'v21' is possibly undefined
// 41A719: variable 'v22' is possibly undefined
// 41A776: variable 'v16' is possibly undefined
// 41A776: variable 'v17' is possibly undefined
// 41A776: variable 'v18' is possibly undefined
// 41A776: variable 'v19' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041A778) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_41A778(
        __int64 (*a1)(void),
        unsigned __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rbx
  _QWORD *v7; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // [rsp-10h] [rbp-18h]
  __int64 v14; // [rsp-8h] [rbp-10h]

  v13 = *(_QWORD *)(v6 + 8);
  if ( *(_QWORD *)(v13 - 8) >> 9 <= a3 )
  {
    caml_ml_array_bound_error((__int64)a1, a2);
    caml_ml_array_bound_error((__int64)a1, a2);
    caml_ml_array_bound_error((__int64)a1, a2);
    return camlHashtbl__mem_255(a1, a2, v9, v10, v11, v12);
  }
  else
  {
    v7 = camlHashtbl__replace_bucket_249((__int64)a1, a2, a3, a4, a5, a6);
    caml_modify((unsigned __int64 *)(v13 + 4 * v14 - 4), (unsigned __int64)v7);
    return 1LL;
  }
}
// 41A7C5: positive sp value 50 has been found
// 41A77D: variable 'v6' is possibly undefined
// 41A7A7: variable 'v14' is possibly undefined
// 41A7EA: variable 'v9' is possibly undefined
// 41A7EA: variable 'v10' is possibly undefined
// 41A7EA: variable 'v11' is possibly undefined
// 41A7EA: variable 'v12' is possibly undefined

//----- (000000000041A7F0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__mem_255(
        __int64 (*a1)(void),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  __int64 (**v10)(void); // rsi
  __int64 v11; // rdx
  __int64 v13; // [rsp+0h] [rbp-18h]
  __int64 v14; // [rsp+10h] [rbp-8h]

  for ( i = v6; ; caml_call_gc((__int64)a1, a2, i, a4, a5, a6, v13) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  v10 = (__int64 (**)(void))(v8 + 1);
  *v8 = 4343LL;
  v8[1] = camlHashtbl__mem_in_bucket_258;
  v8[2] = 3LL;
  v8[3] = *((_QWORD *)a1 + 3);
  v8[4] = v7;
  if ( *(_QWORD *)(*(_QWORD *)(i + 8) - 8LL) >> 10 )
  {
    v14 = *(_QWORD *)(*(_QWORD *)(i + 8) - 8LL) >> 10;
    v13 = i;
    v10 = *(__int64 (***)(void))(*(_QWORD *)(*((_QWORD *)a1 + 4) + 16LL) + 8LL);
    a1 = *v10;
    v11 = (((*v10)() & 0x7FFFFFFFFFFFFFFFLL) >> 1) % v14;
  }
  else
  {
    caml_raise_exn();
  }
  if ( *(_QWORD *)(*(_QWORD *)(v13 + 8) - 8LL) >> 9 > (unsigned __int64)(2 * v11 + 1) )
    return camlHashtbl__mem_in_bucket_258();
  caml_ml_array_bound_error((__int64)a1, (unsigned __int64)v10);
  return camlHashtbl__hash_59();
}
// 41A7F4: variable 'v6' is possibly undefined
// 41A7F7: variable 'v8' is possibly undefined
// 41A831: variable 'v7' is possibly undefined
// 41A835: variable 'i' is possibly undefined
// 41A89E: variable 'v13' is possibly undefined
// 41A894: variable 'v11' is possibly undefined
// 41A8C2: variable 'a4' is possibly undefined
// 41A8C2: variable 'a5' is possibly undefined
// 41A8C2: variable 'a6' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041A8E0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__hash_59()
{
  __int64 v0; // rax

  return caml_hash_univ_param(21LL, 201LL, v0);
}
// 41A8F5: variable 'v0' is possibly undefined

//----- (000000000041A900) ----------------------------------------------------
_QWORD *__fastcall camlHashtbl__create_79()
{
  _QWORD *v0; // r15
  __int64 v1; // rax
  __int64 v2; // rdi
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rax
  __int64 v8; // rbx
  _QWORD *result; // rax
  char v10; // [rsp+0h] [rbp-8h]

  camlPervasives__max_53();
  camlPervasives__min_50();
  v2 = v1;
  caml_c_call(v1, 1uLL);
  v8 = v7;
  while ( 1 )
  {
    v0 -= 3;
    if ( (unsigned __int64)v0 >= caml_young_limit )
      break;
    caml_call_gc(v2, 1LL, v3, v4, v5, v6, v10);
  }
  result = v0 + 1;
  *v0 = 2048LL;
  v0[1] = 1LL;
  v0[2] = v8;
  return result;
}
// 41A92A: variable 'v1' is possibly undefined
// 41A939: variable 'v7' is possibly undefined
// 41A93C: variable 'v0' is possibly undefined
// 41A968: variable 'v3' is possibly undefined
// 41A968: variable 'v4' is possibly undefined
// 41A968: variable 'v5' is possibly undefined
// 41A968: variable 'v6' is possibly undefined
// 41A968: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041A970) ----------------------------------------------------
__int64 __fastcall camlHashtbl__clear_82(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // rax
  _QWORD *v3; // r12
  unsigned __int64 v4; // rbx
  __int64 v5; // rbp
  __int64 v6; // rdi
  unsigned __int64 v7; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9

  v3 = v2;
  v4 = 1LL;
  v5 = ((*(_QWORD *)(v2[1] - 8LL) >> 9) | 1LL) - 2;
  if ( v5 < 1 )
  {
LABEL_4:
    *v3 = 1LL;
    return 1LL;
  }
  else
  {
    while ( 1 )
    {
      v6 = v3[1];
      if ( *(_QWORD *)(v6 - 8) >> 9 <= v4 )
        break;
      a2 = 1LL;
      caml_modify((unsigned __int64 *)(v6 + 4 * v4 - 4), 1uLL);
      v7 = v4;
      v4 += 2LL;
      if ( v7 == v5 )
        goto LABEL_4;
    }
    caml_ml_array_bound_error(v6, a2);
    return (__int64)camlHashtbl__copy_85(v6, a2, v9, v10, v11, v12);
  }
}
// 41A974: variable 'v2' is possibly undefined
// 41A9DC: variable 'v9' is possibly undefined
// 41A9DC: variable 'v10' is possibly undefined
// 41A9DC: variable 'v11' is possibly undefined
// 41A9DC: variable 'v12' is possibly undefined

//----- (000000000041A9E0) ----------------------------------------------------
_QWORD *__fastcall camlHashtbl__copy_85(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rdx
  __int64 v9; // rcx
  void *i; // rdi
  __int64 v11; // r8
  __int64 v12; // r9
  _QWORD *result; // rax
  _QWORD *v14; // [rsp+0h] [rbp-8h]

  v14 = v6;
  for ( i = camlArray__copy_77(a1, a2, a3, a4, a5, a6); ; caml_call_gc((__int64)i, a2, v8, v9, v11, v12, (char)v14) )
  {
    v7 -= 3;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  result = v7 + 1;
  *v7 = 2048LL;
  v7[1] = *v14;
  v7[2] = i;
  return result;
}
// 41A9E4: variable 'v6' is possibly undefined
// 41A9F4: variable 'v7' is possibly undefined
// 41AA14: variable 'v14' is possibly undefined
// 41AA23: variable 'v8' is possibly undefined
// 41AA23: variable 'v9' is possibly undefined
// 41AA23: variable 'v11' is possibly undefined
// 41AA23: variable 'v12' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041AA30) ----------------------------------------------------
__int64 __fastcall camlHashtbl__length_87()
{
  __int64 v0; // rax

  return *(_QWORD *)v0;
}
// 41AA30: variable 'v0' is possibly undefined
// 41AA30: using guessed type __int64 __fastcall camlHashtbl__length_87();

//----- (000000000041AA40) ----------------------------------------------------
__int64 __fastcall camlHashtbl__resize_89()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  _QWORD *v2; // r15
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rdi
  __int64 v13; // rdi
  __int64 v15; // [rsp+0h] [rbp-38h]
  __int64 v16; // [rsp+8h] [rbp-30h]
  __int64 v17; // [rsp+8h] [rbp-30h]
  __int64 v18; // [rsp+10h] [rbp-28h]
  __int64 v19; // [rsp+10h] [rbp-28h]
  __int64 v20; // [rsp+18h] [rbp-20h]
  unsigned __int64 v21; // [rsp+20h] [rbp-18h]
  __int64 v22; // [rsp+28h] [rbp-10h]

  v15 = v0;
  v20 = v1;
  v22 = *(_QWORD *)(v1 + 8);
  v18 = (*(_QWORD *)(v22 - 8) >> 9) | 1LL;
  camlPervasives__min_50();
  if ( v3 == v18 )
    return 1LL;
  v16 = v3;
  v4 = v3;
  caml_c_call(v3, 1uLL);
  v10 = v9;
  v21 = v9;
  while ( 1 )
  {
    v2 -= 6;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
    caml_call_gc(v4, 1LL, v5, v6, v7, v8, v15);
  }
  *v2 = 5367LL;
  v2[1] = camlHashtbl__insert_bucket_96;
  v2[2] = 3LL;
  v2[3] = v15;
  v2[4] = v16;
  v2[5] = v10;
  v11 = 1LL;
  if ( v18 - 2 < 1 )
  {
LABEL_8:
    caml_modify((unsigned __int64 *)(v20 + 8), v21);
    return 1LL;
  }
  else
  {
    v19 = v18 - 2;
    v17 = 1LL;
    while ( 1 )
    {
      v12 = *(_QWORD *)(v22 - 8) >> 9;
      if ( v12 <= v11 )
        break;
      camlHashtbl__insert_bucket_96();
      v13 = v17;
      v11 = v17 + 2;
      v17 += 2LL;
      if ( v13 == v19 )
        goto LABEL_8;
    }
    caml_ml_array_bound_error(v12, 1uLL);
    return camlHashtbl__add_102(v12, 1LL);
  }
}
// 41AA44: variable 'v0' is possibly undefined
// 41AA48: variable 'v1' is possibly undefined
// 41AA8A: variable 'v3' is possibly undefined
// 41AAB0: variable 'v9' is possibly undefined
// 41AAB8: variable 'v2' is possibly undefined
// 41AAEE: variable 'v15' is possibly undefined
// 41AB88: variable 'v5' is possibly undefined
// 41AB88: variable 'v6' is possibly undefined
// 41AB88: variable 'v7' is possibly undefined
// 41AB88: variable 'v8' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041ABA0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__add_102(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax
  __int64 v3; // rbx
  _QWORD *v4; // r15
  _QWORD *v5; // r12
  __int64 v6; // rbp
  __int64 v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rcx
  __int64 v11; // rdx
  unsigned __int64 i; // rdx
  unsigned __int64 v13; // rsi
  __int64 v14; // rbx
  __int64 v15; // rbx
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // [rsp+0h] [rbp-8h]

  v5 = v2;
  v6 = *(_QWORD *)(v2[1] - 8LL) >> 10;
  if ( v6 )
  {
    v21 = a1;
    a2 = 201LL;
    a1 = 21LL;
    v7 = caml_hash_univ_param(21LL, 201LL, v3);
    v10 = v6;
    v11 = (v7 >> 1) % v6;
  }
  else
  {
    caml_raise_exn();
  }
  for ( i = 2 * v11 + 1; ; caml_call_gc(a1, a2, i, v10, v8, v9, v21) )
  {
    v4 -= 4;
    if ( (unsigned __int64)v4 >= caml_young_limit )
      break;
  }
  v13 = (unsigned __int64)(v4 + 1);
  *v4 = 3072LL;
  v4[1] = v3;
  v4[2] = v21;
  v14 = v5[1];
  if ( *(_QWORD *)(v14 - 8) >> 9 <= i )
    goto LABEL_13;
  v4[3] = *(_QWORD *)(v14 + 4 * i - 4);
  v15 = v5[1];
  if ( *(_QWORD *)(v15 - 8) >> 9 <= i )
  {
    caml_ml_array_bound_error(a1, v13);
LABEL_13:
    caml_ml_array_bound_error(a1, v13);
    return camlHashtbl__remove_108(a1, v13, v17, v18, v19, v20);
  }
  caml_modify((unsigned __int64 *)(v15 + 4 * i - 4), v13);
  *v5 += 2LL;
  if ( *v5 <= 2 * ((*(_QWORD *)(v5[1] - 8LL) >> 9) | 1LL) - 1 )
    return 1LL;
  else
    return camlHashtbl__resize_89();
}
// 41ABA4: variable 'v2' is possibly undefined
// 41ABCE: variable 'v3' is possibly undefined
// 41ABEC: variable 'v11' is possibly undefined
// 41ABF2: variable 'v4' is possibly undefined
// 41AC19: variable 'v21' is possibly undefined
// 41AC2D: variable 'i' is possibly undefined
// 41AC9C: variable 'v10' is possibly undefined
// 41AC9C: variable 'v8' is possibly undefined
// 41AC9C: variable 'v9' is possibly undefined
// 41ACAC: variable 'v17' is possibly undefined
// 41ACAC: variable 'v18' is possibly undefined
// 41ACAC: variable 'v19' is possibly undefined
// 41ACAC: variable 'v20' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041ACB0) ----------------------------------------------------
unsigned __int64 __fastcall camlHashtbl__remove_108(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // r12
  __int64 i; // rdx
  __int64 v11; // rbp
  __int64 v12; // rdx
  unsigned __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  char v20; // [rsp+0h] [rbp-18h]
  __int64 v21; // [rsp+0h] [rbp-18h]
  unsigned __int64 v22; // [rsp+8h] [rbp-10h]

  v9 = v6;
  for ( i = v7; ; caml_call_gc(a1, a2, i, a4, a5, a6, v20) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 4343LL;
  v8[1] = camlHashtbl__remove_bucket_111;
  v8[2] = 3LL;
  v8[3] = v9;
  v8[4] = i;
  v11 = *(_QWORD *)(*(_QWORD *)(v9 + 8) - 8LL) >> 10;
  if ( v11 )
  {
    a2 = 201LL;
    a1 = 21LL;
    v12 = (caml_hash_univ_param(21LL, 201LL, i) >> 1) % v11;
  }
  else
  {
    caml_raise_exn();
  }
  v13 = 2 * v12 + 1;
  v22 = v13;
  v21 = *(_QWORD *)(v9 + 8);
  if ( *(_QWORD *)(v21 - 8) >> 9 > v13 )
  {
    a1 = *(_QWORD *)(v9 + 8);
    if ( *(_QWORD *)(a1 - 8) >> 9 > v13 )
    {
      v14 = camlHashtbl__remove_bucket_111();
      caml_modify((unsigned __int64 *)(v21 + 4 * v22 - 4), v14);
      return 1LL;
    }
    caml_ml_array_bound_error(a1, a2);
  }
  caml_ml_array_bound_error(a1, a2);
  return camlHashtbl__find_rec_116(a1, a2, v16, v17, v18, v19);
}
// 41ACB4: variable 'v6' is possibly undefined
// 41ACB7: variable 'v7' is possibly undefined
// 41ACBA: variable 'v8' is possibly undefined
// 41ACF0: variable 'i' is possibly undefined
// 41AD34: variable 'v12' is possibly undefined
// 41AD93: variable 'a4' is possibly undefined
// 41AD93: variable 'a5' is possibly undefined
// 41AD93: variable 'a6' is possibly undefined
// 41AD93: variable 'v20' is possibly undefined
// 41ADA8: variable 'v16' is possibly undefined
// 41ADA8: variable 'v17' is possibly undefined
// 41ADA8: variable 'v18' is possibly undefined
// 41ADA8: variable 'v19' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041ADB0) ----------------------------------------------------
unsigned __int64 __fastcall camlHashtbl__find_rec_116(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rax
  __int64 v11; // [rsp+0h] [rbp-18h]
  unsigned __int64 *v12; // [rsp+8h] [rbp-10h]
  unsigned __int64 v13; // [rsp+10h] [rbp-8h]

  while ( 1 )
  {
    if ( v7 == (unsigned __int64 *)1 )
    {
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
        {
          *v8 = 1024LL;
          v8[1] = &caml_exn_Not_found;
          caml_raise_exn();
        }
        caml_call_gc(a1, a2, a3, a4, a5, a6, v11);
      }
    }
    v11 = v6;
    v12 = (unsigned __int64 *)v7[2];
    v13 = v7[1];
    a2 = *v7;
    a1 = v6;
    caml_c_call(v6, *v7);
    if ( v9 == 1 )
      break;
    v6 = v11;
    v7 = v12;
  }
  return v13;
}
// 41ADB8: variable 'v7' is possibly undefined
// 41ADBA: variable 'v6' is possibly undefined
// 41ADE6: variable 'v9' is possibly undefined
// 41AE00: variable 'v8' is possibly undefined
// 41AE2B: variable 'a3' is possibly undefined
// 41AE2B: variable 'a4' is possibly undefined
// 41AE2B: variable 'a5' is possibly undefined
// 41AE2B: variable 'a6' is possibly undefined
// 41AE2B: variable 'v11' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041AE40) ----------------------------------------------------
__int64 __fastcall camlHashtbl__find_121(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  _QWORD *v4; // r15
  __int64 v5; // r12
  __int64 v6; // rbp
  __int64 v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rcx
  __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  __int64 v13; // rdi
  __int64 *v14; // rdi
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // rax
  unsigned __int64 *v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rax
  __int64 v27; // rsi
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // rax
  __int64 v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // r8
  __int64 v36; // r9
  unsigned __int64 *v37; // [rsp+0h] [rbp-18h]
  __int64 v38; // [rsp+10h] [rbp-8h]
  unsigned __int64 v39; // [rsp+10h] [rbp-8h]
  unsigned __int64 v40; // [rsp+10h] [rbp-8h]

  v5 = v2;
  v6 = *(_QWORD *)(*(_QWORD *)(v2 + 8) - 8LL) >> 10;
  if ( v6 )
  {
    a2 = 201LL;
    v7 = caml_hash_univ_param(21LL, 201LL, v3);
    v10 = v6;
    v11 = (v7 >> 1) % v6;
  }
  else
  {
    caml_raise_exn();
  }
  v12 = 2 * v11 + 1;
  v13 = *(_QWORD *)(v5 + 8);
  if ( *(_QWORD *)(v13 - 8) >> 9 <= v12 )
  {
    caml_ml_array_bound_error(v13, a2);
    return camlHashtbl__find_all_133(v13, a2, v33, v34, v35, v36);
  }
  v14 = *(__int64 **)(v13 + 4 * v12 - 4);
  if ( v14 == (__int64 *)1 )
  {
    while ( 1 )
    {
LABEL_19:
      v4 -= 2;
      if ( (unsigned __int64)v4 >= caml_young_limit )
      {
        *v4 = 1024LL;
        v4[1] = &caml_exn_Not_found;
        caml_raise_exn();
      }
      caml_call_gc((__int64)v14, a2, v12, v10, v8, v9, (char)v37);
    }
  }
  v37 = (unsigned __int64 *)v14[2];
  v38 = v14[1];
  a2 = *v14;
  v14 = (__int64 *)v3;
  caml_c_call(v3, a2);
  if ( v19 == 1 )
    return v38;
  v21 = v37;
  if ( v37 == (unsigned __int64 *)1 )
  {
LABEL_17:
    while ( 1 )
    {
      v4 -= 2;
      if ( (unsigned __int64)v4 >= caml_young_limit )
        break;
      caml_call_gc((__int64)v14, a2, v15, v16, v17, v18, (char)v37);
    }
    *v4 = 1024LL;
    v4[1] = &caml_exn_Not_found;
    caml_raise_exn();
    goto LABEL_19;
  }
  v37 = (unsigned __int64 *)v37[2];
  v39 = v21[1];
  a2 = *v21;
  v14 = (__int64 *)v3;
  caml_c_call(v3, *v21);
  if ( v26 == 1 )
    return v39;
  if ( v37 == (unsigned __int64 *)1 )
  {
    while ( 1 )
    {
      v4 -= 2;
      if ( (unsigned __int64)v4 >= caml_young_limit )
        break;
      caml_call_gc(v3, a2, v22, v23, v24, v25, (char)v37);
    }
    *v4 = 1024LL;
    v4[1] = &caml_exn_Not_found;
    caml_raise_exn();
    goto LABEL_17;
  }
  v40 = v37[1];
  v27 = *v37;
  caml_c_call(v3, *v37);
  if ( v32 == 1 )
    return v40;
  else
    return camlHashtbl__find_rec_116(v3, v27, v28, v29, v30, v31);
}
// 41AE44: variable 'v2' is possibly undefined
// 41AE6A: variable 'v3' is possibly undefined
// 41AE88: variable 'v11' is possibly undefined
// 41AEDF: variable 'v19' is possibly undefined
// 41AF23: variable 'v26' is possibly undefined
// 41AF69: variable 'v32' is possibly undefined
// 41AF85: variable 'v28' is possibly undefined
// 41AF85: variable 'v29' is possibly undefined
// 41AF85: variable 'v30' is possibly undefined
// 41AF85: variable 'v31' is possibly undefined
// 41AF8C: variable 'v4' is possibly undefined
// 41B01B: variable 'v12' is possibly undefined
// 41B01B: variable 'v10' is possibly undefined
// 41B01B: variable 'v8' is possibly undefined
// 41B01B: variable 'v9' is possibly undefined
// 41B01B: variable 'v37' is possibly undefined
// 41B022: variable 'v15' is possibly undefined
// 41B022: variable 'v16' is possibly undefined
// 41B022: variable 'v17' is possibly undefined
// 41B022: variable 'v18' is possibly undefined
// 41B029: variable 'v22' is possibly undefined
// 41B029: variable 'v23' is possibly undefined
// 41B029: variable 'v24' is possibly undefined
// 41B029: variable 'v25' is possibly undefined
// 41B039: variable 'v33' is possibly undefined
// 41B039: variable 'v34' is possibly undefined
// 41B039: variable 'v35' is possibly undefined
// 41B039: variable 'v36' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041B040) ----------------------------------------------------
__int64 __fastcall camlHashtbl__find_all_133(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // r12
  __int64 i; // rdx
  __int64 v11; // rbp
  __int64 v12; // rdx
  __int64 v13; // rdi
  char v15; // [rsp+0h] [rbp-8h]

  v9 = v6;
  for ( i = v7; ; caml_call_gc(a1, a2, i, a4, a5, a6, v15) )
  {
    v8 -= 4;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 3319LL;
  v8[1] = camlHashtbl__find_in_bucket_136;
  v8[2] = 3LL;
  v8[3] = i;
  v11 = *(_QWORD *)(*(_QWORD *)(v9 + 8) - 8LL) >> 10;
  if ( v11 )
  {
    a2 = 201LL;
    v12 = (caml_hash_univ_param(21LL, 201LL, i) >> 1) % v11;
  }
  else
  {
    caml_raise_exn();
  }
  v13 = *(_QWORD *)(v9 + 8);
  if ( *(_QWORD *)(v13 - 8) >> 9 > (unsigned __int64)(2 * v12 + 1) )
    return camlHashtbl__find_in_bucket_136();
  caml_ml_array_bound_error(v13, a2);
  return camlHashtbl__replace_140(v13);
}
// 41B044: variable 'v6' is possibly undefined
// 41B047: variable 'v7' is possibly undefined
// 41B04A: variable 'v8' is possibly undefined
// 41B07C: variable 'i' is possibly undefined
// 41B0C0: variable 'v12' is possibly undefined
// 41B0E6: variable 'a4' is possibly undefined
// 41B0E6: variable 'a5' is possibly undefined
// 41B0E6: variable 'a6' is possibly undefined
// 41B0E6: variable 'v15' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041B100) ----------------------------------------------------
__int64 __fastcall camlHashtbl__replace_140(__int64 a1)
{
  _QWORD *v1; // rax
  __int64 v2; // rbx
  __int64 v3; // r15
  _QWORD *v4; // r12
  _QWORD *v5; // r15
  unsigned __int64 v6; // rsi
  __int64 v7; // rbp
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rcx
  __int64 v12; // rdx
  unsigned __int64 v13; // rdx
  __int64 v14; // rbx
  __int64 v15; // rdx
  _QWORD *v16; // r15
  unsigned __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  _QWORD *v22; // [rsp+0h] [rbp-38h]
  __int64 v23; // [rsp+8h] [rbp-30h]
  __int64 v24; // [rsp+10h] [rbp-28h]
  __int64 v25; // [rsp+18h] [rbp-20h]
  unsigned __int64 v26; // [rsp+30h] [rbp-8h]

  v4 = v1;
  v5 = (_QWORD *)(v3 - 40);
  if ( (unsigned __int64)v5 < caml_young_limit )
    JUMPOUT(0x41B2E1LL);
  v6 = (unsigned __int64)(v5 + 1);
  *v5 = 4343LL;
  v5[1] = camlHashtbl__replace_bucket_144;
  v5[2] = 3LL;
  v5[3] = v2;
  v5[4] = a1;
  v7 = *(_QWORD *)(v1[1] - 8LL) >> 10;
  if ( v7 )
  {
    v24 = a1;
    v23 = v2;
    v22 = v1;
    v6 = 201LL;
    a1 = 21LL;
    v8 = caml_hash_univ_param(21LL, 201LL, v2);
    v11 = v7;
    v12 = (v8 >> 1) % v7;
  }
  else
  {
    caml_raise_exn();
  }
  v13 = 2 * v12 + 1;
  v26 = v13;
  v14 = v4[1];
  if ( *(_QWORD *)(v14 - 8) >> 9 <= v13 )
    JUMPOUT(0x41B2F5LL);
  v25 = *(_QWORD *)(v14 + 4 * v13 - 4);
  if ( *(char ***)sub_41B288(a1, v6, v13, v11, v9, v10) == &caml_exn_Not_found )
  {
    v15 = v22[1];
    if ( *(_QWORD *)(v15 - 8) >> 9 <= v26 )
      JUMPOUT(0x41B2F0LL);
    v16 = v5 - 4;
    if ( (unsigned __int64)v16 < caml_young_limit )
      JUMPOUT(0x41B2D7LL);
    *v16 = 3072LL;
    v16[1] = v23;
    v16[2] = v24;
    v16[3] = v25;
    caml_modify((unsigned __int64 *)(v15 + 4 * v26 - 4), (unsigned __int64)(v16 + 1));
    *v22 += 2LL;
    if ( *v22 <= 2 * ((*(_QWORD *)(v22[1] - 8LL) >> 9) | 1LL) - 1 )
      return 1LL;
    else
      return camlHashtbl__resize_89();
  }
  else
  {
    caml_raise_exn();
    return sub_41B288((__int64)&caml_exn_Not_found, v6, v18, v19, v20, v21);
  }
}
// 41B115: control flows out of bounds to 41B2E1
// 41B1B3: control flows out of bounds to 41B2F5
// 41B1F3: control flows out of bounds to 41B2F0
// 41B207: control flows out of bounds to 41B2D7
// 41B104: variable 'v1' is possibly undefined
// 41B107: variable 'v3' is possibly undefined
// 41B139: variable 'v2' is possibly undefined
// 41B198: variable 'v12' is possibly undefined
// 41B1C3: variable 'v11' is possibly undefined
// 41B1C3: variable 'v9' is possibly undefined
// 41B1C3: variable 'v10' is possibly undefined
// 41B1DF: variable 'v22' is possibly undefined
// 41B21E: variable 'v23' is possibly undefined
// 41B226: variable 'v24' is possibly undefined
// 41B286: variable 'v18' is possibly undefined
// 41B286: variable 'v19' is possibly undefined
// 41B286: variable 'v20' is possibly undefined
// 41B286: variable 'v21' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041B288) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_41B288(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r12
  _QWORD *v7; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // [rsp-8h] [rbp-10h]
  __int64 v14; // [rsp+0h] [rbp-8h]

  v13 = *(_QWORD *)(v6 + 8);
  if ( *(_QWORD *)(v13 - 8) >> 9 <= a3 )
  {
    caml_ml_array_bound_error(a1, a2);
    caml_ml_array_bound_error(a1, a2);
    caml_ml_array_bound_error(a1, a2);
    return camlHashtbl__mem_150(a1, a2, v9, v10, v11, v12);
  }
  else
  {
    v7 = camlHashtbl__replace_bucket_144(a1, a2, a3, a4, a5, a6);
    caml_modify((unsigned __int64 *)(v13 + 4 * v14 - 4), (unsigned __int64)v7);
    return 1LL;
  }
}
// 41B2D6: positive sp value 40 has been found
// 41B28D: variable 'v6' is possibly undefined
// 41B2B8: variable 'v14' is possibly undefined
// 41B2FB: variable 'v9' is possibly undefined
// 41B2FB: variable 'v10' is possibly undefined
// 41B2FB: variable 'v11' is possibly undefined
// 41B2FB: variable 'v12' is possibly undefined

//----- (000000000041B300) ----------------------------------------------------
__int64 __fastcall camlHashtbl__mem_150(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // r12
  __int64 i; // rdx
  __int64 v11; // rbp
  __int64 v12; // rdx
  __int64 v13; // rdi
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  char v19; // [rsp+0h] [rbp-8h]

  v9 = v6;
  for ( i = v7; ; caml_call_gc(a1, a2, i, a4, a5, a6, v19) )
  {
    v8 -= 4;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 3319LL;
  v8[1] = camlHashtbl__mem_in_bucket_153;
  v8[2] = 3LL;
  v8[3] = i;
  v11 = *(_QWORD *)(*(_QWORD *)(v9 + 8) - 8LL) >> 10;
  if ( v11 )
  {
    a2 = 201LL;
    v12 = (caml_hash_univ_param(21LL, 201LL, i) >> 1) % v11;
  }
  else
  {
    caml_raise_exn();
  }
  v13 = *(_QWORD *)(v9 + 8);
  if ( *(_QWORD *)(v13 - 8) >> 9 > (unsigned __int64)(2 * v12 + 1) )
    return camlHashtbl__mem_in_bucket_153();
  caml_ml_array_bound_error(v13, a2);
  return camlHashtbl__iter_157(v13, a2, v15, v16, v17, v18);
}
// 41B304: variable 'v6' is possibly undefined
// 41B307: variable 'v7' is possibly undefined
// 41B30A: variable 'v8' is possibly undefined
// 41B33C: variable 'i' is possibly undefined
// 41B380: variable 'v12' is possibly undefined
// 41B3A6: variable 'a4' is possibly undefined
// 41B3A6: variable 'a5' is possibly undefined
// 41B3A6: variable 'a6' is possibly undefined
// 41B3A6: variable 'v19' is possibly undefined
// 41B3B6: variable 'v15' is possibly undefined
// 41B3B6: variable 'v16' is possibly undefined
// 41B3B6: variable 'v17' is possibly undefined
// 41B3B6: variable 'v18' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041B3C0) ----------------------------------------------------
__int64 __fastcall camlHashtbl__iter_157(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdi
  unsigned __int64 v10; // rsi
  __int64 v11; // rdi
  unsigned __int64 v12; // rbx
  unsigned __int64 v13; // rdi
  __int64 v14; // rdi
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  char v20; // [rsp+0h] [rbp-28h]
  __int64 v21; // [rsp+0h] [rbp-28h]
  __int64 v22; // [rsp+10h] [rbp-18h]
  __int64 v23; // [rsp+18h] [rbp-10h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v20) )
  {
    v8 -= 4;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  v10 = (unsigned __int64)(v8 + 1);
  *v8 = 3319LL;
  v8[1] = camlHashtbl__do_bucket_160;
  v8[2] = 3LL;
  v8[3] = i;
  v11 = *(_QWORD *)(v7 + 8);
  v12 = 1LL;
  if ( ((*(_QWORD *)(v11 - 8) >> 9) | 1LL) - 2 < 1 )
    return 1LL;
  v23 = ((*(_QWORD *)(v11 - 8) >> 9) | 1LL) - 2;
  v22 = 1LL;
  v21 = v11;
  while ( 1 )
  {
    v13 = *(_QWORD *)(v21 - 8) >> 9;
    if ( v13 <= v12 )
      break;
    camlHashtbl__do_bucket_160();
    v14 = v22;
    v12 = v22 + 2;
    v22 += 2LL;
    if ( v14 == v23 )
      return 1LL;
  }
  caml_ml_array_bound_error(v13, v10);
  return (__int64)camlHashtbl__fold_166(v13, v10, v16, v17, v18, v19);
}
// 41B3C4: variable 'v6' is possibly undefined
// 41B3C7: variable 'v8' is possibly undefined
// 41B3FD: variable 'v7' is possibly undefined
// 41B477: variable 'a3' is possibly undefined
// 41B477: variable 'a4' is possibly undefined
// 41B477: variable 'a5' is possibly undefined
// 41B477: variable 'a6' is possibly undefined
// 41B477: variable 'v20' is possibly undefined
// 41B487: variable 'v16' is possibly undefined
// 41B487: variable 'v17' is possibly undefined
// 41B487: variable 'v18' is possibly undefined
// 41B487: variable 'v19' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041B490) ----------------------------------------------------
_QWORD *__fastcall camlHashtbl__fold_166(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  __int64 v10; // rsi
  _QWORD *v11; // rbx
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rsi
  __int64 v14; // rax
  __int64 v15; // rsi
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  char v21; // [rsp+0h] [rbp-28h]
  __int64 v22; // [rsp+0h] [rbp-28h]
  __int64 v23; // [rsp+18h] [rbp-10h]
  __int64 v24; // [rsp+20h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v21) )
  {
    v8 -= 7;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 4343LL;
  v8[1] = caml_curry2;
  v8[2] = 5LL;
  v8[3] = camlHashtbl__do_bucket_170;
  v8[4] = i;
  v10 = *(_QWORD *)(v7 + 8);
  v11 = v8 + 6;
  v8[5] = 1024LL;
  v8[6] = a1;
  v12 = 1LL;
  if ( ((*(_QWORD *)(v10 - 8) >> 9) | 1LL) - 2 < 1 )
    return (_QWORD *)*v11;
  v24 = ((*(_QWORD *)(v10 - 8) >> 9) | 1LL) - 2;
  v23 = 1LL;
  v22 = v10;
  while ( 1 )
  {
    v13 = *(_QWORD *)(v22 - 8) >> 9;
    if ( v13 <= v12 )
      break;
    v14 = camlHashtbl__do_bucket_170((__int64)(v8 + 1));
    v11 = v8 + 6;
    caml_modify(v8 + 6, v14);
    v15 = v23;
    v12 = v23 + 2;
    v23 += 2LL;
    if ( v15 == v24 )
      return (_QWORD *)*v11;
  }
  caml_ml_array_bound_error(v22, v13);
  return camlHashtbl__Make_279(v22, v13, v17, v18, v19, v20);
}
// 41B494: variable 'v6' is possibly undefined
// 41B497: variable 'v8' is possibly undefined
// 41B4D8: variable 'v7' is possibly undefined
// 41B575: variable 'a3' is possibly undefined
// 41B575: variable 'a4' is possibly undefined
// 41B575: variable 'a5' is possibly undefined
// 41B575: variable 'a6' is possibly undefined
// 41B575: variable 'v21' is possibly undefined
// 41B585: variable 'v17' is possibly undefined
// 41B585: variable 'v18' is possibly undefined
// 41B585: variable 'v19' is possibly undefined
// 41B585: variable 'v20' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041B590) ----------------------------------------------------
_QWORD *__fastcall camlHashtbl__Make_279(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // r8
  __int64 v9; // r12
  __int64 v10; // rbp
  __int64 v11; // r11
  _QWORD *v12; // rbx
  _QWORD *v13; // r10
  __int64 v14; // r9
  __int64 v15; // rdi
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // rbx
  __int64 v19; // r13
  _QWORD *result; // rax
  char v21; // [rsp+0h] [rbp-8h]

  v8 = v6;
  v9 = camlHashtbl[0];
  v10 = camlHashtbl[1];
  v11 = camlHashtbl[3];
  while ( 1 )
  {
    v7 -= 27;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc(a1, a2, a3, a4, v8, a6, v21);
  }
  v12 = v7 + 1;
  *v7 = 3319LL;
  v7[1] = camlHashtbl__safehash_205;
  v7[2] = 3LL;
  v7[3] = v8;
  v13 = v7 + 5;
  v7[4] = 4343LL;
  v7[5] = caml_curry3;
  v7[6] = 7LL;
  v7[7] = camlHashtbl__add_207;
  v7[8] = v7 + 1;
  v14 = (__int64)(v7 + 10);
  v7[9] = 5367LL;
  v7[10] = caml_curry2;
  v7[11] = 5LL;
  v7[12] = camlHashtbl__remove_213;
  v7[13] = v8;
  v7[14] = v7 + 1;
  v15 = (__int64)(v7 + 16);
  v7[15] = 4343LL;
  v7[16] = caml_curry2;
  v7[17] = 5LL;
  v7[18] = camlHashtbl__find_rec_221;
  v7[19] = v8;
  v16 = (__int64)(v7 + 21);
  v7[20] = 6391LL;
  v7[21] = caml_curry2;
  v7[22] = 5LL;
  v7[23] = camlHashtbl__find_226;
  v7[24] = v8;
  v7[25] = v7 + 1;
  v7[26] = v7 + 16;
  while ( 1 )
  {
    v7 -= 31;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc(v15, a2, a3, v16, v8, v14, v21);
  }
  *v7 = 5367LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlHashtbl__find_all_238;
  v7[4] = v8;
  v7[5] = v12;
  v7[6] = 5367LL;
  v7[7] = caml_curry3;
  v7[8] = 7LL;
  v7[9] = camlHashtbl__replace_245;
  v7[10] = v8;
  v7[11] = v12;
  v7[12] = 5367LL;
  v7[13] = caml_curry2;
  v7[14] = 5LL;
  v7[15] = camlHashtbl__mem_255;
  v7[16] = v8;
  v7[17] = v12;
  v17 = camlHashtbl[9];
  v18 = camlHashtbl[10];
  v19 = camlHashtbl[11];
  result = v7 + 19;
  v7[18] = 12288LL;
  v7[19] = v9;
  v7[20] = v10;
  v7[21] = v11;
  v7[22] = v13;
  v7[23] = v14;
  v7[24] = v16;
  v7[25] = v7 + 1;
  v7[26] = v7 + 7;
  v7[27] = v7 + 13;
  v7[28] = v17;
  v7[29] = v18;
  v7[30] = v19;
  return result;
}
// 41B594: variable 'v6' is possibly undefined
// 41B5B7: variable 'v7' is possibly undefined
// 41B5EC: variable 'v8' is possibly undefined
// 41B794: variable 'v11' is possibly undefined
// 41B798: variable 'v13' is possibly undefined
// 41B79C: variable 'v14' is possibly undefined
// 41B7A0: variable 'v16' is possibly undefined
// 41B7C1: variable 'a3' is possibly undefined
// 41B7C1: variable 'v21' is possibly undefined
// 41B7CB: variable 'a4' is possibly undefined
// 41B7CB: variable 'a6' is possibly undefined
// 419F90: using guessed type __int64 __fastcall camlHashtbl__safehash_205();
// 651858: using guessed type _QWORD camlHashtbl[17];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041B7E0) ----------------------------------------------------
__int64 camlHashtbl__entry()
{
  camlHashtbl[13] = &camlHashtbl__16;
  camlHashtbl[0] = &camlHashtbl__15;
  camlHashtbl[1] = &camlHashtbl__14;
  camlHashtbl[3] = &camlHashtbl__13;
  camlHashtbl[11] = &camlHashtbl__12;
  camlHashtbl[14] = &camlHashtbl__11;
  camlHashtbl[2] = &camlHashtbl__10;
  camlHashtbl[7] = &camlHashtbl__9;
  camlHashtbl[15] = &camlHashtbl__8;
  camlHashtbl[4] = &camlHashtbl__7;
  camlHashtbl[5] = &camlHashtbl__6;
  camlHashtbl[8] = &camlHashtbl__5;
  camlHashtbl[6] = &camlHashtbl__4;
  camlHashtbl[9] = &camlHashtbl__3;
  camlHashtbl[10] = &camlHashtbl__2;
  camlHashtbl[12] = &camlHashtbl__1;
  return 1LL;
}
// 651858: using guessed type _QWORD camlHashtbl[17];
// 6518E0: using guessed type __int64 (__fastcall *camlHashtbl__1)();
// 6518F8: using guessed type __int64 (__fastcall *camlHashtbl__2)();
// 651918: using guessed type __int64 (__fastcall *camlHashtbl__3)();
// 651938: using guessed type __int64 (__fastcall *camlHashtbl__4)();
// 651958: using guessed type __int64 (__fastcall *camlHashtbl__5)();
// 651978: using guessed type __int64 (__fastcall *camlHashtbl__6)();
// 651998: using guessed type __int64 (__fastcall *camlHashtbl__7)();
// 6519B8: using guessed type __int64 (__fastcall *camlHashtbl__8)();
// 6519D8: using guessed type __int64 (__fastcall *camlHashtbl__9)();
// 6519F8: using guessed type __int64 (__fastcall *camlHashtbl__10)();
// 651A18: using guessed type __int64 (__fastcall *camlHashtbl__11)();
// 651A38: using guessed type __int64 (__fastcall *camlHashtbl__12)();
// 651A50: using guessed type __int64 (__fastcall *camlHashtbl__13)();
// 651A68: using guessed type __int64 (__fastcall *camlHashtbl__14)();
// 651A80: using guessed type __int64 (__fastcall *camlHashtbl__15)();
// 651A98: using guessed type __int64 (__fastcall *camlHashtbl__16)();

//----- (000000000041B910) ----------------------------------------------------
void __fastcall camlMarshal__code_begin(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  caml_c_call(v2, a2);
}
// 41B91E: variable 'v2' is possibly undefined

//----- (000000000041B930) ----------------------------------------------------
void __fastcall camlMarshal__fun_94()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 41B944: variable 'v0' is possibly undefined
// 41B944: variable 'v1' is possibly undefined

//----- (000000000041B950) ----------------------------------------------------
void __fastcall camlMarshal__to_buffer_66(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  signed __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // rdi

  v5 = a1;
  v6 = a2;
  if ( v4 < 1
    || a1 < 1
    || (v7 = 8LL * (*(_QWORD *)(v3 - 8) >> 10) - 1,
        a2 = *(unsigned __int8 *)(v3 + v7),
        a1 = 2 * (v7 - a2) - v5 + 2,
        v4 > a1) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, v5, v6, a3);
  }
  caml_c_call(v3, v4);
}
// 41B961: variable 'v4' is possibly undefined
// 41B969: variable 'v3' is possibly undefined

//----- (000000000041B9C0) ----------------------------------------------------
void __fastcall camlMarshal__data_size_76(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  signed __int64 v7; // rbx
  __int64 v8; // rdx

  if ( v7 < 1
    || (v8 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1, a4 = *(unsigned __int8 *)(v6 + v8), a3 = 2 * (v8 - a4) - 39, v7 > a3) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  }
  caml_c_call(v6, v7);
}
// 41B9C8: variable 'v7' is possibly undefined
// 41B9CA: variable 'v6' is possibly undefined

//----- (000000000041BA20) ----------------------------------------------------
__int64 __fastcall camlMarshal__total_size_79(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax

  camlMarshal__data_size_76(a1, a2, a3, a4, a5, a6);
  return v6 + 40;
}
// 41BA29: variable 'v6' is possibly undefined

//----- (000000000041BA40) ----------------------------------------------------
void __fastcall camlMarshal__from_string_82(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // rax
  __int64 v16; // [rsp+0h] [rbp-18h]

  if ( v7 < 1
    || (v8 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1, a4 = *(unsigned __int8 *)(v6 + v8), a3 = 2 * (v8 - a4) - 39, v7 > a3) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  }
  v16 = v6;
  caml_c_call(v6, v7);
  v14 = v13;
  v15 = 8LL * (*(_QWORD *)(v16 - 8) >> 10) - 1;
  if ( v7 > 2 * (v15 - *(unsigned __int8 *)(v16 + v15)) - v14 - 38 )
    camlPervasives__invalid_arg_40(v16, v7, v9, v10, v11, v12);
  caml_c_call(v16, v7);
}
// 41BA48: variable 'v7' is possibly undefined
// 41BA4E: variable 'v6' is possibly undefined
// 41BA8B: variable 'v13' is possibly undefined
// 41BAC9: variable 'v9' is possibly undefined
// 41BAC9: variable 'v10' is possibly undefined
// 41BAC9: variable 'v11' is possibly undefined
// 41BAC9: variable 'v12' is possibly undefined

//----- (000000000041BB00) ----------------------------------------------------
__int64 camlMarshal__entry()
{
  camlMarshal[2] = &camlMarshal__6;
  camlMarshal[0] = &camlMarshal__5;
  camlMarshal[1] = &camlMarshal__4;
  camlMarshal[4] = 41LL;
  camlMarshal[5] = &camlMarshal__3;
  camlMarshal[6] = &camlMarshal__2;
  camlMarshal[3] = &camlMarshal__1;
  return 1LL;
}
// 652740: using guessed type _QWORD camlMarshal[8];
// 652780: using guessed type __int64 (__fastcall *camlMarshal__1)();
// 6527A0: using guessed type __int64 (__fastcall *camlMarshal__2)();
// 6527C0: using guessed type __int64 (__fastcall *camlMarshal__3)();
// 6527E0: using guessed type __int64 (__fastcall *camlMarshal__4)();
// 652800: using guessed type __int64 (__fastcall *camlMarshal__5)();
// 652820: using guessed type __int64 (__fastcall *camlMarshal__6)();

//----- (000000000041BB90) ----------------------------------------------------
void __fastcall camlObj__code_begin(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r15
  unsigned __int64 i; // rsi
  double *v10; // rdi
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 16LL;
    if ( v8 >= caml_young_limit )
      break;
  }
  *(_QWORD *)v8 = 1277LL;
  v10 = (double *)(*(_QWORD *)(i - 8) >> 9);
  if ( (unsigned __int64)v10 <= v7 )
  {
    caml_ml_array_bound_error((__int64)v10, i);
    camlObj__set_double_field_72(v10);
  }
  else
  {
    *(double *)(v8 + 8) = *(double *)(i + 4 * v7 - 4);
  }
}
// 41BB94: variable 'v6' is possibly undefined
// 41BB97: variable 'v8' is possibly undefined
// 41BBBE: variable 'v7' is possibly undefined
// 41BBCF: variable 'a3' is possibly undefined
// 41BBCF: variable 'a4' is possibly undefined
// 41BBCF: variable 'a5' is possibly undefined
// 41BBCF: variable 'a6' is possibly undefined
// 41BBCF: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041BBE0) ----------------------------------------------------
void __fastcall camlObj__set_double_field_72(double *a1)
{
  __int64 v1; // rax
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // rsi

  v3 = *(_QWORD *)(v1 - 8) >> 9;
  if ( v3 <= v2 )
  {
    caml_ml_array_bound_error((__int64)a1, v3);
    camlObj__marshal_80();
  }
  else
  {
    *(double *)(v1 + 4 * v2 - 4) = *a1;
  }
}
// 41BBE0: variable 'v1' is possibly undefined
// 41BBEB: variable 'v2' is possibly undefined

//----- (000000000041BC10) ----------------------------------------------------
void __fastcall camlObj__marshal_80()
{
  __int64 v0; // rax

  caml_c_call(v0, 1uLL);
}
// 41BC25: variable 'v0' is possibly undefined

//----- (000000000041BC30) ----------------------------------------------------
_QWORD *__fastcall camlObj__unmarshal_82(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  _QWORD *v7; // r15
  __int64 v8; // rax
  __int64 v9; // rdi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rax
  __int64 v19; // rbx
  _QWORD *result; // rax
  __int64 v21; // [rsp+0h] [rbp-18h]

  camlMarshal__data_size_76(a1, a2, a3, a4, a5, a6);
  v9 = v8;
  v21 = v8 + v6 + 39;
  camlMarshal__from_string_82(v8, a2, v10, v11, v12, v13);
  v19 = v18;
  while ( 1 )
  {
    v7 -= 3;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc(v9, a2, v14, v15, v16, v17, v21);
  }
  result = v7 + 1;
  *v7 = 2048LL;
  v7[1] = v19;
  v7[2] = v21;
  return result;
}
// 41BC30: could not find valid save-restore pair for rbx
// 41BC42: variable 'v8' is possibly undefined
// 41BC4C: variable 'v6' is possibly undefined
// 41BC5C: variable 'v10' is possibly undefined
// 41BC5C: variable 'v11' is possibly undefined
// 41BC5C: variable 'v12' is possibly undefined
// 41BC5C: variable 'v13' is possibly undefined
// 41BC61: variable 'v18' is possibly undefined
// 41BC64: variable 'v7' is possibly undefined
// 41BC87: variable 'v21' is possibly undefined
// 41BC90: variable 'v14' is possibly undefined
// 41BC90: variable 'v15' is possibly undefined
// 41BC90: variable 'v16' is possibly undefined
// 41BC90: variable 'v17' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041BCA0) ----------------------------------------------------
__int64 camlObj__entry()
{
  camlObj[0] = &camlObj__4;
  camlObj[1] = &camlObj__3;
  camlObj[17] = &camlObj__2;
  camlObj[18] = &camlObj__1;
  camlObj[2] = 493LL;
  camlObj[3] = 495LL;
  camlObj[4] = 497LL;
  camlObj[5] = 499LL;
  camlObj[6] = 501LL;
  camlObj[7] = 503LL;
  camlObj[8] = 503LL;
  camlObj[9] = 505LL;
  camlObj[10] = 507LL;
  camlObj[11] = 509LL;
  camlObj[12] = 511LL;
  camlObj[13] = 511LL;
  camlObj[14] = 2001LL;
  camlObj[15] = 2003LL;
  camlObj[16] = 2005LL;
  return 1LL;
}
// 6529B0: using guessed type _QWORD camlObj[20];
// 652A50: using guessed type __int64 (__fastcall *camlObj__1)();
// 652A70: using guessed type __int64 (__fastcall *camlObj__2)();
// 652A88: using guessed type __int64 (__fastcall *camlObj__3)();
// 652AA8: using guessed type __int64 (__fastcall *camlObj__4)();

//----- (000000000041BDE0) ----------------------------------------------------
__int64 __fastcall camlMap__code_begin(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rbx
  __int64 v3; // rsi
  __int64 result; // rax
  __int64 v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  _QWORD *v14; // [rsp+0h] [rbp-38h]
  __int64 v15; // [rsp+30h] [rbp-8h]

  while ( v1 != (_QWORD *)1 )
  {
    if ( v2 == (_QWORD *)1 )
      return 3LL;
    v15 = a1;
    v3 = v1[1];
    result = caml_apply2(**(_QWORD **)(a1 + 24));
    if ( result != 1 )
      return result;
    v5 = *(_QWORD *)(a1 + 40);
    result = caml_apply2(v5);
    if ( result != 1 )
      return result;
    v14 = camlMap__cons_enum_210(v5, v3, v6, v7, v8, v9);
    v1 = camlMap__cons_enum_210(v5, v3, v10, v11, v12, v13);
    v2 = v14;
    a1 = v15;
  }
  if ( v2 == (_QWORD *)1 )
    return 1LL;
  else
    return -1LL;
}
// 41BDE8: variable 'v1' is possibly undefined
// 41BDF2: variable 'v2' is possibly undefined
// 41BE7E: variable 'v6' is possibly undefined
// 41BE7E: variable 'v7' is possibly undefined
// 41BE7E: variable 'v8' is possibly undefined
// 41BE7E: variable 'v9' is possibly undefined
// 41BE91: variable 'v10' is possibly undefined
// 41BE91: variable 'v11' is possibly undefined
// 41BE91: variable 'v12' is possibly undefined
// 41BE91: variable 'v13' is possibly undefined

//----- (000000000041BED0) ----------------------------------------------------
__int64 __fastcall camlMap__equal_aux_238(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v2; // rbx
  __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  _QWORD *v14; // [rsp+0h] [rbp-38h]
  __int64 v15; // [rsp+30h] [rbp-8h]

  while ( v1 != (_QWORD *)1 )
  {
    if ( v2 == (_QWORD *)1 )
      return 1LL;
    v15 = a1;
    v3 = v1[1];
    if ( caml_apply2(**(_QWORD **)(a1 + 24)) != 1 )
      return 1LL;
    v4 = *(_QWORD *)(a1 + 40);
    if ( caml_apply2(v4) == 1 )
      return 1LL;
    v14 = camlMap__cons_enum_210(v4, v3, v5, v6, v7, v8);
    v1 = camlMap__cons_enum_210(v4, v3, v9, v10, v11, v12);
    v2 = v14;
    a1 = v15;
  }
  if ( v2 == (_QWORD *)1 )
    return 3LL;
  else
    return 1LL;
}
// 41BED8: variable 'v1' is possibly undefined
// 41BEE2: variable 'v2' is possibly undefined
// 41BF61: variable 'v5' is possibly undefined
// 41BF61: variable 'v6' is possibly undefined
// 41BF61: variable 'v7' is possibly undefined
// 41BF61: variable 'v8' is possibly undefined
// 41BF74: variable 'v9' is possibly undefined
// 41BF74: variable 'v10' is possibly undefined
// 41BF74: variable 'v11' is possibly undefined
// 41BF74: variable 'v12' is possibly undefined

//----- (000000000041BFD0) ----------------------------------------------------
__int64 __fastcall camlMap__height_85()
{
  __int64 v0; // rax

  if ( v0 == 1 )
    return 1LL;
  else
    return *(_QWORD *)(v0 + 32);
}
// 41BFD4: variable 'v0' is possibly undefined
// 41BFD0: using guessed type __int64 __fastcall camlMap__height_85();

//----- (000000000041BFF0) ----------------------------------------------------
_QWORD *__fastcall camlMap__create_87(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdx
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *result; // rax
  char v14; // [rsp+0h] [rbp-8h]

  v9 = v6;
  if ( v6 == 1 )
    v10 = 1LL;
  else
    v10 = *(_QWORD *)(v6 + 32);
  if ( a2 == 1 )
    v11 = 1LL;
  else
    v11 = *(_QWORD *)(a2 + 32);
  if ( v10 < v11 )
    v12 = v11 + 2;
  else
    v12 = v10 + 2;
  while ( 1 )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(a1, a2, v9, v12, a5, a6, v14);
  }
  result = v8 + 1;
  *v8 = 5120LL;
  v8[1] = v9;
  v8[2] = v7;
  v8[3] = a1;
  v8[4] = a2;
  v8[5] = v12;
  return result;
}
// 41BFF4: variable 'v6' is possibly undefined
// 41C034: variable 'v8' is possibly undefined
// 41C050: variable 'v9' is possibly undefined
// 41C053: variable 'v7' is possibly undefined
// 41C05F: variable 'v12' is possibly undefined
// 41C068: variable 'a5' is possibly undefined
// 41C068: variable 'a6' is possibly undefined
// 41C068: variable 'v14' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041C070) ----------------------------------------------------
_QWORD *__fastcall camlMap__bal_94(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 *v9; // rdx
  __int64 v10; // r8
  __int64 v11; // rcx
  __int64 *v12; // rax
  __int64 v13; // r10
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // rcx
  __int64 v17; // rdx
  _QWORD *v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  _QWORD *result; // rax
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // r8
  __int64 v27; // r9
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // rcx
  __int64 v33; // r9
  __int64 v34; // r8
  __int64 *v35; // rsi
  __int64 v36; // r10
  __int64 v37; // rax
  __int64 v38; // rdx
  __int64 v39; // rcx
  __int64 v40; // r8
  __int64 v41; // r9
  __int64 v42; // rdx
  __int64 v43; // rcx
  __int64 v44; // r8
  __int64 v45; // r9
  __int64 v46; // rdx
  __int64 v47; // rcx
  __int64 v48; // r8
  __int64 v49; // r9
  __int64 v50; // rcx
  char v51; // [rsp+0h] [rbp-38h]
  __int64 v52; // [rsp+0h] [rbp-38h]
  __int64 v53; // [rsp+8h] [rbp-30h]
  __int64 v54; // [rsp+10h] [rbp-28h]
  __int64 v55; // [rsp+10h] [rbp-28h]
  _QWORD *v56; // [rsp+18h] [rbp-20h]
  __int64 v57; // [rsp+18h] [rbp-20h]
  __int64 v58; // [rsp+28h] [rbp-10h]
  __int64 v59; // [rsp+30h] [rbp-8h]
  __int64 v60; // [rsp+30h] [rbp-8h]
  _QWORD *_87; // [rsp+30h] [rbp-8h]

  v9 = (__int64 *)v6;
  if ( v6 == 1 )
    v10 = 1LL;
  else
    v10 = *(_QWORD *)(v6 + 32);
  if ( a2 == 1 )
    v11 = 1LL;
  else
    v11 = *(_QWORD *)(a2 + 32);
  if ( v10 <= v11 + 4 )
  {
    if ( v11 <= v10 + 4 )
    {
      if ( v10 < v11 )
        v50 = v11 + 2;
      else
        v50 = v10 + 2;
      while ( 1 )
      {
        v8 -= 6;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(a1, a2, (__int64)v9, v50, v10, a6, v51);
      }
      result = v8 + 1;
      *v8 = 5120LL;
      v8[1] = v9;
      v8[2] = v7;
      v8[3] = a1;
      v8[4] = a2;
      v8[5] = v50;
    }
    else
    {
      if ( a2 == 1 )
        camlPervasives__invalid_arg_40(a1, 1LL, v6, v11, v10, a6);
      v32 = *(_QWORD *)(a2 + 24);
      v33 = *(_QWORD *)(a2 + 16);
      v34 = *(_QWORD *)(a2 + 8);
      v35 = *(__int64 **)a2;
      if ( v35 == (__int64 *)1 )
        v36 = 1LL;
      else
        v36 = v35[4];
      if ( v32 == 1 )
        v37 = 1LL;
      else
        v37 = *(_QWORD *)(v32 + 32);
      if ( v37 < v36 )
      {
        if ( v35 == (__int64 *)1 )
          camlPervasives__invalid_arg_40(a1, 1LL, (__int64)v9, v32, v34, v33);
        v58 = v35[2];
        v57 = *v35;
        _87 = camlMap__create_87(v33, v32, (__int64)v9, v32, v34, v33);
        camlMap__create_87(a1, v57, v42, v43, v44, v45);
        return camlMap__create_87(v58, (__int64)_87, v46, v47, v48, v49);
      }
      else
      {
        v53 = v33;
        v55 = v32;
        camlMap__create_87(a1, (__int64)v35, (__int64)v9, v32, v34, v33);
        return camlMap__create_87(v53, v55, v38, v39, v40, v41);
      }
    }
  }
  else
  {
    if ( v6 == 1 )
      camlPervasives__invalid_arg_40(a1, a2, 1LL, v11, v10, a6);
    v12 = *(__int64 **)(v6 + 24);
    v13 = v9[2];
    v14 = v9[1];
    v15 = *v9;
    if ( v12 == (__int64 *)1 )
      v16 = 1LL;
    else
      v16 = v12[4];
    if ( v15 == 1 )
      v17 = 1LL;
    else
      v17 = *(_QWORD *)(v15 + 32);
    if ( v17 < v16 )
    {
      if ( v12 == (__int64 *)1 )
        camlPervasives__invalid_arg_40(a1, a2, v17, v16, v15, v14);
      v60 = v13;
      v54 = v12[2];
      v52 = *v12;
      v56 = camlMap__create_87(a1, a2, v12[1], v12[3], v15, v14);
      camlMap__create_87(v60, v52, v24, v25, v26, v27);
      return camlMap__create_87(v54, (__int64)v56, v28, v29, v30, v31);
    }
    else
    {
      v59 = v13;
      v18 = camlMap__create_87(a1, a2, v17, v16, v15, v14);
      return camlMap__create_87(v59, (__int64)v18, v19, v20, v21, v22);
    }
  }
  return result;
}
// 41C074: variable 'v6' is possibly undefined
// 41C11E: variable 'v19' is possibly undefined
// 41C11E: variable 'v20' is possibly undefined
// 41C11E: variable 'v21' is possibly undefined
// 41C11E: variable 'v22' is possibly undefined
// 41C176: variable 'v24' is possibly undefined
// 41C176: variable 'v25' is possibly undefined
// 41C176: variable 'v26' is possibly undefined
// 41C176: variable 'v27' is possibly undefined
// 41C18E: variable 'v28' is possibly undefined
// 41C18E: variable 'v29' is possibly undefined
// 41C18E: variable 'v30' is possibly undefined
// 41C18E: variable 'v31' is possibly undefined
// 41C234: variable 'v38' is possibly undefined
// 41C234: variable 'v39' is possibly undefined
// 41C234: variable 'v40' is possibly undefined
// 41C234: variable 'v41' is possibly undefined
// 41C297: variable 'v42' is possibly undefined
// 41C297: variable 'v43' is possibly undefined
// 41C297: variable 'v44' is possibly undefined
// 41C297: variable 'v45' is possibly undefined
// 41C2AF: variable 'v46' is possibly undefined
// 41C2AF: variable 'v47' is possibly undefined
// 41C2AF: variable 'v48' is possibly undefined
// 41C2AF: variable 'v49' is possibly undefined
// 41C2E8: variable 'v8' is possibly undefined
// 41C304: variable 'v9' is possibly undefined
// 41C307: variable 'v7' is possibly undefined
// 41C313: variable 'v50' is possibly undefined
// 41C31C: variable 'v10' is possibly undefined
// 41C31C: variable 'a6' is possibly undefined
// 41C31C: variable 'v51' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041C330) ----------------------------------------------------
__int64 __fastcall camlMap__is_empty_120()
{
  __int64 v0; // rax

  if ( v0 == 1 )
    return 3LL;
  else
    return 1LL;
}
// 41C334: variable 'v0' is possibly undefined
// 41C330: using guessed type __int64 __fastcall camlMap__is_empty_120();

//----- (000000000041C350) ----------------------------------------------------
_QWORD *__fastcall camlMap__add_121(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdx
  __int64 v10; // rdi
  __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  _QWORD *result; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  _QWORD *v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  char v26; // [rsp+0h] [rbp-48h]
  char v27; // [rsp+0h] [rbp-48h]
  __int64 v28; // [rsp+10h] [rbp-38h]
  __int64 *v29; // [rsp+18h] [rbp-30h]
  __int64 v30; // [rsp+20h] [rbp-28h]
  __int64 *v31; // [rsp+30h] [rbp-18h]
  __int64 v32; // [rsp+38h] [rbp-10h]

  v9 = v6;
  if ( a1 == (__int64 *)1 )
  {
    while ( 1 )
    {
      v8 -= 6;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc((__int64)a1, a2, v9, a4, a5, a6, v26);
    }
    result = v8 + 1;
    *v8 = 5120LL;
    v8[1] = 1LL;
    v8[2] = v9;
    v8[3] = v7;
    v8[4] = 1LL;
    v8[5] = 3LL;
  }
  else
  {
    v27 = a2;
    v30 = v6;
    v32 = a1[4];
    v31 = (__int64 *)a1[3];
    v28 = a1[2];
    v29 = (__int64 *)*a1;
    v10 = **(_QWORD **)(a2 + 24);
    v11 = caml_apply2(v10);
    if ( v11 == 1 )
    {
      while ( 1 )
      {
        v8 -= 6;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(v10, a2, v12, v13, v14, v15, v27);
      }
      result = v8 + 1;
      *v8 = 5120LL;
      v8[1] = v29;
      v8[2] = v30;
      v8[3] = v7;
      v8[4] = v31;
      v8[5] = v32;
    }
    else if ( v11 >= 1 )
    {
      v21 = camlMap__add_121(v31, a2, v12, v13, v14, v15);
      return camlMap__bal_94(v28, (__int64)v21, v22, v23, v24, v25);
    }
    else
    {
      camlMap__add_121(v29, a2, v12, v13, v14, v15);
      return camlMap__bal_94(v28, (__int64)v31, v17, v18, v19, v20);
    }
  }
  return result;
}
// 41C354: variable 'v6' is possibly undefined
// 41C3B0: variable 'v8' is possibly undefined
// 41C3E6: variable 'v7' is possibly undefined
// 41C41D: variable 'v12' is possibly undefined
// 41C41D: variable 'v13' is possibly undefined
// 41C41D: variable 'v14' is possibly undefined
// 41C41D: variable 'v15' is possibly undefined
// 41C435: variable 'v17' is possibly undefined
// 41C435: variable 'v18' is possibly undefined
// 41C435: variable 'v19' is possibly undefined
// 41C435: variable 'v20' is possibly undefined
// 41C46A: variable 'v22' is possibly undefined
// 41C46A: variable 'v23' is possibly undefined
// 41C46A: variable 'v24' is possibly undefined
// 41C46A: variable 'v25' is possibly undefined
// 41C493: variable 'v9' is possibly undefined
// 41C4B0: variable 'a4' is possibly undefined
// 41C4B0: variable 'a5' is possibly undefined
// 41C4B0: variable 'a6' is possibly undefined
// 41C4B0: variable 'v26' is possibly undefined
// 41C4B7: variable 'v27' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041C4D0) ----------------------------------------------------
__int64 __fastcall camlMap__find_130(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rax
  __int64 v11; // [rsp+0h] [rbp-28h]
  __int64 *v12; // [rsp+10h] [rbp-18h]
  __int64 *v13; // [rsp+18h] [rbp-10h]
  __int64 v14; // [rsp+20h] [rbp-8h]

  while ( 1 )
  {
    if ( v7 == (__int64 *)1 )
    {
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
        {
          *v8 = 1024LL;
          v8[1] = &caml_exn_Not_found;
          caml_raise_exn();
        }
        caml_call_gc(a1, a2, a3, a4, a5, a6, v11);
      }
    }
    v11 = v6;
    v12 = (__int64 *)v7[3];
    v14 = v7[2];
    a2 = *v7;
    v13 = (__int64 *)*v7;
    v9 = caml_apply2(**(_QWORD **)(a1 + 24));
    if ( v9 == 1 )
      break;
    if ( v9 >= 1 )
      v7 = v12;
    else
      v7 = v13;
    v6 = v11;
  }
  return v14;
}
// 41C4D8: variable 'v7' is possibly undefined
// 41C4DF: variable 'v6' is possibly undefined
// 41C540: variable 'v8' is possibly undefined
// 41C56B: variable 'a3' is possibly undefined
// 41C56B: variable 'a4' is possibly undefined
// 41C56B: variable 'a5' is possibly undefined
// 41C56B: variable 'a6' is possibly undefined
// 41C56B: variable 'v11' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041C580) ----------------------------------------------------
__int64 __fastcall camlMap__mem_137(__int64 a1)
{
  __int64 v1; // rax
  _QWORD *v2; // rbx
  __int64 v3; // rax
  __int64 v5; // [rsp+0h] [rbp-28h]
  _QWORD *v6; // [rsp+10h] [rbp-18h]
  _QWORD *v7; // [rsp+18h] [rbp-10h]

  while ( v2 != (_QWORD *)1 )
  {
    v5 = v1;
    v6 = (_QWORD *)v2[3];
    v7 = (_QWORD *)*v2;
    v3 = caml_apply2(**(_QWORD **)(a1 + 24));
    if ( v3 == 1 )
      return 3LL;
    if ( v3 >= 1 )
      v2 = v6;
    else
      v2 = v7;
    v1 = v5;
  }
  return 1LL;
}
// 41C588: variable 'v2' is possibly undefined
// 41C58F: variable 'v1' is possibly undefined

//----- (000000000041C600) ----------------------------------------------------
_QWORD *__fastcall camlMap__min_binding_144(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rdi
  __int64 v9; // rbx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    if ( v6 == (_QWORD *)1 )
    {
      while ( 1 )
      {
        v7 -= 2;
        if ( (unsigned __int64)v7 >= caml_young_limit )
        {
          *v7 = 1024LL;
          v7[1] = &caml_exn_Not_found;
          caml_raise_exn();
        }
        caml_call_gc(a1, a2, a3, a4, a5, a6, v11);
      }
    }
    if ( *v6 == 1LL )
      break;
    v6 = (_QWORD *)*v6;
  }
  v8 = v6[2];
  v9 = v6[1];
  while ( 1 )
  {
    v7 -= 3;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc(v8, a2, a3, a4, a5, a6, v11);
  }
  result = v7 + 1;
  *v7 = 2048LL;
  v7[1] = v9;
  v7[2] = v8;
  return result;
}
// 41C608: variable 'v6' is possibly undefined
// 41C620: variable 'v7' is possibly undefined
// 41C673: variable 'a3' is possibly undefined
// 41C673: variable 'a4' is possibly undefined
// 41C673: variable 'a5' is possibly undefined
// 41C673: variable 'a6' is possibly undefined
// 41C673: variable 'v11' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041C690) ----------------------------------------------------
_QWORD *__fastcall camlMap__remove_min_binding_152(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v12; // [rsp+8h] [rbp-10h]
  __int64 v13; // [rsp+10h] [rbp-8h]

  if ( v6 == (__int64 *)1 )
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  if ( *v6 == 1 )
    return (_QWORD *)v6[3];
  v13 = v6[3];
  v12 = v6[2];
  camlMap__remove_min_binding_152(*v6, a2, a3, a4, a5, a6);
  return camlMap__bal_94(v12, v13, v7, v8, v9, v10);
}
// 41C690: could not find valid save-restore pair for rbx
// 41C698: variable 'v6' is possibly undefined
// 41C6D7: variable 'v7' is possibly undefined
// 41C6D7: variable 'v8' is possibly undefined
// 41C6D7: variable 'v9' is possibly undefined
// 41C6D7: variable 'v10' is possibly undefined

//----- (000000000041C700) ----------------------------------------------------
_QWORD *__fastcall camlMap__merge_160(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *result; // rax
  __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  _QWORD *v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // [rsp+18h] [rbp-10h]

  if ( result == (_QWORD *)1 )
    return (_QWORD *)v7;
  if ( v7 != 1 )
  {
    v17 = camlMap__min_binding_144(a1, a2, a3, a4, a5, a6)[1];
    v12 = camlMap__remove_min_binding_152(a1, a2, v8, v9, v10, v11);
    return camlMap__bal_94(v17, (__int64)v12, v13, v14, v15, v16);
  }
  return result;
}
// 41C708: variable 'result' is possibly undefined
// 41C70E: variable 'v7' is possibly undefined
// 41C736: variable 'v8' is possibly undefined
// 41C736: variable 'v9' is possibly undefined
// 41C736: variable 'v10' is possibly undefined
// 41C736: variable 'v11' is possibly undefined
// 41C751: variable 'v13' is possibly undefined
// 41C751: variable 'v14' is possibly undefined
// 41C751: variable 'v15' is possibly undefined
// 41C751: variable 'v16' is possibly undefined

//----- (000000000041C770) ----------------------------------------------------
__int64 __fastcall camlMap__remove_167(__int64 a1)
{
  __int64 *v1; // rbx
  __int64 v2; // rsi
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v20; // [rsp+18h] [rbp-20h]
  __int64 v21; // [rsp+28h] [rbp-10h]

  if ( v1 == (__int64 *)1 )
    return 1LL;
  v21 = v1[3];
  v20 = v1[2];
  v2 = *v1;
  v3 = **(_QWORD **)(a1 + 24);
  v4 = caml_apply2(v3);
  if ( v4 == 1 )
    return (__int64)camlMap__merge_160(v3, v2, v5, v6, v7, v8);
  if ( v4 >= 1 )
  {
    v14 = camlMap__remove_167(a1);
    return (__int64)camlMap__bal_94(v20, v14, v15, v16, v17, v18);
  }
  else
  {
    camlMap__remove_167(a1);
    return (__int64)camlMap__bal_94(v20, v21, v10, v11, v12, v13);
  }
}
// 41C778: variable 'v1' is possibly undefined
// 41C7CD: variable 'v5' is possibly undefined
// 41C7CD: variable 'v6' is possibly undefined
// 41C7CD: variable 'v7' is possibly undefined
// 41C7CD: variable 'v8' is possibly undefined
// 41C800: variable 'v10' is possibly undefined
// 41C800: variable 'v11' is possibly undefined
// 41C800: variable 'v12' is possibly undefined
// 41C800: variable 'v13' is possibly undefined
// 41C831: variable 'v15' is possibly undefined
// 41C831: variable 'v16' is possibly undefined
// 41C831: variable 'v17' is possibly undefined
// 41C831: variable 'v18' is possibly undefined

//----- (000000000041C850) ----------------------------------------------------
__int64 __fastcall camlMap__iter_175()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v3; // [rsp+10h] [rbp-18h]
  __int64 v4; // [rsp+18h] [rbp-10h]

  while ( v1 != 1 )
  {
    v3 = v0;
    v4 = *(_QWORD *)(v1 + 24);
    camlMap__iter_175();
    caml_apply2(v3);
    v0 = v3;
    v1 = v4;
  }
  return 1LL;
}
// 41C858: variable 'v1' is possibly undefined
// 41C85A: variable 'v0' is possibly undefined

//----- (000000000041C8B0) ----------------------------------------------------
__int64 __fastcall camlMap__map_181()
{
  __int64 (**v0)(void); // rax
  _QWORD *v1; // rbx
  _QWORD *v2; // r15
  __int64 v3; // rsi
  __int64 (*v4)(void); // rdi
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rbx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 result; // rax
  __int64 v11; // [rsp+0h] [rbp-38h]
  __int64 (**v12)(void); // [rsp+8h] [rbp-30h]
  __int64 v13; // [rsp+18h] [rbp-20h]
  __int64 v14; // [rsp+20h] [rbp-18h]
  __int64 v15; // [rsp+28h] [rbp-10h]

  if ( v1 == (_QWORD *)1 )
    return 1LL;
  v12 = v0;
  v15 = v1[4];
  v3 = v1[3];
  v13 = v1[1];
  v14 = camlMap__map_181();
  v4 = *v12;
  v11 = (*v12)();
  v7 = camlMap__map_181();
  while ( 1 )
  {
    v2 -= 6;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
    caml_call_gc((__int64)v4, v3, v5, v6, v8, v9, v11);
  }
  result = (__int64)(v2 + 1);
  *v2 = 5120LL;
  v2[1] = v7;
  v2[2] = v13;
  v2[3] = v11;
  v2[4] = v14;
  v2[5] = v15;
  return result;
}
// 41C8B8: variable 'v1' is possibly undefined
// 41C8BE: variable 'v0' is possibly undefined
// 41C91A: variable 'v2' is possibly undefined
// 41C946: variable 'v11' is possibly undefined
// 41C970: variable 'v5' is possibly undefined
// 41C970: variable 'v6' is possibly undefined
// 41C970: variable 'v8' is possibly undefined
// 41C970: variable 'v9' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041C980) ----------------------------------------------------
__int64 __fastcall camlMap__mapi_188()
{
  __int64 v0; // rax
  _QWORD *v1; // rbx
  _QWORD *v2; // r15
  __int64 v3; // rsi
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // rbx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 result; // rax
  __int64 v10; // [rsp+0h] [rbp-38h]
  __int64 v11; // [rsp+8h] [rbp-30h]
  __int64 v12; // [rsp+18h] [rbp-20h]
  __int64 v13; // [rsp+20h] [rbp-18h]
  __int64 v14; // [rsp+28h] [rbp-10h]

  if ( v1 == (_QWORD *)1 )
    return 1LL;
  v11 = v0;
  v14 = v1[4];
  v3 = v1[3];
  v12 = v1[1];
  v13 = camlMap__mapi_188();
  v10 = caml_apply2(v11);
  v6 = camlMap__mapi_188();
  while ( 1 )
  {
    v2 -= 6;
    if ( (unsigned __int64)v2 >= caml_young_limit )
      break;
    caml_call_gc(v11, v3, v4, v5, v7, v8, v10);
  }
  result = (__int64)(v2 + 1);
  *v2 = 5120LL;
  v2[1] = v6;
  v2[2] = v12;
  v2[3] = v10;
  v2[4] = v13;
  v2[5] = v14;
  return result;
}
// 41C988: variable 'v1' is possibly undefined
// 41C98E: variable 'v0' is possibly undefined
// 41C9EF: variable 'v2' is possibly undefined
// 41CA1B: variable 'v10' is possibly undefined
// 41CA44: variable 'v4' is possibly undefined
// 41CA44: variable 'v5' is possibly undefined
// 41CA44: variable 'v7' is possibly undefined
// 41CA44: variable 'v8' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041CA50) ----------------------------------------------------
__int64 __fastcall camlMap__fold_195(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 v5; // [rsp+10h] [rbp-18h]
  __int64 v6; // [rsp+18h] [rbp-10h]

  while ( v2 != 1 )
  {
    v5 = v1;
    v6 = *(_QWORD *)(v2 + 24);
    v3 = camlMap__fold_195(a1);
    a1 = caml_apply3(v3, v5);
    v1 = v5;
    v2 = v6;
  }
  return a1;
}
// 41CA58: variable 'v2' is possibly undefined
// 41CA5A: variable 'v1' is possibly undefined

//----- (000000000041CAB0) ----------------------------------------------------
_QWORD *__fastcall camlMap__cons_enum_210(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 *v6; // rax
  _QWORD *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // r8
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 i; // rsi
  char v14; // [rsp+0h] [rbp-8h]

  while ( v6 != (__int64 *)1 )
  {
    v9 = v6[3];
    v10 = v6[2];
    v11 = v6[1];
    for ( i = *v6; ; caml_call_gc(a1, i, v11, v10, v9, a6, v14) )
    {
      v8 -= 5;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
    }
    a1 = (__int64)(v8 + 1);
    *v8 = 4096LL;
    v8[1] = v11;
    v8[2] = v10;
    v8[3] = v9;
    v8[4] = v7;
    v6 = (__int64 *)i;
    v7 = v8 + 1;
  }
  return v7;
}
// 41CAB8: variable 'v6' is possibly undefined
// 41CAC9: variable 'v8' is possibly undefined
// 41CAE5: variable 'v11' is possibly undefined
// 41CAE8: variable 'v10' is possibly undefined
// 41CAEC: variable 'v9' is possibly undefined
// 41CAF0: variable 'v7' is possibly undefined
// 41CB04: variable 'a6' is possibly undefined
// 41CB04: variable 'v14' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041CB10) ----------------------------------------------------
__int64 __fastcall camlMap__compare_217(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  char v7; // bl
  _QWORD *v8; // r15
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  char i; // [rsp+0h] [rbp-18h]

  v9 = v6;
  for ( i = v7; ; caml_call_gc(a1, a2, v9, a4, a5, a6, i) )
  {
    v8 -= 7;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 6391LL;
  v8[1] = caml_curry2;
  v8[2] = 5LL;
  v8[3] = camlMap__code_begin;
  v8[4] = *(_QWORD *)(a2 + 24);
  v8[5] = *(_QWORD *)(a2 + 32);
  v8[6] = v9;
  camlMap__cons_enum_210(a1, a2, v9, a4, a5, a6);
  camlMap__cons_enum_210(a1, a2, v10, v11, v12, v13);
  return camlMap__code_begin((__int64)(v8 + 1));
}
// 41CB10: could not find valid save-restore pair for rbx
// 41CB14: variable 'v6' is possibly undefined
// 41CB17: variable 'v7' is possibly undefined
// 41CB1B: variable 'v8' is possibly undefined
// 41CB69: variable 'v9' is possibly undefined
// 41CB77: variable 'a4' is possibly undefined
// 41CB77: variable 'a5' is possibly undefined
// 41CB77: variable 'a6' is possibly undefined
// 41CB8C: variable 'v10' is possibly undefined
// 41CB8C: variable 'v11' is possibly undefined
// 41CB8C: variable 'v12' is possibly undefined
// 41CB8C: variable 'v13' is possibly undefined
// 41CBA4: variable 'i' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041CBB0) ----------------------------------------------------
__int64 __fastcall camlMap__equal_234(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  char v7; // bl
  _QWORD *v8; // r15
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  char i; // [rsp+0h] [rbp-18h]

  v9 = v6;
  for ( i = v7; ; caml_call_gc(a1, a2, v9, a4, a5, a6, i) )
  {
    v8 -= 7;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 6391LL;
  v8[1] = caml_curry2;
  v8[2] = 5LL;
  v8[3] = camlMap__equal_aux_238;
  v8[4] = *(_QWORD *)(a2 + 24);
  v8[5] = *(_QWORD *)(a2 + 32);
  v8[6] = v9;
  camlMap__cons_enum_210(a1, a2, v9, a4, a5, a6);
  camlMap__cons_enum_210(a1, a2, v10, v11, v12, v13);
  return camlMap__equal_aux_238((__int64)(v8 + 1));
}
// 41CBB0: could not find valid save-restore pair for rbx
// 41CBB4: variable 'v6' is possibly undefined
// 41CBB7: variable 'v7' is possibly undefined
// 41CBBB: variable 'v8' is possibly undefined
// 41CC09: variable 'v9' is possibly undefined
// 41CC17: variable 'a4' is possibly undefined
// 41CC17: variable 'a5' is possibly undefined
// 41CC17: variable 'a6' is possibly undefined
// 41CC2C: variable 'v10' is possibly undefined
// 41CC2C: variable 'v11' is possibly undefined
// 41CC2C: variable 'v12' is possibly undefined
// 41CC2C: variable 'v13' is possibly undefined
// 41CC44: variable 'i' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041CC50) ----------------------------------------------------
_QWORD *__fastcall camlMap__Make_249(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rax
  _QWORD *v6; // r15
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // r8
  _QWORD *v10; // rbx
  __int64 v11; // rsi
  __int64 (__fastcall **v12)(); // r11
  __int64 (__fastcall **v13)(); // r10
  __int64 v14; // rdx
  __int64 v15; // rdi
  _QWORD *result; // rax
  __int64 (__fastcall **i)(); // [rsp+0h] [rbp-38h]
  _QWORD *v18; // [rsp+8h] [rbp-30h]
  _QWORD *v19; // [rsp+18h] [rbp-20h]
  _QWORD *v20; // [rsp+20h] [rbp-18h]
  _QWORD *v21; // [rsp+28h] [rbp-10h]

  v7 = v5;
  for ( i = &camlMap__9; ; caml_call_gc((__int64)&camlMap__9, a2, a3, a4, a5, v7, (char)i) )
  {
    v6 -= 31;
    if ( (unsigned __int64)v6 >= caml_young_limit )
      break;
  }
  v18 = v6 + 1;
  *v6 = 4343LL;
  v6[1] = caml_curry4;
  v6[2] = 9LL;
  v6[3] = camlMap__create_87;
  v6[4] = &camlMap__9;
  v8 = (__int64)(v6 + 6);
  v6[5] = 5367LL;
  v6[6] = caml_curry4;
  v6[7] = 9LL;
  v6[8] = camlMap__bal_94;
  v6[9] = &camlMap__9;
  v6[10] = v6 + 1;
  v19 = v6 + 12;
  v6[11] = 5367LL;
  v6[12] = caml_curry3;
  v6[13] = 7LL;
  v6[14] = camlMap__add_121;
  v6[15] = v7;
  v6[16] = v6 + 6;
  v20 = v6 + 18;
  v6[17] = 4343LL;
  v6[18] = caml_curry2;
  v6[19] = 5LL;
  v6[20] = camlMap__find_130;
  v6[21] = v7;
  v21 = v6 + 23;
  v6[22] = 4343LL;
  v6[23] = caml_curry2;
  v6[24] = 5LL;
  v6[25] = camlMap__mem_137;
  v6[26] = v7;
  v9 = (__int64)(v6 + 28);
  v6[27] = 3319LL;
  v6[28] = camlMap__remove_min_binding_152;
  v6[29] = 3LL;
  v6[30] = v6 + 6;
  while ( 1 )
  {
    v6 -= 26;
    if ( (unsigned __int64)v6 >= caml_young_limit )
      break;
    caml_call_gc((__int64)&camlMap__7, a2, a3, v8, v9, v7, (char)i);
  }
  v10 = v6 + 1;
  *v6 = 6391LL;
  v6[1] = caml_curry2;
  v6[2] = 5LL;
  v6[3] = camlMap__merge_160;
  v6[4] = v8;
  v6[5] = &camlMap__7;
  v6[6] = v9;
  v11 = (__int64)(v6 + 8);
  v6[7] = 6391LL;
  v6[8] = caml_curry2;
  v6[9] = 5LL;
  v6[10] = camlMap__remove_167;
  v6[11] = v7;
  v6[12] = v8;
  v6[13] = v6 + 1;
  v12 = &camlMap__3;
  v13 = &camlMap__2;
  v14 = (__int64)(v6 + 15);
  v6[14] = 5367LL;
  v6[15] = caml_curry3;
  v6[16] = 7LL;
  v6[17] = camlMap__compare_217;
  v6[18] = v7;
  v6[19] = &camlMap__2;
  v15 = (__int64)(v6 + 21);
  v6[20] = 5367LL;
  v6[21] = caml_curry3;
  v6[22] = 7LL;
  v6[23] = camlMap__equal_234;
  v6[24] = v7;
  v6[25] = &camlMap__2;
  while ( 1 )
  {
    v6 -= 20;
    if ( (unsigned __int64)v6 >= caml_young_limit )
      break;
    caml_call_gc(v15, v11, v14, v8, v9, v7, (char)i);
  }
  result = v6 + 1;
  *v6 = 19456LL;
  v6[1] = i;
  v6[2] = v18;
  v6[3] = v8;
  v6[4] = 1LL;
  v6[5] = &camlMap__8;
  v6[6] = v19;
  v6[7] = v20;
  v6[8] = v21;
  v6[9] = &camlMap__7;
  v6[10] = v9;
  v6[11] = v10;
  v6[12] = v11;
  v6[13] = &camlMap__6;
  v6[14] = &camlMap__5;
  v6[15] = &camlMap__4;
  v6[16] = v12;
  v6[17] = v13;
  v6[18] = v14;
  v6[19] = v15;
  return result;
}
// 41CC54: variable 'v5' is possibly undefined
// 41CC62: variable 'v6' is possibly undefined
// 41CD16: variable 'v7' is possibly undefined
// 41CDF9: variable 'v8' is possibly undefined
// 41CE01: variable 'v9' is possibly undefined
// 41CEE9: variable 'i' is possibly undefined
// 41CF46: variable 'v12' is possibly undefined
// 41CF4A: variable 'v13' is possibly undefined
// 41CF51: variable 'v14' is possibly undefined
// 41CF6E: variable 'a3' is possibly undefined
// 41CF78: variable 'a4' is possibly undefined
// 41CF78: variable 'a5' is possibly undefined
// 652BE8: using guessed type __int64 (__fastcall *camlMap__2)();
// 652C08: using guessed type __int64 (__fastcall *camlMap__3)();
// 652C28: using guessed type __int64 (__fastcall *camlMap__4)();
// 652C48: using guessed type __int64 (__fastcall *camlMap__5)();
// 652C68: using guessed type __int64 (__fastcall *camlMap__6)();
// 652C88: using guessed type __int64 (__fastcall *camlMap__7)();
// 652CA0: using guessed type __int64 (__fastcall *camlMap__8)();
// 652CB8: using guessed type __int64 (__fastcall *camlMap__9)();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041CF90) ----------------------------------------------------
_QWORD *__fastcall camlMap__fun_473(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  _QWORD *v5; // r15
  __int64 v6; // rdx
  __int64 v7; // rcx
  _QWORD *i; // rdi
  __int64 v9; // r8
  __int64 v10; // r9
  _QWORD *result; // rax
  char v12; // [rsp+0h] [rbp-8h]

  for ( i = camlMap__Make_249(a1, a2, a3, a4, a5); ; caml_call_gc((__int64)i, a2, v6, v7, v9, v10, v12) )
  {
    v5 -= 13;
    if ( (unsigned __int64)v5 >= caml_young_limit )
      break;
  }
  result = v5 + 1;
  *v5 = 12288LL;
  v5[1] = 1LL;
  v5[2] = i[4];
  v5[3] = i[5];
  v5[4] = i[6];
  v5[5] = i[11];
  v5[6] = i[7];
  v5[7] = i[12];
  v5[8] = i[13];
  v5[9] = i[14];
  v5[10] = i[15];
  v5[11] = i[17];
  v5[12] = i[18];
  return result;
}
// 41CF9C: variable 'v5' is possibly undefined
// 41D022: variable 'v6' is possibly undefined
// 41D022: variable 'v7' is possibly undefined
// 41D022: variable 'v9' is possibly undefined
// 41D022: variable 'v10' is possibly undefined
// 41D022: variable 'v12' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041D030) ----------------------------------------------------
__int64 __fastcall camlMap__entry(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // r15
  char v8; // [rsp+0h] [rbp-8h]

  caml_alloc3((__int64)&camlMap__1, a2, a3, a4, a5, a6, v8);
  *v6 = 3319LL;
  v6[1] = camlMap__fun_473;
  v6[2] = 3LL;
  v6[3] = &camlMap__1;
  camlMap = v6 + 1;
  return 1LL;
}
// 41D03B: variable 'v8' is possibly undefined
// 41D044: variable 'v6' is possibly undefined
// 652BD0: using guessed type __int64 (__fastcall *camlMap__1)();

//----- (000000000041D080) ----------------------------------------------------
__int64 __fastcall camlBuffer__code_begin(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // r10
  __int64 v10; // rcx
  __int64 v11; // r10
  __int64 v12; // rcx
  char v14; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    if ( v7 >= a1 )
    {
      while ( 1 )
      {
        v8 -= 2;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(a1, (__int64)a2, a3, a4, a5, a6, v14);
      }
      *v8 = 1024LL;
      v7 = (__int64)&caml_exn_Not_found;
      v8[1] = &caml_exn_Not_found;
      v6 = caml_raise_exn();
    }
    a3 = a2[3];
    v9 = a2[5];
    a6 = v7 >> 1;
    v10 = 8LL * (*(_QWORD *)(v9 - 8) >> 10) - 1;
    a5 = *(unsigned __int8 *)(v9 + v10);
    if ( v10 - a5 <= (unsigned __int64)(v7 >> 1) )
      break;
    a4 = 2LL * *(unsigned __int8 *)(v9 + a6) + 1;
    if ( a4 == a3 )
    {
      v7 += 2LL;
      v6 += 2LL;
    }
    else
    {
      a3 = a2[4];
      v11 = a2[5];
      a6 = v7 >> 1;
      v12 = 8LL * (*(_QWORD *)(v11 - 8) >> 10) - 1;
      a5 = *(unsigned __int8 *)(v11 + v12);
      if ( v12 - a5 <= (unsigned __int64)(v7 >> 1) )
      {
        caml_ml_array_bound_error(a1, (unsigned __int64)a2);
        break;
      }
      a4 = 2LL * *(unsigned __int8 *)(v11 + a6) + 1;
      if ( a4 == a3 )
      {
        if ( v6 == 1 )
          return v7;
        v7 += 2LL;
        v6 -= 2LL;
      }
      else
      {
        v7 += 2LL;
      }
    }
  }
  caml_ml_array_bound_error(a1, (unsigned __int64)a2);
  return camlBuffer__advance_139(a1);
}
// 41D087: variable 'v7' is possibly undefined
// 41D089: variable 'v8' is possibly undefined
// 41D0FA: variable 'v6' is possibly undefined
// 41D161: variable 'a3' is possibly undefined
// 41D161: variable 'a4' is possibly undefined
// 41D161: variable 'a5' is possibly undefined
// 41D161: variable 'a6' is possibly undefined
// 41D161: variable 'v14' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041D180) ----------------------------------------------------
__int64 __fastcall camlBuffer__advance_139(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rsi
  __int64 v5; // r8
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9

  while ( 1 )
  {
    v3 = v1;
    if ( v1 >= v2 )
      return v2;
    v5 = *(_QWORD *)(a1 + 24);
    v6 = v1 >> 1;
    v7 = 8LL * (*(_QWORD *)(v5 - 8) >> 10) - 1;
    if ( v7 - (unsigned __int64)*(unsigned __int8 *)(v5 + v7) <= v3 >> 1 )
      break;
    v8 = 2LL * *(unsigned __int8 *)(v5 + v6) + 1;
    if ( v8 >= 191 )
    {
      if ( v8 >= 247 )
      {
        if ( v8 >= 385 )
        {
          switch ( (2LL * *(unsigned __int8 *)(v5 + v6) - 383) >> 1 )
          {
            case 0LL:
            case 1LL:
            case 2LL:
            case 7LL:
            case 8LL:
            case 9LL:
            case 10LL:
            case 11LL:
            case 14LL:
            case 15LL:
            case 20LL:
            case 25LL:
            case 27LL:
            case 28LL:
            case 32LL:
            case 33LL:
            case 34LL:
            case 39LL:
            case 40LL:
            case 41LL:
            case 42LL:
            case 43LL:
            case 46LL:
            case 47LL:
            case 52LL:
            case 57LL:
            case 59LL:
            case 60LL:
              goto LABEL_15;
            case 3LL:
            case 4LL:
            case 5LL:
            case 6LL:
            case 12LL:
            case 13LL:
            case 16LL:
            case 17LL:
            case 18LL:
            case 19LL:
            case 21LL:
            case 22LL:
            case 23LL:
            case 24LL:
            case 26LL:
            case 29LL:
            case 30LL:
            case 31LL:
            case 35LL:
            case 36LL:
            case 37LL:
            case 38LL:
            case 44LL:
            case 45LL:
            case 48LL:
            case 49LL:
            case 50LL:
            case 51LL:
            case 53LL:
            case 54LL:
            case 55LL:
            case 56LL:
            case 58LL:
            case 61LL:
            case 62LL:
            case 63LL:
              return v3;
          }
        }
        return v3;
      }
      if ( 2LL * *(unsigned __int8 *)(v5 + v6) == 192 )
        return v3;
    }
    else if ( v8 < 117 )
    {
      if ( v8 < 97 )
        return v3;
    }
    else if ( 2 * (unsigned __int64)*(unsigned __int8 *)(v5 + v6) - 129 > 0x33 )
    {
      return v3;
    }
LABEL_15:
    v1 = v3 + 2;
  }
  caml_ml_array_bound_error(a1, v3);
  return camlBuffer__subst_155(a1, v3, v9, v10, v11, v12);
}
// 41D180: variable 'v1' is possibly undefined
// 41D186: variable 'v2' is possibly undefined
// 41D22E: variable 'v9' is possibly undefined
// 41D22E: variable 'v10' is possibly undefined
// 41D22E: variable 'v11' is possibly undefined
// 41D22E: variable 'v12' is possibly undefined

//----- (000000000041D230) ----------------------------------------------------
__int64 __fastcall camlBuffer__subst_155(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  unsigned __int64 v8; // rsi
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 *ident_142; // rax
  __int64 v16; // rsi
  void (*v17)(void); // rdi
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v23; // [rsp+0h] [rbp-18h]
  __int64 v24; // [rsp+0h] [rbp-18h]
  __int64 v25; // [rsp+10h] [rbp-8h]

  while ( 1 )
  {
    v8 = v6;
    if ( v7 >= *(_QWORD *)(a1 + 48) )
      break;
    a5 = *(_QWORD *)(a1 + 40);
    a4 = v7 >> 1;
    v9 = 8LL * (*(_QWORD *)(a5 - 8) >> 10) - 1;
    if ( v9 - (unsigned __int64)*(unsigned __int8 *)(a5 + v9) <= v7 >> 1 )
    {
      caml_ml_array_bound_error(a1, v8);
      return (__int64)camlBuffer__create_67(a1, v8);
    }
    v10 = *(unsigned __int8 *)(a5 + a4);
    a3 = 2 * v10 + 1;
    if ( 2 * v10 == 72 )
    {
      v25 = a1;
      if ( v8 == 185 )
      {
        camlBuffer__add_char_100(a1, 185LL, a3, a4, a5, a6);
        v7 += 2LL;
        v6 = 65LL;
      }
      else
      {
        ident_142 = camlBuffer__find_ident_142(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 48), a3, a4, a5, a6);
        v24 = ident_142[1];
        v16 = *ident_142;
        v17 = **(void (***)(void))(a1 + 32);
        v17();
        camlBuffer__add_string_110((__int64)v17, v16, v18, v19, v20, v21);
        v6 = 65LL;
        v7 = v24;
      }
      a1 = v25;
    }
    else if ( v8 == 185 )
    {
      camlBuffer__add_char_100(a1, 185LL, a3, a4, a5, a6);
      camlBuffer__add_char_100(a1, 185LL, v11, v12, v13, v14);
      v7 += 2LL;
      v6 = 65LL;
    }
    else if ( 2 * v10 == 184 )
    {
      v6 = 185LL;
      v7 += 2LL;
    }
    else
    {
      v23 = 2 * v10 + 1;
      camlBuffer__add_char_100(a1, v8, a3, a4, a5, a6);
      v7 += 2LL;
      v6 = v23;
    }
  }
  if ( v6 == 185 )
    return camlBuffer__add_char_100(a1, 185LL, a3, a4, a5, a6);
  else
    return 1LL;
}
// 41D234: variable 'v6' is possibly undefined
// 41D23E: variable 'v7' is possibly undefined
// 41D2A5: variable 'a6' is possibly undefined
// 41D2B7: variable 'v11' is possibly undefined
// 41D2B7: variable 'v12' is possibly undefined
// 41D2B7: variable 'v13' is possibly undefined
// 41D2B7: variable 'v14' is possibly undefined
// 41D39F: variable 'v18' is possibly undefined
// 41D39F: variable 'v19' is possibly undefined
// 41D39F: variable 'v20' is possibly undefined
// 41D39F: variable 'v21' is possibly undefined
// 41D3D0: variable 'a3' is possibly undefined
// 41D3D0: variable 'a4' is possibly undefined
// 41D3D0: variable 'a5' is possibly undefined

//----- (000000000041D3F0) ----------------------------------------------------
_QWORD *__fastcall camlBuffer__create_67(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  _QWORD *v3; // r15
  __int64 v4; // rdi
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  __int64 v9; // rax
  __int64 i; // rdi
  _QWORD *result; // rax
  __int64 v12; // [rsp+0h] [rbp-8h]

  if ( v2 < 3 )
    v2 = 3LL;
  if ( v2 <= camlSys[5] )
  {
    v4 = v2;
    v12 = v2;
  }
  else
  {
    v4 = camlSys[5];
    v12 = v4;
  }
  caml_c_call(v4, a2);
  for ( i = v9; ; caml_call_gc(i, a2, v5, v6, v7, v8, v12) )
  {
    v3 -= 5;
    if ( (unsigned __int64)v3 >= caml_young_limit )
      break;
  }
  result = v3 + 1;
  *v3 = 4096LL;
  v3[1] = i;
  v3[2] = 1LL;
  v3[3] = v12;
  v3[4] = i;
  return result;
}
// 41D3F0: could not find valid save-restore pair for rbx
// 41D3F8: variable 'v2' is possibly undefined
// 41D437: variable 'v9' is possibly undefined
// 41D43A: variable 'v3' is possibly undefined
// 41D465: variable 'v12' is possibly undefined
// 41D472: variable 'v5' is possibly undefined
// 41D472: variable 'v6' is possibly undefined
// 41D472: variable 'v7' is possibly undefined
// 41D472: variable 'v8' is possibly undefined
// 6515D0: using guessed type __int64 camlSys[33];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041D480) ----------------------------------------------------
__int64 __fastcall camlBuffer__contents_72(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax

  return camlString__sub_74(*(_QWORD *)(v6 + 8), a2, a3, a4, a5, a6);
}
// 41D480: variable 'v6' is possibly undefined

//----- (000000000041D4A0) ----------------------------------------------------
__int64 __fastcall camlBuffer__sub_74(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v10; // [rsp+18h] [rbp-10h]

  if ( v7 < 1 || a1 < 1 || (a2 = *(_QWORD *)(v6 + 8) - a1 + 1, v7 > a2) )
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  caml_c_call(a1, a2);
  v10 = v8;
  camlString__blit_84(v8, 1LL, a1);
  return v10;
}
// 41D4A8: variable 'v7' is possibly undefined
// 41D4B0: variable 'v6' is possibly undefined
// 41D4DC: variable 'v8' is possibly undefined

//----- (000000000041D520) ----------------------------------------------------
__int64 __fastcall camlBuffer__blit_79(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rcx

  if ( a3 < 1
    || v7 < 1
    || (a4 = *(_QWORD *)(v6 + 8) - a3 + 1, v7 > a4)
    || a2 < 1
    || (v8 = 8LL * (*(_QWORD *)(a1 - 8) >> 10) - 1,
        a5 = *(unsigned __int8 *)(a1 + v8),
        a4 = 2 * (v8 - a5) - a3 + 2,
        a2 > a4) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  }
  return camlString__blit_84(a1, a2, a3);
}
// 41D52A: variable 'v7' is possibly undefined
// 41D52C: variable 'v6' is possibly undefined

//----- (000000000041D580) ----------------------------------------------------
__int64 __fastcall camlBuffer__nth_85(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 *v6; // rax
  __int64 v7; // rbx
  unsigned __int64 v8; // rsi
  unsigned __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rdi

  if ( v7 < 1 || (a1 = v6[1], v7 >= a1) )
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  v8 = *v6;
  v9 = v7 >> 1;
  v10 = 8LL * (*(_QWORD *)(*v6 - 8) >> 10) - 1;
  v11 = *(unsigned __int8 *)(v8 + v10);
  if ( v10 - v11 > v9 )
    return 2LL * *(unsigned __int8 *)(v8 + v9) + 1;
  caml_ml_array_bound_error(v11, v8);
  return camlBuffer__length_88();
}
// 41D584: variable 'v7' is possibly undefined
// 41D586: variable 'v6' is possibly undefined

//----- (000000000041D5E0) ----------------------------------------------------
__int64 __fastcall camlBuffer__length_88()
{
  __int64 v0; // rax

  return *(_QWORD *)(v0 + 8);
}
// 41D5E0: variable 'v0' is possibly undefined

//----- (000000000041D5F0) ----------------------------------------------------
__int64 __fastcall camlBuffer__clear_90()
{
  __int64 v0; // rax

  *(_QWORD *)(v0 + 8) = 1LL;
  return 1LL;
}
// 41D5F0: variable 'v0' is possibly undefined
// 41D5F0: using guessed type __int64 __fastcall camlBuffer__clear_90();

//----- (000000000041D600) ----------------------------------------------------
__int64 __fastcall camlBuffer__reset_92()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rbx
  __int64 v2; // rax

  v1 = v0;
  v0[1] = 1LL;
  caml_modify(v0, v0[3]);
  v2 = 8LL * (*(_QWORD *)(*v1 - 8) >> 10) - 1;
  v1[2] = 2 * (v2 - *(unsigned __int8 *)(*v1 + v2)) + 1;
  return 1LL;
}
// 41D604: variable 'v0' is possibly undefined
// 41D600: using guessed type __int64 __fastcall camlBuffer__reset_92();

//----- (000000000041D650) ----------------------------------------------------
__int64 __fastcall camlBuffer__resize_94(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 *v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdi
  __int64 i; // rsi
  __int64 *v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rsi
  __int64 v14; // rdi
  __int64 v15; // rax
  unsigned __int64 *v17; // [rsp+0h] [rbp-18h]
  unsigned __int64 v18; // [rsp+8h] [rbp-10h]
  __int64 *v19; // [rsp+10h] [rbp-8h]

  v9 = (__int64)v6;
  v17 = v6;
  for ( i = v6[2]; ; caml_call_gc(v9, i, a3, a4, a5, a6, (char)v17) )
  {
    v8 -= 2;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  v11 = v8 + 1;
  v19 = v8 + 1;
  *v8 = 1024LL;
  v8[1] = i;
  while ( *(_QWORD *)(v9 + 8) + v7 - 1 > *v11 )
    *v11 = 4 * (*v11 >> 1) + 1;
  v12 = camlSys[5];
  v13 = *v11;
  if ( *v11 > v12 )
  {
    v13 = camlSys[5];
    v14 = *(_QWORD *)(v9 + 8);
    if ( v14 + v7 - 1 > v13 )
      camlPervasives__failwith_38(v14, v13, v12, a4, a5, a6);
    *v11 = camlSys[5];
  }
  caml_c_call(*v19, v13);
  v18 = v15;
  camlString__blit_84(v15, 1LL, v17[1]);
  caml_modify(v17, v18);
  v17[2] = *v19;
  return 1LL;
}
// 41D654: variable 'v6' is possibly undefined
// 41D65F: variable 'v8' is possibly undefined
// 41D68E: variable 'v7' is possibly undefined
// 41D6EF: variable 'a4' is possibly undefined
// 41D6EF: variable 'a5' is possibly undefined
// 41D6EF: variable 'a6' is possibly undefined
// 41D70B: variable 'v15' is possibly undefined
// 41D714: variable 'v17' is possibly undefined
// 41D757: variable 'a3' is possibly undefined
// 6515D0: using guessed type __int64 camlSys[33];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041D770) ----------------------------------------------------
__int64 __fastcall camlBuffer__add_char_100(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdi
  __int64 v9; // rax
  unsigned __int64 v10; // rsi
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  _QWORD *v16; // [rsp+0h] [rbp-18h]

  v16 = v6;
  v8 = v6[1];
  if ( v8 >= v6[2] )
    camlBuffer__resize_94(v8, a2, a3, a4, a5, a6);
  v9 = 8LL * (*(_QWORD *)(*v16 - 8LL) >> 10) - 1;
  v10 = *(unsigned __int8 *)(*v16 + v9);
  if ( v9 - v10 <= v8 >> 1 )
  {
    caml_ml_array_bound_error((__int64)v16, v10);
    return camlBuffer__add_substring_104((__int64)v16, v10, v12, v13, v14, v15);
  }
  else
  {
    *(_BYTE *)(*v16 + (v8 >> 1)) = v7 >> 1;
    v16[1] = v8 + 2;
    return 1LL;
  }
}
// 41D774: variable 'v6' is possibly undefined
// 41D7CF: variable 'v7' is possibly undefined
// 41D7EF: variable 'v12' is possibly undefined
// 41D7EF: variable 'v13' is possibly undefined
// 41D7EF: variable 'v14' is possibly undefined
// 41D7EF: variable 'v15' is possibly undefined

//----- (000000000041D7F0) ----------------------------------------------------
__int64 __fastcall camlBuffer__add_substring_104(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 *v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rsi
  __int64 v10; // rdi
  __int64 *v13; // [rsp+20h] [rbp-8h]

  v13 = v6;
  if ( a1 < 1
    || a2 < 1
    || (v8 = 8LL * (*(_QWORD *)(v7 - 8) >> 10) - 1, a1 > 2 * (v8 - *(unsigned __int8 *)(v7 + v8)) - a2 + 2) )
  {
    camlPervasives__invalid_arg_40(a1, a2, a3, a4, a5, a6);
  }
  v9 = v13[1] + a2 - 1;
  v10 = v13[2];
  if ( v9 > v10 )
    camlBuffer__resize_94(v10, v9, a3, a4, a5, a6);
  camlString__blit_84(*v13, v13[1], a2);
  v13[1] = v9;
  return 1LL;
}
// 41D7F0: could not find valid save-restore pair for rbx
// 41D7F4: variable 'v6' is possibly undefined
// 41D813: variable 'v7' is possibly undefined

//----- (000000000041D8B0) ----------------------------------------------------
__int64 __fastcall camlBuffer__add_string_110(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 *v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rsi
  __int64 v10; // rdi
  __int64 v12; // [rsp+0h] [rbp-28h]
  __int64 v13; // [rsp+8h] [rbp-20h]
  __int64 *v14; // [rsp+18h] [rbp-10h]

  v14 = v6;
  v12 = v7;
  v8 = 8LL * (*(_QWORD *)(v7 - 8) >> 10) - 1;
  v13 = 2 * (v8 - *(unsigned __int8 *)(v12 + v8)) + 1;
  v9 = v6[1] + 2 * (v8 - *(unsigned __int8 *)(v12 + v8));
  v10 = v6[2];
  if ( v9 > v10 )
    camlBuffer__resize_94(v10, v9, a3, a4, a5, a6);
  camlString__blit_84(*v14, v14[1], v13);
  v14[1] = v9;
  return 1LL;
}
// 41D8B0: could not find valid save-restore pair for rbx
// 41D8B4: variable 'v6' is possibly undefined
// 41D8BC: variable 'v7' is possibly undefined

//----- (000000000041D940) ----------------------------------------------------
__int64 __fastcall camlBuffer__add_buffer_115(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx

  return camlBuffer__add_substring_104(1LL, *(_QWORD *)(v6 + 8), a3, a4, a5, a6);
}
// 41D940: variable 'v6' is possibly undefined

//----- (000000000041D960) ----------------------------------------------------
__int64 __fastcall camlBuffer__add_channel_118(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rsi
  __int64 v10; // [rsp+8h] [rbp-10h]

  v10 = v6;
  v7 = *(_QWORD *)(v6 + 16);
  v8 = *(_QWORD *)(v6 + 8) + a1 - 1;
  if ( v8 > v7 )
    camlBuffer__resize_94(a1, v8, v7, a4, a5, a6);
  camlPervasives__really_input_259(*(_QWORD *)(v10 + 8), a1, v7, a4, a5, a6);
  *(_QWORD *)(v10 + 8) = *(_QWORD *)(v10 + 8) + a1 - 1;
  return 1LL;
}
// 41D960: could not find valid save-restore pair for rbx
// 41D964: variable 'v6' is possibly undefined
// 41D9A1: variable 'v7' is possibly undefined
// 41D9A1: variable 'a4' is possibly undefined
// 41D9A1: variable 'a5' is possibly undefined
// 41D9A1: variable 'a6' is possibly undefined

//----- (000000000041D9D0) ----------------------------------------------------
void __fastcall camlBuffer__output_buffer_122(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx

  camlPervasives__output_218(1LL, *(_QWORD *)(v6 + 8), a3, a4, a5, a6);
}
// 41D9D0: variable 'v6' is possibly undefined

//----- (000000000041D9F0) ----------------------------------------------------
__int64 __fastcall camlBuffer__closing_125(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  char v9; // [rsp+0h] [rbp-8h]

  if ( v6 == 81 )
    return 83LL;
  if ( v6 != 247 )
  {
    while ( 1 )
    {
      v7 -= 3;
      if ( (unsigned __int64)v7 >= caml_young_limit )
        break;
      caml_call_gc(a1, a2, a3, a4, a5, a6, v9);
    }
    *v7 = 2048LL;
    v7[1] = &caml_exn_Assert_failure;
    v7[2] = &camlBuffer__21;
    caml_raise_exn();
  }
  return 251LL;
}
// 41D9F8: variable 'v6' is possibly undefined
// 41DA02: variable 'v7' is possibly undefined
// 41DA50: variable 'a3' is possibly undefined
// 41DA50: variable 'a4' is possibly undefined
// 41DA50: variable 'a5' is possibly undefined
// 41DA50: variable 'a6' is possibly undefined
// 41DA50: variable 'v9' is possibly undefined
// 647C48: using guessed type char *caml_exn_Assert_failure;
// 6536C0: using guessed type char *camlBuffer__21;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041DA60) ----------------------------------------------------
__int64 __fastcall camlBuffer__advance_to_closing_126(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // r8
  __int64 i; // rcx
  __int64 v11; // rax
  __int64 v12; // rdi
  char v14; // [rsp+0h] [rbp-8h]

  v9 = v6;
  for ( i = a2; ; caml_call_gc(a1, a2, a3, i, v9, a6, v14) )
  {
    v8 -= 7;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 6391LL;
  v8[1] = caml_curry3;
  v8[2] = 7LL;
  v8[3] = camlBuffer__code_begin;
  v8[4] = v9;
  v8[5] = v7;
  v8[6] = i;
  v11 = 8LL * (*(_QWORD *)(i - 8) >> 10) - 1;
  v12 = 2 * (v11 - *(unsigned __int8 *)(i + v11)) + 1;
  return camlBuffer__code_begin(v12, v8 + 1, a3, v12, v9, a6);
}
// 41DA64: variable 'v6' is possibly undefined
// 41DA6A: variable 'v8' is possibly undefined
// 41DAA3: variable 'v9' is possibly undefined
// 41DAA7: variable 'v7' is possibly undefined
// 41DAAB: variable 'i' is possibly undefined
// 41DAD9: variable 'a3' is possibly undefined
// 41DAD9: variable 'a6' is possibly undefined
// 41DADE: variable 'v14' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041DAF0) ----------------------------------------------------
__int64 __fastcall camlBuffer__advance_to_non_alpha_136(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rsi
  __int64 i; // rdx
  char v12; // [rsp+0h] [rbp-8h]

  v9 = v6;
  for ( i = v7; ; caml_call_gc(a1, v9, i, a4, a5, a6, v12) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 4343LL;
  v8[1] = caml_curry2;
  v8[2] = 5LL;
  v8[3] = camlBuffer__advance_139;
  v8[4] = v9;
  return camlBuffer__advance_139((__int64)(v8 + 1));
}
// 41DAF4: variable 'v6' is possibly undefined
// 41DAF7: variable 'v7' is possibly undefined
// 41DAFA: variable 'v8' is possibly undefined
// 41DB60: variable 'i' is possibly undefined
// 41DB60: variable 'a4' is possibly undefined
// 41DB60: variable 'a5' is possibly undefined
// 41DB60: variable 'a6' is possibly undefined
// 41DB60: variable 'v12' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041DB70) ----------------------------------------------------
_QWORD *__fastcall camlBuffer__find_ident_142(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdx
  __int64 v10; // rdi
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  __int64 v13; // rdi
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 i; // rdi
  __int64 v21; // r8
  __int64 v22; // r9
  _QWORD *result; // rax
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // rdi
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // r9
  __int64 v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // rbx
  __int64 v35; // r8
  __int64 v36; // r9
  __int64 v37; // rdx
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  char v41; // [rsp+0h] [rbp-28h]
  __int64 v42; // [rsp+0h] [rbp-28h]
  __int64 v43; // [rsp+0h] [rbp-28h]
  __int64 v44; // [rsp+18h] [rbp-10h]

  if ( v7 >= a1 )
  {
    while ( 1 )
    {
      v8 -= 2;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(a1, a2, a3, a4, a5, a6, v41);
    }
    *v8 = 1024LL;
    v7 = (__int64)&caml_exn_Not_found;
    v8[1] = &caml_exn_Not_found;
    v6 = caml_raise_exn();
  }
  v44 = v6;
  v9 = v7 >> 1;
  v10 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1;
  v11 = *(unsigned __int8 *)(v6 + v10);
  v12 = v10 - v11;
  if ( v12 <= v7 >> 1 )
  {
    caml_ml_array_bound_error(v12, v11);
    return (_QWORD *)camlBuffer__add_substitute_150(v12, v11, v37, v38, v39, v40);
  }
  else
  {
    v13 = 2LL * *(unsigned __int8 *)(v6 + v9) + 1;
    if ( 2LL * *(unsigned __int8 *)(v6 + v9) == 80 || 2LL * *(unsigned __int8 *)(v6 + v9) == 246 )
    {
      camlBuffer__closing_125(v13, v11, v9, a4, a5, a6);
      v43 = camlBuffer__advance_to_closing_126(1LL, v44, v7 + 2, v24, v25, v26);
      v27 = v43 - v7 - 3 + 2;
      v34 = camlString__sub_74(v27, v44, v28, v29, v30, v31);
      while ( 1 )
      {
        v8 -= 3;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(v27, v44, v32, v33, v35, v36, v43);
      }
      result = v8 + 1;
      *v8 = 2048LL;
      v8[1] = v34;
      v8[2] = v43 + 2;
    }
    else
    {
      v42 = camlBuffer__advance_to_non_alpha_136(v13, v11, v9, a4, a5, a6);
      for ( i = camlString__sub_74(v42 - v7 + 1, v11, v14, v15, v16, v17); ; caml_call_gc(
                                                                               i,
                                                                               v11,
                                                                               v18,
                                                                               v19,
                                                                               v21,
                                                                               v22,
                                                                               v42) )
      {
        v8 -= 3;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
      }
      *v8 = 2048LL;
      v8[1] = i;
      v8[2] = v42;
      return v8 + 1;
    }
  }
  return result;
}
// 41DB77: variable 'v7' is possibly undefined
// 41DB79: variable 'v8' is possibly undefined
// 41DBAD: variable 'v6' is possibly undefined
// 41DBF6: variable 'a4' is possibly undefined
// 41DBF6: variable 'a5' is possibly undefined
// 41DBF6: variable 'a6' is possibly undefined
// 41DC12: variable 'v14' is possibly undefined
// 41DC12: variable 'v15' is possibly undefined
// 41DC12: variable 'v16' is possibly undefined
// 41DC12: variable 'v17' is possibly undefined
// 41DC41: variable 'v42' is possibly undefined
// 41DC85: variable 'v24' is possibly undefined
// 41DC85: variable 'v25' is possibly undefined
// 41DC85: variable 'v26' is possibly undefined
// 41DCAB: variable 'v28' is possibly undefined
// 41DCAB: variable 'v29' is possibly undefined
// 41DCAB: variable 'v30' is possibly undefined
// 41DCAB: variable 'v31' is possibly undefined
// 41DCD6: variable 'v43' is possibly undefined
// 41DCE3: variable 'v32' is possibly undefined
// 41DCE3: variable 'v33' is possibly undefined
// 41DCE3: variable 'v35' is possibly undefined
// 41DCE3: variable 'v36' is possibly undefined
// 41DCEA: variable 'v18' is possibly undefined
// 41DCEA: variable 'v19' is possibly undefined
// 41DCEA: variable 'v21' is possibly undefined
// 41DCEA: variable 'v22' is possibly undefined
// 41DCF4: variable 'a3' is possibly undefined
// 41DCF4: variable 'v41' is possibly undefined
// 41DD04: variable 'v37' is possibly undefined
// 41DD04: variable 'v38' is possibly undefined
// 41DD04: variable 'v39' is possibly undefined
// 41DD04: variable 'v40' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041DD10) ----------------------------------------------------
__int64 __fastcall camlBuffer__add_substitute_150(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rsi
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 i; // rdx
  char v14; // [rsp+0h] [rbp-8h]

  v9 = v6;
  v10 = a1;
  v11 = 8LL * (*(_QWORD *)(a1 - 8) >> 10) - 1;
  for ( i = 2 * (v11 - *(unsigned __int8 *)(a1 + v11)) + 1; ; caml_call_gc(a1, v9, i, v10, a5, a6, v14) )
  {
    v8 -= 8;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 7415LL;
  v8[1] = caml_curry2;
  v8[2] = 5LL;
  v8[3] = camlBuffer__subst_155;
  v8[4] = v9;
  v8[5] = v7;
  v8[6] = v10;
  v8[7] = i;
  return camlBuffer__subst_155((__int64)(v8 + 1), v9, i, v10, a5, a6);
}
// 41DD14: variable 'v6' is possibly undefined
// 41DD37: variable 'v8' is possibly undefined
// 41DD74: variable 'v7' is possibly undefined
// 41DD78: variable 'v10' is possibly undefined
// 41DD7C: variable 'i' is possibly undefined
// 41DD92: variable 'a5' is possibly undefined
// 41DD92: variable 'a6' is possibly undefined
// 41DD97: variable 'v14' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041DDA0) ----------------------------------------------------
__int64 camlBuffer__entry()
{
  camlBuffer[0] = &camlBuffer__20;
  camlBuffer[1] = &camlBuffer__19;
  camlBuffer[2] = &camlBuffer__18;
  camlBuffer[3] = &camlBuffer__17;
  camlBuffer[4] = &camlBuffer__16;
  camlBuffer[5] = &camlBuffer__15;
  camlBuffer[6] = &camlBuffer__14;
  camlBuffer[7] = &camlBuffer__13;
  camlBuffer[15] = &camlBuffer__12;
  camlBuffer[8] = &camlBuffer__11;
  camlBuffer[10] = &camlBuffer__10;
  camlBuffer[9] = &camlBuffer__9;
  camlBuffer[12] = &camlBuffer__8;
  camlBuffer[13] = &camlBuffer__7;
  camlBuffer[14] = &camlBuffer__6;
  camlBuffer[16] = &camlBuffer__5;
  camlBuffer[17] = &camlBuffer__4;
  camlBuffer[18] = &camlBuffer__3;
  camlBuffer[19] = &camlBuffer__2;
  camlBuffer[11] = &camlBuffer__1;
  return 1LL;
}
// 6533C8: using guessed type _QWORD camlBuffer[21];
// 653470: using guessed type __int64 (__fastcall *camlBuffer__1)();
// 653490: using guessed type __int64 (__fastcall *camlBuffer__2)();
// 6534B0: using guessed type __int64 (__fastcall *camlBuffer__3)();
// 6534D0: using guessed type __int64 (__fastcall *camlBuffer__4)();
// 6534F0: using guessed type __int64 (__fastcall *camlBuffer__5)();
// 653508: using guessed type __int64 (__fastcall *camlBuffer__6)();
// 653528: using guessed type __int64 (__fastcall *camlBuffer__7)();
// 653548: using guessed type __int64 (__fastcall *camlBuffer__8)();
// 653568: using guessed type __int64 (__fastcall *camlBuffer__9)();
// 653588: using guessed type __int64 (__fastcall *camlBuffer__10)();
// 6535A8: using guessed type __int64 (__fastcall *camlBuffer__11)();
// 6535C8: using guessed type __int64 (__fastcall *camlBuffer__12)();
// 6535E8: using guessed type __int64 (__fastcall *camlBuffer__13)();
// 653600: using guessed type __int64 (__fastcall *camlBuffer__14)();
// 653618: using guessed type __int64 (__fastcall *camlBuffer__15)();
// 653630: using guessed type __int64 (__fastcall *camlBuffer__16)();
// 653650: using guessed type __int64 (__fastcall *camlBuffer__17)();
// 653670: using guessed type __int64 (__fastcall *camlBuffer__18)();
// 653690: using guessed type __int64 (__fastcall *camlBuffer__19)();
// 6536A8: using guessed type __int64 (__fastcall *camlBuffer__20)();

//----- (000000000041DF20) ----------------------------------------------------
__int64 __fastcall camlPrintf__code_begin()
{
  __int64 v0; // rbx

  return camlPrintf__doprn_392(*(_QWORD *)(v0 + 16));
}
// 41DF23: variable 'v0' is possibly undefined
// 41DF20: using guessed type __int64 __fastcall camlPrintf__code_begin();

//----- (000000000041DF40) ----------------------------------------------------
__int64 __fastcall camlPrintf__skip_int_literal_120()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v2; // rdi

  while ( 1 )
  {
    v2 = 2LL * *(unsigned __int8 *)(*(_QWORD *)(v1 + 16) + (v0 >> 1)) + 1;
    if ( v2 < 97 )
      break;
    if ( v2 >= 117 )
      return *(_QWORD *)(v1 + 24);
    v0 += 2LL;
  }
  if ( 2LL * *(unsigned __int8 *)(*(_QWORD *)(v1 + 16) + (v0 >> 1)) == 72 )
    return v0 + 2;
  return *(_QWORD *)(v1 + 24);
}
// 41DF46: variable 'v1' is possibly undefined
// 41DF43: variable 'v0' is possibly undefined

//----- (000000000041DF80) ----------------------------------------------------
__int64 __fastcall camlPrintf__sub_sub_157(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rsi
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rax
  __int64 v13; // rdi
  __int64 v14; // rcx
  __int64 v15; // rax
  _QWORD *v16; // rdi
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9

  v8 = v6;
  if ( v6 >= *(_QWORD *)(v7 + 40) )
    return (**(__int64 (***)(void))(v7 + 16))();
  v10 = *(_QWORD *)(v7 + 32);
  v11 = v6 >> 1;
  v12 = 8LL * (*(_QWORD *)(v10 - 8) >> 10) - 1;
  v13 = *(unsigned __int8 *)(v10 + v12);
  if ( v12 - v13 <= (unsigned __int64)(v8 >> 1) )
  {
    caml_ml_array_bound_error(v13, v8);
    return camlPrintf__sub_156(v13, v8, v21, v22, v23, v24);
  }
  else
  {
    v14 = 2LL * *(unsigned __int8 *)(v10 + v11) + 1;
    v15 = v14 - 80;
    if ( (unsigned __int64)(v14 - 80) <= 3 )
      goto LABEL_9;
    if ( (unsigned __int64)(v14 - 246) > 5 )
      return camlPrintf__sub_156(v13, v8, v11, v14, a5, a6);
    v15 = (v14 - 246) >> 1;
    if ( !v15 )
    {
LABEL_12:
      v16 = *(_QWORD **)(v7 + 48);
      camlPrintf__sub_fmt_152(v16, v8, v11, v14, a5, a6);
      return camlPrintf__sub_156((__int64)v16, v8, v17, v18, v19, v20);
    }
    if ( v15 == 1 )
      return camlPrintf__sub_156(v13, v8, v11, v14, a5, a6);
    if ( v15 <= 1 )
    {
LABEL_9:
      if ( v15 == 1 )
        goto LABEL_12;
    }
    if ( v14 == *(_QWORD *)(v7 + 64) )
      return v8 + 2;
    else
      return caml_apply3(v14, *(_QWORD *)(v7 + 24));
  }
}
// 41DF84: variable 'v6' is possibly undefined
// 41DF87: variable 'v7' is possibly undefined
// 41E047: variable 'v17' is possibly undefined
// 41E047: variable 'v18' is possibly undefined
// 41E047: variable 'v19' is possibly undefined
// 41E047: variable 'v20' is possibly undefined
// 41E082: variable 'v21' is possibly undefined
// 41E082: variable 'v22' is possibly undefined
// 41E082: variable 'v23' is possibly undefined
// 41E082: variable 'v24' is possibly undefined

//----- (000000000041E090) ----------------------------------------------------
__int64 __fastcall camlPrintf__sub_156(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rdi
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rdi

  while ( 1 )
  {
    if ( v6 >= *(_QWORD *)(v7 + 64) )
      return (**(__int64 (***)(void))(v7 + 40))();
    v9 = *(_QWORD *)(v7 + 56);
    v10 = v6 >> 1;
    v11 = 8LL * (*(_QWORD *)(v9 - 8) >> 10) - 1;
    v12 = *(unsigned __int8 *)(v9 + v11);
    v13 = v11 - v12;
    if ( v13 <= v6 >> 1 )
      break;
    if ( 2LL * *(unsigned __int8 *)(v9 + v10) == 74 )
      return camlPrintf__sub_sub_157(2LL * *(unsigned __int8 *)(v9 + v10) + 1, v12, v10, v9, a5, a6);
    v6 += 2LL;
  }
  caml_ml_array_bound_error(v13, v12);
  return camlPrintf__loop_187();
}
// 41E097: variable 'v6' is possibly undefined
// 41E090: variable 'v7' is possibly undefined

//----- (000000000041E100) ----------------------------------------------------
__int64 __fastcall camlPrintf__loop_187()
{
  __int64 v0; // rax
  _QWORD *v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rcx
  __int64 v4; // rbx
  unsigned __int64 v5; // rsi
  _QWORD *v7; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    if ( v0 >= v1[4] - 4LL )
      return 1LL;
    v7 = v1;
    v2 = v1[3];
    v3 = v1[2];
    v4 = 8LL * (*(_QWORD *)(v3 - 8) >> 10) - 1;
    v5 = *(unsigned __int8 *)(v3 + v4);
    if ( v4 - v5 <= v0 >> 1 )
      break;
    v0 = caml_apply2(v2);
    v1 = v7;
  }
  caml_ml_array_bound_error(v2, v5);
  return camlPrintf__fun_594(v2);
}
// 41E10F: variable 'v0' is possibly undefined
// 41E104: variable 'v1' is possibly undefined

//----- (000000000041E170) ----------------------------------------------------
__int64 __fastcall camlPrintf__fun_594(__int64 a1)
{
  __int64 v1; // rax
  double *v2; // rbx
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // rsi
  unsigned __int64 v5; // rax
  __int64 v6; // rdi
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9

  v3 = *(_QWORD *)(a1 + 24) - v1 - 3 + 2;
  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 - 8);
  v6 = (unsigned __int8)v5;
  if ( (unsigned __int8)v5 == 254LL )
  {
    if ( v5 >> 9 > v3 )
    {
      *(double *)(v4 + 4 * v3 - 4) = *v2;
      return 1LL;
    }
    caml_ml_array_bound_error(254LL, v4);
  }
  else if ( v5 >> 9 > v3 )
  {
    caml_modify((unsigned __int64 *)(v4 + 4 * v3 - 4), (unsigned __int64)v2);
    return 1LL;
  }
  caml_ml_array_bound_error(v6, v4);
  return (__int64)camlPrintf__fun_597(v6, v4, v8, v9, v10, v11);
}
// 41E178: variable 'v1' is possibly undefined
// 41E1AF: variable 'v2' is possibly undefined
// 41E1E2: variable 'v8' is possibly undefined
// 41E1E2: variable 'v9' is possibly undefined
// 41E1E2: variable 'v10' is possibly undefined
// 41E1E2: variable 'v11' is possibly undefined

//----- (000000000041E1F0) ----------------------------------------------------
_QWORD *__fastcall camlPrintf__fun_597(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdi
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(i, v7, a3, a4, a5, a6, v11) )
  {
    v8 -= 3;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 2048LL;
  v8[1] = i;
  v8[2] = *(_QWORD *)(v7 + 32);
  return camlPrintf__loop_268(*(_QWORD *)(v7 + 16), v7, a3, a4, a5, a6);
}
// 41E1F4: variable 'v6' is possibly undefined
// 41E1FA: variable 'v8' is possibly undefined
// 41E219: variable 'v7' is possibly undefined
// 41E231: variable 'a3' is possibly undefined
// 41E231: variable 'a4' is possibly undefined
// 41E231: variable 'a5' is possibly undefined
// 41E231: variable 'a6' is possibly undefined
// 41E236: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041E240) ----------------------------------------------------
__int64 __fastcall camlPrintf__got_spec_336(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 arg_320; // rbx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // [rsp+0h] [rbp-28h]
  __int64 v18; // [rsp+18h] [rbp-10h]

  v16 = v6;
  v18 = v7;
  v9 = a1[3];
  arg_320 = camlPrintf__get_arg_320(v9, a2, a3, a4, a5, a6);
  while ( 1 )
  {
    v8 -= 3;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(v9, a2, v10, v11, v13, v14, v16);
  }
  *v8 = 2048LL;
  v8[1] = arg_320;
  v8[2] = a1[7];
  if ( v16 == 1 )
    (**(void (***)(void))(camlPrintf[11] + 16LL))();
  return camlPrintf__scan_flags_324((__int64)(v8 + 1), v18, a1[4]);
}
// 41E244: variable 'v6' is possibly undefined
// 41E248: variable 'v7' is possibly undefined
// 41E265: variable 'v8' is possibly undefined
// 41E2A2: variable 'v16' is possibly undefined
// 41E2E3: variable 'v10' is possibly undefined
// 41E2E3: variable 'v11' is possibly undefined
// 41E2E3: variable 'v13' is possibly undefined
// 41E2E3: variable 'v14' is possibly undefined
// 653BE0: using guessed type _QWORD camlPrintf[40];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041E2F0) ----------------------------------------------------
__int64 __fastcall camlPrintf__got_spec_329(__int64 a1)
{
  __int64 v1; // rbx

  return camlPrintf__scan_flags_324(*(_QWORD *)(a1 + 40), v1, *(_QWORD *)(a1 + 24));
}
// 41E302: variable 'v1' is possibly undefined

//----- (000000000041E310) ----------------------------------------------------
__int64 __fastcall camlPrintf__cont_m_397(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  _QWORD *v7; // r15
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 i; // rsi
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v14; // [rsp+0h] [rbp-28h]

  v14 = a2;
  camlPrintf__ac_of_format_212(a1, a2, a3, a4, a5, a6);
  for ( i = camlPrintf__index_of_int_65(a1, a2); ; caml_call_gc(a1, i, v8, v9, v11, v12, v14) )
  {
    v7 -= 6;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 5367LL;
  v7[1] = camlPrintf__code_begin;
  v7[2] = 3LL;
  v7[3] = v14 - 160;
  v7[4] = a1;
  v7[5] = i;
  return camlPrintf__pr_386(v6, *(_QWORD *)(v14 + 88), *(_QWORD **)(v14 + 64));
}
// 41E310: could not find valid save-restore pair for rbx
// 41E344: variable 'v7' is possibly undefined
// 41E379: variable 'v14' is possibly undefined
// 41E3A7: variable 'v6' is possibly undefined
// 41E3AC: variable 'v8' is possibly undefined
// 41E3AC: variable 'v9' is possibly undefined
// 41E3AC: variable 'v11' is possibly undefined
// 41E3AC: variable 'v12' is possibly undefined
// 41DF20: using guessed type __int64 __fastcall camlPrintf__code_begin();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041E3C0) ----------------------------------------------------
__int64 __fastcall camlPrintf__cont_f_396(__int64 a1)
{
  (**(void (***)(void))(a1 + 80))();
  return camlPrintf__doprn_392(a1 - 128);
}

//----- (000000000041E400) ----------------------------------------------------
__int64 __fastcall camlPrintf__cont_t_395(__int64 a1, __int64 a2)
{
  void (**v2)(void); // rbx

  if ( *(_QWORD *)(a2 + 88) == 1LL )
  {
    (*v2)();
  }
  else
  {
    (*v2)();
    caml_apply2(*(_QWORD *)(a2 + 104));
  }
  return camlPrintf__doprn_392(a2 - 96);
}
// 41E423: variable 'v2' is possibly undefined

//----- (000000000041E470) ----------------------------------------------------
__int64 __fastcall camlPrintf__cont_a_394(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx

  if ( *(_QWORD *)(a3 + 120) == 1LL )
  {
    caml_apply2(v3);
  }
  else
  {
    caml_apply2(v3);
    caml_apply2(*(_QWORD *)(a3 + 136));
  }
  return camlPrintf__doprn_392(a3 - 64);
}
// 41E49C: variable 'v3' is possibly undefined

//----- (000000000041E4F0) ----------------------------------------------------
__int64 __fastcall camlPrintf__cont_s_393(__int64 a1, __int64 a2)
{
  caml_apply2(*(_QWORD *)(a2 + 168));
  return camlPrintf__doprn_392(a2 - 32);
}
// 41E4F0: could not find valid save-restore pair for rbx

//----- (000000000041E530) ----------------------------------------------------
__int64 __fastcall camlPrintf__doprn_392(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v4; // [rsp+8h] [rbp-10h]

  while ( 1 )
  {
    if ( v2 >= *(_QWORD *)(a1 + 256) )
      return (**(__int64 (***)(void))(a1 + 232))();
    if ( 2LL * *(unsigned __int8 *)(*(_QWORD *)(a1 + 240) + (v2 >> 1)) == 74 )
      break;
    v4 = v1;
    caml_apply2(*(_QWORD *)(a1 + 192));
    v2 += 2LL;
    v1 = v4;
  }
  return camlPrintf__scan_format_310(v1, v2, a1 + 32, a1 + 64, a1 + 96, a1 + 128);
}
// 41E544: variable 'v2' is possibly undefined
// 41E586: variable 'v1' is possibly undefined

//----- (000000000041E600) ----------------------------------------------------
__int64 camlPrintf__fun_716()
{
  return 1LL;
}
// 41E600: using guessed type __int64 __fastcall camlPrintf__fun_716();

//----- (000000000041E610) ----------------------------------------------------
_QWORD *__fastcall camlPrintf__parse_97(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rsi
  __int64 v10; // rdx
  __int64 v11; // rax
  __int64 v12; // rdx
  _QWORD *result; // rax
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rsi
  unsigned __int64 v17; // rsi
  __int64 v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rax
  __int64 i; // rdi
  char v25; // [rsp+0h] [rbp-8h]
  __int64 v26; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    v9 = v6;
    v10 = *(_QWORD *)(a1 + 24);
    v11 = 8LL * (*(_QWORD *)(v10 - 8) >> 10) - 1;
    v12 = *(unsigned __int8 *)(v10 + v11);
    if ( v7 >= 2 * (v11 - v12) + 1 )
      break;
    v14 = 2LL * *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + (v7 >> 1)) + 1;
    if ( v14 < 99 )
    {
      if ( 2LL * *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + (v7 >> 1)) != 90 )
        goto LABEL_11;
      v7 += 2LL;
      v6 = 3LL;
    }
    else
    {
      if ( v14 < 117 )
      {
        v26 = v9;
        v15 = *(_QWORD *)(a1 + 24);
        v16 = 8LL * (*(_QWORD *)(v15 - 8) >> 10) - 1;
        v17 = 2 * (v16 - *(unsigned __int8 *)(v15 + v16)) - v7;
        v18 = camlString__sub_74(v17, v17, v15, a4, a5, a6);
        caml_c_call(v18, v17);
        for ( i = v23; ; caml_call_gc(i, v17, v19, v20, v21, v22, v26) )
        {
          v8 -= 3;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
        }
        *v8 = 2048LL;
        v8[1] = i;
        v8[2] = v26;
        return v8 + 1;
      }
LABEL_11:
      v7 += 2LL;
      v6 = v9;
    }
  }
  while ( 1 )
  {
    v8 -= 3;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(a1, v9, v12, a4, a5, a6, v25);
  }
  result = v8 + 1;
  *v8 = 2048LL;
  v8[1] = 1LL;
  v8[2] = v9;
  return result;
}
// 41E614: variable 'v6' is possibly undefined
// 41E63B: variable 'v7' is possibly undefined
// 41E63D: variable 'v8' is possibly undefined
// 41E6E1: variable 'v23' is possibly undefined
// 41E707: variable 'v26' is possibly undefined
// 41E738: variable 'v19' is possibly undefined
// 41E738: variable 'v20' is possibly undefined
// 41E738: variable 'v21' is possibly undefined
// 41E738: variable 'v22' is possibly undefined
// 41E73F: variable 'v12' is possibly undefined
// 41E73F: variable 'a4' is possibly undefined
// 41E73F: variable 'a5' is possibly undefined
// 41E73F: variable 'a6' is possibly undefined
// 41E73F: variable 'v25' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041E750) ----------------------------------------------------
__int64 __fastcall camlPrintf__skip_positional_spec_118(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdx
  __int64 v10; // rsi
  unsigned __int64 v11; // rdi
  char v12; // [rsp+0h] [rbp-8h]

  v9 = result;
  v10 = result >> 1;
  v11 = 2LL * *(unsigned __int8 *)(*(_QWORD *)(v7 + 16) + (result >> 1)) - 95;
  if ( v11 <= 0x13 )
  {
    while ( 1 )
    {
      v8 -= 5;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(v11, v10, v9, a4, a5, a6, v12);
    }
    *v8 = 4343LL;
    v8[1] = camlPrintf__skip_int_literal_120;
    v8[2] = 3LL;
    v8[3] = *(_QWORD *)(v7 + 16);
    v8[4] = v9;
    return camlPrintf__skip_int_literal_120();
  }
  return result;
}
// 41E754: variable 'result' is possibly undefined
// 41E75D: variable 'v7' is possibly undefined
// 41E780: variable 'v8' is possibly undefined
// 41E7B6: variable 'v9' is possibly undefined
// 41E7CD: variable 'a4' is possibly undefined
// 41E7CD: variable 'a5' is possibly undefined
// 41E7CD: variable 'a6' is possibly undefined
// 41E7CD: variable 'v12' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041E7E0) ----------------------------------------------------
__int64 __fastcall camlPrintf__fill_format_124(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdx
  __int64 v10; // rsi
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v20; // [rsp+0h] [rbp-18h]
  __int64 v21; // [rsp+8h] [rbp-10h]

  while ( v6 <= *(_QWORD *)(a1 + 32) )
  {
    v9 = v6 >> 1;
    v10 = 2LL * *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + (v6 >> 1)) + 1;
    if ( 2LL * *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + (v6 >> 1)) == 84 )
    {
      if ( v7 == 1 )
      {
        while ( 1 )
        {
          v8 -= 3;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(a1, v10, v9, a4, a5, a6, v20);
        }
        *v8 = 2048LL;
        v8[1] = &caml_exn_Assert_failure;
        v8[2] = &camlPrintf__67;
        caml_raise_exn();
        return 1LL;
      }
      v20 = *(_QWORD *)(v7 + 8);
      camlPervasives__string_of_int_154();
      camlBuffer__add_string_110(a1, v10, v11, v12, v13, v14);
      v6 = camlPrintf__skip_positional_spec_118(a1, v10, v15, v16, v17, v18);
      v7 = v20;
    }
    else
    {
      LOBYTE(v20) = v7;
      v21 = v6;
      camlBuffer__add_char_100(a1, v10, v9, a4, a5, a6);
      v6 = v21 + 2;
    }
  }
  return 1LL;
}
// 41E7EB: variable 'v6' is possibly undefined
// 41E810: variable 'v7' is possibly undefined
// 41E820: variable 'a4' is possibly undefined
// 41E820: variable 'a5' is possibly undefined
// 41E820: variable 'a6' is possibly undefined
// 41E868: variable 'v11' is possibly undefined
// 41E868: variable 'v12' is possibly undefined
// 41E868: variable 'v13' is possibly undefined
// 41E868: variable 'v14' is possibly undefined
// 41E87F: variable 'v15' is possibly undefined
// 41E87F: variable 'v16' is possibly undefined
// 41E87F: variable 'v17' is possibly undefined
// 41E87F: variable 'v18' is possibly undefined
// 41E894: variable 'v8' is possibly undefined
// 41E8DC: variable 'v9' is possibly undefined
// 41E8DC: variable 'v20' is possibly undefined
// 647C48: using guessed type char *caml_exn_Assert_failure;
// 654408: using guessed type char *camlPrintf__67;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041E8F0) ----------------------------------------------------
__int64 __fastcall camlPrintf__sub_fmt_152(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdx
  char v11; // [rsp+0h] [rbp-8h]

  if ( v6 == 81 )
    v9 = 83LL;
  else
    v9 = 251LL;
  while ( 1 )
  {
    v8 -= 13;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc((__int64)a1, a2, v9, a4, a5, a6, v11);
  }
  *v8 = 12535LL;
  v8[1] = camlPrintf__sub_156;
  v8[2] = 3LL;
  v8[3] = 3321LL;
  v8[4] = camlPrintf__sub_sub_157;
  v8[5] = 3LL;
  v8[6] = a1[3];
  v8[7] = a1[4];
  v8[8] = a1[5];
  v8[9] = a1[6];
  v8[10] = a1;
  v8[11] = v7;
  v8[12] = v9;
  return camlPrintf__sub_156((__int64)a1, (__int64)(v8 + 1), v9, a4, a5, a6);
}
// 41E8F8: variable 'v6' is possibly undefined
// 41E90B: variable 'v8' is possibly undefined
// 41E978: variable 'v7' is possibly undefined
// 41E97C: variable 'v9' is possibly undefined
// 41E98A: variable 'a4' is possibly undefined
// 41E98A: variable 'a5' is possibly undefined
// 41E98A: variable 'a6' is possibly undefined
// 41E98F: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041E9A0) ----------------------------------------------------
__int64 __fastcall camlPrintf__scan_fmt_172(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // rbx
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rdi
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rdi
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9

  while ( result < *(_QWORD *)(v7 + 40) )
  {
    v8 = *(_QWORD *)(v7 + 16);
    v9 = result >> 1;
    v10 = 8LL * (*(_QWORD *)(v8 - 8) >> 10) - 1;
    v11 = *(unsigned __int8 *)(v8 + v10);
    v12 = v10 - v11;
    if ( v12 <= result >> 1 )
    {
      caml_ml_array_bound_error(v12, v11);
      return camlPrintf__scan_conv_171(v12, v11, v13, v14, v15, v16);
    }
    if ( 2LL * *(unsigned __int8 *)(v8 + v9) == 74 )
      result = camlPrintf__scan_flags_170((_QWORD *)(v7 - 64), v11, v9, v8, a5, a6);
    else
      result += 2LL;
  }
  return result;
}
// 41E9AB: variable 'result' is possibly undefined
// 41E9A4: variable 'v7' is possibly undefined
// 41E9FD: variable 'a5' is possibly undefined
// 41E9FD: variable 'a6' is possibly undefined
// 41EA1B: variable 'v13' is possibly undefined
// 41EA1B: variable 'v14' is possibly undefined
// 41EA1B: variable 'v15' is possibly undefined
// 41EA1B: variable 'v16' is possibly undefined

//----- (000000000041EA20) ----------------------------------------------------
__int64 __fastcall camlPrintf__scan_conv_171(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  _QWORD *v9; // rsi
  __int64 v10; // rdi
  __int64 v11; // rsi
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 result; // rax
  __int64 v17; // rdi
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rsi
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // r9
  unsigned __int64 v24; // r8
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 i; // [rsp+0h] [rbp-28h]
  __int64 v32; // [rsp+10h] [rbp-18h]
  _QWORD *v33; // [rsp+18h] [rbp-10h]

  while ( 2 )
  {
    v9 = (_QWORD *)a1;
    if ( v7 > *(_QWORD *)(a1 + 72) )
      camlPrintf__incomplete_format_93(a1, a1, a3, v6, a5, a6);
    v10 = 2LL * *(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + (v7 >> 1)) + 1;
    if ( v10 >= 253 )
LABEL_9:
      camlPrintf__bad_conversion_format_89(v10, (unsigned __int64)v9, a3, v6, a5, a6);
    v33 = v9;
    v32 = v6;
    switch ( v10 >> 1 )
    {
      case 0LL:
      case 1LL:
      case 2LL:
      case 3LL:
      case 4LL:
      case 5LL:
      case 6LL:
      case 7LL:
      case 8LL:
      case 9LL:
      case 10LL:
      case 11LL:
      case 12LL:
      case 13LL:
      case 14LL:
      case 15LL:
      case 16LL:
      case 17LL:
      case 18LL:
      case 19LL:
      case 20LL:
      case 21LL:
      case 22LL:
      case 23LL:
      case 24LL:
      case 25LL:
      case 26LL:
      case 27LL:
      case 28LL:
      case 29LL:
      case 30LL:
      case 31LL:
      case 32LL:
      case 34LL:
      case 35LL:
      case 36LL:
      case 38LL:
      case 39LL:
      case 42LL:
      case 43LL:
      case 45LL:
      case 46LL:
      case 47LL:
      case 48LL:
      case 49LL:
      case 50LL:
      case 51LL:
      case 52LL:
      case 53LL:
      case 54LL:
      case 55LL:
      case 56LL:
      case 57LL:
      case 58LL:
      case 59LL:
      case 60LL:
      case 61LL:
      case 62LL:
      case 63LL:
      case 64LL:
      case 65LL:
      case 68LL:
      case 72LL:
      case 73LL:
      case 74LL:
      case 75LL:
      case 77LL:
      case 79LL:
      case 80LL:
      case 81LL:
      case 82LL:
      case 84LL:
      case 85LL:
      case 86LL:
      case 87LL:
      case 89LL:
      case 90LL:
      case 92LL:
      case 93LL:
      case 94LL:
      case 95LL:
      case 96LL:
      case 104LL:
      case 106LL:
      case 107LL:
      case 109LL:
      case 112LL:
      case 113LL:
      case 118LL:
      case 119LL:
      case 121LL:
      case 122LL:
      case 124LL:
        goto LABEL_9;
      case 33LL:
      case 37LL:
      case 44LL:
        return v7 + 2;
      case 40LL:
        v11 = v9[7];
        caml_apply3(v10, v11);
        return camlPrintf__scan_fmt_172(v10, v11, v12, v13, v14, v15);
      case 41LL:
      case 97LL:
      case 114LL:
      case 116LL:
      case 125LL:
        return caml_apply3(v10, v9[7]);
      case 66LL:
      case 98LL:
        return caml_apply3(133LL, v9[7]);
      case 67LL:
      case 99LL:
        return caml_apply3(199LL, v9[7]);
      case 69LL:
      case 70LL:
      case 71LL:
      case 101LL:
      case 102LL:
      case 103LL:
        return caml_apply3(205LL, v9[7]);
      case 76LL:
      case 108LL:
      case 110LL:
        if ( v7 + 2 > v9[9] )
          return caml_apply3(211LL, v9[7]);
        v23 = v9[6];
        v24 = (v7 + 2) >> 1;
        v25 = 8LL * (*(_QWORD *)(v23 - 8) >> 10) - 1;
        if ( v25 - (unsigned __int64)*(unsigned __int8 *)(v23 + v25) <= v24 )
        {
          caml_ml_array_bound_error(v10, (unsigned __int64)v9);
          return camlPrintf__scan_flags_170((_QWORD *)v10, (__int64)v9, v27, v28, v29, v30);
        }
        else
        {
          v26 = 2LL * *(unsigned __int8 *)(v23 + v24) - 175;
          if ( (unsigned __int64)v26 > 0x41 )
          {
            return caml_apply3(211LL, v9[7]);
          }
          else
          {
            switch ( v26 >> 1 )
            {
              case 0LL:
              case 12LL:
              case 17LL:
              case 23LL:
              case 29LL:
              case 32LL:
                caml_apply3(v10, v9[7]);
                result = caml_apply2(v9[8]);
                break;
              case 1LL:
              case 2LL:
              case 3LL:
              case 4LL:
              case 5LL:
              case 6LL:
              case 7LL:
              case 8LL:
              case 9LL:
              case 10LL:
              case 11LL:
              case 13LL:
              case 14LL:
              case 15LL:
              case 16LL:
              case 18LL:
              case 19LL:
              case 20LL:
              case 21LL:
              case 22LL:
              case 24LL:
              case 25LL:
              case 26LL:
              case 27LL:
              case 28LL:
              case 30LL:
              case 31LL:
                return caml_apply3(211LL, v9[7]);
            }
          }
        }
        return result;
      case 78LL:
      case 88LL:
      case 100LL:
      case 105LL:
      case 111LL:
      case 117LL:
      case 120LL:
        return caml_apply3(211LL, v9[7]);
      case 83LL:
      case 91LL:
      case 115LL:
        return caml_apply3(231LL, v9[7]);
      case 123LL:
        caml_apply3(v10, v9[7]);
        v17 = camlPrintf__sub_format_for_printf_163();
        v20 = caml_apply2(v17);
        for ( i = v20; ; caml_call_gc(v17, v20, v18, v19, v21, v22, i) )
        {
          v8 -= 6;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
        }
        *v8 = 5367LL;
        v8[1] = camlPrintf__loop_187;
        v8[2] = 3LL;
        v8[3] = v33[6];
        v8[4] = v33[8];
        v8[5] = v20;
        camlPrintf__loop_187();
        v7 = i - 2;
        v6 = v32;
        a1 = (__int64)v33;
        continue;
    }
  }
}
// 41EA31: variable 'v7' is possibly undefined
// 41EA3B: variable 'a3' is possibly undefined
// 41EA3B: variable 'v6' is possibly undefined
// 41EA3B: variable 'a5' is possibly undefined
// 41EA3B: variable 'a6' is possibly undefined
// 41EA9D: variable 'v12' is possibly undefined
// 41EA9D: variable 'v13' is possibly undefined
// 41EA9D: variable 'v14' is possibly undefined
// 41EA9D: variable 'v15' is possibly undefined
// 41EADF: variable 'v8' is possibly undefined
// 41EB3B: variable 'i' is possibly undefined
// 41ECC4: variable 'v18' is possibly undefined
// 41ECC4: variable 'v19' is possibly undefined
// 41ECC4: variable 'v21' is possibly undefined
// 41ECC4: variable 'v22' is possibly undefined
// 41ECD4: variable 'v27' is possibly undefined
// 41ECD4: variable 'v28' is possibly undefined
// 41ECD4: variable 'v29' is possibly undefined
// 41ECD4: variable 'v30' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041ECE0) ----------------------------------------------------
__int64 __fastcall camlPrintf__scan_flags_170(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rsi
  __int64 v9; // rax

  while ( 1 )
  {
LABEL_1:
    v8 = v6;
    if ( v7 > a1[13] )
      camlPrintf__incomplete_format_93((__int64)a1, v6, a3, a4, a5, a6);
    a3 = v7 >> 1;
    v9 = 2LL * *(unsigned __int8 *)(a1[10] + (v7 >> 1)) + 1;
    if ( v9 < 117 )
      break;
    if ( 2LL * *(unsigned __int8 *)(a1[10] + (v7 >> 1)) != 190 )
      return camlPrintf__scan_conv_171((__int64)(a1 + 4), v8, a3, a4, a5, a6);
    v7 += 2LL;
    v6 = 3LL;
  }
  if ( v9 >= 65 )
  {
    switch ( (2LL * *(unsigned __int8 *)(a1[10] + (v7 >> 1)) - 63) >> 1 )
    {
      case 0LL:
      case 3LL:
      case 11LL:
      case 13LL:
        v7 += 2LL;
        v6 = v8;
        goto LABEL_1;
      case 1LL:
      case 2LL:
      case 4LL:
      case 5LL:
      case 6LL:
      case 7LL:
      case 8LL:
      case 9LL:
      case 12LL:
      case 15LL:
        return camlPrintf__scan_conv_171((__int64)(a1 + 4), v8, a3, a4, a5, a6);
      case 10LL:
        v7 = caml_apply3(211LL, a1[11]);
        v6 = v8;
        goto LABEL_1;
      case 14LL:
      case 16LL:
      case 17LL:
      case 18LL:
      case 19LL:
      case 20LL:
      case 21LL:
      case 22LL:
      case 23LL:
      case 24LL:
      case 25LL:
        v7 += 2LL;
        v6 = v8;
        goto LABEL_1;
    }
  }
  return camlPrintf__scan_conv_171((__int64)(a1 + 4), v8, a3, a4, a5, a6);
}
// 41ECE4: variable 'v6' is possibly undefined
// 41ECEE: variable 'v7' is possibly undefined
// 41ECF8: variable 'a3' is possibly undefined
// 41ECF8: variable 'a4' is possibly undefined
// 41ECF8: variable 'a5' is possibly undefined
// 41ECF8: variable 'a6' is possibly undefined

//----- (000000000041EDB0) ----------------------------------------------------
__int64 __fastcall camlPrintf__add_char_194(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v8; // [rsp+0h] [rbp-8h]

  v8 = v6;
  camlBuffer__add_char_100(a1, a2, a3, a4, a5, a6);
  return v8 + 2;
}
// 41EDB4: variable 'v6' is possibly undefined

//----- (000000000041EDD0) ----------------------------------------------------
__int64 __fastcall camlPrintf__add_conv_197(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9

  if ( v6 == 1 )
    camlBuffer__add_char_100(a1, a2, a3, a4, a5, a6);
  else
    camlBuffer__add_string_110(a1, a2, a3, a4, a5, a6);
  camlBuffer__add_char_100(a1, a2, v8, v9, v10, v11);
  return v7 + 2;
}
// 41EDD0: could not find valid save-restore pair for rbx
// 41EDE6: variable 'v6' is possibly undefined
// 41EE1D: variable 'v8' is possibly undefined
// 41EE1D: variable 'v9' is possibly undefined
// 41EE1D: variable 'v10' is possibly undefined
// 41EE1D: variable 'v11' is possibly undefined
// 41EE27: variable 'v7' is possibly undefined

//----- (000000000041EE30) ----------------------------------------------------
__int64 __fastcall camlPrintf__incr_ac_215(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rsi

  if ( v2 == 195 )
    v3 = 5LL;
  else
    v3 = 3LL;
  if ( v2 == 229 )
    *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16LL) += 2LL;
  if ( v1 == 1 )
    **(_QWORD **)(a1 + 24) = **(_QWORD **)(a1 + 24) + v3 - 1;
  else
    *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL) = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8LL) + v3 - 1;
  return 1LL;
}
// 41EE37: variable 'v2' is possibly undefined
// 41EE61: variable 'v1' is possibly undefined

//----- (000000000041EEA0) ----------------------------------------------------
__int64 __fastcall camlPrintf__add_conv_219(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  if ( a1 != 83 && a1 != 251 )
    camlPrintf__incr_ac_215(*(_QWORD *)(a2 + 24));
  return v2 + 2;
}
// 41EECA: variable 'v2' is possibly undefined

//----- (000000000041EEE0) ----------------------------------------------------
__int64 __fastcall camlPrintf__add_char_220()
{
  __int64 v0; // rax

  return v0 + 2;
}
// 41EEE0: variable 'v0' is possibly undefined
// 41EEE0: using guessed type __int64 __fastcall camlPrintf__add_char_220();

//----- (000000000041EEF0) ----------------------------------------------------
__int64 __fastcall camlPrintf__loop_232(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // rsi
  __int64 v5; // [rsp+0h] [rbp-18h]

  while ( v2 != 1 )
  {
    v3 = *(_QWORD *)(v2 + 8);
    if ( v3 == 1 )
      return caml_apply2(*(_QWORD *)(a1 + 24));
    v5 = v1;
    caml_apply2(*(_QWORD *)(a1 + 24));
    v1 = v5 + 2;
    v2 = v3;
  }
  return 1LL;
}
// 41EEF8: variable 'v2' is possibly undefined
// 41EF11: variable 'v1' is possibly undefined

//----- (000000000041EF50) ----------------------------------------------------
_QWORD *__fastcall camlPrintf__loop_268(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rax
  __int64 i; // rdi
  _QWORD *result; // rax
  char v17; // [rsp+0h] [rbp-18h]
  char v18; // [rsp+0h] [rbp-18h]

  v9 = v6;
  if ( v6 < *(_QWORD *)(a1 + 40) )
  {
    while ( 1 )
    {
      v8 -= 6;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(a1, a2, v9, a4, a5, a6, v17);
    }
    result = v8 + 1;
    *v8 = 5367LL;
    v8[1] = camlPrintf__fun_597;
    v8[2] = 3LL;
    v8[3] = a1;
    v8[4] = v9;
    v8[5] = v7;
  }
  else
  {
    v18 = v7;
    caml_c_call(*(_QWORD *)(a1 + 40), 1uLL);
    for ( i = v14; ; caml_call_gc(i, 1LL, v10, v11, v12, v13, v18) )
    {
      v8 -= 6;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
    }
    *v8 = 5367LL;
    v8[1] = caml_curry2;
    v8[2] = 5LL;
    v8[3] = camlPrintf__fun_594;
    v8[4] = *(_QWORD *)(a1 + 40);
    v8[5] = i;
    camlPrintf__list_iter_i_229(i, 1LL, v10, v11, v12, v13);
    return (_QWORD *)caml_apply2(*(_QWORD *)(a1 + 24));
  }
  return result;
}
// 41EF54: variable 'v6' is possibly undefined
// 41EF69: variable 'v7' is possibly undefined
// 41EF84: variable 'v14' is possibly undefined
// 41EF8C: variable 'v8' is possibly undefined
// 41EFDE: variable 'v10' is possibly undefined
// 41EFDE: variable 'v11' is possibly undefined
// 41EFDE: variable 'v12' is possibly undefined
// 41EFDE: variable 'v13' is possibly undefined
// 41F032: variable 'v9' is possibly undefined
// 41F03F: variable 'a4' is possibly undefined
// 41F03F: variable 'a5' is possibly undefined
// 41F03F: variable 'a6' is possibly undefined
// 41F03F: variable 'v17' is possibly undefined
// 41F046: variable 'v18' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041F050) ----------------------------------------------------
__int64 __fastcall camlPrintf__fun_616(double *a1, double *a2, double *a3, double *a4, __int64 a5)
{
  double *v5; // rax
  double *v6; // rbx
  unsigned __int64 v7; // rsi
  unsigned __int64 *v8; // rax
  unsigned __int64 *v9; // rbx
  unsigned __int64 v10; // rax
  __int64 v11; // rdi
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rax
  double *v18; // rdx
  __int64 v19; // rcx
  double *v25; // [rsp+28h] [rbp-10h]
  double *v26; // [rsp+30h] [rbp-8h]

  v26 = v5;
  v25 = v6;
  v7 = 1LL;
  caml_c_call(13LL, 1uLL);
  v9 = v8;
  v10 = *(v8 - 1);
  v11 = (unsigned __int8)v10;
  if ( (unsigned __int8)v10 == 254LL )
  {
    if ( v10 >> 9 <= 1 )
    {
LABEL_42:
      caml_ml_array_bound_error(v11, v7);
      goto LABEL_43;
    }
    *v9 = *(unsigned __int64 *)v26;
LABEL_6:
    v12 = *(v9 - 1);
    v11 = (unsigned __int8)v12;
    if ( (unsigned __int8)v12 == 254LL )
    {
      if ( v12 >> 9 <= 3 )
      {
LABEL_40:
        caml_ml_array_bound_error(v11, v7);
        goto LABEL_41;
      }
      v9[1] = *(unsigned __int64 *)v25;
    }
    else
    {
      if ( v12 >> 9 <= 3 )
      {
LABEL_41:
        caml_ml_array_bound_error(v11, v7);
        goto LABEL_42;
      }
      v7 = (unsigned __int64)v25;
      caml_modify(v9 + 1, (unsigned __int64)v25);
    }
    v13 = *(v9 - 1);
    v11 = (unsigned __int8)v13;
    if ( (unsigned __int8)v13 == 254LL )
    {
      if ( v13 >> 9 <= 5 )
      {
LABEL_38:
        caml_ml_array_bound_error(v11, v7);
        goto LABEL_39;
      }
      v9[2] = *(unsigned __int64 *)a1;
    }
    else
    {
      if ( v13 >> 9 <= 5 )
      {
LABEL_39:
        caml_ml_array_bound_error(v11, v7);
        goto LABEL_40;
      }
      v7 = (unsigned __int64)a1;
      caml_modify(v9 + 2, (unsigned __int64)a1);
    }
    v14 = *(v9 - 1);
    v11 = (unsigned __int8)v14;
    if ( (unsigned __int8)v14 == 254LL )
    {
      if ( v14 >> 9 <= 7 )
      {
LABEL_36:
        caml_ml_array_bound_error(v11, v7);
        goto LABEL_37;
      }
      v9[3] = *(unsigned __int64 *)a2;
    }
    else
    {
      if ( v14 >> 9 <= 7 )
      {
LABEL_37:
        caml_ml_array_bound_error(v11, v7);
        goto LABEL_38;
      }
      v7 = (unsigned __int64)a2;
      caml_modify(v9 + 3, (unsigned __int64)a2);
    }
    v15 = *(v9 - 1);
    v11 = (unsigned __int8)v15;
    if ( (unsigned __int8)v15 == 254LL )
    {
      if ( v15 >> 9 <= 9 )
      {
LABEL_34:
        caml_ml_array_bound_error(v11, v7);
        goto LABEL_35;
      }
      v9[4] = *(unsigned __int64 *)a3;
    }
    else
    {
      if ( v15 >> 9 <= 9 )
      {
LABEL_35:
        caml_ml_array_bound_error(v11, v7);
        goto LABEL_36;
      }
      v7 = (unsigned __int64)a3;
      caml_modify(v9 + 4, (unsigned __int64)a3);
    }
    v16 = *(v9 - 1);
    v11 = (unsigned __int8)v16;
    if ( (unsigned __int8)v16 == 254LL )
    {
      if ( v16 >> 9 > 0xB )
      {
        v9[5] = *(unsigned __int64 *)a4;
        return caml_apply2(*(_QWORD *)(a5 + 24));
      }
      caml_ml_array_bound_error(254LL, v7);
    }
    else if ( v16 >> 9 > 0xB )
    {
      caml_modify(v9 + 5, (unsigned __int64)a4);
      return caml_apply2(*(_QWORD *)(a5 + 24));
    }
    caml_ml_array_bound_error(v11, v7);
    goto LABEL_34;
  }
  if ( v10 >> 9 > 1 )
  {
    v7 = (unsigned __int64)v26;
    caml_modify(v9, (unsigned __int64)v26);
    goto LABEL_6;
  }
LABEL_43:
  caml_ml_array_bound_error(v11, v7);
  return camlPrintf__fun_613((double *)v11, (double *)v7, v18, v19);
}
// 41F054: variable 'v5' is possibly undefined
// 41F059: variable 'v6' is possibly undefined
// 41F090: variable 'v8' is possibly undefined
// 41F2CE: variable 'v18' is possibly undefined
// 41F2CE: variable 'v19' is possibly undefined

//----- (000000000041F2D0) ----------------------------------------------------
__int64 __fastcall camlPrintf__fun_613(double *a1, double *a2, double *a3, __int64 a4)
{
  double *v4; // rax
  double *v5; // rbx
  unsigned __int64 v6; // rsi
  unsigned __int64 *v7; // rax
  unsigned __int64 *v8; // rbx
  unsigned __int64 v9; // rax
  __int64 v10; // rdi
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rax
  __int64 v16; // rdx
  double *v21; // [rsp+20h] [rbp-18h]
  double *v22; // [rsp+28h] [rbp-10h]

  v22 = v4;
  v21 = v5;
  v6 = 1LL;
  caml_c_call(11LL, 1uLL);
  v8 = v7;
  v9 = *(v7 - 1);
  v10 = (unsigned __int8)v9;
  if ( (unsigned __int8)v9 == 254LL )
  {
    if ( v9 >> 9 <= 1 )
    {
LABEL_35:
      caml_ml_array_bound_error(v10, v6);
      goto LABEL_36;
    }
    *v8 = *(unsigned __int64 *)v22;
LABEL_6:
    v11 = *(v8 - 1);
    v10 = (unsigned __int8)v11;
    if ( (unsigned __int8)v11 == 254LL )
    {
      if ( v11 >> 9 <= 3 )
      {
LABEL_33:
        caml_ml_array_bound_error(v10, v6);
        goto LABEL_34;
      }
      v8[1] = *(unsigned __int64 *)v21;
    }
    else
    {
      if ( v11 >> 9 <= 3 )
      {
LABEL_34:
        caml_ml_array_bound_error(v10, v6);
        goto LABEL_35;
      }
      v6 = (unsigned __int64)v21;
      caml_modify(v8 + 1, (unsigned __int64)v21);
    }
    v12 = *(v8 - 1);
    v10 = (unsigned __int8)v12;
    if ( (unsigned __int8)v12 == 254LL )
    {
      if ( v12 >> 9 <= 5 )
      {
LABEL_31:
        caml_ml_array_bound_error(v10, v6);
        goto LABEL_32;
      }
      v8[2] = *(unsigned __int64 *)a1;
    }
    else
    {
      if ( v12 >> 9 <= 5 )
      {
LABEL_32:
        caml_ml_array_bound_error(v10, v6);
        goto LABEL_33;
      }
      v6 = (unsigned __int64)a1;
      caml_modify(v8 + 2, (unsigned __int64)a1);
    }
    v13 = *(v8 - 1);
    v10 = (unsigned __int8)v13;
    if ( (unsigned __int8)v13 == 254LL )
    {
      if ( v13 >> 9 <= 7 )
      {
LABEL_29:
        caml_ml_array_bound_error(v10, v6);
        goto LABEL_30;
      }
      v8[3] = *(unsigned __int64 *)a2;
    }
    else
    {
      if ( v13 >> 9 <= 7 )
      {
LABEL_30:
        caml_ml_array_bound_error(v10, v6);
        goto LABEL_31;
      }
      v6 = (unsigned __int64)a2;
      caml_modify(v8 + 3, (unsigned __int64)a2);
    }
    v14 = *(v8 - 1);
    v10 = (unsigned __int8)v14;
    if ( (unsigned __int8)v14 == 254LL )
    {
      if ( v14 >> 9 > 9 )
      {
        v8[4] = *(unsigned __int64 *)a3;
        return caml_apply2(*(_QWORD *)(a4 + 24));
      }
      caml_ml_array_bound_error(254LL, v6);
    }
    else if ( v14 >> 9 > 9 )
    {
      caml_modify(v8 + 4, (unsigned __int64)a3);
      return caml_apply2(*(_QWORD *)(a4 + 24));
    }
    caml_ml_array_bound_error(v10, v6);
    goto LABEL_29;
  }
  if ( v9 >> 9 > 1 )
  {
    v6 = (unsigned __int64)v22;
    caml_modify(v8, (unsigned __int64)v22);
    goto LABEL_6;
  }
LABEL_36:
  caml_ml_array_bound_error(v10, v6);
  return camlPrintf__fun_610((double *)v10, (double *)v6, v16);
}
// 41F2D4: variable 'v4' is possibly undefined
// 41F2D9: variable 'v5' is possibly undefined
// 41F30B: variable 'v7' is possibly undefined
// 41F4EC: variable 'v16' is possibly undefined

//----- (000000000041F4F0) ----------------------------------------------------
__int64 __fastcall camlPrintf__fun_610(double *a1, double *a2, __int64 a3)
{
  double *v3; // rax
  double *v4; // rbx
  unsigned __int64 v5; // rsi
  unsigned __int64 *v6; // rax
  unsigned __int64 *v7; // rbx
  unsigned __int64 v8; // rax
  __int64 v9; // rdi
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rax
  double *v17; // [rsp+18h] [rbp-10h]
  double *v18; // [rsp+20h] [rbp-8h]

  v18 = v3;
  v17 = v4;
  v5 = 1LL;
  caml_c_call(9LL, 1uLL);
  v7 = v6;
  v8 = *(v6 - 1);
  v9 = (unsigned __int8)v8;
  if ( (unsigned __int8)v8 == 254LL )
  {
    if ( v8 >> 9 <= 1 )
    {
LABEL_28:
      caml_ml_array_bound_error(v9, v5);
      goto LABEL_29;
    }
    *v7 = *(unsigned __int64 *)v18;
LABEL_6:
    v10 = *(v7 - 1);
    v9 = (unsigned __int8)v10;
    if ( (unsigned __int8)v10 == 254LL )
    {
      if ( v10 >> 9 <= 3 )
      {
LABEL_26:
        caml_ml_array_bound_error(v9, v5);
        goto LABEL_27;
      }
      v7[1] = *(unsigned __int64 *)v17;
    }
    else
    {
      if ( v10 >> 9 <= 3 )
      {
LABEL_27:
        caml_ml_array_bound_error(v9, v5);
        goto LABEL_28;
      }
      v5 = (unsigned __int64)v17;
      caml_modify(v7 + 1, (unsigned __int64)v17);
    }
    v11 = *(v7 - 1);
    v9 = (unsigned __int8)v11;
    if ( (unsigned __int8)v11 == 254LL )
    {
      if ( v11 >> 9 <= 5 )
      {
LABEL_24:
        caml_ml_array_bound_error(v9, v5);
        goto LABEL_25;
      }
      v7[2] = *(unsigned __int64 *)a1;
    }
    else
    {
      if ( v11 >> 9 <= 5 )
      {
LABEL_25:
        caml_ml_array_bound_error(v9, v5);
        goto LABEL_26;
      }
      v5 = (unsigned __int64)a1;
      caml_modify(v7 + 2, (unsigned __int64)a1);
    }
    v12 = *(v7 - 1);
    v9 = (unsigned __int8)v12;
    if ( (unsigned __int8)v12 == 254LL )
    {
      if ( v12 >> 9 > 7 )
      {
        v7[3] = *(unsigned __int64 *)a2;
        return caml_apply2(*(_QWORD *)(a3 + 24));
      }
      caml_ml_array_bound_error(254LL, v5);
    }
    else if ( v12 >> 9 > 7 )
    {
      caml_modify(v7 + 3, (unsigned __int64)a2);
      return caml_apply2(*(_QWORD *)(a3 + 24));
    }
    caml_ml_array_bound_error(v9, v5);
    goto LABEL_24;
  }
  if ( v8 >> 9 > 1 )
  {
    v5 = (unsigned __int64)v18;
    caml_modify(v7, (unsigned __int64)v18);
    goto LABEL_6;
  }
LABEL_29:
  caml_ml_array_bound_error(v9, v5);
  return camlPrintf__fun_607((double *)v9, v5);
}
// 41F4F4: variable 'v3' is possibly undefined
// 41F4F9: variable 'v4' is possibly undefined
// 41F526: variable 'v6' is possibly undefined

//----- (000000000041F6B0) ----------------------------------------------------
__int64 __fastcall camlPrintf__fun_607(double *a1, __int64 a2)
{
  double *v2; // rax
  double *v3; // rbx
  unsigned __int64 v4; // rsi
  unsigned __int64 *v5; // rax
  unsigned __int64 *v6; // rbx
  unsigned __int64 v7; // rax
  __int64 v8; // rdi
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rax
  double *v14; // [rsp+10h] [rbp-18h]
  double *v15; // [rsp+18h] [rbp-10h]

  v15 = v2;
  v14 = v3;
  v4 = 1LL;
  caml_c_call(7LL, 1uLL);
  v6 = v5;
  v7 = *(v5 - 1);
  v8 = (unsigned __int8)v7;
  if ( (unsigned __int8)v7 == 254LL )
  {
    if ( v7 >> 9 <= 1 )
    {
LABEL_21:
      caml_ml_array_bound_error(v8, v4);
      goto LABEL_22;
    }
    *v6 = *(unsigned __int64 *)v15;
LABEL_6:
    v9 = *(v6 - 1);
    v8 = (unsigned __int8)v9;
    if ( (unsigned __int8)v9 == 254LL )
    {
      if ( v9 >> 9 <= 3 )
      {
LABEL_19:
        caml_ml_array_bound_error(v8, v4);
        goto LABEL_20;
      }
      v6[1] = *(unsigned __int64 *)v14;
    }
    else
    {
      if ( v9 >> 9 <= 3 )
      {
LABEL_20:
        caml_ml_array_bound_error(v8, v4);
        goto LABEL_21;
      }
      v4 = (unsigned __int64)v14;
      caml_modify(v6 + 1, (unsigned __int64)v14);
    }
    v10 = *(v6 - 1);
    v8 = (unsigned __int8)v10;
    if ( (unsigned __int8)v10 == 254LL )
    {
      if ( v10 >> 9 > 5 )
      {
        v6[2] = *(unsigned __int64 *)a1;
        return caml_apply2(*(_QWORD *)(a2 + 24));
      }
      caml_ml_array_bound_error(254LL, v4);
    }
    else if ( v10 >> 9 > 5 )
    {
      caml_modify(v6 + 2, (unsigned __int64)a1);
      return caml_apply2(*(_QWORD *)(a2 + 24));
    }
    caml_ml_array_bound_error(v8, v4);
    goto LABEL_19;
  }
  if ( v7 >> 9 > 1 )
  {
    v4 = (unsigned __int64)v15;
    caml_modify(v6, (unsigned __int64)v15);
    goto LABEL_6;
  }
LABEL_22:
  caml_ml_array_bound_error(v8, v4);
  return camlPrintf__fun_604(v8);
}
// 41F6B4: variable 'v2' is possibly undefined
// 41F6B9: variable 'v3' is possibly undefined
// 41F6E1: variable 'v5' is possibly undefined

//----- (000000000041F810) ----------------------------------------------------
__int64 __fastcall camlPrintf__fun_604(__int64 a1)
{
  double *v1; // rax
  double *v2; // rbx
  unsigned __int64 v3; // rsi
  unsigned __int64 *v4; // rax
  unsigned __int64 *v5; // rbx
  unsigned __int64 v6; // rax
  __int64 v7; // rdi
  unsigned __int64 v8; // rax
  double *v11; // [rsp+8h] [rbp-10h]
  double *v12; // [rsp+10h] [rbp-8h]

  v12 = v1;
  v11 = v2;
  v3 = 1LL;
  caml_c_call(5LL, 1uLL);
  v5 = v4;
  v6 = *(v4 - 1);
  v7 = (unsigned __int8)v6;
  if ( (unsigned __int8)v6 == 254LL )
  {
    if ( v6 >> 9 <= 1 )
    {
LABEL_14:
      caml_ml_array_bound_error(v7, v3);
      goto LABEL_15;
    }
    *v5 = *(unsigned __int64 *)v12;
LABEL_6:
    v8 = *(v5 - 1);
    v7 = (unsigned __int8)v8;
    if ( (unsigned __int8)v8 == 254LL )
    {
      if ( v8 >> 9 > 3 )
      {
        v5[1] = *(unsigned __int64 *)v11;
        return caml_apply2(*(_QWORD *)(a1 + 24));
      }
      caml_ml_array_bound_error(254LL, v3);
    }
    else if ( v8 >> 9 > 3 )
    {
      caml_modify(v5 + 1, (unsigned __int64)v11);
      return caml_apply2(*(_QWORD *)(a1 + 24));
    }
    caml_ml_array_bound_error(v7, v3);
    goto LABEL_14;
  }
  if ( v6 >> 9 > 1 )
  {
    v3 = (unsigned __int64)v12;
    caml_modify(v5, (unsigned __int64)v12);
    goto LABEL_6;
  }
LABEL_15:
  caml_ml_array_bound_error(v7, v3);
  return camlPrintf__fun_601();
}
// 41F814: variable 'v1' is possibly undefined
// 41F819: variable 'v2' is possibly undefined
// 41F83C: variable 'v4' is possibly undefined

//----- (000000000041F910) ----------------------------------------------------
__int64 __fastcall camlPrintf__fun_601()
{
  double *v0; // rax
  __int64 v1; // rbx
  unsigned __int64 *v2; // rax
  unsigned __int64 *v3; // rbx
  unsigned __int64 v4; // rax
  __int64 v5; // rdi
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // [rsp+0h] [rbp-18h]
  double *v12; // [rsp+8h] [rbp-10h]

  v12 = v0;
  v11 = v1;
  caml_c_call(3LL, 1uLL);
  v3 = v2;
  v4 = *(v2 - 1);
  v5 = (unsigned __int8)v4;
  if ( (unsigned __int8)v4 == 254LL )
  {
    if ( v4 >> 9 > 1 )
    {
      *v3 = *(unsigned __int64 *)v12;
      return caml_apply2(*(_QWORD *)(v11 + 16));
    }
    caml_ml_array_bound_error(254LL, 1uLL);
  }
  else if ( v4 >> 9 > 1 )
  {
    caml_modify(v3, (unsigned __int64)v12);
    return caml_apply2(*(_QWORD *)(v11 + 16));
  }
  caml_ml_array_bound_error(v5, 1uLL);
  return camlPrintf__get_int_literal_286(v5, 1LL, v7, v8, v9, v10);
}
// 41F914: variable 'v0' is possibly undefined
// 41F919: variable 'v1' is possibly undefined
// 41F937: variable 'v2' is possibly undefined
// 41F9A3: variable 'v7' is possibly undefined
// 41F9A3: variable 'v8' is possibly undefined
// 41F9A3: variable 'v9' is possibly undefined
// 41F9A3: variable 'v10' is possibly undefined

//----- (000000000041F9B0) ----------------------------------------------------
__int64 __fastcall camlPrintf__get_int_literal_286(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rsi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rbx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // [rsp+0h] [rbp-18h]

  while ( 1 )
  {
    v9 = 2LL * *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + (v7 >> 1)) + 1;
    if ( v9 < 97 )
      break;
    if ( v9 >= 117 )
      return caml_apply2(*(_QWORD *)(a1 + 32));
    v7 += 2LL;
    v6 = 20 * (v6 >> 1) + v9 - 96;
  }
  if ( 2LL * *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + (v7 >> 1)) != 72 )
    return caml_apply2(*(_QWORD *)(a1 + 32));
  if ( v6 == 1 )
    camlPervasives__failwith_38(a1, 73LL, v7 >> 1, a4, a5, a6);
  v16 = a1;
  v12 = camlPrintf__index_of_int_65(a1, 73LL);
  while ( 1 )
  {
    v8 -= 2;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(a1, 73LL, v10, v11, v13, v14, v16);
  }
  *v8 = 1024LL;
  v8[1] = v12;
  return caml_apply2(*(_QWORD *)(v16 + 32));
}
// 41F9B7: variable 'v7' is possibly undefined
// 41F9DC: variable 'v6' is possibly undefined
// 41FA1D: variable 'v8' is possibly undefined
// 41FA40: variable 'v16' is possibly undefined
// 41FA77: variable 'v10' is possibly undefined
// 41FA77: variable 'v11' is possibly undefined
// 41FA77: variable 'v13' is possibly undefined
// 41FA77: variable 'v14' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041FA80) ----------------------------------------------------
__int64 camlPrintf__add_dot_302()
{
  return camlPervasives___5e_136();
}

//----- (000000000041FA90) ----------------------------------------------------
__int64 __fastcall camlPrintf__loop_305()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v3; // rcx
  __int64 v4; // rdi
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rdi
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9

  while ( 1 )
  {
    if ( v0 >= *(_QWORD *)(v1 + 32) )
      return camlPrintf__add_dot_302();
    v3 = *(_QWORD *)(v1 + 24);
    v4 = 8LL * (*(_QWORD *)(v3 - 8) >> 10) - 1;
    v5 = *(unsigned __int8 *)(v3 + v4);
    v6 = v4 - v5;
    if ( v6 <= v0 >> 1 )
      break;
    if ( 2LL * *(unsigned __int8 *)(v3 + (v0 >> 1)) == 92 )
      return *(_QWORD *)(v1 + 24);
    v0 += 2LL;
  }
  caml_ml_array_bound_error(v6, v5);
  return camlPrintf__get_arg_320(v6, v5, v7, v8, v9, v10);
}
// 41FA97: variable 'v0' is possibly undefined
// 41FA90: variable 'v1' is possibly undefined
// 41FAF7: variable 'v7' is possibly undefined
// 41FAF7: variable 'v8' is possibly undefined
// 41FAF7: variable 'v9' is possibly undefined
// 41FAF7: variable 'v10' is possibly undefined

//----- (000000000041FB00) ----------------------------------------------------
__int64 __fastcall camlPrintf__get_arg_320(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 *v6; // rax
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rax
  __int64 v11; // rdi
  __int64 result; // rax
  __int64 *v13; // rdx
  char v14; // [rsp+0h] [rbp-8h]

  if ( v6 != (unsigned __int64 *)1 )
    v7 = *v6;
  v9 = *(_QWORD *)(a1 + 24);
  v10 = *(_QWORD *)(v9 - 8);
  v11 = (unsigned __int8)v10;
  if ( (unsigned __int8)v10 != 254LL )
  {
    if ( v10 >> 9 > v7 )
      return *(_QWORD *)(v9 + 4 * v7 - 4);
    goto LABEL_11;
  }
  if ( v10 >> 9 <= v7 )
  {
    caml_ml_array_bound_error(254LL, v9);
LABEL_11:
    caml_ml_array_bound_error(v11, v9);
    return camlPrintf__scan_conv_325(v11, v9, v13);
  }
  while ( 1 )
  {
    v8 -= 16LL;
    if ( v8 >= caml_young_limit )
      break;
    caml_call_gc(254LL, v9, a3, a4, a5, a6, v14);
  }
  result = v8 + 8;
  *(_QWORD *)v8 = 1277LL;
  *(double *)(v8 + 8) = *(double *)(v9 + 4 * v7 - 4);
  return result;
}
// 41FB08: variable 'v6' is possibly undefined
// 41FB2F: variable 'v7' is possibly undefined
// 41FB45: variable 'v8' is possibly undefined
// 41FB70: variable 'a3' is possibly undefined
// 41FB70: variable 'a4' is possibly undefined
// 41FB70: variable 'a5' is possibly undefined
// 41FB70: variable 'a6' is possibly undefined
// 41FB70: variable 'v14' is possibly undefined
// 41FB82: variable 'v13' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000041FB90) ----------------------------------------------------
__int64 __fastcall camlPrintf__scan_conv_325(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 v3; // rax
  __int64 v4; // r8
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v9; // rdi
  __int64 result; // rax
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdi
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // rdi
  __int64 v28; // rcx
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // rax
  __int64 v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // r8
  __int64 v35; // r9
  __int64 format_113; // rax
  __int64 v37; // rdx
  __int64 v38; // rax
  __int64 v39; // rcx
  __int64 v40; // r8
  __int64 v41; // r9
  __int64 format_int_131; // rax
  __int64 v43; // rdx
  __int64 v44; // rcx
  __int64 v45; // r8
  __int64 v46; // r9
  __int64 v47; // rax
  __int64 v48; // rdi
  __int64 v49; // [rsp+0h] [rbp-38h]
  __int64 v50; // [rsp+0h] [rbp-38h]
  __int64 arg_320; // [rsp+0h] [rbp-38h]
  __int64 v52; // [rsp+0h] [rbp-38h]
  __int64 v53; // [rsp+0h] [rbp-38h]
  __int64 v54; // [rsp+8h] [rbp-30h]
  __int64 v55; // [rsp+8h] [rbp-30h]
  __int64 v56; // [rsp+8h] [rbp-30h]
  unsigned __int64 v57; // [rsp+10h] [rbp-28h]
  __int64 v58; // [rsp+18h] [rbp-20h]
  __int64 v59; // [rsp+20h] [rbp-18h]
  __int64 *v60; // [rsp+30h] [rbp-8h]

  v4 = v3;
  v7 = a2 >> 1;
  v8 = *(unsigned __int8 *)(a3[3] + (a2 >> 1));
  v9 = 2 * v8 + 1;
  if ( v9 >= 249 )
LABEL_16:
    camlPrintf__bad_conversion_format_89(v9, a2, v7, (__int64)a3, v4, a1);
  v49 = 2 * v8 + 1;
  v60 = a3;
  v57 = a1;
  v59 = v4;
  switch ( v9 >> 1 )
  {
    case 0LL:
    case 1LL:
    case 2LL:
    case 3LL:
    case 4LL:
    case 5LL:
    case 6LL:
    case 7LL:
    case 8LL:
    case 9LL:
    case 10LL:
    case 11LL:
    case 12LL:
    case 13LL:
    case 14LL:
    case 15LL:
    case 16LL:
    case 17LL:
    case 18LL:
    case 19LL:
    case 20LL:
    case 21LL:
    case 22LL:
    case 23LL:
    case 24LL:
    case 25LL:
    case 26LL:
    case 27LL:
    case 28LL:
    case 29LL:
    case 30LL:
    case 31LL:
    case 32LL:
    case 34LL:
    case 35LL:
    case 36LL:
    case 38LL:
    case 39LL:
    case 42LL:
    case 43LL:
    case 45LL:
    case 46LL:
    case 47LL:
    case 48LL:
    case 49LL:
    case 50LL:
    case 51LL:
    case 52LL:
    case 53LL:
    case 54LL:
    case 55LL:
    case 56LL:
    case 57LL:
    case 58LL:
    case 59LL:
    case 60LL:
    case 61LL:
    case 62LL:
    case 63LL:
    case 64LL:
    case 65LL:
    case 68LL:
    case 72LL:
    case 73LL:
    case 74LL:
    case 75LL:
    case 77LL:
    case 79LL:
    case 80LL:
    case 81LL:
    case 82LL:
    case 84LL:
    case 85LL:
    case 86LL:
    case 87LL:
    case 89LL:
    case 90LL:
    case 91LL:
    case 92LL:
    case 93LL:
    case 94LL:
    case 95LL:
    case 96LL:
    case 104LL:
    case 106LL:
    case 107LL:
    case 109LL:
    case 112LL:
    case 113LL:
    case 114LL:
    case 118LL:
    case 119LL:
    case 121LL:
    case 122LL:
      goto LABEL_16;
    case 33LL:
      return caml_apply2(a3[8]);
    case 37LL:
    case 41LL:
    case 44LL:
      return caml_apply3(a2 + 2, a3[5]);
    case 40LL:
    case 123LL:
      v56 = 2 * v8 + 1;
      camlPrintf__get_arg_320(a3[10], a2, v7, (__int64)a3, v4, a1);
      v48 = camlPrintf__sub_format_for_printf_163();
      v58 = caml_apply2(v48);
      if ( v56 == 247 )
      {
        camlPrintf__summarize_format_type_190(v48, a2);
        if ( v59 == 1 )
          (**(void (***)(void))(camlPrintf[11] + 16LL))();
        return caml_apply3(v58, v60[5]);
      }
      else
      {
        if ( v59 == 1 )
          (**(void (***)(void))(camlPrintf[11] + 16LL))();
        return caml_apply3(v58, v60[9]);
      }
    case 66LL:
    case 98LL:
      camlPrintf__get_arg_320(a3[10], a2, v7, (__int64)a3, v4, a1);
      camlPervasives__string_of_bool_151();
      if ( v59 == 1 )
        goto LABEL_40;
      goto LABEL_41;
    case 67LL:
    case 99LL:
      v50 = 2 * v8 + 1;
      v27 = a3[10];
      camlPrintf__get_arg_320(v27, a2, v7, (__int64)a3, v4, a1);
      if ( v50 == 199 )
      {
        camlString__make_66(v27, a2);
      }
      else
      {
        camlChar__escaped_66(v27, a2);
        camlPervasives___5e_136();
        camlPervasives___5e_136();
      }
      if ( v59 == 1 )
        goto LABEL_40;
      goto LABEL_41;
    case 69LL:
    case 71LL:
    case 101LL:
    case 102LL:
    case 103LL:
      arg_320 = camlPrintf__get_arg_320(a3[10], a2, v7, (__int64)a3, v4, a1);
      format_113 = camlPrintf__extract_format_113(a2, v57, v32, v33, v34, v35);
      caml_c_call(format_113, arg_320);
      if ( v59 == 1 )
        goto LABEL_40;
      goto LABEL_41;
    case 70LL:
      camlPrintf__get_arg_320(a3[10], a2, v7, (__int64)a3, v4, a1);
      if ( v57 == 1 )
      {
        camlPervasives__string_of_float_164();
      }
      else
      {
        camlPrintf__extract_format_float_138(v60[4], a2, v57, v11, v12, v13);
        camlPrintf__fun_630();
      }
      if ( v59 == 1 )
        goto LABEL_40;
      goto LABEL_41;
    case 76LL:
    case 108LL:
    case 110LL:
      v37 = (a2 + 2) >> 1;
      v38 = 2LL * *(unsigned __int8 *)(a3[3] + v37) - 175;
      if ( (unsigned __int64)v38 > 0x41 )
      {
LABEL_36:
        v52 = camlPrintf__get_arg_320(a3[10], a2, v37, (__int64)a3, v4, a1);
        format_int_131 = camlPrintf__extract_format_int_131(v60[4], a2, v57, v39, v40, v41);
        caml_c_call(format_int_131, v52);
        if ( v59 == 1 )
          (**(void (***)(void))(camlPrintf[11] + 16LL))();
      }
      else
      {
        switch ( v38 >> 1 )
        {
          case 0LL:
          case 12LL:
          case 17LL:
          case 23LL:
          case 29LL:
          case 32LL:
            a2 += 2LL;
            v53 = camlPrintf__get_arg_320(a3[10], a2, v37, (__int64)a3, v4, a1);
            v47 = camlPrintf__extract_format_113(a2, v57, v43, v44, v45, v46);
            caml_c_call(v47, v53);
            if ( v59 == 1 )
              goto LABEL_40;
            break;
          case 1LL:
          case 2LL:
          case 3LL:
          case 4LL:
          case 5LL:
          case 6LL:
          case 7LL:
          case 8LL:
          case 9LL:
          case 10LL:
          case 11LL:
          case 13LL:
          case 14LL:
          case 15LL:
          case 16LL:
          case 18LL:
          case 19LL:
          case 20LL:
          case 21LL:
          case 22LL:
          case 24LL:
          case 25LL:
          case 26LL:
          case 27LL:
          case 28LL:
          case 30LL:
          case 31LL:
            goto LABEL_36;
        }
      }
      goto LABEL_41;
    case 78LL:
    case 88LL:
    case 100LL:
    case 105LL:
    case 111LL:
    case 117LL:
    case 120LL:
      v55 = camlPrintf__get_arg_320(a3[10], a2, v7, (__int64)a3, v4, a1);
      v31 = camlPrintf__extract_format_int_131(v60[4], a2, v57, v28, v29, v30);
      caml_c_call(v31, v55);
      if ( v59 == 1 )
        goto LABEL_40;
      goto LABEL_41;
    case 83LL:
    case 115LL:
      v18 = a3[10];
      camlPrintf__get_arg_320(v18, a2, v7, (__int64)a3, v4, a1);
      if ( v49 != 231 )
      {
        camlString__escaped_108(v18, a2, v19, v20, v21, v22);
        camlPervasives___5e_136();
        camlPervasives___5e_136();
      }
      if ( a2 != v60[4] + 2 )
      {
        camlPrintf__extract_format_113(a2, v57, v19, v20, v21, v22);
        camlPrintf__format_string_108(a2, v57, v23, v24, v25, v26);
      }
      if ( v59 == 1 )
LABEL_40:
        (**(void (***)(void))(camlPrintf[11] + 16LL))();
LABEL_41:
      result = caml_apply3(a2 + 2, v60[5]);
      break;
    case 97LL:
      camlPrintf__get_arg_320(a3[10], a2, v7, (__int64)a3, v4, a1);
      (**(void (***)(void))(camlPrintf[11] + 16LL))();
      v54 = camlPrintf__get_arg_320(v60[10], a2, v14, v15, v16, v17);
      if ( v59 == 1 )
        (**(void (***)(void))(camlPrintf[11] + 16LL))();
      result = caml_apply4(v54, a2 + 2, v60[6]);
      break;
    case 116LL:
      camlPrintf__get_arg_320(a3[10], a2, v7, (__int64)a3, v4, a1);
      if ( v59 == 1 )
        (**(void (***)(void))(camlPrintf[11] + 16LL))();
      result = caml_apply3(a2 + 2, v60[7]);
      break;
  }
  return result;
}
// 41FB94: variable 'v3' is possibly undefined
// 41FCBA: variable 'v11' is possibly undefined
// 41FCBA: variable 'v12' is possibly undefined
// 41FCBA: variable 'v13' is possibly undefined
// 41FD6A: variable 'v14' is possibly undefined
// 41FD6A: variable 'v15' is possibly undefined
// 41FD6A: variable 'v16' is possibly undefined
// 41FD6A: variable 'v17' is possibly undefined
// 41FE50: variable 'v19' is possibly undefined
// 41FE50: variable 'v20' is possibly undefined
// 41FE50: variable 'v21' is possibly undefined
// 41FE50: variable 'v22' is possibly undefined
// 41FEAA: variable 'v23' is possibly undefined
// 41FEAA: variable 'v24' is possibly undefined
// 41FEAA: variable 'v25' is possibly undefined
// 41FEAA: variable 'v26' is possibly undefined
// 41FFD8: variable 'v28' is possibly undefined
// 41FFD8: variable 'v29' is possibly undefined
// 41FFD8: variable 'v30' is possibly undefined
// 420067: variable 'v32' is possibly undefined
// 420067: variable 'v33' is possibly undefined
// 420067: variable 'v34' is possibly undefined
// 420067: variable 'v35' is possibly undefined
// 420196: variable 'v39' is possibly undefined
// 420196: variable 'v40' is possibly undefined
// 420196: variable 'v41' is possibly undefined
// 4202DF: variable 'v43' is possibly undefined
// 4202DF: variable 'v44' is possibly undefined
// 4202DF: variable 'v45' is possibly undefined
// 4202DF: variable 'v46' is possibly undefined
// 653BE0: using guessed type _QWORD camlPrintf[40];

//----- (0000000000420440) ----------------------------------------------------
__int64 __fastcall camlPrintf__scan_flags_324(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  _QWORD *v5; // r15
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  while ( 2 )
  {
    v6 = v3;
    v7 = v4;
    v8 = a3;
    v9 = 2LL * *(unsigned __int8 *)(*(_QWORD *)(a3 + 56) + (a2 >> 1)) - 63;
    if ( (unsigned __int64)v9 > 0x33 )
      return camlPrintf__scan_conv_325(a1, a2, (__int64 *)(a3 + 32));
    switch ( v9 >> 1 )
    {
      case 0LL:
      case 3LL:
      case 11LL:
      case 13LL:
      case 14LL:
      case 16LL:
      case 17LL:
      case 18LL:
      case 19LL:
      case 20LL:
      case 21LL:
      case 22LL:
      case 23LL:
      case 24LL:
      case 25LL:
        a2 += 2LL;
        v3 = v6;
        continue;
      case 1LL:
      case 2LL:
      case 4LL:
      case 5LL:
      case 6LL:
      case 7LL:
      case 8LL:
      case 9LL:
      case 12LL:
      case 15LL:
        return camlPrintf__scan_conv_325(a1, a2, (__int64 *)(a3 + 32));
      case 10LL:
        while ( 1 )
        {
          v5 -= 9;
          if ( (unsigned __int64)v5 >= caml_young_limit )
            break;
          caml_call_gc(a1, a2, a3, v8, v6, v7, v11);
        }
        *v5 = 8439LL;
        v5[1] = caml_curry2;
        v5[2] = 5LL;
        v5[3] = camlPrintf__got_spec_336;
        v5[4] = *(_QWORD *)(v8 + 112);
        v5[5] = v8;
        v5[6] = v6;
        v5[7] = v7;
        v5[8] = a1;
        result = camlPrintf__scan_positional_spec_280(v7, a2 + 2, a3, v8, v6);
        break;
    }
    break;
  }
  return result;
}
// 420444: variable 'v3' is possibly undefined
// 420447: variable 'v4' is possibly undefined
// 420484: variable 'v5' is possibly undefined
// 4204C1: variable 'v8' is possibly undefined
// 4204CD: variable 'v6' is possibly undefined
// 4204D1: variable 'v7' is possibly undefined
// 4204E8: variable 'a3' is possibly undefined
// 42051A: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000420530) ----------------------------------------------------
__int64 __fastcall camlPrintf__scan_positional_323(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // r8
  __int64 v10; // rcx
  __int64 i; // rdx
  char v13; // [rsp+0h] [rbp-8h]

  v9 = v6;
  v10 = v7;
  for ( i = a1; ; caml_call_gc(a1, a2, i, v10, v9, a6, v13) )
  {
    v8 -= 7;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 6391LL;
  v8[1] = caml_curry2;
  v8[2] = 5LL;
  v8[3] = camlPrintf__got_spec_329;
  v8[4] = a2 + 32;
  v8[5] = v9;
  v8[6] = v10;
  return camlPrintf__scan_positional_spec_280(v9, i, i, v10, v9);
}
// 420534: variable 'v6' is possibly undefined
// 420537: variable 'v7' is possibly undefined
// 42053D: variable 'v8' is possibly undefined
// 420581: variable 'v9' is possibly undefined
// 420585: variable 'v10' is possibly undefined
// 420597: variable 'i' is possibly undefined
// 42059C: variable 'a6' is possibly undefined
// 42059C: variable 'v13' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004205B0) ----------------------------------------------------
__int64 __fastcall camlPrintf__pr_386(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // rax
  _QWORD *v4; // r15
  __int64 v5; // r9
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rdi
  __int64 i; // r8
  char v11; // [rsp+0h] [rbp-8h]

  v5 = v3;
  v6 = a1;
  v7 = 8LL * (*(_QWORD *)(a1 - 8) >> 10) - 1;
  v8 = *(unsigned __int8 *)(a1 + v7);
  for ( i = 2 * (v7 - v8) + 1; ; caml_call_gc(v8, a2, (__int64)a3, v6, i, v5, v11) )
  {
    v4 -= 34;
    if ( (unsigned __int64)v4 >= caml_young_limit )
      break;
  }
  *v4 = 34039LL;
  v4[1] = caml_curry2;
  v4[2] = 5LL;
  v4[3] = camlPrintf__doprn_392;
  v4[4] = 4345LL;
  v4[5] = caml_curry3;
  v4[6] = 7LL;
  v4[7] = camlPrintf__cont_s_393;
  v4[8] = 8441LL;
  v4[9] = caml_curry4;
  v4[10] = 9LL;
  v4[11] = camlPrintf__cont_a_394;
  v4[12] = 12537LL;
  v4[13] = caml_curry3;
  v4[14] = 7LL;
  v4[15] = camlPrintf__cont_t_395;
  v4[16] = 16633LL;
  v4[17] = caml_curry2;
  v4[18] = 5LL;
  v4[19] = camlPrintf__cont_f_396;
  v4[20] = 20729LL;
  v4[21] = caml_curry3;
  v4[22] = 7LL;
  v4[23] = camlPrintf__cont_m_397;
  v4[24] = a3[3];
  v4[25] = a3[4];
  v4[26] = a3[5];
  v4[27] = a3[6];
  v4[28] = a3[7];
  v4[29] = a3;
  v4[30] = v5;
  v4[31] = v6;
  v4[32] = a2;
  v4[33] = i;
  return camlPrintf__doprn_392((__int64)(v4 + 1));
}
// 4205B4: variable 'v3' is possibly undefined
// 4205D7: variable 'v4' is possibly undefined
// 4206EA: variable 'a3' is possibly undefined
// 420728: variable 'v5' is possibly undefined
// 42072F: variable 'v6' is possibly undefined
// 42073D: variable 'i' is possibly undefined
// 42075A: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000420770) ----------------------------------------------------
__int64 __fastcall camlPrintf__fun_710()
{
  __int64 v0; // rbx

  return *(_QWORD *)(v0 + 16);
}
// 420770: variable 'v0' is possibly undefined
// 420770: using guessed type __int64 __fastcall camlPrintf__fun_710();

//----- (0000000000420780) ----------------------------------------------------
__int64 (__fastcall **camlPrintf__fun_714())()
{
  return &camlPrintf__56;
}
// 654210: using guessed type __int64 (__fastcall *camlPrintf__56)();

//----- (0000000000420790) ----------------------------------------------------
__int64 camlPrintf__fun_719()
{
  return 1LL;
}
// 420790: using guessed type __int64 __fastcall camlPrintf__fun_719();

//----- (00000000004207A0) ----------------------------------------------------
__int64 camlPrintf__fun_727()
{
  return 1LL;
}
// 4207A0: using guessed type __int64 __fastcall camlPrintf__fun_727();

//----- (00000000004207B0) ----------------------------------------------------
__int64 __fastcall camlPrintf__fun_724()
{
  __int64 v0; // rbx

  return *(_QWORD *)(v0 + 16);
}
// 4207B0: variable 'v0' is possibly undefined
// 4207B0: using guessed type __int64 __fastcall camlPrintf__fun_724();

//----- (00000000004207C0) ----------------------------------------------------
__int64 camlPrintf__fun_730()
{
  return 1LL;
}
// 4207C0: using guessed type __int64 __fastcall camlPrintf__fun_730();

//----- (00000000004207D0) ----------------------------------------------------
__int64 camlPrintf__fun_737()
{
  return 1LL;
}
// 4207D0: using guessed type __int64 __fastcall camlPrintf__fun_737();

//----- (00000000004207F0) ----------------------------------------------------
__int64 __fastcall camlPrintf__index_of_int_65(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9

  if ( result < 1 )
  {
    camlPervasives__string_of_int_154();
    camlPervasives___5e_136();
    camlPervasives__failwith_38(a1, a2, v3, v4, v5, v6);
  }
  return result;
}
// 4207F8: variable 'result' is possibly undefined
// 420818: variable 'v3' is possibly undefined
// 420818: variable 'v4' is possibly undefined
// 420818: variable 'v5' is possibly undefined
// 420818: variable 'v6' is possibly undefined

//----- (0000000000420820) ----------------------------------------------------
__int64 __fastcall camlPrintf__add_int_index_68(__int64 a1, __int64 a2)
{
  return camlPrintf__index_of_int_65(a1, a2);
}

//----- (0000000000420830) ----------------------------------------------------
__int64 __fastcall camlPrintf__index_of_literal_position_72(__int64 a1, __int64 a2)
{
  return camlPrintf__index_of_int_65(a1, a2);
}

//----- (0000000000420850) ----------------------------------------------------
__int64 __fastcall camlPrintf__to_string_82(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx

  v7 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1;
  return camlString__sub_74(2 * (v7 - *(unsigned __int8 *)(v6 + v7)) + 1, a2, a3, a4, a5, a6);
}
// 420850: variable 'v6' is possibly undefined

//----- (0000000000420880) ----------------------------------------------------
void __fastcall __noreturn camlPrintf__bad_conversion_85(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9

  camlPervasives___5e_136();
  camlPervasives___5e_136();
  camlPervasives__string_of_int_154();
  camlPervasives___5e_136();
  camlPervasives___5e_136();
  camlString__make_66(a1, a2);
  camlPervasives___5e_136();
  camlPervasives___5e_136();
  camlPervasives__invalid_arg_40(a1, a2, v2, v3, v4, v5);
}
// 420900: variable 'v2' is possibly undefined
// 420900: variable 'v3' is possibly undefined
// 420900: variable 'v4' is possibly undefined
// 420900: variable 'v5' is possibly undefined

//----- (0000000000420910) ----------------------------------------------------
void __fastcall __noreturn camlPrintf__bad_conversion_format_89(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx

  v7 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1;
  camlString__sub_74(2 * (v7 - *(unsigned __int8 *)(v6 + v7)) + 1, a2, a3, a4, a5, a6);
  camlPrintf__bad_conversion_85(a1, a2);
}
// 42091D: variable 'v6' is possibly undefined

//----- (0000000000420960) ----------------------------------------------------
void __fastcall __noreturn camlPrintf__incomplete_format_93(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9

  v7 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1;
  v8 = 2 * (v7 - *(unsigned __int8 *)(v6 + v7)) + 1;
  camlString__sub_74(v8, a2, a3, a4, a5, a6);
  camlPervasives___5e_136();
  camlPervasives___5e_136();
  camlPervasives__invalid_arg_40(v8, a2, v9, v10, v11, v12);
}
// 420964: variable 'v6' is possibly undefined
// 4209AC: variable 'v9' is possibly undefined
// 4209AC: variable 'v10' is possibly undefined
// 4209AC: variable 'v11' is possibly undefined
// 4209AC: variable 'v12' is possibly undefined

//----- (00000000004209C0) ----------------------------------------------------
_QWORD *__fastcall camlPrintf__parse_string_conversion_95(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rbx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  char i; // [rsp+0h] [rbp-8h]

  v8 = v6;
  for ( i = v6; ; caml_call_gc(a1, a2, a3, a4, a5, a6, i) )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 4343LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlPrintf__parse_97;
  v7[4] = v8;
  if ( (char **)*sub_420A44((__int64)(v7 + 1), a2, a3, a4, a5, a6) == &caml_exn_Failure )
    camlPrintf__bad_conversion_85(231LL, a2);
  caml_raise_exn();
  return sub_420A44((__int64)&caml_exn_Failure, a2, v9, v10, v11, v12);
}
// 4209C4: variable 'v6' is possibly undefined
// 4209CB: variable 'v7' is possibly undefined
// 420A0C: variable 'a3' is possibly undefined
// 420A0C: variable 'a4' is possibly undefined
// 420A0C: variable 'a5' is possibly undefined
// 420A0C: variable 'a6' is possibly undefined
// 420A42: variable 'v9' is possibly undefined
// 420A42: variable 'v10' is possibly undefined
// 420A42: variable 'v11' is possibly undefined
// 420A42: variable 'v12' is possibly undefined
// 420A67: variable 'i' is possibly undefined
// 647A80: using guessed type char *caml_exn_Failure;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000420A44) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
_QWORD *__fastcall sub_420A44(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return camlPrintf__parse_97(a1, a2, a3, a4, a5, a6);
}
// 420A66: positive sp value 10 has been found

//----- (0000000000420A80) ----------------------------------------------------
unsigned __int64 __fastcall camlPrintf__pad_string_100(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 _66; // rdi

  if ( v7 == a4 && a3 == 1 )
    return a2;
  if ( v7 <= a4 )
    return camlString__sub_74(a4, a2, a3, a4, v6, a6);
  _66 = camlString__make_66(a1, a2);
  if ( a1 == 1 )
    camlString__blit_84(_66, v7 - a4 + 1, a4);
  else
    camlString__blit_84(_66, 1LL, a4);
  return _66;
}
// 420A8A: variable 'v7' is possibly undefined
// 420AAE: variable 'v6' is possibly undefined

//----- (0000000000420B40) ----------------------------------------------------
unsigned __int64 __fastcall camlPrintf__format_string_108(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned __int64 v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v10; // r9

  v7 = camlPrintf__parse_string_conversion_95(a1, a2, a3, a4, a5, a6)[1];
  v8 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1;
  return camlPrintf__pad_string_100(v7, v6, 1LL, 2 * (v8 - *(unsigned __int8 *)(v6 + v8)) + 1, v9, v10);
}
// 420B58: variable 'v6' is possibly undefined
// 420B87: variable 'v9' is possibly undefined
// 420B87: variable 'v10' is possibly undefined

//----- (0000000000420B90) ----------------------------------------------------
__int64 __fastcall camlPrintf__extract_format_113(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rdx
  __int64 v9; // rdi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 i; // [rsp+0h] [rbp-38h]
  _QWORD *v29; // [rsp+10h] [rbp-28h]
  _QWORD *_67; // [rsp+30h] [rbp-8h]

  v8 = v6;
  for ( i = v6; ; caml_call_gc(a1, a2, v8, a4, a5, a6, i) )
  {
    v7 -= 4;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  v9 = (__int64)(v7 + 1);
  v29 = v7 + 1;
  *v7 = 3319LL;
  v7[1] = camlPrintf__skip_positional_spec_118;
  v7[2] = 3LL;
  v7[3] = v8;
  camlPrintf__skip_positional_spec_118((__int64)(v7 + 1), a2, v8, a4, a5, a6);
  _67 = camlBuffer__create_67((__int64)(v7 + 1), a2);
  camlBuffer__add_char_100((__int64)(v7 + 1), a2, v10, v11, v12, v13);
  while ( 1 )
  {
    v7 -= 8;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc(v9, a2, v14, v15, v16, v17, i);
  }
  *v7 = 7415LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlPrintf__fill_format_124;
  v7[4] = i;
  v7[5] = a1;
  v7[6] = v29;
  v7[7] = _67;
  camlList__rev_append_79(v9, a2, v14, v15, v16, v17);
  camlPrintf__fill_format_124((__int64)(v7 + 1), a2, v18, v19, v20, v21);
  return camlString__sub_74(_67[1], a2, v22, v23, v24, v25);
}
// 420B94: variable 'v6' is possibly undefined
// 420BA5: variable 'v7' is possibly undefined
// 420BDC: variable 'v8' is possibly undefined
// 420BEA: variable 'a4' is possibly undefined
// 420BEA: variable 'a5' is possibly undefined
// 420BEA: variable 'a6' is possibly undefined
// 420C14: variable 'v10' is possibly undefined
// 420C14: variable 'v11' is possibly undefined
// 420C14: variable 'v12' is possibly undefined
// 420C14: variable 'v13' is possibly undefined
// 420C5F: variable 'i' is possibly undefined
// 420C8A: variable 'v14' is possibly undefined
// 420C8A: variable 'v15' is possibly undefined
// 420C8A: variable 'v16' is possibly undefined
// 420C8A: variable 'v17' is possibly undefined
// 420C9C: variable 'v18' is possibly undefined
// 420C9C: variable 'v19' is possibly undefined
// 420C9C: variable 'v20' is possibly undefined
// 420C9C: variable 'v21' is possibly undefined
// 420CB8: variable 'v22' is possibly undefined
// 420CB8: variable 'v23' is possibly undefined
// 420CB8: variable 'v24' is possibly undefined
// 420CB8: variable 'v25' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000420CE0) ----------------------------------------------------
__int64 __fastcall camlPrintf__extract_format_int_131(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rbx
  unsigned __int64 v9; // rsi
  __int64 v10; // rdi
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // [rsp+0h] [rbp-8h]

  v15 = v6;
  result = camlPrintf__extract_format_113(a2, a3, a3, a4, a5, a6);
  if ( v15 == 157 || v15 == 221 )
  {
    v8 = 8LL * (*(_QWORD *)(result - 8) >> 10) - 1;
    v9 = (2 * (v8 - *(unsigned __int8 *)(result + v8)) - 1) >> 1;
    v10 = *(unsigned __int8 *)(result + v8);
    if ( v8 - v10 <= v9 )
    {
      caml_ml_array_bound_error(v10, v9);
      return camlPrintf__extract_format_float_138(v10, v9, v11, v12, v13, v14);
    }
    else
    {
      *(_BYTE *)(result + v9) = 117;
    }
  }
  return result;
}
// 420CE4: variable 'v6' is possibly undefined
// 420D66: variable 'v11' is possibly undefined
// 420D66: variable 'v12' is possibly undefined
// 420D66: variable 'v13' is possibly undefined
// 420D66: variable 'v14' is possibly undefined

//----- (0000000000420D70) ----------------------------------------------------
__int64 __fastcall camlPrintf__extract_format_float_138(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rbx
  unsigned __int64 v9; // rsi
  __int64 v10; // rdi
  __int64 v11; // rdx
  __int64 v12; // [rsp+0h] [rbp-8h]

  v12 = v6;
  result = camlPrintf__extract_format_113(a2, a3, a3, a4, a5, a6);
  if ( v12 == 141 )
  {
    v8 = 8LL * (*(_QWORD *)(result - 8) >> 10) - 1;
    v9 = (2 * (v8 - *(unsigned __int8 *)(result + v8)) - 1) >> 1;
    v10 = *(unsigned __int8 *)(result + v8);
    if ( v8 - v10 <= v9 )
    {
      caml_ml_array_bound_error(v10, v9);
      return camlPrintf__sub_format_145(v10, v9, v11);
    }
    else
    {
      *(_BYTE *)(result + v9) = 103;
    }
  }
  return result;
}
// 420D74: variable 'v6' is possibly undefined
// 420DEE: variable 'v11' is possibly undefined

//----- (0000000000420DF0) ----------------------------------------------------
__int64 __fastcall camlPrintf__sub_format_145(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  _QWORD *v5; // r15
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // r8
  __int64 i; // r9
  char v11; // [rsp+0h] [rbp-8h]

  v6 = v3;
  v7 = 8LL * (*(_QWORD *)(a2 - 8) >> 10) - 1;
  v8 = *(unsigned __int8 *)(a2 + v7);
  for ( i = 2 * (v7 - v8) + 1; ; caml_call_gc(a1, a2, a3, v6, v8, i, v11) )
  {
    v5 -= 8;
    if ( (unsigned __int64)v5 >= caml_young_limit )
      break;
  }
  *v5 = 7415LL;
  v5[1] = caml_curry2;
  v5[2] = 5LL;
  v5[3] = camlPrintf__sub_fmt_152;
  v5[4] = v6;
  v5[5] = v4;
  v5[6] = a2;
  v5[7] = i;
  return camlPrintf__sub_fmt_152(v5 + 1, a2, a3, v6, (__int64)(v5 + 1), i);
}
// 420DF4: variable 'v3' is possibly undefined
// 420E14: variable 'v5' is possibly undefined
// 420E4D: variable 'v6' is possibly undefined
// 420E51: variable 'v4' is possibly undefined
// 420E59: variable 'i' is possibly undefined
// 420E6A: variable 'a3' is possibly undefined
// 420E6F: variable 'v8' is possibly undefined
// 420E6F: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000420E80) ----------------------------------------------------
__int64 __fastcall camlPrintf__sub_format_for_printf_163()
{
  __int64 v0; // rax

  return caml_apply3(v0, camlPrintf[21]);
}
// 420EA7: variable 'v0' is possibly undefined
// 653BE0: using guessed type _QWORD camlPrintf[40];

//----- (0000000000420EB0) ----------------------------------------------------
__int64 __fastcall camlPrintf__iter_on_format_args_165(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rsi
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 i; // rcx
  char v14; // [rsp+0h] [rbp-8h]

  v9 = v6;
  v10 = 8LL * (*(_QWORD *)(v6 - 8) >> 10) - 1;
  v11 = *(unsigned __int8 *)(v9 + v10);
  for ( i = 2 * (v10 - v11) - 1; ; caml_call_gc(a1, v9, v11, i, a5, a6, v14) )
  {
    v8 -= 15;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 14583LL;
  v8[1] = caml_curry2;
  v8[2] = 5LL;
  v8[3] = camlPrintf__scan_flags_170;
  v8[4] = 4345LL;
  v8[5] = caml_curry2;
  v8[6] = 5LL;
  v8[7] = camlPrintf__scan_conv_171;
  v8[8] = 8441LL;
  v8[9] = camlPrintf__scan_fmt_172;
  v8[10] = 3LL;
  v8[11] = v9;
  v8[12] = v7;
  v8[13] = a1;
  v8[14] = i;
  camlPrintf__scan_fmt_172(a1, v9, (__int64)(v8 + 1), i, a5, a6);
  return 1LL;
}
// 420EB4: variable 'v6' is possibly undefined
// 420ED4: variable 'v8' is possibly undefined
// 420F56: variable 'v7' is possibly undefined
// 420F5E: variable 'i' is possibly undefined
// 420F70: variable 'a5' is possibly undefined
// 420F70: variable 'a6' is possibly undefined
// 420F81: variable 'v11' is possibly undefined
// 420F81: variable 'v14' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000420F90) ----------------------------------------------------
__int64 __fastcall camlPrintf__summarize_format_type_190(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  _QWORD *v3; // r15
  __int64 v4; // rdi
  __int64 v5; // rdx
  __int64 v6; // rcx
  _QWORD *i; // rsi
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  char v15; // [rsp+0h] [rbp-18h]

  v4 = v2;
  v15 = v2;
  for ( i = camlBuffer__create_67(v2, a2); ; caml_call_gc(v4, (__int64)i, v5, v6, v8, v9, v15) )
  {
    v3 -= 11;
    if ( (unsigned __int64)v3 >= caml_young_limit )
      break;
  }
  *v3 = 4343LL;
  v3[1] = caml_curry2;
  v3[2] = 5LL;
  v3[3] = camlPrintf__add_char_194;
  v3[4] = i;
  v3[5] = 5367LL;
  v3[6] = caml_curry3;
  v3[7] = 7LL;
  v3[8] = camlPrintf__add_conv_197;
  v3[9] = i;
  v3[10] = v3 + 1;
  camlPrintf__iter_on_format_args_165((__int64)(v3 + 1), (__int64)i, v5, v6, v8, v9);
  return camlString__sub_74(i[1], (__int64)i, v10, v11, v12, v13);
}
// 420F94: variable 'v2' is possibly undefined
// 420FC5: variable 'v3' is possibly undefined
// 42103B: variable 'v5' is possibly undefined
// 42103B: variable 'v6' is possibly undefined
// 42103B: variable 'v8' is possibly undefined
// 42103B: variable 'v9' is possibly undefined
// 421057: variable 'v10' is possibly undefined
// 421057: variable 'v11' is possibly undefined
// 421057: variable 'v12' is possibly undefined
// 421057: variable 'v13' is possibly undefined
// 42105C: variable 'v15' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000421070) ----------------------------------------------------
_QWORD *__fastcall camlPrintf__ac_of_format_212(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rsi
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v10) )
  {
    v7 -= 14;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 3072LL;
  v7[1] = 1LL;
  v7[2] = 1LL;
  v7[3] = 1LL;
  v7[4] = 4343LL;
  v7[5] = caml_curry2;
  v7[6] = 5LL;
  v7[7] = camlPrintf__incr_ac_215;
  v7[8] = v7 + 1;
  v7[9] = 4343LL;
  v7[10] = caml_curry3;
  v7[11] = 7LL;
  v7[12] = camlPrintf__add_conv_219;
  v7[13] = v7 + 5;
  camlPrintf__iter_on_format_args_165((__int64)&camlPrintf__48, i, a3, a4, a5, a6);
  return v7 + 1;
}
// 421074: variable 'v6' is possibly undefined
// 421077: variable 'v7' is possibly undefined
// 421116: variable 'a3' is possibly undefined
// 421116: variable 'a4' is possibly undefined
// 421116: variable 'a5' is possibly undefined
// 421116: variable 'a6' is possibly undefined
// 421124: variable 'v10' is possibly undefined
// 6541F0: using guessed type __int64 (__fastcall *camlPrintf__48)();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000421130) ----------------------------------------------------
__int64 __fastcall camlPrintf__count_arguments_of_format_226(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  return *camlPrintf__ac_of_format_212(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000421150) ----------------------------------------------------
__int64 __fastcall camlPrintf__list_iter_i_229(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rsi
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v10) )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 4343LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlPrintf__loop_232;
  v7[4] = i;
  return camlPrintf__loop_232((__int64)(v7 + 1));
}
// 421154: variable 'v6' is possibly undefined
// 421157: variable 'v7' is possibly undefined
// 4211A4: variable 'a3' is possibly undefined
// 4211A4: variable 'a4' is possibly undefined
// 4211A4: variable 'a5' is possibly undefined
// 4211A4: variable 'a6' is possibly undefined
// 4211A4: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004211B0) ----------------------------------------------------
_QWORD *__fastcall camlPrintf__kapr_237(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rbx
  __int64 v12; // r8
  __int64 v13; // r9
  _QWORD *result; // rax
  __int64 v15; // [rsp+0h] [rbp-18h]
  __int64 v16; // [rsp+8h] [rbp-10h]

  v15 = v6;
  v16 = v7;
  v11 = *camlPrintf__ac_of_format_212(a1, a2, a3, a4, a5, a6);
  if ( (unsigned __int64)v11 <= 0xD )
  {
    switch ( v11 >> 1 )
    {
      case 0LL:
        result = (_QWORD *)caml_apply2(v15);
        break;
      case 1LL:
        while ( 1 )
        {
          v8 -= 5;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(a1, a2, v9, v10, v12, v13, v15);
        }
        result = v8 + 1;
        *v8 = 4343LL;
        v8[1] = camlPrintf__fun_601;
        v8[2] = 3LL;
        v8[3] = v15;
        v8[4] = v16;
        break;
      case 2LL:
        while ( 1 )
        {
          v8 -= 6;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(a1, a2, v9, v10, v12, v13, v15);
        }
        result = v8 + 1;
        *v8 = 5367LL;
        v8[1] = caml_curry2;
        v8[2] = 5LL;
        v8[3] = camlPrintf__fun_604;
        v8[4] = v15;
        v8[5] = v16;
        break;
      case 3LL:
        while ( 1 )
        {
          v8 -= 6;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(a1, a2, v9, v10, v12, v13, v15);
        }
        result = v8 + 1;
        *v8 = 5367LL;
        v8[1] = caml_curry3;
        v8[2] = 7LL;
        v8[3] = camlPrintf__fun_607;
        v8[4] = v15;
        v8[5] = v16;
        break;
      case 4LL:
        while ( 1 )
        {
          v8 -= 6;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(a1, a2, v9, v10, v12, v13, v15);
        }
        result = v8 + 1;
        *v8 = 5367LL;
        v8[1] = caml_curry4;
        v8[2] = 9LL;
        v8[3] = camlPrintf__fun_610;
        v8[4] = v15;
        v8[5] = v16;
        break;
      case 5LL:
        while ( 1 )
        {
          v8 -= 6;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(a1, a2, v9, v10, v12, v13, v15);
        }
        result = v8 + 1;
        *v8 = 5367LL;
        v8[1] = caml_curry5;
        v8[2] = 11LL;
        v8[3] = camlPrintf__fun_613;
        v8[4] = v15;
        v8[5] = v16;
        break;
      case 6LL:
        while ( 1 )
        {
          v8 -= 6;
          if ( (unsigned __int64)v8 >= caml_young_limit )
            break;
          caml_call_gc(a1, a2, v9, v10, v12, v13, v15);
        }
        result = v8 + 1;
        *v8 = 5367LL;
        v8[1] = caml_curry6;
        v8[2] = 13LL;
        v8[3] = camlPrintf__fun_616;
        v8[4] = v15;
        v8[5] = v16;
        break;
    }
  }
  else
  {
    while ( 1 )
    {
      v8 -= 7;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
      caml_call_gc(a1, a2, v9, v10, v12, v13, v15);
    }
    *v8 = 6391LL;
    v8[1] = caml_curry2;
    v8[2] = 5LL;
    v8[3] = camlPrintf__loop_268;
    v8[4] = v15;
    v8[5] = v16;
    v8[6] = v11;
    return camlPrintf__loop_268((__int64)(v8 + 1), a2, v9, v10, v12, v13);
  }
  return result;
}
// 4211B4: variable 'v6' is possibly undefined
// 4211BB: variable 'v7' is possibly undefined
// 4211CE: variable 'v8' is possibly undefined
// 42120F: variable 'v15' is possibly undefined
// 421232: variable 'v9' is possibly undefined
// 421232: variable 'v10' is possibly undefined
// 421232: variable 'v12' is possibly undefined
// 421232: variable 'v13' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004214A0) ----------------------------------------------------
__int64 __fastcall camlPrintf__scan_positional_spec_280(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rax
  __int64 v6; // rbx
  _QWORD *v7; // r15
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // r9
  unsigned __int64 v12; // rdi
  char v14; // [rsp+0h] [rbp-8h]

  v8 = v5;
  v9 = v6;
  v10 = *(unsigned __int8 *)(v5 + (a2 >> 1));
  v11 = 2 * v10 + 1;
  v12 = 2 * v10 - 95;
  if ( v12 > 0x13 )
    return caml_apply2(v6);
  while ( 1 )
  {
    v7 -= 7;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc(v12, a2, v8, v9, a5, v11, v14);
  }
  *v7 = 6391LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlPrintf__get_int_literal_286;
  v7[4] = v8;
  v7[5] = v9;
  v7[6] = a2;
  return camlPrintf__get_int_literal_286((__int64)(v7 + 1), a2, v8, v9, (__int64)camlPrintf__get_int_literal_286, v11);
}
// 4214A4: variable 'v5' is possibly undefined
// 4214A7: variable 'v6' is possibly undefined
// 4214E0: variable 'v7' is possibly undefined
// 421519: variable 'v8' is possibly undefined
// 42151D: variable 'v9' is possibly undefined
// 421534: variable 'v11' is possibly undefined
// 421539: variable 'a5' is possibly undefined
// 421539: variable 'v14' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000421540) ----------------------------------------------------
__int64 __fastcall camlPrintf__next_index_290()
{
  __int64 v0; // rax
  __int64 v1; // rbx

  if ( v0 == 1 )
    return (**(__int64 (***)(void))(camlPrintf[11] + 16LL))();
  else
    return v1;
}
// 421544: variable 'v0' is possibly undefined
// 421546: variable 'v1' is possibly undefined
// 421540: using guessed type __int64 __fastcall camlPrintf__next_index_290();
// 653BE0: using guessed type _QWORD camlPrintf[40];

//----- (0000000000421570) ----------------------------------------------------
__int64 __fastcall camlPrintf__get_index_293()
{
  __int64 v0; // rax
  __int64 v1; // rbx

  if ( v0 == 1 )
    return v1;
  else
    return *(_QWORD *)v0;
}
// 421574: variable 'v0' is possibly undefined
// 42157C: variable 'v1' is possibly undefined
// 421570: using guessed type __int64 __fastcall camlPrintf__get_index_293();

//----- (0000000000421580) ----------------------------------------------------
void *__fastcall camlPrintf__valid_float_lexeme_298(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rdi
  __int64 v12; // rax
  __int64 v13; // rdx
  char v15; // [rsp+0h] [rbp-8h]

  v9 = v6;
  v10 = 8LL * (*(_QWORD *)(v7 - 8) >> 10) - 1;
  v11 = *(unsigned __int8 *)(v7 + v10);
  v12 = v10 - v11;
  v13 = 2 * v12 + 1;
  if ( !(2 * v12) )
    return &camlPrintf__46;
  while ( 1 )
  {
    v8 -= 7;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(v11, (__int64)&camlPrintf__45, v13, v9, a5, a6, v15);
  }
  *v8 = 6391LL;
  v8[1] = camlPrintf__loop_305;
  v8[2] = 3LL;
  v8[3] = v9;
  v8[4] = v7;
  v8[5] = v13;
  v8[6] = &camlPrintf__45;
  return (void *)camlPrintf__loop_305();
}
// 421584: variable 'v6' is possibly undefined
// 421587: variable 'v7' is possibly undefined
// 4215BF: variable 'v8' is possibly undefined
// 4215ED: variable 'v9' is possibly undefined
// 4215F5: variable 'v13' is possibly undefined
// 421610: variable 'a5' is possibly undefined
// 421610: variable 'a6' is possibly undefined
// 421610: variable 'v15' is possibly undefined
// 6541D0: using guessed type __int64 (__fastcall *camlPrintf__45)();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000421620) ----------------------------------------------------
void *__fastcall camlPrintf__fun_630()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rax
  __int64 v9; // [rsp+10h] [rbp-8h]

  caml_c_call(v0, v1);
  v9 = v2;
  caml_c_call(v1, v1);
  if ( v7 < 7 )
    return camlPrintf__valid_float_lexeme_298(v1, v1, v3, v4, v5, v6);
  else
    return (void *)v9;
}
// 421620: could not find valid save-restore pair for rbx
// 42163A: variable 'v0' is possibly undefined
// 42163A: variable 'v1' is possibly undefined
// 42163F: variable 'v2' is possibly undefined
// 421658: variable 'v7' is possibly undefined
// 421672: variable 'v3' is possibly undefined
// 421672: variable 'v4' is possibly undefined
// 421672: variable 'v5' is possibly undefined
// 421672: variable 'v6' is possibly undefined

//----- (0000000000421680) ----------------------------------------------------
__int64 __fastcall camlPrintf__scan_format_310(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 v8; // r10
  _QWORD *v9; // r15
  __int64 v10; // rbp
  char v12; // [rsp+0h] [rbp-8h]

  v10 = v6;
  while ( 1 )
  {
    v9 -= 25;
    if ( (unsigned __int64)v9 >= caml_young_limit )
      break;
    caml_call_gc(a1, a2, a3, a4, a5, a6, v12);
  }
  *v9 = 4343LL;
  v9[1] = caml_curry2;
  v9[2] = 5LL;
  v9[3] = camlPrintf__get_arg_320;
  v9[4] = v7;
  v9[5] = 19703LL;
  v9[6] = caml_curry3;
  v9[7] = 7LL;
  v9[8] = camlPrintf__scan_positional_323;
  v9[9] = 4345LL;
  v9[10] = caml_curry4;
  v9[11] = 9LL;
  v9[12] = camlPrintf__scan_flags_324;
  v9[13] = 8441LL;
  v9[14] = caml_curry4;
  v9[15] = 9LL;
  v9[16] = camlPrintf__scan_conv_325;
  v9[17] = v10;
  v9[18] = a2;
  v9[19] = a3;
  v9[20] = a4;
  v9[21] = a5;
  v9[22] = a6;
  v9[23] = v8;
  v9[24] = v9 + 1;
  return camlPrintf__scan_positional_323(a2 + 2, (__int64)(v9 + 6), a3, a4, a5, a6);
}
// 421684: variable 'v6' is possibly undefined
// 421687: variable 'v9' is possibly undefined
// 4216C7: variable 'v7' is possibly undefined
// 421748: variable 'a3' is possibly undefined
// 42174C: variable 'a4' is possibly undefined
// 421750: variable 'a5' is possibly undefined
// 421754: variable 'a6' is possibly undefined
// 42175B: variable 'v8' is possibly undefined
// 421786: variable 'v12' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000421790) ----------------------------------------------------
_QWORD *__fastcall camlPrintf__mkprintf_377(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 (**v4)(void); // rbx
  _QWORD *v5; // r15
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 i; // rdi
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // [rsp+0h] [rbp-38h]

  v16 = v3;
  for ( i = (*v4)(); ; caml_call_gc(i, a2, v6, v7, v9, v10, v16) )
  {
    v5 -= 9;
    if ( (unsigned __int64)v5 >= caml_young_limit )
      break;
  }
  *v5 = 8439LL;
  v5[1] = caml_curry4;
  v5[2] = 9LL;
  v5[3] = camlPrintf__pr_386;
  v5[4] = v16;
  v5[5] = a1;
  v5[6] = a2;
  v5[7] = a3;
  v5[8] = i;
  camlPrintf__index_of_int_65(i, a2);
  caml_apply2((__int64)(v5 + 1));
  return camlPrintf__kapr_237((__int64)(v5 + 1), a2, v11, v12, v13, v14);
}
// 421794: variable 'v3' is possibly undefined
// 4217B4: variable 'v4' is possibly undefined
// 4217BC: variable 'v5' is possibly undefined
// 421802: variable 'v16' is possibly undefined
// 42184C: variable 'v11' is possibly undefined
// 42184C: variable 'v12' is possibly undefined
// 42184C: variable 'v13' is possibly undefined
// 42184C: variable 'v14' is possibly undefined
// 421851: variable 'v6' is possibly undefined
// 421851: variable 'v7' is possibly undefined
// 421851: variable 'v9' is possibly undefined
// 421851: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000421860) ----------------------------------------------------
__int64 __fastcall camlPrintf__kfprintf_418(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rcx
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(v7, a2, a3, i, a5, a6, v11) )
  {
    v8 -= 4;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 3319LL;
  v8[1] = camlPrintf__fun_710;
  v8[2] = 3LL;
  v8[3] = v7;
  return caml_apply6(camlPervasives[45], camlPervasives[46], camlPervasives[43], i, camlPrintf[35]);
}
// 421864: variable 'v6' is possibly undefined
// 42186A: variable 'v8' is possibly undefined
// 421898: variable 'v7' is possibly undefined
// 4218DF: variable 'i' is possibly undefined
// 4218E4: variable 'a3' is possibly undefined
// 4218E4: variable 'a5' is possibly undefined
// 4218E4: variable 'a6' is possibly undefined
// 4218E4: variable 'v11' is possibly undefined
// 420770: using guessed type __int64 __fastcall camlPrintf__fun_710();
// 64CDA0: using guessed type _QWORD camlPervasives[84];
// 653BE0: using guessed type _QWORD camlPrintf[40];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004218F0) ----------------------------------------------------
__int64 camlPrintf__ifprintf_421()
{
  return (*(__int64 (**)(void))camlPrintf[29])();
}
// 4218F0: using guessed type __int64 __fastcall camlPrintf__ifprintf_421();
// 653BE0: using guessed type _QWORD camlPrintf[40];

//----- (0000000000421910) ----------------------------------------------------
__int64 __fastcall camlPrintf__fprintf_423(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return camlPrintf__kfprintf_418(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000421920) ----------------------------------------------------
__int64 __fastcall camlPrintf__printf_425(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 (**v6)(void); // rbx

  v6 = (__int64 (**)(void))camlPrintf__fprintf_423(a1, a2, a3, a4, a5, a6);
  return (*v6)();
}

//----- (0000000000421950) ----------------------------------------------------
__int64 __fastcall camlPrintf__eprintf_427(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 (**v6)(void); // rbx

  v6 = (__int64 (**)(void))camlPrintf__fprintf_423(a1, a2, a3, a4, a5, a6);
  return (*v6)();
}

//----- (0000000000421980) ----------------------------------------------------
__int64 __fastcall camlPrintf__kbprintf_429(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rcx
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(v7, a2, a3, i, a5, a6, v11) )
  {
    v8 -= 4;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 3319LL;
  v8[1] = camlPrintf__fun_724;
  v8[2] = 3LL;
  v8[3] = v7;
  return caml_apply6(camlBuffer[8], camlBuffer[9], (__int64)&camlPrintf__42, i, camlPrintf[35]);
}
// 421984: variable 'v6' is possibly undefined
// 42198A: variable 'v8' is possibly undefined
// 4219B8: variable 'v7' is possibly undefined
// 4219F2: variable 'i' is possibly undefined
// 4219F7: variable 'a3' is possibly undefined
// 4219F7: variable 'a5' is possibly undefined
// 4219F7: variable 'a6' is possibly undefined
// 4219F7: variable 'v11' is possibly undefined
// 4207B0: using guessed type __int64 __fastcall camlPrintf__fun_724();
// 6533C8: using guessed type _QWORD camlBuffer[21];
// 653BE0: using guessed type _QWORD camlPrintf[40];
// 654188: using guessed type __int64 (__fastcall *camlPrintf__42)();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000421A00) ----------------------------------------------------
__int64 __fastcall camlPrintf__bprintf_432(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return camlPrintf__kbprintf_429(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000421A10) ----------------------------------------------------
_QWORD *__fastcall camlPrintf__get_buff_434(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax

  return camlBuffer__create_67(v2, a2);
}
// 421A33: variable 'v2' is possibly undefined

//----- (0000000000421A40) ----------------------------------------------------
__int64 __fastcall camlPrintf__get_contents_437(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+0h] [rbp-8h]

  v8 = v6;
  result = camlString__sub_74(*(_QWORD *)(v6 + 8), a2, a3, a4, a5, a6);
  *(_QWORD *)(v8 + 8) = 1LL;
  return result;
}
// 421A40: could not find valid save-restore pair for rbx
// 421A44: variable 'v6' is possibly undefined

//----- (0000000000421A70) ----------------------------------------------------
__int64 __fastcall camlPrintf__get_cont_440(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 (**v6)(void); // rax
  __int64 v7; // rbx
  __int64 (**v9)(void); // [rsp+8h] [rbp-10h]

  v9 = v6;
  camlString__sub_74(*(_QWORD *)(v7 + 8), a2, a3, a4, a5, a6);
  *(_QWORD *)(v7 + 8) = 1LL;
  return (*v9)();
}
// 421A70: could not find valid save-restore pair for rbx
// 421A74: variable 'v6' is possibly undefined
// 421A80: variable 'v7' is possibly undefined

//----- (0000000000421AB0) ----------------------------------------------------
__int64 camlPrintf__ksprintf_443()
{
  __int64 v0; // rax

  v0 = (*(__int64 (**)(void))camlPrintf[38])();
  return caml_apply6(camlBuffer[8], camlBuffer[9], (__int64)&camlPrintf__40, v0, camlPrintf[35]);
}
// 6533C8: using guessed type _QWORD camlBuffer[21];
// 653BE0: using guessed type _QWORD camlPrintf[40];
// 654158: using guessed type __int64 (__fastcall *camlPrintf__40)();

//----- (0000000000421B20) ----------------------------------------------------
__int64 camlPrintf__sprintf_446()
{
  __int64 (**v0)(void); // rbx

  v0 = (__int64 (**)(void))camlPrintf__ksprintf_443();
  return (*v0)();
}
// 421B20: using guessed type __int64 __fastcall camlPrintf__sprintf_446();

//----- (0000000000421B50) ----------------------------------------------------
__int64 __fastcall camlPrintf__entry(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // r15
  __int64 (*v7)(void); // rdi
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // r9
  __int64 v15; // r8
  __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rsi
  _QWORD *v19; // rbx
  char v21; // [rsp+0h] [rbp-18h]
  __int64 v22; // [rsp+0h] [rbp-18h]

  caml_allocN((__int64)&camlPrintf__38, a2, a3, a4, a5, a6, (char)&camlPrintf__38);
  *v6 = 4343LL;
  v6[1] = caml_curry2;
  v6[2] = 5LL;
  v6[3] = camlPrintf__add_int_index_68;
  v6[4] = &camlPrintf__38;
  v7 = (__int64 (*)(void))v6[1];
  v8 = v7();
  caml_allocN((__int64)v7, a2, v9, v8, v10, v11, v21);
  *v6 = 3319LL;
  v6[1] = camlPrintf__index_of_literal_position_72;
  v6[2] = 3LL;
  v6[3] = v22;
  v6[4] = 3319LL;
  v6[5] = camlPrintf__to_string_82;
  v6[6] = 3LL;
  v6[7] = &camlPrintf__37;
  v6[8] = 6144LL;
  v6[9] = v22;
  v6[10] = v6 + 1;
  v6[11] = v12;
  v6[12] = v6 + 1;
  v6[13] = &camlPrintf__37;
  v6[14] = v6 + 5;
  camlPrintf[11] = v6 + 9;
  camlPrintf[12] = &camlPrintf__36;
  camlPrintf[13] = &camlPrintf__35;
  camlPrintf[14] = &camlPrintf__34;
  camlPrintf[15] = &camlPrintf__33;
  camlPrintf[16] = &camlPrintf__32;
  camlPrintf[17] = &camlPrintf__31;
  camlPrintf[18] = &camlPrintf__30;
  camlPrintf[19] = &camlPrintf__29;
  camlPrintf[20] = &camlPrintf__28;
  camlPrintf[21] = &camlPrintf__27;
  camlPrintf[22] = &camlPrintf__26;
  camlPrintf[23] = &camlPrintf__25;
  camlPrintf[24] = &camlPrintf__24;
  camlPrintf[25] = &camlPrintf__23;
  camlPrintf[26] = &camlPrintf__22;
  camlPrintf[27] = &camlPrintf__21;
  camlPrintf[28] = &camlPrintf__20;
  camlPrintf[29] = &camlPrintf__19;
  camlPrintf[30] = &camlPrintf__18;
  camlPrintf[31] = &camlPrintf__17;
  camlPrintf[32] = &camlPrintf__16;
  v6[15] = 4343LL;
  v6[16] = caml_curry2;
  v6[17] = 5LL;
  v6[18] = camlPrintf__fun_630;
  v6[19] = &camlPrintf__15;
  camlPrintf[33] = v6 + 16;
  camlPrintf[34] = &camlPrintf__14;
  camlPrintf[35] = &camlPrintf__13;
  camlPrintf[6] = &camlPrintf__12;
  camlPrintf[3] = &camlPrintf__11;
  camlPrintf[0] = &camlPrintf__10;
  camlPrintf[1] = &camlPrintf__9;
  camlPrintf[2] = &camlPrintf__8;
  camlPrintf[8] = &camlPrintf__7;
  camlPrintf[5] = &camlPrintf__6;
  camlPrintf[36] = &camlPrintf__5;
  camlPrintf[37] = &camlPrintf__4;
  camlPrintf[38] = &camlPrintf__3;
  camlPrintf[7] = &camlPrintf__2;
  camlPrintf[9] = camlPrintf[7];
  camlPrintf[4] = &camlPrintf__1;
  v13 = camlPrintf[11];
  v14 = camlPrintf[26];
  v15 = camlPrintf[21];
  v16 = camlPrintf[24];
  v17 = camlPrintf[34];
  v18 = camlPrintf[29];
  v6[20] = 5120LL;
  v6[21] = v14;
  v6[22] = v15;
  v6[23] = v16;
  v6[24] = v17;
  v6[25] = v18;
  v6[26] = 2048LL;
  v6[27] = v13;
  v6[28] = v6 + 21;
  v19 = (_QWORD *)v6[27];
  caml_allocN((__int64)(v6 + 21), (__int64)(v6 + 27), v17, v16, v15, v14, v22);
  *v6 = 4096LL;
  v6[1] = *v19;
  v6[2] = v19[2];
  v6[3] = v19[4];
  v6[4] = v19[5];
  v6[5] = 2048LL;
  v6[6] = v6 + 1;
  v6[7] = v6[28];
  camlPrintf[10] = v6 + 6;
  return 1LL;
}
// 421B74: variable 'v6' is possibly undefined
// 421BB3: variable 'v9' is possibly undefined
// 421BB3: variable 'v10' is possibly undefined
// 421BB3: variable 'v11' is possibly undefined
// 421BB3: variable 'v21' is possibly undefined
// 421BDA: variable 'v22' is possibly undefined
// 421C1F: variable 'v12' is possibly undefined
// 653BE0: using guessed type _QWORD camlPrintf[40];
// 653D20: using guessed type __int64 (__fastcall *camlPrintf__1)();
// 653D38: using guessed type __int64 (__fastcall *camlPrintf__2)();
// 653D50: using guessed type __int64 (__fastcall *camlPrintf__3)();
// 653D70: using guessed type __int64 (__fastcall *camlPrintf__4)();
// 653D88: using guessed type __int64 (__fastcall *camlPrintf__5)();
// 653DA0: using guessed type __int64 (__fastcall *camlPrintf__6)();
// 653DB8: using guessed type __int64 (__fastcall *camlPrintf__7)();
// 653DD8: using guessed type __int64 (__fastcall *camlPrintf__8)();
// 653DF0: using guessed type __int64 (__fastcall *camlPrintf__9)();
// 653E08: using guessed type __int64 (__fastcall *camlPrintf__10)();
// 653E20: using guessed type __int64 (__fastcall *camlPrintf__11)();
// 653E38: using guessed type __int64 (__fastcall *camlPrintf__12)();
// 653E58: using guessed type __int64 (__fastcall *camlPrintf__13)();
// 653E78: using guessed type __int64 (__fastcall *camlPrintf__14)();
// 653E98: using guessed type __int64 (__fastcall *camlPrintf__15)();
// 653EB8: using guessed type __int64 (__fastcall *camlPrintf__16)();
// 653ED8: using guessed type __int64 (__fastcall *camlPrintf__17)();
// 653EF8: using guessed type __int64 (__fastcall *camlPrintf__18)();
// 653F18: using guessed type __int64 (__fastcall *camlPrintf__19)();
// 653F38: using guessed type __int64 (__fastcall *camlPrintf__20)();
// 653F58: using guessed type __int64 (__fastcall *camlPrintf__21)();
// 653F70: using guessed type __int64 (__fastcall *camlPrintf__22)();
// 653F88: using guessed type __int64 (__fastcall *camlPrintf__24)();
// 653FA0: using guessed type __int64 (__fastcall *camlPrintf__25)();
// 653FC0: using guessed type __int64 (__fastcall *camlPrintf__26)();
// 653FD8: using guessed type __int64 (__fastcall *camlPrintf__27)();
// 653FF8: using guessed type __int64 (__fastcall *camlPrintf__28)();
// 654018: using guessed type __int64 (__fastcall *camlPrintf__29)();
// 654038: using guessed type __int64 (__fastcall *camlPrintf__30)();
// 654058: using guessed type __int64 (__fastcall *camlPrintf__31)();
// 654078: using guessed type __int64 (__fastcall *camlPrintf__32)();
// 654098: using guessed type __int64 (__fastcall *camlPrintf__33)();
// 6540B0: using guessed type void (__fastcall __noreturn *camlPrintf__34)();
// 6540C8: using guessed type __int64 (__fastcall *camlPrintf__35)();
// 6540E8: using guessed type __int64 (__fastcall *camlPrintf__36)();
// 654108: using guessed type __int64 (__fastcall *camlPrintf__37)();
// 654128: using guessed type __int64 (__fastcall *camlPrintf__38)();

//----- (0000000000422040) ----------------------------------------------------
void __fastcall camlCallback__code_begin()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 422051: variable 'v0' is possibly undefined
// 422051: variable 'v1' is possibly undefined

//----- (0000000000422060) ----------------------------------------------------
void __fastcall camlCallback__register_exception_62(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  double *v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // rdi
  double v10; // rsi
  char v11; // [rsp+0h] [rbp-8h]

  v9 = v6;
  if ( *((unsigned __int8 *)v7 - 8) == 254LL )
  {
    while ( 1 )
    {
      v8 -= 16LL;
      if ( v8 >= caml_young_limit )
        break;
      caml_call_gc(v9, a2, a3, a4, a5, a6, v11);
    }
    *(_QWORD *)&v10 = v8 + 8;
    *(_QWORD *)v8 = 1277LL;
    *(double *)(v8 + 8) = *v7;
  }
  else
  {
    v10 = *v7;
  }
  caml_c_call(v9, *(unsigned __int64 *)&v10);
}
// 422064: variable 'v6' is possibly undefined
// 422067: variable 'v7' is possibly undefined
// 42207C: variable 'v8' is possibly undefined
// 4220B1: variable 'a3' is possibly undefined
// 4220B1: variable 'a4' is possibly undefined
// 4220B1: variable 'a5' is possibly undefined
// 4220B1: variable 'a6' is possibly undefined
// 4220B1: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004220C0) ----------------------------------------------------
__int64 camlCallback__entry()
{
  camlCallback[0] = &camlCallback__2;
  camlCallback[1] = &camlCallback__1;
  return 1LL;
}
// 655D18: using guessed type _QWORD camlCallback[3];
// 655D30: using guessed type __int64 (__fastcall *camlCallback__1)();
// 655D50: using guessed type __int64 (__fastcall *camlCallback__2)();

//----- (00000000004220F0) ----------------------------------------------------
__int64 *__fastcall camlCamlinternalOO__code_begin(__int64 *a1)
{
  __int64 v1; // rdx
  __int64 v2; // rcx
  __int64 v3; // r8
  __int64 v4; // r9

  if ( camlList__mem_189() == 1 )
    return a1;
  else
    return camlMap__add_121(a1, *(_QWORD *)(camlCamlinternalOO[36] + 16LL), v1, v2, v3, v4);
}
// 422135: variable 'v1' is possibly undefined
// 422135: variable 'v2' is possibly undefined
// 422135: variable 'v3' is possibly undefined
// 422135: variable 'v4' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (0000000000422150) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_727(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  unsigned __int64 *v7; // rdi
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9

  v6 = camlMap__add_121(**(__int64 ***)(a1 + 32), *(_QWORD *)(camlCamlinternalOO[37] + 16LL), a3, a4, a5, a6);
  v7 = *(unsigned __int64 **)(a1 + 32);
  v8 = (__int64)v6;
  caml_modify(v7, (unsigned __int64)v6);
  if ( *(char ***)sub_4221B0((__int64)v7, v8, v9, v10, v11, v12) == &caml_exn_Not_found )
    JUMPOUT(0x4221E2LL);
  caml_raise_exn();
  return sub_4221B0((__int64)&caml_exn_Not_found, v8, v13, v14, v15, v16);
}
// 4221A6: control flows out of bounds to 4221E2
// 42218B: variable 'v9' is possibly undefined
// 42218B: variable 'v10' is possibly undefined
// 42218B: variable 'v11' is possibly undefined
// 42218B: variable 'v12' is possibly undefined
// 4221AE: variable 'v13' is possibly undefined
// 4221AE: variable 'v14' is possibly undefined
// 4221AE: variable 'v15' is possibly undefined
// 4221AE: variable 'v16' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (00000000004221B0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_4221B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  _QWORD *v10; // rax
  __int64 v12; // [rsp-10h] [rbp-18h]

  camlMap__find_130(*(_QWORD *)(camlCamlinternalOO[38] + 24LL), a2, a3, a4, a5, a6);
  v10 = camlMap__add_121(**(__int64 ***)(v12 + 40), *(_QWORD *)(camlCamlinternalOO[38] + 16LL), v6, v7, v8, v9);
  caml_modify(*(unsigned __int64 **)(v12 + 40), (unsigned __int64)v10);
  return 1LL;
}
// 422224: positive sp value 20 has been found
// 4221B0: could not find valid save-restore pair for rbx
// 4221F8: variable 'v12' is possibly undefined
// 422204: variable 'v6' is possibly undefined
// 422204: variable 'v7' is possibly undefined
// 422204: variable 'v8' is possibly undefined
// 422204: variable 'v9' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (0000000000422230) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_730(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  _QWORD *v11; // rax

  v6 = camlMap__add_121(**(__int64 ***)(a1 + 24), *(_QWORD *)(camlCamlinternalOO[37] + 16LL), a3, a4, a5, a6);
  caml_modify(*(unsigned __int64 **)(a1 + 24), (unsigned __int64)v6);
  v11 = camlMap__add_121(**(__int64 ***)(a1 + 32), *(_QWORD *)(camlCamlinternalOO[38] + 16LL), v7, v8, v9, v10);
  caml_modify(*(unsigned __int64 **)(a1 + 32), (unsigned __int64)v11);
  return 1LL;
}
// 422230: could not find valid save-restore pair for rbx
// 422290: variable 'v7' is possibly undefined
// 422290: variable 'v8' is possibly undefined
// 422290: variable 'v9' is possibly undefined
// 422290: variable 'v10' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (00000000004222C0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__fun_733(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  _QWORD *v4; // r15
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  _QWORD *result; // rax
  __int64 v10; // [rsp+0h] [rbp-18h]

  v10 = v2;
  if ( camlList__mem_189() != 1 )
    return (_QWORD *)v3;
  while ( 1 )
  {
    v4 -= 3;
    if ( (unsigned __int64)v4 >= caml_young_limit )
      break;
    caml_call_gc(a1, a2, v5, v6, v7, v8, v10);
  }
  result = v4 + 1;
  *v4 = 2048LL;
  v4[1] = v10;
  v4[2] = v3;
  return result;
}
// 4222C4: variable 'v2' is possibly undefined
// 4222DF: variable 'v3' is possibly undefined
// 4222EC: variable 'v4' is possibly undefined
// 42230C: variable 'v10' is possibly undefined
// 42231D: variable 'v5' is possibly undefined
// 42231D: variable 'v6' is possibly undefined
// 42231D: variable 'v7' is possibly undefined
// 42231D: variable 'v8' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000422330) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__fun_737(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 *v12; // [rsp+8h] [rbp-10h]

  v12 = v6;
  camlMap__find_130(*(_QWORD *)(camlCamlinternalOO[36] + 24LL), *(_QWORD *)(a1 + 24), a1, a4, a5, a6);
  return camlMap__add_121(v12, *(_QWORD *)(camlCamlinternalOO[36] + 16LL), v7, v8, v9, v10);
}
// 422334: variable 'v6' is possibly undefined
// 422384: variable 'v7' is possibly undefined
// 422384: variable 'v8' is possibly undefined
// 422384: variable 'v9' is possibly undefined
// 422384: variable 'v10' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (0000000000422390) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__fun_740(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  _QWORD *v4; // r15
  __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // r8
  __int64 v8; // r9
  _QWORD *result; // rax
  __int64 v10; // [rsp+0h] [rbp-18h]

  v10 = v2;
  if ( camlList__mem_189() != 1 )
    return (_QWORD *)v3;
  while ( 1 )
  {
    v4 -= 3;
    if ( (unsigned __int64)v4 >= caml_young_limit )
      break;
    caml_call_gc(a1, a2, v5, v6, v7, v8, v10);
  }
  result = v4 + 1;
  *v4 = 2048LL;
  v4[1] = v10;
  v4[2] = v3;
  return result;
}
// 422394: variable 'v2' is possibly undefined
// 4223AF: variable 'v3' is possibly undefined
// 4223BC: variable 'v4' is possibly undefined
// 4223DC: variable 'v10' is possibly undefined
// 4223ED: variable 'v5' is possibly undefined
// 4223ED: variable 'v6' is possibly undefined
// 4223ED: variable 'v7' is possibly undefined
// 4223ED: variable 'v8' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000422400) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_751(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  _QWORD *v11; // rax

  v6 = camlMap__add_121(
         *(__int64 **)(*(_QWORD *)(a1 + 24) + 16LL),
         *(_QWORD *)(camlCamlinternalOO[37] + 16LL),
         a3,
         a4,
         a5,
         a6);
  caml_modify((unsigned __int64 *)(*(_QWORD *)(a1 + 24) + 16LL), (unsigned __int64)v6);
  v11 = camlMap__add_121(
          *(__int64 **)(*(_QWORD *)(a1 + 24) + 24LL),
          *(_QWORD *)(camlCamlinternalOO[38] + 16LL),
          v7,
          v8,
          v9,
          v10);
  caml_modify((unsigned __int64 *)(*(_QWORD *)(a1 + 24) + 24LL), (unsigned __int64)v11);
  return 1LL;
}
// 422400: could not find valid save-restore pair for rbx
// 422471: variable 'v7' is possibly undefined
// 422471: variable 'v8' is possibly undefined
// 422471: variable 'v9' is possibly undefined
// 422471: variable 'v10' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (00000000004224A0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_757(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rdi
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9

  v7 = v6;
  camlCamlinternalOO__get_method_label_206(v6, a2, a3, a4, a5, a6);
  return camlCamlinternalOO__get_method_217(v7, a2, v8, v9, v10, v11);
}
// 4224A4: variable 'v6' is possibly undefined
// 4224C6: variable 'v8' is possibly undefined
// 4224C6: variable 'v9' is possibly undefined
// 4224C6: variable 'v10' is possibly undefined
// 4224C6: variable 'v11' is possibly undefined

//----- (00000000004224D0) ----------------------------------------------------
void __fastcall __noreturn camlCamlinternalOO__undef_322(
        char **a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rbx
  _QWORD *v7; // r15
  char v8; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    v7 -= 3;
    if ( (unsigned __int64)v7 >= caml_young_limit )
    {
      *v7 = 2048LL;
      a1 = &caml_exn_Undefined_recursive_module;
      v7[1] = &caml_exn_Undefined_recursive_module;
      v6 = *(_QWORD *)(v6 + 16);
      v7[2] = v6;
      caml_raise_exn();
    }
    caml_call_gc((__int64)a1, a2, a3, a4, a5, a6, v8);
  }
}
// 4224D4: variable 'v7' is possibly undefined
// 4224FA: variable 'v6' is possibly undefined
// 422507: variable 'a3' is possibly undefined
// 422507: variable 'a4' is possibly undefined
// 422507: variable 'a5' is possibly undefined
// 422507: variable 'a6' is possibly undefined
// 422507: variable 'v8' is possibly undefined
// 647C80: using guessed type char *caml_exn_Undefined_recursive_module;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000422510) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__lookup_key_376(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  _QWORD *v6; // rax
  _QWORD *v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // rdi
  __int64 v10; // rsi
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  char v16; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    v9 = (__int64)v6;
    v10 = v7[5];
    if ( *v6 == v10 )
      return camlCamlinternalOO__lookup_keys_371(v6[1], v7[2], v7[4], a4, a5, a6);
    if ( v6[2] == 1LL )
      break;
    v6 = (_QWORD *)v6[2];
  }
  while ( 1 )
  {
    v8 -= 4;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(v9, v10, a3, a4, a5, a6, v16);
  }
  *v8 = 3072LL;
  v8[1] = v7[5];
  v8[2] = 1LL;
  v8[3] = 1LL;
  caml_modify((unsigned __int64 *)(v9 + 16), (unsigned __int64)(v8 + 1));
  return camlCamlinternalOO__build_path_364((__int64)(v8 + 1), v8 + 1, v12, v13, v14, v15);
}
// 422514: variable 'v6' is possibly undefined
// 422517: variable 'v7' is possibly undefined
// 422554: variable 'v8' is possibly undefined
// 4225AA: variable 'v12' is possibly undefined
// 4225AA: variable 'v13' is possibly undefined
// 4225AA: variable 'v14' is possibly undefined
// 4225AA: variable 'v15' is possibly undefined
// 4225AF: variable 'a3' is possibly undefined
// 4225AF: variable 'a4' is possibly undefined
// 4225AF: variable 'a5' is possibly undefined
// 4225AF: variable 'a6' is possibly undefined
// 4225AF: variable 'v16' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004225C0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_784()
{
  __int64 v0; // rbx

  return *(_QWORD *)(v0 + 16);
}
// 4225C0: variable 'v0' is possibly undefined
// 4225C0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_784();

//----- (00000000004225D0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_788()
{
  __int64 v0; // rax
  __int64 v1; // rbx

  return *(_QWORD *)(v0 + 4LL * *(_QWORD *)(v1 + 16) - 4);
}
// 4225D4: variable 'v0' is possibly undefined
// 4225D0: variable 'v1' is possibly undefined
// 4225D0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_788();

//----- (00000000004225E0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_792()
{
  __int64 v0; // rax
  __int64 v1; // rbx

  return *(_QWORD *)(*(_QWORD *)(v0 + 4LL * *(_QWORD *)(v1 + 16) - 4) + 4LL * *(_QWORD *)(v1 + 24) - 4);
}
// 4225E8: variable 'v0' is possibly undefined
// 4225E4: variable 'v1' is possibly undefined
// 4225E0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_792();

//----- (0000000000422600) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_796()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx

  return (**(__int64 (***)(void))(*v0 + 4LL * *(_QWORD *)(v1 + 16) - 4))();
}
// 422604: variable 'v0' is possibly undefined
// 422600: variable 'v1' is possibly undefined
// 422600: using guessed type __int64 __fastcall camlCamlinternalOO__fun_796();

//----- (0000000000422620) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_800(__int64 a1)
{
  __int64 v1; // rax
  unsigned __int64 v2; // rbx

  caml_modify((unsigned __int64 *)(v1 + 4LL * *(_QWORD *)(a1 + 24) - 4), v2);
  return 1LL;
}
// 422628: variable 'v1' is possibly undefined
// 422630: variable 'v2' is possibly undefined

//----- (0000000000422650) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_804()
{
  __int64 v0; // rbx

  return (**(__int64 (***)(void))(v0 + 16))();
}
// 422653: variable 'v0' is possibly undefined
// 422650: using guessed type __int64 __fastcall camlCamlinternalOO__fun_804();

//----- (0000000000422660) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_808()
{
  __int64 v0; // rbx

  return (**(__int64 (***)(void))(v0 + 16))();
}
// 422663: variable 'v0' is possibly undefined
// 422660: using guessed type __int64 __fastcall camlCamlinternalOO__fun_808();

//----- (0000000000422680) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_812()
{
  __int64 v0; // rbx

  return (**(__int64 (***)(void))(v0 + 16))();
}
// 422683: variable 'v0' is possibly undefined
// 422680: using guessed type __int64 __fastcall camlCamlinternalOO__fun_812();

//----- (00000000004226A0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_816()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx
  __int64 (**v3)(void); // [rsp+0h] [rbp-8h]

  v3 = *(__int64 (***)(void))(v1 + 16);
  (**(void (***)(void))(*v0 + 4LL * *(_QWORD *)(v1 + 24) - 4))();
  return (*v3)();
}
// 4226A4: variable 'v1' is possibly undefined
// 4226B0: variable 'v0' is possibly undefined
// 4226A0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_816();

//----- (00000000004226D0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_820()
{
  __int64 v0; // rbx

  return caml_apply2(*(_QWORD *)(v0 + 16));
}
// 4226D3: variable 'v0' is possibly undefined
// 4226D0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_820();

//----- (00000000004226F0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_824()
{
  __int64 v0; // rbx

  return caml_apply2(*(_QWORD *)(v0 + 16));
}
// 4226F3: variable 'v0' is possibly undefined
// 4226F0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_824();

//----- (0000000000422710) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_828()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx

  (**(void (***)(void))(*v0 + 4LL * *(_QWORD *)(v1 + 32) - 4))();
  return caml_apply2(*(_QWORD *)(v1 + 16));
}
// 42271C: variable 'v0' is possibly undefined
// 422718: variable 'v1' is possibly undefined
// 422710: using guessed type __int64 __fastcall camlCamlinternalOO__fun_828();

//----- (0000000000422750) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_832()
{
  __int64 v0; // rbx

  return caml_apply2(*(_QWORD *)(v0 + 16));
}
// 422753: variable 'v0' is possibly undefined
// 422750: using guessed type __int64 __fastcall camlCamlinternalOO__fun_832();

//----- (0000000000422770) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_836()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx

  (**(void (***)(void))(*v0 + 4LL * *(_QWORD *)(v1 + 24) - 4))();
  return caml_apply2(*(_QWORD *)(v1 + 16));
}
// 42277C: variable 'v0' is possibly undefined
// 422778: variable 'v1' is possibly undefined
// 422770: using guessed type __int64 __fastcall camlCamlinternalOO__fun_836();

//----- (00000000004227A0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_840()
{
  __int64 v0; // rbx

  return caml_apply2(*(_QWORD *)(v0 + 16));
}
// 4227A3: variable 'v0' is possibly undefined
// 4227A0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_840();

//----- (00000000004227D0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_844()
{
  __int64 v0; // rbx

  return caml_apply2(*(_QWORD *)(v0 + 16));
}
// 4227D3: variable 'v0' is possibly undefined
// 4227D0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_844();

//----- (0000000000422800) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_848()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx

  return caml_apply2(*(_QWORD *)(*v0 + 4LL * *(_QWORD *)(v1 + 16) - 4));
}
// 422804: variable 'v0' is possibly undefined
// 422800: variable 'v1' is possibly undefined
// 422800: using guessed type __int64 __fastcall camlCamlinternalOO__fun_848();

//----- (0000000000422820) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_852()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx

  return caml_apply2(*(_QWORD *)(*v0 + 4LL * *(_QWORD *)(v1 + 16) - 4));
}
// 422824: variable 'v0' is possibly undefined
// 422820: variable 'v1' is possibly undefined
// 422820: using guessed type __int64 __fastcall camlCamlinternalOO__fun_852();

//----- (0000000000422840) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_856()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx

  return caml_apply2(*(_QWORD *)(*v0 + 4LL * *(_QWORD *)(v1 + 16) - 4));
}
// 422844: variable 'v0' is possibly undefined
// 422840: variable 'v1' is possibly undefined
// 422840: using guessed type __int64 __fastcall camlCamlinternalOO__fun_856();

//----- (0000000000422870) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_860()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx
  __int64 v3; // [rsp+8h] [rbp-10h]

  v3 = *(_QWORD *)(*v0 + 4LL * *(_QWORD *)(v1 + 16) - 4);
  (**(void (***)(void))(*v0 + 4LL * *(_QWORD *)(v1 + 24) - 4))();
  return caml_apply2(v3);
}
// 42287C: variable 'v0' is possibly undefined
// 422878: variable 'v1' is possibly undefined
// 422870: using guessed type __int64 __fastcall camlCamlinternalOO__fun_860();

//----- (00000000004228B0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_864()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx

  return caml_send0((__int64 *)(*v0 + 4LL * *(_QWORD *)(v1 + 32) - 4));
}
// 4228BB: variable 'v0' is possibly undefined
// 4228B7: variable 'v1' is possibly undefined
// 4228B0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_864();

//----- (00000000004228D0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_868()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx

  return caml_send0((__int64 *)(*v0 + 4LL * *(_QWORD *)(v1 + 32) - 4));
}
// 4228E0: variable 'v0' is possibly undefined
// 4228DC: variable 'v1' is possibly undefined
// 4228D0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_868();

//----- (0000000000422900) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_872()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx

  return caml_send0((__int64 *)(*v0 + 4LL * *(_QWORD *)(v1 + 40) - 4));
}
// 422919: variable 'v0' is possibly undefined
// 422915: variable 'v1' is possibly undefined
// 422900: using guessed type __int64 __fastcall camlCamlinternalOO__fun_872();

//----- (0000000000422930) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fun_876()
{
  _QWORD *v0; // rax
  __int64 v1; // rbx
  _QWORD *v3; // [rsp+8h] [rbp-10h]

  v3 = v0;
  (**(void (***)(void))(*v0 + 4LL * *(_QWORD *)(v1 + 24) - 4))();
  return caml_send0((__int64 *)(*v3 + 4LL * *(_QWORD *)(v1 + 32) - 4));
}
// 422934: variable 'v0' is possibly undefined
// 42293D: variable 'v1' is possibly undefined
// 422930: using guessed type __int64 __fastcall camlCamlinternalOO__fun_876();

//----- (0000000000422970) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__next_551(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  unsigned __int64 v7; // r15
  unsigned __int64 v8; // rsi
  __int64 v9; // rdi
  unsigned __int64 v10; // rax
  __int64 result; // rax
  char v12; // [rsp+0h] [rbp-8h]

  **(_QWORD **)(v6 + 16) += 2LL;
  v8 = **(_QWORD **)(v6 + 16);
  v9 = *(_QWORD *)(v6 + 24);
  v10 = *(_QWORD *)(v9 - 8);
  if ( (unsigned __int8)v10 != 254LL )
  {
    if ( v10 >> 9 > v8 )
      return *(_QWORD *)(v9 + 4 * v8 - 4);
    goto LABEL_9;
  }
  if ( v10 >> 9 <= v8 )
  {
    caml_ml_array_bound_error(v9, v8);
LABEL_9:
    caml_ml_array_bound_error(v9, v8);
    return camlCamlinternalOO__new_id_59();
  }
  while ( 1 )
  {
    v7 -= 16LL;
    if ( v7 >= caml_young_limit )
      break;
    caml_call_gc(v9, v8, a3, a4, a5, a6, v12);
  }
  result = v7 + 8;
  *(_QWORD *)v7 = 1277LL;
  *(double *)(v7 + 8) = *(double *)(v9 + 4 * v8 - 4);
  return result;
}
// 422974: variable 'v6' is possibly undefined
// 4229BD: variable 'v7' is possibly undefined
// 4229E8: variable 'a3' is possibly undefined
// 4229E8: variable 'a4' is possibly undefined
// 4229E8: variable 'a5' is possibly undefined
// 4229E8: variable 'a6' is possibly undefined
// 4229E8: variable 'v12' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000422A00) ----------------------------------------------------
__int64 camlCamlinternalOO__new_id_59()
{
  __int64 result; // rax

  result = *(_QWORD *)camlCamlinternalOO[30];
  *(_QWORD *)camlCamlinternalOO[30] = result + 2;
  return result;
}
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (0000000000422A30) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__set_id_61()
{
  __int64 v0; // rax
  __int64 *v1; // rbx
  __int64 v2; // rdi
  __int64 v3; // rax

  v2 = v0;
  v3 = *v1;
  *(_QWORD *)(v2 + 8) = *v1;
  *v1 = v3 + 2;
  return 1LL;
}
// 422A30: variable 'v0' is possibly undefined
// 422A33: variable 'v1' is possibly undefined

//----- (0000000000422A50) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__copy_65(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v5; // [rsp+0h] [rbp-8h]

  caml_c_call(v2, a2);
  v5 = v3;
  camlCamlinternalOO__set_id_61();
  return v5;
}
// 422A5E: variable 'v2' is possibly undefined
// 422A63: variable 'v3' is possibly undefined

//----- (0000000000422A90) ----------------------------------------------------
void __fastcall camlCamlinternalOO__public_method_label_102(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rbx
  __int64 *v9; // rdi
  __int64 v10; // rax
  __int64 v11; // rsi
  signed __int64 v12; // rsi
  __int64 v13; // rdx
  __int64 v14; // rdx
  char v15; // [rsp+0h] [rbp-8h]

  v8 = v6;
  while ( 1 )
  {
    v7 -= 2;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc(a1, a2, a3, a4, a5, a6, v15);
  }
  v9 = v7 + 1;
  *v7 = 1024LL;
  v7[1] = 1LL;
  v10 = 1LL;
  v11 = 8LL * (*(_QWORD *)(v8 - 8) >> 10) - 1;
  v12 = 2 * (v11 - *(unsigned __int8 *)(v8 + v11)) - 1;
  if ( v12 < 1 )
  {
LABEL_6:
    *v9 = (unsigned int)*v9;
  }
  else
  {
    while ( 1 )
    {
      v13 = 8LL * (*(_QWORD *)(v8 - 8) >> 10) - 1;
      if ( v13 - (unsigned __int64)*(unsigned __int8 *)(v8 + v13) <= v10 >> 1 )
        break;
      *v9 = 446 * (*v9 >> 1) + 2LL * *(unsigned __int8 *)(v8 + (v10 >> 1)) + 1;
      v14 = v10;
      v10 += 2LL;
      if ( v14 == v12 )
        goto LABEL_6;
    }
    caml_ml_array_bound_error((__int64)v9, v12);
    camlCamlinternalOO__compare_139();
  }
}
// 422A94: variable 'v6' is possibly undefined
// 422A97: variable 'v7' is possibly undefined
// 422B68: variable 'a3' is possibly undefined
// 422B68: variable 'a4' is possibly undefined
// 422B68: variable 'a5' is possibly undefined
// 422B68: variable 'a6' is possibly undefined
// 422B68: variable 'v15' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000422B80) ----------------------------------------------------
void __fastcall camlCamlinternalOO__compare_139()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 422B91: variable 'v0' is possibly undefined
// 422B91: variable 'v1' is possibly undefined

//----- (0000000000422BA0) ----------------------------------------------------
void __fastcall camlCamlinternalOO__compare_157()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 422BB1: variable 'v0' is possibly undefined
// 422BB1: variable 'v1' is possibly undefined

//----- (0000000000422BC0) ----------------------------------------------------
void __fastcall camlCamlinternalOO__compare_161()
{
  __int64 v0; // rax
  unsigned __int64 v1; // rbx

  caml_c_call(v0, v1);
}
// 422BD1: variable 'v0' is possibly undefined
// 422BD1: variable 'v1' is possibly undefined

//----- (0000000000422BE0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__fit_size_184()
{
  __int64 result; // rax

  if ( result > 5 )
    return 2 * (camlCamlinternalOO__fit_size_184() - 1) + 1;
  return result;
}
// 422BE8: variable 'result' is possibly undefined

//----- (0000000000422C30) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__new_table_186()
{
  __int64 v0; // rax
  unsigned __int64 v1; // r15
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  unsigned __int64 *v4; // rax
  unsigned __int64 *v5; // rbp
  unsigned __int64 *v6; // rbp
  unsigned __int64 *v7; // rdi
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  unsigned __int64 v12; // rbx
  __int64 v13; // rdx
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rax
  __int64 result; // rax
  unsigned __int64 *v17; // [rsp+0h] [rbp-18h]
  __int64 v18; // [rsp+8h] [rbp-10h]
  __int64 v19; // [rsp+10h] [rbp-8h]

  v19 = v0;
  *(_QWORD *)camlCamlinternalOO[39] += 2LL;
  v18 = (*(_QWORD *)(v0 - 8) >> 9) | 1LL;
  v2 = camlCamlinternalOO[40];
  v3 = 2 * v18 + 3;
  caml_c_call(v3, v2);
  v5 = v4;
  v17 = v4;
  if ( *(v4 - 1) >> 9 <= 1 )
    goto LABEL_20;
  v3 = (unsigned __int64)v4;
  v2 = v18;
  caml_modify(v4, v18);
  if ( *(v5 - 1) >> 9 <= 3 )
  {
LABEL_19:
    caml_ml_array_bound_error(v3, v2);
LABEL_20:
    caml_ml_array_bound_error(v3, v2);
    return camlCamlinternalOO__resize_191();
  }
  v2 = 2 * ((((camlSys[4] >> 1) * (camlCamlinternalOO__fit_size_184() - 1) + 1) >> 1) / 8) - 3 + 2;
  v6 = v17;
  v7 = v17 + 1;
  caml_modify(v17 + 1, v2);
  v12 = 1LL;
  if ( v18 - 2 >= 1 )
  {
    while ( 1 )
    {
      v3 = 2 * v12 + 5;
      if ( *(v6 - 1) >> 9 <= v3 )
        break;
      v13 = v19;
      v14 = *(_QWORD *)(v19 - 8);
      v2 = (unsigned __int8)v14;
      if ( (unsigned __int8)v14 == 254LL )
      {
        if ( v14 >> 9 <= v12 )
        {
          caml_ml_array_bound_error(v3, 0xFEuLL);
LABEL_17:
          caml_ml_array_bound_error(v3, v2);
          break;
        }
        while ( 1 )
        {
          v1 -= 16LL;
          if ( v1 >= caml_young_limit )
            break;
          caml_call_gc(v3, 254LL, v13, v9, v10, v11, (char)v17);
        }
        v2 = v1 + 8;
        *(_QWORD *)v1 = 1277LL;
        *(double *)(v1 + 8) = *(double *)(v13 + 4 * v12 - 4);
      }
      else
      {
        if ( v14 >> 9 <= v12 )
          goto LABEL_17;
        v2 = *(_QWORD *)(v19 + 4 * v12 - 4);
      }
      v7 = (unsigned __int64 *)((char *)v6 + 4 * v3 - 4);
      caml_modify(v7, v2);
      v15 = v12;
      v12 += 2LL;
      if ( v15 == v18 - 2 )
        goto LABEL_12;
    }
    caml_ml_array_bound_error(v3, v2);
    goto LABEL_19;
  }
LABEL_12:
  while ( 1 )
  {
    v1 -= 72LL;
    if ( v1 >= caml_young_limit )
      break;
    caml_call_gc((__int64)v7, v2, v8, v9, v10, v11, (char)v17);
  }
  result = v1 + 8;
  *(_QWORD *)v1 = 0x2000LL;
  *(_QWORD *)(v1 + 8) = 5LL;
  *(_QWORD *)(v1 + 16) = v6;
  *(_QWORD *)(v1 + 24) = 1LL;
  *(_QWORD *)(v1 + 32) = 1LL;
  *(_QWORD *)(v1 + 40) = 1LL;
  *(_QWORD *)(v1 + 48) = 1LL;
  *(_QWORD *)(v1 + 56) = 1LL;
  *(_QWORD *)(v1 + 64) = 1LL;
  return result;
}
// 422C34: variable 'v0' is possibly undefined
// 422C7B: variable 'v4' is possibly undefined
// 422D79: variable 'v1' is possibly undefined
// 422D99: variable 'v13' is possibly undefined
// 422E19: variable 'v8' is possibly undefined
// 422E19: variable 'v9' is possibly undefined
// 422E19: variable 'v10' is possibly undefined
// 422E19: variable 'v11' is possibly undefined
// 422E19: variable 'v17' is possibly undefined
// 6515D0: using guessed type __int64 camlSys[33];
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000422E50) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__resize_191()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  unsigned __int64 *v2; // rax
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v7; // [rsp+0h] [rbp-18h]
  __int64 v8; // [rsp+8h] [rbp-10h]
  unsigned __int64 v9; // [rsp+10h] [rbp-8h]

  if ( v1 > ((*(_QWORD *)(*(_QWORD *)(v0 + 8) - 8LL) >> 9) | 1LL) )
  {
    v7 = (*(_QWORD *)(*(_QWORD *)(v0 + 8) - 8LL) >> 9) | 1LL;
    v8 = v0;
    caml_c_call(v1, camlCamlinternalOO[40]);
    v9 = (unsigned __int64)v2;
    camlArray__blit_120(v2, 1LL, v7, v3, v4, v5);
    caml_modify((unsigned __int64 *)(v8 + 8), v9);
  }
  return 1LL;
}
// 422E67: variable 'v1' is possibly undefined
// 422E54: variable 'v0' is possibly undefined
// 422E92: variable 'v2' is possibly undefined
// 422EB2: variable 'v3' is possibly undefined
// 422EB2: variable 'v4' is possibly undefined
// 422EB2: variable 'v5' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (0000000000422EF0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__put_196(unsigned __int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  unsigned __int64 v3; // rbx
  __int64 v4; // rdi
  __int64 v6; // [rsp+0h] [rbp-18h]

  v6 = v2;
  camlCamlinternalOO__resize_191();
  v4 = *(_QWORD *)(v6 + 8);
  if ( *(_QWORD *)(v4 - 8) >> 9 <= v3 )
  {
    caml_ml_array_bound_error(v4, a2);
    return camlCamlinternalOO__new_method_203();
  }
  else
  {
    caml_modify((unsigned __int64 *)(v4 + 4 * v3 - 4), a1);
    return 1LL;
  }
}
// 422EF4: variable 'v2' is possibly undefined
// 422F23: variable 'v3' is possibly undefined

//----- (0000000000422F50) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__new_method_203()
{
  __int64 v0; // rax
  __int64 v2; // [rsp+0h] [rbp-8h]

  v2 = (*(_QWORD *)(*(_QWORD *)(v0 + 8) - 8LL) >> 9) | 1LL;
  camlCamlinternalOO__resize_191();
  return v2;
}
// 422F54: variable 'v0' is possibly undefined

//----- (0000000000422F80) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__get_method_label_206(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  _QWORD *v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  _QWORD *v17; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // [rsp+8h] [rbp-10h]
  __int64 v24; // [rsp+10h] [rbp-8h]

  v7 = v6;
  v23 = v6;
  if ( *(char ***)sub_423040(a1, v6, a3, a4, a5, a6) == &caml_exn_Not_found )
  {
    v24 = camlCamlinternalOO__new_method_203();
    v12 = camlMap__add_121(*(__int64 **)(v23 + 16), *(_QWORD *)(camlCamlinternalOO[37] + 16LL), v8, v9, v10, v11);
    caml_modify((unsigned __int64 *)(v23 + 16), (unsigned __int64)v12);
    v17 = camlMap__add_121(*(__int64 **)(v23 + 24), *(_QWORD *)(camlCamlinternalOO[38] + 16LL), v13, v14, v15, v16);
    caml_modify((unsigned __int64 *)(v23 + 24), (unsigned __int64)v17);
    return v24;
  }
  else
  {
    caml_raise_exn();
    return sub_423040((__int64)&caml_exn_Not_found, v7, v19, v20, v21, v22);
  }
}
// 422F84: variable 'v6' is possibly undefined
// 422FDC: variable 'v8' is possibly undefined
// 422FDC: variable 'v9' is possibly undefined
// 422FDC: variable 'v10' is possibly undefined
// 422FDC: variable 'v11' is possibly undefined
// 423017: variable 'v13' is possibly undefined
// 423017: variable 'v14' is possibly undefined
// 423017: variable 'v15' is possibly undefined
// 423017: variable 'v16' is possibly undefined
// 42303E: variable 'v19' is possibly undefined
// 42303E: variable 'v20' is possibly undefined
// 42303E: variable 'v21' is possibly undefined
// 42303E: variable 'v22' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (0000000000423040) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_423040(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return camlMap__find_130(*(_QWORD *)(camlCamlinternalOO[37] + 24LL), a2, a3, a4, a5, a6);
}
// 42306A: positive sp value 20 has been found
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (0000000000423070) ----------------------------------------------------
void *__fastcall camlCamlinternalOO__get_method_labels_210(__int64 a1, __int64 a2)
{
  void (*v2)(void); // rdi
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9

  v2 = *(void (**)(void))camlCamlinternalOO[6];
  v2();
  return camlArray__map_132((__int64)v2, a2, v3, v4, v5, v6);
}
// 423090: variable 'v3' is possibly undefined
// 423090: variable 'v4' is possibly undefined
// 423090: variable 'v5' is possibly undefined
// 423090: variable 'v6' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (00000000004230A0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__set_method_213(
        unsigned __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  unsigned __int64 v9; // rsi
  __int64 v10; // rdi
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // [rsp+0h] [rbp-18h]

  v9 = v6;
  v16 = v6;
  *(_QWORD *)camlCamlinternalOO[45] += 2LL;
  v10 = *(_QWORD *)(camlCamlinternalOO[38] + 24LL);
  if ( camlMap__find_130(v10, v6, a3, a4, a5, a6) != 1 )
    return camlCamlinternalOO__put_196(a1, v9);
  while ( 1 )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(v10, v9, v11, v12, v13, v14, v16);
  }
  *v8 = 2048LL;
  v8[1] = v7;
  v8[2] = a1;
  v8[3] = 2048LL;
  v8[4] = v8 + 1;
  v8[5] = *(_QWORD *)(v16 + 40);
  caml_modify((unsigned __int64 *)(v16 + 40), (unsigned __int64)(v8 + 4));
  return 1LL;
}
// 4230A4: variable 'v6' is possibly undefined
// 423104: variable 'v8' is possibly undefined
// 423125: variable 'v7' is possibly undefined
// 423144: variable 'v16' is possibly undefined
// 423161: variable 'v11' is possibly undefined
// 423161: variable 'v12' is possibly undefined
// 423161: variable 'v13' is possibly undefined
// 423161: variable 'v14' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000423170) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__get_method_217(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rbx
  __int64 v8; // rdi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // [rsp+0h] [rbp-18h]

  v18 = v6;
  if ( *(char ***)sub_4231C4(v6, a2, a3, a4, a5, a6) == &caml_exn_Not_found )
  {
    v8 = *(_QWORD *)(v18 + 8);
    if ( *(_QWORD *)(v8 - 8) >> 9 <= v7 )
    {
      caml_ml_array_bound_error(v8, a2);
      return camlCamlinternalOO__to_list_220(v8, a2, v14, v15, v16, v17);
    }
    else
    {
      return *(_QWORD *)(v8 + 4 * v7 - 4);
    }
  }
  else
  {
    caml_raise_exn();
    return sub_4231C4((__int64)&caml_exn_Not_found, a2, v10, v11, v12, v13);
  }
}
// 423177: variable 'v6' is possibly undefined
// 4231AF: variable 'v7' is possibly undefined
// 4231C2: variable 'v10' is possibly undefined
// 4231C2: variable 'v11' is possibly undefined
// 4231C2: variable 'v12' is possibly undefined
// 4231C2: variable 'v13' is possibly undefined
// 4231E3: variable 'v14' is possibly undefined
// 4231E3: variable 'v15' is possibly undefined
// 4231E3: variable 'v16' is possibly undefined
// 4231E3: variable 'v17' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;

//----- (00000000004231C4) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_4231C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return camlList__assoc_197(a1, a2, a3, a4, a5, a6);
}
// 4231DC: positive sp value 20 has been found

//----- (00000000004231F0) ----------------------------------------------------
unsigned __int64 __fastcall camlCamlinternalOO__to_list_220(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax

  if ( v6 == 1 )
    return 1LL;
  else
    return camlArray__to_list_148(a1, a2, a3, a4, a5, a6);
}
// 4231F4: variable 'v6' is possibly undefined

//----- (0000000000423210) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__narrow_222(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned __int64 *v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  void (*v16)(void); // rdi
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rsi
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rsi
  __int64 v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // r8
  __int64 v30; // r9
  __int64 v31; // rsi
  __int64 v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // r8
  __int64 v35; // r9
  __int64 v36; // rsi
  __int64 v37; // rdx
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  __int64 v41; // rax
  char v43; // [rsp+0h] [rbp-38h]
  __int64 v44; // [rsp+8h] [rbp-30h]
  unsigned __int64 v45; // [rsp+10h] [rbp-28h]
  unsigned __int64 *v46; // [rsp+10h] [rbp-28h]
  unsigned __int64 *v47; // [rsp+20h] [rbp-18h]
  __int64 v48; // [rsp+28h] [rbp-10h]
  unsigned __int64 *v49; // [rsp+30h] [rbp-8h]

  v49 = v6;
  v45 = camlCamlinternalOO__to_list_220(a1, a2, a3, a4, a5, a6);
  camlCamlinternalOO__to_list_220(a1, a2, v8, v9, v10, v11);
  v43 = camlCamlinternalOO__to_list_220(a1, a2, v12, v13, v14, v15);
  (*(void (**)(void))camlCamlinternalOO[6])();
  v48 = camlList__map_90();
  v16 = *(void (**)(void))camlCamlinternalOO[6];
  v16();
  v44 = camlList__map_90();
  while ( 1 )
  {
    v7 -= 10;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc((__int64)v16, a2, v17, v18, v19, v20, v43);
  }
  *v7 = 6144LL;
  v7[1] = v49[2];
  v7[2] = v49[3];
  v7[3] = v49[5];
  v7[4] = v49[6];
  v7[5] = v48;
  v7[6] = v45;
  v21 = (__int64)(v7 + 8);
  v7[7] = 2048LL;
  v7[8] = v7 + 1;
  v7[9] = v49[4];
  caml_modify(v49 + 4, (unsigned __int64)(v7 + 8));
  while ( 1 )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc((__int64)(v49 + 4), v21, v22, v23, v24, v25, v43);
  }
  *v7 = 4343LL;
  v7[1] = caml_curry3;
  v7[2] = 7LL;
  v7[3] = camlCamlinternalOO__code_begin;
  v7[4] = v45;
  v26 = camlMap__fold_195(1LL);
  caml_modify(v49 + 6, v26);
  while ( 1 )
  {
    v7 -= 11;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc((__int64)(v49 + 6), v26, v27, v28, v29, v30, v43);
  }
  v46 = v7 + 1;
  *v7 = 1024LL;
  v7[1] = 1LL;
  v31 = (__int64)(v7 + 3);
  v47 = v7 + 3;
  v7[2] = 1024LL;
  v7[3] = 1LL;
  v7[4] = 6391LL;
  v7[5] = caml_curry2;
  v7[6] = 5LL;
  v7[7] = camlCamlinternalOO__fun_727;
  v7[8] = v49;
  v7[9] = v7 + 1;
  v7[10] = v7 + 3;
  camlList__iter2_139(v44, (__int64)(v7 + 3), (__int64)(v7 + 1), v28, v29, v30);
  while ( 1 )
  {
    v7 -= 6;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc(v44, v31, v32, v33, v34, v35, v43);
  }
  *v7 = 5367LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlCamlinternalOO__fun_730;
  v7[4] = v46;
  v7[5] = v47;
  camlList__iter2_139(v48, v31, v32, v33, v34, v35);
  caml_modify(v49 + 2, *v46);
  v36 = *v47;
  caml_modify(v49 + 3, *v47);
  while ( 1 )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc((__int64)(v49 + 3), v36, v37, v38, v39, v40, v43);
  }
  *v7 = 4343LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlCamlinternalOO__fun_733;
  v7[4] = v48;
  v41 = camlList__fold_right_112(1LL);
  caml_modify(v49 + 5, v41);
  return 1LL;
}
// 423210: could not find valid save-restore pair for rbp
// 423214: variable 'v6' is possibly undefined
// 423233: variable 'v8' is possibly undefined
// 423233: variable 'v9' is possibly undefined
// 423233: variable 'v10' is possibly undefined
// 423233: variable 'v11' is possibly undefined
// 423242: variable 'v12' is possibly undefined
// 423242: variable 'v13' is possibly undefined
// 423242: variable 'v14' is possibly undefined
// 423242: variable 'v15' is possibly undefined
// 423292: variable 'v7' is possibly undefined
// 4233F2: variable 'v28' is possibly undefined
// 4233F2: variable 'v29' is possibly undefined
// 4233F2: variable 'v30' is possibly undefined
// 423450: variable 'v32' is possibly undefined
// 423450: variable 'v33' is possibly undefined
// 423450: variable 'v34' is possibly undefined
// 423450: variable 'v35' is possibly undefined
// 4234F1: variable 'v37' is possibly undefined
// 4234F1: variable 'v38' is possibly undefined
// 4234F1: variable 'v39' is possibly undefined
// 4234F1: variable 'v40' is possibly undefined
// 4234F1: variable 'v43' is possibly undefined
// 423502: variable 'v27' is possibly undefined
// 42350C: variable 'v22' is possibly undefined
// 42350C: variable 'v23' is possibly undefined
// 42350C: variable 'v24' is possibly undefined
// 42350C: variable 'v25' is possibly undefined
// 423516: variable 'v17' is possibly undefined
// 423516: variable 'v18' is possibly undefined
// 423516: variable 'v19' is possibly undefined
// 423516: variable 'v20' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000423520) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__widen_244(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned __int64 *v6; // rax
  _QWORD *v7; // r15
  unsigned __int64 *v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rsi
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rax
  unsigned __int64 v25; // [rsp+0h] [rbp-38h]
  __int64 v26; // [rsp+8h] [rbp-30h]
  unsigned __int64 v27; // [rsp+10h] [rbp-28h]
  unsigned __int64 v28; // [rsp+18h] [rbp-20h]
  unsigned __int64 v29; // [rsp+20h] [rbp-18h]
  __int64 v30; // [rsp+28h] [rbp-10h]
  unsigned __int64 *v31; // [rsp+30h] [rbp-8h]

  v31 = v6;
  v8 = (unsigned __int64 *)camlList__hd_64(a1, a2, a3, a4, a5, a6);
  v26 = v8[5];
  v29 = v8[4];
  v25 = v8[3];
  v30 = v8[2];
  v28 = v8[1];
  v27 = *v8;
  v13 = camlList__tl_67(a1, a2, v9, v10, v11, v12);
  caml_modify(v31 + 4, v13);
  while ( 1 )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc((__int64)(v31 + 4), v13, v14, v15, v16, v17, v25);
  }
  *v7 = 4343LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlCamlinternalOO__fun_737;
  v7[4] = v31;
  v18 = camlList__fold_left_106(v26);
  caml_modify(v31 + 6, v18);
  caml_modify(v31 + 2, v27);
  caml_modify(v31 + 3, v28);
  while ( 1 )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc((__int64)(v31 + 3), v28, v19, v20, v21, v22, v25);
  }
  *v7 = 4343LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlCamlinternalOO__fun_740;
  v7[4] = v29;
  v23 = camlList__fold_right_112(v30);
  caml_modify(v31 + 5, v23);
  return 1LL;
}
// 423524: variable 'v6' is possibly undefined
// 42356F: variable 'v9' is possibly undefined
// 42356F: variable 'v10' is possibly undefined
// 42356F: variable 'v11' is possibly undefined
// 42356F: variable 'v12' is possibly undefined
// 423588: variable 'v7' is possibly undefined
// 42367A: variable 'v19' is possibly undefined
// 42367A: variable 'v20' is possibly undefined
// 42367A: variable 'v21' is possibly undefined
// 42367A: variable 'v22' is possibly undefined
// 42367A: variable 'v25' is possibly undefined
// 423681: variable 'v14' is possibly undefined
// 423681: variable 'v15' is possibly undefined
// 423681: variable 'v16' is possibly undefined
// 423681: variable 'v17' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000423690) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__new_slot_257()
{
  __int64 *v0; // rax
  __int64 *v1; // rdi
  __int64 result; // rax

  v1 = v0;
  result = *v0;
  *v1 = result + 2;
  return result;
}
// 423690: variable 'v0' is possibly undefined

//----- (00000000004236B0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__new_variable_260(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // rbx
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  _QWORD *v13; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r9
  __int64 v19; // [rsp+8h] [rbp-10h]
  __int64 v20; // [rsp+10h] [rbp-8h]

  v8 = v6;
  v20 = v6;
  if ( *(char ***)sub_423748(a1, v6, a3, a4, a5, a6) == &caml_exn_Not_found )
  {
    v19 = camlCamlinternalOO__new_slot_257();
    if ( caml_string_notequal(v7, camlCamlinternalOO__73) != 1 )
    {
      v13 = camlMap__add_121(*(__int64 **)(v20 + 48), *(_QWORD *)(camlCamlinternalOO[36] + 16LL), v9, v10, v11, v12);
      caml_modify((unsigned __int64 *)(v20 + 48), (unsigned __int64)v13);
    }
    return v19;
  }
  else
  {
    caml_raise_exn();
    return sub_423748((__int64)&caml_exn_Not_found, v8, v15, v16, v17, v18);
  }
}
// 4236B0: could not find valid save-restore pair for rbp
// 4236B4: variable 'v6' is possibly undefined
// 4236F7: variable 'v7' is possibly undefined
// 423720: variable 'v9' is possibly undefined
// 423720: variable 'v10' is possibly undefined
// 423720: variable 'v11' is possibly undefined
// 423720: variable 'v12' is possibly undefined
// 423746: variable 'v15' is possibly undefined
// 423746: variable 'v16' is possibly undefined
// 423746: variable 'v17' is possibly undefined
// 423746: variable 'v18' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];
// 6568A0: using guessed type _QWORD camlCamlinternalOO__73[2];

//----- (0000000000423748) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_423748(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return camlMap__find_130(*(_QWORD *)(camlCamlinternalOO[36] + 24LL), a2, a3, a4, a5, a6);
}
// 423772: positive sp value 20 has been found
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (0000000000423780) ----------------------------------------------------
void *__fastcall camlCamlinternalOO__to_array_264()
{
  __int64 v0; // rax
  __int64 v1; // rax
  __int64 v3; // [rsp+0h] [rbp-8h]

  v3 = v0;
  caml_c_call(v0, 1uLL);
  if ( v1 == 1 )
    return (void *)v3;
  else
    return &camlCamlinternalOO__72;
}
// 423784: variable 'v0' is possibly undefined
// 4237A2: variable 'v1' is possibly undefined

//----- (00000000004237C0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__new_methods_variables_266(__int64 a1)
{
  unsigned __int64 v1; // rsi
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  __int64 v7; // rbx
  unsigned __int64 v8; // rdi
  __int64 v9; // rsi
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v15; // [rsp+0h] [rbp-48h]
  __int64 v16; // [rsp+8h] [rbp-40h]
  _QWORD *v18; // [rsp+18h] [rbp-30h]
  __int64 v19; // [rsp+18h] [rbp-30h]
  __int64 v20; // [rsp+20h] [rbp-28h]
  __int64 v21; // [rsp+30h] [rbp-18h]
  __int64 v22; // [rsp+30h] [rbp-18h]

  v18 = camlCamlinternalOO__to_array_264();
  v16 = (*(v18 - 1) >> 9) | 1LL;
  v15 = (*(_QWORD *)(a1 - 8) >> 9) | 1LL;
  v1 = 1LL;
  caml_c_call(v16 + v15 - 1, 1uLL);
  v7 = v2;
  v8 = 1LL;
  if ( v16 - 2 < 1 )
  {
LABEL_6:
    v8 = 1LL;
    if ( v15 - 2 < 1 )
      return v7;
    v19 = 1LL;
    v22 = v7;
    while ( 1 )
    {
      v1 = v8 + v16 - 1;
      if ( *(_QWORD *)(v7 - 8) >> 9 <= v1 )
        break;
      if ( *(_QWORD *)(a1 - 8) >> 9 <= v8 )
      {
        caml_ml_array_bound_error(v8, v1);
        break;
      }
      v7 = v22;
      *(_QWORD *)(v22 + 4 * v1 - 4) = camlCamlinternalOO__new_variable_260(v8, v1, v3, v4, v5, v6);
      v9 = v19;
      v8 = v19 + 2;
      v19 += 2LL;
      if ( v9 == v15 - 2 )
        return v7;
    }
    caml_ml_array_bound_error(v8, v1);
LABEL_14:
    caml_ml_array_bound_error(v8, v1);
  }
  else
  {
    v20 = 1LL;
    v21 = v2;
    while ( *(_QWORD *)(v7 - 8) >> 9 > v8 )
    {
      if ( *(v18 - 1) >> 9 <= v8 )
        goto LABEL_14;
      v7 = v21;
      *(_QWORD *)(v21 + 4 * v20 - 4) = camlCamlinternalOO__get_method_label_206(v8, v1, v3, v4, v5, v6);
      v1 = v20;
      v8 = v20 + 2;
      v20 += 2LL;
      if ( v1 == v16 - 2 )
        goto LABEL_6;
    }
  }
  caml_ml_array_bound_error(v8, v1);
  return camlCamlinternalOO__get_variable_276(v8, v1, v11, v12, v13, v14);
}
// 423819: variable 'v2' is possibly undefined
// 423871: variable 'v3' is possibly undefined
// 423871: variable 'v4' is possibly undefined
// 423871: variable 'v5' is possibly undefined
// 423871: variable 'v6' is possibly undefined
// 42393F: variable 'v11' is possibly undefined
// 42393F: variable 'v12' is possibly undefined
// 42393F: variable 'v13' is possibly undefined
// 42393F: variable 'v14' is possibly undefined

//----- (0000000000423940) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__get_variable_276(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  char v18; // [rsp+0h] [rbp-8h]

  v8 = v6;
  if ( *(char ***)sub_42399C(a1, v6, a3, a4, a5, a6) == &caml_exn_Not_found )
  {
    while ( 1 )
    {
      v7 -= 3;
      if ( (unsigned __int64)v7 >= caml_young_limit )
        break;
      caml_call_gc((__int64)&caml_exn_Not_found, v8, v9, v10, v11, v12, v18);
    }
    *v7 = 2048LL;
    v7[1] = &caml_exn_Assert_failure;
    v7[2] = &camlCamlinternalOO__71;
    caml_raise_exn();
  }
  caml_raise_exn();
  return sub_42399C((__int64)&caml_exn_Not_found, v8, v13, v14, v15, v16);
}
// 423944: variable 'v6' is possibly undefined
// 42395E: variable 'v7' is possibly undefined
// 42399A: variable 'v13' is possibly undefined
// 42399A: variable 'v14' is possibly undefined
// 42399A: variable 'v15' is possibly undefined
// 42399A: variable 'v16' is possibly undefined
// 4239C7: variable 'v9' is possibly undefined
// 4239C7: variable 'v10' is possibly undefined
// 4239C7: variable 'v11' is possibly undefined
// 4239C7: variable 'v12' is possibly undefined
// 4239C7: variable 'v18' is possibly undefined
// 647B68: using guessed type char *caml_exn_Not_found;
// 647C48: using guessed type char *caml_exn_Assert_failure;
// 656858: using guessed type char *camlCamlinternalOO__71;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000042399C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_42399C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return camlMap__find_130(*(_QWORD *)(camlCamlinternalOO[36] + 24LL), a2, a3, a4, a5, a6);
}
// 4239C6: positive sp value 10 has been found
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (00000000004239D0) ----------------------------------------------------
void *__fastcall camlCamlinternalOO__get_variables_279(__int64 a1, __int64 a2)
{
  void (*v2)(void); // rdi
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9

  v2 = *(void (**)(void))camlCamlinternalOO[4];
  v2();
  return camlArray__map_132((__int64)v2, a2, v3, v4, v5, v6);
}
// 4239F0: variable 'v3' is possibly undefined
// 4239F0: variable 'v4' is possibly undefined
// 4239F0: variable 'v5' is possibly undefined
// 4239F0: variable 'v6' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (0000000000423A00) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__add_initializer_282(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdi
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v11) )
  {
    v8 -= 3;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  *v8 = 2048LL;
  v8[1] = v7;
  v8[2] = *(_QWORD *)(i + 56);
  caml_modify((unsigned __int64 *)(i + 56), (unsigned __int64)(v8 + 1));
  return 1LL;
}
// 423A04: variable 'v6' is possibly undefined
// 423A07: variable 'v8' is possibly undefined
// 423A23: variable 'v7' is possibly undefined
// 423A43: variable 'a3' is possibly undefined
// 423A43: variable 'a4' is possibly undefined
// 423A43: variable 'a5' is possibly undefined
// 423A43: variable 'a6' is possibly undefined
// 423A43: variable 'v11' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000423A50) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__create_table_285(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 i; // rdi
  __int64 v12; // r8
  __int64 v13; // r9
  char v14; // [rsp+0h] [rbp-18h]

  if ( v6 == 1 )
    return camlCamlinternalOO__new_table_186();
  v14 = v6;
  camlArray__map_132(a1, a2, a3, a4, a5, a6);
  for ( i = camlCamlinternalOO__new_table_186(); ; caml_call_gc(i, a2, v9, v10, v12, v13, v14) )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 4343LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlCamlinternalOO__fun_751;
  v7[4] = i;
  camlArray__iteri_138(i, a2, v9, v10, v12, v13);
  return i;
}
// 423A5B: variable 'v6' is possibly undefined
// 423A90: variable 'v7' is possibly undefined
// 423AD1: variable 'v9' is possibly undefined
// 423AD1: variable 'v10' is possibly undefined
// 423AD1: variable 'v12' is possibly undefined
// 423AD1: variable 'v13' is possibly undefined
// 423AE0: variable 'v14' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000423AF0) ----------------------------------------------------
__int64 (__fastcall **__fastcall camlCamlinternalOO__init_class_292(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        double a7))()
{
  __int64 *v7; // rax
  _QWORD *v8; // rsi
  __int64 v9; // rdi
  _QWORD *appended; // rax
  __int64 v11; // rdi
  unsigned __int64 v12; // rsi
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 *v18; // [rsp+0h] [rbp-8h]

  v18 = v7;
  v8 = (_QWORD *)camlCamlinternalOO[46];
  v9 = *v7;
  *v8 = *v8 + *v7 - 3;
  appended = camlList__rev_append_79(v9, (__int64)v8, a3, a4, a5, a6);
  v11 = (__int64)(v18 + 7);
  v12 = (unsigned __int64)appended;
  caml_modify((unsigned __int64 *)v18 + 7, (unsigned __int64)appended);
  if ( !(camlSys[4] >> 1) )
  {
    caml_raise_exn();
    return (__int64 (__fastcall **)())camlCamlinternalOO__resize_191();
  }
  if ( *(_QWORD *)(v18[1] - 8) >> 9 > 3uLL )
    return (__int64 (__fastcall **)())camlCamlinternalOO__resize_191();
  caml_ml_array_bound_error(v11, v12);
  return camlCamlinternalOO__inherits_294(v11, v12, v14, v15, v16, v17, a7);
}
// 423AF0: could not find valid save-restore pair for rbp
// 423AF4: variable 'v7' is possibly undefined
// 423BAD: variable 'v14' is possibly undefined
// 423BAD: variable 'v15' is possibly undefined
// 423BAD: variable 'v16' is possibly undefined
// 423BAD: variable 'v17' is possibly undefined
// 6515D0: using guessed type __int64 camlSys[33];
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (0000000000423BB0) ----------------------------------------------------
__int64 (__fastcall **__fastcall camlCamlinternalOO__inherits_294(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        double a7))()
{
  __int64 v7; // rax
  _QWORD *v8; // r15
  __int64 (__fastcall *v9)(double); // rdi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdx
  __int64 v19; // rcx
  void *v20; // rbx
  __int64 v21; // r8
  __int64 v22; // r9
  void (__fastcall *v23)(double); // rdi
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // r8
  __int64 v27; // r9
  __int64 v28; // rdx
  __int64 v29; // rcx
  void *i; // rdi
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 v33; // rdi
  __int64 v34; // rdx
  __int64 v35; // rcx
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 v38; // rax
  __int64 v39; // rbx
  __int64 v41; // [rsp+0h] [rbp-38h]
  char v42; // [rsp+0h] [rbp-38h]
  _QWORD *v43; // [rsp+0h] [rbp-38h]
  _QWORD *v44; // [rsp+8h] [rbp-30h]
  __int64 v45; // [rsp+18h] [rbp-20h]
  __int64 v46; // [rsp+20h] [rbp-18h]
  __int64 (__fastcall **v47)(double); // [rsp+28h] [rbp-10h]

  v46 = v7;
  v41 = a4;
  v47 = *(__int64 (__fastcall ***)(double))(a3 + 8);
  camlCamlinternalOO__narrow_222(a1, a2, (__int64)v47, *(_QWORD *)(a3 + 24), a5, a6);
  if ( v41 == 1 )
  {
    v9 = *v47;
    v45 = (*v47)(a7);
  }
  else
  {
    v9 = (__int64 (__fastcall *)(double))v47;
    v45 = caml_apply2((__int64)v47);
  }
  camlCamlinternalOO__widen_244((__int64)v9, a2, v10, v11, v12, v13);
  camlCamlinternalOO__to_array_264();
  while ( 1 )
  {
    v8 -= 4;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc((__int64)v9, a2, v14, v15, v16, v17, v41);
  }
  *v8 = 3319LL;
  v8[1] = camlCamlinternalOO__fun_757;
  v8[2] = 3LL;
  v8[3] = v46;
  v20 = camlArray__map_132(v46, a2, v14, v15, v16, v17);
  while ( 1 )
  {
    v8 -= 3;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(v46, a2, v18, v19, v21, v22, v41);
  }
  v44 = v8 + 1;
  *v8 = 2048LL;
  v8[1] = v20;
  v8[2] = 1LL;
  v42 = (unsigned __int8)camlCamlinternalOO__to_array_264();
  v23 = *(void (__fastcall **)(double))camlCamlinternalOO[4];
  v23(a7);
  for ( i = camlArray__map_132((__int64)v23, a2, v24, v25, v26, v27);
        ;
        caml_call_gc((__int64)i, a2, v28, v29, v31, v32, v42) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  v43 = v8 + 1;
  *v8 = 2048LL;
  v8[1] = i;
  v8[2] = v44;
  v33 = (__int64)(v8 + 4);
  v8[3] = 1024LL;
  v8[4] = v45;
  caml_c_call((__int64)(v8 + 4), a2);
  v39 = v38;
  while ( 1 )
  {
    v8 -= 3;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc(v33, a2, v34, v35, v36, v37, (char)v43);
  }
  *v8 = 2048LL;
  v8[1] = v39;
  v8[2] = v43;
  return camlArray__concat_103(a7, v33, a2, v34, v35, v36, v37);
}
// 423BB0: could not find valid save-restore pair for rbx
// 423BB4: variable 'v7' is possibly undefined
// 423C1D: variable 'v10' is possibly undefined
// 423C1D: variable 'v11' is possibly undefined
// 423C1D: variable 'v12' is possibly undefined
// 423C1D: variable 'v13' is possibly undefined
// 423C2F: variable 'v8' is possibly undefined
// 423C6A: variable 'v14' is possibly undefined
// 423C6A: variable 'v15' is possibly undefined
// 423C6A: variable 'v16' is possibly undefined
// 423C6A: variable 'v17' is possibly undefined
// 423CC9: variable 'v24' is possibly undefined
// 423CC9: variable 'v25' is possibly undefined
// 423CC9: variable 'v26' is possibly undefined
// 423CC9: variable 'v27' is possibly undefined
// 423D1D: variable 'v38' is possibly undefined
// 423D43: variable 'v43' is possibly undefined
// 423D4B: variable 'v34' is possibly undefined
// 423D4B: variable 'v35' is possibly undefined
// 423D4B: variable 'v36' is possibly undefined
// 423D4B: variable 'v37' is possibly undefined
// 423D57: variable 'v28' is possibly undefined
// 423D57: variable 'v29' is possibly undefined
// 423D57: variable 'v31' is possibly undefined
// 423D57: variable 'v32' is possibly undefined
// 423D57: variable 'v42' is possibly undefined
// 423D61: variable 'v18' is possibly undefined
// 423D61: variable 'v19' is possibly undefined
// 423D61: variable 'v21' is possibly undefined
// 423D61: variable 'v22' is possibly undefined
// 423D61: variable 'v41' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000423D80) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__make_class_304(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        double a7)
{
  __int64 (__fastcall **v7)(double); // rbx
  _QWORD *v8; // r15
  __int64 (__fastcall *v9)(double); // rdi
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 (*v14)(void); // rdi
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // rbx
  __int64 v18; // r8
  __int64 v19; // r9
  _QWORD *result; // rax
  char table_285; // [rsp+0h] [rbp-18h]
  __int64 (__fastcall **v22)(double); // [rsp+8h] [rbp-10h]
  __int64 (**v23)(void); // [rsp+10h] [rbp-8h]

  v22 = v7;
  table_285 = camlCamlinternalOO__create_table_285(a1, a2, a3, a4, a5, a6);
  v9 = *v7;
  v23 = (__int64 (**)(void))(*v7)(a7);
  camlCamlinternalOO__init_class_292((__int64)v9, a2, v10, v11, v12, v13, a7);
  v14 = *v23;
  v17 = (*v23)();
  while ( 1 )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
    caml_call_gc((__int64)v14, a2, v15, v16, v18, v19, table_285);
  }
  result = v8 + 1;
  *v8 = 4096LL;
  v8[1] = v17;
  v8[2] = v22;
  v8[3] = v23;
  v8[4] = 1LL;
  return result;
}
// 423D80: could not find valid save-restore pair for rbx
// 423D84: variable 'v7' is possibly undefined
// 423DA5: variable 'v10' is possibly undefined
// 423DA5: variable 'v11' is possibly undefined
// 423DA5: variable 'v12' is possibly undefined
// 423DA5: variable 'v13' is possibly undefined
// 423DBE: variable 'v8' is possibly undefined
// 423DFC: variable 'v15' is possibly undefined
// 423DFC: variable 'v16' is possibly undefined
// 423DFC: variable 'v18' is possibly undefined
// 423DFC: variable 'v19' is possibly undefined
// 423DFC: variable 'table_285' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000423E10) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__make_class_store_314(
        unsigned __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        double a7)
{
  __int64 (__fastcall **v7)(double); // rbx
  __int64 (__fastcall *v8)(double); // rdi
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned __int64 v15; // [rsp+18h] [rbp-10h]

  camlCamlinternalOO__create_table_285((__int64)a1, a2, a3, a4, a5, a6);
  v8 = *v7;
  v15 = (*v7)(a7);
  camlCamlinternalOO__init_class_292((__int64)v8, a2, v9, v10, v11, v12, a7);
  caml_modify(a1 + 1, (unsigned __int64)v7);
  caml_modify(a1, v15);
  return 1LL;
}
// 423E10: could not find valid save-restore pair for rbx
// 423E2C: variable 'v7' is possibly undefined
// 423E3A: variable 'v9' is possibly undefined
// 423E3A: variable 'v10' is possibly undefined
// 423E3A: variable 'v11' is possibly undefined
// 423E3A: variable 'v12' is possibly undefined

//----- (0000000000423E70) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__dummy_class_320(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rdi
  _QWORD *result; // rax
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v10) )
  {
    v7 -= 9;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  *v7 = 3319LL;
  v7[1] = camlCamlinternalOO__undef_322;
  v7[2] = 3LL;
  v7[3] = i;
  result = v7 + 5;
  v7[4] = 4096LL;
  v7[5] = v7 + 1;
  v7[6] = v7 + 1;
  v7[7] = v7 + 1;
  v7[8] = 1LL;
  return result;
}
// 423E74: variable 'v6' is possibly undefined
// 423E77: variable 'v7' is possibly undefined
// 423ECD: variable 'a3' is possibly undefined
// 423ECD: variable 'a4' is possibly undefined
// 423ECD: variable 'a5' is possibly undefined
// 423ECD: variable 'a6' is possibly undefined
// 423ECD: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000423EE0) ----------------------------------------------------
unsigned __int64 *__fastcall camlCamlinternalOO__create_object_323()
{
  unsigned __int64 *v0; // rax
  unsigned __int64 *v1; // rax
  double *v2; // rsi
  unsigned __int64 *v4; // [rsp+0h] [rbp-18h]
  unsigned __int64 *v5; // [rsp+8h] [rbp-10h]

  v4 = v0;
  caml_c_call(497LL, *v0);
  v5 = v1;
  v2 = (double *)v4[1];
  if ( *((unsigned __int8 *)v1 - 8) == 254LL )
    *v1 = *(unsigned __int64 *)v2;
  else
    caml_modify(v1, (unsigned __int64)v2);
  camlCamlinternalOO__set_id_61();
  return v5;
}
// 423EE4: variable 'v0' is possibly undefined
// 423F01: variable 'v1' is possibly undefined

//----- (0000000000423F60) ----------------------------------------------------
unsigned __int64 *__fastcall camlCamlinternalOO__create_object_opt_326()
{
  unsigned __int64 *result; // rax
  unsigned __int64 *v1; // rbx
  unsigned __int64 *v2; // rax
  double *v3; // rsi
  unsigned __int64 *v4; // [rsp+8h] [rbp-10h]

  if ( result == (unsigned __int64 *)1 )
  {
    caml_c_call(497LL, *v1);
    v4 = v2;
    v3 = (double *)v1[1];
    if ( *((unsigned __int8 *)v2 - 8) == 254LL )
      *v2 = *(unsigned __int64 *)v3;
    else
      caml_modify(v2, (unsigned __int64)v3);
    camlCamlinternalOO__set_id_61();
    return v4;
  }
  return result;
}
// 423F68: variable 'result' is possibly undefined
// 423F74: variable 'v1' is possibly undefined
// 423F8D: variable 'v2' is possibly undefined

//----- (0000000000423FE0) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__iter_f_330()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v3; // [rsp+0h] [rbp-18h]
  __int64 v4; // [rsp+8h] [rbp-10h]

  while ( v1 != 1 )
  {
    v3 = v0;
    v4 = *(_QWORD *)(v1 + 8);
    (**(void (***)(void))v1)();
    v0 = v3;
    v1 = v4;
  }
  return 1LL;
}
// 423FE8: variable 'v1' is possibly undefined
// 423FEA: variable 'v0' is possibly undefined

//----- (0000000000424020) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__run_initializers_334()
{
  __int64 v0; // rbx

  if ( *(_QWORD *)(v0 + 56) == 1LL )
    return 1LL;
  else
    return camlCamlinternalOO__iter_f_330();
}
// 424020: variable 'v0' is possibly undefined

//----- (0000000000424040) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__run_initializers_opt_338(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx

  if ( v1 != 1 )
    return v2;
  if ( *(_QWORD *)(a1 + 56) != 1LL )
    camlCamlinternalOO__iter_f_330();
  return v2;
}
// 424048: variable 'v1' is possibly undefined
// 42404A: variable 'v2' is possibly undefined

//----- (0000000000424080) ----------------------------------------------------
unsigned __int64 *__fastcall camlCamlinternalOO__create_object_and_run_initializers_343()
{
  unsigned __int64 *result; // rax
  unsigned __int64 *object_323; // [rsp+8h] [rbp-10h]

  if ( result == (unsigned __int64 *)1 )
  {
    object_323 = camlCamlinternalOO__create_object_323();
    camlCamlinternalOO__run_initializers_334();
    return object_323;
  }
  return result;
}
// 424088: variable 'result' is possibly undefined

//----- (00000000004240C0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__build_path_364(
        __int64 a1,
        _QWORD *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // r13
  unsigned __int64 *v10; // r12
  unsigned __int64 v11; // rbp
  unsigned __int64 v12; // rax
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 i; // [rsp+0h] [rbp-18h]
  _QWORD *v19; // [rsp+8h] [rbp-10h]

  v9 = v6;
  for ( i = a1; ; caml_call_gc(a1, (__int64)a2, a3, a4, a5, a6, i) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  v19 = v8 + 1;
  *v8 = 3072LL;
  v8[1] = 1LL;
  v8[2] = 1LL;
  v8[3] = 1LL;
  v10 = v8 + 5;
  v8[4] = 1024LL;
  v8[5] = v8 + 1;
  v11 = 1LL;
  if ( v9 < 1 )
  {
LABEL_7:
    caml_modify((unsigned __int64 *)(i + 8), *v10);
    return v19;
  }
  else
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v8 -= 4;
        if ( (unsigned __int64)v8 >= caml_young_limit )
          break;
        caml_call_gc(a1, (__int64)a2, a3, a4, a5, a6, i);
      }
      a2 = v8 + 1;
      *v8 = 3072LL;
      if ( *(_QWORD *)(v7 - 8) >> 9 <= v11 )
        break;
      *a2 = *(_QWORD *)(v7 + 4 * v11 - 4);
      v8[2] = *v10;
      v8[3] = 1LL;
      a1 = (__int64)v10;
      caml_modify(v10, (unsigned __int64)a2);
      v12 = v11;
      v11 += 2LL;
      if ( v12 == v9 )
        goto LABEL_7;
    }
    caml_ml_array_bound_error(a1, (unsigned __int64)a2);
    return camlCamlinternalOO__lookup_keys_371(a1, (unsigned __int64)a2, v14, v15, v16, v17);
  }
}
// 4240C4: variable 'v6' is possibly undefined
// 4240CB: variable 'v8' is possibly undefined
// 424140: variable 'v7' is possibly undefined
// 424181: variable 'i' is possibly undefined
// 424194: variable 'a3' is possibly undefined
// 424194: variable 'a4' is possibly undefined
// 424194: variable 'a5' is possibly undefined
// 424194: variable 'a6' is possibly undefined
// 4241AB: variable 'v14' is possibly undefined
// 4241AB: variable 'v15' is possibly undefined
// 4241AB: variable 'v16' is possibly undefined
// 4241AB: variable 'v17' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004241B0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__lookup_keys_371(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 v9; // r8
  __int64 i; // rcx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  char v16; // [rsp+0h] [rbp-8h]

  v9 = v6;
  if ( v6 < 1 )
    return (_QWORD *)a1;
  if ( *(_QWORD *)(v7 - 8) >> 9 <= (unsigned __int64)v6 )
  {
    caml_ml_array_bound_error(a1, a2);
    return camlCamlinternalOO__lookup_tables_379(a1, a2, v12, v13, v14, v15);
  }
  else
  {
    for ( i = *(_QWORD *)(v7 + 4 * v6 - 4); ; caml_call_gc(a1, a2, a3, i, v9, a6, v16) )
    {
      v8 -= 7;
      if ( (unsigned __int64)v8 >= caml_young_limit )
        break;
    }
    *v8 = 6391LL;
    v8[1] = camlCamlinternalOO__lookup_key_376;
    v8[2] = 3LL;
    v8[3] = a2;
    v8[4] = v9;
    v8[5] = v7;
    v8[6] = i;
    return camlCamlinternalOO__lookup_key_376(a1, a2, (__int64)(v8 + 1), i, v9, a6);
  }
}
// 4241B4: variable 'v6' is possibly undefined
// 4241C8: variable 'v7' is possibly undefined
// 4241DA: variable 'v8' is possibly undefined
// 42420C: variable 'v9' is possibly undefined
// 424214: variable 'i' is possibly undefined
// 424222: variable 'a6' is possibly undefined
// 424227: variable 'a3' is possibly undefined
// 424227: variable 'v16' is possibly undefined
// 424234: variable 'v12' is possibly undefined
// 424234: variable 'v13' is possibly undefined
// 424234: variable 'v14' is possibly undefined
// 424234: variable 'v15' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424240) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__lookup_tables_379(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx

  if ( *(_QWORD *)(v6 + 8) == 1LL )
    return camlCamlinternalOO__build_path_364(v6, (_QWORD *)(((*(_QWORD *)(v7 - 8) >> 9) | 1LL) - 2), a3, a4, a5, a6);
  else
    return camlCamlinternalOO__lookup_keys_371(*(_QWORD *)(v6 + 8), camlCamlinternalOO[52], a3, a4, a5, a6);
}
// 424243: variable 'v6' is possibly undefined
// 424274: variable 'v7' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];

//----- (0000000000424290) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__get_const_383(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rdi
  _QWORD *result; // rax
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v10) )
  {
    v7 -= 4;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  result = v7 + 1;
  *v7 = 3319LL;
  v7[1] = camlCamlinternalOO__fun_784;
  v7[2] = 3LL;
  v7[3] = i;
  return result;
}
// 424294: variable 'v6' is possibly undefined
// 424297: variable 'v7' is possibly undefined
// 4242CE: variable 'a3' is possibly undefined
// 4242CE: variable 'a4' is possibly undefined
// 4242CE: variable 'a5' is possibly undefined
// 4242CE: variable 'a6' is possibly undefined
// 4242CE: variable 'v10' is possibly undefined
// 4225C0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_784();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004242E0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__get_var_386(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rdi
  _QWORD *result; // rax
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v10) )
  {
    v7 -= 4;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  result = v7 + 1;
  *v7 = 3319LL;
  v7[1] = camlCamlinternalOO__fun_788;
  v7[2] = 3LL;
  v7[3] = i;
  return result;
}
// 4242E4: variable 'v6' is possibly undefined
// 4242E7: variable 'v7' is possibly undefined
// 42431E: variable 'a3' is possibly undefined
// 42431E: variable 'a4' is possibly undefined
// 42431E: variable 'a5' is possibly undefined
// 42431E: variable 'a6' is possibly undefined
// 42431E: variable 'v10' is possibly undefined
// 4225D0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_788();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424330) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__get_env_389(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = camlCamlinternalOO__fun_792;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 424334: variable 'v6' is possibly undefined
// 424337: variable 'v8' is possibly undefined
// 424369: variable 'v7' is possibly undefined
// 424372: variable 'a3' is possibly undefined
// 424372: variable 'a4' is possibly undefined
// 424372: variable 'a5' is possibly undefined
// 424372: variable 'a6' is possibly undefined
// 424372: variable 'v11' is possibly undefined
// 4225E0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_792();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424380) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__get_meth_393(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rdi
  _QWORD *result; // rax
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v10) )
  {
    v7 -= 4;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  result = v7 + 1;
  *v7 = 3319LL;
  v7[1] = camlCamlinternalOO__fun_796;
  v7[2] = 3LL;
  v7[3] = i;
  return result;
}
// 424384: variable 'v6' is possibly undefined
// 424387: variable 'v7' is possibly undefined
// 4243BE: variable 'a3' is possibly undefined
// 4243BE: variable 'a4' is possibly undefined
// 4243BE: variable 'a5' is possibly undefined
// 4243BE: variable 'a6' is possibly undefined
// 4243BE: variable 'v10' is possibly undefined
// 422600: using guessed type __int64 __fastcall camlCamlinternalOO__fun_796();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004243D0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__set_var_396(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  _QWORD *v7; // r15
  __int64 i; // rdi
  _QWORD *result; // rax
  char v10; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(i, a2, a3, a4, a5, a6, v10) )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  result = v7 + 1;
  *v7 = 4343LL;
  v7[1] = caml_curry2;
  v7[2] = 5LL;
  v7[3] = camlCamlinternalOO__fun_800;
  v7[4] = i;
  return result;
}
// 4243D4: variable 'v6' is possibly undefined
// 4243D7: variable 'v7' is possibly undefined
// 424419: variable 'a3' is possibly undefined
// 424419: variable 'a4' is possibly undefined
// 424419: variable 'a5' is possibly undefined
// 424419: variable 'a6' is possibly undefined
// 424419: variable 'v10' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424420) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__app_const_400(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = camlCamlinternalOO__fun_804;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 424424: variable 'v6' is possibly undefined
// 424427: variable 'v8' is possibly undefined
// 424459: variable 'v7' is possibly undefined
// 424462: variable 'a3' is possibly undefined
// 424462: variable 'a4' is possibly undefined
// 424462: variable 'a5' is possibly undefined
// 424462: variable 'a6' is possibly undefined
// 424462: variable 'v11' is possibly undefined
// 422650: using guessed type __int64 __fastcall camlCamlinternalOO__fun_804();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424470) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__app_var_404(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = camlCamlinternalOO__fun_808;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 424474: variable 'v6' is possibly undefined
// 424477: variable 'v8' is possibly undefined
// 4244A9: variable 'v7' is possibly undefined
// 4244B2: variable 'a3' is possibly undefined
// 4244B2: variable 'a4' is possibly undefined
// 4244B2: variable 'a5' is possibly undefined
// 4244B2: variable 'a6' is possibly undefined
// 4244B2: variable 'v11' is possibly undefined
// 422660: using guessed type __int64 __fastcall camlCamlinternalOO__fun_808();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004244C0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__app_env_408(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 5367LL;
  v8[1] = camlCamlinternalOO__fun_812;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  return result;
}
// 4244C4: variable 'v6' is possibly undefined
// 4244C7: variable 'v8' is possibly undefined
// 4244F5: variable 'i' is possibly undefined
// 4244F9: variable 'v7' is possibly undefined
// 424506: variable 'a4' is possibly undefined
// 424506: variable 'a5' is possibly undefined
// 424506: variable 'a6' is possibly undefined
// 424506: variable 'v11' is possibly undefined
// 422680: using guessed type __int64 __fastcall camlCamlinternalOO__fun_812();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424510) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__app_meth_413(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = camlCamlinternalOO__fun_816;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 424514: variable 'v6' is possibly undefined
// 424517: variable 'v8' is possibly undefined
// 424549: variable 'v7' is possibly undefined
// 424552: variable 'a3' is possibly undefined
// 424552: variable 'a4' is possibly undefined
// 424552: variable 'a5' is possibly undefined
// 424552: variable 'a6' is possibly undefined
// 424552: variable 'v11' is possibly undefined
// 4226A0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_816();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424560) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__app_const_const_417(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 5367LL;
  v8[1] = camlCamlinternalOO__fun_820;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  return result;
}
// 424564: variable 'v6' is possibly undefined
// 424567: variable 'v8' is possibly undefined
// 424595: variable 'i' is possibly undefined
// 424599: variable 'v7' is possibly undefined
// 4245A6: variable 'a4' is possibly undefined
// 4245A6: variable 'a5' is possibly undefined
// 4245A6: variable 'a6' is possibly undefined
// 4245A6: variable 'v11' is possibly undefined
// 4226D0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_820();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004245B0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__app_const_var_422(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 5367LL;
  v8[1] = camlCamlinternalOO__fun_824;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  return result;
}
// 4245B4: variable 'v6' is possibly undefined
// 4245B7: variable 'v8' is possibly undefined
// 4245E5: variable 'i' is possibly undefined
// 4245E9: variable 'v7' is possibly undefined
// 4245F6: variable 'a4' is possibly undefined
// 4245F6: variable 'a5' is possibly undefined
// 4245F6: variable 'a6' is possibly undefined
// 4245F6: variable 'v11' is possibly undefined
// 4226F0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_824();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424600) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__app_const_meth_427(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 5367LL;
  v8[1] = camlCamlinternalOO__fun_828;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  return result;
}
// 424604: variable 'v6' is possibly undefined
// 424607: variable 'v8' is possibly undefined
// 424635: variable 'i' is possibly undefined
// 424639: variable 'v7' is possibly undefined
// 424646: variable 'a4' is possibly undefined
// 424646: variable 'a5' is possibly undefined
// 424646: variable 'a6' is possibly undefined
// 424646: variable 'v11' is possibly undefined
// 422710: using guessed type __int64 __fastcall camlCamlinternalOO__fun_828();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424650) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__app_var_const_432(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 5367LL;
  v8[1] = camlCamlinternalOO__fun_832;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  return result;
}
// 424654: variable 'v6' is possibly undefined
// 424657: variable 'v8' is possibly undefined
// 424685: variable 'i' is possibly undefined
// 424689: variable 'v7' is possibly undefined
// 424696: variable 'a4' is possibly undefined
// 424696: variable 'a5' is possibly undefined
// 424696: variable 'a6' is possibly undefined
// 424696: variable 'v11' is possibly undefined
// 422750: using guessed type __int64 __fastcall camlCamlinternalOO__fun_832();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004246A0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__app_meth_const_437(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 5367LL;
  v8[1] = camlCamlinternalOO__fun_836;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  return result;
}
// 4246A4: variable 'v6' is possibly undefined
// 4246A7: variable 'v8' is possibly undefined
// 4246D5: variable 'i' is possibly undefined
// 4246D9: variable 'v7' is possibly undefined
// 4246E6: variable 'a4' is possibly undefined
// 4246E6: variable 'a5' is possibly undefined
// 4246E6: variable 'a6' is possibly undefined
// 4246E6: variable 'v11' is possibly undefined
// 422770: using guessed type __int64 __fastcall camlCamlinternalOO__fun_836();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004246F0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__app_const_env_442(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rcx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, a3, i, a5, a6, v11) )
  {
    v8 -= 7;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 6391LL;
  v8[1] = camlCamlinternalOO__fun_840;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  v8[6] = a2;
  return result;
}
// 4246F4: variable 'v6' is possibly undefined
// 4246F7: variable 'v8' is possibly undefined
// 424725: variable 'i' is possibly undefined
// 424729: variable 'v7' is possibly undefined
// 42473A: variable 'a3' is possibly undefined
// 42473A: variable 'a5' is possibly undefined
// 42473A: variable 'a6' is possibly undefined
// 42473A: variable 'v11' is possibly undefined
// 4227A0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_840();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424750) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__app_env_const_448(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rcx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, a3, i, a5, a6, v11) )
  {
    v8 -= 7;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 6391LL;
  v8[1] = camlCamlinternalOO__fun_844;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  v8[6] = a2;
  return result;
}
// 424754: variable 'v6' is possibly undefined
// 424757: variable 'v8' is possibly undefined
// 424785: variable 'i' is possibly undefined
// 424789: variable 'v7' is possibly undefined
// 42479A: variable 'a3' is possibly undefined
// 42479A: variable 'a5' is possibly undefined
// 42479A: variable 'a6' is possibly undefined
// 42479A: variable 'v11' is possibly undefined
// 4227D0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_844();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004247B0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__meth_app_const_454(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = camlCamlinternalOO__fun_848;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 4247B4: variable 'v6' is possibly undefined
// 4247B7: variable 'v8' is possibly undefined
// 4247E9: variable 'v7' is possibly undefined
// 4247F2: variable 'a3' is possibly undefined
// 4247F2: variable 'a4' is possibly undefined
// 4247F2: variable 'a5' is possibly undefined
// 4247F2: variable 'a6' is possibly undefined
// 4247F2: variable 'v11' is possibly undefined
// 422800: using guessed type __int64 __fastcall camlCamlinternalOO__fun_848();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424800) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__meth_app_var_458(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = camlCamlinternalOO__fun_852;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 424804: variable 'v6' is possibly undefined
// 424807: variable 'v8' is possibly undefined
// 424839: variable 'v7' is possibly undefined
// 424842: variable 'a3' is possibly undefined
// 424842: variable 'a4' is possibly undefined
// 424842: variable 'a5' is possibly undefined
// 424842: variable 'a6' is possibly undefined
// 424842: variable 'v11' is possibly undefined
// 422820: using guessed type __int64 __fastcall camlCamlinternalOO__fun_852();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424850) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__meth_app_env_462(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 5367LL;
  v8[1] = camlCamlinternalOO__fun_856;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  return result;
}
// 424854: variable 'v6' is possibly undefined
// 424857: variable 'v8' is possibly undefined
// 424885: variable 'i' is possibly undefined
// 424889: variable 'v7' is possibly undefined
// 424896: variable 'a4' is possibly undefined
// 424896: variable 'a5' is possibly undefined
// 424896: variable 'a6' is possibly undefined
// 424896: variable 'v11' is possibly undefined
// 422840: using guessed type __int64 __fastcall camlCamlinternalOO__fun_856();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004248A0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__meth_app_meth_467(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rsi
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, i, a3, a4, a5, a6, v11) )
  {
    v8 -= 5;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 4343LL;
  v8[1] = camlCamlinternalOO__fun_860;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  return result;
}
// 4248A4: variable 'v6' is possibly undefined
// 4248A7: variable 'v8' is possibly undefined
// 4248D9: variable 'v7' is possibly undefined
// 4248E2: variable 'a3' is possibly undefined
// 4248E2: variable 'a4' is possibly undefined
// 4248E2: variable 'a5' is possibly undefined
// 4248E2: variable 'a6' is possibly undefined
// 4248E2: variable 'v11' is possibly undefined
// 422870: using guessed type __int64 __fastcall camlCamlinternalOO__fun_860();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004248F0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__send_const_471(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 5367LL;
  v8[1] = camlCamlinternalOO__fun_864;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  return result;
}
// 4248F4: variable 'v6' is possibly undefined
// 4248F7: variable 'v8' is possibly undefined
// 424925: variable 'i' is possibly undefined
// 424929: variable 'v7' is possibly undefined
// 424936: variable 'a4' is possibly undefined
// 424936: variable 'a5' is possibly undefined
// 424936: variable 'a6' is possibly undefined
// 424936: variable 'v11' is possibly undefined
// 4228B0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_864();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424940) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__send_var_476(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 5367LL;
  v8[1] = camlCamlinternalOO__fun_868;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  return result;
}
// 424944: variable 'v6' is possibly undefined
// 424947: variable 'v8' is possibly undefined
// 424975: variable 'i' is possibly undefined
// 424979: variable 'v7' is possibly undefined
// 424986: variable 'a4' is possibly undefined
// 424986: variable 'a5' is possibly undefined
// 424986: variable 'a6' is possibly undefined
// 424986: variable 'v11' is possibly undefined
// 4228D0: using guessed type __int64 __fastcall camlCamlinternalOO__fun_868();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424990) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__send_env_481(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rcx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, a3, i, a5, a6, v11) )
  {
    v8 -= 7;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 6391LL;
  v8[1] = camlCamlinternalOO__fun_872;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  v8[6] = a2;
  return result;
}
// 424994: variable 'v6' is possibly undefined
// 424997: variable 'v8' is possibly undefined
// 4249C5: variable 'i' is possibly undefined
// 4249C9: variable 'v7' is possibly undefined
// 4249DA: variable 'a3' is possibly undefined
// 4249DA: variable 'a5' is possibly undefined
// 4249DA: variable 'a6' is possibly undefined
// 4249DA: variable 'v11' is possibly undefined
// 422900: using guessed type __int64 __fastcall camlCamlinternalOO__fun_872();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004249F0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__send_meth_487(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // r15
  __int64 i; // rdx
  _QWORD *result; // rax
  char v11; // [rsp+0h] [rbp-8h]

  for ( i = v6; ; caml_call_gc(a1, a2, i, a4, a5, a6, v11) )
  {
    v8 -= 6;
    if ( (unsigned __int64)v8 >= caml_young_limit )
      break;
  }
  result = v8 + 1;
  *v8 = 5367LL;
  v8[1] = camlCamlinternalOO__fun_876;
  v8[2] = 3LL;
  v8[3] = i;
  v8[4] = v7;
  v8[5] = a1;
  return result;
}
// 4249F4: variable 'v6' is possibly undefined
// 4249F7: variable 'v8' is possibly undefined
// 424A25: variable 'i' is possibly undefined
// 424A29: variable 'v7' is possibly undefined
// 424A36: variable 'a4' is possibly undefined
// 424A36: variable 'a5' is possibly undefined
// 424A36: variable 'a6' is possibly undefined
// 424A36: variable 'v11' is possibly undefined
// 422930: using guessed type __int64 __fastcall camlCamlinternalOO__fun_876();
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000424A40) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__new_cache_492(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // [rsp+0h] [rbp-8h]

  v13 = v2;
  v3 = camlCamlinternalOO__new_method_203();
  v4 = (v3 >> 1) + 1;
  if ( v3 >> 1 >= 0 )
    v4 = v3 >> 1;
  if ( 2 * ((v3 >> 1) - (v4 & 0xFFFFFFFFFFFFFFFELL)) )
  {
    v5 = camlSys[4] >> 1;
    if ( v5 )
    {
      v6 = v13;
      a2 = *(_QWORD *)(v13 + 8);
      if ( *(_QWORD *)(a2 - 8) >> 9 <= 3uLL )
        goto LABEL_13;
      v7 = ((16 * (*(_QWORD *)(a2 + 8) - 1LL) + 1) >> 1) / v5;
    }
    else
    {
      v7 = caml_raise_exn();
    }
    if ( v3 <= 2 * v7 + 5 )
      v3 = camlCamlinternalOO__new_method_203();
  }
  v6 = *(_QWORD *)(v13 + 8);
  if ( *(_QWORD *)(v6 - 8) >> 9 > (unsigned __int64)v3 )
  {
    caml_modify((unsigned __int64 *)(v6 + 4 * v3 - 4), 1uLL);
    return v3;
  }
  caml_ml_array_bound_error(v6, a2);
LABEL_13:
  caml_ml_array_bound_error(v6, a2);
  return camlCamlinternalOO__method_impl_547(v6, a2, v9, v10, v11, v12);
}
// 424A44: variable 'v2' is possibly undefined
// 424B14: variable 'v9' is possibly undefined
// 424B14: variable 'v10' is possibly undefined
// 424B14: variable 'v11' is possibly undefined
// 424B14: variable 'v12' is possibly undefined
// 6515D0: using guessed type __int64 camlSys[33];

//----- (0000000000424B20) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__method_impl_547(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned __int64 v6; // rbx
  _QWORD *v7; // r15
  __int64 result; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // rdx
  __int64 v26; // rcx
  __int64 v27; // r8
  __int64 v28; // r9
  __int64 v29; // rdx
  __int64 v30; // rcx
  __int64 v31; // r8
  __int64 v32; // r9
  __int64 v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // r8
  __int64 v36; // r9
  __int64 v37; // rdx
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  __int64 v41; // rdx
  __int64 v42; // rcx
  __int64 v43; // r8
  __int64 v44; // r9
  __int64 v45; // rdx
  __int64 v46; // rcx
  __int64 v47; // r8
  __int64 v48; // r9
  __int64 v49; // rdx
  __int64 v50; // rcx
  __int64 v51; // r8
  __int64 v52; // r9
  __int64 v53; // rdx
  __int64 v54; // rcx
  __int64 v55; // r8
  __int64 v56; // r9
  __int64 v57; // rdx
  __int64 v58; // rcx
  __int64 v59; // r8
  __int64 v60; // r9
  __int64 _551; // rax
  __int64 v62; // rdx
  __int64 v63; // rcx
  __int64 v64; // r8
  __int64 v65; // r9
  __int64 v66; // rdx
  __int64 v67; // rcx
  __int64 v68; // r8
  __int64 v69; // r9
  __int64 v70; // rdx
  __int64 v71; // rcx
  __int64 v72; // r8
  __int64 v73; // r9
  __int64 v74; // rdx
  __int64 v75; // rcx
  __int64 v76; // r8
  __int64 v77; // r9
  __int64 v78; // rdx
  __int64 v79; // rcx
  __int64 v80; // r8
  __int64 v81; // r9
  __int64 v82; // rax
  __int64 v83; // rdx
  __int64 v84; // rcx
  __int64 v85; // r8
  __int64 v86; // r9
  __int64 v87; // rdx
  __int64 v88; // rcx
  __int64 v89; // r8
  __int64 v90; // r9
  __int64 v91; // rdx
  __int64 v92; // rcx
  __int64 v93; // r8
  __int64 v94; // r9
  __int64 v95; // rax
  __int64 v96; // rdx
  __int64 v97; // rcx
  __int64 v98; // r8
  __int64 v99; // r9
  __int64 v100; // rdx
  __int64 v101; // rcx
  __int64 v102; // r8
  __int64 v103; // r9
  __int64 v104; // rdx
  __int64 v105; // rcx
  __int64 v106; // r8
  __int64 v107; // r9
  __int64 v108; // rdx
  __int64 v109; // rcx
  __int64 v110; // r8
  __int64 v111; // r9
  __int64 v112; // rax
  __int64 v113; // rdx
  __int64 v114; // rcx
  __int64 v115; // r8
  __int64 v116; // r9
  __int64 v117; // rdx
  __int64 v118; // rcx
  __int64 v119; // r8
  __int64 v120; // r9
  __int64 v121; // rdx
  __int64 v122; // rcx
  __int64 v123; // r8
  __int64 v124; // r9
  __int64 v125; // rax
  __int64 v126; // rdx
  __int64 v127; // rcx
  __int64 v128; // r8
  __int64 v129; // r9
  __int64 v130; // rdx
  __int64 v131; // rcx
  __int64 v132; // r8
  __int64 v133; // r9
  __int64 v134; // rdx
  __int64 v135; // rcx
  __int64 v136; // r8
  __int64 v137; // r9
  __int64 v138; // rax
  __int64 v139; // rdx
  __int64 v140; // rcx
  __int64 v141; // r8
  __int64 v142; // r9
  __int64 v143; // rdx
  __int64 v144; // rcx
  __int64 v145; // r8
  __int64 v146; // r9
  __int64 v147; // rdx
  __int64 v148; // rcx
  __int64 v149; // r8
  __int64 v150; // r9
  __int64 v151; // rdx
  __int64 v152; // rcx
  __int64 v153; // r8
  __int64 v154; // r9
  __int64 v155; // rax
  __int64 v156; // rdx
  __int64 v157; // rcx
  __int64 v158; // r8
  __int64 v159; // r9
  __int64 v160; // rdx
  __int64 v161; // rcx
  __int64 v162; // r8
  __int64 v163; // r9
  __int64 v164; // rdx
  __int64 v165; // rcx
  __int64 v166; // r8
  __int64 v167; // r9
  __int64 v168; // rax
  __int64 v169; // rdx
  __int64 v170; // rcx
  __int64 v171; // r8
  __int64 v172; // r9
  __int64 v173; // rdx
  __int64 v174; // rcx
  __int64 v175; // r8
  __int64 v176; // r9
  __int64 v177; // rdx
  __int64 v178; // rcx
  __int64 v179; // r8
  __int64 v180; // r9
  __int64 v181; // rdx
  __int64 v182; // rcx
  __int64 v183; // r8
  __int64 v184; // r9
  __int64 v185; // rdx
  __int64 v186; // rcx
  __int64 v187; // r8
  __int64 v188; // r9
  __int64 v189; // rdx
  __int64 v190; // rcx
  __int64 v191; // r8
  __int64 v192; // r9
  __int64 v193; // rdx
  __int64 v194; // rcx
  __int64 v195; // r8
  __int64 v196; // r9
  __int64 v197; // rax
  __int64 v198; // rdx
  __int64 v199; // rcx
  __int64 v200; // r8
  __int64 v201; // r9
  __int64 v202; // rdx
  __int64 v203; // rcx
  __int64 v204; // r8
  __int64 v205; // r9
  __int64 v206; // rdx
  __int64 v207; // rcx
  __int64 v208; // r8
  __int64 v209; // r9
  __int64 v210; // rdx
  __int64 v211; // rcx
  __int64 v212; // r8
  __int64 v213; // r9
  __int64 v214; // rax
  __int64 v215; // rdx
  __int64 v216; // rcx
  __int64 v217; // r8
  __int64 v218; // r9
  __int64 v219; // rdx
  __int64 v220; // rcx
  __int64 v221; // r8
  __int64 v222; // r9
  __int64 v223; // rax
  __int64 v224; // rdx
  __int64 v225; // rcx
  __int64 v226; // r8
  __int64 v227; // r9
  __int64 v228; // rdx
  __int64 v229; // rcx
  __int64 v230; // r8
  __int64 v231; // r9
  __int64 v232; // rdx
  __int64 v233; // rcx
  __int64 v234; // r8
  __int64 v235; // r9
  __int64 v236; // rax
  __int64 v237; // rdx
  __int64 v238; // rcx
  __int64 v239; // r8
  __int64 v240; // r9
  __int64 v241; // rdx
  __int64 v242; // rcx
  __int64 v243; // r8
  __int64 v244; // r9
  __int64 v245; // rax
  __int64 v246; // rdx
  __int64 v247; // rcx
  __int64 v248; // r8
  __int64 v249; // r9
  char v250; // [rsp+0h] [rbp-28h]
  __int64 v251; // [rsp+10h] [rbp-18h]
  __int64 v252; // [rsp+10h] [rbp-18h]
  __int64 v253; // [rsp+10h] [rbp-18h]

  while ( 1 )
  {
    v7 -= 5;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
    caml_call_gc(a1, v6, a3, a4, a5, a6, v250);
  }
  *v7 = 4343LL;
  v7[1] = camlCamlinternalOO__next_551;
  v7[2] = 3LL;
  v7[3] = v6;
  v7[4] = a1;
  result = camlCamlinternalOO__next_551(a1, v6, a3, a4, a5, a6);
  if ( (result & 1) != 0 )
  {
    switch ( result >> 1 )
    {
      case 0LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        result = (__int64)camlCamlinternalOO__get_const_383(a1, v6, v13, v14, v15, v16);
        break;
      case 1LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        result = (__int64)camlCamlinternalOO__get_var_386(a1, v6, v17, v18, v19, v20);
        break;
      case 2LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v21, v22, v23, v24);
        result = (__int64)camlCamlinternalOO__get_env_389(a1, v6, v25, v26, v27, v28);
        break;
      case 3LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        result = (__int64)camlCamlinternalOO__get_meth_393(a1, v6, v29, v30, v31, v32);
        break;
      case 4LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        result = (__int64)camlCamlinternalOO__set_var_396(a1, v6, v33, v34, v35, v36);
        break;
      case 5LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v37, v38, v39, v40);
        result = (__int64)camlCamlinternalOO__app_const_400(a1, v6, v41, v42, v43, v44);
        break;
      case 6LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v45, v46, v47, v48);
        result = (__int64)camlCamlinternalOO__app_var_404(a1, v6, v49, v50, v51, v52);
        break;
      case 7LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v53, v54, v55, v56);
        _551 = camlCamlinternalOO__next_551(a1, v6, v57, v58, v59, v60);
        result = (__int64)camlCamlinternalOO__app_env_408(_551, v6, v62, v63, v64, v65);
        break;
      case 8LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v66, v67, v68, v69);
        result = (__int64)camlCamlinternalOO__app_meth_413(a1, v6, v70, v71, v72, v73);
        break;
      case 9LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v74, v75, v76, v77);
        v82 = camlCamlinternalOO__next_551(a1, v6, v78, v79, v80, v81);
        result = (__int64)camlCamlinternalOO__app_const_const_417(v82, v6, v83, v84, v85, v86);
        break;
      case 10LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v87, v88, v89, v90);
        v95 = camlCamlinternalOO__next_551(a1, v6, v91, v92, v93, v94);
        result = (__int64)camlCamlinternalOO__app_const_var_422(v95, v6, v96, v97, v98, v99);
        break;
      case 11LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v100, v101, v102, v103);
        v251 = camlCamlinternalOO__next_551(a1, v6, v104, v105, v106, v107);
        v112 = camlCamlinternalOO__next_551(a1, v6, v108, v109, v110, v111);
        result = (__int64)camlCamlinternalOO__app_const_env_442(v251, v112, v113, v114, v115, v116);
        break;
      case 12LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v117, v118, v119, v120);
        v125 = camlCamlinternalOO__next_551(a1, v6, v121, v122, v123, v124);
        result = (__int64)camlCamlinternalOO__app_const_meth_427(v125, v6, v126, v127, v128, v129);
        break;
      case 13LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v130, v131, v132, v133);
        v138 = camlCamlinternalOO__next_551(a1, v6, v134, v135, v136, v137);
        result = (__int64)camlCamlinternalOO__app_var_const_432(v138, v6, v139, v140, v141, v142);
        break;
      case 14LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v143, v144, v145, v146);
        v252 = camlCamlinternalOO__next_551(a1, v6, v147, v148, v149, v150);
        v155 = camlCamlinternalOO__next_551(a1, v6, v151, v152, v153, v154);
        result = (__int64)camlCamlinternalOO__app_env_const_448(v252, v155, v156, v157, v158, v159);
        break;
      case 15LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v160, v161, v162, v163);
        v168 = camlCamlinternalOO__next_551(a1, v6, v164, v165, v166, v167);
        result = (__int64)camlCamlinternalOO__app_meth_const_437(v168, v6, v169, v170, v171, v172);
        break;
      case 16LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v173, v174, v175, v176);
        result = (__int64)camlCamlinternalOO__meth_app_const_454(a1, v6, v177, v178, v179, v180);
        break;
      case 17LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v181, v182, v183, v184);
        result = (__int64)camlCamlinternalOO__meth_app_var_458(a1, v6, v185, v186, v187, v188);
        break;
      case 18LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v189, v190, v191, v192);
        v197 = camlCamlinternalOO__next_551(a1, v6, v193, v194, v195, v196);
        result = (__int64)camlCamlinternalOO__meth_app_env_462(v197, v6, v198, v199, v200, v201);
        break;
      case 19LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v202, v203, v204, v205);
        result = (__int64)camlCamlinternalOO__meth_app_meth_467(a1, v6, v206, v207, v208, v209);
        break;
      case 20LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v210, v211, v212, v213);
        v214 = camlCamlinternalOO__new_cache_492(a1, v6);
        result = (__int64)camlCamlinternalOO__send_const_471(v214, v6, v215, v216, v217, v218);
        break;
      case 21LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v219, v220, v221, v222);
        v223 = camlCamlinternalOO__new_cache_492(a1, v6);
        result = (__int64)camlCamlinternalOO__send_var_476(v223, v6, v224, v225, v226, v227);
        break;
      case 22LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v228, v229, v230, v231);
        v253 = camlCamlinternalOO__next_551(a1, v6, v232, v233, v234, v235);
        v236 = camlCamlinternalOO__new_cache_492(a1, v6);
        result = (__int64)camlCamlinternalOO__send_env_481(v253, v236, v237, v238, v239, v240);
        break;
      case 23LL:
        camlCamlinternalOO__next_551(a1, v6, v9, v10, v11, v12);
        camlCamlinternalOO__next_551(a1, v6, v241, v242, v243, v244);
        v245 = camlCamlinternalOO__new_cache_492(a1, v6);
        result = (__int64)camlCamlinternalOO__send_meth_487(v245, v6, v246, v247, v248, v249);
        break;
    }
  }
  return result;
}
// 424B2C: variable 'v7' is possibly undefined
// 424B63: variable 'v6' is possibly undefined
// 424B72: variable 'a3' is possibly undefined
// 424B72: variable 'a4' is possibly undefined
// 424B72: variable 'a5' is possibly undefined
// 424B72: variable 'a6' is possibly undefined
// 424BA0: variable 'v9' is possibly undefined
// 424BA0: variable 'v10' is possibly undefined
// 424BA0: variable 'v11' is possibly undefined
// 424BA0: variable 'v12' is possibly undefined
// 424BA9: variable 'v13' is possibly undefined
// 424BA9: variable 'v14' is possibly undefined
// 424BA9: variable 'v15' is possibly undefined
// 424BA9: variable 'v16' is possibly undefined
// 424BC5: variable 'v17' is possibly undefined
// 424BC5: variable 'v18' is possibly undefined
// 424BC5: variable 'v19' is possibly undefined
// 424BC5: variable 'v20' is possibly undefined
// 424BED: variable 'v21' is possibly undefined
// 424BED: variable 'v22' is possibly undefined
// 424BED: variable 'v23' is possibly undefined
// 424BED: variable 'v24' is possibly undefined
// 424BFD: variable 'v25' is possibly undefined
// 424BFD: variable 'v26' is possibly undefined
// 424BFD: variable 'v27' is possibly undefined
// 424BFD: variable 'v28' is possibly undefined
// 424C19: variable 'v29' is possibly undefined
// 424C19: variable 'v30' is possibly undefined
// 424C19: variable 'v31' is possibly undefined
// 424C19: variable 'v32' is possibly undefined
// 424C35: variable 'v33' is possibly undefined
// 424C35: variable 'v34' is possibly undefined
// 424C35: variable 'v35' is possibly undefined
// 424C35: variable 'v36' is possibly undefined
// 424C5D: variable 'v37' is possibly undefined
// 424C5D: variable 'v38' is possibly undefined
// 424C5D: variable 'v39' is possibly undefined
// 424C5D: variable 'v40' is possibly undefined
// 424C6D: variable 'v41' is possibly undefined
// 424C6D: variable 'v42' is possibly undefined
// 424C6D: variable 'v43' is possibly undefined
// 424C6D: variable 'v44' is possibly undefined
// 424C95: variable 'v45' is possibly undefined
// 424C95: variable 'v46' is possibly undefined
// 424C95: variable 'v47' is possibly undefined
// 424C95: variable 'v48' is possibly undefined
// 424CA5: variable 'v49' is possibly undefined
// 424CA5: variable 'v50' is possibly undefined
// 424CA5: variable 'v51' is possibly undefined
// 424CA5: variable 'v52' is possibly undefined
// 424CCD: variable 'v53' is possibly undefined
// 424CCD: variable 'v54' is possibly undefined
// 424CCD: variable 'v55' is possibly undefined
// 424CCD: variable 'v56' is possibly undefined
// 424CE3: variable 'v57' is possibly undefined
// 424CE3: variable 'v58' is possibly undefined
// 424CE3: variable 'v59' is possibly undefined
// 424CE3: variable 'v60' is possibly undefined
// 424CF8: variable 'v62' is possibly undefined
// 424CF8: variable 'v63' is possibly undefined
// 424CF8: variable 'v64' is possibly undefined
// 424CF8: variable 'v65' is possibly undefined
// 424D21: variable 'v66' is possibly undefined
// 424D21: variable 'v67' is possibly undefined
// 424D21: variable 'v68' is possibly undefined
// 424D21: variable 'v69' is possibly undefined
// 424D31: variable 'v70' is possibly undefined
// 424D31: variable 'v71' is possibly undefined
// 424D31: variable 'v72' is possibly undefined
// 424D31: variable 'v73' is possibly undefined
// 424D59: variable 'v74' is possibly undefined
// 424D59: variable 'v75' is possibly undefined
// 424D59: variable 'v76' is possibly undefined
// 424D59: variable 'v77' is possibly undefined
// 424D6F: variable 'v78' is possibly undefined
// 424D6F: variable 'v79' is possibly undefined
// 424D6F: variable 'v80' is possibly undefined
// 424D6F: variable 'v81' is possibly undefined
// 424D84: variable 'v83' is possibly undefined
// 424D84: variable 'v84' is possibly undefined
// 424D84: variable 'v85' is possibly undefined
// 424D84: variable 'v86' is possibly undefined
// 424DAD: variable 'v87' is possibly undefined
// 424DAD: variable 'v88' is possibly undefined
// 424DAD: variable 'v89' is possibly undefined
// 424DAD: variable 'v90' is possibly undefined
// 424DC3: variable 'v91' is possibly undefined
// 424DC3: variable 'v92' is possibly undefined
// 424DC3: variable 'v93' is possibly undefined
// 424DC3: variable 'v94' is possibly undefined
// 424DD8: variable 'v96' is possibly undefined
// 424DD8: variable 'v97' is possibly undefined
// 424DD8: variable 'v98' is possibly undefined
// 424DD8: variable 'v99' is possibly undefined
// 424E01: variable 'v100' is possibly undefined
// 424E01: variable 'v101' is possibly undefined
// 424E01: variable 'v102' is possibly undefined
// 424E01: variable 'v103' is possibly undefined
// 424E17: variable 'v104' is possibly undefined
// 424E17: variable 'v105' is possibly undefined
// 424E17: variable 'v106' is possibly undefined
// 424E17: variable 'v107' is possibly undefined
// 424E2D: variable 'v108' is possibly undefined
// 424E2D: variable 'v109' is possibly undefined
// 424E2D: variable 'v110' is possibly undefined
// 424E2D: variable 'v111' is possibly undefined
// 424E47: variable 'v113' is possibly undefined
// 424E47: variable 'v114' is possibly undefined
// 424E47: variable 'v115' is possibly undefined
// 424E47: variable 'v116' is possibly undefined
// 424E6D: variable 'v117' is possibly undefined
// 424E6D: variable 'v118' is possibly undefined
// 424E6D: variable 'v119' is possibly undefined
// 424E6D: variable 'v120' is possibly undefined
// 424E83: variable 'v121' is possibly undefined
// 424E83: variable 'v122' is possibly undefined
// 424E83: variable 'v123' is possibly undefined
// 424E83: variable 'v124' is possibly undefined
// 424E98: variable 'v126' is possibly undefined
// 424E98: variable 'v127' is possibly undefined
// 424E98: variable 'v128' is possibly undefined
// 424E98: variable 'v129' is possibly undefined
// 424EC1: variable 'v130' is possibly undefined
// 424EC1: variable 'v131' is possibly undefined
// 424EC1: variable 'v132' is possibly undefined
// 424EC1: variable 'v133' is possibly undefined
// 424ED7: variable 'v134' is possibly undefined
// 424ED7: variable 'v135' is possibly undefined
// 424ED7: variable 'v136' is possibly undefined
// 424ED7: variable 'v137' is possibly undefined
// 424EEC: variable 'v139' is possibly undefined
// 424EEC: variable 'v140' is possibly undefined
// 424EEC: variable 'v141' is possibly undefined
// 424EEC: variable 'v142' is possibly undefined
// 424F15: variable 'v143' is possibly undefined
// 424F15: variable 'v144' is possibly undefined
// 424F15: variable 'v145' is possibly undefined
// 424F15: variable 'v146' is possibly undefined
// 424F2B: variable 'v147' is possibly undefined
// 424F2B: variable 'v148' is possibly undefined
// 424F2B: variable 'v149' is possibly undefined
// 424F2B: variable 'v150' is possibly undefined
// 424F41: variable 'v151' is possibly undefined
// 424F41: variable 'v152' is possibly undefined
// 424F41: variable 'v153' is possibly undefined
// 424F41: variable 'v154' is possibly undefined
// 424F5B: variable 'v156' is possibly undefined
// 424F5B: variable 'v157' is possibly undefined
// 424F5B: variable 'v158' is possibly undefined
// 424F5B: variable 'v159' is possibly undefined
// 424F81: variable 'v160' is possibly undefined
// 424F81: variable 'v161' is possibly undefined
// 424F81: variable 'v162' is possibly undefined
// 424F81: variable 'v163' is possibly undefined
// 424F97: variable 'v164' is possibly undefined
// 424F97: variable 'v165' is possibly undefined
// 424F97: variable 'v166' is possibly undefined
// 424F97: variable 'v167' is possibly undefined
// 424FAC: variable 'v169' is possibly undefined
// 424FAC: variable 'v170' is possibly undefined
// 424FAC: variable 'v171' is possibly undefined
// 424FAC: variable 'v172' is possibly undefined
// 424FD5: variable 'v173' is possibly undefined
// 424FD5: variable 'v174' is possibly undefined
// 424FD5: variable 'v175' is possibly undefined
// 424FD5: variable 'v176' is possibly undefined
// 424FE5: variable 'v177' is possibly undefined
// 424FE5: variable 'v178' is possibly undefined
// 424FE5: variable 'v179' is possibly undefined
// 424FE5: variable 'v180' is possibly undefined
// 42500D: variable 'v181' is possibly undefined
// 42500D: variable 'v182' is possibly undefined
// 42500D: variable 'v183' is possibly undefined
// 42500D: variable 'v184' is possibly undefined
// 42501D: variable 'v185' is possibly undefined
// 42501D: variable 'v186' is possibly undefined
// 42501D: variable 'v187' is possibly undefined
// 42501D: variable 'v188' is possibly undefined
// 425045: variable 'v189' is possibly undefined
// 425045: variable 'v190' is possibly undefined
// 425045: variable 'v191' is possibly undefined
// 425045: variable 'v192' is possibly undefined
// 42505B: variable 'v193' is possibly undefined
// 42505B: variable 'v194' is possibly undefined
// 42505B: variable 'v195' is possibly undefined
// 42505B: variable 'v196' is possibly undefined
// 425070: variable 'v198' is possibly undefined
// 425070: variable 'v199' is possibly undefined
// 425070: variable 'v200' is possibly undefined
// 425070: variable 'v201' is possibly undefined
// 425099: variable 'v202' is possibly undefined
// 425099: variable 'v203' is possibly undefined
// 425099: variable 'v204' is possibly undefined
// 425099: variable 'v205' is possibly undefined
// 4250A9: variable 'v206' is possibly undefined
// 4250A9: variable 'v207' is possibly undefined
// 4250A9: variable 'v208' is possibly undefined
// 4250A9: variable 'v209' is possibly undefined
// 4250D1: variable 'v210' is possibly undefined
// 4250D1: variable 'v211' is possibly undefined
// 4250D1: variable 'v212' is possibly undefined
// 4250D1: variable 'v213' is possibly undefined
// 4250F5: variable 'v215' is possibly undefined
// 4250F5: variable 'v216' is possibly undefined
// 4250F5: variable 'v217' is possibly undefined
// 4250F5: variable 'v218' is possibly undefined
// 42511D: variable 'v219' is possibly undefined
// 42511D: variable 'v220' is possibly undefined
// 42511D: variable 'v221' is possibly undefined
// 42511D: variable 'v222' is possibly undefined
// 425141: variable 'v224' is possibly undefined
// 425141: variable 'v225' is possibly undefined
// 425141: variable 'v226' is possibly undefined
// 425141: variable 'v227' is possibly undefined
// 425169: variable 'v228' is possibly undefined
// 425169: variable 'v229' is possibly undefined
// 425169: variable 'v230' is possibly undefined
// 425169: variable 'v231' is possibly undefined
// 42517F: variable 'v232' is possibly undefined
// 42517F: variable 'v233' is possibly undefined
// 42517F: variable 'v234' is possibly undefined
// 42517F: variable 'v235' is possibly undefined
// 4251A8: variable 'v237' is possibly undefined
// 4251A8: variable 'v238' is possibly undefined
// 4251A8: variable 'v239' is possibly undefined
// 4251A8: variable 'v240' is possibly undefined
// 4251D1: variable 'v241' is possibly undefined
// 4251D1: variable 'v242' is possibly undefined
// 4251D1: variable 'v243' is possibly undefined
// 4251D1: variable 'v244' is possibly undefined
// 4251F5: variable 'v246' is possibly undefined
// 4251F5: variable 'v247' is possibly undefined
// 4251F5: variable 'v248' is possibly undefined
// 4251F5: variable 'v249' is possibly undefined
// 425201: variable 'v250' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000425210) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__set_methods_609(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rbx
  _QWORD *v7; // r15
  __int64 *v8; // rbx
  unsigned __int64 v9; // rsi
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  __int64 i; // [rsp+0h] [rbp-28h]
  __int64 v21; // [rsp+8h] [rbp-20h]

  v21 = v6;
  for ( i = (*(_QWORD *)(v6 - 8) >> 9) | 1LL; ; caml_call_gc(a1, a2, a3, a4, a5, a6, i) )
  {
    v7 -= 2;
    if ( (unsigned __int64)v7 >= caml_young_limit )
      break;
  }
  v8 = v7 + 1;
  *v7 = 1024LL;
  for ( v7[1] = 1LL; ; v7[1] += 2LL )
  {
    if ( *v8 >= i )
      return 1LL;
    v9 = *v8;
    if ( *(_QWORD *)(v21 - 8) >> 9 <= (unsigned __int64)*v8 )
      break;
    v10 = camlCamlinternalOO__method_impl_547(v21, v9, a3, a4, a5, a6);
    camlCamlinternalOO__set_method_213(v10, v9, v11, v12, v13, v14);
    v8 = v7 + 1;
  }
  caml_ml_array_bound_error(v21, v9);
  return (__int64)camlCamlinternalOO__stats_623(v21, v9, v16, v17, v18, v19);
}
// 425219: variable 'v6' is possibly undefined
// 42522E: variable 'v7' is possibly undefined
// 425260: variable 'i' is possibly undefined
// 425286: variable 'a3' is possibly undefined
// 425286: variable 'a4' is possibly undefined
// 425286: variable 'a5' is possibly undefined
// 425286: variable 'a6' is possibly undefined
// 425298: variable 'v11' is possibly undefined
// 425298: variable 'v12' is possibly undefined
// 425298: variable 'v13' is possibly undefined
// 425298: variable 'v14' is possibly undefined
// 4252C4: variable 'v16' is possibly undefined
// 4252C4: variable 'v17' is possibly undefined
// 4252C4: variable 'v18' is possibly undefined
// 4252C4: variable 'v19' is possibly undefined
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (00000000004252D0) ----------------------------------------------------
_QWORD *__fastcall camlCamlinternalOO__stats_623(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  _QWORD *v6; // r15
  _QWORD *result; // rax
  char v8; // [rsp+0h] [rbp-8h]

  while ( 1 )
  {
    v6 -= 4;
    if ( (unsigned __int64)v6 >= caml_young_limit )
      break;
    caml_call_gc(a1, a2, a3, a4, a5, a6, v8);
  }
  result = v6 + 1;
  *v6 = 3072LL;
  v6[1] = *(_QWORD *)camlCamlinternalOO[39];
  v6[2] = *(_QWORD *)camlCamlinternalOO[45];
  v6[3] = *(_QWORD *)camlCamlinternalOO[46];
  return result;
}
// 4252D4: variable 'v6' is possibly undefined
// 425333: variable 'a3' is possibly undefined
// 425333: variable 'a4' is possibly undefined
// 425333: variable 'a5' is possibly undefined
// 425333: variable 'a6' is possibly undefined
// 425333: variable 'v8' is possibly undefined
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000425340) ----------------------------------------------------
__int64 __fastcall camlCamlinternalOO__entry(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // r15
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rdx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 v26; // rdx
  __int64 v27; // rcx
  __int64 v28; // r8
  __int64 v29; // r9
  __int64 v30; // rax
  __int64 v31; // rdx
  __int64 v32; // rcx
  __int64 v33; // r8
  __int64 v34; // r9
  char v36; // [rsp+0h] [rbp-8h]
  char v37; // [rsp+0h] [rbp-8h]
  char v38; // [rsp+0h] [rbp-8h]
  char v39; // [rsp+0h] [rbp-8h]
  char v40; // [rsp+0h] [rbp-8h]

  caml_allocN(a1, a2, a3, a4, a5, a6, v36);
  *v6 = 1024LL;
  v6[1] = 1LL;
  camlCamlinternalOO[30] = v6 + 1;
  camlCamlinternalOO[31] = &camlCamlinternalOO__69;
  camlCamlinternalOO[32] = &camlCamlinternalOO__68;
  camlCamlinternalOO[21] = &camlCamlinternalOO__67;
  v6[2] = 5120LL;
  v6[3] = 3LL;
  v6[4] = 3LL;
  v6[5] = 3LL;
  v6[6] = 7LL;
  v6[7] = 33LL;
  camlCamlinternalOO[28] = v6 + 3;
  v9 = camlSys[4] >> 1;
  v10 = v9 + 15;
  if ( v9 >= 0 )
    v10 = camlSys[4] >> 1;
  v11 = v10 >> 4;
  camlCamlinternalOO[33] = 2 * v11 + 1;
  camlCamlinternalOO[34] = 5LL;
  camlCamlinternalOO[35] = 1LL;
  camlCamlinternalOO[0] = &camlCamlinternalOO__66;
  v6[8] = 1024LL;
  v6[9] = &camlCamlinternalOO__65;
  camlCamlinternalOO[36] = camlMap__fun_473((__int64)&camlCamlinternalOO__65, a2, v11, v7, v8);
  caml_alloc1((__int64)&camlCamlinternalOO__65, a2, v12, v13, v14, v15, v37);
  *v6 = 1024LL;
  v6[1] = &camlCamlinternalOO__64;
  camlCamlinternalOO[37] = camlMap__fun_473((__int64)&camlCamlinternalOO__65, a2, v16, v17, v18);
  caml_alloc1((__int64)&camlCamlinternalOO__65, a2, v19, v20, v21, v22, v38);
  *v6 = 1024LL;
  v6[1] = &camlCamlinternalOO__63;
  camlCamlinternalOO[38] = camlMap__fun_473((__int64)&camlCamlinternalOO__65, a2, v23, v24, v25);
  caml_allocN((__int64)&camlCamlinternalOO__65, a2, v26, v27, v28, v29, v39);
  *v6 = 1024LL;
  v6[1] = 1LL;
  v6[2] = 0x2000LL;
  v6[3] = 1LL;
  v6[4] = v6 + 1;
  v6[5] = 1LL;
  v6[6] = 1LL;
  v6[7] = 1LL;
  v6[8] = 1LL;
  v6[9] = 1LL;
  v6[10] = 1LL;
  camlCamlinternalOO[14] = v6 + 3;
  v6[11] = 1024LL;
  v6[12] = 1LL;
  camlCamlinternalOO[39] = v6 + 12;
  caml_c_call(1LL, 1uLL);
  camlCamlinternalOO[40] = v30;
  camlCamlinternalOO[41] = &camlCamlinternalOO__62;
  camlCamlinternalOO[42] = &camlCamlinternalOO__61;
  camlCamlinternalOO[43] = &camlCamlinternalOO__60;
  camlCamlinternalOO[44] = &camlCamlinternalOO__59;
  caml_alloc3(1LL, 1LL, v31, v32, v33, v34, v40);
  *v6 = 1024LL;
  v6[1] = 1LL;
  camlCamlinternalOO[45] = v6 + 1;
  v6[2] = 1024LL;
  v6[3] = 1LL;
  camlCamlinternalOO[46] = v6 + 3;
  camlCamlinternalOO[1] = &camlCamlinternalOO__58;
  camlCamlinternalOO[6] = &camlCamlinternalOO__57;
  camlCamlinternalOO[7] = &camlCamlinternalOO__56;
  camlCamlinternalOO[9] = &camlCamlinternalOO__55;
  camlCamlinternalOO[8] = &camlCamlinternalOO__54;
  camlCamlinternalOO[47] = &camlCamlinternalOO__53;
  camlCamlinternalOO[11] = &camlCamlinternalOO__52;
  camlCamlinternalOO[12] = &camlCamlinternalOO__51;
  camlCamlinternalOO[48] = &camlCamlinternalOO__50;
  camlCamlinternalOO[2] = &camlCamlinternalOO__49;
  camlCamlinternalOO[49] = &camlCamlinternalOO__48;
  camlCamlinternalOO[3] = &camlCamlinternalOO__47;
  camlCamlinternalOO[4] = &camlCamlinternalOO__46;
  camlCamlinternalOO[5] = &camlCamlinternalOO__45;
  camlCamlinternalOO[13] = &camlCamlinternalOO__44;
  camlCamlinternalOO[15] = &camlCamlinternalOO__43;
  camlCamlinternalOO[16] = &camlCamlinternalOO__42;
  camlCamlinternalOO[17] = &camlCamlinternalOO__41;
  camlCamlinternalOO[18] = &camlCamlinternalOO__40;
  camlCamlinternalOO[19] = &camlCamlinternalOO__39;
  camlCamlinternalOO[20] = &camlCamlinternalOO__38;
  camlCamlinternalOO[22] = &camlCamlinternalOO__37;
  camlCamlinternalOO[23] = &camlCamlinternalOO__36;
  camlCamlinternalOO[50] = &camlCamlinternalOO__35;
  camlCamlinternalOO[24] = &camlCamlinternalOO__34;
  camlCamlinternalOO[25] = &camlCamlinternalOO__33;
  camlCamlinternalOO[26] = &camlCamlinternalOO__32;
  camlCamlinternalOO[51] = &camlCamlinternalOO__31;
  camlCamlinternalOO[52] = &camlCamlinternalOO__30;
  camlCamlinternalOO[27] = &camlCamlinternalOO__29;
  camlCamlinternalOO[53] = &camlCamlinternalOO__28;
  camlCamlinternalOO[54] = &camlCamlinternalOO__27;
  camlCamlinternalOO[55] = &camlCamlinternalOO__26;
  camlCamlinternalOO[56] = &camlCamlinternalOO__25;
  camlCamlinternalOO[57] = &camlCamlinternalOO__24;
  camlCamlinternalOO[58] = &camlCamlinternalOO__23;
  camlCamlinternalOO[59] = &camlCamlinternalOO__22;
  camlCamlinternalOO[60] = &camlCamlinternalOO__21;
  camlCamlinternalOO[61] = &camlCamlinternalOO__20;
  camlCamlinternalOO[62] = &camlCamlinternalOO__19;
  camlCamlinternalOO[63] = &camlCamlinternalOO__18;
  camlCamlinternalOO[64] = &camlCamlinternalOO__17;
  camlCamlinternalOO[65] = &camlCamlinternalOO__16;
  camlCamlinternalOO[66] = &camlCamlinternalOO__15;
  camlCamlinternalOO[67] = &camlCamlinternalOO__14;
  camlCamlinternalOO[68] = &camlCamlinternalOO__13;
  camlCamlinternalOO[69] = &camlCamlinternalOO__12;
  camlCamlinternalOO[70] = &camlCamlinternalOO__11;
  camlCamlinternalOO[71] = &camlCamlinternalOO__10;
  camlCamlinternalOO[72] = &camlCamlinternalOO__9;
  camlCamlinternalOO[73] = &camlCamlinternalOO__8;
  camlCamlinternalOO[74] = &camlCamlinternalOO__7;
  camlCamlinternalOO[75] = &camlCamlinternalOO__6;
  camlCamlinternalOO[76] = &camlCamlinternalOO__5;
  camlCamlinternalOO[77] = &camlCamlinternalOO__4;
  camlCamlinternalOO[78] = &camlCamlinternalOO__3;
  camlCamlinternalOO[10] = &camlCamlinternalOO__2;
  camlCamlinternalOO[29] = &camlCamlinternalOO__1;
  return 1LL;
}
// 42534B: variable 'v36' is possibly undefined
// 425354: variable 'v6' is possibly undefined
// 42546F: variable 'v7' is possibly undefined
// 42546F: variable 'v8' is possibly undefined
// 425489: variable 'v12' is possibly undefined
// 425489: variable 'v13' is possibly undefined
// 425489: variable 'v14' is possibly undefined
// 425489: variable 'v15' is possibly undefined
// 425489: variable 'v37' is possibly undefined
// 42549D: variable 'v16' is possibly undefined
// 42549D: variable 'v17' is possibly undefined
// 42549D: variable 'v18' is possibly undefined
// 4254B7: variable 'v19' is possibly undefined
// 4254B7: variable 'v20' is possibly undefined
// 4254B7: variable 'v21' is possibly undefined
// 4254B7: variable 'v22' is possibly undefined
// 4254B7: variable 'v38' is possibly undefined
// 4254CB: variable 'v23' is possibly undefined
// 4254CB: variable 'v24' is possibly undefined
// 4254CB: variable 'v25' is possibly undefined
// 4254E5: variable 'v26' is possibly undefined
// 4254E5: variable 'v27' is possibly undefined
// 4254E5: variable 'v28' is possibly undefined
// 4254E5: variable 'v29' is possibly undefined
// 4254E5: variable 'v39' is possibly undefined
// 425591: variable 'v30' is possibly undefined
// 4255EC: variable 'v31' is possibly undefined
// 4255EC: variable 'v32' is possibly undefined
// 4255EC: variable 'v33' is possibly undefined
// 4255EC: variable 'v34' is possibly undefined
// 4255EC: variable 'v40' is possibly undefined
// 6515D0: using guessed type __int64 camlSys[33];
// 655DD0: using guessed type _QWORD camlCamlinternalOO[80];
// 656050: using guessed type __int64 (__fastcall *camlCamlinternalOO__1)();
// 656068: using guessed type __int64 (__fastcall *camlCamlinternalOO__2)();
// 656088: using guessed type __int64 (__fastcall *camlCamlinternalOO__3)();
// 6560A8: using guessed type __int64 (__fastcall *camlCamlinternalOO__4)();
// 6560C0: using guessed type __int64 (__fastcall *camlCamlinternalOO__5)();
// 6560E0: using guessed type __int64 (__fastcall *camlCamlinternalOO__6)();
// 656100: using guessed type __int64 (__fastcall *camlCamlinternalOO__7)();
// 656120: using guessed type __int64 (__fastcall *camlCamlinternalOO__8)();
// 656140: using guessed type __int64 (__fastcall *camlCamlinternalOO__9)();
// 656160: using guessed type __int64 (__fastcall *camlCamlinternalOO__10)();
// 656180: using guessed type __int64 (__fastcall *camlCamlinternalOO__11)();
// 6561A0: using guessed type __int64 (__fastcall *camlCamlinternalOO__12)();
// 6561C0: using guessed type __int64 (__fastcall *camlCamlinternalOO__13)();
// 6561E0: using guessed type __int64 (__fastcall *camlCamlinternalOO__14)();
// 656200: using guessed type __int64 (__fastcall *camlCamlinternalOO__15)();
// 656220: using guessed type __int64 (__fastcall *camlCamlinternalOO__16)();
// 656240: using guessed type __int64 (__fastcall *camlCamlinternalOO__17)();
// 656260: using guessed type __int64 (__fastcall *camlCamlinternalOO__18)();
// 656280: using guessed type __int64 (__fastcall *camlCamlinternalOO__19)();
// 6562A0: using guessed type __int64 (__fastcall *camlCamlinternalOO__20)();
// 6562C0: using guessed type __int64 (__fastcall *camlCamlinternalOO__21)();
// 6562E0: using guessed type __int64 (__fastcall *camlCamlinternalOO__22)();
// 656300: using guessed type __int64 (__fastcall *camlCamlinternalOO__23)();
// 656320: using guessed type __int64 (__fastcall *camlCamlinternalOO__24)();
// 656338: using guessed type __int64 (__fastcall *camlCamlinternalOO__25)();
// 656350: using guessed type __int64 (__fastcall *camlCamlinternalOO__26)();
// 656370: using guessed type __int64 (__fastcall *camlCamlinternalOO__27)();
// 656388: using guessed type __int64 (__fastcall *camlCamlinternalOO__28)();
// 6563A0: using guessed type __int64 (__fastcall *camlCamlinternalOO__29)();
// 6563C0: using guessed type __int64 (__fastcall *camlCamlinternalOO__30)();
// 6563E0: using guessed type __int64 (__fastcall *camlCamlinternalOO__31)();
// 656400: using guessed type __int64 (__fastcall *camlCamlinternalOO__32)();
// 656420: using guessed type __int64 (__fastcall *camlCamlinternalOO__33)();
// 656440: using guessed type __int64 (__fastcall *camlCamlinternalOO__34)();
// 656460: using guessed type __int64 (__fastcall *camlCamlinternalOO__35)();
// 656480: using guessed type __int64 (__fastcall *camlCamlinternalOO__36)();
// 6564A0: using guessed type __int64 (__fastcall *camlCamlinternalOO__37)();
// 6564B8: using guessed type __int64 (__fastcall *camlCamlinternalOO__38)();
// 6564D0: using guessed type __int64 (__fastcall *camlCamlinternalOO__39)();
// 6564F0: using guessed type __int64 (__fastcall *camlCamlinternalOO__40)();
// 656510: using guessed type __int64 (__fastcall *camlCamlinternalOO__41)();
// 656530: using guessed type __int64 (__fastcall *camlCamlinternalOO__42)();
// 656548: using guessed type __int64 (__fastcall *camlCamlinternalOO__43)();
// 656560: using guessed type __int64 (__fastcall *camlCamlinternalOO__44)();
// 656580: using guessed type __int64 (__fastcall *camlCamlinternalOO__45)();
// 6565A0: using guessed type __int64 (__fastcall *camlCamlinternalOO__46)();
// 6565C0: using guessed type __int64 (__fastcall *camlCamlinternalOO__47)();
// 6565E0: using guessed type __int64 (__fastcall *camlCamlinternalOO__48)();
// 6565F8: using guessed type __int64 (__fastcall *camlCamlinternalOO__49)();
// 656618: using guessed type __int64 (__fastcall *camlCamlinternalOO__50)();
// 656630: using guessed type __int64 (__fastcall *camlCamlinternalOO__51)();
// 656648: using guessed type __int64 (__fastcall *camlCamlinternalOO__52)();
// 656668: using guessed type __int64 (__fastcall *camlCamlinternalOO__53)();
// 656680: using guessed type __int64 (__fastcall *camlCamlinternalOO__54)();
// 6566A0: using guessed type __int64 (__fastcall *camlCamlinternalOO__55)();
// 6566C0: using guessed type __int64 (__fastcall *camlCamlinternalOO__56)();
// 6566E0: using guessed type __int64 (__fastcall *camlCamlinternalOO__57)();
// 656700: using guessed type __int64 (__fastcall *camlCamlinternalOO__58)();
// 656718: using guessed type __int64 (__fastcall *camlCamlinternalOO__59)();
// 656738: using guessed type __int64 (__fastcall *camlCamlinternalOO__60)();
// 656758: using guessed type __int64 (__fastcall *camlCamlinternalOO__61)();
// 656770: using guessed type __int64 (__fastcall *camlCamlinternalOO__62)();
// 656788: using guessed type __int64 (__fastcall *camlCamlinternalOO__63)();
// 6567A8: using guessed type __int64 (__fastcall *camlCamlinternalOO__64)();
// 6567C8: using guessed type __int64 (__fastcall *camlCamlinternalOO__65)();
// 6567E8: using guessed type __int64 (__fastcall *camlCamlinternalOO__66)();
// 656800: using guessed type __int64 (__fastcall *camlCamlinternalOO__67)();
// 656818: using guessed type __int64 (__fastcall *camlCamlinternalOO__68)();
// 656838: using guessed type __int64 (__fastcall *camlCamlinternalOO__69)();

//----- (0000000000425AD8) ----------------------------------------------------
_QWORD *__fastcall unix_accept(__int64 a1)
{
  int v1; // ebp
  _QWORD *result; // rax
  __int64 v3[8]; // [rsp+0h] [rbp-E8h] BYREF
  _QWORD *v4; // [rsp+40h] [rbp-A8h] BYREF
  socklen_t addr_len; // [rsp+4Ch] [rbp-9Ch] BYREF
  struct sockaddr addr; // [rsp+50h] [rbp-98h] BYREF
  unsigned __int64 v7; // [rsp+C8h] [rbp-20h]

  v7 = __readfsqword(0x28u);
  addr_len = 112;
  caml_enter_blocking_section();
  v1 = accept(a1 >> 1, &addr, &addr_len);
  caml_leave_blocking_section();
  if ( v1 == -1 )
    uerror("accept", 0LL);
  v4 = alloc_sockaddr((__int16 *)&addr, addr_len, v1);
  v3[0] = caml_local_roots;
  caml_local_roots = (__int64)v3;
  v3[2] = 1LL;
  v3[1] = 1LL;
  v3[3] = (__int64)&v4;
  result = caml_alloc_small(2LL, 0);
  *result = 2LL * v1 + 1;
  result[1] = v4;
  caml_local_roots = v3[0];
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000425BC4) ----------------------------------------------------
__int64 __fastcall unix_access(char *name, __int64 *a2)
{
  int v2; // eax

  v2 = caml_convert_flag_list(a2, (__int64)&access_permission_table);
  if ( access(name, v2) == -1 )
    uerror("access", name);
  return 1LL;
}

//----- (0000000000425C00) ----------------------------------------------------
_QWORD *__fastcall unix_inet_addr_of_string(char *cp)
{
  _DWORD v2[4]; // [rsp+0h] [rbp-38h] BYREF
  _QWORD buf[5]; // [rsp+10h] [rbp-28h] BYREF

  buf[3] = __readfsqword(0x28u);
  if ( inet_pton(2, cp, v2) > 0 )
    return alloc_inet_addr(v2);
  if ( inet_pton(10, cp, buf) <= 0 )
    caml_failwith("inet_addr_of_string");
  return alloc_inet6_addr(buf);
}

//----- (0000000000425C80) ----------------------------------------------------
__int64 __fastcall unix_alarm(__int64 a1)
{
  return 2LL * alarm(a1 >> 1) + 1;
}

//----- (0000000000425C98) ----------------------------------------------------
__int64 __fastcall unix_bind(__int64 a1, __int64 *a2)
{
  socklen_t len; // [rsp+Ch] [rbp-9Ch] BYREF
  struct sockaddr addr; // [rsp+10h] [rbp-98h] BYREF
  unsigned __int64 v5; // [rsp+88h] [rbp-20h]

  v5 = __readfsqword(0x28u);
  get_sockaddr(a2, (__int64)&addr, &len);
  if ( bind(a1 >> 1, &addr, len) == -1 )
    uerror("bind", 0LL);
  return 1LL;
}

//----- (0000000000425D1C) ----------------------------------------------------
__int64 __fastcall unix_chdir(void *a1)
{
  if ( chdir((const char *)a1) == -1 )
    uerror("chdir", a1);
  return 1LL;
}

//----- (0000000000425D40) ----------------------------------------------------
__int64 __fastcall unix_chmod(void *a1, __int64 a2)
{
  if ( chmod((const char *)a1, a2 >> 1) == -1 )
    uerror("chmod", a1);
  return 1LL;
}

//----- (0000000000425D68) ----------------------------------------------------
__int64 __fastcall unix_chown(void *a1, __int64 a2, __int64 a3)
{
  if ( chown((const char *)a1, a2 >> 1, a3 >> 1) == -1 )
    uerror("chown", a1);
  return 1LL;
}

//----- (0000000000425D94) ----------------------------------------------------
__int64 __fastcall unix_chroot(void *a1)
{
  if ( chroot((const char *)a1) == -1 )
    uerror("chroot", a1);
  return 1LL;
}

//----- (0000000000425DB8) ----------------------------------------------------
__int64 __fastcall unix_close(__int64 a1)
{
  if ( close(a1 >> 1) == -1 )
    uerror("close", 0LL);
  return 1LL;
}

//----- (0000000000425DE4) ----------------------------------------------------
__int64 __fastcall unix_closedir(DIR **a1)
{
  DIR *v2; // rdi

  v2 = *a1;
  if ( !v2 )
    unix_error(9, "closedir", 0LL);
  closedir(v2);
  *a1 = 0LL;
  return 1LL;
}

//----- (0000000000425E18) ----------------------------------------------------
__int64 __fastcall unix_connect(__int64 a1, __int64 *a2)
{
  int v2; // ebx
  socklen_t len; // [rsp+Ch] [rbp-9Ch] BYREF
  struct sockaddr addr; // [rsp+10h] [rbp-98h] BYREF
  unsigned __int64 v6; // [rsp+88h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  get_sockaddr(a2, (__int64)&addr, &len);
  caml_enter_blocking_section();
  v2 = connect(a1 >> 1, &addr, len);
  caml_leave_blocking_section();
  if ( v2 == -1 )
    uerror("connect", 0LL);
  return 1LL;
}

//----- (0000000000425EA8) ----------------------------------------------------
__int64 __fastcall unix_dup(__int64 a1)
{
  int v1; // eax

  v1 = dup(a1 >> 1);
  if ( v1 == -1 )
    uerror("dup", 0LL);
  return 2LL * v1 + 1;
}

//----- (0000000000425ED8) ----------------------------------------------------
__int64 __fastcall unix_dup2(__int64 a1, __int64 a2)
{
  if ( dup2(a1 >> 1, a2 >> 1) == -1 )
    uerror("dup2", 0LL);
  return 1LL;
}

//----- (0000000000425F08) ----------------------------------------------------
char *unix_environment()
{
  return caml_copy_string_array(environ);
}

//----- (0000000000425F20) ----------------------------------------------------
_QWORD *__fastcall unix_error_message(__int64 a1)
{
  char *v1; // rax

  if ( (a1 & 1) != 0 )
    LODWORD(a1) = error_table[(int)(a1 >> 1)];
  else
    a1 = *(_QWORD *)a1 >> 1;
  v1 = strerror(a1);
  return caml_copy_string(v1);
}
// 658520: using guessed type _DWORD error_table[68];

//----- (0000000000425F54) ----------------------------------------------------
void __fastcall __noreturn unix_execv(char *path, __int64 a2)
{
  char **v2; // rbx

  v2 = (char **)cstringvect(a2);
  execv(path, v2);
  caml_stat_free(v2);
  uerror("execv", path);
}

//----- (0000000000425F98) ----------------------------------------------------
void __fastcall __noreturn unix_execve(char *path, __int64 a2, __int64 a3)
{
  char **v4; // rbx
  char **v5; // rbp

  v4 = (char **)cstringvect(a2);
  v5 = (char **)cstringvect(a3);
  execve(path, v4, v5);
  caml_stat_free(v4);
  caml_stat_free(v5);
  uerror("execve", path);
}

//----- (0000000000426000) ----------------------------------------------------
void __fastcall __noreturn unix_execvpe(char *file, __int64 a2, __int64 a3)
{
  char **v4; // rbp
  char **v5; // r13

  v4 = (char **)cstringvect(a2);
  v5 = environ;
  environ = (char **)cstringvect(a3);
  execvp(file, v4);
  caml_stat_free(v4);
  caml_stat_free(environ);
  environ = v5;
  uerror("execvp", file);
}

//----- (000000000042607A) ----------------------------------------------------
void __fastcall __noreturn unix_execvp(char *file, __int64 a2)
{
  char **v2; // rbx

  v2 = (char **)cstringvect(a2);
  execvp(file, v2);
  caml_stat_free(v2);
  uerror("execvp", file);
}

//----- (00000000004260C0) ----------------------------------------------------
__int64 __fastcall unix_fchmod(__int64 a1, __int64 a2)
{
  if ( fchmod(a1 >> 1, a2 >> 1) == -1 )
    uerror(&unk_43CE98, 0LL);
  return 1LL;
}

//----- (00000000004260F0) ----------------------------------------------------
__int64 __fastcall unix_fchown(__int64 a1, __int64 a2, __int64 a3)
{
  if ( fchown(a1 >> 1, a2 >> 1, a3 >> 1) == -1 )
    uerror(&unk_43CE9F, 0LL);
  return 1LL;
}

//----- (0000000000426124) ----------------------------------------------------
__int64 __fastcall unix_clear_close_on_exec(__int64 a1)
{
  __int64 v1; // rdi
  int v2; // eax

  v1 = a1 >> 1;
  v2 = fcntl(v1, 1, 0LL);
  if ( v2 == -1 || fcntl(v1, 2, v2 & 0xFFFFFFFE) == -1 )
    uerror("clear_close_on_exec", 0LL);
  return 1LL;
}

//----- (0000000000426176) ----------------------------------------------------
__int64 __fastcall unix_set_close_on_exec(__int64 a1)
{
  __int64 v1; // rdi
  int v2; // eax

  v1 = a1 >> 1;
  v2 = fcntl(v1, 1, 0LL);
  if ( v2 == -1 || fcntl(v1, 2, v2 | 1u) == -1 )
    uerror("set_close_on_exec", 0LL);
  return 1LL;
}

//----- (00000000004261C8) ----------------------------------------------------
__int64 __fastcall unix_clear_nonblock(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // eax
  __int64 v3; // rdx

  v1 = a1 >> 1;
  v2 = fcntl(v1, 3, 0LL);
  if ( v2 == -1 || (v3 = v2, BYTE1(v3) = BYTE1(v2) & 0xF7, fcntl(v1, 4, v3) == -1) )
    uerror("clear_nonblock", 0LL);
  return 1LL;
}

//----- (000000000042621A) ----------------------------------------------------
__int64 __fastcall unix_set_nonblock(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // eax
  __int64 v3; // rdx

  v1 = a1 >> 1;
  v2 = fcntl(v1, 3, 0LL);
  if ( v2 == -1 || (v3 = v2, BYTE1(v3) = BYTE1(v2) | 8, fcntl(v1, 4, v3) == -1) )
    uerror("set_nonblock", 0LL);
  return 1LL;
}

//----- (000000000042626C) ----------------------------------------------------
__int64 unix_fork()
{
  __pid_t v0; // eax

  v0 = fork();
  if ( v0 == -1 )
    uerror("fork", 0LL);
  return 2LL * v0 + 1;
}
// 42626C: using guessed type __int64 __fastcall unix_fork();

//----- (0000000000426298) ----------------------------------------------------
__int64 __fastcall unix_ftruncate_64(__int64 a1, __int64 a2)
{
  if ( ftruncate64(a1 >> 1, *(_QWORD *)(a2 + 8)) == -1 )
    uerror("ftruncate", 0LL);
  return 1LL;
}

//----- (00000000004262C8) ----------------------------------------------------
__int64 __fastcall unix_ftruncate(__int64 a1, __int64 a2)
{
  if ( ftruncate64(a1 >> 1, a2 >> 1) == -1 )
    uerror("ftruncate", 0LL);
  return 1LL;
}

//----- (0000000000426300) ----------------------------------------------------
__int64 __fastcall unix_getaddrinfo(char *a1, char *a2, __int64 a3)
{
  __int64 v3; // rax
  char *v4; // rbx
  __int64 v5; // rax
  char *v6; // rbp
  __int64 i; // rax
  __int64 v8; // rax
  char v9; // dl
  __int64 v10; // rax
  int v11; // er12
  struct addrinfo *j; // rbx
  __int64 v13; // r12
  unsigned int ai_addrlen; // ebp
  char *ai_canonname; // rdi
  __int64 *v16; // rbp
  __int64 v18; // [rsp+20h] [rbp-208h]
  __int64 v19; // [rsp+28h] [rbp-200h] BYREF
  char *v20; // [rsp+30h] [rbp-1F8h] BYREF
  char *src; // [rsp+38h] [rbp-1F0h] BYREF
  __int64 v22[8]; // [rsp+40h] [rbp-1E8h] BYREF
  __int64 v23[8]; // [rsp+80h] [rbp-1A8h] BYREF
  __int64 v24[8]; // [rsp+C0h] [rbp-168h] BYREF
  struct addrinfo req; // [rsp+100h] [rbp-128h] BYREF
  _QWORD *v26; // [rsp+138h] [rbp-F0h] BYREF
  _QWORD *v27; // [rsp+140h] [rbp-E8h] BYREF
  _QWORD *v28; // [rsp+148h] [rbp-E0h] BYREF
  struct addrinfo *pai; // [rsp+150h] [rbp-D8h] BYREF
  _QWORD *v30; // [rsp+158h] [rbp-D0h] BYREF
  _QWORD *v31; // [rsp+160h] [rbp-C8h] BYREF
  __int64 v32; // [rsp+168h] [rbp-C0h] BYREF
  __int16 v33[60]; // [rsp+170h] [rbp-B8h] BYREF
  unsigned __int64 v34; // [rsp+1E8h] [rbp-40h]

  src = a1;
  v20 = a2;
  v19 = a3;
  v34 = __readfsqword(0x28u);
  v18 = caml_local_roots;
  v24[0] = caml_local_roots;
  v24[2] = 1LL;
  v24[1] = 3LL;
  v24[3] = (__int64)&src;
  v24[4] = (__int64)&v20;
  v24[5] = (__int64)&v19;
  v32 = 0LL;
  v31 = 0LL;
  v30 = 0LL;
  v23[0] = (__int64)v24;
  caml_local_roots = (__int64)v23;
  v23[2] = 1LL;
  v23[1] = 3LL;
  v23[3] = (__int64)&v32;
  v23[4] = (__int64)&v31;
  v23[5] = (__int64)&v30;
  v3 = caml_string_length((__int64)a1);
  v4 = 0LL;
  if ( v3 )
  {
    v4 = (char *)caml_stat_alloc(v3 + 1);
    strcpy(v4, src);
  }
  v5 = caml_string_length((__int64)v20);
  v6 = 0LL;
  if ( v5 )
  {
    v6 = (char *)caml_stat_alloc(v5 + 1);
    strcpy(v6, v20);
  }
  memset(&req, 0, sizeof(req));
  for ( i = v19; (i & 1) == 0; v19 = i )
  {
    v8 = *(_QWORD *)i;
    v31 = (_QWORD *)v8;
    if ( (v8 & 1) != 0 )
    {
      v10 = v8 >> 1;
      switch ( (_DWORD)v10 )
      {
        case 1:
          req.ai_flags |= 2u;
          break;
        case 2:
          req.ai_flags |= 1u;
          break;
        case 0:
          req.ai_flags |= 4u;
          break;
      }
    }
    else
    {
      v9 = *(_BYTE *)(v8 - 8);
      if ( v9 == 1 )
      {
        req.ai_socktype = socket_type_table[(int)(*(__int64 *)v8 >> 1)];
      }
      else if ( v9 )
      {
        if ( v9 == 2 )
          req.ai_protocol = *(__int64 *)v8 >> 1;
      }
      else
      {
        req.ai_family = socket_domain_table[(int)(*(__int64 *)v8 >> 1)];
      }
    }
    i = *(_QWORD *)(v19 + 8);
  }
  caml_enter_blocking_section();
  v11 = getaddrinfo(v4, v6, &req, &pai);
  caml_leave_blocking_section();
  if ( v4 )
    caml_stat_free(v4);
  if ( v6 )
    caml_stat_free(v6);
  v32 = 1LL;
  if ( !v11 )
  {
    for ( j = pai; j; j = j->ai_next )
    {
      v13 = caml_local_roots;
      v28 = 0LL;
      v27 = 0LL;
      v26 = 0LL;
      v22[0] = caml_local_roots;
      caml_local_roots = (__int64)v22;
      v22[2] = 1LL;
      v22[1] = 3LL;
      v22[3] = (__int64)&v28;
      v22[4] = (__int64)&v27;
      v22[5] = (__int64)&v26;
      ai_addrlen = j->ai_addrlen;
      if ( ai_addrlen > 0x70 )
        ai_addrlen = 112;
      __memcpy_chk(v33, j->ai_addr, ai_addrlen, 112LL);
      v27 = alloc_sockaddr(v33, ai_addrlen, -1);
      ai_canonname = j->ai_canonname;
      if ( !ai_canonname )
        ai_canonname = "";
      v26 = caml_copy_string(ai_canonname);
      v28 = caml_alloc_small(5LL, 0);
      *v28 = cst_to_constr(j->ai_family, socket_domain_table, 3, 0);
      v16 = v28 + 1;
      *v16 = cst_to_constr(j->ai_socktype, socket_type_table, 4, 0);
      v28[2] = 2LL * j->ai_protocol + 1;
      v28[3] = v27;
      v28[4] = v26;
      caml_local_roots = v13;
      v30 = v28;
      v31 = caml_alloc_small(2LL, 0);
      *v31 = v30;
      v31[1] = v32;
      v32 = (__int64)v31;
    }
    freeaddrinfo(pai);
  }
  caml_local_roots = v18;
  return v32;
}
// 40A588: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 658080: using guessed type _DWORD socket_domain_table[4];
// 658090: using guessed type _DWORD socket_type_table[4];
// 658A68: using guessed type __int64 caml_local_roots;
// 426300: using guessed type __int16 var_B8[60];

//----- (00000000004267F0) ----------------------------------------------------
_QWORD *unix_getcwd()
{
  char v1[4104]; // [rsp+0h] [rbp-1018h] BYREF
  unsigned __int64 v2; // [rsp+1008h] [rbp-10h]

  v2 = __readfsqword(0x28u);
  if ( !getcwd(v1, 0x1000uLL) )
    uerror("getcwd", 0LL);
  return caml_copy_string(v1);
}

//----- (0000000000426858) ----------------------------------------------------
__int64 unix_getegid()
{
  return 2LL * getegid() + 1;
}
// 426858: using guessed type __int64 __fastcall unix_getegid();

//----- (0000000000426870) ----------------------------------------------------
__int64 unix_geteuid()
{
  return 2LL * geteuid() + 1;
}
// 426870: using guessed type __int64 __fastcall unix_geteuid();

//----- (0000000000426888) ----------------------------------------------------
__int64 unix_getgid()
{
  return 2LL * getgid() + 1;
}
// 426888: using guessed type __int64 __fastcall unix_getgid();

//----- (00000000004268A0) ----------------------------------------------------
_QWORD *__fastcall alloc_group_entry(__int64 a1)
{
  _QWORD *result; // rax
  __int64 v2[9]; // [rsp+0h] [rbp-78h] BYREF
  __int64 v3; // [rsp+48h] [rbp-30h] BYREF
  __int64 v4; // [rsp+50h] [rbp-28h] BYREF
  __int64 v5; // [rsp+58h] [rbp-20h] BYREF

  v5 = 1LL;
  v4 = 1LL;
  v3 = 1LL;
  v2[0] = caml_local_roots;
  caml_local_roots = (__int64)v2;
  v2[2] = 1LL;
  v2[1] = 3LL;
  v2[3] = (__int64)&v5;
  v2[4] = (__int64)&v4;
  v2[5] = (__int64)&v3;
  v5 = (__int64)caml_copy_string(*(void **)a1);
  v4 = (__int64)caml_copy_string(*(void **)(a1 + 8));
  v3 = (__int64)caml_copy_string_array(*(_QWORD **)(a1 + 24));
  result = caml_alloc_small(4LL, 0);
  *result = v5;
  result[1] = v4;
  result[2] = 2LL * *(unsigned int *)(a1 + 16) + 1;
  result[3] = v3;
  caml_local_roots = v2[0];
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000426974) ----------------------------------------------------
_QWORD *__fastcall unix_getgrgid(__int64 a1)
{
  struct group *v1; // rax

  v1 = getgrgid(a1 >> 1);
  if ( !v1 )
    caml_raise_not_found();
  return alloc_group_entry((__int64)v1);
}

//----- (0000000000426997) ----------------------------------------------------
_QWORD *__fastcall unix_getgrnam(const char *a1)
{
  struct group *v1; // rax

  v1 = getgrnam(a1);
  if ( !v1 )
    caml_raise_not_found();
  return alloc_group_entry((__int64)v1);
}

//----- (00000000004269B8) ----------------------------------------------------
char *unix_getgroups()
{
  int v0; // eax
  int v1; // ebx
  char *result; // rax
  unsigned __int64 v3; // rdx
  __gid_t v4[65538]; // [rsp+0h] [rbp-40008h] BYREF

  v0 = getgroups(0x10000, v4);
  v1 = v0;
  if ( v0 == -1 )
    uerror("getgroups", 0LL);
  result = caml_alloc_tuple(v0);
  if ( v1 > 0 )
  {
    v3 = 0LL;
    do
    {
      *(_QWORD *)&result[2 * v3] = 2LL * v4[v3 / 4] + 1;
      v3 += 4LL;
    }
    while ( v3 != 4LL * (unsigned int)(v1 - 1) + 4 );
  }
  return result;
}

//----- (0000000000426A30) ----------------------------------------------------
_QWORD *__fastcall alloc_host_entry(__int64 a1)
{
  _QWORD *v2; // rdi
  _QWORD *result; // rax
  int v4; // ecx
  __int64 v5[8]; // [rsp+0h] [rbp-68h] BYREF
  __int64 v6; // [rsp+40h] [rbp-28h] BYREF
  __int64 v7; // [rsp+48h] [rbp-20h] BYREF
  __int64 v8; // [rsp+50h] [rbp-18h] BYREF
  __int64 v9; // [rsp+58h] [rbp-10h] BYREF

  v9 = 1LL;
  v8 = 1LL;
  v7 = 1LL;
  v6 = 1LL;
  v5[0] = caml_local_roots;
  caml_local_roots = (__int64)v5;
  v5[2] = 1LL;
  v5[1] = 4LL;
  v5[3] = (__int64)&v9;
  v5[4] = (__int64)&v8;
  v5[5] = (__int64)&v7;
  v5[6] = (__int64)&v6;
  v9 = (__int64)caml_copy_string(*(void **)a1);
  v2 = *(_QWORD **)(a1 + 8);
  if ( v2 )
    v8 = (__int64)caml_copy_string_array(v2);
  else
    v8 = (__int64)&caml_atom_table[1];
  entry_h_length = *(_DWORD *)(a1 + 20);
  v7 = (__int64)caml_alloc_array((__int64 (__fastcall *)(_QWORD))alloc_one_addr, *(_QWORD **)(a1 + 24));
  result = caml_alloc_small(4LL, 0);
  *result = v9;
  result[1] = v8;
  v4 = *(_DWORD *)(a1 + 16);
  if ( v4 == 1 )
    result[2] = 1LL;
  else
    result[2] = 2LL * (v4 != 2) + 3;
  result[3] = v7;
  caml_local_roots = v5[0];
  return result;
}
// 6588B8: using guessed type int entry_h_length;
// 658A68: using guessed type __int64 caml_local_roots;
// 662960: using guessed type _QWORD caml_atom_table[1];

//----- (0000000000426B5B) ----------------------------------------------------
_QWORD *__fastcall unix_gethostbyname(char *src)
{
  __int64 v1; // rax
  char *v2; // rbx
  int *v3; // rax
  int v4; // ebp
  hostent v6; // [rsp+0h] [rbp-2768h] BYREF
  struct hostent *result; // [rsp+28h] [rbp-2740h] BYREF
  char buf[10008]; // [rsp+30h] [rbp-2738h] BYREF
  unsigned __int64 v9; // [rsp+2748h] [rbp-20h]

  v9 = __readfsqword(0x28u);
  v1 = caml_string_length((__int64)src);
  v2 = (char *)caml_stat_alloc(v1 + 1);
  strcpy(v2, src);
  caml_enter_blocking_section();
  v3 = __h_errno_location();
  v4 = gethostbyname_r(v2, &v6, buf, 0x2710uLL, &result, v3);
  caml_leave_blocking_section();
  if ( v4 )
    result = 0LL;
  caml_stat_free(v2);
  if ( !result )
    caml_raise_not_found();
  return alloc_host_entry((__int64)result);
}
// 426B5B: using guessed type char buf[10008];
// 426B5B: using guessed type struct hostent anonymous_0;

//----- (0000000000426C11) ----------------------------------------------------
_QWORD *__fastcall unix_gethostbyaddr(int *a1)
{
  int v1; // ebx
  struct hostent result_buf; // [rsp+10h] [rbp-2768h] BYREF
  struct hostent *v4; // [rsp+30h] [rbp-2748h] BYREF
  int h_errnop; // [rsp+3Ch] [rbp-273Ch] BYREF
  int addr[4]; // [rsp+40h] [rbp-2738h] BYREF
  char buf[10008]; // [rsp+50h] [rbp-2728h] BYREF
  unsigned __int64 v8; // [rsp+2768h] [rbp-10h]

  v8 = __readfsqword(0x28u);
  addr[0] = *a1;
  caml_enter_blocking_section();
  v1 = gethostbyaddr_r(addr, 4u, 2, &result_buf, buf, 0x2710uLL, &v4, &h_errnop);
  caml_leave_blocking_section();
  if ( v1 )
  {
    v4 = 0LL;
    goto LABEL_4;
  }
  if ( !v4 )
LABEL_4:
    caml_raise_not_found();
  return alloc_host_entry((__int64)v4);
}
// 426C11: using guessed type int addr[4];
// 426C11: using guessed type char buf[10008];

//----- (0000000000426CBE) ----------------------------------------------------
_QWORD *__fastcall alloc_one_addr(void *src)
{
  _DWORD v2[4]; // [rsp+0h] [rbp-38h] BYREF
  _QWORD dest[5]; // [rsp+10h] [rbp-28h] BYREF

  dest[3] = __readfsqword(0x28u);
  if ( entry_h_length == 16 )
  {
    memmove(dest, src, 0x10uLL);
    return alloc_inet6_addr(dest);
  }
  else
  {
    memmove(v2, src, 4uLL);
    return alloc_inet_addr(v2);
  }
}
// 6588B8: using guessed type int entry_h_length;

//----- (0000000000426D30) ----------------------------------------------------
_QWORD *unix_gethostname()
{
  char v1[72]; // [rsp+0h] [rbp-58h] BYREF
  unsigned __int64 v2; // [rsp+48h] [rbp-10h]

  v2 = __readfsqword(0x28u);
  gethostname(v1, 0x40uLL);
  v1[63] = 0;
  return caml_copy_string(v1);
}

//----- (0000000000426D7C) ----------------------------------------------------
_QWORD *unix_getlogin()
{
  char *v0; // rax

  v0 = getlogin();
  if ( !v0 )
    unix_error(2, "getlogin", 0LL);
  return caml_copy_string(v0);
}

//----- (0000000000426DB0) ----------------------------------------------------
_QWORD *__fastcall unix_getnameinfo(__int64 *a1, __int64 *a2)
{
  __int64 v2; // rbx
  int flags; // er12
  int v4; // ebp
  __int64 v6[8]; // [rsp+10h] [rbp-14F8h] BYREF
  _QWORD *v7; // [rsp+50h] [rbp-14B8h] BYREF
  _QWORD *v8; // [rsp+58h] [rbp-14B0h] BYREF
  _QWORD *v9; // [rsp+60h] [rbp-14A8h] BYREF
  socklen_t salen; // [rsp+6Ch] [rbp-149Ch] BYREF
  char host[4096]; // [rsp+70h] [rbp-1498h] BYREF
  char serv[1024]; // [rsp+1070h] [rbp-498h] BYREF
  struct sockaddr sa; // [rsp+1470h] [rbp-98h] BYREF
  unsigned __int64 v14; // [rsp+14E8h] [rbp-20h]

  v14 = __readfsqword(0x28u);
  v2 = caml_local_roots;
  v9 = 0LL;
  v8 = 0LL;
  v7 = 0LL;
  v6[0] = caml_local_roots;
  caml_local_roots = (__int64)v6;
  v6[2] = 1LL;
  v6[1] = 3LL;
  v6[3] = (__int64)&v9;
  v6[4] = (__int64)&v8;
  v6[5] = (__int64)&v7;
  get_sockaddr(a1, (__int64)&sa, &salen);
  flags = caml_convert_flag_list(a2, (__int64)&getnameinfo_flag_table);
  caml_enter_blocking_section();
  v4 = getnameinfo(&sa, salen, host, 0x1000u, serv, 0x400u, flags);
  caml_leave_blocking_section();
  if ( v4 )
    caml_raise_not_found();
  v9 = caml_copy_string(host);
  v8 = caml_copy_string(serv);
  v7 = caml_alloc_small(2LL, 0);
  *v7 = v9;
  v7[1] = v8;
  caml_local_roots = v2;
  return v7;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000426F18) ----------------------------------------------------
_QWORD *__fastcall unix_getpeername(__int64 a1)
{
  socklen_t len; // [rsp+Ch] [rbp-8Ch] BYREF
  struct sockaddr addr; // [rsp+10h] [rbp-88h] BYREF
  unsigned __int64 v4; // [rsp+88h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  len = 112;
  if ( getpeername(a1 >> 1, &addr, &len) == -1 )
    uerror("getpeername", 0LL);
  return alloc_sockaddr((__int16 *)&addr, len, -1);
}

//----- (0000000000426F98) ----------------------------------------------------
__int64 unix_getpid()
{
  return 2LL * getpid() + 1;
}
// 426F98: using guessed type __int64 __fastcall unix_getpid();

//----- (0000000000426FB0) ----------------------------------------------------
__int64 unix_getppid()
{
  return 2LL * getppid() + 1;
}
// 426FB0: using guessed type __int64 __fastcall unix_getppid();

//----- (0000000000426FC8) ----------------------------------------------------
_QWORD *__fastcall alloc_proto_entry(__int64 a1)
{
  _QWORD *result; // rax
  __int64 v2[8]; // [rsp+0h] [rbp-68h] BYREF
  __int64 v3; // [rsp+40h] [rbp-28h] BYREF
  __int64 v4; // [rsp+48h] [rbp-20h] BYREF

  v4 = 1LL;
  v3 = 1LL;
  v2[0] = caml_local_roots;
  caml_local_roots = (__int64)v2;
  v2[2] = 1LL;
  v2[1] = 2LL;
  v2[3] = (__int64)&v4;
  v2[4] = (__int64)&v3;
  v4 = (__int64)caml_copy_string(*(void **)a1);
  v3 = (__int64)caml_copy_string_array(*(_QWORD **)(a1 + 8));
  result = caml_alloc_small(3LL, 0);
  *result = v4;
  result[1] = v3;
  result[2] = 2LL * *(int *)(a1 + 16) + 1;
  caml_local_roots = v2[0];
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000427073) ----------------------------------------------------
_QWORD *__fastcall unix_getprotobynumber(__int64 a1)
{
  struct protoent *v1; // rax

  v1 = getprotobynumber(a1 >> 1);
  if ( !v1 )
    caml_raise_not_found();
  return alloc_proto_entry((__int64)v1);
}

//----- (0000000000427096) ----------------------------------------------------
_QWORD *__fastcall unix_getprotobyname(const char *a1)
{
  struct protoent *v1; // rax

  v1 = getprotobyname(a1);
  if ( !v1 )
    caml_raise_not_found();
  return alloc_proto_entry((__int64)v1);
}

//----- (00000000004270B8) ----------------------------------------------------
_QWORD *__fastcall alloc_passwd_entry(__int64 a1)
{
  _QWORD *result; // rax
  __int64 v2[9]; // [rsp+0h] [rbp-88h] BYREF
  __int64 v3; // [rsp+48h] [rbp-40h] BYREF
  __int64 v4; // [rsp+50h] [rbp-38h] BYREF
  __int64 v5; // [rsp+58h] [rbp-30h] BYREF
  __int64 v6; // [rsp+60h] [rbp-28h] BYREF
  __int64 v7; // [rsp+68h] [rbp-20h] BYREF

  v7 = 1LL;
  v6 = 1LL;
  v5 = 1LL;
  v4 = 1LL;
  v3 = 1LL;
  v2[0] = caml_local_roots;
  caml_local_roots = (__int64)v2;
  v2[2] = 1LL;
  v2[1] = 5LL;
  v2[3] = (__int64)&v7;
  v2[4] = (__int64)&v6;
  v2[5] = (__int64)&v5;
  v2[6] = (__int64)&v4;
  v2[7] = (__int64)&v3;
  v7 = (__int64)caml_copy_string(*(void **)a1);
  v6 = (__int64)caml_copy_string(*(void **)(a1 + 8));
  v5 = (__int64)caml_copy_string(*(void **)(a1 + 24));
  v4 = (__int64)caml_copy_string(*(void **)(a1 + 32));
  v3 = (__int64)caml_copy_string(*(void **)(a1 + 40));
  result = caml_alloc_small(7LL, 0);
  *result = v7;
  result[1] = v6;
  result[2] = 2LL * *(unsigned int *)(a1 + 16) + 1;
  result[3] = 2LL * *(unsigned int *)(a1 + 20) + 1;
  result[4] = v5;
  result[5] = v4;
  result[6] = v3;
  caml_local_roots = v2[0];
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (00000000004271EC) ----------------------------------------------------
_QWORD *__fastcall unix_getpwuid(__int64 a1)
{
  struct passwd *v1; // rax

  v1 = getpwuid(a1 >> 1);
  if ( !v1 )
    caml_raise_not_found();
  return alloc_passwd_entry((__int64)v1);
}

//----- (000000000042720F) ----------------------------------------------------
_QWORD *__fastcall unix_getpwnam(const char *a1)
{
  struct passwd *v1; // rax

  v1 = getpwnam(a1);
  if ( !v1 )
    caml_raise_not_found();
  return alloc_passwd_entry((__int64)v1);
}

//----- (0000000000427230) ----------------------------------------------------
__int64 unix_gettimeofday()
{
  struct timeval v1; // [rsp+0h] [rbp-18h] BYREF

  if ( gettimeofday(&v1, 0LL) == -1 )
    uerror("gettimeofday", 0LL);
  return caml_copy_double((double)SLODWORD(v1.tv_usec) / 1000000.0 + (double)SLODWORD(v1.tv_sec));
}
// 427230: using guessed type __int64 __fastcall unix_gettimeofday();

//----- (000000000042727C) ----------------------------------------------------
_QWORD *__fastcall alloc_service_entry(__int64 a1)
{
  _QWORD *result; // rax
  __int64 v2[9]; // [rsp+0h] [rbp-78h] BYREF
  __int64 v3; // [rsp+48h] [rbp-30h] BYREF
  __int64 v4; // [rsp+50h] [rbp-28h] BYREF
  __int64 v5; // [rsp+58h] [rbp-20h] BYREF

  v5 = 1LL;
  v4 = 1LL;
  v3 = 1LL;
  v2[0] = caml_local_roots;
  caml_local_roots = (__int64)v2;
  v2[2] = 1LL;
  v2[1] = 3LL;
  v2[3] = (__int64)&v5;
  v2[4] = (__int64)&v4;
  v2[5] = (__int64)&v3;
  v5 = (__int64)caml_copy_string(*(void **)a1);
  v4 = (__int64)caml_copy_string_array(*(_QWORD **)(a1 + 8));
  v3 = (__int64)caml_copy_string(*(void **)(a1 + 24));
  result = caml_alloc_small(4LL, 0);
  *result = v5;
  result[1] = v4;
  result[2] = 2LL * (unsigned __int16)__ROR2__(*(_DWORD *)(a1 + 16), 8) + 1;
  result[3] = v3;
  caml_local_roots = v2[0];
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000427357) ----------------------------------------------------
_QWORD *__fastcall unix_getservbyport(__int64 a1, const char *a2)
{
  struct servent *v2; // rax

  v2 = getservbyport((unsigned __int16)__ROR2__(a1 >> 1, 8), a2);
  if ( !v2 )
    caml_raise_not_found();
  return alloc_service_entry((__int64)v2);
}

//----- (0000000000427381) ----------------------------------------------------
_QWORD *__fastcall unix_getservbyname(const char *a1, const char *a2)
{
  struct servent *v2; // rax

  v2 = getservbyname(a1, a2);
  if ( !v2 )
    caml_raise_not_found();
  return alloc_service_entry((__int64)v2);
}

//----- (00000000004273A4) ----------------------------------------------------
_QWORD *__fastcall unix_getsockname(__int64 a1)
{
  socklen_t len; // [rsp+Ch] [rbp-8Ch] BYREF
  struct sockaddr addr; // [rsp+10h] [rbp-88h] BYREF
  unsigned __int64 v4; // [rsp+88h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  len = 112;
  if ( getsockname(a1 >> 1, &addr, &len) == -1 )
    uerror("getsockname", 0LL);
  return alloc_sockaddr((__int16 *)&addr, len, -1);
}

//----- (0000000000427424) ----------------------------------------------------
__int64 unix_getuid()
{
  return 2LL * getuid() + 1;
}
// 427424: using guessed type __int64 __fastcall unix_getuid();

//----- (000000000042743C) ----------------------------------------------------
_QWORD *__fastcall alloc_tm(int *a1)
{
  _QWORD *result; // rax

  result = caml_alloc_small(9LL, 0);
  *result = 2LL * *a1 + 1;
  result[1] = 2LL * a1[1] + 1;
  result[2] = 2LL * a1[2] + 1;
  result[3] = 2LL * a1[3] + 1;
  result[4] = 2LL * a1[4] + 1;
  result[5] = 2LL * a1[5] + 1;
  result[6] = 2LL * a1[6] + 1;
  result[7] = 2LL * a1[7] + 1;
  result[8] = (-(__int64)(a1[8] == 0) & 0xFFFFFFFFFFFFFFFELL) + 3;
  return result;
}

//----- (00000000004274CA) ----------------------------------------------------
_QWORD *__fastcall unix_mktime(__int64 *a1)
{
  time_t v1; // rax
  int v2; // ebx
  _QWORD *result; // rax
  __int64 v4[8]; // [rsp+0h] [rbp-98h] BYREF
  struct tm tp; // [rsp+40h] [rbp-58h] BYREF
  __int64 v6; // [rsp+80h] [rbp-18h] BYREF
  __int64 v7; // [rsp+88h] [rbp-10h] BYREF

  v7 = 1LL;
  v6 = 1LL;
  v4[0] = caml_local_roots;
  caml_local_roots = (__int64)v4;
  v4[2] = 1LL;
  v4[1] = 2LL;
  v4[3] = (__int64)&v7;
  v4[4] = (__int64)&v6;
  tp.tm_sec = *a1 >> 1;
  tp.tm_min = a1[1] >> 1;
  tp.tm_hour = a1[2] >> 1;
  tp.tm_mday = a1[3] >> 1;
  tp.tm_mon = a1[4] >> 1;
  tp.tm_year = a1[5] >> 1;
  tp.tm_wday = a1[6] >> 1;
  tp.tm_yday = a1[7] >> 1;
  tp.tm_isdst = -1;
  v1 = mktime(&tp);
  v2 = v1;
  if ( v1 == -1 )
    unix_error(34, "mktime", 0LL);
  v7 = (__int64)alloc_tm(&tp.tm_sec);
  v6 = caml_copy_double((double)v2);
  result = caml_alloc_small(2LL, 0);
  *result = v6;
  result[1] = v7;
  caml_local_roots = v4[0];
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000427610) ----------------------------------------------------
_QWORD *__fastcall unix_localtime(double *a1)
{
  struct tm *v1; // rax
  time_t timer; // [rsp+8h] [rbp-10h] BYREF

  timer = (unsigned int)(int)*a1;
  v1 = localtime(&timer);
  if ( !v1 )
    unix_error(22, "localtime", 0LL);
  return alloc_tm(&v1->tm_sec);
}

//----- (0000000000427650) ----------------------------------------------------
_QWORD *__fastcall unix_gmtime(double *a1)
{
  struct tm *v1; // rax
  time_t timer; // [rsp+8h] [rbp-10h] BYREF

  timer = (unsigned int)(int)*a1;
  v1 = gmtime(&timer);
  if ( !v1 )
    unix_error(22, "gmtime", 0LL);
  return alloc_tm(&v1->tm_sec);
}

//----- (0000000000427690) ----------------------------------------------------
unsigned __int64 __fastcall unix_isatty(__int64 a1)
{
  return (-(__int64)(isatty(a1 >> 1) == 0) & 0xFFFFFFFFFFFFFFFELL) + 3;
}

//----- (00000000004276B0) ----------------------------------------------------
double *__fastcall unix_convert_itimer(_QWORD *a1)
{
  double *result; // rax

  result = (double *)caml_alloc_small(2LL, 0xFEu);
  *result = (double)(int)a1[1] / 1000000.0 + (double)(int)*a1;
  result[1] = (double)(int)a1[3] / 1000000.0 + (double)(int)a1[2];
  return result;
}

//----- (0000000000427701) ----------------------------------------------------
double *__fastcall unix_getitimer(__int64 a1)
{
  struct itimerval v2; // [rsp+0h] [rbp-28h] BYREF

  if ( getitimer(itimers[(int)(a1 >> 1)], &v2) == -1 )
    uerror("getitimer", 0LL);
  return unix_convert_itimer(&v2);
}
// 43CF70: using guessed type __itimer_which_t itimers[3];

//----- (0000000000427740) ----------------------------------------------------
unsigned __int64 __fastcall unix_set_timeval(_QWORD *a1, double a2)
{
  double v2; // xmm0_8
  __int64 v3; // rbp
  unsigned __int64 result; // rax
  double iptr[2]; // [rsp+8h] [rbp-20h] BYREF

  v2 = modf(a2, iptr);
  v3 = (unsigned int)(int)iptr[0];
  *a1 = v3;
  result = (unsigned int)(int)ceil(v2 * 1000000.0);
  a1[1] = result;
  if ( result > 0xF423F )
  {
    *a1 = v3 + 1;
    a1[1] = 0LL;
  }
  return result;
}
// 427740: using guessed type double iptr[2];

//----- (00000000004277A1) ----------------------------------------------------
double *__fastcall unix_setitimer(__int64 a1, double *a2)
{
  struct itimerval v3; // [rsp+0h] [rbp-58h] BYREF
  struct itimerval newa; // [rsp+20h] [rbp-38h] BYREF

  unix_set_timeval(&newa, *a2);
  unix_set_timeval(&newa.it_value.tv_sec, a2[1]);
  if ( setitimer(itimers[(int)(a1 >> 1)], &newa, &v3) == -1 )
    uerror("setitimer", 0LL);
  return unix_convert_itimer(&v3);
}
// 43CF70: using guessed type __itimer_which_t itimers[3];

//----- (0000000000427828) ----------------------------------------------------
__int64 __fastcall unix_kill(__int64 a1, __int64 a2)
{
  int v2; // eax

  v2 = caml_convert_signal_number(a2 >> 1);
  if ( kill(a1 >> 1, v2) == -1 )
    uerror("kill", 0LL);
  return 1LL;
}

//----- (0000000000427860) ----------------------------------------------------
__int64 __fastcall unix_link(const char *a1, void *a2)
{
  if ( link(a1, (const char *)a2) == -1 )
    uerror("link", a2);
  return 1LL;
}

//----- (0000000000427884) ----------------------------------------------------
__int64 __fastcall unix_listen(__int64 a1, __int64 a2)
{
  if ( listen(a1 >> 1, a2 >> 1) == -1 )
    uerror("listen", 0LL);
  return 1LL;
}

//----- (00000000004278B4) ----------------------------------------------------
__int64 __fastcall unix_lockf(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rdx
  int v5; // ebx
  __int16 v7[4]; // [rsp+0h] [rbp-28h] BYREF
  __int64 v8; // [rsp+8h] [rbp-20h]
  __int64 v9; // [rsp+10h] [rbp-18h]

  v3 = a1 >> 1;
  v7[1] = 1;
  v4 = a3 >> 1;
  if ( v4 >= 0 )
  {
    v8 = 0LL;
  }
  else
  {
    v8 = v4;
    v4 = -v4;
  }
  v9 = v4;
  switch ( (unsigned int)(a2 >> 1) )
  {
    case 0u:
      v7[0] = 2;
      v5 = fcntl(v3, 6, v7);
      goto LABEL_14;
    case 1u:
      v7[0] = 1;
      caml_enter_blocking_section();
      v5 = fcntl(v3, 7, v7);
      caml_leave_blocking_section();
      goto LABEL_14;
    case 2u:
      v7[0] = 1;
      v5 = fcntl(v3, 6, v7);
      goto LABEL_14;
    case 3u:
      v7[0] = 1;
      if ( fcntl(v3, 5, v7) == -1 )
        break;
      if ( v7[0] == 2 )
        return 1LL;
      *__errno_location() = 13;
      break;
    case 4u:
      v7[0] = 0;
      caml_enter_blocking_section();
      v5 = fcntl(v3, 7, v7);
      caml_leave_blocking_section();
      goto LABEL_14;
    case 5u:
      v7[0] = 0;
      v5 = fcntl(v3, 6, v7);
LABEL_14:
      if ( v5 == -1 )
        break;
      return 1LL;
    default:
      *__errno_location() = 22;
      break;
  }
  uerror("lockf", 0LL);
}

//----- (0000000000427A1C) ----------------------------------------------------
_QWORD *__fastcall unix_lseek_64(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax

  v3 = lseek64(a1 >> 1, *(_QWORD *)(a2 + 8), seek_command_table[(int)(a3 >> 1)]);
  if ( v3 == -1 )
    uerror("lseek", 0LL);
  return caml_copy_int64(v3);
}
// 43CFB0: using guessed type _DWORD seek_command_table[3];

//----- (0000000000427A60) ----------------------------------------------------
__off64_t __fastcall unix_lseek(__int64 a1, __int64 a2, __int64 a3)
{
  __off64_t v3; // rax

  v3 = lseek64(a1 >> 1, a2 >> 1, seek_command_table[(int)(a3 >> 1)]);
  if ( v3 == -1 )
    uerror("lseek", 0LL);
  if ( v3 > 0x3FFFFFFFFFFFFFFFLL )
    unix_error(75, "lseek", 0LL);
  return 2 * v3 + 1;
}
// 43CFB0: using guessed type _DWORD seek_command_table[3];

//----- (0000000000427AC8) ----------------------------------------------------
__int64 __fastcall unix_mkdir(void *a1, __int64 a2)
{
  if ( mkdir((const char *)a1, a2 >> 1) == -1 )
    uerror("mkdir", a1);
  return 1LL;
}

//----- (0000000000427AF0) ----------------------------------------------------
__int64 __fastcall unix_mkfifo(void *a1, __int64 a2)
{
  if ( mkfifo((const char *)a1, a2 >> 1) == -1 )
    uerror("mkfifo", a1);
  return 1LL;
}

//----- (0000000000427B18) ----------------------------------------------------
__int64 __fastcall unix_nice(__int64 a1)
{
  int *v1; // rbx
  int v2; // eax

  v1 = __errno_location();
  *v1 = 0;
  v2 = nice(a1 >> 1);
  if ( v2 == -1 && *v1 )
    uerror("nice", 0LL);
  return 2LL * v2 + 1;
}

//----- (0000000000427B74) ----------------------------------------------------
__int64 __fastcall unix_open(char *a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // rbp
  int v4; // er12
  __int64 v5; // rax
  char *v6; // rbx
  int v7; // er12
  __int64 v9; // [rsp+8h] [rbp-70h] BYREF
  __int64 *v10; // [rsp+10h] [rbp-68h] BYREF
  char *src; // [rsp+18h] [rbp-60h] BYREF
  __int64 v12[11]; // [rsp+20h] [rbp-58h] BYREF

  src = a1;
  v10 = a2;
  v9 = a3;
  v3 = caml_local_roots;
  v12[0] = caml_local_roots;
  caml_local_roots = (__int64)v12;
  v12[2] = 1LL;
  v12[1] = 3LL;
  v12[3] = (__int64)&src;
  v12[4] = (__int64)&v10;
  v12[5] = (__int64)&v9;
  v4 = caml_convert_flag_list(a2, (__int64)&open_flag_table);
  v5 = caml_string_length((__int64)src);
  v6 = (char *)caml_stat_alloc(v5 + 1);
  strcpy(v6, src);
  caml_enter_blocking_section();
  v7 = open64(v6, v4, v9 >> 1);
  caml_leave_blocking_section();
  caml_stat_free(v6);
  if ( v7 == -1 )
    uerror("open", src);
  caml_local_roots = v3;
  return 2LL * v7 + 1;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000427C68) ----------------------------------------------------
_QWORD *__fastcall unix_opendir(char *a1)
{
  DIR *v1; // rbx
  _QWORD *result; // rax

  v1 = opendir(a1);
  if ( !v1 )
    uerror("opendir", a1);
  result = caml_alloc_small(1LL, 0xFBu);
  *result = v1;
  return result;
}

//----- (0000000000427CB8) ----------------------------------------------------
_QWORD *unix_pipe()
{
  _QWORD *result; // rax
  int v1[6]; // [rsp+0h] [rbp-18h] BYREF

  if ( pipe(v1) == -1 )
    uerror("pipe", 0LL);
  result = caml_alloc_small(2LL, 0);
  *result = 2LL * v1[0] + 1;
  result[1] = 2LL * v1[1] + 1;
  return result;
}

//----- (0000000000427D08) ----------------------------------------------------
__int64 __fastcall unix_putenv(void *src, void *a2)
{
  __int64 v2; // rbp
  __int64 v3; // r13
  char *v4; // rbx

  v2 = caml_string_length((__int64)src);
  v3 = caml_string_length((__int64)a2);
  v4 = (char *)caml_stat_alloc(v3 + v2 + 2);
  memmove(v4, src, v2);
  v4[v2] = 61;
  memmove(&v4[v2 + 1], a2, v3);
  v4[v3 + 1 + v2] = 0;
  if ( putenv(v4) == -1 )
    uerror("putenv", src);
  return 1LL;
}

//----- (0000000000427DC0) ----------------------------------------------------
__int64 __fastcall unix_read(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rbx
  int chk; // ebx
  __int64 v8; // [rsp+8h] [rbp-4070h] BYREF
  __int64 v9[8]; // [rsp+10h] [rbp-4068h] BYREF
  char src[16392]; // [rsp+50h] [rbp-4028h] BYREF
  unsigned __int64 v11; // [rsp+4058h] [rbp-20h]

  v8 = a2;
  v11 = __readfsqword(0x28u);
  v9[0] = caml_local_roots;
  caml_local_roots = (__int64)v9;
  v9[2] = 1LL;
  v9[1] = 1LL;
  v9[3] = (__int64)&v8;
  v5 = a4 >> 1;
  caml_enter_blocking_section();
  if ( v5 > 0x4000 )
    LODWORD(v5) = 0x4000;
  chk = __read_chk(a1 >> 1, src, (int)v5, 0x4000LL);
  caml_leave_blocking_section();
  if ( chk == -1 )
    uerror("read", 0LL);
  memmove((void *)(v8 + (a3 >> 1)), src, chk);
  caml_local_roots = v9[0];
  return 2LL * chk + 1;
}
// 40A748: using guessed type __int64 __fastcall __read_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000427EC0) ----------------------------------------------------
_QWORD *__fastcall unix_readdir(DIR **a1)
{
  DIR *v1; // rdi
  struct dirent64 *v2; // rax

  v1 = *a1;
  if ( !v1 )
    unix_error(9, "readdir", 0LL);
  v2 = readdir64(v1);
  if ( !v2 )
    caml_raise_end_of_file();
  return caml_copy_string(v2->d_name);
}

//----- (0000000000427F00) ----------------------------------------------------
_QWORD *__fastcall unix_readlink(char *a1)
{
  int v1; // eax
  char v3[4104]; // [rsp+0h] [rbp-1018h] BYREF
  unsigned __int64 v4; // [rsp+1008h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  v1 = readlink(a1, v3, 0xFFFuLL);
  if ( v1 == -1 )
    uerror(&unk_43CFF4, a1);
  v3[v1] = 0;
  return caml_copy_string(v3);
}
// 427F00: using guessed type char var_1018[4104];

//----- (0000000000427F70) ----------------------------------------------------
__int64 __fastcall unix_rename(void *a1, const char *a2)
{
  if ( rename((const char *)a1, a2) == -1 )
    uerror("rename", a1);
  return 1LL;
}

//----- (0000000000427F94) ----------------------------------------------------
__int64 __fastcall unix_rewinddir(DIR **a1)
{
  DIR *v1; // rdi

  v1 = *a1;
  if ( !v1 )
    unix_error(9, "rewinddir", 0LL);
  rewinddir(v1);
  return 1LL;
}

//----- (0000000000427FC4) ----------------------------------------------------
__int64 __fastcall unix_rmdir(void *a1)
{
  if ( rmdir((const char *)a1) == -1 )
    uerror("rmdir", a1);
  return 1LL;
}

//----- (0000000000427FE8) ----------------------------------------------------
__int64 __fastcall fdlist_to_fdset(_QWORD *a1, void *a2, _DWORD *a3)
{
  _QWORD *v3; // r8
  __int64 result; // rax

  v3 = a1;
  result = 0LL;
  memset(a2, 0, 0x80uLL);
  if ( a1 != (_QWORD *)1 )
  {
    do
    {
      result = *v3 >> 1;
      *((_QWORD *)a2 + (int)result / 64) |= 1LL << ((int)result % 64);
      if ( (int)result > *a3 )
        *a3 = result;
      v3 = (_QWORD *)v3[1];
    }
    while ( v3 != (_QWORD *)1 );
  }
  return result;
}

//----- (000000000042804D) ----------------------------------------------------
__int64 __fastcall fdset_to_fdlist(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdx
  _QWORD *v4; // rax
  __int64 v6[8]; // [rsp+0h] [rbp-68h] BYREF
  __int64 v7; // [rsp+40h] [rbp-28h] BYREF
  _QWORD *i; // [rsp+48h] [rbp-20h] BYREF

  v7 = 1LL;
  v6[0] = caml_local_roots;
  caml_local_roots = (__int64)v6;
  v6[2] = 1LL;
  v6[1] = 2LL;
  v6[3] = (__int64)&i;
  v6[4] = (__int64)&v7;
  if ( a1 != (_QWORD *)1 )
  {
    for ( i = a1; ; i = (_QWORD *)i[1] )
    {
      v2 = *a1 >> 1;
      v3 = *(_QWORD *)(a2 + 8LL * ((int)v2 / 64));
      if ( _bittest64(&v3, (unsigned int)((int)v2 % 64)) )
      {
        v4 = caml_alloc_small(2LL, 0);
        *v4 = 2LL * (int)v2 + 1;
        v4[1] = v7;
        v7 = (__int64)v4;
      }
      a1 = (_QWORD *)i[1];
      if ( a1 == (_QWORD *)1 )
        break;
    }
  }
  caml_local_roots = v6[0];
  return v7;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (000000000042812A) ----------------------------------------------------
_QWORD *__fastcall unix_select(_QWORD *a1, _QWORD *a2, _QWORD *a3, double *a4)
{
  double v5; // xmm0_8
  struct timeval *v6; // rbx
  int v7; // ebx
  _QWORD *result; // rax
  _QWORD *v9; // [rsp+8h] [rbp-210h] BYREF
  _QWORD *v10; // [rsp+10h] [rbp-208h] BYREF
  _QWORD *v11; // [rsp+18h] [rbp-200h] BYREF
  fd_set exceptfds; // [rsp+20h] [rbp-1F8h] BYREF
  fd_set writefds; // [rsp+A0h] [rbp-178h] BYREF
  fd_set readfds; // [rsp+120h] [rbp-F8h] BYREF
  __int64 v15[8]; // [rsp+1A0h] [rbp-78h] BYREF
  __int64 v16[3]; // [rsp+1E0h] [rbp-38h] BYREF
  int v17[7]; // [rsp+1FCh] [rbp-1Ch] BYREF

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v15[0] = caml_local_roots;
  caml_local_roots = (__int64)v15;
  v15[2] = 1LL;
  v15[1] = 3LL;
  v15[3] = (__int64)&v11;
  v15[4] = (__int64)&v10;
  v15[5] = (__int64)&v9;
  v17[0] = -1;
  fdlist_to_fdset(a1, &readfds, v17);
  fdlist_to_fdset(v10, &writefds, v17);
  fdlist_to_fdset(v9, &exceptfds, v17);
  v5 = *a4;
  v6 = 0LL;
  if ( *a4 >= 0.0 )
  {
    v16[0] = (int)v5;
    v16[1] = (int)((v5 - (double)SLODWORD(v16[0])) * 1000000.0);
    v6 = (struct timeval *)v16;
  }
  caml_enter_blocking_section();
  v7 = select(v17[0] + 1, &readfds, &writefds, &exceptfds, v6);
  caml_leave_blocking_section();
  if ( v7 == -1 )
    uerror("select", 0LL);
  v11 = (_QWORD *)fdset_to_fdlist(v11, (__int64)&readfds);
  v10 = (_QWORD *)fdset_to_fdlist(v10, (__int64)&writefds);
  v9 = (_QWORD *)fdset_to_fdlist(v9, (__int64)&exceptfds);
  result = caml_alloc_small(3LL, 0);
  *result = v11;
  result[1] = v10;
  result[2] = v9;
  caml_local_roots = v15[0];
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000428308) ----------------------------------------------------
__int64 __fastcall unix_sendto_native(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5, __int64 *a6)
{
  __int64 v9; // r12
  __int64 v10; // rbx
  int v11; // ebx
  int flags; // [rsp+Ch] [rbp-40CCh]
  socklen_t addr_len; // [rsp+1Ch] [rbp-40BCh] BYREF
  char buf[16384]; // [rsp+20h] [rbp-40B8h] BYREF
  struct sockaddr addr; // [rsp+4020h] [rbp-B8h] BYREF
  unsigned __int64 v17; // [rsp+4098h] [rbp-40h]

  v17 = __readfsqword(0x28u);
  flags = caml_convert_flag_list(a5, (__int64)&msg_flag_table);
  get_sockaddr(a6, (__int64)&addr, &addr_len);
  v9 = a4 >> 1;
  v10 = 0x4000LL;
  if ( v9 <= 0x4000 )
    v10 = v9;
  __memmove_chk(buf, (a3 >> 1) + a2, v10, 0x4000LL);
  caml_enter_blocking_section();
  v11 = sendto(a1 >> 1, buf, (int)v10, flags, &addr, addr_len);
  caml_leave_blocking_section();
  if ( v11 == -1 )
    uerror("sendto", 0LL);
  return 2LL * v11 + 1;
}
// 40AC28: using guessed type __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000428441) ----------------------------------------------------
__int64 __fastcall unix_sendto(__int64 a1)
{
  return unix_sendto_native(
           *(_QWORD *)a1,
           *(_QWORD *)(a1 + 8),
           *(_QWORD *)(a1 + 16),
           *(_QWORD *)(a1 + 24),
           *(__int64 **)(a1 + 32),
           *(__int64 **)(a1 + 40));
}

//----- (0000000000428466) ----------------------------------------------------
__int64 __fastcall unix_send(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5)
{
  int v7; // er14
  __int64 v8; // rbx
  int v9; // ebx
  _QWORD v11[2050]; // [rsp+0h] [rbp-4038h] BYREF

  v11[2049] = __readfsqword(0x28u);
  v7 = caml_convert_flag_list(a5, (__int64)&msg_flag_table);
  v8 = a4 >> 1;
  if ( v8 > 0x4000 )
    v8 = 0x4000LL;
  __memmove_chk(v11, (a3 >> 1) + a2, v8, 0x4000LL);
  caml_enter_blocking_section();
  v9 = send(a1 >> 1, v11, (int)v8, v7);
  caml_leave_blocking_section();
  if ( v9 == -1 )
    uerror("send", 0LL);
  return 2LL * v9 + 1;
}
// 40AC28: using guessed type __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000428568) ----------------------------------------------------
_QWORD *__fastcall unix_recvfrom(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5)
{
  unsigned int v7; // er12
  __int64 v8; // rbx
  int v9; // ebx
  _QWORD *result; // rax
  __int64 v11; // [rsp+18h] [rbp-4100h] BYREF
  __int64 v12[8]; // [rsp+20h] [rbp-40F8h] BYREF
  __int64 v13; // [rsp+60h] [rbp-40B8h] BYREF
  unsigned int v14; // [rsp+6Ch] [rbp-40ACh] BYREF
  char src[16384]; // [rsp+70h] [rbp-40A8h] BYREF
  __int16 v16[60]; // [rsp+4070h] [rbp-A8h] BYREF
  unsigned __int64 v17; // [rsp+40E8h] [rbp-30h]

  v11 = a2;
  v17 = __readfsqword(0x28u);
  v13 = 1LL;
  v7 = caml_convert_flag_list(a5, (__int64)&msg_flag_table);
  v12[0] = caml_local_roots;
  caml_local_roots = (__int64)v12;
  v12[2] = 1LL;
  v12[1] = 2LL;
  v12[3] = (__int64)&v11;
  v12[4] = (__int64)&v13;
  v8 = a4 >> 1;
  v14 = 112;
  caml_enter_blocking_section();
  if ( v8 > 0x4000 )
    LODWORD(v8) = 0x4000;
  v9 = __recvfrom_chk(a1 >> 1, src, (int)v8, 0x4000LL, v7, v16, &v14);
  caml_leave_blocking_section();
  if ( v9 == -1 )
    uerror("recvfrom", 0LL);
  memmove((void *)(v11 + (a3 >> 1)), src, v9);
  v13 = (__int64)alloc_sockaddr(v16, v14, -1);
  result = caml_alloc_small(2LL, 0);
  *result = 2LL * v9 + 1;
  result[1] = v13;
  caml_local_roots = v12[0];
  return result;
}
// 40A9B8: using guessed type __int64 __fastcall __recvfrom_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 658A68: using guessed type __int64 caml_local_roots;
// 428568: using guessed type __int16 var_A8[60];

//----- (00000000004286E2) ----------------------------------------------------
__int64 __fastcall unix_recv(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5)
{
  unsigned int v7; // er12
  __int64 v8; // rbx
  int v9; // ebx
  __int64 v11; // [rsp+8h] [rbp-4080h] BYREF
  __int64 v12[8]; // [rsp+10h] [rbp-4078h] BYREF
  char src[16392]; // [rsp+50h] [rbp-4038h] BYREF
  unsigned __int64 v14; // [rsp+4058h] [rbp-30h]

  v11 = a2;
  v14 = __readfsqword(0x28u);
  v7 = caml_convert_flag_list(a5, (__int64)&msg_flag_table);
  v12[0] = caml_local_roots;
  caml_local_roots = (__int64)v12;
  v12[2] = 1LL;
  v12[1] = 1LL;
  v12[3] = (__int64)&v11;
  v8 = a4 >> 1;
  caml_enter_blocking_section();
  if ( v8 > 0x4000 )
    LODWORD(v8) = 0x4000;
  v9 = __recv_chk(a1 >> 1, src, (int)v8, 0x4000LL, v7);
  caml_leave_blocking_section();
  if ( v9 == -1 )
    uerror("recv", 0LL);
  memmove((void *)(v11 + (a3 >> 1)), src, v9);
  caml_local_roots = v12[0];
  return 2LL * v9 + 1;
}
// 40A6E8: using guessed type __int64 __fastcall __recv_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000428824) ----------------------------------------------------
__int64 __fastcall unix_setgid(__int64 a1)
{
  if ( setgid(a1 >> 1) == -1 )
    uerror("setgid", 0LL);
  return 1LL;
}

//----- (0000000000428850) ----------------------------------------------------
__int64 unix_setsid()
{
  return 2LL * setsid() + 1;
}
// 428850: using guessed type __int64 __fastcall unix_setsid();

//----- (0000000000428868) ----------------------------------------------------
__int64 __fastcall unix_setuid(__int64 a1)
{
  if ( setuid(a1 >> 1) == -1 )
    uerror("setuid", 0LL);
  return 1LL;
}

//----- (0000000000428894) ----------------------------------------------------
__int64 __fastcall unix_shutdown(__int64 a1, __int64 a2)
{
  if ( shutdown(a1 >> 1, shutdown_command_table[(int)(a2 >> 1)]) == -1 )
    uerror("shutdown", 0LL);
  return 1LL;
}
// 43D05C: using guessed type _DWORD shutdown_command_table[3];

//----- (00000000004288D0) ----------------------------------------------------
int __fastcall decode_sigset(__int64 *a1, sigset_t *a2)
{
  __int64 *v2; // rbx
  int result; // eax
  int v4; // eax

  v2 = a1;
  for ( result = sigemptyset(a2); v2 != (__int64 *)1; v2 = (__int64 *)v2[1] )
  {
    v4 = caml_convert_signal_number(*v2 >> 1);
    result = sigaddset(a2, v4);
  }
  return result;
}

//----- (0000000000428910) ----------------------------------------------------
__int64 __fastcall unix_sigsuspend(__int64 *a1)
{
  int v1; // ebx
  sigset_t v3; // [rsp+0h] [rbp-88h] BYREF

  decode_sigset(a1, &v3);
  caml_enter_blocking_section();
  v1 = sigsuspend(&v3);
  caml_leave_blocking_section();
  if ( v1 == -1 && *__errno_location() != 4 )
    uerror("sigsuspend", 0LL);
  return 1LL;
}

//----- (000000000042895E) ----------------------------------------------------
__int64 __fastcall encode_sigset(sigset_t *set)
{
  unsigned int i; // ebx
  _QWORD *v2; // rbp
  __int64 v4[9]; // [rsp+0h] [rbp-68h] BYREF
  __int64 v5; // [rsp+48h] [rbp-20h] BYREF

  v5 = 1LL;
  v4[0] = caml_local_roots;
  caml_local_roots = (__int64)v4;
  v4[2] = 1LL;
  v4[1] = 1LL;
  v4[3] = (__int64)&v5;
  for ( i = 1; i != 65; ++i )
  {
    if ( sigismember(set, i) > 0 )
    {
      v2 = caml_alloc_small(2LL, 0);
      *v2 = 2LL * (int)caml_rev_convert_signal_number(i) + 1;
      v2[1] = v5;
      v5 = (__int64)v2;
    }
  }
  caml_local_roots = v4[0];
  return v5;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000428A08) ----------------------------------------------------
__int64 unix_sigpending()
{
  sigset_t v1; // [rsp+0h] [rbp-88h] BYREF

  if ( sigpending(&v1) == -1 )
    uerror("sigpending", 0LL);
  return encode_sigset(&v1);
}
// 428A08: using guessed type __int64 __fastcall unix_sigpending();

//----- (0000000000428A3D) ----------------------------------------------------
__int64 __fastcall unix_sigprocmask(__int64 a1, __int64 *a2)
{
  int v2; // ebp
  int v3; // ebx
  sigset_t v5; // [rsp+0h] [rbp-118h] BYREF
  sigset_t set; // [rsp+80h] [rbp-98h] BYREF

  v2 = sigprocmask_cmd[(int)(a1 >> 1)];
  decode_sigset(a2, &set);
  caml_enter_blocking_section();
  v3 = sigprocmask(v2, &set, &v5);
  caml_leave_blocking_section();
  if ( v3 == -1 )
    uerror("sigprocmask", 0LL);
  return encode_sigset(&v5);
}
// 43D08C: using guessed type _DWORD sigprocmask_cmd[3];

//----- (0000000000428AAC) ----------------------------------------------------
__int64 __fastcall unix_sleep(__int64 a1)
{
  caml_enter_blocking_section();
  sleep(a1 >> 1);
  caml_leave_blocking_section();
  return 1LL;
}

//----- (0000000000428ACC) ----------------------------------------------------
__int64 __fastcall unix_socket(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // eax

  v3 = socket(socket_domain_table[(int)(a1 >> 1)], socket_type_table[(int)(a2 >> 1)], a3 >> 1);
  if ( v3 == -1 )
    uerror("socket", 0LL);
  return 2LL * v3 + 1;
}
// 658080: using guessed type _DWORD socket_domain_table[4];
// 658090: using guessed type _DWORD socket_type_table[4];

//----- (0000000000428B1C) ----------------------------------------------------
unsigned __int16 __fastcall get_sockaddr(__int64 *a1, __int64 a2, _DWORD *a3)
{
  unsigned __int16 result; // ax
  void *v5; // r13
  unsigned __int64 v6; // rax
  int v7; // er12
  __int64 v8; // rax
  __int64 v9; // rax

  result = *((unsigned __int8 *)a1 - 8);
  if ( (_BYTE)result )
  {
    if ( (_BYTE)result == 1 )
    {
      v8 = caml_string_length(*a1);
      *(_QWORD *)a2 = 0LL;
      *(_QWORD *)(a2 + 8) = 0LL;
      if ( v8 == 16 )
      {
        *(_QWORD *)(a2 + 16) = 0LL;
        *(_DWORD *)(a2 + 24) = 0;
        *(_WORD *)a2 = 10;
        v9 = *a1;
        *(_QWORD *)(a2 + 8) = *(_QWORD *)*a1;
        *(_QWORD *)(a2 + 16) = *(_QWORD *)(v9 + 8);
        result = __ROR2__(a1[1] >> 1, 8);
        *(_WORD *)(a2 + 2) = result;
        *a3 = 28;
      }
      else
      {
        *(_WORD *)a2 = 2;
        *(_DWORD *)(a2 + 4) = *(_DWORD *)*a1;
        result = __ROR2__(a1[1] >> 1, 8);
        *(_WORD *)(a2 + 2) = result;
        *a3 = 16;
      }
    }
  }
  else
  {
    v5 = (void *)*a1;
    v6 = caml_string_length(*a1);
    v7 = v6;
    *(_WORD *)a2 = 1;
    if ( v6 > 0x6B )
      unix_error(36, "", v5);
    result = (unsigned __int16)memmove((void *)(a2 + 2), v5, v6 + 1);
    *a3 = v7 + 2;
  }
  return result;
}

//----- (0000000000428C43) ----------------------------------------------------
_QWORD *__fastcall alloc_inet6_addr(_QWORD *a1)
{
  _QWORD *result; // rax

  result = caml_alloc_string(16LL);
  *result = *a1;
  result[1] = a1[1];
  return result;
}

//----- (0000000000428C61) ----------------------------------------------------
_DWORD *__fastcall alloc_inet_addr(_DWORD *a1)
{
  _DWORD *result; // rax

  result = caml_alloc_string(4LL);
  *result = *a1;
  return result;
}

//----- (0000000000428C75) ----------------------------------------------------
_QWORD *__fastcall alloc_sockaddr(__int16 *a1, __int64 a2, int a3)
{
  __int16 v3; // ax
  _QWORD *result; // rax
  __int64 v5; // [rsp+0h] [rbp-68h] BYREF
  __int64 v6; // [rsp+8h] [rbp-60h]
  __int64 v7; // [rsp+10h] [rbp-58h]
  __int64 *v8; // [rsp+18h] [rbp-50h]
  __int64 v9[4]; // [rsp+48h] [rbp-20h] BYREF

  v3 = *a1;
  if ( *a1 == 2 )
  {
    v9[0] = (__int64)alloc_inet_addr((_DWORD *)a1 + 1);
    v5 = caml_local_roots;
    caml_local_roots = (__int64)&v5;
    v7 = 1LL;
    v6 = 1LL;
    v8 = v9;
    result = caml_alloc_small(2LL, 1u);
    *result = v9[0];
    result[1] = 2LL * (unsigned __int16)__ROR2__(a1[1], 8) + 1;
    caml_local_roots = v5;
  }
  else if ( v3 == 10 )
  {
    v9[0] = (__int64)alloc_inet6_addr((_QWORD *)a1 + 1);
    v5 = caml_local_roots;
    caml_local_roots = (__int64)&v5;
    v7 = 1LL;
    v6 = 1LL;
    v8 = v9;
    result = caml_alloc_small(2LL, 1u);
    *result = v9[0];
    result[1] = 2LL * (unsigned __int16)__ROR2__(a1[1], 8) + 1;
    caml_local_roots = v5;
  }
  else
  {
    if ( v3 != 1 )
    {
      if ( a3 != -1 )
        close(a3);
      unix_error(97, "", 0LL);
    }
    v9[0] = (__int64)caml_copy_string(a1 + 1);
    v5 = caml_local_roots;
    caml_local_roots = (__int64)&v5;
    v7 = 1LL;
    v6 = 1LL;
    v8 = v9;
    result = caml_alloc_small(1LL, 0);
    *result = v9[0];
    caml_local_roots = v5;
  }
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000428E0C) ----------------------------------------------------
_QWORD *__fastcall unix_socketpair(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *result; // rax
  int v4[6]; // [rsp+0h] [rbp-18h] BYREF

  if ( socketpair(socket_domain_table[(int)(a1 >> 1)], socket_type_table[(int)(a2 >> 1)], a3 >> 1, v4) == -1 )
    uerror("socketpair", 0LL);
  result = caml_alloc_small(2LL, 0);
  *result = 2LL * v4[0] + 1;
  result[1] = 2LL * v4[1] + 1;
  return result;
}
// 658080: using guessed type _DWORD socket_domain_table[4];
// 658090: using guessed type _DWORD socket_type_table[4];

//----- (0000000000428E80) ----------------------------------------------------
__int64 __fastcall unix_setsockopt_aux(void *a1, unsigned int a2, int a3, int a4, __int64 a5, double *a6)
{
  double v8; // xmm0_8
  socklen_t v9; // er8
  __int64 v11[3]; // [rsp+0h] [rbp-18h] BYREF

  if ( a2 == 2 )
  {
    LODWORD(v11[0]) = ((unsigned __int8)a6 ^ 1) & 1;
    v9 = 8;
    if ( (((unsigned __int8)a6 ^ 1) & 1) != 0 )
      HIDWORD(v11[0]) = *(__int64 *)a6 >> 1;
  }
  else if ( a2 < 2 )
  {
    LODWORD(v11[0]) = (__int64)a6 >> 1;
    v9 = 4;
  }
  else
  {
    if ( a2 != 3 )
      unix_error(22, a1, 0LL);
    v8 = *a6;
    v11[0] = (int)*a6;
    v11[1] = (int)((v8 - (double)SLODWORD(v11[0])) * 1000000.0);
    v9 = 16;
  }
  if ( setsockopt(a5 >> 1, a3, a4, v11, v9) == -1 )
    uerror(a1, 0LL);
  return 1LL;
}

//----- (0000000000428F45) ----------------------------------------------------
__int64 __fastcall unix_setsockopt(__int64 a1, __int64 a2, __int64 a3, double *a4)
{
  __int64 v4; // rax
  int *v5; // rdx

  v4 = (unsigned int)(a1 >> 1);
  v5 = (int *)((char *)*(&sockopt_table + v4) + 8 * (int)(a3 >> 1));
  return unix_setsockopt_aux(setsockopt_fun_name[v4], a1 >> 1, *v5, v5[1], a2, a4);
}
// 645080: using guessed type void *sockopt_table;
// 6450C0: using guessed type char *setsockopt_fun_name[5];

//----- (0000000000428F86) ----------------------------------------------------
__int64 __fastcall unix_getsockopt_aux(void *a1, int a2, int a3, int a4, __int64 a5)
{
  __int64 result; // rax
  __int64 v6[8]; // [rsp+0h] [rbp-78h] BYREF
  int optval[4]; // [rsp+40h] [rbp-38h] BYREF
  _QWORD *v8; // [rsp+50h] [rbp-28h] BYREF
  int optlen[7]; // [rsp+5Ch] [rbp-1Ch] BYREF

  switch ( a2 )
  {
    case 0:
    case 1:
    case 4:
      optlen[0] = 4;
      break;
    case 2:
      optlen[0] = 8;
      break;
    case 3:
      optlen[0] = 16;
      break;
    default:
      unix_error(22, a1, 0LL);
  }
  if ( getsockopt(a5 >> 1, a3, a4, optval, (socklen_t *)optlen) == -1 )
    uerror(a1, 0LL);
  switch ( a2 )
  {
    case 0:
    case 1:
      return 2LL * optval[0] + 1;
    case 2:
      if ( !optval[0] )
        goto LABEL_16;
      result = (__int64)caml_alloc_small(1LL, 0);
      *(_QWORD *)result = 2LL * optval[1] + 1;
      break;
    case 3:
      return caml_copy_double((double)optval[2] / 1000000.0 + (double)optval[0]);
    case 4:
      if ( optval[0] )
      {
        v8 = unix_error_of_code(optval[0]);
        v6[0] = caml_local_roots;
        caml_local_roots = (__int64)v6;
        v6[2] = 1LL;
        v6[1] = 1LL;
        v6[3] = (__int64)&v8;
        result = (__int64)caml_alloc_small(1LL, 0);
        *(_QWORD *)result = v8;
        caml_local_roots = v6[0];
      }
      else
      {
LABEL_16:
        result = 1LL;
      }
      break;
    default:
      unix_error(22, a1, 0LL);
  }
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 428F86: using guessed type socklen_t optlen[7];

//----- (00000000004290F9) ----------------------------------------------------
__int64 __fastcall unix_getsockopt(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  int *v4; // rdx

  v3 = (unsigned int)(a1 >> 1);
  v4 = (int *)((char *)*(&sockopt_table + v3) + 8 * (int)(a3 >> 1));
  return unix_getsockopt_aux((&getsockopt_fun_name)[v3], a1 >> 1, *v4, v4[1], a2);
}
// 645080: using guessed type void *sockopt_table;
// 645100: using guessed type char *getsockopt_fun_name;

//----- (0000000000429138) ----------------------------------------------------
_QWORD *__fastcall stat_aux(int a1, __int64 a2)
{
  __int64 v2; // rbp
  _QWORD *v3; // rax
  __int64 *v4; // r12
  __int64 v6[9]; // [rsp+0h] [rbp-88h] BYREF
  _QWORD *v7; // [rsp+48h] [rbp-40h] BYREF
  _QWORD *v8; // [rsp+50h] [rbp-38h] BYREF
  __int64 v9; // [rsp+58h] [rbp-30h] BYREF
  __int64 v10; // [rsp+60h] [rbp-28h] BYREF
  __int64 v11; // [rsp+68h] [rbp-20h] BYREF

  v2 = caml_local_roots;
  v11 = 0LL;
  v10 = 0LL;
  v9 = 0LL;
  v8 = 0LL;
  v7 = 0LL;
  v6[0] = caml_local_roots;
  caml_local_roots = (__int64)v6;
  v6[2] = 1LL;
  v6[1] = 5LL;
  v6[3] = (__int64)&v11;
  v6[4] = (__int64)&v10;
  v6[5] = (__int64)&v9;
  v6[6] = (__int64)&v8;
  v6[7] = (__int64)&v7;
  v11 = caml_copy_double((double)(int)*(_QWORD *)(a2 + 72));
  v10 = caml_copy_double((double)(int)*(_QWORD *)(a2 + 88));
  v9 = caml_copy_double((double)(int)*(_QWORD *)(a2 + 104));
  if ( a1 )
    v3 = caml_copy_int64(*(_QWORD *)(a2 + 48));
  else
    v3 = (_QWORD *)(2LL * *(_QWORD *)(a2 + 48) + 1);
  v8 = v3;
  v7 = caml_alloc_small(12LL, 0);
  *v7 = 2LL * *(_QWORD *)a2 + 1;
  v7[1] = 2LL * *(_QWORD *)(a2 + 8) + 1;
  v4 = v7 + 2;
  *v4 = cst_to_constr(*(_DWORD *)(a2 + 24) & 0xF000, file_kind_table, 7, 0);
  v7[3] = 2LL * (*(_DWORD *)(a2 + 24) & 0xFFF) + 1;
  v7[4] = 2LL * *(_QWORD *)(a2 + 16) + 1;
  v7[5] = 2LL * *(unsigned int *)(a2 + 28) + 1;
  v7[6] = 2LL * *(unsigned int *)(a2 + 32) + 1;
  v7[7] = 2LL * *(_QWORD *)(a2 + 40) + 1;
  v7[8] = v8;
  v7[9] = v11;
  v7[10] = v10;
  v7[11] = v9;
  caml_local_roots = v2;
  return v7;
}
// 658160: using guessed type _DWORD file_kind_table[8];
// 658A68: using guessed type __int64 caml_local_roots;

//----- (000000000042931F) ----------------------------------------------------
_QWORD *__fastcall unix_fstat_64(__int64 a1)
{
  struct stat64 v2; // [rsp+0h] [rbp-98h] BYREF

  if ( __fxstat64(1, a1 >> 1, &v2) == -1 )
    uerror("fstat", 0LL);
  return stat_aux(1, (__int64)&v2);
}

//----- (0000000000429364) ----------------------------------------------------
_QWORD *__fastcall unix_lstat_64(char *filename)
{
  struct stat64 v2; // [rsp+0h] [rbp-98h] BYREF

  if ( __lxstat64(1, filename, &v2) == -1 )
    uerror("lstat", filename);
  return stat_aux(1, (__int64)&v2);
}

//----- (00000000004293A9) ----------------------------------------------------
_QWORD *__fastcall unix_stat_64(char *filename)
{
  struct stat64 v2; // [rsp+0h] [rbp-98h] BYREF

  if ( __xstat64(1, filename, &v2) == -1 )
    uerror("stat", filename);
  return stat_aux(1, (__int64)&v2);
}

//----- (00000000004293EE) ----------------------------------------------------
_QWORD *__fastcall unix_fstat(__int64 a1)
{
  struct stat64 v2; // [rsp+0h] [rbp-98h] BYREF

  if ( __fxstat64(1, a1 >> 1, &v2) == -1 )
    uerror("fstat", 0LL);
  if ( v2.st_size > 0x3FFFFFFFFFFFFFFFLL && (v2.st_mode & 0xF000) == 0x8000 )
    unix_error(75, "fstat", 0LL);
  return stat_aux(0, (__int64)&v2);
}

//----- (000000000042946A) ----------------------------------------------------
_QWORD *__fastcall unix_lstat(char *filename)
{
  struct stat64 v2; // [rsp+0h] [rbp-98h] BYREF

  if ( __lxstat64(1, filename, &v2) == -1 )
    uerror("lstat", filename);
  if ( v2.st_size > 0x3FFFFFFFFFFFFFFFLL && (v2.st_mode & 0xF000) == 0x8000 )
    unix_error(75, "lstat", filename);
  return stat_aux(0, (__int64)&v2);
}

//----- (00000000004294E4) ----------------------------------------------------
_QWORD *__fastcall unix_stat(char *filename)
{
  struct stat64 v2; // [rsp+0h] [rbp-98h] BYREF

  if ( __xstat64(1, filename, &v2) == -1 )
    uerror("stat", filename);
  if ( v2.st_size > 0x3FFFFFFFFFFFFFFFLL && (v2.st_mode & 0xF000) == 0x8000 )
    unix_error(75, "stat", filename);
  return stat_aux(0, (__int64)&v2);
}

//----- (0000000000429560) ----------------------------------------------------
_QWORD *__fastcall unix_string_of_inet_addr(void *cp)
{
  char *v1; // rax
  char v3[72]; // [rsp+0h] [rbp-58h] BYREF
  unsigned __int64 v4; // [rsp+48h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  if ( caml_string_length((__int64)cp) == 16 )
    v1 = (char *)inet_ntop(10, cp, v3, 0x40u);
  else
    v1 = (char *)inet_ntop(2, cp, v3, 0x40u);
  if ( !v1 )
    uerror("string_of_inet_addr", 0LL);
  return caml_copy_string(v1);
}

//----- (00000000004295E8) ----------------------------------------------------
__int64 __fastcall unix_symlink(const char *a1, void *a2)
{
  if ( symlink(a1, (const char *)a2) == -1 )
    uerror("symlink", a2);
  return 1LL;
}

//----- (0000000000429610) ----------------------------------------------------
__int64 __fastcall unix_tcflow(__int64 a1, __int64 a2)
{
  if ( tcflow(a1 >> 1, action_flag_table[(int)(a2 >> 1)]) == -1 )
    uerror("tcflow", 0LL);
  return 1LL;
}
// 43D1E0: using guessed type _DWORD action_flag_table[4];

//----- (000000000042964C) ----------------------------------------------------
__int64 __fastcall unix_tcflush(__int64 a1, __int64 a2)
{
  if ( tcflush(a1 >> 1, queue_flag_table[(int)(a2 >> 1)]) == -1 )
    uerror("tcflush", 0LL);
  return 1LL;
}
// 43D1F0: using guessed type _DWORD queue_flag_table[3];

//----- (0000000000429688) ----------------------------------------------------
__int64 __fastcall unix_tcdrain(__int64 a1)
{
  if ( tcdrain(a1 >> 1) == -1 )
    uerror("tcdrain", 0LL);
  return 1LL;
}

//----- (00000000004296B4) ----------------------------------------------------
__int64 __fastcall unix_tcsendbreak(__int64 a1, __int64 a2)
{
  if ( tcsendbreak(a1 >> 1, a2 >> 1) == -1 )
    uerror("tcsendbreak", 0LL);
  return 1LL;
}

//----- (00000000004296E3) ----------------------------------------------------
__int64 __fastcall unix_tcsetattr(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 v4; // rax
  __int64 *v5; // rbx
  _DWORD *v6; // rax
  int v7; // ecx
  int v8; // esi
  int v9; // ecx
  _DWORD *v10; // rsi
  unsigned __int64 v11; // rcx
  _DWORD *v12; // rax
  int v13; // edx
  int v14; // eax
  int v15; // eax
  int fd; // [rsp+4h] [rbp-44h]

  fd = a1 >> 1;
  if ( tcgetattr(fd, &terminal_status) == -1 )
    uerror("tcsetattr", 0LL);
  v4 = terminal_io_descr;
  if ( terminal_io_descr != 4 )
  {
    v5 = &terminal_io_descr;
    while ( 1 )
    {
      ++v5;
      if ( v4 == 1 )
      {
        v8 = *((_DWORD *)v5 + 4);
        v9 = (*a3 >> 1) - *((_DWORD *)v5 + 2);
        if ( v9 < 0 || v8 <= v9 )
          unix_error(22, "tcsetattr", 0LL);
        *(_DWORD *)*v5 = LODWORD(v5[v9 + 4]) | *(_DWORD *)*v5 & ~(unsigned int)v5[3];
        v5 += v8 + 4;
      }
      else if ( v4 > 1 )
      {
        if ( v4 == 2 )
        {
          v10 = (_DWORD *)*v5;
          v11 = (unsigned __int64)*a3 >> 1;
          v12 = &unk_43D22C;
          v13 = 1;
          if ( (_DWORD)v11 == 50 )
          {
            v13 = 0;
          }
          else
          {
            while ( (_DWORD)v11 != *v12 )
            {
              ++v13;
              v12 += 2;
              if ( v13 == 18 )
                unix_error(22, "tcsetattr", 0LL);
            }
          }
          if ( (_DWORD)v10 )
          {
            v14 = 0;
            if ( (_DWORD)v10 == 1 )
              v14 = cfsetospeed(&terminal_status, *((_DWORD *)&speedtable + 2 * v13));
          }
          else
          {
            v14 = cfsetispeed(&terminal_status, *((_DWORD *)&speedtable + 2 * v13));
          }
          if ( v14 == -1 )
            uerror("tcsetattr", 0LL);
          ++v5;
        }
        else if ( v4 == 3 )
        {
          v15 = *(_DWORD *)v5++;
          terminal_status.c_cc[v15] = *a3 >> 1;
        }
      }
      else if ( !v4 )
      {
        v6 = (_DWORD *)*v5;
        v7 = *((_DWORD *)v5 + 2);
        v5 += 2;
        if ( (unsigned int)((unsigned __int64)*a3 >> 1) )
          *v6 |= v7;
        else
          *v6 &= ~v7;
      }
      v4 = *v5;
      if ( *v5 == 4 )
        break;
      ++a3;
    }
  }
  if ( tcsetattr(fd, when_flag_table[(int)(a2 >> 1)], &terminal_status) == -1 )
    uerror("tcsetattr", 0LL);
  return 1LL;
}
// 43D1FC: using guessed type _DWORD when_flag_table[9];
// 658180: using guessed type __int64 terminal_io_descr;

//----- (000000000042990D) ----------------------------------------------------
char *__fastcall unix_tcgetattr(__int64 a1)
{
  char *v1; // r15
  __int64 v2; // rax
  char *v3; // rbp
  __int64 *i; // rdx
  __int64 *v5; // rbx
  _DWORD *v6; // rax
  __int64 v7; // r8
  int v8; // esi
  _QWORD *v9; // rbx
  __int64 v10; // rdi
  int v11; // eax
  __int64 v12; // rcx
  int v13; // edx
  speed_t v14; // eax
  _DWORD *v15; // rcx
  int v16; // edx
  int v17; // eax

  if ( tcgetattr(a1 >> 1, &terminal_status) == -1 )
    uerror("tcgetattr", 0LL);
  v1 = caml_alloc_tuple(0x26uLL);
  v2 = terminal_io_descr;
  if ( terminal_io_descr != 4 )
  {
    v3 = v1;
    for ( i = &terminal_io_descr; ; i = v5 )
    {
      v5 = i + 1;
      if ( v2 == 1 )
      {
        v6 = (_DWORD *)*v5;
        v7 = i[2];
        v8 = *((_DWORD *)i + 6);
        v9 = i + 5;
        if ( v8 > 0 )
        {
          v10 = (int)(*v6 & i[4]);
          v11 = 0;
          if ( v10 == *v9 )
          {
LABEL_17:
            *(_QWORD *)v3 = 2LL * ((int)v7 + v11) + 1;
          }
          else
          {
            while ( v8 > ++v11 )
            {
              v12 = i[6];
              ++i;
              if ( v12 == v10 )
                goto LABEL_17;
            }
          }
        }
        v5 = &v9[v8];
      }
      else if ( v2 > 1 )
      {
        if ( v2 == 2 )
        {
          v13 = *(_DWORD *)v5++;
          *(_QWORD *)v3 = 19201LL;
          if ( v13 )
          {
            v14 = 0;
            if ( v13 == 1 )
              v14 = cfgetospeed(&terminal_status);
          }
          else
          {
            v14 = cfgetispeed(&terminal_status);
          }
          v15 = &unk_43D228;
          v16 = 1;
          if ( speedtable == v14 )
          {
            v16 = 0;
          }
          else
          {
            while ( *v15 != v14 )
            {
              ++v16;
              v15 += 2;
              if ( v16 == 18 )
                goto LABEL_29;
            }
          }
          *(_QWORD *)v3 = 2LL * *((int *)&speedtable + 2 * v16 + 1) + 1;
        }
        else if ( v2 == 3 )
        {
          v17 = *(_DWORD *)v5;
          v5 = i + 2;
          *(_QWORD *)v3 = 2LL * terminal_status.c_cc[v17] + 1;
        }
      }
      else if ( !v2 )
      {
        v5 = i + 3;
        *(_QWORD *)v3 = (-(__int64)((*(_DWORD *)i[1] & (unsigned int)i[2]) == 0) & 0xFFFFFFFFFFFFFFFELL) + 3;
      }
LABEL_29:
      v2 = *v5;
      if ( *v5 == 4 )
        break;
      v3 += 8;
    }
  }
  return v1;
}
// 658180: using guessed type __int64 terminal_io_descr;

//----- (0000000000429ADC) ----------------------------------------------------
__int64 unix_time()
{
  double v0; // xmm0_8

  v0 = (double)(int)time(0LL);
  return caml_copy_double(v0);
}
// 429ADC: using guessed type __int64 __fastcall unix_time();

//----- (0000000000429AFC) ----------------------------------------------------
double *unix_times()
{
  double *v0; // rbx
  struct rusage v2; // [rsp+0h] [rbp-A8h] BYREF

  v0 = (double *)caml_alloc_small(4LL, 0xFEu);
  getrusage(RUSAGE_SELF, &v2);
  *v0 = (double)SLODWORD(v2.ru_utime.tv_usec) / 1000000.0 + (double)SLODWORD(v2.ru_utime.tv_sec);
  v0[1] = (double)SLODWORD(v2.ru_stime.tv_usec) / 1000000.0 + (double)SLODWORD(v2.ru_stime.tv_sec);
  getrusage(RUSAGE_CHILDREN, &v2);
  v0[2] = (double)SLODWORD(v2.ru_utime.tv_usec) / 1000000.0 + (double)SLODWORD(v2.ru_utime.tv_sec);
  v0[3] = (double)SLODWORD(v2.ru_stime.tv_usec) / 1000000.0 + (double)SLODWORD(v2.ru_stime.tv_sec);
  return v0;
}

//----- (0000000000429BB8) ----------------------------------------------------
__int64 __fastcall unix_truncate_64(void *a1, __int64 a2)
{
  if ( truncate64((const char *)a1, *(_QWORD *)(a2 + 8)) == -1 )
    uerror("truncate", a1);
  return 1LL;
}

//----- (0000000000429BE0) ----------------------------------------------------
__int64 __fastcall unix_truncate(void *a1, __int64 a2)
{
  if ( truncate64((const char *)a1, a2 >> 1) == -1 )
    uerror("truncate", a1);
  return 1LL;
}

//----- (0000000000429C08) ----------------------------------------------------
__int64 __fastcall unix_umask(__int64 a1)
{
  return 2LL * umask(a1 >> 1) + 1;
}

//----- (0000000000429C20) ----------------------------------------------------
_QWORD *__fastcall unix_error_of_code(int a1)
{
  _QWORD *result; // rax

  result = (_QWORD *)(int)cst_to_constr(a1, error_table, 68, -1);
  if ( (_DWORD)result == -1 )
  {
    result = caml_alloc_small(1LL, 0);
    *result = 2LL * a1 + 1;
  }
  return result;
}
// 658520: using guessed type _DWORD error_table[68];

//----- (0000000000429C5E) ----------------------------------------------------
void __fastcall __noreturn unix_error(int a1, void *a2, void *a3)
{
  _QWORD *v3; // rax
  __int64 v4[9]; // [rsp+0h] [rbp-78h] BYREF
  __int64 v5; // [rsp+48h] [rbp-30h] BYREF
  __int64 v6; // [rsp+50h] [rbp-28h] BYREF
  __int64 v7; // [rsp+58h] [rbp-20h] BYREF

  v7 = 1LL;
  v6 = 1LL;
  v5 = 1LL;
  v4[0] = caml_local_roots;
  caml_local_roots = (__int64)v4;
  v4[2] = 1LL;
  v4[1] = 3LL;
  v4[3] = (__int64)&v7;
  v4[4] = (__int64)&v6;
  v4[5] = (__int64)&v5;
  if ( !a3 )
    a3 = caml_copy_string("");
  v5 = (__int64)a3;
  v7 = (__int64)caml_copy_string(a2);
  v6 = (__int64)unix_error_of_code(a1);
  if ( !unix_error_exn )
  {
    unix_error_exn = caml_named_value("Unix.Unix_error");
    if ( !unix_error_exn )
      caml_invalid_argument("Exception Unix.Unix_error not initialized, please link unix.cma");
  }
  v3 = caml_alloc_small(4LL, 0);
  *v3 = *(_QWORD *)unix_error_exn;
  v3[1] = v6;
  v3[2] = v7;
  v3[3] = v5;
  caml_local_roots = v4[0];
  caml_raise((__int64)v3);
}
// 658900: using guessed type __int64 unix_error_exn;
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000429D72) ----------------------------------------------------
void __fastcall __noreturn uerror(void *a1, void *a2)
{
  int *v2; // rax

  v2 = __errno_location();
  unix_error(*v2, a1, a2);
}

//----- (0000000000429D98) ----------------------------------------------------
__int64 __fastcall unix_unlink(void *a1)
{
  if ( unlink((const char *)a1) == -1 )
    uerror("unlink", a1);
  return 1LL;
}

//----- (0000000000429DBC) ----------------------------------------------------
__int64 __fastcall unix_utimes(char *file, double *a2, double *a3)
{
  __int64 v3; // rdx
  const struct utimbuf *v4; // rsi
  __int64 v6[3]; // [rsp+0h] [rbp-18h] BYREF

  v6[0] = (unsigned int)(int)*a2;
  v3 = (unsigned int)(int)*a3;
  if ( v6[0] || (v4 = 0LL, v3) )
    v4 = (const struct utimbuf *)v6;
  v6[1] = v3;
  if ( utime(file, v4) == -1 )
    uerror("utimes", file);
  return 1LL;
}

//----- (0000000000429E10) ----------------------------------------------------
_QWORD *__fastcall alloc_process_status(int a1, __int16 a2)
{
  _QWORD *result; // rax
  __int64 v3[9]; // [rsp+0h] [rbp-68h] BYREF
  _QWORD *v4; // [rsp+48h] [rbp-20h] BYREF

  if ( (a2 & 0x7F) != 0 )
  {
    if ( (_BYTE)a2 == 127 )
    {
      v4 = caml_alloc_small(1LL, 2u);
      *v4 = 2LL * (int)caml_rev_convert_signal_number(HIBYTE(a2)) + 1;
    }
    else
    {
      v4 = caml_alloc_small(1LL, 1u);
      *v4 = 2LL * (int)caml_rev_convert_signal_number(a2 & 0x7F) + 1;
    }
  }
  else
  {
    v4 = caml_alloc_small(1LL, 0);
    *v4 = 2LL * HIBYTE(a2) + 1;
  }
  v3[0] = caml_local_roots;
  caml_local_roots = (__int64)v3;
  v3[2] = 1LL;
  v3[1] = 1LL;
  v3[3] = (__int64)&v4;
  result = caml_alloc_small(2LL, 0);
  *result = 2LL * a1 + 1;
  result[1] = v4;
  caml_local_roots = v3[0];
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000429F17) ----------------------------------------------------
_QWORD *__fastcall unix_waitpid(__int64 *a1, __int64 a2)
{
  int v2; // ebp
  int v3; // ebx
  int stat_loc[7]; // [rsp+Ch] [rbp-1Ch] BYREF

  v2 = caml_convert_flag_list(a1, (__int64)&wait_flag_table);
  caml_enter_blocking_section();
  v3 = waitpid(a2 >> 1, stat_loc, v2);
  caml_leave_blocking_section();
  if ( v3 == -1 )
    uerror("waitpid", 0LL);
  return alloc_process_status(v3, stat_loc[0]);
}
// 429F17: using guessed type int stat_loc[7];

//----- (0000000000429F73) ----------------------------------------------------
_QWORD *unix_wait()
{
  int v0; // ebx
  __WAIT_STATUS stat_loc; // [rsp+Ch] [rbp-Ch] BYREF

  caml_enter_blocking_section();
  v0 = wait((__WAIT_STATUS)&stat_loc);
  caml_leave_blocking_section();
  if ( v0 == -1 )
    uerror("wait", 0LL);
  return alloc_process_status(v0, (__int16)stat_loc.__uptr);
}

//----- (0000000000429FC0) ----------------------------------------------------
__int64 __fastcall unix_single_write(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rcx
  int v5; // ebx
  int v6; // ebx
  __int64 v8; // [rsp+8h] [rbp-4070h] BYREF
  __int64 v9[8]; // [rsp+10h] [rbp-4068h] BYREF
  char buf[16392]; // [rsp+50h] [rbp-4028h] BYREF
  unsigned __int64 v11; // [rsp+4058h] [rbp-20h]

  v8 = a2;
  v11 = __readfsqword(0x28u);
  v9[0] = caml_local_roots;
  caml_local_roots = (__int64)v9;
  v9[2] = 1LL;
  v9[1] = 1LL;
  v9[3] = (__int64)&v8;
  v4 = a4 >> 1;
  if ( v4 <= 0 )
  {
    v6 = 0;
  }
  else
  {
    v5 = 0x4000;
    if ( v4 <= 0x4000 )
      v5 = v4;
    __memmove_chk(buf, v8 + (a3 >> 1), v5, 0x4000LL);
    caml_enter_blocking_section();
    v6 = write(a1 >> 1, buf, v5);
    caml_leave_blocking_section();
    if ( v6 == -1 )
      uerror("single_write", 0LL);
  }
  caml_local_roots = v9[0];
  return 2LL * v6 + 1;
}
// 40AC28: using guessed type __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 658A68: using guessed type __int64 caml_local_roots;

//----- (000000000042A0C7) ----------------------------------------------------
__int64 __fastcall unix_write(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v5; // r12
  __int64 v6; // r13
  int v7; // ebp
  int v8; // ebp
  __int64 v10; // [rsp+18h] [rbp-4090h] BYREF
  __int64 v11[8]; // [rsp+20h] [rbp-4088h] BYREF
  char buf[16392]; // [rsp+60h] [rbp-4048h] BYREF
  unsigned __int64 v13; // [rsp+4068h] [rbp-40h]

  v10 = a2;
  v13 = __readfsqword(0x28u);
  v11[0] = caml_local_roots;
  caml_local_roots = (__int64)v11;
  v11[2] = 1LL;
  v11[1] = 1LL;
  v11[3] = (__int64)&v10;
  v4 = a4 >> 1;
  if ( a4 >> 1 <= 0 )
  {
    v6 = 0LL;
  }
  else
  {
    v5 = a3 >> 1;
    v6 = 0LL;
    while ( 1 )
    {
      v7 = 0x4000;
      if ( v4 <= 0x4000 )
        v7 = v4;
      __memmove_chk(buf, v10 + v5, v7, 0x4000LL);
      caml_enter_blocking_section();
      v8 = write(a1 >> 1, buf, v7);
      caml_leave_blocking_section();
      if ( v8 == -1 )
        break;
      v6 += v8;
      v4 -= v8;
      if ( v4 <= 0 )
        goto LABEL_12;
      v5 += v8;
    }
    if ( *__errno_location() != 11 || v6 <= 0 )
      uerror("write", 0LL);
  }
LABEL_12:
  caml_local_roots = v11[0];
  return 2 * v6 + 1;
}
// 40AC28: using guessed type __int64 __fastcall __memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 658A68: using guessed type __int64 caml_local_roots;

//----- (000000000042A20C) ----------------------------------------------------
__int64 __fastcall cst_to_constr(int a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *v4; // r8
  int v5; // eax
  int v6; // esi

  if ( a3 > 0 )
  {
    v4 = a2;
    v5 = 0;
    if ( *a2 == a1 )
      return 2LL * v5 + 1;
    while ( a3 > ++v5 )
    {
      v6 = v4[1];
      ++v4;
      if ( v6 == a1 )
        return 2LL * v5 + 1;
    }
  }
  return 2LL * a4 + 1;
}

//----- (000000000042A244) ----------------------------------------------------
_QWORD *__fastcall cstringvect(__int64 a1)
{
  unsigned __int64 v1; // rbp
  _QWORD *result; // rax
  unsigned __int64 i; // rdx

  v1 = *(_QWORD *)(a1 - 8) >> 10;
  result = caml_stat_alloc(8 * v1 + 8);
  if ( v1 )
  {
    for ( i = 0LL; i < v1; ++i )
      result[i] = *(_QWORD *)(a1 + 8 * i);
  }
  result[v1] = 0LL;
  return result;
}

//----- (000000000042A2A0) ----------------------------------------------------
__int64 __fastcall scanmult(__int64 a1, __int64 *a2)
{
  __int64 result; // rax
  int v3; // [rsp+8h] [rbp-30h] BYREF
  char v4; // [rsp+Fh] [rbp-29h] BYREF

  v4 = 32;
  __isoc99_sscanf(a1, "=%u%c", &v3, &v4);
  __isoc99_sscanf(a1, "=0x%x%c", &v3, &v4);
  switch ( v4 )
  {
    case 'M':
      result = (__int64)v3 << 20;
      *a2 = result;
      break;
    case 'k':
      result = (__int64)v3 << 10;
      *a2 = result;
      break;
    case 'G':
      result = (__int64)v3 << 30;
      *a2 = result;
      break;
    default:
      result = v3;
      *a2 = v3;
      break;
  }
  return result;
}
// 40A468: using guessed type __int64 __isoc99_sscanf(_QWORD, const char *, ...);

//----- (000000000042A360) ----------------------------------------------------
__int64 __fastcall caml_main(const char **a1, double a2)
{
  char *v3; // rbp
  unsigned __int8 v4; // al
  int v5; // edx
  unsigned int v6; // eax
  __int64 v7; // rcx
  __int64 v8; // rdi
  void *v9; // rsi
  int v10; // ebp
  __int64 (__fastcall *v11)(); // rax
  __int64 (__fastcall *v12)(); // rdx
  char (*v13)[12]; // rsi
  char (*v14)[12]; // r8
  __int64 (__fastcall *v15)(); // rbp
  int i; // ecx
  unsigned __int64 v17; // rdx
  char *v18; // rbp
  char *v19; // rdi
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 result; // rax

  caml_init_ieee_floats(a2);
  caml_init_custom_operations();
  v3 = getenv("OCAMLRUNPARAM");
  if ( v3 || (v3 = getenv("CAMLRUNPARAM")) != 0LL )
  {
    while ( *v3 )
    {
      v4 = *v3++ - 79;
      if ( v4 <= 0x27u )
        __asm { jmp     qword ptr [r12+rax*8] }
    }
  }
  caml_init_gc(minor_heap_init, heap_size_init, heap_chunk_init, percent_free_init, max_percent_free_init);
  v5 = 256;
  v6 = 0;
  do
  {
    v7 = (int)v6;
    v8 = v6++;
    --v5;
    caml_atom_table[v7] = v8;
  }
  while ( v5 );
  if ( (unsigned int)caml_page_table_add(4, (__int64)caml_atom_table, (__int64)&caml_frame_descriptors_mask) )
    goto LABEL_32;
  v9 = caml_data_segments;
  v10 = 0;
  if ( caml_data_segments )
  {
    while ( !(unsigned int)caml_page_table_add(4, (__int64)v9, (__int64)*(&off_6480D8 + 2 * v10)) )
    {
      v9 = *(&caml_data_segments + 2 * ++v10);
      if ( !v9 )
        goto LABEL_11;
    }
LABEL_32:
    caml_fatal_error("Fatal error: not enough memory for the initial page table");
  }
LABEL_11:
  v11 = off_648218;
  v12 = caml_code_segments;
  v13 = off_648210;
  caml_code_area_start = (__int64)caml_code_segments;
  caml_code_area_end = (__int64)off_648210;
  if ( off_648218 )
  {
    v14 = off_648210;
    v15 = caml_code_segments;
    for ( i = 1; ; v11 = *(&caml_code_segments + 2 * i) )
    {
      if ( (unsigned __int64)v15 <= (unsigned __int64)v11 )
        v11 = v12;
      v17 = (unsigned __int64)*(&off_648210 + 2 * i);
      if ( v17 <= (unsigned __int64)v14 )
        v17 = (unsigned __int64)v13;
      if ( !*(&caml_code_segments + 2 * ++i) )
        break;
      v13 = (char (*)[12])v17;
      v15 = v11;
      v12 = v11;
      v14 = v13;
    }
    caml_code_area_start = (__int64)v11;
    caml_code_area_end = v17;
  }
  caml_init_signals();
  v18 = (char *)*a1;
  if ( !*a1 )
    v18 = "";
  v19 = proc_self_exe_3682;
  if ( caml_executable_name(proc_self_exe_3682, 256) )
    v19 = caml_search_exe_in_path(v18);
  caml_sys_init(v19, (__int64)a1);
  if ( __sigsetjmp(&caml_termination_jmpbuf, 0) )
  {
    result = (__int64)caml_termination_hook;
    if ( caml_termination_hook )
      return caml_termination_hook(0LL);
  }
  else
  {
    result = caml_start_program((__int64)&caml_termination_jmpbuf, 0LL, v20, v21, v22, v23, a2);
    if ( (result & 3) == 2 )
      caml_fatal_uncaught_exception(result & 0xFFFFFFFFFFFFFFFCLL);
  }
  return result;
}
// 42A61C: variable 'v20' is possibly undefined
// 42A61C: variable 'v21' is possibly undefined
// 42A61C: variable 'v22' is possibly undefined
// 42A61C: variable 'v23' is possibly undefined
// 430CB0: using guessed type __int64 __fastcall caml_init_ieee_floats(double);
// 6480D0: using guessed type void *caml_data_segments;
// 6480D8: using guessed type void *off_6480D8;
// 648208: using guessed type __int64 (__fastcall *caml_code_segments)();
// 648210: using guessed type char (*off_648210)[12];
// 648218: using guessed type __int64 (__fastcall *off_648218)();
// 658638: using guessed type __int64 max_percent_free_init;
// 658640: using guessed type __int64 percent_free_init;
// 658648: using guessed type __int64 heap_chunk_init;
// 658650: using guessed type __int64 heap_size_init;
// 658658: using guessed type __int64 minor_heap_init;
// 658920: using guessed type __int64 (__fastcall *caml_termination_hook)(_QWORD);
// 662860: using guessed type __int64 caml_code_area_start;
// 662948: using guessed type __int64 caml_code_area_end;
// 662960: using guessed type _QWORD caml_atom_table[1];
// 663160: using guessed type int caml_frame_descriptors_mask;

//----- (000000000042A690) ----------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm0_8

  caml_main(argv, v3);
  caml_sys_exit(1LL);
}
// 42A697: variable 'v3' is possibly undefined

//----- (000000000042A6B0) ----------------------------------------------------
void __fastcall __noreturn caml_raise(__int64 a1)
{
  _QWORD *v1; // rax

  if ( caml_channel_mutex_unlock_exn )
    caml_channel_mutex_unlock_exn();
  if ( caml_exception_pointer )
  {
    v1 = (_QWORD *)caml_local_roots;
    if ( caml_local_roots && caml_exception_pointer > (unsigned __int64)caml_local_roots )
    {
      while ( 1 )
      {
        v1 = (_QWORD *)*v1;
        if ( !v1 )
          break;
        if ( caml_exception_pointer <= (unsigned __int64)v1 )
          goto LABEL_11;
      }
      caml_local_roots = 0LL;
    }
    v1 = (_QWORD *)caml_raise_exception(a1);
LABEL_11:
    caml_local_roots = (__int64)v1;
    caml_raise_exception(a1);
  }
  caml_fatal_uncaught_exception(a1);
}
// 658A40: using guessed type __int64 caml_exception_pointer;
// 658A68: using guessed type __int64 caml_local_roots;
// 65E600: using guessed type __int64 (*caml_channel_mutex_unlock_exn)(void);

//----- (000000000042A730) ----------------------------------------------------
void __noreturn caml_array_bound_error()
{
  if ( !array_bound_error_bucket_inited )
  {
    array_bound_error_msg = 3324LL;
    byte_65869F = 4;
    array_bound_error_bucket = 2048LL;
    qword_658A58 = (__int64)&caml_exn_Invalid_argument;
    qword_658A60 = (__int64)aIndexOutOfBoun;
    array_bound_error_bucket_inited = 1;
    caml_page_table_add(4, (__int64)&array_bound_error_msg, (__int64)&caml_last_return_address);
    array_bound_error_bucket_inited = 1;
  }
  caml_raise((__int64)&qword_658A58);
}
// 647AB0: using guessed type char *caml_exn_Invalid_argument;
// 658680: using guessed type __int64 array_bound_error_msg;
// 65869F: using guessed type char byte_65869F;
// 6586A8: using guessed type __int64 caml_last_return_address;
// 658A48: using guessed type int array_bound_error_bucket_inited;
// 658A50: using guessed type __int64 array_bound_error_bucket;
// 658A58: using guessed type __int64 qword_658A58;
// 658A60: using guessed type __int64 qword_658A60;

//----- (000000000042A7B0) ----------------------------------------------------
void __noreturn caml_raise_stack_overflow()
{
  caml_raise((__int64)&caml_bucket_Stack_overflow);
}
// 647C00: using guessed type char **caml_bucket_Stack_overflow;

//----- (000000000042A7C0) ----------------------------------------------------
void __noreturn caml_raise_out_of_memory()
{
  caml_raise((__int64)&caml_bucket_Out_of_memory);
}
// 647A38: using guessed type char **caml_bucket_Out_of_memory;

//----- (000000000042A7D0) ----------------------------------------------------
void __fastcall __noreturn caml_raise_with_args(__int64 a1, int a2, __int64 a3)
{
  _QWORD *v4; // rax
  unsigned __int64 v5; // rdx
  __int64 v6; // [rsp+8h] [rbp-A0h] BYREF
  __int64 v7[8]; // [rsp+10h] [rbp-98h] BYREF
  __int64 v8[11]; // [rsp+50h] [rbp-58h] BYREF

  v6 = a1;
  v7[3] = a3;
  v8[2] = 1LL;
  v8[1] = 1LL;
  v8[0] = caml_local_roots;
  v7[1] = 1LL;
  v8[3] = (__int64)&v6;
  v7[0] = (__int64)v8;
  caml_local_roots = (__int64)v7;
  v7[2] = a2;
  v4 = caml_alloc_small(a2 + 1, 0);
  *v4 = v6;
  if ( a2 > 0 )
  {
    v5 = 0LL;
    do
    {
      v4[v5 / 8 + 1] = *(_QWORD *)(a3 + v5);
      v5 += 8LL;
    }
    while ( v5 != 8LL * (unsigned int)(a2 - 1) + 8 );
  }
  caml_raise((__int64)v4);
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (000000000042A880) ----------------------------------------------------
void __fastcall __noreturn caml_raise_with_arg(__int64 a1, __int64 a2)
{
  __int64 v2; // [rsp+0h] [rbp-A8h] BYREF
  __int64 v3; // [rsp+8h] [rbp-A0h] BYREF
  __int64 v4[8]; // [rsp+10h] [rbp-98h] BYREF
  __int64 v5[9]; // [rsp+50h] [rbp-58h] BYREF
  _QWORD *v6; // [rsp+98h] [rbp-10h] BYREF

  v3 = a1;
  v2 = a2;
  v5[2] = 1LL;
  v5[1] = 2LL;
  v5[0] = caml_local_roots;
  v5[4] = (__int64)&v2;
  v6 = 0LL;
  v4[2] = 1LL;
  v5[3] = (__int64)&v3;
  v4[1] = 1LL;
  v4[0] = (__int64)v5;
  caml_local_roots = (__int64)v4;
  v4[3] = (__int64)&v6;
  v6 = caml_alloc_small(2LL, 0);
  *v6 = v3;
  v6[1] = v2;
  caml_raise((__int64)v6);
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (000000000042A940) ----------------------------------------------------
void __fastcall __noreturn caml_raise_sys_error(__int64 a1)
{
  caml_raise_with_arg((__int64)&caml_exn_Sys_error, a1);
}
// 647A48: using guessed type char *caml_exn_Sys_error;

//----- (000000000042A960) ----------------------------------------------------
void __fastcall __noreturn caml_raise_with_string(__int64 a1, void *a2)
{
  _QWORD *v2; // rax

  v2 = caml_copy_string(a2);
  caml_raise_with_arg(a1, (__int64)v2);
}

//----- (000000000042A980) ----------------------------------------------------
void __fastcall __noreturn caml_invalid_argument(void *a1)
{
  caml_raise_with_string((__int64)&caml_exn_Invalid_argument, a1);
}
// 647AB0: using guessed type char *caml_exn_Invalid_argument;

//----- (000000000042A9A0) ----------------------------------------------------
void __fastcall __noreturn caml_failwith(void *a1)
{
  caml_raise_with_string((__int64)&caml_exn_Failure, a1);
}
// 647A80: using guessed type char *caml_exn_Failure;

//----- (000000000042A9C0) ----------------------------------------------------
void __fastcall __noreturn caml_raise_constant(__int64 a1)
{
  __int64 v1; // [rsp+8h] [rbp-A0h] BYREF
  __int64 v2[8]; // [rsp+10h] [rbp-98h] BYREF
  __int64 v3[9]; // [rsp+50h] [rbp-58h] BYREF
  _QWORD *v4; // [rsp+98h] [rbp-10h] BYREF

  v1 = a1;
  v3[2] = 1LL;
  v3[1] = 1LL;
  v4 = 0LL;
  v3[0] = caml_local_roots;
  v2[2] = 1LL;
  v2[1] = 1LL;
  v3[3] = (__int64)&v1;
  v2[0] = (__int64)v3;
  caml_local_roots = (__int64)v2;
  v2[3] = (__int64)&v4;
  v4 = caml_alloc_small(1LL, 0);
  *v4 = v1;
  caml_raise((__int64)v4);
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (000000000042AA60) ----------------------------------------------------
void __noreturn caml_raise_sys_blocked_io()
{
  caml_raise_constant((__int64)&caml_exn_Sys_blocked_io);
}
// 647C10: using guessed type char *caml_exn_Sys_blocked_io;

//----- (000000000042AA70) ----------------------------------------------------
void __noreturn caml_raise_not_found()
{
  caml_raise_constant((__int64)&caml_exn_Not_found);
}
// 647B68: using guessed type char *caml_exn_Not_found;

//----- (000000000042AA80) ----------------------------------------------------
void __noreturn caml_raise_zero_divide()
{
  caml_raise_constant((__int64)&caml_exn_Division_by_zero);
}
// 647B28: using guessed type char *caml_exn_Division_by_zero;

//----- (000000000042AA90) ----------------------------------------------------
void __noreturn caml_raise_end_of_file()
{
  caml_raise_constant((__int64)&caml_exn_End_of_file);
}
// 647AF0: using guessed type char *caml_exn_End_of_file;

//----- (000000000042AAA0) ----------------------------------------------------
void __fastcall caml_do_local_roots(
        void (__fastcall *a1)(_QWORD, _QWORD *),
        __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        _QWORD *a5)
{
  __int64 v6; // rcx
  __int64 v7; // r15
  _QWORD *v8; // rdi
  __int64 v9; // rax
  __int64 i; // rbp
  unsigned __int16 v11; // ax
  unsigned __int16 v12; // r14
  unsigned __int16 *v13; // r13
  int v14; // er12
  _QWORD *v15; // rax
  int v16; // eax
  __int64 v17; // rax
  _QWORD *j; // r12
  int k; // er14
  int v20; // ebp
  __int64 v21; // rax
  _QWORD *v22; // rsi

  if ( a2 )
  {
    v6 = caml_frame_descriptors_mask;
    v7 = a2;
    v8 = caml_frame_descriptors;
    do
    {
      while ( 1 )
      {
        v9 = v6 & (a3 >> 3);
        for ( i = v8[v9]; *(_QWORD *)i != a3; i = v8[v9] )
          v9 = v6 & (v9 + 1);
        v11 = *(_WORD *)(i + 8);
        if ( v11 == 0xFFFF )
          break;
        v12 = *(_WORD *)(i + 10);
        if ( v12 )
        {
          v13 = (unsigned __int16 *)(i + 12);
          v14 = 0;
          while ( 1 )
          {
            v16 = *v13;
            v15 = (_QWORD *)((v16 & 1) != 0 ? a4 + 8LL * (v16 >> 1) : v7 + *v13);
            ++v14;
            a1(*v15, v15);
            if ( v12 == v14 )
              break;
            ++v13;
          }
          v11 = *(_WORD *)(i + 8);
          v6 = caml_frame_descriptors_mask;
          v8 = caml_frame_descriptors;
        }
        v7 += v11 & 0xFFFC;
        a3 = *(_QWORD *)(v7 - 8);
      }
      v17 = v7 + 16;
      v7 = *(_QWORD *)(v7 + 16);
      a3 = *(_QWORD *)(v17 + 8);
      a4 = *(_QWORD *)(v17 + 16);
    }
    while ( v7 );
  }
  for ( j = a5; j; j = (_QWORD *)*j )
  {
    for ( k = 0; k < j[1]; ++k )
    {
      if ( (__int64)j[2] > 0 )
      {
        v20 = 0;
        v21 = 0LL;
        do
        {
          ++v20;
          v22 = (_QWORD *)(j[k + 3] + 8 * v21);
          a1(*v22, v22);
          v21 = v20;
        }
        while ( v20 < j[2] );
      }
    }
  }
}
// 663160: using guessed type int caml_frame_descriptors_mask;

//----- (000000000042AC20) ----------------------------------------------------
_QWORD *__fastcall caml_register_dyn_global(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *result; // rax

  v1 = caml_dyn_globals;
  result = caml_stat_alloc(0x10uLL);
  *result = a1;
  result[1] = v1;
  caml_dyn_globals = (__int64)result;
  return result;
}
// 658A90: using guessed type __int64 caml_dyn_globals;

//----- (000000000042AC60) ----------------------------------------------------
void __fastcall caml_register_frametable(__int64 a1)
{
  __int64 v2; // rbx
  _QWORD *v3; // rax
  void *v4; // rdi

  v2 = frametables;
  v3 = caml_stat_alloc(0x10uLL);
  v4 = caml_frame_descriptors;
  *v3 = a1;
  v3[1] = v2;
  frametables = (__int64)v3;
  if ( v4 )
  {
    caml_stat_free(v4);
    caml_frame_descriptors = 0LL;
  }
}
// 658AA0: using guessed type __int64 frametables;

//----- (000000000042ACC0) ----------------------------------------------------
char *caml_init_frame_descriptors()
{
  void *v0; // rdi
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rdx
  _QWORD *v4; // rcx
  __int64 v5; // rdx
  __int64 i; // rbx
  char *result; // rax
  int v8; // ecx
  __int64 v9; // rdx
  __int64 v10; // r9
  __int64 v11; // rbx
  __int64 v12; // r8
  __int64 v13; // rsi
  __int64 v14; // rdi
  __int64 v15; // rdx
  char *j; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // rdx

  if ( !inited_3995 )
  {
    v0 = caml_frametable;
    if ( caml_frametable )
    {
      v1 = 0LL;
      do
      {
        ++v1;
        caml_register_frametable((__int64)v0);
        v0 = *(&caml_frametable + v1);
      }
      while ( v0 );
    }
    inited_3995 = 1;
  }
  v2 = frametables;
  if ( !frametables )
    goto LABEL_27;
  v3 = 0LL;
  do
  {
    v4 = *(_QWORD **)v2;
    v2 = *(_QWORD *)(v2 + 8);
    v3 += *v4;
  }
  while ( v2 );
  v5 = 2 * v3;
  if ( v5 > 4 )
  {
    for ( i = 4LL; i < v5; i *= 2LL )
      ;
    result = (char *)caml_stat_alloc(8 * i);
    v8 = i - 1;
    caml_frame_descriptors = result;
  }
  else
  {
LABEL_27:
    i = 4LL;
    result = (char *)caml_stat_alloc(0x20uLL);
    v8 = 3;
    caml_frame_descriptors = result;
  }
  v9 = 0LL;
  do
    *(_QWORD *)&result[8 * v9++] = 0LL;
  while ( v9 < i );
  v10 = frametables;
  caml_frame_descriptors_mask = v8;
  if ( frametables )
  {
    v11 = v8;
    do
    {
      v12 = **(_QWORD **)v10;
      if ( v12 > 0 )
      {
        v13 = *(_QWORD *)v10 + 8LL;
        v14 = 0LL;
        while ( 1 )
        {
          v15 = v11 & (*(_QWORD *)v13 >> 3);
          for ( j = &result[8 * v15]; *(_QWORD *)j; j = &result[8 * v15] )
            v15 = v11 & (v15 + 1);
          v17 = *(unsigned __int16 *)(v13 + 10);
          *(_QWORD *)j = v13;
          v18 = (v13 + 2 * v17 + 19) & 0xFFFFFFFFFFFFFFF8LL;
          if ( (*(_BYTE *)(v13 + 8) & 1) != 0 )
            v18 += 8LL;
          if ( ++v14 == v12 )
            break;
          v13 = v18;
        }
      }
      v10 = *(_QWORD *)(v10 + 8);
    }
    while ( v10 );
  }
  return result;
}
// 648340: using guessed type void *caml_frametable;
// 658AA0: using guessed type __int64 frametables;
// 658AA8: using guessed type int inited_3995;
// 663160: using guessed type int caml_frame_descriptors_mask;

//----- (000000000042AE10) ----------------------------------------------------
__int64 (__fastcall *__fastcall caml_do_roots(void (__fastcall *a1)(__int64, __int64 *)))(_QWORD)
{
  int v1; // er14
  __int64 (*i)[84]; // r12
  __int64 v3; // rdx
  int j; // ebp
  __int64 *v5; // r14
  __int64 v6; // r12
  _QWORD *v7; // r13
  __int64 v8; // rdx
  int v9; // ebp
  __int64 (__fastcall *result)(_QWORD); // rax

  v1 = 0;
  for ( i = caml_globals; i; i = *(&caml_globals + v1) )
  {
    v3 = 0LL;
    for ( j = 0; j < (unsigned __int64)(*i)[-1] >> 10; v3 = j )
    {
      ++j;
      a1((*i)[v3], &(*i)[v3]);
    }
    ++v1;
  }
  v5 = (__int64 *)caml_dyn_globals;
  if ( caml_dyn_globals )
  {
    do
    {
      v6 = *v5;
      v7 = (_QWORD *)(*v5 - 8);
      if ( *v7 >> 10 )
      {
        v8 = 0LL;
        v9 = 0;
        do
        {
          ++v9;
          a1(*(_QWORD *)(v6 + 8 * v8), (__int64 *)(v6 + 8 * v8));
          v8 = v9;
        }
        while ( (unsigned __int64)v9 < *v7 >> 10 );
      }
      v5 = (__int64 *)v5[1];
    }
    while ( v5 );
  }
  if ( !caml_frame_descriptors )
    caml_init_frame_descriptors();
  caml_do_local_roots(a1, caml_bottom_of_stack, caml_last_return_address, caml_gc_regs, (_QWORD *)caml_local_roots);
  caml_scan_global_roots((__int64 (__fastcall *)(_QWORD, _QWORD))a1);
  caml_final_do_strong_roots((__int64 (__fastcall *)(void *, void **))a1);
  result = caml_scan_roots_hook;
  if ( caml_scan_roots_hook )
    return (__int64 (__fastcall *)(_QWORD))caml_scan_roots_hook(a1);
  return result;
}
// 647CC0: using guessed type __int64 (*caml_globals)[84];
// 6586A8: using guessed type __int64 caml_last_return_address;
// 658A68: using guessed type __int64 caml_local_roots;
// 658A70: using guessed type __int64 (__fastcall *caml_scan_roots_hook)(_QWORD);
// 658A80: using guessed type __int64 caml_bottom_of_stack;
// 658A90: using guessed type __int64 caml_dyn_globals;
// 663168: using guessed type __int64 caml_gc_regs;

//----- (000000000042AF40) ----------------------------------------------------
__int64 (__fastcall *caml_darken_all_roots())(_QWORD)
{
  return caml_do_roots((void (__fastcall *)(__int64, __int64 *))caml_darken);
}

//----- (000000000042AF50) ----------------------------------------------------
__int64 (__fastcall *caml_oldify_local_roots())(_QWORD)
{
  int v0; // er12
  __int64 v1; // rdx
  __int64 v2; // rbp
  __int64 v3; // r13
  unsigned __int64 v4; // rcx
  __int64 v5; // rax
  int v6; // ebx
  unsigned __int64 *v7; // rsi
  unsigned __int64 v8; // rdi
  __int64 *v9; // r12
  __int64 v10; // rbp
  unsigned __int64 v11; // rcx
  unsigned __int64 *v12; // r13
  __int64 v13; // rax
  int v14; // ebx
  unsigned __int64 *v15; // rsi
  unsigned __int64 v16; // rdi
  __int64 v17; // r14
  unsigned __int64 v18; // rdx
  __int64 v19; // r15
  __int64 v20; // rcx
  _QWORD *v21; // rsi
  __int64 v22; // rax
  __int64 i; // rbx
  unsigned __int16 v24; // ax
  unsigned __int16 v25; // r13
  unsigned __int16 *v26; // r12
  int v27; // ebp
  unsigned __int64 *v28; // rsi
  unsigned __int64 v29; // rdi
  int v30; // eax
  __int64 v31; // rax
  _QWORD *v32; // rbp
  int j; // er13
  int v34; // ebx
  __int64 v35; // rsi
  unsigned __int64 *v36; // rsi
  unsigned __int64 v37; // rdi
  __int64 (__fastcall *result)(_QWORD); // rax

  v0 = caml_globals_scanned;
  v1 = caml_globals_inited;
  if ( (int)caml_globals_scanned <= caml_globals_inited )
  {
    v2 = (__int64)*(&caml_globals + (int)caml_globals_scanned);
    if ( v2 )
    {
      v3 = (int)caml_globals_scanned + 1LL;
      do
      {
        v4 = *(_QWORD *)(v2 - 8);
        v5 = 0LL;
        v6 = 0;
        if ( v4 >> 10 )
        {
          do
          {
            v7 = (unsigned __int64 *)(v2 + 8 * v5);
            v8 = *v7;
            if ( (*v7 & 1) == 0 && v8 < caml_young_end && v8 > caml_young_start )
            {
              caml_oldify_one(v8, v7);
              v4 = *(_QWORD *)(v2 - 8);
            }
            v5 = ++v6;
          }
          while ( v6 < v4 >> 10 );
          v1 = caml_globals_inited;
        }
        ++v0;
        if ( v1 < v3 )
          break;
        ++v3;
        v2 = (__int64)*(&caml_globals + v0);
      }
      while ( v2 );
    }
  }
  v9 = (__int64 *)caml_dyn_globals;
  caml_globals_scanned = v1;
  if ( caml_dyn_globals )
  {
    do
    {
      v10 = *v9;
      v11 = *(_QWORD *)(*v9 - 8);
      v12 = (unsigned __int64 *)(*v9 - 8);
      if ( v11 >> 10 )
      {
        v13 = 0LL;
        v14 = 0;
        do
        {
          v15 = (unsigned __int64 *)(v10 + 8 * v13);
          v16 = *v15;
          if ( (*v15 & 1) == 0 && v16 < caml_young_end && v16 > caml_young_start )
          {
            caml_oldify_one(v16, v15);
            v11 = *v12;
          }
          v13 = ++v14;
        }
        while ( v14 < v11 >> 10 );
      }
      v9 = (__int64 *)v9[1];
    }
    while ( v9 );
  }
  if ( !caml_frame_descriptors )
    caml_init_frame_descriptors();
  v17 = caml_bottom_of_stack;
  v18 = caml_last_return_address;
  v19 = caml_gc_regs;
  if ( caml_bottom_of_stack )
  {
    v20 = caml_frame_descriptors_mask;
    v21 = caml_frame_descriptors;
    do
    {
      while ( 1 )
      {
        v22 = v20 & (v18 >> 3);
        for ( i = v21[v22]; *(_QWORD *)i != v18; i = v21[v22] )
          v22 = v20 & (v22 + 1);
        v24 = *(_WORD *)(i + 8);
        if ( v24 == 0xFFFF )
          break;
        v25 = *(_WORD *)(i + 10);
        if ( v25 )
        {
          v26 = (unsigned __int16 *)(i + 12);
          v27 = 0;
          while ( 1 )
          {
            v30 = *v26;
            v28 = (unsigned __int64 *)((v30 & 1) != 0 ? v19 + 8LL * (v30 >> 1) : v17 + *v26);
            v29 = *v28;
            if ( (*v28 & 1) == 0 && v29 < caml_young_end && v29 > caml_young_start )
              caml_oldify_one(v29, v28);
            if ( v25 == ++v27 )
              break;
            ++v26;
          }
          v24 = *(_WORD *)(i + 8);
          v20 = caml_frame_descriptors_mask;
          v21 = caml_frame_descriptors;
        }
        v17 += v24 & 0xFFFC;
        v18 = *(_QWORD *)(v17 - 8);
      }
      v31 = v17 + 16;
      v17 = *(_QWORD *)(v17 + 16);
      v18 = *(_QWORD *)(v31 + 8);
      v19 = *(_QWORD *)(v31 + 16);
    }
    while ( v17 );
  }
  v32 = (_QWORD *)caml_local_roots;
  if ( caml_local_roots )
  {
    do
    {
      for ( j = 0; j < v32[1]; ++j )
      {
        if ( (__int64)v32[2] > 0 )
        {
          v34 = 0;
          v35 = 0LL;
          do
          {
            v36 = (unsigned __int64 *)(v32[j + 3] + 8 * v35);
            v37 = *v36;
            if ( (*v36 & 1) == 0 && v37 < caml_young_end && v37 > caml_young_start )
              caml_oldify_one(v37, v36);
            v35 = ++v34;
          }
          while ( v34 < v32[2] );
        }
      }
      v32 = (_QWORD *)*v32;
    }
    while ( v32 );
  }
  caml_scan_global_young_roots((__int64 (__fastcall *)(_QWORD, _QWORD))caml_oldify_one);
  caml_final_do_young_roots((void (__fastcall *)(_QWORD, __int64))caml_oldify_one);
  result = caml_scan_roots_hook;
  if ( caml_scan_roots_hook )
    return (__int64 (__fastcall *)(_QWORD))caml_scan_roots_hook(caml_oldify_one);
  return result;
}
// 647CC0: using guessed type __int64 (*caml_globals)[84];
// 6586A8: using guessed type __int64 caml_last_return_address;
// 658A68: using guessed type __int64 caml_local_roots;
// 658A70: using guessed type __int64 (__fastcall *caml_scan_roots_hook)(_QWORD);
// 658A80: using guessed type __int64 caml_bottom_of_stack;
// 658A88: using guessed type __int64 caml_globals_inited;
// 658A90: using guessed type __int64 caml_dyn_globals;
// 658A98: using guessed type __int64 caml_globals_scanned;
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 663160: using guessed type int caml_frame_descriptors_mask;
// 663168: using guessed type __int64 caml_gc_regs;

//----- (000000000042B2A0) ----------------------------------------------------
__int64 __fastcall caml_iterate_global_roots(__int64 (__fastcall *a1)(_QWORD, _QWORD), __int64 a2)
{
  _QWORD *i; // rbx
  __int64 result; // rax

  for ( i = *(_QWORD **)(a2 + 8); i; i = (_QWORD *)i[1] )
    result = a1(*(_QWORD *)*i, *i);
  return result;
}

//----- (000000000042B2E0) ----------------------------------------------------
__int64 __fastcall caml_scan_global_roots(__int64 (__fastcall *a1)(_QWORD, _QWORD))
{
  caml_iterate_global_roots(a1, (__int64)&caml_global_roots);
  caml_iterate_global_roots(a1, (__int64)&caml_global_roots_young);
  return caml_iterate_global_roots(a1, (__int64)&caml_global_roots_old);
}

//----- (000000000042B310) ----------------------------------------------------
_QWORD *__fastcall caml_insert_global_root(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdx
  int v4; // er8
  int v5; // esi
  __int64 i; // rcx
  unsigned __int64 *v7; // rax
  _QWORD *result; // rax
  int v9; // ebp
  size_t v10; // rcx
  int v11; // edx
  int j; // eax
  __int64 v13; // rdx
  __int64 v14; // rcx
  int v15; // edx
  __int64 v16; // rbx
  __int64 v17; // rsi
  __int64 v18[21]; // [rsp+0h] [rbp-A8h]

  v2 = a1;
  v4 = *(_DWORD *)(a1 + 144);
  if ( v4 >= 0 )
  {
    v5 = *(_DWORD *)(a1 + 144);
    for ( i = v4; ; i = v5 )
    {
      while ( 1 )
      {
        v7 = *(unsigned __int64 **)(v2 + 8 * i + 8);
        if ( !v7 || *v7 >= a2 )
          break;
        v2 = *(_QWORD *)(v2 + 8 * i + 8);
      }
      --v5;
      v18[i] = v2;
      if ( v5 == -1 )
        break;
    }
  }
  result = *(_QWORD **)(v2 + 8);
  if ( !result || *result != a2 )
  {
    v9 = 0;
    v10 = 16LL;
    random_seed = 69069 * random_seed + 25173;
    v11 = random_seed;
    if ( (random_seed & 0xC0000000) == -1073741824 )
    {
      do
      {
        v11 *= 4;
        ++v9;
      }
      while ( (v11 & 0xC0000000) == -1073741824 );
      v10 = 8LL * v9 + 16;
    }
    if ( v4 < v9 )
    {
      for ( j = v4 + 1; v9 >= j; v18[v13] = a1 )
        v13 = j++;
      *(_DWORD *)(a1 + 144) = v9;
    }
    result = caml_stat_alloc(v10);
    v14 = 0LL;
    *result = a2;
    v15 = 0;
    do
    {
      v16 = v18[v14];
      v17 = v15++;
      result[++v14] = *(_QWORD *)(v16 + 8 * v17 + 8);
      *(_QWORD *)(v16 + 8 * v17 + 8) = result;
    }
    while ( v9 >= v15 );
  }
  return result;
}
// 658C98: using guessed type int random_seed;
// 42B310: using guessed type __int64 var_A8[21];

//----- (000000000042B430) ----------------------------------------------------
_QWORD *__fastcall caml_register_global_root(unsigned __int64 a1)
{
  return caml_insert_global_root((__int64)&caml_global_roots, a1);
}

//----- (000000000042B440) ----------------------------------------------------
void __fastcall caml_scan_global_young_roots(__int64 (__fastcall *a1)(_QWORD, _QWORD))
{
  unsigned __int64 *v1; // rbx
  _QWORD *v2; // rdi
  _QWORD *v3; // rbx
  int v4; // ecx
  __int64 *v5; // rdx
  int v6; // eax

  caml_iterate_global_roots(a1, (__int64)&caml_global_roots);
  caml_iterate_global_roots(a1, (__int64)&caml_global_roots_young);
  v1 = (unsigned __int64 *)qword_658B68;
  if ( qword_658B68 )
  {
    do
    {
      caml_insert_global_root((__int64)&caml_global_roots_old, *v1);
      v1 = (unsigned __int64 *)v1[1];
    }
    while ( v1 );
    v2 = (_QWORD *)qword_658B68;
    if ( qword_658B68 )
    {
      while ( 1 )
      {
        v3 = (_QWORD *)v2[1];
        caml_stat_free(v2);
        if ( !v3 )
          break;
        v2 = v3;
      }
    }
  }
  v4 = dword_658BF0;
  if ( dword_658BF0 >= 0 )
  {
    v5 = &qword_658B68;
    v6 = 0;
    do
    {
      ++v6;
      *v5++ = 0LL;
    }
    while ( v6 <= v4 );
  }
  dword_658BF0 = 0;
}
// 658B68: using guessed type __int64 qword_658B68;
// 658BF0: using guessed type int dword_658BF0;

//----- (000000000042B4E0) ----------------------------------------------------
void __fastcall caml_delete_global_root(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdx
  int v4; // er8
  int v5; // edi
  __int64 i; // rcx
  unsigned __int64 *v7; // rax
  _QWORD *v8; // rdi
  __int64 v9; // rdx
  int j; // eax
  __int64 v11; // rcx
  __int64 v12; // rsi
  __int64 v13; // r10
  int v14; // eax
  __int64 v15[19]; // [rsp+0h] [rbp-98h]

  v2 = a1;
  v4 = *(_DWORD *)(a1 + 144);
  if ( v4 >= 0 )
  {
    v5 = *(_DWORD *)(a1 + 144);
    for ( i = v4; ; i = v5 )
    {
      while ( 1 )
      {
        v7 = *(unsigned __int64 **)(v2 + 8 * i + 8);
        if ( !v7 || *v7 >= a2 )
          break;
        v2 = *(_QWORD *)(v2 + 8 * i + 8);
      }
      --v5;
      v15[i] = v2;
      if ( v5 == -1 )
        break;
    }
  }
  v8 = *(_QWORD **)(v2 + 8);
  if ( v8 && *v8 == a2 )
  {
    if ( v4 >= 0 )
    {
      v9 = 0LL;
      for ( j = 0; j <= v4; ++j )
      {
        while ( 1 )
        {
          v11 = v15[v9];
          v12 = j;
          if ( *(_QWORD **)(v11 + 8LL * j + 8) == v8 )
            break;
          ++j;
          ++v9;
          if ( v4 < j )
            goto LABEL_16;
        }
        v13 = v8[++v9];
        *(_QWORD *)(v11 + 8 * v12 + 8) = v13;
      }
    }
LABEL_16:
    caml_stat_free(v8);
    v14 = *(_DWORD *)(a1 + 144);
    if ( v14 > 0 && !*(_QWORD *)(a1 + 8LL * v14 + 8) )
    {
      do
      {
        if ( !--v14 )
        {
          *(_DWORD *)(a1 + 144) = 0;
          return;
        }
      }
      while ( !*(_QWORD *)(a1 + 8LL * v14 + 8) );
      *(_DWORD *)(a1 + 144) = v14;
    }
  }
}
// 42B4E0: using guessed type __int64 var_98[19];

//----- (000000000042B5E0) ----------------------------------------------------
void __fastcall caml_remove_global_root(unsigned __int64 a1)
{
  caml_delete_global_root((__int64)&caml_global_roots, a1);
}

//----- (000000000042B5F0) ----------------------------------------------------
void __fastcall caml_modify_generational_global_root(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rdi

  v3 = *a1;
  if ( (a2 & 1) != 0 || a2 >= caml_young_end || a2 <= caml_young_start )
  {
    if ( (v3 & 1) != 0 )
    {
      if ( (a2 & 1) != 0 )
        goto LABEL_13;
      if ( a2 >= caml_young_end )
      {
LABEL_17:
        if ( (caml_page_table_lookup(a2) & 1) != 0 )
          caml_insert_global_root((__int64)&caml_global_roots_old, (unsigned __int64)a1);
        goto LABEL_13;
      }
LABEL_5:
      if ( a2 > caml_young_start )
      {
        caml_insert_global_root((__int64)&caml_global_roots_young, (unsigned __int64)a1);
        goto LABEL_13;
      }
      goto LABEL_17;
    }
    if ( (a2 & 1) != 0 )
    {
      if ( v3 >= caml_young_end || v3 <= caml_young_start )
      {
        if ( (caml_page_table_lookup(v3) & 1) != 0 )
          caml_delete_global_root((__int64)&caml_global_roots_old, (unsigned __int64)a1);
      }
      else
      {
        caml_delete_global_root((__int64)&caml_global_roots_young, (unsigned __int64)a1);
      }
    }
  }
  else
  {
    if ( (v3 & 1) != 0 )
      goto LABEL_5;
    if ( (caml_page_table_lookup(v3) & 1) != 0 )
    {
      caml_delete_global_root((__int64)&caml_global_roots_old, (unsigned __int64)a1);
      caml_insert_global_root((__int64)&caml_global_roots_young, (unsigned __int64)a1);
    }
  }
LABEL_13:
  *a1 = a2;
}
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;

//----- (000000000042B720) ----------------------------------------------------
void __fastcall caml_remove_generational_global_root(unsigned __int64 *a1)
{
  unsigned __int64 v2; // rdi

  v2 = *a1;
  if ( (v2 & 1) == 0 )
  {
    if ( v2 >= caml_young_end || v2 <= caml_young_start )
    {
      if ( (caml_page_table_lookup(v2) & 1) != 0 )
        caml_delete_global_root((__int64)&caml_global_roots_old, (unsigned __int64)a1);
    }
    else
    {
      caml_delete_global_root((__int64)&caml_global_roots_young, (unsigned __int64)a1);
    }
  }
}
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;

//----- (000000000042B770) ----------------------------------------------------
void __fastcall caml_register_generational_global_root(unsigned __int64 *a1)
{
  unsigned __int64 v2; // rdi

  v2 = *a1;
  if ( (v2 & 1) == 0 )
  {
    if ( v2 >= caml_young_end || v2 <= caml_young_start )
    {
      if ( (caml_page_table_lookup(v2) & 1) != 0 )
        caml_insert_global_root((__int64)&caml_global_roots_old, (unsigned __int64)a1);
    }
    else
    {
      caml_insert_global_root((__int64)&caml_global_roots_young, (unsigned __int64)a1);
    }
  }
}
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;

//----- (000000000042B7C0) ----------------------------------------------------
__int64 __fastcall caml_record_signal(int a1)
{
  __int64 result; // rax

  result = caml_young_end;
  caml_pending_signals[a1] = 1LL;
  caml_signals_are_pending = 1LL;
  caml_young_limit = result;
  return result;
}
// 658CA0: using guessed type __int64 caml_signals_are_pending;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CCF8: using guessed type __int64 caml_young_limit;
// 663180: using guessed type __int64 caml_pending_signals[65];

//----- (000000000042B7F0) ----------------------------------------------------
void caml_enter_blocking_section_default()
{
  caml_async_signal_mode = 1LL;
}
// 658CB0: using guessed type __int64 caml_async_signal_mode;

//----- (000000000042B800) ----------------------------------------------------
void caml_leave_blocking_section_default()
{
  caml_async_signal_mode = 0LL;
}
// 658CB0: using guessed type __int64 caml_async_signal_mode;

//----- (000000000042B810) ----------------------------------------------------
__int64 caml_try_leave_blocking_section_default()
{
  return _InterlockedExchange64(&caml_async_signal_mode, 0LL);
}
// 42B810: using guessed type __int64 __fastcall caml_try_leave_blocking_section_default();
// 658CB0: using guessed type __int64 caml_async_signal_mode;

//----- (000000000042B820) ----------------------------------------------------
__int64 caml_urge_major_slice()
{
  __int64 result; // rax

  result = caml_young_end;
  caml_force_major_slice = 1;
  caml_young_limit = caml_young_end;
  return result;
}
// 658CA8: using guessed type int caml_force_major_slice;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000042B840) ----------------------------------------------------
__int64 __fastcall caml_convert_signal_number(unsigned int a1)
{
  __int64 result; // rax

  result = a1;
  if ( a1 > 0xFFFFFFEA )
    return (unsigned int)posix_signals[~a1];
  return result;
}
// 42B849: conditional instruction was optimized away because edi.4>=FFFFFFEBu
// 43D500: using guessed type int posix_signals[];

//----- (000000000042B860) ----------------------------------------------------
__int64 __fastcall caml_rev_convert_signal_number(unsigned int a1)
{
  __int64 result; // rax
  _DWORD *v2; // rdx
  int v3; // ecx

  result = a1;
  v2 = &unk_43D504;
  v3 = 1;
  if ( a1 == 6 )
    return 0xFFFFFFFFLL;
  while ( *v2 != a1 )
  {
    ++v3;
    ++v2;
    if ( v3 == 21 )
      return result;
  }
  return (unsigned int)~v3;
}

//----- (000000000042B8A0) ----------------------------------------------------
__int64 __fastcall caml_execute_signal(int signo, int a2)
{
  _DWORD *v2; // rax
  int v3; // edx
  __int64 v4; // rax
  __int64 v5; // r12
  __int64 result; // rax
  _BYTE savedregs[168]; // [rsp+0h] [rbp+0h] BYREF

  sigemptyset((sigset_t *)savedregs);
  sigaddset((sigset_t *)savedregs, signo);
  sigprocmask(0, (const sigset_t *)savedregs, (sigset_t *)savedregs);
  v2 = &unk_43D504;
  v3 = 1;
  if ( signo != 6 )
  {
    do
    {
      if ( signo == *v2 )
        break;
      ++v3;
      ++v2;
    }
    while ( v3 != 21 );
  }
  caml_callback_exn();
  v5 = v4;
  if ( a2 )
  {
    result = v4 & 3;
    if ( result != 2 )
      return result;
    sigdelset((sigset_t *)savedregs, signo);
    sigprocmask(2, (const sigset_t *)savedregs, 0LL);
LABEL_11:
    caml_raise(v5 & 0xFFFFFFFFFFFFFFFCLL);
  }
  sigprocmask(2, (const sigset_t *)savedregs, 0LL);
  result = v5 & 3;
  if ( result == 2 )
    goto LABEL_11;
  return result;
}
// 42B91B: variable 'v4' is possibly undefined

//----- (000000000042B9A0) ----------------------------------------------------
__int64 caml_process_pending_signals()
{
  __int64 result; // rax
  int i; // ebx
  int v2; // edi

  result = caml_signals_are_pending;
  if ( caml_signals_are_pending )
  {
    caml_signals_are_pending = 0LL;
    for ( i = 0; i != 65; ++i )
    {
      while ( 1 )
      {
        result = i;
        if ( caml_pending_signals[i] )
          break;
        if ( ++i == 65 )
          return result;
      }
      v2 = i;
      caml_pending_signals[result] = 0LL;
      result = caml_execute_signal(v2, 0);
    }
  }
  return result;
}
// 658CA0: using guessed type __int64 caml_signals_are_pending;
// 663180: using guessed type __int64 caml_pending_signals[65];

//----- (000000000042BA00) ----------------------------------------------------
__int64 __fastcall caml_install_signal_handler(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  int v3; // ebx
  __int64 v4; // rbp
  int v5; // eax
  unsigned __int64 *v6; // rax
  __int64 v7; // rdx
  __int64 v9; // [rsp+0h] [rbp-B8h] BYREF
  __int64 v10; // [rsp+8h] [rbp-B0h] BYREF
  __int64 v11[8]; // [rsp+10h] [rbp-A8h] BYREF
  __int64 v12[9]; // [rsp+50h] [rbp-68h] BYREF
  __int64 v13; // [rsp+98h] [rbp-20h] BYREF

  v2 = a1 >> 1;
  v3 = a1 >> 1;
  v4 = caml_local_roots;
  v10 = a1;
  v9 = a2;
  v12[2] = 1LL;
  v12[1] = 2LL;
  v12[3] = (__int64)&v10;
  v12[0] = caml_local_roots;
  v12[4] = (__int64)&v9;
  v13 = 0LL;
  v11[0] = (__int64)v12;
  v11[2] = 1LL;
  v11[1] = 1LL;
  caml_local_roots = (__int64)v11;
  v11[3] = (__int64)&v13;
  if ( (unsigned int)v3 > 0xFFFFFFEA && (int)v2 < 0 )
  {
    v3 = posix_signals[(int)~(a1 >> 1)];
    LODWORD(v2) = v3;
  }
  if ( (unsigned int)v2 > 0x40 )
    caml_invalid_argument("Sys.signal: unavailable signal");
  if ( (unsigned __int64)(v9 - 1) > 2 )
  {
    v5 = caml_set_signal_action(v3, 2);
    if ( v5 != 1 )
      goto LABEL_7;
LABEL_16:
    v13 = 3LL;
    goto LABEL_10;
  }
  v5 = caml_set_signal_action(v3, CSWTCH_33[v9 - 1]);
  if ( v5 == 1 )
    goto LABEL_16;
LABEL_7:
  if ( v5 == 2 )
  {
    v13 = (__int64)caml_alloc_small(1LL, 0);
    *(_QWORD *)v13 = *(_QWORD *)(caml_signal_handlers + 8LL * v3);
  }
  else
  {
    if ( v5 )
      caml_sys_error((void *)1);
    v13 = 1LL;
  }
LABEL_10:
  v6 = (unsigned __int64 *)v9;
  if ( (v9 & 1) == 0 )
  {
    v7 = caml_signal_handlers;
    if ( !caml_signal_handlers )
    {
      caml_signal_handlers = (__int64)caml_alloc(0x41uLL, 0);
      caml_register_global_root((unsigned __int64)&caml_signal_handlers);
      v6 = (unsigned __int64 *)v9;
      v7 = caml_signal_handlers;
    }
    caml_modify((unsigned __int64 *)(v7 + 8LL * v3), *v6);
  }
  caml_process_pending_signals();
  caml_local_roots = v4;
  return v13;
}
// 43D500: using guessed type int posix_signals[];
// 43D554: using guessed type int CSWTCH_33[3];
// 658A68: using guessed type __int64 caml_local_roots;
// 658CB8: using guessed type __int64 caml_signal_handlers;

//----- (000000000042BBF0) ----------------------------------------------------
__int64 caml_leave_blocking_section()
{
  caml_leave_blocking_section_hook();
  return caml_process_pending_signals();
}
// 6586B8: using guessed type __int64 (*caml_leave_blocking_section_hook)(void);

//----- (000000000042BC10) ----------------------------------------------------
__int64 caml_enter_blocking_section()
{
  __int64 result; // rax

  while ( 1 )
  {
    caml_process_pending_signals();
    caml_enter_blocking_section_hook();
    result = caml_signals_are_pending;
    if ( !caml_signals_are_pending )
      break;
    caml_leave_blocking_section_hook();
  }
  return result;
}
// 6586B0: using guessed type __int64 (*caml_enter_blocking_section_hook)(void);
// 6586B8: using guessed type __int64 (*caml_leave_blocking_section_hook)(void);
// 658CA0: using guessed type __int64 caml_signals_are_pending;

//----- (000000000042BC50) ----------------------------------------------------
int caml_init_signals()
{
  int result; // eax
  struct sigaction v1; // [rsp+0h] [rbp-C8h] BYREF
  struct sigaltstack v2; // [rsp+A0h] [rbp-28h] BYREF

  v2.ss_sp = &sig_alt_stack;
  v2.ss_size = 0x2000LL;
  v2.ss_flags = 0;
  v1.sa_handler = (__sighandler_t)segv_handler;
  v1.sa_flags = 1207959556;
  sigemptyset(&v1.sa_mask);
  system_stack_top = (__int64)&v1;
  result = sigaltstack(&v2, 0LL);
  if ( !result )
    return sigaction(11, &v1, 0LL);
  return result;
}
// 658CC0: using guessed type __int64 system_stack_top;

//----- (000000000042BCD0) ----------------------------------------------------
int __fastcall caml_set_signal_action(int sig, int a2)
{
  int result; // eax
  void *v3[20]; // [rsp+0h] [rbp-158h] BYREF
  struct sigaction v4; // [rsp+A0h] [rbp-B8h] BYREF

  if ( a2 )
  {
    if ( a2 == 1 )
    {
      v4.sa_handler = (__sighandler_t)1;
      v4.sa_flags = 0;
    }
    else
    {
      v4.sa_handler = (__sighandler_t)handle_signal;
      v4.sa_flags = 4;
    }
  }
  else
  {
    v4.sa_handler = 0LL;
    v4.sa_flags = 0;
  }
  sigemptyset(&v4.sa_mask);
  result = sigaction(sig, &v4, (struct sigaction *)v3);
  if ( result != -1 )
  {
    result = 2;
    if ( v3[0] != handle_signal )
      return v3[0] == (void *)1;
  }
  return result;
}
// 42BCD0: using guessed type void (__fastcall *var_158[20])(unsigned int a1);

//----- (000000000042BD80) ----------------------------------------------------
int __fastcall segv_handler(__int64 a1, __int64 a2, _QWORD *a3)
{
  rlim64_t v4; // rbx
  unsigned __int64 v5; // rdi
  struct sigaction v7; // [rsp+0h] [rbp-C8h] BYREF
  struct rlimit64 rlimits; // [rsp+A0h] [rbp-28h] BYREF

  v4 = a3[27];
  if ( (v4 & 7) == 0
    && !getrlimit64(RLIMIT_STACK, &rlimits)
    && v4 < system_stack_top
    && v4 >= system_stack_top - rlimits.rlim_cur - 0x2000 )
  {
    if ( (v5 = a3[21], v5 >= caml_code_area_start) && v5 <= caml_code_area_end || (caml_page_table_lookup(v5) & 8) != 0 )
    {
      caml_exception_pointer = a3[11];
      caml_young_ptr = a3[12];
      caml_raise_stack_overflow();
    }
  }
  v7.sa_handler = 0LL;
  v7.sa_flags = 0;
  sigemptyset(&v7.sa_mask);
  return sigaction(11, &v7, 0LL);
}
// 658A40: using guessed type __int64 caml_exception_pointer;
// 658CC0: using guessed type __int64 system_stack_top;
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 662860: using guessed type __int64 caml_code_area_start;
// 662948: using guessed type __int64 caml_code_area_end;

//----- (000000000042BE50) ----------------------------------------------------
void __fastcall handle_signal(unsigned int a1)
{
  if ( a1 <= 0x40 )
  {
    if ( (unsigned int)caml_try_leave_blocking_section_hook() )
    {
      caml_execute_signal(a1, 1);
      caml_enter_blocking_section_hook();
    }
    else
    {
      caml_record_signal(a1);
    }
  }
}
// 6586B0: using guessed type __int64 (*caml_enter_blocking_section_hook)(void);
// 6586C0: using guessed type __int64 (*caml_try_leave_blocking_section_hook)(void);

//----- (000000000042BEA0) ----------------------------------------------------
__int64 caml_garbage_collection()
{
  caml_young_limit = caml_young_start;
  if ( caml_young_start > (unsigned __int64)caml_young_ptr || caml_force_major_slice )
    caml_minor_collection();
  return caml_process_pending_signals();
}
// 658CA8: using guessed type int caml_force_major_slice;
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000042BEE0) ----------------------------------------------------
void __fastcall caml_ext_table_free(__int64 a1, int a2)
{
  __int64 v3; // r12
  int v4; // ebp
  void *v5; // rdi

  if ( a2 && *(int *)a1 > 0 )
  {
    v3 = 0LL;
    v4 = 0;
    do
    {
      ++v4;
      v5 = *(void **)(*(_QWORD *)(a1 + 8) + v3);
      v3 += 8LL;
      caml_stat_free(v5);
    }
    while ( *(_DWORD *)a1 > v4 );
  }
  caml_stat_free(*(void **)(a1 + 8));
}

//----- (000000000042BF30) ----------------------------------------------------
__int64 __fastcall caml_ext_table_add(void **a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // edx
  void *v4; // rdx
  int v5; // edx

  result = *(unsigned int *)a1;
  v3 = *((_DWORD *)a1 + 1);
  if ( (int)result >= v3 )
  {
    v5 = 2 * v3;
    *((_DWORD *)a1 + 1) = v5;
    v4 = caml_stat_resize(a1[1], 8LL * v5);
    a1[1] = v4;
    result = *(unsigned int *)a1;
  }
  else
  {
    v4 = a1[1];
  }
  ++*(_DWORD *)a1;
  *((_QWORD *)v4 + (int)result) = a2;
  return result;
}

//----- (000000000042BFA0) ----------------------------------------------------
void *__fastcall caml_ext_table_init(__int64 a1, int a2)
{
  void *result; // rax

  *(_DWORD *)(a1 + 4) = a2;
  *(_DWORD *)a1 = 0;
  result = caml_stat_alloc(8LL * a2);
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

//----- (000000000042BFD0) ----------------------------------------------------
unsigned __int64 __fastcall caml_aligned_malloc(__int64 a1, int a2, _QWORD *a3)
{
  void *v4; // rdx
  unsigned __int64 result; // rax

  v4 = malloc(a1 + 4096);
  result = 0LL;
  if ( v4 )
  {
    *a3 = v4;
    return (((unsigned __int64)v4 + a2) & 0xFFFFFFFFFFFFF000LL) + 4096 - a2;
  }
  return result;
}

//----- (000000000042C030) ----------------------------------------------------
void __fastcall __noreturn caml_fatal_error_arg2(const char *a1, __int64 a2, const char *a3, __int64 a4)
{
  __fprintf_chk(stderr, 1LL, a1, a2);
  __fprintf_chk(stderr, 1LL, a3, a4);
  exit(2);
}
// 40A438: using guessed type __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...);

//----- (000000000042C080) ----------------------------------------------------
void __fastcall __noreturn caml_fatal_error_arg(const char *a1, __int64 a2)
{
  __fprintf_chk(stderr, 1LL, a1, a2);
  exit(2);
}
// 40A438: using guessed type __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...);

//----- (000000000042C0B0) ----------------------------------------------------
void __fastcall __noreturn caml_fatal_error(const char *a1)
{
  __fprintf_chk(stderr, 1LL, "%s", a1);
  exit(2);
}
// 40A438: using guessed type __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...);

//----- (000000000042C0E0) ----------------------------------------------------
int __fastcall caml_gc_message(int a1, const char *a2, __int64 a3)
{
  int result; // eax

  if ( a1 < 0 || (a1 & (unsigned __int64)caml_verb_gc) != 0 )
  {
    __fprintf_chk(stderr, 1LL, a2, a3);
    return fflush(stderr);
  }
  return result;
}
// 40A438: using guessed type __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...);
// 65ACE0: using guessed type __int64 caml_verb_gc;

//----- (000000000042C130) ----------------------------------------------------
__int64 *__fastcall allocate_block(__int64 a1, int a2, __int64 *a3, __int64 *a4)
{
  unsigned __int64 v4; // rax
  bool v5; // zf
  __int64 v6; // r8
  __int64 v7; // rax
  int v9; // er9

  v4 = (unsigned __int64)*(a4 - 1) >> 10;
  if ( v4 >= a1 + 1 )
  {
    v7 = v4 - a1;
    caml_fl_cur_size -= a1;
    *(a4 - 1) = (v7 << 10) + 512;
    v6 = caml_allocation_policy;
LABEL_7:
    if ( !v6 )
      fl_prev = a3;
    return &a4[v7];
  }
  caml_fl_cur_size += ~v4;
  v5 = caml_fl_merge == a4;
  *a3 = *a4;
  if ( v5 )
    caml_fl_merge = a3;
  *(a4 - 1) = 0LL;
  v6 = caml_allocation_policy;
  if ( caml_allocation_policy != 1 )
  {
    v7 = v4 - a1;
    goto LABEL_7;
  }
  v9 = a2 + 1;
  if ( a2 + 1 < flp_size && (__int64 *)flp[v9] == a4 )
  {
    flp[v9] = (__int64)a3;
    v7 = v4 - a1;
    return &a4[v7];
  }
  if ( flp_size - 1 == a2 )
  {
    flp_size = a2;
    if ( a3 == &qword_658710 )
      a3 = 0LL;
    beyond = (__int64)a3;
  }
  return &a4[v4 - a1];
}
// 6586E0: using guessed type __int64 *caml_fl_merge;
// 658710: using guessed type __int64 qword_658710;
// 658720: using guessed type __int64 *fl_prev;
// 65AD00: using guessed type __int64 caml_fl_cur_size;
// 65AD08: using guessed type __int64 caml_allocation_policy;
// 65AD10: using guessed type int flp_size;
// 65AD18: using guessed type __int64 beyond;
// 65AD40: using guessed type __int64 flp[];

//----- (000000000042C230) ----------------------------------------------------
void caml_fl_init_merge()
{
  last_fragment = 0LL;
  caml_fl_merge = &qword_658710;
}
// 6586E0: using guessed type __int64 *caml_fl_merge;
// 658710: using guessed type __int64 qword_658710;
// 65CC80: using guessed type __int64 last_fragment;

//----- (000000000042C250) ----------------------------------------------------
__int64 caml_fl_reset()
{
  __int64 result; // rax

  result = caml_allocation_policy;
  qword_658710 = 0LL;
  if ( caml_allocation_policy )
  {
    if ( caml_allocation_policy == 1 )
    {
      flp_size = 0;
      beyond = 0LL;
    }
  }
  else
  {
    fl_prev = &qword_658710;
  }
  caml_fl_cur_size = 0LL;
  last_fragment = 0LL;
  caml_fl_merge = &qword_658710;
  return result;
}
// 6586E0: using guessed type __int64 *caml_fl_merge;
// 658710: using guessed type __int64 qword_658710;
// 658720: using guessed type __int64 *fl_prev;
// 65AD00: using guessed type __int64 caml_fl_cur_size;
// 65AD08: using guessed type __int64 caml_allocation_policy;
// 65AD10: using guessed type int flp_size;
// 65AD18: using guessed type __int64 beyond;
// 65CC80: using guessed type __int64 last_fragment;

//----- (000000000042C2C0) ----------------------------------------------------
__int64 *__fastcall caml_fl_merge_block(__int64 *a1)
{
  unsigned __int64 v1; // r9
  __int64 *v2; // rdx
  unsigned __int64 v3; // r8
  __int64 *v4; // r10
  __int64 *v5; // rcx
  __int64 *v6; // r11
  __int64 *result; // rax
  unsigned __int64 v8; // rsi
  int v9; // eax
  unsigned __int64 v10; // rax
  __int64 v11; // rbx
  unsigned __int64 v12; // rsi
  bool v13; // zf
  unsigned __int64 v14; // rsi

  v1 = *(a1 - 1);
  v2 = caml_fl_merge;
  v3 = v1 >> 10;
  v4 = (__int64 *)*caml_fl_merge;
  caml_fl_cur_size += (v1 >> 10) + 1;
  if ( caml_allocation_policy != 1 )
    goto LABEL_2;
  if ( caml_fl_merge == &qword_658710 )
  {
    flp_size = 0;
    beyond = 0LL;
    goto LABEL_2;
  }
  if ( flp_size <= 0 || (v9 = flp_size - 1, (unsigned __int64)caml_fl_merge > *(_QWORD *)flp[flp_size - 1]) )
  {
LABEL_18:
    if ( (unsigned __int64)caml_fl_merge > beyond )
      goto LABEL_2;
LABEL_19:
    v5 = a1 - 1;
    beyond = 0LL;
    if ( a1 - 1 != (__int64 *)last_fragment )
      goto LABEL_3;
    goto LABEL_20;
  }
  while ( 1 )
  {
    if ( !v9 )
    {
      flp_size = 0;
      goto LABEL_18;
    }
    if ( (unsigned __int64)caml_fl_merge > *(_QWORD *)flp[v9 - 1] )
      break;
    --v9;
  }
  flp_size = v9;
  if ( (unsigned __int64)caml_fl_merge <= beyond )
    goto LABEL_19;
LABEL_2:
  v5 = a1 - 1;
  if ( a1 - 1 != (__int64 *)last_fragment )
  {
LABEL_3:
    v6 = v5;
    v5 = a1;
    goto LABEL_4;
  }
LABEL_20:
  v10 = ((unsigned __int64)*(a1 - 1) >> 10) + 1;
  if ( v10 > 0x3FFFFFFFFFFFFFLL )
    goto LABEL_3;
  v6 = a1 - 2;
  v1 = v10 << 10;
  *(v5 - 1) = v10 << 10;
  ++caml_fl_cur_size;
  v3 = v10 & 0x3FFFFFFFFFFFFFLL;
LABEL_4:
  result = v4 - 1;
  if ( v4 - 1 == &v5[v3] )
  {
    v11 = *v4;
    v12 = v3 + ((unsigned __int64)*(v4 - 1) >> 10) + 1;
    if ( v12 <= 0x3FFFFFFFFFFFFFLL )
    {
      v13 = caml_allocation_policy == 0;
      *v2 = v11;
      if ( v13 && fl_prev == v4 )
        fl_prev = v2;
      v4 = (__int64 *)v11;
      v1 = (v12 << 10) + 512;
      *(v5 - 1) = v1;
      v3 = v1 >> 10;
      result = &v5[v1 >> 10];
    }
  }
  else
  {
    result = &v5[v3];
  }
  v8 = (unsigned __int64)*(v2 - 1) >> 10;
  if ( v6 == &v2[v8] && (v14 = v3 + v8 + 1, v14 <= 0x3FFFFFFFFFFFFELL) )
  {
    *(v2 - 1) = (v14 << 10) + 512;
  }
  else if ( v3 )
  {
    *v5 = (__int64)v4;
    *v2 = (__int64)v5;
    caml_fl_merge = v5;
    *(v5 - 1) = v1 & 0xFFFFFFFFFFFFFCFFLL | 0x200;
  }
  else
  {
    last_fragment = (__int64)v5;
    --caml_fl_cur_size;
  }
  return result;
}
// 6586E0: using guessed type __int64 *caml_fl_merge;
// 658710: using guessed type __int64 qword_658710;
// 658720: using guessed type __int64 *fl_prev;
// 65AD00: using guessed type __int64 caml_fl_cur_size;
// 65AD08: using guessed type __int64 caml_allocation_policy;
// 65AD10: using guessed type int flp_size;
// 65AD18: using guessed type __int64 beyond;
// 65AD40: using guessed type __int64 flp[];
// 65CC80: using guessed type __int64 last_fragment;

//----- (000000000042C520) ----------------------------------------------------
__int64 __fastcall caml_fl_add_blocks(__int64 *a1)
{
  __int64 result; // rax
  bool v2; // zf
  __int64 *v3; // rdx
  __int64 *v4; // rcx
  __int64 *v5; // rsi
  int v6; // edx

  caml_fl_cur_size += ((unsigned __int64)*(a1 - 1) >> 10) + 1;
  result = fl_last;
  if ( (unsigned __int64)a1 <= fl_last )
  {
    v3 = (__int64 *)qword_658710;
    if ( (unsigned __int64)a1 > qword_658710 && qword_658710 )
    {
      while ( 1 )
      {
        v4 = v3;
        if ( (unsigned __int64)a1 <= *v3 || !*v3 )
          break;
        v3 = (__int64 *)*v3;
      }
      v5 = v3;
      v3 = (__int64 *)*v3;
    }
    else
    {
      v4 = &qword_658710;
      v5 = &qword_658710;
    }
    v2 = v5 == caml_fl_merge;
    result = a1[1];
    *(_QWORD *)result = v3;
    *v4 = (__int64)a1;
    if ( v2 && (unsigned __int64)a1 < caml_gc_sweep_hp )
      caml_fl_merge = (__int64 *)result;
    if ( caml_allocation_policy == 1 )
    {
      if ( a1 == &qword_658710 )
      {
        flp_size = 0;
        beyond = 0LL;
      }
      else
      {
        result = (unsigned int)flp_size;
        if ( flp_size > 0 )
        {
          result = (unsigned int)(flp_size - 1);
          if ( (unsigned __int64)a1 <= *(_QWORD *)flp[(int)result] )
          {
            while ( 1 )
            {
              if ( !(_DWORD)result )
              {
                flp_size = 0;
                goto LABEL_19;
              }
              if ( (unsigned __int64)a1 > *(_QWORD *)flp[(int)result - 1] )
                break;
              result = (unsigned int)(result - 1);
            }
            flp_size = result;
          }
        }
LABEL_19:
        if ( (unsigned __int64)a1 <= beyond )
          beyond = 0LL;
      }
    }
  }
  else
  {
    v2 = fl_last == (_QWORD)caml_fl_merge;
    *(_QWORD *)fl_last = a1;
    if ( v2 && (unsigned __int64)a1 < caml_gc_sweep_hp )
      caml_fl_merge = (__int64 *)a1[1];
    if ( caml_allocation_policy == 1 )
    {
      v6 = flp_size;
      if ( flp_size <= 999 )
      {
        flp[flp_size] = result;
        flp_size = v6 + 1;
      }
    }
  }
  return result;
}
// 6586E0: using guessed type __int64 *caml_fl_merge;
// 658710: using guessed type __int64 qword_658710;
// 65AD00: using guessed type __int64 caml_fl_cur_size;
// 65AD08: using guessed type __int64 caml_allocation_policy;
// 65AD10: using guessed type int flp_size;
// 65AD18: using guessed type __int64 beyond;
// 65AD20: using guessed type __int64 fl_last;
// 65AD40: using guessed type __int64 flp[];
// 663390: using guessed type __int64 caml_gc_sweep_hp;

//----- (000000000042C700) ----------------------------------------------------
__int64 *__fastcall caml_make_free_blocks(__int64 **a1, unsigned __int64 a2, int a3)
{
  unsigned __int64 v4; // rbp
  __int64 v6; // r12
  __int64 *result; // rax

  v4 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      v6 = 0x40000000000000LL;
      if ( v4 <= 0x40000000000000LL )
        v6 = v4;
      result = (__int64 *)((v6 - 1) << 10);
      *a1 = result;
      if ( a3 )
      {
        result = caml_fl_merge_block((__int64 *)a1 + 1);
        v4 -= v6;
        if ( !v4 )
          return result;
      }
      else
      {
        v4 -= v6;
        if ( !v4 )
          return result;
      }
      a1 += v6;
    }
  }
  return result;
}

//----- (000000000042C770) ----------------------------------------------------
void __fastcall caml_set_allocation_policy(__int64 a1)
{
  if ( !a1 )
  {
    fl_prev = &qword_658710;
LABEL_3:
    caml_allocation_policy = a1;
    return;
  }
  if ( a1 != 1 )
    goto LABEL_3;
  flp_size = 0;
  beyond = 0LL;
  caml_allocation_policy = 1LL;
}
// 658710: using guessed type __int64 qword_658710;
// 658720: using guessed type __int64 *fl_prev;
// 65AD08: using guessed type __int64 caml_allocation_policy;
// 65AD10: using guessed type int flp_size;
// 65AD18: using guessed type __int64 beyond;

//----- (000000000042C7C0) ----------------------------------------------------
__int64 *__fastcall caml_fl_allocate(unsigned __int64 a1)
{
  __int64 *v1; // rdx
  __int64 *v2; // rcx
  __int64 *v3; // rbx
  __int64 *v4; // rax
  __int64 *v5; // rcx
  __int64 *v6; // r13
  int v8; // esi
  __int64 *v9; // rdx
  int v10; // ebp
  __int64 **v11; // rax
  __int64 *v12; // rcx
  unsigned __int64 v13; // rbx
  unsigned __int64 v14; // rax
  __int64 v15; // rax
  __int64 *v16; // rdx
  __int64 *v17; // rax
  unsigned __int64 v18; // rbx
  __int64 *block; // rax
  int v20; // er8
  unsigned __int64 v21; // rsi
  int v22; // er9
  int v23; // er12
  _QWORD *v24; // rdx
  __int64 v25; // rdi
  _QWORD *v26; // rcx
  unsigned __int64 v27; // rax
  __int64 v28; // rsi
  __int64 v29[1005]; // [rsp+0h] [rbp-1F68h] BYREF

  if ( caml_allocation_policy )
  {
    if ( caml_allocation_policy != 1 )
      return 0LL;
    v8 = flp_size;
    if ( flp_size <= 0 )
    {
      if ( !flp_size )
      {
        v9 = &qword_658710;
        v14 = 0LL;
        goto LABEL_22;
      }
    }
    else
    {
      v9 = (__int64 *)flp[0];
      v10 = 0;
      v11 = (__int64 **)&unk_65AD48;
      v12 = *(__int64 **)flp[0];
      v13 = *(_QWORD *)(*(_QWORD *)flp[0] - 8LL) >> 10;
      if ( a1 <= v13 )
      {
LABEL_39:
        block = allocate_block(a1 + 1, v10, v9, v12);
        v20 = flp_size;
        v6 = block;
        if ( v10 < flp_size )
        {
          v21 = 0LL;
          if ( v10 > 0 )
            v21 = *(_QWORD *)(*(_QWORD *)flp[v10 - 1] - 8LL) >> 10;
          v22 = flp_size - 1;
          if ( flp_size - 1 == v10 )
          {
            if ( v21 < *(_QWORD *)(*(_QWORD *)flp[v10] - 8LL) >> 10 )
            {
              beyond = 0LL;
            }
            else
            {
              beyond = *(_QWORD *)flp[v10];
              flp_size = v10;
            }
          }
          else
          {
            v23 = 0;
            v24 = (_QWORD *)flp[v10];
            v25 = flp[v10 + 1];
            while ( v24 != (_QWORD *)v25 )
            {
              v26 = (_QWORD *)*v24;
              v27 = *(_QWORD *)(*v24 - 8LL) >> 10;
              if ( v21 < v27 )
              {
                v28 = v23++;
                v29[v28] = (__int64)v24;
                if ( v13 <= v27 )
                  break;
                v21 = v27;
              }
              v24 = v26;
            }
            if ( v23 + v20 <= 1001 )
            {
              if ( v23 == 1 || (memmove(&flp[v23 + v10], (char *)&unk_65AD48 + 8 * v10, 8LL * (v22 - v10)), v23) )
                memmove(&flp[v10], v29, 8LL * v23);
              flp_size = v23 + flp_size - 1;
            }
            else
            {
              if ( v23 + v10 > 999 )
              {
                if ( v10 != 1000 )
                  memmove(&flp[v10], v29, 8LL * (1000 - v10));
              }
              else if ( v23 == 1
                     || (memmove(&flp[v23 + v10], (char *)&unk_65AD48 + 8 * v10, 8LL * (1000 - v10 - v23)), v23) )
              {
                memmove(&flp[v10], v29, 8LL * v23);
              }
              flp_size = 999;
              beyond = *(_QWORD *)qword_65CC78;
            }
          }
        }
        return v6;
      }
      while ( ++v10 < flp_size )
      {
        v9 = *v11++;
        v12 = (__int64 *)*v9;
        v13 = *(_QWORD *)(*v9 - 8) >> 10;
        if ( a1 <= v13 )
          goto LABEL_39;
      }
    }
    v9 = *(__int64 **)flp[flp_size - 1];
    v14 = (unsigned __int64)*(v9 - 1) >> 10;
    if ( beyond )
      v9 = (__int64 *)beyond;
LABEL_22:
    v10 = flp_size;
    v12 = 0LL;
    while ( v8 <= 999 )
    {
      v12 = (__int64 *)*v9;
      if ( !*v9 )
      {
        fl_last = (__int64)v9;
        flp_size = v8;
        if ( v9 == &qword_658710 )
          v9 = 0LL;
        v6 = 0LL;
        beyond = (__int64)v9;
        return v6;
      }
      v13 = (unsigned __int64)*(v12 - 1) >> 10;
      if ( v14 < v13 )
      {
        v15 = v8++;
        flp[v15] = (__int64)v9;
        if ( a1 <= v13 )
        {
          flp_size = v8;
          beyond = (__int64)v12;
          goto LABEL_39;
        }
        v14 = v13;
      }
      v9 = v12;
      v10 = v8;
    }
    flp_size = v8;
    beyond = (__int64)v12;
    v16 = v12;
    if ( !v12 )
      v16 = (__int64 *)flp[v8 - 1];
    v17 = (__int64 *)*v16;
    if ( *v16 )
    {
      while ( 1 )
      {
        v18 = (unsigned __int64)*(v17 - 1) >> 10;
        if ( *(_QWORD *)(*(_QWORD *)qword_65CC78 - 8LL) >> 10 <= v18 )
        {
          if ( a1 <= v18 )
          {
            beyond = (__int64)v12;
            return allocate_block(a1 + 1, v8, v16, v17);
          }
        }
        else
        {
          v12 = v17;
        }
        v16 = v17;
        if ( !*v17 )
        {
          beyond = (__int64)v12;
          break;
        }
        v17 = (__int64 *)*v17;
      }
    }
    fl_last = (__int64)v16;
    return 0LL;
  }
  v1 = fl_prev;
  v2 = (__int64 *)*fl_prev;
  v3 = fl_prev;
  if ( *fl_prev )
  {
    if ( a1 <= (unsigned __int64)*(v2 - 1) >> 10 )
      return allocate_block(a1 + 1, 0, v1, v2);
    while ( 1 )
    {
      v3 = v2;
      v2 = (__int64 *)*v2;
      if ( !v2 )
        break;
      if ( (unsigned __int64)*(v2 - 1) >> 10 >= a1 )
      {
        v1 = v3;
        return allocate_block(a1 + 1, 0, v1, v2);
      }
    }
  }
  v4 = &qword_658710;
  fl_last = (__int64)v3;
  v5 = (__int64 *)qword_658710;
  if ( fl_prev == &qword_658710 )
    return 0LL;
  while ( a1 > (unsigned __int64)*(v5 - 1) >> 10 )
  {
    v4 = v5;
    v5 = (__int64 *)*v5;
    if ( fl_prev == v4 )
      return 0LL;
  }
  return allocate_block(a1 + 1, 0, v4, v5);
}
// 658710: using guessed type __int64 qword_658710;
// 658720: using guessed type __int64 *fl_prev;
// 65AD08: using guessed type __int64 caml_allocation_policy;
// 65AD10: using guessed type int flp_size;
// 65AD18: using guessed type __int64 beyond;
// 65AD20: using guessed type __int64 fl_last;
// 65AD40: using guessed type __int64 flp[];
// 65CC78: using guessed type __int64 qword_65CC78;
// 42C7C0: using guessed type __int64 var_1F68[1005];

//----- (000000000042CC90) ----------------------------------------------------
__int64 __fastcall caml_init_major_heap(unsigned __int64 a1)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  void *v4; // rax
  __int64 v5; // rdx
  void *v6; // rax
  __int64 result; // rax

  v2 = 0x2000LL;
  v3 = 0x2000LL;
  if ( a1 > 0x1FFF )
  {
    v2 = (a1 + 4095) & 0xFFFFFFFFFFFFF000LL;
    v3 = v2;
  }
  caml_stat_heap_size = v3;
  caml_stat_top_heap_size = v3;
  v4 = (void *)caml_alloc_for_heap(v2);
  caml_heap_start = v4;
  if ( !v4 )
    caml_fatal_error("Fatal error: not enough memory for the initial heap.\n");
  v5 = (__int64)v4 + caml_stat_heap_size;
  *((_QWORD *)v4 - 1) = 0LL;
  caml_stat_heap_chunks = 1LL;
  if ( (unsigned int)caml_page_table_add(1, (__int64)v4, v5) )
    caml_fatal_error("Fatal error: not enough memory for the initial page table.\n");
  caml_fl_init_merge();
  caml_make_free_blocks((__int64 **)caml_heap_start, (unsigned __int64)caml_stat_heap_size >> 3, 1);
  caml_gc_phase = 2;
  gray_vals_size = 2048LL;
  v6 = malloc(0x4000uLL);
  gray_vals = v6;
  if ( !v6 )
    caml_fatal_error("Fatal error: not enough memory for the gray cache.\n");
  gray_vals_cur = (__int64)v6;
  heap_is_pure = 1;
  caml_allocated_words = 0LL;
  caml_extra_heap_resources = 0LL;
  result = (__int64)v6 + 8 * gray_vals_size;
  gray_vals_end = result;
  return result;
}
// 65CC98: using guessed type __int64 gray_vals_cur;
// 65CCA0: using guessed type __int64 gray_vals_end;
// 65CCA8: using guessed type __int64 gray_vals_size;
// 65CCB0: using guessed type int heap_is_pure;
// 662760: using guessed type __int64 caml_stat_heap_size;
// 662768: using guessed type __int64 caml_stat_top_heap_size;
// 662778: using guessed type __int64 caml_stat_heap_chunks;
// 6633B0: using guessed type int caml_gc_phase;
// 6633B8: using guessed type __int64 caml_extra_heap_resources;
// 6633C0: using guessed type __int64 caml_allocated_words;

//----- (000000000042CDC0) ----------------------------------------------------
unsigned __int64 __fastcall caml_round_heap_chunk_size(unsigned __int64 a1)
{
  unsigned __int64 v1; // rdx
  unsigned __int64 result; // rax

  v1 = caml_major_heap_increment;
  result = 0x2000LL;
  if ( a1 >= caml_major_heap_increment )
    v1 = a1;
  if ( v1 > 0x1FFF )
    result = (v1 + 4095) & 0xFFFFFFFFFFFFF000LL;
  if ( a1 > result )
    caml_raise_out_of_memory();
  return result;
}
// 6633C8: using guessed type __int64 caml_major_heap_increment;

//----- (000000000042CE00) ----------------------------------------------------
__int64 (__fastcall *start_cycle())(_QWORD)
{
  __int64 (__fastcall *result)(_QWORD); // rax

  caml_gc_message(1, "Starting new major GC cycle\n", 0LL);
  result = caml_darken_all_roots();
  caml_gc_phase = 0;
  caml_gc_subphase = 10;
  markhp = 0LL;
  return result;
}
// 65CCB8: using guessed type __int64 markhp;
// 663388: using guessed type int caml_gc_subphase;
// 6633B0: using guessed type int caml_gc_phase;

//----- (000000000042CE40) ----------------------------------------------------
__int64 realloc_gray_vals()
{
  __int64 result; // rax
  void *v1; // rax

  result = caml_stat_heap_size / 128;
  if ( caml_stat_heap_size / 128 > (unsigned __int64)gray_vals_size )
  {
    caml_gc_message(8, "Growing gray_vals to %luk bytes\n", (unsigned __int64)(8 * gray_vals_size) >> 9);
    v1 = realloc(gray_vals, 16 * gray_vals_size);
    if ( v1 )
    {
      gray_vals = v1;
      gray_vals_cur = (__int64)v1 + 8 * gray_vals_size;
      result = (__int64)v1 + 16 * gray_vals_size;
      gray_vals_size *= 2LL;
      gray_vals_end = result;
    }
    else
    {
      caml_gc_message(8, "No room for growing gray_vals\n", 0LL);
      result = (__int64)gray_vals;
      heap_is_pure = 0;
      gray_vals_cur = (__int64)gray_vals;
    }
  }
  else
  {
    heap_is_pure = 0;
    gray_vals_cur = (__int64)gray_vals + 8 * ((unsigned __int64)gray_vals_size >> 1);
  }
  return result;
}
// 65CC98: using guessed type __int64 gray_vals_cur;
// 65CCA0: using guessed type __int64 gray_vals_end;
// 65CCA8: using guessed type __int64 gray_vals_size;
// 65CCB0: using guessed type int heap_is_pure;
// 662760: using guessed type __int64 caml_stat_heap_size;

//----- (000000000042CF30) ----------------------------------------------------
void __fastcall mark_slice(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // r14
  __int64 v3; // r13
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r15
  unsigned __int64 v7; // rbp
  unsigned __int64 *v8; // r12
  unsigned __int64 v9; // rdx
  unsigned __int64 *v10; // rax
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  _QWORD *v13; // rax
  char v14; // al
  char v15; // al
  _QWORD *v16; // rax
  __int64 v17; // r13
  unsigned __int64 i; // r12
  unsigned __int64 v19; // rbp
  _QWORD *v20; // r15
  char v21; // al
  unsigned __int64 v22; // [rsp+8h] [rbp-50h]
  unsigned __int64 v23; // [rsp+10h] [rbp-48h]
  unsigned __int64 v24; // [rsp+18h] [rbp-40h]

  v1 = a1;
  caml_gc_message(64, "Marking %ld words\n", a1);
  caml_gc_message(64, "Subphase = %ld\n", caml_gc_subphase);
  v2 = (_QWORD *)gray_vals_cur;
  while ( v1 > 0 )
  {
    while ( gray_vals < v2 )
    {
      v3 = *--v2;
      v4 = *(_QWORD *)(*v2 - 8LL);
      v5 = v4;
      BYTE1(v5) = BYTE1(v4) | 3;
      v6 = v4 >> 10;
      *(_QWORD *)(*v2 - 8LL) = v5;
      if ( (unsigned __int8)v4 <= 0xFAu && v6 )
      {
        v7 = 0LL;
        do
        {
          while ( 1 )
          {
            v8 = *(unsigned __int64 **)(v3 + 8 * v7);
            if ( ((unsigned __int8)v8 & 1) == 0 && (caml_page_table_lookup(*(_QWORD *)(v3 + 8 * v7)) & 1) != 0 )
            {
              v9 = *(v8 - 1);
              if ( (unsigned __int8)v9 == 250 )
              {
                v12 = *v8;
                if ( (*v8 & 1) != 0
                  || (v22 = *(v8 - 1), v23 = *v8, v14 = caml_page_table_lookup(*v8), v9 = v22, v12 = v23, (v14 & 7) != 0)
                  && (v15 = *(_BYTE *)(v23 - 8), v15 != -6)
                  && v15 != -10
                  && v15 != -3 )
                {
                  *(_QWORD *)(v3 + 8 * v7) = v12;
                }
              }
              else if ( (unsigned __int8)v9 == 249 )
              {
                v8 -= v9 >> 10;
                v9 = *(v8 - 1);
              }
              if ( (v9 & 0x300) == 0 )
              {
                BYTE1(v9) = BYTE1(v9) & 0xFC | 1;
                *(v8 - 1) = v9;
                *v2++ = v8;
                if ( (unsigned __int64)v2 >= gray_vals_end )
                  break;
              }
            }
            if ( v6 <= ++v7 )
              goto LABEL_16;
          }
          ++v7;
          gray_vals_cur = (__int64)v2;
          realloc_gray_vals();
          v2 = (_QWORD *)gray_vals_cur;
        }
        while ( v6 > v7 );
      }
LABEL_16:
      v1 += ~v6;
      if ( v1 <= 0 )
        goto LABEL_17;
    }
    v10 = (unsigned __int64 *)markhp;
    if ( markhp )
    {
      if ( markhp == limit )
      {
        chunk = *(_QWORD *)(chunk - 8);
        v13 = (_QWORD *)chunk;
        if ( chunk )
          goto LABEL_32;
        markhp = 0LL;
      }
      else
      {
        v11 = *(_QWORD *)markhp;
        if ( (*(_QWORD *)markhp & 0x300LL) == 256 )
        {
          *v2++ = markhp + 8;
          v11 = *v10;
        }
        markhp = (__int64)&v10[(v11 >> 10) + 1];
      }
    }
    else if ( heap_is_pure )
    {
      if ( caml_gc_subphase == 11 )
      {
        v17 = *(_QWORD *)weak_prev;
        if ( *(_QWORD *)weak_prev )
        {
          v24 = *(_QWORD *)(v17 - 8) >> 10;
          if ( v24 > 1 )
          {
            for ( i = 1LL; i < v24; ++i )
            {
              v19 = *(_QWORD *)(v17 + 8 * i);
              if ( (void *)v19 != caml_weak_none && (v19 & 1) == 0 )
              {
                while ( (caml_page_table_lookup(v19) & 1) != 0 )
                {
                  v20 = (_QWORD *)(v19 - 8);
                  if ( *(_BYTE *)(v19 - 8) != 0xFA
                    || (v19 = *(_QWORD *)v19, (v19 & 1) != 0)
                    || (caml_page_table_lookup(v19) & 7) == 0
                    || (v21 = *(_BYTE *)(v19 - 8), v21 == -6)
                    || v21 == -10
                    || v21 == -3 )
                  {
                    if ( (*v20 & 0x300LL) == 0 )
                      *(_QWORD *)(v17 + 8 * i) = caml_weak_none;
                    break;
                  }
                  *(_QWORD *)(v17 + 8 * i) = v19;
                  if ( caml_weak_none == (void *)v19 )
                    break;
                }
              }
            }
          }
          weak_prev = v17;
          v1 += ~v24;
        }
        else
        {
          caml_gc_subphase = 12;
          weak_prev = (__int64)&caml_weak_list_head;
        }
      }
      else if ( caml_gc_subphase <= 11 )
      {
        if ( caml_gc_subphase == 10 )
        {
          caml_gc_subphase = 11;
          weak_prev = (__int64)&caml_weak_list_head;
        }
      }
      else if ( caml_gc_subphase == 12 )
      {
        v16 = *(_QWORD **)weak_prev;
        if ( *(_QWORD *)weak_prev )
        {
          if ( (*(v16 - 1) & 0x300LL) != 0 )
            weak_prev = *(_QWORD *)weak_prev;
          else
            *(_QWORD *)weak_prev = *v16;
          --v1;
        }
        else
        {
          gray_vals_cur = (__int64)v2;
          caml_final_update();
          v2 = (_QWORD *)gray_vals_cur;
          caml_gc_subphase = 13;
        }
      }
      else if ( caml_gc_subphase == 13 )
      {
        gray_vals_cur = (__int64)v2;
        caml_gc_sweep_hp = (__int64)caml_heap_start;
        caml_fl_init_merge();
        caml_gc_phase = 1;
        chunk = (__int64)caml_heap_start;
        caml_gc_sweep_hp = (__int64)caml_heap_start;
        limit = *(_QWORD *)(chunk - 16) + chunk;
        caml_fl_size_at_phase_change = caml_fl_cur_size;
        break;
      }
    }
    else
    {
      v13 = caml_heap_start;
      heap_is_pure = 1;
      chunk = (__int64)caml_heap_start;
LABEL_32:
      markhp = (__int64)v13;
      limit = (__int64)v13 + *(v13 - 2);
    }
  }
LABEL_17:
  gray_vals_cur = (__int64)v2;
}
// 658868: using guessed type void *caml_weak_none;
// 65AD00: using guessed type __int64 caml_fl_cur_size;
// 65CC88: using guessed type __int64 caml_fl_size_at_phase_change;
// 65CC98: using guessed type __int64 gray_vals_cur;
// 65CCA0: using guessed type __int64 gray_vals_end;
// 65CCB0: using guessed type int heap_is_pure;
// 65CCB8: using guessed type __int64 markhp;
// 65CCC0: using guessed type __int64 chunk;
// 65CCC8: using guessed type __int64 limit;
// 65CCD0: using guessed type __int64 weak_prev;
// 6627E8: using guessed type __int64 caml_weak_list_head;
// 663388: using guessed type int caml_gc_subphase;
// 663390: using guessed type __int64 caml_gc_sweep_hp;
// 6633B0: using guessed type int caml_gc_phase;

//----- (000000000042D3C0) ----------------------------------------------------
void __fastcall caml_darken(unsigned __int64 a1)
{
  unsigned __int64 v1; // rbx
  unsigned __int64 v2; // rax
  unsigned int v3; // edx
  __int64 v4; // rax

  v1 = a1;
  if ( (a1 & 1) == 0 && (caml_page_table_lookup(a1) & 1) != 0 )
  {
    v2 = *(_QWORD *)(a1 - 8);
    v3 = (unsigned __int8)v2;
    if ( (unsigned __int8)v2 == 249 )
    {
      v1 = a1 - 8 * (v2 >> 10);
      v2 = *(_QWORD *)(v1 - 8);
      v3 = (unsigned __int8)v2;
    }
    if ( (v2 & 0x300) == 0 )
    {
      if ( v3 > 0xFA )
      {
        BYTE1(v2) |= 3u;
        *(_QWORD *)(v1 - 8) = v2;
      }
      else
      {
        BYTE1(v2) = BYTE1(v2) & 0xFC | 1;
        *(_QWORD *)(v1 - 8) = v2;
        v4 = gray_vals_cur;
        *(_QWORD *)gray_vals_cur = v1;
        gray_vals_cur = v4 + 8;
        if ( v4 + 8 >= (unsigned __int64)gray_vals_end )
          realloc_gray_vals();
      }
    }
  }
}
// 65CC98: using guessed type __int64 gray_vals_cur;
// 65CCA0: using guessed type __int64 gray_vals_end;

//----- (000000000042D450) ----------------------------------------------------
int __fastcall sweep_slice(__int64 a1)
{
  __int64 v1; // rbx
  __int64 *v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rsi
  __int64 *v5; // rbp
  void (__fastcall *v6)(__int64 *); // rax

  v1 = a1;
  LODWORD(v2) = caml_gc_message(64, "Sweeping %ld words\n", a1);
LABEL_2:
  while ( 2 )
  {
    if ( v1 > 0 )
    {
      while ( 1 )
      {
        v2 = (__int64 *)caml_gc_sweep_hp;
        if ( caml_gc_sweep_hp >= (unsigned __int64)limit )
          break;
        v3 = *(_QWORD *)caml_gc_sweep_hp;
        v4 = *(_QWORD *)caml_gc_sweep_hp >> 10;
        caml_gc_sweep_hp += 8 * v4 + 8;
        v1 += ~v4;
        if ( (v3 & 0x300) != 0 )
        {
          if ( (v3 & 0x300) == 512 )
          {
            caml_fl_merge = ++v2;
          }
          else
          {
            BYTE1(v3) &= 0xFCu;
            *v2 = v3;
          }
          goto LABEL_2;
        }
        v5 = v2 + 1;
        if ( (_BYTE)v3 == 0xFF )
        {
          v6 = *(void (__fastcall **)(__int64 *))(v2[1] + 8);
          if ( v6 )
            v6(v5);
        }
        v2 = caml_fl_merge_block(v5);
        caml_gc_sweep_hp = (__int64)v2;
        if ( v1 <= 0 )
          return (int)v2;
      }
      chunk = *(_QWORD *)(chunk - 8);
      LODWORD(v2) = chunk;
      if ( chunk )
      {
        caml_gc_sweep_hp = chunk;
        v2 = (__int64 *)(*(_QWORD *)(chunk - 16) + chunk);
        limit = (__int64)v2;
        continue;
      }
      ++caml_stat_major_collections;
      caml_gc_phase = 2;
    }
    return (int)v2;
  }
}
// 6586E0: using guessed type __int64 *caml_fl_merge;
// 65CCC0: using guessed type __int64 chunk;
// 65CCC8: using guessed type __int64 limit;
// 662758: using guessed type __int64 caml_stat_major_collections;
// 663390: using guessed type __int64 caml_gc_sweep_hp;
// 6633B0: using guessed type int caml_gc_phase;

//----- (000000000042D580) ----------------------------------------------------
__int64 caml_finish_major_cycle()
{
  int v0; // eax
  __int64 result; // rax
  double v2; // xmm0_8

  v0 = caml_gc_phase;
  if ( caml_gc_phase == 2 )
  {
    start_cycle();
    v0 = caml_gc_phase;
  }
  while ( !v0 )
  {
    mark_slice(0x7FFFFFFFFFFFFFFFLL);
    v0 = caml_gc_phase;
  }
  if ( v0 == 1 )
  {
    do
      sweep_slice(0x7FFFFFFFFFFFFFFFLL);
    while ( caml_gc_phase == 1 );
  }
  result = caml_allocated_words;
  if ( caml_allocated_words < 0 )
  {
    result = caml_allocated_words & 1;
    v2 = (double)(int)(result | ((unsigned __int64)caml_allocated_words >> 1))
       + (double)(int)(result | ((unsigned __int64)caml_allocated_words >> 1));
  }
  else
  {
    v2 = (double)(int)caml_allocated_words;
  }
  caml_allocated_words = 0LL;
  *(double *)&caml_stat_major_words = v2 + *(double *)&caml_stat_major_words;
  return result;
}
// 662748: using guessed type __int64 caml_stat_major_words;
// 6633B0: using guessed type int caml_gc_phase;
// 6633C0: using guessed type __int64 caml_allocated_words;

//----- (000000000042D640) ----------------------------------------------------
__int64 __fastcall caml_major_collection_slice(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // ecx
  double v3; // xmm2_8
  double v4; // xmm1_8
  double v5; // xmm0_8
  double v6; // xmm0_8
  double v7; // xmm2_8
  double v8; // xmm3_8
  __int64 v9; // rdx
  double v10; // xmm1_8
  __int64 v11; // rdx
  __m128d v12; // xmm0
  int v13; // eax
  double v14; // xmm1_8
  __int64 v15; // rbp
  double v16; // xmm2_8
  double v17; // xmm3_8
  unsigned __int64 v18; // rax
  double v19; // xmm0_8
  __int64 result; // rax
  unsigned __int64 v21; // rsi
  unsigned __int64 v22; // rdx
  double v23; // [rsp+0h] [rbp-48h]

  v1 = a1;
  if ( caml_gc_phase == 2 )
    start_cycle();
  v2 = caml_percent_free + 100;
  if ( caml_percent_free + 100 < 0 )
  {
    v21 = v2 & 1 | ((unsigned __int64)(caml_percent_free + 100) >> 1);
    v3 = (double)(int)v21 + (double)(int)v21;
  }
  else
  {
    v3 = (double)v2;
  }
  if ( caml_percent_free < 0 )
    v4 = (double)(int)(caml_percent_free & 1 | ((unsigned __int64)caml_percent_free >> 1))
       + (double)(int)(caml_percent_free & 1 | ((unsigned __int64)caml_percent_free >> 1));
  else
    v4 = (double)(int)caml_percent_free;
  if ( caml_allocated_words < 0 )
    v5 = (double)(int)(caml_allocated_words & 1 | ((unsigned __int64)caml_allocated_words >> 1))
       + (double)(int)(caml_allocated_words & 1 | ((unsigned __int64)caml_allocated_words >> 1));
  else
    v5 = (double)(int)caml_allocated_words;
  v6 = v5 * 3.0 * v3 / (double)(int)((unsigned __int64)caml_stat_heap_size >> 3) / v4 * 0.5;
  if ( !caml_dependent_size )
  {
    v7 = 0.0;
    goto LABEL_11;
  }
  if ( caml_dependent_allocated < 0 )
  {
    v16 = v3
        * ((double)(int)(caml_dependent_allocated & 1 | ((unsigned __int64)caml_dependent_allocated >> 1))
         + (double)(int)(caml_dependent_allocated & 1 | ((unsigned __int64)caml_dependent_allocated >> 1)));
    if ( caml_dependent_size >= 0 )
      goto LABEL_21;
LABEL_40:
    v17 = (double)(int)(caml_dependent_size & 1 | ((unsigned __int64)caml_dependent_size >> 1))
        + (double)(int)(caml_dependent_size & 1 | ((unsigned __int64)caml_dependent_size >> 1));
    goto LABEL_22;
  }
  v16 = v3 * (double)(int)caml_dependent_allocated;
  if ( caml_dependent_size < 0 )
    goto LABEL_40;
LABEL_21:
  v17 = (double)(int)caml_dependent_size;
LABEL_22:
  v7 = v16 / v17 / v4;
LABEL_11:
  v23 = fmax(*(double *)&caml_extra_heap_resources, fmax(v7, v6));
  caml_gc_message(64, "allocated_words = %lu\n", caml_allocated_words);
  v8 = *(double *)&caml_extra_heap_resources * 1000000.0;
  if ( *(double *)&caml_extra_heap_resources * 1000000.0 >= 9.223372036854776e18 )
    v9 = (unsigned int)(int)(v8 - 9.223372036854776e18) ^ 0x8000000000000000LL;
  else
    v9 = (unsigned int)(int)v8;
  caml_gc_message(64, "extra_heap_resources = %luu\n", v9);
  v10 = 1000000.0 * v23;
  if ( 1000000.0 * v23 >= 9.223372036854776e18 )
    v11 = (unsigned int)(int)(v10 - 9.223372036854776e18) ^ 0x8000000000000000LL;
  else
    v11 = (unsigned int)(int)v10;
  caml_gc_message(64, "amount of work to do = %luu\n", v11);
  v12 = (__m128d)*(unsigned __int64 *)&v23;
  if ( caml_gc_phase )
  {
    v14 = (double)(int)((unsigned __int64)caml_stat_heap_size >> 3) * v23 * 5.0 / 3.0;
    v15 = (unsigned int)(int)v14;
  }
  else
  {
    v13 = caml_percent_free + 100;
    if ( caml_percent_free + 100 < 0 )
    {
      v22 = v13 & 1 | ((unsigned __int64)(caml_percent_free + 100) >> 1);
      v12.m128d_f64[0] = (double)(int)v22 + (double)(int)v22;
    }
    else
    {
      v12.m128d_f64[0] = (double)v13;
    }
    v14 = (double)(int)((unsigned __int64)caml_stat_heap_size >> 3) * v23 * 250.0 / v12.m128d_f64[0];
    v15 = (unsigned int)(int)v14;
  }
  caml_gc_message(64, "ordered work = %ld words\n", a1);
  caml_gc_message(64, "computed work = %ld words\n", v15);
  if ( !a1 )
    v1 = v15;
  if ( !caml_gc_phase )
  {
    mark_slice(v1);
    caml_gc_message(2, "!", 0LL);
    if ( caml_gc_phase != 2 )
      goto LABEL_28;
LABEL_34:
    caml_compact_heap_maybe(v12, v14, (__m128)0x43E0000000000000uLL);
    v18 = caml_allocated_words;
    if ( caml_allocated_words >= 0 )
      goto LABEL_29;
LABEL_35:
    v19 = (double)(int)(v18 & 1 | (v18 >> 1)) + (double)(int)(v18 & 1 | (v18 >> 1));
    goto LABEL_30;
  }
  sweep_slice(v1);
  caml_gc_message(2, "$", 0LL);
  if ( caml_gc_phase == 2 )
    goto LABEL_34;
LABEL_28:
  v18 = caml_allocated_words;
  if ( caml_allocated_words < 0 )
    goto LABEL_35;
LABEL_29:
  v19 = (double)(int)v18;
LABEL_30:
  caml_allocated_words = 0LL;
  result = v15;
  caml_dependent_allocated = 0LL;
  caml_extra_heap_resources = 0LL;
  *(double *)&caml_stat_major_words = v19 + *(double *)&caml_stat_major_words;
  return result;
}
// 662748: using guessed type __int64 caml_stat_major_words;
// 662760: using guessed type __int64 caml_stat_heap_size;
// 663398: using guessed type __int64 caml_percent_free;
// 6633A0: using guessed type __int64 caml_dependent_size;
// 6633B0: using guessed type int caml_gc_phase;
// 6633B8: using guessed type __int64 caml_extra_heap_resources;
// 6633C0: using guessed type __int64 caml_allocated_words;
// 6633D0: using guessed type __int64 caml_dependent_allocated;

//----- (000000000042DA50) ----------------------------------------------------
void __fastcall caml_oldify_one(unsigned __int64 a1, _QWORD *a2)
{
  unsigned __int64 v4; // rbp
  _QWORD *v5; // r13
  unsigned int v6; // esi
  _QWORD *v7; // rbp
  unsigned __int64 v8; // rbp
  __int64 *v9; // rax
  unsigned __int64 v10; // rdx
  unsigned __int8 *v11; // rax
  int v12; // eax
  __int64 *v13; // rax
  unsigned __int64 v14; // rbp
  __int64 *v15; // rax
  unsigned __int64 i; // rdx
  __int64 v17; // rbp

  while ( 1 )
  {
    while ( 1 )
    {
      if ( (a1 & 1) != 0 || a1 >= caml_young_end || a1 <= caml_young_start )
      {
        *a2 = a1;
        return;
      }
      v4 = *(_QWORD *)(a1 - 8);
      v5 = (_QWORD *)(a1 - 8);
      if ( !v4 )
      {
        *a2 = *(_QWORD *)a1;
        return;
      }
      v6 = (unsigned __int8)v4;
      if ( (unsigned __int8)v4 > 0xF8u )
        break;
      v8 = v4 >> 10;
      v9 = caml_alloc_shr(v8, v6);
      *a2 = v9;
      v10 = *(_QWORD *)a1;
      *v5 = 0LL;
      *(_QWORD *)a1 = v9;
      if ( v8 > 1 )
      {
        *v9 = v10;
        v9[1] = oldify_todo_list;
        oldify_todo_list = a1;
        return;
      }
      a2 = v9;
      a1 = v10;
    }
    if ( (unsigned __int8)v4 > 0xFAu )
      break;
    if ( (unsigned __int8)v4 == 249 )
    {
      v17 = 8 * (v4 >> 10);
      caml_oldify_one(a1 - v17, a2);
      *a2 += v17;
      return;
    }
    v7 = *(_QWORD **)a1;
    if ( (*(_QWORD *)a1 & 1) != 0 )
      goto LABEL_10;
    if ( (caml_page_table_lookup(*(_QWORD *)a1) & 7) == 0 )
      goto LABEL_17;
    v11 = (unsigned __int8 *)(v7 - 1);
    if ( !*(v7 - 1) )
      v11 = (unsigned __int8 *)(*v7 - 8LL);
    v12 = *v11;
    if ( v12 == 250 || v12 == 253 || v12 == 246 )
    {
LABEL_17:
      v13 = caml_alloc_shr(1uLL, 0xFAu);
      *a2 = v13;
      *v5 = 0LL;
      a2 = v13;
      *(_QWORD *)a1 = v13;
      a1 = (unsigned __int64)v7;
    }
    else
    {
LABEL_10:
      a1 = (unsigned __int64)v7;
    }
  }
  v14 = v4 >> 10;
  v15 = caml_alloc_shr(v14, v6);
  if ( v14 )
  {
    for ( i = 0LL; i < v14; ++i )
      v15[i] = *(_QWORD *)(a1 + 8 * i);
  }
  *v5 = 0LL;
  *(_QWORD *)a1 = v15;
  *a2 = v15;
}
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CD80: using guessed type __int64 oldify_todo_list;

//----- (000000000042DC20) ----------------------------------------------------
unsigned __int64 caml_oldify_mopup()
{
  unsigned __int64 **v0; // rbp
  unsigned __int64 *v1; // rbx
  unsigned __int64 *v2; // r12
  unsigned __int64 v3; // rdi
  unsigned __int64 *v4; // r13
  unsigned __int64 result; // rax
  unsigned __int64 i; // rbx
  unsigned __int64 v7; // rdi

  while ( 1 )
  {
    v0 = (unsigned __int64 **)oldify_todo_list;
    if ( !oldify_todo_list )
      break;
    while ( 1 )
    {
      v1 = *v0;
      v2 = *v0 + 1;
      oldify_todo_list = *v2;
      v3 = *v1;
      if ( (*v1 & 1) == 0 && v3 < caml_young_end && v3 > caml_young_start )
        caml_oldify_one(v3, v1);
      v4 = v1 - 1;
      result = *(v1 - 1) >> 10;
      if ( result <= 1 )
        break;
      for ( i = 1LL; i < result; ++i )
      {
        v7 = (unsigned __int64)v0[i];
        if ( (v7 & 1) != 0 || v7 >= caml_young_end || v7 <= caml_young_start )
          *v2 = v7;
        else
          caml_oldify_one(v7, v2);
        ++v2;
        result = *v4 >> 10;
      }
      v0 = (unsigned __int64 **)oldify_todo_list;
      if ( !oldify_todo_list )
        return result;
    }
  }
  return result;
}
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CD80: using guessed type __int64 oldify_todo_list;

//----- (000000000042DD00) ----------------------------------------------------
__int64 caml_empty_minor_heap()
{
  unsigned __int64 **v0; // rbx
  unsigned __int64 *v1; // rax
  void *v2; // r8
  unsigned __int64 v3; // rbx
  _QWORD **v4; // rax
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rdi
  _QWORD *v7; // rcx
  _QWORD *v8; // rdx
  unsigned __int64 v9; // rax

  if ( caml_young_ptr != caml_young_end )
  {
    caml_in_minor_collection = 1;
    caml_gc_message(2, "<", 0LL);
    caml_oldify_local_roots();
    v0 = (unsigned __int64 **)caml_ref_table;
    if ( (unsigned __int64)caml_ref_table < qword_65CD18 )
    {
      do
      {
        v1 = *v0++;
        caml_oldify_one(*v1, v1);
      }
      while ( qword_65CD18 > (unsigned __int64)v0 );
    }
    caml_oldify_mopup();
    v2 = caml_weak_ref_table;
    v3 = qword_65CD58;
    v4 = (_QWORD **)caml_weak_ref_table;
    if ( (unsigned __int64)caml_weak_ref_table >= qword_65CD58 )
    {
      v5 = caml_young_end;
      v6 = caml_young_start;
    }
    else
    {
      v5 = caml_young_end;
      v6 = caml_young_start;
      do
      {
        v7 = *v4;
        v8 = (_QWORD *)**v4;
        if ( ((unsigned __int8)v8 & 1) == 0 && (unsigned __int64)v8 < v5 && (unsigned __int64)v8 > v6 )
        {
          if ( *(v8 - 1) )
            *v7 = caml_weak_none;
          else
            *v7 = *v8;
        }
        ++v4;
      }
      while ( v3 > (unsigned __int64)v4 );
    }
    v9 = caml_young_ptr;
    caml_young_ptr = v5;
    caml_young_limit = v6;
    qword_65CD58 = (__int64)v2;
    if ( v9 < v6 )
      v9 = v6;
    qword_65CD18 = (__int64)caml_ref_table;
    qword_65CD20 = qword_65CD10;
    qword_65CD60 = qword_65CD50;
    *(double *)&caml_stat_minor_words = (double)(int)((v5 - v9) >> 3) + *(double *)&caml_stat_minor_words;
    caml_gc_message(2, ">", 0LL);
    caml_in_minor_collection = 0;
  }
  return caml_final_empty_young();
}
// 658868: using guessed type void *caml_weak_none;
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 65CCF8: using guessed type __int64 caml_young_limit;
// 65CD10: using guessed type __int64 qword_65CD10;
// 65CD18: using guessed type __int64 qword_65CD18;
// 65CD20: using guessed type __int64 qword_65CD20;
// 65CD50: using guessed type __int64 qword_65CD50;
// 65CD58: using guessed type __int64 qword_65CD58;
// 65CD60: using guessed type __int64 qword_65CD60;
// 65CD78: using guessed type int caml_in_minor_collection;
// 662738: using guessed type __int64 caml_stat_minor_words;

//----- (000000000042DE80) ----------------------------------------------------
__int64 caml_minor_collection()
{
  __int64 v0; // rbx
  int v1; // eax
  double v2; // xmm0_8
  unsigned __int64 v4; // rdx

  v0 = caml_allocated_words;
  caml_empty_minor_heap();
  v1 = caml_allocated_words - v0;
  if ( caml_allocated_words - v0 < 0 )
  {
    v4 = v1 & 1 | ((unsigned __int64)(caml_allocated_words - v0) >> 1);
    v2 = (double)(int)v4 + (double)(int)v4;
  }
  else
  {
    v2 = (double)v1;
  }
  ++caml_stat_minor_collections;
  *(double *)&caml_stat_promoted_words = v2 + *(double *)&caml_stat_promoted_words;
  caml_major_collection_slice(0LL);
  caml_force_major_slice = 0;
  caml_final_do_calls();
  return caml_empty_minor_heap();
}
// 658CA8: using guessed type int caml_force_major_slice;
// 662740: using guessed type __int64 caml_stat_promoted_words;
// 662750: using guessed type __int64 caml_stat_minor_collections;
// 6633C0: using guessed type __int64 caml_allocated_words;

//----- (000000000042DEF0) ----------------------------------------------------
__int64 __fastcall caml_check_urgent_gc(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v3; // [rsp+8h] [rbp-50h] BYREF
  __int64 v4[9]; // [rsp+10h] [rbp-48h] BYREF

  v1 = caml_local_roots;
  v3 = a1;
  caml_local_roots = (__int64)v4;
  if ( caml_force_major_slice )
  {
    v4[0] = v1;
    v4[2] = 1LL;
    v4[1] = 1LL;
    v4[3] = (__int64)&v3;
    caml_minor_collection();
  }
  caml_local_roots = v1;
  return v3;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 658CA8: using guessed type int caml_force_major_slice;

//----- (000000000042DF50) ----------------------------------------------------
void __fastcall caml_set_minor_heap_size(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  __int64 v3; // r12
  void *v4; // [rsp+8h] [rbp-20h] BYREF

  if ( caml_young_ptr != caml_young_end )
    caml_minor_collection();
  v1 = caml_aligned_malloc(a1, 0, &v4);
  v2 = v1;
  if ( !v1 || (v3 = v1 + a1, (unsigned int)caml_page_table_add(2, v1, v1 + a1)) )
    caml_raise_out_of_memory();
  if ( caml_young_start )
  {
    caml_page_table_remove(2, caml_young_start, caml_young_end);
    free(caml_young_base);
  }
  caml_young_start = v2;
  caml_young_end = v3;
  caml_young_limit = v2;
  caml_young_ptr = v3;
  caml_young_base = v4;
  caml_minor_heap_size = a1;
  qword_65CD28 = 0LL;
  qword_65CD30 = 0LL;
  if ( caml_ref_table )
    caml_stat_free(caml_ref_table);
  qword_65CD08 = 0LL;
  qword_65CD20 = 0LL;
  qword_65CD10 = 0LL;
  qword_65CD18 = 0LL;
  caml_ref_table = 0LL;
  qword_65CD68 = 0LL;
  qword_65CD70 = 0LL;
  if ( caml_weak_ref_table )
    caml_stat_free(caml_weak_ref_table);
  qword_65CD48 = 0LL;
  qword_65CD60 = 0LL;
  qword_65CD50 = 0LL;
  qword_65CD58 = 0LL;
  caml_weak_ref_table = 0LL;
}
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 65CCF8: using guessed type __int64 caml_young_limit;
// 65CD08: using guessed type __int64 qword_65CD08;
// 65CD10: using guessed type __int64 qword_65CD10;
// 65CD18: using guessed type __int64 qword_65CD18;
// 65CD20: using guessed type __int64 qword_65CD20;
// 65CD28: using guessed type __int64 qword_65CD28;
// 65CD30: using guessed type __int64 qword_65CD30;
// 65CD48: using guessed type __int64 qword_65CD48;
// 65CD50: using guessed type __int64 qword_65CD50;
// 65CD58: using guessed type __int64 qword_65CD58;
// 65CD60: using guessed type __int64 qword_65CD60;
// 65CD68: using guessed type __int64 qword_65CD68;
// 65CD70: using guessed type __int64 qword_65CD70;
// 6633D8: using guessed type __int64 caml_minor_heap_size;

//----- (000000000042E0D0) ----------------------------------------------------
char *__fastcall caml_alloc_table(__int64 a1, __int64 a2, __int64 a3)
{
  char *v4; // rax
  void *v5; // rdi
  char *v6; // rbp
  __int64 v7; // rax
  char *v8; // rdx
  __int64 v9; // rax
  char *result; // rax

  *(_QWORD *)(a1 + 40) = a2;
  *(_QWORD *)(a1 + 48) = a3;
  v4 = (char *)caml_stat_alloc(8 * (a3 + a2));
  v5 = *(void **)a1;
  v6 = v4;
  if ( v5 )
    caml_stat_free(v5);
  v7 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + 24) = v6;
  v8 = &v6[8 * v7];
  v9 = *(_QWORD *)(a1 + 48) + v7;
  *(_QWORD *)(a1 + 16) = v8;
  *(_QWORD *)(a1 + 32) = v8;
  result = &v6[8 * v9];
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

//----- (000000000042E130) ----------------------------------------------------
char *__fastcall caml_realloc_ref_table(__int64 a1)
{
  void *v1; // rbp
  __int64 v2; // r12
  __int64 v3; // r13
  signed __int64 v4; // r13
  char *result; // rax
  __int64 v6; // rcx
  char *v7; // rdx

  v1 = *(void **)a1;
  if ( !*(_QWORD *)a1 )
    return caml_alloc_table(a1, (unsigned __int64)caml_minor_heap_size >> 6, 256LL);
  if ( *(_QWORD *)(a1 + 32) == *(_QWORD *)(a1 + 16) )
  {
    caml_gc_message(8, "ref_table threshold crossed\n", 0LL);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 8);
    return (char *)caml_urge_major_slice();
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 24);
    v3 = 2LL * *(_QWORD *)(a1 + 40);
    *(_QWORD *)(a1 + 40) = v3;
    v4 = 8 * (*(_QWORD *)(a1 + 48) + v3);
    caml_gc_message(8, "Growing ref_table to %ldk bytes\n", v4 / 1024);
    result = (char *)realloc(*(void **)a1, v4);
    *(_QWORD *)a1 = result;
    if ( !result )
      caml_fatal_error("Fatal error: ref_table overflow\n");
    v6 = *(_QWORD *)(a1 + 40);
    v7 = &result[8 * v6 + 8 * *(_QWORD *)(a1 + 48)];
    *(_QWORD *)(a1 + 24) = &result[(v2 - (_QWORD)v1) & 0xFFFFFFFFFFFFFFF8LL];
    *(_QWORD *)(a1 + 16) = &result[8 * v6];
    *(_QWORD *)(a1 + 8) = v7;
    *(_QWORD *)(a1 + 32) = v7;
  }
  return result;
}
// 6633D8: using guessed type __int64 caml_minor_heap_size;

//----- (000000000042E280) ----------------------------------------------------
__int64 __fastcall caml_page_table_lookup(unsigned __int64 a1)
{
  unsigned __int64 v1; // rdx
  __int64 result; // rax
  __int64 i; // rdx
  __int64 v4; // rdx

  v1 = (0x9E3779B97F4A7C16LL * (a1 >> 12)) >> dword_65CDA8;
  result = *((_QWORD *)ptr + v1);
  if ( ((a1 ^ result) & 0xFFFFFFFFFFFFF000LL) == 0 )
    return (unsigned __int8)result;
  if ( result )
  {
    for ( i = v1 + 1; ; i = v4 + 1 )
    {
      v4 = qword_65CDB0 & i;
      result = *((_QWORD *)ptr + v4);
      if ( ((a1 ^ result) & 0xFFFFFFFFFFFFF000LL) == 0 )
        break;
      if ( !result )
        return 0LL;
    }
    return (unsigned __int8)result;
  }
  return 0LL;
}
// 65CDA8: using guessed type int dword_65CDA8;
// 65CDB0: using guessed type __int64 qword_65CDB0;

//----- (000000000042E300) ----------------------------------------------------
__int64 __fastcall caml_allocation_color(unsigned __int64 a1)
{
  if ( caml_gc_phase && (caml_gc_phase != 1 || a1 < caml_gc_sweep_hp) )
    return 0LL;
  else
    return 768LL;
}
// 663390: using guessed type __int64 caml_gc_sweep_hp;
// 6633B0: using guessed type int caml_gc_phase;

//----- (000000000042E330) ----------------------------------------------------
void __fastcall caml_alloc_dependent_memory(unsigned __int64 a1)
{
  unsigned __int64 v1; // rdi

  v1 = a1 >> 3;
  caml_dependent_size += v1;
  caml_dependent_allocated += v1;
}
// 6633A0: using guessed type __int64 caml_dependent_size;
// 6633D0: using guessed type __int64 caml_dependent_allocated;

//----- (000000000042E350) ----------------------------------------------------
unsigned __int64 __fastcall caml_free_dependent_memory(unsigned __int64 a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 v2; // rdi

  result = caml_dependent_size;
  v2 = a1 >> 3;
  if ( v2 > caml_dependent_size )
  {
    caml_dependent_size = 0LL;
  }
  else
  {
    result = caml_dependent_size - v2;
    caml_dependent_size -= v2;
  }
  return result;
}
// 6633A0: using guessed type __int64 caml_dependent_size;

//----- (000000000042E380) ----------------------------------------------------
void *__fastcall caml_stat_resize(void *a1, size_t a2)
{
  void *result; // rax

  result = realloc(a1, a2);
  if ( !result )
    caml_raise_out_of_memory();
  return result;
}

//----- (000000000042E3B0) ----------------------------------------------------
void __fastcall caml_free_for_heap(__int64 a1)
{
  free(*(void **)(a1 - 32));
}

//----- (000000000042E3C0) ----------------------------------------------------
void *__fastcall caml_stat_alloc(size_t a1)
{
  void *result; // rax

  result = malloc(a1);
  if ( !result )
  {
    if ( a1 )
      caml_raise_out_of_memory();
  }
  return result;
}

//----- (000000000042E3E0) ----------------------------------------------------
void __fastcall caml_modify(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r12
  unsigned __int64 **v3; // rax

  v2 = *a1;
  *a1 = a2;
  if ( (caml_page_table_lookup((unsigned __int64)a1) & 1) != 0 )
  {
    if ( caml_gc_phase )
    {
      if ( (a2 & 1) != 0 )
        return;
    }
    else
    {
      caml_darken(v2);
      if ( (a2 & 1) != 0 )
        return;
    }
    if ( a2 < caml_young_end
      && a2 > caml_young_start
      && ((v2 & 1) != 0 || caml_young_end <= v2 || caml_young_start >= v2) )
    {
      v3 = (unsigned __int64 **)qword_65CD18;
      if ( qword_65CD18 >= (unsigned __int64)qword_65CD20 )
      {
        caml_realloc_ref_table((__int64)&caml_ref_table);
        v3 = (unsigned __int64 **)qword_65CD18;
      }
      *v3 = a1;
      qword_65CD18 = (__int64)(v3 + 1);
    }
  }
}
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CD18: using guessed type __int64 qword_65CD18;
// 65CD20: using guessed type __int64 qword_65CD20;
// 6633B0: using guessed type int caml_gc_phase;

//----- (000000000042E4B0) ----------------------------------------------------
void __fastcall caml_initialize(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 **v2; // rax

  *a1 = a2;
  if ( (a2 & 1) == 0
    && a2 < caml_young_end
    && a2 > caml_young_start
    && (caml_page_table_lookup((unsigned __int64)a1) & 1) != 0 )
  {
    v2 = (unsigned __int64 **)qword_65CD18;
    if ( qword_65CD18 >= (unsigned __int64)qword_65CD20 )
    {
      caml_realloc_ref_table((__int64)&caml_ref_table);
      v2 = (unsigned __int64 **)qword_65CD18;
    }
    *v2 = a1;
    qword_65CD18 = (__int64)(v2 + 1);
  }
}
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CD18: using guessed type __int64 qword_65CD18;
// 65CD20: using guessed type __int64 qword_65CD20;

//----- (000000000042E520) ----------------------------------------------------
__int64 __fastcall caml_adjust_gc_speed(unsigned __int64 a1, unsigned __int64 a2)
{
  double v2; // xmm0_8
  double v3; // xmm1_8
  double v4; // xmm0_8
  __int64 result; // rax

  if ( !a2 )
    a2 = 1LL;
  if ( a2 <= a1 )
    a1 = a2;
  if ( (a1 & 0x8000000000000000LL) != 0LL )
    v2 = (double)(int)(a1 & 1 | (a1 >> 1)) + (double)(int)(a1 & 1 | (a1 >> 1));
  else
    v2 = (double)(int)a1;
  if ( (a2 & 0x8000000000000000LL) != 0LL )
    v3 = (double)(int)(a2 & 1 | (a2 >> 1)) + (double)(int)(a2 & 1 | (a2 >> 1));
  else
    v3 = (double)(int)a2;
  v4 = v2 / v3 + *(double *)&caml_extra_heap_resources;
  caml_extra_heap_resources = *(_QWORD *)&v4;
  if ( v4 > 1.0 )
  {
    caml_extra_heap_resources = 0x3FF0000000000000LL;
    caml_urge_major_slice();
    v4 = *(double *)&caml_extra_heap_resources;
  }
  result = (unsigned __int64)caml_stat_heap_size >> 3;
  if ( v4 > (double)(int)((unsigned __int64)caml_minor_heap_size >> 3)
          * 0.5
          / (double)(int)((unsigned __int64)caml_stat_heap_size >> 3) )
    return caml_urge_major_slice();
  return result;
}
// 662760: using guessed type __int64 caml_stat_heap_size;
// 6633B8: using guessed type __int64 caml_extra_heap_resources;
// 6633D8: using guessed type __int64 caml_minor_heap_size;

//----- (000000000042E610) ----------------------------------------------------
unsigned __int64 __fastcall caml_alloc_for_heap(__int64 a1)
{
  unsigned __int64 result; // rax
  __int64 v2; // rdx
  __int64 v3; // [rsp+8h] [rbp-10h] BYREF

  result = caml_aligned_malloc(a1 + 32, 32, &v3);
  if ( result )
  {
    v2 = v3;
    result += 32LL;
    *(_QWORD *)(result - 16) = a1;
    *(_QWORD *)(result - 32) = v2;
  }
  return result;
}

//----- (000000000042E650) ----------------------------------------------------
__int64 __fastcall caml_page_table_modify(unsigned __int64 a1, int a2, int a3)
{
  __int64 v6; // r15
  size_t v7; // rbp
  unsigned __int64 v8; // rax
  unsigned __int64 *v9; // rcx
  unsigned __int64 v10; // rdx
  __int64 result; // rax
  _QWORD *v12; // r14
  char *v13; // rax
  size_t i; // rdi
  unsigned __int64 v15; // r8
  unsigned __int64 v16; // rsi
  char *j; // r10
  __int64 v18; // [rsp+0h] [rbp-48h]
  int v19; // [rsp+Ch] [rbp-3Ch]

  v6 = qword_65CDB8;
  v7 = caml_page_table;
  if ( 2 * qword_65CDB8 >= caml_page_table )
  {
    v12 = ptr;
    v19 = dword_65CDA8;
    caml_gc_message(8, "Growing page table to %lu entries\n", caml_page_table);
    v18 = 2 * v7;
    v13 = (char *)calloc(2 * v7, 8uLL);
    if ( !v13 )
    {
      caml_gc_message(8, "No room for growing page table\n", 0LL);
      return 0xFFFFFFFFLL;
    }
    caml_page_table = 2 * v7;
    qword_65CDB0 = v18 - 1;
    qword_65CDB8 = v6;
    ptr = v13;
    dword_65CDA8 = v19 - 1;
    if ( v7 )
    {
      for ( i = 0LL; i < v7; ++i )
      {
        v15 = v12[i];
        if ( v15 )
        {
          v16 = (0x9E3779B97F4A7C16LL * (v15 >> 12)) >> ((unsigned __int8)v19 - 1);
          for ( j = &v13[8 * v16]; *(_QWORD *)j; j = &v13[8 * v16] )
            v16 = (v18 - 1) & (v16 + 1);
          *(_QWORD *)j = v15;
        }
      }
    }
    free(v12);
  }
  v8 = (0x9E3779B97F4A7C16LL * (a1 >> 12)) >> dword_65CDA8;
  v9 = (unsigned __int64 *)((char *)ptr + 8 * v8);
  v10 = *v9;
  if ( !*v9 )
  {
LABEL_7:
    result = 0LL;
    *v9 = a1 | a3;
    ++qword_65CDB8;
    return result;
  }
  while ( ((a1 ^ v10) & 0xFFFFFFFFFFFFF000LL) != 0 )
  {
    v8 = qword_65CDB0 & (v8 + 1);
    v9 = (unsigned __int64 *)((char *)ptr + 8 * v8);
    v10 = *v9;
    if ( !*v9 )
      goto LABEL_7;
  }
  result = 0LL;
  *v9 = a3 | ~a2 & v10;
  return result;
}
// 65CDA8: using guessed type int dword_65CDA8;
// 65CDB0: using guessed type __int64 qword_65CDB0;
// 65CDB8: using guessed type __int64 qword_65CDB8;

//----- (000000000042E830) ----------------------------------------------------
__int64 __fastcall caml_page_table_remove(int a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // rbx

  v3 = a2 & 0xFFFFFFFFFFFFF000LL;
  v4 = (a3 - 1) & 0xFFFFFFFFFFFFF000LL;
  if ( v3 > v4 )
    return 0LL;
  v5 = v3;
  while ( !(unsigned int)caml_page_table_modify(v5, a1, 0) )
  {
    v5 += 4096LL;
    if ( v4 < v5 )
      return 0LL;
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000042E890) ----------------------------------------------------
void __fastcall caml_shrink_heap(_QWORD *a1)
{
  _QWORD *v1; // rax
  void **v2; // rdx

  if ( a1 != caml_heap_start )
  {
    caml_stat_heap_size -= *(a1 - 2);
    caml_gc_message(4, "Shrinking heap to %luk bytes\n", (unsigned __int64)caml_stat_heap_size >> 10);
    v1 = caml_heap_start;
    --caml_stat_heap_chunks;
    v2 = &caml_heap_start;
    if ( a1 != caml_heap_start )
    {
      do
      {
        v2 = (void **)(v1 - 1);
        v1 = (_QWORD *)*(v1 - 1);
      }
      while ( a1 != v1 );
    }
    *v2 = (void *)*(a1 - 1);
    caml_page_table_remove(1, (__int64)a1, (__int64)a1 + *(a1 - 2));
    caml_free_for_heap((__int64)a1);
  }
}
// 662760: using guessed type __int64 caml_stat_heap_size;
// 662778: using guessed type __int64 caml_stat_heap_chunks;

//----- (000000000042E920) ----------------------------------------------------
__int64 __fastcall caml_page_table_add(int a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // rbx

  v3 = a2 & 0xFFFFFFFFFFFFF000LL;
  v4 = (a3 - 1) & 0xFFFFFFFFFFFFF000LL;
  if ( v3 > v4 )
    return 0LL;
  v5 = v3;
  while ( !(unsigned int)caml_page_table_modify(v5, 0, a1) )
  {
    v5 += 4096LL;
    if ( v4 < v5 )
      return 0LL;
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000042E980) ----------------------------------------------------
__int64 __fastcall caml_add_to_heap(unsigned __int64 a1)
{
  int v1; // edx
  __int64 result; // rax
  _QWORD *v3; // rax
  void **v4; // rdx
  __int64 v5; // rdx

  caml_gc_message(
    4,
    "Growing heap to %luk bytes\n",
    (unsigned __int64)(*(_QWORD *)(a1 - 16) + caml_stat_heap_size) >> 10);
  v1 = caml_page_table_add(1, a1, *(_QWORD *)(a1 - 16) + a1);
  result = 0xFFFFFFFFLL;
  if ( !v1 )
  {
    v3 = caml_heap_start;
    if ( a1 > (unsigned __int64)caml_heap_start && caml_heap_start )
    {
      do
      {
        v4 = (void **)(v3 - 1);
        v3 = (_QWORD *)*(v3 - 1);
      }
      while ( a1 > (unsigned __int64)v3 && v3 );
    }
    else
    {
      v4 = &caml_heap_start;
    }
    *(_QWORD *)(a1 - 8) = v3;
    *v4 = (void *)a1;
    result = 0LL;
    v5 = *(_QWORD *)(a1 - 16) + caml_stat_heap_size;
    ++caml_stat_heap_chunks;
    caml_stat_heap_size = v5;
    if ( v5 > caml_stat_top_heap_size )
      caml_stat_top_heap_size = v5;
  }
  return result;
}
// 662760: using guessed type __int64 caml_stat_heap_size;
// 662768: using guessed type __int64 caml_stat_top_heap_size;
// 662778: using guessed type __int64 caml_stat_heap_chunks;

//----- (000000000042EA40) ----------------------------------------------------
__int64 *__fastcall caml_alloc_shr(unsigned __int64 a1, unsigned int a2)
{
  __int64 *v3; // rax
  unsigned __int64 v5; // r13
  _QWORD *v6; // rax
  unsigned __int64 v7; // r14
  _QWORD *v8; // rcx
  unsigned __int64 v9; // rdx
  _QWORD *i; // rsi
  __int64 *v11; // [rsp+8h] [rbp-30h]

  if ( a1 > 0x3FFFFFFFFFFFFFLL )
    goto LABEL_28;
  v3 = caml_fl_allocate(a1);
  if ( !v3 )
  {
    v5 = caml_round_heap_chunk_size(8 * (a1 + caml_percent_free * (a1 / 0x64) + 1));
    v6 = (_QWORD *)caml_alloc_for_heap(v5);
    v7 = (unsigned __int64)v6;
    if ( v6 )
    {
      v8 = v6;
      v9 = (v5 >> 3) - 1;
      if ( v9 > 0x3FFFFFFFFFFFFFLL )
      {
        for ( i = v6; ; i = v6 )
        {
          *v6 = -512LL;
          v6 += 0x40000000000000LL;
          v5 -= 0x200000000000000LL;
          i[1] = v6 + 1;
          *(_QWORD *)(v7 + 16) = v6 + 1;
          v9 = (v5 >> 3) - 1;
          if ( v9 <= 0x3FFFFFFFFFFFFFLL )
            break;
        }
        v8 = v6;
      }
      if ( v5 <= 1 )
      {
        v8[1] = 0LL;
        if ( v5 == 1 )
          *v6 = 0LL;
      }
      else
      {
        *v6 = (v9 << 10) + 512;
        *(_QWORD *)(v7 + 16) = v8 + 1;
        v8[1] = 0LL;
      }
      if ( (unsigned int)caml_add_to_heap(v7) )
      {
        caml_free_for_heap(v7);
      }
      else if ( v7 != -8LL )
      {
        caml_fl_add_blocks((__int64 *)(v7 + 8));
        v3 = caml_fl_allocate(a1);
        goto LABEL_3;
      }
    }
    else
    {
      caml_gc_message(4, "No room for growing heap\n", 0LL);
    }
    if ( caml_in_minor_collection )
      caml_fatal_error("Fatal error: out of memory.\n");
LABEL_28:
    caml_raise_out_of_memory();
  }
LABEL_3:
  if ( caml_gc_phase && (caml_gc_phase != 1 || (unsigned __int64)v3 < caml_gc_sweep_hp) )
    *v3 = (a1 << 10) + a2;
  else
    *v3 = (a1 << 10) + a2 + 768;
  caml_allocated_words += a1 + 1;
  if ( caml_allocated_words > (unsigned __int64)caml_minor_heap_size >> 3 )
  {
    v11 = v3;
    caml_urge_major_slice();
    v3 = v11;
  }
  return v3 + 1;
}
// 65CD78: using guessed type int caml_in_minor_collection;
// 663390: using guessed type __int64 caml_gc_sweep_hp;
// 663398: using guessed type __int64 caml_percent_free;
// 6633B0: using guessed type int caml_gc_phase;
// 6633C0: using guessed type __int64 caml_allocated_words;
// 6633D8: using guessed type __int64 caml_minor_heap_size;

//----- (000000000042EC70) ----------------------------------------------------
__int64 __fastcall caml_page_table_initialize(unsigned __int64 a1)
{
  __int64 v1; // rcx
  unsigned __int64 v2; // rdi
  int v3; // edx
  size_t v4; // rax

  v1 = 0LL;
  v2 = 2 * (a1 >> 12);
  caml_page_table = 1LL;
  dword_65CDA8 = 64;
  v3 = 64;
  v4 = 1LL;
  if ( v2 > 1 )
  {
    do
    {
      v4 *= 2LL;
      --v3;
    }
    while ( v4 < v2 );
    v1 = v4 - 1;
    caml_page_table = v4;
    dword_65CDA8 = v3;
  }
  qword_65CDB0 = v1;
  qword_65CDB8 = 0LL;
  ptr = calloc(caml_page_table, 8uLL);
  return (unsigned int)-(ptr == 0LL);
}
// 65CDA8: using guessed type int dword_65CDA8;
// 65CDB0: using guessed type __int64 qword_65CDB0;
// 65CDB8: using guessed type __int64 qword_65CDB8;

//----- (000000000042ED00) ----------------------------------------------------
__int64 __fastcall caml_convert_flag_list(__int64 *a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdx

  for ( result = 0LL; a1 != (__int64 *)1; result = *(_DWORD *)(a2 + 4LL * (int)(v3 >> 1)) | (unsigned int)result )
  {
    v3 = *a1;
    a1 = (__int64 *)a1[1];
  }
  return result;
}

//----- (000000000042ED30) ----------------------------------------------------
__int64 __fastcall caml_update_dummy(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 *v3; // rbp
  char v4; // al
  unsigned __int64 v5; // r13
  unsigned __int64 v6; // r13
  unsigned __int64 i; // rbx
  unsigned __int64 v8; // rsi
  unsigned __int64 *v9; // rdi
  unsigned __int64 v11; // rcx
  unsigned __int64 j; // rax

  v3 = a1;
  v4 = *(_BYTE *)(a2 - 8);
  v5 = *(_QWORD *)(a2 - 8);
  *((_BYTE *)a1 - 8) = v4;
  if ( v4 != -2 )
  {
    v6 = v5 >> 10;
    for ( i = 0LL; v6 > i; ++i )
    {
      v8 = *(_QWORD *)(a2 + 8 * i);
      v9 = v3++;
      caml_modify(v9, v8);
    }
    return 1LL;
  }
  v11 = *(_QWORD *)(a2 - 8) >> 10;
  if ( !v11 )
    return 1LL;
  for ( j = 0LL; j < v11; ++j )
    a1[j] = *(_QWORD *)(a2 + 8 * j);
  return 1LL;
}

//----- (000000000042EDD0) ----------------------------------------------------
_QWORD *__fastcall caml_alloc_final(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  _QWORD *v6; // rax

  v6 = caml_final_custom_operations(a2);
  return caml_alloc_custom((__int64)v6, 8 * a1, a3, a4);
}

//----- (000000000042EE20) ----------------------------------------------------
_QWORD *__fastcall caml_alloc_small(__int64 a1, unsigned int a2)
{
  _QWORD *v2; // rax

  caml_young_ptr -= 8 * a1 + 8;
  v2 = (_QWORD *)caml_young_ptr;
  if ( caml_young_ptr < (unsigned __int64)caml_young_limit )
  {
    caml_young_ptr += 8 * a1 + 8;
    caml_minor_collection();
    v2 = (_QWORD *)(caml_young_ptr - (8 * a1 + 8));
    caml_young_ptr = (__int64)v2;
  }
  *v2 = (a1 << 10) + a2 + 768;
  return v2 + 1;
}
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000042EEB0) ----------------------------------------------------
_QWORD *__fastcall caml_alloc_string(__int64 a1)
{
  unsigned __int64 v1; // rbx
  _QWORD *v2; // rax
  _QWORD *result; // rax
  __int64 v4; // rbx
  __int64 *v5; // rax

  v1 = (unsigned __int64)(a1 + 8) >> 3;
  if ( v1 > 0x100 )
  {
    v5 = caml_alloc_shr((unsigned __int64)(a1 + 8) >> 3, 0xFCu);
    result = (_QWORD *)caml_check_urgent_gc((__int64)v5);
  }
  else
  {
    caml_young_ptr -= 8 * v1 + 8;
    v2 = (_QWORD *)caml_young_ptr;
    if ( caml_young_ptr < (unsigned __int64)caml_young_limit )
    {
      caml_young_ptr += 8 * v1 + 8;
      caml_minor_collection();
      v2 = (_QWORD *)(caml_young_ptr - (8 * v1 + 8));
      caml_young_ptr = (__int64)v2;
    }
    *v2 = (v1 << 10) + 1020;
    result = v2 + 1;
  }
  v4 = v1;
  result[v4 - 1] = 0LL;
  HIBYTE(result[v4 - 1]) = v4 * 8 - 1 - a1;
  return result;
}
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000042EF90) ----------------------------------------------------
_QWORD *__fastcall caml_copy_string(void *src)
{
  size_t v1; // r12
  _QWORD *v2; // rbx

  v1 = (int)strlen((const char *)src);
  v2 = caml_alloc_string(v1);
  memmove(v2, src, v1);
  return v2;
}

//----- (000000000042EFE0) ----------------------------------------------------
char *__fastcall caml_alloc(unsigned __int64 a1, unsigned int a2)
{
  char *result; // rax
  __int64 v3; // rcx
  __int64 i; // rdx
  __int64 *v5; // rax
  __int64 v6; // rbx

  result = (char *)&unk_662968 + 8 * a2;
  if ( a1 )
  {
    if ( a1 > 0x100 )
    {
      v5 = caml_alloc_shr(a1, a2);
      v6 = (__int64)v5;
      if ( a2 <= 0xFA )
        memset(v5, 0, 8 * a1);
      return (char *)caml_check_urgent_gc(v6);
    }
    else
    {
      caml_young_ptr -= 8 * a1 + 8;
      v3 = caml_young_ptr;
      if ( caml_young_ptr < (unsigned __int64)caml_young_limit )
      {
        caml_young_ptr += 8 * a1 + 8;
        caml_minor_collection();
        v3 = caml_young_ptr - (8 * a1 + 8);
        caml_young_ptr = v3;
      }
      *(_QWORD *)v3 = (a1 << 10) + a2 + 768;
      result = (char *)(v3 + 8);
      if ( a2 <= 0xFA )
      {
        for ( i = 0LL; i != a1; ++i )
          *(_QWORD *)(v3 + 8 * i + 8) = 0LL;
      }
    }
  }
  return result;
}
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000042F100) ----------------------------------------------------
char *__fastcall caml_alloc_dummy_float(__int64 a1)
{
  unsigned __int64 v1; // rdi

  v1 = (int)(a1 >> 1);
  if ( v1 )
    return caml_alloc(v1, 0);
  else
    return (char *)&unk_662968;
}

//----- (000000000042F120) ----------------------------------------------------
char *__fastcall caml_alloc_dummy(__int64 a1)
{
  unsigned __int64 v1; // rdi

  v1 = (int)(a1 >> 1);
  if ( v1 )
    return caml_alloc(v1, 0);
  else
    return (char *)&unk_662968;
}

//----- (000000000042F140) ----------------------------------------------------
char *__fastcall caml_alloc_array(__int64 (__fastcall *a1)(_QWORD), _QWORD *a2)
{
  bool v3; // zf
  __int64 v4; // r14
  unsigned __int64 v5; // rbx
  unsigned __int64 v7; // rbp
  unsigned __int64 v8; // rax
  unsigned __int64 *v9; // rdi
  __int64 v10[8]; // [rsp+0h] [rbp-78h] BYREF
  char *v11; // [rsp+40h] [rbp-38h] BYREF
  unsigned __int64 v12; // [rsp+48h] [rbp-30h] BYREF

  v3 = *a2 == 0LL;
  v4 = caml_local_roots;
  caml_local_roots = (__int64)v10;
  if ( v3 )
    goto LABEL_5;
  v5 = 0LL;
  do
    ++v5;
  while ( a2[v5] );
  if ( v5 )
  {
    v10[0] = v4;
    v10[2] = 1LL;
    v7 = 0LL;
    v10[3] = (__int64)&v12;
    v10[1] = 2LL;
    v11 = 0LL;
    v12 = 0LL;
    v10[4] = (__int64)&v11;
    v11 = caml_alloc(v5, 0);
    do
    {
      v8 = a1(a2[v7]);
      v9 = (unsigned __int64 *)&v11[8 * v7++];
      v12 = v8;
      caml_modify(v9, v8);
    }
    while ( v5 > v7 );
    caml_local_roots = v4;
    return v11;
  }
  else
  {
LABEL_5:
    caml_local_roots = v4;
    return (char *)&unk_662968;
  }
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (000000000042F240) ----------------------------------------------------
char *__fastcall caml_copy_string_array(_QWORD *a1)
{
  return caml_alloc_array((__int64 (__fastcall *)(_QWORD))caml_copy_string, a1);
}

//----- (000000000042F250) ----------------------------------------------------
char *__fastcall caml_alloc_tuple(unsigned __int64 a1)
{
  return caml_alloc(a1, 0);
}

//----- (000000000042F260) ----------------------------------------------------
void compare_free_stack()
{
  if ( compare_stack != &compare_stack_init )
  {
    free(compare_stack);
    compare_stack = &compare_stack_init;
    compare_stack_limit = &locale_is_set_3458;
  }
}
// 658730: using guessed type int *compare_stack_limit;
// 65E5E0: using guessed type int locale_is_set_3458;

//----- (000000000042F2A0) ----------------------------------------------------
void __noreturn compare_stack_overflow()
{
  caml_gc_message(4, "Stack overflow in structural comparison\n", 0LL);
  compare_free_stack();
  caml_raise_out_of_memory();
}

//----- (000000000042F2C0) ----------------------------------------------------
unsigned __int64 __fastcall compare_val(__int64 a1, __int64 a2, int a3)
{
  char *v6; // r12
  bool v7; // r13
  unsigned __int64 result; // rax
  char v9; // al
  bool v10; // dl
  __int64 *v11; // rax
  char v13; // al
  unsigned __int8 v14; // cl
  _QWORD *v15; // r8
  _QWORD *v16; // rdi
  unsigned __int8 v17; // si
  unsigned __int8 v18; // cl
  __int64 v19; // rdx
  __int64 (__fastcall *v20)(__int64, __int64, bool, _QWORD, _QWORD *); // rax
  unsigned __int64 v21; // rax
  double v22; // xmm1_8
  double v23; // xmm0_8
  __int64 v24; // rdx
  double v25; // xmm1_8
  double v26; // xmm0_8
  unsigned __int64 v27; // rax
  unsigned __int64 v28; // rcx
  char *v29; // rax
  unsigned __int64 v30; // [rsp+8h] [rbp-60h]
  __int64 v31; // [rsp+18h] [rbp-50h]
  size_t v32; // [rsp+20h] [rbp-48h]
  _BYTE *v33; // [rsp+28h] [rbp-40h]

  v6 = (char *)compare_stack;
  v7 = a3 != 0;
  while ( 1 )
  {
    while ( 1 )
    {
LABEL_2:
      if ( a1 == a2 && v7 )
        goto LABEL_12;
      if ( (a1 & 1) == 0 )
        break;
      if ( a1 == a2 )
        goto LABEL_12;
      if ( (a2 & 1) != 0 )
        return (a1 >> 1) - (a2 >> 1);
      if ( (caml_page_table_lookup(a2) & 7) == 0 || *(_BYTE *)(a2 - 8) != 0xFA )
        return -1LL;
LABEL_32:
      a2 = *(_QWORD *)a2;
    }
    if ( (a2 & 1) == 0 )
      break;
    if ( (caml_page_table_lookup(a1) & 7) == 0 || *(_BYTE *)(a1 - 8) != 0xFA )
      return 1LL;
LABEL_20:
    a1 = *(_QWORD *)a1;
  }
  v9 = caml_page_table_lookup(a1);
  v10 = a1 == a2;
  if ( (v9 & 7) == 0 || (v13 = caml_page_table_lookup(a2), v10 = a1 == a2, (v13 & 7) == 0) )
  {
    if ( !v10 )
      return (a1 >> 1) - (a2 >> 1);
    goto LABEL_12;
  }
  v14 = *(_BYTE *)(a1 - 8);
  v15 = (_QWORD *)(a1 - 8);
  v16 = (_QWORD *)(a2 - 8);
  v17 = *(_BYTE *)(a2 - 8);
  if ( v14 == 250 )
    goto LABEL_20;
  if ( v17 == 250 )
    goto LABEL_32;
  if ( v14 != v17 )
    return v14 - (unsigned __int64)v17;
  v18 = v14 + 9;
  switch ( v18 )
  {
    case 0u:
    case 2u:
      compare_free_stack();
      caml_invalid_argument("equal: functional value");
    case 1u:
      v21 = *(__int64 *)(a1 + 8) >> 1;
      v19 = *(__int64 *)(a2 + 8) >> 1;
      if ( v21 != v19 )
        return v21 - v19;
      goto LABEL_12;
    case 4u:
      goto LABEL_65;
    case 5u:
      if ( a1 == a2 )
        goto LABEL_12;
      v30 = caml_string_length(a1);
      v27 = caml_string_length(a2);
      v28 = v30;
      if ( v27 <= v30 )
        v28 = v27;
      if ( !v28 )
        goto LABEL_71;
      while ( 2 )
      {
        if ( *(_BYTE *)a1 != *(_BYTE *)a2 )
          return *(unsigned __int8 *)a1 - (unsigned __int64)*(unsigned __int8 *)a2;
        if ( --v28 )
        {
          ++a1;
          ++a2;
          continue;
        }
        break;
      }
LABEL_71:
      if ( v30 == v27 )
        goto LABEL_12;
      return v30 - v27;
    case 6u:
      v25 = *(double *)a1;
      v26 = *(double *)a2;
      if ( *(double *)a2 > *(double *)a1 )
        return -1LL;
      if ( v25 > v26 )
        return 1LL;
      if ( v25 == v26 )
        goto LABEL_12;
      if ( a3 )
        return 1LL;
      return 0x8000000000000000LL;
    case 7u:
      v21 = *v15 >> 10;
      v19 = *v16 >> 10;
      if ( v21 != v19 )
        return v21 - v19;
      if ( !v21 )
        goto LABEL_12;
      v22 = *(double *)a1;
      v23 = *(double *)a2;
      if ( *(double *)a2 > *(double *)a1 )
        return -1LL;
      if ( v22 > v23 )
        return 1LL;
      v24 = 0LL;
      while ( 2 )
      {
        if ( v22 == v23 )
        {
          if ( v21 <= ++v24 )
            goto LABEL_12;
          v22 = *(double *)(a1 + 8 * v24);
          v23 = *(double *)(a2 + 8 * v24);
          if ( v23 <= v22 )
          {
            if ( v22 > v23 )
              return 1LL;
            continue;
          }
          return -1LL;
        }
        break;
      }
      if ( !a3 )
        return 0x8000000000000000LL;
      return 1LL;
    case 8u:
      v20 = *(__int64 (__fastcall **)(__int64, __int64, bool, _QWORD, _QWORD *))(*(_QWORD *)a1 + 16LL);
      if ( !v20 )
      {
LABEL_65:
        compare_free_stack();
        caml_invalid_argument("equal: abstract value");
      }
      caml_compare_unordered = 0;
      LODWORD(result) = v20(a1, a2, a1 == a2, v18, v15);
      if ( !a3 && caml_compare_unordered )
        return 0x8000000000000000LL;
      if ( !(_DWORD)result )
        goto LABEL_12;
      return (int)result;
    default:
      v31 = *v15 >> 10;
      v19 = *v16 >> 10;
      if ( v31 == v19 )
      {
        if ( v31 )
        {
          if ( v31 != 1 )
          {
            v6 += 24;
            if ( v6 >= (char *)compare_stack_limit )
            {
              v33 = compare_stack;
              if ( 0xAAAAAAAAAAAAAAABLL * (((char *)compare_stack_limit - (_BYTE *)compare_stack) >> 2) > 0xFFFFF )
                compare_stack_overflow();
              if ( compare_stack == &compare_stack_init )
              {
                v32 = 8 * (((char *)compare_stack_limit - (_BYTE *)compare_stack) >> 2);
                v29 = (char *)malloc(v32);
                if ( !v29 )
                  compare_stack_overflow();
                qmemcpy(v29, &compare_stack_init, 0x1800uLL);
              }
              else
              {
                v32 = 8 * (((char *)compare_stack_limit - (_BYTE *)compare_stack) >> 2);
                v29 = (char *)realloc(compare_stack, v32);
                if ( !v29 )
                  compare_stack_overflow();
              }
              compare_stack = v29;
              compare_stack_limit = (int *)&v29[v32];
              v6 = &v29[(v6 - v33) & 0xFFFFFFFFFFFFFFF8LL];
            }
            *(_QWORD *)v6 = a1 + 8;
            *((_QWORD *)v6 + 1) = a2 + 8;
            *((_QWORD *)v6 + 2) = v31 - 1;
          }
          a1 = *(_QWORD *)a1;
          goto LABEL_32;
        }
LABEL_12:
        if ( v6 == compare_stack )
          return 0LL;
        a1 = **(_QWORD **)v6;
        *(_QWORD *)v6 += 8LL;
        v11 = (__int64 *)*((_QWORD *)v6 + 1);
        a2 = *v11;
        *((_QWORD *)v6 + 1) = v11 + 1;
        if ( (*((_QWORD *)v6 + 2))-- == 1LL )
          v6 -= 24;
        goto LABEL_2;
      }
      v21 = *v15 >> 10;
      return v21 - v19;
  }
}
// 658730: using guessed type int *compare_stack_limit;
// 6633E0: using guessed type int caml_compare_unordered;

//----- (000000000042F810) ----------------------------------------------------
unsigned __int64 __fastcall caml_greaterequal(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return ((v2 >> 63) & 0xFFFFFFFFFFFFFFFELL) + 3;
}

//----- (000000000042F840) ----------------------------------------------------
__int64 __fastcall caml_greaterthan(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return 2LL * (v2 > 0) + 1;
}

//----- (000000000042F870) ----------------------------------------------------
__int64 __fastcall caml_lessequal(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return 2LL * ((v2 <= 0) & (unsigned __int8)(v2 != 0x8000000000000000LL)) + 1;
}

//----- (000000000042F8C0) ----------------------------------------------------
unsigned __int64 __fastcall caml_lessthan(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return (-(__int64)(v2 + 0x7FFFFFFFFFFFFFFFLL > 0x7FFFFFFFFFFFFFFELL) & 0xFFFFFFFFFFFFFFFELL) + 3;
}

//----- (000000000042F900) ----------------------------------------------------
unsigned __int64 __fastcall caml_notequal(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return (-(__int64)(v2 == 0) & 0xFFFFFFFFFFFFFFFELL) + 3;
}

//----- (000000000042F930) ----------------------------------------------------
__int64 __fastcall caml_equal(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbx

  v2 = compare_val(a1, a2, 0);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  return v2 == 0 ? 3LL : 1LL;
}

//----- (000000000042F960) ----------------------------------------------------
unsigned __int64 __fastcall caml_compare(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rbx
  unsigned __int64 result; // rax

  v2 = compare_val(a1, a2, 1);
  if ( compare_stack != &compare_stack_init )
    compare_free_stack();
  result = -1LL;
  if ( v2 >= 0 )
    return (-(__int64)(v2 == 0) & 0xFFFFFFFFFFFFFFFELL) + 3;
  return result;
}

//----- (000000000042F9A0) ----------------------------------------------------
__int64 __fastcall caml_int_compare(__int64 a1, __int64 a2)
{
  return 2LL * ((a1 > a2) - (a1 < a2)) + 1;
}

//----- (000000000042F9C0) ----------------------------------------------------
__int64 __fastcall int32_cmp(__int64 a1, __int64 a2)
{
  return (*(_DWORD *)(a1 + 8) > *(_DWORD *)(a2 + 8)) - (unsigned int)(*(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 8));
}

//----- (000000000042F9E0) ----------------------------------------------------
__int64 __fastcall int32_hash(__int64 a1)
{
  return *(int *)(a1 + 8);
}

//----- (000000000042F9F0) ----------------------------------------------------
__int64 __fastcall caml_int32_to_int(__int64 a1)
{
  return 2LL * *(int *)(a1 + 8) + 1;
}

//----- (000000000042FA00) ----------------------------------------------------
__int64 __fastcall caml_int32_compare(__int64 a1, __int64 a2)
{
  return 2LL * ((*(_DWORD *)(a1 + 8) > *(_DWORD *)(a2 + 8)) - (*(_DWORD *)(a1 + 8) < *(_DWORD *)(a2 + 8))) + 1;
}

//----- (000000000042FA20) ----------------------------------------------------
__int64 __fastcall int64_cmp(__int64 a1, __int64 a2)
{
  return (*(_QWORD *)(a1 + 8) > *(_QWORD *)(a2 + 8)) - (unsigned int)(*(_QWORD *)(a1 + 8) < *(_QWORD *)(a2 + 8));
}

//----- (000000000042FA40) ----------------------------------------------------
__int64 __fastcall int64_hash(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (000000000042FA50) ----------------------------------------------------
__int64 __fastcall caml_int64_to_int(__int64 a1)
{
  return 2LL * *(_QWORD *)(a1 + 8) + 1;
}

//----- (000000000042FA60) ----------------------------------------------------
__int64 __fastcall caml_int64_compare(__int64 a1, __int64 a2)
{
  return 2LL * ((*(_QWORD *)(a1 + 8) > *(_QWORD *)(a2 + 8)) - (*(_QWORD *)(a1 + 8) < *(_QWORD *)(a2 + 8))) + 1;
}

//----- (000000000042FA90) ----------------------------------------------------
__int64 __fastcall nativeint_cmp(__int64 a1, __int64 a2)
{
  return (*(_QWORD *)(a1 + 8) > *(_QWORD *)(a2 + 8)) - (unsigned int)(*(_QWORD *)(a1 + 8) < *(_QWORD *)(a2 + 8));
}

//----- (000000000042FAB0) ----------------------------------------------------
__int64 __fastcall nativeint_hash(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (000000000042FAC0) ----------------------------------------------------
__int64 __fastcall caml_nativeint_to_int(__int64 a1)
{
  return 2LL * *(_QWORD *)(a1 + 8) + 1;
}

//----- (000000000042FAD0) ----------------------------------------------------
__int64 __fastcall caml_nativeint_compare(__int64 a1, __int64 a2)
{
  return 2LL * ((*(_QWORD *)(a1 + 8) > *(_QWORD *)(a2 + 8)) - (*(_QWORD *)(a1 + 8) < *(_QWORD *)(a2 + 8))) + 1;
}

//----- (000000000042FB00) ----------------------------------------------------
__int64 __fastcall int32_deserialize(_DWORD *a1)
{
  *a1 = caml_deserialize_sint_4();
  return 4LL;
}

//----- (000000000042FB20) ----------------------------------------------------
__int64 __fastcall int64_deserialize(_QWORD *a1)
{
  *a1 = caml_deserialize_sint_8();
  return 8LL;
}

//----- (000000000042FB40) ----------------------------------------------------
__int64 __fastcall nativeint_deserialize(__int64 *a1)
{
  int v1; // eax

  v1 = caml_deserialize_uint_1();
  if ( v1 == 1 )
  {
    *a1 = (int)caml_deserialize_sint_4();
    return 8LL;
  }
  else
  {
    if ( v1 != 2 )
      caml_deserialize_error("input_value: ill-formed native integer");
    *a1 = caml_deserialize_sint_8();
    return 8LL;
  }
}

//----- (000000000042FB90) ----------------------------------------------------
_BYTE *__fastcall int32_serialize(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _BYTE *result; // rax

  result = caml_serialize_int_4(*(_DWORD *)(a1 + 8));
  *a3 = 4LL;
  *a2 = 4LL;
  return result;
}

//----- (000000000042FBD0) ----------------------------------------------------
_BYTE *__fastcall nativeint_serialize(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 v4; // rbp
  _BYTE *result; // rax

  v4 = *(_QWORD *)(a1 + 8);
  if ( (unsigned __int64)(v4 + 0x80000000LL) <= 0xFFFFFFFF )
  {
    caml_serialize_int_1(1);
    result = caml_serialize_int_4(v4);
  }
  else
  {
    caml_serialize_int_1(2);
    result = caml_serialize_int_8(v4);
  }
  *a2 = 4LL;
  *a3 = 8LL;
  return result;
}

//----- (000000000042FC50) ----------------------------------------------------
char *__fastcall int64_serialize(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  char *result; // rax

  result = caml_serialize_int_8(*(_QWORD *)(a1 + 8));
  *a3 = 8LL;
  *a2 = 8LL;
  return result;
}

//----- (000000000042FC90) ----------------------------------------------------
unsigned __int64 __fastcall parse_intnat(char *a1, unsigned int a2)
{
  char *v2; // r14
  int v3; // er13
  char v6; // al
  unsigned __int64 v7; // rsi
  __int64 v8; // rdi
  int v9; // er15
  int v10; // ebp
  unsigned __int64 v11; // rbp
  unsigned __int8 v12; // cl
  char *v13; // r14
  int v14; // eax
  unsigned __int64 v15; // rbp
  bool v16; // cf
  char v17; // al
  unsigned __int64 result; // rax
  __int64 v19; // rax

  v2 = a1;
  v3 = 1;
  v6 = *a1;
  if ( *a1 == 45 )
  {
    v2 = a1 + 1;
    v6 = a1[1];
    v3 = -1;
  }
  v7 = 0x1999999999999999LL;
  v8 = 10LL;
  v9 = 10;
  if ( v6 == 48 )
  {
    v12 = v2[1] - 66;
    if ( v12 <= 0x36u )
    {
      v19 = 1LL << v12;
      if ( ((1LL << v12) & 0x40000000400000LL) != 0 )
      {
        v2 += 2;
        v7 = 0xFFFFFFFFFFFFFFFLL;
        v8 = 16LL;
        v6 = *v2;
        v9 = 16;
        goto LABEL_4;
      }
      if ( (v19 & 0x200000002000LL) != 0 )
      {
        v2 += 2;
        v7 = 0x1FFFFFFFFFFFFFFFLL;
        v8 = 8LL;
        v6 = *v2;
        v9 = 8;
        goto LABEL_4;
      }
      if ( (v19 & 0x100000001LL) != 0 )
      {
        v2 += 2;
        v7 = 0x7FFFFFFFFFFFFFFFLL;
        v8 = 2LL;
        v6 = *v2;
        v9 = 2;
        goto LABEL_4;
      }
    }
    v8 = 10LL;
    v9 = 10;
    v7 = 0x1999999999999999LL;
    v10 = 48;
    goto LABEL_9;
  }
LABEL_4:
  v10 = v6;
  if ( (unsigned __int8)(v6 - 48) <= 9u )
  {
LABEL_9:
    LODWORD(v11) = v10 - 48;
    goto LABEL_10;
  }
  if ( (unsigned __int8)(v6 - 65) > 5u )
  {
    if ( (unsigned __int8)(v6 - 97) > 5u )
      goto LABEL_35;
    LODWORD(v11) = v6 - 87;
  }
  else
  {
    LODWORD(v11) = v6 - 55;
  }
LABEL_10:
  if ( (v11 & 0x80000000) != 0LL || (int)v11 >= v9 )
    goto LABEL_35;
  v13 = v2 + 1;
  v11 = (int)v11;
  while ( 1 )
  {
    v17 = *v13;
    if ( *v13 == 95 )
      goto LABEL_18;
    if ( (unsigned __int8)(v17 - 48) <= 9u )
    {
      v14 = v17 - 48;
    }
    else if ( (unsigned __int8)(v17 - 65) > 5u )
    {
      if ( (unsigned __int8)(v17 - 97) > 5u )
        break;
      v14 = v17 - 87;
    }
    else
    {
      v14 = v17 - 55;
    }
    if ( v14 < 0 || v14 >= v9 )
      break;
    if ( v11 > v7 )
      goto LABEL_35;
    v15 = v8 * v11;
    v16 = __CFADD__(v14, v15);
    v11 = v14 + v15;
    if ( v16 )
      goto LABEL_35;
LABEL_18:
    ++v13;
  }
  if ( v13 != &a1[caml_string_length((__int64)a1)] )
LABEL_35:
    caml_failwith("int_of_string");
  if ( v9 == 10 )
  {
    if ( v11 <= 1LL << ((unsigned __int8)a2 - 1) )
      goto LABEL_28;
    goto LABEL_35;
  }
  if ( a2 <= 0x3F && v11 >= 1LL << a2 )
    goto LABEL_35;
LABEL_28:
  result = -(__int64)v11;
  if ( v3 != -1 )
    return v11;
  return result;
}

//----- (000000000042FED0) ----------------------------------------------------
unsigned __int64 __fastcall caml_int_of_string(char *a1)
{
  return 2 * parse_intnat(a1, 0x3Fu) + 1;
}

//----- (000000000042FEF0) ----------------------------------------------------
void *__fastcall parse_format(char *nptr, void *src, void *dest, __int64 a4, unsigned __int8 *a5)
{
  char *v8; // rbx
  size_t v9; // r14
  unsigned __int8 *v10; // r12
  char v11; // al
  unsigned __int8 v12; // cl
  char v13; // al
  int v14; // eax
  unsigned __int8 v16; // [rsp+0h] [rbp-48h]
  __int64 n; // [rsp+8h] [rbp-40h]

  v8 = nptr;
  n = caml_string_length((__int64)nptr);
  v9 = strlen((const char *)src);
  if ( n + v9 + 1 > 0x1F )
    caml_invalid_argument("format_int: format too long");
  memmove(dest, nptr, n);
  v10 = (unsigned __int8 *)dest + n - 1;
  v11 = *(v10 - 1);
  v12 = *v10;
  if ( v11 == 110 || v11 == 108 || v11 == 76 )
    --v10;
  v16 = v12;
  memmove(v10, src, v9);
  *(_WORD *)&v10[v9] = v16;
  v13 = *nptr;
  if ( *nptr )
  {
    while ( (unsigned __int8)(v13 - 48) > 9u )
    {
      v13 = *++v8;
      if ( !*v8 )
        goto LABEL_12;
    }
    v14 = strtol(v8, 0LL, 10);
    *a5 = v16;
    if ( v14 + 5 > 31 )
      return caml_stat_alloc(v14 + 6);
  }
  else
  {
LABEL_12:
    *a5 = v16;
  }
  return (void *)a4;
}

//----- (0000000000430020) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_format(char *a1, __int64 a2)
{
  char *v2; // rbx
  _QWORD *v3; // r12
  unsigned __int8 v5; // [rsp+Fh] [rbp-79h] BYREF
  char v6[32]; // [rsp+10h] [rbp-78h] BYREF
  char dest[40]; // [rsp+30h] [rbp-58h] BYREF
  unsigned __int64 v8; // [rsp+58h] [rbp-30h]

  v8 = __readfsqword(0x28u);
  v2 = (char *)parse_format(a1, "l", dest, (__int64)v6, &v5);
  __sprintf_chk(v2, 1LL, -1LL, dest, *(_QWORD *)(a2 + 8));
  v3 = caml_copy_string(v2);
  if ( v2 != v6 )
    caml_stat_free(v2);
  return v3;
}
// 40AB48: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000004300E0) ----------------------------------------------------
_QWORD *__fastcall caml_int64_format(char *a1, __int64 a2)
{
  char *v2; // rbx
  _QWORD *v3; // r12
  unsigned __int8 v5; // [rsp+Fh] [rbp-79h] BYREF
  char v6[32]; // [rsp+10h] [rbp-78h] BYREF
  char dest[40]; // [rsp+30h] [rbp-58h] BYREF
  unsigned __int64 v8; // [rsp+58h] [rbp-30h]

  v8 = __readfsqword(0x28u);
  v2 = (char *)parse_format(a1, "l", dest, (__int64)v6, &v5);
  __sprintf_chk(v2, 1LL, -1LL, dest, *(_QWORD *)(a2 + 8));
  v3 = caml_copy_string(v2);
  if ( v2 != v6 )
    caml_stat_free(v2);
  return v3;
}
// 40AB48: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000004301A0) ----------------------------------------------------
_QWORD *__fastcall caml_int32_format(char *a1, __int64 a2)
{
  char *v2; // rbx
  _QWORD *v3; // r12
  unsigned __int8 v5; // [rsp+Fh] [rbp-79h] BYREF
  char v6[32]; // [rsp+10h] [rbp-78h] BYREF
  char dest[40]; // [rsp+30h] [rbp-58h] BYREF
  unsigned __int64 v8; // [rsp+58h] [rbp-30h]

  v8 = __readfsqword(0x28u);
  v2 = (char *)parse_format(a1, "", dest, (__int64)v6, &v5);
  __sprintf_chk(v2, 1LL, -1LL, dest, *(unsigned int *)(a2 + 8));
  v3 = caml_copy_string(v2);
  if ( v2 != v6 )
    caml_stat_free(v2);
  return v3;
}
// 40AB48: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000430260) ----------------------------------------------------
_QWORD *__fastcall caml_format_int(char *a1, __int64 a2)
{
  char *v2; // rbx
  unsigned __int64 v3; // r8
  _QWORD *v4; // r12
  unsigned __int8 v6; // [rsp+Fh] [rbp-79h] BYREF
  char v7[32]; // [rsp+10h] [rbp-78h] BYREF
  char dest[40]; // [rsp+30h] [rbp-58h] BYREF
  unsigned __int64 v9; // [rsp+58h] [rbp-30h]

  v9 = __readfsqword(0x28u);
  v2 = (char *)parse_format(a1, "l", dest, (__int64)v7, &v6);
  if ( (unsigned __int8)(v6 - 88) <= 0x20u && ((1LL << (v6 - 88)) & 0x120800001LL) != 0 )
    v3 = (unsigned __int64)a2 >> 1;
  else
    v3 = a2 >> 1;
  __sprintf_chk(v2, 1LL, -1LL, dest, v3);
  v4 = caml_copy_string(v2);
  if ( v2 != v7 )
    caml_stat_free(v2);
  return v4;
}
// 40AB48: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000430350) ----------------------------------------------------
__int64 __fastcall caml_nativeint_to_float(__int64 a1)
{
  return caml_copy_double((double)(int)*(_QWORD *)(a1 + 8));
}

//----- (0000000000430360) ----------------------------------------------------
__int64 __fastcall caml_int64_float_of_bits(__int64 a1)
{
  return caml_copy_double(*(double *)(a1 + 8));
}

//----- (0000000000430380) ----------------------------------------------------
__int64 __fastcall caml_int64_to_float(__int64 a1)
{
  return caml_copy_double((double)(int)*(_QWORD *)(a1 + 8));
}

//----- (0000000000430390) ----------------------------------------------------
__int64 __fastcall caml_int32_float_of_bits(__int64 a1)
{
  return caml_copy_double(*(float *)(a1 + 8));
}

//----- (00000000004303A0) ----------------------------------------------------
__int64 __fastcall caml_int32_to_float(__int64 a1)
{
  return caml_copy_double((double)*(int *)(a1 + 8));
}

//----- (00000000004303B0) ----------------------------------------------------
_QWORD *__fastcall caml_copy_nativeint(__int64 a1)
{
  _QWORD *result; // rax

  result = caml_alloc_custom((__int64)&caml_nativeint_ops, 8LL, 0LL, 1uLL);
  result[1] = a1;
  return result;
}
// 6587C0: using guessed type char *caml_nativeint_ops;

//----- (00000000004303D0) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_of_string(char *a1)
{
  __int64 v1; // rax

  v1 = parse_intnat(a1, 0x40u);
  return caml_copy_nativeint(v1);
}

//----- (00000000004303F0) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_of_int32(__int64 a1)
{
  return caml_copy_nativeint(*(int *)(a1 + 8));
}

//----- (0000000000430400) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_of_float(double *a1)
{
  return caml_copy_nativeint((unsigned int)(int)*a1);
}

//----- (0000000000430410) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_of_int(__int64 a1)
{
  return caml_copy_nativeint(a1 >> 1);
}

//----- (0000000000430420) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_shift_right_unsigned(__int64 a1, unsigned __int64 a2)
{
  return caml_copy_nativeint(*(_QWORD *)(a1 + 8) >> (a2 >> 1));
}

//----- (0000000000430440) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_shift_right(__int64 a1, unsigned __int64 a2)
{
  return caml_copy_nativeint(*(__int64 *)(a1 + 8) >> (a2 >> 1));
}

//----- (0000000000430460) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_shift_left(__int64 a1, unsigned __int64 a2)
{
  return caml_copy_nativeint(*(_QWORD *)(a1 + 8) << (a2 >> 1));
}

//----- (0000000000430480) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_xor(__int64 a1, __int64 a2)
{
  return caml_copy_nativeint(*(_QWORD *)(a1 + 8) ^ *(_QWORD *)(a2 + 8));
}

//----- (0000000000430490) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_or(__int64 a1, __int64 a2)
{
  return caml_copy_nativeint(*(_QWORD *)(a1 + 8) | *(_QWORD *)(a2 + 8));
}

//----- (00000000004304A0) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_and(__int64 a1, __int64 a2)
{
  return caml_copy_nativeint(*(_QWORD *)(a1 + 8) & *(_QWORD *)(a2 + 8));
}

//----- (00000000004304B0) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_mod(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rdi

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a1 + 8);
  if ( !v2 )
    caml_raise_zero_divide();
  if ( v2 == -1 && v3 == 0x8000000000000000LL )
    return caml_copy_nativeint(0LL);
  else
    return caml_copy_nativeint(v3 % v2);
}

//----- (0000000000430500) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_div(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = *(_QWORD *)(a2 + 8);
  if ( !v2 )
    caml_raise_zero_divide();
  if ( v2 == -1 && *(_QWORD *)(a1 + 8) == 0x8000000000000000LL )
    return (_QWORD *)a1;
  else
    return caml_copy_nativeint(*(_QWORD *)(a1 + 8) / v2);
}

//----- (0000000000430550) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_mul(__int64 a1, __int64 a2)
{
  return caml_copy_nativeint(*(_QWORD *)(a1 + 8) * *(_QWORD *)(a2 + 8));
}

//----- (0000000000430570) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_sub(__int64 a1, __int64 a2)
{
  return caml_copy_nativeint(*(_QWORD *)(a1 + 8) - *(_QWORD *)(a2 + 8));
}

//----- (0000000000430580) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_add(__int64 a1, __int64 a2)
{
  return caml_copy_nativeint(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a2 + 8));
}

//----- (0000000000430590) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_neg(__int64 a1)
{
  return caml_copy_nativeint(-*(_QWORD *)(a1 + 8));
}

//----- (00000000004305A0) ----------------------------------------------------
_QWORD *__fastcall caml_int64_to_nativeint(__int64 a1)
{
  return caml_copy_nativeint(*(_QWORD *)(a1 + 8));
}

//----- (00000000004305B0) ----------------------------------------------------
_QWORD *__fastcall caml_copy_int64(__int64 a1)
{
  _QWORD *result; // rax

  result = caml_alloc_custom((__int64)&caml_int64_ops, 8LL, 0LL, 1uLL);
  result[1] = a1;
  return result;
}
// 658780: using guessed type char *caml_int64_ops;

//----- (00000000004305D0) ----------------------------------------------------
_QWORD *__fastcall caml_int64_bits_of_float(__int64 *a1)
{
  return caml_copy_int64(*a1);
}

//----- (00000000004305E0) ----------------------------------------------------
_QWORD *__fastcall caml_int64_of_string(char *a1)
{
  char *v1; // r12
  int v2; // ebp
  char v3; // al
  unsigned __int64 v5; // rsi
  __int64 v6; // rdi
  int v7; // er14
  int v8; // er13
  unsigned __int64 v9; // r13
  unsigned __int8 v10; // cl
  char v11; // al
  int v12; // eax
  unsigned __int64 v13; // r13
  bool v14; // cf
  __int64 v16; // rax

  v1 = a1;
  v2 = 1;
  v3 = *a1;
  if ( *a1 == 45 )
  {
    v1 = a1 + 1;
    v3 = a1[1];
    v2 = -1;
  }
  v5 = 0x1999999999999999LL;
  v6 = 10LL;
  v7 = 10;
  if ( v3 == 48 )
  {
    v10 = v1[1] - 66;
    if ( v10 <= 0x36u )
    {
      v16 = 1LL << v10;
      if ( ((1LL << v10) & 0x40000000400000LL) != 0 )
      {
        v1 += 2;
        v5 = 0xFFFFFFFFFFFFFFFLL;
        v6 = 16LL;
        v3 = *v1;
        v7 = 16;
        goto LABEL_4;
      }
      if ( (v16 & 0x200000002000LL) != 0 )
      {
        v1 += 2;
        v5 = 0x1FFFFFFFFFFFFFFFLL;
        v6 = 8LL;
        v3 = *v1;
        v7 = 8;
        goto LABEL_4;
      }
      if ( (v16 & 0x100000001LL) != 0 )
      {
        v1 += 2;
        v5 = 0x7FFFFFFFFFFFFFFFLL;
        v6 = 2LL;
        v3 = *v1;
        v7 = 2;
        goto LABEL_4;
      }
    }
    v5 = 0x1999999999999999LL;
    v7 = 10;
    v6 = 10LL;
    v8 = 48;
    goto LABEL_9;
  }
LABEL_4:
  v8 = v3;
  if ( (unsigned __int8)(v3 - 48) <= 9u )
  {
LABEL_9:
    LODWORD(v9) = v8 - 48;
    goto LABEL_10;
  }
  if ( (unsigned __int8)(v3 - 65) > 5u )
  {
    if ( (unsigned __int8)(v3 - 97) > 5u )
      goto LABEL_20;
    LODWORD(v9) = v3 - 87;
  }
  else
  {
    LODWORD(v9) = v3 - 55;
  }
LABEL_10:
  if ( (v9 & 0x80000000) != 0LL || (int)v9 >= v7 )
    goto LABEL_20;
  v9 = (int)v9;
  while ( 1 )
  {
    do
      v11 = *++v1;
    while ( *v1 == 95 );
    if ( (unsigned __int8)(v11 - 48) > 9u )
    {
      if ( (unsigned __int8)(v11 - 65) > 5u )
      {
        if ( (unsigned __int8)(v11 - 97) > 5u )
          break;
        v12 = v11 - 87;
      }
      else
      {
        v12 = v11 - 55;
      }
    }
    else
    {
      v12 = v11 - 48;
    }
    if ( v12 < 0 || v12 >= v7 )
      break;
    if ( v9 <= v5 )
    {
      v13 = v6 * v9;
      v14 = __CFADD__(v12, v13);
      v9 = v12 + v13;
      if ( !v14 )
        continue;
    }
    goto LABEL_20;
  }
  if ( v1 != &a1[caml_string_length((__int64)a1)] || v7 == 10 && v9 > 0x8000000000000000LL )
LABEL_20:
    caml_failwith("int_of_string");
  if ( v2 == -1 )
    v9 = -(__int64)v9;
  return caml_copy_int64(v9);
}

//----- (0000000000430800) ----------------------------------------------------
_QWORD *__fastcall caml_int64_of_nativeint(__int64 a1)
{
  return caml_copy_int64(*(_QWORD *)(a1 + 8));
}

//----- (0000000000430810) ----------------------------------------------------
_QWORD *__fastcall caml_int64_of_int32(__int64 a1)
{
  return caml_copy_int64(*(int *)(a1 + 8));
}

//----- (0000000000430820) ----------------------------------------------------
_QWORD *__fastcall caml_int64_of_float(double *a1)
{
  return caml_copy_int64((unsigned int)(int)*a1);
}

//----- (0000000000430830) ----------------------------------------------------
_QWORD *__fastcall caml_int64_of_int(__int64 a1)
{
  return caml_copy_int64(a1 >> 1);
}

//----- (0000000000430840) ----------------------------------------------------
_QWORD *__fastcall caml_int64_shift_right_unsigned(__int64 a1, unsigned __int64 a2)
{
  return caml_copy_int64(*(_QWORD *)(a1 + 8) >> (a2 >> 1));
}

//----- (0000000000430860) ----------------------------------------------------
_QWORD *__fastcall caml_int64_shift_right(__int64 a1, unsigned __int64 a2)
{
  return caml_copy_int64(*(__int64 *)(a1 + 8) >> (a2 >> 1));
}

//----- (0000000000430880) ----------------------------------------------------
_QWORD *__fastcall caml_int64_shift_left(__int64 a1, unsigned __int64 a2)
{
  return caml_copy_int64(*(_QWORD *)(a1 + 8) << (a2 >> 1));
}

//----- (00000000004308A0) ----------------------------------------------------
_QWORD *__fastcall caml_int64_xor(__int64 a1, __int64 a2)
{
  return caml_copy_int64(*(_QWORD *)(a1 + 8) ^ *(_QWORD *)(a2 + 8));
}

//----- (00000000004308B0) ----------------------------------------------------
_QWORD *__fastcall caml_int64_or(__int64 a1, __int64 a2)
{
  return caml_copy_int64(*(_QWORD *)(a1 + 8) | *(_QWORD *)(a2 + 8));
}

//----- (00000000004308C0) ----------------------------------------------------
_QWORD *__fastcall caml_int64_and(__int64 a1, __int64 a2)
{
  return caml_copy_int64(*(_QWORD *)(a1 + 8) & *(_QWORD *)(a2 + 8));
}

//----- (00000000004308D0) ----------------------------------------------------
_QWORD *__fastcall caml_int64_mod(__int64 a1, __int64 a2)
{
  __int64 v2; // rcx
  __int64 v3; // rdi

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a1 + 8);
  if ( !v2 )
    caml_raise_zero_divide();
  if ( v2 == -1 && v3 == 0x8000000000000000LL )
    return caml_copy_int64(0LL);
  else
    return caml_copy_int64(v3 % v2);
}

//----- (0000000000430920) ----------------------------------------------------
_QWORD *__fastcall caml_int64_div(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = *(_QWORD *)(a2 + 8);
  if ( !v2 )
    caml_raise_zero_divide();
  if ( v2 == -1 && *(_QWORD *)(a1 + 8) == 0x8000000000000000LL )
    return (_QWORD *)a1;
  else
    return caml_copy_int64(*(_QWORD *)(a1 + 8) / v2);
}

//----- (0000000000430970) ----------------------------------------------------
_QWORD *__fastcall caml_int64_mul(__int64 a1, __int64 a2)
{
  return caml_copy_int64(*(_QWORD *)(a1 + 8) * *(_QWORD *)(a2 + 8));
}

//----- (0000000000430990) ----------------------------------------------------
_QWORD *__fastcall caml_int64_sub(__int64 a1, __int64 a2)
{
  return caml_copy_int64(*(_QWORD *)(a1 + 8) - *(_QWORD *)(a2 + 8));
}

//----- (00000000004309A0) ----------------------------------------------------
_QWORD *__fastcall caml_int64_add(__int64 a1, __int64 a2)
{
  return caml_copy_int64(*(_QWORD *)(a1 + 8) + *(_QWORD *)(a2 + 8));
}

//----- (00000000004309B0) ----------------------------------------------------
_QWORD *__fastcall caml_int64_neg(__int64 a1)
{
  return caml_copy_int64(-*(_QWORD *)(a1 + 8));
}

//----- (00000000004309C0) ----------------------------------------------------
_QWORD *__fastcall caml_copy_int32(int a1)
{
  _QWORD *result; // rax

  result = caml_alloc_custom((__int64)&caml_int32_ops, 4LL, 0LL, 1uLL);
  *((_DWORD *)result + 2) = a1;
  return result;
}
// 658740: using guessed type char *caml_int32_ops;

//----- (00000000004309E0) ----------------------------------------------------
_QWORD *__fastcall caml_nativeint_to_int32(__int64 a1)
{
  return caml_copy_int32(*(_QWORD *)(a1 + 8));
}

//----- (00000000004309F0) ----------------------------------------------------
_QWORD *__fastcall caml_int64_to_int32(__int64 a1)
{
  return caml_copy_int32(*(_QWORD *)(a1 + 8));
}

//----- (0000000000430A00) ----------------------------------------------------
_QWORD *__fastcall caml_int32_bits_of_float(double *a1)
{
  int v2; // [rsp+0h] [rbp-Ch]

  *(float *)&v2 = *a1;
  return caml_copy_int32(v2);
}

//----- (0000000000430A20) ----------------------------------------------------
_QWORD *__fastcall caml_int32_of_string(char *a1)
{
  int v1; // eax

  v1 = parse_intnat(a1, 0x20u);
  return caml_copy_int32(v1);
}

//----- (0000000000430A40) ----------------------------------------------------
_QWORD *__fastcall caml_int32_of_float(double *a1)
{
  return caml_copy_int32((int)*a1);
}

//----- (0000000000430A50) ----------------------------------------------------
_QWORD *__fastcall caml_int32_of_int(__int64 a1)
{
  return caml_copy_int32(a1 >> 1);
}

//----- (0000000000430A60) ----------------------------------------------------
_QWORD *__fastcall caml_int32_shift_right_unsigned(__int64 a1, unsigned __int64 a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 8) >> (a2 >> 1));
}

//----- (0000000000430A70) ----------------------------------------------------
_QWORD *__fastcall caml_int32_shift_right(__int64 a1, unsigned __int64 a2)
{
  return caml_copy_int32(*(int *)(a1 + 8) >> (a2 >> 1));
}

//----- (0000000000430A80) ----------------------------------------------------
_QWORD *__fastcall caml_int32_shift_left(__int64 a1, unsigned __int64 a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 8) << (a2 >> 1));
}

//----- (0000000000430A90) ----------------------------------------------------
_QWORD *__fastcall caml_int32_xor(__int64 a1, __int64 a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 8) ^ *(_DWORD *)(a2 + 8));
}

//----- (0000000000430AA0) ----------------------------------------------------
_QWORD *__fastcall caml_int32_or(__int64 a1, __int64 a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 8) | *(_DWORD *)(a2 + 8));
}

//----- (0000000000430AB0) ----------------------------------------------------
_QWORD *__fastcall caml_int32_and(__int64 a1, __int64 a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 8) & *(_DWORD *)(a2 + 8));
}

//----- (0000000000430AC0) ----------------------------------------------------
_QWORD *__fastcall caml_int32_mod(__int64 a1, __int64 a2)
{
  int v2; // ecx
  int v3; // edi

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)(a1 + 8);
  if ( !v2 )
    caml_raise_zero_divide();
  if ( v2 == -1 && v3 == 0x80000000 )
    return caml_copy_int32(0);
  else
    return caml_copy_int32(v3 % v2);
}

//----- (0000000000430B10) ----------------------------------------------------
_QWORD *__fastcall caml_int32_div(__int64 a1, __int64 a2)
{
  int v2; // ecx
  int v3; // edx

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)(a1 + 8);
  if ( !v2 )
    caml_raise_zero_divide();
  if ( v2 == -1 && v3 == 0x80000000 )
    return (_QWORD *)a1;
  else
    return caml_copy_int32(v3 / v2);
}

//----- (0000000000430B50) ----------------------------------------------------
_QWORD *__fastcall caml_int32_mul(__int64 a1, __int64 a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 8) * *(_DWORD *)(a2 + 8));
}

//----- (0000000000430B60) ----------------------------------------------------
_QWORD *__fastcall caml_int32_sub(__int64 a1, __int64 a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
}

//----- (0000000000430B70) ----------------------------------------------------
_QWORD *__fastcall caml_int32_add(__int64 a1, __int64 a2)
{
  return caml_copy_int32(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a2 + 8));
}

//----- (0000000000430B80) ----------------------------------------------------
_QWORD *__fastcall caml_int32_neg(__int64 a1)
{
  return caml_copy_int32(-*(_DWORD *)(a1 + 8));
}

//----- (0000000000430B90) ----------------------------------------------------
__int64 __fastcall caml_int_of_float(double *a1)
{
  return 2LL * (unsigned int)(int)*a1 + 1;
}

//----- (0000000000430BA0) ----------------------------------------------------
__int64 __fastcall caml_eq_float(double *a1, double *a2)
{
  return 2LL * (*a1 == *a2) + 1;
}

//----- (0000000000430BC0) ----------------------------------------------------
__int64 __fastcall caml_neq_float(double *a1, double *a2)
{
  return 2LL * (*a1 != *a2) + 1;
}

//----- (0000000000430BE0) ----------------------------------------------------
unsigned __int64 __fastcall caml_le_float(double *a1, double *a2)
{
  return (-(__int64)(*a2 < *a1) & 0xFFFFFFFFFFFFFFFELL) + 3;
}

//----- (0000000000430C00) ----------------------------------------------------
__int64 __fastcall caml_lt_float(double *a1, double *a2)
{
  return 2LL * (*a2 > *a1) + 1;
}

//----- (0000000000430C20) ----------------------------------------------------
unsigned __int64 __fastcall caml_ge_float(double *a1, double *a2)
{
  return (-(__int64)(*a1 < *a2) & 0xFFFFFFFFFFFFFFFELL) + 3;
}

//----- (0000000000430C40) ----------------------------------------------------
__int64 __fastcall caml_gt_float(double *a1, double *a2)
{
  return 2LL * (*a1 > *a2) + 1;
}

//----- (0000000000430C60) ----------------------------------------------------
__int64 __fastcall caml_float_compare(double *a1, double *a2)
{
  if ( *a1 == *a2 )
    return 1LL;
  if ( *a2 > *a1 )
    return -1LL;
  return 3LL;
}

//----- (0000000000430CC0) ----------------------------------------------------
__int64 __fastcall caml_classify_float(double *a1)
{
  unsigned int v1; // edx
  __int64 result; // rax

  v1 = __fpclassify(*a1);
  result = 1LL;
  if ( v1 <= 3 )
    return CSWTCH_118[v1];
  return result;
}
// 43D9C0: using guessed type __int64 CSWTCH_118[4];

//----- (0000000000430CF0) ----------------------------------------------------
_QWORD *__fastcall caml_format_float(char *nptr, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  char *v5; // rbx
  char v6; // al
  int v7; // ebp
  char v8; // al
  int v9; // eax
  unsigned int v10; // edx
  _QWORD *v11; // rbx
  __int64 v12; // r8
  _QWORD *v13; // rbp
  _QWORD v15[53]; // [rsp+0h] [rbp-1A8h] BYREF

  v5 = nptr;
  v15[47] = __readfsqword(0x28u);
  v6 = *nptr;
  if ( !*nptr )
    goto LABEL_16;
  while ( (unsigned __int8)(v6 - 48) > 9u )
  {
    v6 = *++v5;
    if ( !*v5 )
      goto LABEL_16;
  }
  v7 = strtol(v5, 0LL, 10) + 350;
  if ( v7 < 350 )
    v7 = 350;
  v8 = *v5;
  if ( *v5 )
  {
    while ( v8 != 46 )
    {
      v8 = *++v5;
      if ( !*v5 )
        goto LABEL_18;
    }
    v9 = strtol(v5 + 1, 0LL, 10) + 350;
    v10 = v7;
    if ( v7 < v9 )
    {
      v7 = v9;
      v10 = v9;
    }
  }
  else
  {
LABEL_18:
    v10 = v7;
  }
  if ( v10 > 0x171 )
  {
    v11 = caml_stat_alloc(v7);
    __sprintf_chk(v11, 1LL, -1LL, nptr, v12);
    v13 = caml_copy_string(v11);
    if ( v11 != v15 )
      caml_stat_free(v11);
  }
  else
  {
LABEL_16:
    __sprintf_chk(v15, 1LL, 370LL, nptr, a5);
    return caml_copy_string(v15);
  }
  return v13;
}
// 430DD2: variable 'v12' is possibly undefined
// 430E13: variable 'a5' is possibly undefined
// 40AB48: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000430E60) ----------------------------------------------------
__int64 __fastcall caml_copy_double(double a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx
  __int64 result; // rax

  v1 = caml_young_ptr;
  v2 = caml_young_ptr - 16;
  caml_young_ptr -= 16LL;
  if ( caml_young_ptr < (unsigned __int64)caml_young_limit )
  {
    caml_young_ptr = v1;
    caml_minor_collection();
    v2 = caml_young_ptr - 16;
    caml_young_ptr -= 16LL;
  }
  *(_QWORD *)v2 = 2045LL;
  result = v2 + 8;
  *(double *)(v2 + 8) = a1;
  return result;
}
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000430EC0) ----------------------------------------------------
__int64 __fastcall caml_ceil_float(double *a1)
{
  double v1; // xmm0_8

  v1 = ceil(*a1);
  return caml_copy_double(v1);
}

//----- (0000000000430EE0) ----------------------------------------------------
__int64 __fastcall caml_atan2_float(double *a1, double *a2)
{
  double v2; // xmm0_8

  v2 = atan2(*a1, *a2);
  return caml_copy_double(v2);
}

//----- (0000000000430F00) ----------------------------------------------------
__int64 __fastcall caml_atan_float(double *a1)
{
  double v1; // xmm0_8

  v1 = atan(*a1);
  return caml_copy_double(v1);
}

//----- (0000000000430F20) ----------------------------------------------------
__int64 __fastcall caml_acos_float(double *a1)
{
  double v1; // xmm0_8

  v1 = acos(*a1);
  return caml_copy_double(v1);
}

//----- (0000000000430F40) ----------------------------------------------------
__int64 __fastcall caml_asin_float(double *a1)
{
  double v1; // xmm0_8

  v1 = asin(*a1);
  return caml_copy_double(v1);
}

//----- (0000000000430F60) ----------------------------------------------------
__int64 __fastcall caml_tanh_float(double *a1)
{
  double v1; // xmm0_8

  v1 = tanh(*a1);
  return caml_copy_double(v1);
}

//----- (0000000000430F80) ----------------------------------------------------
__int64 __fastcall caml_tan_float(double *a1)
{
  double v1; // xmm0_8

  v1 = tan(*a1);
  return caml_copy_double(v1);
}

//----- (0000000000430FA0) ----------------------------------------------------
__int64 __fastcall caml_cosh_float(double *a1)
{
  double v1; // xmm0_8

  v1 = cosh(*a1);
  return caml_copy_double(v1);
}

//----- (0000000000430FC0) ----------------------------------------------------
__int64 __fastcall caml_cos_float(double *a1)
{
  double v1; // xmm0_8

  v1 = cos(*a1);
  return caml_copy_double(v1);
}

//----- (0000000000430FE0) ----------------------------------------------------
__int64 __fastcall caml_sinh_float(double *a1)
{
  double v1; // xmm0_8

  v1 = sinh(*a1);
  return caml_copy_double(v1);
}

//----- (0000000000431000) ----------------------------------------------------
__int64 __fastcall caml_sin_float(double *a1)
{
  double v1; // xmm0_8

  v1 = sin(*a1);
  return caml_copy_double(v1);
}

//----- (0000000000431020) ----------------------------------------------------
__int64 __fastcall caml_power_float(double *a1, double *a2)
{
  double v2; // xmm0_8

  v2 = pow(*a1, *a2);
  return caml_copy_double(v2);
}

//----- (0000000000431040) ----------------------------------------------------
__int64 __fastcall caml_sqrt_float(double *a1)
{
  return caml_copy_double(sqrt(*a1));
}

//----- (0000000000431070) ----------------------------------------------------
char *__fastcall caml_modf_float(double *a1)
{
  __int64 v1; // rbx
  double v2; // xmm0_8
  double v3; // xmm0_8
  double *v5; // [rsp+8h] [rbp-B0h] BYREF
  __int64 v6[8]; // [rsp+10h] [rbp-A8h] BYREF
  __int64 v7[8]; // [rsp+50h] [rbp-68h] BYREF
  __int64 v8; // [rsp+90h] [rbp-28h] BYREF
  __int64 v9; // [rsp+98h] [rbp-20h] BYREF
  char *v10; // [rsp+A0h] [rbp-18h] BYREF
  double iptr[2]; // [rsp+A8h] [rbp-10h] BYREF

  v1 = caml_local_roots;
  v5 = a1;
  v2 = *a1;
  v7[2] = 1LL;
  v7[3] = (__int64)&v5;
  v7[0] = caml_local_roots;
  v7[1] = 1LL;
  v10 = 0LL;
  v6[0] = (__int64)v7;
  v9 = 0LL;
  v8 = 0LL;
  v6[2] = 1LL;
  caml_local_roots = (__int64)v6;
  v6[1] = 3LL;
  v6[3] = (__int64)&v10;
  v6[4] = (__int64)&v9;
  v6[5] = (__int64)&v8;
  v3 = modf(v2, iptr);
  v9 = caml_copy_double(v3);
  v8 = caml_copy_double(iptr[0]);
  v10 = caml_alloc_tuple(2uLL);
  caml_local_roots = v1;
  *(_QWORD *)v10 = v9;
  *((_QWORD *)v10 + 1) = v8;
  return v10;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 431070: using guessed type double iptr[2];

//----- (00000000004311A0) ----------------------------------------------------
__int64 __fastcall caml_log10_float(double *a1)
{
  double v1; // xmm0_8

  v1 = log10(*a1);
  return caml_copy_double(v1);
}

//----- (00000000004311C0) ----------------------------------------------------
__int64 __fastcall caml_log_float(double *a1)
{
  double v1; // xmm0_8

  v1 = log(*a1);
  return caml_copy_double(v1);
}

//----- (00000000004311E0) ----------------------------------------------------
__int64 __fastcall caml_ldexp_float(double *a1, __int64 a2)
{
  double v2; // xmm0_8

  v2 = ldexp(*a1, a2 >> 1);
  return caml_copy_double(v2);
}

//----- (0000000000431200) ----------------------------------------------------
char *__fastcall caml_frexp_float(double *a1)
{
  __int64 v1; // rbx
  double v2; // xmm0_8
  double v3; // xmm0_8
  double *v5; // [rsp+8h] [rbp-B0h] BYREF
  __int64 v6[8]; // [rsp+10h] [rbp-A8h] BYREF
  __int64 v7[9]; // [rsp+50h] [rbp-68h] BYREF
  __int64 v8; // [rsp+98h] [rbp-20h] BYREF
  char *v9; // [rsp+A0h] [rbp-18h] BYREF
  int exponent[3]; // [rsp+ACh] [rbp-Ch] BYREF

  v1 = caml_local_roots;
  v5 = a1;
  v2 = *a1;
  v7[2] = 1LL;
  v7[3] = (__int64)&v5;
  v7[0] = caml_local_roots;
  v7[1] = 1LL;
  v9 = 0LL;
  v6[0] = (__int64)v7;
  v8 = 0LL;
  v6[2] = 1LL;
  v6[1] = 2LL;
  caml_local_roots = (__int64)v6;
  v6[3] = (__int64)&v9;
  v6[4] = (__int64)&v8;
  v3 = frexp(v2, exponent);
  v8 = caml_copy_double(v3);
  v9 = caml_alloc_tuple(2uLL);
  caml_local_roots = v1;
  *(_QWORD *)v9 = v8;
  *((_QWORD *)v9 + 1) = 2LL * exponent[0] + 1;
  return v9;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 431200: using guessed type int exponent[3];

//----- (0000000000431300) ----------------------------------------------------
__int64 __fastcall caml_fmod_float(double *a1, double *a2)
{
  long double v2; // fst4
  char v4; // c2

  v2 = *a1;
  do
    v2 = __FPREM__(v2, *a2);
  while ( v4 );
  return caml_copy_double(v2);
}
// 431313: variable 'v4' is possibly undefined

//----- (0000000000431370) ----------------------------------------------------
__int64 __fastcall caml_floor_float(double *a1)
{
  double v1; // xmm0_8

  v1 = floor(*a1);
  return caml_copy_double(v1);
}

//----- (0000000000431390) ----------------------------------------------------
__int64 __fastcall caml_exp_float(double *a1)
{
  double v1; // xmm0_8

  v1 = exp(*a1);
  return caml_copy_double(v1);
}

//----- (00000000004313B0) ----------------------------------------------------
__int64 __fastcall caml_div_float(double *a1, double *a2)
{
  return caml_copy_double(*a1 / *a2);
}

//----- (00000000004313C0) ----------------------------------------------------
__int64 __fastcall caml_mul_float(double *a1, double *a2)
{
  return caml_copy_double(*a1 * *a2);
}

//----- (00000000004313D0) ----------------------------------------------------
__int64 __fastcall caml_sub_float(double *a1, double *a2)
{
  return caml_copy_double(*a1 - *a2);
}

//----- (00000000004313E0) ----------------------------------------------------
__int64 __fastcall caml_add_float(double *a1, double *a2)
{
  return caml_copy_double(*a1 + *a2);
}

//----- (00000000004313F0) ----------------------------------------------------
__int64 __fastcall caml_abs_float(double *a1)
{
  return caml_copy_double(fabs(*a1));
}

//----- (0000000000431410) ----------------------------------------------------
__int64 __fastcall caml_neg_float(double *a1)
{
  return caml_copy_double(-*a1);
}

//----- (0000000000431430) ----------------------------------------------------
__int64 __fastcall caml_float_of_int(__int64 a1)
{
  return caml_copy_double((double)(int)(a1 >> 1));
}

//----- (0000000000431440) ----------------------------------------------------
__int64 __fastcall caml_float_of_string(__int64 a1)
{
  unsigned __int64 v1; // rax
  unsigned __int64 v2; // rbx
  char *v3; // r12
  char *v4; // rax
  char *v5; // rbp
  double v6; // xmm0_8
  char *endptr; // [rsp+18h] [rbp-80h] BYREF
  char nptr[72]; // [rsp+20h] [rbp-78h] BYREF
  unsigned __int64 v10; // [rsp+68h] [rbp-30h]

  v10 = __readfsqword(0x28u);
  v1 = caml_string_length(a1);
  v2 = v1;
  v3 = nptr;
  if ( v1 > 0x3F )
    v3 = (char *)caml_stat_alloc(v1 + 1);
  v4 = (char *)a1;
  v5 = v3;
  while ( v2 )
  {
    if ( *v4 != 95 )
      *v5++ = *v4;
    ++v4;
    --v2;
  }
  *v5 = 0;
  if ( v5 == v3 || (v6 = strtod(v3, &endptr), endptr != v5) )
  {
    if ( v3 != nptr )
      caml_stat_free(v3);
    caml_failwith("float_of_string");
  }
  if ( v3 != nptr )
    caml_stat_free(v3);
  return caml_copy_double(v6);
}

//----- (0000000000431530) ----------------------------------------------------
__int64 __fastcall caml_float_of_substring(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbp
  unsigned __int64 v5; // rax
  __int64 v6; // r12
  char *v7; // r14
  char *v8; // rbx
  char *v9; // r13
  double v10; // xmm0_8
  char *endptr; // [rsp+18h] [rbp-90h] BYREF
  char nptr[72]; // [rsp+20h] [rbp-88h] BYREF
  unsigned __int64 v14; // [rsp+68h] [rbp-40h]

  v4 = a2 >> 1;
  v14 = __readfsqword(0x28u);
  v5 = caml_string_length(a1);
  if ( v5 > a2 >> 1 && v4 >= 0 && (v6 = a3 >> 1, v6 > 0) && v6 <= v5 - v4 )
  {
    if ( (unsigned __int64)v6 > 0x3F )
    {
      v7 = (char *)caml_stat_alloc(v6 + 1);
      goto LABEL_7;
    }
  }
  else
  {
    v6 = 0LL;
  }
  v7 = nptr;
LABEL_7:
  v8 = (char *)(v4 + a1);
  v9 = v7;
  while ( v6 )
  {
    if ( *v8 != 95 )
      *v9++ = *v8;
    ++v8;
    --v6;
  }
  *v9 = 0;
  if ( v9 == v7 || (v10 = strtod(v7, &endptr), endptr != v9) )
  {
    if ( v7 != nptr )
      caml_stat_free(v7);
    caml_failwith("float_of_string");
  }
  if ( v7 != nptr )
    caml_stat_free(v7);
  return caml_copy_double(v10);
}

//----- (0000000000431650) ----------------------------------------------------
__int64 __fastcall caml_string_length(__int64 a1)
{
  return 8LL * (*(_QWORD *)(a1 - 8) >> 10) - 1 - *(char *)(a1 + 8LL * (*(_QWORD *)(a1 - 8) >> 10) - 1);
}

//----- (0000000000431670) ----------------------------------------------------
__int64 __fastcall caml_ml_string_length(__int64 a1)
{
  return 2 * (8LL * (*(_QWORD *)(a1 - 8) >> 10) - 1 - *(char *)(a1 + 8LL * (*(_QWORD *)(a1 - 8) >> 10) - 1)) + 1;
}

//----- (00000000004316A0) ----------------------------------------------------
__int64 __fastcall caml_string_equal(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rax

  if ( a1 != a2 )
  {
    v2 = *(a1 - 1) >> 10;
    if ( v2 != *(a2 - 1) >> 10 )
      return 1LL;
    if ( v2 )
    {
      while ( *a1 == *a2 )
      {
        if ( !--v2 )
          return 3LL;
        ++a1;
        ++a2;
      }
      return 1LL;
    }
  }
  return 3LL;
}

//----- (0000000000431700) ----------------------------------------------------
__int64 __fastcall caml_string_notequal(_QWORD *a1, _QWORD *a2)
{
  return 4 - caml_string_equal(a1, a2);
}

//----- (0000000000431720) ----------------------------------------------------
__int64 __fastcall caml_bitvect_test(__int64 a1, unsigned __int64 a2)
{
  return 2LL * (unsigned __int8)(*(_BYTE *)(((int)(a2 >> 1) >> 3) + a1) & (1 << ((a2 >> 1) & 7))) + 1;
}

//----- (0000000000431750) ----------------------------------------------------
unsigned __int64 __fastcall caml_is_printable(__int64 a1)
{
  if ( !locale_is_set_3458 )
  {
    setlocale(0, "");
    locale_is_set_3458 = 1;
  }
  return (-(__int64)(((*__ctype_b_loc())[(int)(a1 >> 1)] & 0x4000) == 0) & 0xFFFFFFFFFFFFFFFELL) + 3;
}
// 65E5E0: using guessed type int locale_is_set_3458;

//----- (00000000004317A0) ----------------------------------------------------
__int64 __fastcall caml_fill_string(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  memset((void *)((a2 >> 1) + a1), a4 >> 1, a3 >> 1);
  return 1LL;
}

//----- (00000000004317D0) ----------------------------------------------------
__int64 __fastcall caml_blit_string(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  memmove((void *)((a4 >> 1) + a3), (const void *)(a1 + (a2 >> 1)), (int)(a5 >> 1));
  return 1LL;
}

//----- (0000000000431800) ----------------------------------------------------
__int64 __fastcall caml_string_compare(_QWORD *a1, _QWORD *a2)
{
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rcx
  bool v6; // zf

  if ( a1 == a2 )
    return 1LL;
  v3 = 8LL * (*(a1 - 1) >> 10) - 1 - SHIBYTE(a1[(*(a1 - 1) >> 10) - 1]);
  v4 = 8LL * (*(a2 - 1) >> 10) - 1 - SHIBYTE(a2[(*(a2 - 1) >> 10) - 1]);
  v5 = v3;
  if ( v4 <= v3 )
    v5 = 8LL * (*(a2 - 1) >> 10) - 1 - SHIBYTE(a2[(*(a2 - 1) >> 10) - 1]);
  v6 = memcmp(a1, a2, v5) == 0;
  if ( !v6 >= 0 )
  {
    if ( !v6 )
      return 3LL;
    if ( v3 >= v4 )
    {
      if ( v3 <= v4 )
        return 1LL;
      return 3LL;
    }
  }
  return -1LL;
}

//----- (00000000004318A0) ----------------------------------------------------
__int64 __fastcall caml_string_greaterequal(_QWORD *a1, _QWORD *a2)
{
  return 2LL * (caml_string_compare(a1, a2) > 0) + 1;
}

//----- (00000000004318C0) ----------------------------------------------------
__int64 __fastcall caml_string_greaterthan(_QWORD *a1, _QWORD *a2)
{
  return 2LL * (caml_string_compare(a1, a2) > 1) + 1;
}

//----- (00000000004318E0) ----------------------------------------------------
__int64 __fastcall caml_string_lessequal(_QWORD *a1, _QWORD *a2)
{
  return 2LL * (caml_string_compare(a1, a2) < 2) + 1;
}

//----- (0000000000431900) ----------------------------------------------------
__int64 __fastcall caml_string_lessthan(_QWORD *a1, _QWORD *a2)
{
  return 2LL * (caml_string_compare(a1, a2) <= 0) + 1;
}

//----- (0000000000431920) ----------------------------------------------------
__int64 __fastcall caml_string_set(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 result; // rax

  v3 = a2 >> 1;
  if ( v3 < 0
    || v3 >= (unsigned __int64)(8LL * (*(_QWORD *)(a1 - 8) >> 10)
                              - 1
                              - *(char *)(a1 + 8LL * (*(_QWORD *)(a1 - 8) >> 10) - 1)) )
  {
    caml_array_bound_error();
  }
  result = 1LL;
  *(_BYTE *)(v3 + a1) = a3 >> 1;
  return result;
}

//----- (0000000000431960) ----------------------------------------------------
__int64 __fastcall caml_string_get(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = a2 >> 1;
  if ( v2 < 0
    || v2 >= (unsigned __int64)(8LL * (*(_QWORD *)(a1 - 8) >> 10)
                              - 1
                              - *(char *)(a1 + 8LL * (*(_QWORD *)(a1 - 8) >> 10) - 1)) )
  {
    caml_array_bound_error();
  }
  return 2LL * *(unsigned __int8 *)(v2 + a1) + 1;
}

//----- (00000000004319A0) ----------------------------------------------------
_QWORD *__fastcall caml_create_string(__int64 a1)
{
  unsigned __int64 v1; // rdi

  v1 = a1 >> 1;
  if ( v1 > 0x1FFFFFFFFFFFFF7LL )
    caml_invalid_argument("String.create");
  return caml_alloc_string(v1);
}

//----- (00000000004319D0) ----------------------------------------------------
__int64 __fastcall caml_array_unsafe_set_float(__int64 a1, __int64 a2, _QWORD *a3)
{
  *(_QWORD *)(a1 + 8 * (a2 >> 1)) = *a3;
  return 1LL;
}

//----- (00000000004319E0) ----------------------------------------------------
unsigned __int64 *__fastcall caml_make_array(unsigned __int64 *a1)
{
  unsigned __int64 *result; // rax
  __int64 v2; // rbp
  unsigned __int64 v3; // rbx
  unsigned __int64 v4; // rbx
  __int64 v5; // rdi
  unsigned __int64 *v6; // rsi
  unsigned __int64 i; // rdx
  unsigned __int64 *v8; // [rsp+8h] [rbp-B0h] BYREF
  __int64 v9[8]; // [rsp+10h] [rbp-A8h] BYREF
  __int64 v10[8]; // [rsp+50h] [rbp-68h] BYREF
  unsigned __int64 *v11; // [rsp+90h] [rbp-28h] BYREF
  __int64 v12; // [rsp+98h] [rbp-20h] BYREF

  result = a1;
  v2 = caml_local_roots;
  v8 = a1;
  v10[2] = 1LL;
  v10[1] = 1LL;
  v12 = 0LL;
  v10[3] = (__int64)&v8;
  v11 = 0LL;
  v9[2] = 1LL;
  v9[1] = 2LL;
  v9[0] = (__int64)v10;
  v3 = *(a1 - 1);
  v10[0] = caml_local_roots;
  caml_local_roots = (__int64)v9;
  v4 = v3 >> 10;
  v9[3] = (__int64)&v12;
  v9[4] = (__int64)&v11;
  if ( v4 )
  {
    v5 = *a1;
    if ( (v5 & 1) == 0 )
    {
      v12 = v5;
      if ( (caml_page_table_lookup(v5) & 7) != 0 && *(_BYTE *)(v12 - 8) == 0xFD )
      {
        result = caml_alloc_small(v4, 0xFEu);
        v6 = v8;
        v11 = result;
        for ( i = 0LL; i < v4; ++i )
          result[i] = *(_QWORD *)v6[i];
      }
      else
      {
        result = v8;
      }
    }
  }
  caml_local_roots = v2;
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000431B10) ----------------------------------------------------
_QWORD *__fastcall caml_array_unsafe_get_float(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  _QWORD *v4; // rdx
  _QWORD *result; // rax

  v2 = caml_young_ptr;
  v3 = *(_QWORD *)(a1 + 8 * (a2 >> 1));
  v4 = (_QWORD *)(caml_young_ptr - 16);
  caml_young_ptr -= 16LL;
  if ( caml_young_ptr < (unsigned __int64)caml_young_limit )
  {
    caml_young_ptr = v2;
    caml_minor_collection();
    v4 = (_QWORD *)(caml_young_ptr - 16);
    caml_young_ptr -= 16LL;
  }
  *v4 = 2045LL;
  result = v4 + 1;
  v4[1] = v3;
  return result;
}
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000431B70) ----------------------------------------------------
_QWORD *__fastcall caml_array_unsafe_get(__int64 a1, __int64 a2)
{
  if ( *(_BYTE *)(a1 - 8) == 0xFE )
    return caml_array_unsafe_get_float(a1, a2);
  else
    return *(_QWORD **)(a1 + 8 * (a2 >> 1));
}

//----- (0000000000431B90) ----------------------------------------------------
_QWORD *__fastcall caml_make_vect(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rbp
  _QWORD *result; // rax
  __int64 v5; // rbx
  __int64 *v6; // rax
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // r12
  __int64 *v9; // rax
  unsigned __int64 *v10; // rdi
  __int64 v11; // r12
  __int64 v12; // rdx
  __int64 v13; // rbx
  __int64 *v14; // rax
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // [rsp+0h] [rbp-B8h] BYREF
  __int64 v17; // [rsp+8h] [rbp-B0h] BYREF
  __int64 v18[8]; // [rsp+10h] [rbp-A8h] BYREF
  __int64 v19[9]; // [rsp+50h] [rbp-68h] BYREF
  __int64 *i; // [rsp+98h] [rbp-20h] BYREF

  v2 = a1 >> 1;
  v3 = caml_local_roots;
  v17 = a1;
  v16 = a2;
  i = 0LL;
  caml_local_roots = (__int64)v18;
  result = &unk_662968;
  if ( a1 >> 1 )
  {
    v19[0] = v3;
    v19[2] = 1LL;
    v19[1] = 2LL;
    v19[3] = (__int64)&v17;
    v19[4] = (__int64)&v16;
    v18[2] = 1LL;
    v18[1] = 1LL;
    v18[0] = (__int64)v19;
    v18[3] = (__int64)&i;
    if ( (a2 & 1) == 0 && (caml_page_table_lookup(a2) & 7) != 0 && *(_BYTE *)(v16 - 8) == 0xFD )
    {
      v11 = *(_QWORD *)v16;
      if ( v2 <= 0x3FFFFFFFFFFFFFLL )
      {
        result = caml_alloc(v2, 0xFEu);
        v12 = 0LL;
        do
          result[v12++] = v11;
        while ( v2 != v12 );
        goto LABEL_12;
      }
LABEL_27:
      caml_invalid_argument("Array.make");
    }
    if ( v2 > 0x3FFFFFFFFFFFFFLL )
      goto LABEL_27;
    if ( v2 <= 0xFF )
    {
      v13 = 8 * v2;
      v14 = caml_alloc_small(a1 >> 1, 0);
      v15 = 0LL;
      for ( i = v14; ; v14 = i )
      {
        v14[v15 / 8] = v16;
        v15 += 8LL;
        if ( v15 == v13 )
          break;
      }
      result = i;
    }
    else
    {
      if ( (v16 & 1) != 0 || v16 >= caml_young_end || v16 <= caml_young_start )
      {
        v8 = 0LL;
        v9 = caml_alloc_shr(v2, 0);
        for ( i = v9; ; v9 = i )
        {
          v10 = (unsigned __int64 *)&v9[v8++];
          caml_initialize(v10, v16);
          if ( v2 <= v8 )
            break;
        }
      }
      else
      {
        caml_minor_collection();
        v5 = 8 * v2;
        v6 = caml_alloc_shr(a1 >> 1, 0);
        v7 = 0LL;
        for ( i = v6; ; v6 = i )
        {
          v6[v7 / 8] = v16;
          v7 += 8LL;
          if ( v7 == v5 )
            break;
        }
      }
      result = (_QWORD *)caml_check_urgent_gc((__int64)i);
    }
  }
LABEL_12:
  caml_local_roots = v3;
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;

//----- (0000000000431DD0) ----------------------------------------------------
__int64 __fastcall caml_array_unsafe_set_addr(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 *v3; // rbx
  unsigned __int64 v5; // r12
  unsigned __int64 **v6; // rax

  v3 = (unsigned __int64 *)(a1 + 8 * (a2 >> 1));
  v5 = *v3;
  *v3 = a3;
  if ( (caml_page_table_lookup((unsigned __int64)v3) & 1) != 0 )
  {
    if ( caml_gc_phase )
    {
      if ( (a3 & 1) != 0 )
        return 1LL;
    }
    else
    {
      caml_darken(v5);
      if ( (a3 & 1) != 0 )
        return 1LL;
    }
    if ( a3 < caml_young_end
      && a3 > caml_young_start
      && ((v5 & 1) != 0 || caml_young_end <= v5 || caml_young_start >= v5) )
    {
      v6 = (unsigned __int64 **)qword_65CD18;
      if ( qword_65CD18 >= (unsigned __int64)qword_65CD20 )
      {
        caml_realloc_ref_table((__int64)&caml_ref_table);
        v6 = (unsigned __int64 **)qword_65CD18;
      }
      *v6 = v3;
      qword_65CD18 = (__int64)(v6 + 1);
    }
  }
  return 1LL;
}
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CD18: using guessed type __int64 qword_65CD18;
// 65CD20: using guessed type __int64 qword_65CD20;
// 6633B0: using guessed type int caml_gc_phase;

//----- (0000000000431EB0) ----------------------------------------------------
__int64 __fastcall caml_array_unsafe_set(__int64 a1, __int64 a2, _QWORD *a3)
{
  if ( *(_BYTE *)(a1 - 8) != 0xFE )
    return caml_array_unsafe_set_addr(a1, a2, (unsigned __int64)a3);
  *(_QWORD *)(a1 + 8 * (a2 >> 1)) = *a3;
  return 1LL;
}

//----- (0000000000431ED0) ----------------------------------------------------
__int64 __fastcall caml_array_set_float(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v3; // rsi

  v3 = a2 >> 1;
  if ( v3 < 0 || (unsigned __int64)v3 >= *(_QWORD *)(a1 - 8) >> 10 )
    caml_array_bound_error();
  *(_QWORD *)(a1 + 8 * v3) = *a3;
  return 1LL;
}

//----- (0000000000431F00) ----------------------------------------------------
__int64 __fastcall caml_array_set_addr(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rsi
  unsigned __int64 *v5; // rbx
  unsigned __int64 v6; // r12
  unsigned __int64 **v7; // rax

  v4 = a2 >> 1;
  if ( v4 < 0 || (unsigned __int64)v4 >= *(_QWORD *)(a1 - 8) >> 10 )
    caml_array_bound_error();
  v5 = (unsigned __int64 *)(a1 + 8 * v4);
  v6 = *v5;
  *v5 = a3;
  if ( (caml_page_table_lookup((unsigned __int64)v5) & 1) != 0 )
  {
    if ( caml_gc_phase )
    {
      if ( (a3 & 1) != 0 )
        return 1LL;
    }
    else
    {
      caml_darken(v6);
      if ( (a3 & 1) != 0 )
        return 1LL;
    }
    if ( a3 < caml_young_end
      && a3 > caml_young_start
      && ((v6 & 1) != 0 || caml_young_end <= v6 || caml_young_start >= v6) )
    {
      v7 = (unsigned __int64 **)qword_65CD18;
      if ( qword_65CD18 >= (unsigned __int64)qword_65CD20 )
      {
        caml_realloc_ref_table((__int64)&caml_ref_table);
        v7 = (unsigned __int64 **)qword_65CD18;
      }
      *v7 = v5;
      qword_65CD18 = (__int64)(v7 + 1);
    }
  }
  return 1LL;
}
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CD18: using guessed type __int64 qword_65CD18;
// 65CD20: using guessed type __int64 qword_65CD20;
// 6633B0: using guessed type int caml_gc_phase;

//----- (0000000000431FF0) ----------------------------------------------------
__int64 __fastcall caml_array_set(__int64 a1, __int64 a2, _QWORD *a3)
{
  if ( *(_BYTE *)(a1 - 8) == 0xFE )
    return caml_array_set_float(a1, a2, a3);
  else
    return caml_array_set_addr(a1, a2, (unsigned __int64)a3);
}

//----- (0000000000432010) ----------------------------------------------------
_QWORD *__fastcall caml_array_get_float(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // rax
  __int64 v4; // rbx
  _QWORD *v5; // rdx
  _QWORD *result; // rax

  v2 = a2 >> 1;
  if ( v2 < 0 || (unsigned __int64)v2 >= *(_QWORD *)(a1 - 8) >> 10 )
    caml_array_bound_error();
  v3 = caml_young_ptr;
  v4 = *(_QWORD *)(a1 + 8 * v2);
  v5 = (_QWORD *)(caml_young_ptr - 16);
  caml_young_ptr -= 16LL;
  if ( caml_young_ptr < (unsigned __int64)caml_young_limit )
  {
    caml_young_ptr = v3;
    caml_minor_collection();
    v5 = (_QWORD *)(caml_young_ptr - 16);
    caml_young_ptr -= 16LL;
  }
  *v5 = 2045LL;
  result = v5 + 1;
  v5[1] = v4;
  return result;
}
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (0000000000432080) ----------------------------------------------------
__int64 __fastcall caml_array_get_addr(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi

  v2 = a2 >> 1;
  if ( v2 < 0 || (unsigned __int64)v2 >= *(_QWORD *)(a1 - 8) >> 10 )
    caml_array_bound_error();
  return *(_QWORD *)(a1 + 8 * v2);
}

//----- (00000000004320B0) ----------------------------------------------------
_QWORD *__fastcall caml_array_get(__int64 a1, __int64 a2)
{
  if ( *(_BYTE *)(a1 - 8) == 0xFE )
    return caml_array_get_float(a1, a2);
  else
    return (_QWORD *)caml_array_get_addr(a1, a2);
}

//----- (00000000004320D0) ----------------------------------------------------
__int64 caml_channel_binary_mode()
{
  return 1LL;
}

//----- (00000000004320E0) ----------------------------------------------------
__int64 __fastcall caml_pos_out(__int64 a1)
{
  return *(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 24) - (a1 + 80);
}

//----- (00000000004320F0) ----------------------------------------------------
__int64 __fastcall caml_pos_in(_QWORD *a1)
{
  return a1[1] + a1[3] - a1[4];
}

//----- (0000000000432100) ----------------------------------------------------
__int64 __fastcall compare_channel(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned __int64 v3; // rdx

  result = 0LL;
  v3 = *(_QWORD *)(a2 + 8);
  if ( *(_QWORD *)(a1 + 8) != v3 )
    return *(_QWORD *)(a1 + 8) < v3 ? -1 : 1;
  return result;
}

//----- (0000000000432120) ----------------------------------------------------
__int64 caml_ml_set_binary_mode()
{
  return 1LL;
}
// 432120: using guessed type __int64 __fastcall caml_ml_set_binary_mode();

//----- (0000000000432130) ----------------------------------------------------
_QWORD *__fastcall caml_ml_pos_in_64(__int64 a1)
{
  return caml_copy_int64(
           *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL)
         + *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24LL)
         - *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL));
}

//----- (0000000000432150) ----------------------------------------------------
_QWORD *__fastcall caml_ml_pos_out_64(__int64 a1)
{
  return caml_copy_int64(
           *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL)
         + *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24LL)
         - (*(_QWORD *)(a1 + 8)
          + 80LL));
}

//----- (0000000000432170) ----------------------------------------------------
__int64 __fastcall caml_ml_pos_in(__int64 a1)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL)
     + *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24LL)
     - *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32LL);
  if ( v1 > 0x3FFFFFFFFFFFFFFFLL )
  {
    *__errno_location() = 75;
    caml_sys_error((void *)1);
  }
  return 2 * v1 + 1;
}

//----- (00000000004321B0) ----------------------------------------------------
__int64 __fastcall caml_ml_pos_out(__int64 a1)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8LL) + *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24LL) - (*(_QWORD *)(a1 + 8) + 80LL);
  if ( v1 > 0x3FFFFFFFFFFFFFFFLL )
  {
    *__errno_location() = 75;
    caml_sys_error((void *)1);
  }
  return 2 * v1 + 1;
}

//----- (00000000004321F0) ----------------------------------------------------
__int64 __fastcall caml_channel_descriptor(__int64 a1)
{
  int v1; // ebx

  v1 = **(_DWORD **)(a1 + 8);
  if ( v1 == -1 )
  {
    *__errno_location() = 9;
    caml_sys_error((void *)1);
  }
  return 2LL * v1 + 1;
}

//----- (0000000000432230) ----------------------------------------------------
__int64 __fastcall caml_ml_close_channel(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // eax
  __int64 v3; // rdx
  __int64 v5; // rax

  v1 = *(_QWORD *)(a1 + 8);
  if ( *(_DWORD *)v1 == -1 )
  {
    v5 = *(_QWORD *)(v1 + 16);
    *(_QWORD *)(v1 + 32) = v5;
    *(_QWORD *)(v1 + 24) = v5;
    return 1LL;
  }
  else
  {
    v2 = close(*(_DWORD *)v1);
    v3 = *(_QWORD *)(v1 + 16);
    *(_DWORD *)v1 = -1;
    *(_QWORD *)(v1 + 32) = v3;
    *(_QWORD *)(v1 + 24) = v3;
    if ( v2 == -1 )
      caml_sys_error((void *)1);
    return 1LL;
  }
}

//----- (0000000000432290) ----------------------------------------------------
_QWORD *__fastcall caml_alloc_channel(__int64 a1)
{
  _QWORD *result; // rax

  ++*(_DWORD *)(a1 + 72);
  result = caml_alloc_custom((__int64)&channel_operations, 8LL, 1uLL, 0x3E8uLL);
  result[1] = a1;
  return result;
}
// 658800: using guessed type char *channel_operations;

//----- (00000000004322C0) ----------------------------------------------------
__int64 caml_ml_out_channels_list()
{
  __int64 result; // rax
  __int64 v1; // rbx
  __int64 v2; // rbp
  __int64 v3[9]; // [rsp+0h] [rbp-78h] BYREF
  _QWORD *v4; // [rsp+48h] [rbp-30h] BYREF
  __int64 v5; // [rsp+50h] [rbp-28h] BYREF
  __int64 v6; // [rsp+58h] [rbp-20h] BYREF

  result = 1LL;
  v1 = caml_all_opened_channels;
  v2 = caml_local_roots;
  v6 = 1LL;
  caml_local_roots = (__int64)v3;
  if ( caml_all_opened_channels )
  {
    v5 = 0LL;
    v4 = 0LL;
    v3[0] = v2;
    v3[2] = 1LL;
    v3[3] = (__int64)&v6;
    v3[1] = 3LL;
    v3[4] = (__int64)&v5;
    v3[5] = (__int64)&v4;
    do
    {
      if ( !*(_QWORD *)(v1 + 32) )
      {
        v4 = caml_alloc_channel(v1);
        v5 = v6;
        v6 = (__int64)caml_alloc_small(2LL, 0);
        *(_QWORD *)v6 = v4;
        *(_QWORD *)(v6 + 8) = v5;
      }
      v1 = *(_QWORD *)(v1 + 48);
    }
    while ( v1 );
    result = v6;
  }
  caml_local_roots = v2;
  return result;
}
// 4322C0: using guessed type __int64 __fastcall caml_ml_out_channels_list();
// 658A68: using guessed type __int64 caml_local_roots;
// 65E608: using guessed type __int64 caml_all_opened_channels;

//----- (00000000004323A0) ----------------------------------------------------
void __fastcall caml_finalize_channel(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // eax
  bool v3; // zf
  __int64 v4; // rax
  __int64 v5; // rdx

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_DWORD *)(v1 + 72) - 1;
  v3 = *(_DWORD *)(v1 + 72) == 1;
  *(_DWORD *)(v1 + 72) = v2;
  if ( v2 < 0 || v3 )
  {
    if ( caml_channel_mutex_free )
      caml_channel_mutex_free(v1);
    v4 = *(_QWORD *)(v1 + 56);
    if ( v4 )
    {
      *(_QWORD *)(v4 + 48) = *(_QWORD *)(v1 + 48);
      v5 = *(_QWORD *)(v1 + 48);
      if ( v5 )
        *(_QWORD *)(v5 + 56) = v4;
    }
    else
    {
      caml_all_opened_channels = *(_QWORD *)(caml_all_opened_channels + 48);
      if ( caml_all_opened_channels )
        *(_QWORD *)(caml_all_opened_channels + 56) = 0LL;
    }
    caml_stat_free((void *)v1);
  }
}
// 65E5E8: using guessed type __int64 (__fastcall *caml_channel_mutex_free)(_QWORD);
// 65E608: using guessed type __int64 caml_all_opened_channels;

//----- (0000000000432420) ----------------------------------------------------
void __fastcall caml_close_channel(void *ptr)
{
  __int64 v1; // rax
  __int64 v2; // rdx

  close(*(_DWORD *)ptr);
  if ( *((int *)ptr + 18) <= 0 )
  {
    if ( caml_channel_mutex_free )
      caml_channel_mutex_free(ptr);
    v1 = *((_QWORD *)ptr + 7);
    if ( v1 )
    {
      *(_QWORD *)(v1 + 48) = *((_QWORD *)ptr + 6);
      v2 = *((_QWORD *)ptr + 6);
      if ( v2 )
        *(_QWORD *)(v2 + 56) = v1;
    }
    else
    {
      caml_all_opened_channels = *(_QWORD *)(caml_all_opened_channels + 48);
      if ( caml_all_opened_channels )
        *(_QWORD *)(caml_all_opened_channels + 56) = 0LL;
    }
    caml_stat_free(ptr);
  }
}
// 65E5E8: using guessed type __int64 (__fastcall *caml_channel_mutex_free)(_QWORD);
// 65E608: using guessed type __int64 caml_all_opened_channels;

//----- (00000000004324A0) ----------------------------------------------------
__off64_t __fastcall caml_seek_in(__int64 a1, __off64_t a2)
{
  __off64_t v2; // rdx
  __int64 v3; // r12
  __int64 v4; // rcx
  __off64_t result; // rax

  v2 = *(_QWORD *)(a1 + 8);
  v3 = a1 + 80;
  v4 = *(_QWORD *)(a1 + 32);
  result = a1 + 80 + v2 - v4;
  if ( result <= a2 && v2 >= a2 )
  {
    *(_QWORD *)(a1 + 24) = a2 - v2 + v4;
  }
  else
  {
    result = lseek64(*(_DWORD *)a1, a2, 0);
    if ( result != a2 )
      caml_sys_error((void *)1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 32) = v3;
    *(_QWORD *)(a1 + 24) = v3;
  }
  return result;
}

//----- (0000000000432520) ----------------------------------------------------
__int64 __fastcall caml_ml_seek_in_64(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  __int64 v5; // [rsp+0h] [rbp-68h] BYREF
  __int64 v6; // [rsp+8h] [rbp-60h] BYREF
  __int64 v7[11]; // [rsp+10h] [rbp-58h] BYREF

  v2 = caml_local_roots;
  v6 = a1;
  v5 = a2;
  v7[2] = 1LL;
  v7[1] = 2LL;
  caml_local_roots = (__int64)v7;
  v7[0] = v2;
  v7[4] = (__int64)&v5;
  v7[3] = (__int64)&v6;
  v3 = *(_QWORD *)(a1 + 8);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_QWORD *)(a1 + 8));
  caml_seek_in(v3, *(_QWORD *)(v5 + 8));
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1LL;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (00000000004325C0) ----------------------------------------------------
__int64 __fastcall caml_ml_seek_in(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  __int64 v5; // [rsp+0h] [rbp-68h] BYREF
  __int64 v6; // [rsp+8h] [rbp-60h] BYREF
  __int64 v7[11]; // [rsp+10h] [rbp-58h] BYREF

  v2 = caml_local_roots;
  v6 = a1;
  v5 = a2;
  v7[2] = 1LL;
  v7[1] = 2LL;
  caml_local_roots = (__int64)v7;
  v7[0] = v2;
  v7[4] = (__int64)&v5;
  v7[3] = (__int64)&v6;
  v3 = *(_QWORD *)(a1 + 8);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_QWORD *)(a1 + 8));
  caml_seek_in(v3, v5 >> 1);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1LL;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000432650) ----------------------------------------------------
__off64_t __fastcall caml_channel_size(__int64 a1)
{
  __off64_t v1; // rbp

  v1 = lseek64(*(_DWORD *)a1, 0LL, 2);
  if ( v1 == -1 || lseek64(*(_DWORD *)a1, *(_QWORD *)(a1 + 8), 0) != *(_QWORD *)(a1 + 8) )
    caml_sys_error((void *)1);
  return v1;
}

//----- (00000000004326B0) ----------------------------------------------------
_QWORD *__fastcall caml_ml_channel_size_64(__int64 a1)
{
  __int64 v1; // rax

  v1 = caml_channel_size(*(_QWORD *)(a1 + 8));
  return caml_copy_int64(v1);
}

//----- (00000000004326D0) ----------------------------------------------------
__off64_t __fastcall caml_ml_channel_size(__int64 a1)
{
  __off64_t v1; // rbx

  v1 = caml_channel_size(*(_QWORD *)(a1 + 8));
  if ( v1 > 0x3FFFFFFFFFFFFFFFLL )
  {
    *__errno_location() = 75;
    caml_sys_error((void *)1);
  }
  return 2 * v1 + 1;
}

//----- (0000000000432710) ----------------------------------------------------
__int64 __fastcall caml_do_read(int fd, void *buf, size_t nbytes)
{
  size_t v3; // rbx
  unsigned int v4; // er13

  v3 = (unsigned int)nbytes;
  while ( 1 )
  {
    caml_enter_blocking_section();
    v4 = read(fd, buf, v3);
    caml_leave_blocking_section();
    if ( v4 != -1 )
      break;
    if ( *__errno_location() != 4 )
      caml_sys_io_error((void *)1);
  }
  return v4;
}

//----- (0000000000432770) ----------------------------------------------------
__int64 __fastcall caml_ml_input(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r13
  __int64 v5; // rbx
  size_t v6; // rbp
  const void *v7; // rsi
  __int64 v8; // r12
  int v9; // eax
  int v11; // eax
  void *v12; // rdi
  __int64 v13; // [rsp+0h] [rbp-88h] BYREF
  __int64 v14; // [rsp+8h] [rbp-80h] BYREF
  __int64 v15; // [rsp+10h] [rbp-78h] BYREF
  __int64 v16; // [rsp+18h] [rbp-70h] BYREF
  __int64 v17[8]; // [rsp+20h] [rbp-68h] BYREF

  v4 = caml_local_roots;
  v14 = a3;
  v16 = a1;
  v15 = a2;
  caml_local_roots = (__int64)v17;
  v13 = a4;
  v17[0] = v4;
  v17[2] = 1LL;
  v17[3] = (__int64)&v16;
  v17[1] = 4LL;
  v17[6] = (__int64)&v13;
  v5 = *(_QWORD *)(a1 + 8);
  v17[4] = (__int64)&v15;
  v17[5] = (__int64)&v14;
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v5);
  LODWORD(v6) = 0x7FFFFFFF;
  v7 = *(const void **)(v5 + 24);
  v8 = v14 >> 1;
  if ( v13 >> 1 < 0x7FFFFFFF )
    LODWORD(v6) = v13 >> 1;
  v9 = *(_QWORD *)(v5 + 32) - (_DWORD)v7;
  if ( (int)v6 <= v9 )
  {
    v6 = (int)v6;
    goto LABEL_8;
  }
  if ( v9 > 0 )
  {
    v6 = v9;
LABEL_8:
    memmove((void *)(v15 + v8), v7, v6);
    *(_QWORD *)(v5 + 24) += v6;
    goto LABEL_9;
  }
  v11 = caml_do_read(*(_DWORD *)v5, (void *)(v5 + 80), (unsigned int)*(_QWORD *)(v5 + 16) - ((_DWORD)v5 + 80));
  *(_QWORD *)(v5 + 8) += v11;
  if ( (int)v6 > v11 )
    LODWORD(v6) = v11;
  v12 = (void *)(v15 + v8);
  v6 = (int)v6;
  *(_QWORD *)(v5 + 32) = v5 + v11 + 80;
  memmove(v12, (const void *)(v5 + 80), (int)v6);
  *(_QWORD *)(v5 + 24) = v5 + (int)v6 + 80;
LABEL_9:
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v5);
  caml_local_roots = v4;
  return 2 * v6 + 1;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (00000000004328F0) ----------------------------------------------------
signed __int64 __fastcall caml_input_scan_line(__int64 a1)
{
  char *v1; // r12
  int v2; // er13
  char *v3; // rax
  char *v4; // rbp
  unsigned __int64 v5; // rdx
  int v6; // eax
  char v7; // dl
  char *v8; // rsi
  __int64 v9; // rdx

  v1 = (char *)(a1 + 80);
  v2 = a1 + 80;
  v3 = *(char **)(a1 + 24);
  v4 = v3;
  while ( 1 )
  {
    v8 = *(char **)(a1 + 32);
    if ( v4 < v8 )
      goto LABEL_5;
    if ( v1 < v3 )
    {
      memmove(v1, v3, *(_QWORD *)(a1 + 32) - (_QWORD)v3);
      v9 = -(__int64)(int)(*(_QWORD *)(a1 + 24) - v2);
      v8 = (char *)(*(_QWORD *)(a1 + 32) - (int)(*(_QWORD *)(a1 + 24) - v2));
      v3 = (char *)(*(_QWORD *)(a1 + 24) - (int)(*(_QWORD *)(a1 + 24) - v2));
      *(_QWORD *)(a1 + 24) = v3;
      v4 += v9;
      *(_QWORD *)(a1 + 32) = v8;
    }
    v5 = *(_QWORD *)(a1 + 16);
    if ( v5 <= (unsigned __int64)v8 )
      return v3 - v8;
    v6 = caml_do_read(*(_DWORD *)a1, v8, (unsigned int)(v5 - (_DWORD)v8));
    if ( !v6 )
      return *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 8) += v6;
    *(_QWORD *)(a1 + 32) += v6;
    v3 = *(char **)(a1 + 24);
LABEL_5:
    v7 = *v4++;
    if ( v7 == 10 )
      return v4 - v3;
  }
}

//----- (00000000004329C0) ----------------------------------------------------
__int64 __fastcall caml_ml_input_scan_line(__int64 a1)
{
  __int64 v1; // rbp
  __int64 v2; // rbx
  signed __int64 v3; // r12
  __int64 v5; // [rsp+8h] [rbp-60h] BYREF
  __int64 v6[8]; // [rsp+10h] [rbp-58h] BYREF

  v1 = caml_local_roots;
  v5 = a1;
  v6[2] = 1LL;
  v6[1] = 1LL;
  caml_local_roots = (__int64)v6;
  v6[0] = v1;
  v2 = *(_QWORD *)(a1 + 8);
  v6[3] = (__int64)&v5;
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v2);
  v3 = caml_input_scan_line(v2);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v2);
  caml_local_roots = v1;
  return 2 * v3 + 1;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000432A60) ----------------------------------------------------
__int64 __fastcall caml_getblock(__int64 a1, void *a2, __int64 a3)
{
  int v3; // ebp
  const void *v5; // rsi
  int v6; // er12
  void *v8; // r12
  int v9; // eax

  v3 = 0x7FFFFFFF;
  v5 = *(const void **)(a1 + 24);
  if ( a3 < 0x7FFFFFFF )
    v3 = a3;
  v6 = *(_QWORD *)(a1 + 32) - (_DWORD)v5;
  if ( v3 <= v6 )
  {
    memmove(a2, v5, v3);
    *(_QWORD *)(a1 + 24) += v3;
  }
  else if ( v6 <= 0 )
  {
    v8 = (void *)(a1 + 80);
    v9 = caml_do_read(*(_DWORD *)a1, v8, (unsigned int)*(_QWORD *)(a1 + 16) - (unsigned int)v8);
    *(_QWORD *)(a1 + 8) += v9;
    if ( v3 > v9 )
      v3 = v9;
    *(_QWORD *)(a1 + 32) = a1 + v9 + 80;
    memmove(a2, v8, v3);
    *(_QWORD *)(a1 + 24) = a1 + v3 + 80;
  }
  else
  {
    memmove(a2, v5, v6);
    *(_QWORD *)(a1 + 24) += v6;
    return (unsigned int)v6;
  }
  return (unsigned int)v3;
}

//----- (0000000000432B50) ----------------------------------------------------
_BOOL8 __fastcall caml_really_getblock(__int64 a1, char *a2, __int64 a3)
{
  __int64 v4; // rbx
  int v5; // eax

  v4 = a3;
  if ( a3 > 0 )
  {
    while ( 1 )
    {
      v5 = caml_getblock(a1, a2, v4);
      if ( !v5 )
        break;
      v4 -= v5;
      if ( v4 <= 0 )
        break;
      a2 += v5;
    }
  }
  return v4 == 0;
}

//----- (0000000000432BA0) ----------------------------------------------------
__int64 __fastcall caml_refill(__int64 a1)
{
  int v1; // eax

  v1 = caml_do_read(*(_DWORD *)a1, (void *)(a1 + 80), (unsigned int)*(_QWORD *)(a1 + 16) - ((_DWORD)a1 + 80));
  if ( !v1 )
    caml_raise_end_of_file();
  *(_QWORD *)(a1 + 8) += v1;
  *(_QWORD *)(a1 + 32) = a1 + v1 + 80;
  *(_QWORD *)(a1 + 24) = a1 + 81;
  return *(unsigned __int8 *)(a1 + 80);
}

//----- (0000000000432BE0) ----------------------------------------------------
__int64 __fastcall caml_ml_input_char(__int64 a1)
{
  __int64 v1; // rbp
  __int64 v2; // rbx
  unsigned __int8 *v3; // rax
  unsigned __int8 v4; // r12
  __int64 v6; // [rsp+8h] [rbp-60h] BYREF
  __int64 v7[8]; // [rsp+10h] [rbp-58h] BYREF

  v1 = caml_local_roots;
  v6 = a1;
  v7[2] = 1LL;
  v7[1] = 1LL;
  caml_local_roots = (__int64)v7;
  v7[0] = v1;
  v2 = *(_QWORD *)(a1 + 8);
  v7[3] = (__int64)&v6;
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v2);
  v3 = *(unsigned __int8 **)(v2 + 24);
  if ( (unsigned __int64)v3 >= *(_QWORD *)(v2 + 32) )
  {
    v4 = caml_refill(v2);
  }
  else
  {
    v4 = *v3;
    *(_QWORD *)(v2 + 24) = v3 + 1;
  }
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v2);
  caml_local_roots = v1;
  return 2LL * v4 + 1;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000432CA0) ----------------------------------------------------
__int64 __fastcall caml_getword(__int64 a1)
{
  unsigned int v1; // er12
  int i; // ebx
  unsigned __int8 *v3; // rdx
  int v4; // eax

  v1 = 0;
  for ( i = 0; i != 4; ++i )
  {
    v3 = *(unsigned __int8 **)(a1 + 24);
    if ( (unsigned __int64)v3 >= *(_QWORD *)(a1 + 32) )
    {
      v4 = (unsigned __int8)caml_refill(a1);
    }
    else
    {
      v4 = *v3;
      *(_QWORD *)(a1 + 24) = v3 + 1;
    }
    v1 = v4 + (v1 << 8);
  }
  return v1;
}

//----- (0000000000432CF0) ----------------------------------------------------
__int64 __fastcall caml_ml_input_int(__int64 a1)
{
  __int64 v1; // rbp
  __int64 v2; // rbx
  int v3; // er12
  __int64 v5; // [rsp+8h] [rbp-60h] BYREF
  __int64 v6[8]; // [rsp+10h] [rbp-58h] BYREF

  v1 = caml_local_roots;
  v5 = a1;
  v6[2] = 1LL;
  v6[1] = 1LL;
  caml_local_roots = (__int64)v6;
  v6[0] = v1;
  v2 = *(_QWORD *)(a1 + 8);
  v6[3] = (__int64)&v5;
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v2);
  v3 = caml_getword(v2);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v2);
  caml_local_roots = v1;
  return 2LL * v3 + 1;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000432D90) ----------------------------------------------------
__int64 __fastcall do_write(int fd, void *buf, int a3)
{
  unsigned int v4; // er14
  int v5; // eax
  bool v6; // zf
  bool v7; // sf
  bool v8; // of

  while ( 1 )
  {
    caml_enter_blocking_section();
    v4 = write(fd, buf, a3);
    caml_leave_blocking_section();
    if ( v4 != -1 )
      break;
    v5 = *__errno_location();
    if ( v5 != 4 )
    {
      v8 = __OFSUB__(a3, 1);
      v6 = a3 == 1;
      v7 = a3 - 1 < 0;
      a3 = 1;
      if ( v7 ^ v8 | v6 || v5 != 11 )
        caml_sys_io_error((void *)1);
    }
  }
  return v4;
}

//----- (0000000000432E10) ----------------------------------------------------
__int64 __fastcall caml_putblock(__int64 a1, const void *a2, __int64 a3)
{
  void *v4; // rdi
  unsigned int v5; // ebp
  int v6; // er12
  __int64 v7; // r12
  int v8; // er14
  int v9; // eax
  __int64 v10; // rbp

  if ( a3 > 2147483646 )
  {
    v4 = *(void **)(a1 + 24);
    v6 = *(_QWORD *)(a1 + 16) - (_DWORD)v4;
  }
  else
  {
    v4 = *(void **)(a1 + 24);
    v5 = a3;
    v6 = *(_QWORD *)(a1 + 16) - (_DWORD)v4;
    if ( (int)a3 < v6 )
    {
      v7 = (int)a3;
      memmove(v4, a2, (int)a3);
      *(_QWORD *)(a1 + 24) += v7;
      return v5;
    }
  }
  memmove(v4, a2, v6);
  v8 = *(_QWORD *)(a1 + 16) - (a1 + 80);
  v9 = do_write(*(_DWORD *)a1, (void *)(a1 + 80), v8);
  v10 = v9;
  if ( v8 > v9 )
    memmove((void *)(a1 + 80), (const void *)(a1 + 80 + v9), v8 - v9);
  *(_QWORD *)(a1 + 8) += v10;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) - v10;
  return (unsigned int)v6;
}

//----- (0000000000432EE0) ----------------------------------------------------
__int64 __fastcall caml_ml_output(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rbx
  __int64 v6; // r13
  __int64 v7; // r12
  __int64 v8; // rbp
  int v9; // eax
  __int64 v11; // [rsp+0h] [rbp-88h] BYREF
  __int64 v12; // [rsp+8h] [rbp-80h] BYREF
  __int64 v13; // [rsp+10h] [rbp-78h] BYREF
  __int64 v14; // [rsp+18h] [rbp-70h] BYREF
  __int64 v15[13]; // [rsp+20h] [rbp-68h] BYREF

  v5 = a4 >> 1;
  v6 = caml_local_roots;
  v12 = a3;
  v14 = a1;
  v13 = a2;
  v11 = a4;
  caml_local_roots = (__int64)v15;
  v15[0] = v6;
  v15[2] = 1LL;
  v15[3] = (__int64)&v14;
  v15[1] = 4LL;
  v15[6] = (__int64)&v11;
  v7 = *(_QWORD *)(a1 + 8);
  v15[4] = (__int64)&v13;
  v15[5] = (__int64)&v12;
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v7);
  if ( v5 > 0 )
  {
    v8 = a3 >> 1;
    do
    {
      v9 = caml_putblock(v7, (const void *)(v13 + v8), v5);
      v5 -= v9;
      v8 += v9;
    }
    while ( v5 > 0 );
  }
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v7);
  caml_local_roots = v6;
  return 1LL;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000432FC0) ----------------------------------------------------
__int64 __fastcall caml_ml_output_partial(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbp
  __int64 v5; // rbx
  int v6; // er12
  __int64 v8; // [rsp+0h] [rbp-78h] BYREF
  __int64 v9; // [rsp+8h] [rbp-70h] BYREF
  __int64 v10; // [rsp+10h] [rbp-68h] BYREF
  __int64 v11; // [rsp+18h] [rbp-60h] BYREF
  __int64 v12[11]; // [rsp+20h] [rbp-58h] BYREF

  v4 = caml_local_roots;
  v9 = a3;
  v11 = a1;
  v10 = a2;
  v8 = a4;
  caml_local_roots = (__int64)v12;
  v12[0] = v4;
  v12[2] = 1LL;
  v12[3] = (__int64)&v11;
  v12[1] = 4LL;
  v12[6] = (__int64)&v8;
  v5 = *(_QWORD *)(a1 + 8);
  v12[4] = (__int64)&v10;
  v12[5] = (__int64)&v9;
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v5);
  v6 = caml_putblock(v5, (const void *)(v10 + (v9 >> 1)), v8 >> 1);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v5);
  caml_local_roots = v4;
  return 2LL * v6 + 1;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000433090) ----------------------------------------------------
void __fastcall caml_really_putblock(__int64 a1, char *a2, __int64 a3)
{
  __int64 i; // rbx
  int v5; // eax

  for ( i = a3; i > 0; a2 += v5 )
  {
    v5 = caml_putblock(a1, a2, i);
    i -= v5;
  }
}

//----- (00000000004330D0) ----------------------------------------------------
_BOOL8 __fastcall caml_flush_partial(__int64 a1)
{
  char *v1; // rbp
  char *v2; // r13
  int v3; // er12
  int v4; // eax
  __int64 v5; // r13

  v1 = (char *)(a1 + 80);
  v2 = *(char **)(a1 + 24);
  v3 = (_DWORD)v2 - (a1 + 80);
  if ( v3 > 0 )
  {
    v4 = do_write(*(_DWORD *)a1, v1, v3);
    v5 = v4;
    *(_QWORD *)(a1 + 8) += v4;
    if ( v3 > v4 )
      memmove(v1, &v1[v4], v3 - v4);
    v2 = (char *)(*(_QWORD *)(a1 + 24) - v5);
    *(_QWORD *)(a1 + 24) = v2;
  }
  return v2 == v1;
}

//----- (0000000000433160) ----------------------------------------------------
__int64 __fastcall caml_ml_output_char(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  _BYTE *v4; // rax
  __int64 v6; // [rsp+0h] [rbp-68h] BYREF
  __int64 v7; // [rsp+8h] [rbp-60h] BYREF
  __int64 v8[11]; // [rsp+10h] [rbp-58h] BYREF

  v2 = caml_local_roots;
  v7 = a1;
  v6 = a2;
  v8[2] = 1LL;
  v8[1] = 2LL;
  caml_local_roots = (__int64)v8;
  v8[0] = v2;
  v8[4] = (__int64)&v6;
  v8[3] = (__int64)&v7;
  v3 = *(_QWORD *)(a1 + 8);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_QWORD *)(a1 + 8));
  v4 = *(_BYTE **)(v3 + 24);
  if ( (unsigned __int64)v4 >= *(_QWORD *)(v3 + 16) )
  {
    caml_flush_partial(v3);
    v4 = *(_BYTE **)(v3 + 24);
  }
  *v4 = v6 >> 1;
  *(_QWORD *)(v3 + 24) = v4 + 1;
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1LL;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000433210) ----------------------------------------------------
unsigned __int64 __fastcall caml_ml_flush_partial(__int64 a1)
{
  _DWORD *v1; // rbx
  __int64 v2; // rbp
  bool v3; // zf
  _BOOL4 v4; // er12
  __int64 v6; // [rsp+8h] [rbp-60h] BYREF
  __int64 v7[8]; // [rsp+10h] [rbp-58h] BYREF

  v1 = *(_DWORD **)(a1 + 8);
  v2 = caml_local_roots;
  v6 = a1;
  v3 = *v1 == -1;
  caml_local_roots = (__int64)v7;
  if ( v3 )
  {
    caml_local_roots = v2;
    return 3LL;
  }
  else
  {
    v7[0] = v2;
    v7[2] = 1LL;
    v7[1] = 1LL;
    v7[3] = (__int64)&v6;
    if ( caml_channel_mutex_lock )
      caml_channel_mutex_lock(v1);
    v4 = caml_flush_partial((__int64)v1);
    if ( caml_channel_mutex_unlock )
      caml_channel_mutex_unlock(v1);
    caml_local_roots = v2;
    return (-(__int64)!v4 & 0xFFFFFFFFFFFFFFFELL) + 3;
  }
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (00000000004332D0) ----------------------------------------------------
_BYTE *__fastcall caml_putword(__int64 a1, int a2)
{
  _BYTE *v2; // rax
  _BYTE *v3; // rax
  bool v4; // cf
  _BYTE *v5; // rax
  _BYTE *v6; // rax
  _BYTE *result; // rax

  v2 = *(_BYTE **)(a1 + 24);
  if ( (unsigned __int64)v2 >= *(_QWORD *)(a1 + 16) )
  {
    caml_flush_partial(a1);
    v2 = *(_BYTE **)(a1 + 24);
  }
  *v2 = HIBYTE(a2);
  v3 = v2 + 1;
  v4 = (unsigned __int64)v3 < *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 24) = v3;
  if ( !v4 )
  {
    caml_flush_partial(a1);
    v3 = *(_BYTE **)(a1 + 24);
  }
  *v3 = BYTE2(a2);
  v5 = v3 + 1;
  v4 = (unsigned __int64)v5 < *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 24) = v5;
  if ( !v4 )
  {
    caml_flush_partial(a1);
    v5 = *(_BYTE **)(a1 + 24);
  }
  *v5 = BYTE1(a2);
  v6 = v5 + 1;
  v4 = (unsigned __int64)v6 < *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 24) = v6;
  if ( !v4 )
  {
    caml_flush_partial(a1);
    v6 = *(_BYTE **)(a1 + 24);
  }
  *v6 = a2;
  result = v6 + 1;
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

//----- (0000000000433380) ----------------------------------------------------
__int64 __fastcall caml_ml_output_int(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  __int64 v5; // [rsp+0h] [rbp-68h] BYREF
  __int64 v6; // [rsp+8h] [rbp-60h] BYREF
  __int64 v7[11]; // [rsp+10h] [rbp-58h] BYREF

  v2 = caml_local_roots;
  v6 = a1;
  v5 = a2;
  v7[2] = 1LL;
  v7[1] = 2LL;
  caml_local_roots = (__int64)v7;
  v7[0] = v2;
  v7[4] = (__int64)&v5;
  v7[3] = (__int64)&v6;
  v3 = *(_QWORD *)(a1 + 8);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_QWORD *)(a1 + 8));
  caml_putword(v3, v5 >> 1);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1LL;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000433410) ----------------------------------------------------
_BOOL8 __fastcall caml_flush(__int64 a1)
{
  _BOOL8 result; // rax

  do
    result = caml_flush_partial(a1);
  while ( !result );
  return result;
}

//----- (0000000000433430) ----------------------------------------------------
__int64 __fastcall caml_ml_flush(__int64 a1)
{
  _DWORD *v1; // rbx
  __int64 v2; // rbp
  bool v3; // zf
  __int64 v5; // [rsp+8h] [rbp-60h] BYREF
  __int64 v6[11]; // [rsp+10h] [rbp-58h] BYREF

  v1 = *(_DWORD **)(a1 + 8);
  v2 = caml_local_roots;
  v5 = a1;
  v3 = *v1 == -1;
  caml_local_roots = (__int64)v6;
  if ( !v3 )
  {
    v6[0] = v2;
    v6[2] = 1LL;
    v6[1] = 1LL;
    v6[3] = (__int64)&v5;
    if ( caml_channel_mutex_lock )
      caml_channel_mutex_lock(v1);
    caml_flush((__int64)v1);
    if ( caml_channel_mutex_unlock )
      caml_channel_mutex_unlock(v1);
  }
  caml_local_roots = v2;
  return 1LL;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (00000000004334C0) ----------------------------------------------------
__off64_t __fastcall caml_seek_out(__int64 a1, __off64_t a2)
{
  __off64_t result; // rax

  caml_flush(a1);
  result = lseek64(*(_DWORD *)a1, a2, 0);
  if ( result != a2 )
    caml_sys_error((void *)1);
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

//----- (0000000000433510) ----------------------------------------------------
__int64 __fastcall caml_ml_seek_out_64(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  __int64 v5; // [rsp+0h] [rbp-68h] BYREF
  __int64 v6; // [rsp+8h] [rbp-60h] BYREF
  __int64 v7[11]; // [rsp+10h] [rbp-58h] BYREF

  v2 = caml_local_roots;
  v6 = a1;
  v5 = a2;
  v7[2] = 1LL;
  v7[1] = 2LL;
  caml_local_roots = (__int64)v7;
  v7[0] = v2;
  v7[4] = (__int64)&v5;
  v7[3] = (__int64)&v6;
  v3 = *(_QWORD *)(a1 + 8);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_QWORD *)(a1 + 8));
  caml_seek_out(v3, *(_QWORD *)(v5 + 8));
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1LL;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (00000000004335B0) ----------------------------------------------------
__int64 __fastcall caml_ml_seek_out(__int64 a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  __int64 v5; // [rsp+0h] [rbp-68h] BYREF
  __int64 v6; // [rsp+8h] [rbp-60h] BYREF
  __int64 v7[11]; // [rsp+10h] [rbp-58h] BYREF

  v2 = caml_local_roots;
  v6 = a1;
  v5 = a2;
  v7[2] = 1LL;
  v7[1] = 2LL;
  caml_local_roots = (__int64)v7;
  v7[0] = v2;
  v7[4] = (__int64)&v5;
  v7[3] = (__int64)&v6;
  v3 = *(_QWORD *)(a1 + 8);
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(*(_QWORD *)(a1 + 8));
  caml_seek_out(v3, v5 >> 1);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v3);
  caml_local_roots = v2;
  return 1LL;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000433640) ----------------------------------------------------
_QWORD *__fastcall caml_open_descriptor_in(int fd)
{
  _QWORD *v1; // rbx
  __int64 v2; // rax

  v1 = caml_stat_alloc(0x1050uLL);
  *(_DWORD *)v1 = fd;
  v1[1] = lseek64(fd, 0LL, 1);
  v1[5] = 0LL;
  *((_DWORD *)v1 + 16) = 0;
  *((_DWORD *)v1 + 17) = 0;
  v1[4] = v1 + 10;
  v1[3] = v1 + 10;
  *((_DWORD *)v1 + 18) = 0;
  *((_DWORD *)v1 + 19) = 0;
  v1[2] = v1 + 522;
  v2 = caml_all_opened_channels;
  v1[7] = 0LL;
  v1[6] = v2;
  if ( v2 )
    *(_QWORD *)(v2 + 56) = v1;
  caml_all_opened_channels = (__int64)v1;
  return v1;
}
// 65E608: using guessed type __int64 caml_all_opened_channels;

//----- (00000000004336E0) ----------------------------------------------------
_QWORD *__fastcall caml_ml_open_descriptor_in(__int64 a1)
{
  _QWORD *v1; // rax

  v1 = caml_open_descriptor_in(a1 >> 1);
  return caml_alloc_channel((__int64)v1);
}

//----- (0000000000433700) ----------------------------------------------------
_QWORD *__fastcall caml_open_descriptor_out(int a1)
{
  _QWORD *result; // rax

  result = caml_open_descriptor_in(a1);
  result[4] = 0LL;
  return result;
}

//----- (0000000000433720) ----------------------------------------------------
_QWORD *__fastcall caml_ml_open_descriptor_out(__int64 a1)
{
  _QWORD *v1; // rax

  v1 = caml_open_descriptor_out(a1 >> 1);
  return caml_alloc_channel((__int64)v1);
}

//----- (0000000000433740) ----------------------------------------------------
void extern_replay_trail()
{
  char *v0; // rdi
  unsigned __int64 v1; // rsi
  _QWORD *v2; // rdx
  _QWORD *v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rax
  char *v6; // rbx

  v0 = (char *)extern_trail_block;
  v1 = extern_trail_cur;
  while ( 1 )
  {
    v2 = v0 + 8;
    if ( v1 > (unsigned __int64)(v0 + 8) )
    {
      do
      {
        v3 = (_QWORD *)(*v2 & 0xFFFFFFFFFFFFFFFCLL);
        v4 = *(v3 - 1);
        BYTE1(v4) &= 0xFCu;
        *(v3 - 1) = ((*v2 & 3LL) << 8) | v4;
        v5 = v2[1];
        v2 += 2;
        *v3 = v5;
      }
      while ( v1 > (unsigned __int64)v2 );
    }
    if ( v0 == (char *)&extern_trail_first )
      break;
    v6 = *(char **)v0;
    free(v0);
    v1 = (unsigned __int64)(v6 + 16408);
    v0 = v6;
  }
  extern_trail_block = &extern_trail_first;
  extern_trail_cur = (__int64)&unk_65E648;
}
// 662660: using guessed type __int64 extern_trail_cur;

//----- (00000000004337D0) ----------------------------------------------------
void free_extern_output()
{
  _QWORD *v0; // rdi
  _QWORD *v1; // rbx

  if ( !extern_userprovided_output )
  {
    v0 = extern_output_first;
    if ( extern_output_first )
    {
      do
      {
        v1 = (_QWORD *)*v0;
        free(v0);
        v0 = v1;
      }
      while ( v1 );
    }
    extern_output_first = 0LL;
  }
}
// 662670: using guessed type __int64 extern_userprovided_output;

//----- (0000000000433810) ----------------------------------------------------
void __noreturn extern_out_of_memory()
{
  extern_replay_trail();
  free_extern_output();
  caml_raise_out_of_memory();
}

//----- (0000000000433830) ----------------------------------------------------
__int64 __fastcall grow_extern_output(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v2; // rax
  void *v3; // rdx
  __int64 result; // rax

  if ( extern_userprovided_output )
  {
    extern_replay_trail();
    caml_failwith("Marshal.to_buffer: buffer overflow");
  }
  v1 = 8100LL;
  *(_QWORD *)(extern_output_block + 8) = extern_ptr;
  if ( a1 > 4050 )
  {
    v1 = a1 + 8100;
    v2 = malloc(a1 + 8120);
    if ( v2 )
      goto LABEL_4;
LABEL_6:
    extern_out_of_memory();
  }
  v2 = malloc(0x1FB8uLL);
  if ( !v2 )
    goto LABEL_6;
LABEL_4:
  *(_QWORD *)extern_output_block = v2;
  extern_output_block = (__int64)v2;
  v3 = v2 + 2;
  *v2 = 0LL;
  result = (__int64)v2 + v1 + 16;
  extern_ptr = v3;
  extern_limit = result;
  return result;
}
// 662670: using guessed type __int64 extern_userprovided_output;
// 662680: using guessed type __int64 extern_limit;
// 662690: using guessed type __int64 extern_output_block;

//----- (00000000004338F0) ----------------------------------------------------
char *__fastcall caml_serialize_block_8(char *a1, __int64 a2)
{
  char *v3; // r9
  char *result; // rax
  __int64 v5; // rdx
  char v6; // di
  char v7; // cl
  char v8; // r8
  char v9; // di
  char v10; // cl
  char v11; // r8

  v3 = (char *)extern_ptr;
  result = (char *)extern_ptr + 8 * a2;
  if ( extern_limit < (unsigned __int64)result )
  {
    result = (char *)grow_extern_output(8 * a2);
    v3 = (char *)extern_ptr;
  }
  if ( a2 > 0 )
  {
    result = v3;
    v5 = a2;
    do
    {
      v6 = *a1;
      v7 = a1[1];
      *result = a1[7];
      v8 = a1[6];
      result[7] = v6;
      result[6] = v7;
      result[1] = v8;
      v9 = a1[2];
      v10 = a1[3];
      result[2] = a1[5];
      v11 = a1[4];
      a1 += 8;
      result[5] = v9;
      result[4] = v10;
      result[3] = v11;
      result += 8;
      --v5;
    }
    while ( v5 );
    v3 += 8 * a2;
  }
  extern_ptr = v3;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (00000000004339A0) ----------------------------------------------------
char *__fastcall caml_serialize_int_8(__int64 a1)
{
  __int64 v2; // [rsp+8h] [rbp-10h] BYREF

  v2 = a1;
  return caml_serialize_block_8((char *)&v2, 1LL);
}

//----- (00000000004339C0) ----------------------------------------------------
char *__fastcall caml_serialize_block_4(__int64 a1, __int64 a2)
{
  void *v3; // rdx
  char *result; // rax
  __int64 v5; // rcx
  char v6; // r8
  char v7; // di
  char v8; // r9

  v3 = extern_ptr;
  result = (char *)extern_ptr + 4 * a2;
  if ( extern_limit < (unsigned __int64)result )
  {
    result = (char *)grow_extern_output(4 * a2);
    v3 = extern_ptr;
  }
  if ( a2 > 0 )
  {
    v5 = a2;
    result = 0LL;
    do
    {
      v6 = result[a1];
      v7 = result[a1 + 1];
      result[(_QWORD)v3] = result[a1 + 3];
      v8 = result[a1 + 2];
      result[(_QWORD)v3 + 3] = v6;
      result[(_QWORD)v3 + 2] = v7;
      result[(_QWORD)v3 + 1] = v8;
      result += 4;
      --v5;
    }
    while ( v5 );
    v3 = (char *)v3 + 4 * a2;
  }
  extern_ptr = v3;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000433A50) ----------------------------------------------------
char *__fastcall caml_serialize_float_4(float a1)
{
  float v2[3]; // [rsp+Ch] [rbp-Ch] BYREF

  v2[0] = a1;
  return caml_serialize_block_4((__int64)v2, 1LL);
}
// 433A50: using guessed type float var_C[3];

//----- (0000000000433A70) ----------------------------------------------------
char *__fastcall caml_serialize_block_2(__int64 a1, __int64 a2)
{
  void *v2; // rcx
  char *result; // rax
  __int64 v4; // rdx
  char v5; // r8

  v2 = extern_ptr;
  result = (char *)extern_ptr + 2 * a2;
  if ( extern_limit < (unsigned __int64)result )
  {
    result = (char *)grow_extern_output(2 * a2);
    v2 = extern_ptr;
  }
  if ( a2 > 0 )
  {
    v4 = a2;
    result = 0LL;
    do
    {
      v5 = result[a1 + 1];
      result[(_QWORD)v2 + 1] = result[a1];
      result[(_QWORD)v2] = v5;
      result += 2;
      --v4;
    }
    while ( v4 );
    v2 = (char *)v2 + 2 * a2;
  }
  extern_ptr = v2;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000433AF0) ----------------------------------------------------
_BYTE *__fastcall caml_serialize_int_4(int a1)
{
  _BYTE *result; // rax
  char *v2; // rdx

  result = extern_ptr;
  v2 = (char *)extern_ptr + 4;
  if ( (unsigned __int64)extern_ptr + 4 > extern_limit )
  {
    grow_extern_output(4LL);
    result = extern_ptr;
    v2 = (char *)extern_ptr + 4;
  }
  result[3] = a1;
  *result = HIBYTE(a1);
  result[1] = BYTE2(a1);
  result[2] = BYTE1(a1);
  extern_ptr = v2;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000433B40) ----------------------------------------------------
_BYTE *__fastcall caml_serialize_int_2(__int16 a1)
{
  _BYTE *result; // rax
  char *v2; // rdx

  result = extern_ptr;
  v2 = (char *)extern_ptr + 2;
  if ( (unsigned __int64)extern_ptr + 2 > extern_limit )
  {
    grow_extern_output(2LL);
    result = extern_ptr;
    v2 = (char *)extern_ptr + 2;
  }
  result[1] = a1;
  *result = HIBYTE(a1);
  extern_ptr = v2;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000433B80) ----------------------------------------------------
_BYTE *__fastcall caml_serialize_int_1(char a1)
{
  _BYTE *result; // rax
  char *v2; // rdx

  result = extern_ptr;
  v2 = (char *)extern_ptr + 1;
  if ( (unsigned __int64)extern_ptr + 1 > extern_limit )
  {
    grow_extern_output(1LL);
    result = extern_ptr;
    v2 = (char *)extern_ptr + 1;
  }
  *result = a1;
  extern_ptr = v2;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000433BC0) ----------------------------------------------------
_BYTE *__fastcall writecode8(char a1, char a2)
{
  _BYTE *result; // rax
  char *v3; // rdx

  result = extern_ptr;
  v3 = (char *)extern_ptr + 2;
  if ( (unsigned __int64)extern_ptr + 2 > extern_limit )
  {
    grow_extern_output(2LL);
    result = extern_ptr;
    v3 = (char *)extern_ptr + 2;
  }
  *result = a1;
  result[1] = a2;
  extern_ptr = v3;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000433C20) ----------------------------------------------------
_BYTE *__fastcall writecode32(char a1, int a2)
{
  _BYTE *result; // rax
  char *v3; // rdx

  result = extern_ptr;
  v3 = (char *)extern_ptr + 5;
  if ( (unsigned __int64)extern_ptr + 5 > extern_limit )
  {
    grow_extern_output(5LL);
    result = extern_ptr;
    v3 = (char *)extern_ptr + 5;
  }
  *result = a1;
  result[4] = a2;
  result[1] = HIBYTE(a2);
  result[2] = BYTE2(a2);
  result[3] = BYTE1(a2);
  extern_ptr = v3;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000433CA0) ----------------------------------------------------
_BYTE *__fastcall write32(int a1)
{
  _BYTE *result; // rax
  char *v2; // rdx

  result = extern_ptr;
  v2 = (char *)extern_ptr + 4;
  if ( (unsigned __int64)extern_ptr + 4 > extern_limit )
  {
    grow_extern_output(4LL);
    result = extern_ptr;
    v2 = (char *)extern_ptr + 4;
  }
  result[3] = a1;
  *result = HIBYTE(a1);
  result[1] = BYTE2(a1);
  result[2] = BYTE1(a1);
  extern_ptr = v2;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000433D00) ----------------------------------------------------
__int64 __fastcall extern_record_location(unsigned __int64 a1)
{
  __int64 result; // rax
  unsigned __int64 *v2; // rdx
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rax
  __int64 v5; // rax
  unsigned __int64 *v6; // rax

  result = (unsigned int)extern_ignore_sharing;
  if ( !extern_ignore_sharing )
  {
    v2 = (unsigned __int64 *)extern_trail_cur;
    if ( extern_trail_cur == extern_trail_limit )
    {
      v6 = (unsigned __int64 *)malloc(0x4018uLL);
      if ( !v6 )
        extern_out_of_memory();
      *v6 = (unsigned __int64)extern_trail_block;
      v2 = v6 + 1;
      extern_trail_block = v6;
      extern_trail_cur = (__int64)(v6 + 1);
      extern_trail_limit = (__int64)(v6 + 2051);
    }
    v3 = *(_QWORD *)(a1 - 8);
    *v2 = a1 | (v3 >> 8) & 3;
    v2[1] = *(_QWORD *)a1;
    v4 = v3;
    extern_trail_cur = (__int64)(v2 + 2);
    BYTE1(v4) = BYTE1(v3) & 0xFC | 2;
    *(_QWORD *)(a1 - 8) = v4;
    v5 = obj_counter;
    *(_QWORD *)a1 = obj_counter;
    result = v5 + 1;
    obj_counter = result;
  }
  return result;
}
// 65E620: using guessed type __int64 obj_counter;
// 65E638: using guessed type int extern_ignore_sharing;
// 662660: using guessed type __int64 extern_trail_cur;
// 662668: using guessed type __int64 extern_trail_limit;

//----- (0000000000433DC0) ----------------------------------------------------
__int64 init_extern_output()
{
  _QWORD *v0; // rax
  void *v1; // rdx
  __int64 result; // rax

  extern_userprovided_output = 0LL;
  v0 = malloc(0x1FB8uLL);
  extern_output_first = v0;
  if ( !v0 )
    caml_raise_out_of_memory();
  v1 = v0 + 2;
  extern_output_block = (__int64)v0;
  *v0 = 0LL;
  result = (__int64)v0 + 8116;
  extern_ptr = v1;
  extern_limit = result;
  return result;
}
// 662670: using guessed type __int64 extern_userprovided_output;
// 662680: using guessed type __int64 extern_limit;
// 662690: using guessed type __int64 extern_output_block;

//----- (0000000000433E20) ----------------------------------------------------
void *__fastcall caml_serialize_block_float_8(void *src, __int64 a2)
{
  void *v3; // rdi
  void *result; // rax

  v3 = extern_ptr;
  if ( extern_limit < (unsigned __int64)extern_ptr + 8 * a2 )
  {
    grow_extern_output(8 * a2);
    v3 = extern_ptr;
  }
  result = memmove(v3, src, 8 * a2);
  extern_ptr = (char *)extern_ptr + 8 * a2;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000433E80) ----------------------------------------------------
void *__fastcall caml_serialize_float_8(double a1)
{
  double src[2]; // [rsp+8h] [rbp-10h] BYREF

  src[0] = a1;
  return caml_serialize_block_float_8(src, 1LL);
}
// 433E80: using guessed type double src[2];

//----- (0000000000433EA0) ----------------------------------------------------
void *__fastcall caml_serialize_block_1(void *src, size_t n)
{
  void *v3; // rdi
  void *result; // rax

  v3 = extern_ptr;
  if ( extern_limit < (unsigned __int64)extern_ptr + n )
  {
    grow_extern_output(n);
    v3 = extern_ptr;
  }
  result = memmove(v3, src, n);
  extern_ptr = (char *)extern_ptr + n;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000433F00) ----------------------------------------------------
void *__fastcall writeblock(void *src, size_t n)
{
  void *v3; // rdi
  void *result; // rax

  v3 = extern_ptr;
  if ( extern_limit < (unsigned __int64)extern_ptr + n )
  {
    grow_extern_output(n);
    v3 = extern_ptr;
  }
  result = memmove(v3, src, n);
  extern_ptr = (char *)extern_ptr + n;
  return result;
}
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000433F60) ----------------------------------------------------
void __fastcall __noreturn extern_invalid_argument(void *a1)
{
  extern_replay_trail();
  free_extern_output();
  caml_invalid_argument(a1);
}

//----- (0000000000433F80) ----------------------------------------------------
_BYTE *__fastcall extern_rec(__int64 a1)
{
  unsigned __int64 v2; // r13
  _QWORD *v3; // r15
  unsigned __int64 v4; // r12
  _BYTE *v5; // rax
  signed __int64 v6; // r13
  _BYTE *v7; // rdx
  int i; // ecx
  __int64 v9; // rsi
  char **v10; // r13
  char **v11; // r12
  char *v12; // rbp
  _BYTE *v13; // rax
  size_t v14; // rax
  _BYTE *result; // rax
  __int64 v16; // r12
  unsigned __int64 v17; // rax
  size_t v18; // rbp
  _BYTE *v19; // rax
  size_t v20; // rax
  unsigned __int64 v21; // rbp
  _BYTE *v22; // rax
  _BYTE *v23; // rax
  char v24; // al
  __int64 v25; // rdi
  unsigned __int64 v26; // r12
  unsigned __int64 v27; // r13
  __int64 v28; // rax
  __int64 v29; // rdi
  __int64 v30; // rbx
  _BYTE *v31; // rax
  _QWORD *v32; // rax
  _BYTE *v33; // rax
  unsigned __int64 v34; // rbp
  char *v35; // rdx
  char *v36; // rdx
  _BYTE *v37; // rdx
  int j; // ecx
  __int64 v39; // rsi
  __int64 v40; // [rsp+0h] [rbp-48h] BYREF
  __int64 v41; // [rsp+8h] [rbp-40h] BYREF

LABEL_1:
  while ( (a1 & 1) == 0 )
  {
    if ( (caml_page_table_lookup(a1) & 7) == 0 )
    {
      if ( a1 < (unsigned __int64)caml_code_area_start || a1 >= (unsigned __int64)caml_code_area_end )
        extern_invalid_argument("output_value: abstract value (outside heap)");
      if ( !extern_closures )
        extern_invalid_argument("output_value: functional value");
      writecode32(16, a1 - caml_code_area_start);
      v32 = caml_code_checksum();
      return writeblock(v32, 0x10uLL);
    }
    v2 = *(_QWORD *)(a1 - 8);
    v3 = (_QWORD *)(a1 - 8);
    if ( (unsigned __int8)v2 != 250
      || (v11 = *(char ***)a1, (*(_QWORD *)a1 & 1) == 0)
      && ((caml_page_table_lookup(*(_QWORD *)a1) & 7) == 0
       || (v24 = *((_BYTE *)v11 - 8), v24 == -6)
       || v24 == -10
       || v24 == -3) )
    {
      v4 = v2 >> 10;
      if ( v2 >> 10 )
      {
        if ( (v2 & 0x300) != 512 )
        {
          switch ( (char)v2 )
          {
            case -7:
              v16 = 8 * v4;
              writecode32(17, v16);
              return extern_rec(a1 - v16);
            case -5:
              extern_invalid_argument("output_value: abstract value (Abstract)");
            case -4:
              v17 = caml_string_length(a1);
              v18 = v17;
              if ( v17 > 0x1F )
              {
                if ( v17 > 0xFF )
                  writecode32(10, v17);
                else
                  writecode8(9, v17);
              }
              else
              {
                v19 = extern_ptr;
                if ( (unsigned __int64)extern_ptr >= extern_limit )
                {
                  grow_extern_output(1LL);
                  v19 = extern_ptr;
                }
                *v19 = v18 + 32;
                extern_ptr = v19 + 1;
              }
              writeblock((void *)a1, v18);
              v20 = v18 + 4;
              v21 = (v18 + 8) >> 3;
              size_32 += (v20 >> 2) + 1;
              goto LABEL_31;
            case -3:
              v22 = extern_ptr;
              if ( (unsigned __int64)extern_ptr >= extern_limit )
              {
                grow_extern_output(1LL);
                v22 = extern_ptr;
              }
              *v22 = 12;
              extern_ptr = v22 + 1;
              writeblock((void *)a1, 8uLL);
              size_32 += 3LL;
              size_64 += 2LL;
              return (_BYTE *)extern_record_location(a1);
            case -2:
              v21 = *v3 >> 10;
              if ( v21 > 0xFF )
                writecode32(7, *v3 >> 10);
              else
                writecode8(14, *v3 >> 10);
              writeblock((void *)a1, 8 * v21);
              size_32 += 2 * v21 + 1;
LABEL_31:
              size_64 += v21 + 1;
              return (_BYTE *)extern_record_location(a1);
            case -1:
              v12 = **(char ***)a1;
              if ( !*(_QWORD *)(*(_QWORD *)a1 + 32LL) )
                extern_invalid_argument("output_value: abstract value (Custom)");
              v13 = extern_ptr;
              if ( (unsigned __int64)extern_ptr >= extern_limit )
              {
                grow_extern_output(1LL);
                v13 = extern_ptr;
              }
              *v13 = 18;
              extern_ptr = v13 + 1;
              v14 = strlen(v12);
              writeblock(v12, v14 + 1);
              (*(void (__fastcall **)(__int64, __int64 *, __int64 *))(*(_QWORD *)a1 + 32LL))(a1, &v41, &v40);
              size_32 += ((unsigned __int64)(v41 + 3) >> 2) + 2;
              size_64 += ((unsigned __int64)(v40 + 7) >> 3) + 2;
              return (_BYTE *)extern_record_location(a1);
            default:
              if ( (unsigned __int8)v2 > 0xFu || v4 > 7 )
              {
                if ( v2 <= 0xFFFFFFFF )
                {
                  writecode32(8, v2 & 0xFFFFFCFF);
                }
                else
                {
                  v5 = extern_ptr;
                  v6 = v2 & 0xFFFFFFFFFFFFFCFFLL;
                  if ( extern_limit < (unsigned __int64)extern_ptr + 9 )
                  {
                    grow_extern_output(9LL);
                    v5 = extern_ptr;
                  }
                  v7 = v5 + 1;
                  *v5 = 19;
                  for ( i = 56; i != -8; i -= 8 )
                  {
                    v9 = v6 >> i;
                    *++v5 = v9;
                  }
                  extern_ptr = v7 + 8;
                }
              }
              else
              {
                v23 = extern_ptr;
                if ( (unsigned __int64)extern_ptr >= extern_limit )
                {
                  grow_extern_output(1LL);
                  v23 = extern_ptr;
                }
                *v23 = 16 * v4 + v2 + 0x80;
                extern_ptr = v23 + 1;
              }
              size_32 += v4 + 1;
              size_64 += v4 + 1;
              v10 = *(char ***)a1;
              extern_record_location(a1);
              if ( v4 == 1 )
              {
                a1 = (__int64)v10;
              }
              else
              {
                v25 = (__int64)v10;
                v26 = v4 - 1;
                v27 = 1LL;
                extern_rec(v25);
                v28 = 8LL;
                if ( v26 > 1 )
                {
                  do
                  {
                    v29 = *(_QWORD *)(a1 + 8 * v27++);
                    extern_rec(v29);
                  }
                  while ( v27 < v26 );
                  v28 = 8 * v26;
                }
                a1 = *(_QWORD *)(v28 + a1);
              }
              goto LABEL_1;
          }
        }
        v34 = obj_counter - *(_QWORD *)a1;
        if ( v34 <= 0xFF )
        {
          return writecode8(4, (unsigned __int8)obj_counter - *(_BYTE *)a1);
        }
        else if ( v34 > 0xFFFF )
        {
          return writecode32(6, (int)obj_counter - *(_DWORD *)a1);
        }
        else
        {
          result = extern_ptr;
          v35 = (char *)extern_ptr + 3;
          if ( (unsigned __int64)extern_ptr + 3 > extern_limit )
          {
            grow_extern_output(3LL);
            result = extern_ptr;
            v35 = (char *)extern_ptr + 3;
          }
          *result = 5;
          result[2] = v34;
          result[1] = BYTE1(v34);
          extern_ptr = v35;
        }
      }
      else if ( (unsigned __int8)v2 > 0xFu )
      {
        return writecode32(8, v2);
      }
      else
      {
        v33 = extern_ptr;
        if ( (unsigned __int64)extern_ptr >= extern_limit )
        {
          grow_extern_output(1LL);
          v33 = extern_ptr;
        }
        *v33 = v2 + 0x80;
        result = v33 + 1;
        extern_ptr = result;
      }
      return result;
    }
    a1 = (__int64)v11;
  }
  v30 = a1 >> 1;
  if ( (unsigned __int64)v30 > 0x3F )
  {
    if ( (unsigned __int64)(v30 + 128) <= 0xFF )
    {
      return writecode8(0, v30);
    }
    else if ( (unsigned __int64)(v30 + 0x8000) > 0xFFFF )
    {
      if ( (unsigned __int64)(v30 + 0x80000000LL) <= 0xFFFFFFFF )
      {
        return writecode32(2, v30);
      }
      else
      {
        result = extern_ptr;
        if ( extern_limit < (unsigned __int64)extern_ptr + 9 )
        {
          grow_extern_output(9LL);
          result = extern_ptr;
        }
        v37 = result + 1;
        *result = 3;
        for ( j = 56; j != -8; j -= 8 )
        {
          v39 = v30 >> j;
          *++result = v39;
        }
        extern_ptr = v37 + 8;
      }
    }
    else
    {
      result = extern_ptr;
      v36 = (char *)extern_ptr + 3;
      if ( (unsigned __int64)extern_ptr + 3 > extern_limit )
      {
        grow_extern_output(3LL);
        result = extern_ptr;
        v36 = (char *)extern_ptr + 3;
      }
      *result = 1;
      result[2] = v30;
      result[1] = BYTE1(v30);
      extern_ptr = v36;
    }
  }
  else
  {
    v31 = extern_ptr;
    if ( (unsigned __int64)extern_ptr >= extern_limit )
    {
      grow_extern_output(1LL);
      v31 = extern_ptr;
    }
    *v31 = v30 + 64;
    result = v31 + 1;
    extern_ptr = result;
  }
  return result;
}
// 65E620: using guessed type __int64 obj_counter;
// 65E628: using guessed type __int64 size_32;
// 65E630: using guessed type __int64 size_64;
// 65E63C: using guessed type int extern_closures;
// 662680: using guessed type __int64 extern_limit;
// 662860: using guessed type __int64 caml_code_area_start;
// 662948: using guessed type __int64 caml_code_area_end;

//----- (0000000000434780) ----------------------------------------------------
__int64 __fastcall extern_value(__int64 a1, __int64 *a2)
{
  char v2; // al
  __int64 v3; // rbx
  _QWORD *v5; // rax
  __int64 v6; // rdx

  v2 = caml_convert_flag_list(a2, (__int64)&extern_flags);
  extern_closures = v2 & 2;
  extern_trail_block = &extern_trail_first;
  extern_ignore_sharing = v2 & 1;
  extern_trail_cur = (__int64)&unk_65E648;
  extern_trail_limit = (__int64)&extern_trail_block;
  obj_counter = 0LL;
  size_32 = 0LL;
  size_64 = 0LL;
  write32(-2070567234);
  extern_ptr = (char *)extern_ptr + 16;
  extern_rec(a1);
  if ( !extern_userprovided_output )
    *(_QWORD *)(extern_output_block + 8) = extern_ptr;
  extern_replay_trail();
  if ( extern_userprovided_output )
  {
    v3 = (__int64)extern_ptr - extern_userprovided_output;
  }
  else
  {
    v5 = extern_output_first;
    v3 = 0LL;
    if ( !extern_output_first )
      goto LABEL_6;
    do
    {
      v6 = v5[1] - (_QWORD)v5;
      v5 = (_QWORD *)*v5;
      v3 = v6 + v3 - 16;
    }
    while ( v5 );
  }
  if ( v3 > 0xFFFFFFFFLL )
    goto LABEL_15;
LABEL_6:
  if ( (unsigned __int64)size_32 > 0xFFFFFFFF || (unsigned __int64)size_64 > 0xFFFFFFFF )
  {
LABEL_15:
    free_extern_output();
    caml_failwith("output_value: object too big");
  }
  if ( extern_userprovided_output )
  {
    extern_ptr = (void *)(extern_userprovided_output + 4);
  }
  else
  {
    extern_limit = (__int64)extern_output_first + 8116;
    extern_ptr = (char *)extern_output_first + 20;
  }
  write32(v3 - 20);
  write32(obj_counter);
  write32(size_32);
  write32(size_64);
  return v3;
}
// 65E620: using guessed type __int64 obj_counter;
// 65E628: using guessed type __int64 size_32;
// 65E630: using guessed type __int64 size_64;
// 65E638: using guessed type int extern_ignore_sharing;
// 65E63C: using guessed type int extern_closures;
// 662660: using guessed type __int64 extern_trail_cur;
// 662668: using guessed type __int64 extern_trail_limit;
// 662670: using guessed type __int64 extern_userprovided_output;
// 662680: using guessed type __int64 extern_limit;
// 662690: using guessed type __int64 extern_output_block;

//----- (0000000000434930) ----------------------------------------------------
__int64 __fastcall caml_output_value_to_block(__int64 a1, __int64 *a2, void *a3, __int64 a4)
{
  extern_userprovided_output = (__int64)a3;
  extern_ptr = a3;
  extern_limit = (__int64)a3 + a4;
  return extern_value(a1, a2);
}
// 662670: using guessed type __int64 extern_userprovided_output;
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000434950) ----------------------------------------------------
void __fastcall caml_output_value_to_malloc(__int64 a1, __int64 *a2, char **a3, __int64 *a4)
{
  __int64 v6; // r13
  char *v7; // rax
  char *v8; // rbp
  _QWORD *v9; // rbx
  char *v10; // rdi
  size_t v11; // rdx

  init_extern_output();
  v6 = extern_value(a1, a2);
  v7 = (char *)malloc(v6);
  v8 = v7;
  if ( !v7 )
    extern_out_of_memory();
  *a3 = v7;
  v9 = extern_output_first;
  for ( *a4 = v6; v9; v9 = (_QWORD *)*v9 )
  {
    v10 = v8;
    v11 = (int)(v9[1] - ((_DWORD)v9 + 16));
    v8 += v11;
    memmove(v10, v9 + 2, v11);
  }
  free_extern_output();
}

//----- (00000000004349F0) ----------------------------------------------------
__int64 __fastcall caml_output_value_to_buffer(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5)
{
  extern_userprovided_output = (a2 >> 1) + a1;
  extern_ptr = (void *)((a2 >> 1) + a1);
  extern_limit = (a3 >> 1) + extern_userprovided_output;
  return 2 * extern_value(a4, a5) + 1;
}
// 662670: using guessed type __int64 extern_userprovided_output;
// 662680: using guessed type __int64 extern_limit;

//----- (0000000000434A30) ----------------------------------------------------
_QWORD *__fastcall caml_output_value_to_string(__int64 a1, __int64 *a2)
{
  __int64 v2; // rax
  _QWORD *v3; // rbx
  _QWORD *v4; // r13
  __int64 v5; // rbp
  char *v6; // rdi
  size_t v7; // rdx
  _QWORD *v8; // r12

  init_extern_output();
  v2 = extern_value(a1, a2);
  v3 = extern_output_first;
  v4 = caml_alloc_string(v2);
  if ( v3 )
  {
    v5 = 0LL;
    do
    {
      v6 = (char *)v4 + v5;
      v7 = (int)(v3[1] - ((_DWORD)v3 + 16));
      v5 += v7;
      memmove(v6, v3 + 2, v7);
      v8 = (_QWORD *)*v3;
      free(v3);
      v3 = v8;
    }
    while ( v8 );
  }
  return v4;
}

//----- (0000000000434AB0) ----------------------------------------------------
void __fastcall caml_output_val(__int64 a1, __int64 a2, __int64 *a3)
{
  char *v4; // rbp
  char *v5; // r12

  if ( !(unsigned int)caml_channel_binary_mode() )
    caml_failwith("output_value: not a binary channel");
  init_extern_output();
  extern_value(a2, a3);
  v4 = (char *)extern_output_first;
  if ( extern_output_first )
  {
    do
    {
      caml_really_putblock(a1, v4 + 16, *((_QWORD *)v4 + 1) - (_QWORD)(v4 + 16));
      v5 = *(char **)v4;
      free(v4);
      v4 = v5;
    }
    while ( v5 );
  }
}

//----- (0000000000434B20) ----------------------------------------------------
__int64 __fastcall caml_output_value(__int64 a1, __int64 a2, __int64 *a3)
{
  __int64 v3; // rbp
  __int64 v4; // rbx
  __int64 *v6; // [rsp+8h] [rbp-70h] BYREF
  __int64 v7; // [rsp+10h] [rbp-68h] BYREF
  __int64 v8; // [rsp+18h] [rbp-60h] BYREF
  __int64 v9[11]; // [rsp+20h] [rbp-58h] BYREF

  v3 = caml_local_roots;
  v6 = a3;
  v8 = a1;
  v7 = a2;
  v9[2] = 1LL;
  caml_local_roots = (__int64)v9;
  v9[0] = v3;
  v9[1] = 3LL;
  v9[3] = (__int64)&v8;
  v4 = *(_QWORD *)(a1 + 8);
  v9[4] = (__int64)&v7;
  v9[5] = (__int64)&v6;
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v4);
  caml_output_val(v4, v7, v6);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v4);
  caml_local_roots = v3;
  return 1LL;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000434BD0) ----------------------------------------------------
__int64 caml_deserialize_uint_1()
{
  __int64 result; // rax

  result = *(unsigned __int8 *)intern_src;
  intern_src = (char *)intern_src + 1;
  return result;
}

//----- (0000000000434BF0) ----------------------------------------------------
__int64 caml_deserialize_sint_1()
{
  __int64 result; // rax

  result = *(char *)intern_src;
  intern_src = (char *)intern_src + 1;
  return result;
}
// 434BF0: using guessed type __int64 __fastcall caml_deserialize_sint_1();

//----- (0000000000434C10) ----------------------------------------------------
__int64 caml_deserialize_uint_2()
{
  unsigned __int8 *v0; // rdx

  v0 = (unsigned __int8 *)intern_src;
  intern_src = (char *)intern_src + 2;
  return (unsigned __int8)*((char *)intern_src - 1) + (*v0 << 8);
}
// 434C10: using guessed type __int64 __fastcall caml_deserialize_uint_2();

//----- (0000000000434C30) ----------------------------------------------------
__int64 caml_deserialize_sint_2()
{
  char *v0; // rax

  v0 = (char *)intern_src;
  intern_src = (char *)intern_src + 2;
  return (unsigned __int8)*((char *)intern_src - 1) + ((__int64)*v0 << 8);
}
// 434C30: using guessed type __int64 __fastcall caml_deserialize_sint_2();

//----- (0000000000434C60) ----------------------------------------------------
unsigned __int64 caml_deserialize_uint_4()
{
  unsigned __int8 *v0; // rcx

  v0 = (unsigned __int8 *)intern_src;
  intern_src = (char *)intern_src + 4;
  return ((unsigned __int8)*((char *)intern_src - 2) << 8)
       + ((unsigned __int64)*v0 << 24)
       + (unsigned __int8)*((char *)intern_src - 1)
       + ((unsigned __int8)*((char *)intern_src - 3) << 16);
}

//----- (0000000000434CA0) ----------------------------------------------------
__int64 caml_deserialize_sint_4()
{
  char *v0; // rax

  v0 = (char *)intern_src;
  intern_src = (char *)intern_src + 4;
  return ((unsigned __int8)*((char *)intern_src - 2) << 8)
       + ((__int64)*v0 << 24)
       + (unsigned __int8)*((char *)intern_src - 1)
       + ((unsigned __int8)*((char *)intern_src - 3) << 16);
}

//----- (0000000000434CE0) ----------------------------------------------------
void __fastcall caml_deserialize_block_2(__int64 a1, __int64 a2)
{
  _BYTE *v2; // rcx
  __int64 v3; // rdx
  __int64 v4; // rax
  char v5; // r9

  v2 = intern_src;
  if ( a2 > 0 )
  {
    v3 = a2;
    v4 = 0LL;
    do
    {
      v5 = v2[v4 + 1];
      *(_BYTE *)(a1 + v4 + 1) = v2[v4];
      *(_BYTE *)(a1 + v4) = v5;
      v4 += 2LL;
      --v3;
    }
    while ( v3 );
    v2 += 2 * a2;
  }
  intern_src = v2;
}

//----- (0000000000434D30) ----------------------------------------------------
void __fastcall caml_deserialize_block_4(__int64 a1, __int64 a2)
{
  _BYTE *v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // rax
  char v5; // r9
  char v6; // r8
  char v7; // r10

  v2 = intern_src;
  if ( a2 > 0 )
  {
    v3 = a2;
    v4 = 0LL;
    do
    {
      v5 = v2[v4];
      v6 = v2[v4 + 1];
      *(_BYTE *)(a1 + v4) = v2[v4 + 3];
      v7 = v2[v4 + 2];
      *(_BYTE *)(a1 + v4 + 3) = v5;
      *(_BYTE *)(a1 + v4 + 2) = v6;
      *(_BYTE *)(a1 + v4 + 1) = v7;
      v4 += 4LL;
      --v3;
    }
    while ( v3 );
    v2 += 4 * a2;
  }
  intern_src = v2;
}

//----- (0000000000434D90) ----------------------------------------------------
float caml_deserialize_float_4()
{
  float v1; // [rsp+Ch] [rbp-4h] BYREF

  caml_deserialize_block_4((__int64)&v1, 1LL);
  return v1;
}

//----- (0000000000434DB0) ----------------------------------------------------
void __fastcall caml_deserialize_block_8(_BYTE *a1, __int64 a2)
{
  char *v2; // r10
  char *v3; // rax
  __int64 v4; // rdx
  char v5; // r8
  char v6; // cl
  char v7; // r9
  char v8; // r8
  char v9; // cl
  char v10; // r9

  v2 = (char *)intern_src;
  if ( a2 > 0 )
  {
    v3 = (char *)intern_src;
    v4 = a2;
    do
    {
      v5 = *v3;
      v6 = v3[1];
      *a1 = v3[7];
      v7 = v3[6];
      a1[7] = v5;
      a1[6] = v6;
      a1[1] = v7;
      v8 = v3[2];
      v9 = v3[3];
      a1[2] = v3[5];
      v10 = v3[4];
      v3 += 8;
      a1[5] = v8;
      a1[4] = v9;
      a1[3] = v10;
      a1 += 8;
      --v4;
    }
    while ( v4 );
    v2 += 8 * a2;
  }
  intern_src = v2;
}

//----- (0000000000434E30) ----------------------------------------------------
__int64 caml_deserialize_sint_8()
{
  __int64 v1; // [rsp+8h] [rbp-8h] BYREF

  caml_deserialize_block_8(&v1, 1LL);
  return v1;
}

//----- (0000000000434E50) ----------------------------------------------------
__int64 caml_deserialize_uint_8()
{
  __int64 v1; // [rsp+8h] [rbp-8h] BYREF

  caml_deserialize_block_8(&v1, 1LL);
  return v1;
}
// 434E50: using guessed type __int64 __fastcall caml_deserialize_uint_8();

//----- (0000000000434E70) ----------------------------------------------------
unsigned __int64 __fastcall caml_marshal_data_size(__int64 a1, __int64 a2)
{
  unsigned __int8 *v2; // rdi

  intern_input_malloced = 0;
  v2 = (unsigned __int8 *)((a2 >> 1) + a1);
  intern_src = v2 + 4;
  if ( (*v2 << 24) + v2[3] + (v2[1] << 16) + (v2[2] << 8) != -2070567234 )
    caml_failwith("Marshal.data_size: bad object");
  intern_src = v2 + 8;
  return 2 * (v2[7] + ((unsigned __int64)v2[4] << 24) + (v2[5] << 16) + (v2[6] << 8)) + 1;
}
// 6626D0: using guessed type int intern_input_malloced;

//----- (0000000000434F10) ----------------------------------------------------
void intern_cleanup()
{
  if ( intern_input_malloced )
    caml_stat_free(intern_input);
  if ( intern_obj_table )
    caml_stat_free(intern_obj_table);
  if ( intern_extra_block )
  {
    caml_free_for_heap(intern_extra_block);
  }
  else if ( intern_block )
  {
    *(_QWORD *)(intern_block - 8) = intern_header;
  }
}
// 6626D0: using guessed type int intern_input_malloced;
// 6626E0: using guessed type __int64 intern_extra_block;
// 662700: using guessed type __int64 intern_header;
// 662708: using guessed type __int64 intern_block;

//----- (0000000000434F80) ----------------------------------------------------
void __fastcall __noreturn caml_deserialize_error(void *a1)
{
  intern_cleanup();
  caml_failwith(a1);
}

//----- (0000000000434FA0) ----------------------------------------------------
void *__fastcall caml_deserialize_block_float_8(void *a1, __int64 a2)
{
  void *result; // rax

  result = memmove(a1, intern_src, 8 * a2);
  intern_src = (char *)intern_src + 8 * a2;
  return result;
}

//----- (0000000000434FD0) ----------------------------------------------------
double caml_deserialize_float_8()
{
  double v1[2]; // [rsp+8h] [rbp-10h] BYREF

  caml_deserialize_block_float_8(v1, 1LL);
  return v1[0];
}
// 434FD0: using guessed type double var_10[2];

//----- (0000000000434FF0) ----------------------------------------------------
void *__fastcall caml_deserialize_block_1(void *a1, size_t a2)
{
  void *result; // rax

  result = memmove(a1, intern_src, a2);
  intern_src = (char *)intern_src + a2;
  return result;
}

//----- (0000000000435010) ----------------------------------------------------
_QWORD *caml_code_checksum()
{
  _DWORD v1[22]; // [rsp+0h] [rbp-68h] BYREF
  unsigned __int64 v2; // [rsp+58h] [rbp-10h]

  v2 = __readfsqword(0x28u);
  if ( !checksum_computed_4045 )
  {
    caml_MD5Init(v1);
    caml_MD5Update((__int64)v1, (char *)caml_code_area_start, caml_code_area_end - caml_code_area_start);
    caml_MD5Final(checksum_4044, (__int64)v1);
    checksum_computed_4045 = 1;
  }
  return checksum_4044;
}
// 6626A0: using guessed type int checksum_computed_4045;
// 6626B0: using guessed type _QWORD checksum_4044[2];
// 662860: using guessed type __int64 caml_code_area_start;
// 662948: using guessed type __int64 caml_code_area_end;

//----- (0000000000435090) ----------------------------------------------------
void __fastcall intern_alloc(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 *v3; // rax
  __int64 v4; // rdx
  __int64 v5; // rax
  __int64 v6; // rax

  if ( a1 )
  {
    v2 = a1 - 1;
    if ( (unsigned __int64)(a1 - 1) > 0x3FFFFFFFFFFFFFLL )
    {
      v6 = caml_alloc_for_heap((8 * a1 + 4095) & 0xFFFFFFFFFFFFF000LL);
      intern_extra_block = v6;
      if ( !v6 )
        caml_raise_out_of_memory();
      intern_color = caml_allocation_color(v6);
      obj_counter_0 = 0LL;
      intern_dest = intern_extra_block;
      if ( !a2 )
        goto LABEL_6;
    }
    else
    {
      if ( a1 == 1 )
      {
        v3 = (__int64 *)&unk_663148;
        intern_block = (__int64)&unk_663148;
      }
      else
      {
        if ( v2 > 0x100 )
          v3 = caml_alloc_shr(v2, 0xFCu);
        else
          v3 = caml_alloc_small(v2, 0xFCu);
        intern_block = (__int64)v3;
      }
      v4 = (__int64)(v3 - 1);
      v5 = *(v3 - 1);
      intern_extra_block = 0LL;
      obj_counter_0 = 0LL;
      intern_dest = v4;
      intern_header = v5;
      intern_color = v5 & 0x300;
      if ( !a2 )
      {
LABEL_6:
        intern_obj_table = 0LL;
        return;
      }
    }
    intern_obj_table = caml_stat_alloc(8 * a2);
  }
  else
  {
    intern_obj_table = 0LL;
    intern_extra_block = 0LL;
    intern_block = 0LL;
  }
}
// 6626D8: using guessed type __int64 intern_dest;
// 6626E0: using guessed type __int64 intern_extra_block;
// 6626E8: using guessed type __int64 obj_counter_0;
// 6626F8: using guessed type int intern_color;
// 662700: using guessed type __int64 intern_header;
// 662708: using guessed type __int64 intern_block;

//----- (00000000004351F0) ----------------------------------------------------
__int64 __fastcall intern_add_to_heap(__int64 a1)
{
  __int64 result; // rax
  unsigned __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rax
  unsigned __int64 v5; // rsi

  result = a1;
  v2 = intern_extra_block;
  if ( intern_extra_block )
  {
    v3 = 8 * result + 4095;
    v4 = intern_dest;
    v5 = intern_extra_block + (v3 & 0xFFFFFFFFFFFFF000LL);
    if ( v5 > intern_dest )
    {
      caml_make_free_blocks((__int64 **)intern_dest, (__int64)(v5 - intern_dest) >> 3, 0);
      v4 = intern_dest;
      v2 = intern_extra_block;
    }
    caml_allocated_words += (v4 - v2) >> 3;
    return caml_add_to_heap(v2);
  }
  return result;
}
// 6626D8: using guessed type __int64 intern_dest;
// 6626E0: using guessed type __int64 intern_extra_block;
// 6633C0: using guessed type __int64 caml_allocated_words;

//----- (0000000000435270) ----------------------------------------------------
unsigned __int64 __fastcall intern_rec(const char ****a1)
{
  char *v2; // rax
  unsigned __int8 v3; // dl
  unsigned __int8 *v4; // rdi
  int v5; // ebp
  unsigned int v6; // esi
  unsigned __int64 v7; // rbp
  __int64 v8; // rax
  _QWORD *v9; // rdx
  __int64 v10; // rcx
  bool v11; // zf
  __int64 v12; // rbx
  unsigned __int64 v13; // r13
  const char ****v14; // r12
  const char ****v15; // rdi
  char *v16; // rcx
  unsigned __int64 v17; // rbp
  __int64 v18; // rdx
  __int64 v19; // rax
  const char ***v20; // r15
  unsigned __int64 result; // rax
  unsigned __int8 *v22; // rcx
  __int64 v23; // rax
  __int64 v24; // rdx
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // r12
  __int64 v27; // r13
  void *v28; // rdi
  __int64 v29; // rdx
  const void *v30; // rsi
  unsigned __int64 v31; // rax
  char v32; // cl
  char v33; // dl
  char v34; // si
  char v35; // cl
  char v36; // dl
  char v37; // si
  char v38; // si
  size_t v39; // rbp
  _QWORD *v40; // rdx
  unsigned __int64 v41; // rax
  char *v42; // rdi
  __int64 v43; // rsi
  __int64 v44; // rdx
  __int64 v45; // rax
  _QWORD *v46; // rax
  char *v47; // r12
  __int64 v48; // rcx
  const void *v49; // rsi
  char v50; // dl
  char v51; // al
  char v52; // cl
  char v53; // dl
  char v54; // al
  char v55; // cl
  char v56; // cl
  __int64 v57; // rbp
  int v58; // er13
  int v59; // er12
  __int64 v60; // r14
  const char **custom_operations; // rbp
  char *v62; // rax
  char v63; // dl
  __int64 v64; // rax
  _QWORD *v65; // rdx
  unsigned __int64 v66; // rax
  __int64 v67; // rsi
  __int64 v68; // rsi
  unsigned __int8 v69; // r14
  int v70; // er12
  __int16 v71; // r15
  unsigned __int8 v72; // r13
  const char ***v73; // [rsp+8h] [rbp-60h] BYREF
  char dest[24]; // [rsp+10h] [rbp-58h] BYREF
  unsigned __int64 v75; // [rsp+28h] [rbp-40h]

  v75 = __readfsqword(0x28u);
  while ( 1 )
  {
    v2 = (char *)intern_src;
    v3 = *(_BYTE *)intern_src;
    v4 = (unsigned __int8 *)intern_src + 1;
    intern_src = (char *)intern_src + 1;
    v5 = v3;
    if ( v3 <= 0x3Fu )
      break;
    if ( v3 <= 0x7Fu )
    {
      v20 = (const char ***)(2LL * (v3 & 0x3F) + 1);
      goto LABEL_20;
    }
    v6 = v3 & 0xF;
    v7 = (v3 >> 4) & 7;
LABEL_5:
    if ( !v7 )
    {
      v20 = (const char ***)((char *)&unk_662968 + 8 * v6);
      goto LABEL_20;
    }
    v8 = intern_dest;
    v9 = intern_obj_table;
    v10 = intern_dest + 8;
    v11 = intern_obj_table == 0LL;
    *a1 = (const char ***)(intern_dest + 8);
    if ( !v11 )
    {
      v12 = obj_counter_0;
      v9[obj_counter_0] = v10;
      obj_counter_0 = v12 + 1;
    }
    a1 = (const char ****)(v8 + 8);
    *(_QWORD *)v8 = (unsigned int)intern_color + (v7 << 10) + v6;
    intern_dest += 8 * v7 + 8;
    if ( v7 != 1 )
    {
      v13 = v7;
      v14 = (const char ****)(v8 + 8);
      do
      {
        v15 = v14;
        --v13;
        ++v14;
        intern_rec(v15);
      }
      while ( v13 > 1 );
      a1 = &a1[v7 - 1];
    }
  }
  if ( v3 <= 0x1Fu )
  {
    switch ( v3 )
    {
      case 0u:
        v19 = (char)*v4;
        intern_src = v4 + 1;
        v20 = (const char ***)(2 * v19 + 1);
        goto LABEL_20;
      case 1u:
        intern_src = v4 + 2;
        v20 = (const char ***)(2 * (v4[1] + ((__int64)(char)*v4 << 8)) + 1);
        goto LABEL_20;
      case 2u:
        intern_src = v4 + 4;
        v20 = (const char ***)(2 * ((v4[1] << 16) + (__int64)(v4[2] << 8) + v4[3] + ((__int64)(char)*v4 << 24)) + 1);
        goto LABEL_20;
      case 3u:
        v22 = v4 + 8;
        v23 = 0LL;
        do
        {
          v24 = *v4++;
          v23 = v24 + (v23 << 8);
        }
        while ( v4 != v22 );
        intern_src = v4;
        v20 = (const char ***)(2 * v23 + 1);
        goto LABEL_20;
      case 4u:
        v25 = *v4;
        intern_src = v4 + 1;
        goto LABEL_27;
      case 5u:
        intern_src = v4 + 2;
        v25 = v4[1] + (*v4 << 8);
        goto LABEL_27;
      case 6u:
        intern_src = v4 + 4;
        v25 = (v4[2] << 8) + (v4[1] << 16) + ((unsigned __int64)*v4 << 24) + v4[3];
LABEL_27:
        v20 = (const char ***)*((_QWORD *)intern_obj_table + obj_counter_0 - v25);
        goto LABEL_20;
      case 7u:
      case 0xFu:
        intern_src = v4 + 4;
        v26 = (v4[2] << 8) + (v4[1] << 16) + ((unsigned __int64)*v4 << 24) + v4[3];
        goto LABEL_31;
      case 8u:
        intern_src = v4 + 4;
        v7 = ((v4[2] << 8) + (v4[1] << 16) + ((unsigned __int64)*v4 << 24) + v4[3]) >> 10;
        v6 = v4[3];
        goto LABEL_5;
      case 9u:
        v39 = *v4;
        intern_src = v4 + 1;
        goto LABEL_41;
      case 0xAu:
        intern_src = v4 + 4;
        v39 = (v4[2] << 8) + (v4[1] << 16) + ((unsigned __int64)*v4 << 24) + v4[3];
        goto LABEL_41;
      case 0xBu:
      case 0xCu:
        v46 = (_QWORD *)intern_dest;
        v47 = (char *)(intern_dest + 8);
        v20 = (const char ***)(intern_dest + 8);
        if ( intern_obj_table )
        {
          v48 = obj_counter_0;
          *((_QWORD *)intern_obj_table + obj_counter_0) = v47;
          obj_counter_0 = v48 + 1;
        }
        v49 = intern_src;
        intern_dest += 16LL;
        *v46 = (unsigned int)intern_color + 1277LL;
        memmove(v47, v49, 8uLL);
        intern_src = (char *)intern_src + 8;
        if ( v5 != 12 )
        {
          v50 = *v47;
          v51 = v47[1];
          *v47 = v47[7];
          v52 = v47[6];
          v47[7] = v50;
          v47[6] = v51;
          v53 = v47[2];
          v54 = v47[3];
          v47[1] = v52;
          v55 = v47[5];
          v47[5] = v53;
          v47[2] = v55;
          v56 = v47[4];
          v47[4] = v54;
          v47[3] = v56;
        }
        goto LABEL_20;
      case 0xDu:
      case 0xEu:
        v26 = *v4;
        intern_src = v4 + 1;
LABEL_31:
        v27 = intern_dest;
        v28 = (void *)(intern_dest + 8);
        v20 = (const char ***)(intern_dest + 8);
        if ( intern_obj_table )
        {
          v29 = obj_counter_0;
          *((_QWORD *)intern_obj_table + obj_counter_0) = v28;
          obj_counter_0 = v29 + 1;
        }
        v30 = intern_src;
        *(_QWORD *)v27 = (unsigned int)intern_color + (v26 << 10) + 254;
        intern_dest += 8 * v26 + 8;
        memmove(v28, v30, 8 * v26);
        intern_src = (char *)intern_src + 8 * v26;
        if ( v5 != 7 && v5 != 14 && v26 )
        {
          v31 = 0LL;
          do
          {
            v32 = *(_BYTE *)(v27 + 8);
            ++v31;
            v33 = *(_BYTE *)(v27 + 9);
            *(_BYTE *)(v27 + 8) = *(_BYTE *)(v27 + 15);
            v34 = *(_BYTE *)(v27 + 14);
            *(_BYTE *)(v27 + 15) = v32;
            *(_BYTE *)(v27 + 14) = v33;
            v35 = *(_BYTE *)(v27 + 10);
            v36 = *(_BYTE *)(v27 + 11);
            *(_BYTE *)(v27 + 9) = v34;
            v37 = *(_BYTE *)(v27 + 13);
            *(_BYTE *)(v27 + 13) = v35;
            *(_BYTE *)(v27 + 10) = v37;
            v38 = *(_BYTE *)(v27 + 12);
            *(_BYTE *)(v27 + 12) = v36;
            *(_BYTE *)(v27 + 11) = v38;
            v27 += 8LL;
          }
          while ( v26 > v31 );
        }
        goto LABEL_20;
      case 0x10u:
        intern_src = v4 + 4;
        v69 = *v4;
        v70 = v4[1];
        v71 = v4[2];
        v72 = v4[3];
        memmove(dest, v4 + 4, 0x10uLL);
        intern_src = (char *)intern_src + 16;
        if ( memcmp(dest, caml_code_checksum(), 0x10uLL) )
        {
          intern_cleanup();
          caml_failwith("input_value: code mismatch");
        }
        v20 = (const char ***)(caml_code_area_start
                             + v72
                             + ((unsigned __int64)v69 << 24)
                             + ((v70 << 16) & 0xFF0000)
                             + (unsigned __int16)(v71 << 8));
        goto LABEL_20;
      case 0x11u:
        intern_src = v4 + 4;
        v57 = *v4;
        v58 = v4[1];
        v59 = v4[2];
        v60 = v4[3];
        intern_rec(&v73);
        v20 = (const char ***)((char *)&(&(&v73[0x200000 * v57])[0x2000 * v58])[32 * v59] + v60);
        goto LABEL_20;
      case 0x12u:
        custom_operations = caml_find_custom_operations((char *)v4);
        if ( !custom_operations )
        {
          intern_cleanup();
          caml_failwith("input_value: unknown custom block identifier");
        }
        v62 = (char *)intern_src;
        do
        {
          v63 = *v62++;
          intern_src = v62;
        }
        while ( v63 );
        v64 = ((__int64 (__fastcall *)(__int64))custom_operations[5])(intern_dest + 16);
        v65 = (_QWORD *)intern_dest;
        v66 = ((unsigned __int64)(v64 + 7) >> 3) + 1;
        v20 = (const char ***)(intern_dest + 8);
        if ( intern_obj_table )
        {
          v67 = obj_counter_0;
          *((_QWORD *)intern_obj_table + obj_counter_0) = v20;
          obj_counter_0 = v67 + 1;
        }
        v68 = (unsigned int)intern_color;
        *v20 = custom_operations;
        intern_dest += 8 * v66 + 8;
        *v65 = v68 + (v66 << 10) + 255;
        goto LABEL_20;
      case 0x13u:
        v16 = v2 + 8;
        v17 = 0LL;
        do
        {
          v18 = (unsigned __int8)*++v2;
          v17 = v18 + (v17 << 8);
        }
        while ( v2 != v16 );
        LOBYTE(v6) = v17;
        v7 = v17 >> 10;
        intern_src = v4 + 8;
        v6 = (unsigned __int8)v6;
        goto LABEL_5;
      default:
        intern_cleanup();
        caml_failwith("input_value: ill-formed message");
    }
  }
  v39 = v3 & 0x1F;
LABEL_41:
  v40 = (_QWORD *)intern_dest;
  v41 = (v39 + 8) >> 3;
  v42 = (char *)(intern_dest + 8);
  v20 = (const char ***)(intern_dest + 8);
  if ( intern_obj_table )
  {
    v43 = obj_counter_0;
    *((_QWORD *)intern_obj_table + obj_counter_0) = v42;
    obj_counter_0 = v43 + 1;
  }
  *v40 = (unsigned int)intern_color + (v41 << 10) + 252;
  v44 = 8 * v41 + 8;
  v45 = 8 * v41;
  intern_dest += v44;
  *(_QWORD *)&v42[v45 - 8] = 0LL;
  v42[v45 - 1] = v45 - 1 - v39;
  memmove(v42, intern_src, v39);
  intern_src = (char *)intern_src + v39;
LABEL_20:
  result = __readfsqword(0x28u) ^ v75;
  *a1 = v20;
  return result;
}
// 6626D8: using guessed type __int64 intern_dest;
// 6626E8: using guessed type __int64 obj_counter_0;
// 6626F8: using guessed type int intern_color;
// 662860: using guessed type __int64 caml_code_area_start;

//----- (0000000000435A60) ----------------------------------------------------
const char ***input_val_from_block()
{
  unsigned __int8 *v0; // rax
  unsigned __int64 v1; // rsi
  int v2; // ecx
  int v3; // edx
  __int64 v4; // rbx
  const char ***v6; // [rsp+8h] [rbp-10h] BYREF

  v0 = (unsigned __int8 *)intern_src;
  intern_src = (char *)intern_src + 4;
  v1 = ((unsigned __int64)*v0 << 24) + (unsigned __int8)*((char *)intern_src - 1);
  v2 = (unsigned __int8)*((char *)intern_src - 3);
  v3 = (unsigned __int8)*((char *)intern_src - 2);
  intern_src = v0 + 12;
  v4 = (v0[10] << 8) + (v0[9] << 16) + ((unsigned __int64)v0[8] << 24) + v0[11];
  intern_alloc(v4, (v3 << 8) + (v2 << 16) + v1);
  intern_rec(&v6);
  intern_add_to_heap(v4);
  if ( intern_obj_table )
    caml_stat_free(intern_obj_table);
  return v6;
}

//----- (0000000000435B10) ----------------------------------------------------
const char ***__fastcall caml_input_value_from_block(unsigned __int8 *a1, unsigned __int64 a2)
{
  intern_input = a1;
  intern_input_malloced = 0;
  intern_src = a1 + 4;
  if ( (*a1 << 24) + a1[3] + (a1[1] << 16) + (a1[2] << 8) != -2070567234 )
    caml_failwith("input_value_from_block: bad object");
  intern_src = a1 + 8;
  if ( a1[7] + ((unsigned __int64)a1[4] << 24) + 20 + (a1[5] << 16) + (a1[6] << 8) > a2 )
    caml_failwith("input_value_from_block: bad block length");
  return input_val_from_block();
}
// 6626D0: using guessed type int intern_input_malloced;

//----- (0000000000435BC0) ----------------------------------------------------
const char ***__fastcall caml_input_value_from_malloc(char *a1, __int64 a2)
{
  unsigned __int8 *v2; // rdi
  const char ***v3; // rbx

  intern_input = a1;
  v2 = (unsigned __int8 *)&a1[a2];
  intern_input_malloced = 1;
  intern_src = v2 + 4;
  if ( (*v2 << 24) + v2[3] + (v2[1] << 16) + (v2[2] << 8) != -2070567234 )
    caml_failwith("input_value_from_malloc: bad object");
  intern_src = v2 + 8;
  v3 = input_val_from_block();
  caml_stat_free(intern_input);
  return v3;
}
// 6626D0: using guessed type int intern_input_malloced;

//----- (0000000000435C40) ----------------------------------------------------
const char ***__fastcall caml_input_val_from_string(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx
  char *v4; // rax
  unsigned __int64 v5; // rsi
  int v6; // ecx
  int v7; // edx
  __int64 v8; // rbp
  __int64 v10; // [rsp+8h] [rbp-C0h] BYREF
  __int64 v11[8]; // [rsp+10h] [rbp-B8h] BYREF
  __int64 v12[9]; // [rsp+50h] [rbp-78h] BYREF
  const char ***v13[6]; // [rsp+98h] [rbp-30h] BYREF

  v3 = caml_local_roots;
  intern_input_malloced = 0;
  v10 = a1;
  v12[2] = 1LL;
  v12[1] = 1LL;
  v12[3] = (__int64)&v10;
  v12[0] = caml_local_roots;
  v13[0] = 0LL;
  v11[2] = 1LL;
  v11[0] = (__int64)v12;
  v11[1] = 1LL;
  v11[3] = (__int64)v13;
  caml_local_roots = (__int64)v11;
  intern_src = (void *)(a2 + a1 + 12);
  v4 = (char *)(a2 + a1 + 20);
  v5 = ((unsigned __int64)*(unsigned __int8 *)(a2 + a1 + 8) << 24) + *(unsigned __int8 *)(a2 + a1 + 11);
  v6 = (unsigned __int8)*((char *)intern_src - 3);
  v7 = (unsigned __int8)*((char *)intern_src - 2);
  intern_src = v4;
  v8 = ((unsigned __int8)*(v4 - 2) << 8)
     + ((unsigned __int8)*(v4 - 3) << 16)
     + ((unsigned __int64)(unsigned __int8)*(v4 - 4) << 24)
     + (unsigned __int8)*(v4 - 1);
  intern_alloc(v8, (v7 << 8) + (v6 << 16) + v5);
  intern_src = (void *)(a2 + v10 + 20);
  intern_rec(v13);
  intern_add_to_heap(v8);
  if ( intern_obj_table )
    caml_stat_free(intern_obj_table);
  caml_local_roots = v3;
  return v13[0];
}
// 658A68: using guessed type __int64 caml_local_roots;
// 6626D0: using guessed type int intern_input_malloced;

//----- (0000000000435D90) ----------------------------------------------------
const char ***__fastcall caml_input_value_from_string(__int64 a1, __int64 a2)
{
  return caml_input_val_from_string(a1, a2 >> 1);
}

//----- (0000000000435DA0) ----------------------------------------------------
const char ***__fastcall caml_input_val(__int64 a1)
{
  size_t v1; // r14
  unsigned int v2; // er12
  unsigned int v3; // er13
  void *v4; // rbp
  const char ***v6; // [rsp+8h] [rbp-30h] BYREF

  if ( !(unsigned int)caml_channel_binary_mode() )
    caml_failwith("input_value: not a binary channel");
  if ( (unsigned int)caml_getword(a1) != -2070567234 )
    caml_failwith("input_value: bad object");
  v1 = (unsigned int)caml_getword(a1);
  v2 = caml_getword(a1);
  caml_getword(a1);
  v3 = caml_getword(a1);
  v4 = caml_stat_alloc(v1);
  if ( !caml_really_getblock(a1, (char *)v4, v1) )
  {
    caml_stat_free(v4);
    caml_failwith("input_value: truncated object");
  }
  intern_input = v4;
  intern_input_malloced = 1;
  intern_src = v4;
  intern_alloc(v3, v2);
  intern_rec(&v6);
  intern_add_to_heap(v3);
  caml_stat_free(intern_input);
  if ( intern_obj_table )
    caml_stat_free(intern_obj_table);
  return v6;
}
// 6626D0: using guessed type int intern_input_malloced;

//----- (0000000000435ED0) ----------------------------------------------------
const char ***__fastcall caml_input_value(__int64 a1)
{
  __int64 v1; // rbp
  __int64 v2; // rbx
  const char ***result; // rax
  __int64 v4; // [rsp+8h] [rbp-B0h] BYREF
  __int64 v5[8]; // [rsp+10h] [rbp-A8h] BYREF
  __int64 v6[9]; // [rsp+50h] [rbp-68h] BYREF
  const char ***v7; // [rsp+98h] [rbp-20h] BYREF

  v1 = caml_local_roots;
  v2 = *(_QWORD *)(a1 + 8);
  v4 = a1;
  v6[2] = 1LL;
  v6[1] = 1LL;
  v5[0] = (__int64)v6;
  v6[0] = caml_local_roots;
  v6[3] = (__int64)&v4;
  v7 = 0LL;
  caml_local_roots = (__int64)v5;
  v5[2] = 1LL;
  v5[1] = 1LL;
  v5[3] = (__int64)&v7;
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v2);
  result = caml_input_val(v2);
  v7 = result;
  if ( caml_channel_mutex_unlock )
  {
    caml_channel_mutex_unlock(v2);
    result = v7;
  }
  caml_local_roots = v1;
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000435FA0) ----------------------------------------------------
__int64 __fastcall caml_hash_variant(_BYTE *a1)
{
  __int64 v1; // rdx
  __int64 result; // rax
  int v3; // eax

  v1 = 1LL;
  result = 1LL;
  if ( *a1 )
  {
    do
    {
      v3 = (unsigned __int8)*a1++;
      v1 = 2LL * (int)(v3 + 223 * (v1 >> 1)) + 1;
    }
    while ( *a1 );
    return (int)v1;
  }
  return result;
}

//----- (0000000000435FE0) ----------------------------------------------------
__int64 __fastcall hash_aux(__int64 a1)
{
  __int64 result; // rax
  unsigned __int8 v3; // al
  __int64 v4; // rsi
  unsigned __int64 *v5; // rdx
  unsigned int v6; // ecx
  unsigned __int64 v7; // rbx
  __int64 *v8; // rbp
  __int64 v9; // rdi
  __int64 v10; // rbp
  unsigned __int64 v11; // rdx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 v17; // rax
  unsigned __int64 v18; // rdi
  __int64 v19; // rdx
  unsigned __int64 i; // rbx
  __int64 v21; // rcx
  __int64 v22; // rdx

  result = --hash_univ_limit;
  if ( hash_univ_count >= 0 && result >= 0 )
  {
    while ( (a1 & 1) == 0 )
    {
      while ( 2 )
      {
        if ( (caml_page_table_lookup(a1) & 7) == 0 )
          goto LABEL_19;
        v3 = *(_BYTE *)(a1 - 8);
        v4 = a1;
        v5 = (unsigned __int64 *)(a1 - 8);
        v6 = v3;
        LOBYTE(result) = v3 + 8;
        result = (unsigned __int8)result;
        switch ( (char)result )
        {
          case 0:
            --hash_univ_count;
            result = (*(__int64 *)(a1 + 8) >> 1) + 65599 * hash_accu;
            hash_accu = result;
            return result;
          case 1:
            v11 = *v5;
            result = --hash_univ_limit;
            if ( hash_univ_count < 0 || result < 0 )
              return result;
            a1 -= 8 * (v11 >> 10);
            break;
          case 2:
            a1 = *(_QWORD *)a1;
            if ( (a1 & 1) != 0 )
              goto LABEL_18;
            continue;
          case 3:
            return result;
          case 4:
            --hash_univ_count;
            result = caml_string_length(a1);
            if ( result )
            {
              v12 = hash_accu;
              do
              {
                v13 = 19 * v12;
                v14 = *(unsigned __int8 *)a1++;
                --result;
                v12 = v13 + v14;
              }
              while ( result );
              hash_accu = v12;
            }
            return result;
          case 5:
            --hash_univ_count;
            result = hash_accu;
            v15 = a1 + 8;
            do
            {
              v16 = 19 * result;
              v17 = *(unsigned __int8 *)a1++;
              result = v16 + v17;
            }
            while ( a1 != v15 );
            hash_accu = result;
            return result;
          case 6:
            --hash_univ_count;
            v18 = 8 * (*v5 >> 10);
            if ( v18 )
            {
              v19 = hash_accu;
              for ( i = 0LL; i < v18; i += 8LL )
              {
                result = v4;
                v4 += 8LL;
                do
                {
                  v21 = 19 * v19;
                  v22 = *(unsigned __int8 *)result++;
                  v19 = v21 + v22;
                }
                while ( v4 != result );
              }
              hash_accu = v19;
            }
            return result;
          case 7:
            result = *(_QWORD *)(*(_QWORD *)a1 + 24LL);
            if ( result )
            {
              --hash_univ_count;
              v10 = 65599 * hash_accu;
              result = ((__int64 (__fastcall *)(__int64, __int64))result)(a1, a1);
              hash_accu = result + v10;
            }
            return result;
          default:
            --hash_univ_count;
            result = v6 + 19 * hash_accu;
            hash_accu = result;
            v7 = *v5 >> 10;
            if ( v7 )
            {
              v8 = (__int64 *)&v5[v7];
              do
              {
                v9 = *v8;
                --v7;
                --v8;
                result = hash_aux(v9);
              }
              while ( v7 );
            }
            return result;
        }
        break;
      }
    }
LABEL_18:
    --hash_univ_count;
    a1 >>= 1;
LABEL_19:
    result = a1 + 65599 * hash_accu;
    hash_accu = result;
  }
  return result;
}
// 662710: using guessed type __int64 hash_accu;
// 662718: using guessed type __int64 hash_univ_limit;
// 662720: using guessed type __int64 hash_univ_count;

//----- (0000000000436290) ----------------------------------------------------
__int64 __fastcall caml_hash_univ_param(__int64 a1, __int64 a2, __int64 a3)
{
  hash_univ_count = a1 >> 1;
  hash_univ_limit = a2 >> 1;
  hash_accu = 0LL;
  hash_aux(a3);
  return 2 * (hash_accu & 0x3FFFFFFF) + 1;
}
// 662710: using guessed type __int64 hash_accu;
// 662718: using guessed type __int64 hash_univ_limit;
// 662720: using guessed type __int64 hash_univ_count;

//----- (00000000004362E0) ----------------------------------------------------
void __fastcall caml_sys_init(void *a1, __int64 a2)
{
  caml_exe_name = a1;
  caml_main_argv = a2;
}
// 662728: using guessed type __int64 caml_main_argv;

//----- (00000000004362F0) ----------------------------------------------------
_QWORD *caml_sys_get_config()
{
  __int64 v0; // rbx
  __int64 v2[8]; // [rsp+0h] [rbp-58h] BYREF
  _QWORD *v3; // [rsp+40h] [rbp-18h] BYREF
  _QWORD *v4; // [rsp+48h] [rbp-10h] BYREF

  v0 = caml_local_roots;
  v4 = 0LL;
  v3 = 0LL;
  caml_local_roots = (__int64)v2;
  v2[2] = 1LL;
  v2[3] = (__int64)&v4;
  v2[0] = v0;
  v2[1] = 2LL;
  v2[4] = (__int64)&v3;
  v3 = caml_copy_string("Unix");
  v4 = caml_alloc_small(2LL, 0);
  caml_local_roots = v0;
  *v4 = v3;
  v4[1] = 129LL;
  return v4;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000436390) ----------------------------------------------------
_QWORD *caml_sys_get_argv()
{
  __int64 v0; // rbx
  __int64 v2[9]; // [rsp+0h] [rbp-68h] BYREF
  _QWORD *v3; // [rsp+48h] [rbp-20h] BYREF
  char *v4; // [rsp+50h] [rbp-18h] BYREF
  _QWORD *v5; // [rsp+58h] [rbp-10h] BYREF

  v0 = caml_local_roots;
  v5 = 0LL;
  v4 = 0LL;
  v3 = 0LL;
  caml_local_roots = (__int64)v2;
  v2[3] = (__int64)&v5;
  v2[0] = v0;
  v2[2] = 1LL;
  v2[1] = 3LL;
  v2[4] = (__int64)&v4;
  v2[5] = (__int64)&v3;
  v5 = caml_copy_string(caml_exe_name);
  v4 = caml_copy_string_array((_QWORD *)caml_main_argv);
  v3 = caml_alloc_small(2LL, 0);
  caml_local_roots = v0;
  *v3 = v5;
  v3[1] = v4;
  return v3;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 662728: using guessed type __int64 caml_main_argv;

//----- (0000000000436450) ----------------------------------------------------
__int64 caml_sys_random_seed()
{
  __time_t v0; // rbx
  __pid_t v1; // ebp
  struct timeval v3; // [rsp+0h] [rbp-28h] BYREF

  gettimeofday(&v3, 0LL);
  v0 = v3.tv_sec ^ v3.tv_usec;
  v1 = getppid() << 16;
  return 2 * (v0 ^ getpid() ^ v1) + 1;
}
// 436450: using guessed type __int64 __fastcall caml_sys_random_seed();

//----- (00000000004364A0) ----------------------------------------------------
__int64 caml_sys_time()
{
  struct rusage v1; // [rsp+0h] [rbp-98h] BYREF

  getrusage(RUSAGE_SELF, &v1);
  return caml_copy_double(
           (double)SLODWORD(v1.ru_utime.tv_sec)
         + (double)SLODWORD(v1.ru_utime.tv_usec) / 1000000.0
         + (double)SLODWORD(v1.ru_stime.tv_sec)
         + (double)SLODWORD(v1.ru_stime.tv_usec) / 1000000.0);
}
// 4364A0: using guessed type __int64 __fastcall caml_sys_time();

//----- (0000000000436500) ----------------------------------------------------
_QWORD *__fastcall caml_sys_getenv(const char *a1)
{
  char *v1; // rax

  v1 = getenv(a1);
  if ( !v1 )
    caml_raise_not_found();
  return caml_copy_string(v1);
}

//----- (0000000000436520) ----------------------------------------------------
__int64 __fastcall caml_sys_file_exists(char *filename)
{
  stat64 v2; // [rsp+0h] [rbp-98h] BYREF

  return __xstat64(1, filename, &v2) == 0 ? 3LL : 1LL;
}
// 436520: using guessed type struct stat64 anonymous_0;

//----- (0000000000436550) ----------------------------------------------------
__int64 __fastcall caml_sys_close(__int64 a1)
{
  close(a1 >> 1);
  return 1LL;
}

//----- (0000000000436570) ----------------------------------------------------
void __fastcall __noreturn caml_sys_exit(__int64 a1)
{
  exit(a1 >> 1);
}

//----- (0000000000436580) ----------------------------------------------------
void __fastcall __noreturn caml_sys_error(void *a1)
{
  int *v1; // rax
  char *v2; // rax
  void *v3; // rbx
  char *v4; // rbp
  int v5; // er12
  int v6; // eax
  size_t v7; // rbx
  _QWORD *v8; // rdi
  void *src; // [rsp+8h] [rbp-B0h] BYREF
  __int64 v10[8]; // [rsp+10h] [rbp-A8h] BYREF
  __int64 v11[9]; // [rsp+50h] [rbp-68h] BYREF
  _QWORD *v12; // [rsp+98h] [rbp-20h] BYREF

  src = a1;
  v11[2] = 1LL;
  v11[1] = 1LL;
  v12 = 0LL;
  v11[0] = caml_local_roots;
  v10[2] = 1LL;
  v10[1] = 1LL;
  v11[3] = (__int64)&src;
  v10[0] = (__int64)v11;
  caml_local_roots = (__int64)v10;
  v10[3] = (__int64)&v12;
  v1 = __errno_location();
  v2 = strerror(*v1);
  v3 = src;
  v4 = v2;
  if ( src == (void *)1 )
  {
    v8 = caml_copy_string(v2);
    v12 = v8;
  }
  else
  {
    v5 = strlen(v2);
    v6 = caml_string_length((__int64)v3);
    v7 = v6;
    v12 = caml_alloc_string(v6 + v5 + 2);
    memmove(v12, src, v7);
    *(_WORD *)((char *)v12 + v7) = 8250;
    memmove((char *)v12 + v7 + 2, v4, v5);
    v8 = v12;
  }
  caml_raise_sys_error((__int64)v8);
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (00000000004366A0) ----------------------------------------------------
char *__fastcall caml_sys_read_directory(void *a1)
{
  __int64 v1; // rbp
  void *v3; // [rsp+8h] [rbp-C0h] BYREF
  __int64 v4[8]; // [rsp+10h] [rbp-B8h] BYREF
  __int64 v5[8]; // [rsp+50h] [rbp-78h] BYREF
  void *v6[3]; // [rsp+90h] [rbp-38h] BYREF
  char *v7; // [rsp+A8h] [rbp-20h] BYREF

  v1 = caml_local_roots;
  v3 = a1;
  v5[2] = 1LL;
  v5[1] = 1LL;
  v5[3] = (__int64)&v3;
  v5[0] = caml_local_roots;
  v7 = 0LL;
  v4[0] = (__int64)v5;
  v4[2] = 1LL;
  v4[1] = 1LL;
  caml_local_roots = (__int64)v4;
  v4[3] = (__int64)&v7;
  caml_ext_table_init((__int64)v6, 50);
  if ( (unsigned int)caml_read_directory((const char *)v3, v6) == -1 )
  {
    caml_ext_table_free((__int64)v6, 1);
    caml_sys_error(v3);
  }
  caml_ext_table_add(v6, 0LL);
  v7 = caml_copy_string_array((_QWORD *)v6[1]);
  caml_ext_table_free((__int64)v6, 1);
  caml_local_roots = v1;
  return v7;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (00000000004367B0) ----------------------------------------------------
__int64 __fastcall caml_sys_system_command(void *a1)
{
  __int64 v1; // rbp
  size_t v2; // r12
  void *v3; // rbx
  int v4; // er12
  __int64 result; // rax
  void *src; // [rsp+8h] [rbp-60h] BYREF
  __int64 v7[8]; // [rsp+10h] [rbp-58h] BYREF

  v1 = caml_local_roots;
  src = a1;
  v7[2] = 1LL;
  v7[1] = 1LL;
  caml_local_roots = (__int64)v7;
  v7[0] = v1;
  v7[3] = (__int64)&src;
  v2 = caml_string_length((__int64)a1) + 1;
  v3 = caml_stat_alloc(v2);
  memmove(v3, src, v2);
  caml_enter_blocking_section();
  v4 = system((const char *)v3);
  caml_leave_blocking_section();
  caml_stat_free(v3);
  if ( v4 == -1 )
    caml_sys_error(src);
  result = 511LL;
  if ( (v4 & 0x7F) == 0 )
    result = 2LL * BYTE1(v4) + 1;
  caml_local_roots = v1;
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000436890) ----------------------------------------------------
_QWORD *caml_sys_getcwd()
{
  char v1[4104]; // [rsp+0h] [rbp-1018h] BYREF
  unsigned __int64 v2; // [rsp+1008h] [rbp-10h]

  v2 = __readfsqword(0x28u);
  if ( !getcwd(v1, 0x1000uLL) )
    caml_sys_error((void *)1);
  return caml_copy_string(v1);
}

//----- (0000000000436900) ----------------------------------------------------
__int64 __fastcall caml_sys_chdir(void *a1)
{
  if ( chdir((const char *)a1) )
    caml_sys_error(a1);
  return 1LL;
}

//----- (0000000000436920) ----------------------------------------------------
__int64 __fastcall caml_sys_rename(const char *a1, const char *a2)
{
  if ( rename(a1, a2) )
    caml_sys_error((void *)1);
  return 1LL;
}

//----- (0000000000436950) ----------------------------------------------------
__int64 __fastcall caml_sys_remove(void *a1)
{
  if ( unlink((const char *)a1) )
    caml_sys_error(a1);
  return 1LL;
}

//----- (0000000000436970) ----------------------------------------------------
__int64 __fastcall caml_sys_is_directory(char *filename)
{
  struct stat64 v2; // [rsp+0h] [rbp-98h] BYREF

  if ( __xstat64(1, filename, &v2) == -1 )
    caml_sys_error(filename);
  return 2LL * ((v2.st_mode & 0xF000) == 0x4000) + 1;
}

//----- (00000000004369D0) ----------------------------------------------------
__int64 __fastcall caml_sys_open(char *a1, __int64 *a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v4; // rax
  char *v5; // rbp
  int v6; // eax
  __int64 v7; // r13
  int v8; // ebx
  int v9; // ebx
  __int64 v11; // [rsp+8h] [rbp-80h] BYREF
  __int64 *v12; // [rsp+10h] [rbp-78h] BYREF
  char *src; // [rsp+18h] [rbp-70h] BYREF
  __int64 v14[9]; // [rsp+20h] [rbp-68h] BYREF

  v11 = a3;
  v3 = caml_local_roots;
  v12 = a2;
  src = a1;
  caml_local_roots = (__int64)v14;
  v14[2] = 1LL;
  v14[0] = v3;
  v14[1] = 3LL;
  v14[3] = (__int64)&src;
  v14[4] = (__int64)&v12;
  v14[5] = (__int64)&v11;
  v4 = caml_string_length((__int64)a1);
  v5 = (char *)caml_stat_alloc(v4 + 1);
  strcpy(v5, src);
  v6 = caml_convert_flag_list(v12, (__int64)&sys_open_flags);
  v7 = v11;
  v8 = v6;
  caml_enter_blocking_section();
  v9 = open64(v5, v8, (unsigned int)(v7 >> 1));
  caml_leave_blocking_section();
  caml_stat_free(v5);
  if ( v9 == -1 )
    caml_sys_error(src);
  fcntl(v9, 2, 1LL);
  caml_local_roots = v3;
  return 2LL * v9 + 1;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000436B00) ----------------------------------------------------
void __fastcall __noreturn caml_sys_io_error(void *a1)
{
  if ( *__errno_location() != 11 )
    caml_sys_error(a1);
  caml_raise_sys_blocked_io();
}

//----- (0000000000436B20) ----------------------------------------------------
unsigned __int64 __fastcall caml_set_parser_trace(__int64 a1)
{
  unsigned __int64 v1; // rax

  v1 = -(__int64)(caml_parser_trace == 0) & 0xFFFFFFFFFFFFFFFELL;
  caml_parser_trace = a1 >> 1;
  return v1 + 3;
}
// 662730: using guessed type int caml_parser_trace;

//----- (0000000000436B40) ----------------------------------------------------
__int64 __fastcall caml_parse_engine(_QWORD *a1, _QWORD *a2, __int64 a3, signed __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v10; // r15
  unsigned __int64 v11; // r13
  __int64 v12; // r14
  unsigned __int64 v13; // r12
  __int64 v14; // rcx
  __int64 v15; // rax
  unsigned int v16; // er12
  __int64 v17; // rdx
  __int64 v18; // r12
  int v19; // eax
  int v20; // ecx
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rdx
  unsigned __int64 v24; // r13
  __int64 v25; // rax
  __int64 v26; // rdx
  __int64 v27; // rcx
  int v28; // esi
  __int64 v29; // rdx
  int v30; // esi
  __int64 i; // r14
  __int64 v32; // rcx
  __int64 v33; // rax
  const char *v34; // r12
  __int64 v35; // rax
  int v36; // edx
  unsigned __int8 v37; // al
  const char *v38; // r8
  int v39; // edx
  __int64 v40; // rcx
  char v41; // al
  int v42; // [rsp+8h] [rbp-50h]
  int v43; // [rsp+8h] [rbp-50h]
  __int64 v44; // [rsp+10h] [rbp-48h]
  int v45; // [rsp+18h] [rbp-40h]
  int v46; // [rsp+18h] [rbp-40h]

  v6 = a3 >> 1;
  switch ( (int)v6 )
  {
    case 0:
      v14 = 0LL;
      LODWORD(v12) = 0;
      LODWORD(v10) = 0;
      v11 = (int)((__int64)a2[13] >> 1);
      goto LABEL_6;
    case 1:
      v10 = a2[14] >> 1;
      v12 = a2[15] >> 1;
      v11 = (int)((__int64)a2[13] >> 1);
      if ( (a4 & 1) != 0 )
      {
        a2[6] = *(_QWORD *)(a1[1] + 8LL * (int)(a4 >> 1));
        caml_modify(a2 + 7, 1uLL);
      }
      else
      {
        a2[6] = *(_QWORD *)(a1[2] + 8LL * *(unsigned __int8 *)(a4 - 8));
        caml_modify(a2 + 7, *(_QWORD *)a4);
      }
      if ( !caml_parser_trace )
        goto LABEL_40;
      if ( (a4 & 1) != 0 )
      {
        v33 = a4;
        v34 = (const char *)a1[14];
        v35 = v33 >> 1;
        if ( (int)v35 > 0 )
        {
          if ( *v34 )
          {
            v36 = 0;
            v45 = v35 - 1;
            while ( 1 )
            {
              v42 = v36;
              v34 += strlen(v34) + 1;
              if ( v45 - v42 <= 0 )
                break;
              v36 = v42 + 1;
              if ( !*v34 )
                goto LABEL_82;
            }
          }
          else
          {
LABEL_82:
            v34 = "<unknown token>";
          }
        }
        __fprintf_chk(stderr, 1LL, "State %d: read token %s\n", (unsigned int)v10, v34);
        v14 = 2LL * (int)v10;
        v17 = a2[6] >> 1;
        goto LABEL_8;
      }
      v37 = *(_BYTE *)(a4 - 8);
      v38 = (const char *)a1[15];
      if ( !v37 )
        goto LABEL_74;
      if ( !*v38 )
        goto LABEL_83;
      v39 = 0;
      v46 = v37 - 1;
      break;
    case 2:
      v10 = a2[14] >> 1;
      v11 = (int)((__int64)a2[13] >> 1);
      v12 = a2[15] >> 1;
      goto LABEL_34;
    case 3:
      v29 = a2[14] >> 1;
      v24 = (int)((__int64)a2[13] >> 1);
      v12 = a2[15] >> 1;
      goto LABEL_36;
    case 4:
      v10 = a2[14] >> 1;
      v11 = (int)((__int64)a2[13] >> 1);
      v12 = a2[15] >> 1;
      *(_QWORD *)(*a2 + 8 * v11) = 2LL * (int)v10 + 1;
      caml_modify((unsigned __int64 *)(a2[1] + 8 * v11), a4);
      v13 = (int)((__int64)a2[10] >> 1);
      caml_modify((unsigned __int64 *)(8 * v11 + a2[3]), *(_QWORD *)(a2[3] + 8 * v13));
      v14 = 2LL * (int)v10;
      if ( v11 > v13 )
      {
        caml_modify((unsigned __int64 *)(a2[2] + 8 * v11), *(_QWORD *)(a2[3] + 8 * v13));
        v14 = 2LL * (int)v10;
      }
      goto LABEL_6;
    case 5:
      v10 = a2[14] >> 1;
      v11 = (int)((__int64)a2[13] >> 1);
      v12 = a2[15] >> 1;
      goto LABEL_19;
    default:
      return 3LL;
  }
  while ( 1 )
  {
    v43 = v39;
    v38 += strlen(v38) + 1;
    if ( v46 == v43 )
      break;
    v39 = v43 + 1;
    if ( !*v38 )
    {
LABEL_83:
      v38 = "<unknown token>";
      break;
    }
  }
LABEL_74:
  __fprintf_chk(stderr, 1LL, "State %d: read token %s(", (unsigned int)v10, v38);
  v40 = *(_QWORD *)a4;
  if ( (*(_QWORD *)a4 & 1) != 0 )
  {
    __fprintf_chk(stderr, 1LL, (const char *)&off_43DDF7, v40 >> 1);
  }
  else
  {
    v41 = *(_BYTE *)(v40 - 8);
    if ( v41 == -4 )
    {
      __fprintf_chk(stderr, 1LL, "%s", (const char *)v40);
    }
    else if ( v41 == -3 )
    {
      __fprintf_chk(stderr, 1LL, "%g", *(double *)v40);
    }
    else
    {
      __fprintf_chk(stderr, 1LL, "_");
    }
  }
  __fprintf_chk(stderr, 1LL, ")\n");
LABEL_40:
  v14 = 2LL * (int)v10;
  v17 = a2[6] >> 1;
  while ( 1 )
  {
LABEL_8:
    LODWORD(v18) = v17 + *(__int16 *)(a1[7] + v14);
    if ( (int)v18 >= 0 )
    {
      if ( *(_WORD *)(a1[7] + v14) )
      {
        if ( (int)v18 <= (int)((__int64)a1[10] >> 1) )
        {
          v18 = (int)v18;
          a6 = 2LL * (int)v18;
          if ( *(__int16 *)(a1[12] + a6) == (_DWORD)v17 )
          {
            a2[6] = -1LL;
            LODWORD(v12) = v12 - ((int)v12 > 0);
            goto LABEL_56;
          }
        }
      }
    }
    v19 = *(__int16 *)(a1[8] + v14);
    v20 = v17 + v19;
    if ( (int)v17 + v19 >= 0
      && v19
      && v20 <= (int)((__int64)a1[10] >> 1)
      && *(__int16 *)(a1[12] + 2LL * v20) == (_DWORD)v17 )
    {
      break;
    }
    if ( (int)v12 <= 0 )
    {
      a2[13] = 2 * v11 + 1;
      a2[14] = 2LL * (int)v10 + 1;
      a2[15] = 2LL * (int)v12 + 1;
      return 11LL;
    }
LABEL_19:
    if ( (int)v12 > 2 )
    {
      if ( !(unsigned int)(a2[6] >> 1) )
        return 3LL;
      if ( caml_parser_trace )
        __fprintf_chk(stderr, 1LL, "Discarding last token read\n");
      v21 = a1[5];
      a2[6] = -1LL;
      v14 = 2LL * (int)v10;
      v16 = *(__int16 *)(v21 + v14);
      if ( *(_WORD *)(v21 + v14) )
        goto LABEL_24;
      goto LABEL_7;
    }
    v30 = caml_parser_trace;
    for ( i = 8 * v11; ; i -= 8LL )
    {
      v32 = (unsigned int)(*(__int64 *)(*a2 + i) >> 1);
      LODWORD(v18) = *(__int16 *)(a1[7] + 2LL * (int)(*(__int64 *)(*a2 + i) >> 1)) + 256;
      if ( (int)v18 >= 0 )
      {
        if ( *(_WORD *)(a1[7] + 2LL * (int)(*(__int64 *)(*a2 + i) >> 1)) )
        {
          if ( (int)v18 <= (int)((__int64)a1[10] >> 1) )
          {
            v18 = (int)v18;
            a6 = 2LL * (int)v18;
            if ( *(_WORD *)(a1[12] + a6) == 256 )
              break;
          }
        }
      }
      if ( v30 )
      {
        __fprintf_chk(stderr, 1LL, "Discarding state %d\n", v32);
        v30 = caml_parser_trace;
      }
      if ( v11 <= (int)((__int64)a2[5] >> 1) )
      {
        if ( !v30 )
          return 3LL;
        __fprintf_chk(stderr, 1LL, "No more states to discard\n", v32, a5, a6);
        return 3LL;
      }
      --v11;
    }
    LODWORD(v12) = 3;
    if ( !v30 )
      goto LABEL_58;
    __fprintf_chk(stderr, 1LL, "Recovering in state %d\n", v32);
    a6 = 2LL * (int)v18;
LABEL_56:
    if ( caml_parser_trace )
    {
      v44 = a6;
      __fprintf_chk(
        stderr,
        1LL,
        "State %d: shift to state %d\n",
        (unsigned int)v10,
        (unsigned int)*(__int16 *)(a1[11] + a6));
      a6 = v44;
    }
    else
    {
      a6 = 2 * v18;
    }
LABEL_58:
    ++v11;
    LODWORD(v10) = *(__int16 *)(a1[11] + a6);
    if ( v11 >= (__int64)a2[4] >> 1 )
    {
      a2[13] = 2 * v11 + 1;
      a2[14] = 2LL * (int)v10 + 1;
      a2[15] = 2LL * (int)v12 + 1;
      return 5LL;
    }
LABEL_34:
    *(_QWORD *)(*a2 + 8 * v11) = 2LL * (int)v10 + 1;
    caml_modify((unsigned __int64 *)(a2[1] + 8 * v11), a2[7]);
    caml_modify((unsigned __int64 *)(a2[2] + 8 * v11), a2[8]);
    caml_modify((unsigned __int64 *)(a2[3] + 8 * v11), a2[9]);
    v14 = 2LL * (int)v10;
LABEL_6:
    v15 = a1[5];
    v16 = *(__int16 *)(v15 + v14);
    if ( *(_WORD *)(v15 + v14) )
      goto LABEL_24;
LABEL_7:
    v17 = a2[6] >> 1;
    if ( (int)v17 < 0 )
    {
      a2[13] = 2 * v11 + 1;
      a2[14] = 2LL * (int)v10 + 1;
      a2[15] = 2LL * (int)v12 + 1;
      return 1LL;
    }
  }
  v16 = *(__int16 *)(a1[11] + 2LL * v20);
LABEL_24:
  if ( caml_parser_trace )
    __fprintf_chk(stderr, 1LL, "State %d: reduce by rule %d\n", (unsigned int)v10, v16);
  v22 = a1[4];
  a2[10] = 2 * v11 + 1;
  LODWORD(v22) = *(__int16 *)(v22 + 2LL * (int)v16);
  a2[12] = 2LL * (int)v16 + 1;
  v23 = 2LL * (int)v22 + 1;
  v24 = v11 + 1 - (int)v22;
  v25 = *a2;
  a2[11] = v23;
  v26 = *(_QWORD *)(v25 + 8 * v24 - 8) >> 1;
  v27 = *(__int16 *)(a1[3] + 2LL * (int)v16);
  v28 = *(__int16 *)(a1[9] + 2 * v27) + (_DWORD)v26;
  if ( v28 >= 0
    && *(_WORD *)(a1[9] + 2 * v27)
    && v28 <= (int)((__int64)a1[10] >> 1)
    && *(__int16 *)(a1[12] + 2LL * v28) == (_DWORD)v26 )
  {
    LODWORD(v29) = *(__int16 *)(a1[11] + 2LL * v28);
  }
  else
  {
    LODWORD(v29) = *(__int16 *)(a1[6] + 2 * v27);
  }
  if ( v24 < (__int64)a2[4] >> 1 )
  {
LABEL_36:
    a2[13] = 2 * v24 + 1;
    a2[14] = 2LL * (int)v29 + 1;
    a2[15] = 2LL * (int)v12 + 1;
    return 9LL;
  }
  else
  {
    a2[13] = 2 * v24 + 1;
    a2[14] = 2LL * (int)v29 + 1;
    a2[15] = 2LL * (int)v12 + 1;
    return 7LL;
  }
}
// 43703B: variable 'v32' is possibly undefined
// 43703B: variable 'a5' is possibly undefined
// 43703B: variable 'a6' is possibly undefined
// 40A438: using guessed type __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...);
// 43DDF7: using guessed type void *__ptr32 off_43DDF7;
// 662730: using guessed type int caml_parser_trace;

//----- (00000000004373E0) ----------------------------------------------------
int __fastcall caml_init_gc(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v5; // rsi
  __int64 v9; // rbp
  unsigned __int64 v10; // r14
  __int64 v11; // rdi
  unsigned __int64 v12; // rdx
  __int64 v13; // rax

  v5 = (unsigned __int64)(a2 + 511) >> 9;
  v9 = 8LL;
  v10 = 0x2000LL;
  if ( v5 << 9 > 0x3FF )
  {
    v10 = v5 << 12;
    v9 = (4 * v5) & 0x3FFFFFFFFFFFFFLL;
  }
  caml_page_table_initialize(v10 + 8 * a1);
  if ( a1 <= 4095 )
  {
    a1 = 4096LL;
LABEL_5:
    v11 = 8 * a1;
    goto LABEL_6;
  }
  if ( a1 <= 0x10000000 )
    goto LABEL_5;
  v11 = 0x80000000LL;
LABEL_6:
  caml_set_minor_heap_size(v11);
  v12 = (unsigned __int64)(a3 + 511) >> 9;
  v13 = 0x2000LL;
  caml_percent_max = a5;
  if ( v12 << 9 > 0x3FF )
    v13 = v12 << 12;
  caml_major_heap_increment = v13;
  if ( !a4 )
    a4 = 1LL;
  caml_percent_free = a4;
  caml_init_major_heap(v10);
  caml_gc_message(32, "Initial minor heap size: %luk bytes\n", (unsigned __int64)caml_minor_heap_size >> 10);
  caml_gc_message(32, "Initial major heap size: %luk bytes\n", v9);
  caml_gc_message(32, "Initial space overhead: %lu%%\n", caml_percent_free);
  caml_gc_message(32, "Initial max overhead: %lu%%\n", caml_percent_max);
  caml_gc_message(32, "Initial heap increment: %luk bytes\n", (unsigned __int64)caml_major_heap_increment >> 10);
  return caml_gc_message(32, "Initial allocation policy: %d\n", caml_allocation_policy);
}
// 65AD08: using guessed type __int64 caml_allocation_policy;
// 663398: using guessed type __int64 caml_percent_free;
// 6633C8: using guessed type __int64 caml_major_heap_increment;
// 6633D8: using guessed type __int64 caml_minor_heap_size;
// 6633F0: using guessed type __int64 caml_percent_max;

//----- (0000000000437580) ----------------------------------------------------
int __fastcall test_and_compact(__m128d a1)
{
  double v1; // xmm0_8
  signed __int64 v2; // rdx
  double v3; // xmm1_8
  float v4; // xmm0_4
  __int64 v5; // rdx
  int result; // eax
  float v7; // xmm1_4
  unsigned __int64 v8; // rcx

  if ( caml_fl_cur_size < 0 )
    v1 = (double)(int)(caml_fl_cur_size & 1 | ((unsigned __int64)caml_fl_cur_size >> 1))
       + (double)(int)(caml_fl_cur_size & 1 | ((unsigned __int64)caml_fl_cur_size >> 1));
  else
    v1 = (double)(int)caml_fl_cur_size;
  a1.m128d_f64[0] = v1 * 100.0;
  v2 = ((unsigned __int64)caml_stat_heap_size >> 3) - caml_fl_cur_size;
  if ( v2 < 0 )
  {
    v8 = v2 & 1 | ((((unsigned __int64)caml_stat_heap_size >> 3) - caml_fl_cur_size) >> 1);
    v3 = (double)(int)v8 + (double)(int)v8;
  }
  else
  {
    v3 = (double)(int)v2;
  }
  a1.m128d_f64[0] = a1.m128d_f64[0] / v3;
  v4 = _mm_unpacklo_pd(a1, a1).m128d_f64[0];
  if ( v4 <= 999999.0 )
  {
    if ( v4 < 9.223372e18 )
      v5 = (unsigned int)(int)v4;
    else
      v5 = (unsigned int)(int)(float)(v4 - 9.223372e18) ^ 0x8000000000000000LL;
  }
  else
  {
    v5 = 999999LL;
    v4 = 999999.0;
  }
  caml_gc_message(512, "Estimated overhead (lower bound) = %lu%%\n", v5);
  result = caml_percent_max;
  if ( caml_percent_max < 0 )
  {
    result = caml_percent_max & 1;
    v7 = (float)(int)(result | ((unsigned __int64)caml_percent_max >> 1))
       + (float)(int)(result | ((unsigned __int64)caml_percent_max >> 1));
  }
  else
  {
    v7 = (float)(int)caml_percent_max;
  }
  if ( v4 >= v7 && caml_stat_heap_chunks > 1 )
  {
    caml_gc_message(512, "Automatic compaction triggered.\n", 0LL);
    return caml_compact_heap();
  }
  return result;
}
// 65AD00: using guessed type __int64 caml_fl_cur_size;
// 662760: using guessed type __int64 caml_stat_heap_size;
// 662778: using guessed type __int64 caml_stat_heap_chunks;
// 6633F0: using guessed type __int64 caml_percent_max;

//----- (00000000004376E0) ----------------------------------------------------
__int64 caml_gc_compaction()
{
  caml_empty_minor_heap();
  caml_finish_major_cycle();
  caml_finish_major_cycle();
  caml_compact_heap();
  caml_final_do_calls();
  return 1LL;
}
// 4376E0: using guessed type __int64 __fastcall caml_gc_compaction();

//----- (0000000000437710) ----------------------------------------------------
__int64 __fastcall caml_gc_full_major(__m128d a1)
{
  caml_gc_message(1, "Full major GC cycle requested\n", 0LL);
  caml_empty_minor_heap();
  caml_finish_major_cycle();
  caml_final_do_calls();
  caml_empty_minor_heap();
  caml_finish_major_cycle();
  test_and_compact(a1);
  caml_final_do_calls();
  return 1LL;
}

//----- (0000000000437760) ----------------------------------------------------
__int64 __fastcall caml_gc_major(__m128d a1)
{
  caml_gc_message(1, "Major GC cycle requested\n", 0LL);
  caml_empty_minor_heap();
  caml_finish_major_cycle();
  test_and_compact(a1);
  caml_final_do_calls();
  return 1LL;
}

//----- (00000000004377A0) ----------------------------------------------------
__int64 __fastcall caml_gc_major_slice(__int64 a1)
{
  caml_empty_minor_heap();
  return 2 * caml_major_collection_slice(a1 >> 1) + 1;
}

//----- (00000000004377C0) ----------------------------------------------------
__int64 caml_gc_minor()
{
  caml_minor_collection();
  return 1LL;
}
// 4377C0: using guessed type __int64 __fastcall caml_gc_minor();

//----- (00000000004377E0) ----------------------------------------------------
__int64 __fastcall caml_gc_set(__int64 *a1)
{
  __int64 v1; // rdx
  __int64 v2; // rdx
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // rcx
  __int64 v5; // rbp
  __int64 v6; // rbx

  caml_verb_gc = a1[3] >> 1;
  v1 = a1[2] >> 1;
  if ( !v1 )
    v1 = 1LL;
  if ( caml_percent_free != v1 )
  {
    caml_percent_free = v1;
    caml_gc_message(32, "New space overhead: %d%%\n", v1);
  }
  v2 = a1[4] >> 1;
  if ( v2 != caml_percent_max )
  {
    caml_percent_max = a1[4] >> 1;
    caml_gc_message(32, "New max overhead: %d%%\n", v2);
  }
  v3 = 0x2000LL;
  v4 = (unsigned __int64)((a1[1] >> 1) + 511) >> 9;
  if ( v4 << 9 > 0x3FF )
    v3 = v4 << 12;
  if ( caml_major_heap_increment != v3 )
  {
    caml_major_heap_increment = v3;
    caml_gc_message(32, "New heap increment size: %luk bytes\n", v3 >> 10);
  }
  v5 = a1[6] >> 1 != 0;
  if ( caml_allocation_policy != v5 )
  {
    caml_gc_message(32, "New allocation policy: %d\n", v5);
    caml_set_allocation_policy(v5);
  }
  v6 = 8 * (*a1 >> 1);
  if ( v6 > 4095 )
  {
    if ( v6 > 0x10000000 )
      v6 = 0x10000000LL;
  }
  else
  {
    v6 = 4096LL;
  }
  if ( caml_minor_heap_size != v6 )
  {
    caml_gc_message(32, "New minor heap size: %luk bytes\n", (unsigned __int64)v6 >> 10);
    caml_set_minor_heap_size(v6);
  }
  return 1LL;
}
// 65ACE0: using guessed type __int64 caml_verb_gc;
// 65AD08: using guessed type __int64 caml_allocation_policy;
// 663398: using guessed type __int64 caml_percent_free;
// 6633C8: using guessed type __int64 caml_major_heap_increment;
// 6633D8: using guessed type __int64 caml_minor_heap_size;
// 6633F0: using guessed type __int64 caml_percent_max;

//----- (0000000000437930) ----------------------------------------------------
unsigned __int64 *caml_gc_get()
{
  __int64 v0; // rbx
  __int64 v2[9]; // [rsp+0h] [rbp-58h] BYREF
  unsigned __int64 *v3; // [rsp+48h] [rbp-10h] BYREF

  v0 = caml_local_roots;
  v3 = 0LL;
  caml_local_roots = (__int64)v2;
  v2[2] = 1LL;
  v2[1] = 1LL;
  v2[0] = v0;
  v2[3] = (__int64)&v3;
  v3 = (unsigned __int64 *)caml_alloc_tuple(7uLL);
  caml_modify(v3, 2 * ((unsigned __int64)caml_minor_heap_size >> 3) + 1);
  caml_modify(v3 + 1, 2 * ((unsigned __int64)caml_major_heap_increment >> 3) + 1);
  caml_modify(v3 + 2, 2 * caml_percent_free + 1);
  caml_modify(v3 + 3, 2 * caml_verb_gc + 1);
  caml_modify(v3 + 4, 2 * caml_percent_max + 1);
  caml_modify(v3 + 5, 1uLL);
  caml_modify(v3 + 6, 2 * caml_allocation_policy + 1);
  caml_local_roots = v0;
  return v3;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65ACE0: using guessed type __int64 caml_verb_gc;
// 65AD08: using guessed type __int64 caml_allocation_policy;
// 663398: using guessed type __int64 caml_percent_free;
// 6633C8: using guessed type __int64 caml_major_heap_increment;
// 6633D8: using guessed type __int64 caml_minor_heap_size;
// 6633F0: using guessed type __int64 caml_percent_max;

//----- (0000000000437A40) ----------------------------------------------------
unsigned __int64 *caml_gc_counters()
{
  __int64 v0; // rbx
  double v1; // xmm1_8
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  double v6; // [rsp+0h] [rbp-88h]
  double v7; // [rsp+10h] [rbp-78h]
  double v8; // [rsp+20h] [rbp-68h]
  __int64 v9[9]; // [rsp+30h] [rbp-58h] BYREF
  unsigned __int64 *v10; // [rsp+78h] [rbp-10h] BYREF

  v0 = caml_local_roots;
  v10 = 0LL;
  v9[2] = 1LL;
  v9[1] = 1LL;
  caml_local_roots = (__int64)v9;
  v9[0] = v0;
  v9[3] = (__int64)&v10;
  if ( caml_allocated_words < 0 )
    v1 = (double)(int)(caml_allocated_words & 1 | ((unsigned __int64)caml_allocated_words >> 1))
       + (double)(int)(caml_allocated_words & 1 | ((unsigned __int64)caml_allocated_words >> 1));
  else
    v1 = (double)(int)caml_allocated_words;
  v7 = *(double *)&caml_stat_promoted_words;
  v8 = (double)(int)((unsigned __int64)(caml_young_end - caml_young_ptr) >> 3) + *(double *)&caml_stat_minor_words;
  v6 = v1 + *(double *)&caml_stat_major_words;
  v10 = (unsigned __int64 *)caml_alloc_tuple(3uLL);
  v2 = caml_copy_double(v8);
  caml_modify(v10, v2);
  v3 = caml_copy_double(v7);
  caml_modify(v10 + 1, v3);
  v4 = caml_copy_double(v6);
  caml_modify(v10 + 2, v4);
  caml_local_roots = v0;
  return v10;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 662738: using guessed type __int64 caml_stat_minor_words;
// 662740: using guessed type __int64 caml_stat_promoted_words;
// 662748: using guessed type __int64 caml_stat_major_words;
// 6633C0: using guessed type __int64 caml_allocated_words;

//----- (0000000000437B70) ----------------------------------------------------
unsigned __int64 *caml_gc_quick_stat()
{
  __int64 v0; // r12
  double v1; // xmm1_8
  __int64 v2; // r15
  __int64 v3; // r13
  __int64 v4; // r14
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // rbp
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v11; // [rsp+8h] [rbp-C0h]
  double v12; // [rsp+10h] [rbp-B8h]
  double v13; // [rsp+20h] [rbp-A8h]
  double v14; // [rsp+30h] [rbp-98h]
  __int64 v15[9]; // [rsp+40h] [rbp-88h] BYREF
  unsigned __int64 *v16; // [rsp+88h] [rbp-40h] BYREF

  v0 = caml_local_roots;
  v16 = 0LL;
  v15[2] = 1LL;
  v15[1] = 1LL;
  caml_local_roots = (__int64)v15;
  v15[0] = v0;
  v15[3] = (__int64)&v16;
  if ( caml_allocated_words < 0 )
    v1 = (double)(int)(caml_allocated_words & 1 | ((unsigned __int64)caml_allocated_words >> 1))
       + (double)(int)(caml_allocated_words & 1 | ((unsigned __int64)caml_allocated_words >> 1));
  else
    v1 = (double)(int)caml_allocated_words;
  v13 = *(double *)&caml_stat_promoted_words;
  v2 = caml_stat_major_collections;
  v3 = caml_stat_compactions;
  v4 = caml_stat_heap_chunks;
  v14 = (double)(int)((unsigned __int64)(caml_young_end - caml_young_ptr) >> 3) + *(double *)&caml_stat_minor_words;
  v11 = caml_stat_minor_collections;
  v5 = caml_stat_top_heap_size;
  v6 = (unsigned __int64)caml_stat_heap_size >> 3;
  v12 = v1 + *(double *)&caml_stat_major_words;
  v16 = (unsigned __int64 *)caml_alloc_tuple(0xFuLL);
  v7 = caml_copy_double(v14);
  caml_modify(v16, v7);
  v8 = caml_copy_double(v13);
  caml_modify(v16 + 1, v8);
  v9 = caml_copy_double(v12);
  caml_modify(v16 + 2, v9);
  caml_modify(v16 + 3, 2 * v11 + 1);
  caml_modify(v16 + 4, 2 * v2 + 1);
  caml_modify(v16 + 5, 2 * v6 + 1);
  caml_modify(v16 + 6, 2 * v4 + 1);
  caml_modify(v16 + 7, 1uLL);
  caml_modify(v16 + 8, 1uLL);
  caml_modify(v16 + 9, 1uLL);
  caml_modify(v16 + 10, 1uLL);
  caml_modify(v16 + 11, 1uLL);
  caml_modify(v16 + 12, 1uLL);
  caml_modify(v16 + 13, 2 * v3 + 1);
  caml_modify(v16 + 14, 2 * (v5 >> 3) + 1);
  caml_local_roots = v0;
  return v16;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 662738: using guessed type __int64 caml_stat_minor_words;
// 662740: using guessed type __int64 caml_stat_promoted_words;
// 662748: using guessed type __int64 caml_stat_major_words;
// 662750: using guessed type __int64 caml_stat_minor_collections;
// 662758: using guessed type __int64 caml_stat_major_collections;
// 662760: using guessed type __int64 caml_stat_heap_size;
// 662768: using guessed type __int64 caml_stat_top_heap_size;
// 662770: using guessed type __int64 caml_stat_compactions;
// 662778: using guessed type __int64 caml_stat_heap_chunks;
// 6633C0: using guessed type __int64 caml_allocated_words;

//----- (0000000000437E20) ----------------------------------------------------
unsigned __int64 *caml_gc_stat()
{
  char *v0; // rax
  __int64 v1; // r12
  __int64 v2; // r8
  unsigned __int64 v3; // rsi
  __int64 v4; // r9
  __int64 v5; // r10
  __int64 v6; // rdi
  __int64 v7; // rbp
  __int64 v8; // r11
  char *v9; // rbx
  char *v10; // r13
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // r15
  unsigned __int64 v16; // r14
  unsigned __int64 v17; // r13
  double v18; // xmm1_8
  unsigned __int64 v19; // rbp
  unsigned __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // rdx
  __int64 v27; // [rsp+8h] [rbp-F0h]
  __int64 v28; // [rsp+10h] [rbp-E8h]
  __int64 v29; // [rsp+18h] [rbp-E0h]
  double v30; // [rsp+20h] [rbp-D8h]
  double v31; // [rsp+30h] [rbp-C8h]
  double v32; // [rsp+40h] [rbp-B8h]
  unsigned __int64 v33; // [rsp+50h] [rbp-A8h]
  unsigned __int64 v34; // [rsp+58h] [rbp-A0h]
  unsigned __int64 v35; // [rsp+60h] [rbp-98h]
  unsigned __int64 v36; // [rsp+68h] [rbp-90h]
  __int64 v37[9]; // [rsp+70h] [rbp-88h] BYREF
  unsigned __int64 *v38; // [rsp+B8h] [rbp-40h] BYREF

  v0 = (char *)caml_heap_start;
  v1 = caml_local_roots;
  if ( caml_heap_start )
  {
    v2 = 0LL;
    v3 = 0LL;
    v4 = 0LL;
    v5 = 0LL;
    v6 = 0LL;
    v7 = 0LL;
    v8 = 0LL;
    while ( 1 )
    {
      v9 = &v0[*((_QWORD *)v0 - 2)];
      ++v8;
      v10 = v0 - 32;
      if ( v9 > v0 )
        break;
LABEL_14:
      v0 = (char *)*((_QWORD *)v10 + 3);
      if ( !v0 )
      {
        v15 = 2 * v8 + 1;
        v16 = 2 * v7 + 1;
        v17 = 2 * v6 + 1;
        v36 = 2 * v5 + 1;
        v35 = 2 * v4 + 1;
        v34 = 2 * v3 + 1;
        v33 = 2 * v2 + 1;
        goto LABEL_16;
      }
    }
    while ( 1 )
    {
      v13 = *(_QWORD *)v0;
      v14 = *(_QWORD *)v0 & 0x300LL;
      if ( v14 == 256 )
        goto LABEL_22;
      if ( v14 <= 0x100 )
      {
        if ( !v14 )
        {
          v11 = v13 >> 10;
          if ( v11 )
          {
            if ( caml_gc_phase == 1 && caml_gc_sweep_hp <= (unsigned __int64)v0 )
            {
              v5 += v11 + 1;
              v12 = v11 + 1;
              ++v4;
              if ( v12 > v3 )
                v3 = v12;
            }
            else
            {
              v7 += v11 + 1;
              ++v6;
              v12 = v11 + 1;
            }
          }
          else
          {
            ++v2;
            v12 = 1LL;
          }
          goto LABEL_8;
        }
LABEL_13:
        v0 += 8 * (v13 >> 10) + 8;
        if ( v9 <= v0 )
          goto LABEL_14;
      }
      else
      {
        if ( v14 == 512 )
        {
          v25 = v13 >> 10;
          ++v4;
          v5 += v25 + 1;
          v12 = v25 + 1;
          if ( v12 > v3 )
            v3 = v12;
          goto LABEL_8;
        }
        if ( v14 != 768 )
          goto LABEL_13;
LABEL_22:
        v26 = v13 >> 10;
        ++v6;
        v7 += v26 + 1;
        v12 = v26 + 1;
LABEL_8:
        v0 += 8 * v12;
        if ( v9 <= v0 )
          goto LABEL_14;
      }
    }
  }
  v33 = 1LL;
  v34 = 1LL;
  v17 = 1LL;
  v35 = 1LL;
  v36 = 1LL;
  v16 = 1LL;
  v15 = 1LL;
LABEL_16:
  v38 = 0LL;
  v37[0] = caml_local_roots;
  v37[2] = 1LL;
  v37[1] = 1LL;
  caml_local_roots = (__int64)v37;
  v37[3] = (__int64)&v38;
  if ( caml_allocated_words < 0 )
    v18 = (double)(int)(caml_allocated_words & 1 | ((unsigned __int64)caml_allocated_words >> 1))
        + (double)(int)(caml_allocated_words & 1 | ((unsigned __int64)caml_allocated_words >> 1));
  else
    v18 = (double)(int)caml_allocated_words;
  v31 = *(double *)&caml_stat_promoted_words;
  v32 = (double)(int)((unsigned __int64)(caml_young_end - caml_young_ptr) >> 3) + *(double *)&caml_stat_minor_words;
  v27 = caml_stat_compactions;
  v28 = caml_stat_major_collections;
  v29 = caml_stat_minor_collections;
  v19 = (unsigned __int64)caml_stat_heap_size >> 3;
  v20 = (unsigned __int64)caml_stat_top_heap_size >> 3;
  v30 = v18 + *(double *)&caml_stat_major_words;
  v38 = (unsigned __int64 *)caml_alloc_tuple(0xFuLL);
  v21 = caml_copy_double(v32);
  caml_modify(v38, v21);
  v22 = caml_copy_double(v31);
  caml_modify(v38 + 1, v22);
  v23 = caml_copy_double(v30);
  caml_modify(v38 + 2, v23);
  caml_modify(v38 + 3, 2 * v29 + 1);
  caml_modify(v38 + 4, 2 * v28 + 1);
  caml_modify(v38 + 5, 2 * v19 + 1);
  caml_modify(v38 + 6, v15);
  caml_modify(v38 + 7, v16);
  caml_modify(v38 + 8, v17);
  caml_modify(v38 + 9, v36);
  caml_modify(v38 + 10, v35);
  caml_modify(v38 + 11, v34);
  caml_modify(v38 + 12, v33);
  caml_modify(v38 + 13, 2 * v27 + 1);
  caml_modify(v38 + 14, 2 * v20 + 1);
  caml_local_roots = v1;
  return v38;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 662738: using guessed type __int64 caml_stat_minor_words;
// 662740: using guessed type __int64 caml_stat_promoted_words;
// 662748: using guessed type __int64 caml_stat_major_words;
// 662750: using guessed type __int64 caml_stat_minor_collections;
// 662758: using guessed type __int64 caml_stat_major_collections;
// 662760: using guessed type __int64 caml_stat_heap_size;
// 662768: using guessed type __int64 caml_stat_top_heap_size;
// 662770: using guessed type __int64 caml_stat_compactions;
// 663390: using guessed type __int64 caml_gc_sweep_hp;
// 6633B0: using guessed type int caml_gc_phase;
// 6633C0: using guessed type __int64 caml_allocated_words;

//----- (00000000004382A0) ----------------------------------------------------
void __fastcall caml_MD5Init(_DWORD *a1)
{
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[4] = 0;
  a1[5] = 0;
}

//----- (00000000004382D0) ----------------------------------------------------
__int64 __fastcall caml_MD5Transform(_DWORD *a1, int *a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // er14
  int v5; // er13
  int v6; // er8
  int v7; // er10
  int v8; // er12
  int v9; // er9
  int v10; // er11
  int v11; // eax
  int v12; // edx
  int v13; // ebx
  int v14; // ecx
  int v15; // er15
  int v16; // er14
  int v17; // eax
  int v18; // edx
  int v19; // er15
  int v20; // er14
  int v21; // eax
  int v22; // edx
  int v23; // ebp
  int v24; // er15
  int v25; // er14
  int v26; // eax
  int v27; // edx
  int v28; // ecx
  int v29; // er15
  int v30; // er14
  int v31; // eax
  int v32; // edx
  int v33; // esi
  int v34; // er14
  int v35; // eax
  int v36; // edx
  int v37; // esi
  int v38; // er14
  int v39; // eax
  int v40; // edx
  int v41; // esi
  int v42; // er14
  int v43; // eax
  int v44; // edx
  int v45; // esi
  int v46; // er14
  int v47; // er15
  int v48; // edx
  int v49; // esi
  int v50; // er14
  int v51; // er15
  int v52; // eax
  int v53; // edx
  int v54; // er14
  int v55; // esi
  int v56; // er15
  int v57; // eax
  int v58; // edx
  int v59; // esi
  int v60; // er15
  int v61; // eax
  int v62; // edx
  int v63; // er13
  int v64; // er12
  int v65; // ebp
  int v66; // edx
  int v67; // er13
  int v68; // er12
  int v69; // ebp
  int v70; // edx
  int v71; // er13
  int v72; // esi
  int v73; // ebx
  int v74; // edx
  int v75; // eax
  int v76; // esi
  int v77; // ecx
  int v78; // ebx
  int v79; // edx
  int v80; // eax
  int v81; // ecx
  __int64 result; // rax
  int v83; // [rsp+0h] [rbp-50h]
  int v84; // [rsp+4h] [rbp-4Ch]
  int v85; // [rsp+8h] [rbp-48h]
  int v86; // [rsp+Ch] [rbp-44h]
  int v87; // [rsp+10h] [rbp-40h]
  int v88; // [rsp+14h] [rbp-3Ch]
  int v89; // [rsp+18h] [rbp-38h]

  v2 = a1[3];
  v3 = a1[2];
  v4 = a1[1];
  v5 = *a2;
  v6 = a2[1];
  v7 = a2[3];
  v8 = a2[7];
  v9 = a2[10];
  v10 = a2[12];
  v88 = a2[4];
  v11 = v4 + __ROR4__(*a1 + *a2 - 680876936 + (v2 ^ v4 & (v3 ^ v2)), 25);
  v12 = v11 + __ROR4__((v3 ^ v11 & (v4 ^ v3)) + v2 + v6 - 389564586, 20);
  v89 = a2[2];
  v13 = a2[5];
  v14 = __ROR4__(v3 + v89 + 606105819 + (v4 ^ v12 & (v4 ^ v11)), 15);
  v15 = v14 + v12;
  v16 = v14 + v12 + __ROR4__((v11 ^ (v14 + v12) & (v11 ^ v12)) + v4 + v7 - 1044525330, 10);
  v86 = a2[8];
  v17 = v16 + __ROR4__((v12 ^ v16 & (v12 ^ (v14 + v12))) + v11 + v88 - 176418897, 25);
  v18 = v17 + __ROR4__((v15 ^ v17 & (v15 ^ v16)) + v12 + v13 + 1200080426, 20);
  v87 = a2[6];
  v19 = v18 + __ROR4__((v16 ^ v18 & (v16 ^ v17)) + v15 + v87 - 1473231341, 15);
  v20 = v19 + __ROR4__((v17 ^ v19 & (v17 ^ v18)) + v16 + v8 - 45705983, 10);
  v84 = a2[11];
  v21 = v20 + __ROR4__((v18 ^ v20 & (v18 ^ v19)) + v17 + v86 + 1770035416, 25);
  v85 = a2[9];
  v22 = v21 + __ROR4__((v19 ^ v21 & (v19 ^ v20)) + v18 + v85 - 1958414417, 20);
  v23 = a2[14];
  v24 = v22 + __ROR4__((v20 ^ v22 & (v20 ^ v21)) + v19 + v9 - 42063, 15);
  v25 = v24 + __ROR4__((v21 ^ v24 & (v21 ^ v22)) + v20 + v84 - 1990404162, 10);
  v26 = v25 + __ROR4__((v22 ^ v25 & (v22 ^ v24)) + v21 + v10 + 1804603682, 25);
  v83 = a2[13];
  v27 = v26 + __ROR4__((v24 ^ v26 & (v24 ^ v25)) + v22 + v83 - 40341101, 20);
  v28 = a2[15];
  v29 = v27 + __ROR4__((v25 ^ v27 & (v25 ^ v26)) + v24 + v23 - 1502002290, 15);
  v30 = v29 + __ROR4__((v26 ^ v29 & (v26 ^ v27)) + v25 + v28 + 1236535329, 10);
  v31 = v30 + __ROR4__((v29 ^ v27 & (v29 ^ v30)) + v26 + v6 - 165796510, 27);
  v32 = v31 + __ROR4__((v30 ^ v29 & (v30 ^ v31)) + v27 + v87 - 1069501632, 23);
  v33 = v32 + __ROR4__(v29 + v84 + 643717713 + (v31 ^ v30 & (v31 ^ v32)), 18);
  v34 = v33 + __ROR4__((v32 ^ v31 & (v32 ^ v33)) + v30 + v5 - 373897302, 12);
  v35 = v34 + __ROR4__((v33 ^ v32 & (v33 ^ v34)) + v31 + v13 - 701558691, 27);
  v36 = v35 + __ROR4__((v34 ^ v33 & (v34 ^ v35)) + v32 + v9 + 38016083, 23);
  v37 = v36 + __ROR4__((v35 ^ v34 & (v35 ^ v36)) + v33 + v28 - 660478335, 18);
  v38 = v37 + __ROR4__((v36 ^ v35 & (v36 ^ v37)) + v34 + v88 - 405537848, 12);
  v39 = v38 + __ROR4__((v37 ^ v36 & (v37 ^ v38)) + v35 + v85 + 568446438, 27);
  v40 = v39 + __ROR4__((v38 ^ v37 & (v38 ^ v39)) + v36 + v23 - 1019803690, 23);
  v41 = v40 + __ROR4__((v39 ^ v38 & (v39 ^ v40)) + v37 + v7 - 187363961, 18);
  v42 = v41 + __ROR4__((v40 ^ v39 & (v40 ^ v41)) + v38 + v86 + 1163531501, 12);
  v43 = v42 + __ROR4__((v41 ^ v40 & (v41 ^ v42)) + v39 + v83 - 1444681467, 27);
  v44 = v43 + __ROR4__((v42 ^ v41 & (v42 ^ v43)) + v40 + v89 - 51403784, 23);
  v45 = v44 + __ROR4__((v43 ^ v42 & (v43 ^ v44)) + v41 + v8 + 1735328473, 18);
  v46 = v45 + __ROR4__(v42 + v10 - 1926607734 + (v44 ^ v43 & (v44 ^ v45)), 12);
  v47 = v46 + __ROR4__(v43 + v13 - 378558 + (v46 ^ v44 ^ v45), 28);
  v48 = v47 + __ROR4__((v47 ^ v45 ^ v46) + v44 + v86 - 2022574463, 21);
  v49 = v48 + __ROR4__((v48 ^ v46 ^ v47) + v45 + v84 + 1839030562, 16);
  v50 = v49 + __ROR4__((v49 ^ v47 ^ v48) + v46 + v23 - 35309556, 9);
  v51 = v50 + __ROR4__((v50 ^ v48 ^ v49) + v47 + v6 - 1530992060, 28);
  v52 = v51 + __ROR4__(v48 + v88 + 1272893353 + (v51 ^ v49 ^ v50), 21);
  v53 = v52 + __ROR4__(v49 + v8 - 155497632 + (v52 ^ v50 ^ v51), 16);
  v54 = v53 + __ROR4__((v53 ^ v51 ^ v52) + v50 + v9 - 1094730640, 9);
  v55 = v54 + __ROR4__(v51 + v83 + 681279174 + (v54 ^ v52 ^ v53), 28);
  v56 = v55 + __ROR4__(v52 + v5 - 358537222 + (v55 ^ v53 ^ v54), 21);
  v57 = v56 + __ROR4__(v53 + v7 - 722521979 + (v56 ^ v54 ^ v55), 16);
  v58 = v57 + __ROR4__(v54 + v87 + 76029189 + (v57 ^ v55 ^ v56), 9);
  v59 = v58 + __ROR4__((v58 ^ v56 ^ v57) + v55 + v85 - 640364487, 28);
  v60 = v59 + __ROR4__((v59 ^ v57 ^ v58) + v56 + v10 - 421815835, 21);
  v61 = v60 + __ROR4__((v60 ^ v58 ^ v59) + v57 + v28 + 530742520, 16);
  v62 = v61 + __ROR4__((v61 ^ v59 ^ v60) + v58 + v89 - 995338651, 9);
  v63 = v62 + __ROR4__((v61 ^ (v62 | ~v60)) + v59 + v5 - 198630844, 26);
  v64 = v63 + __ROR4__((v62 ^ (v63 | ~v61)) + v60 + v8 + 1126891415, 22);
  v65 = v64 + __ROR4__((v63 ^ (v64 | ~v62)) + v61 + v23 - 1416354905, 17);
  v66 = v65 + __ROR4__((v64 ^ (v65 | ~v63)) + v62 + v13 - 57434055, 11);
  v67 = v66 + __ROR4__((v65 ^ (v66 | ~v64)) + v63 + v10 + 1700485571, 26);
  v68 = v67 + __ROR4__((v66 ^ (v67 | ~v65)) + v64 + v7 - 1894986606, 22);
  v69 = v68 + __ROR4__((v67 ^ (v68 | ~v66)) + v65 + v9 - 1051523, 17);
  v70 = v69 + __ROR4__((v68 ^ (v69 | ~v67)) + v66 + v6 - 2054922799, 11);
  v71 = v70 + __ROR4__((v69 ^ (v70 | ~v68)) + v67 + v86 + 1873313359, 26);
  v72 = v71 + __ROR4__((v70 ^ (v71 | ~v69)) + v68 + v28 - 30611744, 22);
  v73 = v72 + __ROR4__((v71 ^ (v72 | ~v70)) + v69 + v87 - 1560198380, 17);
  v74 = v73 + __ROR4__((v72 ^ (v73 | ~v71)) + v70 + v83 + 1309151649, 11);
  v75 = v74 + __ROR4__((v73 ^ (v74 | ~v72)) + v71 + v88 - 145523070, 26);
  v76 = v75 + __ROR4__(v72 + v84 - 1120210379 + (v74 ^ (v75 | ~v73)), 22);
  a1[3] += v76;
  v77 = v73 + v89 + 718787259 + (v75 ^ (v76 | ~v74));
  v78 = v74 + v85 - 343485551;
  v79 = v75;
  v80 = *a1 + v75;
  v81 = v76 + __ROR4__(v77, 17);
  a1[2] += v81;
  *a1 = v80;
  result = (unsigned int)(v81 + a1[1]);
  a1[1] = result + __ROR4__(v78 + (v76 ^ (v81 | ~v79)), 11);
  return result;
}

//----- (0000000000438A50) ----------------------------------------------------
void *__fastcall caml_MD5Update(__int64 a1, char *a2, size_t a3)
{
  char *v3; // r13
  unsigned __int64 v5; // rbp
  unsigned int v6; // er14
  unsigned int v7; // eax
  int v8; // eax
  _QWORD *v9; // rbx
  unsigned int v10; // er14
  void *v11; // rdi
  size_t v12; // rax
  size_t v13; // r14
  __int64 v14; // r14
  char *v15; // rax
  unsigned __int64 v16; // rax

  v3 = a2;
  v5 = a3;
  v6 = *(_DWORD *)(a1 + 16);
  v7 = v6 + 8 * a3;
  *(_DWORD *)(a1 + 16) = v7;
  if ( v6 > v7 )
  {
    v8 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v8;
  }
  else
  {
    v8 = *(_DWORD *)(a1 + 20);
  }
  v9 = (_QWORD *)(a1 + 24);
  v10 = (v6 >> 3) & 0x3F;
  *(_DWORD *)(a1 + 20) = (a3 >> 29) + v8;
  if ( v10 )
  {
    v11 = (void *)(a1 + v10 + 24);
    v12 = 64 - v10;
    v13 = v12;
    if ( a3 < v12 )
      return memcpy(v11, a2, a3);
    v3 = &a2[v12];
    memcpy(v11, a2, v12);
    v5 -= v13;
    caml_MD5Transform((_DWORD *)a1, (int *)(a1 + 24));
  }
  if ( v5 > 0x3F )
  {
    v14 = 0LL;
    do
    {
      v15 = &v3[v14];
      v14 += 64LL;
      *v9 = *(_QWORD *)v15;
      *(_QWORD *)(a1 + 32) = *((_QWORD *)v15 + 1);
      *(_QWORD *)(a1 + 40) = *((_QWORD *)v15 + 2);
      *(_QWORD *)(a1 + 48) = *((_QWORD *)v15 + 3);
      *(_QWORD *)(a1 + 56) = *((_QWORD *)v15 + 4);
      *(_QWORD *)(a1 + 64) = *((_QWORD *)v15 + 5);
      *(_QWORD *)(a1 + 72) = *((_QWORD *)v15 + 6);
      *(_QWORD *)(a1 + 80) = *((_QWORD *)v15 + 7);
      caml_MD5Transform((_DWORD *)a1, (int *)(a1 + 24));
    }
    while ( v5 - v14 > 0x3F );
    v16 = v5 - 64;
    v5 = ((_DWORD)v5 - 64) & 0x3F;
    v3 += (v16 & 0xFFFFFFFFFFFFFFC0LL) + 64;
  }
  a3 = v5;
  a2 = v3;
  v11 = (void *)(a1 + 24);
  return memcpy(v11, a2, a3);
}

//----- (0000000000438B80) ----------------------------------------------------
__int64 __fastcall caml_MD5Final(_QWORD *a1, __int64 a2)
{
  unsigned int v3; // eax
  void *v4; // rdi
  unsigned int v5; // edx
  int *v6; // r12
  __int64 result; // rax
  _WORD *v8; // rdi
  unsigned int v9; // edx
  __int64 v10; // rcx
  _DWORD *v11; // rdi

  v3 = (*(_DWORD *)(a2 + 16) >> 3) & 0x3F;
  *(_BYTE *)(a2 + v3 + 24) = 0x80;
  v4 = (void *)(a2 + v3 + 25);
  v5 = 63 - v3;
  if ( 63 - v3 <= 7 )
  {
    v6 = (int *)(a2 + 24);
    memset(v4, 0, v5);
    caml_MD5Transform((_DWORD *)a2, (int *)(a2 + 24));
    v8 = (_WORD *)(a2 + 24);
    v9 = 56;
    if ( (((_BYTE)a2 + 24) & 1) != 0 )
    {
      *(_BYTE *)(a2 + 24) = 0;
      v8 = (_WORD *)(a2 + 25);
      LOBYTE(v9) = 55;
    }
    if ( ((unsigned __int8)v8 & 2) != 0 )
    {
      *v8 = 0;
      v9 -= 2;
      ++v8;
    }
    if ( ((unsigned __int8)v8 & 4) != 0 )
    {
      *(_DWORD *)v8 = 0;
      v9 -= 4;
      v8 += 2;
    }
    v10 = v9 >> 3;
    memset(v8, 0, 8 * v10);
    v11 = &v8[4 * v10];
    if ( (v9 & 4) != 0 )
    {
      *v11++ = 0;
      if ( (v9 & 2) == 0 )
      {
LABEL_12:
        if ( (v9 & 1) == 0 )
          goto LABEL_3;
LABEL_13:
        *(_BYTE *)v11 = 0;
        goto LABEL_3;
      }
    }
    else if ( (v9 & 2) == 0 )
    {
      goto LABEL_12;
    }
    *(_WORD *)v11 = 0;
    v11 = (_DWORD *)((char *)v11 + 2);
    if ( (v9 & 1) == 0 )
      goto LABEL_3;
    goto LABEL_13;
  }
  v6 = (int *)(a2 + 24);
  memset(v4, 0, v5 - 8);
LABEL_3:
  v6[14] = *(_DWORD *)(a2 + 16);
  v6[15] = *(_DWORD *)(a2 + 20);
  caml_MD5Transform((_DWORD *)a2, v6);
  *a1 = *(_QWORD *)a2;
  result = *(_QWORD *)(a2 + 8);
  a1[1] = result;
  *(_QWORD *)a2 = 0LL;
  return result;
}

//----- (0000000000438CE0) ----------------------------------------------------
_QWORD *__fastcall caml_md5_chan(__int64 a1, __int64 a2)
{
  __int64 v2; // r13
  __int64 v3; // rbx
  __int64 v4; // rdx
  int v5; // eax
  _QWORD *v6; // rbx
  int v8; // eax
  __int64 v9; // [rsp+0h] [rbp-10F8h]
  __int64 v10; // [rsp+8h] [rbp-10F0h]
  __int64 v11; // [rsp+10h] [rbp-10E8h] BYREF
  __int64 v12; // [rsp+18h] [rbp-10E0h] BYREF
  __int64 v13[8]; // [rsp+20h] [rbp-10D8h] BYREF
  char v14[4096]; // [rsp+60h] [rbp-1098h] BYREF
  int v15[22]; // [rsp+1060h] [rbp-98h] BYREF
  unsigned __int64 v16; // [rsp+10B8h] [rbp-40h]

  v2 = *(_QWORD *)(a1 + 8);
  v16 = __readfsqword(0x28u);
  v12 = a1;
  v11 = a2;
  v13[2] = 1LL;
  v13[1] = 2LL;
  v10 = caml_local_roots;
  v13[0] = caml_local_roots;
  caml_local_roots = (__int64)v13;
  v13[3] = (__int64)&v12;
  v13[4] = (__int64)&v11;
  if ( caml_channel_mutex_lock )
    caml_channel_mutex_lock(v2);
  v15[0] = 1732584193;
  v15[1] = -271733879;
  v15[2] = -1732584194;
  v15[3] = 271733878;
  v15[4] = 0;
  v3 = v11 >> 1;
  v15[5] = 0;
  if ( v11 >> 1 < 0 )
  {
    while ( 1 )
    {
      v8 = caml_getblock(v2, v14, 4096LL);
      if ( !v8 )
        break;
      caml_MD5Update((__int64)v15, v14, v8);
    }
  }
  else if ( v11 >> 1 )
  {
    do
    {
      v4 = 4096LL;
      if ( (unsigned __int64)v3 <= 0x1000 )
        v4 = v3;
      v5 = caml_getblock(v2, v14, v4);
      if ( !v5 )
        caml_raise_end_of_file();
      v9 = v5;
      caml_MD5Update((__int64)v15, v14, v5);
      v3 -= v9;
    }
    while ( v3 > 0 );
  }
  v6 = caml_alloc_string(16LL);
  caml_MD5Final(v6, (__int64)v15);
  if ( caml_channel_mutex_unlock )
    caml_channel_mutex_unlock(v2);
  caml_local_roots = v10;
  return v6;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65E5F0: using guessed type __int64 (__fastcall *caml_channel_mutex_lock)(_QWORD);
// 65E5F8: using guessed type __int64 (__fastcall *caml_channel_mutex_unlock)(_QWORD);

//----- (0000000000438ED0) ----------------------------------------------------
_QWORD *__fastcall caml_md5_string(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbp
  int v5[22]; // [rsp+0h] [rbp-78h] BYREF
  unsigned __int64 v6; // [rsp+58h] [rbp-20h]

  v5[0] = 1732584193;
  v5[1] = -271733879;
  v6 = __readfsqword(0x28u);
  v5[2] = -1732584194;
  v5[3] = 271733878;
  v5[4] = 0;
  v5[5] = 0;
  caml_MD5Update((__int64)v5, (char *)(a1 + (a2 >> 1)), a3 >> 1);
  v3 = caml_alloc_string(16LL);
  caml_MD5Final(v3, (__int64)v5);
  return v3;
}

//----- (0000000000438F60) ----------------------------------------------------
__int64 __fastcall caml_obj_is_block(char a1)
{
  return (a1 & 1) == 0LL ? 3LL : 1LL;
}

//----- (0000000000438F80) ----------------------------------------------------
__int64 __fastcall caml_obj_set_tag(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = 1LL;
  *(_BYTE *)(a1 - 8) = a2 >> 1;
  return result;
}

//----- (0000000000438F90) ----------------------------------------------------
__int64 __fastcall caml_obj_add_offset(__int64 a1, __int64 a2)
{
  return a1 + *(int *)(a2 + 8);
}

//----- (0000000000438FA0) ----------------------------------------------------
__int64 __fastcall caml_get_public_method(int **a1, __int64 a2)
{
  int *v2; // rdi
  int v3; // er8
  int v4; // edx
  int v5; // eax
  __int64 result; // rax
  int *v7; // rdx
  int v8; // er8

  v2 = *a1;
  v3 = 3;
  v4 = *v2;
  if ( *v2 <= 3 )
  {
LABEL_6:
    result = 0LL;
    v7 = &v2[2 * v3];
    if ( *(_QWORD *)v7 == a2 )
      return *((_QWORD *)v7 - 1);
  }
  else
  {
    while ( 1 )
    {
      v5 = ((v4 + v3) >> 1) | 1;
      if ( a2 >= *(_QWORD *)&v2[2 * v5] )
        break;
LABEL_5:
      v4 = v5 - 2;
      if ( v3 >= v5 - 2 )
        goto LABEL_6;
    }
    while ( 1 )
    {
      v3 = v5;
      if ( v4 <= v5 )
        break;
      v5 = ((v4 + v5) >> 1) | 1;
      if ( *(_QWORD *)&v2[2 * v5] > a2 )
        goto LABEL_5;
    }
    v8 = v5;
    result = 0LL;
    v7 = &v2[2 * v8];
    if ( *(_QWORD *)v7 == a2 )
      return *((_QWORD *)v7 - 1);
  }
  return result;
}

//----- (0000000000439020) ----------------------------------------------------
unsigned __int64 __fastcall caml_lazy_follow_forward(unsigned __int64 a1)
{
  unsigned __int64 v1; // rbx

  v1 = a1;
  if ( (a1 & 1) == 0 && (caml_page_table_lookup(a1) & 7) != 0 && *(_BYTE *)(a1 - 8) == 0xFA )
    return *(_QWORD *)a1;
  return v1;
}

//----- (0000000000439050) ----------------------------------------------------
char __fastcall caml_obj_tag(unsigned __int64 a1)
{
  char result; // al
  char v2; // dl

  result = -47;
  if ( (a1 & 1) == 0 )
  {
    result = -43;
    if ( (a1 & 7) == 0 )
    {
      v2 = caml_page_table_lookup(a1);
      result = -45;
      if ( (v2 & 7) != 0 )
        return 2 * *(_BYTE *)(a1 - 8) + 1;
    }
  }
  return result;
}

//----- (0000000000439090) ----------------------------------------------------
unsigned __int64 *__fastcall caml_lazy_make_forward(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // rbp
  unsigned __int64 v3; // rax
  unsigned __int64 **v4; // rdx
  unsigned __int64 *result; // rax
  __int64 v6; // [rsp+8h] [rbp-B0h] BYREF
  __int64 v7[8]; // [rsp+10h] [rbp-A8h] BYREF
  __int64 v8[9]; // [rsp+50h] [rbp-68h] BYREF
  unsigned __int64 *v9; // [rsp+98h] [rbp-20h] BYREF

  v1 = caml_local_roots;
  v6 = a1;
  v8[2] = 1LL;
  v8[1] = 1LL;
  v8[3] = (__int64)&v6;
  v8[0] = caml_local_roots;
  v9 = 0LL;
  v7[2] = 1LL;
  v7[0] = (__int64)v8;
  v7[1] = 1LL;
  caml_local_roots = (__int64)v7;
  v7[3] = (__int64)&v9;
  v9 = caml_alloc_small(1LL, 0xFAu);
  v2 = *v9;
  *v9 = v6;
  if ( (caml_page_table_lookup((unsigned __int64)v9) & 1) == 0 )
    goto LABEL_12;
  if ( !caml_gc_phase )
  {
    caml_darken(v2);
    v3 = v6;
    if ( (v6 & 1) == 0 )
      goto LABEL_4;
LABEL_12:
    result = v9;
    goto LABEL_13;
  }
  v3 = v6;
  if ( (v6 & 1) != 0 )
    goto LABEL_12;
LABEL_4:
  if ( v3 >= caml_young_end || v3 <= caml_young_start || (v2 & 1) == 0 && caml_young_end > v2 && caml_young_start < v2 )
    goto LABEL_12;
  v4 = (unsigned __int64 **)qword_65CD18;
  if ( qword_65CD18 >= (unsigned __int64)qword_65CD20 )
  {
    caml_realloc_ref_table((__int64)&caml_ref_table);
    v4 = (unsigned __int64 **)qword_65CD18;
  }
  result = v9;
  *v4 = v9;
  qword_65CD18 = (__int64)(v4 + 1);
LABEL_13:
  caml_local_roots = v1;
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CD18: using guessed type __int64 qword_65CD18;
// 65CD20: using guessed type __int64 qword_65CD20;
// 6633B0: using guessed type int caml_gc_phase;

//----- (0000000000439210) ----------------------------------------------------
__int64 __fastcall caml_obj_truncate(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // r12
  unsigned __int64 v3; // r15
  unsigned __int64 v4; // r13
  unsigned __int64 *v5; // rbp
  unsigned __int64 v6; // rbx

  v2 = a2 >> 1;
  v3 = *(_QWORD *)(a1 - 8);
  v4 = v3 >> 10;
  if ( a2 >> 1 > v3 >> 10 || !v2 )
    caml_invalid_argument(&unk_43E0E8);
  if ( v2 != v4 )
  {
    if ( (unsigned __int8)v3 <= 0xFAu && v2 < v4 )
    {
      v5 = (unsigned __int64 *)(a1 + 8 * v2);
      v6 = a2 >> 1;
      do
      {
        ++v6;
        caml_modify(v5++, 1uLL);
      }
      while ( v4 > v6 );
    }
    *(_QWORD *)(a1 + 8 * v2) = ((~v2 + v4) << 10) + 1;
    *(_QWORD *)(a1 - 8) = (unsigned __int8)v3 + (v3 & 0x300) + (v2 << 10);
  }
  return 1LL;
}

//----- (0000000000439300) ----------------------------------------------------
char *__fastcall caml_obj_block(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int64 v3; // rbx
  char *result; // rax
  unsigned __int64 v5; // rdx

  v2 = a1 >> 1;
  v3 = a2 >> 1;
  result = (char *)&unk_662968 + 8 * (unsigned int)v2;
  if ( a2 >> 1 )
  {
    result = caml_alloc(v3, v2);
    v5 = 0LL;
    do
      *(_QWORD *)&result[8 * v5++] = 1LL;
    while ( v3 > v5 );
  }
  return result;
}

//----- (0000000000439350) ----------------------------------------------------
char *__fastcall caml_obj_dup(char *a1)
{
  char *result; // rax
  __int64 v2; // rbx
  unsigned __int64 v3; // rbp
  unsigned __int64 v4; // rbp
  unsigned int v5; // esi
  __int64 v6; // rdi
  __int64 v7; // rbp
  char *v8; // rax
  __int64 v9; // rdx
  unsigned __int64 v10; // r12
  __int64 *v11; // rax
  unsigned __int64 *v12; // rdi
  unsigned __int64 v13; // rsi
  void *src; // [rsp+8h] [rbp-B0h] BYREF
  __int64 v15[8]; // [rsp+10h] [rbp-A8h] BYREF
  __int64 v16[9]; // [rsp+50h] [rbp-68h] BYREF
  char *i; // [rsp+98h] [rbp-20h] BYREF

  result = a1;
  v2 = caml_local_roots;
  src = a1;
  v16[2] = 1LL;
  v16[1] = 1LL;
  i = 0LL;
  v16[3] = (__int64)&src;
  v15[2] = 1LL;
  v15[1] = 1LL;
  v3 = *((_QWORD *)a1 - 1);
  v15[0] = (__int64)v16;
  v16[0] = caml_local_roots;
  caml_local_roots = (__int64)v15;
  v4 = v3 >> 10;
  v15[3] = (__int64)&i;
  if ( v4 )
  {
    v5 = (unsigned __int8)*(a1 - 8);
    if ( v5 > 0xFA )
    {
      i = caml_alloc(v4, v5);
      memcpy(i, src, 8 * v4);
    }
    else if ( v4 > 0x100 )
    {
      v10 = 0LL;
      v11 = caml_alloc_shr(v4, v5);
      for ( i = (char *)v11; ; v11 = (__int64 *)i )
      {
        v12 = (unsigned __int64 *)&v11[v10];
        v13 = *((_QWORD *)src + v10++);
        caml_initialize(v12, v13);
        if ( v4 <= v10 )
          break;
      }
    }
    else
    {
      v6 = v4;
      v7 = 8 * v4;
      v8 = (char *)caml_alloc_small(v6, v5);
      v9 = 0LL;
      for ( i = v8; ; v8 = i )
      {
        *(_QWORD *)&v8[v9] = *(_QWORD *)((char *)src + v9);
        v9 += 8LL;
        if ( v9 == v7 )
          break;
      }
    }
    caml_local_roots = v2;
    return i;
  }
  else
  {
    caml_local_roots = v2;
  }
  return result;
}
// 658A68: using guessed type __int64 caml_local_roots;

//----- (00000000004394E0) ----------------------------------------------------
void *__fastcall caml_static_resize(void *a1, __int64 a2)
{
  return caml_stat_resize(a1, a2 >> 1);
}

//----- (00000000004394F0) ----------------------------------------------------
void __noreturn caml_static_release_bytecode()
{
  caml_failwith("Meta.static_release_bytecode impossible with native code");
}
// 4394F0: using guessed type void __fastcall __noreturn caml_static_release_bytecode();

//----- (0000000000439500) ----------------------------------------------------
__int64 __fastcall caml_static_free(void *a1)
{
  caml_stat_free(a1);
  return 1LL;
}

//----- (0000000000439520) ----------------------------------------------------
void *__fastcall caml_static_alloc(__int64 a1)
{
  return caml_stat_alloc(a1 >> 1);
}

//----- (0000000000439530) ----------------------------------------------------
size_t __fastcall add_string(char **a1, const char *a2)
{
  size_t result; // rax
  char *v4; // rdi
  size_t v5; // rbp
  char *v6; // rdx

  result = strlen(a2);
  v4 = *a1;
  v5 = (int)result;
  v6 = a1[1];
  if ( v6 < &(*a1)[(int)result] )
  {
    result = (unsigned int)((_DWORD)v6 - (_DWORD)v4);
    v5 = (int)result;
  }
  if ( (int)result > 0 )
  {
    result = (size_t)memmove(v4, a2, v5);
    v4 = *a1;
  }
  *a1 = &v4[v5];
  return result;
}

//----- (00000000004395A0) ----------------------------------------------------
void *__fastcall caml_format_exception(__int64 a1)
{
  _QWORD *v1; // r12
  unsigned __int64 v2; // rax
  __int64 v3; // rdx
  unsigned __int64 v4; // r14
  char *v5; // rax
  const char **v6; // rbp
  unsigned __int64 v7; // rbx
  char *v8; // rax
  const char *v9; // rsi
  char *v10; // rax
  char *v11; // rax
  char *v12; // rax
  size_t v13; // rbp
  void *v14; // rax
  void *v15; // rbx
  char *v17; // [rsp+0h] [rbp-198h] BYREF
  char *v18; // [rsp+8h] [rbp-190h]
  char v19[255]; // [rsp+10h] [rbp-188h] BYREF
  char v20; // [rsp+10Fh] [rbp-89h] BYREF
  char v21[72]; // [rsp+110h] [rbp-88h] BYREF
  unsigned __int64 v22; // [rsp+158h] [rbp-40h]

  v1 = (_QWORD *)(a1 - 8);
  v22 = __readfsqword(0x28u);
  v17 = v19;
  v18 = &v20;
  add_string(&v17, **(const char ***)a1);
  v2 = *(_QWORD *)(a1 - 8) >> 10;
  if ( v2 <= 1 )
  {
    v12 = v17;
  }
  else
  {
    if ( v2 != 2 || (v3 = *(_QWORD *)(a1 + 8), (v3 & 1) != 0) || *(_BYTE *)(v3 - 8) )
    {
      v3 = a1;
      v4 = 1LL;
    }
    else
    {
      v1 = (_QWORD *)(v3 - 8);
      v4 = 0LL;
    }
    v5 = v17;
    if ( v17 < v18 )
    {
      *v17 = 40;
      v17 = v5 + 1;
    }
    if ( v4 < *v1 >> 10 )
    {
      v6 = (const char **)(v3 + 8 * v4);
      v7 = v4;
      while ( 1 )
      {
        v9 = *v6;
        if ( ((unsigned __int8)*v6 & 1) != 0 )
        {
          __sprintf_chk(v21, 1LL, 64LL, &off_43DDF7, (__int64)v9 >> 1);
          add_string(&v17, v21);
        }
        else if ( *(v9 - 8) == -4 )
        {
          v10 = v17;
          if ( v17 < v18 )
          {
            *v17 = 34;
            v17 = v10 + 1;
          }
          add_string(&v17, v9);
          v11 = v17;
          if ( v17 < v18 )
          {
            *v17 = 34;
            v17 = v11 + 1;
          }
        }
        else
        {
          v8 = v17;
          if ( v17 < v18 )
          {
            *v17 = 95;
            v17 = v8 + 1;
          }
        }
        if ( *v1 >> 10 <= ++v7 )
          break;
        if ( v4 < v7 )
          add_string(&v17, ", ");
        ++v6;
      }
    }
    v12 = v17;
    if ( v17 < v18 )
    {
      *v17 = 41;
      v17 = ++v12;
    }
  }
  *v12 = 0;
  v13 = v17 - v19 + 1;
  v14 = malloc(v13);
  v15 = v14;
  if ( v14 )
    memmove(v14, v19, v13);
  return v15;
}
// 40AB48: using guessed type __int64 __fastcall __sprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 43DDF7: using guessed type void *__ptr32 off_43DDF7;

//----- (00000000004397E0) ----------------------------------------------------
void __fastcall __noreturn caml_fatal_uncaught_exception(__int64 a1)
{
  char *v1; // rax
  int v2; // er12
  char *v3; // rbx
  int v4; // ebp

  v1 = (char *)caml_format_exception(a1);
  v2 = caml_backtrace_active;
  v3 = v1;
  v4 = caml_backtrace_pos;
  caml_backtrace_active = 0;
  if ( caml_named_value("Pervasives.do_at_exit") )
    caml_callback_exn();
  caml_backtrace_active = v2;
  caml_backtrace_pos = v4;
  __fprintf_chk(stderr, 1LL, "Fatal error: exception %s\n", v3);
  free(v3);
  if ( caml_backtrace_active )
    caml_print_exception_backtrace();
  exit(2);
}
// 40A438: using guessed type __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...);
// 662848: using guessed type int caml_backtrace_active;
// 66284C: using guessed type int caml_backtrace_pos;

//----- (0000000000439880) ----------------------------------------------------
__int64 __fastcall caml_named_value(char *s1)
{
  unsigned int v1; // ecx
  unsigned int v2; // edx
  char *v3; // rsi
  char v4; // al
  __int64 v5; // rbp

  v1 = 0;
  v2 = 0;
  v3 = s1;
  v4 = *s1;
  if ( *s1 )
  {
    do
    {
      ++v3;
      v1 = v4 + 19 * v1;
      v4 = *v3;
    }
    while ( *v3 );
    v2 = v1 % 0xD;
  }
  v5 = named_value_table[v2];
  if ( !v5 )
    return 0LL;
  while ( strcmp(s1, (const char *)(v5 + 16)) )
  {
    v5 = *(_QWORD *)(v5 + 8);
    if ( !v5 )
      return 0LL;
  }
  return v5;
}
// 662780: using guessed type __int64 named_value_table[13];

//----- (0000000000439920) ----------------------------------------------------
__int64 __fastcall caml_register_named_value(char *src, __int64 a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // edx
  char *v5; // rsi
  char v6; // al
  __int64 v7; // r13
  __int64 v8; // r12
  size_t v10; // rax
  char *v11; // r12
  __int64 v12; // rax

  v2 = 0;
  v3 = 0;
  v5 = src;
  v6 = *src;
  if ( *src )
  {
    do
    {
      ++v5;
      v2 = v6 + 19 * v2;
      v6 = *v5;
    }
    while ( *v5 );
    v3 = v2 % 0xD;
  }
  v7 = v3;
  v8 = named_value_table[v3];
  if ( v8 )
  {
    while ( strcmp(src, (const char *)(v8 + 16)) )
    {
      v8 = *(_QWORD *)(v8 + 8);
      if ( !v8 )
        goto LABEL_9;
    }
    *(_QWORD *)v8 = a2;
    return 1LL;
  }
  else
  {
LABEL_9:
    v10 = strlen(src);
    v11 = (char *)caml_stat_alloc(v10 + 24);
    strcpy(v11 + 16, src);
    v12 = named_value_table[v7];
    *(_QWORD *)v11 = a2;
    *((_QWORD *)v11 + 1) = v12;
    named_value_table[v7] = (__int64)v11;
    caml_register_global_root((unsigned __int64)v11);
    return 1LL;
  }
}
// 662780: using guessed type __int64 named_value_table[13];

//----- (0000000000439A20) ----------------------------------------------------
void caml_callback3()
{
  __int64 v0; // rax

  caml_callback3_exn();
  if ( (v0 & 3) == 2 )
    caml_raise(v0 & 0xFFFFFFFFFFFFFFFCLL);
}
// 439A2C: variable 'v0' is possibly undefined

//----- (0000000000439A50) ----------------------------------------------------
void caml_callback2()
{
  __int64 v0; // rax

  caml_callback2_exn();
  if ( (v0 & 3) == 2 )
    caml_raise(v0 & 0xFFFFFFFFFFFFFFFCLL);
}
// 439A5C: variable 'v0' is possibly undefined

//----- (0000000000439A80) ----------------------------------------------------
void caml_callback()
{
  __int64 v0; // rax

  caml_callback_exn();
  if ( (v0 & 3) == 2 )
    caml_raise(v0 & 0xFFFFFFFFFFFFFFFCLL);
}
// 439A8C: variable 'v0' is possibly undefined

//----- (0000000000439AB0) ----------------------------------------------------
void __fastcall caml_callbackN_exn(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // r13
  int v4; // ebx
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // [rsp+8h] [rbp-100h] BYREF
  __int64 v9[8]; // [rsp+10h] [rbp-F8h] BYREF
  __int64 v10[8]; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v11[9]; // [rsp+90h] [rbp-78h] BYREF
  __int64 v12; // [rsp+D8h] [rbp-30h] BYREF

  v3 = caml_local_roots;
  v8 = a1;
  v12 = a1;
  caml_local_roots = (__int64)v9;
  if ( a2 > 0 )
  {
    v11[0] = v3;
    v11[2] = 1LL;
    v11[1] = 1LL;
    v10[1] = 1LL;
    v4 = 0;
    v11[3] = (__int64)&v8;
    v10[3] = a3;
    v9[2] = 1LL;
    v9[1] = 1LL;
    v10[0] = (__int64)v11;
    v10[2] = a2;
    v9[0] = (__int64)v10;
    v9[3] = (__int64)&v12;
    do
    {
      while ( a2 - v4 != 1 )
      {
        if ( a2 - v4 == 2 )
        {
          caml_callback2_exn();
          if ( (v7 & 3) == 2 )
            goto LABEL_10;
          v12 = v7;
          v4 += 2;
        }
        else
        {
          caml_callback3_exn();
          if ( (v5 & 3) == 2 )
            goto LABEL_10;
          v12 = v5;
          v4 += 3;
        }
        if ( a2 <= v4 )
          goto LABEL_10;
      }
      caml_callback_exn();
      if ( (v6 & 3) == 2 )
        break;
      ++v4;
      v12 = v6;
    }
    while ( a2 > v4 );
  }
LABEL_10:
  caml_local_roots = v3;
}
// 439B95: variable 'v5' is possibly undefined
// 439BD0: variable 'v6' is possibly undefined
// 439C1F: variable 'v7' is possibly undefined
// 658A68: using guessed type __int64 caml_local_roots;

//----- (0000000000439C40) ----------------------------------------------------
void __fastcall caml_callbackN(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // rax

  caml_callbackN_exn(a1, a2, a3);
  if ( (v3 & 3) == 2 )
    caml_raise(v3 & 0xFFFFFFFFFFFFFFFCLL);
}
// 439C4C: variable 'v3' is possibly undefined

//----- (0000000000439C70) ----------------------------------------------------
__int64 __fastcall caml_weak_check(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rsi

  v2 = (a2 >> 1) + 1;
  if ( !v2 || v2 >= *(_QWORD *)(a1 - 8) >> 10 )
    caml_invalid_argument("Weak.get");
  return 2LL * (*(_QWORD *)(a1 + 8 * v2) != (_QWORD)caml_weak_none) + 1;
}
// 658868: using guessed type void *caml_weak_none;

//----- (0000000000439CB0) ----------------------------------------------------
void __fastcall do_set(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rcx
  unsigned __int64 *v5; // rbx
  unsigned __int64 v6; // rsi
  unsigned __int64 **v7; // rax

  if ( (a3 & 1) != 0 || (v3 = caml_young_end, a3 >= caml_young_end) || (v4 = caml_young_start, a3 <= caml_young_start) )
  {
    *(_QWORD *)(a1 + 8 * a2) = a3;
  }
  else
  {
    v5 = (unsigned __int64 *)(a1 + 8 * a2);
    v6 = *v5;
    *v5 = a3;
    if ( (v6 & 1) != 0 || v3 <= v6 || v4 >= v6 )
    {
      v7 = (unsigned __int64 **)qword_65CD58;
      if ( qword_65CD58 >= (unsigned __int64)qword_65CD60 )
      {
        caml_realloc_ref_table((__int64)&caml_weak_ref_table);
        v7 = (unsigned __int64 **)qword_65CD58;
      }
      *v7 = v5;
      qword_65CD58 = (__int64)(v7 + 1);
    }
  }
}
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CD58: using guessed type __int64 qword_65CD58;
// 65CD60: using guessed type __int64 qword_65CD60;

//----- (0000000000439D30) ----------------------------------------------------
__int64 __fastcall caml_weak_blit(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rsi
  unsigned __int64 v7; // r13
  unsigned __int64 v8; // r12
  __int64 v9; // rcx
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rsi
  unsigned __int64 j; // r15
  __int64 v14; // r13
  unsigned __int64 v15; // rsi
  __int64 v16; // r12
  unsigned __int64 *v17; // rbp
  unsigned __int64 v18; // rdx
  __int64 v19; // rsi
  unsigned __int64 v20; // rax
  unsigned __int64 i; // r15
  unsigned __int64 v22; // rax
  unsigned __int64 *v23; // r8
  char v24; // al
  __int64 v25; // [rsp+8h] [rbp-50h]
  _QWORD *v26; // [rsp+10h] [rbp-48h]
  unsigned __int64 v27; // [rsp+18h] [rbp-40h]

  v5 = a2 >> 1;
  v7 = v5 + 1;
  if ( v5 == -1
    || (v8 = a5 >> 1, (a5 >> 1) + v7 > *(_QWORD *)(a1 - 8) >> 10)
    || (v9 = a4 >> 1, v10 = v9 + 1, v9 == -1)
    || v8 + v10 > *(_QWORD *)(a3 - 8) >> 10 )
  {
    caml_invalid_argument("Weak.blit");
  }
  if ( !caml_gc_phase && caml_gc_subphase == 11 && v8 )
  {
    v20 = 0LL;
    for ( i = 0LL; i < v8; v20 = i )
    {
      v22 = v7 + v20;
      v23 = (unsigned __int64 *)(a1 + 8 * v22);
      if ( (void *)*v23 != caml_weak_none && (*v23 & 1) == 0 )
      {
        v27 = *v23;
        v25 = v9;
        v26 = (_QWORD *)(a1 + 8 * v22);
        v24 = caml_page_table_lookup(*v23);
        v9 = v25;
        if ( (v24 & 1) != 0 && (*(_QWORD *)(v27 - 8) & 0x300LL) == 0 )
          *v26 = caml_weak_none;
      }
      ++i;
    }
  }
  if ( v7 <= v10 )
  {
    v14 = v8 - 1;
    if ( (__int64)(v8 - 1) >= 0 )
    {
      v15 = v8 + v5;
      v16 = v9 + v8;
      v17 = (unsigned __int64 *)(a1 + 8 * v15);
      do
      {
        v18 = *v17;
        v19 = v16;
        --v17;
        --v16;
        do_set(a3, v19, v18);
        --v14;
      }
      while ( v14 >= 0 );
    }
  }
  else if ( v8 )
  {
    v11 = 0LL;
    for ( j = 0LL; j < v8; v11 = j )
    {
      ++j;
      do_set(a3, v10 + v11, *(_QWORD *)(a1 + 8 * (v11 + v7)));
    }
  }
  return 1LL;
}
// 658868: using guessed type void *caml_weak_none;
// 663388: using guessed type int caml_gc_subphase;
// 6633B0: using guessed type int caml_gc_phase;

//----- (0000000000439ED0) ----------------------------------------------------
__int64 __fastcall caml_weak_set(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // rsi

  v3 = (a2 >> 1) + 1;
  if ( !v3 || v3 >= *(_QWORD *)(a1 - 8) >> 10 )
    caml_invalid_argument("Weak.set");
  if ( a3 == (unsigned __int64 *)1 || ((unsigned __int8)a3 & 1) != 0 )
  {
    *(_QWORD *)(a1 + 8 * v3) = caml_weak_none;
    return 1LL;
  }
  else
  {
    do_set(a1, v3, *a3);
    return 1LL;
  }
}
// 658868: using guessed type void *caml_weak_none;

//----- (0000000000439F30) ----------------------------------------------------
__int64 __fastcall caml_weak_get(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rdi
  __int64 result; // rax
  __int64 v6; // [rsp+0h] [rbp-A8h] BYREF
  __int64 v7; // [rsp+8h] [rbp-A0h] BYREF
  __int64 v8[8]; // [rsp+10h] [rbp-98h] BYREF
  __int64 v9[8]; // [rsp+50h] [rbp-58h] BYREF
  unsigned __int64 v10; // [rsp+90h] [rbp-18h] BYREF
  _QWORD *v11; // [rsp+98h] [rbp-10h] BYREF

  v2 = caml_local_roots;
  v3 = (a2 >> 1) + 1;
  v7 = a1;
  v6 = a2;
  v9[2] = 1LL;
  v9[1] = 2LL;
  v9[3] = (__int64)&v7;
  v9[0] = caml_local_roots;
  v9[4] = (__int64)&v6;
  v11 = 0LL;
  v8[0] = (__int64)v9;
  v10 = 0LL;
  v8[2] = 1LL;
  v8[1] = 2LL;
  caml_local_roots = (__int64)v8;
  v8[3] = (__int64)&v11;
  v8[4] = (__int64)&v10;
  if ( a2 >> 1 == -1 || v3 >= *(_QWORD *)(a1 - 8) >> 10 )
    caml_invalid_argument("Weak.get");
  v4 = *(_QWORD *)(a1 + 8 * v3);
  result = 1LL;
  if ( (void *)v4 != caml_weak_none )
  {
    v10 = v4;
    if ( !caml_gc_phase && (v4 & 1) == 0 && (caml_page_table_lookup(v4) & 1) != 0 )
      caml_darken(v10);
    v11 = caml_alloc_small(1LL, 0);
    *v11 = v10;
    result = (__int64)v11;
  }
  caml_local_roots = v2;
  return result;
}
// 658868: using guessed type void *caml_weak_none;
// 658A68: using guessed type __int64 caml_local_roots;
// 6633B0: using guessed type int caml_gc_phase;

//----- (000000000043A070) ----------------------------------------------------
__int64 __fastcall caml_weak_get_copy(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned __int64 v3; // rbp
  __int64 v4; // r12
  char *v6; // rax
  char *v7; // rbp
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // r15
  _QWORD *v10; // rax
  __int64 v11; // r14
  unsigned __int64 v12; // r13
  __int64 v13; // [rsp+10h] [rbp-D8h] BYREF
  __int64 v14; // [rsp+18h] [rbp-D0h] BYREF
  __int64 v15[8]; // [rsp+20h] [rbp-C8h] BYREF
  __int64 v16[8]; // [rsp+60h] [rbp-88h] BYREF
  __int64 v17; // [rsp+A0h] [rbp-48h] BYREF
  _QWORD *v18; // [rsp+A8h] [rbp-40h] BYREF

  v2 = caml_local_roots;
  v3 = (a2 >> 1) + 1;
  v14 = a1;
  v13 = a2;
  v16[3] = (__int64)&v14;
  v16[2] = 1LL;
  v16[0] = caml_local_roots;
  v16[1] = 2LL;
  v16[4] = (__int64)&v13;
  v18 = 0LL;
  v17 = 0LL;
  v15[2] = 1LL;
  v15[0] = (__int64)v16;
  v15[1] = 2LL;
  caml_local_roots = (__int64)v15;
  v15[3] = (__int64)&v18;
  v15[4] = (__int64)&v17;
  if ( a2 >> 1 == -1 || v3 >= *(_QWORD *)(a1 - 8) >> 10 )
    caml_invalid_argument("Weak.get");
  v4 = *(_QWORD *)(a1 + 8 * v3);
  if ( (void *)v4 != caml_weak_none )
  {
    if ( (v4 & 1) != 0 || (caml_page_table_lookup(*(_QWORD *)(a1 + 8 * v3)) & 3) == 0 )
    {
      v17 = v4;
LABEL_6:
      v18 = caml_alloc_small(1LL, 0);
      caml_local_roots = v2;
      *v18 = v17;
      return (__int64)v18;
    }
    v6 = caml_alloc(*(_QWORD *)(v4 - 8) >> 10, *(unsigned __int8 *)(v4 - 8));
    v17 = (__int64)v6;
    v7 = *(char **)(v14 + 8 * v3);
    if ( v7 != caml_weak_none )
    {
      if ( (unsigned __int8)*(v7 - 8) > 0xFAu )
      {
        memmove(v6, v7, 8LL * (*((_QWORD *)v7 - 1) >> 10));
      }
      else if ( *((_QWORD *)v7 - 1) >> 10 )
      {
        v8 = 0LL;
        do
        {
          v11 = 8 * v8;
          v12 = *(_QWORD *)&v7[8 * v8];
          if ( !caml_gc_phase && (v12 & 1) == 0 && (caml_page_table_lookup(*(_QWORD *)&v7[8 * v8]) & 1) != 0 )
            caml_darken(v12);
          v9 = *(_QWORD *)(v17 + 8 * v8);
          *(_QWORD *)(v17 + 8 * v8) = v12;
          if ( (caml_page_table_lookup(v17 + v11) & 1) != 0 )
          {
            if ( !caml_gc_phase )
              caml_darken(v9);
            if ( (v12 & 1) == 0
              && v12 < caml_young_end
              && v12 > caml_young_start
              && ((v9 & 1) != 0 || caml_young_end <= v9 || caml_young_start >= v9) )
            {
              v10 = (_QWORD *)qword_65CD18;
              if ( qword_65CD18 >= (unsigned __int64)qword_65CD20 )
              {
                caml_realloc_ref_table((__int64)&caml_ref_table);
                v10 = (_QWORD *)qword_65CD18;
              }
              *v10 = v17 + v11;
              qword_65CD18 = (__int64)(v10 + 1);
            }
          }
          ++v8;
        }
        while ( *((_QWORD *)v7 - 1) >> 10 > v8 );
      }
      goto LABEL_6;
    }
  }
  caml_local_roots = v2;
  return 1LL;
}
// 658868: using guessed type void *caml_weak_none;
// 658A68: using guessed type __int64 caml_local_roots;
// 65CCE0: using guessed type __int64 caml_young_start;
// 65CCE8: using guessed type __int64 caml_young_end;
// 65CD18: using guessed type __int64 qword_65CD18;
// 65CD20: using guessed type __int64 qword_65CD20;
// 6633B0: using guessed type int caml_gc_phase;

//----- (000000000043A3A0) ----------------------------------------------------
__int64 *__fastcall caml_weak_create(__int64 a1)
{
  unsigned __int64 v1; // rdi
  __int64 *result; // rax
  unsigned __int64 v3; // rdx

  v1 = a1 >> 1;
  if ( v1 > 0x3FFFFFFFFFFFFELL )
    caml_invalid_argument("Weak.create");
  result = caml_alloc_shr(v1 + 1, 0xFBu);
  if ( v1 )
  {
    v3 = 1LL;
    do
      result[v3++] = (__int64)caml_weak_none;
    while ( v1 + 1 > v3 );
  }
  *result = caml_weak_list_head;
  caml_weak_list_head = (__int64)result;
  return result;
}
// 658868: using guessed type void *caml_weak_none;
// 6627E8: using guessed type __int64 caml_weak_list_head;

//----- (000000000043A410) ----------------------------------------------------
void __fastcall invert_pointer_at(__int64 a1)
{
  unsigned __int64 v1; // rbx
  __int64 v2; // rbp
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rcx
  _QWORD *v5; // rdx
  unsigned __int64 i; // rax

  v1 = *(_QWORD *)a1;
  v2 = a1;
  if ( (*(_QWORD *)a1 & 3) == 0 && (caml_page_table_lookup(*(_QWORD *)a1) & 1) != 0 )
  {
    v3 = *(_QWORD *)(v1 - 8);
    if ( (v3 & 3) == 1 )
    {
      v4 = v1 - 8 * (v3 >> 10);
      v5 = (_QWORD *)(v4 - 8);
      for ( i = *(_QWORD *)(v4 - 8); (i & 3) == 0; i = *(_QWORD *)i )
        v5 = (_QWORD *)i;
      if ( (unsigned __int8)(i >> 2) != 0xF7 )
        i = (v4 + 8 * (i >> 10)) | 1;
      *(_QWORD *)a1 = i;
      *(_QWORD *)(v1 - 8) = a1 | 2;
      *v5 = ((((v1 - v4) >> 3) - 1) << 10) | 0x3E7;
    }
    else
    {
      *(_QWORD *)a1 = v3;
      if ( (v3 & 3) == 2 )
        v2 = a1 | 2;
      *(_QWORD *)(v1 - 8) = v2;
    }
  }
}

//----- (000000000043A500) ----------------------------------------------------
void __fastcall invert_root(__int64 a1, __int64 a2)
{
  invert_pointer_at(a2);
}

//----- (000000000043A510) ----------------------------------------------------
int caml_compact_heap()
{
  __int64 *v0; // rax
  char *v1; // rsi
  __int64 *i; // rdi
  unsigned __int64 v3; // rbx
  _QWORD **v4; // r13
  char *v5; // r14
  _QWORD **j; // r15
  unsigned __int64 k; // rax
  unsigned __int64 v8; // r12
  unsigned int v9; // eax
  unsigned __int64 v10; // r12
  _QWORD **v11; // rbp
  unsigned __int64 n; // rbx
  __int64 v13; // rdi
  _QWORD *v14; // r13
  __int64 *v15; // r14
  unsigned __int64 ii; // r12
  unsigned __int64 v17; // r12
  void **v18; // rbx
  unsigned __int64 jj; // rbp
  __int64 v20; // rdi
  _QWORD *v21; // rbp
  _QWORD *v22; // rax
  _QWORD *kk; // rcx
  unsigned __int64 *v24; // rdi
  unsigned __int64 *v25; // r10
  char *v26; // r9
  unsigned __int64 v27; // rdx
  _QWORD *v28; // rsi
  unsigned __int64 v29; // rax
  __int64 v30; // r13
  unsigned __int64 v31; // rax
  __int64 v32; // r11
  unsigned __int64 v33; // r8
  _QWORD *v34; // r14
  unsigned __int64 v35; // rbx
  _QWORD *v36; // r12
  _QWORD *v37; // rbx
  char *v38; // r12
  _QWORD *v39; // rbx
  _QWORD *v40; // rcx
  _QWORD *v41; // r11
  unsigned __int64 v42; // rdx
  __int64 v43; // rbx
  _QWORD *v44; // rdx
  unsigned __int64 m; // rax
  unsigned __int64 v46; // r12
  unsigned __int64 v47; // r13
  _QWORD *v48; // rax
  char *v49; // r12
  _QWORD *v50; // r13
  unsigned __int64 v51; // rax
  size_t v52; // rbx
  __int64 v53; // rax
  __int64 v54; // rdi
  __int64 v55; // rcx
  unsigned __int64 v56; // rdx
  __int64 v57; // rsi
  __int64 v58; // r8
  __int64 v59; // rdx
  __int64 v60; // rdx
  const void *v61; // rsi
  _QWORD *v62; // rdi
  _QWORD *v63; // rdx
  unsigned __int64 v64; // rbx
  unsigned __int64 v65; // rax
  unsigned __int64 v66; // rcx
  unsigned __int64 v67; // rbp
  _QWORD *v68; // r12
  _QWORD *v69; // rbp
  unsigned __int64 v70; // rsi
  unsigned __int64 v71; // rdi

  caml_gc_message(16, "Compacting heap...\n", 0LL);
  v0 = (__int64 *)caml_heap_start;
  if ( caml_heap_start )
  {
    do
    {
      v1 = (char *)v0 + *(v0 - 2);
      for ( i = v0 - 4; v1 > (char *)v0; v0 += v3 + 1 )
      {
        while ( 1 )
        {
          v3 = (unsigned __int64)*v0 >> 10;
          if ( (*v0 & 0x300) == 512 )
            break;
          *v0 = (4 * (unsigned __int16)*v0) & 0x3FC | (v3 << 10) | 3;
          v0 += v3 + 1;
          if ( v1 <= (char *)v0 )
            goto LABEL_7;
        }
        *v0 = (v3 << 10) | 0x3F3;
      }
LABEL_7:
      v0 = (__int64 *)i[3];
    }
    while ( v0 );
  }
  caml_do_roots((void (__fastcall *)(__int64, __int64 *))invert_root);
  caml_final_do_weak_roots((__int64 (__fastcall *)(_QWORD, __int64))invert_root);
  v4 = (_QWORD **)caml_heap_start;
  if ( caml_heap_start )
  {
    do
    {
      v5 = (char *)v4 + (_QWORD)*(v4 - 2);
      for ( j = v4 - 4; v5 > (char *)v4; v4 += v10 )
      {
        for ( k = (unsigned __int64)*v4; (k & 3) == 0; k = *(_QWORD *)k )
          ;
        v8 = k;
        v9 = (unsigned __int8)(k >> 2);
        v10 = (v8 >> 10) + 1;
        if ( v9 == 249 )
        {
          for ( m = (unsigned __int64)v4[v10]; (m & 3) != 3; m = *(_QWORD *)(m & 0xFFFFFFFFFFFFFFFCLL) )
            ;
          v46 = m >> 10;
          v9 = (unsigned __int8)(m >> 2);
          v10 = v46 + 1;
        }
        if ( v9 <= 0xFA && v10 > 1 )
        {
          v11 = v4 + 1;
          for ( n = 1LL; n < v10; ++n )
          {
            v13 = (__int64)v11++;
            invert_pointer_at(v13);
          }
        }
      }
      v4 = (_QWORD **)j[3];
    }
    while ( v4 );
  }
  v14 = (_QWORD *)caml_weak_list_head;
  if ( caml_weak_list_head )
  {
    v15 = &caml_weak_list_head;
    do
    {
      for ( ii = *(v14 - 1); (ii & 3) == 0; ii = *(_QWORD *)ii )
        ;
      v17 = ii >> 10;
      if ( v17 > 1 )
      {
        v18 = (void **)(v14 + 1);
        for ( jj = 1LL; jj < v17; ++jj )
        {
          if ( *v18 != caml_weak_none )
            invert_pointer_at((__int64)v18);
          ++v18;
        }
      }
      v20 = (__int64)v15;
      v15 = v14;
      invert_pointer_at(v20);
      v14 = (_QWORD *)*v14;
    }
    while ( v14 );
  }
  v21 = caml_heap_start;
  if ( !caml_heap_start )
  {
    compact_fl = 0LL;
    goto LABEL_103;
  }
  v22 = caml_heap_start;
  do
  {
    *(v22 - 3) = 0LL;
    v22 = (_QWORD *)*(v22 - 1);
  }
  while ( v22 );
  kk = v21;
  v24 = v21;
  do
  {
    v25 = v24 - 4;
    v26 = (char *)v24 + *(v24 - 2);
    while ( v26 > (char *)v24 )
    {
      v29 = *v24;
      if ( (*v24 & 3) != 0 )
      {
        v27 = v29 >> 2;
        if ( (unsigned __int8)(v29 >> 2) != 0xF9 )
        {
          v28 = kk;
          *v24 = (*v24 & 0xFFFFFFFFFFFFFC00LL) + (unsigned __int8)v27 + 512;
          v24 += (v29 >> 10) + 1;
          goto LABEL_36;
        }
      }
      else
      {
        do
          v29 = *(_QWORD *)v29;
        while ( (v29 & 3) == 0 );
        v27 = v29 >> 2;
      }
      LODWORD(v27) = (unsigned __int8)v27;
      v30 = (v29 >> 10) + 1;
      v31 = 0LL;
      if ( (unsigned __int8)v27 == 249 )
      {
        v31 = (unsigned __int64)&v24[v30];
        v27 = *(_QWORD *)v31;
        if ( (*(_QWORD *)v31 & 3LL) != 3 )
        {
          do
            v27 = *(_QWORD *)(v27 & 0xFFFFFFFFFFFFFFFCLL);
          while ( (v27 & 3) != 3 );
        }
        v47 = v27 >> 10;
        LODWORD(v27) = (unsigned __int8)(v27 >> 2);
        v30 = v47 + 1;
      }
      v32 = *(kk - 3);
      v33 = 8 * v30;
      v34 = kk - 4;
      v35 = *(kk - 2) - v32;
      if ( v35 <= 0x20 )
      {
        v28 = (_QWORD *)*(kk - 1);
        v36 = v28 - 4;
        if ( *(v28 - 2) - *(v28 - 3) <= 0x20uLL )
        {
          for ( kk = (_QWORD *)*(kk - 1); ; kk = v37 )
          {
            v37 = (_QWORD *)v36[3];
            v36 = v37 - 4;
            if ( *(v37 - 2) - *(v37 - 3) > 0x20uLL )
              break;
            v28 = v37;
          }
          goto LABEL_49;
        }
      }
      v28 = kk;
      while ( v33 > v35 )
      {
        kk = (_QWORD *)v34[3];
LABEL_49:
        v32 = *(kk - 3);
        v34 = kk - 4;
        v35 = *(kk - 2) - v32;
      }
      v38 = (char *)kk + v32;
      v34[1] = v33 + v32;
      v39 = (_QWORD *)*v24;
      if ( (*v24 & 3) == 0 )
      {
        do
        {
          v40 = (_QWORD *)*v39;
          *v39 = v38 + 8;
          v39 = v40;
        }
        while ( ((unsigned __int8)v40 & 3) == 0 );
      }
      *v24 = (v30 << 10) + (unsigned int)v27 - 1024;
      if ( v31 && (v31 & 3) != 3 )
      {
        do
        {
          v41 = (_QWORD *)(v31 & 0xFFFFFFFFFFFFFFFCLL);
          v31 = *(_QWORD *)(v31 & 0xFFFFFFFFFFFFFFFCLL);
          v42 = v31 & 3;
          if ( v42 == 2 )
          {
            v43 = v41 - v24;
            do
            {
              v44 = (_QWORD *)(v31 & 0xFFFFFFFFFFFFFFFCLL);
              v31 = *(_QWORD *)(v31 & 0xFFFFFFFFFFFFFFFCLL);
              *v44 = &v38[8 * v43 + 8];
              v42 = v31 & 3;
            }
            while ( v42 == 2 );
          }
          else
          {
            v43 = v41 - v24;
          }
          *v41 = (v43 << 10) + 249;
        }
        while ( v42 != 3 );
      }
      v24 = (unsigned __int64 *)((char *)v24 + v33);
LABEL_36:
      kk = v28;
    }
    v24 = (unsigned __int64 *)v25[3];
  }
  while ( v24 );
  v48 = v21;
  do
  {
    *(v48 - 3) = 0LL;
    v48 = (_QWORD *)*(v48 - 1);
  }
  while ( v48 );
  compact_fl = (__int64)v21;
  while ( 2 )
  {
    v49 = (char *)v21 + *(v21 - 2);
    v50 = v21 - 4;
LABEL_73:
    while ( v49 > (char *)v21 )
    {
      v51 = *v21;
      if ( (*v21 & 0x300LL) != 0 )
      {
        v21 += (v51 >> 10) + 1;
        goto LABEL_73;
      }
      v52 = 8 * (v51 >> 10) + 8;
      v53 = compact_fl;
      v54 = *(_QWORD *)(compact_fl - 24);
      v55 = compact_fl - 32;
      v56 = *(_QWORD *)(compact_fl - 16) - v54;
      if ( v56 <= 0x20 )
      {
        v57 = *(_QWORD *)(compact_fl - 8);
        v58 = v57 - 32;
        if ( *(_QWORD *)(v57 - 16) - *(_QWORD *)(v57 - 24) <= 0x20uLL )
        {
          while ( 1 )
          {
            v59 = *(_QWORD *)(v58 + 24);
            v53 = v57;
            v58 = v59 - 32;
            if ( *(_QWORD *)(v59 - 16) - *(_QWORD *)(v59 - 24) > 0x20uLL )
              break;
            v57 = v59;
          }
          v54 = *(_QWORD *)(v57 - 24);
          v60 = *(_QWORD *)(v57 - 16);
          v55 = v57 - 32;
          compact_fl = v57;
          if ( v52 <= v60 - v54 )
            goto LABEL_83;
LABEL_81:
          v53 = *(_QWORD *)(v55 + 24);
          v54 = *(_QWORD *)(v53 - 24);
          v55 = v53 - 32;
          v56 = *(_QWORD *)(v53 - 16) - v54;
        }
      }
      if ( v52 > v56 )
        goto LABEL_81;
LABEL_83:
      v61 = v21;
      v21 = (_QWORD *)((char *)v21 + v52);
      *(_QWORD *)(v55 + 8) = v54 + v52;
      memmove((void *)(v53 + v54), v61, v52);
    }
    v21 = (_QWORD *)v50[3];
    if ( v21 )
      continue;
    break;
  }
  v62 = caml_heap_start;
  if ( !caml_heap_start )
  {
LABEL_103:
    caml_fl_reset();
    goto LABEL_104;
  }
  v63 = caml_heap_start;
  v64 = 0LL;
  v65 = 0LL;
  do
  {
    v66 = *(v63 - 3);
    if ( v66 )
    {
      v65 += v66 >> 3;
      v64 += (*(v63 - 2) - v66) >> 3;
    }
    v63 = (_QWORD *)*(v63 - 1);
  }
  while ( v63 );
  v67 = caml_percent_free * (v65 / 0x64 + 1);
  do
  {
    v68 = (_QWORD *)*(v62 - 1);
    if ( !*(v62 - 3) )
    {
      if ( v64 < v67 )
        v64 += *(v62 - 2) >> 3;
      else
        caml_shrink_heap(v62);
    }
    v62 = v68;
  }
  while ( v68 );
  v69 = caml_heap_start;
  caml_fl_reset();
  for ( ; v69; v69 = (_QWORD *)*(v69 - 1) )
  {
    v70 = *(v69 - 2);
    v71 = *(v69 - 3);
    if ( v70 > v71 )
      caml_make_free_blocks((__int64 **)((char *)v69 + v71), (v70 - v71) >> 3, 1);
  }
LABEL_104:
  ++caml_stat_compactions;
  return caml_gc_message(16, "done.\n", 0LL);
}
// 658868: using guessed type void *caml_weak_none;
// 662770: using guessed type __int64 caml_stat_compactions;
// 6627E8: using guessed type __int64 caml_weak_list_head;
// 6627F8: using guessed type __int64 compact_fl;
// 663398: using guessed type __int64 caml_percent_free;

//----- (000000000043AB90) ----------------------------------------------------
int __fastcall caml_compact_heap_maybe(__m128d a1, double a2, __m128 a3)
{
  double v3; // xmm0_8
  double v4; // xmm1_8
  __m128 v5; // xmm0
  float v6; // xmm2_4
  __m128 v7; // xmm0
  __m128d v8; // xmm1
  float v9; // xmm0_4
  __int64 v10; // rbx
  int result; // eax
  float v12; // xmm1_4
  __m128 v13; // xmm2
  __m128d v14; // xmm0
  float v15; // xmm0_4
  __int64 v16; // rdx

  if ( (unsigned __int64)caml_percent_max <= 0xF423F && caml_stat_major_collections > 2 && caml_stat_heap_chunks > 2 )
  {
    if ( caml_fl_cur_size < 0 )
      v3 = (double)(int)(caml_fl_cur_size & 1 | ((unsigned __int64)caml_fl_cur_size >> 1))
         + (double)(int)(caml_fl_cur_size & 1 | ((unsigned __int64)caml_fl_cur_size >> 1));
    else
      v3 = (double)(int)caml_fl_cur_size;
    v4 = 3.0 * v3;
    if ( caml_fl_size_at_phase_change < 0 )
      a1.m128d_f64[0] = (double)(int)(caml_fl_size_at_phase_change & 1 | ((unsigned __int64)caml_fl_size_at_phase_change >> 1))
                      + (double)(int)(caml_fl_size_at_phase_change & 1 | ((unsigned __int64)caml_fl_size_at_phase_change >> 1));
    else
      a1.m128d_f64[0] = (double)(int)caml_fl_size_at_phase_change;
    a1.m128d_f64[0] = a1.m128d_f64[0] * -2.0 + v4;
    v5 = _mm_cvtpd_ps(_mm_unpacklo_pd(a1, a1));
    if ( v5.m128_f32[0] < 0.0 )
    {
      if ( caml_fl_cur_size < 0 )
        v5.m128_f32[0] = (float)(caml_fl_cur_size & 1 | (unsigned int)((unsigned __int64)caml_fl_cur_size >> 1))
                       + (float)(caml_fl_cur_size & 1 | (unsigned int)((unsigned __int64)caml_fl_cur_size >> 1));
      else
        v5.m128_f32[0] = (float)(int)caml_fl_cur_size;
    }
    v6 = (float)(int)((unsigned __int64)caml_stat_heap_size >> 3);
    if ( v5.m128_f32[0] >= v6
      || (v7 = _mm_unpacklo_ps(v5, v5),
          v8 = _mm_cvtps_pd(v7),
          *(double *)a3.m128_u64 = (float)(v6 - v7.m128_f32[0]),
          a3.m128_u64[1] = a3.m128_u64[0],
          v8.m128d_f64[0] = v8.m128d_f64[0] * 100.0 / *(double *)a3.m128_u64,
          v9 = _mm_unpacklo_pd(v8, v8).m128d_f64[0],
          v9 > 1000000.0) )
    {
      v10 = 1000000LL;
      v9 = 1000000.0;
    }
    else if ( v9 < 9.223372e18 )
    {
      v10 = (unsigned int)(int)v9;
    }
    else
    {
      v10 = (unsigned int)(int)(float)(v9 - 9.223372e18) ^ 0x8000000000000000LL;
    }
    caml_gc_message(512, "FL size at phase change = %lu\n", caml_fl_size_at_phase_change);
    caml_gc_message(512, "Estimated overhead = %lu%%\n", v10);
    result = caml_percent_max;
    if ( caml_percent_max < 0 )
    {
      result = caml_percent_max & 1;
      v12 = (float)(int)(result | ((unsigned __int64)caml_percent_max >> 1))
          + (float)(int)(result | ((unsigned __int64)caml_percent_max >> 1));
    }
    else
    {
      v12 = (float)(int)caml_percent_max;
    }
    if ( v9 >= v12 )
    {
      caml_gc_message(512, "Automatic compaction triggered.\n", 0LL);
      caml_finish_major_cycle();
      if ( caml_fl_cur_size < 0 )
        a3.m128_f32[0] = (float)(caml_fl_cur_size & 1 | (unsigned int)((unsigned __int64)caml_fl_cur_size >> 1))
                       + (float)(caml_fl_cur_size & 1 | (unsigned int)((unsigned __int64)caml_fl_cur_size >> 1));
      else
        a3.m128_f32[0] = (float)(int)caml_fl_cur_size;
      v13 = _mm_unpacklo_ps(a3, a3);
      v14 = _mm_cvtps_pd(v13);
      v14.m128d_f64[0] = v14.m128d_f64[0]
                       * 100.0
                       / (float)((float)(int)((unsigned __int64)caml_stat_heap_size >> 3) - v13.m128_f32[0]);
      v15 = _mm_unpacklo_pd(v14, v14).m128d_f64[0];
      if ( v15 >= 9.223372e18 )
        v16 = (unsigned int)(int)(float)(v15 - 9.223372e18) ^ 0x8000000000000000LL;
      else
        v16 = (unsigned int)(int)v15;
      caml_gc_message(512, "Measured overhead: %lu%%\n", v16);
      return caml_compact_heap();
    }
  }
  return result;
}
// 65AD00: using guessed type __int64 caml_fl_cur_size;
// 65CC88: using guessed type __int64 caml_fl_size_at_phase_change;
// 662758: using guessed type __int64 caml_stat_major_collections;
// 662760: using guessed type __int64 caml_stat_heap_size;
// 662778: using guessed type __int64 caml_stat_heap_chunks;
// 6633F0: using guessed type __int64 caml_percent_max;

//----- (000000000043AE50) ----------------------------------------------------
unsigned __int64 __fastcall caml_final_do_strong_roots(__int64 (__fastcall *a1)(void *, void **))
{
  __int64 v2; // rbp
  unsigned __int64 v3; // rbx
  void **v4; // rax
  unsigned __int64 result; // rax
  void **v6; // r13
  unsigned __int64 v7; // rbx
  void **v8; // rbp
  __int64 v9; // rax
  void **v10; // r12
  void *v11; // rdi

  if ( old )
  {
    v2 = 0LL;
    v3 = 0LL;
    do
    {
      v4 = (void **)(final_table + v2);
      ++v3;
      v2 += 24LL;
      result = a1(*v4, v4);
    }
    while ( old > v3 );
  }
  v6 = (void **)to_do_hd;
  if ( to_do_hd )
  {
    do
    {
      result = *((unsigned int *)v6 + 2);
      v7 = 0LL;
      v8 = v6;
      if ( (_DWORD)result )
      {
        do
        {
          v9 = 3 * v7++;
          v10 = &v6[v9 + 2];
          a1(v8[2], v10);
          v11 = v8[3];
          v8 += 3;
          a1(v11, v10 + 1);
          result = *((int *)v6 + 2);
        }
        while ( result > v7 );
      }
      v6 = (void **)*v6;
    }
    while ( v6 );
  }
  return result;
}
// 662818: using guessed type __int64 final_table;
// 662820: using guessed type __int64 old;

//----- (000000000043AF00) ----------------------------------------------------
__int64 __fastcall caml_final_do_weak_roots(__int64 (__fastcall *a1)(_QWORD, __int64))
{
  __int64 v1; // rbp
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  __int64 result; // rax

  if ( old )
  {
    v1 = 0LL;
    v2 = 0LL;
    do
    {
      v3 = final_table + v1;
      ++v2;
      v1 += 24LL;
      result = a1(*(_QWORD *)(v3 + 8), v3 + 8);
    }
    while ( old > v2 );
  }
  return result;
}
// 662818: using guessed type __int64 final_table;
// 662820: using guessed type __int64 old;

//----- (000000000043AF50) ----------------------------------------------------
__int64 __fastcall caml_final_do_young_roots(void (__fastcall *a1)(_QWORD, __int64))
{
  unsigned __int64 v1; // rbp
  __int64 v2; // rbx
  __int64 v3; // rax
  __int64 result; // rax

  v1 = old;
  if ( old < (unsigned __int64)young )
  {
    v2 = 24 * old;
    do
    {
      ++v1;
      a1(*(_QWORD *)(final_table + v2), final_table + v2);
      v3 = final_table + v2;
      v2 += 24LL;
      result = ((__int64 (__fastcall *)(_QWORD, __int64))a1)(*(_QWORD *)(v3 + 8), v3 + 8);
    }
    while ( young > v1 );
  }
  return result;
}
// 662808: using guessed type __int64 young;
// 662818: using guessed type __int64 final_table;
// 662820: using guessed type __int64 old;

//----- (000000000043AFB0) ----------------------------------------------------
__int64 caml_final_empty_young()
{
  __int64 result; // rax

  result = young;
  old = young;
  return result;
}
// 662808: using guessed type __int64 young;
// 662820: using guessed type __int64 old;

//----- (000000000043AFC0) ----------------------------------------------------
__int64 caml_final_release()
{
  running_finalisation_function = 0;
  return 1LL;
}
// 43AFC0: using guessed type __int64 __fastcall caml_final_release();
// 662800: using guessed type int running_finalisation_function;

//----- (000000000043AFD0) ----------------------------------------------------
__int64 __fastcall caml_final_register(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v4; // rdx
  char *v5; // rax
  char *v6; // rax
  __int64 result; // rax
  size_t v8; // rdi
  __int64 v9; // r12
  __int64 v10; // rcx

  v2 = a2;
  if ( (a2 & 1) != 0 || (caml_page_table_lookup(a2) & 3) == 0 )
    caml_invalid_argument("Gc.finalise");
  v4 = young;
  if ( young >= (unsigned __int64)size )
  {
    v8 = final_table;
    if ( final_table )
    {
      v9 = 2 * size;
      v5 = (char *)caml_stat_resize((void *)final_table, 48 * size);
      size = v9;
    }
    else
    {
      LOWORD(v8) = 720;
      v5 = (char *)caml_stat_alloc(v8);
      size = 30LL;
    }
    final_table = (__int64)v5;
    v4 = young;
  }
  else
  {
    v5 = (char *)final_table;
  }
  v6 = &v5[24 * v4];
  *(_QWORD *)v6 = a1;
  if ( *(_BYTE *)(a2 - 8) == 0xF9 )
  {
    v10 = 8LL * (*(_QWORD *)(a2 - 8) >> 10);
    v2 = a2 - v10;
    *((_DWORD *)v6 + 4) = v10;
  }
  else
  {
    *((_DWORD *)v6 + 4) = 0;
  }
  *((_QWORD *)v6 + 1) = v2;
  result = 1LL;
  young = v4 + 1;
  return result;
}
// 662808: using guessed type __int64 young;
// 662810: using guessed type __int64 size;
// 662818: using guessed type __int64 final_table;

//----- (000000000043B100) ----------------------------------------------------
void caml_final_do_calls()
{
  _DWORD *i; // rdi
  _DWORD *v1; // rbx
  int v2; // eax

  if ( !running_finalisation_function && to_do_hd )
  {
    caml_gc_message(128, "Calling finalisation functions.\n", 0LL);
    for ( i = to_do_hd; i; i = v1 )
    {
      v2 = i[2];
      if ( v2 )
      {
        i[2] = v2 - 1;
        running_finalisation_function = 1;
        caml_callback();
        v1 = to_do_hd;
        running_finalisation_function = 0;
      }
      else
      {
        v1 = *(_DWORD **)i;
        free(i);
        to_do_hd = v1;
        if ( !v1 )
          to_do_tl = 0LL;
      }
    }
    caml_gc_message(128, "Done calling finalisation functions.\n", 0LL);
  }
}
// 662800: using guessed type int running_finalisation_function;
// 662830: using guessed type __int64 to_do_tl;

//----- (000000000043B1D0) ----------------------------------------------------
void caml_final_update()
{
  __int64 v0; // rcx
  __int64 v1; // rbx
  unsigned __int64 v2; // rdx
  _DWORD *v3; // rax
  _QWORD *v4; // rdx
  __int64 v5; // r12
  unsigned __int64 v6; // rbx
  __int64 v7; // r14
  unsigned __int64 v8; // r13
  __int64 v9; // rcx
  _QWORD *v10; // rdx
  unsigned __int64 *v11; // rax
  unsigned __int64 v12; // rbp
  __int64 v13; // rax
  _QWORD *v14; // rax
  __int64 v15; // rax
  unsigned __int64 v16; // rbp
  __int64 v17; // rdx
  char v18; // al
  __int64 v19; // rsi
  __int64 v20; // rax

  if ( !old )
    return;
  v0 = final_table;
  v1 = 0LL;
  v2 = 0LL;
  do
  {
    v1 += (*(_QWORD *)(*(_QWORD *)(v0 + 8) - 8LL) & 0x300LL) == 0;
    ++v2;
    v0 += 24LL;
  }
  while ( v2 < old );
  if ( !v1 )
    return;
  v3 = malloc(24LL * (int)v1 + 40);
  if ( !v3 )
    caml_fatal_error("out of memory");
  v4 = (_QWORD *)to_do_tl;
  *(_QWORD *)v3 = 0LL;
  v3[2] = v1;
  if ( v4 )
    *v4 = v3;
  else
    to_do_hd = v3;
  to_do_tl = (__int64)v3;
  if ( !old )
  {
    old = 0LL;
    young = 0LL;
    *(_DWORD *)(to_do_tl + 8) = 0;
    return;
  }
  v5 = 0LL;
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
  do
  {
    while ( 1 )
    {
      v9 = final_table;
      v10 = (_QWORD *)(final_table + v5);
      v11 = *(unsigned __int64 **)(final_table + v5 + 8);
      if ( (*(v11 - 1) & 0x300) != 0 )
        break;
      if ( *((_BYTE *)v11 - 8) != 0xFA )
        goto LABEL_15;
      v12 = *v11;
      if ( (*v11 & 1) != 0 )
      {
        v10[1] = v12;
LABEL_15:
        v13 = 3 * v6++;
        v14 = (_QWORD *)(to_do_tl + 8 * v13);
        v14[2] = *v10;
        v14[3] = v10[1];
        v14[4] = v10[2];
        goto LABEL_16;
      }
      if ( (caml_page_table_lookup(*v11) & 7) != 0 )
      {
        v18 = *(_BYTE *)(v12 - 8);
        if ( v18 != -6 && v18 != -10 && v18 != -3 )
        {
          *(_QWORD *)(final_table + v5 + 8) = v12;
          if ( (caml_page_table_lookup(v12) & 1) != 0 )
            continue;
        }
      }
      v10 = (_QWORD *)(final_table + v5);
      goto LABEL_15;
    }
    v19 = 3 * v7++;
    v20 = 8 * v19;
    *(_QWORD *)(final_table + 8 * v19) = *v10;
    *(_QWORD *)(v20 + v9 + 8) = v10[1];
    *(_QWORD *)(v20 + v9 + 16) = v10[2];
LABEL_16:
    ++v8;
    v5 += 24LL;
  }
  while ( old > v8 );
  v15 = to_do_tl;
  old = v7;
  young = v7;
  *(_DWORD *)(to_do_tl + 8) = v6;
  if ( v6 )
  {
    v16 = 0LL;
    while ( 1 )
    {
      v17 = 3 * v16++;
      caml_darken(*(_QWORD *)(v15 + 8 * v17 + 24));
      if ( v6 <= v16 )
        break;
      v15 = to_do_tl;
    }
  }
}
// 662808: using guessed type __int64 young;
// 662818: using guessed type __int64 final_table;
// 662820: using guessed type __int64 old;
// 662830: using guessed type __int64 to_do_tl;

//----- (000000000043B420) ----------------------------------------------------
_QWORD *__fastcall caml_final_custom_operations(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v3; // rax
  _QWORD *v4; // rbx
  _QWORD *v5; // rax
  __int64 v6; // rdx

  v1 = (_QWORD *)custom_ops_final_table;
  if ( custom_ops_final_table )
  {
    while ( *(_QWORD *)(*v1 + 8LL) != a1 )
    {
      v1 = (_QWORD *)v1[1];
      if ( !v1 )
        goto LABEL_6;
    }
    return (_QWORD *)*v1;
  }
  else
  {
LABEL_6:
    v3 = caml_stat_alloc(0x30uLL);
    v3[1] = a1;
    *v3 = "_final";
    v3[2] = 0LL;
    v3[3] = 0LL;
    v4 = v3;
    v3[4] = 0LL;
    v3[5] = 0LL;
    v5 = caml_stat_alloc(0x10uLL);
    v6 = custom_ops_final_table;
    *v5 = v4;
    v5[1] = v6;
    custom_ops_final_table = (__int64)v5;
    return v4;
  }
}
// 662838: using guessed type __int64 custom_ops_final_table;

//----- (000000000043B4D0) ----------------------------------------------------
_QWORD *__fastcall caml_register_custom_operations(__int64 a1)
{
  _QWORD *result; // rax
  __int64 v2; // rdx

  result = caml_stat_alloc(0x10uLL);
  v2 = custom_ops_table;
  *result = a1;
  result[1] = v2;
  custom_ops_table = (__int64)result;
  return result;
}
// 662840: using guessed type __int64 custom_ops_table;

//----- (000000000043B500) ----------------------------------------------------
_QWORD *caml_init_custom_operations()
{
  caml_register_custom_operations((__int64)&caml_int32_ops);
  caml_register_custom_operations((__int64)&caml_nativeint_ops);
  return caml_register_custom_operations((__int64)&caml_int64_ops);
}
// 658740: using guessed type char *caml_int32_ops;
// 658780: using guessed type char *caml_int64_ops;
// 6587C0: using guessed type char *caml_nativeint_ops;

//----- (000000000043B530) ----------------------------------------------------
const char **__fastcall caml_find_custom_operations(char *s2)
{
  __int64 v1; // rbx
  const char **v2; // rbp

  v1 = custom_ops_table;
  if ( !custom_ops_table )
    return 0LL;
  while ( 1 )
  {
    v2 = *(const char ***)v1;
    if ( !strcmp(**(const char ***)v1, s2) )
      break;
    v1 = *(_QWORD *)(v1 + 8);
    if ( !v1 )
      return 0LL;
  }
  return v2;
}
// 662840: using guessed type __int64 custom_ops_table;

//----- (000000000043B580) ----------------------------------------------------
_QWORD *__fastcall caml_alloc_custom(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v5; // rdi
  _QWORD *result; // rax
  __int64 *v9; // r13

  v5 = ((unsigned __int64)(a2 + 7) >> 3) + 1;
  if ( v5 > 0x100 || *(_QWORD *)(a1 + 8) )
  {
    v9 = caml_alloc_shr(v5, 0xFFu);
    *v9 = a1;
    caml_adjust_gc_speed(a3, a4);
    return (_QWORD *)caml_check_urgent_gc((__int64)v9);
  }
  else
  {
    result = caml_alloc_small(v5, 0xFFu);
    *result = a1;
  }
  return result;
}

//----- (000000000043B630) ----------------------------------------------------
int __fastcall caml_executable_name(char *filename, int a2)
{
  int v2; // eax
  int result; // eax
  struct stat64 v4; // [rsp+0h] [rbp-A8h] BYREF

  v2 = readlink("/proc/self/exe", filename, a2);
  if ( v2 >= a2 )
    return -1;
  if ( v2 == -1 )
    return -1;
  filename[v2] = 0;
  result = __xstat64(1, filename, &v4);
  if ( result || (v4.st_mode & 0xF000) != 0x8000 )
    return -1;
  return result;
}

//----- (000000000043B6B0) ----------------------------------------------------
__int64 __fastcall caml_read_directory(const char *a1, void **a2)
{
  DIR *v2; // rbx
  __int64 result; // rax
  struct dirent64 *v4; // rax
  char *d_name; // r13
  int v6; // eax
  size_t v7; // rax
  char *v8; // rbp

  v2 = opendir(a1);
  result = 0xFFFFFFFFLL;
  if ( v2 )
  {
    while ( 1 )
    {
      v4 = readdir64(v2);
      if ( !v4 )
        break;
      while ( 1 )
      {
        d_name = v4->d_name;
        v6 = (unsigned __int8)v4->d_name[0];
        if ( v6 == 46 && !d_name[1] )
          break;
        if ( v6 == 46 && d_name[1] == 46 && !d_name[2] )
          break;
        v7 = strlen(d_name);
        v8 = (char *)caml_stat_alloc(v7 + 1);
        strcpy(v8, d_name);
        caml_ext_table_add(a2, (__int64)v8);
        v4 = readdir64(v2);
        if ( !v4 )
          goto LABEL_7;
      }
    }
LABEL_7:
    closedir(v2);
    return 0LL;
  }
  return result;
}

//----- (000000000043B790) ----------------------------------------------------
char *__fastcall caml_decompose_path(void **a1, const char *a2)
{
  char *v2; // r12
  size_t v3; // rax
  char *v4; // rsi
  char *v5; // rbx
  char *v6; // rax
  char v7; // dl

  v2 = 0LL;
  if ( a2 )
  {
    v3 = strlen(a2);
    v2 = (char *)caml_stat_alloc(v3 + 1);
    strcpy(v2, a2);
    v4 = v2;
    while ( 1 )
    {
      if ( *v4 == 58 || !*v4 )
      {
        v5 = v4;
      }
      else
      {
        v6 = v4 + 1;
        while ( 1 )
        {
          v7 = *v6;
          v5 = v6++;
          if ( v7 == 58 )
            break;
          if ( !v7 )
          {
            caml_ext_table_add(a1, (__int64)v4);
            if ( *v5 )
              goto LABEL_5;
            return v2;
          }
        }
      }
      caml_ext_table_add(a1, (__int64)v4);
      if ( !*v5 )
        break;
LABEL_5:
      v4 = v5 + 1;
      *v5 = 0;
    }
  }
  return v2;
}

//----- (000000000043B840) ----------------------------------------------------
void *__fastcall caml_globalsym(char *name)
{
  return caml_dlsym(0LL, name);
}

//----- (000000000043B860) ----------------------------------------------------
void *__fastcall caml_dlopen(const char *a1, __int64 a2, int a3)
{
  int v3; // esi

  v3 = -(a3 == 0);
  LOBYTE(v3) = 0;
  return dlopen(a1, v3 + 4354);
}

//----- (000000000043B880) ----------------------------------------------------
char *__fastcall caml_search_in_path(__int64 a1, const char *a2)
{
  const char *v2; // rax
  __int64 v3; // rbp
  int v4; // er13
  size_t v5; // rbx
  size_t v6; // rax
  char *v7; // rbx
  size_t v8; // rax
  struct stat64 v10; // [rsp+0h] [rbp-C8h] BYREF

  if ( *a2 )
  {
    v2 = a2;
    if ( *a2 == 47 )
      goto LABEL_13;
    while ( *++v2 )
    {
      if ( *v2 == 47 )
        goto LABEL_13;
    }
  }
  if ( *(int *)a1 <= 0 )
  {
LABEL_13:
    v8 = strlen(a2);
    v7 = (char *)caml_stat_alloc(v8 + 1);
    strcpy(v7, a2);
    return v7;
  }
  v3 = 0LL;
  v4 = 0;
  while ( 1 )
  {
    v5 = strlen(*(const char **)(*(_QWORD *)(a1 + 8) + v3));
    v6 = strlen(a2);
    v7 = (char *)caml_stat_alloc(v5 + v6 + 2);
    strcpy(v7, *(const char **)(*(_QWORD *)(a1 + 8) + v3));
    if ( *v7 )
      *(_WORD *)&v7[strlen(v7)] = 47;
    strcat(v7, a2);
    if ( !__xstat64(1, v7, &v10) && (v10.st_mode & 0xF000) == 0x8000 )
      return v7;
    ++v4;
    v3 += 8LL;
    caml_stat_free(v7);
    if ( *(_DWORD *)a1 <= v4 )
      goto LABEL_13;
  }
}

//----- (000000000043B9C0) ----------------------------------------------------
char *__fastcall caml_search_dll_in_path(__int64 a1, const char *a2)
{
  size_t v2; // rax
  char *v3; // rbx
  char *v4; // rbp

  v2 = strlen(a2);
  v3 = (char *)caml_stat_alloc(v2 + 4);
  strcpy(v3, a2);
  *(_DWORD *)&v3[strlen(v3)] = 7303982;
  v4 = caml_search_in_path(a1, v3);
  caml_stat_free(v3);
  return v4;
}

//----- (000000000043BA40) ----------------------------------------------------
char *__fastcall caml_search_exe_in_path(const char *a1)
{
  char *v1; // rax
  char *v2; // rbp
  char *v3; // r12
  void *v5[2]; // [rsp+0h] [rbp-28h] BYREF

  caml_ext_table_init((__int64)v5, 8);
  v1 = getenv("PATH");
  v2 = caml_decompose_path(v5, v1);
  v3 = caml_search_in_path((__int64)v5, a1);
  caml_stat_free(v2);
  caml_ext_table_free((__int64)v5, 0);
  return v3;
}

//----- (000000000043BAC0) ----------------------------------------------------
unsigned __int64 caml_backtrace_status()
{
  return (-(__int64)(caml_backtrace_active == 0) & 0xFFFFFFFFFFFFFFFELL) + 3;
}
// 662848: using guessed type int caml_backtrace_active;

//----- (000000000043BAE0) ----------------------------------------------------
_QWORD *caml_get_exception_backtrace()
{
  __int64 v0; // r14
  __int64 v1; // rbx
  int v2; // ebp
  unsigned int *v3; // rax
  unsigned int v4; // er12
  unsigned int v5; // er13
  unsigned __int64 *v6; // rdi
  __int64 v7; // rax
  __int64 v9[8]; // [rsp+0h] [rbp-88h] BYREF
  _QWORD *v10; // [rsp+40h] [rbp-48h] BYREF
  _QWORD *v11; // [rsp+48h] [rbp-40h] BYREF
  char *v12; // [rsp+50h] [rbp-38h] BYREF
  _QWORD *v13; // [rsp+58h] [rbp-30h] BYREF

  v0 = caml_local_roots;
  v13 = 0LL;
  v12 = 0LL;
  v11 = 0LL;
  v10 = 0LL;
  v9[3] = (__int64)&v13;
  v9[0] = caml_local_roots;
  caml_local_roots = (__int64)v9;
  v9[2] = 1LL;
  v9[4] = (__int64)&v12;
  v9[1] = 4LL;
  v9[5] = (__int64)&v11;
  v9[6] = (__int64)&v10;
  v12 = caml_alloc(caml_backtrace_pos, 0);
  if ( caml_backtrace_pos > 0 )
  {
    v1 = 0LL;
    v2 = 0;
    do
    {
      v7 = *(_QWORD *)(caml_backtrace_buffer + v1);
      if ( (*(_BYTE *)(v7 + 8) & 1) != 0 )
      {
        v3 = (unsigned int *)((v7 + 2LL * *(unsigned __int16 *)(v7 + 10) + 19) & 0xFFFFFFFFFFFFFFF8LL);
        v4 = *v3;
        v5 = v3[1];
        v10 = caml_copy_string((char *)v3 + (*v3 & 0x3FFFFFC));
        v11 = caml_alloc_small(5LL, 0);
        *v11 = (-(__int64)((v4 & 3) == 0) & 0xFFFFFFFFFFFFFFFELL) + 3;
        v11[1] = v10;
        v11[2] = 2LL * (v5 >> 12) + 1;
        v11[3] = 2LL * (unsigned __int8)(v5 >> 4) + 1;
        v11[4] = 2LL * ((v4 >> 26) | ((v5 & 0xF) << 6)) + 1;
      }
      else
      {
        v11 = caml_alloc_small(1LL, 1u);
        *v11 = 3LL;
      }
      v6 = (unsigned __int64 *)&v12[v1];
      ++v2;
      v1 += 8LL;
      caml_modify(v6, (unsigned __int64)v11);
    }
    while ( caml_backtrace_pos > v2 );
  }
  v13 = caml_alloc_small(1LL, 0);
  caml_local_roots = v0;
  *v13 = v12;
  return v13;
}
// 658A68: using guessed type __int64 caml_local_roots;
// 66284C: using guessed type int caml_backtrace_pos;
// 662850: using guessed type __int64 caml_backtrace_buffer;

//----- (000000000043BCD0) ----------------------------------------------------
void caml_print_exception_backtrace()
{
  __int64 v0; // rbp
  int v1; // ebx
  __int64 v2; // rax
  const char *v3; // rcx
  const char *v4; // rax
  unsigned int v5; // edi
  unsigned int v6; // er9
  __int64 v7; // [rsp+0h] [rbp-38h]
  __int64 v8; // [rsp+8h] [rbp-30h]

  if ( caml_backtrace_pos > 0 )
  {
    v0 = 0LL;
    v1 = 0;
    do
    {
      v2 = *(_QWORD *)(caml_backtrace_buffer + v0);
      if ( (*(_BYTE *)(v2 + 8) & 1) != 0 )
      {
        v3 = "Raised at";
        v4 = (const char *)((v2 + 2LL * *(unsigned __int16 *)(v2 + 10) + 19) & 0xFFFFFFFFFFFFFFF8LL);
        v5 = *(_DWORD *)v4;
        v6 = *((_DWORD *)v4 + 1);
        if ( v1 )
        {
          v3 = "Called from";
          if ( (v5 & 3) != 0 )
            v3 = "Re-raised at";
        }
        LODWORD(v8) = (v5 >> 26) | ((*((_DWORD *)v4 + 1) & 0xF) << 6);
        LODWORD(v7) = (unsigned __int8)(v6 >> 4);
        __fprintf_chk(
          stderr,
          1LL,
          "%s file \"%s\", line %d, characters %d-%d\n",
          v3,
          &v4[v5 & 0x3FFFFFC],
          v6 >> 12,
          v7,
          v8);
      }
      ++v1;
      v0 += 8LL;
    }
    while ( caml_backtrace_pos > v1 );
  }
}
// 43BD7D: variable 'v7' is possibly undefined
// 43BD7D: variable 'v8' is possibly undefined
// 40A438: using guessed type __int64 __fprintf_chk(_QWORD, _QWORD, const char *, ...);
// 66284C: using guessed type int caml_backtrace_pos;
// 662850: using guessed type __int64 caml_backtrace_buffer;

//----- (000000000043BDA0) ----------------------------------------------------
unsigned __int64 __fastcall caml_stash_backtrace(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4)
{
  _QWORD *v4; // r8
  __int64 v5; // r9
  __int64 v6; // r11
  int v7; // er10
  unsigned __int64 result; // rax
  __int64 v9; // rdi
  __int64 v10; // rax
  unsigned __int64 v11; // [rsp+8h] [rbp-20h]
  unsigned __int64 v12; // [rsp+8h] [rbp-20h]
  unsigned __int64 v13; // [rsp+10h] [rbp-18h]
  unsigned __int64 v14; // [rsp+10h] [rbp-18h]

  if ( a1 != caml_backtrace_last_exn )
  {
    caml_backtrace_pos = 0;
    caml_backtrace_last_exn = a1;
  }
  if ( caml_backtrace_buffer
    || (v14 = a3,
        v12 = a4,
        result = (unsigned __int64)malloc(0x2000uLL),
        caml_backtrace_buffer = result,
        a3 = v14,
        a4 = v12,
        result) )
  {
    v4 = caml_frame_descriptors;
    if ( !caml_frame_descriptors )
    {
      v13 = a3;
      v11 = a4;
      caml_init_frame_descriptors();
      v4 = caml_frame_descriptors;
      a4 = v11;
      a3 = v13;
    }
    v5 = caml_frame_descriptors_mask;
    v6 = caml_backtrace_buffer;
    v7 = caml_backtrace_pos;
    do
    {
      result = v5 & (a2 >> 3);
      v9 = v4[result];
      if ( !v9 )
        break;
      while ( *(_QWORD *)v9 != a2 )
      {
        result = v5 & (result + 1);
        v9 = v4[result];
        if ( !v9 )
          goto LABEL_15;
      }
      if ( *(_WORD *)(v9 + 8) == 0xFFFF )
      {
        result = a3 + 16;
        a3 = *(_QWORD *)(a3 + 16);
        a2 = *(_QWORD *)(result + 8);
        if ( !a3 )
          break;
      }
      else
      {
        if ( v7 > 1023 )
          break;
        v10 = v7++;
        *(_QWORD *)(v6 + 8 * v10) = v9;
        result = *(_WORD *)(v9 + 8) & 0xFFFC;
        a3 += result;
        a2 = *(_QWORD *)(a3 - 8);
      }
    }
    while ( a3 <= a4 );
LABEL_15:
    caml_backtrace_pos = v7;
  }
  return result;
}
// 658870: using guessed type __int64 caml_backtrace_last_exn;
// 66284C: using guessed type int caml_backtrace_pos;
// 662850: using guessed type __int64 caml_backtrace_buffer;
// 663160: using guessed type int caml_frame_descriptors_mask;

//----- (000000000043BEF0) ----------------------------------------------------
__int64 __fastcall caml_record_backtrace(__int64 a1)
{
  __int64 v1; // rdi

  v1 = a1 >> 1;
  if ( (_DWORD)v1 == caml_backtrace_active )
    return 1LL;
  caml_backtrace_active = v1;
  caml_backtrace_pos = 0;
  if ( !(_DWORD)v1 )
  {
    caml_remove_global_root((unsigned __int64)&caml_backtrace_last_exn);
    return 1LL;
  }
  caml_register_global_root((unsigned __int64)&caml_backtrace_last_exn);
  return 1LL;
}
// 658870: using guessed type __int64 caml_backtrace_last_exn;
// 662848: using guessed type int caml_backtrace_active;
// 66284C: using guessed type int caml_backtrace_pos;

//----- (000000000043BF44) ----------------------------------------------------
void __fastcall caml_call_gc(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  __int64 retaddr; // [rsp+0h] [rbp+0h]

  caml_last_return_address = retaddr;
  caml_bottom_of_stack = (__int64)&a7;
  sub_43BF5B(a1, a2, a3, a4, a5, a6);
}
// 6586A8: using guessed type __int64 caml_last_return_address;
// 658A80: using guessed type __int64 caml_bottom_of_stack;

//----- (000000000043BF5B) ----------------------------------------------------
void __fastcall sub_43BF5B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // r10
  __int64 v8; // r11
  __int64 v9; // r14
  __int64 v10; // r15
  _QWORD v11[13]; // [rsp+80h] [rbp-68h] BYREF

  caml_young_ptr = v10;
  caml_exception_pointer = v9;
  v11[9] = v8;
  v11[8] = v7;
  v11[7] = a6;
  v11[6] = a5;
  v11[5] = a4;
  v11[4] = a3;
  v11[3] = a2;
  v11[2] = a1;
  v11[0] = v6;
  caml_gc_regs = (__int64)v11;
  caml_garbage_collection();
}
// 43BF5B: variable 'v10' is possibly undefined
// 43BF62: variable 'v9' is possibly undefined
// 43BF6E: variable 'v8' is possibly undefined
// 43BF70: variable 'v7' is possibly undefined
// 43BF7B: variable 'v6' is possibly undefined
// 658A40: using guessed type __int64 caml_exception_pointer;
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 663168: using guessed type __int64 caml_gc_regs;

//----- (000000000043C088) ----------------------------------------------------
void __fastcall caml_alloc1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  unsigned __int64 v7; // r15
  __int64 retaddr; // [rsp+0h] [rbp+0h]

  while ( 1 )
  {
    v7 -= 16LL;
    if ( v7 >= caml_young_limit )
      break;
    caml_last_return_address = retaddr;
    caml_bottom_of_stack = (__int64)&a7;
    sub_43BF5B(a1, a2, a3, a4, a5, a6);
  }
}
// 43C088: variable 'v7' is possibly undefined
// 43C0B1: variable 'a3' is possibly undefined
// 43C0B1: variable 'a4' is possibly undefined
// 43C0B1: variable 'a5' is possibly undefined
// 43C0B1: variable 'a6' is possibly undefined
// 6586A8: using guessed type __int64 caml_last_return_address;
// 658A80: using guessed type __int64 caml_bottom_of_stack;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000043C0C0) ----------------------------------------------------
void __fastcall caml_alloc2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  unsigned __int64 v7; // r15
  __int64 retaddr; // [rsp+0h] [rbp+0h]

  while ( 1 )
  {
    v7 -= 24LL;
    if ( v7 >= caml_young_limit )
      break;
    caml_last_return_address = retaddr;
    caml_bottom_of_stack = (__int64)&a7;
    sub_43BF5B(a1, a2, a3, a4, a5, a6);
  }
}
// 43C0C0: variable 'v7' is possibly undefined
// 43C0E9: variable 'a3' is possibly undefined
// 43C0E9: variable 'a4' is possibly undefined
// 43C0E9: variable 'a5' is possibly undefined
// 43C0E9: variable 'a6' is possibly undefined
// 6586A8: using guessed type __int64 caml_last_return_address;
// 658A80: using guessed type __int64 caml_bottom_of_stack;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000043C0F8) ----------------------------------------------------
void __fastcall caml_alloc3(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  unsigned __int64 v7; // r15
  __int64 retaddr; // [rsp+0h] [rbp+0h]

  while ( 1 )
  {
    v7 -= 32LL;
    if ( v7 >= caml_young_limit )
      break;
    caml_last_return_address = retaddr;
    caml_bottom_of_stack = (__int64)&a7;
    sub_43BF5B(a1, a2, a3, a4, a5, a6);
  }
}
// 43C0F8: variable 'v7' is possibly undefined
// 43C121: variable 'a3' is possibly undefined
// 43C121: variable 'a4' is possibly undefined
// 43C121: variable 'a5' is possibly undefined
// 43C121: variable 'a6' is possibly undefined
// 6586A8: using guessed type __int64 caml_last_return_address;
// 658A80: using guessed type __int64 caml_bottom_of_stack;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000043C130) ----------------------------------------------------
__int64 __fastcall caml_allocN(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  __int64 result; // rax
  unsigned __int64 v8; // r15
  __int64 v9; // [rsp-8h] [rbp-8h]
  __int64 retaddr; // [rsp+0h] [rbp+0h]

  while ( 1 )
  {
    v8 -= result;
    if ( v8 >= caml_young_limit )
      break;
    v9 = result;
    caml_last_return_address = retaddr;
    caml_bottom_of_stack = (__int64)&a7;
    sub_43BF5B(a1, a2, a3, a4, a5, a6);
    result = v9;
  }
  return result;
}
// 43C130: variable 'v8' is possibly undefined
// 43C130: variable 'result' is possibly undefined
// 43C156: variable 'a3' is possibly undefined
// 43C156: variable 'a4' is possibly undefined
// 43C156: variable 'a5' is possibly undefined
// 43C156: variable 'a6' is possibly undefined
// 6586A8: using guessed type __int64 caml_last_return_address;
// 658A80: using guessed type __int64 caml_bottom_of_stack;
// 65CCF8: using guessed type __int64 caml_young_limit;

//----- (000000000043C164) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall caml_c_call(__int64 a1, unsigned __int64 a2)
{
  void (__fastcall *v2)(__int64, unsigned __int64); // rax
  __int64 v3; // r14
  __int64 v4; // r15
  __int64 v5; // [rsp-8h] [rbp-8h]
  void *retaddr; // [rsp+0h] [rbp+0h] BYREF

  caml_last_return_address = v5;
  caml_bottom_of_stack = (__int64)&retaddr;
  caml_young_ptr = v4;
  caml_exception_pointer = v3;
  v2(a1, a2);
  __asm { retn }
}
// 43C166: positive sp value 8 has been found
// 43C18D: unbalanced stack, ignored a potential tail call
// 43C166: variable 'v5' is possibly undefined
// 43C174: variable 'v4' is possibly undefined
// 43C17B: variable 'v3' is possibly undefined
// 43C182: variable 'v2' is possibly undefined
// 6586A8: using guessed type __int64 caml_last_return_address;
// 658A40: using guessed type __int64 caml_exception_pointer;
// 658A80: using guessed type __int64 caml_bottom_of_stack;
// 65CCF0: using guessed type __int64 caml_young_ptr;

//----- (000000000043C190) ----------------------------------------------------
__int64 __fastcall caml_start_program(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        double a7)
{
  __int64 v7; // r15
  __int64 result; // rax
  __int64 v9; // [rsp-28h] [rbp-68h]
  __int64 v10; // [rsp-18h] [rbp-58h]
  __int64 v11; // [rsp-10h] [rbp-50h]
  __int64 v12; // [rsp-8h] [rbp-48h]

  v12 = caml_gc_regs;
  v11 = caml_last_return_address;
  v10 = caml_bottom_of_stack;
  v7 = caml_young_ptr;
  v9 = caml_exception_pointer;
  result = caml_startup__code_begin(a1, a2, a3, a4, a5, a6, a7);
  caml_young_ptr = v7;
  caml_exception_pointer = v9;
  caml_bottom_of_stack = v10;
  caml_last_return_address = v11;
  caml_gc_regs = v12;
  return result;
}
// 6586A8: using guessed type __int64 caml_last_return_address;
// 658A40: using guessed type __int64 caml_exception_pointer;
// 658A80: using guessed type __int64 caml_bottom_of_stack;
// 65CCF0: using guessed type __int64 caml_young_ptr;
// 663168: using guessed type __int64 caml_gc_regs;

//----- (000000000043C211) ----------------------------------------------------
void sub_43C211()
{
  JUMPOUT(0x43C1DELL);
}
// 43C215: control flows out of bounds to 43C1DE

//----- (000000000043C218) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall caml_raise_exn()
{
  __int64 result; // rax
  unsigned __int64 v1; // r14
  __int64 v2; // r12
  unsigned __int64 v3; // [rsp-8h] [rbp-8h]
  void *retaddr; // [rsp+0h] [rbp+0h] BYREF

  if ( (caml_backtrace_active & 1) != 0 )
  {
    v2 = result;
    caml_stash_backtrace(result, v3, (unsigned __int64)&retaddr, v1);
    return v2;
  }
  return result;
}
// 43C229: positive sp value 8 has been found
// 43C22A: variable 'result' is possibly undefined
// 43C23C: variable 'v3' is possibly undefined
// 43C23C: variable 'v1' is possibly undefined
// 662848: using guessed type int caml_backtrace_active;

//----- (000000000043C24C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall caml_raise_exception(__int64 a1)
{
  if ( (caml_backtrace_active & 1) != 0 )
    caml_stash_backtrace(a1, caml_last_return_address, caml_bottom_of_stack, caml_exception_pointer);
  return a1;
}
// 43C264: positive sp value 8 has been found
// 43C24C: could not find valid save-restore pair for r14
// 6586A8: using guessed type __int64 caml_last_return_address;
// 658A40: using guessed type __int64 caml_exception_pointer;
// 658A80: using guessed type __int64 caml_bottom_of_stack;
// 662848: using guessed type int caml_backtrace_active;

//----- (000000000043C2A0) ----------------------------------------------------
void caml_callback_exn()
{
  JUMPOUT(0x43C1A5LL);
}
// 43C2B7: control flows out of bounds to 43C1A5

//----- (000000000043C2BC) ----------------------------------------------------
void caml_callback2_exn()
{
  JUMPOUT(0x43C1A5LL);
}
// 43C2D7: control flows out of bounds to 43C1A5

//----- (000000000043C2DC) ----------------------------------------------------
void caml_callback3_exn()
{
  JUMPOUT(0x43C1A5LL);
}
// 43C2FD: control flows out of bounds to 43C1A5

//----- (000000000043C304) ----------------------------------------------------
void __fastcall caml_ml_array_bound_error(__int64 a1, unsigned __int64 a2)
{
  caml_c_call(a1, a2);
}

// nfuncs=1789 queued=1419 decompiled=1419 lumina nreq=0 worse=0 better=0
// ALL OK, 1419 function(s) have been successfully decompiled
