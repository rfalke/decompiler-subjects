/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a910 */
#include <stdint.h>
 
void entry0 (void) {
    /* [13] -r-x section size 156332 named .text */
    ebp = 0;
    ecx = esp;
    return libc_start_main (main, esi, ecx, sym.__libc_csu_init, sym.__libc_csu_fini, edx, esp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a0b4 */
#include <stdint.h>
 
void libc_start_main (void) {
    libc_start_main ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a940 */
#include <stdint.h>
 
int32_t do_global_dtors_aux (void) {
    if (*(obj.completed.5978) != 0) {
        goto label_0;
    }
    eax = *(obj.dtor_idx.5980);
    ebx = obj.__DTOR_END__;
    ebx -= obj.__DTOR_LIST__;
    ebx >>= 2;
    ebx--;
    if (eax >= ebx) {
        goto label_1;
    }
    do {
        eax++;
        *(obj.dtor_idx.5980) = eax;
        uint32_t (*eax*4 + obj.__DTOR_LIST__)() ();
        eax = *(obj.dtor_idx.5980);
    } while (eax < ebx);
label_1:
    *(obj.completed.5978) = 1;
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a9a0 */
#include <stdint.h>
 
int32_t frame_dummy (void) {
    eax = *(obj.__JCR_LIST__);
    if (eax != 0) {
        eax = 0;
        if (eax == 0) {
            goto label_0;
        }
        void (*eax)(uint32_t) (obj.__JCR_LIST__);
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070b90 */
#include <stdint.h>
 
int32_t do_global_ctors_aux (void) {
    eax = .ctors;
    if (eax == -1) {
        goto label_0;
    }
    ebx = .ctors;
    do {
        ebx -= 4;
        void (*eax)() ();
        eax = *(ebx);
    } while (eax != -1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d710 */
#include <stdint.h>
 
uint32_t alloc_group_entry (void) {
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x15ae6;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x44)) = eax;
    eax = ebp - 0x44;
    *(edi) = eax;
    *((ebp - 0x3c)) = 1;
    *((ebp - 0x40)) = 3;
    eax = ebp - 0x1c;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string (eax);
    *((ebp - 0x20)) = eax;
    eax = *((esi + 0xc));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x24)) = eax;
    caml_alloc_small (4, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((ebp - 0x24));
    *((eax + 0xc)) = edx;
    edx = *((ebp - 0x44));
    *(edi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c7ea */
#include <stdint.h>
 
void i686_get_pc_thunk_bx (void) {
    ebx = *(esp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065504 */
#include <stdint.h>
 
int32_t caml_copy_string (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = *((ebp + 8));
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ebx = ecx - 1;
    eax = caml_alloc_string (ebx);
    esi = eax;
    eax = *((ebp + 8));
    memmove (esi, eax, ebx);
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806545a */
#include <stdint.h>
 
int32_t caml_alloc_string (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    ebx = esi + 4;
    ebx >>= 2;
    if (ebx <= 0x100) {
        edx = ebx*4 + 4;
        edi = edx;
        edi = -edi;
        eax = edi;
        eax += *(obj.caml_young_ptr);
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            eax += edx;
            *(obj.caml_young_ptr) = eax;
            caml_minor_collection ();
            *(obj.caml_young_ptr) += edi;
        }
        edx = ebx;
        edx <<= 0xa;
        edx += 0x3fc;
        eax = caml_young_ptr;
        *(eax) = edx;
        eax = caml_young_ptr;
        eax += 4;
    } else {
        eax = caml_alloc_shr (ebx, 0xfc);
        caml_check_urgent_gc (eax);
    }
    ebx <<= 2;
    *((eax + ebx - 4)) = 0;
    ebx--;
    edx = ebx;
    ecx = esi;
    dl -= cl;
    *((eax + ebx)) = dl;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a684 */
#include <stdint.h>
 
void memmove (void) {
    memmove ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806573a */
#include <stdint.h>
 
int32_t caml_copy_string_array (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    caml_alloc_array (sym.caml_copy_string, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065676 */
#include <stdint.h>
 
int32_t caml_alloc_array (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4ch;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    esi = *((ebp + 0xc));
    eax = caml_local_roots;
    *((ebp - 0x4c)) = eax;
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x40;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 2;
    eax = ebp - 0x1c;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x30)) = eax;
    if (*(esi) == 0) {
        goto label_0;
    }
    ebx = 0;
    do {
        ebx++;
    } while (*((esi + ebx*4)) != 0);
    if (ebx == 0) {
label_0:
        eax = 0x8083504;
        edx = *((ebp - 0x4c));
        *(obj.caml_local_roots) = edx;
        goto label_1;
    }
    eax = caml_alloc (ebx, 0);
    *((ebp - 0x20)) = eax;
    edi = 0;
    do {
        eax = *(esi);
        eax = uint32_t (*ebp + 8)(uint32_t) (eax);
        *((ebp - 0x1c)) = eax;
        eax = edi*4;
        eax += *((ebp - 0x20));
        caml_modify (eax, eax);
        edi++;
        esi += 4;
    } while (edi < ebx);
    eax = *((ebp - 0x4c));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x20));
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80653f1 */
#include <stdint.h>
 
int32_t caml_alloc_small (int32_t arg_8h, fd_set * arg_ch) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = *((ebp + 8));
    edx = esi*4 + 4;
    ebx = edx;
    ebx = -ebx;
    eax = ebx;
    eax += *(obj.caml_young_ptr);
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        eax += edx;
        *(obj.caml_young_ptr) = eax;
        caml_minor_collection ();
        *(obj.caml_young_ptr) += ebx;
    }
    esi <<= 0xa;
    eax = *((ebp + 0xc));
    edx = eax + esi + 0x300;
    eax = caml_young_ptr;
    *(eax) = edx;
    eax = caml_young_ptr;
    eax += 4;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064903 */
#include <stdint.h>
 
int32_t caml_minor_collection (void) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = caml_allocated_words;
    caml_empty_minor_heap ();
    eax = caml_allocated_words;
    eax -= ebx;
    esi = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = esi;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] += *(obj.caml_stat_promoted_words);
    *(obj.caml_stat_promoted_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_stat_minor_collections)++;
    caml_major_collection_slice (0);
    *(obj.caml_force_major_slice) = 0;
    caml_final_do_calls ();
    caml_empty_minor_heap ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80647b9 */
#include <stdint.h>
 
int32_t caml_empty_minor_heap (void) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    eax = caml_young_ptr;
    if (eax == *(obj.caml_young_end)) {
        goto label_0;
    }
    *(obj.caml_in_minor_collection) = 1;
    caml_gc_message (2, 0x807141c, 0);
    caml_oldify_local_roots ();
    ebx = caml_ref_table;
    if (ebx >= *(0x807fe88)) {
        goto label_1;
    }
    esi = 0x807fe88;
    do {
        eax = *(ebx);
        eax = *(eax);
        caml_oldify_one (eax, eax);
        ebx += 4;
    } while (*(esi) > ebx);
label_1:
    caml_oldify_mopup ();
    eax = caml_weak_ref_table;
    if (eax >= *(0x807fea4)) {
        goto label_2;
    }
    ebx = 0x807fea4;
    do {
        ecx = *(eax);
        edx = *(ecx);
        if ((dl & 1) == 0) {
            if (edx >= *(obj.caml_young_end)) {
                goto label_3;
            }
            if (edx <= *(obj.caml_young_start)) {
                goto label_3;
            }
            if (*((edx - 4)) == 0) {
                edx = *(edx);
                *(ecx) = edx;
            } else {
                edx = caml_weak_none;
                *(ecx) = edx;
            }
        }
label_3:
        eax += 4;
    } while (*(ebx) > eax);
label_2:
    eax = caml_young_start;
    edx = caml_young_ptr;
    if (*(obj.caml_young_ptr) < eax) {
        edx = eax;
    }
    eax = caml_young_end;
    ecx = caml_young_end;
    ecx -= edx;
    edx = ecx;
    edx >>= 2;
    ecx = 0;
    *((ebp - 0x10)) = edx;
    *((ebp - 0xc)) = ecx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *(obj.caml_stat_minor_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_young_ptr) = eax;
    eax = caml_young_start;
    *(obj.caml_young_limit) = eax;
    eax = caml_ref_table;
    clear_table ();
    eax = caml_weak_ref_table;
    clear_table ();
    caml_gc_message (2, 0x8071a87, 0);
    *(obj.caml_in_minor_collection) = 0;
label_0:
    caml_final_empty_young ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80642a8 */
#include <stdint.h>
 
int32_t caml_major_collection_slice (int32_t arg_8h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_22h;
    int32_t var_20h;
    int32_t var_1ch;
    char * var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    if (*(obj.caml_gc_phase) == 2) {
        start_cycle ();
    }
    eax = caml_allocated_words;
    edx = caml_percent_free;
    esi = edx + 0x64;
    edi = 0;
    *((ebp - 0x20)) = esi;
    *((ebp - 0x1c)) = edi;
    *(fp_stack--) = *((ebp - 0x20));
    ecx = 0;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x1c)) = ecx;
    *(fp_stack--) = *((ebp - 0x20));
    ecx = 0;
    *((ebp - 0x20)) = eax;
    *((ebp - 0x1c)) = ecx;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] *= *(0x807140c);
    fp_stack[0] *= fp_stack[2];
    edx = caml_stat_heap_size;
    edx >>= 2;
    ecx = 0;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x1c)) = ecx;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    fp_stack[0] /= fp_stack[1];
    fp_stack[0] *= *(0x8071410);
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    edx = caml_dependent_size;
    if (edx == 0) {
        fp_stack++;
        fp_stack++;
        *(fp_stack--) = 0.0;
    } else {
        esi = caml_dependent_allocated;
        edi = 0;
        *((ebp - 0x20)) = esi;
        *((ebp - 0x1c)) = edi;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] *= fp_stack[2];
        fp_stack++;
        ecx = 0;
        *((ebp - 0x20)) = edx;
        *((ebp - 0x1c)) = ecx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] /= fp_stack[2];
        fp_stack++;
        fp_stack[0] /= fp_stack[1];
        fp_stack++;
    }
    *(fp_stack--) = *((ebp - 0x30));
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    __asm ("fcmovbe st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_extra_heap_resources);
    __asm ("fcmovbe st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    caml_gc_message (0x40, "allocated_words = %lu\n", eax);
    *(fp_stack--) = *(0x8071030);
    fp_stack[0] *= *(obj.caml_extra_heap_resources);
    eax = *((ebp - 0x22));
    ah = 0xc;
    *((ebp - 0x24)) = ax;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x20));
    caml_gc_message (0x40, "extra_heap_resources = %luu\n", eax);
    *(fp_stack--) = *(0x8071030);
    fp_stack[0] *= *((ebp - 0x30));
    eax = *((ebp - 0x22));
    ah = 0xc;
    *((ebp - 0x24)) = ax;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x20));
    caml_gc_message (0x40, "amount of work to do = %luu\n", eax);
    if (*(obj.caml_gc_phase) == 0) {
        eax = caml_stat_heap_size;
        eax >>= 2;
        edx = 0;
        *((ebp - 0x20)) = eax;
        *((ebp - 0x1c)) = edx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] *= *((ebp - 0x30));
        fp_stack[0] *= *(0x8071414);
        eax = caml_percent_free;
        eax += 0x64;
        edx = 0;
        *((ebp - 0x20)) = eax;
        *((ebp - 0x1c)) = edx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] /= fp_stack[1];
        fp_stack++;
        eax = *((ebp - 0x22));
        ah = 0xc;
        *((ebp - 0x24)) = ax;
        *((ebp - 0x28)) = fp_stack[0];
        fp_stack--;
        esi = *((ebp - 0x28));
    } else {
        eax = caml_stat_heap_size;
        eax >>= 2;
        edx = 0;
        *((ebp - 0x20)) = eax;
        *((ebp - 0x1c)) = edx;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] *= *((ebp - 0x30));
        fp_stack[0] *= *(0x8071418);
        fp_stack[0] /= *(0x807140c);
        eax = *((ebp - 0x22));
        ah = 0xc;
        *((ebp - 0x24)) = ax;
        *((ebp - 0x28)) = fp_stack[0];
        fp_stack--;
        esi = *((ebp - 0x28));
    }
    caml_gc_message (0x40, "ordered work = %ld words\n", ebx);
    caml_gc_message (0x40, "computed work = %ld words\n", esi);
    if (ebx == 0) {
        ebx = esi;
    }
    if (*(obj.caml_gc_phase) == 0) {
        eax = ebx;
        mark_slice ();
        caml_gc_message (2, 0x8071405, 0);
    } else {
        eax = ebx;
        sweep_slice ();
        caml_gc_message (2, 0x8071407, 0);
    }
    if (*(obj.caml_gc_phase) == 2) {
        caml_compact_heap_maybe ();
    }
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x20)) = eax;
    *((ebp - 0x1c)) = edx;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *(obj.caml_stat_major_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_allocated_words) = 0;
    *(obj.caml_dependent_allocated) = 0;
    *(fp_stack--) = 0.0;
    *(obj.caml_extra_heap_resources) = fp_stack[0];
    fp_stack--;
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806f749 */
#include <stdint.h>
 
uint32_t caml_final_do_calls (void) {
    char * var_4h;
    int32_t var_8h;
    if (*(obj.running_finalisation_function) != 0) {
        goto label_1;
    }
    if (*(obj.to_do_hd) == 0) {
        goto label_1;
    }
    eax = caml_gc_message (0x80, "Calling finalisation functions.\n", 0);
    while (edx == 0) {
        ebx = *(eax);
        free (eax);
        *(obj.to_do_hd) = ebx;
        if (ebx == 0) {
            *(obj.to_do_tl) = 0;
        }
label_0:
        eax = to_do_hd;
        if (eax == 0) {
            goto label_2;
        }
        edx = *((eax + 4));
    }
    edx--;
    *((eax + 4)) = edx;
    edx *= 3;
    eax = eax + edx*4;
    edx = *((eax + 8));
    ecx = *((eax + 0x10));
    eax = *((eax + 0xc));
    *(obj.running_finalisation_function) = 1;
    eax += ecx;
    eax = caml_callback_exn (edx, eax);
    *(obj.running_finalisation_function) = 0;
    edx = eax;
    edx &= 3;
    if (edx != 2) {
        goto label_0;
    }
    eax &= 0xfffffffc;
    caml_raise (eax);
label_2:
    caml_gc_message (0x80, "Done calling finalisation functions.\n", 0);
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80630ff */
#include <stdint.h>
 
int32_t caml_gc_message (int32_t arg_8h, char * arg_ch, size_t arg_10h) {
    char * format;
    size_t var_8h;
    eax = *((ebp + 8));
    if (eax >= 0) {
        if ((*(obj.caml_verb_gc) & eax) == 0) {
            goto label_0;
        }
    }
    eax = *((ebp + 0x10));
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax = stderr;
    fprintf (eax, eax);
    eax = stderr;
    fflush (eax);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a1a4 */
#include <stdint.h>
 
void free (void) {
    free ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070628 */
#include <stdint.h>
 
int32_t loc_caml_callback_exn (int32_t arg_14h, int32_t arg_18h) {
    do {
        *(obj.caml_exception_pointer) = esp;
        void (*esi)(uint32_t*, uint32_t, uint32_t*, uint32_t*, uint32_t*) (*(obj.caml_exception_pointer), 0x807059e, *(obj.caml_bottom_of_stack), *(obj.caml_last_return_address), *(obj.caml_gc_regs));
        return;
        ebx = *((esp + 0x14));
        eax = *((esp + 0x18));
        esi = *(ebx);
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061ba0 */
#include <stdint.h>
 
int32_t caml_raise (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = caml_channel_mutex_unlock_exn;
    if (eax != 0) {
        void (*eax)() ();
    }
    edx = caml_exception_pointer;
    if (edx != 0) {
        eax = caml_local_roots;
        if (eax == 0) {
            goto label_0;
        }
        if (eax < edx) {
            goto label_1;
        }
        goto label_0;
    }
    eax = caml_fatal_uncaught_exception (ebx);
    do {
label_1:
        eax = *(eax);
        *(obj.caml_local_roots) = eax;
        if (eax == 0) {
            goto label_0;
        }
    } while (edx > eax);
label_0:
    return caml_raise_exception (ebx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d8b4 */
#include <stdint.h>
 
uint32_t alloc_host_entry (void) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x15943;
    esi = eax;
    *((ebp - 0xc)) = 1;
    *((ebp - 0x10)) = 1;
    *((ebp - 0x14)) = 1;
    *((ebp - 0x18)) = 1;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x38)) = edx;
    edx = ebp - 0x38;
    *(eax) = edx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp - 0xc;
    *((ebp - 0x2c)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x28)) = eax;
    eax = ebp - 0x14;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x18;
    *((ebp - 0x20)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0xc)) = eax;
    eax = *((esi + 4));
    if (eax != 0) {
        eax = caml_copy_string_array (eax);
        *((ebp - 0x10)) = eax;
    } else {
        eax = *((ebx - 4));
        eax = eax + 4;
        *((ebp - 0x10)) = eax;
    }
    eax = *((esi + 0xc));
    *((ebx + 0x9968)) = eax;
    eax = *((esi + 0x10));
    eax = ebx - 0x15792;
    eax = caml_alloc_array (eax, eax);
    *((ebp - 0x14)) = eax;
    caml_alloc_small (4, 0);
    edx = *((ebp - 0xc));
    *(eax) = edx;
    edx = eax;
    ecx = *((ebp - 0x10));
    *((eax + 4)) = ecx;
    ecx = *((esi + 8));
    if (ecx != 1) {
        cl = (ecx != 2) ? 1 : 0;
        ecx = (int32_t) cl;
        ecx = ecx + ecx + 3;
        *((eax + 8)) = ecx;
    } else {
        *((eax + 8)) = 1;
    }
    ecx = *((ebp - 0x14));
    *((edx + 0xc)) = ecx;
    ecx = *((ebp - 0x38));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805da72 */
#include <stdint.h>
 
int32_t alloc_one_addr (int32_t arg_8h) {
    void * s1;
    void * var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x15781;
    eax = *((ebp + 8));
    if (*((ebx + 0x9968)) == 0x10) {
        esi = ebp - 0x1c;
        memmove (esi, eax, 0x10);
        eax = alloc_inet6_addr (esi);
    } else {
        esi = ebp - 0xc;
        memmove (esi, eax, 4);
        alloc_inet_addr (esi);
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805de10 */
#include <stdint.h>
 
uint32_t alloc_proto_entry (void) {
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x153e0;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x40;
    *(edi) = eax;
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 2;
    eax = ebp - 0x1c;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x20)) = eax;
    caml_alloc_small (3, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((ebp - 0x40));
    *(edi) = edx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805df20 */
#include <stdint.h>
 
uint32_t alloc_passwd_entry (void) {
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x152d6;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    *((ebp - 0x28)) = 1;
    *((ebp - 0x2c)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(edi) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 5;
    eax = ebp - 0x1c;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x2c;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string (eax);
    *((ebp - 0x20)) = eax;
    eax = *((esi + 0x10));
    eax = caml_copy_string (eax);
    *((ebp - 0x24)) = eax;
    eax = *((esi + 0x14));
    eax = caml_copy_string (eax);
    *((ebp - 0x28)) = eax;
    eax = *((esi + 0x18));
    eax = caml_copy_string (eax);
    *((ebp - 0x2c)) = eax;
    caml_alloc_small (7, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((esi + 0xc));
    edx = edx + edx + 1;
    *((eax + 0xc)) = edx;
    edx = *((ebp - 0x24));
    *((eax + 0x10)) = edx;
    edx = *((ebp - 0x28));
    *((eax + 0x14)) = edx;
    edx = *((ebp - 0x2c));
    *((eax + 0x18)) = edx;
    edx = *((ebp - 0x4c));
    *(edi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e0f0 */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
uint32_t alloc_service_entry (void) {
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x15106;
    esi = eax;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    edi = *((ebx - 0x18));
    eax = *(edi);
    *((ebp - 0x44)) = eax;
    eax = ebp - 0x44;
    *(edi) = eax;
    *((ebp - 0x3c)) = 1;
    *((ebp - 0x40)) = 3;
    eax = ebp - 0x1c;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x30)) = eax;
    eax = *(esi);
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = *((esi + 4));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x20)) = eax;
    eax = *((esi + 0xc));
    eax = caml_copy_string (eax);
    *((ebp - 0x24)) = eax;
    caml_alloc_small (4, 0);
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    dx = rotate_right16 (dx, 8);
    edx = (int32_t) dx;
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((ebp - 0x24));
    *((eax + 0xc)) = edx;
    edx = *((ebp - 0x44));
    *(edi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e2d0 */
#include <stdint.h>
 
uint32_t alloc_tm (void) {
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x14f27;
    esi = eax;
    caml_alloc_small (9, 0);
    edx = *(esi);
    edx = edx + edx + 1;
    *(eax) = edx;
    edx = *((esi + 4));
    edx = edx + edx + 1;
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    edx = edx + edx + 1;
    *((eax + 8)) = edx;
    edx = *((esi + 0xc));
    edx = edx + edx + 1;
    *((eax + 0xc)) = edx;
    edx = *((esi + 0x10));
    edx = edx + edx + 1;
    *((eax + 0x10)) = edx;
    edx = *((esi + 0x14));
    edx = edx + edx + 1;
    *((eax + 0x14)) = edx;
    edx = *((esi + 0x18));
    edx = edx + edx + 1;
    *((eax + 0x18)) = edx;
    edx = *((esi + 0x1c));
    edx = edx + edx + 1;
    *((eax + 0x1c)) = edx;
    edx -= edx;
    edx &= 0xfffffffe;
    edx += 3;
    *((eax + 0x20)) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e5b4 */
#include <stdint.h>
 
uint32_t unix_convert_itimer (void) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x14c3f;
    esi = eax;
    eax = caml_alloc_small (4, 0xfe);
    *(fp_stack--) = *(esi);
    *(fp_stack--) = *((esi + 4));
    *(fp_stack--) = *((ebx - 0x251c));
    fp_stack[1] /= fp_stack[0];
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack[0] += fp_stack[2];
    fp_stack++;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    *(eax) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((esi + 8));
    *(fp_stack--) = *((esi + 0xc));
    fp_stack[2] /= fp_stack[0];
    fp_stack++;
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e663 */
#include <stdint.h>
 
uint32_t unix_set_timeval (void) {
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_2ah;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x14b8d;
    esi = eax;
    eax = ebp - 0x20;
    *(fp_stack--) = *((ebp + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    modf (eax);
    eax = *((ebp - 0x2a));
    ah = 0xc;
    *((ebp - 0x2c)) = ax;
    *(fp_stack--) = *((ebp - 0x20));
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    edi = *((ebp - 0x30));
    *(esi) = edi;
    fp_stack[0] *= *((ebx - 0x251c));
    *(esp) = fp_stack[0];
    fp_stack--;
    ceil ();
    eax = *((ebp - 0x2a));
    ah = 0xc;
    *((ebp - 0x2c)) = ax;
    *((ebp - 0x30)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x30));
    *((esi + 4)) = eax;
    if (eax > 0xf423f) {
        edi++;
        *(esi) = edi;
        *((esi + 4)) = 0;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a0e4 */
#include <stdint.h>
 
void modf (void) {
    modf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a8e4 */
#include <stdint.h>
 
void ceil (void) {
    ceil ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f16c */
#include <stdint.h>
 
int32_t fdlist_to_fdset (int32_t arg_8h) {
    int32_t var_ch;
    esi = eax;
    *((ebp - 0xc)) = edx;
    ecx = 0x20;
    edi = edx;
    eax = 0;
    memset (edi, eax, ecx);
    if (esi == 1) {
        goto label_0;
    }
    edx = esi;
    do {
        edi = *(edx);
        eax = *(edx);
        eax >>= 1;
        esi = eax + 0x1f;
        __asm ("cmovns esi, eax");
        esi >>= 5;
        edi >>= 0x1f;
        edi >>= 0x1b;
        ecx = eax + edi;
        ecx &= 0x1f;
        ecx -= edi;
        edi = 1;
        edi <<= cl;
        ecx = edi;
        edi = *((ebp - 0xc));
        *((edi + esi*4)) |= ecx;
        ecx = *((ebp + 8));
        if (eax > *(ecx)) {
            *(ecx) = eax;
        }
        edx = *((edx + 4));
    } while (edx != 1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f1d5 */
#include <stdint.h>
 
uint32_t fdset_to_fdlist (void) {
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x14021;
    edi = edx;
    *((ebp - 0x20)) = 1;
    edx = *((ebx - 0x18));
    ecx = *(edx);
    *((ebp - 0x40)) = ecx;
    ecx = ebp - 0x40;
    *(edx) = ecx;
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 2;
    edx = ebp - 0x1c;
    *((ebp - 0x34)) = edx;
    edx = ebp - 0x20;
    *((ebp - 0x30)) = edx;
    if (eax == 1) {
        goto label_0;
    }
    *((ebp - 0x1c)) = eax;
    do {
        eax = *(eax);
        esi = *(eax);
        esi >>= 1;
        edx = esi + 0x1f;
        __asm ("cmovns edx, esi");
        edx >>= 5;
        eax >>= 0x1f;
        eax >>= 0x1b;
        ecx = esi + eax;
        ecx &= 0x1f;
        ecx -= eax;
        edx = *((edi + edx*4));
        if (((edx >> ecx) & 1) < 0) {
            caml_alloc_small (2, 0);
            edx = esi + esi + 1;
            *(eax) = edx;
            edx = *((ebp - 0x20));
            *((eax + 4)) = edx;
            *((ebp - 0x20)) = eax;
        }
        eax = *((ebp - 0x1c));
        eax = *((eax + 4));
        if (eax == 1) {
            goto label_0;
        }
        *((ebp - 0x1c)) = eax;
    } while (1);
label_0:
    edx = *((ebp - 0x40));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = *((ebp - 0x20));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fa70 */
#include <stdint.h>
 
uint32_t decode_sigset (void) {
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x13786;
    esi = eax;
    edi = edx;
    *(esp) = edx;
    sigemptyset ();
    if (esi == 1) {
        goto label_0;
    }
    do {
        eax = *(esi);
        eax >>= 1;
        eax = caml_convert_signal_number (eax);
        *((esp + 4)) = eax;
        *(esp) = edi;
        sigaddset ();
        esi = *((esi + 4));
    } while (esi != 1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fb2f */
#include <stdint.h>
 
uint32_t encode_sigset (void) {
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x136c7;
    *((ebp - 0x4c)) = eax;
    *((ebp - 0x1c)) = 1;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x3c)) = edx;
    edx = ebp - 0x3c;
    *(eax) = edx;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    esi = 1;
    do {
        *((esp + 4)) = esi;
        eax = *((ebp - 0x4c));
        *(esp) = eax;
        eax = sigismember ();
        if (eax > 0) {
            eax = caml_alloc_small (2, 0);
            edi = eax;
            caml_rev_convert_signal_number (esi);
            eax = eax + eax + 1;
            *(edi) = eax;
            eax = *((ebp - 0x1c));
            *((edi + 4)) = eax;
            *((ebp - 0x1c)) = edi;
        }
        esi++;
    } while (esi != 0x41);
    edx = *((ebp - 0x3c));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806048c */
#include <stdint.h>
 
uint32_t stat_aux (void) {
    uint32_t var_5ch;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x12d6a;
    *((ebp - 0x5c)) = eax;
    esi = edx;
    eax = *((ebx - 0x18));
    edi = *(eax);
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x28)) = 0;
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x4c)) = edi;
    edx = ebp - 0x4c;
    *(eax) = edx;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 5;
    eax = ebp - 0x1c;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x2c;
    *((ebp - 0x30)) = eax;
    *(fp_stack--) = *((esi + 0x40));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x1c)) = eax;
    *(fp_stack--) = *((esi + 0x48));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x20)) = eax;
    *(fp_stack--) = *((esi + 0x50));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x24)) = eax;
    if (*((ebp - 0x5c)) != 0) {
        eax = *((esi + 0x2c));
        edx = *((esi + 0x30));
        caml_copy_int64 (eax, edx);
    } else {
        eax = *((esi + 0x2c));
        eax = eax + eax + 1;
    }
    *((ebp - 0x28)) = eax;
    eax = caml_alloc_small (0xc, 0);
    *((ebp - 0x2c)) = eax;
    edx = *(esi);
    edx = edx + edx + 1;
    *(eax) = edx;
    eax = *((esi + 0x58));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 4)) = edx;
    eax = *((ebp - 0x2c));
    eax += 8;
    *((ebp - 0x5c)) = eax;
    eax = ebx + 0x94cc;
    eax = *((esi + 0x10));
    eax &= 0xf000;
    eax = cst_to_constr (0, eax, 7);
    edx = *((ebp - 0x5c));
    *(edx) = eax;
    eax = *((esi + 0x10));
    eax &= 0xfff;
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0xc)) = edx;
    eax = *((esi + 0x14));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x10)) = edx;
    eax = *((esi + 0x18));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x14)) = edx;
    eax = *((esi + 0x1c));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x18)) = edx;
    eax = *((esi + 0x20));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 0x1c)) = edx;
    edx = *((ebp - 0x28));
    eax = *((ebp - 0x2c));
    *((eax + 0x20)) = edx;
    edx = *((ebp - 0x1c));
    eax = *((ebp - 0x2c));
    *((eax + 0x24)) = edx;
    edx = *((ebp - 0x20));
    eax = *((ebp - 0x2c));
    *((eax + 0x28)) = edx;
    edx = *((ebp - 0x24));
    eax = *((ebp - 0x2c));
    *((eax + 0x2c)) = edx;
    eax = *((ebx - 0x18));
    *(eax) = edi;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806134c */
#include <stdint.h>
 
uint32_t alloc_process_status (void) {
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = _i686_get_pc_thunk_bx ();
    ebx += 0x11ea4;
    edi = eax;
    esi = edx;
    eax = edx;
    eax &= 0x7f;
    *((ebp - 0x4c)) = eax;
    if (eax == 0) {
        eax = caml_alloc_small (1, 0);
        *((ebp - 0x1c)) = eax;
        edx = esi;
        esi = (int32_t) dh;
        edx = esi + esi + 1;
        *(eax) = edx;
    } else {
        if (dl == 0x7f) {
            eax = caml_alloc_small (1, 2);
            *((ebp - 0x4c)) = eax;
            *((ebp - 0x1c)) = eax;
            edx = esi;
            esi = (int32_t) dh;
            caml_rev_convert_signal_number (esi);
            eax = eax + eax + 1;
            edx = *((ebp - 0x4c));
            *(edx) = eax;
        } else {
            eax = caml_alloc_small (1, 1);
            esi = eax;
            *((ebp - 0x1c)) = eax;
            eax = *((ebp - 0x4c));
            caml_rev_convert_signal_number (eax);
            eax = eax + eax + 1;
            *(esi) = eax;
        }
    }
    esi = *((ebx - 0x18));
    eax = *(esi);
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x3c;
    *(esi) = eax;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    caml_alloc_small (2, 0);
    edx = edi + edi + 1;
    *(eax) = edx;
    edx = *((ebp - 0x1c));
    *((eax + 4)) = edx;
    edx = *((ebp - 0x3c));
    *(esi) = edx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061800 */
#include <stdint.h>
 
uint32_t scanmult (void) {
    int32_t var_2ch;
    int32_t var_20h;
    int32_t var_19h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * format;
    uint32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = eax;
    *((ebp - 0x2c)) = edx;
    *((ebp - 0x19)) = 0x20;
    ebx = ebp - 0x19;
    esi = ebp - 0x20;
    isoc99_sscanf (ebx, "=%u%c", esi);
    isoc99_sscanf (ebx, "=0x%x%c", esi);
    eax = *((ebp - 0x19));
    if (al != 0x4d) {
        if (al != 0x6b) {
            if (al != 0x47) {
                goto label_0;
            }
            eax = *((ebp - 0x20));
            eax <<= 0xa;
            edx = *((ebp - 0x2c));
            *(edx) = eax;
        } else {
        } else {
            eax = *((ebp - 0x20));
            eax <<= 0x14;
            edx = *((ebp - 0x2c));
            *(edx) = eax;
            goto label_1;
        }
        eax = *((ebp - 0x20));
        eax <<= 0x1e;
        edx = *((ebp - 0x2c));
        *(edx) = eax;
        goto label_1;
label_0:
        eax = *((ebp - 0x20));
        edx = *((ebp - 0x2c));
        *(edx) = eax;
    }
label_1:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062002 */
#include <stdint.h>
 
int32_t cons (void) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = eax;
    esi = edx;
    caml_stat_alloc (8);
    *(eax) = ebx;
    *((eax + 4)) = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064d0a */
#include <stdint.h>
 
uint32_t caml_stat_alloc (size_t size) {
    ebx = *((ebp + 8));
    eax = malloc (ebx);
    if (eax == 0) {
        if (ebx == 0) {
            goto label_0;
        }
        caml_raise_out_of_memory ();
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a5c4 */
#include <stdint.h>
 
void malloc (void) {
    malloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061c79 */
#include <stdint.h>
 
void caml_raise_out_of_memory (void) {
    return caml_raise (loc.caml_bucket_Out_of_memory);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062590 */
#include <stdint.h>
 
int32_t caml_iterate_global_roots (void) {
    int32_t var_4h;
    esi = eax;
    ebx = *((edx + 4));
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = *(ebx);
        eax = *(eax);
        void (*esi)(uint32_t, uint32_t) (eax, eax);
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80625f0 */
#include <stdint.h>
 
int32_t caml_insert_global_root (void) {
    int32_t var_70h;
    int32_t var_6ch;
    int32_t var_5ch;
    *((ebp - 0x70)) = eax;
    ebx = edx;
    edi = eax;
    eax = *((eax + 0x48));
    *((ebp - 0x6c)) = eax;
    ecx = eax;
    edx = edi;
    if (eax < 0) {
        goto label_1;
    }
    esi = ebp - 0x5c;
    do {
label_0:
        eax = *((edx + ecx*4 + 4));
        if (eax == 0) {
            goto label_2;
        }
        if (*(eax) >= ebx) {
            goto label_2;
        }
        edx = eax;
    } while (1);
label_2:
    *((esi + ecx*4)) = edx;
    ecx--;
    if (ecx != -1) {
        goto label_0;
    }
label_1:
    eax = *((edx + 4));
    if (eax != 0) {
        if (*(eax) == ebx) {
            goto label_3;
        }
    }
    eax = *(obj.random_seed) * 0x10dcd;
    eax += 0x6255;
    *(obj.random_seed) = eax;
    edx = eax;
    edx &= 0xc0000000;
    esi = 0;
    if (edx != 0xc0000000) {
        goto label_4;
    }
    do {
        esi++;
        eax <<= 2;
        edx = eax;
        edx &= 0xc0000000;
    } while (edx == 0xc0000000);
label_4:
    if (*((ebp - 0x6c)) >= esi) {
        goto label_5;
    }
    eax = *((ebp - 0x6c));
    eax++;
    if (eax > esi) {
        goto label_6;
    }
    edx = ebp - 0x5c;
    do {
        *((edx + eax*4)) = edi;
        eax++;
    } while (eax <= esi);
label_6:
    eax = *((ebp - 0x70));
    *((eax + 0x48)) = esi;
label_5:
    eax = esi*4 + 8;
    caml_stat_alloc (eax);
    *(eax) = ebx;
    if (esi < 0) {
        goto label_3;
    }
    edx = 0;
    edi = ebp - 0x5c;
    do {
        ecx = *((edi + edx*4));
        ebx = *((ecx + edx*4 + 4));
        *((eax + edx*4 + 4)) = ebx;
        *((ecx + edx*4 + 4)) = eax;
        edx++;
    } while (edx <= esi);
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80627cc */
#include <stdint.h>
 
int32_t caml_delete_global_root (void) {
    int32_t var_6ch;
    int32_t var_5ch;
    ebx = eax;
    ecx = eax;
    eax = *((eax + 0x48));
    *((ebp - 0x6c)) = eax;
    if (eax < 0) {
        goto label_1;
    }
    esi = eax;
    edi = ebp - 0x5c;
    do {
label_0:
        eax = *((ecx + esi*4 + 4));
        if (eax == 0) {
            goto label_2;
        }
        if (*(eax) >= edx) {
            goto label_2;
        }
        ecx = eax;
    } while (1);
label_2:
    *((edi + esi*4)) = ecx;
    esi--;
    if (esi != -1) {
        goto label_0;
    }
label_1:
    ecx = *((ecx + 4));
    if (ecx == 0) {
        goto label_3;
    }
    if (*(ecx) != edx) {
        goto label_3;
    }
    if (*((ebp - 0x6c)) < 0) {
        goto label_4;
    }
    eax = 0;
    edi = ebp - 0x5c;
    do {
        edx = *((edi + eax*4));
        if (*((edx + eax*4 + 4)) == ecx) {
            esi = *((ecx + eax*4 + 4));
            *((edx + eax*4 + 4)) = esi;
        }
        eax++;
    } while (*((ebx + 0x48)) >= eax);
label_4:
    caml_stat_free (ecx);
    eax = *((ebx + 0x48));
    if (eax <= 0) {
        goto label_3;
    }
    if (*((ebx + eax*4 + 4)) != 0) {
        goto label_3;
    }
    do {
        eax--;
        if (eax <= 0) {
            goto label_5;
        }
    } while (*((ebx + eax*4 + 4)) == 0);
    *((ebx + 0x48)) = eax;
    goto label_3;
label_5:
    *((ebx + 0x48)) = eax;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062a07 */
#include <stdint.h>
 
void caml_enter_blocking_section_default (void) {
    *(obj.caml_async_signal_mode) = 1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062a16 */
#include <stdint.h>
 
void caml_leave_blocking_section_default (void) {
    *(obj.caml_async_signal_mode) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062a25 */
#include <stdint.h>
 
int32_t caml_try_leave_blocking_section_default (void) {
    eax = 0;
    tmp_0 = obj.caml_async_signal_mode;
    obj.caml_async_signal_mode = eax;
    eax = tmp_0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062e7f */
#include <stdint.h>
 
uint32_t segv_handler (int32_t arg_60h) {
    int32_t var_a4h;
    int32_t var_a0h;
    int32_t var_20h;
    int32_t var_18h;
    struct sigaction * act;
    struct sigaction * oldact;
    ebx = *((ebp + 0x60));
    if ((bl & 3) == 0) {
        eax = ebp - 0x18;
        *((esp + 4)) = eax;
        *(esp) = 3;
        eax = getrlimit64 ();
        if (eax != 0) {
            goto label_0;
        }
        eax = system_stack_top;
        if (ebx >= eax) {
            goto label_0;
        }
        eax -= *((ebp - 0x18));
        eax = eax - 0x2000;
        if (ebx < eax) {
            goto label_0;
        }
        caml_raise_stack_overflow ();
    }
label_0:
    *((ebp - 0xa4)) = 0;
    *((ebp - 0x20)) = 0;
    ebx = ebp - 0xa4;
    eax = ebp - 0xa0;
    *(esp) = eax;
    sigemptyset ();
    sigaction (0xb, ebx, 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a754 */
#include <stdint.h>
 
void getrlimit64 (void) {
    getrlimit64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061c67 */
#include <stdint.h>
 
void caml_raise_stack_overflow (void) {
    return caml_raise (loc.caml_bucket_Stack_overflow);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049e04 */
#include <stdint.h>
 
void sigemptyset (void) {
    sigemptyset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a234 */
#include <stdint.h>
 
void sigaction (void) {
    sigaction ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062f09 */
#include <stdint.h>
 
uint32_t handle_signal (int32_t arg_8h) {
    int32_t var_4h;
    ebx = *((ebp + 8));
    if (ebx <= 0x40) {
        eax = uint32_t (*caml_try_leave_blocking_section_hook)() ();
        if (eax != 0) {
            caml_execute_signal (ebx, 1);
            uint32_t (*caml_enter_blocking_section_hook)() ();
        } else {
            caml_record_signal (ebx);
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063140 */
#include <stdint.h>
 
uint32_t allocate_block (int32_t arg_8h) {
    uint32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    *((ebp - 0x10)) = edx;
    edx = *((ebp + 8));
    esi = edx - 4;
    ebx = *(esi);
    ebx >>= 0xa;
    edi = eax + 1;
    if (ebx < edi) {
        edi = ebx;
        edi = ~edi;
        *(obj.caml_fl_cur_size) += edi;
        edi = *(edx);
        *(ecx) = edi;
        edi = caml_fl_merge;
        if (*(obj.caml_fl_merge) == edx) {
            edi = ecx;
        }
        *(obj.caml_fl_merge) = edi;
        *(esi) = 0;
        if (*(obj.caml_allocation_policy) == 1) {
            edi = *((ebp - 0x10));
            edi++;
            esi = flp_size;
            if (edi < esi) {
                if (*((edi*4 + obj.flp)) != edx) {
                    goto label_0;
                }
                *((edi*4 + obj.flp)) = ecx;
                goto label_1;
            }
label_0:
            esi--;
            if (esi != *((ebp - 0x10))) {
                goto label_2;
            }
            edi = 0;
            if (ecx == 0x807ca48) {
                ecx = edi;
            }
            *(obj.beyond) = ecx;
            *(obj.flp_size) = esi;
        } else {
            *(obj.caml_fl_cur_size) -= eax;
            edi = ebx;
            edi -= eax;
            edi <<= 0xa;
            edi += 0x200;
            *(esi) = edi;
        }
label_2:
        if (*(obj.caml_allocation_policy) != 0) {
            goto label_1;
        }
        *(obj.fl_prev) = ecx;
    }
label_1:
    ebx -= eax;
    eax = edx + ebx*4;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806322b */
#include <stdint.h>
 
void truncate_flp (void) {
    if (eax != 0x807ca48) {
        edx = flp_size;
        if (edx <= 0) {
            goto label_0;
        }
        edx--;
        ecx = *((edx*4 + obj.flp));
        esi = flp;
        if (eax <= *(ecx)) {
            goto label_1;
        }
        goto label_0;
    }
    *(obj.flp_size) = 0;
    *(obj.beyond) = 0;
    goto label_2;
    do {
        edx = ecx;
label_1:
        if (edx <= 0) {
            goto label_3;
        }
        ecx = edx - 1;
        ebx = *((esi + ecx*4));
    } while (eax <= *(ebx));
    *(obj.flp_size) = edx;
    goto label_0;
label_3:
    *(obj.flp_size) = edx;
label_0:
    if (eax <= *(obj.beyond)) {
        *(obj.beyond) = 0;
    }
label_2:
    esi = ebx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063a10 */
#include <stdint.h>
 
int32_t clip_heap_chunk_size (void) {
    edx = 0x2000;
    if (eax <= 0x1fff) {
        eax = edx;
    }
    eax += 0xfff;
    eax &= 0xfffff000;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063b57 */
#include <stdint.h>
 
void start_cycle (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (1, "Starting new major GC cycle\n", 0);
    caml_darken_all_roots ();
    *(obj.caml_gc_phase) = 0;
    *(obj.caml_gc_subphase) = 0xa;
    *(obj.markhp) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80622f6 */
#include <stdint.h>
 
void caml_darken_all_roots (void) {
    caml_do_roots (sym.caml_darken);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80621d5 */
#include <stdint.h>
 
uint32_t caml_do_roots (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    edi = caml_globals;
    if (edi == 0) {
        goto label_3;
    }
    *((ebp - 0x1c)) = 0;
    goto label_4;
    do {
label_0:
        eax = edi + eax*4;
        eax = *(eax);
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (ebx < edx);
label_1:
    *((ebp - 0x1c))++;
    eax = *((ebp - 0x1c));
    edx = caml_globals;
    edi = *((edx + eax*4));
    if (edi == 0) {
        goto label_3;
    }
label_4:
    esi = edi - 4;
    edx = *(esi);
    edx >>= 0xa;
    eax = 0;
    ebx = 0;
    if (edx != 0) {
        goto label_0;
    }
    goto label_1;
label_3:
    eax = caml_dyn_globals;
    *((ebp - 0x1c)) = eax;
    if (eax == 0) {
        goto label_5;
    }
label_2:
    edx = *((ebp - 0x1c));
    edi = *(edx);
    esi = edi - 4;
    eax = *(esi);
    eax >>= 0xa;
    if (eax == 0) {
        goto label_6;
    }
    eax = 0;
    ebx = 0;
    do {
        eax = edi + eax*4;
        eax = *(eax);
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (edx > ebx);
label_6:
    eax = *((ebp - 0x1c));
    eax = *((eax + 4));
    *((ebp - 0x1c)) = eax;
    if (eax != 0) {
        goto label_2;
    }
label_5:
    if (*(obj.caml_frame_descriptors) == 0) {
        caml_init_frame_descriptors ();
    }
    eax = caml_local_roots;
    eax = caml_gc_regs;
    eax = caml_last_return_address;
    eax = caml_bottom_of_stack;
    edx = *((ebp + 8));
    caml_do_local_roots (eax, eax, eax);
    eax = *((ebp + 8));
    caml_scan_global_roots (eax);
    edx = *((ebp + 8));
    caml_final_do_strong_roots (edx);
    eax = caml_scan_roots_hook;
    if (eax != 0) {
        edx = *((ebp + 8));
        void (*eax)(uint32_t) (edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063b9e */
#include <stdint.h>
 
int32_t realloc_gray_vals (void) {
    char * size;
    int32_t var_8h;
    edx = gray_vals_size;
    eax = caml_stat_heap_size;
    ecx = eax + 0x7f;
    __asm ("cmovs eax, ecx");
    eax >>= 7;
    if (eax > edx) {
        edx <<= 2;
        edx >>= 9;
        caml_gc_message (8, "Growing gray_vals to %luk bytes\n", edx);
        eax = gray_vals_size;
        eax <<= 3;
        eax = gray_vals;
        eax = realloc (eax, eax);
        if (eax == 0) {
            caml_gc_message (8, "No room for growing gray_vals\n", 0);
            eax = gray_vals;
            *(obj.gray_vals_cur) = eax;
            *(obj.heap_is_pure) = 0;
        } else {
            *(obj.gray_vals) = eax;
        }
        edx = gray_vals_size;
        ecx = eax + edx*4;
        *(obj.gray_vals_cur) = ecx;
        ecx = edx + edx;
        *(obj.gray_vals_size) = ecx;
        eax = eax + edx*8;
        *(obj.gray_vals_end) = eax;
    } else {
        edx >>= 1;
        edx <<= 2;
        edx += *(obj.gray_vals);
        *(obj.gray_vals_cur) = edx;
        *(obj.heap_is_pure) = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063c73 */
#include <stdint.h>
 
int32_t mark_slice (void) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    uint32_t var_1ch;
    char * var_4h;
    int32_t var_8h;
    *((ebp - 0x24)) = eax;
    caml_gc_message (ebx, esi, edi);
    eax = caml_gc_subphase;
    caml_gc_message (0x40, "Subphase = %ld\n", eax);
    esi = gray_vals_cur;
    if (*((ebp - 0x24)) <= 0) {
        goto label_2;
    }
label_1:
    if (*(obj.gray_vals) >= esi) {
        goto label_3;
    }
    esi -= 4;
    edi = *(esi);
    edx = edi - 4;
    eax = *(edx);
    ecx = *(edx);
    ch |= 3;
    *(edx) = ecx;
    edx = eax;
    edx >>= 0xa;
    *((ebp - 0x1c)) = edx;
    if (al > 0xfa) {
        goto label_4;
    }
    if (edx == 0) {
        goto label_4;
    }
    ebx = 0;
    *((ebp - 0x34)) = esi;
    do {
        eax = *((edi + ebx*4));
        if ((al & 1) == 0) {
            esi = eax;
            ecx = eax;
            ecx >>= 0x17;
            edx = eax;
            edx >>= 0xc;
            edx &= 0x7ff;
            ecx = *((ecx*4 + obj.caml_page_table));
            if ((*((ecx + edx)) & 1) == 0) {
                goto label_5;
            }
            edx = *((eax - 4));
            ecx = (int32_t) dl;
            if (ecx == 0xfa) {
                ecx = *(eax);
                *((ebp - 0x20)) = ecx;
                if ((cl & 1) == 0) {
                    *((ebp - 0x2c)) = ecx;
                    esi = ecx;
                    esi >>= 0x17;
                    ecx >>= 0xc;
                    ecx &= 0x7ff;
                    esi = *((esi*4 + obj.caml_page_table));
                    if ((*((esi + ecx)) & 7) == 0) {
                        goto label_6;
                    }
                    ecx = *((ebp - 0x2c));
                    esi = *((ecx - 4));
                    ecx = esi;
                    if (cl == 0xfa) {
                        goto label_6;
                    }
                    if (cl == 0xf6) {
                        goto label_6;
                    }
                    if (cl == 0xfd) {
                        goto label_6;
                    }
                }
                esi = *((ebp - 0x20));
                *((edi + ebx*4)) = esi;
            } else {
                if (ecx != 0xf9) {
                    goto label_6;
                }
                edx >>= 0xa;
                eax = edx*4;
                esi -= eax;
                eax = esi;
                edx = *((esi - 4));
            }
label_6:
            if ((dh & 3) != 0) {
                goto label_5;
            }
            dh &= 0xfc;
            dh |= 1;
            *((eax - 4)) = edx;
            edx = *((ebp - 0x34));
            *(edx) = eax;
            edx += 4;
            *((ebp - 0x34)) = edx;
            if (edx < *(obj.gray_vals_end)) {
                goto label_5;
            }
            *(obj.gray_vals_cur) = edx;
            realloc_gray_vals ();
            ecx = gray_vals_cur;
            *((ebp - 0x34)) = ecx;
        }
label_5:
        ebx++;
    } while (*((ebp - 0x1c)) > ebx);
    esi = *((ebp - 0x34));
label_4:
    eax = *((ebp - 0x1c));
    eax = ~eax;
    *((ebp - 0x24)) += eax;
    goto label_7;
label_3:
    eax = markhp;
    if (eax != 0) {
        if (eax == *(obj.limit)) {
            eax = chunk;
            eax = *((eax - 4));
            *(obj.chunk) = eax;
            if (eax == 0) {
                *(obj.markhp) = 0;
                goto label_7;
            }
            *(obj.markhp) = eax;
            eax += *((eax - 8));
            *(obj.limit) = eax;
            goto label_7;
        }
        edx = *(eax);
        edx &= 0x300;
        if (edx == 0x100) {
            eax += 4;
            *(esi) = eax;
            esi += 4;
        }
        eax = markhp;
        edx = *(eax);
        edx >>= 0xa;
        eax = eax + edx*4 + 4;
        *(obj.markhp) = eax;
        goto label_7;
    }
    if (*(obj.heap_is_pure) == 0) {
        *(obj.heap_is_pure) = 1;
        eax = caml_heap_start;
        *(obj.chunk) = eax;
        *(obj.markhp) = eax;
        eax += *((eax - 8));
        *(obj.limit) = eax;
        goto label_7;
    }
    eax = caml_gc_subphase;
    if (eax != 0xb) {
        if (eax <= 0xb) {
            if (eax != 0xa) {
                goto label_7;
            }
        } else {
            if (eax == 0xc) {
                goto label_8;
            }
            if (eax != 0xd) {
                goto label_7;
            }
            goto label_9;
        }
        *(obj.caml_gc_subphase) = 0xb;
        *(obj.weak_prev) = 0x80833f4;
        goto label_7;
    }
    eax = weak_prev;
    eax = *(eax);
    *((ebp - 0x34)) = eax;
    if (eax == 0) {
        goto label_10;
    }
    *((ebp - 0x28)) = eax;
    eax = *((eax - 4));
    eax >>= 0xa;
    *((ebp - 0x30)) = eax;
    if (eax <= 1) {
        goto label_11;
    }
    *((ebp - 0x20)) = 1;
    *((ebp - 0x38)) = esi;
label_0:
    edx = *((ebp - 0x20));
    ecx = *((ebp - 0x28));
    eax = *((ecx + edx*4));
    edi = caml_weak_none;
    if (eax == edi) {
        goto label_12;
    }
    if ((al & 1) != 0) {
        goto label_12;
    }
    ecx = eax;
    ecx >>= 0x17;
    edx = eax;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 1) == 0) {
        goto label_12;
    }
    edx = eax - 4;
    if (*(edx) != 0xfa) {
        goto label_13;
    }
    eax = *(eax);
    if ((al & 1) == 0) {
        goto label_14;
    }
    goto label_13;
    do {
        if ((al & 1) != 0) {
            goto label_12;
        }
        ecx = *((esi*4 + obj.caml_page_table));
        if ((*((ecx + ebx)) & 1) == 0) {
            goto label_12;
        }
        esi = *((ebp - 0x1c));
        if (*(esi) != 0xfa) {
            goto label_13;
        }
        eax = *(eax);
        if ((al & 1) != 0) {
            goto label_13;
        }
label_14:
        *((ebp - 0x2c)) = edx;
        edx = eax;
        esi = eax;
        esi >>= 0x17;
        ebx = eax;
        ebx >>= 0xc;
        ebx &= 0x7ff;
        ecx = *((esi*4 + obj.caml_page_table));
        if ((*((ecx + ebx)) & 7) == 0) {
            goto label_15;
        }
        edx -= 4;
        *((ebp - 0x1c)) = edx;
        ecx = *(edx);
        if (cl == 0xfa) {
            goto label_15;
        }
        if (cl == 0xf6) {
            goto label_15;
        }
        if (cl == 0xfd) {
            goto label_15;
        }
        edi = *((ebp - 0x20));
        ecx = *((ebp - 0x28));
        *((ecx + edi*4)) = eax;
        edi = caml_weak_none;
    } while (eax != edi);
    goto label_12;
label_15:
    edx = *((ebp - 0x2c));
label_13:
    if ((*(edx) & 0x300) == 0) {
        esi = *((ebp - 0x20));
        eax = *((ebp - 0x28));
        *((eax + esi*4)) = edi;
    }
label_12:
    *((ebp - 0x20))++;
    edx = *((ebp - 0x30));
    if (*((ebp - 0x20)) != edx) {
        goto label_0;
    }
    esi = *((ebp - 0x38));
label_11:
    ecx = *((ebp - 0x34));
    *(obj.weak_prev) = ecx;
    eax = *((ebp - 0x30));
    eax = ~eax;
    *((ebp - 0x24)) += eax;
    goto label_7;
label_10:
    *(obj.caml_gc_subphase) = 0xc;
    *(obj.weak_prev) = 0x80833f4;
    goto label_7;
label_8:
    edx = weak_prev;
    eax = *(edx);
    if (eax != 0) {
        if ((*((eax - 4)) & 0x300) == 0) {
            eax = *(eax);
            *(edx) = eax;
        } else {
            *(obj.weak_prev) = eax;
        }
        *((ebp - 0x24))--;
    } else {
        *(obj.gray_vals_cur) = esi;
        caml_final_update ();
        esi = gray_vals_cur;
        *(obj.caml_gc_subphase) = 0xd;
        goto label_7;
label_9:
        *(obj.gray_vals_cur) = esi;
        eax = caml_heap_start;
        *(obj.caml_gc_sweep_hp) = eax;
        caml_fl_init_merge ();
        *(obj.caml_gc_phase) = 1;
        eax = caml_heap_start;
        *(obj.chunk) = eax;
        *(obj.caml_gc_sweep_hp) = eax;
        eax += *((eax - 8));
        *(obj.limit) = eax;
        eax = caml_fl_cur_size;
        *(obj.caml_fl_size_at_phase_change) = eax;
        goto label_2;
    }
label_7:
    if (*((ebp - 0x24)) > 0) {
        goto label_1;
    }
label_2:
    *(obj.gray_vals_cur) = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064150 */
#include <stdint.h>
 
int32_t sweep_slice (void) {
    char * var_4h;
    int32_t var_8h;
    esi = eax;
    caml_gc_message (ebx, esi, edi);
    if (esi <= 0) {
        goto label_0;
    }
    do {
        ebx = caml_gc_sweep_hp;
        if (ebx < *(obj.limit)) {
            ecx = ebx;
            eax = *(ebx);
            edx = *(ebx);
            edx >>= 0xa;
            edi = edx;
            edi = ~edi;
            esi += edi;
            edx = ebx + edx*4 + 4;
            *(obj.caml_gc_sweep_hp) = edx;
            edx = eax;
            edx &= 0x300;
            if (edx != 0) {
                if (edx != 0x200) {
                    goto label_1;
                }
            } else {
                if (al == 0xff) {
                    eax = *((ebx + 4));
                    eax = *((eax + 4));
                    if (eax == 0) {
                        goto label_2;
                    }
                    ecx += 4;
                    void (*eax)(uint32_t) (ecx);
                }
label_2:
                ebx += 4;
                eax = caml_fl_merge_block (ebx);
                *(obj.caml_gc_sweep_hp) = eax;
                goto label_3;
            }
            ebx += 4;
            *(obj.caml_fl_merge) = ebx;
            goto label_3;
label_1:
            ah &= 0xfc;
            *(ebx) = eax;
        } else {
            eax = chunk;
            eax = *((eax - 4));
            *(obj.chunk) = eax;
            if (eax == 0) {
                *(obj.caml_stat_major_collections)++;
                *(obj.caml_gc_phase) = 2;
                goto label_0;
            }
            *(obj.caml_gc_sweep_hp) = eax;
            eax += *((eax - 8));
            *(obj.limit) = eax;
        }
label_3:
    } while (esi > 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806457c */
#include <stdint.h>
 
void clear_table (void) {
    edx = *(eax);
    *((eax + 0xc)) = edx;
    edx = *((eax + 8));
    *((eax + 0x10)) = edx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80649b5 */
#include <stdint.h>
 
int32_t reset_table (void) {
    ebx = eax;
    *((eax + 0x14)) = 0;
    *((eax + 0x18)) = 0;
    eax = *(eax);
    if (eax != 0) {
        caml_stat_free (eax);
    }
    *((ebx + 4)) = 0;
    *((ebx + 0x10)) = 0;
    *((ebx + 8)) = 0;
    *((ebx + 0xc)) = 0;
    *(ebx) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064ce1 */
#include <stdint.h>
 
int32_t caml_stat_free (void * ptr) {
    eax = *((ebp + 8));
    free (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064f27 */
#include <stdint.h>
 
uint32_t caml_page_table_modify (void) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    size_t size;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = eax;
    edi = edx;
    *((ebp - 0x1c)) = ecx;
    esi = eax;
    esi >>= 0x17;
    if (*((esi*4 + obj.caml_page_table)) == 0x807fec0) {
        eax = calloc (0x800, 1);
        edx = eax;
        eax = 0xffffffff;
        if (edx == 0) {
            goto label_0;
        }
        *((esi*4 + obj.caml_page_table)) = edx;
    }
    ebx >>= 0xc;
    ebx &= 0x7ff;
    ebx += *((esi*4 + obj.caml_page_table));
    eax = edi;
    eax = ~eax;
    al &= *(ebx);
    al |= *((ebp - 0x1c));
    *(ebx) = al;
    eax = 0;
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049fd4 */
#include <stdint.h>
 
void calloc (void) {
    calloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065770 */
#include <stdint.h>
 
int32_t compare_free_stack (void) {
    eax = compare_stack;
    if (eax != obj.compare_stack_init) {
        free (eax);
        *(obj.compare_stack) = 0x80806c0;
        *(obj.compare_stack_limit) = 0x80812c0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80657a0 */
#include <stdint.h>
 
void compare_stack_overflow (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (4, "Stack overflow in structural comparison\n", 0);
    compare_free_stack ();
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80657cc */
#include <stdint.h>
 
int32_t compare_val (void) {
    int32_t var_3ch;
    size_t size;
    uint32_t var_34h;
    void * var_30h;
    int32_t var_2ch;
    uint32_t var_28h;
    uint32_t var_24h;
    int32_t var_20h;
    void * s1;
    char * s2;
    size_t n;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x24)) = ecx;
    ebx = compare_stack;
    do {
label_0:
        eax = *((ebp - 0x20));
        al = (*((ebp - 0x1c)) == eax) ? 1 : 0;
        if (*((ebp - 0x1c)) == eax) {
            if (*((ebp - 0x24)) != 0) {
                goto label_1;
            }
        }
        if ((*((ebp - 0x1c)) & 1) == 0) {
            goto label_2;
        }
        if (al != 0) {
            goto label_1;
        }
        if ((*((ebp - 0x20)) & 1) != 0) {
            eax = *((ebp - 0x1c));
            eax >>= 1;
            ecx = *((ebp - 0x20));
            ecx >>= 1;
            eax -= ecx;
            goto label_3;
        }
        ecx = *((ebp - 0x20));
        edx = *((ebp - 0x20));
        edx >>= 0x17;
        eax = ecx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 7) == 0) {
            goto label_4;
        }
        eax = *((ecx - 4));
        if (al != 0xfa) {
            if (al != 0xff) {
                goto label_4;
            }
        } else {
            edx = *((ebp - 0x20));
            edx = *(edx);
            *((ebp - 0x20)) = edx;
        } while (1);
    }
    ecx = *((ebp - 0x20));
    eax = *(ecx);
    eax = *((eax + 0x18));
    if (eax == 0) {
        goto label_4;
    }
    *(obj.caml_compare_unordered) = 0;
    edx = *((ebp - 0x1c));
    eax = void (*eax)(uint32_t, uint32_t) (edx, ecx);
    if (*(obj.caml_compare_unordered) != 0) {
        if (*((ebp - 0x24)) == 0) {
            goto label_5;
        }
    }
    if (eax == 0) {
        goto label_1;
    }
    goto label_3;
label_2:
    if ((*((ebp - 0x20)) & 1) != 0) {
        ecx = *((ebp - 0x1c));
        edx = *((ebp - 0x1c));
        edx >>= 0x17;
        eax = ecx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 7) == 0) {
            goto label_6;
        }
        eax = *((ecx - 4));
        if (al != 0xfa) {
            if (al != 0xff) {
                goto label_6;
            }
        } else {
            ecx = *((ebp - 0x1c));
            ecx = *(ecx);
            *((ebp - 0x1c)) = ecx;
            goto label_0;
        }
        edx = *((ebp - 0x1c));
        eax = *(edx);
        eax = *((eax + 0x18));
        if (eax == 0) {
            goto label_6;
        }
        *(obj.caml_compare_unordered) = 0;
        ecx = *((ebp - 0x20));
        eax = void (*eax)(uint32_t, uint32_t) (edx, ecx);
        if (*(obj.caml_compare_unordered) != 0) {
            if (*((ebp - 0x24)) == 0) {
                goto label_5;
            }
        }
        if (eax == 0) {
            goto label_1;
        }
        goto label_3;
    }
    edx = *((ebp - 0x1c));
    *((ebp - 0x28)) = edx;
    ecx = edx;
    ecx >>= 0x17;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 7) != 0) {
        ecx = *((ebp - 0x20));
        *((ebp - 0x2c)) = ecx;
        ecx >>= 0x17;
        edx = *((ebp - 0x20));
        edx >>= 0xc;
        edx &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
        if ((*((ecx + edx)) & 7) != 0) {
            goto label_7;
        }
    }
    if (al != 0) {
        goto label_1;
    }
    edx = *((ebp - 0x1c));
    edx >>= 1;
    eax = *((ebp - 0x20));
    eax >>= 1;
    edx -= eax;
    eax = edx;
    goto label_3;
label_7:
    edi = *((ebp - 0x28));
    edi -= 4;
    esi = *(edi);
    ecx = esi;
    edx = (int32_t) cl;
    ecx = *((ebp - 0x2c));
    ecx -= 4;
    *((ebp - 0x30)) = ecx;
    ecx = *(ecx);
    *((ebp - 0x34)) = cl;
    if (edx == 0xfa) {
        eax = *((ebp - 0x1c));
        eax = *(eax);
        *((ebp - 0x1c)) = eax;
        goto label_0;
    }
    ecx = *((ebp - 0x34));
    if (ecx == 0xfa) {
        edx = *((ebp - 0x20));
        edx = *(edx);
        *((ebp - 0x20)) = edx;
        goto label_0;
    }
    if (edx != ecx) {
        edx -= ecx;
        eax = edx;
        goto label_3;
    }
    edx = esi + 9;
    if (dl > 8) {
        goto label_8;
    }
    edx = (int32_t) dl;
    /* switch table (9 cases) at 0x807154c */
    if (al != 0) {
        goto label_1;
    }
    ecx = *((ebp - 0x1c));
    eax = caml_string_length (ecx);
    esi = eax;
    eax = *((ebp - 0x20));
    eax = caml_string_length (eax);
    edi = eax;
    eax = esi;
    if (eax <= esi) {
        eax = edi;
    }
    edx = *((ebp - 0x20));
    ecx = *((ebp - 0x1c));
    eax = memcmp (ecx, edx, eax);
    if (eax < 0) {
        goto label_4;
    }
    if (eax > 0) {
        goto label_6;
    }
    if (esi == edi) {
        goto label_1;
    }
    eax = esi;
    eax -= edi;
    goto label_3;
    eax = *((ebp - 0x1c));
    *(fp_stack--) = *(eax);
    edx = *((ebp - 0x20));
    *(fp_stack--) = *(edx);
    if (fp_stack[0] > fp_stack[1]) {
        goto label_9;
    }
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_10;
    }
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_11;
        }
    }
    if (*((ebp - 0x24)) == 0) {
        goto label_12;
    }
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_13;
        }
    }
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        goto label_1;
    }
    if (fp_stack[0] != fp_stack[0]) {
        goto label_4;
    }
    goto label_1;
    edx = *(edi);
    edx >>= 0xb;
    ecx = *((ebp - 0x30));
    eax = *(ecx);
    eax >>= 0xb;
    if (edx == eax) {
        if (edx == 0) {
            goto label_1;
        }
        eax = *((ebp - 0x28));
        *(fp_stack--) = *(eax);
        ecx = *((ebp - 0x2c));
        *(fp_stack--) = *(ecx);
        if (fp_stack[0] > fp_stack[1]) {
            goto label_14;
        }
        fp_tmp_1 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
        if (fp_stack[0] > fp_stack[1]) {
            goto label_15;
        }
        eax = 0;
        esi = *((ebp - 0x28));
        goto label_16;
    }
    edx -= eax;
    eax = edx;
    goto label_3;
    do {
        *(fp_stack--) = *((esi + eax*8));
        *(fp_stack--) = *((ecx + eax*8));
        if (fp_stack[0] > fp_stack[1]) {
            goto label_17;
        }
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
        if (fp_stack[0] > fp_stack[1]) {
            goto label_18;
        }
label_16:
        if (fp_stack[0] != fp_stack[1]) {
            if (fp_stack[0] == fp_stack[1]) {
                goto label_19;
            }
        }
        if (*((ebp - 0x24)) == 0) {
            goto label_20;
        }
        fp_stack--;
        if (fp_stack[0] != fp_stack[0]) {
            if (fp_stack[0] == fp_stack[0]) {
                goto label_21;
            }
        }
        fp_stack--;
        if (fp_stack[0] != fp_stack[0]) {
            if (fp_stack[0] == fp_stack[0]) {
                goto label_4;
            }
            goto label_22;
label_19:
            fp_stack++;
            fp_stack++;
        }
label_22:
        eax++;
    } while (edx > eax);
    goto label_1;
    compare_free_stack ();
    caml_invalid_argument ("equal: abstract value");
    compare_free_stack ();
    caml_invalid_argument ("equal: functional value");
    eax = *((ebp - 0x28));
    edx = *((eax + 4));
    edx >>= 1;
    ecx = *((ebp - 0x2c));
    eax = *((ecx + 4));
    eax >>= 1;
    if (edx != eax) {
        edx -= eax;
        eax = edx;
        goto label_3;
        eax = *((ebp - 0x1c));
        ecx = *(eax);
        edx = *((ebp - 0x20));
        eax = *(edx);
        edx = *((eax + 8));
        if (edx != *((ecx + 8))) {
            edx = *(ecx);
            eax = *(eax);
            eax = strcmp (edx, eax);
            if (eax >= 0) {
                goto label_6;
            }
            goto label_4;
        }
        if (edx == 0) {
            compare_free_stack ();
            caml_invalid_argument ("equal: abstract value");
        }
        *(obj.caml_compare_unordered) = 0;
        ecx = *((ebp - 0x20));
        eax = *((ebp - 0x1c));
        eax = void (*edx)(uint32_t, uint32_t) (eax, ecx);
        if (*(obj.caml_compare_unordered) != 0) {
            if (*((ebp - 0x24)) == 0) {
                goto label_5;
            }
        }
        if (eax == 0) {
            goto label_1;
        }
        goto label_3;
label_8:
        eax = *(edi);
        eax >>= 0xa;
        *((ebp - 0x34)) = eax;
        edx = *((ebp - 0x30));
        eax = *(edx);
        eax >>= 0xa;
        if (*((ebp - 0x34)) != eax) {
            ecx = *((ebp - 0x34));
            ecx -= eax;
            eax = ecx;
            goto label_3;
        }
        if (*((ebp - 0x34)) == 0) {
            goto label_1;
        }
        if (*((ebp - 0x34)) > 1) {
            ebx += 0xc;
            eax = compare_stack_limit;
            if (ebx >= eax) {
                edx = compare_stack;
                *((ebp - 0x3c)) = edx;
                eax -= edx;
                eax >>= 2;
                eax *= 0xaaaaaaab;
                eax += eax;
                *((ebp - 0x38)) = eax;
                if (eax > 0xfffff) {
                    eax = compare_stack_overflow ();
                }
                edx = compare_stack;
                if (edx == obj.compare_stack_init) {
                    eax = *((ebp - 0x38)) * 0xc;
                    eax = malloc (eax);
                    *((ebp - 0x30)) = eax;
                    if (eax == 0) {
                        eax = compare_stack_overflow ();
                    }
                    ecx = 0x300;
                    edi = *((ebp - 0x30));
                    esi = compare_stack_init;
                    *(es:edi) = *(esi);
                    ecx--;
                    esi += 4;
                    es:edi += 4;
                } else {
                    eax = *((ebp - 0x38)) * 0xc;
                    eax = realloc (edx, eax);
                    *((ebp - 0x30)) = eax;
                    if (eax != 0) {
                        goto label_23;
                    }
                    eax = compare_stack_overflow ();
                }
label_23:
                ecx = *((ebp - 0x30));
                *(obj.compare_stack) = ecx;
                eax = *((ebp - 0x38)) * 0xc;
                eax += ecx;
                *(obj.compare_stack_limit) = eax;
                ebx -= *((ebp - 0x3c));
                ebx &= 0xfffffffc;
                ebx += ecx;
            }
            eax = *((ebp - 0x28));
            eax += 4;
            *(ebx) = eax;
            eax = *((ebp - 0x2c));
            eax += 4;
            *((ebx + 4)) = eax;
            eax = *((ebp - 0x34));
            eax--;
            *((ebx + 8)) = eax;
        }
        eax = *((ebp - 0x1c));
        eax = *(eax);
        *((ebp - 0x1c)) = eax;
        edx = *((ebp - 0x20));
        edx = *(edx);
        *((ebp - 0x20)) = edx;
        goto label_0;
label_11:
        fp_stack++;
        fp_stack++;
    }
label_1:
    if (ebx == *(obj.compare_stack)) {
        eax = 0;
    } else {
        eax = *(ebx);
        ecx = *(eax);
        *((ebp - 0x1c)) = ecx;
        eax += 4;
        *(ebx) = eax;
        eax = *((ebx + 4));
        edx = *(eax);
        *((ebp - 0x20)) = edx;
        eax += 4;
        *((ebx + 4)) = eax;
        eax = *((ebx + 8));
        eax--;
        *((ebx + 8)) = eax;
        edx = ebx - 0xc;
        if (eax == 0) {
            ebx = edx;
        }
        goto label_0;
label_12:
        fp_stack++;
        fp_stack++;
        goto label_5;
label_20:
        fp_stack++;
        fp_stack++;
label_5:
        eax = 0x80000000;
        goto label_3;
label_9:
        fp_stack++;
        fp_stack++;
        goto label_4;
label_14:
        fp_stack++;
        fp_stack++;
        goto label_4;
label_17:
        fp_stack++;
        fp_stack++;
label_4:
        eax = 0xffffffff;
        goto label_3;
label_10:
        fp_stack++;
        fp_stack++;
        goto label_6;
label_13:
        fp_stack++;
        goto label_6;
label_15:
        fp_stack++;
        fp_stack++;
        goto label_6;
label_18:
        fp_stack++;
        fp_stack++;
        goto label_6;
label_21:
        fp_stack++;
label_6:
        eax = 1;
    }
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065f80 */
#include <stdint.h>
 
int32_t parse_sign_and_base (void) {
    *(ecx) = 1;
    if (*(eax) == 0x2d) {
        *(ecx) = 0xffffffff;
        eax++;
    }
    *(edx) = 0xa;
    if (*(eax) == 0x30) {
        ecx = *((eax + 1));
        ecx -= 0x42;
        if (cl > 0x36) {
            goto label_0;
        }
        ecx = (int32_t) cl;
        /* switch table (55 cases) at 0x8071570 */
        *(edx) = 0x10;
        eax += 2;
        goto label_0;
        *(edx) = 8;
        eax += 2;
        goto label_0;
        *(edx) = 2;
        eax += 2;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065fd9 */
#include <stdint.h>
 
uint32_t parse_digit (void) {
    edx = eax;
    ecx = edx - 0x30;
    if (cl <= 9) {
        edx = (int32_t) al;
        eax = edx - 0x30;
    } else {
        ecx = eax - 0x41;
        if (cl <= 5) {
            edx = (int32_t) al;
            eax = edx - 0x37;
        } else {
            ecx = eax - 0x61;
            eax = 0xffffffff;
            if (cl > 5) {
                goto label_0;
            }
            eax = (int32_t) dl;
            eax -= 0x57;
        }
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066036 */
#include <stdint.h>
 
int32_t int32_cmp (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    eax = *((ebp + 0xc));
    edx = *((eax + 4));
    al = (ecx > edx) ? 1 : 0;
    eax = (int32_t) al;
    dl = (ecx < edx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066059 */
#include <stdint.h>
 
int32_t int32_hash (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806609c */
#include <stdint.h>
 
int32_t int64_cmp (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    esi = *((edx + 4));
    ecx = *((edx + 8));
    edi = *((eax + 4));
    edx = *((eax + 8));
    eax = 1;
    if (ecx <= edx) {
        if (ecx >= edx) {
            if (esi > edi) {
                goto label_0;
            }
        }
        eax = 0;
    }
label_0:
    ebx = 1;
    if (ecx >= edx) {
        if (ecx <= edx) {
            if (esi < edi) {
                goto label_1;
            }
        }
        ebx = 0;
    }
label_1:
    eax -= ebx;
    ebx = *(esp);
    esi = *((esp + 4));
    edi = *((esp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80660f8 */
#include <stdint.h>
 
int32_t int64_hash (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066172 */
#include <stdint.h>
 
int32_t nativeint_cmp (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    eax = *((ebp + 0xc));
    edx = *((eax + 4));
    al = (ecx > edx) ? 1 : 0;
    eax = (int32_t) al;
    dl = (ecx < edx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066195 */
#include <stdint.h>
 
int32_t nativeint_hash (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80661d8 */
#include <stdint.h>
 
uint32_t int32_deserialize (int32_t arg_8h) {
    eax = caml_deserialize_sint_4 ();
    edx = *((ebp + 8));
    *(edx) = eax;
    eax = 4;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a81e */
#include <stdint.h>
 
uint32_t caml_deserialize_sint_4 (void) {
    ecx = intern_src;
    edx = ecx + 4;
    *(obj.intern_src) = edx;
    ebx = *((edx - 1));
    eax = *(ecx);
    eax <<= 0x18;
    eax = ebx + eax;
    ecx = *((edx - 3));
    ecx <<= 0x10;
    eax += ecx;
    edx = *((edx - 2));
    edx <<= 8;
    eax += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80661ef */
#include <stdint.h>
 
uint32_t nativeint_deserialize (int32_t arg_8h) {
    eax = caml_deserialize_uint_1 ();
    if (eax != 1) {
        if (eax != 2) {
            goto label_0;
        }
    } else {
        eax = caml_deserialize_sint_4 ();
        edx = *((ebp + 8));
        *(edx) = eax;
        goto label_1;
    }
    caml_deserialize_error (0x807164c);
label_0:
    caml_deserialize_error ("input_value: ill-formed native integer");
label_1:
    eax = 4;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066233 */
#include <stdint.h>
 
int32_t nativeint_serialize (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    caml_serialize_int_1 (ebx);
    caml_serialize_int_4 (ebx);
    eax = *((ebp + 0xc));
    *(eax) = 4;
    eax = *((ebp + 0x10));
    *(eax) = 8;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069c64 */
#include <stdint.h>
 
int32_t caml_serialize_int_1 (int32_t arg_8h) {
    eax = extern_ptr;
    eax++;
    if (*(obj.extern_limit) < eax) {
        eax = 1;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = *((ebp + 8));
    *(eax) = dl;
    eax++;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80698c6 */
#include <stdint.h>
 
uint32_t grow_extern_output (void) {
    if (*(obj.extern_userprovided_output) != 0) {
        extern_replay_trail ();
        eax = caml_failwith ("Marshal.to_buffer: buffer overflow");
    }
    ecx = extern_ptr;
    edx = extern_output_block;
    *((edx + 4)) = ecx;
    esi = 0;
    if (eax >= 0xfd3) {
        esi = eax;
    }
    eax = esi + 0x1fac;
    eax = malloc (eax);
    ebx = eax;
    if (eax == 0) {
        extern_out_of_memory ();
    }
    eax = extern_output_block;
    *(eax) = ebx;
    *(obj.extern_output_block) = ebx;
    *(ebx) = 0;
    eax = ebx + 8;
    *(obj.extern_ptr) = eax;
    eax = ebx + esi + 0x1fac;
    *(obj.extern_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069bd2 */
#include <stdint.h>
 
int32_t caml_serialize_int_4 (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = extern_ptr;
    eax += 4;
    if (*(obj.extern_limit) < eax) {
        eax = 4;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = ebx;
    edx >>= 0x18;
    *(eax) = dl;
    edx = ebx;
    edx >>= 0x10;
    *((eax + 1)) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 2)) = dl;
    *((eax + 3)) = bl;
    eax += 4;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806626c */
#include <stdint.h>
 
int32_t int32_serialize (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_serialize_int_4 (eax);
    eax = *((ebp + 0x10));
    *(eax) = 4;
    eax = *((ebp + 0xc));
    *(eax) = 4;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066294 */
#include <stdint.h>
 
uint32_t int64_deserialize (int32_t arg_8h) {
    eax = caml_deserialize_sint_8 (ebx);
    ecx = eax;
    ebx = edx;
    edx = *((ebp + 8));
    *(edx) = ecx;
    *((edx + 4)) = ebx;
    eax = 8;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a9b4 */
#include <stdint.h>
 
uint32_t caml_deserialize_sint_8 (void) {
    int32_t var_8h;
    int32_t var_bp_4h;
    int32_t var_4h;
    eax = ebp - 8;
    caml_deserialize_block_8 (eax, 1);
    eax = *((ebp - 8));
    edx = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a92c */
#include <stdint.h>
 
int32_t caml_deserialize_block_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_14h;
    int32_t var_10h;
    edi = intern_src;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    edx = *((ebp + 8));
    eax = edi;
    ecx = *((ebp + 0xc));
    *((ebp - 0x14)) = ecx;
    *((ebp - 0x10)) = edi;
    do {
        esi = *(eax);
        ebx = *((eax + 1));
        edi = *((eax + 7));
        ecx = edi;
        *(edx) = cl;
        edi = *((eax + 6));
        ecx = edi;
        *((edx + 1)) = cl;
        ecx = esi;
        *((edx + 7)) = cl;
        *((edx + 6)) = bl;
        esi = *((eax + 2));
        ebx = *((eax + 3));
        edi = *((eax + 5));
        ecx = edi;
        *((edx + 2)) = cl;
        edi = *((eax + 4));
        ecx = edi;
        *((edx + 3)) = cl;
        ecx = esi;
        *((edx + 5)) = cl;
        *((edx + 4)) = bl;
        eax += 8;
        edx += 8;
        *((ebp - 0x14))--;
    } while (*((ebp - 0x14)) != 0);
    edi = *((ebp - 0x10));
    eax = *((ebp + 0xc));
    edi = edi + eax*8;
label_0:
    *(obj.intern_src) = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80662b7 */
#include <stdint.h>
 
int32_t int64_serialize (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    caml_serialize_int_8 (eax, edx);
    eax = *((ebp + 0x10));
    *(eax) = 8;
    eax = *((ebp + 0xc));
    *(eax) = 8;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069a5d */
#include <stdint.h>
 
int32_t caml_serialize_int_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    eax = *((ebp + 8));
    *((ebp - 0x10)) = eax;
    eax = *((ebp + 0xc));
    *((ebp - 0xc)) = eax;
    eax = ebp - 0x10;
    caml_serialize_block_8 (eax, 1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80699ba */
#include <stdint.h>
 
int32_t caml_serialize_block_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_2ch;
    int32_t var_1ch;
    eax = *((ebp + 0xc));
    eax <<= 3;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    edi = extern_ptr;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    edx = *((ebp + 8));
    eax = edi;
    ecx = *((ebp + 0xc));
    *((ebp - 0x2c)) = ecx;
    *((ebp - 0x1c)) = edi;
    do {
        esi = *(edx);
        ebx = *((edx + 1));
        edi = *((edx + 7));
        ecx = edi;
        *(eax) = cl;
        edi = *((edx + 6));
        ecx = edi;
        *((eax + 1)) = cl;
        ecx = esi;
        *((eax + 7)) = cl;
        *((eax + 6)) = bl;
        esi = *((edx + 2));
        ebx = *((edx + 3));
        edi = *((edx + 5));
        ecx = edi;
        *((eax + 2)) = cl;
        edi = *((edx + 4));
        ecx = edi;
        *((eax + 3)) = cl;
        ecx = esi;
        *((eax + 5)) = cl;
        *((eax + 4)) = bl;
        edx += 8;
        eax += 8;
        *((ebp - 0x2c))--;
    } while (*((ebp - 0x2c)) != 0);
    edi = *((ebp - 0x1c));
    eax = *((ebp + 0xc));
    edi = edi + eax*8;
label_0:
    *(obj.extern_ptr) = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80662e6 */
#include <stdint.h>
 
uint32_t parse_intnat (void) {
    uint32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    uint32_t var_2ch;
    uint32_t var_20h;
    int32_t var_1ch;
    *((ebp - 0x34)) = eax;
    *((ebp - 0x38)) = edx;
    ecx = ebp - 0x1c;
    edx = ebp - 0x20;
    eax = parse_sign_and_base (ebx, esi, edi);
    ebx = eax;
    edi = *((ebp - 0x20));
    *((ebp - 0x30)) = edi;
    eax = 0xffffffff;
    edx = 0;
    eax = edx:eax / edi;
    edx = edx:eax % edi;
    *((ebp - 0x2c)) = eax;
    eax = *(ebx);
    eax = parse_digit ();
    if (eax >= 0) {
        if (edi > eax) {
            goto label_0;
        }
    }
    eax = caml_failwith ("int_of_string");
label_0:
    ebx++;
    esi = eax;
    do {
        eax = *(ebx);
        if (al != 0x5f) {
            eax = (int32_t) al;
            eax = parse_digit ();
            if (eax < 0) {
                goto label_1;
            }
            if (edi <= eax) {
                goto label_1;
            }
            if (esi > *((ebp - 0x2c))) {
                caml_failwith ("int_of_string");
            }
            esi *= *((ebp - 0x30));
            esi += eax;
            if (esi >= 0) {
                goto label_2;
            }
            caml_failwith ("int_of_string");
        }
label_2:
        ebx++;
    } while (1);
label_1:
    eax = *((ebp - 0x34));
    eax = caml_string_length (eax);
    eax += *((ebp - 0x34));
    if (ebx != eax) {
        caml_failwith ("int_of_string");
    }
    if (*((ebp - 0x20)) == 0xa) {
        if (*((ebp - 0x1c)) >= 0) {
            ecx = *((ebp - 0x38));
            ecx--;
            eax = 1;
            eax <<= cl;
            if (eax > esi) {
                goto label_3;
            }
            caml_failwith ("int_of_string");
        }
        ecx = *((ebp - 0x38));
        ecx--;
        eax = 1;
        eax <<= cl;
        if (eax >= esi) {
            goto label_4;
        }
        caml_failwith ("int_of_string");
    }
    if (*((ebp - 0x38)) <= 0x1f) {
        eax = 1;
        ecx = *((ebp - 0x38));
        eax <<= cl;
        if (eax > esi) {
            goto label_5;
        }
        caml_failwith ("int_of_string");
    }
label_5:
    if (*((ebp - 0x1c)) < 0) {
label_4:
        eax = esi;
        eax = -eax;
    } else {
label_3:
        eax = esi;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806642d */
#include <stdint.h>
 
uint32_t parse_format (int32_t arg_8h, int32_t arg_ch) {
    void * s1;
    int32_t var_20h;
    int32_t var_1ch;
    char * * endptr;
    size_t base;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x20)) = edx;
    *((ebp - 0x24)) = ecx;
    eax = caml_string_length (ebx, esi, edi);
    ebx = eax;
    edi = *((ebp - 0x20));
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    esi = ecx - 1;
    eax = esi + ebx + 1;
    if (eax > 0x1f) {
        caml_invalid_argument ("format_int: format too long");
    }
    eax = *((ebp - 0x1c));
    edx = *((ebp - 0x24));
    memmove (edx, eax, ebx);
    ecx = *((ebp - 0x24));
    ebx = ecx + ebx - 1;
    edi = *(ebx);
    edx = ebx - 1;
    eax = *(edx);
    if (al != 0x6c) {
        if (al == 0x6e) {
            goto label_0;
        }
        if (al != 0x4c) {
            goto label_1;
        }
    }
label_0:
    ebx = edx;
label_1:
    eax = *((ebp - 0x20));
    memmove (ebx, eax, esi);
    ebx += esi;
    edx = edi;
    *(ebx) = dl;
    *((ebx + 1)) = 0;
    eax = *((ebp - 0x1c));
    edx = *(eax);
    if (dl == 0) {
        goto label_2;
    }
    edx -= 0x30;
    if (dl > 9) {
        goto label_3;
    }
    while (dl != 0) {
        edx -= 0x30;
        if (dl <= 9) {
            eax = strtol (eax, 0, 0xa);
            eax += 5;
            ecx = edi;
            edx = *((ebp + 0xc));
            *(edx) = cl;
            if (eax > 0x1f) {
                goto label_4;
            }
            goto label_5;
        }
label_3:
        eax++;
        edx = *(eax);
    }
    goto label_2;
label_4:
    eax++;
    eax = caml_stat_alloc (eax);
    *((ebp + 8)) = eax;
    do {
label_5:
        eax = *((ebp + 8));
        return eax;
label_2:
        ecx = edi;
        eax = *((ebp + 0xc));
        *(eax) = cl;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068410 */
#include <stdint.h>
 
int32_t unlink_channel (void) {
    edx = *((eax + 0x20));
    if (edx == 0) {
        eax = caml_all_opened_channels;
        eax = *((eax + 0x1c));
        *(obj.caml_all_opened_channels) = eax;
        if (eax == 0) {
            goto label_0;
        }
        *((eax + 0x20)) = 0;
    } else {
        ecx = *((eax + 0x1c));
        *((edx + 0x1c)) = ecx;
        edx = *((eax + 0x1c));
        if (edx == 0) {
            goto label_0;
        }
        eax = *((eax + 0x20));
        *((edx + 0x20)) = eax;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80684a6 */
#include <stdint.h>
 
int32_t compare_channel (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    eax = *((ebp + 0xc));
    edx = *((eax + 4));
    eax = 0;
    if (ecx != edx) {
        eax -= eax;
        eax |= 1;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068fbc */
#include <stdint.h>
 
int32_t do_write (void) {
    int32_t var_1ch;
    char * ptr;
    size_t nbytes;
    edi = eax;
    *((ebp - 0x1c)) = edx;
    esi = ecx;
    do {
label_0:
        caml_enter_blocking_section (ebx, esi, edi);
        eax = *((ebp - 0x1c));
        eax = write (edi, eax, esi);
        ebx = eax;
        caml_leave_blocking_section ();
        if (ebx != -1) {
            goto label_1;
        }
        eax = errno_location ();
        eax = *(eax);
    } while (eax == 4);
    if (eax == 0xb) {
        if (esi <= 1) {
            goto label_2;
        }
        esi = 1;
        goto label_0;
    }
label_2:
    caml_sys_io_error (1);
label_1:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80697f0 */
#include <stdint.h>
 
int32_t extern_replay_trail (void) {
    void ** ptr;
    eax = extern_trail_block;
    *((ebp - 0x1c)) = eax;
    edi = extern_trail_cur;
label_0:
    eax = *((ebp - 0x1c));
    eax += 4;
    if (edi <= eax) {
        goto label_1;
    }
    do {
        ebx = *(eax);
        edx = *(eax);
        edx &= 0xfffffffc;
        ecx = edx - 4;
        esi = *(ecx);
        esi &= 0xfffffcff;
        ebx &= 3;
        ebx <<= 8;
        ebx |= esi;
        *(ecx) = ebx;
        ecx = *((eax + 4));
        *(edx) = ecx;
        eax += 8;
    } while (edi > eax);
label_1:
    if (*((ebp - 0x1c)) != obj.extern_trail_first) {
        eax = *((ebp - 0x1c));
        ebx = *(eax);
        free (eax);
        edi = ebx + 0x200c;
        *((ebp - 0x1c)) = ebx;
        goto label_0;
    }
    *(obj.extern_trail_block) = 0x8081300;
    *(obj.extern_trail_cur) = 0x8081304;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069876 */
#include <stdint.h>
 
int32_t free_extern_output (void) {
    if (*(obj.extern_userprovided_output) != 0) {
        goto label_0;
    }
    eax = extern_output_first;
    if (eax == 0) {
        goto label_1;
    }
    do {
        ebx = *(eax);
        free (eax);
        if (ebx == 0) {
            goto label_1;
        }
        eax = ebx;
    } while (1);
label_1:
    *(obj.extern_output_first) = 0;
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80698b1 */
#include <stdint.h>
 
void extern_out_of_memory (void) {
    extern_replay_trail ();
    free_extern_output ();
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069c98 */
#include <stdint.h>
 
int32_t writecode16 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = eax;
    ebx = edx;
    eax = extern_ptr;
    eax += 3;
    if (*(obj.extern_limit) < eax) {
        eax = 3;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = esi;
    *(eax) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 1)) = dl;
    *((eax + 2)) = bl;
    eax += 3;
    *(obj.extern_ptr) = eax;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069cea */
#include <stdint.h>
 
int32_t writecode8 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    ebx = eax;
    esi = edx;
    eax = extern_ptr;
    eax += 2;
    if (*(obj.extern_limit) < eax) {
        eax = 2;
        grow_extern_output ();
    }
    eax = extern_ptr;
    *(eax) = bl;
    edx = esi;
    *((eax + 1)) = dl;
    eax += 2;
    *(obj.extern_ptr) = eax;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069d34 */
#include <stdint.h>
 
int32_t writecode32 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = eax;
    ebx = edx;
    eax = extern_ptr;
    eax += 5;
    if (*(obj.extern_limit) < eax) {
        eax = 5;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = esi;
    *(eax) = dl;
    edx = ebx;
    edx >>= 0x18;
    *((eax + 1)) = dl;
    edx = ebx;
    edx >>= 0x10;
    *((eax + 2)) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 3)) = dl;
    *((eax + 4)) = bl;
    eax += 5;
    *(obj.extern_ptr) = eax;
    ebx = *(esp);
    esi = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069d96 */
#include <stdint.h>
 
int32_t writeblock (void) {
    int32_t var_8h;
    int32_t var_4h;
    void ** s2;
    size_t * n;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = eax;
    ebx = edx;
    eax = edx;
    eax += *(obj.extern_ptr);
    if (*(obj.extern_limit) < eax) {
        eax = edx;
        grow_extern_output ();
    }
    eax = extern_ptr;
    memmove (eax, esi, ebx);
    *(obj.extern_ptr) += ebx;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069de2 */
#include <stdint.h>
 
int32_t write32 (void) {
    ebx = eax;
    eax = extern_ptr;
    eax += 4;
    if (*(obj.extern_limit) < eax) {
        eax = 4;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = ebx;
    edx >>= 0x18;
    *(eax) = dl;
    edx = ebx;
    edx >>= 0x10;
    *((eax + 1)) = dl;
    edx = ebx;
    edx >>= 8;
    *((eax + 2)) = dl;
    *((eax + 3)) = bl;
    eax += 4;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069e32 */
#include <stdint.h>
 
int32_t extern_record_location (void) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = eax;
    if (*(obj.extern_ignore_sharing) == 0) {
        eax = extern_trail_cur;
        if (eax == *(obj.extern_trail_limit)) {
            eax = malloc (0x200c);
            esi = eax;
            if (eax == 0) {
                extern_out_of_memory ();
            }
            eax = extern_trail_block;
            *(esi) = eax;
            *(obj.extern_trail_block) = esi;
            eax = esi + 4;
            *(obj.extern_trail_cur) = eax;
            esi += 0x200c;
            *(obj.extern_trail_limit) = esi;
        }
        edx = ebx - 4;
        ecx = *(edx);
        eax = extern_trail_cur;
        esi = ecx;
        esi >>= 8;
        esi &= 3;
        esi |= ebx;
        *(eax) = esi;
        esi = *(ebx);
        *((eax + 4)) = esi;
        eax += 8;
        *(obj.extern_trail_cur) = eax;
        ch &= 0xfc;
        ch |= 2;
        *(edx) = ecx;
        eax = obj_counter;
        *(ebx) = eax;
        eax++;
        *(obj.obj_counter) = eax;
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069ed2 */
#include <stdint.h>
 
uint32_t init_extern_output (void) {
    *(obj.extern_userprovided_output) = 0;
    eax = malloc (0x1fac);
    *(obj.extern_output_first) = eax;
    if (eax == 0) {
        eax = caml_raise_out_of_memory ();
    }
    *(obj.extern_output_block) = eax;
    *(eax) = 0;
    edx = eax + 8;
    *(obj.extern_ptr) = edx;
    eax += 0x1fac;
    *(obj.extern_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069f1c */
#include <stdint.h>
 
void extern_invalid_argument (void) {
    ebx = eax;
    extern_replay_trail (ebx);
    free_extern_output ();
    return caml_invalid_argument (ebx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069f37 */
#include <stdint.h>
 
int32_t extern_rec (void) {
    int32_t var_4ch;
    int32_t var_30h;
    uint32_t var_2ch;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
label_1:
    ebx = eax;
    while ((al & 1) != 0) {
label_0:
        ebx = *((ebp - 0x4c));
label_2:
        if ((bl & 1) != 0) {
            ebx >>= 1;
            eax = ebx;
            if (ebx <= 0x3f) {
                eax = extern_ptr;
                if (eax >= *(obj.extern_limit)) {
                    eax = 1;
                    grow_extern_output ();
                }
                eax = extern_ptr;
                ebx += 0x40;
                *(eax) = bl;
                eax++;
                *(obj.extern_ptr) = eax;
                goto label_3;
            }
            edx = ebx + 0x80;
            if (edx <= 0xff) {
                edx = ebx;
                eax = 0;
                eax = writecode8 ();
                goto label_3;
            }
            eax += 0x8000;
            if (eax <= 0xffff) {
                edx = ebx;
                eax = 1;
                writecode16 ();
                goto label_3;
            }
            edx = ebx;
            eax = 2;
            writecode32 ();
            goto label_3;
        }
        esi = ebx;
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 7) == 0) {
            goto label_4;
        }
        edx = *((ebx - 4));
        edi = (int32_t) dl;
        if (edi != 0xfa) {
            goto label_5;
        }
        eax = *(ebx);
        *((ebp - 0x4c)) = eax;
    }
    *((ebp - 0x30)) = eax;
    eax >>= 0x17;
    ecx = *((ebp - 0x4c));
    ecx >>= 0xc;
    ecx &= 0x7ff;
    eax = *((eax*4 + obj.caml_page_table));
    if ((*((eax + ecx)) & 7) == 0) {
        goto label_5;
    }
    eax = *((ebp - 0x30));
    eax = *((eax - 4));
    *((ebp - 0x2c)) = al;
    if (al == 0xfa) {
        goto label_5;
    }
    if (al == 0xf6) {
        goto label_5;
    }
    if (al != 0xfd) {
        goto label_0;
    }
label_5:
    ecx = edx;
    ecx >>= 0xa;
    *((ebp - 0x2c)) = ecx;
    if (ecx == 0) {
        if (edi <= 0xf) {
            eax = extern_ptr;
            if (eax >= *(obj.extern_limit)) {
                eax = 1;
                grow_extern_output ();
            }
            eax = extern_ptr;
            edx = edi - 0x80;
            *(eax) = dl;
            eax++;
            *(obj.extern_ptr) = eax;
            goto label_3;
        }
        eax = 8;
        writecode32 ();
        goto label_3;
    }
    eax = edx;
    eax &= 0x300;
    if (eax == 0x200) {
        edx = obj_counter;
        edx -= *(ebx);
        if (edx <= 0xff) {
            ax = 4;
            writecode8 ();
            goto label_3;
        }
        if (edx <= 0xffff) {
            eax = 5;
            writecode16 ();
            goto label_3;
        }
        eax = 6;
        writecode32 ();
        goto label_3;
    }
    eax = edi - 0xf9;
    if (eax <= 6) {
        /* switch table (7 cases) at 0x807184c */
        eax = caml_string_length (ebx);
        esi = eax;
        if (eax <= 0x1f) {
            eax = extern_ptr;
            if (eax >= *(obj.extern_limit)) {
                eax = 1;
                grow_extern_output ();
            }
            eax = extern_ptr;
            edx = esi + 0x20;
            *(eax) = dl;
            eax++;
            *(obj.extern_ptr) = eax;
        } else {
            if (eax <= 0xff) {
                edx = eax;
                eax = 9;
                eax = writecode8 ();
            } else {
                edx = eax;
                eax = 0xa;
                writecode32 ();
            }
        }
        edx = esi;
        eax = ebx;
        writeblock ();
        eax = esi + 4;
        eax >>= 2;
        edx = size_32;
        eax = edx + eax + 1;
        *(obj.size_32) = eax;
        esi += 8;
        esi >>= 3;
        eax = size_64;
        eax = eax + esi + 1;
        *(obj.size_64) = eax;
        eax = ebx;
        extern_record_location ();
        goto label_3;
        eax = extern_ptr;
        if (eax >= *(obj.extern_limit)) {
            eax = 1;
            grow_extern_output ();
        }
        eax = extern_ptr;
        *(eax) = 0xc;
        eax++;
        *(obj.extern_ptr) = eax;
        edx = 8;
        eax = ebx;
        writeblock ();
        *(obj.size_32) += 3;
        *(obj.size_64) += 2;
        eax = ebx;
        extern_record_location ();
        goto label_3;
        esi = *((ebp - 0x2c));
        esi >>= 1;
        if (esi <= 0xff) {
            edx = esi;
            eax = 0xe;
            writecode8 ();
        } else {
            edx = esi;
            eax = 7;
            writecode32 ();
        }
        edx = esi*8;
        eax = ebx;
        writeblock ();
        eax = size_32;
        eax = eax + esi*2 + 1;
        *(obj.size_32) = eax;
        eax = size_64;
        eax = esi + eax + 1;
        *(obj.size_64) = eax;
        eax = ebx;
        extern_record_location ();
        goto label_3;
        eax = "output_value: abstract value (Abstract)";
        extern_invalid_argument ();
        ebx = *((ebp - 0x2c));
        ebx <<= 2;
        edx = ebx;
        eax = 0x11;
        writecode32 ();
        eax = esi;
        eax -= ebx;
        extern_rec ();
        goto label_1;
        goto label_3;
        *((ebp - 0x2c)) = ebx;
        eax = *(ebx);
        esi = *(eax);
        if (*((eax + 0x10)) == 0) {
            eax = "output_value: abstract value (Custom)";
            extern_invalid_argument ();
        }
        eax = extern_ptr;
        if (eax >= *(obj.extern_limit)) {
            eax = 1;
            grow_extern_output ();
        }
        eax = extern_ptr;
        *(eax) = 0x12;
        eax++;
        *(obj.extern_ptr) = eax;
        edi = esi;
        eax = 0;
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        edx = ecx;
        edx = ~edx;
        eax = esi;
        writeblock ();
        edx = *((ebp - 0x2c));
        eax = *(edx);
        edx = ebp - 0x20;
        edx = ebp - 0x1c;
        uint32_t (*eax + 0x10)(uint32_t, uint32_t, uint32_t) (ebx, edx, edx);
        eax = *((ebp - 0x1c));
        eax += 3;
        eax >>= 2;
        edx = size_32;
        eax = edx + eax + 2;
        *(obj.size_32) = eax;
        eax = *((ebp - 0x20));
        eax += 7;
        eax >>= 3;
        edx = size_64;
        eax = edx + eax + 2;
        *(obj.size_64) = eax;
        eax = ebx;
        extern_record_location ();
        goto label_3;
    }
    if (edi <= 0xf) {
        if (*((ebp - 0x2c)) <= 7) {
            eax = extern_ptr;
            if (eax >= *(obj.extern_limit)) {
                eax = 1;
                grow_extern_output ();
            }
            eax = extern_ptr;
            edx = *((ebp - 0x2c));
            edx <<= 4;
            edx = edx + edi - 0x80;
            *(eax) = dl;
            eax++;
            *(obj.extern_ptr) = eax;
        }
    } else {
        dh &= 0xfc;
        eax = 8;
        writecode32 ();
    }
    eax = size_32;
    ecx = *((ebp - 0x2c));
    eax = ecx + eax + 1;
    *(obj.size_32) = eax;
    eax = size_64;
    eax = ecx + eax + 1;
    *(obj.size_64) = eax;
    edi = *(ebx);
    eax = ebx;
    extern_record_location ();
    ebx = edi;
    if (*((ebp - 0x2c)) == 1) {
        goto label_2;
    }
    eax = edi;
    extern_rec ();
    goto label_1;
    edi = *((ebp - 0x2c));
    edi--;
    ebx = 1;
    if (edi > 1) {
        goto label_6;
    }
    edi = 1;
    goto label_7;
    do {
label_6:
        eax = *((esi + ebx*4));
        extern_rec ();
        goto label_1;
        ebx++;
    } while (edi > ebx);
label_7:
    ebx = *((esi + edi*4));
    goto label_2;
label_4:
    if (ebx >= *(obj.caml_code_area_start)) {
        if (ebx < *(obj.caml_code_area_end)) {
            if (*(obj.extern_closures) == 0) {
                eax = "output_value: functional value";
                extern_invalid_argument ();
            }
            edx = ebx;
            edx -= *(obj.caml_code_area_start);
            eax = 0x10;
            writecode32 ();
            caml_code_checksum ();
            edx = 0x10;
            writeblock ();
        }
    } else {
        eax = "output_value: abstract value (outside heap)";
        extern_invalid_argument ();
    }
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a42d */
#include <stdint.h>
 
uint32_t extern_value (void) {
    int32_t var_4h;
    ebx = eax;
    eax = caml_convert_flag_list (ebx, 0x807cacc);
    edx = eax;
    edx &= 1;
    *(obj.extern_ignore_sharing) = edx;
    eax &= 2;
    *(obj.extern_closures) = eax;
    *(obj.extern_trail_block) = 0x8081300;
    *(obj.extern_trail_cur) = 0x8081304;
    *(obj.extern_trail_limit) = 0x808330c;
    *(obj.obj_counter) = 0;
    *(obj.size_32) = 0;
    *(obj.size_64) = 0;
    eax = 0x8495a6be;
    write32 ();
    *(obj.extern_ptr) += 0x10;
    eax = ebx;
    extern_rec ();
    if (*(obj.extern_userprovided_output) == 0) {
        edx = extern_ptr;
        eax = extern_output_block;
        *((eax + 4)) = edx;
    }
    extern_replay_trail ();
    eax = extern_userprovided_output;
    if (eax != 0) {
        ebx = extern_ptr;
        ebx -= eax;
        eax += 4;
        *(obj.extern_ptr) = eax;
        goto label_0;
    }
    ecx = extern_output_first;
    ebx = 0;
    if (ecx == 0) {
        goto label_1;
    }
    eax = ecx;
    do {
        edx = *((eax + 4));
        edx -= eax;
        ebx = edx + ebx - 8;
        eax = *(eax);
    } while (eax != 0);
    while (1) {
label_0:
        eax = ebx - 0x14;
        write32 ();
        eax = obj_counter;
        write32 ();
        eax = size_32;
        write32 ();
        eax = size_64;
        write32 ();
        eax = ebx;
        return eax;
label_1:
        eax = ecx + 0xc;
        *(obj.extern_ptr) = eax;
        ecx += 0x1fac;
        *(obj.extern_limit) = ecx;
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806aa77 */
#include <stdint.h>
 
int32_t intern_cleanup (void) {
    if (*(obj.intern_input_malloced) != 0) {
        eax = intern_input;
        caml_stat_free (eax);
    }
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    eax = intern_extra_block;
    if (eax != 0) {
        caml_free_for_heap (eax);
    } else {
        eax = intern_block;
        if (eax == 0) {
            goto label_0;
        }
        edx = intern_header;
        *((eax - 4)) = edx;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806abbb */
#include <stdint.h>
 
uint32_t intern_alloc (void) {
    int32_t var_4h;
    ebx = edx;
    if (eax == 0) {
        *(obj.intern_obj_table) = 0;
        *(obj.intern_extra_block) = 0;
        *(obj.intern_block) = 0;
    } else {
        edx = eax - 1;
        if (edx > 0x3fffff) {
            eax = eax*4 + 0xfff;
            eax &= 0xfffff000;
            eax = caml_alloc_for_heap (eax);
            *(obj.intern_extra_block) = eax;
            if (eax == 0) {
                eax = caml_raise_out_of_memory ();
            }
            eax = caml_allocation_color (eax);
            *(obj.intern_color) = eax;
            eax = intern_extra_block;
            *(obj.intern_dest) = eax;
        } else {
            if (edx == 0) {
                *(obj.intern_block) = 0x80838f4;
            } else {
                if (edx <= 0x100) {
                    eax = caml_alloc_small (edx, 0xfc);
                    *(obj.intern_block) = eax;
                } else {
                    eax = caml_alloc_shr (edx, 0xfc);
                    *(obj.intern_block) = eax;
                }
            }
            eax = intern_block;
            eax -= 4;
            edx = *(eax);
            *(obj.intern_header) = edx;
            edx &= 0x300;
            *(obj.intern_color) = edx;
            *(obj.intern_dest) = eax;
            *(obj.intern_extra_block) = 0;
        }
        *(obj.obj_counter_1) = 0;
        if (ebx != 0) {
            ebx <<= 2;
            eax = caml_stat_alloc (ebx);
            *(obj.intern_obj_table) = eax;
        } else {
            *(obj.intern_obj_table) = 0;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806acd0 */
#include <stdint.h>
 
int32_t intern_rec (void) {
    int32_t var_40h;
    int32_t var_3ch;
    void * s2;
    size_t * n;
label_0:
    *((ebp - 0x3c)) = eax;
    esi = 0x8071a04;
    do {
label_1:
        eax = intern_src;
        edx = *(eax);
        ebx = (int32_t) dl;
        eax++;
        *(obj.intern_src) = eax;
        if (ebx <= 0x3f) {
            goto label_2;
        }
        if (ebx <= 0x7f) {
            goto label_3;
        }
        edx = ebx;
        edx &= 0xf;
        ebx >>= 4;
        ebx &= 7;
        if (ebx == 0) {
            esi = edx*4 + 0x8083504;
            goto label_4;
        }
        ecx = intern_dest;
        ecx += 4;
        eax = *((ebp - 0x3c));
        *(eax) = ecx;
        eax = intern_obj_table;
        if (eax != 0) {
            edi = obj_counter;
            *((eax + edi*4)) = ecx;
            edi++;
            *(obj.obj_counter_1) = edi;
        }
        eax = intern_dest;
        ecx = eax + 4;
        *((ebp - 0x3c)) = ecx;
        edx += *(obj.intern_color);
        ecx = ebx;
        ecx <<= 0xa;
        edx += ecx;
        *(eax) = edx;
        eax = ebx*4 + 4;
        *(obj.intern_dest) += eax;
    } while (ebx <= 1);
    edi = ebx;
    eax = *((ebp - 0x3c));
    *((ebp - 0x40)) = eax;
    do {
        eax = *((ebp - 0x40));
        intern_rec ();
        goto label_0;
        edi--;
        *((ebp - 0x40)) += 4;
    } while (edi > 1);
    edx = *((ebp - 0x3c));
    edx = edx + ebx*4 - 4;
    *((ebp - 0x3c)) = edx;
    goto label_1;
label_3:
    ebx &= 0x3f;
    esi = ebx + ebx + 1;
    goto label_4;
label_2:
    if (ebx > 0x1f) {
        ebx &= 0x1f;
        eax = ebx + 4;
        eax >>= 2;
        edi = intern_dest;
        edi += 4;
        esi = edi;
        edx = intern_obj_table;
        if (edx != 0) {
            ecx = obj_counter;
            *((edx + ecx*4)) = edi;
            ecx++;
            *(obj.obj_counter_1) = ecx;
        }
        edx = eax;
        edx <<= 0xa;
        ecx = intern_color;
        ecx = ecx + edx + 0xfc;
        edx = intern_dest;
        *(edx) = ecx;
        edx = eax*4 + 4;
        *(obj.intern_dest) += edx;
        eax <<= 2;
        *((esi + eax - 4)) = 0;
        eax--;
        edx = eax;
        dl -= bl;
        *((eax + esi)) = dl;
        eax = intern_src;
        memmove (edi, eax, ebx);
        *(obj.intern_src) += ebx;
    } else {
        if (dl <= 0x13) {
            edx = (int32_t) dl;
            uint32_t (*esi + edx*4)() ();
        }
        intern_cleanup ();
        caml_failwith ("input_value: ill-formed message");
    }
label_4:
    ecx = *((ebp - 0x3c));
    *(ecx) = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806b336 */
#include <stdint.h>
 
uint32_t intern_add_to_heap (void) {
    int32_t var_4h;
    int32_t var_8h;
    edx = intern_extra_block;
    if (edx != 0) {
        eax = eax*4 + 0xfff;
        eax &= 0xfffff000;
        edx += eax;
        eax = intern_dest;
        if (edx > eax) {
            edx -= eax;
            edx >>= 2;
            caml_make_free_blocks (eax, edx, 0);
        }
        eax = intern_extra_block;
        edx = intern_dest;
        edx -= eax;
        edx >>= 2;
        *(obj.caml_allocated_words) += edx;
        caml_add_to_heap (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063509 */
#include <stdint.h>
 
uint32_t caml_make_free_blocks (int32_t arg_8h, char * arg_ch, size_t arg_10h) {
    esi = *((ebp + 8));
    edi = *((ebp + 0xc));
    if (edi == 0) {
        goto label_0;
    }
    do {
        ebx = 0x400000;
        if (edi <= 0x400000) {
            ebx = edi;
        }
        eax = ebx - 1;
        eax <<= 0xa;
        *(esi) = eax;
        if (*((ebp + 0x10)) != 0) {
            eax = esi + 4;
            caml_fl_merge_block (eax);
        }
        edi -= ebx;
        if (edi == 0) {
            goto label_0;
        }
        esi = esi + ebx*4;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80650d6 */
#include <stdint.h>
 
int32_t caml_add_to_heap (int32_t arg_8h) {
    char * var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    esi = ebx - 0x10;
    eax = caml_stat_heap_size;
    eax += *((esi + 8));
    eax >>= 0xa;
    caml_gc_message (ebx, esi, eax);
    eax = ebx;
    eax += *((esi + 8));
    eax = caml_page_table_add (1, ebx, eax);
    edx = eax;
    eax = 0xffffffff;
    if (edx != 0) {
        goto label_0;
    }
    eax = caml_heap_start;
    if (eax != 0) {
        if (ebx > eax) {
            goto label_1;
        }
    }
    edx = caml_heap_start;
    goto label_2;
    do {
label_1:
        edx = eax - 4;
        eax = *((eax - 4));
        if (eax == 0) {
            goto label_2;
        }
    } while (ebx > eax);
label_2:
    *((esi + 0xc)) = eax;
    *(edx) = ebx;
    *(obj.caml_stat_heap_chunks)++;
    edx = caml_stat_heap_size;
    edx += *((esi + 8));
    *(obj.caml_stat_heap_size) = edx;
    eax = 0;
    if (edx > *(obj.caml_stat_top_heap_size)) {
        *(obj.caml_stat_top_heap_size) = edx;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806b396 */
#include <stdint.h>
 
int32_t input_val_from_block (void) {
    int32_t var_ch;
    eax = intern_src;
    ecx = eax + 4;
    ebx = *((ecx - 1));
    edx = *(eax);
    edx <<= 0x18;
    edx = ebx + edx;
    ebx = *((ecx - 3));
    ebx <<= 0x10;
    edx += ebx;
    ecx = *((ecx - 2));
    ecx <<= 8;
    edx += ecx;
    ecx = eax + 8;
    ebx = *((ecx - 4));
    ebx <<= 0x18;
    esi = *((ecx - 1));
    ebx += esi;
    esi = *((ecx - 3));
    esi <<= 0x10;
    ebx += esi;
    ecx = *((ecx - 2));
    ecx <<= 8;
    ebx += ecx;
    eax += 0xc;
    *(obj.intern_src) = eax;
    eax = ebx;
    intern_alloc (ebx, esi);
    eax = ebp - 0xc;
    intern_rec ();
    eax = ebx;
    intern_add_to_heap ();
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806b80b */
#include <stdint.h>
 
int32_t hash_aux (void) {
    uint32_t var_1ch;
label_1:
    esi = eax;
    edx = hash_univ_limit;
    edx--;
    *(obj.hash_univ_limit) = edx;
    eax = hash_univ_count;
    if (eax < 0) {
        goto label_4;
    }
    if (edx < 0) {
        goto label_4;
    }
    if ((esi & 1) == 0) {
        ebx = esi;
        ecx = esi;
        ecx >>= 0x17;
        edx = esi;
        edx >>= 0xc;
        edx &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
        if ((*((ecx + edx)) & 7) != 0) {
            goto label_5;
        }
        goto label_6;
    }
label_3:
    eax--;
    *(obj.hash_univ_count) = eax;
    esi >>= 1;
    eax = *(obj.hash_accu) * 0x1003f;
    eax = esi + eax;
    *(obj.hash_accu) = eax;
    goto label_4;
label_2:
    ebx = esi;
    ecx = esi;
    ecx >>= 0x17;
    edx = esi;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 7) == 0) {
        goto label_6;
    }
label_5:
    ecx = ebx - 4;
    edx = *(ecx);
    edi = (int32_t) dl;
    *((ebp - 0x1c)) = edi;
    edx += 8;
    if (dl > 7) {
        goto label_7;
    }
    edx = (int32_t) dl;
    /* switch table (8 cases) at 0x8071a54 */
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = caml_string_length (esi);
    if (eax == 0) {
        goto label_4;
    }
    edx = hash_accu;
    do {
        ecx = edx * 9;
        ecx = edx + ecx*2;
        edx = *(esi);
        edx = ecx + edx;
        esi++;
        eax--;
    } while (eax != 0);
    *(obj.hash_accu) = edx;
    goto label_4;
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = hash_accu;
    ecx = esi + 8;
    do {
        edx = eax * 9;
        edx = eax + edx*2;
        eax = *(esi);
        eax = edx + eax;
        esi++;
    } while (esi != ecx);
    *(obj.hash_accu) = eax;
    goto label_4;
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = *(ecx);
    eax >>= 0xa;
    eax <<= 2;
    *((ebp - 0x1c)) = eax;
    if (eax == 0) {
        goto label_4;
    }
    edx = hash_accu;
    esi = 0;
label_0:
    eax = ebx;
    ebx += 8;
    ecx = ebx;
    do {
        edi = edx * 9;
        edi = edx + edi*2;
        edx = *(eax);
        edx = edi + edx;
        eax++;
    } while (ecx != eax);
    esi += 8;
    if (esi < *((ebp - 0x1c))) {
        goto label_0;
    }
    *(obj.hash_accu) = edx;
    goto label_4;
    eax = *(ecx);
    eax >>= 0xa;
    eax <<= 2;
    ebx -= eax;
    eax = ebx;
    eax = hash_aux ();
    goto label_1;
    goto label_4;
    esi = *(esi);
    if ((esi & 1) == 0) {
        goto label_2;
    }
    goto label_3;
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = *((ebx + 4));
    eax >>= 1;
    edx = *(obj.hash_accu) * 0x1003f;
    eax += edx;
    *(obj.hash_accu) = eax;
    goto label_4;
    edx = *(esi);
    edx = *((edx + 0xc));
    if (edx == 0) {
        goto label_4;
    }
    eax--;
    *(obj.hash_univ_count) = eax;
    ebx = *(obj.hash_accu) * 0x1003f;
    eax = void (*edx)(uint32_t) (esi);
    ebx = eax + ebx;
    *(obj.hash_accu) = ebx;
    goto label_4;
label_7:
    eax--;
    *(obj.hash_univ_count) = eax;
    eax = hash_accu;
    edx = eax * 9;
    eax = eax + edx*2;
    eax += *((ebp - 0x1c));
    *(obj.hash_accu) = eax;
    esi = *(ecx);
    esi >>= 0xa;
    if (esi == 0) {
        goto label_4;
    }
    do {
        esi--;
        eax = *((ebx + esi*4));
        eax = hash_aux ();
        goto label_1;
    } while (esi != 0);
    goto label_4;
label_6:
    eax = *(obj.hash_accu) * 0x1003f;
    ebx += eax;
    *(obj.hash_accu) = ebx;
label_4:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c183 */
#include <stdint.h>
 
int32_t token_name (void) {
    ebx = eax;
    if (edx <= 0) {
        goto label_0;
    }
    esi = 0xffffffff;
    eax = 0;
    if (*(ebx) != 0) {
        goto label_1;
    }
    goto label_2;
    do {
        if (*(ebx) == 0) {
            goto label_2;
        }
label_1:
        edi = ebx;
        ecx = esi;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        ebx += ecx;
        edx--;
    } while (edx > 0);
    goto label_0;
label_2:
    ebx = "<unknown token>";
label_0:
    eax = "<unknown token>";
    esi = ebx;
    edi = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c830 */
#include <stdint.h>
 
int32_t norm_pfree (void) {
    edx = 1;
    if (eax == 0) {
        eax = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c83f */
#include <stdint.h>
 
void norm_pmax (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c844 */
#include <stdint.h>
 
int32_t norm_heapincr (void) {
    eax += 0x3ff;
    eax &= 0xfffffc00;
    edx = 0x800;
    if (eax <= 0x7ff) {
        eax = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c860 */
#include <stdint.h>
 
int32_t norm_minsize (void) {
    edx = 0x1000;
    if (eax <= 0xfff) {
        eax = edx;
    }
    edx = 0x10000000;
    if (eax > 0x10000000) {
        eax = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ca01 */
#include <stdint.h>
 
int32_t test_and_compact (void) {
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_18h;
    int32_t var_14h;
    char * var_4h;
    int32_t var_8h;
    eax = caml_fl_cur_size;
    ecx = 0;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = ecx;
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[0] *= *(0x8071dbc);
    edx = caml_stat_heap_size;
    edx >>= 2;
    edx -= eax;
    eax = edx;
    edx = 0;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = edx;
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(0x8071dc0);
    *(fp_stack--) = *((ebp - 0x20));
    __asm ("fcmovnbe st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *((ebp - 0x20)) = fp_stack[0];
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0x18)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x18));
    caml_gc_message (0x200, "Estimated overhead (lower bound) = %lu%%\n", eax);
    eax = caml_percent_max;
    edx = 0;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = edx;
    *(fp_stack--) = *((ebp - 0x18));
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        if (*(obj.caml_stat_heap_chunks) <= 1) {
            goto label_0;
        }
        caml_gc_message (0x200, "Automatic compaction triggered.\n", 0);
        caml_compact_heap ();
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ee70 */
#include <stdint.h>
 
int32_t caml_compact_heap (void) {
    int32_t var_2ch;
    uint32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    int32_t var_1ch;
    char * s2;
    size_t n;
    caml_gc_message (ebx, esi, edi);
    eax = caml_heap_start;
    if (eax == 0) {
        goto label_9;
    }
label_0:
    edi = eax - 0x10;
    esi = eax;
    esi += *((edi + 8));
    if (esi <= eax) {
        goto label_10;
    }
    do {
        edx = *(eax);
        ecx = *(eax);
        ecx >>= 0xa;
        ebx = edx;
        ebx &= 0x300;
        if (ebx == 0x200) {
            edx = ecx;
            edx <<= 0xa;
            edx |= 0x3f3;
            *(eax) = edx;
        } else {
            ebx = ecx;
            ebx <<= 0xa;
            edx &= 0xff;
            edx <<= 2;
            edx |= ebx;
            edx |= 3;
            *(eax) = edx;
        }
        eax = eax + ecx*4 + 4;
    } while (esi > eax);
label_10:
    eax = *((edi + 0xc));
    if (eax != 0) {
        goto label_0;
    }
label_9:
    caml_do_roots (sym.invert_root);
    caml_final_do_weak_roots (sym.invert_root);
    eax = caml_heap_start;
    if (eax == 0) {
        goto label_11;
    }
label_2:
    *((ebp - 0x1c)) = eax;
    eax -= 0x10;
    *((ebp - 0x24)) = eax;
    edx = *((ebp - 0x1c));
    edx += *((eax + 8));
    *((ebp - 0x20)) = edx;
    ecx = *((ebp - 0x1c));
    if (edx <= ecx) {
        goto label_12;
    }
label_1:
    edx = *((ebp - 0x1c));
    eax = *(edx);
    if ((al & 3) != 0) {
        goto label_13;
    }
    do {
        eax = *(eax);
    } while ((al & 3) == 0);
label_13:
    edi = eax;
    edi >>= 0xa;
    edi++;
    eax >>= 2;
    eax &= 0xff;
    if (eax != 0xf9) {
        goto label_14;
    }
    ecx = *((ebp - 0x1c));
    eax = *((ecx + edi*4));
    edx = *((ecx + edi*4));
    edx &= 3;
    if (edx == 3) {
        goto label_15;
    }
    do {
        eax &= 0xfffffffc;
        eax = *(eax);
        edx = *(eax);
        edx &= 3;
    } while (edx != 3);
label_15:
    edi = eax;
    edi >>= 0xa;
    edi++;
    eax >>= 2;
    eax &= 0xff;
label_14:
    if (eax > 0xfa) {
        goto label_16;
    }
    if (edi <= 1) {
        goto label_16;
    }
    ebx = *((ebp - 0x1c));
    ebx += 4;
    esi = 1;
    do {
        eax = ebx;
        invert_pointer_at ();
        esi++;
        ebx += 4;
    } while (edi > esi);
label_16:
    eax = *((ebp - 0x1c));
    eax = eax + edi*4;
    *((ebp - 0x1c)) = eax;
    if (*((ebp - 0x20)) > eax) {
        goto label_1;
    }
label_12:
    edx = *((ebp - 0x24));
    eax = *((edx + 0xc));
    if (eax != 0) {
        goto label_2;
    }
label_11:
    ecx = caml_weak_list_head;
    *((ebp - 0x1c)) = ecx;
    if (ecx == 0) {
        goto label_17;
    }
    *((ebp - 0x20)) = obj.caml_weak_list_head;
label_3:
    ebx = *((ebp - 0x1c));
    edi = *((ebx - 4));
    if ((edi & 3) != 0) {
        goto label_18;
    }
    do {
        edi = *(edi);
    } while ((edi & 3) == 0);
label_18:
    edi >>= 0xa;
    if (edi <= 1) {
        goto label_19;
    }
    ebx += 4;
    esi = 1;
    do {
        eax = *(ebx);
        if (eax != *(obj.caml_weak_none)) {
            eax = ebx;
            invert_pointer_at ();
        }
        esi++;
        ebx += 4;
    } while (edi > esi);
label_19:
    eax = *((ebp - 0x20));
    invert_pointer_at ();
    eax = *((ebp - 0x1c));
    *((ebp - 0x20)) = eax;
    edx = *(eax);
    *((ebp - 0x1c)) = edx;
    if (edx != 0) {
        goto label_3;
    }
label_17:
    init_compact_allocate ();
    ebx = caml_heap_start;
    if (ebx == 0) {
        goto label_20;
    }
label_6:
    ecx = ebx - 0x10;
    *((ebp - 0x2c)) = ecx;
    eax = *((ecx + 8));
    eax += ebx;
    *((ebp - 0x28)) = eax;
    goto label_21;
label_5:
    eax = *(ebx);
    if ((al & 3) == 0) {
        goto label_22;
    }
    edx = eax;
    edx >>= 2;
    edx &= 0xff;
    if (edx != 0xf9) {
        goto label_23;
    }
    goto label_24;
    do {
label_22:
        eax = *(eax);
    } while ((al & 3) == 0);
    esi = eax;
    esi >>= 0xa;
    esi++;
    eax >>= 2;
    eax &= 0xff;
    *((ebp - 0x24)) = eax;
    *((ebp - 0x20)) = 0;
    if (eax != 0xf9) {
        goto label_25;
    }
label_8:
    esi = ebx + esi*4;
    *((ebp - 0x20)) = esi;
    eax = *(esi);
    edx = *(esi);
    edx &= 3;
    if (edx == 3) {
        goto label_26;
    }
    do {
        eax &= 0xfffffffc;
        eax = *(eax);
        edx = *(eax);
        edx &= 3;
    } while (edx != 3);
label_26:
    esi = eax;
    esi >>= 0xa;
    esi++;
    eax >>= 2;
    eax &= 0xff;
    *((ebp - 0x24)) = eax;
label_25:
    edx = esi*4;
    *((ebp - 0x1c)) = edx;
    eax = edx;
    eax = compact_allocate ();
    edx = *(ebx);
    if ((dl & 3) != 0) {
        goto label_27;
    }
    edi = eax + 4;
    do {
        ecx = *(edx);
        *(edx) = edi;
        if ((cl & 3) != 0) {
            goto label_27;
        }
        edx = ecx;
    } while (1);
label_27:
    esi <<= 0xa;
    ecx = *((ebp - 0x24));
    edx = esi + ecx - 0x400;
    *(ebx) = edx;
    if (*((ebp - 0x20)) == 0) {
        goto label_28;
    }
    ecx = *((ebp - 0x20));
    edx = *((ebp - 0x20));
    edx &= 3;
    if (edx == 3) {
        goto label_28;
    }
label_4:
    edi = ecx;
    edi &= 0xfffffffc;
    ecx = *(edi);
    edx = *(edi);
    edx &= 3;
    if (edx != 2) {
        goto label_29;
    }
    edx = edi;
    edx -= ebx;
    edx >>= 2;
    esi = eax + edx*4 + 4;
    do {
        edx = ecx;
        edx &= 0xfffffffc;
        ecx = *(edx);
        *(edx) = esi;
        edx = ecx;
        edx &= 3;
    } while (edx == 2);
label_29:
    edx = edi;
    edx -= ebx;
    edx >>= 2;
    edx <<= 0xa;
    edx += 0xf9;
    *(edi) = edx;
    edx = ecx;
    edx &= 3;
    if (edx != 3) {
        goto label_4;
    }
label_28:
    ebx += *((ebp - 0x1c));
    goto label_21;
label_23:
    ecx = eax;
    ecx &= 0xfffffc00;
    edx = edx + ecx + 0x200;
    *(ebx) = edx;
    eax >>= 0xa;
    ebx = ebx + eax*4 + 4;
label_21:
    if (*((ebp - 0x28)) > ebx) {
        goto label_5;
    }
    eax = *((ebp - 0x2c));
    ebx = *((eax + 0xc));
    if (ebx != 0) {
        goto label_6;
    }
label_20:
    init_compact_allocate ();
    ebx = caml_heap_start;
    if (ebx == 0) {
        goto label_30;
    }
label_7:
    edx = ebx - 0x10;
    *((ebp - 0x1c)) = edx;
    esi = ebx;
    esi += *((edx + 8));
    while (esi > ebx) {
        eax = *(ebx);
        if ((ah & 3) == 0) {
            eax >>= 0xa;
            edi = eax*4 + 4;
            eax = edi;
            eax = compact_allocate ();
            eax = memmove (eax, ebx, edi);
            ebx += edi;
        } else {
            eax >>= 0xa;
            ebx = ebx + eax*4 + 4;
        }
    }
    ecx = *((ebp - 0x1c));
    ebx = *((ecx + 0xc));
    if (ebx != 0) {
        goto label_7;
    }
    ecx = caml_heap_start;
    if (ecx == 0) {
        goto label_30;
    }
    edx = ecx;
    eax = 0;
    do {
        edx -= 0x10;
        esi = *((edx + 4));
        if (esi != 0) {
            edi = esi;
            edi >>= 2;
            eax += edi;
            edi = *((edx + 8));
            edi -= esi;
            esi = edi;
            esi >>= 2;
            ebx += esi;
        }
        edx = *((edx + 0xc));
    } while (edx != 0);
    esi = 0x64;
    edx = 0;
    eax = edx:eax / esi;
    edx = edx:eax % esi;
    eax++;
    edi = eax;
    edi *= *(obj.caml_percent_free);
    do {
        eax = ecx - 0x10;
        esi = *((eax + 0xc));
        if (*((eax + 4)) == 0) {
            if (edi > ebx) {
                eax = *((eax + 8));
                eax >>= 2;
                ebx += eax;
            } else {
                caml_shrink_heap (ecx);
            }
        }
        if (esi == 0) {
            goto label_31;
        }
        ecx = esi;
    } while (1);
label_31:
    ebx = caml_heap_start;
    caml_fl_reset ();
    if (ebx == 0) {
        goto label_32;
    }
    do {
        esi = ebx - 0x10;
        edx = *((esi + 8));
        eax = *((esi + 4));
        if (edx > eax) {
            edx -= eax;
            edx >>= 2;
            eax = ebx + eax;
            caml_make_free_blocks (eax, edx, 1);
        }
        ebx = *((esi + 0xc));
    } while (ebx != 0);
    do {
label_32:
        *(obj.caml_stat_compactions)++;
        caml_gc_message (0x10, "done.\n", 0);
        return eax;
label_30:
        eax = caml_fl_reset ();
    } while (1);
label_24:
    eax >>= 0xa;
    esi = eax + 1;
    goto label_8;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e088 */
#include <stdint.h>
 
int32_t add_char (void) {
    ecx = *(eax);
    if (ecx < *((eax + 4))) {
        *(ecx) = dl;
        ecx++;
        *(eax) = ecx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e09b */
#include <stdint.h>
 
int32_t add_string (void) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = eax;
    edi = edx;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ebx = ecx - 1;
    eax = *(esi);
    ecx = eax + ebx;
    edi = *((esi + 4));
    edi -= eax;
    if (*((esi + 4)) < ecx) {
        ebx = edi;
    }
    if (ebx > 0) {
        memmove (eax, edx, ebx);
    }
    *(esi) += ebx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e340 */
#include <stdint.h>
 
int32_t hash_value_name (void) {
    edx = *(eax);
    ecx = 0;
    if (dl == 0) {
        goto label_0;
    }
    do {
        ebx = ecx * 9;
        ebx = ecx + ebx*2;
        ecx = (int32_t) dl;
        ecx += ebx;
        eax++;
        edx = *(eax);
    } while (dl != 0);
label_0:
    edx = 0x4ec4ec4f;
    eax = ecx;
    edx:eax = eax * edx;
    eax = edx;
    eax >>= 2;
    edx = eax * 3;
    eax = eax + edx*4;
    ecx -= eax;
    eax = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e6de */
#include <stdint.h>
 
int32_t do_set (void) {
    if ((cl & 1) == 0) {
        if (ecx < *(obj.caml_young_end)) {
            if (ecx <= *(obj.caml_young_start)) {
                goto label_0;
            }
            ebx = eax + edx*4;
            eax = *(ebx);
            *(ebx) = ecx;
            if ((al & 1) == 0) {
                if (eax >= *(obj.caml_young_end)) {
                    goto label_1;
                }
                if (eax > *(obj.caml_young_start)) {
                    goto label_2;
                }
            }
label_1:
            eax = .comment;
            if (eax >= *(0x807fea8)) {
                caml_realloc_ref_table (obj.caml_weak_ref_table);
            }
            eax = 0x807fea4;
            edx = *(eax);
            *(edx) = ebx;
            edx += 4;
            *(eax) = edx;
        }
    } else {
label_0:
        *((eax + edx*4)) = ecx;
    }
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ecd0 */
#include <stdint.h>
 
int32_t invert_pointer_at (void) {
    int32_t var_14h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ecx = *(eax);
    if ((cl & 3) != 0) {
        goto label_0;
    }
    ebx = ecx;
    ebx >>= 0x17;
    edx = ecx;
    edx >>= 0xc;
    edx &= 0x7ff;
    ebx = *((ebx*4 + obj.caml_page_table));
    if ((*((ebx + edx)) & 1) == 0) {
        goto label_0;
    }
    esi = ecx - 4;
    edi = *(esi);
    edx = *(esi);
    edx &= 3;
    if (edx != 1) {
        if (edx >= 1) {
            if (edx == 2) {
                goto label_1;
            }
            if (edx != 3) {
                goto label_0;
            }
        }
        *(eax) = edi;
        *(esi) = eax;
        goto label_0;
    }
    edi >>= 0xa;
    edi <<= 2;
    edx = ecx;
    edx -= edi;
    edi = edx;
    ebx = edx - 4;
    *((ebp - 0x14)) = ebx;
    edx = *(ebx);
    if ((dl & 3) != 0) {
        goto label_2;
    }
    do {
        ebx = edx;
        edx = *(edx);
    } while ((dl & 3) == 0);
    *((ebp - 0x14)) = ebx;
label_2:
    ebx = edx;
    ebx >>= 2;
    if (bl == 0xf7) {
        *(eax) = edx;
        eax |= 2;
        *(esi) = eax;
        ecx -= edi;
        ecx >>= 2;
        eax = ecx - 1;
        eax <<= 0xa;
        eax |= 0x3e7;
        edx = *((ebp - 0x14));
        *(edx) = eax;
    } else {
        edx >>= 0xa;
        edx = edi + edx*4;
        edx |= 1;
        *(eax) = edx;
        eax |= 2;
        *(esi) = eax;
        ecx -= edi;
        ecx >>= 2;
        eax = ecx - 1;
        eax <<= 0xa;
        eax |= 0x3e7;
        ebx = *((ebp - 0x14));
        *(ebx) = eax;
        goto label_0;
label_1:
        *(eax) = edi;
        eax |= 2;
        *(esi) = eax;
    }
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806edbf */
#include <stdint.h>
 
int32_t invert_root (int32_t arg_ch) {
    eax = *((ebp + 0xc));
    invert_pointer_at ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806edcc */
#include <stdint.h>
 
int32_t init_compact_allocate (void) {
    eax = caml_heap_start;
    if (eax == 0) {
        goto label_0;
    }
    do {
        eax -= 0x10;
        *((eax + 4)) = 0;
        eax = *((eax + 0xc));
    } while (eax != 0);
label_0:
    eax = caml_heap_start;
    *(obj.compact_fl) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806edf5 */
#include <stdint.h>
 
uint32_t compact_allocate (void) {
    ecx = compact_fl;
    edx = ecx - 0x10;
    ebx = *((edx + 8));
    ebx -= *((edx + 4));
    if (ebx > 0x10) {
        goto label_1;
    }
    esi = *((edx + 0xc));
    edx = esi - 0x10;
    ebx = *((edx + 8));
    ebx -= *((edx + 4));
    if (ebx <= 0x10) {
        goto label_2;
    }
    goto label_1;
    do {
        esi = ebx;
        ecx = ebx;
label_0:
        ebx = *((edx + 0xc));
        edx = ebx - 0x10;
        edi = *((edx + 8));
        edi -= *((edx + 4));
    } while (edi <= 0x10);
    *(obj.compact_fl) = esi;
label_1:
    edx = ecx - 0x10;
    ebx = *((edx + 4));
    esi = *((edx + 8));
    esi -= ebx;
    if (eax <= esi) {
        goto label_3;
    }
    do {
        ecx = *((edx + 0xc));
        edx = ecx - 0x10;
        ebx = *((edx + 4));
        esi = *((edx + 8));
        esi -= ebx;
    } while (esi < eax);
label_3:
    eax = ebx + eax;
    *((edx + 4)) = eax;
    eax = ecx + ebx;
    esi = ebx;
    edi = ebx;
    return eax;
label_2:
    ecx = esi;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070054 */
#include <stdint.h>
 
int32_t extract_location_info (void) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    if ((*((eax + 4)) & 1) == 0) {
        *(edx) = 0;
        *((edx + 4)) = 1;
    } else {
        ecx = *((eax + 6));
        ebx = eax + ecx*2 + 0xb;
        ebx &= 0xfffffffc;
        edi = *(ebx);
        ecx = *((ebx + 4));
        *(edx) = 1;
        al = ((edi & 3) != 0) ? 1 : 0;
        esi = eax;
        esi &= 0xff;
        *((edx + 4)) = esi;
        esi = edi;
        esi &= 0x3fffffc;
        ebx = esi + ebx;
        *((edx + 8)) = ebx;
        ebx = ecx;
        ebx >>= 0xc;
        *((edx + 0xc)) = ebx;
        ebx = ecx;
        ebx >>= 4;
        ebx &= 0xff;
        *((edx + 0x10)) = ebx;
        ecx &= 0xf;
        ecx <<= 6;
        eax = edi;
        eax >>= 0x1a;
        eax |= ecx;
        *((edx + 0x14)) = eax;
    }
    ebx = *(esp);
    esi = *((esp + 4));
    edi = *((esp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068449 */
#include <stdint.h>
 
int32_t caml_channel_binary_mode (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c550 */
#include <stdint.h>
 
int32_t camlUnix_fun_2782 (void) {
    eax = unix_error_message;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070538 */
#include <stdint.h>
 
void loc_caml_c_call (int32_t arg_4h) {
    edx = *(esp);
    *(obj.caml_last_return_address) = edx;
    edx = esp + 4;
    *(obj.caml_bottom_of_stack) = edx;
    return void (*eax)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806957c */
#include <stdint.h>
 
int32_t caml_seek_out (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    edi = *((ebp + 0x10));
    caml_flush (ebx);
    caml_enter_blocking_section ();
    *((esp + 0xc)) = 0;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    eax = *(ebx);
    *(esp) = eax;
    eax = lseek64 ();
    edx ^= edi;
    eax ^= esi;
    edx |= eax;
    if (edx != 0) {
        caml_leave_blocking_section ();
        caml_sys_error (1);
    }
    caml_leave_blocking_section ();
    *((ebx + 4)) = esi;
    *((ebx + 8)) = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80694ea */
#include <stdint.h>
 
uint32_t caml_flush (int32_t arg_8h) {
    ebx = *((ebp + 8));
    do {
        eax = caml_flush_partial (ebx);
    } while (eax == 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069247 */
#include <stdint.h>
 
uint32_t caml_flush_partial (int32_t arg_8h) {
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    eax = ebx + 0x34;
    *((ebp - 0x1c)) = eax;
    esi = *((ebx + 0x10));
    esi -= eax;
    if (esi > 0) {
        edx = eax;
        ecx = esi;
        eax = *(ebx);
        eax = do_write ();
        edi = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebx + 4)) += eax;
        *((ebx + 8)) += edx;
        if (esi > edi) {
            esi -= edi;
            eax = *((ebp - 0x1c));
            eax += edi;
            eax = *((ebp - 0x1c));
            memmove (eax, eax, esi);
        }
        *((ebx + 0x10)) -= edi;
    }
    eax = ebx + 0x34;
    al = (*((ebx + 0x10)) == eax) ? 1 : 0;
    eax = (int32_t) al;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062d1d */
#include <stdint.h>
 
int32_t caml_enter_blocking_section (void) {
    do {
        caml_process_pending_signals ();
        uint32_t (*caml_enter_blocking_section_hook)() ();
        eax = caml_signals_are_pending;
        if (eax == 0) {
            goto label_0;
        }
        uint32_t (*caml_leave_blocking_section_hook)() ();
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a844 */
#include <stdint.h>
 
void lseek64 (void) {
    lseek64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062d0a */
#include <stdint.h>
 
void caml_leave_blocking_section (void) {
    uint32_t (*caml_leave_blocking_section_hook)() ();
    caml_process_pending_signals ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062b6c */
#include <stdint.h>
 
int32_t caml_process_pending_signals (void) {
    int32_t var_4h;
    eax = caml_signals_are_pending;
    if (eax == 0) {
        goto label_0;
    }
    *(obj.caml_signals_are_pending) = 0;
    ebx = 0;
    esi = caml_pending_signals;
    do {
        eax = *((esi + ebx*4));
        if (eax != 0) {
            *((esi + ebx*4)) = 0;
            caml_execute_signal (ebx, 0);
        }
        ebx++;
    } while (ebx != 0x41);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bcdb */
#include <stdint.h>
 
int32_t caml_sys_error (int32_t arg_8h) {
    int32_t var_3ch_2;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    void * s2;
    size_t n;
    eax = caml_local_roots;
    *((ebp - 0x38)) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    eax = ebp - 0x3c;
    *((ebp - 0x50)) = eax;
    eax = errno_location ();
    eax = *(eax);
    eax = strerror (eax);
    esi = eax;
    edx = *((ebp + 8));
    if (edx == 1) {
        eax = caml_copy_string (eax);
        *((ebp - 0x3c)) = eax;
    } else {
        edi = eax;
        eax = 0;
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        edi = ecx - 1;
        eax = caml_string_length (edx);
        ebx = eax;
        eax = eax + edi + 2;
        eax = caml_alloc_string (eax);
        *((ebp - 0x3c)) = eax;
        edx = *((ebp + 8));
        memmove (eax, edx, ebx);
        eax = ebx;
        eax += *((ebp - 0x3c));
        *(eax) = 0x203a;
        eax = *((ebp - 0x3c));
        eax = ebx + eax + 2;
        memmove (eax, esi, edi);
    }
    eax = *((ebp - 0x3c));
    return caml_raise_sys_error (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050ad0 */
#include <stdint.h>
 
int32_t camlArray_find_init_1077 (void) {
    do {
        ebx = eax;
        if (ebx == 1) {
            goto label_1;
        }
        eax = *((ebx + 4));
        ecx = *(ebx);
        edx = *((ecx - 4));
        esi = *((ecx - 4));
        esi &= 0xff;
        if (esi != 0xfe) {
            edx >>= 9;
        } else {
            edx >>= 0xa;
        }
        edx |= 1;
        if (edx > 1) {
            eax = *((ecx - 4));
            if (eax != 0xfe) {
                eax = *(ecx);
            } else {
label_0:
                eax = caml_young_ptr;
                eax -= 0xc;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_2;
                }
                eax = eax + 4;
                *((eax - 4)) = 0x8fd;
                *(fp_stack--) = *(ecx);
                *(eax) = fp_stack[0];
                fp_stack--;
            }
            void (*0x8052140)() ();
        }
    } while (1);
label_1:
    eax = camlArray__36;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c000 */
#include <stdint.h>
 
int32_t camlUnix_fun_2630 (void) {
    eax = unix_getegid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066064 */
#include <stdint.h>
 
int32_t caml_int32_to_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066e19 */
#include <stdint.h>
 
int32_t caml_int64_mul (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 8));
    ecx *= *((eax + 4));
    ebx = *((eax + 8));
    ebx *= *((edx + 4));
    ecx += ebx;
    eax = *((eax + 4));
    edx:eax = eax * *((edx + 4));
    edx = ecx + edx;
    caml_copy_int64 (ebx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80669d2 */
#include <stdint.h>
 
void caml_copy_int64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_ch;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    caml_alloc_custom (1, 8, 0);
    *((eax + 4)) = ebx;
    *((eax + 8)) = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fb6a */
#include <stdint.h>
 
int32_t caml_alloc_custom (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax += 3;
    eax >>= 2;
    eax++;
    if (*((ebx + 4)) == 0) {
        if (eax <= 0x100) {
            caml_alloc_small (eax, 0xff);
            *(eax) = ebx;
        }
    } else {
        eax = caml_alloc_shr (eax, 0xff);
        esi = eax;
        *(eax) = ebx;
        eax = *((ebp + 0x14));
        eax = *((ebp + 0x10));
        caml_adjust_gc_speed (eax, eax);
        caml_check_urgent_gc (esi);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a5e1 */
#include <stdint.h>
 
int32_t caml_output_value_to_buffer (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    *(obj.extern_userprovided_output) = eax;
    *(obj.extern_ptr) = eax;
    edx = *((ebp + 0x10));
    edx >>= 1;
    eax += edx;
    *(obj.extern_limit) = eax;
    edx = *((ebp + 0x18));
    eax = *((ebp + 0x14));
    extern_value ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062d50 */
#include <stdint.h>
 
uint32_t caml_init_signals (void) {
    int32_t var_a0h;
    int32_t var_9ch;
    int32_t var_1ch;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    struct sigaction * act;
    struct sigaction * oldact;
    *((ebp - 0x14)) = 0x807ce60;
    *((ebp - 0xc)) = 0x2000;
    *((ebp - 0x10)) = 0;
    *((ebp - 0xa0)) = 0x8062e7f;
    *((ebp - 0x1c)) = 0x48000000;
    ebx = ebp - 0xa0;
    eax = ebp - 0x9c;
    *(esp) = eax;
    sigemptyset ();
    *(obj.system_stack_top) = ebx;
    *((esp + 4)) = 0;
    eax = ebp - 0x14;
    *(esp) = eax;
    eax = sigaltstack ();
    if (eax == 0) {
        sigaction (0xb, ebx, 0);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a134 */
#include <stdint.h>
 
void sigaltstack (void) {
    sigaltstack ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80696ed */
#include <stdint.h>
 
uint32_t caml_open_descriptor_in (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    esi = *((ebp + 8));
    eax = caml_stat_alloc (ebx, esi);
    ebx = eax;
    *(eax) = esi;
    caml_enter_blocking_section ();
    *((esp + 0xc)) = 1;
    *((esp + 4)) = 0;
    *((esp + 8)) = 0;
    *(esp) = esi;
    eax = lseek64 ();
    *((ebx + 4)) = eax;
    *((ebx + 8)) = edx;
    caml_leave_blocking_section ();
    eax = ebx + 0x34;
    *((ebx + 0x14)) = eax;
    *((ebx + 0x10)) = eax;
    eax = ebx + 0x1034;
    *((ebx + 0xc)) = eax;
    *((ebx + 0x18)) = 0;
    *((ebx + 0x24)) = 0;
    *((ebx + 0x28)) = 0;
    *((ebx + 0x2c)) = 0;
    *((ebx + 0x30)) = 0;
    eax = caml_all_opened_channels;
    *((ebx + 0x1c)) = eax;
    *((ebx + 0x20)) = 0;
    eax = caml_all_opened_channels;
    if (eax != 0) {
        *((eax + 0x20)) = ebx;
    }
    *(obj.caml_all_opened_channels) = ebx;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050040 */
#include <stdint.h>
 
uint32_t camlPervasives_prerr_int_1281 (void) {
    eax = camlPervasives_string_of_int_1130 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fa30 */
#include <stdint.h>
 
int32_t camlPervasives_string_of_int_1130 (void) {
    eax = caml_format_int;
    caml_c_call (loc.camlPervasives__96);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b340 */
#include <stdint.h>
 
int32_t camlPrintf_index_of_literal_position_1044 (void) {
    eax += 0xfffffffe;
    return camlPrintf_index_of_int_1037 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80705a4 */
#include <stdint.h>
 
int32_t loc_caml_raise_exn (int32_t arg_4h) {
    if ((*(obj.caml_backtrace_active) & 1) == 0) {
        esp = caml_exception_pointer;
        return;
    }
    esi = eax;
    edi = caml_exception_pointer;
    eax = *(esp);
    edx = esp + 4;
    caml_stash_backtrace (esi, eax, edx, edi);
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80702f9 */
#include <stdint.h>
 
int32_t caml_stash_backtrace (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, uint32_t arg_14h) {
    eax = *((ebp + 8));
    ebx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    if (eax != *(obj.caml_backtrace_last_exn)) {
        *(obj.caml_backtrace_pos) = 0;
        *(obj.caml_backtrace_last_exn) = eax;
    }
    if (*(obj.caml_backtrace_buffer) == 0) {
        eax = malloc (0x1000);
        *(obj.caml_backtrace_buffer) = eax;
        if (eax == 0) {
            goto label_1;
        }
    }
    if (*(obj.caml_frame_descriptors) == 0) {
        caml_init_frame_descriptors ();
    }
label_0:
    edi = caml_frame_descriptors_mask;
    edx = ebx;
    edx >>= 3;
    edx &= edi;
    ecx = caml_frame_descriptors;
    eax = *((ecx + edx*4));
    if (eax == 0) {
        goto label_1;
    }
    if (*(eax) != ebx) {
        goto label_2;
    }
    goto label_3;
    do {
        if (*(eax) == ebx) {
            goto label_3;
        }
label_2:
        edx++;
        edx &= edi;
        eax = *((ecx + edx*4));
    } while (eax != 0);
    goto label_1;
label_3:
    if (*((eax + 4)) != 0xffff) {
        edx = caml_backtrace_pos;
        if (edx > 0x3ff) {
            goto label_1;
        }
        ecx = caml_backtrace_buffer;
        *((ecx + edx*4)) = eax;
        edx++;
        *(obj.caml_backtrace_pos) = edx;
        eax = *((eax + 4));
        eax &= 0xfffc;
        esi += eax;
        ebx = *((esi - 4));
    } else {
        eax = esi + 8;
        esi = *(eax);
        ebx = *((eax + 4));
        if (esi == 0) {
            goto label_1;
        }
    }
    if (esi <= *((ebp + 0x14))) {
        goto label_0;
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x807042c */
#include <stdint.h>
 
int32_t loc_caml_call_gc (int32_t arg_4h) {
    eax = *(esp);
    *(obj.caml_last_return_address) = eax;
    eax = esp + 4;
    *(obj.caml_bottom_of_stack) = eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062f4b */
#include <stdint.h>
 
int32_t caml_garbage_collection (void) {
    eax = caml_young_start;
    *(obj.caml_young_limit) = eax;
    if (eax <= *(obj.caml_young_ptr)) {
        eax = caml_force_major_slice;
        if (eax == 0) {
            goto label_0;
        }
    }
    caml_minor_collection ();
label_0:
    caml_process_pending_signals ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f900 */
#include <stdint.h>
 
uint32_t camlPervasives_5e_1112 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
    *((esp + 4)) = edx;
    *((esp + 0xc)) = ebx;
    ecx = *((edx - 4));
    ecx >>= 0xa;
    eax = ecx*4 - 1;
    ecx = *((edx + eax));
    eax -= ecx;
    eax = eax + eax + 1;
    *(esp) = eax;
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    ebx = *((ebx + ecx));
    ecx -= ebx;
    ebx = ecx + ecx + 1;
    *((esp + 8)) = ebx;
    eax = caml_create_string;
    eax = caml_c_call (eax + ebx - 1);
    ebx = eax;
    esi = *(esp);
    eax = *((esp + 0x14));
    caml_blit_string (eax, 1, ebx, 1, esi);
    eax = *((esp + 8));
    eax = *((esp + 0x1c));
    caml_blit_string (eax, 1, ebx, esi, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067beb */
#include <stdint.h>
 
int32_t caml_blit_string (int32_t arg_8h, int32_t arg_ch, void * s1, int32_t arg_14h, int32_t arg_18h) {
    void * s2;
    size_t n;
    eax = *((ebp + 0x18));
    eax >>= 1;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    eax = *((ebp + 0x14));
    eax >>= 1;
    eax += *((ebp + 0x10));
    memmove (eax, eax, eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e05f */
#include <stdint.h>
 
int32_t unix_getpwnam (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15199;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getpwnam ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_passwd_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a834 */
#include <stdint.h>
 
void getpwnam (void) {
    getpwnam ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061e77 */
#include <stdint.h>
 
void caml_raise_not_found (void) {
    return caml_raise_constant (loc.caml_exn_Not_found);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070426 */
#include <stdint.h>
 
void caml_debugger_cleanup_fork (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80661a0 */
#include <stdint.h>
 
int32_t caml_nativeint_to_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067b6d */
#include <stdint.h>
 
uint32_t caml_is_printable (int32_t arg_8h) {
    char * locale;
    if (*(obj.locale_is_set.2848) == 0) {
        setlocale (0, 0x8071d88);
        *(obj.locale_is_set.2848) = 1;
    }
    eax = ctype_b_loc ();
    edx = *((ebp + 8));
    edx >>= 1;
    eax = *(eax);
    eax = *((eax + edx*2));
    eax &= 0x4000;
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a424 */
#include <stdint.h>
 
void setlocale (void) {
    setlocale ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a2d4 */
#include <stdint.h>
 
void ctype_b_loc (void) {
    ctype_b_loc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80549a0 */
#include <stdint.h>
 
int32_t camlList_exists_1141 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t) (edx, eax);
        if (eax != 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c040 */
#include <stdint.h>
 
int32_t camlUnix_fun_2638 (void) {
    eax = unix_getuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b6b0 */
#include <stdint.h>
 
int32_t camlSource_echo_client_1311 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = unix_socket;
    eax = caml_c_call (3);
    *((esp + 8)) = eax;
    eax = "127.0.0.1";
    eax = unix_inet_addr_of_string;
    eax = caml_c_call (eax);
    ecx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x801;
    *(ebx) = ecx;
    eax = *(esp);
    *((ebx + 4)) = eax;
    eax = *((esp + 0xc));
    eax = unix_connect;
    caml_c_call (eax);
    ebx = camlSource;
    eax = *((ebx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ebx = *((ebx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    *((esp + 0x10)) = eax;
    eax = caml_create_string;
    eax = caml_c_call (0x81);
    ecx = 3;
    ebx = *((esp + 4));
    if (ecx > ebx) {
        goto label_2;
    }
    do {
        ecx = 1;
        ebx = camlSource;
        eax = *((esp + 8));
        edx = *((esp + 0x10));
        camlSource_sock_write_1298 (ecx, ebx);
        eax = *((esp + 0x14));
        ebx = *((esp + 8));
        eax = camlSource_sock_readline_1304 ();
        *((esp + 0xc)) = eax;
        ebx = *((esp + 0x10));
        if (eax == ebx) {
            ebx += 0xfffffffe;
            eax = *((esp + 0x14));
            eax = camlSource_buf_ok_1308 ();
            if (eax != 1) {
                goto label_3;
            }
        }
        ebx = 1;
        eax = *((esp + 0x14));
        ecx = *((esp + 0xc));
        eax = camlString_sub_1046 ();
        ebx = eax;
        eax = "client got bad data: ";
        camlPervasives_$5e_1112 ();
        camlPervasives_failwith_1010 ();
label_3:
        eax = *(esp);
        ebx = *(esp);
        eax += 2;
        *(esp) = eax;
        eax = *((esp + 4));
    } while (ebx != eax);
label_2:
    eax = *((esp + 8));
    eax = unix_close;
    caml_c_call (eax);
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80692ba */
#include <stdint.h>
 
uint32_t caml_ml_output_char (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebx + 0x10));
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = *((ebp + 0xc));
    edx >>= 1;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d0b0 */
#include <stdint.h>
 
int32_t camlUnix_getnameinfo_emulation_1772 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = *((eax - 4));
    if (ecx != 0) {
        *((esp + 8)) = ebx;
        ecx = *((eax + 4));
        *((esp + 4)) = ecx;
        eax = *(eax);
        eax = fcn_0804d160 (eax);
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 5;
            ebx = *((esp + 8));
            eax = camlList_mem_1161 ();
            if (eax != 1) {
label_2:
                eax = caml_young_ptr;
                eax -= 8;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_3;
                }
                eax = eax + 4;
                *((eax - 4)) = 0x400;
                *(eax) = loc.caml_exn_Not_found;
                caml_raise_exn ();
            }
            eax = *(esp);
            eax = unix_string_of_inet_addr;
            caml_c_call (eax);
        } else {
            eax = caml_raise_exn ();
        }
        *(esp) = eax;
        eax = void (*0x804d210)() ();
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            eax = *((esp + 4));
            eax = camlPervasives_string_of_int_1130 ();
            ecx = eax;
        } else {
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            eax = 7;
            ebx = *((esp + 0x10));
            eax = camlList_mem_1161 (*(obj.caml_exception_pointer));
            if (eax != 1) {
label_1:
                eax = caml_young_ptr;
                eax -= 8;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_4;
                }
                eax = eax + 4;
                *((eax - 4)) = 0x400;
                *(eax) = loc.caml_exn_Not_found;
                caml_raise_exn ();
            }
            eax = 9;
            ebx = *((esp + 0x10));
            eax = camlList_mem_1161 ();
            if (eax != 1) {
                eax = loc.camlUnix__194;
            } else {
                eax = loc.camlUnix__193;
            }
            eax = *((esp + 0x10));
            eax = unix_getservbyport;
            eax = caml_c_call (eax);
            ecx = *(eax);
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        *((eax + 4)) = ecx;
        return eax;
    }
    ebx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = loc.camlUnix__192;
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804add0 */
#include <stdint.h>
 
int32_t caml_curry7_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b350 */
#include <stdint.h>
 
int32_t caml_curry3_2 (void) {
    ecx = eax;
    eax = *((ebx + 0xc));
    edx = *((eax + 0xc));
    ebx = *((ebx + 8));
    eax = *((eax + 8));
    esi = *((edx + 8));
    return void (*esi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b4f0 */
#include <stdint.h>
 
uint32_t caml_apply3 (void) {
    int32_t var_4h;
    esi = *((edx + 4));
    if (esi == 7) {
        esi = *((edx + 8));
        void (*esi)() ();
    }
    ecx = *(edx);
    ebx = edx;
    eax = void (*ecx)(uint32_t, uint32_t) (ebx, ecx);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 4));
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ceb4 */
#include <stdint.h>
 
int32_t unix_fchown (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16344;
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = fchown ();
    if (eax == -1) {
        eax = ebx - 0x25a9;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049ff4 */
#include <stdint.h>
 
void fchown (void) {
    fchown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806124c */
#include <stdint.h>
 
uint32_t uerror (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x11fac;
    eax = errno_location ();
    edx = *((ebp + 0xc));
    edx = *((ebp + 8));
    eax = *(eax);
    return unix_error (eax, edx, edx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049df4 */
#include <stdint.h>
 
void errno_location (void) {
    errno_location ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806114f */
#include <stdint.h>
 
int32_t unix_error (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_34h_2;
    int32_t var_14h_2;
    int32_t var_10h_2;
    int32_t var_ch_3;
    int32_t var_bp_8h;
    int32_t var_bp_4h;
    int32_t var_ch_2;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h_2;
    int32_t var_8h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x120a9;
    eax = *((ebp + 0x10));
    *((ebp - 0xc)) = 1;
    *((ebp - 0x10)) = 1;
    *((ebp - 0x14)) = 1;
    edx = *((ebx - 0x18));
    ecx = *(edx);
    *((ebp - 0x34)) = ecx;
    ecx = ebp - 0x34;
    *(edx) = ecx;
    *((ebp - 0x2c)) = 1;
    *((ebp - 0x30)) = 3;
    edx = ebp - 0xc;
    *((ebp - 0x28)) = edx;
    edx = ebp - 0x10;
    *((ebp - 0x24)) = edx;
    edx = ebp - 0x14;
    *((ebp - 0x20)) = edx;
    if (eax == 0) {
        eax = ebx - 0x147c;
        eax = caml_copy_string (eax);
    }
    *((ebp - 0x14)) = eax;
    eax = *((ebp + 0xc));
    eax = caml_copy_string (eax);
    *((ebp - 0xc)) = eax;
    eax = *((ebp + 8));
    eax = unix_error_of_code (eax);
    *((ebp - 0x10)) = eax;
    if (*((ebx + 0x99b8)) == 0) {
        eax = ebx - 0x21cc;
        eax = caml_named_value (eax);
        *((ebx + 0x99b8)) = eax;
        if (eax != 0) {
            goto label_0;
        }
        eax = ebx - 0x21bc;
        caml_invalid_argument (eax);
    }
label_0:
    caml_alloc_small (4, 0);
    edx = *((ebx + 0x99b8));
    edx = *(edx);
    *(eax) = edx;
    edx = *((ebp - 0x10));
    *((eax + 4)) = edx;
    edx = *((ebp - 0xc));
    *((eax + 8)) = edx;
    edx = *((ebp - 0x14));
    *((eax + 0xc)) = edx;
    ecx = *((ebp - 0x34));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a3e4 */
#include <stdint.h>
 
void unlink (void) {
    unlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060881 */
#include <stdint.h>
 
uint32_t unix_stat (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x12976;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = xstat64 ();
    if (eax == -1) {
        eax = ebx - 0x231d;
        uerror (eax, esi);
    }
    if (*((ebp - 0x38)) >= 0) {
        if (*((ebp - 0x38)) <= 0) {
            if (*((ebp - 0x3c)) <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = *((ebp - 0x58));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        eax = ebx - 0x231d;
        unix_error (0x4b, eax, esi);
    }
label_0:
    edx = ebp - 0x68;
    eax = 0;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fad0 */
#include <stdint.h>
 
int32_t camlPervasives_40_1143 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        edx = *((eax + 4));
        ecx = *(eax);
        eax = edx;
        eax = camlPervasives_$40_1143 (ecx);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *(esp);
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c2b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2710 (void) {
    eax = unix_dup;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804e0f0 */
#include <stdint.h>
 
int32_t camlUnix_close_process_full_2013 (int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = ecx;
    esi = ebx;
    *((esp + 0xc)) = esi;
    edx = eax;
    *(esp) = edx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc03;
            *(ebx) = edx;
            *((ebx + 4)) = esi;
            *((ebx + 8)) = ecx;
            eax = "close_process_full";
            eax = camlUnix_find_proc_id_1997 ();
            *((esp + 8)) = eax;
            eax = *(esp);
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = void (*0x804e170)() ();
            ecx = loc.caml_exn_Sys_error;
            ebx = *(eax);
            if (ebx != ecx) {
                caml_raise_exn ();
                *(obj.caml_exception_pointer) = esp;
                eax = *((esp + 0x14));
                camlPervasives_close_out_1209 (*(obj.caml_exception_pointer));
            }
            eax = *((esp + 4));
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = *((esp + 8));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804de40 */
#include <stdint.h>
 
uint32_t camlUnix_find_proc_id_1997 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = void (*0x804deb0)(uint32_t, uint32_t) (eax, ebx);
    ecx = loc.caml_exn_Not_found;
    ebx = *(eax);
    while (1) {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1000;
            ebx = camlUnix;
            *(eax) = ebx;
            *((eax + 4)) = 7;
            ebx = *((esp + 4));
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = 0x8074cc4;
            caml_raise_exn ();
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            eax = .comment;
            eax = camlHashtbl_find_1093 (*(obj.caml_exception_pointer));
            eax = .comment;
            ebx = *((esp + 0x10));
            camlHashtbl_remove_1080 (eax);
            eax = *(esp);
            return eax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8057a40 */
#include <stdint.h>
 
int32_t camlHashtbl_find_1093 (void) {
    int32_t var_4h_6;
    int32_t var_8h_5;
    edi = eax;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = caml_hash_univ_param (0x15, 0xc9, ebx);
        eax >>= 1;
        ecx = esi;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    ecx = *((edi + 4));
    eax = *((ecx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    ecx = *((ecx + edx*2 - 2));
    if (ecx == 1) {
        goto label_3;
    }
    *((esp + 4)) = ebx;
    eax = *((ecx + 8));
    *(esp) = eax;
    eax = *((ecx + 4));
    *((esp + 8)) = eax;
    eax = *(ecx);
    eax = caml_compare;
    eax = caml_c_call (ebx);
    if (eax == 1) {
        eax = *((esp + 8));
        return eax;
    }
    eax = *(esp);
    if (eax != 1) {
        ebx = *((eax + 8));
        *(esp) = ebx;
        ebx = *((eax + 4));
        *((esp + 8)) = ebx;
        eax = *(eax);
        eax = *((esp + 8));
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        if (eax != 1) {
            ebx = *((eax + 8));
            *(esp) = ebx;
            ebx = *((eax + 4));
            *((esp + 8)) = ebx;
            eax = *(eax);
            eax = *((esp + 8));
            eax = caml_compare;
            eax = caml_c_call (eax);
            if (eax == 1) {
                eax = *((esp + 8));
                return eax;
            }
            eax = *((esp + 4));
            ebx = *(esp);
            void (*0x80579b0)() ();
        }
label_1:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x400;
        *(eax) = loc.caml_exn_Not_found;
        caml_raise_exn ();
    }
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = loc.caml_exn_Not_found;
    caml_raise_exn ();
    do {
label_3:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80578d0 */
#include <stdint.h>
 
int32_t camlHashtbl_remove_1080 (void) {
    int32_t var_8h;
    int32_t var_ch;
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.camlHashtbl__remove_bucket_1083;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = edi;
            *((ebx + 0xc)) = ecx;
            eax = *((edi + 4));
            esi = *((eax - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = caml_hash_univ_param (0x15, 0xc9, ecx);
                eax >>= 1;
                ecx = esi;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            *((esp + 4)) = edx;
            eax = *((edi + 4));
            *(esp) = eax;
            eax = *((eax - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            ecx = *((edi + 4));
            eax = *((ecx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_1;
            }
            eax = *((ecx + edx*2 - 2));
            eax = camlHashtbl_remove_bucket_1083 ();
            ebx = *((esp + 4));
            eax = *((esp + 8));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fc50 */
#include <stdint.h>
 
int32_t camlPervasives_close_out_1209 (void) {
    *(esp) = eax;
    eax = caml_ml_flush;
    caml_c_call (eax);
    eax = *(esp);
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804df00 */
#include <stdint.h>
 
uint32_t camlUnix_waitpid_non_intr_2001 (void) {
    do {
        eax = void (*0x804df40)(uint32_t) (eax);
        ecx = camlUnix;
        ebx = *(eax);
        if (ebx != ecx) {
            goto label_0;
        }
        ebx = *((eax + 4));
        if ((ebx & 1) == 0) {
            goto label_0;
        }
        if (ebx != 0x17) {
            goto label_0;
        }
        eax = *(esp);
    } while (1);
label_0:
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_waitpid;
    caml_c_call (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d740 */
#include <stdint.h>
 
int32_t camlUnix_open_proc_1949 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    ebx = esi;
    eax = .comment;
    eax = camlList_for_all_1137 (ebx, eax, ebx);
    *(esp) = eax;
    eax = unix_fork;
    eax = caml_c_call (1);
    ecx = eax;
    if (ecx != 1) {
        eax = .comment;
        ebx = *((esp + 0x14));
        void (*0x80577e0)() ();
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        *((esp + 0x10)) = eax;
        eax = unix_dup2;
        caml_c_call (eax);
        eax = *((esp + 0x10));
        eax = unix_close;
        caml_c_call (eax);
    }
    eax = *((esp + 0xc));
    if (eax != 3) {
        *((esp + 0xc)) = eax;
        eax = unix_dup2;
        caml_c_call (eax);
        eax = *((esp + 0xc));
        eax = unix_close;
        caml_c_call (eax);
    }
    eax = *(esp);
    if (eax == 1) {
        eax = loc.camlUnix__188;
        ebx = *((esp + 8));
        camlList_iter_1074 ();
    }
    fcn_0804d820 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c020 */
#include <stdint.h>
 
int32_t camlUnix_fun_2634 (void) {
    eax = unix_setuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063449 */
#include <stdint.h>
 
int32_t caml_fl_add_blocks (int32_t arg_8h) {
    eax = *((ebp + 8));
    edx = *((eax - 4));
    edx >>= 0xa;
    ecx = caml_fl_cur_size;
    edx = ecx + edx + 1;
    *(obj.caml_fl_cur_size) = edx;
    edx = fl_last;
    if (eax > edx) {
        *(edx) = eax;
        if (edx == *(obj.caml_fl_merge)) {
            if (eax >= *(obj.caml_gc_sweep_hp)) {
                goto label_0;
            }
            eax = *((eax + 4));
            *(obj.caml_fl_merge) = eax;
        }
label_0:
        if (*(obj.caml_allocation_policy) != 1) {
            goto label_1;
        }
        eax = flp_size;
        if (eax > 0x3e7) {
            goto label_1;
        }
        *((eax*4 + obj.flp)) = edx;
        eax++;
        *(obj.flp_size) = eax;
        goto label_1;
    }
    ecx = .comment;
    if (ecx != 0) {
        if (eax > ecx) {
            goto label_2;
        }
    }
    ebx = 0x807ca48;
    goto label_3;
    do {
        ecx = edx;
label_2:
        edx = *(ecx);
        if (edx == 0) {
            goto label_4;
        }
    } while (eax > edx);
label_4:
    ebx = ecx;
    ecx = edx;
label_3:
    edx = eax + 4;
    esi = *(edx);
    *(esi) = ecx;
    *(ebx) = eax;
    if (ebx == *(obj.caml_fl_merge)) {
        if (eax >= *(obj.caml_gc_sweep_hp)) {
            goto label_5;
        }
        edx = *(edx);
        *(obj.caml_fl_merge) = edx;
    }
label_5:
    if (*(obj.caml_allocation_policy) == 1) {
        truncate_flp ();
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806d529 */
#include <stdint.h>
 
uint32_t rotate_right32 (uint32_t value, uint32_t count) {
    const uint32_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
int32_t caml_MD5Transform (void * arg_8h, void * arg_ch) {
    int32_t var_64h;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    edx = *(edx);
    *((ebp - 0x5c)) = edx;
    ecx = *((ebp + 8));
    ecx += 4;
    *((ebp - 0x54)) = ecx;
    esi = *(ecx);
    ebx = *((ebp + 8));
    ebx += 8;
    *((ebp - 0x50)) = ebx;
    ecx = *(ebx);
    edi = *((ebp + 8));
    edi += 0xc;
    *((ebp - 0x4c)) = edi;
    edx = *(edi);
    ebx = *(eax);
    *((ebp - 0x48)) = ebx;
    edi = *((ebp - 0x5c));
    edi = edi + ebx - 0x28955b88;
    ebx = edx;
    ebx ^= ecx;
    ebx &= esi;
    ebx ^= edx;
    ebx += edi;
    ebx = rotate_right32 (ebx, 0x19);
    ebx += esi;
    edi = *((eax + 4));
    *((ebp - 0x44)) = edi;
    edx = edx + edi - 0x173848aa;
    *((ebp - 0x10)) = edx;
    edx = ecx;
    edx ^= esi;
    edx &= ebx;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += ebx;
    edi = *((eax + 8));
    *((ebp - 0x40)) = edi;
    ecx = ecx + edi + 0x242070db;
    *((ebp - 0x10)) = ecx;
    ecx = ebx;
    ecx ^= esi;
    ecx &= edx;
    ecx ^= esi;
    ecx += *((ebp - 0x10));
    ecx = rotate_right32 (ecx, 0xf);
    ecx += edx;
    edi = *((eax + 0xc));
    *((ebp - 0x3c)) = edi;
    esi = esi + edi - 0x3e423112;
    *((ebp - 0x10)) = esi;
    esi = edx;
    esi ^= ebx;
    esi &= ecx;
    esi ^= ebx;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0xa);
    esi += ecx;
    edi = *((eax + 0x10));
    *((ebp - 0x38)) = edi;
    ebx = ebx + edi - 0xa83f051;
    *((ebp - 0x10)) = ebx;
    ebx = ecx;
    ebx ^= edx;
    ebx &= esi;
    ebx ^= edx;
    ebx += *((ebp - 0x10));
    ebx = rotate_right32 (ebx, 0x19);
    ebx += esi;
    edi = *((eax + 0x14));
    *((ebp - 0x34)) = edi;
    edx = edx + edi + 0x4787c62a;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx ^= ecx;
    edx &= ebx;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += ebx;
    edi = *((eax + 0x18));
    *((ebp - 0x30)) = edi;
    ecx = ecx + edi - 0x57cfb9ed;
    *((ebp - 0x10)) = ecx;
    ecx = ebx;
    ecx ^= esi;
    ecx &= edx;
    ecx ^= esi;
    ecx += *((ebp - 0x10));
    ecx = rotate_right32 (ecx, 0xf);
    ecx += edx;
    edi = *((eax + 0x1c));
    *((ebp - 0x2c)) = edi;
    esi = esi + edi - 0x2b96aff;
    *((ebp - 0x10)) = esi;
    esi = edx;
    esi ^= ebx;
    esi &= ecx;
    esi ^= ebx;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0xa);
    esi += ecx;
    edi = *((eax + 0x20));
    *((ebp - 0x28)) = edi;
    ebx = ebx + edi + 0x698098d8;
    *((ebp - 0x10)) = ebx;
    ebx = ecx;
    ebx ^= edx;
    ebx &= esi;
    ebx ^= edx;
    ebx += *((ebp - 0x10));
    ebx = rotate_right32 (ebx, 0x19);
    ebx += esi;
    edi = *((eax + 0x24));
    *((ebp - 0x24)) = edi;
    edx = edx + edi - 0x74bb0851;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx ^= ecx;
    edx &= ebx;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += ebx;
    edi = *((eax + 0x28));
    *((ebp - 0x20)) = edi;
    ecx = ecx + edi - 0xa44f;
    *((ebp - 0x10)) = ecx;
    ecx = ebx;
    ecx ^= esi;
    ecx &= edx;
    ecx ^= esi;
    ecx += *((ebp - 0x10));
    ecx = rotate_right32 (ecx, 0xf);
    ecx += edx;
    edi = *((eax + 0x2c));
    *((ebp - 0x1c)) = edi;
    esi = esi + edi - 0x76a32842;
    *((ebp - 0x10)) = esi;
    esi = edx;
    esi ^= ebx;
    esi &= ecx;
    esi ^= ebx;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0xa);
    esi += ecx;
    edi = *((eax + 0x30));
    *((ebp - 0x18)) = edi;
    ebx = ebx + edi + 0x6b901122;
    edi = ecx;
    edi ^= edx;
    edi &= esi;
    edi ^= edx;
    edi = ebx + edi;
    edi = rotate_right32 (edi, 0x19);
    edi += esi;
    ebx = *((eax + 0x34));
    *((ebp - 0x14)) = ebx;
    edx = edx + ebx - 0x2678e6d;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx ^= ecx;
    edx &= edi;
    edx ^= ecx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x14);
    edx += edi;
    ebx = *((eax + 0x38));
    *((ebp - 0x10)) = ebx;
    ecx = ecx + ebx - 0x5986bc72;
    ebx = edi;
    ebx ^= esi;
    ebx &= edx;
    ebx ^= esi;
    ebx = ecx + ebx;
    ebx = rotate_right32 (ebx, 0xf);
    ebx += edx;
    ecx = *((eax + 0x3c));
    eax = esi + ecx + 0x49b40821;
    esi = edx;
    esi ^= edi;
    esi &= ebx;
    esi ^= edi;
    esi = eax + esi;
    esi = rotate_right32 (esi, 0xa);
    esi += ebx;
    eax = *((ebp - 0x44));
    edi = edi + eax - 0x9e1da9e;
    eax = esi;
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax = edi + eax;
    eax = rotate_right32 (eax, 0x1b);
    eax += esi;
    edi = *((ebp - 0x30));
    edx = edx + edi - 0x3fbf4cc0;
    *((ebp - 0x58)) = edx;
    edx = eax;
    edx ^= esi;
    edx &= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    edi = *((ebp - 0x1c));
    ebx = ebx + edi + 0x265e5a51;
    *((ebp - 0x58)) = ebx;
    ebx = edx;
    ebx ^= eax;
    ebx &= esi;
    ebx ^= eax;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = *((ebp - 0x48));
    esi = esi + edi - 0x16493856;
    *((ebp - 0x58)) = esi;
    esi = ebx;
    esi ^= edx;
    esi &= eax;
    esi ^= edx;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0xc);
    esi += ebx;
    edi = *((ebp - 0x34));
    eax = eax + edi - 0x29d0efa3;
    *((ebp - 0x58)) = eax;
    eax = esi;
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax += *((ebp - 0x58));
    eax = rotate_right32 (eax, 0x1b);
    eax += esi;
    edi = *((ebp - 0x20));
    edx = edx + edi + 0x2441453;
    *((ebp - 0x58)) = edx;
    edx = eax;
    edx ^= esi;
    edx &= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    edi = ebx + ecx - 0x275e197f;
    ebx = edx;
    ebx ^= eax;
    ebx &= esi;
    ebx ^= eax;
    ebx = edi + ebx;
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = *((ebp - 0x38));
    esi = esi + edi - 0x182c0438;
    *((ebp - 0x58)) = esi;
    esi = ebx;
    esi ^= edx;
    esi &= eax;
    esi ^= edx;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0xc);
    esi += ebx;
    edi = *((ebp - 0x24));
    eax = eax + edi + 0x21e1cde6;
    *((ebp - 0x58)) = eax;
    eax = esi;
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax += *((ebp - 0x58));
    eax = rotate_right32 (eax, 0x1b);
    eax += esi;
    edi = *((ebp - 0x10));
    edx = edx + edi - 0x3cc8f82a;
    *((ebp - 0x58)) = edx;
    edx = eax;
    edx ^= esi;
    edx &= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    edi = *((ebp - 0x3c));
    ebx = ebx + edi - 0xb2af279;
    *((ebp - 0x58)) = ebx;
    ebx = edx;
    ebx ^= eax;
    ebx &= esi;
    ebx ^= eax;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = *((ebp - 0x28));
    esi = esi + edi + 0x455a14ed;
    edi = ebx;
    edi ^= edx;
    edi &= eax;
    edi ^= edx;
    edi = esi + edi;
    edi = rotate_right32 (edi, 0xc);
    edi += ebx;
    *((ebp - 0x58)) = edi;
    esi = *((ebp - 0x14));
    edi = eax + esi - 0x561c16fb;
    eax = *((ebp - 0x58));
    eax ^= ebx;
    eax &= edx;
    eax ^= ebx;
    eax = edi + eax;
    eax = rotate_right32 (eax, 0x1b);
    eax += *((ebp - 0x58));
    *((ebp - 0x60)) = eax;
    edi = *((ebp - 0x40));
    eax = edx + edi - 0x3105c08;
    edx = *((ebp - 0x60));
    edx ^= *((ebp - 0x58));
    edx &= ebx;
    edx ^= *((ebp - 0x58));
    edx = eax + edx;
    edx = rotate_right32 (edx, 0x17);
    edx += *((ebp - 0x60));
    esi = *((ebp - 0x2c));
    eax = ebx + esi + 0x676f02d9;
    ebx = *((ebp - 0x60));
    ebx ^= edx;
    ebx &= *((ebp - 0x58));
    ebx ^= *((ebp - 0x60));
    ebx = eax + ebx;
    ebx = rotate_right32 (ebx, 0x12);
    ebx += edx;
    edi = ebx;
    edi ^= edx;
    *((ebp - 0x64)) = edi;
    edi = *((ebp - 0x58));
    eax = *((ebp - 0x18));
    esi = edi + eax - 0x72d5b376;
    eax = *((ebp - 0x60));
    eax &= *((ebp - 0x64));
    eax ^= edx;
    edi = esi + eax;
    edi = rotate_right32 (edi, 0xc);
    edi += ebx;
    eax = *((ebp - 0x60));
    esi = *((ebp - 0x34));
    esi = eax + esi - 0x5c6be;
    *((ebp - 0x58)) = esi;
    esi = *((ebp - 0x64));
    esi ^= edi;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0x1c);
    esi += edi;
    eax = *((ebp - 0x28));
    edx = edx + eax - 0x788e097f;
    *((ebp - 0x58)) = edx;
    edx = edi;
    edx ^= ebx;
    edx ^= esi;
    edx += *((ebp - 0x58));
    edx = rotate_right32 (edx, 0x15);
    edx += esi;
    eax = *((ebp - 0x1c));
    ebx = ebx + eax + 0x6d9d6122;
    *((ebp - 0x58)) = ebx;
    ebx = esi;
    ebx ^= edi;
    ebx ^= edx;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x10);
    ebx += edx;
    eax = *((ebp - 0x10));
    edi = edi + eax - 0x21ac7f4;
    *((ebp - 0x58)) = edi;
    edi = edx;
    edi ^= esi;
    edi ^= ebx;
    edi += *((ebp - 0x58));
    edi = rotate_right32 (edi, 9);
    edi += ebx;
    eax = *((ebp - 0x44));
    esi = esi + eax - 0x5b4115bc;
    eax = ebx;
    eax ^= edx;
    eax ^= edi;
    eax = esi + eax;
    eax = rotate_right32 (eax, 0x1c);
    eax += edi;
    esi = *((ebp - 0x38));
    edx = edx + esi + 0x4bdecfa9;
    esi = edi;
    esi ^= ebx;
    esi ^= eax;
    esi = edx + esi;
    esi = rotate_right32 (esi, 0x15);
    esi += eax;
    edx = *((ebp - 0x2c));
    ebx = ebx + edx - 0x944b4a0;
    *((ebp - 0x58)) = ebx;
    ebx = eax;
    ebx ^= edi;
    ebx ^= esi;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 0x10);
    ebx += esi;
    edx = *((ebp - 0x20));
    edi = edi + edx - 0x41404390;
    edx = esi;
    edx ^= eax;
    edx ^= ebx;
    edx = edi + edx;
    edx = rotate_right32 (edx, 9);
    edx += ebx;
    edi = *((ebp - 0x14));
    eax = eax + edi + 0x289b7ec6;
    edi = ebx;
    edi ^= esi;
    edi ^= edx;
    edi = eax + edi;
    edi = rotate_right32 (edi, 0x1c);
    edi += edx;
    eax = *((ebp - 0x48));
    esi = esi + eax - 0x155ed806;
    *((ebp - 0x58)) = esi;
    esi = edx;
    esi ^= ebx;
    esi ^= edi;
    esi += *((ebp - 0x58));
    esi = rotate_right32 (esi, 0x15);
    esi += edi;
    eax = *((ebp - 0x3c));
    ebx = ebx + eax - 0x2b10cf7b;
    eax = edi;
    eax ^= edx;
    eax ^= esi;
    eax = ebx + eax;
    eax = rotate_right32 (eax, 0x10);
    eax += esi;
    ebx = *((ebp - 0x30));
    edx = edx + ebx + 0x4881d05;
    ebx = esi;
    ebx ^= edi;
    ebx ^= eax;
    ebx = edx + ebx;
    ebx = rotate_right32 (ebx, 9);
    ebx += eax;
    edx = *((ebp - 0x24));
    edi = edi + edx - 0x262b2fc7;
    *((ebp - 0x58)) = edi;
    edi = eax;
    edi ^= esi;
    edi ^= ebx;
    edi += *((ebp - 0x58));
    edi = rotate_right32 (edi, 0x1c);
    edi += ebx;
    edx = *((ebp - 0x18));
    esi = esi + edx - 0x1924661b;
    edx = ebx;
    edx ^= eax;
    edx ^= edi;
    edx = esi + edx;
    edx = rotate_right32 (edx, 0x15);
    edx += edi;
    eax = eax + ecx + 0x1fa27cf8;
    esi = edi;
    esi ^= ebx;
    esi ^= edx;
    esi = eax + esi;
    esi = rotate_right32 (esi, 0x10);
    esi += edx;
    eax = *((ebp - 0x40));
    ebx = ebx + eax - 0x3b53a99b;
    *((ebp - 0x58)) = ebx;
    ebx = edx;
    ebx ^= edi;
    ebx ^= esi;
    ebx += *((ebp - 0x58));
    ebx = rotate_right32 (ebx, 9);
    ebx += esi;
    eax = *((ebp - 0x48));
    edi = edi + eax - 0xbd6ddbc;
    eax = edx;
    eax = ~eax;
    eax |= ebx;
    eax ^= esi;
    eax = edi + eax;
    eax = rotate_right32 (eax, 0x1a);
    eax += ebx;
    edi = *((ebp - 0x2c));
    edx = edx + edi + 0x432aff97;
    *((ebp - 0x2c)) = edx;
    edx = esi;
    edx = ~edx;
    edx |= eax;
    edx ^= ebx;
    edx += *((ebp - 0x2c));
    edx = rotate_right32 (edx, 0x16);
    edx += eax;
    edi = *((ebp - 0x10));
    esi = esi + edi - 0x546bdc59;
    *((ebp - 0x10)) = esi;
    esi = ebx;
    esi = ~esi;
    esi |= edx;
    esi ^= eax;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0x11);
    esi += edx;
    edi = *((ebp - 0x34));
    ebx = ebx + edi - 0x36c5fc7;
    *((ebp - 0x10)) = ebx;
    ebx = eax;
    ebx = ~ebx;
    ebx |= esi;
    ebx ^= edx;
    ebx += *((ebp - 0x10));
    ebx = rotate_right32 (ebx, 0xb);
    ebx += esi;
    edi = *((ebp - 0x18));
    eax = eax + edi + 0x655b59c3;
    edi = edx;
    edi = ~edi;
    edi |= ebx;
    edi ^= esi;
    edi = eax + edi;
    edi = rotate_right32 (edi, 0x1a);
    edi += ebx;
    eax = *((ebp - 0x3c));
    edx = edx + eax - 0x70f3336e;
    *((ebp - 0x10)) = edx;
    edx = esi;
    edx = ~edx;
    edx |= edi;
    edx ^= ebx;
    edx += *((ebp - 0x10));
    edx = rotate_right32 (edx, 0x16);
    edx += edi;
    eax = *((ebp - 0x20));
    esi = esi + eax - 0x100b83;
    *((ebp - 0x10)) = esi;
    esi = ebx;
    esi = ~esi;
    esi |= edx;
    esi ^= edi;
    esi += *((ebp - 0x10));
    esi = rotate_right32 (esi, 0x11);
    esi += edx;
    eax = *((ebp - 0x44));
    ebx = ebx + eax - 0x7a7ba22f;
    eax = edi;
    eax = ~eax;
    eax |= esi;
    eax ^= edx;
    eax = ebx + eax;
    eax = rotate_right32 (eax, 0xb);
    eax += esi;
    ebx = *((ebp - 0x28));
    edi = edi + ebx + 0x6fa87e4f;
    ebx = edx;
    ebx = ~ebx;
    ebx |= eax;
    ebx ^= esi;
    ebx = edi + ebx;
    ebx = rotate_right32 (ebx, 0x1a);
    ebx += eax;
    ecx = edx + ecx - 0x1d31920;
    edx = esi;
    edx = ~edx;
    edx |= ebx;
    edx ^= eax;
    edx = ecx + edx;
    edx = rotate_right32 (edx, 0x16);
    edx += ebx;
    edi = *((ebp - 0x30));
    esi = esi + edi - 0x5cfebcec;
    ecx = eax;
    ecx = ~ecx;
    ecx |= edx;
    ecx ^= ebx;
    ecx = esi + ecx;
    ecx = rotate_right32 (ecx, 0x11);
    ecx += edx;
    edi = *((ebp - 0x14));
    esi = eax + edi + 0x4e0811a1;
    eax = ebx;
    eax = ~eax;
    eax |= ecx;
    eax ^= edx;
    eax = esi + eax;
    eax = rotate_right32 (eax, 0xb);
    eax += ecx;
    edi = *((ebp - 0x38));
    esi = ebx + edi - 0x8ac817e;
    ebx = edx;
    ebx = ~ebx;
    ebx |= eax;
    ebx ^= ecx;
    ebx = esi + ebx;
    ebx = rotate_right32 (ebx, 0x1a);
    ebx += eax;
    edi = *((ebp - 0x1c));
    esi = edx + edi - 0x42c50dcb;
    edx = ecx;
    edx = ~edx;
    edx |= ebx;
    edx ^= eax;
    edx = esi + edx;
    edx = rotate_right32 (edx, 0x16);
    edx += ebx;
    edi = *((ebp - 0x40));
    esi = ecx + edi + 0x2ad7d2bb;
    ecx = eax;
    ecx = ~ecx;
    ecx |= edx;
    ecx ^= ebx;
    ecx = esi + ecx;
    ecx = rotate_right32 (ecx, 0x11);
    ecx += edx;
    edi = *((ebp - 0x24));
    esi = eax + edi - 0x14792c6f;
    eax = ebx;
    eax = ~eax;
    eax |= ecx;
    eax ^= edx;
    eax = esi + eax;
    ebx += *((ebp - 0x5c));
    esi = *((ebp + 8));
    *(esi) = ebx;
    ebx = ecx;
    edi = *((ebp - 0x54));
    ebx += *(edi);
    eax = rotate_right32 (eax, 0xb);
    eax = ebx + eax;
    *(edi) = eax;
    eax = *((ebp - 0x50));
    *(eax) += ecx;
    ecx = *((ebp - 0x4c));
    *(ecx) += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80671be */
#include <stdint.h>
 
int32_t caml_le_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055ff0 */
#include <stdint.h>
 
int32_t camlString_uncapitalize_1106 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_apply1_1100 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80557b0 */
#include <stdint.h>
 
uint32_t camlString_copy_1042 (void) {
    int32_t var_4h;
    ecx = eax;
    *((esp + 4)) = ecx;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    *(esp) = eax;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    eax = *((esp + 0x14));
    caml_blit_string (eax, 1, ebx, 1, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056060 */
#include <stdint.h>
 
void camlString_index_1113 (void) {
    edx = ebx;
    ecx = 1;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    esi = *((eax + ebx));
    ebx -= esi;
    ebx = ebx + ebx + 1;
    return camlString_index_rec_1108 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c7f0 */
#include <stdint.h>
 
uint32_t unix_access (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t mode;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16a03;
    esi = *((ebp + 8));
    eax = ebx + 0x937c;
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, eax);
    eax = access (esi, eax);
    if (eax == -1) {
        eax = ebx - 0x2611;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065324 */
#include <stdint.h>
 
int32_t caml_convert_flag_list (int32_t arg_8h, char * arg_ch) {
    edx = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = 0;
    if (edx == 1) {
        goto label_0;
    }
    do {
        ecx = *(edx);
        ecx >>= 1;
        eax |= *((ebx + ecx*4));
        edx = *((edx + 4));
    } while (edx != 1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a204 */
#include <stdint.h>
 
void access (void) {
    access ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bb29 */
#include <stdint.h>
 
uint32_t caml_sys_get_argv (void) {
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x10)) = 0;
    *((ebp - 0x14)) = 0;
    *((ebp - 0x34)) = ebx;
    eax = ebp - 0x34;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x2c)) = 1;
    *((ebp - 0x30)) = 3;
    eax = ebp - 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x14;
    *((ebp - 0x20)) = eax;
    eax = caml_exe_name;
    eax = caml_copy_string (ebx);
    *((ebp - 0xc)) = eax;
    eax = caml_main_argv;
    eax = caml_copy_string_array (eax);
    *((ebp - 0x10)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0x14)) = eax;
    edx = *((ebp - 0xc));
    *(eax) = edx;
    edx = *((ebp - 0x10));
    eax = *((ebp - 0x14));
    *((eax + 4)) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x14));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fb90 */
#include <stdint.h>
 
int32_t camlPervasives_flush_all_1185 (void) {
    eax = loc.camlPervasives__92;
    eax = caml_ml_out_channels_list;
    caml_c_call (1);
    return camlPervasives_iter_1186 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c220 */
#include <stdint.h>
 
int32_t camlPrintf_kbprintf_1397 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlPrintf__fun_1694;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            ebp = .comment;
            esi = loc.camlPrintf__42;
            edx = .comment;
            ecx = .comment;
            eax = 1;
            *(loc.caml_extra_params) = ebp;
            void (*0x804b3e0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80569d0 */
#include <stdint.h>
 
int32_t camlHashtbl_remove_bucket_1083 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        *((esp + 8)) = ebx;
        ecx = *((eax + 8));
        *((esp + 0xc)) = ecx;
        ecx = *((eax + 4));
        *((esp + 4)) = ecx;
        eax = *(eax);
        *(esp) = eax;
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = *((esp + 8));
            eax = *((eax + 8));
            *(eax) += 0xfffffffe;
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_remove_bucket_1083 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            *((eax + 8)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806baa5 */
#include <stdint.h>
 
uint32_t caml_sys_get_config (void) {
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x10)) = 0;
    *((ebp - 0x30)) = ebx;
    eax = ebp - 0x30;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x28)) = 1;
    *((ebp - 0x2c)) = 2;
    eax = ebp - 0xc;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x20)) = eax;
    eax = caml_copy_string (ebx);
    *((ebp - 0x10)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0xc)) = eax;
    edx = *((ebp - 0x10));
    *(eax) = edx;
    eax = *((ebp - 0xc));
    *((eax + 4)) = 0x41;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c9b1 */
#include <stdint.h>
 
int32_t caml_gc_compaction (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (0x10, "Heap compaction requested\n", 0);
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    caml_final_do_calls ();
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    caml_compact_heap ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064231 */
#include <stdint.h>
 
int32_t caml_finish_major_cycle (void) {
    int32_t var_10h;
    int32_t var_ch;
    if (*(obj.caml_gc_phase) == 2) {
        start_cycle ();
    }
    if (*(obj.caml_gc_phase) != 0) {
        goto label_0;
    }
    do {
        eax = 0x7fffffff;
        mark_slice ();
    } while (*(obj.caml_gc_phase) == 0);
label_0:
    if (*(obj.caml_gc_phase) != 1) {
        goto label_1;
    }
    do {
        eax = 0x7fffffff;
        sweep_slice ();
    } while (*(obj.caml_gc_phase) == 1);
label_1:
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *(obj.caml_stat_major_words) = fp_stack[0];
    fp_stack--;
    *(obj.caml_allocated_words) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050080 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_endline_1285 (void) {
    ebx = eax;
    eax = .comment;
    camlPervasives_output_string_1191 ();
    eax = caml_ml_output_char;
    caml_c_call (*(0x8076898));
    eax = caml_ml_flush;
    caml_c_call (*(0x8076898));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fbb0 */
#include <stdint.h>
 
int32_t camlPervasives_output_string_1191 (void) {
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx + 1;
    eax = caml_ml_output;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f9b0 */
#include <stdint.h>
 
int32_t camlPervasives_string_of_bool_1127 (void) {
    if (eax != 1) {
        eax = "true";
        return eax;
    }
    eax = "false";
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c300 */
#include <stdint.h>
 
int32_t camlUnix_fun_2718 (void) {
    eax = unix_chown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806207e */
#include <stdint.h>
 
int32_t caml_init_frame_descriptors (void) {
    int32_t var_20h;
    uint32_t var_1ch;
    if (*(obj.inited.3139) != 0) {
        goto label_3;
    }
    eax = caml_frametable;
    if (eax == 0) {
        goto label_4;
    }
    ebx = 0;
    esi = caml_frametable;
    do {
        caml_register_frametable (eax);
        ebx++;
        eax = *((esi + ebx*4));
    } while (eax != 0);
label_4:
    *(obj.inited.3139) = 1;
label_3:
    eax = frametables;
    if (eax == 0) {
        goto label_5;
    }
    edx = 0;
    do {
        ecx = *(eax);
        edx += *(ecx);
        eax = *((eax + 4));
    } while (eax != 0);
    edx += edx;
    if (edx <= 4) {
        goto label_5;
    }
    ebx = 4;
    do {
        ebx += ebx;
    } while (ebx < edx);
    eax = ebx*4;
    eax = caml_stat_alloc (eax);
    *(obj.caml_frame_descriptors) = eax;
    if (ebx > 0) {
        goto label_6;
    }
    goto label_7;
    do {
label_2:
        edx = caml_frame_descriptors;
        *((edx + eax*4)) = 0;
        eax++;
    } while (eax < ebx);
label_7:
    ebx--;
    *(obj.caml_frame_descriptors_mask) = ebx;
    eax = frametables;
    *((ebp - 0x20)) = eax;
    if (eax == 0) {
        goto label_8;
    }
label_1:
    eax = *((ebp - 0x20));
    esi = *(eax);
    eax = *(esi);
    *((ebp - 0x1c)) = eax;
    if (eax <= 0) {
        goto label_9;
    }
    esi += 4;
    edi = 0;
label_0:
    ebx = caml_frame_descriptors_mask;
    eax = *(esi);
    eax >>= 3;
    eax &= ebx;
    ecx = caml_frame_descriptors;
    edx = ecx + eax*4;
    if (*(edx) == 0) {
        goto label_10;
    }
    do {
        eax++;
        eax &= ebx;
        edx = ecx + eax*4;
    } while (*(edx) != 0);
label_10:
    *(edx) = esi;
    eax = *((esi + 6));
    eax = esi + eax*2 + 0xb;
    eax &= 0xfffffffc;
    edx = eax + 8;
    if ((*((esi + 4)) & 1) != 0) {
        eax = edx;
    }
    edi++;
    if (edi != *((ebp - 0x1c))) {
        esi = eax;
        goto label_0;
    }
label_9:
    eax = *((ebp - 0x20));
    eax = *((eax + 4));
    *((ebp - 0x20)) = eax;
    if (eax != 0) {
        goto label_1;
    }
    goto label_8;
label_5:
    eax = caml_stat_alloc (0x10);
    *(obj.caml_frame_descriptors) = eax;
    ebx = 4;
label_6:
    eax = 0;
    goto label_2;
label_8:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f5a9 */
#include <stdint.h>
 
uint32_t unix_send (int32_t flags, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, void * buffer, size_t length) {
    int32_t var_401ch;
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13c44;
    eax = ebx + 0x93ec;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x401c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    edi = ebp - 0x4018;
    memmove (edi, eax, esi);
    caml_enter_blocking_section ();
    eax = *((ebp - 0x401c));
    eax = *((ebp + 8));
    eax >>= 1;
    eax = send (eax, edi, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x243e;
        uerror (eax, 0);
    }
    eax = esi + esi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a6c4 */
#include <stdint.h>
 
void send (void) {
    send ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804e330 */
#include <stdint.h>
 
int32_t camlUnix_establish_server_2026 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = ebx;
    eax = camlUnix_domain_of_sockaddr_1529 (eax, eax);
    eax = unix_socket;
    eax = caml_c_call (eax);
    ecx = 3;
    ebx = 5;
    camlUnix_setsockopt_1646 (eax);
    eax = *(esp);
    eax = *((esp + 8));
    eax = unix_bind;
    caml_c_call (eax);
    eax = *((esp + 8));
    eax = unix_listen;
    caml_c_call (eax);
    do {
label_0:
        eax = *((esp + 4));
        eax = camlUnix_accept_non_intr_2024 ();
        eax = *(eax);
        *((esp + 0xc)) = eax;
        eax = unix_fork;
        eax = caml_c_call (1);
        *(esp) = eax;
        if (eax == 1) {
            goto label_1;
        }
        eax = *((esp + 0xc));
        eax = unix_close;
        caml_c_call (eax);
        eax = *(esp);
        camlUnix_waitpid_non_intr_2001 ();
    } while (1);
label_1:
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        eax = 1;
        camlPervasives_exit_1326 ();
    }
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    camlUnix_try_set_close_on_exec_1366 ();
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    ecx = *((esp + 8));
    caml_apply2 ();
    eax = 1;
    camlPervasives_exit_1326 ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068671 */
#include <stdint.h>
 
uint32_t caml_ml_out_channels_list (void) {
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    esi = caml_local_roots;
    eax = ebp - 0x34;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0xc)) = 1;
    ebx = caml_all_opened_channels;
    if (ebx == 0) {
        goto label_0;
    }
    *((ebp - 0x10)) = 0;
    *((ebp - 0x14)) = 0;
    *((ebp - 0x34)) = esi;
    *((ebp - 0x2c)) = 1;
    *((ebp - 0x30)) = 3;
    eax = ebp - 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp - 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp - 0x14;
    *((ebp - 0x20)) = eax;
    do {
        if (*((ebx + 0x14)) == 0) {
            eax = caml_alloc_channel (ebx);
            *((ebp - 0x14)) = eax;
            eax = *((ebp - 0xc));
            *((ebp - 0x10)) = eax;
            eax = caml_alloc_small (2, 0);
            *((ebp - 0xc)) = eax;
            edx = *((ebp - 0x14));
            *(eax) = edx;
            edx = *((ebp - 0x10));
            eax = *((ebp - 0xc));
            *((eax + 4)) = edx;
        }
        ebx = *((ebx + 0x1c));
    } while (ebx != 0);
label_0:
    *(obj.caml_local_roots) = esi;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ffcc */
#include <stdint.h>
 
uint32_t caml_search_exe_in_path (int32_t arg_8h) {
    int32_t var_24h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = ebp - 0x24;
    caml_ext_table_init (ebx, 8);
    eax = getenv ("PATH");
    eax = caml_decompose_path (ebx, eax);
    esi = eax;
    eax = *((ebp + 8));
    eax = caml_search_in_path (ebx, eax);
    edi = eax;
    caml_stat_free (esi);
    caml_ext_table_free (ebx, 0);
    eax = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062ffa */
#include <stdint.h>
 
int32_t caml_ext_table_init (int32_t arg_8h, int32_t arg_ch) {
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    *(ebx) = 0;
    *((ebx + 4)) = eax;
    eax <<= 2;
    eax = caml_stat_alloc (ebx);
    *((ebx + 8)) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049fc4 */
#include <stdint.h>
 
void getenv (void) {
    getenv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fc4e */
#include <stdint.h>
 
int32_t caml_decompose_path (int32_t arg_8h, char * arg_ch) {
    char * src;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    edi = 0;
    if (ebx == 0) {
        goto label_1;
    }
    edi = ebx;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = caml_stat_alloc (ecx);
    edi = eax;
    strcpy (eax, ebx);
    ecx = edi;
label_0:
    eax = *(ecx);
    if (al != 0) {
        if (al != 0x3a) {
            goto label_2;
        }
    }
    ebx = ecx;
    goto label_3;
label_2:
    eax = ecx + 1;
    do {
        ebx = eax;
        edx = *(eax);
        eax++;
        if (dl == 0) {
            goto label_3;
        }
    } while (dl != 0x3a);
label_3:
    caml_ext_table_add (esi, ecx);
    if (*(ebx) != 0) {
        *(ebx) = 0;
        ecx = ebx + 1;
        goto label_0;
    }
label_1:
    eax = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fe18 */
#include <stdint.h>
 
int32_t caml_search_in_path (int32_t arg_8h, char * arg_ch) {
    int32_t var_80h;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_68h;
    char * src;
    int32_t var_8h;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *(eax);
    if (dl == 0) {
        goto label_0;
    }
    if (dl != 0x2f) {
        goto label_1;
    }
    goto label_2;
    do {
        if (dl == 0x2f) {
            goto label_2;
        }
label_1:
        eax++;
        edx = *(eax);
    } while (dl != 0);
label_0:
    if (*(esi) <= 0) {
        goto label_2;
    }
    *((ebp - 0x7c)) = 0;
    do {
        edx = *((ebp - 0x7c));
        edx <<= 2;
        *((ebp - 0x80)) = edx;
        eax = *((esi + 8));
        edi = *((eax + edx));
        eax = 0;
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        edx = ecx;
        edx = ~edx;
        edi = *((ebp + 0xc));
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        edx += ecx;
        eax = caml_stat_alloc (edx);
        ebx = eax;
        eax = *((esi + 8));
        edx = *((ebp - 0x80));
        eax = *((eax + edx));
        strcpy (ebx, eax);
        if (*(ebx) != 0) {
            edi = ebx;
            eax = 0;
            ecx = 0xffffffff;
            __asm ("repne scasb al, byte es:[edi]");
            ecx = ~ecx;
            *((ebx + ecx - 1)) = 0x2f;
        }
        eax = *((ebp + 0xc));
        strcat (ebx, eax);
        edx = ebp - 0x78;
        *((esp + 8)) = edx;
        *((esp + 4)) = ebx;
        *(esp) = 3;
        eax = xstat64 ();
        if (eax == 0) {
            eax = *((ebp - 0x68));
            eax &= 0xf000;
            if (eax == 0x8000) {
                goto label_3;
            }
        }
        caml_stat_free (ebx);
        *((ebp - 0x7c))++;
        eax = *((ebp - 0x7c));
    } while (*(esi) > eax);
label_2:
    edi = *((ebp + 0xc));
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = caml_stat_alloc (ecx);
    ebx = eax;
    edx = *((ebp + 0xc));
    strcpy (eax, edx);
label_3:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062f78 */
#include <stdint.h>
 
int32_t caml_ext_table_free (int32_t arg_8h, char * arg_ch) {
    esi = *((ebp + 8));
    if (*((ebp + 0xc)) == 0) {
        goto label_0;
    }
    if (*(esi) <= 0) {
        goto label_0;
    }
    ebx = 0;
    do {
        eax = *((esi + 8));
        eax = *((eax + ebx*4));
        caml_stat_free (eax);
        ebx++;
    } while (*(esi) > ebx);
label_0:
    eax = *((esi + 8));
    caml_stat_free (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8051320 */
#include <stdint.h>
 
uint32_t camlArray_bubbledown_1170 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        ecx = *((ecx + 0x10));
        eax = camlArray_maxson_1155 (ecx, eax, ebx);
        ebx = eax;
        esi = *(esp);
        ecx = *((esi + 0xc));
        eax = *((ecx - 4));
        edx = *((ecx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            eax >>= 9;
            if (eax <= ebx) {
                goto label_1;
            }
            edx = *((ecx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_2;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi + 0xc));
        edi = *((eax - 4));
        ecx = *((eax - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            edi >>= 9;
            ecx = *((esp + 8));
            if (edi <= ecx) {
                goto label_4;
            }
            caml_modify (eax + ecx*2 - 2, edx);
        } else {
            edi >>= 0xa;
            ecx = *((esp + 8));
            if (edi <= ecx) {
                goto label_5;
            }
            *(fp_stack--) = *(edx);
            *((eax + ecx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 4));
        ecx = esi;
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c2d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2714 (void) {
    eax = unix_umask;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062048 */
#include <stdint.h>
 
int32_t caml_register_frametable (int32_t arg_8h) {
    edx = frametables;
    eax = *((ebp + 8));
    eax = cons ();
    *(obj.frametables) = eax;
    eax = caml_frame_descriptors;
    if (eax != 0) {
        caml_stat_free (eax);
        *(obj.caml_frame_descriptors) = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f8f0 */
#include <stdint.h>
 
int32_t camlPervasives_lnot_1049 (void) {
    eax ^= 0xffffffff;
    eax |= 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c006 */
#include <stdint.h>
 
uint32_t caml_sys_is_directory (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = ebx;
    *(esp) = 3;
    eax = xstat64 ();
    if (eax == -1) {
        caml_sys_error (ebx);
    }
    eax = *((ebp - 0x58));
    eax &= 0xf000;
    al = (eax == 0x4000) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049f54 */
#include <stdint.h>
 
void xstat64 (void) {
    xstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806f305 */
#include <stdint.h>
 
int32_t caml_compact_heap_maybe (void) {
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_18h;
    int32_t var_14h;
    char * var_4h;
    int32_t var_8h;
    if (*(obj.caml_percent_max) <= 0xf423f) {
        if (*(obj.caml_stat_major_collections) <= 2) {
            goto label_0;
        }
        if (*(obj.caml_stat_heap_chunks) <= 2) {
            goto label_0;
        }
        edx = caml_fl_cur_size;
        eax = caml_fl_size_at_phase_change;
        ebx = 0;
        *((ebp - 0x18)) = edx;
        *((ebp - 0x14)) = ebx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_stack[0] *= *(0x807140c);
        ebx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = ebx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_stack[0] *= *(0x8071e94);
        fp_stack[0] += fp_stack[1];
        fp_stack++;
        *((ebp - 0xc)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0xc));
        *(fp_stack--) = 0.0;
        fp_stack--;
        if (fp_stack[0] > fp_stack[1]) {
            fp_stack++;
            ecx = 0;
            *((ebp - 0x18)) = edx;
            *((ebp - 0x14)) = ecx;
            *(fp_stack--) = *((ebp - 0x18));
        }
        edx = caml_stat_heap_size;
        edx >>= 2;
        ecx = 0;
        *((ebp - 0x18)) = edx;
        *((ebp - 0x14)) = ecx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        if (fp_stack[0] >= fp_stack[1]) {
            fp_stack++;
            fp_stack++;
            *(fp_stack--) = *(0x8070ce8);
            *((ebp - 0x20)) = fp_stack[0];
            fp_stack--;
        } else {
            *(fp_stack--) = fp_stack[0];
            fp_stack[0] *= *(0x8071dbc);
            fp_tmp_1 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_1;
            fp_stack[0] -= fp_stack[2];
            fp_stack++;
            fp_stack[1] /= fp_stack[0];
            fp_stack++;
            *((ebp - 0x20)) = fp_stack[0];
            fp_stack--;
            *(fp_stack--) = *(0x8070ce8);
            *(fp_stack--) = *((ebp - 0x20));
            __asm ("fcmovnbe st(0), st(1)");
            fp_stack[1] = fp_stack[0];
            fp_stack--;
            *((ebp - 0x20)) = fp_stack[0];
            fp_stack--;
        }
        caml_gc_message (0x200, "FL size at phase change = %lu\n", eax);
        eax = *((ebp - 0x1a));
        ah = 0xc;
        *((ebp - 0x1c)) = ax;
        *(fp_stack--) = *((ebp - 0x20));
        *((ebp - 0x18)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x18));
        caml_gc_message (0x200, "Estimated overhead = %lu%%\n", eax);
        eax = caml_percent_max;
        edx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = edx;
        *(fp_stack--) = *((ebp - 0x18));
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] < fp_stack[1]) {
            goto label_0;
        }
        caml_gc_message (0x200, "Automatic compaction triggered.\n", 0);
        caml_finish_major_cycle ();
        eax = caml_fl_cur_size;
        edx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = edx;
        *(fp_stack--) = *((ebp - 0x18));
        *(fp_stack--) = fp_stack[0];
        fp_stack[0] *= *(0x8071dbc);
        eax = caml_stat_heap_size;
        eax >>= 2;
        edx = 0;
        *((ebp - 0x18)) = eax;
        *((ebp - 0x14)) = edx;
        *(fp_stack--) = *((ebp - 0x18));
        fp_stack[2] -= fp_stack[0];
        fp_stack++;
        fp_stack[1] /= fp_stack[0];
        fp_stack++;
        *((ebp - 0xc)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0xc));
        eax = *((ebp - 0x1a));
        ah = 0xc;
        *((ebp - 0x1c)) = ax;
        *((ebp - 0x18)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x18));
        caml_gc_message (0x200, "Measured overhead: %lu%%\n", eax);
        caml_compact_heap ();
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806770e */
#include <stdint.h>
 
int32_t caml_log_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    log (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a6e4 */
#include <stdint.h>
 
void log (void) {
    log ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806740a */
#include <stdint.h>
 
uint32_t caml_copy_double (void) {
    *(fp_stack--) = *((ebp + 8));
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    edx = caml_young_ptr;
    eax = edx - 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        *(obj.caml_young_ptr) = edx;
        caml_minor_collection ();
        *(obj.caml_young_ptr) -= 0xc;
    }
    eax = caml_young_ptr;
    *(eax) = 0xbfd;
    eax = caml_young_ptr;
    eax += 4;
    *(fp_stack--) = *((ebp - 0x10));
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068e51 */
#include <stdint.h>
 
uint32_t caml_ml_input_char (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebx + 0x10));
    if (eax >= *((ebx + 0x14))) {
        eax = caml_refill (ebx);
        edi = eax;
    } else {
        edi = *(eax);
        eax++;
        *((ebx + 0x10)) = eax;
    }
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    edi &= 0xff;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80509a0 */
#include <stdint.h>
 
int32_t camlArray_fill_1070 (void) {
    int32_t var_4h;
    int32_t var_8h;
label_0:
    edi = ecx;
    if (ebx == 1) {
        goto label_2;
    }
    *((esp + 8)) = eax;
    eax = *((ebx + 4));
    *(esp) = eax;
    eax = *(ebx);
    *((esp + 4)) = eax;
    ebx = 1;
    esi = *((eax - 4));
    eax = *((eax - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        esi >>= 9;
    } else {
        esi >>= 0xa;
    }
    esi |= 1;
    esi += 0xfffffffe;
    if (ebx > esi) {
        goto label_3;
    }
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            eax = *((ecx + ebx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((esp + 8));
        ebp = ecx + ebx - 1;
        edx = *((edi + 0xc));
        ecx = *((edx - 4));
        if (ecx != 0xfe) {
            eax = caml_modify (edx + ebp*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            *((edx + ebp*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = ebx;
        ebx += 2;
    } while (eax != esi);
label_3:
    eax = *((esp + 4));
    ebx = *((eax - 4));
    eax = *((eax - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        ebx >>= 9;
    } else {
        ebx >>= 0xa;
    }
    ebx |= 1;
    eax = *((esp + 8));
    eax += ebx;
    eax--;
    ebx = *(esp);
    ecx = edi;
    goto label_0;
label_2:
    eax = 1;
    return eax;
label_4:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d470 */
#include <stdint.h>
 
int32_t camlUnix_safe_dup_1894 (void) {
    int32_t var_4h;
    do {
        *(esp) = eax;
        eax = unix_dup;
        eax = caml_c_call (eax);
        if (eax >= 7) {
            return eax;
        }
        eax = *(esp);
        eax = camlUnix_safe_dup_1894 (eax);
    } while (1);
    *(esp) = eax;
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ba90 */
#include <stdint.h>
 
int32_t caml_sys_init (int32_t arg_8h, char ** arg_ch) {
    eax = *((ebp + 8));
    *(obj.caml_exe_name) = eax;
    eax = *((ebp + 0xc));
    *(obj.caml_main_argv) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066f14 */
#include <stdint.h>
 
int32_t caml_nativeint_to_int32 (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066ee2 */
#include <stdint.h>
 
void caml_copy_int32 (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    caml_alloc_custom (1, 4, 0);
    edx = *((ebp + 8));
    *((eax + 4)) = edx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067aa0 */
#include <stdint.h>
 
int32_t caml_string_length (uint32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    edx = *((eax + edx));
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80671d9 */
#include <stdint.h>
 
int32_t caml_lt_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] > fp_stack[1]) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054c00 */
#include <stdint.h>
 
int32_t camlList_assq_1174 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        esi = *((ebx + 4));
        ecx = *(ebx);
        edx = *((ecx + 4));
        ecx = *(ecx);
        if (ecx == eax) {
            eax = edx;
            return eax;
        }
        ebx = esi;
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065f3b */
#include <stdint.h>
 
int32_t caml_compare (int32_t arg_8h, int32_t arg_ch) {
    ecx = 1;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80806c0) {
        compare_free_stack ();
    }
    eax = 0xffffffff;
    if (ebx >= 0) {
        al = (ebx > 0) ? 1 : 0;
        eax = (int32_t) al;
        eax = eax + eax + 1;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054e10 */
#include <stdint.h>
 
int32_t camlList_find_1201 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, eax);
        if (eax != 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056c30 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_in_bucket_1125 (void) {
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        *((esp + 4)) = ebx;
        ecx = *((eax + 8));
        *(esp) = ecx;
        eax = *(eax);
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068515 */
#include <stdint.h>
 
int32_t caml_ml_pos_in (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_in (ebx);
    ebx = eax;
    if (edx >= 0) {
        if (edx <= 0) {
            if (eax <= 0x3fffffff) {
                goto label_0;
            }
        }
        errno_location ();
        *(eax) = 0x4b;
        caml_sys_error (1);
    }
label_0:
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a616 */
#include <stdint.h>
 
int32_t caml_output_value_to_string (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_1ch;
    void * s2;
    size_t n;
    init_extern_output (ebx, esi, edi);
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = extern_value ();
    ebx = extern_output_first;
    eax = caml_alloc_string (eax);
    *((ebp - 0x1c)) = eax;
    if (ebx == 0) {
        goto label_0;
    }
    edi = 0;
    do {
        eax = ebx + 8;
        esi = *((ebx + 4));
        esi -= eax;
        eax = *((ebp - 0x1c));
        eax = edi + eax;
        memmove (eax, eax, esi);
        edi += esi;
        esi = *(ebx);
        free (ebx);
        if (esi == 0) {
            goto label_0;
        }
        ebx = esi;
    } while (1);
label_0:
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804be20 */
#include <stdint.h>
 
int32_t camlUnix_fun_2574 (void) {
    eax = unix_tcgetattr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058bd0 */
#include <stdint.h>
 
int32_t camlBuffer_advance_to_closing_1098 (void) {
    edi = edx;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x18f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x8058330;
            *((edx + 0xc)) = ebp;
            *((edx + 0x10)) = ebx;
            *((edx + 0x14)) = edi;
            eax = *((edi - 4));
            eax >>= 0xa;
            eax = eax*4 - 1;
            ebx = *((edi + eax));
            eax -= ebx;
            edi = eax + eax + 1;
            eax = ecx;
            ebx = esi;
            ecx = edi;
            void (*0x8058330)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067b47 */
#include <stdint.h>
 
int32_t caml_bitvect_test (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax >>= 4;
    edx = *((ebp + 8));
    eax = *((eax + edx));
    ecx &= 7;
    edx = 1;
    edx <<= cl;
    eax &= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804aac0 */
#include <stdint.h>
 
int32_t caml_curry9_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059c40 */
#include <stdint.h>
 
int32_t camlPrintf_incr_ac_1187 (void) {
    if (ebx == 0xc3) {
        edx = 5;
    } else {
        edx = 3;
    }
    if (ebx == 0xe5) {
        ebx = *((ecx + 0xc));
        *((ebx + 8)) += 2;
    }
    if (eax != 1) {
        ebx = *((ecx + 0xc));
        eax = *((ecx + 0xc));
        eax = *((eax + 4));
        eax = eax + edx - 1;
        *((ebx + 4)) = eax;
        eax = 1;
        return eax;
    }
    ebx = *((ecx + 0xc));
    eax = *((ecx + 0xc));
    eax = *(eax);
    eax = eax + edx - 1;
    *(ebx) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058b70 */
#include <stdint.h>
 
int32_t camlBuffer_closing_1097 (void) {
    if (eax == 0x51) {
        goto label_0;
    }
    while (1) {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = "L6\a\b";
            *((eax + 4)) = 0x807a31c;
            caml_raise_exn ();
            eax = 0xfb;
            return eax;
label_0:
            eax = 0x53;
            return eax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805cc24 */
#include <stdint.h>
 
int32_t unix_dup2 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x165d4;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = dup2 ();
    if (eax == -1) {
        eax = ebx - 0x25c9;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a2c4 */
#include <stdint.h>
 
void dup2 (void) {
    dup2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ab12 */
#include <stdint.h>
 
uint32_t caml_deserialize_float_8 (void) {
    int32_t var_10h;
    int32_t var_4h;
    eax = ebp - 0x10;
    caml_deserialize_block_float_8 (eax, 1);
    *(fp_stack--) = *((ebp - 0x10));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806aae1 */
#include <stdint.h>
 
int32_t caml_deserialize_block_float_8 (void * s1, int32_t arg_ch) {
    void * s2;
    size_t * n;
    ebx = *((ebp + 0xc));
    ebx <<= 3;
    eax = intern_src;
    eax = *((ebp + 8));
    memmove (eax, eax, ebx);
    *(obj.intern_src) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804be40 */
#include <stdint.h>
 
int32_t camlUnix_fun_2578 (void) {
    eax = unix_getservbyname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ccb3 */
#include <stdint.h>
 
uint32_t caml_gc_get (void) {
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x2c)) = ebx;
    eax = ebp - 0x2c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x24)) = 1;
    *((ebp - 0x28)) = 1;
    eax = ebp - 0xc;
    *((ebp - 0x20)) = eax;
    eax = caml_alloc_tuple (ebx);
    *((ebp - 0xc)) = eax;
    edx = caml_minor_heap_size;
    edx >>= 2;
    edx = edx + edx + 1;
    caml_modify (eax, edx);
    eax = caml_major_heap_increment;
    eax >>= 2;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 4;
    caml_modify (eax, eax);
    eax = caml_percent_free;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 8;
    caml_modify (eax, eax);
    eax = caml_verb_gc;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 0xc;
    caml_modify (eax, eax);
    eax = caml_percent_max;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 0x10;
    caml_modify (eax, eax);
    eax = *((ebp - 0xc));
    eax += 0x14;
    caml_modify (eax, 1);
    eax = caml_allocation_policy;
    eax = eax + eax + 1;
    eax = *((ebp - 0xc));
    eax += 0x18;
    caml_modify (eax, eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065755 */
#include <stdint.h>
 
int32_t caml_alloc_tuple (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    caml_alloc (eax, 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065553 */
#include <stdint.h>
 
uint32_t caml_alloc (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t c;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    eax = esi*4 + 0x8083504;
    if (ebx == 0) {
        goto label_0;
    }
    if (ebx > 0x100) {
        goto label_1;
    }
    edx = ebx*4 + 4;
    edi = edx;
    edi = -edi;
    eax = edi;
    eax += *(obj.caml_young_ptr);
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        eax += edx;
        *(obj.caml_young_ptr) = eax;
        caml_minor_collection ();
        *(obj.caml_young_ptr) += edi;
    }
    eax = ebx;
    eax <<= 0xa;
    edx = esi + eax + 0x300;
    eax = caml_young_ptr;
    *(eax) = edx;
    ecx = caml_young_ptr;
    eax = ecx + 4;
    if (esi > 0xfa) {
        goto label_0;
    }
    edx = 0;
    do {
        *((ecx + edx*4 + 4)) = 0;
        edx++;
    } while (edx != ebx);
    goto label_0;
label_1:
    eax = caml_alloc_shr (ebx, esi);
    edi = eax;
    if (esi <= 0xfa) {
        ebx <<= 2;
        memset (eax, 0, ebx);
    }
    caml_check_urgent_gc (edi);
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064d2f */
#include <stdint.h>
 
int32_t caml_modify (uint32_t arg_8h, char * arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    edi = *(ebx);
    *(ebx) = esi;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) != 0) {
        if (*(obj.caml_gc_phase) == 0) {
            caml_darken (edi, 0);
        }
        if ((esi & 1) != 0) {
            goto label_0;
        }
        eax = caml_young_end;
        if (esi >= eax) {
            goto label_0;
        }
        edx = caml_young_start;
        if (esi <= edx) {
            goto label_0;
        }
        if ((edi & 1) == 0) {
            if (eax <= edi) {
                goto label_1;
            }
            if (edx < edi) {
                goto label_0;
            }
        }
label_1:
        eax = .comment;
        if (eax >= *(0x807fe8c)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x807fe88;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804afc0 */
#include <stdint.h>
 
int32_t caml_curry6_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80609a4 */
#include <stdint.h>
 
int32_t unix_symlink (char * path1, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    char * path2;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1284f;
    esi = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = symlink (eax, esi);
    if (eax == -1) {
        eax = ebx - 0x22fe;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a2a4 */
#include <stdint.h>
 
void symlink (void) {
    symlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070b20 */
#include <stdint.h>
 
void libc_csu_fini (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a7ca */
#include <stdint.h>
 
int32_t caml_deserialize_sint_2 (void) {
    eax = intern_src;
    edx = eax + 2;
    *(obj.intern_src) = edx;
    eax = *(eax);
    eax <<= 8;
    edx = *((edx - 1));
    eax += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056220 */
#include <stdint.h>
 
void camlString_contains_1137 (void) {
    ecx = ebx;
    ebx = 1;
    return camlString_contains_from_1132 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056000 */
#include <stdint.h>
 
int32_t camlString_index_rec_1108 (void) {
    do {
        if (ecx >= ebx) {
label_0:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_1;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        esi = ecx;
        esi >>= 1;
        esi = *((eax + esi));
        esi = esi + esi + 1;
        if (esi == edx) {
            eax = ecx;
            return eax;
        }
        ecx += 2;
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b0e0 */
#include <stdint.h>
 
int32_t camlPrintf_scan_positional_1291 (void) {
    esi = eax;
    edi = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x18f7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x8059280;
            eax = edx;
            eax += 0x10;
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = esi;
            *((ebx + 0x14)) = edi;
            eax = *((edx + 0x2c));
            ecx = esi;
            edx = ebp;
            void (*0x805be10)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bdf0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2570 (void) {
    eax = unix_tcsendbreak;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ca90 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_1643 (void) {
    eax = unix_getsockopt;
    caml_c_call (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c120 */
#include <stdint.h>
 
int32_t camlUnix_fun_2664 (void) {
    eax = unix_sigpending;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bf30 */
#include <stdint.h>
 
int32_t camlUnix_fun_2606 (void) {
    eax = unix_socket;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ccdc */
#include <stdint.h>
 
int32_t unix_execv (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16514;
    edi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    esi = eax;
    *((esp + 4)) = eax;
    *(esp) = edi;
    execv ();
    caml_stat_free (esi);
    eax = ebx - 0x25c4;
    return uerror (eax, edi);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061798 */
#include <stdint.h>
 
uint32_t cstringvect (int32_t arg_8h) {
    int32_t var_1ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x11a5e;
    esi = *((ebp + 8));
    edi = *((esi - 4));
    edi >>= 0xa;
    eax = edi*4 + 4;
    eax = caml_stat_alloc (eax);
    *((ebp - 0x1c)) = eax;
    if (edi == 0) {
        goto label_0;
    }
    edx = 0;
    do {
        ecx = *((esi + edx*4));
        *((eax + edx*4)) = ecx;
        edx++;
    } while (edi > edx);
label_0:
    eax = *((ebp - 0x1c));
    *((eax + edi*4)) = 0;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a3a4 */
#include <stdint.h>
 
void execv (void) {
    execv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a5a4 */
#include <stdint.h>
 
void execve (void) {
    execve ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a3b4 */
#include <stdint.h>
 
void execvp (void) {
    execvp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a8b4 */
#include <stdint.h>
 
void fchmod (void) {
    fchmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b270 */
#include <stdint.h>
 
int32_t caml_curry4_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry4_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b370 */
#include <stdint.h>
 
int32_t caml_curry2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80684f3 */
#include <stdint.h>
 
int32_t caml_ml_pos_out_64 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_out (eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068453 */
#include <stdint.h>
 
int32_t caml_pos_out (int32_t arg_8h) {
    edx = *((ebp + 8));
    ebx = edx + 0x34;
    ecx = *((edx + 0x10));
    ecx -= ebx;
    ebx = ecx;
    ebx >>= 0x1f;
    eax = *((edx + 4));
    edx = *((edx + 8));
    eax += ecx;
    edx += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80667b4 */
#include <stdint.h>
 
int32_t caml_nativeint_of_string (int32_t arg_8h) {
    edx = 0x20;
    eax = *((ebp + 8));
    eax = parse_intnat ();
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066782 */
#include <stdint.h>
 
void caml_copy_nativeint (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    caml_alloc_custom (1, 4, 0);
    edx = *((ebp + 8));
    *((eax + 4)) = edx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e584 */
#include <stdint.h>
 
int32_t unix_isatty (int32_t fd) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14c74;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = isatty (eax);
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a2e4 */
#include <stdint.h>
 
void isatty (void) {
    isatty ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804e2c0 */
#include <stdint.h>
 
uint32_t camlUnix_accept_non_intr_2024 (void) {
    do {
        eax = void (*0x804e300)(uint32_t) (eax);
        ecx = camlUnix;
        ebx = *(eax);
        if (ebx != ecx) {
            goto label_0;
        }
        ebx = *((eax + 4));
        if ((ebx & 1) == 0) {
            goto label_0;
        }
        if (ebx != 0x17) {
            goto label_0;
        }
        eax = *(esp);
    } while (1);
label_0:
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = sym.unix_accept;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067119 */
#include <stdint.h>
 
int32_t caml_int32_add (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax += *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c1e0 */
#include <stdint.h>
 
int32_t camlPrintf_printf_1393 (void) {
    eax = .comment;
    eax = camlPrintf_fprintf_1391 (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80672d7 */
#include <stdint.h>
 
void caml_expm1 (void) {
    *(fp_stack--) = *((ebp + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    expm1 (ebp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a174 */
#include <stdint.h>
 
void expm1 (void) {
    expm1 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065081 */
#include <stdint.h>
 
int32_t caml_page_table_add (int32_t arg_8h, char * arg_ch, int32_t arg_10h) {
    edi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx &= 0xfffff000;
    esi = *((ebp + 0x10));
    esi--;
    esi &= 0xfffff000;
    if (ebx > esi) {
        goto label_0;
    }
    do {
        ecx = edi;
        edx = 0;
        eax = ebx;
        eax = caml_page_table_modify ();
        if (eax != 0) {
            eax = 0xffffffff;
            goto label_1;
        }
        ebx += 0x1000;
    } while (esi >= ebx);
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c4a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2764 (void) {
    eax = unix_wait;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055690 */
#include <stdint.h>
 
uint32_t camlString_fun_1160 (void) {
    ecx = *((ebx + 8));
    *(ecx) += 2;
    ecx = *((ebx + 0xc));
    edx = *((eax - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    eax = *((eax + edx));
    edx -= eax;
    eax = *((ebx + 0xc));
    eax = *(eax);
    eax = eax + edx*2;
    *(ecx) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d4c0 */
#include <stdint.h>
 
uint32_t camlUnix_safe_close_1898 (void) {
    eax = void (*0x804d4f0)() ();
    ecx = camlUnix;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = 1;
        return eax;
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804af40 */
#include <stdint.h>
 
int32_t caml_curry6 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d020 */
#include <stdint.h>
 
uint32_t camlUnix_getaddrinfo_1751 (void) {
    int32_t var_4h;
    int32_t var_8h;
    eax = void (*0x804d070)(uint32_t, uint32_t, uint32_t) (eax, ebx, ecx);
    ecx = "P5\a\b";
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        void (*0x804cbb0)() ();
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_getaddrinfo;
    caml_c_call (eax);
    ebx = 1;
    camlList_rev_append_1051 ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804aa80 */
#include <stdint.h>
 
int32_t caml_curry9 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c290 */
#include <stdint.h>
 
int32_t camlUnix_fun_2706 (void) {
    eax = unix_set_nonblock;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c140 */
#include <stdint.h>
 
int32_t camlUnix_fun_2668 (void) {
    eax = unix_kill;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fcb4 */
#include <stdint.h>
 
int32_t unix_sleep (int32_t s) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13544;
    caml_enter_blocking_section ();
    eax = *((ebp + 8));
    eax >>= 1;
    sleep (eax);
    caml_leave_blocking_section ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a654 */
#include <stdint.h>
 
void sleep (void) {
    sleep ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054700 */
#include <stdint.h>
 
uint32_t camlList_fold_right_1084 (void) {
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        esi = *((ebx + 4));
        edx = *(ebx);
        ebx = esi;
        eax = camlList_fold_right_1084 (edx, eax);
    } while (1);
    ebx = eax;
    eax = *(esp);
    ecx = *((esp + 4));
    void (*0x804b540)() ();
label_0:
    eax = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806358c */
#include <stdint.h>
 
int32_t caml_fl_allocate (int32_t arg_8h) {
    int32_t var_fc8h;
    int32_t var_fc4h;
    int32_t var_fc0h;
    int32_t var_fbch;
    int32_t var_fb8h;
    void * s2;
    size_t n;
    eax = *((ebp + 8));
    edx = caml_allocation_policy;
    if (edx != 0) {
        if (edx != 1) {
            goto label_0;
        }
        edx = flp_size;
        *((ebp - 0xfbc)) = edx;
        if (edx <= 0) {
            goto label_1;
        }
        ecx = flp;
        edx = *(ecx);
        esi = *((edx - 4));
        esi >>= 0xa;
        ebx = 0;
        edi = flp;
        if (eax > esi) {
            goto label_2;
        }
        goto label_3;
    }
    ecx = fl_prev;
    edx = *(ecx);
    if (edx == 0) {
        goto label_4;
    }
    ebx = *((edx - 4));
    ebx >>= 0xa;
    if (eax > ebx) {
        goto label_5;
    }
    while (edx != 0) {
        ebx = *((edx - 4));
        ebx >>= 0xa;
        if (ebx >= eax) {
            eax++;
            edx = 0;
            eax = allocate_block (edx);
            edi = eax;
            goto label_6;
        }
label_5:
        ecx = edx;
        edx = *(edx);
    }
label_4:
    *(obj.fl_last) = ecx;
    ecx = 0x807ca48;
    edx = *(ecx);
    esi = fl_prev;
    if (ecx == esi) {
        goto label_0;
    }
    ebx = *((edx - 4));
    ebx >>= 0xa;
    if (eax > ebx) {
        goto label_7;
    }
    while (esi != ecx) {
        ebx = *((edx - 4));
        ebx >>= 0xa;
        if (eax <= ebx) {
            eax++;
            edx = 0;
            eax = allocate_block (edx);
            edi = eax;
            goto label_6;
        }
label_7:
        ecx = edx;
        edx = *(edx);
    }
    goto label_0;
    do {
        ecx = *((edi + ebx*4));
        edx = *(ecx);
        esi = *((edx - 4));
        esi >>= 0xa;
        if (eax <= esi) {
label_3:
            eax++;
            edx = ebx;
            eax = allocate_block (edx);
            edi = eax;
            goto label_8;
        }
label_2:
        ebx++;
    } while (ebx < *((ebp - 0xfbc)));
label_1:
    if (*((ebp - 0xfbc)) != 0) {
        goto label_9;
    }
    ecx = 0x807ca48;
    edi = 0;
    do {
        edx = 0;
        goto label_10;
label_9:
        ecx = *((ebp - 0xfbc));
        edx = *((ecx*4 + 0x807ee9c));
        ecx = *(edx);
        edi = *((ecx - 4));
        edi >>= 0xa;
        edx = beyond;
        if (edx != 0) {
            ecx = edx;
        }
    } while (1);
    do {
        edx = *(ecx);
        if (edx == 0) {
            *(obj.fl_last) = ecx;
            eax = 0;
            if (ecx == 0x807ca48) {
                ecx = eax;
            }
            *(obj.beyond) = ecx;
            edi = 0;
            goto label_6;
        }
        esi = *((edx - 4));
        esi >>= 0xa;
        if (edi < esi) {
            *((ebx*4 + obj.flp)) = ecx;
            ebx = flp_size;
            edi = ebx + 1;
            *(obj.flp_size) = edi;
            if (eax <= esi) {
                *(obj.beyond) = edx;
                eax++;
                edx = ebx;
                eax = allocate_block (edx);
                edi = eax;
                goto label_8;
            }
            edi = esi;
        }
        ecx = edx;
label_10:
        ebx = flp_size;
    } while (ebx <= 0x3e7);
    *(obj.beyond) = edx;
    ecx = edx;
    if (edx == 0) {
        ecx = *((ebx*4 + 0x807ee9c));
    }
    edx = .comment;
    edx = *(edx);
    esi = *((edx - 4));
    esi >>= 0xa;
    edx = *(ecx);
    if (edx == 0) {
        goto label_11;
    }
    do {
        ebx = *((edx - 4));
        ebx >>= 0xa;
        if (esi > ebx) {
            *(obj.beyond) = edx;
        } else {
            if (eax > ebx) {
                goto label_12;
            }
            eax++;
            edx = flp_size;
            eax = allocate_block (edx);
            edi = eax;
            goto label_6;
        }
label_12:
        ebx = *(edx);
        if (ebx == 0) {
            goto label_13;
        }
        ecx = edx;
        edx = ebx;
    } while (1);
label_13:
    ecx = edx;
label_11:
    *(obj.fl_last) = ecx;
    edi = 0;
    goto label_6;
label_8:
    eax = flp_size;
    if (ebx >= eax) {
        goto label_6;
    }
    ecx = 0;
    if (ebx > 0) {
        edx = *((ebx*4 + 0x807ee9c));
        edx = *(edx);
        edx = *((edx - 4));
        ecx = *((edx - 4));
        ecx >>= 0xa;
    }
    eax--;
    if (eax == ebx) {
        eax = *((eax*4 + obj.flp));
        eax = *(eax);
        edx = *((eax - 4));
        edx >>= 0xa;
        if (ecx >= edx) {
            *(obj.beyond) = eax;
            *(obj.flp_size)--;
            goto label_6;
        }
        *(obj.beyond) = 0;
        goto label_6;
    }
    edx = flp;
    eax = *((edx + ebx*4));
    edx = *((edx + ebx*4 + 4));
    *((ebp - 0xfc0)) = 0;
    *((ebp - 0xfbc)) = esi;
    esi = ecx;
    *((ebp - 0xfc4)) = ebx;
    ebx = 0;
    *((ebp - 0xfc8)) = edi;
    edi = edx;
    while (edi != eax) {
        edx = *(eax);
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (esi < ecx) {
            *((ebp + ebx*4 - 0xfb8)) = eax;
            ebx++;
            if (*((ebp - 0xfbc)) <= ecx) {
                goto label_14;
            }
            esi = ecx;
        }
        eax = edx;
    }
label_14:
    *((ebp - 0xfc0)) = ebx;
    ebx = *((ebp - 0xfc4));
    edi = *((ebp - 0xfc8));
    eax = flp_size;
    eax--;
    edx = *((ebp - 0xfc0));
    edx = eax + edx;
    if (edx <= 0x3e8) {
        if (*((ebp - 0xfc0)) != 1) {
            eax -= ebx;
            eax <<= 2;
            eax = ebx*4 + 0x807eea4;
            eax = *((ebp - 0xfc0));
            eax += ebx;
            eax = eax*4 + obj_flp;
            memmove (eax, eax, eax);
            if (*((ebp - 0xfc0)) <= 0) {
                goto label_15;
            }
        }
        eax = *((ebp - 0xfc0));
        eax <<= 2;
        eax = ebp - 0xfb8;
        eax = ebx*4 + obj_flp;
        memmove (eax, eax, eax);
label_15:
        eax = flp_size;
        edx = *((ebp - 0xfc0));
        eax = edx + eax - 1;
        *(obj.flp_size) = eax;
    } else {
        eax = *((ebp - 0xfc0));
        eax += ebx;
        if (eax <= 0x3e7) {
            if (*((ebp - 0xfc0)) != 1) {
                edx = 0x3e8;
                edx -= ebx;
                edx -= *((ebp - 0xfc0));
                edx <<= 2;
                edx = ebx*4 + 0x807eea4;
                eax = eax*4 + obj_flp;
                memmove (eax, edx, edx);
                if (*((ebp - 0xfc0)) <= 0) {
                    goto label_16;
                }
            }
            eax = *((ebp - 0xfc0));
            eax <<= 2;
            eax = ebp - 0xfb8;
            eax = ebx*4 + obj_flp;
            memmove (eax, eax, eax);
        } else {
            if (ebx == 0x3e8) {
                goto label_16;
            }
            eax = 0x3e8;
            eax -= ebx;
            eax <<= 2;
            eax = ebp - 0xfb8;
            eax = ebx*4 + obj_flp;
            memmove (eax, eax, eax);
        }
label_16:
        *(obj.flp_size) = 0x3e7;
        eax = .comment;
        eax = *(eax);
        *(obj.beyond) = eax;
        goto label_6;
label_0:
        edi = 0;
    }
label_6:
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8051bd0 */
#include <stdint.h>
 
uint32_t camlArray_sortto_1217 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    do {
label_0:
        if (edx <= 0xb) {
            esi = *((esi + 0x14));
            void (*0x80518d0)() ();
        }
        *(esp) = esi;
        *((esp + 8)) = ecx;
        *((esp + 0x14)) = ebx;
        *((esp + 0x10)) = eax;
        esi = edx;
        esi >>= 1;
        if (esi < 0) {
            esi++;
        }
        esi >>= 1;
        esi = esi + esi + 1;
        edx -= esi;
        edx++;
        ecx = ecx + esi - 1;
        eax = eax + esi - 1;
        edx = *((esp + 0xc));
        esi = *(esp);
        camlArray_sortto_1217 (edx, esi);
    } while (1);
    ebx = *((esp + 0xc));
    eax = *((esp + 0x10));
    ecx = eax + ebx - 1;
    esi = *(esp);
    ebx = *((esi + 0xc));
    edx = *((esp + 4));
    camlArray_sortto_1217 ();
    goto label_0;
    eax = *(esp);
    eax = *((eax + 0x10));
    *(esp) = eax;
    ebx = *((esp + 4));
    ebp = *((esp + 8));
    edx = ebp + ebx - 1;
    esi = *((esp + 0xc));
    eax = *((esp + 0x10));
    eax = eax + esi - 1;
    ecx = *((esp + 0x14));
    edi = *((esp + 0x14));
    *(loc.caml_extra_params) = ebp;
    ebp = *(esp);
    *(0x807cb20) = ebp;
    return camlArray_merge_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bb30 */
#include <stdint.h>
 
uint32_t camlUnix_get_port_1739 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    esi = eax;
    edi = ecx;
    eax = caml_string_equal (*((edi + 0xc)), loc.camlUnix__215);
    if (eax != 1) {
label_1:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        *(ebx) = esi;
        *((ebx + 4)) = 1;
        eax = ebx + 0xc;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        *((eax + 4)) = 1;
        return eax;
    }
    eax = void (*0x804bc70)(uint32_t, uint32_t, uint32_t) (ebx, edi, esi);
    ecx = "45\a\b";
    ebx = *(eax);
    if (ebx == ecx) {
        eax = void (*0x804bbe0)() ();
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 1;
            return eax;
        }
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = *((esp + 8));
        eax = *((esp + 0x10));
        eax = unix_getservbyname;
        eax = caml_c_call (*((eax + 0xc)));
        eax += 8;
        ecx = *(eax);
label_0:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        eax = *((esp + 0x10));
        *(ebx) = eax;
        *((ebx + 4)) = ecx;
        eax = ebx + 0xc;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        *((eax + 4)) = 1;
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = caml_int_of_string;
    eax = caml_c_call (*((edi + 0xc)));
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 0x10));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx + 0xc;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            *((eax + 4)) = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067ada */
#include <stdint.h>
 
int32_t caml_string_equal (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 8));
    edx = *((ebp + 0xc));
    if (ecx == edx) {
        goto label_0;
    }
    eax = *((ecx - 4));
    eax >>= 0xa;
    ebx = *((edx - 4));
    ebx >>= 0xa;
    if (eax != ebx) {
        goto label_1;
    }
    if (eax == 0) {
        goto label_0;
    }
    ebx = *(ecx);
    if (ebx == *(edx)) {
        goto label_2;
    }
    goto label_1;
    do {
        ecx += 4;
        edx += 4;
        ebx = *(ecx);
        if (ebx != *(edx)) {
            goto label_1;
        }
label_2:
        eax--;
    } while (eax != 0);
label_0:
    eax = 3;
    goto label_3;
label_1:
    eax = 1;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069b05 */
#include <stdint.h>
 
uint32_t caml_serialize_float_4 (int32_t arg_8h) {
    int32_t var_4h;
    eax = ebp + 8;
    caml_serialize_block_4 (eax, 1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069a84 */
#include <stdint.h>
 
int32_t caml_serialize_block_4 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_1ch;
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax <<= 2;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    edx = extern_ptr;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    ecx = *((ebp + 0xc));
    eax = 0;
    *((ebp - 0x1c)) = ecx;
    do {
        edi = *((ebx + eax));
        esi = *((ebx + eax + 1));
        ecx = *((ebx + eax + 3));
        *((edx + eax)) = cl;
        ecx = *((ebx + eax + 2));
        *((edx + eax + 1)) = cl;
        ecx = edi;
        *((edx + eax + 3)) = cl;
        ecx = esi;
        *((edx + eax + 2)) = cl;
        eax += 4;
        *((ebp - 0x1c))--;
    } while (*((ebp - 0x1c)) != 0);
    eax = *((ebp + 0xc));
    edx = edx + eax*4;
label_0:
    *(obj.extern_ptr) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059b00 */
#include <stdint.h>
 
void camlPrintf_scan_flags_1142 (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806cb1c */
#include <stdint.h>
 
int32_t caml_gc_major (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (1, "Major GC cycle requested\n", 0);
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    test_and_compact ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059ce0 */
#include <stdint.h>
 
int32_t camlPrintf_loop_1204 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 4));
        ebx = *(ebx);
        if (edx == 1) {
            goto label_1;
        }
        ecx = *((ecx + 0xc));
        caml_apply2 (eax, edx, ecx);
        eax = *(esp);
        eax += 2;
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_1:
    ecx = *((ecx + 0xc));
    void (*0x804b540)() ();
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80528b0 */
#include <stdint.h>
 
uint32_t camlArray_iteri_1111 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = 1;
    edx = *((ebx - 4));
    esi = *((ebx - 4));
    esi &= 0xff;
    if (esi != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    edx += 0xfffffffe;
    if (ecx > edx) {
        goto label_1;
    }
    *((esp + 0xc)) = edx;
    *((esp + 8)) = ecx;
    *(esp) = ebx;
    *((esp + 4)) = eax;
    do {
        edx = *(esp);
        eax = *((edx - 4));
        if (eax != 0xfe) {
            ebx = *((edx + ecx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ecx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = ecx;
        ecx = *((esp + 4));
        caml_apply2 ();
        ecx = *((esp + 8));
        ebx = *((esp + 8));
        ecx += 2;
        *((esp + 8)) = ecx;
        eax = *((esp + 0xc));
    } while (ebx != eax);
label_1:
    eax = 1;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80592a0 */
#include <stdint.h>
 
int32_t camlPrintf_cont_m_1365 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = ebx;
    eax = camlPrintf_ac_of_format_1184 (eax, ecx, eax);
    ebx = *(eax);
    eax = *((esp + 8));
    eax = ebx + eax - 1;
    eax = camlPrintf_index_of_int_1037 ();
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = loc.camlPrintf__code_begin;
            *((eax + 4)) = 3;
            ecx = *(esp);
            ebx = *(esp);
            ebx += 0xffffffb0;
            *((eax + 8)) = ebx;
            ebx = *((esp + 4));
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = edx;
            esi = *((ecx + 0x20));
            edx = *((ecx + 0x2c));
            ebx = *((esp + 8));
            ecx = *((esp + 0xc));
            void (*0x805b140)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070268 */
#include <stdint.h>
 
int32_t caml_print_exception_backtrace (void) {
    uint32_t var_30h;
    uint32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    char * format;
    char ** var_8h;
    char ** var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    if (*(obj.caml_backtrace_pos) <= 0) {
        goto label_0;
    }
    ebx = 0;
    esi = ebp - 0x30;
    edi = "Re-raised at";
    do {
        eax = caml_backtrace_buffer;
        eax = *((eax + ebx*4));
        edx = esi;
        extract_location_info ();
        if (*((ebp - 0x30)) != 0) {
            eax = "Raised at";
            if (ebx != 0) {
                eax = "Called from";
                if (*((ebp - 0x2c)) == 0) {
                    eax = edi;
                    goto label_1;
                }
            }
label_1:
            edx = *((ebp - 0x1c));
            *((esp + 0x18)) = edx;
            edx = *((ebp - 0x20));
            *((esp + 0x14)) = edx;
            edx = *((ebp - 0x24));
            *((esp + 0x10)) = edx;
            edx = *((ebp - 0x28));
            *((esp + 0xc)) = edx;
            *((esp + 8)) = eax;
            eax = stderr;
            fprintf (eax, "%s file \"%s\", line %d, characters %d-%d\n");
        }
        ebx++;
    } while (*(obj.caml_backtrace_pos) > ebx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c4c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2768 (void) {
    eax = unix_execvpe;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052390 */
#include <stdint.h>
 
int32_t camlArray_fill_1087 (void) {
    esi = eax;
    edi = edx;
    if (ebx < 1) {
        goto label_0;
    }
    if (ecx < 1) {
        goto label_0;
    }
    edx = *((esi - 4));
    eax = *((esi - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = edx;
        eax >>= 9;
    } else {
        eax = edx;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= ecx;
    eax++;
    if (ebx > eax) {
        goto label_0;
    }
    ebx = ebx + ecx - 3;
    if (ebp > ebx) {
        goto label_1;
    }
    do {
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebp*2 - 2, edi);
        } else {
            *(fp_stack--) = *(edi);
            *((esi + ebp*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebp;
        eax = ebp;
        eax += 2;
    } while (ecx != ebx);
label_1:
    eax = 1;
    return eax;
label_0:
    eax = "Array.fill";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f740 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1408 (void) {
    eax = caml_ml_input_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069993 */
#include <stdint.h>
 
int32_t caml_serialize_float_8 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    eax = *((ebp + 8));
    *((ebp - 0x10)) = eax;
    eax = *((ebp + 0xc));
    *((ebp - 0xc)) = eax;
    eax = ebp - 0x10;
    caml_serialize_block_float_8 (eax, 1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806994b */
#include <stdint.h>
 
int32_t caml_serialize_block_float_8 (int32_t arg_8h, int32_t arg_ch) {
    void ** s2;
    size_t * n;
    eax = *((ebp + 0xc));
    eax <<= 3;
    ebx = eax;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    eax = *((ebp + 8));
    eax = extern_ptr;
    memmove (eax, eax, ebx);
    *(obj.extern_ptr) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fd60 */
#include <stdint.h>
 
int32_t camlPervasives_input_1224 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = caml_ml_input;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "input";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f810 */
#include <stdint.h>
 
int32_t camlPervasives_invalid_arg_1012 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = "P5\a\b";
            *((eax + 4)) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e46e */
#include <stdint.h>
 
int32_t unix_localtime (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_1ah;
    time_t * timer;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14d8a;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0xc)) = fp_stack[0];
    fp_stack--;
    eax = ebp - 0xc;
    eax = localtime (eax);
    if (eax == 0) {
        eax = ebx - 0x2505;
        unix_error (0x16, eax, 0);
    }
    alloc_tm ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049f64 */
#include <stdint.h>
 
void localtime (void) {
    localtime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fa54 */
#include <stdint.h>
 
int32_t caml_final_custom_operations (int32_t arg_8h) {
    esi = *((ebp + 8));
    eax = custom_ops_final_table;
    if (eax == 0) {
        goto label_0;
    }
    ebx = *(eax);
    if (*((ebx + 4)) != esi) {
        goto label_1;
    }
    goto label_2;
    do {
        ebx = *(eax);
        if (*((ebx + 4)) == esi) {
            goto label_2;
        }
label_1:
        eax = *((eax + 4));
    } while (eax != 0);
label_0:
    eax = caml_stat_alloc (0x1c);
    ebx = eax;
    *(eax) = "_final";
    *((eax + 4)) = esi;
    *((eax + 8)) = 0;
    *((eax + 0xc)) = 0;
    *((eax + 0x10)) = 0;
    *((eax + 0x14)) = 0;
    caml_stat_alloc (8);
    *(eax) = ebx;
    edx = custom_ops_final_table;
    *((eax + 4)) = edx;
    *(obj.custom_ops_final_table) = eax;
label_2:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d63c */
#include <stdint.h>
 
uint32_t unix_getcwd (void) {
    int32_t var_1008h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15bb9;
    *((esp + 4)) = 0x1000;
    eax = ebp - 0x1008;
    *(esp) = eax;
    eax = getcwd ();
    if (eax == 0) {
        eax = ebx - 0x2551;
        uerror (eax, 0);
    }
    eax = ebp - 0x1008;
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a6d4 */
#include <stdint.h>
 
void getcwd (void) {
    getcwd ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068d01 */
#include <stdint.h>
 
int32_t caml_getblock (int32_t arg_8h, void * s1, int32_t arg_10h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *((ebp + 0x10));
    eax = *((ebx + 0x10));
    esi = *((ebx + 0x14));
    esi -= eax;
    if (edi <= esi) {
        eax = *((ebp + 0xc));
        eax = memmove (eax, eax, edi);
        *((ebx + 0x10)) += edi;
        esi = edi;
    } else {
        if (esi > 0) {
            eax = *((ebp + 0xc));
            memmove (eax, eax, esi);
            *((ebx + 0x10)) += esi;
        } else {
            eax = ebx + 0x34;
            *((ebp - 0x1c)) = eax;
            eax = *((ebx + 0xc));
            eax -= *((ebp - 0x1c));
            eax = *((ebp - 0x1c));
            eax = *(ebx);
            eax = caml_do_read (eax, eax, eax);
            ecx = eax;
            ecx >>= 0x1f;
            *((ebx + 4)) += eax;
            *((ebx + 8)) += ecx;
            edx = ebx + eax + 0x34;
            *((ebx + 0x14)) = edx;
            esi = edi;
            if (eax <= edi) {
                esi = eax;
            }
            eax = *((ebp - 0x1c));
            eax = *((ebp + 0xc));
            memmove (eax, eax, esi);
            eax = ebx + esi + 0x34;
            *((ebx + 0x10)) = eax;
        }
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067135 */
#include <stdint.h>
 
int32_t caml_int32_neg (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = -eax;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806496c */
#include <stdint.h>
 
uint32_t caml_check_urgent_gc (int32_t arg_8h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    ebx = caml_local_roots;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    eax = caml_force_major_slice;
    if (eax != 0) {
        *((ebp - 0x28)) = ebx;
        *((ebp - 0x20)) = 1;
        *((ebp - 0x24)) = 1;
        eax = ebp + 8;
        *((ebp - 0x1c)) = eax;
        caml_minor_collection ();
    }
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b840 */
#include <stdint.h>
 
int32_t camlPrintf_sub_format_1117 (void) {
    *(esp) = eax;
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((edx + eax));
    eax -= ecx;
    edi = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x1cf7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80597b0;
            eax = *(esp);
            *((ecx + 0xc)) = eax;
            *((ecx + 0x10)) = ebx;
            *((ecx + 0x14)) = edx;
            *((ecx + 0x18)) = edi;
            eax = ebp;
            ebx = esi;
            void (*0x80597b0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070421 */
#include <stdint.h>
 
void caml_debugger (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066fb5 */
#include <stdint.h>
 
int32_t caml_int32_shift_right_unsigned (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fdb0 */
#include <stdint.h>
 
int32_t camlPervasives_unsafe_really_input_1229 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (edx <= 1) {
            eax = 1;
            return eax;
        }
        *(esp) = edx;
        *((esp + 4)) = ecx;
        *((esp + 0xc)) = ebx;
        *((esp + 8)) = eax;
        eax = caml_ml_input;
        eax = caml_c_call (eax);
        if (eax == 1) {
label_0:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_1;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = "x5\a\b";
            eax = caml_raise_exn ();
        }
        edx = *(esp);
        edx -= eax;
        edx++;
        ebx = *((esp + 4));
        ecx = ebx + eax - 1;
        eax = *((esp + 8));
        ebx = *((esp + 0xc));
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b5a0 */
#include <stdint.h>
 
uint32_t camlSource_sock_write_1298 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (edx == 1) {
            goto label_0;
        }
        eax = camlUnix_write_1242 (edx, ecx, eax);
        edx = *(esp);
        edx -= eax;
        edx++;
        ebx = *((esp + 4));
        ecx = ebx + eax - 1;
        eax = *((esp + 8));
        ebx = *((esp + 0xc));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e2ac */
#include <stdint.h>
 
uint32_t unix_getuid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14f4c;
    getuid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a4d4 */
#include <stdint.h>
 
void getuid (void) {
    getuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f720 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1404 (void) {
    eax = caml_ml_input_int;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068ee1 */
#include <stdint.h>
 
uint32_t caml_getword (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = caml_channel_binary_mode (ebx, esi, edi);
    if (eax == 0) {
        caml_failwith ("input_binary_int: not a binary channel");
    }
    edi = 0;
    esi = 0;
    do {
        edx = *((ebx + 0x10));
        if (edx >= *((ebx + 0x14))) {
            al = caml_refill (ebx);
            eax = (int32_t) al;
        } else {
            eax = *(edx);
            edx++;
            *((ebx + 0x10)) = edx;
        }
        edi <<= 8;
        edi = eax + edi;
        esi++;
    } while (esi != 4);
    eax = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ca70 */
#include <stdint.h>
 
int32_t camlUnix_fun_2814 (void) {
    eax = unix_getsockopt;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8051c90 */
#include <stdint.h>
 
int32_t camlArray_init_1037 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    if (eax == 1) {
        eax = loc.camlArray__34;
        return eax;
    }
    eax = 1;
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t, uint32_t) (eax, ebx);
    eax = *((esp + 4));
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    esi = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (esi > eax) {
        goto label_0;
    }
    do {
        ebx = *((esp + 4));
        ecx = *(ebx);
        eax = esi;
        eax = void (*ecx)(uint32_t, uint32_t) (esi, eax);
        ebx = *(esp);
        ecx = *((ebx - 4));
        if (ecx != 0xfe) {
            esi = *((esp + 0x10));
            eax = caml_modify (ebx + esi*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            esi = *((esp + 0xc));
            *((ebx + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = esi;
        esi += 2;
        *((esp + 0xc)) = esi;
        eax = *((esp + 8));
    } while (ecx != eax);
label_0:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b3c0 */
#include <stdint.h>
 
int32_t caml_tuplify2 (void) {
    ecx = ebx;
    ebx = *((eax + 4));
    eax = *(eax);
    edx = *((ecx + 8));
    return void (*edx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b300 */
#include <stdint.h>
 
uint32_t camlPrintf_index_of_int_1037 (void) {
    if (eax >= 1) {
        return;
    }
    eax = camlPervasives_string_of_int_1130 ();
    ebx = eax;
    eax = "Sformat.index_of_int: negative argument ";
    camlPervasives_$5e_1112 ();
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e460 */
#include <stdint.h>
 
int32_t caml_callback3 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = *((ebp + 0x14));
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = loc_caml_callback3_exn (eax, eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070658 */
#include <stdint.h>
 
int32_t loc_caml_callback3_exn (int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, int32_t arg_20h) {
    edx = *((esp + 0x14));
    eax = *((esp + 0x18));
    ebx = *((esp + 0x1c));
    ecx = *((esp + 0x20));
    esi = caml_apply3;
    return void (*0x8070559)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056e40 */
#include <stdint.h>
 
int32_t camlHashtbl_remove_1185 (void) {
    int32_t var_4h_3;
    int32_t var_4h_2;
    int32_t var_8h;
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = loc.camlHashtbl__code_begin;
            *((eax + 4)) = 3;
            esi = *((ecx + 0xc));
            *((eax + 8)) = esi;
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = ebx;
            esi = *((edx + 4));
            esi = *((esi - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = *((ecx + 0x10));
                eax = *((eax + 8));
                edx = *((eax + 4));
                ecx = *(edx);
                eax = ebx;
                ebx = edx;
                eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, esi);
                ebx = 0x7fffffff;
                eax &= ebx;
                eax >>= 1;
                ecx = *((esp + 8));
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            *((esp + 8)) = edx;
            eax = *(esp);
            ebx = *((eax + 4));
            *(esp) = ebx;
            ebx = *((ebx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_0;
            }
            ebx = *((eax + 4));
            eax = *((ebx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_1;
            }
            eax = *((ebx + edx*2 - 2));
            ebx = *((esp + 4));
            eax = camlHashtbl_code_begin ();
            ebx = *((esp + 4));
            eax = *((esp + 0xc));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c100 */
#include <stdint.h>
 
int32_t camlUnix_fun_2660 (void) {
    eax = unix_time;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8057580 */
#include <stdint.h>
 
void camlHashtbl_hash_1031 (void) {
    caml_hash_univ_param (0x15, 0xc9, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ba4f */
#include <stdint.h>
 
int32_t caml_hash_univ_param (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    *(obj.hash_univ_limit) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(obj.hash_univ_count) = eax;
    *(obj.hash_accu) = 0;
    eax = *((ebp + 0x10));
    hash_aux ();
    eax = hash_accu;
    eax &= 0x3fffffff;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a8a8 */
#include <stdint.h>
 
int32_t caml_deserialize_block_4 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    ecx = *((ebp + 8));
    edx = intern_src;
    if (*((ebp + 0xc)) <= 0) {
        goto label_0;
    }
    ebx = *((ebp + 0xc));
    eax = 0;
    *((ebp - 0x10)) = ebx;
    do {
        edi = *((edx + eax));
        esi = *((edx + eax + 1));
        ebx = *((edx + eax + 3));
        *((ecx + eax)) = bl;
        ebx = *((edx + eax + 2));
        *((ecx + eax + 1)) = bl;
        ebx = edi;
        *((ecx + eax + 3)) = bl;
        ebx = esi;
        *((ecx + eax + 2)) = bl;
        eax += 4;
        *((ebp - 0x10))--;
    } while (*((ebp - 0x10)) != 0);
    eax = *((ebp + 0xc));
    edx = edx + eax*4;
label_0:
    *(obj.intern_src) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055600 */
#include <stdint.h>
 
int32_t camlChar_uppercase_1045 (void) {
    if (eax >= 0xc3) {
        if (eax <= 0xf5) {
            goto label_0;
        }
    }
    if (eax >= 0x1c1) {
        if (eax <= 0x1ed) {
            goto label_0;
        }
    }
    if (eax >= 0x1f1) {
        if (eax <= 0x1fd) {
            goto label_0;
        }
    }
    return;
label_0:
    eax += 0xffffffc0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c480 */
#include <stdint.h>
 
int32_t camlUnix_fun_2760 (void) {
    eax = unix_getpid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059450 */
#include <stdint.h>
 
int32_t camlPrintf_doprn_1360 (void) {
    int32_t var_8h;
    int32_t var_ch;
    do {
        edx = ebx;
        eax = *((ecx + 0x80));
        if (edx >= eax) {
            ebx = *((ecx + 0x74));
            eax = *((ecx + 0x6c));
            ecx = *(ebx);
            void (*ecx)() ();
        }
        ebx = edx;
        ebx >>= 1;
        eax = *((ecx + 0x78));
        eax = *((eax + ebx));
        ebx = eax + eax + 1;
        if (ebx == 0x4b) {
            goto label_0;
        }
        edx = *((ecx + 0x60));
        eax = *((ecx + 0x6c));
        ecx = edx;
        caml_apply2 (edx, ebp, ecx);
        ebx = *(esp);
        ebx += 2;
        eax = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_0:
    eax = ecx;
    eax += 0x50;
    *((esp + 4)) = eax;
    eax = ecx;
    eax += 0x40;
    *(esp) = eax;
    *((esp + 8)) = ecx;
    edi = ecx;
    edi += 0x20;
    esi = ecx;
    esi += 0x10;
    ebx = *((ecx + 0x7c));
    eax = *((ecx + 0x78));
    ecx = ebp;
    ebp = *((esp + 8));
    *(loc.caml_extra_params) = ebp;
    ebp = *(esp);
    *(0x807cb20) = ebp;
    ebp = *((esp + 4));
    *(0x807cb24) = ebp;
    return camlPrintf_scan_format_1278 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c240 */
#include <stdint.h>
 
int32_t camlUnix_fun_2696 (void) {
    eax = unix_rmdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066112 */
#include <stdint.h>
 
int32_t caml_int64_compare (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    ebx = *((edx + 4));
    edx = *((edx + 8));
    esi = *((eax + 4));
    eax = *((eax + 8));
    edi = 1;
    if (edx <= eax) {
        if (edx >= eax) {
            if (ebx > esi) {
                goto label_0;
            }
        }
        edi = 0;
    }
label_0:
    ecx = 1;
    if (edx >= eax) {
        if (edx <= eax) {
            if (ebx < esi) {
                goto label_1;
            }
        }
        ecx = 0;
    }
label_1:
    edi -= ecx;
    eax = edi + edi + 1;
    ebx = *(esp);
    esi = *((esp + 4));
    edi = *((esp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f700 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1400 (void) {
    eax = caml_ml_seek_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056400 */
#include <stdint.h>
 
int32_t camlSys_set_signal_1057 (void) {
    eax = caml_install_signal_handler;
    caml_c_call (eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066824 */
#include <stdint.h>
 
int32_t caml_nativeint_shift_right_unsigned (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066714 */
#include <stdint.h>
 
int32_t caml_nativeint_to_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e502 */
#include <stdint.h>
 
int32_t caml_callbackN_exn (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8ch;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_74h;
    int32_t var_70h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edi = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    eax = caml_local_roots;
    *((ebp - 0x8c)) = eax;
    eax = ebp - 0x7c;
    *(obj.caml_local_roots) = eax;
    eax = *((ebp + 8));
    *((ebp - 0x5c)) = eax;
    if (edi <= 0) {
        goto label_0;
    }
    edx = *((ebp - 0x8c));
    *((ebp - 0x38)) = edx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp - 0x38;
    *((ebp - 0x58)) = eax;
    *((ebp - 0x50)) = edi;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x4c)) = esi;
    eax = ebp - 0x58;
    *((ebp - 0x7c)) = eax;
    *((ebp - 0x74)) = 1;
    *((ebp - 0x78)) = 1;
    eax = ebp - 0x5c;
    *((ebp - 0x70)) = eax;
    ebx = 0;
    do {
        eax = edi;
        eax -= ebx;
        if (eax != 1) {
            if (eax != 2) {
                goto label_1;
            }
        } else {
            eax = *((esi + ebx*4));
            eax = *((ebp - 0x5c));
            eax = caml_callback_exn (eax, eax);
            edx = eax;
            edx &= 3;
            if (edx == 2) {
                edx = *((ebp - 0x8c));
                *(obj.caml_local_roots) = edx;
                goto label_2;
            }
            *((ebp - 0x5c)) = eax;
            ebx++;
            goto label_3;
        }
        eax = *((esi + ebx*4 + 4));
        eax = *((esi + ebx*4));
        eax = *((ebp - 0x5c));
        eax = caml_callback2_exn (eax, eax, eax);
        edx = eax;
        edx &= 3;
        if (edx == 2) {
            edx = *((ebp - 0x8c));
            *(obj.caml_local_roots) = edx;
            goto label_2;
        }
        *((ebp - 0x5c)) = eax;
        ebx += 2;
        goto label_3;
label_1:
        eax = *((esi + ebx*4 + 8));
        eax = *((esi + ebx*4 + 4));
        eax = *((esi + ebx*4));
        eax = *((ebp - 0x5c));
        eax = loc_caml_callback3_exn (eax, eax, eax);
        edx = eax;
        edx &= 3;
        if (edx == 2) {
            edx = *((ebp - 0x8c));
            *(obj.caml_local_roots) = edx;
            goto label_2;
        }
        *((ebp - 0x5c)) = eax;
        ebx += 3;
label_3:
    } while (edi > ebx);
label_0:
    eax = *((ebp - 0x8c));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x5c));
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069797 */
#include <stdint.h>
 
int32_t caml_ml_open_descriptor_in (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    eax = caml_open_descriptor_in (eax);
    caml_alloc_channel (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068636 */
#include <stdint.h>
 
void caml_alloc_channel (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ebx = *((ebp + 8));
    *((ebx + 0x2c))++;
    caml_alloc_custom (ebx, 4, 1);
    *((eax + 4)) = ebx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ab5e */
#include <stdint.h>
 
int32_t caml_code_checksum (void) {
    int32_t var_60h;
    int32_t var_4h;
    int32_t var_8h;
    if (*(obj.checksum_computed.3405) == 0) {
        ebx = ebp - 0x60;
        caml_MD5Init (ebx);
        eax = caml_code_area_start;
        edx = caml_code_area_end;
        edx -= eax;
        caml_MD5Update (ebx, eax, edx);
        caml_MD5Final (obj.checksum.3404, ebx);
        *(obj.checksum_computed.3405) = 1;
    }
    eax = checksum.3404;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806d4f8 */
#include <stdint.h>
 
int32_t caml_MD5Init (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(eax) = 0x67452301;
    *((eax + 4)) = 0xefcdab89;
    *((eax + 8)) = 0x98badcfe;
    *((eax + 0xc)) = 0x10325476;
    *((eax + 0x10)) = 0;
    *((eax + 0x14)) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806dd76 */
#include <stdint.h>
 
int32_t caml_MD5Update (void * s1, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_20h;
    int32_t var_1ch;
    void * s2;
    size_t n;
    edi = *((ebp + 0x10));
    eax = *((ebp + 8));
    ebx = *((eax + 0x10));
    eax = ebx + edi*8;
    edx = *((ebp + 8));
    *((edx + 0x10)) = eax;
    if (ebx > eax) {
        *((edx + 0x14))++;
    }
    eax = edi;
    eax >>= 0x1d;
    edx = *((ebp + 8));
    *((edx + 0x14)) += eax;
    ebx >>= 3;
    ebx &= 0x3f;
    if (ebx != 0) {
        eax = edx + ebx + 0x18;
        edx = 0x40;
        edx -= ebx;
        ebx = edx;
        if (edi < edx) {
            edx = *((ebp + 0xc));
            eax = memcpy (eax, edx, edi);
            goto label_0;
        }
        edx = *((ebp + 0xc));
        memcpy (eax, edx, edx);
        eax = *((ebp + 8));
        eax += 0x18;
        eax = *((ebp + 8));
        caml_MD5Transform (eax, eax);
        *((ebp + 0xc)) += ebx;
        edi -= ebx;
    }
    if (edi <= 0x3f) {
        goto label_1;
    }
    ebx = *((ebp + 8));
    ebx += 0x18;
    *((ebp - 0x20)) = ebx;
    edx = *((ebp + 8));
    *((ebp - 0x1c)) = edx;
    esi = 0;
    do {
        eax = *((ebp + 0xc));
        eax += esi;
        edx = *(eax);
        *(ebx) = edx;
        edx = *((eax + 4));
        *((ebx + 4)) = edx;
        edx = *((eax + 8));
        *((ebx + 8)) = edx;
        edx = *((eax + 0xc));
        *((ebx + 0xc)) = edx;
        edx = *((eax + 0x10));
        *((ebx + 0x10)) = edx;
        edx = *((eax + 0x14));
        *((ebx + 0x14)) = edx;
        edx = *((eax + 0x18));
        *((ebx + 0x18)) = edx;
        edx = *((eax + 0x1c));
        *((ebx + 0x1c)) = edx;
        edx = *((eax + 0x20));
        *((ebx + 0x20)) = edx;
        edx = *((eax + 0x24));
        *((ebx + 0x24)) = edx;
        edx = *((eax + 0x28));
        *((ebx + 0x28)) = edx;
        edx = *((eax + 0x2c));
        *((ebx + 0x2c)) = edx;
        edx = *((eax + 0x30));
        *((ebx + 0x30)) = edx;
        edx = *((eax + 0x34));
        *((ebx + 0x34)) = edx;
        edx = *((eax + 0x38));
        *((ebx + 0x38)) = edx;
        eax = *((eax + 0x3c));
        *((ebx + 0x3c)) = eax;
        eax = *((ebp - 0x20));
        edx = *((ebp - 0x1c));
        caml_MD5Transform (edx, eax);
        esi += 0x40;
        eax = edi;
        eax -= esi;
    } while (eax > 0x3f);
    edi -= 0x40;
    eax = edi;
    eax &= 0xffffffc0;
    edx = *((ebp + 0xc));
    edx = edx + eax + 0x40;
    *((ebp + 0xc)) = edx;
    edi &= 0x3f;
label_1:
    eax = *((ebp + 8));
    eax += 0x18;
    edx = *((ebp + 0xc));
    memcpy (eax, edx, edi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806dc88 */
#include <stdint.h>
 
int32_t caml_MD5Final (int32_t arg_8h, int32_t arg_ch) {
    int32_t c;
    size_t n;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = *((ebx + 0x10));
    eax >>= 3;
    eax &= 0x3f;
    *((ebx + eax + 0x18)) = 0x80;
    edx = ebx + eax + 0x19;
    ecx = 0x3f;
    ecx -= eax;
    eax = ecx;
    if (ecx <= 7) {
        memset (edx, 0, ecx);
        edi = ebx + 0x18;
        caml_MD5Transform (ebx, edi);
        edx = 0x38;
        eax = 0;
        if ((edi & 1) != 0) {
            *(edi) = al;
            edi++;
            edx--;
        }
        if ((edi & 2) != 0) {
            *(edi) = ax;
            edi += 2;
            edx -= 2;
        }
        ecx = edx;
        ecx >>= 2;
        memset (edi, eax, ecx);
        if ((dl & 2) != 0) {
            *(edi) = ax;
            edi += 2;
        }
        if ((dl & 1) == 0) {
            goto label_0;
        }
        *(edi) = al;
    } else {
        eax -= 8;
        memset (edx, 0, eax);
    }
label_0:
    eax = ebx + 0x18;
    edx = *((ebx + 0x10));
    *((eax + 0x38)) = edx;
    edx = *((ebx + 0x14));
    *((eax + 0x3c)) = edx;
    caml_MD5Transform (ebx, eax);
    eax = *(ebx);
    *(esi) = eax;
    eax = *((ebx + 4));
    *((esi + 4)) = eax;
    eax = *((ebx + 8));
    *((esi + 8)) = eax;
    eax = *((ebx + 0xc));
    *((esi + 0xc)) = eax;
    *(ebx) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ddc0 */
#include <stdint.h>
 
uint32_t unix_getpid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15438;
    getpid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049e64 */
#include <stdint.h>
 
void getpid (void) {
    getpid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060a00 */
#include <stdint.h>
 
int32_t unix_tcflow (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x127f8;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x22a4));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcflow ();
    if (eax == -1) {
        eax = ebx - 0x22f6;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049e34 */
#include <stdint.h>
 
void tcflow (void) {
    tcflow ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b020 */
#include <stdint.h>
 
int32_t camlPrintf_scan_flags_1292 (void) {
    edi = eax;
    ebx = edx;
    ebx >>= 1;
    eax = *((esi + 0x1c));
    eax = *((eax + ebx));
    eax = eax + eax + 1;
    eax += 0xffffffc0;
    if (eax > 0x33) {
        void (*0x805b0b0)() ();
    }
    eax >>= 1;
    /* switch table (38 cases) at 0x807b1ec */
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a8d0 */
#include <stdint.h>
 
int32_t case_0x8059907_217 (void) {
    ecx = *((esi + 0x20));
    edx += 2;
    eax = ebx;
    ebx = edx;
    return caml_apply2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a8f0 */
#include <stdint.h>
 
int32_t case_0x8059907_221 (void) {
    esi = *((esi + 0x14));
    ecx = edx;
    ecx += 2;
    edi = loc.camlPrintf__59;
    eax = ebx;
    ebx = edi;
    edx = esi;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a910 */
#include <stdint.h>
 
int32_t case_0x8059907_225 (void) {
    esi = *((esi + 0x14));
    ecx = edx;
    ecx += 2;
    edi = loc.camlPrintf__60;
    eax = ebx;
    ebx = edi;
    edx = esi;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a930 */
#include <stdint.h>
 
int32_t case_0x8059907_228 (void) {
    esi = *((esi + 0x14));
    ecx = edx;
    ecx += 2;
    edi = loc.camlPrintf__61;
    eax = ebx;
    ebx = edi;
    edx = esi;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805aad0 */
#include <stdint.h>
 
int32_t case_0x8059a9a_235 (void) {
    eax = *((esi + 0xc));
    ebx = edx;
    return camlPrintf_bad_conversion_format_1061 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805aba0 */
#include <stdint.h>
 
uint32_t case_0x8059907_251 (int32_t arg_ch_5, int32_t arg_10h_2, int32_t arg_14h_2, int32_t arg_18h_2) {
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx);
    ebx = eax;
    eax = *(esp);
    if (eax == 0xc7) {
        eax = 3;
        eax = camlString_make_1038 ();
        *(esp) = eax;
    } else {
        eax = ebx;
        camlChar_escaped_1038 ();
        ebx = loc.camlPrintf__56;
        eax = camlPervasives_$5e_1112 ();
        ebx = eax;
        eax = camlPrintf__55;
        eax = camlPervasives_$5e_1112 ();
        *(esp) = eax;
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ad30 */
#include <stdint.h>
 
uint32_t case_0x8059907_250 (int32_t arg_ch_5, int32_t arg_10h_2, int32_t arg_14h_2, int32_t arg_18h_2) {
    ecx = *((esi + 0x28));
    camlPrintf_get_arg_1288 ();
    eax = camlPervasives_string_of_bool_1127 ();
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805af50 */
#include <stdint.h>
 
uint32_t case_0x8059907_224 (int32_t arg_4h_3, int32_t arg_8h_2, int32_t arg_ch_4, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx);
    eax = *((esp + 0xc));
    eax += 2;
    eax = *((esp + 4));
    eax = camlPrintf_sub_format_for_printf_1135 (eax, eax);
    ecx = eax;
    eax = *((esp + 0x18));
    eax = *((eax + 0xc));
    ebx = *(esp);
    eax = caml_apply2 ();
    *((esp + 0xc)) = eax;
    eax = *((esp + 4));
    if (eax == 0xf7) {
        eax = *((esp + 8));
        eax = camlPrintf_summarize_format_type_1162 ();
        *(esp) = eax;
        eax = *((esp + 0x10));
        if (eax != 1) {
            eax = *((esp + 0x14));
        } else {
            eax = .comment;
            ebx = *((eax + 8));
            ecx = *(ebx);
            eax = *((esp + 0x14));
            void (*ecx)() ();
        }
        ebx = *((esp + 0x18));
        edx = *((ebx + 0x14));
        ebx = *(esp);
        ecx = *((esp + 0xc));
        void (*0x804b4f0)() ();
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x24));
    ebx = *((esp + 8));
    ecx = *((esp + 0xc));
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a800 */
#include <stdint.h>
 
int32_t camlPrintf_get_arg_1288 (void) {
    if (eax != 1) {
        ebx = *(eax);
    }
    ecx = *((ecx + 0xc));
    eax = *((ecx - 4));
    edx = *((ecx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
        if (eax <= ebx) {
            goto label_0;
        }
        eax = *((ecx + ebx*2 - 2));
        return eax;
    }
    eax >>= 0xa;
    if (eax <= ebx) {
        goto label_1;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fab0 */
#include <stdint.h>
 
int32_t camlPervasives_string_of_float_1140 (void) {
    eax = caml_format_float;
    caml_c_call ("%.12g");
    return camlPervasives_valid_float_lexem_1135 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b7c0 */
#include <stdint.h>
 
int32_t camlPrintf_extract_format_float_1110 (void) {
    eax = ebx;
    ebx = ecx;
    ecx = edx;
    edx = esi;
    camlPrintf_extract_format_1085 (eax);
    ebx = *(esp);
    if (ebx != 0x8d) {
        return eax;
    }
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx - 1;
    ebx >>= 1;
    ecx = *((eax - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((eax + ecx));
    ecx -= edx;
    if (ecx > ebx) {
        edx = 0x67;
        *((eax + ebx)) = dl;
        return eax;
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b630 */
#include <stdint.h>
 
int32_t camlPrintf_extract_format_1085 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    esi = eax;
    *(esp) = esi;
    *((esp + 4)) = ecx;
    *((esp + 0xc)) = edx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0xcf7;
    *(ecx) = sym.camlPrintf__skip_positional_spec_1090;
    *((ecx + 4)) = 3;
    *((ecx + 8)) = esi;
    eax = ebx;
    eax += 2;
    ebx = ecx;
    eax = camlPrintf_skip_positional_spec_1090 (ecx);
    ebx = eax;
    eax = *((esp + 4));
    eax -= ebx;
    eax += 0x15;
    eax = camlBuffer_create_1039 (ebx);
    ebx = 0x4b;
    camlBuffer_add_char_1072 (eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x1cf7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x80596c0;
            eax = *(esp);
            *((ebx + 0xc)) = eax;
            eax = *((esp + 4));
            *((ebx + 0x10)) = eax;
            eax = *((esp + 8));
            *((ebx + 0x14)) = eax;
            eax = *((esp + 0x18));
            *((ebx + 0x18)) = eax;
            ebx = 1;
            eax = *((esp + 0xc));
            eax = camlList_rev_append_1051 (ebx);
            ebx = eax;
            eax = *((esp + 0x10));
            ecx = *((esp + 0x14));
            camlPrintf_fill_format_1096 ();
            eax = *((esp + 0x18));
            ecx = *((eax + 4));
            ebx = 1;
            eax = *(eax);
            void (*0x8055800)() ();
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059650 */
#include <stdint.h>
 
int32_t camlPrintf_skip_positional_spec_1090 (void) {
    ecx = eax;
    edx = eax;
    edx >>= 1;
    eax = *((ebx + 8));
    eax = *((eax + edx));
    eax = eax + eax + 1;
    eax += 0xffffffa0;
    if (eax <= 0x13) {
        goto label_0;
    }
    eax = ecx;
    return eax;
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.camlPrintf__skip_int_literal_1092;
            *((edx + 4)) = 3;
            eax = *((ebx + 8));
            *((edx + 8)) = eax;
            *((edx + 0xc)) = ecx;
            eax = ecx;
            eax += 2;
            ebx = edx;
            void (*0x8058f70)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058670 */
#include <stdint.h>
 
int32_t camlBuffer_create_1039 (void) {
    if (eax < 3) {
        eax = 3;
    }
    ebx = .comment;
    if (eax > ebx) {
        eax = .comment;
        *(esp) = eax;
    } else {
        *(esp) = eax;
    }
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x1000;
            *(eax) = ecx;
            *((eax + 4)) = 1;
            ebx = *(esp);
            *((eax + 8)) = ebx;
            *((eax + 0xc)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058960 */
#include <stdint.h>
 
int32_t camlBuffer_add_char_1072 (void) {
    int32_t var_4h_2;
    int32_t var_8h;
    *(esp) = eax;
    *((esp + 8)) = ebx;
    ecx = *((eax + 4));
    *((esp + 4)) = ecx;
    ebx = *((eax + 8));
    if (ecx >= ebx) {
        ebx = 3;
        camlBuffer_resize_1066 ();
    }
    esi = *(esp);
    ebx = *(esi);
    ecx = *((esp + 4));
    eax = *((esp + 4));
    eax >>= 1;
    edx = *((ebx - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    edi = *((ebx + edx));
    edx -= edi;
    if (edx > eax) {
        edx = *((esp + 8));
        edx >>= 1;
        *((ebx + eax)) = dl;
        ecx += 2;
        *((esi + 4)) = ecx;
        eax = 1;
        return eax;
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054520 */
#include <stdint.h>
 
int32_t camlList_rev_append_1051 (void) {
    do {
        if (eax == 1) {
            goto label_1;
        }
        esi = *((eax + 4));
        edx = *(eax);
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x800;
        *(ecx) = edx;
        *((ecx + 4)) = ebx;
        eax = esi;
        ebx = ecx;
    } while (1);
label_1:
    eax = ebx;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80596c0 */
#include <stdint.h>
 
int32_t camlPrintf_fill_format_1096 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
label_0:
        edx = *((ecx + 0x10));
        if (eax > edx) {
            goto label_1;
        }
        esi = eax;
        esi >>= 1;
        edx = *((ecx + 0xc));
        edx = *((edx + esi));
        edx = edx + edx + 1;
        if (edx == 0x55) {
            goto label_2;
        }
        eax = *((ecx + 0x18));
        ebx = edx;
        camlBuffer_add_char_1072 (ebx, eax, ecx);
        eax = *((esp + 4));
        eax += 2;
        ebx = *(esp);
        ecx = *((esp + 8));
    } while (1);
label_2:
    if (ebx == 1) {
        goto label_3;
    }
    eax = *((ebx + 4));
    eax = *(ebx);
    eax = camlPervasives_string_of_int_1130 (eax, eax, ecx);
    ebx = eax;
    eax = *((esp + 8));
    eax = *((eax + 0x18));
    camlBuffer_add_string_1082 ();
    eax = *((esp + 8));
    ebx = *((eax + 0x14));
    eax = *((esp + 4));
    eax += 2;
    camlPrintf_skip_positional_spec_1090 ();
    ebx = *(esp);
    ecx = *((esp + 8));
    goto label_0;
    do {
label_3:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = "L6\a\b";
            *((eax + 4)) = 0x807ac78;
            caml_raise_exn ();
label_1:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070678 */
#include <stdint.h>
 
void loc_caml_ml_array_bound_error (int32_t arg_4h) {
    edx = *(esp);
    *(obj.caml_last_return_address) = edx;
    edx = esp + 4;
    *(obj.caml_bottom_of_stack) = edx;
    return caml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805bf40 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1600 (void) {
    int32_t var_4h;
    *(esp) = ebx;
    eax = caml_format_float;
    eax = caml_c_call (eax);
    *((esp + 4)) = eax;
    eax = *(esp);
    eax = caml_classify_float;
    eax = caml_c_call (eax);
    if (eax >= 7) {
        eax = *((esp + 4));
        return eax;
    }
    eax = *((esp + 4));
    return camlPrintf_make_valid_float_lexeme_1270 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055b30 */
#include <stdint.h>
 
int32_t camlString_escaped_1080 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    edx = eax;
    *((esp + 0x10)) = edx;
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x400;
    *(ebx) = 1;
    eax = 1;
    ecx = *((edx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((edx + ecx));
    ecx -= edx;
    ecx = ecx + ecx - 1;
    if (eax > ecx) {
        goto label_2;
    }
    *((esp + 4)) = ecx;
    *(esp) = eax;
    *((esp + 0x14)) = ebx;
    do {
        eax >>= 1;
        ebx = *((esp + 0x10));
        eax = *((ebx + eax));
        eax = eax + eax + 1;
        if (eax >= 0x1d) {
            if (eax == 0x45) {
                goto label_3;
            }
            if (eax == 0xb9) {
                goto label_3;
            }
        } else {
            if (eax >= 0x17) {
                if (eax >= 0x1b) {
                    goto label_3;
                }
            } else {
                if (eax >= 0x11) {
                    goto label_3;
                }
            }
        }
        eax = caml_is_printable;
        eax = caml_c_call (eax);
        if (eax != 1) {
            ecx = 3;
        } else {
            ecx = 9;
            goto label_4;
label_3:
            ecx = 5;
        }
label_4:
        ebx = *((esp + 0x14));
        eax = *(ebx);
        eax += ecx;
        eax--;
        *(ebx) = eax;
        eax = *(esp);
        edx = *(esp);
        eax += 2;
        *(esp) = eax;
        ecx = *((esp + 4));
    } while (edx != ecx);
label_2:
    eax = *((esp + 0x10));
    ecx = *((eax - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((eax + ecx));
    ecx -= edx;
    edx = ecx + ecx + 1;
    ecx = *(ebx);
    if (ecx == edx) {
        return eax;
    }
    *((esp + 0x14)) = ebx;
    *((esp + 0x10)) = eax;
    eax = caml_create_string;
    eax = caml_c_call (*(ebx));
    esi = *((esp + 0x14));
    *(esi) = 1;
    eax = 1;
    ebx = *((esp + 0x10));
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx - 1;
    if (eax > ecx) {
        goto label_5;
    }
    *((esp + 8)) = ecx;
    *((esp + 4)) = eax;
    *((esp + 0xc)) = ebp;
    *((esp + 0x14)) = esi;
    *((esp + 0x10)) = ebx;
    do {
        eax >>= 1;
        ebx = *((esp + 0x10));
        eax = *((ebx + eax));
        eax = eax + eax + 1;
        ebx = eax;
        ebx += 0xffffffbc;
        if (ebx > 0x75) {
            if (ebx >= 0xffffffd9) {
                goto label_6;
            }
            ebx += 0x44;
            ebx >>= 1;
        }
        ebx += 0xfffffffe;
        if (ebx > 0x71) {
            ebx = *(esi);
            ebx >>= 1;
            edx = 0x5c;
            *((ebp + ebx)) = dl;
            *(esi) += 2;
            ebx = *(esi);
            ebx >>= 1;
            eax >>= 1;
            edx = eax;
            *((ebp + ebx)) = dl;
        } else {
label_6:
            *(esp) = eax;
            eax = caml_is_printable;
            eax = caml_c_call (eax);
            if (eax != 1) {
                esi = *((esp + 0x14));
                eax = *(esi);
                eax >>= 1;
                edx = *(esp);
                edx >>= 1;
                ebp = *((esp + 0xc));
                *((ebp + eax)) = dl;
            } else {
                edi = *(esp);
                esi = *((esp + 0x14));
                eax = *(esi);
                eax >>= 1;
                edx = 0x5c;
                ebp = *((esp + 0xc));
                *((ebp + eax)) = dl;
                *(esi) += 2;
                ebx = *(esi);
                ebx >>= 1;
                ecx = 0x64;
                eax = edi;
                eax >>= 1;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                edx = eax + eax + 0x61;
                edx >>= 1;
                *((ebp + ebx)) = dl;
                *(esi) += 2;
                ebx = *(esi);
                ebx >>= 1;
                eax = 0xa;
                *(esp) = eax;
                ecx = 0xa;
                eax = edi;
                eax >>= 1;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                ecx = *(esp);
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                edx = edx + edx + 0x61;
                edx >>= 1;
                *((ebp + ebx)) = dl;
                *(esi) += 2;
                ebx = *(esi);
                ebx >>= 1;
                ecx = 0xa;
                eax = edi;
                eax >>= 1;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
                edx = edx + edx + 0x61;
                edx >>= 1;
                *((ebp + ebx)) = dl;
            }
        }
        *(esi) += 2;
        eax = *((esp + 4));
        ecx = *((esp + 4));
        eax += 2;
        *((esp + 4)) = eax;
        ebx = *((esp + 8));
    } while (ecx != ebx);
label_5:
    eax = ebp;
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b5f0 */
#include <stdint.h>
 
uint32_t camlPrintf_format_string_1080 (void) {
    eax = camlPrintf_parse_string_conversion_1067 (ebx);
    ecx = *((eax + 4));
    ebx = *(eax);
    edx = *(esp);
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    esi = *((edx + eax));
    eax -= esi;
    edi = eax + eax + 1;
    esi = 1;
    eax = 0x41;
    return camlPrintf_pad_string_1072 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055800 */
#include <stdint.h>
 
int32_t camlString_sub_1046 (void) {
    int32_t var_14h;
    int32_t var_18h;
    if (ebx >= 1) {
        if (ecx < 1) {
            goto label_0;
        }
        edx = *((eax - 4));
        edx >>= 0xa;
        edx = edx*4 - 1;
        esi = *((eax + edx));
        edx -= esi;
        edx <<= 1;
        edx -= ecx;
        edx += 2;
        if (ebx > edx) {
            goto label_0;
        }
        *(esp) = ecx;
        *((esp + 4)) = ebx;
        *((esp + 8)) = eax;
        eax = caml_create_string;
        eax = caml_c_call (ecx);
        ebx = eax;
        eax = *(esp);
        eax = *((esp + 0x10));
        eax = *((esp + 0x18));
        caml_blit_string (eax, eax, ebx, 1, eax);
        eax = ebx;
        return eax;
    }
label_0:
    eax = "String.sub";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055770 */
#include <stdint.h>
 
int32_t camlString_make_1038 (void) {
    int32_t var_4h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    eax = *((esp + 8));
    caml_fill_string (ebx, 1, eax, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067bbc */
#include <stdint.h>
 
int32_t caml_fill_string (void * s, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t c;
    size_t n;
    ecx = *((ebp + 0x10));
    ecx >>= 1;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    edx = *((ebp + 0x14));
    edx >>= 1;
    memset (eax, edx, ecx);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a074 */
#include <stdint.h>
 
void memset (void) {
    memset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80558d0 */
#include <stdint.h>
 
int32_t camlString_blit_1056 (void) {
    if (esi >= 1) {
        if (ebx < 1) {
            goto label_0;
        }
        edi = *((eax - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((eax + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= esi;
        ebp += 2;
        if (ebx > ebp) {
            goto label_0;
        }
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ecx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ecx + ebp));
        ebp -= edi;
        edi = ebp;
        edi <<= 1;
        edi -= esi;
        edi += 2;
        if (edx > edi) {
            goto label_0;
        }
        caml_blit_string (eax, ebx, ecx, edx, esi);
        return;
    }
label_0:
    eax = "String.blit";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b480 */
#include <stdint.h>
 
int32_t camlPrintf_parse_string_conversion_1067 (void) {
    ebx = eax;
    *(esp) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8059520;
            *((ecx + 0xc)) = ebx;
            eax = void (*0x805b500)() ();
            ecx = "45\a\b";
            ebx = *(eax);
            if (ebx == ecx) {
                ecx = 0xe7;
                ebx = 1;
                eax = *(esp);
                void (*0x805b390)() ();
            }
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            ebx = 3;
            eax = 1;
            camlPrintf_parse_1069 (*(obj.caml_exception_pointer));
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b740 */
#include <stdint.h>
 
int32_t camlPrintf_extract_format_int_1103 (void) {
    eax = ebx;
    ebx = ecx;
    ecx = edx;
    edx = esi;
    camlPrintf_extract_format_1085 (eax);
    ebx = *(esp);
    if (ebx != 0x9d) {
        if (ebx == 0xdd) {
            goto label_0;
        }
        return eax;
    }
label_0:
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx - 1;
    ebx >>= 1;
    ecx = *((eax - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((eax + ecx));
    ecx -= edx;
    if (ecx > ebx) {
        edx = 0x75;
        *((eax + ebx)) = dl;
        return eax;
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805be10 */
#include <stdint.h>
 
int32_t camlPrintf_scan_positional_spec_1252 (void) {
    esi = eax;
    edi = ebx;
    ebx = edx;
    eax = edx;
    eax >>= 1;
    eax = *((esi + eax));
    edx = eax + eax + 1;
    eax = edx;
    eax += 0xffffffa0;
    if (eax <= 0x13) {
        goto label_0;
    }
    eax = 1;
    ecx = edi;
    void (*0x804b540)() ();
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x18f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x805a6c0;
            *((ecx + 0xc)) = esi;
            *((ecx + 0x10)) = edi;
            *((ecx + 0x14)) = ebx;
            ebx += 2;
            eax = edx;
            eax += 0xffffffa0;
            void (*0x805a6c0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b540 */
#include <stdint.h>
 
uint32_t caml_apply2 (void) {
    edx = *((ecx + 4));
    if (edx == 5) {
        edx = *((ecx + 8));
        void (*edx)() ();
    }
    edx = *(ecx);
    ebx = ecx;
    eax = void (*edx)(uint32_t) (ebx);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049e24 */
#include <stdint.h>
 
void sprintf (void) {
    sprintf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a184 */
#include <stdint.h>
 
void strtol (void) {
    strtol ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050290 */
#include <stdint.h>
 
int32_t camlPervasives_exit_1326 (void) {
    eax = .comment;
    ebx = *(eax);
    eax = 1;
    ecx = *(ebx);
    void (*ecx)(uint32_t) (eax);
    eax = *(esp);
    eax = caml_sys_exit;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055470 */
#include <stdint.h>
 
int32_t camlChar_chr_1032 (void) {
    if (eax >= 1) {
        if (eax > 0x1ff) {
            goto label_0;
        }
        return;
    }
label_0:
    eax = "Char.chr";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bf80 */
#include <stdint.h>
 
int32_t camlUnix_fun_2614 (void) {
    eax = unix_getpwuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a290 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1581 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = ebx;
    *((esp + 8)) = ecx;
    *((esp + 4)) = edx;
    *(esp) = esi;
    eax = caml_make_vect;
    eax = caml_c_call (9);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0x10));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0x10));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 0xc));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 7) {
            goto label_6;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 0xc;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 7) {
            goto label_7;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x18)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b540)() ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c520 */
#include <stdint.h>
 
int32_t camlUnix_fun_2776 (void) {
    eax = unix_putenv;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8053510 */
#include <stdint.h>
 
int32_t camlArray_entry (void) {
    eax = loc.camlArray__21;
    *(loc.camlArray) = eax;
    eax = loc.camlArray__20;
    *(0x8077684) = eax;
    eax = .comment;
    *(0x8077688) = eax;
    eax = loc.camlArray__19;
    *(0x8077698) = eax;
    eax = loc.camlArray__18;
    *(0x807768c) = eax;
    eax = loc.camlArray__17;
    *(0x80776d0) = eax;
    eax = loc.camlArray__16;
    *(0x8077690) = eax;
    eax = loc.camlArray__15;
    *(0x8077694) = eax;
    eax = loc.camlArray__14;
    *(0x807769c) = eax;
    eax = loc.camlArray__13;
    *(0x80776a0) = eax;
    eax = loc.camlArray__12;
    *(0x80776ac) = eax;
    eax = loc.camlArray__11;
    *(0x80776b0) = eax;
    eax = loc.camlArray__10;
    *(0x80776b4) = eax;
    eax = loc.camlArray__9;
    *(0x80776b8) = eax;
    eax = loc.camlArray__8;
    *(0x80776a4) = eax;
    eax = loc.camlArray__7;
    *(0x80776d4) = eax;
    eax = loc.camlArray__6;
    *(0x80776a8) = eax;
    eax = loc.camlArray__5;
    *(0x80776bc) = eax;
    eax = loc.camlArray__4;
    *(0x80776c0) = eax;
    caml_alloc1 ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = "Array.Bottom";
    *(0x80776d8) = eax;
    eax = loc.camlArray__2;
    *(0x80776c4) = eax;
    *(0x80776dc) = 0xb;
    eax = camlArray__1;
    *(0x80776c8) = eax;
    eax = .comment;
    *(0x80776cc) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070458 */
#include <stdint.h>
 
int32_t loc_caml_alloc1 (int32_t arg_4h) {
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            return eax;
        }
        eax = *(esp);
        *(obj.caml_last_return_address) = eax;
        eax = esp + 4;
        *(obj.caml_bottom_of_stack) = eax;
        fcn_0807043d ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x807043d */
#include <stdint.h>
 
void fcn_0807043d (void) {
    *(obj.caml_gc_regs) = esp;
    caml_garbage_collection (eax, ebx, ecx, edx, esi, edi);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067840 */
#include <stdint.h>
 
int32_t caml_floor_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    floor (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a0d4 */
#include <stdint.h>
 
void floor (void) {
    floor ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f690 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1500 (void) {
    ebx = *((ebx + 8));
    eax = 1;
    ecx = *(ebx);
    void (*ecx)(uint32_t) (ebx);
    eax = *(esp);
    ebx = *((eax + 0xc));
    eax = 1;
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064eeb */
#include <stdint.h>
 
uint32_t caml_alloc_for_heap (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = ebp - 0xc;
    eax = ebx + 0x10;
    eax = caml_aligned_malloc (ebx, 0x10, eax);
    if (eax != 0) {
        eax += 0x10;
        edx = eax - 0x10;
        *((edx + 8)) = ebx;
        ecx = *((ebp - 0xc));
        *(edx) = ecx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063024 */
#include <stdint.h>
 
int32_t caml_aligned_malloc (size_t size, int32_t arg_ch, void ** arg_10h) {
    ebx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax += 0x1000;
    eax = malloc (eax);
    edx = eax;
    eax = 0;
    if (edx != 0) {
        eax = *((ebp + 0x10));
        *(eax) = edx;
        edx += ebx;
        edx &= 0xfffff000;
        eax = edx + 0x1000;
        eax -= ebx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068962 */
#include <stdint.h>
 
int32_t caml_channel_size (int32_t arg_8h) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    ebx = *(eax);
    edx = *((eax + 4));
    *((ebp - 0x1c)) = edx;
    eax = *((eax + 8));
    *((ebp - 0x20)) = eax;
    caml_enter_blocking_section ();
    *((esp + 0xc)) = 2;
    *((esp + 4)) = 0;
    *((esp + 8)) = 0;
    *(esp) = ebx;
    eax = lseek64 ();
    esi = eax;
    edi = edx;
    eax &= edx;
    if (eax != -1) {
        *((esp + 0xc)) = 0;
        eax = *((ebp - 0x1c));
        *((esp + 4)) = eax;
        edx = *((ebp - 0x20));
        *((esp + 8)) = edx;
        *(esp) = ebx;
        eax = lseek64 ();
        edx ^= *((ebp - 0x20));
        eax ^= *((ebp - 0x1c));
        edx |= eax;
        if (edx == 0) {
            goto label_0;
        }
    }
    caml_leave_blocking_section ();
    caml_sys_error (1);
label_0:
    caml_leave_blocking_section ();
    eax = esi;
    edx = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d1ca */
#include <stdint.h>
 
int32_t unix_ftruncate (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1602e;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((esp + 8)) = edx;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = ftruncate64 ();
    if (eax == -1) {
        eax = ebx - 0x255b;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a5b4 */
#include <stdint.h>
 
void ftruncate64 (void) {
    ftruncate64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050170 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1491 (void) {
    eax = caml_ml_seek_in_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bf60 */
#include <stdint.h>
 
int32_t camlUnix_fun_2610 (void) {
    eax = unix_inet_addr_of_string;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805cc74 */
#include <stdint.h>
 
int32_t unix_environment (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16584;
    eax = *((ebx - 0x14));
    eax = *(eax);
    caml_copy_string_array (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ba50 */
#include <stdint.h>
 
int32_t loc_camlUnix_code_begin (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x801;
            *(edx) = esi;
            eax = *((ecx + 0x14));
            *((edx + 4)) = eax;
            eax = edx + 0xc;
            *((eax - 4)) = 0x1400;
            *(eax) = 3;
            esi = *((ecx + 0x10));
            *((eax + 4)) = esi;
            ecx = *((ecx + 0xc));
            ecx = *(ecx);
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066740 */
#include <stdint.h>
 
int32_t caml_int64_to_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064fa2 */
#include <stdint.h>
 
int32_t caml_page_table_remove (int32_t arg_8h, char * arg_ch, int32_t arg_10h) {
    edi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx &= 0xfffff000;
    esi = *((ebp + 0x10));
    esi--;
    esi &= 0xfffff000;
    if (ebx > esi) {
        goto label_0;
    }
    do {
        ecx = 0;
        edx = edi;
        eax = ebx;
        eax = caml_page_table_modify ();
        if (eax != 0) {
            eax = 0xffffffff;
            goto label_1;
        }
        ebx += 0x1000;
    } while (esi >= ebx);
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c6e0 */
#include <stdint.h>
 
int32_t camlCallback_entry (void) {
    eax = loc.camlCallback__2;
    *(loc.camlCallback) = eax;
    eax = camlCallback__1;
    *(0x807c518) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062a4b */
#include <stdint.h>
 
int32_t caml_convert_signal_number (int32_t arg_8h) {
    eax = *((ebp + 8));
    if (eax < 0) {
        if (eax <= 0xffffffea) {
            goto label_0;
        }
        eax = ~eax;
        eax = *((eax*4 + obj.posix_signals));
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806f644 */
#include <stdint.h>
 
int32_t caml_final_release (void) {
    *(obj.running_finalisation_function) = 0;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e380 */
#include <stdint.h>
 
int32_t caml_named_value (int32_t arg_8h) {
    char * s2;
    esi = *((ebp + 8));
    eax = *((ebp + 8));
    hash_value_name (ebx, esi);
    ebx = *((eax*4 + obj.named_value_table));
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        eax = strcmp (esi, eax);
        if (eax == 0) {
            eax = ebx;
            goto label_1;
        }
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ec6b */
#include <stdint.h>
 
int32_t caml_weak_create (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax >>= 1;
    ebx = eax + 1;
    if (eax > 0x3ffffe) {
        caml_invalid_argument ("Weak.create");
    }
    caml_alloc_shr (ebx, 0xfb);
    if (ebx <= 1) {
        goto label_0;
    }
    edx = 1;
    do {
        ecx = caml_weak_none;
        *((eax + edx*4)) = ecx;
        edx++;
    } while (ebx > edx);
label_0:
    edx = caml_weak_list_head;
    *(eax) = edx;
    *(obj.caml_weak_list_head) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066d38 */
#include <stdint.h>
 
int32_t caml_int64_mod (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    ebx = *((edx + 4));
    ecx = *((edx + 8));
    edx = *((eax + 4));
    eax = *((eax + 8));
    esi = *((eax + 8));
    esi |= edx;
    if (esi == 0) {
        eax = caml_raise_zero_divide ();
    }
    esi = ecx - 0x80000000;
    esi |= ebx;
    if (esi == 0) {
        esi = edx;
        esi &= eax;
        if (esi == -1) {
            eax = caml_copy_int64 (0, 0);
        }
    } else {
        eax = _moddi3 (eax, ecx, edx);
        caml_copy_int64 (eax, edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060d71 */
#include <stdint.h>
 
uint32_t unix_tcgetattr (int32_t arg_8h) {
    int32_t var_3ch;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x12485;
    eax = ebx + 0x997c;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcgetattr ();
    if (eax == -1) {
        eax = ebx - 0x22c9;
        uerror (eax, 0);
    }
    eax = caml_alloc_tuple (0x26);
    *((ebp - 0x28)) = eax;
    eax = *((ebx + 0x94fc));
    if (eax == 4) {
        goto label_1;
    }
    edi = *((ebp - 0x28));
    edx = ebx + 0x94fc;
    ecx = 0xffffdd9c;
    *((ebp - 0x2c)) = ecx;
    ecx = ebx + 0x997c;
    *((ebp - 0x30)) = ecx;
label_0:
    esi = edx + 4;
    if (eax != 1) {
        if (eax <= 1) {
            if (eax == 0) {
                goto label_2;
            }
            goto label_3;
        }
        if (eax == 2) {
            goto label_4;
        }
        if (eax != 3) {
            goto label_3;
        }
        goto label_5;
label_2:
        edx = esi + 4;
        eax = *(esi);
        eax = *(eax);
        eax &= *(edx);
        eax -= eax;
        eax &= 0xfffffffe;
        eax += 3;
        esi = edx + 4;
        *(edi) = eax;
        goto label_3;
    }
    eax = *(esi);
    *((ebp - 0x20)) = eax;
    ecx = *((esi + 4));
    *((ebp - 0x24)) = ecx;
    ecx = *((esi + 8));
    eax = *((esi + 0xc));
    *((ebp - 0x3c)) = eax;
    esi += 0x10;
    *((ebp - 0x1c)) = esi;
    if (ecx <= 0) {
        goto label_6;
    }
    esi = eax;
    eax = *((ebp - 0x20));
    esi &= *(eax);
    *((ebp - 0x20)) = 0;
    eax = *((ebp - 0x1c));
    if (esi != *(eax)) {
        goto label_7;
    }
    while (ecx > eax) {
        if (*((edx + eax*4 + 0x14)) == esi) {
            *((ebp - 0x20)) = eax;
            eax = *((ebp - 0x20));
            eax += *((ebp - 0x24));
            eax = eax + eax + 1;
            *(edi) = eax;
            goto label_6;
label_7:
            eax = *((ebp - 0x20));
        }
        eax++;
    }
label_6:
    eax = *((ebp - 0x1c));
    esi = eax + ecx*4;
    goto label_3;
label_4:
    edx = *(esi);
    esi += 4;
    *(edi) = 0x4b01;
    if (edx != 0) {
        eax = 0;
        if (edx != 1) {
            goto label_8;
        }
        ecx = *((ebp - 0x30));
        *(esp) = ecx;
        cfgetospeed ();
    } else {
        eax = *((ebp - 0x30));
        *(esp) = eax;
        eax = cfgetispeed ();
    }
label_8:
    edx = 1;
    ecx = *((ebp - 0x2c));
    if (*((ebx + ecx)) != eax) {
        goto label_9;
    }
    dl = 0;
    while (edx != 0x12) {
label_9:
        if (*((ebx + edx*8 - 0x2264)) == eax) {
            eax = *((ebx + edx*8 - 0x2260));
            eax = eax + eax + 1;
            *(edi) = eax;
            goto label_3;
        }
        edx++;
    }
    goto label_3;
label_5:
    eax = *(esi);
    esi += 4;
    eax = *((ebx + eax + 0x998d));
    eax = eax + eax + 1;
    *(edi) = eax;
label_3:
    eax = *(esi);
    if (eax != 4) {
        edi += 4;
        edx = esi;
        goto label_0;
    }
label_1:
    eax = *((ebp - 0x28));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a686 */
#include <stdint.h>
 
uint32_t caml_output_val (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    eax = caml_channel_binary_mode (ebx, esi, edi);
    if (eax == 0) {
        caml_failwith ("output_value: not a binary channel");
    }
    init_extern_output ();
    edx = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    extern_value ();
    ebx = extern_output_first;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        edx = *((ebx + 4));
        edx -= eax;
        caml_really_putblock (edi, eax, edx);
        esi = *(ebx);
        free (ebx);
        if (esi == 0) {
            goto label_0;
        }
        ebx = esi;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fb30 */
#include <stdint.h>
 
int32_t camlPervasives_open_out_gen_1175 (void) {
    eax = caml_sys_open;
    eax = caml_c_call (ecx);
    eax = caml_ml_open_descriptor_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058f70 */
#include <stdint.h>
 
int32_t camlPrintf_skip_int_literal_1092 (void) {
    do {
        edx = eax;
        edx >>= 1;
        ecx = *((ebx + 8));
        ecx = *((ecx + edx));
        ecx = ecx + ecx + 1;
        if (ecx < 0x61) {
            goto label_0;
        }
        if (ecx >= 0x75) {
            goto label_1;
        }
        eax += 2;
    } while (1);
label_0:
    if (ecx == 0x49) {
        eax += 2;
        return eax;
    }
label_1:
    eax = *((ebx + 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070820 */
#include <stdint.h>
 
int32_t moddi3 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    uint32_t var_28h;
    uint32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_10h;
    int32_t var_ch;
    ecx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    edi = *((ebp + 0x14));
    edx = *((ebp + 8));
    *((ebp - 0x20)) = esi;
    *((ebp - 0x1c)) = edi;
    *((ebp - 0x2c)) = 0;
    if (ecx < 0) {
        goto label_5;
    }
label_3:
    esi = *((ebp - 0x1c));
    if (esi < 0) {
        goto label_6;
    }
label_2:
    eax = *((ebp - 0x1c));
    esi = ebp - 0x10;
    edi = *((ebp - 0x20));
    *((ebp - 0x30)) = edx;
    *((ebp - 0x28)) = edx;
    *((ebp - 0x24)) = edi;
    edi = ecx;
    if (eax != 0) {
        goto label_7;
    }
    if (*((ebp - 0x24)) <= ecx) {
        goto label_8;
    }
    eax = edx;
    edx = ecx;
    eax = *(edx:eax) / ebp - 0x24;
    edx = *(edx:eax) % ebp - 0x24;
label_1:
    eax = *((ebp - 0x2c));
    *(esi) = edx;
    *((esi + 4)) = 0;
    if (eax != 0) {
        goto label_9;
    }
    do {
        eax = *((ebp - 0x10));
        edx = *((ebp - 0xc));
        return eax;
label_7:
        if (eax <= ecx) {
            goto label_10;
        }
        *(esi) = edx;
        *((esi + 4)) = ecx;
label_0:
        eax = *((ebp - 0x2c));
    } while (eax == 0);
label_9:
    eax = *((ebp - 0x10));
    edx = *((ebp - 0xc));
    eax = -eax;
    edx += 0;
    edx = -edx;
    return eax;
label_10:
    __asm ("bsr edx, eax");
    edx ^= 0x1f;
    *((ebp - 0x20)) = edx;
    if (edx != 0) {
        goto label_11;
    }
    ecx = *((ebp - 0x28));
    if (*((ebp - 0x24)) <= ecx) {
        goto label_12;
    }
    while (1) {
        ecx = *((ebp - 0x28));
        *((esi + 4)) = edi;
        *(esi) = ecx;
        goto label_0;
label_8:
        edx = *((ebp - 0x24));
        if (edx == 0) {
            eax = 1;
            edx = 0;
            eax = *(edx:eax) / ebp - 0x24;
            edx = *(edx:eax) % ebp - 0x24;
            *((ebp - 0x24)) = eax;
        }
        eax = edi;
        edx = 0;
        eax = *(edx:eax) / ebp - 0x24;
        edx = *(edx:eax) % ebp - 0x24;
        eax = *((ebp - 0x28));
        eax = *(edx:eax) / ebp - 0x24;
        edx = *(edx:eax) % ebp - 0x24;
        goto label_1;
label_6:
        ebp - 0x20 = -ebp - 0x20;
        *((ebp - 0x1c)) += 0;
        ebp - 0x1c = -ebp - 0x1c;
        goto label_2;
label_5:
        edx = -edx;
        ecx += 0;
        ecx = -ecx;
        *((ebp - 0x2c)) = 0xffffffff;
        goto label_3;
label_11:
        ecx = *((ebp - 0x20));
        edx = eax;
        eax = 0x20;
        eax -= *((ebp - 0x20));
        edx <<= cl;
        *((ebp - 0x28)) = eax;
        eax = *((ebp - 0x24));
        ecx = *((ebp - 0x28));
        eax >>= cl;
        ecx = *((ebp - 0x20));
        eax |= edx;
        edx = edi;
        *((ebp - 0x38)) = eax;
        eax = *((ebp - 0x24));
        eax <<= cl;
        ecx = *((ebp - 0x28));
        *((ebp - 0x34)) = eax;
        eax = *((ebp - 0x30));
        edx >>= cl;
        ecx = *((ebp - 0x20));
        edi <<= cl;
        ecx = *((ebp - 0x28));
        eax >>= cl;
        ecx = *((ebp - 0x20));
        eax |= edi;
        edi = *((ebp - 0x30));
        eax = *(edx:eax) / ebp - 0x38;
        edx = *(edx:eax) % ebp - 0x38;
        edi <<= cl;
        *((ebp - 0x24)) = edi;
        edi = edx;
        edx:eax = eax * *((ebp - 0x34));
        if (edi < edx) {
            goto label_13;
        }
        if (*((ebp - 0x24)) < eax) {
            goto label_14;
        }
label_4:
        ecx = *((ebp - 0x24));
        ecx -= eax;
        edi -= edx;
        edx = ecx;
        ecx = *((ebp - 0x20));
        eax = edi;
        edx >>= cl;
        ecx = *((ebp - 0x28));
        eax <<= cl;
        ecx = *((ebp - 0x20));
        eax |= edx;
        *(esi) = eax;
        edi >>= cl;
        *((esi + 4)) = edi;
        goto label_0;
label_12:
        edx = *((ebp - 0x28));
        edx -= *((ebp - 0x24));
        edi -= eax;
        *((ebp - 0x28)) = edx;
    }
label_14:
    if (edi != edx) {
        goto label_4;
    }
label_13:
    eax -= *((ebp - 0x34));
    edx -= *((ebp - 0x38));
    goto label_4;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056230 */
#include <stdint.h>
 
uint32_t camlString_rcontains_from_1140 (void) {
    if (ebx >= 1) {
        edx = *((eax - 4));
        edx >>= 0xa;
        edx = edx*4 - 1;
        esi = *((eax + edx));
        edx -= esi;
        edx = edx + edx + 1;
        if (ebx >= edx) {
            goto label_0;
        }
        eax = void (*0x8056280)() ();
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 1;
            return eax;
        }
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        camlString_rindex_rec_1121 (*(obj.caml_exception_pointer));
        eax = 3;
        return eax;
    }
label_0:
    eax = "String.rcontains_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80560d0 */
#include <stdint.h>
 
int32_t camlString_rindex_rec_1121 (void) {
    do {
        if (ebx < 1) {
label_0:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_1;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        edx = ebx;
        edx >>= 1;
        edx = *((eax + edx));
        edx = edx + edx + 1;
        if (edx == ecx) {
            eax = ebx;
            return eax;
        }
        ebx += 0xfffffffe;
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804abc0 */
#include <stdint.h>
 
int32_t caml_curry9_5 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_6;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bab0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2828 (void) {
    if ((eax & 1) != 0) {
        eax >>= 1;
        if (eax < 2) {
            goto label_0;
        }
        eax = *((ebx + 0x10));
        *(eax) = 3;
        eax = 1;
        return eax;
    }
    ecx = *((eax - 4));
    if (ecx < 1) {
        goto label_0;
    }
    if (ecx > 1) {
        goto label_1;
    }
    ecx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = ecx;
            caml_modify (*((ebx + 8)), eax);
            eax = 1;
            return eax;
label_1:
            ecx = *(eax);
            eax = *((ebx + 0xc));
            *(eax) = ecx;
            eax = 1;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fce8 */
#include <stdint.h>
 
int32_t unix_socket (int32_t domain, int32_t arg_ch, int32_t arg_10h) {
    int32_t type;
    int32_t protocol;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13510;
    eax = *((ebp + 0x10));
    eax >>= 1;
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebx - 0x1c));
    eax = *((eax + edx*4));
    edx = *((ebp + 8));
    edx >>= 1;
    eax = *((ebx - 0x20));
    eax = *((eax + edx*4));
    eax = socket (eax, eax, eax);
    if (eax == -1) {
        eax = ebx - 0x23cc;
        uerror (eax, 0);
    }
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a2b4 */
#include <stdint.h>
 
void socket (void) {
    socket ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b2c0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1694 (void) {
    eax = *((ebx + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8051dd0 */
#include <stdint.h>
 
int32_t camlArray_copy_1049 (void) {
    int32_t var_4h;
    ebx = eax;
    ecx = *((ebx - 4));
    eax = *((ebx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        ecx >>= 9;
    } else {
        ecx >>= 0xa;
    }
    ecx |= 1;
    if (ecx == 1) {
        eax = loc.camlArray__32;
        return eax;
    }
    *(esp) = ecx;
    *((esp + 4)) = ebx;
    eax = *((ebx - 4));
    if (eax != 0xfe) {
        eax = *(ebx);
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(eax) = fp_stack[0];
        fp_stack--;
    }
    eax = caml_make_vect;
    eax = caml_c_call (ecx);
    esi = eax;
    ebx = 3;
    edi = *(esp);
    edi += 0xfffffffe;
    if (ebx > edi) {
        goto label_3;
    }
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            edx = *((ecx + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebx*2 - 2, edx);
        } else {
            *(fp_stack--) = *(edx);
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = ebx;
        ebx += 2;
    } while (eax != edi);
label_3:
    eax = esi;
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80684d1 */
#include <stdint.h>
 
int32_t caml_ml_pos_in_64 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_in (eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068474 */
#include <stdint.h>
 
int32_t caml_pos_in (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    eax = *((ebp + 8));
    edx = *((eax + 0x14));
    edx -= *((eax + 0x10));
    ecx = edx;
    ecx >>= 0x1f;
    ebx = *((eax + 4));
    esi = *((eax + 8));
    ebx -= edx;
    esi -= ecx;
    eax = ebx;
    edx = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805cb60 */
#include <stdint.h>
 
uint32_t unix_connect (int32_t socket, int32_t arg_ch) {
    int32_t var_7ch;
    int32_t var_78h;
    void * addr;
    size_t addrlen;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x16694;
    eax = ebp - 0x7c;
    esi = ebp - 0x78;
    eax = *((ebp + 0xc));
    get_sockaddr (eax, esi, eax);
    caml_enter_blocking_section ();
    eax = *((ebp - 0x7c));
    eax = *((ebp + 8));
    eax >>= 1;
    eax = connect (eax, esi, eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x25d5;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fd50 */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
int32_t get_sockaddr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x134a0;
    eax = *((ebp + 8));
    esi = *((ebp + 0xc));
    edi = eax;
    edx = *((eax - 4));
    if (dl != 0) {
        if (dl != 1) {
            goto label_0;
        }
    } else {
        eax = *(eax);
        *((ebp - 0x1c)) = eax;
        eax = caml_string_length (eax);
        edi = eax;
        *(esi) = 1;
        if (eax > 0x6b) {
            eax = *((ebp - 0x1c));
            eax = ebx - 0x147c;
            unix_error (0x24, eax, eax);
        }
        eax = eax + 1;
        edx = *((ebp - 0x1c));
        esi += 2;
        memmove (esi, edx, eax);
        edi += 2;
        eax = *((ebp + 0x10));
        *(eax) = edi;
        goto label_0;
    }
    *((ebp - 0x1c)) = eax;
    eax = *(eax);
    eax = caml_string_length (eax);
    if (eax != 0x10) {
        goto label_1;
    }
    edx = esi;
    ecx = 0;
    al = 0;
    do {
        *((edx + eax)) = ecx;
        eax += 4;
    } while (eax < 0x1c);
    *(esi) = 0xa;
    edx = *((ebp - 0x1c));
    eax = *(edx);
    edx = *(eax);
    *((esi + 8)) = edx;
    edx = *((eax + 4));
    *((esi + 0xc)) = edx;
    edx = *((eax + 8));
    *((esi + 0x10)) = edx;
    eax = *((eax + 0xc));
    *((esi + 0x14)) = eax;
    eax = *((edi + 4));
    eax >>= 1;
    ax = rotate_right16 (ax, 8);
    *((esi + 2)) = ax;
    eax = *((ebp + 0x10));
    *(eax) = 0x1c;
    goto label_0;
label_1:
    *(esi) = 0;
    *((esi + 4)) = 0;
    *((esi + 8)) = 0;
    *((esi + 0xc)) = 0;
    *(esi) = 2;
    edx = *((ebp - 0x1c));
    eax = *(edx);
    eax = *(eax);
    *((esi + 4)) = eax;
    eax = *((edi + 4));
    eax >>= 1;
    ax = rotate_right16 (ax, 8);
    *((esi + 2)) = ax;
    eax = *((ebp + 0x10));
    *(eax) = 0x10;
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049e44 */
#include <stdint.h>
 
void connect (void) {
    connect ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068abd */
#include <stdint.h>
 
uint32_t caml_ml_input (int32_t arg_8h, void * s1, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    void * s2;
    size_t n;
    edi = caml_local_roots;
    *((ebp - 0x38)) = edi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp + 0x14;
    *((ebp - 0x20)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebp - 0x40)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    *((ebp - 0x3c)) = esi;
    eax = *((ebx + 0x10));
    esi = *((ebx + 0x14));
    esi -= eax;
    if (*((ebp - 0x3c)) <= esi) {
        edx = *((ebp - 0x3c));
        eax = *((ebp - 0x40));
        eax += *((ebp + 0xc));
        memmove (eax, eax, edx);
        eax = *((ebp - 0x3c));
        *((ebx + 0x10)) += eax;
        esi = eax;
    } else {
        if (esi > 0) {
            eax = *((ebp - 0x40));
            eax += *((ebp + 0xc));
            memmove (eax, eax, esi);
            *((ebx + 0x10)) += esi;
        } else {
            edx = ebx + 0x34;
            *((ebp - 0x44)) = edx;
            eax = *((ebx + 0xc));
            eax -= edx;
            eax = *(ebx);
            eax = caml_do_read (eax, edx, eax);
            esi = eax;
            edx = eax;
            edx >>= 0x1f;
            *((ebx + 4)) += eax;
            *((ebx + 8)) += edx;
            eax = ebx + esi + 0x34;
            *((ebx + 0x14)) = eax;
            if (esi > *((ebp - 0x3c))) {
                esi = *((ebp - 0x3c));
            }
            eax = *((ebp - 0x44));
            eax = *((ebp - 0x40));
            eax += *((ebp + 0xc));
            memmove (eax, eax, esi);
            eax = ebx + esi + 0x34;
            *((ebx + 0x10)) = eax;
        }
    }
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = edi;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80548f0 */
#include <stdint.h>
 
uint32_t camlList_fold_right2_1128 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        esi = *((ecx + 4));
        ecx = *(ecx);
        edi = *((ebx + 4));
        ecx = *(ebx);
        ebx = edi;
        ecx = esi;
        eax = camlList_fold_right2_1128 (ecx, ecx, eax);
    } while (1);
    ecx = eax;
    eax = *(esp);
    ebx = *((esp + 4));
    edx = *((esp + 8));
    void (*0x804b4f0)() ();
label_0:
    if (ecx == 1) {
        eax = edx;
        return eax;
    }
label_1:
    eax = "List.fold_right2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054950 */
#include <stdint.h>
 
int32_t camlList_for_all_1137 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t) (edx, eax);
        if (eax == 1) {
            goto label_1;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_1:
    eax = 1;
    return eax;
label_0:
    eax = 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068224 */
#include <stdint.h>
 
int32_t caml_array_set_float (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xb;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    ecx = *((ebp + 0x10));
    *(fp_stack--) = *(ecx);
    *((edx + eax*8)) = fp_stack[0];
    fp_stack--;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805bb40 */
#include <stdint.h>
 
int32_t camlPrintf_kapr_1209 (void) {
    int32_t var_4h;
    eax = ebx;
    eax = camlPrintf_ac_of_format_1184 (eax, eax);
    ebx = *(eax);
    while (1) {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x18f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8059d40;
            eax = *(esp);
            *((ecx + 0xc)) = eax;
            eax = *((esp + 4));
            *((ecx + 0x10)) = eax;
            *((ecx + 0x14)) = ebx;
            ebx = 1;
            eax = 1;
            void (*0x8059d40)() ();
            ebx >>= 1;
            /* switch table (12 cases) at 0x807b254 */
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d5f0 */
#include <stdint.h>
 
int32_t camlUnix_create_process_1907 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = ebx;
    *(esp) = ecx;
    *((esp + 4)) = edx;
    *((esp + 8)) = esi;
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        return eax;
    }
    fcn_0804d640 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d640 */
#include <stdint.h>
 
int32_t fcn_0804d640 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_1ch) {
    *(obj.caml_exception_pointer) = esp;
    eax = *((esp + 8));
    ebx = *((esp + 0xc));
    ecx = *((esp + 0x10));
    camlUnix_perform_redirections_1900 (*(obj.caml_exception_pointer));
    eax = *((esp + 0x14));
    eax = *((esp + 0x1c));
    eax = unix_execvp;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d520 */
#include <stdint.h>
 
uint32_t camlUnix_perform_redirections_1900 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    eax = camlUnix_safe_dup_1894 (eax, ebx, ecx);
    eax = *((esp + 4));
    eax = camlUnix_safe_dup_1894 (eax);
    eax = *((esp + 8));
    eax = camlUnix_safe_dup_1894 (eax);
    eax = *(esp);
    camlUnix_safe_close_1898 (eax);
    eax = *((esp + 4));
    camlUnix_safe_close_1898 ();
    eax = *((esp + 8));
    camlUnix_safe_close_1898 ();
    eax = *((esp + 0x10));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x14));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 0x10));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x18));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 0x14));
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804beb0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2592 (void) {
    eax = unix_getsockname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a430 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1578 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = ebx;
    *((esp + 4)) = ecx;
    *(esp) = edx;
    eax = caml_make_vect;
    eax = caml_c_call (7);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0xc));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b540)() ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067566 */
#include <stdint.h>
 
int32_t caml_cosh_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    cosh (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a7d4 */
#include <stdint.h>
 
void cosh (void) {
    cosh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054ad0 */
#include <stdint.h>
 
int32_t camlList_mem_1161 (void) {
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 4)) = ecx;
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067abb */
#include <stdint.h>
 
int32_t caml_ml_string_length (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    edx = *((eax + edx));
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b2e0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1707 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c164 */
#include <stdint.h>
 
int32_t caml_set_parser_trace (int32_t arg_8h) {
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    edx = *((ebp + 8));
    edx >>= 1;
    *(obj.caml_parser_trace) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060aef */
#include <stdint.h>
 
int32_t unix_tcsendbreak (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12709;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcsendbreak ();
    if (eax == -1) {
        eax = ebx - 0x22df;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a814 */
#include <stdint.h>
 
void tcsendbreak (void) {
    tcsendbreak ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80632e4 */
#include <stdint.h>
 
uint32_t caml_fl_merge_block (int32_t arg_8h) {
    int32_t var_20h;
    uint32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    edi = *((ebp + 8));
    eax = edi - 4;
    *((ebp - 0x10)) = eax;
    esi = *(eax);
    eax = *(eax);
    eax >>= 0xa;
    edx = caml_fl_cur_size;
    eax = edx + eax + 1;
    *(obj.caml_fl_cur_size) = eax;
    ebx = caml_fl_merge;
    *((ebp - 0x18)) = ebx;
    ecx = *(ebx);
    *((ebp - 0x14)) = ecx;
    if (*(obj.caml_allocation_policy) == 1) {
        eax = ebx;
        truncate_flp ();
    }
    edx = edi - 4;
    if (edx == *(obj.last_fragment)) {
        ecx = *((ebp - 0x10));
        eax = *(ecx);
        eax >>= 0xa;
        eax++;
        if (eax <= 0x3fffff) {
            esi = eax;
            esi <<= 0xa;
            *((edx - 4)) = esi;
            *(obj.caml_fl_cur_size)++;
        }
    } else {
        edx = edi;
    }
    edi = esi;
    edi >>= 0xa;
    ecx = edx + edi*4;
    eax = *((ebp - 0x14));
    eax -= 4;
    if (eax != ecx) {
        eax = ecx;
    } else {
        ecx = *((ebp - 0x14));
        ecx = *(ecx);
        *((ebp - 0x10)) = ecx;
        ecx = *((ebp - 0x14));
        ecx = *((ecx - 4));
        *((ebp - 0x20)) = ecx;
        ecx >>= 0xa;
        ecx = edi + ecx + 1;
        if (ecx > 0x3fffff) {
            goto label_0;
        }
        edi = *((ebp - 0x10));
        esi = *((ebp - 0x18));
        *(esi) = edi;
        if (*(obj.caml_allocation_policy) == 0) {
            eax = *((ebp - 0x14));
            eax = fl_prev;
            if (*(obj.fl_prev) == eax) {
                eax = ebx;
            }
            *(obj.fl_prev) = eax;
        }
        esi = ecx;
        esi <<= 0xa;
        esi += 0x200;
        *((edx - 4)) = esi;
        eax = esi;
        eax >>= 0xa;
        eax = edx + eax*4;
        ecx = *((ebp - 0x10));
        *((ebp - 0x14)) = ecx;
    }
label_0:
    ecx = ebx - 4;
    edi = *(ecx);
    edi >>= 0xa;
    *((ebp - 0x10)) = edi;
    ebx = ebx + edi*4;
    *((ebp - 0x1c)) = ebx;
    ebx = edx - 4;
    if (*((ebp - 0x1c)) == ebx) {
        ebx = esi;
        ebx >>= 0xa;
        ebx = edi + ebx + 1;
        if (ebx <= 0x3ffffe) {
            ebx <<= 0xa;
            ebx += 0x200;
            *(ecx) = ebx;
        }
    } else {
        ecx = esi;
        ecx >>= 0xa;
        if (ecx != 0) {
            esi &= 0xfffffcff;
            esi |= 0x200;
            *((edx - 4)) = esi;
            esi = *((ebp - 0x14));
            *(edx) = esi;
            edi = *((ebp - 0x18));
            *(edi) = edx;
            *(obj.caml_fl_merge) = edx;
        } else {
            *(obj.last_fragment) = edx;
            *(obj.caml_fl_cur_size)--;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070bbc */
#include <stdint.h>
 
void fini (void) {
    /* [14] -r-x section size 28 named .fini */
    void (*0x8070bc8)(uint32_t) (ebx);
    ebx += 0x263c;
    _do_global_dtors_aux ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c220 */
#include <stdint.h>
 
int32_t camlUnix_fun_2692 (void) {
    eax = unix_getcwd;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055f60 */
#include <stdint.h>
 
int32_t camlString_lowercase_1098 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_map_1090 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80584e0 */
#include <stdint.h>
 
int32_t camlBuffer_subst_1127 (void) {
    int32_t var_4h_2;
    int32_t var_8h;
    do {
label_0:
        edi = eax;
        eax = *((ecx + 0x18));
        if (ebx >= eax) {
            goto label_1;
        }
        edx = *((ecx + 0x14));
        eax = ebx;
        eax >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        ebp = esi*4 - 1;
        esi = *((edx + ebp));
        ebp -= esi;
        if (ebp <= eax) {
            goto label_2;
        }
        eax = *((edx + eax));
        edx = eax + eax + 1;
        if (edx == 0x49) {
            goto label_3;
        }
        if (edi != 0xb9) {
            goto label_4;
        }
        ebx = 0xb9;
        eax = *((ecx + 0xc));
        camlBuffer_add_char_1072 (edx, ebx, ecx);
        eax = *((esp + 8));
        eax = *((eax + 0xc));
        ebx = *(esp);
        camlBuffer_add_char_1072 ();
        ebx = *((esp + 4));
        ebx += 2;
        eax = 0x41;
        ecx = *((esp + 8));
    } while (1);
label_4:
    if (edx != 0xb9) {
        ebx = edx;
        eax = *((ecx + 0xc));
        camlBuffer_add_char_1072 (ebx, ebx, ecx);
        eax = *((esp + 4));
        ebx = *((esp + 4));
        ebx += 2;
        eax = *(esp);
        ecx = *((esp + 8));
        goto label_0;
    }
    eax = edx;
    ebx += 2;
    goto label_0;
label_3:
    *((esp + 8)) = ecx;
    if (edi == 0xb9) {
        eax = *((ecx + 0xc));
        ebx = edx;
        camlBuffer_add_char_1072 (ebx);
        ebx = *((esp + 4));
        ebx += 2;
        eax = 0x41;
        ecx = *((esp + 8));
        goto label_0;
    }
    ebx += 2;
    edx = *((ecx + 0x18));
    eax = *((ecx + 0x14));
    ecx = edx;
    eax = camlBuffer_find_ident_1114 ();
    ebx = eax;
    eax = *((ebx + 4));
    edx = *(ebx);
    eax = *((esp + 8));
    ebx = *((eax + 0x10));
    ecx = *(ebx);
    eax = edx;
    eax = void (*ecx)(uint32_t) (eax);
    ebx = eax;
    eax = *((esp + 8));
    eax = *((eax + 0xc));
    camlBuffer_add_string_1082 ();
    eax = 0x41;
    ebx = *(esp);
    ecx = *((esp + 8));
    goto label_0;
label_1:
    if (edi == 0xb9) {
        eax = *((ecx + 0xc));
        ebx = edi;
        void (*0x8058960)() ();
    }
    eax = 1;
    return eax;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bed0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2596 (void) {
    eax = unix_listen;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c900 */
#include <stdint.h>
 
int32_t camlUnix_recv_1558 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ebx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ebx + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = unix_recv;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.recv";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805dd48 */
#include <stdint.h>
 
uint32_t unix_getpeername (int32_t arg_8h) {
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x154ad;
    *((ebp - 0x7c)) = 0x70;
    eax = ebp - 0x7c;
    *((esp + 8)) = eax;
    eax = ebp - 0x78;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getpeername ();
    if (eax == -1) {
        eax = ebx - 0x2537;
        uerror (eax, 0);
    }
    eax = *((ebp - 0x7c));
    eax = ebp - 0x78;
    alloc_sockaddr (eax, eax, 0xffffffff);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a804 */
#include <stdint.h>
 
void getpeername (void) {
    getpeername ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fefe */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
uint32_t alloc_sockaddr (void * arg_8h, void * arg_10h) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x132f2;
    esi = *((ebp + 8));
    edx = *((ebp + 0x10));
    eax = *(esi);
    if (ax != 2) {
        if (ax != 0xa) {
            if (ax == 1) {
                esi += 2;
                eax = caml_copy_string (esi);
                *((ebp - 0x1c)) = eax;
                esi = *((ebx - 0x18));
                eax = *(esi);
                *((ebp - 0x3c)) = eax;
                eax = ebp - 0x3c;
                *(esi) = eax;
                *((ebp - 0x34)) = 1;
                *((ebp - 0x38)) = 1;
                eax = ebp - 0x1c;
                *((ebp - 0x30)) = eax;
                caml_alloc_small (1, 0);
                edx = *((ebp - 0x1c));
                *(eax) = edx;
                edx = *((ebp - 0x3c));
                *(esi) = edx;
            } else {
                eax = esi + 4;
                eax = alloc_inet_addr (eax);
                *((ebp - 0x1c)) = eax;
                edi = *((ebx - 0x18));
                eax = *(edi);
                *((ebp - 0x3c)) = eax;
                eax = ebp - 0x3c;
                *(edi) = eax;
                *((ebp - 0x34)) = 1;
                *((ebp - 0x38)) = 1;
                eax = ebp - 0x1c;
                *((ebp - 0x30)) = eax;
                caml_alloc_small (2, 1);
                edx = *((ebp - 0x1c));
                *(eax) = edx;
                edx = *((esi + 2));
                dx = rotate_right16 (dx, 8);
                edx = (int32_t) dx;
                edx = edx + edx + 1;
                *((eax + 4)) = edx;
                edx = *((ebp - 0x3c));
                *(edi) = edx;
            } else {
                eax = esi + 8;
            }
            eax = alloc_inet6_addr (eax);
            *((ebp - 0x1c)) = eax;
            edi = *((ebx - 0x18));
            eax = *(edi);
            *((ebp - 0x3c)) = eax;
            eax = ebp - 0x3c;
            *(edi) = eax;
            *((ebp - 0x34)) = 1;
            *((ebp - 0x38)) = 1;
            eax = ebp - 0x1c;
            *((ebp - 0x30)) = eax;
            caml_alloc_small (2, 1);
            edx = *((ebp - 0x1c));
            *(eax) = edx;
            edx = *((esi + 2));
            dx = rotate_right16 (dx, 8);
            edx = (int32_t) dx;
            edx = edx + edx + 1;
            *((eax + 4)) = edx;
            edx = *((ebp - 0x3c));
            *(edi) = edx;
        } else {
        }
        if (edx != -1) {
            close (edx);
        }
        eax = ebx - 0x147c;
        unix_error (0x61, eax, 0);
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e747 */
#include <stdint.h>
 
int32_t caml_weak_blit (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    int32_t var_4ch;
    int32_t var_30h;
    int32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    uint32_t var_1ch;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((ebp - 0x28)) = eax;
    esi = eax;
    esi++;
    if (esi != 0) {
        eax = *((ebp + 0x18));
        eax >>= 1;
        *((ebp - 0x1c)) = eax;
        edi = *((ebp + 8));
        edx = eax;
        edx += esi;
        eax = *((edi - 4));
        eax >>= 0xa;
        if (edx <= eax) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.blit");
label_0:
    eax = *((ebp + 0x14));
    eax >>= 1;
    *((ebp - 0x24)) = eax;
    eax++;
    *((ebp - 0x20)) = eax;
    if (eax != 0) {
        eax = *((ebp - 0x1c));
        eax += *((ebp - 0x20));
        ecx = *((ebp + 0x10));
        edx = *((ecx - 4));
        edx >>= 0xa;
        if (eax <= edx) {
            goto label_1;
        }
    }
    caml_invalid_argument ("Weak.blit");
label_1:
    if (*(obj.caml_gc_phase) != 0) {
        goto label_2;
    }
    if (*(obj.caml_gc_subphase) != 0xb) {
        goto label_2;
    }
    if (*((ebp - 0x1c)) == 0) {
        goto label_2;
    }
    edx = 0;
    eax = 0;
    *((ebp - 0x4c)) = esi;
    do {
        edx += *((ebp - 0x4c));
        edx = edi + edx*4;
        ebx = *(edx);
        ecx = caml_weak_none;
        if (ebx != ecx) {
            if ((bl & 1) != 0) {
                goto label_3;
            }
            *((ebp - 0x30)) = ebx;
            esi = ebx;
            esi >>= 0x17;
            ebx >>= 0xc;
            ebx &= 0x7ff;
            esi = *((esi*4 + obj.caml_page_table));
            if ((*((esi + ebx)) & 1) == 0) {
                goto label_3;
            }
            ebx = *((ebp - 0x30));
            if ((*((ebx - 4)) & 0x300) != 0) {
                goto label_3;
            }
            *(edx) = ecx;
        }
label_3:
        eax++;
        edx = eax;
    } while (*((ebp - 0x1c)) > eax);
    esi = *((ebp - 0x4c));
label_2:
    if (esi <= *((ebp - 0x20))) {
        goto label_4;
    }
    if (*((ebp - 0x1c)) == 0) {
        goto label_5;
    }
    edx = 0;
    ebx = 0;
    do {
        eax = edx + esi;
        ecx = *((edi + eax*4));
        edx += *((ebp - 0x20));
        eax = *((ebp + 0x10));
        do_set ();
        ebx++;
        edx = ebx;
    } while (*((ebp - 0x1c)) > ebx);
    goto label_5;
label_4:
    esi = *((ebp - 0x1c));
    esi--;
    *((ebp - 0x20)) = esi;
    if (esi < 0) {
        goto label_5;
    }
    eax = *((ebp - 0x1c));
    eax += *((ebp - 0x28));
    ebx = edi + eax*4;
    esi = *((ebp - 0x1c));
    esi += *((ebp - 0x24));
    edi = *((ebp - 0x20));
    do {
        ecx = *(ebx);
        edx = esi;
        eax = *((ebp + 0x10));
        do_set ();
        ebx -= 4;
        esi--;
        edi--;
    } while (edi >= 0);
label_5:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066c35 */
#include <stdint.h>
 
int32_t caml_int64_shift_right_unsigned (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    __asm ("shrd eax, edx, cl");
    edx >>= cl;
    if ((cl & 0x20) != 0) {
        eax = edx;
        edx = 0;
    }
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050150 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1495 (void) {
    eax = caml_ml_channel_size_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067f32 */
#include <stdint.h>
 
int32_t caml_array_unsafe_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    if (*((eax - 4)) == 0xfe) {
        caml_array_unsafe_get_float (eax, edx);
    } else {
        edx >>= 1;
        eax = *((eax + edx*4));
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d690 */
#include <stdint.h>
 
int32_t camlUnix_create_process_env_1914 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = ebx;
    *((esp + 0xc)) = ecx;
    *(esp) = edx;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        return eax;
    }
    fcn_0804d6f0 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d6f0 */
#include <stdint.h>
 
int32_t fcn_0804d6f0 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_1ch, int32_t arg_24h) {
    *(obj.caml_exception_pointer) = esp;
    eax = *((esp + 8));
    ebx = *((esp + 0xc));
    ecx = *((esp + 0x10));
    camlUnix_perform_redirections_1900 (*(obj.caml_exception_pointer));
    eax = *((esp + 0x14));
    eax = *((esp + 0x1c));
    eax = *((esp + 0x24));
    eax = unix_execvpe;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c0a0 */
#include <stdint.h>
 
int32_t camlPrintf_mkprintf_1345 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    eax = caml_extra_params;
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (eax, ecx, edx);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x20f7;
            *(ebx) = sym.caml_curry4;
            *((ebx + 4)) = 9;
            *((ebx + 8)) = 0x805b140;
            eax = *(esp);
            *((ebx + 0xc)) = eax;
            eax = *((esp + 4));
            *((ebx + 0x10)) = eax;
            eax = *((esp + 8));
            *((ebx + 0x14)) = eax;
            eax = *((esp + 0xc));
            *((ebx + 0x18)) = eax;
            *((ebx + 0x1c)) = ecx;
            eax = 1;
            eax = camlPrintf_index_of_int_1037 (ebx);
            ebx = eax;
            eax = *((esp + 0x10));
            ecx = *((esp + 0x14));
            caml_apply2 ();
            ebx = *((esp + 0x18));
            void (*0x805bb40)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d07a */
#include <stdint.h>
 
uint32_t unix_set_nonblock (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16179;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 3;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        ah |= 8;
        *((esp + 8)) = eax;
        *((esp + 4)) = 4;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x256d;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80518d0 */
#include <stdint.h>
 
int32_t camlArray_isortto_1209 (void) {
    int32_t var_4h_3;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h_2;
    int32_t var_14h_2;
    int32_t var_18h;
    int32_t var_1ch;
    edi = 1;
    edx += 0xfffffffe;
    if (edi > edx) {
        goto label_5;
    }
    *((esp + 0x10)) = edx;
    *((esp + 0xc)) = edi;
    *((esp + 0x18)) = esi;
    *((esp + 0x14)) = ecx;
    *((esp + 0x1c)) = ebx;
    *(esp) = eax;
label_0:
    eax = *(esp);
    eax = eax + edi - 1;
    *((esp + 4)) = eax;
    ecx = *((esp + 0x18));
    ecx = *((ecx + 0x10));
    edx = *((ecx - 4));
    *((esp + 8)) = edx;
    edx = *((esp + 8));
    edx &= 0xff;
    if (edx != 0xfe) {
        edx = *((esp + 8));
        edx >>= 9;
        if (edx <= eax) {
            goto label_6;
        }
        edx = *((ecx + eax*2 - 2));
        *((esp + 4)) = edx;
    } else {
        edx = *((esp + 8));
        edx >>= 0xa;
        if (edx <= eax) {
            goto label_7;
        }
label_4:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_8;
        }
        edx = eax + 4;
        *((edx - 4)) = 0x8fd;
        eax = *((esp + 4));
        *(fp_stack--) = *((ecx + eax*4 - 4));
        *(edx) = fp_stack[0];
        fp_stack--;
        *((esp + 4)) = edx;
    }
label_3:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_9;
    }
    esi = eax + 4;
    *((esp + 8)) = esi;
    *((esi - 4)) = 0x400;
    eax = *((esp + 0x14));
    eax = eax + edi - 3;
    *(esi) = eax;
    do {
        ecx = *(esi);
        eax = *((esp + 0x14));
        if (ecx < eax) {
            goto label_10;
        }
        ecx = *(esi);
        eax = *((ebx - 4));
        edx = *((ebx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_11;
            }
            eax = *((ebx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_12;
            }
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_13;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 0x18));
        ecx = *((ebx + 0xc));
        ebx = *((esp + 4));
        eax = caml_apply2 ();
        if (eax <= 1) {
            goto label_10;
        }
        esi = *((esp + 8));
        ecx = *(esi);
        ebx = *((esp + 0x1c));
        eax = *((ebx - 4));
        edx = *((ebx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_14;
            }
            edx = *((ebx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_15;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_16;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *(esi);
        eax += 2;
        ecx = *((ebx - 4));
        edi = *((ebx - 4));
        edi &= 0xff;
        if (edi != 0xfe) {
            ecx >>= 9;
            if (ecx <= eax) {
                goto label_17;
            }
            eax = caml_modify (ebx + eax*2 - 2, edx);
        } else {
            ecx >>= 0xa;
            if (ecx <= eax) {
                goto label_18;
            }
            *(fp_stack--) = *(edx);
            *((ebx + eax*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        *(esi) += 0xfffffffe;
    } while (1);
label_10:
    eax = *((esp + 8));
    eax = *(eax);
    eax += 2;
    ebx = *((esp + 0x1c));
    ecx = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_19;
        }
        ecx = *((esp + 4));
        eax = caml_modify (ebx + eax*2 - 2, ecx);
    } else {
        ecx >>= 0xa;
        if (ecx <= eax) {
            goto label_20;
        }
        ecx = *((esp + 4));
        *(fp_stack--) = *(ecx);
        *((ebx + eax*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    edi = *((esp + 0xc));
    ecx = *((esp + 0xc));
    edi += 2;
    *((esp + 0xc)) = edi;
    eax = *((esp + 0x10));
    if (ecx != eax) {
        goto label_0;
    }
label_5:
    eax = 1;
    return eax;
label_16:
    caml_call_gc ();
    goto label_1;
label_13:
    caml_call_gc ();
    goto label_2;
label_9:
    caml_call_gc ();
    goto label_3;
label_8:
    caml_call_gc ();
    goto label_4;
label_20:
    caml_ml_array_bound_error ();
label_19:
    caml_ml_array_bound_error ();
label_18:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060918 */
#include <stdint.h>
 
uint32_t unix_string_of_inet_addr (int32_t arg_8h) {
    int32_t var_48h;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x128df;
    esi = *((ebp + 8));
    eax = caml_string_length (esi);
    if (eax == 0x10) {
        *((esp + 0xc)) = 0x40;
        eax = ebp - 0x48;
        *((esp + 8)) = eax;
        *((esp + 4)) = esi;
        *(esp) = 0xa;
        inet_ntop ();
    } else {
        *((esp + 0xc)) = 0x40;
        eax = ebp - 0x48;
        *((esp + 8)) = eax;
        *((esp + 4)) = esi;
        *(esp) = 2;
        eax = inet_ntop ();
    }
    if (eax == 0) {
        eax = ebx - 0x2312;
        eax = uerror (eax, 0);
    }
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068f45 */
#include <stdint.h>
 
uint32_t caml_ml_input_int (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = caml_getword (ebx);
    edi = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067060 */
#include <stdint.h>
 
int32_t caml_int32_mod (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    ecx = *((eax + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            caml_copy_int32 (0);
        }
    } else {
        eax = edx;
        edx >>= 0x1f;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        caml_copy_int32 (edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c060 */
#include <stdint.h>
 
int32_t camlUnix_fun_2642 (void) {
    eax = unix_getitimer;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b1d0 */
#include <stdint.h>
 
int32_t caml_curry5_4 (void) {
    esi = eax;
    ecx = *((ebx + 0xc));
    eax = *((ecx + 0xc));
    ebp = *((eax + 0xc));
    edi = *((ebp + 0xc));
    edx = *((ebx + 8));
    ecx = *((ecx + 8));
    ebx = *((eax + 8));
    eax = *((ebp + 8));
    ebp = *((edi + 8));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806cb7a */
#include <stdint.h>
 
int32_t caml_gc_minor (void) {
    caml_minor_collection ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806719c */
#include <stdint.h>
 
int32_t caml_neq_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] != fp_stack[1]) ? 1 : 0;
    __asm ("setp dl");
    eax |= edx;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c4f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2772 (void) {
    eax = unix_execve;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c950 */
#include <stdint.h>
 
int32_t camlUnix_recvfrom_1564 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ebx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ebx + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = unix_recvfrom;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.recvfrom";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80669a4 */
#include <stdint.h>
 
int32_t caml_nativeint_neg (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = -eax;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8053620 */
#include <stdint.h>
 
int32_t camlList_nth_aux_1045 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 4));
        eax = *(eax);
        if (ebx == 1) {
            return eax;
        }
        ebx += 0xfffffffe;
        eax = ecx;
    } while (1);
label_0:
    eax = loc.camlList__53;
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f7d0 */
#include <stdint.h>
 
int32_t camlPervasives_failwith_1010 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = "45\a\b";
            *((eax + 4)) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805db78 */
#include <stdint.h>
 
void unix_gethostname (void) {
    int32_t var_48h;
    int32_t var_9h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1567b;
    *((esp + 4)) = 0x40;
    esi = ebp - 0x48;
    *(esp) = esi;
    gethostname ();
    *((ebp - 9)) = 0;
    caml_copy_string (esi);
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a5f4 */
#include <stdint.h>
 
void gethostname (void) {
    gethostname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80629e0 */
#include <stdint.h>
 
int32_t caml_record_signal (int32_t arg_8h) {
    eax = *((ebp + 8));
    *((eax*4 + obj.caml_pending_signals)) = 1;
    *(obj.caml_signals_are_pending) = 1;
    eax = caml_young_end;
    *(obj.caml_young_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80575a0 */
#include <stdint.h>
 
int32_t camlHashtbl_create_1051 (void) {
    ebx = eax;
    eax = 3;
    camlPervasives_max_1025 ();
    ebx = .comment;
    eax = camlPervasives_min_1022 ();
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = 1;
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f890 */
#include <stdint.h>
 
int32_t camlPervasives_max_1025 (void) {
    int32_t var_4h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_greaterequal;
    eax = caml_c_call (eax);
    if (eax != 1) {
        eax = *((esp + 4));
        return eax;
    }
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f850 */
#include <stdint.h>
 
int32_t camlPervasives_min_1022 (void) {
    int32_t var_4h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_lessequal;
    eax = caml_c_call (eax);
    if (eax != 1) {
        eax = *((esp + 4));
        return eax;
    }
    eax = *(esp);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066756 */
#include <stdint.h>
 
int32_t caml_int32_float_of_bits (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c860 */
#include <stdint.h>
 
int32_t camlUnix_pause_1408 (void) {
    eax = unix_sigprocmask;
    eax = caml_c_call (3);
    eax = unix_sigsuspend;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067da7 */
#include <stdint.h>
 
int32_t caml_create_string (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    if (eax > 0xfffffb) {
        eax = caml_invalid_argument ("String.create");
    }
    caml_alloc_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061dc1 */
#include <stdint.h>
 
int32_t caml_invalid_argument (void) {
    int32_t var_4h_5;
    int32_t var_4h_4;
    eax = *((ebp + 8));
    return caml_raise_with_string ("P5\a\b", eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c142 */
#include <stdint.h>
 
uint32_t caml_sys_io_error (int32_t arg_8h) {
    eax = errno_location ();
    if (*(eax) == 0xb) {
        caml_raise_sys_blocked_io ();
    }
    eax = *((ebp + 8));
    return caml_sys_error (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061e65 */
#include <stdint.h>
 
void caml_raise_sys_blocked_io (void) {
    return caml_raise_constant ("(6\a\b");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c200 */
#include <stdint.h>
 
int32_t camlPrintf_eprintf_1395 (void) {
    eax = .comment;
    eax = camlPrintf_fprintf_1391 (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80674f2 */
#include <stdint.h>
 
int32_t caml_acos_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    acos (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a364 */
#include <stdint.h>
 
void acos (void) {
    acos ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c6a0 */
#include <stdint.h>
 
int32_t camlUnix_read_1237 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = unix_read;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.read";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e090 */
#include <stdint.h>
 
uint32_t unix_gettimeofday (void) {
    int32_t var_10h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15168;
    *((esp + 4)) = 0;
    eax = ebp - 0x10;
    *(esp) = eax;
    eax = gettimeofday ();
    if (eax == -1) {
        eax = ebx - 0x252b;
        uerror (eax, 0);
    }
    *(fp_stack--) = *((ebp - 0x10));
    *(fp_stack--) = *((ebp - 0xc));
    fp_stack[0] /= *((ebx - 0x251c));
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a164 */
#include <stdint.h>
 
void gettimeofday (void) {
    gettimeofday ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058e90 */
#include <stdint.h>
 
int32_t camlBuffer_entry (void) {
    eax = loc.camlBuffer__20;
    *(loc.camlBuffer) = eax;
    eax = loc.camlBuffer__19;
    *(0x807a1a4) = eax;
    eax = loc.camlBuffer__18;
    *(0x807a1a8) = eax;
    eax = loc.camlBuffer__17;
    *(0x807a1ac) = eax;
    eax = loc.camlBuffer__16;
    *(0x807a1b0) = eax;
    eax = loc.camlBuffer__15;
    *(0x807a1b4) = eax;
    eax = loc.camlBuffer__14;
    *(0x807a1b8) = eax;
    eax = loc.camlBuffer__13;
    *(0x807a1bc) = eax;
    eax = loc.camlBuffer__12;
    *(0x807a1dc) = eax;
    eax = loc.camlBuffer__11;
    *(0x807a1c0) = eax;
    eax = loc.camlBuffer__10;
    *(0x807a1c8) = eax;
    eax = loc.camlBuffer__9;
    *(0x807a1c4) = eax;
    eax = loc.camlBuffer__8;
    *(0x807a1d0) = eax;
    eax = loc.camlBuffer__7;
    *(0x807a1d4) = eax;
    eax = loc.camlBuffer__6;
    *(0x807a1d8) = eax;
    eax = loc.camlBuffer__5;
    *(0x807a1e0) = eax;
    eax = loc.camlBuffer__4;
    *(0x807a1e4) = eax;
    eax = loc.camlBuffer__3;
    *(0x807a1e8) = eax;
    eax = loc.camlBuffer__2;
    *(0x807a1ec) = eax;
    eax = camlBuffer__1;
    *(0x807a1cc) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80670fd */
#include <stdint.h>
 
int32_t caml_int32_sub (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = *((ebp + 0xc));
    eax -= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c3d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2742 (void) {
    eax = unix_lseek;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80681eb */
#include <stdint.h>
 
int32_t caml_array_unsafe_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((ebp + 0x10));
    if (*((eax - 4)) == 0xfe) {
        eax = caml_array_unsafe_set_float (eax, edx, ecx);
    } else {
        caml_array_unsafe_set_addr (eax, edx, ecx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c090 */
#include <stdint.h>
 
int32_t camlUnix_fun_2646 (void) {
    eax = unix_times;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f561 */
#include <stdint.h>
 
int32_t unix_sendto (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13c97;
    eax = *((ebp + 8));
    edx = *((eax + 0x14));
    edx = *((eax + 0x10));
    edx = *((eax + 0xc));
    edx = *((eax + 8));
    edx = *((eax + 4));
    eax = *(eax);
    unix_sendto_native (edx, edx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f470 */
#include <stdint.h>
 
uint32_t unix_sendto_native (int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch, int32_t arg_sp_10h, int32_t arg_sp_14h) {
    int32_t var_40a0h;
    int32_t var_409ch;
    int32_t var_408ch;
    int32_t var_4088h;
    void * s1;
    void * s2;
    size_t n;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x13d83;
    eax = ebx + 0x93ec;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x40a0)) = eax;
    eax = ebp - 0x408c;
    esi = ebp - 0x4088;
    eax = *((ebp + 0x1c));
    get_sockaddr (eax, esi, eax);
    edi = *((ebp + 0x14));
    edi >>= 1;
    eax = 0x4000;
    if (edi > 0x4000) {
        edi = eax;
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    eax = ebp - 0x4018;
    *((ebp - 0x409c)) = eax;
    memmove (eax, eax, edi);
    caml_enter_blocking_section ();
    eax = *((ebp - 0x408c));
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = esi;
    eax = *((ebp - 0x40a0));
    *((esp + 0xc)) = eax;
    *((esp + 8)) = edi;
    eax = *((ebp - 0x409c));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = sendto ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x2445;
        uerror (eax, 0);
    }
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a014 */
#include <stdint.h>
 
void sendto (void) {
    sendto ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8057650 */
#include <stdint.h>
 
int32_t camlHashtbl_copy_1057 (void) {
    eax = *((eax + 4));
    eax = camlArray_copy_1049 (eax);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *(esp);
            ebx = *(ebx);
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067b24 */
#include <stdint.h>
 
int32_t caml_string_notequal (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_equal (eax, eax);
    edx = 4;
    edx -= eax;
    eax = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058800 */
#include <stdint.h>
 
int32_t camlBuffer_length_1060 (void) {
    eax = *((eax + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80544c0 */
#include <stdint.h>
 
int32_t camlList_hd_1036 (void) {
    if (eax != 1) {
        eax = *(eax);
        return eax;
    }
    eax = loc.camlList__51;
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b5f0 */
#include <stdint.h>
 
int32_t camlSource_sock_readline_1304 (void) {
    int32_t var_4h;
    int32_t var_8h;
    esi = eax;
    eax = ebx;
    edx = 0x81;
    ecx = 1;
    ebx = esi;
    eax = camlUnix_read_1237 (esi, eax);
    ecx = eax;
    *((esp + 8)) = ecx;
    do {
        eax = ecx;
        eax += 0xfffffffe;
        eax >>= 1;
        ebx = *(esp);
        eax = *((ebx + eax));
        eax = eax + eax + 1;
        if (eax == 0x15) {
            goto label_0;
        }
        edx = 0x81;
        eax = *((esp + 4));
        eax = camlUnix_read_1237 ();
        ecx = *((esp + 8));
        ecx += eax;
        ecx--;
        *((esp + 8)) = ecx;
    } while (1);
label_0:
    eax = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d7d0 */
#include <stdint.h>
 
int32_t unix_getgrgid (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15a28;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getgrgid ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_group_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a644 */
#include <stdint.h>
 
void getgrgid (void) {
    getgrgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806f589 */
#include <stdint.h>
 
int32_t caml_final_do_weak_roots (int32_t arg_8h) {
    int32_t var_4h;
    edi = *((ebp + 8));
    if (*(obj.old) == 0) {
        goto label_0;
    }
    ebx = 0;
    esi = 0;
    do {
        eax = ebx;
        eax += *(obj.final_table);
        edx = eax + 4;
        eax = *((eax + 4));
        void (*edi)(uint32_t, uint32_t) (eax, edx);
        esi++;
        ebx += 0xc;
    } while (*(obj.old) > esi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80536c0 */
#include <stdint.h>
 
int32_t camlList_rmap2_f_1103 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (ebx == 1) {
            goto label_1;
        }
        if (ecx == 1) {
            goto label_2;
        }
        eax = *((ecx + 4));
        esi = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *((edx + 0xc));
        ebx = esi;
        eax = caml_apply2 (edx, eax, eax);
        ebx = eax;
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        ebx = *(esp);
        *((eax + 4)) = ebx;
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        edx = *((esp + 0xc));
    } while (1);
label_1:
    if (ecx == 1) {
        return eax;
    }
label_2:
    eax = "List.rev_map2";
    void (*0x804f810)() ();
label_3:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c400 */
#include <stdint.h>
 
int32_t camlUnix_fun_2746 (void) {
    eax = caml_channel_descriptor;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ebd0 */
#include <stdint.h>
 
int32_t unix_mkfifo (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14623;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = mkfifo ();
    if (eax == -1) {
        eax = ebx - 0x249e;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a4a4 */
#include <stdint.h>
 
void mkfifo (void) {
    mkfifo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805cbe0 */
#include <stdint.h>
 
int32_t unix_dup (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16618;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = dup ();
    if (eax == -1) {
        eax = ebx - 0x25cd;
        uerror (eax, 0);
    }
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a334 */
#include <stdint.h>
 
void dup (void) {
    dup ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061eb0 */
#include <stdint.h>
 
int32_t caml_do_local_roots (void) {
    int32_t var_24h_4;
    int32_t var_20h_4;
    uint32_t var_1ch_4;
    int32_t var_8h_2;
    int32_t var_ch_4;
    int32_t var_10h_2;
    int32_t var_14h;
    uint32_t var_18h_2;
    int32_t var_4h_8;
    eax = *((ebp + 0xc));
    if (eax != 0) {
        edx = *((ebp + 0x14));
        *((ebp - 0x20)) = edx;
        edx = *((ebp + 0x10));
        *((ebp - 0x1c)) = eax;
    } else {
label_1:
        if (*((ebp + 0x18)) == 0) {
            goto label_6;
        }
        esi = *((ebp + 0x18));
        *((ebp - 0x1c)) = 0;
        goto label_7;
    }
label_0:
    esi = caml_frame_descriptors_mask;
    eax = edx;
    eax >>= 3;
    eax &= esi;
    ecx = caml_frame_descriptors;
    ebx = *((ecx + eax*4));
    if (*(ebx) == edx) {
        goto label_8;
    }
    do {
        eax++;
        eax &= esi;
        ebx = *((ecx + eax*4));
    } while (*(ebx) != edx);
label_8:
    if (*((ebx + 4)) == 0xffff) {
        goto label_9;
    }
    esi = *((ebx + 6));
    if (esi <= 0) {
        goto label_10;
    }
    edi = ebx + 8;
    *((ebp - 0x24)) = ebx;
    ebx = *((ebp + 8));
    do {
        eax = *(edi);
        if ((al & 1) != 0) {
            eax >>= 1;
            edx = *((ebp - 0x20));
            eax = edx + eax*4;
        } else {
            eax += *((ebp - 0x1c));
        }
        eax = *(eax);
        void (*ebx)(uint32_t, uint32_t) (eax, eax);
        esi--;
        if (esi <= 0) {
            goto label_11;
        }
        edi += 2;
    } while (1);
label_11:
    ebx = *((ebp - 0x24));
label_10:
    eax = *((ebx + 4));
    eax &= 0xfffc;
    *((ebp - 0x1c)) += eax;
    eax = *((ebp - 0x1c));
    edx = *((eax - 4));
    goto label_0;
label_9:
    eax = *((ebp - 0x1c));
    eax += 8;
    edx = *(eax);
    *((ebp - 0x1c)) = edx;
    edx = *((eax + 4));
    eax = *((eax + 8));
    *((ebp - 0x20)) = eax;
    if (*((ebp - 0x1c)) != 0) {
        goto label_0;
    }
    goto label_1;
    do {
label_2:
        eax = ebx*4;
        eax += *((esi + edi*4 + 0xc));
        eax = *(eax);
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        ebx++;
    } while (*((esi + 8)) > ebx);
label_3:
    edi++;
    if (*((esi + 4)) <= edi) {
        goto label_5;
    }
label_4:
    ebx = *((ebp - 0x1c));
    if (*((esi + 8)) > 0) {
        goto label_2;
    }
    goto label_3;
label_5:
    esi = *(esi);
    if (esi == 0) {
        goto label_6;
    }
label_7:
    edi = 0;
    if (*((esi + 4)) > 0) {
        goto label_4;
    }
    goto label_5;
label_6:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806792b */
#include <stdint.h>
 
uint32_t caml_float_of_string (int32_t arg_8h) {
    int32_t var_8h_2;
    uint32_t var_5ch_2;
    int32_t var_58h_2;
    char * * endptr;
    int32_t var_58h;
    esi = *((ebp + 8));
    eax = caml_string_length (ebx, esi, edi);
    ebx = eax;
    edi = ebp - 0x58;
    if (eax > 0x3f) {
        eax = eax + 1;
        eax = caml_stat_alloc (eax);
        edi = eax;
    }
    eax = esi;
    esi = edi;
    while (ebx != 0) {
        edx = *(eax);
        if (dl != 0x5f) {
            *(esi) = dl;
            esi++;
        }
        eax++;
        ebx--;
    }
    *(esi) = 0;
    if (esi != edi) {
        eax = ebp - 0x5c;
        strtod (edi, eax);
        *((ebp - 0x70)) = fp_stack[0];
        fp_stack--;
        if (*((ebp - 0x5c)) != esi) {
            goto label_0;
        }
        eax = ebp - 0x58;
        if (edi != eax) {
            caml_stat_free (edi);
        }
        *(fp_stack--) = *((ebp - 0x70));
        *(esp) = fp_stack[0];
        fp_stack--;
        caml_copy_double ();
        return eax;
    }
label_0:
    eax = ebp - 0x58;
    if (edi != eax) {
        caml_stat_free (edi);
    }
    return caml_failwith ("float_of_string");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056420 */
#include <stdint.h>
 
int32_t camlSys_catch_break_1082 (void) {
    while (1) {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x400;
            *(ebx) = loc.camlSys__5;
            eax = 0xfffffff5;
            void (*0x8056400)() ();
            ebx = 1;
            eax = 0xfffffff5;
            void (*0x8056400)() ();
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f490 */
#include <stdint.h>
 
int32_t camlPervasives_scan_1249 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
        *((esp + 0x10)) = eax;
        *((esp + 0xc)) = ebx;
        *((esp + 4)) = ecx;
        eax = caml_ml_input_scan_line;
        eax = caml_c_call (*((ecx + 0xc)));
        if (eax == 1) {
            eax = *((esp + 0x10));
            if (eax != 1) {
                *((esp + 0x10)) = eax;
                eax = *((esp + 0xc));
                eax = caml_create_string;
                caml_c_call (eax);
                ebx = *((esp + 0xc));
                ecx = *((esp + 0x10));
                void (*0x804f440)() ();
            }
label_2:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = "x5\a\b";
            eax = caml_raise_exn ();
        }
        *((esp + 8)) = eax;
        if (eax > 1) {
            eax += 0xfffffffe;
            eax = caml_create_string;
            eax = caml_c_call (eax);
            *(esp) = eax;
            ebx = *((esp + 8));
            ebx += 0xfffffffe;
            eax = *((esp + 0x10));
            eax = caml_ml_input;
            caml_c_call (*((eax + 0xc)));
            eax = *((esp + 4));
            eax = caml_ml_input_char;
            caml_c_call (*((eax + 0xc)));
            ecx = *((esp + 0x10));
            if (ecx != 1) {
                ebx = *((esp + 8));
                eax = *((esp + 0xc));
                edx = eax + ebx - 3;
                *((esp + 4)) = edx;
label_1:
                eax = caml_young_ptr;
                eax -= 0xc;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_4;
                }
                ebx = eax + 4;
                *((esp + 8)) = ebx;
                *((ebx - 4)) = 0x800;
                eax = *(esp);
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = caml_create_string;
                caml_c_call (edx);
                ebx = *((esp + 4));
                ecx = *((esp + 8));
                void (*0x804f440)() ();
            }
            eax = *(esp);
            return eax;
        }
        ebx = 2;
        ebx -= eax;
        eax = caml_create_string;
        eax = caml_c_call (ebx);
        *(esp) = eax;
        ecx = 2;
        ebx = *((esp + 8));
        ecx -= ebx;
        eax = *((esp + 0x10));
        eax = caml_ml_input;
        caml_c_call (*((eax + 0xc)));
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        ebx = *((esp + 0x10));
        *((eax + 4)) = ebx;
        ebx = *((esp + 0xc));
        ecx = *((esp + 8));
        ebx -= ecx;
        ebx++;
        ecx = *((esp + 4));
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805cd2c */
#include <stdint.h>
 
int32_t unix_execve (void) {
    int32_t var_ch_2;
    int32_t var_8h_2;
    int32_t var_4h_2;
    int32_t var_ch_3;
    int32_t var_10h;
    int32_t var_sp_8h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x164c4;
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    esi = eax;
    eax = *((ebp + 0x10));
    eax = cstringvect (eax);
    edi = eax;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    eax = *((ebp + 8));
    *(esp) = eax;
    execve ();
    caml_stat_free (esi);
    caml_stat_free (edi);
    eax = *((ebp + 8));
    eax = ebx - 0x25be;
    return uerror (eax, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064c54 */
#include <stdint.h>
 
int32_t caml_allocation_color (int32_t arg_8h) {
    eax = caml_gc_phase;
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
        eax = *((ebp + 8));
        if (eax < *(obj.caml_gc_sweep_hp)) {
            goto label_0;
        }
    }
    eax = 0x300;
    goto label_1;
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c2a0 */
#include <stdint.h>
 
uint32_t camlPrintf_get_buff_1402 (void) {
    ecx = eax;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax*4 + 1;
    return camlBuffer_create_1039 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066e51 */
#include <stdint.h>
 
int32_t caml_int64_sub (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    ecx = *((eax + 4));
    ebx = *((eax + 8));
    edx = *((ebp + 0xc));
    esi = ecx;
    edi = ebx;
    esi -= *((edx + 4));
    edi -= *((edx + 8));
    caml_copy_int64 (esi, edi);
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805be90 */
#include <stdint.h>
 
int32_t camlPrintf_next_index_1262 (void) {
    if (eax != 1) {
        eax = ebx;
        return eax;
    }
    edx = *((ecx + 8));
    ecx = *(edx);
    eax = ebx;
    ebx = edx;
    return void (*0x807a850)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bdb0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2562 (void) {
    eax = unix_setsid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806cacb */
#include <stdint.h>
 
int32_t caml_gc_full_major (void) {
    char * var_4h;
    int32_t var_8h;
    caml_gc_message (1, "Full major GC cycle requested\n", 0);
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    caml_final_do_calls ();
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    test_and_compact ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f440 */
#include <stdint.h>
 
int32_t camlPervasives_build_result_1243 (void) {
    do {
        edi = eax;
        if (ecx == 1) {
            goto label_0;
        }
        ebp = *((ecx + 4));
        eax = *(ecx);
        ecx = *((eax - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edx = *((eax + ecx));
        ecx -= edx;
        ecx = ebx;
        ecx -= esi;
        ecx++;
        caml_blit_string (eax, 1, edi, ecx, ecx + ecx + 1);
        ebx -= esi;
        ebx++;
        eax = edi;
        ecx = ebp;
    } while (1);
label_0:
    eax = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80709f0 */
#include <stdint.h>
 
int32_t udivdi3 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_18h;
    uint32_t var_14h;
    uint32_t var_10h;
    uint32_t var_ch;
    eax = *((ebp + 0x14));
    edx = *((ebp + 8));
    esi = *((ebp + 0x10));
    edi = *((ebp + 0xc));
    *((ebp - 0x10)) = edx;
    if (eax == 0) {
        if (esi > edi) {
            goto label_1;
        }
        if (esi == 0) {
            eax = 1;
            edx = 0;
            eax = edx:eax / esi;
            edx = edx:eax % esi;
            esi = eax;
        }
        ecx = *((ebp - 0x10));
        edx = 0;
        eax = edi;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        edi = eax;
        eax = ecx;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
        edx = edi;
        eax = ecx;
        return eax;
    }
    if (eax <= edi) {
        __asm ("bsr edx, eax");
        edx ^= 0x1f;
        *((ebp - 0xc)) = edx;
        if (eax != edi) {
            goto label_2;
        }
        if (esi <= *((ebp - 0x10))) {
            goto label_3;
        }
        if (eax < edi) {
            goto label_3;
        }
    }
    edi = 0;
    ecx = 0;
    do {
label_0:
        eax = ecx;
        edx = edi;
        return eax;
label_1:
        ecx = edx;
        edx = edi;
        eax = ecx;
        edi = 0;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
        edx = edi;
        eax = ecx;
        return eax;
label_2:
        ecx = *((ebp - 0xc));
        edx = esi;
        eax <<= cl;
        *((ebp - 0x14)) = eax;
        eax = 0x20;
        eax -= *((ebp - 0xc));
        ecx = eax;
        edx >>= cl;
        ecx = *((ebp - 0xc));
        edx |= *((ebp - 0x14));
        esi <<= cl;
        ecx = eax;
        *((ebp - 0x18)) = esi;
        esi = edi;
        esi >>= cl;
        ecx = *((ebp - 0xc));
        *((ebp - 0x14)) = edx;
        edx = *((ebp - 0x10));
        edi <<= cl;
        ecx = eax;
        edx >>= cl;
        edi |= edx;
        edx = esi;
        eax = edi;
        eax = *(edx:eax) / ebp - 0x14;
        edx = *(edx:eax) % ebp - 0x14;
        esi = edx;
        edi = eax;
        edx:eax = eax * *((ebp - 0x18));
        *((ebp - 0x14)) = edx;
        if (esi < edx) {
            goto label_4;
        }
        edx = *((ebp - 0x10));
        ecx = *((ebp - 0xc));
        edx <<= cl;
        if (edx < eax) {
            if (esi == *((ebp - 0x14))) {
                goto label_4;
            }
        }
        ecx = edi;
        edi = 0;
    } while (1);
label_3:
    edi = 0;
    ecx = 1;
    goto label_0;
label_4:
    ecx = edi - 1;
    edi = 0;
    eax = ecx;
    edx = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806458c */
#include <stdint.h>
 
uint32_t caml_oldify_one (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_24h;
    uint32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
label_0:
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    do {
label_1:
        if ((bl & 1) != 0) {
            goto label_2;
        }
        if (ebx >= *(obj.caml_young_end)) {
            goto label_2;
        }
        if (ebx <= *(obj.caml_young_start)) {
            goto label_2;
        }
        esi = ebx;
        eax = ebx - 4;
        *((ebp - 0x1c)) = eax;
        edx = *(eax);
        if (edx == 0) {
            eax = *(ebx);
            *(edi) = eax;
            goto label_3;
        }
        eax = (int32_t) dl;
        if (eax > 0xf8) {
            goto label_4;
        }
        esi = edx;
        esi >>= 0xa;
        eax = caml_alloc_shr (esi, eax);
        *(edi) = eax;
        edx = *(ebx);
        ecx = *((ebp - 0x1c));
        *(ecx) = 0;
        *(ebx) = eax;
        if (esi > 1) {
            *(eax) = edx;
            edx = oldify_todo_list;
            *((eax + 4)) = edx;
            *(obj.oldify_todo_list) = ebx;
            goto label_3;
        }
        edi = eax;
        ebx = edx;
    } while (1);
label_4:
    if (eax <= 0xfa) {
        goto label_5;
    }
    edx >>= 0xa;
    *((ebp - 0x20)) = edx;
    eax = caml_alloc_shr (edx, eax);
    if (*((ebp - 0x20)) == 0) {
        goto label_6;
    }
    edx = 0;
    *((ebp - 0x24)) = ebx;
    ebx = *((ebp - 0x20));
    do {
        ecx = *((esi + edx*4));
        *((eax + edx*4)) = ecx;
        edx++;
    } while (ebx > edx);
    ebx = *((ebp - 0x24));
label_6:
    edx = *((ebp - 0x1c));
    *(edx) = 0;
    *(ebx) = eax;
    *(edi) = eax;
    goto label_3;
label_5:
    if (eax == 0xf9) {
        edx >>= 0xa;
        ebx = edx*4;
        esi -= ebx;
        caml_oldify_one (esi, edi);
        goto label_0;
        *(edi) += ebx;
        goto label_3;
    }
    esi = ebx;
    ebx = *(ebx);
    if ((bl & 1) != 0) {
        goto label_1;
    }
    ecx = ebx;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 7) == 0) {
        goto label_7;
    }
    ecx -= 4;
    eax = ecx;
    if (*(ecx) == 0) {
        eax = *(ebx);
        eax -= 4;
    }
    eax = *(eax);
    if (eax == 0xfa) {
        goto label_7;
    }
    if (eax == 0xf6) {
        goto label_7;
    }
    if (eax != 0xfd) {
        goto label_1;
    }
label_7:
    eax = caml_alloc_shr (1, 0xfa);
    *(edi) = eax;
    ecx = *((ebp - 0x1c));
    *(ecx) = 0;
    *(esi) = eax;
    edi = eax;
    goto label_1;
label_2:
    *(edi) = ebx;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052140 */
#include <stdint.h>
 
int32_t camlArray_concat_aux_1062 (void) {
    int32_t var_4h;
    eax = loc.camlArray__30;
    eax = 1;
    eax = camlArray_size_1065 (eax, ebx);
    ebx = *(esp);
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    *(esp) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80509a0;
            *((ecx + 0xc)) = ebx;
            eax = 1;
            ebx = *((esp + 4));
            camlArray_fill_1070 ();
            eax = *(esp);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80690cf */
#include <stdint.h>
 
int32_t caml_ml_output (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_4h;
    int32_t var_8h;
    eax = caml_local_roots;
    *((ebp - 0x3c)) = eax;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp + 0x14;
    *((ebp - 0x20)) = eax;
    eax = *((ebp + 8));
    edi = *((eax + 4));
    esi = *((ebp + 0x10));
    ebx = *((ebp + 0x14));
    ebx >>= 1;
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (edi);
    }
    if (ebx <= 0) {
        goto label_0;
    }
    esi >>= 1;
    do {
        eax = esi;
        eax += *((ebp + 0xc));
        eax = caml_putblock (edi, eax, ebx);
        esi += eax;
        ebx -= eax;
    } while (ebx > 0);
label_0:
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (edi);
    }
    eax = *((ebp - 0x3c));
    *(obj.caml_local_roots) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062a32 */
#include <stdint.h>
 
int32_t caml_urge_major_slice (void) {
    *(obj.caml_force_major_slice) = 1;
    eax = caml_young_end;
    *(obj.caml_young_limit) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806160d */
#include <stdint.h>
 
int32_t unix_write (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t fd;
    void * s1;
    int32_t var_4040h;
    int32_t var_403ch;
    int32_t var_4038h;
    int32_t var_4034h;
    int32_t var_4030h;
    int32_t var_402ch;
    int32_t var_4018h;
    char * ptr;
    size_t nbytes;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x11be6;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4038)) = edx;
    edx = ebp - 0x4038;
    *(eax) = edx;
    *((ebp - 0x4030)) = 1;
    *((ebp - 0x4034)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x402c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    if (esi <= 0) {
        goto label_0;
    }
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebp - 0x403c)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *((ebp - 0x4048)) = eax;
    *((ebp - 0x4040)) = 0;
    eax = ebp - 0x4018;
    *((ebp - 0x4044)) = eax;
    do {
        edi = 0x4000;
        if (esi <= 0x4000) {
            edi = esi;
        }
        eax = *((ebp - 0x403c));
        eax += *((ebp + 0xc));
        edx = *((ebp - 0x4044));
        memmove (edx, eax, edi);
        caml_enter_blocking_section ();
        eax = *((ebp - 0x4044));
        edx = *((ebp - 0x4048));
        eax = write (edx, eax, edi);
        edi = eax;
        caml_leave_blocking_section ();
        if (edi == -1) {
            esi = *((ebp - 0x4040));
            eax = errno_location ();
            if (*(eax) == 0xb) {
                if (esi > 0) {
                    goto label_1;
                }
            }
            eax = ebx - 0x215a;
            uerror (eax, 0);
        }
        *((ebp - 0x4040)) += edi;
        esi -= edi;
        if (esi <= 0) {
            goto label_1;
        }
        *((ebp - 0x403c)) += edi;
    } while (1);
label_0:
    *((ebp - 0x4040)) = 0;
label_1:
    edx = *((ebp - 0x4038));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    edx = *((ebp - 0x4040));
    eax = edx + edx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c740 */
#include <stdint.h>
 
int32_t camlUnix_single_write_1247 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = unix_single_write;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.single_write";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054da0 */
#include <stdint.h>
 
int32_t camlList_remove_assq_1195 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        esi = *((ebx + 4));
        edx = *(ebx);
        ecx = *(edx);
        if (ecx == eax) {
            eax = esi;
            return eax;
        }
        ebx = esi;
        eax = camlList_remove_assq_1195 (edx);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *(esp);
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f7a0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1420 (void) {
    eax = caml_ml_output_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054490 */
#include <stdint.h>
 
int32_t camlList_length_aux_1030 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        ebx = *((ebx + 4));
        eax += 2;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064b2a */
#include <stdint.h>
 
int32_t caml_realloc_ref_table (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * size;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *(ebx);
    if (edi == 0) {
        eax = caml_minor_heap_size;
        eax >>= 5;
        caml_alloc_table (ebx, eax, 0x100);
    } else {
        eax = *((ebx + 0x10));
        if (eax == *((ebx + 8))) {
            caml_gc_message (8, "ref_table threshold crossed\n", 0);
            eax = *((ebx + 4));
            *((ebx + 0x10)) = eax;
            caml_urge_major_slice ();
        } else {
            eax = *((ebx + 0xc));
            *((ebp - 0x1c)) = eax;
            esi = *((ebx + 0x14));
            esi += esi;
            *((ebx + 0x14)) = esi;
            esi += *((ebx + 0x18));
            esi <<= 2;
            eax = esi + 0x3ff;
            __asm ("cmovns eax, esi");
            eax >>= 0xa;
            caml_gc_message (8, "Growing ref_table to %ldk bytes\n", eax);
            eax = *(ebx);
            eax = realloc (eax, esi);
            *(ebx) = eax;
            if (eax == 0) {
                eax = caml_fatal_error ("Fatal error: ref_table overflow\n");
            }
            ecx = *((ebx + 0x14));
            edx = *((ebx + 0x18));
            edx += ecx;
            edx = eax + edx*4;
            *((ebx + 4)) = edx;
            ecx = eax + ecx*4;
            *((ebx + 8)) = ecx;
            ecx = *((ebp - 0x1c));
            ecx -= edi;
            edi = ecx;
            edi &= 0xfffffffc;
            eax += edi;
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = edx;
        }
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e299 */
#include <stdint.h>
 
int32_t caml_fatal_uncaught_exception (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * format;
    char ** var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    eax = caml_format_exception (eax);
    ebx = eax;
    esi = caml_backtrace_active;
    edi = caml_backtrace_pos;
    *(obj.caml_backtrace_active) = 0;
    eax = caml_named_value ("Pervasives.do_at_exit");
    if (eax != 0) {
        eax = *(eax);
        caml_callback_exn (eax, 1);
    }
    *(obj.caml_backtrace_active) = esi;
    *(obj.caml_backtrace_pos) = edi;
    *((esp + 8)) = ebx;
    eax = stderr;
    fprintf (eax, "Fatal error: exception %s\n");
    free (ebx);
    if (*(obj.caml_backtrace_active) != 0) {
        caml_print_exception_backtrace ();
    }
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055640 */
#include <stdint.h>
 
int32_t camlChar_compare_1048 (void) {
    eax -= ebx;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056fd0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_1198 (void) {
    int32_t var_4h_5;
    int32_t var_8h_3;
    int32_t var_ch_2;
    edx = *((eax + 4));
    edx = *((edx - 4));
    edx >>= 0xa;
    if (edx != 0) {
        eax = *((ecx + 0x10));
        eax = *((eax + 8));
        edx = *((eax + 4));
        ecx = *(edx);
        eax = ebx;
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, ecx, ebx);
        ebx = 0x7fffffff;
        eax &= ebx;
        eax >>= 1;
        ecx = *((esp + 0xc));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    eax = *(esp);
    ebx = *((eax + 4));
    eax = *((ebx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    ebx = *((ebx + edx*2 - 2));
    if (ebx == 1) {
        goto label_3;
    }
    eax = *((ebx + 8));
    eax = *((ebx + 4));
    ebx = *(ebx);
    eax = *((esp + 4));
    eax = *((eax + 0xc));
    ecx = *(eax);
    eax = *((esp + 8));
    eax = caml_apply2 (eax);
    if (eax != 1) {
        eax = *((esp + 0xc));
        return eax;
    }
    eax = *(esp);
    if (eax != 1) {
        ebx = *((eax + 8));
        ebx = *((eax + 4));
        ebx = *(eax);
        eax = *((esp + 4));
        eax = *((eax + 0xc));
        ecx = *(eax);
        eax = *((esp + 8));
        eax = caml_apply2 (ebx);
        if (eax != 1) {
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *(esp);
        if (eax != 1) {
            ebx = *((eax + 8));
            ebx = *((eax + 4));
            ebx = *(eax);
            eax = *((esp + 4));
            eax = *((eax + 0xc));
            ecx = *(eax);
            eax = *((esp + 8));
            eax = caml_apply2 (ebx);
            if (eax != 1) {
                eax = *((esp + 0xc));
                return eax;
            }
            eax = *((esp + 4));
            ecx = *((eax + 0x14));
            eax = *((esp + 8));
            ebx = *(esp);
            void (*0x8056f40)() ();
        }
label_1:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x400;
        *(eax) = loc.caml_exn_Not_found;
        caml_raise_exn ();
    }
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = loc.caml_exn_Not_found;
    caml_raise_exn ();
    do {
label_3:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80577e0 */
#include <stdint.h>
 
int32_t camlHashtbl_add_1074 (void) {
    edi = eax;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = caml_hash_univ_param (ecx, 0xc9, ebx);
        eax >>= 1;
        ecx = esi;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            *(eax) = ebx;
            ebx = *(esp);
            *((eax + 4)) = ebx;
            ecx = *((edi + 4));
            ebx = *((ecx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_0;
            }
            ebx = *((ecx + edx*2 - 2));
            *((eax + 8)) = ebx;
            ecx = *((edi + 4));
            ebx = *((ecx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_1;
            }
            caml_modify (ecx + edx*2 - 2, eax);
            *(edi) += 2;
            eax = *((edi + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ebx = eax + eax - 1;
            eax = *(edi);
            if (eax > ebx) {
                eax = .comment;
                ebx = edi;
                void (*0x80576b0)() ();
            }
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80563c0 */
#include <stdint.h>
 
int32_t loc_camlSys_code_begin (void) {
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            ebx = .comment;
            *(eax) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ea38 */
#include <stdint.h>
 
int32_t unix_lseek_64 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x147b8;
    eax = *((ebp + 0xc));
    esi = *((eax + 4));
    edi = *((eax + 8));
    caml_enter_blocking_section ();
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x24b0));
    *((esp + 0xc)) = eax;
    *((esp + 4)) = esi;
    *((esp + 8)) = edi;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = lseek64 ();
    esi = eax;
    edi = edx;
    caml_leave_blocking_section ();
    eax = esi;
    eax &= edi;
    if (eax == -1) {
        eax = ebx - 0x24b6;
        uerror (eax, 0);
    }
    caml_copy_int64 (esi, edi);
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fd9d */
#include <stdint.h>
 
void caml_dlerror (void) {
    dlerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a634 */
#include <stdint.h>
 
void dlerror (void) {
    dlerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067232 */
#include <stdint.h>
 
int32_t caml_float_compare (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_0;
        }
        fp_tmp_1 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
    } else {
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
    }
    if (fp_stack[0] <= fp_stack[1]) {
        fp_tmp_3 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_3;
        if (fp_stack[0] <= fp_stack[1]) {
            fp_stack--;
            if (fp_stack[0] != fp_stack[0]) {
                if (fp_stack[0] == fp_stack[0]) {
                    goto label_1;
                }
            }
            fp_stack--;
            if (fp_stack[0] != fp_stack[0]) {
                if (fp_stack[0] == fp_stack[0]) {
                    goto label_2;
                }
                goto label_3;
label_0:
                fp_stack++;
                fp_stack++;
            }
label_3:
            eax = 1;
            fp_stack++;
            fp_stack++;
label_2:
            eax = 0xffffffff;
        } else {
        } else {
            fp_stack++;
            fp_stack++;
            goto label_4;
label_1:
            fp_stack++;
label_4:
            eax = 3;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bf90 */
#include <stdint.h>
 
int32_t camlUnix_fun_2616 (void) {
    eax = unix_getgrnam;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c190 */
#include <stdint.h>
 
int32_t camlUnix_fun_2674 (void) {
    eax = unix_readlink;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c2d0 */
#include <stdint.h>
 
int32_t camlPrintf_get_contents_1405 (void) {
    ecx = *((eax + 4));
    ebx = 1;
    eax = *(eax);
    camlString_sub_1046 (eax);
    ebx = *(esp);
    *((ebx + 4)) = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8057fe0 */
#include <stdint.h>
 
int32_t camlHashtbl_fold_1138 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h;
    esi = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x1c;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x10f7;
    *(edx) = sym.caml_curry2;
    *((edx + 4)) = 5;
    *((edx + 8)) = 0x8056cd0;
    *((edx + 0xc)) = esi;
    esi = *((ebx + 4));
    ebx = edx + 0x14;
    *((ebx - 4)) = 0x400;
    *(ebx) = ecx;
    eax = 1;
    ecx = *((esi - 4));
    ecx >>= 9;
    ecx |= 1;
    ecx += 0xfffffffe;
    if (eax > ecx) {
        goto label_2;
    }
    *((esp + 0x10)) = ecx;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = ebx;
    *(esp) = esi;
    *((esp + 4)) = edx;
    do {
        ebx = *(ebx);
        ecx = *(esp);
        edx = *((ecx - 4));
        edx >>= 9;
        if (edx <= eax) {
            goto label_3;
        }
        eax = *((ecx + eax*2 - 2));
        ecx = *((esp + 4));
        eax = camlHashtbl_do_bucket_1142 ();
        ebx = *((esp + 0xc));
        caml_modify (ebx, eax);
        eax = *((esp + 0xc));
        edx = *((esp + 0xc));
        eax += 2;
        *((esp + 0xc)) = eax;
        ecx = *((esp + 0x10));
    } while (edx != ecx);
label_2:
    eax = *(ebx);
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066a18 */
#include <stdint.h>
 
int32_t caml_int64_bits_of_float (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *(eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060438 */
#include <stdint.h>
 
int32_t unix_getsockopt (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12dc0;
    eax = *((ebp + 8));
    eax >>= 1;
    edx = *((ebp + 0x10));
    edx >>= 1;
    edx <<= 3;
    edx += *((ebx + eax*4 - 0x138));
    ecx = *((ebp + 0xc));
    ecx = *((edx + 4));
    edx = *(edx);
    eax = *((ebx + eax*4 - 0x110));
    return unix_getsockopt_aux (ecx, eax, edx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060285 */
#include <stdint.h>
 
int32_t unix_getsockopt_aux (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t sockfd) {
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t level;
    int32_t optname;
    void * optval;
    socklen_t * optlen;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x12f6b;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    if (esi <= 4) {
        eax = ebx;
        eax -= *((ebx + esi*4 - 0x12f4c));
        void (*eax)() ();
    }
    return unix_error (0x16, edi, 0);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f124 */
#include <stdint.h>
 
uint32_t unix_rmdir (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x140cf;
    esi = *((ebp + 8));
    *(esp) = esi;
    eax = rmdir ();
    if (eax == -1) {
        eax = ebx - 0x2452;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a624 */
#include <stdint.h>
 
void rmdir (void) {
    rmdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f7c0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1424 (void) {
    eax = caml_ml_flush;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806831d */
#include <stdint.h>
 
int32_t caml_array_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((ebp + 0x10));
    if (*((eax - 4)) == 0xfe) {
        eax = caml_array_set_float (eax, edx, ecx);
    } else {
        caml_array_set_addr (eax, edx, ecx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bdd0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2566 (void) {
    eax = unix_tcflush;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804dc80 */
#include <stdint.h>
 
int32_t camlUnix_open_process_full_1985 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    int32_t var_20h;
    int32_t var_24h;
    int32_t var_28h;
    *((esp + 0xc)) = eax;
    *((esp + 0x10)) = ebx;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 0x18)) = ebx;
    eax = *(eax);
    *((esp + 8)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 4)) = ebx;
    eax = *(eax);
    *((esp + 0x14)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 0x1c)) = ebx;
    eax = *(eax);
    *(esp) = eax;
    eax = *((esp + 8));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    *((esp + 0x20)) = eax;
    eax = *((esp + 4));
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    *((esp + 0x24)) = eax;
    eax = *(esp);
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    ebx = eax;
    *((esp + 0x28)) = ebx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x34;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x800;
    eax = *(esp);
    *(esi) = eax;
    *((esi + 4)) = 1;
    edx = esi + 0xc;
    *((edx - 4)) = 0x800;
    eax = *((esp + 4));
    *(edx) = eax;
    *((edx + 4)) = esi;
    ecx = esi + 0x18;
    *((ecx - 4)) = 0x800;
    eax = *((esp + 8));
    *(ecx) = eax;
    *((ecx + 4)) = edx;
    ecx = esi + 0x24;
    *((ecx - 4)) = 0xc03;
    eax = *((esp + 0x20));
    *(ecx) = eax;
    eax = *((esp + 0x24));
    *((ecx + 4)) = eax;
    *((ecx + 8)) = ebx;
    eax = *((esp + 0xc));
    ebx = *((esp + 0x10));
    edx = *((esp + 0x14));
    esi = *((esp + 0x18));
    edi = *((esp + 0x1c));
    ebp = *(esp);
    *(loc.caml_extra_params) = ebp;
    camlUnix_open_proc_full_1975 (ecx);
    eax = *((esp + 0x14));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x18));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x1c));
    eax = unix_close;
    caml_c_call (eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *((esp + 0x20));
            *(eax) = ebx;
            ebx = *((esp + 0x24));
            *((eax + 4)) = ebx;
            ebx = *((esp + 0x28));
            *((eax + 8)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804db10 */
#include <stdint.h>
 
int32_t camlUnix_open_proc_full_1975 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    ebx = caml_extra_params;
    eax = .comment;
    eax = camlList_for_all_1137 (eax, esi, edi);
    *((esp + 0xc)) = eax;
    eax = unix_fork;
    eax = caml_c_call (1);
    ecx = eax;
    if (ecx != 1) {
        eax = .comment;
        ebx = *((esp + 0x1c));
        void (*0x80577e0)() ();
    }
    eax = *((esp + 4));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *(esp);
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 8));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    eax = unix_dup2;
    caml_c_call (eax);
    eax = *((esp + 8));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    if (eax == 1) {
        eax = loc.camlUnix__184;
        ebx = *((esp + 0x18));
        camlList_iter_1074 ();
    }
    fcn_0804dc10 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ae10 */
#include <stdint.h>
 
int32_t caml_curry7_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059150 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1565 (void) {
    edx = eax;
    eax = *((ecx + 0xc));
    eax -= edx;
    eax -= 3;
    eax += 2;
    esi = *((ecx + 0x10));
    ecx = *((esi - 4));
    edx = *((esi - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_0;
        }
        eax = caml_modify (esi + eax*2 - 2, ebx);
    } else {
        ecx >>= 0xa;
        if (ecx <= eax) {
            goto label_1;
        }
        *(fp_stack--) = *(ebx);
        *((esi + eax*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066613 */
#include <stdint.h>
 
uint32_t caml_int32_format (void) {
    char * format;
    int32_t var_8h_4;
    int32_t var_4h_3;
    int32_t var_8h_3;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = ebp - 0x38;
    eax = ebp - 0x59;
    edi = ebp - 0x58;
    ecx = esi;
    edx = 0x8071d88;
    eax = *((ebp + 8));
    eax = parse_format (edi, eax);
    ebx = eax;
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    sprintf (ebx, esi, eax);
    eax = caml_copy_string (ebx);
    esi = eax;
    if (ebx != edi) {
        caml_stat_free (ebx);
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b490 */
#include <stdint.h>
 
uint32_t caml_apply4 (void) {
    int32_t var_14h;
    int32_t var_18h;
    edi = *((esi + 4));
    if (edi == 9) {
        edi = *((esi + 8));
        void (*edi)() ();
    }
    ecx = *(esi);
    ebx = esi;
    eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (ebx, ecx, edx);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 4));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 8));
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e664 */
#include <stdint.h>
 
int32_t caml_callbackN (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_callbackN_exn (eax, eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80502c0 */
#include <stdint.h>
 
int32_t camlPervasives_entry (void) {
    *(0x8076958) = loc.camlPervasives__84;
    *(0x8076950) = 0x8076d3c;
    *(0x807694c) = 0x8076d30;
    *(0x8076948) = 0x8076d24;
    *(0x8076944) = 0x8076d14;
    *(0x8076940) = 0x8076d08;
    *(0x807693c) = 0x8076cfc;
    *(0x8076938) = 0x8076cf0;
    *(0x8076928) = 0x8076ce4;
    *(0x8076918) = 0x8076cd4;
    *(0x807690c) = 0x8076cc8;
    *(0x8076908) = 0x8076cbc;
    *(0x8076904) = 0x8076cac;
    *(0x80768fc) = 0x8076c9c;
    *(0x80768f8) = 0x8076c8c;
    *(0x80768ec) = 0x8076c7c;
    *(0x80768e4) = 0x8076c70;
    eax = loc.camlPervasives__67;
    *(0x807683c) = eax;
    eax = loc.camlPervasives__66;
    *(loc.camlPervasives) = eax;
    caml_alloc1 ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = "Pervasives.Exit";
    *(0x8076840) = eax;
    eax = loc.camlPervasives__64;
    *(0x8076844) = eax;
    eax = loc.camlPervasives__63;
    *(0x8076848) = eax;
    eax = loc.camlPervasives__62;
    *(0x807684c) = eax;
    eax = loc.camlPervasives__61;
    *(0x8076858) = eax;
    eax = 0x80000001;
    *(0x8076854) = 0x80000001;
    *(0x8076850) = 0x7fffffff;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__60);
    *(0x807685c) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__59);
    *(0x8076860) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__58);
    *(0x8076864) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__57);
    *(0x8076868) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__56);
    *(0x807686c) = eax;
    eax = caml_int64_float_of_bits;
    eax = caml_c_call (loc.camlPervasives__55);
    *(0x8076870) = eax;
    eax = loc.camlPervasives__54;
    *(0x8076874) = eax;
    eax = loc.camlPervasives__53;
    *(0x8076878) = eax;
    eax = loc.camlPervasives__52;
    *(0x807687c) = eax;
    eax = loc.camlPervasives__51;
    *(0x8076880) = eax;
    eax = loc.camlPervasives__50;
    *(0x8076884) = eax;
    eax = loc.camlPervasives__49;
    *(0x807697c) = eax;
    eax = loc.camlPervasives__48;
    *(0x8076970) = eax;
    eax = loc.camlPervasives__47;
    *(0x8076888) = eax;
    eax = loc.camlPervasives__46;
    *(0x807688c) = eax;
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (1);
    *(0x8076890) = eax;
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (3);
    *(0x8076894) = eax;
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (5);
    *(0x8076898) = eax;
    eax = loc.camlPervasives__45;
    *(0x80768e0) = eax;
    eax = loc.camlPervasives__44;
    *(0x80768d8) = eax;
    eax = loc.camlPervasives__43;
    *(0x80768dc) = eax;
    eax = loc.camlPervasives__42;
    *(0x80768e8) = eax;
    eax = loc.camlPervasives__41;
    *(0x80768f0) = eax;
    eax = loc.camlPervasives__40;
    *(0x80768f4) = eax;
    eax = loc.camlPervasives__39;
    *(0x8076900) = eax;
    eax = loc.camlPervasives__38;
    *(0x8076910) = eax;
    eax = loc.camlPervasives__37;
    *(0x8076914) = eax;
    eax = loc.camlPervasives__36;
    *(0x8076924) = eax;
    eax = loc.camlPervasives__35;
    *(0x807691c) = eax;
    eax = loc.camlPervasives__34;
    *(0x8076920) = eax;
    eax = loc.camlPervasives__33;
    *(0x8076930) = eax;
    eax = loc.camlPervasives__32;
    *(0x8076974) = eax;
    eax = loc.camlPervasives__31;
    *(0x8076934) = eax;
    eax = loc.camlPervasives__30;
    *(0x807692c) = eax;
    eax = loc.camlPervasives__29;
    *(0x8076954) = eax;
    eax = loc.camlPervasives__28;
    *(0x807689c) = eax;
    eax = loc.camlPervasives__27;
    *(0x80768a0) = eax;
    eax = loc.camlPervasives__26;
    *(0x80768a4) = eax;
    eax = loc.camlPervasives__25;
    *(0x80768a8) = eax;
    eax = loc.camlPervasives__24;
    *(0x80768ac) = eax;
    eax = loc.camlPervasives__23;
    *(0x80768b0) = eax;
    eax = loc.camlPervasives__22;
    *(0x80768b4) = eax;
    eax = loc.camlPervasives__21;
    *(0x80768b8) = eax;
    eax = loc.camlPervasives__20;
    *(0x80768bc) = eax;
    eax = loc.camlPervasives__19;
    *(0x80768c0) = eax;
    eax = loc.camlPervasives__18;
    *(0x80768c4) = eax;
    eax = loc.camlPervasives__17;
    *(0x80768c8) = eax;
    eax = loc.camlPervasives__16;
    *(0x80768cc) = eax;
    eax = loc.camlPervasives__15;
    *(0x80768d0) = eax;
    eax = loc.camlPervasives__14;
    *(0x80768d4) = eax;
    eax = loc.camlPervasives__13;
    eax = 0x24;
    caml_allocN ();
    ebx = eax + 4;
    *((ebx - 4)) = 0x1800;
    *(ebx) = loc.camlPervasives__7;
    *((ebx + 4)) = 0x80769d8;
    *((ebx + 8)) = 0x80769e4;
    *((ebx + 0xc)) = 0x80769f0;
    *((ebx + 0x10)) = 0x8076a00;
    *((ebx + 0x14)) = 0x8076a0c;
    *(0x807695c) = ebx;
    eax = loc.camlPervasives__6;
    *(0x8076964) = eax;
    eax = loc.camlPervasives__5;
    *(0x8076960) = eax;
    ebx += 0x1c;
    *((ebx - 4)) = 0x400;
    eax = .comment;
    *(ebx) = eax;
    *(0x8076980) = ebx;
    eax = loc.camlPervasives__4;
    *(0x807696c) = eax;
    eax = loc.camlPervasives__3;
    *(0x8076978) = eax;
    eax = camlPervasives__2;
    *(0x8076968) = eax;
    eax = caml_register_named_value;
    caml_c_call ("Pervasives.do_at_exit");
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80704f4 */
#include <stdint.h>
 
void loc_caml_allocN (int32_t arg_4h, int32_t arg_8h) {
    do {
        eax -= *(obj.caml_young_ptr);
        eax = -eax;
        if (eax >= *(obj.caml_young_limit)) {
            *(obj.caml_young_ptr) = eax;
            return eax;
        }
        eax -= *(obj.caml_young_ptr);
        eax = -eax;
        *(obj.caml_young_ptr) -= eax;
        eax = *((esp + 4));
        *(obj.caml_last_return_address) = eax;
        eax = esp + 8;
        *(obj.caml_bottom_of_stack) = eax;
        fcn_0807043d ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d000 */
#include <stdint.h>
 
uint32_t unix_clear_nonblock (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x161f3;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 3;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        ah &= 0xf7;
        *((esp + 8)) = eax;
        *((esp + 4)) = 4;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x257c;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80566e0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_in_bucket_1213 (void) {
    int32_t var_4h_4;
    int32_t var_8h_2;
    do {
label_0:
        if (eax == 1) {
            goto label_1;
        }
        ecx = *((eax + 8));
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0xc));
        eax = caml_apply2 (ecx, ebx, ecx);
        if (eax == 1) {
            goto label_2;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        eax = camlHashtbl_find_in_bucket_1213 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 8));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_2:
            eax = *(esp);
            ebx = *((esp + 4));
            goto label_0;
label_1:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067549 */
#include <stdint.h>
 
int32_t caml_tan_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    tan (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a7a4 */
#include <stdint.h>
 
void tan (void) {
    tan ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80678c8 */
#include <stdint.h>
 
int32_t caml_add_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] += *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c440 */
#include <stdint.h>
 
int32_t camlUnix_fun_2754 (void) {
    eax = unix_open;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805efbc */
#include <stdint.h>
 
int32_t unix_readdir (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1423c;
    eax = *((ebp + 8));
    eax = *(eax);
    if (eax == 0) {
        eax = ebx - 0x2474;
        eax = unix_error (9, eax, 0);
    }
    *(esp) = eax;
    eax = readdir64 ();
    if (eax == 0) {
        eax = caml_raise_end_of_file ();
    }
    eax += 0x13;
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056a80 */
#include <stdint.h>
 
int32_t camlHashtbl_find_in_bucket_1108 (void) {
    int32_t var_18h_3;
    int32_t var_18h;
    do {
label_0:
        if (eax == 1) {
            goto label_1;
        }
        *((esp + 4)) = ebx;
        ecx = *((eax + 8));
        *(esp) = ecx;
        ecx = *((eax + 4));
        *((esp + 8)) = ecx;
        eax = *(eax);
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax != 1) {
            goto label_2;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        eax = camlHashtbl_find_in_bucket_1108 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 8));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_2:
            eax = *(esp);
            ebx = *((esp + 4));
            goto label_0;
label_1:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80695ec */
#include <stdint.h>
 
uint32_t caml_ml_seek_out_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    caml_seek_out (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058700 */
#include <stdint.h>
 
int32_t camlBuffer_sub_1046 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    if (ebx >= 1) {
        if (ecx < 1) {
            goto label_0;
        }
        edx = *((eax + 4));
        edx -= ecx;
        edx++;
        if (ebx > edx) {
            goto label_0;
        }
        *((esp + 8)) = ecx;
        *((esp + 4)) = ebx;
        *(esp) = eax;
        eax = caml_create_string;
        eax = caml_c_call (ecx);
        ecx = eax;
        edx = 1;
        eax = *(esp);
        eax = *(eax);
        ebx = *((esp + 4));
        esi = *((esp + 8));
        camlString_blit_1056 (ecx);
        eax = *((esp + 0xc));
        return eax;
    }
label_0:
    eax = "Buffer.sub";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e8f9 */
#include <stdint.h>
 
uint32_t caml_weak_get_copy (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_78h;
    int32_t var_74h;
    int32_t var_70h;
    int32_t var_6ch;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    void * var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    void * s2;
    size_t n;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    eax = ebp - 0x38;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    edx = ebp + 8;
    *((ebp - 0x2c)) = edx;
    edx = ebp + 0xc;
    *((ebp - 0x28)) = edx;
    esi = *((ebp + 0xc));
    esi >>= 1;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x40)) = 0;
    *((ebp - 0x60)) = eax;
    eax = ebp - 0x60;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x58)) = 1;
    *((ebp - 0x5c)) = 2;
    eax = ebp - 0x3c;
    *((ebp - 0x54)) = eax;
    eax = ebp - 0x40;
    *((ebp - 0x50)) = eax;
    esi++;
    if (esi != 0) {
        eax = *((ebp + 8));
        edx = *((eax - 4));
        edx >>= 0xa;
        if (esi < edx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.get");
label_0:
    esi <<= 2;
    eax = *((esi + eax));
    if (eax == *(obj.caml_weak_none)) {
        *(obj.caml_local_roots) = ebx;
        eax = 1;
        goto label_1;
    }
    if ((al & 1) != 0) {
        goto label_2;
    }
    edi = eax;
    ecx = eax;
    ecx >>= 0x17;
    edx = eax;
    edx >>= 0xc;
    edx &= 0x7ff;
    ecx = *((ecx*4 + obj.caml_page_table));
    if ((*((ecx + edx)) & 3) == 0) {
        goto label_2;
    }
    edi -= 4;
    eax = *(edi);
    eax = *(edi);
    eax >>= 0xa;
    eax = caml_alloc (eax, eax);
    *((ebp - 0x40)) = eax;
    edx = *((ebp + 8));
    edx = *((esi + edx));
    if (edx == *(obj.caml_weak_none)) {
        *(obj.caml_local_roots) = ebx;
        eax = 1;
        goto label_1;
    }
    *((ebp - 0x74)) = edx;
    ecx = edx - 4;
    if (*(ecx) > 0xfa) {
        goto label_3;
    }
    *((ebp - 0x70)) = ecx;
    eax = *(ecx);
    eax >>= 0xa;
    if (eax == 0) {
        goto label_4;
    }
    esi = 0;
    *((ebp - 0x78)) = ebx;
    do {
        edi = esi*4;
        eax = *((ebp - 0x74));
        ebx = *((eax + esi*4));
        if (*(obj.caml_gc_phase) == 0) {
            if ((bl & 1) != 0) {
                goto label_5;
            }
            edx = ebx;
            edx >>= 0x17;
            eax = ebx;
            eax >>= 0xc;
            eax &= 0x7ff;
            edx = *((edx*4 + obj.caml_page_table));
            if ((*((edx + eax)) & 1) == 0) {
                goto label_5;
            }
            caml_darken (ebx, 0);
        }
label_5:
        eax = edi;
        eax += *((ebp - 0x40));
        edx = *(eax);
        *((ebp - 0x6c)) = edx;
        *(eax) = ebx;
        eax = edi;
        eax += *((ebp - 0x40));
        edx = eax;
        edx >>= 0x17;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 1) != 0) {
            if (*(obj.caml_gc_phase) == 0) {
                eax = *((ebp - 0x6c));
                caml_darken (eax, 0);
            }
            if ((bl & 1) != 0) {
                goto label_6;
            }
            eax = caml_young_end;
            if (ebx >= eax) {
                goto label_6;
            }
            edx = caml_young_start;
            if (ebx <= edx) {
                goto label_6;
            }
            if ((*((ebp - 0x6c)) & 1) == 0) {
                ecx = *((ebp - 0x6c));
                if (eax <= ecx) {
                    goto label_7;
                }
                if (edx < ecx) {
                    goto label_6;
                }
            }
label_7:
            edx = 0x807fe88;
            eax = *(edx);
            if (eax >= *(0x807fe8c)) {
                caml_realloc_ref_table (obj.caml_ref_table);
            }
            edx = 0x807fe88;
            eax = *(edx);
            edi += *((ebp - 0x40));
            *(eax) = edi;
            eax += 4;
            *(edx) = eax;
        }
label_6:
        esi++;
        edx = *((ebp - 0x70));
        eax = *(edx);
        eax >>= 0xa;
    } while (eax > esi);
    ebx = *((ebp - 0x78));
    goto label_4;
label_3:
    ecx = *(ecx);
    ecx >>= 0xa;
    ecx <<= 2;
    eax = memmove (eax, edx, ecx);
    goto label_4;
label_2:
    *((ebp - 0x40)) = eax;
label_4:
    eax = caml_alloc_small (1, 0);
    *((ebp - 0x3c)) = eax;
    edx = *((ebp - 0x40));
    *(eax) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x3c));
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062dd2 */
#include <stdint.h>
 
int32_t caml_set_signal_action (int32_t signum, int32_t arg_ch) {
    int32_t var_120h;
    int32_t var_94h;
    int32_t var_90h;
    int32_t var_10h;
    struct sigaction * act;
    struct sigaction * oldact;
    eax = *((ebp + 0xc));
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
    } else {
        *((ebp - 0x94)) = 0;
        *((ebp - 0x10)) = 0;
        goto label_1;
    }
    *((ebp - 0x94)) = 1;
    *((ebp - 0x10)) = 0;
    goto label_1;
label_0:
    *((ebp - 0x94)) = sym.handle_signal;
    *((ebp - 0x10)) = 0;
label_1:
    ebx = ebp - 0x94;
    eax = ebp - 0x90;
    *(esp) = eax;
    sigemptyset ();
    eax = ebp - 0x120;
    eax = *((ebp + 8));
    eax = sigaction (eax, ebx, eax);
    edx = eax;
    eax = 0xffffffff;
    if (edx != -1) {
        edx = *((ebp - 0x120));
        eax = 2;
        if (edx == sym.handle_signal) {
            goto label_2;
        }
        al = (edx == 1) ? 1 : 0;
        eax = (int32_t) al;
    }
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c1b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2678 (void) {
    eax = unix_mkfifo;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e02d */
#include <stdint.h>
 
int32_t caml_md5_string (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_60h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = ebp - 0x60;
    caml_MD5Init (ebx);
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax += *((ebp + 8));
    caml_MD5Update (ebx, eax, eax);
    eax = caml_alloc_string (0x10);
    esi = eax;
    caml_MD5Final (eax, ebx);
    eax = esi;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8051740 */
#include <stdint.h>
 
int32_t camlArray_merge_1191 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    uint32_t var_8h;
    uint32_t var_ch;
    int32_t var_10h;
    *(esp) = eax;
    *((esp + 4)) = ecx;
    *((esp + 0x10)) = edx;
    *((esp + 8)) = edi;
    eax = caml_extra_params;
    *((esp + 0xc)) = eax;
    ebp = .comment;
    ecx = *(esp);
    edx = ecx + ebx - 1;
    eax = *((esp + 0x10));
    esi = eax + esi - 1;
label_1:
    eax = caml_young_ptr;
    eax -= 0x28;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    edi = eax + 4;
    *((edi - 4)) = 0x24f7;
    *(edi) = sym.caml_curry5;
    *((edi + 4)) = 0xb;
    *((edi + 8)) = 0x80506f0;
    eax = *((ebp + 0xc));
    *((edi + 0xc)) = eax;
    eax = *((ebp + 0x10));
    *((edi + 0x10)) = eax;
    ebx = *((esp + 4));
    *((edi + 0x14)) = ebx;
    eax = *((esp + 8));
    *((edi + 0x18)) = eax;
    *((edi + 0x1c)) = edx;
    *((edi + 0x20)) = esi;
    eax = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
        if (eax <= *((esp + 0x10))) {
            goto label_3;
        }
        eax = *((esp + 0x10));
        edx = *((ebx + eax*2 - 2));
    } else {
        eax >>= 0xa;
        if (eax <= *((esp + 0x10))) {
            goto label_4;
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        edx = eax + 4;
        *((edx - 4)) = 0x8fd;
        eax = *((esp + 0x10));
        *(fp_stack--) = *((ebx + eax*4 - 4));
        *(edx) = fp_stack[0];
        fp_stack--;
    }
    esi = *((ebp + 0x10));
    eax = *((esi - 4));
    ebx = *((esi - 4));
    ebx &= 0xff;
    if (ebx != 0xfe) {
        eax >>= 9;
        if (eax <= ecx) {
            goto label_6;
        }
        ebx = *((esi + ecx*2 - 2));
        goto label_7;
    }
    eax >>= 0xa;
    if (eax <= ecx) {
        goto label_8;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((esi + ecx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
label_7:
            eax = ecx;
            ecx = *((esp + 0x10));
            esi = *((esp + 0xc));
            void (*0x80506f0)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
label_8:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069173 */
#include <stdint.h>
 
uint32_t caml_ml_output_partial (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 4;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebp + 0x14;
    *((ebp - 0x20)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0x14));
    eax >>= 1;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    eax = caml_putblock (ebx, eax, eax);
    edi = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062a65 */
#include <stdint.h>
 
int32_t caml_rev_convert_signal_number (int32_t arg_8h) {
    eax = *((ebp + 8));
    edx = 1;
    ecx = posix_signals;
    if (eax != 6) {
        goto label_0;
    }
    dl = 0;
    while (edx != 0x15) {
label_0:
        if (*((ecx + edx*4)) == eax) {
            eax = edx;
            eax = ~eax;
        } else {
            edx++;
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f360 */
#include <stdint.h>
 
int32_t loc_camlPervasives_code_begin (void) {
    do {
        ecx = *((ebx + 0xc));
        if (eax >= ecx) {
            ecx = loc.camlPervasives__103;
            eax = *((ebx + 8));
            ebx = ecx;
            void (*0x804f900)() ();
        }
        edx = *((ebx + 8));
        ecx = eax;
        ecx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ecx) {
            goto label_0;
        }
        ecx = *((edx + ecx));
        ecx = ecx + ecx + 1;
        if (ecx >= 0x61) {
            if (ecx < 0x75) {
                goto label_1;
            }
        } else {
            if (ecx == 0x5b) {
                goto label_1;
            }
        }
        eax = *((ebx + 8));
        return eax;
label_1:
        eax += 2;
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b580 */
#include <stdint.h>
 
int32_t camlStd_exit_entry (void) {
    eax = .comment;
    ebx = *(eax);
    eax = 1;
    ecx = *(ebx);
    void (*ecx)() ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061fd7 */
#include <stdint.h>
 
int32_t caml_stack_usage (void) {
    ebx = caml_top_of_stack;
    ebx -= *(obj.caml_bottom_of_stack);
    ebx >>= 2;
    eax = caml_stack_usage_hook;
    if (eax != 0) {
        eax = void (*eax)() ();
        ebx += eax;
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bf85 */
#include <stdint.h>
 
uint32_t caml_sys_chdir (int32_t arg_8h) {
    ebx = *((ebp + 8));
    *(esp) = ebx;
    eax = chdir ();
    if (eax != 0) {
        caml_sys_error (ebx);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a4b4 */
#include <stdint.h>
 
void chdir (void) {
    chdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059be0 */
#include <stdint.h>
 
int32_t camlPrintf_add_conv_1169 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *((esp + 8)) = ebx;
    *((esp + 4)) = ecx;
    *(esp) = edx;
    if (eax != 1) {
        ebx = camlPrintf__64;
        eax = *((edx + 0xc));
        camlBuffer_add_string_1082 ();
    } else {
        ebx = 0x4b;
        eax = *((edx + 0xc));
        camlBuffer_add_char_1072 ();
    }
    eax = *(esp);
    eax = *((eax + 0x10));
    eax = *((eax + 0xc));
    ebx = *((esp + 4));
    camlBuffer_add_char_1072 ();
    eax = *((esp + 8));
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f9d0 */
#include <stdint.h>
 
uint32_t camlPervasives_bool_of_string_1129 (void) {
    ebx = eax;
    eax = caml_string_notequal (ebx, "false");
    if (eax != 1) {
        eax = caml_string_notequal (ebx, "true");
        if (eax != 1) {
            eax = "bool_of_string";
            void (*0x804f810)() ();
        }
        eax = 3;
        return eax;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806772b */
#include <stdint.h>
 
int32_t caml_ldexp_float (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    ldexp (ebp, eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049dc4 */
#include <stdint.h>
 
void ldexp (void) {
    ldexp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ff30 */
#include <stdint.h>
 
int32_t camlPervasives_print_char_1266 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x8076894));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804e470 */
#include <stdint.h>
 
int32_t camlUnix_entry (void) {
    *(0x80742b4) = loc.camlUnix__175;
    *(0x80742b0) = 0x8074bcc;
    *(0x80742ac) = 0x8074bbc;
    *(0x80742a8) = 0x8074bb0;
    *(0x80742a4) = 0x8074ba0;
    *(0x80742a0) = 0x8074b90;
    *(0x807429c) = 0x8074b84;
    *(0x8074290) = 0x8074b74;
    *(0x807428c) = 0x8074b64;
    *(0x8074288) = 0x8074b58;
    *(0x8074284) = 0x8074b4c;
    *(0x8074280) = 0x8074b40;
    *(0x807427c) = 0x8074b34;
    *(0x8074278) = 0x8074b28;
    *(0x8074234) = 0x8074b1c;
    *(0x8074230) = 0x8074b10;
    *(0x807422c) = 0x8074b00;
    *(0x8074228) = 0x8074af0;
    *(0x8074224) = 0x8074ae0;
    *(0x8074220) = 0x8074ad0;
    *(0x807421c) = 0x8074ac4;
    *(0x8074218) = 0x8074ab4;
    *(0x8074210) = 0x8074aa4;
    *(0x80741fc) = 0x8074a98;
    *(0x80741f8) = 0x8074a8c;
    *(0x80741f4) = 0x8074a80;
    *(0x80741f0) = 0x8074a74;
    *(0x80741ec) = 0x8074a68;
    *(0x80741e8) = 0x8074a5c;
    *(0x80741e4) = 0x8074a50;
    *(0x80741e0) = 0x8074a40;
    *(0x80741dc) = 0x8074a34;
    *(0x80741d8) = 0x8074a28;
    *(0x80741d4) = 0x8074a1c;
    *(0x80741d0) = 0x8074a10;
    *(0x80741cc) = 0x8074a04;
    *(0x80741c8) = 0x80749f8;
    *(0x80741c4) = 0x80749ec;
    *(0x80741c0) = 0x80749e0;
    *(0x80741bc) = 0x80749d0;
    *(0x80741b8) = 0x80749c4;
    *(0x80741b4) = 0x80749b4;
    *(0x80741b0) = 0x80749a8;
    *(0x80741ac) = 0x807499c;
    *(0x80741a8) = 0x8074990;
    *(0x80741a4) = 0x8074984;
    *(0x80741a0) = 0x8074978;
    *(0x807419c) = 0x807496c;
    *(0x8074198) = 0x8074960;
    *(0x8074194) = 0x8074954;
    *(0x807418c) = 0x8074948;
    *(0x8074188) = 0x807493c;
    *(0x8074184) = 0x807492c;
    *(0x8074180) = 0x807491c;
    *(0x807417c) = 0x807490c;
    *(0x8074178) = 0x80748fc;
    *(0x8074174) = 0x80748f0;
    *(0x8074170) = 0x80748e0;
    *(0x8074144) = 0x80748d0;
    *(0x8074140) = 0x80748c4;
    *(0x807413c) = 0x80748b8;
    *(0x8074138) = 0x80748ac;
    *(0x8074134) = 0x80748a0;
    *(0x8074130) = 0x8074894;
    *(0x807412c) = 0x8074888;
    *(0x8074128) = 0x807487c;
    *(0x8074124) = 0x8074870;
    *(0x8074120) = 0x8074864;
    *(0x807411c) = 0x8074854;
    *(0x8074118) = 0x8074848;
    *(0x8074114) = 0x807483c;
    *(0x8074110) = 0x8074830;
    *(0x807410c) = 0x8074824;
    *(0x8074108) = 0x8074814;
    *(0x8074104) = 0x8074808;
    *(0x8074100) = 0x80747f8;
    *(0x80740fc) = 0x80747ec;
    *(0x80740f8) = 0x80747dc;
    *(0x80740f4) = 0x80747cc;
    *(0x80740f0) = 0x80747bc;
    *(0x80740ec) = 0x80747ac;
    *(0x80740e8) = 0x807479c;
    *(0x80740e4) = 0x807478c;
    *(0x80740e0) = 0x8074780;
    *(0x80740d8) = 0x8074774;
    *(0x80740d4) = 0x8074768;
    *(0x80740d0) = 0x807475c;
    *(0x80740cc) = 0x8074750;
    *(0x80740c8) = 0x8074740;
    *(0x80740c4) = 0x8074730;
    *(0x80740c0) = 0x8074720;
    *(0x80740bc) = 0x8074714;
    *(0x80740b8) = 0x8074708;
    *(0x80740b4) = 0x80746fc;
    *(0x80740b0) = 0x80746f0;
    *(0x80740a0) = 0x80746e4;
    *(0x807409c) = 0x80746d4;
    *(0x807408c) = 0x80746c8;
    *(0x8074088) = 0x80746bc;
    *(0x8074084) = 0x80746b0;
    *(0x807407c) = 0x80746a0;
    *(0x8074078) = 0x8074694;
    *(0x8074074) = 0x8074688;
    *(0x8074070) = 0x8074678;
    *(0x807406c) = 0x8074668;
    *(0x8074068) = 0x8074658;
    *(0x8074064) = 0x8074648;
    *(0x8074060) = 0x8074638;
    *(0x807405c) = 0x807462c;
    *(0x8074058) = 0x8074620;
    *(0x8074050) = 0x8074614;
    eax = 0x1c;
    caml_allocN ();
    eax = eax + 4;
    *((eax - 4)) = 0x400;
    *(eax) = "Unix.Unix_error";
    *(loc.camlUnix) = eax;
    ebx = eax + 8;
    *((ebx - 4)) = 0x1000;
    eax = camlUnix;
    *(ebx) = eax;
    *((ebx + 4)) = 1;
    *((ebx + 8)) = 0x8074c44;
    *((ebx + 0xc)) = 0x8074c4c;
    eax = "Unix.Unix_error";
    camlCallback_register_exception_1034 ();
    eax = loc.camlUnix__60;
    *(0x8074054) = eax;
    *(0x8074090) = 1;
    *(0x8074094) = 3;
    *(0x8074098) = 5;
    eax = loc.camlUnix__59;
    *(0x80740a4) = eax;
    eax = loc.camlUnix__58;
    *(0x80740a8) = eax;
    eax = loc.camlUnix__57;
    *(0x80740ac) = eax;
    eax = loc.camlUnix__56;
    eax = 0x1c;
    caml_allocN ();
    eax = eax + 4;
    *((eax - 4)) = 0x1800;
    *(eax) = loc.camlUnix__50;
    *((eax + 4)) = 0x8074590;
    *((eax + 8)) = 0x80745a0;
    *((eax + 0xc)) = 0x80745b0;
    *((eax + 0x10)) = 0x80745bc;
    *((eax + 0x14)) = 0x80745c8;
    *(0x80740dc) = eax;
    eax = loc.camlUnix__49;
    *(0x80742b8) = eax;
    eax = loc.camlUnix__48;
    *(0x8074190) = eax;
    eax = loc.camlUnix__47;
    *(0x80742bc) = eax;
    eax = unix_inet_addr_of_string;
    eax = caml_c_call ("0.0.0.0");
    *(0x8074200) = eax;
    eax = unix_inet_addr_of_string;
    eax = caml_c_call ("127.0.0.1");
    *(0x8074204) = eax;
    eax = void (*0x804ea0a)() ();
    ecx = "45\a\b";
    ebx = *(eax);
    if (ebx == ecx) {
        eax = .comment;
    } else {
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = unix_inet_addr_of_string;
        eax = caml_c_call (loc.camlUnix__44);
    }
    *(0x8074208) = eax;
    eax = void (*0x804ea52)() ();
    ecx = "45\a\b";
    ebx = *(eax);
    if (ebx == ecx) {
        eax = .comment;
    } else {
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = unix_inet_addr_of_string;
        eax = caml_c_call (loc.camlUnix__43);
    }
    *(0x807420c) = eax;
    eax = loc.camlUnix__42;
    *(0x8074214) = eax;
    eax = loc.camlUnix__41;
    *(0x8074238) = eax;
    eax = loc.camlUnix__40;
    *(0x807423c) = eax;
    eax = loc.camlUnix__39;
    *(0x8074240) = eax;
    eax = loc.camlUnix__38;
    *(0x8074244) = eax;
    eax = 0x20;
    caml_allocN ();
    eax = eax + 4;
    *((eax - 4)) = 0x1c00;
    *(eax) = 1;
    *((eax + 4)) = 3;
    *((eax + 8)) = 5;
    *((eax + 0xc)) = 7;
    *((eax + 0x10)) = 9;
    *((eax + 0x14)) = 0x80744f0;
    *((eax + 0x18)) = 0x8074500;
    *(0x80742c0) = eax;
    eax = loc.camlUnix__35;
    *(0x8074248) = eax;
    eax = loc.camlUnix__34;
    *(0x807424c) = eax;
    eax = loc.camlUnix__33;
    *(0x8074250) = eax;
    eax = loc.camlUnix__32;
    *(0x8074254) = eax;
    eax = loc.camlUnix__31;
    *(0x8074258) = eax;
    eax = loc.camlUnix__30;
    *(0x807425c) = eax;
    eax = loc.camlUnix__29;
    *(0x8074260) = eax;
    eax = loc.camlUnix__28;
    *(0x8074264) = eax;
    eax = loc.camlUnix__27;
    *(0x8074268) = eax;
    eax = loc.camlUnix__26;
    *(0x80742c4) = eax;
    eax = loc.camlUnix__25;
    *(0x8074294) = eax;
    eax = loc.camlUnix__24;
    *(0x80742c8) = eax;
    eax = loc.camlUnix__23;
    *(0x8074298) = eax;
    eax = loc.camlUnix__22;
    *(0x8074080) = eax;
    eax = loc.camlUnix__21;
    *(0x80742cc) = eax;
    eax = loc.camlUnix__20;
    *(0x80742d0) = eax;
    eax = loc.camlUnix__19;
    *(0x80742d4) = eax;
    eax = loc.camlUnix__18;
    *(0x8074148) = eax;
    eax = loc.camlUnix__17;
    *(0x807414c) = eax;
    eax = 0xf;
    eax = camlHashtbl_create_1051 ();
    *(0x80742d8) = eax;
    eax = loc.camlUnix__16;
    *(0x80742dc) = eax;
    eax = loc.camlUnix__15;
    *(0x8074150) = eax;
    eax = loc.camlUnix__14;
    *(0x8074154) = eax;
    eax = loc.camlUnix__13;
    *(0x8074158) = eax;
    eax = loc.camlUnix__12;
    *(0x80742e0) = eax;
    eax = loc.camlUnix__11;
    *(0x807415c) = eax;
    eax = loc.camlUnix__10;
    *(0x80742e4) = eax;
    eax = loc.camlUnix__9;
    *(0x80742e8) = eax;
    eax = loc.camlUnix__8;
    *(0x8074160) = eax;
    eax = loc.camlUnix__7;
    *(0x8074164) = eax;
    eax = loc.camlUnix__6;
    *(0x8074168) = eax;
    eax = loc.camlUnix__5;
    *(0x807416c) = eax;
    eax = loc.camlUnix__4;
    *(0x807426c) = eax;
    eax = loc.camlUnix__3;
    *(0x8074270) = eax;
    eax = loc.camlUnix__2;
    *(0x80742ec) = eax;
    eax = camlUnix__1;
    *(0x8074274) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b230 */
#include <stdint.h>
 
int32_t caml_curry4_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry4_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804cb90 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_error_1671 (void) {
    eax = unix_getsockopt;
    caml_c_call (9);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058ae0 */
#include <stdint.h>
 
int32_t camlBuffer_add_channel_1090 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    *((esp + 8)) = ecx;
    if (ecx >= 1) {
        eax = .comment;
        if (ecx <= eax) {
            goto label_0;
        }
    }
    eax = "Buffer.add_channel";
    camlPervasives_invalid_arg_1012 ();
label_0:
    eax = *((esp + 4));
    edx = *((eax + 8));
    ecx = *((eax + 4));
    ebx = *((esp + 8));
    ecx = ecx + ebx - 1;
    if (ecx > edx) {
        camlBuffer_resize_1066 ();
    }
    eax = *((esp + 4));
    ecx = *((eax + 4));
    ebx = *(eax);
    eax = *(esp);
    edx = *((esp + 8));
    camlPervasives_really_input_1235 ();
    ebx = *((esp + 4));
    ecx = *((ebx + 4));
    eax = *((esp + 8));
    eax = ecx + eax - 1;
    *((ebx + 4)) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c470 */
#include <stdint.h>
 
int32_t camlUnix_fun_2758 (void) {
    eax = unix_getppid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a793 */
#include <stdint.h>
 
int32_t caml_deserialize_sint_1 (void) {
    edx = intern_src;
    eax = *(edx);
    edx++;
    *(obj.intern_src) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054fc0 */
#include <stdint.h>
 
int32_t camlList_combine_1226 (void) {
    int32_t var_4h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        if (ebx == 1) {
            goto label_1;
        }
        esi = *((ebx + 4));
        ecx = *(ebx);
        edx = *((eax + 4));
        ecx = *(eax);
        eax = edx;
        ebx = esi;
        eax = camlList_combine_1226 (ecx, ecx);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            eax = *((esp + 4));
            *((ebx + 4)) = eax;
            eax = ebx + 0xc;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            if (ebx == 1) {
                eax = 1;
                return eax;
            }
label_1:
            eax = "List.combine";
            void (*0x804f810)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fa0c */
#include <stdint.h>
 
int32_t unix_shutdown (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x137ec;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x2408));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = shutdown ();
    if (eax == -1) {
        eax = ebx - 0x2413;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049ee4 */
#include <stdint.h>
 
void shutdown (void) {
    shutdown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805edc8 */
#include <stdint.h>
 
uint32_t unix_pipe (void) {
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14430;
    eax = ebp - 0x10;
    *(esp) = eax;
    eax = pipe ();
    if (eax == -1) {
        eax = ebx - 0x2485;
        uerror (eax, 0);
    }
    caml_alloc_small (2, 0);
    edx = *((ebp - 0x10));
    edx = edx + edx + 1;
    *(eax) = edx;
    edx = *((ebp - 0xc));
    edx = edx + edx + 1;
    *((eax + 4)) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a794 */
#include <stdint.h>
 
void pipe (void) {
    pipe ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805eee4 */
#include <stdint.h>
 
int32_t unix_read (int32_t fildes, void * s1, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4028h;
    int32_t var_4024h;
    int32_t var_4020h;
    int32_t var_401ch;
    int32_t var_4008h;
    void * buf;
    size_t nbyte;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x14310;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4028)) = edx;
    edx = ebp - 0x4028;
    *(eax) = edx;
    *((ebp - 0x4020)) = 1;
    *((ebp - 0x4024)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x401c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    caml_enter_blocking_section ();
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    eax = ebp - 0x4008;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = read (eax, eax, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x2479;
        uerror (eax, 0);
    }
    eax = ebp - 0x4008;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    memmove (eax, eax, esi);
    edx = *((ebp - 0x4028));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a114 */
#include <stdint.h>
 
void read (void) {
    read ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a54a */
#include <stdint.h>
 
int32_t caml_output_value_to_block (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    eax = *((ebp + 0x10));
    *(obj.extern_userprovided_output) = eax;
    *(obj.extern_ptr) = eax;
    eax += *((ebp + 0x14));
    *(obj.extern_limit) = eax;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    extern_value ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8053650 */
#include <stdint.h>
 
int32_t camlList_rmap_f_1070 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_1;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = *((ecx + 0xc));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (eax, eax, ecx);
        ebx = eax;
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        *(eax) = ebx;
        ebx = *(esp);
        *((eax + 4)) = ebx;
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_1:
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069023 */
#include <stdint.h>
 
int32_t caml_putblock (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_20h;
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edx = *((ebp + 0xc));
    edi = *((ebp + 0x10));
    eax = *((ebx + 0x10));
    esi = *((ebx + 0xc));
    esi -= eax;
    if (edi < esi) {
        memmove (eax, edx, edi);
        *((ebx + 0x10)) += edi;
        eax = edi;
    } else {
        memmove (eax, edx, esi);
        eax = ebx + 0x34;
        *((ebp - 0x1c)) = eax;
        eax = *((ebx + 0xc));
        eax -= *((ebp - 0x1c));
        *((ebp - 0x20)) = eax;
        ecx = eax;
        edx = *((ebp - 0x1c));
        eax = *(ebx);
        eax = do_write ();
        edi = eax;
        if (*((ebp - 0x20)) > eax) {
            eax = *((ebp - 0x20));
            eax -= edi;
            eax = *((ebp - 0x1c));
            eax += edi;
            eax = *((ebp - 0x1c));
            memmove (eax, eax, eax);
        }
        edx = edi;
        edx >>= 0x1f;
        *((ebx + 4)) += edi;
        *((ebx + 8)) += edx;
        edi = -edi;
        edi += *((ebx + 0xc));
        *((ebx + 0x10)) = edi;
        eax = esi;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80669bc */
#include <stdint.h>
 
int32_t caml_int64_to_nativeint (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c680 */
#include <stdint.h>
 
uint32_t camlCallback_register_exception_1034 (void) {
    ecx = eax;
    eax = *((ebx - 4));
    if (eax == 0xfe) {
        goto label_0;
    }
    eax = *(ebx);
    while (1) {
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(eax) = fp_stack[0];
            fp_stack--;
            eax = caml_register_named_value;
            caml_c_call (ecx);
            return eax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068c8a */
#include <stdint.h>
 
uint32_t caml_ml_input_scan_line (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = caml_input_scan_line (ebx);
    edi = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806787a */
#include <stdint.h>
 
int32_t caml_div_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] /= *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c150 */
#include <stdint.h>
 
int32_t camlUnix_fun_2670 (void) {
    eax = unix_lockf;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ab00 */
#include <stdint.h>
 
int32_t caml_curry9_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fc26 */
#include <stdint.h>
 
int32_t unix_sigprocmask (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_118h;
    int32_t var_98h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x135c7;
    eax = *((ebp + 8));
    eax >>= 1;
    edi = *((ebx + eax*4 - 0x23d8));
    esi = ebp - 0x98;
    edx = esi;
    eax = *((ebp + 0xc));
    decode_sigset ();
    caml_enter_blocking_section ();
    eax = ebp - 0x118;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = edi;
    eax = sigprocmask ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x23e6;
        uerror (eax, 0);
    }
    eax = ebp - 0x118;
    encode_sigset ();
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a5d4 */
#include <stdint.h>
 
void sigprocmask (void) {
    sigprocmask ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806022b */
#include <stdint.h>
 
int32_t unix_setsockopt (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12fcd;
    eax = *((ebp + 8));
    eax >>= 1;
    edx = *((ebp + 0x10));
    edx >>= 1;
    edx <<= 3;
    edx += *((ebx + eax*4 - 0x138));
    ecx = *((ebp + 0x14));
    ecx = *((ebp + 0xc));
    ecx = *((edx + 4));
    edx = *(edx);
    eax = *((ebx + eax*4 - 0x124));
    unix_setsockopt_aux (ecx, eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060130 */
#include <stdint.h>
 
int32_t unix_setsockopt_aux (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t sockfd, int32_t arg_1ch) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_10h;
    int32_t var_bp_ch;
    int32_t level;
    int32_t optname;
    void * optval;
    socklen_t optlen;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x130c7;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *((ebp + 0x1c));
    if (eax != 2) {
        if (eax >= 2) {
            if (eax != 3) {
                goto label_0;
            }
            edx >>= 1;
            *((ebp - 0x10)) = edx;
            eax = 4;
        } else {
        } else {
            ecx = edx;
            ecx ^= 1;
            ecx &= 1;
            *((ebp - 0x10)) = ecx;
            eax = 8;
            if (ecx == 0) {
                goto label_1;
            }
            eax = *(edx);
            eax >>= 1;
            *((ebp - 0xc)) = eax;
            eax = 8;
            goto label_1;
        }
        *(fp_stack--) = *(edx);
        eax = *((ebp - 0x1a));
        ah = 0xc;
        *((ebp - 0x1c)) = ax;
        *((ebp - 0x20)) = fp_stack[0];
        eax = *((ebp - 0x20));
        *((ebp - 0x10)) = eax;
        *((ebp - 0x20)) = eax;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] -= fp_stack[1];
        fp_stack++;
        fp_stack[0] *= *((ebx - 0x251c));
        *((ebp - 0xc)) = fp_stack[0];
        fp_stack--;
        eax = 8;
        goto label_1;
label_0:
        eax = unix_error (0x16, esi, 0);
    }
label_1:
    eax = ebp - 0x10;
    eax = *((ebp + 0x14));
    eax = *((ebp + 0x10));
    eax = *((ebp + 0x18));
    eax >>= 1;
    eax = setsockopt (eax, eax, eax);
    if (eax == -1) {
        uerror (esi, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056630 */
#include <stdint.h>
 
int32_t loc_camlHashtbl_code_begin (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 8));
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0x10));
        eax = caml_apply2 (ecx, ecx, ebx);
        if (eax != 1) {
            eax = *((esp + 8));
            eax = *((eax + 0xc));
            *(eax) += 0xfffffffe;
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_code_begin ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            *((eax + 8)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063554 */
#include <stdint.h>
 
int32_t caml_set_allocation_policy (int32_t arg_8h) {
    eax = *((ebp + 8));
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
    } else {
        *(obj.fl_prev) = 0x807ca48;
        goto label_0;
    }
    *(obj.flp_size) = 0;
    *(obj.beyond) = 0;
label_0:
    *(obj.caml_allocation_policy) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c9a0 */
#include <stdint.h>
 
int32_t camlUnix_send_1570 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ebx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ebx + ebp));
        ebp -= edi;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = unix_send;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.send";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80670e0 */
#include <stdint.h>
 
int32_t caml_int32_mul (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax *= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058a60 */
#include <stdint.h>
 
int32_t camlBuffer_add_string_1082 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 0xc)) = eax;
    edx = ebx;
    *(esp) = edx;
    ecx = *((edx - 4));
    ecx >>= 0xa;
    ebx = ecx*4 - 1;
    ecx = *((edx + ebx));
    ebx -= ecx;
    ebx = ebx + ebx + 1;
    *((esp + 4)) = ebx;
    ecx = *((eax + 4));
    edx = ecx + ebx - 1;
    *((esp + 8)) = edx;
    ecx = *((eax + 8));
    if (edx > ecx) {
        camlBuffer_resize_1066 ();
    }
    eax = *((esp + 0xc));
    edx = *((eax + 4));
    ecx = *(eax);
    ebx = 1;
    eax = *(esp);
    esi = *((esp + 4));
    camlString_blit_1056 ();
    ebx = *((esp + 8));
    eax = *((esp + 0xc));
    *((eax + 4)) = ebx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058860 */
#include <stdint.h>
 
int32_t camlBuffer_resize_1066 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = eax;
    *((esp + 4)) = ecx;
    edx = *((ecx + 8));
label_0:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    eax = eax + 4;
    *((esp + 8)) = eax;
    *((eax - 4)) = 0x400;
    *(eax) = edx;
    do {
        esi = *(eax);
        edx = *((ecx + 4));
        edx = edx + ebx - 1;
        if (edx <= esi) {
            goto label_2;
        }
        edx = *(eax);
        edx >>= 1;
        edx = edx*4 + 1;
        *(eax) = edx;
    } while (1);
label_2:
    esi = .comment;
    edx = *(eax);
    if (edx > esi) {
        edx = .comment;
        ecx = *((ecx + 4));
        ebx = ecx + ebx - 1;
        if (ebx <= edx) {
            ebx = .comment;
            *(eax) = ebx;
        } else {
            eax = "Buffer.add: cannot grow buffer";
            camlPervasives_failwith_1010 ();
        }
    }
    eax = *((esp + 8));
    eax = caml_create_string;
    eax = caml_c_call (*(eax));
    ecx = eax;
    eax = *((esp + 4));
    esi = *((eax + 4));
    edx = 1;
    ebx = 1;
    eax = *(eax);
    camlString_blit_1056 (ecx);
    eax = *(esp);
    ebx = *((esp + 8));
    caml_modify (ebx, eax);
    eax = *((esp + 8));
    eax = *(eax);
    *((ebx + 8)) = eax;
    eax = 1;
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066bb1 */
#include <stdint.h>
 
int32_t caml_int64_of_nativeint (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = eax;
    edx >>= 0x1f;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060aaa */
#include <stdint.h>
 
int32_t unix_tcdrain (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1274e;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcdrain ();
    if (eax == -1) {
        eax = ebx - 0x22e7;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a124 */
#include <stdint.h>
 
void tcdrain (void) {
    tcdrain ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064cf4 */
#include <stdint.h>
 
int32_t caml_free_for_heap (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax - 0x10));
    free (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060f60 */
#include <stdint.h>
 
uint32_t unix_times (void) {
    int32_t var_60h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x12290;
    eax = caml_alloc_small (8, 0xfe);
    esi = eax;
    edi = ebp - 0x60;
    *((esp + 4)) = edi;
    *(esp) = 0;
    getrusage ();
    *(fp_stack--) = *((ebp - 0x60));
    *(fp_stack--) = *((ebp - 0x5c));
    eax = ebx - 0x21d4;
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(esi) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x58));
    *(fp_stack--) = *((ebp - 0x54));
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((esi + 8)) = fp_stack[0];
    fp_stack--;
    *((esp + 4)) = edi;
    *(esp) = 0xffffffff;
    getrusage ();
    *(fp_stack--) = *((ebp - 0x60));
    *(fp_stack--) = *((ebp - 0x5c));
    eax = ebx - 0x21d4;
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((esi + 0x10)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x58));
    *(fp_stack--) = *((ebp - 0x54));
    fp_stack[0] /= *(eax);
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((esi + 0x18)) = fp_stack[0];
    fp_stack--;
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a154 */
#include <stdint.h>
 
void getrusage (void) {
    getrusage ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d230 */
#include <stdint.h>
 
int32_t unix_getaddrinfo (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_138h;
    int32_t var_134h;
    void * s1;
    uint32_t var_12ch;
    int32_t var_124h;
    int32_t var_b4h;
    int32_t var_b0h;
    int32_t var_ach;
    int32_t var_a8h;
    int32_t var_a4h;
    int32_t var_a0h;
    int32_t var_94h;
    int32_t var_90h;
    int32_t var_8ch;
    int32_t var_88h;
    int32_t var_84h;
    int32_t var_80h;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_64h;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    char * src;
    size_t n;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x15fc3;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x138)) = edx;
    *((ebp - 0x38)) = edx;
    edx = ebp - 0x38;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 3;
    ecx = ebp + 8;
    *((ebp - 0x2c)) = ecx;
    ecx = ebp + 0xc;
    *((ebp - 0x28)) = ecx;
    ecx = ebp + 0x10;
    *((ebp - 0x24)) = ecx;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x40)) = 0;
    *((ebp - 0x44)) = 0;
    *((ebp - 0x64)) = edx;
    edx = ebp - 0x64;
    *(eax) = edx;
    *((ebp - 0x5c)) = 1;
    *((ebp - 0x60)) = 3;
    eax = ebp - 0x3c;
    *((ebp - 0x58)) = eax;
    eax = ebp - 0x40;
    *((ebp - 0x54)) = eax;
    eax = ebp - 0x44;
    *((ebp - 0x50)) = eax;
    eax = *((ebp + 8));
    eax = caml_string_length (eax);
    esi = 0;
    if (eax != 0) {
        eax++;
        eax = caml_stat_alloc (eax);
        esi = eax;
        eax = *((ebp + 8));
        strcpy (esi, eax);
    }
    eax = *((ebp + 0xc));
    eax = caml_string_length (eax);
    edi = 0;
    if (eax != 0) {
        eax++;
        eax = caml_stat_alloc (eax);
        edi = eax;
        eax = *((ebp + 0xc));
        strcpy (edi, eax);
    }
    ecx = ebp - 0x84;
    edx = 0;
    eax = 0;
    do {
        *((ecx + eax)) = edx;
        eax += 4;
    } while (eax < 0x20);
    *((ebp - 0x80)) = 0;
    eax = *((ebp + 0x10));
    if ((al & 1) != 0) {
        goto label_0;
    }
    ecx = *((ebx - 0x1c));
    do {
        eax = *(eax);
        *((ebp - 0x40)) = eax;
        if ((al & 1) == 0) {
            edx = *((eax - 4));
            if (dl != 1) {
                if (dl >= 1) {
                    if (dl != 2) {
                        goto label_1;
                    }
                    eax = *(eax);
                    eax >>= 1;
                    edx = *((ebx - 0x20));
                    eax = *((edx + eax*4));
                    *((ebp - 0x80)) = eax;
                } else {
                } else {
                    eax = *(eax);
                    eax >>= 1;
                    eax = *((ecx + eax*4));
                    *((ebp - 0x7c)) = eax;
                    goto label_1;
                }
            }
            eax = *(eax);
            eax >>= 1;
            *((ebp - 0x78)) = eax;
        } else {
            eax >>= 1;
            if (eax != 1) {
                if (eax != 2) {
                    if (eax != 0) {
                        goto label_1;
                    }
                    *((ebp - 0x84)) |= 4;
                    *((ebp - 0x84)) |= 2;
                } else {
                } else {
                    *((ebp - 0x84)) |= 1;
                }
            }
        }
label_1:
        eax = *((ebp + 0x10));
        eax = *((eax + 4));
        *((ebp + 0x10)) = eax;
    } while ((al & 1) == 0);
label_0:
    caml_enter_blocking_section ();
    eax = ebp - 0x88;
    *((esp + 0xc)) = eax;
    eax = ebp - 0x84;
    *((esp + 8)) = eax;
    *((esp + 4)) = edi;
    *(esp) = esi;
    eax = getaddrinfo ();
    *((ebp - 0x12c)) = eax;
    caml_leave_blocking_section ();
    if (esi != 0) {
        caml_stat_free (esi);
    }
    if (edi != 0) {
        caml_stat_free (edi);
    }
    *((ebp - 0x3c)) = 1;
    if (*((ebp - 0x12c)) != 0) {
        goto label_2;
    }
    esi = *((ebp - 0x88));
    if (esi == 0) {
        goto label_3;
    }
    ecx = ebp - 0xb4;
    *((ebp - 0x134)) = ecx;
    do {
        eax = *((ebx - 0x18));
        eax = *(eax);
        *((ebp - 0x12c)) = eax;
        *((ebp - 0x8c)) = 0;
        *((ebp - 0x90)) = 0;
        *((ebp - 0x94)) = 0;
        *((ebp - 0xb4)) = eax;
        ecx = *((ebp - 0x134));
        edx = *((ebx - 0x18));
        *(edx) = ecx;
        *((ebp - 0xac)) = 1;
        *((ebp - 0xb0)) = 3;
        eax = ebp - 0x8c;
        *((ebp - 0xa8)) = eax;
        eax = ebp - 0x90;
        *((ebp - 0xa4)) = eax;
        eax = ebp - 0x94;
        *((ebp - 0xa0)) = eax;
        eax = *((esi + 0x10));
        edi = 0x70;
        if (eax <= 0x70) {
            edi = eax;
        }
        eax = ebp - 0x124;
        *((ebp - 0x130)) = eax;
        eax = *((esi + 0x14));
        edx = *((ebp - 0x130));
        memcpy (edx, eax, edi);
        ecx = *((ebp - 0x130));
        eax = alloc_sockaddr (ecx, edi, 0xffffffff);
        *((ebp - 0x90)) = eax;
        eax = *((esi + 0x18));
        edx = ebx - 0x147c;
        if (eax == 0) {
            eax = edx;
        }
        eax = caml_copy_string (eax);
        *((ebp - 0x94)) = eax;
        eax = caml_alloc_small (5, 0);
        edi = eax;
        *((ebp - 0x8c)) = eax;
        eax = *((ebx - 0x20));
        eax = *((esi + 4));
        eax = cst_to_constr (0, eax, 3);
        *(edi) = eax;
        edi = *((ebp - 0x8c));
        edi += 4;
        edx = *((ebx - 0x1c));
        eax = *((esi + 8));
        eax = cst_to_constr (0, edx, 4);
        *(edi) = eax;
        eax = *((esi + 0xc));
        edx = eax + eax + 1;
        eax = *((ebp - 0x8c));
        *((eax + 8)) = edx;
        edx = *((ebp - 0x90));
        eax = *((ebp - 0x8c));
        *((eax + 0xc)) = edx;
        edx = *((ebp - 0x94));
        eax = *((ebp - 0x8c));
        *((eax + 0x10)) = edx;
        eax = *((ebx - 0x18));
        ecx = *((ebp - 0x12c));
        *(eax) = ecx;
        eax = *((ebp - 0x8c));
        *((ebp - 0x44)) = eax;
        eax = caml_alloc_small (2, 0);
        *((ebp - 0x40)) = eax;
        edx = *((ebp - 0x44));
        *(eax) = edx;
        edx = *((ebp - 0x3c));
        eax = *((ebp - 0x40));
        *((eax + 4)) = edx;
        eax = *((ebp - 0x40));
        *((ebp - 0x3c)) = eax;
        esi = *((esi + 0x1c));
    } while (esi != 0);
label_3:
    eax = *((ebp - 0x88));
    *(esp) = eax;
    freeaddrinfo ();
label_2:
    eax = *((ebx - 0x18));
    edx = *((ebp - 0x138));
    *(eax) = edx;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c9c4 */
#include <stdint.h>
 
int32_t unix_chmod (char * path, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t mode;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1682f;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = chmod (esi, eax);
    if (eax == -1) {
        eax = ebx - 0x25af;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a104 */
#include <stdint.h>
 
void chmod (void) {
    chmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062fba */
#include <stdint.h>
 
int32_t caml_ext_table_add (int32_t arg_8h, char * arg_ch) {
    int32_t var_4h;
    ebx = *((ebp + 8));
    eax = *((ebx + 4));
    if (*(ebx) >= eax) {
        edx = eax + eax;
        *((ebx + 4)) = edx;
        eax <<= 3;
        eax = *((ebx + 8));
        eax = caml_stat_resize (eax, eax);
        *((ebx + 8)) = eax;
    }
    eax = *(ebx);
    edx = *((ebx + 8));
    ecx = *((ebp + 0xc));
    *((edx + eax*4)) = ecx;
    *(ebx)++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064cbe */
#include <stdint.h>
 
int32_t caml_stat_resize (void * ptr, int32_t arg_ch) {
    size_t size;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = realloc (eax, eax);
    if (eax == 0) {
        caml_raise_out_of_memory ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049f24 */
#include <stdint.h>
 
void realloc (void) {
    realloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80667e7 */
#include <stdint.h>
 
int32_t caml_nativeint_of_float (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_ah;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0xa));
    ah = 0xc;
    *((ebp - 0xc)) = ax;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_nativeint ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059360 */
#include <stdint.h>
 
int32_t camlPrintf_cont_t_1363 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = eax;
    *((esp + 4)) = ecx;
    *((esp + 8)) = edx;
    eax = *((edx + 0x2c));
    if (eax != 1) {
        eax = 1;
        ecx = *(ebx);
        eax = void (*ecx)() ();
        ebx = eax;
        eax = *((esp + 8));
        ecx = *((eax + 0x34));
        eax = *((eax + 0x3c));
        caml_apply2 ();
    } else {
        eax = *((edx + 0x3c));
        ecx = *(ebx);
        void (*ecx)() ();
    }
    ecx = *((esp + 8));
    ecx += 0xffffffd0;
    eax = *(esp);
    ebx = *((esp + 4));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bfb0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2620 (void) {
    eax = unix_getlogin;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061c8b */
#include <stdint.h>
 
int32_t caml_raise_with_args (void) {
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_4h;
    esi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    eax = caml_local_roots;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x48)) = eax;
    eax = ebp - 0x48;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x40)) = esi;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x3c)) = ebx;
    eax = esi + 1;
    caml_alloc_small (ebx, esi);
    edx = *((ebp + 8));
    *(eax) = edx;
    if (esi <= 0) {
        goto label_0;
    }
    edx = 0;
    do {
        ecx = *((ebx + edx*4));
        *((eax + edx*4 + 4)) = ecx;
        edx++;
    } while (edx != esi);
label_0:
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e4d3 */
#include <stdint.h>
 
int32_t unix_gmtime (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_1ah;
    time_t * timer;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14d25;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0xc)) = fp_stack[0];
    fp_stack--;
    eax = ebp - 0xc;
    eax = gmtime (eax);
    if (eax == 0) {
        eax = ebx - 0x24fb;
        unix_error (0x16, eax, 0);
    }
    alloc_tm ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a764 */
#include <stdint.h>
 
void gmtime (void) {
    gmtime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c051 */
#include <stdint.h>
 
uint32_t caml_sys_open (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    char * src;
    int32_t var_8h;
    edi = caml_local_roots;
    *((ebp - 0x38)) = edi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 3;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = *((ebp + 8));
    eax = caml_string_length (ebx, esi, edi);
    eax++;
    eax = caml_stat_alloc (eax);
    ebx = eax;
    eax = *((ebp + 8));
    strcpy (ebx, eax);
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, 0x807cae0);
    esi = eax;
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebp - 0x3c)) = eax;
    caml_enter_blocking_section ();
    eax = *((ebp - 0x3c));
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = open64 ();
    esi = eax;
    if (eax != -1) {
        *((esp + 8)) = 1;
        *((esp + 4)) = 2;
        *(esp) = eax;
        fcntl ();
        caml_leave_blocking_section ();
        caml_stat_free (ebx);
    } else {
        caml_leave_blocking_section ();
        caml_stat_free (ebx);
        eax = *((ebp + 8));
        caml_sys_error (eax);
    }
    *(obj.caml_local_roots) = edi;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80568e0 */
#include <stdint.h>
 
int32_t camlHashtbl_insert_bucket_1068 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_0;
        }
        edx = *((eax + 8));
        ecx = *((eax + 4));
        ecx = *(eax);
        eax = edx;
        camlHashtbl_insert_bucket_1068 (ebx, ecx, ecx);
    } while (1);
    eax = *(esp);
    ebx = *((eax + 0xc));
    ebx >>= 1;
    if (ebx != 0) {
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 8));
        eax = void (*ecx)(uint32_t) (ebx);
        eax >>= 1;
        ecx = *((esp + 0xc));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    ebx = *(esp);
    ecx = *((ebx + 0x10));
    eax = *((ecx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_1;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            esi = *((esp + 8));
            *(eax) = esi;
            esi = *((esp + 4));
            *((eax + 4)) = esi;
            esi = *((ebx + 0x10));
            ebx = *((esi - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_2;
            }
            ebx = *((esi + edx*2 - 2));
            *((eax + 8)) = ebx;
            caml_modify (ecx + edx*2 - 2, eax);
            eax = 1;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_ml_array_bound_error ();
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054ee0 */
#include <stdint.h>
 
int32_t camlList_partition_1212 (void) {
    esi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x80537f0;
            *((edx + 0xc)) = esi;
            ebx = 1;
            eax = 1;
            void (*0x80537f0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804af80 */
#include <stdint.h>
 
int32_t caml_curry6_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c420 */
#include <stdint.h>
 
int32_t camlUnix_fun_2750 (void) {
    eax = caml_ml_open_descriptor_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806672a */
#include <stdint.h>
 
int32_t caml_int64_float_of_bits (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052740 */
#include <stdint.h>
 
int32_t camlArray_map_1105 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ecx = eax;
    eax = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    if (eax == 1) {
        eax = loc.camlArray__24;
        return eax;
    }
    *(esp) = eax;
    *((esp + 4)) = ebx;
    *((esp + 8)) = ecx;
    eax = *((ebx - 4));
    if (eax != 0xfe) {
        eax = *(ebx);
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(eax) = fp_stack[0];
        fp_stack--;
    }
    edx = *(ecx);
    ebx = ecx;
    eax = void (*edx)() ();
    eax = *((esp + 4));
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    esi = eax;
    ebx = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ebx > eax) {
        goto label_3;
    }
    *((esp + 0xc)) = eax;
    *((esp + 0x10)) = ebx;
    *(esp) = esi;
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            eax = *((ecx + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 8));
        ecx = *(ebx);
        eax = void (*ecx)() ();
        esi = *(esp);
        ebx = *((esi - 4));
        if (ebx != 0xfe) {
            ebx = *((esp + 0x14));
            eax = caml_modify (esi + ebx*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            ebx = *((esp + 0x10));
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebx;
        ebx += 2;
        *((esp + 0x10)) = ebx;
        eax = *((esp + 0xc));
    } while (ecx != eax);
label_3:
    eax = esi;
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fe90 */
#include <stdint.h>
 
int32_t camlPervasives_input_line_1241 (void) {
    edx = eax;
    ebx = loc.camlPervasives__86;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x804f490;
            *((ecx + 0xc)) = edx;
            *((ecx + 0x10)) = ebx;
            ebx = 1;
            eax = 1;
            void (*0x804f490)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b0d0 */
#include <stdint.h>
 
int32_t caml_curry5 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064c30 */
#include <stdint.h>
 
int32_t caml_page_table_initialize (void) {
    eax = 0;
    edx = caml_page_table;
    do {
        *((edx + eax*4)) = obj.caml_page_table_empty;
        eax++;
    } while (eax != 0x200);
    ax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bff0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2628 (void) {
    eax = unix_setgid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062bbe */
#include <stdint.h>
 
uint32_t caml_install_signal_handler (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    eax = ebp - 0x3c;
    *((ebp - 0x50)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = caml_convert_signal_number (ebx, esi, edi);
    esi = eax;
    if (eax > 0x40) {
        eax = caml_invalid_argument (0x80711a8);
    }
    ecx = *((ebp + 0xc));
    edi = ecx - 1;
    edx = 2;
    if (edi <= 2) {
        edx = *((ecx*4 + 0x8071230));
    }
    eax = caml_set_signal_action (eax, edx);
    if (eax != 1) {
        if (eax != 2) {
            if (eax == 0) {
                *((ebp - 0x3c)) = 1;
            } else {
                *((ebp - 0x3c)) = 3;
            } else {
            }
            eax = caml_alloc_small (1, 0);
            *((ebp - 0x3c)) = eax;
            edx = caml_signal_handlers;
            edx = *((edx + esi*4));
            *(eax) = edx;
        } else {
        }
        caml_sys_error (1);
    }
    if ((*((ebp + 0xc)) & 1) == 0) {
        if (*(obj.caml_signal_handlers) == 0) {
            eax = caml_alloc (0x41, 0);
            *(obj.caml_signal_handlers) = eax;
            caml_register_global_root (obj.caml_signal_handlers);
        }
        eax = *((ebp + 0xc));
        eax = *(eax);
        esi <<= 2;
        esi += *(obj.caml_signal_handlers);
        caml_modify (esi, eax);
    }
    caml_process_pending_signals ();
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065f00 */
#include <stdint.h>
 
int32_t caml_equal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80806c0) {
        eax = compare_free_stack ();
    }
    eax -= eax;
    eax &= 2;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065dc2 */
#include <stdint.h>
 
int32_t caml_greaterequal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80806c0) {
        compare_free_stack ();
    }
    eax = ebx;
    eax >>= 0x1f;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b080 */
#include <stdint.h>
 
int32_t caml_curry6_5 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *(esp) = eax;
    eax = *((ebx + 0xc));
    ecx = *((eax + 0xc));
    edi = *((ecx + 0xc));
    ebp = *((edi + 0xc));
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    ebx = *((ebx + 8));
    *((esp + 0xc)) = ebx;
    esi = *((eax + 8));
    ecx = *((ecx + 8));
    ebx = *((edi + 8));
    eax = *((ebp + 8));
    edx = *((edx + 8));
    *((esp + 8)) = edx;
    edx = esi;
    esi = *((esp + 0xc));
    edi = *(esp);
    ebp = *((esp + 4));
    *(loc.caml_extra_params) = ebp;
    ebp = *((esp + 8));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c9f0 */
#include <stdint.h>
 
int32_t camlUnix_sendto_1576 (void) {
    int32_t var_14h;
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        *(esp) = eax;
        eax = *((ebx - 4));
        eax >>= 0xa;
        ebp = eax*4 - 1;
        eax = *((ebx + ebp));
        ebp -= eax;
        ebp <<= 1;
        ebp -= edx;
        ebp += 2;
        if (ecx > ebp) {
            goto label_0;
        }
        eax = *((esp + 0x14));
        eax = unix_sendto_native;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.sendto";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c320 */
#include <stdint.h>
 
int32_t camlUnix_fun_2720 (void) {
    eax = unix_fchmod;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066a34 */
#include <stdint.h>
 
int32_t caml_int64_of_string (int32_t arg_8h) {
    int32_t var_60h;
    uint32_t var_5ch;
    int32_t var_50h;
    int32_t var_4ch;
    uint32_t var_3ch;
    int32_t var_38h;
    uint32_t var_34h;
    uint32_t var_30h;
    uint32_t var_2ch;
    uint32_t var_20h;
    uint32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = ebp - 0x1c;
    edx = ebp - 0x20;
    eax = *((ebp + 8));
    eax = parse_sign_and_base (ebx, esi, edi);
    edi = eax;
    eax = *((ebp - 0x20));
    *((ebp - 0x38)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((ebp - 0x30)) = eax;
    *((ebp - 0x2c)) = edx;
    eax = _udivdi3 (edx, 0xffffffff, eax);
    *((ebp - 0x3c)) = eax;
    *((ebp - 0x34)) = edx;
    eax = *(edi);
    eax = parse_digit ();
    ebx = eax;
    if (eax >= 0) {
        if (*((ebp - 0x38)) > eax) {
            goto label_0;
        }
    }
    eax = caml_failwith ("int_of_string");
label_0:
    esi = eax;
    esi >>= 0x1f;
    edi++;
    do {
        eax = *(edi);
        if (al != 0x5f) {
            eax = (int32_t) al;
            eax = parse_digit ();
            *((ebp - 0x4c)) = eax;
            if (eax < 0) {
                goto label_1;
            }
            if (*((ebp - 0x38)) <= eax) {
                goto label_1;
            }
            if (esi >= *((ebp - 0x34))) {
                if (esi <= *((ebp - 0x34))) {
                    if (ebx <= *((ebp - 0x3c))) {
                        goto label_2;
                    }
                }
                caml_failwith ("int_of_string");
            }
label_2:
            edx = *((ebp - 0x30));
            edx *= esi;
            ecx = *((ebp - 0x2c));
            ecx *= ebx;
            edx += ecx;
            *((ebp - 0x50)) = edx;
            eax = *((ebp - 0x30));
            edx:eax = eax * ebx;
            ebx = eax;
            esi = edx;
            esi += *((ebp - 0x50));
            eax = *((ebp - 0x4c));
            edx = *((ebp - 0x4c));
            edx >>= 0x1f;
            *((ebp - 0x60)) = eax;
            *((ebp - 0x5c)) = edx;
            ebx += eax;
            esi += edx;
            if (edx < esi) {
                goto label_3;
            }
            if (*((ebp - 0x5c)) <= esi) {
                if (eax <= ebx) {
                    goto label_3;
                }
            }
            caml_failwith ("int_of_string");
        }
label_3:
        edi++;
    } while (1);
label_1:
    *((ebp - 0x30)) = ebx;
    *((ebp - 0x2c)) = esi;
    edx = *((ebp + 8));
    eax = caml_string_length (edx);
    eax += *((ebp + 8));
    if (edi != eax) {
        caml_failwith ("int_of_string");
    }
    if (*((ebp - 0x20)) == 0xa) {
        eax = 0xffffffff;
        edx = 0x7fffffff;
        if (*((ebp - 0x1c)) < 0) {
            eax = 0;
            edx = 0x80000000;
        }
        if (edx > *((ebp - 0x2c))) {
            goto label_4;
        }
        if (edx >= *((ebp - 0x2c))) {
            if (eax >= *((ebp - 0x30))) {
                goto label_4;
            }
        }
        caml_failwith ("int_of_string");
    }
label_4:
    if (*((ebp - 0x1c)) < 0) {
        ebx = *((ebp - 0x30));
        esi = *((ebp - 0x2c));
        ebx = -ebx;
        esi += 0;
        esi = -esi;
    }
    caml_copy_int64 (ebx, esi);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c290 */
#include <stdint.h>
 
int32_t camlPrintf_bprintf_1400 (void) {
    ebx = eax;
    eax = loc.camlPrintf__41;
    return camlPrintf_kbprintf_1397 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bfd0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2624 (void) {
    eax = unix_setgroups;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e35d */
#include <stdint.h>
 
int32_t unix_mktime (int32_t arg_8h) {
    int32_t var_6ch;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    tm * timeptr;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14e9a;
    eax = *((ebp + 8));
    *((ebp - 0x38)) = 1;
    *((ebp - 0x3c)) = 1;
    edx = *((ebx - 0x18));
    ecx = *(edx);
    *((ebp - 0x5c)) = ecx;
    ecx = ebp - 0x5c;
    *(edx) = ecx;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 2;
    edx = ebp - 0x38;
    *((ebp - 0x50)) = edx;
    edx = ebp - 0x3c;
    *((ebp - 0x4c)) = edx;
    edx = *(eax);
    edx >>= 1;
    *((ebp - 0x34)) = edx;
    edx = *((eax + 4));
    edx >>= 1;
    *((ebp - 0x30)) = edx;
    edx = *((eax + 8));
    edx >>= 1;
    *((ebp - 0x2c)) = edx;
    edx = *((eax + 0xc));
    edx >>= 1;
    *((ebp - 0x28)) = edx;
    edx = *((eax + 0x10));
    edx >>= 1;
    *((ebp - 0x24)) = edx;
    edx = *((eax + 0x14));
    edx >>= 1;
    *((ebp - 0x20)) = edx;
    edx = *((eax + 0x18));
    edx >>= 1;
    *((ebp - 0x1c)) = edx;
    eax = *((eax + 0x1c));
    eax >>= 1;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x14)) = 0xffffffff;
    eax = ebp - 0x34;
    eax = mktime (eax);
    esi = eax;
    if (eax == -1) {
        eax = ebx - 0x250c;
        unix_error (0x22, eax, 0);
    }
    eax = ebp - 0x34;
    eax = alloc_tm ();
    *((ebp - 0x38)) = eax;
    *((ebp - 0x6c)) = esi;
    *(fp_stack--) = *((ebp - 0x6c));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x3c)) = eax;
    caml_alloc_small (2, 0);
    edx = *((ebp - 0x3c));
    *(eax) = edx;
    edx = *((ebp - 0x38));
    *((eax + 4)) = edx;
    ecx = *((ebp - 0x5c));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a344 */
#include <stdint.h>
 
void mktime (void) {
    mktime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ca18 */
#include <stdint.h>
 
int32_t unix_chown (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x167db;
    esi = *((ebp + 8));
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = chown ();
    if (eax == -1) {
        eax = ebx - 0x25a8;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a5e4 */
#include <stdint.h>
 
void chown (void) {
    chown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a090 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1584 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = ebx;
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = edx;
    *((esp + 4)) = esi;
    *(esp) = edi;
    eax = caml_make_vect;
    eax = caml_c_call (0xb);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0x14));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0x14));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 0x10));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 0x10));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 0xc));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 7) {
            goto label_6;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 0xc;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 7) {
            goto label_7;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 0x18)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 9) {
            goto label_8;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 0x10;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 9) {
            goto label_9;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x20)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b540)() ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805dbb8 */
#include <stdint.h>
 
uint32_t unix_getlogin (void) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15640;
    eax = getlogin ();
    if (eax == 0) {
        eax = ebx - 0x2540;
        eax = unix_error (2, eax, 0);
    }
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a064 */
#include <stdint.h>
 
void getlogin (void) {
    getlogin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054d10 */
#include <stdint.h>
 
int32_t camlList_remove_assoc_1189 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 8)) = ecx;
        ebx = *(ebx);
        *((esp + 4)) = ebx;
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 8));
        eax = camlList_remove_assoc_1189 ();
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 4));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068a01 */
#include <stdint.h>
 
int32_t caml_ml_channel_size_64 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_channel_size (eax);
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c360 */
#include <stdint.h>
 
int32_t camlUnix_fun_2728 (void) {
    eax = unix_unlink;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806471b */
#include <stdint.h>
 
int32_t caml_oldify_mopup (void) {
    uint32_t var_1ch;
    int32_t var_4h;
    goto label_1;
label_0:
    ebx = *(edi);
    esi = ebx + 4;
    eax = *(esi);
    *(obj.oldify_todo_list) = eax;
    eax = *(ebx);
    if ((al & 1) == 0) {
        if (eax >= *(obj.caml_young_end)) {
            goto label_2;
        }
        if (eax <= *(obj.caml_young_start)) {
            goto label_2;
        }
        caml_oldify_one (eax, ebx);
    }
label_2:
    ebx -= 4;
    eax = *(ebx);
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_1;
    }
    *((ebp - 0x1c)) = 1;
    do {
        edx = *((ebp - 0x1c));
        eax = *((edi + edx*4));
        if ((al & 1) == 0) {
            if (eax < *(obj.caml_young_end)) {
                if (eax <= *(obj.caml_young_start)) {
                    goto label_3;
                }
                eax = caml_oldify_one (eax, esi);
            }
        } else {
label_3:
            *(esi) = eax;
        }
        *((ebp - 0x1c))++;
        esi += 4;
        eax = *(ebx);
        eax >>= 0xa;
    } while (eax > *((ebp - 0x1c)));
label_1:
    edi = oldify_todo_list;
    if (edi != 0) {
        goto label_0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fc30 */
#include <stdint.h>
 
int32_t camlPervasives_output_value_1202 (void) {
    eax = caml_output_value;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056190 */
#include <stdint.h>
 
uint32_t camlString_contains_from_1132 (void) {
    esi = ebx;
    edx = ecx;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx + 1;
    if (esi >= 1) {
        if (esi > ebx) {
            goto label_0;
        }
        eax = void (*0x80561e0)() ();
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            eax = 1;
            return eax;
        }
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        ecx = esi;
        camlString_index_rec_1108 (*(obj.caml_exception_pointer));
        eax = 3;
        return eax;
    }
label_0:
    eax = "String.contains_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bfdd */
#include <stdint.h>
 
uint32_t caml_sys_remove (char * path) {
    ebx = *((ebp + 8));
    eax = unlink (ebx);
    if (eax != 0) {
        caml_sys_error (ebx);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80547e0 */
#include <stdint.h>
 
int32_t camlList_rev_map2_1099 (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x80536c0;
            *((edx + 0xc)) = esi;
            eax = 1;
            void (*0x80536c0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067910 */
#include <stdint.h>
 
int32_t caml_float_of_int (int32_t arg_8h) {
    int32_t var_ch;
    eax = *((ebp + 8));
    eax >>= 1;
    *((ebp - 0xc)) = eax;
    *(fp_stack--) = *((ebp - 0xc));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056130 */
#include <stdint.h>
 
void camlString_rindex_1125 (void) {
    ecx = ebx;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    edx = *((eax + ebx));
    ebx -= edx;
    ebx = ebx + ebx - 1;
    return camlString_rindex_rec_1121 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80676f1 */
#include <stdint.h>
 
int32_t caml_log10_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    log10 (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a594 */
#include <stdint.h>
 
void log10 (void) {
    log10 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80610b8 */
#include <stdint.h>
 
int32_t unix_umask (int32_t m) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12140;
    eax = *((ebp + 8));
    eax >>= 1;
    umask (eax);
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a304 */
#include <stdint.h>
 
void umask (void) {
    umask ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fcd4 */
#include <stdint.h>
 
int32_t caml_read_directory (int32_t arg_8h, int32_t arg_ch) {
    uint32_t var_1ch;
    char * src;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = opendir ();
    *((ebp - 0x1c)) = eax;
    eax = 0xffffffff;
    if (*((ebp - 0x1c)) == 0) {
        goto label_1;
    }
    esi = 0x8071f15;
    do {
label_0:
        eax = *((ebp - 0x1c));
        *(esp) = eax;
        eax = readdir64 ();
        if (eax == 0) {
            goto label_2;
        }
        ebx = eax + 0x13;
        edi = ebx;
        edx = *(ebx);
        ecx = *(esi);
        if (edx != ecx) {
            goto label_3;
        }
        ecx = *((ebx + 1));
    } while (cl == *((esi + 1)));
label_3:
    ecx = 0x8071f14;
    ecx = *(ecx);
    if (edx != ecx) {
        goto label_4;
    }
    edx = *((edi + 1));
    if (dl != *(0x8071f15)) {
        goto label_4;
    }
    edx = *((edi + 2));
    if (dl == *(0x8071f16)) {
        goto label_0;
    }
label_4:
    edi = eax + 0x13;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = caml_stat_alloc (ecx);
    edi = eax;
    strcpy (eax, ebx);
    eax = *((ebp + 0xc));
    caml_ext_table_add (eax, edi);
    goto label_0;
label_2:
    ecx = *((ebp - 0x1c));
    *(esp) = ecx;
    closedir ();
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058c40 */
#include <stdint.h>
 
int32_t camlBuffer_advance_to_non_alpha_1108 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8058440;
            *((ecx + 0xc)) = edx;
            eax = *((edx - 4));
            eax >>= 0xa;
            eax = eax*4 - 1;
            edx = *((edx + eax));
            eax -= edx;
            edx = eax + eax + 1;
            eax = ebx;
            ebx = edx;
            void (*0x8058440)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c340 */
#include <stdint.h>
 
int32_t camlUnix_fun_2724 (void) {
    eax = unix_link;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b290 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1684 (void) {
    eax = loc.camlPrintf__54;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805eac6 */
#include <stdint.h>
 
int32_t unix_lseek (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1472a;
    caml_enter_blocking_section ();
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x24b0));
    *((esp + 0xc)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((esp + 8)) = edx;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = lseek64 ();
    edi = eax;
    esi = edx;
    caml_leave_blocking_section ();
    eax = edi;
    eax &= esi;
    if (eax == -1) {
        eax = ebx - 0x24b6;
        uerror (eax, 0);
    }
    if (esi >= 0) {
        if (esi <= 0) {
            if (edi <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = ebx - 0x24b6;
        unix_error (0x4b, eax, 0);
    }
label_0:
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80683bd */
#include <stdint.h>
 
int32_t caml_array_get_addr (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    eax = *((edx + eax*4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b3d0 */
#include <stdint.h>
 
int32_t caml_tuplify3 (void) {
    edx = ebx;
    ecx = *((eax + 8));
    ebx = *((eax + 4));
    eax = *(eax);
    esi = *((edx + 8));
    return void (*esi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b140 */
#include <stdint.h>
 
int32_t camlPrintf_pr_1354 (void) {
    *(esp) = eax;
    edi = ecx;
    eax = *((edi - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((edi + eax));
    eax -= ecx;
    ebp = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x88;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x84f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8059450;
            *((ecx + 0xc)) = 0x10f9;
            *((ecx + 0x10)) = 0x804b2d0;
            *((ecx + 0x14)) = 7;
            *((ecx + 0x18)) = 0x8059420;
            *((ecx + 0x1c)) = 0x20f9;
            *((ecx + 0x20)) = 0x804b1f0;
            *((ecx + 0x24)) = 9;
            *((ecx + 0x28)) = 0x80593c0;
            *((ecx + 0x2c)) = 0x30f9;
            *((ecx + 0x30)) = 0x804b2d0;
            *((ecx + 0x34)) = 7;
            *((ecx + 0x38)) = 0x8059360;
            *((ecx + 0x3c)) = 0x40f9;
            *((ecx + 0x40)) = 0x804b370;
            *((ecx + 0x44)) = 5;
            *((ecx + 0x48)) = 0x8059330;
            *((ecx + 0x4c)) = 0x50f9;
            *((ecx + 0x50)) = 0x804b2d0;
            *((ecx + 0x54)) = 7;
            *((ecx + 0x58)) = 0x80592a0;
            eax = *((esi + 0xc));
            *((ecx + 0x5c)) = eax;
            eax = *((esi + 0x10));
            *((ecx + 0x60)) = eax;
            eax = *((esi + 0x14));
            *((ecx + 0x64)) = eax;
            eax = *((esi + 0x18));
            *((ecx + 0x68)) = eax;
            eax = *((esi + 0x1c));
            *((ecx + 0x6c)) = eax;
            *((ecx + 0x70)) = esi;
            eax = *(esp);
            *((ecx + 0x74)) = eax;
            *((ecx + 0x78)) = edi;
            *((ecx + 0x7c)) = edx;
            *((ecx + 0x80)) = ebp;
            edx = 1;
            eax = ebx;
            ebx = edx;
            void (*0x8059450)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f6d0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1394 (void) {
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054500 */
#include <stdint.h>
 
int32_t camlList_nth_1042 (void) {
    if (ebx < 1) {
        eax = "List.nth";
        void (*0x804f810)() ();
    }
    ecx = loc.camlList__48;
    return camlList_nth_aux_1045 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058280 */
#include <stdint.h>
 
int32_t camlHashtbl_entry (void) {
    eax = loc.camlHashtbl__16;
    *(0x80797f4) = eax;
    eax = loc.camlHashtbl__15;
    *(loc.camlHashtbl) = eax;
    eax = loc.camlHashtbl__14;
    *(0x80797c4) = eax;
    eax = loc.camlHashtbl__13;
    *(0x80797cc) = eax;
    eax = loc.camlHashtbl__12;
    *(0x80797ec) = eax;
    eax = loc.camlHashtbl__11;
    *(0x80797f8) = eax;
    eax = loc.camlHashtbl__10;
    *(0x80797c8) = eax;
    eax = loc.camlHashtbl__9;
    *(0x80797dc) = eax;
    eax = loc.camlHashtbl__8;
    *(0x80797fc) = eax;
    eax = loc.camlHashtbl__7;
    *(0x80797d0) = eax;
    eax = loc.camlHashtbl__6;
    *(0x80797d4) = eax;
    eax = loc.camlHashtbl__5;
    *(0x80797e0) = eax;
    eax = loc.camlHashtbl__4;
    *(0x80797d8) = eax;
    eax = loc.camlHashtbl__3;
    *(0x80797e4) = eax;
    eax = loc.camlHashtbl__2;
    *(0x80797e8) = eax;
    eax = camlHashtbl__1;
    *(0x80797f0) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b8e0 */
#include <stdint.h>
 
int32_t camlPrintf_iter_on_format_args_1137 (void) {
    edx = eax;
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    esi = *((edx + eax));
    eax -= esi;
    esi = eax + eax - 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x3c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x38f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x8059b00;
            *((eax + 0xc)) = 0x10f9;
            *((eax + 0x10)) = 0x804b370;
            *((eax + 0x14)) = 5;
            *((eax + 0x18)) = 0x80598c0;
            *((eax + 0x1c)) = 0x20f9;
            *((eax + 0x20)) = 0x8059840;
            *((eax + 0x24)) = 3;
            *((eax + 0x28)) = edx;
            *((eax + 0x2c)) = ebx;
            *((eax + 0x30)) = ecx;
            *((eax + 0x34)) = esi;
            ebx = eax;
            ebx += 0x20;
            eax = 1;
            camlPrintf_scan_fmt_1144 ();
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059840 */
#include <stdint.h>
 
int32_t camlPrintf_scan_fmt_1144 (void) {
    do {
label_0:
        ecx = *((ebx + 0x14));
        if (eax >= ecx) {
            goto label_1;
        }
        esi = *((ebx + 8));
        edx = eax;
        edx >>= 1;
        ecx = *((esi - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edi = *((esi + ecx));
        ecx -= edi;
        if (ecx <= edx) {
            goto label_2;
        }
        ecx = *((esi + edx));
        ecx = ecx + ecx + 1;
        if (ecx != 0x4b) {
            goto label_3;
        }
        ecx = ebx;
        ecx += 0xffffffe0;
        ebx = eax;
        ebx += 2;
        eax = 1;
        eax = camlPrintf_scan_flags_1142 (ebx);
        ebx = *(esp);
    } while (1);
label_3:
    eax += 2;
    goto label_0;
label_1:
    return eax;
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8057600 */
#include <stdint.h>
 
int32_t camlHashtbl_clear_1054 (void) {
    edi = eax;
    ebx = 1;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 9;
    esi |= 1;
    esi += 0xfffffffe;
    if (ebx > esi) {
        goto label_0;
    }
    do {
        ecx = *((edi + 4));
        eax = *((ecx - 4));
        eax >>= 9;
        if (eax <= ebx) {
            goto label_1;
        }
        caml_modify (ecx + ebx*2 - 2, 1);
        eax = ebx;
        ebx += 2;
    } while (eax != esi);
label_0:
    *(edi) = 1;
    eax = 1;
    return eax;
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054580 */
#include <stdint.h>
 
int32_t camlList_flatten_1058 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 4));
        ebx = *(eax);
        eax = ecx;
        eax = camlList_flatten_1058 (ebx);
    } while (1);
    ebx = eax;
    eax = *(esp);
    void (*0x804fad0)() ();
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804be50 */
#include <stdint.h>
 
int32_t camlUnix_fun_2580 (void) {
    eax = unix_getprotobynumber;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805cabc */
#include <stdint.h>
 
int32_t unix_close (int32_t fildes) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1673c;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = close (eax);
    if (eax == -1) {
        eax = ebx - 0x25e4;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a524 */
#include <stdint.h>
 
void close (void) {
    close ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068131 */
#include <stdint.h>
 
int32_t caml_array_unsafe_set_addr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 0x10));
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    ebx <<= 2;
    ebx += *((ebp + 8));
    edi = *(ebx);
    *(ebx) = esi;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) != 0) {
        if (*(obj.caml_gc_phase) == 0) {
            caml_darken (edi, 0);
        }
        if ((esi & 1) != 0) {
            goto label_0;
        }
        eax = caml_young_end;
        if (esi >= eax) {
            goto label_0;
        }
        edx = caml_young_start;
        if (esi <= edx) {
            goto label_0;
        }
        if ((edi & 1) == 0) {
            if (eax <= edi) {
                goto label_1;
            }
            if (edx < edi) {
                goto label_0;
            }
        }
label_1:
        eax = .comment;
        if (eax >= *(0x807fe8c)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x807fe88;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_0:
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068be8 */
#include <stdint.h>
 
int32_t caml_input_scan_line (int32_t arg_8h) {
    void * s1;
    int32_t var_1ch;
    void * s2;
    size_t n;
    ebx = *((ebp + 8));
    esi = *((ebx + 0x10));
    edi = ebx + 0x34;
    *((ebp - 0x20)) = edi;
    *((ebp - 0x1c)) = edi;
    do {
        eax = *((ebx + 0x14));
        if (esi >= eax) {
            edx = *((ebx + 0x10));
            if (edx > edi) {
                eax -= edx;
                eax = *((ebp - 0x20));
                memmove (eax, edx, eax);
                eax = *((ebp - 0x1c));
                eax -= *((ebx + 0x10));
                edx = *((ebp - 0x1c));
                *((ebx + 0x10)) = edx;
                *((ebx + 0x14)) += eax;
                esi += eax;
            }
            edx = *((ebx + 0x14));
            eax = *((ebx + 0xc));
            if (edx >= eax) {
                eax = *((ebx + 0x10));
                eax -= edx;
                goto label_0;
            }
            eax -= edx;
            eax = *(ebx);
            eax = caml_do_read (eax, edx, eax);
            if (eax == 0) {
                eax = *((ebx + 0x10));
                eax -= *((ebx + 0x14));
                goto label_0;
            }
            ecx = eax;
            ecx >>= 0x1f;
            *((ebx + 4)) += eax;
            *((ebx + 8)) += ecx;
            *((ebx + 0x14)) += eax;
        }
        eax = *(esi);
        esi++;
    } while (al != 0xa);
    eax = esi;
    eax -= *((ebx + 0x10));
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f6f0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1398 (void) {
    eax = caml_ml_pos_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c0b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2650 (void) {
    eax = unix_alarm;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059ca0 */
#include <stdint.h>
 
int32_t camlPrintf_add_conv_1191 (void) {
    *(esp) = ebx;
    if (ecx != 0x53) {
        if (ecx == 0xfb) {
            goto label_0;
        }
        edx = *((edx + 0xc));
        ebx = ecx;
        ecx = edx;
        camlPrintf_incr_ac_1187 ();
    }
label_0:
    eax = *(esp);
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806be8b */
#include <stdint.h>
 
uint32_t caml_sys_system_command (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = caml_local_roots;
    *((ebp - 0x38)) = edi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    caml_string_length (eax);
    esi = eax + 1;
    eax = caml_stat_alloc (esi);
    ebx = eax;
    eax = *((ebp + 8));
    memmove (ebx, eax, esi);
    caml_enter_blocking_section ();
    eax = system (ebx);
    esi = eax;
    caml_leave_blocking_section ();
    caml_stat_free (ebx);
    if (esi == -1) {
        eax = *((ebp + 8));
        caml_sys_error (eax);
    }
    eax = 0xff;
    if ((esi & 0x7f) == 0) {
        edx = esi;
        eax = (int32_t) dh;
    }
    *(obj.caml_local_roots) = edi;
    eax = eax + eax + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f088 */
#include <stdint.h>
 
int32_t unix_rename (char * oldpath, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    char * newpath;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1416b;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax = rename (esi, eax);
    if (eax == -1) {
        eax = ebx - 0x2463;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a054 */
#include <stdint.h>
 
void rename (void) {
    rename ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c0d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2654 (void) {
    eax = unix_localtime;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059330 */
#include <stdint.h>
 
int32_t camlPrintf_cont_f_1364 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ecx + 0x28));
    eax = *((ecx + 0x2c));
    ecx = *(ebx);
    void (*ecx)(uint32_t, uint32_t, uint32_t) (ecx, eax, ebx);
    ecx = *(esp);
    ecx += 0xffffffc0;
    eax = *((esp + 4));
    ebx = *((esp + 8));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055fe0 */
#include <stdint.h>
 
int32_t camlString_capitalize_1104 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_apply1_1100 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806144f */
#include <stdint.h>
 
uint32_t unix_waitpid (int32_t arg_8h, pid_t pid) {
    int32_t var_ch;
    int32_t wstatus;
    int32_t options;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x11da8;
    eax = ebx + 0x97ec;
    eax = *((ebp + 8));
    eax = caml_convert_flag_list (eax, eax);
    esi = eax;
    caml_enter_blocking_section ();
    eax = ebp - 0xc;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = waitpid (eax, eax, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x216e;
        uerror (eax, 0);
    }
    edx = *((ebp - 0xc));
    eax = esi;
    alloc_process_status ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a434 */
#include <stdint.h>
 
void waitpid (void) {
    waitpid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fd00 */
#include <stdint.h>
 
int32_t camlPervasives_open_in_gen_1214 (void) {
    eax = caml_sys_open;
    eax = caml_c_call (ecx);
    eax = caml_ml_open_descriptor_in;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054630 */
#include <stdint.h>
 
int32_t camlList_rev_map_1067 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8053650;
            *((ecx + 0xc)) = edx;
            eax = 1;
            void (*0x8053650)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b360 */
#include <stdint.h>
 
void camlPrintf_to_string_1054 (void) {
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ecx = ebx + ebx + 1;
    ebx = 1;
    return camlString_sub_1046 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055160 */
#include <stdint.h>
 
int32_t camlList_chop_1243 (void) {
    do {
        if (eax == 1) {
            eax = ebx;
            return eax;
        }
        if (ebx == 1) {
            goto label_0;
        }
        ebx = *((ebx + 4));
        eax += 0xfffffffe;
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = "L6\a\b";
            *((eax + 4)) = 0x807883c;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a572 */
#include <stdint.h>
 
int32_t caml_output_value_to_malloc (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    void * s2;
    size_t n;
    init_extern_output (ebx, esi, edi);
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = extern_value ();
    ebx = eax;
    eax = malloc (eax);
    esi = eax;
    if (eax == 0) {
        extern_out_of_memory ();
    }
    eax = *((ebp + 0x10));
    *(eax) = esi;
    eax = *((ebp + 0x14));
    *(eax) = ebx;
    ebx = extern_output_first;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        edi = *((ebx + 4));
        edi -= eax;
        memmove (esi, eax, edi);
        esi += edi;
        ebx = *(ebx);
    } while (ebx != 0);
label_0:
    free_extern_output ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b660 */
#include <stdint.h>
 
int32_t camlSource_buf_ok_1308 (void) {
    do {
        if (ebx <= 1) {
            eax = 3;
            return eax;
        }
        edx = ebx;
        edx >>= 1;
        ecx = camlSource;
        ecx = *((ecx + edx));
        edx = ecx + ecx + 1;
        ecx = ebx;
        ecx >>= 1;
        ecx = *((eax + ecx));
        ecx = ecx + ecx + 1;
        if (ecx != edx) {
            goto label_0;
        }
        ebx += 0xfffffffe;
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a7aa */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_2 (void) {
    edx = intern_src;
    eax = edx + 2;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    eax = *(edx);
    eax <<= 8;
    eax = ecx + eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8053b10 */
#include <stdint.h>
 
int32_t camlList_rev_sort_1272 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    if (eax != 5) {
        *((esp + 0x10)) = ecx;
        if (eax != 7) {
            goto label_7;
        }
        if (ebx == 1) {
            goto label_7;
        }
        esi = *((ebx + 4));
        if (esi == 1) {
            goto label_7;
        }
        edx = *((esi + 4));
        if (edx == 1) {
            goto label_7;
        }
        eax = *(edx);
        edx = *(esi);
        eax = *(ebx);
        ecx = *((ecx + 0xc));
        ebx = edx;
        eax = caml_apply2 (eax, edx, eax);
        if (eax > 1) {
            eax = *((esp + 0x10));
            ecx = *((eax + 0xc));
            eax = *((esp + 4));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax > 1) {
label_6:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_8;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *(esp);
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
            eax = *((esp + 0x10));
            ecx = *((eax + 0xc));
            eax = *((esp + 8));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax > 1) {
label_5:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_9;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *(esp);
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
label_4:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0xc));
        eax = *((esp + 8));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax > 1) {
label_3:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_11;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0xc));
        eax = *((esp + 4));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax > 1) {
label_2:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_12;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_13;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        eax = *((esp + 8));
        *(ebx) = eax;
        *((ebx + 4)) = 1;
        ecx = ebx + 0xc;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 4));
        *(ecx) = eax;
        *((ecx + 4)) = ebx;
        ebx += 0x18;
        *((ebx - 4)) = 0x800;
        eax = *(esp);
        *(ebx) = eax;
        *((ebx + 4)) = ecx;
        eax = ebx;
        return eax;
    }
    if (ebx == 1) {
        goto label_14;
    }
    edx = *((ebx + 4));
    if (edx == 1) {
        goto label_15;
    }
    edx = *(edx);
    eax = *(ebx);
    ecx = *((ecx + 0xc));
    ebx = edx;
    eax = caml_apply2 (edx, eax);
    if (eax <= 1) {
        goto label_16;
    }
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_17;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x800;
    eax = *(esp);
    *(ecx) = eax;
    *((ecx + 4)) = 1;
    ebx = ecx + 0xc;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 4));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = ebx;
    return eax;
    do {
label_16:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ecx) = eax;
            *((ecx + 4)) = 1;
            ebx = ecx + 0xc;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
label_15:
            *((esp + 0x10)) = ecx;
            goto label_7;
label_14:
label_7:
            ecx = eax;
            ecx >>= 1;
            ecx |= 1;
            eax -= ecx;
            eax++;
            eax = ecx;
            eax = camlList_chop_1243 (ecx, ebx, eax);
            ecx = *((esp + 0x10));
            ecx += 0xfffffff0;
            eax = *(esp);
            ebx = *((esp + 4));
            eax = camlList_sort_1271 (eax);
            ecx = *((esp + 0x10));
            ecx += 0xfffffff0;
            eax = *((esp + 8));
            ebx = *((esp + 0xc));
            eax = camlList_sort_1271 (eax);
            ebx = eax;
            eax = *((esp + 0x10));
            edx = *((eax + 0x10));
            ecx = 1;
            eax = *(esp);
            void (*0x8053910)() ();
        }
        caml_call_gc ();
    } while (1);
label_17:
    caml_call_gc ();
    goto label_0;
label_13:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_call_gc ();
    goto label_2;
label_11:
    caml_call_gc ();
    goto label_3;
label_10:
    caml_call_gc ();
    goto label_4;
label_9:
    caml_call_gc ();
    goto label_5;
label_8:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8053fd0 */
#include <stdint.h>
 
int32_t camlList_sort_1271 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    if (eax != 5) {
        *((esp + 0x10)) = ecx;
        if (eax != 7) {
            goto label_7;
        }
        if (ebx == 1) {
            goto label_7;
        }
        esi = *((ebx + 4));
        if (esi == 1) {
            goto label_7;
        }
        edx = *((esi + 4));
        if (edx == 1) {
            goto label_7;
        }
        eax = *(edx);
        edx = *(esi);
        eax = *(ebx);
        ecx = *((ecx + 0x1c));
        ebx = edx;
        eax = caml_apply2 (eax, edx, eax);
        if (eax <= 1) {
            eax = *((esp + 0x10));
            ecx = *((eax + 0x1c));
            eax = *((esp + 4));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax <= 1) {
label_6:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_8;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *(esp);
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
            eax = *((esp + 0x10));
            ecx = *((eax + 0x1c));
            eax = *((esp + 8));
            ebx = *(esp);
            eax = caml_apply2 ();
            if (eax <= 1) {
label_5:
                eax = caml_young_ptr;
                eax -= 0x24;
                *(obj.caml_young_ptr) = eax;
                if (eax < *(obj.caml_young_limit)) {
                    goto label_9;
                }
                ebx = eax + 4;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 4));
                *(ebx) = eax;
                *((ebx + 4)) = 1;
                ecx = ebx + 0xc;
                *((ecx - 4)) = 0x800;
                eax = *(esp);
                *(ecx) = eax;
                *((ecx + 4)) = ebx;
                ebx += 0x18;
                *((ebx - 4)) = 0x800;
                eax = *((esp + 8));
                *(ebx) = eax;
                *((ebx + 4)) = ecx;
                eax = ebx;
                return eax;
            }
label_4:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0x1c));
        eax = *((esp + 8));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax <= 1) {
label_3:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_11;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
        eax = *((esp + 0x10));
        ecx = *((eax + 0x1c));
        eax = *((esp + 4));
        ebx = *(esp);
        eax = caml_apply2 ();
        if (eax <= 1) {
label_2:
            eax = caml_young_ptr;
            eax -= 0x24;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_12;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ebx) = eax;
            *((ebx + 4)) = 1;
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx += 0x18;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_13;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        eax = *((esp + 8));
        *(ebx) = eax;
        *((ebx + 4)) = 1;
        ecx = ebx + 0xc;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 4));
        *(ecx) = eax;
        *((ecx + 4)) = ebx;
        ebx += 0x18;
        *((ebx - 4)) = 0x800;
        eax = *(esp);
        *(ebx) = eax;
        *((ebx + 4)) = ecx;
        eax = ebx;
        return eax;
    }
    if (ebx == 1) {
        goto label_14;
    }
    edx = *((ebx + 4));
    if (edx == 1) {
        goto label_15;
    }
    edx = *(edx);
    eax = *(ebx);
    ecx = *((ecx + 0x1c));
    ebx = edx;
    eax = caml_apply2 (edx, eax);
    if (eax > 1) {
        goto label_16;
    }
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_17;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x800;
    eax = *(esp);
    *(ecx) = eax;
    *((ecx + 4)) = 1;
    ebx = ecx + 0xc;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 4));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = ebx;
    return eax;
    do {
label_16:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ecx) = eax;
            *((ecx + 4)) = 1;
            ebx = ecx + 0xc;
            *((ebx - 4)) = 0x800;
            eax = *(esp);
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
label_15:
            *((esp + 0x10)) = ecx;
            goto label_7;
label_14:
label_7:
            ecx = eax;
            ecx >>= 1;
            ecx |= 1;
            eax -= ecx;
            eax++;
            eax = ecx;
            eax = camlList_chop_1243 (ecx, ebx, eax);
            ecx = *((esp + 0x10));
            ecx += 0x10;
            eax = *(esp);
            ebx = *((esp + 4));
            eax = camlList_rev_sort_1272 (eax);
            ecx = *((esp + 0x10));
            ecx += 0x10;
            eax = *((esp + 8));
            ebx = *((esp + 0xc));
            eax = camlList_rev_sort_1272 (eax);
            ebx = eax;
            eax = *((esp + 0x10));
            edx = *((eax + 0x24));
            ecx = 1;
            eax = *(esp);
            void (*0x8053a10)() ();
        }
        caml_call_gc ();
    } while (1);
label_17:
    caml_call_gc ();
    goto label_0;
label_13:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_call_gc ();
    goto label_2;
label_11:
    caml_call_gc ();
    goto label_3;
label_10:
    caml_call_gc ();
    goto label_4;
label_9:
    caml_call_gc ();
    goto label_5;
label_8:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c8d8 */
#include <stdint.h>
 
int32_t unix_alarm (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16920;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    alarm ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a3d4 */
#include <stdint.h>
 
void alarm (void) {
    alarm ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061dda */
#include <stdint.h>
 
int32_t caml_failwith (void) {
    int32_t var_4h_6;
    int32_t var_4h_5;
    eax = *((ebp + 8));
    return caml_raise_with_string ("45\a\b", eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804be70 */
#include <stdint.h>
 
int32_t camlUnix_fun_2584 (void) {
    eax = unix_gethostbyaddr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058fb0 */
#include <stdint.h>
 
int32_t camlPrintf_sub_sub_1129 (void) {
    ecx = *((ebx + 0x14));
    if (eax >= ecx) {
        edx = *((ebx + 8));
        eax = *((ebx + 0x10));
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)() ();
    }
    edx = *((ebx + 0x10));
    ecx = eax;
    ecx >>= 1;
    esi = *((edx - 4));
    esi >>= 0xa;
    esi = esi*4 - 1;
    edi = *((edx + esi));
    esi -= edi;
    if (esi > ecx) {
        ecx = *((edx + ecx));
        edx = ecx + ecx + 1;
        ecx = edx;
        ecx += 0xffffffb0;
        if (ecx > 3) {
            ecx += 0xffffff5a;
            if (ecx > 5) {
                goto label_0;
            }
            *(esp) = ebx;
            ecx >>= 1;
            if (ecx < 1) {
                goto label_1;
            }
            if (ecx == 1) {
                goto label_0;
            }
            if (ecx > 1) {
                goto label_2;
            }
        }
        if (ecx == 1) {
            *(esp) = ebx;
            goto label_1;
label_0:
            ebx += 0xfffffff4;
            eax += 2;
            void (*0x8059090)() ();
label_1:
            ecx = *((ebx + 0x18));
            ebx = eax;
            ebx += 2;
            eax = edx;
            eax = camlPrintf_sub_fmt_1124 ();
            ebx = *(esp);
            ebx += 0xfffffff4;
            eax += 2;
            void (*0x8059090)() ();
        }
label_2:
        ecx = *((ebx + 0x20));
        if (edx == ecx) {
            eax += 2;
            return eax;
        }
        esi = *((ebx + 0xc));
        ecx = *((ebx + 0x1c));
        eax = *((ebx + 0x10));
        ebx = ecx;
        ecx = edx;
        edx = esi;
        void (*0x804b4f0)() ();
    }
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bc5d */
#include <stdint.h>
 
int32_t caml_sys_getenv (char * name) {
    eax = *((ebp + 8));
    eax = getenv (eax);
    if (eax == 0) {
        eax = caml_raise_not_found ();
    }
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050190 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1487 (void) {
    eax = caml_ml_pos_out_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c370 */
#include <stdint.h>
 
int32_t camlUnix_fun_2730 (void) {
    eax = unix_isatty;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c390 */
#include <stdint.h>
 
int32_t camlUnix_fun_2734 (void) {
    eax = unix_lstat;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063212 */
#include <stdint.h>
 
void caml_fl_init_merge (void) {
    *(obj.last_fragment) = 0;
    *(obj.caml_fl_merge) = 0x807ca48;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fe8d */
#include <stdint.h>
 
int32_t alloc_inet6_addr (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13366;
    esi = *((ebp + 8));
    caml_alloc_string (0x10);
    edx = *(esi);
    *(eax) = edx;
    edx = *((esi + 4));
    *((eax + 4)) = edx;
    edx = *((esi + 8));
    *((eax + 8)) = edx;
    edx = *((esi + 0xc));
    *((eax + 0xc)) = edx;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ba40 */
#include <stdint.h>
 
int32_t camlPrintf_ac_of_format_1184 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x38;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = 1;
            *((ebx + 4)) = 1;
            *((ebx + 8)) = 1;
            eax = ebx + 0x10;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x8059c40;
            *((eax + 0xc)) = ebx;
            ebx += 0x24;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.caml_curry3;
            *((ebx + 4)) = 7;
            *((ebx + 8)) = 0x8059ca0;
            *((ebx + 0xc)) = eax;
            ecx = loc.camlPrintf__46;
            eax = edx;
            camlPrintf_iter_on_format_args_1137 (ebx);
            eax = *(esp);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805cf86 */
#include <stdint.h>
 
uint32_t unix_set_close_on_exec (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1626d;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 1;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        eax |= 1;
        *((esp + 8)) = eax;
        *((esp + 4)) = 2;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x258e;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806687b */
#include <stdint.h>
 
int32_t caml_nativeint_xor (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax ^= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056cd0 */
#include <stdint.h>
 
int32_t camlHashtbl_do_bucket_1142 (void) {
    int32_t var_4h;
    do {
        esi = ebx;
        if (eax == 1) {
            goto label_0;
        }
        ebx = *((eax + 8));
        ebx = *((eax + 4));
        eax = *(eax);
        edx = *((ecx + 0xc));
        ecx = esi;
        eax = caml_apply3 (ebx, ecx);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
    } while (1);
label_0:
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806717a */
#include <stdint.h>
 
int32_t caml_eq_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] == fp_stack[1]) ? 1 : 0;
    __asm ("setnp dl");
    eax &= edx;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055880 */
#include <stdint.h>
 
int32_t camlString_fill_1051 (void) {
    if (ebx >= 1) {
        if (ecx < 1) {
            goto label_0;
        }
        esi = *((eax - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((eax + esi));
        esi -= edi;
        esi <<= 1;
        esi -= ecx;
        esi += 2;
        if (ebx > esi) {
            goto label_0;
        }
        caml_fill_string (eax, ebx, ecx, edx);
        return;
    }
label_0:
    eax = "String.fill";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f8d0 */
#include <stdint.h>
 
int32_t camlPervasives_abs_1044 (void) {
    if (eax >= 1) {
        return;
    }
    ebx = 2;
    ebx -= eax;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c0f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2658 (void) {
    eax = unix_gettimeofday;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c7e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2794 (void) {
    eax = unix_lseek_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d803 */
#include <stdint.h>
 
int32_t unix_getgrnam (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x159f5;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getgrnam ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_group_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049f84 */
#include <stdint.h>
 
void getgrnam (void) {
    getgrnam ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c7c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2798 (void) {
    eax = unix_ftruncate_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061d88 */
#include <stdint.h>
 
int32_t caml_raise_sys_error (void) {
    int32_t var_4h_3;
    int32_t var_4h_2;
    eax = *((ebp + 8));
    return caml_raise_with_arg (loc.caml_exn_Sys_error, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80597b0 */
#include <stdint.h>
 
int32_t camlPrintf_sub_fmt_1124 (void) {
    edx = ebx;
    if (eax == 0x51) {
        esi = 0x53;
    } else {
        esi = 0xfb;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x34;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x30f7;
            *(ebx) = sym.camlPrintf__sub_1128;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = 0xcf9;
            *((ebx + 0xc)) = 0x8058fb0;
            *((ebx + 0x10)) = 3;
            eax = *((ecx + 0xc));
            *((ebx + 0x14)) = eax;
            eax = *((ecx + 0x10));
            *((ebx + 0x18)) = eax;
            eax = *((ecx + 0x14));
            *((ebx + 0x1c)) = eax;
            eax = *((ecx + 0x18));
            *((ebx + 0x20)) = eax;
            *((ebx + 0x24)) = ecx;
            *((ebx + 0x28)) = edx;
            *((ebx + 0x2c)) = esi;
            eax = edx;
            void (*0x8059090)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804be90 */
#include <stdint.h>
 
int32_t camlUnix_fun_2588 (void) {
    eax = unix_gethostname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067297 */
#include <stdint.h>
 
void caml_init_ieee_floats (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065dfd */
#include <stdint.h>
 
int32_t caml_greaterthan (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80806c0) {
        compare_free_stack ();
    }
    al = (ebx > 0) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068e02 */
#include <stdint.h>
 
uint32_t caml_refill (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = ebx + 0x34;
    edx = *((ebx + 0xc));
    edx -= eax;
    eax = *(ebx);
    eax = caml_do_read (ebx, eax, edx);
    if (eax == 0) {
        eax = caml_raise_end_of_file ();
    }
    ecx = eax;
    ecx >>= 0x1f;
    *((ebx + 4)) += eax;
    *((ebx + 8)) += ecx;
    eax = ebx + eax + 0x34;
    *((ebx + 0x14)) = eax;
    eax = ebx + 0x35;
    *((ebx + 0x10)) = eax;
    eax = *((ebx + 0x34));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068a6a */
#include <stdint.h>
 
int32_t caml_do_read (int32_t arg_8h, void * arg_ch, size_t arg_10h) {
    void * buf;
    size_t nbyte;
    esi = *((ebp + 8));
    edi = *((ebp + 0xc));
    do {
        caml_enter_blocking_section (ebx, esi, edi);
        eax = *((ebp + 0x10));
        eax = read (esi, edi, eax);
        ebx = eax;
        caml_leave_blocking_section ();
        if (ebx != -1) {
            goto label_0;
        }
        eax = errno_location ();
    } while (*(eax) == 4);
    caml_sys_io_error (1);
label_0:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061e9b */
#include <stdint.h>
 
void caml_raise_end_of_file (void) {
    return caml_raise_constant ("x5\a\b");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804cb50 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_float_1664 (void) {
    eax = unix_getsockopt;
    caml_c_call (7);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c330 */
#include <stdint.h>
 
uint32_t camlPrintf_ksprintf_1411 (void) {
    ebx = .comment;
    ecx = *(ebx);
    eax = void (*ecx)() ();
    edi = eax;
    ebp = .comment;
    esi = loc.camlPrintf__40;
    edx = .comment;
    ecx = .comment;
    ebx = .comment;
    eax = 3;
    *(loc.caml_extra_params) = ebp;
    return caml_apply6 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b280 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1680 (void) {
    eax = *((ebx + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c3b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2738 (void) {
    eax = unix_ftruncate;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e234 */
#include <stdint.h>
 
uint32_t unix_getsockname (int32_t sockfd) {
    int32_t var_7ch;
    int32_t var_78h;
    struct sockaddr * addr;
    socklen_t * addrlen;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14fc1;
    *((ebp - 0x7c)) = 0x70;
    eax = ebp - 0x7c;
    eax = ebp - 0x78;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = getsockname (eax, eax, eax);
    if (eax == -1) {
        eax = ebx - 0x2518;
        uerror (eax, 0);
    }
    eax = *((ebp - 0x7c));
    eax = ebp - 0x78;
    alloc_sockaddr (eax, eax, 0xffffffff);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049e94 */
#include <stdint.h>
 
void getsockname (void) {
    getsockname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8053910 */
#include <stdint.h>
 
int32_t camlList_rev_merge_1251 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
label_0:
        if (eax == 1) {
            goto label_2;
        }
        if (ebx == 1) {
            goto label_3;
        }
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((edx + 0xc));
        eax = caml_apply2 (edx, eax, ecx);
        if (eax > 1) {
            goto label_4;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 0xc));
        *(ecx) = eax;
        eax = *((esp + 0x10));
        *((ecx + 4)) = eax;
        eax = *((esp + 0x14));
        ebx = *((esp + 0x18));
        edx = *((esp + 0x1c));
    } while (1);
    do {
label_4:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            eax = *((esp + 0x10));
            *((ecx + 4)) = eax;
            eax = *((esp + 4));
            ebx = *((esp + 8));
            edx = *((esp + 0x1c));
            goto label_0;
label_3:
            ebx = ecx;
            void (*0x8054520)() ();
label_2:
            eax = ebx;
            ebx = ecx;
            void (*0x8054520)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066cc6 */
#include <stdint.h>
 
int32_t caml_int64_xor (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 4));
    ecx ^= *((eax + 4));
    edx = *((edx + 8));
    edx ^= *((eax + 8));
    caml_copy_int64 (ecx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055f50 */
#include <stdint.h>
 
int32_t camlString_uppercase_1096 (void) {
    ebx = eax;
    eax = .comment;
    return camlString_map_1090 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056d30 */
#include <stdint.h>
 
int32_t camlHashtbl_add_1179 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    esi = *((eax + 4));
    esi = *((esi - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = *((edx + 0xc));
        eax = *((eax + 8));
        edx = *((eax + 4));
        ecx = *(edx);
        eax = ebx;
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (esi, ecx, eax);
        ebx = 0x7fffffff;
        eax &= ebx;
        eax >>= 1;
        ecx = *((esp + 0x10));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            ebx = *((esp + 8));
            esi = *((ebx + 4));
            ecx = *((esi - 4));
            ecx >>= 9;
            if (ecx <= edx) {
                goto label_0;
            }
            ecx = *((esi + edx*2 - 2));
            *((eax + 8)) = ecx;
            esi = *((ebx + 4));
            ecx = *((esi - 4));
            ecx >>= 9;
            if (ecx <= edx) {
                goto label_1;
            }
            caml_modify (esi + edx*2 - 2, eax);
            *(ebx) += 2;
            eax = *((ebx + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ecx = eax + eax - 1;
            eax = *(ebx);
            if (eax > ecx) {
                eax = *((esp + 0xc));
                eax = *((eax + 0xc));
                void (*0x80576b0)() ();
            }
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80500c0 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_newline_1287 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x8076898));
    eax = caml_ml_flush;
    caml_c_call (*(0x8076898));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f9c4 */
#include <stdint.h>
 
int32_t unix_setuid (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13834;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = setuid ();
    if (eax == -1) {
        eax = ebx - 0x241a;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a324 */
#include <stdint.h>
 
void setuid (void) {
    setuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067458 */
#include <stdint.h>
 
int32_t caml_log1p_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_log1p ();
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80672c4 */
#include <stdint.h>
 
void caml_log1p (void) {
    *(fp_stack--) = *((ebp + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    log1p (ebp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049eb4 */
#include <stdint.h>
 
void log1p (void) {
    log1p ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804cb70 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_float_1667 (void) {
    eax = unix_setsockopt;
    caml_c_call (7);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ac00 */
#include <stdint.h>
 
int32_t caml_curry9_6 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_7;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806855c */
#include <stdint.h>
 
int32_t caml_ml_pos_out (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_pos_out (ebx);
    ebx = eax;
    if (edx >= 0) {
        if (edx <= 0) {
            if (eax <= 0x3fffffff) {
                goto label_0;
            }
        }
        errno_location ();
        *(eax) = 0x4b;
        caml_sys_error (1);
    }
label_0:
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fb70 */
#include <stdint.h>
 
int32_t camlPervasives_open_out_bin_1181 (void) {
    ecx = eax;
    ebx = 0x36d;
    eax = loc.camlPervasives__93;
    return camlPervasives_open_out_gen_1175 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806f824 */
#include <stdint.h>
 
int32_t caml_final_update (void) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    uint32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    esi = old;
    if (esi == 0) {
        goto label_2;
    }
    edx = final_table;
    ebx = 0;
    eax = 0;
    do {
        ecx = *((edx + 4));
        ecx = *((ecx - 4));
        ecx &= 0x300;
        ebx += 0;
        eax++;
        edx += 0xc;
    } while (eax < esi);
    if (ebx == 0) {
        goto label_2;
    }
    eax = ebx * 3;
    eax = eax*4 + 0x14;
    eax = malloc (eax);
    if (eax == 0) {
        caml_fatal_error ("out of memory");
    }
    *(eax) = 0;
    *((eax + 4)) = ebx;
    edx = to_do_tl;
    if (edx == 0) {
        *(obj.to_do_hd) = eax;
        *(obj.to_do_tl) = eax;
    } else {
        *(edx) = eax;
        *(obj.to_do_tl) = eax;
    }
    eax = old;
    *((ebp - 0x30)) = eax;
    if (eax == 0) {
        goto label_3;
    }
    edx = final_table;
    *((ebp - 0x38)) = edx;
    ecx = to_do_tl;
    *((ebp - 0x2c)) = ecx;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x34)) = 0;
    *((ebp - 0x28)) = 0;
    edi = caml_page_table;
    do {
        *((ebp - 0x3c)) = edx;
label_0:
        ecx = *((edx + 4));
        eax = ecx - 4;
        if ((*(eax) & 0x300) == 0) {
            if (*(eax) == 0xfa) {
                eax = *(ecx);
                if ((al & 1) == 0) {
                    *((ebp - 0x20)) = eax;
                    ebx = eax;
                    ebx >>= 0x17;
                    ecx = eax;
                    ecx >>= 0xc;
                    ecx &= 0x7ff;
                    *((ebp - 0x1c)) = ecx;
                    esi = *((edi + ebx*4));
                    if ((*((esi + ecx)) & 7) != 0) {
                        ecx = *((eax - 4));
                        if (cl != 0xfa) {
                            if (cl != 0xf6) {
                                if (cl != 0xfd) {
                                    goto label_4;
                                }
                                esi = *((ebp - 0x3c));
                                esi = *((ebp - 0x3c));
                                *((esi + 4)) = eax;
                                esi = *((ebp - 0x3c));
                                esi = *((ebp - 0x3c));
                                esi = *((ebp - 0x3c));
                            } else {
                            } else {
                            } else {
                            } else {
                            } else {
                                esi = *((ebp - 0x3c));
                            }
                        }
                    }
                }
            }
label_1:
            ebx = *((ebp - 0x24));
            eax = ebx * 3;
            eax <<= 2;
            ecx = *(esi);
            ebx = *((ebp - 0x2c));
            *((eax + ebx + 8)) = ecx;
            ecx = *((esi + 4));
            *((eax + ebx + 0xc)) = ecx;
            ecx = *((esi + 8));
            *((eax + ebx + 0x10)) = ecx;
            *((ebp - 0x24))++;
        } else {
            esi = *((ebp - 0x3c));
            ecx = *((ebp - 0x34));
            eax = ecx * 3;
            eax <<= 2;
            ecx = *(esi);
            ebx = *((ebp - 0x38));
            *((eax + ebx)) = ecx;
            ecx = *((esi + 4));
            *((eax + ebx + 4)) = ecx;
            ecx = *((esi + 8));
            *((eax + ebx + 8)) = ecx;
            *((ebp - 0x34))++;
        }
        *((ebp - 0x28))++;
        edx += 0xc;
        esi = *((ebp - 0x28));
    } while (*((ebp - 0x30)) > esi);
    eax = *((ebp - 0x34));
    *(obj.old) = eax;
    *(obj.young) = eax;
    ecx = *((ebp - 0x24));
    edx = *((ebp - 0x2c));
    *((edx + 4)) = ecx;
    if (ecx == 0) {
        goto label_2;
    }
    ebx = 0;
    esi = ecx;
    do {
        eax = ebx * 3;
        eax <<= 2;
        eax += *(obj.to_do_tl);
        eax = *((eax + 0xc));
        eax = caml_darken (eax, 0);
        ebx++;
    } while (ebx < esi);
    goto label_2;
label_4:
    *((edx + 4)) = eax;
    eax = *((edi + ebx*4));
    ebx = *((ebp - 0x1c));
    if ((*((eax + ebx)) & 1) != 0) {
        goto label_0;
    }
    esi = *((ebp - 0x3c));
    goto label_1;
label_3:
    *(obj.old) = 0;
    *(obj.young) = 0;
    eax = to_do_tl;
    *((eax + 4)) = 0;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fc80 */
#include <stdint.h>
 
void camlPervasives_close_out_noerr_1211 (void) {
    *(esp) = eax;
    fcn_0804fc90 ();
    return void (*0x804fcb3)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fc90 */
#include <stdint.h>
 
int32_t fcn_0804fc90 (void) {
    *(obj.caml_exception_pointer) = esp;
    eax = caml_ml_flush;
    caml_c_call (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fcd0 */
#include <stdint.h>
 
int32_t fcn_0804fcd0 (int32_t arg_8h) {
    *(obj.caml_exception_pointer) = esp;
    eax = *((esp + 8));
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fcb3 */
#include <stdint.h>
 
int32_t fcn_0804fcb3 (void) {
    fcn_0804fcd0 ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806b420 */
#include <stdint.h>
 
uint32_t caml_input_value_from_block (int32_t arg_8h, uint32_t arg_ch) {
    edx = *((ebp + 8));
    *(obj.intern_input) = edx;
    *(obj.intern_input_malloced) = 0;
    eax = edx + 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *(edx);
    edx <<= 0x18;
    edx = ecx + edx;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    edx += ecx;
    ecx = *((eax - 2));
    ecx <<= 8;
    edx += ecx;
    if (edx != 0x8495a6be) {
        eax = caml_failwith ("input_value_from_block: bad object");
    }
    eax += 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *((eax - 4));
    edx <<= 0x18;
    edx = ecx + edx + 0x14;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    ecx = edx + ecx;
    edx = *((eax - 2));
    edx <<= 8;
    eax = ecx + edx;
    if (eax > *((ebp + 0xc))) {
        caml_failwith ("input_value_from_block: bad block length");
    }
    input_val_from_block ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ffa0 */
#include <stdint.h>
 
int32_t camlPervasives_print_endline_1274 (void) {
    ebx = eax;
    eax = .comment;
    camlPervasives_output_string_1191 ();
    eax = caml_ml_output_char;
    caml_c_call (*(0x8076894));
    eax = caml_ml_flush;
    caml_c_call (*(0x8076894));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b110 */
#include <stdint.h>
 
int32_t caml_curry5_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067edc */
#include <stdint.h>
 
int32_t caml_array_unsafe_get_float (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + edx*8));
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    edx = caml_young_ptr;
    eax = edx - 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        *(obj.caml_young_ptr) = edx;
        caml_minor_collection ();
        *(obj.caml_young_ptr) -= 0xc;
    }
    eax = caml_young_ptr;
    *(eax) = 0xbfd;
    eax = caml_young_ptr;
    eax += 4;
    *(fp_stack--) = *((ebp - 0x10));
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806272a */
#include <stdint.h>
 
int32_t caml_register_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = caml_global_roots;
    caml_insert_global_root ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f790 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1418 (void) {
    eax = caml_ml_output_int;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c1e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2684 (void) {
    eax = unix_rewinddir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062976 */
#include <stdint.h>
 
int32_t caml_remove_generational_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *(edx);
    if ((al & 1) != 0) {
        goto label_0;
    }
    if (eax >= *(obj.caml_young_end)) {
        goto label_1;
    }
    if (eax <= *(obj.caml_young_start)) {
        goto label_1;
    }
    eax = caml_global_roots_young;
    caml_delete_global_root ();
    goto label_0;
    do {
        eax = caml_global_roots_old;
        eax = caml_delete_global_root ();
        goto label_0;
label_1:
        ecx = eax;
        ecx >>= 0x17;
        eax >>= 0xc;
        eax &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
    } while ((*((ecx + eax)) & 1) != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c7a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2802 (void) {
    eax = unix_lstat_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054740 */
#include <stdint.h>
 
int32_t camlList_map2_1090 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        eax = caml_apply2 (edx, eax, eax);
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        eax = camlList_map2_1090 (eax);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 0xc));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            if (ecx == 1) {
                eax = 1;
                return eax;
            }
label_1:
            eax = "List.map2";
            void (*0x804f810)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ce64 */
#include <stdint.h>
 
int32_t unix_fchmod (void) {
    int32_t fd;
    int32_t mode;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16394;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = fchmod (eax, eax);
    if (eax == -1) {
        eax = ebx - 0x25b0;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066e8f */
#include <stdint.h>
 
int32_t caml_int64_add (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    ecx = *((eax + 4));
    ebx = *((eax + 8));
    edx = *((ebp + 8));
    eax = *((edx + 4));
    edx = *((edx + 8));
    eax += ecx;
    edx += ebx;
    caml_copy_int64 (ebx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c200 */
#include <stdint.h>
 
int32_t camlUnix_fun_2688 (void) {
    eax = unix_opendir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058330 */
#include <stdint.h>
 
int32_t camlBuffer_advance_1104 (void) {
    int32_t var_4h;
    do {
label_0:
        if (ebx >= ecx) {
label_1:
            eax = caml_young_ptr;
            eax -= 8;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            eax = caml_raise_exn ();
        }
        *((esp + 4)) = ecx;
        *(esp) = eax;
        edi = *((edx + 0xc));
        ecx = *((edx + 0x14));
        eax = ebx;
        eax >>= 1;
        esi = *((ecx - 4));
        esi >>= 0xa;
        ebp = esi*4 - 1;
        esi = *((ecx + ebp));
        ebp -= esi;
        if (ebp <= eax) {
            goto label_3;
        }
        eax = *((ecx + eax));
        eax = eax + eax + 1;
        if (eax != edi) {
            goto label_4;
        }
        ebx += 2;
        eax = *(esp);
        eax += 2;
        ecx = *((esp + 4));
    } while (1);
label_4:
    edi = *((edx + 0x10));
    ecx = *((edx + 0x14));
    eax = ebx;
    eax >>= 1;
    esi = *((ecx - 4));
    esi >>= 0xa;
    ebp = esi*4 - 1;
    esi = *((ecx + ebp));
    ebp -= esi;
    if (ebp > eax) {
        eax = *((ecx + eax));
        eax = eax + eax + 1;
        if (eax == edi) {
            eax = *(esp);
            if (eax == 1) {
                eax = ebx;
                return eax;
            }
            ebx += 2;
            eax += 0xfffffffe;
            ecx = *((esp + 4));
            goto label_0;
        }
        ebx += 2;
        eax = *(esp);
        ecx = *((esp + 4));
        goto label_0;
label_2:
        caml_call_gc ();
        goto label_1;
    }
    caml_ml_array_bound_error ();
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ff50 */
#include <stdint.h>
 
int32_t camlPervasives_print_string_1268 (void) {
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bcc8 */
#include <stdint.h>
 
int32_t caml_sys_exit (int32_t status) {
    eax = *((ebp + 8));
    eax >>= 1;
    return exit (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a894 */
#include <stdint.h>
 
void exit (void) {
    exit ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c1c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2680 (void) {
    eax = unix_pipe;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f750 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1410 (void) {
    eax = caml_ml_set_binary_mode;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056150 */
#include <stdint.h>
 
int32_t camlString_rindex_from_1128 (void) {
    if (ebx >= -1) {
        edx = *((eax - 4));
        edx >>= 0xa;
        edx = edx*4 - 1;
        esi = *((eax + edx));
        edx -= esi;
        edx = edx + edx + 1;
        if (ebx >= edx) {
            goto label_0;
        }
        void (*0x80560d0)() ();
    }
label_0:
    eax = "String.rindex_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b350 */
#include <stdint.h>
 
void camlPrintf_sub_1050 (void) {
    return camlString_sub_1046 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058ad0 */
#include <stdint.h>
 
void camlBuffer_add_buffer_1087 (void) {
    edx = *((ebx + 4));
    ecx = 1;
    ebx = *(ebx);
    return camlBuffer_add_substring_1076 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052d00 */
#include <stdint.h>
 
int32_t camlArray_fold_right_1145 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x400;
    *(esi) = ecx;
    ecx = *((ebx - 4));
    eax = *((ebx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        ecx >>= 9;
    } else {
        ecx >>= 0xa;
    }
    ecx |= 1;
    ecx += 0xfffffffe;
    if (ecx < 1) {
        goto label_3;
    }
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = esi;
    *(esp) = ebx;
    *((esp + 4)) = edx;
    do {
        ebx = *(esp);
        eax = *((ebx - 4));
        if (eax != 0xfe) {
            eax = *((ebx + ecx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *(esi);
        ecx = *((esp + 4));
        eax = caml_apply2 ();
        esi = *((esp + 0xc));
        caml_modify (esi, eax);
        ecx = *((esp + 0xc));
        eax = *((esp + 0xc));
        ecx -= 2;
        *((esp + 0xc)) = ecx;
    } while (eax != 1);
label_3:
    eax = *(esi);
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e1b7 */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
int32_t unix_getservbyport (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15041;
    eax = *((ebp + 8));
    eax >>= 1;
    ax = rotate_right16 (ax, 8);
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    eax = (int32_t) ax;
    *(esp) = eax;
    eax = getservbyport ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_service_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a194 */
#include <stdint.h>
 
void getservbyport (void) {
    getservbyport ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8051050 */
#include <stdint.h>
 
uint32_t camlArray_trickledown_1160 (void) {
    int32_t var_4h_3;
    int32_t var_8h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
        ecx = *((edx + 0x14));
        eax = camlArray_maxson_1155 (ebx, eax, ecx);
        ebx = eax;
        *((esp + 0x10)) = ebx;
        edx = *(esp);
        ecx = *((edx + 0x10));
        eax = *((ecx - 4));
        esi = *((ecx - 4));
        esi &= 0xff;
        if (esi != 0xfe) {
            eax >>= 9;
            if (eax <= ebx) {
                goto label_2;
            }
            eax = *((ecx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_3;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((edx + 0xc));
        ebx = *((esp + 8));
        eax = caml_apply2 ();
        if (eax <= 1) {
            goto label_5;
        }
        esi = *(esp);
        ecx = *((esi + 0x10));
        eax = *((ecx - 4));
        ebx = *((ecx - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            eax >>= 9;
            ebx = *((esp + 0x10));
            if (eax <= ebx) {
                goto label_6;
            }
            edx = *((ecx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            ebx = *((esp + 0x10));
            if (eax <= ebx) {
                goto label_7;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_8;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi + 0x10));
        edi = *((eax - 4));
        ecx = *((eax - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            edi >>= 9;
            ecx = *((esp + 0xc));
            if (edi <= ecx) {
                goto label_9;
            }
            caml_modify (eax + ecx*2 - 2, edx);
        } else {
            edi >>= 0xa;
            ecx = *((esp + 0xc));
            if (edi <= ecx) {
                goto label_10;
            }
            *(fp_stack--) = *(edx);
            *((eax + ecx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 4));
        ecx = *((esp + 8));
        edx = esi;
    } while (1);
label_5:
    eax = *(esp);
    eax = *((eax + 0x10));
    ebx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        ebx >>= 9;
        ecx = *((esp + 0xc));
        if (ebx <= ecx) {
            goto label_11;
        }
        ebx = *((esp + 8));
        caml_modify (eax + ecx*2 - 2, ebx);
    } else {
        ebx >>= 0xa;
        ecx = *((esp + 0xc));
        if (ebx <= ecx) {
            goto label_12;
        }
        ebx = *((esp + 8));
        *(fp_stack--) = *(ebx);
        *((eax + ecx*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_8:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066fef */
#include <stdint.h>
 
int32_t caml_int32_shift_left (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax <<= cl;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f770 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1414 (void) {
    eax = caml_ml_pos_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a9d0 */
#include <stdint.h>
 
int32_t loc_caml_startup_code_begin (void) {
    camlPervasives_entry ();
    *(obj.caml_globals_inited)++;
    camlArray_entry ();
    *(obj.caml_globals_inited)++;
    camlList_entry ();
    *(obj.caml_globals_inited)++;
    camlChar_entry ();
    *(obj.caml_globals_inited)++;
    camlString_entry ();
    *(obj.caml_globals_inited)++;
    camlSys_entry ();
    *(obj.caml_globals_inited)++;
    camlHashtbl_entry ();
    *(obj.caml_globals_inited)++;
    camlBuffer_entry ();
    *(obj.caml_globals_inited)++;
    camlPrintf_entry ();
    *(obj.caml_globals_inited)++;
    camlCallback_entry ();
    *(obj.caml_globals_inited)++;
    camlUnix_entry ();
    *(obj.caml_globals_inited)++;
    camlUnixLabels_code_begin ();
    *(obj.caml_globals_inited)++;
    camlSource_entry ();
    *(obj.caml_globals_inited)++;
    camlStd_exit_entry ();
    *(obj.caml_globals_inited)++;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80552b0 */
#include <stdint.h>
 
int32_t camlList_entry (void) {
    eax = loc.camlList__38;
    *(0x80785dc) = eax;
    eax = loc.camlList__37;
    *(loc.camlList) = eax;
    eax = loc.camlList__36;
    *(0x807853c) = eax;
    eax = loc.camlList__35;
    *(0x8078540) = eax;
    eax = loc.camlList__34;
    *(0x8078544) = eax;
    eax = .comment;
    *(0x807854c) = eax;
    eax = loc.camlList__33;
    *(0x8078550) = eax;
    eax = loc.camlList__32;
    *(0x8078548) = eax;
    eax = loc.camlList__31;
    *(0x8078558) = eax;
    eax = .comment;
    *(0x8078554) = eax;
    eax = loc.camlList__30;
    *(0x8078560) = eax;
    eax = loc.camlList__29;
    *(0x8078564) = eax;
    eax = loc.camlList__28;
    *(0x807855c) = eax;
    eax = loc.camlList__27;
    *(0x8078568) = eax;
    eax = loc.camlList__26;
    *(0x807856c) = eax;
    eax = loc.camlList__25;
    *(0x8078574) = eax;
    eax = loc.camlList__24;
    *(0x8078578) = eax;
    eax = loc.camlList__23;
    *(0x8078570) = eax;
    eax = loc.camlList__22;
    *(0x807857c) = eax;
    eax = loc.camlList__21;
    *(0x8078580) = eax;
    eax = loc.camlList__20;
    *(0x8078584) = eax;
    eax = loc.camlList__19;
    *(0x8078588) = eax;
    eax = loc.camlList__18;
    *(0x807858c) = eax;
    eax = loc.camlList__17;
    *(0x8078590) = eax;
    eax = loc.camlList__16;
    *(0x8078594) = eax;
    eax = loc.camlList__15;
    *(0x8078598) = eax;
    eax = loc.camlList__14;
    *(0x80785ac) = eax;
    eax = loc.camlList__13;
    *(0x80785b0) = eax;
    eax = loc.camlList__12;
    *(0x80785b4) = eax;
    eax = loc.camlList__11;
    *(0x80785b8) = eax;
    eax = loc.camlList__10;
    *(0x80785bc) = eax;
    eax = loc.camlList__9;
    *(0x80785c0) = eax;
    eax = loc.camlList__8;
    *(0x807859c) = eax;
    eax = loc.camlList__7;
    *(0x80785a4) = eax;
    eax = .comment;
    *(0x80785a0) = eax;
    eax = loc.camlList__6;
    *(0x80785a8) = eax;
    eax = loc.camlList__5;
    *(0x80785c4) = eax;
    eax = loc.camlList__4;
    *(0x80785c8) = eax;
    eax = loc.camlList__3;
    *(0x80785d8) = eax;
    eax = loc.camlList__2;
    *(0x80785e0) = eax;
    eax = camlList__1;
    *(0x80785d0) = eax;
    eax = .comment;
    *(0x80785cc) = eax;
    eax = .comment;
    *(0x80785d4) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055650 */
#include <stdint.h>
 
int32_t camlChar_entry (void) {
    eax = loc.camlChar__5;
    *(loc.camlChar) = eax;
    eax = loc.camlChar__4;
    *(0x80790b4) = eax;
    eax = loc.camlChar__3;
    *(0x80790b8) = eax;
    eax = loc.camlChar__2;
    *(0x80790bc) = eax;
    eax = camlChar__1;
    *(0x80790c0) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80562c0 */
#include <stdint.h>
 
int32_t camlString_entry (void) {
    eax = loc.camlString__24;
    *(loc.camlString) = eax;
    eax = loc.camlString__23;
    *(0x80791d8) = eax;
    eax = loc.camlString__22;
    *(0x80791dc) = eax;
    eax = loc.camlString__21;
    *(0x80791e0) = eax;
    eax = loc.camlString__20;
    *(0x80791e4) = eax;
    eax = loc.camlString__19;
    *(0x80791ec) = eax;
    eax = loc.camlString__18;
    *(0x80791e8) = eax;
    eax = loc.camlString__17;
    *(0x80791f0) = eax;
    eax = loc.camlString__16;
    *(0x8079224) = eax;
    eax = loc.camlString__15;
    *(0x8079210) = eax;
    eax = loc.camlString__14;
    *(0x8079214) = eax;
    eax = loc.camlString__13;
    *(0x8079228) = eax;
    eax = loc.camlString__12;
    *(0x8079218) = eax;
    eax = loc.camlString__11;
    *(0x807921c) = eax;
    eax = loc.camlString__10;
    *(0x807922c) = eax;
    eax = loc.camlString__9;
    *(0x80791f4) = eax;
    eax = loc.camlString__8;
    *(0x80791fc) = eax;
    eax = loc.camlString__7;
    *(0x8079230) = eax;
    eax = loc.camlString__6;
    *(0x80791f8) = eax;
    eax = loc.camlString__5;
    *(0x8079200) = eax;
    eax = loc.camlString__4;
    *(0x8079208) = eax;
    eax = loc.camlString__3;
    *(0x8079204) = eax;
    eax = loc.camlString__2;
    *(0x807920c) = eax;
    eax = camlString__1;
    *(0x8079220) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056480 */
#include <stdint.h>
 
int32_t camlSys_entry (void) {
    eax = caml_sys_get_argv;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    eax = *(eax);
    *(0x8079660) = eax;
    *(loc.camlSys) = ebx;
    eax = caml_sys_get_config;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    eax = *(eax);
    *(0x8079668) = eax;
    *(0x807966c) = ebx;
    ecx = .comment;
    ecx += 0xffffffec;
    ecx >>= 1;
    eax = 2;
    eax <<= cl;
    eax -= 3;
    eax += 2;
    *(0x8079674) = eax;
    ebx = .comment;
    ebx >>= 1;
    eax = .comment;
    eax >>= 1;
    if (eax < 0) {
        eax += 7;
    }
    eax >>= 3;
    eax <<= 1;
    eax *= ebx;
    eax -= 3;
    eax += 2;
    *(0x8079670) = eax;
    caml_alloc3 ();
    ebx = eax + 4;
    *((ebx - 4)) = 0x400;
    *(ebx) = 1;
    *(0x8079664) = ebx;
    eax = loc.camlSys__4;
    *(0x8079678) = eax;
    *(0x807967c) = 0xffffffff;
    *(0x8079680) = 0xfffffffd;
    *(0x8079684) = 0xfffffffb;
    *(0x8079688) = 0xfffffff9;
    *(0x807968c) = 0xfffffff7;
    *(0x8079690) = 0xfffffff5;
    *(0x8079694) = 0xfffffff3;
    *(0x8079698) = 0xfffffff1;
    *(0x807969c) = 0xffffffef;
    *(0x80796a0) = 0xffffffed;
    *(0x80796a4) = 0xffffffeb;
    *(0x80796a8) = 0xffffffe9;
    *(0x80796ac) = 0xffffffe7;
    *(0x80796b0) = 0xffffffe5;
    *(0x80796b4) = 0xffffffe3;
    *(0x80796b8) = 0xffffffe1;
    *(0x80796bc) = 0xffffffdf;
    *(0x80796c0) = 0xffffffdd;
    *(0x80796c4) = 0xffffffdb;
    *(0x80796c8) = 0xffffffd9;
    *(0x80796cc) = 0xffffffd7;
    eax = ebx + 8;
    *((eax - 4)) = 0x400;
    *(eax) = "Sys.Break";
    *(0x80796d0) = eax;
    eax = camlSys__2;
    *(0x80796d4) = eax;
    eax = "3.12.1";
    *(0x80796d8) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80704c0 */
#include <stdint.h>
 
int32_t loc_caml_alloc3 (int32_t arg_4h) {
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            return eax;
        }
        eax = *(esp);
        *(obj.caml_last_return_address) = eax;
        eax = esp + 4;
        *(obj.caml_bottom_of_stack) = eax;
        fcn_0807043d ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c390 */
#include <stdint.h>
 
int32_t camlPrintf_entry (void) {
    int32_t var_4h;
    ecx = loc.camlPrintf__38;
    eax = 0x14;
    caml_allocN (ecx);
    ebx = eax + 4;
    *((ebx - 4)) = 0x10f7;
    *(ebx) = sym.caml_curry2;
    *((ebx + 4)) = 5;
    *((ebx + 8)) = 0x805b330;
    *((ebx + 0xc)) = ecx;
    eax = 3;
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t) (ebx);
    ebx = eax;
    eax = 0x94;
    caml_allocN ();
    ecx = eax + 4;
    *((ecx - 4)) = 0xcf7;
    *(ecx) = sym.camlPrintf__index_of_literal_position_1044;
    *((ecx + 4)) = 3;
    eax = *(esp);
    *((ecx + 8)) = eax;
    edi = loc.camlPrintf__37;
    esi = ecx + 0x10;
    *((esi - 4)) = 0xcf7;
    *(esi) = sym.camlPrintf__to_string_1054;
    *((esi + 4)) = 3;
    *((esi + 8)) = edi;
    edx = ecx + 0x20;
    *((edx - 4)) = 0x1800;
    *(edx) = eax;
    eax = *((esp + 4));
    *((edx + 4)) = eax;
    *((edx + 8)) = ebx;
    *((edx + 0xc)) = ecx;
    *((edx + 0x10)) = edi;
    *((edx + 0x14)) = esi;
    *(0x807a850) = edx;
    eax = loc.camlPrintf__36;
    *(0x807a854) = eax;
    eax = loc.camlPrintf__35;
    *(0x807a858) = eax;
    eax = loc.camlPrintf__34;
    *(0x807a85c) = eax;
    eax = loc.camlPrintf__33;
    *(0x807a860) = eax;
    eax = loc.camlPrintf__32;
    *(0x807a864) = eax;
    eax = loc.camlPrintf__31;
    *(0x807a868) = eax;
    eax = loc.camlPrintf__30;
    *(0x807a86c) = eax;
    eax = loc.camlPrintf__29;
    *(0x807a870) = eax;
    eax = loc.camlPrintf__28;
    *(0x807a874) = eax;
    eax = loc.camlPrintf__27;
    *(0x807a878) = eax;
    eax = loc.camlPrintf__26;
    *(0x807a87c) = eax;
    eax = loc.camlPrintf__25;
    *(0x807a880) = eax;
    eax = loc.camlPrintf__24;
    *(0x807a884) = eax;
    eax = loc.camlPrintf__23;
    *(0x807a888) = eax;
    eax = loc.camlPrintf__22;
    *(0x807a88c) = eax;
    eax = loc.camlPrintf__21;
    *(0x807a890) = eax;
    eax = loc.camlPrintf__20;
    *(0x807a894) = eax;
    eax = loc.camlPrintf__19;
    *(0x807a898) = eax;
    eax = loc.camlPrintf__18;
    *(0x807a89c) = eax;
    eax = loc.camlPrintf__17;
    *(0x807a8a0) = eax;
    eax = loc.camlPrintf__16;
    *(0x807a8a4) = eax;
    ebx = loc.camlPrintf__15;
    eax = ecx + 0x3c;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x805bf40;
    *((eax + 0xc)) = ebx;
    *(0x807a8a8) = eax;
    eax = loc.camlPrintf__14;
    *(0x807a8ac) = eax;
    eax = loc.camlPrintf__13;
    *(0x807a8b0) = eax;
    eax = loc.camlPrintf__12;
    *(0x807a83c) = eax;
    eax = loc.camlPrintf__11;
    *(0x807a830) = eax;
    eax = loc.camlPrintf__10;
    *(loc.camlPrintf) = eax;
    eax = loc.camlPrintf__9;
    *(0x807a828) = eax;
    eax = loc.camlPrintf__8;
    *(0x807a82c) = eax;
    eax = loc.camlPrintf__7;
    *(0x807a844) = eax;
    eax = loc.camlPrintf__6;
    *(0x807a838) = eax;
    eax = loc.camlPrintf__5;
    *(0x807a8b4) = eax;
    eax = loc.camlPrintf__4;
    *(0x807a8b8) = eax;
    eax = loc.camlPrintf__3;
    *(0x807a8bc) = eax;
    eax = loc.camlPrintf__2;
    *(0x807a840) = eax;
    eax = camlPrintf__1;
    *(0x807a834) = eax;
    eax = .comment;
    *(0x807a848) = eax;
    eax = .comment;
    *(esp) = eax;
    ebp = .comment;
    edi = .comment;
    esi = .comment;
    edx = .comment;
    ebx = .comment;
    eax = ecx + 0x50;
    *((eax - 4)) = 0x1400;
    *(eax) = ebp;
    *((eax + 4)) = edi;
    *((eax + 8)) = esi;
    *((eax + 0xc)) = edx;
    *((eax + 0x10)) = ebx;
    ebx = ecx + 0x68;
    *((ebx - 4)) = 0x800;
    edx = *(esp);
    *(ebx) = edx;
    *((ebx + 4)) = eax;
    esi = *(ebx);
    eax = ecx + 0x74;
    *((eax - 4)) = 0x1000;
    edx = *(esi);
    *(eax) = edx;
    edx = *((esi + 8));
    *((eax + 4)) = edx;
    edx = *((esi + 0x10));
    *((eax + 8)) = edx;
    edx = *((esi + 0x14));
    *((eax + 0xc)) = edx;
    ecx += 0x88;
    *((ecx - 4)) = 0x800;
    *(ecx) = eax;
    eax = *((ebx + 4));
    *((ecx + 4)) = eax;
    *(0x807a84c) = ecx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ec70 */
#include <stdint.h>
 
int32_t loc_camlUnixLabels_code_begin (void) {
    eax = camlUnix;
    ebx = *(eax);
    *(loc.camlUnixLabels) = ebx;
    ebx = *((eax + 4));
    *(0x80765c4) = ebx;
    ebx = *((eax + 8));
    *(0x80765c8) = ebx;
    ebx = *((eax + 0xc));
    *(0x80765cc) = ebx;
    ebx = *((eax + 0x10));
    *(0x80765d0) = ebx;
    ebx = *((eax + 0x14));
    *(0x80765d4) = ebx;
    ebx = *((eax + 0x18));
    *(0x80765d8) = ebx;
    ebx = *((eax + 0x1c));
    *(0x80765dc) = ebx;
    ebx = *((eax + 0x20));
    *(0x80765e0) = ebx;
    ebx = *((eax + 0x24));
    *(0x80765e4) = ebx;
    ebx = *((eax + 0x28));
    *(0x80765e8) = ebx;
    ebx = *((eax + 0x2c));
    *(0x80765ec) = ebx;
    ebx = *((eax + 0x30));
    *(0x80765f0) = ebx;
    ebx = *((eax + 0x34));
    *(0x80765f4) = ebx;
    ebx = *((eax + 0x38));
    *(0x80765f8) = ebx;
    ebx = *((eax + 0x3c));
    *(0x80765fc) = ebx;
    ebx = *((eax + 0x40));
    *(0x8076600) = ebx;
    *(0x8076604) = 1;
    *(0x8076608) = 3;
    *(0x807660c) = 5;
    ebx = *((eax + 0x50));
    *(0x8076610) = ebx;
    ebx = *((eax + 0x54));
    *(0x8076614) = ebx;
    ebx = *((eax + 0x58));
    *(0x8076618) = ebx;
    ebx = *((eax + 0x5c));
    *(0x807661c) = ebx;
    ebx = *((eax + 0x60));
    *(0x8076620) = ebx;
    ebx = *((eax + 0x64));
    *(0x8076624) = ebx;
    ebx = *((eax + 0x68));
    *(0x8076628) = ebx;
    ebx = *((eax + 0x6c));
    *(0x807662c) = ebx;
    ebx = *((eax + 0x70));
    *(0x8076630) = ebx;
    ebx = *((eax + 0x74));
    *(0x8076634) = ebx;
    ebx = *((eax + 0x78));
    *(0x8076638) = ebx;
    ebx = *((eax + 0x7c));
    *(0x807663c) = ebx;
    ebx = *((eax + 0x80));
    *(0x8076640) = ebx;
    ebx = *((eax + 0x84));
    *(0x8076644) = ebx;
    ebx = *((eax + 0x88));
    *(0x8076648) = ebx;
    ebx = *((eax + 0x8c));
    *(0x807664c) = ebx;
    ebx = *((eax + 0x90));
    *(0x8076650) = ebx;
    ebx = *((eax + 0x94));
    *(0x8076654) = ebx;
    ebx = *((eax + 0x98));
    *(0x8076658) = ebx;
    ebx = *((eax + 0x9c));
    *(0x807665c) = ebx;
    ebx = *((eax + 0xa0));
    *(0x8076660) = ebx;
    ebx = *((eax + 0xa4));
    *(0x8076664) = ebx;
    ebx = *((eax + 0xa8));
    *(0x8076668) = ebx;
    ebx = *((eax + 0xac));
    *(0x807666c) = ebx;
    ebx = *((eax + 0xb0));
    *(0x8076670) = ebx;
    ebx = *((eax + 0xb4));
    *(0x8076674) = ebx;
    ebx = *((eax + 0xb8));
    *(0x8076678) = ebx;
    ebx = *((eax + 0xbc));
    *(0x807667c) = ebx;
    ebx = *((eax + 0xc0));
    *(0x8076680) = ebx;
    ebx = *((eax + 0xc4));
    *(0x8076684) = ebx;
    ebx = *((eax + 0xc8));
    *(0x8076688) = ebx;
    ebx = *((eax + 0xcc));
    *(0x807668c) = ebx;
    ebx = *((eax + 0xd0));
    *(0x8076690) = ebx;
    ebx = *((eax + 0xd4));
    *(0x8076694) = ebx;
    ebx = *((eax + 0xd8));
    *(0x8076698) = ebx;
    ebx = *((eax + 0xdc));
    *(0x807669c) = ebx;
    ebx = *((eax + 0xe0));
    *(0x80766a0) = ebx;
    ebx = *((eax + 0xe4));
    *(0x80766a4) = ebx;
    ebx = *((eax + 0xe8));
    *(0x80766a8) = ebx;
    ebx = *((eax + 0xec));
    *(0x80766ac) = ebx;
    ebx = *((eax + 0xf0));
    *(0x80766b0) = ebx;
    ebx = *((eax + 0xf4));
    *(0x80766b4) = ebx;
    ebx = *((eax + 0xf8));
    *(0x80766b8) = ebx;
    ebx = *((eax + 0xfc));
    *(0x80766bc) = ebx;
    ebx = *((eax + 0x100));
    *(0x80766c0) = ebx;
    ebx = *((eax + 0x104));
    *(0x80766c4) = ebx;
    ebx = *((eax + 0x108));
    *(0x80766c8) = ebx;
    ebx = *((eax + 0x10c));
    *(0x80766cc) = ebx;
    ebx = *((eax + 0x110));
    *(0x80766d0) = ebx;
    ebx = *((eax + 0x114));
    *(0x80766d4) = ebx;
    ebx = *((eax + 0x118));
    *(0x80766d8) = ebx;
    ebx = *((eax + 0x11c));
    *(0x80766dc) = ebx;
    ebx = *((eax + 0x120));
    *(0x80766e0) = ebx;
    ebx = *((eax + 0x124));
    *(0x80766e4) = ebx;
    ebx = *((eax + 0x128));
    *(0x80766e8) = ebx;
    ebx = *((eax + 0x12c));
    *(0x80766ec) = ebx;
    ebx = *((eax + 0x130));
    *(0x80766f0) = ebx;
    ebx = *((eax + 0x134));
    *(0x80766f4) = ebx;
    ebx = *((eax + 0x138));
    *(0x80766f8) = ebx;
    ebx = *((eax + 0x13c));
    *(0x80766fc) = ebx;
    ebx = *((eax + 0x140));
    *(0x8076700) = ebx;
    ebx = *((eax + 0x144));
    *(0x8076704) = ebx;
    ebx = *((eax + 0x148));
    *(0x8076708) = ebx;
    ebx = *((eax + 0x14c));
    *(0x807670c) = ebx;
    ebx = *((eax + 0x150));
    *(0x8076710) = ebx;
    ebx = *((eax + 0x154));
    *(0x8076714) = ebx;
    ebx = *((eax + 0x158));
    *(0x8076718) = ebx;
    ebx = *((eax + 0x15c));
    *(0x807671c) = ebx;
    ebx = *((eax + 0x160));
    *(0x8076720) = ebx;
    ebx = *((eax + 0x164));
    *(0x8076724) = ebx;
    ebx = *((eax + 0x168));
    *(0x8076728) = ebx;
    ebx = *((eax + 0x16c));
    *(0x807672c) = ebx;
    ebx = *((eax + 0x170));
    *(0x8076730) = ebx;
    ebx = *((eax + 0x174));
    *(0x8076734) = ebx;
    ebx = *((eax + 0x178));
    *(0x8076738) = ebx;
    ebx = *((eax + 0x17c));
    *(0x807673c) = ebx;
    ebx = *((eax + 0x180));
    *(0x8076740) = ebx;
    ebx = *((eax + 0x184));
    *(0x8076744) = ebx;
    ebx = *((eax + 0x188));
    *(0x8076748) = ebx;
    ebx = *((eax + 0x18c));
    *(0x807674c) = ebx;
    ebx = *((eax + 0x190));
    *(0x8076750) = ebx;
    ebx = *((eax + 0x194));
    *(0x8076754) = ebx;
    ebx = *((eax + 0x198));
    *(0x8076758) = ebx;
    ebx = *((eax + 0x19c));
    *(0x807675c) = ebx;
    ebx = *((eax + 0x1a0));
    *(0x8076760) = ebx;
    ebx = *((eax + 0x1a4));
    *(0x8076764) = ebx;
    ebx = *((eax + 0x1a8));
    *(0x8076768) = ebx;
    ebx = *((eax + 0x1ac));
    *(0x807676c) = ebx;
    ebx = *((eax + 0x1b0));
    *(0x8076770) = ebx;
    ebx = *((eax + 0x1b4));
    *(0x8076774) = ebx;
    ebx = *((eax + 0x1b8));
    *(0x8076778) = ebx;
    ebx = *((eax + 0x1bc));
    *(0x807677c) = ebx;
    ebx = *((eax + 0x1c0));
    *(0x8076780) = ebx;
    ebx = *((eax + 0x1c4));
    *(0x8076784) = ebx;
    ebx = *((eax + 0x1c8));
    *(0x8076788) = ebx;
    ebx = *((eax + 0x1cc));
    *(0x807678c) = ebx;
    ebx = *((eax + 0x1d0));
    *(0x8076790) = ebx;
    ebx = *((eax + 0x1d4));
    *(0x8076794) = ebx;
    ebx = *((eax + 0x1d8));
    *(0x8076798) = ebx;
    ebx = *((eax + 0x1dc));
    *(0x807679c) = ebx;
    ebx = *((eax + 0x1e0));
    *(0x80767a0) = ebx;
    ebx = *((eax + 0x1e4));
    *(0x80767a4) = ebx;
    ebx = *((eax + 0x1e8));
    *(0x80767a8) = ebx;
    ebx = *((eax + 0x1ec));
    *(0x80767ac) = ebx;
    ebx = *((eax + 0x1f0));
    *(0x80767b0) = ebx;
    ebx = *((eax + 0x1f4));
    *(0x80767b4) = ebx;
    ebx = *((eax + 0x1f8));
    *(0x80767b8) = ebx;
    ebx = *((eax + 0x1fc));
    *(0x80767bc) = ebx;
    ebx = *((eax + 0x200));
    *(0x80767c0) = ebx;
    ebx = *((eax + 0x204));
    *(0x80767c4) = ebx;
    ebx = *((eax + 0x208));
    *(0x80767c8) = ebx;
    ebx = *((eax + 0x20c));
    *(0x80767cc) = ebx;
    ebx = *((eax + 0x210));
    *(0x80767d0) = ebx;
    ebx = *((eax + 0x214));
    *(0x80767d4) = ebx;
    ebx = *((eax + 0x218));
    *(0x80767d8) = ebx;
    ebx = *((eax + 0x21c));
    *(0x80767dc) = ebx;
    ebx = *((eax + 0x220));
    *(0x80767e0) = ebx;
    ebx = *((eax + 0x224));
    *(0x80767e4) = ebx;
    ebx = *((eax + 0x228));
    *(0x80767e8) = ebx;
    ebx = *((eax + 0x22c));
    *(0x80767ec) = ebx;
    ebx = *((eax + 0x230));
    *(0x80767f0) = ebx;
    ebx = *((eax + 0x234));
    *(0x80767f4) = ebx;
    ebx = *((eax + 0x238));
    *(0x80767f8) = ebx;
    ebx = *((eax + 0x23c));
    *(0x80767fc) = ebx;
    ebx = *((eax + 0x240));
    *(0x8076800) = ebx;
    ebx = *((eax + 0x244));
    *(0x8076804) = ebx;
    ebx = *((eax + 0x248));
    *(0x8076808) = ebx;
    ebx = *((eax + 0x24c));
    *(0x807680c) = ebx;
    ebx = *((eax + 0x250));
    *(0x8076810) = ebx;
    ebx = *((eax + 0x254));
    *(0x8076814) = ebx;
    ebx = *((eax + 0x258));
    *(0x8076818) = ebx;
    ebx = *((eax + 0x25c));
    *(0x807681c) = ebx;
    ebx = *((eax + 0x260));
    *(0x8076820) = ebx;
    ebx = *((eax + 0x264));
    *(0x8076824) = ebx;
    eax = *((eax + 0x268));
    *(0x8076828) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b930 */
#include <stdint.h>
 
int32_t camlSource_entry (void) {
    int32_t var_4h;
    eax = "Hello there sailor\n";
    *(loc.camlSource) = eax;
    eax = loc.camlSource__7;
    *(0x8073d58) = eax;
    eax = loc.camlSource__6;
    *(0x8073d5c) = eax;
    eax = loc.camlSource__5;
    *(0x8073d60) = eax;
    eax = loc.camlSource__4;
    *(0x8073d64) = eax;
    eax = unix_socket;
    eax = caml_c_call (3);
    *(esp) = eax;
    eax = "127.0.0.1";
    eax = unix_inet_addr_of_string;
    eax = caml_c_call (eax);
    ebx = eax;
    caml_alloc2 ();
    eax = eax + 4;
    *((eax - 4)) = 0x801;
    *(eax) = ebx;
    *((eax + 4)) = 1;
    eax = *((esp + 4));
    eax = unix_bind;
    caml_c_call (eax);
    ecx = 3;
    ebx = 5;
    eax = *(esp);
    camlUnix_setsockopt_1646 ();
    eax = *((esp + 4));
    eax = unix_listen;
    caml_c_call (eax);
    eax = *(esp);
    *(0x8073d68) = eax;
    eax = loc.camlSource__2;
    *(0x8073d6c) = eax;
    eax = camlSource__1;
    *(0x8073d70) = eax;
    eax = *(loc.camlSys);
    eax = *((eax - 4));
    eax >>= 9;
    eax |= 1;
    if (eax > 3) {
        eax = *(loc.camlSys);
        eax = caml_int_of_string;
        caml_c_call (*((eax + 4)));
    } else {
        eax = 3;
    }
    *(0x8073d74) = eax;
    eax = .comment;
    camlSource_echo_server_1325 ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c540 */
#include <stdint.h>
 
int32_t camlUnix_fun_2780 (void) {
    eax = unix_environment;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bc1c */
#include <stdint.h>
 
uint32_t caml_sys_time (void) {
    int32_t var_50h;
    int32_t var_4h;
    eax = ebp - 0x50;
    *((esp + 4)) = eax;
    *(esp) = 0;
    getrusage ();
    *(fp_stack--) = *((ebp - 0x50));
    *(fp_stack--) = *((ebp - 0x4c));
    *(fp_stack--) = *(0x8070ce8);
    fp_stack[1] /= fp_stack[0];
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack[0] += fp_stack[2];
    fp_stack++;
    *(fp_stack--) = *((ebp - 0x48));
    fp_stack[0] += fp_stack[2];
    fp_stack++;
    *(fp_stack--) = *((ebp - 0x44));
    fp_stack[1] /= fp_stack[0];
    fp_stack++;
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062869 */
#include <stdint.h>
 
int32_t caml_modify_generational_global_root (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    *(esp) = ebx;
    *((esp + 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = *(esi);
    edx = ebx;
    edx &= 1;
    if (edx == 0) {
        if (ebx < *(obj.caml_young_end)) {
            if (ebx <= *(obj.caml_young_start)) {
                goto label_3;
            }
            if ((al & 1) != 0) {
                goto label_4;
            }
            edx = eax;
            edx >>= 0x17;
            eax >>= 0xc;
            eax &= 0x7ff;
            edx = *((edx*4 + obj.caml_page_table));
            if ((*((edx + eax)) & 1) == 0) {
                goto label_1;
            }
            edx = esi;
            eax = caml_global_roots_old;
            caml_delete_global_root ();
            edx = esi;
            eax = caml_global_roots_young;
            al = caml_insert_global_root ();
        }
    } else {
label_3:
        if ((al & 1) != 0) {
            if (edx != 0) {
                goto label_1;
            }
label_4:
            if (ebx >= *(obj.caml_young_end)) {
                goto label_5;
            }
            if (ebx <= *(obj.caml_young_start)) {
                goto label_5;
            }
            edx = esi;
            eax = caml_global_roots_young;
            caml_insert_global_root ();
            goto label_1;
label_0:
            edx = esi;
            eax = caml_global_roots_old;
            eax = caml_insert_global_root ();
        } else {
            if (edx == 0) {
                goto label_1;
            }
            if (eax >= *(obj.caml_young_end)) {
                goto label_6;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_6;
            }
            edx = esi;
            eax = caml_global_roots_young;
            caml_delete_global_root ();
            goto label_1;
label_2:
            edx = esi;
            eax = caml_global_roots_old;
            caml_delete_global_root ();
        }
    }
    do {
label_1:
        *(esi) = ebx;
        ebx = *(esp);
        esi = *((esp + 4));
        return eax;
label_5:
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
    } while ((*((edx + eax)) & 1) == 0);
    goto label_0;
label_6:
    edx = eax;
    edx >>= 0x17;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) == 0) {
        goto label_1;
    }
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ca74 */
#include <stdint.h>
 
uint32_t unix_chroot (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1677f;
    esi = *((ebp + 8));
    *(esp) = esi;
    eax = chroot ();
    if (eax == -1) {
        eax = ebx - 0x25eb;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a474 */
#include <stdint.h>
 
void chroot (void) {
    chroot ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806189e */
#include <stdint.h>
 
uint32_t caml_main (char ** arg_8h) {
    int32_t var_20h;
    int32_t var_19h;
    char ** var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    caml_init_ieee_floats (ebx, esi, edi);
    caml_init_custom_operations ();
    eax = ebp - 0x19;
    *(obj.caml_top_of_stack) = eax;
    eax = getenv ("OCAMLRUNPARAM");
    ebx = eax;
    if (eax != 0) {
        goto label_0;
    }
    eax = getenv (0x80710bf);
    ebx = eax;
    if (eax == 0) {
        goto label_1;
    }
    while (al != 0) {
        ebx++;
        eax -= 0x4f;
        if (al <= 0x27) {
            eax = (int32_t) al;
            uint32_t (*esi + eax*4)() ();
label_0:
            esi = 0x8071108;
            edi = ebp - 0x20;
        }
        eax = *(ebx);
    }
label_1:
    eax = max_percent_free_init;
    eax = percent_free_init;
    eax = heap_chunk_init;
    eax = heap_size_init;
    eax = minor_heap_init;
    caml_init_gc (eax, eax, eax);
    eax = 0;
    edx = caml_atom_table;
    do {
        *((edx + eax*4)) = eax;
        eax++;
    } while (eax != 0x100);
    eax = caml_page_table_add (4, 0x8083500, obj.caml_frame_descriptors_mask);
    if (eax == 0) {
        eax = caml_data_segments;
        ebx = 0;
        esi = 0x8073984;
        edi = caml_data_segments;
        if (eax != 0) {
            goto label_2;
        }
        goto label_3;
    }
    eax = caml_fatal_error ("Fatal error: not enough memory for the initial page table");
    do {
label_2:
        edx = *((esi + ebx*8));
        eax = caml_page_table_add (4, eax, edx);
        if (eax != 0) {
            caml_fatal_error ("Fatal error: not enough memory for the initial page table");
        }
        ebx++;
        eax = *((edi + ebx*8));
    } while (eax != 0);
label_3:
    eax = caml_code_segments;
    *(obj.caml_code_area_start) = eax;
    ecx = *(loc.caml_startup__code_end);
    *(obj.caml_code_area_end) = ecx;
    eax = *(loc.camlPervasives__code_begin);
    if (eax == 0) {
        goto label_4;
    }
    ebx = caml_code_area_start;
    edx = 1;
    edi = 0x8073a00;
    esi = caml_code_segments;
    do {
        if (ebx > eax) {
            ebx = eax;
        }
        eax = *((edi + edx*8));
        if (ecx < eax) {
            ecx = eax;
        }
        edx++;
        eax = *((esi + edx*8));
    } while (eax != 0);
    *(obj.caml_code_area_start) = ebx;
    *(obj.caml_code_area_end) = ecx;
label_4:
    caml_init_signals ();
    caml_debugger_init ();
    eax = *((ebp + 8));
    ebx = *(eax);
    eax = 0x8071d88;
    if (ebx == 0) {
        ebx = eax;
    }
    eax = caml_executable_name (obj.proc_self_exe.2949, 0x100);
    edx = proc_self_exe.2949;
    if (eax != 0) {
        eax = caml_search_exe_in_path (ebx);
        edx = eax;
    }
    eax = *((ebp + 8));
    caml_sys_init (edx, eax);
    *((esp + 4)) = 0;
    *(esp) = obj.caml_termination_jmpbuf;
    eax = sigsetjmp ();
    if (eax != 0) {
        eax = caml_termination_hook;
        if (eax == 0) {
            goto label_5;
        }
        void (*eax)(uint32_t) (0);
    } else {
        eax = loc_caml_start_program ();
        edx = eax;
        edx &= 3;
        if (edx != 2) {
            goto label_5;
        }
        eax &= 0xfffffffc;
        caml_fatal_uncaught_exception (eax);
    }
label_5:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bf00 */
#include <stdint.h>
 
int32_t camlUnix_fun_2602 (void) {
    eax = sym.unix_accept;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064ad4 */
#include <stdint.h>
 
int32_t caml_alloc_table (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *((ebp + 0x10));
    *((ebx + 0x14)) = eax;
    *((ebx + 0x18)) = edx;
    eax = edx + eax;
    eax <<= 2;
    eax = caml_stat_alloc (ebx, esi);
    esi = eax;
    eax = *(ebx);
    if (eax != 0) {
        caml_stat_free (eax);
    }
    *(ebx) = esi;
    *((ebx + 0xc)) = esi;
    eax = *((ebx + 0x14));
    edx = esi + eax*4;
    *((ebx + 8)) = edx;
    *((ebx + 0x10)) = edx;
    eax += *((ebx + 0x18));
    eax = esi + eax*4;
    *((ebx + 4)) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806068f */
#include <stdint.h>
 
uint32_t unix_lstat_64 (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x12b64;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = lxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x2318;
        uerror (eax, esi);
    }
    edx = ebp - 0x68;
    eax = 1;
    stat_aux ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a1c4 */
#include <stdint.h>
 
void lxstat64 (void) {
    lxstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80683e1 */
#include <stdint.h>
 
int32_t caml_array_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    if (*((eax - 4)) == 0xfe) {
        eax = caml_array_get_float (eax, edx);
    } else {
        caml_array_get_addr (eax, edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b8c0 */
#include <stdint.h>
 
int32_t camlPrintf_sub_format_for_printf_1135 (void) {
    ecx = eax;
    edx = .comment;
    ebx = .comment;
    eax = .comment;
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806eb6b */
#include <stdint.h>
 
uint32_t caml_weak_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0x28)) = ebx;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x30)) = 0;
    edx = ebp - 0x28;
    *((ebp - 0x50)) = edx;
    edx = ebp - 0x50;
    *(obj.caml_local_roots) = edx;
    *((ebp - 0x48)) = 1;
    *((ebp - 0x4c)) = 2;
    edx = ebp - 0x2c;
    *((ebp - 0x44)) = edx;
    edx = ebp - 0x30;
    *((ebp - 0x40)) = edx;
    eax++;
    if (eax != 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.get");
label_0:
    eax = *((edx + eax*4));
    if (eax == *(obj.caml_weak_none)) {
        *((ebp - 0x2c)) = 1;
    } else {
        *((ebp - 0x30)) = eax;
        if (*(obj.caml_gc_phase) == 0) {
            if ((al & 1) != 0) {
                goto label_1;
            }
            ecx = eax;
            ecx >>= 0x17;
            edx = eax;
            edx >>= 0xc;
            edx &= 0x7ff;
            ecx = *((ecx*4 + obj.caml_page_table));
            if ((*((ecx + edx)) & 1) == 0) {
                goto label_1;
            }
            caml_darken (eax, 0);
        }
label_1:
        eax = caml_alloc_small (1, 0);
        *((ebp - 0x2c)) = eax;
        edx = *((ebp - 0x30));
        *(eax) = edx;
    }
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806f4e0 */
#include <stdint.h>
 
int32_t caml_final_do_strong_roots (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    if (*(obj.old) == 0) {
        goto label_2;
    }
    ebx = 0;
    esi = 0;
    edi = *((ebp + 8));
    do {
        eax = ebx;
        eax += *(obj.final_table);
        eax = *(eax);
        void (*edi)(uint32_t, uint32_t) (eax, eax);
        esi++;
        ebx += 0xc;
    } while (*(obj.old) > esi);
label_2:
    eax = to_do_hd;
    *((ebp - 0x1c)) = eax;
    if (eax != 0) {
        goto label_3;
    }
    goto label_4;
    do {
label_0:
        eax = esi * 3;
        edx = *((ebp - 0x1c));
        edi = edx + eax*4;
        eax = edi + 8;
        eax = *((ebx + 8));
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, eax);
        edi += 0xc;
        eax = *((ebx + 0xc));
        uint32_t (*ebp + 8)(uint32_t, uint32_t) (eax, edi);
        esi++;
        ebx += 0xc;
        eax = *((ebp - 0x1c));
    } while (*((eax + 4)) > esi);
label_1:
    edx = *((ebp - 0x1c));
    edx = *(edx);
    *((ebp - 0x1c)) = edx;
    if (edx == 0) {
        goto label_4;
    }
label_3:
    ebx = *((ebp - 0x1c));
    esi = 0;
    if (*((ebx + 4)) != 0) {
        goto label_0;
    }
    goto label_1;
label_4:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80614c9 */
#include <stdint.h>
 
uint32_t unix_wait (void) {
    int32_t wstatus;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x11d2a;
    caml_enter_blocking_section ();
    eax = ebp - 0xc;
    eax = wait (eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x2166;
        uerror (eax, 0);
    }
    edx = *((ebp - 0xc));
    eax = esi;
    alloc_process_status ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a0c4 */
#include <stdint.h>
 
void wait (void) {
    wait ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063b2f */
#include <stdint.h>
 
int32_t caml_round_heap_chunk_size (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = caml_major_heap_increment;
    if (ebx >= eax) {
        eax = ebx;
    }
    eax = clip_heap_chunk_size ();
    if (ebx > eax) {
        caml_raise_out_of_memory ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ae50 */
#include <stdint.h>
 
int32_t caml_curry7_4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_5;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80587c0 */
#include <stdint.h>
 
int32_t camlBuffer_nth_1057 (void) {
    if (ebx >= 1) {
        ecx = *((eax + 4));
        if (ebx >= ecx) {
            goto label_0;
        }
        eax = *(eax);
        ebx >>= 1;
        ecx = *((eax - 4));
        ecx >>= 0xa;
        ecx = ecx*4 - 1;
        edx = *((eax + ecx));
        ecx -= edx;
        if (ecx <= ebx) {
            goto label_1;
        }
        eax = *((eax + ebx));
        eax = eax + eax + 1;
        return eax;
    }
label_0:
    eax = "Buffer.nth";
    void (*0x804f810)() ();
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80501d0 */
#include <stdint.h>
 
uint32_t camlPervasives_string_of_format_1315 (void) {
    int32_t var_4h;
    ecx = eax;
    *((esp + 4)) = ecx;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    *(esp) = eax;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    ebx = eax;
    eax = *(esp);
    eax = *((esp + 0x14));
    caml_blit_string (eax, 1, ebx, 1, eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067213 */
#include <stdint.h>
 
int32_t caml_gt_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    al = (fp_stack[0] > fp_stack[1]) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806cb5c */
#include <stdint.h>
 
int32_t caml_gc_major_slice (int32_t arg_8h) {
    caml_empty_minor_heap ();
    eax = *((ebp + 8));
    eax >>= 1;
    caml_major_collection_slice (eax);
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805baf0 */
#include <stdint.h>
 
int32_t camlPrintf_list_iter_i_1201 (void) {
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8059ce0;
            *((ecx + 0xc)) = edx;
            eax = 1;
            void (*0x8059ce0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c270 */
#include <stdint.h>
 
int32_t camlUnix_fun_2702 (void) {
    eax = unix_set_close_on_exec;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806b7e0 */
#include <stdint.h>
 
int32_t caml_hash_variant (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = 1;
    if (*(edx) == 0) {
        goto label_0;
    }
    do {
        eax >>= 1;
        eax *= 0xdf;
        ecx = *(edx);
        eax += ecx;
        eax = eax + eax + 1;
        edx++;
    } while (*(edx) != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804cad0 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_int_1650 (void) {
    eax = unix_getsockopt;
    caml_c_call (3);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805bf90 */
#include <stdint.h>
 
int32_t camlPrintf_scan_format_1278 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = edx;
    *((esp + 0x14)) = edi;
    eax = caml_extra_params;
    *((esp + 0x10)) = eax;
    edi = .comment;
    ebp = .comment;
    do {
        eax = caml_young_ptr;
        eax -= 0x64;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x805a800;
            ebx = *(esp);
            *((eax + 0xc)) = ebx;
            edx = eax + 0x14;
            *((edx - 4)) = 0x4cf7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x805b0e0;
            *((edx + 0xc)) = 0x10f9;
            *((edx + 0x10)) = 0x804b1f0;
            *((edx + 0x14)) = 9;
            *((edx + 0x18)) = 0x805b020;
            *((edx + 0x1c)) = 0x20f9;
            *((edx + 0x20)) = 0x804b1f0;
            *((edx + 0x24)) = 9;
            *((edx + 0x28)) = 0x805a880;
            ebx = *((esp + 4));
            *((edx + 0x2c)) = ebx;
            ecx = *((esp + 8));
            *((edx + 0x30)) = ecx;
            *((edx + 0x34)) = esi;
            ebx = *((esp + 0x14));
            *((edx + 0x38)) = ebx;
            ebx = *((esp + 0x10));
            *((edx + 0x3c)) = ebx;
            *((edx + 0x40)) = edi;
            *((edx + 0x44)) = ebp;
            *((edx + 0x48)) = eax;
            ecx += 2;
            ebx = 1;
            eax = *((esp + 0xc));
            void (*0x805b0e0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80625bc */
#include <stdint.h>
 
int32_t caml_scan_global_roots (int32_t arg_8h) {
    ebx = *((ebp + 8));
    edx = caml_global_roots;
    eax = ebx;
    caml_iterate_global_roots (ebx);
    edx = caml_global_roots_young;
    eax = ebx;
    caml_iterate_global_roots ();
    edx = caml_global_roots_old;
    eax = ebx;
    caml_iterate_global_roots ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8051420 */
#include <stdint.h>
 
uint32_t camlArray_bubble_1174 (void) {
    eax = void (*0x8051450)() ();
    ecx = .comment;
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *((eax + 4));
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ecx = *((ecx + 0xc));
    return camlArray_bubbledown_1170 (*(obj.caml_exception_pointer));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052430 */
#include <stdint.h>
 
int32_t camlArray_blit_1093 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edi = eax;
    *((esp + 8)) = ecx;
    if (esi < 1) {
        goto label_2;
    }
    if (ebx < 1) {
        goto label_2;
    }
    ecx = *((edi - 4));
    eax = *((edi - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = ecx;
        eax >>= 9;
    } else {
        eax = ecx;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= esi;
    eax++;
    if (ebx > eax) {
        goto label_2;
    }
    if (ebp < 1) {
        goto label_2;
    }
    eax = *((esp + 8));
    ecx = *((eax - 4));
    eax = *((eax - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = ecx;
        eax >>= 9;
    } else {
        eax = ecx;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= esi;
    eax++;
    if (ebp > eax) {
        goto label_2;
    }
    if (ebx >= ebp) {
        goto label_3;
    }
    esi += 0xfffffffe;
    if (esi < 1) {
        goto label_4;
    }
    *((esp + 4)) = ebx;
    do {
        eax = *((esp + 4));
        ebx = eax + esi - 1;
        eax = *((edi - 4));
        if (eax != 0xfe) {
            ebx = *((edi + ebx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edi + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            ebx = eax;
        }
        eax = ebp;
        eax = eax + esi - 1;
        ecx = *((esp + 8));
        ecx = *((ecx - 4));
        if (ecx != 0xfe) {
            ebx = *((esp + 0xc));
            caml_modify (ebx + eax*2 - 2, ebx);
        } else {
            *(fp_stack--) = *(ebx);
            ebx = *((esp + 8));
            *((ebx + eax*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ebx = esi;
        eax = esi;
        eax -= 2;
        esi = eax;
    } while (ebx != 1);
label_4:
    eax = 1;
    return eax;
label_3:
    eax = 1;
    *((esp + 0xc)) = eax;
    esi += 0xfffffffe;
    if (*((esp + 0xc)) > esi) {
        goto label_6;
    }
    *((esp + 4)) = ebx;
    *(esp) = edi;
    do {
        ebx = *((esp + 4));
        eax = *((esp + 0xc));
        ebx = ebx + eax - 1;
        eax = *(esp);
        ecx = *((eax - 4));
        if (ecx != 0xfe) {
            ebx = *((eax + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_7;
            }
            ecx = eax + 4;
            *((ecx - 4)) = 0x8fd;
            eax = *(esp);
            *(fp_stack--) = *((eax + ebx*4 - 4));
            *(ecx) = fp_stack[0];
            fp_stack--;
            ebx = ecx;
        }
        ecx = *((esp + 0xc));
        eax = ebp;
        eax = eax + ecx - 1;
        ecx = *((esp + 8));
        ecx = *((ecx - 4));
        if (ecx != 0xfe) {
            ebx = *((esp + 0xc));
            caml_modify (ebx + eax*2 - 2, ebx);
        } else {
            *(fp_stack--) = *(ebx);
            ebx = *((esp + 8));
            *((ebx + eax*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 0xc));
        eax = *((esp + 0xc));
        eax += 2;
        *((esp + 0xc)) = eax;
    } while (ebx != esi);
label_6:
    eax = 1;
    return eax;
label_2:
    eax = "Array.blit";
    void (*0x804f810)() ();
label_7:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80586f0 */
#include <stdint.h>
 
int32_t camlBuffer_contents_1044 (void) {
    ecx = *((eax + 4));
    ebx = 1;
    eax = *(eax);
    return camlString_sub_1046 ();
}


r2dec has crashed (info: SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80576a0).
Please report the bug at https://github.com/radareorg/r2dec-js/issues
Use the option '--issue' or the command 'pddi' to generate 
the needed data for the issue.
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ffe0 */
#include <stdint.h>
 
int32_t camlPervasives_print_newline_1276 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x8076894));
    eax = caml_ml_flush;
    caml_c_call (*(0x8076894));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804df70 */
#include <stdint.h>
 
int32_t camlUnix_close_process_in_2003 (void) {
    int32_t var_4h;
    ecx = eax;
    *(esp) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x401;
            *(ebx) = ecx;
            eax = "close_process_in";
            eax = camlUnix_find_proc_id_1997 ();
            *((esp + 4)) = eax;
            eax = *(esp);
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = *((esp + 4));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054a60 */
#include <stdint.h>
 
int32_t camlList_exists2_1153 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        eax = caml_apply2 (edx, eax, eax);
        if (eax != 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_0:
    if (ecx == 1) {
        eax = 1;
        return eax;
    }
label_1:
    eax = "List.exists2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80653be */
#include <stdint.h>
 
int32_t caml_alloc_final (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = *((ebp + 0xc));
    eax = caml_final_custom_operations (eax);
    edx = *((ebp + 0x14));
    edx = *((ebp + 0x10));
    edx = *((ebp + 8));
    edx <<= 2;
    caml_alloc_custom (edx, edx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067d30 */
#include <stdint.h>
 
uint32_t caml_string_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    if (ebx >= 0) {
        eax = caml_string_length (esi);
        if (ebx < eax) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((ebx + esi)) = al;
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061d07 */
#include <stdint.h>
 
int32_t caml_raise_with_arg (void) {
    int32_t var_4ch;
    int32_t var_48h_2;
    int32_t var_44h_2;
    int32_t var_40h_2;
    int32_t var_2ch;
    int32_t var_28h_2;
    int32_t var_24h_2;
    int32_t var_20h_2;
    int32_t var_1ch_2;
    int32_t var_18h;
    int32_t var_ch_2;
    int32_t var_4h_2;
    int32_t var_4h;
    eax = caml_local_roots;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    *((ebp - 0x2c)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0x2c)) = eax;
    edx = *((ebp + 8));
    *(eax) = edx;
    edx = *((ebp + 0xc));
    eax = *((ebp - 0x2c));
    *((eax + 4)) = edx;
    eax = *((ebp - 0x2c));
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054e90 */
#include <stdint.h>
 
int32_t camlList_find_all_1205 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x8053760;
            *((ebx + 0xc)) = ecx;
            eax = 1;
            ecx = *(ebx);
            void (*ecx)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fbe0 */
#include <stdint.h>
 
uint32_t caml_executable_name (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_68h;
    int32_t var_58h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    *((esp + 8)) = esi;
    *((esp + 4)) = ebx;
    *(esp) = "/proc/self/exe";
    eax = readlink ();
    if (eax != -1) {
        if (esi <= eax) {
            goto label_0;
        }
        *((ebx + eax)) = 0;
        eax = ebp - 0x68;
        *((esp + 8)) = eax;
        *((esp + 4)) = ebx;
        *(esp) = 3;
        eax = xstat64 ();
        if (eax != 0) {
            goto label_0;
        }
        edx = *((ebp - 0x58));
        edx &= 0xf000;
        if (edx == 0x8000) {
            goto label_1;
        }
    }
label_0:
    eax = 0xffffffff;
label_1:
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806b533 */
#include <stdint.h>
 
uint32_t caml_input_val_from_string (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_6ch;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    esi = ebp - 0x3c;
    *((ebp - 0x50)) = esi;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    eax = edx + eax + 8;
    *(obj.intern_input_malloced) = 0;
    ecx = eax + 4;
    edi = *((ecx - 1));
    edx = *(eax);
    edx <<= 0x18;
    edx = edi + edx;
    edi = *((ecx - 3));
    edi <<= 0x10;
    edi = edx + edi;
    edx = *((ecx - 2));
    edx <<= 8;
    edx = edi + edx;
    ecx = eax + 8;
    edi = *((ecx - 4));
    edi <<= 0x18;
    *((ebp - 0x6c)) = edi;
    edi = *((ecx - 1));
    edi += *((ebp - 0x6c));
    *((ebp - 0x6c)) = edi;
    edi = *((ecx - 3));
    edi <<= 0x10;
    edi += *((ebp - 0x6c));
    ecx = *((ecx - 2));
    ecx <<= 8;
    edi += ecx;
    eax += 0xc;
    *(obj.intern_src) = eax;
    eax = edi;
    intern_alloc (ebx, esi, edi);
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    eax = edx + eax + 0x14;
    *(obj.intern_src) = eax;
    eax = esi;
    intern_rec ();
    eax = edi;
    intern_add_to_heap ();
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050220 */
#include <stdint.h>
 
int32_t camlPervasives_at_exit_1322 (void) {
    ecx = eax;
    eax = .comment;
    ebx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlPervasives__fun_1500;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            caml_modify (*(0x8076980), eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065ec5 */
#include <stdint.h>
 
int32_t caml_notequal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80806c0) {
        eax = compare_free_stack ();
    }
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066c17 */
#include <stdint.h>
 
int32_t caml_int64_of_int (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax >>= 1;
    edx = eax;
    edx >>= 0x1f;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054680 */
#include <stdint.h>
 
int32_t camlList_iter_1074 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        void (*ecx)(uint32_t, uint32_t) (edx, eax);
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066f40 */
#include <stdint.h>
 
int32_t caml_int32_bits_of_float (int32_t arg_8h) {
    int32_t var_10h;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x10));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80544b0 */
#include <stdint.h>
 
int32_t camlList_length_1034 (void) {
    ebx = eax;
    eax = 1;
    return camlList_length_aux_1030 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806cb8c */
#include <stdint.h>
 
int32_t caml_gc_set (int32_t arg_8h) {
    char * var_4h;
    int32_t var_8h;
    esi = *((ebp + 8));
    ebx = *((ebp + 8));
    eax = *((esi + 0xc));
    eax >>= 1;
    *(obj.caml_verb_gc) = eax;
    eax = *((esi + 8));
    eax >>= 1;
    eax = norm_pfree (ebx, esi);
    if (eax != *(obj.caml_percent_free)) {
        *(obj.caml_percent_free) = eax;
        caml_gc_message (0x20, "New space overhead: %d%%\n", eax);
    }
    eax = *((ebx + 0x10));
    eax >>= 1;
    eax = norm_pmax ();
    if (eax != *(obj.caml_percent_max)) {
        *(obj.caml_percent_max) = eax;
        caml_gc_message (0x20, "New max overhead: %d%%\n", eax);
    }
    eax = *((ebx + 4));
    eax >>= 1;
    eax = norm_heapincr ();
    eax <<= 2;
    if (eax != *(obj.caml_major_heap_increment)) {
        *(obj.caml_major_heap_increment) = eax;
        eax >>= 0xa;
        caml_gc_message (0x20, "New heap increment size: %luk bytes\n", eax);
    }
    ebx = *((ebx + 0x18));
    ebx >>= 1;
    eax = 1;
    if (ebx >= 2) {
        ebx = eax;
    }
    if (ebx != *(obj.caml_allocation_policy)) {
        caml_gc_message (0x20, "New allocation policy: %d\n", ebx);
        caml_set_allocation_policy (ebx);
    }
    eax = *(esi);
    eax >>= 1;
    eax <<= 2;
    eax = norm_minsize ();
    ebx = eax;
    if (eax != *(obj.caml_minor_heap_size)) {
        eax >>= 0xa;
        caml_gc_message (0x20, "New minor heap size: %luk bytes\n", eax);
        caml_set_minor_heap_size (ebx);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806273f */
#include <stdint.h>
 
int32_t caml_scan_global_young_roots (int32_t arg_8h) {
    ebx = *((ebp + 8));
    edx = caml_global_roots;
    eax = ebx;
    caml_iterate_global_roots (ebx);
    edx = caml_global_roots_young;
    eax = ebx;
    caml_iterate_global_roots ();
    ebx = .comment;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        edx = *(ebx);
        eax = caml_global_roots_old;
        caml_insert_global_root ();
        ebx = *((ebx + 4));
    } while (ebx != 0);
    eax = .comment;
    if (eax == 0) {
        goto label_0;
    }
    do {
        ebx = *((eax + 4));
        caml_stat_free (eax);
        if (ebx == 0) {
            goto label_0;
        }
        eax = ebx;
    } while (1);
label_0:
    edx = .comment;
    if (edx < 0) {
        goto label_1;
    }
    eax = 0;
    ecx = 0x807cd84;
    do {
        *((ecx + eax*4)) = 0;
        eax++;
    } while (eax <= edx);
label_1:
    *(0x807cdc8) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056c90 */
#include <stdint.h>
 
int32_t camlHashtbl_do_bucket_1132 (void) {
    int32_t var_4h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 8));
        edx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ebx = edx;
        caml_apply2 (ecx, ebx);
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067c1d */
#include <stdint.h>
 
uint32_t caml_string_compare (int32_t arg_8h, int32_t arg_ch) {
    uint32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    if (ebx != edi) {
        eax = caml_string_length (ebx);
        *((ebp - 0x10)) = eax;
        eax = caml_string_length (edi);
        edx = eax;
        eax = *((ebp - 0x10));
        if (eax <= *((ebp - 0x10))) {
            eax = edx;
        }
        esi = ebx;
        ecx = eax;
        __asm ("repe cmpsb byte [esi], byte ptr es:[edi]");
        al = (eax > eax) ? 1 : 0;
        cl = (eax < eax) ? 1 : 0;
        al -= cl;
        eax = (int32_t) al;
        if (eax < 0) {
            goto label_0;
        }
        if (eax > 0) {
            goto label_1;
        }
        if (*((ebp - 0x10)) < edx) {
            goto label_0;
        }
        if (*((ebp - 0x10)) > edx) {
            goto label_1;
        }
    }
    eax = 1;
    goto label_2;
label_0:
    eax = 0xffffffff;
    goto label_2;
label_1:
    eax = 3;
label_2:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c010 */
#include <stdint.h>
 
int32_t camlUnix_fun_2632 (void) {
    eax = unix_getgid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806667e */
#include <stdint.h>
 
uint32_t caml_format_int (void) {
    char * format;
    int32_t var_8h_5;
    int32_t var_4h_4;
    int32_t var_8h_4;
    esi = *((ebp + 0xc));
    ecx = ebp - 0x28;
    eax = ebp - 0x49;
    eax = ebp - 0x48;
    edx = 0x8071f03;
    eax = *((ebp + 8));
    eax = parse_format (ebx, esi);
    ebx = eax;
    eax = *((ebp - 0x49));
    if (al != 0x6f) {
        if (al <= 0x6f) {
            if (al != 0x58) {
                goto label_0;
            }
        } else {
            if (al == 0x75) {
                goto label_1;
            }
            if (al != 0x78) {
                goto label_0;
            }
        }
    }
label_1:
    esi >>= 1;
    eax = ebp - 0x28;
    sprintf (ebx, eax, esi);
    goto label_2;
label_0:
    esi >>= 1;
    eax = ebp - 0x28;
    sprintf (ebx, eax, esi);
label_2:
    eax = caml_copy_string (ebx);
    esi = eax;
    eax = ebp - 0x48;
    if (ebx != eax) {
        caml_stat_free (ebx);
    }
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806694f */
#include <stdint.h>
 
int32_t caml_nativeint_mul (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax *= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8057c10 */
#include <stdint.h>
 
int32_t camlHashtbl_find_all_1105 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlHashtbl__find_in_bucket_1108;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            eax = *((edi + 4));
            esi = *((eax - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = caml_hash_univ_param (0x15, 0xc9, ecx);
                eax >>= 1;
                ecx = esi;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            ecx = *((edi + 4));
            eax = *((ecx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ecx + edx*2 - 2));
            void (*0x8056a80)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067028 */
#include <stdint.h>
 
int32_t caml_int32_or (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax |= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e87c */
#include <stdint.h>
 
int32_t unix_lockf (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_1eh;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x1497b;
    eax = *((ebp + 0x10));
    esi = *((ebp + 8));
    esi >>= 1;
    *((ebp - 0x1e)) = 1;
    eax >>= 1;
    if (eax < 0) {
        *((ebp - 0x1c)) = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebp - 0x18)) = edx;
        eax = -eax;
        *((ebp - 0x14)) = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebp - 0x10)) = edx;
    } else {
        *((ebp - 0x1c)) = 0;
        *((ebp - 0x18)) = 0;
        *((ebp - 0x14)) = eax;
        edx = eax;
        edx >>= 0x1f;
        *((ebp - 0x10)) = edx;
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax <= 5) {
        edx = ebx;
        edx -= *((ebx + eax*4 - 0x14914));
        void (*edx)() ();
    }
    errno_location ();
    *(eax) = 0x16;
    eax = ebx - 0x24bc;
    return uerror (eax, 0);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806562d */
#include <stdint.h>
 
int32_t caml_alloc_dummy_float (int32_t arg_8h) {
    int32_t var_4h;
    edx = *((ebp + 8));
    eax = 0x8083504;
    edx &= 0xfffffffe;
    if (edx != 0) {
        caml_alloc (edx, 0);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066ebe */
#include <stdint.h>
 
int32_t caml_int64_neg (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    eax = -eax;
    edx += 0;
    edx = -edx;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fe50 */
#include <stdint.h>
 
int32_t camlPervasives_really_input_1235 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        void (*0x804fdb0)() ();
    }
label_0:
    eax = "really_input";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f018 */
#include <stdint.h>
 
uint32_t unix_readlink (int32_t arg_8h) {
    int32_t var_1008h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x141d8;
    esi = *((ebp + 8));
    *((esp + 8)) = 0xfff;
    eax = ebp - 0x1008;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = readlink ();
    if (eax == -1) {
        eax = ebx - 0x246c;
        uerror (eax, esi);
    }
    *((ebp + eax - 0x1008)) = 0;
    eax = ebp - 0x1008;
    caml_copy_string (eax);
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a674 */
#include <stdint.h>
 
void readlink (void) {
    readlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806700c */
#include <stdint.h>
 
int32_t caml_int32_xor (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax ^= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806680f */
#include <stdint.h>
 
int32_t caml_nativeint_of_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050280 */
#include <stdint.h>
 
int32_t camlPervasives_do_at_exit_1325 (void) {
    eax = .comment;
    ebx = *(eax);
    eax = 1;
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066fd2 */
#include <stdint.h>
 
int32_t caml_int32_shift_right (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c2c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2712 (void) {
    eax = unix_access;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805cd98 */
#include <stdint.h>
 
int32_t unix_execvpe (void) {
    int32_t var_1ch;
    int32_t var_ch_4;
    int32_t var_8h_3;
    int32_t var_4h_3;
    int32_t var_8h_4;
    int32_t var_10h_2;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16458;
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    edi = eax;
    esi = *((ebx - 0x14));
    eax = *(esi);
    *((ebp - 0x1c)) = eax;
    eax = *((ebp + 0x10));
    eax = cstringvect (eax);
    *(esi) = eax;
    *((esp + 4)) = edi;
    eax = *((ebp + 8));
    *(esp) = eax;
    execvp ();
    caml_stat_free (edi);
    eax = *(esi);
    caml_stat_free (eax);
    eax = *((ebp - 0x1c));
    *(esi) = eax;
    eax = *((ebp + 8));
    eax = ebx - 0x25b7;
    return uerror (eax, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066414 */
#include <stdint.h>
 
int32_t caml_int_of_string (int32_t arg_8h) {
    edx = 0x1f;
    eax = *((ebp + 8));
    parse_intnat ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052c00 */
#include <stdint.h>
 
int32_t camlArray_fold_left_1139 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    edi = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x400;
    *(esi) = ebx;
    edx = 1;
    eax = *((ecx - 4));
    ebx = *((ecx - 4));
    ebx &= 0xff;
    if (ebx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    eax += 0xfffffffe;
    if (edx > eax) {
        goto label_3;
    }
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = esi;
    *(esp) = ecx;
    *((esp + 4)) = edi;
    do {
        ecx = *(esp);
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            ebx = *((ecx + edx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + edx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = *(esi);
        ecx = *((esp + 4));
        eax = caml_apply2 ();
        esi = *((esp + 0xc));
        caml_modify (esi, eax);
        edx = *((esp + 0xc));
        ebx = *((esp + 0xc));
        edx += 2;
        *((esp + 0xc)) = edx;
        eax = *((esp + 0x10));
    } while (ebx != eax);
label_3:
    eax = *(esi);
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80591b0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1568 (void) {
    ecx = eax;
    edx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            eax = *((edx + 0x10));
            *((ebx + 4)) = eax;
            ecx = *((edx + 8));
            eax = *((edx + 0xc));
            eax += 2;
            void (*0x8059d40)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80630d9 */
#include <stdint.h>
 
int32_t caml_fatal_error (char * s) {
    FILE * stream;
    eax = stderr;
    eax = *((ebp + 8));
    fputs (eax, eax);
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049dd4 */
#include <stdint.h>
 
void fputs (void) {
    fputs ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c854 */
#include <stdint.h>
 
uint32_t unix_inet_addr_of_string (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1699f;
    esi = *((ebp + 8));
    eax = ebp - 0xc;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 2;
    eax = inet_pton ();
    if (eax > 0) {
        eax = ebp - 0xc;
        alloc_inet_addr (eax);
    } else {
        eax = ebp - 0x1c;
        *((esp + 8)) = eax;
        *((esp + 4)) = esi;
        *(esp) = 0xa;
        eax = inet_pton ();
        if (eax > 0) {
            eax = ebp - 0x1c;
            alloc_inet6_addr (eax);
        } else {
            eax = ebx - 0x260a;
            caml_failwith (eax);
        }
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80668b3 */
#include <stdint.h>
 
int32_t caml_nativeint_and (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax &= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054830 */
#include <stdint.h>
 
int32_t camlList_iter2_1111 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        caml_apply2 (edx, eax, eax);
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_0:
    if (ecx == 1) {
        eax = 1;
        return eax;
    }
label_1:
    eax = "List.iter2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c030 */
#include <stdint.h>
 
int32_t camlUnix_fun_2636 (void) {
    eax = unix_geteuid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c1d0 */
#include <stdint.h>
 
int32_t camlPrintf_fprintf_1391 (void) {
    ebx = eax;
    eax = loc.camlPrintf__43;
    return camlPrintf_kfprintf_1386 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80571e0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_all_1210 (void) {
    int32_t var_4h_4;
    int32_t var_8h_2;
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlHashtbl__find_in_bucket_1213;
            *((eax + 4)) = 3;
            esi = *((ecx + 0xc));
            *((eax + 8)) = esi;
            *((eax + 0xc)) = ebx;
            esi = *((edx + 4));
            esi = *((esi - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = *((ecx + 0x10));
                eax = *((eax + 8));
                edx = *((eax + 4));
                ecx = *(edx);
                eax = ebx;
                ebx = edx;
                eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, esi);
                ebx = 0x7fffffff;
                eax &= ebx;
                eax >>= 1;
                ecx = *((esp + 8));
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            eax = *(esp);
            ebx = *((eax + 4));
            eax = *((ebx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ebx + edx*2 - 2));
            ebx = *((esp + 4));
            void (*0x80566e0)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80537f0 */
#include <stdint.h>
 
int32_t camlList_part_1215 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
label_0:
        *((esp + 4)) = eax;
        if (ecx == 1) {
            goto label_3;
        }
        eax = *((ecx + 4));
        eax = *(ecx);
        ebx = *((edx + 0xc));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t, uint32_t) (edx, ebx);
        if (eax == 1) {
            goto label_1;
        }
label_2:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        ebx = *((esp + 4));
        *((eax + 4)) = ebx;
        ebx = *((esp + 8));
        ecx = *((esp + 0xc));
        edx = *((esp + 0x10));
    } while (1);
label_1:
    eax = caml_young_ptr;
    eax -= 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x800;
    eax = *(esp);
    *(ebx) = eax;
    eax = *((esp + 8));
    *((ebx + 4)) = eax;
    eax = *((esp + 4));
    ecx = *((esp + 0xc));
    edx = *((esp + 0x10));
    goto label_0;
label_3:
    ecx = 1;
    eax = ebx;
    ebx = ecx;
    eax = camlList_rev_append_1051 ();
    ebx = 1;
    eax = *((esp + 4));
    eax = camlList_rev_append_1051 (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *(esp);
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
label_4:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804e1c0 */
#include <stdint.h>
 
uint32_t camlUnix_open_connection_2018 (int32_t arg_ch) {
    int32_t var_4h;
    eax = camlUnix_domain_of_sockaddr_1529 (eax);
    eax = unix_socket;
    eax = caml_c_call (eax);
    eax = void (*0x804e210)(uint32_t) (eax);
    *(esp) = eax;
    eax = *((esp + 4));
    eax = unix_close;
    caml_c_call (eax);
    eax = *(esp);
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ebx = *((esp + 8));
    eax = unix_connect;
    caml_c_call (eax);
    eax = *((esp + 0xc));
    camlUnix_try_set_close_on_exec_1366 ();
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    *((esp + 8)) = eax;
    eax = *((esp + 0xc));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *((esp + 8));
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c8b0 */
#include <stdint.h>
 
int32_t camlUnix_domain_of_sockaddr_1529 (void) {
    ebx = *((eax - 4));
    if (ebx != 0) {
        ebx = *(eax);
        eax = *((ebx - 4));
        eax >>= 0xa;
        eax = eax*4 - 1;
        ebx = *((ebx + eax));
        eax -= ebx;
        eax = eax + eax + 1;
        if (eax == 0x21) {
            eax = 5;
            return eax;
        }
        eax = 3;
        return eax;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c800 */
#include <stdint.h>
 
uint32_t camlUnix_try_set_close_on_exec_1366 (void) {
    eax = void (*0x804c830)() ();
    ecx = "P5\a\b";
    ebx = *(eax);
    if (ebx == ecx) {
        eax = 1;
        return eax;
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_set_close_on_exec;
    caml_c_call (eax);
    eax = 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069b8d */
#include <stdint.h>
 
int32_t caml_serialize_block_1 (int32_t arg_8h, int32_t arg_ch) {
    void ** s2;
    size_t * n;
    eax = *((ebp + 0xc));
    ebx = *((ebp + 0xc));
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    eax = *((ebp + 8));
    eax = extern_ptr;
    memmove (eax, eax, ebx);
    *(obj.extern_ptr) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806696c */
#include <stdint.h>
 
int32_t caml_nativeint_sub (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = *((ebp + 0xc));
    eax -= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bda0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2863 (void) {
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060633 */
#include <stdint.h>
 
uint32_t unix_fstat_64 (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12bc5;
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = 3;
    eax = fxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x231e;
        uerror (eax, 0);
    }
    edx = ebp - 0x68;
    eax = 1;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a714 */
#include <stdint.h>
 
void fxstat64 (void) {
    fxstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c2e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2716 (void) {
    eax = unix_fchown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fdf2 */
#include <stdint.h>
 
int32_t caml_dlopen (int32_t arg_8h, int32_t arg_10h) {
    int32_t var_4h;
    eax = *((ebp + 0x10));
    eax -= eax;
    al = 0;
    eax += 0x1102;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    dlopen ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a494 */
#include <stdint.h>
 
void dlopen (void) {
    dlopen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80551c0 */
#include <stdint.h>
 
int32_t camlList_stable_sort_1248 (void) {
    int32_t var_4h;
    esi = eax;
    *((esp + 4)) = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x54;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x8053910;
            *((edx + 0xc)) = esi;
            ecx = edx + 0x14;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry3;
            *((ecx + 4)) = 7;
            *((ecx + 8)) = 0x8053a10;
            *((ecx + 0xc)) = esi;
            eax = edx + 0x28;
            *((eax - 4)) = 0x28f7;
            *(eax) = sym.caml_curry2;
            *((eax + 4)) = 5;
            *((eax + 8)) = 0x8053fd0;
            *((eax + 0xc)) = 0x10f9;
            *((eax + 0x10)) = 0x804b370;
            *((eax + 0x14)) = 5;
            *((eax + 0x18)) = 0x8053b10;
            *((eax + 0x1c)) = esi;
            *((eax + 0x20)) = edx;
            *((eax + 0x24)) = ecx;
            eax = 1;
            eax = camlList_length_aux_1030 (eax);
            if (eax < 5) {
                eax = *((esp + 4));
                return eax;
            }
            ebx = *((esp + 4));
            ecx = *(esp);
            void (*0x8053fd0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f0d8 */
#include <stdint.h>
 
int32_t unix_rewinddir (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14120;
    eax = *((ebp + 8));
    eax = *(eax);
    if (eax == 0) {
        eax = ebx - 0x245c;
        eax = unix_error (9, eax, 0);
    }
    *(esp) = eax;
    rewinddir ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a544 */
#include <stdint.h>
 
void rewinddir (void) {
    rewinddir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bc81 */
#include <stdint.h>
 
uint32_t caml_sys_file_exists (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_4h;
    int32_t var_8h;
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    *((esp + 4)) = eax;
    *(esp) = 3;
    eax = xstat64 ();
    eax -= eax;
    eax &= 2;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066f5b */
#include <stdint.h>
 
int32_t caml_int32_of_string (int32_t arg_8h) {
    edx = 0x20;
    eax = *((ebp + 8));
    eax = parse_intnat ();
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e82c */
#include <stdint.h>
 
int32_t unix_listen (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x149cc;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = listen (eax, eax);
    if (eax == -1) {
        eax = ebx - 0x24c3;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a034 */
#include <stdint.h>
 
void listen (void) {
    listen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070b30 */
#include <stdint.h>
 
uint32_t libc_csu_init (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x26c9;
    _init ();
    edi = ebx - 0x14c;
    eax = ebx - 0x14c;
    edi -= eax;
    edi >>= 2;
    if (edi == 0) {
        goto label_0;
    }
    esi = 0;
    do {
        eax = *((ebp + 0x10));
        eax = *((ebp + 0xc));
        eax = *((ebp + 8));
        uint32_t (*ebx + esi*4 - 0x14c)(uint32_t, uint32_t, uint32_t) (eax, eax, eax);
        esi++;
    } while (esi < edi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055940 */
#include <stdint.h>
 
int32_t camlString_iter_1062 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = 1;
    edx = *((ebx - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    esi = *((ebx + edx));
    edx -= esi;
    edx = edx + edx - 1;
    if (ecx > edx) {
        goto label_0;
    }
    do {
        ecx >>= 1;
        eax = *(esp);
        eax = *((eax + ecx));
        eax = eax + eax + 1;
        ebx = *((esp + 4));
        ecx = *(ebx);
        void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, ecx);
        ecx = *((esp + 8));
        ebx = *((esp + 8));
        ecx += 2;
        *((esp + 8)) = ecx;
        eax = *((esp + 0xc));
    } while (ebx != eax);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805dc00 */
#include <stdint.h>
 
int32_t unix_getnameinfo (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_14bch;
    int32_t var_14b8h;
    int32_t var_10b8h;
    int32_t var_b8h;
    int32_t var_b4h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x155f3;
    eax = *((ebx - 0x18));
    edi = *(eax);
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x44)) = edi;
    edx = ebp - 0x44;
    *(eax) = edx;
    *((ebp - 0x3c)) = 1;
    *((ebp - 0x40)) = 3;
    eax = ebp - 0x1c;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x30)) = eax;
    eax = ebp - 0xb8;
    esi = ebp - 0xb4;
    eax = *((ebp + 8));
    get_sockaddr (eax, esi, eax);
    eax = ebx + 0x938c;
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x14bc)) = eax;
    caml_enter_blocking_section ();
    eax = *((ebp - 0x14bc));
    *((esp + 0x18)) = eax;
    *((esp + 0x14)) = 0x400;
    eax = ebp - 0x14b8;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = 0x1000;
    eax = ebp - 0x10b8;
    *((esp + 8)) = eax;
    eax = *((ebp - 0xb8));
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = getnameinfo ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi != 0) {
        caml_raise_not_found ();
    }
    eax = ebp - 0x10b8;
    eax = caml_copy_string (eax);
    *((ebp - 0x1c)) = eax;
    eax = ebp - 0x14b8;
    eax = caml_copy_string (eax);
    *((ebp - 0x20)) = eax;
    eax = caml_alloc_small (2, 0);
    *((ebp - 0x24)) = eax;
    edx = *((ebp - 0x1c));
    *(eax) = edx;
    edx = *((ebp - 0x20));
    eax = *((ebp - 0x24));
    *((eax + 4)) = edx;
    eax = *((ebx - 0x18));
    *(eax) = edi;
    eax = *((ebp - 0x24));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a6a4 */
#include <stdint.h>
 
void getnameinfo (void) {
    getnameinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804be00 */
#include <stdint.h>
 
int32_t camlUnix_fun_2572 (void) {
    eax = unix_tcsetattr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ff80 */
#include <stdint.h>
 
uint32_t camlPervasives_print_float_1272 (void) {
    eax = camlPervasives_string_of_float_1140 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e3c7 */
#include <stdint.h>
 
int32_t caml_register_named_value (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_1ch;
    char * src;
    esi = *((ebp + 8));
    eax = *((ebp + 8));
    eax = hash_value_name (ebx, esi, edi);
    *((ebp - 0x1c)) = eax;
    ebx = *((eax*4 + obj.named_value_table));
    if (ebx == 0) {
        goto label_0;
    }
    do {
        eax = ebx + 8;
        eax = strcmp (esi, eax);
        if (eax == 0) {
            eax = *((ebp + 0xc));
            *(ebx) = eax;
            goto label_1;
        }
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    edi = esi;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ecx += 0xb;
    eax = caml_stat_alloc (ecx);
    ebx = eax;
    eax = eax + 8;
    strcpy (eax, esi);
    edx = *((ebp + 0xc));
    *(ebx) = edx;
    eax = named_value_table;
    ecx = *((ebp - 0x1c));
    edx = *((eax + ecx*4));
    *((ebx + 4)) = edx;
    *((eax + ecx*4)) = ebx;
    caml_register_global_root (ebx);
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c110 */
#include <stdint.h>
 
int32_t camlUnix_fun_2662 (void) {
    eax = unix_sigsuspend;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066916 */
#include <stdint.h>
 
int32_t caml_nativeint_div (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    ecx = *((ebp + 0xc));
    ecx = *((ecx + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            goto label_0;
        }
    }
    eax = edx;
    edx >>= 0x1f;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    caml_copy_nativeint (eax);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050c60 */
#include <stdint.h>
 
int32_t camlArray_maxson_1155 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = ebx;
    eax += ebx;
    esi = eax + ebx + 3;
    esi += 0xfffffffd;
    *((esp + 8)) = esi;
label_6:
    eax = caml_young_ptr;
    eax -= 8;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_7;
    }
    edi = eax + 4;
    *((edi - 4)) = 0x400;
    *(edi) = esi;
    eax = esi;
    eax += 4;
    if (eax < edx) {
        *((esp + 4)) = edi;
        *(esp) = ecx;
        edx = esi;
        edx += 2;
        edi = *((ecx + 0x10));
        eax = *((edi - 4));
        ebx = *((edi - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            eax >>= 9;
            if (eax <= edx) {
                goto label_8;
            }
            ebx = *((edi + edx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= edx) {
                goto label_9;
            }
label_5:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((edi + edx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        edx = *((ecx + 0x10));
        eax = *((edx - 4));
        edi = *((edx - 4));
        edi &= 0xff;
        if (edi != 0xfe) {
            eax >>= 9;
            if (eax <= esi) {
                goto label_11;
            }
            eax = *((edx + esi*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_12;
            }
label_4:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_13;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + esi*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((ecx + 0xc));
        eax = caml_apply2 ();
        if (eax < 1) {
            ebx = *((esp + 8));
            ebx += 2;
            eax = *((esp + 4));
            *(eax) = ebx;
        }
        ecx = *((esp + 8));
        ecx += 4;
        esi = *(esp);
        edx = *((esi + 0x10));
        eax = *((edx - 4));
        ebx = *((edx - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_14;
            }
            ebx = *((edx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_15;
            }
label_3:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_16;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ecx*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 4));
        edx = *(eax);
        ecx = *((esi + 0x10));
        eax = *((ecx - 4));
        edi = *((ecx - 4));
        edi &= 0xff;
        if (edi != 0xfe) {
            eax >>= 9;
            if (eax <= edx) {
                goto label_17;
            }
            eax = *((ecx + edx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= edx) {
                goto label_18;
            }
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_19;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + edx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((esi + 0xc));
        eax = caml_apply2 ();
        if (eax < 1) {
            ebx = *((esp + 8));
            ebx += 4;
            eax = *((esp + 4));
            *(eax) = ebx;
        }
        eax = *((esp + 4));
        eax = *(eax);
        return eax;
    }
    *((esp + 4)) = ebx;
    *(esp) = edx;
    eax = esi;
    eax += 2;
    if (eax < edx) {
        ebx = esi;
        ebx += 2;
        edx = *((ecx + 0x10));
        edi = *((edx - 4));
        eax = *((edx - 4));
        eax &= 0xff;
        if (eax != 0xfe) {
            eax = edi;
            eax >>= 9;
            if (eax <= ebx) {
                goto label_20;
            }
            ebx = *((edx + ebx*2 - 2));
        } else {
            eax = edi;
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_21;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_22;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ebx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            ebx = eax;
        }
        edx = *((ecx + 0x10));
        edi = *((edx - 4));
        eax = *((edx - 4));
        eax &= 0xff;
        if (eax != 0xfe) {
            eax = edi;
            eax >>= 9;
            if (eax <= esi) {
                goto label_23;
            }
            eax = *((edx + esi*2 - 2));
        } else {
            eax = edi;
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_24;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_25;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + esi*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((ecx + 0xc));
        eax = caml_apply2 ();
        if (eax >= 1) {
            goto label_26;
        }
        eax = *((esp + 8));
        eax += 2;
        return eax;
    }
label_26:
    eax = *((esp + 8));
    ebx = *(esp);
    if (eax >= ebx) {
        goto label_27;
    }
    return eax;
    do {
label_27:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = .comment;
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_25:
    caml_call_gc ();
    goto label_0;
label_22:
    caml_call_gc ();
    goto label_1;
label_19:
    caml_call_gc ();
    goto label_2;
label_16:
    caml_call_gc ();
    goto label_3;
label_13:
    caml_call_gc ();
    goto label_4;
label_10:
    caml_call_gc ();
    goto label_5;
label_7:
    caml_call_gc ();
    goto label_6;
label_24:
    caml_ml_array_bound_error ();
label_23:
    caml_ml_array_bound_error ();
label_21:
    caml_ml_array_bound_error ();
label_20:
    caml_ml_array_bound_error ();
label_18:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f7d7 */
#include <stdint.h>
 
uint32_t unix_recv (int32_t socket, void * s1, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    int32_t var_4038h;
    int32_t var_4034h;
    int32_t var_4030h;
    int32_t var_402ch;
    int32_t var_4018h;
    void * buffer;
    size_t length;
    int32_t flags;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x13a1c;
    eax = ebx + 0x93ec;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    edi = eax;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4038)) = edx;
    edx = ebp - 0x4038;
    *(eax) = edx;
    *((ebp - 0x4030)) = 1;
    *((ebp - 0x4034)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x402c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    caml_enter_blocking_section ();
    *((esp + 0xc)) = edi;
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    *((esp + 8)) = esi;
    eax = ebp - 0x4018;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = recv (eax, eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x2430;
        uerror (eax, 0);
    }
    eax = ebp - 0x4018;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    memmove (eax, eax, esi);
    edx = *((ebp - 0x4038));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = esi + esi + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049fb4 */
#include <stdint.h>
 
void recv (void) {
    recv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806534a */
#include <stdint.h>
 
uint32_t caml_update_dummy (int32_t arg_8h, int32_t arg_ch) {
    uint32_t var_1ch;
    int32_t var_4h;
    edi = *((ebp + 0xc));
    eax = edi - 4;
    ecx = *(eax);
    edx = *(eax);
    esi = *((ebp + 8));
    *((esi - 4)) = dl;
    if (dl != 0xfe) {
        ecx >>= 0xa;
        *((ebp - 0x1c)) = ecx;
        ebx = 0;
        if (ecx != 0) {
            goto label_0;
        }
        goto label_1;
    }
    edx = *(eax);
    edx >>= 0xb;
    if (edx == 0) {
        goto label_1;
    }
    eax = 0;
    do {
        *(fp_stack--) = *((edi + eax*8));
        *((esi + eax*8)) = fp_stack[0];
        fp_stack--;
        eax++;
    } while (edx > eax);
    goto label_1;
    do {
label_0:
        eax = *((edi + ebx*4));
        caml_modify (esi, eax);
        ebx++;
        esi += 4;
    } while (*((ebp - 0x1c)) > ebx);
label_1:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ee30 */
#include <stdint.h>
 
int32_t unix_putenv (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void * s2;
    size_t n;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x143c0;
    eax = *((ebp + 8));
    eax = caml_string_length (eax);
    edi = eax;
    eax = *((ebp + 0xc));
    eax = caml_string_length (eax);
    *((ebp - 0x1c)) = eax;
    eax += edi;
    *((ebp - 0x20)) = eax;
    eax += 2;
    eax = caml_stat_alloc (eax);
    esi = eax;
    eax = *((ebp + 8));
    memmove (esi, eax, edi);
    *((esi + edi)) = 0x3d;
    eax = *((ebp - 0x1c));
    eax = *((ebp + 0xc));
    eax = esi + edi + 1;
    memmove (eax, eax, eax);
    eax = *((ebp - 0x20));
    *((esi + eax + 1)) = 0;
    *(esp) = esi;
    eax = putenv ();
    if (eax == -1) {
        eax = *((ebp + 8));
        eax = ebx - 0x2480;
        uerror (eax, eax);
    }
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a4e4 */
#include <stdint.h>
 
void putenv (void) {
    putenv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065652 */
#include <stdint.h>
 
int32_t caml_alloc_dummy (int32_t arg_8h) {
    int32_t var_4h;
    edx = *((ebp + 8));
    eax = 0x8083504;
    edx >>= 1;
    if (edx != 0) {
        caml_alloc (edx, 0);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059e30 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1587 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_10h_2;
    int32_t var_14h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    *((esp + 0x18)) = eax;
    *((esp + 0x14)) = ebx;
    *((esp + 0x10)) = ecx;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = esi;
    *((esp + 4)) = edi;
    eax = caml_extra_params;
    *(esp) = eax;
    eax = caml_make_vect;
    eax = caml_c_call (0xd);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 0x18));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 0x18));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 0x14));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 0x14));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 5) {
            goto label_4;
        }
        eax = *((esp + 0x10));
        eax = ebx;
        eax += 8;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 5) {
            goto label_5;
        }
        eax = *((esp + 0x10));
        *(fp_stack--) = *(eax);
        *((ebx + 0x10)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 7) {
            goto label_6;
        }
        eax = *((esp + 0xc));
        eax = ebx;
        eax += 0xc;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 7) {
            goto label_7;
        }
        eax = *((esp + 0xc));
        *(fp_stack--) = *(eax);
        *((ebx + 0x18)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 9) {
            goto label_8;
        }
        eax = *((esp + 8));
        eax = ebx;
        eax += 0x10;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 9) {
            goto label_9;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *((ebx + 0x20)) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 0xb) {
            goto label_10;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 0x14;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 0xb) {
            goto label_11;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 0x28)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b540)() ();
label_11:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050950 */
#include <stdint.h>
 
int32_t camlArray_size_1065 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ebx = *((ebx - 4));
        edx = *((ebx - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            ebx >>= 9;
        } else {
            ebx >>= 0xa;
        }
        ebx |= 1;
        eax += ebx;
        eax--;
        ebx = ecx;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064c7e */
#include <stdint.h>
 
int32_t caml_alloc_dependent_memory (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 2;
    *(obj.caml_dependent_size) += eax;
    *(obj.caml_dependent_allocated) += eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064e48 */
#include <stdint.h>
 
int32_t caml_adjust_gc_speed (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10h;
    int32_t var_ch;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    ecx = 1;
    if (eax == 0) {
        eax = ecx;
    }
    if (eax <= edx) {
        edx = eax;
    }
    ecx = 0;
    *((ebp - 0x10)) = edx;
    *((ebp - 0xc)) = ecx;
    *(fp_stack--) = *((ebp - 0x10));
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    fp_stack[0] += *(obj.caml_extra_heap_resources);
    *(obj.caml_extra_heap_resources) = fp_stack[0];
    *(fp_stack--) = 1.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        *(fp_stack--) = 1.0;
        *(obj.caml_extra_heap_resources) = fp_stack[0];
        fp_stack--;
        caml_urge_major_slice ();
    }
    eax = caml_minor_heap_size;
    eax >>= 2;
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] *= *(0x8071410);
    eax = caml_stat_heap_size;
    eax >>= 2;
    edx = 0;
    *((ebp - 0x10)) = eax;
    *((ebp - 0xc)) = edx;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] /= fp_stack[1];
    fp_stack++;
    *(fp_stack--) = *(obj.caml_extra_heap_resources);
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        caml_urge_major_slice ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c130 */
#include <stdint.h>
 
int32_t camlUnix_fun_2666 (void) {
    eax = unix_sigprocmask;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d174 */
#include <stdint.h>
 
int32_t unix_ftruncate_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x16084;
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    *((esp + 4)) = eax;
    *((esp + 8)) = edx;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = ftruncate64 ();
    if (eax == -1) {
        eax = ebx - 0x255b;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ab40 */
#include <stdint.h>
 
int32_t caml_curry9_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b390 */
#include <stdint.h>
 
uint32_t camlPrintf_bad_conversion_1057 (void) {
    ebx = loc.camlPrintf__52;
    eax = camlPervasives_$5e_1112 (ebx, ecx);
    ebx = eax;
    eax = " in format string ``";
    eax = camlPervasives_$5e_1112 ();
    eax = *(esp);
    camlPervasives_string_of_int_1130 (eax);
    ebx = *((esp + 4));
    eax = camlPervasives_$5e_1112 ();
    ebx = eax;
    eax = ", at char number ";
    eax = camlPervasives_$5e_1112 ();
    eax = 3;
    ebx = *((esp + 8));
    camlString_make_1038 (eax);
    ebx = *(esp);
    eax = camlPervasives_$5e_1112 ();
    ebx = eax;
    eax = "Printf: bad conversion %";
    camlPervasives_$5e_1112 ();
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c490 */
#include <stdint.h>
 
int32_t camlUnix_fun_2762 (void) {
    eax = unix_waitpid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80626d7 */
#include <stdint.h>
 
int32_t caml_register_generational_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = *(edx);
    if ((al & 1) != 0) {
        goto label_0;
    }
    if (eax >= *(obj.caml_young_end)) {
        goto label_1;
    }
    if (eax <= *(obj.caml_young_start)) {
        goto label_1;
    }
    eax = caml_global_roots_young;
    caml_insert_global_root ();
    goto label_0;
    do {
        eax = caml_global_roots_old;
        eax = caml_insert_global_root ();
        goto label_0;
label_1:
        ecx = eax;
        ecx >>= 0x17;
        eax >>= 0xc;
        eax &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
    } while ((*((ecx + eax)) & 1) != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c4b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2766 (void) {
    eax = unix_fork;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066d12 */
#include <stdint.h>
 
int32_t caml_int64_and (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 4));
    ecx &= *((eax + 4));
    edx = *((edx + 8));
    edx &= *((eax + 8));
    caml_copy_int64 (ecx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806202d */
#include <stdint.h>
 
int32_t caml_register_dyn_global (int32_t arg_8h) {
    edx = caml_dyn_globals;
    eax = *((ebp + 8));
    eax = cons ();
    *(obj.caml_dyn_globals) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bf50 */
#include <stdint.h>
 
int32_t camlUnix_fun_2608 (void) {
    eax = unix_string_of_inet_addr;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80556c0 */
#include <stdint.h>
 
int32_t camlString_fun_1163 (void) {
    esi = eax;
    ecx = *((ebx + 8));
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((ecx + eax));
    eax -= ecx;
    eax = *((ebx + 0x10));
    caml_blit_string (*((ebx + 8)), 1, *((ebx + 0xc)), *(eax), eax + eax + 1);
    eax = *((ebx + 0x10));
    edi = *((ebx + 8));
    ecx = *((edi - 4));
    ecx >>= 0xa;
    edx = ecx*4 - 1;
    ecx = *((edi + edx));
    edx -= ecx;
    ecx = *((ebx + 0x10));
    ecx = *(ecx);
    ecx = ecx + edx*2;
    *(eax) = ecx;
    eax = *((esi - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((esi + eax));
    eax -= ecx;
    eax = *((ebx + 0x10));
    caml_blit_string (esi, 1, *((ebx + 0xc)), *(eax), eax + eax + 1);
    eax = *((ebx + 0x10));
    ecx = *((esi - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((esi + ecx));
    ecx -= edx;
    ebx = *((ebx + 0x10));
    ebx = *(ebx);
    ebx = ebx + ecx*2;
    *(eax) = ebx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804be30 */
#include <stdint.h>
 
int32_t camlUnix_fun_2576 (void) {
    eax = unix_getservbyport;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8053760 */
#include <stdint.h>
 
int32_t camlList_find_1207 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
label_0:
        if (ebx == 1) {
            goto label_2;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = *((ecx + 0xc));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (ecx, eax, eax);
        if (eax == 1) {
            goto label_3;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x800;
        ebx = *(esp);
        *(eax) = ebx;
        ebx = *((esp + 4));
        *((eax + 4)) = ebx;
        ebx = *((esp + 8));
        ecx = *((esp + 0xc));
    } while (1);
label_3:
    eax = *((esp + 4));
    ebx = *((esp + 8));
    ecx = *((esp + 0xc));
    goto label_0;
label_2:
    ebx = 1;
    void (*0x8054520)() ();
label_4:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067dd0 */
#include <stdint.h>
 
int32_t caml_array_unsafe_set_float (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebp + 0x10));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 8));
    *((eax + edx*8)) = fp_stack[0];
    fp_stack--;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b1f0 */
#include <stdint.h>
 
int32_t caml_curry4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry4_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80501b0 */
#include <stdint.h>
 
int32_t camlPervasives_5e_5e_1312 (void) {
    eax = loc.camlPervasives__85;
    eax = camlPervasives_$5e_1112 (eax);
    ebx = eax;
    eax = *(esp);
    return camlPervasives_5e_1112 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066f2a */
#include <stdint.h>
 
int32_t caml_int64_to_int32 (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806871c */
#include <stdint.h>
 
int32_t caml_finalize_channel (int32_t arg_8h) {
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = *((ebx + 0x2c));
    eax--;
    *((ebx + 0x2c)) = eax;
    if (eax <= 0) {
        eax = caml_channel_mutex_free;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        eax = ebx;
        unlink_channel ();
        caml_stat_free (ebx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052960 */
#include <stdint.h>
 
int32_t camlArray_mapi_1115 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ecx = eax;
    eax = *((ebx - 4));
    edx = *((ebx - 4));
    edx &= 0xff;
    if (edx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    if (eax == 1) {
        eax = loc.camlArray__23;
        return eax;
    }
    *(esp) = eax;
    *((esp + 4)) = ebx;
    *((esp + 8)) = ecx;
    eax = *((ebx - 4));
    if (eax != 0xfe) {
        ebx = *(ebx);
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        edx = eax + 4;
        *((edx - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(edx) = fp_stack[0];
        fp_stack--;
        ebx = edx;
    }
    eax = 1;
    eax = caml_apply2 ();
    eax = *((esp + 4));
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    esi = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (esi > eax) {
        goto label_3;
    }
    *((esp + 0xc)) = eax;
    *((esp + 0x10)) = esi;
    *(esp) = ebx;
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            ebx = *((ecx + esi*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + esi*4 - 4));
            *(ebx) = fp_stack[0];
            fp_stack--;
        }
        eax = esi;
        ecx = *((esp + 8));
        eax = caml_apply2 ();
        ebx = *(esp);
        ecx = *((ebx - 4));
        if (ecx != 0xfe) {
            esi = *((esp + 0x14));
            eax = caml_modify (ebx + esi*2 - 2, eax);
        } else {
            *(fp_stack--) = *(eax);
            esi = *((esp + 0x10));
            *((ebx + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = esi;
        esi += 2;
        *((esp + 0x10)) = esi;
        eax = *((esp + 0xc));
    } while (ecx != eax);
label_3:
    eax = ebx;
    return eax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055eb0 */
#include <stdint.h>
 
int32_t camlString_map_1090 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx + 1;
    if (ecx == 1) {
        eax = ebx;
        return eax;
    }
    *(esp) = ecx;
    *((esp + 4)) = ebx;
    *((esp + 8)) = eax;
    eax = caml_create_string;
    eax = caml_c_call (ecx);
    ebx = 1;
    ecx = *(esp);
    ecx += 0xfffffffe;
    if (ebx > ecx) {
        goto label_0;
    }
    do {
        ebx >>= 1;
        eax = *((esp + 4));
        eax = *((eax + ebx));
        eax = eax + eax + 1;
        ebx = *((esp + 8));
        ecx = *(ebx);
        eax = void (*ecx)(uint32_t) (ecx);
        eax >>= 1;
        ebx = *(esp);
        ecx = *(esp);
        ecx >>= 1;
        edx = eax;
        eax = *((esp + 0xc));
        *((eax + ecx)) = dl;
        edx = ebx;
        ebx += 2;
        *(esp) = ebx;
        ecx = *((esp + 0x10));
    } while (edx != ecx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80598c0 */
#include <stdint.h>
 
int32_t camlPrintf_scan_conv_1143 (int32_t arg_ch, int32_t arg_ch_2, int32_t arg_4h, int32_t arg_4h_2, int32_t arg_8h, int32_t arg_ch_3) {
    int32_t var_4h_2;
    int32_t var_4h;
label_2:
    do {
        edx = ecx;
        ecx = *((edx + 0x24));
        if (ebx > ecx) {
            eax = *((edx + 0x18));
            void (*0x805b440)() ();
        }
        esi = ebx;
        esi >>= 1;
        ecx = *((edx + 0x18));
        ecx = *((ecx + esi));
        ecx = ecx + ecx + 1;
        if (ecx >= 0xfd) {
            goto label_3;
        }
        esi = ecx;
        esi >>= 1;
        /* switch table (254 cases) at 0x807ac94 */
        edx = *((edx + 0x1c));
        caml_apply3 (edx, eax);
        ebx = *((esp + 0xc));
        ebx += 0x10;
        void (*0x8059840)() ();
        edx = *((edx + 0x1c));
        eax = caml_apply3 (ecx);
        eax = *(esp);
        eax = camlPrintf_sub_format_for_printf_1135 (eax);
        ecx = eax;
        eax = *((esp + 0xc));
        eax = *((eax + 0x18));
        ebx = *((esp + 4));
        eax = caml_apply2 ();
        edx = eax;
        *(esp) = edx;
label_0:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_4;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x14f7;
        *(ecx) = sym.camlPrintf__loop_1159;
        *((ecx + 4)) = 3;
        eax = *((esp + 0xc));
        ebx = *((eax + 0x18));
        *((ecx + 8)) = ebx;
        eax = *((eax + 0x20));
        *((ecx + 0xc)) = eax;
        *((ecx + 0x10)) = edx;
        eax = *((esp + 4));
        ebx = ecx;
        camlPrintf_loop_1159 ();
        ebx = *(esp);
        ebx += 0xfffffffe;
        eax = *((esp + 8));
        ecx = *((esp + 0xc));
    } while (1);
label_3:
    eax = *((edx + 0x18));
    void (*0x805b400)() ();
    eax = ebx;
    eax += 2;
    return eax;
    edx = *((edx + 0x1c));
    ecx = 0xe7;
    void (*0x804b4f0)() ();
    edx = *((edx + 0x1c));
    ecx = 0xc7;
    void (*0x804b4f0)() ();
    edx = *((edx + 0x1c));
    ecx = 0xd3;
    void (*0x804b4f0)() ();
    edx = *((edx + 0x1c));
    ecx = 0xcd;
    void (*0x804b4f0)() ();
    edx = *((edx + 0x1c));
    ecx = 0x85;
    void (*0x804b4f0)() ();
    edx = *((edx + 0x1c));
    void (*0x804b4f0)() ();
    edi = ebx;
    edi += 2;
    esi = *((edx + 0x24));
    if (edi > esi) {
        edx = *((edx + 0x1c));
        ecx = 0xd3;
        void (*0x804b4f0)() ();
    }
    *(esp) = ecx;
    esi = *((edx + 0x18));
    ecx = edi;
    ecx >>= 1;
    edi = *((esi - 4));
    edi >>= 0xa;
    ebp = edi*4 - 1;
    edi = *((esi + ebp));
    ebp -= edi;
    if (ebp > ecx) {
        ecx = *((esi + ecx));
        ecx = ecx + ecx + 1;
        ecx += 0xffffff50;
        if (ecx <= 0x41) {
            *((esp + 0xc)) = edx;
            ecx >>= 1;
            /* switch table (66 cases) at 0x807ae8c */
        }
        edx = *((edx + 0x1c));
        ecx = 0xd3;
        void (*0x804b4f0)() ();
        edx = *((edx + 0x1c));
        ecx = *(esp);
        caml_apply3 ();
        ebx = *((esp + 0xc));
        ecx = *((ebx + 0x20));
        ebx = 0xd3;
        void (*0x804b540)() ();
        edx = *((edx + 0x1c));
        void (*0x804b4f0)() ();
label_4:
        caml_call_gc ();
        goto label_0;
    }
    caml_ml_array_bound_error ();
    do {
label_1:
        edx = *((ecx + 0x34));
        if (ebx > edx) {
            eax = *((ecx + 0x28));
            void (*0x805b440)() ();
        }
        esi = ebx;
        esi >>= 1;
        edx = *((ecx + 0x28));
        edx = *((edx + esi));
        edx = edx + edx + 1;
        if (edx < 0x75) {
            goto label_5;
        }
        if (edx != 0xbf) {
            goto label_6;
        }
        ebx += 2;
        eax = 3;
    } while (1);
label_5:
    if (edx >= 0x41) {
        edx += 0xffffffc0;
        edx >>= 1;
        /* switch table (66 cases) at 0x807af10 */
        edx = *((ecx + 0x2c));
        ecx = 0xd3;
        eax = caml_apply3 (eax, ecx);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
        goto label_1;
    }
label_6:
    ecx += 0x10;
    goto label_2;
    ebx += 2;
    goto label_1;
    ebx += 2;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806d101 */
#include <stdint.h>
 
int32_t caml_gc_stat (void) {
    int32_t var_94h;
    int32_t var_90h;
    uint32_t var_8ch;
    int32_t var_88h;
    int32_t var_84h;
    uint32_t var_80h;
    uint32_t var_78h;
    int32_t var_70h;
    int32_t var_6ch;
    int32_t var_68h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = caml_local_roots;
    *((ebp - 0x84)) = eax;
    eax = caml_heap_start;
    if (eax == 0) {
        *((ebp - 0x6c)) = 0;
        esi = 0;
        *((ebp - 0x5c)) = 0;
        *((ebp - 0x58)) = 0;
        *((ebp - 0x54)) = 0;
        ebx = 0;
        *((ebp - 0x70)) = 0;
        goto label_1;
    }
    edx = caml_gc_phase;
    *((ebp - 0x78)) = edx;
    ecx = caml_gc_sweep_hp;
    *((ebp - 0x80)) = ecx;
    *((ebp - 0x6c)) = 0;
    esi = 0;
    *((ebp - 0x5c)) = 0;
    *((ebp - 0x58)) = 0;
    *((ebp - 0x54)) = 0;
    ebx = 0;
    *((ebp - 0x70)) = 0;
label_0:
    *((ebp - 0x70))++;
    edi = eax - 0x10;
    *((ebp - 0x68)) = edi;
    edi = eax;
    edx = *((ebp - 0x68));
    edi += *((edx + 8));
    if (edi <= eax) {
        goto label_2;
    }
    *((ebp - 0x8c)) = edi;
    do {
        edx = *(eax);
        ecx = *(eax);
        ecx &= 0x300;
        if (ecx != 0x100) {
            if (ecx <= 0x100) {
                if (ecx != 0) {
                } else {
                }
                if (ecx == 0x200) {
                    goto label_3;
                }
                if (ecx != 0x300) {
                    goto label_4;
                }
            } else {
                ecx = edx;
                ecx >>= 0xa;
                *((ebp - 0x88)) = ecx;
                if (ecx == 0) {
                    *((ebp - 0x6c))++;
                    goto label_4;
                }
                if (*((ebp - 0x78)) == 1) {
                    if (*((ebp - 0x80)) > eax) {
                        goto label_5;
                    }
                    *((ebp - 0x5c))++;
                    ecx = *((ebp - 0x88));
                    edi = *((ebp - 0x58));
                    edi = ecx + edi + 1;
                    *((ebp - 0x58)) = edi;
                    ecx++;
                    if (ecx > esi) {
                        esi = ecx;
                    }
                    goto label_4;
                }
label_5:
                *((ebp - 0x54))++;
                ecx = *((ebp - 0x88));
                ebx = ecx + ebx + 1;
            }
        } else {
            *((ebp - 0x54))++;
            ecx = edx;
            ecx >>= 0xa;
            ebx = ebx + ecx + 1;
            goto label_4;
label_3:
            *((ebp - 0x5c))++;
            edi = edx;
            edi >>= 0xa;
            ecx = *((ebp - 0x58));
            ecx = edi + ecx + 1;
            *((ebp - 0x58)) = ecx;
            ecx = edi;
            ecx++;
            if (ecx <= esi) {
                esi = ecx;
                goto label_4;
            }
        }
label_4:
        edx >>= 0xa;
        eax = eax + edx*4 + 4;
    } while (*((ebp - 0x8c)) > eax);
label_2:
    edi = *((ebp - 0x68));
    eax = *((edi + 0xc));
    if (eax != 0) {
        goto label_0;
    }
label_1:
    *((ebp - 0x1c)) = 0;
    eax = *((ebp - 0x84));
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x3c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    eax = caml_young_end;
    eax -= *(obj.caml_young_ptr);
    eax >>= 2;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *((ebp - 0x68)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_stat_promoted_words);
    *((ebp - 0x78)) = fp_stack[0];
    fp_stack--;
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *((ebp - 0x80)) = fp_stack[0];
    fp_stack--;
    edi = caml_stat_minor_collections;
    eax = caml_stat_major_collections;
    *((ebp - 0x88)) = eax;
    eax = caml_stat_heap_size;
    eax >>= 2;
    *((ebp - 0x8c)) = eax;
    edx = caml_stat_compactions;
    *((ebp - 0x90)) = edx;
    eax = caml_stat_top_heap_size;
    eax >>= 2;
    *((ebp - 0x94)) = eax;
    eax = caml_alloc_tuple (0x10);
    *((ebp - 0x1c)) = eax;
    *(fp_stack--) = *((ebp - 0x68));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x78));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 4;
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x80));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 8;
    caml_modify (eax, eax);
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0xc;
    caml_modify (eax, eax);
    edx = *((ebp - 0x88));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x10;
    caml_modify (eax, eax);
    ecx = *((ebp - 0x8c));
    eax = ecx + ecx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x14;
    caml_modify (eax, eax);
    edi = *((ebp - 0x70));
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x18;
    caml_modify (eax, eax);
    eax = ebx + ebx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x1c;
    caml_modify (eax, eax);
    edx = *((ebp - 0x54));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x20;
    caml_modify (eax, eax);
    ecx = *((ebp - 0x58));
    eax = ecx + ecx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x24;
    caml_modify (eax, eax);
    edi = *((ebp - 0x5c));
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x28;
    caml_modify (eax, eax);
    eax = esi + esi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x2c;
    caml_modify (eax, eax);
    edx = *((ebp - 0x6c));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x30;
    caml_modify (eax, eax);
    ecx = *((ebp - 0x90));
    eax = ecx + ecx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x34;
    caml_modify (eax, eax);
    edi = *((ebp - 0x94));
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x38;
    caml_modify (eax, eax);
    caml_stack_usage ();
    eax = eax + eax + 1;
    eax = *((ebp - 0x1c));
    eax += 0x3c;
    caml_modify (eax, eax);
    eax = *((ebp - 0x84));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066988 */
#include <stdint.h>
 
int32_t caml_nativeint_add (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax += *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8051f00 */
#include <stdint.h>
 
int32_t camlArray_append_1054 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    ecx = *((ebx - 4));
    esi = *((ebx - 4));
    esi &= 0xff;
    if (esi != 0xfe) {
        ecx >>= 9;
    } else {
        ecx >>= 0xa;
    }
    ecx |= 1;
    if (edx == 1) {
        if (ecx == 1) {
            eax = loc.camlArray__31;
            return eax;
        }
        *(esp) = ecx;
        *((esp + 8)) = edx;
        *((esp + 4)) = ebx;
        *((esp + 0xc)) = eax;
    } else {
        *(esp) = ecx;
        *((esp + 8)) = edx;
        *((esp + 4)) = ebx;
        *((esp + 0xc)) = eax;
    }
    if (edx > 1) {
        ebx = eax;
    }
    esi = *((ebx - 4));
    if (esi != 0xfe) {
        esi = *(ebx);
    } else {
label_2:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        esi = eax + 4;
        *((esi - 4)) = 0x8fd;
        *(fp_stack--) = *(ebx);
        *(esi) = fp_stack[0];
        fp_stack--;
    }
    eax = caml_make_vect;
    eax = caml_c_call (edx + ecx - 1);
    esi = eax;
    ebx = 1;
    edi = *((esp + 8));
    edi += 0xfffffffe;
    if (ebx > edi) {
        goto label_4;
    }
    do {
        ecx = *((esp + 0xc));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            edx = *((ecx + ebx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebx*2 - 2, edx);
        } else {
            *(fp_stack--) = *(edx);
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = ebx;
        ebx += 2;
    } while (eax != edi);
label_4:
    ebx = 1;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ebx > eax) {
        goto label_6;
    }
    *(esp) = eax;
    do {
        ecx = *((esp + 4));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            edx = *((ecx + ebx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_7;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + ebx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 8));
        ecx = ebx + eax - 1;
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ecx*2 - 2, edx);
        } else {
            *(fp_stack--) = *(edx);
            *((esi + ecx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebx;
        ebx += 2;
        eax = *(esp);
    } while (ecx != eax);
label_6:
    eax = esi;
    return eax;
label_7:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066f78 */
#include <stdint.h>
 
int32_t caml_int32_of_float (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_ah;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0xa));
    ah = 0xc;
    *((ebp - 0xc)) = ax;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_int32 ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d9d0 */
#include <stdint.h>
 
int32_t camlUnix_open_process_1967 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    *((esp + 8)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 0x10)) = ebx;
    eax = *(eax);
    *((esp + 4)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *(esp) = ebx;
    eax = *(eax);
    *((esp + 0xc)) = eax;
    eax = *((esp + 4));
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    *((esp + 0x14)) = eax;
    eax = *(esp);
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (eax);
    ecx = eax;
    *((esp + 0x18)) = ecx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x24;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x800;
    eax = *(esp);
    *(edx) = eax;
    *((edx + 4)) = 1;
    ebx = edx + 0xc;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 4));
    *(ebx) = eax;
    *((ebx + 4)) = edx;
    ebx = edx + 0x18;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 0x14));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = *((esp + 8));
    ecx = *((esp + 0xc));
    edx = *((esp + 0x10));
    esi = *(esp);
    camlUnix_open_proc_1949 (ebx);
    eax = *((esp + 0xc));
    eax = unix_close;
    caml_c_call (eax);
    eax = *((esp + 0x10));
    eax = unix_close;
    caml_c_call (eax);
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 0x14));
            *(eax) = ebx;
            ebx = *((esp + 0x18));
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80675a0 */
#include <stdint.h>
 
int32_t caml_sinh_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    sinh (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049f34 */
#include <stdint.h>
 
void sinh (void) {
    sinh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804cb30 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_optint_1660 (void) {
    eax = unix_setsockopt;
    caml_c_call (5);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fdc4 */
#include <stdint.h>
 
int32_t caml_globalsym (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    caml_dlsym (0, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fdaa */
#include <stdint.h>
 
int32_t caml_dlsym (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    dlsym ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a214 */
#include <stdint.h>
 
void dlsym (void) {
    dlsym ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c2a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2708 (void) {
    eax = unix_dup2;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fddf */
#include <stdint.h>
 
int32_t caml_dlclose (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(esp) = eax;
    dlclose ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a044 */
#include <stdint.h>
 
void dlclose (void) {
    dlclose ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b840 */
#include <stdint.h>
 
int32_t camlSource_echo_server_1325 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    eax = .comment;
    eax = camlSource_get_port_1322 (eax);
    *((esp + 4)) = eax;
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax == 1) {
        goto label_0;
    }
    eax = .comment;
    eax = sym.unix_accept;
    eax = caml_c_call (eax);
    eax = *(eax);
    *(esp) = eax;
    eax = caml_create_string;
    eax = caml_c_call (0x81);
    *((esp + 4)) = eax;
    eax = 1;
    *((esp + 0xc)) = eax;
    edx = 3;
    do {
        if (edx <= 1) {
            goto label_1;
        }
        edx = 0x81;
        ecx = 1;
        eax = *(esp);
        ebx = *((esp + 4));
        eax = camlUnix_read_1237 ();
        edx = eax;
        ecx = 1;
        eax = *(esp);
        ebx = *((esp + 4));
        camlSource_sock_write_1298 (edx);
        edx = *((esp + 8));
        eax = *((esp + 0xc));
        eax = eax + edx - 1;
        *((esp + 0xc)) = eax;
    } while (1);
label_1:
    eax = unix_wait;
    caml_c_call (1);
    eax = "server processed %d bytes\n";
    eax = camlPrintf_printf_1393 ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0xc));
    void (*ecx)() ();
label_0:
    eax = *(esp);
    ebx = *((esp + 4));
    return camlSource_echo_client_1311 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80675bd */
#include <stdint.h>
 
int32_t caml_sin_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    sin (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a7f4 */
#include <stdint.h>
 
void sin (void) {
    sin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066073 */
#include <stdint.h>
 
int32_t caml_int32_compare (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    cl = (edx > eax) ? 1 : 0;
    ecx = (int32_t) cl;
    dl = (edx < eax) ? 1 : 0;
    edx = (int32_t) dl;
    eax = ecx;
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80703d4 */
#include <stdint.h>
 
int32_t caml_record_backtrace (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    if (eax != *(obj.caml_backtrace_active)) {
        *(obj.caml_backtrace_active) = eax;
        *(obj.caml_backtrace_pos) = 0;
        if (eax != 0) {
            caml_register_global_root (obj.caml_backtrace_last_exn);
        } else {
            caml_remove_global_root (obj.caml_backtrace_last_exn);
        }
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067f59 */
#include <stdint.h>
 
uint32_t caml_make_vect (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_70h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_4h;
    edi = caml_local_roots;
    eax = ebp - 0x38;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 1;
    eax = ebp - 0x3c;
    *((ebp - 0x50)) = eax;
    esi = *((ebp + 8));
    esi >>= 1;
    if (esi == 0) {
        *((ebp - 0x3c)) = 0x8083504;
        goto label_0;
    }
    *((ebp - 0x38)) = edi;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = *((ebp + 0xc));
    edx = *((ebp + 0xc));
    edx &= 1;
    if (edx != 0) {
        goto label_1;
    }
    *((ebp - 0x70)) = eax;
    ebx = eax;
    ebx >>= 0x17;
    ecx = eax;
    ecx >>= 0xc;
    ecx &= 0x7ff;
    ebx = *((ebx*4 + obj.caml_page_table));
    if ((*((ebx + ecx)) & 7) == 0) {
        goto label_1;
    }
    if (*((eax - 4)) != 0xfd) {
        goto label_1;
    }
    *(fp_stack--) = *(eax);
    *((ebp - 0x70)) = fp_stack[0];
    fp_stack--;
    eax = esi + esi;
    if (eax > 0x3fffff) {
        eax = caml_invalid_argument ("Array.make");
    }
    eax = caml_alloc (eax, 0xfe);
    *((ebp - 0x3c)) = eax;
    eax = 0;
    do {
        edx = *((ebp - 0x3c));
        *(fp_stack--) = *((ebp - 0x70));
        *((edx + eax*8)) = fp_stack[0];
        fp_stack--;
        eax++;
    } while (esi > eax);
    goto label_0;
label_1:
    if (esi > 0x3fffff) {
        caml_invalid_argument ("Array.make");
    }
    if (esi > 0xff) {
        goto label_2;
    }
    eax = caml_alloc_small (esi, 0);
    *((ebp - 0x3c)) = eax;
    esi <<= 2;
    eax = 0;
    do {
        ecx = *((ebp + 0xc));
        edx = *((ebp - 0x3c));
        *((eax + edx)) = ecx;
        eax += 4;
    } while (eax != esi);
    goto label_0;
label_2:
    if (edx != 0) {
        goto label_3;
    }
    if (eax >= *(obj.caml_young_end)) {
        goto label_3;
    }
    if (eax <= *(obj.caml_young_start)) {
        goto label_3;
    }
    caml_minor_collection ();
    eax = caml_alloc_shr (esi, 0);
    *((ebp - 0x3c)) = eax;
    esi <<= 2;
    eax = 0;
    do {
        ecx = *((ebp + 0xc));
        edx = *((ebp - 0x3c));
        *((edx + eax)) = ecx;
        eax += 4;
    } while (eax != esi);
    eax = *((ebp - 0x3c));
    eax = caml_check_urgent_gc (eax);
    *((ebp - 0x3c)) = eax;
    goto label_0;
label_3:
    eax = caml_alloc_shr (esi, 0);
    *((ebp - 0x3c)) = eax;
    ebx = 0;
    do {
        eax = *((ebp + 0xc));
        eax = ebx*4;
        eax += *((ebp - 0x3c));
        caml_initialize (eax, eax);
        ebx++;
    } while (esi > ebx);
    eax = *((ebp - 0x3c));
    eax = caml_check_urgent_gc (eax);
    *((ebp - 0x3c)) = eax;
label_0:
    *(obj.caml_local_roots) = edi;
    eax = *((ebp - 0x3c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064ff7 */
#include <stdint.h>
 
int32_t caml_shrink_heap (int32_t arg_8h) {
    char * var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    if (ebx == *(obj.caml_heap_start)) {
        goto label_0;
    }
    esi = ebx - 0x10;
    eax = caml_stat_heap_size;
    eax -= *((esi + 8));
    *(obj.caml_stat_heap_size) = eax;
    eax >>= 0xa;
    caml_gc_message (4, "Shrinking heap to %luk bytes\n", eax);
    *(obj.caml_stat_heap_chunks)--;
    eax = caml_heap_start;
    edx = caml_heap_start;
    if (ebx == eax) {
        goto label_1;
    }
    do {
        edx = eax - 4;
        eax = *((eax - 4));
    } while (ebx != eax);
label_1:
    eax = *((esi + 0xc));
    *(edx) = eax;
    eax = ebx;
    eax += *((esi + 8));
    caml_page_table_remove (1, ebx, eax);
    caml_free_for_heap (ebx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058f60 */
#include <stdint.h>
 
int32_t loc_camlPrintf_code_begin (void) {
    eax = ebx;
    ecx = *((eax + 8));
    ebx = *((eax + 0xc));
    eax = *((eax + 0x10));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064ddc */
#include <stdint.h>
 
int32_t caml_initialize (int32_t arg_8h, int32_t arg_ch) {
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    *(ebx) = eax;
    if ((al & 1) == 0) {
        if (eax >= *(obj.caml_young_end)) {
            goto label_0;
        }
        if (eax <= *(obj.caml_young_start)) {
            goto label_0;
        }
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 1) == 0) {
            goto label_0;
        }
        eax = .comment;
        if (eax >= *(0x807fe8c)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x807fe88;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804cb10 */
#include <stdint.h>
 
int32_t camlUnix_getsockopt_optint_1657 (void) {
    eax = unix_getsockopt;
    caml_c_call (5);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067cbc */
#include <stdint.h>
 
int32_t caml_string_greaterthan (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax > 1) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b2d0 */
#include <stdint.h>
 
int32_t caml_curry3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry3_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060b3d */
#include <stdint.h>
 
int32_t unix_tcsetattr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x126b9;
    eax = *((ebp + 8));
    eax >>= 1;
    *((ebp - 0x28)) = eax;
    eax = ebx + 0x997c;
    *((esp + 4)) = eax;
    eax = *((ebp - 0x28));
    *(esp) = eax;
    eax = tcgetattr ();
    if (eax == -1) {
        eax = ebx - 0x22d3;
        uerror (eax, 0);
    }
    eax = *((ebx + 0x94fc));
    if (eax == 4) {
        goto label_1;
    }
    edi = *((ebp + 0x10));
    esi = ebx + 0x94fc;
    edx = ebx - 0x2264;
    *((ebp - 0x24)) = edx;
    ecx = ebx + 0x997c;
    *((ebp - 0x2c)) = ecx;
label_0:
    esi += 4;
    if (eax != 1) {
        if (eax <= 1) {
            if (eax == 0) {
                goto label_2;
            }
            goto label_3;
        }
        if (eax == 2) {
            goto label_4;
        }
        if (eax != 3) {
            goto label_3;
        }
        goto label_5;
label_2:
        eax = *(esi);
        ecx = *((esi + 4));
        esi += 8;
        edx = *(edi);
        edx >>= 1;
        if (edx != 0) {
            *(eax) |= ecx;
            goto label_3;
        }
        ecx = ~ecx;
        *(eax) &= ecx;
        goto label_3;
    }
    eax = *(esi);
    edx = *((esi + 8));
    *((ebp - 0x1c)) = edx;
    edx = esi + 0xc;
    ecx = *(edx);
    *((ebp - 0x20)) = ecx;
    ecx = *(edi);
    ecx >>= 1;
    ecx -= *((esi + 4));
    if (ecx >= 0) {
        if (*((ebp - 0x1c)) <= ecx) {
            goto label_6;
        }
        edx += 4;
        esi = *((ebp - 0x20));
        esi = ~esi;
        esi &= *(eax);
        esi |= *((edx + ecx*4));
        *(eax) = esi;
        eax = *((ebp - 0x1c));
        esi = edx + eax*4;
        goto label_3;
    }
label_6:
    eax = ebx - 0x22d3;
    unix_error (0x16, eax, 0);
label_4:
    ecx = *(esi);
    edx = *(edi);
    edx >>= 1;
    eax = 1;
    if (edx == *((ebx - 0x2260))) {
        al = 0;
        goto label_7;
    }
    *((ebp - 0x1c)) = esi;
    esi = *((ebp - 0x24));
    do {
        if (edx == *((esi + eax*8 + 4))) {
            esi = *((ebp - 0x1c));
label_7:
            if (ecx != 0) {
                edx = 0;
                if (ecx != 1) {
                    goto label_8;
                }
                eax = *((ebx + eax*8 - 0x2264));
                *((esp + 4)) = eax;
                edx = *((ebp - 0x2c));
                *(esp) = edx;
                eax = cfsetospeed ();
                edx = eax;
            } else {
                eax = *((ebx + eax*8 - 0x2264));
                *((esp + 4)) = eax;
                ecx = *((ebp - 0x2c));
                *(esp) = ecx;
                eax = cfsetispeed ();
                edx = eax;
            }
label_8:
            if (edx != -1) {
                esi += 4;
                goto label_3;
            }
            eax = ebx - 0x22d3;
            eax = uerror (eax, 0);
        }
        eax++;
    } while (eax != 0x12);
    eax = ebx - 0x22d3;
    unix_error (0x16, eax, 0);
label_5:
    eax = *(esi);
    esi += 4;
    edx = *(edi);
    edx >>= 1;
    *((ebx + eax + 0x998d)) = dl;
label_3:
    eax = *(esi);
    if (eax != 4) {
        edi += 4;
        goto label_0;
    }
label_1:
    eax = ebx + 0x997c;
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x2288));
    *((esp + 4)) = eax;
    eax = *((ebp - 0x28));
    *(esp) = eax;
    eax = tcsetattr ();
    if (eax == -1) {
        eax = ebx - 0x22d3;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b040 */
#include <stdint.h>
 
int32_t caml_curry6_4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_5;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063064 */
#include <stdint.h>
 
int32_t caml_fatal_error_arg2 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    char ** format;
    int32_t var_8h;
    eax = *((ebp + 0xc));
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax = stderr;
    fprintf (eax, eax);
    eax = *((ebp + 0x14));
    *((esp + 8)) = eax;
    eax = *((ebp + 0x10));
    eax = stderr;
    fprintf (eax, eax);
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a574 */
#include <stdint.h>
 
void fprintf (void) {
    fprintf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061b59 */
#include <stdint.h>
 
int32_t caml_startup (int32_t arg_8h) {
    eax = *((ebp + 8));
    caml_main (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bd90 */
#include <stdint.h>
 
int32_t camlUnix_fun_2857 (void) {
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f730 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1406 (void) {
    eax = caml_ml_input_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b810 */
#include <stdint.h>
 
int32_t camlSource_get_port_1322 (void) {
    eax = unix_getsockname;
    caml_c_call (eax);
    ebx = *((eax - 4));
    if (ebx != 0) {
        eax = *((eax + 4));
        return eax;
    }
    eax = "getsockname";
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065182 */
#include <stdint.h>
 
uint32_t caml_alloc_shr (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    if (esi > 0x3fffff) {
        caml_raise_out_of_memory ();
    }
    eax = caml_fl_allocate (esi);
    ebx = eax;
    if (eax != 0) {
        goto label_0;
    }
    edx = 0x51eb851f;
    eax = esi;
    edx:eax = eax * edx;
    edx >>= 5;
    edx *= *(obj.caml_percent_free);
    eax = esi + edx + 1;
    eax <<= 2;
    eax = caml_round_heap_chunk_size (eax);
    ebx = eax;
    eax = caml_alloc_for_heap (eax);
    edi = eax;
    if (eax != 0) {
        edx = ebx;
        edx >>= 2;
        edx--;
        ecx = eax;
        if (edx > 0x3fffff) {
            goto label_1;
        }
        goto label_2;
    }
    eax = caml_gc_message (4, "No room for growing heap\n", 0);
    goto label_3;
    do {
        ecx = eax;
label_1:
        *(eax) = 0xfffffe00;
        eax += 0x1000000;
        ebx -= 0x1000000;
        edx = eax + 4;
        *((ecx + 4)) = edx;
        *((edi + 8)) = edx;
        edx = ebx;
        edx >>= 2;
        edx--;
    } while (edx > 0x3fffff);
    ecx = eax;
label_2:
    if (ebx > 1) {
        edx <<= 0xa;
        edx += 0x200;
        *(eax) = edx;
        ecx += 4;
        *((edi + 8)) = ecx;
        *(ecx) = 0;
    } else {
        *((ecx + 4)) = 0;
        if (ebx != 1) {
            goto label_4;
        }
        *(eax) = 0;
    }
label_4:
    eax = caml_add_to_heap (edi);
    if (eax != 0) {
        caml_free_for_heap (edi);
    } else {
        edi += 4;
        if (edi != 0) {
            goto label_5;
        }
    }
label_3:
    if (*(obj.caml_in_minor_collection) != 0) {
        caml_fatal_error ("Fatal error: out of memory.\n");
    }
    caml_raise_out_of_memory ();
label_5:
    caml_fl_add_blocks (edi);
    eax = caml_fl_allocate (esi);
    ebx = eax;
label_0:
    eax = caml_gc_phase;
    if (eax != 0) {
        if (eax != 1) {
            goto label_6;
        }
        if (ebx < *(obj.caml_gc_sweep_hp)) {
            goto label_6;
        }
    }
    eax = esi;
    eax <<= 0xa;
    edx = *((ebp + 0xc));
    eax = edx + eax + 0x300;
    *(ebx) = eax;
    goto label_7;
label_6:
    eax = esi;
    eax <<= 0xa;
    eax += *((ebp + 0xc));
    *(ebx) = eax;
label_7:
    eax = caml_allocated_words;
    eax = esi + eax + 1;
    *(obj.caml_allocated_words) = eax;
    edx = caml_minor_heap_size;
    edx >>= 2;
    if (eax > edx) {
        caml_urge_major_slice ();
    }
    eax = ebx + 4;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050c00 */
#include <stdint.h>
 
uint32_t camlArray_fill_1135 (void) {
    do {
        edi = eax;
        esi = ecx;
        if (ebx == 1) {
            goto label_0;
        }
        ebp = *((ebx + 4));
        ecx = *(ebx);
        ebx = *((esi + 0xc));
        eax = *((ebx - 4));
        if (eax != 0xfe) {
            caml_modify (ebx + edi*2 - 2, ecx);
        } else {
            *(fp_stack--) = *(ecx);
            *((ebx + edi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = edi;
        eax += 2;
        ebx = ebp;
        ecx = esi;
    } while (1);
label_0:
    eax = *((esi + 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060f2c */
#include <stdint.h>
 
uint32_t unix_time (void) {
    time_t var_ch;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x122cc;
    eax = time (0);
    *((ebp - 0xc)) = eax;
    *(fp_stack--) = *((ebp - 0xc));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a584 */
#include <stdint.h>
 
void time (void) {
    time ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050010 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_char_1277 (void) {
    eax = caml_ml_output_char;
    caml_c_call (*(0x8076898));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ca50 */
#include <stdint.h>
 
int32_t camlUnix_fun_2816 (void) {
    eax = unix_setsockopt;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b2a0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1689 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d9c3 */
#include <stdint.h>
 
uint32_t unix_gethostbyname (int32_t arg_8h, char * src, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_2740h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1582a;
    edi = *((ebp + 8));
    eax = caml_string_length (edi);
    eax++;
    eax = caml_stat_alloc (eax);
    esi = eax;
    strcpy (eax, edi);
    caml_enter_blocking_section ();
    eax = h_errno_location ();
    *((esp + 0x14)) = eax;
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = 0x2710;
    eax = ebp - 0x2740;
    *((esp + 8)) = eax;
    eax = ebp - 0x30;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = gethostbyname_r ();
    edi = eax;
    caml_leave_blocking_section ();
    if (edi != 0) {
        *((ebp - 0x1c)) = 0;
    }
    caml_stat_free (esi);
    eax = *((ebp - 0x1c));
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_host_entry ();
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8057f30 */
#include <stdint.h>
 
int32_t camlHashtbl_iter_1129 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0xcf7;
    *(ecx) = sym.camlHashtbl__do_bucket_1132;
    *((ecx + 4)) = 3;
    *((ecx + 8)) = edx;
    edx = *((ebx + 4));
    eax = 1;
    ebx = *((edx - 4));
    ebx >>= 9;
    ebx |= 1;
    ebx += 0xfffffffe;
    if (eax > ebx) {
        goto label_2;
    }
    *((esp + 0xc)) = ebx;
    *((esp + 8)) = eax;
    *(esp) = edx;
    *((esp + 4)) = ecx;
    do {
        ebx = *(esp);
        ecx = *((ebx - 4));
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_3;
        }
        eax = *((ebx + eax*2 - 2));
        ebx = *((esp + 4));
        camlHashtbl_do_bucket_1132 ();
        eax = *((esp + 8));
        ecx = *((esp + 8));
        eax += 2;
        *((esp + 8)) = eax;
        ebx = *((esp + 0xc));
    } while (ecx != ebx);
label_2:
    eax = 1;
    return eax;
label_1:
    caml_call_gc ();
    goto label_0;
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ed68 */
#include <stdint.h>
 
uint32_t unix_opendir (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14488;
    edi = *((ebp + 8));
    *(esp) = edi;
    eax = opendir ();
    esi = eax;
    if (eax == 0) {
        eax = ebx - 0x248d;
        uerror (eax, edi);
    }
    caml_alloc_small (1, 0xfb);
    *(eax) = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a264 */
#include <stdint.h>
 
void opendir (void) {
    opendir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f710 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1402 (void) {
    eax = caml_input_value;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80579b0 */
#include <stdint.h>
 
int32_t camlHashtbl_find_rec_1088 (void) {
    int32_t var_4h_5;
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 8));
        *((esp + 4)) = ecx;
        ecx = *((ebx + 4));
        *((esp + 8)) = ecx;
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8053a10 */
#include <stdint.h>
 
int32_t camlList_rev_merge_rev_1261 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    do {
label_0:
        if (eax == 1) {
            goto label_2;
        }
        if (ebx == 1) {
            goto label_3;
        }
        ecx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((edx + 0xc));
        eax = caml_apply2 (edx, eax, ecx);
        if (eax <= 1) {
            goto label_4;
        }
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_5;
        }
        ecx = eax + 4;
        *((ecx - 4)) = 0x800;
        eax = *((esp + 0xc));
        *(ecx) = eax;
        eax = *((esp + 0x10));
        *((ecx + 4)) = eax;
        eax = *((esp + 0x14));
        ebx = *((esp + 0x18));
        edx = *((esp + 0x1c));
    } while (1);
    do {
label_4:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            eax = *((esp + 0x10));
            *((ecx + 4)) = eax;
            eax = *((esp + 4));
            ebx = *((esp + 8));
            edx = *((esp + 0x1c));
            goto label_0;
label_3:
            ebx = ecx;
            void (*0x8054520)() ();
label_2:
            eax = ebx;
            ebx = ecx;
            void (*0x8054520)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066536 */
#include <stdint.h>
 
uint32_t caml_nativeint_format (void) {
    char * format;
    int32_t var_8h_3;
    int32_t var_4h_2;
    int32_t var_8h_2;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = ebp - 0x38;
    eax = ebp - 0x59;
    edi = ebp - 0x58;
    ecx = esi;
    edx = 0x8071f03;
    eax = *((ebp + 8));
    eax = parse_format (edi, eax);
    ebx = eax;
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    sprintf (ebx, esi, eax);
    eax = caml_copy_string (ebx);
    esi = eax;
    if (ebx != edi) {
        caml_stat_free (ebx);
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c230 */
#include <stdint.h>
 
int32_t camlUnix_fun_2694 (void) {
    eax = unix_chdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b540 */
#include <stdint.h>
 
int32_t camlPrintf_pad_string_1072 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    if (ebx == edi) {
        if (esi != 1) {
            goto label_0;
        }
        eax = edx;
        return eax;
    }
label_0:
    if (ebx <= edi) {
        eax = edx;
        ebx = esi;
        ecx = edi;
        void (*0x8055800)() ();
    }
    eax = ebx;
    ebx = ebp;
    eax = camlString_make_1038 (edi, ebx);
    ecx = eax;
    *((esp + 4)) = ecx;
    eax = *(esp);
    if (eax != 1) {
        edx = 1;
        eax = *((esp + 0xc));
        ebx = *((esp + 0x10));
        esi = *((esp + 0x14));
        camlString_blit_1056 ();
    } else {
        edx = *((esp + 8));
        esi = *((esp + 0x14));
        edx -= esi;
        edx++;
        eax = *((esp + 0xc));
        ebx = *((esp + 0x10));
        camlString_blit_1056 ();
    }
    eax = *((esp + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806230a */
#include <stdint.h>
 
int32_t caml_oldify_local_roots (void) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = caml_globals_scanned;
    *((ebp - 0x1c)) = eax;
    eax = caml_globals_inited;
    if (*((ebp - 0x1c)) > eax) {
        goto label_8;
    }
    edx = *((ebp - 0x1c));
    edi = *((edx*4 + loc.caml_globals));
    if (edi != 0) {
        goto label_9;
    }
    goto label_8;
    do {
label_0:
        edx = edi + eax*4;
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_10;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_10;
            }
            caml_oldify_one (eax, edx);
        }
label_10:
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (ebx < edx);
label_1:
    *((ebp - 0x1c))++;
    eax = caml_globals_inited;
    if (eax < *((ebp - 0x1c))) {
        goto label_8;
    }
    ecx = *((ebp - 0x1c));
    edx = caml_globals;
    edi = *((edx + ecx*4));
    if (edi == 0) {
        goto label_8;
    }
label_9:
    esi = edi - 4;
    edx = *(esi);
    edx >>= 0xa;
    eax = 0;
    ebx = 0;
    if (edx != 0) {
        goto label_0;
    }
    goto label_1;
label_8:
    *(obj.caml_globals_scanned) = eax;
    ecx = caml_dyn_globals;
    *((ebp - 0x1c)) = ecx;
    if (ecx == 0) {
        goto label_11;
    }
label_2:
    eax = *((ebp - 0x1c));
    edi = *(eax);
    esi = edi - 4;
    eax = *(esi);
    eax >>= 0xa;
    if (eax == 0) {
        goto label_12;
    }
    eax = 0;
    ebx = 0;
    do {
        edx = edi + eax*4;
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_13;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_13;
            }
            caml_oldify_one (eax, edx);
        }
label_13:
        ebx++;
        eax = ebx;
        edx = *(esi);
        edx >>= 0xa;
    } while (ebx < edx);
label_12:
    edx = *((ebp - 0x1c));
    edx = *((edx + 4));
    *((ebp - 0x1c)) = edx;
    if (edx != 0) {
        goto label_2;
    }
label_11:
    if (*(obj.caml_frame_descriptors) == 0) {
        caml_init_frame_descriptors ();
    }
    ecx = caml_bottom_of_stack;
    *((ebp - 0x1c)) = ecx;
    edx = caml_last_return_address;
    eax = caml_gc_regs;
    *((ebp - 0x20)) = eax;
    if (ecx == 0) {
        goto label_14;
    }
label_3:
    esi = caml_frame_descriptors_mask;
    eax = edx;
    eax >>= 3;
    eax &= esi;
    ecx = caml_frame_descriptors;
    ebx = *((ecx + eax*4));
    if (*(ebx) == edx) {
        goto label_15;
    }
    do {
        eax++;
        eax &= esi;
        ebx = *((ecx + eax*4));
    } while (*(ebx) != edx);
label_15:
    if (*((ebx + 4)) == 0xffff) {
        goto label_16;
    }
    esi = *((ebx + 6));
    if (esi <= 0) {
        goto label_17;
    }
    edi = ebx + 8;
    do {
        edx = *(edi);
        if ((dl & 1) != 0) {
            edx >>= 1;
            ecx = *((ebp - 0x20));
            edx = ecx + edx*4;
        } else {
            edx += *((ebp - 0x1c));
        }
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_18;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_18;
            }
            caml_oldify_one (eax, edx);
        }
label_18:
        esi--;
        if (esi <= 0) {
            goto label_17;
        }
        edi += 2;
    } while (1);
label_17:
    eax = *((ebx + 4));
    eax &= 0xfffc;
    *((ebp - 0x1c)) += eax;
    eax = *((ebp - 0x1c));
    edx = *((eax - 4));
    goto label_3;
label_16:
    eax = *((ebp - 0x1c));
    eax += 8;
    edx = *(eax);
    *((ebp - 0x1c)) = edx;
    edx = *((eax + 4));
    eax = *((eax + 8));
    *((ebp - 0x20)) = eax;
    if (*((ebp - 0x1c)) != 0) {
        goto label_3;
    }
label_14:
    esi = caml_local_roots;
    *((ebp - 0x1c)) = 0;
    if (esi != 0) {
        goto label_19;
    }
    goto label_20;
    do {
label_4:
        edx = ebx*4;
        edx += *((esi + edi*4 + 0xc));
        eax = *(edx);
        if ((al & 1) == 0) {
            if (eax >= *(obj.caml_young_end)) {
                goto label_21;
            }
            if (eax <= *(obj.caml_young_start)) {
                goto label_21;
            }
            caml_oldify_one (eax, edx);
        }
label_21:
        ebx++;
    } while (*((esi + 8)) > ebx);
label_5:
    edi++;
    if (*((esi + 4)) <= edi) {
        goto label_7;
    }
label_6:
    ebx = *((ebp - 0x1c));
    if (*((esi + 8)) > 0) {
        goto label_4;
    }
    goto label_5;
label_7:
    esi = *(esi);
    if (esi == 0) {
        goto label_20;
    }
label_19:
    edi = 0;
    if (*((esi + 4)) > 0) {
        goto label_6;
    }
    goto label_7;
label_20:
    caml_scan_global_young_roots (sym.caml_oldify_one);
    caml_final_do_young_roots (sym.caml_oldify_one);
    eax = caml_scan_roots_hook;
    if (eax != 0) {
        void (*eax)(uint32_t) (sym.caml_oldify_one);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c250 */
#include <stdint.h>
 
int32_t camlUnix_fun_2698 (void) {
    eax = unix_mkdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80545c0 */
#include <stdint.h>
 
int32_t camlList_map_1062 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        eax = *((ebx + 4));
        eax = *(ebx);
        ecx = *(edx);
        ebx = edx;
        eax = void (*ecx)(uint32_t, uint32_t) (edx, eax);
        eax = *(esp);
        ebx = *((esp + 4));
        eax = camlList_map_1062 (eax);
    } while (1);
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            ebx = *((esp + 8));
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80693d1 */
#include <stdint.h>
 
uint32_t caml_putword (int32_t arg_8h, int32_t arg_ch) {
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    eax = caml_channel_binary_mode (ebx, esi);
    if (eax == 0) {
        caml_failwith ("output_binary_int: not a binary channel");
    }
    eax = *((ebx + 0x10));
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    edx >>= 0x18;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    edx >>= 0x10;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    edx >>= 8;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    if (eax >= *((ebx + 0xc))) {
        caml_flush_partial (ebx);
    }
    eax = *((ebx + 0x10));
    edx = esi;
    *(eax) = dl;
    eax++;
    *((ebx + 0x10)) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e6a0 */
#include <stdint.h>
 
int32_t caml_weak_check (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax++;
    if (eax != 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.get");
label_0:
    eax = *((edx + eax*4));
    al = (eax != *(obj.caml_weak_none)) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061e89 */
#include <stdint.h>
 
void caml_raise_zero_divide (void) {
    return caml_raise_constant (loc.caml_exn_Division_by_zero);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80668cf */
#include <stdint.h>
 
int32_t caml_nativeint_mod (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    ecx = *((eax + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            caml_copy_nativeint (0);
        }
    } else {
        eax = edx;
        edx >>= 0x1f;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        caml_copy_nativeint (edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067631 */
#include <stdint.h>
 
uint32_t caml_modf_float (int32_t arg_8h) {
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_10h;
    int32_t var_8h;
    ebx = caml_local_roots;
    *((ebp - 0x30)) = ebx;
    *((ebp - 0x28)) = 1;
    *((ebp - 0x2c)) = 1;
    eax = ebp + 8;
    *((ebp - 0x24)) = eax;
    *((ebp - 0x34)) = 0;
    *((ebp - 0x38)) = 0;
    *((ebp - 0x3c)) = 0;
    eax = ebp - 0x30;
    *((ebp - 0x5c)) = eax;
    eax = ebp - 0x5c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x58)) = 3;
    eax = ebp - 0x34;
    *((ebp - 0x50)) = eax;
    eax = ebp - 0x38;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x3c;
    *((ebp - 0x48)) = eax;
    eax = ebp - 0x10;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    modf (ebx, eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x38)) = eax;
    *(fp_stack--) = *((ebp - 0x10));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x3c)) = eax;
    eax = caml_alloc_tuple (2);
    *((ebp - 0x34)) = eax;
    edx = *((ebp - 0x38));
    *(eax) = edx;
    edx = *((ebp - 0x3c));
    eax = *((ebp - 0x34));
    *((eax + 4)) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x34));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c510 */
#include <stdint.h>
 
int32_t camlUnix_fun_2774 (void) {
    eax = unix_execv;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80580b0 */
#include <stdint.h>
 
int32_t camlHashtbl_Make_1251 (void) {
    int32_t var_4h_3;
    int32_t var_8h_3;
    int32_t var_ch_3;
    int32_t var_10h_2;
    int32_t var_14h;
    int32_t var_18h_2;
    ebx = eax;
    eax = camlHashtbl;
    *(esp) = eax;
    eax = .comment;
    *((esp + 4)) = eax;
    eax = .comment;
    *((esp + 8)) = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xe8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0xcf7;
            *(eax) = sym.camlHashtbl__safehash_1177;
            *((eax + 4)) = 3;
            *((eax + 8)) = ebx;
            ecx = eax + 0x10;
            *((esp + 0xc)) = ecx;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry3;
            *((ecx + 4)) = 7;
            *((ecx + 8)) = 0x8056d30;
            *((ecx + 0xc)) = eax;
            ecx = eax + 0x24;
            *((esp + 0x10)) = ecx;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8056e40;
            *((ecx + 0xc)) = ebx;
            *((ecx + 0x10)) = eax;
            edx = eax + 0x3c;
            *((edx - 4)) = 0x10f7;
            *(edx) = sym.caml_curry2;
            *((edx + 4)) = 5;
            *((edx + 8)) = 0x8056f40;
            *((edx + 0xc)) = ebx;
            ecx = eax + 0x50;
            *((esp + 0x14)) = ecx;
            *((ecx - 4)) = 0x18f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8056fd0;
            *((ecx + 0xc)) = ebx;
            *((ecx + 0x10)) = eax;
            *((ecx + 0x14)) = edx;
            esi = eax + 0x6c;
            *((esi - 4)) = 0x14f7;
            *(esi) = sym.caml_curry2;
            *((esi + 4)) = 5;
            *((esi + 8)) = 0x80571e0;
            *((esi + 0xc)) = ebx;
            *((esi + 0x10)) = eax;
            edx = eax + 0x84;
            *((edx - 4)) = 0x14f7;
            *(edx) = sym.caml_curry3;
            *((edx + 4)) = 7;
            *((edx + 8)) = 0x80572b0;
            *((edx + 0xc)) = ebx;
            *((edx + 0x10)) = eax;
            ecx = eax + 0x9c;
            *((ecx - 4)) = 0x14f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80574b0;
            *((ecx + 0xc)) = ebx;
            *((ecx + 0x10)) = eax;
            ebx = .comment;
            ebp = .comment;
            edi = .comment;
            eax += 0xb4;
            *((eax - 4)) = 0x3000;
            ebx = *(esp);
            *(eax) = ebx;
            ebx = *((esp + 4));
            *((eax + 4)) = ebx;
            ebx = *((esp + 8));
            *((eax + 8)) = ebx;
            ebx = *((esp + 0xc));
            *((eax + 0xc)) = ebx;
            ebx = *((esp + 0x10));
            *((eax + 0x10)) = ebx;
            ebx = *((esp + 0x14));
            *((eax + 0x14)) = ebx;
            *((eax + 0x18)) = esi;
            *((eax + 0x1c)) = edx;
            *((eax + 0x20)) = ecx;
            ebx = *((esp + 0x18));
            *((eax + 0x24)) = ebx;
            *((eax + 0x28)) = ebp;
            *((eax + 0x2c)) = edi;
            return eax;
        }
        caml_call_gc (ebx);
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c210 */
#include <stdint.h>
 
int32_t camlUnix_fun_2690 (void) {
    eax = unix_chroot;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a853 */
#include <stdint.h>
 
int32_t caml_deserialize_block_2 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_14h;
    int32_t var_10h;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    ecx = intern_src;
    if (edi <= 0) {
        goto label_0;
    }
    eax = 0;
    *((ebp - 0x14)) = edi;
    *((ebp - 0x10)) = edi;
    do {
        esi = *((ecx + eax));
        edi = *((ecx + eax + 1));
        edx = edi;
        *((ebx + eax)) = dl;
        edx = esi;
        *((ebx + eax + 1)) = dl;
        eax += 2;
        *((ebp - 0x14))--;
    } while (*((ebp - 0x14)) != 0);
    edi = *((ebp - 0x10));
    ecx = ecx + edi*2;
label_0:
    *(obj.intern_src) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ec24 */
#include <stdint.h>
 
uint32_t unix_nice (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x145cf;
    eax = errno_location ();
    esi = eax;
    *(eax) = 0;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = nice ();
    if (eax == -1) {
        if (*(esi) == 0) {
            goto label_0;
        }
        eax = ebx - 0x2497;
        uerror (eax, 0);
    }
label_0:
    eax = eax + eax + 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a404 */
#include <stdint.h>
 
void nice (void) {
    nice ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a77c */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_1 (void) {
    edx = intern_src;
    eax = *(edx);
    edx++;
    *(obj.intern_src) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c530 */
#include <stdint.h>
 
int32_t camlUnix_fun_2778 (void) {
    eax = caml_sys_getenv;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069506 */
#include <stdint.h>
 
uint32_t caml_ml_flush (int32_t arg_8h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    if (*(ebx) == -1) {
        *(obj.caml_local_roots) = esi;
    } else {
        eax = caml_channel_mutex_lock;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        caml_flush (ebx);
        eax = caml_channel_mutex_unlock;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        *(obj.caml_local_roots) = esi;
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805deed */
#include <stdint.h>
 
int32_t unix_getprotobyname (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1530b;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getprotobyname ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_proto_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a0a4 */
#include <stdint.h>
 
void getprotobyname (void) {
    getprotobyname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806127c */
#include <stdint.h>
 
uint32_t unix_unlink (void) {
    int32_t var_bp_8h;
    int32_t var_bp_4h;
    int32_t var_4h_2;
    char * path;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x11f77;
    esi = *((ebp + 8));
    eax = unlink (esi);
    if (eax == -1) {
        eax = ebx - 0x217c;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c4e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2770 (void) {
    eax = unix_execvp;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80607eb */
#include <stdint.h>
 
uint32_t unix_lstat (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x12a0c;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = lxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x2318;
        uerror (eax, esi);
    }
    if (*((ebp - 0x38)) >= 0) {
        if (*((ebp - 0x38)) <= 0) {
            if (*((ebp - 0x3c)) <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = *((ebp - 0x58));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        eax = ebx - 0x2318;
        unix_error (0x4b, eax, esi);
    }
label_0:
    edx = ebp - 0x68;
    eax = 0;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056090 */
#include <stdint.h>
 
int32_t camlString_index_from_1116 (void) {
    esi = ebx;
    edx = ecx;
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ebx = ebx + ebx + 1;
    if (esi >= 1) {
        if (esi > ebx) {
            goto label_0;
        }
        ecx = esi;
        void (*0x8056000)() ();
    }
label_0:
    eax = "String.index_from";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fabd */
#include <stdint.h>
 
int32_t unix_sigsuspend (int32_t arg_8h) {
    int32_t var_88h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x13733;
    esi = ebp - 0x88;
    edx = esi;
    eax = *((ebp + 8));
    decode_sigset ();
    caml_enter_blocking_section ();
    *(esp) = esi;
    eax = sigsuspend ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = errno_location ();
        if (*(eax) == 4) {
            goto label_0;
        }
        eax = ebx - 0x23fc;
        uerror (eax, 0);
    }
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a8c4 */
#include <stdint.h>
 
void sigsuspend (void) {
    sigsuspend ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bf70 */
#include <stdint.h>
 
int32_t camlUnix_fun_2612 (void) {
    eax = unix_getgrgid;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050160 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1493 (void) {
    eax = caml_ml_pos_in_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a640 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1572 (void) {
    int32_t var_4h_4;
    *((esp + 4)) = eax;
    *(esp) = ebx;
    eax = caml_make_vect;
    eax = caml_c_call (3);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 4));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 8));
    eax = *((eax + 0xc));
    void (*0x804b540)() ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d3a0 */
#include <stdint.h>
 
int32_t camlUnix_system_1891 (void) {
    *(esp) = eax;
    eax = unix_fork;
    eax = caml_c_call (1);
    if (eax != 1) {
        eax = unix_waitpid;
        eax = caml_c_call (1);
        eax += 4;
        eax = *(eax);
        return eax;
    }
    fcn_0804d400 ();
    eax = 0xff;
    return camlPervasives_exit_1326 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d400 */
#include <stdint.h>
 
int32_t fcn_0804d400 (int32_t arg_8h) {
    *(obj.caml_exception_pointer) = esp;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = "/bin/sh";
            *((ebx + 4)) = 0x8074d24;
            eax = *((esp + 8));
            *((ebx + 8)) = eax;
            eax = unix_execv;
            caml_c_call ("/bin/sh");
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055f70 */
#include <stdint.h>
 
int32_t camlString_apply1_1100 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    edx = *((ebx + ecx));
    ecx -= edx;
    ecx = ecx + ecx + 1;
    if (ecx == 1) {
        eax = ebx;
        return eax;
    }
    eax = ebx;
    eax = camlString_copy_1042 (ebx, eax);
    eax = *(esp);
    eax = *(eax);
    eax = eax + eax + 1;
    ebx = *((esp + 4));
    ecx = *(ebx);
    eax = void (*ecx)(uint32_t) (eax);
    eax >>= 1;
    edx = eax;
    eax = *((esp + 8));
    *(eax) = dl;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c370 */
#include <stdint.h>
 
int32_t camlPrintf_sprintf_1413 (void) {
    eax = loc.camlPrintf__39;
    eax = camlPrintf_ksprintf_1411 (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *(esp);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068dbe */
#include <stdint.h>
 
uint32_t caml_really_getblock (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    if (ebx <= 0) {
        goto label_0;
    }
    do {
        eax = caml_getblock (edi, esi, ebx);
        if (eax == 0) {
            goto label_0;
        }
        ebx -= eax;
        if (ebx <= 0) {
            goto label_0;
        }
        esi += eax;
    } while (1);
label_0:
    al = (ebx == 0) ? 1 : 0;
    eax = (int32_t) al;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80544e0 */
#include <stdint.h>
 
int32_t camlList_tl_1039 (void) {
    if (eax != 1) {
        eax = *((eax + 4));
        return eax;
    }
    eax = loc.camlList__50;
    return camlPervasives_failwith_1010 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806deda */
#include <stdint.h>
 
int32_t caml_md5_chan (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_10a0h;
    int32_t var_109ch;
    int32_t var_1090h;
    int32_t var_90h;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_4h;
    int32_t var_8h;
    eax = caml_local_roots;
    *((ebp - 0x10a0)) = eax;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 2;
    edx = ebp + 8;
    *((ebp - 0x2c)) = edx;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    *((ebp - 0x109c)) = eax;
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        edx = *((ebp - 0x109c));
        void (*eax)(uint32_t) (edx);
    }
    eax = ebp - 0x90;
    caml_MD5Init (eax);
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    if (ebx >= 0) {
        edi = ebp - 0x1090;
        if (ebx > 0) {
            goto label_0;
        }
        goto label_1;
    }
    ebx = ebp - 0x1090;
    esi = ebp - 0x90;
    do {
        eax = *((ebp - 0x109c));
        eax = caml_getblock (eax, ebx, 0x1000);
        if (eax == 0) {
            goto label_1;
        }
        caml_MD5Update (esi, ebx, eax);
    } while (1);
    do {
label_0:
        eax = 0x1000;
        if (ebx <= 0x1000) {
            eax = ebx;
        }
        edx = *((ebp - 0x109c));
        eax = caml_getblock (edx, edi, eax);
        esi = eax;
        if (eax == 0) {
            eax = caml_raise_end_of_file ();
        }
        eax = ebp - 0x90;
        caml_MD5Update (eax, edi, eax);
        ebx -= esi;
    } while (ebx > 0);
label_1:
    eax = caml_alloc_string (0x10);
    ebx = eax;
    eax = ebp - 0x90;
    caml_MD5Final (ebx, eax);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        edx = *((ebp - 0x109c));
        void (*eax)(uint32_t) (edx);
    }
    eax = *((ebp - 0x10a0));
    *(obj.caml_local_roots) = eax;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80576b0 */
#include <stdint.h>
 
int32_t camlHashtbl_resize_1061 (void) {
    int32_t var_18h_3;
    eax = *((ebx + 4));
    eax = *((eax - 4));
    eax >>= 9;
    eax |= 1;
    ebx = .comment;
    eax >>= 1;
    eax = eax*4 + 3;
    eax = camlPervasives_min_1022 (eax, eax);
    ebx = *((esp + 8));
    if (eax == ebx) {
        goto label_1;
    }
    *((esp + 4)) = eax;
    *((esp + 8)) = ebx;
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    *((esp + 0xc)) = ebx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x14f7;
    *(ecx) = sym.camlHashtbl__insert_bucket_1068;
    *((ecx + 4)) = 3;
    eax = *(esp);
    *((ecx + 8)) = eax;
    eax = *((esp + 4));
    *((ecx + 0xc)) = eax;
    *((ecx + 0x10)) = ebx;
    eax = 1;
    ebx = *((esp + 8));
    ebx += 0xfffffffe;
    if (eax > ebx) {
        goto label_3;
    }
    *((esp + 8)) = ebx;
    *((esp + 4)) = eax;
    *(esp) = ecx;
    do {
        ebx = *((esp + 0x14));
        ecx = *((ebx - 4));
        ecx >>= 9;
        if (ecx <= eax) {
            goto label_4;
        }
        eax = *((ebx + eax*2 - 2));
        ebx = *(esp);
        camlHashtbl_insert_bucket_1068 ();
        eax = *((esp + 4));
        ecx = *((esp + 4));
        eax += 2;
        *((esp + 4)) = eax;
        ebx = *((esp + 8));
    } while (ecx != ebx);
label_3:
    eax = *((esp + 0xc));
    eax = *((esp + 0x14));
    eax += 4;
    caml_modify (eax, eax);
    eax = 1;
    return eax;
label_1:
    eax = 1;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
label_4:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fd20 */
#include <stdint.h>
 
int32_t camlPervasives_open_in_1218 (void) {
    ecx = eax;
    ebx = 1;
    eax = loc.camlPervasives__90;
    return camlPervasives_open_in_gen_1214 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068356 */
#include <stdint.h>
 
int32_t caml_array_get_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xb;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    *(fp_stack--) = *((edx + eax*8));
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    edx = caml_young_ptr;
    eax = edx - 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        *(obj.caml_young_ptr) = edx;
        caml_minor_collection ();
        *(obj.caml_young_ptr) -= 0xc;
    }
    eax = caml_young_ptr;
    *(eax) = 0xbfd;
    eax = caml_young_ptr;
    eax += 4;
    *(fp_stack--) = *((ebp - 0x10));
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b3b0 */
#include <stdint.h>
 
int32_t caml_curry2_1 (void) {
    esi = eax;
    ecx = *((ebx + 0xc));
    eax = *((ebx + 8));
    edx = *((ecx + 8));
    ebx = esi;
    return void (*edx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054890 */
#include <stdint.h>
 
int32_t camlList_fold_left2_1119 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        esi = eax;
        if (ecx == 1) {
            goto label_0;
        }
        if (edx == 1) {
            goto label_1;
        }
        eax = *((edx + 4));
        edx = *(edx);
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = ebx;
        ebx = ecx;
        ecx = edx;
        edx = esi;
        eax = caml_apply3 (esi, eax, eax);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
        edx = *((esp + 8));
    } while (1);
label_0:
    if (edx == 1) {
        eax = ebx;
        return eax;
    }
label_1:
    eax = "List.fold_left2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067d0a */
#include <stdint.h>
 
int32_t caml_string_lessthan (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax <= 0) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066bd0 */
#include <stdint.h>
 
int32_t caml_int64_of_int32 (int32_t arg_8h) {
    int32_t var_4h;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    edx = eax;
    edx >>= 0x1f;
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f9a0 */
#include <stdint.h>
 
uint32_t unix_setsid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13858;
    setsid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a094 */
#include <stdint.h>
 
void setsid (void) {
    setsid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061004 */
#include <stdint.h>
 
int32_t unix_truncate_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x121ef;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    *((esp + 4)) = eax;
    *((esp + 8)) = edx;
    *(esp) = esi;
    eax = truncate64 ();
    if (eax == -1) {
        eax = ebx - 0x255a;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a224 */
#include <stdint.h>
 
void truncate64 (void) {
    truncate64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806752c */
#include <stdint.h>
 
int32_t caml_tanh_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    tanh (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a314 */
#include <stdint.h>
 
void tanh (void) {
    tanh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bea0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2590 (void) {
    eax = unix_getpeername;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fb50 */
#include <stdint.h>
 
int32_t camlPervasives_open_out_1179 (void) {
    ecx = eax;
    ebx = 0x36d;
    eax = camlPervasives__94;
    return camlPervasives_open_out_gen_1175 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805dde4 */
#include <stdint.h>
 
uint32_t unix_getppid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15414;
    getppid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a414 */
#include <stdint.h>
 
void getppid (void) {
    getppid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804caf0 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_int_1653 (void) {
    eax = unix_setsockopt;
    caml_c_call (3);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ac40 */
#include <stdint.h>
 
int32_t caml_curry9_7 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_8;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e4d3 */
#include <stdint.h>
 
int32_t caml_callback (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_callback_exn (eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b150 */
#include <stdint.h>
 
int32_t caml_curry5_2 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_3;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8057e90 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_1122 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlHashtbl__mem_in_bucket_1125;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            eax = *((edi + 4));
            esi = *((eax - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = caml_hash_univ_param (0x15, 0xc9, ecx);
                eax >>= 1;
                ecx = esi;
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            ecx = *((edi + 4));
            eax = *((ecx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ecx + edx*2 - 2));
            void (*0x8056c30)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80521e0 */
#include <stdint.h>
 
int32_t camlArray_sub_1081 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    edx = eax;
    if (ebx < 1) {
        goto label_2;
    }
    if (ecx < 1) {
        goto label_2;
    }
    esi = *((edx - 4));
    eax = *((edx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = esi;
        eax >>= 9;
    } else {
        eax = esi;
        eax >>= 0xa;
    }
    eax |= 1;
    eax -= ecx;
    eax++;
    if (ebx > eax) {
        goto label_2;
    }
    if (ecx == 1) {
        eax = loc.camlArray__28;
        return eax;
    }
    *(esp) = ecx;
    *((esp + 4)) = ebx;
    *((esp + 8)) = edx;
    eax = *((edx - 4));
    if (eax != 0xfe) {
        eax = *((edx + ebx*2 - 2));
    } else {
label_1:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x8fd;
        *(fp_stack--) = *((edx + ebx*4 - 4));
        *(eax) = fp_stack[0];
        fp_stack--;
    }
    eax = caml_make_vect;
    eax = caml_c_call (ecx);
    esi = eax;
    ebx = 3;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ebx > eax) {
        goto label_4;
    }
    *((esp + 0xc)) = eax;
    *(esp) = esi;
    do {
        eax = *((esp + 4));
        edx = eax + ebx - 1;
        ecx = *((esp + 8));
        eax = *((ecx - 4));
        if (eax != 0xfe) {
            ecx = *((ecx + edx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ecx + edx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            ecx = eax;
        }
        esi = *(esp);
        eax = *((esi - 4));
        if (eax != 0xfe) {
            caml_modify (esi + ebx*2 - 2, ecx);
        } else {
            *(fp_stack--) = *(ecx);
            *((esi + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = ebx;
        eax = ebx;
        eax += 2;
        ebx = eax;
        eax = *((esp + 0xc));
    } while (ecx != eax);
label_4:
    eax = esi;
    return eax;
label_2:
    eax = "Array.sub";
    void (*0x804f810)() ();
label_5:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80612c4 */
#include <stdint.h>
 
int32_t unix_utimes (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_1ah;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x11f33;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x20));
    *((ebp - 0x10)) = eax;
    edx = *((ebp + 0x10));
    *(fp_stack--) = *(edx);
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    edx = *((ebp - 0x20));
    if (eax == 0) {
        if (edx == 0) {
            goto label_0;
        }
    }
    eax = ebp - 0x10;
label_0:
    *((ebp - 0xc)) = edx;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = utime ();
    if (eax == -1) {
        eax = ebx - 0x2175;
        uerror (eax, esi);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806b632 */
#include <stdint.h>
 
int32_t caml_input_value_from_string (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebp + 8));
    caml_input_val_from_string (eax, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059280 */
#include <stdint.h>
 
void camlPrintf_got_spec_1297 (void) {
    edx = ebx;
    ebx = ecx;
    esi = *((ebx + 0xc));
    ecx = *((ebx + 0x14));
    ebx = *((ebx + 0x10));
    return camlPrintf_scan_flags_1292 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c050 */
#include <stdint.h>
 
int32_t camlUnix_fun_2640 (void) {
    eax = unix_setitimer;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ec84 */
#include <stdint.h>
 
int32_t unix_open (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    char * src;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x14572;
    eax = *((ebx - 0x18));
    edi = *(eax);
    *((ebp - 0x38)) = edi;
    edx = ebp - 0x38;
    *(eax) = edx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 3;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x28)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x24)) = eax;
    eax = ebx + 0x93bc;
    eax = *((ebp + 0xc));
    eax = caml_convert_flag_list (eax, eax);
    *((ebp - 0x3c)) = eax;
    eax = *((ebp + 8));
    eax = caml_string_length (eax);
    eax++;
    eax = caml_stat_alloc (eax);
    esi = eax;
    eax = *((ebp + 8));
    strcpy (esi, eax);
    caml_enter_blocking_section ();
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    edx = *((ebp - 0x3c));
    *((esp + 4)) = edx;
    *(esp) = esi;
    eax = open64 ();
    *((ebp - 0x3c)) = eax;
    caml_leave_blocking_section ();
    caml_stat_free (esi);
    if (*((ebp - 0x3c)) == -1) {
        eax = *((ebp + 8));
        eax = ebx - 0x2492;
        uerror (eax, eax);
    }
    eax = *((ebx - 0x18));
    *(eax) = edi;
    edx = *((ebp - 0x3c));
    eax = edx + edx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a464 */
#include <stdint.h>
 
void strcpy (void) {
    strcpy ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049ef4 */
#include <stdint.h>
 
void open64 (void) {
    open64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c070 */
#include <stdint.h>
 
int32_t camlUnix_fun_2644 (void) {
    eax = unix_utimes;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806aacb */
#include <stdint.h>
 
int32_t caml_deserialize_error (int32_t arg_8h) {
    int32_t var_bp_8h;
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    intern_cleanup ();
    eax = *((ebp + 8));
    return caml_failwith (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067894 */
#include <stdint.h>
 
int32_t caml_mul_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] *= *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a6f6 */
#include <stdint.h>
 
uint32_t caml_output_value (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 3;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x14)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    caml_output_val (ebx, eax, eax);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e60d */
#include <stdint.h>
 
uint32_t unix_getitimer (int32_t arg_8h) {
    int32_t var_18h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14beb;
    eax = ebp - 0x18;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x24d4));
    *(esp) = eax;
    eax = getitimer ();
    if (eax == -1) {
        eax = ebx - 0x24e9;
        uerror (eax, 0);
    }
    eax = ebp - 0x18;
    unix_convert_itimer ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a854 */
#include <stdint.h>
 
void getitimer (void) {
    getitimer ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d100 */
#include <stdint.h>
 
uint32_t unix_fork (void) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x160f3;
    eax = fork ();
    esi = eax;
    if (eax == -1) {
        eax = ebx - 0x2560;
        uerror (eax, 0);
    }
    eax = *((ebx - 0x10));
    if (*(eax) != 0) {
        eax = *((ebx - 0xc));
        eax = *(eax);
        if (eax != 0) {
            if (esi == 0) {
                goto label_0;
            }
        }
        if (eax != 0) {
            goto label_1;
        }
        if (esi == 0) {
            goto label_1;
        }
label_0:
        caml_debugger_cleanup_fork ();
    }
label_1:
    eax = esi + esi + 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d834 */
#include <stdint.h>
 
uint32_t unix_getgroups (void) {
    int32_t var_40018h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x159bf;
    eax = ebp - 0x40018;
    *((esp + 4)) = eax;
    *(esp) = 0x10000;
    eax = getgroups ();
    esi = eax;
    if (eax == -1) {
        eax = ebx - 0x254a;
        eax = uerror (eax, 0);
    }
    caml_alloc_tuple (eax);
    if (esi <= 0) {
        goto label_0;
    }
    edx = 0;
    edi = ebp - 0x40018;
    do {
        ecx = *((edi + edx*4));
        ecx = ecx + ecx + 1;
        *((eax + edx*4)) = ecx;
        edx++;
    } while (edx != esi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806966c */
#include <stdint.h>
 
uint32_t caml_ml_seek_out (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    edx = eax;
    edx >>= 0x1f;
    caml_seek_out (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a6c0 */
#include <stdint.h>
 
int32_t camlPrintf_get_int_literal_1258 (void) {
    int32_t var_4h;
    do {
        esi = ebx;
        esi >>= 1;
        edx = *((ecx + 0xc));
        edx = *((edx + esi));
        edx = edx + edx + 1;
        if (edx < 0x61) {
            goto label_0;
        }
        if (edx >= 0x75) {
            goto label_1;
        }
        ebx += 2;
        eax >>= 1;
        eax *= 0x14;
        eax = eax + edx - 0x60;
    } while (1);
label_0:
    if (edx != 0x49) {
        goto label_1;
    }
    if (eax == 1) {
        eax = "printf: bad positional specification (0).";
        void (*0x804f7d0)() ();
    }
    eax += 0xfffffffe;
    eax = camlPrintf_index_of_int_1037 (ecx, ebx);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x400;
            *(edx) = ebx;
            eax = *(esp);
            ecx = *((eax + 0x10));
            ebx = *((esp + 4));
            ebx += 2;
            eax = edx;
            void (*0x804b540)() ();
label_1:
            edx = *((ecx + 0x10));
            ebx = *((ecx + 0x14));
            eax = 1;
            ecx = edx;
            void (*0x804b540)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bec0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2594 (void) {
    eax = unix_shutdown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fad7 */
#include <stdint.h>
 
int32_t caml_register_custom_operations (int32_t arg_8h) {
    caml_stat_alloc (8);
    edx = *((ebp + 8));
    *(eax) = edx;
    edx = custom_ops_table;
    *((eax + 4)) = edx;
    *(obj.custom_ops_table) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80546c0 */
#include <stdint.h>
 
int32_t camlList_fold_left_1078 (void) {
    int32_t var_4h;
    do {
        edx = eax;
        eax = ebx;
        if (ecx == 1) {
            goto label_0;
        }
        esi = *((ecx + 4));
        ecx = *(ecx);
        ebx = *(ecx);
        ecx = edx;
        eax = caml_apply2 (edx, esi);
        ebx = eax;
        eax = *(esp);
        ecx = *((esp + 4));
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c3c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2740 (void) {
    eax = unix_truncate;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806f658 */
#include <stdint.h>
 
int32_t caml_final_register (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 0xc));
    if ((bl & 1) == 0) {
        esi = ebx;
        edx = ebx;
        edx >>= 0x17;
        eax = ebx;
        eax >>= 0xc;
        eax &= 0x7ff;
        edx = *((edx*4 + obj.caml_page_table));
        if ((*((edx + eax)) & 3) != 0) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Gc.finalise");
label_0:
    eax = size;
    if (*(obj.young) >= eax) {
        edx = final_table;
        if (edx == 0) {
            eax = caml_stat_alloc (0x168);
            *(obj.final_table) = eax;
            *(obj.size) = 0x1e;
        } else {
            edi = eax + eax;
            eax = edi + eax*4;
            eax <<= 2;
            eax = caml_stat_resize (edx, eax);
            *(obj.final_table) = eax;
            *(obj.size) = edi;
        }
    }
    eax = young;
    edx = eax * 3;
    edx <<= 2;
    edx += *(obj.final_table);
    ecx = *((ebp + 8));
    *(edx) = ecx;
    ecx = esi - 4;
    if (*(ecx) == 0xf9) {
        ebx = *(ecx);
        ebx >>= 0xa;
        ebx <<= 2;
        *((edx + 8)) = ebx;
        ecx = *(ecx);
        ecx >>= 0xa;
        ecx <<= 2;
        esi -= ecx;
        *((edx + 4)) = esi;
    } else {
        *((edx + 8)) = 0;
        *((edx + 4)) = ebx;
    }
    eax++;
    *(obj.young) = eax;
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059420 */
#include <stdint.h>
 
int32_t camlPrintf_cont_s_1361 (void) {
    int32_t var_4h;
    int32_t var_8h;
    ecx = *((edx + 0x54));
    eax = *((edx + 0x5c));
    caml_apply2 (edx, eax, ecx);
    ecx = *(esp);
    ecx += 0xfffffff0;
    eax = *((esp + 4));
    ebx = *((esp + 8));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c3f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2744 (void) {
    eax = caml_channel_descriptor;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805bee0 */
#include <stdint.h>
 
int32_t camlPrintf_make_valid_float_lexeme_1270 (void) {
    ecx = eax;
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    edx = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = sym.camlPrintf__valid_float_loop_1273;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            *((ebx + 0xc)) = edx;
            eax = 1;
            void (*0x805a780)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e89b */
#include <stdint.h>
 
int32_t caml_weak_set (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    eax = *((ebp + 8));
    ecx = *((ebp + 0x10));
    edx = *((ebp + 0xc));
    edx >>= 1;
    edx++;
    if (edx != 0) {
        esi = eax;
        ebx = *((eax - 4));
        ebx >>= 0xa;
        if (edx < ebx) {
            goto label_0;
        }
    }
    caml_invalid_argument ("Weak.set");
label_0:
    if (ecx != 1) {
        if ((cl & 1) == 0) {
            ecx = *(ecx);
            do_set ();
        }
    } else {
        eax = caml_weak_none;
        *((esi + edx*4)) = eax;
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80640c0 */
#include <stdint.h>
 
int32_t caml_darken (int32_t arg_8h) {
    eax = *((ebp + 8));
    if ((al & 1) == 0) {
        ebx = eax;
        ecx = eax;
        ecx >>= 0x17;
        edx = eax;
        edx >>= 0xc;
        edx &= 0x7ff;
        ecx = *((ecx*4 + obj.caml_page_table));
        if ((*((ecx + edx)) & 1) == 0) {
            goto label_0;
        }
        edx = *((eax - 4));
        ecx = (int32_t) dl;
        if (ecx == 0xf9) {
            edx >>= 0xa;
            eax = edx*4;
            ebx -= eax;
            eax = ebx;
            edx = *((ebx - 4));
            ecx = (int32_t) dl;
        }
        if ((dh & 3) != 0) {
            goto label_0;
        }
        if (ecx <= 0xfa) {
            dh &= 0xfc;
            dh |= 1;
            *((eax - 4)) = edx;
            edx = gray_vals_cur;
            *(edx) = eax;
            eax = edx + 4;
            *(obj.gray_vals_cur) = eax;
            if (eax < *(obj.gray_vals_end)) {
                goto label_0;
            }
            realloc_gray_vals ();
        } else {
            dh |= 3;
            *((eax - 4)) = edx;
        }
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050110 */
#include <stdint.h>
 
int32_t camlPervasives_read_int_1289 (void) {
    eax = 1;
    eax = camlPervasives_read_line_1288 ();
    eax = caml_int_of_string;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80500f0 */
#include <stdint.h>
 
int32_t camlPervasives_read_line_1288 (void) {
    eax = caml_ml_flush;
    caml_c_call (*(0x8076894));
    eax = .comment;
    return camlPervasives_input_line_1241 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056f40 */
#include <stdint.h>
 
uint32_t camlHashtbl_find_rec_1193 (void) {
    int32_t var_4h;
    int32_t var_8h_2;
    int32_t var_ch;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 8));
        edx = *((ebx + 4));
        ebx = *(ebx);
        ecx = *((ecx + 0xc));
        ecx = *(ecx);
        eax = caml_apply2 (eax, edx, ecx);
        if (eax != 1) {
            eax = *((esp + 0xc));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c0a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2648 (void) {
    eax = unix_sleep;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e0f2 */
#include <stdint.h>
 
uint32_t caml_format_exception (int32_t arg_8h) {
    int32_t var_170h;
    uint32_t var_16ch;
    char * s;
    int32_t var_120h;
    int32_t var_11ch;
    int32_t var_118h;
    int32_t var_19h;
    int32_t var_18h;
    char * format;
    size_t n;
    ebx = *((ebp + 8));
    eax = ebp - 0x120;
    edx = ebp - 0x118;
    *((ebp - 0x120)) = edx;
    edx = ebp - 0x19;
    *((ebp - 0x11c)) = edx;
    edx = *(ebx);
    edx = *(edx);
    add_string (ebx, esi, edi);
    eax = *((ebx - 4));
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_0;
    }
    if (eax == 2) {
        esi = *((ebx + 4));
        if ((esi & 1) != 0) {
            goto label_1;
        }
        *((ebp - 0x16c)) = 0;
        if (*((esi - 4)) == 0) {
            goto label_2;
        }
    }
label_1:
    esi = ebx;
    *((ebp - 0x16c)) = 1;
label_2:
    eax = ebp - 0x120;
    edx = 0x28;
    add_char ();
    *((ebp - 0x170)) = esi;
    edi = esi;
    edi -= 4;
    eax = *(edi);
    eax >>= 0xa;
    if (*((ebp - 0x16c)) >= eax) {
        goto label_3;
    }
    esi = *((ebp - 0x16c));
    while (eax > esi) {
        if (*((ebp - 0x16c)) < esi) {
            edx = 0x8071dc4;
            eax = ebp - 0x120;
            add_string ();
        }
        eax = *((ebp - 0x170));
        ebx = *((eax + esi*4));
        if ((bl & 1) != 0) {
            ebx >>= 1;
            edx = ebp - 0x160;
            sprintf (edx, 0x8071abb, ebx);
            edx = ebp - 0x160;
            eax = ebp - 0x120;
            add_string ();
        } else {
            if (*((ebx - 4)) == 0xfc) {
                edx = 0x22;
                eax = ebp - 0x120;
                add_char ();
                edx = ebx;
                eax = ebp - 0x120;
                add_string ();
                edx = 0x22;
                eax = ebp - 0x120;
                add_char ();
            } else {
                edx = 0x5f;
                eax = ebp - 0x120;
                add_char ();
            }
        }
        esi++;
        eax = *(edi);
        eax >>= 0xa;
    }
label_3:
    eax = ebp - 0x120;
    edx = 0x29;
    add_char ();
label_0:
    eax = *((ebp - 0x120));
    *(eax) = 0;
    eax = *((ebp - 0x120));
    edx = ebp - 0x18;
    eax -= edx;
    esi = eax + 0x101;
    eax = malloc (esi);
    ebx = eax;
    if (eax != 0) {
        eax = ebp - 0x118;
        memmove (ebx, eax, esi);
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fd40 */
#include <stdint.h>
 
int32_t camlPervasives_open_in_bin_1220 (void) {
    ecx = eax;
    ebx = 1;
    eax = loc.camlPervasives__89;
    return camlPervasives_open_in_gen_1214 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f990 */
#include <stdint.h>
 
int32_t camlPervasives_char_of_int_1120 (void) {
    if (eax >= 1) {
        if (eax > 0x1ff) {
            goto label_0;
        }
        return;
    }
label_0:
    eax = "char_of_int";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bee0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2598 (void) {
    eax = unix_connect;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066013 */
#include <stdint.h>
 
int32_t caml_int_compare (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    cl = (edx > eax) ? 1 : 0;
    ecx = (int32_t) cl;
    dl = (edx < eax) ? 1 : 0;
    edx = (int32_t) dl;
    eax = ecx;
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bfae */
#include <stdint.h>
 
int32_t caml_sys_rename (char * oldpath, int32_t arg_ch) {
    char * newpath;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = rename (eax, eax);
    if (eax != 0) {
        caml_sys_error (1);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805dadf */
#include <stdint.h>
 
int32_t unix_gethostbyaddr (int32_t arg_8h, int32_t arg_ch, int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch) {
    int32_t var_2738h;
    int32_t var_2734h;
    int32_t var_24h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x15715;
    eax = *((ebp + 8));
    eax = *(eax);
    *((ebp - 0xc)) = eax;
    caml_enter_blocking_section ();
    eax = ebp - 0x2738;
    *((esp + 0x1c)) = eax;
    eax = ebp - 0x10;
    *((esp + 0x18)) = eax;
    *((esp + 0x14)) = 0x2710;
    eax = ebp - 0x2734;
    *((esp + 0x10)) = eax;
    eax = ebp - 0x24;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = 2;
    *((esp + 4)) = 4;
    eax = ebp - 0xc;
    *(esp) = eax;
    eax = gethostbyaddr_r ();
    esi = eax;
    caml_leave_blocking_section ();
    if (esi != 0) {
        *((ebp - 0x10)) = 0;
    } else {
        eax = *((ebp - 0x10));
        if (eax != 0) {
            goto label_0;
        }
    }
    caml_raise_not_found ();
label_0:
    alloc_host_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066103 */
#include <stdint.h>
 
int32_t caml_int64_to_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80589d0 */
#include <stdint.h>
 
int32_t camlBuffer_add_substring_1076 (void) {
    int32_t var_4h_3;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 0x10)) = eax;
    *(esp) = ebx;
    *((esp + 4)) = ecx;
    *((esp + 8)) = edx;
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        eax = *((ebx - 4));
        eax >>= 0xa;
        eax = eax*4 - 1;
        ebx = *((ebx + eax));
        eax -= ebx;
        eax <<= 1;
        eax -= edx;
        eax += 2;
        if (ecx <= eax) {
            goto label_1;
        }
    }
label_0:
    eax = "Buffer.add_substring";
    camlPervasives_invalid_arg_1012 ();
label_1:
    eax = *((esp + 0x10));
    ecx = *((eax + 4));
    ebx = *((esp + 8));
    edx = ecx + ebx - 1;
    *((esp + 0xc)) = edx;
    ecx = *((eax + 8));
    if (edx > ecx) {
        camlBuffer_resize_1066 ();
    }
    eax = *((esp + 0x10));
    edx = *((eax + 4));
    ecx = *(eax);
    eax = *(esp);
    ebx = *((esp + 4));
    esi = *((esp + 8));
    camlString_blit_1056 ();
    ebx = *((esp + 0xc));
    eax = *((esp + 0x10));
    *((eax + 4)) = ebx;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061da1 */
#include <stdint.h>
 
int32_t caml_raise_with_string (void) {
    int32_t var_ch_3;
    int32_t var_4h_4;
    int32_t var_4h_3;
    eax = *((ebp + 0xc));
    eax = caml_copy_string (eax);
    eax = *((ebp + 8));
    return caml_raise_with_arg (eax, eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80559b0 */
#include <stdint.h>
 
int32_t camlString_concat_1066 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    if (ebx == 1) {
        goto label_1;
    }
    *((esp + 0xc)) = eax;
    eax = *((ebx + 4));
    *((esp + 0x10)) = eax;
    eax = *(ebx);
    *((esp + 8)) = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x24;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x400;
    *(edx) = 1;
    ecx = edx + 8;
    *((ecx - 4)) = 0x400;
    *(ecx) = 1;
    eax = edx + 0x10;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.camlString__fun_1160;
    *((eax + 4)) = 3;
    *((eax + 8)) = edx;
    *((eax + 0xc)) = ecx;
    camlList_iter_1074 (edx, ecx);
    eax = *(esp);
    eax = *(eax);
    eax += 0xfffffffe;
    eax >>= 1;
    ebx = *((esp + 0xc));
    ecx = *((ebx - 4));
    ecx >>= 0xa;
    ecx = ecx*4 - 1;
    ebx = *((ebx + ecx));
    ecx -= ebx;
    ecx <<= 1;
    ecx *= eax;
    eax = *((esp + 4));
    eax = *(eax);
    eax += ecx;
    eax = caml_create_string;
    eax = caml_c_call (eax);
    edi = eax;
    esi = *((esp + 8));
    eax = *((esi - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ebx = *((esi + eax));
    eax -= ebx;
    caml_blit_string (edi, 1, edi, 1, eax + eax + 1);
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x400;
            eax = *((esi - 4));
            eax >>= 0xa;
            eax = eax*4 - 1;
            ecx = *((esi + eax));
            eax -= ecx;
            eax = eax + eax + 1;
            *(ebx) = eax;
            eax = ebx + 8;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlString__fun_1163;
            *((eax + 4)) = 3;
            ecx = *((esp + 0xc));
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = edi;
            *((eax + 0x10)) = ebx;
            ebx = *((esp + 0x10));
            camlList_iter_1074 ();
            eax = *(esp);
            return eax;
label_1:
            eax = loc.camlString__29;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ae90 */
#include <stdint.h>
 
int32_t caml_curry7_5 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_6;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c410 */
#include <stdint.h>
 
int32_t camlUnix_fun_2748 (void) {
    eax = caml_ml_open_descriptor_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050b70 */
#include <stdint.h>
 
int32_t camlArray_tolist_1123 (void) {
    do {
        edx = eax;
        if (edx < 1) {
            eax = ebx;
            return eax;
        }
        esi = *((ecx + 0xc));
        eax = *((esi - 4));
        if (eax != 0xfe) {
            edi = *((esi + edx*2 - 2));
        } else {
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            edi = eax + 4;
            *((edi - 4)) = 0x8fd;
            *(fp_stack--) = *((esi + edx*4 - 4));
            *(edi) = fp_stack[0];
            fp_stack--;
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_3;
        }
        esi = eax + 4;
        *((esi - 4)) = 0x800;
        *(esi) = edi;
        *((esi + 4)) = ebx;
        eax = edx;
        eax += 0xfffffffe;
        ebx = esi;
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f669 */
#include <stdint.h>
 
uint32_t unix_recvfrom (void * s1, int32_t arg_bp_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_10h, int32_t arg_sp_14h) {
    int32_t var_40b0h;
    int32_t var_40ach;
    int32_t var_40a8h;
    int32_t var_40a4h;
    int32_t var_40a0h;
    int32_t var_4090h;
    int32_t var_408ch;
    int32_t var_401ch;
    int32_t var_4018h;
    void * s2;
    size_t n;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x13b8a;
    *((ebp - 0x401c)) = 1;
    eax = ebx + 0x93ec;
    eax = *((ebp + 0x18));
    eax = caml_convert_flag_list (eax, eax);
    edi = eax;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x40b0)) = edx;
    edx = ebp - 0x40b0;
    *(eax) = edx;
    *((ebp - 0x40a8)) = 1;
    *((ebp - 0x40ac)) = 2;
    eax = ebp + 0xc;
    *((ebp - 0x40a4)) = eax;
    eax = ebp - 0x401c;
    *((ebp - 0x40a0)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    *((ebp - 0x4090)) = 0x70;
    caml_enter_blocking_section ();
    eax = ebp - 0x4090;
    *((esp + 0x14)) = eax;
    eax = ebp - 0x408c;
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = edi;
    eax = 0x4000;
    if (esi > 0x4000) {
        esi = eax;
    }
    eax = ebp - 0x4018;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = recvfrom (eax, eax, esi);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x2439;
        uerror (eax, 0);
    }
    eax = ebp - 0x4018;
    eax = *((ebp + 0x10));
    eax >>= 1;
    eax += *((ebp + 0xc));
    memmove (eax, eax, esi);
    eax = *((ebp - 0x4090));
    eax = ebp - 0x408c;
    eax = alloc_sockaddr (eax, eax, 0xffffffff);
    *((ebp - 0x401c)) = eax;
    caml_alloc_small (2, 0);
    edx = esi + esi + 1;
    *(eax) = edx;
    edx = *((ebp - 0x401c));
    *((eax + 4)) = edx;
    ecx = *((ebp - 0x40b0));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a824 */
#include <stdint.h>
 
void recvfrom (void) {
    recvfrom ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056b10 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_bucket_1116 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_2;
        }
        *((esp + 8)) = ebx;
        ecx = *((eax + 8));
        *((esp + 0xc)) = ecx;
        ecx = *((eax + 4));
        *(esp) = ecx;
        eax = *(eax);
        *((esp + 4)) = eax;
        eax = caml_compare;
        eax = caml_c_call (eax);
        if (eax == 1) {
label_1:
            eax = caml_young_ptr;
            eax -= 0x10;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *((esp + 4));
            *(eax) = ebx;
            ebx = *((esp + 8));
            ebx = *((ebx + 0xc));
            *((eax + 4)) = ebx;
            ebx = *((esp + 0xc));
            *((eax + 8)) = ebx;
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_replace_bucket_1116 ();
    } while (1);
    ecx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_4;
    }
    eax = eax + 4;
    *((eax - 4)) = 0xc00;
    ebx = *((esp + 4));
    *(eax) = ebx;
    ebx = *(esp);
    *((eax + 4)) = ebx;
    *((eax + 8)) = ecx;
    return eax;
    do {
label_2:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e784 */
#include <stdint.h>
 
int32_t unix_kill (pid_t pid, int32_t arg_ch) {
    int32_t sig;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14a74;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = caml_convert_signal_number (eax);
    eax = *((ebp + 8));
    eax >>= 1;
    eax = kill (eax, eax);
    if (eax == -1) {
        eax = ebx - 0x24c8;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a7e4 */
#include <stdint.h>
 
void kill (void) {
    kill ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80632a0 */
#include <stdint.h>
 
int32_t caml_fl_reset (void) {
    *(0x807ca48) = 0;
    eax = caml_allocation_policy;
    if (eax != 0) {
        if (eax != 1) {
            goto label_0;
        }
    } else {
        *(obj.fl_prev) = 0x807ca48;
        goto label_0;
    }
    eax = 0x807ca48;
    truncate_flp ();
label_0:
    *(obj.caml_fl_cur_size) = 0;
    caml_fl_init_merge ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069472 */
#include <stdint.h>
 
uint32_t caml_ml_output_int (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    caml_putword (ebx, eax);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c560 */
#include <stdint.h>
 
int32_t camlUnix_handle_unix_error_1171 (void) {
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = ebx;
    eax = void (*0x804c670)() ();
    ecx = camlUnix;
    ebx = *(eax);
    if (ebx == ecx) {
        ebx = *((eax + 0xc));
        *((esp + 8)) = ebx;
        ebx = *((eax + 8));
        *(esp) = ebx;
        eax = *((eax + 4));
        *((esp + 4)) = eax;
        ebx = *(loc.camlSys);
        eax = *((ebx - 4));
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        ebx = *(ebx);
        eax = .comment;
        camlPervasives_output_string_1191 ();
        ebx = loc.camlUnix__214;
        eax = .comment;
        camlPervasives_output_string_1191 ();
        eax = .comment;
        ebx = *(esp);
        camlPervasives_output_string_1191 ();
        ebx = "\" failed";
        eax = .comment;
        camlPervasives_output_string_1191 ();
        eax = *((esp + 8));
        ebx = *((eax - 4));
        ebx >>= 0xa;
        ebx = ebx*4 - 1;
        ecx = *((eax + ebx));
        ebx -= ecx;
        ebx = ebx + ebx + 1;
        if (ebx > 1) {
            ebx = " on \";
            eax = .comment;
            camlPervasives_output_string_1191 (eax);
            eax = .comment;
            ebx = *((esp + 8));
            camlPervasives_output_string_1191 ();
            ebx = loc.camlUnix__211;
            eax = .comment;
            camlPervasives_output_string_1191 ();
        }
        ebx = loc.camlUnix__210;
        eax = .comment;
        camlPervasives_output_string_1191 ();
        eax = *((esp + 4));
        eax = unix_error_message;
        caml_c_call (eax);
        camlPervasives_prerr_endline_1285 ();
        eax = 5;
        void (*0x8050290)() ();
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    ecx = *(edx);
    ebx = edx;
    void (*ecx)(uint32_t*) (*(obj.caml_exception_pointer));
    return eax;
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bbca */
#include <stdint.h>
 
uint32_t caml_sys_random_seed (void) {
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    *((esp + 4)) = 0;
    eax = ebp - 0x20;
    *(esp) = eax;
    gettimeofday ();
    esi = *((ebp - 0x20));
    ebx = *((ebp - 0x1c));
    eax = getppid ();
    edi = eax;
    eax = getpid ();
    ebx ^= esi;
    ebx ^= eax;
    edx = edi;
    edx <<= 0x10;
    edi = ebx;
    edi ^= edx;
    eax = edi + edi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b330 */
#include <stdint.h>
 
uint32_t camlPrintf_add_int_index_1040 (void) {
    eax = eax + ebx - 1;
    return camlPrintf_index_of_int_1037 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80630ac */
#include <stdint.h>
 
int32_t caml_fatal_error_arg (int32_t arg_8h, int32_t arg_ch) {
    char ** format;
    int32_t var_8h;
    eax = *((ebp + 0xc));
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax = stderr;
    fprintf (eax, eax);
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806685e */
#include <stdint.h>
 
int32_t caml_nativeint_shift_left (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax <<= cl;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c880 */
#include <stdint.h>
 
uint32_t camlUnix_is_inet6_addr_1500 (void) {
    ecx = eax;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    al = (eax == 0x21) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060a55 */
#include <stdint.h>
 
int32_t unix_tcflush (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x127a3;
    eax = *((ebp + 0xc));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x2294));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = tcflush ();
    if (eax == -1) {
        eax = ebx - 0x22ef;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a294 */
#include <stdint.h>
 
void tcflush (void) {
    tcflush ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050060 */
#include <stdint.h>
 
uint32_t camlPervasives_prerr_float_1283 (void) {
    eax = camlPervasives_string_of_float_1140 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804cbb0 */
#include <stdint.h>
 
int32_t camlUnix_getaddrinfo_emulation_1730 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_4h;
    int32_t var_8h;
    *((esp + 0xc)) = eax;
    *(esp) = ebx;
    ebx = ecx;
    *((esp + 0x10)) = ebx;
label_6:
    eax = caml_young_ptr;
    eax -= 0x30;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_7;
    }
    edi = eax + 4;
    *((edi - 4)) = 0x400;
    *(edi) = 1;
    esi = edi + 8;
    *((esi - 4)) = 0x400;
    *(esi) = 1;
    edx = edi + 0x10;
    *((edx - 4)) = 0x400;
    *(edx) = 1;
    eax = edi + 0x18;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.camlUnix__fun_2828;
    *((eax + 4)) = 3;
    *((eax + 8)) = edi;
    *((eax + 0xc)) = esi;
    *((eax + 0x10)) = edx;
    camlList_iter_1074 (edi, esi);
label_5:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_8;
    }
    ecx = eax + 4;
    *((ecx - 4)) = 0x10f7;
    *(ecx) = sym.caml_curry2;
    *((ecx + 4)) = 5;
    *((ecx + 8)) = 0x804bb30;
    edx = *(esp);
    *((ecx + 0xc)) = edx;
    eax = *((esp + 4));
    eax = *(eax);
    if (eax != 1) {
        ebx = *(eax);
        if (ebx != 3) {
            if (ebx != 1) {
                eax = caml_string_equal (edx, loc.camlUnix__202);
                if (eax != 1) {
label_4:
                    eax = caml_young_ptr;
                    eax -= 0x18;
                    *(obj.caml_young_ptr) = eax;
                    if (eax < *(obj.caml_young_limit)) {
                        goto label_9;
                    }
                    ecx = eax + 4;
                    *((ecx - 4)) = 0x800;
                    *(ecx) = ebx;
                    *((ecx + 4)) = 1;
                    eax = ecx + 0xc;
                    *(esp) = eax;
                    *((eax - 4)) = 0x800;
                    *(eax) = ecx;
                    *((eax + 4)) = 1;
                    eax = 1;
                    *(esp) = eax;
                    ebx = loc.camlUnix__201;
                    eax = 1;
                    eax = camlUnix_get_port_1739 ();
                    *(esp) = eax;
                    ebx = loc.camlUnix__200;
                    eax = 3;
                    eax = camlUnix_get_port_1739 ();
                    *(esp) = eax;
                } else {
                } else {
                } else {
                } else {
                    ebx = loc.camlUnix__199;
                    eax = 3;
                    eax = camlUnix_get_port_1739 (ecx);
                    ebx = loc.camlUnix__198;
                    eax = 1;
                    ecx = *(esp);
                    camlUnix_get_port_1739 (eax);
                    ebx = *((esp + 4));
                    eax = camlPervasives_$40_1143 ();
                }
            }
        }
    }
    ebx = *((esp + 0x10));
    eax = caml_string_equal (eax, loc.camlUnix__197);
    if (eax != 1) {
        eax = 5;
        ebx = *((esp + 0x10));
        eax = camlList_mem_1161 ();
        if (eax != 1) {
label_3:
            eax = caml_young_ptr;
            eax -= 0x18;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = .comment;
            *(ebx) = eax;
            *((ebx + 4)) = "0.0.0.0";
            ecx = ebx + 0xc;
            *((ecx - 4)) = 0x800;
            *(ecx) = ebx;
            *((ecx + 4)) = 1;
label_2:
            eax = caml_young_ptr;
            eax -= 0x18;
            *(obj.caml_young_ptr) = eax;
        } else {
        } else {
        }
    }
    if (eax < *(obj.caml_young_limit)) {
        goto label_11;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x800;
    eax = .comment;
    *(ebx) = eax;
    *((ebx + 4)) = "127.0.0.1";
    ecx = ebx + 0xc;
    *((ecx - 4)) = 0x800;
    *(ecx) = ebx;
    *((ecx + 4)) = 1;
    eax = void (*0x804cf20)(uint32_t) (ebx);
    ecx = "45\a\b";
    ebx = *(eax);
    if (ebx == ecx) {
        eax = void (*0x804ce90)() ();
        ecx = loc.caml_exn_Not_found;
        ebx = *(eax);
        if (ebx == ecx) {
            ecx = 1;
        } else {
            caml_raise_exn ();
        }
        *(obj.caml_exception_pointer) = esp;
        eax = *((esp + 0x14));
        eax = unix_gethostbyname;
        eax = caml_c_call (eax);
        eax = *((eax + 0xc));
        eax = camlArray_to_list_1121 (eax);
        ebx = eax;
label_1:
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_12;
        }
        eax = eax + 4;
        *((eax - 4)) = 0xcf7;
        *(eax) = sym.camlUnix__fun_2833;
        *((eax + 4)) = 3;
        ecx = *((esp + 0xc));
        *((eax + 8)) = ecx;
        eax = camlList_map_1062 ();
        ecx = eax;
    } else {
        caml_raise_exn ();
        *(obj.caml_exception_pointer) = esp;
        eax = unix_inet_addr_of_string;
        eax = caml_c_call (ebx);
        ecx = eax;
label_0:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_13;
        }
        ebx = eax + 4;
        *((ebx - 4)) = 0x800;
        *(ebx) = ecx;
        eax = *((esp + 0x14));
        *((ebx + 4)) = eax;
        ecx = ebx + 0xc;
        *((ecx - 4)) = 0x800;
        *(ecx) = ebx;
        *((ecx + 4)) = 1;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.caml_tuplify2;
            *((eax + 4)) = 0xfffffffd;
            *((eax + 8)) = 0x804bd40;
            ebx = *((esp + 8));
            *((eax + 0xc)) = ebx;
            *((eax + 0x10)) = ecx;
            ebx = *(esp);
            camlList_map_1062 ();
            void (*0x8054580)() ();
        }
        caml_call_gc ();
    } while (1);
label_13:
    caml_call_gc ();
    goto label_0;
label_12:
    caml_call_gc ();
    goto label_1;
label_11:
    caml_call_gc ();
    goto label_2;
label_10:
    caml_call_gc ();
    goto label_3;
label_9:
    caml_call_gc ();
    goto label_4;
label_8:
    caml_call_gc ();
    goto label_5;
label_7:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068a23 */
#include <stdint.h>
 
int32_t caml_ml_channel_size (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax = caml_channel_size (ebx);
    ebx = eax;
    if (edx >= 0) {
        if (edx <= 0) {
            if (eax <= 0x3fffffff) {
                goto label_0;
            }
        }
        errno_location ();
        *(eax) = 0x4b;
        caml_sys_error (1);
    }
label_0:
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806729c */
#include <stdint.h>
 
int32_t caml_classify_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = fpclassify ();
    edx = eax;
    eax = 1;
    if (edx <= 3) {
        eax = *((edx*4 + obj.CSWTCH.118));
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a1e4 */
#include <stdint.h>
 
void fpclassify (void) {
    fpclassify ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c170 */
#include <stdint.h>
 
int32_t camlUnix_fun_2672 (void) {
    eax = unix_select;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f7b0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1422 (void) {
    eax = caml_ml_output_char;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068759 */
#include <stdint.h>
 
int32_t caml_close_channel (int32_t fildes) {
    ebx = *((ebp + 8));
    eax = *(ebx);
    close (eax);
    if (*((ebx + 0x2c)) <= 0) {
        eax = caml_channel_mutex_free;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        eax = ebx;
        unlink_channel ();
        caml_stat_free (ebx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c1a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2676 (void) {
    eax = unix_symlink;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806750f */
#include <stdint.h>
 
int32_t caml_asin_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    asin (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049ed4 */
#include <stdint.h>
 
void asin (void) {
    asin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bdc0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2564 (void) {
    eax = unix_tcflow;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bde0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2568 (void) {
    eax = unix_tcdrain;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058ca0 */
#include <stdint.h>
 
int32_t camlBuffer_find_ident_1114 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    if (ebx >= ecx) {
label_1:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_2;
        }
        eax = eax + 4;
        *((eax - 4)) = 0x400;
        *(eax) = loc.caml_exn_Not_found;
        eax = caml_raise_exn ();
    }
    *((esp + 8)) = ebx;
    *((esp + 0xc)) = eax;
    ecx = ebx;
    ecx >>= 1;
    edx = *((eax - 4));
    edx >>= 0xa;
    edx = edx*4 - 1;
    esi = *((eax + edx));
    edx -= esi;
    if (edx <= ecx) {
        goto label_3;
    }
    ecx = *((eax + ecx));
    ecx = ecx + ecx + 1;
    if (ecx != 0x51) {
        if (ecx != 0xf7) {
            ebx += 2;
            eax = camlBuffer_advance_to_non_alpha_1108 ();
            ebx = *((esp + 8));
            eax -= ebx;
            ecx = eax;
            ecx++;
            eax = *((esp + 0xc));
            eax = camlString_sub_1046 (eax);
            ecx = eax;
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_4;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            eax = *(esp);
            *((ebx + 4)) = eax;
            eax = ebx;
            return eax;
        }
        *(esp) = ecx;
    } else {
    }
    ebx += 2;
    eax = ecx;
    eax = camlBuffer_closing_1097 (ecx, ebx);
    ebx = eax;
    ecx = 1;
    eax = *(esp);
    edx = *((esp + 0xc));
    esi = *((esp + 4));
    eax = camlBuffer_advance_to_closing_1098 ();
    ebx = *((esp + 8));
    eax -= ebx;
    eax -= 3;
    ecx = eax;
    ecx += 2;
    eax = *((esp + 0xc));
    ebx = *((esp + 4));
    eax = camlString_sub_1046 (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            ebx = *(esp);
            ebx += 2;
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067dea */
#include <stdint.h>
 
uint32_t caml_make_array (int32_t arg_8h) {
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = caml_local_roots;
    *((ebp - 0x38)) = ebx;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x3c)) = 0;
    *((ebp - 0x40)) = 0;
    eax = ebp - 0x38;
    *((ebp - 0x60)) = eax;
    eax = ebp - 0x60;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x58)) = 1;
    *((ebp - 0x5c)) = 2;
    eax = ebp - 0x3c;
    *((ebp - 0x54)) = eax;
    eax = ebp - 0x40;
    *((ebp - 0x50)) = eax;
    eax = *((ebp + 8));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi == 0) {
        *(obj.caml_local_roots) = ebx;
        goto label_0;
    }
    edx = *(eax);
    if ((dl & 1) == 0) {
        *((ebp - 0x3c)) = edx;
        edi = edx;
        edi >>= 0x17;
        ecx = edx;
        ecx >>= 0xc;
        ecx &= 0x7ff;
        edi = *((edi*4 + obj.caml_page_table));
        if ((*((edi + ecx)) & 7) == 0) {
            goto label_1;
        }
        if (*((edx - 4)) == 0xfd) {
            goto label_2;
        }
    }
label_1:
    *(obj.caml_local_roots) = ebx;
    goto label_0;
label_2:
    eax = esi + esi;
    eax = caml_alloc_small (eax, 0xfe);
    *((ebp - 0x40)) = eax;
    eax = 0;
    do {
        edx = *((ebp + 8));
        edx = *((edx + eax*4));
        *(fp_stack--) = *(edx);
        edx = *((ebp - 0x40));
        *((edx + eax*8)) = fp_stack[0];
        fp_stack--;
        eax++;
    } while (esi > eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x40));
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c430 */
#include <stdint.h>
 
int32_t camlUnix_fun_2752 (void) {
    eax = unix_close;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80697ce */
#include <stdint.h>
 
int32_t caml_ml_open_descriptor_out (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    eax = caml_open_descriptor_out (eax);
    caml_alloc_channel (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80697b4 */
#include <stdint.h>
 
int32_t caml_open_descriptor_out (int32_t arg_8h) {
    eax = *((ebp + 8));
    caml_open_descriptor_in (eax);
    *((eax + 0x14)) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c150 */
#include <stdint.h>
 
int32_t camlPrintf_kfprintf_1386 (void) {
    edi = eax;
    ecx = ebx;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xcf7;
            *(ebx) = sym.camlPrintf__fun_1680;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            ebp = .comment;
            esi = .comment;
            edx = .comment;
            ecx = .comment;
            eax = 1;
            *(loc.caml_extra_params) = ebp;
            void (*0x804b3e0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bfa0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2618 (void) {
    eax = unix_getpwnam;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e02c */
#include <stdint.h>
 
int32_t unix_getpwuid (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x151cc;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getpwuid ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_passwd_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a3f4 */
#include <stdint.h>
 
void getpwuid (void) {
    getpwuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f294 */
#include <stdint.h>
 
int32_t unix_select (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_1c0h;
    int32_t var_1bch;
    int32_t var_1bah;
    int32_t var_1b4h;
    int32_t var_1b0h;
    int32_t var_1ach;
    int32_t var_1a8h;
    int32_t var_1a4h;
    int32_t var_1a0h;
    int32_t var_194h;
    int32_t nfds;
    int32_t var_188h;
    int32_t var_108h;
    int32_t var_88h;
    fd_set * readfds;
    fd_set * writefds;
    fd_set * exceptfds;
    struct timeval * timeout;
    _i686_get_pc_thunk_bx (ebx, esi);
    ebx += 0x13f60;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x1b4)) = edx;
    edx = ebp - 0x1b4;
    *(eax) = edx;
    *((ebp - 0x1ac)) = 1;
    *((ebp - 0x1b0)) = 3;
    eax = ebp + 8;
    *((ebp - 0x1a8)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x1a4)) = eax;
    eax = ebp + 0x10;
    *((ebp - 0x1a0)) = eax;
    *((ebp - 0x18c)) = 0xffffffff;
    edx = ebp - 0x88;
    esi = ebp - 0x18c;
    eax = *((ebp + 8));
    fdlist_to_fdset (esi);
    edx = ebp - 0x108;
    eax = *((ebp + 0xc));
    fdlist_to_fdset (esi);
    edx = ebp - 0x188;
    eax = *((ebp + 0x10));
    fdlist_to_fdset (esi);
    eax = *((ebp + 0x14));
    *(fp_stack--) = *(eax);
    esi = 0;
    *(fp_stack--) = 0.0;
    fp_stack--;
    if (fp_stack[0] <= fp_stack[1]) {
        eax = *((ebp - 0x1ba));
        ah = 0xc;
        *((ebp - 0x1bc)) = ax;
        *((ebp - 0x1c0)) = fp_stack[0];
        eax = *((ebp - 0x1c0));
        *((ebp - 0x194)) = eax;
        *((ebp - 0x1c0)) = eax;
        *(fp_stack--) = *((ebp - 0x1c0));
        fp_stack[0] -= fp_stack[1];
        fp_stack++;
        fp_stack[0] *= *((ebx - 0x251c));
        *((ebp - 0x190)) = fp_stack[0];
        fp_stack--;
        esi = ebp - 0x194;
    } else {
        fp_stack++;
    }
    caml_enter_blocking_section ();
    eax = ebp - 0x188;
    eax = ebp - 0x108;
    eax = ebp - 0x88;
    eax = *((ebp - 0x18c));
    eax++;
    eax = select (esi, eax, eax);
    esi = eax;
    caml_leave_blocking_section ();
    if (esi == -1) {
        eax = ebx - 0x244c;
        uerror (eax, 0);
    }
    edx = ebp - 0x88;
    eax = *((ebp + 8));
    eax = fdset_to_fdlist ();
    *((ebp + 8)) = eax;
    edx = ebp - 0x108;
    eax = *((ebp + 0xc));
    eax = fdset_to_fdlist ();
    *((ebp + 0xc)) = eax;
    edx = ebp - 0x188;
    eax = *((ebp + 0x10));
    eax = fdset_to_fdlist ();
    *((ebp + 0x10)) = eax;
    caml_alloc_small (3, 0);
    edx = *((ebp + 8));
    *(eax) = edx;
    edx = *((ebp + 0xc));
    *((eax + 4)) = edx;
    edx = *((ebp + 0x10));
    *((eax + 8)) = edx;
    ecx = *((ebp - 0x1b4));
    edx = *((ebx - 0x18));
    *(edx) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b3e0 */
#include <stdint.h>
 
int32_t caml_apply6 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    *((esp + 4)) = eax;
    *((esp + 8)) = ebx;
    *((esp + 0xc)) = ecx;
    *((esp + 0x10)) = edx;
    *((esp + 0x14)) = esi;
    *((esp + 0x18)) = edi;
    ebx = caml_extra_params;
    eax = *((ebx + 4));
    if (eax == 0xd) {
        *(esp) = ebx;
        eax = *((ebx + 8));
        *((esp + 0x1c)) = eax;
        eax = *((esp + 4));
        ebx = *((esp + 8));
        ecx = *((esp + 0xc));
        edx = *((esp + 0x10));
        esi = *((esp + 0x14));
        edi = *((esp + 0x18));
        ebp = *(esp);
        *(loc.caml_extra_params) = ebp;
        ebp = *((esp + 0x1c));
        void (*ebp)() ();
    }
    eax = *(ebx);
    eax = *((esp + 4));
    ecx = *(esp);
    eax = void (*ecx)(uint32_t) (eax);
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 8));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0xc));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0x10));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0x14));
    eax = void (*ecx)() ();
    ebx = eax;
    ecx = *(ebx);
    eax = *((esp + 0x18));
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c460 */
#include <stdint.h>
 
int32_t camlUnix_fun_2756 (void) {
    eax = unix_nice;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80684c7 */
#include <stdint.h>
 
int32_t caml_ml_set_binary_mode (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067600 */
#include <stdint.h>
 
int32_t caml_sqrt_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(fp_stack--) = fp_stack[0];
    fp_stack[0] = sqrt(fp_stack[0]);
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_0;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(esp) = fp_stack[0];
    fp_stack--;
    sqrt ();
    goto label_1;
label_0:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_1:
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ad90 */
#include <stdint.h>
 
int32_t caml_curry7_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d6e0 */
#include <stdint.h>
 
uint32_t unix_getgid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15b18;
    getgid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a8d4 */
#include <stdint.h>
 
void getgid (void) {
    getgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c87f */
#include <stdint.h>
 
int32_t caml_init_gc (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h) {
    char * var_4h;
    int32_t var_8h;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    norm_heapincr (ebx, esi);
    ebx = eax*4;
    eax = ebx + esi*4;
    eax = caml_page_table_initialize (eax);
    if (eax != 0) {
        caml_fatal_error (0x8071b7c);
    }
    eax = esi;
    eax = norm_minsize ();
    eax <<= 2;
    caml_set_minor_heap_size (eax);
    eax = *((ebp + 0x10));
    eax = norm_heapincr ();
    eax <<= 2;
    *(obj.caml_major_heap_increment) = eax;
    eax = *((ebp + 0x14));
    eax = norm_pfree ();
    *(obj.caml_percent_free) = eax;
    eax = *((ebp + 0x18));
    eax = norm_pmax ();
    *(obj.caml_percent_max) = eax;
    caml_init_major_heap (ebx);
    eax = caml_minor_heap_size;
    eax >>= 0xa;
    caml_gc_message (0x20, "Initial minor heap size: %luk bytes\n", eax);
    ebx >>= 0xa;
    caml_gc_message (0x20, "Initial major heap size: %luk bytes\n", ebx);
    eax = caml_percent_free;
    caml_gc_message (0x20, "Initial space overhead: %lu%%\n", eax);
    eax = caml_percent_max;
    caml_gc_message (0x20, "Initial max overhead: %lu%%\n", eax);
    eax = caml_major_heap_increment;
    eax >>= 0xa;
    caml_gc_message (0x20, "Initial heap increment: %luk bytes\n", eax);
    eax = caml_allocation_policy;
    caml_gc_message (0x20, "Initial allocation policy: %d\n", eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064a02 */
#include <stdint.h>
 
int32_t caml_set_minor_heap_size (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    eax = caml_young_ptr;
    if (eax != *(obj.caml_young_end)) {
        caml_minor_collection ();
    }
    eax = ebp - 0x1c;
    eax = caml_aligned_malloc (edi, 0, eax);
    ebx = eax;
    if (eax == 0) {
        eax = caml_raise_out_of_memory ();
    }
    esi = eax + edi;
    eax = caml_page_table_add (2, eax, esi);
    if (eax != 0) {
        caml_raise_out_of_memory ();
    }
    eax = caml_young_start;
    if (eax != 0) {
        edx = caml_young_end;
        caml_page_table_remove (2, eax, edx);
        eax = caml_young_base;
        free (eax);
    }
    eax = *((ebp - 0x1c));
    *(obj.caml_young_base) = eax;
    *(obj.caml_young_start) = ebx;
    *(obj.caml_young_end) = esi;
    *(obj.caml_young_limit) = ebx;
    *(obj.caml_young_ptr) = esi;
    *(obj.caml_minor_heap_size) = edi;
    eax = caml_ref_table;
    reset_table ();
    eax = caml_weak_ref_table;
    reset_table ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8063a2c */
#include <stdint.h>
 
int32_t caml_init_major_heap (int32_t arg_8h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 8));
    eax = clip_heap_chunk_size ();
    *(obj.caml_stat_heap_size) = eax;
    *(obj.caml_stat_top_heap_size) = eax;
    eax = caml_alloc_for_heap (eax);
    *(obj.caml_heap_start) = eax;
    if (eax == 0) {
        caml_fatal_error ("Fatal error: not enough memory for the initial heap.\n");
    }
    *((eax - 4)) = 0;
    *(obj.caml_stat_heap_chunks) = 1;
    eax = caml_heap_start;
    edx = caml_heap_start;
    edx += *(obj.caml_stat_heap_size);
    eax = caml_page_table_add (1, eax, edx);
    if (eax != 0) {
        caml_fatal_error ("Fatal error: not enough memory for the initial page table.\n");
    }
    caml_fl_init_merge ();
    eax = caml_stat_heap_size;
    eax >>= 2;
    eax = caml_heap_start;
    caml_make_free_blocks (eax, eax, 1);
    *(obj.caml_gc_phase) = 2;
    *(obj.gray_vals_size) = 0x800;
    eax = malloc (0x2000);
    *(obj.gray_vals) = eax;
    if (eax == 0) {
        eax = caml_fatal_error ("Fatal error: not enough memory for the gray cache.\n");
    }
    *(obj.gray_vals_cur) = eax;
    edx = gray_vals_size;
    eax = eax + edx*4;
    *(obj.gray_vals_end) = eax;
    *(obj.heap_is_pure) = 1;
    *(obj.caml_allocated_words) = 0;
    *(fp_stack--) = 0.0;
    *(obj.caml_extra_heap_resources) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80574b0 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_1227 (void) {
    int32_t var_4h;
    int32_t var_4h_2;
    edx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.camlHashtbl__mem_in_bucket_1230;
            *((eax + 4)) = 3;
            esi = *((ecx + 0xc));
            *((eax + 8)) = esi;
            *((eax + 0xc)) = ebx;
            esi = *((edx + 4));
            esi = *((esi - 4));
            esi >>= 0xa;
            if (esi != 0) {
                eax = *((ecx + 0x10));
                eax = *((eax + 8));
                edx = *((eax + 4));
                ecx = *(edx);
                eax = ebx;
                ebx = edx;
                eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (edx, eax, esi);
                ebx = 0x7fffffff;
                eax &= ebx;
                eax >>= 1;
                ecx = *((esp + 8));
                edx:eax = (int64_t) eax;
                eax = edx:eax / ecx;
                edx = edx:eax % ecx;
            } else {
                eax = caml_bucket_Division_by_zero;
                caml_raise_exn ();
            }
            edx <<= 1;
            edx++;
            eax = *(esp);
            ebx = *((eax + 4));
            eax = *((ebx - 4));
            eax >>= 9;
            if (eax <= edx) {
                goto label_0;
            }
            eax = *((ebx + edx*2 - 2));
            ebx = *((esp + 4));
            void (*0x8056890)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fafe */
#include <stdint.h>
 
void caml_init_custom_operations (void) {
    caml_register_custom_operations (obj.caml_int32_ops);
    caml_register_custom_operations (obj.caml_nativeint_ops);
    caml_register_custom_operations (obj.caml_int64_ops);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052b70 */
#include <stdint.h>
 
int32_t camlArray_of_list_1130 (void) {
    int32_t var_4h;
    ebx = eax;
    if (ebx == 1) {
        goto label_0;
    }
    eax = *((ebx + 4));
    eax = *(ebx);
    eax = 1;
    eax = camlArray_list_length_1126 (eax, eax);
    ebx = *(esp);
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8050c00;
            *((ecx + 0xc)) = ebx;
            eax = 3;
            ebx = *((esp + 4));
            void (*0x8050c00)() ();
label_0:
            eax = loc.camlArray__22;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c300 */
#include <stdint.h>
 
int32_t camlPrintf_get_cont_1408 (void) {
    int32_t var_4h;
    eax = ebx;
    ecx = *((eax + 4));
    ebx = 1;
    eax = *(eax);
    camlString_sub_1046 (eax, eax);
    ebx = *(esp);
    *((ebx + 4)) = 1;
    ebx = *((esp + 4));
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b310 */
#include <stdint.h>
 
int32_t caml_curry3_1 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry3_2;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80672ea */
#include <stdint.h>
 
uint32_t caml_format_float (void) {
    char * * format;
    int32_t base;
    int32_t var_4h_5;
    int32_t var_8h_5;
    edi = *((ebp + 8));
    ebx = *((ebp + 8));
    eax = *(edi);
    if (al == 0) {
        goto label_0;
    }
    eax -= 0x30;
    if (al > 9) {
        goto label_1;
    }
    while (al != 0) {
        eax -= 0x30;
        if (al <= 9) {
            strtol (ebx, 0, 0xa);
            esi = eax + 0x15e;
            eax = 0x15e;
            if (esi < 0x15e) {
                esi = eax;
            }
            eax = *(ebx);
            if (al == 0) {
                goto label_2;
            }
            if (al != 0x2e) {
                goto label_3;
            }
            goto label_4;
        }
label_1:
        ebx++;
        eax = *(ebx);
    }
    goto label_0;
    do {
        if (al == 0x2e) {
label_4:
            ebx++;
            eax = strtol (ebx, 0, 0xa);
            eax += 0x15e;
            if (esi < eax) {
                esi = eax;
            }
        } else {
label_3:
            ebx++;
            eax = *(ebx);
        }
    } while (al != 0);
label_2:
    if (esi <= 0x171) {
        goto label_0;
    }
    eax = caml_stat_alloc (esi);
    esi = eax;
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    sprintf (esi, edi);
    eax = caml_copy_string (esi);
    ebx = eax;
    eax = ebp - 0x18a;
    if (esi == eax) {
        goto label_5;
    }
    caml_stat_free (esi);
    do {
label_5:
        eax = ebx;
        return eax;
label_0:
        eax = *((ebp + 0xc));
        *(fp_stack--) = *(eax);
        *((esp + 8)) = fp_stack[0];
        fp_stack--;
        ebx = ebp - 0x18a;
        sprintf (ebx, edi);
        eax = caml_copy_string (ebx);
        ebx = eax;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059090 */
#include <stdint.h>
 
int32_t camlPrintf_sub_1128 (void) {
    do {
        ecx = *((ebx + 0x20));
        if (eax >= ecx) {
            edx = *((ebx + 0x14));
            eax = *((ebx + 0x1c));
            ecx = *(edx);
            ebx = edx;
            eax = void (*ecx)() ();
        }
        edx = *((ebx + 0x1c));
        ecx = eax;
        ecx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ecx) {
            goto label_0;
        }
        ecx = *((edx + ecx));
        ecx = ecx + ecx + 1;
        if (ecx == 0x4b) {
            goto label_1;
        }
        eax += 2;
    } while (1);
label_1:
    ebx += 0xc;
    eax += 2;
    void (*0x8058fb0)() ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80688e1 */
#include <stdint.h>
 
uint32_t caml_ml_seek_in (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    eax >>= 1;
    edx = eax;
    edx >>= 0x1f;
    caml_seek_in (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055490 */
#include <stdint.h>
 
int32_t camlChar_escaped_1038 (void) {
    if (eax != 0x4f) {
        if (eax != 0xb9) {
            *(esp) = eax;
            if (eax >= 0x1d) {
                goto label_0;
            }
            ebx = eax;
            ebx >>= 1;
            /* switch table (16 cases) at 0x8079144 */
            eax = loc.camlChar__8;
            return eax;
            eax = loc.camlChar__9;
            return eax;
            eax = loc.camlChar__10;
            return eax;
            eax = loc.camlChar__11;
            return eax;
        }
        eax = loc.camlChar__7;
        return eax;
    }
    eax = loc.camlChar__6;
    return eax;
label_0:
    eax = caml_is_printable;
    eax = caml_c_call (eax);
    if (eax != 1) {
        eax = caml_create_string;
        caml_c_call (3);
        edx = *(esp);
        edx >>= 1;
        *(eax) = dl;
        return eax;
    }
    eax = *(esp);
    *(esp) = eax;
    eax = caml_create_string;
    eax = caml_c_call (9);
    ebx = eax;
    edx = 0x5c;
    *(ebx) = dl;
    ecx = 0x64;
    edi = *(esp);
    eax = *(esp);
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    edx = eax + eax + 0x61;
    edx >>= 1;
    *((ebx + 1)) = dl;
    esi = 0xa;
    ecx = 0xa;
    eax = edi;
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    ecx = esi;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    edx = edx + edx + 0x61;
    edx >>= 1;
    *((ebx + 2)) = dl;
    ecx = 0xa;
    eax = edi;
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    edx = edx + edx + 0x61;
    edx >>= 1;
    *((ebx + 3)) = dl;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052690 */
#include <stdint.h>
 
uint32_t camlArray_iter_1101 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ecx = 1;
    edx = *((ebx - 4));
    esi = *((ebx - 4));
    esi &= 0xff;
    if (esi != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    edx += 0xfffffffe;
    if (ecx > edx) {
        goto label_1;
    }
    *((esp + 0xc)) = edx;
    *((esp + 8)) = ecx;
    *(esp) = ebx;
    *((esp + 4)) = eax;
    do {
        ebx = *(esp);
        eax = *((ebx - 4));
        if (eax != 0xfe) {
            eax = *((ebx + ecx*2 - 2));
        } else {
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_2;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ebx = *((esp + 4));
        ecx = *(ebx);
        void (*ecx)() ();
        ecx = *((esp + 8));
        ebx = *((esp + 8));
        ecx += 2;
        *((esp + 8)) = ecx;
        eax = *((esp + 0xc));
    } while (ebx != eax);
label_1:
    eax = 1;
    return eax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054f30 */
#include <stdint.h>
 
int32_t camlList_split_1220 (void) {
    int32_t var_4h;
    do {
        if (eax == 1) {
            goto label_0;
        }
        edx = *((eax + 4));
        ecx = *(eax);
        ebx = *((ecx + 4));
        ebx = *(ecx);
        eax = edx;
        eax = camlList_split_1220 (ebx, ebx);
    } while (1);
    ebx = *((eax + 4));
    edx = *(eax);
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x800;
            eax = *(esp);
            *(ecx) = eax;
            *((ecx + 4)) = ebx;
            ebx = ecx + 0xc;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 4));
            *(ebx) = eax;
            *((ebx + 4)) = edx;
            eax = ecx + 0x18;
            *((eax - 4)) = 0x800;
            *(eax) = ebx;
            *((eax + 4)) = ecx;
            return eax;
label_0:
            eax = loc.camlList__41;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80706a0 */
#include <stdint.h>
 
int32_t divdi3 (int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, int32_t arg_4h) {
    int32_t var_20h;
    uint32_t var_1ch;
    uint32_t var_18h;
    int32_t var_14h;
    uint32_t var_10h;
    int32_t var_ch;
    ecx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    edi = *((ebp + 0x14));
    edx = *((ebp + 8));
    *((ebp - 0x10)) = esi;
    *((ebp - 0xc)) = edi;
    *((ebp - 0x14)) = 0;
    if (ecx < 0) {
        goto label_3;
    }
    esi = *((ebp - 0xc));
    if (esi < 0) {
        goto label_4;
    }
label_2:
    eax = *((ebp - 0xc));
    edi = ecx;
    esi = *((ebp - 0x10));
    *((ebp - 0x10)) = edx;
    if (eax == 0) {
        if (esi <= ecx) {
            goto label_5;
        }
        ecx = edx;
        edx = edi;
        eax = ecx;
        edi = 0;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
    } else {
        if (eax <= ecx) {
            goto label_6;
        }
label_0:
        edi = 0;
        ecx = 0;
    }
    do {
label_1:
        eax = ecx;
        ecx = *((ebp - 0x14));
        edx = edi;
        if (ecx != 0) {
            eax = -eax;
            edx += 0;
            edx = -edx;
        }
        return eax;
label_5:
        if (esi == 0) {
            eax = 1;
            edx = 0;
            eax = edx:eax / esi;
            edx = edx:eax % esi;
            esi = eax;
        }
        ecx = *((ebp - 0x10));
        eax = edi;
        edx = 0;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        edi = eax;
        eax = ecx;
        eax = edx:eax / esi;
        edx = edx:eax % esi;
        ecx = eax;
    } while (1);
label_6:
    __asm ("bsr edx, eax");
    edx ^= 0x1f;
    *((ebp - 0x18)) = edx;
    if (esi != 0) {
        goto label_7;
    }
    if (esi <= *((ebp - 0x10))) {
        goto label_8;
    }
    if (eax >= ecx) {
        goto label_0;
    }
label_8:
    edi = 0;
    ecx = 1;
    goto label_1;
label_3:
    esi = *((ebp - 0xc));
    edx = -edx;
    ecx += 0;
    ecx = -ecx;
    *((ebp - 0x14)) = 0xffffffff;
    if (esi >= 0) {
        goto label_2;
    }
label_4:
    ebp - 0x10 = -ebp - 0x10;
    *((ebp - 0xc)) += 0;
    ebp - 0x14 = ~ebp - 0x14;
    ebp - 0xc = -ebp - 0xc;
    goto label_2;
label_7:
    ecx = *((ebp - 0x18));
    edx = esi;
    eax <<= cl;
    *((ebp - 0x1c)) = eax;
    eax = 0x20;
    eax -= *((ebp - 0x18));
    ecx = eax;
    edx >>= cl;
    ecx = *((ebp - 0x18));
    edx |= *((ebp - 0x1c));
    esi <<= cl;
    ecx = eax;
    *((ebp - 0x20)) = esi;
    esi = edi;
    esi >>= cl;
    ecx = *((ebp - 0x18));
    *((ebp - 0x1c)) = edx;
    edx = *((ebp - 0x10));
    edi <<= cl;
    ecx = eax;
    edx >>= cl;
    edi |= edx;
    edx = esi;
    eax = edi;
    eax = *(edx:eax) / ebp - 0x1c;
    edx = *(edx:eax) % ebp - 0x1c;
    esi = edx;
    edi = eax;
    edx:eax = eax * *((ebp - 0x20));
    *((ebp - 0x1c)) = edx;
    if (esi >= edx) {
        edx = *((ebp - 0x10));
        ecx = *((ebp - 0x18));
        edx <<= cl;
        if (edx < eax) {
            if (esi == *((ebp - 0x1c))) {
                goto label_9;
            }
        }
        ecx = edi;
        edi = 0;
        goto label_1;
    }
label_9:
    ecx = edi - 1;
    edi = 0;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806f5d5 */
#include <stdint.h>
 
int32_t caml_final_do_young_roots (int32_t arg_8h) {
    int32_t var_4h;
    edi = *((ebp + 8));
    esi = old;
    if (esi >= *(obj.young)) {
        goto label_0;
    }
    ebx = esi * 3;
    ebx <<= 2;
    do {
        eax = ebx;
        eax += *(obj.final_table);
        eax = *(eax);
        void (*edi)(uint32_t, uint32_t) (eax, eax);
        eax = ebx;
        eax += *(obj.final_table);
        edx = eax + 4;
        eax = *((eax + 4));
        void (*edi)(uint32_t, uint32_t) (eax, edx);
        esi++;
        ebx += 0xc;
    } while (*(obj.young) > esi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80678e2 */
#include <stdint.h>
 
int32_t caml_abs_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    fp_stack[0] = abs(fp_stack[0]);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a9f6 */
#include <stdint.h>
 
uint32_t caml_marshal_data_size (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 0xc));
    edx >>= 1;
    edx += *((ebp + 8));
    *(obj.intern_input_malloced) = 0;
    eax = edx + 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *(edx);
    edx <<= 0x18;
    edx = ecx + edx;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    edx += ecx;
    ecx = *((eax - 2));
    ecx <<= 8;
    edx += ecx;
    if (edx != 0x8495a6be) {
        eax = caml_failwith (0x8071868);
    }
    eax += 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 4));
    ecx <<= 0x18;
    edx = *((eax - 1));
    ecx += edx;
    edx = *((eax - 3));
    edx <<= 0x10;
    ecx += edx;
    edx = *((eax - 2));
    edx <<= 8;
    eax = ecx + edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804e040 */
#include <stdint.h>
 
int32_t camlUnix_close_process_2009 (int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edx = ebx;
    *((esp + 8)) = edx;
    ecx = eax;
    *(esp) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            *((ebx + 4)) = edx;
            eax = "close_process";
            eax = camlUnix_find_proc_id_1997 ();
            *((esp + 4)) = eax;
            eax = *(esp);
            eax = caml_ml_close_channel;
            caml_c_call (eax);
            eax = void (*0x804e0b0)() ();
            ecx = loc.caml_exn_Sys_error;
            ebx = *(eax);
            if (ebx != ecx) {
                caml_raise_exn ();
                *(obj.caml_exception_pointer) = esp;
                eax = *((esp + 0x10));
                camlPervasives_close_out_1209 (*(obj.caml_exception_pointer));
            }
            eax = *((esp + 4));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069c23 */
#include <stdint.h>
 
int32_t caml_serialize_int_2 (int32_t arg_8h) {
    ebx = *((ebp + 8));
    eax = extern_ptr;
    eax += 2;
    if (*(obj.extern_limit) < eax) {
        eax = 2;
        grow_extern_output ();
    }
    eax = extern_ptr;
    edx = ebx;
    edx >>= 8;
    *(eax) = dl;
    *((eax + 1)) = bl;
    eax += 2;
    *(obj.extern_ptr) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8055060 */
#include <stdint.h>
 
int32_t camlList_merge_1233 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    do {
label_0:
        if (ebx == 1) {
            goto label_2;
        }
        if (ecx == 1) {
            goto label_3;
        }
        edx = *((ecx + 4));
        edx = *(ecx);
        ecx = *((ebx + 4));
        eax = *(ebx);
        ebx = edx;
        ecx = *((esp + 0xc));
        eax = caml_apply2 (ecx, edx, edx);
        if (eax > 1) {
            goto label_4;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 0x10));
        ecx = *((esp + 0x14));
        eax = camlList_merge_1233 ();
    } while (1);
    ecx = eax;
label_1:
    eax = caml_young_ptr;
    eax -= 0xc;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    ebx = eax + 4;
    *((ebx - 4)) = 0x800;
    eax = *((esp + 0x18));
    *(ebx) = eax;
    *((ebx + 4)) = ecx;
    eax = ebx;
    return eax;
label_4:
    eax = *((esp + 0xc));
    ebx = *(esp);
    ecx = *((esp + 4));
    eax = camlList_merge_1233 ();
    goto label_0;
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            eax = *((esp + 8));
            *(ebx) = eax;
            *((ebx + 4)) = ecx;
            eax = ebx;
            return eax;
label_3:
            eax = ebx;
            return eax;
label_2:
            eax = ecx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ac80 */
#include <stdint.h>
 
int32_t caml_curry9_8 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    int32_t var_20h;
    int32_t var_24h;
    int32_t var_28h;
    *((esp + 0x24)) = eax;
    *(esp) = ebx;
    eax = *((ebx + 0xc));
    *((esp + 4)) = eax;
    eax = *((eax + 0xc));
    *((esp + 8)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0xc)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x10)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x14)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x18)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x1c)) = eax;
    eax = *((eax + 0xc));
    *((esp + 0x28)) = eax;
    eax = *(esp);
    eax = *((eax + 8));
    *((esp + 0x20)) = eax;
    eax = *((esp + 4));
    eax = *((eax + 8));
    *((esp + 4)) = eax;
    eax = *((esp + 8));
    eax = *((eax + 8));
    *(esp) = eax;
    eax = *((esp + 0xc));
    esi = *((eax + 8));
    eax = *((esp + 0x10));
    edx = *((eax + 8));
    eax = *((esp + 0x14));
    ecx = *((eax + 8));
    eax = *((esp + 0x18));
    ebx = *((eax + 8));
    eax = *((esp + 0x1c));
    eax = *((eax + 8));
    edi = *((esp + 0x28));
    edi = *((edi + 8));
    *((esp + 8)) = edi;
    edi = *(esp);
    ebp = *((esp + 4));
    *(loc.caml_extra_params) = ebp;
    ebp = *((esp + 0x20));
    *(0x807cb20) = ebp;
    ebp = *((esp + 0x24));
    *(0x807cb24) = ebp;
    ebp = *((esp + 0x28));
    *(0x807cb28) = ebp;
    ebp = *((esp + 8));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80678ae */
#include <stdint.h>
 
int32_t caml_sub_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    fp_stack[0] -= *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d330 */
#include <stdint.h>
 
uint32_t camlUnix_getnameinfo_1781 (void) {
    int32_t var_4h;
    eax = void (*0x804d370)(uint32_t, uint32_t) (eax, ebx);
    ecx = "P5\a\b";
    ebx = *(eax);
    if (ebx == ecx) {
        eax = *(esp);
        ebx = *((esp + 4));
        void (*0x804d0b0)() ();
    }
    eax = caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    eax = unix_getnameinfo;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b2b0 */
#include <stdint.h>
 
int32_t caml_curry4_3 (void) {
    edx = eax;
    edi = *((ebx + 0xc));
    eax = *((edi + 0xc));
    esi = *((eax + 0xc));
    ecx = *((ebx + 8));
    ebx = *((edi + 8));
    eax = *((eax + 8));
    edi = *((esi + 8));
    return void (*edi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806676c */
#include <stdint.h>
 
int32_t caml_int32_to_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *((eax + 4));
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069b20 */
#include <stdint.h>
 
uint32_t caml_serialize_block_2 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_2ch;
    int32_t var_1ch;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    eax = edi + edi;
    edx = eax;
    edx += *(obj.extern_ptr);
    if (*(obj.extern_limit) < edx) {
        grow_extern_output ();
    }
    ecx = extern_ptr;
    if (edi <= 0) {
        goto label_0;
    }
    eax = 0;
    *((ebp - 0x2c)) = edi;
    *((ebp - 0x1c)) = edi;
    do {
        esi = *((ebx + eax));
        edi = *((ebx + eax + 1));
        edx = edi;
        *((ecx + eax)) = dl;
        edx = esi;
        *((ecx + eax + 1)) = dl;
        eax += 2;
        *((ebp - 0x2c))--;
    } while (*((ebp - 0x2c)) != 0);
    edi = *((ebp - 0x1c));
    ecx = ecx + edi*2;
label_0:
    *(obj.extern_ptr) = ecx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068796 */
#include <stdint.h>
 
int32_t caml_seek_in (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    uint32_t var_30h;
    int32_t var_2ch;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    eax = *((ebx + 4));
    edx = *((ebx + 8));
    *((ebp - 0x30)) = eax;
    *((ebp - 0x2c)) = edx;
    edx = *((ebx + 0x14));
    *((ebp - 0x24)) = edx;
    eax = ebx + 0x34;
    edx -= eax;
    *((ebp - 0x20)) = edx;
    ecx = edx;
    ecx >>= 0x1f;
    *((ebp - 0x1c)) = ecx;
    eax = *((ebp - 0x30));
    edx = *((ebp - 0x2c));
    eax -= *((ebp - 0x20));
    edx -= *((ebp - 0x1c));
    *((ebp - 0x20)) = eax;
    *((ebp - 0x1c)) = edx;
    if (edx <= esi) {
        if (*((ebp - 0x1c)) >= esi) {
            if (eax > edi) {
                goto label_0;
            }
        }
        if (*((ebp - 0x2c)) >= esi) {
            if (*((ebp - 0x2c)) <= esi) {
                if (*((ebp - 0x30)) < edi) {
                    goto label_0;
                }
            }
            eax = edi;
            eax -= *((ebp - 0x30));
            eax += *((ebp - 0x24));
            *((ebx + 0x10)) = eax;
        }
    } else {
label_0:
        caml_enter_blocking_section ();
        *((esp + 0xc)) = 0;
        *((esp + 4)) = edi;
        *((esp + 8)) = esi;
        eax = *(ebx);
        *(esp) = eax;
        eax = lseek64 ();
        edx ^= esi;
        eax ^= edi;
        edx |= eax;
        if (edx != 0) {
            caml_leave_blocking_section ();
            caml_sys_error (1);
        }
        caml_leave_blocking_section ();
        *((ebx + 4)) = edi;
        *((ebx + 8)) = esi;
        eax = ebx + 0x34;
        *((ebx + 0x14)) = eax;
        *((ebx + 0x10)) = eax;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806105d */
#include <stdint.h>
 
int32_t unix_truncate (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x12196;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    edx = eax;
    edx >>= 0x1f;
    *((esp + 8)) = edx;
    *(esp) = esi;
    eax = truncate64 ();
    if (eax == -1) {
        eax = ebx - 0x255a;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ff4f */
#include <stdint.h>
 
int32_t caml_search_dll_in_path (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * src;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = 0xffffffff;
    edi = *((ebp + 0xc));
    ecx = esi;
    eax = 0;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ecx += 3;
    eax = caml_stat_alloc (ecx);
    ebx = eax;
    ecx = *((ebp + 0xc));
    strcpy (eax, ecx);
    edi = ebx;
    ecx = esi;
    eax = 0;
    __asm ("repne scasb al, byte es:[edi]");
    esi = ecx;
    esi = ~esi;
    *((ebx + esi - 1)) = 0x6f732e;
    eax = *((ebp + 8));
    eax = caml_search_in_path (eax, ebx);
    esi = eax;
    caml_stat_free (ebx);
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bfc0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2622 (void) {
    eax = unix_initgroups;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c904 */
#include <stdint.h>
 
uint32_t unix_bind (int32_t socket, int32_t arg_ch) {
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_8h;
    int32_t var_4h;
    struct sockaddr* address;
    socklen_t address_len;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x168ec;
    eax = ebp - 0x7c;
    esi = ebp - 0x78;
    eax = *((ebp + 0xc));
    get_sockaddr (eax, esi, eax);
    eax = *((ebp - 0x7c));
    eax = *((ebp + 8));
    eax >>= 1;
    eax = bind (eax, esi, eax);
    if (eax == -1) {
        eax = ebx - 0x25f6;
        uerror (eax, 0);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a4c4 */
#include <stdint.h>
 
void bind (void) {
    bind ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804cab0 */
#include <stdint.h>
 
int32_t camlUnix_setsockopt_1646 (void) {
    eax = unix_setsockopt;
    caml_c_call (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805cf0c */
#include <stdint.h>
 
uint32_t unix_clear_close_on_exec (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x162e7;
    esi = *((ebp + 8));
    esi >>= 1;
    *((esp + 8)) = 0;
    *((esp + 4)) = 1;
    *(esp) = esi;
    eax = fcntl ();
    if (eax != -1) {
        eax &= 0xfffffffe;
        *((esp + 8)) = eax;
        *((esp + 4)) = 2;
        *(esp) = esi;
        eax = fcntl ();
        if (eax != -1) {
            goto label_0;
        }
    }
    eax = ebx - 0x25a2;
    uerror (eax, 0);
label_0:
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80685d8 */
#include <stdint.h>
 
int32_t caml_ml_close_channel (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    ebx = *(eax);
    if (ebx == -1) {
        goto label_0;
    }
    *(eax) = 0xffffffff;
    edx = *((eax + 0xc));
    *((eax + 0x14)) = edx;
    *((eax + 0x10)) = edx;
    caml_enter_blocking_section ();
    eax = close (ebx);
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx != -1) {
        goto label_1;
    }
    caml_sys_error (1);
    do {
label_1:
        eax = 1;
        return eax;
label_0:
        edx = *((eax + 0xc));
        *((eax + 0x14)) = edx;
        *((eax + 0x10)) = edx;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fbd4 */
#include <stdint.h>
 
uint32_t unix_sigpending (void) {
    int32_t var_88h;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13621;
    eax = ebp - 0x88;
    *(esp) = eax;
    eax = sigpending ();
    if (eax == -1) {
        eax = ebx - 0x23f1;
        uerror (eax, 0);
    }
    eax = ebp - 0x88;
    encode_sigset ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a4f4 */
#include <stdint.h>
 
void sigpending (void) {
    sigpending ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056d10 */
#include <stdint.h>
 
uint32_t camlHashtbl_safehash_1177 (void) {
    ebx = *((ebx + 8));
    ebx = *((ebx + 4));
    ecx = *(ebx);
    eax = void (*ecx)() ();
    ebx = 0x7fffffff;
    eax &= ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b000 */
#include <stdint.h>
 
int32_t caml_curry6_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry6_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066cec */
#include <stdint.h>
 
int32_t caml_int64_or (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    ecx = *((edx + 4));
    ecx |= *((eax + 4));
    edx = *((edx + 8));
    edx |= *((eax + 8));
    caml_copy_int64 (ecx, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d698 */
#include <stdint.h>
 
uint32_t unix_getegid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15b60;
    getegid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a484 */
#include <stdint.h>
 
void getegid (void) {
    getegid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8064c95 */
#include <stdint.h>
 
int32_t caml_free_dependent_memory (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 2;
    edx = caml_dependent_size;
    if (eax > edx) {
        *(obj.caml_dependent_size) = 0;
    } else {
        edx -= eax;
        *(obj.caml_dependent_size) = edx;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054570 */
#include <stdint.h>
 
void camlList_rev_1056 (void) {
    ebx = 1;
    return camlList_rev_append_1051 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058b60 */
#include <stdint.h>
 
void camlBuffer_output_buffer_1094 (void) {
    edx = *((ebx + 4));
    ecx = 1;
    ebx = *(ebx);
    return camlPervasives_output_1194 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059510 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1686 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x807041c */
#include <stdint.h>
 
void caml_debugger_init (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058e20 */
#include <stdint.h>
 
int32_t camlBuffer_add_substitute_1122 (void) {
    esi = eax;
    edx = ecx;
    eax = *((edx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((edx + eax));
    eax -= ecx;
    edi = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x20;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x1cf7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x80584e0;
            *((ecx + 0xc)) = esi;
            *((ecx + 0x10)) = ebx;
            *((ecx + 0x14)) = edx;
            *((ecx + 0x18)) = edi;
            ebx = 1;
            eax = 0x41;
            void (*0x80584e0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c330 */
#include <stdint.h>
 
int32_t camlUnix_fun_2722 (void) {
    eax = unix_chmod;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ad50 */
#include <stdint.h>
 
int32_t caml_curry7 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry7_1;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80521d0 */
#include <stdint.h>
 
void camlArray_concat_1075 (void) {
    ebx = loc.camlArray__29;
    return camlArray_find_init_1077 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bfe0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2626 (void) {
    eax = unix_getgroups;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c6f0 */
#include <stdint.h>
 
int32_t camlUnix_write_1242 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = unix_write;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "Unix.write";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c6fc */
#include <stdint.h>
 
uint32_t unix_accept (int32_t arg_8h) {
    int32_t var_b0h;
    int32_t var_ach;
    int32_t var_a8h;
    int32_t var_a4h;
    int32_t var_90h;
    int32_t var_8ch;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x16af7;
    *((ebp - 0x90)) = 0x70;
    caml_enter_blocking_section ();
    eax = ebp - 0x90;
    eax = ebp - 0x8c;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = accept (eax, eax, eax);
    edi = eax;
    caml_leave_blocking_section ();
    if (edi == -1) {
        eax = ebx - 0x2618;
        uerror (eax, 0);
    }
    eax = *((ebp - 0x90));
    eax = ebp - 0x8c;
    eax = alloc_sockaddr (eax, eax, edi);
    *((ebp - 0x1c)) = eax;
    esi = *((ebx - 0x18));
    eax = *(esi);
    *((ebp - 0xb0)) = eax;
    eax = ebp - 0xb0;
    *(esi) = eax;
    *((ebp - 0xa8)) = 1;
    *((ebp - 0xac)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0xa4)) = eax;
    caml_alloc_small (2, 0);
    edx = edi + edi + 1;
    *(eax) = edx;
    edx = *((ebp - 0x1c));
    *((eax + 4)) = edx;
    edx = *((ebp - 0xb0));
    *(esi) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a284 */
#include <stdint.h>
 
void accept (void) {
    accept ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806f635 */
#include <stdint.h>
 
int32_t caml_final_empty_young (void) {
    eax = young;
    *(obj.old) = eax;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059d40 */
#include <stdint.h>
 
int32_t camlPrintf_loop_1240 (void) {
    int32_t var_4h;
    int32_t var_8h;
    edx = eax;
    eax = *((ecx + 0x14));
    if (edx < eax) {
        goto label_1;
    }
    *((esp + 4)) = ecx;
    *(esp) = ebx;
    eax = caml_make_vect;
    eax = caml_c_call (*((ecx + 0x14)));
    ecx = eax;
    *((esp + 8)) = ecx;
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_2;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x8059150;
    ebx = *((esp + 4));
    ebx = *((ebx + 0x14));
    *((eax + 0xc)) = ebx;
    *((eax + 0x10)) = ecx;
    ebx = *(esp);
    camlPrintf_list_iter_i_1201 ();
    eax = *((esp + 4));
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    ebx = *((esp + 8));
    void (*0x804b540)() ();
    do {
label_1:
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.camlPrintf__fun_1568;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80555c0 */
#include <stdint.h>
 
int32_t camlChar_lowercase_1043 (void) {
    if (eax >= 0x83) {
        if (eax <= 0xb5) {
            goto label_0;
        }
    }
    if (eax >= 0x181) {
        if (eax <= 0x1ad) {
            goto label_0;
        }
    }
    if (eax >= 0x1b1) {
        if (eax <= 0x1bd) {
            goto label_0;
        }
    }
    return;
label_0:
    eax += 0x40;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80610e4 */
#include <stdint.h>
 
int32_t unix_error_of_code (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_ch;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x1210f;
    esi = *((ebp + 8));
    eax = *((ebx - 8));
    eax = cst_to_constr (0xffffffff, eax, 0x44);
    edx = eax;
    if (eax == -1) {
        eax = caml_alloc_small (1, 0);
        edx = eax;
        eax = esi + esi + 1;
        *(edx) = eax;
    }
    eax = edx;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061760 */
#include <stdint.h>
 
int32_t cst_to_constr (int32_t arg_8h, char * arg_ch, size_t arg_10h, int32_t arg_14h) {
    ecx = *((ebp + 8));
    esi = *((ebp + 0xc));
    edx = *((ebp + 0x10));
    if (edx <= 0) {
        goto label_0;
    }
    eax = 0;
    if (*(esi) != ecx) {
        goto label_1;
    }
    while (edx > eax) {
        if (*((esi + eax*4)) == ecx) {
            eax = eax + eax + 1;
            goto label_2;
        }
label_1:
        eax++;
    }
label_0:
    eax = *((ebp + 0x14));
    eax = eax + eax + 1;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80629c9 */
#include <stdint.h>
 
int32_t caml_remove_global_root (int32_t arg_8h) {
    edx = *((ebp + 8));
    eax = caml_global_roots;
    caml_delete_global_root ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068861 */
#include <stdint.h>
 
uint32_t caml_ml_seek_in_64 (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_4h;
    int32_t var_8h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 2;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    eax = ebp + 0xc;
    *((ebp - 0x18)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    caml_seek_in (ebx, eax, edx);
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058810 */
#include <stdint.h>
 
int32_t camlBuffer_clear_1062 (void) {
    *((eax + 4)) = 1;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b990 */
#include <stdint.h>
 
uint32_t camlPrintf_summarize_format_type_1162 (void) {
    int32_t var_4h;
    ecx = eax;
    ebx = *((ecx - 4));
    ebx >>= 0xa;
    eax = ebx*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    eax = eax + eax + 1;
    eax = camlBuffer_create_1039 (ecx);
    edx = eax;
    *((esp + 4)) = edx;
    do {
        eax = caml_young_ptr;
        eax -= 0x2c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8059bc0;
            *((ecx + 0xc)) = edx;
            ebx = ecx + 0x14;
            *((ebx - 4)) = 0x14f7;
            *(ebx) = sym.caml_curry3;
            *((ebx + 4)) = 7;
            *((ebx + 8)) = 0x8059be0;
            *((ebx + 0xc)) = edx;
            *((ebx + 0x10)) = ecx;
            eax = *(esp);
            camlPrintf_iter_on_format_args_1137 ();
            eax = *((esp + 4));
            ecx = *((eax + 4));
            ebx = 1;
            eax = *(eax);
            void (*0x8055800)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056770 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_bucket_1221 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
        if (eax == 1) {
            goto label_2;
        }
        ecx = *((eax + 8));
        ecx = *((eax + 4));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0xc));
        eax = caml_apply2 (ecx, eax, ebx);
        if (eax != 1) {
label_1:
            eax = caml_young_ptr;
            eax -= 0x10;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0xc00;
            ebx = *((esp + 4));
            *(eax) = ebx;
            ebx = *((esp + 8));
            ebx = *((ebx + 0x10));
            *((eax + 4)) = ebx;
            ebx = *((esp + 0xc));
            *((eax + 8)) = ebx;
            return eax;
        }
        eax = *((esp + 0xc));
        ebx = *((esp + 8));
        eax = camlHashtbl_replace_bucket_1221 ();
    } while (1);
    ecx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x10;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_4;
    }
    eax = eax + 4;
    *((eax - 4)) = 0xc00;
    ebx = *((esp + 4));
    *(eax) = ebx;
    ebx = *(esp);
    *((eax + 4)) = ebx;
    *((eax + 8)) = ecx;
    return eax;
    do {
label_2:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805fed3 */
#include <stdint.h>
 
int32_t alloc_inet_addr (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13325;
    caml_alloc_string (4);
    edx = *((ebp + 8));
    edx = *(edx);
    *(eax) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8068252 */
#include <stdint.h>
 
int32_t caml_array_set_addr (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    eax >>= 1;
    if (eax >= 0) {
        edx = *((ebp + 8));
        ecx = *((edx - 4));
        ecx >>= 0xa;
        if (eax < ecx) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    ebx = edx + eax*4;
    edi = *(ebx);
    *(ebx) = esi;
    edx = ebx;
    edx >>= 0x17;
    eax = ebx;
    eax >>= 0xc;
    eax &= 0x7ff;
    edx = *((edx*4 + obj.caml_page_table));
    if ((*((edx + eax)) & 1) != 0) {
        if (*(obj.caml_gc_phase) == 0) {
            caml_darken (edi, 0);
        }
        if ((esi & 1) != 0) {
            goto label_1;
        }
        eax = caml_young_end;
        if (esi >= eax) {
            goto label_1;
        }
        edx = caml_young_start;
        if (esi <= edx) {
            goto label_1;
        }
        if ((edi & 1) == 0) {
            if (eax <= edi) {
                goto label_2;
            }
            if (edx < edi) {
                goto label_1;
            }
        }
label_2:
        eax = .comment;
        if (eax >= *(0x807fe8c)) {
            caml_realloc_ref_table (obj.caml_ref_table);
        }
        eax = 0x807fe88;
        edx = *(eax);
        *(edx) = ebx;
        edx += 4;
        *(eax) = edx;
    }
label_1:
    eax = 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805bec0 */
#include <stdint.h>
 
int32_t camlPrintf_get_index_1265 (void) {
    if (eax != 1) {
        eax = *(eax);
        return eax;
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066dad */
#include <stdint.h>
 
int32_t caml_int64_div (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    eax = *((ebp + 8));
    edx = *((ebp + 0xc));
    esi = *((eax + 4));
    ebx = *((eax + 8));
    ecx = *((edx + 4));
    edx = *((edx + 8));
    edi = *((edx + 8));
    edi |= ecx;
    if (edi == 0) {
        caml_raise_zero_divide ();
    }
    edi = ebx - 0x80000000;
    edi |= esi;
    if (edi == 0) {
        edi = ecx;
        edi &= edx;
        if (edi == -1) {
            goto label_0;
        }
    }
    eax = _divdi3 (edx, ebx, ecx);
    caml_copy_int64 (eax, edx);
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a90e */
#include <stdint.h>
 
uint32_t caml_deserialize_float_4 (void) {
    int32_t var_bp_4h;
    int32_t var_4h;
    eax = ebp - 4;
    caml_deserialize_block_4 (eax, 1);
    *(fp_stack--) = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bd40 */
#include <stdint.h>
 
int32_t camlUnix_fun_2836 (void) {
    esi = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x1c;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x18f7;
            *(eax) = sym.caml_tuplify2;
            *((eax + 4)) = 0xfffffffd;
            *((eax + 8)) = 0x804ba50;
            edx = *((ecx + 0xc));
            *((eax + 0xc)) = edx;
            *((eax + 0x10)) = esi;
            *((eax + 0x14)) = ebx;
            ebx = *((ecx + 0x10));
            void (*0x80545c0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805cb04 */
#include <stdint.h>
 
int32_t unix_closedir (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x166ef;
    esi = *((ebp + 8));
    eax = *(esi);
    if (eax == 0) {
        eax = ebx - 0x25de;
        eax = unix_error (9, eax, 0);
    }
    *(esp) = eax;
    closedir ();
    *(esi) = 0;
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a514 */
#include <stdint.h>
 
void closedir (void) {
    closedir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c350 */
#include <stdint.h>
 
int32_t camlUnix_fun_2726 (void) {
    eax = unix_rename;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80591f0 */
#include <stdint.h>
 
uint32_t camlPrintf_got_spec_1304 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ebx = ecx;
    ecx = *((ebx + 0xc));
    ebx = *((ebx + 0x18));
    eax = camlPrintf_get_arg_1288 (eax, ebx);
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((esp + 8)) = ecx;
            *((ecx - 4)) = 0x800;
            *(ecx) = ebx;
            eax = *((esp + 4));
            ebx = *((eax + 0x1c));
            *((ecx + 4)) = ebx;
            eax = *((eax + 0x18));
            ecx = *(esp);
            if (ecx != 1) {
                ebx = eax;
            } else {
                ebx = *((ecx + 8));
                ecx = *(ebx);
                eax = void (*0x807a850)() ();
                ebx = eax;
            }
            ecx = *((esp + 4));
            esi = *((ecx + 0x10));
            eax = *((ecx + 0x14));
            ecx = *((esp + 8));
            edx = *((esp + 0xc));
            void (*0x805b020)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806e49d */
#include <stdint.h>
 
int32_t caml_callback2 (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    eax = *((ebp + 0x10));
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_callback2_exn (eax, eax, eax);
    edx = eax;
    edx &= 3;
    if (edx == 2) {
        eax &= 0xfffffffc;
        caml_raise (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x807063c */
#include <stdint.h>
 
int32_t loc_caml_callback2_exn (int32_t arg_14h, int32_t arg_18h, int32_t arg_1ch) {
    ecx = *((esp + 0x14));
    eax = *((esp + 0x18));
    ebx = *((esp + 0x1c));
    esi = caml_apply2;
    return void (*0x8070559)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067d6e */
#include <stdint.h>
 
uint32_t caml_string_get (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    ebx >>= 1;
    if (ebx >= 0) {
        eax = caml_string_length (esi);
        if (ebx < eax) {
            goto label_0;
        }
    }
    caml_array_bound_error ();
label_0:
    eax = *((ebx + esi));
    eax = eax + eax + 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806b741 */
#include <stdint.h>
 
uint32_t caml_input_value (int32_t arg_8h) {
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    eax = ebp - 0x28;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    edx = ebp + 8;
    *((ebp - 0x1c)) = edx;
    edx = *((ebp + 8));
    ebx = *((edx + 4));
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    eax = caml_channel_mutex_lock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    eax = caml_input_val (ebx);
    *((ebp - 0x2c)) = eax;
    eax = caml_channel_mutex_unlock;
    if (eax != 0) {
        void (*eax)(uint32_t) (ebx);
    }
    *(obj.caml_local_roots) = esi;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067ce3 */
#include <stdint.h>
 
int32_t caml_string_lessequal (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax < 2) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80670a7 */
#include <stdint.h>
 
int32_t caml_int32_div (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    ecx = *((ebp + 0xc));
    ecx = *((ecx + 4));
    if (ecx == 0) {
        caml_raise_zero_divide ();
    }
    if (edx == 0x80000000) {
        if (ecx == -1) {
            goto label_0;
        }
    }
    eax = edx;
    edx >>= 0x1f;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    caml_copy_int32 (eax);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806b64e */
#include <stdint.h>
 
uint32_t caml_input_val (int32_t arg_8h) {
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    ebx = *((ebp + 8));
    eax = caml_channel_binary_mode (ebx, esi, edi);
    if (eax == 0) {
        caml_failwith ("input_value: not a binary channel");
    }
    eax = caml_getword (ebx);
    if (eax != 0x8495a6be) {
        caml_failwith ("input_value: bad object");
    }
    eax = caml_getword (ebx);
    edi = eax;
    eax = caml_getword (ebx);
    *((ebp - 0x30)) = eax;
    eax = caml_getword (ebx);
    *((ebp - 0x2c)) = eax;
    caml_getword (ebx);
    eax = caml_stat_alloc (edi);
    esi = eax;
    eax = caml_really_getblock (ebx, eax, edi);
    if (eax == 0) {
        caml_stat_free (esi);
        caml_failwith ("input_value: truncated object");
    }
    *(obj.intern_input) = esi;
    *(obj.intern_input_malloced) = 1;
    *(obj.intern_src) = esi;
    edx = *((ebp - 0x30));
    eax = *((ebp - 0x2c));
    intern_alloc ();
    eax = ebp - 0x1c;
    intern_rec ();
    eax = *((ebp - 0x2c));
    intern_add_to_heap ();
    eax = intern_input;
    caml_stat_free (eax);
    eax = intern_obj_table;
    if (eax != 0) {
        caml_stat_free (eax);
    }
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058440 */
#include <stdint.h>
 
int32_t camlBuffer_advance_1111 (void) {
    do {
        if (eax >= ebx) {
            eax = ebx;
            return eax;
        }
        esi = *((ecx + 0xc));
        edx = eax;
        edx >>= 1;
        edi = *((esi - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((esi + ebp));
        ebp -= edi;
        if (ebp <= edx) {
            goto label_0;
        }
        edx = *((esi + edx));
        edx = edx + edx + 1;
        if (edx < 0xbf) {
            if (edx >= 0x75) {
                edx += 0xffffff7e;
                if (edx <= 0x33) {
                    goto label_1;
                }
            } else {
            } else {
            }
        }
        if (edx >= 0x61) {
            goto label_1;
        }
        if (edx >= 0xf7) {
            if (edx < 0x181) {
                goto label_2;
            }
            edx += 0xfffffe80;
            edx >>= 1;
            /* switch table (64 cases) at 0x807a3c0 */
        }
        if (edx != 0xc1) {
            goto label_1;
        }
label_2:
        return eax;
label_1:
        eax += 2;
    } while (1);
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f6c0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1392 (void) {
    eax = caml_ml_set_binary_mode;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806c1c4 */
#include <stdint.h>
 
int32_t caml_parse_engine (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t arg_14h) {
    int32_t var_2ch;
    uint32_t var_28h;
    int32_t var_24h;
    uint32_t var_20h;
    uint32_t var_1ch;
    char * format;
    size_t nitems;
    char ** stream;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = *((ebp + 0x10));
    eax >>= 1;
    if (eax > 5) {
        goto label_1;
    }
    /* switch table (6 cases) at 0x8071b64 */
    edi = *((ebx + 0x34));
    edi >>= 1;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x20)) = 0;
label_0:
    eax = *((esi + 0x14));
    edx = *((ebp - 0x20));
    eax = *((eax + edx*2));
    *((ebp - 0x1c)) = eax;
    if (eax != 0) {
        goto label_2;
    }
    if (*((ebx + 0x18)) < 0) {
        eax = edi + edi + 1;
        *((ebx + 0x34)) = eax;
        eax = edx + edx + 1;
        *((ebx + 0x38)) = eax;
        ecx = *((ebp - 0x24));
        eax = ecx + ecx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 1;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        *((ebp - 0x20)) = eax;
        eax = *((ebx + 0x3c));
        eax >>= 1;
        *((ebp - 0x24)) = eax;
        eax = *((ebp + 0x14));
        eax &= 1;
        *((ebp - 0x28)) = eax;
        if (eax == 0) {
            ecx = *((ebp + 0x14));
            edx = *((ecx - 4));
            eax = *((esi + 8));
            eax = *((eax + edx*4));
            *((ebx + 0x18)) = eax;
            eax = *(ecx);
            eax = ebx + 0x1c;
            caml_modify (eax, eax);
        } else {
            edx = *((ebp + 0x14));
            edx >>= 1;
            eax = *((esi + 4));
            eax = *((eax + edx*4));
            *((ebx + 0x18)) = eax;
            eax = ebx + 0x1c;
            caml_modify (eax, 1);
        }
        if (*(obj.caml_parser_trace) == 0) {
            goto label_4;
        }
        if (*((ebp - 0x28)) != 0) {
            edx = *((ebp + 0x14));
            edx >>= 1;
            eax = *((esi + 0x38));
            eax = token_name ();
            *((esp + 0xc)) = eax;
            eax = *((ebp - 0x20));
            *((esp + 8)) = eax;
            eax = stderr;
            fprintf (eax, "State %d: read token %s\n");
        } else {
            ecx = *((ebp + 0x14));
            edx = *((ecx - 4));
            eax = *((esi + 0x3c));
            eax = token_name ();
            *((esp + 0xc)) = eax;
            eax = *((ebp - 0x20));
            *((esp + 8)) = eax;
            eax = stderr;
            fprintf (eax, "State %d: read token %s(");
            edx = *((ebp + 0x14));
            eax = *(edx);
            if ((al & 1) != 0) {
                eax >>= 1;
                *((esp + 8)) = eax;
                eax = stderr;
                eax = fprintf (eax, 0x8071abb);
            } else {
                edx = *((eax - 4));
                if (dl == 0xfc) {
                    edx = stderr;
                    eax = fputs (eax, edx);
                } else {
                    if (dl == 0xfd) {
                        *(fp_stack--) = *(eax);
                        *((esp + 8)) = fp_stack[0];
                        fp_stack--;
                        eax = stderr;
                        fprintf (eax, 0x8071abf);
                    } else {
                        eax = stderr;
                        fputc (0x5f, eax);
                    }
                }
            }
            eax = stderr;
            fwrite (eax, 1, 2);
        }
    }
label_4:
    ecx = *((ebp - 0x20));
    ecx += ecx;
    *((ebp - 0x28)) = ecx;
    eax = *((esi + 0x1c));
    eax = *((eax + ecx));
    ecx = *((ebx + 0x18));
    ecx >>= 1;
    edx = eax + ecx;
    *((ebp - 0x1c)) = edx;
    if (eax != 0) {
        if (edx < 0) {
            goto label_5;
        }
        eax = *((esi + 0x28));
        eax >>= 1;
        if (edx > eax) {
            goto label_5;
        }
        eax = *((esi + 0x30));
        eax = *((eax + edx*2));
        if (ecx == eax) {
            goto label_6;
        }
    }
label_5:
    eax = *((esi + 0x20));
    edx = *((ebp - 0x28));
    eax = *((eax + edx));
    edx = eax + ecx;
    if (eax != 0) {
        if (edx < 0) {
            goto label_7;
        }
        eax = *((esi + 0x28));
        eax >>= 1;
        if (edx > eax) {
            goto label_7;
        }
        edx += edx;
        eax = *((esi + 0x30));
        eax = *((eax + edx));
        if (ecx != eax) {
            goto label_7;
        }
        eax = *((esi + 0x2c));
        eax = *((eax + edx));
        *((ebp - 0x1c)) = eax;
        goto label_2;
    }
label_7:
    if (*((ebp - 0x24)) <= 0) {
        eax = edi + edi + 1;
        *((ebx + 0x34)) = eax;
        ecx = *((ebp - 0x20));
        eax = ecx + ecx + 1;
        *((ebx + 0x38)) = eax;
        edx = *((ebp - 0x24));
        eax = edx + edx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 0xb;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        *((ebp - 0x20)) = eax;
        eax = *((ebx + 0x3c));
        eax >>= 1;
        *((ebp - 0x24)) = eax;
    }
    if (*((ebp - 0x24)) > 2) {
        goto label_8;
    }
    do {
        eax = *(ebx);
        edx = *((eax + edi*4));
        edx >>= 1;
        eax = *((esi + 0x1c));
        eax = *((eax + edx*2));
        ecx = eax + 0x100;
        if (eax != 0) {
            if (ecx < 0) {
                goto label_9;
            }
            eax = *((esi + 0x28));
            eax >>= 1;
            if (ecx > eax) {
                goto label_9;
            }
            eax = *((esi + 0x30));
            if (*((eax + ecx*2)) != 0x100) {
                goto label_9;
            }
            *((ebp - 0x1c)) = ecx;
            *((ebp - 0x24)) = 3;
            if (*(obj.caml_parser_trace) == 0) {
                goto label_10;
            }
            *((esp + 8)) = edx;
            eax = stderr;
            fprintf (eax, "Recovering in state %d\n");
            *((ebp - 0x24)) = 3;
            goto label_11;
        }
label_9:
        if (*(obj.caml_parser_trace) != 0) {
            *((esp + 8)) = edx;
            eax = stderr;
            fprintf (eax, "Discarding state %d\n");
        }
        eax = *((ebx + 0x14));
        eax >>= 1;
        if (edi <= eax) {
            if (*(obj.caml_parser_trace) == 0) {
                goto label_1;
            }
            eax = stderr;
            fwrite (eax, 1, 0x1a);
            eax = 3;
            goto label_3;
        }
        edi--;
    } while (1);
label_8:
    eax = *((ebx + 0x18));
    eax >>= 1;
    if (eax == 0) {
        goto label_1;
    }
    if (*(obj.caml_parser_trace) != 0) {
        eax = stderr;
        fwrite (eax, 1, 0x1b);
    }
    *((ebx + 0x18)) = 0xffffffff;
    goto label_0;
label_6:
    *((ebx + 0x18)) = 0xffffffff;
    al = (*((ebp - 0x24)) > 0) ? 1 : 0;
    eax = (int32_t) al;
    *((ebp - 0x24)) -= eax;
label_11:
    if (*(obj.caml_parser_trace) != 0) {
        eax = *((esi + 0x2c));
        ecx = *((ebp - 0x1c));
        eax = *((eax + ecx*2));
        *((esp + 0xc)) = eax;
        eax = *((ebp - 0x20));
        *((esp + 8)) = eax;
        eax = stderr;
        fprintf (eax, "State %d: shift to state %d\n");
    }
label_10:
    eax = *((esi + 0x2c));
    edx = *((ebp - 0x1c));
    eax = *((eax + edx*2));
    *((ebp - 0x20)) = eax;
    edi++;
    eax = *((ebx + 0x10));
    eax >>= 1;
    if (edi >= eax) {
        eax = edi + edi + 1;
        *((ebx + 0x34)) = eax;
        ecx = *((ebp - 0x20));
        eax = ecx + ecx + 1;
        *((ebx + 0x38)) = eax;
        edx = *((ebp - 0x24));
        eax = edx + edx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 5;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        *((ebp - 0x20)) = eax;
        eax = *((ebx + 0x3c));
        eax >>= 1;
        *((ebp - 0x24)) = eax;
    }
    ecx = edi*4;
    *((ebp - 0x1c)) = ecx;
    edx = *(ebx);
    ecx = *((ebp - 0x20));
    eax = ecx + ecx + 1;
    ecx = *((ebp - 0x1c));
    *((ecx + edx)) = eax;
    eax = *((ebx + 0x1c));
    eax = ecx;
    eax += *((ebx + 4));
    caml_modify (eax, eax);
    eax = *((ebx + 0x20));
    eax = *((ebp - 0x1c));
    eax += *((ebx + 8));
    caml_modify (eax, eax);
    eax = *((ebx + 0x24));
    eax = *((ebp - 0x1c));
    eax += *((ebx + 0xc));
    caml_modify (eax, eax);
    goto label_0;
label_2:
    if (*(obj.caml_parser_trace) != 0) {
        eax = *((ebp - 0x1c));
        *((esp + 0xc)) = eax;
        edx = *((ebp - 0x20));
        *((esp + 8)) = edx;
        eax = stderr;
        fprintf (eax, "State %d: reduce by rule %d\n");
    }
    eax = *((ebp - 0x1c));
    eax += eax;
    edx = *((esi + 0x10));
    edx = *((edx + eax));
    ecx = edi + edi + 1;
    *((ebx + 0x28)) = ecx;
    ecx = eax + 1;
    *((ebx + 0x30)) = ecx;
    ecx = edx + edx + 1;
    *((ebx + 0x2c)) = ecx;
    edi++;
    edi -= edx;
    edx = *(ebx);
    edx = *((edx + edi*4 - 4));
    edx >>= 1;
    *((ebp - 0x20)) = edx;
    edx = *((esi + 0xc));
    edx = *((edx + eax));
    edx += edx;
    eax = *((esi + 0x24));
    eax = *((eax + edx));
    ecx = *((ebp - 0x20));
    ecx += eax;
    if (eax != 0) {
        if (ecx >= 0) {
            eax = *((esi + 0x28));
            eax >>= 1;
            if (ecx > eax) {
                goto label_12;
            }
            ecx += ecx;
            eax = *((esi + 0x30));
            eax = *((eax + ecx));
            if (eax != *((ebp - 0x20))) {
                goto label_12;
            }
            eax = *((esi + 0x2c));
            eax = *((eax + ecx));
        }
    } else {
label_12:
        eax = *((esi + 0x18));
        eax = *((eax + edx));
    }
    edx = *((ebx + 0x10));
    edx >>= 1;
    if (edi >= edx) {
        edx = edi + edi + 1;
        *((ebx + 0x34)) = edx;
        eax = eax + eax + 1;
        *((ebx + 0x38)) = eax;
        ecx = *((ebp - 0x24));
        eax = ecx + ecx + 1;
        *((ebx + 0x3c)) = eax;
        eax = 7;
        goto label_3;
        edi = *((ebx + 0x34));
        edi >>= 1;
        eax = *((ebx + 0x38));
        eax >>= 1;
        edx = *((ebx + 0x3c));
        edx >>= 1;
        *((ebp - 0x24)) = edx;
    }
    edx = edi + edi + 1;
    *((ebx + 0x34)) = edx;
    eax = eax + eax + 1;
    *((ebx + 0x38)) = eax;
    edx = *((ebp - 0x24));
    eax = edx + edx + 1;
    *((ebx + 0x3c)) = eax;
    eax = 9;
    goto label_3;
    edi = *((ebx + 0x34));
    edi >>= 1;
    eax = *((ebx + 0x38));
    eax >>= 1;
    *((ebp - 0x20)) = eax;
    eax = *((ebx + 0x3c));
    eax >>= 1;
    *((ebp - 0x24)) = eax;
    ecx = edi*4;
    *((ebp - 0x28)) = ecx;
    edx = *(ebx);
    ecx = *((ebp - 0x20));
    eax = ecx + ecx + 1;
    ecx = *((ebp - 0x28));
    *((ecx + edx)) = eax;
    eax = *((ebp + 0x14));
    eax = ecx;
    eax += *((ebx + 4));
    caml_modify (eax, eax);
    eax = *((ebx + 0x28));
    eax >>= 1;
    *((ebp - 0x1c)) = eax;
    eax <<= 2;
    *((ebp - 0x2c)) = eax;
    eax = *((ebx + 0xc));
    ecx = *((ebp - 0x2c));
    edx = *((ecx + eax));
    eax += *((ebp - 0x28));
    caml_modify (eax, edx);
    if (edi <= *((ebp - 0x1c))) {
        goto label_0;
    }
    eax = *((ebx + 0xc));
    edx = *((ebp - 0x2c));
    eax = *((edx + eax));
    eax = *((ebp - 0x28));
    eax += *((ebx + 8));
    caml_modify (eax, eax);
    goto label_0;
label_1:
    eax = 3;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a614 */
#include <stdint.h>
 
void fputc (void) {
    fputc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a534 */
#include <stdint.h>
 
void fwrite (void) {
    fwrite ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a9d5 */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_8 (void) {
    int32_t var_8h;
    int32_t var_bp_4h;
    int32_t var_4h;
    eax = ebp - 8;
    caml_deserialize_block_8 (eax, 1);
    eax = *((ebp - 8));
    edx = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066bef */
#include <stdint.h>
 
int32_t caml_int64_of_float (int32_t arg_8h) {
    int32_t var_ch;
    int32_t var_ah;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 0xa));
    ah = 0xc;
    *((ebp - 0xc)) = ax;
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_int64 ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066841 */
#include <stdint.h>
 
int32_t caml_nativeint_shift_right (int32_t arg_8h, int32_t arg_ch) {
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    eax = *((eax + 4));
    eax >>= cl;
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067c96 */
#include <stdint.h>
 
int32_t caml_string_greaterequal (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = caml_string_compare (eax, eax);
    al = (eax > 0) ? 1 : 0;
    eax = (int32_t) al;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e1fb */
#include <stdint.h>
 
int32_t unix_getservbyname (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14ffd;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = getservbyname ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_service_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a884 */
#include <stdint.h>
 
void getservbyname (void) {
    getservbyname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80501a0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1485 (void) {
    eax = caml_ml_seek_out_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f6e0 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1396 (void) {
    eax = caml_ml_channel_size;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80685a3 */
#include <stdint.h>
 
int32_t caml_channel_descriptor (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    ebx = *(eax);
    if (ebx == -1) {
        errno_location ();
        *(eax) = 9;
        caml_sys_error (1);
    }
    eax = ebx + ebx + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804be60 */
#include <stdint.h>
 
int32_t camlUnix_fun_2582 (void) {
    eax = unix_getprotobyname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061df3 */
#include <stdint.h>
 
int32_t caml_raise_constant (void) {
    int32_t var_4ch_2;
    int32_t var_48h_3;
    int32_t var_44h_3;
    int32_t var_40h_3;
    int32_t var_2ch_2;
    int32_t var_28h_3;
    int32_t var_24h_3;
    int32_t var_20h_3;
    int32_t var_1ch_3;
    int32_t var_4h_7;
    int32_t var_4h_6;
    eax = caml_local_roots;
    *((ebp - 0x28)) = eax;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x2c)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    eax = caml_alloc_small (1, 0);
    *((ebp - 0x2c)) = eax;
    edx = *((ebp + 8));
    *(eax) = edx;
    eax = *((ebp - 0x2c));
    return caml_raise (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b2f0 */
#include <stdint.h>
 
void camlPrintf_fun_1710 (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804be80 */
#include <stdint.h>
 
int32_t camlUnix_fun_2586 (void) {
    eax = unix_gethostbyname;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a570 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1575 (void) {
    int32_t var_4h_3;
    int32_t var_8h_3;
    *((esp + 8)) = eax;
    *((esp + 4)) = ebx;
    *(esp) = ecx;
    eax = caml_make_vect;
    eax = caml_c_call (5);
    ebx = eax;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_0;
        }
        eax = *((esp + 8));
        eax = caml_modify (ebx, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_1;
        }
        eax = *((esp + 8));
        *(fp_stack--) = *(eax);
        *(ebx) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_2;
        }
        eax = *((esp + 4));
        eax = ebx;
        eax += 4;
        eax = caml_modify (eax, eax);
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_3;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *((ebx + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax = *(esp);
    ecx = *((eax + 0xc));
    eax = *((eax + 0x10));
    void (*0x804b540)() ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ab30 */
#include <stdint.h>
 
int32_t caml_deserialize_block_1 (void * s1, int32_t arg_ch) {
    void * s2;
    size_t * n;
    ebx = *((ebp + 0xc));
    eax = intern_src;
    eax = *((ebp + 8));
    memmove (eax, eax, ebx);
    *(obj.intern_src) += ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050180 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1489 (void) {
    eax = caml_ml_channel_size_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c0c0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2652 (void) {
    eax = unix_mktime;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067044 */
#include <stdint.h>
 
int32_t caml_int32_and (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax &= *((edx + 4));
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066897 */
#include <stdint.h>
 
int32_t caml_nativeint_or (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax |= *((edx + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061bed */
#include <stdint.h>
 
void caml_array_bound_error (void) {
    int32_t var_4h_9;
    int32_t var_sp_8h;
    if (*(obj.array_bound_error_bucket_inited) == 0) {
        *(obj.array_bound_error_msg) = 0x14fc;
        *(0x807ca27) = 0;
        *(obj.array_bound_error_bucket) = 0x800;
        *(0x807ccec) = 0x8073548;
        *(0x807ccf0) = 0x807ca14;
        *(obj.array_bound_error_bucket_inited) = 1;
        caml_page_table_add (4, 0x807ca10, 0x807ca2c);
        *(obj.array_bound_error_bucket_inited) = 1;
    }
    return caml_raise (0x807ccec);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806a7e9 */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_4 (void) {
    ecx = intern_src;
    edx = ecx + 4;
    *(obj.intern_src) = edx;
    ebx = *((edx - 1));
    eax = *(ecx);
    eax <<= 0x18;
    eax = ebx + eax;
    ecx = *((edx - 3));
    ecx <<= 0x10;
    eax += ecx;
    edx = *((edx - 2));
    edx <<= 8;
    eax += edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ff60 */
#include <stdint.h>
 
uint32_t camlPervasives_print_int_1270 (void) {
    eax = camlPervasives_string_of_int_1130 ();
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80606ee */
#include <stdint.h>
 
uint32_t unix_stat_64 (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x12b05;
    esi = *((ebp + 8));
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = 3;
    eax = xstat64 ();
    if (eax == -1) {
        eax = ebx - 0x231d;
        uerror (eax, esi);
    }
    edx = ebp - 0x68;
    eax = 1;
    stat_aux ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b2b0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1697 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f914 */
#include <stdint.h>
 
uint32_t unix_setgroups (int32_t arg_8h) {
    int32_t var_1ch;
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x138e2;
    esi = *((ebp + 8));
    edi = *((esi - 4));
    edi >>= 0xa;
    eax = edi*4;
    eax = caml_stat_alloc (eax);
    *((ebp - 0x1c)) = eax;
    if (edi == 0) {
        goto label_0;
    }
    edx = 0;
    do {
        ecx = *((esi + edx*4));
        ecx >>= 1;
        *((eax + edx*4)) = ecx;
        edx++;
    } while (edi > edx);
label_0:
    eax = *((ebp - 0x1c));
    *((esp + 4)) = eax;
    *(esp) = edi;
    eax = setgroups ();
    esi = eax;
    eax = *((ebp - 0x1c));
    caml_stat_free (eax);
    if (esi == -1) {
        eax = ebx - 0x2424;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80678f9 */
#include <stdint.h>
 
int32_t caml_neg_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    fp_stack[0] = -fp_stack[0];
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069341 */
#include <stdint.h>
 
uint32_t caml_ml_flush_partial (int32_t arg_8h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = caml_local_roots;
    *((ebp - 0x38)) = esi;
    eax = ebp - 0x38;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x30)) = 1;
    *((ebp - 0x34)) = 1;
    eax = ebp + 8;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp + 8));
    ebx = *((eax + 4));
    if (*(ebx) == -1) {
        *(obj.caml_local_roots) = esi;
        eax = 3;
    } else {
        eax = caml_channel_mutex_lock;
        if (eax != 0) {
            void (*eax)(uint32_t) (ebx);
        }
        eax = caml_flush_partial (ebx);
        edi = eax;
        eax = caml_channel_mutex_unlock;
        if (eax != 0) {
            eax = void (*eax)(uint32_t) (ebx);
        }
        eax -= eax;
        eax &= 0xfffffffe;
        *(obj.caml_local_roots) = esi;
        eax = eax + 3;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b400 */
#include <stdint.h>
 
void camlPrintf_bad_conversion_format_1061 (void) {
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ecx = ebx + ebx + 1;
    ebx = 1;
    camlString_sub_1046 (ebx, ecx);
    ebx = *(esp);
    ecx = *((esp + 4));
    return camlPrintf_bad_conversion_1057 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805bae0 */
#include <stdint.h>
 
uint32_t camlPrintf_count_arguments_of_format_1198 (void) {
    eax = camlPrintf_ac_of_format_1184 ();
    eax = *(eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805ce12 */
#include <stdint.h>
 
int32_t unix_execvp (void) {
    int32_t var_ch_5;
    int32_t var_8h_5;
    int32_t var_4h_4;
    int32_t var_8h_6;
    int32_t var_ch_6;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x163de;
    edi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax = cstringvect (eax);
    esi = eax;
    *((esp + 4)) = eax;
    *(esp) = edi;
    execvp ();
    caml_stat_free (esi);
    eax = ebx - 0x25b7;
    return uerror (eax, edi);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c380 */
#include <stdint.h>
 
int32_t camlUnix_fun_2732 (void) {
    eax = unix_fstat;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066fa0 */
#include <stdint.h>
 
int32_t caml_int32_of_int (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax >>= 1;
    caml_copy_int32 (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bf46 */
#include <stdint.h>
 
uint32_t caml_sys_getcwd (void) {
    int32_t var_1008h;
    int32_t var_4h;
    *((esp + 4)) = 0x1000;
    eax = ebp - 0x1008;
    *(esp) = eax;
    eax = getcwd ();
    if (eax == 0) {
        caml_sys_error (1);
    }
    eax = ebp - 0x1008;
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c0e0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2656 (void) {
    eax = unix_gmtime;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80665a1 */
#include <stdint.h>
 
uint32_t caml_int64_format (void) {
    char * format;
    int32_t var_8h_2;
    int32_t var_ch_2;
    int32_t var_4h;
    int32_t var_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = ebp - 0x38;
    eax = ebp - 0x59;
    edi = ebp - 0x58;
    ecx = esi;
    edx = 0x8070d3e;
    eax = *((ebp + 8));
    eax = parse_format (edi, eax);
    ebx = eax;
    eax = *((ebp + 0xc));
    edx = *((eax + 8));
    eax = *((eax + 4));
    *((esp + 8)) = eax;
    sprintf (edx, esi);
    eax = caml_copy_string (ebx);
    esi = eax;
    if (ebx != edi) {
        caml_stat_free (ebx);
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054b30 */
#include <stdint.h>
 
int32_t camlList_memq_1165 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 4));
        ecx = *(ebx);
        if (ecx == eax) {
            eax = 3;
            return eax;
        }
        ebx = edx;
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80590f0 */
#include <stdint.h>
 
int32_t camlPrintf_loop_1159 (void) {
    do {
        ecx = *((ebx + 0x10));
        ecx += 0xfffffffc;
        if (eax >= ecx) {
            goto label_0;
        }
        *(esp) = ebx;
        ecx = *((ebx + 0xc));
        edx = *((ebx + 8));
        ebx = eax;
        ebx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ebx) {
            goto label_1;
        }
        ebx = *((edx + ebx));
        ebx = ebx + ebx + 1;
        caml_apply2 ();
        ebx = *(esp);
    } while (1);
label_0:
    eax = 1;
    return eax;
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c7b0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2800 (void) {
    eax = unix_stat_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066c96 */
#include <stdint.h>
 
int32_t caml_int64_shift_left (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    __asm ("shld edx, eax, cl");
    eax <<= cl;
    if ((cl & 0x20) != 0) {
        edx = eax;
        eax = 0;
    }
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c1c0 */
#include <stdint.h>
 
int32_t camlPrintf_ifprintf_1389 (void) {
    ebx = .comment;
    eax = loc.camlPrintf__44;
    ecx = *(ebx);
    return void (*ecx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804e2a0 */
#include <stdint.h>
 
int32_t camlUnix_shutdown_connection_2022 (void) {
    eax = caml_channel_descriptor;
    eax = caml_c_call (eax);
    eax = unix_shutdown;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80675da */
#include <stdint.h>
 
int32_t caml_power_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    pow (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a024 */
#include <stdint.h>
 
void pow (void) {
    pow ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c7d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2796 (void) {
    eax = unix_truncate_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80506f0 */
#include <stdint.h>
 
int32_t loc_camlArray_code_begin (void) {
    int32_t var_4h_4;
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    do {
label_0:
        eax = ebx;
        ecx = *((edi + 0xc));
        ebx = edx;
        eax = caml_apply2 (eax, eax, ecx);
        if (eax > 1) {
            goto label_2;
        }
        edi = *(esp);
        eax = *((edi + 0x18));
        ebx = *((eax - 4));
        ecx = *((eax - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            ebx >>= 9;
            esi = *((esp + 0x10));
            if (ebx <= esi) {
                goto label_3;
            }
            ebx = *((esp + 0x14));
            caml_modify (eax + esi*2 - 2, ebx);
        } else {
            ebx >>= 0xa;
            esi = *((esp + 0x10));
            if (ebx <= esi) {
                goto label_4;
            }
            ebx = *((esp + 0x14));
            *(fp_stack--) = *(ebx);
            *((eax + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((esp + 4));
        ecx += 2;
        eax = *((edi + 0x1c));
        if (ecx >= eax) {
            goto label_5;
        }
        ebx = *((edi + 0x10));
        edx = *((ebx - 4));
        eax = *((ebx - 4));
        eax &= 0xff;
        if (eax != 0xfe) {
            eax = edx;
            eax >>= 9;
            if (eax <= ecx) {
                goto label_6;
            }
            ebx = *((ebx + ecx*2 - 2));
        } else {
            eax = edx;
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_7;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_8;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
            ebx = edx;
        }
        esi += 2;
        eax = ecx;
        ecx = *((esp + 8));
        edx = *((esp + 0xc));
    } while (1);
label_5:
    ebp = *((edi + 0x20));
    ebx = *((esp + 8));
    ebp -= ebx;
    ebp++;
    esi += 2;
    ecx = *((edi + 0x18));
    eax = *((edi + 0x14));
    edx = esi;
    esi = ebp;
    void (*0x8052430)() ();
label_2:
    edi = *(esp);
    eax = *((edi + 0x18));
    ebx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        ebx >>= 9;
        esi = *((esp + 0x10));
        if (ebx <= esi) {
            goto label_9;
        }
        ebx = *((esp + 0xc));
        caml_modify (eax + esi*2 - 2, ebx);
    } else {
        ebx >>= 0xa;
        esi = *((esp + 0x10));
        if (ebx <= esi) {
            goto label_10;
        }
        ebx = *((esp + 0xc));
        *(fp_stack--) = *(ebx);
        *((eax + esi*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    ecx = *((esp + 8));
    ecx += 2;
    eax = *((edi + 0x20));
    if (ecx >= eax) {
        goto label_11;
    }
    ebx = *((edi + 0x14));
    edx = *((ebx - 4));
    eax = *((ebx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = edx;
        eax >>= 9;
        if (eax <= ecx) {
            goto label_12;
        }
        edx = *((ebx + ecx*2 - 2));
        goto label_13;
    }
    eax = edx;
    eax >>= 0xa;
    if (eax <= ecx) {
        goto label_14;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + ecx*4 - 4));
            *(edx) = fp_stack[0];
            fp_stack--;
label_13:
            esi += 2;
            eax = *((esp + 4));
            ebx = *((esp + 0x14));
            goto label_0;
label_11:
            ebp = *((edi + 0x1c));
            ebx = *((esp + 4));
            ebp -= ebx;
            ebp++;
            esi += 2;
            ecx = *((edi + 0x18));
            eax = *((edi + 0x10));
            edx = esi;
            esi = ebp;
            void (*0x8052430)() ();
        }
        caml_call_gc ();
    } while (1);
label_8:
    caml_call_gc ();
    goto label_1;
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054b70 */
#include <stdint.h>
 
int32_t camlList_assoc_1169 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 4)) = ecx;
        ecx = *(ebx);
        ebx = *((ecx + 4));
        *((esp + 8)) = ebx;
        ebx = *(ecx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = *((esp + 8));
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
    do {
label_0:
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806785d */
#include <stdint.h>
 
int32_t caml_exp_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    exp (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a144 */
#include <stdint.h>
 
void exp (void) {
    exp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067150 */
#include <stdint.h>
 
int32_t caml_int_of_float (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_2h;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp - 2));
    ah = 0xc;
    *((ebp - 4)) = ax;
    *((ebp - 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 8));
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ab80 */
#include <stdint.h>
 
int32_t caml_curry9_4 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry9_5;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a880 */
#include <stdint.h>
 
uint32_t camlPrintf_scan_conv_1293 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
label_0:
    edi = ecx;
    ebp >>= 1;
    ecx = *((esi + 0xc));
    ecx = *((ecx + ebp));
    ecx = ecx + ecx + 1;
    if (ecx >= 0xf9) {
        void (*0x805aad0)() ();
    }
    edi = ecx;
    edi >>= 1;
    /* switch table (195 cases) at 0x807af78 */
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx, edi);
    *((esp + 4)) = eax;
    esi = *((esp + 8));
    if (esi == 1) {
        eax = camlPervasives_string_of_float_1140 ();
        *(esp) = eax;
    } else {
        eax = *((esp + 0x18));
        ecx = *((eax + 0x10));
        ebx = *((eax + 0xc));
        eax = *(esp);
        edx = *((esp + 0xc));
        camlPrintf_extract_format_float_1110 ();
        ebx = *((esp + 4));
        eax = camlPrintf_fun_1600 ();
        *(esp) = eax;
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    *(esp) = eax;
    eax = .comment;
    ebx = *((eax + 8));
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *(eax);
    } else {
        eax = *((esp + 0x14));
    }
    ecx = *(ebx);
    eax = void (*ecx)() ();
    ebx = eax;
    eax = *((esp + 0x18));
    ecx = *((eax + 0x28));
    eax = 1;
    eax = camlPrintf_get_arg_1288 (ebx);
    *((esp + 4)) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 8));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 8));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    esi = *((ebx + 0x18));
    edx = *((esp + 0xc));
    edx += 2;
    ebx = *(esp);
    ecx = *((esp + 4));
    void (*0x804b490)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x1c));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    ecx = *((esi + 0x28));
    camlPrintf_get_arg_1288 ();
    ebx = *(esp);
    if (ebx == 0xe7) {
    } else {
        camlString_escaped_1080 ();
        ebx = loc.camlPrintf__58;
        eax = camlPervasives_$5e_1112 ();
        ebx = eax;
        eax = loc.camlPrintf__57;
        eax = camlPervasives_$5e_1112 ();
    }
    edx = *((esp + 0x18));
    ebx = *((edx + 0x10));
    ebx += 2;
    ecx = *((esp + 0xc));
    if (ecx == ebx) {
        *(esp) = eax;
    } else {
        ebx = *((edx + 0x10));
        eax = *((edx + 0xc));
        edx = *((esp + 8));
        camlPrintf_extract_format_1085 (eax);
        ebx = *(esp);
        eax = camlPrintf_format_string_1080 ();
        *(esp) = eax;
    }
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 (ecx);
    eax = *((esp + 0x18));
    ecx = *((eax + 0x10));
    ebx = *((eax + 0xc));
    eax = *(esp);
    edx = *((esp + 0xc));
    esi = *((esp + 8));
    eax = camlPrintf_extract_format_int_1103 (eax);
    ebx = *((esp + 4));
    eax = caml_format_int;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    eax = *((esp + 0x18));
    ebx = *((eax + 0x10));
    eax = *((eax + 0xc));
    ecx = *((esp + 0xc));
    edx = *((esp + 8));
    eax = camlPrintf_extract_format_1085 (eax);
    ebx = *(esp);
    eax = caml_format_float;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    ebp += 2;
    ebp >>= 1;
    edi = *((esi + 0xc));
    edi = *((edi + ebp));
    edi = edi + edi + 1;
    edi += 0xffffff50;
    if (edi <= 0x41) {
        edi >>= 1;
        /* switch table (66 cases) at 0x807b168 */
    }
    ecx = *((esi + 0x28));
    eax = camlPrintf_get_arg_1288 ();
    eax = *((esp + 0x18));
    ecx = *((eax + 0x10));
    ebx = *((eax + 0xc));
    eax = 0xdd;
    edx = *((esp + 0xc));
    esi = *((esp + 8));
    eax = camlPrintf_extract_format_int_1103 (eax);
    ebx = *(esp);
    eax = caml_format_int;
    eax = caml_c_call (eax);
    *(esp) = eax;
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 0xc));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    edx += 2;
    *((esp + 4)) = edx;
    ecx += 0xffffff28;
    if (ecx <= 5) {
        ecx >>= 1;
        if (ecx != 1) {
            if (ecx <= 1) {
                ecx = *((esi + 0x28));
                eax = camlPrintf_get_arg_1288 ();
                eax = *((esp + 0x18));
                ebx = *((eax + 0x10));
                eax = *((eax + 0xc));
                ecx = *((esp + 4));
                edx = *((esp + 8));
                eax = camlPrintf_extract_format_1085 (eax);
                ebx = *(esp);
                eax = caml_int32_format;
                eax = caml_c_call (eax);
                *(esp) = eax;
                goto label_6;
            }
            ecx = *((esi + 0x28));
            eax = camlPrintf_get_arg_1288 ();
            eax = *((esp + 0x18));
            ebx = *((eax + 0x10));
            eax = *((eax + 0xc));
            ecx = *((esp + 4));
            edx = *((esp + 8));
            eax = camlPrintf_extract_format_1085 (eax);
            ebx = *(esp);
            eax = caml_nativeint_format;
            eax = caml_c_call (eax);
            *(esp) = eax;
        }
    } else {
        ecx = *((esi + 0x28));
        eax = camlPrintf_get_arg_1288 ();
        eax = *((esp + 0x18));
        ebx = *((eax + 0x10));
        eax = *((eax + 0xc));
        ecx = *((esp + 4));
        edx = *((esp + 8));
        eax = camlPrintf_extract_format_1085 (eax);
        ebx = *(esp);
        eax = caml_int64_format;
        eax = caml_c_call (eax);
        *(esp) = eax;
    }
label_6:
    eax = *((esp + 0x10));
    if (eax != 1) {
        eax = *((esp + 0x14));
    } else {
        eax = .comment;
        ebx = *((eax + 8));
        ecx = *(ebx);
        eax = *((esp + 0x14));
        void (*ecx)() ();
    }
    ebx = *((esp + 0x18));
    edx = *((ebx + 0x14));
    ecx = *((esp + 4));
    ecx += 2;
    ebx = *(esp);
    void (*0x804b4f0)() ();
    do {
        eax = caml_young_ptr;
        eax -= 0x24;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x20f7;
            *(ebx) = sym.caml_curry2;
            *((ebx + 4)) = 5;
            *((ebx + 8)) = 0x80591f0;
            eax = *((esi + 0x38));
            *((ebx + 0xc)) = eax;
            *((ebx + 0x10)) = esi;
            *((ebx + 0x14)) = edi;
            *((ebx + 0x18)) = ebp;
            *((ebx + 0x1c)) = ecx;
            edx += 2;
            eax = *((esi + 0x1c));
            ecx = ebp;
            void (*0x805be10)() ();
            esi += 0x10;
            eax = edi;
            ebx = ebp;
            goto label_0;
            edx += 2;
            eax = edi;
            ebx = ebp;
            void (*0x805b020)() ();
        }
        caml_call_gc ();
    } while (1);
    ebx = loc.camlPrintf__45;
    eax = *((esp + 4));
    ecx = *(esp);
    void (*0x804b540)() ();
label_5:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_7;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.camlPrintf__fun_1572;
    *((eax + 4)) = 3;
    ebx = *(esp);
    *((eax + 8)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0xc)) = ebx;
    return eax;
label_4:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_8;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x805a570;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
label_3:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_9;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry3;
    *((eax + 4)) = 7;
    *((eax + 8)) = 0x805a430;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
label_2:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_10;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry4;
    *((eax + 4)) = 9;
    *((eax + 8)) = 0x805a290;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
label_1:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_11;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry5;
    *((eax + 4)) = 0xb;
    *((eax + 8)) = 0x805a090;
    ebx = *(esp);
    *((eax + 0xc)) = ebx;
    ebx = *((esp + 4));
    *((eax + 0x10)) = ebx;
    return eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x18;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x14f7;
            *(eax) = sym.caml_curry6;
            *((eax + 4)) = 0xd;
            *((eax + 8)) = 0x8059e30;
            ebx = *(esp);
            *((eax + 0xc)) = ebx;
            ebx = *((esp + 4));
            *((eax + 0x10)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_11:
    caml_call_gc ();
    goto label_1;
label_10:
    caml_call_gc ();
    goto label_2;
label_9:
    caml_call_gc ();
    goto label_3;
label_8:
    caml_call_gc ();
    goto label_4;
label_7:
    caml_call_gc ();
    goto label_5;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067751 */
#include <stdint.h>
 
uint32_t caml_frexp_float (int32_t arg_8h) {
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_8h;
    ebx = caml_local_roots;
    *((ebp - 0x28)) = ebx;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x30)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x50)) = eax;
    eax = ebp - 0x50;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x48)) = 1;
    *((ebp - 0x4c)) = 2;
    eax = ebp - 0x2c;
    *((ebp - 0x44)) = eax;
    eax = ebp - 0x30;
    *((ebp - 0x40)) = eax;
    eax = ebp - 0x54;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    frexp (ebx, eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    *((ebp - 0x30)) = eax;
    eax = caml_alloc_tuple (2);
    *((ebp - 0x2c)) = eax;
    edx = *((ebp - 0x30));
    *(eax) = edx;
    eax = *((ebp - 0x54));
    edx = eax + eax + 1;
    eax = *((ebp - 0x2c));
    *((eax + 4)) = edx;
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a554 */
#include <stdint.h>
 
void frexp (void) {
    frexp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80562b0 */
#include <stdint.h>
 
void camlString_compare_1145 (void) {
    caml_string_compare (eax, ebx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c3a0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2736 (void) {
    eax = unix_stat;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067475 */
#include <stdint.h>
 
int32_t caml_expm1_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_expm1 ();
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80661af */
#include <stdint.h>
 
int32_t caml_nativeint_compare (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    edx = *((eax + 4));
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    cl = (edx > eax) ? 1 : 0;
    ecx = (int32_t) cl;
    dl = (edx < eax) ? 1 : 0;
    edx = (int32_t) dl;
    eax = ecx;
    eax -= edx;
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80572b0 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_1217 (void) {
    int32_t var_4h_3;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_18h_2;
    int32_t var_18h;
    int32_t var_24h;
    esi = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x18;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.camlHashtbl__replace_bucket_1221;
    *((eax + 4)) = 3;
    edi = *((edx + 0xc));
    *((eax + 8)) = edi;
    *((eax + 0xc)) = ebx;
    *((eax + 0x10)) = ecx;
    edi = *((esi + 4));
    edi = *((edi - 4));
    edi >>= 0xa;
    if (edi != 0) {
        eax = *((edx + 0x10));
        eax = *((eax + 8));
        ebx = *((eax + 4));
        ecx = *(ebx);
        eax = *((esp + 0x1c));
        eax = void (*ecx)(uint32_t, uint32_t, uint32_t) (eax, ecx, edi);
        ebx = 0x7fffffff;
        eax &= ebx;
        eax >>= 1;
        ecx = *((esp + 8));
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    *((esp + 0x18)) = edx;
    ebx = *(esp);
    ecx = *((ebx + 4));
    eax = *((ecx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    eax = *((ecx + edx*2 - 2));
    eax = void (*0x8057430)(uint32_t) (eax);
    ecx = loc.caml_exn_Not_found;
    ebx = *(eax);
    if (ebx != ecx) {
        goto label_3;
    }
    ebx = *(esp);
    edx = *((ebx + 4));
    eax = *((edx - 4));
    eax >>= 9;
    ecx = *((esp + 0x18));
    if (eax <= ecx) {
        goto label_4;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0xc00;
            eax = *((esp + 0x1c));
            *(esi) = eax;
            eax = *((esp + 4));
            *((esi + 4)) = eax;
            eax = *((esp + 8));
            *((esi + 8)) = eax;
            caml_modify (edx + ecx*2 - 2, esi);
            *(ebx) += 2;
            eax = *((ebx + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ecx = eax + eax - 1;
            eax = *(ebx);
            if (eax > ecx) {
                eax = *((esp + 0xc));
                eax = *((eax + 0x10));
                void (*0x80576b0)() ();
            }
            eax = 1;
            return eax;
label_3:
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            ebx = *((ebx + 4));
            *((esp + 0x1c)) = ebx;
            ebx = *((ebx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_5;
            }
            ebx = *((esp + 0x18));
            eax = camlHashtbl_replace_bucket_1221 ();
            ebx = *((esp + 0x20));
            eax = *((esp + 0x24));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fef0 */
#include <stdint.h>
 
int32_t camlPervasives_close_in_noerr_1263 (void) {
    fcn_0804ff00 ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804ff00 */
#include <stdint.h>
 
int32_t fcn_0804ff00 (void) {
    *(obj.caml_exception_pointer) = esp;
    eax = caml_ml_close_channel;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054cd0 */
#include <stdint.h>
 
int32_t camlList_mem_assq_1184 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        edx = *((ebx + 4));
        ecx = *(ebx);
        ecx = *(ecx);
        if (ecx == eax) {
            eax = 3;
            return eax;
        }
        ebx = edx;
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805cc9c */
#include <stdint.h>
 
int32_t unix_error_message (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1655c;
    eax = *((ebp + 8));
    if ((al & 1) == 0) {
        eax = *(eax);
        eax >>= 1;
    } else {
        eax >>= 1;
        edx = *((ebx - 8));
        eax = *((edx + eax*4));
    }
    eax = strerror (eax);
    caml_copy_string (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80667d1 */
#include <stdint.h>
 
int32_t caml_nativeint_of_int32 (int32_t arg_8h) {
    eax = *((ebp + 8));
    eax = *((eax + 4));
    caml_copy_nativeint (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052ae0 */
#include <stdint.h>
 
int32_t camlArray_to_list_1121 (void) {
    ebx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ecx = eax + 4;
            *((ecx - 4)) = 0x10f7;
            *(ecx) = sym.caml_curry2;
            *((ecx + 4)) = 5;
            *((ecx + 8)) = 0x8050b70;
            *((ecx + 0xc)) = ebx;
            eax = *((ebx - 4));
            ebx = *((ebx - 4));
            ebx &= 0xff;
            if (ebx != 0xfe) {
                eax >>= 9;
            } else {
                eax >>= 0xa;
            }
            eax |= 1;
            eax += 0xfffffffe;
            ebx = 1;
            void (*0x8050b70)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052df0 */
#include <stdint.h>
 
int32_t camlArray_sort_1152 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch_2;
    int32_t var_10h;
    int32_t var_14h;
    ecx = eax;
    *((esp + 0x10)) = ebx;
label_4:
    eax = caml_young_ptr;
    eax -= 0x90;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_5;
    }
    esi = eax + 4;
    *((esi - 4)) = 0x14f7;
    *(esi) = sym.caml_curry2;
    *((esi + 4)) = 5;
    *((esi + 8)) = 0x8050c60;
    *((esi + 0xc)) = ecx;
    *((esi + 0x10)) = ebx;
    edx = esi + 0x18;
    *((edx - 4)) = 0x18f7;
    *(edx) = sym.caml_curry3;
    *((edx + 4)) = 7;
    *((edx + 8)) = 0x8051050;
    *((edx + 0xc)) = ecx;
    *((edx + 0x10)) = ebx;
    *((edx + 0x14)) = esi;
    eax = esi + 0x34;
    *((esp + 4)) = eax;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry3;
    *((eax + 4)) = 7;
    *((eax + 8)) = 0x8051260;
    *((eax + 0xc)) = ebx;
    *((eax + 0x10)) = edx;
    edx = esi + 0x4c;
    *((edx - 4)) = 0x14f7;
    *(edx) = sym.caml_curry2;
    *((edx + 4)) = 5;
    *((edx + 8)) = 0x8051320;
    *((edx + 0xc)) = ebx;
    *((edx + 0x10)) = esi;
    eax = esi + 0x64;
    *(esp) = eax;
    *((eax - 4)) = 0x10f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x8051420;
    *((eax + 0xc)) = edx;
    eax = esi + 0x78;
    *((esp + 8)) = eax;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry2;
    *((eax + 4)) = 5;
    *((eax + 8)) = 0x8051470;
    *((eax + 0xc)) = ecx;
    *((eax + 0x10)) = ebx;
    eax = *((ebx - 4));
    ebx = *((ebx - 4));
    ebx &= 0xff;
    if (ebx != 0xfe) {
        eax >>= 9;
    } else {
        eax >>= 0xa;
    }
    eax |= 1;
    *((esp + 0x14)) = eax;
    ecx = 3;
    eax += 2;
    eax >>= 1;
    edx:eax = (int64_t) eax;
    eax = edx:eax / ecx;
    edx = edx:eax % ecx;
    ebx = eax + eax - 1;
    if (ebx < 1) {
        goto label_6;
    }
    *((esp + 0xc)) = ebx;
    do {
        edx = *((esp + 0x10));
        eax = *((edx - 4));
        ecx = *((edx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= ebx) {
                goto label_7;
            }
            ecx = *((edx + ebx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ebx) {
                goto label_8;
            }
label_3:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_9;
            }
            ecx = eax + 4;
            *((ecx - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ebx*4 - 4));
            *(ecx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((esp + 0x14));
        edx = *((esp + 4));
        camlArray_trickle_1165 ();
        ebx = *((esp + 0xc));
        eax = *((esp + 0xc));
        ebx -= 2;
        *((esp + 0xc)) = ebx;
    } while (eax != 1);
label_6:
    esi = *((esp + 0x14));
    esi += 0xfffffffe;
    if (esi < 5) {
        goto label_10;
    }
    *((esp + 0xc)) = esi;
    do {
        ebx = *((esp + 0x10));
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= esi) {
                goto label_11;
            }
            eax = *((ebx + esi*2 - 2));
            *((esp + 4)) = eax;
        } else {
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_12;
            }
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_13;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + esi*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
            *((esp + 4)) = eax;
        }
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= 1) {
                goto label_14;
            }
            edx = *(ebx);
        } else {
            eax >>= 0xa;
            if (eax <= 1) {
                goto label_15;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_16;
            }
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(edx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            if (eax <= esi) {
                goto label_17;
            }
            eax = caml_modify (ebx + esi*2 - 2, edx);
        } else {
            eax >>= 0xa;
            if (eax <= esi) {
                goto label_18;
            }
            *(fp_stack--) = *(edx);
            *((ebx + esi*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        ebx = 1;
        eax = esi;
        ecx = *(esp);
        camlArray_bubble_1174 ();
        ebx = *((esp + 4));
        ecx = *((esp + 8));
        camlArray_trickleup_1178 ();
        esi = *((esp + 0xc));
        eax = *((esp + 0xc));
        esi -= 2;
        *((esp + 0xc)) = esi;
    } while (eax != 5);
label_10:
    eax = *((esp + 0x14));
    if (eax <= 3) {
        goto label_19;
    }
    ebx = *((esp + 0x10));
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 3) {
            goto label_20;
        }
        esi = *((ebx + 4));
    } else {
        eax >>= 0xa;
        if (eax <= 3) {
            goto label_21;
        }
label_0:
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax < *(obj.caml_young_limit)) {
            goto label_22;
        }
        esi = eax + 4;
        *((esi - 4)) = 0x8fd;
        *(fp_stack--) = *((ebx + 8));
        *(esi) = fp_stack[0];
        fp_stack--;
    }
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_23;
        }
        edx = *(ebx);
        goto label_24;
    }
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_25;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            edx = eax + 4;
            *((edx - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(edx) = fp_stack[0];
            fp_stack--;
label_24:
            eax = *((ebx - 4));
            ecx = *((ebx - 4));
            ecx &= 0xff;
            if (ecx != 0xfe) {
                eax >>= 9;
                if (eax <= 3) {
                    goto label_26;
                }
                eax = ebx;
                eax += 4;
                eax = caml_modify (eax, edx);
            } else {
                eax >>= 0xa;
                if (eax <= 3) {
                    goto label_27;
                }
                *(fp_stack--) = *(edx);
                *((ebx + 8)) = fp_stack[0];
                fp_stack--;
            }
            eax = *((ebx - 4));
            ecx = *((ebx - 4));
            ecx &= 0xff;
            if (ecx != 0xfe) {
                eax >>= 9;
                if (eax <= 1) {
                    goto label_28;
                }
                eax = caml_modify (ebx, esi);
            } else {
                eax >>= 0xa;
                if (eax <= 1) {
                    goto label_29;
                }
                *(fp_stack--) = *(esi);
                *(ebx) = fp_stack[0];
                fp_stack--;
            }
            eax = 1;
            return eax;
label_19:
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_22:
    caml_call_gc ();
    goto label_0;
label_16:
    caml_call_gc ();
    goto label_1;
label_13:
    caml_call_gc ();
    goto label_2;
label_9:
    caml_call_gc ();
    goto label_3;
label_5:
    caml_call_gc ();
    goto label_4;
label_29:
    caml_ml_array_bound_error ();
label_28:
    caml_ml_array_bound_error ();
label_27:
    caml_ml_array_bound_error ();
label_26:
    caml_ml_array_bound_error ();
label_25:
    caml_ml_array_bound_error ();
label_23:
    caml_ml_array_bound_error ();
label_21:
    caml_ml_array_bound_error ();
label_20:
    caml_ml_array_bound_error ();
label_18:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_7:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c790 */
#include <stdint.h>
 
int32_t camlUnix_fun_2804 (void) {
    eax = unix_fstat_64;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050030 */
#include <stdint.h>
 
int32_t camlPervasives_prerr_string_1279 (void) {
    ebx = eax;
    eax = .comment;
    return camlPervasives_output_string_1191 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059cd0 */
#include <stdint.h>
 
int32_t camlPrintf_add_char_1192 (void) {
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8052b50 */
#include <stdint.h>
 
int32_t camlArray_list_length_1126 (void) {
    do {
        if (ebx == 1) {
            goto label_0;
        }
        ebx = *((ebx + 4));
        eax += 2;
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e6f9 */
#include <stdint.h>
 
int32_t unix_setitimer (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_38h;
    int32_t var_28h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14af7;
    esi = *((ebp + 0xc));
    edi = ebp - 0x28;
    *(fp_stack--) = *(esi);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = edi;
    unix_set_timeval ();
    eax = ebp - 0x20;
    *(fp_stack--) = *((esi + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    unix_set_timeval ();
    eax = ebp - 0x38;
    *((esp + 8)) = eax;
    *((esp + 4)) = edi;
    eax = *((ebp + 8));
    eax >>= 1;
    eax = *((ebx + eax*4 - 0x24d4));
    *(esp) = eax;
    eax = setitimer ();
    if (eax == -1) {
        eax = ebx - 0x24df;
        uerror (eax, 0);
    }
    eax = ebp - 0x38;
    unix_convert_itimer ();
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a084 */
#include <stdint.h>
 
void setitimer (void) {
    setitimer ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8056890 */
#include <stdint.h>
 
int32_t camlHashtbl_mem_in_bucket_1230 (void) {
    int32_t var_4h_2;
    do {
        if (eax == 1) {
            goto label_0;
        }
        ecx = *((eax + 8));
        eax = *(eax);
        ecx = *((ebx + 8));
        ecx = *(ecx);
        ebx = *((ebx + 0xc));
        eax = caml_apply2 (ecx, ebx);
        if (eax != 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f760 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1412 (void) {
    eax = caml_ml_channel_size;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bdba */
#include <stdint.h>
 
uint32_t caml_sys_read_directory (void) {
    int32_t var_58h_2;
    int32_t var_50h_2;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_2ch_2;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h_2;
    int32_t var_4h;
    esi = caml_local_roots;
    *((ebp - 0x28)) = esi;
    *((ebp - 0x20)) = 1;
    *((ebp - 0x24)) = 1;
    eax = ebp + 8;
    *((ebp - 0x1c)) = eax;
    *((ebp - 0x2c)) = 0;
    eax = ebp - 0x28;
    *((ebp - 0x4c)) = eax;
    eax = ebp - 0x4c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x44)) = 1;
    *((ebp - 0x48)) = 1;
    eax = ebp - 0x2c;
    *((ebp - 0x40)) = eax;
    ebx = ebp - 0x58;
    caml_ext_table_init (ebx, esi);
    eax = *((ebp + 8));
    eax = caml_read_directory (eax, ebx);
    if (eax == -1) {
        caml_ext_table_free (ebx, 1);
        eax = *((ebp + 8));
        caml_sys_error (eax);
    }
    ebx = ebp - 0x58;
    caml_ext_table_add (ebx, 0);
    eax = *((ebp - 0x50));
    eax = caml_copy_string_array (eax);
    *((ebp - 0x2c)) = eax;
    caml_ext_table_free (ebx, 1);
    *(obj.caml_local_roots) = esi;
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8054c70 */
#include <stdint.h>
 
int32_t camlList_mem_assoc_1179 (void) {
    int32_t var_4h;
    do {
        if (ebx == 1) {
            goto label_0;
        }
        *(esp) = eax;
        ecx = *((ebx + 4));
        *((esp + 4)) = ecx;
        ebx = *(ebx);
        ebx = *(ebx);
        eax = caml_compare;
        eax = caml_c_call (ebx);
        if (eax == 1) {
            eax = 3;
            return eax;
        }
        eax = *(esp);
        ebx = *((esp + 4));
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805a780 */
#include <stdint.h>
 
int32_t camlPrintf_valid_float_loop_1273 (void) {
    do {
        ecx = *((ebx + 0xc));
        if (eax >= ecx) {
            ecx = loc.camlPrintf__62;
            eax = *((ebx + 8));
            ebx = ecx;
            void (*0x804f900)() ();
        }
        edx = *((ebx + 8));
        ecx = eax;
        ecx >>= 1;
        esi = *((edx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((edx + esi));
        esi -= edi;
        if (esi <= ecx) {
            goto label_0;
        }
        ecx = *((edx + ecx));
        ecx = ecx + ecx + 1;
        ecx += 0xffffffa4;
        if (ecx > 0x2f) {
            if (ecx == 0x6f) {
                goto label_1;
            }
        } else {
            ecx += 0xfffffffe;
            if (ecx > 0x2b) {
                goto label_1;
            }
        }
        eax += 2;
    } while (1);
label_1:
    eax = *((ebx + 8));
    return eax;
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b2d0 */
#include <stdint.h>
 
int32_t camlPrintf_fun_1700 (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8066c65 */
#include <stdint.h>
 
int32_t caml_int64_shift_right (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    ecx = *((ebp + 0xc));
    ecx >>= 1;
    eax = *((ebp + 8));
    edx = *((eax + 8));
    eax = *((eax + 4));
    __asm ("shrd eax, edx, cl");
    edx >>= cl;
    if ((cl & 0x20) != 0) {
        eax = edx;
        edx >>= 0x1f;
    }
    caml_copy_int64 (eax, edx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f3e0 */
#include <stdint.h>
 
int32_t camlPervasives_iter_1186 (void) {
    do {
        if (eax == 1) {
            goto label_0;
        }
        ebx = *((eax + 4));
        *(esp) = ebx;
        eax = *(eax);
        fcn_0804f400 ();
        eax = *(esp);
    } while (1);
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f780 */
#include <stdint.h>
 
int32_t camlPervasives_fun_1416 (void) {
    eax = caml_ml_seek_out;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804dfe0 */
#include <stdint.h>
 
int32_t camlUnix_close_process_out_2006 (void) {
    int32_t var_4h;
    ecx = eax;
    *(esp) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x402;
            *(ebx) = ecx;
            eax = "close_process_out";
            eax = camlUnix_find_proc_id_1997 ();
            eax = *(esp);
            camlPervasives_close_out_1209 (eax);
            eax = *((esp + 4));
            eax = camlUnix_waitpid_non_intr_2001 ();
            eax += 4;
            eax = *(eax);
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8057cb0 */
#include <stdint.h>
 
int32_t camlHashtbl_replace_1112 (void) {
    int32_t var_4h_4;
    int32_t var_8h_4;
    int32_t var_ch_4;
    int32_t var_ch_5;
    int32_t var_18h;
    int32_t var_24h;
    edi = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x14;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    edx = eax + 4;
    *((edx - 4)) = 0x10f7;
    *(edx) = sym.camlHashtbl__replace_bucket_1116;
    *((edx + 4)) = 3;
    *((edx + 8)) = ebx;
    *((edx + 0xc)) = ecx;
    eax = *((edi + 4));
    esi = *((eax - 4));
    esi >>= 0xa;
    if (esi != 0) {
        eax = caml_hash_univ_param (edx, ebx, ecx);
        eax >>= 1;
        ecx = esi;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
    } else {
        eax = caml_bucket_Division_by_zero;
        caml_raise_exn ();
    }
    edx <<= 1;
    edx++;
    *((esp + 0x18)) = edx;
    ebx = *((edi + 4));
    eax = *((ebx - 4));
    eax >>= 9;
    if (eax <= edx) {
        goto label_2;
    }
    eax = *((ebx + edx*2 - 2));
    eax = void (*0x8057e10)(uint32_t) (eax);
    ecx = loc.caml_exn_Not_found;
    ebx = *(eax);
    if (ebx != ecx) {
        goto label_3;
    }
    ebx = *(esp);
    edx = *((ebx + 4));
    eax = *((edx - 4));
    eax >>= 9;
    ecx = *((esp + 0x18));
    if (eax <= ecx) {
        goto label_4;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0xc00;
            eax = *((esp + 4));
            *(esi) = eax;
            eax = *((esp + 8));
            *((esi + 4)) = eax;
            eax = *((esp + 0xc));
            *((esi + 8)) = eax;
            caml_modify (edx + ecx*2 - 2, esi);
            *(ebx) += 2;
            eax = *((ebx + 4));
            eax = *((eax - 4));
            eax >>= 9;
            eax |= 1;
            ecx = eax + eax - 1;
            eax = *(ebx);
            if (eax > ecx) {
                eax = .comment;
                void (*0x80576b0)() ();
            }
            eax = 1;
            return eax;
label_3:
            caml_raise_exn ();
            *(obj.caml_exception_pointer) = esp;
            ebx = *((edi + 4));
            *((esp + 0x1c)) = ebx;
            ebx = *((ebx - 4));
            ebx >>= 9;
            if (ebx <= edx) {
                goto label_5;
            }
            ebx = *((esp + 0x18));
            eax = camlHashtbl_replace_bucket_1116 ();
            ebx = *((esp + 0x20));
            eax = *((esp + 0x24));
            caml_modify (ebx + eax*2 - 2, eax);
            eax = 1;
            return eax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80679ce */
#include <stdint.h>
 
int32_t caml_float_of_substring (void) {
    uint32_t var_5ch;
    int32_t var_58h_3;
    char * * endptr;
    int32_t var_10h;
    int32_t var_58h_2;
    int32_t var_8h;
    int32_t var_ch;
    esi = *((ebp + 0xc));
    esi >>= 1;
    eax = *((ebp + 8));
    eax = caml_string_length (ebx, esi, edi);
    if (esi >= 0) {
        if (eax > esi) {
            ebx = *((ebp + 0x10));
            ebx >>= 1;
            if (ebx <= 0) {
                goto label_0;
            }
            eax -= esi;
            if (ebx > eax) {
                goto label_0;
            }
            if (ebx <= 0x3f) {
                edi = ebp - 0x58;
                goto label_1;
            }
            eax = ebx + 1;
            eax = caml_stat_alloc (eax);
            edi = eax;
        }
    } else {
label_0:
        ebx = 0;
        edi = ebp - 0x58;
    }
label_1:
    eax = *((ebp + 8));
    eax = esi + eax;
    esi = edi;
    while (ebx != 0) {
        edx = *(eax);
        if (dl != 0x5f) {
            *(esi) = dl;
            esi++;
        }
        eax++;
        ebx--;
    }
    *(esi) = 0;
    if (esi != edi) {
        eax = ebp - 0x5c;
        strtod (edi, eax);
        *((ebp - 0x70)) = fp_stack[0];
        fp_stack--;
        if (*((ebp - 0x5c)) != esi) {
            goto label_2;
        }
        eax = ebp - 0x58;
        if (edi != eax) {
            caml_stat_free (edi);
        }
        *(fp_stack--) = *((ebp - 0x70));
        *(esp) = fp_stack[0];
        fp_stack--;
        caml_copy_double ();
        return eax;
    }
label_2:
    eax = ebp - 0x58;
    if (edi != eax) {
        caml_stat_free (edi);
    }
    return caml_failwith ("float_of_string");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80674af */
#include <stdint.h>
 
int32_t caml_atan2_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    atan2 (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a604 */
#include <stdint.h>
 
void atan2 (void) {
    atan2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c1f0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2686 (void) {
    eax = unix_readdir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059520 */
#include <stdint.h>
 
int32_t camlPrintf_parse_1069 (void) {
    do {
label_0:
        edx = eax;
        esi = *((ecx + 0xc));
        eax = *((esi - 4));
        eax >>= 0xa;
        eax = eax*4 - 1;
        esi = *((esi + eax));
        eax -= esi;
        eax = eax + eax + 1;
        if (ebx >= eax) {
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = 1;
            *((eax + 4)) = edx;
            return eax;
        }
        esi = ebx;
        esi >>= 1;
        eax = *((ecx + 0xc));
        eax = *((eax + esi));
        eax = eax + eax + 1;
        if (eax >= 0x63) {
            if (eax >= 0x75) {
                goto label_4;
            }
            esi = *((ecx + 0xc));
            eax = *((esi - 4));
            eax >>= 0xa;
            edx = eax*4 - 1;
            eax = *((esi + edx));
            edx -= eax;
            edx <<= 1;
            edx -= ebx;
            edx -= 3;
            edx += 3;
            eax = *((ecx + 0xc));
            ecx = edx;
            eax = camlString_sub_1046 (edx);
            eax = caml_int_of_string;
            eax = caml_c_call (eax);
            ecx = eax;
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_5;
            }
            ebx = eax + 4;
            *((ebx - 4)) = 0x800;
            *(ebx) = ecx;
            eax = *(esp);
            *((ebx + 4)) = eax;
            eax = ebx;
            return eax;
        }
        if (eax != 0x5b) {
            goto label_4;
        }
        ebx += 2;
        eax = 3;
    } while (1);
label_4:
    ebx += 2;
    eax = edx;
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c97c */
#include <stdint.h>
 
uint32_t unix_chdir (int32_t arg_8h) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x16877;
    esi = *((ebp + 8));
    *(esp) = esi;
    eax = chdir ();
    if (eax == -1) {
        eax = ebx - 0x25f1;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065e39 */
#include <stdint.h>
 
int32_t caml_lessequal (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80806c0) {
        compare_free_stack ();
    }
    dl = (ebx <= 0) ? 1 : 0;
    al = (ebx != 0x80000000) ? 1 : 0;
    eax = (int32_t) al;
    eax &= edx;
    eax += eax;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806bcae */
#include <stdint.h>
 
int32_t caml_sys_close (int32_t fildes) {
    eax = *((ebp + 8));
    eax >>= 1;
    close (eax);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bf10 */
#include <stdint.h>
 
int32_t camlUnix_fun_2604 (void) {
    eax = unix_socketpair;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80549f0 */
#include <stdint.h>
 
int32_t camlList_for_all2_1145 (void) {
    int32_t var_4h;
    int32_t var_8h;
    do {
        edx = eax;
        if (ebx == 1) {
            goto label_0;
        }
        if (ecx == 1) {
            goto label_1;
        }
        eax = *((ecx + 4));
        ecx = *(ecx);
        eax = *((ebx + 4));
        eax = *(ebx);
        ebx = ecx;
        ecx = edx;
        eax = caml_apply2 (edx, eax, eax);
        if (eax == 1) {
            goto label_2;
        }
        eax = *(esp);
        ebx = *((esp + 4));
        ecx = *((esp + 8));
    } while (1);
label_2:
    eax = 1;
    return eax;
label_0:
    if (ecx == 1) {
        eax = 3;
        return eax;
    }
label_1:
    eax = "List.for_all2";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e7dc */
#include <stdint.h>
 
int32_t unix_link (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14a17;
    esi = *((ebp + 0xc));
    *((esp + 4)) = esi;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = link ();
    if (eax == -1) {
        eax = ebx - 0x2468;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a784 */
#include <stdint.h>
 
void link (void) {
    link ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061528 */
#include <stdint.h>
 
int32_t unix_single_write (int32_t arg_ch, int32_t arg_10h, int32_t arg_14h, char * ptr, size_t nbytes) {
    int32_t var_4038h;
    int32_t var_4034h;
    int32_t var_4030h;
    int32_t var_402ch;
    void * s1;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x11cc5;
    eax = *((ebx - 0x18));
    edx = *(eax);
    *((ebp - 0x4038)) = edx;
    edx = ebp - 0x4038;
    *(eax) = edx;
    *((ebp - 0x4030)) = 1;
    *((ebp - 0x4034)) = 1;
    eax = ebp + 0xc;
    *((ebp - 0x402c)) = eax;
    esi = *((ebp + 0x14));
    esi >>= 1;
    if (esi > 0) {
        eax = 0x4000;
        if (esi > 0x4000) {
            esi = eax;
        }
        eax = *((ebp + 0x10));
        eax >>= 1;
        eax += *((ebp + 0xc));
        edi = ebp - 0x4018;
        memmove (edi, eax, esi);
        caml_enter_blocking_section ();
        eax = *((ebp + 8));
        eax >>= 1;
        eax = write (eax, edi, esi);
        esi = eax;
        caml_leave_blocking_section ();
        if (esi != -1) {
            goto label_0;
        }
        eax = ebx - 0x2161;
        uerror (eax, 0);
    }
    esi = 0;
label_0:
    edx = *((ebp - 0x4038));
    eax = *((ebx - 0x18));
    *(eax) = edx;
    eax = esi + esi + 1;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a004 */
#include <stdint.h>
 
void write (void) {
    write ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8060094 */
#include <stdint.h>
 
uint32_t unix_socketpair (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_10h;
    int32_t var_bp_ch;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x13164;
    eax = ebp - 0x10;
    *((esp + 0xc)) = eax;
    eax = *((ebp + 0x10));
    eax >>= 1;
    *((esp + 8)) = eax;
    edx = *((ebp + 0xc));
    edx >>= 1;
    eax = *((ebx - 0x1c));
    eax = *((eax + edx*4));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    edx >>= 1;
    eax = *((ebx - 0x20));
    eax = *((eax + edx*4));
    *(esp) = eax;
    eax = socketpair ();
    if (eax == -1) {
        eax = ebx - 0x23c5;
        uerror (eax, 0);
    }
    caml_alloc_small (2, 0);
    edx = *((ebp - 0x10));
    edx = edx + edx + 1;
    *(eax) = edx;
    edx = *((ebp - 0xc));
    edx = edx + edx + 1;
    *((eax + 4)) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049fa4 */
#include <stdint.h>
 
void socketpair (void) {
    socketpair ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805eb7c */
#include <stdint.h>
 
int32_t unix_mkdir (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    _i686_get_pc_thunk_bx ();
    ebx += 0x14677;
    esi = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = esi;
    eax = mkdir ();
    if (eax == -1) {
        eax = ebx - 0x24a4;
        uerror (eax, esi);
    }
    eax = 1;
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049e74 */
#include <stdint.h>
 
void mkdir (void) {
    mkdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806cdbd */
#include <stdint.h>
 
uint32_t caml_gc_counters (void) {
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0xc)) = 0;
    *((ebp - 0x2c)) = ebx;
    eax = ebp - 0x2c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x24)) = 1;
    *((ebp - 0x28)) = 1;
    eax = ebp - 0xc;
    *((ebp - 0x20)) = eax;
    eax = caml_young_end;
    eax -= *(obj.caml_young_ptr);
    eax >>= 2;
    edx = 0;
    *((ebp - 0x40)) = eax;
    *((ebp - 0x3c)) = edx;
    *(fp_stack--) = *((ebp - 0x40));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *((ebp - 0x58)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_stat_promoted_words);
    *((ebp - 0x50)) = fp_stack[0];
    fp_stack--;
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x40)) = eax;
    *((ebp - 0x3c)) = edx;
    *(fp_stack--) = *((ebp - 0x40));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *((ebp - 0x48)) = fp_stack[0];
    fp_stack--;
    eax = caml_alloc_tuple (ebx);
    *((ebp - 0xc)) = eax;
    *(fp_stack--) = *((ebp - 0x58));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0xc));
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x50));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0xc));
    eax += 4;
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x48));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0xc));
    eax += 8;
    caml_modify (eax, eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0xc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058820 */
#include <stdint.h>
 
int32_t camlBuffer_reset_1064 (void) {
    ebx = eax;
    *((ebx + 4)) = 1;
    caml_modify (ebx, *((ebx + 0xc)));
    ecx = *(ebx);
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ecx = *((ecx + eax));
    eax -= ecx;
    eax = eax + eax + 1;
    *((ebx + 8)) = eax;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805e538 */
#include <stdint.h>
 
int32_t unix_initgroups (int32_t arg_8h, int32_t arg_ch) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x14cc0;
    eax = *((ebp + 0xc));
    eax >>= 1;
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = initgroups ();
    if (eax == -1) {
        eax = ebx - 0x24f4;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a564 */
#include <stdint.h>
 
void initgroups (void) {
    initgroups ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805c670 */
#include <stdint.h>
 
int32_t loc_camlCallback_code_begin (void) {
    eax = caml_register_named_value;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8051260 */
#include <stdint.h>
 
uint32_t camlArray_trickle_1165 (void) {
    int32_t var_4h_2;
    eax = void (*0x80512f0)(uint32_t, uint32_t) (edx, ecx);
    ecx = .comment;
    ebx = *(eax);
    if (ebx == ecx) {
        ebx = *((eax + 4));
        eax = *(esp);
        eax = *((eax + 0xc));
        ecx = *((eax - 4));
        edx = *((eax - 4));
        edx &= 0xff;
        if (edx != 0xfe) {
            ecx >>= 9;
            if (ecx <= ebx) {
                goto label_0;
            }
            ecx = *((esp + 4));
            caml_modify (eax + ebx*2 - 2, ecx);
        } else {
            ecx >>= 0xa;
            if (ecx <= ebx) {
                goto label_1;
            }
            ecx = *((esp + 4));
            *(fp_stack--) = *(ecx);
            *((eax + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        eax = 1;
        return eax;
    }
    caml_raise_exn ();
    *(obj.caml_exception_pointer) = esp;
    edx = *((edx + 0x10));
    camlArray_trickledown_1160 (*(obj.caml_exception_pointer));
    return eax;
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bef0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2600 (void) {
    eax = unix_bind;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d930 */
#include <stdint.h>
 
int32_t camlUnix_open_process_out_1962 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *(esp) = ebx;
    eax = *(eax);
    *((esp + 8)) = eax;
    eax = caml_ml_open_descriptor_out;
    eax = caml_c_call (ebx);
    ecx = eax;
    *((esp + 0xc)) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0x800;
            eax = *(esp);
            *(esi) = eax;
            *((esi + 4)) = 1;
            ebx = esi + 0xc;
            *((ebx - 4)) = 0x402;
            *(ebx) = ecx;
            edx = 3;
            eax = *((esp + 4));
            ecx = *((esp + 8));
            camlUnix_open_proc_1949 ();
            eax = *((esp + 8));
            eax = unix_close;
            caml_c_call (eax);
            eax = *((esp + 0xc));
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80674d5 */
#include <stdint.h>
 
int32_t caml_atan_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    atan (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a1d4 */
#include <stdint.h>
 
void atan (void) {
    atan ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806ceac */
#include <stdint.h>
 
uint32_t caml_gc_quick_stat (void) {
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_1ch;
    int32_t var_4h;
    ebx = caml_local_roots;
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x3c)) = ebx;
    eax = ebp - 0x3c;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x34)) = 1;
    *((ebp - 0x38)) = 1;
    eax = ebp - 0x1c;
    *((ebp - 0x30)) = eax;
    eax = caml_young_end;
    eax -= *(obj.caml_young_ptr);
    eax >>= 2;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_minor_words);
    *((ebp - 0x78)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.caml_stat_promoted_words);
    *((ebp - 0x70)) = fp_stack[0];
    fp_stack--;
    eax = caml_allocated_words;
    edx = 0;
    *((ebp - 0x50)) = eax;
    *((ebp - 0x4c)) = edx;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack[0] += *(obj.caml_stat_major_words);
    *((ebp - 0x68)) = fp_stack[0];
    fp_stack--;
    esi = caml_stat_minor_collections;
    edi = caml_stat_major_collections;
    eax = caml_stat_heap_size;
    eax >>= 2;
    *((ebp - 0x60)) = eax;
    eax = caml_stat_top_heap_size;
    eax >>= 2;
    *((ebp - 0x5c)) = eax;
    eax = caml_stat_compactions;
    *((ebp - 0x58)) = eax;
    edx = caml_stat_heap_chunks;
    *((ebp - 0x54)) = edx;
    eax = caml_alloc_tuple (ebx, esi, edi);
    *((ebp - 0x1c)) = eax;
    *(fp_stack--) = *((ebp - 0x78));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x70));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 4;
    caml_modify (eax, eax);
    *(fp_stack--) = *((ebp - 0x68));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = caml_copy_double ();
    eax = *((ebp - 0x1c));
    eax += 8;
    caml_modify (eax, eax);
    eax = esi + esi + 1;
    eax = *((ebp - 0x1c));
    eax += 0xc;
    caml_modify (eax, eax);
    eax = edi + edi + 1;
    eax = *((ebp - 0x1c));
    eax += 0x10;
    caml_modify (eax, eax);
    edx = *((ebp - 0x60));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x14;
    caml_modify (eax, eax);
    edx = *((ebp - 0x54));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x18;
    caml_modify (eax, eax);
    eax = *((ebp - 0x1c));
    eax += 0x1c;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x20;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x24;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x28;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x2c;
    caml_modify (eax, 1);
    eax = *((ebp - 0x1c));
    eax += 0x30;
    caml_modify (eax, 1);
    edx = *((ebp - 0x58));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x34;
    caml_modify (eax, eax);
    edx = *((ebp - 0x5c));
    eax = edx + edx + 1;
    eax = *((ebp - 0x1c));
    eax += 0x38;
    caml_modify (eax, eax);
    caml_stack_usage ();
    eax = eax + eax + 1;
    eax = *((ebp - 0x1c));
    eax += 0x3c;
    caml_modify (eax, eax);
    *(obj.caml_local_roots) = ebx;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804b190 */
#include <stdint.h>
 
int32_t caml_curry5_3 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x10f7;
            *(eax) = sym.caml_curry5_4;
            *((eax + 4)) = 3;
            *((eax + 8)) = ecx;
            *((eax + 0xc)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d890 */
#include <stdint.h>
 
int32_t camlUnix_open_process_in_1957 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    *((esp + 4)) = eax;
    eax = unix_pipe;
    eax = caml_c_call (1);
    ebx = *((eax + 4));
    *((esp + 8)) = ebx;
    eax = *(eax);
    *(esp) = eax;
    eax = caml_ml_open_descriptor_in;
    eax = caml_c_call (eax);
    ecx = eax;
    *((esp + 0xc)) = ecx;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            esi = eax + 4;
            *((esi - 4)) = 0x800;
            eax = *(esp);
            *(esi) = eax;
            *((esi + 4)) = 1;
            ebx = esi + 0xc;
            *((ebx - 4)) = 0x401;
            *(ebx) = ecx;
            ecx = 1;
            eax = *((esp + 4));
            edx = *((esp + 8));
            camlUnix_open_proc_1949 ();
            eax = *((esp + 8));
            eax = unix_close;
            caml_c_call (eax);
            eax = *((esp + 0xc));
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8050130 */
#include <stdint.h>
 
int32_t camlPervasives_read_float_1290 (void) {
    eax = 1;
    eax = camlPervasives_read_line_1288 ();
    eax = caml_float_of_string;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067492 */
#include <stdint.h>
 
int32_t caml_ceil_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    ceil (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8051470 */
#include <stdint.h>
 
int32_t camlArray_trickleup_1178 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch_2;
    do {
        esi = eax;
        edi = ecx;
        ecx = 3;
        eax = esi;
        eax += 0xfffffffe;
        eax >>= 1;
        edx:eax = (int64_t) eax;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        ecx = eax + eax + 1;
        if (esi != ecx) {
            *((esp + 0xc)) = ecx;
            *(esp) = edi;
            *((esp + 4)) = ebx;
            *((esp + 8)) = esi;
        } else {
label_2:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_3;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = "L6\a\b";
            *((eax + 4)) = 0x8077894;
            caml_raise_exn ();
        }
        edx = *((edi + 0x10));
        eax = *((edx - 4));
        esi = *((edx - 4));
        esi &= 0xff;
        if (esi != 0xfe) {
            eax >>= 9;
            if (eax <= ecx) {
                goto label_4;
            }
            eax = *((edx + ecx*2 - 2));
        } else {
            eax >>= 0xa;
            if (eax <= ecx) {
                goto label_5;
            }
label_1:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_6;
            }
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *((edx + ecx*4 - 4));
            *(eax) = fp_stack[0];
            fp_stack--;
        }
        ecx = *((edi + 0xc));
        eax = caml_apply2 ();
        if (eax >= 1) {
            goto label_7;
        }
        edi = *(esp);
        ebx = *((edi + 0x10));
        eax = *((ebx - 4));
        ecx = *((ebx - 4));
        ecx &= 0xff;
        if (ecx != 0xfe) {
            eax >>= 9;
            esi = *((esp + 0xc));
            if (eax <= esi) {
                goto label_8;
            }
            ecx = *((ebx + esi*2 - 2));
        } else {
            eax >>= 0xa;
            esi = *((esp + 0xc));
            if (eax <= esi) {
                goto label_9;
            }
label_0:
            eax = caml_young_ptr;
            eax -= 0xc;
            *(obj.caml_young_ptr) = eax;
            if (eax < *(obj.caml_young_limit)) {
                goto label_10;
            }
            ecx = eax + 4;
            *((ecx - 4)) = 0x8fd;
            *(fp_stack--) = *((ebx + esi*4 - 4));
            *(ecx) = fp_stack[0];
            fp_stack--;
        }
        eax = *((edi + 0x10));
        edx = *((eax - 4));
        ebx = *((eax - 4));
        ebx &= 0xff;
        if (ebx != 0xfe) {
            edx >>= 9;
            ebx = *((esp + 8));
            if (edx <= ebx) {
                goto label_11;
            }
            caml_modify (eax + ebx*2 - 2, ecx);
        } else {
            edx >>= 0xa;
            ebx = *((esp + 8));
            if (edx <= ebx) {
                goto label_12;
            }
            *(fp_stack--) = *(ecx);
            *((eax + ebx*4 - 4)) = fp_stack[0];
            fp_stack--;
        }
        if (esi <= 1) {
            goto label_13;
        }
        eax = esi;
        ebx = *((esp + 4));
        ecx = edi;
    } while (1);
label_13:
    ecx = *((edi + 0x10));
    ebx = *((ecx - 4));
    eax = *((ecx - 4));
    eax &= 0xff;
    if (eax != 0xfe) {
        eax = ebx;
        eax >>= 9;
        if (eax <= 1) {
            goto label_14;
        }
        eax = *((esp + 4));
        caml_modify (ecx, eax);
    } else {
        eax = ebx;
        eax >>= 0xa;
        if (eax <= 1) {
            goto label_15;
        }
        eax = *((esp + 4));
        *(fp_stack--) = *(eax);
        *(ecx) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_7:
    eax = *(esp);
    eax = *((eax + 0x10));
    ebx = *((eax - 4));
    ecx = *((eax - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        ebx >>= 9;
        ecx = *((esp + 8));
        if (ebx <= ecx) {
            goto label_16;
        }
        ebx = *((esp + 4));
        caml_modify (eax + ecx*2 - 2, ebx);
    } else {
        ebx >>= 0xa;
        ecx = *((esp + 8));
        if (ebx <= ecx) {
            goto label_17;
        }
        ebx = *((esp + 4));
        *(fp_stack--) = *(ebx);
        *((eax + ecx*4 - 4)) = fp_stack[0];
        fp_stack--;
    }
    eax = 1;
    return eax;
label_10:
    caml_call_gc ();
    goto label_0;
label_6:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
label_17:
    caml_ml_array_bound_error ();
label_16:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8062a93 */
#include <stdint.h>
 
uint32_t caml_execute_signal (int32_t arg_8h, uint32_t arg_ch) {
    int32_t var_98h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = ebp - 0x98;
    *(esp) = esi;
    sigemptyset ();
    *((esp + 4)) = ebx;
    *(esp) = esi;
    sigaddset ();
    *((esp + 8)) = esi;
    *((esp + 4)) = esi;
    *(esp) = 0;
    sigprocmask ();
    caml_rev_convert_signal_number (ebx);
    eax = eax + eax + 1;
    eax = caml_signal_handlers;
    eax = *((eax + ebx*4));
    eax = caml_callback_exn (eax, eax);
    edi = eax;
    if (*((ebp + 0xc)) == 0) {
        *((esp + 8)) = 0;
        *((esp + 4)) = esi;
        *(esp) = 2;
        sigprocmask ();
        eax = edi;
        eax &= 3;
        if (eax != 2) {
            goto label_0;
        }
    } else {
        eax &= 3;
        if (eax != 2) {
            goto label_0;
        }
        *((esp + 4)) = ebx;
        eax = ebp - 0x98;
        *(esp) = eax;
        sigdelset ();
        *((esp + 8)) = 0;
        *((esp + 4)) = esi;
        *(esp) = 2;
        sigprocmask ();
    }
    edi &= 0xfffffffc;
    caml_raise (edi);
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c280 */
#include <stdint.h>
 
int32_t camlUnix_fun_2704 (void) {
    eax = unix_clear_nonblock;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804aed0 */
#include <stdint.h>
 
int32_t caml_curry7_6 (void) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *((esp + 4)) = eax;
    esi = ebx;
    eax = *((esi + 0xc));
    ecx = *((eax + 0xc));
    edi = *((ecx + 0xc));
    ebp = *((edi + 0xc));
    ebx = *((ebp + 0xc));
    edx = *((ebx + 0xc));
    *((esp + 8)) = edx;
    esi = *((esi + 8));
    *(esp) = esi;
    eax = *((eax + 8));
    *((esp + 0x10)) = eax;
    esi = *((ecx + 8));
    ecx = *((edi + 8));
    edi = *((ebp + 8));
    eax = *((ebx + 8));
    ebx = *((edx + 8));
    *((esp + 0xc)) = ebx;
    ebx = edi;
    edx = esi;
    esi = *((esp + 0x10));
    edi = *(esp);
    ebp = *((esp + 4));
    *(loc.caml_extra_params) = ebp;
    ebp = *((esp + 8));
    *(0x807cb20) = ebp;
    ebp = *((esp + 0xc));
    return void (*ebp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8069211 */
#include <stdint.h>
 
uint32_t caml_really_putblock (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    if (ebx <= 0) {
        goto label_0;
    }
    do {
        eax = caml_putblock (edi, esi, ebx);
        esi += eax;
        ebx -= eax;
    } while (ebx > 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805d6bc */
#include <stdint.h>
 
uint32_t unix_geteuid (void) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x15b3c;
    geteuid ();
    eax = eax + eax + 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a8f4 */
#include <stdint.h>
 
void geteuid (void) {
    geteuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80671f6 */
#include <stdint.h>
 
int32_t caml_ge_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806b4b7 */
#include <stdint.h>
 
uint32_t caml_input_value_from_malloc (int32_t arg_8h, int32_t arg_ch) {
    edx = *((ebp + 8));
    *(obj.intern_input) = edx;
    edx += *((ebp + 0xc));
    *(obj.intern_input_malloced) = 1;
    eax = edx + 4;
    *(obj.intern_src) = eax;
    ecx = *((eax - 1));
    edx = *(edx);
    edx <<= 0x18;
    edx = ecx + edx;
    ecx = *((eax - 3));
    ecx <<= 0x10;
    edx += ecx;
    ecx = *((eax - 2));
    ecx <<= 8;
    edx += ecx;
    if (edx != 0x8495a6be) {
        eax = caml_failwith ("input_value_from_malloc: bad object");
    }
    eax += 4;
    *(obj.intern_src) = eax;
    eax = input_val_from_block ();
    ebx = eax;
    eax = intern_input;
    caml_stat_free (eax);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fa50 */
#include <stdint.h>
 
int32_t camlPervasives_valid_float_lexem_1135 (void) {
    ecx = eax;
    eax = *((ecx - 4));
    eax >>= 0xa;
    eax = eax*4 - 1;
    ebx = *((ecx + eax));
    eax -= ebx;
    edx = eax + eax + 1;
    do {
        eax = caml_young_ptr;
        eax -= 0x14;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0x10f7;
            *(ebx) = loc.camlPervasives__code_begin;
            *((ebx + 4)) = 3;
            *((ebx + 8)) = ecx;
            *((ebx + 0xc)) = edx;
            eax = 1;
            void (*0x804f360)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c260 */
#include <stdint.h>
 
int32_t camlUnix_fun_2700 (void) {
    eax = unix_clear_close_on_exec;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8058770 */
#include <stdint.h>
 
int32_t camlBuffer_blit_1051 (void) {
    if (esi >= 1) {
        if (ebx < 1) {
            goto label_0;
        }
        edi = *((eax + 4));
        edi -= esi;
        edi++;
        if (ebx > edi) {
            goto label_0;
        }
        if (edx < 1) {
            goto label_0;
        }
        edi = *((ecx - 4));
        edi >>= 0xa;
        ebp = edi*4 - 1;
        edi = *((ecx + ebp));
        ebp -= edi;
        edi = ebp;
        edi <<= 1;
        edi -= esi;
        edi += 2;
        if (edx > edi) {
            goto label_0;
        }
        eax = *(eax);
        void (*0x80558d0)() ();
    }
label_0:
    eax = "Buffer.blit";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805b440 */
#include <stdint.h>
 
uint32_t camlPrintf_incomplete_format_1065 (void) {
    ebx = *((eax - 4));
    ebx >>= 0xa;
    ebx = ebx*4 - 1;
    ecx = *((eax + ebx));
    ebx -= ecx;
    ecx = ebx + ebx + 1;
    ebx = 1;
    camlString_sub_1046 ();
    ebx = camlPrintf__48;
    eax = camlPervasives_$5e_1112 ();
    ebx = eax;
    eax = "Printf: premature end of format string ``";
    camlPervasives_$5e_1112 ();
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806fb2a */
#include <stdint.h>
 
int32_t caml_find_custom_operations (int32_t arg_8h) {
    char * s2;
    edi = *((ebp + 8));
    ebx = custom_ops_table;
    if (ebx == 0) {
        goto label_0;
    }
    do {
        esi = *(ebx);
        eax = *(esi);
        eax = strcmp (eax, edi);
        if (eax == 0) {
            goto label_1;
        }
        ebx = *((ebx + 4));
    } while (ebx != 0);
label_0:
    esi = 0;
label_1:
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8061b6c */
#include <stdint.h>
 
int32_t main (char ** envp) {
    eax = *((ebp + 0xc));
    caml_main (eax);
    return caml_sys_exit (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x806074d */
#include <stdint.h>
 
uint32_t unix_fstat (int32_t arg_8h) {
    int32_t var_68h;
    int32_t var_58h;
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x12aab;
    eax = ebp - 0x68;
    *((esp + 8)) = eax;
    eax = *((ebp + 8));
    eax >>= 1;
    *((esp + 4)) = eax;
    *(esp) = 3;
    eax = fxstat64 ();
    if (eax == -1) {
        eax = ebx - 0x231e;
        uerror (eax, 0);
    }
    if (*((ebp - 0x38)) >= 0) {
        if (*((ebp - 0x38)) <= 0) {
            if (*((ebp - 0x3c)) <= 0x3fffffff) {
                goto label_0;
            }
        }
        eax = *((ebp - 0x58));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        eax = ebx - 0x231e;
        unix_error (0x4b, eax, 0);
    }
label_0:
    edx = ebp - 0x68;
    eax = 0;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049d84 */
#include <stdint.h>
 
void init (void) {
    /* [11] -r-x section size 48 named .init */
    void (*0x8049d90)(uint32_t) (ebx);
    ebx += 0x29474;
    edx = *((ebx - 0x24));
    if (edx != 0) {
        gmon_start_ ();
    }
    frame_dummy ();
    _do_global_ctors_aux ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049f14 */
#include <stdint.h>
 
void loc_imp_gmon_start_ (void) {
    gmon_start_ ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8067583 */
#include <stdint.h>
 
int32_t caml_cos_float (int32_t arg_8h) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    *(esp) = fp_stack[0];
    fp_stack--;
    cos (ebp);
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a3c4 */
#include <stdint.h>
 
void cos (void) {
    cos ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804bd00 */
#include <stdint.h>
 
int32_t camlUnix_fun_2833 (void) {
    ecx = eax;
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x800;
            *(eax) = ecx;
            ebx = *((ebx + 8));
            ebx = *(ebx);
            *((eax + 4)) = ebx;
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8051d50 */
#include <stdint.h>
 
int32_t camlArray_make_matrix_1042 (void) {
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    *(esp) = eax;
    *((esp + 8)) = ebx;
    *((esp + 4)) = ecx;
    eax = caml_make_vect;
    eax = caml_c_call (eax);
    ebx = eax;
    ecx = 1;
    eax = *(esp);
    eax += 0xfffffffe;
    if (ecx > eax) {
        goto label_0;
    }
    *((esp + 0x10)) = eax;
    *(esp) = ecx;
    *((esp + 0xc)) = ebx;
    do {
        eax = *((esp + 4));
        eax = *((esp + 0xc));
        eax = caml_make_vect;
        eax = caml_c_call (eax);
        esi = *((esp + 4));
        ebx = *((esp + 0x10));
        caml_modify (ebx + esi*2 - 2, eax);
        ecx = esi;
        esi += 2;
        *(esp) = esi;
        eax = *((esp + 0x10));
    } while (ecx != eax);
label_0:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80700e7 */
#include <stdint.h>
 
int32_t caml_get_exception_backtrace (void) {
    int32_t var_6ch;
    uint32_t var_60h;
    uint32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    eax = caml_local_roots;
    *((ebp - 0x6c)) = eax;
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x28)) = 0;
    *((ebp - 0x48)) = eax;
    eax = ebp - 0x48;
    *(obj.caml_local_roots) = eax;
    *((ebp - 0x40)) = 1;
    *((ebp - 0x44)) = 4;
    eax = ebp - 0x1c;
    *((ebp - 0x3c)) = eax;
    eax = ebp - 0x20;
    *((ebp - 0x38)) = eax;
    eax = ebp - 0x24;
    *((ebp - 0x34)) = eax;
    eax = ebp - 0x28;
    *((ebp - 0x30)) = eax;
    eax = caml_backtrace_pos;
    eax = caml_alloc (ebx, esi, edi);
    *((ebp - 0x20)) = eax;
    if (*(obj.caml_backtrace_pos) <= 0) {
        goto label_0;
    }
    ebx = 0;
    edi = ebp - 0x60;
    do {
        esi = ebx*4;
        eax = caml_backtrace_buffer;
        eax = *((eax + esi));
        edx = edi;
        extract_location_info ();
        if (*((ebp - 0x60)) != 0) {
            eax = *((ebp - 0x58));
            eax = caml_copy_string (eax);
            *((ebp - 0x28)) = eax;
            eax = caml_alloc_small (5, 0);
            edx -= edx;
            edx &= 0xfffffffe;
            edx += 3;
            *((ebp - 0x24)) = eax;
            *(eax) = edx;
            edx = *((ebp - 0x28));
            eax = *((ebp - 0x24));
            *((eax + 4)) = edx;
            eax = *((ebp - 0x54));
            edx = eax + eax + 1;
            eax = *((ebp - 0x24));
            *((eax + 8)) = edx;
            eax = *((ebp - 0x50));
            edx = eax + eax + 1;
            eax = *((ebp - 0x24));
            *((eax + 0xc)) = edx;
            eax = *((ebp - 0x4c));
            edx = eax + eax + 1;
            eax = *((ebp - 0x24));
            *((eax + 0x10)) = edx;
        } else {
            eax = caml_alloc_small (1, 1);
            edx -= edx;
            edx &= 0xfffffffe;
            edx += 3;
            *((ebp - 0x24)) = eax;
            *(eax) = edx;
        }
        eax = *((ebp - 0x24));
        esi += *((ebp - 0x20));
        caml_modify (esi, eax);
        ebx++;
    } while (*(obj.caml_backtrace_pos) > ebx);
label_0:
    eax = caml_alloc_small (1, 0);
    *((ebp - 0x1c)) = eax;
    edx = *((ebp - 0x20));
    *(eax) = edx;
    eax = *((ebp - 0x6c));
    *(obj.caml_local_roots) = eax;
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8059bc0 */
#include <stdint.h>
 
int32_t camlPrintf_add_char_1166 (void) {
    eax = *((ecx + 0xc));
    camlBuffer_add_char_1072 (eax);
    eax = *(esp);
    eax += 2;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80593c0 */
#include <stdint.h>
 
int32_t camlPrintf_cont_a_1362 (void) {
    int32_t var_4h;
    int32_t var_8h;
    *(esp) = eax;
    edi = ebx;
    ebx = ecx;
    *((esp + 4)) = edx;
    *((esp + 8)) = esi;
    eax = *((esi + 0x3c));
    if (eax != 1) {
        eax = 1;
        ecx = edi;
        eax = caml_apply2 ();
        ebx = eax;
        eax = *((esp + 8));
        ecx = *((eax + 0x44));
        eax = *((eax + 0x4c));
        caml_apply2 ();
    } else {
        eax = *((esi + 0x4c));
        ecx = edi;
        caml_apply2 ();
    }
    ecx = *((esp + 8));
    ecx += 0xffffffe0;
    eax = *(esp);
    ebx = *((esp + 4));
    return camlPrintf_doprn_1360 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804fbe0 */
#include <stdint.h>
 
int32_t camlPervasives_output_1194 (void) {
    if (ecx >= 1) {
        if (edx < 1) {
            goto label_0;
        }
        esi = *((ebx - 4));
        esi >>= 0xa;
        esi = esi*4 - 1;
        edi = *((ebx + esi));
        esi -= edi;
        esi <<= 1;
        esi -= edx;
        esi += 2;
        if (ecx > esi) {
            goto label_0;
        }
        eax = caml_ml_output;
        caml_c_call (eax);
        return eax;
    }
label_0:
    eax = "output";
    return camlPervasives_invalid_arg_1012 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070040 */
#include <stdint.h>
 
int32_t caml_backtrace_status (void) {
    eax -= eax;
    eax &= 0xfffffffe;
    eax += 3;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804c1d0 */
#include <stdint.h>
 
int32_t camlUnix_fun_2682 (void) {
    eax = unix_closedir;
    caml_c_call (eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805deba */
#include <stdint.h>
 
int32_t unix_getprotobynumber (int32_t arg_8h) {
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1533e;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = getprotobynumber ();
    if (eax == 0) {
        caml_raise_not_found ();
    }
    alloc_proto_entry ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a1f4 */
#include <stdint.h>
 
void getprotobynumber (void) {
    getprotobynumber ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x805f8cc */
#include <stdint.h>
 
int32_t unix_setgid (int32_t arg_8h) {
    int32_t var_4h;
    _i686_get_pc_thunk_bx (ebx);
    ebx += 0x1392c;
    eax = *((ebp + 8));
    eax >>= 1;
    *(esp) = eax;
    eax = setgid ();
    if (eax == -1) {
        eax = ebx - 0x242b;
        uerror (eax, 0);
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a7c4 */
#include <stdint.h>
 
void setgid (void) {
    setgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8053320 */
#include <stdint.h>
 
int32_t camlArray_stable_sort_1188 (void) {
    int32_t var_4h_2;
    int32_t var_8h_2;
    int32_t var_ch;
    int32_t var_10h_2;
    int32_t var_14h_2;
    ecx = eax;
label_0:
    eax = caml_young_ptr;
    eax -= 0x4c;
    *(obj.caml_young_ptr) = eax;
    if (eax < *(obj.caml_young_limit)) {
        goto label_1;
    }
    eax = eax + 4;
    *((eax - 4)) = 0x14f7;
    *(eax) = sym.caml_curry7;
    *((eax + 4)) = 0xf;
    *((eax + 8)) = 0x8051740;
    *((eax + 0xc)) = ecx;
    *((eax + 0x10)) = ebx;
    esi = eax + 0x18;
    *((esi - 4)) = 0x14f7;
    *(esi) = sym.caml_curry4;
    *((esi + 4)) = 9;
    *((esi + 8)) = 0x80518d0;
    *((esi + 0xc)) = ecx;
    *((esi + 0x10)) = ebx;
    ecx = eax + 0x30;
    *((ecx - 4)) = 0x18f7;
    *(ecx) = sym.caml_curry4;
    *((ecx + 4)) = 9;
    *((ecx + 8)) = 0x8051bd0;
    *((ecx + 0xc)) = ebx;
    *((ecx + 0x10)) = eax;
    *((ecx + 0x14)) = esi;
    edx = *((ebx - 4));
    edi = *((ebx - 4));
    edi &= 0xff;
    if (edi != 0xfe) {
        edx >>= 9;
    } else {
        edx >>= 0xa;
    }
    edx |= 1;
    if (edx <= 0xb) {
        ecx = 1;
        eax = 1;
        void (*0x80518d0)() ();
    }
    *(esp) = ecx;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = ebx;
    eax = edx;
    eax >>= 1;
    if (eax < 0) {
        eax++;
    }
    eax >>= 1;
    eax = eax + eax + 1;
    *((esp + 8)) = eax;
    edx -= eax;
    edx++;
    *((esp + 4)) = edx;
    eax = *((ebx - 4));
    ecx = *((ebx - 4));
    ecx &= 0xff;
    if (ecx != 0xfe) {
        eax >>= 9;
        if (eax <= 1) {
            goto label_2;
        }
        eax = *(ebx);
        goto label_3;
    }
    eax >>= 0xa;
    if (eax <= 1) {
        goto label_4;
    }
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x8fd;
            *(fp_stack--) = *(ebx);
            *(eax) = fp_stack[0];
            fp_stack--;
label_3:
            eax = caml_make_vect;
            eax = caml_c_call (edx);
            ebx = eax;
            ecx = 1;
            eax = *((esp + 8));
            edx = *((esp + 4));
            esi = *(esp);
            camlArray_sortto_1217 (ebx);
            eax = 1;
            ebx = *((esp + 0x10));
            ecx = *((esp + 4));
            edx = *((esp + 8));
            esi = *(esp);
            camlArray_sortto_1217 ();
            edx = 1;
            eax = *((esp + 4));
            ebx = *((esp + 8));
            ecx = *((esp + 0xc));
            esi = eax;
            edi = *((esp + 0x10));
            *(loc.caml_extra_params) = ebp;
            ebp = *((esp + 0x14));
            *(0x807cb20) = ebp;
            void (*0x8051740)() ();
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_ml_array_bound_error ();
label_2:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8065e81 */
#include <stdint.h>
 
int32_t caml_lessthan (int32_t arg_8h, int32_t arg_ch) {
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = compare_val (ebx);
    ebx = eax;
    if (*(obj.compare_stack) != 0x80806c0) {
        eax = compare_free_stack ();
    }
    ebx += 0x7fffffff;
    eax -= eax;
    eax &= 2;
    eax++;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80677fa */
#include <stdint.h>
 
int32_t caml_fmod_float (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 8));
    *(fp_stack--) = *(eax);
    eax = *((ebp + 0xc));
    *(fp_stack--) = *(eax);
    *(fp_stack--) = fp_stack[0];
    *(fp_stack--) = fp_stack[2];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (? == ?);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_0;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_1;
label_0:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_1:
    *(esp) = fp_stack[0];
    fp_stack--;
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049e14 */
#include <stdint.h>
 
void inet_ntop (void) {
    inet_ntop ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049e54 */
#include <stdint.h>
 
void setgroups (void) {
    setgroups ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049e84 */
#include <stdint.h>
 
void strerror (void) {
    strerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049ea4 */
#include <stdint.h>
 
void memcmp (void) {
    memcmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049ec4 */
#include <stdint.h>
 
void freeaddrinfo (void) {
    freeaddrinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049f04 */
#include <stdint.h>
 
void sigismember (void) {
    sigismember ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049f44 */
#include <stdint.h>
 
void isoc99_sscanf (void) {
    isoc99_sscanf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049f74 */
#include <stdint.h>
 
void cfgetispeed (void) {
    cfgetispeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049f94 */
#include <stdint.h>
 
void strtod (void) {
    strtod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049fe4 */
#include <stdint.h>
 
void system (void) {
    system ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a0f4 */
#include <stdint.h>
 
void tcgetattr (void) {
    tcgetattr ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a1b4 */
#include <stdint.h>
 
void inet_pton (void) {
    inet_pton ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a244 */
#include <stdint.h>
 
void fflush (void) {
    fflush ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a274 */
#include <stdint.h>
 
void gethostbyaddr_r (void) {
    gethostbyaddr_r ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a2f4 */
#include <stdint.h>
 
void getaddrinfo (void) {
    getaddrinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a354 */
#include <stdint.h>
 
void readdir64 (void) {
    readdir64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a374 */
#include <stdint.h>
 
void memcpy (void) {
    memcpy ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a384 */
#include <stdint.h>
 
void cfsetospeed (void) {
    cfsetospeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a394 */
#include <stdint.h>
 
void utime (void) {
    utime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a444 */
#include <stdint.h>
 
void sigdelset (void) {
    sigdelset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a454 */
#include <stdint.h>
 
void h_errno_location (void) {
    h_errno_location ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a504 */
#include <stdint.h>
 
void select (void) {
    select ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a664 */
#include <stdint.h>
 
void sigaddset (void) {
    sigaddset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a694 */
#include <stdint.h>
 
void cfgetospeed (void) {
    cfgetospeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a6b4 */
#include <stdint.h>
 
void strcat (void) {
    strcat ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a6f4 */
#include <stdint.h>
 
void gethostbyname_r (void) {
    gethostbyname_r ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a704 */
#include <stdint.h>
 
void fork (void) {
    fork ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a724 */
#include <stdint.h>
 
void setsockopt (void) {
    setsockopt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a734 */
#include <stdint.h>
 
void tcsetattr (void) {
    tcsetattr ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a744 */
#include <stdint.h>
 
void fcntl (void) {
    fcntl ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a774 */
#include <stdint.h>
 
void getgroups (void) {
    getgroups ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a7b4 */
#include <stdint.h>
 
void getsockopt (void) {
    getsockopt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a864 */
#include <stdint.h>
 
void strcmp (void) {
    strcmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a874 */
#include <stdint.h>
 
void sigsetjmp (void) {
    sigsetjmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a8a4 */
#include <stdint.h>
 
void cfsetispeed (void) {
    cfsetispeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8049de4 */
#include <stdint.h>
 
void fmod (void) {
    fmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804a254 */
#include <stdint.h>
 
void sqrt (void) {
    sqrt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80487c5 */
#include <stdint.h>
 
void fcn_080487c5 (int32_t arg_2h) {
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edx) += bl;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 4)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    al -= 4;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    edx = 1;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + eax)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    dh += ch;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 2)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(ecx) -= al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    edx = 4;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edx) += dl;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((esi + 5)) += dh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    bh += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 4)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(es:edi) = al;
    es:edi++;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((esi + 5)) += ch;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    ah += cl;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebp + 2)) += bh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 4)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("in al, dx");
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax -= 5;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    al += cl;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edx + 1)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(ecx) += bh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + 4)) += bh;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(fp_stack--) = *(ecx);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax = *(ecx);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("aam 4");
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 4)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(gs:eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebx + eax)) += cl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("scasb al, byte es:[edi]");
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + 3)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebx + 3)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    bh = 2;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    edi = 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    bl += ch;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) &= eax;
    *(eax) += al;
    tmp_0 = eax;
    eax = esi;
    esi = tmp_0;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edi) += dl;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax += *(es:eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 4)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    eax = (int32_t) ax;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    es = *(edx);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("in eax, 2");
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    tmp_1 = eax;
    eax = ebx;
    ebx = tmp_1;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 2)) += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    if (*(eax) >= 0) {
        *(eax) += al;
        *(eax) += al;
    }
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edx) += dl;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ecx + 3)) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    dl += al;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((ebp + eax)) += cl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edx + 5)) += dl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("lar eax, word [eax]");
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(esi) += dh;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    dl += ch;
    eax += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += eax;
    *(eax) += al;
    ebx--;
    al += 0;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *(edi) += dh;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    cl += dh;
    al += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edi + 5)) += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    cl += bh;
    *(eax) += eax;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 3)) += ah;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((edx + 2)) += bl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    ch += ah;
    eax += *(eax);
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(edx) += dl;
    *(eax) += al;
    *((eax + 2)) += cl;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    *(eax) += al;
    al += *(eax);
    *(eax) += al;
    __asm ("int3");
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x807048c */
#include <stdint.h>
 
int32_t loc_caml_alloc2 (int32_t arg_4h) {
    do {
        eax = caml_young_ptr;
        eax -= 0xc;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            return eax;
        }
        eax = *(esp);
        *(obj.caml_last_return_address) = eax;
        eax = esp + 4;
        *(obj.caml_bottom_of_stack) = eax;
        fcn_0807043d ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d160 */
#include <stdint.h>
 
int32_t fcn_0804d160 (int32_t arg_8h) {
    *(obj.caml_exception_pointer) = esp;
    eax = 3;
    eax = camlList_mem_1161 (*(obj.caml_exception_pointer));
    while (1) {
        eax = caml_young_ptr;
        eax -= 8;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            eax = eax + 4;
            *((eax - 4)) = 0x400;
            *(eax) = loc.caml_exn_Not_found;
            caml_raise_exn ();
            eax = *((esp + 8));
            eax = unix_gethostbyaddr;
            eax = caml_c_call (eax);
            eax = *(eax);
        }
        caml_call_gc (eax);
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804d820 */
#include <stdint.h>
 
int32_t fcn_0804d820 (int32_t arg_ch) {
    *(obj.caml_exception_pointer) = esp;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = "/bin/sh";
            *((ebx + 4)) = 0x8074d04;
            eax = *((esp + 0xc));
            *((ebx + 8)) = eax;
            eax = unix_execv;
            caml_c_call ("/bin/sh");
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804dc10 */
#include <stdint.h>
 
int32_t fcn_0804dc10 (int32_t arg_18h, int32_t arg_1ch) {
    *(obj.caml_exception_pointer) = esp;
    do {
        eax = caml_young_ptr;
        eax -= 0x10;
        *(obj.caml_young_ptr) = eax;
        if (eax >= *(obj.caml_young_limit)) {
            ebx = eax + 4;
            *((ebx - 4)) = 0xc00;
            *(ebx) = "/bin/sh";
            *((ebx + 4)) = 0x8074ce4;
            eax = *((esp + 0x18));
            *((ebx + 8)) = eax;
            eax = *((esp + 0x1c));
            eax = unix_execve;
            caml_c_call ("/bin/sh");
            return eax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x804f400 */
#include <stdint.h>
 
int32_t fcn_0804f400 (void) {
    *(obj.caml_exception_pointer) = esp;
    eax = caml_ml_flush;
    caml_c_call (eax);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x8070550 */
#include <stdint.h>
 
void loc_caml_start_program (void) {
    esi = caml_startup__code_begin;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/echo_ocaml/ia32_elf/subject.exe @ 0x80705e0 */
#include <stdint.h>
 
int32_t loc_caml_raise_exception (int32_t arg_4h) {
    if ((*(obj.caml_backtrace_active) & 1) == 0) {
        eax = *((esp + 4));
        esp = caml_exception_pointer;
        return eax;
    }
    esi = *((esp + 4));
    caml_stash_backtrace (esi, *(obj.caml_last_return_address), *(obj.caml_bottom_of_stack), *(obj.caml_exception_pointer));
    eax = esi;
    esp = caml_exception_pointer;
    return eax;
}
