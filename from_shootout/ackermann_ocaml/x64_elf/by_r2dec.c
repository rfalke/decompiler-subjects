/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4097f0 */
#include <stdint.h>
 
void entry0 (func rtld_fini, void * stack_end) {
    rdx = rtld_fini;
    xmm0 = stack_end;
    /* [13] -r-x section size 178408 named .text */
    ebp = 0;
    return libc_start_main (main, rsi, rsp, sym.__libc_csu_init, sym.__libc_csu_fini, rdx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408f60 */
#include <stdint.h>
 
void libc_start_main (void) {
    libc_start_main ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b580 */
#include <stdint.h>
 
uint64_t caml_ml_out_channels_list (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    eax = 1;
    rbx = caml_all_opened_channels;
    rbp = caml_local_roots;
    *((rsp + 0x58)) = 1;
    *(obj.caml_local_roots) = rsp;
    if (rbx == 0) {
        goto label_1;
    }
    rax = rsp + 0x58;
    *((rsp + 0x50)) = 0;
    *((rsp + 0x48)) = 0;
    *(rsp) = rbp;
    *((rsp + 0x10)) = 1;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x50;
    *((rsp + 8)) = 3;
    *((rsp + 0x20)) = rax;
    rax = rsp + 0x48;
    *((rsp + 0x28)) = rax;
    do {
        if (*((rbx + 0x20)) == 0) {
            goto label_2;
        }
label_0:
        rbx = *((rbx + 0x30));
    } while (rbx != 0);
    rax = *((rsp + 0x58));
label_1:
    *(obj.caml_local_roots) = rbp;
    return rax;
label_2:
    rdi = rbx;
    rax = caml_alloc_channel ();
    *((rsp + 0x48)) = rax;
    rax = *((rsp + 0x58));
    esi = 0;
    edi = 2;
    *((rsp + 0x50)) = rax;
    rax = caml_alloc_small ();
    rdx = *((rsp + 0x48));
    *((rsp + 0x58)) = rax;
    *(rax) = rdx;
    rdx = *((rsp + 0x50));
    rax = *((rsp + 0x58));
    *((rax + 8)) = rdx;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ba30 */
#include <stdint.h>
 
int64_t caml_ml_input (int64_t arg4, int64_t arg3, void * arg2, int64_t arg1) {
    int64_t var_8h;
    void * s1;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_70h;
    int64_t var_78h;
    int64_t var_80h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = r13;
    *((rsp - 0x28)) = rbx;
    *((rsp - 0x20)) = rbp;
    *((rsp - 0x18)) = r12;
    *((rsp - 8)) = r14;
    r13 = caml_local_roots;
    *((rsp + 8)) = rdx;
    rdx = rsp + 0x20;
    rax = caml_channel_mutex_lock;
    *((rsp + 0x18)) = rdi;
    *((rsp + 0x10)) = rsi;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 0x18;
    *(rsp) = rcx;
    *((rsp + 0x20)) = r13;
    *((rsp + 0x30)) = 1;
    *((rsp + 0x38)) = rdx;
    rdx = rsp + 0x10;
    *((rsp + 0x28)) = 4;
    *((rsp + 0x50)) = rsp;
    rbx = *((rdi + 8));
    *((rsp + 0x40)) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x48)) = rdx;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rax = *(rsp);
    r12 = *((rsp + 8));
    rsi = *((rbx + 0x18));
    rax >>= 1;
    r12 >>= 1;
    if (rax < 0x7fffffff) {
    }
    rax = *((rbx + 0x20));
    eax -= esi;
    if (ebp <= eax) {
        goto label_1;
    }
    if (eax <= 0) {
        goto label_2;
    }
    rbp = (int64_t) eax;
    do {
        rdi += *((rsp + 0x10));
        memmove (r12, rsi, rbp);
        *((rbx + 0x18)) += rbp;
label_0:
        rax = caml_channel_mutex_unlock;
        if (rax != 0) {
            rdi = rbx;
            void (*rax)() ();
        }
        *(obj.caml_local_roots) = r13;
        rax = rbp + rbp + 1;
        rbx = *((rsp + 0x60));
        rbp = *((rsp + 0x68));
        r12 = *((rsp + 0x70));
        r13 = *((rsp + 0x78));
        r14 = *((rsp + 0x80));
        return rax;
label_1:
        rbp = (int64_t) ebp;
    } while (1);
label_2:
    rdx = *((rbx + 0x10));
    r14 = rbx + 0x50;
    edi = *(rbx);
    rsi = r14;
    edx -= r14d;
    eax = caml_do_read ();
    rdx = (int64_t) eax;
    *((rbx + 8)) += rdx;
    if (ebp > eax) {
    }
    rdi += *((rsp + 0x10));
    rdx = rbx + rdx + 0x50;
    rbp = (int64_t) ebp;
    *((rbx + 0x20)) = rdx;
    memmove (r12, r14, rbp);
    rax = rbx + rbp + 0x50;
    *((rbx + 0x18)) = rax;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4231d7 */
#include <stdint.h>
 
uint32_t unix_waitpid (int64_t arg2, int64_t arg1) {
    int64_t wstatus;
    rsi = arg2;
    rdi = arg1;
    rbx = rsi;
    rsi = obj_wait_flag_table;
    eax = caml_convert_flag_list ();
    caml_enter_blocking_section ();
    rbx >>= 1;
    eax = waitpid (ebx, rsp + 0xc, ebp);
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx == 0xffffffff) {
        esi = 0;
        rdi = "waitpid";
        uerror ();
    }
    esi = *((rsp + 0xc));
    edi = ebx;
    alloc_process_status ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427fc0 */
#include <stdint.h>
 
int32_t caml_convert_flag_list (int64_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    eax = 0;
    if (rdi == 1) {
        goto label_0;
    }
    do {
        rdx = *(rdi);
        rdi = *((rdi + 8));
        rdx >>= 1;
        rdx = (int64_t) edx;
        eax |= *((rsi + rdx*4));
    } while (rdi != 1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424ed0 */
#include <stdint.h>
 
int64_t caml_enter_blocking_section (void) {
    while (rax != 0) {
        uint64_t (*caml_leave_blocking_section_hook)() ();
        caml_process_pending_signals ();
        uint64_t (*caml_enter_blocking_section_hook)() ();
        rax = caml_signals_are_pending;
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4093a0 */
#include <stdint.h>
 
void waitpid (void) {
    waitpid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424eb0 */
#include <stdint.h>
 
void caml_leave_blocking_section (void) {
    uint64_t (*caml_leave_blocking_section_hook)() ();
    return caml_process_pending_signals ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424b60 */
#include <stdint.h>
 
int64_t caml_execute_signal (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    r13d = esi;
    ebx = edi;
    rdi = rsp;
    sigemptyset ();
    esi = ebx;
    rdi = rsp;
    sigaddset ();
    rdx = rsp;
    rsi = rsp;
    edi = 0;
    sigprocmask ();
    eax = 0x436124;
    edx = 1;
    rsi = 0xffffffffffffffff;
    ecx = 6;
    if (ebx == 6) {
        goto label_0;
    }
    do {
        if (ebx == *(rax)) {
            goto label_1;
        }
        edx++;
        rax += 4;
    } while (edx != 0x15);
    rcx = (int64_t) ebx;
    rsi = rcx + rcx + 1;
    do {
label_0:
        rax = caml_signal_handlers;
        rdi = *((rax + rcx*8));
        rax = caml_callback_exn ();
        r12 = rax;
        if (r13d == 0) {
            goto label_2;
        }
        eax &= 3;
        if (rax == 2) {
            goto label_3;
        }
        return rax;
label_1:
        edx = ~edx;
        rcx = (int64_t) ebx;
        rdx = (int64_t) edx;
        rsi = rdx + rdx + 1;
    } while (1);
label_2:
    edx = 0;
    rsi = rbp;
    edi = 2;
    sigprocmask ();
    rax = r12;
    eax &= 3;
    if (rax != 2) {
        return rax;
label_3:
        esi = ebx;
        rdi = rsp;
        sigdelset ();
        edx = 0;
        rsi = rbp;
        edi = 2;
        sigprocmask ();
    }
    rdi = r12;
    rdi &= 0xfffffffffffffffc;
    return caml_raise ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423032 */
#include <stdint.h>
 
uint64_t uerror (char * arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rbx = rsi;
    rax = errno_location ();
    rdx = rbx;
    rsi = rbp;
    edi = *(rax);
    return unix_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409440 */
#include <stdint.h>
 
void errno_location (void) {
    errno_location ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422f1e */
#include <stdint.h>
 
int64_t unix_error (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rbx = rsi;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x50)) = 1;
    *((rsp + 0x48)) = 1;
    rax = *(reloc.caml_local_roots);
    rcx = *(rax);
    *(rsp) = rcx;
    *(rax) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 3;
    rax = rsp + 0x58;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x20)) = rax;
    rax = rsp + 0x48;
    *((rsp + 0x28)) = rax;
    if (rdx == 0) {
        rdi = 0x00436cc1;
        rax = caml_copy_string ();
        rdx = rax;
    }
    *((rsp + 0x48)) = rdx;
    rdi = rbx;
    rax = caml_copy_string ();
    *((rsp + 0x58)) = rax;
    edi = ebp;
    rax = unix_error_of_code ();
    *((rsp + 0x50)) = rax;
    if (*(obj.unix_error_exn) == 0) {
        rdi = "Unix.Unix_error";
        rax = caml_named_value ();
        *(obj.unix_error_exn) = rax;
        if (rax != 0) {
            goto label_0;
        }
        rdi = "Exception Unix.Unix_error not initialized, please link unix.cma";
        caml_invalid_argument ();
    }
label_0:
    esi = 0;
    edi = 4;
    caml_alloc_small ();
    rdx = unix_error_exn;
    rdx = *(rdx);
    *(rax) = rdx;
    rdx = *((rsp + 0x50));
    *((rax + 8)) = rdx;
    rdx = *((rsp + 0x58));
    *((rax + 0x10)) = rdx;
    rdx = *((rsp + 0x48));
    *((rax + 0x18)) = rdx;
    rcx = *(rsp);
    rdx = *(reloc.caml_local_roots);
    *(rdx) = rcx;
    rdi = rax;
    return caml_raise ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408fb0 */
#include <stdint.h>
 
void unlink (void) {
    unlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4230d0 */
#include <stdint.h>
 
uint64_t alloc_process_status (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    *((rsp - 8)) = r12;
    ebx = esi;
    r12d = esi;
    r12d &= 0x7f;
    if (r12d == 0) {
        esi = 0;
        edi = 1;
        rax = caml_alloc_small ();
        *((rsp + 0x48)) = rax;
        ebx = (int32_t) bh;
        rdx = rbx + rbx + 1;
        *(rax) = rdx;
    } else {
        if (sil == 0x7f) {
            esi = 2;
            edi = 1;
            rax = caml_alloc_small ();
            r12 = rax;
            *((rsp + 0x48)) = rax;
            edi = (int32_t) bh;
            caml_rev_convert_signal_number ();
            rax = (int64_t) eax;
            rax = rax + rax + 1;
            *(r12) = rax;
        } else {
            esi = 1;
            edi = 1;
            rax = caml_alloc_small ();
            rbx = rax;
            *((rsp + 0x48)) = rax;
            edi = r12d;
            caml_rev_convert_signal_number ();
            rax = (int64_t) eax;
            rax = rax + rax + 1;
            *(rbx) = rax;
        }
    }
    rbx = *(reloc.caml_local_roots);
    rax = *(rbx);
    *(rsp) = rax;
    *(rbx) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 1;
    rax = rsp + 0x48;
    *((rsp + 0x18)) = rax;
    esi = 0;
    edi = 2;
    caml_alloc_small ();
    rbp = (int64_t) ebp;
    rdx = rbp + rbp + 1;
    *(rax) = rdx;
    rdx = *((rsp + 0x48));
    *((rax + 8)) = rdx;
    rdx = *(rsp);
    *(rbx) = rdx;
    rbx = *((rsp + 0x50));
    rbp = *((rsp + 0x58));
    r12 = *((rsp + 0x60));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418510 */
#include <stdint.h>
 
int64_t camlHashtbl_remove_213 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h_2;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
    do {
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x14f7;
            rax = *(reloc.camlHashtbl__remove_bucket_216);
            *(rsi) = rax;
            *((rsi + 8)) = 3;
            rax = *((rdi + 0x18));
            *((rsi + 0x10)) = rax;
            *((rsi + 0x18)) = rdx;
            *((rsi + 0x20)) = rbx;
            rax = *((rdx + 8));
            rax = *((rax - 8));
            rax >>= 0xa;
            if (rax != 0) {
                rax = *((rdi + 0x20));
                rax = *((rax + 0x10));
                rsi = *((rax + 8));
                rdi = *(rsi);
                rax = rbx;
                rbx = rsi;
                rax = void (*rdi)(uint64_t, uint64_t) (rax, rsi);
                rbx = 0x7fffffffffffffff;
                rax &= rbx;
                rax >>= 1;
                rcx = *((rsp + 0x10));
                __asm ("cqo");
                rax = rdx:rax / rcx;
                rdx = rdx:rax % rcx;
            } else {
                rax = *(reloc.caml_bucket_Division_by_zero);
                caml_raise_exn ();
            }
            rdx <<= 1;
            rdx++;
            *((rsp + 0x10)) = rdx;
            rax = *(rsp);
            rbx = *((rax + 8));
            *(rsp) = rbx;
            rbx = *((rbx - 8));
            rbx >>= 9;
            if (rbx <= rdx) {
                goto label_0;
            }
            rbx = *((rax + 8));
            rax = *((rbx - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_1;
            }
            rax = *((rbx + rdx*4 - 4));
            rbx = *((rsp + 8));
            rax = camlHashtbl_remove_bucket_216 ();
            rdi = *(rsp);
            rbx = *((rsp + 0x10));
            rdi = rdi + rbx*4 - 4;
            rsi = rax;
            caml_modify ();
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x411720 */
#include <stdint.h>
 
int64_t camlArray_maxson_182 (int64_t arg6, int64_t arg5, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rcx = rax;
    rax = rbx;
    rax += rbx;
    rsi = rax + rbx + 3;
    rsi += 0xfffffffffffffffd;
    *((rsp + 0x10)) = rsi;
label_6:
    r15 -= 0x10;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_7;
    }
    rdx = r15 + 8;
    *((rdx - 8)) = 0x400;
    *(rdx) = rsi;
    rax = rsi;
    rax += 4;
    if (rax < rcx) {
        *((rsp + 8)) = rdx;
        *(rsp) = rdi;
        rcx = rsi;
        rcx += 2;
        rdx = *((rdi + 0x20));
        rax = *((rdx - 8));
        rbx = *((rdx - 8));
        rbx &= 0xff;
        if (rbx != 0xfe) {
            rax >>= 9;
            if (rax <= rcx) {
                goto label_8;
            }
            rbx = *((rdx + rcx*4 - 4));
        } else {
            rax >>= 9;
            if (rax <= rcx) {
                goto label_9;
            }
label_5:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_10;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdx + rcx*4 - 4]");
            __asm ("movlpd qword [rbx], xmm0");
        }
        rcx = *((rdi + 0x20));
        rax = *((rcx - 8));
        rdx = *((rcx - 8));
        rdx &= 0xff;
        if (rdx != 0xfe) {
            rax >>= 9;
            if (rax <= rsi) {
                goto label_11;
            }
            rax = *((rcx + rsi*4 - 4));
        } else {
            rax >>= 9;
            if (rax <= rsi) {
                goto label_12;
            }
label_4:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_13;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rcx + rsi*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
        }
        rdi = *((rdi + 0x18));
        rax = caml_apply2 ();
        if (rax < 1) {
            rbx = *((rsp + 0x10));
            rbx += 2;
            rax = *((rsp + 8));
            *(rax) = rbx;
        }
        rbx = *((rsp + 0x10));
        rbx += 4;
        rdi = *(rsp);
        rdx = *((rdi + 0x20));
        rax = *((rdx - 8));
        rsi = *((rdx - 8));
        rsi &= 0xff;
        if (rsi != 0xfe) {
            rax >>= 9;
            if (rax <= rbx) {
                goto label_14;
            }
            rbx = *((rdx + rbx*4 - 4));
        } else {
            rax >>= 9;
            if (rax <= rbx) {
                goto label_15;
            }
label_3:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_16;
            }
            r8 = r15 + 8;
            *((r8 - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdx + rbx*4 - 4]");
            __asm ("movlpd qword [r8], xmm0");
            rbx = r8;
        }
        rax = *((rsp + 8));
        rcx = *(rax);
        rdx = *((rdi + 0x20));
        rax = *((rdx - 8));
        rsi = *((rdx - 8));
        rsi &= 0xff;
        if (rsi != 0xfe) {
            rax >>= 9;
            if (rax <= rcx) {
                goto label_17;
            }
            rax = *((rdx + rcx*4 - 4));
        } else {
            rax >>= 9;
            if (rax <= rcx) {
                goto label_18;
            }
label_2:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_19;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdx + rcx*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
        }
        rdi = *((rdi + 0x18));
        rax = caml_apply2 ();
        if (rax < 1) {
            rbx = *((rsp + 0x10));
            rbx += 4;
            rax = *((rsp + 8));
            *(rax) = rbx;
        }
        rax = *((rsp + 8));
        rax = *(rax);
        return rax;
    }
    *((rsp + 8)) = rbx;
    *(rsp) = rcx;
    rax = rsi;
    rax += 2;
    if (rax < rcx) {
        rcx = rsi;
        rcx += 2;
        rdx = *((rdi + 0x20));
        rbx = *((rdx - 8));
        rax = *((rdx - 8));
        rax &= 0xff;
        if (rax != 0xfe) {
            rax = rbx;
            rax >>= 9;
            if (rax <= rcx) {
                goto label_20;
            }
            rbx = *((rdx + rcx*4 - 4));
        } else {
            rax = rbx;
            rax >>= 9;
            if (rax <= rcx) {
                goto label_21;
            }
label_1:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_22;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdx + rcx*4 - 4]");
            __asm ("movlpd qword [rbx], xmm0");
        }
        rcx = *((rdi + 0x20));
        rdx = *((rcx - 8));
        rax = *((rcx - 8));
        rax &= 0xff;
        if (rax != 0xfe) {
            rax = rdx;
            rax >>= 9;
            if (rax <= rsi) {
                goto label_23;
            }
            rax = *((rcx + rsi*4 - 4));
        } else {
            rax = rdx;
            rax >>= 9;
            if (rax <= rsi) {
                goto label_24;
            }
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_25;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rcx + rsi*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
        }
        rdi = *((rdi + 0x18));
        rax = caml_apply2 ();
        if (rax >= 1) {
            goto label_26;
        }
        rax = *((rsp + 0x10));
        rax += 2;
        return rax;
    }
label_26:
    rax = *((rsp + 0x10));
    rbx = *(rsp);
    if (rax >= rbx) {
        goto label_27;
    }
    return rax;
    do {
label_27:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *(reloc.camlArray);
            rbx = *((rbx + 0xb0));
            *(rax) = rbx;
            rbx = *((rsp + 8));
            *((rax + 8)) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_25:
    caml_call_gc ();
    goto label_0;
label_22:
    caml_call_gc ();
    goto label_1;
label_19:
    caml_call_gc ();
    goto label_2;
label_16:
    caml_call_gc ();
    goto label_3;
label_13:
    caml_call_gc ();
    goto label_4;
label_10:
    caml_call_gc ();
    goto label_5;
label_7:
    caml_call_gc ();
    goto label_6;
label_24:
    caml_ml_array_bound_error ();
label_23:
    caml_ml_array_bound_error ();
label_21:
    caml_ml_array_bound_error ();
label_20:
    caml_ml_array_bound_error ();
label_18:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b990 */
#include <stdint.h>
 
void camlPrintf_scan_flags_170 (int64_t arg6, int64_t arg5, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428ad0 */
#include <stdint.h>
 
uint64_t caml_greaterequal (void) {
    edx = 0;
    rax = compare_val ();
    rbx = rax;
    if (*(obj.compare_stack) != 0x652500) {
        compare_free_stack ();
    }
    rax = rbx;
    rax >>= 0x3f;
    rax &= 0xfffffffffffffffe;
    rax += 3;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428580 */
#include <stdint.h>
 
uint64_t compare_val (int64_t arg3, int64_t arg2, int64_t arg1) {
    void * var_8h;
    void * var_10h;
    uint32_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r15d = compare_stack_init;
    r14d = edx;
    rbx = rdi;
    r12 = compare_stack;
    r13b = (edx != 0) ? 1 : 0;
    do {
label_1:
        dl = (rbx == rbp) ? 1 : 0;
        if (rbx == rbp) {
            if (r13b != 0) {
                goto label_4;
            }
        }
        if ((bl & 1) == 0) {
            goto label_12;
        }
        if (dl == 0) {
            if ((bpl & 1) != 0) {
                goto label_13;
            }
            rdi = rbp;
            al = caml_page_table_lookup ();
            if ((al & 7) != 0) {
                if (*((rbp - 8)) == 0xfa) {
                    goto label_14;
                }
            }
label_6:
            rax = 0xffffffffffffffff;
label_5:
            return rax;
label_0:
            rdi = rbx;
            *((rsp + 8)) = dl;
            al = caml_page_table_lookup ();
            edx = *((rsp + 8));
            if ((al & 7) != 0) {
                goto label_15;
            }
label_2:
            if (dl == 0) {
                goto label_13;
            }
        }
label_4:
        if (r12 == *(obj.compare_stack)) {
            goto label_16;
        }
        rax = *(r12);
        rdx = r12 - 0x18;
        rbx = *(rax);
        rax += 8;
        *(r12) = rax;
        rax = *((r12 + 8));
        rbp = *(rax);
        rax += 8;
        *((r12 + 8)) = rax;
        rax = *((r12 + 0x10));
        rax--;
        *((r12 + 0x10)) = rax;
        if (rax == 0) {
            r12 = rdx;
        }
    } while (1);
label_12:
    if ((bpl & 1) == 0) {
        goto label_0;
    }
    rdi = rbx;
    al = caml_page_table_lookup ();
    if ((al & 7) != 0) {
        if (*((rbx - 8)) == 0xfa) {
            goto label_3;
        }
    }
label_7:
    eax = 1;
    return rax;
label_3:
    rbx = *(rbx);
    goto label_1;
label_15:
    rdi = rbp;
    al = caml_page_table_lookup ();
    edx = *((rsp + 8));
    if ((al & 7) == 0) {
        goto label_2;
    }
    ecx = *((rbx - 8));
    r8 = rbx - 8;
    rdi = rbp - 8;
    esi = *((rbp - 8));
    eax = (int32_t) cl;
    if (eax == 0xfa) {
        goto label_3;
    }
    esi = (int32_t) sil;
    if (esi == 0xfa) {
        goto label_14;
    }
    if (eax != esi) {
        goto label_17;
    }
    ecx += 9;
    if (cl <= 8) {
        goto label_18;
    }
    r8 = *(r8);
    rdx = *(rdi);
    *((rsp + 0x18)) = r8;
    rdx >>= 0xa;
    if (*((rsp + 0x18)) != rdx) {
        goto label_19;
    }
    if (*((rsp + 0x18)) == 0) {
        goto label_4;
    }
    if (*((rsp + 0x18)) != 1) {
        rax = compare_stack_limit;
        r12 += 0x18;
        if (r12 >= rax) {
            goto label_20;
        }
label_10:
        rax = rbx + 8;
        *(r12) = rax;
        rax = rbp + 8;
        *((r12 + 8)) = rax;
        rax = *((rsp + 0x18));
        rax--;
        *((r12 + 0x10)) = rax;
    }
    rbx = *(rbx);
label_14:
    rbp = *(rbp);
    goto label_1;
label_16:
    eax = 0;
    goto label_5;
label_13:
    rax = rbx;
    rbp >>= 1;
    rax >>= 1;
    rax -= rbp;
    goto label_5;
label_18:
    ecx = (int32_t) cl;
    /* switch table (9 cases) at 0x436518 */
    rax = *(rbx);
    rax = *((rax + 0x10));
    if (rax == 0) {
        goto label_21;
    }
    *(obj.caml_compare_unordered) = 0;
    rsi = rbp;
    rdi = rbx;
    void (*rax)() ();
    if (r14d != 0) {
        goto label_22;
    }
    if (*(obj.caml_compare_unordered) == 0) {
        goto label_22;
    }
label_9:
    rax = 0x8000000000000000;
    goto label_5;
    rax = *(r8);
    rdx = *(rdi);
    rax >>= 0xa;
    rdx >>= 0xa;
    if (rax != rdx) {
        goto label_11;
    }
    if (rax == 0) {
        goto label_4;
    }
    xmm1 = *(rbx);
    xmm0 = *(rbp);
    __asm ("ucomisd xmm0, xmm1");
    if (rax > 0) {
        goto label_6;
    }
    __asm ("ucomisd xmm1, xmm0");
    if (rax > 0) {
        goto label_7;
    }
    edx = 0;
    goto label_23;
label_8:
    rdx++;
    if (rax <= rdx) {
        goto label_4;
    }
    xmm1 = *((rbx + rdx*8));
    xmm0 = *((rbp + rdx*8));
    __asm ("ucomisd xmm0, xmm1");
    if (rax > rdx) {
        goto label_6;
    }
    __asm ("ucomisd xmm1, xmm0");
    if (rax > rdx) {
        goto label_7;
    }
label_23:
    __asm ("ucomisd xmm1, xmm0");
    if (rax == rdx) {
        goto label_24;
    }
    if (rax == rdx) {
        goto label_8;
    }
label_24:
    if (r14d == 0) {
        goto label_9;
    }
    __asm ("ucomisd xmm1, xmm1");
    if (r14d == 0) {
        goto label_25;
    }
    if (r14d == 0) {
        goto label_7;
    }
label_25:
    __asm ("ucomisd xmm0, xmm0");
    if (r14d == 0) {
        goto label_8;
    }
    if (r14d != 0) {
        goto label_8;
    }
    goto label_6;
    xmm1 = *(rbx);
    xmm0 = *(rbp);
    __asm ("ucomisd xmm0, xmm1");
    if (r14d > 0) {
        goto label_6;
    }
    __asm ("ucomisd xmm1, xmm0");
    if (r14d > 0) {
        goto label_7;
    }
    __asm ("ucomisd xmm1, xmm0");
    if (r14d == 0) {
        goto label_26;
    }
    if (r14d == 0) {
        goto label_4;
    }
label_26:
    if (r14d == 0) {
        goto label_9;
    }
    __asm ("ucomisd xmm1, xmm1");
    if (r14d == 0) {
        goto label_27;
    }
    if (r14d == 0) {
        goto label_7;
    }
label_27:
    __asm ("ucomisd xmm0, xmm0");
    if (r14d != 0) {
        goto label_4;
    }
    if (r14d != 0) {
        goto label_6;
    }
    goto label_4;
    if (dl != 0) {
        goto label_4;
    }
    rdi = rbx;
    rax = caml_string_length ();
    rdi = rbp;
    *((rsp + 8)) = rax;
    rax = caml_string_length ();
    rdx = *((rsp + 8));
    rcx = rdx;
    if (rax <= rdx) {
        rcx = rax;
    }
    if (rcx != 0) {
        goto label_28;
    }
    goto label_29;
    do {
        rcx--;
        if (rcx == 0) {
            goto label_29;
        }
        rbx++;
        rbp++;
label_28:
        edi = *(rbx);
        esi = *(rbp);
    } while (dil == sil);
    eax = (int32_t) dil;
    esi = (int32_t) sil;
    rax -= rsi;
    goto label_5;
label_21:
    compare_free_stack ();
    edi = "equal: abstract value";
    caml_invalid_argument ();
    rax = *((rbx + 8));
    rdx = *((rbp + 8));
    rax >>= 1;
    rdx >>= 1;
    if (rax == rdx) {
        goto label_4;
    }
label_11:
    rax -= rdx;
    goto label_5;
    compare_free_stack ();
    edi = "equal: functional value";
    eax = caml_invalid_argument ();
label_22:
    if (eax == 0) {
        goto label_4;
    }
    rax = (int64_t) eax;
    goto label_5;
label_29:
    if (rdx == rax) {
        goto label_4;
    }
    rdx -= rax;
    rax = rdx;
    goto label_5;
label_17:
    rax -= rsi;
    goto label_5;
label_20:
    rdi = compare_stack;
    rdx = 0xaaaaaaaaaaaaaaab;
    rax -= rdi;
    *((rsp + 0x28)) = rdi;
    rax >>= 2;
    rax *= rdx;
    if (rax > 0xfffff) {
        goto label_30;
    }
    if (rdi == obj.compare_stack_init) {
        goto label_31;
    }
    rax *= 0x18;
    rsi = rax;
    *((rsp + 0x20)) = rax;
    rax = realloc (rdi, rsi);
    while (1) {
        rdx = *((rsp + 0x20));
        r12 -= *((rsp + 0x28));
        *(obj.compare_stack) = rax;
        rdx = rax + rdx;
        r12 &= 0xfffffffffffffff8;
        *(obj.compare_stack_limit) = rdx;
        r12 = rax + r12;
        goto label_10;
label_19:
        rax = *((rsp + 0x18));
        goto label_11;
        *((rsp + 0x10)) = rax;
        rax = compare_stack_overflow ();
label_31:
        rax *= 0x18;
        rdi = rax;
        *((rsp + 0x20)) = rax;
        rax = malloc (rdi);
        rdx = rax;
        if (rdx == 0) {
            *((rsp + 0x10)) = rax;
            *((rsp + 8)) = rdx;
            rax = compare_stack_overflow ();
        }
        rdi = rdx;
        rsi = r15;
        ecx = 0x300;
        *(rdi) = *(rsi);
        rcx--;
        rsi += 8;
        rdi += 8;
    }
label_30:
    *((rsp + 0x10)) = rax;
    return compare_stack_overflow ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428520 */
#include <stdint.h>
 
void compare_free_stack (void) {
    rdi = compare_stack;
    if (rdi != obj.compare_stack_init) {
        free (rdi);
        *(obj.compare_stack) = 0x652500;
        *(obj.compare_stack_limit) = 0x653d00;
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4090e0 */
#include <stdint.h>
 
void free (void) {
    free ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417da0 */
#include <stdint.h>
 
int64_t camlHashtbl_replace_bucket_249 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rax == 1) {
            goto label_2;
        }
        *((rsp + 0x10)) = rbx;
        rdi = *((rax + 0x10));
        *((rsp + 0x18)) = rdi;
        rdi = *((rax + 8));
        *(rsp) = rdi;
        rax = *(rax);
        *((rsp + 8)) = rax;
        rdi = *((rbx + 0x10));
        rdi = *(rdi);
        rbx = *((rbx + 0x18));
        rax = caml_apply2 ();
        if (rax != 1) {
label_1:
            r15 -= 0x20;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_3;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0xc00;
            rbx = *((rsp + 8));
            *(rax) = rbx;
            rbx = *((rsp + 0x10));
            rbx = *((rbx + 0x20));
            *((rax + 8)) = rbx;
            rbx = *((rsp + 0x18));
            *((rax + 0x10)) = rbx;
            return rax;
        }
        rax = *((rsp + 0x18));
        rbx = *((rsp + 0x10));
        rax = camlHashtbl_replace_bucket_249 ();
    } while (1);
    rdi = rax;
label_0:
    r15 -= 0x20;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_4;
    }
    rax = r15 + 8;
    *((rax - 8)) = 0xc00;
    rbx = *((rsp + 8));
    *(rax) = rbx;
    rbx = *(rsp);
    *((rax + 8)) = rbx;
    *((rax + 0x10)) = rdi;
    return rax;
    do {
label_2:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a5b0 */
#include <stdint.h>
 
uint64_t caml_apply2 (uint32_t arg1) {
    rdi = arg1;
    rsi = *((rdi + 8));
    if (rsi == 5) {
        rsi = *((rdi + 0x10));
        void (*rsi)() ();
    }
    rsi = *(rdi);
    rbx = rdi;
    rax = void (*rsi)(uint64_t) (rbx);
    rbx = rax;
    rdi = *(rbx);
    rax = *(rsp);
    return void (*rdi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434f08 */
#include <stdint.h>
 
int64_t caml_raise_exn (int64_t arg_8h) {
    if ((*(obj.caml_backtrace_active) & 1) == 0) {
        return;
    }
    r12 = rax;
    rdi = rax;
    rsi = *(rsp);
    rdx = rsp + 8;
    rcx = r14;
    caml_stash_backtrace ();
    rax = r12;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434a90 */
#include <stdint.h>
 
int64_t caml_stash_backtrace (int64_t arg4, int64_t arg3, int64_t arg2, uint32_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    if (rdi != *(obj.caml_backtrace_last_exn)) {
        *(obj.caml_backtrace_pos) = 0;
        *(obj.caml_backtrace_last_exn) = rdi;
    }
    if (*(obj.caml_backtrace_buffer) == 0) {
        goto label_6;
    }
label_4:
    r8 = caml_frame_descriptors;
    if (r8 == 0) {
        goto label_7;
    }
label_3:
    r9 = *(obj.caml_frame_descriptors_mask);
    r11 = caml_backtrace_buffer;
    r10d = caml_backtrace_pos;
label_0:
    rax = rsi;
    rax >>= 3;
    rax &= r9;
    rdi = *((r8 + rax*8));
    if (rdi != 0) {
        goto label_8;
    }
    goto label_2;
    do {
        rax++;
        rax &= r9;
        rdi = *((r8 + rax*8));
        if (rdi == 0) {
            goto label_2;
        }
label_8:
    } while (*(rdi) != rsi);
    if (*((rdi + 8)) == 0xffff) {
        goto label_9;
    }
    if (r10d > 0x3ff) {
        goto label_2;
    }
    rax = (int64_t) r10d;
    r10d++;
    *((r11 + rax*8)) = rdi;
    eax = *((rdi + 8));
    eax &= 0xfffc;
    rdx += rax;
    rsi = *((rdx - 8));
label_1:
    if (rdx <= rcx) {
        goto label_0;
    }
label_2:
    *(obj.caml_backtrace_pos) = r10d;
label_5:
    return rax;
label_9:
    rax = rdx + 0x10;
    rdx = *((rdx + 0x10));
    rsi = *((rax + 8));
    if (rdx != 0) {
        goto label_1;
    }
    goto label_2;
label_7:
    *((rsp + 0x10)) = rdx;
    *((rsp + 8)) = rcx;
    *((rsp + 0x18)) = rsi;
    caml_init_frame_descriptors ();
    r8 = caml_frame_descriptors;
    rsi = *((rsp + 0x18));
    rcx = *((rsp + 8));
    rdx = *((rsp + 0x10));
    goto label_3;
label_6:
    *((rsp + 0x10)) = rdx;
    *((rsp + 8)) = rcx;
    *((rsp + 0x18)) = rsi;
    rax = malloc (0x2000);
    *(obj.caml_backtrace_buffer) = rax;
    rdx = *((rsp + 0x10));
    rcx = *((rsp + 8));
    rsi = *((rsp + 0x18));
    if (rax != 0) {
        goto label_4;
    }
    goto label_5;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434c34 */
#include <stdint.h>
 
int64_t caml_call_gc (int64_t arg_8h, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rax = *(rsp);
    *(obj.caml_last_return_address) = rax;
    rax = rsp + 8;
    *(obj.caml_bottom_of_stack) = rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425160 */
#include <stdint.h>
 
int64_t caml_garbage_collection (void) {
    rax = caml_young_start;
    *(obj.caml_young_limit) = rax;
    if (rax <= *(obj.caml_young_ptr)) {
        eax = caml_force_major_slice;
        if (eax == 0) {
            goto label_0;
        }
    }
    caml_minor_collection ();
label_0:
    return caml_process_pending_signals ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d4d0 */
#include <stdint.h>
 
uint64_t camlPrintf_add_int_index_68 (void) {
    rax = rax + rbx - 1;
    return camlPrintf_index_of_int_65 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fe70 */
#include <stdint.h>
 
int64_t camlPervasives_string_of_int_154 (void) {
    rdi = *(loc.camlPervasives__96);
    rsi = rax;
    rax = *(reloc.caml_format_int);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434e54 */
#include <stdint.h>
 
void caml_c_call (void) {
    *(obj.caml_last_return_address) = r12;
    *(obj.caml_bottom_of_stack) = rsp;
    *(obj.caml_young_ptr) = r15;
    *(obj.caml_exception_pointer) = r14;
    void (*rax)() ();
    r15 = caml_young_ptr;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fd20 */
#include <stdint.h>
 
uint64_t camlPervasives_5e_136 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    rsi = rax;
    *(rsp) = rsi;
    *((rsp + 0x10)) = rbx;
    rdi = *((rsi - 8));
    rdi >>= 0xa;
    rax = rdi*8 - 1;
    rdi = *((rsi + rax));
    rax -= rdi;
    rdi = rax + rax + 1;
    *((rsp + 8)) = rdi;
    rax = *((rbx - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rbx = *((rbx + rax));
    rax -= rbx;
    rax = rax + rax + 1;
    *((rsp + 0x18)) = rax;
    rdi = rdi + rax - 1;
    rax = *(reloc.caml_create_string);
    rax = caml_c_call ();
    rbx = rax;
    rcx = 1;
    rsi = 1;
    rdi = *(rsp);
    rdx = rbx;
    rbp = *((rsp + 8));
    r8 = *((rsp + 8));
    caml_blit_string ();
    rsi = 1;
    rdi = *((rsp + 0x10));
    rdx = rbx;
    rcx = rbp;
    r8 = *((rsp + 0x18));
    caml_blit_string ();
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42aa90 */
#include <stdint.h>
 
int32_t caml_blit_string (size_t n, void * s1, void * arg2, void * s2) {
    r8 = n;
    rcx = s1;
    rsi = arg2;
    rdi = s2;
    rcx >>= 1;
    r8 >>= 1;
    rsi >>= 1;
    r8 = (int64_t) r8d;
    rsi += rdi;
    memmove (rcx + rdx, rsi, r8);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409390 */
#include <stdint.h>
 
void memmove (void) {
    memmove ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fbf0 */
#include <stdint.h>
 
int64_t camlPervasives_failwith_38 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *(reloc.caml_exn_Failure);
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42dde0 */
#include <stdint.h>
 
int64_t caml_output_value (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_48h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rbp = caml_local_roots;
    rax = caml_channel_mutex_lock;
    *((rsp + 8)) = rdx;
    rdx = rsp + 0x20;
    *((rsp + 0x18)) = rdi;
    *((rsp + 0x10)) = rsi;
    *((rsp + 0x30)) = 1;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 0x18;
    *((rsp + 0x20)) = rbp;
    *((rsp + 0x28)) = 3;
    *((rsp + 0x38)) = rdx;
    rdx = rsp + 0x10;
    rbx = *((rdi + 8));
    *((rsp + 0x40)) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x48)) = rdx;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rdx = *((rsp + 8));
    rsi = *((rsp + 0x10));
    rdi = rbx;
    caml_output_val ();
    rax = caml_channel_mutex_unlock;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    *(obj.caml_local_roots) = rbp;
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41adb0 */
#include <stdint.h>
 
int64_t camlPrintf_loop_187 (void) {
    do {
        rdi = *((rbx + 0x20));
        rdi += 0xfffffffffffffffc;
        if (rax >= rdi) {
            goto label_0;
        }
        *(rsp) = rbx;
        rdi = *((rbx + 0x18));
        rcx = *((rbx + 0x10));
        rdx = rax;
        rdx >>= 1;
        rbx = *((rcx - 8));
        rbx >>= 0xa;
        rbx = rbx*8 - 1;
        rsi = *((rcx + rbx));
        rbx -= rsi;
        if (rbx <= rdx) {
            goto label_1;
        }
        rbx = *((rcx + rdx));
        rbx = rbx + rbx + 1;
        caml_apply2 ();
        rbx = *(rsp);
    } while (1);
label_0:
    rax = 1;
    return rax;
label_1:
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424cc0 */
#include <stdint.h>
 
int64_t caml_install_signal_handler (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_70h;
    int64_t var_98h;
    rsi = arg2;
    rdi = arg1;
    rax = rdi;
    rax >>= 1;
    ebx = eax;
    rbp = caml_local_roots;
    rdx = rsp + 8;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 2;
    *((rsp + 0x68)) = rdx;
    rdx = rsp + 0x50;
    *((rsp + 0x50)) = rbp;
    *((rsp + 0x70)) = rsp;
    *((rsp + 0x98)) = 0;
    *((rsp + 0x10)) = rdx;
    rdx = rsp + 0x10;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 0x98;
    *((rsp + 0x28)) = rdx;
    if (eax <= 0xffffffea) {
        goto label_3;
    }
    while (1) {
label_3:
        if (eax > 0x40) {
            goto label_4;
        }
        rax = *(rsp);
        esi = 2;
        rax--;
        if (rax <= 2) {
            goto label_5;
        }
        edi = ebx;
        eax = caml_set_signal_action ();
        if (eax == 1) {
            goto label_6;
        }
label_0:
        if (eax == 2) {
            goto label_7;
        }
        if (eax == 0) {
            goto label_8;
        }
        edi = 1;
        caml_sys_error ();
label_1:
        rax = *(rsp);
        if ((al & 1) == 0) {
            rdx = caml_signal_handlers;
            if (rdx == 0) {
                goto label_9;
            }
label_2:
            rbx = (int64_t) ebx;
            rsi = *(rax);
            rdi = rdx + rbx*8;
            caml_modify ();
        }
        caml_process_pending_signals ();
        *(obj.caml_local_roots) = rbp;
        rax = *((rsp + 0x98));
        return rax;
        ebx = ~ebx;
        rbx = (int64_t) ebx;
        ebx = *((rbx*4 + obj.posix_signals));
        eax = *((rbx*4 + obj.posix_signals));
    }
label_5:
    esi = *((rax*4 + obj.CSWTCH.33));
    edi = ebx;
    eax = caml_set_signal_action ();
    if (eax != 1) {
        goto label_0;
    }
label_6:
    *((rsp + 0x98)) = 3;
    goto label_1;
label_8:
    *((rsp + 0x98)) = 1;
    goto label_1;
label_7:
    esi = 0;
    edi = 1;
    rax = caml_alloc_small ();
    rdx = caml_signal_handlers;
    rcx = (int64_t) ebx;
    *((rsp + 0x98)) = rax;
    rdx = *((rdx + rcx*8));
    *(rax) = rdx;
    goto label_1;
label_9:
    esi = 0;
    edi = 0x41;
    rax = caml_alloc ();
    edi = caml_signal_handlers;
    *(obj.caml_signal_handlers) = rax;
    caml_register_global_root ();
    rax = *(rsp);
    rdx = caml_signal_handlers;
    goto label_2;
label_4:
    edi = "Sys.signal: unavailable signal";
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4292e0 */
#include <stdint.h>
 
int64_t caml_nativeint_format (int64_t arg2, int64_t arg1) {
    int64_t var_fh;
    int64_t var_10h;
    int64_t var_30h;
    int64_t var_58h;
    int64_t var_68h;
    int64_t var_70h;
    int64_t var_78h;
    int64_t canary;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x20)) = rbx;
    *((rsp - 0x18)) = rbp;
    *((rsp - 0x10)) = r12;
    *((rsp - 8)) = r13;
    r12 = rsp + 0x30;
    rbp = rsp + 0x10;
    r8 = rsp + 0xf;
    r13 = rsi;
    esi = 0x436e5b;
    rdx = r12;
    rcx = rbp;
    rax = *(fs:0x28);
    *((rsp + 0x58)) = rax;
    eax = 0;
    rax = parse_format ();
    r8 = *((r13 + 8));
    rbx = rax;
    rcx = r12;
    rdi = rax;
    rdx = 0xffffffffffffffff;
    esi = 1;
    eax = 0;
    sprintf_chk ();
    rdi = rbx;
    rax = caml_copy_string ();
    r12 = rax;
    if (rbx != rbp) {
        rdi = rbx;
        caml_stat_free ();
    }
    rdx = *((rsp + 0x58));
    rdx ^= *(fs:0x28);
    rax = r12;
    if (rbx == rbp) {
        rbx = *((rsp + 0x68));
        rbp = *((rsp + 0x70));
        r12 = *((rsp + 0x78));
        r13 = *((rsp + 0x80));
        return rax;
    }
    return stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4146b0 */
#include <stdint.h>
 
int64_t camlList_rev_merge_279 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
label_0:
        if (rax == 1) {
            goto label_2;
        }
        if (rbx == 1) {
            goto label_3;
        }
        *((rsp + 0x38)) = rsi;
        *((rsp + 0x20)) = rdi;
        *((rsp + 0x30)) = rbx;
        *((rsp + 8)) = rax;
        rdi = *((rbx + 8));
        *((rsp + 0x10)) = rdi;
        rbx = *(rbx);
        *(rsp) = rbx;
        rdi = *((rax + 8));
        *((rsp + 0x28)) = rdi;
        rax = *(rax);
        *((rsp + 0x18)) = rax;
        rdi = *((rsi + 0x18));
        rax = caml_apply2 ();
        if (rax > 1) {
            goto label_4;
        }
label_1:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_5;
        }
        rdi = r15 + 8;
        *((rdi - 8)) = 0x800;
        rax = *((rsp + 0x18));
        *(rdi) = rax;
        rax = *((rsp + 0x20));
        *((rdi + 8)) = rax;
        rax = *((rsp + 0x28));
        rbx = *((rsp + 0x30));
        rsi = *((rsp + 0x38));
    } while (1);
    do {
label_4:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x800;
            rax = *(rsp);
            *(rdi) = rax;
            rax = *((rsp + 0x20));
            *((rdi + 8)) = rax;
            rax = *((rsp + 8));
            rbx = *((rsp + 0x10));
            rsi = *((rsp + 0x38));
            goto label_0;
label_3:
            rbx = rdi;
            void (*0x415380)() ();
label_2:
            rax = rbx;
            rbx = rdi;
            void (*0x415380)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4219a2 */
#include <stdint.h>
 
int64_t unix_recv (void * s1, int64_t arg_10h, int64_t arg_18h, int64_t arg_20h, int64_t arg_28h, void * s2, int64_t canary, int64_t arg_4068h, int64_t arg_4070h, int64_t arg_4078h, int64_t arg_4080h, int64_t arg5, int64_t arg4, int64_t arg3, void * arg2, int64_t arg1) {
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x20)) = rbx;
    *((rsp - 0x18)) = rbp;
    *((rsp - 0x10)) = r12;
    *((rsp - 8)) = r13;
    *((rsp + 8)) = rsi;
    r13 = rdx;
    rbx = rcx;
    rax = *(fs:0x28);
    *((rsp + 0x4058)) = rax;
    eax = 0;
    rsi = obj_msg_flag_table;
    rdi = r8;
    eax = caml_convert_flag_list ();
    r12d = eax;
    rax = *(reloc.caml_local_roots);
    rdx = *(rax);
    *((rsp + 0x10)) = rdx;
    rdx = rsp + 0x10;
    *(rax) = rdx;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    rax = rsp + 8;
    *((rsp + 0x28)) = rax;
    rbx >>= 1;
    caml_enter_blocking_section ();
    edx = 0x4000;
    if (rbx > 0x4000) {
        rbx = rdx;
    }
    rdx = (int64_t) ebx;
    rsi = rsp + 0x50;
    rdi = rbp;
    rdi >>= 1;
    r8d = r12d;
    ecx = 0x4000;
    eax = recv_chk ();
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx == 0xffffffff) {
        esi = 0;
        rdi = "recv";
        uerror ();
    }
    rbx = (int64_t) ebx;
    r13 >>= 1;
    rdi += *((rsp + 8));
    memmove (r13, rsp + 0x50, rbx);
    rdx = *((rsp + 0x10));
    rax = *(reloc.caml_local_roots);
    *(rax) = rdx;
    rax = rbx + rbx + 1;
    rdx = *((rsp + 0x4058));
    rdx ^= *(fs:0x28);
    if (rdi != 0) {
        stack_chk_fail ();
    }
    rbx = *((rsp + 0x4068));
    rbp = *((rsp + 0x4070));
    r12 = *((rsp + 0x4078));
    r13 = *((rsp + 0x4080));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418360 */
#include <stdint.h>
 
int64_t camlHashtbl_do_bucket_170 (int64_t arg1) {
    int64_t var_8h;
    rdi = arg1;
    do {
        rdx = rbx;
        if (rax == 1) {
            goto label_0;
        }
        *((rsp + 8)) = rdi;
        rbx = *((rax + 0x10));
        *(rsp) = rbx;
        rbx = *((rax + 8));
        rax = *(rax);
        rsi = *((rdi + 0x18));
        rdi = rdx;
        rax = caml_apply3 ();
        rbx = rax;
        rax = *(rsp);
        rdi = *((rsp + 8));
    } while (1);
label_0:
    rax = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4182b0 */
#include <stdint.h>
 
int64_t camlHashtbl_mem_in_bucket_153 (void) {
    int64_t var_8h;
    do {
        if (rax == 1) {
            goto label_0;
        }
        *((rsp + 8)) = rbx;
        rdi = *((rax + 0x10));
        *(rsp) = rdi;
        rdi = *(rax);
        rsi = *((rbx + 0x10));
        rax = *(reloc.caml_compare);
        rax = caml_c_call ();
        if (rax == 1) {
            rax = 3;
            return rax;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
    } while (1);
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a9e0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1852 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            *(rax) = rdi;
            rbx = *((rbx + 0x10));
            rbx = *(rbx);
            *((rax + 8)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421bd0 */
#include <stdint.h>
 
uint64_t unix_sigsuspend (int64_t arg1) {
    rdi = arg1;
    rsi = rsp;
    decode_sigset ();
    caml_enter_blocking_section ();
    rdi = rsp;
    eax = sigsuspend ();
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx == 0xffffffff) {
        rax = errno_location ();
        if (*(rax) == 4) {
            goto label_0;
        }
        esi = 0;
        rdi = "sigsuspend";
        uerror ();
    }
label_0:
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421b90 */
#include <stdint.h>
 
uint32_t decode_sigset (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rdi = rsi;
    sigemptyset ();
    if (rbx == 1) {
        goto label_0;
    }
    do {
        rdi = *(rbx);
        rdi >>= 1;
        eax = caml_convert_signal_number ();
        esi = eax;
        rdi = rbp;
        sigaddset ();
        rbx = *((rbx + 8));
    } while (rbx != 1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4090a0 */
#include <stdint.h>
 
void sigsuspend (void) {
    sigsuspend ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42bfb0 */
#include <stdint.h>
 
int64_t caml_ml_input_int (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    rdi = arg1;
    *((rsp - 0x10)) = rbp;
    *((rsp - 0x18)) = rbx;
    *((rsp - 8)) = r12;
    rax = caml_channel_mutex_lock;
    rdx = rsp + 0x10;
    rbp = caml_local_roots;
    *((rsp + 8)) = rdi;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x10)) = rbp;
    rbx = *((rdi + 8));
    *((rsp + 0x28)) = rdx;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rdi = rbx;
    eax = caml_getword ();
    rdx = caml_channel_mutex_unlock;
    r12d = eax;
    if (rdx != 0) {
        rdi = rbx;
        void (*rdx)() ();
    }
    r12 = (int64_t) r12d;
    *(obj.caml_local_roots) = rbp;
    rbx = *((rsp + 0x50));
    rax = r12 + r12 + 1;
    rbp = *((rsp + 0x58));
    r12 = *((rsp + 0x60));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420b44 */
#include <stdint.h>
 
uint32_t unix_listen (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    rdi >>= 1;
    eax = listen (rdi, rsi);
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "listen";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409170 */
#include <stdint.h>
 
void listen (void) {
    listen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40aa20 */
#include <stdint.h>
 
int64_t camlUnix_fun_1855 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
    do {
        r15 -= 0x38;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x18f7;
            rsi = *(reloc.caml_tuplify2);
            *(rax) = rsi;
            *((rax + 8)) = 0xfffffffffffffffd;
            rsi = *(reloc.camlUnix__fun_1861);
            *((rax + 0x10)) = rsi;
            rsi = *((rdi + 0x18));
            *((rax + 0x18)) = rsi;
            *((rax + 0x20)) = rdx;
            *((rax + 0x28)) = rbx;
            rbx = *((rdi + 0x20));
            void (*0x415420)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415420 */
#include <stdint.h>
 
int64_t camlList_map_90 (void) {
    int64_t var_8h;
    int64_t var_10h;
    do {
        rsi = rax;
        if (rbx == 1) {
            goto label_0;
        }
        rax = *((rbx + 8));
        rax = *(rbx);
        rdi = *(rsi);
        rbx = rsi;
        rax = void (*rdi)(uint64_t, uint64_t) (rsi, rax);
        *((rsp + 0x10)) = rax;
        rax = *(rsp);
        rbx = *((rsp + 8));
        rax = camlList_map_90 ();
    } while (1);
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *((rsp + 0x10));
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            return rax;
label_0:
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b120 */
#include <stdint.h>
 
int64_t camlPrintf_cont_a_394 (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *(rsp) = rax;
    rcx = rbx;
    rbx = rdi;
    *((rsp + 8)) = rsi;
    *((rsp + 0x10)) = rdx;
    rax = *((rdx + 0x78));
    if (rax != 1) {
        rax = 1;
        rdi = rcx;
        rax = caml_apply2 ();
        rbx = rax;
        rax = *((rsp + 0x10));
        rdi = *((rax + 0x88));
        rax = *((rax + 0x98));
        caml_apply2 ();
    } else {
        rax = *((rdx + 0x98));
        rdi = rcx;
        caml_apply2 ();
    }
    rdi = *((rsp + 0x10));
    rdi += 0xffffffffffffffc0;
    rax = *(rsp);
    rbx = *((rsp + 8));
    return camlPrintf_doprn_392 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4220cc */
#include <stdint.h>
 
int64_t unix_socketpair (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_4h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rcx = rsp;
    rdx >>= 1;
    rsi >>= 1;
    rsi = (int64_t) esi;
    rax = *(reloc.socket_type_table);
    esi = *((rax + rsi*4));
    rdi >>= 1;
    rdi = (int64_t) edi;
    rax = *(reloc.socket_domain_table);
    edi = *((rax + rdi*4));
    eax = socketpair ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "socketpair";
        uerror ();
    }
    esi = 0;
    edi = 2;
    caml_alloc_small ();
    rdx = *(rsp);
    rdx = rdx + rdx + 1;
    *(rax) = rdx;
    rdx = *((rsp + 4));
    rdx = rdx + rdx + 1;
    *((rax + 8)) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4092a0 */
#include <stdint.h>
 
void socketpair (void) {
    socketpair ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4280e0 */
#include <stdint.h>
 
int64_t caml_alloc_small (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_18h;
    int64_t var_20h;
    rsi = arg2;
    rdi = arg1;
    rdx = rdi*8 + 8;
    *((rsp - 8)) = rbp;
    *((rsp - 0x10)) = rbx;
    rbx = rdi;
    rbp = -rbp;
    rax = rbp;
    rax += *(obj.caml_young_ptr);
    *(obj.caml_young_ptr) = rax;
    if (rax < *(obj.caml_young_limit)) {
        rax += rdx;
        *((rsp + 8)) = esi;
        *(obj.caml_young_ptr) = rax;
        caml_minor_collection ();
        rax = rbp;
        rax += *(obj.caml_young_ptr);
        esi = *((rsp + 8));
        *(obj.caml_young_ptr) = rax;
    }
    rbx <<= 0xa;
    rdx = rbx + rsi + 0x300;
    *(rax) = rdx;
    rax += 8;
    rbx = *((rsp + 0x18));
    rbp = *((rsp + 0x20));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427140 */
#include <stdint.h>
 
int64_t caml_minor_collection (void) {
    rbx = caml_allocated_words;
    caml_empty_minor_heap ();
    rax = caml_allocated_words;
    rax -= rbx;
    if (rax < 0) {
        goto label_0;
    }
    __asm ("cvtsi2sd xmm0, rax");
    do {
        __asm ("addsd xmm0, qword [obj.caml_stat_promoted_words]");
        edi = 0;
        *(obj.caml_stat_minor_collections)++;
        *(obj.caml_stat_promoted_words) = xmm0;
        caml_major_collection_slice ();
        *(obj.caml_force_major_slice) = 0;
        rax = caml_final_do_calls ();
        void (*0x426fc0)() ();
label_0:
        rdx = rax;
        eax &= 1;
        rdx >>= 1;
        rdx |= rax;
        __asm ("cvtsi2sd xmm0, rdx");
        __asm ("addsd xmm0, xmm0");
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420910 */
#include <stdint.h>
 
uint64_t unix_gmtime (void) {
    time_t * timer;
    __asm ("cvttsd2si rax, qword [rdi]");
    *((rsp + 8)) = rax;
    rax = gmtime (rsp + 8);
    if (rax == 0) {
        edx = 0;
        rsi = "gmtime";
        edi = 0x16;
        rax = unix_error ();
    }
    rdi = rax;
    alloc_tm ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409010 */
#include <stdint.h>
 
void gmtime (void) {
    gmtime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4206fc */
#include <stdint.h>
 
int64_t alloc_tm (tm * arg1) {
    rdi = arg1;
    rbx = rdi;
    esi = 0;
    edi = 9;
    caml_alloc_small ();
    rdx = *(rbx);
    rdx = rdx + rdx + 1;
    *(rax) = rdx;
    rdx = *((rbx + 4));
    rdx = rdx + rdx + 1;
    *((rax + 8)) = rdx;
    rdx = *((rbx + 8));
    rdx = rdx + rdx + 1;
    *((rax + 0x10)) = rdx;
    rdx = *((rbx + 0xc));
    rdx = rdx + rdx + 1;
    *((rax + 0x18)) = rdx;
    rdx = *((rbx + 0x10));
    rdx = rdx + rdx + 1;
    *((rax + 0x20)) = rdx;
    rdx = *((rbx + 0x14));
    rdx = rdx + rdx + 1;
    *((rax + 0x28)) = rdx;
    rdx = *((rbx + 0x18));
    rdx = rdx + rdx + 1;
    *((rax + 0x30)) = rdx;
    rdx = *((rbx + 0x1c));
    rdx = rdx + rdx + 1;
    *((rax + 0x38)) = rdx;
    rdx -= rdx;
    rdx &= 0xfffffffffffffffe;
    rdx += 3;
    *((rax + 0x40)) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b3f0 */
#include <stdint.h>
 
int64_t caml_ml_pos_in_64 (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    rdi = *((rax + 0x18));
    rdi += *((rax + 8));
    rdi -= *((rax + 0x20));
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434270 */
#include <stdint.h>
 
int64_t caml_alloc_custom (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rsi += 7;
    *((rsp - 0x20)) = rbx;
    rbx = rdi;
    rsi >>= 3;
    *((rsp - 0x18)) = rbp;
    *((rsp - 0x10)) = r12;
    rdi = rsi + 1;
    *((rsp - 8)) = r13;
    r12 = rcx;
    if (rdi <= 0x100) {
        if (*((rbx + 8)) != 0) {
            goto label_0;
        }
        esi = 0xff;
        caml_alloc_small ();
        *(rax) = rbx;
        rbx = *((rsp + 8));
        rbp = *((rsp + 0x10));
        r12 = *((rsp + 0x18));
        r13 = *((rsp + 0x20));
        return rax;
    }
label_0:
    esi = 0xff;
    rax = caml_alloc_shr ();
    rdi = rbp;
    r13 = rax;
    *(rax) = rbx;
    rsi = r12;
    caml_adjust_gc_speed ();
    rdi = r13;
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    r12 = *((rsp + 0x18));
    r13 = *((rsp + 0x20));
    return caml_check_urgent_gc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427d00 */
#include <stdint.h>
 
uint64_t caml_alloc_shr (int64_t arg2, uint32_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x20)) = rbp;
    *((rsp - 0x28)) = rbx;
    *((rsp - 0x18)) = r12;
    *((rsp - 0x10)) = r13;
    rbx = rdi;
    *((rsp - 8)) = r14;
    r12d = esi;
    if (rdi > rbp) {
        goto label_4;
    }
    rax = caml_fl_allocate ();
    if (rax == 0) {
        goto label_5;
    }
label_2:
    edx = caml_gc_phase;
    if (edx != 0) {
        goto label_6;
    }
label_1:
    rdx = rbx;
    rdx <<= 0xa;
    rdx = rdx + r12 + 0x300;
    *(rax) = rdx;
    do {
        rdx = caml_allocated_words;
        rcx = rbx + rdx + 1;
        rdx = caml_minor_heap_size;
        *(obj.caml_allocated_words) = rcx;
        rdx >>= 3;
        if (rcx > rdx) {
            *((rsp + 8)) = rax;
            caml_urge_major_slice ();
            rax = *((rsp + 8));
        }
        rax += 8;
        rbx = *((rsp + 0x10));
        rbp = *((rsp + 0x18));
        r12 = *((rsp + 0x20));
        r13 = *((rsp + 0x28));
        r14 = *((rsp + 0x30));
        return rax;
label_6:
        if (edx == 1) {
            goto label_7;
        }
label_0:
        rdx = rbx;
        rdx <<= 0xa;
        r12 += rdx;
        *(rax) = r12;
    } while (1);
label_7:
    if (rax < *(obj.caml_gc_sweep_hp)) {
        goto label_0;
    }
    goto label_1;
label_5:
    rax = rbx;
    rdx = 0x28f5c28f5c28f5c3;
    rax >>= 2;
    rdx:rax = rax * rdx;
    rdx >>= 2;
    rdx *= *(obj.caml_percent_free);
    rdi = rbx + rdx + 1;
    rdi <<= 3;
    rax = caml_round_heap_chunk_size ();
    rdi = rax;
    r13 = rax;
    rax = caml_alloc_for_heap ();
    r14 = rax;
    if (rax == 0) {
        goto label_8;
    }
    rdx = r13;
    rcx = rax;
    rdx >>= 3;
    rdx--;
    if (rdx <= rbp) {
        goto label_9;
    }
    rdi = r14 + 0x10;
    rsi = r14;
    rax = r14;
    rcx = 0x200000000000000;
    while (rdx > rbp) {
        rsi = rax;
        *(rax) = 0xfffffffffffffe00;
        rax += rcx;
        r13 -= rcx;
        rdx = rax + 8;
        *((rsi + 8)) = rdx;
        *(rdi) = rdx;
        rdx = r13;
        rdx >>= 3;
        rdx--;
    }
    rcx = rax;
label_9:
    if (r13 <= 1) {
        goto label_10;
    }
    rdx <<= 0xa;
    rdx += 0x200;
    *(rax) = rdx;
    rax = rcx + 8;
    *((r14 + 0x10)) = rax;
    *((rcx + 8)) = 0;
    do {
label_3:
        rdi = r14;
        eax = caml_add_to_heap ();
        if (eax != 0) {
            goto label_11;
        }
        rdi = r14;
        rdi += 8;
        if (rdi == 0) {
            goto label_12;
        }
        caml_fl_add_blocks ();
        rdi = rbx;
        caml_fl_allocate ();
        goto label_2;
label_10:
        *((rcx + 8)) = 0;
    } while (rdi != 0);
    *(rax) = 0;
    goto label_3;
label_8:
    edx = 0;
    esi = "No room for growing heap\n";
    edi = 4;
    rax = caml_gc_message ();
    do {
label_12:
        edx = caml_in_minor_collection;
        if (edx != 0) {
            edi = "Fatal error: out of memory.\n";
            caml_fatal_error ();
        }
label_4:
        caml_raise_out_of_memory ();
label_11:
        rdi = r14;
        caml_free_for_heap ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4277e0 */
#include <stdint.h>
 
int64_t caml_adjust_gc_speed (int64_t arg2, uint32_t arg1, int64_t arg7, int64_t arg8) {
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    eax = 1;
    if (rsi == 0) {
        rsi = rax;
    }
    if (rsi <= rdi) {
        rdi = rsi;
    }
    if (rdi < 0) {
        goto label_2;
    }
    __asm ("cvtsi2sd xmm0, rdi");
label_1:
    if (rsi < 0) {
        goto label_3;
    }
    __asm ("cvtsi2sd xmm1, rsi");
label_0:
    __asm ("divsd xmm0, xmm1");
    xmm1 = *(0x004364b8);
    __asm ("addsd xmm0, qword [obj.caml_extra_heap_resources]");
    *(obj.caml_extra_heap_resources) = xmm0;
    __asm ("ucomisd xmm0, xmm1");
    while (1) {
        rax = caml_minor_heap_size;
        rax >>= 3;
        __asm ("cvtsi2sd xmm1, rax");
        rax = caml_stat_heap_size;
        rax >>= 3;
        __asm ("cvtsi2sd xmm2, rax");
        __asm ("mulsd xmm1, qword [0x00436368]");
        __asm ("divsd xmm1, xmm2");
        __asm ("ucomisd xmm0, xmm1");
        if (rax > 0) {
            void (*0x424ae0)() ();
        }
        return rax;
        *(obj.caml_extra_heap_resources) = xmm1;
        caml_urge_major_slice ();
        xmm0 = caml_extra_heap_resources;
    }
label_3:
    rax = rsi;
    esi &= 1;
    rax >>= 1;
    rax |= rsi;
    __asm ("cvtsi2sd xmm1, rax");
    __asm ("addsd xmm1, xmm1");
    goto label_0;
label_2:
    rax = rdi;
    edi &= 1;
    rax >>= 1;
    rax |= rdi;
    __asm ("cvtsi2sd xmm0, rax");
    __asm ("addsd xmm0, xmm0");
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422d9c */
#include <stdint.h>
 
uint64_t unix_time (void) {
    rax = time (0);
    __asm ("cvtsi2sd xmm0, rax");
    caml_copy_double ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4097b0 */
#include <stdint.h>
 
void time (void) {
    time ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a120 */
#include <stdint.h>
 
int64_t caml_copy_double (int64_t arg7) {
    xmm0 = arg7;
    rax = caml_young_ptr;
    rdx = rax - 0x10;
    *(obj.caml_young_ptr) = rdx;
    if (rdx < *(obj.caml_young_limit)) {
        *(rsp) = xmm0;
        *(obj.caml_young_ptr) = rax;
        caml_minor_collection ();
        rdx = caml_young_ptr;
        xmm0 = *(rsp);
        rdx -= 0x10;
        *(obj.caml_young_ptr) = rdx;
    }
    *(rdx) = 0x7fd;
    rax = rdx + 8;
    *((rdx + 8)) = xmm0;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422bcd */
#include <stdint.h>
 
uint64_t unix_tcgetattr (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    rsi = obj_terminal_status;
    eax = tcgetattr ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "tcgetattr";
        uerror ();
    }
    edi = 0x26;
    rax = caml_alloc_tuple ();
    r15 = rax;
    rax = terminal_io_descr;
    if (rax == 4) {
        goto label_1;
    }
    rdx = obj_terminal_io_descr;
    r13d = 0;
    r12 = obj_speedtable;
    r14 = 0x0064dff0;
label_0:
    rbx = rdx + 8;
    if (rax != 1) {
        if (rax <= 1) {
            if (rax == 0) {
                goto label_2;
            }
            goto label_3;
        }
        if (rax == 2) {
            goto label_4;
        }
        if (rax != 3) {
            goto label_3;
        }
        goto label_5;
label_2:
        rdx = rbx + 8;
        rcx = *(rbx);
        rax = *(rdx);
        eax &= *(rcx);
        rax -= rax;
        rax &= 0xfffffffffffffffe;
        rax += 3;
        rbx = rdx + 8;
        *(rbp) = rax;
        goto label_3;
    }
    rax = *(rbx);
    r8 = *((rbx + 8));
    esi = *((rbx + 0x10));
    rdi = *((rbx + 0x18));
    rbx += 0x20;
    if (esi <= 0) {
        goto label_6;
    }
    edi &= *(rax);
    rdi = (int64_t) edi;
    eax = r13d;
    if (rdi != *(rbx)) {
        goto label_7;
    }
    while (esi > eax) {
        rcx = *((rdx + 0x30));
        rdx += 8;
        if (rcx == rdi) {
            eax += r8d;
            rax = (int64_t) eax;
            rax = rax + rax + 1;
            *(rbp) = rax;
        } else {
label_7:
            eax++;
        }
    }
label_6:
    rsi = (int64_t) esi;
    rbx = rbx + rsi*8;
    goto label_3;
label_4:
    edx = *(rbx);
    rbx += 8;
    *(rbp) = 0x4b01;
    if (edx != 0) {
        eax = r13d;
        if (edx != 1) {
            goto label_8;
        }
        rdi = obj_terminal_status;
        cfgetospeed ();
    } else {
        rdi = obj_terminal_status;
        eax = cfgetispeed ();
    }
label_8:
    rcx = 0x00435e48;
    edx = 1;
    if (*(r12) != eax) {
        goto label_9;
    }
    edx = r13d;
    while (edx != 0x12) {
label_9:
        if (*(rcx) == eax) {
            rdx = (int64_t) edx;
            rax = *((r12 + rdx*8 + 4));
            rax = rax + rax + 1;
            *(rbp) = rax;
            goto label_3;
        }
        edx++;
        rcx += 8;
    }
    goto label_3;
label_5:
    eax = *(rbx);
    rbx += 8;
    rax = (int64_t) eax;
    eax = *((r14 + rax + 1));
    rax = rax + rax + 1;
    *(rbp) = rax;
label_3:
    rax = *(rbx);
    if (rax != 4) {
        rbp += 8;
        rdx = rbx;
        goto label_0;
    }
label_1:
    rax = r15;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420b20 */
#include <stdint.h>
 
uint32_t unix_link (int64_t arg2) {
    rsi = arg2;
    rbx = rsi;
    eax = link ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = 0x00435c18;
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4091d0 */
#include <stdint.h>
 
void link (void) {
    link ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4223b9 */
#include <stdint.h>
 
int32_t unix_getsockopt (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r8 = rsi;
    rsi = rdi;
    rsi >>= 1;
    eax = esi;
    rdx >>= 1;
    rdx = (int64_t) edx;
    rdx <<= 3;
    rcx = obj_sockopt_table;
    rdx += *((rcx + rax*8));
    ecx = *((rdx + 4));
    rdi = obj_getsockopt_fun_name;
    rdi = *((rdi + rax*8));
    edx = *(rdx);
    unix_getsockopt_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422246 */
#include <stdint.h>
 
uint64_t unix_getsockopt_aux (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    void * optval;
    int64_t var_44h;
    int64_t var_50h;
    socklen_t * optlen;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    ebx = esi;
    esi = edx;
    edx = ecx;
    if (ebx <= 4) {
        ecx = ebx;
        rax = 0x00435ccc;
        rcx = *((rax + rcx*4));
        rax = rcx + rax;
        /* switch table (5 cases) at 0x435ccc */
        void (*rax)() ();
        *((rsp + 0x5c)) = 4;
        goto label_0;
        *((rsp + 0x5c)) = 8;
        goto label_0;
        *((rsp + 0x5c)) = 0x10;
    } else {
        edx = 0;
        rsi = rdi;
        edi = 0x16;
        unix_error ();
    }
label_0:
    rdi >>= 1;
    eax = getsockopt (r8, rsi, rdx, rsp + 0x40, rsp + 0x5c);
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = rbp;
        uerror ();
    }
    if (ebx <= 4) {
        rax = 0x00435ce0;
        rdx = *((rax + rbx*4));
        rax = rdx + rax;
        /* switch table (5 cases) at 0x435ce0 */
        void (*rax)() ();
        rax = *((rsp + 0x40));
        rax = rax + rax + 1;
        goto label_1;
        if (*((rsp + 0x40)) != 0) {
            esi = 0;
            edi = 1;
            caml_alloc_small ();
            rdx = *((rsp + 0x44));
            rdx = rdx + rdx + 1;
            *(rax) = rdx;
            goto label_1;
            __asm ("cvtsi2sd xmm1, qword [rsp + 0x40]");
            __asm ("cvtsi2sd xmm0, qword [rsp + 0x48]");
            __asm ("divsd xmm0, qword [0x00435b50]");
            __asm ("addsd xmm0, xmm1");
            caml_copy_double ();
            goto label_1;
            edi = *((rsp + 0x40));
            if (edi == 0) {
                goto label_2;
            }
            rax = unix_error_of_code ();
            *((rsp + 0x50)) = rax;
            rbx = *(reloc.caml_local_roots);
            rax = *(rbx);
            *(rsp) = rax;
            *(rbx) = rsp;
            *((rsp + 0x10)) = 1;
            *((rsp + 8)) = 1;
            rax = rsp + 0x50;
            *((rsp + 0x18)) = rax;
            esi = 0;
            edi = 1;
            caml_alloc_small ();
            rdx = *((rsp + 0x50));
            *(rax) = rdx;
            rdx = *(rsp);
            *(rbx) = rdx;
        } else {
            edx = 0;
            rsi = rbp;
            edi = 0x16;
            unix_error ();
        }
label_2:
        eax = 1;
    }
label_1:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ef40 */
#include <stdint.h>
 
uint64_t unix_alarm (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    eax = alarm ();
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409400 */
#include <stdint.h>
 
void alarm (void) {
    alarm ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b070 */
#include <stdint.h>
 
int64_t camlPrintf_cont_f_396 (int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rbx = *((rdi + 0x50));
    rax = *((rdi + 0x58));
    rdi = *(rbx);
    void (*rdi)(uint64_t, uint64_t) (rbx, rax);
    rdi = *(rsp);
    rdi += 0xffffffffffffff80;
    rax = *((rsp + 8));
    rbx = *((rsp + 0x10));
    return camlPrintf_doprn_392 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e2d0 */
#include <stdint.h>
 
int64_t camlPrintf_fun_630 (void) {
    int64_t var_8h;
    int64_t var_10h;
    *((rsp + 8)) = rax;
    *(rsp) = rbx;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_format_float);
    rax = caml_c_call ();
    *((rsp + 0x10)) = rax;
    rdi = *(rsp);
    rax = *(reloc.caml_classify_float);
    rax = caml_c_call ();
    if (rax >= 7) {
        rax = *((rsp + 0x10));
        return rax;
    }
    rax = *((rsp + 8));
    rbx = *((rsp + 0x10));
    return camlPrintf_valid_float_lexeme_298 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434ff4 */
#include <stdint.h>
 
uint64_t caml_ml_array_bound_error (void) {
    rax = sym_caml_array_bound_error;
    return caml_c_call ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f650 */
#include <stdint.h>
 
uint64_t caml_sys_get_argv (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    rbx = caml_local_roots;
    rdi = caml_exe_name;
    rax = rsp + 0x58;
    *((rsp + 0x58)) = 0;
    *((rsp + 0x50)) = 0;
    *((rsp + 0x48)) = 0;
    *(obj.caml_local_roots) = rsp;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x50;
    *(rsp) = rbx;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 3;
    *((rsp + 0x20)) = rax;
    rax = rsp + 0x48;
    *((rsp + 0x28)) = rax;
    rax = caml_copy_string ();
    rdi = caml_main_argv;
    *((rsp + 0x58)) = rax;
    rax = caml_copy_string_array ();
    esi = 0;
    edi = 2;
    *((rsp + 0x50)) = rax;
    rax = caml_alloc_small ();
    rdx = *((rsp + 0x58));
    *((rsp + 0x48)) = rax;
    *(obj.caml_local_roots) = rbx;
    *(rax) = rdx;
    rax = *((rsp + 0x48));
    rdx = *((rsp + 0x50));
    *((rax + 8)) = rdx;
    rax = *((rsp + 0x48));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428250 */
#include <stdint.h>
 
uint64_t caml_copy_string (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    *((rsp - 8)) = r12;
    eax = strlen (rdi);
    r12 = (int64_t) eax;
    rdi = r12;
    rax = caml_alloc_string ();
    rbx = rax;
    memmove (rax, rbp, r12);
    rax = rbx;
    rbp = *((rsp + 8));
    rbx = *(rsp);
    r12 = *((rsp + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409100 */
#include <stdint.h>
 
void strlen (void) {
    strlen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428170 */
#include <stdint.h>
 
int64_t caml_alloc_string (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    rbx = rdi + 8;
    *((rsp - 0x10)) = rbp;
    *((rsp - 8)) = r12;
    rbx >>= 3;
    if (rbx > 0x100) {
        goto label_1;
    }
    rdx = rbx*8 + 8;
    r12 = rdx;
    r12 = -r12;
    rax = r12;
    rax += *(obj.caml_young_ptr);
    *(obj.caml_young_ptr) = rax;
    while (1) {
        rdx = rbx;
        rdx <<= 0xa;
        rdx += 0x3fc;
        *(rax) = rdx;
        rax += 8;
label_0:
        rbx <<= 3;
        rdx = rbx - 1;
        *((rax + rbx - 8)) = 0;
        dl -= bpl;
        *((rax + rbx - 1)) = dl;
        rbx = *(rsp);
        rbp = *((rsp + 8));
        r12 = *((rsp + 0x10));
        return rax;
        rax += rdx;
        *(obj.caml_young_ptr) = rax;
        caml_minor_collection ();
        rax = r12;
        rax += *(obj.caml_young_ptr);
        *(obj.caml_young_ptr) = rax;
    }
label_1:
    rdi = rbx;
    esi = 0xfc;
    rax = caml_alloc_shr ();
    rdi = rax;
    caml_check_urgent_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428500 */
#include <stdint.h>
 
void caml_copy_string_array (int64_t arg1) {
    rdi = arg1;
    rsi = rdi;
    edi = caml_copy_string;
    return caml_alloc_array ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a820 */
#include <stdint.h>
 
uint64_t camlUnix_get_port_765 (int64_t arg_20h, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    r12 = rax;
    rsi = *(loc.camlUnix__213);
    rdi = *((rbp + 0x18));
    rax = caml_string_equal ();
    if (rax != 1) {
label_1:
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_2;
        }
        rbx = r15 + 8;
        *((rbx - 8)) = 0x800;
        *(rbx) = r12;
        *((rbx + 8)) = 1;
        rax = rbx + 0x18;
        *((rax - 8)) = 0x800;
        *(rax) = rbx;
        *((rax + 8)) = 1;
        return rax;
    }
    *(rsp) = rbp;
    *((rsp + 8)) = rbx;
    *((rsp + 0x10)) = r12;
    rax = void (*0x40a954)() ();
    rdi = *(reloc.caml_exn_Failure);
    rbx = *(rax);
    if (rbx == rdi) {
        rax = void (*0x40a8d8)() ();
        rdi = *(reloc.caml_exn_Not_found);
        rbx = *(rax);
        if (rbx == rdi) {
            rax = 1;
            return rax;
        }
        rax = caml_raise_exn ();
        r14 = rsp;
        rax = *((rsp + 0x10));
        rdi = *((rax + 0x18));
        rsi = *((rsp + 0x18));
        rax = *(reloc.unix_getservbyname);
        rax = caml_c_call ();
        rax += 0x10;
        rdi = *(rax);
label_0:
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_3;
        }
        rbx = r15 + 8;
        *((rbx - 8)) = 0x800;
        rax = *((rsp + 0x20));
        *(rbx) = rax;
        *((rbx + 8)) = rdi;
        rax = rbx + 0x18;
        *((rax - 8)) = 0x800;
        *(rax) = rbx;
        *((rax + 8)) = 1;
        return rax;
    }
    rax = caml_raise_exn ();
    r14 = rsp;
    rdi = *((rbp + 0x18));
    rax = *(reloc.caml_int_of_string);
    rax = caml_c_call ();
    rdi = rax;
    do {
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            rax = *((rsp + 0x20));
            *(rbx) = rax;
            *((rbx + 8)) = rdi;
            rax = rbx + 0x18;
            *((rax - 8)) = 0x800;
            *(rax) = rbx;
            *((rax + 8)) = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a960 */
#include <stdint.h>
 
int64_t caml_string_equal (uint32_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    if (rdi == rsi) {
        goto label_1;
    }
    rax = *((rdi - 8));
    rdx = *((rsi - 8));
    rax >>= 0xa;
    rdx >>= 0xa;
    if (rax != rdx) {
label_0:
        eax = 1;
        return rax;
    }
    if (rax != 0) {
        goto label_2;
    }
    goto label_1;
    do {
        rax--;
        if (rax == 0) {
            goto label_1;
        }
        rdi += 8;
        rsi += 8;
label_2:
        rdx = *(rsi);
    } while (*(rdi) == rdx);
    goto label_0;
label_1:
    eax = 3;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4211c0 */
#include <stdint.h>
 
int64_t unix_readlink (int64_t arg1) {
    int64_t canary;
    rdi = arg1;
    rbx = rdi;
    rax = *(fs:0x28);
    *((rsp + 0x1008)) = rax;
    eax = 0;
    rsi = rsp;
    edx = 0xfff;
    eax = readlink ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "readlink";
        uerror ();
    }
    rax = (int64_t) eax;
    *((rsp + rax)) = 0;
    rdi = rsp;
    caml_copy_string ();
    rdx = *((rsp + 0x1008));
    rdx ^= *(fs:0x28);
    if (eax != 0xffffffff) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fc78 */
#include <stdint.h>
 
uint32_t unix_getgroups (void) {
    rsi = rsp;
    edi = 0x10000;
    eax = getgroups ();
    ebx = eax;
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "getgroups";
        eax = uerror ();
    }
    rdi = (int64_t) eax;
    caml_alloc_tuple ();
    if (ebx <= 0) {
        goto label_0;
    }
    ebx--;
    rsi = rbx*4 + 4;
    edx = 0;
    rbx = rsp;
    do {
        ecx = *((rbx + rdx));
        rcx = rcx + rcx + 1;
        *((rax + rdx*2)) = rcx;
        rdx += 4;
    } while (rdx != rsi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42290c */
#include <stdint.h>
 
uint64_t unix_tcflush (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    rsi = (int64_t) esi;
    rax = obj_queue_flag_table;
    esi = *((rax + rsi*4));
    rdi >>= 1;
    eax = tcflush ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "tcflush";
        uerror ();
    }
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4090d0 */
#include <stdint.h>
 
void tcflush (void) {
    tcflush ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f830 */
#include <stdint.h>
 
void caml_sys_exit (int64_t status) {
    rdi = status;
    rdi >>= 1;
    return exit (rdi);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408f10 */
#include <stdint.h>
 
void exit (void) {
    exit ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428c20 */
#include <stdint.h>
 
uint64_t caml_compare (void) {
    edx = 1;
    rax = compare_val ();
    rbx = rax;
    if (*(obj.compare_stack) != 0x652500) {
        compare_free_stack ();
    }
    rax = 0xffffffffffffffff;
    if (rbx >= 0) {
        rax -= rax;
        rax &= 0xfffffffffffffffe;
        rax += 3;
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f5c0 */
#include <stdint.h>
 
uint64_t unix_getaddrinfo (int64_t arg3, char * arg2, char * arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    char * var_30h;
    char * src;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_80h;
    int64_t var_88h;
    int64_t var_90h;
    int64_t var_98h;
    int64_t var_a0h;
    int64_t var_a8h;
    int64_t var_c0h;
    int64_t var_c8h;
    int64_t var_d0h;
    int64_t var_d8h;
    int64_t var_e0h;
    int64_t var_e8h;
    int64_t var_100h;
    int64_t var_104h;
    int64_t var_108h;
    int64_t var_10ch;
    int64_t var_138h;
    int64_t var_140h;
    int64_t var_148h;
    int64_t var_150h;
    int64_t var_158h;
    int64_t var_160h;
    int64_t var_168h;
    int64_t var_170h;
    int64_t canary;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x38)) = rdi;
    *((rsp + 0x30)) = rsi;
    *((rsp + 0x28)) = rdx;
    rdx = *(fs:0x28);
    *((rsp + 0x1e8)) = rdx;
    edx = 0;
    rdx = *(reloc.caml_local_roots);
    rcx = *(rdx);
    *((rsp + 0x20)) = rcx;
    *((rsp + 0xc0)) = rcx;
    rcx = rsp + 0xc0;
    *((rsp + 0xd0)) = 1;
    *((rsp + 0xc8)) = 3;
    rbx = rsp + 0x38;
    *((rsp + 0xd8)) = rbx;
    rbx = rsp + 0x30;
    *((rsp + 0xe0)) = rbx;
    rbx = rsp + 0x28;
    *((rsp + 0xe8)) = rbx;
    *((rsp + 0x168)) = 0;
    *((rsp + 0x160)) = 0;
    *((rsp + 0x158)) = 0;
    *((rsp + 0x80)) = rcx;
    rcx = rsp + 0x80;
    *(rdx) = rcx;
    *((rsp + 0x90)) = 1;
    *((rsp + 0x88)) = 3;
    rdx = rsp + 0x168;
    *((rsp + 0x98)) = rdx;
    rdx = rsp + 0x160;
    *((rsp + 0xa0)) = rdx;
    rdx = rsp + 0x158;
    *((rsp + 0xa8)) = rdx;
    rax = caml_string_length ();
    ebx = 0;
    if (rax != 0) {
        rdi = rax + 1;
        rax = caml_stat_alloc ();
        rbx = rax;
        strcpy (rax, *((rsp + 0x38)));
    }
    rdi = *((rsp + 0x30));
    rax = caml_string_length ();
    if (rax != 0) {
        rdi = rax + 1;
        rax = caml_stat_alloc ();
        strcpy (rax, *((rsp + 0x30)));
    }
    rdx = rsp + 0x100;
    ecx = 6;
    eax = 0;
    rdi = rdx;
    do {
        *(rdi) = rax;
        rcx--;
        rdi += 8;
    } while (rcx != 0);
    rax = *((rsp + 0x28));
    if ((al & 1) != 0) {
        goto label_0;
    }
    do {
        rax = *(rax);
        *((rsp + 0x160)) = rax;
        if ((al & 1) == 0) {
            edx = *((rax - 8));
            if (dl != 1) {
                if (dl >= 1) {
                    if (dl != 2) {
                        goto label_1;
                    }
                    rdx = *(rax);
                    rdx >>= 1;
                    rdx = (int64_t) edx;
                    rax = *(reloc.socket_domain_table);
                    eax = *((rax + rdx*4));
                    *((rsp + 0x104)) = eax;
                } else {
                } else {
                    rdx = *(rax);
                    rdx >>= 1;
                    rdx = (int64_t) edx;
                    rax = *(reloc.socket_type_table);
                    eax = *((rax + rdx*4));
                    *((rsp + 0x108)) = eax;
                    goto label_1;
                }
            }
            rax = *(rax);
            rax >>= 1;
            *((rsp + 0x10c)) = eax;
        } else {
            rax >>= 1;
            if (eax != 1) {
                if (eax != 2) {
                    if (eax != 0) {
                        goto label_1;
                    }
                } else {
                } else {
                }
            }
        }
label_1:
        rax = *((rsp + 0x28));
        rax = *((rax + 8));
        *((rsp + 0x28)) = rax;
    } while ((al & 1) == 0);
label_0:
    caml_enter_blocking_section ();
    rcx = rsp + 0x150;
    rdx = rsp + 0x100;
    rsi = rbp;
    rdi = rbx;
    eax = getaddrinfo ();
    r12d = eax;
    caml_leave_blocking_section ();
    if (rbx != 0) {
        rdi = rbx;
        caml_stat_free ();
    }
    if (rbp != 0) {
        rdi = rbp;
        caml_stat_free ();
    }
    *((rsp + 0x168)) = 1;
    if (r12d != 0) {
        goto label_2;
    }
    rbx = *((rsp + 0x150));
    if (rbx == 0) {
        goto label_3;
    }
    r13 = *(reloc.caml_local_roots);
    r15 = rsp + 0x40;
    rax = rsp + 0x148;
    *((rsp + 8)) = rax;
    rdx = rsp + 0x140;
    *((rsp + 0x10)) = rdx;
    rcx = rsp + 0x138;
    *((rsp + 0x18)) = rcx;
    r14 = rsp + 0x170;
    do {
        r12 = *(r13);
        *((rsp + 0x148)) = 0;
        *((rsp + 0x140)) = 0;
        *((rsp + 0x138)) = 0;
        *((rsp + 0x40)) = r12;
        *(r13) = r15;
        *((rsp + 0x50)) = 1;
        *((rsp + 0x48)) = 3;
        rax = *((rsp + 8));
        *((rsp + 0x58)) = rax;
        rdx = *((rsp + 0x10));
        *((rsp + 0x60)) = rdx;
        rcx = *((rsp + 0x18));
        *((rsp + 0x68)) = rcx;
        ebp = *((rbx + 0x10));
        eax = 0x70;
        if (ebp > 0x70) {
        }
        edx = ebp;
        rsi = *((rbx + 0x18));
        ecx = 0x70;
        rdi = r14;
        memcpy_chk ();
        edx = 0xffffffff;
        esi = ebp;
        rdi = r14;
        rax = alloc_sockaddr ();
        *((rsp + 0x140)) = rax;
        rdi = *((rbx + 0x20));
        rdx = 0x00436cc1;
        if (rdi == 0) {
            rdi = rdx;
        }
        rax = caml_copy_string ();
        *((rsp + 0x138)) = rax;
        esi = 0;
        edi = 5;
        rax = caml_alloc_small ();
        *((rsp + 0x148)) = rax;
        edi = *((rbx + 4));
        ecx = 0;
        edx = 3;
        rsi = *(reloc.socket_domain_table);
        rax = cst_to_constr ();
        *(rbp) = rax;
        rbp = *((rsp + 0x148));
        rbp += 8;
        edi = *((rbx + 8));
        ecx = 0;
        edx = 4;
        rsi = *(reloc.socket_type_table);
        rax = cst_to_constr ();
        *(rbp) = rax;
        rax = *((rbx + 0xc));
        rdx = rax + rax + 1;
        rax = *((rsp + 0x148));
        *((rax + 0x10)) = rdx;
        rdx = *((rsp + 0x140));
        rax = *((rsp + 0x148));
        *((rax + 0x18)) = rdx;
        rdx = *((rsp + 0x138));
        rax = *((rsp + 0x148));
        *((rax + 0x20)) = rdx;
        rax = *(reloc.caml_local_roots);
        *(rax) = r12;
        rax = *((rsp + 0x148));
        *((rsp + 0x158)) = rax;
        esi = 0;
        edi = 2;
        rax = caml_alloc_small ();
        *((rsp + 0x160)) = rax;
        rdx = *((rsp + 0x158));
        *(rax) = rdx;
        rdx = *((rsp + 0x168));
        rax = *((rsp + 0x160));
        *((rax + 8)) = rdx;
        rax = *((rsp + 0x160));
        *((rsp + 0x168)) = rax;
        rbx = *((rbx + 0x28));
    } while (rbx != 0);
label_3:
    rdi = *((rsp + 0x150));
    freeaddrinfo ();
label_2:
    rax = *(reloc.caml_local_roots);
    rcx = *((rsp + 0x20));
    *(rax) = rcx;
    rax = *((rsp + 0x168));
    rdx = *((rsp + 0x1e8));
    rdx ^= *(fs:0x28);
    if (rbx != 0) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422624 */
#include <stdint.h>
 
uint32_t unix_lstat_64 (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    rdx = rsp;
    rsi = rdi;
    edi = 1;
    eax = lxstat64 ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "lstat";
        uerror ();
    }
    rsi = rsp;
    edi = 1;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4093b0 */
#include <stdint.h>
 
void lxstat64 (void) {
    lxstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4223f8 */
#include <stdint.h>
 
int64_t stat_aux (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    rsi = arg2;
    rdi = arg1;
    r12d = edi;
    rbx = rsi;
    rax = *(reloc.caml_local_roots);
    rbp = *(rax);
    *((rsp + 0x68)) = 0;
    *((rsp + 0x60)) = 0;
    *((rsp + 0x58)) = 0;
    *((rsp + 0x50)) = 0;
    *((rsp + 0x48)) = 0;
    *(rsp) = rbp;
    *(rax) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 5;
    rax = rsp + 0x68;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x60;
    *((rsp + 0x20)) = rax;
    rax = rsp + 0x58;
    *((rsp + 0x28)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x30)) = rax;
    rax = rsp + 0x48;
    *((rsp + 0x38)) = rax;
    __asm ("cvtsi2sd xmm0, qword [rsi + 0x48]");
    rax = caml_copy_double ();
    *((rsp + 0x68)) = rax;
    __asm ("cvtsi2sd xmm0, qword [rbx + 0x58]");
    rax = caml_copy_double ();
    *((rsp + 0x60)) = rax;
    __asm ("cvtsi2sd xmm0, qword [rbx + 0x68]");
    rax = caml_copy_double ();
    *((rsp + 0x58)) = rax;
    if (r12d != 0) {
        rdi = *((rbx + 0x30));
        caml_copy_int64 ();
    } else {
        rax = *((rbx + 0x30));
        rax = rax + rax + 1;
    }
    *((rsp + 0x50)) = rax;
    esi = 0;
    edi = 0xc;
    rax = caml_alloc_small ();
    *((rsp + 0x48)) = rax;
    rdx = *(rbx);
    rdx = rdx + rdx + 1;
    *(rax) = rdx;
    rax = *((rbx + 8));
    rdx = rax + rax + 1;
    rax = *((rsp + 0x48));
    *((rax + 8)) = rdx;
    r12 = *((rsp + 0x48));
    r12 += 0x10;
    edi = *((rbx + 0x18));
    edi &= 0xf000;
    ecx = 0;
    edx = 7;
    rsi = obj_file_kind_table;
    rax = cst_to_constr ();
    *(r12) = rax;
    eax = *((rbx + 0x18));
    eax &= 0xfff;
    rdx = rax + rax + 1;
    rax = *((rsp + 0x48));
    *((rax + 0x18)) = rdx;
    rax = *((rbx + 0x10));
    rdx = rax + rax + 1;
    rax = *((rsp + 0x48));
    *((rax + 0x20)) = rdx;
    eax = *((rbx + 0x1c));
    rdx = rax + rax + 1;
    rax = *((rsp + 0x48));
    *((rax + 0x28)) = rdx;
    eax = *((rbx + 0x20));
    rdx = rax + rax + 1;
    rax = *((rsp + 0x48));
    *((rax + 0x30)) = rdx;
    rax = *((rbx + 0x28));
    rdx = rax + rax + 1;
    rax = *((rsp + 0x48));
    *((rax + 0x38)) = rdx;
    rdx = *((rsp + 0x50));
    rax = *((rsp + 0x48));
    *((rax + 0x40)) = rdx;
    rdx = *((rsp + 0x68));
    rax = *((rsp + 0x48));
    *((rax + 0x48)) = rdx;
    rdx = *((rsp + 0x60));
    rax = *((rsp + 0x48));
    *((rax + 0x50)) = rdx;
    rdx = *((rsp + 0x58));
    rax = *((rsp + 0x48));
    *((rax + 0x58)) = rdx;
    rax = *(reloc.caml_local_roots);
    *(rax) = rbp;
    rax = *((rsp + 0x48));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d460 */
#include <stdint.h>
 
int64_t camlPrintf_fun_724 (void) {
    rax = *((rbx + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a0e0 */
#include <stdint.h>
 
int64_t caml_curry5_1 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry5_2);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423058 */
#include <stdint.h>
 
uint32_t unix_unlink (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    eax = unlink (rdi);
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "unlink";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a130 */
#include <stdint.h>
 
int64_t caml_curry5_2 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry5_3);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420950 */
#include <stdint.h>
 
uint64_t unix_isatty (int64_t fd) {
    rdi = fd;
    rdi >>= 1;
    eax = isatty (rdi);
    rax -= rax;
    rax &= 0xfffffffffffffffe;
    rax += 3;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408ec0 */
#include <stdint.h>
 
void isatty (void) {
    isatty ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a180 */
#include <stdint.h>
 
int64_t caml_curry5_3 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry5_4);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a1d0 */
#include <stdint.h>
 
int64_t caml_curry5_4 (void) {
    rdx = rax;
    rdi = *((rbx + 0x18));
    r8 = *((rdi + 0x18));
    rax = *((r8 + 0x18));
    rcx = *((rax + 0x18));
    rsi = *((rbx + 0x10));
    rdi = *((rdi + 0x10));
    rbx = *((r8 + 0x10));
    rax = *((rax + 0x10));
    r8 = *((rcx + 0x10));
    return void (*r8)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418900 */
#include <stdint.h>
 
int64_t camlHashtbl_find_all_238 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h_4;
    int64_t var_10h_4;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x10f7;
            rax = *(reloc.camlHashtbl__find_in_bucket_241);
            *(rsi) = rax;
            *((rsi + 8)) = 3;
            rax = *((rdi + 0x18));
            *((rsi + 0x10)) = rax;
            *((rsi + 0x18)) = rbx;
            rax = *((rdx + 8));
            rax = *((rax - 8));
            rax >>= 0xa;
            if (rax != 0) {
                rax = *((rdi + 0x20));
                rax = *((rax + 0x10));
                rsi = *((rax + 8));
                rdi = *(rsi);
                rax = rbx;
                rbx = rsi;
                rax = void (*rdi)(uint64_t, uint64_t) (rax, rsi);
                rbx = 0x7fffffffffffffff;
                rax &= rbx;
                rax >>= 1;
                rcx = *((rsp + 0x10));
                __asm ("cqo");
                rax = rdx:rax / rcx;
                rdx = rdx:rax % rcx;
            } else {
                rax = *(reloc.caml_bucket_Division_by_zero);
                caml_raise_exn ();
            }
            rdx <<= 1;
            rdx++;
            rax = *(rsp);
            rbx = *((rax + 8));
            rax = *((rbx - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_0;
            }
            rax = *((rbx + rdx*4 - 4));
            rbx = *((rsp + 8));
            void (*0x417d00)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x414de0 */
#include <stdint.h>
 
int64_t camlList_sort_299 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rax != 5) {
        *((rsp + 0x20)) = rdi;
        if (rax != 7) {
            goto label_7;
        }
        if (rbx == 1) {
            goto label_7;
        }
        rdx = *((rbx + 8));
        if (rdx == 1) {
            goto label_7;
        }
        rsi = *((rdx + 8));
        if (rsi == 1) {
            goto label_7;
        }
        rax = *(rsi);
        *(rsp) = rax;
        rsi = *(rdx);
        *((rsp + 8)) = rsi;
        rax = *(rbx);
        *((rsp + 0x10)) = rax;
        rdi = *((rdi + 0x38));
        rbx = rsi;
        rax = caml_apply2 ();
        if (rax <= 1) {
            rax = *((rsp + 0x20));
            rdi = *((rax + 0x38));
            rax = *((rsp + 8));
            rbx = *(rsp);
            rax = caml_apply2 ();
            if (rax <= 1) {
label_6:
                r15 -= 0x48;
                rax = *(reloc.caml_young_limit);
                if (r15 < *(rax)) {
                    goto label_8;
                }
                rbx = r15 + 8;
                *((rbx - 8)) = 0x800;
                rax = *(rsp);
                *(rbx) = rax;
                *((rbx + 8)) = 1;
                rdi = rbx + 0x18;
                *((rdi - 8)) = 0x800;
                rax = *((rsp + 8));
                *(rdi) = rax;
                *((rdi + 8)) = rbx;
                rbx += 0x30;
                *((rbx - 8)) = 0x800;
                rax = *((rsp + 0x10));
                *(rbx) = rax;
                *((rbx + 8)) = rdi;
                rax = rbx;
                return rax;
            }
            rax = *((rsp + 0x20));
            rdi = *((rax + 0x38));
            rax = *((rsp + 0x10));
            rbx = *(rsp);
            rax = caml_apply2 ();
            if (rax <= 1) {
label_5:
                r15 -= 0x48;
                rax = *(reloc.caml_young_limit);
                if (r15 < *(rax)) {
                    goto label_9;
                }
                rbx = r15 + 8;
                *((rbx - 8)) = 0x800;
                rax = *((rsp + 8));
                *(rbx) = rax;
                *((rbx + 8)) = 1;
                rdi = rbx + 0x18;
                *((rdi - 8)) = 0x800;
                rax = *(rsp);
                *(rdi) = rax;
                *((rdi + 8)) = rbx;
                rbx += 0x30;
                *((rbx - 8)) = 0x800;
                rax = *((rsp + 0x10));
                *(rbx) = rax;
                *((rbx + 8)) = rdi;
                rax = rbx;
                return rax;
            }
label_4:
            r15 -= 0x48;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_10;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            rax = *((rsp + 8));
            *(rbx) = rax;
            *((rbx + 8)) = 1;
            rdi = rbx + 0x18;
            *((rdi - 8)) = 0x800;
            rax = *((rsp + 0x10));
            *(rdi) = rax;
            *((rdi + 8)) = rbx;
            rbx += 0x30;
            *((rbx - 8)) = 0x800;
            rax = *(rsp);
            *(rbx) = rax;
            *((rbx + 8)) = rdi;
            rax = rbx;
            return rax;
        }
        rax = *((rsp + 0x20));
        rdi = *((rax + 0x38));
        rax = *((rsp + 0x10));
        rbx = *(rsp);
        rax = caml_apply2 ();
        if (rax <= 1) {
label_3:
            r15 -= 0x48;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_11;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            rax = *(rsp);
            *(rbx) = rax;
            *((rbx + 8)) = 1;
            rdi = rbx + 0x18;
            *((rdi - 8)) = 0x800;
            rax = *((rsp + 0x10));
            *(rdi) = rax;
            *((rdi + 8)) = rbx;
            rbx += 0x30;
            *((rbx - 8)) = 0x800;
            rax = *((rsp + 8));
            *(rbx) = rax;
            *((rbx + 8)) = rdi;
            rax = rbx;
            return rax;
        }
        rax = *((rsp + 0x20));
        rdi = *((rax + 0x38));
        rax = *((rsp + 8));
        rbx = *(rsp);
        rax = caml_apply2 ();
        if (rax <= 1) {
label_2:
            r15 -= 0x48;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_12;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            rax = *((rsp + 0x10));
            *(rbx) = rax;
            *((rbx + 8)) = 1;
            rdi = rbx + 0x18;
            *((rdi - 8)) = 0x800;
            rax = *(rsp);
            *(rdi) = rax;
            *((rdi + 8)) = rbx;
            rbx += 0x30;
            *((rbx - 8)) = 0x800;
            rax = *((rsp + 8));
            *(rbx) = rax;
            *((rbx + 8)) = rdi;
            rax = rbx;
            return rax;
        }
label_1:
        r15 -= 0x48;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_13;
        }
        rbx = r15 + 8;
        *((rbx - 8)) = 0x800;
        rax = *((rsp + 0x10));
        *(rbx) = rax;
        *((rbx + 8)) = 1;
        rdi = rbx + 0x18;
        *((rdi - 8)) = 0x800;
        rax = *((rsp + 8));
        *(rdi) = rax;
        *((rdi + 8)) = rbx;
        rbx += 0x30;
        *((rbx - 8)) = 0x800;
        rax = *(rsp);
        *(rbx) = rax;
        *((rbx + 8)) = rdi;
        rax = rbx;
        return rax;
    }
    if (rbx == 1) {
        goto label_14;
    }
    rsi = *((rbx + 8));
    if (rsi == 1) {
        goto label_15;
    }
    rsi = *(rsi);
    *(rsp) = rsi;
    rax = *(rbx);
    *((rsp + 8)) = rax;
    rdi = *((rdi + 0x38));
    rbx = rsi;
    rax = caml_apply2 ();
    if (rax > 1) {
        goto label_16;
    }
label_0:
    r15 -= 0x30;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_17;
    }
    rdi = r15 + 8;
    *((rdi - 8)) = 0x800;
    rax = *(rsp);
    *(rdi) = rax;
    *((rdi + 8)) = 1;
    rbx = rdi + 0x18;
    *((rbx - 8)) = 0x800;
    rax = *((rsp + 8));
    *(rbx) = rax;
    *((rbx + 8)) = rdi;
    rax = rbx;
    return rax;
    do {
label_16:
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x800;
            rax = *((rsp + 8));
            *(rdi) = rax;
            *((rdi + 8)) = 1;
            rbx = rdi + 0x18;
            *((rbx - 8)) = 0x800;
            rax = *(rsp);
            *(rbx) = rax;
            *((rbx + 8)) = rdi;
            rax = rbx;
            return rax;
label_15:
            *((rsp + 0x20)) = rdi;
            goto label_7;
label_14:
            *((rsp + 0x20)) = rdi;
label_7:
            *((rsp + 8)) = rbx;
            rdi = rax;
            rdi >>= 1;
            rdi |= 1;
            *(rsp) = rdi;
            rax -= rdi;
            rax++;
            *((rsp + 0x10)) = rax;
            rax = rdi;
            rax = camlList_chop_271 ();
            *((rsp + 0x18)) = rax;
            rdi = *((rsp + 0x20));
            rdi += 0x20;
            rax = *(rsp);
            rbx = *((rsp + 8));
            rax = camlList_rev_sort_300 ();
            *(rsp) = rax;
            rdi = *((rsp + 0x20));
            rdi += 0x20;
            rax = *((rsp + 0x10));
            rbx = *((rsp + 0x18));
            rax = camlList_rev_sort_300 ();
            rbx = rax;
            rax = *((rsp + 0x20));
            rsi = *((rax + 0x48));
            rdi = 1;
            rax = *(rsp);
            void (*0x4147c0)() ();
        }
        caml_call_gc ();
    } while (1);
label_17:
    caml_call_gc ();
    goto label_0;
label_13:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_call_gc ();
    goto label_2;
label_11:
    caml_call_gc ();
    goto label_3;
label_10:
    caml_call_gc ();
    goto label_4;
label_9:
    caml_call_gc ();
    goto label_5;
label_8:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415380 */
#include <stdint.h>
 
int64_t camlList_rev_append_79 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rax == 1) {
            goto label_1;
        }
        rdx = *((rax + 8));
        rsi = *(rax);
label_0:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_2;
        }
        rdi = r15 + 8;
        *((rdi - 8)) = 0x800;
        *(rdi) = rsi;
        *((rdi + 8)) = rbx;
        rax = rdx;
        rbx = rdi;
    } while (1);
label_1:
    rax = rbx;
    return rax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416100 */
#include <stdint.h>
 
int64_t camlList_chop_271 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rax == 1) {
            rax = rbx;
            return rax;
        }
        if (rbx == 1) {
            goto label_0;
        }
        rbx = *((rbx + 8));
        rax += 0xfffffffffffffffe;
    } while (1);
    do {
label_0:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *(reloc.caml_exn_Assert_failure);
            *(rax) = rbx;
            rbx = *(loc.camlList__39);
            *((rax + 8)) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4148d0 */
#include <stdint.h>
 
int64_t camlList_rev_sort_300 (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdi = arg1;
    if (rax != 5) {
        *((rsp + 0x20)) = rdi;
        if (rax != 7) {
            goto label_7;
        }
        if (rbx == 1) {
            goto label_7;
        }
        rdx = *((rbx + 8));
        if (rdx == 1) {
            goto label_7;
        }
        rsi = *((rdx + 8));
        if (rsi == 1) {
            goto label_7;
        }
        rax = *(rsi);
        *(rsp) = rax;
        rsi = *(rdx);
        *((rsp + 8)) = rsi;
        rax = *(rbx);
        *((rsp + 0x10)) = rax;
        rdi = *((rdi + 0x18));
        rbx = rsi;
        rax = caml_apply2 ();
        if (rax > 1) {
            rax = *((rsp + 0x20));
            rdi = *((rax + 0x18));
            rax = *((rsp + 8));
            rbx = *(rsp);
            rax = caml_apply2 ();
            if (rax > 1) {
label_6:
                r15 -= 0x48;
                rax = *(reloc.caml_young_limit);
                if (r15 < *(rax)) {
                    goto label_8;
                }
                rbx = r15 + 8;
                *((rbx - 8)) = 0x800;
                rax = *(rsp);
                *(rbx) = rax;
                *((rbx + 8)) = 1;
                rdi = rbx + 0x18;
                *((rdi - 8)) = 0x800;
                rax = *((rsp + 8));
                *(rdi) = rax;
                *((rdi + 8)) = rbx;
                rbx += 0x30;
                *((rbx - 8)) = 0x800;
                rax = *((rsp + 0x10));
                *(rbx) = rax;
                *((rbx + 8)) = rdi;
                rax = rbx;
                return rax;
            }
            rax = *((rsp + 0x20));
            rdi = *((rax + 0x18));
            rax = *((rsp + 0x10));
            rbx = *(rsp);
            rax = caml_apply2 ();
            if (rax > 1) {
label_5:
                r15 -= 0x48;
                rax = *(reloc.caml_young_limit);
                if (r15 < *(rax)) {
                    goto label_9;
                }
                rbx = r15 + 8;
                *((rbx - 8)) = 0x800;
                rax = *((rsp + 8));
                *(rbx) = rax;
                *((rbx + 8)) = 1;
                rdi = rbx + 0x18;
                *((rdi - 8)) = 0x800;
                rax = *(rsp);
                *(rdi) = rax;
                *((rdi + 8)) = rbx;
                rbx += 0x30;
                *((rbx - 8)) = 0x800;
                rax = *((rsp + 0x10));
                *(rbx) = rax;
                *((rbx + 8)) = rdi;
                rax = rbx;
                return rax;
            }
label_4:
            r15 -= 0x48;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_10;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            rax = *((rsp + 8));
            *(rbx) = rax;
            *((rbx + 8)) = 1;
            rdi = rbx + 0x18;
            *((rdi - 8)) = 0x800;
            rax = *((rsp + 0x10));
            *(rdi) = rax;
            *((rdi + 8)) = rbx;
            rbx += 0x30;
            *((rbx - 8)) = 0x800;
            rax = *(rsp);
            *(rbx) = rax;
            *((rbx + 8)) = rdi;
            rax = rbx;
            return rax;
        }
        rax = *((rsp + 0x20));
        rdi = *((rax + 0x18));
        rax = *((rsp + 0x10));
        rbx = *(rsp);
        rax = caml_apply2 ();
        if (rax > 1) {
label_3:
            r15 -= 0x48;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_11;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            rax = *(rsp);
            *(rbx) = rax;
            *((rbx + 8)) = 1;
            rdi = rbx + 0x18;
            *((rdi - 8)) = 0x800;
            rax = *((rsp + 0x10));
            *(rdi) = rax;
            *((rdi + 8)) = rbx;
            rbx += 0x30;
            *((rbx - 8)) = 0x800;
            rax = *((rsp + 8));
            *(rbx) = rax;
            *((rbx + 8)) = rdi;
            rax = rbx;
            return rax;
        }
        rax = *((rsp + 0x20));
        rdi = *((rax + 0x18));
        rax = *((rsp + 8));
        rbx = *(rsp);
        rax = caml_apply2 ();
        if (rax > 1) {
label_2:
            r15 -= 0x48;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_12;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            rax = *((rsp + 0x10));
            *(rbx) = rax;
            *((rbx + 8)) = 1;
            rdi = rbx + 0x18;
            *((rdi - 8)) = 0x800;
            rax = *(rsp);
            *(rdi) = rax;
            *((rdi + 8)) = rbx;
            rbx += 0x30;
            *((rbx - 8)) = 0x800;
            rax = *((rsp + 8));
            *(rbx) = rax;
            *((rbx + 8)) = rdi;
            rax = rbx;
            return rax;
        }
label_1:
        r15 -= 0x48;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_13;
        }
        rbx = r15 + 8;
        *((rbx - 8)) = 0x800;
        rax = *((rsp + 0x10));
        *(rbx) = rax;
        *((rbx + 8)) = 1;
        rdi = rbx + 0x18;
        *((rdi - 8)) = 0x800;
        rax = *((rsp + 8));
        *(rdi) = rax;
        *((rdi + 8)) = rbx;
        rbx += 0x30;
        *((rbx - 8)) = 0x800;
        rax = *(rsp);
        *(rbx) = rax;
        *((rbx + 8)) = rdi;
        rax = rbx;
        return rax;
    }
    if (rbx == 1) {
        goto label_14;
    }
    rsi = *((rbx + 8));
    if (rsi == 1) {
        goto label_15;
    }
    rsi = *(rsi);
    *(rsp) = rsi;
    rax = *(rbx);
    *((rsp + 8)) = rax;
    rdi = *((rdi + 0x18));
    rbx = rsi;
    rax = caml_apply2 ();
    if (rax <= 1) {
        goto label_16;
    }
label_0:
    r15 -= 0x30;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_17;
    }
    rdi = r15 + 8;
    *((rdi - 8)) = 0x800;
    rax = *(rsp);
    *(rdi) = rax;
    *((rdi + 8)) = 1;
    rbx = rdi + 0x18;
    *((rbx - 8)) = 0x800;
    rax = *((rsp + 8));
    *(rbx) = rax;
    *((rbx + 8)) = rdi;
    rax = rbx;
    return rax;
    do {
label_16:
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x800;
            rax = *((rsp + 8));
            *(rdi) = rax;
            *((rdi + 8)) = 1;
            rbx = rdi + 0x18;
            *((rbx - 8)) = 0x800;
            rax = *(rsp);
            *(rbx) = rax;
            *((rbx + 8)) = rdi;
            rax = rbx;
            return rax;
label_15:
            *((rsp + 0x20)) = rdi;
            goto label_7;
label_14:
            *((rsp + 0x20)) = rdi;
label_7:
            *((rsp + 8)) = rbx;
            rdi = rax;
            rdi >>= 1;
            rdi |= 1;
            *(rsp) = rdi;
            rax -= rdi;
            rax++;
            *((rsp + 0x10)) = rax;
            rax = rdi;
            rax = camlList_chop_271 ();
            *((rsp + 0x18)) = rax;
            rdi = *((rsp + 0x20));
            rdi += 0xffffffffffffffe0;
            rax = *(rsp);
            rbx = *((rsp + 8));
            rax = camlList_sort_299 ();
            *(rsp) = rax;
            rdi = *((rsp + 0x20));
            rdi += 0xffffffffffffffe0;
            rax = *((rsp + 0x10));
            rbx = *((rsp + 0x18));
            rax = camlList_sort_299 ();
            rbx = rax;
            rax = *((rsp + 0x20));
            rsi = *((rax + 0x20));
            rdi = 1;
            rax = *(rsp);
            void (*0x4146b0)() ();
        }
        caml_call_gc ();
    } while (1);
label_17:
    caml_call_gc ();
    goto label_0;
label_13:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_call_gc ();
    goto label_2;
label_11:
    caml_call_gc ();
    goto label_3;
label_10:
    caml_call_gc ();
    goto label_4;
label_9:
    caml_call_gc ();
    goto label_5;
label_8:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422dbc */
#include <stdint.h>
 
uint64_t unix_times (void) {
    esi = 0xfe;
    edi = 4;
    rax = caml_alloc_small ();
    rbx = rax;
    rsi = rsp;
    edi = 0;
    getrusage ();
    __asm ("cvtsi2sd xmm1, qword [rsp]");
    __asm ("cvtsi2sd xmm0, qword [rsp + 8]");
    __asm ("divsd xmm0, qword [0x00435b50]");
    __asm ("addsd xmm0, xmm1");
    *(rbx) = xmm0;
    __asm ("cvtsi2sd xmm1, qword [rsp + 0x10]");
    __asm ("cvtsi2sd xmm0, qword [rsp + 0x18]");
    __asm ("divsd xmm0, qword [0x00435b50]");
    __asm ("addsd xmm0, xmm1");
    *((rbx + 8)) = xmm0;
    rsi = rsp;
    edi = 0xffffffff;
    getrusage ();
    __asm ("cvtsi2sd xmm1, qword [rsp]");
    __asm ("cvtsi2sd xmm0, qword [rsp + 8]");
    __asm ("divsd xmm0, qword [0x00435b50]");
    __asm ("addsd xmm0, xmm1");
    *((rbx + 0x10)) = xmm0;
    __asm ("cvtsi2sd xmm1, qword [rsp + 0x10]");
    __asm ("cvtsi2sd xmm0, qword [rsp + 0x18]");
    __asm ("divsd xmm0, qword [0x00435b50]");
    __asm ("addsd xmm0, xmm1");
    *((rbx + 0x18)) = xmm0;
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408eb0 */
#include <stdint.h>
 
void getrusage (void) {
    getrusage ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a710 */
#include <stdint.h>
 
int64_t camlUnix_fun_1861 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x48;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdx = r15 + 8;
            *((rdx - 8)) = 0x801;
            *(rdx) = rsi;
            rax = *((rdi + 0x28));
            *((rdx + 8)) = rax;
            rax = rdx + 0x18;
            *((rax - 8)) = 0x1400;
            *(rax) = 3;
            rsi = *((rdi + 0x20));
            *((rax + 8)) = rsi;
            rdi = *((rdi + 0x18));
            rdi = *(rdi);
            *((rax + 0x10)) = rdi;
            *((rax + 0x18)) = rdx;
            *((rax + 0x20)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432610 */
#include <stdint.h>
 
uint64_t caml_register_named_value (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    ecx = 0;
    edx = 0;
    rsi = rdi;
    rbx = rdi;
    eax = *(rdi);
    if (al == 0) {
        goto label_0;
    }
    do {
        edx = rcx * 9;
        eax = (int32_t) al;
        rsi++;
        ecx = rcx + rdx*2;
        ecx = rax + rcx;
        eax = *(rsi);
    } while (al != 0);
    eax = ecx;
    edx = 0x4ec4ec4f;
    edx:eax = eax * edx;
    edx >>= 2;
    r13d = rdx * 3;
    edx = rdx + r13*4;
    ecx -= edx;
    edx = ecx;
label_0:
    r13d = ecx;
    r12 = *((r13*8 + obj.named_value_table));
    if (r12 != 0) {
        goto label_1;
    }
    goto label_2;
    do {
        r12 = *((r12 + 8));
        if (r12 == 0) {
            goto label_2;
        }
label_1:
        eax = strcmp (rbx, r12 + 0x10);
    } while (eax != 0);
    *(r12) = rbp;
    eax = 1;
    return eax;
label_2:
    strlen (rbx);
    rdi = rax + 0x18;
    rax = caml_stat_alloc ();
    r12 = rax;
    strcpy (rax + 0x10, rbx);
    rax = *((r13*8 + obj.named_value_table));
    *(r12) = rbp;
    rdi = r12;
    *((r12 + 8)) = rax;
    *((r13*8 + obj.named_value_table)) = r12;
    caml_register_global_root ();
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f7c0 */
#include <stdint.h>
 
uint64_t caml_sys_getenv (const char * name) {
    rdi = name;
    rax = getenv (rdi);
    if (rax != 0) {
        rdi = rax;
        void (*0x428250)() ();
    }
    return caml_raise_not_found ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x411e60 */
#include <stdint.h>
 
uint64_t camlArray_bubbledown_197 (int64_t arg1) {
    int64_t var_bp_18h;
    int64_t var_8h_4;
    int64_t var_10h_3;
    rdi = arg1;
    do {
        *((rsp + 8)) = rax;
        *((rsp + 0x10)) = rbx;
        *(rsp) = rdi;
        rdi = *((rdi + 0x20));
        rax = camlArray_maxson_182 ();
        rbx = rax;
        rbp = *(rsp);
        rdx = *((rbp + 0x18));
        rax = *((rdx - 8));
        rdi = *((rdx - 8));
        rdi &= 0xff;
        if (rdi != 0xfe) {
            rax >>= 9;
            if (rax <= rbx) {
                goto label_1;
            }
            rsi = *((rdx + rbx*4 - 4));
        } else {
            rax >>= 9;
            if (rax <= rbx) {
                goto label_2;
            }
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_3;
            }
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdx + rbx*4 - 4]");
            __asm ("movlpd qword [rsi], xmm0");
        }
        rdx = *((rbp + 0x18));
        rdi = *((rdx - 8));
        rax = *((rdx - 8));
        rax &= 0xff;
        if (rax != 0xfe) {
            rdi >>= 9;
            rax = *((rsp + 0x10));
            if (rdi <= rax) {
                goto label_4;
            }
            rdi = rdx + rax*4 - 4;
            caml_modify ();
        } else {
            rdi >>= 9;
            rax = *((rsp + 0x10));
            if (rdi <= rax) {
                goto label_5;
            }
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [rdx + rax*4 - 4], xmm0");
        }
        rax = *((rsp + 8));
        rdi = rbp;
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416880 */
#include <stdint.h>
 
uint64_t camlString_fun_188 (void) {
    rdi = *((rbx + 0x10));
    *(rdi) += 2;
    rsi = *((rbx + 0x18));
    rdi = *((rax - 8));
    rdi >>= 0xa;
    rdi = rdi*8 - 1;
    rax = *((rax + rdi));
    rdi -= rax;
    rax = *((rbx + 0x18));
    rax = *(rax);
    rax = rax + rdi*2;
    *(rsi) = rax;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4226ae */
#include <stdint.h>
 
uint64_t unix_fstat (int64_t arg1) {
    int64_t var_18h;
    signed int64_t var_30h;
    rdi = arg1;
    rdx = rsp;
    rsi = rdi;
    rsi >>= 1;
    edi = 1;
    eax = fxstat64 ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "fstat";
        uerror ();
    }
    rax = 0x3fffffffffffffff;
    if (*((rsp + 0x30)) > rax) {
        eax = *((rsp + 0x18));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        edx = 0;
        rsi = "fstat";
        edi = 0x4b;
        unix_error ();
    }
label_0:
    rsi = rsp;
    edi = 0;
    stat_aux ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420070 */
#include <stdint.h>
 
int64_t unix_getnameinfo (int64_t arg2, int64_t arg1) {
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_6ch;
    int64_t var_70h;
    int64_t var_1070h;
    int64_t var_1470h;
    int64_t canary;
    rsi = arg2;
    rdi = arg1;
    r12 = rsi;
    rax = *(fs:0x28);
    *((rsp + 0x14e8)) = rax;
    eax = 0;
    rax = *(reloc.caml_local_roots);
    rbx = *(rax);
    *((rsp + 0x60)) = 0;
    *((rsp + 0x58)) = 0;
    *((rsp + 0x50)) = 0;
    *((rsp + 0x10)) = rbx;
    rdx = rsp + 0x10;
    *(rax) = rdx;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 3;
    rax = rsp + 0x60;
    *((rsp + 0x28)) = rax;
    rax = rsp + 0x58;
    *((rsp + 0x30)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x38)) = rax;
    rdx = rsp + 0x6c;
    rbp = rsp + 0x1470;
    rsi = rbp;
    get_sockaddr ();
    rsi = obj_getnameinfo_flag_table;
    rdi = r12;
    eax = caml_convert_flag_list ();
    r12d = eax;
    caml_enter_blocking_section ();
    rdx = rsp + 0x70;
    *(rsp) = r12d;
    r9d = 0x400;
    r8 = rsp + 0x1070;
    ecx = 0x1000;
    esi = *((rsp + 0x6c));
    rdi = rbp;
    eax = getnameinfo ();
    caml_leave_blocking_section ();
    if (ebp != 0) {
        caml_raise_not_found ();
    }
    rdi = rsp + 0x70;
    rax = caml_copy_string ();
    *((rsp + 0x60)) = rax;
    rdi = rsp + 0x1070;
    rax = caml_copy_string ();
    *((rsp + 0x58)) = rax;
    esi = 0;
    edi = 2;
    rax = caml_alloc_small ();
    *((rsp + 0x50)) = rax;
    rdx = *((rsp + 0x60));
    *(rax) = rdx;
    rdx = *((rsp + 0x58));
    rax = *((rsp + 0x50));
    *((rax + 8)) = rdx;
    rax = *(reloc.caml_local_roots);
    *(rax) = rbx;
    rax = *((rsp + 0x50));
    rdx = *((rsp + 0x14e8));
    rdx ^= *(fs:0x28);
    if (ebp != 0) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420ae8 */
#include <stdint.h>
 
uint32_t unix_kill (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rdi = rsi;
    rdi >>= 1;
    eax = caml_convert_signal_number ();
    rbx >>= 1;
    eax = kill (ebx, eax);
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "kill";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424b00 */
#include <stdint.h>
 
int64_t caml_convert_signal_number (uint32_t arg1) {
    rdi = arg1;
    eax = edi;
    if (edi > 0xffffffea) {
        if (edi < 0) {
            goto label_0;
        }
    }
    return eax;
label_0:
    eax = ~eax;
    rax = (int64_t) eax;
    eax = *((rax*4 + obj.posix_signals));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409240 */
#include <stdint.h>
 
void kill (void) {
    kill ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421d8c */
#include <stdint.h>
 
int64_t unix_socket (int64_t protocol, int64_t type, int64_t domain) {
    rdx = protocol;
    rsi = type;
    rdi = domain;
    rdx >>= 1;
    rsi >>= 1;
    rsi = (int64_t) esi;
    rax = *(reloc.socket_type_table);
    rdi >>= 1;
    rdi = (int64_t) edi;
    rax = *(reloc.socket_domain_table);
    eax = socket (*((rax + rdi*4)), *((rax + rsi*4)), rdx);
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "socket";
        uerror ();
    }
    rax = (int64_t) eax;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4093c0 */
#include <stdint.h>
 
void socket (void) {
    socket ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40f9a0 */
#include <stdint.h>
 
int64_t camlPervasives_fun_524 (void) {
    rbx = *((rbx + 0x10));
    rax = 1;
    rdi = *(rbx);
    void (*rdi)(uint64_t) (rbx);
    rax = *(rsp);
    rbx = *((rax + 0x18));
    rax = 1;
    rdi = *(rbx);
    return void (*rdi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417ec0 */
#include <stdint.h>
 
int64_t camlHashtbl_mem_in_bucket_258 (void) {
    int64_t var_8h;
    do {
        if (rax == 1) {
            goto label_0;
        }
        *((rsp + 8)) = rbx;
        rdi = *((rax + 0x10));
        *(rsp) = rdi;
        rax = *(rax);
        rdi = *((rbx + 0x10));
        rdi = *(rdi);
        rbx = *((rbx + 0x18));
        rax = caml_apply2 ();
        if (rax != 1) {
            rax = 3;
            return rax;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
    } while (1);
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4122a0 */
#include <stdint.h>
 
int64_t camlArray_merge_218 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r11 = rax;
    r10 = rsi;
    rsi = r11 + rbx - 1;
    rbx = r10 + rdx - 1;
label_1:
    r15 -= 0x50;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_2;
    }
    rcx = r15 + 8;
    *((rcx - 8)) = 0x24f7;
    rax = *(reloc.caml_curry5);
    *(rcx) = rax;
    *((rcx + 8)) = 0xb;
    rax = *(reloc.camlArray__loop_228);
    *((rcx + 0x10)) = rax;
    rax = *((r9 + 0x18));
    *((rcx + 0x18)) = rax;
    rax = *((r9 + 0x20));
    *((rcx + 0x20)) = rax;
    *((rcx + 0x28)) = rdi;
    *((rcx + 0x30)) = rbp;
    *((rcx + 0x38)) = rsi;
    *((rcx + 0x40)) = rbx;
    rax = *((rdi - 8));
    rbx = *((rdi - 8));
    rbx &= 0xff;
    if (rbx != 0xfe) {
        rax >>= 9;
        if (rax <= r10) {
            goto label_3;
        }
        rsi = *((rdi + r10*4 - 4));
    } else {
        rax >>= 9;
        if (rax <= r10) {
            goto label_4;
        }
label_0:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_5;
        }
        rsi = r15 + 8;
        *((rsi - 8)) = 0x4fd;
        __asm ("movlpd xmm0, qword [rdi + r10*4 - 4]");
        __asm ("movlpd qword [rsi], xmm0");
    }
    rdi = *((r9 + 0x20));
    rax = *((rdi - 8));
    rbx = *((rdi - 8));
    rbx &= 0xff;
    if (rbx != 0xfe) {
        rax >>= 9;
        if (rax <= r11) {
            goto label_6;
        }
        rbx = *((rdi + r11*4 - 4));
        goto label_7;
    }
    rax >>= 9;
    if (rax <= r11) {
        goto label_8;
    }
    do {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdi + r11*4 - 4]");
            __asm ("movlpd qword [rbx], xmm0");
label_7:
            rax = r11;
            rdi = r10;
            rdx = r8;
            void (*0x4111a0)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
label_8:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b430 */
#include <stdint.h>
 
int64_t caml_ml_pos_in (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    rbx = *((rax + 0x18));
    rbx += *((rax + 8));
    rbx -= *((rax + 0x20));
    rax = 0x3fffffffffffffff;
    if (rbx > rax) {
        errno_location ();
        edi = 1;
        *(rax) = 0x4b;
        caml_sys_error ();
    }
    rax = rbx + rbx + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f840 */
#include <stdint.h>
 
int64_t caml_sys_error (char * arg1) {
    char * s2;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_98h;
    rdi = arg1;
    rax = caml_local_roots;
    *((rsp + 8)) = rdi;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x98)) = 0;
    *((rsp + 0x50)) = rax;
    rax = rsp + 8;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *((rsp + 0x68)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x10)) = rax;
    rax = rsp + 0x10;
    *(obj.caml_local_roots) = rax;
    rax = rsp + 0x98;
    *((rsp + 0x28)) = rax;
    rax = errno_location ();
    rax = strerror (*(rax));
    rbx = *((rsp + 8));
    if (rbx == 1) {
        goto label_0;
    }
    eax = strlen (rax);
    rdi = rbx;
    r12d = eax;
    eax = caml_string_length ();
    ebx = eax;
    edi = rbx + r12 + 2;
    rbx = (int64_t) ebx;
    rdi = (int64_t) edi;
    rax = caml_alloc_string ();
    rdi = rax;
    *((rsp + 0x98)) = rax;
    memmove (rdi, *((rsp + 8)), rbx);
    rax = rbx;
    rax += *((rsp + 0x98));
    rdx = (int64_t) r12d;
    *(rax) = 0x203a;
    rax = *((rsp + 0x98));
    memmove (rbx + rax + 2, rbp, rdx);
    rdi = *((rsp + 0x98));
    do {
        rax = caml_raise_sys_error ();
label_0:
        rdi = rax;
        rax = caml_copy_string ();
        rdi = rax;
        *((rsp + 0x98)) = rax;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f000 */
#include <stdint.h>
 
uint32_t unix_chmod (int64_t mode, int64_t arg1) {
    rsi = mode;
    rdi = arg1;
    rbx = rdi;
    rsi >>= 1;
    eax = chmod (rdi, rsi);
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = 0x00435ab9;
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408d00 */
#include <stdint.h>
 
void chmod (void) {
    chmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f3e4 */
#include <stdint.h>
 
int32_t unix_clear_close_on_exec (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    ebx = edi;
    edx = 0;
    esi = 1;
    eax = 0;
    eax = fcntl ();
    if (eax != 0xffffffff) {
        edx = eax;
        edx &= 0xfffffffe;
        esi = 2;
        edi = ebx;
        eax = 0;
        eax = fcntl ();
        if (eax != 0xffffffff) {
            goto label_0;
        }
    }
    esi = 0;
    rdi = "clear_close_on_exec";
    uerror ();
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418640 */
#include <stdint.h>
 
uint64_t camlHashtbl_find_rec_221 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h_2;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rbx == 1) {
            goto label_0;
        }
        *((rsp + 0x10)) = rdi;
        *(rsp) = rax;
        rsi = *((rbx + 0x10));
        *((rsp + 8)) = rsi;
        rsi = *((rbx + 8));
        *((rsp + 0x18)) = rsi;
        rbx = *(rbx);
        rdi = *((rdi + 0x18));
        rdi = *(rdi);
        rax = caml_apply2 ();
        if (rax != 1) {
            rax = *((rsp + 0x18));
            return rax;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
        rdi = *((rsp + 0x10));
    } while (1);
    do {
label_0:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420d88 */
#include <stdint.h>
 
uint32_t unix_mkdir (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rsi >>= 1;
    eax = mkdir ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "mkdir";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4097a0 */
#include <stdint.h>
 
void mkdir (void) {
    mkdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c1a0 */
#include <stdint.h>
 
int64_t caml_ml_output (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_50h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rbx = rcx;
    rbx >>= 1;
    r13 = caml_local_roots;
    rax = caml_channel_mutex_lock;
    *((rsp + 8)) = rdx;
    rdx = rsp + 0x20;
    *((rsp + 0x18)) = rdi;
    *((rsp + 0x10)) = rsi;
    *(rsp) = rcx;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 0x18;
    *((rsp + 0x20)) = r13;
    *((rsp + 0x30)) = 1;
    *((rsp + 0x38)) = rdx;
    rdx = rsp + 0x10;
    *((rsp + 0x28)) = 4;
    *((rsp + 0x50)) = rsp;
    r12 = *((rdi + 8));
    *((rsp + 0x40)) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x48)) = rdx;
    if (rax != 0) {
        rdi = r12;
        void (*rax)() ();
    }
    if (rbx <= 0) {
        goto label_0;
    }
    rbp >>= 1;
    do {
        rsi = rbp;
        rsi += *((rsp + 0x10));
        rdx = rbx;
        rdi = r12;
        rax = caml_putblock ();
        rax = (int64_t) eax;
        rbx -= rax;
        rbp += rax;
    } while (rbx > 0);
label_0:
    rax = caml_channel_mutex_unlock;
    if (rax != 0) {
        rdi = r12;
        void (*rax)() ();
    }
    *(obj.caml_local_roots) = r13;
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x411b70 */
#include <stdint.h>
 
uint64_t camlArray_trickledown_187 (int64_t arg2, int64_t arg1) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_18h;
    int64_t var_20h;
    rsi = arg2;
    rdi = arg1;
    do {
        *((rsp + 8)) = rax;
        *((rsp + 0x18)) = rbx;
        *((rsp + 0x10)) = rdi;
        *(rsp) = rsi;
        rdi = *((rsi + 0x28));
        rax = camlArray_maxson_182 ();
        rdx = rax;
        *((rsp + 0x20)) = rdx;
        rbx = *(rsp);
        rsi = *((rbx + 0x20));
        rax = *((rsi - 8));
        rdi = *((rsi - 8));
        rdi &= 0xff;
        if (rdi != 0xfe) {
            rax >>= 9;
            if (rax <= rdx) {
                goto label_2;
            }
            rax = *((rsi + rdx*4 - 4));
        } else {
            rax >>= 9;
            if (rax <= rdx) {
                goto label_3;
            }
label_1:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_4;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rsi + rdx*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
        }
        rdi = *((rbx + 0x18));
        rbx = *((rsp + 0x10));
        rax = caml_apply2 ();
        if (rax <= 1) {
            goto label_5;
        }
        rbp = *(rsp);
        rdi = *((rbp + 0x20));
        rax = *((rdi - 8));
        rbx = *((rdi - 8));
        rbx &= 0xff;
        if (rbx != 0xfe) {
            rax >>= 9;
            rbx = *((rsp + 0x20));
            if (rax <= rbx) {
                goto label_6;
            }
            rsi = *((rdi + rbx*4 - 4));
        } else {
            rax >>= 9;
            rbx = *((rsp + 0x20));
            if (rax <= rbx) {
                goto label_7;
            }
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_8;
            }
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdi + rbx*4 - 4]");
            __asm ("movlpd qword [rsi], xmm0");
        }
        rdx = *((rbp + 0x20));
        rdi = *((rdx - 8));
        rax = *((rdx - 8));
        rax &= 0xff;
        if (rax != 0xfe) {
            rdi >>= 9;
            rax = *((rsp + 0x18));
            if (rdi <= rax) {
                goto label_9;
            }
            rdi = rdx + rax*4 - 4;
            caml_modify ();
        } else {
            rdi >>= 9;
            rax = *((rsp + 0x18));
            if (rdi <= rax) {
                goto label_10;
            }
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [rdx + rax*4 - 4], xmm0");
        }
        rax = *((rsp + 8));
        rdi = *((rsp + 0x10));
        rsi = rbp;
    } while (1);
label_5:
    rax = *(rsp);
    rsi = *((rax + 0x20));
    rdi = *((rsi - 8));
    rax = *((rsi - 8));
    rax &= 0xff;
    if (rax != 0xfe) {
        rdi >>= 9;
        rax = *((rsp + 0x18));
        if (rdi <= rax) {
            goto label_11;
        }
        rdi = rsi + rax*4 - 4;
        rsi = *((rsp + 0x10));
        caml_modify ();
    } else {
        rdi >>= 9;
        rbx = *((rsp + 0x18));
        if (rdi <= rbx) {
            goto label_12;
        }
        rax = *((rsp + 0x10));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rsi + rbx*4 - 4], xmm0");
    }
    rax = 1;
    return rax;
label_8:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429fb0 */
#include <stdint.h>
 
int64_t caml_format_float (int64_t arg2, int64_t arg1) {
    int64_t var_178h;
    rsi = arg2;
    rdi = arg1;
    r13 = rsi;
    r12 = rdi;
    rbx = rdi;
    rax = *(fs:0x28);
    *((rsp + 0x178)) = rax;
    eax = 0;
    eax = *(rdi);
    if (al != 0) {
        goto label_0;
    }
    goto label_1;
    do {
        rbx++;
        eax = *(rbx);
        if (al == 0) {
            goto label_1;
        }
label_0:
        eax -= 0x30;
    } while (al > 9);
    strtol (rbx, 0, 0xa);
    ebp = rax + 0x15e;
    eax = 0x15e;
    if (ebp < 0x15e) {
    }
    eax = *(rbx);
    if (al != 0) {
        goto label_2;
    }
    goto label_3;
    do {
        rbx++;
        eax = *(rbx);
        if (al == 0) {
            goto label_3;
        }
label_2:
    } while (al != 0x2e);
    eax = strtol (rbx + 1, 0, 0xa);
    eax += 0x15e;
    edx = ebp;
    if (ebp >= eax) {
        goto label_4;
    }
    edx = eax;
    do {
label_4:
        if (edx > 0x171) {
            rdi = (int64_t) ebp;
            rax = caml_stat_alloc ();
            xmm0 = *(r13);
            rbx = rax;
            rdi = rax;
            rcx = r12;
            rdx = 0xffffffffffffffff;
            esi = 1;
            eax = 1;
            sprintf_chk ();
            rdi = rbx;
            rax = caml_copy_string ();
            if (rbx == rsp) {
                goto label_5;
            }
            rdi = rbx;
            caml_stat_free ();
        } else {
label_1:
            xmm0 = *(r13);
            rcx = r12;
            edx = 0x172;
            esi = 1;
            rdi = rsp;
            eax = 1;
            sprintf_chk ();
            rdi = rsp;
            rax = caml_copy_string ();
        }
label_5:
        rdx = *((rsp + 0x178));
        rdx ^= *(fs:0x28);
        rax = rbp;
        if (rbx != rsp) {
            goto label_6;
        }
        return rax;
label_3:
        edx = ebp;
    } while (1);
label_6:
    return stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41efdc */
#include <stdint.h>
 
uint32_t unix_chdir (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    eax = chdir ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "chdir";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408d40 */
#include <stdint.h>
 
void chdir (void) {
    chdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4144d0 */
#include <stdint.h>
 
int64_t camlList_find_235 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
label_0:
        if (rbx == 1) {
            goto label_2;
        }
        rax = *((rbx + 8));
        rax = *(rbx);
        rbx = *((rdi + 0x18));
        rdi = *(rbx);
        rax = void (*rdi)(uint64_t, uint64_t) (rdi, rax);
        if (rax == 1) {
            goto label_3;
        }
label_1:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_4;
        }
        rax = r15 + 8;
        *((rax - 8)) = 0x800;
        rbx = *(rsp);
        *(rax) = rbx;
        rbx = *((rsp + 8));
        *((rax + 8)) = rbx;
        rbx = *((rsp + 0x10));
        rdi = *((rsp + 0x18));
    } while (1);
label_3:
    rax = *((rsp + 8));
    rbx = *((rsp + 0x10));
    rdi = *((rsp + 0x18));
    goto label_0;
label_2:
    rbx = 1;
    void (*0x415380)() ();
label_4:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4183b0 */
#include <stdint.h>
 
uint64_t camlHashtbl_safehash_205 (void) {
    rbx = *((rbx + 0x10));
    rbx = *((rbx + 8));
    rdi = *(rbx);
    rax = void (*rdi)() ();
    rbx = 0x7fffffffffffffff;
    rax &= rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a3e0 */
#include <stdint.h>
 
int64_t caml_curry2 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry2_1);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a320 */
#include <stdint.h>
 
int64_t caml_curry3 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry3_1);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f558 */
#include <stdint.h>
 
uint32_t unix_ftruncate_64 (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi = *((rsi + 8));
    rdi >>= 1;
    eax = ftruncate64 ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "ftruncate";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4092e0 */
#include <stdint.h>
 
void ftruncate64 (void) {
    ftruncate64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a200 */
#include <stdint.h>
 
int64_t caml_curry4 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry4_1);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a090 */
#include <stdint.h>
 
int64_t caml_curry5 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry5_1);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409ec0 */
#include <stdint.h>
 
int64_t caml_curry6 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry6_1);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409f10 */
#include <stdint.h>
 
int64_t caml_curry6_1 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry6_2);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409f60 */
#include <stdint.h>
 
int64_t caml_curry6_2 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry6_3);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409ca0 */
#include <stdint.h>
 
int64_t caml_curry7 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry7_1);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4168c0 */
#include <stdint.h>
 
int64_t camlString_fun_191 (void) {
    rdi = *((rbx + 0x10));
    rax = *((rdi - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rdi = *((rdi + rax));
    rax -= rdi;
    r8 = rax + rax + 1;
    rax = *((rbx + 0x20));
    rcx = *(rax);
    rdx = *((rbx + 0x18));
    rsi = 1;
    rdi = *((rbx + 0x10));
    caml_blit_string ();
    rdx = *((rbx + 0x20));
    rsi = *((rbx + 0x10));
    rax = *((rsi - 8));
    rax >>= 0xa;
    rdi = rax*8 - 1;
    rax = *((rsi + rdi));
    rdi -= rax;
    rax = *((rbx + 0x20));
    rax = *(rax);
    rax = rax + rdi*2;
    *(rdx) = rax;
    rax = *((rbp - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rdi = *((rbp + rax));
    rax -= rdi;
    r8 = rax + rax + 1;
    rax = *((rbx + 0x20));
    rcx = *(rax);
    rdx = *((rbx + 0x18));
    rsi = 1;
    rdi = rbp;
    caml_blit_string ();
    rsi = *((rbx + 0x20));
    rax = *((rbp - 8));
    rax >>= 0xa;
    rdi = rax*8 - 1;
    rax = *((rbp + rdi));
    rdi -= rax;
    rax = *((rbx + 0x20));
    rax = *(rax);
    rax = rax + rdi*2;
    *(rsi) = rax;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409fb0 */
#include <stdint.h>
 
int64_t caml_curry6_3 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry6_4);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41c840 */
#include <stdint.h>
 
int64_t camlPrintf_scan_conv_325 (int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r8 = rax;
    r9 = rdi;
    rcx = rdx;
    rdx = rsi;
    rdx >>= 1;
    rax = *((rcx + 0x18));
    eax = *((rcx + 0x18));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a000 */
#include <stdint.h>
 
int64_t caml_curry6_4 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry6_5);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a050 */
#include <stdint.h>
 
int64_t caml_curry6_5 (void) {
    rcx = rax;
    rsi = *((rbx + 0x18));
    rdi = *((rsi + 0x18));
    r9 = *((rdi + 0x18));
    rax = *((r9 + 0x18));
    r8 = *((rax + 0x18));
    rdx = *((rbx + 0x10));
    rsi = *((rsi + 0x10));
    rdi = *((rdi + 0x10));
    rbx = *((r9 + 0x10));
    rax = *((rax + 0x10));
    r9 = *((r8 + 0x10));
    return void (*r9)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b1e0 */
#include <stdint.h>
 
int64_t camlPrintf_doprn_392 (int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        r11 = rax;
        rsi = rbx;
        rax = *((rdi + 0x100));
        if (rsi >= rax) {
            rbx = *((rdi + 0xe8));
            rax = *((rdi + 0xd8));
            rdi = *(rbx);
            void (*rdi)() ();
        }
        rbx = rsi;
        rbx >>= 1;
        rax = *((rdi + 0xf0));
        rax = *((rax + rbx));
        rbx = rax + rax + 1;
        if (rbx == 0x4b) {
            goto label_0;
        }
        *((rsp + 0x10)) = rdi;
        *(rsp) = rsi;
        *((rsp + 8)) = r11;
        rsi = *((rdi + 0xc0));
        rax = *((rdi + 0xd8));
        rdi = rsi;
        caml_apply2 ();
        rbx = *(rsp);
        rbx += 2;
        rax = *((rsp + 8));
        rdi = *((rsp + 0x10));
    } while (1);
label_0:
    r10 = rdi;
    r10 += 0xa0;
    r9 = rdi;
    r9 += 0x80;
    r8 = rdi;
    r8 += 0x60;
    rcx = rdi;
    rcx += 0x40;
    rdx = rdi;
    rdx += 0x20;
    rbx = *((rdi + 0xf8));
    rax = *((rdi + 0xf0));
    rdi = r11;
    return camlPrintf_scan_format_310 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4183e0 */
#include <stdint.h>
 
int64_t camlHashtbl_add_207 (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rsi = arg2;
    rdi = arg1;
    rdx = *((rax + 8));
    rdx = *((rdx - 8));
    rdx >>= 0xa;
    if (rdx != 0) {
        rdi = *((rsi + 0x18));
        rdi = *((rdi + 0x10));
        rsi = *((rdi + 8));
        rdi = *(rsi);
        rax = rbx;
        rbx = rsi;
        rax = void (*rdi)(uint64_t, uint64_t) (rdx, rdi);
        rbx = 0x7fffffffffffffff;
        rax &= rbx;
        rax >>= 1;
        rcx = *((rsp + 0x20));
        __asm ("cqo");
        rax = rdx:rax / rcx;
        rdx = rdx:rax % rcx;
    } else {
        rax = *(reloc.caml_bucket_Division_by_zero);
        caml_raise_exn ();
    }
    rdx <<= 1;
    rdx++;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0xc00;
            rax = *(rsp);
            *(rsi) = rax;
            rax = *((rsp + 8));
            *((rsi + 8)) = rax;
            rbx = *((rsp + 0x10));
            rdi = *((rbx + 8));
            rax = *((rdi - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_0;
            }
            rax = *((rdi + rdx*4 - 4));
            *((rsi + 0x10)) = rax;
            rdi = *((rbx + 8));
            rax = *((rdi - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_1;
            }
            rdi = rdi + rdx*4 - 4;
            caml_modify ();
            *(rbx) += 2;
            rax = *((rbx + 8));
            rax = *((rax - 8));
            rax >>= 9;
            rax |= 1;
            rdi = rax + rax - 1;
            rax = *(rbx);
            if (rax > rdi) {
                rax = *((rsp + 0x18));
                rax = *((rax + 0x18));
                void (*0x418e60)() ();
            }
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41c740 */
#include <stdint.h>
 
int64_t camlPrintf_loop_305 (void) {
    do {
        rdi = *((rbx + 0x20));
        if (rax >= rdi) {
            rdi = *((rbx + 0x18));
            rax = *((rbx + 0x10));
            rbx = rdi;
            void (*0x41c730)() ();
        }
        rcx = *((rbx + 0x18));
        rdx = rax;
        rdx >>= 1;
        rdi = *((rcx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rcx + rdi));
        rdi -= rsi;
        if (rdi <= rdx) {
            goto label_0;
        }
        rdi = *((rcx + rdx));
        rdi = rdi + rdi + 1;
        if (rdi == 0x5d) {
            goto label_1;
        }
        rax += 2;
    } while (1);
label_1:
    rax = *((rbx + 0x18));
    return rax;
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f436 */
#include <stdint.h>
 
int32_t unix_set_close_on_exec (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    ebx = edi;
    edx = 0;
    esi = 1;
    eax = 0;
    eax = fcntl ();
    if (eax != 0xffffffff) {
        edx = eax;
        edx |= 1;
        esi = 2;
        edi = ebx;
        eax = 0;
        eax = fcntl ();
        if (eax != 0xffffffff) {
            goto label_0;
        }
    }
    esi = 0;
    rdi = "set_close_on_exec";
    uerror ();
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ed9c */
#include <stdint.h>
 
int64_t unix_accept (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_40h;
    int64_t var_4ch;
    int64_t var_50h;
    int64_t canary;
    rdi = arg1;
    rbx = rdi;
    rax = *(fs:0x28);
    *((rsp + 0xc8)) = rax;
    eax = 0;
    *((rsp + 0x4c)) = 0x70;
    caml_enter_blocking_section ();
    rbx >>= 1;
    eax = accept (ebx, rsp + 0x50, rsp + 0x4c);
    caml_leave_blocking_section ();
    if (ebp == 0xffffffff) {
        esi = 0;
        rdi = "accept";
        uerror ();
    }
    rdi = rsp + 0x50;
    edx = ebp;
    esi = *((rsp + 0x4c));
    rax = alloc_sockaddr ();
    *((rsp + 0x40)) = rax;
    rbx = *(reloc.caml_local_roots);
    rax = *(rbx);
    *(rsp) = rax;
    *(rbx) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 1;
    rax = rsp + 0x40;
    *((rsp + 0x18)) = rax;
    esi = 0;
    edi = 2;
    caml_alloc_small ();
    rbp = (int64_t) ebp;
    rdx = rbp + rbp + 1;
    *(rax) = rdx;
    rdx = *((rsp + 0x40));
    *((rax + 8)) = rdx;
    rdx = *(rsp);
    *(rbx) = rdx;
    rdx = *((rsp + 0xc8));
    rdx ^= *(fs:0x28);
    if (ebp != 0xffffffff) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42078a */
#include <stdint.h>
 
int64_t unix_mktime (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    tm * timeptr;
    int64_t var_44h;
    int64_t var_48h;
    int64_t var_4ch;
    int64_t var_50h;
    int64_t var_54h;
    int64_t var_58h;
    int64_t var_5ch;
    int64_t var_60h;
    int64_t var_80h;
    int64_t var_88h;
    rdi = arg1;
    *((rsp + 0x88)) = 1;
    *((rsp + 0x80)) = 1;
    rax = *(reloc.caml_local_roots);
    rdx = *(rax);
    *(rsp) = rdx;
    *(rax) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 2;
    rax = rsp + 0x88;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x80;
    *((rsp + 0x20)) = rax;
    rax = *(rdi);
    rax >>= 1;
    *((rsp + 0x40)) = eax;
    rax = *((rdi + 8));
    rax >>= 1;
    *((rsp + 0x44)) = eax;
    rax = *((rdi + 0x10));
    rax >>= 1;
    *((rsp + 0x48)) = eax;
    rax = *((rdi + 0x18));
    rax >>= 1;
    *((rsp + 0x4c)) = eax;
    rax = *((rdi + 0x20));
    rax >>= 1;
    *((rsp + 0x50)) = eax;
    rax = *((rdi + 0x28));
    rax >>= 1;
    *((rsp + 0x54)) = eax;
    rax = *((rdi + 0x30));
    rax >>= 1;
    *((rsp + 0x58)) = eax;
    rax = *((rdi + 0x38));
    rax >>= 1;
    *((rsp + 0x5c)) = eax;
    *((rsp + 0x60)) = 0xffffffff;
    rax = mktime (rsp + 0x40);
    rbx = rax;
    if (rax == -1) {
        edx = 0;
        rsi = "mktime";
        edi = 0x22;
        unix_error ();
    }
    rdi = rsp + 0x40;
    rax = alloc_tm ();
    *((rsp + 0x88)) = rax;
    __asm ("cvtsi2sd xmm0, rbx");
    rax = caml_copy_double ();
    *((rsp + 0x80)) = rax;
    esi = 0;
    edi = 2;
    caml_alloc_small ();
    rdx = *((rsp + 0x80));
    *(rax) = rdx;
    rdx = *((rsp + 0x88));
    *((rax + 8)) = rdx;
    rcx = *(rsp);
    rdx = *(reloc.caml_local_roots);
    *(rdx) = rcx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408da0 */
#include <stdint.h>
 
void mktime (void) {
    mktime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fed1 */
#include <stdint.h>
 
int64_t unix_gethostbyaddr (int64_t arg_8h, int64_t arg_10h, int64_t arg_30h, int64_t arg_3ch, int64_t arg_40h, int64_t arg_50h, int64_t arg_2768h, int64_t arg1) {
    rdi = arg1;
    rax = *(fs:0x28);
    *((rsp + 0x2768)) = rax;
    eax = 0;
    eax = *(rdi);
    *((rsp + 0x40)) = eax;
    caml_enter_blocking_section ();
    rcx = rsp + 0x10;
    rdi = rsp + 0x40;
    rax = rsp + 0x3c;
    *((rsp + 8)) = rax;
    rax = rsp + 0x30;
    *(rsp) = rax;
    r9d = 0x2710;
    r8 = rsp + 0x50;
    edx = 2;
    esi = 4;
    eax = gethostbyaddr_r ();
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx != 0) {
        *((rsp + 0x30)) = 0;
    } else {
        rdi = *((rsp + 0x30));
        if (rdi != 0) {
            goto label_0;
        }
    }
    caml_raise_not_found ();
label_0:
    alloc_host_entry ();
    rdx = *((rsp + 0x2768));
    rdx ^= *(fs:0x28);
    if (rdi != 0) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418c10 */
#include <stdint.h>
 
int64_t camlHashtbl_mem_255 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x10f7;
            rax = *(reloc.camlHashtbl__mem_in_bucket_258);
            *(rsi) = rax;
            *((rsi + 8)) = 3;
            rax = *((rdi + 0x18));
            *((rsi + 0x10)) = rax;
            *((rsi + 0x18)) = rbx;
            rax = *((rdx + 8));
            rax = *((rax - 8));
            rax >>= 0xa;
            if (rax != 0) {
                rax = *((rdi + 0x20));
                rax = *((rax + 0x10));
                rsi = *((rax + 8));
                rdi = *(rsi);
                rax = rbx;
                rbx = rsi;
                rax = void (*rdi)(uint64_t, uint64_t) (rax, rsi);
                rbx = 0x7fffffffffffffff;
                rax &= rbx;
                rax >>= 1;
                rcx = *((rsp + 0x10));
                __asm ("cqo");
                rax = rdx:rax / rcx;
                rdx = rdx:rax % rcx;
            } else {
                rax = *(reloc.caml_bucket_Division_by_zero);
                caml_raise_exn ();
            }
            rdx <<= 1;
            rdx++;
            rax = *(rsp);
            rbx = *((rax + 8));
            rax = *((rbx - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_0;
            }
            rax = *((rbx + rdx*4 - 4));
            rbx = *((rsp + 8));
            void (*0x417ec0)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421cfd */
#include <stdint.h>
 
int64_t unix_sigprocmask (int64_t arg2, int64_t arg1) {
    int64_t var_80h;
    rsi = arg2;
    rdi = arg1;
    rax = rdi;
    rdi = rsi;
    rax >>= 1;
    rax = (int64_t) eax;
    rdx = obj_sigprocmask_cmd;
    ebp = *((rdx + rax*4));
    rbx = rsp + 0x80;
    rsi = rbx;
    decode_sigset ();
    caml_enter_blocking_section ();
    rdx = rsp;
    rsi = rbx;
    edi = ebp;
    eax = sigprocmask ();
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx == 0xffffffff) {
        esi = 0;
        rdi = "sigprocmask";
        uerror ();
    }
    rdi = rsp;
    encode_sigset ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409270 */
#include <stdint.h>
 
void sigprocmask (void) {
    sigprocmask ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421c1e */
#include <stdint.h>
 
int64_t encode_sigset (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_48h;
    rdi = arg1;
    r12 = rdi;
    *((rsp + 0x48)) = 1;
    rax = *(reloc.caml_local_roots);
    rdx = *(rax);
    *(rsp) = rdx;
    *(rax) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 1;
    rax = rsp + 0x48;
    *((rsp + 0x18)) = rax;
    ebx = 1;
    do {
        esi = 1;
        rdi = r12;
        eax = sigismember ();
        if (eax > 0) {
            esi = 0;
            edi = 2;
            rax = caml_alloc_small ();
            edi = ebx;
            caml_rev_convert_signal_number ();
            rax = (int64_t) eax;
            rax = rax + rax + 1;
            *(rbp) = rax;
            rax = *((rsp + 0x48));
            *((rbp + 8)) = rax;
            *((rsp + 0x48)) = rbp;
        }
        ebx++;
    } while (ebx != 0x41);
    rdx = *(rsp);
    rax = *(reloc.caml_local_roots);
    *(rax) = rdx;
    rax = *((rsp + 0x48));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420fc8 */
#include <stdint.h>
 
uint64_t unix_putenv (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x30)) = rbx;
    *((rsp - 0x28)) = rbp;
    *((rsp - 0x20)) = r12;
    *((rsp - 0x18)) = r13;
    *((rsp - 0x10)) = r14;
    *((rsp - 8)) = r15;
    r14 = rdi;
    r15 = rsi;
    rax = caml_string_length ();
    rdi = r15;
    rax = caml_string_length ();
    r13 = rax;
    r12 = rax + rbp;
    rdi = r12 + 2;
    rax = caml_stat_alloc ();
    rbx = rax;
    memmove (rax, r14, rbp);
    *((rbx + rbp)) = 0x3d;
    memmove (rbx + rbp + 1, r15, r13);
    *((rbx + r12 + 1)) = 0;
    rdi = rbx;
    eax = putenv ();
    if (eax == 0xffffffff) {
        rsi = r14;
        rdi = "putenv";
        uerror ();
    }
    eax = 1;
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    r12 = *((rsp + 0x18));
    r13 = *((rsp + 0x20));
    r14 = *((rsp + 0x28));
    r15 = *((rsp + 0x30));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a910 */
#include <stdint.h>
 
int64_t caml_string_length (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi - 8));
    rax >>= 0xa;
    rdx = rax*8;
    rax = rdx - 1;
    rdx = *((rdi + rdx - 1));
    rax -= rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427680 */
#include <stdint.h>
 
uint64_t caml_stat_alloc (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    rax = malloc (rdi);
    while (rbx == 0) {
        return rax;
    }
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409380 */
#include <stdint.h>
 
void putenv (void) {
    putenv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fe1b */
#include <stdint.h>
 
int64_t unix_gethostbyname (int64_t arg_28h, int64_t arg_30h, int64_t arg_2748h, int64_t arg1) {
    rdi = arg1;
    rax = *(fs:0x28);
    *((rsp + 0x2748)) = rax;
    eax = 0;
    caml_string_length ();
    rdi = rax + 1;
    rax = caml_stat_alloc ();
    rbx = rax;
    strcpy (rax, rbp);
    caml_enter_blocking_section ();
    rax = h_errno_location ();
    r9 = rax;
    rdx = rsp + 0x30;
    rsi = rsp;
    r8 = rsp + 0x28;
    ecx = 0x2710;
    rdi = rbx;
    eax = gethostbyname_r ();
    caml_leave_blocking_section ();
    if (ebp != 0) {
        *((rsp + 0x28)) = 0;
    }
    rdi = rbx;
    caml_stat_free ();
    rdi = *((rsp + 0x28));
    if (rdi == 0) {
        caml_raise_not_found ();
    }
    alloc_host_entry ();
    rdx = *((rsp + 0x2748));
    rdx ^= *(fs:0x28);
    if (rdi != 0) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f168 */
#include <stdint.h>
 
int64_t unix_dup (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    eax = dup ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = 0x00435a9b;
        uerror ();
    }
    rax = (int64_t) eax;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408f90 */
#include <stdint.h>
 
void dup (void) {
    dup ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f380 */
#include <stdint.h>
 
uint32_t unix_fchmod (int64_t mode, int64_t fd) {
    rsi = mode;
    rdi = fd;
    rsi >>= 1;
    rdi >>= 1;
    eax = fchmod (rdi, rsi);
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "fchmod";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409350 */
#include <stdint.h>
 
void fchmod (void) {
    fchmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b2c0 */
#include <stdint.h>
 
int64_t camlPrintf_parse_97 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
label_0:
        rsi = rax;
        rdx = *((rdi + 0x18));
        rax = *((rdx - 8));
        rax >>= 0xa;
        rax = rax*8 - 1;
        rdx = *((rdx + rax));
        rax -= rdx;
        rax = rax + rax + 1;
        if (rbx >= rax) {
label_2:
            r15 -= 0x18;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_3;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            *(rax) = 1;
            *((rax + 8)) = rsi;
            return rax;
        }
        rdx = rbx;
        rdx >>= 1;
        rax = *((rdi + 0x18));
        rax = *((rax + rdx));
        rax = rax + rax + 1;
        if (rax >= 0x63) {
            if (rax >= 0x75) {
                goto label_4;
            }
            *(rsp) = rsi;
            rdx = *((rdi + 0x18));
            rax = *((rdx - 8));
            rax >>= 0xa;
            rsi = rax*8 - 1;
            rax = *((rdx + rsi));
            rsi -= rax;
            rsi <<= 1;
            rsi -= rbx;
            rsi -= 3;
            rsi += 3;
            rax = *((rdi + 0x18));
            rdi = rsi;
            rax = camlString_sub_74 ();
            rdi = rax;
            rax = *(reloc.caml_int_of_string);
            rax = caml_c_call ();
            rdi = rax;
label_1:
            r15 -= 0x18;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_5;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            *(rbx) = rdi;
            rax = *(rsp);
            *((rbx + 8)) = rax;
            rax = rbx;
            return rax;
        }
        if (rax != 0x5b) {
            goto label_4;
        }
        rbx += 2;
        rax = 3;
    } while (1);
label_4:
    rbx += 2;
    rax = rsi;
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416a50 */
#include <stdint.h>
 
int64_t camlString_sub_74 (int64_t arg_8h_9, int64_t arg_10h_6, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, signed int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rbx >= 1) {
        if (rdi < 1) {
            goto label_0;
        }
        rsi = *((rax - 8));
        rsi >>= 0xa;
        rsi = rsi*8 - 1;
        rdx = *((rax + rsi));
        rsi -= rdx;
        rsi <<= 1;
        rsi -= rdi;
        rsi += 2;
        if (rbx > rsi) {
            goto label_0;
        }
        *((rsp + 0x10)) = rdi;
        *((rsp + 8)) = rbx;
        *(rsp) = rax;
        rax = *(reloc.caml_create_string);
        rax = caml_c_call ();
        rbx = rax;
        rcx = 1;
        rdi = *(rsp);
        rsi = *((rsp + 8));
        rdx = rbx;
        r8 = *((rsp + 0x10));
        caml_blit_string ();
        rax = rbx;
        return rax;
    }
label_0:
    rax = *(loc.camlString__32);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f214 */
#include <stdint.h>
 
uint64_t unix_execv (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rdi = rsi;
    eax = 0;
    rax = cstringvect ();
    rbx = rax;
    rsi = rax;
    rdi = rbp;
    execv ();
    rdi = rbx;
    caml_stat_free ();
    rsi = rbp;
    rdi = "execv";
    return uerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420333 */
#include <stdint.h>
 
uint64_t unix_getprotobynumber (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    rax = getprotobynumber ();
    if (rax == 0) {
        rax = caml_raise_not_found ();
    }
    rdi = rax;
    alloc_proto_entry ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409510 */
#include <stdint.h>
 
void getprotobynumber (void) {
    getprotobynumber ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423d30 */
#include <stdint.h>
 
void caml_raise_not_found (void) {
    edi = loc.caml_exn_Not_found;
    return caml_raise_constant ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420288 */
#include <stdint.h>
 
int64_t alloc_proto_entry (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_40h;
    int64_t var_48h;
    rdi = arg1;
    rbx = rdi;
    *((rsp + 0x48)) = 1;
    *((rsp + 0x40)) = 1;
    rbp = *(reloc.caml_local_roots);
    rax = *(rbp);
    *(rsp) = rax;
    *(rbp) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 2;
    rax = rsp + 0x48;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x40;
    *((rsp + 0x20)) = rax;
    rdi = *(rdi);
    rax = caml_copy_string ();
    *((rsp + 0x48)) = rax;
    rdi = *((rbx + 8));
    rax = caml_copy_string_array ();
    *((rsp + 0x40)) = rax;
    esi = 0;
    edi = 3;
    caml_alloc_small ();
    rdx = *((rsp + 0x48));
    *(rax) = rdx;
    rdx = *((rsp + 0x40));
    *((rax + 8)) = rdx;
    rdx = *((rbx + 0x10));
    rdx = rdx + rdx + 1;
    *((rax + 0x10)) = rdx;
    rdx = *(rsp);
    *(rbp) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422e78 */
#include <stdint.h>
 
uint32_t unix_truncate_64 (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rsi = *((rsi + 8));
    eax = truncate64 ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = 0x00435b0e;
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408e00 */
#include <stdint.h>
 
void truncate64 (void) {
    truncate64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429620 */
#include <stdint.h>
 
int64_t caml_int64_float_of_bits (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    *((rsp - 0x10)) = rax;
    xmm0 = *((rsp - 0x10));
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x411620 */
#include <stdint.h>
 
int64_t camlArray_tolist_150 (int64_t arg6, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        r8 = rax;
        if (r8 < 1) {
            rax = rbx;
            return rax;
        }
        rcx = *((rdi + 0x18));
        rsi = *((rcx - 8));
        if (rsi != 0xfe) {
            rdx = *((rcx + r8*4 - 4));
        } else {
label_1:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_2;
            }
            rdx = r15 + 8;
            *((rdx - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rcx + r8*4 - 4]");
            __asm ("movlpd qword [rdx], xmm0");
        }
label_0:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_3;
        }
        rsi = r15 + 8;
        *((rsi - 8)) = 0x800;
        *(rsi) = rdx;
        *((rsi + 8)) = rbx;
        rax = r8;
        rax += 0xfffffffffffffffe;
        rbx = rsi;
    } while (1);
label_3:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4143c0 */
#include <stdint.h>
 
int64_t camlList_rmap_f_98 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rbx == 1) {
            goto label_1;
        }
        rax = *((rbx + 8));
        rax = *(rbx);
        rbx = *((rdi + 0x18));
        rdi = *(rbx);
        rax = void (*rdi)(uint64_t, uint64_t) (rdi, rax);
        rbx = rax;
label_0:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_2;
        }
        rax = r15 + 8;
        *((rax - 8)) = 0x800;
        *(rax) = rbx;
        rbx = *(rsp);
        *((rax + 8)) = rbx;
        rbx = *((rsp + 8));
        rdi = *((rsp + 0x10));
    } while (1);
label_1:
    return rax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4293a0 */
#include <stdint.h>
 
int64_t caml_int64_format (int64_t arg2, int64_t arg1) {
    int64_t var_fh;
    int64_t var_10h;
    int64_t var_30h;
    int64_t var_58h;
    int64_t var_68h;
    int64_t var_70h;
    int64_t var_78h;
    int64_t canary;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x20)) = rbx;
    *((rsp - 0x18)) = rbp;
    *((rsp - 0x10)) = r12;
    *((rsp - 8)) = r13;
    r12 = rsp + 0x30;
    rbp = rsp + 0x10;
    r8 = rsp + 0xf;
    r13 = rsi;
    esi = 0x436e5b;
    rdx = r12;
    rcx = rbp;
    rax = *(fs:0x28);
    *((rsp + 0x58)) = rax;
    eax = 0;
    rax = parse_format ();
    r8 = *((r13 + 8));
    rbx = rax;
    rcx = r12;
    rdi = rax;
    rdx = 0xffffffffffffffff;
    esi = 1;
    eax = 0;
    sprintf_chk ();
    rdi = rbx;
    rax = caml_copy_string ();
    r12 = rax;
    if (rbx != rbp) {
        rdi = rbx;
        caml_stat_free ();
    }
    rdx = *((rsp + 0x58));
    rdx ^= *(fs:0x28);
    rax = r12;
    if (rbx == rbp) {
        rbx = *((rsp + 0x68));
        rbp = *((rsp + 0x70));
        r12 = *((rsp + 0x78));
        r13 = *((rsp + 0x80));
        return rax;
    }
    return stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429460 */
#include <stdint.h>
 
int64_t caml_int32_format (int64_t arg2, int64_t arg1) {
    int64_t var_fh;
    int64_t var_10h;
    int64_t var_30h;
    int64_t var_58h;
    int64_t var_68h;
    int64_t var_70h;
    int64_t var_78h;
    int64_t canary;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x20)) = rbx;
    *((rsp - 0x18)) = rbp;
    *((rsp - 0x10)) = r12;
    *((rsp - 8)) = r13;
    r12 = rsp + 0x30;
    rbp = rsp + 0x10;
    r8 = rsp + 0xf;
    r13 = rsi;
    esi = 0x436cc1;
    rdx = r12;
    rcx = rbp;
    rax = *(fs:0x28);
    *((rsp + 0x58)) = rax;
    eax = 0;
    rax = parse_format ();
    r8d = *((r13 + 8));
    rbx = rax;
    rcx = r12;
    rdi = rax;
    rdx = 0xffffffffffffffff;
    esi = 1;
    eax = 0;
    sprintf_chk ();
    rdi = rbx;
    rax = caml_copy_string ();
    r12 = rax;
    if (rbx != rbp) {
        rdi = rbx;
        caml_stat_free ();
    }
    rdx = *((rsp + 0x58));
    rdx ^= *(fs:0x28);
    rax = r12;
    if (rbx == rbp) {
        rbx = *((rsp + 0x68));
        rbp = *((rsp + 0x70));
        r12 = *((rsp + 0x78));
        r13 = *((rsp + 0x80));
        return rax;
    }
    return stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a450 */
#include <stdint.h>
 
int64_t caml_tuplify2 (void) {
    rdi = rbx;
    rbx = *((rax + 8));
    rax = *(rax);
    rsi = *((rdi + 0x10));
    return void (*rsi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f488 */
#include <stdint.h>
 
int32_t unix_clear_nonblock (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    ebx = edi;
    edx = 0;
    esi = 3;
    eax = 0;
    eax = fcntl ();
    if (eax != 0xffffffff) {
        edx = eax;
        dh &= 0xf7;
        esi = 4;
        edi = ebx;
        eax = 0;
        eax = fcntl ();
        if (eax != 0xffffffff) {
            goto label_0;
        }
    }
    esi = 0;
    rdi = "clear_nonblock";
    uerror ();
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ba80 */
#include <stdint.h>
 
int64_t camlPrintf_add_conv_197 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    *((rsp + 0x10)) = rbx;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    if (rax != 1) {
        rbx = *(loc.camlPrintf__66);
        rax = *((rsi + 0x18));
        camlBuffer_add_string_110 ();
    } else {
        rbx = 0x4b;
        rax = *((rsi + 0x18));
        camlBuffer_add_char_100 ();
    }
    rax = *(rsp);
    rax = *((rax + 0x20));
    rax = *((rax + 0x18));
    rbx = *((rsp + 8));
    camlBuffer_add_char_100 ();
    rax = *((rsp + 0x10));
    rax += 2;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409cf0 */
#include <stdint.h>
 
int64_t caml_curry7_1 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry7_2);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409d40 */
#include <stdint.h>
 
int64_t caml_curry7_2 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry7_3);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fff0 */
#include <stdint.h>
 
int64_t unix_gethostname (void) {
    int64_t var_3fh;
    int64_t canary;
    rax = *(fs:0x28);
    *((rsp + 0x48)) = rax;
    eax = 0;
    esi = 0x40;
    rdi = rsp;
    gethostname ();
    *((rsp + 0x3f)) = 0;
    rdi = rsp;
    caml_copy_string ();
    rdx = *((rsp + 0x48));
    rdx ^= *(fs:0x28);
    if (? != ?) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409320 */
#include <stdint.h>
 
void gethostname (void) {
    gethostname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409460 */
#include <stdint.h>
 
void stack_chk_fail (void) {
    stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f258 */
#include <stdint.h>
 
uint64_t unix_execve (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    *((rsp - 8)) = r12;
    r12 = rdi;
    rdi = rsi;
    eax = 0;
    rax = cstringvect ();
    rbx = rax;
    rdi = rbp;
    eax = 0;
    rax = cstringvect ();
    rdx = rax;
    rsi = rbx;
    rdi = r12;
    execve ();
    rdi = rbx;
    caml_stat_free ();
    rdi = rbp;
    caml_stat_free ();
    rsi = r12;
    rdi = "execve";
    return uerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42272a */
#include <stdint.h>
 
uint64_t unix_lstat (int64_t arg1) {
    int64_t var_18h;
    signed int64_t var_30h;
    rdi = arg1;
    rbx = rdi;
    rdx = rsp;
    rsi = rdi;
    edi = 1;
    eax = lxstat64 ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "lstat";
        uerror ();
    }
    rax = 0x3fffffffffffffff;
    if (*((rsp + 0x30)) > rax) {
        eax = *((rsp + 0x18));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        rdx = rbx;
        rsi = "lstat";
        edi = 0x4b;
        unix_error ();
    }
label_0:
    rsi = rsp;
    edi = 0;
    stat_aux ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4111a0 */
#include <stdint.h>
 
int64_t camlArray_loop_228 (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_20h;
    int64_t var_28h_2;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_28h_3;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    do {
label_0:
        *((rsp + 8)) = rax;
        rax = rbx;
        *((rsp + 0x28)) = rax;
        *((rsp + 0x10)) = rdi;
        *((rsp + 0x18)) = rsi;
        *((rsp + 0x20)) = rdx;
        *(rsp) = rcx;
        rdi = *((rcx + 0x18));
        rbx = rsi;
        rax = caml_apply2 ();
        if (rax > 1) {
            goto label_2;
        }
        rbp = *(rsp);
        rdi = *((rbp + 0x30));
        rax = *((rdi - 8));
        rbx = *((rdi - 8));
        rbx &= 0xff;
        if (rbx != 0xfe) {
            rax >>= 9;
            r12 = *((rsp + 0x20));
            if (rax <= r12) {
                goto label_3;
            }
            rdi = rdi + r12*4 - 4;
            rsi = *((rsp + 0x28));
            rax = caml_modify ();
        } else {
            rax >>= 9;
            r12 = *((rsp + 0x20));
            if (rax <= r12) {
                goto label_4;
            }
            rax = *((rsp + 0x28));
            __asm ("movlpd xmm0, qword [rax]");
            __asm ("movlpd qword [rdi + r12*4 - 4], xmm0");
        }
        rbx = *((rsp + 8));
        rbx += 2;
        rax = *((rbp + 0x38));
        if (rbx >= rax) {
            goto label_5;
        }
        rsi = *((rbp + 0x20));
        rdi = *((rsi - 8));
        rax = *((rsi - 8));
        rax &= 0xff;
        if (rax != 0xfe) {
            rax = rdi;
            rax >>= 9;
            if (rax <= rbx) {
                goto label_6;
            }
            rdi = *((rsi + rbx*4 - 4));
        } else {
            rax = rdi;
            rax >>= 9;
            if (rax <= rbx) {
                goto label_7;
            }
label_1:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_8;
            }
            rdi = r15 + 8;
            *((rdi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rsi + rbx*4 - 4]");
            __asm ("movlpd qword [rdi], xmm0");
        }
        rdx = r12;
        rdx += 2;
        rax = rbx;
        rbx = rdi;
        rdi = *((rsp + 0x10));
        rsi = *((rsp + 0x18));
        rcx = rbp;
    } while (1);
label_5:
    rdx = *((rbp + 0x40));
    rbx = *((rsp + 0x10));
    rdx -= rbx;
    rdx++;
    rsi = r12;
    rsi += 2;
    rdi = *((rbp + 0x30));
    rax = *((rbp + 0x28));
    void (*0x412fe0)() ();
label_2:
    rbp = *(rsp);
    rdi = *((rbp + 0x30));
    rax = *((rdi - 8));
    rbx = *((rdi - 8));
    rbx &= 0xff;
    if (rbx != 0xfe) {
        rax >>= 9;
        r12 = *((rsp + 0x20));
        if (rax <= r12) {
            goto label_9;
        }
        rdi = rdi + r12*4 - 4;
        rsi = *((rsp + 0x18));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        r12 = *((rsp + 0x20));
        if (rax <= r12) {
            goto label_10;
        }
        rax = *((rsp + 0x18));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rdi + r12*4 - 4], xmm0");
    }
    rdi = *((rsp + 0x10));
    rdi += 2;
    rax = *((rbp + 0x40));
    if (rdi >= rax) {
        goto label_11;
    }
    rdx = *((rbp + 0x28));
    rbx = *((rdx - 8));
    rax = *((rdx - 8));
    rax &= 0xff;
    if (rax != 0xfe) {
        rax = rbx;
        rax >>= 9;
        if (rax <= rdi) {
            goto label_12;
        }
        rsi = *((rdx + rdi*4 - 4));
        goto label_13;
    }
    rax = rbx;
    rax >>= 9;
    if (rax <= rdi) {
        goto label_14;
    }
    do {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdx + rdi*4 - 4]");
            __asm ("movlpd qword [rsi], xmm0");
label_13:
            rdx = r12;
            rdx += 2;
            rax = *((rsp + 8));
            rbx = *((rsp + 0x28));
            rcx = rbp;
            goto label_0;
label_11:
            rdx = *((rbp + 0x38));
            rbx = *((rsp + 8));
            rdx -= rbx;
            rdx++;
            rsi = r12;
            rsi += 2;
            rdi = *((rbp + 0x30));
            rax = *((rbp + 0x20));
            void (*0x412fe0)() ();
        }
        caml_call_gc ();
    } while (1);
label_8:
    caml_call_gc ();
    goto label_1;
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409d90 */
#include <stdint.h>
 
int64_t caml_curry7_3 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry7_4);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409de0 */
#include <stdint.h>
 
int64_t caml_curry7_4 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry7_5);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f1e0 */
#include <stdint.h>
 
int64_t unix_error_message (int64_t arg1) {
    rdi = arg1;
    if ((dil & 1) == 0) {
        rdi = *(rdi);
        rdi >>= 1;
    } else {
        rdi >>= 1;
        rdi = (int64_t) edi;
        rax = *(reloc.error_table);
    }
    rax = strerror (*((rax + rdi*4)));
    rdi = rax;
    caml_copy_string ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418030 */
#include <stdint.h>
 
int64_t camlHashtbl_remove_bucket_111 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    do {
        if (rax == 1) {
            goto label_0;
        }
        *((rsp + 0x10)) = rbx;
        rdi = *((rax + 0x10));
        *((rsp + 0x18)) = rdi;
        rdi = *((rax + 8));
        *((rsp + 8)) = rdi;
        rdi = *(rax);
        *(rsp) = rdi;
        rsi = *((rbx + 0x18));
        rax = *(reloc.caml_compare);
        rax = caml_c_call ();
        if (rax == 1) {
            rax = *((rsp + 0x10));
            rax = *((rax + 0x10));
            *(rax) += 0xfffffffffffffffe;
            rax = *((rsp + 0x18));
            return rax;
        }
        rax = *((rsp + 0x18));
        rbx = *((rsp + 0x10));
        rax = camlHashtbl_remove_bucket_111 ();
    } while (1);
    rdi = rax;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0xc00;
            rbx = *(rsp);
            *(rax) = rbx;
            rbx = *((rsp + 8));
            *((rax + 8)) = rbx;
            *((rax + 0x10)) = rdi;
            return rax;
label_0:
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f588 */
#include <stdint.h>
 
uint32_t unix_ftruncate (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    rdi >>= 1;
    eax = ftruncate64 ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "ftruncate";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423233 */
#include <stdint.h>
 
uint32_t unix_wait (void) {
    int64_t wstatus;
    caml_enter_blocking_section ();
    eax = wait (rsp + 0xc);
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx == 0xffffffff) {
        esi = 0;
        rdi = "wait";
        uerror ();
    }
    esi = *((rsp + 0xc));
    edi = ebx;
    alloc_process_status ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408e30 */
#include <stdint.h>
 
void wait (void) {
    wait ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409e30 */
#include <stdint.h>
 
int64_t caml_curry7_5 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry7_6);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x414570 */
#include <stdint.h>
 
int64_t camlList_part_243 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, uint32_t arg2, uint32_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    uint32_t var_18h;
    uint32_t var_20h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
label_0:
        *((rsp + 8)) = rax;
        if (rdi == 1) {
            goto label_3;
        }
        rax = *((rdi + 8));
        rax = *(rdi);
        rbx = *((rsi + 0x18));
        rdi = *(rbx);
        rax = void (*rdi)(uint64_t) (rsi);
        if (rax == 1) {
            goto label_1;
        }
label_2:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_4;
        }
        rax = r15 + 8;
        *((rax - 8)) = 0x800;
        rbx = *(rsp);
        *(rax) = rbx;
        rbx = *((rsp + 8));
        *((rax + 8)) = rbx;
        rbx = *((rsp + 0x10));
        rdi = *((rsp + 0x18));
        rsi = *((rsp + 0x20));
    } while (1);
label_1:
    r15 -= 0x18;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_5;
    }
    rbx = r15 + 8;
    *((rbx - 8)) = 0x800;
    rax = *(rsp);
    *(rbx) = rax;
    rax = *((rsp + 0x10));
    *((rbx + 8)) = rax;
    rax = *((rsp + 8));
    rdi = *((rsp + 0x18));
    rsi = *((rsp + 0x20));
    goto label_0;
label_3:
    rdi = 1;
    rax = rbx;
    rbx = rdi;
    rax = camlList_rev_append_79 ();
    *(rsp) = rax;
    rbx = 1;
    rax = *((rsp + 8));
    rax = camlList_rev_append_79 ();
    rbx = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            *(rax) = rbx;
            rbx = *(rsp);
            *((rax + 8)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
label_4:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409e80 */
#include <stdint.h>
 
int64_t caml_curry7_6 (void) {
    r8 = rax;
    rdx = *((rbx + 0x18));
    rsi = *((rdx + 0x18));
    rdi = *((rsi + 0x18));
    r10 = *((rdi + 0x18));
    rax = *((r10 + 0x18));
    r9 = *((rax + 0x18));
    rcx = *((rbx + 0x10));
    rdx = *((rdx + 0x10));
    rsi = *((rsi + 0x10));
    rdi = *((rdi + 0x10));
    rbx = *((r10 + 0x10));
    rax = *((rax + 0x10));
    r10 = *((r9 + 0x10));
    return void (*r10)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d1e0 */
#include <stdint.h>
 
int64_t camlPrintf_scan_positional_323 (int64_t arg6, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r8 = rax;
    rcx = rbx;
    rdx = rdi;
    do {
        r15 -= 0x38;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x18f7;
            rax = *(reloc.caml_curry2);
            *(rbx) = rax;
            *((rbx + 8)) = 5;
            rax = *(reloc.camlPrintf__got_spec_329);
            *((rbx + 0x10)) = rax;
            rax = rsi;
            rax += 0x20;
            *((rbx + 0x18)) = rax;
            *((rbx + 0x20)) = r8;
            *((rbx + 0x28)) = rcx;
            rax = *((rsi + 0x58));
            rdi = r8;
            rsi = rdx;
            void (*0x41e150)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ad40 */
#include <stdint.h>
 
int64_t camlPrintf_sub_156 (int64_t arg6, int64_t arg5, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10) {
    r9 = arg6;
    r8 = arg5;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    do {
        rdi = *((rbx + 0x40));
        if (rax >= rdi) {
            rsi = *((rbx + 0x28));
            rax = *((rbx + 0x38));
            rdi = *(rsi);
            rbx = rsi;
            rax = void (*rdi)() ();
        }
        rcx = *((rbx + 0x38));
        rdx = rax;
        rdx >>= 1;
        rdi = *((rcx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rcx + rdi));
        rdi -= rsi;
        if (rdi <= rdx) {
            goto label_0;
        }
        rdi = *((rcx + rdx));
        rdi = rdi + rdi + 1;
        if (rdi == 0x4b) {
            goto label_1;
        }
        rax += 2;
    } while (1);
label_1:
    rbx += 0x18;
    rax += 2;
    void (*0x41ac30)() ();
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x411f60 */
#include <stdint.h>
 
uint64_t camlArray_bubble_201 (void) {
    rax = void (*0x411f90)() ();
    rbx = *(reloc.camlArray);
    rdi = *((rbx + 0xb0));
    rbx = *(rax);
    if (rbx == rdi) {
        rax = *((rax + 8));
        return rax;
    }
    rax = caml_raise_exn ();
    r14 = rsp;
    rdi = *((rdi + 0x18));
    camlArray_bubbledown_197 ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f33a */
#include <stdint.h>
 
uint64_t unix_execvp (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rdi = rsi;
    eax = 0;
    rax = cstringvect ();
    rbx = rax;
    rsi = rax;
    rdi = rbp;
    execvp ();
    rdi = rbx;
    caml_stat_free ();
    rsi = rbp;
    rdi = "execvp";
    return uerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420617 */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
uint64_t unix_getservbyport (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    di = rotate_right16 (di, 8);
    edi = (int32_t) di;
    rax = getservbyport ();
    if (rax == 0) {
        rax = caml_raise_not_found ();
    }
    rdi = rax;
    alloc_service_entry ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409530 */
#include <stdint.h>
 
void getservbyport (void) {
    getservbyport ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42053c */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
int64_t alloc_service_entry (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    rdi = arg1;
    rbx = rdi;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x50)) = 1;
    *((rsp + 0x48)) = 1;
    rbp = *(reloc.caml_local_roots);
    rax = *(rbp);
    *(rsp) = rax;
    *(rbp) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 3;
    rax = rsp + 0x58;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x20)) = rax;
    rax = rsp + 0x48;
    *((rsp + 0x28)) = rax;
    rdi = *(rdi);
    rax = caml_copy_string ();
    *((rsp + 0x58)) = rax;
    rdi = *((rbx + 8));
    rax = caml_copy_string_array ();
    *((rsp + 0x50)) = rax;
    rdi = *((rbx + 0x18));
    rax = caml_copy_string ();
    *((rsp + 0x48)) = rax;
    esi = 0;
    edi = 4;
    caml_alloc_small ();
    rdx = *((rsp + 0x58));
    *(rax) = rdx;
    rdx = *((rsp + 0x50));
    *((rax + 8)) = rdx;
    edx = *((rbx + 0x10));
    dx = rotate_right16 (dx, 8);
    edx = (int32_t) dx;
    rdx = rdx + rdx + 1;
    *((rax + 0x10)) = rdx;
    rdx = *((rsp + 0x48));
    *((rax + 0x18)) = rdx;
    rdx = *(rsp);
    *(rbp) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421254 */
#include <stdint.h>
 
int32_t unix_rewinddir (int64_t arg1) {
    rdi = arg1;
    rdi = *(rdi);
    if (rdi == 0) {
        edx = 0;
        rsi = "rewinddir";
        dil = 9;
        unix_error ();
    }
    rewinddir ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4093d0 */
#include <stdint.h>
 
void rewinddir (void) {
    rewinddir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d500 */
#include <stdint.h>
 
void camlPrintf_to_string_82 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rdi = *((rax + rbx));
    rbx -= rdi;
    rdi = rbx + rbx + 1;
    rbx = 1;
    return camlString_sub_74 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420db0 */
#include <stdint.h>
 
uint32_t unix_mkfifo (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rsi >>= 1;
    eax = mkfifo ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "mkfifo";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4095a0 */
#include <stdint.h>
 
void mkfifo (void) {
    mkfifo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b650 */
#include <stdint.h>
 
int64_t camlPrintf_scan_fmt_172 (int64_t arg6, int64_t arg5, int64_t arg7, int64_t arg8) {
    r9 = arg6;
    r8 = arg5;
    xmm0 = arg7;
    xmm1 = arg8;
    do {
label_0:
        rdi = *((rbx + 0x28));
        if (rax >= rdi) {
            goto label_1;
        }
        rcx = *((rbx + 0x10));
        rdx = rax;
        rdx >>= 1;
        rdi = *((rcx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rcx + rdi));
        rdi -= rsi;
        if (rdi <= rdx) {
            goto label_2;
        }
        rdi = *((rcx + rdx));
        rdi = rdi + rdi + 1;
        if (rdi != 0x4b) {
            goto label_3;
        }
        *(rsp) = rbx;
        rdi = rbx;
        rdi += 0xffffffffffffffc0;
        rbx = rax;
        rbx += 2;
        rax = 1;
        rax = camlPrintf_scan_flags_170 ();
        rbx = *(rsp);
    } while (1);
label_3:
    rax += 2;
    goto label_0;
label_1:
    return rax;
label_2:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x414430 */
#include <stdint.h>
 
int64_t camlList_rmap2_f_131 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, uint32_t arg2, uint32_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    uint32_t var_10h;
    uint32_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rbx == 1) {
            goto label_1;
        }
        if (rdi == 1) {
            goto label_2;
        }
        *((rsp + 0x18)) = rsi;
        *(rsp) = rax;
        rax = *((rdi + 8));
        *((rsp + 0x10)) = rax;
        rdx = *(rdi);
        rax = *((rbx + 8));
        *((rsp + 8)) = rax;
        rax = *(rbx);
        rdi = *((rsi + 0x18));
        rbx = rdx;
        rax = caml_apply2 ();
        rbx = rax;
label_0:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_3;
        }
        rax = r15 + 8;
        *((rax - 8)) = 0x800;
        *(rax) = rbx;
        rbx = *(rsp);
        *((rax + 8)) = rbx;
        rbx = *((rsp + 8));
        rdi = *((rsp + 0x10));
        rsi = *((rsp + 0x18));
    } while (1);
label_1:
    if (rdi == 1) {
        return rax;
    }
label_2:
    rax = *(loc.camlList__52);
    void (*0x40fc30)() ();
label_3:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422948 */
#include <stdint.h>
 
uint32_t unix_tcdrain (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    eax = tcdrain ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "tcdrain";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409130 */
#include <stdint.h>
 
void tcdrain (void) {
    tcdrain ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c6f0 */
#include <stdint.h>
 
uint64_t caml_ml_flush (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    rdi = arg1;
    rbx = *((rdi + 8));
    rbp = caml_local_roots;
    rdx = rsp + 0x10;
    *((rsp + 8)) = rdi;
    *(obj.caml_local_roots) = rdx;
    if (*(rbx) != 0xffffffff) {
        rax = rsp + 8;
        *((rsp + 0x10)) = rbp;
        *((rsp + 0x20)) = 1;
        *((rsp + 0x18)) = 1;
        *((rsp + 0x28)) = rax;
        rax = caml_channel_mutex_lock;
        if (rax != 0) {
            rdi = rbx;
            void (*rax)() ();
        }
        rdi = rbx;
        caml_flush ();
        rax = caml_channel_mutex_unlock;
        if (rax == 0) {
            goto label_0;
        }
        rdi = rbx;
        void (*rax)() ();
    }
label_0:
    *(obj.caml_local_roots) = rbp;
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41bba0 */
#include <stdint.h>
 
int64_t camlPrintf_loop_232 (int64_t arg_8h_6, int64_t arg_10h_5, int64_t arg1) {
    rdi = arg1;
    do {
        if (rbx == 1) {
            goto label_0;
        }
        rsi = *((rbx + 8));
        rbx = *(rbx);
        if (rsi == 1) {
            goto label_1;
        }
        *((rsp + 8)) = rsi;
        *((rsp + 0x10)) = rdi;
        *(rsp) = rax;
        rdi = *((rdi + 0x18));
        caml_apply2 ();
        rax = *(rsp);
        rax += 2;
        rbx = *((rsp + 8));
        rdi = *((rsp + 0x10));
    } while (1);
label_1:
    rdi = *((rdi + 0x18));
    void (*0x40a5b0)() ();
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x419ee0 */
#include <stdint.h>
 
int64_t camlBuffer_subst_155 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    do {
label_0:
        rsi = rax;
        rax = *((rdi + 0x30));
        if (rbx >= rax) {
            goto label_1;
        }
        r8 = *((rdi + 0x28));
        rcx = rbx;
        rcx >>= 1;
        rax = *((r8 - 8));
        rax >>= 0xa;
        rax = rax*8 - 1;
        rdx = *((r8 + rax));
        rax -= rdx;
        if (rax <= rcx) {
            goto label_2;
        }
        rax = *((r8 + rcx));
        rdx = rax + rax + 1;
        if (rdx == 0x49) {
            goto label_3;
        }
        if (rsi != 0xb9) {
            goto label_4;
        }
        *(rsp) = rdx;
        *((rsp + 0x10)) = rdi;
        *((rsp + 8)) = rbx;
        rbx = 0xb9;
        rax = *((rdi + 0x18));
        camlBuffer_add_char_100 ();
        rax = *((rsp + 0x10));
        rax = *((rax + 0x18));
        rbx = *(rsp);
        camlBuffer_add_char_100 ();
        rbx = *((rsp + 8));
        rbx += 2;
        rax = 0x41;
        rdi = *((rsp + 0x10));
    } while (1);
label_4:
    if (rdx != 0xb9) {
        *((rsp + 0x10)) = rdi;
        *((rsp + 8)) = rbx;
        rbx = rdx;
        *(rsp) = rbx;
        rax = *((rdi + 0x18));
        camlBuffer_add_char_100 ();
        rax = *((rsp + 8));
        rbx = *((rsp + 8));
        rbx += 2;
        rax = *(rsp);
        rdi = *((rsp + 0x10));
        goto label_0;
    }
    rax = rdx;
    rbx += 2;
    goto label_0;
label_3:
    *((rsp + 0x10)) = rdi;
    if (rsi == 0xb9) {
        *((rsp + 8)) = rbx;
        rax = *((rdi + 0x18));
        rbx = rdx;
        camlBuffer_add_char_100 ();
        rbx = *((rsp + 8));
        rbx += 2;
        rax = 0x41;
        rdi = *((rsp + 0x10));
        goto label_0;
    }
    rbx += 2;
    rsi = *((rdi + 0x30));
    rax = *((rdi + 0x28));
    rdi = rsi;
    rax = camlBuffer_find_ident_142 ();
    rbx = rax;
    rax = *((rbx + 8));
    rsi = *(rbx);
    rax = *((rsp + 0x10));
    rbx = *((rax + 0x20));
    rdi = *(rbx);
    rax = rsi;
    rax = void (*rdi)(uint64_t) (rax);
    rbx = rax;
    rax = *((rsp + 0x10));
    rax = *((rax + 0x18));
    camlBuffer_add_string_110 ();
    rax = 0x41;
    rbx = *(rsp);
    rdi = *((rsp + 0x10));
    goto label_0;
label_1:
    if (rsi == 0xb9) {
        rax = *((rdi + 0x18));
        rbx = rsi;
        void (*0x41a420)() ();
    }
    rax = 1;
    return rax;
label_2:
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420641 */
#include <stdint.h>
 
uint64_t unix_getservbyname (void) {
    rax = getservbyname ();
    if (rax == 0) {
        rax = caml_raise_not_found ();
    }
    rdi = rax;
    alloc_service_entry ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4097e0 */
#include <stdint.h>
 
void getservbyname (void) {
    getservbyname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4227a4 */
#include <stdint.h>
 
uint64_t unix_stat (int64_t arg1) {
    int64_t var_18h;
    signed int64_t var_30h;
    rdi = arg1;
    rbx = rdi;
    rdx = rsp;
    rsi = rdi;
    edi = 1;
    eax = xstat64 ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = 0x00435d91;
        uerror ();
    }
    rax = 0x3fffffffffffffff;
    if (*((rsp + 0x30)) > rax) {
        eax = *((rsp + 0x18));
        eax &= 0xf000;
        if (eax != 0x8000) {
            goto label_0;
        }
        rdx = rbx;
        rsi = 0x00435d91;
        edi = 0x4b;
        unix_error ();
    }
label_0:
    rsi = rsp;
    edi = 0;
    stat_aux ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41afa0 */
#include <stdint.h>
 
void camlPrintf_got_spec_329 (int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rbx;
    rbx = rdi;
    rdx = *((rbx + 0x18));
    rdi = *((rbx + 0x28));
    rbx = *((rbx + 0x20));
    return camlPrintf_scan_flags_324 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fb30 */
#include <stdint.h>
 
uint64_t unix_geteuid (void) {
    eax = geteuid ();
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409070 */
#include <stdint.h>
 
void geteuid (void) {
    geteuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420cdc */
#include <stdint.h>
 
uint64_t unix_lseek_64 (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rdx >>= 1;
    rdx = (int64_t) edx;
    rax = obj_seek_command_table;
    edx = *((rax + rdx*4));
    rsi = *((rsi + 8));
    rdi >>= 1;
    rax = lseek64 ();
    if (rax == -1) {
        esi = 0;
        rdi = "lseek";
        rax = uerror ();
    }
    rdi = rax;
    caml_copy_int64 ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409570 */
#include <stdint.h>
 
void lseek64 (void) {
    lseek64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429870 */
#include <stdint.h>
 
void caml_copy_int64 (int64_t arg1) {
    rdi = arg1;
    ecx = 1;
    rbx = rdi;
    edx = 0;
    esi = 8;
    edi = caml_int64_ops;
    caml_alloc_custom ();
    *((rax + 8)) = rbx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c7d0 */
#include <stdint.h>
 
int64_t caml_ml_seek_out_64 (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    rsi = arg2;
    rdi = arg1;
    rax = caml_channel_mutex_lock;
    rbp = caml_local_roots;
    rdx = rsp + 0x10;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 2;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x10)) = rbp;
    *((rsp + 0x30)) = rsp;
    *((rsp + 0x28)) = rdx;
    rbx = *((rdi + 8));
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rax = *(rsp);
    rdi = rbx;
    rsi = *((rax + 8));
    caml_seek_out ();
    rax = caml_channel_mutex_unlock;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    *(obj.caml_local_roots) = rbp;
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f028 */
#include <stdint.h>
 
uint32_t unix_chown (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rdx >>= 1;
    rsi >>= 1;
    eax = chown ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = 0x00435ac0;
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409500 */
#include <stdint.h>
 
void chown (void) {
    chown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41afc0 */
#include <stdint.h>
 
int64_t camlPrintf_cont_m_397 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    *((rsp + 0x10)) = rax;
    rax = rbx;
    *((rsp + 0x18)) = rax;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    rax = camlPrintf_ac_of_format_212 ();
    rbx = *(rax);
    rax = *((rsp + 0x10));
    rax = rbx + rax - 1;
    rax = camlPrintf_index_of_int_65 ();
    rsi = rax;
    do {
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x14f7;
            rbx = *(reloc.camlPrintf__fun_703);
            *(rax) = rbx;
            *((rax + 8)) = 3;
            rdi = *(rsp);
            rbx = *(rsp);
            rbx += 0xffffffffffffff60;
            *((rax + 0x10)) = rbx;
            rbx = *((rsp + 8));
            *((rax + 0x18)) = rbx;
            *((rax + 0x20)) = rsi;
            rdx = *((rdi + 0x40));
            rsi = *((rdi + 0x58));
            rbx = *((rsp + 0x10));
            rdi = *((rsp + 0x18));
            void (*0x41d260)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421284 */
#include <stdint.h>
 
uint32_t unix_rmdir (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    eax = rmdir ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "rmdir";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408fc0 */
#include <stdint.h>
 
void rmdir (void) {
    rmdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f4da */
#include <stdint.h>
 
int32_t unix_set_nonblock (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    ebx = edi;
    edx = 0;
    esi = 3;
    eax = 0;
    eax = fcntl ();
    if (eax != 0xffffffff) {
        edx = eax;
        dh |= 8;
        esi = 4;
        edi = ebx;
        eax = 0;
        eax = fcntl ();
        if (eax != 0xffffffff) {
            goto label_0;
        }
    }
    esi = 0;
    rdi = "set_nonblock";
    uerror ();
label_0:
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4180f0 */
#include <stdint.h>
 
int64_t camlHashtbl_find_in_bucket_136 (void) {
    int64_t var_8h;
    int64_t var_10h;
    do {
label_0:
        if (rax == 1) {
            goto label_1;
        }
        *((rsp + 8)) = rbx;
        rdi = *((rax + 0x10));
        *(rsp) = rdi;
        rdi = *((rax + 8));
        *((rsp + 0x10)) = rdi;
        rdi = *(rax);
        rsi = *((rbx + 0x10));
        rax = *(reloc.caml_compare);
        rax = caml_c_call ();
        if (rax != 1) {
            goto label_2;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
        rax = camlHashtbl_find_in_bucket_136 ();
    } while (1);
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *((rsp + 0x10));
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            return rax;
label_2:
            rax = *(rsp);
            rbx = *((rsp + 8));
            goto label_0;
label_1:
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4225df */
#include <stdint.h>
 
uint32_t unix_fstat_64 (int64_t arg1) {
    rdi = arg1;
    rdx = rsp;
    rsi = rdi;
    rsi >>= 1;
    edi = 1;
    eax = fxstat64 ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "fstat";
        uerror ();
    }
    rsi = rsp;
    edi = 1;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409040 */
#include <stdint.h>
 
void fxstat64 (void) {
    fxstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fb18 */
#include <stdint.h>
 
uint64_t unix_getegid (void) {
    eax = getegid ();
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409230 */
#include <stdint.h>
 
void getegid (void) {
    getegid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41bb50 */
#include <stdint.h>
 
int64_t camlPrintf_add_conv_219 (int64_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    *(rsp) = rbx;
    if (rdi != 0x53) {
        if (rdi == 0xfb) {
            goto label_0;
        }
        rsi = *((rsi + 0x18));
        rbx = rdi;
        rdi = rsi;
        camlPrintf_incr_ac_215 ();
    }
label_0:
    rax = *(rsp);
    rax += 2;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41bae0 */
#include <stdint.h>
 
int64_t camlPrintf_incr_ac_215 (int64_t arg1) {
    rdi = arg1;
    if (rbx == 0xc3) {
        rsi = 5;
    } else {
        rsi = 3;
    }
    if (rbx == 0xe5) {
        rbx = *((rdi + 0x18));
        *((rbx + 0x10)) += 2;
    }
    if (rax != 1) {
        rbx = *((rdi + 0x18));
        rax = *((rdi + 0x18));
        rax = *((rax + 8));
        rax = rax + rsi - 1;
        *((rbx + 8)) = rax;
        rax = 1;
        return rax;
    }
    rbx = *((rdi + 0x18));
    rax = *((rdi + 0x18));
    rax = *(rax);
    rax = rax + rsi - 1;
    *(rbx) = rax;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f078 */
#include <stdint.h>
 
uint32_t unix_close (int64_t fildes) {
    rdi = fildes;
    rdi >>= 1;
    eax = close (rdi);
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "close";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408e20 */
#include <stdint.h>
 
void close (void) {
    close ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f52c */
#include <stdint.h>
 
int64_t unix_fork (void) {
    eax = fork ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "fork";
        uerror ();
    }
    rax = (int64_t) eax;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4095d0 */
#include <stdint.h>
 
void fork (void) {
    fork ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ba60 */
#include <stdint.h>
 
int64_t camlPrintf_add_char_194 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    *(rsp) = rax;
    rax = *((rdi + 0x18));
    camlBuffer_add_char_100 ();
    rax = *(rsp);
    rax += 2;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a420 */
#include <stdint.h>
 
int64_t camlBuffer_add_char_100 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    *(rsp) = rax;
    *((rsp + 0x10)) = rbx;
    rdi = *((rax + 8));
    *((rsp + 8)) = rdi;
    rbx = *((rax + 0x10));
    if (rdi >= rbx) {
        rbx = 3;
        camlBuffer_resize_94 ();
    }
    rdi = *(rsp);
    rcx = *(rdi);
    rbx = *((rsp + 8));
    rdx = *((rsp + 8));
    rdx >>= 1;
    rax = *((rcx - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rsi = *((rcx + rax));
    rax -= rsi;
    if (rax > rdx) {
        rax = *((rsp + 0x10));
        rax >>= 1;
        *((rcx + rdx)) = al;
        rbx += 2;
        *((rdi + 8)) = rbx;
        rax = 1;
        return rax;
    }
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ac30 */
#include <stdint.h>
 
int64_t camlPrintf_sub_sub_157 (int64_t arg6, int64_t arg5, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10) {
    r9 = arg6;
    r8 = arg5;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    rsi = rax;
    rax = *((rbx + 0x28));
    if (rsi >= rax) {
        rsi = *((rbx + 0x10));
        rax = *((rbx + 0x20));
        rdi = *(rsi);
        rbx = rsi;
        void (*rdi)() ();
    }
    rcx = *((rbx + 0x20));
    rdx = rsi;
    rdx >>= 1;
    rax = *((rcx - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rdi = *((rcx + rax));
    rax -= rdi;
    if (rax > rdx) {
        rax = *((rcx + rdx));
        rcx = rax + rax + 1;
        rax = rcx;
        rax += 0xffffffffffffffb0;
        if (rax > 3) {
            rax += 0xffffffffffffff5a;
            if (rax > 5) {
                goto label_0;
            }
            *(rsp) = rbx;
            rax >>= 1;
            if (rax < 1) {
                goto label_1;
            }
            if (rax == 1) {
                goto label_0;
            }
            if (rax > 1) {
                goto label_2;
            }
        }
        if (rax == 1) {
            *(rsp) = rbx;
            goto label_1;
label_0:
            rbx += 0xffffffffffffffe8;
            rax = rsi;
            rax += 2;
            void (*0x41ad40)() ();
label_1:
            rdi = *((rbx + 0x30));
            rbx = rsi;
            rbx += 2;
            rax = rcx;
            rax = camlPrintf_sub_fmt_152 ();
            rbx = *(rsp);
            rbx += 0xffffffffffffffe8;
            rax += 2;
            void (*0x41ad40)() ();
        }
label_2:
        rdi = rcx;
        rax = *((rbx + 0x40));
        if (rdi == rax) {
            rax = rsi;
            rax += 2;
            return rax;
        }
        rsi = *((rbx + 0x18));
        rdx = *((rbx + 0x38));
        rax = *((rbx + 0x20));
        rbx = rdx;
        void (*0x40a560)() ();
    }
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417c40 */
#include <stdint.h>
 
int64_t camlHashtbl_remove_bucket_216 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    do {
        if (rax == 1) {
            goto label_0;
        }
        *((rsp + 0x10)) = rbx;
        rdi = *((rax + 0x10));
        *((rsp + 0x18)) = rdi;
        rdi = *((rax + 8));
        *((rsp + 8)) = rdi;
        rax = *(rax);
        *(rsp) = rax;
        rdi = *((rbx + 0x10));
        rdi = *(rdi);
        rbx = *((rbx + 0x20));
        rax = caml_apply2 ();
        if (rax != 1) {
            rax = *((rsp + 0x10));
            rax = *((rax + 0x18));
            *(rax) += 0xfffffffffffffffe;
            rax = *((rsp + 0x18));
            return rax;
        }
        rax = *((rsp + 0x18));
        rbx = *((rsp + 0x10));
        rax = camlHashtbl_remove_bucket_216 ();
    } while (1);
    rdi = rax;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0xc00;
            rbx = *(rsp);
            *(rax) = rbx;
            rbx = *((rsp + 8));
            *((rax + 8)) = rbx;
            *((rax + 0x10)) = rdi;
            return rax;
label_0:
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x411490 */
#include <stdint.h>
 
int64_t camlArray_fill_98 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
label_0:
    r12 = rax;
    r13 = rdi;
    if (rbx == 1) {
        goto label_2;
    }
    rax = *((rbx + 8));
    *(rsp) = rax;
    rax = *(rbx);
    *((rsp + 8)) = rax;
    rbx = 1;
    rbp = *((rax - 8));
    rbp >>= 9;
    rbp |= 1;
    rbp += 0xfffffffffffffffe;
    if (rbx > rbp) {
        goto label_3;
    }
    do {
        rdi = *((rsp + 8));
        rax = *((rdi - 8));
        if (rax != 0xfe) {
            rsi = *((rdi + rbx*4 - 4));
        } else {
label_1:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_4;
            }
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdi + rbx*4 - 4]");
            __asm ("movlpd qword [rsi], xmm0");
        }
        rdx = r12 + rbx - 1;
        rdi = *((r13 + 0x18));
        rax = *((rdi - 8));
        if (rax != 0xfe) {
            rdi = rdi + rdx*4 - 4;
            caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [rdi + rdx*4 - 4], xmm0");
        }
        rax = rbx;
        rbx += 2;
    } while (rax != rbp);
label_3:
    rax = *((rsp + 8));
    rax = *((rax - 8));
    rax >>= 9;
    rax |= 1;
    rax = r12 + rax - 1;
    rbx = *(rsp);
    rdi = r13;
    goto label_0;
label_2:
    rax = 1;
    return rax;
label_4:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4206e4 */
#include <stdint.h>
 
uint64_t unix_getuid (void) {
    eax = getuid ();
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409520 */
#include <stdint.h>
 
void getuid (void) {
    getuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ae50 */
#include <stdint.h>
 
uint64_t caml_make_vect (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_70h;
    int64_t var_98h;
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rbx >>= 1;
    rbp = caml_local_roots;
    rax = rsp + 0x10;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    *((rsp + 0x98)) = 0;
    *(obj.caml_local_roots) = rax;
    eax = 0x658088;
    if (rbx == 0) {
        goto label_0;
    }
    rax = rsp + 8;
    *((rsp + 0x50)) = rbp;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 2;
    rdi = rsi;
    *((rsp + 0x68)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x70)) = rsp;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *((rsp + 0x10)) = rax;
    rax = rsp + 0x98;
    *((rsp + 0x28)) = rax;
    if ((sil & 1) == 0) {
        goto label_2;
    }
label_1:
    rax = 0x3fffffffffffff;
    if (rbx > rax) {
        goto label_3;
    }
    if (rbx <= 0xff) {
        goto label_4;
    }
    rax = *(rsp);
    if ((al & 1) != 0) {
        goto label_5;
    }
    if (rax >= *(obj.caml_young_end)) {
        goto label_5;
    }
    if (rax <= *(obj.caml_young_start)) {
        goto label_5;
    }
    caml_minor_collection ();
    rdi = rbx;
    esi = 0;
    rbx <<= 3;
    rax = caml_alloc_shr ();
    edx = 0;
    *((rsp + 0x98)) = rax;
    while (rdx != rbx) {
        rax = *((rsp + 0x98));
        rcx = *(rsp);
        *((rax + rdx)) = rcx;
        rdx += 8;
    }
    rdi = *((rsp + 0x98));
    caml_check_urgent_gc ();
label_0:
    *(obj.caml_local_roots) = rbp;
    return rax;
label_5:
    esi = 0;
    rdi = rbx;
    r12d = 0;
    rax = caml_alloc_shr ();
    *((rsp + 0x98)) = rax;
    while (rbx > r12) {
        rax = *((rsp + 0x98));
        rsi = *(rsp);
        rdi = rax + r12*8;
        r12++;
        caml_initialize ();
    }
    rdi = *((rsp + 0x98));
    caml_check_urgent_gc ();
    goto label_0;
label_2:
    al = caml_page_table_lookup ();
    if ((al & 7) == 0) {
        goto label_1;
    }
    rax = *(rsp);
    if (*((rax - 8)) != 0xfd) {
        goto label_1;
    }
    r12 = *(rax);
    rax = 0x3fffffffffffff;
    if (rbx > rax) {
        goto label_3;
    }
    esi = 0xfe;
    rdi = rbx;
    rax = caml_alloc ();
    edx = 0;
    do {
        *((rax + rdx*8)) = r12;
        rdx++;
    } while (rbx != rdx);
    goto label_0;
label_4:
    rdi = rbx;
    esi = 0;
    rbx <<= 3;
    rax = caml_alloc_small ();
    edx = 0;
    *((rsp + 0x98)) = rax;
    while (rdx != rbx) {
        rax = *((rsp + 0x98));
        rcx = *(rsp);
        *((rdx + rax)) = rcx;
        rdx += 8;
    }
    rax = *((rsp + 0x98));
    goto label_0;
label_3:
    edi = "Array.make";
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41c7b0 */
#include <stdint.h>
 
int64_t camlPrintf_get_arg_320 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rax != 1) {
        rbx = *(rax);
    }
    rsi = *((rdi + 0x18));
    rax = *((rsi - 8));
    rdi = *((rsi - 8));
    rdi &= 0xff;
    if (rdi == 0xfe) {
        goto label_0;
    }
    rax >>= 9;
    if (rax <= rbx) {
        void (*0x41c82c)() ();
    }
    rax = *((rsi + rbx*4 - 4));
    return rax;
label_0:
    rax >>= 9;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b6d0 */
#include <stdint.h>
 
int64_t camlPrintf_scan_conv_171 (int64_t arg_8h_2, int64_t arg_18h_3, int64_t arg_20h, int64_t arg_10h_2, int64_t arg_18h_5, int64_t arg_20h_2, int64_t arg_30h_2, int64_t arg_8h_4, int64_t arg_10h_3, int64_t arg_18h_6, int64_t arg_20h_3, int64_t arg_28h_3, int64_t arg_30h_3, int64_t arg_18h_2, int64_t arg_8h_6, int64_t arg_8h_5, int64_t arg_10h_4, int64_t arg_18h_7, int64_t arg_20h_4, int64_t arg_28h_4, int64_t arg_30h_4, int64_t arg_8h_3, int64_t arg_10h, int64_t arg_18h_4, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_10h_2;
    int64_t var_8h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
label_2:
    do {
        rcx = rax;
        rsi = rdi;
        rax = *((rsi + 0x48));
        if (rbx > rax) {
            rax = *((rsi + 0x30));
            void (*0x41d610)() ();
        }
        rdi = rbx;
        rdi >>= 1;
        rax = *((rsi + 0x30));
        rax = *((rax + rdi));
        rdi = rax + rax + 1;
        if (rdi >= 0xfd) {
            goto label_3;
        }
        rax = rdi;
        rax >>= 1;
        rdx = 0x00435450;
        rax = *((rdx + rax*4));
        rdx += rax;
        /* switch table (254 cases) at 0x435450 */
        void (*rdx)(uint64_t) (rsi);
        rsi = *((rsi + 0x38));
        rax = rcx;
        caml_apply3 ();
        rbx = *((rsp + 0x18));
        *((rax - 0x7d)) -= cl;
        return rax;
        *((rax - 0x7d)) &= cl;
        cl -= ch;
        *(rsp) = rdi;
        rsi = *((rsi + 0x38));
        rax = rcx;
        rax = caml_apply3 ();
        *((rsp + 8)) = rax;
        rax = *(rsp);
        rax = camlPrintf_sub_format_for_printf_163 ();
        rdi = rax;
        rax = *((rsp + 0x18));
        rax = *((rax + 0x30));
        rbx = *((rsp + 8));
        rax = caml_apply2 ();
        rsi = rax;
        *(rsp) = rsi;
        *(rsp) = esi;
label_0:
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_4;
        }
        rdi = r15 + 8;
        *((rdi - 8)) = 0x14f7;
        rax = *(reloc.camlPrintf__loop_187);
        al &= *(rax);
        *(rdi) = rax;
        *((rdi + 8)) = 3;
        rax = *((rsp + 0x18));
        al &= 0x18;
        rbx = *((rax + 0x30));
        *((rdi + 0x10)) = rbx;
        rax = *((rax + 0x40));
        *((rdi + 0x18)) = rax;
        *((rdi + 0x20)) = rsi;
        rax = *((rsp + 8));
        rbx = rdi;
        camlPrintf_loop_187 ();
        rbx = *(rsp);
        rbx += 0xfffffffffffffffe;
        rax = *((rsp + 0x10));
        rdi = *((rsp + 0x18));
    } while (1);
label_3:
    rax = *((rsi + 0x30));
    void (*0x41d5c0)() ();
    rax = rbx;
    rax += 2;
    return rax;
    rsi = *((rsi + 0x38));
    rdi = 0xe7;
    rax = rcx;
    void (*0x40a560)() ();
    rsi = *((rsi + 0x38));
    rdi = 0xc7;
    rax = rcx;
    void (*0x40a560)() ();
    rsi = *((rsi + 0x38));
    rdi = 0xd3;
    rax = rcx;
    void (*0x40a560)() ();
    rsi = *((rsi + 0x38));
    rdi = 0xcd;
    rax = rcx;
    void (*0x40a560)() ();
    rsi = *((rsi + 0x38));
    rdi = 0x85;
    rax = rcx;
    void (*0x40a560)() ();
    rsi = *((rsi + 0x38));
    rax = rcx;
    void (*0x40a560)() ();
    r8 = rbx;
    r8 += 2;
    rax = *((rsi + 0x48));
    if (r8 > rax) {
        rsi = *((rsi + 0x38));
        rdi = 0xd3;
        rax = rcx;
        void (*0x40a560)() ();
    }
    r9 = *((rsi + 0x30));
    r8 >>= 1;
    rax = *((r9 - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rdx = *((r9 + rax));
    rax -= rdx;
    if (rax > r8) {
        rax = *((r9 + r8));
        rax = rax + rax + 1;
        rax += 0xffffffffffffff50;
        if (rax <= 0x41) {
            rax >>= 1;
            rdx = 0x00435648;
            rax = *((rdx + rax*4));
            rdx += rax;
            /* switch table (66 cases) at 0x435648 */
            void (*rdx)(uint64_t) (rsi);
        }
        rsi = *((rsi + 0x38));
        rdi = 0xd3;
        rax = rcx;
        void (*0x40a560)() ();
        rsi = *((rsi + 0x38));
        rax = rcx;
        caml_apply3 ();
        rbx = *((rsp + 0x18));
        rdi = *((rbx + 0x40));
        rbx = 0xd3;
        void (*0x40a5b0)() ();
        rsi = *((rsi + 0x38));
        rax = rcx;
        void (*0x40a560)() ();
label_4:
        caml_call_gc ();
        goto label_0;
    }
    rax = caml_ml_array_bound_error ();
    do {
label_1:
        rsi = rax;
        rax = *((rdi + 0x68));
        if (rbx > rax) {
            rax = *((rdi + 0x50));
            void (*0x41d610)() ();
            *(rdi) += cl;
        }
        rdx = rbx;
        rdx >>= 1;
        rax = *((rdi + 0x50));
        rax = *((rax + rdx));
        dh = 4;
        *((rax - 0x73)) += cl;
        *(rcx) += r8b;
        if (rax < 0x75) {
            goto label_5;
        }
        if (rax != 0xbf) {
            goto label_6;
        }
        rbx += 2;
        rax = 3;
    } while (1);
label_5:
    if (rax >= 0x41) {
        rax += 0xffffffffffffffc0;
        rax >>= 1;
        rdx = 0x004356cc;
        rax = *((rdx + rax*4));
        rdx += rax;
        /* switch table (66 cases) at 0x4356cc */
        void (*rdx)(uint64_t, uint64_t) (rsi, rdi);
        rdx = *((rdi + 0x58));
        rdi = 0xd3;
        rax = rsi;
        rsi = rdx;
        rax = caml_apply3 ();
        rbx = rax;
        rax = *(rsp);
        rdi = *((rsp + 8));
        goto label_1;
    }
label_6:
    rdi += 0x20;
    rax = rsi;
    goto label_2;
    rbx += 2;
    rax = rsi;
    goto label_1;
    rbx += 2;
    rax = rsi;
    goto label_1;
    *(rax) += al;
    *((rax - 0x75)) += cl;
    eax += 0x22346e;
    *(rax) += al;
    *((rbx + rbx + 0x48)) += dh;
    rax >>= 9;
    if (rax <= rbx) {
        goto label_7;
    }
    do {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rsi + rbx*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_7:
    caml_ml_array_bound_error ();
    al = caml_ml_array_bound_error ();
    *(rax) += al;
    *(rax) += al;
    eax = *((rcx + 0x18));
    rax = *((rax + rdx));
    rdi = rax + rax + 1;
    if (rdi < 0xf9) {
        rax = rdi;
        rax >>= 1;
        rdx = 0x00435734;
        rax = *((rdx + rax*4));
        rdx += rax;
        /* switch table (190 cases) at 0x435734 */
        void (*rdx)(uint64_t) (rdi);
        rdi = *((rcx + 0x40));
        rsi += 2;
        rax = rbx;
        rbx = rsi;
        void (*0x40a5b0)() ();
        rcx = *((rcx + 0x28));
        rdi = rsi;
        rdi += 2;
        rdx = *(loc.camlPrintf__61);
        al &= *(rax);
        rax = rbx;
        rbx = rdx;
        rsi = rcx;
        void (*0x40a560)() ();
        rcx = *((rcx + 0x28));
        rdi = rsi;
        rdi += 2;
        rdx = *(loc.camlPrintf__62);
        rax = rbx;
        rbx = rdx;
        rsi = rcx;
        void (*0x40a560)() ();
        rcx = *((rcx + 0x28));
        rdi = rsi;
        rdi += 2;
        rdx = *(loc.camlPrintf__63);
        rax = rbx;
        rbx = rdx;
        rsi = rcx;
        void (*0x40a560)() ();
        *(rsp) = rdi;
        rdi = *((rcx + 0x50));
        rax = r8;
        rax = camlPrintf_get_arg_320 ();
        *((rsp + 8)) = rax;
        rdx = *((rsp + 0x10));
        if (rdx == 1) {
            rax = camlPervasives_string_of_float_164 ();
            *(rsp) = rax;
        } else {
            rax = *((rsp + 0x30));
            rdi = *((rax + 0x20));
            rbx = *((rax + 0x18));
            rax = *(rsp);
            rsi = *((rsp + 0x18));
            camlPrintf_extract_format_float_138 ();
            rbx = *((rsp + 8));
            rax = camlPrintf_fun_630 ();
            *(rsp) = rax;
        }
        rax = *((rsp + 0x20));
        if (rax != 1) {
            rax = *((rsp + 0x28));
        } else {
            rax = *(reloc.camlPrintf);
            rax = *((rax + 0x58));
            rbx = *((rax + 0x10));
            rdi = *(rbx);
            rax = *((rsp + 0x28));
            void (*rdi)() ();
        }
        rbx = *((rsp + 0x30));
        rsi = *((rbx + 0x28));
        rdi = *((rsp + 0x18));
        rdi += 2;
        rbx = *(rsp);
        void (*0x40a560)() ();
        rdi = *((rcx + 0x50));
        rax = r8;
        rax = camlPrintf_get_arg_320 ();
        *(rsp) = rax;
        rax = *(reloc.camlPrintf);
        rax = *((rax + 0x58));
        rbx = *((rax + 0x10));
        rax = *((rsp + 0x20));
        eax = *((rsp + 0x20));
        if (rax != 1) {
            rax = *(rax);
        } else {
            rax = *((rsp + 0x28));
        }
        rdi = *(rbx);
        rax = void (*rdi)() ();
        rbx = rax;
        *((rsp + 0x10)) = rbx;
        rax = *((rsp + 0x30));
        rdi = *((rax + 0x50));
        rax = 1;
        rax = camlPrintf_get_arg_320 ();
        *((rsp + 8)) = rax;
        rax = *((rsp + 0x20));
        if (rax != 1) {
            rax = *((rsp + 0x10));
        } else {
            rax = *(reloc.camlPrintf);
            rax = *((rax + 0x58));
            rbx = *((rax + 0x10));
            rdi = *(rbx);
            rax = *((rsp + 0x10));
            void (*rdi)() ();
        }
        rbx = *((rsp + 0x30));
        rdx = *((rbx + 0x30));
        rsi = *((rsp + 0x18));
        rsi += 2;
        rbx = *(rsp);
        rdi = *((rsp + 8));
        void (*0x40a500)() ();
        rdi = *((rcx + 0x50));
        rax = r8;
        rax = camlPrintf_get_arg_320 ();
        *(rsp) = rax;
        rax = *((rsp + 0x20));
        if (rax != 1) {
            rax = *((rsp + 0x28));
        } else {
            rax = *(reloc.camlPrintf);
            rax = *((rax + 0x58));
            rbx = *((rax + 0x10));
            rdi = *(rbx);
            rax = *((rsp + 0x28));
            void (*rdi)() ();
        }
        rbx = *((rsp + 0x30));
        rsi = *((rbx + 0x38));
        rdi = *((rsp + 0x18));
        rdi += 2;
        rbx = *(rsp);
        void (*0x40a560)() ();
    }
    rax = *((rcx + 0x18));
    rbx = rsi;
    void (*0x41d5c0)() ();
    rdi = *((rcx + 0x50));
    rax = r8;
    camlPrintf_get_arg_320 ();
    rbx = *(rsp);
    if (rbx == 0xe7) {
    } else {
        camlString_escaped_108 ();
        rbx = *(loc.camlPrintf__60);
        rax = camlPervasives_$5e_136 ();
        rbx = rax;
        rax = *(loc.camlPrintf__59);
        rax = camlPervasives_$5e_136 ();
    }
    rsi = *((rsp + 0x30));
    rbx = *((rsi + 0x20));
    rbx += 2;
    rdi = *((rsp + 0x18));
    if (rdi == rbx) {
        *(rsp) = rax;
    } else {
        *(rsp) = rax;
        rbx = *((rsi + 0x20));
        rax = *((rsi + 0x18));
        rsi = *((rsp + 0x10));
        camlPrintf_extract_format_113 ();
        rbx = *(rsp);
        rax = camlPrintf_format_string_108 ();
        *(rsp) = rax;
    }
    rax = *((rsp + 0x20));
    if (rax != 1) {
        rax = *((rsp + 0x28));
    } else {
        rax = *(reloc.camlPrintf);
        rax = *((rax + 0x58));
        rbx = *((rax + 0x10));
        rdi = *(rbx);
        rax = *((rsp + 0x28));
        void (*rdi)() ();
    }
    rbx = *((rsp + 0x30));
    rsi = *((rbx + 0x28));
    rdi = *((rsp + 0x18));
    rdi += 2;
    rbx = *(rsp);
    void (*0x40a560)() ();
    *(rsp) = rdi;
    rdi = *((rcx + 0x50));
    rax = r8;
    rax = camlPrintf_get_arg_320 ();
    rbx = rax;
    rax = *(rsp);
    if (rax == 0xc7) {
        rax = 3;
        rax = camlString_make_66 ();
        *(rsp) = rax;
    } else {
        rax = rbx;
        camlChar_escaped_66 ();
        rbx = *(loc.camlPrintf__58);
        rax = camlPervasives_$5e_136 ();
        rbx = rax;
        rax = *(loc.camlPrintf__57);
        rax = camlPervasives_$5e_136 ();
        *(rsp) = rax;
    }
    rax = *((rsp + 0x20));
    if (rax != 1) {
        rax = *((rsp + 0x28));
    } else {
        rax = *(reloc.camlPrintf);
        rax = *((rax + 0x58));
        eax = *((rax + 0x58));
        rbx = *((rax + 0x10));
        rdi = *(rbx);
        rax = *((rsp + 0x28));
        void (*rdi)() ();
    }
    rbx = *((rsp + 0x30));
    rsi = *((rbx + 0x28));
    rdi = *((rsp + 0x18));
    rdi += 2;
    rbx = *(rsp);
    void (*0x40a560)() ();
    *(rsp) = rdi;
    rdi = *((rcx + 0x50));
    rax = r8;
    rax = camlPrintf_get_arg_320 ();
    *((rsp + 8)) = rax;
    rax = *((rsp + 0x30));
    rdi = *((rax + 0x20));
    rbx = *((rax + 0x18));
    rax = *(rsp);
    rsi = *((rsp + 0x18));
    rdx = *((rsp + 0x10));
    rax = camlPrintf_extract_format_int_131 ();
    rdi = rax;
    rsi = *((rsp + 8));
    rax = *(reloc.caml_format_int);
    rax = caml_c_call ();
    *(rsp) = rax;
    rax = *((rsp + 0x20));
    if (rax != 1) {
        rax = *((rsp + 0x28));
    } else {
        rax = *(reloc.camlPrintf);
        rax = *((rax + 0x58));
        rbx = *((rax + 0x10));
        rdi = *(rbx);
        rax = *((rsp + 0x28));
        void (*rdi)() ();
    }
    rbx = *((rsp + 0x30));
    rsi = *((rbx + 0x28));
    rdi = *((rsp + 0x18));
    rdi += 2;
    rbx = *(rsp);
    void (*0x40a560)() ();
    rdi = *((rcx + 0x50));
    rax = r8;
    rax = camlPrintf_get_arg_320 ();
    *(rsp) = rax;
    rax = *((rsp + 0x30));
    rbx = *((rax + 0x20));
    rax = *((rax + 0x18));
    rdi = *((rsp + 0x18));
    rsi = *((rsp + 0x10));
    if (rdi != 0) {
        al += ch;
        al &= 0xb;
        *(rax) += al;
        rdi = rax;
        rsi = *(rsp);
        rax = *(reloc.caml_format_float);
        rax = caml_c_call ();
        *(rsp) = rax;
        rax = *((rsp + 0x20));
    }
    __asm ("clc");
    if (rax != 1) {
        *((rdx + rcx + 0x48)) += esi;
        rax = *((rsp + 0x28));
    } else {
        rax = *(reloc.camlPrintf);
        rax = *((rax + 0x58));
        rbx = *((rax + 0x10));
        rdi = *(rbx);
        rax = *((rsp + 0x28));
        void (*rdi)() ();
    }
    rbx = *((rsp + 0x30));
    rsi = *((rbx + 0x28));
    rdi = *((rsp + 0x18));
    rdi += 2;
    rbx = *(rsp);
    void (*0x40a560)() ();
    rdi = *((rcx + 0x50));
    rax = r8;
    camlPrintf_get_arg_320 ();
    rax = camlPervasives_string_of_bool_151 ();
    *(rsp) = rax;
    rax = *((rsp + 0x20));
    if (rax != 1) {
        rax = *((rsp + 0x28));
    } else {
        rax = *(reloc.camlPrintf);
        rax = *((rax + 0x58));
        rbx = *((rax + 0x10));
        rdi = *(rbx);
        rax = *((rsp + 0x28));
        void (*rdi)() ();
    }
    rbx = *((rsp + 0x30));
    rsi = *((rbx + 0x28));
    rdi = *((rsp + 0x18));
    rdi += 2;
    rbx = *(rsp);
    void (*0x40a560)() ();
    rdx = rsi;
    rdx += 2;
    rdx >>= 1;
    rax = *((rcx + 0x18));
    rax = *((rax + rdx));
    rax = rax + rax + 1;
    rax += 0xffffffffffffff50;
    if (rax <= 0x41) {
        rax >>= 1;
        rdx = 0x00435924;
        rax = *((rdx + rax*4));
        rdx += rax;
        /* switch table (66 cases) at 0x435924 */
        void (*rdx)() ();
    }
    rdi = *((rcx + 0x50));
    rax = r8;
    rax = camlPrintf_get_arg_320 ();
    *(rsp) = rax;
    rax = *((rsp + 0x30));
    rdi = *((rax + 0x20));
    rbx = *((rax + 0x18));
    rax = 0xdd;
    rsi = *((rsp + 0x18));
    rdx = *((rsp + 0x10));
    rax = camlPrintf_extract_format_int_131 ();
    rdi = rax;
    rsi = *(rsp);
    rax = *(reloc.caml_format_int);
    rax = caml_c_call ();
    *(rsp) = rax;
    rax = *((rsp + 0x20));
    if (rax != 1) {
        rax = *((rsp + 0x28));
    } else {
        rax = *(reloc.camlPrintf);
        rax = *((rax + 0x58));
        rbx = *((rax + 0x10));
        rdi = *(rbx);
        rax = *((rsp + 0x28));
        void (*rdi)() ();
    }
    rbx = *((rsp + 0x30));
    rsi = *((rbx + 0x28));
    rdi = *((rsp + 0x18));
    rdi += 2;
    rbx = *(rsp);
    void (*0x40a560)() ();
    rsi += 2;
    *((rsp + 8)) = rsi;
    rdi += 0xffffffffffffff28;
    if (rdi <= 5) {
        rdi >>= 1;
        if (rdi != 1) {
            if (rdi <= 1) {
                rdi = *((rcx + 0x50));
                rax = r8;
                rax = camlPrintf_get_arg_320 ();
                *(rsp) = rax;
                rax = *((rsp + 0x30));
                rbx = *((rax + 0x20));
                rax = *((rax + 0x18));
                rdi = *((rsp + 8));
                rsi = *((rsp + 0x10));
                rax = camlPrintf_extract_format_113 ();
                rdi = rax;
                rsi = *(rsp);
                rax = *(reloc.caml_int32_format);
                rax = caml_c_call ();
                *(rsp) = rax;
                goto label_8;
            }
            rdi = *((rcx + 0x50));
            rax = r8;
            rax = camlPrintf_get_arg_320 ();
            *(rsp) = rax;
            rax = *((rsp + 0x30));
            rbx = *((rax + 0x20));
            rax = *((rax + 0x18));
            rdi = *((rsp + 8));
            rsi = *((rsp + 0x10));
            if (rdi == 1) {
                goto label_9;
            }
            al += ch;
            return _hlt ();
            *(rax) |= al;
            *((rax - 0x77)) += cl;
            rsi = *(rsp);
            rax = *(reloc.caml_nativeint_format);
            rax = caml_c_call ();
            *(rsp) = rax;
        }
    } else {
        rdi = *((rcx + 0x50));
        if (*((rax - 0x77)) >= 0) {
label_9:
            goto label_10;
        }
        rax = r8;
        rax = camlPrintf_get_arg_320 ();
        *(rsp) = rax;
        rax = *((rsp + 0x30));
        rbx = *((rax + 0x20));
        rax = *((rax + 0x18));
        rdi = *((rsp + 8));
        rsi = *((rsp + 0x10));
        rax = camlPrintf_extract_format_113 ();
        rdi = rax;
        rsi = *(rsp);
        rax = *(reloc.caml_int64_format);
        rax = caml_c_call ();
        *(rsp) = rax;
    }
label_8:
    rax = *((rsp + 0x20));
    if (rax != 1) {
        rax = *((rsp + 0x28));
        goto label_11;
label_10:
        al -= 0xf;
    }
    rax = *(reloc.camlPrintf);
    rax = *((rax + 0x58));
    rbx = *((rax + 0x10));
    rdi = *(rbx);
    rax = *((rsp + 0x28));
    void (*rdi)() ();
label_11:
    rbx = *((rsp + 0x30));
    rsi = *((rbx + 0x28));
    rdi = *((rsp + 8));
    rdi += 2;
    rbx = *(rsp);
    void (*0x40a560)() ();
    *((rsp + 8)) = rdi;
    rdi = *((rcx + 0x50));
    rax = r8;
    rax = camlPrintf_get_arg_320 ();
    *((rsp + 0x10)) = rax;
    rax = *((rsp + 0x18));
    rax += 2;
    *(rsp) = rax;
    rax = *((rsp + 8));
    rax = camlPrintf_sub_format_for_printf_163 ();
    rdi = rax;
    rax = *((rsp + 0x30));
    rax = *((rax + 0x18));
    rbx = *(rsp);
    rax = caml_apply2 ();
    *((rsp + 0x18)) = rax;
    rax = *((rsp + 8));
    if (rax == 0xf7) {
        rax = *((rsp + 0x10));
        rax = camlPrintf_summarize_format_type_190 ();
        *(rsp) = rax;
        rax = *((rsp + 0x20));
        if (rax != 1) {
            rax = *((rsp + 0x28));
        } else {
            rax = *(reloc.camlPrintf);
            rax = *((rax + 0x58));
            rbx = *((rax + 0x10));
            rdi = *(rbx);
            rax = *((rsp + 0x28));
            void (*rdi)() ();
        }
        rbx = *((rsp + 0x30));
        rsi = *((rbx + 0x28));
        rbx = *(rsp);
        rdi = *((rsp + 0x18));
        void (*0x40a560)() ();
    }
    rax = *((rsp + 0x20));
    if (rax != 1) {
        rax = *((rsp + 0x28));
    } else {
        rax = *(reloc.camlPrintf);
        rax = *((rax + 0x58));
        rbx = *((rax + 0x10));
        rdi = *(rbx);
        rax = *((rsp + 0x28));
        al = void (*rdi)() ();
    }
    rbx = *((rsp + 0x30));
    rsi = *((rbx + 0x48));
    rbx = *((rsp + 0x10));
    rdi = *((rsp + 0x18));
    void (*0x40a560)() ();
    *(rax) += al;
    *((rax - 0x2f)) += cl;
    __asm ("clc");
    camlPrintf_scan_fmt_172 ();
    rax = 1;
    return rax;
    eax -= 0x89480022;
    *((r8 - 0x77)) += cl;
    if (*((r8 - 0x77)) < 0) {
        *((rbx + 0x20)) = rdi;
        rax = *(rsp);
        camlPrintf_iter_on_format_args_165 ();
        rax = *((rsp + 8));
        rdi = *((rax + 8));
        rbx = 1;
    }
    return rax;
    *(rax) += eax;
    *(rax) += al;
    rax = *(rax);
    void (*0x416a50)() ();
    do {
        r15 -= 0x70;
        rax = *(reloc.caml_young_limit);
        eax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *(rsp) = rbx;
            *((rbx - 8)) = 0xc00;
            *(rbx) = 1;
            *((rbx + 8)) = 1;
            *((rbx + 0x10)) = 1;
            rdi = rbx + 0x20;
            *((rdi - 8)) = 0x10f7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlPrintf__incr_ac_215);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = rbx;
            rbx += 0x48;
            *((rbx - 8)) = 0x10f7;
            rax = *(reloc.caml_curry3);
            *(rbx) = rax;
            *((rbx + 8)) = 7;
            rax = *(reloc.camlPrintf__add_conv_219);
            *((rbx + 0x10)) = rax;
            *((rbx + 0x18)) = rdi;
            rdi = *(loc.camlPrintf__48);
            rax = rsi;
            camlPrintf_iter_on_format_args_165 ();
            rax = *(rsp);
            return rax;
        }
        caml_call_gc ();
    } while (1);
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        al &= *(rax);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x10f7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlPrintf__loop_232);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = rsi;
            rax = 1;
            void (*0x41bba0)() ();
        }
        eax = caml_call_gc ();
    } while (1);
    *((rax - 0x75))--;
    *((rax - 0x7d)) -= cl;
    __asm ("sti");
    eax |= 0x83496a76;
    r15 -= 0x38;
    rax = *(reloc.caml_young_limit);
    al = 1;
    *(rax) += al;
    *(rax) += eax;
    *((rcx - 0x73)) += cl;
    *((r8 - 0x39)) |= r9b;
    __asm ("clc");
    rax + rax = ~rax + rax;
    *((rax - 0x75)) += cl;
    eax -= 0x221a85;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40f640 */
#include <stdint.h>
 
int64_t camlPervasives_loop_162 (void) {
    do {
        rdi = *((rbx + 0x18));
        if (rax >= rdi) {
            rdi = *(loc.camlPervasives__103);
            rax = *((rbx + 0x10));
            rbx = rdi;
            void (*0x40fd20)() ();
        }
        rcx = *((rbx + 0x10));
        rdx = rax;
        rdx >>= 1;
        rdi = *((rcx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rcx + rdi));
        rdi -= rsi;
        if (rdi <= rdx) {
            goto label_0;
        }
        rdi = *((rcx + rdx));
        rdi = rdi + rdi + 1;
        if (rdi >= 0x61) {
            if (rdi < 0x75) {
                goto label_1;
            }
        } else {
            if (rdi == 0x5b) {
                goto label_1;
            }
        }
        rax = *((rbx + 0x10));
        return rax;
label_1:
        rax += 2;
    } while (1);
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429520 */
#include <stdint.h>
 
int64_t caml_format_int (int64_t arg2, int64_t arg1) {
    int64_t var_fh;
    int64_t var_10h;
    int64_t var_30h;
    int64_t var_58h;
    int64_t var_68h;
    int64_t var_70h;
    int64_t var_78h;
    int64_t var_80h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x20)) = rbx;
    *((rsp - 0x18)) = rbp;
    *((rsp - 0x10)) = r12;
    *((rsp - 8)) = r13;
    rbp = rsp + 0x10;
    r12 = rsp + 0x30;
    r8 = rsp + 0xf;
    r13 = rsi;
    esi = 0x436e5b;
    rcx = rbp;
    rdx = r12;
    rax = *(fs:0x28);
    *((rsp + 0x58)) = rax;
    eax = 0;
    rax = parse_format ();
    ecx = *((rsp + 0xf));
    rbx = rax;
    ecx -= 0x58;
    if (cl <= 0x20) {
        eax = 1;
        rdx = 0x120800001;
        rax <<= cl;
        if ((rax & rdx) != 0) {
            goto label_0;
        }
    }
    r8 = r13;
    r8 >>= 1;
    do {
        rcx = r12;
        rdx = 0xffffffffffffffff;
        esi = 1;
        rdi = rbx;
        eax = 0;
        sprintf_chk ();
        rdi = rbx;
        rax = caml_copy_string ();
        r12 = rax;
        if (rbx != rbp) {
            rdi = rbx;
            caml_stat_free ();
        }
        rdx = *((rsp + 0x58));
        rdx ^= *(fs:0x28);
        rax = r12;
        if (rbx != rbp) {
            goto label_1;
        }
        rbx = *((rsp + 0x68));
        rbp = *((rsp + 0x70));
        r12 = *((rsp + 0x78));
        r13 = *((rsp + 0x80));
        return rax;
label_0:
        r8 = r13;
        r8 >>= 1;
    } while (1);
label_1:
    return stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4189f0 */
#include <stdint.h>
 
int64_t camlHashtbl_replace_245 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_18h_2;
    int64_t var_38h_2;
    int64_t var_38h;
    int64_t var_48h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
label_0:
    r15 -= 0x30;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    rcx = r15 + 8;
    *((rcx - 8)) = 0x14f7;
    rax = *(reloc.camlHashtbl__replace_bucket_249);
    *(rcx) = rax;
    *((rcx + 8)) = 3;
    rax = *((rsi + 0x18));
    *((rcx + 0x10)) = rax;
    *((rcx + 0x18)) = rbx;
    *((rcx + 0x20)) = rdi;
    rax = *((rdx + 8));
    rax = *((rax - 8));
    rax >>= 0xa;
    if (rax != 0) {
        rax = *((rsi + 0x20));
        rax = *((rax + 0x10));
        rsi = *((rax + 8));
        rdi = *(rsi);
        rax = rbx;
        rbx = rsi;
        rax = void (*rdi)(uint64_t, uint64_t) (rax, rbx);
        rbx = 0x7fffffffffffffff;
        rax &= rbx;
        rax >>= 1;
        rcx = *((rsp + 0x18));
        __asm ("cqo");
        rax = rdx:rax / rcx;
        rdx = rdx:rax % rcx;
    } else {
        rax = *(reloc.caml_bucket_Division_by_zero);
        caml_raise_exn ();
    }
    rdx <<= 1;
    rdx++;
    *((rsp + 0x38)) = rdx;
    rbx = *(rsp);
    rdi = *((rbx + 8));
    rax = *((rdi - 8));
    rax >>= 9;
    if (rax <= rdx) {
        goto label_2;
    }
    rax = *((rdi + rdx*4 - 4));
    *((rsp + 0x18)) = rax;
    rax = void (*0x418b98)() ();
    rdi = *(reloc.caml_exn_Not_found);
    rbx = *(rax);
    if (rbx != rdi) {
        goto label_3;
    }
    rbx = *(rsp);
    rdx = *((rbx + 8));
    rax = *((rdx - 8));
    rax >>= 9;
    rdi = *((rsp + 0x38));
    if (rax <= rdi) {
        goto label_4;
    }
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0xc00;
            rax = *((rsp + 8));
            *(rsi) = rax;
            rax = *((rsp + 0x10));
            *((rsi + 8)) = rax;
            rax = *((rsp + 0x18));
            *((rsi + 0x10)) = rax;
            rdi = rdx + rdi*4 - 4;
            caml_modify ();
            *(rbx) += 2;
            rax = *((rbx + 8));
            rax = *((rax - 8));
            rax >>= 9;
            rax |= 1;
            rdi = rax + rax - 1;
            rax = *(rbx);
            if (rax > rdi) {
                rax = *((rsp + 0x20));
                rax = *((rax + 0x20));
                void (*0x418e60)() ();
            }
            rax = 1;
            return rax;
label_3:
            rax = caml_raise_exn ();
            r14 = rsp;
            rbx = *((rbx + 8));
            *((rsp + 0x40)) = rbx;
            rbx = *((rbx - 8));
            rbx >>= 9;
            if (rbx <= rdx) {
                goto label_5;
            }
            rbx = *((rsp + 0x38));
            rax = camlHashtbl_replace_bucket_249 ();
            rdi = *((rsp + 0x40));
            rbx = *((rsp + 0x48));
            rdi = rdi + rbx*4 - 4;
            rsi = rax;
            caml_modify ();
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ef58 */
#include <stdint.h>
 
int64_t unix_bind (int64_t arg2, int64_t arg1) {
    socklen_t address_len;
    int64_t var_10h;
    int64_t canary;
    rsi = arg2;
    rdi = arg1;
    rdi = rsi;
    rax = *(fs:0x28);
    *((rsp + 0x88)) = rax;
    eax = 0;
    rdx = rsp + 0xc;
    rbx = rsp + 0x10;
    rsi = rbx;
    get_sockaddr ();
    rdi >>= 1;
    eax = bind (rbp, rbx, *((rsp + 0xc)));
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "bind";
        uerror ();
    }
    eax = 1;
    rdx = *((rsp + 0x88));
    rdx ^= *(fs:0x28);
    if (eax != 0xffffffff) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421b10 */
#include <stdint.h>
 
int64_t unix_setsid (void) {
    setsid ();
    rax = (int64_t) eax;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408de0 */
#include <stdint.h>
 
void setsid (void) {
    setsid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f0d8 */
#include <stdint.h>
 
int64_t unix_connect (int64_t arg2, int64_t arg1) {
    size_t addrlen;
    int64_t var_10h;
    int64_t canary;
    rsi = arg2;
    rdi = arg1;
    rdi = rsi;
    rax = *(fs:0x28);
    *((rsp + 0x88)) = rax;
    eax = 0;
    rdx = rsp + 0xc;
    rbx = rsp + 0x10;
    rsi = rbx;
    get_sockaddr ();
    caml_enter_blocking_section ();
    rdi >>= 1;
    eax = connect (rbp, rbx, *((rsp + 0xc)));
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx == 0xffffffff) {
        esi = 0;
        rdi = "connect";
        uerror ();
    }
    eax = 1;
    rdx = *((rsp + 0x88));
    rdx ^= *(fs:0x28);
    if (ebx != 0xffffffff) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429190 */
#include <stdint.h>
 
uint64_t caml_int_of_string (int64_t arg1) {
    rdi = arg1;
    esi = 0x3f;
    parse_intnat ();
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428f50 */
#include <stdint.h>
 
int64_t parse_intnat (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    r14 = rdi;
    r13d = 1;
    r12d = esi;
    rbx = rdi;
    eax = *(rdi);
    if (al == 0x2d) {
        goto label_6;
    }
label_3:
    rsi = 0x1999999999999999;
    edi = 0xa;
    r15d = 0xa;
    if (al != 0x30) {
label_5:
        edx = rax - 0x30;
        ebp = (int32_t) al;
        if (dl > 9) {
            edx = rax - 0x41;
            if (dl > 5) {
                goto label_7;
            }
            ebp -= 0x37;
        } else {
            ecx = *((r14 + 1));
            ecx -= 0x42;
            if (cl <= 0x36) {
                goto label_8;
            }
label_4:
            edi = 0xa;
            r15d = 0xa;
            rsi = 0x1999999999999999;
        }
        ebp -= 0x30;
    }
label_2:
    if (ebp < 0) {
        goto label_9;
    }
    if (ebp >= r15d) {
        goto label_9;
    }
    r14++;
    rbp = (int64_t) ebp;
    goto label_10;
label_0:
    eax = rcx - 0x30;
label_1:
    if (eax < 0) {
        goto label_11;
    }
    if (eax >= r15d) {
        goto label_11;
    }
    if (rbp > rsi) {
        goto label_9;
    }
    rbp *= rdi;
    rax = (int64_t) eax;
    rbp += rax;
    if (rbp < 0) {
        goto label_9;
    }
    do {
        r14++;
label_10:
        eax = *(r14);
    } while (al == 0x5f);
    edx = rax - 0x30;
    ecx = (int32_t) al;
    if (dl <= 9) {
        goto label_0;
    }
    edx = rax - 0x41;
    if (dl <= 5) {
        eax = rcx - 0x37;
        goto label_1;
    }
    eax -= 0x61;
    if (al <= 5) {
        goto label_12;
    }
label_11:
    rdi = rbx;
    caml_string_length ();
    rbx = rax + rbx;
    if (r14 != rbx) {
        goto label_9;
    }
    if (r15d == 0xa) {
        goto label_13;
    }
    if (r12d > 0x3f) {
        goto label_14;
    }
    eax = 1;
    ecx = r12d;
    rax <<= cl;
    if (rbp >= rax) {
        goto label_9;
    }
    do {
label_14:
        rax = rbp;
        rax = -rax;
        if (r13d != 0xffffffff) {
            rax = rbp;
        }
        return rax;
label_12:
        eax = rcx - 0x57;
        goto label_1;
label_7:
        eax -= 0x61;
        if (al > 5) {
            goto label_9;
        }
        ebp -= 0x57;
        goto label_2;
label_6:
        r14 = rdi + 1;
        eax = *((rdi + 1));
        r13d = 0xffffffff;
        goto label_3;
label_13:
        ecx = r12 - 1;
        eax = 1;
        rax <<= cl;
    } while (rbp <= rax);
label_9:
    edi = "int_of_string";
    caml_failwith ();
label_8:
    eax = 1;
    rdx = 0x40000000400000;
    rax <<= cl;
    if ((rax & rdx) != 0) {
        goto label_15;
    }
    rdx = 0x200000002000;
    if ((rax & rdx) != 0) {
        goto label_16;
    }
    rdx = 0x100000001;
    if ((rax & rdx) == 0) {
        goto label_4;
    }
    r14 += 2;
    rsi = 0x7fffffffffffffff;
    edi = 2;
    eax = *(r14);
    r15d = 2;
    goto label_5;
label_16:
    r14 += 2;
    rsi = 0x1fffffffffffffff;
    edi = 8;
    eax = *(r14);
    r15d = 8;
    goto label_5;
label_15:
    r14 += 2;
    rsi = 0xfffffffffffffff;
    edi = 0x10;
    eax = *(r14);
    r15d = 0x10;
    goto label_5;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fb48 */
#include <stdint.h>
 
uint64_t unix_getgid (void) {
    eax = getgid ();
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408dc0 */
#include <stdint.h>
 
void getgid (void) {
    getgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b410 */
#include <stdint.h>
 
int64_t caml_ml_pos_out_64 (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    rdi = *((rax + 0x18));
    rdi += *((rax + 8));
    rax += 0x50;
    rdi -= rax;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41aef0 */
#include <stdint.h>
 
uint64_t camlPrintf_got_spec_336 (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    rdi = arg1;
    *(rsp) = rax;
    *((rsp + 0x18)) = rbx;
    rbx = rdi;
    *((rsp + 8)) = rbx;
    rdi = *((rbx + 0x18));
    rbx = *((rbx + 0x30));
    rax = camlPrintf_get_arg_320 ();
    rbx = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rsp + 0x10)) = rdi;
            *((rdi - 8)) = 0x800;
            *(rdi) = rbx;
            rax = *((rsp + 8));
            rbx = *((rax + 0x38));
            *((rdi + 8)) = rbx;
            rax = *((rax + 0x30));
            rdi = *(rsp);
            if (rdi != 1) {
                rbx = rax;
            } else {
                rdi = *((rdi + 0x58));
                rbx = *((rdi + 0x10));
                rdi = *(rbx);
                rax = camlPrintf ();
                rbx = rax;
            }
            rdi = *((rsp + 8));
            rdx = *((rdi + 0x20));
            rax = *((rdi + 0x28));
            rdi = *((rsp + 0x10));
            rsi = *((rsp + 0x18));
            void (*0x41d0f0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f3b0 */
#include <stdint.h>
 
uint32_t unix_fchown (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rdx >>= 1;
    rsi >>= 1;
    rdi >>= 1;
    eax = fchown ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "fchown";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409730 */
#include <stdint.h>
 
void fchown (void) {
    fchown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420b74 */
#include <stdint.h>
 
uint64_t unix_lockf (int64_t arg3, uint32_t arg2, int64_t arg1) {
    int64_t var_2h;
    int64_t var_8h;
    int64_t var_10h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rbx >>= 1;
    *((rsp + 2)) = 1;
    rdx >>= 1;
    if (rdx < 0) {
        *((rsp + 8)) = rdx;
        rdx = -rdx;
        *((rsp + 0x10)) = rdx;
    } else {
        *((rsp + 8)) = 0;
        *((rsp + 0x10)) = rdx;
    }
    rsi >>= 1;
    if (esi <= 5) {
        rax = 0x00435bb0;
        rdx = *((rax + rsi*4));
        rax = rdx + rax;
        /* switch table (6 cases) at 0x435bb0 */
        void (*rax)() ();
        *(rsp) = 2;
        rdx = rsp;
        esi = 6;
        edi = ebx;
        eax = 0;
        eax = fcntl ();
        ebx = eax;
        goto label_0;
        *(rsp) = 1;
        caml_enter_blocking_section ();
        rdx = rsp;
        esi = 7;
        edi = ebx;
        eax = 0;
        eax = fcntl ();
        ebx = eax;
        caml_leave_blocking_section ();
        goto label_0;
        *(rsp) = 1;
        rdx = rsp;
        esi = 6;
        edi = ebx;
        eax = 0;
        eax = fcntl ();
        ebx = eax;
        goto label_0;
        *(rsp) = 1;
        rdx = rsp;
        esi = 5;
        edi = ebx;
        eax = 0;
        eax = fcntl ();
        if (eax == 0xffffffff) {
            goto label_1;
        }
        if (*(rsp) == 2) {
            goto label_2;
        }
        errno_location ();
        *(rax) = 0xd;
        goto label_1;
        *(rsp) = 0;
        caml_enter_blocking_section ();
        rdx = rsp;
        esi = 7;
        edi = ebx;
        eax = 0;
        eax = fcntl ();
        ebx = eax;
        caml_leave_blocking_section ();
        goto label_0;
        *(rsp) = 0;
        rdx = rsp;
        esi = 6;
        edi = ebx;
        eax = 0;
        eax = fcntl ();
        ebx = eax;
    } else {
        errno_location ();
        *(rax) = 0x16;
        goto label_1;
    }
label_0:
    if (ebx == 0xffffffff) {
label_1:
        esi = 0;
        rdi = "lockf";
        uerror ();
    }
label_2:
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f198 */
#include <stdint.h>
 
uint32_t unix_dup2 (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    rdi >>= 1;
    eax = dup2 ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "dup2";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408d50 */
#include <stdint.h>
 
void dup2 (void) {
    dup2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a700 */
#include <stdint.h>
 
int64_t caml_float_of_string (int64_t arg1) {
    char * * endptr;
    int64_t var_20h;
    int64_t var_68h;
    rdi = arg1;
    r13 = rsp + 0x20;
    rax = *(fs:0x28);
    *((rsp + 0x68)) = rax;
    eax = 0;
    rax = caml_string_length ();
    rbx = rax;
    r12 = r13;
    if (rax > 0x3f) {
        goto label_1;
    }
label_0:
    rax = rbp;
    while (rbx != 0) {
        edx = *(rax);
        if (dl != 0x5f) {
            *(rbp) = dl;
            rbp++;
        }
        rax++;
        rbx--;
    }
    *(rbp) = 0;
    if (rbp != r12) {
        strtod (r12, rsp + 0x18);
        if (*((rsp + 0x18)) != rbp) {
            goto label_2;
        }
        if (r12 != r13) {
            rdi = r12;
            *(rsp) = xmm0;
            caml_stat_free ();
            xmm0 = *(rsp);
        }
        caml_copy_double ();
        rdx = *((rsp + 0x68));
        rdx ^= *(fs:0x28);
        if (r12 == r13) {
            return rax;
label_1:
            rdi = rax + 1;
            r13 = rsp + 0x20;
            rax = caml_stat_alloc ();
            r12 = rax;
            goto label_0;
        }
        stack_chk_fail ();
    }
label_2:
    if (r12 != r13) {
        rdi = r12;
        caml_stat_free ();
    }
    edi = "float_of_string";
    return caml_failwith ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423280 */
#include <stdint.h>
 
int64_t unix_single_write (int64_t arg_18h, int64_t arg_20h, int64_t arg_28h, int64_t arg_50h, int64_t canary, uint32_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r12 = rdi;
    *((rsp + 8)) = rsi;
    rax = *(fs:0x28);
    *((rsp + 0x4058)) = rax;
    eax = 0;
    rax = *(reloc.caml_local_roots);
    rbx = *(rax);
    *((rsp + 0x10)) = rbx;
    rbx = rsp + 0x10;
    *(rax) = rbx;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    rax = rsp + 8;
    *((rsp + 0x28)) = rax;
    rcx >>= 1;
    if (rcx > 0) {
        ebx = 0x4000;
        if (rcx <= 0x4000) {
            rbx = rcx;
        }
        rbx = (int64_t) ebx;
        rdx >>= 1;
        rsi = rdx;
        rsi += *((rsp + 8));
        rbp = rsp + 0x50;
        ecx = 0x4000;
        rdx = rbx;
        rdi = rbp;
        memmove_chk ();
        caml_enter_blocking_section ();
        rdi >>= 1;
        eax = write (r12, rbp, rbx);
        ebx = eax;
        caml_leave_blocking_section ();
        if (ebx != 0xffffffff) {
            goto label_0;
        }
        esi = 0;
        rdi = "single_write";
        uerror ();
    }
    ebx = 0;
label_0:
    rdx = *((rsp + 0x10));
    rax = *(reloc.caml_local_roots);
    *(rax) = rdx;
    rbx = (int64_t) ebx;
    rax = rbx + rbx + 1;
    rdx = *((rsp + 0x4058));
    rdx ^= *(fs:0x28);
    if (ebx != 0xffffffff) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ee88 */
#include <stdint.h>
 
uint32_t unix_access (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rdi = rsi;
    rsi = obj_access_permission_table;
    eax = caml_convert_flag_list ();
    eax = access (rbx, eax);
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "access";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4095c0 */
#include <stdint.h>
 
void access (void) {
    access ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d0f0 */
#include <stdint.h>
 
int64_t camlPrintf_scan_flags_324 (int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        r8 = rax;
        r9 = rbx;
        rcx = rdx;
        rbx = rsi;
        rbx >>= 1;
        rax = *((rcx + 0x38));
        rax = *((rax + rbx));
        rax = rax + rax + 1;
        rax += 0xffffffffffffffc0;
        if (rax <= 0x33) {
            *(rax) += al;
            rax >>= 1;
            rdx = 0x004359a8;
            rax = *((rdx + rax*4));
            rdx += rax;
            /* switch table (33 cases) at 0x4359a8 */
            void (*rdx)() ();
label_0:
            r15 -= 0x48;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_1;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x20f7;
            rax = *(reloc.caml_curry2);
            *(rbx) = rax;
            *((rbx + 8)) = 5;
            rax = *(reloc.camlPrintf__got_spec_336);
            *((rbx + 0x10)) = rax;
            rax = *((rcx + 0x70));
            *((rbx + 0x18)) = rax;
            *((rbx + 0x20)) = rcx;
            *((rbx + 0x28)) = r8;
            *((rbx + 0x30)) = r9;
            *((rbx + 0x38)) = rdi;
            rsi += 2;
            rax = *((rcx + 0x38));
            rdi = r9;
            void (*0x41e150)() ();
        }
        rdx = rcx;
        rdx += 0x20;
        rax = r8;
        rbx = r9;
        void (*0x41c840)() ();
        rsi += 2;
        rax = r8;
        rbx = r9;
        rdx = rcx;
    } while (1);
label_1:
    al = caml_call_gc ();
    goto label_0;
    if (rsi > 0) {
        void (*0x41de9e)() ();
    }
    bh >>= 1;
    __asm ("loopne 0x41de8c");
    al -= 0x24;
    al &= 0x48;
    *((rax + 0x18)) = ebx;
    al &= 0x48;
    *((rax + 0x18)) = ebx;
    al &= 0x48;
    *((rax + 0x18)) = ebx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422ea0 */
#include <stdint.h>
 
uint32_t unix_truncate (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rsi >>= 1;
    eax = truncate64 ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = 0x00435b0e;
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429f80 */
#include <stdint.h>
 
uint64_t caml_classify_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    eax = fpclassify ();
    edx = eax;
    eax = 1;
    if (edx <= 3) {
        rdx = (int64_t) edx;
        rax = *((rdx*8 + obj.CSWTCH.118));
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4090c0 */
#include <stdint.h>
 
void fpclassify (void) {
    fpclassify ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409a20 */
#include <stdint.h>
 
int64_t caml_curry9_1 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry9_2);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421180 */
#include <stdint.h>
 
uint64_t unix_readdir (int64_t arg1) {
    rdi = arg1;
    rdi = *(rdi);
    if (rdi == 0) {
        edx = 0;
        rsi = "readdir";
        dil = 9;
        unix_error ();
    }
    rax = readdir64 ();
    if (rax == 0) {
        caml_raise_end_of_file ();
    }
    rdi = rax + 0x13;
    caml_copy_string ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409a70 */
#include <stdint.h>
 
int64_t caml_curry9_2 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry9_3);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409ac0 */
#include <stdint.h>
 
int64_t caml_curry9_3 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry9_4);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41c660 */
#include <stdint.h>
 
int64_t camlPrintf_get_int_literal_286 (int64_t arg_8h_6, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        rdx = rbx;
        rdx >>= 1;
        rsi = *((rdi + 0x18));
        rsi = *((rsi + rdx));
        rsi = rsi + rsi + 1;
        if (rsi < 0x61) {
            goto label_0;
        }
        if (rsi >= 0x75) {
            goto label_1;
        }
        rbx += 2;
        rax >>= 1;
        rax *= 0x14;
        rax = rax + rsi - 0x60;
    } while (1);
label_0:
    if (rsi != 0x49) {
        goto label_1;
    }
    if (rax == 1) {
        rax = *(loc.camlPrintf__65);
        void (*0x40fbf0)() ();
    }
    *(rsp) = rdi;
    *((rsp + 8)) = rbx;
    rax += 0xfffffffffffffffe;
    rax = camlPrintf_index_of_int_65 ();
    rbx = rax;
    do {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x400;
            *(rsi) = rbx;
            rax = *(rsp);
            rdi = *((rax + 0x20));
            rbx = *((rsp + 8));
            rbx += 2;
            rax = rsi;
            void (*0x40a5b0)() ();
label_1:
            rsi = *((rdi + 0x20));
            rbx = *((rdi + 0x28));
            rax = 1;
            rdi = rsi;
            void (*0x40a5b0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409b10 */
#include <stdint.h>
 
int64_t caml_curry9_4 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry9_5);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409b60 */
#include <stdint.h>
 
int64_t caml_curry9_5 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry9_6);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a430 */
#include <stdint.h>
 
int64_t caml_curry2_1 (void) {
    rdx = rax;
    rdi = *((rbx + 0x18));
    rax = *((rbx + 0x10));
    rsi = *((rdi + 0x10));
    rbx = rdx;
    return void (*rsi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4209c1 */
#include <stdint.h>
 
uint64_t unix_getitimer (int64_t arg1) {
    rdi = arg1;
    rsi = rsp;
    rdi >>= 1;
    rdi = (int64_t) edi;
    rax = obj_itimers;
    edi = *((rax + rdi*4));
    eax = getitimer ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "getitimer";
        uerror ();
    }
    rdi = rsp;
    unix_convert_itimer ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409680 */
#include <stdint.h>
 
void getitimer (void) {
    getitimer ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420970 */
#include <stdint.h>
 
int64_t unix_convert_itimer (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    esi = 0xfe;
    edi = 2;
    caml_alloc_small ();
    __asm ("cvtsi2sd xmm2, qword [rbx]");
    __asm ("cvtsi2sd xmm1, qword [rbx + 8]");
    xmm0 = *(0x00435b50);
    __asm ("divsd xmm1, xmm0");
    __asm ("addsd xmm1, xmm2");
    *(rax) = xmm1;
    __asm ("cvtsi2sd xmm1, qword [rbx + 0x10]");
    __asm ("cvtsi2sd xmm2, qword [rbx + 0x18]");
    __asm ("divsd xmm2, xmm0");
    __asm ("movapd xmm0, xmm2");
    __asm ("addsd xmm0, xmm1");
    *((rax + 8)) = xmm0;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4228a8 */
#include <stdint.h>
 
uint32_t unix_symlink (int64_t arg2, const char * path1) {
    rsi = arg2;
    rdi = path1;
    rbx = rsi;
    eax = symlink (rdi, rsi);
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "symlink";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408d10 */
#include <stdint.h>
 
void symlink (void) {
    symlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421080 */
#include <stdint.h>
 
int64_t unix_read (int64_t arg_18h, int64_t arg_20h, int64_t arg_28h, void * s2, int64_t canary, int64_t arg4, int64_t arg3, void * arg2, int64_t arg1) {
    void * s1;
    int64_t var_10h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 8)) = rsi;
    r12 = rdx;
    rax = *(fs:0x28);
    *((rsp + 0x4058)) = rax;
    eax = 0;
    rax = *(reloc.caml_local_roots);
    rdx = *(rax);
    *((rsp + 0x10)) = rdx;
    rdx = rsp + 0x10;
    *(rax) = rdx;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    rax = rsp + 8;
    *((rsp + 0x28)) = rax;
    rbx = rcx;
    rbx >>= 1;
    caml_enter_blocking_section ();
    edx = 0x4000;
    if (rbx > 0x4000) {
        rbx = rdx;
    }
    rdx = (int64_t) ebx;
    rsi = rsp + 0x50;
    rdi = rbp;
    rdi >>= 1;
    ecx = 0x4000;
    eax = read_chk ();
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx == 0xffffffff) {
        esi = 0;
        rdi = "read";
        uerror ();
    }
    rbx = (int64_t) ebx;
    r12 >>= 1;
    rdi += *((rsp + 8));
    memmove (r12, rsp + 0x50, rbx);
    rdx = *((rsp + 0x10));
    rax = *(reloc.caml_local_roots);
    *(rax) = rdx;
    rax = rbx + rbx + 1;
    rdx = *((rsp + 0x4058));
    rdx ^= *(fs:0x28);
    if (rdi != 0) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409bb0 */
#include <stdint.h>
 
int64_t caml_curry9_6 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry9_7);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41eec0 */
#include <stdint.h>
 
int64_t unix_inet_addr_of_string (int64_t arg1) {
    int64_t var_10h;
    int64_t canary;
    rdi = arg1;
    rax = *(fs:0x28);
    *((rsp + 0x28)) = rax;
    eax = 0;
    rbx = rdi;
    rdx = rsp;
    rsi = rdi;
    edi = 2;
    eax = inet_pton ();
    if (eax > 0) {
        rdi = rsp;
        alloc_inet_addr ();
    } else {
        rdx = rsp + 0x10;
        rsi = rbx;
        edi = 0xa;
        eax = inet_pton ();
        if (eax > 0) {
            rdi = rsp + 0x10;
            alloc_inet6_addr ();
        } else {
            rdi = "inet_addr_of_string";
            caml_failwith ();
        }
    }
    rdx = *((rsp + 0x28));
    rdx ^= *(fs:0x28);
    if (eax != 0) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409c00 */
#include <stdint.h>
 
int64_t caml_curry9_7 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry9_8);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409c50 */
#include <stdint.h>
 
int64_t caml_curry9_8 (void) {
    r10 = rax;
    rcx = *((rbx + 0x18));
    rdx = *((rcx + 0x18));
    rsi = *((rdx + 0x18));
    rax = *((rsi + 0x18));
    rdi = *((rax + 0x18));
    rbp = *((rdi + 0x18));
    r12 = *((rbp + 0x18));
    r11 = *((r12 + 0x18));
    r9 = *((rbx + 0x10));
    r8 = *((rcx + 0x10));
    rcx = *((rdx + 0x10));
    rdx = *((rsi + 0x10));
    rsi = *((rax + 0x10));
    rdi = *((rdi + 0x10));
    rbx = *((rbp + 0x10));
    rax = *((r12 + 0x10));
    rbp = *((r11 + 0x10));
    return void (*rbp)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x412420 */
#include <stdint.h>
 
int64_t camlArray_isortto_236 (int64_t arg6, int64_t arg5, int64_t arg3, signed int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    signed int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h_2;
    int64_t var_30h;
    int64_t var_38h;
    r9 = arg6;
    r8 = arg5;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rcx = 1;
    rsi += 0xfffffffffffffffe;
    if (rcx > rsi) {
        goto label_5;
    }
    *((rsp + 0x10)) = rsi;
    *((rsp + 8)) = rcx;
    *((rsp + 0x20)) = rdx;
    *((rsp + 0x18)) = rdi;
    *((rsp + 0x38)) = rbx;
    *(rsp) = rax;
label_0:
    rax = *(rsp);
    rdx = rax + rcx - 1;
    rax = *((rsp + 0x20));
    rsi = *((rax + 0x20));
    rax = *((rsi - 8));
    rdi = *((rsi - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= rdx) {
            goto label_6;
        }
        rax = *((rsi + rdx*4 - 4));
        *((rsp + 0x28)) = rax;
    } else {
        rax >>= 9;
        if (rax <= rdx) {
            goto label_7;
        }
label_4:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_8;
        }
        rax = r15 + 8;
        *((rax - 8)) = 0x4fd;
        __asm ("movlpd xmm0, qword [rsi + rdx*4 - 4]");
        __asm ("movlpd qword [rax], xmm0");
        *((rsp + 0x28)) = rax;
    }
label_3:
    r15 -= 0x10;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_9;
    }
    rbp = r15 + 8;
    *((rsp + 0x30)) = rbp;
    *((rbp - 8)) = 0x400;
    rax = *((rsp + 0x18));
    rax = rax + rcx - 3;
    *(rbp) = rax;
    do {
        rdi = *(rbp);
        rax = *((rsp + 0x18));
        if (rdi < rax) {
            goto label_10;
        }
        rsi = *(rbp);
        rax = *((rbx - 8));
        rdi = *((rbx - 8));
        rdi &= 0xff;
        if (rdi != 0xfe) {
            rax >>= 9;
            if (rax <= rsi) {
                goto label_11;
            }
            rax = *((rbx + rsi*4 - 4));
        } else {
            rax >>= 9;
            if (rax <= rsi) {
                goto label_12;
            }
label_2:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_13;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rbx + rsi*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
        }
        rbx = *((rsp + 0x20));
        rdi = *((rbx + 0x18));
        rbx = *((rsp + 0x28));
        rax = caml_apply2 ();
        if (rax <= 1) {
            goto label_10;
        }
        rbp = *((rsp + 0x30));
        rdx = *(rbp);
        rbx = *((rsp + 0x38));
        rax = *((rbx - 8));
        rdi = *((rbx - 8));
        rdi &= 0xff;
        if (rdi != 0xfe) {
            rax >>= 9;
            if (rax <= rdx) {
                goto label_14;
            }
            rsi = *((rbx + rdx*4 - 4));
        } else {
            rax >>= 9;
            if (rax <= rdx) {
                goto label_15;
            }
label_1:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_16;
            }
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rbx + rdx*4 - 4]");
            __asm ("movlpd qword [rsi], xmm0");
        }
        rdx = *(rbp);
        rdx += 2;
        rax = *((rbx - 8));
        rdi = *((rbx - 8));
        rdi &= 0xff;
        if (rdi != 0xfe) {
            rax >>= 9;
            if (rax <= rdx) {
                goto label_17;
            }
            rdi = rbx + rdx*4 - 4;
            rax = caml_modify ();
        } else {
            rax >>= 9;
            if (rax <= rdx) {
                goto label_18;
            }
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [rbx + rdx*4 - 4], xmm0");
        }
        *(rbp) += 0xfffffffffffffffe;
    } while (1);
label_10:
    rax = *((rsp + 0x30));
    rsi = *(rax);
    rsi += 2;
    rbx = *((rsp + 0x38));
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= rsi) {
            goto label_19;
        }
        rdi = rbx + rsi*4 - 4;
        rsi = *((rsp + 0x28));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= rsi) {
            goto label_20;
        }
        rax = *((rsp + 0x28));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + rsi*4 - 4], xmm0");
    }
    rcx = *((rsp + 8));
    rdi = *((rsp + 8));
    rcx += 2;
    *((rsp + 8)) = rcx;
    rax = *((rsp + 0x10));
    if (rdi != rax) {
        goto label_0;
    }
label_5:
    rax = 1;
    return rax;
label_16:
    caml_call_gc ();
    goto label_1;
label_13:
    caml_call_gc ();
    goto label_2;
label_9:
    caml_call_gc ();
    goto label_3;
label_8:
    caml_call_gc ();
    goto label_4;
label_20:
    caml_ml_array_bound_error ();
label_19:
    caml_ml_array_bound_error ();
label_18:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41c5c0 */
#include <stdint.h>
 
int64_t camlPrintf_fun_601 (int64_t arg_28h_2) {
    *((rsp + 8)) = rax;
    *(rsp) = rbx;
    rsi = 1;
    rdi = 3;
    *(rax) += al;
    *((rax - 0x75)) += cl;
    eax += 0x22346e;
    rax = caml_c_call ();
    rbx = rax;
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    *(rax) += al;
    if (*(rax) != 0) {
        rax >>= 9;
        if (rax <= 1) {
            goto label_0;
        }
        rdi = rbx;
        rsi = *((rsp + 8));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 1) {
            goto label_1;
        }
        rax = *((rsp + 8));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx], xmm0");
    }
    rax = *(rsp);
    rdi = *((rax + 0x10));
    rax = *((rax + 0x18));
    void (*0x40a5b0)() ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4229a3 */
#include <stdint.h>
 
uint64_t unix_tcsetattr (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_4h;
    int64_t var_8h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 8)) = rsi;
    rdi >>= 1;
    *((rsp + 4)) = edi;
    rsi = obj_terminal_status;
    eax = tcgetattr ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "tcsetattr";
        uerror ();
    }
    rax = terminal_io_descr;
    if (rax == 4) {
        goto label_1;
    }
    rbx = obj_terminal_io_descr;
    r13 = 0x00435e4c;
    r14d = 1;
    r15 = obj_speedtable;
    r12 = 0x0064dff0;
label_0:
    rbx += 8;
    if (rax != 1) {
        if (rax <= 1) {
            if (rax == 0) {
                goto label_2;
            }
            goto label_3;
        }
        if (rax == 2) {
            goto label_4;
        }
        if (rax != 3) {
            goto label_3;
        }
        goto label_5;
label_2:
        rax = *(rbx);
        ecx = *((rbx + 8));
        rbx += 0x10;
        rdx = *(rbp);
        rdx >>= 1;
        if (edx != 0) {
            *(rax) |= ecx;
            goto label_3;
        }
        ecx = ~ecx;
        *(rax) &= ecx;
        goto label_3;
    }
    rdx = *(rbx);
    esi = *((rbx + 0x10));
    rax = rbx + 0x18;
    rdi = *(rax);
    rcx = *(rbp);
    rcx >>= 1;
    ecx -= *((rbx + 8));
    if (ecx >= 0) {
        if (esi <= ecx) {
            goto label_6;
        }
        rax += 8;
        rbx = (int64_t) ecx;
        edi = ~edi;
        ecx = edi;
        ecx &= *(rdx);
        ecx |= *((rax + rbx*8));
        *(rdx) = ecx;
        rsi = (int64_t) esi;
        rbx = rax + rsi*8;
        goto label_3;
    }
label_6:
    edx = 0;
    rsi = "tcsetattr";
    edi = 0x16;
    unix_error ();
label_4:
    rsi = *(rbx);
    rcx = *(rbp);
    rcx >>= 1;
    rax = r13;
    edx = r14d;
    if (ecx != *(0x00435e44)) {
        goto label_7;
    }
    edx = 0;
    while (edx != 0x12) {
label_7:
        if (ecx == *(rax)) {
            if (esi != 0) {
                eax = 0;
                if (esi != 1) {
                    goto label_8;
                }
                rdx = (int64_t) edx;
                esi = *((r15 + rdx*8));
                rdi = obj_terminal_status;
                cfsetospeed ();
            } else {
                rdx = (int64_t) edx;
                esi = *((r15 + rdx*8));
                rdi = obj_terminal_status;
                eax = cfsetispeed ();
            }
label_8:
            if (eax != 0xffffffff) {
                rbx += 8;
                goto label_3;
            }
            esi = 0;
            rdi = "tcsetattr";
            rax = uerror ();
        }
        edx++;
        rax += 8;
    }
    edx = 0;
    rsi = "tcsetattr";
    edi = 0x16;
    unix_error ();
label_5:
    eax = *(rbx);
    rbx += 8;
    rax = (int64_t) eax;
    rdx = *(rbp);
    rdx >>= 1;
    *((r12 + rax + 1)) = dl;
label_3:
    rax = *(rbx);
    if (rax != 4) {
        rbp += 8;
        goto label_0;
    }
label_1:
    rdx = *((rsp + 8));
    rdx >>= 1;
    rdx = (int64_t) edx;
    rax = obj_when_flag_table;
    esi = *((rax + rdx*4));
    rdx = obj_terminal_status;
    edi = *((rsp + 4));
    eax = tcsetattr ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "tcsetattr";
        uerror ();
    }
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ae20 */
#include <stdint.h>
 
int64_t camlPrintf_fun_594 (int64_t arg1) {
    rdi = arg1;
    rdx = *((rdi + 0x18));
    rdx -= rax;
    rdx -= 3;
    rdx += 2;
    rsi = *((rdi + 0x20));
    rax = *((rsi - 8));
    rdi = *((rsi - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= rdx) {
            goto label_0;
        }
        rdi = rsi + rdx*4 - 4;
        rsi = rbx;
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= rdx) {
            goto label_1;
        }
        __asm ("movlpd xmm0, qword [rbx]");
        __asm ("movlpd qword [rsi + rdx*4 - 4], xmm0");
    }
    rax = 1;
    return rax;
label_1:
    caml_ml_array_bound_error ();
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f2c0 */
#include <stdint.h>
 
uint64_t unix_execvpe (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x28)) = rbx;
    *((rsp - 0x20)) = rbp;
    *((rsp - 0x18)) = r12;
    *((rsp - 0x10)) = r13;
    *((rsp - 8)) = r14;
    r12 = rdi;
    r14 = rdx;
    rdi = rsi;
    eax = 0;
    rax = cstringvect ();
    rbx = *(reloc.environ);
    r13 = *(rbx);
    rdi = r14;
    eax = 0;
    rax = cstringvect ();
    *(rbx) = rax;
    rsi = rbp;
    rdi = r12;
    execvp ();
    rdi = rbp;
    caml_stat_free ();
    rdi = *(rbx);
    caml_stat_free ();
    *(rbx) = r13;
    rsi = r12;
    rdi = "execvp";
    return uerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421d6c */
#include <stdint.h>
 
int32_t unix_sleep (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    caml_enter_blocking_section ();
    rbx >>= 1;
    sleep (ebx);
    caml_leave_blocking_section ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409200 */
#include <stdint.h>
 
void sleep (void) {
    sleep ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41c4c0 */
#include <stdint.h>
 
int64_t camlPrintf_fun_604 (int64_t arg1) {
    int64_t var_8h_2;
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    *((rsp + 0x10)) = rax;
    *((rsp + 8)) = rbx;
    *(rsp) = rdi;
    rsi = 1;
    rdi = 5;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = rax;
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 1) {
            goto label_0;
        }
        rdi = rbx;
        rsi = *((rsp + 0x10));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 1) {
            goto label_1;
        }
        rax = *((rsp + 0x10));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 3) {
            goto label_2;
        }
        rdi = rbx;
        rdi += 8;
        rsi = *((rsp + 8));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 3) {
            goto label_3;
        }
        rax = *((rsp + 8));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 8], xmm0");
    }
    rax = *(rsp);
    rdi = *((rax + 0x18));
    rax = *((rax + 0x20));
    void (*0x40a5b0)() ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b490 */
#include <stdint.h>
 
int64_t camlPrintf_fill_format_124 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
label_0:
        rsi = *((rdi + 0x20));
        if (rax > rsi) {
            goto label_1;
        }
        rdx = rax;
        rdx >>= 1;
        rsi = *((rdi + 0x18));
        rsi = *((rsi + rdx));
        rsi = rsi + rsi + 1;
        if (rsi == 0x55) {
            goto label_2;
        }
        *((rsp + 0x10)) = rdi;
        *(rsp) = rbx;
        *((rsp + 8)) = rax;
        rbx = rsi;
        rax = *((rdi + 0x30));
        camlBuffer_add_char_100 ();
        rax = *((rsp + 8));
        rax += 2;
        rbx = *(rsp);
        rdi = *((rsp + 0x10));
    } while (1);
label_2:
    if (rbx == 1) {
        goto label_3;
    }
    *((rsp + 0x10)) = rdi;
    *((rsp + 8)) = rax;
    rax = *((rbx + 8));
    *(rsp) = rax;
    rax = *(rbx);
    rax = camlPervasives_string_of_int_154 ();
    rbx = rax;
    rax = *((rsp + 0x10));
    rax = *((rax + 0x30));
    camlBuffer_add_string_110 ();
    rax = *((rsp + 0x10));
    rbx = *((rax + 0x28));
    rax = *((rsp + 8));
    rax += 2;
    camlPrintf_skip_positional_spec_118 ();
    rbx = *(rsp);
    rdi = *((rsp + 0x10));
    goto label_0;
    do {
label_3:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            rax = *(reloc.caml_exn_Assert_failure);
            *(rbx) = rax;
            rax = *(loc.camlPrintf__67);
            *((rbx + 8)) = rax;
            rax = rbx;
            rax = caml_raise_exn ();
label_1:
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41aea0 */
#include <stdint.h>
 
int64_t camlPrintf_fun_597 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    rsi = rbx;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            *(rbx) = rdi;
            rax = *((rsi + 0x20));
            *((rbx + 8)) = rax;
            rdi = *((rsi + 0x10));
            rax = *((rsi + 0x18));
            rax += 2;
            void (*0x41bc00)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42bc80 */
#include <stdint.h>
 
int64_t caml_ml_input_scan_line (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    rdi = arg1;
    *((rsp - 0x10)) = rbp;
    *((rsp - 0x18)) = rbx;
    *((rsp - 8)) = r12;
    rax = caml_channel_mutex_lock;
    rdx = rsp + 0x10;
    rbp = caml_local_roots;
    *((rsp + 8)) = rdi;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x10)) = rbp;
    rbx = *((rdi + 8));
    *((rsp + 0x28)) = rdx;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rdi = rbx;
    rax = caml_input_scan_line ();
    rdx = caml_channel_mutex_unlock;
    r12 = rax;
    if (rdx != 0) {
        rdi = rbx;
        void (*rdx)() ();
    }
    *(obj.caml_local_roots) = rbp;
    rax = r12 + r12 + 1;
    rbx = *((rsp + 0x50));
    rbp = *((rsp + 0x58));
    r12 = *((rsp + 0x60));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c870 */
#include <stdint.h>
 
int64_t caml_ml_seek_out (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    rsi = arg2;
    rdi = arg1;
    rax = caml_channel_mutex_lock;
    rbp = caml_local_roots;
    rdx = rsp + 0x10;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 2;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x10)) = rbp;
    *((rsp + 0x30)) = rsp;
    *((rsp + 0x28)) = rdx;
    rbx = *((rdi + 8));
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rsi = *(rsp);
    rdi = rbx;
    rsi >>= 1;
    caml_seek_out ();
    rax = caml_channel_mutex_unlock;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    *(obj.caml_local_roots) = rbp;
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41c360 */
#include <stdint.h>
 
int64_t camlPrintf_fun_607 (int64_t arg2, int64_t arg1) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x18)) = rax;
    *((rsp + 0x10)) = rbx;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    rsi = 1;
    rdi = 7;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = rax;
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 1) {
            goto label_0;
        }
        rdi = rbx;
        rsi = *((rsp + 0x18));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 1) {
            goto label_1;
        }
        rax = *((rsp + 0x18));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 3) {
            goto label_2;
        }
        rdi = rbx;
        rdi += 8;
        rsi = *((rsp + 0x10));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 3) {
            goto label_3;
        }
        rax = *((rsp + 0x10));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 8], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 5) {
            goto label_4;
        }
        rdi = rbx;
        rdi += 0x10;
        rsi = *((rsp + 8));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 5) {
            goto label_5;
        }
        rax = *((rsp + 8));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 0x10], xmm0");
    }
    rax = *(rsp);
    rdi = *((rax + 0x18));
    rax = *((rax + 0x20));
    void (*0x40a5b0)() ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b4f0 */
#include <stdint.h>
 
uint64_t caml_ml_close_channel (int64_t arg1) {
    rdi = arg1;
    rbx = *((rdi + 8));
    edi = *(rbx);
    if (edi != 0xffffffff) {
        eax = close (rdi);
        rdx = *((rbx + 0x10));
        *(rbx) = 0xffffffff;
        *((rbx + 0x20)) = rdx;
        *((rbx + 0x18)) = rdx;
        if (eax == 0xffffffff) {
            goto label_0;
        }
        eax = 1;
        return eax;
    }
    rax = *((rbx + 0x10));
    *((rbx + 0x20)) = rax;
    *((rbx + 0x18)) = rax;
    eax = 1;
    return rax;
label_0:
    edi = 1;
    return caml_sys_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b1a0 */
#include <stdint.h>
 
int64_t camlPrintf_cont_s_393 (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 8)) = rax;
    *((rsp + 0x10)) = rdi;
    *(rsp) = rsi;
    rdi = *((rsi + 0xa8));
    rax = *((rsi + 0xb8));
    caml_apply2 ();
    rdi = *(rsp);
    rdi += 0xffffffffffffffe0;
    rax = *((rsp + 8));
    rbx = *((rsp + 0x10));
    return camlPrintf_doprn_392 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420664 */
#include <stdint.h>
 
int64_t unix_getsockname (int64_t sockfd) {
    socklen_t * addrlen;
    struct sockaddr * addr;
    int64_t canary;
    rdi = sockfd;
    rax = *(fs:0x28);
    *((rsp + 0x88)) = rax;
    eax = 0;
    *((rsp + 0xc)) = 0x70;
    rdi >>= 1;
    eax = getsockname (rdi, rsp + 0x10, rsp + 0xc);
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = 0x00435b58;
        uerror ();
    }
    rdi = rsp + 0x10;
    edx = 0xffffffff;
    esi = *((rsp + 0xc));
    alloc_sockaddr ();
    rdx = *((rsp + 0x88));
    rdx ^= *(fs:0x28);
    if (eax != 0xffffffff) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b400 */
#include <stdint.h>
 
int64_t camlPrintf_skip_positional_spec_118 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
    rsi = rax;
    rsi >>= 1;
    rdi = *((rbx + 0x10));
    rdi = *((rdi + rsi));
    rdi = rdi + rdi + 1;
    rdi += 0xffffffffffffffa0;
    if (rdi <= 0x13) {
        goto label_0;
    }
    rax = rdx;
    return rax;
    do {
label_0:
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x10f7;
            rdi = *(reloc.camlPrintf__skip_int_literal_120);
            *(rsi) = rdi;
            *((rsi + 8)) = 3;
            rdi = *((rbx + 0x10));
            *((rsi + 0x10)) = rdi;
            *((rsi + 0x18)) = rdx;
            rax = rdx;
            rax += 2;
            rbx = rsi;
            void (*0x41abf0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c9e0 */
#include <stdint.h>
 
uint64_t caml_ml_open_descriptor_out (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    rax = caml_open_descriptor_out ();
    rdi = rax;
    return caml_alloc_channel ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c9c0 */
#include <stdint.h>
 
void caml_open_descriptor_out (int64_t arg1) {
    rdi = arg1;
    caml_open_descriptor_in ();
    *((rax + 0x20)) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c900 */
#include <stdint.h>
 
uint64_t caml_open_descriptor_in (int64_t arg1) {
    rdi = arg1;
    edi = 0x1050;
    rax = caml_stat_alloc ();
    esi = 0;
    rbx = rax;
    *(rax) = ebp;
    edx = 1;
    edi = ebp;
    rax = lseek64 ();
    *((rbx + 8)) = rax;
    rax = rbx + 0x50;
    *((rbx + 0x28)) = 0;
    *((rbx + 0x40)) = 0;
    *((rbx + 0x44)) = 0;
    *((rbx + 0x20)) = rax;
    *((rbx + 0x18)) = rax;
    rax = rbx + 0x1050;
    *((rbx + 0x48)) = 0;
    *((rbx + 0x4c)) = 0;
    *((rbx + 0x10)) = rax;
    rax = caml_all_opened_channels;
    *((rbx + 0x38)) = 0;
    *((rbx + 0x30)) = rax;
    if (rax != 0) {
        *((rax + 0x38)) = rbx;
    }
    *(obj.caml_all_opened_channels) = rbx;
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420d20 */
#include <stdint.h>
 
uint64_t unix_lseek (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rdx >>= 1;
    rdx = (int64_t) edx;
    rax = obj_seek_command_table;
    edx = *((rax + rdx*4));
    rsi >>= 1;
    rdi >>= 1;
    rax = lseek64 ();
    if (rax == -1) {
        esi = 0;
        rdi = "lseek";
        rax = uerror ();
    }
    rdx = 0x3fffffffffffffff;
    if (rax > rdx) {
        edx = 0;
        rsi = "lseek";
        edi = 0x4b;
        unix_error ();
    }
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b4b0 */
#include <stdint.h>
 
int64_t caml_channel_descriptor (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    ebx = *(rax);
    if (ebx != 0xffffffff) {
        rbx = (int64_t) ebx;
        rax = rbx + rbx + 1;
        return rax;
    }
    errno_location ();
    rbx = (int64_t) ebx;
    *(rax) = 9;
    edi = 1;
    return caml_sys_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42aa10 */
#include <stdint.h>
 
uint64_t caml_is_printable (int64_t arg1) {
    rdi = arg1;
    eax = locale_is_set.3458;
    rbx = rdi;
    while (1) {
        rax = ctype_b_loc ();
        rax = *(rax);
        rbx >>= 1;
        rbx = (int64_t) ebx;
        eax = *((rax + rbx*2));
        eax &= 0x4000;
        rax -= rax;
        rax &= 0xfffffffffffffffe;
        rax += 3;
        return rax;
        setlocale (0, 0x436cc1);
        *(obj.locale_is_set.3458) = 1;
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fc34 */
#include <stdint.h>
 
uint64_t unix_getgrgid (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    rax = getgrgid ();
    if (rax == 0) {
        rax = caml_raise_not_found ();
    }
    rdi = rax;
    alloc_group_entry ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4094c0 */
#include <stdint.h>
 
void getgrgid (void) {
    getgrgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fb60 */
#include <stdint.h>
 
int64_t alloc_group_entry (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    rdi = arg1;
    rbx = rdi;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x50)) = 1;
    *((rsp + 0x48)) = 1;
    rbp = *(reloc.caml_local_roots);
    rax = *(rbp);
    *(rsp) = rax;
    *(rbp) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 3;
    rax = rsp + 0x58;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x20)) = rax;
    rax = rsp + 0x48;
    *((rsp + 0x28)) = rax;
    rdi = *(rdi);
    rax = caml_copy_string ();
    *((rsp + 0x58)) = rax;
    rdi = *((rbx + 8));
    rax = caml_copy_string ();
    *((rsp + 0x50)) = rax;
    rdi = *((rbx + 0x18));
    rax = caml_copy_string_array ();
    *((rsp + 0x48)) = rax;
    esi = 0;
    edi = 4;
    caml_alloc_small ();
    rdx = *((rsp + 0x58));
    *(rax) = rdx;
    rdx = *((rsp + 0x50));
    *((rax + 8)) = rdx;
    edx = *((rbx + 0x10));
    rdx = rdx + rdx + 1;
    *((rax + 0x10)) = rdx;
    rdx = *((rsp + 0x48));
    *((rax + 0x18)) = rdx;
    rdx = *(rsp);
    *(rbp) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x411da0 */
#include <stdint.h>
 
uint64_t camlArray_trickle_192 (int64_t arg2, int64_t arg1) {
    int64_t var_8h_3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    rax = void (*0x411e34)() ();
    rbx = *(reloc.camlArray);
    rdi = *((rbx + 0xb0));
    rbx = *(rax);
    if (rbx == rdi) {
        rsi = *((rax + 8));
        rax = *(rsp);
        rdi = *((rax + 0x18));
        rax = *((rdi - 8));
        rbx = *((rdi - 8));
        rbx &= 0xff;
        if (rbx != 0xfe) {
            rax >>= 9;
            if (rax <= rsi) {
                goto label_0;
            }
            rdi = rdi + rsi*4 - 4;
            rsi = *((rsp + 8));
            rax = caml_modify ();
        } else {
            rax >>= 9;
            if (rax <= rsi) {
                goto label_1;
            }
            rax = *((rsp + 8));
            __asm ("movlpd xmm0, qword [rax]");
            __asm ("movlpd qword [rdi + rsi*4 - 4], xmm0");
        }
        rax = 1;
        return rax;
    }
    rax = caml_raise_exn ();
    r14 = rsp;
    rsi = *((rsi + 0x20));
    camlArray_trickledown_187 ();
    return rax;
label_1:
    caml_ml_array_bound_error ();
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428b30 */
#include <stdint.h>
 
uint64_t caml_lessequal (void) {
    edx = 0;
    rax = compare_val ();
    rbx = rax;
    if (*(obj.compare_stack) != 0x652500) {
        compare_free_stack ();
    }
    rax = 0x8000000000000000;
    al = (rbx != rax) ? 1 : 0;
    dl = (rbx <= 0) ? 1 : 0;
    rax &= rdx;
    eax &= 1;
    rax += rax;
    rax++;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x411fb0 */
#include <stdint.h>
 
int64_t camlArray_trickleup_205 (int64_t arg6, int64_t arg5, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_20h;
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        rsi = rax;
        rcx = 3;
        rax = rsi;
        rax += 0xfffffffffffffffe;
        rax >>= 1;
        __asm ("cqo");
        rax = rdx:rax / rcx;
        rdx = rdx:rax % rcx;
        rcx = rax + rax + 1;
        if (rsi != rcx) {
            *((rsp + 0x18)) = rcx;
            *(rsp) = rdi;
            *((rsp + 8)) = rbx;
            *((rsp + 0x10)) = rsi;
        } else {
label_2:
            r15 -= 0x18;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_3;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *(reloc.caml_exn_Assert_failure);
            *(rax) = rbx;
            rbx = *(loc.camlArray__34);
            *((rax + 8)) = rbx;
            caml_raise_exn ();
        }
        rdx = *((rdi + 0x20));
        rax = *((rdx - 8));
        rsi = *((rdx - 8));
        rsi &= 0xff;
        if (rsi != 0xfe) {
            rax >>= 9;
            if (rax <= rcx) {
                goto label_4;
            }
            rax = *((rdx + rcx*4 - 4));
        } else {
            rax >>= 9;
            if (rax <= rcx) {
                goto label_5;
            }
label_1:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_6;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdx + rcx*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
        }
        rdi = *((rdi + 0x18));
        rax = caml_apply2 ();
        if (rax >= 1) {
            goto label_7;
        }
        rbp = *(rsp);
        rdi = *((rbp + 0x20));
        rax = *((rdi - 8));
        rbx = *((rdi - 8));
        rbx &= 0xff;
        if (rbx != 0xfe) {
            rax >>= 9;
            rbx = *((rsp + 0x18));
            if (rax <= rbx) {
                goto label_8;
            }
            rsi = *((rdi + rbx*4 - 4));
        } else {
            rax >>= 9;
            rbx = *((rsp + 0x18));
            if (rax <= rbx) {
                goto label_9;
            }
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_10;
            }
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdi + rbx*4 - 4]");
            __asm ("movlpd qword [rsi], xmm0");
        }
        rdx = *((rbp + 0x20));
        rdi = *((rdx - 8));
        rax = *((rdx - 8));
        rax &= 0xff;
        if (rax != 0xfe) {
            rdi >>= 9;
            rax = *((rsp + 0x10));
            if (rdi <= rax) {
                goto label_11;
            }
            rdi = rdx + rax*4 - 4;
            caml_modify ();
        } else {
            rdi >>= 9;
            rax = *((rsp + 0x10));
            if (rdi <= rax) {
                goto label_12;
            }
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [rdx + rax*4 - 4], xmm0");
        }
        if (rbx <= 1) {
            goto label_13;
        }
        rax = rbx;
        rbx = *((rsp + 8));
        rdi = rbp;
    } while (1);
label_13:
    rdi = *((rbp + 0x20));
    rbx = *((rdi - 8));
    rax = *((rdi - 8));
    rax &= 0xff;
    if (rax != 0xfe) {
        rax = rbx;
        rax >>= 9;
        if (rax <= 1) {
            goto label_14;
        }
        rsi = *((rsp + 8));
        caml_modify ();
    } else {
        rax = rbx;
        rax >>= 9;
        if (rax <= 1) {
            goto label_15;
        }
        rax = *((rsp + 8));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rdi], xmm0");
    }
    rax = 1;
    return rax;
label_7:
    rax = *(rsp);
    rsi = *((rax + 0x20));
    rdi = *((rsi - 8));
    rax = *((rsi - 8));
    rax &= 0xff;
    if (rax != 0xfe) {
        rdi >>= 9;
        rax = *((rsp + 0x10));
        if (rdi <= rax) {
            goto label_16;
        }
        rdi = rsi + rax*4 - 4;
        rsi = *((rsp + 8));
        caml_modify ();
    } else {
        rdi >>= 9;
        rbx = *((rsp + 0x10));
        if (rdi <= rbx) {
            goto label_17;
        }
        rax = *((rsp + 8));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rsi + rbx*4 - 4], xmm0");
    }
    rax = 1;
    return rax;
label_10:
    caml_call_gc ();
    goto label_0;
label_6:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
label_17:
    caml_ml_array_bound_error ();
label_16:
    caml_ml_array_bound_error ();
label_15:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_12:
    caml_ml_array_bound_error ();
label_11:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4204f0 */
#include <stdint.h>
 
uint32_t unix_gettimeofday (void) {
    rdi = rsp;
    esi = 0;
    eax = gettimeofday ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "gettimeofday";
        uerror ();
    }
    __asm ("cvtsi2sd xmm1, qword [rsp]");
    __asm ("cvtsi2sd xmm0, qword [rsp + 8]");
    __asm ("divsd xmm0, qword [0x00435b50]");
    __asm ("addsd xmm0, xmm1");
    caml_copy_double ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408f30 */
#include <stdint.h>
 
void gettimeofday (void) {
    gettimeofday ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fc57 */
#include <stdint.h>
 
uint64_t unix_getgrnam (void) {
    rax = getgrnam ();
    if (rax == 0) {
        rax = caml_raise_not_found ();
    }
    rdi = rax;
    alloc_group_entry ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408dd0 */
#include <stdint.h>
 
void getgrnam (void) {
    getgrnam ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f054 */
#include <stdint.h>
 
uint32_t unix_chroot (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    eax = chroot ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "chroot";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4094f0 */
#include <stdint.h>
 
void chroot (void) {
    chroot ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417d00 */
#include <stdint.h>
 
int64_t camlHashtbl_find_in_bucket_241 (void) {
    int64_t var_8h_4;
    int64_t var_10h_4;
    do {
label_0:
        if (rax == 1) {
            goto label_1;
        }
        *((rsp + 8)) = rbx;
        rdi = *((rax + 0x10));
        *(rsp) = rdi;
        rdi = *((rax + 8));
        *((rsp + 0x10)) = rdi;
        rax = *(rax);
        rdi = *((rbx + 0x10));
        rdi = *(rdi);
        rbx = *((rbx + 0x18));
        rax = caml_apply2 ();
        if (rax == 1) {
            goto label_2;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
        rax = camlHashtbl_find_in_bucket_241 ();
    } while (1);
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *((rsp + 0x10));
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            return rax;
label_2:
            rax = *(rsp);
            rbx = *((rsp + 8));
            goto label_0;
label_1:
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4204ac */
#include <stdint.h>
 
uint64_t unix_getpwuid (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    rax = getpwuid ();
    if (rax == 0) {
        rax = caml_raise_not_found ();
    }
    rdi = rax;
    alloc_passwd_entry ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409060 */
#include <stdint.h>
 
void getpwuid (void) {
    getpwuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420378 */
#include <stdint.h>
 
int64_t alloc_passwd_entry (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    rdi = arg1;
    rbx = rdi;
    *((rsp + 0x68)) = 1;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x50)) = 1;
    *((rsp + 0x48)) = 1;
    rbp = *(reloc.caml_local_roots);
    rax = *(rbp);
    *(rsp) = rax;
    *(rbp) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 5;
    rax = rsp + 0x68;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x60;
    *((rsp + 0x20)) = rax;
    rax = rsp + 0x58;
    *((rsp + 0x28)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x30)) = rax;
    rax = rsp + 0x48;
    *((rsp + 0x38)) = rax;
    rdi = *(rdi);
    rax = caml_copy_string ();
    *((rsp + 0x68)) = rax;
    rdi = *((rbx + 8));
    rax = caml_copy_string ();
    *((rsp + 0x60)) = rax;
    rdi = *((rbx + 0x18));
    rax = caml_copy_string ();
    *((rsp + 0x58)) = rax;
    rdi = *((rbx + 0x20));
    rax = caml_copy_string ();
    *((rsp + 0x50)) = rax;
    rdi = *((rbx + 0x28));
    rax = caml_copy_string ();
    *((rsp + 0x48)) = rax;
    esi = 0;
    edi = 7;
    caml_alloc_small ();
    rdx = *((rsp + 0x68));
    *(rax) = rdx;
    rdx = *((rsp + 0x60));
    *((rax + 8)) = rdx;
    edx = *((rbx + 0x10));
    rdx = rdx + rdx + 1;
    *((rax + 0x10)) = rdx;
    edx = *((rbx + 0x14));
    rdx = rdx + rdx + 1;
    *((rax + 0x18)) = rdx;
    rdx = *((rsp + 0x58));
    *((rax + 0x20)) = rdx;
    rdx = *((rsp + 0x50));
    *((rax + 0x28)) = rdx;
    rdx = *((rsp + 0x48));
    *((rax + 0x30)) = rdx;
    rdx = *(rsp);
    *(rbp) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4215c8 */
#include <stdint.h>
 
int64_t unix_sendto_native (int64_t arg_ch, int64_t arg_1ch, int64_t arg_20h, int64_t arg_4020h, int64_t canary, int64_t arg_40a8h, int64_t arg_40b0h, int64_t arg_40b8h, int64_t arg_40c0h, int64_t arg_40c8h, int64_t arg_40d0h, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x30)) = rbx;
    *((rsp - 0x28)) = rbp;
    *((rsp - 0x20)) = r12;
    *((rsp - 0x18)) = r13;
    *((rsp - 0x10)) = r14;
    *((rsp - 8)) = r15;
    r15 = rdi;
    r14 = rsi;
    r13 = rdx;
    r12 = rcx;
    rbx = r9;
    rax = *(fs:0x28);
    *((rsp + 0x4098)) = rax;
    eax = 0;
    rsi = obj_msg_flag_table;
    rdi = r8;
    eax = caml_convert_flag_list ();
    *((rsp + 0xc)) = eax;
    rdx = rsp + 0x1c;
    rbp = rsp + 0x4020;
    rsi = rbp;
    rdi = rbx;
    get_sockaddr ();
    r12 >>= 1;
    ebx = 0x4000;
    if (r12 <= 0x4000) {
        rbx = r12;
    }
    r13 >>= 1;
    rsi = r13 + r14;
    r12 = rsp + 0x20;
    ecx = 0x4000;
    rdx = rbx;
    rdi = r12;
    memmove_chk ();
    caml_enter_blocking_section ();
    rdx = (int64_t) ebx;
    rdi = r15;
    rdi >>= 1;
    r9d = *((rsp + 0x1c));
    r8 = rbp;
    ecx = *((rsp + 0xc));
    rsi = r12;
    eax = sendto ();
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx == 0xffffffff) {
        esi = 0;
        rdi = "sendto";
        uerror ();
    }
    rbx = (int64_t) ebx;
    rax = rbx + rbx + 1;
    rdx = *((rsp + 0x4098));
    rdx ^= *(fs:0x28);
    if (ebx != 0xffffffff) {
        stack_chk_fail ();
    }
    rbx = *((rsp + 0x40a8));
    rbp = *((rsp + 0x40b0));
    r12 = *((rsp + 0x40b8));
    r13 = *((rsp + 0x40c0));
    r14 = *((rsp + 0x40c8));
    r15 = *((rsp + 0x40d0));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423387 */
#include <stdint.h>
 
int64_t unix_write (int64_t arg_30h, int64_t arg_38h, int64_t arg_60h, int64_t canary, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x18)) = rsi;
    rax = *(fs:0x28);
    *((rsp + 0x4068)) = rax;
    eax = 0;
    rax = *(reloc.caml_local_roots);
    rbx = *(rax);
    *((rsp + 0x20)) = rbx;
    rbx = rsp + 0x20;
    *(rax) = rbx;
    *((rsp + 0x30)) = 1;
    *((rsp + 0x28)) = 1;
    rax = rsp + 0x18;
    *((rsp + 0x38)) = rax;
    rbx = rcx;
    rbx >>= 1;
    if (rbx <= 0) {
        goto label_0;
    }
    r12 = rdx;
    r12 >>= 1;
    rdi >>= 1;
    *(rsp) = edi;
    r13d = 0;
    r14d = 0x4000;
    r15 = rsp + 0x60;
    do {
        if (rbx <= 0x4000) {
        }
        rbp = (int64_t) ebp;
        rsi = r12;
        rsi += *((rsp + 0x18));
        rcx = r14;
        rdx = rbp;
        rdi = r15;
        memmove_chk ();
        caml_enter_blocking_section ();
        eax = write (*(rsp), r15, rbp);
        caml_leave_blocking_section ();
        if (ebp == 0xffffffff) {
            rax = errno_location ();
            if (*(rax) == 0xb) {
                if (r13 > 0) {
                    goto label_1;
                }
            }
            esi = 0;
            rdi = 0x00435f42;
            uerror ();
        }
        rbp = (int64_t) ebp;
        r13 += rbp;
        rbx -= rbp;
        if (rbx <= 0) {
            goto label_1;
        }
        r12 += rbp;
    } while (1);
label_0:
    r13d = 0;
label_1:
    rdx = *((rsp + 0x20));
    rax = *(reloc.caml_local_roots);
    *(rax) = rdx;
    rax = r13 + r13 + 1;
    rdx = *((rsp + 0x4068));
    rdx ^= *(fs:0x28);
    if (r12 != 0) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b5a0 */
#include <stdint.h>
 
int64_t camlPrintf_sub_fmt_152 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rax == 0x51) {
        rdx = 0x53;
    } else {
        rdx = 0xfb;
    }
    do {
        r15 -= 0x68;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x30f7;
            rax = *(reloc.camlPrintf__sub_156);
            *(rsi) = rax;
            *((rsi + 8)) = 3;
            *((rsi + 0x10)) = 0xcf9;
            rax = *(reloc.camlPrintf__sub_sub_157);
            *((rsi + 0x18)) = rax;
            *((rsi + 0x20)) = 3;
            rax = *((rdi + 0x18));
            *((rsi + 0x28)) = rax;
            rax = *((rdi + 0x20));
            *((rsi + 0x30)) = rax;
            rax = *((rdi + 0x28));
            *((rsi + 0x38)) = rax;
            rax = *((rdi + 0x30));
            *((rsi + 0x40)) = rax;
            *((rsi + 0x48)) = rdi;
            *((rsi + 0x50)) = rbx;
            *((rsi + 0x58)) = rdx;
            rax = rbx;
            rbx = rsi;
            void (*0x41ad40)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420f28 */
#include <stdint.h>
 
uint64_t unix_opendir (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rax = opendir ();
    rbx = rax;
    if (rax == 0) {
        rsi = rbp;
        rdi = "opendir";
        uerror ();
    }
    esi = 0xfb;
    edi = 1;
    caml_alloc_small ();
    *(rax) = rbx;
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409120 */
#include <stdint.h>
 
void opendir (void) {
    opendir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420356 */
#include <stdint.h>
 
uint64_t unix_getprotobyname (void) {
    rax = getprotobyname ();
    if (rax == 0) {
        rax = caml_raise_not_found ();
    }
    rdi = rax;
    alloc_proto_entry ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409160 */
#include <stdint.h>
 
void getprotobyname (void) {
    getprotobyname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40f780 */
#include <stdint.h>
 
int64_t camlPervasives_scan_273 (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdi = arg1;
    do {
        *((rsp + 0x20)) = rax;
        *((rsp + 0x18)) = rbx;
        *((rsp + 8)) = rdi;
        rdi = *((rdi + 0x18));
        rax = *(reloc.caml_ml_input_scan_line);
        rax = caml_c_call ();
        if (rax == 1) {
            rax = *((rsp + 0x20));
            if (rax != 1) {
                *((rsp + 0x20)) = rax;
                rdi = *((rsp + 0x18));
                rax = *(reloc.caml_create_string);
                caml_c_call ();
                rbx = *((rsp + 0x18));
                rdi = *((rsp + 0x20));
                void (*0x40f710)() ();
            }
label_2:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_3;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_End_of_file);
            *(rax) = rbx;
            rax = caml_raise_exn ();
        }
        *((rsp + 0x10)) = rax;
        if (rax > 1) {
            rax += 0xfffffffffffffffe;
            rdi = rax;
            rax = *(reloc.caml_create_string);
            rax = caml_c_call ();
            *(rsp) = rax;
            rcx = *((rsp + 0x10));
            rcx += 0xfffffffffffffffe;
            rdx = 1;
            rbx = *((rsp + 8));
            rdi = *((rbx + 0x18));
            rsi = rax;
            rax = *(reloc.caml_ml_input);
            caml_c_call ();
            rax = *((rsp + 8));
            rdi = *((rax + 0x18));
            rax = *(reloc.caml_ml_input_char);
            caml_c_call ();
            rdi = *((rsp + 0x20));
            if (rdi != 1) {
                rbx = *((rsp + 0x10));
                rax = *((rsp + 0x18));
                rsi = rax + rbx - 3;
                *((rsp + 8)) = rsi;
label_1:
                r15 -= 0x18;
                rax = *(reloc.caml_young_limit);
                if (r15 < *(rax)) {
                    goto label_4;
                }
                rbx = r15 + 8;
                *((rsp + 0x10)) = rbx;
                *((rbx - 8)) = 0x800;
                rax = *(rsp);
                *(rbx) = rax;
                *((rbx + 8)) = rdi;
                rdi = rsi;
                rax = *(reloc.caml_create_string);
                caml_c_call ();
                rbx = *((rsp + 8));
                rdi = *((rsp + 0x10));
                void (*0x40f710)() ();
            }
            rax = *(rsp);
            return rax;
        }
        rdi = 2;
        rdi -= rax;
        rax = *(reloc.caml_create_string);
        rax = caml_c_call ();
        *(rsp) = rax;
        rcx = 2;
        rbx = *((rsp + 0x10));
        rcx -= rbx;
        rdx = 1;
        rbx = *((rsp + 8));
        rdi = *((rbx + 0x18));
        rsi = rax;
        rax = *(reloc.caml_ml_input);
        caml_c_call ();
label_0:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_5;
        }
        rax = r15 + 8;
        *((rax - 8)) = 0x800;
        rbx = *(rsp);
        *(rax) = rbx;
        rbx = *((rsp + 0x20));
        *((rax + 8)) = rbx;
        rbx = *((rsp + 0x18));
        rdi = *((rsp + 0x10));
        rbx -= rdi;
        rbx++;
        rdi = *((rsp + 8));
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421cc8 */
#include <stdint.h>
 
uint32_t unix_sigpending (void) {
    rdi = rsp;
    eax = sigpending ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "sigpending";
        uerror ();
    }
    rdi = rsp;
    encode_sigset ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4091a0 */
#include <stdint.h>
 
void sigpending (void) {
    sigpending ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41abf0 */
#include <stdint.h>
 
int64_t camlPrintf_skip_int_literal_120 (void) {
    do {
        rsi = rax;
        rsi >>= 1;
        rdi = *((rbx + 0x10));
        rdi = *((rdi + rsi));
        rdi = rdi + rdi + 1;
        if (rdi < 0x61) {
            goto label_0;
        }
        if (rdi >= 0x75) {
            goto label_1;
        }
        rax += 2;
    } while (1);
label_0:
    if (rdi == 0x49) {
        rax += 2;
        return rax;
    }
label_1:
    rax = *((rbx + 0x18));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421b54 */
#include <stdint.h>
 
uint64_t unix_shutdown (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    rsi = (int64_t) esi;
    rax = obj_shutdown_command_table;
    esi = *((rax + rsi*4));
    rdi >>= 1;
    eax = shutdown ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "shutdown";
        uerror ();
    }
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408df0 */
#include <stdint.h>
 
void shutdown (void) {
    shutdown ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4208d0 */
#include <stdint.h>
 
uint64_t unix_localtime (void) {
    time_t * timer;
    __asm ("cvttsd2si rax, qword [rdi]");
    *((rsp + 8)) = rax;
    rax = localtime (rsp + 8);
    if (rax == 0) {
        edx = 0;
        rsi = "localtime";
        edi = 0x16;
        rax = unix_error ();
    }
    rdi = rax;
    alloc_tm ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4096a0 */
#include <stdint.h>
 
void localtime (void) {
    localtime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fab0 */
#include <stdint.h>
 
int64_t unix_getcwd (void) {
    int64_t canary;
    rax = *(fs:0x28);
    *((rsp + 0x1008)) = rax;
    eax = 0;
    rdi = rsp;
    esi = 0x1000;
    rax = getcwd ();
    if (rax == 0) {
        esi = 0;
        rdi = "getcwd";
        uerror ();
    }
    rdi = rsp;
    caml_copy_string ();
    rdx = *((rsp + 0x1008));
    rdx ^= *(fs:0x28);
    if (rax != 0) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x411590 */
#include <stdint.h>
 
uint64_t camlArray_find_init_105 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rax == 1) {
            goto label_1;
        }
        rdx = *((rax + 8));
        rsi = *(rax);
        rdi = *((rsi - 8));
        rdi >>= 9;
        rdi |= 1;
        if (rdi > 1) {
            rax = *((rsi - 8));
            if (rax != 0xfe) {
                rax = *(rsi);
            } else {
label_0:
                r15 -= 0x10;
                rax = *(reloc.caml_young_limit);
                if (r15 < *(rax)) {
                    goto label_2;
                }
                rax = r15 + 8;
                *((rax - 8)) = 0x4fd;
                __asm ("movlpd xmm0, qword [rsi]");
                __asm ("movlpd qword [rax], xmm0");
            }
            rbx = *((rbx + 0x10));
            void (*0x412cd0)() ();
        }
        rax = rdx;
    } while (1);
label_1:
    rax = *(loc.camlArray__35);
    return rax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4213ea */
#include <stdint.h>
 
int64_t unix_select (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    fd_set * exceptfds;
    fd_set * writefds;
    fd_set * readfds;
    int64_t var_1a0h;
    int64_t var_1a8h;
    int64_t var_1b0h;
    int64_t var_1b8h;
    int64_t var_1c0h;
    int64_t var_1c8h;
    int64_t var_1e0h;
    int64_t var_1e8h;
    int64_t nfds;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x18)) = rdi;
    *((rsp + 0x10)) = rsi;
    *((rsp + 8)) = rdx;
    rdx = *(reloc.caml_local_roots);
    rcx = *(rdx);
    *((rsp + 0x1a0)) = rcx;
    rcx = rsp + 0x1a0;
    *(rdx) = rcx;
    *((rsp + 0x1b0)) = 1;
    *((rsp + 0x1a8)) = 3;
    rdx = rsp + 0x18;
    *((rsp + 0x1b8)) = rdx;
    rdx = rsp + 0x10;
    *((rsp + 0x1c0)) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x1c8)) = rdx;
    *((rsp + 0x1fc)) = 0xffffffff;
    rbx = rsp + 0x1fc;
    rsi = rsp + 0x120;
    rdx = rbx;
    fdlist_to_fdset ();
    rsi = rsp + 0xa0;
    rdx = rbx;
    rdi = *((rsp + 0x10));
    fdlist_to_fdset ();
    rsi = rsp + 0x20;
    rdx = rbx;
    rdi = *((rsp + 8));
    eax = fdlist_to_fdset ();
    xmm0 = *(rbp);
    ebx = 0;
    __asm ("ucomisd xmm0, qword [0x00435c40]");
    if (? != ?) {
        if (? < ?) {
            goto label_0;
        }
    }
    __asm ("cvttsd2si eax, xmm0");
    rax = (int64_t) eax;
    *((rsp + 0x1e0)) = rax;
    __asm ("cvtsi2sd xmm1, rax");
    __asm ("subsd xmm0, xmm1");
    __asm ("mulsd xmm0, qword [0x00435b50]");
    __asm ("cvttsd2si eax, xmm0");
    rax = (int64_t) eax;
    *((rsp + 0x1e8)) = rax;
    rbx = rsp + 0x1e0;
label_0:
    caml_enter_blocking_section ();
    edi++;
    eax = select (*((rsp + 0x1fc)), rsp + 0x120, rsp + 0xa0, rsp + 0x20, rbx);
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx == 0xffffffff) {
        esi = 0;
        rdi = "select";
        uerror ();
    }
    rsi = rsp + 0x120;
    rdi = *((rsp + 0x18));
    rax = fdset_to_fdlist ();
    *((rsp + 0x18)) = rax;
    rsi = rsp + 0xa0;
    rdi = *((rsp + 0x10));
    rax = fdset_to_fdlist ();
    *((rsp + 0x10)) = rax;
    rsi = rsp + 0x20;
    rdi = *((rsp + 8));
    rax = fdset_to_fdlist ();
    *((rsp + 8)) = rax;
    esi = 0;
    edi = 3;
    caml_alloc_small ();
    rdx = *((rsp + 0x18));
    *(rax) = rdx;
    rdx = *((rsp + 0x10));
    *((rax + 8)) = rdx;
    rdx = *((rsp + 8));
    *((rax + 0x10)) = rdx;
    rcx = *((rsp + 0x1a0));
    rdx = *(reloc.caml_local_roots);
    *(rdx) = rcx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420a61 */
#include <stdint.h>
 
uint64_t unix_setitimer (int64_t arg2, int64_t arg1) {
    int64_t var_20h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_50h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    *((rsp - 8)) = r12;
    r12 = rdi;
    rbx = rsp + 0x20;
    xmm0 = *(rsi);
    rdi = rbx;
    unix_set_timeval ();
    xmm0 = *((rbp + 8));
    rdi = rbx + 0x10;
    unix_set_timeval ();
    rdx = rsp;
    r12 >>= 1;
    r12 = (int64_t) r12d;
    rax = obj_itimers;
    edi = *((rax + r12*4));
    rsi = rbx;
    eax = setitimer ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "setitimer";
        uerror ();
    }
    rdi = rsp;
    unix_convert_itimer ();
    rbx = *((rsp + 0x40));
    rbp = *((rsp + 0x48));
    r12 = *((rsp + 0x50));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420a00 */
#include <stdint.h>
 
uint64_t unix_set_timeval (floating_point * iptr, int64_t arg1) {
    floating_point value;
    int64_t var_18h;
    int64_t var_20h;
    rsi = iptr;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rbx = rdi;
    modf (rsp + 8, rsi);
    __asm ("cvttsd2si rbp, qword [rsp + 8]");
    *(rbx) = rbp;
    __asm ("mulsd xmm0, qword [0x00435b50]");
    rax = ceil (rdi);
    __asm ("cvttsd2si rax, xmm0");
    *((rbx + 8)) = rax;
    if (rax > 0xf423f) {
        rbp++;
        *(rbx) = rbp;
        *((rbx + 8)) = 0;
    }
    rbx = *((rsp + 0x18));
    rbp = *((rsp + 0x20));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4095f0 */
#include <stdint.h>
 
void modf (void) {
    modf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408e40 */
#include <stdint.h>
 
void ceil (void) {
    ceil ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408f80 */
#include <stdint.h>
 
void setitimer (void) {
    setitimer ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c9a0 */
#include <stdint.h>
 
uint64_t caml_ml_open_descriptor_in (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    rax = caml_open_descriptor_in ();
    rdi = rax;
    return caml_alloc_channel ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b880 */
#include <stdint.h>
 
int64_t caml_ml_seek_in (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    rsi = arg2;
    rdi = arg1;
    rax = caml_channel_mutex_lock;
    rbp = caml_local_roots;
    rdx = rsp + 0x10;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 2;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x10)) = rbp;
    *((rsp + 0x30)) = rsp;
    *((rsp + 0x28)) = rdx;
    rbx = *((rdi + 8));
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rsi = *(rsp);
    rdi = rbx;
    rsi >>= 1;
    caml_seek_in ();
    rax = caml_channel_mutex_unlock;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    *(obj.caml_local_roots) = rbp;
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f190 */
#include <stdint.h>
 
uint64_t caml_input_value (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_98h;
    rdi = arg1;
    rbp = caml_local_roots;
    rbx = *((rdi + 8));
    rax = rsp + 0x50;
    rdx = rsp + 8;
    *((rsp + 8)) = rdi;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x10)) = rax;
    rax = rsp + 0x10;
    *((rsp + 0x50)) = rbp;
    *((rsp + 0x68)) = rdx;
    *((rsp + 0x98)) = 0;
    *(obj.caml_local_roots) = rax;
    rax = rsp + 0x98;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *((rsp + 0x28)) = rax;
    rax = caml_channel_mutex_lock;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rdi = rbx;
    rax = caml_input_val ();
    rdx = caml_channel_mutex_unlock;
    *((rsp + 0x98)) = rax;
    if (rdx != 0) {
        rdi = rbx;
        void (*rdx)() ();
        rax = *((rsp + 0x98));
    }
    *(obj.caml_local_roots) = rbp;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c420 */
#include <stdint.h>
 
int64_t caml_ml_output_char (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    rsi = arg2;
    rdi = arg1;
    rax = caml_channel_mutex_lock;
    rbp = caml_local_roots;
    rdx = rsp + 0x10;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 2;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x10)) = rbp;
    *((rsp + 0x30)) = rsp;
    *((rsp + 0x28)) = rdx;
    rbx = *((rdi + 8));
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rax = *((rbx + 0x18));
    while (1) {
        rdx = *(rsp);
        rdx >>= 1;
        *(rax) = dl;
        rax++;
        *((rbx + 0x18)) = rax;
        rax = caml_channel_mutex_unlock;
        if (rax != 0) {
            rdi = rbx;
            void (*rax)() ();
        }
        *(obj.caml_local_roots) = rbp;
        eax = 1;
        return rax;
        rdi = rbx;
        caml_flush_partial ();
        rax = *((rbx + 0x18));
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d260 */
#include <stdint.h>
 
int64_t camlPrintf_pr_386 (int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r9 = rax;
    rcx = rdi;
    rax = *((rcx - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rdi = *((rcx + rax));
    rax -= rdi;
    r8 = rax + rax + 1;
    do {
        r15 -= 0x110;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x84f7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlPrintf__doprn_392);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = 0x10f9;
            rax = *(reloc.caml_curry3);
            *((rdi + 0x20)) = rax;
            *((rdi + 0x28)) = 7;
            rax = *(reloc.camlPrintf__cont_s_393);
            *((rdi + 0x30)) = rax;
            *((rdi + 0x38)) = 0x20f9;
            rax = *(reloc.caml_curry4);
            *((rdi + 0x40)) = rax;
            *((rdi + 0x48)) = 9;
            rax = *(reloc.camlPrintf__cont_a_394);
            *((rdi + 0x50)) = rax;
            *((rdi + 0x58)) = 0x30f9;
            rax = *(reloc.caml_curry3);
            *((rdi + 0x60)) = rax;
            *((rdi + 0x68)) = 7;
            rax = *(reloc.camlPrintf__cont_t_395);
            *((rdi + 0x70)) = rax;
            *((rdi + 0x78)) = 0x40f9;
            rax = *(reloc.caml_curry2);
            *((rdi + 0x80)) = rax;
            *((rdi + 0x88)) = 5;
            rax = *(reloc.camlPrintf__cont_f_396);
            *((rdi + 0x90)) = rax;
            *((rdi + 0x98)) = 0x50f9;
            rax = *(reloc.caml_curry3);
            *((rdi + 0xa0)) = rax;
            *((rdi + 0xa8)) = 7;
            rax = *(reloc.camlPrintf__cont_m_397);
            *((rdi + 0xb0)) = rax;
            rax = *((rdx + 0x18));
            *((rdi + 0xb8)) = rax;
            rax = *((rdx + 0x20));
            *((rdi + 0xc0)) = rax;
            rax = *((rdx + 0x28));
            *((rdi + 0xc8)) = rax;
            rax = *((rdx + 0x30));
            *((rdi + 0xd0)) = rax;
            rax = *((rdx + 0x38));
            *((rdi + 0xd8)) = rax;
            *((rdi + 0xe0)) = rdx;
            *((rdi + 0xe8)) = r9;
            *((rdi + 0xf0)) = rcx;
            *((rdi + 0xf8)) = rsi;
            *((rdi + 0x100)) = r8;
            rsi = 1;
            rax = rbx;
            rbx = rsi;
            void (*0x41b1e0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4228d0 */
#include <stdint.h>
 
uint64_t unix_tcflow (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    rsi = (int64_t) esi;
    rax = obj_action_flag_table;
    esi = *((rax + rsi*4));
    rdi >>= 1;
    eax = tcflow ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "tcflow";
        uerror ();
    }
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409430 */
#include <stdint.h>
 
void tcflow (void) {
    tcflow ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4116c0 */
#include <stdint.h>
 
uint64_t camlArray_fill_162 (int64_t arg1) {
    rdi = arg1;
    do {
        r12 = rax;
        if (rbx == 1) {
            goto label_0;
        }
        r13 = *((rbx + 8));
        rsi = *(rbx);
        rbx = *((rbp + 0x18));
        rax = *((rbx - 8));
        if (rax != 0xfe) {
            rdi = rbx + r12*4 - 4;
            caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [rbx + r12*4 - 4], xmm0");
        }
        rax = r12;
        rax += 2;
        rbx = r13;
        rdi = rbp;
    } while (1);
label_0:
    rax = *((rbp + 0x18));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41c1a0 */
#include <stdint.h>
 
int64_t camlPrintf_fun_610 (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_18h_2;
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x20)) = rax;
    *((rsp + 0x18)) = rbx;
    *((rsp + 0x10)) = rdi;
    *((rsp + 8)) = rsi;
    *(rsp) = rdx;
    rsi = 1;
    rdi = 9;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = rax;
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 1) {
            goto label_0;
        }
        rdi = rbx;
        rsi = *((rsp + 0x20));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 1) {
            goto label_1;
        }
        rax = *((rsp + 0x20));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 3) {
            goto label_2;
        }
        rdi = rbx;
        rdi += 8;
        rsi = *((rsp + 0x18));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 3) {
            goto label_3;
        }
        rax = *((rsp + 0x18));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 8], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 5) {
            goto label_4;
        }
        rdi = rbx;
        rdi += 0x10;
        rsi = *((rsp + 0x10));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 5) {
            goto label_5;
        }
        rax = *((rsp + 0x10));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 0x10], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 7) {
            goto label_6;
        }
        rdi = rbx;
        rdi += 0x18;
        rsi = *((rsp + 8));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 7) {
            goto label_7;
        }
        rax = *((rsp + 8));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 0x18], xmm0");
    }
    rax = *(rsp);
    rdi = *((rax + 0x18));
    rax = *((rax + 0x20));
    void (*0x40a5b0)() ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b3e0 */
#include <stdint.h>
 
int32_t caml_ml_set_binary_mode (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a370 */
#include <stdint.h>
 
int64_t caml_curry3_1 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry3_2);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4204cf */
#include <stdint.h>
 
uint64_t unix_getpwnam (void) {
    rax = getpwnam ();
    if (rax == 0) {
        rax = caml_raise_not_found ();
    }
    rdi = rax;
    alloc_passwd_entry ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409740 */
#include <stdint.h>
 
void getpwnam (void) {
    getpwnam ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a3c0 */
#include <stdint.h>
 
int64_t caml_curry3_2 (void) {
    rdi = rax;
    rax = *((rbx + 0x18));
    rsi = *((rax + 0x18));
    rbx = *((rbx + 0x10));
    rax = *((rax + 0x10));
    rdx = *((rsi + 0x10));
    return void (*rdx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418190 */
#include <stdint.h>
 
int64_t camlHashtbl_replace_bucket_144 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rax == 1) {
            goto label_2;
        }
        *((rsp + 0x10)) = rbx;
        rdi = *((rax + 0x10));
        *((rsp + 0x18)) = rdi;
        rdi = *((rax + 8));
        *(rsp) = rdi;
        rdi = *(rax);
        *((rsp + 8)) = rdi;
        rsi = *((rbx + 0x10));
        rax = *(reloc.caml_compare);
        rax = caml_c_call ();
        if (rax == 1) {
label_1:
            r15 -= 0x20;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_3;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0xc00;
            rbx = *((rsp + 8));
            *(rax) = rbx;
            rbx = *((rsp + 0x10));
            rbx = *((rbx + 0x18));
            *((rax + 8)) = rbx;
            rbx = *((rsp + 0x18));
            *((rax + 0x10)) = rbx;
            return rax;
        }
        rax = *((rsp + 0x18));
        rbx = *((rsp + 0x10));
        rax = camlHashtbl_replace_bucket_144 ();
    } while (1);
    rdi = rax;
label_0:
    r15 -= 0x20;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_4;
    }
    rax = r15 + 8;
    *((rax - 8)) = 0xc00;
    rbx = *((rsp + 8));
    *(rax) = rbx;
    rbx = *(rsp);
    *((rax + 8)) = rbx;
    *((rax + 0x10)) = rdi;
    return rax;
    do {
label_2:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4147c0 */
#include <stdint.h>
 
int64_t camlList_rev_merge_rev_289 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_18h_2;
    int64_t var_20h_2;
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
label_0:
        if (rax == 1) {
            goto label_2;
        }
        if (rbx == 1) {
            goto label_3;
        }
        *((rsp + 0x38)) = rsi;
        *((rsp + 0x20)) = rdi;
        *((rsp + 0x30)) = rbx;
        *((rsp + 8)) = rax;
        rdi = *((rbx + 8));
        *((rsp + 0x10)) = rdi;
        rbx = *(rbx);
        *(rsp) = rbx;
        rdi = *((rax + 8));
        *((rsp + 0x28)) = rdi;
        rax = *(rax);
        *((rsp + 0x18)) = rax;
        rdi = *((rsi + 0x18));
        rax = caml_apply2 ();
        if (rax <= 1) {
            goto label_4;
        }
label_1:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_5;
        }
        rdi = r15 + 8;
        *((rdi - 8)) = 0x800;
        rax = *((rsp + 0x18));
        *(rdi) = rax;
        rax = *((rsp + 0x20));
        *((rdi + 8)) = rax;
        rax = *((rsp + 0x28));
        rbx = *((rsp + 0x30));
        rsi = *((rsp + 0x38));
    } while (1);
    do {
label_4:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x800;
            rax = *(rsp);
            *(rdi) = rax;
            rax = *((rsp + 0x20));
            *((rdi + 8)) = rax;
            rax = *((rsp + 8));
            rbx = *((rsp + 0x10));
            rsi = *((rsp + 0x38));
            goto label_0;
label_3:
            rbx = rdi;
            void (*0x415380)() ();
label_2:
            rax = rbx;
            rbx = rdi;
            void (*0x415380)() ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41bf80 */
#include <stdint.h>
 
int64_t camlPrintf_fun_613 (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_18h_2;
    int64_t var_20h_2;
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x28)) = rax;
    *((rsp + 0x20)) = rbx;
    *((rsp + 0x18)) = rdi;
    *((rsp + 0x10)) = rsi;
    *((rsp + 8)) = rdx;
    *(rsp) = rcx;
    rsi = 1;
    rdi = 0xb;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = rax;
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 1) {
            goto label_0;
        }
        rdi = rbx;
        rsi = *((rsp + 0x28));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 1) {
            goto label_1;
        }
        rax = *((rsp + 0x28));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 3) {
            goto label_2;
        }
        rdi = rbx;
        rdi += 8;
        rsi = *((rsp + 0x20));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 3) {
            goto label_3;
        }
        rax = *((rsp + 0x20));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 8], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 5) {
            goto label_4;
        }
        rdi = rbx;
        rdi += 0x10;
        rsi = *((rsp + 0x18));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 5) {
            goto label_5;
        }
        rax = *((rsp + 0x18));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 0x10], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 7) {
            goto label_6;
        }
        rdi = rbx;
        rdi += 0x18;
        rsi = *((rsp + 0x10));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 7) {
            goto label_7;
        }
        rax = *((rsp + 0x10));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 0x18], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 9) {
            goto label_8;
        }
        rdi = rbx;
        rdi += 0x20;
        rsi = *((rsp + 8));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 9) {
            goto label_9;
        }
        rax = *((rsp + 8));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 0x20], xmm0");
    }
    rax = *(rsp);
    rdi = *((rax + 0x18));
    rax = *((rax + 0x20));
    void (*0x40a5b0)() ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4186d0 */
#include <stdint.h>
 
int64_t camlHashtbl_find_226 (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    rdi = arg1;
    rsi = *((rax + 8));
    rsi = *((rsi - 8));
    rsi >>= 0xa;
    if (rsi != 0) {
        rdi = *((rdi + 0x20));
        rdi = *((rdi + 0x10));
        rsi = *((rdi + 8));
        rdi = *(rsi);
        rax = rbx;
        rbx = rsi;
        rax = void (*rdi)(uint64_t, uint64_t) (rsi, rdi);
        rbx = 0x7fffffffffffffff;
        rax &= rbx;
        rax >>= 1;
        rcx = *((rsp + 0x18));
        __asm ("cqo");
        rax = rdx:rax / rcx;
        rdx = rdx:rax % rcx;
    } else {
        rax = *(reloc.caml_bucket_Division_by_zero);
        caml_raise_exn ();
    }
    rdx <<= 1;
    rdx++;
    rax = *(rsp);
    rbx = *((rax + 8));
    rax = *((rbx - 8));
    rax >>= 9;
    if (rax <= rdx) {
        goto label_2;
    }
    rbx = *((rbx + rdx*4 - 4));
    if (rbx == 1) {
        goto label_3;
    }
    rax = *((rbx + 0x10));
    *(rsp) = rax;
    rax = *((rbx + 8));
    *((rsp + 0x18)) = rax;
    rbx = *(rbx);
    rax = *((rsp + 8));
    rax = *((rax + 0x18));
    rdi = *(rax);
    rax = *((rsp + 0x10));
    rax = caml_apply2 ();
    if (rax != 1) {
        rax = *((rsp + 0x18));
        return rax;
    }
    rax = *(rsp);
    if (rax != 1) {
        rbx = *((rax + 0x10));
        *(rsp) = rbx;
        rbx = *((rax + 8));
        *((rsp + 0x18)) = rbx;
        rbx = *(rax);
        rax = *((rsp + 8));
        rax = *((rax + 0x18));
        rdi = *(rax);
        rax = *((rsp + 0x10));
        rax = caml_apply2 ();
        if (rax != 1) {
            rax = *((rsp + 0x18));
            return rax;
        }
        rax = *(rsp);
        if (rax != 1) {
            rbx = *((rax + 0x10));
            *(rsp) = rbx;
            rbx = *((rax + 8));
            *((rsp + 0x18)) = rbx;
            rbx = *(rax);
            rax = *((rsp + 8));
            rax = *((rax + 0x18));
            rdi = *(rax);
            rax = *((rsp + 0x10));
            rax = caml_apply2 ();
            if (rax != 1) {
                rax = *((rsp + 0x18));
                return rax;
            }
            rax = *((rsp + 8));
            rdi = *((rax + 0x28));
            rax = *((rsp + 0x10));
            rbx = *(rsp);
            void (*0x418640)() ();
        }
label_1:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_4;
        }
        rbx = r15 + 8;
        *((rbx - 8)) = 0x400;
        rax = *(reloc.caml_exn_Not_found);
        *(rbx) = rax;
        rax = rbx;
        caml_raise_exn ();
    }
label_0:
    r15 -= 0x10;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_5;
    }
    rbx = r15 + 8;
    *((rbx - 8)) = 0x400;
    rax = *(reloc.caml_exn_Not_found);
    *(rbx) = rax;
    rax = rbx;
    caml_raise_exn ();
    do {
label_3:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_2:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x412760 */
#include <stdint.h>
 
int64_t camlArray_sortto_244 (signed int64_t arg3, signed int64_t arg2, int64_t arg1) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    signed int64_t var_18h_2;
    signed int64_t var_20h_2;
    int64_t var_28h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    do {
label_0:
        r8 = rax;
        rcx = rdx;
        if (rsi <= 0xb) {
            rdx = *((rcx + 0x28));
            rax = r8;
            void (*0x412420)() ();
        }
        *(rsp) = rcx;
        *((rsp + 0x10)) = rdi;
        *((rsp + 0x28)) = rbx;
        *((rsp + 0x20)) = r8;
        rdx = rsi;
        rdx >>= 1;
        rax = rdx;
        rdx++;
        __asm ("cmovns rdx, rax");
        rdx >>= 1;
        rax = rdx + rdx + 1;
        *((rsp + 8)) = rax;
        rsi -= rax;
        rsi++;
        *((rsp + 0x18)) = rsi;
        rdi = rdi + rax - 1;
        rax = r8 + rax - 1;
        rdx = rcx;
        camlArray_sortto_244 ();
    } while (1);
    rbx = *((rsp + 0x18));
    rax = *((rsp + 0x20));
    rdi = rax + rbx - 1;
    rdx = *(rsp);
    rbx = *((rdx + 0x18));
    rsi = *((rsp + 8));
    camlArray_sortto_244 ();
    goto label_0;
    rax = *(rsp);
    r9 = *((rax + 0x20));
    rbx = *((rsp + 8));
    r8 = *((rsp + 0x10));
    rsi = r8 + rbx - 1;
    rdx = *((rsp + 0x18));
    rax = *((rsp + 0x20));
    rax = rax + rdx - 1;
    rdi = *((rsp + 0x28));
    rcx = *((rsp + 0x28));
    return camlArray_merge_218 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f1c8 */
#include <stdint.h>
 
int64_t unix_environment (void) {
    rax = *(reloc.environ);
    rdi = *(rax);
    caml_copy_string_array ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d4e0 */
#include <stdint.h>
 
int64_t camlPrintf_index_of_literal_position_72 (void) {
    rax += 0xfffffffffffffffe;
    return camlPrintf_index_of_int_65 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41bd00 */
#include <stdint.h>
 
int64_t camlPrintf_fun_616 (int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_18h_2;
    int64_t var_20h_2;
    int64_t var_28h_2;
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x30)) = rax;
    *((rsp + 0x28)) = rbx;
    *((rsp + 0x20)) = rdi;
    *((rsp + 0x18)) = rsi;
    *((rsp + 0x10)) = rdx;
    *((rsp + 8)) = rcx;
    *(rsp) = r8;
    rsi = 1;
    rdi = 0xd;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = rax;
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 1) {
            goto label_0;
        }
        rdi = rbx;
        rsi = *((rsp + 0x30));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 1) {
            goto label_1;
        }
        rax = *((rsp + 0x30));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 3) {
            goto label_2;
        }
        rdi = rbx;
        rdi += 8;
        rsi = *((rsp + 0x28));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 3) {
            goto label_3;
        }
        rax = *((rsp + 0x28));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 8], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 5) {
            goto label_4;
        }
        rdi = rbx;
        rdi += 0x10;
        rsi = *((rsp + 0x20));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 5) {
            goto label_5;
        }
        rax = *((rsp + 0x20));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 0x10], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 7) {
            goto label_6;
        }
        rdi = rbx;
        rdi += 0x18;
        rsi = *((rsp + 0x18));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 7) {
            goto label_7;
        }
        rax = *((rsp + 0x18));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 0x18], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 9) {
            goto label_8;
        }
        rdi = rbx;
        rdi += 0x20;
        rsi = *((rsp + 0x10));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 9) {
            goto label_9;
        }
        rax = *((rsp + 0x10));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 0x20], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 0xb) {
            goto label_10;
        }
        rdi = rbx;
        rdi += 0x28;
        rsi = *((rsp + 8));
        rax = caml_modify ();
    } else {
        rax >>= 9;
        if (rax <= 0xb) {
            goto label_11;
        }
        rax = *((rsp + 8));
        __asm ("movlpd xmm0, qword [rax]");
        __asm ("movlpd qword [rbx + 0x28], xmm0");
    }
    rax = *(rsp);
    rdi = *((rax + 0x18));
    rax = *((rax + 0x20));
    void (*0x40a5b0)() ();
label_11:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
label_8:
    caml_ml_array_bound_error ();
label_7:
    caml_ml_array_bound_error ();
label_6:
    caml_ml_array_bound_error ();
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
label_1:
    caml_ml_array_bound_error ();
label_0:
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b470 */
#include <stdint.h>
 
int64_t caml_ml_pos_out (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    rbx = *((rax + 0x18));
    rbx += *((rax + 8));
    rax += 0x50;
    rbx -= rax;
    rax = 0x3fffffffffffffff;
    if (rbx > rax) {
        errno_location ();
        edi = 1;
        *(rax) = 0x4b;
        caml_sys_error ();
    }
    rax = rbx + rbx + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422669 */
#include <stdint.h>
 
uint32_t unix_stat_64 (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    rdx = rsp;
    rsi = rdi;
    edi = 1;
    eax = xstat64 ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = 0x00435d91;
        uerror ();
    }
    rsi = rsp;
    edi = 1;
    stat_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409560 */
#include <stdint.h>
 
void xstat64 (void) {
    xstat64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41abd0 */
#include <stdint.h>
 
int64_t camlPrintf_fun_703 (int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rax = rbx;
    rdi = *((rax + 0x10));
    rbx = *((rax + 0x18));
    rax = *((rax + 0x20));
    return camlPrintf_doprn_392 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420e34 */
#include <stdint.h>
 
int64_t unix_open (int64_t arg3, int64_t arg2, char * arg1) {
    int64_t var_8h;
    int64_t var_10h;
    char * src;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_48h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x18)) = rdi;
    rdi = rsi;
    *((rsp + 0x10)) = rsi;
    *((rsp + 8)) = rdx;
    rax = *(reloc.caml_local_roots);
    rbp = *(rax);
    *((rsp + 0x20)) = rbp;
    rdx = rsp + 0x20;
    *(rax) = rdx;
    *((rsp + 0x30)) = 1;
    *((rsp + 0x28)) = 3;
    rax = rsp + 0x18;
    *((rsp + 0x38)) = rax;
    rax = rsp + 0x10;
    *((rsp + 0x40)) = rax;
    rax = rsp + 8;
    *((rsp + 0x48)) = rax;
    rsi = obj_open_flag_table;
    eax = caml_convert_flag_list ();
    r12d = eax;
    rdi = *((rsp + 0x18));
    caml_string_length ();
    rdi = rax + 1;
    rax = caml_stat_alloc ();
    rbx = rax;
    strcpy (rax, *((rsp + 0x18)));
    caml_enter_blocking_section ();
    rdx = *((rsp + 8));
    rdx >>= 1;
    esi = r12d;
    rdi = rbx;
    eax = 0;
    eax = open64 ();
    r12d = eax;
    caml_leave_blocking_section ();
    rdi = rbx;
    caml_stat_free ();
    if (r12d == 0xffffffff) {
        rsi = *((rsp + 0x18));
        rdi = "open";
        uerror ();
    }
    rax = *(reloc.caml_local_roots);
    *(rax) = rbp;
    r12 = (int64_t) r12d;
    rax = r12 + r12 + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4094e0 */
#include <stdint.h>
 
void strcpy (void) {
    strcpy ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409260 */
#include <stdint.h>
 
void open64 (void) {
    open64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427660 */
#include <stdint.h>
 
void caml_stat_free (void) {
    return free ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420f78 */
#include <stdint.h>
 
uint64_t unix_pipe (void) {
    int64_t var_4h;
    rdi = rsp;
    eax = pipe ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "pipe";
        uerror ();
    }
    esi = 0;
    edi = 2;
    caml_alloc_small ();
    rdx = *(rsp);
    rdx = rdx + rdx + 1;
    *(rax) = rdx;
    rdx = *((rsp + 4));
    rdx = rdx + rdx + 1;
    *((rax + 8)) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4091f0 */
#include <stdint.h>
 
void pipe (void) {
    pipe ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42fc90 */
#include <stdint.h>
 
uint64_t caml_sys_open (int64_t arg3, int64_t arg2, char * arg1) {
    int64_t var_8h;
    int64_t var_10h;
    char * src;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_68h;
    int64_t var_70h;
    int64_t var_78h;
    int64_t var_80h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x20)) = rbx;
    *((rsp - 0x18)) = rbp;
    *((rsp - 0x10)) = r12;
    *((rsp - 8)) = r13;
    *((rsp + 8)) = rdx;
    rdx = rsp + 0x20;
    r12 = caml_local_roots;
    *((rsp + 0x10)) = rsi;
    *((rsp + 0x18)) = rdi;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 0x18;
    *((rsp + 0x30)) = 1;
    *((rsp + 0x20)) = r12;
    *((rsp + 0x28)) = 3;
    *((rsp + 0x38)) = rdx;
    rdx = rsp + 0x10;
    *((rsp + 0x40)) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x48)) = rdx;
    caml_string_length ();
    rdi = rax + 1;
    rax = caml_stat_alloc ();
    rdi = rax;
    strcpy (rdi, *((rsp + 0x18)));
    rdi = *((rsp + 0x10));
    esi = sys_open_flags;
    eax = caml_convert_flag_list ();
    r13 = *((rsp + 8));
    ebx = eax;
    eax = caml_enter_blocking_section ();
    esi = ebx;
    rdi = rbp;
    eax = 0;
    r13 >>= 1;
    edx = r13d;
    eax = open64 ();
    ebx = eax;
    caml_leave_blocking_section ();
    rdi = rbp;
    eax = caml_stat_free ();
    if (ebx != 0xffffffff) {
        edi = ebx;
        edx = 1;
        rbx = (int64_t) ebx;
        esi = 2;
        eax = 0;
        fcntl ();
        *(obj.caml_local_roots) = r12;
        rax = rbx + rbx + 1;
        rbp = *((rsp + 0x70));
        rbx = *((rsp + 0x68));
        r12 = *((rsp + 0x78));
        r13 = *((rsp + 0x80));
        return rax;
    }
    rdi = *((rsp + 0x18));
    return caml_sys_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420270 */
#include <stdint.h>
 
int64_t unix_getppid (void) {
    getppid ();
    rax = (int64_t) eax;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409600 */
#include <stdint.h>
 
void getppid (void) {
    getppid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c640 */
#include <stdint.h>
 
int64_t caml_ml_output_int (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    rsi = arg2;
    rdi = arg1;
    rax = caml_channel_mutex_lock;
    rbp = caml_local_roots;
    rdx = rsp + 0x10;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 2;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x10)) = rbp;
    *((rsp + 0x30)) = rsp;
    *((rsp + 0x28)) = rdx;
    rbx = *((rdi + 8));
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rsi = *(rsp);
    rdi = rbx;
    rsi >>= 1;
    caml_putword ();
    rax = caml_channel_mutex_unlock;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    *(obj.caml_local_roots) = rbp;
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420258 */
#include <stdint.h>
 
int64_t unix_getpid (void) {
    getpid ();
    rax = (int64_t) eax;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409030 */
#include <stdint.h>
 
void getpid (void) {
    getpid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421828 */
#include <stdint.h>
 
int64_t unix_recvfrom (int64_t arg_20h, int64_t arg_28h, int64_t arg_30h, int64_t arg_38h, int64_t arg_40h, int64_t arg_60h, int64_t arg_6ch, void * s2, int64_t arg_4070h, int64_t canary, int64_t arg5, int64_t arg4, int64_t arg3, void * arg2, int64_t arg1) {
    void * s1;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x18)) = rsi;
    r13 = rdx;
    rbx = rcx;
    rax = *(fs:0x28);
    *((rsp + 0x40e8)) = rax;
    eax = 0;
    *((rsp + 0x60)) = 1;
    rsi = obj_msg_flag_table;
    rdi = r8;
    eax = caml_convert_flag_list ();
    r12d = eax;
    rax = *(reloc.caml_local_roots);
    rdx = *(rax);
    *((rsp + 0x20)) = rdx;
    rdx = rsp + 0x20;
    *(rax) = rdx;
    *((rsp + 0x30)) = 1;
    *((rsp + 0x28)) = 2;
    rax = rsp + 0x18;
    *((rsp + 0x38)) = rax;
    rax = rsp + 0x60;
    *((rsp + 0x40)) = rax;
    rbx >>= 1;
    *((rsp + 0x6c)) = 0x70;
    caml_enter_blocking_section ();
    edx = 0x4000;
    if (rbx > 0x4000) {
        rbx = rdx;
    }
    rdx = (int64_t) ebx;
    rsi = rsp + 0x70;
    rdi = rbp;
    rdi >>= 1;
    rax = rsp + 0x6c;
    *(rsp) = rax;
    r9 = rsp + 0x4070;
    r8d = r12d;
    ecx = 0x4000;
    eax = recvfrom_chk ();
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx == 0xffffffff) {
        esi = 0;
        rdi = "recvfrom";
        uerror ();
    }
    rbx = (int64_t) ebx;
    r13 >>= 1;
    rdi += *((rsp + 0x18));
    memmove (r13, rsp + 0x70, rbx);
    rdi = rsp + 0x4070;
    edx = 0xffffffff;
    esi = *((rsp + 0x6c));
    rax = alloc_sockaddr ();
    *((rsp + 0x60)) = rax;
    esi = 0;
    edi = 2;
    caml_alloc_small ();
    rdx = rbx + rbx + 1;
    *(rax) = rdx;
    rdx = *((rsp + 0x60));
    *((rax + 8)) = rdx;
    rcx = *((rsp + 0x20));
    rdx = *(reloc.caml_local_roots);
    *(rdx) = rcx;
    rdx = *((rsp + 0x40e8));
    rdx ^= *(fs:0x28);
    if (rdi != 0) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42307c */
#include <stdint.h>
 
uint32_t unix_utimes (int64_t arg3, int64_t arg1) {
    int64_t var_8h;
    rdx = arg3;
    rdi = arg1;
    rbx = rdi;
    __asm ("cvttsd2si rax, qword [rsi]");
    *(rsp) = rax;
    __asm ("cvttsd2si rdx, qword [rdx]");
    if (rax == 0) {
        esi = 0;
        if (rdx == 0) {
            goto label_0;
        }
    }
    rsi = rsp;
label_0:
    *((rsp + 8)) = rdx;
    rdi = rbx;
    eax = utime ();
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "utimes";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f5b0 */
#include <stdint.h>
 
uint64_t caml_sys_get_config (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_40h;
    int64_t var_48h;
    edi = "Unix";
    rbx = caml_local_roots;
    rax = rsp + 0x48;
    *((rsp + 0x48)) = 0;
    *((rsp + 0x40)) = 0;
    *(obj.caml_local_roots) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x40;
    *(rsp) = rbx;
    *((rsp + 8)) = 2;
    *((rsp + 0x20)) = rax;
    rax = caml_copy_string ();
    esi = 0;
    edi = 2;
    *((rsp + 0x40)) = rax;
    rax = caml_alloc_small ();
    rdx = *((rsp + 0x40));
    *((rsp + 0x48)) = rax;
    *(obj.caml_local_roots) = rbx;
    *(rax) = rdx;
    rax = *((rsp + 0x48));
    *((rax + 8)) = 0x81;
    rax = *((rsp + 0x48));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418310 */
#include <stdint.h>
 
int64_t camlHashtbl_do_bucket_160 (void) {
    int64_t var_8h;
    do {
        if (rax == 1) {
            goto label_0;
        }
        *((rsp + 8)) = rbx;
        rdi = *((rax + 0x10));
        *(rsp) = rdi;
        rsi = *((rax + 8));
        rax = *(rax);
        rdi = *((rbx + 0x10));
        rbx = rsi;
        caml_apply2 ();
        rax = *(rsp);
        rbx = *((rsp + 8));
    } while (1);
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42bea0 */
#include <stdint.h>
 
int64_t caml_ml_input_char (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    rdi = arg1;
    *((rsp - 0x10)) = rbp;
    *((rsp - 0x18)) = rbx;
    *((rsp - 8)) = r12;
    rax = caml_channel_mutex_lock;
    rdx = rsp + 0x10;
    rbp = caml_local_roots;
    *((rsp + 8)) = rdi;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x10)) = rbp;
    rbx = *((rdi + 8));
    *((rsp + 0x28)) = rdx;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rax = *((rbx + 0x18));
    if (rax >= *((rbx + 0x20))) {
        goto label_0;
    }
    r12d = *(rax);
    rax++;
    *((rbx + 0x18)) = rax;
    do {
        rdx = caml_channel_mutex_unlock;
        if (rdx != 0) {
            rdi = rbx;
            void (*rdx)() ();
        }
        r12d = (int32_t) r12b;
        *(obj.caml_local_roots) = rbp;
        rbx = *((rsp + 0x50));
        rax = r12 + r12 + 1;
        rbp = *((rsp + 0x58));
        r12 = *((rsp + 0x60));
        return rax;
label_0:
        rdi = rbx;
        eax = caml_refill ();
        r12d = eax;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422205 */
#include <stdint.h>
 
int32_t unix_setsockopt (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r8 = rsi;
    r9 = rcx;
    rsi = rdi;
    rsi >>= 1;
    eax = esi;
    rdx >>= 1;
    rdx = (int64_t) edx;
    rdx <<= 3;
    rcx = obj_sockopt_table;
    rdx += *((rcx + rax*8));
    ecx = *((rdx + 4));
    rdi = obj_setsockopt_fun_name;
    rdi = *((rdi + rax*8));
    edx = *(rdx);
    unix_setsockopt_aux ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422140 */
#include <stdint.h>
 
int32_t unix_setsockopt_aux (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, uint32_t arg2, int64_t arg1) {
    int64_t var_4h;
    int64_t var_8h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    eax = edx;
    edx = ecx;
    rdi = r8;
    if (esi != 2) {
        if (esi >= 2) {
            if (esi != 3) {
                goto label_0;
            }
            r9 >>= 1;
            *(rsp) = r9d;
            r8d = 4;
        } else {
        } else {
            rcx = r9;
            rcx ^= 1;
            ecx &= 1;
            *(rsp) = ecx;
            r8d = 8;
            if (ecx == 0) {
                goto label_1;
            }
            rcx = *(r9);
            rcx >>= 1;
            *((rsp + 4)) = ecx;
            goto label_1;
        }
        xmm0 = *(r9);
        __asm ("cvttsd2si ecx, xmm0");
        rcx = (int64_t) ecx;
        *(rsp) = rcx;
        __asm ("cvtsi2sd xmm1, rcx");
        __asm ("subsd xmm0, xmm1");
        __asm ("mulsd xmm0, qword [0x00435b50]");
        __asm ("cvttsd2si ecx, xmm0");
        rcx = (int64_t) ecx;
        *((rsp + 8)) = rcx;
        r8d = 0x10;
        goto label_1;
label_0:
        edx = 0;
        rsi = rbx;
        edi = 0x16;
        eax = unix_error ();
    }
label_1:
    rdi >>= 1;
    eax = setsockopt (rdi, eax, rdx, rsp, r8);
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = rbx;
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421b28 */
#include <stdint.h>
 
uint32_t unix_setuid (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    eax = setuid ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "setuid";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409080 */
#include <stdint.h>
 
void setuid (void) {
    setuid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42003c */
#include <stdint.h>
 
uint64_t unix_getlogin (void) {
    rax = getlogin ();
    if (rax == 0) {
        edx = 0;
        rsi = "getlogin";
        edi = 2;
        rax = unix_error ();
    }
    rdi = rax;
    caml_copy_string ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408e70 */
#include <stdint.h>
 
void getlogin (void) {
    getlogin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41bc00 */
#include <stdint.h>
 
int64_t camlPrintf_loop_268 (int64_t arg_8h_5, int64_t arg_10h_4, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
    rax = *((rdi + 0x28));
    if (rdx < rax) {
        goto label_1;
    }
    *((rsp + 8)) = rdi;
    *(rsp) = rbx;
    rsi = 1;
    rdi = *((rdi + 0x28));
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rdi = rax;
    *((rsp + 0x10)) = rdi;
label_0:
    r15 -= 0x30;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_2;
    }
    rax = r15 + 8;
    *((rax - 8)) = 0x14f7;
    rbx = *(reloc.caml_curry2);
    *(rax) = rbx;
    *((rax + 8)) = 5;
    rbx = *(reloc.camlPrintf__fun_594);
    *((rax + 0x10)) = rbx;
    rbx = *((rsp + 8));
    rbx = *((rbx + 0x28));
    *((rax + 0x18)) = rbx;
    *((rax + 0x20)) = rdi;
    rbx = *(rsp);
    camlPrintf_list_iter_i_229 ();
    rax = *((rsp + 8));
    rdi = *((rax + 0x18));
    rax = *((rax + 0x20));
    rbx = *((rsp + 0x10));
    void (*0x40a5b0)() ();
    do {
label_1:
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x14f7;
            rsi = *(reloc.camlPrintf__fun_597);
            *(rax) = rsi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rdi;
            *((rax + 0x18)) = rdx;
            *((rax + 0x20)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422820 */
#include <stdint.h>
 
int64_t unix_string_of_inet_addr (int64_t arg1) {
    int64_t canary;
    rdi = arg1;
    rbx = rdi;
    rax = *(fs:0x28);
    *((rsp + 0x48)) = rax;
    eax = 0;
    rax = caml_string_length ();
    if (rax == 0x10) {
        rdx = rsp;
        ecx = 0x40;
        rsi = rbx;
        edi = 0xa;
        inet_ntop ();
    } else {
        rdx = rsp;
        ecx = 0x40;
        rsi = rbx;
        edi = 2;
        rax = inet_ntop ();
    }
    if (rax == 0) {
        esi = 0;
        rdi = "string_of_inet_addr";
        rax = uerror ();
    }
    rdi = rax;
    caml_copy_string ();
    rdx = *((rsp + 0x48));
    rdx ^= *(fs:0x28);
    if (rax != 0) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ac60 */
#include <stdint.h>
 
int64_t caml_create_string (uint32_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    rax = 0x1fffffffffffff7;
    if (rdi <= rax) {
        void (*0x428170)() ();
    }
    edi = "String.create";
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x419d30 */
#include <stdint.h>
 
int64_t camlBuffer_advance_132 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, signed int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
label_0:
        if (rbx >= rdi) {
label_1:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_2;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            rax = caml_raise_exn ();
        }
        rdx = *((rsi + 0x18));
        r10 = *((rsi + 0x28));
        r9 = rbx;
        r9 >>= 1;
        rcx = *((r10 - 8));
        rcx >>= 0xa;
        rcx = rcx*8 - 1;
        r8 = *((r10 + rcx));
        rcx -= r8;
        if (rcx <= r9) {
            goto label_3;
        }
        rcx = *((r10 + r9));
        rcx = rcx + rcx + 1;
        if (rcx != rdx) {
            goto label_4;
        }
        rbx += 2;
        rax += 2;
    } while (1);
label_4:
    rdx = *((rsi + 0x20));
    r10 = *((rsi + 0x28));
    r9 = rbx;
    r9 >>= 1;
    rcx = *((r10 - 8));
    rcx >>= 0xa;
    rcx = rcx*8 - 1;
    r8 = *((r10 + rcx));
    rcx -= r8;
    if (rcx > r9) {
        rcx = *((r10 + r9));
        rcx = rcx + rcx + 1;
        if (rcx == rdx) {
            if (rax == 1) {
                rax = rbx;
                return rax;
            }
            rbx += 2;
            rax += 0xfffffffffffffffe;
            goto label_0;
        }
        rbx += 2;
        goto label_0;
label_2:
        caml_call_gc ();
        goto label_1;
    }
    caml_ml_array_bound_error ();
label_3:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41f0a4 */
#include <stdint.h>
 
int32_t unix_closedir (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    rdi = *(rdi);
    if (rdi == 0) {
        edx = 0;
        rsi = "closedir";
        dil = 9;
        unix_error ();
    }
    closedir ();
    *(rbx) = 0;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409590 */
#include <stdint.h>
 
void closedir (void) {
    closedir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a780 */
#include <stdint.h>
 
int64_t camlUnix_fun_1847 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    if ((dil & 1) != 0) {
        rdi >>= 1;
        if (rdi < 2) {
            goto label_0;
        }
        rax = *((rbx + 0x20));
        *(rax) = 3;
        rax = 1;
        return rax;
    }
    rax = *((rdi - 8));
    if (rax < 1) {
        goto label_0;
    }
    if (rax > 1) {
        goto label_1;
    }
    rdi = *(rdi);
    do {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x400;
            *(rsi) = rdi;
            rdi = *((rbx + 0x10));
            caml_modify ();
            rax = 1;
            return rax;
label_1:
            rdi = *(rdi);
            rax = *((rbx + 0x18));
            *(rax) = rdi;
            rax = 1;
            return rax;
label_0:
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4276a0 */
#include <stdint.h>
 
uint64_t caml_modify (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    rbx = rdi;
    *((rsp - 0x10)) = rbp;
    *((rsp - 8)) = r12;
    r12 = *(rdi);
    *(rbx) = rsi;
    al = caml_page_table_lookup ();
    if ((al & 1) == 0) {
        goto label_0;
    }
    eax = caml_gc_phase;
    if (eax == 0) {
        goto label_3;
    }
    while ((bpl & 1) == 0) {
        rax = caml_young_end;
        if (rbp < rax) {
            rdx = caml_young_start;
            if (rbp <= rdx) {
                goto label_0;
            }
            if ((r12b & 1) == 0) {
                goto label_4;
            }
label_1:
            rax = .comment;
            if (rax >= *(0x00652440)) {
                goto label_5;
            }
label_2:
            *(rax) = rbx;
            rax += 8;
            *(0x00652438) = rax;
        }
label_0:
        rbx = *(rsp);
        rbp = *((rsp + 8));
        r12 = *((rsp + 0x10));
        return rax;
label_3:
        esi = 0;
        rdi = r12;
        rax = caml_darken ();
    }
    goto label_0;
label_4:
    if (rax <= r12) {
        goto label_1;
    }
    if (rdx < r12) {
        goto label_0;
    }
    goto label_1;
label_5:
    edi = caml_ref_table;
    caml_realloc_ref_table ();
    rax = .comment;
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421ae4 */
#include <stdint.h>
 
uint32_t unix_setgid (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    eax = setgid ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "setgid";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4096b0 */
#include <stdint.h>
 
void setgid (void) {
    setgid ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4201d8 */
#include <stdint.h>
 
int64_t unix_getpeername (int64_t arg1) {
    int64_t var_ch;
    int64_t var_10h;
    int64_t canary;
    rdi = arg1;
    rax = *(fs:0x28);
    *((rsp + 0x88)) = rax;
    eax = 0;
    *((rsp + 0xc)) = 0x70;
    rdx = rsp + 0xc;
    rsi = rsp + 0x10;
    rdi >>= 1;
    eax = getpeername ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "getpeername";
        uerror ();
    }
    rdi = rsp + 0x10;
    edx = 0xffffffff;
    esi = *((rsp + 0xc));
    alloc_sockaddr ();
    rdx = *((rsp + 0x88));
    rdx ^= *(fs:0x28);
    if (eax != 0xffffffff) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b990 */
#include <stdint.h>
 
uint64_t caml_ml_channel_size (int64_t arg1) {
    rdi = arg1;
    rdi = *((rdi + 8));
    rax = caml_channel_size ();
    rbx = rax;
    rax = 0x3fffffffffffffff;
    if (rbx > rax) {
        errno_location ();
        edi = 1;
        *(rax) = 0x4b;
        caml_sys_error ();
    }
    rax = rbx + rbx + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b910 */
#include <stdint.h>
 
uint64_t caml_channel_size (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rbx = rdi;
    edi = *(rdi);
    esi = 0;
    edx = 2;
    rax = lseek64 ();
    if (rax != -1) {
        rsi = *((rbx + 8));
        edi = *(rbx);
        edx = 0;
        rax = lseek64 ();
        if (rax == *((rbx + 8))) {
            goto label_0;
        }
    }
    edi = 1;
    caml_sys_error ();
label_0:
    rax = rbp;
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x419e30 */
#include <stdint.h>
 
int64_t camlBuffer_advance_139 (int64_t arg1) {
    rdi = arg1;
    do {
        rsi = rax;
        if (rsi >= rbx) {
            rax = rbx;
            return rax;
        }
        r8 = *((rdi + 0x18));
        rcx = rsi;
        rcx >>= 1;
        rax = *((r8 - 8));
        rax >>= 0xa;
        rax = rax*8 - 1;
        rdx = *((r8 + rax));
        rax -= rdx;
        if (rax <= rcx) {
            goto label_0;
        }
        rax = *((r8 + rcx));
        rax = rax + rax + 1;
        if (rax < 0xbf) {
            if (rax >= 0x75) {
                rax += 0xffffffffffffff7e;
                if (rax <= 0x33) {
                    goto label_1;
                }
            } else {
            } else {
            }
        }
        if (rax >= 0x61) {
            goto label_1;
        }
        if (rax >= 0xf7) {
            if (rax < 0x181) {
                goto label_2;
            }
            rax += 0xfffffffffffffe80;
            rax >>= 1;
            rdx = 0x00435330;
            rax = *((rdx + rax*4));
            rdx += rax;
            /* switch table (64 cases) at 0x435330 */
            rax = void (*rdx)() ();
        }
        if (rax != 0xc1) {
            goto label_1;
        }
label_2:
        rax = rsi;
        return rax;
label_1:
        rax = rsi;
        rax += 2;
    } while (1);
label_0:
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422ec8 */
#include <stdint.h>
 
uint64_t unix_umask (int64_t m) {
    rdi = m;
    rdi >>= 1;
    eax = umask (rdi);
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409710 */
#include <stdint.h>
 
void umask (void) {
    umask ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x420dd8 */
#include <stdint.h>
 
uint64_t unix_nice (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rax = errno_location ();
    rbx = rax;
    *(rax) = 0;
    rdi = rbp;
    rdi >>= 1;
    eax = nice ();
    if (eax == 0xffffffff) {
        if (*(rbx) == 0) {
            goto label_0;
        }
        esi = 0;
        rdi = "nice";
        uerror ();
    }
label_0:
    rax = (int64_t) eax;
    rax = rax + rax + 1;
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409110 */
#include <stdint.h>
 
void nice (void) {
    nice ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b0b0 */
#include <stdint.h>
 
int64_t camlPrintf_cont_t_395 (int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    *(rsp) = rax;
    *((rsp + 8)) = rdi;
    *((rsp + 0x10)) = rsi;
    rax = *((rsi + 0x58));
    if (rax != 1) {
        rax = 1;
        rdi = *(rbx);
        rax = void (*rdi)() ();
        rbx = rax;
        rax = *((rsp + 0x10));
        rdi = *((rax + 0x68));
        rax = *((rax + 0x78));
        caml_apply2 ();
    } else {
        rax = *((rsi + 0x78));
        rdi = *(rbx);
        void (*rdi)() ();
    }
    rdi = *((rsp + 0x10));
    rdi += 0xffffffffffffffa0;
    rax = *(rsp);
    rbx = *((rsp + 8));
    return camlPrintf_doprn_392 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421230 */
#include <stdint.h>
 
uint32_t unix_rename (const char * newpath, int64_t arg1) {
    rsi = newpath;
    rdi = arg1;
    rbx = rdi;
    eax = rename (rdi, rsi);
    if (eax == 0xffffffff) {
        rsi = rbx;
        rdi = "rename";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409770 */
#include <stdint.h>
 
void rename (void) {
    rename ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b970 */
#include <stdint.h>
 
uint64_t caml_ml_channel_size_64 (int64_t arg1) {
    rdi = arg1;
    rdi = *((rdi + 8));
    rax = caml_channel_size ();
    rdi = rax;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b7e0 */
#include <stdint.h>
 
int64_t caml_ml_seek_in_64 (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    rsi = arg2;
    rdi = arg1;
    rax = caml_channel_mutex_lock;
    rbp = caml_local_roots;
    rdx = rsp + 0x10;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 2;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x10)) = rbp;
    *((rsp + 0x30)) = rsp;
    *((rsp + 0x28)) = rdx;
    rbx = *((rdi + 8));
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rax = *(rsp);
    rdi = rbx;
    rsi = *((rax + 8));
    caml_seek_in ();
    rax = caml_channel_mutex_unlock;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    *(obj.caml_local_roots) = rbp;
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421726 */
#include <stdint.h>
 
int64_t unix_send (int64_t canary, int64_t arg_4010h, int64_t arg_4018h, int64_t arg_4020h, int64_t arg_4028h, int64_t arg_4030h, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x28)) = rbx;
    *((rsp - 0x20)) = rbp;
    *((rsp - 0x18)) = r12;
    *((rsp - 0x10)) = r13;
    *((rsp - 8)) = r14;
    r13 = rdi;
    r12 = rsi;
    rbx = rcx;
    rax = *(fs:0x28);
    *((rsp + 0x4008)) = rax;
    eax = 0;
    rsi = obj_msg_flag_table;
    rdi = r8;
    eax = caml_convert_flag_list ();
    r14d = eax;
    rbx >>= 1;
    eax = 0x4000;
    if (rbx > 0x4000) {
        rbx = rax;
    }
    rbp >>= 1;
    rsi = rbp + r12;
    ecx = 0x4000;
    rdx = rbx;
    rdi = rsp;
    memmove_chk ();
    caml_enter_blocking_section ();
    rdx = (int64_t) ebx;
    rdi >>= 1;
    eax = send (r13, rsp, rdx, r14d);
    ebx = eax;
    caml_leave_blocking_section ();
    if (ebx == 0xffffffff) {
        esi = 0;
        rdi = "send";
        uerror ();
    }
    rbx = (int64_t) ebx;
    rax = rbx + rbx + 1;
    rdx = *((rsp + 0x4008));
    rdx ^= *(fs:0x28);
    if (ebx != 0xffffffff) {
        stack_chk_fail ();
    }
    rbx = *((rsp + 0x4010));
    rbp = *((rsp + 0x4018));
    r12 = *((rsp + 0x4020));
    r13 = *((rsp + 0x4028));
    r14 = *((rsp + 0x4030));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422974 */
#include <stdint.h>
 
uint32_t unix_tcsendbreak (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    rdi >>= 1;
    eax = tcsendbreak ();
    if (eax == 0xffffffff) {
        esi = 0;
        rdi = "tcsendbreak";
        uerror ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408f70 */
#include <stdint.h>
 
void tcsendbreak (void) {
    tcsendbreak ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d420 */
#include <stdint.h>
 
int64_t camlPrintf_fun_710 (void) {
    rax = *((rbx + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a250 */
#include <stdint.h>
 
int64_t caml_curry4_1 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry4_2);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417f20 */
#include <stdint.h>
 
int64_t camlHashtbl_insert_bucket_96 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    do {
        if (rax == 1) {
            goto label_0;
        }
        *(rsp) = rbx;
        rsi = *((rax + 0x10));
        rdi = *((rax + 8));
        *((rsp + 8)) = rdi;
        rdi = *(rax);
        *((rsp + 0x10)) = rdi;
        rax = rsi;
        camlHashtbl_insert_bucket_96 ();
    } while (1);
    rax = *(rsp);
    rbx = *((rax + 0x18));
    rbx >>= 1;
    if (rbx != 0) {
        rbx = *((rax + 0x10));
        rdi = *(rbx);
        rax = *((rsp + 0x10));
        rax = void (*rdi)(uint64_t) (rbx);
        rax >>= 1;
        rcx = *((rsp + 0x18));
        __asm ("cqo");
        rax = rdx:rax / rcx;
        rdx = rdx:rax % rcx;
    } else {
        rax = *(reloc.caml_bucket_Division_by_zero);
        caml_raise_exn ();
    }
    rdx <<= 1;
    rdx++;
    rbx = *(rsp);
    rdi = *((rbx + 0x20));
    rax = *((rdi - 8));
    rax >>= 9;
    if (rax <= rdx) {
        goto label_1;
    }
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0xc00;
            rax = *((rsp + 0x10));
            *(rsi) = rax;
            rax = *((rsp + 8));
            *((rsi + 8)) = rax;
            rbx = *((rbx + 0x20));
            rax = *((rbx - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_2;
            }
            rax = *((rbx + rdx*4 - 4));
            *((rsi + 0x10)) = rax;
            rdi = rdi + rdx*4 - 4;
            caml_modify ();
            rax = 1;
            return rax;
label_0:
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_ml_array_bound_error ();
label_1:
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a2a0 */
#include <stdint.h>
 
int64_t caml_curry4_2 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry4_3);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a2f0 */
#include <stdint.h>
 
int64_t caml_curry4_3 (void) {
    rsi = rax;
    rcx = *((rbx + 0x18));
    rax = *((rcx + 0x18));
    rdx = *((rax + 0x18));
    rdi = *((rbx + 0x10));
    rbx = *((rcx + 0x10));
    rax = *((rax + 0x10));
    rcx = *((rdx + 0x10));
    return void (*rcx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40981c */
#include <stdint.h>
 
int64_t call_gmon_start (void) {
    rax = *(reloc.__gmon_start__);
    if (rax != 0) {
        void (*rax)() ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409840 */
#include <stdint.h>
 
int64_t do_global_dtors_aux (void) {
    if (*(obj.completed.6338) != 0) {
        goto label_0;
    }
    ebx = obj.__DTOR_END__;
    rax = *(obj.dtor_idx.6340);
    rbx -= obj.__DTOR_LIST__;
    rbx >>= 3;
    rbx--;
    if (rax >= rbx) {
        goto label_1;
    }
    do {
        rax++;
        *(obj.dtor_idx.6340) = rax;
        uint64_t (*rax*8 + obj.__DTOR_LIST__)() ();
        rax = *(obj.dtor_idx.6340);
    } while (rax < rbx);
label_1:
    *(obj.completed.6338) = 1;
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4098b0 */
#include <stdint.h>
 
int32_t frame_dummy (void) {
    if (*(obj.__JCR_LIST__) != 0) {
        eax = 0;
        if (rax == 0) {
            goto label_0;
        }
        edi = obj.__JCR_LIST__;
        void (*rax)() ();
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4350a0 */
#include <stdint.h>
 
int64_t do_global_ctors_aux (void) {
    rax = .ctors;
    if (rax == -1) {
        goto label_0;
    }
    ebx = .ctors;
    do {
        rbx -= 8;
        void (*rax)() ();
        rax = *(rbx);
    } while (rax != -1);
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41fcf0 */
#include <stdint.h>
 
int64_t alloc_host_entry (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    rdi = arg1;
    rbx = rdi;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x50)) = 1;
    *((rsp + 0x48)) = 1;
    *((rsp + 0x40)) = 1;
    rax = *(reloc.caml_local_roots);
    rdx = *(rax);
    *(rsp) = rdx;
    *(rax) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 4;
    rax = rsp + 0x58;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x20)) = rax;
    rax = rsp + 0x48;
    *((rsp + 0x28)) = rax;
    rax = rsp + 0x40;
    *((rsp + 0x30)) = rax;
    rdi = *(rdi);
    rax = caml_copy_string ();
    *((rsp + 0x58)) = rax;
    rdi = *((rbx + 8));
    if (rdi != 0) {
        rax = caml_copy_string_array ();
        *((rsp + 0x50)) = rax;
    } else {
        rax = *(reloc.caml_atom_table);
        rax = rax + 8;
        *((rsp + 0x50)) = rax;
    }
    eax = *((rbx + 0x14));
    *(obj.entry_h_length) = eax;
    rsi = *((rbx + 0x18));
    rdi = sym_alloc_one_addr;
    rax = caml_alloc_array ();
    *((rsp + 0x48)) = rax;
    esi = 0;
    edi = 4;
    caml_alloc_small ();
    rdx = *((rsp + 0x58));
    *(rax) = rdx;
    rdx = rax;
    rcx = *((rsp + 0x50));
    *((rax + 8)) = rcx;
    ecx = *((rbx + 0x10));
    if (ecx != 1) {
        cl = (ecx != 2) ? 1 : 0;
        ecx = (int32_t) cl;
        rcx = rcx + rcx + 3;
        *((rax + 0x10)) = rcx;
    } else {
        *((rax + 0x10)) = 1;
    }
    rcx = *((rsp + 0x48));
    *((rdx + 0x18)) = rcx;
    rcx = *(rsp);
    rdx = *(reloc.caml_local_roots);
    *(rdx) = rcx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ff7e */
#include <stdint.h>
 
int64_t alloc_one_addr (void * s2) {
    void * s1;
    int64_t canary;
    rdi = s2;
    rax = *(fs:0x28);
    *((rsp + 0x28)) = rax;
    eax = 0;
    if (*(obj.entry_h_length) == 0x10) {
        rbx = rsp + 0x10;
        memmove (rbx, rdi, 0x10);
        rdi = rbx;
        alloc_inet6_addr ();
    } else {
        memmove (rsp, rdi, 4);
        rdi = rsp;
        alloc_inet_addr ();
    }
    rdx = *((rsp + 0x28));
    rdx ^= *(fs:0x28);
    if (*(obj.entry_h_length) != 0x10) {
        stack_chk_fail ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4212a8 */
#include <stdint.h>
 
int64_t fdlist_to_fdset (signed int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r8 = rdi;
    ecx = 0x10;
    eax = 0;
    rdi = rsi;
    do {
        *(rdi) = rax;
        rcx--;
        rdi += 8;
    } while (rcx != 0);
    if (r8 == 1) {
        goto label_0;
    }
    r9d = 1;
    do {
        rax = *(r8);
        rax >>= 1;
        edi = rax + 0x3f;
        __asm ("cmovns edi, eax");
        edi >>= 6;
        rdi = (int64_t) edi;
        r10d = eax;
        r10d >>= 0x1f;
        r10d >>= 0x1a;
        ecx = rax + r10;
        ecx &= 0x3f;
        ecx -= r10d;
        r10 = r9;
        r10 <<= cl;
        *((rsi + rdi*8)) |= r10;
        if (eax > *(rdx)) {
            *(rdx) = eax;
        }
        r8 = *((r8 + 8));
    } while (r8 != 1);
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42130d */
#include <stdint.h>
 
int64_t fdset_to_fdlist (fd_set * arg2, uint32_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_40h;
    uint32_t var_48h;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x40)) = 1;
    rax = *(reloc.caml_local_roots);
    rdx = *(rax);
    *(rsp) = rdx;
    *(rax) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 2;
    rax = rsp + 0x48;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x40;
    *((rsp + 0x20)) = rax;
    if (rdi == 1) {
        goto label_0;
    }
    *((rsp + 0x48)) = rdi;
    do {
        rbx = *(rdi);
        rbx >>= 1;
        edx = rbx + 0x3f;
        __asm ("cmovns edx, ebx");
        edx >>= 6;
        rdx = (int64_t) edx;
        eax = ebx;
        eax >>= 0x1f;
        eax >>= 0x1a;
        ecx = rbx + rax;
        ecx &= 0x3f;
        ecx -= eax;
        eax = ecx;
        rdx = *((rbp + rdx*8));
        if (((rdx >> rax) & 1) < 0) {
            esi = 0;
            edi = 2;
            caml_alloc_small ();
            rbx = (int64_t) ebx;
            rdx = rbx + rbx + 1;
            *(rax) = rdx;
            rdx = *((rsp + 0x40));
            *((rax + 8)) = rdx;
            *((rsp + 0x40)) = rax;
        }
        rax = *((rsp + 0x48));
        rdi = *((rax + 8));
        if (rdi == 1) {
            goto label_0;
        }
        *((rsp + 0x48)) = rdi;
    } while (1);
label_0:
    rdx = *(rsp);
    rax = *(reloc.caml_local_roots);
    *(rax) = rdx;
    rax = *((rsp + 0x40));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423560 */
#include <stdint.h>
 
int64_t scanmult (int64_t arg2, int64_t arg1) {
    uint32_t var_8h;
    int64_t var_fh;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x20)) = rbx;
    *((rsp - 0x18)) = rbp;
    rbx = rdi;
    *((rsp - 0x10)) = r12;
    *((rsp - 8)) = r13;
    r12 = rsp + 0xf;
    rbp = rsp + 8;
    eax = 0;
    r13 = rsi;
    esi = "=%u%c";
    *((rsp + 0xf)) = 0x20;
    rcx = r12;
    rdx = rbp;
    eax = isoc99_sscanf ();
    eax = 0;
    rcx = r12;
    rdx = rbp;
    esi = "=0x%x%c";
    rdi = rbx;
    isoc99_sscanf ();
    eax = *((rsp + 0xf));
    if (al == 0x4d) {
        goto label_1;
    }
    if (al == 0x6b) {
        goto label_2;
    }
    if (al == 0x47) {
        goto label_3;
    }
    rax = *((rsp + 8));
    *(r13) = rax;
    do {
label_0:
        rbx = *((rsp + 0x18));
        rbp = *((rsp + 0x20));
        r12 = *((rsp + 0x28));
        r13 = *((rsp + 0x30));
        return rax;
label_3:
        rax = *((rsp + 8));
        rax <<= 0x1e;
        *(r13) = rax;
    } while (1);
label_2:
    rax = *((rsp + 8));
    rax <<= 0xa;
    *(r13) = rax;
    goto label_0;
label_1:
    rax = *((rsp + 8));
    rax <<= 0x14;
    *(r13) = rax;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408ed0 */
#include <stdint.h>
 
void isoc99_sscanf (void) {
    isoc99_sscanf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424560 */
#include <stdint.h>
 
int64_t caml_iterate_global_roots (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = *((rsi + 8));
    if (rbx == 0) {
        goto label_0;
    }
    do {
        rax = *(rbx);
        rsi = *(rbx);
        rdi = *(rax);
        void (*rbp)() ();
        rbx = *((rbx + 8));
    } while (rbx != 0);
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4245d0 */
#include <stdint.h>
 
int64_t caml_insert_global_root (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = rdi;
    rbx = rsi;
    r8d = *((rdi + 0x90));
    if (r8d < 0) {
        goto label_1;
    }
    esi = r8d;
    rcx = (int64_t) r8d;
    while (*(rax) < rbx) {
        rdx = rax;
label_0:
        rax = *((rdx + rcx*8 + 8));
        if (rax == 0) {
            goto label_2;
        }
    }
label_2:
    esi--;
    *((rsp + rcx*8)) = rdx;
    if (esi != 0xffffffff) {
        rcx = (int64_t) esi;
        goto label_0;
    }
label_1:
    rax = *((rdx + 8));
    if (rax != 0) {
        if (*(rax) == rbx) {
            goto label_3;
        }
    }
    eax = random_seed;
    ebp = 0;
    ecx = 0x10;
    edx = eax * 0x10dcd;
    edx += 0x6255;
    eax = edx;
    *(obj.random_seed) = edx;
    eax &= 0xc0000000;
    if (eax != 0xc0000000) {
        goto label_4;
    }
    do {
        edx <<= 2;
        ebp++;
        ecx = edx;
        ecx &= 0xc0000000;
    } while (ecx == 0xc0000000);
    rax = (int64_t) ebp;
    rcx = rax*8 + 0x10;
label_4:
    if (r8d >= ebp) {
        goto label_5;
    }
    eax = r8 + 1;
    if (ebp < eax) {
        goto label_6;
    }
    do {
        rdx = (int64_t) eax;
        eax++;
        *((rsp + rdx*8)) = rdi;
    } while (ebp >= eax);
label_6:
    *((rdi + 0x90)) = ebp;
label_5:
    rdi = rcx;
    caml_stat_alloc ();
    ecx = 0;
    *(rax) = rbx;
    edx = 0;
    r8 = rsp;
    do {
        rbx = *((r8 + rcx));
        rsi = (int64_t) edx;
        edx++;
        rdi = *((rbx + rsi*8 + 8));
        *((rax + rcx + 8)) = rdi;
        rcx += 8;
        *((rbx + rsi*8 + 8)) = rax;
    } while (ebp >= edx);
label_3:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4247a0 */
#include <stdint.h>
 
int64_t caml_delete_global_root (uint32_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = rdi;
    rbx = rdi;
    r8d = *((rdi + 0x90));
    if (r8d < 0) {
        goto label_3;
    }
    edi = r8d;
    rcx = (int64_t) r8d;
    while (*(rax) < rsi) {
        rdx = rax;
label_0:
        rax = *((rdx + rcx*8 + 8));
        if (rax == 0) {
            goto label_4;
        }
    }
label_4:
    edi--;
    *((rsp + rcx*8)) = rdx;
    if (edi != 0xffffffff) {
        rcx = (int64_t) edi;
        goto label_0;
    }
label_3:
    rdi = *((rdx + 8));
    if (rdi != 0) {
        if (*(rdi) == rsi) {
            goto label_5;
        }
    }
label_2:
    return rax;
label_5:
    if (r8d < 0) {
        goto label_6;
    }
    edx = 0;
    eax = 0;
    r9 = rsp;
    while (*((rcx + rsi*8 + 8)) != rdi) {
        eax++;
        rdx += 8;
        if (r8d < eax) {
            goto label_6;
        }
label_1:
        rcx = *((r9 + rdx));
        rsi = (int64_t) eax;
    }
    r10 = *((rdi + rdx + 8));
    eax++;
    rdx += 8;
    *((rcx + rsi*8 + 8)) = r10;
    if (r8d >= eax) {
        goto label_1;
    }
label_6:
    caml_stat_free ();
    eax = *((rbx + 0x90));
    if (eax <= 0) {
        goto label_2;
    }
    rdx = (int64_t) eax;
    if (*((rbx + rdx*8 + 8)) == 0) {
        goto label_7;
    }
    goto label_2;
    do {
        rdx = (int64_t) eax;
        if (*((rbx + rdx*8 + 8)) != 0) {
            goto label_8;
        }
label_7:
        eax--;
    } while (eax != 0);
    *((rbx + 0x90)) = 0;
    return rax;
label_8:
    *((rbx + 0x90)) = eax;
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424ab0 */
#include <stdint.h>
 
void caml_enter_blocking_section_default (void) {
    *(obj.caml_async_signal_mode) = 1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424ac0 */
#include <stdint.h>
 
void caml_leave_blocking_section_default (void) {
    *(obj.caml_async_signal_mode) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424ad0 */
#include <stdint.h>
 
int64_t caml_try_leave_blocking_section_default (void) {
    rax = 0;
    tmp_0 = obj.caml_async_signal_mode;
    obj.caml_async_signal_mode = rax;
    rax = tmp_0;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425040 */
#include <stdint.h>
 
uint64_t segv_handler (int64_t arg3) {
    int64_t var_8h;
    int64_t var_88h;
    int64_t var_a0h;
    rdx = arg3;
    rbx = *((rdx + 0xd8));
    if ((bl & 7) == 0) {
        rsi = rsp + 0xa0;
        edi = 3;
        eax = getrlimit64 ();
        if (eax != 0) {
            goto label_0;
        }
        rax = system_stack_top;
        if (rbx >= rax) {
            goto label_0;
        }
        rax -= *((rsp + 0xa0));
        rax -= 0x2000;
        if (rbx < rax) {
            goto label_0;
        }
        rdi = *((rbp + 0xa8));
        if (rdi >= *(obj.caml_code_area_start)) {
            if (rdi <= *(obj.caml_code_area_end)) {
                goto label_1;
            }
        }
        al = caml_page_table_lookup ();
        if ((al & 8) != 0) {
            goto label_1;
        }
    }
label_0:
    rdi = rsp + 8;
    *(rsp) = 0;
    *((rsp + 0x88)) = 0;
    sigemptyset ();
    sigaction (0xb, rsp, 0);
    return rax;
label_1:
    rax = *((rbp + 0x58));
    *(obj.caml_exception_pointer) = rax;
    rax = *((rbp + 0x60));
    *(obj.caml_young_ptr) = rax;
    return caml_raise_stack_overflow ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425110 */
#include <stdint.h>
 
uint64_t handle_signal (uint32_t arg1) {
    uint32_t var_8h_2;
    rdi = arg1;
    if (edi > 0x40) {
        return;
    }
    eax = uint64_t (*caml_try_leave_blocking_section_hook)(uint64_t) (edi);
    edi = *((rsp + 8));
    if (eax == 0) {
        void (*0x424a80)() ();
    }
    esi = 1;
    caml_execute_signal ();
    rax = caml_enter_blocking_section_hook;
    return void (*rax)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4253f0 */
#include <stdint.h>
 
int64_t allocate_block (uint32_t arg4, uint32_t arg3, uint32_t arg2, uint32_t arg1) {
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rax = *((rcx - 8));
    r8 = rdi + 1;
    rax >>= 0xa;
    if (rax >= r8) {
        goto label_2;
    }
    r8 = rax;
    r8 = ~r8;
    *(obj.caml_fl_cur_size) += r8;
    r8 = *(rcx);
    *(rdx) = r8;
    while (1) {
        *((rcx - 8)) = 0;
        r8 = caml_allocation_policy;
        if (r8 != 1) {
            rax -= rdi;
            goto label_3;
label_2:
            rax -= rdi;
            *(obj.caml_fl_cur_size) -= rdi;
            rsi = rax;
            rsi <<= 0xa;
            rsi += 0x200;
            *((rcx - 8)) = rsi;
            r8 = caml_allocation_policy;
label_3:
            if (r8 == 0) {
                *(obj.fl_prev) = rdx;
            }
label_1:
            rax = rcx + rax*8;
            return rax;
        }
        r8d = flp_size;
        r9d = rsi + 1;
        if (r9d < r8d) {
            r9 = (int64_t) r9d;
            if (*((r9*8 + obj.flp)) == rcx) {
                goto label_4;
            }
        }
        r8d--;
        if (r8d == esi) {
            goto label_5;
        }
label_0:
        rax -= rdi;
        rax = rcx + rax*8;
        return rax;
        *(obj.caml_fl_merge) = rdx;
    }
label_5:
    r8d = 0;
    *(obj.flp_size) = esi;
    if (rdx == 0x64de30) {
        rdx = r8;
    }
    *(obj.beyond) = rdx;
    goto label_0;
label_4:
    *((r9*8 + obj.flp)) = rdx;
    rax -= rdi;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4260c0 */
#include <stdint.h>
 
void start_cycle (void) {
    edx = 0;
    esi = "Starting new major GC cycle\n";
    edi = 1;
    caml_gc_message ();
    caml_darken_all_roots ();
    *(obj.caml_gc_phase) = 0;
    *(obj.caml_gc_subphase) = 0xa;
    *(obj.markhp) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4253a0 */
#include <stdint.h>
 
int32_t caml_gc_message (uint32_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    if (edi >= 0) {
        rdi = (int64_t) edi;
        if ((*(obj.caml_verb_gc) & rdi) == 0) {
            goto label_0;
        }
    }
    rdi = stderr;
    rcx = rdx;
    eax = 0;
    rdx = rsi;
    esi = 1;
    fprintf_chk ();
    rdi = stderr;
    void (*0x4097c0)() ();
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424200 */
#include <stdint.h>
 
void caml_darken_all_roots (void) {
    edi = caml_darken;
    return caml_do_roots ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x426100 */
#include <stdint.h>
 
int64_t realloc_gray_vals (void) {
    rax = caml_stat_heap_size;
    rdx = gray_vals_size;
    rcx = rax + 0x7f;
    __asm ("cmovs rax, rcx");
    rax >>= 7;
    if (rax > rdx) {
        goto label_0;
    }
    rdx >>= 1;
    *(obj.heap_is_pure) = 0;
    rdx <<= 3;
    rdx += *(obj.gray_vals);
    *(obj.gray_vals_cur) = rdx;
    do {
        return rax;
label_0:
        rdx <<= 3;
        esi = "Growing gray_vals to %luk bytes\n";
        edi = 8;
        rdx >>= 9;
        caml_gc_message ();
        rsi <<= 4;
        rax = realloc (*(obj.gray_vals), *(obj.gray_vals_size));
        if (rax != 0) {
            rdx = gray_vals_size;
            *(obj.gray_vals) = rax;
            rcx = rax + rdx*8;
            *(obj.gray_vals_cur) = rcx;
            rcx = rdx + rdx;
            rdx <<= 4;
            rax += rdx;
            *(obj.gray_vals_size) = rcx;
            *(obj.gray_vals_end) = rax;
            return rax;
        }
        edx = 0;
        esi = "No room for growing gray_vals\n";
        edi = 8;
        caml_gc_message ();
        rax = gray_vals;
        *(obj.heap_is_pure) = 0;
        *(obj.gray_vals_cur) = rax;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409640 */
#include <stdint.h>
 
void realloc (void) {
    realloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4261f0 */
#include <stdint.h>
 
int64_t mark_slice (int64_t arg1) {
    int64_t var_sp_8h;
    int64_t var_10h;
    uint32_t var_18h;
    rdi = arg1;
    rdx = rdi;
    esi = "Marking %ld words\n";
    rbx = rdi;
    edi = 0x40;
    caml_gc_message ();
    rdx = *(obj.caml_gc_subphase);
    esi = "Subphase = %ld\n";
    edi = 0x40;
    caml_gc_message ();
    r14 = gray_vals_cur;
label_3:
    if (rbx <= 0) {
        goto label_5;
    }
label_2:
    if (*(obj.gray_vals) >= r14) {
        goto label_10;
    }
    r14 -= 8;
    r13 = *(r14);
    rax = *((r13 - 8));
    rdx = *((r13 - 8));
    r15 = rax;
    dh |= 3;
    r15 >>= 0xa;
    *((r13 - 8)) = rdx;
    if (al > 0xfa) {
        goto label_11;
    }
    if (r15 == 0) {
        goto label_11;
    }
    ebp = 0;
    while ((r12b & 1) != 0) {
label_0:
        rbp++;
        if (r15 <= rbp) {
            goto label_11;
        }
label_1:
        r12 = *((r13 + rbp*8));
    }
    rdi = r12;
    al = caml_page_table_lookup ();
    if ((al & 1) == 0) {
        goto label_0;
    }
    rdx = *((r12 - 8));
    eax = (int32_t) dl;
    if (eax == 0xfa) {
        goto label_12;
    }
    if (eax == 0xf9) {
        goto label_13;
    }
label_4:
    if ((dh & 3) != 0) {
        goto label_0;
    }
    dh &= 0xfc;
    dh |= 1;
    *((r12 - 8)) = rdx;
    *(r14) = r12;
    r14 += 8;
    if (r14 < *(obj.gray_vals_end)) {
        goto label_0;
    }
    rbp++;
    *(obj.gray_vals_cur) = r14;
    realloc_gray_vals ();
    r14 = gray_vals_cur;
    if (r15 > rbp) {
        goto label_1;
    }
label_11:
    r15 = ~r15;
    rbx = r15 + rbx;
    if (rbx > 0) {
        goto label_2;
    }
label_5:
    *(obj.gray_vals_cur) = r14;
    return rax;
label_10:
    rax = markhp;
    if (rax == 0) {
        goto label_14;
    }
    if (rax == *(obj.limit)) {
        goto label_15;
    }
    rdx = *(rax);
    rcx = *(rax);
    ecx &= 0x300;
    while (1) {
        rdx >>= 0xa;
        rax = rax + rdx*8 + 8;
        *(obj.markhp) = rax;
        goto label_3;
label_12:
        rcx = *(r12);
        if ((cl & 1) == 0) {
            goto label_16;
        }
label_6:
        *((r13 + rbp*8)) = rcx;
        goto label_4;
        rdx = rax + 8;
        *(r14) = rdx;
        r14 += 8;
        rdx = *(rax);
    }
label_14:
    eax = heap_is_pure;
    if (eax == 0) {
        goto label_17;
    }
    eax = caml_gc_subphase;
    if (eax == 0xb) {
        goto label_18;
    }
    if (eax <= 0xb) {
        goto label_19;
    }
    if (eax == 0xc) {
        goto label_20;
    }
    if (eax != 0xd) {
        goto label_3;
    }
    rax = caml_heap_start;
    *(obj.gray_vals_cur) = r14;
    *(obj.caml_gc_sweep_hp) = rax;
    caml_fl_init_merge ();
    rax = caml_heap_start;
    *(obj.caml_gc_phase) = 1;
    *(obj.chunk) = rax;
    *(obj.caml_gc_sweep_hp) = rax;
    rax += *((rax - 0x10));
    *(obj.limit) = rax;
    rax = caml_fl_cur_size;
    *(obj.caml_fl_size_at_phase_change) = rax;
    goto label_5;
label_13:
    rdx >>= 0xa;
    rdx <<= 3;
    r12 -= rdx;
    rdx = *((r12 - 8));
    goto label_4;
label_15:
    rax = chunk;
    rax = *((rax - 8));
    *(obj.chunk) = rax;
    if (rax == 0) {
        goto label_21;
    }
    do {
        *(obj.markhp) = rax;
        rax += *((rax - 0x10));
        *(obj.limit) = rax;
        goto label_3;
label_17:
        rax = caml_heap_start;
        *(obj.heap_is_pure) = 1;
        *(obj.chunk) = rax;
    } while (1);
label_16:
    rdi = rcx;
    *((rsp + 8)) = rdx;
    *((rsp + 0x10)) = rcx;
    al = caml_page_table_lookup ();
    rdx = *((rsp + 8));
    rcx = *((rsp + 0x10));
    if ((al & 7) == 0) {
        goto label_4;
    }
    eax = *((rcx - 8));
    if (al == 0xfa) {
        goto label_4;
    }
    if (al == 0xf6) {
        goto label_4;
    }
    if (al != 0xfd) {
        goto label_6;
    }
    goto label_4;
label_19:
    if (eax != 0xa) {
        goto label_3;
    }
    *(obj.caml_gc_subphase) = 0xb;
    *(obj.weak_prev) = 0x657f08;
    goto label_3;
label_21:
    *(obj.markhp) = 0;
    goto label_3;
label_20:
    rdx = weak_prev;
    rax = *(rdx);
    if (rax == 0) {
        goto label_22;
    }
    if ((*((rax - 8)) & 0x300) != 0) {
        goto label_23;
    }
    rax = *(rax);
    *(rdx) = rax;
label_8:
    rbx--;
    goto label_3;
label_18:
    rax = weak_prev;
    r13 = *(rax);
    if (r13 == 0) {
        goto label_24;
    }
    rax = *((r13 - 8));
    rax >>= 0xa;
    *((rsp + 0x18)) = rax;
    if (rax <= 1) {
        goto label_25;
    }
    r12d = 1;
label_7:
    rbp = *((r13 + r12*8));
    if (rbp == *(obj.caml_weak_none)) {
        goto label_9;
    }
    if ((bpl & 1) == 0) {
        goto label_26;
    }
    goto label_9;
    do {
        r15 = rbp - 8;
        if (*((rbp - 8)) != 0xfa) {
            goto label_27;
        }
        rbp = *(rbp);
        if ((bpl & 1) != 0) {
            goto label_27;
        }
        rdi = rbp;
        al = caml_page_table_lookup ();
        if ((al & 7) == 0) {
            goto label_27;
        }
        eax = *((rbp - 8));
        if (al == 0xfa) {
            goto label_27;
        }
        if (al == 0xf6) {
            goto label_27;
        }
        if (al == 0xfd) {
            goto label_27;
        }
        *((r13 + r12*8)) = rbp;
        if (*(obj.caml_weak_none) == rbp) {
            goto label_9;
        }
label_26:
        rdi = rbp;
        al = caml_page_table_lookup ();
    } while ((al & 1) != 0);
label_9:
    r12++;
    if (*((rsp + 0x18)) > r12) {
        goto label_7;
    }
label_25:
    rax = *((rsp + 0x18));
    *(obj.weak_prev) = r13;
    rax = ~rax;
    rbx += rax;
    goto label_3;
label_24:
    *(obj.caml_gc_subphase) = 0xc;
    *(obj.weak_prev) = 0x657f08;
    goto label_3;
label_23:
    *(obj.weak_prev) = rax;
    goto label_8;
label_27:
    if ((*(r15) & 0x300) != 0) {
        goto label_9;
    }
    rax = caml_weak_none;
    *((r13 + r12*8)) = rax;
    goto label_9;
label_22:
    *(obj.gray_vals_cur) = r14;
    caml_final_update ();
    r14 = gray_vals_cur;
    *(obj.caml_gc_subphase) = 0xd;
    goto label_3;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x426710 */
#include <stdint.h>
 
int64_t sweep_slice (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    esi = "Sweeping %ld words\n";
    rbx = rdi;
    edi = 0x40;
    caml_gc_message ();
label_0:
    if (rbx <= 0) {
        goto label_2;
    }
    do {
        rax = caml_gc_sweep_hp;
        if (rax >= *(obj.limit)) {
            goto label_3;
        }
        rdx = *(rax);
        rcx = *(rax);
        rcx >>= 0xa;
        rsi = rcx;
        rcx = rax + rcx*8 + 8;
        rsi = ~rsi;
        *(obj.caml_gc_sweep_hp) = rcx;
        rcx = rdx;
        rbx += rsi;
        ecx &= 0x300;
        if (ecx != 0) {
            goto label_4;
        }
        rbp = rax + 8;
        if (dl == 0xff) {
            goto label_5;
        }
label_1:
        rdi = rbp;
        rax = caml_fl_merge_block ();
        *(obj.caml_gc_sweep_hp) = rax;
    } while (rbx > 0);
label_2:
    return rax;
label_3:
    rax = chunk;
    rax = *((rax - 8));
    *(obj.chunk) = rax;
    if (rax != 0) {
        *(obj.caml_gc_sweep_hp) = rax;
        rax += *((rax - 0x10));
        *(obj.limit) = rax;
        goto label_0;
label_4:
        if (rcx != 0x200) {
            dh &= 0xfc;
            *(rax) = rdx;
            goto label_0;
        }
        rax += 8;
        *(obj.caml_fl_merge) = rax;
        goto label_0;
    }
    *(obj.caml_stat_major_collections)++;
    *(obj.caml_gc_phase) = 2;
    return rax;
label_5:
    rax = *((rax + 8));
    rax = *((rax + 8));
    if (rax == 0) {
        goto label_1;
    }
    rdi = rbp;
    void (*rax)() ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427910 */
#include <stdint.h>
 
uint64_t caml_page_table_modify (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_ch;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r13d = esi;
    r12d = edx;
    rbx = rdi;
    r15 = .comment;
    rbp = caml_page_table;
    rax = r15 + r15;
    if (rax >= rbp) {
        goto label_3;
    }
label_1:
    rax = rbx;
    rdx = 0x9e3779b97f4a7c16;
    ecx = .comment;
    rax >>= 0xc;
    rdi = .comment;
    rax *= rdx;
    rax >>= cl;
    rcx = rdi + rax*8;
    rdx = *(rcx);
    if (rdx == 0) {
        goto label_4;
    }
    rsi = rdx;
    rsi ^= rbx;
    if ((rsi & 0xfffffffffffff000) == 0) {
        goto label_5;
    }
    rbp = .comment;
    while (rdx != 0) {
        rsi = rdx;
        rsi ^= rbx;
        if ((rsi & 0xfffffffffffff000) == 0) {
            goto label_5;
        }
        rax++;
        rax &= rbp;
        rcx = rdi + rax*8;
        rdx = *(rcx);
    }
label_4:
    r12 = (int64_t) r12d;
    eax = 0;
    r12 |= rbx;
    *(rcx) = r12;
    *(0x006524d8)++;
label_2:
    return rax;
label_5:
    r13d = ~r13d;
    r12 = (int64_t) r12d;
    eax = 0;
    r13 = (int64_t) r13d;
    rdx &= r13;
    rdx |= r12;
    *(rcx) = rdx;
    return rax;
label_3:
    eax = .comment;
    rdx = rbp;
    esi = "Growing page table to %lu entries\n";
    edi = 8;
    r14 = .comment;
    *((rsp + 0xc)) = eax;
    caml_gc_message ();
    rdx = rbp + rbp;
    rdi = rdx;
    *(rsp) = rdx;
    rax = calloc (rdi, 8);
    rdx = *(rsp);
    if (rax == 0) {
        goto label_6;
    }
    ecx = *((rsp + 0xc));
    *(obj.caml_page_table) = rdx;
    rdx--;
    *(0x006524d0) = rdx;
    *(0x006524d8) = r15;
    *(0x006524e0) = rax;
    ecx--;
    *(0x006524c8) = ecx;
    if (rbp == 0) {
        goto label_7;
    }
    edi = 0;
    r9 = 0x9e3779b97f4a7c16;
label_0:
    r8 = *((r14 + rdi*8));
    if (r8 == 0) {
        goto label_8;
    }
    rsi = r8;
    rsi >>= 0xc;
    rsi *= r9;
    rsi >>= cl;
    r10 = rax + rsi*8;
    if (*(r10) == 0) {
        goto label_9;
    }
    do {
        rsi++;
        rsi &= rdx;
        r10 = rax + rsi*8;
    } while (*(r10) != 0);
label_9:
    *(r10) = r8;
label_8:
    rdi++;
    if (rbp > rdi) {
        goto label_0;
    }
label_7:
    free (r14);
    goto label_1;
label_6:
    edx = 0;
    esi = "No room for growing page table\n";
    edi = 8;
    eax = caml_gc_message ();
    eax |= 0xffffffff;
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428560 */
#include <stdint.h>
 
void compare_stack_overflow (void) {
    edx = 0;
    esi = 0x4364c0;
    edi = 4;
    caml_gc_message ();
    compare_free_stack ();
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428c80 */
#include <stdint.h>
 
int32_t int32_cmp (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    edx = *((rsi + 8));
    ecx = *((rdi + 8));
    eax = 0;
    al = (ecx > edx) ? 1 : 0;
    dl = (ecx < edx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428ca0 */
#include <stdint.h>
 
int64_t int32_hash (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428ce0 */
#include <stdint.h>
 
int32_t int64_cmp (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = *((rsi + 8));
    rcx = *((rdi + 8));
    eax = 0;
    al = (rcx > rdx) ? 1 : 0;
    dl = (rcx < rdx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428d00 */
#include <stdint.h>
 
int64_t int64_hash (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428d50 */
#include <stdint.h>
 
int32_t nativeint_cmp (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = *((rsi + 8));
    rcx = *((rdi + 8));
    eax = 0;
    al = (rcx > rdx) ? 1 : 0;
    dl = (rcx < rdx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428d70 */
#include <stdint.h>
 
int64_t nativeint_hash (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428dc0 */
#include <stdint.h>
 
uint32_t int32_deserialize (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    eax = caml_deserialize_sint_4 ();
    *(rbx) = eax;
    eax = 4;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42df60 */
#include <stdint.h>
 
int64_t caml_deserialize_sint_4 (void) {
    rax = intern_src;
    rdx = rax + 4;
    *(obj.intern_src) = rdx;
    rax = *(rax);
    esi = *((rdx - 1));
    rax <<= 0x18;
    rsi = rax + rsi;
    eax = *((rdx - 3));
    edx = *((rdx - 2));
    eax <<= 0x10;
    edx <<= 8;
    rcx = (int64_t) eax;
    rdx = (int64_t) edx;
    rax = rsi + rcx;
    rax += rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428de0 */
#include <stdint.h>
 
uint64_t int64_deserialize (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    rax = caml_deserialize_sint_8 ();
    *(rbx) = rax;
    eax = 8;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e0f0 */
#include <stdint.h>
 
int64_t caml_deserialize_sint_8 (void) {
    int64_t var_8h;
    esi = 1;
    rdi = rsp + 8;
    caml_deserialize_block_8 ();
    rax = *((rsp + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e070 */
#include <stdint.h>
 
int64_t caml_deserialize_block_8 (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    r10 = intern_src;
    if (rsi <= 0) {
        goto label_0;
    }
    rax = r10;
    rdx = rsi;
    do {
        r9d = *((rax + 7));
        r8d = *(rax);
        ecx = *((rax + 1));
        *(rdi) = r9b;
        r9d = *((rax + 6));
        *((rdi + 7)) = r8b;
        *((rdi + 6)) = cl;
        *((rdi + 1)) = r9b;
        r9d = *((rax + 5));
        r8d = *((rax + 2));
        ecx = *((rax + 3));
        *((rdi + 2)) = r9b;
        r9d = *((rax + 4));
        rax += 8;
        *((rdi + 5)) = r8b;
        *((rdi + 4)) = cl;
        *((rdi + 3)) = r9b;
        rdi += 8;
        rdx--;
    } while (rdx != 0);
    r10 = r10 + rsi*8;
label_0:
    *(obj.intern_src) = r10;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428e00 */
#include <stdint.h>
 
uint64_t nativeint_deserialize (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    eax = caml_deserialize_uint_1 ();
    if (eax != 1) {
        if (eax == 2) {
            goto label_0;
        }
        edi = "input_value: ill-formed native integer";
        caml_deserialize_error ();
    }
    rax = caml_deserialize_sint_4 ();
    rax = (int64_t) eax;
    *(rbx) = rax;
    eax = 8;
    return rax;
label_0:
    rax = caml_deserialize_sint_8 ();
    *(rbx) = rax;
    eax = 8;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42de90 */
#include <stdint.h>
 
uint32_t caml_deserialize_uint_1 (void) {
    rdx = intern_src;
    eax = *(rdx);
    rdx++;
    *(obj.intern_src) = rdx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e240 */
#include <stdint.h>
 
void caml_deserialize_error (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    intern_cleanup ();
    rdi = rbx;
    return caml_failwith ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e1d0 */
#include <stdint.h>
 
int64_t intern_cleanup (void) {
    eax = intern_input_malloced;
    while (1) {
        rdi = intern_obj_table;
        if (rdi != 0) {
            caml_stat_free ();
        }
        rdi = intern_extra_block;
        if (rdi != 0) {
            void (*0x427670)() ();
        }
        rax = intern_block;
        if (rax != 0) {
            rdx = intern_header;
            *((rax - 8)) = rdx;
        }
        return rax;
        rdi = intern_input;
        caml_stat_free ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423c60 */
#include <stdint.h>
 
void caml_failwith (int64_t arg1) {
    int64_t var_8h_2;
    rdi = arg1;
    rsi = rdi;
    edi = caml_exn_Failure;
    return caml_raise_with_string ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428e50 */
#include <stdint.h>
 
void int32_serialize (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    edi = *((rdi + 8));
    rbx = rsi;
    caml_serialize_int_4 ();
    *(rbp) = 4;
    *(rbx) = 4;
    rbp = *((rsp + 0x10));
    rbx = *((rsp + 8));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42cdb0 */
#include <stdint.h>
 
int64_t caml_serialize_int_4 (int64_t arg1) {
    rdi = arg1;
    rax = extern_ptr;
    ebx = edi;
    rdx = rax + 4;
    if (rdx > *(obj.extern_limit)) {
        edi = 4;
        grow_extern_output ();
        rax = extern_ptr;
        rdx = rax + 4;
    }
    ecx = ebx;
    *((rax + 3)) = bl;
    ecx >>= 0x18;
    *(rax) = cl;
    ecx = ebx;
    ecx >>= 0x10;
    *((rax + 1)) = cl;
    ecx = ebx;
    ecx >>= 8;
    *((rax + 2)) = cl;
    *(obj.extern_ptr) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42caf0 */
#include <stdint.h>
 
int64_t grow_extern_output (size_t size) {
    void * var_8h_2;
    rdi = size;
    if (*(obj.extern_userprovided_output) != 0) {
        goto label_0;
    }
    rax = extern_output_block;
    rdx = extern_ptr;
    ebx = 0x1fa4;
    *((rax + 8)) = rdx;
    eax = 0x1fb8;
    if (rdi > 0xfd2) {
        goto label_1;
    }
    rax = malloc (rax);
    if (rax == 0) {
        goto label_2;
    }
    do {
        rdx = extern_output_block;
        *(rdx) = rax;
        *(obj.extern_output_block) = rax;
        rdx = rax + 0x10;
        *(rax) = 0;
        rax = rax + rbx + 0x10;
        *(obj.extern_ptr) = rdx;
        *(obj.extern_limit) = rax;
        return rax;
label_1:
        rax = rdi + 0x1fb8;
        rbx = rdi + 0x1fa4;
        rax = malloc (rax);
    } while (rax != 0);
label_2:
    *((rsp + 8)) = rax;
    extern_out_of_memory ();
label_0:
    extern_replay_trail ();
    edi = "Marshal.to_buffer: buffer overflow";
    return caml_failwith ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428e90 */
#include <stdint.h>
 
int32_t nativeint_serialize (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 8)) = r12;
    r12 = rdx;
    *((rsp - 0x10)) = rbp;
    rbp = *((rdi + 8));
    edx = 0x80000000;
    eax = 0xffffffff;
    rbx = rsi;
    rdx = rbp + rdx;
    if (rdx <= rax) {
        goto label_0;
    }
    edi = 2;
    caml_serialize_int_1 ();
    rdi = rbp;
    caml_serialize_int_8 ();
    do {
        *(rbx) = 4;
        rbp = *((rsp + 8));
        *(r12) = 8;
        rbx = *(rsp);
        r12 = *((rsp + 0x10));
        return eax;
label_0:
        edi = 1;
        caml_serialize_int_1 ();
        edi = ebp;
        caml_serialize_int_4 ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ce40 */
#include <stdint.h>
 
int64_t caml_serialize_int_1 (int64_t arg1) {
    rdi = arg1;
    rax = extern_ptr;
    ebx = edi;
    rdx = rax + 1;
    if (rdx > *(obj.extern_limit)) {
        edi = 1;
        grow_extern_output ();
        rax = extern_ptr;
        rdx = rax + 1;
    }
    *(rax) = bl;
    *(obj.extern_ptr) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42cc60 */
#include <stdint.h>
 
void caml_serialize_int_8 (int64_t arg1) {
    int64_t var_8h;
    rdi = arg1;
    esi = 1;
    *((rsp + 8)) = rdi;
    rdi = rsp + 8;
    caml_serialize_block_8 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42cbb0 */
#include <stdint.h>
 
uint64_t caml_serialize_block_8 (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rdi = rsi*8;
    r9 = extern_ptr;
    rax = r9 + rdi;
    if (*(obj.extern_limit) < rax) {
        goto label_1;
    }
label_0:
    if (rsi <= 0) {
        goto label_2;
    }
    rax = r9;
    rdx = rsi;
    do {
        r8d = *((rbx + 7));
        edi = *(rbx);
        ecx = *((rbx + 1));
        *(rax) = r8b;
        r8d = *((rbx + 6));
        *((rax + 7)) = dil;
        *((rax + 6)) = cl;
        *((rax + 1)) = r8b;
        r8d = *((rbx + 5));
        edi = *((rbx + 2));
        ecx = *((rbx + 3));
        *((rax + 2)) = r8b;
        r8d = *((rbx + 4));
        rbx += 8;
        *((rax + 5)) = dil;
        *((rax + 4)) = cl;
        *((rax + 3)) = r8b;
        rax += 8;
        rdx--;
    } while (rdx != 0);
    r9 = r9 + rsi*8;
label_2:
    *(obj.extern_ptr) = r9;
    return rax;
label_1:
    *((rsp + 8)) = rsi;
    grow_extern_output ();
    r9 = extern_ptr;
    rsi = *((rsp + 8));
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428f10 */
#include <stdint.h>
 
void int64_serialize (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rdi = *((rdi + 8));
    rbx = rsi;
    caml_serialize_int_8 ();
    *(rbp) = 8;
    *(rbx) = 8;
    rbp = *((rsp + 0x10));
    rbx = *((rsp + 8));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4291b0 */
#include <stdint.h>
 
uint64_t parse_format (int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_fh;
    int64_t var_10h;
    int64_t var_30h;
    int64_t var_58h;
    size_t * n;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r15 = r8;
    r13 = rcx;
    r12 = rdx;
    rbx = rdi;
    rax = caml_string_length ();
    *((rsp + 8)) = rax;
    rax = strlen (rbp);
    rdx = *((rsp + 8));
    r14 = rax;
    rax = rdx + rax + 1;
    if (rax > 0x1f) {
        goto label_1;
    }
    memmove (r12, rbx, *((rsp + 8)));
    rax = *((rsp + 8));
    r12 = r12 + rax - 1;
    eax = *((r12 - 1));
    ecx = *(r12);
    rdx = r12 - 1;
    if (al == 0x6e) {
        goto label_2;
    }
    if (al == 0x6c) {
        goto label_2;
    }
    if (al == 0x4c) {
        goto label_2;
    }
label_0:
    *(rsp) = cl;
    r12 += r14;
    memmove (r12, rbp, r14);
    ecx = *(rsp);
    *((r12 + 1)) = 0;
    *(r12) = cl;
    eax = *(rbx);
    if (al != 0) {
        goto label_3;
    }
    goto label_4;
    do {
        rbx++;
        eax = *(rbx);
        if (al == 0) {
            goto label_4;
        }
label_3:
        eax -= 0x30;
    } while (al > 9);
    *(rsp) = cl;
    eax = strtol (rbx, 0, 0xa);
    ecx = *(rsp);
    edx = rax + 5;
    *(r15) = cl;
    if (edx > 0x1f) {
        eax += 6;
        rdi = (int64_t) eax;
        void (*0x427680)() ();
label_2:
        r12 = rdx;
        goto label_0;
label_4:
        *(r15) = cl;
    }
    rax = r13;
    return rax;
label_1:
    edi = "format_int: format too long";
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b3c0 */
#include <stdint.h>
 
int32_t compare_channel (int64_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    eax = 0;
    rdx = *((rsi + 8));
    if (*((rdi + 8)) != rdx) {
        eax -= eax;
        eax |= 1;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c050 */
#include <stdint.h>
 
uint64_t do_write (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r13d = edx;
    r12d = edi;
label_0:
    rbx = (int64_t) r13d;
    do {
        caml_enter_blocking_section ();
        eax = write (r12d, rbp, rbx);
        r14d = eax;
        caml_leave_blocking_section ();
        if (r14d != 0xffffffff) {
            goto label_1;
        }
        rax = errno_location ();
        eax = *(rax);
    } while (eax == 4);
    dl = (eax == 0xb) ? 1 : 0;
    r13d = 1;
    al = (r13d > 1) ? 1 : 0;
    if ((dl & al) != 0) {
        goto label_0;
    }
    edi = 1;
    caml_sys_io_error ();
label_1:
    eax = r14d;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4096c0 */
#include <stdint.h>
 
void write (void) {
    write ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42fdc0 */
#include <stdint.h>
 
uint64_t caml_sys_io_error (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    rax = errno_location ();
    if (*(rax) != 0xb) {
        rdi = rbx;
        void (*0x42f840)() ();
    }
    return caml_raise_sys_blocked_io ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ca00 */
#include <stdint.h>
 
int64_t extern_replay_trail (void) {
    rdi = extern_trail_block;
    rsi = extern_trail_cur;
label_0:
    rdx = rdi + 8;
    if (rsi <= rdx) {
        goto label_1;
    }
    do {
        rbx = *(rdx);
        rcx = *(rdx);
        ebx &= 3;
        rcx &= 0xfffffffffffffffc;
        rbx <<= 8;
        rax = *((rcx - 8));
        ah &= 0xfc;
        rax |= rbx;
        *((rcx - 8)) = rax;
        rax = *((rdx + 8));
        rdx += 0x10;
        *(rcx) = rax;
    } while (rsi > rdx);
label_1:
    if (rdi != obj.extern_trail_first) {
        rbx = *(rdi);
        free (rdi);
        rsi = rbx + 0x4018;
        rdi = rbx;
        goto label_0;
    }
    *(obj.extern_trail_block) = 0x653d60;
    *(obj.extern_trail_cur) = 0x653d68;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ca90 */
#include <stdint.h>
 
void free_extern_output (void) {
    if (*(obj.extern_userprovided_output) != 0) {
        return;
    }
    rdi = extern_output_first;
    if (rdi == 0) {
        goto label_0;
    }
    do {
        rbx = *(rdi);
        free (rdi);
        rdi = rbx;
    } while (rbx != 0);
label_0:
    *(obj.extern_output_first) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42cad0 */
#include <stdint.h>
 
void extern_out_of_memory (void) {
    extern_replay_trail ();
    free_extern_output ();
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ce80 */
#include <stdint.h>
 
int64_t writecode8 (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rax = extern_ptr;
    ebx = edi;
    rdx = rax + 2;
    if (rdx > *(obj.extern_limit)) {
        edi = 2;
        grow_extern_output ();
        rax = extern_ptr;
        rdx = rax + 2;
    }
    *(rax) = bl;
    *((rax + 1)) = bpl;
    *(obj.extern_ptr) = rdx;
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42cee0 */
#include <stdint.h>
 
int64_t writecode32 (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rax = extern_ptr;
    ebx = edi;
    rdx = rax + 5;
    if (rdx > *(obj.extern_limit)) {
        edi = 5;
        grow_extern_output ();
        rax = extern_ptr;
        rdx = rax + 5;
    }
    rcx = rbp;
    *(rax) = bl;
    *((rax + 4)) = bpl;
    rcx >>= 0x18;
    *((rax + 1)) = cl;
    rcx = rbp;
    rcx >>= 0x10;
    *((rax + 2)) = cl;
    rcx = rbp;
    rcx >>= 8;
    *((rax + 3)) = cl;
    *(obj.extern_ptr) = rdx;
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42cf60 */
#include <stdint.h>
 
int64_t write32 (int64_t arg1) {
    rdi = arg1;
    rax = extern_ptr;
    rbx = rdi;
    rdx = rax + 4;
    if (rdx > *(obj.extern_limit)) {
        edi = 4;
        grow_extern_output ();
        rax = extern_ptr;
        rdx = rax + 4;
    }
    rcx = rbx;
    *((rax + 3)) = bl;
    rcx >>= 0x18;
    *(rax) = cl;
    rcx = rbx;
    rcx >>= 0x10;
    *((rax + 1)) = cl;
    rcx = rbx;
    rcx >>= 8;
    *((rax + 2)) = cl;
    *(obj.extern_ptr) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42cfc0 */
#include <stdint.h>
 
int64_t extern_record_location (int64_t arg1) {
    int64_t var_8h;
    rdi = arg1;
    rbx = rdi;
    eax = extern_ignore_sharing;
    if (eax != 0) {
        goto label_0;
    }
    rdx = extern_trail_cur;
    while (1) {
        rcx = *((rbx - 8));
        rax = *((rbx - 8));
        rax >>= 8;
        eax &= 3;
        rax |= rbx;
        *(rdx) = rax;
        rax = *(rbx);
        *((rdx + 8)) = rax;
        rax = rcx;
        rdx += 0x10;
        ah &= 0xfc;
        *(obj.extern_trail_cur) = rdx;
        ah |= 2;
        *((rbx - 8)) = rax;
        rax = obj_counter;
        *(rbx) = rax;
        rax++;
        *(obj.obj_counter) = rax;
label_0:
        return rax;
        rax = malloc (0x4018);
        if (rax == 0) {
            goto label_1;
        }
        rdx = extern_trail_block;
        *(rax) = rdx;
        rdx = rax + 8;
        *(obj.extern_trail_block) = rax;
        rax += 0x4018;
        *(obj.extern_trail_cur) = rdx;
        *(obj.extern_trail_limit) = rax;
    }
label_1:
    *((rsp + 8)) = rax;
    return extern_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42d080 */
#include <stdint.h>
 
uint64_t init_extern_output (void) {
    *(obj.extern_userprovided_output) = 0;
    rax = malloc (0x1fb8);
    *(obj.extern_output_first) = rax;
    if (rax != 0) {
        rdx = rax + 0x10;
        *(obj.extern_output_block) = rax;
        *(rax) = 0;
        rax += 0x1fb4;
        *(obj.extern_ptr) = rdx;
        *(obj.extern_limit) = rax;
        return rax;
    }
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408f50 */
#include <stdint.h>
 
void malloc (void) {
    malloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423a80 */
#include <stdint.h>
 
void caml_raise_out_of_memory (void) {
    int64_t var_8h_4;
    int64_t var_8h_3;
    int64_t var_10h_3;
    int64_t var_18h_3;
    int64_t var_20h_3;
    int64_t var_28h_3;
    int64_t var_50h_3;
    int64_t var_58h_3;
    int64_t var_60h_3;
    int64_t var_68h_3;
    int64_t var_98h_2;
    edi = caml_bucket_Out_of_memory;
    return caml_raise ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42d1c0 */
#include <stdint.h>
 
uint64_t writeblock (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rdi = extern_ptr;
    rbx = rsi;
    rax = rdi + rsi;
    if (*(obj.extern_limit) < rax) {
        rdi = rsi;
        grow_extern_output ();
    }
    memmove (*(obj.extern_ptr), rbp, rbx);
    *(obj.extern_ptr) += rbx;
    rbp = *((rsp + 0x10));
    rbx = *((rsp + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42d220 */
#include <stdint.h>
 
void extern_invalid_argument (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    extern_replay_trail ();
    free_extern_output ();
    rdi = rbx;
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42d240 */
#include <stdint.h>
 
uint64_t extern_rec (int64_t arg1) {
    int64_t var_8h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    rdi = arg1;
label_1:
    *((rsp - 0x30)) = rbx;
    *((rsp - 0x28)) = rbp;
    rbx = rdi;
    *((rsp - 0x20)) = r12;
    *((rsp - 0x18)) = r13;
    *((rsp - 0x10)) = r14;
    *((rsp - 8)) = r15;
label_0:
    if ((bl & 1) != 0) {
        goto label_13;
    }
    rdi = rbx;
    al = caml_page_table_lookup ();
    if ((al & 7) == 0) {
        goto label_14;
    }
    r13 = *((rbx - 8));
    r15 = rbx - 8;
    r14d = (int32_t) r13b;
    if (r14d == 0xfa) {
        goto label_15;
    }
label_5:
    r12 = r13;
    r12 >>= 0xa;
    if (r12 == 0) {
        goto label_16;
    }
    rax = r13;
    eax &= 0x300;
    if (rax == 0x200) {
        goto label_17;
    }
    eax = r14 - 0xf9;
    if (eax <= 6) {
        goto label_18;
    }
    if (r14d <= 0xf) {
        goto label_19;
    }
label_3:
    if (r13 <= rbp) {
        goto label_20;
    }
    rax = extern_ptr;
    r13 &= 0xfffffffffffffcff;
    rdx = rax + 9;
    if (*(obj.extern_limit) < rdx) {
        goto label_21;
    }
label_9:
    rdx = rax + 1;
    *(rax) = 0x13;
    ecx = 0x38;
    do {
        rsi = r13;
        rsi >>= cl;
        ecx -= 8;
        *((rax + 1)) = sil;
        rax++;
    } while (ecx != 0xfffffff8);
    rdx += 8;
    *(obj.extern_ptr) = rdx;
label_4:
    rax = size_32;
    rdi = rbx;
    rax = r12 + rax + 1;
    *(obj.size_32) = rax;
    rax = size_64;
    rax = r12 + rax + 1;
    *(obj.size_64) = rax;
    r13 = *(rbx);
    eax = extern_record_location ();
    if (r12 != 1) {
        goto label_22;
    }
    rbx = r13;
    goto label_0;
label_18:
    /* switch table (7 cases) at 0x436730 */
label_15:
    r12 = *(rbx);
    if ((r12b & 1) == 0) {
        goto label_23;
    }
label_6:
    rbx = r12;
    goto label_0;
    rax = *(rbx);
    rbp = *(rax);
    if (*((rax + 0x20)) == 0) {
        goto label_24;
    }
    rax = extern_ptr;
    if (rax >= *(obj.extern_limit)) {
        edi = 1;
        grow_extern_output ();
        rax = extern_ptr;
    }
    *(rax) = 0x12;
    rax++;
    *(obj.extern_ptr) = rax;
    strlen (rbp);
    rsi = rax + 1;
    rdi = rbp;
    writeblock ();
    rax = *(rbx);
    rdx = rsp;
    rdi = rbx;
    rsi = rsp + 8;
    uint64_t (*rax + 0x20)() ();
    rax = *((rsp + 8));
    rdx = size_32;
    rdi = rbx;
    rax += 3;
    rax >>= 2;
    rax = rdx + rax + 2;
    rdx = size_64;
    *(obj.size_32) = rax;
    rax = *(rsp);
    rax += 7;
    rax >>= 3;
    rax = rdx + rax + 2;
    *(obj.size_64) = rax;
    rax = extern_record_location ();
    do {
label_2:
        rbx = *((rsp + 0x18));
        rbp = *((rsp + 0x20));
        r12 = *((rsp + 0x28));
        r13 = *((rsp + 0x30));
        r14 = *((rsp + 0x38));
        r15 = *((rsp + 0x40));
        return rax;
        r12 <<= 3;
        edi = 0x11;
        rsi = r12;
        writecode32 ();
        rdi = rbx;
        rdi -= r12;
        extern_rec ();
        goto label_1;
    } while (1);
    edi = "output_value: abstract value (Abstract)";
    extern_invalid_argument ();
    rdi = rbx;
    rax = caml_string_length ();
    if (rax > 0x1f) {
        goto label_25;
    }
    rax = extern_ptr;
    if (rax >= *(obj.extern_limit)) {
        goto label_26;
    }
label_10:
    edx = ebp;
    edx += 0x20;
    *(rax) = dl;
    rax++;
    *(obj.extern_ptr) = rax;
label_7:
    rsi = rbp;
    rdi = rbx;
    writeblock ();
    rax = rbp + 4;
    rdx = size_32;
    rbp += 8;
    rbp >>= 3;
    rax >>= 2;
    rax = rdx + rax + 1;
    *(obj.size_32) = rax;
    do {
        rax = size_64;
        rdi = rbx;
        rax = rbp + rax + 1;
        *(obj.size_64) = rax;
        extern_record_location ();
        goto label_2;
        rax = extern_ptr;
        if (rax >= *(obj.extern_limit)) {
            edi = 1;
            grow_extern_output ();
            rax = extern_ptr;
        }
        *(rax) = 0xc;
        rdi = rbx;
        rax++;
        esi = 8;
        *(obj.extern_ptr) = rax;
        writeblock ();
        rdi = rbx;
        *(obj.size_32) += 3;
        *(obj.size_64) += 2;
        extern_record_location ();
        goto label_2;
        rbp = *(r15);
        rbp >>= 0xa;
        if (rbp > 0xff) {
            goto label_27;
        }
        rsi = rbp;
        edi = 0xe;
        writecode8 ();
label_8:
        rsi = rbp*8;
        rdi = rbx;
        writeblock ();
        rax = size_32;
        rax = rax + rbp*2 + 1;
        *(obj.size_32) = rax;
    } while (1);
label_19:
    if (r12 > 7) {
        goto label_3;
    }
    rax = extern_ptr;
    if (rax >= *(obj.extern_limit)) {
        goto label_28;
    }
label_11:
    edx = r12d;
    edx <<= 4;
    r14d = rdx + r14 - 0x80;
    *(rax) = r14b;
    rax++;
    *(obj.extern_ptr) = rax;
    goto label_4;
label_23:
    rdi = r12;
    al = caml_page_table_lookup ();
    if ((al & 7) == 0) {
        goto label_5;
    }
    eax = *((r12 - 8));
    if (al == 0xfa) {
        goto label_5;
    }
    if (al == 0xf6) {
        goto label_5;
    }
    if (al != 0xfd) {
        goto label_6;
    }
    goto label_5;
label_22:
    rdi = r13;
    r12--;
    r13d = 1;
    extern_rec ();
    goto label_1;
    eax = 8;
    if (r12 <= 1) {
        goto label_29;
    }
    do {
        rdi = *((rbx + r13*8));
        r13++;
        extern_rec ();
        goto label_1;
    } while (r13 < r12);
    rax = r12*8;
label_29:
    rbx = *((rax + rbx));
    goto label_0;
label_25:
    if (rax <= 0xff) {
        rsi = rax;
        edi = 9;
        writecode8 ();
        goto label_7;
label_27:
        rsi = rbp;
        edi = 7;
        rax = writecode32 ();
        goto label_8;
    }
    rsi = rax;
    edi = 0xa;
    writecode32 ();
    goto label_7;
label_21:
    edi = 9;
    grow_extern_output ();
    rax = extern_ptr;
    goto label_9;
label_13:
    rbx >>= 1;
    if (rbx <= 0x3f) {
        rax = extern_ptr;
        if (rax >= *(obj.extern_limit)) {
            edi = 1;
            grow_extern_output ();
            rax = extern_ptr;
        }
        ebx += 0x40;
        *(rax) = bl;
        rax++;
        *(obj.extern_ptr) = rax;
        goto label_2;
label_14:
        rax = caml_code_area_start;
        if (rbx >= rax) {
            if (rbx >= *(obj.caml_code_area_end)) {
                goto label_30;
            }
            edx = extern_closures;
            if (edx == 0) {
                edi = "output_value: functional value";
                rax = extern_invalid_argument ();
            }
            rsi = rbx;
            edi = 0x10;
            rsi -= rax;
            writecode32 ();
            rax = caml_code_checksum ();
            esi = 0x10;
            rdi = rax;
            writeblock ();
            goto label_2;
label_16:
            if (r14d > 0xf) {
                goto label_31;
            }
            rax = extern_ptr;
            if (rax >= *(obj.extern_limit)) {
                edi = 1;
                grow_extern_output ();
                rax = extern_ptr;
            }
            r14d += 0xffffff80;
            *(rax) = r14b;
            rax++;
            *(obj.extern_ptr) = rax;
            goto label_2;
label_26:
            edi = 1;
            grow_extern_output ();
            rax = extern_ptr;
            goto label_10;
label_28:
            edi = 1;
            grow_extern_output ();
            rax = extern_ptr;
            goto label_11;
label_20:
            rsi = r13;
            edi = 8;
            rsi &= 0xfffffffffffffcff;
            writecode32 ();
            goto label_4;
label_17:
            rbp = obj_counter;
            rbp -= *(rbx);
            if (rbp <= 0xff) {
                goto label_32;
            }
            if (rbp > 0xffff) {
                goto label_33;
            }
            rax = extern_ptr;
            rdx = rax + 3;
            if (rdx > *(obj.extern_limit)) {
                edi = 3;
                grow_extern_output ();
                rax = extern_ptr;
                rdx = rax + 3;
            }
            rcx = rbp;
            *(rax) = 5;
            *((rax + 2)) = bpl;
            rcx >>= 8;
            *((rax + 1)) = cl;
            *(obj.extern_ptr) = rdx;
            goto label_2;
        }
label_30:
        edi = "output_value: abstract value (outside heap)";
        extern_invalid_argument ();
    }
    rax = rbx + 0x80;
    if (rax <= 0xff) {
        goto label_34;
    }
    rax = rbx + 0x8000;
    if (rax <= 0xffff) {
        rax = extern_ptr;
        rdx = rax + 3;
        if (rdx > *(obj.extern_limit)) {
            edi = 3;
            grow_extern_output ();
            rax = extern_ptr;
            rdx = rax + 3;
        }
        rcx = rbx;
        *(rax) = 1;
        *((rax + 2)) = bl;
        rcx >>= 8;
        *((rax + 1)) = cl;
        *(obj.extern_ptr) = rdx;
        goto label_2;
label_24:
        edi = "output_value: abstract value (Custom)";
        extern_invalid_argument ();
    }
    edx = 0x80000000;
    eax = 0xffffffff;
    rdx = rbx + rdx;
    if (rdx <= rax) {
        goto label_35;
    }
    rax = extern_ptr;
    rdx = rax + 9;
    if (*(obj.extern_limit) < rdx) {
        goto label_36;
    }
label_12:
    rdx = rax + 1;
    *(rax) = 3;
    ecx = 0x38;
    do {
        rsi = rbx;
        rsi >>= cl;
        ecx -= 8;
        *((rax + 1)) = sil;
        rax++;
    } while (ecx != 0xfffffff8);
    rdx += 8;
    *(obj.extern_ptr) = rdx;
    goto label_2;
label_31:
    rsi = r13;
    edi = 8;
    writecode32 ();
    goto label_2;
label_32:
    rsi = rbp;
    edi = 4;
    writecode8 ();
    goto label_2;
label_33:
    rsi = rbp;
    edi = 6;
    writecode32 ();
    goto label_2;
label_34:
    rsi = rbx;
    edi = 0;
    writecode8 ();
    goto label_2;
label_36:
    edi = 9;
    grow_extern_output ();
    rax = extern_ptr;
    goto label_12;
label_35:
    rsi = rbx;
    edi = 2;
    writecode32 ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42da40 */
#include <stdint.h>
 
uint64_t extern_value (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rdi = rsi;
    esi = extern_flags;
    eax = caml_convert_flag_list ();
    edx = eax;
    edi = 0x8495a6be;
    eax &= 2;
    edx &= 1;
    *(obj.extern_closures) = eax;
    *(obj.extern_trail_block) = 0x653d60;
    *(obj.extern_ignore_sharing) = edx;
    *(obj.extern_trail_cur) = 0x653d68;
    *(obj.extern_trail_limit) = 0x657d78;
    *(obj.obj_counter) = 0;
    *(obj.size_32) = 0;
    *(obj.size_64) = 0;
    write32 ();
    rdi = rbx;
    *(obj.extern_ptr) += 0x10;
    extern_rec ();
    if (*(obj.extern_userprovided_output) == 0) {
        goto label_3;
    }
label_2:
    extern_replay_trail ();
    rcx = extern_userprovided_output;
    if (rcx == 0) {
        goto label_4;
    }
    rbx = extern_ptr;
    rbx -= rcx;
label_1:
    eax = 0xffffffff;
    if (rbx > rax) {
        goto label_5;
    }
label_0:
    eax = 0xffffffff;
    if (*(obj.size_32) > rax) {
        goto label_5;
    }
    if (*(obj.size_64) > rax) {
        goto label_5;
    }
    if (rcx == 0) {
        goto label_6;
    }
    rcx += 4;
    *(obj.extern_ptr) = rcx;
    do {
        rdi = rbx - 0x14;
        write32 ();
        rdi = obj_counter;
        write32 ();
        rdi = size_32;
        write32 ();
        rdi = size_64;
        write32 ();
        rax = rbx;
        return rax;
label_6:
        rax = extern_output_first;
        rdx = rax + 0x14;
        rax += 0x1fb4;
        *(obj.extern_limit) = rax;
        *(obj.extern_ptr) = rdx;
    } while (1);
label_4:
    rax = extern_output_first;
    ebx = 0;
    if (rax == 0) {
        goto label_0;
    }
    do {
        rdx = *((rax + 8));
        rdx -= rax;
        rax = *(rax);
        rbx = rdx + rbx - 0x10;
    } while (rax != 0);
    goto label_1;
label_3:
    rdx = extern_ptr;
    rax = extern_output_block;
    *((rax + 8)) = rdx;
    goto label_2;
label_5:
    free_extern_output ();
    edi = "output_value: object too big";
    return caml_failwith ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e350 */
#include <stdint.h>
 
uint64_t intern_alloc (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rsi;
    if (rdi == 0) {
        goto label_2;
    }
    rax = rdi - 1;
    rdx = 0x3fffffffffffff;
    if (rax > rdx) {
        goto label_3;
    }
    if (rax != 0) {
        goto label_4;
    }
    eax = 0x658868;
    *(obj.intern_block) = rax;
    do {
label_1:
        rdx = rax - 8;
        rax = *((rax - 8));
        *(obj.intern_extra_block) = 0;
        *(obj.obj_counter_1) = 0;
        *(obj.intern_dest) = rdx;
        *(obj.intern_header) = rax;
        eax &= 0x300;
        *(obj.intern_color) = eax;
        if (rbx != 0) {
            goto label_5;
        }
label_0:
        *(obj.intern_obj_table) = 0;
        return rax;
label_2:
        *(obj.intern_obj_table) = 0;
        *(obj.intern_extra_block) = 0;
        *(obj.intern_block) = 0;
        return rax;
label_4:
        if (rax > 0x100) {
            goto label_6;
        }
        esi = 0xfc;
        rdi = rax;
        rax = caml_alloc_small ();
        *(obj.intern_block) = rax;
    } while (1);
label_3:
    rdi = rdi*8 + 0xfff;
    rdi &= 0xfffffffffffff000;
    rax = caml_alloc_for_heap ();
    *(obj.intern_extra_block) = rax;
    if (rax == 0) {
        goto label_7;
    }
    rdi = rax;
    eax = caml_allocation_color ();
    *(obj.intern_color) = eax;
    rax = intern_extra_block;
    *(obj.obj_counter_1) = 0;
    *(obj.intern_dest) = rax;
    if (rbx == 0) {
        goto label_0;
    }
label_5:
    rdi = rbx*8;
    rax = caml_stat_alloc ();
    *(obj.intern_obj_table) = rax;
    return rax;
label_6:
    esi = 0xfc;
    rdi = rax;
    rax = caml_alloc_shr ();
    *(obj.intern_block) = rax;
    goto label_1;
label_7:
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e4b0 */
#include <stdint.h>
 
int64_t intern_add_to_heap (int64_t arg1) {
    rdi = arg1;
    rax = rdi;
    rdi = intern_extra_block;
    if (rdi == 0) {
        goto label_0;
    }
    rsi = rax*8 + 0xfff;
    rax = intern_dest;
    rsi &= 0xfffffffffffff000;
    rsi = rdi + rsi;
    while (1) {
        rax -= rdi;
        rax >>= 3;
        *(obj.caml_allocated_words) += rax;
        void (*0x427c40)() ();
        rsi -= rax;
        rdi = rax;
        edx = 0;
        rsi >>= 3;
        caml_make_free_blocks ();
        rax = intern_dest;
        rdi = intern_extra_block;
    }
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e530 */
#include <stdint.h>
 
int64_t intern_rec (int64_t arg1) {
    int64_t var_8h_2;
    void ** s1;
    int64_t var_28h;
    rdi = arg1;
label_0:
    rbx = rdi;
    rax = *(fs:0x28);
    *((rsp + 0x28)) = rax;
    eax = 0;
    do {
label_1:
        rax = intern_src;
        edx = *(rax);
        rdi = rax + 1;
        *(obj.intern_src) = rdi;
        ebp = (int32_t) dl;
        if (ebp <= 0x3f) {
            goto label_7;
        }
        if (ebp <= 0x7f) {
            goto label_8;
        }
        esi = ebp;
        ebp >>= 4;
        esi &= 0xf;
        ebp &= 7;
label_2:
        if (rbp == 0) {
            goto label_9;
        }
        rax = intern_dest;
        rdx = intern_obj_table;
        rcx = rax + 8;
        *(rbx) = rcx;
        if (rdx != 0) {
            rbx = obj_counter;
            *((rdx + rbx*8)) = rcx;
            rbx++;
            *(obj.obj_counter_1) = rbx;
        }
        rdx = rbp;
        rbx = rax + 8;
        rdx <<= 0xa;
        rsi = rdx + rsi;
        edx = intern_color;
        rsi += rdx;
        *(rax) = rsi;
        rax = rbp*8 + 8;
        *(obj.intern_dest) += rax;
    } while (rbp == 1);
    r13 = rbp;
    r12 = rbx;
    do {
        rdi = rbx;
        r13--;
        r12 += 8;
        intern_rec ();
        goto label_0;
    } while (r13 > 1);
    rbx = rbx + rbp*8 - 8;
    goto label_1;
label_7:
    if (ebp > 0x1f) {
        goto label_10;
    }
    if (dl > 0x13) {
        intern_cleanup ();
        edi = "input_value: ill-formed message";
        rax = caml_failwith ();
    }
    edx = (int32_t) dl;
    /* switch table (20 cases) at 0x4368f0 */
    rcx = rax + 8;
    ebp = 0;
    do {
        edx = *((rax + 1));
        rbp <<= 8;
        rax++;
        rbp += rdx;
    } while (rax != rcx);
    esi = ebp;
    rdi += 8;
    rbp >>= 0xa;
    *(obj.intern_src) = rdi;
    esi &= 0xff;
    goto label_2;
    rax = *(rdi);
    rdi++;
    *(obj.intern_src) = rdi;
    r15 = rax + rax + 1;
    do {
label_3:
        rax = *((rsp + 0x28));
        rax ^= *(fs:0x28);
        *(rbx) = r15;
        if (rdi != 0) {
            goto label_11;
        }
        return rax;
        rdi += 2;
        *(obj.intern_src) = rdi;
        rax = *((rdi - 2));
        edx = *((rdi - 1));
        rax <<= 8;
        rax += rdx;
        r15 = rax + rax + 1;
    } while (1);
    rdi += 4;
    *(obj.intern_src) = rdi;
    eax = *((rdi - 3));
    eax <<= 0x10;
    rdx = (int64_t) eax;
    eax = *((rdi - 2));
    eax <<= 8;
    rax = (int64_t) eax;
    rax = rdx + rax;
    edx = *((rdi - 1));
    rdx = rax + rdx;
    rax = *((rdi - 4));
    rax <<= 0x18;
    rax = rdx + rax;
    r15 = rax + rax + 1;
    goto label_3;
    rcx = rdi + 8;
    eax = 0;
    do {
        edx = *(rdi);
        rax <<= 8;
        rdi++;
        rax += rdx;
    } while (rdi != rcx);
    *(obj.intern_src) = rdi;
    r15 = rax + rax + 1;
    goto label_3;
    edx = *(rdi);
    rdi++;
    *(obj.intern_src) = rdi;
    do {
label_4:
        rax = obj_counter;
        rax -= rdx;
        rdx = intern_obj_table;
        r15 = *((rdx + rax*8));
        goto label_3;
        rdi += 2;
        *(obj.intern_src) = rdi;
        eax = *((rdi - 2));
        edx = *((rdi - 1));
        eax <<= 8;
        eax += edx;
        rdx = (int64_t) eax;
    } while (1);
    rdi += 4;
    *(obj.intern_src) = rdi;
    eax = *((rdi - 4));
    edx = *((rdi - 1));
    rax <<= 0x18;
    rdx = rax + rdx;
    eax = *((rdi - 3));
    eax <<= 0x10;
    rax = (int64_t) eax;
    rdx += rax;
    eax = *((rdi - 2));
    eax <<= 8;
    rax = (int64_t) eax;
    rdx += rax;
    goto label_4;
    rdi += 4;
    *(obj.intern_src) = rdi;
    eax = *((rdi - 4));
    r12d = *((rdi - 1));
    rax <<= 0x18;
    r12 = rax + r12;
    eax = *((rdi - 3));
    eax <<= 0x10;
    rax = (int64_t) eax;
    r12 += rax;
    eax = *((rdi - 2));
    eax <<= 8;
    rax = (int64_t) eax;
    r12 += rax;
label_5:
    r13 = intern_dest;
    rax = intern_obj_table;
    rdi = r13 + 8;
    r15 = rdi;
    if (rax != 0) {
        rdx = obj_counter;
        *((rax + rdx*8)) = rdi;
        rdx++;
        *(obj.obj_counter_1) = rdx;
    }
    edx = intern_color;
    rax = r12;
    r14 = r12*8;
    rax <<= 0xa;
    rax = rdx + rax + 0xfe;
    *(r13) = rax;
    rax = r12*8 + 8;
    *(obj.intern_dest) += rax;
    eax = memmove (rdi, *(obj.intern_src), r14);
    *(obj.intern_src) += r14;
    if (ebp == 7) {
        goto label_3;
    }
    if (ebp == 0xe) {
        goto label_3;
    }
    if (r12 == 0) {
        goto label_3;
    }
    eax = 0;
    do {
        esi = *((r13 + 0xf));
        ecx = *((r13 + 8));
        rax++;
        edx = *((r13 + 9));
        *((r13 + 8)) = sil;
        esi = *((r13 + 0xe));
        *((r13 + 0xf)) = cl;
        *((r13 + 0xe)) = dl;
        ecx = *((r13 + 0xa));
        edx = *((r13 + 0xb));
        *((r13 + 9)) = sil;
        esi = *((r13 + 0xd));
        *((r13 + 0xd)) = cl;
        *((r13 + 0xa)) = sil;
        esi = *((r13 + 0xc));
        *((r13 + 0xc)) = dl;
        *((r13 + 0xb)) = sil;
        r13 += 8;
    } while (r12 > rax);
    goto label_3;
    rdi += 4;
    *(obj.intern_src) = rdi;
    eax = *((rdi - 4));
    ebp = *((rdi - 1));
    rax <<= 0x18;
    rbp = rax + rbp;
    eax = *((rdi - 3));
    eax <<= 0x10;
    rax = (int64_t) eax;
    rbp += rax;
    eax = *((rdi - 2));
    eax <<= 8;
    rax = (int64_t) eax;
    rbp += rax;
    esi = ebp;
    rbp >>= 0xa;
    esi &= 0xff;
    goto label_2;
    ebp = *(rdi);
    rdi++;
    *(obj.intern_src) = rdi;
    do {
label_6:
        rdx = intern_dest;
        rcx = intern_obj_table;
        rax = rbp + 8;
        rax >>= 3;
        rdi = rdx + 8;
        r15 = rdi;
        if (rcx != 0) {
            rsi = obj_counter;
            *((rcx + rsi*8)) = rdi;
            rsi++;
            *(obj.obj_counter_1) = rsi;
        }
        esi = intern_color;
        rcx = rax;
        rcx <<= 0xa;
        rcx = rsi + rcx + 0xfc;
        *(rdx) = rcx;
        rdx = rax*8 + 8;
        rax <<= 3;
        *(obj.intern_dest) += rdx;
        rdx = rax - 1;
        *((rdi + rax - 8)) = 0;
        dl -= bpl;
        *((rdi + rax - 1)) = dl;
        memmove (rdi, *(obj.intern_src), rbp);
        *(obj.intern_src) += rbp;
        goto label_3;
        rdi += 4;
        *(obj.intern_src) = rdi;
        eax = *((rdi - 4));
        ebp = *((rdi - 1));
        rax <<= 0x18;
        rbp = rax + rbp;
        eax = *((rdi - 3));
        eax <<= 0x10;
        rax = (int64_t) eax;
        rbp += rax;
        eax = *((rdi - 2));
        eax <<= 8;
        rax = (int64_t) eax;
        rbp += rax;
    } while (1);
    rax = intern_dest;
    rdx = intern_obj_table;
    r12 = rax + 8;
    r15 = r12;
    if (rdx != 0) {
        rcx = obj_counter;
        *((rdx + rcx*8)) = r12;
        rcx++;
        *(obj.obj_counter_1) = rcx;
    }
    edx = intern_color;
    *(obj.intern_dest) += 0x10;
    rdx += 0x4fd;
    *(rax) = rdx;
    memmove (r12, *(obj.intern_src), 8);
    *(obj.intern_src) += 8;
    if (ebp == 0xc) {
        goto label_3;
    }
    ecx = *((r12 + 7));
    edx = *(r12);
    eax = *((r12 + 1));
    *(r12) = cl;
    ecx = *((r12 + 6));
    *((r12 + 7)) = dl;
    *((r12 + 6)) = al;
    edx = *((r12 + 2));
    eax = *((r12 + 3));
    *((r12 + 1)) = cl;
    ecx = *((r12 + 5));
    *((r12 + 5)) = dl;
    *((r12 + 2)) = cl;
    ecx = *((r12 + 4));
    *((r12 + 4)) = al;
    *((r12 + 3)) = cl;
    goto label_3;
    r12d = *(rdi);
    rdi++;
    *(obj.intern_src) = rdi;
    goto label_5;
    rdi += 4;
    *(obj.intern_src) = rdi;
    ebp = *((rdi - 4));
    r13d = *((rdi - 3));
    r12d = *((rdi - 2));
    r14d = *((rdi - 1));
    rdi = rsp + 8;
    intern_rec ();
    goto label_0;
    r14 += *((rsp + 8));
    rbp <<= 0x18;
    r13d <<= 0x10;
    r13 = (int64_t) r13d;
    r12d <<= 8;
    r12 = (int64_t) r12d;
    rbp = r14 + rbp;
    r13 = rbp + r13;
    r15 = r13 + r12;
    goto label_3;
    rax = caml_find_custom_operations ();
    if (rax == 0) {
        goto label_12;
    }
    rax = intern_src;
    do {
        edx = *(rax);
        rax++;
        *(obj.intern_src) = rax;
    } while (dl != 0);
    rdi = intern_dest;
    rdi += 0x10;
    rax = uint64_t (*rbp + 0x28)() ();
    rcx = intern_obj_table;
    rax += 7;
    rdx = intern_dest;
    rax >>= 3;
    rax++;
    r15 = rdx + 8;
    if (rcx != 0) {
        rsi = obj_counter;
        *((rcx + rsi*8)) = r15;
        rsi++;
        *(obj.obj_counter_1) = rsi;
    }
    esi = intern_color;
    rcx = rax;
    *(r15) = rbp;
    rcx <<= 0xa;
    rax = rax*8 + 8;
    *(obj.intern_dest) += rax;
    rcx = rsi + rcx + 0xff;
    *(rdx) = rcx;
    goto label_3;
    rbp = rsp + 0x10;
    *(obj.intern_src) = rsi;
    r14d = *((rsi - 4));
    r12d = *((rsi - 3));
    r15d = *((rsi - 2));
    r13d = *((rsi - 1));
    memmove (rbp, rdi + 4, 0x10);
    *(obj.intern_src) += 0x10;
    rax = caml_code_checksum ();
    ecx = 0x10;
    rsi = rbp;
    rdi = rax;
    __asm ("repe cmpsb byte [rsi], byte ptr [rdi]");
    if (*(obj.intern_src) == 0) {
        r14d = (int32_t) r14b;
        r13d = (int32_t) r13b;
        r12 <<= 0x10;
        r14 <<= 0x18;
        r12d &= 0xff0000;
        r15 <<= 8;
        r14 += r13;
        r15d &= 0xff00;
        r12 = r14 + r12;
        r15 = r12 + r15;
        r15 += *(obj.caml_code_area_start);
        goto label_3;
label_9:
        r15 = rsi*8 + 0x658088;
        goto label_3;
label_10:
        ebp &= 0x1f;
        goto label_6;
label_8:
        ebp &= 0x3f;
        r15 = rbp + rbp + 1;
        goto label_3;
label_11:
        stack_chk_fail ();
    }
    intern_cleanup ();
    edi = "input_value: code mismatch";
    caml_failwith ();
label_12:
    intern_cleanup ();
    edi = "input_value: unknown custom block identifier";
    return caml_failwith ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ed20 */
#include <stdint.h>
 
int64_t input_val_from_block (void) {
    int64_t var_8h;
    rax = intern_src;
    rdx = rax + 4;
    *(obj.intern_src) = rdx;
    ecx = *(rax);
    rax += 0xc;
    esi = *((rdx - 1));
    rcx <<= 0x18;
    rsi += rcx;
    ecx = *((rdx - 3));
    edx = *((rdx - 2));
    *(obj.intern_src) = rax;
    ecx <<= 0x10;
    edx <<= 8;
    rbx = (int64_t) ecx;
    rdx = (int64_t) edx;
    rsi += rbx;
    ebx = *((rax - 1));
    rsi += rdx;
    edx = *((rax - 4));
    rdx <<= 0x18;
    rbx = rdx + rbx;
    edx = *((rax - 3));
    eax = *((rax - 2));
    edx <<= 0x10;
    eax <<= 8;
    rcx = (int64_t) edx;
    rax = (int64_t) eax;
    rbx += rcx;
    rbx += rax;
    rdi = rbx;
    intern_alloc ();
    rdi = rsp + 8;
    intern_rec ();
    rdi = rbx;
    intern_add_to_heap ();
    rdi = intern_obj_table;
    if (rdi != 0) {
        caml_stat_free ();
    }
    rax = *((rsp + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f2a0 */
#include <stdint.h>
 
int64_t hash_aux (int64_t arg1) {
    rdi = arg1;
    do {
        rbx = rdi;
        rax = hash_univ_limit;
        rax--;
        *(obj.hash_univ_limit) = rax;
        if (*(obj.hash_univ_count) < 0) {
            goto label_1;
        }
        if (rax < 0) {
            goto label_1;
        }
label_2:
        if ((bl & 1) != 0) {
            goto label_7;
        }
label_3:
        rdi = rbx;
        al = caml_page_table_lookup ();
        if ((al & 7) == 0) {
            goto label_8;
        }
        eax = *((rbx - 8));
        rsi = rbx;
        rdx = rbx - 8;
        ecx = (int32_t) al;
        eax += 8;
        if (al <= 7) {
            goto label_9;
        }
        rax = hash_accu;
        *(obj.hash_univ_count)--;
        rbx = rax * 9;
        rax = rax + rbx*2;
        rax = rcx + rax;
        *(obj.hash_accu) = rax;
        rbx = *(rdx);
        rbx >>= 0xa;
        if (rbx == 0) {
            goto label_1;
        }
        rbp = rdx + rbx*8;
label_0:
        rdi = *(rbp);
        rbx--;
        rbp -= 8;
        al = hash_aux ();
    } while (1);
    if (rbx != 0) {
        goto label_0;
    }
    do {
label_1:
        return rax;
label_9:
        eax = (int32_t) al;
        /* switch table (8 cases) at 0x436990 */
        rax = *(rbx);
        rax = *((rax + 0x18));
    } while (rax == 0);
    rdx = hash_accu;
    *(obj.hash_univ_count)--;
    rdi = rbx;
    rcx = rdx;
    rcx <<= 0x10;
    rbp <<= 6;
    rbp += rcx;
    rbp -= rdx;
    void (*rax)() ();
    rbp = rax + rbp;
    *(obj.hash_accu) = rbp;
    goto label_1;
    rcx = hash_accu;
    *(obj.hash_univ_count)--;
    rdx = *((rbx + 8));
    rax = rcx;
    rbx = rcx;
    rbx <<= 6;
    rax <<= 0x10;
    rdx >>= 1;
    rax = rbx + rax;
    rax -= rcx;
    rax = rdx + rax;
    *(obj.hash_accu) = rax;
    return rax;
    rax = hash_univ_limit;
    rdx = *(rdx);
    rax--;
    *(obj.hash_univ_limit) = rax;
    if (*(obj.hash_univ_count) < 0) {
        goto label_1;
    }
    if (rax < 0) {
        goto label_1;
    }
    rdx >>= 0xa;
    rax = rdx*8;
    rbx -= rax;
    goto label_2;
    rbx = *(rbx);
    if ((bl & 1) == 0) {
        goto label_3;
    }
label_7:
    *(obj.hash_univ_count)--;
    rbx >>= 1;
label_8:
    rdx = hash_accu;
    rcx = hash_accu;
    rax = rdx;
    rcx <<= 6;
    rax <<= 0x10;
    rax = rcx + rax;
    rax -= rdx;
    rax = rbx + rax;
    *(obj.hash_accu) = rax;
label_4:
    return rax;
    rdi = rbx;
    *(obj.hash_univ_count)--;
    rax = caml_string_length ();
    if (rax == 0) {
        goto label_1;
    }
    rdx = hash_accu;
    do {
        rcx = rdx * 9;
        rcx = rdx + rcx*2;
        edx = *(rbx);
        rbx++;
        rax--;
        rdx = rcx + rdx;
    } while (rax != 0);
    *(obj.hash_accu) = rdx;
label_6:
    return rax;
    *(obj.hash_univ_count)--;
    rax = hash_accu;
    rcx = rbx + 8;
    do {
        rdx = rax * 9;
        rdx = rax + rdx*2;
        eax = *(rbx);
        rbx++;
        rax = rdx + rax;
    } while (rbx != rcx);
    *(obj.hash_accu) = rax;
    goto label_4;
    *(obj.hash_univ_count)--;
    rdi = *(rdx);
    rdi >>= 0xa;
    rdi <<= 3;
    if (rdi == 0) {
        goto label_1;
    }
    rdx = hash_accu;
    ebx = 0;
label_5:
    rax = rsi;
    rsi += 8;
    do {
        rcx = rdx * 9;
        rcx = rdx + rcx*2;
        edx = *(rax);
        rax++;
        rdx = rcx + rdx;
    } while (rsi != rax);
    rbx += 8;
    if (rbx < rdi) {
        goto label_5;
    }
    *(obj.hash_accu) = rdx;
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x430840 */
#include <stdint.h>
 
int64_t test_and_compact (int64_t arg7, int64_t arg8) {
    xmm0 = arg7;
    xmm1 = arg8;
    rax = caml_fl_cur_size;
    if (rax < 0) {
        goto label_4;
    }
    __asm ("cvtsi2sd xmm0, rax");
label_3:
    rdx = caml_stat_heap_size;
    __asm ("mulsd xmm0, qword [0x00436cf8]");
    rdx >>= 3;
    rdx -= rax;
    if (rdx < 0) {
        goto label_5;
    }
    __asm ("cvtsi2sd xmm1, rdx");
label_2:
    __asm ("divsd xmm0, xmm1");
    __asm ("unpcklpd xmm0, xmm0");
    __asm ("cvtpd2ps xmm0, xmm0");
    __asm ("ucomiss xmm0, dword [0x00436d00]");
    if (rdx <= 0) {
        goto label_6;
    }
    edx = 0xf423f;
    xmm0 = *(0x00436d00);
    do {
label_0:
        esi = "Estimated overhead (lower bound) = %lu%%\n";
        edi = 0x200;
        *(rsp) = xmm0;
        caml_gc_message ();
        rax = caml_percent_max;
        xmm0 = *(rsp);
        if (rax < 0) {
            goto label_7;
        }
        __asm ("cvtsi2ss xmm1, rax");
label_1:
        __asm ("ucomiss xmm0, xmm1");
        if (rax >= 0) {
            if (*(obj.caml_stat_heap_chunks) <= 1) {
                goto label_8;
            }
            edx = 0;
            esi = "Automatic compaction triggered.\n";
            edi = 0x200;
            caml_gc_message ();
            void (*0x433200)() ();
        }
label_8:
        return rax;
label_6:
        __asm ("ucomiss xmm0, dword [0x00436d04]");
        if (*(obj.caml_stat_heap_chunks) < 1) {
            goto label_9;
        }
        xmm1 = xmm0;
        rax = 0x8000000000000000;
        __asm ("subss xmm1, dword [0x00436d04]");
        __asm ("cvttss2si rdx, xmm1");
        rdx ^= rax;
    } while (1);
label_9:
    __asm ("cvttss2si rdx, xmm0");
    goto label_0;
label_7:
    rdx = rax;
    eax &= 1;
    rdx >>= 1;
    rdx |= rax;
    __asm ("cvtsi2ss xmm1, rdx");
    __asm ("addss xmm1, xmm1");
    goto label_1;
label_5:
    rcx = rdx;
    edx &= 1;
    rcx >>= 1;
    rcx |= rdx;
    __asm ("cvtsi2sd xmm1, rcx");
    __asm ("addsd xmm1, xmm1");
    goto label_2;
label_4:
    rdx = rax;
    rcx = rax;
    rdx >>= 1;
    ecx &= 1;
    rdx |= rcx;
    __asm ("cvtsi2sd xmm0, rdx");
    __asm ("addsd xmm0, xmm0");
    goto label_3;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432220 */
#include <stdint.h>
 
uint32_t add_string (char * s, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = s;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    rbx = rdi;
    *((rsp - 8)) = r12;
    rdi = rsi;
    r12 = rsi;
    eax = strlen (rdi);
    rdi = *(rbx);
    rbp = (int64_t) eax;
    rdx = *((rbx + 8));
    rcx = rdi + rbp;
    if (rdx < rcx) {
        eax = edx;
        eax -= edi;
        rbp = (int64_t) eax;
    }
    if (eax > 0) {
        memmove (rdi, r12, rbp);
        rdi = *(rbx);
    }
    rbp = rdi + rbp;
    r12 = *((rsp + 0x10));
    *(rbx) = rbp;
    rbx = *(rsp);
    rbp = *((rsp + 8));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4329a0 */
#include <stdint.h>
 
int64_t do_set (uint32_t arg3, int64_t arg1) {
    rdx = arg3;
    rdi = arg1;
    if ((dl & 1) == 0) {
        rax = caml_young_end;
        if (rdx >= rax) {
            goto label_0;
        }
        rcx = caml_young_start;
        if (rdx <= rcx) {
            goto label_0;
        }
        rbx = rdi + rsi*8;
        rsi = *(rbx);
        *(rbx) = rdx;
        if ((sil & 1) == 0) {
            if (rax <= rsi) {
                goto label_1;
            }
            if (rcx < rsi) {
                goto label_2;
            }
        }
label_1:
        rax = .comment;
        if (rax >= *(0x00652480)) {
            edi = caml_weak_ref_table;
            caml_realloc_ref_table ();
            rax = .comment;
        }
        *(rax) = rbx;
        rax += 8;
        *(0x00652478) = rax;
label_2:
        return rax;
    }
label_0:
    *((rdi + rsi*8)) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433100 */
#include <stdint.h>
 
uint64_t invert_pointer_at (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    *((rsp - 8)) = rbp;
    *((rsp - 0x10)) = rbx;
    rbx = *(rdi);
    while ((al & 1) == 0) {
label_0:
        rbx = *((rsp + 8));
        rbp = *((rsp + 0x10));
        return;
        rdi = rbx;
        al = caml_page_table_lookup ();
    }
    rax = *((rbx - 8));
    rdx = *((rbx - 8));
    edx &= 3;
    if (rdx != 1) {
        if (rdx == 2) {
            goto label_1;
        }
        *(rbp) = rax;
        *((rbx - 8)) = rbp;
        goto label_0;
    }
    rax >>= 0xa;
    rcx = rax*8;
    rax = rbx;
    rax -= rcx;
    rcx = rax;
    rdx = rax - 8;
    rax = *((rax - 8));
    if ((al & 3) != 0) {
        goto label_2;
    }
    do {
        rdx = rax;
        rax = *(rax);
    } while ((al & 3) == 0);
label_2:
    rsi = rax;
    rsi >>= 2;
    if (sil != 0xf7) {
        rax >>= 0xa;
        rax = rcx + rax*8;
        rax |= 1;
    }
    *(rbp) = rax;
    rbp |= 2;
    *((rbx - 8)) = rbp;
    rbx -= rcx;
    rbx >>= 3;
    rcx = rbx - 1;
    rcx <<= 0xa;
    rcx |= 0x3e7;
    *(rdx) = rcx;
    goto label_0;
label_1:
    *(rbp) = rax;
    rbp |= 2;
    *((rbx - 8)) = rbp;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4331f0 */
#include <stdint.h>
 
void invert_root (int64_t arg2) {
    rsi = arg2;
    rdi = rsi;
    return invert_pointer_at ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415f30 */
#include <stdint.h>
 
int64_t camlList_combine_254 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rax == 1) {
            goto label_0;
        }
        if (rbx == 1) {
            goto label_1;
        }
        rdx = *((rbx + 8));
        rdi = *(rbx);
        *((rsp + 8)) = rdi;
        rsi = *((rax + 8));
        rdi = *(rax);
        *(rsp) = rdi;
        rax = rsi;
        rbx = rdx;
        rax = camlList_combine_254 ();
    } while (1);
    rdi = rax;
    do {
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            rax = *(rsp);
            *(rbx) = rax;
            rax = *((rsp + 8));
            *((rbx + 8)) = rax;
            rax = rbx + 0x18;
            *((rax - 8)) = 0x800;
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            return rax;
label_0:
            if (rbx == 1) {
                rax = 1;
                return rax;
            }
label_1:
            rax = *(loc.camlList__40);
            void (*0x40fc30)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fc30 */
#include <stdint.h>
 
int64_t camlPervasives_invalid_arg_40 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *(reloc.caml_exn_Invalid_argument);
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b390 */
#include <stdint.h>
 
int32_t caml_channel_binary_mode (void) {
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415a90 */
#include <stdint.h>
 
int64_t camlList_assoc_197 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rbx == 1) {
            goto label_0;
        }
        *(rsp) = rax;
        rdi = *((rbx + 8));
        *((rsp + 8)) = rdi;
        rdi = *(rbx);
        rbx = *((rdi + 8));
        *((rsp + 0x10)) = rbx;
        rdi = *(rdi);
        rsi = rax;
        rax = *(reloc.caml_compare);
        rax = caml_c_call ();
        if (rax == 1) {
            rax = *((rsp + 0x10));
            return rax;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
    } while (1);
    do {
label_0:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c780 */
#include <stdint.h>
 
uint64_t caml_seek_out (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rbx = rdi;
    caml_flush ();
    edi = *(rbx);
    edx = 0;
    rsi = rbp;
    rax = lseek64 ();
    if (rax != rbp) {
        edi = 1;
        caml_sys_error ();
    }
    *((rbx + 8)) = rbp;
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c6d0 */
#include <stdint.h>
 
uint32_t caml_flush (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    do {
        rdi = rbx;
        eax = caml_flush_partial ();
    } while (eax == 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c390 */
#include <stdint.h>
 
uint32_t caml_flush_partial (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdi = arg1;
    *((rsp - 0x20)) = rbx;
    *((rsp - 0x18)) = rbp;
    rbp = rdi + 0x50;
    *((rsp - 0x10)) = r12;
    *((rsp - 8)) = r13;
    r13 = *((rdi + 0x18));
    rbx = rdi;
    r12d = r13d;
    r12d -= ebp;
    if (r12d <= 0) {
        goto label_0;
    }
    edi = *(rdi);
    edx = r12d;
    rsi = rbp;
    eax = do_write ();
    r13 = (int64_t) eax;
    *((rbx + 8)) += r13;
    while (1) {
        r13 = -r13;
        r13 += *((rbx + 0x18));
        *((rbx + 0x18)) = r13;
label_0:
        eax = 0;
        rbx = *((rsp + 8));
        al = (r13 == rbp) ? 1 : 0;
        rbp = *((rsp + 0x10));
        r12 = *((rsp + 0x18));
        r13 = *((rsp + 0x20));
        return eax;
        r12d -= eax;
        rdx = (int64_t) r12d;
        memmove (rbp, rbp + r13, rdx);
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4199b0 */
#include <stdint.h>
 
int64_t camlHashtbl_Make_279 (int64_t arg6, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r8 = rax;
    rax = *(reloc.camlHashtbl);
    r12 = *(rax);
    rax = *(reloc.camlHashtbl);
    rbp = *((rax + 8));
    rax = *(reloc.camlHashtbl);
    r11 = *((rax + 0x18));
label_0:
    r15 -= 0xd8;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    rbx = r15 + 8;
    *((rbx - 8)) = 0xcf7;
    rax = *(reloc.camlHashtbl__safehash_205);
    *(rbx) = rax;
    *((rbx + 8)) = 3;
    *((rbx + 0x10)) = r8;
    r10 = rbx + 0x20;
    *((r10 - 8)) = 0x10f7;
    rax = *(reloc.caml_curry3);
    *(r10) = rax;
    *((r10 + 8)) = 7;
    rax = *(reloc.camlHashtbl__add_207);
    *((r10 + 0x10)) = rax;
    *((r10 + 0x18)) = rbx;
    r9 = rbx + 0x48;
    *((r9 - 8)) = 0x14f7;
    rax = *(reloc.caml_curry2);
    *(r9) = rax;
    *((r9 + 8)) = 5;
    rax = *(reloc.camlHashtbl__remove_213);
    *((r9 + 0x10)) = rax;
    *((r9 + 0x18)) = r8;
    *((r9 + 0x20)) = rbx;
    rdi = rbx + 0x78;
    *((rdi - 8)) = 0x10f7;
    rax = *(reloc.caml_curry2);
    *(rdi) = rax;
    *((rdi + 8)) = 5;
    rax = *(reloc.camlHashtbl__find_rec_221);
    *((rdi + 0x10)) = rax;
    *((rdi + 0x18)) = r8;
    rcx = rbx + 0xa0;
    *((rcx - 8)) = 0x18f7;
    rax = *(reloc.caml_curry2);
    *(rcx) = rax;
    *((rcx + 8)) = 5;
    rax = *(reloc.camlHashtbl__find_226);
    *((rcx + 0x10)) = rax;
    *((rcx + 0x18)) = r8;
    *((rcx + 0x20)) = rbx;
    *((rcx + 0x28)) = rdi;
    do {
        r15 -= 0xf8;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x14f7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlHashtbl__find_all_238);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = r8;
            *((rdi + 0x20)) = rbx;
            rdx = rdi + 0x30;
            *((rdx - 8)) = 0x14f7;
            rax = *(reloc.caml_curry3);
            *(rdx) = rax;
            *((rdx + 8)) = 7;
            rax = *(reloc.camlHashtbl__replace_245);
            *((rdx + 0x10)) = rax;
            *((rdx + 0x18)) = r8;
            *((rdx + 0x20)) = rbx;
            rsi = rdi + 0x60;
            *((rsi - 8)) = 0x14f7;
            rax = *(reloc.caml_curry2);
            *(rsi) = rax;
            *((rsi + 8)) = 5;
            rax = *(reloc.camlHashtbl__mem_255);
            *((rsi + 0x10)) = rax;
            *((rsi + 0x18)) = r8;
            *((rsi + 0x20)) = rbx;
            rax = *(reloc.camlHashtbl);
            r8 = *((rax + 0x48));
            rax = *(reloc.camlHashtbl);
            rbx = *((rax + 0x50));
            rax = *(reloc.camlHashtbl);
            r13 = *((rax + 0x58));
            rax = rdi + 0x90;
            *((rax - 8)) = 0x3000;
            *(rax) = r12;
            *((rax + 8)) = rbp;
            *((rax + 0x10)) = r11;
            *((rax + 0x18)) = r10;
            *((rax + 0x20)) = r9;
            *((rax + 0x28)) = rcx;
            *((rax + 0x30)) = rdi;
            *((rax + 0x38)) = rdx;
            *((rax + 0x40)) = rsi;
            *((rax + 0x48)) = r8;
            *((rax + 0x50)) = rbx;
            *((rax + 0x58)) = r13;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4152f0 */
#include <stdint.h>
 
int64_t camlList_length_aux_58 (void) {
    do {
        if (rbx == 1) {
            goto label_0;
        }
        rbx = *((rbx + 8));
        rax += 2;
    } while (1);
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428cb0 */
#include <stdint.h>
 
int64_t caml_int32_to_int (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429c30 */
#include <stdint.h>
 
int64_t caml_int64_mul (int64_t arg2) {
    rsi = arg2;
    rax = *((rsi + 8));
    rax *= *((rdi + 8));
    rdi = rax;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42dcb0 */
#include <stdint.h>
 
uint64_t caml_output_value_to_buffer (int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2) {
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rsi >>= 1;
    rdx >>= 1;
    rdi = rsi + rdi;
    rsi = r8;
    *(obj.extern_userprovided_output) = rdi;
    *(obj.extern_ptr) = rdi;
    rdi += rdx;
    *(obj.extern_limit) = rdi;
    rdi = rcx;
    extern_value ();
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424f10 */
#include <stdint.h>
 
uint32_t caml_init_signals (void) {
    int64_t var_8h;
    int64_t var_88h;
    int64_t var_a0h;
    int64_t var_a8h;
    int64_t var_b0h;
    rdi = rsp + 8;
    *((rsp + 0xa0)) = obj.sig_alt_stack;
    *((rsp + 0xb0)) = 0x2000;
    *((rsp + 0xa8)) = 0;
    *(rsp) = sym.segv_handler;
    *((rsp + 0x88)) = 0x48000004;
    sigemptyset ();
    rdi = rsp + 0xa0;
    esi = 0;
    *(obj.system_stack_top) = rsp;
    eax = sigaltstack ();
    if (eax == 0) {
        sigaction (0xb, rsp, 0);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4095e0 */
#include <stdint.h>
 
void sigemptyset (void) {
    sigemptyset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4096f0 */
#include <stdint.h>
 
void sigaltstack (void) {
    sigaltstack ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409290 */
#include <stdint.h>
 
void sigaction (void) {
    sigaction ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415500 */
#include <stdint.h>
 
int64_t camlList_iter_102 (void) {
    int64_t var_8h;
    do {
        rsi = rax;
        if (rbx == 1) {
            goto label_0;
        }
        rax = *((rbx + 8));
        rax = *(rbx);
        rdi = *(rsi);
        rbx = rsi;
        void (*rdi)(uint64_t, uint64_t) (rsi, rax);
        rax = *(rsp);
        rbx = *((rsp + 8));
    } while (1);
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417380 */
#include <stdint.h>
 
int64_t camlString_capitalize_132 (void) {
    rbx = rax;
    rax = *(reloc.camlChar);
    rax = *((rax + 0x18));
    return camlString_apply1_128 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4169e0 */
#include <stdint.h>
 
uint64_t camlString_copy_70 (void) {
    int64_t var_8h;
    rdi = rax;
    *(rsp) = rdi;
    rbx = *((rdi - 8));
    rbx >>= 0xa;
    rax = rbx*8 - 1;
    rbx = *((rdi + rax));
    rax -= rbx;
    rdi = rax + rax + 1;
    *((rsp + 8)) = rdi;
    rax = *(reloc.caml_create_string);
    rax = caml_c_call ();
    rbx = rax;
    rcx = 1;
    rsi = 1;
    rdi = *(rsp);
    rdx = rbx;
    r8 = *((rsp + 8));
    caml_blit_string ();
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b050 */
#include <stdint.h>
 
int64_t camlUnix_fun_1673 (void) {
    rdi = rax;
    rax = *(reloc.unix_localtime);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428d80 */
#include <stdint.h>
 
int64_t caml_nativeint_to_int (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a560 */
#include <stdint.h>
 
uint64_t caml_apply3 (uint32_t arg_8h, uint32_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = *((rsi + 8));
    if (rdx == 7) {
        rdx = *((rsi + 0x10));
        void (*rdx)() ();
    }
    rdi = *(rsi);
    rbx = rsi;
    rax = void (*rdi)(uint64_t, uint64_t) (rbx, rdi);
    rbx = rax;
    rdi = *(rbx);
    rax = *(rsp);
    rax = void (*rdi)() ();
    rbx = rax;
    rdi = *(rbx);
    rax = *((rsp + 8));
    return void (*rdi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4257e0 */
#include <stdint.h>
 
int64_t caml_fl_add_blocks (uint32_t arg1) {
    rdi = arg1;
    rax = *((rdi - 8));
    rdx = caml_fl_cur_size;
    rax >>= 0xa;
    rax = rdx + rax + 1;
    *(obj.caml_fl_cur_size) = rax;
    rax = fl_last;
    if (rdi <= rax) {
        goto label_7;
    }
    *(rax) = rdi;
    if (rax == *(obj.caml_fl_merge)) {
        goto label_8;
    }
label_3:
    if (*(obj.caml_allocation_policy) == 1) {
        goto label_9;
    }
    do {
label_0:
        return rax;
label_7:
        rdx = .comment;
        if (rdi <= rdx) {
            goto label_10;
        }
        if (rdx == 0) {
            goto label_10;
        }
label_2:
        rax = *(rdx);
        rcx = rdx;
        if (rdi > rax) {
            goto label_11;
        }
label_1:
        rsi = rdx;
        rdx = rax;
label_6:
        rax = *((rdi + 8));
        *(rax) = rdx;
        *(rcx) = rdi;
        if (rsi == *(obj.caml_fl_merge)) {
            goto label_12;
        }
label_5:
    } while (*(obj.caml_allocation_policy) != 1);
    if (rdi == 0x64de30) {
        goto label_13;
    }
    eax = flp_size;
    if (eax <= 0) {
        goto label_4;
    }
    eax--;
    rdx = (int64_t) eax;
    rdx = *((rdx*8 + obj.flp));
    if (rdi <= *(rdx)) {
        goto label_14;
    }
    goto label_4;
    do {
        edx = rax - 1;
        rcx = (int64_t) edx;
        rcx = *((rcx*8 + obj.flp));
        if (rdi > *(rcx)) {
            goto label_15;
        }
        eax = edx;
label_14:
    } while (eax != 0);
    *(obj.flp_size) = 0;
label_4:
    if (rdi > *(obj.beyond)) {
        goto label_0;
    }
    *(obj.beyond) = 0;
    return rax;
label_11:
    if (rax == 0) {
        goto label_1;
    }
    rdx = rax;
    goto label_2;
label_9:
    edx = flp_size;
    if (edx > 0x3e7) {
        goto label_0;
    }
    rcx = (int64_t) edx;
    edx++;
    *((rcx*8 + obj.flp)) = rax;
    *(obj.flp_size) = edx;
    return rax;
label_8:
    if (rdi >= *(obj.caml_gc_sweep_hp)) {
        goto label_3;
    }
    rdx = *((rdi + 8));
    *(obj.caml_fl_merge) = rdx;
    goto label_3;
label_15:
    *(obj.flp_size) = eax;
    goto label_4;
label_12:
    if (rdi >= *(obj.caml_gc_sweep_hp)) {
        goto label_5;
    }
    *(obj.caml_fl_merge) = rax;
    goto label_5;
label_10:
    ecx = 0x64de30;
    rsi = rcx;
    goto label_6;
label_13:
    *(obj.flp_size) = 0;
    *(obj.beyond) = 0;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x431590 */
#include <stdint.h>
 
uint32_t rotate_right32 (uint32_t value, uint32_t count) {
    const uint32_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
int32_t caml_MD5Transform (int64_t arg2, int64_t arg1) {
    int64_t var_5cfebcech;
    int64_t var_100b83h;
    rsi = arg2;
    rdi = arg1;
    edx = *((rdi + 0xc));
    eax = *(rdi);
    ecx = *((rdi + 8));
    r14d = *((rdi + 4));
    r13d = *(rsi);
    r8d = *((rsi + 4));
    r10d = *((rsi + 0xc));
    ebp = *((rsi + 0x10));
    r12d = *((rsi + 0x1c));
    ebx = rax + r13 - 0x28955b88;
    eax = edx;
    r9d = *((rsi + 0x28));
    eax ^= ecx;
    r11d = *((rsi + 0x30));
    eax &= r14d;
    *((rsp - 0xc)) = ebp;
    eax ^= edx;
    edx = rdx + r8 - 0x173848aa;
    eax = rbx + rax;
    ebx = ecx;
    ebx ^= r14d;
    eax = rotate_right32 (eax, 0x19);
    eax += r14d;
    ebx &= eax;
    ebx ^= ecx;
    edx += ebx;
    ebx = *((rsi + 8));
    edx = rotate_right32 (edx, 0x14);
    edx += eax;
    r15d = rcx + rbx + 0x242070db;
    ecx = eax;
    *((rsp - 8)) = ebx;
    ecx ^= r14d;
    ebx = *((rsi + 0x14));
    ecx &= edx;
    ecx ^= r14d;
    r14d = r14 + r10 - 0x3e423112;
    ecx = r15 + rcx;
    ecx = rotate_right32 (ecx, 0xf);
    r15d = rcx + rdx;
    ecx = edx;
    ecx ^= eax;
    ecx &= r15d;
    ecx ^= eax;
    eax = rax + rbp - 0xa83f051;
    ebp = *((rsi + 0x20));
    r14d += ecx;
    ecx = r15d;
    r14d = rotate_right32 (r14d, 0xa);
    ecx ^= edx;
    r14d += r15d;
    *((rsp - 0x14)) = ebp;
    ecx &= r14d;
    ecx ^= edx;
    edx = rdx + rbx + 0x4787c62a;
    eax += ecx;
    ecx = r14d;
    eax = rotate_right32 (eax, 0x19);
    ecx ^= r15d;
    eax += r14d;
    ecx &= eax;
    ecx ^= r15d;
    edx += ecx;
    ecx = *((rsi + 0x18));
    edx = rotate_right32 (edx, 0x14);
    edx += eax;
    *((rsp - 0x10)) = ecx;
    r15d = r15 + rcx - 0x57cfb9ed;
    ecx = eax;
    ecx ^= r14d;
    ecx &= edx;
    ecx ^= r14d;
    r14d = r14 + r12 - 0x2b96aff;
    r15d += ecx;
    ecx = edx;
    r15d = rotate_right32 (r15d, 0xf);
    ecx ^= eax;
    r15d += edx;
    ecx &= r15d;
    ecx ^= eax;
    eax = rax + rbp + 0x698098d8;
    ebp = *((rsi + 0x2c));
    r14d += ecx;
    ecx = r15d;
    r14d = rotate_right32 (r14d, 0xa);
    ecx ^= edx;
    r14d += r15d;
    *((rsp - 0x1c)) = ebp;
    ecx &= r14d;
    ecx ^= edx;
    eax += ecx;
    ecx = *((rsi + 0x24));
    eax = rotate_right32 (eax, 0x19);
    eax += r14d;
    *((rsp - 0x18)) = ecx;
    edx = rdx + rcx - 0x74bb0851;
    ecx = r14d;
    ecx ^= r15d;
    ecx &= eax;
    ecx ^= r15d;
    r15d = r15 + r9 - 0xa44f;
    edx += ecx;
    ecx = eax;
    edx = rotate_right32 (edx, 0x14);
    ecx ^= r14d;
    edx += eax;
    ecx &= edx;
    ecx ^= r14d;
    r14d = r14 + rbp - 0x76a32842;
    ebp = *((rsi + 0x38));
    r15d += ecx;
    ecx = edx;
    r15d = rotate_right32 (r15d, 0xf);
    ecx ^= eax;
    r15d += edx;
    ecx &= r15d;
    ecx ^= eax;
    eax = rax + r11 + 0x6b901122;
    r14d += ecx;
    ecx = r15d;
    r14d = rotate_right32 (r14d, 0xa);
    ecx ^= edx;
    r14d += r15d;
    ecx &= r14d;
    ecx ^= edx;
    eax += ecx;
    ecx = *((rsi + 0x34));
    eax = rotate_right32 (eax, 0x19);
    eax += r14d;
    *((rsp - 0x20)) = ecx;
    edx = rdx + rcx - 0x2678e6d;
    ecx = r14d;
    ecx ^= r15d;
    ecx &= eax;
    ecx ^= r15d;
    r15d = r15 + rbp - 0x5986bc72;
    edx += ecx;
    ecx = eax;
    edx = rotate_right32 (edx, 0x14);
    ecx ^= r14d;
    edx += eax;
    ecx &= edx;
    ecx ^= r14d;
    r15d += ecx;
    ecx = *((rsi + 0x3c));
    esi = edx;
    r15d = rotate_right32 (r15d, 0xf);
    esi ^= eax;
    r15d += edx;
    esi &= r15d;
    r14d = r14 + rcx + 0x49b40821;
    esi ^= eax;
    eax = rax + r8 - 0x9e1da9e;
    r14d += esi;
    r14d = rotate_right32 (r14d, 0xa);
    r14d += r15d;
    esi = r14d;
    esi ^= r15d;
    esi &= edx;
    esi ^= r15d;
    eax += esi;
    esi = *((rsp - 0x10));
    eax = rotate_right32 (eax, 0x1b);
    eax += r14d;
    edx = rdx + rsi - 0x3fbf4cc0;
    esi = eax;
    esi ^= r14d;
    esi &= r15d;
    esi ^= r14d;
    edx += esi;
    esi = *((rsp - 0x1c));
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    r15d = r15 + rsi + 0x265e5a51;
    esi = edx;
    esi ^= eax;
    esi &= r14d;
    r14d = r14 + r13 - 0x16493856;
    esi ^= eax;
    esi = r15 + rsi;
    esi = rotate_right32 (esi, 0x12);
    esi += edx;
    r15d = esi;
    r15d ^= edx;
    r15d &= eax;
    eax = rax + rbx - 0x29d0efa3;
    r15d ^= edx;
    r14d += r15d;
    r14d = rotate_right32 (r14d, 0xc);
    r14d += esi;
    r15d = r14d;
    r15d ^= esi;
    r15d &= edx;
    edx = rdx + r9 + 0x2441453;
    r15d ^= esi;
    eax += r15d;
    eax = rotate_right32 (eax, 0x1b);
    eax += r14d;
    r15d = eax;
    r15d ^= r14d;
    r15d &= esi;
    esi = rsi + rcx - 0x275e197f;
    r15d ^= r14d;
    edx += r15d;
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    r15d = edx;
    r15d ^= eax;
    r15d &= r14d;
    r15d ^= eax;
    esi += r15d;
    r15d = *((rsp - 0xc));
    esi = rotate_right32 (esi, 0x12);
    esi += edx;
    r14d = r14 + r15 - 0x182c0438;
    r15d = esi;
    r15d ^= edx;
    r15d &= eax;
    r15d ^= edx;
    r14d += r15d;
    r15d = *((rsp - 0x18));
    r14d = rotate_right32 (r14d, 0xc);
    r14d += esi;
    eax = rax + r15 + 0x21e1cde6;
    r15d = r14d;
    r15d ^= esi;
    r15d &= edx;
    edx = rdx + rbp - 0x3cc8f82a;
    r15d ^= esi;
    eax += r15d;
    eax = rotate_right32 (eax, 0x1b);
    eax += r14d;
    r15d = eax;
    r15d ^= r14d;
    r15d &= esi;
    esi = rsi + r10 - 0xb2af279;
    r15d ^= r14d;
    edx += r15d;
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    r15d = edx;
    r15d ^= eax;
    r15d &= r14d;
    r15d ^= eax;
    esi += r15d;
    r15d = *((rsp - 0x14));
    esi = rotate_right32 (esi, 0x12);
    esi += edx;
    r14d = r14 + r15 + 0x455a14ed;
    r15d = esi;
    r15d ^= edx;
    r15d &= eax;
    r15d ^= edx;
    r14d += r15d;
    r15d = *((rsp - 0x20));
    r14d = rotate_right32 (r14d, 0xc);
    r14d += esi;
    eax = rax + r15 - 0x561c16fb;
    r15d = r14d;
    r15d ^= esi;
    r15d &= edx;
    r15d ^= esi;
    eax += r15d;
    r15d = *((rsp - 8));
    eax = rotate_right32 (eax, 0x1b);
    eax += r14d;
    edx = rdx + r15 - 0x3105c08;
    r15d = eax;
    r15d ^= r14d;
    r15d &= esi;
    esi = rsi + r12 + 0x676f02d9;
    r15d ^= r14d;
    edx += r15d;
    edx = rotate_right32 (edx, 0x17);
    edx += eax;
    r15d = edx;
    r15d ^= eax;
    r15d &= r14d;
    r14d = r14 + r11 - 0x72d5b376;
    r15d ^= eax;
    esi += r15d;
    *((rsp - 4)) = r14d;
    esi = rotate_right32 (esi, 0x12);
    esi += edx;
    r15d = esi;
    r15d ^= edx;
    r14d = r15d;
    r14d &= eax;
    eax = rax + rbx - 0x5c6be;
    r14d ^= edx;
    r14d += *((rsp - 4));
    r14d = rotate_right32 (r14d, 0xc);
    r14d += esi;
    r15d ^= r14d;
    r15d = rax + r15;
    eax = *((rsp - 0x14));
    r15d = rotate_right32 (r15d, 0x1c);
    edx = rdx + rax - 0x788e097f;
    eax = r14d;
    r15d += r14d;
    eax ^= esi;
    eax ^= r15d;
    edx += eax;
    eax = *((rsp - 0x1c));
    edx = rotate_right32 (edx, 0x15);
    edx += r15d;
    esi = rsi + rax + 0x6d9d6122;
    eax = r15d;
    eax ^= r14d;
    r14d = r14 + rbp - 0x21ac7f4;
    eax ^= edx;
    esi += eax;
    eax = edx;
    esi = rotate_right32 (esi, 0x10);
    eax ^= r15d;
    r15d = r15 + r8 - 0x5b4115bc;
    esi += edx;
    eax ^= esi;
    r14d += eax;
    eax = esi;
    r14d = rotate_right32 (r14d, 9);
    eax ^= edx;
    r14d += esi;
    eax ^= r14d;
    r15d += eax;
    eax = *((rsp - 0xc));
    r15d = rotate_right32 (r15d, 0x1c);
    r15d += r14d;
    edx = rdx + rax + 0x4bdecfa9;
    eax = r14d;
    eax ^= esi;
    esi = rsi + r12 - 0x944b4a0;
    eax ^= r15d;
    eax = rdx + rax;
    edx = r15d;
    edx ^= r14d;
    r14d = r14 + r9 - 0x41404390;
    eax = rotate_right32 (eax, 0x15);
    eax += r15d;
    edx ^= eax;
    edx = rsi + rdx;
    esi = eax;
    esi ^= r15d;
    edx = rotate_right32 (edx, 0x10);
    edx += eax;
    esi ^= edx;
    r14d += esi;
    esi = *((rsp - 0x20));
    r14d = rotate_right32 (r14d, 9);
    r14d += edx;
    r15d = r15 + rsi + 0x289b7ec6;
    esi = edx;
    esi ^= eax;
    eax = rax + r13 - 0x155ed806;
    esi ^= r14d;
    esi = r15 + rsi;
    r15d = r14d;
    r15d ^= edx;
    edx = rdx + r10 - 0x2b10cf7b;
    esi = rotate_right32 (esi, 0x1c);
    esi += r14d;
    r15d ^= esi;
    r15d = rax + r15;
    eax = esi;
    r15d = rotate_right32 (r15d, 0x15);
    r15d += esi;
    eax ^= r14d;
    eax ^= r15d;
    eax = rdx + rax;
    edx = *((rsp - 0x10));
    eax = rotate_right32 (eax, 0x10);
    r14d = r14 + rdx + 0x4881d05;
    edx = r15d;
    eax += r15d;
    edx ^= esi;
    edx ^= eax;
    edx = r14 + rdx;
    r14d = *((rsp - 0x18));
    edx = rotate_right32 (edx, 9);
    esi = rsi + r14 - 0x262b2fc7;
    r14d = eax;
    edx += eax;
    r14d ^= r15d;
    r15d = r15 + r11 - 0x1924661b;
    r14d ^= edx;
    esi += r14d;
    r14d = edx;
    esi = rotate_right32 (esi, 0x1c);
    r14d ^= eax;
    eax = rax + rcx + 0x1fa27cf8;
    esi += edx;
    r14d ^= esi;
    r13d = rsi + r13 - 0xbd6ddbc;
    r15d += r14d;
    r14d = esi;
    r15d = rotate_right32 (r15d, 0x15);
    r14d ^= edx;
    r15d += esi;
    r14d ^= r15d;
    r12d = r15 + r12 + 0x432aff97;
    eax += r14d;
    r14d = *((rsp - 8));
    eax = rotate_right32 (eax, 0x10);
    eax += r15d;
    edx = rdx + r14 - 0x3b53a99b;
    r14d = r15d;
    ebp = rax + rbp - 0x546bdc59;
    r14d ^= esi;
    esi = eax;
    r14d ^= eax;
    esi = ~esi;
    edx += r14d;
    r14d = r15d;
    r15d = *((rsp - 0x14));
    edx = rotate_right32 (edx, 9);
    r14d = ~r14d;
    edx += eax;
    r14d |= edx;
    r14d ^= eax;
    r13d += r14d;
    r14d = *((rsp - 0x1c));
    r13d = rotate_right32 (r13d, 0x1a);
    r13d += edx;
    esi |= r13d;
    eax = r13d;
    esi ^= edx;
    eax = ~eax;
    r12d += esi;
    esi = edx;
    edx = rdx + rbx - 0x36c5fc7;
    r12d = rotate_right32 (r12d, 0x16);
    esi = ~esi;
    r12d += r13d;
    esi |= r12d;
    esi ^= r13d;
    r13d = r13 + r11 + 0x655b59c3;
    ebp += esi;
    ebp = rotate_right32 (ebp, 0x11);
    ebp += r12d;
    eax |= ebp;
    eax ^= r12d;
    edx += eax;
    eax = r12d;
    r12d = r12 + r10 - 0x70f3336e;
    edx = rotate_right32 (edx, 0xb);
    eax = ~eax;
    edx += ebp;
    eax |= edx;
    ebx = edx;
    eax ^= ebp;
    ebx = ~ebx;
    r13d += eax;
    eax = ebp;
    ebp = rbp + r9 - 0x100b83;
    r13d = rotate_right32 (r13d, 0x1a);
    eax = ~eax;
    r13d += edx;
    eax |= r13d;
    esi = r13d;
    eax ^= edx;
    esi = ~esi;
    edx = rdx + r8 - 0x7a7ba22f;
    r12d += eax;
    eax = *((rsp - 0x10));
    r12d = rotate_right32 (r12d, 0x16);
    r12d += r13d;
    ebx |= r12d;
    ebx ^= r13d;
    r13d = r13 + r15 + 0x6fa87e4f;
    r15d = *((rsp - 8));
    ebp += ebx;
    ebx = r12d;
    ebp = rotate_right32 (ebp, 0x11);
    ebx = ~ebx;
    ebp += r12d;
    esi |= ebp;
    esi ^= r12d;
    edx += esi;
    esi = r12 + rcx - 0x1d31920;
    ecx = *((rsp - 0x20));
    edx = rotate_right32 (edx, 0xb);
    edx += ebp;
    ebx |= edx;
    ebx ^= ebp;
    r13d += ebx;
    ebx = ebp;
    r13d = rotate_right32 (r13d, 0x1a);
    ebx = ~ebx;
    r13d += edx;
    ebx |= r13d;
    ebx ^= edx;
    esi += ebx;
    ebx = rbp + rax - 0x5cfebcec;
    eax = edx;
    esi = rotate_right32 (esi, 0x16);
    eax = ~eax;
    edx = rdx + rcx + 0x4e0811a1;
    esi += r13d;
    ebp = *((rsp - 0xc));
    eax |= esi;
    ecx = esi;
    eax ^= r13d;
    ecx = ~ecx;
    ebx += eax;
    eax = r13d;
    ebx = rotate_right32 (ebx, 0x11);
    eax = ~eax;
    ebx += esi;
    eax |= ebx;
    eax ^= esi;
    edx += eax;
    eax = r13 + rbp - 0x8ac817e;
    ebp = *((rsp - 0x18));
    edx = rotate_right32 (edx, 0xb);
    edx += ebx;
    ecx |= edx;
    ecx ^= ebx;
    eax += ecx;
    ecx = rsi + r14 - 0x42c50dcb;
    esi = ebx;
    eax = rotate_right32 (eax, 0x1a);
    esi = ~esi;
    ebx = rbx + r15 + 0x2ad7d2bb;
    eax += edx;
    esi |= eax;
    esi ^= edx;
    esi = rcx + rsi;
    ecx = edx;
    ecx = ~ecx;
    esi = rotate_right32 (esi, 0x16);
    esi += eax;
    ecx |= esi;
    ecx ^= eax;
    *((rdi + 0xc)) += esi;
    ecx = rbx + rcx;
    ebx = rdx + rbp - 0x14792c6f;
    edx = eax;
    eax += *(rdi);
    edx = ~edx;
    ecx = rotate_right32 (ecx, 0x11);
    ecx += esi;
    *((rdi + 8)) += ecx;
    edx |= ecx;
    edx ^= esi;
    *(rdi) = eax;
    eax = *((rdi + 4));
    edx = rbx + rdx;
    eax += ecx;
    edx = rotate_right32 (edx, 0xb);
    edx = rax + rdx;
    *((rdi + 4)) = edx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429ea0 */
#include <stdint.h>
 
int64_t caml_le_float (int64_t arg2) {
    rsi = arg2;
    xmm0 = *(rsi);
    __asm ("ucomisd xmm0, qword [rdi]");
    rax -= rax;
    rax &= 0xfffffffffffffffe;
    rax += 3;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x412900 */
#include <stdint.h>
 
int64_t camlArray_make_matrix_70 (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdi = arg1;
    *(rsp) = rax;
    *((rsp + 8)) = rbx;
    *((rsp + 0x10)) = rdi;
    rsi = *(loc.camlArray__32);
    rdi = rax;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = 1;
    rax = *(rsp);
    rax += 0xfffffffffffffffe;
    if (rbx > rax) {
        goto label_0;
    }
    *((rsp + 0x20)) = rax;
    *(rsp) = rbx;
    *((rsp + 0x18)) = rbp;
    do {
        rdi = *((rsp + 8));
        rsi = *((rsp + 0x10));
        rax = *(reloc.caml_make_vect);
        rax = caml_c_call ();
        rbx = *(rsp);
        rbp = *((rsp + 0x18));
        rdi = rbp + rbx*4 - 4;
        rsi = rax;
        caml_modify ();
        rdi = rbx;
        rbx += 2;
        *(rsp) = rbx;
        rax = *((rsp + 0x20));
    } while (rdi != rax);
label_0:
    rax = rbp;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b800 */
#include <stdint.h>
 
int64_t camlUnix_fun_1795 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_putenv);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4309a0 */
#include <stdint.h>
 
int32_t caml_gc_compaction (void) {
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    caml_finish_major_cycle ();
    caml_compact_heap ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x426fc0 */
#include <stdint.h>
 
int64_t caml_empty_minor_heap (void) {
    rax = caml_young_end;
    if (*(obj.caml_young_ptr) == rax) {
        goto label_1;
    }
    edx = 0;
    esi = 0x436388;
    edi = 2;
    *(obj.caml_in_minor_collection) = 1;
    caml_gc_message ();
    rax = caml_oldify_local_roots ();
    rbx = caml_ref_table;
    if (rbx >= *(0x00652438)) {
        goto label_2;
    }
    do {
        rax = *(rbx);
        rbx += 8;
        rdi = *(rax);
        rsi = rax;
        caml_oldify_one ();
    } while (*(0x00652438) > rbx);
label_2:
    caml_oldify_mopup ();
    r8 = caml_weak_ref_table;
    rbx = .comment;
    rax = r8;
    if (r8 >= rbx) {
        goto label_3;
    }
    rsi = caml_young_end;
    rdi = caml_young_start;
    do {
        rcx = *(rax);
        rdx = *(rcx);
        if ((dl & 1) == 0) {
            if (rdx >= rsi) {
                goto label_0;
            }
            if (rdx <= rdi) {
                goto label_0;
            }
            if (*((rdx - 8)) == 0) {
                goto label_4;
            }
            rdx = caml_weak_none;
            *(rcx) = rdx;
        }
label_0:
        rax += 8;
    } while (rbx > rax);
    do {
        rax = caml_young_ptr;
        rdx = rsi;
        *(obj.caml_young_ptr) = rsi;
        *(obj.caml_young_limit) = rdi;
        esi = 0x4369e3;
        *(0x00652478) = r8;
        if (rax < rdi) {
            rax = rdi;
        }
        edi = 2;
        rdx -= rax;
        rax = rdx;
        edx = 0;
        rax >>= 3;
        __asm ("cvtsi2sd xmm0, rax");
        rax = caml_ref_table;
        *(0x00652438) = rax;
        rax = .comment;
        *(0x00652440) = rax;
        rax = .comment;
        *(0x00652480) = rax;
        __asm ("addsd xmm0, qword [obj.caml_stat_minor_words]");
        *(obj.caml_stat_minor_words) = xmm0;
        caml_gc_message ();
        *(obj.caml_in_minor_collection) = 0;
label_1:
        void (*0x433ca0)() ();
label_4:
        rdx = *(rdx);
        *(rcx) = rdx;
        goto label_0;
label_3:
        rsi = caml_young_end;
        rdi = caml_young_start;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x426840 */
#include <stdint.h>
 
int64_t caml_finish_major_cycle (int64_t arg7) {
    xmm0 = arg7;
    eax = caml_gc_phase;
    if (eax != 2) {
        goto label_0;
    }
    goto label_1;
    do {
        rdi = 0x7fffffffffffffff;
        mark_slice ();
        eax = caml_gc_phase;
label_0:
    } while (eax == 0);
    if (eax != 1) {
        goto label_2;
    }
    do {
        rdi = 0x7fffffffffffffff;
        sweep_slice ();
    } while (*(obj.caml_gc_phase) == 1);
label_2:
    rax = caml_allocated_words;
    if (rax < 0) {
        goto label_3;
    }
    __asm ("cvtsi2sd xmm0, rax");
    do {
        __asm ("addsd xmm0, qword [obj.caml_stat_major_words]");
        *(obj.caml_allocated_words) = 0;
        *(obj.caml_stat_major_words) = xmm0;
        return rax;
label_3:
        rdx = rax;
        eax &= 1;
        rdx >>= 1;
        rdx |= rax;
        __asm ("cvtsi2sd xmm0, rdx");
        __asm ("addsd xmm0, xmm0");
    } while (1);
label_1:
    start_cycle ();
    eax = caml_gc_phase;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433200 */
#include <stdint.h>
 
int64_t caml_compact_heap (void) {
    edx = 0;
    esi = "Compacting heap...\n";
    edi = 0x10;
    caml_gc_message ();
    rax = caml_heap_start;
    if (rax == 0) {
        goto label_18;
    }
label_1:
    rsi = rax;
    rsi += *((rax - 0x10));
    rdi = rax - 0x20;
    if (rsi > rax) {
        goto label_0;
    }
    goto label_19;
    do {
        rdx = rbx;
        rcx <<= 2;
        rdx <<= 0xa;
        ecx &= 0x3fc;
        rdx |= 3;
        rdx |= rcx;
        *(rax) = rdx;
        rax = rax + rbx*8 + 8;
        if (rsi <= rax) {
            goto label_19;
        }
label_0:
        rcx = *(rax);
        rdx = *(rax);
        rbx = rcx;
        edx &= 0x300;
        rbx >>= 0xa;
    } while (rdx != 0x200);
    rdx = rbx;
    rdx <<= 0xa;
    rdx |= 0x3f3;
    *(rax) = rdx;
    rax = rax + rbx*8 + 8;
    if (rsi > rax) {
        goto label_0;
    }
label_19:
    rax = *((rdi + 0x18));
    if (rax != 0) {
        goto label_1;
    }
label_18:
    edi = invert_root;
    caml_do_roots ();
    edi = invert_root;
    rax = caml_final_do_weak_roots ();
    r13 = caml_heap_start;
    if (r13 == 0) {
        goto label_20;
    }
label_3:
    r14 = r13;
    r14 += *((r13 - 0x10));
    r15 = r13 - 0x20;
    if (r14 <= r13) {
        goto label_21;
    }
label_2:
    rax = *(r13);
    if ((al & 3) != 0) {
        goto label_22;
    }
    do {
        rax = *(rax);
    } while ((al & 3) == 0);
label_22:
    r12 = rax;
    rax >>= 2;
    r12 >>= 0xa;
    eax &= 0xff;
    r12++;
    if (eax == 0xf9) {
        goto label_23;
    }
label_9:
    if (eax > 0xfa) {
        goto label_24;
    }
    if (r12 <= 1) {
        goto label_24;
    }
    rbp = r13 + 8;
    ebx = 1;
    do {
        rdi = rbp;
        rbx++;
        rbp += 8;
        rax = invert_pointer_at ();
    } while (r12 > rbx);
label_24:
    r13 = r13 + r12*8;
    if (r14 > r13) {
        goto label_2;
    }
label_21:
    r13 = *((r15 + 0x18));
    if (r13 != 0) {
        goto label_3;
    }
label_20:
    r13 = caml_weak_list_head;
    if (r13 == 0) {
        goto label_25;
    }
    r14d = caml_weak_list_head;
label_4:
    r12 = *((r13 - 8));
    if ((r12b & 3) != 0) {
        goto label_26;
    }
    do {
        r12 = *(r12);
    } while ((r12b & 3) == 0);
label_26:
    r12 >>= 0xa;
    if (r12 <= 1) {
        goto label_27;
    }
    rbx = r13 + 8;
    do {
        rax = caml_weak_none;
        if (*(rbx) != rax) {
            rdi = rbx;
            invert_pointer_at ();
        }
        rbp++;
        rbx += 8;
    } while (r12 > rbp);
label_27:
    rdi = r14;
    r14 = r13;
    invert_pointer_at ();
    r13 = *(r13);
    if (r13 != 0) {
        goto label_4;
    }
label_25:
    rbp = caml_heap_start;
    if (rbp == 0) {
        goto label_28;
    }
    rax = rbp;
    do {
        *((rax - 0x18)) = 0;
        rax = *((rax - 8));
    } while (rax != 0);
    rcx = rbp;
    rdi = rbp;
label_11:
    r9 = rbp;
    r10 = rdi - 0x20;
    r9 += *((rdi - 0x10));
    while ((al & 3) != 0) {
        rdx = rax;
        rdx >>= 2;
        if (dl == 0xf9) {
            goto label_29;
        }
        rbx = rax;
        edx = (int32_t) dl;
        rax >>= 0xa;
        rbx &= 0xfffffffffffffc00;
        rsi = rcx;
        rdx = rbx + rdx + 0x200;
        *(rdi) = rdx;
        rdi = rdi + rax*8 + 8;
label_6:
        rcx = rsi;
        if (r9 <= rdi) {
            goto label_30;
        }
        rax = *(rdi);
    }
    do {
        rax = *(rax);
    } while ((al & 3) == 0);
    rdx = rax;
    rdx >>= 2;
label_29:
    rax >>= 0xa;
    edx &= 0xff;
    r13 = rax + 1;
    eax = 0;
    if (edx == 0xf9) {
        goto label_31;
    }
label_10:
    r11 = *((rcx - 0x18));
    rbx = *((rcx - 0x10));
    r8 = r13*8;
    r14 = rcx - 0x20;
    rbx -= r11;
    if (rbx > 0x20) {
        goto label_32;
    }
    rsi = *((rcx - 8));
    r15 = *((rsi - 0x10));
    r15 -= *((rsi - 0x18));
    r12 = rsi - 0x20;
    if (r15 > 0x20) {
        goto label_32;
    }
    rcx = rsi;
    while (r11 <= 0x20) {
        rsi = rbx;
        rcx = rbx;
        rbx = *((r12 + 0x18));
        r11 = *((rbx - 0x10));
        r11 -= *((rbx - 0x18));
        r12 = rbx - 0x20;
    }
    while (r8 > rbx) {
        rcx = *((r14 + 0x18));
        r11 = *((rcx - 0x18));
        rbx = *((rcx - 0x10));
        r14 = rcx - 0x20;
        rbx -= r11;
label_8:
    }
    r12 = rcx + r11;
    r11 += r8;
    *((r14 + 8)) = r11;
    rbx = *(rdi);
    if ((bl & 3) != 0) {
        goto label_33;
    }
    r11 = r12 + 8;
    do {
        rcx = *(rbx);
        *(rbx) = r11;
        rbx = rcx;
    } while ((cl & 3) == 0);
label_33:
    r13 <<= 0xa;
    rdx = r13 + rdx - 0x400;
    *(rdi) = rdx;
    if (rax == 0) {
        goto label_34;
    }
    rdx = rax;
    edx &= 3;
    if (rdx == 3) {
        goto label_34;
    }
label_5:
    r11 = rax;
    r11 &= 0xfffffffffffffffc;
    rax = *(r11);
    rdx = *(r11);
    edx &= 3;
    if (rdx != 2) {
        goto label_35;
    }
    rbx = r11;
    rbx -= rdi;
    rbx >>= 3;
    rcx = r12 + rbx*8 + 8;
    do {
        rdx = rax;
        rdx &= 0xfffffffffffffffc;
        rax = *(rdx);
        *(rdx) = rcx;
        rdx = rax;
        edx &= 3;
    } while (rdx == 2);
label_7:
    rbx <<= 0xa;
    rbx += 0xf9;
    *(r11) = rbx;
    if (rdx != 3) {
        goto label_5;
    }
label_34:
    rdi += r8;
    goto label_6;
label_35:
    rbx = r11;
    rbx -= rdi;
    rbx >>= 3;
    goto label_7;
label_32:
    rsi = rcx;
    goto label_8;
label_23:
    rax = *((r13 + r12*8));
    rdx = *((r13 + r12*8));
    edx &= 3;
    if (rdx == 3) {
        goto label_36;
    }
    do {
        rax &= 0xfffffffffffffffc;
        rax = *(rax);
        rdx = *(rax);
        edx &= 3;
    } while (rdx != 3);
label_36:
    r12 = rax;
    rax >>= 2;
    r12 >>= 0xa;
    eax &= 0xff;
    r12++;
    goto label_9;
label_31:
    rax = rdi + r13*8;
    rdx = *(rax);
    rbx = *(rax);
    ebx &= 3;
    if (rbx == 3) {
        goto label_37;
    }
    do {
        rdx &= 0xfffffffffffffffc;
        rdx = *(rdx);
        rbx = *(rdx);
        ebx &= 3;
    } while (rbx != 3);
label_37:
    r13 = rdx;
    rdx >>= 2;
    r13 >>= 0xa;
    edx &= 0xff;
    r13++;
    goto label_10;
label_30:
    rdi = *((r10 + 0x18));
    if (rdi != 0) {
        goto label_11;
    }
    rax = rbp;
    do {
        *((rax - 0x18)) = 0;
        rax = *((rax - 8));
    } while (rax != 0);
    *(obj.compact_fl) = rbp;
label_13:
    r12 = rbp;
    r12 += *((rbp - 0x10));
    r13 = rbp - 0x20;
label_16:
    if (r12 <= rbp) {
        goto label_38;
    }
label_12:
    rax = *(rbp);
    if ((ah & 3) != 0) {
        goto label_39;
    }
    rax >>= 0xa;
    rbx = rax*8 + 8;
    rax = compact_fl;
    rdi = *((rax - 0x18));
    rdx = *((rax - 0x10));
    rcx = rax - 0x20;
    rdx -= rdi;
    if (rdx > 0x20) {
        goto label_40;
    }
    rsi = *((rax - 8));
    r9 = *((rsi - 0x10));
    r9 -= *((rsi - 0x18));
    r8 = rsi - 0x20;
    if (r9 <= 0x20) {
        goto label_41;
    }
    goto label_40;
    do {
        rsi = rdx;
label_41:
        rdx = *((r8 + 0x18));
        rax = rsi;
        rcx = *((rdx - 0x10));
        rcx -= *((rdx - 0x18));
        r8 = rdx - 0x20;
    } while (rcx <= 0x20);
    rdi = *((rsi - 0x18));
    rdx = *((rsi - 0x10));
    rcx = rsi - 0x20;
    *(obj.compact_fl) = rsi;
    rdx -= rdi;
    if (rbx <= rdx) {
        goto label_42;
    }
    do {
        rax = *((rcx + 0x18));
        rdi = *((rax - 0x18));
        rdx = *((rax - 0x10));
        rcx = rax - 0x20;
        rdx -= rdi;
label_40:
    } while (rbx > rdx);
label_42:
    rdx = rdi + rbx;
    rbp += rbx;
    *((rcx + 8)) = rdx;
    eax = memmove (rax + rdi, rbp, rbx);
    if (r12 > rbp) {
        goto label_12;
    }
label_38:
    rbp = *((r13 + 0x18));
    if (rbp != 0) {
        goto label_13;
    }
    rdi = caml_heap_start;
    if (rdi == 0) {
        goto label_43;
    }
    rdx = rdi;
    ebx = 0;
    eax = 0;
    do {
        rcx = *((rdx - 0x18));
        rsi = rdx - 0x20;
        if (rcx != 0) {
            rdx = *((rdx - 0x10));
            rbp >>= 3;
            rax += rbp;
            rdx -= rcx;
            rdx >>= 3;
            rbx += rdx;
        }
        rdx = *((rsi + 0x18));
    } while (rdx != 0);
    ecx = 0x64;
    edx = 0;
    rax = rdx:rax / rcx;
    rdx = rdx:rax % rcx;
    rbp = rax + 1;
    rbp *= *(obj.caml_percent_free);
    goto label_44;
label_14:
    rax = *((rax + 0x10));
    rax >>= 3;
    rbx += rax;
    do {
label_15:
        rdi = r12;
        if (r12 == 0) {
            goto label_45;
        }
label_44:
        rax = rdi - 0x20;
        r12 = *((rdi - 8));
    } while (*((rdi - 0x18)) != 0);
    if (rbx < rbp) {
        goto label_14;
    }
    rax = caml_shrink_heap ();
    goto label_15;
label_39:
    rax >>= 0xa;
    rbp = rbp + rax*8 + 8;
    goto label_16;
label_45:
    rbp = caml_heap_start;
    caml_fl_reset ();
    if (rbp != 0) {
        goto label_46;
    }
    goto label_47;
    do {
label_17:
        rbp = *((rbx + 0x18));
        if (rbp == 0) {
            goto label_47;
        }
label_46:
        rsi = *((rbp - 0x10));
        rdi = *((rbp - 0x18));
        rbx = rbp - 0x20;
    } while (rsi <= rdi);
    rsi -= rdi;
    rdi = rbp + rdi;
    edx = 1;
    rsi >>= 3;
    caml_make_free_blocks ();
    goto label_17;
label_28:
    *(obj.compact_fl) = 0;
label_43:
    caml_fl_reset ();
label_47:
    *(obj.caml_stat_compactions)++;
    edx = 0;
    esi = "done.\n";
    edi = 0x10;
    return caml_gc_message ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433df0 */
#include <stdint.h>
 
int64_t caml_final_do_calls (void) {
    edx = running_finalisation_function;
    if (edx != 0) {
        goto label_1;
    }
    if (*(obj.to_do_hd) == 0) {
        goto label_1;
    }
    edi = 0x80;
    edx = 0;
    esi = "Calling finalisation functions.\n";
    eax = caml_gc_message ();
    rdi = to_do_hd;
    while (eax != 0) {
        eax--;
        *((rdi + 8)) = eax;
        rax = (int64_t) eax;
        rax *= 3;
        rax = rdi + rax*8;
        rsi = *((rax + 0x20));
        rdi = *((rax + 0x10));
        rax = *((rax + 0x18));
        *(obj.running_finalisation_function) = 1;
        rsi += rax;
        caml_callback ();
        rbx = to_do_hd;
        *(obj.running_finalisation_function) = 0;
label_0:
        rdi = rbx;
        if (rdi == 0) {
            goto label_2;
        }
        eax = *((rdi + 8));
    }
    rbx = *(rdi);
    free (rdi);
    *(obj.to_do_hd) = rbx;
    if (rbx != 0) {
        goto label_0;
    }
    *(obj.to_do_tl) = 0;
    goto label_0;
label_1:
    return rax;
label_2:
    edx = 0;
    esi = "Done calling finalisation functions.\n";
    edi = 0x80;
    return caml_gc_message ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b090 */
#include <stdint.h>
 
int64_t camlUnix_fun_1677 (void) {
    rdi = rax;
    rax = *(reloc.unix_gettimeofday);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423f80 */
#include <stdint.h>
 
int64_t caml_init_frame_descriptors (void) {
    if (*(obj.inited.3995) != 0) {
        goto label_3;
    }
    rdi = caml_frametable;
    if (rdi == 0) {
        goto label_4;
    }
    ebx = 0;
    do {
        rbx++;
        caml_register_frametable ();
        rdi = *((rbx*8 + loc.caml_frametable));
    } while (rdi != 0);
label_4:
    *(obj.inited.3995) = 1;
label_3:
    rax = frametables;
    if (rax == 0) {
        goto label_5;
    }
    edx = 0;
    do {
        rcx = *(rax);
        rax = *((rax + 8));
        rdx += *(rcx);
    } while (rax != 0);
    rdx += rdx;
    if (rdx <= 4) {
        goto label_5;
    }
    ebx = 4;
    do {
        rbx += rbx;
    } while (rbx < rdx);
    rdi = rbx*8;
    rax = caml_stat_alloc ();
    ecx = rbx - 1;
    *(obj.caml_frame_descriptors) = rax;
label_2:
    edx = 0;
    do {
        *((rax + rdx*8)) = 0;
        rdx++;
    } while (rdx < rbx);
    r9 = frametables;
    *(obj.caml_frame_descriptors_mask) = ecx;
    if (r9 == 0) {
        goto label_6;
    }
    rbx = (int64_t) ecx;
label_1:
    rsi = *(r9);
    r8 = *(rsi);
    if (r8 <= 0) {
        goto label_7;
    }
    rsi += 8;
    edi = 0;
label_0:
    rdx = *(rsi);
    rdx >>= 3;
    rdx &= rbx;
    rcx = rax + rdx*8;
    if (*(rcx) == 0) {
        goto label_8;
    }
    do {
        rdx++;
        rdx &= rbx;
        rcx = rax + rdx*8;
    } while (*(rcx) != 0);
label_8:
    edx = *((rsi + 0xa));
    *(rcx) = rsi;
    rdx = rsi + rdx*2 + 0x13;
    rdx &= 0xfffffffffffffff8;
    rcx = rdx + 8;
    if ((*((rsi + 8)) & 1) != 0) {
        rdx = rcx;
    }
    rdi++;
    if (rdi != r8) {
        rsi = rdx;
        goto label_0;
    }
label_7:
    r9 = *((r9 + 8));
    if (r9 != 0) {
        goto label_1;
    }
label_6:
    return rax;
label_5:
    edi = 0x20;
    ebx = 4;
    rax = caml_stat_alloc ();
    ecx = 3;
    *(obj.caml_frame_descriptors) = rax;
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x412d70 */
#include <stdint.h>
 
int64_t camlArray_concat_103 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0xcf7;
            rax = *(reloc.camlArray__find_init_105);
            *(rbx) = rax;
            *((rbx + 8)) = 3;
            *((rbx + 0x10)) = rdi;
            rax = rdi;
            void (*0x411590)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b320 */
#include <stdint.h>
 
int64_t camlUnix_fun_1717 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_mkdir);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fe90 */
#include <stdint.h>
 
int64_t camlPervasives_valid_float_lexem_159 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    rax = *((rsi - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rbx = *((rsi + rax));
    rax -= rbx;
    rdi = rax + rax + 1;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x10f7;
            rax = *(reloc.camlPervasives__loop_162);
            *(rbx) = rax;
            *((rbx + 8)) = 3;
            *((rbx + 0x10)) = rsi;
            *((rbx + 0x18)) = rdi;
            rax = 1;
            void (*0x40f640)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415540 */
#include <stdint.h>
 
int64_t camlList_fold_left_106 (uint32_t arg1) {
    uint32_t var_8h;
    rdi = arg1;
    do {
        rdx = rax;
        rax = rbx;
        if (rdi == 1) {
            goto label_0;
        }
        *(rsp) = rdx;
        rsi = *((rdi + 8));
        *((rsp + 8)) = rsi;
        rdi = *(rdi);
        rbx = *(rdi);
        rdi = rdx;
        rax = caml_apply2 ();
        rbx = rax;
        rax = *(rsp);
        rdi = *((rsp + 8));
    } while (1);
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410540 */
#include <stdint.h>
 
int64_t camlPervasives_print_newline_300 (void) {
    rsi = 0x15;
    rax = *(reloc.camlPervasives);
    rdi = *((rax + 0xb8));
    rax = *(reloc.caml_ml_output_char);
    caml_c_call ();
    rax = *(reloc.camlPervasives);
    rdi = *((rax + 0xb8));
    rax = *(reloc.caml_ml_flush);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434730 */
#include <stdint.h>
 
uint64_t caml_search_exe_in_path (int64_t arg1) {
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    esi = 8;
    *((rsp - 8)) = r12;
    r12 = rdi;
    rdi = rsp;
    caml_ext_table_init ();
    rax = getenv ("PATH");
    rdi = rsp;
    rsi = rax;
    rax = caml_decompose_path ();
    rsi = r12;
    rdi = rsp;
    rax = caml_search_in_path ();
    rdi = rbp;
    r12 = rax;
    caml_stat_free ();
    rdi = rsp;
    esi = 0;
    caml_ext_table_free ();
    rax = r12;
    rbx = *((rsp + 0x10));
    rbp = *((rsp + 0x18));
    r12 = *((rsp + 0x20));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425260 */
#include <stdint.h>
 
uint64_t caml_ext_table_init (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    *((rdi + 4)) = esi;
    rsi = (int64_t) esi;
    rbx = rdi;
    *(rdi) = 0;
    rdi = rsi*8;
    rax = caml_stat_alloc ();
    *((rbx + 8)) = rax;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4093f0 */
#include <stdint.h>
 
void getenv (void) {
    getenv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434480 */
#include <stdint.h>
 
uint64_t caml_decompose_path (char * s, int64_t arg1) {
    rsi = s;
    rdi = arg1;
    r12d = 0;
    rbx = rsi;
    if (rsi == 0) {
        goto label_4;
    }
    strlen (rsi);
    rdi = rax + 1;
    rax = caml_stat_alloc ();
    r12 = rax;
    strcpy (rax, rbx);
    rsi = r12;
    while (al == 0x3a) {
label_0:
        rbx = rsi;
label_1:
        rdi = rbp;
        caml_ext_table_add ();
        if (*(rbx) == 0) {
            goto label_4;
        }
label_3:
        rsi = rbx + 1;
        *(rbx) = 0;
        eax = *(rsi);
    }
    if (al == 0) {
        goto label_0;
    }
    rax = rsi + 1;
label_2:
    edx = *(rax);
    rbx = rax;
    rax++;
    if (dl == 0x3a) {
        goto label_1;
    }
    if (dl != 0) {
        goto label_2;
    }
    rdi = rbp;
    caml_ext_table_add ();
    if (*(rbx) != 0) {
        goto label_3;
    }
label_4:
    rax = r12;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434570 */
#include <stdint.h>
 
int64_t caml_search_in_path (int64_t arg2, int64_t arg1) {
    int64_t var_18h;
    rsi = arg2;
    rdi = arg1;
    r14 = rsi;
    r12 = rdi;
    edx = *(rsi);
    if (dl == 0) {
        goto label_1;
    }
    rax = rsi;
    if (dl != 0x2f) {
        goto label_2;
    }
    goto label_3;
    do {
        if (dl == 0x2f) {
            goto label_3;
        }
label_2:
        rax++;
        edx = *(rax);
    } while (dl != 0);
label_1:
    eax = *(r12);
    if (eax <= 0) {
        goto label_3;
    }
    ebp = 0;
    r13d = 0;
    while (*(rbx) == 0) {
label_0:
        strcat (rbx, r14);
        rdx = rsp;
        rsi = rbx;
        edi = 1;
        eax = xstat64 ();
        if (eax == 0) {
            eax = *((rsp + 0x18));
            eax &= 0xf000;
            if (eax == 0x8000) {
                goto label_4;
            }
        }
        rdi = rbx;
        r13d++;
        rbp += 8;
        caml_stat_free ();
        if (*(r12) <= r13d) {
            goto label_3;
        }
        rax = *((r12 + 8));
        rax = strlen (*((rax + rbp)));
        rbx = rax;
        strlen (r14);
        rdi = rbx + rax + 2;
        rax = caml_stat_alloc ();
        rbx = rax;
        rax = *((r12 + 8));
        strcpy (rbx, *((rax + rbp)));
    }
    strlen (rbx);
    *((rbx + rax)) = 0x2f;
    goto label_0;
label_3:
    strlen (r14);
    rdi = rax + 1;
    rax = caml_stat_alloc ();
    rdi = rax;
    rbx = rax;
    strcpy (rdi, r14);
label_4:
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4251a0 */
#include <stdint.h>
 
int64_t caml_ext_table_free (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    if (esi == 0) {
        goto label_0;
    }
    eax = *(rdi);
    if (eax <= 0) {
        goto label_0;
    }
    r12d = 0;
    ebp = 0;
    do {
        rax = *((rbx + 8));
        ebp++;
        rdi = *((rax + r12));
        r12 += 8;
        caml_stat_free ();
    } while (*(rbx) > ebp);
label_0:
    rdi = *((rbx + 8));
    return caml_stat_free ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423f20 */
#include <stdint.h>
 
int64_t caml_register_frametable (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    edi = 0x10;
    rbx = frametables;
    caml_stat_alloc ();
    rdi = caml_frame_descriptors;
    *(rax) = rbp;
    *((rax + 8)) = rbx;
    *(obj.frametables) = rax;
    if (rdi != 0) {
        caml_stat_free ();
        *(obj.caml_frame_descriptors) = 0;
    }
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x412fe0 */
#include <stdint.h>
 
int64_t camlArray_blit_120 (int64_t arg6, int64_t arg5, int64_t arg4, signed int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_10h;
    int64_t var_30h;
    signed int64_t var_38h;
    int64_t var_28h_3;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r13 = rdi;
    r12 = rsi;
    if (rdx < 1) {
        goto label_2;
    }
    if (rbx < 1) {
        goto label_2;
    }
    rax = *((rbp - 8));
    rax >>= 9;
    rax |= 1;
    rax -= rdx;
    rax++;
    if (rbx > rax) {
        goto label_2;
    }
    if (r12 < 1) {
        goto label_2;
    }
    rax = *((r13 - 8));
    rax >>= 9;
    rax |= 1;
    rax -= rdx;
    rax++;
    if (r12 > rax) {
        goto label_2;
    }
    if (rbx >= r12) {
        goto label_3;
    }
    *(rsp) = rdx;
    if (*(rsp) < 1) {
        goto label_4;
    }
    *((rsp + 8)) = rbx;
    do {
        rbx = *((rsp + 8));
        rax = *(rsp);
        rbx = rbx + rax - 1;
        rax = *((rbp - 8));
        if (rax != 0xfe) {
            rsi = *((rbp + rbx*4 - 4));
        } else {
label_1:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_5;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rbp + rbx*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
            rsi = rax;
        }
        rax = *(rsp);
        rbx = r12 + rax - 1;
        rax = *((r13 - 8));
        if (rax != 0xfe) {
            rax = r13 + rbx*4 - 4;
            rdi = rax;
            caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [r13 + rbx*4 - 4], xmm0");
        }
        rbx = *(rsp);
        rax = *(rsp);
        rax -= 2;
        *(rsp) = rax;
    } while (rbx != 1);
label_4:
    rax = 1;
    return rax;
label_3:
    *((rsp + 0x18)) = 1;
    *((rsp + 0x10)) = rdx;
    rax = *((rsp + 0x18));
    if (rax > *((rsp + 0x10))) {
        goto label_6;
    }
    *((rsp + 8)) = rbx;
    *(rsp) = rbp;
    do {
        rbx = *((rsp + 8));
        rax = *((rsp + 0x18));
        rdi = rbx + rax - 1;
        rbx = *(rsp);
        rax = *((rbx - 8));
        if (rax != 0xfe) {
            rsi = *((rbx + rdi*4 - 4));
        } else {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_7;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rbx + rdi*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
            rsi = rax;
        }
        rax = *((rsp + 0x18));
        rbx = r12 + rax - 1;
        rax = *((r13 - 8));
        if (rax != 0xfe) {
            rax = r13 + rbx*4 - 4;
            rdi = rax;
            caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [r13 + rbx*4 - 4], xmm0");
        }
        rbx = *((rsp + 0x18));
        rax = *((rsp + 0x18));
        rax += 2;
        *((rsp + 0x18)) = rax;
    } while (rbx != *((rsp + 0x10)));
label_6:
    rax = 1;
    return rax;
label_2:
    rax = *(loc.camlArray__25);
    void (*0x40fc30)() ();
label_7:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42fc30 */
#include <stdint.h>
 
uint64_t caml_sys_is_directory (int64_t arg1) {
    int64_t var_18h;
    rdi = arg1;
    rsi = rdi;
    rbx = rdi;
    edi = 1;
    rdx = rsp;
    eax = xstat64 ();
    if (eax != 0xffffffff) {
        eax = *((rsp + 0x18));
        eax &= 0xf000;
        al = (eax == 0x4000) ? 1 : 0;
        eax = (int32_t) al;
        rax = rax + rax + 1;
        return rax;
    }
    rdi = rbx;
    return caml_sys_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433880 */
#include <stdint.h>
 
int64_t caml_compact_heap_maybe (int64_t arg7) {
    xmm0 = arg7;
    if (*(obj.caml_percent_max) > 0xf423f) {
        goto label_6;
    }
    if (*(obj.caml_stat_major_collections) <= 2) {
        goto label_6;
    }
    if (*(obj.caml_stat_heap_chunks) <= 2) {
        goto label_6;
    }
    rax = caml_fl_cur_size;
    rdx = caml_fl_size_at_phase_change;
    if (rax < 0) {
        goto label_7;
    }
    __asm ("cvtsi2sd xmm0, rax");
label_0:
    xmm1 = *(0x00436360);
    __asm ("mulsd xmm1, xmm0");
    if (rdx < 0) {
        goto label_8;
    }
    __asm ("cvtsi2sd xmm0, rdx");
label_3:
    __asm ("mulsd xmm0, qword [0x00436dd8]");
    __asm ("addsd xmm0, xmm1");
    __asm ("unpcklpd xmm0, xmm0");
    __asm ("cvtpd2ps xmm0, xmm0");
    __asm ("ucomiss xmm0, dword [0x00436de0]");
    if (rdx < 0) {
        if (rdx == 0) {
            goto label_4;
        }
        if (rax < 0) {
            goto label_9;
        }
        __asm ("cvtsi2ss xmm0, rax");
    }
label_4:
    rax = caml_stat_heap_size;
    rax >>= 3;
    __asm ("cvtsi2ss xmm2, rax");
    __asm ("ucomiss xmm0, xmm2");
    if (rax >= 0) {
        goto label_10;
    }
    __asm ("unpcklps xmm0, xmm0");
    __asm ("subss xmm2, xmm0");
    __asm ("cvtps2pd xmm1, xmm0");
    __asm ("mulsd xmm1, qword [0x00436cf8]");
    __asm ("unpcklps xmm2, xmm2");
    __asm ("cvtps2pd xmm2, xmm2");
    __asm ("divsd xmm1, xmm2");
    __asm ("unpcklpd xmm1, xmm1");
    __asm ("cvtpd2ps xmm0, xmm1");
    __asm ("ucomiss xmm0, dword [0x00436de4]");
    if (rax > 0) {
        goto label_10;
    }
    __asm ("ucomiss xmm0, dword [0x00436d04]");
    if (rax < 0) {
        goto label_11;
    }
    xmm1 = xmm0;
    rax = 0x8000000000000000;
    __asm ("subss xmm1, dword [0x00436d04]");
    __asm ("cvttss2si rbx, xmm1");
    rbx ^= rax;
    while (rax < 0) {
label_6:
        return rax;
label_10:
        ebx = 0xf4240;
        xmm0 = *(0x00436de4);
label_1:
        esi = "FL size at phase change = %lu\n";
        edi = 0x200;
        *(rsp) = xmm0;
        caml_gc_message ();
        rdx = rbx;
        esi = "Estimated overhead = %lu%%\n";
        edi = 0x200;
        caml_gc_message ();
        rax = caml_percent_max;
        xmm0 = *(rsp);
        if (rax < 0) {
            goto label_12;
        }
        __asm ("cvtsi2ss xmm1, rax");
label_2:
        __asm ("ucomiss xmm0, xmm1");
    }
    edx = 0;
    esi = "Automatic compaction triggered.\n";
    edi = 0x200;
    caml_gc_message ();
    caml_finish_major_cycle ();
    rax = caml_fl_cur_size;
    if (rax < 0) {
        goto label_13;
    }
    __asm ("cvtsi2ss xmm2, rax");
label_5:
    rax = caml_stat_heap_size;
    __asm ("unpcklps xmm2, xmm2");
    rax >>= 3;
    __asm ("cvtps2pd xmm0, xmm2");
    __asm ("mulsd xmm0, qword [0x00436cf8]");
    __asm ("cvtsi2ss xmm1, rax");
    __asm ("subss xmm1, xmm2");
    __asm ("unpcklps xmm1, xmm1");
    __asm ("cvtps2pd xmm1, xmm1");
    __asm ("divsd xmm0, xmm1");
    __asm ("unpcklpd xmm0, xmm0");
    __asm ("cvtpd2ps xmm0, xmm0");
    __asm ("ucomiss xmm0, dword [0x00436d04]");
    if (rax >= 0) {
        goto label_14;
    }
    __asm ("cvttss2si rdx, xmm0");
    do {
        esi = "Measured overhead: %lu%%\n";
        edi = 0x200;
        rax = caml_gc_message ();
        void (*0x433200)() ();
label_7:
        rcx = rax;
        rbx = rax;
        rcx >>= 1;
        ebx &= 1;
        rcx |= rbx;
        __asm ("cvtsi2sd xmm0, rcx");
        __asm ("addsd xmm0, xmm0");
        goto label_0;
label_14:
        __asm ("subss xmm0, dword [0x00436d04]");
        rax = 0x8000000000000000;
        __asm ("cvttss2si rdx, xmm0");
        rdx ^= rax;
    } while (1);
label_11:
    __asm ("cvttss2si rbx, xmm0");
    goto label_1;
label_12:
    rdx = rax;
    eax &= 1;
    rdx >>= 1;
    rdx |= rax;
    __asm ("cvtsi2ss xmm1, rdx");
    __asm ("addss xmm1, xmm1");
    goto label_2;
label_8:
    rcx = rdx;
    rbx = rdx;
    rcx >>= 1;
    ebx &= 1;
    rcx |= rbx;
    __asm ("cvtsi2sd xmm0, rcx");
    __asm ("addsd xmm0, xmm0");
    goto label_3;
label_9:
    rcx = rax;
    eax &= 1;
    rcx >>= 1;
    rcx |= rax;
    __asm ("cvtsi2ss xmm0, rcx");
    __asm ("addss xmm0, xmm0");
    goto label_4;
label_13:
    rdx = rax;
    eax &= 1;
    rdx >>= 1;
    rdx |= rax;
    __asm ("cvtsi2ss xmm2, rdx");
    __asm ("addss xmm2, xmm2");
    goto label_5;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a480 */
#include <stdint.h>
 
void caml_log_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    log (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b7c0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1791 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_execve);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b840 */
#include <stdint.h>
 
int64_t camlUnix_fun_1799 (void) {
    rdi = rax;
    rax = *(reloc.unix_environment);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a2b0 */
#include <stdint.h>
 
int64_t camlBuffer_reset_92 (void) {
    rbx = rax;
    *((rbx + 8)) = 1;
    rsi = *((rbx + 0x18));
    rdi = rbx;
    caml_modify ();
    rdi = *(rbx);
    rax = *((rdi - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rdi = *((rdi + rax));
    rax -= rdi;
    rax = rax + rax + 1;
    *((rbx + 0x10)) = rax;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b2e0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1713 (void) {
    rdi = rax;
    rax = *(reloc.unix_chdir);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f5a0 */
#include <stdint.h>
 
void caml_sys_init (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    *(obj.caml_exe_name) = rdi;
    *(obj.caml_main_argv) = rsi;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429ca0 */
#include <stdint.h>
 
void caml_nativeint_to_int32 (int64_t arg1) {
    rdi = arg1;
    rdi = *((rdi + 8));
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427540 */
#include <stdint.h>
 
int64_t caml_page_table_lookup (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rax = 0x9e3779b97f4a7c16;
    ecx = .comment;
    rdx >>= 0xc;
    rsi = .comment;
    rdx *= rax;
    rdx >>= cl;
    rax = *((rsi + rdx*8));
    rcx = *((rsi + rdx*8));
    rcx ^= rdi;
    if ((rcx & 0xfffffffffffff000) == 0) {
        goto label_0;
    }
    if (rax == 0) {
        goto label_1;
    }
    rdx++;
    r8 = .comment;
    while ((rcx & 0xfffffffffffff000) != 0) {
        if (rax == 0) {
            goto label_1;
        }
        rdx++;
        rdx &= r8;
        rax = *((rsi + rdx*8));
        rcx = *((rsi + rdx*8));
        rcx ^= rdi;
    }
label_0:
    eax &= 0xff;
    return rax;
label_1:
    eax = 0;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429ec0 */
#include <stdint.h>
 
uint64_t caml_lt_float (int64_t arg2) {
    rsi = arg2;
    xmm0 = *(rsi);
    eax = 0;
    __asm ("ucomisd xmm0, qword [rdi]");
    al = (? > ?) ? 1 : 0;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fab0 */
#include <stdint.h>
 
int64_t camlPervasives_fun_430 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_input_char);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e5d0 */
#include <stdint.h>
 
int64_t camlPrintf_printf_425 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    *(rsp) = rax;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0xb8));
    rax = camlPrintf_fprintf_423 ();
    rbx = rax;
    rdi = *(rbx);
    rax = *(rsp);
    return void (*rdi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ba90 */
#include <stdint.h>
 
int64_t camlUnix_write_270 (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = rdi;
    rcx = rsi;
    if (rdx >= 1) {
        if (rcx < 1) {
            goto label_0;
        }
        rdi = *((rbx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rbx + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= rcx;
        rdi += 2;
        if (rdx > rdi) {
            goto label_0;
        }
        rdi = rax;
        rsi = rbx;
        rax = *(reloc.unix_write);
        caml_c_call ();
        return rax;
    }
label_0:
    rax = *(loc.camlUnix__206);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41daa0 */
#include <stdint.h>
 
int64_t camlPrintf_sub_format_145 (int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rcx = rax;
    rax = *((rsi - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    r8 = *((rsi + rax));
    rax -= r8;
    r9 = rax + rax + 1;
    do {
        r15 -= 0x40;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            r8 = r15 + 8;
            *((r8 - 8)) = 0x1cf7;
            rax = *(reloc.caml_curry2);
            *(r8) = rax;
            *((r8 + 8)) = 5;
            rax = *(reloc.camlPrintf__sub_fmt_152);
            *((r8 + 0x10)) = rax;
            *((r8 + 0x18)) = rcx;
            *((r8 + 0x20)) = rbx;
            *((r8 + 0x28)) = rsi;
            *((r8 + 0x30)) = r9;
            rax = rdi;
            rbx = rdx;
            rdi = r8;
            void (*0x41b5a0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42dcf0 */
#include <stdint.h>
 
uint64_t caml_output_value_to_string (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    init_extern_output ();
    rdi = rbx;
    rsi = rbp;
    rax = extern_value ();
    rbx = extern_output_first;
    rdi = rax;
    rax = caml_alloc_string ();
    r13 = rax;
    if (rbx == 0) {
        goto label_0;
    }
    ebp = 0;
    do {
        r12 = *((rbx + 8));
        r12d -= esi;
        r12 = (int64_t) r12d;
        rbp += r12;
        memmove (rbp + r13, rbx + 0x10, r12);
        r12 = *(rbx);
        free (rbx);
        rbx = r12;
    } while (r12 != 0);
label_0:
    rax = r13;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ab50 */
#include <stdint.h>
 
int64_t camlUnix_fun_1593 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_tcsendbreak);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a9e0 */
#include <stdint.h>
 
uint64_t caml_bitvect_test (int64_t arg2) {
    rsi = arg2;
    rsi >>= 1;
    eax = 1;
    edx = esi;
    ecx = esi;
    edx >>= 3;
    ecx &= 7;
    rdx = (int64_t) edx;
    eax <<= cl;
    al &= *((rdx + rdi));
    eax = (int32_t) al;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4174b0 */
#include <stdint.h>
 
int64_t camlString_rindex_rec_149 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, uint32_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rbx < 1) {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_1;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            rax = caml_raise_exn ();
        }
        rsi = rbx;
        rsi >>= 1;
        rsi = *((rax + rsi));
        rsi = rsi + rsi + 1;
        if (rsi == rdi) {
            rax = rbx;
            return rax;
        }
        rbx += 0xfffffffffffffffe;
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ad70 */
#include <stdint.h>
 
int64_t camlUnix_fun_1627 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_socketpair);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416c60 */
#include <stdint.h>
 
int64_t camlString_concat_94 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rbx == 1) {
        goto label_1;
    }
    *((rsp + 0x18)) = rax;
    rax = *((rbx + 8));
    *((rsp + 0x20)) = rax;
    rax = *(rbx);
    *((rsp + 0x10)) = rax;
label_0:
    r15 -= 0x48;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_2;
    }
    rdx = r15 + 8;
    *(rsp) = rdx;
    *((rdx - 8)) = 0x400;
    *(rdx) = 1;
    rsi = rdx + 0x10;
    *((rsp + 8)) = rsi;
    *((rsi - 8)) = 0x400;
    *(rsi) = 1;
    rax = rdx + 0x20;
    *((rax - 8)) = 0x10f7;
    rdi = *(reloc.camlString__fun_188);
    *(rax) = rdi;
    *((rax + 8)) = 3;
    *((rax + 0x10)) = rdx;
    *((rax + 0x18)) = rsi;
    camlList_iter_102 ();
    rax = *(rsp);
    rdi = *(rax);
    rdi += 0xfffffffffffffffe;
    rdi >>= 1;
    rax = *((rsp + 0x18));
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rax = *((rax + rbx));
    rbx -= rax;
    rbx <<= 1;
    rbx *= rdi;
    rax = *((rsp + 8));
    rdi = *(rax);
    rdi += rbx;
    rax = *(reloc.caml_create_string);
    rax = caml_c_call ();
    *(rsp) = rbp;
    rbx = *((rsp + 0x10));
    rax = *((rbx - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rdi = *((rbx + rax));
    rax -= rdi;
    r8 = rax + rax + 1;
    rcx = 1;
    rsi = 1;
    rdi = rbx;
    rdx = rbp;
    caml_blit_string ();
    do {
        r15 -= 0x40;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x400;
            rax = *((rbx - 8));
            rax >>= 0xa;
            rax = rax*8 - 1;
            rbx = *((rbx + rax));
            rax -= rbx;
            rax = rax + rax + 1;
            *(rdi) = rax;
            rax = rdi + 0x10;
            *((rax - 8)) = 0x14f7;
            rbx = *(reloc.camlString__fun_191);
            *(rax) = rbx;
            *((rax + 8)) = 3;
            rbx = *((rsp + 0x18));
            *((rax + 0x10)) = rbx;
            *((rax + 0x18)) = rbp;
            *((rax + 0x20)) = rdi;
            rbx = *((rsp + 0x20));
            camlList_iter_102 ();
            rax = *(rsp);
            return rax;
label_1:
            rax = *(loc.camlString__29);
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d840 */
#include <stdint.h>
 
int64_t camlPrintf_extract_format_113 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
    *(rsp) = rdx;
    *((rsp + 8)) = rdi;
    *((rsp + 0x18)) = rsi;
label_0:
    r15 -= 0x20;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    rdi = r15 + 8;
    *((rsp + 0x10)) = rdi;
    *((rdi - 8)) = 0xcf7;
    rax = *(reloc.camlPrintf__skip_positional_spec_118);
    *(rdi) = rax;
    *((rdi + 8)) = 3;
    *((rdi + 0x10)) = rdx;
    rbx += 2;
    rax = rbx;
    rbx = rdi;
    rax = camlPrintf_skip_positional_spec_118 ();
    rbx = rax;
    *((rsp + 0x20)) = rbx;
    rax = *((rsp + 8));
    rax -= rbx;
    rax += 0x15;
    rax = camlBuffer_create_67 ();
    *((rsp + 0x30)) = rax;
    rbx = 0x4b;
    camlBuffer_add_char_100 ();
    do {
        r15 -= 0x40;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rsp + 0x28)) = rbx;
            *((rbx - 8)) = 0x1cf7;
            rax = *(reloc.caml_curry2);
            *(rbx) = rax;
            *((rbx + 8)) = 5;
            rax = *(reloc.camlPrintf__fill_format_124);
            *((rbx + 0x10)) = rax;
            rax = *(rsp);
            *((rbx + 0x18)) = rax;
            rax = *((rsp + 8));
            *((rbx + 0x20)) = rax;
            rax = *((rsp + 0x10));
            *((rbx + 0x28)) = rax;
            rax = *((rsp + 0x30));
            *((rbx + 0x30)) = rax;
            rbx = 1;
            rax = *((rsp + 0x18));
            rax = camlList_rev_append_79 ();
            rbx = rax;
            rax = *((rsp + 0x20));
            rdi = *((rsp + 0x28));
            camlPrintf_fill_format_124 ();
            rax = *((rsp + 0x30));
            rdi = *((rax + 8));
            rbx = 1;
            rax = *(rax);
            void (*0x416a50)() ();
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e290 */
#include <stdint.h>
 
void caml_deserialize_float_8 (void) {
    int64_t var_8h;
    esi = 1;
    rdi = rsp + 8;
    caml_deserialize_block_float_8 ();
    xmm0 = *((rsp + 8));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e260 */
#include <stdint.h>
 
void caml_deserialize_block_float_8 (void * s1) {
    rdi = s1;
    rbx = rsi*8;
    memmove (rdi, *(obj.intern_src), rbx);
    *(obj.intern_src) += rbx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x430bf0 */
#include <stdint.h>
 
uint64_t caml_gc_get (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_48h;
    edi = 7;
    rbx = caml_local_roots;
    rax = rsp + 0x48;
    *((rsp + 0x48)) = 0;
    *(obj.caml_local_roots) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 8)) = 1;
    *(rsp) = rbx;
    *((rsp + 0x18)) = rax;
    rax = caml_alloc_tuple ();
    rdx = caml_minor_heap_size;
    rdi = rax;
    *((rsp + 0x48)) = rax;
    rdx >>= 3;
    rsi = rdx + rdx + 1;
    caml_modify ();
    rax = caml_major_heap_increment;
    rdi = *((rsp + 0x48));
    rax >>= 3;
    rdi += 8;
    rsi = rax + rax + 1;
    caml_modify ();
    rax = caml_percent_free;
    rdi = *((rsp + 0x48));
    rsi = rax + rax + 1;
    rdi += 0x10;
    caml_modify ();
    rax = caml_verb_gc;
    rdi = *((rsp + 0x48));
    rsi = rax + rax + 1;
    rdi += 0x18;
    caml_modify ();
    rax = caml_percent_max;
    rdi = *((rsp + 0x48));
    rsi = rax + rax + 1;
    rdi += 0x20;
    caml_modify ();
    rdi = *((rsp + 0x48));
    esi = 1;
    rdi += 0x28;
    caml_modify ();
    rax = caml_allocation_policy;
    rdi = *((rsp + 0x48));
    rsi = rax + rax + 1;
    rdi += 0x30;
    caml_modify ();
    *(obj.caml_local_roots) = rbx;
    rax = *((rsp + 0x48));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428510 */
#include <stdint.h>
 
void caml_alloc_tuple (int64_t arg1) {
    rdi = arg1;
    esi = 0;
    return caml_alloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b3e0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1729 (void) {
    rdi = rax;
    rax = *(reloc.unix_dup);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c130 */
#include <stdint.h>
 
int64_t camlUnix_getaddrinfo_emulation_756 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    *((rsp + 0x18)) = rax;
    *(rsp) = rbx;
    rbx = rdi;
    *((rsp + 0x20)) = rbx;
label_6:
    r15 -= 0x60;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_7;
    }
    r8 = r15 + 8;
    *((rsp + 8)) = r8;
    *((r8 - 8)) = 0x400;
    *(r8) = 1;
    rcx = r8 + 0x10;
    *((rsp + 0x10)) = rcx;
    *((rcx - 8)) = 0x400;
    *(rcx) = 1;
    rdx = r8 + 0x20;
    *((rdx - 8)) = 0x400;
    *(rdx) = 1;
    rax = r8 + 0x30;
    *((rax - 8)) = 0x14f7;
    rsi = *(reloc.camlUnix__fun_1847);
    *(rax) = rsi;
    *((rax + 8)) = 3;
    *((rax + 0x10)) = r8;
    *((rax + 0x18)) = rcx;
    *((rax + 0x20)) = rdx;
    camlList_iter_102 ();
label_5:
    r15 -= 0x28;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_8;
    }
    rdi = r15 + 8;
    *((rdi - 8)) = 0x10f7;
    rax = *(reloc.caml_curry2);
    *(rdi) = rax;
    *((rdi + 8)) = 5;
    rax = *(reloc.camlUnix__get_port_765);
    *((rdi + 0x10)) = rax;
    rsi = *(rsp);
    *((rdi + 0x18)) = rsi;
    rax = *((rsp + 8));
    rax = *(rax);
    if (rax != 1) {
        rbx = *(rax);
        if (rbx != 3) {
            if (rbx != 1) {
                rax = *(loc.camlUnix__200);
                rdi = rsi;
                rsi = rax;
                rax = caml_string_equal ();
                if (rax != 1) {
label_4:
                    r15 -= 0x30;
                    rax = *(reloc.caml_young_limit);
                    if (r15 < *(rax)) {
                        goto label_9;
                    }
                    rdi = r15 + 8;
                    *((rdi - 8)) = 0x800;
                    *(rdi) = rbx;
                    *((rdi + 8)) = 1;
                    rax = rdi + 0x18;
                    *(rsp) = rax;
                    *((rax - 8)) = 0x800;
                    *(rax) = rdi;
                    *((rax + 8)) = 1;
                    rax = 1;
                    *(rsp) = rax;
                    rbx = *(loc.camlUnix__199);
                    rax = 1;
                    rax = camlUnix_get_port_765 ();
                    *(rsp) = rax;
                    rbx = *(loc.camlUnix__198);
                    rax = 3;
                    rax = camlUnix_get_port_765 ();
                    *(rsp) = rax;
                } else {
                } else {
                } else {
                } else {
                    *(rsp) = rdi;
                    rbx = *(loc.camlUnix__197);
                    rax = 3;
                    rax = camlUnix_get_port_765 ();
                    *((rsp + 8)) = rax;
                    rbx = *(loc.camlUnix__196);
                    rax = 1;
                    rdi = *(rsp);
                    camlUnix_get_port_765 ();
                    rbx = *((rsp + 8));
                    rax = camlPervasives_$40_167 ();
                    *(rsp) = rax;
                }
            }
        }
    }
    rsi = *(loc.camlUnix__195);
    rbx = *((rsp + 0x18));
    rdi = *((rsp + 0x18));
    rax = caml_string_equal ();
    if (rax != 1) {
        rax = 5;
        rbx = *((rsp + 0x20));
        rax = camlList_mem_189 ();
        if (rax != 1) {
label_3:
            r15 -= 0x30;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_10;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            rax = *(reloc.camlUnix);
            rax = *((rax + 0x358));
            *(rbx) = rax;
            rax = *(loc.camlUnix__194);
            *((rbx + 8)) = rax;
            rdi = rbx + 0x18;
            *((rdi - 8)) = 0x800;
            *(rdi) = rbx;
            *((rdi + 8)) = 1;
label_2:
            r15 -= 0x30;
            rax = *(reloc.caml_young_limit);
        } else {
        } else {
        }
    }
    if (r15 < *(rax)) {
        goto label_11;
    }
    rbx = r15 + 8;
    *((rbx - 8)) = 0x800;
    rax = *(reloc.camlUnix);
    rax = *((rax + 0x360));
    *(rbx) = rax;
    rax = *(loc.camlUnix__193);
    *((rbx + 8)) = rax;
    rdi = rbx + 0x18;
    *((rdi - 8)) = 0x800;
    *(rdi) = rbx;
    *((rdi + 8)) = 1;
    *((rsp + 0x18)) = rbx;
    rax = void (*0x40c4cc)() ();
    rdi = *(reloc.caml_exn_Failure);
    rbx = *(rax);
    if (rbx == rdi) {
        rax = void (*0x40c450)() ();
        rdi = *(reloc.caml_exn_Not_found);
        rbx = *(rax);
        if (rbx == rdi) {
            rdi = 1;
        } else {
            rax = caml_raise_exn ();
        }
        r14 = rsp;
        rdi = *((rsp + 0x28));
        rax = *(reloc.unix_gethostbyname);
        rax = caml_c_call ();
        *((rsp + 0x18)) = rax;
        rax = *((rax + 0x18));
        rax = camlArray_to_list_148 ();
        rbx = rax;
label_1:
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_12;
        }
        rax = r15 + 8;
        *((rax - 8)) = 0xcf7;
        rdi = *(reloc.camlUnix__fun_1852);
        *(rax) = rdi;
        *((rax + 8)) = 3;
        rdi = *((rsp + 0x18));
        *((rax + 0x10)) = rdi;
        rax = camlList_map_90 ();
        rdi = rax;
    } else {
        rax = caml_raise_exn ();
        r14 = rsp;
        rdi = rbx;
        rax = *(reloc.unix_inet_addr_of_string);
        rax = caml_c_call ();
        rdi = rax;
label_0:
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_13;
        }
        rbx = r15 + 8;
        *((rbx - 8)) = 0x800;
        *(rbx) = rdi;
        rax = *((rsp + 0x28));
        *((rbx + 8)) = rax;
        rdi = rbx + 0x18;
        *((rdi - 8)) = 0x800;
        *(rdi) = rbx;
        *((rdi + 8)) = 1;
    }
    do {
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x14f7;
            rbx = *(reloc.caml_tuplify2);
            *(rax) = rbx;
            *((rax + 8)) = 0xfffffffffffffffd;
            rbx = *(reloc.camlUnix__fun_1855);
            *((rax + 0x10)) = rbx;
            rbx = *((rsp + 0x10));
            *((rax + 0x18)) = rbx;
            *((rax + 0x20)) = rdi;
            rbx = *(rsp);
            camlList_map_90 ();
            void (*0x4153e0)() ();
        }
        caml_call_gc ();
    } while (1);
label_13:
    caml_call_gc ();
    goto label_0;
label_12:
    caml_call_gc ();
    goto label_1;
label_11:
    caml_call_gc ();
    goto label_2;
label_10:
    caml_call_gc ();
    goto label_3;
label_9:
    caml_call_gc ();
    goto label_4;
label_8:
    caml_call_gc ();
    goto label_5;
label_7:
    caml_call_gc ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x435000 */
#include <stdint.h>
 
void libc_csu_fini (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42def0 */
#include <stdint.h>
 
int64_t caml_deserialize_sint_2 (void) {
    rax = intern_src;
    rdx = rax + 2;
    *(obj.intern_src) = rdx;
    rax = *(rax);
    edx = *((rdx - 1));
    rax <<= 8;
    rax += rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410730 */
#include <stdint.h>
 
int64_t camlPervasives_read_int_313 (void) {
    rax = 1;
    rax = camlPervasives_read_line_312 ();
    rdi = rax;
    rax = *(reloc.caml_int_of_string);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4106f0 */
#include <stdint.h>
 
int64_t camlPervasives_read_line_312 (void) {
    rax = *(reloc.camlPervasives);
    rdi = *((rax + 0xb8));
    rax = *(reloc.caml_ml_flush);
    caml_c_call ();
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0xb0));
    return camlPervasives_input_line_265 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429690 */
#include <stdint.h>
 
uint64_t caml_nativeint_of_string (int64_t arg1) {
    rdi = arg1;
    esi = 0x40;
    rax = parse_intnat ();
    rdi = rax;
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b3a0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1725 (void) {
    rdi = rax;
    rax = *(reloc.unix_set_nonblock);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bd10 */
#include <stdint.h>
 
int64_t camlUnix_domain_of_sockaddr_555 (void) {
    rbx = *((rax - 8));
    if (rbx != 0) {
        rbx = *(rax);
        rax = *((rbx - 8));
        rax >>= 0xa;
        rax = rax*8 - 1;
        rbx = *((rbx + rax));
        rax -= rbx;
        rax = rax + rax + 1;
        if (rax == 0x21) {
            rax = 5;
            return rax;
        }
        rax = 3;
        return rax;
    }
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429e30 */
#include <stdint.h>
 
int32_t caml_int32_add (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    eax = *((rsi + 8));
    eax += *((rdi + 8));
    edi = eax;
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427be0 */
#include <stdint.h>
 
uint32_t caml_page_table_add (int64_t arg3, uint32_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rsi &= 0xfffffffffffff000;
    r12d = edi;
    rbp = rdx - 1;
    rbp &= 0xfffffffffffff000;
    if (rsi > rbp) {
        goto label_0;
    }
    rbx = rsi;
    while (eax == 0) {
        rbx += 0x1000;
        if (rbp < rbx) {
            goto label_0;
        }
        esi = 0;
        edx = r12d;
        rdi = rbx;
        eax = caml_page_table_modify ();
    }
    eax = 0xffffffff;
    return eax;
label_0:
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415d40 */
#include <stdint.h>
 
int64_t camlList_find_229 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        rsi = rax;
        if (rbx == 1) {
            goto label_0;
        }
        rax = *((rbx + 8));
        rax = *(rbx);
        rdi = *(rsi);
        rbx = rsi;
        rax = void (*rdi)(uint64_t, uint64_t) (rsi, rax);
        if (rax != 1) {
            rax = *((rsp + 0x10));
            return rax;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
    } while (1);
    do {
label_0:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417910 */
#include <stdint.h>
 
int64_t camlSys_catch_break_110 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    while (1) {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x400;
            rax = *(loc.camlSys__5);
            *(rbx) = rax;
            rax = 0xfffffffffffffff5;
            void (*0x4178e0)() ();
            rbx = 1;
            rax = 0xfffffffffffffff5;
            void (*0x4178e0)() ();
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4108f0 */
#include <stdint.h>
 
int64_t camlPervasives_at_exit_346 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0x290));
    rbx = *(rax);
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x10f7;
            rax = *(reloc.camlPervasives__fun_524);
            *(rsi) = rax;
            *((rsi + 8)) = 3;
            *((rsi + 0x10)) = rdi;
            *((rsi + 0x18)) = rbx;
            rax = *(reloc.camlPervasives);
            rdi = *((rax + 0x290));
            caml_modify ();
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ab90 */
#include <stdint.h>
 
int64_t camlUnix_fun_1597 (void) {
    rdi = rax;
    rax = *(reloc.unix_tcgetattr);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434fac */
#include <stdint.h>
 
int64_t caml_callback2_exn (int64_t arg3, int64_t arg2) {
    rdx = arg3;
    rsi = arg2;
    do {
        r15 = caml_young_ptr;
        r14 = caml_exception_pointer;
        r14 = rsp;
        void (*r12)(uint64_t, uint64_t, uint64_t*, uint64_t*, uint64_t*) (r14, 0x00434f01, *(obj.caml_bottom_of_stack), *(obj.caml_last_return_address), *(obj.caml_gc_regs));
        *(obj.caml_young_ptr) = r15;
        *(obj.caml_exception_pointer) = r14;
        return;
        rax = rsi;
        rbx = rdx;
        r12 = sym_caml_apply2;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4099d0 */
#include <stdint.h>
 
int64_t caml_curry9 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            rdi = *(reloc.caml_curry9_1);
            *(rax) = rdi;
            *((rax + 8)) = 3;
            *((rax + 0x10)) = rsi;
            *((rax + 0x18)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425a80 */
#include <stdint.h>
 
int64_t caml_fl_allocate (uint32_t arg1) {
    rdi = arg1;
    rax = caml_allocation_policy;
    if (rax != 0) {
        goto label_6;
    }
    rdx = fl_prev;
    rcx = *(rdx);
    rbx = rdx;
    if (rcx == 0) {
        goto label_7;
    }
    rax = *((rcx - 8));
    rax >>= 0xa;
    if (rdi > rax) {
        goto label_8;
    }
    goto label_9;
    do {
        rax = *((rcx - 8));
        rax >>= 0xa;
        if (rax >= rdi) {
            goto label_10;
        }
label_8:
        rbx = rcx;
        rcx = *(rcx);
    } while (rcx != 0);
label_7:
    eax = 0x64de30;
    *(obj.fl_last) = rbx;
    rcx = .comment;
    if (rdx != rax) {
        goto label_11;
    }
    goto label_12;
    do {
        rax = rcx;
        rcx = *(rcx);
        if (rdx == rax) {
            goto label_12;
        }
label_11:
        rbx = *((rcx - 8));
        rbx >>= 0xa;
    } while (rdi > rbx);
    rdi++;
    rdx = rax;
    esi = 0;
    rax = allocate_block ();
    r13 = rax;
    goto label_1;
label_6:
    if (rax != 1) {
label_12:
        r13d = 0;
label_1:
        rax = r13;
        return rax;
    }
    esi = flp_size;
    if (esi <= 0) {
        goto label_13;
    }
    rdx = flp;
    ebp = 0;
    eax = 0x650468;
    rcx = *(rdx);
    rbx = *((rcx - 8));
    rbx >>= 0xa;
    if (rdi > rbx) {
        goto label_14;
    }
    goto label_15;
    do {
        rdx = *(rax);
        rax += 8;
        rcx = *(rdx);
        rbx = *((rcx - 8));
        rbx >>= 0xa;
        if (rdi <= rbx) {
            goto label_15;
        }
label_14:
        ebp++;
    } while (ebp < esi);
label_3:
    eax = rsi - 1;
    rcx = beyond;
    rax = (int64_t) eax;
    rax = *((rax*8 + obj.flp));
    rdx = *(rax);
    rax = *((rdx - 8));
    rax >>= 0xa;
    if (rcx != 0) {
        rdx = rcx;
    }
label_4:
    ecx = 0;
    while (esi <= 0x3e7) {
        rcx = *(rdx);
        if (rcx == 0) {
            goto label_16;
        }
        rbx = *((rcx - 8));
        rbx >>= 0xa;
        if (rax < rbx) {
            rax = (int64_t) esi;
            esi++;
            *((rax*8 + obj.flp)) = rdx;
            if (rdi <= rbx) {
                goto label_17;
            }
            rax = rbx;
        }
        rdx = rcx;
    }
    *(obj.flp_size) = esi;
    *(obj.beyond) = rcx;
    rdx = rcx;
    if (rcx == 0) {
        goto label_18;
    }
label_5:
    rax = .comment;
    rax = *(rax);
    rbp = *((rax - 8));
    rax = *(rdx);
    rbp >>= 0xa;
    if (rax != 0) {
        goto label_19;
    }
    goto label_20;
    do {
        if (rdi <= rbx) {
            goto label_21;
        }
label_0:
        rbx = *(rax);
        rdx = rax;
        if (rbx == 0) {
            goto label_22;
        }
        rax = rbx;
label_19:
        rbx = *((rax - 8));
        rbx >>= 0xa;
    } while (rbp <= rbx);
    rcx = rax;
    goto label_0;
label_17:
    *(obj.flp_size) = esi;
    *(obj.beyond) = rcx;
label_15:
    rdi++;
    esi = ebp;
    rax = allocate_block ();
    r8d = flp_size;
    r13 = rax;
    if (ebp >= r8d) {
        goto label_1;
    }
    esi = 0;
    if (ebp > 0) {
        eax = rbp - 1;
        rax = (int64_t) eax;
        rax = *((rax*8 + obj.flp));
        rax = *(rax);
        rsi = *((rax - 8));
        rsi >>= 0xa;
    }
    r9d = r8 - 1;
    if (r9d == ebp) {
        goto label_23;
    }
    eax = rbp + 1;
    r14 = (int64_t) ebp;
    r12d = 0;
    rdx = *((r14*8 + obj.flp));
    rax = (int64_t) eax;
    rdi = *((rax*8 + obj.flp));
    while (rdx != rdi) {
        rcx = *(rdx);
        rax = *((rcx - 8));
        rax >>= 0xa;
        if (rsi < rax) {
            rsi = (int64_t) r12d;
            r12d++;
            *((rsp + rsi*8)) = rdx;
            if (rbx <= rax) {
                goto label_24;
            }
            rsi = rax;
        }
        rdx = rcx;
    }
label_24:
    r8d = r12 + r8;
    if (r8d > 0x3e9) {
        eax = r12 + rbp;
        if (eax > 0x3e7) {
            goto label_25;
        }
        if (r12d == 1) {
            goto label_26;
        }
        rax = (int64_t) eax;
        edx -= ebp;
        edx -= r12d;
        rdx = (int64_t) edx;
        rdx <<= 3;
        memmove (rax*8 + obj.flp, r14*8 + 0x650468, 0x3e8);
        if (r12d != 0) {
            goto label_26;
        }
label_2:
        rax = .comment;
        *(obj.flp_size) = 0x3e7;
        rax = *(rax);
        *(obj.beyond) = rax;
        goto label_1;
label_10:
        rdx = rbx;
label_9:
        rdi++;
        esi = 0;
        rax = allocate_block ();
        r13 = rax;
        goto label_1;
label_16:
        *(obj.fl_last) = rdx;
        *(obj.flp_size) = esi;
        if (rdx == 0x64de30) {
            rdx = rcx;
        }
        r13d = 0;
        *(obj.beyond) = rdx;
        goto label_1;
    }
    if (r12d == 1) {
        goto label_27;
    }
    eax = r12 + rbp;
    r9d -= ebp;
    rdx = (int64_t) r9d;
    rax = (int64_t) eax;
    rdx <<= 3;
    memmove (rax*8 + obj.flp, r14*8 + 0x650468, rdx);
    while (1) {
        eax = flp_size;
        r12d = r12 + rax - 1;
        *(obj.flp_size) = r12d;
        goto label_1;
label_22:
        *(obj.beyond) = rcx;
label_20:
        *(obj.fl_last) = rdx;
        r13d = 0;
        goto label_1;
label_23:
        rax = (int64_t) ebp;
        rax = *((rax*8 + obj.flp));
        rdx = *(rax);
        rax = *((rdx - 8));
        rax >>= 0xa;
        if (rsi < rax) {
            goto label_28;
        }
        *(obj.beyond) = rdx;
        *(obj.flp_size) = ebp;
        goto label_1;
label_27:
        rdx = (int64_t) r12d;
        rdx <<= 3;
        rax = memmove (r14*8 + obj.flp, rsp, rdx);
    }
label_21:
    *(obj.beyond) = rcx;
    rdi++;
    rcx = rax;
    rax = allocate_block ();
    r13 = rax;
    goto label_1;
label_25:
    if (ebp == 0x3e8) {
        goto label_2;
    }
    eax = 0x3e8;
    eax -= ebp;
    rax = (int64_t) eax;
    eax = memmove (r14*8 + obj.flp, rsp, rax*8);
    goto label_2;
label_28:
    *(obj.beyond) = 0;
    goto label_1;
    if (eax != 0) {
label_13:
        goto label_3;
    }
    edx = 0x64de30;
    eax = 0;
    goto label_4;
label_26:
    rdx = (int64_t) r12d;
    rdx <<= 3;
    memmove (r14*8 + obj.flp, rsp, rdx);
    goto label_2;
label_18:
    eax = rsi - 1;
    rax = (int64_t) eax;
    rdx = *((rax*8 + obj.flp));
    goto label_5;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42cd10 */
#include <stdint.h>
 
void caml_serialize_float_4 (int64_t arg7) {
    int64_t var_ch;
    xmm0 = arg7;
    esi = 1;
    rdi = rsp + 0xc;
    *((rsp + 0xc)) = xmm0;
    caml_serialize_block_4 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42cc80 */
#include <stdint.h>
 
uint64_t caml_serialize_block_4 (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rdi = rsi*4;
    rdx = extern_ptr;
    rax = rdx + rdi;
    if (*(obj.extern_limit) < rax) {
        goto label_1;
    }
label_0:
    if (rsi <= 0) {
        goto label_2;
    }
    rcx = rsi;
    eax = 0;
    do {
        r9d = *((rbx + rax + 3));
        r8d = *((rbx + rax));
        edi = *((rbx + rax + 1));
        *((rdx + rax)) = r9b;
        r9d = *((rbx + rax + 2));
        *((rdx + rax + 3)) = r8b;
        *((rdx + rax + 2)) = dil;
        *((rdx + rax + 1)) = r9b;
        rax += 4;
        rcx--;
    } while (rcx != 0);
    rdx = rdx + rsi*4;
label_2:
    *(obj.extern_ptr) = rdx;
    return rax;
label_1:
    *((rsp + 8)) = rsi;
    grow_extern_output ();
    rdx = extern_ptr;
    rsi = *((rsp + 8));
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e330 */
#include <stdint.h>
 
int64_t camlPrintf_scan_format_310 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        r15 -= 0xc8;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x10f7;
            r11 = *(reloc.caml_curry2);
            *(rax) = r11;
            *((rax + 8)) = 5;
            r11 = *(reloc.camlPrintf__get_arg_320);
            *((rax + 0x10)) = r11;
            *((rax + 0x18)) = rbx;
            r11 = rax + 0x28;
            *((r11 - 8)) = 0x4cf7;
            rbx = *(reloc.caml_curry3);
            *(r11) = rbx;
            *((r11 + 8)) = 7;
            rbx = *(reloc.camlPrintf__scan_positional_323);
            *((r11 + 0x10)) = rbx;
            *((r11 + 0x18)) = 0x10f9;
            rbx = *(reloc.caml_curry4);
            *((r11 + 0x20)) = rbx;
            *((r11 + 0x28)) = 9;
            rbx = *(reloc.camlPrintf__scan_flags_324);
            *((r11 + 0x30)) = rbx;
            *((r11 + 0x38)) = 0x20f9;
            rbx = *(reloc.caml_curry4);
            *((r11 + 0x40)) = rbx;
            *((r11 + 0x48)) = 9;
            rbx = *(reloc.camlPrintf__scan_conv_325);
            *((r11 + 0x50)) = rbx;
            *((r11 + 0x58)) = rbp;
            *((r11 + 0x60)) = rsi;
            *((r11 + 0x68)) = rdx;
            *((r11 + 0x70)) = rcx;
            *((r11 + 0x78)) = r8;
            *((r11 + 0x80)) = r9;
            *((r11 + 0x88)) = r10;
            *((r11 + 0x90)) = rax;
            rsi += 2;
            rbx = 1;
            rax = rdi;
            rdi = rsi;
            rsi = r11;
            void (*0x41d1e0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x430a20 */
#include <stdint.h>
 
int32_t caml_gc_major (void) {
    edx = 0;
    esi = "Major GC cycle requested\n";
    edi = 1;
    caml_gc_message ();
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    test_and_compact ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4349c0 */
#include <stdint.h>
 
int64_t caml_print_exception_backtrace (void) {
    int64_t var_8h;
    edx = caml_backtrace_pos;
    if (edx <= 0) {
        goto label_0;
    }
    ebp = 0;
    ebx = 0;
    r12d = "Re-raised at";
    r13d = "Called from";
    do {
        rax = caml_backtrace_buffer;
        rax = *((rax + rbp));
        if ((*((rax + 8)) & 1) != 0) {
            edx = *((rax + 0xa));
            ecx = "Raised at";
            rax = rax + rdx*2 + 0x13;
            rax &= 0xfffffffffffffff8;
            edi = *(rax);
            r9d = *((rax + 4));
            if (ebx != 0) {
                rcx = r13;
                if ((dil & 3) == 0) {
                    rcx = r12;
                    goto label_1;
                }
            }
label_1:
            esi = r9d;
            rdx = rdi;
            edi >>= 0x1a;
            esi &= 0xf;
            edx &= 0x3fffffc;
            esi <<= 6;
            r8 = rdx + rax;
            edx = "%s file \"%s\", line %d, characters %d-%d\n";
            esi |= edi;
            rdi = stderr;
            eax = 0;
            *((rsp + 8)) = esi;
            esi = r9d;
            r9d >>= 0xc;
            esi >>= 4;
            esi &= 0xff;
            *(rsp) = esi;
            esi = 1;
            fprintf_chk ();
        }
        ebx++;
        rbp += 8;
    } while (*(obj.caml_backtrace_pos) > ebx);
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418e60 */
#include <stdint.h>
 
int64_t camlHashtbl_resize_89 (void) {
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_18h_2;
    int64_t var_38h_2;
    int64_t var_38h;
    *(rsp) = rax;
    *((rsp + 0x18)) = rbx;
    rax = *((rbx + 8));
    *((rsp + 0x28)) = rax;
    rax = *((rax - 8));
    rax >>= 9;
    rax |= 1;
    *((rsp + 0x10)) = rax;
    rbx = *(reloc.camlSys);
    rbx = *((rbx + 0x30));
    rax >>= 1;
    rax = rax*4 + 3;
    rax = camlPervasives_min_50 ();
    rbx = *((rsp + 0x10));
    if (rax == rbx) {
        goto label_1;
    }
    *((rsp + 8)) = rax;
    *((rsp + 0x10)) = rbx;
    rsi = 1;
    rdi = rax;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = rax;
    *((rsp + 0x20)) = rbx;
label_0:
    r15 -= 0x30;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_2;
    }
    rdi = r15 + 8;
    *((rdi - 8)) = 0x14f7;
    rax = *(reloc.camlHashtbl__insert_bucket_96);
    *(rdi) = rax;
    *((rdi + 8)) = 3;
    rax = *(rsp);
    *((rdi + 0x10)) = rax;
    rax = *((rsp + 8));
    *((rdi + 0x18)) = rax;
    *((rdi + 0x20)) = rbx;
    rbx = 1;
    rax = *((rsp + 0x10));
    rax += 0xfffffffffffffffe;
    if (rbx > rax) {
        goto label_3;
    }
    *((rsp + 0x10)) = rax;
    *((rsp + 8)) = rbx;
    *(rsp) = rdi;
    do {
        rax = *((rsp + 0x28));
        rdi = *((rax - 8));
        rdi >>= 9;
        if (rdi <= rbx) {
            goto label_4;
        }
        rax = *((rax + rbx*4 - 4));
        rbx = *(rsp);
        camlHashtbl_insert_bucket_96 ();
        rbx = *((rsp + 8));
        rdi = *((rsp + 8));
        rbx += 2;
        *((rsp + 8)) = rbx;
        rax = *((rsp + 0x10));
    } while (rdi != rax);
label_3:
    rdi = *((rsp + 0x18));
    rdi += 8;
    rsi = *((rsp + 0x20));
    caml_modify ();
    rax = 1;
    return rax;
label_1:
    rax = 1;
    return rax;
label_2:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fb70 */
#include <stdint.h>
 
int64_t camlPervasives_fun_442 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_ml_output_int);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x411460 */
#include <stdint.h>
 
uint64_t camlArray_size_93 (void) {
    do {
        if (rbx == 1) {
            goto label_0;
        }
        rsi = *((rbx + 8));
        rdi = *(rbx);
        rdi = *((rdi - 8));
        rdi >>= 9;
        rdi |= 1;
        rax = rax + rdi - 1;
        rbx = rsi;
    } while (1);
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42d140 */
#include <stdint.h>
 
void caml_serialize_float_8 (int64_t arg7) {
    int64_t var_8h;
    xmm0 = arg7;
    esi = 1;
    rdi = rsp + 8;
    *((rsp + 8)) = xmm0;
    caml_serialize_block_float_8 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42d0e0 */
#include <stdint.h>
 
uint64_t caml_serialize_block_float_8 (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rdi = extern_ptr;
    rbx = rsi*8;
    rax = rdi + rbx;
    if (*(obj.extern_limit) < rax) {
        rdi = rbx;
        grow_extern_output ();
    }
    memmove (*(obj.extern_ptr), rbp, rbx);
    *(obj.extern_ptr) += rbx;
    rbp = *((rsp + 0x10));
    rbx = *((rsp + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ad30 */
#include <stdint.h>
 
int64_t camlUnix_fun_1623 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_bind);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fe10 */
#include <stdint.h>
 
uint64_t camlPervasives_bool_of_string_153 (void) {
    rbx = rax;
    rsi = *(loc.camlPervasives__99);
    rdi = rbx;
    rax = caml_string_notequal ();
    if (rax != 1) {
        rsi = *(loc.camlPervasives__98);
        rdi = rbx;
        rax = caml_string_notequal ();
        if (rax != 1) {
            rax = *(loc.camlPervasives__97);
            void (*0x40fc30)() ();
        }
        rax = 3;
        return rax;
    }
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40faf0 */
#include <stdint.h>
 
int64_t camlPervasives_fun_434 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_ml_set_binary_mode);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415360 */
#include <stdint.h>
 
int64_t camlList_nth_70 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rbx < 1) {
        rax = *(loc.camlList__49);
        void (*0x40fc30)() ();
    }
    rdi = *(loc.camlList__48);
    return camlList_nth_aux_73 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434110 */
#include <stdint.h>
 
int64_t caml_final_custom_operations (int64_t arg1) {
    rdi = arg1;
    rax = custom_ops_final_table;
    if (rax != 0) {
        goto label_0;
    }
    goto label_1;
    do {
        rax = *((rax + 8));
        if (rax == 0) {
            goto label_1;
        }
label_0:
        rbx = *(rax);
    } while (*((rbx + 8)) != rbp);
    rax = rbx;
    return rax;
label_1:
    edi = 0x30;
    caml_stat_alloc ();
    edi = 0x10;
    *((rax + 8)) = rbp;
    *(rax) = "_final";
    *((rax + 0x10)) = 0;
    *((rax + 0x18)) = 0;
    rbx = rax;
    *((rax + 0x20)) = 0;
    *((rax + 0x28)) = 0;
    caml_stat_alloc ();
    rdx = custom_ops_final_table;
    *(rax) = rbx;
    *((rax + 8)) = rdx;
    *(obj.custom_ops_final_table) = rax;
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42bd20 */
#include <stdint.h>
 
uint64_t caml_getblock (uint32_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x28)) = rbx;
    *((rsp - 0x20)) = rbp;
    *((rsp - 0x10)) = r13;
    *((rsp - 0x18)) = r12;
    r13 = rsi;
    *((rsp - 8)) = r14;
    rsi = *((rdi + 0x18));
    r12 = *((rdi + 0x20));
    rbx = rdi;
    if (rdx < 0x7fffffff) {
    }
    r12d -= esi;
    if (ebp <= r12d) {
        goto label_1;
    }
    if (r12d <= 0) {
        goto label_2;
    }
    rbp = (int64_t) r12d;
    memmove (r13, rsi, rbp);
    *((rbx + 0x18)) += rbp;
    do {
label_0:
        eax = r12d;
        rbx = *(rsp);
        rbp = *((rsp + 8));
        r12 = *((rsp + 0x10));
        r13 = *((rsp + 0x18));
        r14 = *((rsp + 0x20));
        return eax;
label_2:
        rdx = *((rdi + 0x10));
        r12 = rdi + 0x50;
        edi = *(rdi);
        rsi = r12;
        edx -= r12d;
        eax = caml_do_read ();
        rdx = (int64_t) eax;
        *((rbx + 8)) += rdx;
        rdx = rbx + rdx + 0x50;
        if (ebp > eax) {
        }
        r14 = (int64_t) ebp;
        *((rbx + 0x20)) = rdx;
        memmove (r13, r12, r14);
        rax = rbx + r14 + 0x50;
        *((rbx + 0x18)) = rax;
    } while (1);
label_1:
    r12 = (int64_t) ebp;
    memmove (r13, rsi, r12);
    *((rbx + 0x18)) += r12;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b9d0 */
#include <stdint.h>
 
uint64_t caml_do_read (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r12d = edi;
    ebx = edx;
    do {
        caml_enter_blocking_section ();
        eax = read (r12d, rbp, rbx);
        r13d = eax;
        caml_leave_blocking_section ();
        if (r13d != 0xffffffff) {
            goto label_0;
        }
        rax = errno_location ();
    } while (*(rax) == 4);
    edi = 1;
    caml_sys_io_error ();
label_0:
    eax = r13d;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408f40 */
#include <stdint.h>
 
void read (void) {
    read ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429e40 */
#include <stdint.h>
 
void caml_int32_neg (int64_t arg1) {
    rdi = arg1;
    edi = *((rdi + 8));
    edi = -edi;
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4271b0 */
#include <stdint.h>
 
uint64_t caml_check_urgent_gc (int64_t arg1) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_18h_2;
    int64_t var_20h_2;
    int64_t var_28h;
    rdi = arg1;
    rbx = caml_local_roots;
    rax = rsp + 0x10;
    *((rsp + 8)) = rdi;
    *(obj.caml_local_roots) = rax;
    eax = caml_force_major_slice;
    if (eax != 0) {
        rax = rsp + 8;
        *((rsp + 0x10)) = rbx;
        *((rsp + 0x20)) = 1;
        *((rsp + 0x18)) = 1;
        *((rsp + 0x28)) = rax;
        caml_minor_collection ();
    }
    *(obj.caml_local_roots) = rbx;
    rax = *((rsp + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429d20 */
#include <stdint.h>
 
void caml_int32_shift_right_unsigned (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    edi = *((rdi + 8));
    rcx = rsi;
    rcx >>= 1;
    edi >>= cl;
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fb30 */
#include <stdint.h>
 
int64_t camlPervasives_fun_438 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_pos_out);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42bf60 */
#include <stdint.h>
 
uint32_t caml_getword (int64_t arg1) {
    rdi = arg1;
    r12d = 0;
    ebx = 0;
    do {
        rdx = *((rbp + 0x18));
        if (rdx >= *((rbp + 0x20))) {
            goto label_1;
        }
        eax = *(rdx);
        rdx++;
        *((rbp + 0x18)) = rdx;
label_0:
        ebx++;
        r12d <<= 8;
        r12d = rax + r12;
    } while (ebx != 4);
    eax = r12d;
    r12 = rbx;
    return eax;
label_1:
    rdi = rbp;
    al = caml_refill ();
    eax = (int32_t) al;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fbb0 */
#include <stdint.h>
 
int64_t camlPervasives_fun_446 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_ml_output_char);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b360 */
#include <stdint.h>
 
int64_t camlUnix_fun_1721 (void) {
    rdi = rax;
    rax = *(reloc.unix_set_close_on_exec);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410480 */
#include <stdint.h>
 
uint64_t camlPervasives_print_int_294 (void) {
    rax = camlPervasives_string_of_int_154 ();
    rbx = rax;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0xb8));
    return camlPervasives_output_string_215 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bc90 */
#include <stdint.h>
 
int64_t camlUnix_pause_436 (void) {
    rsi = 1;
    rdi = 3;
    rax = *(reloc.unix_sigprocmask);
    rax = caml_c_call ();
    rdi = rax;
    rax = *(reloc.unix_sigsuspend);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bbb0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1819 (void) {
    rdi = rax;
    rax = *(reloc.unix_stat_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432710 */
#include <stdint.h>
 
uint64_t caml_callback3 (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rax = caml_callback3_exn ();
    rdx = rax;
    edx &= 3;
    if (rdx != 2) {
        return rax;
    }
    rdi = rax;
    rdi &= 0xfffffffffffffffc;
    return caml_raise ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434fcc */
#include <stdint.h>
 
int64_t caml_callback3_exn (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rax = rsi;
    rbx = rdx;
    rsi = rdi;
    rdi = rcx;
    r12 = sym_caml_apply3;
    return void (*0x434e95)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423970 */
#include <stdint.h>
 
int64_t caml_raise (int64_t arg1) {
    int64_t var_8h;
    rdi = arg1;
    rax = caml_channel_mutex_unlock_exn;
    if (rax != 0) {
        void (*rax)(uint64_t) (rdi);
        rdi = *((rsp + 8));
    }
    rdx = caml_exception_pointer;
    if (rdx == 0) {
        goto label_0;
    }
    rax = caml_local_roots;
    if (rax == 0) {
        goto label_1;
    }
    if (rdx > rax) {
        goto label_2;
    }
    goto label_1;
    do {
        if (rdx <= rax) {
            goto label_3;
        }
label_2:
        rax = *(rax);
    } while (rax != 0);
    *(obj.caml_local_roots) = 0;
label_1:
    rax = caml_raise_exception ();
label_3:
    *(obj.caml_local_roots) = rax;
    caml_raise_exception ();
label_0:
    return caml_fatal_uncaught_exception ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434f90 */
#include <stdint.h>
 
int64_t caml_callback_exn (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rax = rsi;
    r12 = *(rbx);
    return void (*0x434e95)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c010 */
#include <stdint.h>
 
int64_t camlUnix_setsockopt_int_679 (int64_t arg1) {
    rdi = arg1;
    rcx = rdi;
    rdi = 3;
    rsi = rax;
    rdx = rbx;
    rax = *(reloc.unix_setsockopt);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418fc0 */
#include <stdint.h>
 
int64_t camlHashtbl_add_102 (int64_t arg1) {
    rdi = arg1;
    r12 = rax;
    rax = *((r12 + 8));
    rbp = *((rax - 8));
    rbp >>= 0xa;
    if (rbp != 0) {
        *(rsp) = rdi;
        rsi = 0xc9;
        rdi = 0x15;
        rdx = rbx;
        rax = caml_hash_univ_param ();
        rax >>= 1;
        rcx = rbp;
        __asm ("cqo");
        rax = rdx:rax / rcx;
        rdx = rdx:rax % rcx;
    } else {
        rax = *(reloc.caml_bucket_Division_by_zero);
        caml_raise_exn ();
    }
    rdx <<= 1;
    rdx++;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0xc00;
            *(rsi) = rbx;
            rax = *(rsp);
            *((rsi + 8)) = rax;
            rbx = *((r12 + 8));
            rax = *((rbx - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_0;
            }
            rax = *((rbx + rdx*4 - 4));
            *((rsi + 0x10)) = rax;
            rbx = *((r12 + 8));
            rax = *((rbx - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_1;
            }
            rdi = rbx + rdx*4 - 4;
            caml_modify ();
            *(r12) += 2;
            rax = *((r12 + 8));
            rax = *((rax - 8));
            rax >>= 9;
            rax |= 1;
            rbx = rax + rax - 1;
            rax = *(r12);
            if (rax > rbx) {
                rax = *(reloc.camlHashtbl);
                rax = *((rax + 0x68));
                rbx = r12;
                void (*0x418e60)() ();
            }
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415e90 */
#include <stdint.h>
 
int64_t camlList_split_248 (void) {
    int64_t var_8h;
    do {
        if (rax == 1) {
            goto label_0;
        }
        rsi = *((rax + 8));
        rdi = *(rax);
        rbx = *((rdi + 8));
        *(rsp) = rbx;
        rbx = *(rdi);
        *((rsp + 8)) = rbx;
        rax = rsi;
        rax = camlList_split_248 ();
    } while (1);
    rbx = *((rax + 8));
    rsi = *(rax);
    do {
        r15 -= 0x48;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x800;
            rax = *(rsp);
            *(rdi) = rax;
            *((rdi + 8)) = rbx;
            rbx = rdi + 0x18;
            *((rbx - 8)) = 0x800;
            rax = *((rsp + 8));
            *(rbx) = rax;
            *((rbx + 8)) = rsi;
            rax = rdi + 0x30;
            *((rax - 8)) = 0x800;
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            return rax;
label_0:
            rax = *(loc.camlList__41);
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415fe0 */
#include <stdint.h>
 
int64_t camlList_merge_261 (uint32_t arg1) {
    uint32_t var_8h;
    uint32_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    uint32_t var_28h;
    int64_t var_30h;
    rdi = arg1;
    do {
label_0:
        rdx = rax;
        if (rbx == 1) {
            goto label_2;
        }
        if (rdi == 1) {
            goto label_3;
        }
        *((rsp + 0x28)) = rdi;
        *(rsp) = rbx;
        *((rsp + 0x18)) = rdx;
        rsi = *((rdi + 8));
        *((rsp + 8)) = rsi;
        rsi = *(rdi);
        *((rsp + 0x10)) = rsi;
        rdi = *((rbx + 8));
        *((rsp + 0x20)) = rdi;
        rax = *(rbx);
        *((rsp + 0x30)) = rax;
        rbx = rsi;
        rdi = rdx;
        rax = caml_apply2 ();
        if (rax > 1) {
            goto label_4;
        }
        rax = *((rsp + 0x18));
        rbx = *((rsp + 0x20));
        rdi = *((rsp + 0x28));
        rax = camlList_merge_261 ();
    } while (1);
    rdi = rax;
label_1:
    r15 -= 0x18;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_5;
    }
    rbx = r15 + 8;
    *((rbx - 8)) = 0x800;
    rax = *((rsp + 0x30));
    *(rbx) = rax;
    *((rbx + 8)) = rdi;
    rax = rbx;
    return rax;
label_4:
    rax = *((rsp + 0x18));
    rbx = *(rsp);
    rdi = *((rsp + 8));
    rax = camlList_merge_261 ();
    goto label_0;
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            rax = *((rsp + 0x10));
            *(rbx) = rax;
            *((rbx + 8)) = rdi;
            rax = rbx;
            return rax;
label_3:
            rax = rbx;
            return rax;
label_2:
            rax = rdi;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bbf0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1815 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_truncate_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42dff0 */
#include <stdint.h>
 
int64_t caml_deserialize_block_4 (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = intern_src;
    if (rsi <= 0) {
        goto label_0;
    }
    rcx = rsi;
    eax = 0;
    do {
        r10d = *((rdx + rax + 3));
        r9d = *((rdx + rax));
        r8d = *((rdx + rax + 1));
        *((rdi + rax)) = r10b;
        r10d = *((rdx + rax + 2));
        *((rdi + rax + 3)) = r9b;
        *((rdi + rax + 2)) = r8b;
        *((rdi + rax + 1)) = r10b;
        rax += 4;
        rcx--;
    } while (rcx != 0);
    rdx = rdx + rsi*4;
label_0:
    *(obj.intern_src) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4173c0 */
#include <stdint.h>
 
int64_t camlString_index_rec_136 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, uint32_t arg2, signed int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rdi >= rbx) {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_1;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            caml_raise_exn ();
        }
        rdx = rdi;
        rdx >>= 1;
        rdx = *((rax + rdx));
        rdx = rdx + rdx + 1;
        if (rdx == rsi) {
            rax = rdi;
            return rax;
        }
        rdi += 2;
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434f3c */
#include <stdint.h>
 
int64_t caml_raise_exception (int64_t arg1) {
    rdi = arg1;
    if ((*(obj.caml_backtrace_active) & 1) == 0) {
        rax = rdi;
        rsp = caml_exception_pointer;
        r15 = caml_young_ptr;
        return rax;
    }
    r12 = rdi;
    rsi = caml_last_return_address;
    rdx = caml_bottom_of_stack;
    rcx = caml_exception_pointer;
    caml_stash_backtrace ();
    rax = r12;
    rsp = caml_exception_pointer;
    r15 = caml_young_ptr;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428d20 */
#include <stdint.h>
 
int64_t caml_int64_compare (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = *((rsi + 8));
    rcx = *((rdi + 8));
    eax = 0;
    al = (rcx > rdx) ? 1 : 0;
    dl = (rcx < rdx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    rax = (int64_t) eax;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40aef0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1651 (void) {
    rdi = rax;
    rax = *(reloc.unix_getgid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4296e0 */
#include <stdint.h>
 
void caml_nativeint_shift_right_unsigned (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdi = *((rdi + 8));
    rcx = rsi;
    rcx >>= 1;
    rdi >>= cl;
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429610 */
#include <stdint.h>
 
void caml_nativeint_to_float (int64_t arg7) {
    xmm0 = arg7;
    __asm ("cvtsi2sd xmm0, qword [rdi + 8]");
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c8c0 */
#include <stdint.h>
 
uint64_t camlUnix_getnameinfo_807 (void) {
    int64_t var_8h;
    *(rsp) = rax;
    *((rsp + 8)) = rbx;
    rax = void (*0x40c8fc)() ();
    rdi = *(reloc.caml_exn_Invalid_argument);
    rbx = *(rax);
    if (rbx == rdi) {
        rax = *(rsp);
        rbx = *((rsp + 8));
        void (*0x40c660)() ();
    }
    rax = caml_raise_exn ();
    r14 = rsp;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_getnameinfo);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4105e0 */
#include <stdint.h>
 
uint64_t camlPervasives_prerr_int_305 (void) {
    rax = camlPervasives_string_of_int_154 ();
    rbx = rax;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0xc0));
    return camlPervasives_output_string_215 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4327a0 */
#include <stdint.h>
 
int64_t caml_callbackN_exn (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_90h;
    int64_t var_98h;
    int64_t var_a0h;
    int64_t var_a8h;
    int64_t var_d8h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rax = rdi;
    r12 = rdx;
    r13 = caml_local_roots;
    rdx = rsp + 0x10;
    *((rsp + 8)) = rdi;
    *((rsp + 0xd8)) = rdi;
    *(obj.caml_local_roots) = rdx;
    if (esi <= 0) {
        goto label_2;
    }
    rdx = rsp + 8;
    *((rsp + 0x90)) = r13;
    *((rsp + 0xa0)) = 1;
    *((rsp + 0x98)) = 1;
    *((rsp + 0x58)) = 1;
    ebx = 0;
    *((rsp + 0xa8)) = rdx;
    rdx = rsp + 0x90;
    *((rsp + 0x68)) = r12;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *((rsp + 0x50)) = rdx;
    rdx = (int64_t) esi;
    *((rsp + 0x60)) = rdx;
    rdx = rsp + 0x50;
    *((rsp + 0x10)) = rdx;
    rdx = rsp + 0xd8;
    *((rsp + 0x28)) = rdx;
    while (edx != 1) {
        if (edx == 2) {
            goto label_3;
        }
        rsi = (int64_t) ebx;
        rdi = rax;
        rdx = *((r12 + rsi*8 + 8));
        rcx = *((r12 + rsi*8 + 0x10));
        rsi = *((r12 + rsi*8));
        rax = caml_callback3_exn ();
        rdx = rax;
        edx &= 3;
        if (rdx == 2) {
            goto label_2;
        }
        *((rsp + 0xd8)) = rax;
        ebx += 3;
label_1:
        if (ebp <= ebx) {
            goto label_4;
        }
label_0:
        rax = *((rsp + 0xd8));
        edx = ebp;
        edx -= ebx;
    }
    rdx = (int64_t) ebx;
    rdi = rax;
    rsi = *((r12 + rdx*8));
    rax = caml_callback_exn ();
    rdx = rax;
    edx &= 3;
    if (rdx == 2) {
        goto label_2;
    }
    ebx++;
    *((rsp + 0xd8)) = rax;
    if (ebp > ebx) {
        goto label_0;
    }
label_4:
    rax = *((rsp + 0xd8));
    do {
label_2:
        *(obj.caml_local_roots) = r13;
        return rax;
label_3:
        rcx = (int64_t) ebx;
        rdi = rax;
        rdx = *((r12 + rcx*8 + 8));
        rsi = *((r12 + rcx*8));
        rax = caml_callback2_exn ();
        rdx = rax;
        edx &= 3;
    } while (rdx == 2);
    *((rsp + 0xd8)) = rax;
    ebx += 2;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e2d0 */
#include <stdint.h>
 
int64_t caml_code_checksum (void) {
    int64_t var_58h;
    edx = checksum_computed.4045;
    rax = *(fs:0x28);
    *((rsp + 0x58)) = rax;
    eax = 0;
    if (edx == 0) {
        rdi = rsp;
        caml_MD5Init ();
        rsi = caml_code_area_start;
        rdx = caml_code_area_end;
        rdi = rsp;
        rdx -= rsi;
        caml_MD5Update ();
        rsi = rsp;
        edi = checksum.4044;
        caml_MD5Final ();
        *(obj.checksum_computed.4045) = 1;
    }
    rdx = *((rsp + 0x58));
    rdx ^= *(fs:0x28);
    eax = checksum.4044;
    if (rdx == 0) {
        return rax;
    }
    return stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410880 */
#include <stdint.h>
 
uint64_t camlPervasives_string_of_format_339 (void) {
    int64_t var_8h;
    rdi = rax;
    *(rsp) = rdi;
    rbx = *((rdi - 8));
    rbx >>= 0xa;
    rax = rbx*8 - 1;
    rbx = *((rdi + rax));
    rax -= rbx;
    rdi = rax + rax + 1;
    *((rsp + 8)) = rdi;
    rax = *(reloc.caml_create_string);
    rax = caml_c_call ();
    rbx = rax;
    rcx = 1;
    rsi = 1;
    rdi = *(rsp);
    rdx = rbx;
    r8 = *((rsp + 8));
    caml_blit_string ();
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x414190 */
#include <stdint.h>
 
int64_t camlArray_entry (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rbx = *(loc.camlArray__21);
    rax = *(reloc.camlArray);
    *(rax) = rbx;
    rbx = *(loc.camlArray__20);
    rax = *(reloc.camlArray);
    *((rax + 8)) = rbx;
    rax = *(reloc.camlArray);
    rbx = *((rax + 8));
    rax = *(reloc.camlArray);
    *((rax + 0x10)) = rbx;
    rbx = *(loc.camlArray__19);
    rax = *(reloc.camlArray);
    *((rax + 0x30)) = rbx;
    rbx = *(loc.camlArray__18);
    rax = *(reloc.camlArray);
    *((rax + 0x18)) = rbx;
    rbx = *(loc.camlArray__17);
    rax = *(reloc.camlArray);
    *((rax + 0xa0)) = rbx;
    rbx = *(loc.camlArray__16);
    rax = *(reloc.camlArray);
    *((rax + 0x20)) = rbx;
    rbx = *(loc.camlArray__15);
    rax = *(reloc.camlArray);
    *((rax + 0x28)) = rbx;
    rbx = *(loc.camlArray__14);
    rax = *(reloc.camlArray);
    *((rax + 0x38)) = rbx;
    rbx = *(loc.camlArray__13);
    rax = *(reloc.camlArray);
    *((rax + 0x40)) = rbx;
    rbx = *(loc.camlArray__12);
    rax = *(reloc.camlArray);
    *((rax + 0x58)) = rbx;
    rbx = *(loc.camlArray__11);
    rax = *(reloc.camlArray);
    *((rax + 0x60)) = rbx;
    rbx = *(loc.camlArray__10);
    rax = *(reloc.camlArray);
    *((rax + 0x68)) = rbx;
    rbx = *(loc.camlArray__9);
    rax = *(reloc.camlArray);
    *((rax + 0x70)) = rbx;
    rbx = *(loc.camlArray__8);
    rax = *(reloc.camlArray);
    *((rax + 0x48)) = rbx;
    rbx = *(loc.camlArray__7);
    rax = *(reloc.camlArray);
    *((rax + 0xa8)) = rbx;
    rbx = *(loc.camlArray__6);
    rax = *(reloc.camlArray);
    *((rax + 0x50)) = rbx;
    rbx = *(loc.camlArray__5);
    rax = *(reloc.camlArray);
    *((rax + 0x78)) = rbx;
    rbx = *(loc.camlArray__4);
    rax = *(reloc.camlArray);
    *((rax + 0x80)) = rbx;
    caml_alloc1 ();
    rbx = r15 + 8;
    *((rbx - 8)) = 0x400;
    rax = *(loc.camlArray__3);
    *(rbx) = rax;
    rax = *(reloc.camlArray);
    *((rax + 0xb0)) = rbx;
    rbx = *(loc.camlArray__2);
    rax = *(reloc.camlArray);
    *((rax + 0x88)) = rbx;
    rax = *(reloc.camlArray);
    *((rax + 0xb8)) = 0xb;
    rbx = *(loc.camlArray__1);
    rax = *(reloc.camlArray);
    *((rax + 0x90)) = rbx;
    rax = *(reloc.camlArray);
    rbx = *((rax + 0x90));
    rax = *(reloc.camlArray);
    *((rax + 0x98)) = rbx;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434d78 */
#include <stdint.h>
 
int64_t caml_alloc1 (int64_t arg_8h, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        r15 -= 0x10;
        if (r15 >= *(obj.caml_young_limit)) {
            return;
        }
        rax = *(rsp);
        *(obj.caml_last_return_address) = rax;
        rax = rsp + 8;
        *(obj.caml_bottom_of_stack) = rax;
        fcn_00434c4b (rdi, rsi, rdx, rcx, r8, r9);
        caml_alloc1 ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434c4b */
#include <stdint.h>
 
void fcn_00434c4b (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_70h;
    int64_t var_78h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    *(obj.caml_young_ptr) = r15;
    *(obj.caml_exception_pointer) = r14;
    *(obj.caml_gc_regs) = rsp;
    __asm ("movlpd qword [rsp], xmm0");
    __asm ("movlpd qword [rsp + 8], xmm1");
    __asm ("movlpd qword [rsp + 0x10], xmm2");
    __asm ("movlpd qword [rsp + 0x18], xmm3");
    __asm ("movlpd qword [rsp + 0x20], xmm4");
    __asm ("movlpd qword [rsp + 0x28], xmm5");
    __asm ("movlpd qword [rsp + 0x30], xmm6");
    __asm ("movlpd qword [rsp + 0x38], xmm7");
    __asm ("movlpd qword [rsp + 0x40], xmm8");
    __asm ("movlpd qword [rsp + 0x48], xmm9");
    __asm ("movlpd qword [rsp + 0x50], xmm10");
    __asm ("movlpd qword [rsp + 0x58], xmm11");
    __asm ("movlpd qword [rsp + 0x60], xmm12");
    __asm ("movlpd qword [rsp + 0x68], xmm13");
    __asm ("movlpd qword [rsp + 0x70], xmm14");
    __asm ("movlpd qword [rsp + 0x78], xmm15");
    caml_garbage_collection ();
    __asm ("movlpd xmm0, qword [rsp]");
    __asm ("movlpd xmm1, qword [rsp + 8]");
    __asm ("movlpd xmm2, qword [rsp + 0x10]");
    __asm ("movlpd xmm3, qword [rsp + 0x18]");
    __asm ("movlpd xmm4, qword [rsp + 0x20]");
    __asm ("movlpd xmm5, qword [rsp + 0x28]");
    __asm ("movlpd xmm6, qword [rsp + 0x30]");
    __asm ("movlpd xmm7, qword [rsp + 0x38]");
    __asm ("movlpd xmm8, qword [rsp + 0x40]");
    __asm ("movlpd xmm9, qword [rsp + 0x48]");
    __asm ("movlpd xmm10, qword [rsp + 0x50]");
    __asm ("movlpd xmm11, qword [rsp + 0x58]");
    __asm ("movlpd xmm12, qword [rsp + 0x60]");
    __asm ("movlpd xmm13, qword [rsp + 0x68]");
    __asm ("movlpd xmm14, qword [rsp + 0x70]");
    __asm ("movlpd xmm15, qword [rsp + 0x78]");
    r15 = caml_young_ptr;
    r14 = caml_exception_pointer;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a630 */
#include <stdint.h>
 
void caml_floor_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    floor (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4278d0 */
#include <stdint.h>
 
uint64_t caml_alloc_for_heap (int64_t arg1) {
    int64_t var_8h;
    rdi = arg1;
    rbx = rdi;
    rdi = rdi + 0x20;
    esi = 0x20;
    rdx = rsp + 8;
    rax = caml_aligned_malloc ();
    if (rax != 0) {
        rdx = *((rsp + 8));
        rax += 0x20;
        *((rax - 0x10)) = rbx;
        *((rax - 0x20)) = rdx;
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425290 */
#include <stdint.h>
 
uint64_t caml_aligned_malloc (int64_t arg3, int64_t arg2, size_t size) {
    int64_t var_8h;
    int64_t var_10h;
    rdx = arg3;
    rsi = arg2;
    rdi = size;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rdi += 0x1000;
    ebx = esi;
    rax = malloc (rdi);
    rdx = rax;
    eax = 0;
    if (rdx != 0) {
        rbx = (int64_t) ebx;
        *(rbp) = rdx;
        rdx += rbx;
        rdx &= 0xfffffffffffff000;
        rax = rdx + 0x1000;
        rax -= rbx;
    }
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41dde0 */
#include <stdint.h>
 
uint64_t camlPrintf_count_arguments_of_format_226 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    rax = camlPrintf_ac_of_format_212 ();
    rax = *(rax);
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41dd20 */
#include <stdint.h>
 
void camlPrintf_ac_of_format_212 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429640 */
#include <stdint.h>
 
void caml_int64_to_float (int64_t arg7) {
    xmm0 = arg7;
    __asm ("cvtsi2sd xmm0, qword [rdi + 8]");
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427af0 */
#include <stdint.h>
 
uint32_t caml_page_table_remove (int64_t arg3, uint32_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rsi &= 0xfffffffffffff000;
    r12d = edi;
    rbp = rdx - 1;
    rbp &= 0xfffffffffffff000;
    if (rsi > rbp) {
        goto label_0;
    }
    rbx = rsi;
    while (eax == 0) {
        rbx += 0x1000;
        if (rbp < rbx) {
            goto label_0;
        }
        edx = 0;
        esi = r12d;
        rdi = rbx;
        eax = caml_page_table_modify ();
    }
    eax = 0xffffffff;
    return eax;
label_0:
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fd10 */
#include <stdint.h>
 
int64_t camlPervasives_lnot_76 (void) {
    rax ^= 0xffffffffffffffff;
    rax |= 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ed70 */
#include <stdint.h>
 
int64_t camlCallback_entry (void) {
    rbx = *(loc.camlCallback__2);
    rax = *(reloc.camlCallback);
    *(rax) = rbx;
    rbx = *(loc.camlCallback__1);
    rax = *(reloc.camlCallback);
    *((rax + 8)) = rbx;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433cb0 */
#include <stdint.h>
 
int32_t caml_final_release (void) {
    *(obj.running_finalisation_function) = 0;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e510 */
#include <stdint.h>
 
int64_t camlPrintf_kfprintf_418 (int64_t arg6, int64_t arg5, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rcx = rax;
    rdi = rbx;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0xcf7;
            rax = *(reloc.camlPrintf__fun_710);
            *(rbx) = rax;
            *((rbx + 8)) = 3;
            *((rbx + 0x10)) = rdi;
            rax = *(reloc.camlPrintf);
            r8 = *((rax + 0x118));
            rax = *(reloc.camlPervasives);
            rdx = *((rax + 0x158));
            rax = *(reloc.camlPervasives);
            rsi = *((rax + 0x170));
            rax = *(reloc.camlPervasives);
            rdi = *((rax + 0x168));
            rax = 1;
            void (*0x40a480)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432570 */
#include <stdint.h>
 
uint64_t caml_named_value (int64_t arg1) {
    rdi = arg1;
    ecx = 0;
    edx = 0;
    rsi = rdi;
    rbx = rdi;
    eax = *(rdi);
    if (al == 0) {
        goto label_0;
    }
    do {
        edx = rcx * 9;
        eax = (int32_t) al;
        rsi++;
        ecx = rcx + rdx*2;
        ecx = rax + rcx;
        eax = *(rsi);
    } while (al != 0);
    eax = ecx;
    edx = 0x4ec4ec4f;
    edx:eax = eax * edx;
    edx >>= 2;
    eax = rdx * 3;
    edx = rdx + rax*4;
    ecx -= edx;
    edx = ecx;
label_0:
    edx = ecx;
    rbp = *((rdx*8 + obj.named_value_table));
    if (rbp != 0) {
        goto label_1;
    }
    goto label_2;
    do {
        rbp = *((rbp + 8));
        if (rbp == 0) {
            goto label_2;
        }
label_1:
        eax = strcmp (rbx, rbp + 0x10);
    } while (eax != 0);
    rax = rbp;
    return rax;
label_2:
    eax = 0;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41db30 */
#include <stdint.h>
 
int64_t camlPrintf_sub_format_for_printf_163 (void) {
    rdi = rax;
    rax = *(reloc.camlPrintf);
    rsi = *((rax + 0xa8));
    rax = *(reloc.camlPrintf);
    rbx = *((rax + 0x68));
    rax = *(reloc.camlPrintf);
    rax = *((rax + 0x70));
    return caml_apply3 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433090 */
#include <stdint.h>
 
int64_t caml_weak_create (uint32_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    rax = 0x3ffffffffffffe;
    rbx = rdi + 1;
    if (rdi > rax) {
        goto label_0;
    }
    esi = 0xfb;
    rdi = rbx;
    caml_alloc_shr ();
    if (rbx == 1) {
        goto label_1;
    }
    edx = 1;
    do {
        rcx = caml_weak_none;
        *((rax + rdx*8)) = rcx;
        rdx++;
    } while (rbx > rdx);
label_1:
    rdx = caml_weak_list_head;
    *(rax) = rdx;
    *(obj.caml_weak_list_head) = rax;
    return rax;
label_0:
    edi = "Weak.create";
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429b90 */
#include <stdint.h>
 
int64_t caml_int64_mod (int64_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rcx = *((rsi + 8));
    rdi = *((rdi + 8));
    if (rcx == 0) {
        goto label_0;
    }
    while (rdi != rax) {
        rdx = rdi;
        rax = rdi;
        rdx >>= 0x3f;
        rax = rdx:rax / rcx;
        rdx = rdx:rax % rcx;
        rdi = rdx;
        void (*0x429870)() ();
        rax = 0x8000000000000000;
    }
    edi = 0;
    void (*0x429870)() ();
label_0:
    return caml_raise_zero_divide ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42dd70 */
#include <stdint.h>
 
uint32_t caml_output_val (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_48h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r12 = rdx;
    rbx = rdi;
    eax = caml_channel_binary_mode ();
    if (eax == 0) {
        goto label_0;
    }
    init_extern_output ();
    rdi = rbp;
    rsi = r12;
    extern_value ();
    rbp = extern_output_first;
    if (rbp == 0) {
        goto label_1;
    }
    do {
        rdx = *((rbp + 8));
        rsi = rbp + 0x10;
        rdi = rbx;
        rdx -= rsi;
        caml_really_putblock ();
        r12 = *(rbp);
        free (rbp);
    } while (r12 != 0);
label_1:
    return eax;
label_0:
    edi = "output_value: not a binary channel";
    return caml_failwith ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40af70 */
#include <stdint.h>
 
int64_t camlUnix_fun_1659 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_setitimer);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x414390 */
#include <stdint.h>
 
int64_t camlList_nth_aux_73 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rax == 1) {
            goto label_0;
        }
        rdi = *((rax + 8));
        rax = *(rax);
        if (rbx == 1) {
            return rax;
        }
        rbx += 0xfffffffffffffffe;
        rax = rdi;
    } while (1);
label_0:
    rax = *(loc.camlList__53);
    return camlPervasives_failwith_38 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410970 */
#include <stdint.h>
 
int64_t camlPervasives_do_at_exit_349 (void) {
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0x290));
    rbx = *(rax);
    rax = 1;
    rdi = *(rbx);
    return void (*rdi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b190 */
#include <stdint.h>
 
int64_t caml_array_set_float (int64_t arg3, uint32_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    if (rsi >= 0) {
        rax = *((rdi - 8));
        rax >>= 0xa;
        if (rsi >= rax) {
            goto label_0;
        }
        rax = *(rdx);
        *((rdi + rsi*8)) = rax;
        eax = 1;
        return rax;
    }
label_0:
    return caml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4239f0 */
#include <stdint.h>
 
int32_t caml_array_bound_error (void) {
    eax = array_bound_error_bucket_inited;
    while (1) {
        edi = 0x64e178;
        caml_raise ();
        edx = caml_last_return_address;
        esi = array_bound_error_msg;
        edi = 4;
        *(obj.array_bound_error_msg) = 0xcfc;
        *(0x0064ddbf) = 4;
        *(obj.array_bound_error_bucket) = 0x800;
        *(0x0064e178) = loc.caml_exn_Invalid_argument;
        *(0x0064e180) = str.index_out_of_bounds;
        *(obj.array_bound_error_bucket_inited) = 1;
        caml_page_table_add ();
        *(obj.array_bound_error_bucket_inited) = 1;
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x426680 */
#include <stdint.h>
 
uint64_t caml_darken (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    while ((al & 1) == 0) {
label_0:
        return;
        al = caml_page_table_lookup ();
    }
    rax = *((rbx - 8));
    edx = (int32_t) al;
    if (edx == 0xf9) {
        goto label_2;
    }
label_1:
    if ((ah & 3) != 0) {
        goto label_0;
    }
    if (edx > 0xfa) {
        goto label_3;
    }
    ah &= 0xfc;
    ah |= 1;
    *((rbx - 8)) = rax;
    rax = gray_vals_cur;
    *(rax) = rbx;
    rax += 8;
    *(obj.gray_vals_cur) = rax;
    if (rax < *(obj.gray_vals_end)) {
        goto label_0;
    }
    void (*0x426100)() ();
label_2:
    rax >>= 0xa;
    rax <<= 3;
    rbx -= rax;
    rax = *((rbx - 8));
    edx = (int32_t) al;
    goto label_1;
label_3:
    ah |= 3;
    *((rbx - 8)) = rax;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4273f0 */
#include <stdint.h>
 
int64_t caml_realloc_ref_table (uint32_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdi = arg1;
    *((rsp - 0x20)) = rbx;
    *((rsp - 0x18)) = rbp;
    rbx = rdi;
    *((rsp - 0x10)) = r12;
    *((rsp - 8)) = r13;
    rbp = *(rdi);
    if (rbp != 0) {
        rax = *((rdi + 0x10));
        if (*((rdi + 0x20)) != rax) {
            r13 = *((rdi + 0x28));
            r12 = *((rdi + 0x18));
            esi = "Growing ref_table to %ldk bytes\n";
            r13 += r13;
            *((rdi + 0x28)) = r13;
            r13 += *((rdi + 0x30));
            edi = 8;
            r13 <<= 3;
            rdx = r13 + 0x3ff;
            __asm ("cmovns rdx, r13");
            rdx >>= 0xa;
            caml_gc_message ();
            rax = realloc (*(rbx), r13);
            *(rbx) = rax;
            if (rax == 0) {
                goto label_0;
            }
            rcx = *((rbx + 0x28));
            rdx = *((rbx + 0x30));
            r12 -= rbp;
            r12 &= 0xfffffffffffffff8;
            rbp = *((rsp + 0x10));
            r13 = *((rsp + 0x20));
            r12 = rax + r12;
            rdx += rcx;
            rcx = rax + rcx*8;
            rdx = rax + rdx*8;
            *((rbx + 0x18)) = r12;
            r12 = *((rsp + 0x18));
            *((rbx + 0x10)) = rcx;
            *((rbx + 8)) = rdx;
            *((rbx + 0x20)) = rdx;
            rbx = *((rsp + 8));
            return rax;
        }
        edx = 0;
        esi = "ref_table threshold crossed\n";
        edi = 8;
        caml_gc_message ();
        rax = *((rbx + 8));
        rbp = *((rsp + 0x10));
        r12 = *((rsp + 0x18));
        r13 = *((rsp + 0x20));
        *((rbx + 0x20)) = rax;
        rbx = *((rsp + 8));
        void (*0x424ae0)() ();
    }
    rsi = caml_minor_heap_size;
    rbx = *((rsp + 8));
    edx = 0x100;
    rbp = *((rsp + 0x10));
    r12 = *((rsp + 0x18));
    r13 = *((rsp + 0x20));
    rsi >>= 6;
    void (*0x427390)() ();
label_0:
    edi = "Fatal error: ref_table overflow\n";
    return caml_fatal_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424ae0 */
#include <stdint.h>
 
int64_t caml_urge_major_slice (void) {
    rax = caml_young_end;
    *(obj.caml_force_major_slice) = 1;
    *(obj.caml_young_limit) = rax;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425370 */
#include <stdint.h>
 
int32_t caml_fatal_error (int64_t arg1) {
    rdi = arg1;
    rcx = rdi;
    rdi = stderr;
    edx = 0x436180;
    esi = 1;
    eax = 0;
    fprintf_chk ();
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408ea0 */
#include <stdint.h>
 
void fprintf_chk (void) {
    fprintf_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40cf80 */
#include <stdint.h>
 
int64_t camlUnix_open_process_993 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    *((rsp + 0x10)) = rax;
    rdi = 1;
    rax = *(reloc.unix_pipe);
    rax = caml_c_call ();
    rbx = *((rax + 8));
    *((rsp + 0x20)) = rbx;
    rax = *(rax);
    *((rsp + 8)) = rax;
    rdi = 1;
    rax = *(reloc.unix_pipe);
    rax = caml_c_call ();
    rbx = *((rax + 8));
    *(rsp) = rbx;
    rax = *(rax);
    *((rsp + 0x18)) = rax;
    rdi = *((rsp + 8));
    rax = *(reloc.caml_ml_open_descriptor_in);
    rax = caml_c_call ();
    *((rsp + 0x28)) = rax;
    rdi = *(rsp);
    rax = *(reloc.caml_ml_open_descriptor_out);
    rax = caml_c_call ();
    rdi = rax;
    *((rsp + 0x30)) = rdi;
label_0:
    r15 -= 0x48;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    rbx = r15 + 8;
    *((rbx - 8)) = 0x800;
    rax = *(rsp);
    *(rbx) = rax;
    *((rbx + 8)) = 1;
    rdx = rbx + 0x18;
    *((rdx - 8)) = 0x800;
    rax = *((rsp + 8));
    *(rdx) = rax;
    *((rdx + 8)) = rbx;
    rbx += 0x30;
    *((rbx - 8)) = 0x800;
    rax = *((rsp + 0x28));
    *(rbx) = rax;
    *((rbx + 8)) = rdi;
    rax = *((rsp + 0x10));
    rdi = *((rsp + 0x18));
    rsi = *((rsp + 0x20));
    camlUnix_open_proc_975 ();
    rdi = *((rsp + 0x18));
    rax = *(reloc.unix_close);
    caml_c_call ();
    rdi = *((rsp + 0x20));
    rax = *(reloc.unix_close);
    caml_c_call ();
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *((rsp + 0x28));
            *(rax) = rbx;
            rbx = *((rsp + 0x30));
            *((rax + 8)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40cc90 */
#include <stdint.h>
 
int64_t camlUnix_open_proc_975 (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 8)) = rax;
    *((rsp + 0x28)) = rbx;
    *((rsp + 0x20)) = rdi;
    *((rsp + 0x18)) = rsi;
    rbx = rdx;
    *((rsp + 0x10)) = rbx;
    rax = *(reloc.camlUnix);
    rax = *((rax + 0x4c8));
    rax = camlList_for_all_165 ();
    *(rsp) = rax;
    rdi = 1;
    rax = *(reloc.unix_fork);
    rax = caml_c_call ();
    rdi = rax;
    if (rdi != 1) {
        rax = *(reloc.camlUnix);
        rax = *((rax + 0x508));
        rbx = *((rsp + 0x28));
        void (*0x418fc0)() ();
    }
    rdi = *((rsp + 0x20));
    if (rdi != 1) {
        *((rsp + 0x20)) = rdi;
        rsi = 1;
        rax = *(reloc.unix_dup2);
        caml_c_call ();
        rdi = *((rsp + 0x20));
        rax = *(reloc.unix_close);
        caml_c_call ();
    }
    rdi = *((rsp + 0x18));
    if (rdi != 3) {
        *((rsp + 0x18)) = rdi;
        rsi = 3;
        rax = *(reloc.unix_dup2);
        caml_c_call ();
        rdi = *((rsp + 0x18));
        rax = *(reloc.unix_close);
        caml_c_call ();
    }
    rax = *(rsp);
    if (rax == 1) {
        rax = *(loc.camlUnix__186);
        rbx = *((rsp + 0x10));
        camlList_iter_102 ();
    }
    fcn_0040cd98 (rdi, rsi, rdx, rcx, r8, r9);
    rax = 0xff;
    return camlPervasives_exit_350 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410830 */
#include <stdint.h>
 
int64_t camlPervasives_fun_509 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_ml_seek_out_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b6e0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1777 (void) {
    rdi = rax;
    rax = *(reloc.unix_getppid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40af30 */
#include <stdint.h>
 
int64_t camlUnix_fun_1655 (void) {
    rdi = rax;
    rax = *(reloc.unix_geteuid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a260 */
#include <stdint.h>
 
void caml_cosh_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    cosh (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e230 */
#include <stdint.h>
 
int64_t camlPrintf_valid_float_lexeme_298 (int64_t arg6, int64_t arg5, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rcx = rax;
    rax = *((rbx - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rdi = *((rbx + rax));
    rax -= rdi;
    rdx = rax + rax + 1;
    if (rdx == 1) {
        rax = *(loc.camlPrintf__46);
        return rax;
    }
    rsi = *(loc.camlPrintf__45);
    do {
        r15 -= 0x38;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x18f7;
            rax = *(reloc.camlPrintf__loop_305);
            *(rdi) = rax;
            *((rdi + 8)) = 3;
            *((rdi + 0x10)) = rcx;
            *((rdi + 0x18)) = rbx;
            *((rdi + 0x20)) = rdx;
            *((rdi + 0x28)) = rsi;
            rax = 1;
            rbx = rdi;
            void (*0x41c740)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a930 */
#include <stdint.h>
 
int64_t caml_ml_string_length (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi - 8));
    rax >>= 0xa;
    rdx = rax*8;
    rax = rdx - 1;
    rdx = *((rdi + rdx - 1));
    rax -= rdx;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42fde0 */
#include <stdint.h>
 
int64_t caml_set_parser_trace (int64_t arg1) {
    rdi = arg1;
    rax -= rax;
    rdi >>= 1;
    rax &= 0xfffffffffffffffe;
    *(obj.caml_parser_trace) = edi;
    rax += 3;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425580 */
#include <stdint.h>
 
int64_t caml_fl_merge_block (int64_t arg1) {
    rdi = arg1;
    r9 = *((rdi - 8));
    rax = caml_fl_cur_size;
    rdx = caml_fl_merge;
    r8 = r9;
    r8 >>= 0xa;
    r10 = *(rdx);
    rax = r8 + rax + 1;
    *(obj.caml_fl_cur_size) = rax;
    if (*(obj.caml_allocation_policy) != 1) {
label_0:
        rcx = rdi - 8;
        if (rcx == *(obj.last_fragment)) {
            goto label_6;
        }
label_1:
        r11 = rcx;
        rcx = rdi;
label_2:
        rsi = rcx + r8*8;
        rax = r10 - 8;
        if (rax == rsi) {
            goto label_7;
        }
        rax = rsi;
label_3:
        rsi = *((rdx - 8));
        rsi >>= 0xa;
        rdi = rdx + rsi*8;
        if (r11 == rdi) {
            goto label_8;
        }
label_4:
        if (r8 == 0) {
            *(obj.last_fragment) = rcx;
            *(obj.caml_fl_cur_size)--;
            return rax;
        }
        r9 &= 0xfffffffffffffcff;
        *(rcx) = r10;
        *(rdx) = rcx;
        r9 |= 0x200;
        *(obj.caml_fl_merge) = rcx;
        *((rcx - 8)) = r9;
        return rax;
    }
    if (rdx == 0x64de30) {
        goto label_9;
    }
    eax = flp_size;
    if (eax <= 0) {
        goto label_10;
    }
    eax--;
    rcx = (int64_t) eax;
    rcx = *((rcx*8 + obj.flp));
    if (rdx <= *(rcx)) {
        goto label_11;
    }
    goto label_10;
    do {
        ecx = rax - 1;
        rsi = (int64_t) ecx;
        rsi = *((rsi*8 + obj.flp));
        if (rdx > *(rsi)) {
            goto label_12;
        }
        eax = ecx;
label_11:
    } while (eax != 0);
    *(obj.flp_size) = 0;
label_10:
    if (rdx > *(obj.beyond)) {
        goto label_0;
    }
label_5:
    rcx = rdi - 8;
    *(obj.beyond) = 0;
    if (rcx != *(obj.last_fragment)) {
        goto label_1;
    }
label_6:
    rax = *((rdi - 8));
    rsi = 0x3fffffffffffff;
    rax >>= 0xa;
    rax++;
    if (rax > rsi) {
        goto label_1;
    }
    r9 = rax;
    r11 = rdi - 0x10;
    r9 <<= 0xa;
    r8 = r9;
    *((rcx - 8)) = r9;
    *(obj.caml_fl_cur_size)++;
    r8 >>= 0xa;
    goto label_2;
label_7:
    rsi = *((r10 - 8));
    rdi = 0x3fffffffffffff;
    rbx = *(r10);
    rsi >>= 0xa;
    rsi = r8 + rsi + 1;
    if (rsi > rdi) {
        goto label_3;
    }
    *(rdx) = rbx;
    if (*(obj.caml_allocation_policy) == 0) {
        if (*(obj.fl_prev) != r10) {
            goto label_13;
        }
        *(obj.fl_prev) = rdx;
    }
label_13:
    rsi <<= 0xa;
    r10 = rbx;
    r9 = rsi + 0x200;
    r8 = r9;
    *((rcx - 8)) = r9;
    r8 >>= 0xa;
    rax = rcx + r8*8;
    goto label_3;
label_8:
    rsi = r8 + rsi + 1;
    rdi = 0x3ffffffffffffe;
    if (rsi > rdi) {
        goto label_4;
    }
    rsi <<= 0xa;
    rsi += 0x200;
    *((rdx - 8)) = rsi;
    return rax;
label_12:
    *(obj.flp_size) = eax;
    if (rdx > *(obj.beyond)) {
        goto label_0;
    }
    goto label_5;
label_9:
    *(obj.flp_size) = 0;
    *(obj.beyond) = 0;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4350d8 */
#include <stdint.h>
 
void fini (void) {
    /* [14] -r-x section size 14 named .fini */
    _do_global_dtors_aux ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d4a0 */
#include <stdint.h>
 
uint64_t camlPrintf_index_of_int_65 (void) {
    if (rax >= 1) {
        return;
    }
    rax = camlPervasives_string_of_int_154 ();
    rbx = rax;
    rax = *(loc.camlPrintf__55);
    camlPervasives_$5e_136 ();
    return camlPervasives_failwith_38 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c070 */
#include <stdint.h>
 
int64_t camlUnix_setsockopt_optint_686 (int64_t arg1) {
    rdi = arg1;
    rcx = rdi;
    rdi = 5;
    rsi = rax;
    rdx = rbx;
    rax = *(reloc.unix_setsockopt);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432a20 */
#include <stdint.h>
 
int64_t caml_weak_blit (int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h_3;
    int64_t var_10h_3;
    int64_t var_18h_3;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    r13 = rsi;
    rbx = rdx;
    r13++;
    if (r13 == 0) {
        goto label_3;
    }
    r12 = r8;
    rax = *((rdi - 8));
    r12 >>= 1;
    rdx = r12 + r13;
    rax >>= 0xa;
    if (rdx > rax) {
        goto label_3;
    }
    rcx >>= 1;
    r14 = rcx;
    r14++;
    if (r14 == 0) {
        goto label_3;
    }
    rax = *((rbx - 8));
    rdx = r12 + r14;
    rax >>= 0xa;
    if (rdx > rax) {
        goto label_3;
    }
    eax = caml_gc_phase;
    if (eax == 0) {
        if (*(obj.caml_gc_subphase) == 0xb) {
            goto label_4;
        }
    }
label_1:
    if (r13 <= r14) {
        goto label_5;
    }
    if (r12 == 0) {
        goto label_0;
    }
    esi = 0;
    r15d = 0;
    do {
        rax = rsi + r13;
        r15++;
        rsi += r14;
        rdi = rbx;
        rdx = *((rbp + rax*8));
        do_set ();
        rsi = r15;
    } while (r12 > r15);
    do {
label_0:
        eax = 1;
        return rax;
label_5:
        r13 = r12;
        r13--;
    } while (r13 < 0);
    rsi += r12;
    r12 += rcx;
    rbp = rbp + rsi*8;
    do {
        rdx = *(rbp);
        rsi = r12;
        rdi = rbx;
        rbp -= 8;
        r12--;
        eax = do_set ();
        r13--;
    } while (r13 >= 0);
    goto label_0;
label_4:
    if (r12 == 0) {
        goto label_1;
    }
    eax = 0;
    r15d = 0;
    goto label_6;
label_2:
    r15++;
    rax = r15;
    if (r12 <= r15) {
        goto label_1;
    }
label_6:
    rax += r13;
    r8 = rbp + rax*8;
    rdx = *(r8);
    if (rdx == *(obj.caml_weak_none)) {
        goto label_2;
    }
    if ((dl & 1) != 0) {
        goto label_2;
    }
    rdi = rdx;
    *((rsp + 0x18)) = rdx;
    *((rsp + 8)) = rcx;
    *(rsp) = rsi;
    *((rsp + 0x10)) = r8;
    al = caml_page_table_lookup ();
    rdx = *((rsp + 0x18));
    rcx = *((rsp + 8));
    rsi = *(rsp);
    r8 = *((rsp + 0x10));
    if ((al & 1) == 0) {
        goto label_2;
    }
    if ((*((rdx - 8)) & 0x300) != 0) {
        goto label_2;
    }
    rax = caml_weak_none;
    *(r8) = rax;
    goto label_2;
label_3:
    edi = "Weak.blit";
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429b00 */
#include <stdint.h>
 
void caml_int64_shift_right_unsigned (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdi = *((rdi + 8));
    rcx = rsi;
    rcx >>= 1;
    rdi >>= cl;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ac50 */
#include <stdint.h>
 
int64_t camlUnix_fun_1609 (void) {
    rdi = rax;
    rax = *(reloc.unix_gethostbyname);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b860 */
#include <stdint.h>
 
int64_t camlUnix_fun_1801 (void) {
    rdi = rax;
    rax = *(reloc.unix_error_message);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ae30 */
#include <stdint.h>
 
int64_t caml_array_unsafe_get (int64_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    if (*((rdi - 8)) != 0xfe) {
        rsi >>= 1;
        rax = *((rdi + rsi*8));
        return rax;
    }
    return caml_array_unsafe_get_float ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416b40 */
#include <stdint.h>
 
int64_t camlString_blit_84 (int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r9 = rdi;
    rcx = rsi;
    r8 = rdx;
    if (r8 >= 1) {
        if (rbx < 1) {
            goto label_0;
        }
        rdi = *((rax - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rax + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= r8;
        rdi += 2;
        if (rbx > rdi) {
            goto label_0;
        }
        if (rcx < 1) {
            goto label_0;
        }
        rdi = *((r9 - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((r9 + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= r8;
        rdi += 2;
        if (rcx > rdi) {
            goto label_0;
        }
        rdi = rax;
        rsi = rbx;
        rdx = r9;
        caml_blit_string ();
        return;
    }
label_0:
    rax = *(loc.camlString__30);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4172f0 */
#include <stdint.h>
 
int64_t camlString_lowercase_126 (void) {
    rbx = rax;
    rax = *(reloc.camlChar);
    rax = *((rax + 0x10));
    return camlString_map_118 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e760 */
#include <stdint.h>
 
uint64_t camlPrintf_ksprintf_443 (void) {
    rbx = *(reloc.camlPrintf);
    rbx = *((rbx + 0x130));
    rdi = *(rbx);
    rax = void (*rdi)() ();
    rcx = rax;
    rax = *(reloc.camlPrintf);
    r8 = *((rax + 0x118));
    rdx = *(loc.camlPrintf__40);
    rax = *(reloc.camlBuffer);
    rsi = *((rax + 0x48));
    rax = *(reloc.camlBuffer);
    rdi = *((rax + 0x40));
    rax = *(reloc.camlPrintf);
    rbx = *((rax + 0x120));
    rax = 3;
    return caml_apply6 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d530 */
#include <stdint.h>
 
uint64_t camlPrintf_bad_conversion_85 (int64_t arg1) {
    int64_t var_10h;
    rdi = arg1;
    *(rsp) = rbx;
    *((rsp + 0x10)) = rdi;
    rbx = *(loc.camlPrintf__54);
    rax = camlPervasives_$5e_136 ();
    rbx = rax;
    rax = *(loc.camlPrintf__53);
    rax = camlPervasives_$5e_136 ();
    *((rsp + 8)) = rax;
    rax = *(rsp);
    camlPervasives_string_of_int_154 ();
    rbx = *((rsp + 8));
    rax = camlPervasives_$5e_136 ();
    rbx = rax;
    rax = *(loc.camlPrintf__52);
    rax = camlPervasives_$5e_136 ();
    *(rsp) = rax;
    rax = 3;
    rbx = *((rsp + 0x10));
    camlString_make_66 ();
    rbx = *(rsp);
    rax = camlPervasives_$5e_136 ();
    rbx = rax;
    rax = *(loc.camlPrintf__51);
    camlPervasives_$5e_136 ();
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a4a0 */
#include <stdint.h>
 
int64_t camlBuffer_add_substring_104 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, signed int64_t arg2, signed int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10) {
    signed int64_t var_8h_2;
    signed int64_t var_10h_2;
    int64_t var_18h;
    int64_t var_20h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    *((rsp + 0x20)) = rax;
    *(rsp) = rbx;
    *((rsp + 8)) = rdi;
    *((rsp + 0x10)) = rsi;
    if (rdi >= 1) {
        if (rsi < 1) {
            goto label_0;
        }
        rax = *((rbx - 8));
        rax >>= 0xa;
        rax = rax*8 - 1;
        rbx = *((rbx + rax));
        rax -= rbx;
        rax <<= 1;
        rax -= rsi;
        rax += 2;
        if (rdi <= rax) {
            goto label_1;
        }
    }
label_0:
    rax = *(loc.camlBuffer__22);
    camlPervasives_invalid_arg_40 ();
label_1:
    rax = *((rsp + 0x20));
    rdi = *((rax + 8));
    rbx = *((rsp + 0x10));
    rsi = rdi + rbx - 1;
    *((rsp + 0x18)) = rsi;
    rdi = *((rax + 0x10));
    if (rsi > rdi) {
        camlBuffer_resize_94 ();
    }
    rax = *((rsp + 0x20));
    rsi = *((rax + 8));
    rdi = *(rax);
    rax = *(rsp);
    rbx = *((rsp + 8));
    rdx = *((rsp + 0x10));
    camlString_blit_84 ();
    rbx = *((rsp + 0x18));
    rax = *((rsp + 0x20));
    *((rax + 8)) = rbx;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b6a0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1773 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_open);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x431d10 */
#include <stdint.h>
 
uint64_t caml_MD5Update (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r13 = rsi;
    r12 = rdi;
    r14d = *((rdi + 0x10));
    eax = r14 + rdx*8;
    *((rdi + 0x10)) = eax;
    if (r14d > eax) {
        goto label_1;
    }
    eax = *((rdi + 0x14));
label_0:
    rdx = rbp;
    r14d >>= 3;
    rbx = r12 + 0x18;
    rdx >>= 0x1d;
    eax += edx;
    r14d &= 0x3f;
    *((r12 + 0x14)) = eax;
    if (r14d != 0) {
        eax = r14d;
        rdx = rbp;
        rsi = r13;
        rdi = r12 + rax + 0x18;
        eax = 0x40;
        eax -= r14d;
        r14 = rax;
        if (rbp < rax) {
            goto label_2;
        }
        r13 += r14;
        memcpy (rdi, r13, rax);
        rbp -= r14;
        rsi = rbx;
        rdi = r12;
        rax = caml_MD5Transform ();
    }
    if (rbp <= 0x3f) {
        goto label_3;
    }
    r14d = 0;
    do {
        rax = r13 + r14;
        rsi = rbx;
        rdi = r12;
        r14 += 0x40;
        rdx = *(rax);
        *(rbx) = rdx;
        rdx = *((rax + 8));
        *((rbx + 8)) = rdx;
        rdx = *((rax + 0x10));
        *((rbx + 0x10)) = rdx;
        rdx = *((rax + 0x18));
        *((rbx + 0x18)) = rdx;
        rdx = *((rax + 0x20));
        *((rbx + 0x20)) = rdx;
        rdx = *((rax + 0x28));
        *((rbx + 0x28)) = rdx;
        rdx = *((rax + 0x30));
        *((rbx + 0x30)) = rdx;
        rax = *((rax + 0x38));
        *((rbx + 0x38)) = rax;
        caml_MD5Transform ();
        rax = rbp;
        rax -= r14;
    } while (rax > 0x3f);
    rbp -= 0x40;
    rax = rbp;
    ebp &= 0x3f;
    rax &= 0xffffffffffffffc0;
    r13 = r13 + rax + 0x40;
label_3:
    rdx = rbp;
    rsi = r13;
    rdi = rbx;
label_2:
    void (*0x409370)() ();
label_1:
    eax = *((rdi + 0x14));
    eax++;
    *((rdi + 0x14)) = eax;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429d80 */
#include <stdint.h>
 
int32_t caml_int32_mod (int64_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    ecx = *((rsi + 8));
    edi = *((rdi + 8));
    if (ecx == 0) {
        goto label_0;
    }
    while (edi != 0x80000000) {
        edx = edi;
        eax = edi;
        edx >>= 0x1f;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        edi = edx;
        void (*0x429c80)() ();
    }
    edi = 0;
    void (*0x429c80)() ();
label_0:
    return caml_raise_zero_divide ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x430a80 */
#include <stdint.h>
 
int32_t caml_gc_minor (void) {
    caml_minor_collection ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429e80 */
#include <stdint.h>
 
uint64_t caml_neq_float (int64_t arg3, int64_t arg1) {
    rdx = arg3;
    rdi = arg1;
    xmm0 = *(rdi);
    __asm ("ucomisd xmm0, qword [rsi]");
    al = (? != ?) ? 1 : 0;
    __asm ("setp dl");
    eax |= edx;
    eax = (int32_t) al;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b0f0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1683 (void) {
    rdi = rax;
    rax = *(reloc.unix_sigpending);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429850 */
#include <stdint.h>
 
void caml_nativeint_neg (int64_t arg1) {
    rdi = arg1;
    rdi = *((rdi + 8));
    rdi = -rdi;
    return caml_copy_nativeint ();
}


r2dec has crashed (info: SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418e50).
Please report the bug at https://github.com/radareorg/r2dec-js/issues
Use the option '--issue' or the command 'pddi' to generate 
the needed data for the issue.
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415760 */
#include <stdint.h>
 
int64_t camlList_fold_left2_147 (int64_t arg6, int64_t arg5, int64_t arg4, uint32_t arg2, uint32_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    uint32_t var_8h;
    uint32_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        rdx = rax;
        if (rdi == 1) {
            goto label_0;
        }
        if (rsi == 1) {
            goto label_1;
        }
        *(rsp) = rdx;
        rcx = *((rsi + 8));
        *((rsp + 0x10)) = rcx;
        rcx = *(rsi);
        rsi = *((rdi + 8));
        *((rsp + 8)) = rsi;
        rsi = *(rdi);
        rax = rbx;
        rbx = rsi;
        rdi = rcx;
        rsi = rdx;
        rax = caml_apply3 ();
        rbx = rax;
        rax = *(rsp);
        rdi = *((rsp + 8));
        rsi = *((rsp + 0x10));
    } while (1);
label_0:
    if (rsi == 1) {
        rax = rbx;
        return rax;
    }
label_1:
    rax = *(loc.camlList__45);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b280 */
#include <stdint.h>
 
int64_t camlUnix_fun_1707 (void) {
    rdi = rax;
    rax = *(reloc.unix_opendir);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424a80 */
#include <stdint.h>
 
int64_t caml_record_signal (int64_t arg1) {
    rdi = arg1;
    rax = caml_young_end;
    rdi = (int64_t) edi;
    *((rdi*8 + obj.caml_pending_signals)) = 1;
    *(obj.caml_signals_are_pending) = 1;
    *(obj.caml_young_limit) = rax;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ce00 */
#include <stdint.h>
 
int64_t camlUnix_open_process_in_983 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    *((rsp + 8)) = rax;
    rdi = 1;
    rax = *(reloc.unix_pipe);
    rax = caml_c_call ();
    rbx = *((rax + 8));
    *((rsp + 0x10)) = rbx;
    rdi = *(rax);
    *(rsp) = rdi;
    rax = *(reloc.caml_ml_open_descriptor_in);
    rax = caml_c_call ();
    rdi = rax;
    *((rsp + 0x18)) = rdi;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdx = r15 + 8;
            *((rdx - 8)) = 0x800;
            rax = *(rsp);
            *(rdx) = rax;
            *((rdx + 8)) = 1;
            rbx = rdx + 0x18;
            *((rbx - 8)) = 0x401;
            *(rbx) = rdi;
            rdi = 1;
            rax = *((rsp + 8));
            rsi = *((rsp + 0x10));
            camlUnix_open_proc_975 ();
            rdi = *((rsp + 0x10));
            rax = *(reloc.unix_close);
            caml_c_call ();
            rax = *((rsp + 0x18));
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429650 */
#include <stdint.h>
 
void caml_int32_float_of_bits (int64_t arg1) {
    rdi = arg1;
    xmm0 = *((rdi + 8));
    __asm ("cvtps2pd xmm0, xmm0");
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410220 */
#include <stdint.h>
 
int64_t camlPervasives_input_248 (int64_t arg6, int64_t arg5, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rdi;
    rcx = rsi;
    if (rdx >= 1) {
        if (rcx < 1) {
            goto label_0;
        }
        rdi = *((rbx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rbx + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= rcx;
        rdi += 2;
        if (rdx > rdi) {
            goto label_0;
        }
        rdi = rax;
        rsi = rbx;
        rax = *(reloc.caml_ml_input);
        caml_c_call ();
        return rax;
    }
label_0:
    rax = *(loc.camlPervasives__88);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a1e0 */
#include <stdint.h>
 
void caml_acos_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    acos (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41aa50 */
#include <stdint.h>
 
int64_t camlBuffer_entry (void) {
    rbx = *(loc.camlBuffer__20);
    rax = *(reloc.camlBuffer);
    *(rax) = rbx;
    rbx = *(loc.camlBuffer__19);
    rax = *(reloc.camlBuffer);
    *((rax + 8)) = rbx;
    rbx = *(loc.camlBuffer__18);
    rax = *(reloc.camlBuffer);
    *((rax + 0x10)) = rbx;
    rbx = *(loc.camlBuffer__17);
    rax = *(reloc.camlBuffer);
    *((rax + 0x18)) = rbx;
    rbx = *(loc.camlBuffer__16);
    rax = *(reloc.camlBuffer);
    *((rax + 0x20)) = rbx;
    rbx = *(loc.camlBuffer__15);
    rax = *(reloc.camlBuffer);
    *((rax + 0x28)) = rbx;
    rbx = *(loc.camlBuffer__14);
    rax = *(reloc.camlBuffer);
    *((rax + 0x30)) = rbx;
    rbx = *(loc.camlBuffer__13);
    rax = *(reloc.camlBuffer);
    *((rax + 0x38)) = rbx;
    rbx = *(loc.camlBuffer__12);
    rax = *(reloc.camlBuffer);
    *((rax + 0x78)) = rbx;
    rbx = *(loc.camlBuffer__11);
    rax = *(reloc.camlBuffer);
    *((rax + 0x40)) = rbx;
    rbx = *(loc.camlBuffer__10);
    rax = *(reloc.camlBuffer);
    *((rax + 0x50)) = rbx;
    rbx = *(loc.camlBuffer__9);
    rax = *(reloc.camlBuffer);
    *((rax + 0x48)) = rbx;
    rbx = *(loc.camlBuffer__8);
    rax = *(reloc.camlBuffer);
    *((rax + 0x60)) = rbx;
    rbx = *(loc.camlBuffer__7);
    rax = *(reloc.camlBuffer);
    *((rax + 0x68)) = rbx;
    rbx = *(loc.camlBuffer__6);
    rax = *(reloc.camlBuffer);
    *((rax + 0x70)) = rbx;
    rbx = *(loc.camlBuffer__5);
    rax = *(reloc.camlBuffer);
    *((rax + 0x80)) = rbx;
    rbx = *(loc.camlBuffer__4);
    rax = *(reloc.camlBuffer);
    *((rax + 0x88)) = rbx;
    rbx = *(loc.camlBuffer__3);
    rax = *(reloc.camlBuffer);
    *((rax + 0x90)) = rbx;
    rbx = *(loc.camlBuffer__2);
    rax = *(reloc.camlBuffer);
    *((rax + 0x98)) = rbx;
    rbx = *(loc.camlBuffer__1);
    rax = *(reloc.camlBuffer);
    *((rax + 0x58)) = rbx;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429e20 */
#include <stdint.h>
 
void caml_int32_sub (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    edi = *((rdi + 8));
    edi -= *((rsi + 8));
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b170 */
#include <stdint.h>
 
int64_t caml_array_unsafe_set (int64_t arg3, int64_t arg2, uint32_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    if (*((rdi - 8)) != 0xfe) {
        void (*0x42b090)() ();
    }
    rax = *(rdx);
    rsi >>= 1;
    *((rdi + rsi*8)) = rax;
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b720 */
#include <stdint.h>
 
int64_t camlUnix_fun_1781 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_waitpid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421701 */
#include <stdint.h>
 
void unix_sendto (int64_t arg1) {
    rdi = arg1;
    rcx = *((rdi + 0x18));
    rdx = *((rdi + 0x10));
    rsi = *((rdi + 8));
    r9 = *((rdi + 0x28));
    r8 = *((rdi + 0x20));
    rdi = *(rdi);
    unix_sendto_native ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410330 */
#include <stdint.h>
 
int64_t camlPervasives_really_input_259 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, signed int64_t arg2, signed int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rdi >= 1) {
        if (rsi < 1) {
            goto label_0;
        }
        rdx = *((rbx - 8));
        rdx >>= 0xa;
        rdx = rdx*8 - 1;
        rcx = *((rbx + rdx));
        rdx -= rcx;
        rdx <<= 1;
        rdx -= rsi;
        rdx += 2;
        if (rdi > rdx) {
            goto label_0;
        }
        void (*0x410290)() ();
    }
label_0:
    rax = *(loc.camlPervasives__87);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a9c0 */
#include <stdint.h>
 
uint64_t caml_string_notequal (void) {
    rax = caml_string_equal ();
    rdx = rax;
    eax = 4;
    rax -= rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415590 */
#include <stdint.h>
 
uint64_t camlList_fold_right_112 (int64_t arg1) {
    int64_t var_8h;
    rdi = arg1;
    do {
        if (rbx == 1) {
            goto label_0;
        }
        *((rsp + 8)) = rax;
        rdx = *((rbx + 8));
        rsi = *(rbx);
        *(rsp) = rsi;
        rbx = rdx;
        rax = camlList_fold_right_112 ();
    } while (1);
    rbx = rax;
    rax = *(rsp);
    rdi = *((rsp + 8));
    void (*0x40a5b0)() ();
label_0:
    rax = rdi;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x413440 */
#include <stdint.h>
 
uint64_t camlArray_iteri_138 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = 1;
    rsi = *((rbx - 8));
    rsi >>= 9;
    rsi |= 1;
    rsi += 0xfffffffffffffffe;
    if (rdi > rsi) {
        goto label_1;
    }
    *((rsp + 0x18)) = rsi;
    *((rsp + 0x10)) = rdi;
    *(rsp) = rbx;
    *((rsp + 8)) = rax;
    do {
        rsi = *(rsp);
        rax = *((rsi - 8));
        if (rax != 0xfe) {
            rbx = *((rsi + rdi*4 - 4));
        } else {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_2;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rsi + rdi*4 - 4]");
            __asm ("movlpd qword [rbx], xmm0");
        }
        rax = rdi;
        rdi = *((rsp + 8));
        caml_apply2 ();
        rdi = *((rsp + 0x10));
        rbx = *((rsp + 0x10));
        rdi += 2;
        *((rsp + 0x10)) = rdi;
        rax = *((rsp + 0x18));
    } while (rbx != rax);
label_1:
    rax = 1;
    return rax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4197e0 */
#include <stdint.h>
 
int64_t camlHashtbl_iter_157 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
label_0:
    r15 -= 0x20;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    rsi = r15 + 8;
    *((rsi - 8)) = 0xcf7;
    rax = *(reloc.camlHashtbl__do_bucket_160);
    *(rsi) = rax;
    *((rsi + 8)) = 3;
    *((rsi + 0x10)) = rdi;
    rdi = *((rbx + 8));
    rbx = 1;
    rax = *((rdi - 8));
    rax >>= 9;
    rax |= 1;
    rax += 0xfffffffffffffffe;
    if (rbx > rax) {
        goto label_2;
    }
    *((rsp + 0x18)) = rax;
    *((rsp + 0x10)) = rbx;
    *(rsp) = rdi;
    *((rsp + 8)) = rsi;
    do {
        rax = *(rsp);
        rdi = *((rax - 8));
        rdi >>= 9;
        if (rdi <= rbx) {
            goto label_3;
        }
        rax = *((rax + rbx*4 - 4));
        rbx = *((rsp + 8));
        camlHashtbl_do_bucket_160 ();
        rbx = *((rsp + 0x10));
        rdi = *((rsp + 0x10));
        rbx += 2;
        *((rsp + 0x10)) = rbx;
        rax = *((rsp + 0x18));
    } while (rdi != rax);
label_2:
    rax = 1;
    return rax;
label_1:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4167c0 */
#include <stdint.h>
 
int64_t camlChar_uppercase_73 (void) {
    if (rax >= 0xc3) {
        if (rax <= 0xf5) {
            goto label_0;
        }
    }
    if (rax >= 0x1c1) {
        if (rax <= 0x1ed) {
            goto label_0;
        }
    }
    if (rax >= 0x1f1) {
        if (rax <= 0x1fd) {
            goto label_0;
        }
    }
    return;
label_0:
    rax += 0xffffffffffffffc0;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433bf0 */
#include <stdint.h>
 
int64_t caml_final_do_weak_roots (int64_t arg1) {
    rdi = arg1;
    r12 = rdi;
    if (*(obj.old) == 0) {
        goto label_0;
    }
    ebp = 0;
    ebx = 0;
    do {
        rax = rbp;
        rax += *(obj.final_table);
        rbx++;
        rbp += 0x18;
        rsi = rax + 8;
        rdi = *((rax + 8));
        void (*r12)() ();
    } while (*(obj.old) > rbx);
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a290 */
#include <stdint.h>
 
int64_t camlBuffer_length_88 (void) {
    rax = *((rax + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ac10 */
#include <stdint.h>
 
int64_t camlUnix_fun_1605 (void) {
    rdi = rax;
    rax = *(reloc.unix_getprotobyname);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40f9d0 */
#include <stdint.h>
 
int64_t camlPervasives_fun_416 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_ml_set_binary_mode);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423d60 */
#include <stdint.h>
 
int64_t caml_do_local_roots (int64_t arg5, int64_t arg4, uint32_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    *((rsp + 8)) = r8;
    if (rsi == 0) {
        goto label_4;
    }
    *(rsp) = rcx;
    rcx = *(obj.caml_frame_descriptors_mask);
    r15 = rsi;
    rdi = caml_frame_descriptors;
label_1:
    rax = rdx;
    rax >>= 3;
    rax &= rcx;
    rbp = *((rdi + rax*8));
    if (*(rbp) == rdx) {
        goto label_5;
    }
    do {
        rax++;
        rax &= rcx;
        rbp = *((rdi + rax*8));
    } while (*(rbp) != rdx);
label_5:
    eax = *((rbp + 8));
    if (ax == 0xffff) {
        goto label_6;
    }
    r14d = *((rbp + 0xa));
    if (r14w == 0) {
        goto label_7;
    }
    r13 = rbp + 0xc;
    r12d = 0;
    r14d = (int32_t) r14w;
    while ((al & 1) != 0) {
        rdx = *(rsp);
        eax >>= 1;
        rax = (int64_t) eax;
        rax = rdx + rax*8;
label_0:
        r12d++;
        rsi = rax;
        rdi = *(rax);
        void (*rbx)() ();
        if (r14d == r12d) {
            goto label_8;
        }
        r13 += 2;
        eax = *(r13);
    }
    rax = (int64_t) eax;
    rax = r15 + rax;
    goto label_0;
label_8:
    eax = *((rbp + 8));
    rcx = *(obj.caml_frame_descriptors_mask);
    rdi = caml_frame_descriptors;
label_7:
    eax &= 0xfffc;
    r15 += rax;
    rdx = *((r15 - 8));
    goto label_1;
label_6:
    rax = r15 + 0x10;
    r15 = *((r15 + 0x10));
    rdx = *((rax + 8));
    rax = *((rax + 0x10));
    *(rsp) = rax;
    if (r15 != 0) {
        goto label_1;
    }
label_4:
    r12 = *((rsp + 8));
    if (r12 == 0) {
        goto label_9;
    }
label_3:
    r14d = 0;
    if (*((r12 + 8)) <= 0) {
        goto label_10;
    }
label_2:
    if (*((r12 + 0x10)) <= 0) {
        goto label_11;
    }
    r13 = (int64_t) r14d;
    ebp = 0;
    eax = 0;
    r13 += 2;
    do {
        rax <<= 3;
        rax += *((r12 + r13*8 + 8));
        ebp++;
        rsi = rax;
        rdi = *(rax);
        void (*rbx)() ();
        rax = (int64_t) ebp;
    } while (rax < *((r12 + 0x10)));
label_11:
    r14d++;
    r13 = (int64_t) r14d;
    if (r13 < *((r12 + 8))) {
        goto label_2;
    }
label_10:
    r12 = *(r12);
    if (r12 != 0) {
        goto label_3;
    }
label_9:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c040 */
#include <stdint.h>
 
int64_t camlUnix_getsockopt_optint_683 (void) {
    rdi = 5;
    rsi = rax;
    rdx = rbx;
    rax = *(reloc.unix_getsockopt);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a1d0 */
#include <stdint.h>
 
int64_t camlBuffer_blit_79 (int64_t arg6, int64_t arg5, int64_t arg4, signed int64_t arg3, signed int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rdx >= 1) {
        if (rbx < 1) {
            goto label_0;
        }
        rcx = *((rax + 8));
        rcx -= rdx;
        rcx++;
        if (rbx > rcx) {
            goto label_0;
        }
        if (rsi < 1) {
            goto label_0;
        }
        rcx = *((rdi - 8));
        rcx >>= 0xa;
        rcx = rcx*8 - 1;
        r8 = *((rdi + rcx));
        rcx -= r8;
        rcx <<= 1;
        rcx -= rdx;
        rcx += 2;
        if (rsi > rcx) {
            goto label_0;
        }
        rax = *(rax);
        void (*0x416b40)() ();
    }
label_0:
    rax = *(loc.camlBuffer__25);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4275c0 */
#include <stdint.h>
 
int32_t caml_allocation_color (uint32_t arg1) {
    rdi = arg1;
    eax = caml_gc_phase;
    if (eax == 0) {
        goto label_0;
    }
    while (rdi < *(obj.caml_gc_sweep_hp)) {
        eax = 0;
        return eax;
    }
label_0:
    eax = 0x300;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429c50 */
#include <stdint.h>
 
void caml_int64_sub (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdi = *((rdi + 8));
    rdi -= *((rsi + 8));
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bf60 */
#include <stdint.h>
 
int64_t camlUnix_fun_1833 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_getsockopt);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4309d0 */
#include <stdint.h>
 
int32_t caml_gc_full_major (void) {
    edx = 0;
    esi = "Full major GC cycle requested\n";
    edi = 1;
    caml_gc_message ();
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    caml_final_do_calls ();
    caml_empty_minor_heap ();
    caml_finish_major_cycle ();
    test_and_compact ();
    caml_final_do_calls ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418e00 */
#include <stdint.h>
 
int64_t camlHashtbl_copy_85 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    *(rsp) = rax;
    rax = *((rax + 8));
    rax = camlArray_copy_77 ();
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *(rsp);
            rbx = *(rbx);
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4129a0 */
#include <stdint.h>
 
int64_t camlArray_copy_77 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rbx = rax;
    rdi = *((rbx - 8));
    rdi >>= 9;
    rdi |= 1;
    if (rdi == 1) {
        rax = *(loc.camlArray__31);
        return rax;
    }
    *(rsp) = rdi;
    *((rsp + 8)) = rbx;
    rax = *((rbx - 8));
    if (rax != 0xfe) {
        rsi = *(rbx);
    } else {
label_1:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_2;
        }
        rsi = r15 + 8;
        *((rsi - 8)) = 0x4fd;
        __asm ("movlpd xmm0, qword [rbx]");
        __asm ("movlpd qword [rsi], xmm0");
    }
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = 3;
    r12 = *(rsp);
    r12 += 0xfffffffffffffffe;
    if (rbx > r12) {
        goto label_3;
    }
    do {
        rdi = *((rsp + 8));
        rax = *((rdi - 8));
        if (rax != 0xfe) {
            rsi = *((rdi + rbx*4 - 4));
        } else {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_4;
            }
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdi + rbx*4 - 4]");
            __asm ("movlpd qword [rsi], xmm0");
        }
        rax = *((rbp - 8));
        if (rax != 0xfe) {
            rdi = rbp + rbx*4 - 4;
            caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [rbp + rbx*4 - 4], xmm0");
        }
        rax = rbx;
        rbx += 2;
    } while (rax != r12);
label_3:
    rax = rbp;
    return rax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b240 */
#include <stdint.h>
 
int64_t camlUnix_fun_1703 (void) {
    rdi = rax;
    rax = *(reloc.unix_rewinddir);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b7a0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1789 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_execvp);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40abd0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1601 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_getservbyname);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b130 */
#include <stdint.h>
 
int64_t camlUnix_fun_1687 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_kill);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x426d10 */
#include <stdint.h>
 
uint64_t caml_oldify_one (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
label_1:
    r12 = rsi;
    rbx = rdi;
label_0:
    if ((bl & 1) != 0) {
        goto label_5;
    }
    while (rbx <= *(obj.caml_young_start)) {
label_5:
        *(r12) = rbx;
label_2:
        return;
    }
    rbp = *((rbx - 8));
    r13 = rbx - 8;
    if (rbp != 0) {
        esi = ebp;
        esi &= 0xff;
        if (esi > 0xf8) {
            if (esi > 0xfa) {
                goto label_6;
            }
            if (esi == 0xf9) {
                goto label_7;
            }
            rbp = *(rbx);
            if ((bpl & 1) == 0) {
                goto label_8;
            }
label_4:
            rbx = rbp;
            goto label_0;
        }
        rbp >>= 0xa;
        rdi = rbp;
        rax = caml_alloc_shr ();
        *(r12) = rax;
        rdx = *(rbx);
        *(r13) = 0;
        *(rbx) = rax;
        if (rbp > 1) {
            goto label_9;
        }
        r12 = rax;
        rbx = rdx;
        goto label_0;
label_8:
        rdi = rbp;
        al = caml_page_table_lookup ();
        if ((al & 7) != 0) {
            rax = rbp - 8;
            if (*((rbp - 8)) == 0) {
                rax = *(rbp);
                rax -= 8;
            }
            eax = *(rax);
            if (eax != 0xfa) {
                goto label_10;
            }
        }
label_3:
        esi = 0xfa;
        edi = 1;
        rax = caml_alloc_shr ();
        *(r12) = rax;
        *(r13) = 0;
        r12 = rax;
        *(rbx) = rax;
        rbx = rbp;
        goto label_0;
    }
    rax = *(rbx);
    *(r12) = rax;
    return rax;
label_6:
    rbp >>= 0xa;
    rdi = rbp;
    rax = caml_alloc_shr ();
    if (rbp == 0) {
        goto label_11;
    }
    edx = 0;
    do {
        rcx = *((rbx + rdx*8));
        *((rax + rdx*8)) = rcx;
        rdx++;
    } while (rbp > rdx);
label_11:
    *(r13) = 0;
    *(rbx) = rax;
    *(r12) = rax;
    return rax;
label_7:
    rbp >>= 0xa;
    rdi = rbx;
    rsi = r12;
    rbp <<= 3;
    rdi -= rbp;
    caml_oldify_one ();
    goto label_1;
    *(r12) += rbp;
    return rax;
label_9:
    *(rax) = rdx;
    rdx = oldify_todo_list;
    *((rax + 8)) = rdx;
    *(obj.oldify_todo_list) = rbx;
    goto label_2;
label_10:
    if (eax == 0xfd) {
        goto label_3;
    }
    if (eax != 0xf6) {
        goto label_4;
    }
    goto label_3;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d490 */
#include <stdint.h>
 
void camlPrintf_fun_740 (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d800 */
#include <stdint.h>
 
uint64_t camlUnix_open_connection_1044 (void) {
    int64_t var_8h;
    int64_t var_18h;
    *(rsp) = rax;
    rax = camlUnix_domain_of_sockaddr_555 ();
    rdx = 1;
    rsi = 1;
    rdi = rax;
    rax = *(reloc.unix_socket);
    rax = caml_c_call ();
    *((rsp + 8)) = rax;
    rax = void (*0x40d854)() ();
    *(rsp) = rax;
    rdi = *((rsp + 8));
    rax = *(reloc.unix_close);
    caml_c_call ();
    rax = *(rsp);
    rax = caml_raise_exn ();
    r14 = rsp;
    rdi = rax;
    rsi = *((rsp + 0x10));
    rax = *(reloc.unix_connect);
    caml_c_call ();
    rax = *((rsp + 0x18));
    camlUnix_try_set_close_on_exec_394 ();
    rdi = *((rsp + 0x18));
    rax = *(reloc.caml_ml_open_descriptor_out);
    rax = caml_c_call ();
    *((rsp + 0x10)) = rax;
    rdi = *((rsp + 0x18));
    rax = *(reloc.caml_ml_open_descriptor_in);
    rax = caml_c_call ();
    rbx = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            *(rax) = rbx;
            rbx = *((rsp + 0x10));
            *((rax + 8)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bc30 */
#include <stdint.h>
 
uint64_t camlUnix_try_set_close_on_exec_394 (void) {
    rax = void (*0x40bc5c)() ();
    rdi = *(reloc.caml_exn_Invalid_argument);
    rbx = *(rax);
    if (rbx == rdi) {
        rax = 1;
        return rax;
    }
    rax = caml_raise_exn ();
    r14 = rsp;
    rdi = rax;
    rax = *(reloc.unix_set_close_on_exec);
    caml_c_call ();
    rax = 3;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40aa90 */
#include <stdint.h>
 
int64_t camlUnix_fun_1876 (void) {
    rdi = rax;
    rax = *(reloc.unix_close);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410430 */
#include <stdint.h>
 
int64_t camlPervasives_print_char_290 (void) {
    rbx = *(reloc.camlPervasives);
    rdi = *((rbx + 0xb8));
    rsi = rax;
    rax = *(reloc.caml_ml_output_char);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x431560 */
#include <stdint.h>
 
void caml_MD5Init (int64_t arg1) {
    rdi = arg1;
    *(rdi) = 0x67452301;
    *((rdi + 4)) = 0xefcdab89;
    *((rdi + 8)) = 0x98badcfe;
    *((rdi + 0xc)) = 0x10325476;
    *((rdi + 0x10)) = 0;
    *((rdi + 0x14)) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x419720 */
#include <stdint.h>
 
int64_t camlHashtbl_mem_150 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r12 = rax;
    rdx = rbx;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0xcf7;
            rax = *(reloc.camlHashtbl__mem_in_bucket_153);
            *(rbx) = rax;
            *((rbx + 8)) = 3;
            *((rbx + 0x10)) = rdx;
            rax = *((r12 + 8));
            rbp = *((rax - 8));
            rbp >>= 0xa;
            if (rbp != 0) {
                rsi = 0xc9;
                rdi = 0x15;
                rax = caml_hash_univ_param ();
                rax >>= 1;
                rcx = rbp;
                __asm ("cqo");
                rax = rdx:rax / rcx;
                rdx = rdx:rax % rcx;
            } else {
                rax = *(reloc.caml_bucket_Division_by_zero);
                caml_raise_exn ();
            }
            rdx <<= 1;
            rdx++;
            rdi = *((r12 + 8));
            rax = *((rdi - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_0;
            }
            rax = *((rdi + rdx*4 - 4));
            void (*0x4182b0)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4324d0 */
#include <stdint.h>
 
uint64_t caml_fatal_uncaught_exception (int64_t arg1) {
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    *((rsp - 8)) = r12;
    rax = caml_format_exception ();
    edi = "Pervasives.do_at_exit";
    r12d = caml_backtrace_active;
    rbx = rax;
    ebp = caml_backtrace_pos;
    *(obj.caml_backtrace_active) = 0;
    rax = caml_named_value ();
    if (rax != 0) {
        rdi = *(rax);
        esi = 1;
        eax = caml_callback_exn ();
    }
    rdi = stderr;
    rcx = rbx;
    edx = "Fatal error: exception %s\n";
    esi = 1;
    eax = 0;
    *(obj.caml_backtrace_active) = r12d;
    *(obj.caml_backtrace_pos) = ebp;
    fprintf_chk ();
    free (rbx);
    eax = caml_backtrace_active;
    while (1) {
        exit (2);
        caml_print_exception_backtrace ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b760 */
#include <stdint.h>
 
int64_t camlUnix_fun_1785 (void) {
    rdi = rax;
    rax = *(reloc.unix_fork);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434510 */
#include <stdint.h>
 
void caml_dlerror (void) {
    return dlerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429f20 */
#include <stdint.h>
 
int64_t caml_float_compare (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    xmm0 = *(rdi);
    xmm1 = *(rsi);
    __asm ("ucomisd xmm0, xmm1");
    if (? == ?) {
        goto label_1;
    }
    while (? == ?) {
label_0:
        eax = 1;
        return eax;
label_1:
        __asm ("ucomisd xmm1, xmm0");
        if (? > ?) {
            goto label_2;
        }
        __asm ("ucomisd xmm0, xmm1");
        if (? <= ?) {
            __asm ("ucomisd xmm0, xmm0");
            if (? == ?) {
                goto label_3;
            }
            if (? != ?) {
                goto label_3;
            }
        }
        eax = 3;
        return eax;
label_3:
        __asm ("ucomisd xmm1, xmm1");
    }
    if (? != ?) {
        goto label_0;
    }
label_2:
    rax = 0xffffffffffffffff;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e6b0 */
#include <stdint.h>
 
int64_t camlPrintf_bprintf_432 (int64_t arg6, int64_t arg5, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rbx = rax;
    rax = *(loc.camlPrintf__41);
    return camlPrintf_kbprintf_429 ();
}


r2dec has crashed (info: SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429890).
Please report the bug at https://github.com/radareorg/r2dec-js/issues
Use the option '--issue' or the command 'pddi' to generate 
the needed data for the issue.
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4178a0 */
#include <stdint.h>
 
int64_t loc_camlSys_code_begin (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.camlSys);
            rbx = *((rbx + 0xe8));
            *(rax) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ab10 */
#include <stdint.h>
 
int64_t camlUnix_fun_1589 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_tcflush);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b2b0 */
#include <stdint.h>
 
void caml_array_set (int64_t arg3, int64_t arg2, uint32_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    if (*((rdi - 8)) != 0xfe) {
        void (*0x42b1c0)() ();
    }
    return caml_array_set_float ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b5c0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1759 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_truncate);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a500 */
#include <stdint.h>
 
uint64_t caml_apply4 (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_10h_2;
    int64_t var_8h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rcx = *((rdx + 8));
    if (rcx == 9) {
        rcx = *((rdx + 0x10));
        void (*rcx)() ();
    }
    rdi = *(rdx);
    rbx = rdx;
    rax = void (*rdi)(uint64_t, uint64_t) (rsi, rdi);
    rbx = rax;
    rdi = *(rbx);
    rax = *(rsp);
    rax = void (*rdi)() ();
    rbx = rax;
    rdi = *(rbx);
    rax = *((rsp + 8));
    rax = void (*rdi)() ();
    rbx = rax;
    rdi = *(rbx);
    rax = *((rsp + 0x10));
    return void (*rdi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40aad0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1585 (void) {
    rdi = rax;
    rax = *(reloc.unix_setsid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432930 */
#include <stdint.h>
 
uint64_t caml_callbackN (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rax = caml_callbackN_exn ();
    rdx = rax;
    edx &= 3;
    if (rdx != 2) {
        return rax;
    }
    rdi = rax;
    rdi &= 0xfffffffffffffffc;
    return caml_raise ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423c40 */
#include <stdint.h>
 
void caml_invalid_argument (int64_t arg1) {
    rdi = arg1;
    rsi = rdi;
    edi = caml_exn_Invalid_argument;
    return caml_raise_with_string ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42aa60 */
#include <stdint.h>
 
int32_t caml_fill_string (int64_t c, size_t n, void * s) {
    rcx = c;
    rdx = n;
    rsi = s;
    rsi >>= 1;
    rcx >>= 1;
    rdx >>= 1;
    memset (rsi + rdi, ecx, rdx);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408db0 */
#include <stdint.h>
 
void memset (void) {
    memset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4109d0 */
#include <stdint.h>
 
int64_t camlPervasives_entry (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__84);
    *((rbx + 0x240)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__83);
    *((rbx + 0x230)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__82);
    *((rbx + 0x228)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__81);
    *((rbx + 0x220)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__80);
    *((rbx + 0x218)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__79);
    *((rbx + 0x210)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__78);
    *((rbx + 0x208)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__77);
    *((rbx + 0x200)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__76);
    *((rbx + 0x1e0)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__75);
    *((rbx + 0x1c0)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__74);
    *((rbx + 0x1a8)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__73);
    *((rbx + 0x1a0)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__72);
    *((rbx + 0x198)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__71);
    *((rbx + 0x188)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__70);
    *((rbx + 0x180)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__69);
    *((rbx + 0x168)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = *(loc.camlPervasives__68);
    *((rbx + 0x158)) = rax;
    rbx = *(loc.camlPervasives__67);
    rax = *(reloc.camlPervasives);
    *((rax + 8)) = rbx;
    rbx = *(loc.camlPervasives__66);
    rax = *(reloc.camlPervasives);
    *(rax) = rbx;
    caml_alloc1 ();
    rbx = r15 + 8;
    *((rbx - 8)) = 0x400;
    rax = *(loc.camlPervasives__65);
    *(rbx) = rax;
    rax = *(reloc.camlPervasives);
    *((rax + 0x10)) = rbx;
    rbx = *(loc.camlPervasives__64);
    rax = *(reloc.camlPervasives);
    *((rax + 0x18)) = rbx;
    rbx = *(loc.camlPervasives__63);
    rax = *(reloc.camlPervasives);
    *((rax + 0x20)) = rbx;
    rbx = *(loc.camlPervasives__62);
    rax = *(reloc.camlPervasives);
    *((rax + 0x28)) = rbx;
    rbx = *(loc.camlPervasives__61);
    rax = *(reloc.camlPervasives);
    *((rax + 0x40)) = rbx;
    rax = 0x8000000000000001;
    rbx = *(reloc.camlPervasives);
    rax = 0x8000000000000001;
    *((rbx + 0x38)) = rax;
    rbx = *(reloc.camlPervasives);
    rax = 0x7fffffffffffffff;
    *((rbx + 0x30)) = rax;
    rdi = *(loc.camlPervasives__60);
    rax = *(reloc.caml_int64_float_of_bits);
    rax = caml_c_call ();
    rbx = *(reloc.camlPervasives);
    *((rbx + 0x48)) = rax;
    rdi = *(loc.camlPervasives__59);
    rax = *(reloc.caml_int64_float_of_bits);
    rax = caml_c_call ();
    rbx = *(reloc.camlPervasives);
    *((rbx + 0x50)) = rax;
    rdi = *(loc.camlPervasives__58);
    rax = *(reloc.caml_int64_float_of_bits);
    rax = caml_c_call ();
    rbx = *(reloc.camlPervasives);
    *((rbx + 0x58)) = rax;
    rdi = *(loc.camlPervasives__57);
    rax = *(reloc.caml_int64_float_of_bits);
    rax = caml_c_call ();
    rbx = *(reloc.camlPervasives);
    *((rbx + 0x60)) = rax;
    rdi = *(loc.camlPervasives__56);
    rax = *(reloc.caml_int64_float_of_bits);
    rax = caml_c_call ();
    rbx = *(reloc.camlPervasives);
    *((rbx + 0x68)) = rax;
    rdi = *(loc.camlPervasives__55);
    rax = *(reloc.caml_int64_float_of_bits);
    rax = caml_c_call ();
    rbx = *(reloc.camlPervasives);
    *((rbx + 0x70)) = rax;
    rbx = *(loc.camlPervasives__54);
    rax = *(reloc.camlPervasives);
    *((rax + 0x78)) = rbx;
    rbx = *(loc.camlPervasives__53);
    rax = *(reloc.camlPervasives);
    *((rax + 0x80)) = rbx;
    rbx = *(loc.camlPervasives__52);
    rax = *(reloc.camlPervasives);
    *((rax + 0x88)) = rbx;
    rbx = *(loc.camlPervasives__51);
    rax = *(reloc.camlPervasives);
    *((rax + 0x90)) = rbx;
    rbx = *(loc.camlPervasives__50);
    rax = *(reloc.camlPervasives);
    *((rax + 0x98)) = rbx;
    rbx = *(loc.camlPervasives__49);
    rax = *(reloc.camlPervasives);
    *((rax + 0x288)) = rbx;
    rbx = *(loc.camlPervasives__48);
    rax = *(reloc.camlPervasives);
    *((rax + 0x270)) = rbx;
    rbx = *(loc.camlPervasives__47);
    rax = *(reloc.camlPervasives);
    *((rax + 0xa0)) = rbx;
    rbx = *(loc.camlPervasives__46);
    rax = *(reloc.camlPervasives);
    *((rax + 0xa8)) = rbx;
    rdi = 1;
    rax = *(reloc.caml_ml_open_descriptor_in);
    rax = caml_c_call ();
    rbx = *(reloc.camlPervasives);
    *((rbx + 0xb0)) = rax;
    rdi = 3;
    rax = *(reloc.caml_ml_open_descriptor_out);
    rax = caml_c_call ();
    rbx = *(reloc.camlPervasives);
    *((rbx + 0xb8)) = rax;
    rdi = 5;
    rax = *(reloc.caml_ml_open_descriptor_out);
    rax = caml_c_call ();
    rbx = *(reloc.camlPervasives);
    *((rbx + 0xc0)) = rax;
    rbx = *(loc.camlPervasives__45);
    rax = *(reloc.camlPervasives);
    *((rax + 0x150)) = rbx;
    rbx = *(loc.camlPervasives__44);
    rax = *(reloc.camlPervasives);
    *((rax + 0x140)) = rbx;
    rbx = *(loc.camlPervasives__43);
    rax = *(reloc.camlPervasives);
    *((rax + 0x148)) = rbx;
    rbx = *(loc.camlPervasives__42);
    rax = *(reloc.camlPervasives);
    *((rax + 0x160)) = rbx;
    rbx = *(loc.camlPervasives__41);
    rax = *(reloc.camlPervasives);
    *((rax + 0x170)) = rbx;
    rbx = *(loc.camlPervasives__40);
    rax = *(reloc.camlPervasives);
    *((rax + 0x178)) = rbx;
    rbx = *(loc.camlPervasives__39);
    rax = *(reloc.camlPervasives);
    *((rax + 0x190)) = rbx;
    rbx = *(loc.camlPervasives__38);
    rax = *(reloc.camlPervasives);
    *((rax + 0x1b0)) = rbx;
    rbx = *(loc.camlPervasives__37);
    rax = *(reloc.camlPervasives);
    *((rax + 0x1b8)) = rbx;
    rbx = *(loc.camlPervasives__36);
    rax = *(reloc.camlPervasives);
    *((rax + 0x1d8)) = rbx;
    rbx = *(loc.camlPervasives__35);
    rax = *(reloc.camlPervasives);
    *((rax + 0x1c8)) = rbx;
    rbx = *(loc.camlPervasives__34);
    rax = *(reloc.camlPervasives);
    *((rax + 0x1d0)) = rbx;
    rbx = *(loc.camlPervasives__33);
    rax = *(reloc.camlPervasives);
    *((rax + 0x1f0)) = rbx;
    rbx = *(loc.camlPervasives__32);
    rax = *(reloc.camlPervasives);
    *((rax + 0x278)) = rbx;
    rbx = *(loc.camlPervasives__31);
    rax = *(reloc.camlPervasives);
    *((rax + 0x1f8)) = rbx;
    rbx = *(loc.camlPervasives__30);
    rax = *(reloc.camlPervasives);
    *((rax + 0x1e8)) = rbx;
    rbx = *(loc.camlPervasives__29);
    rax = *(reloc.camlPervasives);
    *((rax + 0x238)) = rbx;
    rbx = *(loc.camlPervasives__28);
    rax = *(reloc.camlPervasives);
    *((rax + 0xc8)) = rbx;
    rbx = *(loc.camlPervasives__27);
    rax = *(reloc.camlPervasives);
    *((rax + 0xd0)) = rbx;
    rbx = *(loc.camlPervasives__26);
    rax = *(reloc.camlPervasives);
    *((rax + 0xd8)) = rbx;
    rbx = *(loc.camlPervasives__25);
    rax = *(reloc.camlPervasives);
    *((rax + 0xe0)) = rbx;
    rbx = *(loc.camlPervasives__24);
    rax = *(reloc.camlPervasives);
    *((rax + 0xe8)) = rbx;
    rbx = *(loc.camlPervasives__23);
    rax = *(reloc.camlPervasives);
    *((rax + 0xf0)) = rbx;
    rbx = *(loc.camlPervasives__22);
    rax = *(reloc.camlPervasives);
    *((rax + 0xf8)) = rbx;
    rbx = *(loc.camlPervasives__21);
    rax = *(reloc.camlPervasives);
    *((rax + 0x100)) = rbx;
    rbx = *(loc.camlPervasives__20);
    rax = *(reloc.camlPervasives);
    *((rax + 0x108)) = rbx;
    rbx = *(loc.camlPervasives__19);
    rax = *(reloc.camlPervasives);
    *((rax + 0x110)) = rbx;
    rbx = *(loc.camlPervasives__18);
    rax = *(reloc.camlPervasives);
    *((rax + 0x118)) = rbx;
    rbx = *(loc.camlPervasives__17);
    rax = *(reloc.camlPervasives);
    *((rax + 0x120)) = rbx;
    rbx = *(loc.camlPervasives__16);
    rax = *(reloc.camlPervasives);
    *((rax + 0x128)) = rbx;
    rbx = *(loc.camlPervasives__15);
    rax = *(reloc.camlPervasives);
    *((rax + 0x130)) = rbx;
    rbx = *(loc.camlPervasives__14);
    rax = *(reloc.camlPervasives);
    *((rax + 0x138)) = rbx;
    rax = *(loc.camlPervasives__13);
    rax = 0x48;
    caml_allocN ();
    rdi = r15 + 8;
    *((rdi - 8)) = 0x1800;
    rax = *(loc.camlPervasives__7);
    *(rdi) = rax;
    rax = *(loc.camlPervasives__8);
    *((rdi + 8)) = rax;
    rax = *(loc.camlPervasives__9);
    *((rdi + 0x10)) = rax;
    rax = *(loc.camlPervasives__10);
    *((rdi + 0x18)) = rax;
    rax = *(loc.camlPervasives__11);
    *((rdi + 0x20)) = rax;
    rax = *(loc.camlPervasives__12);
    *((rdi + 0x28)) = rax;
    rax = *(reloc.camlPervasives);
    *((rax + 0x248)) = rdi;
    rbx = *(loc.camlPervasives__6);
    rax = *(reloc.camlPervasives);
    *((rax + 0x258)) = rbx;
    rbx = *(loc.camlPervasives__5);
    rax = *(reloc.camlPervasives);
    *((rax + 0x250)) = rbx;
    rbx = rdi + 0x38;
    *((rbx - 8)) = 0x400;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0x160));
    *(rbx) = rax;
    rax = *(reloc.camlPervasives);
    *((rax + 0x290)) = rbx;
    rbx = *(loc.camlPervasives__4);
    rax = *(reloc.camlPervasives);
    *((rax + 0x268)) = rbx;
    rbx = *(loc.camlPervasives__3);
    rax = *(reloc.camlPervasives);
    *((rax + 0x280)) = rbx;
    rbx = *(loc.camlPervasives__2);
    rax = *(reloc.camlPervasives);
    *((rax + 0x260)) = rbx;
    rax = *(reloc.camlPervasives);
    rsi = *((rax + 0x280));
    rdi = *(loc.camlPervasives__1);
    rax = *(reloc.caml_register_named_value);
    caml_c_call ();
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434e20 */
#include <stdint.h>
 
void caml_allocN (int64_t arg_8h, int64_t arg_10h, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        r15 -= rax;
        if (r15 >= *(obj.caml_young_limit)) {
            return;
        }
        rax = *((rsp + 8));
        *(obj.caml_last_return_address) = rax;
        rax = rsp + 0x10;
        *(obj.caml_bottom_of_stack) = rax;
        fcn_00434c4b (rdi, rsi, rdx, rcx, r8, r9);
        caml_allocN ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a2a0 */
#include <stdint.h>
 
int64_t camlBuffer_clear_90 (void) {
    *((rax + 8)) = 1;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a620 */
#include <stdint.h>
 
int64_t camlSource_ack_58 (void) {
label_0:
    do {
label_1:
        if (rax == 1) {
            rbx += 2;
            rax = rbx;
            return rax;
        }
        if (rbx != 1) {
            goto label_2;
        }
        rbx = 3;
        rax += 0xfffffffffffffffe;
    } while (1);
label_2:
    *(rsp) = rax;
    rbx += 0xfffffffffffffffe;
    rax = camlSource_ack_58 ();
    goto label_0;
    rbx = rax;
    rax = *(rsp);
    rax += 0xfffffffffffffffe;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a240 */
#include <stdint.h>
 
void caml_tan_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    tan (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a6a0 */
#include <stdint.h>
 
void caml_add_float (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    xmm0 = *(rdi);
    __asm ("addsd xmm0, qword [rsi]");
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d5a0 */
#include <stdint.h>
 
int64_t camlUnix_close_process_in_1029 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    *(rsp) = rdi;
    do {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x401;
            *(rbx) = rdi;
            rax = *(loc.camlUnix__177);
            rax = camlUnix_find_proc_id_1023 ();
            *((rsp + 8)) = rax;
            rdi = *(rsp);
            rax = *(reloc.caml_ml_close_channel);
            caml_c_call ();
            rax = *((rsp + 8));
            rax = camlUnix_waitpid_non_intr_1027 ();
            rax += 8;
            rax = *(rax);
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d460 */
#include <stdint.h>
 
uint64_t camlUnix_find_proc_id_1023 (int64_t arg_20h) {
    int64_t var_8h;
    int64_t var_10h;
    *((rsp + 8)) = rax;
    *((rsp + 0x10)) = rbx;
    rax = void (*0x40d4d8)() ();
    rdi = *(reloc.caml_exn_Not_found);
    rbx = *(rax);
    while (1) {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x1000;
            rbx = *(reloc.camlUnix);
            rbx = *(rbx);
            *(rax) = rbx;
            *((rax + 8)) = 7;
            rbx = *((rsp + 8));
            *((rax + 0x10)) = rbx;
            rbx = *(loc.camlUnix__178);
            *((rax + 0x18)) = rbx;
            caml_raise_exn ();
            rax = caml_raise_exn ();
            r14 = rsp;
            rax = *(reloc.camlUnix);
            rax = *((rax + 0x508));
            rax = camlHashtbl_find_121 ();
            *((rsp + 0x10)) = rax;
            rax = *(reloc.camlUnix);
            rax = *((rax + 0x508));
            rbx = *((rsp + 0x20));
            camlHashtbl_remove_108 ();
            rax = *(rsp);
            return rax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x419260 */
#include <stdint.h>
 
int64_t camlHashtbl_find_121 (void) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    r12 = rax;
    rax = *((r12 + 8));
    rbp = *((rax - 8));
    rbp >>= 0xa;
    if (rbp != 0) {
        rsi = 0xc9;
        rdi = 0x15;
        rdx = rbx;
        rax = caml_hash_univ_param ();
        rax >>= 1;
        rcx = rbp;
        __asm ("cqo");
        rax = rdx:rax / rcx;
        rdx = rdx:rax % rcx;
    } else {
        rax = *(reloc.caml_bucket_Division_by_zero);
        caml_raise_exn ();
    }
    rdx <<= 1;
    rdx++;
    rdi = *((r12 + 8));
    rax = *((rdi - 8));
    rax >>= 9;
    if (rax <= rdx) {
        goto label_2;
    }
    rdi = *((rdi + rdx*4 - 4));
    if (rdi == 1) {
        goto label_3;
    }
    *((rsp + 8)) = rbx;
    rax = *((rdi + 0x10));
    *(rsp) = rax;
    rax = *((rdi + 8));
    *((rsp + 0x10)) = rax;
    rsi = *(rdi);
    rdi = rbx;
    rax = *(reloc.caml_compare);
    rax = caml_c_call ();
    if (rax == 1) {
        rax = *((rsp + 0x10));
        return rax;
    }
    rax = *(rsp);
    if (rax != 1) {
        rbx = *((rax + 0x10));
        *(rsp) = rbx;
        rbx = *((rax + 8));
        *((rsp + 0x10)) = rbx;
        rsi = *(rax);
        rdi = *((rsp + 8));
        rax = *(reloc.caml_compare);
        rax = caml_c_call ();
        if (rax == 1) {
            rax = *((rsp + 0x10));
            return rax;
        }
        rax = *(rsp);
        if (rax != 1) {
            rbx = *((rax + 0x10));
            *(rsp) = rbx;
            rbx = *((rax + 8));
            *((rsp + 0x10)) = rbx;
            rbx = *(rax);
            rax = *((rsp + 8));
            rdi = *((rsp + 8));
            rsi = rbx;
            rax = *(reloc.caml_compare);
            rax = caml_c_call ();
            if (rax == 1) {
                rax = *((rsp + 0x10));
                return rax;
            }
            rax = *((rsp + 8));
            rbx = *(rsp);
            void (*0x4191d0)() ();
        }
label_1:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_4;
        }
        rbx = r15 + 8;
        *((rbx - 8)) = 0x400;
        rax = *(reloc.caml_exn_Not_found);
        *(rbx) = rax;
        rax = rbx;
        caml_raise_exn ();
    }
label_0:
    r15 -= 0x10;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_5;
    }
    rbx = r15 + 8;
    *((rbx - 8)) = 0x400;
    rax = *(reloc.caml_exn_Not_found);
    *(rbx) = rax;
    rax = rbx;
    caml_raise_exn ();
    do {
label_3:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_2:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4190d0 */
#include <stdint.h>
 
int64_t camlHashtbl_remove_108 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r12 = rax;
    rdx = rbx;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x10f7;
            rax = *(reloc.camlHashtbl__remove_bucket_111);
            *(rbx) = rax;
            *((rbx + 8)) = 3;
            *((rbx + 0x10)) = r12;
            *((rbx + 0x18)) = rdx;
            rax = *((r12 + 8));
            rbp = *((rax - 8));
            rbp >>= 0xa;
            if (rbp != 0) {
                rsi = 0xc9;
                rdi = 0x15;
                rax = caml_hash_univ_param ();
                rax >>= 1;
                rcx = rbp;
                __asm ("cqo");
                rax = rdx:rax / rcx;
                rdx = rdx:rax % rcx;
            } else {
                rax = *(reloc.caml_bucket_Division_by_zero);
                caml_raise_exn ();
            }
            rdx <<= 1;
            rdx++;
            *((rsp + 8)) = rdx;
            rax = *((r12 + 8));
            *(rsp) = rax;
            rax = *((rax - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_0;
            }
            rdi = *((r12 + 8));
            rax = *((rdi - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_1;
            }
            rax = *((rdi + rdx*4 - 4));
            rax = camlHashtbl_remove_bucket_111 ();
            rdi = *(rsp);
            rbx = *((rsp + 8));
            rdi = rdi + rbx*4 - 4;
            rsi = rax;
            caml_modify ();
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_ml_array_bound_error ();
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d530 */
#include <stdint.h>
 
uint64_t camlUnix_waitpid_non_intr_1027 (void) {
    do {
        *(rsp) = rax;
        rax = void (*0x40d56c)() ();
        rbx = *(reloc.camlUnix);
        rdi = *(rbx);
        rbx = *(rax);
        if (rbx != rdi) {
            goto label_0;
        }
        rbx = *((rax + 8));
        if ((bl & 1) == 0) {
            goto label_0;
        }
        if (rbx != 0x17) {
            goto label_0;
        }
        rax = *(rsp);
    } while (1);
label_0:
    rax = caml_raise_exn ();
    r14 = rsp;
    rdi = 1;
    rsi = rax;
    rax = *(reloc.unix_waitpid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432d60 */
#include <stdint.h>
 
uint64_t caml_weak_get_copy (int64_t arg2, int64_t arg1) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_18h_2;
    int64_t var_20h_2;
    int64_t var_28h_2;
    int64_t var_30h_2;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_60h_2;
    int64_t var_68h_2;
    int64_t var_70h_2;
    int64_t var_78h;
    int64_t var_80h;
    int64_t var_a0h;
    int64_t var_a8h;
    int64_t var_b8h;
    int64_t var_c0h;
    int64_t var_c8h;
    int64_t var_d0h;
    int64_t var_d8h;
    int64_t var_e0h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x30)) = rbx;
    *((rsp - 0x28)) = rbp;
    *((rsp - 0x20)) = r12;
    *((rsp - 0x18)) = r13;
    rbp >>= 1;
    *((rsp - 0x10)) = r14;
    *((rsp - 8)) = r15;
    rax = rsp + 0x18;
    rbx = caml_local_roots;
    rbp++;
    *((rsp + 0x18)) = rdi;
    *((rsp + 0x10)) = rsi;
    *((rsp + 0x78)) = rax;
    rax = rsp + 0x10;
    *((rsp + 0x70)) = 1;
    *((rsp + 0x60)) = rbx;
    *((rsp + 0x68)) = 2;
    *((rsp + 0x80)) = rax;
    rax = rsp + 0x60;
    *((rsp + 0xa8)) = 0;
    *((rsp + 0xa0)) = 0;
    *((rsp + 0x30)) = 1;
    *((rsp + 0x20)) = rax;
    rax = rsp + 0x20;
    *((rsp + 0x28)) = 2;
    *(obj.caml_local_roots) = rax;
    rax = rsp + 0xa8;
    *((rsp + 0x38)) = rax;
    rax = rsp + 0xa0;
    *((rsp + 0x40)) = rax;
    if (rbp == 0) {
        goto label_5;
    }
    rax = *((rdi - 8));
    rax >>= 0xa;
    if (rbp >= rax) {
        goto label_5;
    }
    r12 = *((rdi + rbp*8));
    if (r12 == *(obj.caml_weak_none)) {
        goto label_6;
    }
    while ((al & 3) == 0) {
        *((rsp + 0xa0)) = r12;
label_0:
        esi = 0;
        edi = 1;
        rax = caml_alloc_small ();
        rdx = *((rsp + 0xa0));
        *((rsp + 0xa8)) = rax;
        *(obj.caml_local_roots) = rbx;
        *(rax) = rdx;
        rax = *((rsp + 0xa8));
label_2:
        rbx = *((rsp + 0xb8));
        rbp = *((rsp + 0xc0));
        r12 = *((rsp + 0xc8));
        r13 = *((rsp + 0xd0));
        r14 = *((rsp + 0xd8));
        r15 = *((rsp + 0xe0));
        return rax;
        rdi = r12;
        al = caml_page_table_lookup ();
    }
    rdi = *((r12 - 8));
    esi = *((r12 - 8));
    rdi >>= 0xa;
    rax = caml_alloc ();
    rdx = *((rsp + 0x18));
    *((rsp + 0xa0)) = rax;
    rbp = *((rdx + rbp*8));
    if (rbp == *(obj.caml_weak_none)) {
        goto label_6;
    }
    rdx = rbp - 8;
    *((rsp + 8)) = rdx;
    if (*((rbp - 8)) > 0xfa) {
        goto label_7;
    }
    rax = *((rbp - 8));
    rax >>= 0xa;
    if (rax == 0) {
        goto label_0;
    }
    r12d = 0;
    goto label_8;
label_1:
    rax = r14;
    rax += *((rsp + 0xa0));
    rdi = r14;
    r15 = *(rax);
    *(rax) = r13;
    rdi += *((rsp + 0xa0));
    al = caml_page_table_lookup ();
    if ((al & 1) != 0) {
        ecx = caml_gc_phase;
        if (ecx == 0) {
            goto label_9;
        }
label_3:
        if ((r13b & 1) != 0) {
            goto label_10;
        }
        rax = caml_young_end;
        if (r13 >= rax) {
            goto label_10;
        }
        rdx = caml_young_start;
        if (r13 <= rdx) {
            goto label_10;
        }
        if ((r15b & 1) == 0) {
            if (rax <= r15) {
                goto label_11;
            }
            if (rdx < r15) {
                goto label_10;
            }
        }
label_11:
        rax = .comment;
        if (rax >= *(0x00652440)) {
            goto label_12;
        }
label_4:
        r14 += *((rsp + 0xa0));
        *(rax) = r14;
        rax += 8;
        *(0x00652438) = rax;
    }
label_10:
    rdx = *((rsp + 8));
    r12++;
    rax = *(rdx);
    rax >>= 0xa;
    if (rax <= r12) {
        goto label_0;
    }
label_8:
    esi = caml_gc_phase;
    r14 = r12*8;
    r13 = *((rbp + r12*8));
    if (esi != 0) {
        goto label_1;
    }
    if ((r13b & 1) != 0) {
        goto label_1;
    }
    rdi = r13;
    al = caml_page_table_lookup ();
    if ((al & 1) == 0) {
        goto label_1;
    }
    esi = 0;
    rdi = r13;
    caml_darken ();
    goto label_1;
label_6:
    *(obj.caml_local_roots) = rbx;
    eax = 1;
    goto label_2;
label_7:
    rdx >>= 0xa;
    rdx <<= 3;
    memmove (rax, rbp, *((rbp - 8)));
    goto label_0;
label_9:
    esi = 0;
    rdi = r15;
    caml_darken ();
    goto label_3;
label_12:
    edi = caml_ref_table;
    caml_realloc_ref_table ();
    rax = .comment;
    goto label_4;
label_5:
    edi = "Weak.get";
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424f90 */
#include <stdint.h>
 
uint32_t caml_set_signal_action (uint32_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_a0h;
    int64_t var_128h;
    rsi = arg2;
    rdi = arg1;
    ebx = edi;
    if (esi != 0) {
        goto label_1;
    }
    *((rsp + 0xa0)) = 0;
    *((rsp + 0x128)) = 0;
    do {
label_0:
        rbp = rsp + 0xa0;
        rdi = rbp + 8;
        sigemptyset ();
        eax = sigaction (ebx, rbp, rsp);
        if (eax != 0xffffffff) {
            rdx = *(rsp);
            eax = 2;
            if (rdx == sym.handle_signal) {
                goto label_2;
            }
            eax = 0;
            al = (rdx == 1) ? 1 : 0;
        }
label_2:
        return eax;
label_1:
        if (esi == 1) {
            goto label_3;
        }
        *((rsp + 0xa0)) = sym.handle_signal;
        *((rsp + 0x128)) = 4;
    } while (1);
label_3:
    *((rsp + 0xa0)) = 1;
    *((rsp + 0x128)) = 0;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432190 */
#include <stdint.h>
 
int64_t caml_md5_string (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_4h;
    int64_t var_8h;
    int64_t var_ch;
    int64_t var_10h;
    int64_t var_14h;
    int64_t var_58h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    rdx >>= 1;
    rsi += rdi;
    rdi = rsp;
    *(rsp) = 0x67452301;
    *((rsp + 4)) = 0xefcdab89;
    rax = *(fs:0x28);
    *((rsp + 0x58)) = rax;
    eax = 0;
    *((rsp + 8)) = 0x98badcfe;
    *((rsp + 0xc)) = 0x10325476;
    *((rsp + 0x10)) = 0;
    *((rsp + 0x14)) = 0;
    caml_MD5Update ();
    edi = 0x10;
    rax = caml_alloc_string ();
    rsi = rsp;
    rdi = rax;
    caml_MD5Final ();
    rdx = *((rsp + 0x58));
    rdx ^= *(fs:0x28);
    rax = rbp;
    if (rsi == 0) {
        return rax;
    }
    return stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x431e40 */
#include <stdint.h>
 
int64_t caml_MD5Final (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    *((rsp - 8)) = r12;
    eax = *((rsi + 0x10));
    rbx = rsi;
    eax >>= 3;
    eax &= 0x3f;
    edx = eax;
    *((rsi + rdx + 0x18)) = 0x80;
    rdi = rsi + rdx + 0x19;
    edx = 0x3f;
    edx -= eax;
    if (edx > 7) {
        r12 = rbx + 0x18;
        edx -= 8;
        memset (rdi, 0, rdx);
label_0:
        eax = *((rbx + 0x10));
        rsi = r12;
        rdi = rbx;
        *((r12 + 0x38)) = eax;
        eax = *((rbx + 0x14));
        *((r12 + 0x3c)) = eax;
        caml_MD5Transform ();
        rax = *(rbx);
        *(rbp) = rax;
        rax = *((rbx + 8));
        *((rbp + 8)) = rax;
        *(rbx) = 0;
        rbp = *((rsp + 8));
        rbx = *(rsp);
        r12 = *((rsp + 0x10));
        return rax;
    }
    r12 = rbx + 0x18;
    memset (rdi, 0, edx);
    rdi = rbx;
    rsi = r12;
    eax = caml_MD5Transform ();
    rdi = r12;
    edx = 0x38;
    if ((r12b & 1) != 0) {
        goto label_7;
    }
label_5:
    if ((dil & 2) != 0) {
        goto label_8;
    }
label_6:
    if ((dil & 4) != 0) {
        goto label_9;
    }
label_4:
    ecx = edx;
    eax = 0;
    ecx >>= 3;
    do {
        *(rdi) = rax;
        rcx--;
        rdi += 8;
    } while (rcx != 0);
    if ((dl & 4) != 0) {
        goto label_10;
    }
    if ((dl & 2) != 0) {
        goto label_3;
    }
label_2:
    edx &= 1;
    if (edx == 0) {
        goto label_0;
    }
label_1:
    *(rdi) = 0;
    goto label_0;
label_3:
    *(rdi) = 0;
    rdi += 2;
    edx &= 1;
    if (edx == 0) {
        goto label_0;
    }
    goto label_1;
label_10:
    *(rdi) = 0;
    rdi += 4;
    if ((dl & 2) == 0) {
        goto label_2;
    }
    goto label_3;
label_9:
    *(rdi) = 0;
    edx -= 4;
    rdi += 4;
    goto label_4;
label_7:
    *((rbx + 0x18)) = 0;
    rdi = rbx + 0x19;
    dl = 0x37;
    goto label_5;
label_8:
    *(rdi) = 0;
    edx -= 2;
    rdi += 2;
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c280 */
#include <stdint.h>
 
int64_t caml_ml_output_partial (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_50h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rbp = caml_local_roots;
    rax = caml_channel_mutex_lock;
    *((rsp + 8)) = rdx;
    rdx = rsp + 0x20;
    *((rsp + 0x18)) = rdi;
    *((rsp + 0x10)) = rsi;
    *(rsp) = rcx;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 0x18;
    *((rsp + 0x20)) = rbp;
    *((rsp + 0x30)) = 1;
    *((rsp + 0x38)) = rdx;
    rdx = rsp + 0x10;
    *((rsp + 0x28)) = 4;
    *((rsp + 0x50)) = rsp;
    rbx = *((rdi + 8));
    *((rsp + 0x40)) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x48)) = rdx;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rsi = *((rsp + 8));
    rdx = *(rsp);
    rdi = rbx;
    rsi >>= 1;
    rsi += *((rsp + 0x10));
    rdx >>= 1;
    eax = caml_putblock ();
    rdx = caml_channel_mutex_unlock;
    r12d = eax;
    if (rdx != 0) {
        rdi = rbx;
        void (*rdx)() ();
    }
    *(obj.caml_local_roots) = rbp;
    r12 = (int64_t) r12d;
    rax = r12 + r12 + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4169a0 */
#include <stdint.h>
 
int64_t camlString_make_66 (void) {
    int64_t var_8h;
    *(rsp) = rax;
    *((rsp + 8)) = rbx;
    rdi = rax;
    rax = *(reloc.caml_create_string);
    rax = caml_c_call ();
    rbx = rax;
    rsi = 1;
    rdi = rbx;
    rdx = *(rsp);
    rcx = *((rsp + 8));
    caml_fill_string ();
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424b20 */
#include <stdint.h>
 
int32_t caml_rev_convert_signal_number (uint32_t arg1) {
    rdi = arg1;
    eax = edi;
    edx = 0x436124;
    ecx = 1;
    if (edi == 6) {
        goto label_0;
    }
    do {
        if (*(rdx) == eax) {
            goto label_1;
        }
        ecx++;
        rdx += 4;
    } while (ecx != 0x15);
    return eax;
label_1:
    eax = ecx;
    eax = ~eax;
    return eax;
label_0:
    eax = 0xffffffff;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a5f0 */
#include <stdint.h>
 
int64_t camlStd_exit_entry (void) {
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0x290));
    rbx = *(rax);
    rax = 1;
    rdi = *(rbx);
    void (*rdi)() ();
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42fbc0 */
#include <stdint.h>
 
uint32_t caml_sys_chdir (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    eax = chdir ();
    if (eax != 0) {
        rdi = rbx;
        caml_sys_error ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a4a0 */
#include <stdint.h>
 
int64_t caml_ldexp_float (arithmetic value, int64_t arg1) {
    rsi = value;
    rdi = arg1;
    rax = rdi;
    rsi >>= 1;
    xmm0 = *(rax);
    ldexp (esi, rsi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e220 */
#include <stdint.h>
 
int64_t camlPrintf_get_index_293 (void) {
    if (rax != 1) {
        rax = *(rax);
        return rax;
    }
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fa70 */
#include <stdint.h>
 
int64_t camlPervasives_fun_426 (void) {
    rdi = rax;
    rax = *(reloc.caml_input_value);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ae10 */
#include <stdint.h>
 
int64_t camlUnix_fun_1637 (void) {
    rdi = rax;
    rax = *(reloc.unix_getpwuid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40dad0 */
#include <stdint.h>
 
int64_t camlUnix_entry (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__173);
    *((rbx + 0x4c0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__172);
    *((rbx + 0x4b8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__171);
    *((rbx + 0x4b0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__170);
    *((rbx + 0x4a8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__169);
    *((rbx + 0x4a0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__168);
    *((rbx + 0x498)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__167);
    *((rbx + 0x490)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__166);
    *((rbx + 0x478)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__165);
    *((rbx + 0x470)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__164);
    *((rbx + 0x468)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__163);
    *((rbx + 0x460)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__162);
    *((rbx + 0x458)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__161);
    *((rbx + 0x450)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__160);
    *((rbx + 0x448)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__159);
    *((rbx + 0x3c0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__158);
    *((rbx + 0x3b8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__157);
    *((rbx + 0x3b0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__156);
    *((rbx + 0x3a8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__155);
    *((rbx + 0x3a0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__154);
    *((rbx + 0x398)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__153);
    *((rbx + 0x390)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__152);
    *((rbx + 0x388)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__151);
    *((rbx + 0x378)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__150);
    *((rbx + 0x350)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__149);
    *((rbx + 0x348)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__148);
    *((rbx + 0x340)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__147);
    *((rbx + 0x338)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__146);
    *((rbx + 0x330)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__145);
    *((rbx + 0x328)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__144);
    *((rbx + 0x320)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__143);
    *((rbx + 0x318)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__142);
    *((rbx + 0x310)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__141);
    *((rbx + 0x308)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__140);
    *((rbx + 0x300)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__139);
    *((rbx + 0x2f8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__138);
    *((rbx + 0x2f0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__137);
    *((rbx + 0x2e8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__136);
    *((rbx + 0x2e0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__135);
    *((rbx + 0x2d8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__134);
    *((rbx + 0x2d0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__133);
    *((rbx + 0x2c8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__132);
    *((rbx + 0x2c0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__131);
    *((rbx + 0x2b8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__130);
    *((rbx + 0x2b0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__129);
    *((rbx + 0x2a8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__128);
    *((rbx + 0x2a0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__127);
    *((rbx + 0x298)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__126);
    *((rbx + 0x290)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__125);
    *((rbx + 0x280)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__124);
    *((rbx + 0x278)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__123);
    *((rbx + 0x270)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__122);
    *((rbx + 0x268)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__121);
    *((rbx + 0x260)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__120);
    *((rbx + 0x258)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__119);
    *((rbx + 0x250)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__118);
    *((rbx + 0x248)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__117);
    *((rbx + 0x1f0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__116);
    *((rbx + 0x1e8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__115);
    *((rbx + 0x1e0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__114);
    *((rbx + 0x1d8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__113);
    *((rbx + 0x1d0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__112);
    *((rbx + 0x1c8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__111);
    *((rbx + 0x1c0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__110);
    *((rbx + 0x1b8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__109);
    *((rbx + 0x1b0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__108);
    *((rbx + 0x1a8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__107);
    *((rbx + 0x1a0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__106);
    *((rbx + 0x198)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__105);
    *((rbx + 0x190)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__104);
    *((rbx + 0x188)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__103);
    *((rbx + 0x180)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__102);
    *((rbx + 0x178)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__101);
    *((rbx + 0x170)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__100);
    *((rbx + 0x168)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__99);
    *((rbx + 0x160)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__98);
    *((rbx + 0x158)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__97);
    *((rbx + 0x150)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__96);
    *((rbx + 0x148)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__95);
    *((rbx + 0x140)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__94);
    *((rbx + 0x138)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__93);
    *((rbx + 0x130)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__92);
    *((rbx + 0x128)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__91);
    *((rbx + 0x118)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__90);
    *((rbx + 0x110)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__89);
    *((rbx + 0x108)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__88);
    *((rbx + 0x100)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__87);
    *((rbx + 0xf8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__86);
    *((rbx + 0xf0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__85);
    *((rbx + 0xe8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__84);
    *((rbx + 0xe0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__83);
    *((rbx + 0xd8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__82);
    *((rbx + 0xd0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__81);
    *((rbx + 0xc8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__80);
    *((rbx + 0xa8)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__79);
    *((rbx + 0xa0)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__78);
    *((rbx + 0x80)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__77);
    *((rbx + 0x78)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__76);
    *((rbx + 0x70)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__75);
    *((rbx + 0x60)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__74);
    *((rbx + 0x58)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__73);
    *((rbx + 0x50)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__72);
    *((rbx + 0x48)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__71);
    *((rbx + 0x40)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__70);
    *((rbx + 0x38)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__69);
    *((rbx + 0x30)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__68);
    *((rbx + 0x28)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__67);
    *((rbx + 0x20)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__66);
    *((rbx + 0x18)) = rax;
    rbx = *(reloc.camlUnix);
    rax = *(loc.camlUnix__65);
    *((rbx + 8)) = rax;
    rax = 0x38;
    caml_allocN ();
    rbx = r15 + 8;
    *((rbx - 8)) = 0x400;
    rax = *(loc.camlUnix__64);
    *(rbx) = rax;
    rax = *(reloc.camlUnix);
    *(rax) = rbx;
    rbx += 0x10;
    *((rbx - 8)) = 0x1000;
    rax = *(reloc.camlUnix);
    rax = *(rax);
    *(rbx) = rax;
    *((rbx + 8)) = 1;
    rax = *(loc.camlUnix__62);
    *((rbx + 0x10)) = rax;
    rax = *(loc.camlUnix__63);
    *((rbx + 0x18)) = rax;
    rax = *(loc.camlUnix__61);
    camlCallback_register_exception_62 ();
    rbx = *(loc.camlUnix__60);
    rax = *(reloc.camlUnix);
    *((rax + 0x10)) = rbx;
    rax = *(reloc.camlUnix);
    *((rax + 0x88)) = 1;
    rax = *(reloc.camlUnix);
    *((rax + 0x90)) = 3;
    rax = *(reloc.camlUnix);
    *((rax + 0x98)) = 5;
    rbx = *(loc.camlUnix__59);
    rax = *(reloc.camlUnix);
    *((rax + 0xb0)) = rbx;
    rbx = *(loc.camlUnix__58);
    rax = *(reloc.camlUnix);
    *((rax + 0xb8)) = rbx;
    rbx = *(loc.camlUnix__57);
    rax = *(reloc.camlUnix);
    *((rax + 0xc0)) = rbx;
    rax = *(loc.camlUnix__56);
    rax = 0x38;
    caml_allocN ();
    rbx = r15 + 8;
    *((rbx - 8)) = 0x1800;
    rax = *(loc.camlUnix__50);
    *(rbx) = rax;
    rax = *(loc.camlUnix__51);
    *((rbx + 8)) = rax;
    rax = *(loc.camlUnix__52);
    *((rbx + 0x10)) = rax;
    rax = *(loc.camlUnix__53);
    *((rbx + 0x18)) = rax;
    rax = *(loc.camlUnix__54);
    *((rbx + 0x20)) = rax;
    rax = *(loc.camlUnix__55);
    *((rbx + 0x28)) = rax;
    rax = *(reloc.camlUnix);
    *((rax + 0x120)) = rbx;
    rbx = *(loc.camlUnix__49);
    rax = *(reloc.camlUnix);
    *((rax + 0x4c8)) = rbx;
    rbx = *(loc.camlUnix__48);
    rax = *(reloc.camlUnix);
    *((rax + 0x288)) = rbx;
    rbx = *(loc.camlUnix__47);
    rax = *(reloc.camlUnix);
    *((rax + 0x4d0)) = rbx;
    rdi = *(loc.camlUnix__46);
    rax = *(reloc.unix_inet_addr_of_string);
    rax = caml_c_call ();
    rbx = *(reloc.camlUnix);
    *((rbx + 0x358)) = rax;
    rdi = *(loc.camlUnix__45);
    rax = *(reloc.unix_inet_addr_of_string);
    rax = caml_c_call ();
    rbx = *(reloc.camlUnix);
    *((rbx + 0x360)) = rax;
    rax = void (*0x40e5ac)() ();
    rdi = *(reloc.caml_exn_Failure);
    rbx = *(rax);
    if (rbx == rdi) {
        rax = *(reloc.camlUnix);
        rax = *((rax + 0x358));
    } else {
        caml_raise_exn ();
        r14 = rsp;
        rdi = *(loc.camlUnix__44);
        rax = *(reloc.unix_inet_addr_of_string);
        rax = caml_c_call ();
    }
    rbx = *(reloc.camlUnix);
    *((rbx + 0x368)) = rax;
    rax = void (*0x40e601)() ();
    rdi = *(reloc.caml_exn_Failure);
    rbx = *(rax);
    if (rbx == rdi) {
        rax = *(reloc.camlUnix);
        rax = *((rax + 0x360));
    } else {
        caml_raise_exn ();
        r14 = rsp;
        rdi = *(loc.camlUnix__43);
        rax = *(reloc.unix_inet_addr_of_string);
        rax = caml_c_call ();
    }
    rbx = *(reloc.camlUnix);
    *((rbx + 0x370)) = rax;
    rbx = *(loc.camlUnix__42);
    rax = *(reloc.camlUnix);
    *((rax + 0x380)) = rbx;
    rbx = *(loc.camlUnix__41);
    rax = *(reloc.camlUnix);
    *((rax + 0x3c8)) = rbx;
    rbx = *(loc.camlUnix__40);
    rax = *(reloc.camlUnix);
    *((rax + 0x3d0)) = rbx;
    rbx = *(loc.camlUnix__39);
    rax = *(reloc.camlUnix);
    *((rax + 0x3d8)) = rbx;
    rbx = *(loc.camlUnix__38);
    rax = *(reloc.camlUnix);
    *((rax + 0x3e0)) = rbx;
    rax = 0x40;
    caml_allocN ();
    rbx = r15 + 8;
    *((rbx - 8)) = 0x1c00;
    *(rbx) = 1;
    *((rbx + 8)) = 3;
    *((rbx + 0x10)) = 5;
    *((rbx + 0x18)) = 7;
    *((rbx + 0x20)) = 9;
    rax = *(loc.camlUnix__36);
    *((rbx + 0x28)) = rax;
    rax = *(loc.camlUnix__37);
    *((rbx + 0x30)) = rax;
    rax = *(reloc.camlUnix);
    *((rax + 0x4d8)) = rbx;
    rbx = *(loc.camlUnix__35);
    rax = *(reloc.camlUnix);
    *((rax + 0x3e8)) = rbx;
    rbx = *(loc.camlUnix__34);
    rax = *(reloc.camlUnix);
    *((rax + 0x3f0)) = rbx;
    rbx = *(loc.camlUnix__33);
    rax = *(reloc.camlUnix);
    *((rax + 0x3f8)) = rbx;
    rbx = *(loc.camlUnix__32);
    rax = *(reloc.camlUnix);
    *((rax + 0x400)) = rbx;
    rbx = *(loc.camlUnix__31);
    rax = *(reloc.camlUnix);
    *((rax + 0x408)) = rbx;
    rbx = *(loc.camlUnix__30);
    rax = *(reloc.camlUnix);
    *((rax + 0x410)) = rbx;
    rbx = *(loc.camlUnix__29);
    rax = *(reloc.camlUnix);
    *((rax + 0x418)) = rbx;
    rbx = *(loc.camlUnix__28);
    rax = *(reloc.camlUnix);
    *((rax + 0x420)) = rbx;
    rbx = *(loc.camlUnix__27);
    rax = *(reloc.camlUnix);
    *((rax + 0x428)) = rbx;
    rbx = *(loc.camlUnix__26);
    rax = *(reloc.camlUnix);
    *((rax + 0x4e0)) = rbx;
    rbx = *(loc.camlUnix__25);
    rax = *(reloc.camlUnix);
    *((rax + 0x480)) = rbx;
    rbx = *(loc.camlUnix__24);
    rax = *(reloc.camlUnix);
    *((rax + 0x4e8)) = rbx;
    rbx = *(loc.camlUnix__23);
    rax = *(reloc.camlUnix);
    *((rax + 0x488)) = rbx;
    rbx = *(loc.camlUnix__22);
    rax = *(reloc.camlUnix);
    *((rax + 0x68)) = rbx;
    rbx = *(loc.camlUnix__21);
    rax = *(reloc.camlUnix);
    *((rax + 0x4f0)) = rbx;
    rbx = *(loc.camlUnix__20);
    rax = *(reloc.camlUnix);
    *((rax + 0x4f8)) = rbx;
    rbx = *(loc.camlUnix__19);
    rax = *(reloc.camlUnix);
    *((rax + 0x500)) = rbx;
    rbx = *(loc.camlUnix__18);
    rax = *(reloc.camlUnix);
    *((rax + 0x1f8)) = rbx;
    rbx = *(loc.camlUnix__17);
    rax = *(reloc.camlUnix);
    *((rax + 0x200)) = rbx;
    rax = 0xf;
    rax = camlHashtbl_create_79 ();
    rbx = *(reloc.camlUnix);
    *((rbx + 0x508)) = rax;
    rbx = *(loc.camlUnix__16);
    rax = *(reloc.camlUnix);
    *((rax + 0x510)) = rbx;
    rbx = *(loc.camlUnix__15);
    rax = *(reloc.camlUnix);
    *((rax + 0x208)) = rbx;
    rbx = *(loc.camlUnix__14);
    rax = *(reloc.camlUnix);
    *((rax + 0x210)) = rbx;
    rbx = *(loc.camlUnix__13);
    rax = *(reloc.camlUnix);
    *((rax + 0x218)) = rbx;
    rbx = *(loc.camlUnix__12);
    rax = *(reloc.camlUnix);
    *((rax + 0x518)) = rbx;
    rbx = *(loc.camlUnix__11);
    rax = *(reloc.camlUnix);
    *((rax + 0x220)) = rbx;
    rbx = *(loc.camlUnix__10);
    rax = *(reloc.camlUnix);
    *((rax + 0x520)) = rbx;
    rbx = *(loc.camlUnix__9);
    rax = *(reloc.camlUnix);
    *((rax + 0x528)) = rbx;
    rbx = *(loc.camlUnix__8);
    rax = *(reloc.camlUnix);
    *((rax + 0x228)) = rbx;
    rbx = *(loc.camlUnix__7);
    rax = *(reloc.camlUnix);
    *((rax + 0x230)) = rbx;
    rbx = *(loc.camlUnix__6);
    cl = 0xb;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4137b0 */
#include <stdint.h>
 
int64_t camlArray_fold_left_166 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_sp_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
label_1:
    r15 -= 0x10;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_2;
    }
    rbp = r15 + 8;
    *((rbp - 8)) = 0x400;
    *(rbp) = rbx;
    rsi = 1;
    rax = *((rdi - 8));
    rax >>= 9;
    rax |= 1;
    rax += 0xfffffffffffffffe;
    if (rsi > rax) {
        goto label_3;
    }
    *((rsp + 0x20)) = rax;
    *((rsp + 0x18)) = rsi;
    *((rsp + 0x10)) = rbp;
    *(rsp) = rdi;
    *((rsp + 8)) = rdx;
    do {
        rdi = *(rsp);
        rax = *((rdi - 8));
        if (rax != 0xfe) {
            rbx = *((rdi + rsi*4 - 4));
        } else {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_4;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdi + rsi*4 - 4]");
            __asm ("movlpd qword [rbx], xmm0");
        }
        rax = *(rbp);
        rdi = *((rsp + 8));
        rax = caml_apply2 ();
        rbp = *((rsp + 0x10));
        rdi = *((rsp + 0x10));
        rsi = rax;
        caml_modify ();
        rsi = *((rsp + 0x18));
        rbx = *((rsp + 0x18));
        rsi += 2;
        *((rsp + 0x18)) = rsi;
        rax = *((rsp + 0x20));
    } while (rbx != rax);
label_3:
    rax = *(rbp);
    return rax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415310 */
#include <stdint.h>
 
int64_t camlList_length_62 (void) {
    rbx = rax;
    rax = 1;
    return camlList_length_aux_58 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42deb0 */
#include <stdint.h>
 
int64_t caml_deserialize_sint_1 (void) {
    rdx = intern_src;
    rax = *(rdx);
    rdx++;
    *(obj.intern_src) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41b2b0 */
#include <stdint.h>
 
int64_t camlPrintf_fun_716 (void) {
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fa30 */
#include <stdint.h>
 
int64_t camlPervasives_fun_422 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_pos_in);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4132d0 */
#include <stdint.h>
 
int64_t camlArray_map_132 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    rax = *((rbx - 8));
    rax >>= 9;
    rax |= 1;
    if (rax == 1) {
        rax = *(loc.camlArray__24);
        return rax;
    }
    *(rsp) = rax;
    *((rsp + 8)) = rbx;
    *((rsp + 0x10)) = rsi;
    rax = *((rbx - 8));
    if (rax != 0xfe) {
        rax = *(rbx);
    } else {
label_1:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_2;
        }
        rax = r15 + 8;
        *((rax - 8)) = 0x4fd;
        __asm ("movlpd xmm0, qword [rbx]");
        __asm ("movlpd qword [rax], xmm0");
    }
    rdi = *(rsi);
    rbx = rsi;
    rax = void (*rdi)() ();
    rdi = *(rsp);
    rsi = rax;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = 3;
    rax = *(rsp);
    rax += 0xfffffffffffffffe;
    if (rbx > rax) {
        goto label_3;
    }
    *((rsp + 0x18)) = rax;
    *((rsp + 0x20)) = rbx;
    *(rsp) = rbp;
    do {
        rdi = *((rsp + 8));
        rax = *((rdi - 8));
        if (rax != 0xfe) {
            rax = *((rdi + rbx*4 - 4));
        } else {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_4;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdi + rbx*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
        }
        rbx = *((rsp + 0x10));
        rdi = *(rbx);
        rax = void (*rdi)() ();
        rbp = *(rsp);
        rbx = *((rbp - 8));
        if (rbx != 0xfe) {
            rbx = *((rsp + 0x20));
            rdi = rbp + rbx*4 - 4;
            rsi = rax;
            rax = caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [rax]");
            rbx = *((rsp + 0x20));
            __asm ("movlpd qword [rbp + rbx*4 - 4], xmm0");
        }
        rdi = rbx;
        rbx += 2;
        *((rsp + 0x20)) = rbx;
        rax = *((rsp + 0x18));
    } while (rdi != rax);
label_3:
    rax = rbp;
    return rax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a680 */
#include <stdint.h>
 
void camlBuffer_output_buffer_122 (int64_t arg6, int64_t arg5, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = *((rbx + 8));
    rdi = 1;
    rbx = *(rbx);
    return camlPervasives_output_218 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42dbf0 */
#include <stdint.h>
 
void caml_output_value_to_block (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *(obj.extern_userprovided_output) = rdx;
    *(obj.extern_ptr) = rdx;
    rdx += rcx;
    *(obj.extern_limit) = rdx;
    return extern_value ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415860 */
#include <stdint.h>
 
int64_t camlList_for_all_165 (void) {
    int64_t var_8h;
    do {
        rsi = rax;
        if (rbx == 1) {
            goto label_0;
        }
        rax = *((rbx + 8));
        rax = *(rbx);
        rdi = *(rsi);
        rbx = rsi;
        rax = void (*rdi)(uint64_t, uint64_t) (rsi, rax);
        if (rax == 1) {
            goto label_1;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
    } while (1);
label_1:
    rax = 1;
    return rax;
label_0:
    rax = 3;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b580 */
#include <stdint.h>
 
int64_t camlUnix_fun_1755 (void) {
    rdi = rax;
    rax = *(reloc.unix_stat);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40add0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1633 (void) {
    rdi = rax;
    rax = *(reloc.unix_inet_addr_of_string);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c0d0 */
#include <stdint.h>
 
uint32_t caml_putblock (size_t n, const void * s2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdx = n;
    rsi = s2;
    rdi = arg1;
    *((rsp - 0x28)) = rbx;
    *((rsp - 0x20)) = rbp;
    rbx = rdi;
    *((rsp - 0x18)) = r12;
    *((rsp - 0x10)) = r13;
    *((rsp - 8)) = r14;
    if (rdx <= 0x7ffffffe) {
        rdi = *((rdi + 0x18));
        r12 = *((rbx + 0x10));
        r12d -= edi;
        if (edx >= r12d) {
            goto label_0;
        }
        r12 = (int64_t) edx;
        memmove (rdi, rsi, r12);
        *((rbx + 0x18)) += r12;
        goto label_1;
    }
    r12 = *((rbx + 0x10));
    r12d -= edi;
label_0:
    rdx = (int64_t) r12d;
    r13 = rbx + 0x50;
    memmove (*((rdi + 0x18)), rsi, rdx);
    r14 = *((rbx + 0x10));
    edi = *(rbx);
    rsi = r13;
    r14d -= r13d;
    edx = r14d;
    eax = do_write ();
    rbp = (int64_t) eax;
    while (1) {
        *((rbx + 8)) += rbp;
        rbp = -rbp;
        rbp += *((rbx + 0x10));
        *((rbx + 0x18)) = rbp;
label_1:
        eax = r12d;
        rbx = *(rsp);
        rbp = *((rsp + 8));
        r12 = *((rsp + 0x10));
        r13 = *((rsp + 0x18));
        r14 = *((rsp + 0x20));
        return eax;
        r14d -= eax;
        rdx = (int64_t) r14d;
        memmove (r13, r13 + rbp, rdx);
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429860 */
#include <stdint.h>
 
void caml_int64_to_nativeint (int64_t arg1) {
    rdi = arg1;
    rdi = *((rdi + 8));
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415e20 */
#include <stdint.h>
 
int64_t camlList_partition_240 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
    rdi = rbx;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x10f7;
            rax = *(reloc.caml_curry3);
            *(rsi) = rax;
            *((rsi + 8)) = 7;
            rax = *(reloc.camlList__part_243);
            *((rsi + 0x10)) = rax;
            *((rsi + 0x18)) = rdx;
            rbx = 1;
            rax = 1;
            void (*0x414570)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a670 */
#include <stdint.h>
 
void caml_div_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    __asm ("divsd xmm0, qword [rsi]");
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415dc0 */
#include <stdint.h>
 
int64_t camlList_find_all_233 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x10f7;
            rax = *(reloc.caml_curry2);
            *(rbx) = rax;
            *((rbx + 8)) = 5;
            rax = *(reloc.camlList__find_235);
            *((rbx + 0x10)) = rax;
            *((rbx + 0x18)) = rdi;
            rax = 1;
            rdi = *(rbx);
            void (*rdi)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425a30 */
#include <stdint.h>
 
void caml_set_allocation_policy (uint32_t arg1) {
    rdi = arg1;
    if (rdi != 0) {
        goto label_0;
    }
    *(obj.fl_prev) = 0x64de30;
    do {
        *(obj.caml_allocation_policy) = rdi;
        return;
label_0:
    } while (rdi != 1);
    *(obj.flp_size) = 0;
    *(obj.beyond) = 0;
    *(obj.caml_allocation_policy) = rdi;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429e10 */
#include <stdint.h>
 
int32_t caml_int32_mul (int64_t arg2) {
    rsi = arg2;
    eax = *((rsi + 8));
    eax *= *((rdi + 8));
    edi = eax;
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429ac0 */
#include <stdint.h>
 
void caml_int64_of_nativeint (int64_t arg1) {
    rdi = arg1;
    rdi = *((rdi + 8));
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427670 */
#include <stdint.h>
 
void caml_free_for_heap (int64_t arg1) {
    rdi = arg1;
    rdi = *((rdi - 0x20));
    return free ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b540 */
#include <stdint.h>
 
int64_t camlUnix_fun_1751 (void) {
    rdi = rax;
    rax = *(reloc.unix_fstat);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bb70 */
#include <stdint.h>
 
int64_t camlUnix_fun_1823 (void) {
    rdi = rax;
    rax = *(reloc.unix_fstat_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4251f0 */
#include <stdint.h>
 
uint64_t caml_ext_table_add (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    eax = *(rdi);
    edx = *((rdi + 4));
    rbx = rdi;
    if (eax >= edx) {
        goto label_0;
    }
    rdx = *((rdi + 8));
    do {
        rcx = (int64_t) eax;
        *(rbx)++;
        *((rdx + rcx*8)) = rbp;
        rbx = *((rsp + 8));
        rbp = *((rsp + 0x10));
        return eax;
label_0:
        edx += edx;
        *((rdi + 4)) = edx;
        rdx = (int64_t) edx;
        rdi = *((rdi + 8));
        rsi = rdx*8;
        rax = caml_stat_resize ();
        rdx = rax;
        *((rbx + 8)) = rax;
        eax = *(rbx);
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427640 */
#include <stdint.h>
 
uint64_t caml_stat_resize (size_t size, void * ptr) {
    rsi = size;
    rdi = ptr;
    rax = realloc (rdi, rsi);
    if (rax != 0) {
        return rax;
    }
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4296c0 */
#include <stdint.h>
 
void caml_nativeint_of_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    __asm ("cvttsd2si rdi, xmm0");
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e440 */
#include <stdint.h>
 
int64_t camlPrintf_mkprintf_377 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rax = r8;
    rdi = *(rbx);
    rax = void (*rdi)(uint64_t, uint64_t) (rax, rdi);
    rdi = rax;
    do {
        r15 -= 0x48;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rsp + 0x28)) = rbx;
            *((rbx - 8)) = 0x20f7;
            rax = *(reloc.caml_curry4);
            *(rbx) = rax;
            *((rbx + 8)) = 9;
            rax = *(reloc.camlPrintf__pr_386);
            *((rbx + 0x10)) = rax;
            rax = *(rsp);
            *((rbx + 0x18)) = rax;
            rax = *((rsp + 8));
            *((rbx + 0x20)) = rax;
            rax = *((rsp + 0x10));
            *((rbx + 0x28)) = rax;
            rax = *((rsp + 0x18));
            *((rbx + 0x30)) = rax;
            *((rbx + 0x38)) = rdi;
            rax = 1;
            rax = camlPrintf_index_of_int_65 ();
            rbx = rax;
            rax = *((rsp + 0x20));
            rdi = *((rsp + 0x28));
            caml_apply2 ();
            rbx = *((rsp + 0x30));
            void (*0x41de60)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423a90 */
#include <stdint.h>
 
int64_t caml_raise_with_args (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    ebx = esi;
    rax = caml_local_roots;
    *((rsp + 8)) = rdi;
    edi = rbx + 1;
    *((rsp + 0x28)) = rdx;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x50)) = rax;
    rax = rsp + 8;
    rdi = (int64_t) edi;
    *((rsp + 0x18)) = 1;
    *((rsp + 0x68)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x10)) = rax;
    rax = rsp + 0x10;
    *(obj.caml_local_roots) = rax;
    rax = (int64_t) esi;
    esi = 0;
    *((rsp + 0x20)) = rax;
    caml_alloc_small ();
    rdx = *((rsp + 8));
    *(rax) = rdx;
    if (ebx <= 0) {
        goto label_0;
    }
    ebx--;
    edx = 0;
    rbx = rbx*8 + 8;
    do {
        rcx = *((rbp + rdx));
        *((rdx + rax + 8)) = rcx;
        rdx += 8;
    } while (rdx != rbx);
label_0:
    rdi = rax;
    return caml_raise ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d680 */
#include <stdint.h>
 
int64_t camlUnix_close_process_1035 (int64_t arg_20h, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rbx;
    *((rsp + 0x10)) = rsi;
    rdi = rax;
    *(rsp) = rdi;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            *(rbx) = rdi;
            *((rbx + 8)) = rsi;
            rax = *(loc.camlUnix__175);
            rax = camlUnix_find_proc_id_1023 ();
            *((rsp + 8)) = rax;
            rdi = *(rsp);
            rax = *(reloc.caml_ml_close_channel);
            caml_c_call ();
            rax = void (*0x40d6f0)() ();
            rdi = *(reloc.caml_exn_Sys_error);
            rbx = *(rax);
            if (rbx != rdi) {
                caml_raise_exn ();
                r14 = rsp;
                rax = *((rsp + 0x20));
                camlPervasives_close_out_233 ();
            }
            rax = *((rsp + 8));
            rax = camlUnix_waitpid_non_intr_1027 ();
            rax += 8;
            rax = *(rax);
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410120 */
#include <stdint.h>
 
int64_t camlPervasives_close_out_233 (void) {
    *(rsp) = rax;
    rdi = rax;
    rax = *(reloc.caml_ml_flush);
    caml_c_call ();
    rdi = *(rsp);
    rax = *(reloc.caml_ml_close_channel);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427f30 */
#include <stdint.h>
 
int64_t caml_page_table_initialize (uint32_t arg1) {
    rdi = arg1;
    rdi >>= 0xc;
    ecx = 0;
    rdi += rdi;
    *(obj.caml_page_table) = 1;
    *(0x006524c8) = 0x40;
    edx = 0x40;
    eax = 1;
    if (rdi <= 1) {
        goto label_0;
    }
    do {
        rax += rax;
        edx--;
    } while (rax < rdi);
    rcx = rax - 1;
    *(obj.caml_page_table) = rax;
    *(0x006524c8) = edx;
label_0:
    *(0x006524d0) = rcx;
    *(0x006524d8) = 0;
    rax = calloc (*(obj.caml_page_table), 8);
    *(0x006524e0) = rax;
    eax -= eax;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409540 */
#include <stdint.h>
 
void calloc (void) {
    calloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410080 */
#include <stdint.h>
 
int64_t camlPervasives_output_218 (int64_t arg6, int64_t arg5, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rdi;
    rcx = rsi;
    if (rdx >= 1) {
        if (rcx < 1) {
            goto label_0;
        }
        rdi = *((rbx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rbx + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= rcx;
        rdi += 2;
        if (rdx > rdi) {
            goto label_0;
        }
        rdi = rax;
        rsi = rbx;
        rax = *(reloc.caml_ml_output);
        caml_c_call ();
        return rax;
    }
label_0:
    rax = *(loc.camlPervasives__91);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a150 */
#include <stdint.h>
 
int64_t camlBuffer_sub_74 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, signed int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    signed int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rbx >= 1) {
        if (rdi < 1) {
            goto label_0;
        }
        rsi = *((rax + 8));
        rsi -= rdi;
        rsi++;
        if (rbx > rsi) {
            goto label_0;
        }
        *((rsp + 0x10)) = rdi;
        *((rsp + 8)) = rbx;
        *(rsp) = rax;
        rax = *(reloc.caml_create_string);
        rax = caml_c_call ();
        rdi = rax;
        *((rsp + 0x18)) = rdi;
        rsi = 1;
        rax = *(rsp);
        rax = *(rax);
        rbx = *((rsp + 8));
        rdx = *((rsp + 0x10));
        camlString_blit_84 ();
        rax = *((rsp + 0x18));
        return rax;
    }
label_0:
    rax = *(loc.camlBuffer__26);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410040 */
#include <stdint.h>
 
int64_t camlPervasives_output_string_215 (void) {
    rdx = *((rbx - 8));
    rdx >>= 0xa;
    rdx = rdx*8 - 1;
    rcx = *((rbx + rdx));
    rdx -= rcx;
    rcx = rdx + rdx + 1;
    rdx = 1;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_ml_output);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428bf0 */
#include <stdint.h>
 
uint64_t caml_equal (void) {
    edx = 0;
    rax = compare_val ();
    rbx = rax;
    if (*(obj.compare_stack) != 0x652500) {
        rax = compare_free_stack ();
    }
    rax -= rax;
    eax &= 2;
    rax++;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b5e0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1761 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_lseek);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410850 */
#include <stdint.h>
 
int64_t camlPervasives_5e_5e_336 (void) {
    *(rsp) = rax;
    rax = *(loc.camlPervasives__85);
    rax = camlPervasives_$5e_136 ();
    rbx = rax;
    rax = *(rsp);
    return camlPervasives_5e_136 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c0d0 */
#include <stdint.h>
 
int64_t camlUnix_setsockopt_float_693 (int64_t arg1) {
    rdi = arg1;
    rcx = rdi;
    rdi = 7;
    rsi = rax;
    rdx = rbx;
    rax = *(reloc.unix_setsockopt);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4298a0 */
#include <stdint.h>
 
int64_t caml_int64_of_string (int64_t arg1) {
    rdi = arg1;
    r12 = rdi;
    eax = *(rdi);
    rbx = rdi;
    if (al == 0x2d) {
        goto label_8;
    }
label_4:
    rsi = 0x1999999999999999;
    edi = 0xa;
    r14d = 0xa;
    if (al != 0x30) {
label_7:
        edx = rax - 0x30;
        r13d = (int32_t) al;
        if (dl > 9) {
            edx = rax - 0x41;
            if (dl > 5) {
                goto label_9;
            }
            r13d -= 0x37;
        } else {
            ecx = *((r12 + 1));
            ecx -= 0x42;
            if (cl <= 0x36) {
                goto label_10;
            }
label_6:
            rsi = 0x1999999999999999;
            r14d = 0xa;
            edi = 0xa;
            r13d = 0x30;
        }
        r13d -= 0x30;
    }
label_3:
    if (r13d < 0) {
        goto label_2;
    }
    if (r13d >= r14d) {
        goto label_2;
    }
    r13 = (int64_t) r13d;
    do {
label_0:
        r12++;
        eax = *(r12);
    } while (al == 0x5f);
    edx = rax - 0x30;
    ecx = (int32_t) al;
    if (dl > 9) {
        goto label_11;
    }
    eax = rcx - 0x30;
label_1:
    if (eax < 0) {
        goto label_12;
    }
    if (eax >= r14d) {
        goto label_12;
    }
    if (r13 > rsi) {
        goto label_2;
    }
    r13 *= rdi;
    rax = (int64_t) eax;
    r13 += rax;
    if (r13 >= 0) {
        goto label_0;
    }
    do {
label_2:
        edi = "int_of_string";
        caml_failwith ();
label_11:
        edx = rax - 0x41;
        if (dl <= 5) {
            eax = rcx - 0x37;
            goto label_1;
        }
        eax -= 0x61;
        if (al <= 5) {
            goto label_13;
        }
label_12:
        rdi = rbx;
        caml_string_length ();
        rbx = rax + rbx;
    } while (r12 != rbx);
    if (r14d == 0xa) {
        goto label_14;
    }
label_5:
    rax = r13;
    rax = -rax;
    if (ebp == 0xffffffff) {
        r13 = rax;
    }
    rdi = r13;
    void (*0x429870)() ();
label_13:
    eax = rcx - 0x57;
    goto label_1;
label_9:
    eax -= 0x61;
    if (al > 5) {
        goto label_2;
    }
    r13d -= 0x57;
    goto label_3;
label_8:
    r12 = rdi + 1;
    eax = *((rdi + 1));
    goto label_4;
label_14:
    rax = 0x8000000000000000;
    if (r13 <= rax) {
        goto label_5;
    }
    goto label_2;
label_10:
    eax = 1;
    rdx = 0x40000000400000;
    rax <<= cl;
    if ((rax & rdx) != 0) {
        goto label_15;
    }
    rdx = 0x200000002000;
    if ((rax & rdx) != 0) {
        goto label_16;
    }
    rdx = 0x100000001;
    if ((rax & rdx) == 0) {
        goto label_6;
    }
    r12 += 2;
    rsi = 0x7fffffffffffffff;
    edi = 2;
    eax = *(r12);
    r14d = 2;
    goto label_7;
label_16:
    r12 += 2;
    rsi = 0x1fffffffffffffff;
    edi = 8;
    eax = *(r12);
    r14d = 8;
    goto label_7;
label_15:
    r12 += 2;
    rsi = 0xfffffffffffffff;
    edi = 0x10;
    eax = *(r12);
    r14d = 0x10;
    goto label_7;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410640 */
#include <stdint.h>
 
int64_t camlPervasives_prerr_endline_309 (void) {
    rbx = rax;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0xc0));
    camlPervasives_output_string_215 ();
    rsi = 0x15;
    rax = *(reloc.camlPervasives);
    rdi = *((rax + 0xc0));
    rax = *(reloc.caml_ml_output_char);
    caml_c_call ();
    rax = *(reloc.camlPervasives);
    rdi = *((rax + 0xc0));
    rax = *(reloc.caml_ml_flush);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4103f0 */
#include <stdint.h>
 
int64_t camlPervasives_close_in_noerr_287 (void) {
    fcn_00410408 ();
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410408 */
#include <stdint.h>
 
int64_t fcn_00410408 (void) {
    r14 = rsp;
    rdi = rax;
    rax = *(reloc.caml_ml_close_channel);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4101b0 */
#include <stdint.h>
 
int64_t camlPervasives_open_in_gen_238 (void) {
    rsi = rax;
    rdx = rbx;
    rax = *(reloc.caml_sys_open);
    rax = caml_c_call ();
    rdi = rax;
    rax = *(reloc.caml_ml_open_descriptor_in);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415b20 */
#include <stdint.h>
 
int64_t camlList_assq_202 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rbx == 1) {
            goto label_0;
        }
        rdx = *((rbx + 8));
        rdi = *(rbx);
        rsi = *((rdi + 8));
        rdi = *(rdi);
        if (rdi == rax) {
            rax = rsi;
            return rax;
        }
        rbx = rdx;
    } while (1);
    do {
label_0:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b880 */
#include <stdint.h>
 
int64_t camlUnix_handle_unix_error_199 (void) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = rax;
    rax = rbx;
    rax = void (*0x40ba00)() ();
    rbx = *(reloc.camlUnix);
    rdi = *(rbx);
    rbx = *(rax);
    if (rbx == rdi) {
        rbx = *((rax + 0x18));
        *((rsp + 0x10)) = rbx;
        rbx = *((rax + 0x10));
        *(rsp) = rbx;
        rax = *((rax + 8));
        *((rsp + 8)) = rax;
        rax = *(reloc.camlSys);
        rbx = *(rax);
        rax = *((rbx - 8));
        rax >>= 9;
        if (rax <= 1) {
            goto label_0;
        }
        rbx = *(rbx);
        rax = *(reloc.camlPervasives);
        rax = *((rax + 0xc0));
        camlPervasives_output_string_215 ();
        rbx = *(loc.camlUnix__212);
        rax = *(reloc.camlPervasives);
        rax = *((rax + 0xc0));
        camlPervasives_output_string_215 ();
        rax = *(reloc.camlPervasives);
        rax = *((rax + 0xc0));
        rbx = *(rsp);
        camlPervasives_output_string_215 ();
        rbx = *(loc.camlUnix__211);
        rax = *(reloc.camlPervasives);
        rax = *((rax + 0xc0));
        camlPervasives_output_string_215 ();
        rax = *((rsp + 0x10));
        rbx = *((rax - 8));
        rbx >>= 0xa;
        rbx = rbx*8 - 1;
        rdi = *((rax + rbx));
        rbx -= rdi;
        rbx = rbx + rbx + 1;
        if (rbx > 1) {
            *((rsp + 0x10)) = rax;
            rbx = *(loc.camlUnix__210);
            rax = *(reloc.camlPervasives);
            rax = *((rax + 0xc0));
            camlPervasives_output_string_215 ();
            rax = *(reloc.camlPervasives);
            rax = *((rax + 0xc0));
            rbx = *((rsp + 0x10));
            camlPervasives_output_string_215 ();
            rbx = *(loc.camlUnix__209);
            rax = *(reloc.camlPervasives);
            rax = *((rax + 0xc0));
            camlPervasives_output_string_215 ();
        }
        rbx = *(loc.camlUnix__208);
        rax = *(reloc.camlPervasives);
        rax = *((rax + 0xc0));
        camlPervasives_output_string_215 ();
        rdi = *((rsp + 8));
        rax = *(reloc.unix_error_message);
        caml_c_call ();
        camlPervasives_prerr_endline_309 ();
        rax = 5;
        void (*0x410990)() ();
    }
    rax = caml_raise_exn ();
    r14 = rsp;
    rdi = *(rsi);
    rbx = rsi;
    void (*rdi)(uint64_t) (r14);
    return rax;
label_0:
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x426ee0 */
#include <stdint.h>
 
int64_t caml_oldify_mopup (void) {
    do {
        rbp = oldify_todo_list;
        if (rbp == 0) {
            goto label_1;
        }
label_0:
        rbx = *(rbp);
        rax = *((rbx + 8));
        r12 = rbx + 8;
        *(obj.oldify_todo_list) = rax;
        rdi = *(rbx);
        if ((dil & 1) == 0) {
            if (rdi >= *(obj.caml_young_end)) {
                goto label_2;
            }
            if (rdi <= *(obj.caml_young_start)) {
                goto label_2;
            }
            rsi = rbx;
            caml_oldify_one ();
        }
label_2:
        rax = *((rbx - 8));
        r13 = rbx - 8;
        rax >>= 0xa;
    } while (rax <= 1);
    ebx = 1;
    do {
        rdi = *((rbp + rbx*8));
        if ((dil & 1) == 0) {
            if (rdi < *(obj.caml_young_end)) {
                if (rdi <= *(obj.caml_young_start)) {
                    goto label_3;
                }
                rsi = r12;
                caml_oldify_one ();
            }
        } else {
label_3:
            *(r12) = rdi;
        }
        rax = *(r13);
        rbx++;
        r12 += 8;
        rax >>= 0xa;
    } while (rax > rbx);
    rbp = oldify_todo_list;
    if (rbp != 0) {
        goto label_0;
    }
label_1:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42fc10 */
#include <stdint.h>
 
uint32_t caml_sys_remove (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    eax = unlink (rdi);
    if (eax != 0) {
        rdi = rbx;
        caml_sys_error ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418d90 */
#include <stdint.h>
 
int64_t camlHashtbl_clear_82 (void) {
    r12 = rax;
    rbx = 1;
    rax = *((r12 + 8));
    rbp = *((rax - 8));
    rbp >>= 9;
    rbp |= 1;
    rbp += 0xfffffffffffffffe;
    if (rbx > rbp) {
        goto label_0;
    }
    do {
        rdi = *((r12 + 8));
        rax = *((rdi - 8));
        rax >>= 9;
        if (rax <= rbx) {
            goto label_1;
        }
        rsi = 1;
        rdi = rdi + rbx*4 - 4;
        caml_modify ();
        rax = rbx;
        rbx += 2;
    } while (rax != rbp);
label_0:
    *(r12) = 1;
    rax = 1;
    return rax;
label_1:
    return caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a6f0 */
#include <stdint.h>
 
void caml_float_of_int (int64_t arg1, int64_t arg7) {
    rdi = arg1;
    xmm0 = arg7;
    rdi >>= 1;
    __asm ("cvtsi2sd xmm0, rdi");
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40aff0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1667 (void) {
    rdi = rax;
    rax = *(reloc.unix_sleep);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a460 */
#include <stdint.h>
 
void caml_log10_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    log10 (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4343a0 */
#include <stdint.h>
 
uint64_t caml_read_directory (int64_t arg2) {
    rsi = arg2;
    r12 = rsi;
    rax = opendir ();
    rbx = rax;
    eax = 0xffffffff;
    if (rbx == 0) {
        goto label_3;
    }
    do {
label_2:
        rdi = rbx;
        rax = readdir64 ();
        if (rax == 0) {
            goto label_4;
        }
label_0:
        r13 = rax + 0x13;
        edx = *(0x00436e6d);
        eax = *((rax + 0x13));
        if (eax != edx) {
            goto label_5;
        }
        edx = *((r13 + 1));
    } while (dl == *(0x00436e6e));
label_5:
    edx = *(0x00436e6c);
    if (eax == edx) {
        goto label_6;
    }
label_1:
    strlen (r13);
    rdi = rax + 1;
    rax = caml_stat_alloc ();
    strcpy (rax, r13);
    rsi = rbp;
    rdi = r12;
    caml_ext_table_add ();
    rdi = rbx;
    rax = readdir64 ();
    if (rax != 0) {
        goto label_0;
    }
label_4:
    rdi = rbx;
    eax = closedir ();
    eax = 0;
label_3:
    return rax;
label_6:
    eax = *((r13 + 1));
    if (al != *(0x00436e6d)) {
        goto label_1;
    }
    eax = *((r13 + 2));
    if (al == *(0x00436e6e)) {
        goto label_2;
    }
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b340 */
#include <stdint.h>
 
int64_t caml_array_get_addr (uint32_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    if (rsi >= 0) {
        rax = *((rdi - 8));
        rax >>= 0xa;
        if (rsi >= rax) {
            goto label_0;
        }
        rax = *((rdi + rsi*8));
        return rax;
    }
label_0:
    return caml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a460 */
#include <stdint.h>
 
int64_t caml_tuplify3 (void) {
    rsi = rbx;
    rdi = *((rax + 0x10));
    rbx = *((rax + 8));
    rax = *(rax);
    rdx = *((rsi + 0x10));
    return void (*rdx)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a130 */
#include <stdint.h>
 
int64_t camlBuffer_contents_72 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = *((rax + 8));
    rbx = 1;
    rax = *(rax);
    return camlString_sub_74 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x419c00 */
#include <stdint.h>
 
int64_t camlHashtbl_entry (void) {
    rbx = *(loc.camlHashtbl__16);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x68)) = rbx;
    rbx = *(loc.camlHashtbl__15);
    rax = *(reloc.camlHashtbl);
    *(rax) = rbx;
    rbx = *(loc.camlHashtbl__14);
    rax = *(reloc.camlHashtbl);
    *((rax + 8)) = rbx;
    rbx = *(loc.camlHashtbl__13);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x18)) = rbx;
    rbx = *(loc.camlHashtbl__12);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x58)) = rbx;
    rbx = *(loc.camlHashtbl__11);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x70)) = rbx;
    rbx = *(loc.camlHashtbl__10);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x10)) = rbx;
    rbx = *(loc.camlHashtbl__9);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x38)) = rbx;
    rbx = *(loc.camlHashtbl__8);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x78)) = rbx;
    rbx = *(loc.camlHashtbl__7);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x20)) = rbx;
    rbx = *(loc.camlHashtbl__6);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x28)) = rbx;
    rbx = *(loc.camlHashtbl__5);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x40)) = rbx;
    rbx = *(loc.camlHashtbl__4);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x30)) = rbx;
    rbx = *(loc.camlHashtbl__3);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x48)) = rbx;
    rbx = *(loc.camlHashtbl__2);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x50)) = rbx;
    rbx = *(loc.camlHashtbl__1);
    rax = *(reloc.camlHashtbl);
    *((rax + 0x60)) = rbx;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4107b0 */
#include <stdint.h>
 
int64_t camlPervasives_fun_517 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_pos_in_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40acf0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1619 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_listen);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40afb0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1663 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_utimes);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b090 */
#include <stdint.h>
 
uint64_t caml_array_unsafe_set_addr (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    rbx = rdi + rsi*8;
    *((rsp - 8)) = r12;
    r12 = *(rbx);
    rdi = rbx;
    *(rbx) = rdx;
    al = caml_page_table_lookup ();
    if ((al & 1) == 0) {
        goto label_0;
    }
    eax = caml_gc_phase;
    if (eax == 0) {
        goto label_3;
    }
    while ((bpl & 1) == 0) {
        rax = caml_young_end;
        if (rbp < rax) {
            rdx = caml_young_start;
            if (rbp <= rdx) {
                goto label_0;
            }
            if ((r12b & 1) == 0) {
                goto label_4;
            }
label_1:
            rax = .comment;
            if (rax >= *(0x00652440)) {
                goto label_5;
            }
label_2:
            *(rax) = rbx;
            rax += 8;
            *(0x00652438) = rax;
        }
label_0:
        eax = 1;
        rbx = *(rsp);
        rbp = *((rsp + 8));
        r12 = *((rsp + 0x10));
        return rax;
label_3:
        esi = 0;
        rdi = r12;
        rax = caml_darken ();
    }
    goto label_0;
label_4:
    if (rax <= r12) {
        goto label_1;
    }
    if (rdx < r12) {
        goto label_0;
    }
    goto label_1;
label_5:
    edi = caml_ref_table;
    caml_realloc_ref_table ();
    rax = .comment;
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d4f0 */
#include <stdint.h>
 
void camlPrintf_sub_78 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    return camlString_sub_74 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42bbb0 */
#include <stdint.h>
 
int64_t caml_input_scan_line (int64_t arg1) {
    rdi = arg1;
    r12 = rdi + 0x50;
    r13d = r12d;
    rbx = rdi;
    rax = *((rdi + 0x18));
    goto label_2;
label_0:
    rdx = *((rbx + 0x10));
    if (rdx <= rsi) {
        goto label_3;
    }
    edi = *(rbx);
    edx -= esi;
    eax = caml_do_read ();
    if (eax == 0) {
        goto label_4;
    }
    rax = (int64_t) eax;
    *((rbx + 8)) += rax;
    *((rbx + 0x20)) += rax;
    rax = *((rbx + 0x18));
    do {
        edx = *(rbp);
        rbp++;
        if (dl == 0xa) {
            goto label_5;
        }
label_2:
        rsi = *((rbx + 0x20));
    } while (rbp < rsi);
    if (r12 >= rax) {
        goto label_0;
    }
    rdx -= rax;
    memmove (r12, rax, rsi);
    rax = *((rbx + 0x18));
    edx = eax;
    edx -= r13d;
    rdx = (int64_t) edx;
    rdx = -rdx;
    rsi = rdx;
    rsi += *((rbx + 0x20));
    rax += rdx;
    *((rbx + 0x18)) = rax;
    rbp += rdx;
    *((rbx + 0x20)) = rsi;
    goto label_0;
label_5:
    rbp -= rax;
    rax = rbp;
    do {
label_1:
        return rax;
label_3:
        rax -= rsi;
    } while (1);
label_4:
    rax = *((rbx + 0x18));
    rax -= *((rbx + 0x20));
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b660 */
#include <stdint.h>
 
int64_t camlUnix_fun_1769 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_open_descriptor_in);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42fa70 */
#include <stdint.h>
 
uint64_t caml_sys_system_command (void * arg1) {
    void * s2;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    *((rsp - 8)) = r12;
    rbp = caml_local_roots;
    rdx = rsp + 0x10;
    *((rsp + 8)) = rdi;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 8;
    *((rsp + 0x10)) = rbp;
    *((rsp + 0x28)) = rdx;
    caml_string_length ();
    r12 = rax + 1;
    rdi = r12;
    rax = caml_stat_alloc ();
    rbx = rax;
    memmove (rax, *((rsp + 8)), r12);
    caml_enter_blocking_section ();
    eax = system (rbx);
    r12d = eax;
    caml_leave_blocking_section ();
    rdi = rbx;
    caml_stat_free ();
    if (r12d != 0xffffffff) {
        eax = 0x1ff;
        if ((r12b & 0x7f) == 0) {
            rdx = r12;
            eax = (int32_t) dh;
            rax = rax + rax + 1;
        }
        *(obj.caml_local_roots) = rbp;
        rbx = *((rsp + 0x50));
        rbp = *((rsp + 0x58));
        r12 = *((rsp + 0x60));
        return rax;
    }
    rdi = *((rsp + 8));
    return caml_sys_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408fa0 */
#include <stdint.h>
 
void system (void) {
    system ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417210 */
#include <stdint.h>
 
int64_t camlString_map_118 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdi = *((rbx - 8));
    rdi >>= 0xa;
    rdi = rdi*8 - 1;
    rsi = *((rbx + rdi));
    rdi -= rsi;
    rdi = rdi + rdi + 1;
    if (rdi == 1) {
        rax = rbx;
        return rax;
    }
    *(rsp) = rdi;
    *((rsp + 8)) = rbx;
    *((rsp + 0x10)) = rax;
    rax = *(reloc.caml_create_string);
    rax = caml_c_call ();
    rdx = rax;
    rdi = 1;
    rbx = *(rsp);
    rbx += 0xfffffffffffffffe;
    if (rdi > rbx) {
        goto label_0;
    }
    do {
        rdi >>= 1;
        rax = *((rsp + 8));
        rax = *((rax + rdi));
        rax = rax + rax + 1;
        rbx = *((rsp + 0x10));
        rdi = *(rbx);
        rax = void (*rdi)(uint64_t) (rbx);
        rax >>= 1;
        rdi = *(rsp);
        rbx = *(rsp);
        rbx >>= 1;
        rdx = *((rsp + 0x18));
        *((rdx + rbx)) = al;
        rsi = rdi;
        rdi += 2;
        *(rsp) = rdi;
        rbx = *((rsp + 0x20));
    } while (rsi != rbx);
label_0:
    rax = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40acb0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1615 (void) {
    rdi = rax;
    rax = *(reloc.unix_getsockname);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4107f0 */
#include <stdint.h>
 
int64_t camlPervasives_fun_513 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_channel_size_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42dc10 */
#include <stdint.h>
 
uint64_t caml_output_value_to_malloc (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    void * var_8h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r13 = rsi;
    r12 = rcx;
    rbx = rdx;
    init_extern_output ();
    rsi = r13;
    rdi = rbp;
    rax = extern_value ();
    rdi = rax;
    r13 = rax;
    rax = malloc (rdi);
    if (rax == 0) {
        goto label_0;
    }
    *(rbx) = rax;
    rbx = extern_output_first;
    *(r12) = r13;
    if (rbx == 0) {
        goto label_1;
    }
    do {
        r12 = *((rbx + 8));
        r12d -= esi;
        r12 = (int64_t) r12d;
        rbp += r12;
        rax = memmove (rbp, rbx + 0x10, r12);
        rbx = *(rbx);
    } while (rbx != 0);
label_1:
    void (*0x42ca90)() ();
label_0:
    *((rsp + 8)) = rax;
    return extern_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b620 */
#include <stdint.h>
 
int64_t camlUnix_fun_1765 (void) {
    rdi = rax;
    rax = *(reloc.caml_channel_descriptor);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ded0 */
#include <stdint.h>
 
uint64_t caml_deserialize_uint_2 (void) {
    rdx = intern_src;
    rax = rdx + 2;
    *(obj.intern_src) = rax;
    ecx = *((rax - 1));
    eax = *(rdx);
    eax <<= 8;
    eax = rcx + rax;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d280 */
#include <stdint.h>
 
int64_t camlUnix_open_process_full_1011 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_50h;
    *((rsp + 0x18)) = rax;
    *((rsp + 0x20)) = rbx;
    rdi = 1;
    rax = *(reloc.unix_pipe);
    rax = caml_c_call ();
    rbx = *((rax + 8));
    *((rsp + 0x30)) = rbx;
    rax = *(rax);
    *((rsp + 0x10)) = rax;
    rdi = 1;
    rax = *(reloc.unix_pipe);
    rax = caml_c_call ();
    rbx = *((rax + 8));
    *((rsp + 8)) = rbx;
    rax = *(rax);
    *((rsp + 0x28)) = rax;
    rdi = 1;
    rax = *(reloc.unix_pipe);
    rax = caml_c_call ();
    rbx = *((rax + 8));
    *((rsp + 0x38)) = rbx;
    rax = *(rax);
    *(rsp) = rax;
    rdi = *((rsp + 0x10));
    rax = *(reloc.caml_ml_open_descriptor_in);
    rax = caml_c_call ();
    *((rsp + 0x40)) = rax;
    rdi = *((rsp + 8));
    rax = *(reloc.caml_ml_open_descriptor_out);
    rax = caml_c_call ();
    *((rsp + 0x48)) = rax;
    rdi = *(rsp);
    rax = *(reloc.caml_ml_open_descriptor_in);
    rax = caml_c_call ();
    rsi = rax;
    *((rsp + 0x50)) = rsi;
label_0:
    r15 -= 0x68;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    rdi = r15 + 8;
    *((rdi - 8)) = 0x800;
    rax = *(rsp);
    *(rdi) = rax;
    *((rdi + 8)) = 1;
    rbx = rdi + 0x18;
    *((rbx - 8)) = 0x800;
    rax = *((rsp + 8));
    *(rbx) = rax;
    *((rbx + 8)) = rdi;
    r8 = rdi + 0x30;
    *((r8 - 8)) = 0x800;
    rax = *((rsp + 0x10));
    *(r8) = rax;
    *((r8 + 8)) = rbx;
    rdi += 0x48;
    *((rdi - 8)) = 0xc03;
    rax = *((rsp + 0x40));
    *(rdi) = rax;
    rax = *((rsp + 0x48));
    *((rdi + 8)) = rax;
    *((rdi + 0x10)) = rsi;
    rax = *((rsp + 0x18));
    rbx = *((rsp + 0x20));
    rsi = *((rsp + 0x28));
    rdx = *((rsp + 0x30));
    rcx = *((rsp + 0x38));
    camlUnix_open_proc_full_1001 ();
    rdi = *((rsp + 0x28));
    rax = *(reloc.unix_close);
    caml_c_call ();
    rdi = *((rsp + 0x30));
    rax = *(reloc.unix_close);
    caml_c_call ();
    rdi = *((rsp + 0x38));
    rax = *(reloc.unix_close);
    caml_c_call ();
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0xc00;
            rbx = *((rsp + 0x40));
            *(rax) = rbx;
            rbx = *((rsp + 0x48));
            *((rax + 8)) = rbx;
            rbx = *((rsp + 0x50));
            *((rax + 0x10)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d0e0 */
#include <stdint.h>
 
int64_t camlUnix_open_proc_full_1001 (int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x20)) = rax;
    *((rsp + 0x28)) = rbx;
    *((rsp + 0x38)) = rdi;
    *(rsp) = rsi;
    *((rsp + 8)) = rdx;
    *((rsp + 0x10)) = rcx;
    rbx = r8;
    *((rsp + 0x30)) = rbx;
    rax = *(reloc.camlUnix);
    rax = *((rax + 0x4c8));
    rax = camlList_for_all_165 ();
    *((rsp + 0x18)) = rax;
    rdi = 1;
    rax = *(reloc.unix_fork);
    rax = caml_c_call ();
    rdi = rax;
    if (rdi != 1) {
        rax = *(reloc.camlUnix);
        rax = *((rax + 0x508));
        rbx = *((rsp + 0x38));
        void (*0x418fc0)() ();
    }
    rsi = 1;
    rdi = *(rsp);
    rax = *(reloc.unix_dup2);
    caml_c_call ();
    rdi = *(rsp);
    rax = *(reloc.unix_close);
    caml_c_call ();
    rsi = 3;
    rdi = *((rsp + 8));
    rax = *(reloc.unix_dup2);
    caml_c_call ();
    rdi = *((rsp + 8));
    rax = *(reloc.unix_close);
    caml_c_call ();
    rsi = 5;
    rdi = *((rsp + 0x10));
    rax = *(reloc.unix_dup2);
    caml_c_call ();
    rdi = *((rsp + 0x10));
    rax = *(reloc.unix_close);
    caml_c_call ();
    rax = *((rsp + 0x18));
    if (rax == 1) {
        rax = *(loc.camlUnix__182);
        rbx = *((rsp + 0x30));
        camlList_iter_102 ();
    }
    fcn_0040d208 (rdi, rsi, rdx, rcx, r8, r9);
    rax = 0xff;
    return camlPervasives_exit_350 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d610 */
#include <stdint.h>
 
int64_t camlUnix_close_process_out_1032 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    *(rsp) = rdi;
    do {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0x402;
            *(rbx) = rdi;
            rax = *(loc.camlUnix__176);
            rax = camlUnix_find_proc_id_1023 ();
            *((rsp + 8)) = rax;
            rax = *(rsp);
            camlPervasives_close_out_233 ();
            rax = *((rsp + 8));
            rax = camlUnix_waitpid_non_intr_1027 ();
            rax += 8;
            rax = *(rax);
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d910 */
#include <stdint.h>
 
uint64_t camlUnix_accept_non_intr_1050 (void) {
    do {
        *(rsp) = rax;
        rax = void (*0x40d94c)() ();
        rbx = *(reloc.camlUnix);
        rdi = *(rbx);
        rbx = *(rax);
        if (rbx != rdi) {
            goto label_0;
        }
        rbx = *((rax + 8));
        if ((bl & 1) == 0) {
            goto label_0;
        }
        if (rbx != 0x17) {
            goto label_0;
        }
        rax = *(rsp);
    } while (1);
label_0:
    rax = caml_raise_exn ();
    r14 = rsp;
    rdi = rax;
    rax = *(reloc.unix_accept);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b460 */
#include <stdint.h>
 
int64_t camlUnix_fun_1737 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_chown);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4254f0 */
#include <stdint.h>
 
void caml_fl_init_merge (void) {
    *(obj.last_fragment) = 0;
    *(obj.caml_fl_merge) = 0x64de30;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421f03 */
#include <stdint.h>
 
int64_t alloc_inet6_addr (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    edi = 0x10;
    caml_alloc_string ();
    rdx = *(rbx);
    *(rax) = rdx;
    rdx = *((rbx + 8));
    *((rax + 8)) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416ae0 */
#include <stdint.h>
 
int64_t camlString_fill_79 (int64_t arg6, int64_t arg5, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rdi;
    rcx = rsi;
    if (rbx >= 1) {
        if (rdx < 1) {
            goto label_0;
        }
        rdi = *((rax - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rax + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= rdx;
        rdi += 2;
        if (rbx > rdi) {
            goto label_0;
        }
        rdi = rax;
        rsi = rbx;
        caml_fill_string ();
        return;
    }
label_0:
    rax = *(loc.camlString__31);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429740 */
#include <stdint.h>
 
int64_t caml_nativeint_xor (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = *((rsi + 8));
    rax ^= *((rdi + 8));
    rdi = rax;
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410010 */
#include <stdint.h>
 
int64_t camlPervasives_flush_all_209 (void) {
    rax = *(loc.camlPervasives__92);
    rdi = 1;
    rax = *(reloc.caml_ml_out_channels_list);
    caml_c_call ();
    return camlPervasives_iter_210 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429e60 */
#include <stdint.h>
 
uint64_t caml_eq_float (int64_t arg3, int64_t arg1) {
    rdx = arg3;
    rdi = arg1;
    xmm0 = *(rdi);
    __asm ("ucomisd xmm0, qword [rsi]");
    al = (? == ?) ? 1 : 0;
    __asm ("setnp dl");
    eax &= edx;
    eax = (int32_t) al;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b1a0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1693 (void) {
    rdi = rax;
    rax = *(reloc.unix_readlink);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4105c0 */
#include <stdint.h>
 
int64_t camlPervasives_prerr_string_303 (void) {
    rbx = rax;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0xc0));
    return camlPervasives_output_string_215 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423c00 */
#include <stdint.h>
 
void caml_raise_sys_error (int64_t arg1) {
    rdi = arg1;
    rsi = rdi;
    edi = caml_exn_Sys_error;
    return caml_raise_with_arg ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4139a0 */
#include <stdint.h>
 
int64_t camlArray_sort_179 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h_2;
    int64_t var_10h;
    int64_t var_18h_2;
    int64_t var_20h;
    int64_t var_28h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    *((rsp + 0x20)) = rbx;
label_5:
    r15 -= 0xf0;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_6;
    }
    rax = r15 + 8;
    *((rax - 8)) = 0x14f7;
    rdi = *(reloc.caml_curry2);
    *(rax) = rdi;
    *((rax + 8)) = 5;
    rdi = *(reloc.camlArray__maxson_182);
    *((rax + 0x10)) = rdi;
    *((rax + 0x18)) = rsi;
    *((rax + 0x20)) = rbx;
    rcx = rax + 0x30;
    *((rcx - 8)) = 0x18f7;
    rdi = *(reloc.caml_curry3);
    *(rcx) = rdi;
    *((rcx + 8)) = 7;
    rdi = *(reloc.camlArray__trickledown_187);
    *((rcx + 0x10)) = rdi;
    *((rcx + 0x18)) = rsi;
    *((rcx + 0x20)) = rbx;
    *((rcx + 0x28)) = rax;
    rdi = rax + 0x68;
    *((rdi - 8)) = 0x14f7;
    rdx = *(reloc.caml_curry3);
    *(rdi) = rdx;
    *((rdi + 8)) = 7;
    rdx = *(reloc.camlArray__trickle_192);
    *((rdi + 0x10)) = rdx;
    *((rdi + 0x18)) = rbx;
    *((rdi + 0x20)) = rcx;
    rcx = rax + 0x98;
    *((rcx - 8)) = 0x14f7;
    rdx = *(reloc.caml_curry2);
    *(rcx) = rdx;
    *((rcx + 8)) = 5;
    rdx = *(reloc.camlArray__bubbledown_197);
    *((rcx + 0x10)) = rdx;
    *((rcx + 0x18)) = rbx;
    *((rcx + 0x20)) = rax;
    rdx = rax + 0xc8;
    *(rsp) = rdx;
    *((rdx - 8)) = 0x10f7;
    rax = *(reloc.caml_curry2);
    *(rdx) = rax;
    *((rdx + 8)) = 5;
    rax = *(reloc.camlArray__bubble_201);
    *((rdx + 0x10)) = rax;
    *((rdx + 0x18)) = rcx;
label_4:
    r15 -= 0x30;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_7;
    }
    rdx = r15 + 8;
    *((rsp + 0x10)) = rdx;
    *((rdx - 8)) = 0x14f7;
    rax = *(reloc.caml_curry2);
    *(rdx) = rax;
    *((rdx + 8)) = 5;
    rax = *(reloc.camlArray__trickleup_205);
    *((rdx + 0x10)) = rax;
    *((rdx + 0x18)) = rsi;
    *((rdx + 0x20)) = rbx;
    rax = *((rbx - 8));
    rax >>= 9;
    rax |= 1;
    *((rsp + 0x28)) = rax;
    rcx = 3;
    rax += 2;
    rax >>= 1;
    __asm ("cqo");
    rax = rdx:rax / rcx;
    rdx = rdx:rax % rcx;
    rbx = rax + rax - 1;
    if (rbx < 1) {
        goto label_8;
    }
    *((rsp + 0x18)) = rbx;
    *((rsp + 8)) = rdi;
    do {
        rsi = *((rsp + 0x20));
        rax = *((rsi - 8));
        rdi = *((rsi - 8));
        rdi &= 0xff;
        if (rdi != 0xfe) {
            rax >>= 9;
            if (rax <= rbx) {
                goto label_9;
            }
            rdi = *((rsi + rbx*4 - 4));
        } else {
            rax >>= 9;
            if (rax <= rbx) {
                goto label_10;
            }
label_3:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_11;
            }
            rdi = r15 + 8;
            *((rdi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rsi + rbx*4 - 4]");
            __asm ("movlpd qword [rdi], xmm0");
        }
        rax = *((rsp + 0x28));
        rsi = *((rsp + 8));
        camlArray_trickle_192 ();
        rbx = *((rsp + 0x18));
        rax = *((rsp + 0x18));
        rbx -= 2;
        *((rsp + 0x18)) = rbx;
    } while (rax != 1);
label_8:
    rbp = *((rsp + 0x28));
    rbp += 0xfffffffffffffffe;
    if (rbp < 5) {
        goto label_12;
    }
    *((rsp + 0x18)) = rbp;
    do {
        rbx = *((rsp + 0x20));
        rax = *((rbx - 8));
        rdi = *((rbx - 8));
        rdi &= 0xff;
        if (rdi != 0xfe) {
            rax >>= 9;
            if (rax <= rbp) {
                goto label_13;
            }
            rax = *((rbx + rbp*4 - 4));
            *((rsp + 8)) = rax;
        } else {
            rax >>= 9;
            if (rax <= rbp) {
                goto label_14;
            }
label_2:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_15;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rbx + rbp*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
            *((rsp + 8)) = rax;
        }
        rax = *((rbx - 8));
        rdi = *((rbx - 8));
        rdi &= 0xff;
        if (rdi != 0xfe) {
            rax >>= 9;
            if (rax <= 1) {
                goto label_16;
            }
            rsi = *(rbx);
        } else {
            rax >>= 9;
            if (rax <= 1) {
                goto label_17;
            }
label_1:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_18;
            }
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rbx]");
            __asm ("movlpd qword [rsi], xmm0");
        }
        rax = *((rbx - 8));
        rdi = *((rbx - 8));
        rdi &= 0xff;
        if (rdi != 0xfe) {
            rax >>= 9;
            if (rax <= rbp) {
                goto label_19;
            }
            rdi = rbx + rbp*4 - 4;
            rax = caml_modify ();
        } else {
            rax >>= 9;
            if (rax <= rbp) {
                goto label_20;
            }
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [rbx + rbp*4 - 4], xmm0");
        }
        rbx = 1;
        rax = rbp;
        rdi = *(rsp);
        camlArray_bubble_201 ();
        rbx = *((rsp + 8));
        rdi = *((rsp + 0x10));
        camlArray_trickleup_205 ();
        rbp = *((rsp + 0x18));
        rax = *((rsp + 0x18));
        rbp -= 2;
        *((rsp + 0x18)) = rbp;
    } while (rax != 5);
label_12:
    rax = *((rsp + 0x28));
    if (rax <= 3) {
        goto label_21;
    }
    rbx = *((rsp + 0x20));
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 3) {
            goto label_22;
        }
        rbp = *((rbx + 8));
    } else {
        rax >>= 9;
        if (rax <= 3) {
            goto label_23;
        }
label_0:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_24;
        }
        rbp = r15 + 8;
        *((rbp - 8)) = 0x4fd;
        __asm ("movlpd xmm0, qword [rbx + 8]");
        __asm ("movlpd qword [rbp], xmm0");
    }
    rax = *((rbx - 8));
    rdi = *((rbx - 8));
    rdi &= 0xff;
    if (rdi != 0xfe) {
        rax >>= 9;
        if (rax <= 1) {
            goto label_25;
        }
        rsi = *(rbx);
        goto label_26;
    }
    rax >>= 9;
    if (rax <= 1) {
        goto label_27;
    }
    do {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rbx]");
            __asm ("movlpd qword [rsi], xmm0");
label_26:
            rax = *((rbx - 8));
            rdi = *((rbx - 8));
            rdi &= 0xff;
            if (rdi != 0xfe) {
                rax >>= 9;
                if (rax <= 3) {
                    goto label_28;
                }
                rdi = rbx;
                rdi += 8;
                rax = caml_modify ();
            } else {
                rax >>= 9;
                if (rax <= 3) {
                    goto label_29;
                }
                __asm ("movlpd xmm0, qword [rsi]");
                __asm ("movlpd qword [rbx + 8], xmm0");
            }
            rax = *((rbx - 8));
            rdi = *((rbx - 8));
            rdi &= 0xff;
            if (rdi != 0xfe) {
                rax >>= 9;
                if (rax <= 1) {
                    goto label_30;
                }
                rdi = rbx;
                rsi = rbp;
                rax = caml_modify ();
            } else {
                rax >>= 9;
                if (rax <= 1) {
                    goto label_31;
                }
                __asm ("movlpd xmm0, qword [rbp]");
                __asm ("movlpd qword [rbx], xmm0");
            }
            rax = 1;
            return rax;
label_21:
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_24:
    caml_call_gc ();
    goto label_0;
label_18:
    caml_call_gc ();
    goto label_1;
label_15:
    caml_call_gc ();
    goto label_2;
label_11:
    caml_call_gc ();
    goto label_3;
label_7:
    caml_call_gc ();
    goto label_4;
label_6:
    caml_call_gc ();
    goto label_5;
label_31:
    caml_ml_array_bound_error ();
label_30:
    caml_ml_array_bound_error ();
label_29:
    caml_ml_array_bound_error ();
label_28:
    caml_ml_array_bound_error ();
label_27:
    caml_ml_array_bound_error ();
label_25:
    caml_ml_array_bound_error ();
label_23:
    caml_ml_array_bound_error ();
label_22:
    caml_ml_array_bound_error ();
label_20:
    caml_ml_array_bound_error ();
label_19:
    caml_ml_array_bound_error ();
label_17:
    caml_ml_array_bound_error ();
label_16:
    caml_ml_array_bound_error ();
label_14:
    caml_ml_array_bound_error ();
label_13:
    caml_ml_array_bound_error ();
label_10:
    caml_ml_array_bound_error ();
label_9:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429f70 */
#include <stdint.h>
 
void caml_init_ieee_floats (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428b00 */
#include <stdint.h>
 
uint64_t caml_greaterthan (void) {
    edx = 0;
    rax = compare_val ();
    rbx = rax;
    if (*(obj.compare_stack) != 0x652500) {
        eax = compare_free_stack ();
    }
    eax = 0;
    al = (rbx > 0) ? 1 : 0;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42be60 */
#include <stdint.h>
 
int64_t caml_refill (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    rdi = arg1;
    rdx = *((rdi + 0x10));
    rsi = rdi + 0x50;
    rbx = rdi;
    edi = *(rdi);
    edx -= esi;
    eax = caml_do_read ();
    if (eax != 0) {
        rax = (int64_t) eax;
        *((rbx + 8)) += rax;
        rax = rbx + rax + 0x50;
        *((rbx + 0x20)) = rax;
        rax = rbx + 0x51;
        *((rbx + 0x18)) = rax;
        eax = *((rbx + 0x50));
        return rax;
    }
    return caml_raise_end_of_file ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423d50 */
#include <stdint.h>
 
void caml_raise_end_of_file (void) {
    edi = caml_exn_End_of_file;
    return caml_raise_constant ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4191d0 */
#include <stdint.h>
 
int64_t camlHashtbl_find_rec_116 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h_3;
    int64_t var_10h_3;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rbx == 1) {
            goto label_0;
        }
        *(rsp) = rax;
        rsi = *((rbx + 0x10));
        *((rsp + 8)) = rsi;
        rsi = *((rbx + 8));
        *((rsp + 0x10)) = rsi;
        rsi = *(rbx);
        rdi = rax;
        rax = *(reloc.caml_compare);
        rax = caml_c_call ();
        if (rax == 1) {
            rax = *((rsp + 0x10));
            return rax;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
    } while (1);
    do {
label_0:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            caml_raise_exn ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41c730 */
#include <stdint.h>
 
int64_t camlPrintf_add_dot_302 (void) {
    rax = rbx;
    rbx = *(loc.camlPrintf__64);
    return camlPervasives_5e_136 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429b60 */
#include <stdint.h>
 
int64_t caml_int64_xor (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = *((rsi + 8));
    rax ^= *((rdi + 8));
    rdi = rax;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ac70 */
#include <stdint.h>
 
int64_t camlUnix_fun_1611 (void) {
    rdi = rax;
    rax = *(reloc.unix_gethostname);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417630 */
#include <stdint.h>
 
uint64_t camlString_rcontains_from_168 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rbx >= 1) {
        rsi = *((rax - 8));
        rsi >>= 0xa;
        rsi = rsi*8 - 1;
        rdx = *((rax + rsi));
        rsi -= rdx;
        rsi = rsi + rsi + 1;
        if (rbx >= rsi) {
            goto label_0;
        }
        rax = void (*0x417684)() ();
        rdi = *(reloc.caml_exn_Not_found);
        rbx = *(rax);
        if (rbx == rdi) {
            rax = 1;
            return rax;
        }
        rax = caml_raise_exn ();
        r14 = rsp;
        camlString_rindex_rec_149 ();
        rax = 3;
        return rax;
    }
label_0:
    rax = *(loc.camlString__25);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433ec0 */
#include <stdint.h>
 
int64_t caml_final_update (void) {
    rsi = old;
    if (rsi == 0) {
        goto label_0;
    }
    rcx = final_table;
    ebx = 0;
    edx = 0;
    do {
        rax = *((rcx + 8));
        rax = *((rax - 8));
        eax &= 0x300;
        rbx += 0;
        rdx++;
        rcx += 0x18;
    } while (rdx < rsi);
    if (rbx == 0) {
label_0:
        r12 = rbx;
        r13 = rbx;
        r14 = rbx;
        return rax;
    }
    rax = (int64_t) ebx;
    rax *= 3;
    rax = malloc (rax*8 + 0x28);
    if (rax == 0) {
        goto label_5;
    }
    rdx = to_do_tl;
    *(rax) = 0;
    *((rax + 8)) = ebx;
    if (rdx == 0) {
        goto label_6;
    }
    *(rdx) = rax;
    *(obj.to_do_tl) = rax;
label_4:
    if (*(obj.old) == 0) {
        goto label_7;
    }
    r12d = 0;
    ebx = 0;
    r14d = 0;
    r13d = 0;
    do {
label_1:
        rcx = final_table;
        rdx = rcx + r12;
        rax = *((rdx + 8));
        if ((*((rax - 8)) & 0x300) != 0) {
            goto label_8;
        }
        if (*((rax - 8)) == 0xfa) {
            rbp = *(rax);
            if ((bpl & 1) == 0) {
                goto label_9;
            }
            *((rdx + 8)) = rbp;
        }
label_2:
        rax = rbx * 3;
        rsi = *(rdx);
        rbx++;
        rax <<= 3;
        rax += *(obj.to_do_tl);
        *((rax + 0x10)) = rsi;
        rcx = rax + 0x10;
        rax = *((rdx + 8));
        *((rcx + 8)) = rax;
        rax = *((rdx + 0x10));
        *((rcx + 0x10)) = rax;
label_3:
        r13++;
        r12 += 0x18;
    } while (*(obj.old) > r13);
    rax = to_do_tl;
    *(obj.old) = r14;
    *(obj.young) = r14;
    *((rax + 8)) = ebx;
    if (rbx == 0) {
        goto label_0;
    }
    ebp = 0;
    while (rbx > rbp) {
        rax = to_do_tl;
        rdx = rbp + rbp*2;
        esi = 0;
        rbp++;
        rdi = *((rax + rdx*8 + 0x18));
        caml_darken ();
    }
    return rax;
label_9:
    rdi = rbp;
    al = caml_page_table_lookup ();
    if ((al & 7) == 0) {
        goto label_10;
    }
    eax = *((rbp - 8));
    if (al == 0xfa) {
        goto label_10;
    }
    if (al == 0xf6) {
        goto label_10;
    }
    if (al == 0xfd) {
        goto label_10;
    }
    rax = final_table;
    rdi = rbp;
    *((rax + r12 + 8)) = rbp;
    al = caml_page_table_lookup ();
    if ((al & 1) != 0) {
        goto label_1;
    }
label_10:
    rdx = r12;
    rdx += *(obj.final_table);
    goto label_2;
label_8:
    rdi = *(rdx);
    rsi = r14 * 3;
    r14++;
    rax = rsi*8;
    *((rcx + rsi*8)) = rdi;
    rsi = *((rdx + 8));
    *((rax + rcx + 8)) = rsi;
    rdx = *((rdx + 0x10));
    *((rax + rcx + 0x10)) = rdx;
    goto label_3;
label_6:
    *(obj.to_do_hd) = rax;
    *(obj.to_do_tl) = rax;
    goto label_4;
label_7:
    rax = to_do_tl;
    *(obj.old) = 0;
    *(obj.young) = 0;
    *((rax + 8)) = 0;
    goto label_0;
label_5:
    edi = "out of memory";
    return caml_fatal_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42edd0 */
#include <stdint.h>
 
uint64_t caml_input_value_from_block (uint32_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = rdi + 4;
    *(obj.intern_input) = rdi;
    *(obj.intern_input_malloced) = 0;
    *(obj.intern_src) = rax;
    edx = *(rdi);
    r8d = *((rax - 1));
    rdx <<= 0x18;
    r8 += rdx;
    edx = *((rax - 3));
    eax = *((rax - 2));
    edx <<= 0x10;
    eax <<= 8;
    rcx = (int64_t) edx;
    rax = (int64_t) eax;
    rdx = r8 + rcx;
    rax = rdx + rax;
    if (eax == 0x8495a6be) {
        rdi += 8;
        *(obj.intern_src) = rdi;
        eax = *((rdi - 4));
        edx = *((rdi - 1));
        rax <<= 0x18;
        rax = rdx + rax + 0x14;
        edx = *((rdi - 3));
        edx <<= 0x10;
        rdx = (int64_t) edx;
        rdx = rax + rdx;
        eax = *((rdi - 2));
        eax <<= 8;
        rax = (int64_t) eax;
        rax = rdx + rax;
        if (rax > rsi) {
            goto label_0;
        }
        void (*0x42ed20)() ();
    }
    edi = "input_value_from_block: bad object";
    caml_failwith ();
label_0:
    edi = "input_value_from_block: bad block length";
    return caml_failwith ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a300 */
#include <stdint.h>
 
int64_t camlBuffer_resize_94 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    *(rsp) = rdi;
    rsi = *((rdi + 0x10));
label_0:
    r15 -= 0x10;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    rax = r15 + 8;
    *((rsp + 0x10)) = rax;
    *((rax - 8)) = 0x400;
    *(rax) = rsi;
    do {
        rdx = *(rax);
        rsi = *((rdi + 8));
        rsi = rsi + rbx - 1;
        if (rsi <= rdx) {
            goto label_2;
        }
        rsi = *(rax);
        rsi >>= 1;
        rsi = rsi*4 + 1;
        *(rax) = rsi;
    } while (1);
label_2:
    rsi = *(reloc.camlSys);
    rdx = *((rsi + 0x28));
    rsi = *(rax);
    if (rsi > rdx) {
        rsi = *(reloc.camlSys);
        rsi = *((rsi + 0x28));
        rdi = *((rdi + 8));
        rbx = rdi + rbx - 1;
        if (rbx <= rsi) {
            rbx = *(reloc.camlSys);
            rbx = *((rbx + 0x28));
            *(rax) = rbx;
        } else {
            rax = *(loc.camlBuffer__23);
            camlPervasives_failwith_38 ();
        }
    }
    rax = *((rsp + 0x10));
    rdi = *(rax);
    rax = *(reloc.caml_create_string);
    rax = caml_c_call ();
    rdi = rax;
    *((rsp + 8)) = rdi;
    rax = *(rsp);
    rdx = *((rax + 8));
    rsi = 1;
    rbx = 1;
    rax = *(rax);
    camlString_blit_84 ();
    rbx = *(rsp);
    rdi = *(rsp);
    rsi = *((rsp + 8));
    caml_modify ();
    rax = *((rsp + 0x10));
    rax = *(rax);
    *((rbx + 0x10)) = rax;
    rax = 1;
    return rax;
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42add0 */
#include <stdint.h>
 
int64_t caml_array_unsafe_get_float (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = caml_young_ptr;
    rsi >>= 1;
    rbx = *((rdi + rsi*8));
    rdx = rax - 0x10;
    *(obj.caml_young_ptr) = rdx;
    if (rdx < *(obj.caml_young_limit)) {
        *(obj.caml_young_ptr) = rax;
        caml_minor_collection ();
        rdx = caml_young_ptr;
        rdx -= 0x10;
        *(obj.caml_young_ptr) = rdx;
    }
    *(rdx) = 0x7fd;
    rax = rdx + 8;
    *((rdx + 8)) = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4246f0 */
#include <stdint.h>
 
void caml_register_global_root (int64_t arg1) {
    rdi = arg1;
    rsi = rdi;
    edi = caml_global_roots;
    return caml_insert_global_root ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b420 */
#include <stdint.h>
 
int64_t camlUnix_fun_1733 (void) {
    rdi = rax;
    rax = *(reloc.unix_umask);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4249e0 */
#include <stdint.h>
 
uint8_t caml_remove_generational_global_root (uint32_t arg1) {
    rdi = arg1;
    rbx = rdi;
    rdi = *(rdi);
    if ((dil & 1) == 0) {
        if (rdi < *(obj.caml_young_end)) {
            if (rdi <= *(obj.caml_young_start)) {
                goto label_0;
            }
            rsi = rbx;
            edi = caml_global_roots_young;
            void (*0x4247a0)() ();
        }
label_0:
        al = caml_page_table_lookup ();
        if ((al & 1) != 0) {
            goto label_1;
        }
    }
    return al;
label_1:
    rsi = rbx;
    edi = caml_global_roots_old;
    return caml_delete_global_root ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x412f40 */
#include <stdint.h>
 
int64_t camlArray_fill_114 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, signed int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r12 = rsi;
    if (rbx < 1) {
        goto label_0;
    }
    if (rdi < 1) {
        goto label_0;
    }
    rax = *((rbp - 8));
    rax >>= 9;
    rax |= 1;
    rax -= rdi;
    rax++;
    if (rbx > rax) {
        goto label_0;
    }
    r13 = rbx;
    rbx = rbx + rdi - 3;
    if (r13 > rbx) {
        goto label_1;
    }
    do {
        rax = *((rbp - 8));
        if (rax != 0xfe) {
            rax = rbp + r13*4 - 4;
            rdi = rax;
            rsi = r12;
            caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [r12]");
            __asm ("movlpd qword [rbp + r13*4 - 4], xmm0");
        }
        rdi = r13;
        rax = r13;
        rax += 2;
        r13 = rax;
    } while (rdi != rbx);
label_1:
    rax = 1;
    return rax;
label_0:
    rax = *(loc.camlArray__26);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429c60 */
#include <stdint.h>
 
int64_t caml_int64_add (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = *((rsi + 8));
    rax += *((rdi + 8));
    rdi = rax;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40aed0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1649 (void) {
    rdi = rax;
    rax = *(reloc.unix_getegid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b1e0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1697 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_mkfifo);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40aab0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1882 (void) {
    rdi = rax;
    rax = *(reloc.unix_close);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429d40 */
#include <stdint.h>
 
void caml_int32_shift_left (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    edi = *((rdi + 8));
    rcx = rsi;
    rcx >>= 1;
    edi <<= cl;
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4098e0 */
#include <stdint.h>
 
int64_t loc_caml_startup_code_begin (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    camlPervasives_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlArray_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlList_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlChar_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlString_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlSys_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlHashtbl_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlBuffer_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlPrintf_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlCallback_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlUnix_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlUnixLabels_code_begin ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlSource_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    camlStd_exit_entry ();
    rax = *(reloc.caml_globals_inited);
    *(rax)++;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416290 */
#include <stdint.h>
 
int64_t camlList_entry (void) {
    rbx = *(loc.camlList__38);
    rax = *(reloc.camlList);
    *((rax + 0x148)) = rbx;
    rbx = *(loc.camlList__37);
    rax = *(reloc.camlList);
    *(rax) = rbx;
    rbx = *(loc.camlList__36);
    rax = *(reloc.camlList);
    *((rax + 8)) = rbx;
    rbx = *(loc.camlList__35);
    rax = *(reloc.camlList);
    *((rax + 0x10)) = rbx;
    rbx = *(loc.camlList__34);
    rax = *(reloc.camlList);
    *((rax + 0x18)) = rbx;
    rax = *(reloc.camlPervasives);
    rbx = *((rax + 0xa8));
    rax = *(reloc.camlList);
    *((rax + 0x28)) = rbx;
    rbx = *(loc.camlList__33);
    rax = *(reloc.camlList);
    *((rax + 0x30)) = rbx;
    rbx = *(loc.camlList__32);
    rax = *(reloc.camlList);
    *((rax + 0x20)) = rbx;
    rbx = *(loc.camlList__31);
    rax = *(reloc.camlList);
    *((rax + 0x40)) = rbx;
    rax = *(reloc.camlList);
    rbx = *((rax + 0x40));
    rax = *(reloc.camlList);
    *((rax + 0x38)) = rbx;
    rbx = *(loc.camlList__30);
    rax = *(reloc.camlList);
    *((rax + 0x50)) = rbx;
    rbx = *(loc.camlList__29);
    rax = *(reloc.camlList);
    *((rax + 0x58)) = rbx;
    rbx = *(loc.camlList__28);
    rax = *(reloc.camlList);
    *((rax + 0x48)) = rbx;
    rbx = *(loc.camlList__27);
    rax = *(reloc.camlList);
    *((rax + 0x60)) = rbx;
    rbx = *(loc.camlList__26);
    rax = *(reloc.camlList);
    *((rax + 0x68)) = rbx;
    rbx = *(loc.camlList__25);
    rax = *(reloc.camlList);
    *((rax + 0x78)) = rbx;
    rbx = *(loc.camlList__24);
    rax = *(reloc.camlList);
    *((rax + 0x80)) = rbx;
    rbx = *(loc.camlList__23);
    rax = *(reloc.camlList);
    *((rax + 0x70)) = rbx;
    rbx = *(loc.camlList__22);
    rax = *(reloc.camlList);
    *((rax + 0x88)) = rbx;
    rbx = *(loc.camlList__21);
    rax = *(reloc.camlList);
    *((rax + 0x90)) = rbx;
    rbx = *(loc.camlList__20);
    rax = *(reloc.camlList);
    *((rax + 0x98)) = rbx;
    rbx = *(loc.camlList__19);
    rax = *(reloc.camlList);
    *((rax + 0xa0)) = rbx;
    rbx = *(loc.camlList__18);
    rax = *(reloc.camlList);
    *((rax + 0xa8)) = rbx;
    rbx = *(loc.camlList__17);
    rax = *(reloc.camlList);
    *((rax + 0xb0)) = rbx;
    rbx = *(loc.camlList__16);
    rax = *(reloc.camlList);
    *((rax + 0xb8)) = rbx;
    rbx = *(loc.camlList__15);
    rax = *(reloc.camlList);
    *((rax + 0xc0)) = rbx;
    rbx = *(loc.camlList__14);
    rax = *(reloc.camlList);
    *((rax + 0xe8)) = rbx;
    rbx = *(loc.camlList__13);
    rax = *(reloc.camlList);
    *((rax + 0xf0)) = rbx;
    rbx = *(loc.camlList__12);
    rax = *(reloc.camlList);
    *((rax + 0xf8)) = rbx;
    rbx = *(loc.camlList__11);
    rax = *(reloc.camlList);
    *((rax + 0x100)) = rbx;
    rbx = *(loc.camlList__10);
    rax = *(reloc.camlList);
    *((rax + 0x108)) = rbx;
    rbx = *(loc.camlList__9);
    rax = *(reloc.camlList);
    *((rax + 0x110)) = rbx;
    rbx = *(loc.camlList__8);
    rax = *(reloc.camlList);
    *((rax + 0xc8)) = rbx;
    rbx = *(loc.camlList__7);
    rax = *(reloc.camlList);
    *((rax + 0xd8)) = rbx;
    rax = *(reloc.camlList);
    rbx = *((rax + 0xd8));
    rax = *(reloc.camlList);
    *((rax + 0xd0)) = rbx;
    rbx = *(loc.camlList__6);
    rax = *(reloc.camlList);
    *((rax + 0xe0)) = rbx;
    rbx = *(loc.camlList__5);
    rax = *(reloc.camlList);
    *((rax + 0x118)) = rbx;
    rbx = *(loc.camlList__4);
    rax = *(reloc.camlList);
    *((rax + 0x120)) = rbx;
    rbx = *(loc.camlList__3);
    rax = *(reloc.camlList);
    *((rax + 0x140)) = rbx;
    rbx = *(loc.camlList__2);
    rax = *(reloc.camlList);
    *((rax + 0x150)) = rbx;
    rbx = *(loc.camlList__1);
    rax = *(reloc.camlList);
    *((rax + 0x130)) = rbx;
    rax = *(reloc.camlList);
    rbx = *((rax + 0x130));
    rax = *(reloc.camlList);
    *((rax + 0x128)) = rbx;
    rax = *(reloc.camlList);
    rbx = *((rax + 0x130));
    rax = *(reloc.camlList);
    *((rax + 0x138)) = rbx;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416810 */
#include <stdint.h>
 
int64_t camlChar_entry (void) {
    rbx = *(loc.camlChar__5);
    rax = *(reloc.camlChar);
    *(rax) = rbx;
    rbx = *(loc.camlChar__4);
    rax = *(reloc.camlChar);
    *((rax + 8)) = rbx;
    rbx = *(loc.camlChar__3);
    rax = *(reloc.camlChar);
    *((rax + 0x10)) = rbx;
    rbx = *(loc.camlChar__2);
    rax = *(reloc.camlChar);
    *((rax + 0x18)) = rbx;
    rbx = *(loc.camlChar__1);
    rax = *(reloc.camlChar);
    *((rax + 0x20)) = rbx;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4176d0 */
#include <stdint.h>
 
int64_t camlString_entry (void) {
    rbx = *(loc.camlString__24);
    rax = *(reloc.camlString);
    *(rax) = rbx;
    rbx = *(loc.camlString__23);
    rax = *(reloc.camlString);
    *((rax + 8)) = rbx;
    rbx = *(loc.camlString__22);
    rax = *(reloc.camlString);
    *((rax + 0x10)) = rbx;
    rbx = *(loc.camlString__21);
    rax = *(reloc.camlString);
    *((rax + 0x18)) = rbx;
    rbx = *(loc.camlString__20);
    rax = *(reloc.camlString);
    *((rax + 0x20)) = rbx;
    rbx = *(loc.camlString__19);
    rax = *(reloc.camlString);
    *((rax + 0x30)) = rbx;
    rbx = *(loc.camlString__18);
    rax = *(reloc.camlString);
    *((rax + 0x28)) = rbx;
    rbx = *(loc.camlString__17);
    rax = *(reloc.camlString);
    *((rax + 0x38)) = rbx;
    rbx = *(loc.camlString__16);
    rax = *(reloc.camlString);
    *((rax + 0xa0)) = rbx;
    rbx = *(loc.camlString__15);
    rax = *(reloc.camlString);
    *((rax + 0x78)) = rbx;
    rbx = *(loc.camlString__14);
    rax = *(reloc.camlString);
    *((rax + 0x80)) = rbx;
    rbx = *(loc.camlString__13);
    rax = *(reloc.camlString);
    *((rax + 0xa8)) = rbx;
    rbx = *(loc.camlString__12);
    rax = *(reloc.camlString);
    *((rax + 0x88)) = rbx;
    rbx = *(loc.camlString__11);
    rax = *(reloc.camlString);
    *((rax + 0x90)) = rbx;
    rbx = *(loc.camlString__10);
    rax = *(reloc.camlString);
    *((rax + 0xb0)) = rbx;
    rbx = *(loc.camlString__9);
    rax = *(reloc.camlString);
    *((rax + 0x40)) = rbx;
    rbx = *(loc.camlString__8);
    rax = *(reloc.camlString);
    *((rax + 0x50)) = rbx;
    rbx = *(loc.camlString__7);
    rax = *(reloc.camlString);
    *((rax + 0xb8)) = rbx;
    rbx = *(loc.camlString__6);
    rax = *(reloc.camlString);
    *((rax + 0x48)) = rbx;
    rbx = *(loc.camlString__5);
    rax = *(reloc.camlString);
    *((rax + 0x58)) = rbx;
    rbx = *(loc.camlString__4);
    rax = *(reloc.camlString);
    *((rax + 0x68)) = rbx;
    rbx = *(loc.camlString__3);
    rax = *(reloc.camlString);
    *((rax + 0x60)) = rbx;
    rbx = *(loc.camlString__2);
    rax = *(reloc.camlString);
    *((rax + 0x70)) = rbx;
    rbx = *(loc.camlString__1);
    rax = *(reloc.camlString);
    *((rax + 0x98)) = rbx;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417970 */
#include <stdint.h>
 
int64_t camlSys_entry (void) {
    rdi = 1;
    rax = *(reloc.caml_sys_get_argv);
    rax = caml_c_call ();
    rdi = *((rax + 8));
    rbx = *(rax);
    rax = *(reloc.camlSys);
    *((rax + 8)) = rbx;
    rax = *(reloc.camlSys);
    *(rax) = rdi;
    rdi = 1;
    rax = *(reloc.caml_sys_get_config);
    rax = caml_c_call ();
    rdi = *((rax + 8));
    rbx = *(rax);
    rax = *(reloc.camlSys);
    *((rax + 0x18)) = rbx;
    rax = *(reloc.camlSys);
    *((rax + 0x20)) = rdi;
    rax = *(reloc.camlSys);
    rcx = *((rax + 0x20));
    rcx += 0xffffffffffffffec;
    rcx >>= 1;
    rbx = 2;
    rbx <<= cl;
    rbx -= 3;
    rbx += 2;
    rax = *(reloc.camlSys);
    *((rax + 0x30)) = rbx;
    rax = *(reloc.camlSys);
    rbx = *((rax + 0x30));
    rbx >>= 1;
    rax = *(reloc.camlSys);
    rdx = *((rax + 0x20));
    rdx >>= 1;
    rax = rdx;
    rdx += 7;
    __asm ("cmovns rdx, rax");
    rdx >>= 3;
    rdx <<= 1;
    rdx *= rbx;
    rdx -= 3;
    rdx += 2;
    rax = *(reloc.camlSys);
    *((rax + 0x28)) = rdx;
    caml_alloc3 ();
    rax = r15 + 8;
    *((rax - 8)) = 0x400;
    *(rax) = 1;
    rbx = *(reloc.camlSys);
    *((rbx + 0x10)) = rax;
    rdi = *(loc.camlSys__4);
    rbx = *(reloc.camlSys);
    *((rbx + 0x38)) = rdi;
    rbx = *(reloc.camlSys);
    *((rbx + 0x40)) = 0xffffffffffffffff;
    rbx = *(reloc.camlSys);
    *((rbx + 0x48)) = 0xfffffffffffffffd;
    rbx = *(reloc.camlSys);
    *((rbx + 0x50)) = 0xfffffffffffffffb;
    rbx = *(reloc.camlSys);
    *((rbx + 0x58)) = 0xfffffffffffffff9;
    rbx = *(reloc.camlSys);
    *((rbx + 0x60)) = 0xfffffffffffffff7;
    rbx = *(reloc.camlSys);
    *((rbx + 0x68)) = 0xfffffffffffffff5;
    rbx = *(reloc.camlSys);
    *((rbx + 0x70)) = 0xfffffffffffffff3;
    rbx = *(reloc.camlSys);
    *((rbx + 0x78)) = 0xfffffffffffffff1;
    rbx = *(reloc.camlSys);
    *((rbx + 0x80)) = 0xffffffffffffffef;
    rbx = *(reloc.camlSys);
    *((rbx + 0x88)) = 0xffffffffffffffed;
    rbx = *(reloc.camlSys);
    *((rbx + 0x90)) = 0xffffffffffffffeb;
    rbx = *(reloc.camlSys);
    *((rbx + 0x98)) = 0xffffffffffffffe9;
    rbx = *(reloc.camlSys);
    *((rbx + 0xa0)) = 0xffffffffffffffe7;
    rbx = *(reloc.camlSys);
    *((rbx + 0xa8)) = 0xffffffffffffffe5;
    rbx = *(reloc.camlSys);
    *((rbx + 0xb0)) = 0xffffffffffffffe3;
    rbx = *(reloc.camlSys);
    *((rbx + 0xb8)) = 0xffffffffffffffe1;
    rbx = *(reloc.camlSys);
    *((rbx + 0xc0)) = 0xffffffffffffffdf;
    rbx = *(reloc.camlSys);
    *((rbx + 0xc8)) = 0xffffffffffffffdd;
    rbx = *(reloc.camlSys);
    *((rbx + 0xd0)) = 0xffffffffffffffdb;
    rbx = *(reloc.camlSys);
    *((rbx + 0xd8)) = 0xffffffffffffffd9;
    rbx = *(reloc.camlSys);
    *((rbx + 0xe0)) = 0xffffffffffffffd7;
    rbx = rax + 0x10;
    *((rbx - 8)) = 0x400;
    rax = *(loc.camlSys__3);
    *(rbx) = rax;
    rax = *(reloc.camlSys);
    *((rax + 0xe8)) = rbx;
    rbx = *(loc.camlSys__2);
    rax = *(reloc.camlSys);
    *((rax + 0xf0)) = rbx;
    rbx = *(loc.camlSys__1);
    rax = *(reloc.camlSys);
    *((rax + 0xf8)) = rbx;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434de8 */
#include <stdint.h>
 
int64_t caml_alloc3 (int64_t arg_8h, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        r15 -= 0x20;
        if (r15 >= *(obj.caml_young_limit)) {
            return;
        }
        rax = *(rsp);
        *(obj.caml_last_return_address) = rax;
        rax = rsp + 8;
        *(obj.caml_bottom_of_stack) = rax;
        fcn_00434c4b (rdi, rsi, rdx, rcx, r8, r9);
        caml_alloc3 ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e800 */
#include <stdint.h>
 
int64_t camlPrintf_entry (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = *(loc.camlPrintf__38);
    *(rsp) = rdi;
    rax = 0x28;
    caml_allocN ();
    rbx = r15 + 8;
    *((rbx - 8)) = 0x10f7;
    rax = *(reloc.caml_curry2);
    *(rbx) = rax;
    *((rbx + 8)) = 5;
    rax = *(reloc.camlPrintf__add_int_index_68);
    *((rbx + 0x10)) = rax;
    *((rbx + 0x18)) = rdi;
    rax = 3;
    rdi = *(rbx);
    rax = void (*rdi)(uint64_t) (rbx);
    rcx = rax;
    rax = 0xe8;
    caml_allocN ();
    rbx = r15 + 8;
    *((rbx - 8)) = 0xcf7;
    rax = *(reloc.camlPrintf__index_of_literal_position_72);
    *(rbx) = rax;
    *((rbx + 8)) = 3;
    rax = *(rsp);
    *((rbx + 0x10)) = rax;
    rdx = *(loc.camlPrintf__37);
    rsi = rbx + 0x20;
    *((rsi - 8)) = 0xcf7;
    rdi = *(reloc.camlPrintf__to_string_82);
    *(rsi) = rdi;
    *((rsi + 8)) = 3;
    *((rsi + 0x10)) = rdx;
    rdi = rbx + 0x40;
    *((rdi - 8)) = 0x1800;
    *(rdi) = rax;
    rax = *((rsp + 8));
    *((rdi + 8)) = rax;
    *((rdi + 0x10)) = rcx;
    *((rdi + 0x18)) = rbx;
    *((rdi + 0x20)) = rdx;
    *((rdi + 0x28)) = rsi;
    rax = *(reloc.camlPrintf);
    *((rax + 0x58)) = rdi;
    rdi = *(loc.camlPrintf__36);
    rax = *(reloc.camlPrintf);
    *((rax + 0x60)) = rdi;
    rdi = *(loc.camlPrintf__35);
    rax = *(reloc.camlPrintf);
    *((rax + 0x68)) = rdi;
    rdi = *(loc.camlPrintf__34);
    rax = *(reloc.camlPrintf);
    *((rax + 0x70)) = rdi;
    rdi = *(loc.camlPrintf__33);
    rax = *(reloc.camlPrintf);
    *((rax + 0x78)) = rdi;
    rdi = *(loc.camlPrintf__32);
    rax = *(reloc.camlPrintf);
    *((rax + 0x80)) = rdi;
    rdi = *(loc.camlPrintf__31);
    rax = *(reloc.camlPrintf);
    *((rax + 0x88)) = rdi;
    rdi = *(loc.camlPrintf__30);
    rax = *(reloc.camlPrintf);
    *((rax + 0x90)) = rdi;
    rdi = *(loc.camlPrintf__29);
    rax = *(reloc.camlPrintf);
    *((rax + 0x98)) = rdi;
    rdi = *(loc.camlPrintf__28);
    rax = *(reloc.camlPrintf);
    *((rax + 0xa0)) = rdi;
    rdi = *(loc.camlPrintf__27);
    rax = *(reloc.camlPrintf);
    *((rax + 0xa8)) = rdi;
    rdi = *(loc.camlPrintf__26);
    rax = *(reloc.camlPrintf);
    *((rax + 0xb0)) = rdi;
    rdi = *(loc.camlPrintf__25);
    rax = *(reloc.camlPrintf);
    *((rax + 0xb8)) = rdi;
    rdi = *(loc.camlPrintf__24);
    rax = *(reloc.camlPrintf);
    *((rax + 0xc0)) = rdi;
    rdi = *(loc.camlPrintf__23);
    rax = *(reloc.camlPrintf);
    *((rax + 0xc8)) = rdi;
    rdi = *(loc.camlPrintf__22);
    rax = *(reloc.camlPrintf);
    *((rax + 0xd0)) = rdi;
    rdi = *(loc.camlPrintf__21);
    rax = *(reloc.camlPrintf);
    *((rax + 0xd8)) = rdi;
    rdi = *(loc.camlPrintf__20);
    rax = *(reloc.camlPrintf);
    *((rax + 0xe0)) = rdi;
    rdi = *(loc.camlPrintf__19);
    rax = *(reloc.camlPrintf);
    *((rax + 0xe8)) = rdi;
    rdi = *(loc.camlPrintf__18);
    rax = *(reloc.camlPrintf);
    *((rax + 0xf0)) = rdi;
    rdi = *(loc.camlPrintf__17);
    rax = *(reloc.camlPrintf);
    *((rax + 0xf8)) = rdi;
    rdi = *(loc.camlPrintf__16);
    rax = *(reloc.camlPrintf);
    *((rax + 0x100)) = rdi;
    rsi = *(loc.camlPrintf__15);
    rdi = rbx + 0x78;
    *((rdi - 8)) = 0x10f7;
    rax = *(reloc.caml_curry2);
    *(rdi) = rax;
    *((rdi + 8)) = 5;
    rax = *(reloc.camlPrintf__fun_630);
    *((rdi + 0x10)) = rax;
    *((rdi + 0x18)) = rsi;
    rax = *(reloc.camlPrintf);
    *((rax + 0x108)) = rdi;
    rdi = *(loc.camlPrintf__14);
    rax = *(reloc.camlPrintf);
    *((rax + 0x110)) = rdi;
    rdi = *(loc.camlPrintf__13);
    rax = *(reloc.camlPrintf);
    *((rax + 0x118)) = rdi;
    rdi = *(loc.camlPrintf__12);
    rax = *(reloc.camlPrintf);
    *((rax + 0x30)) = rdi;
    rdi = *(loc.camlPrintf__11);
    rax = *(reloc.camlPrintf);
    *((rax + 0x18)) = rdi;
    rdi = *(loc.camlPrintf__10);
    rax = *(reloc.camlPrintf);
    *(rax) = rdi;
    rdi = *(loc.camlPrintf__9);
    rax = *(reloc.camlPrintf);
    *((rax + 8)) = rdi;
    rdi = *(loc.camlPrintf__8);
    rax = *(reloc.camlPrintf);
    *((rax + 0x10)) = rdi;
    rdi = *(loc.camlPrintf__7);
    rax = *(reloc.camlPrintf);
    *((rax + 0x40)) = rdi;
    rdi = *(loc.camlPrintf__6);
    rax = *(reloc.camlPrintf);
    *((rax + 0x28)) = rdi;
    rdi = *(loc.camlPrintf__5);
    rax = *(reloc.camlPrintf);
    *((rax + 0x120)) = rdi;
    rdi = *(loc.camlPrintf__4);
    rax = *(reloc.camlPrintf);
    *((rax + 0x128)) = rdi;
    rdi = *(loc.camlPrintf__3);
    rax = *(reloc.camlPrintf);
    *((rax + 0x130)) = rdi;
    rdi = *(loc.camlPrintf__2);
    rax = *(reloc.camlPrintf);
    *((rax + 0x38)) = rdi;
    rax = *(reloc.camlPrintf);
    rdi = *((rax + 0x38));
    rax = *(reloc.camlPrintf);
    *((rax + 0x48)) = rdi;
    rdi = *(loc.camlPrintf__1);
    rax = *(reloc.camlPrintf);
    *((rax + 0x20)) = rdi;
    rax = *(reloc.camlPrintf);
    rax = *((rax + 0x58));
    rdi = *(reloc.camlPrintf);
    r9 = *((rdi + 0xd0));
    rdi = *(reloc.camlPrintf);
    r8 = *((rdi + 0xa8));
    rdi = *(reloc.camlPrintf);
    rcx = *((rdi + 0xc0));
    rdi = *(reloc.camlPrintf);
    rdx = *((rdi + 0x110));
    rdi = *(reloc.camlPrintf);
    rsi = *((rdi + 0xe8));
    rdi = rbx + 0xa0;
    *((rdi - 8)) = 0x1400;
    *(rdi) = r9;
    *((rdi + 8)) = r8;
    *((rdi + 0x10)) = rcx;
    *((rdi + 0x18)) = rdx;
    *((rdi + 0x20)) = rsi;
    rsi = rbx + 0xd0;
    *((rsi - 8)) = 0x800;
    *(rsi) = rax;
    *((rsi + 8)) = rdi;
    rbx = *(rsi);
    rax = 0x40;
    caml_allocN ();
    rdi = r15 + 8;
    *((rdi - 8)) = 0x1000;
    rax = *(rbx);
    *(rdi) = rax;
    rax = *((rbx + 0x10));
    *((rdi + 8)) = rax;
    rax = *((rbx + 0x20));
    *((rdi + 0x10)) = rax;
    rax = *((rbx + 0x28));
    *((rdi + 0x18)) = rax;
    rbx = rdi + 0x28;
    *((rbx - 8)) = 0x800;
    *(rbx) = rdi;
    rax = *((rsi + 8));
    *((rbx + 8)) = rax;
    rax = *(reloc.camlPrintf);
    *((rax + 0x50)) = rbx;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ea00 */
#include <stdint.h>
 
int64_t loc_camlUnixLabels_code_begin (void) {
    rax = *(reloc.camlUnix);
    rdi = *(rax);
    rbx = *(reloc.camlUnixLabels);
    *(rbx) = rdi;
    rdi = *((rax + 8));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 8)) = rdi;
    rdi = *((rax + 0x10));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x10)) = rdi;
    rdi = *((rax + 0x18));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x18)) = rdi;
    rdi = *((rax + 0x20));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x20)) = rdi;
    rdi = *((rax + 0x28));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x28)) = rdi;
    rdi = *((rax + 0x30));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x30)) = rdi;
    rdi = *((rax + 0x38));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x38)) = rdi;
    rdi = *((rax + 0x40));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x40)) = rdi;
    rdi = *((rax + 0x48));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x48)) = rdi;
    rdi = *((rax + 0x50));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x50)) = rdi;
    rdi = *((rax + 0x58));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x58)) = rdi;
    rdi = *((rax + 0x60));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x60)) = rdi;
    rdi = *((rax + 0x68));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x68)) = rdi;
    rdi = *((rax + 0x70));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x70)) = rdi;
    rdi = *((rax + 0x78));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x78)) = rdi;
    rdi = *((rax + 0x80));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x80)) = rdi;
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x88)) = 1;
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x90)) = 3;
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x98)) = 5;
    rdi = *((rax + 0xa0));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xa0)) = rdi;
    rdi = *((rax + 0xa8));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xa8)) = rdi;
    rdi = *((rax + 0xb0));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xb0)) = rdi;
    rdi = *((rax + 0xb8));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xb8)) = rdi;
    rdi = *((rax + 0xc0));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xc0)) = rdi;
    rdi = *((rax + 0xc8));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xc8)) = rdi;
    rdi = *((rax + 0xd0));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xd0)) = rdi;
    rdi = *((rax + 0xd8));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xd8)) = rdi;
    rdi = *((rax + 0xe0));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xe0)) = rdi;
    rdi = *((rax + 0xe8));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xe8)) = rdi;
    rdi = *((rax + 0xf0));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xf0)) = rdi;
    rdi = *((rax + 0xf8));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0xf8)) = rdi;
    rdi = *((rax + 0x100));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x100)) = rdi;
    rdi = *((rax + 0x108));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x108)) = rdi;
    rdi = *((rax + 0x110));
    rbx = *(reloc.camlUnixLabels);
    *((rbx + 0x110)) = rdi;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a670 */
#include <stdint.h>
 
int64_t camlSource_entry (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9) {
    int64_t var_8h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    rbx = .got;
    rax = *(reloc.camlSource);
    *(rax) = rbx;
    rax = *(reloc.camlSys);
    rax = *(rax);
    rax = *((rax - 8));
    rax >>= 9;
    rax |= 1;
    if (rax > 3) {
        rax = *(reloc.camlSys);
        rax = *(rax);
        rdi = *((rax + 8));
        rax = *(reloc.caml_int_of_string);
        rax = caml_c_call ();
        *(rsp) = rax;
    } else {
        rax = 3;
        *(rsp) = rax;
    }
    rax = *(loc.camlSource__1);
    rax = camlPrintf_printf_425 ();
    *((rsp + 8)) = rax;
    rax = 7;
    rbx = *(rsp);
    rax = camlSource_ack_58 ();
    rbx = rax;
    rax = *(rsp);
    rdi = *((rsp + 8));
    caml_apply2 ();
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f760 */
#include <stdint.h>
 
void caml_sys_time (void) {
    edi = 0;
    rsi = rsp;
    getrusage ();
    __asm ("cvtsi2sd xmm1, qword [rsp + 8]");
    __asm ("cvtsi2sd xmm0, qword [rsp]");
    xmm2 = *(0x00435b50);
    __asm ("divsd xmm1, xmm2");
    __asm ("addsd xmm0, xmm1");
    __asm ("cvtsi2sd xmm1, qword [rsp + 0x10]");
    __asm ("addsd xmm0, xmm1");
    __asm ("cvtsi2sd xmm1, qword [rsp + 0x18]");
    __asm ("divsd xmm1, xmm2");
    __asm ("addsd xmm0, xmm1");
    caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4248b0 */
#include <stdint.h>
 
int64_t caml_modify_generational_global_root (uint32_t arg2, uint32_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    rax = rsi;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    eax &= 1;
    rbx = rsi;
    rdi = *(rdi);
    if (eax == 0) {
        if (rsi < *(obj.caml_young_end)) {
            if (rsi <= *(obj.caml_young_start)) {
                goto label_2;
            }
            if ((dil & 1) == 0) {
                goto label_3;
            }
label_1:
            if (rbx <= *(obj.caml_young_start)) {
                goto label_4;
            }
            rsi = rbp;
            edi = caml_global_roots_young;
            rax = caml_insert_global_root ();
        }
    } else {
label_2:
        if ((dil & 1) == 0) {
            if (rax == 0) {
                goto label_0;
            }
            if (rdi >= *(obj.caml_young_end)) {
                goto label_5;
            }
            if (rdi <= *(obj.caml_young_start)) {
                goto label_5;
            }
            rsi = rbp;
            edi = caml_global_roots_young;
            rax = caml_delete_global_root ();
        } else {
            if (rax == 0) {
                goto label_6;
            }
        }
    }
    do {
label_0:
        *(rbp) = rbx;
        rbx = *((rsp + 8));
        rbp = *((rsp + 0x10));
        return rax;
label_5:
        al = caml_page_table_lookup ();
    } while ((al & 1) == 0);
    rsi = rbp;
    edi = caml_global_roots_old;
    caml_delete_global_root ();
    goto label_0;
label_6:
    if (rbx < *(obj.caml_young_end)) {
        goto label_1;
    }
label_4:
    rdi = rbx;
    al = caml_page_table_lookup ();
    if ((al & 1) == 0) {
        goto label_0;
    }
    rsi = rbp;
    edi = caml_global_roots_old;
    caml_insert_global_root ();
    goto label_0;
label_3:
    al = caml_page_table_lookup ();
    if ((al & 1) == 0) {
        goto label_0;
    }
    rsi = rbp;
    edi = caml_global_roots_old;
    caml_delete_global_root ();
    rsi = rbp;
    edi = caml_global_roots_young;
    caml_insert_global_root ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423620 */
#include <stdint.h>
 
uint64_t caml_main (int64_t arg1) {
    int64_t var_8h;
    rdi = arg1;
    rbx = rdi;
    caml_init_ieee_floats ();
    caml_init_custom_operations ();
    rax = getenv ("OCAMLRUNPARAM");
    if (rax == 0) {
        goto label_3;
    }
label_2:
    r13 = rsp + 8;
    r12d = 0x435fa8;
    do {
        eax = *(rbp);
        if (al == 0) {
            goto label_1;
        }
        eax -= 0x4f;
        rbp++;
    } while (al > 0x27);
    eax = (int32_t) al;
    uint64_t (*r12 + rax*8)() ();
label_1:
    rdx = heap_chunk_init;
    rsi = heap_size_init;
    r8 = max_percent_free_init;
    rcx = percent_free_init;
    rdi = minor_heap_init;
    eax = caml_init_gc ();
    edx = 0x100;
    eax = 0;
    esi = caml_atom_table;
    do {
        rcx = (int64_t) eax;
        edi = eax;
        eax++;
        edx--;
        *((rsi + rcx*8)) = rdi;
    } while (edx != 0);
    edx = caml_frame_descriptors_mask;
    esi = caml_atom_table;
    edi = 4;
    eax = caml_page_table_add ();
    if (eax != 0) {
        goto label_4;
    }
    rsi = caml_data_segments;
    ebp = 0;
    r13d = 0x640a58;
    r12d = caml_data_segments;
    if (rsi == 0) {
        goto label_5;
    }
    do {
        rax = (int64_t) ebp;
        edi = 4;
        rax <<= 4;
        rdx = *((rax + r13));
        eax = caml_page_table_add ();
        if (eax != 0) {
            goto label_4;
        }
        ebp++;
        rax = (int64_t) ebp;
        rax <<= 4;
        rsi = *((rax + r12));
    } while (rsi != 0);
label_5:
    rax = *(sym.camlPervasives__loop_162);
    rdx = caml_code_segments;
    rsi = *(loc.caml_startup__code_end);
    *(obj.caml_code_area_start) = rdx;
    *(obj.caml_code_area_end) = rsi;
    if (rax == 0) {
        goto label_6;
    }
    r8 = rsi;
    ecx = 1;
    r10d = 0x640b50;
    r9d = caml_code_segments;
    while (rdi != 0) {
        rsi = rdx;
        rdx = rax;
        r8 = rsi;
        rax = rdi;
        if (rbp <= rax) {
            rax = rdx;
        }
        rdx = (int64_t) ecx;
        rdx <<= 4;
        rdx = *((rdx + r10));
        if (rdx <= r8) {
            rdx = rsi;
        }
        ecx++;
        rsi = (int64_t) ecx;
        rsi <<= 4;
        rdi = *((rsi + r9));
    }
    *(obj.caml_code_area_start) = rax;
    *(obj.caml_code_area_end) = rdx;
label_6:
    caml_init_signals ();
    rbp = *(rbx);
    eax = 0x436cc1;
    edi = proc_self_exe.3682;
    esi = 0x100;
    if (rbp == 0) {
    }
    eax = caml_executable_name ();
    edi = proc_self_exe.3682;
    if (eax != 0) {
        goto label_7;
    }
label_0:
    rsi = rbx;
    caml_sys_init ();
    esi = 0;
    edi = caml_termination_jmpbuf;
    eax = sigsetjmp ();
    if (eax == 0) {
        goto label_8;
    }
    rax = caml_termination_hook;
    if (rax == 0) {
        goto label_9;
    }
    edi = 0;
    void (*rax)() ();
    do {
label_9:
        return rax;
label_8:
        rax = caml_start_program ();
        rdx = rax;
        edx &= 3;
    } while (rdx != 2);
    rdi = rax;
    rdi &= 0xfffffffffffffffc;
    caml_fatal_uncaught_exception ();
label_7:
    rdi = rbp;
    rax = caml_search_exe_in_path ();
    rdi = rax;
    goto label_0;
label_3:
    rax = getenv (0x435f57);
    if (rax == 0) {
        goto label_1;
    }
    goto label_2;
label_4:
    edi = "Fatal error: not enough memory for the initial page table";
    return caml_fatal_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427390 */
#include <stdint.h>
 
uint64_t caml_alloc_table (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    xmm4l = arg1;
    rbx = rdi;
    *((rdi + 0x28)) = rsi;
    rsi = rdx + rsi;
    *((rdi + 0x30)) = rdx;
    rdi = rsi*8;
    rax = caml_stat_alloc ();
    rdi = *(rbx);
    if (rdi != 0) {
        caml_stat_free ();
    }
    rax = *((rbx + 0x28));
    *(rbx) = rbp;
    *((rbx + 0x18)) = rbp;
    rdx = rbp + rax*8;
    rax += *((rbx + 0x30));
    *((rbx + 0x10)) = rdx;
    *((rbx + 0x20)) = rdx;
    rax = rbp + rax*8;
    *((rbx + 8)) = rax;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b370 */
#include <stdint.h>
 
void caml_array_get (int64_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    if (*((rdi - 8)) != 0xfe) {
        void (*0x42b340)() ();
    }
    return caml_array_get_float ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432c20 */
#include <stdint.h>
 
int64_t caml_weak_get (int64_t arg2, uint32_t arg1) {
    uint32_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_70h;
    int64_t var_90h;
    int64_t var_98h;
    rsi = arg2;
    rdi = arg1;
    rax = rsi;
    rax >>= 1;
    rbx = caml_local_roots;
    rax++;
    rdx = rsp + 8;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 2;
    *((rsp + 0x68)) = rdx;
    rdx = rsp + 0x50;
    *((rsp + 0x50)) = rbx;
    *((rsp + 0x70)) = rsp;
    *((rsp + 0x98)) = 0;
    *((rsp + 0x10)) = rdx;
    rdx = rsp + 0x10;
    *((rsp + 0x90)) = 0;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 2;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 0x98;
    *((rsp + 0x28)) = rdx;
    rdx = rsp + 0x90;
    *((rsp + 0x30)) = rdx;
    if (rax == 0) {
        goto label_1;
    }
    rdx = *((rdi - 8));
    rdx >>= 0xa;
    if (rax >= rdx) {
        goto label_1;
    }
    rdi = *((rdi + rax*8));
    eax = 1;
    if (rdi == *(obj.caml_weak_none)) {
        goto label_2;
    }
    edx = caml_gc_phase;
    *((rsp + 0x90)) = rdi;
    while ((dil & 1) != 0) {
label_0:
        esi = 0;
        edi = 1;
        rax = caml_alloc_small ();
        rdx = *((rsp + 0x90));
        *((rsp + 0x98)) = rax;
        *(rax) = rdx;
        rax = *((rsp + 0x98));
label_2:
        *(obj.caml_local_roots) = rbx;
        return rax;
    }
    al = caml_page_table_lookup ();
    if ((al & 1) == 0) {
        goto label_0;
    }
    rdi = *((rsp + 0x90));
    esi = 0;
    caml_darken ();
    goto label_0;
label_1:
    edi = "Weak.get";
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433b40 */
#include <stdint.h>
 
int64_t caml_final_do_strong_roots (int64_t arg1) {
    rdi = arg1;
    r14 = rdi;
    if (*(obj.old) == 0) {
        goto label_1;
    }
    ebp = 0;
    ebx = 0;
    do {
        rax = rbp;
        rax += *(obj.final_table);
        rbx++;
        rbp += 0x18;
        rsi = rax;
        rdi = *(rax);
        void (*r14)() ();
    } while (*(obj.old) > rbx);
label_1:
    r13 = to_do_hd;
    if (r13 == 0) {
        goto label_2;
    }
label_0:
    eax = *((r13 + 8));
    ebx = 0;
    if (eax == 0) {
        goto label_3;
    }
    do {
        rax = rbx * 3;
        rdi = *((rbp + 0x10));
        rbx++;
        r12 = r13 + rax*8 + 0x10;
        rsi = r12;
        void (*r14)() ();
        rdi = *((rbp + 0x18));
        rsi = r12 + 8;
        rbp += 0x18;
        void (*r14)() ();
        rax = *((r13 + 8));
    } while (rax > rbx);
label_3:
    r13 = *(r13);
    if (r13 != 0) {
        goto label_0;
    }
label_2:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41bb90 */
#include <stdint.h>
 
int64_t camlPrintf_add_char_220 (void) {
    rax += 2;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d610 */
#include <stdint.h>
 
uint64_t camlPrintf_incomplete_format_93 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rdi = *((rax + rbx));
    rbx -= rdi;
    rdi = rbx + rbx + 1;
    rbx = 1;
    camlString_sub_74 ();
    rbx = *(loc.camlPrintf__50);
    rax = camlPervasives_$5e_136 ();
    rbx = rax;
    rax = *(loc.camlPrintf__49);
    camlPervasives_$5e_136 ();
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x426080 */
#include <stdint.h>
 
int64_t caml_round_heap_chunk_size (uint32_t arg1) {
    rdi = arg1;
    rax = caml_major_heap_increment;
    rdx = rax;
    eax = 0x2000;
    if (rdi >= rax) {
        rdx = rdi;
    }
    if (rdx > 0x1fff) {
        rax = rdx + 0xfff;
        rax &= 0xfffffffffffff000;
    }
    if (rdi <= rax) {
        return rax;
    }
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429f00 */
#include <stdint.h>
 
uint64_t caml_gt_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    eax = 0;
    __asm ("ucomisd xmm0, qword [rsi]");
    al = (? > ?) ? 1 : 0;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x430a60 */
#include <stdint.h>
 
uint64_t caml_gc_major_slice (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    caml_empty_minor_heap ();
    rdi = rbx;
    rdi >>= 1;
    caml_major_collection_slice ();
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x426900 */
#include <stdint.h>
 
int64_t caml_major_collection_slice (int64_t arg1) {
    int64_t var_10h;
    int64_t var_20h;
    rdi = arg1;
    rbx = rdi;
    if (*(obj.caml_gc_phase) == 2) {
        goto label_11;
    }
label_10:
    rax = caml_percent_free;
    rdx = caml_allocated_words;
    rcx = rax;
    rcx += 0x64;
    if (rcx < 0) {
        goto label_12;
    }
    __asm ("cvtsi2sd xmm2, rcx");
label_6:
    if (rax < 0) {
        goto label_13;
    }
    __asm ("cvtsi2sd xmm1, rax");
label_5:
    if (rdx < 0) {
        goto label_14;
    }
    __asm ("cvtsi2sd xmm0, rdx");
label_4:
    rax = caml_stat_heap_size;
    __asm ("mulsd xmm0, qword [0x00436360]");
    rax >>= 3;
    __asm ("cvtsi2sd xmm3, rax");
    rax = caml_dependent_size;
    __asm ("mulsd xmm0, xmm2");
    __asm ("divsd xmm0, xmm3");
    __asm ("divsd xmm0, xmm1");
    __asm ("mulsd xmm0, qword [0x00436368]");
    if (rax != 0) {
        goto label_15;
    }
    __asm ("xorpd xmm2, xmm2");
    do {
        __asm ("maxsd xmm2, xmm0");
        xmm1 = caml_extra_heap_resources;
        esi = "allocated_words = %lu\n";
        edi = 0x40;
        __asm ("maxsd xmm1, xmm2");
        *(rsp) = xmm1;
        caml_gc_message ();
        xmm1 = *(0x00435b50);
        xmm3 = caml_extra_heap_resources;
        xmm2 = *(0x00436370);
        __asm ("mulsd xmm3, xmm1");
        xmm0 = *(rsp);
        __asm ("ucomisd xmm3, xmm2");
        if (rax >= 0) {
            goto label_16;
        }
        __asm ("cvttsd2si rdx, xmm3");
label_1:
        esi = "extra_heap_resources = %luu\n";
        edi = 0x40;
        *(rsp) = xmm0;
        *((rsp + 0x20)) = xmm1;
        *((rsp + 0x10)) = xmm2;
        caml_gc_message ();
        xmm1 = *((rsp + 0x20));
        xmm0 = *(rsp);
        xmm2 = *((rsp + 0x10));
        __asm ("mulsd xmm1, xmm0");
        __asm ("ucomisd xmm1, xmm2");
        if (rax >= 0) {
            goto label_17;
        }
        __asm ("cvttsd2si rdx, xmm1");
label_0:
        esi = "amount of work to do = %luu\n";
        edi = 0x40;
        *(rsp) = xmm0;
        caml_gc_message ();
        ecx = caml_gc_phase;
        xmm0 = *(rsp);
        if (ecx != 0) {
            goto label_18;
        }
        rax = caml_stat_heap_size;
        rax >>= 3;
        __asm ("cvtsi2sd xmm1, rax");
        rax = caml_percent_free;
        rax += 0x64;
        __asm ("mulsd xmm1, xmm0");
        __asm ("mulsd xmm1, qword [0x00436378]");
        if (rax < 0) {
            goto label_19;
        }
        __asm ("cvtsi2sd xmm0, rax");
label_9:
        __asm ("divsd xmm1, xmm0");
        __asm ("cvttsd2si rbp, xmm1");
        goto label_20;
label_15:
        rcx = caml_dependent_allocated;
        if (rcx < 0) {
            goto label_21;
        }
        __asm ("cvtsi2sd xmm3, rcx");
        __asm ("mulsd xmm2, xmm3");
        if (rax < 0) {
            goto label_22;
        }
label_7:
        __asm ("cvtsi2sd xmm3, rax");
label_8:
        __asm ("divsd xmm2, xmm3");
        __asm ("divsd xmm2, xmm1");
    } while (1);
label_18:
    rax = caml_stat_heap_size;
    rax >>= 3;
    __asm ("cvtsi2sd xmm1, rax");
    __asm ("mulsd xmm1, xmm0");
    __asm ("mulsd xmm1, qword [0x00436380]");
    __asm ("divsd xmm1, qword [0x00436360]");
    __asm ("cvttsd2si rbp, xmm1");
label_20:
    rdx = rbx;
    esi = "ordered work = %ld words\n";
    edi = 0x40;
    caml_gc_message ();
    rdx = rbp;
    esi = "computed work = %ld words\n";
    edi = 0x40;
    caml_gc_message ();
    edx = caml_gc_phase;
    if (rbx == 0) {
        rbx = rbp;
    }
    if (edx != 0) {
        goto label_23;
    }
    rdi = rbx;
    mark_slice ();
    edx = 0;
    esi = 0x436359;
    edi = 2;
    caml_gc_message ();
    if (*(obj.caml_gc_phase) == 2) {
        goto label_24;
    }
    do {
        rax = caml_allocated_words;
        if (rax < 0) {
            goto label_25;
        }
label_2:
        __asm ("cvtsi2sd xmm0, rax");
label_3:
        __asm ("addsd xmm0, qword [obj.caml_stat_major_words]");
        *(obj.caml_allocated_words) = 0;
        rax = rbp;
        *(obj.caml_dependent_allocated) = 0;
        *(obj.caml_extra_heap_resources) = 0;
        *(obj.caml_stat_major_words) = xmm0;
        return rax;
label_17:
        __asm ("subsd xmm1, xmm2");
        rax = 0x8000000000000000;
        __asm ("cvttsd2si rdx, xmm1");
        rdx ^= rax;
        goto label_0;
label_16:
        __asm ("subsd xmm3, xmm2");
        rax = 0x8000000000000000;
        __asm ("cvttsd2si rdx, xmm3");
        rdx ^= rax;
        goto label_1;
label_23:
        rdi = rbx;
        sweep_slice ();
        edx = 0;
        esi = 0x43635b;
        edi = 2;
        caml_gc_message ();
    } while (*(obj.caml_gc_phase) != 2);
label_24:
    caml_compact_heap_maybe ();
    rax = caml_allocated_words;
    if (rax >= 0) {
        goto label_2;
    }
label_25:
    rdx = rax;
    eax &= 1;
    rdx >>= 1;
    rdx |= rax;
    __asm ("cvtsi2sd xmm0, rdx");
    __asm ("addsd xmm0, xmm0");
    goto label_3;
label_14:
    rax = rdx;
    rcx = rdx;
    rax >>= 1;
    ecx &= 1;
    rax |= rcx;
    __asm ("cvtsi2sd xmm0, rax");
    __asm ("addsd xmm0, xmm0");
    goto label_4;
label_13:
    rcx = rax;
    eax &= 1;
    rcx >>= 1;
    rcx |= rax;
    __asm ("cvtsi2sd xmm1, rcx");
    __asm ("addsd xmm1, xmm1");
    goto label_5;
label_12:
    rsi = rcx;
    ecx &= 1;
    rsi >>= 1;
    rsi |= rcx;
    __asm ("cvtsi2sd xmm2, rsi");
    __asm ("addsd xmm2, xmm2");
    goto label_6;
label_21:
    rsi = rcx;
    ecx &= 1;
    rsi >>= 1;
    rsi |= rcx;
    __asm ("cvtsi2sd xmm3, rsi");
    __asm ("addsd xmm3, xmm3");
    __asm ("mulsd xmm2, xmm3");
    if (rax >= 0) {
        goto label_7;
    }
label_22:
    rcx = rax;
    eax &= 1;
    rcx >>= 1;
    rcx |= rax;
    __asm ("cvtsi2sd xmm3, rcx");
    __asm ("addsd xmm3, xmm3");
    goto label_8;
label_19:
    rdx = rax;
    eax &= 1;
    rdx >>= 1;
    rdx |= rax;
    __asm ("cvtsi2sd xmm0, rdx");
    __asm ("addsd xmm0, xmm0");
    goto label_9;
label_11:
    start_cycle ();
    goto label_10;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415320 */
#include <stdint.h>
 
int64_t camlList_hd_64 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rax != 1) {
        rax = *(rax);
        return rax;
    }
    rax = *(loc.camlList__51);
    return camlPervasives_failwith_38 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f260 */
#include <stdint.h>
 
int64_t caml_hash_variant (uint32_t arg1) {
    rdi = arg1;
    edx = 1;
    eax = 1;
    if (*(rdi) == 0) {
        goto label_0;
    }
    do {
        rdx >>= 1;
        eax = *(rdi);
        rdi++;
        edx *= 0xdf;
        edx += eax;
        rdx = (int64_t) edx;
        rdx = rdx + rdx + 1;
    } while (*(rdi) != 0);
    rax = (int64_t) edx;
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ae90 */
#include <stdint.h>
 
int64_t camlUnix_fun_1645 (void) {
    rdi = rax;
    rax = *(reloc.unix_getgroups);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418d20 */
#include <stdint.h>
 
int64_t camlHashtbl_create_79 (void) {
    rbx = rax;
    rax = 3;
    camlPervasives_max_53 ();
    rbx = *(reloc.camlSys);
    rbx = *((rbx + 0x30));
    rax = camlPervasives_min_50 ();
    rsi = 1;
    rdi = rax;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            *(rax) = 1;
            *((rax + 8)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fcb0 */
#include <stdint.h>
 
int64_t camlPervasives_max_53 (void) {
    int64_t var_8h;
    *((rsp + 8)) = rax;
    *(rsp) = rbx;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_greaterequal);
    rax = caml_c_call ();
    if (rax != 1) {
        rax = *((rsp + 8));
        return rax;
    }
    rax = *(rsp);
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fc70 */
#include <stdint.h>
 
int64_t camlPervasives_min_50 (void) {
    int64_t var_8h;
    *((rsp + 8)) = rax;
    *(rsp) = rbx;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_lessequal);
    rax = caml_c_call ();
    if (rax != 1) {
        rax = *((rsp + 8));
        return rax;
    }
    rax = *(rsp);
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417590 */
#include <stdint.h>
 
uint64_t camlString_contains_from_160 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rbx;
    rsi = rdi;
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rdi = *((rax + rbx));
    rbx -= rdi;
    rbx = rbx + rbx + 1;
    if (rdx >= 1) {
        if (rdx > rbx) {
            goto label_0;
        }
        rax = void (*0x4175ec)() ();
        rdi = *(reloc.caml_exn_Not_found);
        rbx = *(rax);
        if (rbx == rdi) {
            rax = 1;
            return rax;
        }
        rax = caml_raise_exn ();
        r14 = rsp;
        rdi = rdx;
        camlString_index_rec_136 ();
        rax = 3;
        return rax;
    }
label_0:
    rax = *(loc.camlString__26);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4245a0 */
#include <stdint.h>
 
void caml_scan_global_roots (int64_t arg1) {
    rdi = arg1;
    esi = caml_global_roots;
    rbx = rdi;
    caml_iterate_global_roots ();
    rdi = rbx;
    esi = caml_global_roots_young;
    caml_iterate_global_roots ();
    rdi = rbx;
    esi = caml_global_roots_old;
    return caml_iterate_global_roots ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d470 */
#include <stdint.h>
 
int64_t camlPrintf_fun_730 (void) {
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40cbf0 */
#include <stdint.h>
 
int64_t camlUnix_create_process_env_940 (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x18)) = rax;
    *((rsp + 0x20)) = rbx;
    *((rsp + 0x28)) = rdi;
    *(rsp) = rsi;
    *((rsp + 8)) = rdx;
    *((rsp + 0x10)) = rcx;
    rdi = 1;
    rax = *(reloc.unix_fork);
    rax = caml_c_call ();
    if (rax != 1) {
        return rax;
    }
    fcn_0040cc48 (rdi, rsi, rdx, rcx, r8, r9);
    rax = 0xff;
    return camlPervasives_exit_350 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40cc48 */
#include <stdint.h>
 
int64_t fcn_0040cc48 (int64_t arg_10h, int64_t arg_18h, int64_t arg_20h, int64_t arg_28h, int64_t arg_30h, int64_t arg_38h) {
    r14 = rsp;
    rax = *((rsp + 0x10));
    rbx = *((rsp + 0x18));
    rdi = *((rsp + 0x20));
    camlUnix_perform_redirections_926 ();
    rdi = *((rsp + 0x28));
    rsi = *((rsp + 0x30));
    rdx = *((rsp + 0x38));
    rax = *(reloc.unix_execvpe);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ca80 */
#include <stdint.h>
 
uint64_t camlUnix_perform_redirections_926 (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    rdi = arg1;
    *(rsp) = rax;
    *((rsp + 8)) = rbx;
    *((rsp + 0x10)) = rdi;
    rax = camlUnix_safe_dup_920 ();
    *((rsp + 0x18)) = rax;
    rax = *((rsp + 8));
    rax = camlUnix_safe_dup_920 ();
    *((rsp + 0x20)) = rax;
    rax = *((rsp + 0x10));
    rax = camlUnix_safe_dup_920 ();
    *((rsp + 0x28)) = rax;
    rax = *(rsp);
    camlUnix_safe_close_924 ();
    rax = *((rsp + 8));
    camlUnix_safe_close_924 ();
    rax = *((rsp + 0x10));
    camlUnix_safe_close_924 ();
    rsi = 1;
    rdi = *((rsp + 0x18));
    rax = *(reloc.unix_dup2);
    caml_c_call ();
    rdi = *((rsp + 0x18));
    rax = *(reloc.unix_close);
    caml_c_call ();
    rsi = 3;
    rdi = *((rsp + 0x20));
    rax = *(reloc.unix_dup2);
    caml_c_call ();
    rdi = *((rsp + 0x20));
    rax = *(reloc.unix_close);
    caml_c_call ();
    rsi = 5;
    rdi = *((rsp + 0x28));
    rax = *(reloc.unix_dup2);
    caml_c_call ();
    rdi = *((rsp + 0x28));
    rax = *(reloc.unix_close);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c9e0 */
#include <stdint.h>
 
int64_t camlUnix_safe_dup_920 (void) {
    int64_t var_8h;
    do {
        *(rsp) = rax;
        rdi = rax;
        rax = *(reloc.unix_dup);
        rax = caml_c_call ();
        if (rax >= 7) {
            return rax;
        }
        *((rsp + 8)) = rax;
        rax = *(rsp);
        rax = camlUnix_safe_dup_920 ();
    } while (1);
    *(rsp) = rax;
    rdi = *((rsp + 8));
    rax = *(reloc.unix_close);
    caml_c_call ();
    rax = *(rsp);
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ca30 */
#include <stdint.h>
 
uint64_t camlUnix_safe_close_924 (void) {
    rax = void (*0x40ca60)() ();
    rbx = *(reloc.camlUnix);
    rdi = *(rbx);
    rbx = *(rax);
    if (rbx == rdi) {
        rax = 1;
        return rax;
    }
    rax = caml_raise_exn ();
    r14 = rsp;
    rdi = rax;
    rax = *(reloc.unix_close);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410990 */
#include <stdint.h>
 
int64_t camlPervasives_exit_350 (void) {
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0x290));
    rbx = *(rax);
    rax = 1;
    rdi = *(rbx);
    void (*rdi)(uint64_t) (rax);
    rdi = *(rsp);
    rax = *(reloc.caml_sys_exit);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fdd0 */
#include <stdint.h>
 
int64_t camlPervasives_char_of_int_144 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rax >= 1) {
        if (rax > 0x1ff) {
            goto label_0;
        }
        return;
    }
label_0:
    rax = *(loc.camlPervasives__102);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428090 */
#include <stdint.h>
 
uint64_t caml_alloc_final (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    rbx = rdi;
    *((rsp - 8)) = r12;
    rdi = rsi;
    r12 = rcx;
    rax = caml_final_custom_operations ();
    rsi = rbx*8;
    rcx = r12;
    rdx = rbp;
    rbx = *(rsp);
    rbp = *((rsp + 8));
    rdi = rax;
    r12 = *((rsp + 0x10));
    return caml_alloc_custom ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42abe0 */
#include <stdint.h>
 
int64_t caml_string_set (int64_t arg3, uint32_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    if (rsi >= 0) {
        rax = *((rdi - 8));
        rax >>= 0xa;
        rcx = rax*8;
        rax = rcx - 1;
        rcx = *((rdi + rcx - 1));
        rax -= rcx;
        if (rsi >= rax) {
            goto label_0;
        }
        rdx >>= 1;
        eax = 1;
        *((rsi + rdi)) = dl;
        return rax;
    }
label_0:
    return caml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ae50 */
#include <stdint.h>
 
int64_t camlUnix_fun_1641 (void) {
    rdi = rax;
    rax = *(reloc.unix_getpwnam);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423b40 */
#include <stdint.h>
 
int64_t caml_raise_with_arg (int64_t arg2, int64_t arg1) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_18h_2;
    int64_t var_20h_2;
    int64_t var_28h_2;
    int64_t var_50h_2;
    int64_t var_58h_2;
    int64_t var_60h_2;
    int64_t var_68h_2;
    int64_t var_70h;
    int64_t var_98h;
    rsi = arg2;
    rdi = arg1;
    rax = caml_local_roots;
    *((rsp + 8)) = rdi;
    *(rsp) = rsi;
    edi = 2;
    esi = 0;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 2;
    *((rsp + 0x50)) = rax;
    rax = rsp + 8;
    *((rsp + 0x70)) = rsp;
    *((rsp + 0x98)) = 0;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x68)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x18)) = 1;
    *((rsp + 0x10)) = rax;
    rax = rsp + 0x10;
    *(obj.caml_local_roots) = rax;
    rax = rsp + 0x98;
    *((rsp + 0x28)) = rax;
    rax = caml_alloc_small ();
    rdx = *((rsp + 8));
    *((rsp + 0x98)) = rax;
    *(rax) = rdx;
    rdx = *(rsp);
    rax = *((rsp + 0x98));
    *((rax + 8)) = rdx;
    rdi = *((rsp + 0x98));
    return caml_raise ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434320 */
#include <stdint.h>
 
int64_t caml_executable_name (int64_t arg2, int64_t arg1) {
    int64_t var_18h;
    int64_t var_98h;
    int64_t var_a0h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    ebx = esi;
    rdx = (int64_t) esi;
    rsi = rdi;
    edi = "/proc/self/exe";
    eax = readlink ();
    if (eax < ebx) {
        if (eax == 0xffffffff) {
            goto label_0;
        }
        rax = (int64_t) eax;
        rdx = rsp;
        rsi = rbp;
        *((rbp + rax)) = 0;
        edi = 1;
        eax = xstat64 ();
        if (eax != 0) {
            goto label_0;
        }
        edx = *((rsp + 0x18));
        edx &= 0xf000;
        if (edx == 0x8000) {
            goto label_1;
        }
    }
label_0:
    eax = 0xffffffff;
label_1:
    rbx = *((rsp + 0x98));
    rbp = *((rsp + 0xa0));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4092f0 */
#include <stdint.h>
 
void readlink (void) {
    readlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ef00 */
#include <stdint.h>
 
uint64_t caml_input_val_from_string (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_98h;
    rsi = arg2;
    rdi = arg1;
    rax = rsi + rdi + 8;
    r13 = rsi;
    rbx = caml_local_roots;
    *(obj.intern_input_malloced) = 0;
    rdx = rsp + 8;
    r12 = rsp + 0x98;
    *((rsp + 8)) = rdi;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x68)) = rdx;
    rdx = rsp + 0x50;
    *((rsp + 0x50)) = rbx;
    *((rsp + 0x98)) = 0;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x10)) = rdx;
    rdx = rsp + 0x10;
    *((rsp + 0x18)) = 1;
    *((rsp + 0x28)) = r12;
    *(obj.caml_local_roots) = rdx;
    rdx = rax + 4;
    *(obj.intern_src) = rdx;
    ecx = *(rax);
    rax += 0xc;
    esi = *((rdx - 1));
    rcx <<= 0x18;
    rsi += rcx;
    ecx = *((rdx - 3));
    edx = *((rdx - 2));
    *(obj.intern_src) = rax;
    ebp = *((rax - 1));
    ecx <<= 0x10;
    edx <<= 8;
    rdi = (int64_t) ecx;
    rdx = (int64_t) edx;
    rsi += rdi;
    rsi += rdx;
    edx = *((rax - 4));
    rdx <<= 0x18;
    rbp = rdx + rbp;
    edx = *((rax - 3));
    eax = *((rax - 2));
    edx <<= 0x10;
    eax <<= 8;
    rcx = (int64_t) edx;
    rax = (int64_t) eax;
    rbp += rcx;
    rbp += rax;
    rdi = rbp;
    intern_alloc ();
    rax = *((rsp + 8));
    rdi = r12;
    rax = r13 + rax + 0x14;
    *(obj.intern_src) = rax;
    intern_rec ();
    rdi = rbp;
    intern_add_to_heap ();
    rdi = intern_obj_table;
    if (rdi != 0) {
        caml_stat_free ();
    }
    *(obj.caml_local_roots) = rbx;
    rax = *((rsp + 0x98));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fcf0 */
#include <stdint.h>
 
int64_t camlPervasives_abs_71 (void) {
    if (rax >= 1) {
        return;
    }
    rbx = 2;
    rbx -= rax;
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c0a0 */
#include <stdint.h>
 
int64_t camlUnix_getsockopt_float_690 (void) {
    rdi = 7;
    rsi = rax;
    rdx = rbx;
    rax = *(reloc.unix_getsockopt);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428bc0 */
#include <stdint.h>
 
uint64_t caml_notequal (void) {
    edx = 0;
    rax = compare_val ();
    rbx = rax;
    if (*(obj.compare_stack) != 0x652500) {
        rax = compare_free_stack ();
    }
    rax -= rax;
    rax &= 0xfffffffffffffffe;
    rax += 3;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4156f0 */
#include <stdint.h>
 
int64_t camlList_iter2_139 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, uint32_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    uint32_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        rsi = rax;
        if (rbx == 1) {
            goto label_0;
        }
        if (rdi == 1) {
            goto label_1;
        }
        *(rsp) = rsi;
        rax = *((rdi + 8));
        *((rsp + 0x10)) = rax;
        rdi = *(rdi);
        rax = *((rbx + 8));
        *((rsp + 8)) = rax;
        rax = *(rbx);
        rbx = rdi;
        rdi = rsi;
        caml_apply2 ();
        rax = *(rsp);
        rbx = *((rsp + 8));
        rdi = *((rsp + 0x10));
    } while (1);
label_0:
    if (rdi == 1) {
        rax = 1;
        return rax;
    }
label_1:
    rax = *(loc.camlList__46);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429af0 */
#include <stdint.h>
 
void caml_int64_of_int (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b500 */
#include <stdint.h>
 
int64_t camlUnix_fun_1747 (void) {
    rdi = rax;
    rax = *(reloc.unix_unlink);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429cc0 */
#include <stdint.h>
 
void caml_int32_bits_of_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    __asm ("cvtpd2ps xmm0, xmm0");
    *((rsp - 0xc)) = xmm0;
    edi = *((rsp - 0xc));
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ffa0 */
#include <stdint.h>
 
int64_t camlPervasives_open_out_gen_199 (void) {
    rsi = rax;
    rdx = rbx;
    rax = *(reloc.caml_sys_open);
    rax = caml_c_call ();
    rdi = rax;
    rax = *(reloc.caml_ml_open_descriptor_out);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x430aa0 */
#include <stdint.h>
 
int64_t caml_gc_set (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    rax = *((rdi + 0x18));
    rax >>= 1;
    *(obj.caml_verb_gc) = rax;
    rdx = *((rdi + 0x10));
    eax = 1;
    rdx >>= 1;
    if (rdx == 0) {
        rdx = rax;
    }
    if (*(obj.caml_percent_free) != rdx) {
        esi = "New space overhead: %d%%\n";
        edi = 0x20;
        *(obj.caml_percent_free) = rdx;
        caml_gc_message ();
    }
    rdx = *((rbx + 0x20));
    rdx >>= 1;
    if (rdx != *(obj.caml_percent_max)) {
        esi = "New max overhead: %d%%\n";
        edi = 0x20;
        *(obj.caml_percent_max) = rdx;
        caml_gc_message ();
    }
    rax = *((rbx + 8));
    edx = 0x2000;
    rax >>= 1;
    rax += 0x1ff;
    rax >>= 9;
    rcx = rax;
    rax <<= 0xc;
    rcx <<= 9;
    if (rcx > 0x3ff) {
        rdx = rax;
    }
    if (*(obj.caml_major_heap_increment) != rdx) {
        *(obj.caml_major_heap_increment) = rdx;
        esi = "New heap increment size: %luk bytes\n";
        rdx >>= 0xa;
        edi = 0x20;
        caml_gc_message ();
    }
    rax = *((rbx + 0x30));
    rax >>= 1;
    if (rbp > rax) {
    }
    if (*(obj.caml_allocation_policy) != rbp) {
        edi = 0x20;
        rdx = rbp;
        esi = "New allocation policy: %d\n";
        caml_gc_message ();
        rdi = rbp;
        caml_set_allocation_policy ();
    }
    rbx = *(rbx);
    rbx >>= 1;
    rbx <<= 3;
    if (rbx > 0xfff) {
        goto label_1;
    }
    ebx = 0x1000;
    do {
label_0:
        if (*(obj.caml_minor_heap_size) != rbx) {
            rdx = rbx;
            edi = 0x20;
            esi = "New minor heap size: %luk bytes\n";
            rdx >>= 0xa;
            caml_gc_message ();
            rdi = rbx;
            caml_set_minor_heap_size ();
        }
        eax = 1;
        return rax;
label_1:
    } while (rbx <= 0x10000000);
    ebx = 0x10000000;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424700 */
#include <stdint.h>
 
uint32_t caml_scan_global_young_roots (int64_t arg1) {
    rdi = arg1;
    esi = caml_global_roots;
    rbx = rdi;
    caml_iterate_global_roots ();
    rdi = rbx;
    esi = caml_global_roots_young;
    caml_iterate_global_roots ();
    rbx = .comment;
    if (rbx == 0) {
        goto label_0;
    }
    do {
        rsi = *(rbx);
        edi = caml_global_roots_old;
        caml_insert_global_root ();
        rbx = *((rbx + 8));
    } while (rbx != 0);
    rdi = .comment;
    if (rdi != 0) {
        goto label_1;
    }
    goto label_0;
    do {
        rdi = rbx;
label_1:
        rbx = *((rdi + 8));
        eax = caml_stat_free ();
    } while (rbx != 0);
label_0:
    ecx = .comment;
    if (ecx < 0) {
        goto label_2;
    }
    edx = 0x64e288;
    eax = 0;
    do {
        eax++;
        *(rdx) = 0;
        rdx += 8;
    } while (eax <= ecx);
label_2:
    *(0x0064e310) = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42aac0 */
#include <stdint.h>
 
int64_t caml_string_compare (uint32_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = rdi;
    rdi = rsi;
    if (rax == rsi) {
label_0:
        eax = 1;
        return rax;
    }
    rdx = *((rax - 8));
    rdx >>= 0xa;
    rdx <<= 3;
    r8 = rdx - 1;
    rdx = *((rax + rdx - 1));
    r8 -= rdx;
    rdx = *((rsi - 8));
    rdx >>= 0xa;
    rcx = rdx*8;
    rdx = rcx - 1;
    rcx = *((rsi + rcx - 1));
    rsi = rax;
    rdx -= rcx;
    rcx = r8;
    if (rdx <= r8) {
        rcx = rdx;
    }
    __asm ("repe cmpsb byte [rsi], byte ptr [rdi]");
    al = (rcx > rcx) ? 1 : 0;
    cl = (rcx < rcx) ? 1 : 0;
    al -= cl;
    eax = (int32_t) al;
    if (eax < 0) {
        goto label_2;
    }
    if (eax == 0) {
        goto label_3;
    }
label_1:
    eax = 3;
    return rax;
    do {
label_2:
        rax = 0xffffffffffffffff;
        return rax;
label_3:
    } while (r8 < rdx);
    if (r8 <= rdx) {
        goto label_0;
    }
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429810 */
#include <stdint.h>
 
int64_t caml_nativeint_mul (int64_t arg2) {
    rsi = arg2;
    rax = *((rsi + 8));
    rax *= *((rdi + 8));
    rdi = rax;
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429d60 */
#include <stdint.h>
 
int32_t caml_int32_or (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    eax = *((rsi + 8));
    eax |= *((rdi + 8));
    edi = eax;
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41de60 */
#include <stdint.h>
 
int64_t camlPrintf_kapr_237 (int64_t arg_8h_5, int64_t arg_20h_4, int64_t arg_28h_4, int64_t arg_8h_7, int64_t arg_8h_8, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10) {
    int64_t var_28h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    *(rsp) = rax;
    rax = rbx;
    *((rsp + 8)) = rax;
    camlPrintf_ac_of_format_212 ();
    *((rax - 0x75))--;
    *((rax - 0x7d)) -= cl;
    __asm ("sti");
    if (*((rax - 0x7d)) > 0) {
label_5:
        r15 -= 0x38;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_6;
        }
        rdi = r15 + 8;
        if (r15 <= *(rax)) {
            *((rdi - 8)) = 0x18f7;
        }
        rax = *(reloc.caml_curry2);
        *(rdi) = rax;
        *((rdi + 8)) = 5;
        rax = *(reloc.camlPrintf__loop_268);
        *((rdi + 0x10)) = rax;
        rax = *(rsp);
        *((rdi + 0x18)) = rax;
        rax = *((rsp + 8));
        *((rdi + 0x20)) = rax;
        *((rdi + 0x28)) = rbx;
        rbx = 1;
        rax = 1;
        void (*0x41bc00)() ();
    }
    rbx >>= 1;
    rax = 0x00435a10;
    rdx = *((rax + rbx*4));
    rax += rdx;
    bh >>= 1;
    rbx = *(loc.camlPrintf__47);
    rax = *((rsp + 8));
    rdi = *(rsp);
    void (*0x40a5b0)() ();
label_4:
    r15 -= 0x28;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_7;
    }
    rax = r15 + 8;
    *((rax - 8)) = 0x10f7;
    rbx = *(reloc.camlPrintf__fun_601);
    *(rax) = rbx;
    *((rax + 8)) = 3;
    rbx = *(rsp);
    al -= 0x24;
    *((rax + 0x10)) = rbx;
    rbx = *((rsp + 8));
    *((rax + 0x18)) = rbx;
    return rax;
label_3:
    r15 -= 0x30;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_8;
    }
    al = 1;
    *(rax) += al;
    rax = r15 + 8;
    *((rax - 8)) = 0x14f7;
    rbx = *(reloc.caml_curry2);
    *(rax) = rbx;
    *((rax + 8)) = 5;
    rbx = *(reloc.camlPrintf__fun_604);
    *((rax + 0x10)) = rbx;
    rbx = *(rsp);
    al &= 0x48;
    *((rax + 0x18)) = ebx;
    rbx = *((rsp + 8));
    *((rax + 0x20)) = rbx;
    return rax;
label_2:
    r15 -= 0x30;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_9;
    }
    *(rax) += eax;
    rax = r15 + 8;
    *((rax - 8)) = 0x14f7;
    rbx = *(reloc.caml_curry3);
    *(rax) = rbx;
    *((rax + 8)) = 7;
    rbx = *(reloc.camlPrintf__fun_607);
    *((rax + 0x10)) = rbx;
    rbx = *(rsp);
    al &= 0x48;
    *((rax + 0x18)) = ebx;
    rbx = *((rsp + 8));
    *((rax + 0x20)) = rbx;
    return rax;
label_1:
    r15 -= 0x30;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_10;
    }
    rax = r15 + 8;
    *((rax - 8)) = 0x14f7;
    rbx = *(reloc.caml_curry4);
    *(rax) = rbx;
    *((rax + 8)) = 9;
    rbx = *(reloc.camlPrintf__fun_610);
    *((rax + 0x10)) = rbx;
    rbx = *(rsp);
    al &= 0x48;
    *((rax + 0x18)) = ebx;
    rbx = *((rsp + 8));
    *((rax + 0x20)) = rbx;
    return rax;
label_0:
    r15 -= 0x30;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_11;
    }
    rax = r15 + 8;
    *((rax - 8)) = 0x14f7;
    rbx = *(reloc.caml_curry5);
    *(rax) = rbx;
    *((rax + 8)) = 0xb;
    rbx = *(reloc.camlPrintf__fun_613);
    *((rax + 0x10)) = rbx;
    rbx = *(rsp);
    *((rax + 0x18)) = rbx;
    rbx = *((rsp + 8));
    *((rax + 0x20)) = rbx;
    return rax;
    do {
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x14f7;
            rbx = *(reloc.caml_curry6);
            *(rax) = rbx;
            *((rax + 8)) = 0xd;
            rbx = *(reloc.camlPrintf__fun_616);
            *((rax + 0x10)) = rbx;
            rbx = *(rsp);
            *((rax + 0x18)) = rbx;
            rbx = *((rsp + 8));
            *((rax + 0x20)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_11:
    caml_call_gc ();
    goto label_0;
label_10:
    caml_call_gc ();
    goto label_1;
label_9:
    caml_call_gc ();
    goto label_2;
label_8:
    caml_call_gc ();
    goto label_3;
label_7:
    caml_call_gc ();
    goto label_4;
label_6:
    caml_call_gc ();
    goto label_5;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b4c0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1743 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_link);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4283c0 */
#include <stdint.h>
 
int32_t caml_alloc_dummy_float (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    rdi = (int64_t) edi;
    if (rdi == 0) {
        eax = 0x658088;
        return eax;
    }
    esi = 0;
    return caml_alloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4282a0 */
#include <stdint.h>
 
uint64_t caml_alloc (int64_t arg2, uint32_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    xmm0h = arg1;
    *((rsp - 0x10)) = rbp;
    *((rsp - 8)) = r12;
    eax = esi;
    *((rsp - 0x18)) = rbx;
    r12d = esi;
    rax = rax*8 + 0x658088;
    if (rdi == 0) {
        goto label_1;
    }
    if (rdi > 0x100) {
        goto label_2;
    }
    rax = rdi*8 + 8;
    rbx = rax;
    rbx = -rbx;
    rcx = rbx;
    rcx += *(obj.caml_young_ptr);
    *(obj.caml_young_ptr) = rcx;
    if (rcx < *(obj.caml_young_limit)) {
        goto label_3;
    }
label_0:
    rdx = rbp;
    eax = r12d;
    rdx <<= 0xa;
    rax = rdx + rax + 0x300;
    *(rcx) = rax;
    rax = rcx + 8;
    if (r12d > 0xfa) {
        goto label_1;
    }
    edx = 0;
    do {
        *((rcx + rdx*8 + 8)) = 0;
        rdx++;
    } while (rdx != rbp);
label_1:
    rbx = *(rsp);
    rbp = *((rsp + 8));
    r12 = *((rsp + 0x10));
    return rax;
label_2:
    rax = caml_alloc_shr ();
    rbx = rax;
    while (1) {
        rdi = rbx;
        rbp = *((rsp + 8));
        rbx = *(rsp);
        r12 = *((rsp + 0x10));
        void (*0x4271b0)() ();
label_3:
        rax = rcx + rax;
        *(obj.caml_young_ptr) = rax;
        rax = caml_minor_collection ();
        rcx = rbx;
        rcx += *(obj.caml_young_ptr);
        *(obj.caml_young_ptr) = rcx;
        goto label_0;
        memset (rax, 0, rbp*8);
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429c70 */
#include <stdint.h>
 
void caml_int64_neg (int64_t arg1) {
    rdi = arg1;
    rdi = *((rdi + 8));
    rdi = -rdi;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416630 */
#include <stdint.h>
 
int64_t camlChar_escaped_66 (void) {
    rdi = rax;
    if (rdi != 0x4f) {
        if (rdi != 0xb9) {
            *(rsp) = rdi;
            if (rdi >= 0x1d) {
                goto label_0;
            }
            rax = rdi;
            rax >>= 1;
            rdx = 0x00435230;
            rax = *((rdx + rax*4));
            rdx += rax;
            /* switch table (14 cases) at 0x435230 */
            void (*rdx)() ();
            rax = *(loc.camlChar__8);
            return rax;
            rax = *(loc.camlChar__9);
            return rax;
            rax = *(loc.camlChar__10);
            return rax;
            rax = *(loc.camlChar__11);
            return rax;
        }
        rax = *(loc.camlChar__7);
        return rax;
    }
    rax = *(loc.camlChar__6);
    return rax;
label_0:
    rax = *(reloc.caml_is_printable);
    rax = caml_c_call ();
    if (rax != 1) {
        rdi = 3;
        rax = *(reloc.caml_create_string);
        caml_c_call ();
        rbx = *(rsp);
        rbx >>= 1;
        *(rax) = bl;
        return rax;
    }
    rax = *(rsp);
    *(rsp) = rax;
    rdi = 9;
    rax = *(reloc.caml_create_string);
    rax = caml_c_call ();
    rbx = rax;
    rax = 0x5c;
    *(rbx) = al;
    rcx = 0x64;
    rdi = *(rsp);
    rax = *(rsp);
    rax >>= 1;
    __asm ("cqo");
    rax = rdx:rax / rcx;
    rdx = rdx:rax % rcx;
    rax = rax + rax + 0x61;
    rax >>= 1;
    *((rbx + 1)) = al;
    rsi = 0xa;
    rcx = 0xa;
    rax = rdi;
    rax >>= 1;
    __asm ("cqo");
    rax = rdx:rax / rcx;
    rdx = rdx:rax % rcx;
    rcx = rsi;
    __asm ("cqo");
    rax = rdx:rax / rcx;
    rdx = rdx:rax % rcx;
    rax = rdx + rdx + 0x61;
    rax >>= 1;
    *((rbx + 2)) = al;
    rcx = 0xa;
    rax = rdi;
    rax >>= 1;
    __asm ("cqo");
    rax = rdx:rax / rcx;
    rdx = rdx:rax % rcx;
    rax = rdx + rdx + 0x61;
    rax >>= 1;
    *((rbx + 3)) = al;
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40cb60 */
#include <stdint.h>
 
int64_t camlUnix_create_process_933 (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp + 0x18)) = rax;
    *((rsp + 0x20)) = rbx;
    *(rsp) = rdi;
    *((rsp + 8)) = rsi;
    *((rsp + 0x10)) = rdx;
    rdi = 1;
    rax = *(reloc.unix_fork);
    rax = caml_c_call ();
    if (rax != 1) {
        return rax;
    }
    fcn_0040cbb4 (rdi, rsi, rdx, rcx, r8);
    rax = 0xff;
    return camlPervasives_exit_350 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40cbb4 */
#include <stdint.h>
 
int64_t fcn_0040cbb4 (int64_t arg_10h, int64_t arg_18h, int64_t arg_20h, int64_t arg_28h, int64_t arg_30h) {
    r14 = rsp;
    rax = *((rsp + 0x10));
    rbx = *((rsp + 0x18));
    rdi = *((rsp + 0x20));
    camlUnix_perform_redirections_926 ();
    rdi = *((rsp + 0x28));
    rsi = *((rsp + 0x30));
    rax = *(reloc.unix_execvp);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c100 */
#include <stdint.h>
 
int64_t camlUnix_getsockopt_error_697 (void) {
    rdx = 1;
    rdi = 9;
    rsi = rax;
    rax = *(reloc.unix_getsockopt);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429d50 */
#include <stdint.h>
 
int32_t caml_int32_xor (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    eax = *((rsi + 8));
    eax ^= *((rdi + 8));
    edi = eax;
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4296d0 */
#include <stdint.h>
 
void caml_nativeint_of_int (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b030 */
#include <stdint.h>
 
int64_t camlUnix_fun_1671 (void) {
    rdi = rax;
    rax = *(reloc.unix_mktime);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429d30 */
#include <stdint.h>
 
void caml_int32_shift_right (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    edi = *((rdi + 8));
    rcx = rsi;
    rcx >>= 1;
    edi >>= cl;
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b340 */
#include <stdint.h>
 
int64_t camlUnix_fun_1719 (void) {
    rdi = rax;
    rax = *(reloc.unix_clear_close_on_exec);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4153d0 */
#include <stdint.h>
 
void camlList_rev_84 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rbx = 1;
    return camlList_rev_append_79 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e5c0 */
#include <stdint.h>
 
int64_t camlPrintf_fprintf_423 (int64_t arg6, int64_t arg5, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rbx = rax;
    rax = *(loc.camlPrintf__43);
    return camlPrintf_kfprintf_418 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429760 */
#include <stdint.h>
 
int64_t caml_nativeint_and (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = *((rsi + 8));
    rax &= *((rdi + 8));
    rdi = rax;
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d990 */
#include <stdint.h>
 
int64_t camlPrintf_extract_format_int_131 (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *(rsp) = rax;
    rax = rbx;
    rbx = rdi;
    rdi = rsi;
    rsi = rdx;
    camlPrintf_extract_format_113 ();
    rbx = *(rsp);
    if (rbx != 0x9d) {
        if (rbx == 0xdd) {
            goto label_0;
        }
        return rax;
    }
label_0:
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rdi = *((rax + rbx));
    rbx -= rdi;
    rsi = rbx + rbx - 1;
    rsi >>= 1;
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rdi = *((rax + rbx));
    rbx -= rdi;
    if (rbx > rsi) {
        rbx = 0x75;
        *((rax + rsi)) = bl;
        return rax;
    }
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4154a0 */
#include <stdint.h>
 
int64_t camlList_rev_map_95 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x10f7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlList__rmap_f_98);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = rsi;
            rax = 1;
            void (*0x4143c0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c660 */
#include <stdint.h>
 
int64_t camlUnix_getnameinfo_emulation_798 (int64_t arg_20h, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = *((rax - 8));
    if (rdi != 0) {
        *((rsp + 0x10)) = rbx;
        *((rsp + 8)) = rdi;
        rax = *(rax);
        *(rsp) = rax;
        rax = fcn_0040c708 (*((rax + 8)));
        rdi = *(reloc.caml_exn_Not_found);
        rbx = *(rax);
        if (rbx == rdi) {
            rax = 5;
            rbx = *((rsp + 0x10));
            rax = camlList_mem_189 ();
            if (rax != 1) {
label_2:
                r15 -= 0x10;
                rax = *(reloc.caml_young_limit);
                if (r15 < *(rax)) {
                    goto label_3;
                }
                rbx = r15 + 8;
                *((rbx - 8)) = 0x400;
                rax = *(reloc.caml_exn_Not_found);
                *(rbx) = rax;
                rax = rbx;
                caml_raise_exn ();
            }
            rdi = *(rsp);
            rax = *(reloc.unix_string_of_inet_addr);
            caml_c_call ();
        } else {
            rax = caml_raise_exn ();
        }
        *(rsp) = rax;
        rax = void (*0x40c7a0)() ();
        rdi = *(reloc.caml_exn_Not_found);
        rbx = *(rax);
        if (rbx == rdi) {
            rax = *((rsp + 8));
            rax = camlPervasives_string_of_int_154 ();
            rdi = rax;
        } else {
            rax = caml_raise_exn ();
            r14 = rsp;
            rax = 7;
            rbx = *((rsp + 0x20));
            rax = camlList_mem_189 ();
            if (rax != 1) {
label_1:
                r15 -= 0x10;
                rax = *(reloc.caml_young_limit);
                if (r15 < *(rax)) {
                    goto label_4;
                }
                rax = r15 + 8;
                *((rax - 8)) = 0x400;
                rbx = *(reloc.caml_exn_Not_found);
                *(rax) = rbx;
                caml_raise_exn ();
            }
            rax = 9;
            rbx = *((rsp + 0x20));
            rax = camlList_mem_189 ();
            if (rax != 1) {
                rsi = *(loc.camlUnix__192);
            } else {
                rsi = *(loc.camlUnix__191);
            }
            rdi = *((rsp + 0x18));
            rax = *(reloc.unix_getservbyport);
            rax = caml_c_call ();
            rdi = *(rax);
        }
label_0:
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_5;
        }
        rax = r15 + 8;
        *((rax - 8)) = 0x800;
        rbx = *(rsp);
        *(rax) = rbx;
        *((rax + 8)) = rdi;
        return rax;
    }
    rdi = *(rax);
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *(loc.camlUnix__190);
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_5:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417620 */
#include <stdint.h>
 
void camlString_contains_165 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rbx;
    rbx = 1;
    return camlString_contains_from_160 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b7e0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1793 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_execv);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416800 */
#include <stdint.h>
 
int64_t camlChar_compare_76 (void) {
    rax -= rbx;
    rax++;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415900 */
#include <stdint.h>
 
int64_t camlList_for_all2_173 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, uint32_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    uint32_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        rsi = rax;
        if (rbx == 1) {
            goto label_0;
        }
        if (rdi == 1) {
            goto label_1;
        }
        *(rsp) = rsi;
        rax = *((rdi + 8));
        *((rsp + 0x10)) = rax;
        rdi = *(rdi);
        rax = *((rbx + 8));
        *((rsp + 8)) = rax;
        rax = *(rbx);
        rbx = rdi;
        rdi = rsi;
        rax = caml_apply2 ();
        if (rax == 1) {
            goto label_2;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
        rdi = *((rsp + 0x10));
    } while (1);
label_2:
    rax = 1;
    return rax;
label_0:
    if (rdi == 1) {
        rax = 3;
        return rax;
    }
label_1:
    rax = *(loc.camlList__43);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x412ac0 */
#include <stdint.h>
 
int64_t camlArray_append_82 (int64_t arg6, int64_t arg5, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rcx = *((rax - 8));
    rcx >>= 9;
    rcx |= 1;
    rdx = *((rbx - 8));
    rdx >>= 9;
    rdx |= 1;
    if (rcx == 1) {
        if (rdx == 1) {
            rax = *(loc.camlArray__30);
            return rax;
        }
        *(rsp) = rdx;
        *((rsp + 0x10)) = rcx;
        *((rsp + 8)) = rbx;
        *((rsp + 0x18)) = rax;
    } else {
        *(rsp) = rdx;
        *((rsp + 0x10)) = rcx;
        *((rsp + 8)) = rbx;
        *((rsp + 0x18)) = rax;
    }
    if (rcx > 1) {
        rbx = rax;
    }
    rdi = *((rbx - 8));
    if (rdi != 0xfe) {
        rsi = *(rbx);
    } else {
label_2:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_3;
        }
        rsi = r15 + 8;
        *((rsi - 8)) = 0x4fd;
        __asm ("movlpd xmm0, qword [rbx]");
        __asm ("movlpd qword [rsi], xmm0");
    }
    rdi = rcx + rdx - 1;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = 1;
    r12 = *((rsp + 0x10));
    r12 += 0xfffffffffffffffe;
    if (rbx > r12) {
        goto label_4;
    }
    do {
        rdi = *((rsp + 0x18));
        rax = *((rdi - 8));
        if (rax != 0xfe) {
            rsi = *((rdi + rbx*4 - 4));
        } else {
label_1:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_5;
            }
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdi + rbx*4 - 4]");
            __asm ("movlpd qword [rsi], xmm0");
        }
        rax = *((rbp - 8));
        if (rax != 0xfe) {
            rdi = rbp + rbx*4 - 4;
            caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [rbp + rbx*4 - 4], xmm0");
        }
        rax = rbx;
        rbx += 2;
    } while (rax != r12);
label_4:
    rbx = 1;
    rax = *(rsp);
    rax += 0xfffffffffffffffe;
    if (rbx > rax) {
        goto label_6;
    }
    *(rsp) = rax;
    do {
        rdi = *((rsp + 8));
        rax = *((rdi - 8));
        if (rax != 0xfe) {
            rsi = *((rdi + rbx*4 - 4));
        } else {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_7;
            }
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdi + rbx*4 - 4]");
            __asm ("movlpd qword [rsi], xmm0");
        }
        rax = *((rsp + 0x10));
        rdi = rbx + rax - 1;
        rax = *((rbp - 8));
        if (rax != 0xfe) {
            rdi = rbp + rdi*4 - 4;
            caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [rbp + rdi*4 - 4], xmm0");
        }
        rdi = rbx;
        rbx += 2;
        rax = *(rsp);
    } while (rdi != rax);
label_6:
    rax = rbp;
    return rax;
label_7:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_call_gc ();
    goto label_2;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42d160 */
#include <stdint.h>
 
uint64_t caml_serialize_block_1 (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rdi = extern_ptr;
    rbx = rsi;
    rax = rdi + rsi;
    if (*(obj.extern_limit) < rax) {
        rdi = rsi;
        grow_extern_output ();
    }
    memmove (*(obj.extern_ptr), rbp, rbx);
    *(obj.extern_ptr) += rbx;
    rbp = *((rsp + 0x10));
    rbx = *((rsp + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bf80 */
#include <stdint.h>
 
int64_t camlUnix_getsockopt_669 (void) {
    rdi = 1;
    rsi = rax;
    rdx = rbx;
    rax = *(reloc.unix_getsockopt);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429830 */
#include <stdint.h>
 
void caml_nativeint_sub (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdi = *((rdi + 8));
    rdi -= *((rsi + 8));
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c5e0 */
#include <stdint.h>
 
uint64_t camlUnix_getaddrinfo_777 (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    *(rsp) = rax;
    *((rsp + 8)) = rbx;
    rdx = rdi;
    *((rsp + 0x10)) = rdx;
    rax = void (*0x40c628)() ();
    rdi = *(reloc.caml_exn_Invalid_argument);
    rbx = *(rax);
    if (rbx == rdi) {
        rax = *(rsp);
        rbx = *((rsp + 8));
        rdi = *((rsp + 0x10));
        void (*0x40c130)() ();
    }
    rax = caml_raise_exn ();
    r14 = rsp;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_getaddrinfo);
    caml_c_call ();
    rbx = 1;
    camlList_rev_append_79 ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e1f0 */
#include <stdint.h>
 
int64_t camlPrintf_next_index_290 (void) {
    if (rax != 1) {
        rax = rbx;
        return rax;
    }
    rdi = *((rdi + 0x58));
    rsi = *((rdi + 0x10));
    rdi = *(rsi);
    rax = rbx;
    rbx = rsi;
    return void (*reloc.camlPrintf)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410760 */
#include <stdint.h>
 
int64_t camlPervasives_read_float_314 (void) {
    rax = 1;
    rax = camlPervasives_read_line_312 ();
    rdi = rax;
    rax = *(reloc.caml_float_of_string);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417310 */
#include <stdint.h>
 
int64_t camlString_apply1_128 (void) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = *((rbx - 8));
    rdi >>= 0xa;
    rdi = rdi*8 - 1;
    rsi = *((rbx + rdi));
    rdi -= rsi;
    rdi = rdi + rdi + 1;
    if (rdi == 1) {
        rax = rbx;
        return rax;
    }
    *(rsp) = rbx;
    *((rsp + 8)) = rax;
    rax = rbx;
    rax = camlString_copy_70 ();
    rax = *(rsp);
    rax = *(rax);
    rax = rax + rax + 1;
    rbx = *((rsp + 8));
    rdi = *(rbx);
    rax = void (*rdi)(uint64_t) (rax);
    rbx = rax;
    rbx >>= 1;
    rax = *((rsp + 0x10));
    *(rax) = bl;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b0b0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1679 (void) {
    rdi = rax;
    rax = *(reloc.unix_time);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434550 */
#include <stdint.h>
 
void caml_dlopen (uint32_t arg3, int64_t arg2) {
    rdx = arg3;
    rsi = arg2;
    esi -= esi;
    sil = 0;
    esi += 0x1102;
    return dlopen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a710 */
#include <stdint.h>
 
int64_t camlBuffer_advance_to_closing_126 (int64_t arg6, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r8 = rax;
    rcx = rsi;
    do {
        r15 -= 0x38;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x18f7;
            rax = *(reloc.caml_curry3);
            *(rsi) = rax;
            *((rsi + 8)) = 7;
            rax = *(reloc.camlBuffer__advance_132);
            *((rsi + 0x10)) = rax;
            *((rsi + 0x18)) = r8;
            *((rsi + 0x20)) = rbx;
            *((rsi + 0x28)) = rcx;
            rax = *((rcx - 8));
            rax >>= 0xa;
            rax = rax*8 - 1;
            rbx = *((rcx + rax));
            rax -= rbx;
            rcx = rax + rax + 1;
            rax = rdi;
            rbx = rdx;
            rdi = rcx;
            void (*0x419d30)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f7e0 */
#include <stdint.h>
 
uint64_t caml_sys_file_exists (int64_t arg1) {
    rdi = arg1;
    rsi = rdi;
    edi = 1;
    rdx = rsp;
    eax = xstat64 ();
    rax -= rax;
    eax &= 2;
    rax++;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416e20 */
#include <stdint.h>
 
int64_t camlString_escaped_108 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    *((rsp + 0x20)) = rsi;
label_0:
    r15 -= 0x10;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    rbx = r15 + 8;
    *((rbx - 8)) = 0x400;
    *(rbx) = 1;
    rdi = 1;
    rax = *((rsi - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rsi = *((rsi + rax));
    rax -= rsi;
    rax = rax + rax - 1;
    if (rdi > rax) {
        goto label_2;
    }
    *((rsp + 8)) = rax;
    *(rsp) = rdi;
    *((rsp + 0x28)) = rbx;
    do {
        rdi >>= 1;
        rax = *((rsp + 0x20));
        rax = *((rax + rdi));
        rdi = rax + rax + 1;
        if (rdi >= 0x1d) {
            if (rdi == 0x45) {
                goto label_3;
            }
            if (rdi == 0xb9) {
                goto label_3;
            }
        } else {
            if (rdi >= 0x17) {
                if (rdi >= 0x1b) {
                    goto label_3;
                }
            } else {
                if (rdi >= 0x11) {
                    goto label_3;
                }
            }
        }
        rax = *(reloc.caml_is_printable);
        rax = caml_c_call ();
        if (rax != 1) {
            rdi = 3;
        } else {
            rdi = 9;
            goto label_4;
label_3:
            rdi = 5;
        }
label_4:
        rbx = *((rsp + 0x28));
        rax = *(rbx);
        rax += rdi;
        rax--;
        *(rbx) = rax;
        rdi = *(rsp);
        rsi = *(rsp);
        rdi += 2;
        *(rsp) = rdi;
        rax = *((rsp + 8));
    } while (rsi != rax);
label_2:
    rax = *((rsp + 0x20));
    rdi = *((rax - 8));
    rdi >>= 0xa;
    rdi = rdi*8 - 1;
    rsi = *((rax + rdi));
    rdi -= rsi;
    rsi = rdi + rdi + 1;
    rdi = *(rbx);
    if (rdi == rsi) {
        return rax;
    }
    *((rsp + 0x28)) = rbx;
    *((rsp + 0x20)) = rax;
    rdi = *(rbx);
    rax = *(reloc.caml_create_string);
    rax = caml_c_call ();
    r8 = rax;
    rsi = *((rsp + 0x28));
    *(rsi) = 1;
    rbx = 1;
    rax = *((rsp + 0x20));
    rdi = *((rax - 8));
    rdi >>= 0xa;
    rdi = rdi*8 - 1;
    rdx = *((rax + rdi));
    rdi -= rdx;
    rdi = rdi + rdi - 1;
    if (rbx > rdi) {
        goto label_5;
    }
    *((rsp + 8)) = rdi;
    *(rsp) = rbx;
    *((rsp + 0x18)) = r8;
    *((rsp + 0x28)) = rsi;
    *((rsp + 0x20)) = rax;
    do {
        rbx >>= 1;
        rax = *((rsp + 0x20));
        rax = *((rax + rbx));
        rdi = rax + rax + 1;
        rax = rdi;
        rax += 0xffffffffffffffbc;
        if (rax > 0x75) {
            if (rax >= 0xffffffffffffffd9) {
                goto label_6;
            }
            rax += 0x44;
            rax >>= 1;
            rdx = 0x00435290;
            rax = *((rdx + rax*4));
            rdx += rax;
            rax = void (*rdx)() ();
        }
        rax += 0xfffffffffffffffe;
        if (rax > 0x71) {
            rbx = *(rsi);
            rbx >>= 1;
            rax = 0x5c;
            *((r8 + rbx)) = al;
            *(rsi) += 2;
            rax = *(rsi);
            rax >>= 1;
            rdi >>= 1;
            *((r8 + rax)) = dil;
        } else {
label_6:
            *((rsp + 0x10)) = rdi;
            rax = *(reloc.caml_is_printable);
            rax = caml_c_call ();
            if (rax != 1) {
                rsi = *((rsp + 0x28));
                rbx = *(rsi);
                rbx >>= 1;
                rax = *((rsp + 0x10));
                rax >>= 1;
                r8 = *((rsp + 0x18));
                *((r8 + rbx)) = al;
            } else {
                rdi = *((rsp + 0x10));
                rsi = *((rsp + 0x28));
                rbx = *(rsi);
                rbx >>= 1;
                rax = 0x5c;
                r8 = *((rsp + 0x18));
                *((r8 + rbx)) = al;
                *(rsi) += 2;
                rbx = *(rsi);
                rbx >>= 1;
                rcx = 0x64;
                rax = rdi;
                rax >>= 1;
                __asm ("cqo");
                rax = rdx:rax / rcx;
                rdx = rdx:rax % rcx;
                rax = rax + rax + 0x61;
                rax >>= 1;
                *((r8 + rbx)) = al;
                *(rsi) += 2;
                rbx = *(rsi);
                rbx >>= 1;
                r9 = 0xa;
                rcx = 0xa;
                rax = rdi;
                rax >>= 1;
                __asm ("cqo");
                rax = rdx:rax / rcx;
                rdx = rdx:rax % rcx;
                rcx = r9;
                __asm ("cqo");
                rax = rdx:rax / rcx;
                rdx = rdx:rax % rcx;
                rax = rdx + rdx + 0x61;
                rax >>= 1;
                *((r8 + rbx)) = al;
                *(rsi) += 2;
                rbx = *(rsi);
                rbx >>= 1;
                rcx = 0xa;
                rax = rdi;
                rax >>= 1;
                __asm ("cqo");
                rax = rdx:rax / rcx;
                rdx = rdx:rax % rcx;
                rax = rdx + rdx + 0x61;
                rax >>= 1;
                *((r8 + rbx)) = al;
            }
        }
        *(rsi) += 2;
        rbx = *(rsp);
        rdi = *(rsp);
        rbx += 2;
        *(rsp) = rbx;
        rax = *((rsp + 8));
    } while (rdi != rax);
label_5:
    rax = r8;
    return rax;
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429ce0 */
#include <stdint.h>
 
uint32_t caml_int32_of_string (int64_t arg1) {
    rdi = arg1;
    esi = 0x20;
    eax = parse_intnat ();
    edi = eax;
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40cec0 */
#include <stdint.h>
 
int64_t camlUnix_open_process_out_988 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    *((rsp + 8)) = rax;
    rdi = 1;
    rax = *(reloc.unix_pipe);
    rax = caml_c_call ();
    rdi = *((rax + 8));
    *(rsp) = rdi;
    rax = *(rax);
    *((rsp + 0x10)) = rax;
    rax = *(reloc.caml_ml_open_descriptor_out);
    rax = caml_c_call ();
    rdi = rax;
    *((rsp + 0x18)) = rdi;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdx = r15 + 8;
            *((rdx - 8)) = 0x800;
            rax = *(rsp);
            *(rdx) = rax;
            *((rdx + 8)) = 1;
            rbx = rdx + 0x18;
            *((rbx - 8)) = 0x402;
            *(rbx) = rdi;
            rsi = 3;
            rax = *((rsp + 8));
            rdi = *((rsp + 0x10));
            camlUnix_open_proc_975 ();
            rdi = *((rsp + 0x10));
            rax = *(reloc.unix_close);
            caml_c_call ();
            rax = *((rsp + 0x18));
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423d20 */
#include <stdint.h>
 
void caml_raise_sys_blocked_io (void) {
    edi = caml_exn_Sys_blocked_io;
    return caml_raise_constant ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x435010 */
#include <stdint.h>
 
uint64_t libc_csu_init (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x28)) = rbp;
    *((rsp - 0x20)) = r12;
    rbp = obj___CTOR_LIST__;
    r12 = obj___CTOR_LIST__;
    *((rsp - 0x18)) = r13;
    *((rsp - 0x10)) = r14;
    *((rsp - 8)) = r15;
    *((rsp - 0x30)) = rbx;
    rbp -= r12;
    r13d = edi;
    r14 = rsi;
    rbp >>= 3;
    r15 = rdx;
    rax = _init ();
    if (rbp == 0) {
        goto label_0;
    }
    ebx = 0;
    do {
        rdx = r15;
        rsi = r14;
        edi = r13d;
        uint64_t (*r12 + rbx*8)() ();
        rbx++;
    } while (rbx < rbp);
label_0:
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    r12 = *((rsp + 0x18));
    r13 = *((rsp + 0x20));
    r14 = *((rsp + 0x28));
    r15 = *((rsp + 0x30));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b070 */
#include <stdint.h>
 
int64_t camlUnix_fun_1675 (void) {
    rdi = rax;
    rax = *(reloc.unix_gmtime);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ad90 */
#include <stdint.h>
 
int64_t camlUnix_fun_1629 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_socket);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b300 */
#include <stdint.h>
 
int64_t camlUnix_fun_1715 (void) {
    rdi = rax;
    rax = *(reloc.unix_rmdir);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4297c0 */
#include <stdint.h>
 
int64_t caml_nativeint_div (uint32_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi = *((rsi + 8));
    rdx = *((rdi + 8));
    if (rsi == 0) {
        goto label_0;
    }
    while (rdx != rcx) {
        rax = rdx;
        rdx >>= 0x3f;
        rax = rdx:rax / rsi;
        rdx = rdx:rax % rsi;
        rdi = rax;
        void (*0x429670)() ();
        rcx = 0x8000000000000000;
    }
    rax = rdi;
    return rax;
label_0:
    return caml_raise_zero_divide ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ab30 */
#include <stdint.h>
 
int64_t camlUnix_fun_1591 (void) {
    rdi = rax;
    rax = *(reloc.unix_tcdrain);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427ff0 */
#include <stdint.h>
 
uint64_t caml_update_dummy (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    r12 = rsi;
    eax = *((rsi - 8));
    r13 = *((rsi - 8));
    *((rdi - 8)) = al;
    if (al == 0xfe) {
        goto label_0;
    }
    r13 >>= 0xa;
    ebx = 0;
    if (r13 == 0) {
        goto label_1;
    }
    do {
        rsi = *((r12 + rbx*8));
        rdi = rbp;
        rbx++;
        rbp += 8;
        caml_modify ();
    } while (r13 > rbx);
    do {
label_1:
        eax = 1;
        return eax;
label_0:
        rcx = *((rsi - 8));
        rcx >>= 0xa;
    } while (rcx == 0);
    eax = 0;
    do {
        rdx = *((r12 + rax*8));
        *((rdi + rax*8)) = rdx;
        rax++;
    } while (rcx > rax);
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4283e0 */
#include <stdint.h>
 
int32_t caml_alloc_dummy (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    rdi = (int64_t) edi;
    if (rdi == 0) {
        eax = 0x658088;
        return eax;
    }
    esi = 0;
    return caml_alloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4275f0 */
#include <stdint.h>
 
void caml_alloc_dependent_memory (int64_t arg1) {
    rdi = arg1;
    rdi >>= 3;
    *(obj.caml_dependent_size) += rdi;
    *(obj.caml_dependent_allocated) += rdi;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bcd0 */
#include <stdint.h>
 
uint64_t camlUnix_is_inet6_addr_526 (void) {
    rdi = rax;
    rbx = *((rdi - 8));
    rbx >>= 0xa;
    rax = rbx*8 - 1;
    rbx = *((rdi + rax));
    rax -= rbx;
    rax = rax + rax + 1;
    al = (rax == 0x21) ? 1 : 0;
    rax = (int64_t) al;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e7d0 */
#include <stdint.h>
 
int64_t camlPrintf_sprintf_446 (void) {
    *(rsp) = rax;
    rax = *(loc.camlPrintf__39);
    rax = camlPrintf_ksprintf_443 ();
    rbx = rax;
    rdi = *(rbx);
    rax = *(rsp);
    return void (*rdi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b2c0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1711 (void) {
    rdi = rax;
    rax = *(reloc.unix_getcwd);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b820 */
#include <stdint.h>
 
int64_t camlUnix_fun_1797 (void) {
    rdi = rax;
    rax = *(reloc.caml_sys_getenv);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424a30 */
#include <stdint.h>
 
uint8_t caml_register_generational_global_root (uint32_t arg1) {
    rdi = arg1;
    rbx = rdi;
    rdi = *(rdi);
    if ((dil & 1) == 0) {
        if (rdi < *(obj.caml_young_end)) {
            if (rdi <= *(obj.caml_young_start)) {
                goto label_0;
            }
            rsi = rbx;
            edi = caml_global_roots_young;
            void (*0x4245d0)() ();
        }
label_0:
        al = caml_page_table_lookup ();
        if ((al & 1) != 0) {
            goto label_1;
        }
    }
    return al;
label_1:
    rsi = rbx;
    edi = caml_global_roots_old;
    return caml_insert_global_root ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415340 */
#include <stdint.h>
 
int64_t camlList_tl_67 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rax != 1) {
        rax = *((rax + 8));
        return rax;
    }
    rax = *(loc.camlList__50);
    return camlPervasives_failwith_38 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416bd0 */
#include <stdint.h>
 
int64_t camlString_iter_90 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    rdx = rbx;
    rbx = 1;
    rdi = *((rdx - 8));
    rdi >>= 0xa;
    rdi = rdi*8 - 1;
    rsi = *((rdx + rdi));
    rdi -= rsi;
    rdi = rdi + rdi - 1;
    if (rbx > rdi) {
        goto label_0;
    }
    do {
        rbx >>= 1;
        rax = *(rsp);
        rax = *((rax + rbx));
        rax = rax + rax + 1;
        rbx = *((rsp + 8));
        rdi = *(rbx);
        void (*rdi)(uint64_t, uint64_t) (rdi, rax);
        rbx = *((rsp + 0x10));
        rdi = *((rsp + 0x10));
        rbx += 2;
        *((rsp + 0x10)) = rbx;
        rax = *((rsp + 0x18));
    } while (rdi != rax);
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429b80 */
#include <stdint.h>
 
int64_t caml_int64_and (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = *((rsi + 8));
    rax &= *((rdi + 8));
    rdi = rax;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b3c0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1727 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_dup2);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423ee0 */
#include <stdint.h>
 
int64_t caml_register_dyn_global (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rbx = caml_dyn_globals;
    edi = 0x10;
    caml_stat_alloc ();
    *(rax) = rbp;
    *((rax + 8)) = rbx;
    *(obj.caml_dyn_globals) = rax;
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ac90 */
#include <stdint.h>
 
int64_t caml_array_unsafe_set_float (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rax = *(rdx);
    rsi >>= 1;
    *((rdi + rsi*8)) = rax;
    eax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d440 */
#include <stdint.h>
 
int64_t camlPrintf_fun_719 (void) {
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429cb0 */
#include <stdint.h>
 
void caml_int64_to_int32 (int64_t arg1) {
    rdi = arg1;
    rdi = *((rdi + 8));
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b660 */
#include <stdint.h>
 
int64_t caml_finalize_channel (int64_t arg1) {
    rdi = arg1;
    rbx = *((rdi + 8));
    eax = *((rbx + 0x48));
    eax--;
    *((rbx + 0x48)) = eax;
    if (eax > 0) {
        return eax;
    }
    rax = caml_channel_mutex_free;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rax = *((rbx + 0x38));
    if (rax == 0) {
        goto label_1;
    }
    rdx = *((rbx + 0x30));
    *((rax + 0x30)) = rdx;
    rdx = *((rbx + 0x30));
    if (rdx == 0) {
        goto label_0;
    }
    *((rdx + 0x38)) = rax;
    do {
label_0:
        rdi = rbx;
        void (*0x427660)() ();
label_1:
        rax = caml_all_opened_channels;
        rax = *((rax + 0x30));
        *(obj.caml_all_opened_channels) = rax;
    } while (rax == 0);
    *((rax + 0x38)) = 0;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4157e0 */
#include <stdint.h>
 
uint64_t camlList_fold_right2_156 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, uint32_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        if (rbx == 1) {
            goto label_0;
        }
        if (rdi == 1) {
            goto label_1;
        }
        *((rsp + 0x10)) = rax;
        r8 = *((rdi + 8));
        rdx = *(rdi);
        *((rsp + 8)) = rdx;
        rcx = *((rbx + 8));
        rdx = *(rbx);
        *(rsp) = rdx;
        rbx = rcx;
        rdi = r8;
        rax = camlList_fold_right2_156 ();
    } while (1);
    rdi = rax;
    rax = *(rsp);
    rbx = *((rsp + 8));
    rsi = *((rsp + 0x10));
    void (*0x40a560)() ();
label_0:
    if (rdi == 1) {
        rax = rsi;
        return rax;
    }
label_1:
    rax = *(loc.camlList__44);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40abb0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1599 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_getservbyport);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410150 */
#include <stdint.h>
 
void camlPervasives_close_out_noerr_235 (void) {
    *(rsp) = rax;
    fcn_00410160 ();
    return void (*0x41017a)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410160 */
#include <stdint.h>
 
int64_t fcn_00410160 (void) {
    r14 = rsp;
    rdi = rax;
    rax = *(reloc.caml_ml_flush);
    caml_c_call ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41018c */
#include <stdint.h>
 
int64_t fcn_0041018c (int64_t arg_10h) {
    r14 = rsp;
    rdi = *((rsp + 0x10));
    rax = *(reloc.caml_ml_close_channel);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41017a */
#include <stdint.h>
 
int64_t fcn_0041017a (void) {
    fcn_0041018c (rdi);
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ad50 */
#include <stdint.h>
 
int64_t camlUnix_fun_1625 (void) {
    rdi = rax;
    rax = *(reloc.unix_accept);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4310e0 */
#include <stdint.h>
 
int64_t caml_gc_stat (int64_t arg7, int64_t arg8) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_30h;
    int64_t var_40h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_70h;
    int64_t var_78h;
    int64_t var_80h;
    int64_t var_88h;
    int64_t var_b8h;
    xmm0 = arg7;
    xmm1 = arg8;
    rax = caml_heap_start;
    r12 = caml_local_roots;
    if (rax == 0) {
        goto label_5;
    }
    r14d = caml_gc_phase;
    r15 = caml_gc_sweep_hp;
    r8d = 0;
    esi = 0;
    r9d = 0;
    r10d = 0;
    edi = 0;
    ebp = 0;
    r11d = 0;
label_1:
    rbx = rax;
    rbx += *((rax - 0x10));
    r11++;
    r13 = rax - 0x20;
    if (rbx > rax) {
        goto label_0;
    }
    goto label_6;
    do {
        if (rcx != 0) {
            goto label_7;
        }
        rdx >>= 0xa;
        if (rdx != 0) {
            goto label_8;
        }
        r8++;
        dl = 1;
label_2:
        rax = rax + rdx*8;
        if (rbx <= rax) {
            goto label_6;
        }
label_0:
        rdx = *(rax);
        rcx = *(rax);
        ecx &= 0x300;
        if (rcx == 0x100) {
            goto label_9;
        }
    } while (rcx <= 0x100);
    if (rcx == 0x200) {
        goto label_10;
    }
    if (rcx == 0x300) {
        goto label_9;
    }
label_7:
    rdx >>= 0xa;
    rdx++;
    rax = rax + rdx*8;
    if (rbx > rax) {
        goto label_0;
    }
label_6:
    rax = *((r13 + 0x18));
    if (rax != 0) {
        goto label_1;
    }
    r10 = r10 + r10 + 1;
    r9 = r9 + r9 + 1;
    rsi = rsi + rsi + 1;
    r8 = r8 + r8 + 1;
    r15 = r11 + r11 + 1;
    r14 = rbp + rbp + 1;
    r13 = rdi + rdi + 1;
    *((rsp + 0x68)) = r10;
    *((rsp + 0x60)) = r9;
    *((rsp + 0x58)) = rsi;
    *((rsp + 0x50)) = r8;
label_4:
    rax = rsp + 0x70;
    *((rsp + 0xb8)) = 0;
    *((rsp + 0x70)) = r12;
    *((rsp + 0x80)) = 1;
    *((rsp + 0x78)) = 1;
    *(obj.caml_local_roots) = rax;
    rax = rsp + 0xb8;
    xmm2 = caml_stat_promoted_words;
    *((rsp + 0x88)) = rax;
    rax = caml_young_end;
    rax -= *(obj.caml_young_ptr);
    rax >>= 3;
    __asm ("cvtsi2sd xmm0, rax");
    rax = caml_allocated_words;
    __asm ("addsd xmm0, qword [obj.caml_stat_minor_words]");
    if (rax < 0) {
        goto label_11;
    }
    __asm ("cvtsi2sd xmm1, rax");
label_3:
    __asm ("addsd xmm1, qword [obj.caml_stat_major_words]");
    rdx = caml_stat_compactions;
    edi = 0xf;
    rcx = caml_stat_major_collections;
    r8 = caml_stat_minor_collections;
    *((rsp + 0x30)) = xmm2;
    *((rsp + 0x40)) = xmm0;
    rbp = caml_stat_heap_size;
    rbx = caml_stat_top_heap_size;
    *((rsp + 8)) = rdx;
    *((rsp + 0x10)) = rcx;
    *((rsp + 0x18)) = r8;
    rbp >>= 3;
    rbx >>= 3;
    *((rsp + 0x20)) = xmm1;
    rax = caml_alloc_tuple ();
    xmm0 = *((rsp + 0x40));
    *((rsp + 0xb8)) = rax;
    rax = caml_copy_double ();
    rdi = *((rsp + 0xb8));
    rsi = rax;
    caml_modify ();
    xmm2 = *((rsp + 0x30));
    __asm ("movapd xmm0, xmm2");
    rax = caml_copy_double ();
    rdi = *((rsp + 0xb8));
    rsi = rax;
    rdi += 8;
    caml_modify ();
    xmm1 = *((rsp + 0x20));
    __asm ("movapd xmm0, xmm1");
    rax = caml_copy_double ();
    rdi = *((rsp + 0xb8));
    rsi = rax;
    rdi += 0x10;
    caml_modify ();
    r8 = *((rsp + 0x18));
    rdi = *((rsp + 0xb8));
    rsi = r8 + r8 + 1;
    rdi += 0x18;
    caml_modify ();
    rcx = *((rsp + 0x10));
    rdi = *((rsp + 0xb8));
    rsi = rcx + rcx + 1;
    rdi += 0x20;
    caml_modify ();
    rdi = *((rsp + 0xb8));
    rsi = rbp + rbp + 1;
    rdi += 0x28;
    caml_modify ();
    rdi = *((rsp + 0xb8));
    rsi = r15;
    rdi += 0x30;
    caml_modify ();
    rdi = *((rsp + 0xb8));
    rsi = r14;
    rdi += 0x38;
    caml_modify ();
    rdi = *((rsp + 0xb8));
    rsi = r13;
    rdi += 0x40;
    caml_modify ();
    rdi = *((rsp + 0xb8));
    rsi = *((rsp + 0x68));
    rdi += 0x48;
    caml_modify ();
    rdi = *((rsp + 0xb8));
    rsi = *((rsp + 0x60));
    rdi += 0x50;
    caml_modify ();
    rdi = *((rsp + 0xb8));
    rsi = *((rsp + 0x58));
    rdi += 0x58;
    caml_modify ();
    rdi = *((rsp + 0xb8));
    rsi = *((rsp + 0x50));
    rdi += 0x60;
    caml_modify ();
    rdx = *((rsp + 8));
    rdi = *((rsp + 0xb8));
    rsi = rdx + rdx + 1;
    rdi += 0x68;
    caml_modify ();
    rdi = *((rsp + 0xb8));
    rsi = rbx + rbx + 1;
    rdi += 0x70;
    caml_modify ();
    *(obj.caml_local_roots) = r12;
    rax = *((rsp + 0xb8));
    return rax;
label_10:
    rdx >>= 0xa;
    r9++;
    r10 = rdx + r10 + 1;
    rdx++;
    if (rdx > rsi) {
        rsi = rdx;
    }
    goto label_2;
label_9:
    rdx >>= 0xa;
    rdi++;
    rbp = rdx + rbp + 1;
    rdx++;
    goto label_2;
label_8:
    while (r15 > rax) {
        rbp = rbp + rdx + 1;
        rdi++;
        rdx++;
        goto label_2;
    }
    r10 = r10 + rdx + 1;
    rdx++;
    r9++;
    if (rdx > rsi) {
        rsi = rdx;
    }
    goto label_2;
label_11:
    rdx = rax;
    eax &= 1;
    rdx >>= 1;
    rdx |= rax;
    __asm ("cvtsi2sd xmm1, rdx");
    __asm ("addsd xmm1, xmm1");
    goto label_3;
label_5:
    *((rsp + 0x50)) = 1;
    *((rsp + 0x58)) = 1;
    r13d = 1;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x68)) = 1;
    r14d = 1;
    r15d = 1;
    goto label_4;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429840 */
#include <stdint.h>
 
int64_t caml_nativeint_add (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = *((rsi + 8));
    rax += *((rdi + 8));
    rdi = rax;
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429d00 */
#include <stdint.h>
 
void caml_int32_of_float (int64_t arg1) {
    rdi = arg1;
    xmm2 = *(rdi);
    __asm ("cvttsd2si edi, xmm2");
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e6c0 */
#include <stdint.h>
 
uint64_t camlPrintf_get_buff_434 (void) {
    rdi = rax;
    rbx = *((rdi - 8));
    rbx >>= 0xa;
    rax = rbx*8 - 1;
    rbx = *((rdi + rax));
    rax -= rbx;
    rax = rax*4 + 1;
    return camlBuffer_create_67 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a2a0 */
#include <stdint.h>
 
void caml_sinh_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    sinh (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434530 */
#include <stdint.h>
 
void caml_globalsym (int64_t arg1) {
    rdi = arg1;
    rsi = rdi;
    edi = 0;
    return caml_dlsym ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434540 */
#include <stdint.h>
 
void caml_dlclose (void) {
    return dlclose ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a2c0 */
#include <stdint.h>
 
void caml_sin_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    sin (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428cc0 */
#include <stdint.h>
 
int64_t caml_int32_compare (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    edx = *((rsi + 8));
    ecx = *((rdi + 8));
    eax = 0;
    al = (ecx > edx) ? 1 : 0;
    dl = (ecx < edx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    rax = (int64_t) eax;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d730 */
#include <stdint.h>
 
int64_t camlPrintf_pad_string_100 (int64_t arg6, int32_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int32_t var_28h;
    r9 = arg6;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r8 = rax;
    if (rbx == rcx) {
        if (rdx != 1) {
            goto label_0;
        }
        rax = rsi;
        return rax;
    }
label_0:
    if (rbx <= rcx) {
        rax = rsi;
        rbx = rdx;
        rdi = rcx;
        void (*0x416a50)() ();
    }
    *((rsp + 0x28)) = rcx;
    *((rsp + 0x20)) = rdx;
    *((rsp + 0x18)) = rsi;
    *(rsp) = rdi;
    *((rsp + 0x10)) = rbx;
    rax = rbx;
    rbx = r8;
    rax = camlString_make_66 ();
    rdi = rax;
    *((rsp + 8)) = rdi;
    rax = *(rsp);
    if (rax != 1) {
        rsi = 1;
        rax = *((rsp + 0x18));
        rbx = *((rsp + 0x20));
        rdx = *((rsp + 0x28));
        camlString_blit_84 ();
    } else {
        rsi = *((rsp + 0x10));
        rdx = *((rsp + 0x28));
        rsi -= rdx;
        rsi++;
        rax = *((rsp + 0x18));
        rbx = *((rsp + 0x20));
        camlString_blit_84 ();
    }
    rax = *((rsp + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fb10 */
#include <stdint.h>
 
int64_t camlPervasives_fun_436 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_channel_size);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ad10 */
#include <stdint.h>
 
int64_t camlUnix_fun_1621 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_connect);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434be0 */
#include <stdint.h>
 
int32_t caml_record_backtrace (uint32_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    if (edi != *(obj.caml_backtrace_active)) {
        *(obj.caml_backtrace_active) = edi;
        *(obj.caml_backtrace_pos) = 0;
        if (edi != 0) {
            goto label_0;
        }
        edi = caml_backtrace_last_exn;
        caml_remove_global_root ();
    }
    eax = 1;
    return eax;
label_0:
    edi = caml_backtrace_last_exn;
    caml_register_global_root ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4248a0 */
#include <stdint.h>
 
void caml_remove_global_root (int64_t arg1) {
    rdi = arg1;
    rsi = rdi;
    edi = caml_global_roots;
    return caml_delete_global_root ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427b50 */
#include <stdint.h>
 
int64_t caml_shrink_heap (uint32_t arg1) {
    rdi = arg1;
    rbx = rdi;
    if (rdi == *(obj.caml_heap_start)) {
        goto label_0;
    }
    rdx = caml_stat_heap_size;
    rdx -= *((rdi - 0x10));
    esi = "Shrinking heap to %luk bytes\n";
    edi = 4;
    *(obj.caml_stat_heap_size) = rdx;
    rdx >>= 0xa;
    caml_gc_message ();
    rax = caml_heap_start;
    *(obj.caml_stat_heap_chunks)--;
    edx = caml_heap_start;
    if (rbx == rax) {
        goto label_1;
    }
    do {
        rdx = rax - 8;
        rax = *((rax - 8));
    } while (rbx != rax);
label_1:
    rax = *((rbx - 8));
    rsi = rbx;
    edi = 1;
    *(rdx) = rax;
    rdx = rbx;
    rdx += *((rbx - 0x10));
    caml_page_table_remove ();
    rdi = rbx;
    void (*0x427670)() ();
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427770 */
#include <stdint.h>
 
uint64_t caml_initialize (uint32_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    *(rdi) = rsi;
    if ((sil & 1) != 0) {
        goto label_0;
    }
    if (rsi >= *(obj.caml_young_end)) {
        goto label_0;
    }
    if (rsi <= *(obj.caml_young_start)) {
        goto label_0;
    }
    al = caml_page_table_lookup ();
    if ((al & 1) == 0) {
        goto label_0;
    }
    rax = .comment;
    while (1) {
        *(rax) = rbx;
        rax += 8;
        *(0x00652438) = rax;
label_0:
        return rax;
        edi = caml_ref_table;
        caml_realloc_ref_table ();
        rax = .comment;
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ab70 */
#include <stdint.h>
 
int64_t camlUnix_fun_1595 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_tcsetattr);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e150 */
#include <stdint.h>
 
int64_t camlPrintf_scan_positional_spec_280 (int64_t arg5, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r8 = arg5;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
    rcx = rbx;
    rbx = rsi;
    rax = rsi;
    rax >>= 1;
    rax = *((rdx + rax));
    r9 = rax + rax + 1;
    rdi = r9;
    rdi += 0xffffffffffffffa0;
    if (rdi <= 0x13) {
        goto label_0;
    }
    rax = 1;
    rdi = rcx;
    void (*0x40a5b0)() ();
    do {
label_0:
        r15 -= 0x38;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x18f7;
            r8 = *(reloc.caml_curry2);
            *(rdi) = r8;
            *((rdi + 8)) = 5;
            r8 = *(reloc.camlPrintf__get_int_literal_286);
            *((rdi + 0x10)) = r8;
            *((rdi + 0x18)) = rdx;
            *((rdi + 0x20)) = rcx;
            *((rdi + 0x28)) = rbx;
            rbx += 2;
            rax = r9;
            rax += 0xffffffffffffffa0;
            void (*0x41c660)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ab80 */
#include <stdint.h>
 
uint64_t caml_string_greaterthan (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = caml_string_compare ();
    al = (rax > 1) ? 1 : 0;
    eax = (int32_t) al;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b380 */
#include <stdint.h>
 
int64_t camlUnix_fun_1723 (void) {
    rdi = rax;
    rax = *(reloc.unix_clear_nonblock);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fb90 */
#include <stdint.h>
 
int64_t camlPervasives_fun_444 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_ml_output_char);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4252f0 */
#include <stdint.h>
 
int32_t caml_fatal_error_arg2 (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rbx = rdx;
    rdx = rdi;
    rdi = stderr;
    eax = 0;
    rcx = rsi;
    esi = 1;
    eax = fprintf_chk ();
    rdi = stderr;
    rcx = rbp;
    rdx = rbx;
    esi = 1;
    eax = 0;
    fprintf_chk ();
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fb50 */
#include <stdint.h>
 
int64_t camlPervasives_fun_440 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_ml_seek_out);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423940 */
#include <stdint.h>
 
void caml_startup (int64_t arg1) {
    rdi = arg1;
    return caml_main ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ffd0 */
#include <stdint.h>
 
int64_t camlPervasives_open_out_203 (void) {
    rdi = rax;
    rbx = 0x36d;
    rax = *(loc.camlPervasives__94);
    return camlPervasives_open_out_gen_199 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fad0 */
#include <stdint.h>
 
int64_t camlPervasives_fun_432 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_input_char);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e600 */
#include <stdint.h>
 
int64_t camlPrintf_eprintf_427 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    *(rsp) = rax;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0xc0));
    rax = camlPrintf_fprintf_423 ();
    rbx = rax;
    rdi = *(rbx);
    rax = *(rsp);
    return void (*rdi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421f35 */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
uint64_t alloc_sockaddr (uint32_t fildes, struct sockaddr * arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_48h;
    rdx = fildes;
    rdi = arg1;
    rbx = rdi;
    eax = *(rdi);
    if (ax != 2) {
        if (ax != 0xa) {
            if (ax == 1) {
                rdi = rdi + 2;
                rax = caml_copy_string ();
                *((rsp + 0x48)) = rax;
                rbx = *(reloc.caml_local_roots);
                rax = *(rbx);
                *(rsp) = rax;
                *(rbx) = rsp;
                *((rsp + 0x10)) = 1;
                *((rsp + 8)) = 1;
                rax = rsp + 0x48;
                *((rsp + 0x18)) = rax;
                esi = 0;
                edi = 1;
                caml_alloc_small ();
                rdx = *((rsp + 0x48));
                *(rax) = rdx;
                rdx = *(rsp);
                *(rbx) = rdx;
            } else {
                rdi = rdi + 4;
                rax = alloc_inet_addr ();
                *((rsp + 0x48)) = rax;
                rbp = *(reloc.caml_local_roots);
                rax = *(rbp);
                *(rsp) = rax;
                *(rbp) = rsp;
                *((rsp + 0x10)) = 1;
                *((rsp + 8)) = 1;
                rax = rsp + 0x48;
                *((rsp + 0x18)) = rax;
                esi = 1;
                edi = 2;
                caml_alloc_small ();
                rdx = *((rsp + 0x48));
                *(rax) = rdx;
                edx = *((rbx + 2));
                dx = rotate_right16 (dx, 8);
                edx = (int32_t) dx;
                rdx = rdx + rdx + 1;
                *((rax + 8)) = rdx;
                rdx = *(rsp);
                *(rbp) = rdx;
            } else {
                rdi = rdi + 8;
            }
            rax = alloc_inet6_addr ();
            *((rsp + 0x48)) = rax;
            rbp = *(reloc.caml_local_roots);
            rax = *(rbp);
            *(rsp) = rax;
            *(rbp) = rsp;
            *((rsp + 0x10)) = 1;
            *((rsp + 8)) = 1;
            rax = rsp + 0x48;
            *((rsp + 0x18)) = rax;
            esi = 1;
            edi = 2;
            caml_alloc_small ();
            rdx = *((rsp + 0x48));
            *(rax) = rdx;
            edx = *((rbx + 2));
            dx = rotate_right16 (dx, 8);
            edx = (int32_t) dx;
            rdx = rdx + rdx + 1;
            *((rax + 8)) = rdx;
            rdx = *(rsp);
            *(rbp) = rdx;
        } else {
        }
        if (edx != 0xffffffff) {
            close (edx);
        }
        edx = 0;
        rsi = 0x00436cc1;
        edi = 0x61;
        unix_error ();
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x412cd0 */
#include <stdint.h>
 
int64_t camlArray_concat_aux_90 (void) {
    int64_t var_8h;
    *(rsp) = rax;
    *((rsp + 8)) = rbx;
    rax = *(loc.camlArray__29);
    rax = 1;
    rax = camlArray_size_93 ();
    rdi = rax;
    rsi = *(rsp);
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = rax;
    *(rsp) = rbx;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x10f7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlArray__fill_98);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = rbx;
            rax = 1;
            rbx = *((rsp + 8));
            camlArray_fill_98 ();
            rax = *(rsp);
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416780 */
#include <stdint.h>
 
int64_t camlChar_lowercase_71 (void) {
    if (rax >= 0x83) {
        if (rax <= 0xb5) {
            goto label_0;
        }
    }
    if (rax >= 0x181) {
        if (rax <= 0x1ad) {
            goto label_0;
        }
    }
    if (rax >= 0x1b1) {
        if (rax <= 0x1bd) {
            goto label_0;
        }
    }
    return;
label_0:
    rax += 0x40;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4136e0 */
#include <stdint.h>
 
int64_t camlArray_list_length_153 (void) {
    do {
        if (rbx == 1) {
            goto label_0;
        }
        rbx = *((rbx + 8));
        rax += 2;
    } while (1);
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415b90 */
#include <stdint.h>
 
int64_t camlList_mem_assoc_207 (void) {
    int64_t var_8h;
    do {
        if (rbx == 1) {
            goto label_0;
        }
        *(rsp) = rax;
        rdi = *((rbx + 8));
        *((rsp + 8)) = rdi;
        rbx = *(rbx);
        rdi = *(rbx);
        rsi = rax;
        rax = *(reloc.caml_compare);
        rax = caml_c_call ();
        if (rax == 1) {
            rax = 3;
            return rax;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
    } while (1);
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416610 */
#include <stdint.h>
 
int64_t loc_camlChar_code_begin (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rax >= 1) {
        if (rax > 0x1ff) {
            goto label_0;
        }
        return;
    }
label_0:
    rax = *(loc.camlChar__12);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410460 */
#include <stdint.h>
 
int64_t camlPervasives_print_string_292 (void) {
    rbx = rax;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0xb8));
    return camlPervasives_output_string_215 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424210 */
#include <stdint.h>
 
int64_t caml_oldify_local_roots (void) {
    r12d = caml_globals_scanned;
    rdx = caml_globals_inited;
    r13 = (int64_t) r12d;
    if (r13 > rdx) {
        goto label_7;
    }
    rbp = *((r13*8 + loc.caml_globals));
    if (rbp == 0) {
        goto label_7;
    }
    r13++;
label_0:
    rcx = *((rbp - 8));
    eax = 0;
    ebx = 0;
    r14 = rbp - 8;
    rsi = rcx;
    rsi >>= 0xa;
    if (rsi == 0) {
        goto label_8;
    }
    do {
        rsi = rbp + rax*8;
        rdi = *(rsi);
        if ((dil & 1) == 0) {
            if (rdi >= *(obj.caml_young_end)) {
                goto label_9;
            }
            if (rdi <= *(obj.caml_young_start)) {
                goto label_9;
            }
            caml_oldify_one ();
            rcx = *(r14);
        }
label_9:
        ebx++;
        rdx = rcx;
        rax = (int64_t) ebx;
        rdx >>= 0xa;
    } while (rax < rdx);
    rdx = caml_globals_inited;
label_8:
    r12d++;
    if (rdx < r13) {
        goto label_7;
    }
    rax = (int64_t) r12d;
    r13++;
    rbp = *((rax*8 + loc.caml_globals));
    if (rbp != 0) {
        goto label_0;
    }
label_7:
    r12 = caml_dyn_globals;
    *(obj.caml_globals_scanned) = rdx;
    if (r12 == 0) {
        goto label_10;
    }
label_1:
    rbp = *(r12);
    rcx = *((rbp - 8));
    r13 = rbp - 8;
    rax = rcx;
    rax >>= 0xa;
    if (rax == 0) {
        goto label_11;
    }
    eax = 0;
    ebx = 0;
    do {
        rsi = rbp + rax*8;
        rdi = *(rsi);
        if ((dil & 1) == 0) {
            if (rdi >= *(obj.caml_young_end)) {
                goto label_12;
            }
            if (rdi <= *(obj.caml_young_start)) {
                goto label_12;
            }
            rax = caml_oldify_one ();
            rcx = *(r13);
        }
label_12:
        ebx++;
        rdx = rcx;
        rax = (int64_t) ebx;
        rdx >>= 0xa;
    } while (rax < rdx);
label_11:
    r12 = *((r12 + 8));
    if (r12 != 0) {
        goto label_1;
    }
label_10:
    if (*(obj.caml_frame_descriptors) == 0) {
        goto label_13;
    }
label_6:
    r14 = caml_bottom_of_stack;
    rdx = caml_last_return_address;
    r15 = caml_gc_regs;
    if (r14 == 0) {
        goto label_14;
    }
    rcx = *(obj.caml_frame_descriptors_mask);
    rsi = caml_frame_descriptors;
label_3:
    rax = rdx;
    rax >>= 3;
    rax &= rcx;
    rbx = *((rsi + rax*8));
    if (*(rbx) == rdx) {
        goto label_15;
    }
    do {
        rax++;
        rax &= rcx;
        rbx = *((rsi + rax*8));
    } while (*(rbx) != rdx);
label_15:
    eax = *((rbx + 8));
    if (ax == 0xffff) {
        goto label_16;
    }
    r13d = *((rbx + 0xa));
    if (r13w == 0) {
        goto label_17;
    }
    r12 = rbx + 0xc;
    ebp = 0;
    r13d = (int32_t) r13w;
    while ((al & 1) != 0) {
        eax >>= 1;
        rax = (int64_t) eax;
        rsi = r15 + rax*8;
label_2:
        rdi = *(rsi);
        if ((dil & 1) == 0) {
            if (rdi >= *(obj.caml_young_end)) {
                goto label_18;
            }
            if (rdi <= *(obj.caml_young_start)) {
                goto label_18;
            }
            caml_oldify_one ();
        }
label_18:
        ebp++;
        if (r13d == ebp) {
            goto label_19;
        }
        r12 += 2;
        eax = *(r12);
    }
    rax = (int64_t) eax;
    rsi = r14 + rax;
    goto label_2;
label_19:
    eax = *((rbx + 8));
    rcx = *(obj.caml_frame_descriptors_mask);
    rsi = caml_frame_descriptors;
label_17:
    eax &= 0xfffc;
    r14 += rax;
    rdx = *((r14 - 8));
    goto label_3;
label_16:
    rax = r14 + 0x10;
    r14 = *((r14 + 0x10));
    rdx = *((rax + 8));
    r15 = *((rax + 0x10));
    if (r14 != 0) {
        goto label_3;
    }
label_14:
    rbp = caml_local_roots;
    if (rbp == 0) {
        goto label_20;
    }
label_5:
    r13d = 0;
    if (*((rbp + 8)) <= 0) {
        goto label_21;
    }
label_4:
    if (*((rbp + 0x10)) <= 0) {
        goto label_22;
    }
    r12 = (int64_t) r13d;
    ebx = 0;
    esi = 0;
    r12 += 2;
    do {
        rsi <<= 3;
        rsi += *((rbp + r12*8 + 8));
        rdi = *(rsi);
        if ((dil & 1) == 0) {
            if (rdi >= *(obj.caml_young_end)) {
                goto label_23;
            }
            if (rdi <= *(obj.caml_young_start)) {
                goto label_23;
            }
            rax = caml_oldify_one ();
        }
label_23:
        ebx++;
        rsi = (int64_t) ebx;
    } while (rsi < *((rbp + 0x10)));
label_22:
    r13d++;
    r12 = (int64_t) r13d;
    if (r12 < *((rbp + 8))) {
        goto label_4;
    }
label_21:
    rbp = *(rbp);
    if (rbp != 0) {
        goto label_5;
    }
label_20:
    edi = caml_oldify_one;
    caml_scan_global_young_roots ();
    edi = caml_oldify_one;
    caml_final_do_young_roots ();
    rax = caml_scan_roots_hook;
    if (rax != 0) {
        edi = caml_oldify_one;
        void (*rax)() ();
    }
    return rax;
label_13:
    caml_init_frame_descriptors ();
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d670 */
#include <stdint.h>
 
int64_t camlPrintf_parse_string_conversion_95 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rbx = rax;
    *(rsp) = rbx;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x10f7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlPrintf__parse_97);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = rbx;
            rax = void (*0x41d6f4)() ();
            rdi = *(reloc.caml_exn_Failure);
            rbx = *(rax);
            if (rbx == rdi) {
                rdi = 0xe7;
                rbx = 1;
                rax = *(rsp);
                void (*0x41d530)() ();
            }
            rax = caml_raise_exn ();
            r14 = rsp;
            rbx = 3;
            rax = 1;
            camlPrintf_parse_97 ();
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x413220 */
#include <stdint.h>
 
uint64_t camlArray_iter_128 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = 1;
    rsi = *((rbx - 8));
    rsi >>= 9;
    rsi |= 1;
    rsi += 0xfffffffffffffffe;
    if (rdi > rsi) {
        goto label_1;
    }
    *((rsp + 0x18)) = rsi;
    *((rsp + 0x10)) = rdi;
    *(rsp) = rbx;
    *((rsp + 8)) = rax;
    do {
        rbx = *(rsp);
        rax = *((rbx - 8));
        if (rax != 0xfe) {
            rax = *((rbx + rdi*4 - 4));
        } else {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_2;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rbx + rdi*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
        }
        rbx = *((rsp + 8));
        rdi = *(rbx);
        void (*rdi)() ();
        rdi = *((rsp + 0x10));
        rbx = *((rsp + 0x10));
        rdi += 2;
        *((rsp + 0x10)) = rdi;
        rax = *((rsp + 0x18));
    } while (rbx != rax);
label_1:
    rax = 1;
    return rax;
label_2:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c590 */
#include <stdint.h>
 
int64_t caml_putword (int64_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rax = *((rdi + 0x18));
    if (rax >= *((rdi + 0x10))) {
        goto label_2;
    }
label_1:
    edx = ebp;
    edx >>= 0x18;
    *(rax) = dl;
    rax++;
    *((rbx + 0x18)) = rax;
    if (rax >= *((rbx + 0x10))) {
        goto label_3;
    }
label_0:
    edx = ebp;
    edx >>= 0x10;
    *(rax) = dl;
    rax++;
    *((rbx + 0x18)) = rax;
    while (1) {
        edx = ebp;
        edx >>= 8;
        *(rax) = dl;
        rax++;
        *((rbx + 0x18)) = rax;
        if (rax >= *((rbx + 0x10))) {
            rdi = rbx;
            caml_flush_partial ();
            rax = *((rbx + 0x18));
        }
        *(rax) = bpl;
        rax++;
        *((rbx + 0x18)) = rax;
        return rax;
        rdi = rbx;
        caml_flush_partial ();
        rax = *((rbx + 0x18));
    }
label_3:
    rdi = rbx;
    caml_flush_partial ();
    rax = *((rbx + 0x18));
    goto label_0;
label_2:
    caml_flush_partial ();
    rax = *((rbx + 0x18));
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a0a0 */
#include <stdint.h>
 
int64_t camlBuffer_create_67 (void) {
    if (rax < 3) {
        rax = 3;
    }
    rbx = *(reloc.camlSys);
    rbx = *((rbx + 0x28));
    if (rax > rbx) {
        rax = *(reloc.camlSys);
        rdi = *((rax + 0x28));
        *(rsp) = rdi;
    } else {
        rdi = rax;
        *(rsp) = rdi;
    }
    rax = *(reloc.caml_create_string);
    rax = caml_c_call ();
    rdi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x1000;
            *(rax) = rdi;
            *((rax + 8)) = 1;
            rbx = *(rsp);
            *((rax + 0x10)) = rbx;
            *((rax + 0x18)) = rdi;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ff40 */
#include <stdint.h>
 
int64_t camlPervasives_40_167 (void) {
    do {
        if (rax == 1) {
            goto label_0;
        }
        rsi = *((rax + 8));
        rdi = *(rax);
        *(rsp) = rdi;
        rax = rsi;
        rax = camlPervasives_$40_167 ();
    } while (1);
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *(rsp);
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            return rax;
label_0:
            rax = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432960 */
#include <stdint.h>
 
int64_t caml_weak_check (uint32_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    rsi++;
    if (rsi != 0) {
        rax = *((rdi - 8));
        rax >>= 0xa;
        if (rsi >= rax) {
            goto label_0;
        }
        rax = caml_weak_none;
        al = (*((rdi + rsi*8)) != rax) ? 1 : 0;
        eax = (int32_t) al;
        rax = rax + rax + 1;
        return rax;
    }
label_0:
    edi = "Weak.get";
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423d40 */
#include <stdint.h>
 
void caml_raise_zero_divide (void) {
    edi = loc.caml_exn_Division_by_zero;
    return caml_raise_constant ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429770 */
#include <stdint.h>
 
int64_t caml_nativeint_mod (int64_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rcx = *((rsi + 8));
    rdi = *((rdi + 8));
    if (rcx == 0) {
        goto label_0;
    }
    while (rdi != rax) {
        rdx = rdi;
        rax = rdi;
        rdx >>= 0x3f;
        rax = rdx:rax / rcx;
        rdx = rdx:rax % rcx;
        rdi = rdx;
        void (*0x429670)() ();
        rax = 0x8000000000000000;
    }
    edi = 0;
    void (*0x429670)() ();
label_0:
    return caml_raise_zero_divide ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x419520 */
#include <stdint.h>
 
int64_t camlHashtbl_replace_140 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_30h_2;
    int64_t var_30h;
    int64_t var_40h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r12 = rax;
label_0:
    r15 -= 0x28;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    rsi = r15 + 8;
    *((rsi - 8)) = 0x10f7;
    rax = *(reloc.camlHashtbl__replace_bucket_144);
    *(rsi) = rax;
    *((rsi + 8)) = 3;
    *((rsi + 0x10)) = rbx;
    *((rsi + 0x18)) = rdi;
    rax = *((r12 + 8));
    rbp = *((rax - 8));
    rbp >>= 0xa;
    if (rbp != 0) {
        *((rsp + 0x20)) = rsi;
        *((rsp + 0x10)) = rdi;
        *((rsp + 8)) = rbx;
        *(rsp) = r12;
        rsi = 0xc9;
        rdi = 0x15;
        rdx = rbx;
        rax = caml_hash_univ_param ();
        rax >>= 1;
        rcx = rbp;
        __asm ("cqo");
        rax = rdx:rax / rcx;
        rdx = rdx:rax % rcx;
    } else {
        rax = *(reloc.caml_bucket_Division_by_zero);
        caml_raise_exn ();
    }
    rdx <<= 1;
    rdx++;
    *((rsp + 0x30)) = rdx;
    rbx = *((r12 + 8));
    rax = *((rbx - 8));
    rax >>= 9;
    if (rax <= rdx) {
        goto label_2;
    }
    rax = *((rbx + rdx*4 - 4));
    *((rsp + 0x18)) = rax;
    rax = void (*0x4196a8)() ();
    rdi = *(reloc.caml_exn_Not_found);
    rbx = *(rax);
    if (rbx != rdi) {
        goto label_3;
    }
    rbx = *(rsp);
    rdx = *((rbx + 8));
    rax = *((rdx - 8));
    rax >>= 9;
    rdi = *((rsp + 0x30));
    if (rax <= rdi) {
        goto label_4;
    }
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0xc00;
            rax = *((rsp + 8));
            *(rsi) = rax;
            rax = *((rsp + 0x10));
            *((rsi + 8)) = rax;
            rax = *((rsp + 0x18));
            *((rsi + 0x10)) = rax;
            rdi = rdx + rdi*4 - 4;
            caml_modify ();
            *(rbx) += 2;
            rax = *((rbx + 8));
            rax = *((rax - 8));
            rax >>= 9;
            rax |= 1;
            rdi = rax + rax - 1;
            rax = *(rbx);
            if (rax > rdi) {
                rax = *(reloc.camlHashtbl);
                rax = *((rax + 0x68));
                void (*0x418e60)() ();
            }
            rax = 1;
            return rax;
label_3:
            rax = caml_raise_exn ();
            r14 = rsp;
            rbx = *((r12 + 8));
            *((rsp + 0x38)) = rbx;
            rbx = *((rbx - 8));
            rbx >>= 9;
            if (rbx <= rdx) {
                goto label_5;
            }
            rbx = *((rsp + 0x30));
            rax = camlHashtbl_replace_bucket_144 ();
            rdi = *((rsp + 0x38));
            rbx = *((rsp + 0x40));
            rdi = rdi + rbx*4 - 4;
            rsi = rax;
            caml_modify ();
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_5:
    caml_ml_array_bound_error ();
label_4:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a330 */
#include <stdint.h>
 
int64_t caml_modf_float (floating_point * iptr, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_90h;
    int64_t var_98h;
    int64_t var_a0h;
    floating_point * value;
    rsi = iptr;
    rdi = arg1;
    rax = rdi;
    rbx = caml_local_roots;
    rdx = rsp + 8;
    *((rsp + 8)) = rdi;
    xmm0 = *(rax);
    *((rsp + 0x60)) = 1;
    *((rsp + 0x68)) = rdx;
    rdx = rsp + 0x50;
    *((rsp + 0x50)) = rbx;
    *((rsp + 0x58)) = 1;
    *((rsp + 0xa0)) = 0;
    *((rsp + 0x10)) = rdx;
    rdx = rsp + 0x10;
    *((rsp + 0x98)) = 0;
    *((rsp + 0x90)) = 0;
    *((rsp + 0x20)) = 1;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 0xa0;
    *((rsp + 0x18)) = 3;
    *((rsp + 0x28)) = rdx;
    rdx = rsp + 0x98;
    *((rsp + 0x30)) = rdx;
    rdx = rsp + 0x90;
    *((rsp + 0x38)) = rdx;
    modf (rsp + 0xa8, rsi);
    rax = caml_copy_double ();
    xmm0 = *((rsp + 0xa8));
    *((rsp + 0x98)) = rax;
    rax = caml_copy_double ();
    edi = 2;
    *((rsp + 0x90)) = rax;
    rax = caml_alloc_tuple ();
    rdx = *((rsp + 0x98));
    *((rsp + 0xa0)) = rax;
    *(obj.caml_local_roots) = rbx;
    *(rax) = rdx;
    rax = *((rsp + 0xa0));
    rdx = *((rsp + 0x90));
    *((rax + 8)) = rdx;
    rax = *((rsp + 0xa0));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42dfa0 */
#include <stdint.h>
 
int64_t caml_deserialize_block_2 (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rcx = intern_src;
    if (rsi <= 0) {
        goto label_0;
    }
    rdx = rsi;
    eax = 0;
    do {
        r8d = *((rcx + rax));
        r9d = *((rcx + rax + 1));
        *((rdi + rax + 1)) = r8b;
        *((rdi + rax)) = r9b;
        rax += 2;
        rdx--;
    } while (rdx != 0);
    rcx = rcx + rsi*2;
label_0:
    *(obj.intern_src) = rcx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a560 */
#include <stdint.h>
 
int64_t camlBuffer_add_string_110 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg7, int64_t arg8, int64_t arg9) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    *((rsp + 0x18)) = rax;
    rsi = rbx;
    *(rsp) = rsi;
    rdi = *((rsi - 8));
    rdi >>= 0xa;
    rbx = rdi*8 - 1;
    rdi = *((rsi + rbx));
    rbx -= rdi;
    rbx = rbx + rbx + 1;
    *((rsp + 8)) = rbx;
    rdi = *((rax + 8));
    rsi = rdi + rbx - 1;
    *((rsp + 0x10)) = rsi;
    rdi = *((rax + 0x10));
    if (rsi > rdi) {
        camlBuffer_resize_94 ();
    }
    rax = *((rsp + 0x18));
    rsi = *((rax + 8));
    rdi = *(rax);
    rbx = 1;
    rax = *(rsp);
    rdx = *((rsp + 8));
    camlString_blit_84 ();
    rbx = *((rsp + 0x10));
    rax = *((rsp + 0x18));
    *((rax + 8)) = rbx;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bbd0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1817 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_ftruncate_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x412dc0 */
#include <stdint.h>
 
int64_t camlArray_sub_108 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, signed int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    if (rbx < 1) {
        goto label_2;
    }
    if (rdi < 1) {
        goto label_2;
    }
    rax = *((rsi - 8));
    rax >>= 9;
    rax |= 1;
    rax -= rdi;
    rax++;
    if (rbx > rax) {
        goto label_2;
    }
    if (rdi == 1) {
        rax = *(loc.camlArray__28);
        return rax;
    }
    *(rsp) = rdi;
    *((rsp + 8)) = rbx;
    *((rsp + 0x10)) = rsi;
    rax = *((rsi - 8));
    if (rax != 0xfe) {
        rax = *((rsi + rbx*4 - 4));
    } else {
label_1:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_3;
        }
        rax = r15 + 8;
        *((rax - 8)) = 0x4fd;
        __asm ("movlpd xmm0, qword [rsi + rbx*4 - 4]");
        __asm ("movlpd qword [rax], xmm0");
    }
    rsi = rax;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = 3;
    rax = *(rsp);
    rax += 0xfffffffffffffffe;
    if (rbx > rax) {
        goto label_4;
    }
    *(rsp) = rax;
    do {
        rax = *((rsp + 8));
        rsi = rax + rbx - 1;
        rdi = *((rsp + 0x10));
        rax = *((rdi - 8));
        if (rax != 0xfe) {
            rsi = *((rdi + rsi*4 - 4));
        } else {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_5;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdi + rsi*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
            rsi = rax;
        }
        rax = *((rbp - 8));
        if (rax != 0xfe) {
            rax = rbp + rbx*4 - 4;
            rdi = rax;
            caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [rsi]");
            __asm ("movlpd qword [rbp + rbx*4 - 4], xmm0");
        }
        rdi = rbx;
        rax = rbx;
        rax += 2;
        rbx = rax;
        rax = *(rsp);
    } while (rdi != rax);
label_4:
    rax = rbp;
    return rax;
label_2:
    rax = *(loc.camlArray__27);
    void (*0x40fc30)() ();
label_5:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40af10 */
#include <stdint.h>
 
int64_t camlUnix_fun_1653 (void) {
    rdi = rax;
    rax = *(reloc.unix_setuid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a6a0 */
#include <stdint.h>
 
int64_t camlBuffer_closing_125 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rax == 0x51) {
        goto label_0;
    }
    while (1) {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *(reloc.caml_exn_Assert_failure);
            *(rax) = rbx;
            rbx = *(loc.camlBuffer__21);
            *((rax + 8)) = rbx;
            caml_raise_exn ();
            rax = 0xfb;
            return rax;
label_0:
            rax = 0x53;
            return rax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bc10 */
#include <stdint.h>
 
int64_t camlUnix_fun_1813 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_lseek_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423504 */
#include <stdint.h>
 
uint64_t cstringvect (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    rbp = *((rdi - 8));
    rbp >>= 0xa;
    rdi = rbp*8 + 8;
    rax = caml_stat_alloc ();
    rsi = rax;
    if (rbp == 0) {
        goto label_0;
    }
    edx = 0;
    do {
        rcx = *((rbx + rdx*8));
        *((rax + rdx*8)) = rcx;
        rdx++;
    } while (rbp > rdx);
label_0:
    *((rsi + rbp*8)) = 0;
    rax = rsi;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42be10 */
#include <stdint.h>
 
int64_t caml_really_getblock (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r12 = rdi;
    rbx = rdx;
    if (rdx > 0) {
        goto label_0;
    }
    goto label_1;
    do {
        rax = (int64_t) eax;
        rbx -= rax;
        if (rbx <= 0) {
            goto label_1;
        }
        rbp += rax;
label_0:
        rdx = rbx;
        rsi = rbp;
        rdi = r12;
        eax = caml_getblock ();
    } while (eax != 0);
label_1:
    eax = 0;
    al = (rbx == 0) ? 1 : 0;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x431fa0 */
#include <stdint.h>
 
int64_t caml_md5_chan (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_60h;
    int64_t var_1060h;
    int64_t var_1064h;
    int64_t var_1068h;
    int64_t var_106ch;
    int64_t var_1070h;
    int64_t var_1074h;
    int64_t var_10b8h;
    rsi = arg2;
    rdi = arg1;
    rax = caml_channel_mutex_lock;
    r13 = *((rdi + 8));
    rdx = *(fs:0x28);
    *((rsp + 0x10b8)) = rdx;
    edx = 0;
    rdx = caml_local_roots;
    *((rsp + 0x18)) = rdi;
    *((rsp + 0x10)) = rsi;
    *((rsp + 0x30)) = 1;
    *((rsp + 0x28)) = 2;
    *((rsp + 8)) = rdx;
    *((rsp + 0x20)) = rdx;
    rdx = rsp + 0x20;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 0x18;
    *((rsp + 0x38)) = rdx;
    rdx = rsp + 0x10;
    *((rsp + 0x40)) = rdx;
    if (rax != 0) {
        rdi = r13;
        void (*rax)() ();
    }
    rbx = *((rsp + 0x10));
    *((rsp + 0x1060)) = 0x67452301;
    rbp = rsp + 0x60;
    *((rsp + 0x1064)) = 0xefcdab89;
    *((rsp + 0x1068)) = 0x98badcfe;
    r14 = rsp + 0x1060;
    *((rsp + 0x106c)) = 0x10325476;
    *((rsp + 0x1070)) = 0;
    rbx >>= 1;
    *((rsp + 0x1074)) = 0;
    if (rbx < 0) {
        goto label_1;
    }
    rbp = rsp + 0x60;
    if (rbx == 0) {
        goto label_2;
    }
    r12 = rsp + 0x1060;
    r15d = 0x1000;
    do {
        rdx = r15;
        rsi = rbp;
        if (rbx <= 0x1000) {
            rdx = rbx;
        }
        rdi = r13;
        rax = caml_getblock ();
        rax = (int64_t) eax;
        if (rax == 0) {
            goto label_3;
        }
        rdx = rax;
        rsi = rbp;
        rdi = r12;
        *(rsp) = rax;
        r14 = r12;
        caml_MD5Update ();
        rax = *(rsp);
        rbx -= rax;
    } while (rbx > 0);
label_0:
    edi = 0x10;
    rax = caml_alloc_string ();
    rsi = r14;
    rdi = rax;
    rbx = rax;
    caml_MD5Final ();
    rax = caml_channel_mutex_unlock;
    if (rax != 0) {
        rdi = r13;
        void (*rax)() ();
    }
    rax = *((rsp + 8));
    rdx = *((rsp + 0x10b8));
    rdx ^= *(fs:0x28);
    *(obj.caml_local_roots) = rax;
    rax = rbx;
    if (rax != 0) {
        goto label_4;
    }
    return rax;
    do {
        rsi = rbp;
        rdi = r14;
        caml_MD5Update ();
label_1:
        edx = 0x1000;
        rsi = rbp;
        rdi = r13;
        eax = caml_getblock ();
        rdx = (int64_t) eax;
    } while (rdx != 0);
    goto label_0;
label_2:
    r14 = rsp + 0x1060;
    goto label_0;
label_3:
    caml_raise_end_of_file ();
label_4:
    return stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b680 */
#include <stdint.h>
 
int64_t camlUnix_fun_1771 (void) {
    rdi = rax;
    rax = *(reloc.unix_close);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4178e0 */
#include <stdint.h>
 
int64_t camlSys_set_signal_85 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_install_signal_handler);
    caml_c_call ();
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40af50 */
#include <stdint.h>
 
int64_t camlUnix_fun_1657 (void) {
    rdi = rax;
    rax = *(reloc.unix_getuid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b2d0 */
#include <stdint.h>
 
int64_t caml_array_get_float (uint32_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    if (rsi >= 0) {
        rax = *((rdi - 8));
        rax >>= 0xa;
        if (rsi >= rax) {
            goto label_0;
        }
        rax = caml_young_ptr;
        rbx = *((rdi + rsi*8));
        rdx = rax - 0x10;
        *(obj.caml_young_ptr) = rdx;
        if (rdx < *(obj.caml_young_limit)) {
            *(obj.caml_young_ptr) = rax;
            caml_minor_collection ();
            rdx = caml_young_ptr;
            rdx -= 0x10;
            *(obj.caml_young_ptr) = rdx;
        }
        *(rdx) = 0x7fd;
        rax = rdx + 8;
        *((rdx + 8)) = rbx;
        return rax;
    }
label_0:
    return caml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d8e0 */
#include <stdint.h>
 
int64_t camlUnix_shutdown_connection_1048 (void) {
    rdi = rax;
    rax = *(reloc.caml_channel_descriptor);
    rax = caml_c_call ();
    rsi = 3;
    rdi = rax;
    rax = *(reloc.unix_shutdown);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434db0 */
#include <stdint.h>
 
int64_t caml_alloc2 (int64_t arg_8h, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        r15 -= 0x18;
        if (r15 >= *(obj.caml_young_limit)) {
            return;
        }
        rax = *(rsp);
        *(obj.caml_last_return_address) = rax;
        rax = rsp + 8;
        *(obj.caml_bottom_of_stack) = rax;
        fcn_00434c4b (rdi, rsi, rdx, rcx, r8, r9);
        caml_alloc2 ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40be40 */
#include <stdint.h>
 
int64_t camlUnix_send_596 (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rcx = rdi;
    r8 = rsi;
    r9 = rdx;
    if (rcx >= 1) {
        if (r8 < 1) {
            goto label_0;
        }
        rdi = *((rbx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rbx + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= r8;
        rdi += 2;
        if (rcx > rdi) {
            goto label_0;
        }
        rdi = rax;
        rsi = rbx;
        rdx = rcx;
        rcx = r8;
        r8 = r9;
        rax = *(reloc.unix_send);
        caml_c_call ();
        return rax;
    }
label_0:
    rax = *(loc.camlUnix__202);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41de00 */
#include <stdint.h>
 
void camlPrintf_list_iter_i_229 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41db60 */
#include <stdint.h>
 
int64_t camlPrintf_iter_on_format_args_165 (int64_t arg1) {
    rdi = arg1;
    rsi = rax;
    rax = *((rsi - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rdx = *((rsi + rax));
    rax -= rdx;
    rcx = rax + rax - 1;
    r15 -= 0x78;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        void (*0x41dc31)() ();
    }
    rdx = r15 + 8;
    *((rdx - 8)) = 0x38f7;
    rax = *(reloc.caml_curry2);
    *(rdx) = rax;
    *((rdx + 8)) = 5;
    rax = *(reloc.camlPrintf__scan_flags_170);
    *((rdx + 0x10)) = rax;
    *((rdx + 0x18)) = 0x10f9;
    rax = *(reloc.caml_curry2);
    *((rdx + 0x20)) = rax;
    *((rdx + 0x28)) = 5;
    rax = *(reloc.camlPrintf__scan_conv_171);
    *((rdx + 0x30)) = rax;
    *((rdx + 0x38)) = 0x20f9;
    rax = *(reloc.camlPrintf__scan_fmt_172);
    *((rdx + 0x40)) = rax;
    *((rdx + 0x48)) = 3;
    *((rdx + 0x50)) = rsi;
    *((rdx + 0x58)) = rbx;
    *((rdx + 0x60)) = rdi;
    *((rdx + 0x68)) = rcx;
    rbx = rdx;
    rbx += 0x40;
    rax = 1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42abc0 */
#include <stdint.h>
 
uint64_t caml_string_lessthan (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = caml_string_compare ();
    al = (rax <= 0) ? 1 : 0;
    eax = (int32_t) al;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429ad0 */
#include <stdint.h>
 
void caml_int64_of_int32 (int64_t arg1) {
    rdi = arg1;
    rdi = *((rdi + 8));
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b700 */
#include <stdint.h>
 
int64_t camlUnix_fun_1779 (void) {
    rdi = rax;
    rax = *(reloc.unix_getpid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a220 */
#include <stdint.h>
 
void caml_tanh_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    tanh (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fbd0 */
#include <stdint.h>
 
int64_t camlPervasives_fun_448 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_flush);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4158b0 */
#include <stdint.h>
 
int64_t camlList_exists_169 (void) {
    int64_t var_8h;
    do {
        rsi = rax;
        if (rbx == 1) {
            goto label_0;
        }
        rax = *((rbx + 8));
        rax = *(rbx);
        rdi = *(rsi);
        rbx = rsi;
        rax = void (*rdi)(uint64_t, uint64_t) (rsi, rax);
        if (rax != 1) {
            rax = 3;
            return rax;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
    } while (1);
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4172d0 */
#include <stdint.h>
 
int64_t camlString_uppercase_124 (void) {
    rbx = rax;
    rax = *(reloc.camlChar);
    rax = *((rax + 0x18));
    return camlString_map_118 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b6c0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1775 (void) {
    rdi = rax;
    rax = *(reloc.unix_nice);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432770 */
#include <stdint.h>
 
uint64_t caml_callback (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = caml_callback_exn ();
    rdx = rax;
    edx &= 3;
    if (rdx != 2) {
        return rax;
    }
    rdi = rax;
    rdi &= 0xfffffffffffffffc;
    return caml_raise ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bd60 */
#include <stdint.h>
 
int64_t camlUnix_recv_584 (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rcx = rdi;
    r8 = rsi;
    r9 = rdx;
    if (rcx >= 1) {
        if (r8 < 1) {
            goto label_0;
        }
        rdi = *((rbx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rbx + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= r8;
        rdi += 2;
        if (rcx > rdi) {
            goto label_0;
        }
        rdi = rax;
        rsi = rbx;
        rdx = rcx;
        rcx = r8;
        r8 = r9;
        rax = *(reloc.unix_recv);
        caml_c_call ();
        return rax;
    }
label_0:
    rax = *(loc.camlUnix__204);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f050 */
#include <stdint.h>
 
void caml_input_value_from_string (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    return caml_input_val_from_string ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a680 */
#include <stdint.h>
 
void caml_mul_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    __asm ("mulsd xmm0, qword [rsi]");
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a230 */
#include <stdint.h>
 
int64_t camlBuffer_nth_85 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rbx >= 1) {
        rdi = *((rax + 8));
        if (rbx >= rdi) {
            goto label_0;
        }
        rsi = *(rax);
        rbx >>= 1;
        rax = *((rsi - 8));
        rax >>= 0xa;
        rax = rax*8 - 1;
        rdi = *((rsi + rax));
        rax -= rdi;
        if (rax <= rbx) {
            goto label_1;
        }
        rax = *((rsi + rbx));
        rax = rax + rax + 1;
        return rax;
    }
label_0:
    rax = *(loc.camlBuffer__24);
    void (*0x40fc30)() ();
label_1:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4341c0 */
#include <stdint.h>
 
int64_t caml_register_custom_operations (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    edi = 0x10;
    caml_stat_alloc ();
    rdx = custom_ops_table;
    *(rax) = rbx;
    *((rax + 8)) = rdx;
    *(obj.custom_ops_table) = rax;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433cc0 */
#include <stdint.h>
 
uint64_t caml_final_register (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    rbx = rsi;
    *((rsp - 8)) = r12;
    if ((sil & 1) != 0) {
        goto label_2;
    }
    rdi = rsi;
    al = caml_page_table_lookup ();
    if ((al & 3) == 0) {
        goto label_2;
    }
    rdx = young;
    rax = size;
    if (rdx >= rax) {
        goto label_3;
    }
    rax = final_table;
    do {
label_1:
        rcx = rdx * 3;
        rax = rax + rcx*8;
        *(rax) = rbp;
        if (*((rbx - 8)) == 0xf9) {
            goto label_4;
        }
        *((rax + 0x10)) = 0;
        *((rax + 8)) = rbx;
label_0:
        rdx++;
        eax = 1;
        rbx = *(rsp);
        *(obj.young) = rdx;
        rbp = *((rsp + 8));
        r12 = *((rsp + 0x10));
        return rax;
label_3:
        rdi = final_table;
        if (rdi == 0) {
            goto label_5;
        }
        r12 = rax + rax;
        rsi = r12 + rax*4;
        rsi <<= 3;
        rax = caml_stat_resize ();
        *(obj.size) = r12;
        *(obj.final_table) = rax;
        rdx = young;
    } while (1);
label_4:
    rcx = *((rbx - 8));
    rcx >>= 0xa;
    esi = rcx*8;
    rcx <<= 3;
    rbx -= rcx;
    *((rax + 0x10)) = esi;
    *((rax + 8)) = rbx;
    goto label_0;
label_5:
    di = 0x2d0;
    rax = caml_stat_alloc ();
    *(obj.size) = 0x1e;
    *(obj.final_table) = rax;
    rdx = young;
    goto label_1;
label_2:
    edi = 0x436de8;
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b2a0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1709 (void) {
    rdi = rax;
    rax = *(reloc.unix_chroot);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4259c0 */
#include <stdint.h>
 
uint64_t caml_make_free_blocks (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r14d = edx;
    rbx = rdi;
    if (rsi == 0) {
        goto label_1;
    }
    r13 = 0x40000000000000;
    while (r14d == 0) {
        rbp -= r12;
        if (rbp == 0) {
            goto label_1;
        }
label_0:
        rbx = rbx + r12*8;
        r12 = r13;
        if (rbp <= r13) {
            r12 = rbp;
        }
        rax = r12 - 1;
        rax <<= 0xa;
        *(rbx) = rax;
    }
    rdi = rbx + 8;
    caml_fl_merge_block ();
    rbp -= r12;
    if (rbp != 0) {
        goto label_0;
    }
label_1:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bfb0 */
#include <stdint.h>
 
int64_t camlUnix_setsockopt_672 (int64_t arg1) {
    rdi = arg1;
    rcx = rdi;
    rdi = 1;
    rsi = rax;
    rdx = rbx;
    rax = *(reloc.unix_setsockopt);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b110 */
#include <stdint.h>
 
int64_t camlUnix_fun_1685 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_sigprocmask);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432bc0 */
#include <stdint.h>
 
int64_t caml_weak_set (uint32_t arg3, uint32_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    rsi++;
    if (rsi != 0) {
        rax = *((rdi - 8));
        rax >>= 0xa;
        if (rsi >= rax) {
            goto label_0;
        }
        if (rdx != 1) {
            if ((dl & 1) == 0) {
                goto label_1;
            }
        }
        rax = caml_weak_none;
        *((rdi + rsi*8)) = rax;
        eax = 1;
        return rax;
label_1:
        rdx = *(rdx);
        do_set ();
        eax = 1;
        return rax;
    }
label_0:
    edi = "Weak.set";
    return caml_invalid_argument ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417460 */
#include <stdint.h>
 
int64_t camlString_index_from_144 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rbx;
    rsi = rdi;
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rdi = *((rax + rbx));
    rbx -= rdi;
    rbx = rbx + rbx + 1;
    if (rdx >= 1) {
        if (rdx > rbx) {
            goto label_0;
        }
        rdi = rdx;
        void (*0x4173c0)() ();
    }
label_0:
    rax = *(loc.camlString__28);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ac30 */
#include <stdint.h>
 
int64_t camlUnix_fun_1607 (void) {
    rdi = rax;
    rax = *(reloc.unix_gethostbyaddr);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432290 */
#include <stdint.h>
 
int64_t caml_format_exception (int64_t arg1) {
    uint32_t var_8h;
    int64_t var_10h;
    int64_t var_10fh;
    int64_t var_110h;
    int64_t var_158h;
    rdi = arg1;
    rbx = rdi;
    r12 = rbx - 8;
    rax = *(fs:0x28);
    *((rsp + 0x158)) = rax;
    eax = 0;
    rax = rsp + 0x10;
    r13 = rsp;
    *(rsp) = rax;
    rax = rsp + 0x10f;
    *((rsp + 8)) = rax;
    rax = *(rdi);
    rdi = rsp;
    rsi = *(rax);
    add_string ();
    rax = *((rbx - 8));
    rax >>= 0xa;
    if (rax <= 1) {
        goto label_6;
    }
    if (rax == 2) {
        goto label_7;
    }
label_4:
    rdx = rbx;
    r14d = 1;
label_5:
    rax = *(rsp);
    if (rax < *((rsp + 8))) {
        goto label_8;
    }
label_2:
    rax = *(r12);
    rax >>= 0xa;
    if (r14 >= rax) {
        goto label_9;
    }
    rbp = rdx + r14*8;
    rbx = r14;
    r15 = rsp + 0x110;
    while ((sil & 1) == 0) {
        if (*((rsi - 8)) == 0xfc) {
            goto label_10;
        }
        rax = *(rsp);
        if (rax < *((rsp + 8))) {
            *(rax) = 0x5f;
            rax++;
            *(rsp) = rax;
        }
label_0:
        rax = *(r12);
        rbx++;
        rax >>= 0xa;
        if (rax <= rbx) {
            goto label_9;
        }
        if (r14 < rbx) {
            goto label_11;
        }
label_1:
        rbp += 8;
        rsi = *(rbp);
    }
    r8 = rsi;
    rdi = r15;
    ecx = 0x436a17;
    r8 >>= 1;
    edx = 0x40;
    esi = 1;
    eax = 0;
    sprintf_chk ();
    rsi = r15;
    rdi = rsp;
    add_string ();
    goto label_0;
label_11:
    esi = 0x436d08;
    rdi = rsp;
    add_string ();
    goto label_1;
label_10:
    rax = *(rsp);
    if (rax < *((rsp + 8))) {
        *(rax) = 0x22;
        rax++;
        *(rsp) = rax;
    }
    rdi = rsp;
    add_string ();
    rax = *(rsp);
    if (rax >= *((rsp + 8))) {
        goto label_0;
    }
    *(rax) = 0x22;
    rax++;
    *(rsp) = rax;
    goto label_0;
label_9:
    rax = *(rsp);
    while (1) {
label_3:
        *(rax) = 0;
        rbp = *(rsp);
        r13 += 0x10;
        rbp -= r13;
        rbp++;
        rax = malloc (rbp);
        rbx = rax;
        if (rax != 0) {
            memmove (rax, r13, rbp);
        }
        rdx = *((rsp + 0x158));
        rdx ^= *(fs:0x28);
        rax = rbx;
        if (rax != 0) {
            goto label_12;
        }
        return rax;
        *(rax) = 0x29;
        rax++;
        *(rsp) = rax;
    }
label_8:
    *(rax) = 0x28;
    rax++;
    *(rsp) = rax;
    goto label_2;
label_6:
    rax = *(rsp);
    goto label_3;
label_7:
    rdx = *((rbx + 8));
    if ((dl & 1) != 0) {
        goto label_4;
    }
    rax = rdx - 8;
    if (*((rdx - 8)) != 0) {
        goto label_4;
    }
    r12 = rax;
    r14d = 0;
    goto label_5;
label_12:
    return stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428c60 */
#include <stdint.h>
 
int64_t caml_int_compare (int64_t arg2, uint32_t arg1) {
    rsi = arg2;
    rdi = arg1;
    eax = 0;
    al = (rdi > rsi) ? 1 : 0;
    edx = 0;
    dl = (rdi < rsi) ? 1 : 0;
    eax -= edx;
    rax = (int64_t) eax;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40f710 */
#include <stdint.h>
 
int64_t camlPervasives_build_result_267 (uint32_t arg1) {
    rdi = arg1;
    do {
        r12 = rax;
        if (rdi == 1) {
            goto label_0;
        }
        r13 = *((rdi + 8));
        rdi = *(rdi);
        rax = *((rdi - 8));
        rax >>= 0xa;
        rax = rax*8 - 1;
        rsi = *((rdi + rax));
        rax -= rsi;
        rbp = rax + rax + 1;
        rcx = rbx;
        rcx -= rbp;
        rcx++;
        rsi = 1;
        rdx = r12;
        r8 = rbp;
        caml_blit_string ();
        rbx -= rbp;
        rbx++;
        rax = r12;
        rdi = r13;
    } while (1);
label_0:
    rax = r12;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42fbe0 */
#include <stdint.h>
 
uint32_t caml_sys_rename (const char * newpath, const char * oldpath) {
    rsi = newpath;
    rdi = oldpath;
    eax = rename (rdi, rsi);
    if (eax != 0) {
        edi = 1;
        caml_sys_error ();
    }
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b550 */
#include <stdint.h>
 
void caml_alloc_channel (int64_t arg1) {
    rdi = arg1;
    *((rdi + 0x48))++;
    rbx = rdi;
    ecx = 0x3e8;
    edx = 1;
    esi = 8;
    edi = channel_operations;
    caml_alloc_custom ();
    *((rax + 8)) = rbx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428d10 */
#include <stdint.h>
 
int64_t caml_int64_to_int (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 8));
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421ddc */
#include <stdint.h>
 
uint16_t rotate_right16 (uint16_t value, uint32_t count) {
    const uint16_t mask = (CHAR_BIT * sizeof (value)) - 1;
    count &= mask;
    return (value >> count) | (value << (-count & mask));
}
 
uint64_t get_sockaddr (int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x20)) = rbx;
    *((rsp - 0x18)) = rbp;
    *((rsp - 0x10)) = r12;
    *((rsp - 8)) = r13;
    rbx = rsi;
    r12 = rdi;
    eax = *((rdi - 8));
    if (al != 0) {
        if (al != 1) {
            goto label_0;
        }
    } else {
        r13 = *(rdi);
        rdi = *(rdi);
        rax = caml_string_length ();
        r12 = rax;
        *(rbx) = 1;
        if (rax > 0x6b) {
            rdx = r13;
            rsi = 0x00436cc1;
            edi = 0x24;
            unix_error ();
        }
        memmove (rbx + 2, r13, rax + 1);
        r12d += 2;
        *(rbp) = r12d;
        goto label_0;
    }
    rdi = *(rdi);
    rax = caml_string_length ();
    if (rax == 0x10) {
        *(rbx) = 0;
        *((rbx + 8)) = 0;
        *((rbx + 0x10)) = 0;
        *((rbx + 0x18)) = 0;
        *(rbx) = 0xa;
        rax = *(r12);
        rdx = *(rax);
        *((rbx + 8)) = rdx;
        rax = *((rax + 8));
        *((rbx + 0x10)) = rax;
        rax = *((r12 + 8));
        rax >>= 1;
        ax = rotate_right16 (ax, 8);
        *((rbx + 2)) = ax;
        *(rbp) = 0x1c;
    } else {
        *(rbx) = 0;
        *((rbx + 8)) = 0;
        *(rbx) = 2;
        rax = *(r12);
        eax = *(rax);
        *((rbx + 4)) = eax;
        rax = *((r12 + 8));
        rax >>= 1;
        ax = rotate_right16 (ax, 8);
        *((rbx + 2)) = ax;
        *(rbp) = 0x10;
    }
label_0:
    rbx = *((rsp + 8));
    rbp = *((rsp + 0x10));
    r12 = *((rsp + 0x18));
    r13 = *((rsp + 0x20));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b740 */
#include <stdint.h>
 
int64_t camlUnix_fun_1783 (void) {
    rdi = rax;
    rax = *(reloc.unix_wait);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4198b0 */
#include <stdint.h>
 
int64_t camlHashtbl_fold_166 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_18h_2;
    int64_t var_20h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
label_0:
    r15 -= 0x38;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    rdx = r15 + 8;
    *((rdx - 8)) = 0x10f7;
    rax = *(reloc.caml_curry2);
    *(rdx) = rax;
    *((rdx + 8)) = 5;
    rax = *(reloc.camlHashtbl__do_bucket_170);
    *((rdx + 0x10)) = rax;
    *((rdx + 0x18)) = rsi;
    rsi = *((rbx + 8));
    rbx = rdx + 0x28;
    *((rbx - 8)) = 0x400;
    *(rbx) = rdi;
    rax = 1;
    rdi = *((rsi - 8));
    rdi >>= 9;
    rdi |= 1;
    rdi += 0xfffffffffffffffe;
    if (rax > rdi) {
        goto label_2;
    }
    *((rsp + 0x20)) = rdi;
    *((rsp + 0x18)) = rax;
    *((rsp + 0x10)) = rbx;
    *(rsp) = rsi;
    *((rsp + 8)) = rdx;
    do {
        rbx = *(rbx);
        rdi = *(rsp);
        rsi = *((rdi - 8));
        rsi >>= 9;
        if (rsi <= rax) {
            goto label_3;
        }
        rax = *((rdi + rax*4 - 4));
        rdi = *((rsp + 8));
        rax = camlHashtbl_do_bucket_170 ();
        rbx = *((rsp + 0x10));
        rdi = *((rsp + 0x10));
        rsi = rax;
        caml_modify ();
        rax = *((rsp + 0x18));
        rsi = *((rsp + 0x18));
        rax += 2;
        *((rsp + 0x18)) = rax;
        rdi = *((rsp + 0x20));
    } while (rsi != rdi);
label_2:
    rax = *(rbx);
    return rax;
label_1:
    caml_call_gc ();
    goto label_0;
label_3:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b0d0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1681 (void) {
    rdi = rax;
    rax = *(reloc.unix_sigsuspend);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b150 */
#include <stdint.h>
 
int64_t camlUnix_fun_1689 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_lockf);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40abf0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1603 (void) {
    rdi = rax;
    rax = *(reloc.unix_getprotobynumber);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40f9f0 */
#include <stdint.h>
 
int64_t camlPervasives_fun_418 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_close_channel);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4100f0 */
#include <stdint.h>
 
int64_t camlPervasives_output_value_226 (void) {
    rdx = 1;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_output_value);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423c20 */
#include <stdint.h>
 
uint64_t caml_raise_with_string (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rdi = rsi;
    rax = caml_copy_string ();
    rdi = rbx;
    rsi = rax;
    return caml_raise_with_arg ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410590 */
#include <stdint.h>
 
int64_t camlPervasives_prerr_char_301 (void) {
    rbx = *(reloc.camlPervasives);
    rdi = *((rbx + 0xc0));
    rsi = rax;
    rax = *(reloc.caml_ml_output_char);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40beb0 */
#include <stdint.h>
 
int64_t camlUnix_sendto_602 (int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r8 = rdi;
    r9 = rsi;
    r10 = rdx;
    r11 = rcx;
    if (r8 >= 1) {
        if (r9 < 1) {
            goto label_0;
        }
        rdi = *((rbx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rbx + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= r9;
        rdi += 2;
        if (r8 > rdi) {
            goto label_0;
        }
        rdi = rax;
        rsi = rbx;
        rdx = r8;
        rcx = r9;
        r8 = r10;
        r9 = r11;
        rax = *(reloc.unix_sendto_native);
        caml_c_call ();
        return rax;
    }
label_0:
    rax = *(loc.camlUnix__201);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b260 */
#include <stdint.h>
 
int64_t camlUnix_fun_1705 (void) {
    rdi = rax;
    rax = *(reloc.unix_readdir);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a610 */
#include <stdint.h>
 
int64_t camlBuffer_add_channel_118 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9) {
    int64_t var_8h;
    int64_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    *((rsp + 8)) = rax;
    *(rsp) = rbx;
    *((rsp + 0x10)) = rdi;
    rdx = *((rax + 0x10));
    rsi = *((rax + 8));
    rsi = rsi + rdi - 1;
    if (rsi > rdx) {
        rbx = rdi;
        camlBuffer_resize_94 ();
    }
    rax = *((rsp + 8));
    rdi = *((rax + 8));
    rbx = *(rax);
    rax = *(rsp);
    rsi = *((rsp + 0x10));
    camlPervasives_really_input_259 ();
    rbx = *((rsp + 8));
    rdi = *((rbx + 8));
    rax = *((rsp + 0x10));
    rax = rdi + rax - 1;
    *((rbx + 8)) = rax;
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425510 */
#include <stdint.h>
 
int64_t caml_fl_reset (void) {
    rax = caml_allocation_policy;
    *(0x0064de30) = 0;
    if (rax != 0) {
        goto label_1;
    }
    *(obj.fl_prev) = 0x64de30;
    do {
label_0:
        *(obj.caml_fl_cur_size) = 0;
        *(obj.last_fragment) = 0;
        *(obj.caml_fl_merge) = 0x64de30;
        return rax;
label_1:
    } while (rax != 1);
    *(obj.flp_size) = 0;
    *(obj.beyond) = 0;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f710 */
#include <stdint.h>
 
uint64_t caml_sys_random_seed (void) {
    int64_t var_8h;
    int64_t var_18h;
    int64_t var_20h;
    *((rsp - 0x10)) = rbx;
    *((rsp - 8)) = rbp;
    rdi = rsp;
    esi = 0;
    gettimeofday ();
    rbx = *((rsp + 8));
    rbx ^= *(rsp);
    eax = getppid ();
    ebp <<= 0x10;
    eax = getpid ();
    ebp ^= eax;
    rbp = (int64_t) ebp;
    rbp ^= rbx;
    rbx = *((rsp + 0x18));
    rax = rbp + rbp + 1;
    rbp = *((rsp + 0x20));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425340 */
#include <stdint.h>
 
int32_t caml_fatal_error_arg (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = rdi;
    rdi = stderr;
    rcx = rsi;
    eax = 0;
    esi = 1;
    fprintf_chk ();
    return exit (2);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ff10 */
#include <stdint.h>
 
int64_t camlPervasives_string_of_float_164 (void) {
    rdi = *(loc.camlPervasives__95);
    rsi = rax;
    rax = *(reloc.caml_format_float);
    caml_c_call ();
    return camlPervasives_valid_float_lexem_159 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429720 */
#include <stdint.h>
 
void caml_nativeint_shift_left (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdi = *((rdi + 8));
    rcx = rsi;
    rcx >>= 1;
    rdi <<= cl;
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b780 */
#include <stdint.h>
 
int64_t camlUnix_fun_1787 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_execvpe);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fa50 */
#include <stdint.h>
 
int64_t camlPervasives_fun_424 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_ml_seek_in);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4176b0 */
#include <stdint.h>
 
int64_t camlString_compare_173 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_compare);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b220 */
#include <stdint.h>
 
int64_t camlUnix_fun_1701 (void) {
    rdi = rax;
    rax = *(reloc.unix_closedir);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fa10 */
#include <stdint.h>
 
int64_t camlPervasives_fun_420 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_channel_size);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4138b0 */
#include <stdint.h>
 
int64_t camlArray_fold_right_172 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_sp_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
label_1:
    r15 -= 0x10;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_2;
    }
    rbp = r15 + 8;
    *((rbp - 8)) = 0x400;
    *(rbp) = rdi;
    rdi = *((rbx - 8));
    rdi >>= 9;
    rdi |= 1;
    rdi += 0xfffffffffffffffe;
    if (rdi < 1) {
        goto label_3;
    }
    *((rsp + 0x18)) = rdi;
    *((rsp + 0x10)) = rbp;
    *(rsp) = rbx;
    *((rsp + 8)) = rsi;
    do {
        rbx = *(rsp);
        rax = *((rbx - 8));
        if (rax != 0xfe) {
            rax = *((rbx + rdi*4 - 4));
        } else {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_4;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rbx + rdi*4 - 4]");
            __asm ("movlpd qword [rax], xmm0");
        }
        rbx = *(rbp);
        rdi = *((rsp + 8));
        rax = caml_apply2 ();
        rbp = *((rsp + 0x10));
        rdi = *((rsp + 0x10));
        rsi = rax;
        caml_modify ();
        rdi = *((rsp + 0x18));
        rax = *((rsp + 0x18));
        rdi -= 2;
        *((rsp + 0x18)) = rdi;
    } while (rax != 1);
label_3:
    rax = *(rbp);
    return rax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fdf0 */
#include <stdint.h>
 
int64_t camlPervasives_string_of_bool_151 (void) {
    if (rax != 1) {
        rax = *(loc.camlPervasives__101);
        return rax;
    }
    rax = *(loc.camlPervasives__100);
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b6e0 */
#include <stdint.h>
 
int64_t caml_close_channel (int64_t fildes) {
    rdi = fildes;
    rbx = rdi;
    close (*(rdi));
    eax = *((rbx + 0x48));
    if (eax > 0) {
        return eax;
    }
    rax = caml_channel_mutex_free;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rax = *((rbx + 0x38));
    if (rax == 0) {
        goto label_1;
    }
    rdx = *((rbx + 0x30));
    *((rax + 0x30)) = rdx;
    rdx = *((rbx + 0x30));
    if (rdx == 0) {
        goto label_0;
    }
    *((rdx + 0x38)) = rax;
    do {
label_0:
        rdi = rbx;
        void (*0x427660)() ();
label_1:
        rax = caml_all_opened_channels;
        rax = *((rax + 0x30));
        *(obj.caml_all_opened_channels) = rax;
    } while (rax == 0);
    *((rax + 0x38)) = 0;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d480 */
#include <stdint.h>
 
int64_t camlPrintf_fun_737 (void) {
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a200 */
#include <stdint.h>
 
void caml_asin_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    asin (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bfe0 */
#include <stdint.h>
 
int64_t camlUnix_getsockopt_int_676 (void) {
    rdi = 3;
    rsi = rax;
    rdx = rbx;
    rax = *(reloc.unix_getsockopt);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x413700 */
#include <stdint.h>
 
int64_t camlArray_of_list_157 (void) {
    int64_t var_8h;
    rbx = rax;
    if (rbx == 1) {
        goto label_0;
    }
    rax = *((rbx + 8));
    *((rsp + 8)) = rax;
    rax = *(rbx);
    *(rsp) = rax;
    rax = 1;
    rax = camlArray_list_length_153 ();
    rdi = rax;
    rsi = *(rsp);
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x10f7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlArray__fill_162);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = rbx;
            rax = 3;
            rbx = *((rsp + 8));
            void (*0x4116c0)() ();
label_0:
            rax = *(loc.camlArray__22);
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42aca0 */
#include <stdint.h>
 
int64_t caml_make_array (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_90h;
    int64_t var_98h;
    rdi = arg1;
    rax = rdi;
    rbp = caml_local_roots;
    rdx = rsp + 8;
    *((rsp + 8)) = rdi;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x98)) = 0;
    *((rsp + 0x68)) = rdx;
    rdx = rsp + 0x50;
    *((rsp + 0x90)) = 0;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 2;
    *((rsp + 0x10)) = rdx;
    rdx = rsp + 0x10;
    rbx = *((rdi - 8));
    *((rsp + 0x50)) = rbp;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 0x98;
    rbx >>= 0xa;
    *((rsp + 0x28)) = rdx;
    rdx = rsp + 0x90;
    *((rsp + 0x30)) = rdx;
    if (rbx == 0) {
        goto label_0;
    }
    rdi = *(rdi);
    while (1) {
label_0:
        *(obj.caml_local_roots) = rbp;
        return rax;
        *((rsp + 0x98)) = rdi;
        al = caml_page_table_lookup ();
        if ((al & 7) != 0) {
            rax = *((rsp + 0x98));
            if (*((rax - 8)) == 0xfd) {
                goto label_1;
            }
        }
        rax = *((rsp + 8));
    }
label_1:
    esi = 0xfe;
    rdi = rbx;
    rax = caml_alloc_small ();
    rsi = *((rsp + 8));
    *((rsp + 0x90)) = rax;
    edx = 0;
    do {
        rcx = *((rsi + rdx*8));
        rcx = *(rcx);
        *((rax + rdx*8)) = rcx;
        rdx++;
    } while (rbx > rdx);
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4153e0 */
#include <stdint.h>
 
int64_t camlList_flatten_86 (void) {
    do {
        if (rax == 1) {
            goto label_0;
        }
        rdi = *((rax + 8));
        rbx = *(rax);
        *(rsp) = rbx;
        rax = rdi;
        rax = camlList_flatten_86 ();
    } while (1);
    rbx = rax;
    rax = *(rsp);
    void (*0x40ff40)() ();
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428400 */
#include <stdint.h>
 
uint64_t caml_alloc_array (uint32_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_40h;
    int64_t var_48h;
    rsi = arg2;
    rdi = arg1;
    r13 = rdi;
    r12 = rsi;
    r14 = caml_local_roots;
    *(obj.caml_local_roots) = rsp;
    if (*(rsi) == 0) {
        goto label_0;
    }
    ebx = 0;
    do {
        rbx++;
    } while (*((r12 + rbx*8)) != 0);
    if (rbx == 0) {
label_0:
        *(obj.caml_local_roots) = r14;
        eax = 0x658088;
        return eax;
    }
    rax = rsp + 0x48;
    esi = 0;
    rdi = rbx;
    *(rsp) = r14;
    *((rsp + 0x10)) = 1;
    ebp = 0;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x40;
    *((rsp + 8)) = 2;
    *((rsp + 0x40)) = 0;
    *((rsp + 0x48)) = 0;
    *((rsp + 0x20)) = rax;
    rax = caml_alloc ();
    do {
        rdi = *((r12 + rbp*8));
        rax = void (*r13)(uint64_t) (rax);
        rdi = rbp*8;
        rdi += *((rsp + 0x40));
        rsi = rax;
        rbp++;
        *((rsp + 0x48)) = rax;
        caml_modify ();
    } while (rbx > rbp);
    *(obj.caml_local_roots) = r14;
    rax = *((rsp + 0x40));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4104e0 */
#include <stdint.h>
 
int64_t camlPervasives_print_endline_298 (void) {
    rbx = rax;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0xb8));
    camlPervasives_output_string_215 ();
    rsi = 0x15;
    rax = *(reloc.camlPervasives);
    rdi = *((rax + 0xb8));
    rax = *(reloc.caml_ml_output_char);
    caml_c_call ();
    rax = *(reloc.camlPervasives);
    rdi = *((rax + 0xb8));
    rax = *(reloc.caml_ml_flush);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x418d00 */
#include <stdint.h>
 
void camlHashtbl_hash_59 (void) {
    rsi = 0xc9;
    rdi = 0x15;
    rdx = rax;
    caml_hash_univ_param ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e630 */
#include <stdint.h>
 
int64_t camlPrintf_kbprintf_429 (int64_t arg6, int64_t arg5, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rcx = rax;
    rdi = rbx;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0xcf7;
            rax = *(reloc.camlPrintf__fun_724);
            *(rbx) = rax;
            *((rbx + 8)) = 3;
            *((rbx + 0x10)) = rdi;
            rax = *(reloc.camlPrintf);
            r8 = *((rax + 0x118));
            rdx = *(loc.camlPrintf__42);
            rax = *(reloc.camlBuffer);
            rsi = *((rax + 0x48));
            rax = *(reloc.camlBuffer);
            rdi = *((rax + 0x40));
            rax = 1;
            void (*0x40a480)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417550 */
#include <stdint.h>
 
int64_t camlString_rindex_from_156 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rbx >= -1) {
        rsi = *((rax - 8));
        rsi >>= 0xa;
        rsi = rsi*8 - 1;
        rdx = *((rax + rsi));
        rsi -= rdx;
        rsi = rsi + rsi + 1;
        if (rbx >= rsi) {
            goto label_0;
        }
        void (*0x4174b0)() ();
    }
label_0:
    rax = *(loc.camlString__27);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40a480 */
#include <stdint.h>
 
uint64_t caml_apply6 (int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r9 = *((r8 + 8));
    if (r9 == 0xd) {
        r9 = *((r8 + 0x10));
        void (*r9)() ();
    }
    rdi = *(r8);
    rbx = r8;
    rax = void (*rdi)(uint64_t, uint64_t) (rcx, rdi);
    rbx = rax;
    rdi = *(rbx);
    rax = *(rsp);
    rax = void (*rdi)() ();
    rbx = rax;
    rdi = *(rbx);
    rax = *((rsp + 8));
    rax = void (*rdi)() ();
    rbx = rax;
    rdi = *(rbx);
    rax = *((rsp + 0x10));
    rax = void (*rdi)() ();
    rbx = rax;
    rdi = *(rbx);
    rax = *((rsp + 0x18));
    rax = void (*rdi)() ();
    rbx = rax;
    rdi = *(rbx);
    rax = *((rsp + 0x20));
    return void (*rdi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40adb0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1631 (void) {
    rdi = rax;
    rax = *(reloc.unix_string_of_inet_addr);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a300 */
#include <stdint.h>
 
void caml_sqrt_float (int64_t arg1) {
    rdi = arg1;
    xmm1 = *(rdi);
    __asm ("sqrtsd xmm0, xmm1");
    __asm ("ucomisd xmm0, xmm0");
    if (? != ?) {
        if (? == ?) {
            goto label_0;
        }
    }
    __asm ("movapd xmm0, xmm1");
    sqrt (rdi);
label_0:
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d730 */
#include <stdint.h>
 
int64_t camlUnix_close_process_full_1039 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_28h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    *((rsp + 8)) = rdi;
    rdx = rbx;
    *((rsp + 0x18)) = rdx;
    rsi = rax;
    *(rsp) = rsi;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0xc03;
            *(rbx) = rsi;
            *((rbx + 8)) = rdx;
            *((rbx + 0x10)) = rdi;
            rax = *(loc.camlUnix__174);
            rax = camlUnix_find_proc_id_1023 ();
            *((rsp + 0x10)) = rax;
            rdi = *(rsp);
            rax = *(reloc.caml_ml_close_channel);
            caml_c_call ();
            rax = void (*0x40d7b0)() ();
            rdi = *(reloc.caml_exn_Sys_error);
            rbx = *(rax);
            if (rbx != rdi) {
                rax = caml_raise_exn ();
                r14 = rsp;
                rax = *((rsp + 0x28));
                camlPervasives_close_out_233 ();
            }
            rdi = *((rsp + 8));
            rax = *(reloc.caml_ml_close_channel);
            caml_c_call ();
            rax = *((rsp + 0x10));
            rax = camlUnix_waitpid_non_intr_1027 ();
            rax += 8;
            rax = *(rax);
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40aaf0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1587 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_tcflow);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bf30 */
#include <stdint.h>
 
int64_t camlUnix_fun_1835 (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = rdi;
    rcx = rsi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_setsockopt);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ae30 */
#include <stdint.h>
 
int64_t camlUnix_fun_1639 (void) {
    rdi = rax;
    rax = *(reloc.unix_getgrnam);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4306a0 */
#include <stdint.h>
 
int64_t caml_init_gc (int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rsi += 0x1ff;
    *((rsp - 0x30)) = rbx;
    *((rsp - 0x28)) = rbp;
    rsi >>= 9;
    *((rsp - 0x20)) = r12;
    *((rsp - 0x18)) = r13;
    rax = rsi;
    *((rsp - 0x10)) = r14;
    *((rsp - 8)) = r15;
    rax <<= 9;
    rbx = rdi;
    r12 = rdx;
    r13 = rcx;
    r15 = r8;
    r14d = 0x2000;
    if (rax > 0x3ff) {
        r14 = rsi;
        r14 <<= 0xc;
        rbp >>= 0xa;
    }
    rdi = r14 + rbx*8;
    caml_page_table_initialize ();
    rdi = rbx;
    if (rbx > 0xfff) {
        goto label_1;
    }
    edi = 0x1000;
    do {
        rdi <<= 3;
label_0:
        r12 += 0x1ff;
        r12 >>= 9;
        caml_set_minor_heap_size ();
        rdx = r12;
        eax = 0x2000;
        r12 <<= 0xc;
        rdx <<= 9;
        rdi = r14;
        *(obj.caml_percent_max) = r15;
        if (rdx > 0x3ff) {
            rax = r12;
        }
        *(obj.caml_major_heap_increment) = rax;
        eax = 1;
        if (r13 == 0) {
            r13 = rax;
        }
        *(obj.caml_percent_free) = r13;
        caml_init_major_heap ();
        rdx = caml_minor_heap_size;
        esi = "Initial minor heap size: %luk bytes\n";
        edi = 0x20;
        rdx >>= 0xa;
        caml_gc_message ();
        rdx = rbp;
        esi = "Initial major heap size: %luk bytes\n";
        edi = 0x20;
        caml_gc_message ();
        rdx = caml_percent_free;
        esi = "Initial space overhead: %lu%%\n";
        edi = 0x20;
        caml_gc_message ();
        rdx = caml_percent_max;
        esi = "Initial max overhead: %lu%%\n";
        edi = 0x20;
        caml_gc_message ();
        rdx = caml_major_heap_increment;
        esi = "Initial heap increment: %luk bytes\n";
        edi = 0x20;
        rdx >>= 0xa;
        caml_gc_message ();
        rdx = caml_allocation_policy;
        rbx = *((rsp + 8));
        esi = "Initial allocation policy: %d\n";
        rbp = *((rsp + 0x10));
        r12 = *((rsp + 0x18));
        edi = 0x20;
        r13 = *((rsp + 0x20));
        r14 = *((rsp + 0x28));
        r15 = *((rsp + 0x30));
        void (*0x4253a0)() ();
label_1:
    } while (rbx <= 0x10000000);
    edi = 0x80000000;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417520 */
#include <stdint.h>
 
void camlString_rindex_153 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rbx;
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rsi = *((rax + rbx));
    rbx -= rsi;
    rbx = rbx + rbx - 1;
    return camlString_rindex_rec_149 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410290 */
#include <stdint.h>
 
int64_t camlPervasives_unsafe_really_input_253 (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    rsi = arg2;
    rdi = arg1;
    do {
        rdx = rdi;
        rcx = rsi;
        if (rcx <= 1) {
            rax = 1;
            return rax;
        }
        *(rsp) = rcx;
        *((rsp + 8)) = rdx;
        *((rsp + 0x18)) = rbx;
        *((rsp + 0x10)) = rax;
        rdi = rax;
        rsi = rbx;
        rax = *(reloc.caml_ml_input);
        rax = caml_c_call ();
        if (rax == 1) {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_1;
            }
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_End_of_file);
            *(rax) = rbx;
            rax = caml_raise_exn ();
        }
        rsi = *(rsp);
        rsi -= rax;
        rsi++;
        rbx = *((rsp + 8));
        rdi = rbx + rax - 1;
        rax = *((rsp + 0x10));
        rbx = *((rsp + 0x18));
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415a00 */
#include <stdint.h>
 
int64_t camlList_mem_189 (void) {
    int64_t var_8h;
    do {
        if (rbx == 1) {
            goto label_0;
        }
        *(rsp) = rax;
        rdi = *((rbx + 8));
        *((rsp + 8)) = rdi;
        rdi = *(rbx);
        rsi = rax;
        rax = *(reloc.caml_compare);
        rax = caml_c_call ();
        if (rax == 1) {
            rax = 3;
            return rax;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
    } while (1);
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4341f0 */
#include <stdint.h>
 
void caml_init_custom_operations (void) {
    edi = caml_int32_ops;
    caml_register_custom_operations ();
    edi = caml_nativeint_ops;
    caml_register_custom_operations ();
    edi = caml_int64_ops;
    return caml_register_custom_operations ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40adf0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1635 (void) {
    rdi = rax;
    rax = *(reloc.unix_getgrgid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fa90 */
#include <stdint.h>
 
int64_t camlPervasives_fun_428 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_input_int);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4104b0 */
#include <stdint.h>
 
uint64_t camlPervasives_print_float_296 (void) {
    rax = camlPervasives_string_of_float_164 ();
    rbx = rax;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0xb8));
    return camlPervasives_output_string_215 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x417430 */
#include <stdint.h>
 
void camlString_index_141 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rbx;
    rdi = 1;
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rdx = *((rax + rbx));
    rbx -= rdx;
    rbx = rbx + rbx + 1;
    return camlString_index_rec_136 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b5a0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1757 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_ftruncate);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415c20 */
#include <stdint.h>
 
int64_t camlList_remove_assoc_217 (void) {
    int64_t var_8h;
    int64_t var_10h;
    do {
        if (rbx == 1) {
            goto label_0;
        }
        *(rsp) = rax;
        rdi = *((rbx + 8));
        *((rsp + 0x10)) = rdi;
        rbx = *(rbx);
        *((rsp + 8)) = rbx;
        rdi = *(rbx);
        rsi = rax;
        rax = *(reloc.caml_compare);
        rax = caml_c_call ();
        if (rax == 1) {
            rax = *((rsp + 0x10));
            return rax;
        }
        rax = *(rsp);
        rbx = *((rsp + 0x10));
        rax = camlList_remove_assoc_217 ();
    } while (1);
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *((rsp + 8));
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            return rax;
label_0:
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433c40 */
#include <stdint.h>
 
int64_t caml_final_do_young_roots (int64_t arg1) {
    rdi = arg1;
    r12 = rdi;
    rbp = old;
    if (rbp >= *(obj.young)) {
        goto label_0;
    }
    rbx = rbp + rbp*2;
    rbx <<= 3;
    do {
        rax = rbx;
        rax += *(obj.final_table);
        rbp++;
        rsi = rax;
        rdi = *(rax);
        void (*r12)() ();
        rax = rbx;
        rax += *(obj.final_table);
        rbx += 0x18;
        rsi = rax + 8;
        rdi = *((rax + 8));
        void (*r12)() ();
    } while (*(obj.young) > rbp);
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a7a0 */
#include <stdint.h>
 
int64_t camlBuffer_advance_to_non_alpha_136 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    rdx = rbx;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x10f7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlBuffer__advance_139);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = rsi;
            rax = *((rsi - 8));
            rax >>= 0xa;
            rax = rax*8 - 1;
            rsi = *((rsi + rax));
            rax -= rsi;
            rbx = rax + rax + 1;
            rax = rdx;
            void (*0x419e30)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a6b0 */
#include <stdint.h>
 
void caml_abs_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    xmm1 = *(0x00436600);
    __asm ("andpd xmm0, xmm1");
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b560 */
#include <stdint.h>
 
int64_t camlUnix_fun_1753 (void) {
    rdi = rax;
    rax = *(reloc.unix_lstat);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e130 */
#include <stdint.h>
 
uint64_t caml_marshal_data_size (int64_t arg2) {
    rsi = arg2;
    rsi >>= 1;
    *(obj.intern_input_malloced) = 0;
    rdi = rsi + rdi;
    rax = rdi + 4;
    *(obj.intern_src) = rax;
    edx = *(rdi);
    esi = *((rax - 1));
    rdx <<= 0x18;
    rsi += rdx;
    edx = *((rax - 3));
    eax = *((rax - 2));
    edx <<= 0x10;
    eax <<= 8;
    rcx = (int64_t) edx;
    rax = (int64_t) eax;
    rdx = rsi + rcx;
    rax = rdx + rax;
    if (eax == 0x8495a6be) {
        rdi += 8;
        *(obj.intern_src) = rdi;
        eax = *((rdi - 4));
        edx = *((rdi - 1));
        rax <<= 0x18;
        rax += rdx;
        edx = *((rdi - 3));
        edx <<= 0x10;
        rdx = (int64_t) edx;
        rdx = rax + rdx;
        eax = *((rdi - 2));
        eax <<= 8;
        rax = (int64_t) eax;
        rax = rdx + rax;
        rax = rax + rax + 1;
        return rax;
    }
    edi = "Marshal.data_size: bad object";
    return caml_failwith ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ce00 */
#include <stdint.h>
 
int64_t caml_serialize_int_2 (int64_t arg1) {
    rdi = arg1;
    rax = extern_ptr;
    ebx = edi;
    rdx = rax + 2;
    if (rdx > *(obj.extern_limit)) {
        edi = 2;
        grow_extern_output ();
        rax = extern_ptr;
        rdx = rax + 2;
    }
    ecx = ebx;
    *((rax + 1)) = bl;
    ecx >>= 8;
    *(rax) = cl;
    *(obj.extern_ptr) = rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d970 */
#include <stdint.h>
 
int64_t camlUnix_establish_server_1052 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    *((rsp + 0x10)) = rax;
    rax = rbx;
    *(rsp) = rax;
    rax = camlUnix_domain_of_sockaddr_555 ();
    rdx = 1;
    rsi = 1;
    rdi = rax;
    rax = *(reloc.unix_socket);
    rax = caml_c_call ();
    *((rsp + 8)) = rax;
    rdi = 3;
    rbx = 5;
    camlUnix_setsockopt_672 ();
    rdi = *((rsp + 8));
    rsi = *(rsp);
    rax = *(reloc.unix_bind);
    caml_c_call ();
    rsi = 0xb;
    rdi = *((rsp + 8));
    rax = *(reloc.unix_listen);
    caml_c_call ();
    do {
label_0:
        rax = *((rsp + 8));
        rax = camlUnix_accept_non_intr_1050 ();
        rax = *(rax);
        *((rsp + 0x18)) = rax;
        rdi = 1;
        rax = *(reloc.unix_fork);
        rax = caml_c_call ();
        *(rsp) = rax;
        if (rax == 1) {
            goto label_1;
        }
        rdi = *((rsp + 0x18));
        rax = *(reloc.unix_close);
        caml_c_call ();
        rax = *(rsp);
        camlUnix_waitpid_non_intr_1027 ();
    } while (1);
label_1:
    rdi = 1;
    rax = *(reloc.unix_fork);
    rax = caml_c_call ();
    if (rax != 1) {
        rax = 1;
        camlPervasives_exit_350 ();
    }
    rdi = *((rsp + 8));
    rax = *(reloc.unix_close);
    caml_c_call ();
    rax = *((rsp + 0x18));
    camlUnix_try_set_close_on_exec_394 ();
    rdi = *((rsp + 0x18));
    rax = *(reloc.caml_ml_open_descriptor_in);
    rax = caml_c_call ();
    *(rsp) = rax;
    rdi = *((rsp + 0x18));
    rax = *(reloc.caml_ml_open_descriptor_out);
    rax = caml_c_call ();
    rbx = rax;
    rax = *(rsp);
    rdi = *((rsp + 0x10));
    caml_apply2 ();
    rax = 1;
    camlPervasives_exit_350 ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bdd0 */
#include <stdint.h>
 
int64_t camlUnix_recvfrom_590 (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rcx = rdi;
    r8 = rsi;
    r9 = rdx;
    if (rcx >= 1) {
        if (r8 < 1) {
            goto label_0;
        }
        rdi = *((rbx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rbx + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= r8;
        rdi += 2;
        if (rcx > rdi) {
            goto label_0;
        }
        rdi = rax;
        rsi = rbx;
        rdx = rcx;
        rcx = r8;
        r8 = r9;
        rax = *(reloc.unix_recvfrom);
        caml_c_call ();
        return rax;
    }
label_0:
    rax = *(loc.camlUnix__203);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a690 */
#include <stdint.h>
 
void caml_sub_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    __asm ("subsd xmm0, qword [rsi]");
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a5f0 */
#include <stdint.h>
 
void camlBuffer_add_buffer_115 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    rsi = *((rbx + 8));
    rdi = 1;
    rbx = *(rbx);
    return camlBuffer_add_substring_104 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c920 */
#include <stdint.h>
 
int64_t camlUnix_system_917 (void) {
    *(rsp) = rax;
    rdi = 1;
    rax = *(reloc.unix_fork);
    rax = caml_c_call ();
    if (rax != 1) {
        rdi = 1;
        rsi = rax;
        rax = *(reloc.unix_waitpid);
        rax = caml_c_call ();
        rax += 8;
        rax = *(rax);
        return rax;
    }
    fcn_0040c97c (rdi, rsi, rdx, rcx, r8, r9);
    rax = 0xff;
    return camlPervasives_exit_350 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c97c */
#include <stdint.h>
 
int64_t fcn_0040c97c (int64_t arg_10h, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r14 = rsp;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0xc00;
            rax = *(loc.camlUnix__188);
            *(rsi) = rax;
            rax = *(loc.camlUnix__189);
            *((rsi + 8)) = rax;
            rax = *((rsp + 0x10));
            *((rsi + 0x10)) = rax;
            rdi = *(loc.camlUnix__187);
            rax = *(reloc.unix_execv);
            caml_c_call ();
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429660 */
#include <stdint.h>
 
void caml_int32_to_float (int64_t arg7) {
    xmm0 = arg7;
    __asm ("cvtsi2sd xmm0, dword [rdi + 8]");
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42cd30 */
#include <stdint.h>
 
uint64_t caml_serialize_block_2 (int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    rsi = arg2;
    rdi = arg1;
    rbx = rdi;
    rdi = rsi + rsi;
    rcx = extern_ptr;
    rax = rcx + rdi;
    if (*(obj.extern_limit) < rax) {
        goto label_1;
    }
label_0:
    if (rsi <= 0) {
        goto label_2;
    }
    rdx = rsi;
    eax = 0;
    do {
        edi = *((rbx + rax));
        r8d = *((rbx + rax + 1));
        *((rcx + rax + 1)) = dil;
        *((rcx + rax)) = r8b;
        rax += 2;
        rdx--;
    } while (rdx != 0);
    rcx = rcx + rsi*2;
label_2:
    *(obj.extern_ptr) = rcx;
    return rax;
label_1:
    *((rsp + 8)) = rsi;
    grow_extern_output ();
    rcx = extern_ptr;
    rsi = *((rsp + 8));
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b760 */
#include <stdint.h>
 
uint64_t caml_seek_in (signed int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    rbx = rdi;
    *((rsp - 8)) = r12;
    rdx = *((rdi + 8));
    r12 = rdi + 0x50;
    rcx = *((rdi + 0x20));
    rax = r12 + rdx;
    rax -= rcx;
    if (rax <= rsi) {
        if (rdx >= rsi) {
            goto label_0;
        }
    }
    edi = *(rbx);
    edx = 0;
    rsi = rbp;
    rax = lseek64 ();
    if (rax != rbp) {
        edi = 1;
        caml_sys_error ();
    }
    *((rbx + 8)) = rbp;
    *((rbx + 0x20)) = r12;
    *((rbx + 0x18)) = r12;
    do {
        rbx = *(rsp);
        rbp = *((rsp + 8));
        r12 = *((rsp + 0x10));
        return rax;
label_0:
        rbp -= rdx;
        rcx += rbp;
        *((rdi + 0x18)) = rcx;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bb00 */
#include <stdint.h>
 
int64_t camlUnix_single_write_275 (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = rdi;
    rcx = rsi;
    if (rdx >= 1) {
        if (rcx < 1) {
            goto label_0;
        }
        rdi = *((rbx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rbx + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= rcx;
        rdi += 2;
        if (rdx > rdi) {
            goto label_0;
        }
        rdi = rax;
        rsi = rbx;
        rax = *(reloc.unix_single_write);
        caml_c_call ();
        return rax;
    }
label_0:
    rax = *(loc.camlUnix__205);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4346b0 */
#include <stdint.h>
 
uint64_t caml_search_dll_in_path (char * s, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rsi = s;
    rdi = arg1;
    *((rsp - 0x18)) = rbx;
    *((rsp - 0x10)) = rbp;
    *((rsp - 8)) = r12;
    rdi = rsi;
    r12 = rsi;
    strlen (rdi);
    rdi = rax + 4;
    rax = caml_stat_alloc ();
    rbx = rax;
    strcpy (rax, r12);
    strlen (rbx);
    rsi = rbx;
    rdi = rbp;
    *((rbx + rax)) = 0x6f732e;
    rax = caml_search_in_path ();
    rdi = rbx;
    caml_stat_free ();
    rax = rbp;
    rbx = *(rsp);
    rbp = *((rsp + 8));
    r12 = *((rsp + 0x10));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4173a0 */
#include <stdint.h>
 
int64_t camlString_uncapitalize_134 (void) {
    rbx = rax;
    rax = *(reloc.camlChar);
    rax = *((rax + 0x10));
    return camlString_apply1_128 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415bf0 */
#include <stdint.h>
 
int64_t camlList_mem_assq_212 (void) {
    do {
        if (rbx == 1) {
            goto label_0;
        }
        rsi = *((rbx + 8));
        rdi = *(rbx);
        rdi = *(rdi);
        if (rdi == rax) {
            rax = 3;
            return rax;
        }
        rbx = rsi;
    } while (1);
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d7f0 */
#include <stdint.h>
 
uint64_t camlPrintf_format_string_108 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    *(rsp) = rbx;
    rax = camlPrintf_parse_string_conversion_95 ();
    rdi = *((rax + 8));
    rbx = *(rax);
    rsi = *(rsp);
    rax = *((rsi - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rdx = *((rsi + rax));
    rax -= rdx;
    rcx = rax + rax + 1;
    rdx = 1;
    rax = 0x41;
    return camlPrintf_pad_string_100 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427c40 */
#include <stdint.h>
 
uint64_t caml_add_to_heap (int64_t arg1) {
    rdi = arg1;
    rdx = caml_stat_heap_size;
    rbx = rdi;
    rdx += *((rdi - 0x10));
    esi = "Growing heap to %luk bytes\n";
    edi = 4;
    rdx >>= 0xa;
    caml_gc_message ();
    rdx = rbx;
    rdx += *((rbx - 0x10));
    rsi = rbx;
    edi = 1;
    eax = caml_page_table_add ();
    edx = eax;
    eax = 0xffffffff;
    if (edx != 0) {
        goto label_1;
    }
    rax = caml_heap_start;
    if (rbx <= rax) {
        goto label_2;
    }
    if (rax == 0) {
        goto label_2;
    }
    do {
        rdx = rax - 8;
        rax = *((rax - 8));
        if (rbx <= rax) {
label_0:
            *((rbx - 8)) = rax;
            *(rdx) = rbx;
            eax = 0;
            rdx = caml_stat_heap_size;
            rdx += *((rbx - 0x10));
            *(obj.caml_stat_heap_chunks)++;
            *(obj.caml_stat_heap_size) = rdx;
            if (rdx > *(obj.caml_stat_top_heap_size)) {
                *(obj.caml_stat_top_heap_size) = rdx;
            }
label_1:
            return rax;
        }
    } while (rax != 0);
    goto label_0;
label_2:
    edx = caml_heap_start;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410810 */
#include <stdint.h>
 
int64_t camlPervasives_fun_511 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_pos_out_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d430 */
#include <stdint.h>
 
int64_t camlPrintf_fun_714 (void) {
    rax = *(loc.camlPrintf__56);
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429b70 */
#include <stdint.h>
 
int64_t caml_int64_or (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = *((rsi + 8));
    rax |= *((rdi + 8));
    rdi = rax;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427610 */
#include <stdint.h>
 
int64_t caml_free_dependent_memory (uint32_t arg1) {
    rdi = arg1;
    rax = caml_dependent_size;
    rdi >>= 3;
    if (rdi <= rax) {
        rax -= rdi;
        *(obj.caml_dependent_size) = rax;
        return rax;
    }
    *(obj.caml_dependent_size) = 0;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434520 */
#include <stdint.h>
 
void caml_dlsym (void) {
    return dlsym ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40af90 */
#include <stdint.h>
 
int64_t camlUnix_fun_1661 (void) {
    rdi = rax;
    rax = *(reloc.unix_getitimer);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40bb90 */
#include <stdint.h>
 
int64_t camlUnix_fun_1821 (void) {
    rdi = rax;
    rax = *(reloc.unix_lstat_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x419460 */
#include <stdint.h>
 
int64_t camlHashtbl_find_all_133 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r12 = rax;
    rdx = rbx;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rbx = r15 + 8;
            *((rbx - 8)) = 0xcf7;
            rax = *(reloc.camlHashtbl__find_in_bucket_136);
            *(rbx) = rax;
            *((rbx + 8)) = 3;
            *((rbx + 0x10)) = rdx;
            rax = *((r12 + 8));
            rbp = *((rax - 8));
            rbp >>= 0xa;
            if (rbp != 0) {
                rsi = 0xc9;
                rdi = 0x15;
                rax = caml_hash_univ_param ();
                rax >>= 1;
                rcx = rbp;
                __asm ("cqo");
                rax = rdx:rax / rcx;
                rdx = rdx:rax % rcx;
            } else {
                rax = *(reloc.caml_bucket_Division_by_zero);
                caml_raise_exn ();
            }
            rdx <<= 1;
            rdx++;
            rdi = *((r12 + 8));
            rax = *((rdi - 8));
            rax >>= 9;
            if (rax <= rdx) {
                goto label_0;
            }
            rax = *((rdi + rdx*4 - 4));
            void (*0x4180f0)() ();
        }
        caml_call_gc ();
    } while (1);
label_0:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b010 */
#include <stdint.h>
 
int64_t camlUnix_fun_1669 (void) {
    rdi = rax;
    rax = *(reloc.unix_alarm);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ba20 */
#include <stdint.h>
 
int64_t camlUnix_read_265 (int64_t arg6, int64_t arg5, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rdi;
    rcx = rsi;
    if (rdx >= 1) {
        if (rcx < 1) {
            goto label_0;
        }
        rdi = *((rbx - 8));
        rdi >>= 0xa;
        rdi = rdi*8 - 1;
        rsi = *((rbx + rdi));
        rdi -= rsi;
        rdi <<= 1;
        rdi -= rcx;
        rdi += 2;
        if (rdx > rdi) {
            goto label_0;
        }
        rdi = rax;
        rsi = rbx;
        rax = *(reloc.unix_read);
        caml_c_call ();
        return rax;
    }
label_0:
    rax = *(loc.camlUnix__207);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x433ca0 */
#include <stdint.h>
 
int64_t caml_final_empty_young (void) {
    rax = young;
    *(obj.old) = rax;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e720 */
#include <stdint.h>
 
int64_t camlPrintf_get_cont_440 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    *((rsp + 8)) = rax;
    rax = rbx;
    *(rsp) = rax;
    rdi = *((rax + 8));
    rbx = 1;
    rax = *(rax);
    camlString_sub_74 ();
    rbx = *(rsp);
    *((rbx + 8)) = 1;
    rbx = *((rsp + 8));
    rdi = *(rbx);
    return void (*rdi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410200 */
#include <stdint.h>
 
int64_t camlPervasives_open_in_bin_244 (void) {
    rdi = rax;
    rbx = 1;
    rax = *(loc.camlPervasives__89);
    return camlPervasives_open_in_gen_238 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x422ee0 */
#include <stdint.h>
 
int64_t unix_error_of_code (int64_t arg1) {
    rdi = arg1;
    ebx = edi;
    ecx = 0xffffffff;
    edx = 0x44;
    rsi = *(reloc.error_table);
    eax = cst_to_constr ();
    edx = eax;
    rax = (int64_t) eax;
    if (edx == 0xffffffff) {
        esi = 0;
        edi = 1;
        caml_alloc_small ();
        rbx = (int64_t) ebx;
        rdx = rbx + rbx + 1;
        *(rax) = rdx;
    }
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4234cc */
#include <stdint.h>
 
int64_t cst_to_constr (int64_t arg4, signed int64_t arg3, int64_t arg2, uint32_t arg1) {
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    if (edx <= 0) {
        goto label_0;
    }
    r8 = rsi;
    eax = 0;
    if (*(rsi) != edi) {
        goto label_1;
    }
    while (edx > eax) {
        esi = *((r8 + 4));
        r8 += 4;
        if (esi == edi) {
            rax = (int64_t) eax;
            rax = rax + rax + 1;
            return rax;
        }
label_1:
        eax++;
    }
label_0:
    rcx = (int64_t) ecx;
    rax = rcx + rcx + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b600 */
#include <stdint.h>
 
int64_t camlUnix_fun_1763 (void) {
    rdi = rax;
    rax = *(reloc.caml_channel_descriptor);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40fff0 */
#include <stdint.h>
 
int64_t camlPervasives_open_out_bin_205 (void) {
    rdi = rax;
    rbx = 0x36d;
    rax = *(loc.camlPervasives__93);
    return camlPervasives_open_out_gen_199 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x421f21 */
#include <stdint.h>
 
int64_t alloc_inet_addr (int64_t arg1) {
    rdi = arg1;
    rbx = rdi;
    edi = 4;
    caml_alloc_string ();
    edx = *(rbx);
    *(rax) = edx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40afd0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1665 (void) {
    rdi = rax;
    rax = *(reloc.unix_times);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b1c0 */
#include <stdint.h>
 
int64_t caml_array_set_addr (int64_t arg3, uint32_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *((rsp - 0x10)) = rbp;
    *((rsp - 0x18)) = rbx;
    *((rsp - 8)) = r12;
    rsi >>= 1;
    if (rsi < 0) {
        goto label_3;
    }
    rax = *((rdi - 8));
    rax >>= 0xa;
    if (rsi >= rax) {
        goto label_3;
    }
    rbx = rdi + rsi*8;
    r12 = *(rbx);
    rdi = rbx;
    *(rbx) = rdx;
    al = caml_page_table_lookup ();
    if ((al & 1) == 0) {
        goto label_0;
    }
    edx = caml_gc_phase;
    if (edx == 0) {
        goto label_4;
    }
    while ((bpl & 1) == 0) {
        rax = caml_young_end;
        if (rbp < rax) {
            rdx = caml_young_start;
            if (rbp <= rdx) {
                goto label_0;
            }
            if ((r12b & 1) == 0) {
                goto label_5;
            }
label_1:
            rax = .comment;
            if (rax >= *(0x00652440)) {
                goto label_6;
            }
label_2:
            *(rax) = rbx;
            rax += 8;
            *(0x00652438) = rax;
        }
label_0:
        eax = 1;
        rbx = *(rsp);
        rbp = *((rsp + 8));
        r12 = *((rsp + 0x10));
        return rax;
label_4:
        esi = 0;
        rdi = r12;
        rax = caml_darken ();
    }
    goto label_0;
label_5:
    if (rax <= r12) {
        goto label_1;
    }
    if (rdx < r12) {
        goto label_0;
    }
    goto label_1;
label_6:
    edi = caml_ref_table;
    caml_realloc_ref_table ();
    rax = .comment;
    goto label_2;
label_3:
    return caml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x424c60 */
#include <stdint.h>
 
int64_t caml_process_pending_signals (void) {
    rax = caml_signals_are_pending;
    if (rax == 0) {
        goto label_1;
    }
    *(obj.caml_signals_are_pending) = 0;
    ebx = 0;
    while (rdx == 0) {
        ebx++;
        if (ebx == 0x41) {
            goto label_1;
        }
label_0:
        rax = (int64_t) ebx;
        rdx = *((rax*8 + obj.caml_pending_signals));
    }
    esi = 0;
    edi = ebx;
    ebx++;
    *((rax*8 + obj.caml_pending_signals)) = 0;
    rax = caml_execute_signal ();
    if (ebx != 0x41) {
        goto label_0;
    }
label_1:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429be0 */
#include <stdint.h>
 
int64_t caml_int64_div (uint32_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi = *((rsi + 8));
    rdx = *((rdi + 8));
    if (rsi == 0) {
        goto label_0;
    }
    while (rdx != rcx) {
        rax = rdx;
        rdx >>= 0x3f;
        rax = rdx:rax / rsi;
        rdx = rdx:rax % rsi;
        rdi = rax;
        void (*0x429870)() ();
        rcx = 0x8000000000000000;
    }
    rax = rdi;
    return rax;
label_0:
    return caml_raise_zero_divide ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e050 */
#include <stdint.h>
 
void caml_deserialize_float_4 (void) {
    int64_t var_ch;
    esi = 1;
    rdi = rsp + 0xc;
    caml_deserialize_block_4 ();
    xmm0 = *((rsp + 0xc));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x432740 */
#include <stdint.h>
 
uint64_t caml_callback2 (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = caml_callback2_exn ();
    rdx = rax;
    edx &= 3;
    if (rdx != 2) {
        return rax;
    }
    rdi = rax;
    rdi &= 0xfffffffffffffffc;
    return caml_raise ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ac20 */
#include <stdint.h>
 
int64_t caml_string_get (uint32_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rsi >>= 1;
    if (rsi >= 0) {
        rax = *((rdi - 8));
        rax >>= 0xa;
        rdx = rax*8;
        rax = rdx - 1;
        rdx = *((rdi + rdx - 1));
        rax -= rdx;
        if (rsi >= rax) {
            goto label_0;
        }
        eax = *((rsi + rdi));
        rax = rax + rax + 1;
        return rax;
    }
label_0:
    return caml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4106a0 */
#include <stdint.h>
 
int64_t camlPervasives_prerr_newline_311 (void) {
    rsi = 0x15;
    rax = *(reloc.camlPervasives);
    rdi = *((rax + 0xc0));
    rax = *(reloc.caml_ml_output_char);
    caml_c_call ();
    rax = *(reloc.camlPervasives);
    rdi = *((rax + 0xc0));
    rax = *(reloc.caml_ml_flush);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42aba0 */
#include <stdint.h>
 
uint64_t caml_string_lessequal (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = caml_string_compare ();
    al = (rax < 2) ? 1 : 0;
    eax = (int32_t) al;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429dd0 */
#include <stdint.h>
 
int64_t caml_int32_div (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    ecx = *((rsi + 8));
    edx = *((rdi + 8));
    if (ecx == 0) {
        goto label_0;
    }
    while (edx != 0x80000000) {
        eax = edx;
        edx >>= 0x1f;
        eax = edx:eax / ecx;
        edx = edx:eax % ecx;
        edi = eax;
        void (*0x429c80)() ();
    }
    rax = rdi;
    return rax;
label_0:
    return caml_raise_zero_divide ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415a60 */
#include <stdint.h>
 
int64_t camlList_memq_193 (void) {
    do {
        if (rbx == 1) {
            goto label_0;
        }
        rsi = *((rbx + 8));
        rdi = *(rbx);
        if (rdi == rax) {
            rax = 3;
            return rax;
        }
        rbx = rsi;
    } while (1);
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f060 */
#include <stdint.h>
 
uint64_t caml_input_val (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_98h;
    int64_t var_8h_2;
    int64_t var_10h_2;
    int64_t var_18h_2;
    int64_t var_20h_2;
    int64_t var_28h_2;
    int64_t var_30h;
    rdi = arg1;
    *((rsp - 0x28)) = rbx;
    *((rsp - 0x20)) = rbp;
    rbx = rdi;
    *((rsp - 0x18)) = r12;
    *((rsp - 0x10)) = r13;
    *((rsp - 8)) = r14;
    eax = caml_channel_binary_mode ();
    if (eax != 0) {
        rdi = rbx;
        eax = caml_getword ();
        if (eax != 0x8495a6be) {
            goto label_0;
        }
        rdi = rbx;
        eax = caml_getword ();
        rdi = rbx;
        r14d = eax;
        eax = caml_getword ();
        rdi = rbx;
        r12d = eax;
        caml_getword ();
        rdi = rbx;
        eax = caml_getword ();
        rdi = r14;
        r13d = eax;
        rax = caml_stat_alloc ();
        rdx = r14;
        rsi = rax;
        rdi = rbx;
        eax = caml_really_getblock ();
        if (eax == 0) {
            goto label_1;
        }
        esi = r12d;
        *(obj.intern_input) = rbp;
        rdi = r13;
        *(obj.intern_input_malloced) = 1;
        *(obj.intern_src) = rbp;
        intern_alloc ();
        rdi = rsp + 8;
        intern_rec ();
        rdi = r13;
        intern_add_to_heap ();
        rdi = intern_input;
        caml_stat_free ();
        rdi = intern_obj_table;
        if (rdi != 0) {
            caml_stat_free ();
        }
        rax = *((rsp + 8));
        rbx = *((rsp + 0x10));
        rbp = *((rsp + 0x18));
        r12 = *((rsp + 0x20));
        r13 = *((rsp + 0x28));
        r14 = *((rsp + 0x30));
        return rax;
    }
    edi = "input_value: not a binary channel";
    caml_failwith ();
label_1:
    rdi = rbp;
    caml_stat_free ();
    edi = "input_value: truncated object";
    caml_failwith ();
label_0:
    edi = "input_value: bad object";
    return caml_failwith ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41da20 */
#include <stdint.h>
 
int64_t camlPrintf_extract_format_float_138 (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    *(rsp) = rax;
    rax = rbx;
    rbx = rdi;
    rdi = rsi;
    rsi = rdx;
    camlPrintf_extract_format_113 ();
    rbx = *(rsp);
    if (rbx != 0x8d) {
        return rax;
    }
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rdi = *((rax + rbx));
    rbx -= rdi;
    rsi = rbx + rbx - 1;
    rsi >>= 1;
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rdi = *((rax + rbx));
    rbx -= rdi;
    if (rbx > rsi) {
        rbx = 0x67;
        *((rax + rsi)) = bl;
        return rax;
    }
    rax = caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b640 */
#include <stdint.h>
 
int64_t camlUnix_fun_1767 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_open_descriptor_out);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d450 */
#include <stdint.h>
 
int64_t camlPrintf_fun_727 (void) {
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42fe00 */
#include <stdint.h>
 
uint64_t caml_parse_engine (int64_t arg4, uint32_t arg3, int64_t arg2, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    uint32_t var_18h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_50h;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rdx >>= 1;
    *((rsp - 0x30)) = rbx;
    *((rsp - 0x28)) = rbp;
    *((rsp - 0x20)) = r12;
    *((rsp - 0x18)) = r13;
    *((rsp - 0x10)) = r14;
    *((rsp - 8)) = r15;
    rbx = rsi;
    r12 = rcx;
    if (edx <= 5) {
        goto label_19;
    }
label_0:
    eax = 3;
    do {
label_2:
        rbx = *((rsp + 0x28));
        rbp = *((rsp + 0x30));
        r12 = *((rsp + 0x38));
        r13 = *((rsp + 0x40));
        r14 = *((rsp + 0x48));
        r15 = *((rsp + 0x50));
        return eax;
label_19:
        /* switch table (6 cases) at 0x436ac8 */
        r13 = *((rsi + 0x68));
        r15 = *((rsi + 0x70));
        rdx = *(rsi);
        r14 = *((rsi + 0x78));
        r13 >>= 1;
        r15 >>= 1;
        r13 = (int64_t) r13d;
        r14 >>= 1;
        rax = r13*8;
        *((rsp + 0x18)) = rax;
        rax = (int64_t) r15d;
        rdi = *((rsp + 0x18));
        rax += rax;
        rcx = rax + 1;
        *((rsp + 0x10)) = rax;
        *((rdx + r13*8)) = rcx;
        rdi += *((rsi + 8));
        rsi = r12;
        caml_modify ();
        r12 = *((rbx + 0x50));
        rdi = *((rbx + 0x18));
        r12 >>= 1;
        r12 = (int64_t) r12d;
        rsi = *((rdi + r12*8));
        rdi += *((rsp + 0x18));
        caml_modify ();
        rax = *((rsp + 0x10));
        rcx = rax;
        if (r13 > r12) {
            goto label_20;
        }
label_3:
        rax = *((rbp + 0x28));
        r12d = *((rax + rcx));
        if (r12d != 0) {
            goto label_10;
        }
label_1:
        rdx = *((rbx + 0x30));
        rdx >>= 1;
        if (edx < 0) {
            goto label_21;
        }
label_4:
        rax = *((rbp + 0x38));
        eax = *((rax + rcx));
        r12d = eax;
        r12d += edx;
        if (r12d >= 0) {
            if (eax == 0) {
                goto label_22;
            }
            rax = *((rbp + 0x50));
            rax >>= 1;
            if (r12d > eax) {
                goto label_22;
            }
            rax = *((rbp + 0x60));
            r12 = (int64_t) r12d;
            r9 = r12 + r12;
            eax = *((rax + r12*2));
            if (eax == edx) {
                goto label_23;
            }
        }
label_22:
        rax = *((rbp + 0x40));
        eax = *((rax + rcx));
        ecx = eax;
        ecx += edx;
        if (ecx >= 0) {
            if (eax == 0) {
                goto label_24;
            }
            rax = *((rbp + 0x50));
            rax >>= 1;
            if (ecx > eax) {
                goto label_24;
            }
            rax = *((rbp + 0x60));
            rcx = (int64_t) ecx;
            eax = *((rax + rcx*2));
            if (eax == edx) {
                goto label_25;
            }
        }
label_24:
        if (r14d > 0) {
            goto label_26;
        }
        rax = r13 + r13 + 1;
        r15 = (int64_t) r15d;
        r14 = (int64_t) r14d;
        *((rbx + 0x68)) = rax;
        rax = r15 + r15 + 1;
        *((rbx + 0x70)) = rax;
        rax = r14 + r14 + 1;
        *((rbx + 0x78)) = rax;
        eax = 0xb;
    } while (1);
    r13 = *((rsi + 0x68));
    r15 = *((rsi + 0x70));
    r14 = *((rsi + 0x78));
    r13 >>= 1;
    r15 >>= 1;
    r13 = (int64_t) r13d;
    r14 >>= 1;
label_26:
    if (r14d <= 2) {
        goto label_27;
    }
    rax = *((rbx + 0x30));
    rax >>= 1;
    if (eax == 0) {
        goto label_0;
    }
    ecx = caml_parser_trace;
    if (ecx != 0) {
        goto label_28;
    }
label_12:
    rax = *((rbp + 0x28));
    rcx = (int64_t) r15d;
    *((rbx + 0x30)) = 0xffffffffffffffff;
    rcx += rcx;
    r12d = *((rax + rcx));
    if (r12d == 0) {
        goto label_1;
    }
label_10:
    eax = caml_parser_trace;
    if (eax != 0) {
        goto label_29;
    }
label_11:
    rax = *((rbp + 0x20));
    r12 = (int64_t) r12d;
    rdx = r13 + r13 + 1;
    r13++;
    *((rbx + 0x50)) = rdx;
    rdx = r12 + r12 + 1;
    eax = *((rax + r12*2));
    *((rbx + 0x60)) = rdx;
    rax = (int64_t) eax;
    rdx = rax + rax + 1;
    r13 -= rax;
    rax = *(rbx);
    *((rbx + 0x58)) = rdx;
    rdx = *((rax + r13*8 - 8));
    rax = *((rbp + 0x18));
    ecx = *((rax + r12*2));
    rax = *((rbp + 0x48));
    rdx >>= 1;
    esi = edx;
    rcx = (int64_t) ecx;
    eax = *((rax + rcx*2));
    esi += eax;
    if (esi >= 0) {
        if (eax == 0) {
            goto label_7;
        }
        rax = *((rbp + 0x50));
        rax >>= 1;
        if (esi <= eax) {
            goto label_30;
        }
    }
label_7:
    rax = *((rbp + 0x30));
    edx = *((rax + rcx*2));
label_8:
    rax = *((rbx + 0x20));
    rax >>= 1;
    if (r13 >= rax) {
        rax = r13 + r13 + 1;
        rdx = (int64_t) edx;
        r14 = (int64_t) r14d;
        *((rbx + 0x68)) = rax;
        rax = rdx + rdx + 1;
        *((rbx + 0x70)) = rax;
        rax = r14 + r14 + 1;
        *((rbx + 0x78)) = rax;
        eax = 7;
        goto label_2;
        r13 = *((rsi + 0x68));
        ecx = 0;
        r14d = 0;
        r15d = 0;
        r13 >>= 1;
        r13 = (int64_t) r13d;
        goto label_3;
        r13 = *((rsi + 0x68));
        r15 = *((rsi + 0x70));
        r14 = *((rsi + 0x78));
        r13 >>= 1;
        r15 >>= 1;
        r13 = (int64_t) r13d;
        r14 >>= 1;
label_9:
        rax = (int64_t) r15d;
        rdx = *(rbx);
        r12 = r13*8;
        rax += rax;
        rcx = rax + 1;
        rdi = r12;
        *((rsp + 0x10)) = rax;
        *((rdx + r13*8)) = rcx;
        rdi += *((rbx + 8));
        rsi = *((rbx + 0x38));
        caml_modify ();
        rdi = r12;
        rdi += *((rbx + 0x10));
        rsi = *((rbx + 0x40));
        caml_modify ();
        rdi = r12;
        rdi += *((rbx + 0x18));
        rsi = *((rbx + 0x48));
        caml_modify ();
        rax = *((rsp + 0x10));
        rcx = *((rsp + 0x10));
        goto label_3;
        r13 = *((rsi + 0x68));
        rdx = *((rsi + 0x70));
        r14 = *((rsi + 0x78));
        r13 >>= 1;
        rdx >>= 1;
        r13 = (int64_t) r13d;
        r14 >>= 1;
    }
    rax = r13 + r13 + 1;
    rdx = (int64_t) edx;
    r14 = (int64_t) r14d;
    *((rbx + 0x68)) = rax;
    rax = rdx + rdx + 1;
    *((rbx + 0x70)) = rax;
    rax = r14 + r14 + 1;
    *((rbx + 0x78)) = rax;
    eax = 9;
    goto label_2;
    r13 = *((rsi + 0x68));
    r15 = *((rsi + 0x70));
    r14 = *((rsi + 0x78));
    r13 >>= 1;
    r15 >>= 1;
    r14 >>= 1;
    r13 = (int64_t) r13d;
    if ((cl & 1) != 0) {
        goto label_31;
    }
    edx = *((rcx - 8));
    rax = *((rdi + 0x10));
    rdi = rsi + 0x38;
    rax = *((rax + rdx*8));
    *((rsi + 0x30)) = rax;
    rsi = *(rcx);
    caml_modify ();
label_6:
    esi = caml_parser_trace;
    if (esi != 0) {
        goto label_32;
    }
label_13:
    rdx = *((rbx + 0x30));
    rcx = (int64_t) r15d;
    rcx += rcx;
    rdx >>= 1;
    goto label_4;
label_27:
    esi = caml_parser_trace;
    r14 = r13*8;
    while (esi == 0) {
label_5:
        rax = *((rbx + 0x28));
        r14 -= 8;
        rax >>= 1;
        rax = (int64_t) eax;
        if (r13 <= rax) {
            goto label_33;
        }
        r13--;
        rax = *(rbx);
        rdx = *((rbp + 0x38));
        rax = *((rax + r14));
        rax >>= 1;
        rdi = (int64_t) eax;
        ecx = eax;
        edx = *((rdx + rdi*2));
        r12d = edx;
        r12d += 0x100;
        if (r12d >= 0) {
            if (edx == 0) {
                goto label_34;
            }
            rdx = *((rbp + 0x50));
            rdx >>= 1;
            if (r12d > edx) {
                goto label_34;
            }
            rdx = *((rbp + 0x60));
            r12 = (int64_t) r12d;
            r9 = r12 + r12;
            if (*((rdx + r12*2)) == 0x100) {
                goto label_35;
            }
        }
label_34:
    }
    rdi = stderr;
    esi = 1;
    edx = "Discarding state %d\n";
    eax = 0;
    fprintf_chk ();
    esi = caml_parser_trace;
    goto label_5;
label_31:
    rax = *((rdi + 8));
    rdx = rcx;
    rdi = rsi + 0x38;
    rdx >>= 1;
    rdx = (int64_t) edx;
    rax = *((rax + rdx*8));
    *((rsi + 0x30)) = rax;
    esi = 1;
    eax = caml_modify ();
    goto label_6;
label_33:
    if (esi == 0) {
        goto label_0;
    }
    rdi = stderr;
    edx = "No more states to discard\n";
    esi = 1;
    eax = 0;
    fprintf_chk ();
    eax = 3;
    goto label_2;
label_30:
    rax = *((rbp + 0x60));
    rsi = (int64_t) esi;
    eax = *((rax + rsi*2));
    if (eax != edx) {
        goto label_7;
    }
    rax = *((rbp + 0x58));
    edx = *((rax + rsi*2));
    goto label_8;
label_23:
    eax = 0;
    *((rbx + 0x30)) = 0xffffffffffffffff;
    al = (r14d > 0) ? 1 : 0;
    r14d -= eax;
label_15:
    edx = caml_parser_trace;
    if (edx != 0) {
        goto label_36;
    }
    r9 = r12 + r12;
label_14:
    rax = *((rbp + 0x58));
    r13++;
    r15d = *((rax + r9));
    rax = *((rbx + 0x20));
    rax >>= 1;
    if (r13 < rax) {
        goto label_9;
    }
    rax = r13 + r13 + 1;
    r15 = (int64_t) r15d;
    r14 = (int64_t) r14d;
    *((rbx + 0x68)) = rax;
    rax = r15 + r15 + 1;
    *((rbx + 0x70)) = rax;
    rax = r14 + r14 + 1;
    *((rbx + 0x78)) = rax;
    eax = 5;
    goto label_2;
label_25:
    rax = *((rbp + 0x58));
    r12d = *((rax + rcx*2));
    goto label_10;
label_29:
    rdi = stderr;
    r8d = r12d;
    ecx = r15d;
    edx = "State %d: reduce by rule %d\n";
    esi = 1;
    eax = 0;
    fprintf_chk ();
    goto label_11;
label_32:
    if ((r12b & 1) == 0) {
        goto label_37;
    }
    rax = r12;
    r12 = *((rbp + 0x70));
    rax >>= 1;
    if (eax <= 0) {
        goto label_16;
    }
    if (*(r12) == 0) {
        goto label_38;
    }
    eax--;
    edx = 0;
    *((rsp + 0x18)) = eax;
    while (eax > 0) {
        edx++;
        if (*(r12) == 0) {
            goto label_38;
        }
        *((rsp + 8)) = edx;
        strlen (r12);
        edx = *((rsp + 8));
        r12 = r12 + rax + 1;
        eax = *((rsp + 0x18));
        eax -= edx;
    }
label_16:
    rdi = stderr;
    ecx = r15d;
    edx = "State %d: read token %s\n";
    r8 = r12;
    esi = 1;
    eax = 0;
    fprintf_chk ();
    rdx = *((rbx + 0x30));
    rcx = (int64_t) r15d;
    rcx += rcx;
    rdx >>= 1;
    goto label_4;
label_20:
    rdx = *((rbx + 0x18));
    rdi = *((rsp + 0x18));
    rdi += *((rbx + 0x10));
    rsi = *((rdx + r12*8));
    caml_modify ();
    rax = *((rsp + 0x10));
    rcx = *((rsp + 0x10));
    goto label_3;
label_28:
    rdi = stderr;
    edx = "Discarding last token read\n";
    esi = 1;
    eax = 0;
    fprintf_chk ();
    goto label_12;
label_21:
    rax = r13 + r13 + 1;
    r15 = (int64_t) r15d;
    r14 = (int64_t) r14d;
    *((rbx + 0x68)) = rax;
    rax = r15 + r15 + 1;
    *((rbx + 0x70)) = rax;
    rax = r14 + r14 + 1;
    *((rbx + 0x78)) = rax;
    eax = 1;
    goto label_2;
label_37:
    eax = *((r12 - 8));
    r8 = *((rbp + 0x78));
    if (al == 0) {
        goto label_17;
    }
    if (*(r8) == 0) {
        goto label_39;
    }
    eax = (int32_t) al;
    edx = 0;
    eax--;
    *((rsp + 0x18)) = eax;
    while (*((rsp + 0x18)) != edx) {
        edx++;
        if (*(r8) == 0) {
            goto label_39;
        }
        rdi = r8;
        *((rsp + 8)) = edx;
        *((rsp + 0x10)) = r8;
        eax = strlen (rdi);
        edx = *((rsp + 8));
        r8 = *((rsp + 0x10));
        r8 = r8 + rax + 1;
    }
label_17:
    rdi = stderr;
    ecx = r15d;
    eax = 0;
    edx = "State %d: read token %s(";
    esi = 1;
    fprintf_chk ();
    rcx = *(r12);
    if ((cl & 1) != 0) {
        goto label_40;
    }
    eax = *((rcx - 8));
    if (al == 0xfc) {
        goto label_41;
    }
    if (al == 0xfd) {
        goto label_42;
    }
    rdi = stderr;
    edx = 0x436a1e;
    esi = 1;
    eax = 0;
    eax = fprintf_chk ();
label_18:
    rdi = stderr;
    edx = 0x436a20;
    esi = 1;
    eax = 0;
    eax = fprintf_chk ();
    goto label_13;
label_35:
    r14d = 3;
    if (esi == 0) {
        goto label_14;
    }
    rdi = stderr;
    edx = "Recovering in state %d\n";
    esi = 1;
    eax = 0;
    *((rsp + 0x10)) = r9;
    fprintf_chk ();
    r9 = *((rsp + 0x10));
    goto label_15;
label_36:
    rax = *((rbp + 0x58));
    rdi = stderr;
    ecx = r15d;
    edx = "State %d: shift to state %d\n";
    esi = 1;
    *((rsp + 0x10)) = r9;
    r8d = *((rax + r9));
    eax = 0;
    eax = fprintf_chk ();
    r9 = *((rsp + 0x10));
    goto label_14;
label_38:
    r12d = "<unknown token>";
    goto label_16;
label_39:
    r8d = "<unknown token>";
    goto label_17;
label_40:
    rdi = stderr;
    rcx >>= 1;
    edx = 0x436a17;
    esi = 1;
    eax = 0;
    fprintf_chk ();
    goto label_18;
label_42:
    rdi = stderr;
    xmm0 = *(rcx);
    edx = 0x436a1b;
    esi = 1;
    eax = 1;
    eax = fprintf_chk ();
    goto label_18;
label_41:
    rdi = stderr;
    edx = 0x436180;
    esi = 1;
    eax = 0;
    fprintf_chk ();
    goto label_18;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x427210 */
#include <stdint.h>
 
int64_t caml_set_minor_heap_size (int64_t arg1) {
    int64_t var_8h;
    rdi = arg1;
    rax = caml_young_end;
    if (*(obj.caml_young_ptr) != rax) {
        caml_minor_collection ();
    }
    rdx = rsp + 8;
    esi = 0;
    rdi = rbp;
    rax = caml_aligned_malloc ();
    rbx = rax;
    if (rax != 0) {
        r12 = rax + rbp;
        rsi = rax;
        edi = 2;
        rdx = r12;
        eax = caml_page_table_add ();
        if (eax != 0) {
            goto label_0;
        }
        rsi = caml_young_start;
        if (rsi != 0) {
            rdx = caml_young_end;
            edi = 2;
            caml_page_table_remove ();
            free (*(obj.caml_young_base));
        }
        rdi = caml_ref_table;
        rax = *((rsp + 8));
        *(obj.caml_young_start) = rbx;
        *(obj.caml_young_end) = r12;
        *(obj.caml_young_limit) = rbx;
        *(obj.caml_young_ptr) = r12;
        *(obj.caml_young_base) = rax;
        *(obj.caml_minor_heap_size) = rbp;
        *(0x00652448) = 0;
        *(0x00652450) = 0;
        if (rdi != 0) {
            caml_stat_free ();
        }
        rdi = caml_weak_ref_table;
        *(0x00652428) = 0;
        *(0x00652440) = 0;
        *(0x00652430) = 0;
        *(0x00652438) = 0;
        *(obj.caml_ref_table) = 0;
        *(0x00652488) = 0;
        *(0x00652490) = 0;
        if (rdi != 0) {
            caml_stat_free ();
        }
        *(0x00652468) = 0;
        *(0x00652480) = 0;
        *(0x00652470) = 0;
        *(0x00652478) = 0;
        *(obj.caml_weak_ref_table) = 0;
        return rax;
    }
label_0:
    return caml_raise_out_of_memory ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e110 */
#include <stdint.h>
 
int64_t caml_deserialize_uint_8 (void) {
    int64_t var_8h;
    esi = 1;
    rdi = rsp + 8;
    caml_deserialize_block_8 ();
    rax = *((rsp + 8));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429ae0 */
#include <stdint.h>
 
void caml_int64_of_float (int64_t arg1) {
    rdi = arg1;
    xmm1 = *(rdi);
    __asm ("cvttsd2si rdi, xmm1");
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429700 */
#include <stdint.h>
 
void caml_nativeint_shift_right (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdi = *((rdi + 8));
    rcx = rsi;
    rcx >>= 1;
    rdi >>= cl;
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41dc40 */
#include <stdint.h>
 
uint64_t camlPrintf_summarize_format_type_190 (void) {
    int64_t var_8h;
    rdi = rax;
    *(rsp) = rdi;
    rbx = *((rdi - 8));
    rbx >>= 0xa;
    rax = rbx*8 - 1;
    rbx = *((rdi + rax));
    rax -= rbx;
    rax = rax + rax + 1;
    rax = camlBuffer_create_67 ();
    rsi = rax;
    *((rsp + 8)) = rsi;
label_0:
    r15 -= 0x58;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    *(rax) += 0;
    rdi = r15 + 8;
    *((rdi - 8)) = 0x10f7;
    rax = *(reloc.caml_curry2);
    *(rdi) = rax;
    *((rdi + 8)) = 5;
    rax = *(reloc.camlPrintf__add_char_194);
    *((rdi + 0x10)) = rax;
    *((rdi + 0x18)) = rsi;
    rbx = rdi + 0x28;
    *((rbx - 8)) = 0x14f7;
    rax = *(reloc.caml_curry3);
    *(rbx) = rax;
    *((rbx + 8)) = 7;
    rax = *(reloc.camlPrintf__add_conv_197);
    eax -= 0x89480022;
    *((r8 - 0x77)) += cl;
    if (*((r8 - 0x77)) >= 0) {
        void (*0x41dcfb)() ();
    }
label_1:
    caml_call_gc ();
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410380 */
#include <stdint.h>
 
int64_t camlPervasives_input_line_265 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    rbx = *(loc.camlPervasives__86);
    do {
        r15 -= 0x30;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x14f7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlPervasives__scan_273);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = rsi;
            *((rdi + 0x20)) = rbx;
            rbx = 1;
            rax = 1;
            void (*0x40f780)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ab60 */
#include <stdint.h>
 
uint64_t caml_string_greaterequal (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = caml_string_compare ();
    al = (rax > 0) ? 1 : 0;
    eax = (int32_t) al;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40acd0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1617 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_shutdown);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4107d0 */
#include <stdint.h>
 
int64_t camlPervasives_fun_515 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_ml_seek_in_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f550 */
#include <stdint.h>
 
int64_t caml_hash_univ_param (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    rdi >>= 1;
    rsi >>= 1;
    *(obj.hash_univ_count) = rdi;
    rdi = rdx;
    *(obj.hash_univ_limit) = rsi;
    *(obj.hash_accu) = 0;
    hash_aux ();
    rax = hash_accu;
    eax &= 0x3fffffff;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423c80 */
#include <stdint.h>
 
int64_t caml_raise_constant (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_98h;
    rdi = arg1;
    rax = caml_local_roots;
    esi = 0;
    *((rsp + 8)) = rdi;
    edi = 1;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x98)) = 0;
    *((rsp + 0x50)) = rax;
    rax = rsp + 8;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *((rsp + 0x68)) = rax;
    rax = rsp + 0x50;
    *((rsp + 0x10)) = rax;
    rax = rsp + 0x10;
    *(obj.caml_local_roots) = rax;
    rax = rsp + 0x98;
    *((rsp + 0x28)) = rax;
    rax = caml_alloc_small ();
    rdx = *((rsp + 8));
    *((rsp + 0x98)) = rax;
    *(rax) = rdx;
    rdi = *((rsp + 0x98));
    return caml_raise ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4155d0 */
#include <stdint.h>
 
int64_t camlList_map2_118 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, uint32_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    uint32_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        rsi = rax;
        if (rbx == 1) {
            goto label_0;
        }
        if (rdi == 1) {
            goto label_1;
        }
        *(rsp) = rsi;
        rax = *((rdi + 8));
        *((rsp + 0x10)) = rax;
        rdi = *(rdi);
        rax = *((rbx + 8));
        *((rsp + 8)) = rax;
        rax = *(rbx);
        rbx = rdi;
        rdi = rsi;
        rax = caml_apply2 ();
        *((rsp + 0x18)) = rax;
        rax = *(rsp);
        rbx = *((rsp + 8));
        rdi = *((rsp + 0x10));
        rax = camlList_map2_118 ();
    } while (1);
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *((rsp + 0x18));
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            return rax;
label_0:
            if (rdi == 1) {
                rax = 1;
                return rax;
            }
label_1:
            rax = *(loc.camlList__47);
            void (*0x40fc30)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42e2b0 */
#include <stdint.h>
 
void caml_deserialize_block_1 (size_t * n, void * s1) {
    rsi = n;
    rdi = s1;
    rdx = rsi;
    rbx = rsi;
    memmove (rdi, *(obj.intern_src), rdx);
    *(obj.intern_src) += rbx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410790 */
#include <stdint.h>
 
int64_t camlPervasives_fun_519 (void) {
    rdi = rax;
    rax = *(reloc.caml_ml_channel_size_64);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b480 */
#include <stdint.h>
 
int64_t camlUnix_fun_1739 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_fchmod);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a9c0 */
#include <stdint.h>
 
int64_t camlBuffer_add_substitute_150 (int64_t arg6, int64_t arg5, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    rcx = rdi;
    rax = *((rcx - 8));
    rax >>= 0xa;
    rax = rax*8 - 1;
    rdx = *((rcx + rax));
    rax -= rdx;
    rdx = rax + rax + 1;
    do {
        r15 -= 0x40;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x1cf7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlBuffer__subst_155);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = rsi;
            *((rdi + 0x20)) = rbx;
            *((rdi + 0x28)) = rcx;
            *((rdi + 0x30)) = rdx;
            rbx = 1;
            rax = 0x41;
            void (*0x419ee0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429d70 */
#include <stdint.h>
 
int32_t caml_int32_and (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    eax = *((rsi + 8));
    eax &= *((rdi + 8));
    edi = eax;
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429750 */
#include <stdint.h>
 
int64_t caml_nativeint_or (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rax = *((rsi + 8));
    rax |= *((rdi + 8));
    rdi = rax;
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415cc0 */
#include <stdint.h>
 
int64_t camlList_remove_assq_223 (void) {
    do {
        if (rbx == 1) {
            goto label_0;
        }
        rdx = *((rbx + 8));
        rsi = *(rbx);
        rdi = *(rsi);
        if (rdi == rax) {
            rax = rdx;
            return rax;
        }
        *(rsp) = rsi;
        rbx = rdx;
        rax = camlList_remove_assq_223 ();
    } while (1);
    rdi = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            rbx = *(rsp);
            *(rax) = rbx;
            *((rax + 8)) = rdi;
            return rax;
label_0:
            rax = 1;
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42df20 */
#include <stdint.h>
 
uint64_t caml_deserialize_uint_4 (void) {
    rcx = intern_src;
    rdx = rcx + 4;
    *(obj.intern_src) = rdx;
    eax = *(rcx);
    esi = *((rdx - 1));
    rax <<= 0x18;
    rsi += rax;
    eax = *((rdx - 3));
    edx = *((rdx - 2));
    eax <<= 0x10;
    edx <<= 8;
    rcx = (int64_t) eax;
    rdx = (int64_t) edx;
    rax = rsi + rcx;
    rax += rdx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41a820 */
#include <stdint.h>
 
int64_t camlBuffer_find_ident_142 (int64_t arg6, int64_t arg5, int64_t arg4, signed int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    if (rbx >= rdi) {
label_1:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_2;
        }
        rax = r15 + 8;
        *((rax - 8)) = 0x400;
        rbx = *(reloc.caml_exn_Not_found);
        *(rax) = rbx;
        rax = caml_raise_exn ();
    }
    *((rsp + 0x10)) = rbx;
    *((rsp + 0x18)) = rax;
    rdx = rbx;
    rdx >>= 1;
    rdi = *((rax - 8));
    rdi >>= 0xa;
    rdi = rdi*8 - 1;
    rsi = *((rax + rdi));
    rdi -= rsi;
    if (rdi <= rdx) {
        goto label_3;
    }
    rdi = *((rax + rdx));
    rdi = rdi + rdi + 1;
    if (rdi != 0x51) {
        if (rdi != 0xf7) {
            rbx += 2;
            rax = camlBuffer_advance_to_non_alpha_136 ();
            *(rsp) = rax;
            rbx = *((rsp + 0x10));
            rax -= rbx;
            rdi = rax;
            rdi++;
            rax = *((rsp + 0x18));
            rax = camlString_sub_74 ();
            rdi = rax;
label_0:
            r15 -= 0x18;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_4;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x800;
            *(rbx) = rdi;
            rax = *(rsp);
            *((rbx + 8)) = rax;
            rax = rbx;
            return rax;
        }
        *(rsp) = rdi;
    } else {
        *(rsp) = rdi;
    }
    rbx += 2;
    *((rsp + 8)) = rbx;
    rax = rdi;
    rax = camlBuffer_closing_125 ();
    rbx = rax;
    rdi = 1;
    rax = *(rsp);
    rsi = *((rsp + 0x18));
    rdx = *((rsp + 8));
    rax = camlBuffer_advance_to_closing_126 ();
    *(rsp) = rax;
    rbx = *((rsp + 0x10));
    rax -= rbx;
    rax -= 3;
    rdi = rax;
    rdi += 2;
    rax = *((rsp + 0x18));
    rbx = *((rsp + 8));
    rax = camlString_sub_74 ();
    rbx = rax;
    do {
        r15 -= 0x18;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x800;
            *(rax) = rbx;
            rbx = *(rsp);
            rbx += 2;
            *((rax + 8)) = rbx;
            return rax;
        }
        caml_call_gc ();
    } while (1);
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
label_3:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a6d0 */
#include <stdint.h>
 
void caml_neg_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    xmm1 = *(0x00436610);
    __asm ("xorpd xmm0, xmm1");
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c4d0 */
#include <stdint.h>
 
uint64_t caml_ml_flush_partial (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    rdi = arg1;
    *((rsp - 0x10)) = rbp;
    *((rsp - 0x18)) = rbx;
    *((rsp - 8)) = r12;
    rbx = *((rdi + 8));
    rdx = rsp + 0x10;
    rbp = caml_local_roots;
    *((rsp + 8)) = rdi;
    *(obj.caml_local_roots) = rdx;
    if (*(rbx) == 0xffffffff) {
        goto label_0;
    }
    rax = rsp + 8;
    *((rsp + 0x10)) = rbp;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *((rsp + 0x28)) = rax;
    rax = caml_channel_mutex_lock;
    if (rax != 0) {
        rdi = rbx;
        void (*rax)() ();
    }
    rdi = rbx;
    eax = caml_flush_partial ();
    rdx = caml_channel_mutex_unlock;
    r12d = eax;
    if (rdx != 0) {
        rdi = rbx;
        rax = void (*rdx)() ();
    }
    *(obj.caml_local_roots) = rbp;
    rax -= rax;
    rax &= 0xfffffffffffffffe;
    rax += 3;
    do {
        rbx = *((rsp + 0x50));
        rbp = *((rsp + 0x58));
        r12 = *((rsp + 0x60));
        return rax;
label_0:
        *(obj.caml_local_roots) = rbp;
        eax = 3;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b1c0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1695 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_symlink);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429d10 */
#include <stdint.h>
 
void caml_int32_of_int (int64_t arg1) {
    rdi = arg1;
    rdi >>= 1;
    return caml_copy_int32 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42fb50 */
#include <stdint.h>
 
int64_t caml_sys_getcwd (void) {
    int64_t var_1008h;
    esi = 0x1000;
    rdi = rsp;
    rax = *(fs:0x28);
    *((rsp + 0x1008)) = rax;
    eax = 0;
    rax = getcwd ();
    if (rax != 0) {
        rdi = rsp;
        caml_copy_string ();
        rdx = *((rsp + 0x1008));
        rdx ^= *(fs:0x28);
        if (rax != 0) {
            goto label_0;
        }
        return rax;
    }
    edi = 1;
    caml_sys_error ();
label_0:
    return stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ac90 */
#include <stdint.h>
 
int64_t camlUnix_fun_1613 (void) {
    rdi = rax;
    rax = *(reloc.unix_getpeername);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429c80 */
#include <stdint.h>
 
void caml_copy_int32 (int64_t arg1) {
    rdi = arg1;
    ecx = 1;
    ebx = edi;
    edx = 0;
    esi = 4;
    edi = caml_int32_ops;
    caml_alloc_custom ();
    *((rax + 8)) = ebx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41d5c0 */
#include <stdint.h>
 
void camlPrintf_bad_conversion_format_89 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    *(rsp) = rbx;
    *((rsp + 8)) = rdi;
    rbx = *((rax - 8));
    rbx >>= 0xa;
    rbx = rbx*8 - 1;
    rdi = *((rax + rbx));
    rbx -= rdi;
    rdi = rbx + rbx + 1;
    rbx = 1;
    camlString_sub_74 ();
    rbx = *(rsp);
    rdi = *((rsp + 8));
    return camlPrintf_bad_conversion_85 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429b40 */
#include <stdint.h>
 
void caml_int64_shift_left (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdi = *((rdi + 8));
    rcx = rsi;
    rcx >>= 1;
    rdi <<= cl;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a2e0 */
#include <stdint.h>
 
void caml_power_float (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    xmm1 = *(rsi);
    xmm0 = *(rdi);
    pow (rdi, rsi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x416170 */
#include <stdint.h>
 
int64_t camlList_stable_sort_276 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    *((rsp + 8)) = rbx;
    do {
        r15 -= 0xa8;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rcx = r15 + 8;
            *((rcx - 8)) = 0x10f7;
            rax = *(reloc.caml_curry3);
            *(rcx) = rax;
            *((rcx + 8)) = 7;
            rax = *(reloc.camlList__rev_merge_279);
            *((rcx + 0x10)) = rax;
            *((rcx + 0x18)) = rdi;
            rdx = rcx + 0x28;
            *((rdx - 8)) = 0x10f7;
            rax = *(reloc.caml_curry3);
            *(rdx) = rax;
            *((rdx + 8)) = 7;
            rax = *(reloc.camlList__rev_merge_rev_289);
            *((rdx + 0x10)) = rax;
            *((rdx + 0x18)) = rdi;
            rsi = rcx + 0x50;
            *(rsp) = rsi;
            *((rsi - 8)) = 0x28f7;
            rax = *(reloc.caml_curry2);
            *(rsi) = rax;
            *((rsi + 8)) = 5;
            rax = *(reloc.camlList__sort_299);
            *((rsi + 0x10)) = rax;
            *((rsi + 0x18)) = 0x10f9;
            rax = *(reloc.caml_curry2);
            *((rsi + 0x20)) = rax;
            *((rsi + 0x28)) = 5;
            rax = *(reloc.camlList__rev_sort_300);
            *((rsi + 0x30)) = rax;
            *((rsi + 0x38)) = rdi;
            *((rsi + 0x40)) = rcx;
            *((rsi + 0x48)) = rdx;
            rax = 1;
            rax = camlList_length_aux_58 ();
            if (rax < 5) {
                rax = *((rsp + 8));
                return rax;
            }
            rbx = *((rsp + 8));
            rdi = *(rsp);
            void (*0x414de0)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a650 */
#include <stdint.h>
 
void caml_exp_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    exp (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b170 */
#include <stdint.h>
 
int64_t camlUnix_fun_1691 (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = rdi;
    rcx = rsi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_select);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429e50 */
#include <stdint.h>
 
uint64_t caml_int_of_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    __asm ("cvttsd2si rax, xmm0");
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b440 */
#include <stdint.h>
 
int64_t camlUnix_fun_1735 (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_fchown);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a4c0 */
#include <stdint.h>
 
int64_t caml_frexp_float (int * exp, int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_98h;
    int64_t var_a0h;
    arithmetic * value;
    rsi = exp;
    rdi = arg1;
    rax = rdi;
    rbx = caml_local_roots;
    rdx = rsp + 8;
    *((rsp + 8)) = rdi;
    xmm0 = *(rax);
    *((rsp + 0x60)) = 1;
    *((rsp + 0x68)) = rdx;
    rdx = rsp + 0x50;
    *((rsp + 0x50)) = rbx;
    *((rsp + 0x58)) = 1;
    *((rsp + 0xa0)) = 0;
    *((rsp + 0x10)) = rdx;
    rdx = rsp + 0x10;
    *((rsp + 0x98)) = 0;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 2;
    *(obj.caml_local_roots) = rdx;
    rdx = rsp + 0xa0;
    *((rsp + 0x28)) = rdx;
    rdx = rsp + 0x98;
    *((rsp + 0x30)) = rdx;
    frexp (rsp + 0xac, rsi);
    rax = caml_copy_double ();
    edi = 2;
    *((rsp + 0x98)) = rax;
    rax = caml_alloc_tuple ();
    rdx = *((rsp + 0x98));
    *((rsp + 0xa0)) = rax;
    *(obj.caml_local_roots) = rbx;
    *(rax) = rdx;
    rax = *((rsp + 0xac));
    rdx = rax + rax + 1;
    rax = *((rsp + 0xa0));
    *((rax + 8)) = rdx;
    rax = *((rsp + 0xa0));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408d70 */
#include <stdint.h>
 
void frexp (void) {
    frexp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428d90 */
#include <stdint.h>
 
int64_t caml_nativeint_compare (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdx = *((rsi + 8));
    rcx = *((rdi + 8));
    eax = 0;
    al = (rcx > rdx) ? 1 : 0;
    dl = (rcx < rdx) ? 1 : 0;
    edx = (int32_t) dl;
    eax -= edx;
    rax = (int64_t) eax;
    rax = rax + rax + 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b200 */
#include <stdint.h>
 
int64_t camlUnix_fun_1699 (void) {
    rdi = rax;
    rax = *(reloc.unix_pipe);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x425f50 */
#include <stdint.h>
 
int64_t caml_init_major_heap (int64_t arg1) {
    rdi = arg1;
    rdx = rdi;
    edi = 0x2000;
    eax = 0x2000;
    if (rdx > 0x1fff) {
        rdi = rdx + 0xfff;
        rdi &= 0xfffffffffffff000;
        rax = rdi;
    }
    *(obj.caml_stat_heap_size) = rax;
    *(obj.caml_stat_top_heap_size) = rax;
    rax = caml_alloc_for_heap ();
    *(obj.caml_heap_start) = rax;
    if (rax != 0) {
        rdx = rax;
        rdx += *(obj.caml_stat_heap_size);
        *((rax - 8)) = 0;
        rsi = rax;
        edi = 1;
        *(obj.caml_stat_heap_chunks) = 1;
        eax = caml_page_table_add ();
        if (eax != 0) {
            goto label_0;
        }
        caml_fl_init_merge ();
        rsi = caml_stat_heap_size;
        rdi = caml_heap_start;
        edx = 1;
        rsi >>= 3;
        caml_make_free_blocks ();
        *(obj.caml_gc_phase) = 2;
        *(obj.gray_vals_size) = 0x800;
        rax = malloc (0x4000);
        *(obj.gray_vals) = rax;
        if (rax == 0) {
            goto label_1;
        }
        rdx = gray_vals_size;
        *(obj.gray_vals_cur) = rax;
        *(obj.heap_is_pure) = 1;
        *(obj.caml_allocated_words) = 0;
        *(obj.caml_extra_heap_resources) = 0;
        rax = rax + rdx*8;
        *(obj.gray_vals_end) = rax;
        return rax;
    }
    edi = "Fatal error: not enough memory for the initial heap.\n";
    caml_fatal_error ();
label_1:
    edi = "Fatal error: not enough memory for the gray cache.\n";
    caml_fatal_error ();
label_0:
    edi = "Fatal error: not enough memory for the initial page table.\n";
    return caml_fatal_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b400 */
#include <stdint.h>
 
int64_t camlUnix_fun_1731 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_access);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4296b0 */
#include <stdint.h>
 
void caml_nativeint_of_int32 (int64_t arg1) {
    rdi = arg1;
    rdi = *((rdi + 8));
    return caml_copy_nativeint ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b3b0 */
#include <stdint.h>
 
int64_t caml_pos_in (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 0x18));
    rax += *((rdi + 8));
    rax -= *((rdi + 0x20));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x410610 */
#include <stdint.h>
 
uint64_t camlPervasives_prerr_float_307 (void) {
    rax = camlPervasives_string_of_float_164 ();
    rbx = rax;
    rax = *(reloc.camlPervasives);
    rax = *((rax + 0xc0));
    return camlPervasives_output_string_215 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f960 */
#include <stdint.h>
 
uint64_t caml_sys_read_directory (int64_t arg1) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    int64_t var_90h;
    int64_t var_98h;
    int64_t var_a8h;
    rdi = arg1;
    esi = 0x32;
    rbp = caml_local_roots;
    rax = rsp + 8;
    rbx = rsp + 0x90;
    *((rsp + 8)) = rdi;
    *((rsp + 0x60)) = 1;
    *((rsp + 0x58)) = 1;
    *((rsp + 0x68)) = rax;
    rax = rsp + 0x50;
    rdi = rbx;
    *((rsp + 0x50)) = rbp;
    *((rsp + 0xa8)) = 0;
    *((rsp + 0x10)) = rax;
    rax = rsp + 0x10;
    *((rsp + 0x20)) = 1;
    *((rsp + 0x18)) = 1;
    *(obj.caml_local_roots) = rax;
    rax = rsp + 0xa8;
    *((rsp + 0x28)) = rax;
    caml_ext_table_init ();
    rdi = *((rsp + 8));
    rsi = rbx;
    eax = caml_read_directory ();
    if (eax != 0xffffffff) {
        esi = 0;
        rdi = rbx;
        caml_ext_table_add ();
        rdi = *((rsp + 0x98));
        rax = caml_copy_string_array ();
        rdi = rbx;
        esi = 1;
        *((rsp + 0xa8)) = rax;
        caml_ext_table_free ();
        *(obj.caml_local_roots) = rbp;
        rax = *((rsp + 0xa8));
        return rax;
    }
    rdi = rbx;
    esi = 1;
    caml_ext_table_free ();
    rdi = *((rsp + 8));
    return caml_sys_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40f6c0 */
#include <stdint.h>
 
int64_t camlPervasives_iter_210 (void) {
    do {
        if (rax == 1) {
            goto label_0;
        }
        rbx = *((rax + 8));
        *(rsp) = rbx;
        rdi = *(rax);
        fcn_0040f6dc ();
        rax = *(rsp);
    } while (1);
label_0:
    rax = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4101e0 */
#include <stdint.h>
 
int64_t camlPervasives_open_in_242 (void) {
    rdi = rax;
    rbx = 1;
    rax = *(loc.camlPervasives__90);
    return camlPervasives_open_in_gen_238 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423a70 */
#include <stdint.h>
 
void caml_raise_stack_overflow (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_60h;
    int64_t var_68h;
    edi = caml_bucket_Stack_overflow;
    return caml_raise ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ed10 */
#include <stdint.h>
 
uint64_t camlCallback_register_exception_62 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    rax = *((rbx - 8));
    if (rax == 0xfe) {
        goto label_0;
    }
    rsi = *(rbx);
    while (1) {
label_0:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rbx]");
            __asm ("movlpd qword [rsi], xmm0");
            rax = *(reloc.caml_register_named_value);
            caml_c_call ();
            return rax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429b20 */
#include <stdint.h>
 
void caml_int64_shift_right (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    rdi = *((rdi + 8));
    rcx = rsi;
    rcx >>= 1;
    rdi >>= cl;
    return caml_copy_int64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a7f0 */
#include <stdint.h>
 
int64_t caml_float_of_substring (int64_t arg3, int64_t arg2, int64_t arg1) {
    char * * endptr;
    int64_t var_20h_2;
    int64_t var_68h_2;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r12 = rdx;
    rbp >>= 1;
    rbx = rdi;
    rax = *(fs:0x28);
    *((rsp + 0x68)) = rax;
    eax = 0;
    rax = caml_string_length ();
    if (rax > rbp) {
        if (rbp < 0) {
            goto label_2;
        }
        r12 >>= 1;
        if (r12 <= 0) {
            goto label_2;
        }
        rax -= rbp;
        if (r12 <= rax) {
            goto label_3;
        }
    }
label_2:
    r12d = 0;
label_0:
    r15 = rsp + 0x20;
    r14 = r15;
label_1:
    rbx = rbp + rbx;
    r13 = r14;
    while (r12 != 0) {
        eax = *(rbx);
        if (al != 0x5f) {
            *(r13) = al;
            r13++;
        }
        rbx++;
        r12--;
    }
    *(r13) = 0;
    if (r13 == r14) {
        goto label_4;
    }
    strtod (r14, rsp + 0x18);
    if (*((rsp + 0x18)) != r13) {
        goto label_4;
    }
    if (r14 != r15) {
        rdi = r14;
        *(rsp) = xmm0;
        caml_stat_free ();
        xmm0 = *(rsp);
    }
    caml_copy_double ();
    rdx = *((rsp + 0x68));
    rdx ^= *(fs:0x28);
    if (r14 != r15) {
        goto label_5;
    }
    return rax;
label_3:
    if (r12 <= 0x3f) {
        goto label_0;
    }
    rdi = r12 + 1;
    r15 = rsp + 0x20;
    rax = caml_stat_alloc ();
    r14 = rax;
    goto label_1;
label_4:
    if (r14 != r15) {
        rdi = r14;
        caml_stat_free ();
    }
    edi = "float_of_string";
    caml_failwith ();
label_5:
    return stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a1a0 */
#include <stdint.h>
 
void caml_atan2_float (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    xmm1 = *(rsi);
    xmm0 = *(rdi);
    atan2 (rdi, rsi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e6f0 */
#include <stdint.h>
 
int64_t camlPrintf_get_contents_437 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    *(rsp) = rax;
    rdi = *((rax + 8));
    rbx = 1;
    rax = *(rax);
    camlString_sub_74 ();
    rbx = *(rsp);
    *((rbx + 8)) = 1;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x413f70 */
#include <stdint.h>
 
int64_t camlArray_stable_sort_215 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h_2;
    int64_t var_18h;
    int64_t var_20h_2;
    int64_t var_28h_2;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
label_0:
    r15 -= 0x98;
    rax = *(reloc.caml_young_limit);
    if (r15 < *(rax)) {
        goto label_1;
    }
    rax = r15 + 8;
    *((rax - 8)) = 0x14f7;
    rdi = *(reloc.caml_curry7);
    *(rax) = rdi;
    *((rax + 8)) = 0xf;
    rdi = *(reloc.camlArray__merge_218);
    *((rax + 0x10)) = rdi;
    *((rax + 0x18)) = rsi;
    *((rax + 0x20)) = rbx;
    rdx = rax + 0x30;
    *((rdx - 8)) = 0x14f7;
    rdi = *(reloc.caml_curry4);
    *(rdx) = rdi;
    *((rdx + 8)) = 9;
    rdi = *(reloc.camlArray__isortto_236);
    *((rdx + 0x10)) = rdi;
    *((rdx + 0x18)) = rsi;
    *((rdx + 0x20)) = rbx;
    rcx = rax + 0x60;
    *((rcx - 8)) = 0x18f7;
    rdi = *(reloc.caml_curry4);
    *(rcx) = rdi;
    *((rcx + 8)) = 9;
    rdi = *(reloc.camlArray__sortto_244);
    *((rcx + 0x10)) = rdi;
    *((rcx + 0x18)) = rbx;
    *((rcx + 0x20)) = rax;
    *((rcx + 0x28)) = rdx;
    rsi = *((rbx - 8));
    rsi >>= 9;
    rsi |= 1;
    if (rsi <= 0xb) {
        rdi = 1;
        rax = 1;
        void (*0x412420)() ();
    }
    *(rsp) = rcx;
    *((rsp + 0x28)) = rax;
    *((rsp + 0x20)) = rbx;
    rdx = rsi;
    rdx >>= 1;
    rax = rdx;
    rdx++;
    __asm ("cmovns rdx, rax");
    rdx >>= 1;
    rax = rdx + rdx + 1;
    *((rsp + 0x10)) = rax;
    rdi = rsi;
    rdi -= rax;
    rdi++;
    *((rsp + 8)) = rdi;
    rax = *((rbx - 8));
    rdx = *((rbx - 8));
    rdx &= 0xff;
    if (rdx != 0xfe) {
        rax >>= 9;
        if (rax <= 1) {
            goto label_2;
        }
        rax = *(rbx);
        goto label_3;
    }
    rax >>= 9;
    if (rax <= 1) {
        goto label_4;
    }
    do {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rbx]");
            __asm ("movlpd qword [rax], xmm0");
label_3:
            rsi = rax;
            rax = *(reloc.caml_make_vect);
            rax = caml_c_call ();
            rbx = rax;
            *((rsp + 0x18)) = rbx;
            rdi = 1;
            rax = *((rsp + 0x10));
            rsi = *((rsp + 8));
            rdx = *(rsp);
            camlArray_sortto_244 ();
            rax = 1;
            rbx = *((rsp + 0x20));
            rdi = *((rsp + 8));
            rsi = *((rsp + 0x10));
            rdx = *(rsp);
            camlArray_sortto_244 ();
            r8 = 1;
            rsi = 1;
            rax = *((rsp + 8));
            rbx = *((rsp + 0x10));
            rdi = *((rsp + 0x18));
            rdx = rax;
            rcx = *((rsp + 0x20));
            r9 = *((rsp + 0x28));
            void (*0x4122a0)() ();
        }
        caml_call_gc ();
    } while (1);
label_1:
    caml_call_gc ();
    goto label_0;
label_4:
    caml_ml_array_bound_error ();
label_2:
    caml_ml_array_bound_error ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42f810 */
#include <stdint.h>
 
int32_t caml_sys_close (int64_t fildes) {
    rdi = fildes;
    rdi >>= 1;
    close (rdi);
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429670 */
#include <stdint.h>
 
void caml_copy_nativeint (int64_t arg1) {
    rdi = arg1;
    ecx = 1;
    rbx = rdi;
    edx = 0;
    esi = 8;
    edi = caml_nativeint_ops;
    caml_alloc_custom ();
    *((rax + 8)) = rbx;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41ecf0 */
#include <stdint.h>
 
int64_t loc_camlCallback_code_begin (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.caml_register_named_value);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x430d00 */
#include <stdint.h>
 
uint64_t caml_gc_counters (int64_t arg7, int64_t arg8) {
    int64_t var_10h;
    int64_t var_20h;
    int64_t var_30h;
    int64_t var_38h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_78h;
    xmm0 = arg7;
    xmm1 = arg8;
    rbx = caml_local_roots;
    rax = rsp + 0x30;
    *((rsp + 0x78)) = 0;
    *((rsp + 0x40)) = 1;
    *((rsp + 0x38)) = 1;
    xmm2 = caml_stat_promoted_words;
    *(obj.caml_local_roots) = rax;
    rax = rsp + 0x78;
    *((rsp + 0x30)) = rbx;
    *((rsp + 0x48)) = rax;
    rax = caml_young_end;
    rax -= *(obj.caml_young_ptr);
    rax >>= 3;
    __asm ("cvtsi2sd xmm0, rax");
    rax = caml_allocated_words;
    __asm ("addsd xmm0, qword [obj.caml_stat_minor_words]");
    if (rax < 0) {
        goto label_0;
    }
    __asm ("cvtsi2sd xmm1, rax");
    do {
        __asm ("addsd xmm1, qword [obj.caml_stat_major_words]");
        edi = 3;
        *((rsp + 0x10)) = xmm2;
        *((rsp + 0x20)) = xmm0;
        *(rsp) = xmm1;
        rax = caml_alloc_tuple ();
        xmm0 = *((rsp + 0x20));
        *((rsp + 0x78)) = rax;
        rax = caml_copy_double ();
        rdi = *((rsp + 0x78));
        rsi = rax;
        caml_modify ();
        xmm2 = *((rsp + 0x10));
        __asm ("movapd xmm0, xmm2");
        rax = caml_copy_double ();
        rdi = *((rsp + 0x78));
        rsi = rax;
        rdi += 8;
        caml_modify ();
        xmm1 = *(rsp);
        __asm ("movapd xmm0, xmm1");
        rax = caml_copy_double ();
        rdi = *((rsp + 0x78));
        rsi = rax;
        rdi += 0x10;
        caml_modify ();
        *(obj.caml_local_roots) = rbx;
        rax = *((rsp + 0x78));
        return rax;
label_0:
        rdx = rax;
        eax &= 1;
        rdx >>= 1;
        rdx |= rax;
        __asm ("cvtsi2sd xmm1, rdx");
        __asm ("addsd xmm1, xmm1");
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415980 */
#include <stdint.h>
 
int64_t camlList_exists2_181 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, uint32_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    uint32_t var_10h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    do {
        rsi = rax;
        if (rbx == 1) {
            goto label_0;
        }
        if (rdi == 1) {
            goto label_1;
        }
        *(rsp) = rsi;
        rax = *((rdi + 8));
        *((rsp + 0x10)) = rax;
        rdi = *(rdi);
        rax = *((rbx + 8));
        *((rsp + 8)) = rax;
        rax = *(rbx);
        rbx = rdi;
        rdi = rsi;
        rax = caml_apply2 ();
        if (rax != 1) {
            rax = 3;
            return rax;
        }
        rax = *(rsp);
        rbx = *((rsp + 8));
        rdi = *((rsp + 0x10));
    } while (1);
label_0:
    if (rdi == 1) {
        rax = 1;
        return rax;
    }
label_1:
    rax = *(loc.camlList__42);
    return camlPervasives_invalid_arg_40 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x41e5a0 */
#include <stdint.h>
 
int64_t camlPrintf_ifprintf_421 (void) {
    rax = *(reloc.camlPrintf);
    rbx = *((rax + 0xe8));
    rax = *(loc.camlPrintf__44);
    rdi = *(rbx);
    return void (*rdi)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x413670 */
#include <stdint.h>
 
int64_t camlArray_to_list_148 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rsi = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rdi = r15 + 8;
            *((rdi - 8)) = 0x10f7;
            rax = *(reloc.caml_curry2);
            *(rdi) = rax;
            *((rdi + 8)) = 5;
            rax = *(reloc.camlArray__tolist_150);
            *((rdi + 0x10)) = rax;
            *((rdi + 0x18)) = rsi;
            rbx = 1;
            rax = *((rsi - 8));
            rax >>= 9;
            rax |= 1;
            rax += 0xfffffffffffffffe;
            void (*0x411620)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40aeb0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1647 (void) {
    rdi = rax;
    rax = *(reloc.unix_setgid);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a1c0 */
#include <stdint.h>
 
void caml_atan_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    atan (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x430e30 */
#include <stdint.h>
 
uint64_t caml_gc_quick_stat (int64_t arg7, int64_t arg8) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_20h;
    int64_t var_30h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    int64_t var_88h;
    xmm0 = arg7;
    xmm1 = arg8;
    r12 = caml_local_roots;
    rax = rsp + 0x40;
    *((rsp + 0x88)) = 0;
    *((rsp + 0x50)) = 1;
    *((rsp + 0x48)) = 1;
    xmm2 = caml_stat_promoted_words;
    *(obj.caml_local_roots) = rax;
    rax = rsp + 0x88;
    *((rsp + 0x40)) = r12;
    *((rsp + 0x58)) = rax;
    rax = caml_young_end;
    rax -= *(obj.caml_young_ptr);
    rax >>= 3;
    __asm ("cvtsi2sd xmm0, rax");
    rax = caml_allocated_words;
    __asm ("addsd xmm0, qword [obj.caml_stat_minor_words]");
    if (rax < 0) {
        goto label_0;
    }
    __asm ("cvtsi2sd xmm1, rax");
    do {
        __asm ("addsd xmm1, qword [obj.caml_stat_major_words]");
        rdx = caml_stat_minor_collections;
        edi = 0xf;
        *((rsp + 0x20)) = xmm2;
        r15 = caml_stat_major_collections;
        r13 = caml_stat_compactions;
        r14 = caml_stat_heap_chunks;
        *((rsp + 0x30)) = xmm0;
        rbp = caml_stat_heap_size;
        *((rsp + 8)) = rdx;
        rbx = caml_stat_top_heap_size;
        rbp >>= 3;
        *((rsp + 0x10)) = xmm1;
        rax = caml_alloc_tuple ();
        xmm0 = *((rsp + 0x30));
        rbx >>= 3;
        *((rsp + 0x88)) = rax;
        rax = caml_copy_double ();
        rdi = *((rsp + 0x88));
        rsi = rax;
        caml_modify ();
        xmm2 = *((rsp + 0x20));
        __asm ("movapd xmm0, xmm2");
        rax = caml_copy_double ();
        rdi = *((rsp + 0x88));
        rsi = rax;
        rdi += 8;
        caml_modify ();
        xmm1 = *((rsp + 0x10));
        __asm ("movapd xmm0, xmm1");
        rax = caml_copy_double ();
        rdi = *((rsp + 0x88));
        rsi = rax;
        rdi += 0x10;
        caml_modify ();
        rdx = *((rsp + 8));
        rdi = *((rsp + 0x88));
        rsi = rdx + rdx + 1;
        rdi += 0x18;
        caml_modify ();
        rdi = *((rsp + 0x88));
        rsi = r15 + r15 + 1;
        rdi += 0x20;
        caml_modify ();
        rdi = *((rsp + 0x88));
        rsi = rbp + rbp + 1;
        rdi += 0x28;
        caml_modify ();
        rdi = *((rsp + 0x88));
        rsi = r14 + r14 + 1;
        rdi += 0x30;
        caml_modify ();
        rdi = *((rsp + 0x88));
        esi = 1;
        rdi += 0x38;
        caml_modify ();
        rdi = *((rsp + 0x88));
        esi = 1;
        rdi += 0x40;
        caml_modify ();
        rdi = *((rsp + 0x88));
        esi = 1;
        rdi += 0x48;
        caml_modify ();
        rdi = *((rsp + 0x88));
        esi = 1;
        rdi += 0x50;
        caml_modify ();
        rdi = *((rsp + 0x88));
        esi = 1;
        rdi += 0x58;
        caml_modify ();
        rdi = *((rsp + 0x88));
        esi = 1;
        rdi += 0x60;
        caml_modify ();
        rdi = *((rsp + 0x88));
        rsi = r13 + r13 + 1;
        rdi += 0x68;
        caml_modify ();
        rdi = *((rsp + 0x88));
        rsi = rbx + rbx + 1;
        rdi += 0x70;
        caml_modify ();
        *(obj.caml_local_roots) = r12;
        rax = *((rsp + 0x88));
        return rax;
label_0:
        rdx = rax;
        eax &= 1;
        rdx >>= 1;
        rdx |= rax;
        __asm ("cvtsi2sd xmm1, rdx");
        __asm ("addsd xmm1, xmm1");
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4134f0 */
#include <stdint.h>
 
int64_t camlArray_mapi_142 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdi = rax;
    rax = *((rbx - 8));
    rax >>= 9;
    rax |= 1;
    if (rax == 1) {
        rax = *(loc.camlArray__23);
        return rax;
    }
    *(rsp) = rax;
    *((rsp + 8)) = rbx;
    *((rsp + 0x10)) = rdi;
    rax = *((rbx - 8));
    if (rax != 0xfe) {
        rbx = *(rbx);
    } else {
label_1:
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 < *(rax)) {
            goto label_2;
        }
        rsi = r15 + 8;
        *((rsi - 8)) = 0x4fd;
        __asm ("movlpd xmm0, qword [rbx]");
        __asm ("movlpd qword [rsi], xmm0");
        rbx = rsi;
    }
    rax = 1;
    rax = caml_apply2 ();
    rdi = *(rsp);
    rsi = rax;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = rax;
    rax = *(rsp);
    rax += 0xfffffffffffffffe;
    if (rbp > rax) {
        goto label_3;
    }
    *((rsp + 0x18)) = rax;
    *((rsp + 0x20)) = rbp;
    *(rsp) = rbx;
    do {
        rdi = *((rsp + 8));
        rax = *((rdi - 8));
        if (rax != 0xfe) {
            rbx = *((rdi + rbp*4 - 4));
        } else {
label_0:
            r15 -= 0x10;
            rax = *(reloc.caml_young_limit);
            if (r15 < *(rax)) {
                goto label_4;
            }
            rbx = r15 + 8;
            *((rbx - 8)) = 0x4fd;
            __asm ("movlpd xmm0, qword [rdi + rbp*4 - 4]");
            __asm ("movlpd qword [rbx], xmm0");
        }
        rax = rbp;
        rdi = *((rsp + 0x10));
        rax = caml_apply2 ();
        rbx = *(rsp);
        rdi = *((rbx - 8));
        if (rdi != 0xfe) {
            rbp = *((rsp + 0x20));
            rdi = rbx + rbp*4 - 4;
            rsi = rax;
            rax = caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [rax]");
            rbp = *((rsp + 0x20));
            __asm ("movlpd qword [rbx + rbp*4 - 4], xmm0");
        }
        rdi = rbp;
        rbp += 2;
        *((rsp + 0x20)) = rbp;
        rax = *((rsp + 0x18));
    } while (rdi != rax);
label_3:
    rax = rbx;
    return rax;
label_4:
    caml_call_gc ();
    goto label_0;
label_2:
    caml_call_gc ();
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a180 */
#include <stdint.h>
 
void caml_ceil_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    ceil (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b4a0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1741 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_chmod);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ae70 */
#include <stdint.h>
 
int64_t camlUnix_fun_1643 (void) {
    rdi = rax;
    rax = *(reloc.unix_getlogin);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42c350 */
#include <stdint.h>
 
uint64_t caml_really_putblock (int64_t arg3, int64_t arg2, int64_t arg1) {
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    r12 = rdi;
    rbx = rdx;
    if (rdx <= 0) {
        goto label_0;
    }
    do {
        rdx = rbx;
        rsi = rbp;
        rdi = r12;
        rax = caml_putblock ();
        rax = (int64_t) eax;
        rbx -= rax;
        rbp += rax;
    } while (rbx > 0);
label_0:
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x429ee0 */
#include <stdint.h>
 
int64_t caml_ge_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    __asm ("ucomisd xmm0, qword [rsi]");
    rax -= rax;
    rax &= 0xfffffffffffffffe;
    rax += 3;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b520 */
#include <stdint.h>
 
int64_t camlUnix_fun_1749 (void) {
    rdi = rax;
    rax = *(reloc.unix_isatty);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42ee80 */
#include <stdint.h>
 
uint64_t caml_input_value_from_malloc (int64_t arg2, int64_t arg1) {
    rsi = arg2;
    rdi = arg1;
    *(obj.intern_input) = rdi;
    rdi += rsi;
    rax = rdi + 4;
    *(obj.intern_input_malloced) = 1;
    *(obj.intern_src) = rax;
    edx = *(rdi);
    ebx = *((rax - 1));
    rdx <<= 0x18;
    rbx += rdx;
    edx = *((rax - 3));
    eax = *((rax - 2));
    edx <<= 0x10;
    eax <<= 8;
    rcx = (int64_t) edx;
    rax = (int64_t) eax;
    rdx = rbx + rcx;
    rax = rdx + rax;
    if (eax == 0x8495a6be) {
        rdi += 8;
        *(obj.intern_src) = rdi;
        rax = input_val_from_block ();
        rdi = intern_input;
        rbx = rax;
        caml_stat_free ();
        rax = rbx;
        return rax;
    }
    edi = "input_value_from_malloc: bad object";
    return caml_failwith ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434e80 */
#include <stdint.h>
 
void caml_start_program (void) {
    r12 = loc_caml_startup__code_begin;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40b4e0 */
#include <stdint.h>
 
int64_t camlUnix_fun_1745 (void) {
    rdi = rax;
    rsi = rbx;
    rax = *(reloc.unix_rename);
    caml_c_call ();
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4240d0 */
#include <stdint.h>
 
int64_t caml_do_roots (int64_t arg1) {
    rdi = arg1;
    r14d = 0;
    r12 = caml_globals;
    rbx = rdi;
    if (r12 == 0) {
        goto label_2;
    }
label_0:
    rax = *((r12 - 8));
    edx = 0;
    ebp = 0;
    r13 = r12 - 8;
    rax >>= 0xa;
    if (rax == 0) {
        goto label_3;
    }
    do {
        rax = r12 + rdx*8;
        ebp++;
        rsi = rax;
        rdi = *(rax);
        void (*rbx)() ();
        rax = *(r13);
        rdx = (int64_t) ebp;
        rax >>= 0xa;
    } while (rdx < rax);
label_3:
    r14d++;
    rax = (int64_t) r14d;
    r12 = *((rax*8 + loc.caml_globals));
    if (r12 != 0) {
        goto label_0;
    }
label_2:
    r14 = caml_dyn_globals;
    if (r14 == 0) {
        goto label_4;
    }
label_1:
    r12 = *(r14);
    rax = *((r12 - 8));
    r13 = r12 - 8;
    rax >>= 0xa;
    if (rax == 0) {
        goto label_5;
    }
    edx = 0;
    ebp = 0;
    do {
        rax = r12 + rdx*8;
        ebp++;
        rsi = rax;
        rdi = *(rax);
        void (*rbx)() ();
        rax = *(r13);
        rdx = (int64_t) ebp;
        rax >>= 0xa;
    } while (rdx < rax);
label_5:
    r14 = *((r14 + 8));
    if (r14 != 0) {
        goto label_1;
    }
label_4:
    while (1) {
        r8 = caml_local_roots;
        rcx = caml_gc_regs;
        rdi = rbx;
        rdx = caml_last_return_address;
        rsi = caml_bottom_of_stack;
        caml_do_local_roots ();
        rdi = rbx;
        caml_scan_global_roots ();
        rdi = rbx;
        caml_final_do_strong_roots ();
        rax = caml_scan_roots_hook;
        if (rax != 0) {
            rdi = rbx;
            void (*rax)() ();
        }
        return rax;
        caml_init_frame_descriptors ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x434220 */
#include <stdint.h>
 
uint64_t caml_find_custom_operations (int64_t arg1) {
    rdi = arg1;
    r12 = rdi;
    rbx = custom_ops_table;
    if (rbx != 0) {
        goto label_0;
    }
    goto label_1;
    do {
        rbx = *((rbx + 8));
        if (rbx == 0) {
            goto label_1;
        }
label_0:
        rbp = *(rbx);
        eax = strcmp (*(rbp), r12);
    } while (eax != 0);
    rax = rbp;
    return rax;
label_1:
    ebp = 0;
    rax = rbp;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x423950 */
#include <stdint.h>
 
int32_t main (int64_t arg2) {
    rsi = arg2;
    rdi = rsi;
    caml_main ();
    edi = 1;
    return caml_sys_exit ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408cc8 */
#include <stdint.h>
 
void init (void) {
    /* [11] -r-x section size 24 named .init */
    call_gmon_start ();
    frame_dummy ();
    _do_global_ctors_aux ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a280 */
#include <stdint.h>
 
void caml_cos_float (int64_t arg1) {
    rdi = arg1;
    xmm0 = *(rdi);
    cos (rdi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x412830 */
#include <stdint.h>
 
int64_t camlArray_init_65 (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    if (rax == 1) {
        rax = *(loc.camlArray__33);
        return rax;
    }
    rax = 1;
    rdi = *(rbx);
    rax = void (*rdi)(uint64_t, uint64_t) (rax, rbx);
    rdi = *(rsp);
    rsi = rax;
    rax = *(reloc.caml_make_vect);
    rax = caml_c_call ();
    rbx = rax;
    rax = *(rsp);
    rax += 0xfffffffffffffffe;
    if (rbp > rax) {
        goto label_0;
    }
    do {
        rbx = *((rsp + 8));
        rdi = *(rbx);
        rax = rbp;
        rax = void (*rdi)(uint64_t) (rax);
        rbx = *(rsp);
        rdi = *((rbx - 8));
        if (rdi != 0xfe) {
            rbp = *((rsp + 0x18));
            rdi = rbx + rbp*4 - 4;
            rsi = rax;
            rax = caml_modify ();
        } else {
            __asm ("movlpd xmm0, qword [rax]");
            rbp = *((rsp + 0x18));
            __asm ("movlpd qword [rbx + rbp*4 - 4], xmm0");
        }
        rdi = rbp;
        rbp += 2;
        *((rsp + 0x18)) = rbp;
        rax = *((rsp + 0x10));
    } while (rdi != rax);
label_0:
    rax = rbx;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x415690 */
#include <stdint.h>
 
int64_t camlList_rev_map2_127 (int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    rdx = rax;
    do {
        r15 -= 0x28;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0x10f7;
            rax = *(reloc.caml_curry3);
            *(rsi) = rax;
            *((rsi + 8)) = 7;
            rax = *(reloc.camlList__rmap2_f_131);
            *((rsi + 0x10)) = rax;
            *((rsi + 0x18)) = rdx;
            rax = 1;
            void (*0x414430)() ();
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4347d0 */
#include <stdint.h>
 
uint64_t caml_get_exception_backtrace (void) {
    int64_t var_8h;
    int64_t var_10h;
    int64_t var_18h;
    int64_t var_20h;
    int64_t var_28h;
    int64_t var_30h;
    int64_t var_40h;
    int64_t var_48h;
    int64_t var_50h;
    int64_t var_58h;
    esi = 0;
    rdi = *(obj.caml_backtrace_pos);
    r14 = caml_local_roots;
    rax = rsp + 0x58;
    *((rsp + 0x58)) = 0;
    *((rsp + 0x50)) = 0;
    *((rsp + 0x48)) = 0;
    *((rsp + 0x40)) = 0;
    *((rsp + 0x18)) = rax;
    rax = rsp + 0x50;
    *(rsp) = r14;
    *(obj.caml_local_roots) = rsp;
    *((rsp + 0x10)) = 1;
    *((rsp + 0x20)) = rax;
    rax = rsp + 0x48;
    *((rsp + 8)) = 4;
    *((rsp + 0x28)) = rax;
    rax = rsp + 0x40;
    *((rsp + 0x30)) = rax;
    rax = caml_alloc ();
    *((rsp + 0x50)) = rax;
    eax = caml_backtrace_pos;
    if (eax <= 0) {
        goto label_1;
    }
    ebx = 0;
    ebp = 0;
    while ((*((rax + 8)) & 1) != 0) {
        edx = *((rax + 0xa));
        rax = rax + rdx*2 + 0x13;
        rax &= 0xfffffffffffffff8;
        r12d = *(rax);
        r13d = *((rax + 4));
        rdi = r12;
        edi &= 0x3fffffc;
        rdi += rax;
        rax = caml_copy_string ();
        esi = 0;
        edi = 5;
        *((rsp + 0x40)) = rax;
        rax = caml_alloc_small ();
        edx = r12d;
        *((rsp + 0x48)) = rax;
        edx &= 3;
        rdx -= rdx;
        r12d >>= 0x1a;
        rdx &= 0xfffffffffffffffe;
        rdx += 3;
        *(rax) = rdx;
        rdx = *((rsp + 0x40));
        rax = *((rsp + 0x48));
        *((rax + 8)) = rdx;
        eax = r13d;
        eax >>= 0xc;
        rax = (int64_t) eax;
        rdx = rax + rax + 1;
        rax = *((rsp + 0x48));
        *((rax + 0x10)) = rdx;
        eax = r13d;
        r13d &= 0xf;
        eax >>= 4;
        r13d <<= 6;
        eax = (int32_t) al;
        r13d |= r12d;
        rdx = rax + rax + 1;
        rax = *((rsp + 0x48));
        r13 = (int64_t) r13d;
        *((rax + 0x18)) = rdx;
        rax = *((rsp + 0x48));
        rdx = r13 + r13 + 1;
        *((rax + 0x20)) = rdx;
label_0:
        rdi = rbx;
        rdi += *((rsp + 0x50));
        rsi = *((rsp + 0x48));
        ebp++;
        rbx += 8;
        caml_modify ();
        if (*(obj.caml_backtrace_pos) <= ebp) {
            goto label_1;
        }
        rax = caml_backtrace_buffer;
        rax = *((rax + rbx));
    }
    esi = 1;
    edi = 1;
    rax = caml_alloc_small ();
    *((rsp + 0x48)) = rax;
    *(rax) = 3;
    goto label_0;
label_1:
    esi = 0;
    edi = 1;
    rax = caml_alloc_small ();
    rdx = *((rsp + 0x50));
    *((rsp + 0x58)) = rax;
    *(obj.caml_local_roots) = r14;
    *(rax) = rdx;
    rax = *((rsp + 0x58));
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4347b0 */
#include <stdint.h>
 
int64_t caml_backtrace_status (void) {
    rax -= rax;
    rax &= 0xfffffffffffffffe;
    rax += 3;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42b3a0 */
#include <stdint.h>
 
int64_t caml_pos_out (int64_t arg1) {
    rdi = arg1;
    rax = *((rdi + 0x18));
    rax += *((rdi + 8));
    rdi += 0x50;
    rax -= rdi;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x428b80 */
#include <stdint.h>
 
uint64_t caml_lessthan (void) {
    edx = 0;
    rax = compare_val ();
    rbx = rax;
    if (*(obj.compare_stack) != 0x652500) {
        compare_free_stack ();
    }
    rdx = 0x7fffffffffffffff;
    rax = rbx + rdx;
    rdx--;
    rax -= rax;
    rax &= 0xfffffffffffffffe;
    rax += 3;
    return rax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x42a5c0 */
#include <stdint.h>
 
void caml_fmod_float (arithmetic y, arithmetic x) {
    int64_t var_8h;
    int64_t var_18h;
    rsi = y;
    rdi = x;
    *(fp_stack--) = *(rdi);
    *(fp_stack--) = *(rsi);
    *(fp_stack--) = fp_stack[0];
    *(fp_stack--) = fp_stack[2];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
    } while ((ah & 4) != 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *((rsp + 0x18)) = fp_stack[0];
    fp_stack--;
    xmm0 = *((rsp + 0x18));
    __asm ("ucomisd xmm0, xmm0");
    if ((ah & 4) != 0) {
        if ((ah & 4) != 0) {
            goto label_0;
        }
        fp_stack++;
        fp_stack++;
        void (*0x42a120)() ();
    }
label_0:
    *((rsp + 8)) = fp_stack[0];
    fp_stack--;
    xmm1 = *((rsp + 8));
    *((rsp + 8)) = fp_stack[0];
    fp_stack--;
    xmm0 = *((rsp + 8));
    fmod (rdi, rsi);
    return caml_copy_double ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408d20 */
#include <stdint.h>
 
void tcsetattr (void) {
    tcsetattr ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408d80 */
#include <stdint.h>
 
void execv (void) {
    execv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408e10 */
#include <stdint.h>
 
void inet_pton (void) {
    inet_pton ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408e50 */
#include <stdint.h>
 
void utime (void) {
    utime ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408e60 */
#include <stdint.h>
 
void h_errno_location (void) {
    h_errno_location ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408e90 */
#include <stdint.h>
 
void ldexp (void) {
    ldexp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408ee0 */
#include <stdint.h>
 
void select (void) {
    select ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408ef0 */
#include <stdint.h>
 
void execvp (void) {
    execvp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408f00 */
#include <stdint.h>
 
void getpeername (void) {
    getpeername ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408f20 */
#include <stdint.h>
 
void getaddrinfo (void) {
    getaddrinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408fd0 */
#include <stdint.h>
 
void getgroups (void) {
    getgroups ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408fe0 */
#include <stdint.h>
 
void sigismember (void) {
    sigismember ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408ff0 */
#include <stdint.h>
 
void memcpy_chk (void) {
    memcpy_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409020 */
#include <stdint.h>
 
void setsockopt (void) {
    setsockopt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409050 */
#include <stdint.h>
 
void gethostbyaddr_r (void) {
    gethostbyaddr_r ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4090b0 */
#include <stdint.h>
 
void freeaddrinfo (void) {
    freeaddrinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409150 */
#include <stdint.h>
 
void recv_chk (void) {
    recv_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409180 */
#include <stdint.h>
 
void ctype_b_loc (void) {
    ctype_b_loc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409190 */
#include <stdint.h>
 
void cfsetospeed (void) {
    cfsetospeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4091b0 */
#include <stdint.h>
 
void read_chk (void) {
    read_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4091c0 */
#include <stdint.h>
 
void dlerror (void) {
    dlerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409210 */
#include <stdint.h>
 
void dlclose (void) {
    dlclose ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409250 */
#include <stdint.h>
 
void strerror (void) {
    strerror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409280 */
#include <stdint.h>
 
void cfgetispeed (void) {
    cfgetispeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4092b0 */
#include <stdint.h>
 
void strcat (void) {
    strcat ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4092c0 */
#include <stdint.h>
 
void getsockopt (void) {
    getsockopt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4092d0 */
#include <stdint.h>
 
void strtol (void) {
    strtol ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409300 */
#include <stdint.h>
 
void getsockname (void) {
    getsockname ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409310 */
#include <stdint.h>
 
void connect (void) {
    connect ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409330 */
#include <stdint.h>
 
void gethostbyname_r (void) {
    gethostbyname_r ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409340 */
#include <stdint.h>
 
void execve (void) {
    execve ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409360 */
#include <stdint.h>
 
void tcgetattr (void) {
    tcgetattr ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409370 */
#include <stdint.h>
 
void memcpy (void) {
    memcpy ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4093e0 */
#include <stdint.h>
 
void getrlimit64 (void) {
    getrlimit64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409410 */
#include <stdint.h>
 
void cfgetospeed (void) {
    cfgetospeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409420 */
#include <stdint.h>
 
void recvfrom_chk (void) {
    recvfrom_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409450 */
#include <stdint.h>
 
void sigaddset (void) {
    sigaddset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409470 */
#include <stdint.h>
 
void getnameinfo (void) {
    getnameinfo ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409480 */
#include <stdint.h>
 
void strcmp (void) {
    strcmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409490 */
#include <stdint.h>
 
void cfsetispeed (void) {
    cfsetispeed ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4094a0 */
#include <stdint.h>
 
void getcwd (void) {
    getcwd ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4094b0 */
#include <stdint.h>
 
void send (void) {
    send ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409550 */
#include <stdint.h>
 
void dlopen (void) {
    dlopen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409580 */
#include <stdint.h>
 
void dlsym (void) {
    dlsym ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4095b0 */
#include <stdint.h>
 
void sprintf_chk (void) {
    sprintf_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409610 */
#include <stdint.h>
 
void sendto (void) {
    sendto ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409620 */
#include <stdint.h>
 
void bind (void) {
    bind ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409630 */
#include <stdint.h>
 
void sigdelset (void) {
    sigdelset ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409650 */
#include <stdint.h>
 
void setlocale (void) {
    setlocale ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409670 */
#include <stdint.h>
 
void sigsetjmp (void) {
    sigsetjmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409690 */
#include <stdint.h>
 
void memmove_chk (void) {
    memmove_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4096d0 */
#include <stdint.h>
 
void accept (void) {
    accept ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409700 */
#include <stdint.h>
 
void inet_ntop (void) {
    inet_ntop ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409720 */
#include <stdint.h>
 
void fcntl (void) {
    fcntl ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409780 */
#include <stdint.h>
 
void strtod (void) {
    strtod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409790 */
#include <stdint.h>
 
void readdir64 (void) {
    readdir64 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4097c0 */
#include <stdint.h>
 
void fflush (void) {
    fflush ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409000 */
#include <stdint.h>
 
void cos (void) {
    cos ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408d90 */
#include <stdint.h>
 
void tanh (void) {
    tanh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4096e0 */
#include <stdint.h>
 
void sqrt (void) {
    sqrt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409760 */
#include <stdint.h>
 
void log (void) {
    log ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4094d0 */
#include <stdint.h>
 
void acos (void) {
    acos ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408d30 */
#include <stdint.h>
 
void exp (void) {
    exp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409750 */
#include <stdint.h>
 
void sin (void) {
    sin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4097d0 */
#include <stdint.h>
 
void sinh (void) {
    sinh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408d60 */
#include <stdint.h>
 
void atan2 (void) {
    atan2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408e80 */
#include <stdint.h>
 
void tan (void) {
    tan ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409140 */
#include <stdint.h>
 
void cosh (void) {
    cosh ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4091e0 */
#include <stdint.h>
 
void asin (void) {
    asin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409660 */
#include <stdint.h>
 
void floor (void) {
    floor ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x408cf0 */
#include <stdint.h>
 
void log10 (void) {
    log10 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409220 */
#include <stdint.h>
 
void pow (void) {
    pow ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x409090 */
#include <stdint.h>
 
void fmod (void) {
    fmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x4090f0 */
#include <stdint.h>
 
void atan (void) {
    atan ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40e97e */
#include <stdint.h>
 
int64_t fcn_0040e97e (uint32_t arg3) {
    rdx = arg3;
    *((rax - 0x77)) += cl;
    eax = (int32_t) ax;
    *(rax) += al;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40ec7f */
#include <stdint.h>
 
int64_t fcn_0040ec7f (void) {
    *(rax) += eax;
    *((rax - 0x75)) += cl;
    eax -= 0x230eaf;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40c708 */
#include <stdint.h>
 
int64_t fcn_0040c708 (int64_t arg_10h) {
    r14 = rsp;
    rax = 3;
    rax = camlList_mem_189 ();
    while (1) {
        r15 -= 0x10;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rax = r15 + 8;
            *((rax - 8)) = 0x400;
            rbx = *(reloc.caml_exn_Not_found);
            *(rax) = rbx;
            caml_raise_exn ();
            rdi = *((rsp + 0x10));
            rax = *(reloc.unix_gethostbyaddr);
            rax = caml_c_call ();
            rax = *(rax);
            *((rsp + 0x10)) = rax;
        }
        caml_call_gc ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40cd98 */
#include <stdint.h>
 
int64_t fcn_0040cd98 (int64_t arg_18h, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r14 = rsp;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0xc00;
            rax = *(loc.camlUnix__184);
            *(rsi) = rax;
            rax = *(loc.camlUnix__185);
            *((rsi + 8)) = rax;
            rax = *((rsp + 0x18));
            *((rsi + 0x10)) = rax;
            rdi = *(loc.camlUnix__183);
            rax = *(reloc.unix_execv);
            caml_c_call ();
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40d208 */
#include <stdint.h>
 
int64_t fcn_0040d208 (int64_t arg_30h, int64_t arg_38h, int64_t arg6, int64_t arg5, int64_t arg4, int64_t arg3, int64_t arg2, int64_t arg1, int64_t arg7, int64_t arg8, int64_t arg9, int64_t arg10, int64_t arg11) {
    r9 = arg6;
    r8 = arg5;
    rcx = arg4;
    rdx = arg3;
    rsi = arg2;
    rdi = arg1;
    xmm0 = arg7;
    xmm1 = arg8;
    xmm2 = arg9;
    xmm3 = arg10;
    xmm4 = arg11;
    r14 = rsp;
    do {
        r15 -= 0x20;
        rax = *(reloc.caml_young_limit);
        if (r15 >= *(rax)) {
            rsi = r15 + 8;
            *((rsi - 8)) = 0xc00;
            rax = *(loc.camlUnix__180);
            *(rsi) = rax;
            rax = *(loc.camlUnix__181);
            *((rsi + 8)) = rax;
            rax = *((rsp + 0x30));
            *((rsi + 0x10)) = rax;
            rdi = *(loc.camlUnix__179);
            rdx = *((rsp + 0x38));
            rax = *(reloc.unix_execve);
            caml_c_call ();
            return rax;
        }
        caml_call_gc ();
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_shootout/ackermann_ocaml/x64_elf/subject.exe @ 0x40f6dc */
#include <stdint.h>
 
int64_t fcn_0040f6dc (void) {
    r14 = rsp;
    rax = *(reloc.caml_ml_flush);
    caml_c_call ();
}
