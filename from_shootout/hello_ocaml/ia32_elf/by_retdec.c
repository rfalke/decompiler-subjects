//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <setjmp.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int3_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_sigset_t {
    int32_t e0[1];
};

struct sigaction {
    void (*e0)(int32_t);
    int32_t e1;
    void (*e2)();
    struct _TYPEDEF_sigset_t e3;
};

struct sigaltstack {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int32_t add_char(void);
int32_t add_string(void);
int32_t allocate_block(int32_t a1);
int32_t caml_add_to_heap(uint32_t a1);
int32_t caml_aligned_malloc(int32_t a1, int32_t a2, int32_t * a3);
int32_t caml_alloc_for_heap(int32_t a1);
int32_t caml_alloc_shr(uint32_t a1, int32_t a2);
int32_t caml_callback_exn(int32_t a1, int32_t a2);
int32_t caml_compact_heap(void);
int32_t caml_compact_heap_maybe(void);
int32_t caml_darken(uint32_t result, int32_t a2);
int32_t caml_darken_all_roots(void);
int32_t caml_debugger_init(void);
int32_t caml_decompose_path(int32_t * a1, int32_t str2);
int32_t caml_delete_global_root(int32_t a1);
int32_t caml_do_local_roots(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t caml_do_roots(int32_t a1);
int32_t caml_empty_minor_heap(void);
int32_t caml_executable_name(int32_t * buf, int32_t buf_size);
int32_t caml_ext_table_add(int32_t * a1, int32_t a2);
int32_t caml_ext_table_free(int32_t * a1, int32_t a2);
int32_t caml_ext_table_init(int32_t * a1, int32_t a2);
int32_t caml_fatal_error(char * str);
int32_t caml_fatal_uncaught_exception(int32_t a1);
int32_t caml_final_do_calls(void);
int32_t caml_final_do_strong_roots(int32_t a1);
int32_t caml_final_do_weak_roots(int32_t a1);
int32_t caml_final_do_young_roots(int32_t a1);
int32_t caml_final_empty_young(void);
int32_t caml_final_update(void);
int32_t caml_finish_major_cycle(void);
int32_t caml_fl_add_blocks(uint32_t a1);
int32_t caml_fl_allocate(uint32_t a1);
int32_t caml_fl_init_merge(void);
int32_t caml_fl_merge_block(int32_t a1);
int32_t caml_fl_reset(void);
int32_t caml_format_exception(int32_t a1);
int32_t caml_free_for_heap(int32_t a1);
int32_t caml_gc_message(uint32_t result, char * format, int32_t a3);
int32_t caml_init_custom_operations(void);
int32_t caml_init_frame_descriptors(void);
int32_t caml_init_gc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t caml_init_ieee_floats(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t caml_init_major_heap(int32_t a1);
int32_t caml_init_signals(void);
int32_t caml_insert_global_root(void);
int32_t caml_iterate_global_roots(void);
int32_t caml_main(int32_t a1);
int32_t caml_major_collection_slice(int32_t a1);
int32_t caml_make_free_blocks(int32_t a1, int32_t a2, int32_t a3);
int32_t caml_minor_collection(void);
int32_t caml_named_value(int32_t str);
int32_t caml_oldify_local_roots(void);
int32_t caml_oldify_mopup(void);
int32_t caml_oldify_one(uint32_t a1, int32_t a2);
int32_t caml_page_table_add(int32_t a1, int32_t * a2, int32_t * a3);
int32_t caml_page_table_initialize(int32_t a1);
int32_t caml_page_table_modify(void);
int32_t caml_page_table_remove(int32_t a1, int32_t a2, int32_t a3);
int32_t caml_print_exception_backtrace(void);
int32_t caml_raise(int32_t a1);
int32_t caml_raise_exception(int32_t result);
int32_t caml_raise_out_of_memory(void);
int32_t caml_record_backtrace(int32_t a1);
int32_t caml_register_custom_operations(char (**a1)[3]);
int32_t caml_register_frametable(int32_t a1);
int32_t caml_register_global_root(int32_t * a1);
int32_t caml_remove_global_root(int32_t * a1);
int32_t caml_round_heap_chunk_size(uint32_t a1);
int32_t caml_scan_global_roots(int32_t a1);
int32_t caml_scan_global_young_roots(int32_t a1);
int32_t caml_search_exe_in_path(int32_t a1);
int32_t caml_search_in_path(int32_t a1, int32_t a2);
int32_t caml_set_allocation_policy(int32_t result);
int32_t caml_set_minor_heap_size(int32_t a1);
int32_t caml_shrink_heap(int32_t a1);
int32_t caml_start_program(void);
int32_t caml_stash_backtrace(int32_t a1, int32_t a2, int32_t * a3, uint32_t a4);
int32_t caml_stat_alloc(int32_t size);
int32_t caml_stat_free(int32_t a1);
int32_t caml_stat_resize(int32_t a1, int32_t a2);
int32_t caml_sys_exit(int32_t a1);
int32_t caml_sys_init(int32_t a1, int32_t result);
int32_t caml_urge_major_slice(void);
int32_t clear_table(void);
int32_t clip_heap_chunk_size(int32_t a1);
int32_t compact_allocate(void);
int32_t cons(int32_t a1);
int32_t extract_location_info(void);
int32_t function_806aa19(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t hash_value_name(int32_t a1, int32_t a2, int32_t a3);
int32_t init_compact_allocate(void);
int32_t invert_pointer_at(void);
int32_t mark_slice(void);
int32_t norm_heapincr(void);
int32_t norm_minsize(void);
int32_t norm_pfree(void);
int32_t norm_pmax(void);
int32_t realloc_gray_vals(int32_t a1);
int32_t reset_table(void);
int32_t scanmult(void);
int32_t start_cycle(int32_t a1);
int32_t sweep_slice(void);
int32_t truncate_flp(void);

// --------------------- Global Variables ---------------------

char * g1; // 0x806c248
char (*g2)[14] = "Out_of_memory"; // 0x806d9a8
int32_t g4; // 0x806db54
int32_t g5; // 0x806dd78
int32_t g6; // 0x806dd7c
int32_t g7 = 0x804a9d0; // 0x806ddd4
int32_t g8 = 0x804b165; // 0x806ddd8
int32_t g9 = 0x804eab0; // 0x806dddc
int32_t g10; // 0x806de30
int32_t g11 = 500; // 0x80740b8
int32_t g12 = 80; // 0x80740bc
int32_t g13 = 0x1f000; // 0x80740c0
int32_t g14 = 0x1f000; // 0x80740c4
int32_t g15 = 0x40000; // 0x80740c8
int32_t g16 = 1; // 0x80740ec
int32_t g17 = 0x805cee5; // 0x80740f8
int32_t g19 = 0; // 0x8074108
int32_t g20; // 0x8074110
char (*g21)[3] = "_i"; // 0x807411c
char (*g22)[3] = "_j"; // 0x8074138
char (*g23)[3] = "_n"; // 0x8074154
int32_t g25 = 1; // 0x80741c8
struct _IO_FILE * g26 = NULL; // 0x8074220
int32_t g27 = 0; // 0x8074280
int32_t g28 = 0; // 0x80742a0
int32_t g29 = 0; // 0x80743a0
int32_t g30 = 0; // 0x80743b4
int32_t g31 = 0; // 0x80743b8
int32_t g32 = 0; // 0x80743bc
int32_t g33 = 0; // 0x80743c0
int32_t g34 = 0; // 0x80743c4
int32_t g35 = 0; // 0x80743cc
int32_t g36 = 0; // 0x80743d0
int32_t g37 = 0; // 0x80743d4
int32_t g38 = 0; // 0x80743d8
int32_t g39 = 0; // 0x8074444
int32_t g40 = 0; // 0x8074488
int64_t g41 = 0; // 0x80744ec
int32_t g42 = 0; // 0x80744f4
int32_t g43 = 0; // 0x8074500
int32_t g44 = 0; // 0x8074520
int32_t g45 = 0; // 0x8076520
int64_t g46 = 0; // 0x8076540
int32_t g47 = 0; // 0x8076544
int32_t g48 = 0; // 0x8076548
int32_t g49 = 0; // 0x807654c
int32_t g50 = 0; // 0x8076550
int32_t g51 = 0; // 0x807655c
int32_t g52 = 0; // 0x8076560
int32_t g53 = 0; // 0x8076564
int32_t g54 = 0; // 0x80774fc
int32_t g55 = 0; // 0x8077500
int64_t g56 = 0; // 0x8077504
int32_t g57 = 0; // 0x8077508
int32_t g58 = 0; // 0x807750c
int32_t g59 = 0; // 0x8077510
int32_t g60 = 0; // 0x8077514
int32_t g61 = 0; // 0x8077518
int32_t g62 = 0; // 0x807751c
int32_t g63 = 0; // 0x8077520
int32_t g64 = 0; // 0x8077524
int32_t g65 = 0; // 0x8077528
int32_t g66 = 0; // 0x807752c
int32_t g67 = 0; // 0x8077530
int32_t g68 = 0; // 0x8077534
int32_t g69 = 0; // 0x8077538
int32_t g70 = 0; // 0x807753c
int32_t g71 = 0; // 0x8077548
int32_t g72 = 0; // 0x8077558
int32_t g73 = 0; // 0x8077564
int32_t g74 = 0; // 0x8077574
int32_t g75 = 0; // 0x8077578
int32_t g76 = 0; // 0x807757c
int32_t g77 = 0; // 0x8077580
int32_t g78 = 0; // 0x807aa34
int32_t g79 = 0; // 0x807aa38
float64_t g80 = 0.0; // 0x807aa40
float64_t g81 = 0.0; // 0x807aa48
float64_t g82 = 0.0; // 0x807aa50
int32_t g83 = 0; // 0x807aa58
int32_t g84 = 0; // 0x807aa5c
int32_t g85 = 0; // 0x807aa60
int32_t g86 = 0; // 0x807aa64
int32_t g87 = 0; // 0x807aa68
int32_t g88 = 0; // 0x807aa6c
int32_t g89 = 0; // 0x807aa80
int32_t g90 = 0; // 0x807aab4
int32_t g91 = 0; // 0x807aab8
int32_t g92 = 0; // 0x807aabc
int32_t g93 = 0; // 0x807aac0
int32_t g94 = 0; // 0x807aac4
int32_t g95 = 0; // 0x807aacc
int32_t g96 = 0; // 0x807aad0
int32_t g97 = 0; // 0x807aad4
int32_t g98 = 0; // 0x807aad8
int32_t g99 = 0; // 0x807aae0
int32_t g100 = 0; // 0x807aae4
int32_t g101 = 0; // 0x807aae8
int32_t g102 = 0; // 0x807aaec
int32_t g103 = 0; // 0x807ab00
int32_t g104 = 0; // 0x807ab20
int32_t g105 = 0; // 0x807abbc
int32_t g106 = 0; // 0x807abc0
int32_t g107 = 0; // 0x807afc0
int32_t g108 = 0; // 0x807afc4
int32_t g109 = 0; // 0x807afc8
int32_t g110 = 0; // 0x807b0e8
int32_t g111 = 0; // 0x807b0ec
int64_t g112 = 0; // 0x807b0f0
int64_t g113 = 0; // 0x807b0f4
int32_t g114 = 0; // 0x807b0f8
int32_t g115 = 0; // 0x807b0fc
float64_t g116 = 0.0; // 0x807b100
int64_t g117 = 0; // 0x807b108
int32_t g118 = 0; // 0x807b10c
int64_t g119 = 0; // 0x807b110
int32_t g120 = 0; // 0x807b114
int32_t g121 = 0; // 0x807b120
int32_t g122 = 0; // 0x807b924
int64_t g123 = 0; // 0x807b928
int32_t g124;
int32_t g125;
char (**g3)[14] = &g2; // 0x806d9c4
int32_t * g18 = &g19; // 0x80740fc
int32_t * g24 = &g91; // 0x80741c4

// ------------------------ Functions -------------------------

// Address range: 0x805bcc0 - 0x805bd5e
int32_t scanmult(void) {
    char v1 = 32; // bp-29, 0x805bcd4
    int32_t v2; // 0x805bcc0
    char * str = (char *)v2; // 0x805bcee
    int32_t v3; // bp-36, 0x805bcc0
    sscanf(str, "=%u%c", &v3, &v1);
    sscanf(str, "=0x%x%c", &v3, &v1);
    switch (v1) {
        case 77: {
            int32_t result = 0x100000 * v3; // 0x805bd32
            *(int32_t *)v2 = result;
            // 0x805bd51
            return result;
        }
        case 107: {
            int32_t result2 = 1024 * v3; // 0x805bd25
            *(int32_t *)v2 = result2;
            // 0x805bd51
            return result2;
        }
    }
    // 0x805bd1a
    int32_t result3; // 0x805bcc0
    if (v1 != 71) {
        // 0x805bd49
        *(int32_t *)v2 = v3;
        result3 = v3;
    } else {
        int32_t v4 = 0x40000000 * v3; // 0x805bd3f
        *(int32_t *)v2 = v4;
        result3 = v4;
    }
    // 0x805bd51
    return result3;
}

// Address range: 0x805bd5e - 0x805c019
int32_t caml_main(int32_t a1) {
    // 0x805bd5e
    int32_t v1; // 0x805bd5e
    caml_init_ieee_floats(v1, v1, v1, v1);
    caml_init_custom_operations();
    int32_t v2; // bp-29, 0x805bd5e
    g108 = &v2;
    char * env_val = getenv("OCAMLRUNPARAM"); // 0x805bd80
    char * env_val2 = env_val; // 0x805bd89
    if (env_val != NULL) {
        goto lab_0x805be53;
    } else {
        // 0x805bd8f
        env_val2 = getenv("CAMLRUNPARAM");
        if (env_val2 == NULL) {
            goto lab_0x805be66;
        } else {
            goto lab_0x805be53;
        }
    }
  lab_0x805be53:;
    char v3 = *env_val2; // 0x805be5b
    if (v3 != 0) {
        int32_t v4 = (int32_t)env_val2; // 0x805bdaa
        g124 = v3 - 79;
        switch (v3) {
            case 79: {
                // 0x805be07
                scanmult();
                // break -> 0x805be5b
                break;
            }
            case 97: {
                // 0x805be3d
                scanmult();
                caml_set_allocation_policy(v1);
                // break -> 0x805be5b
                break;
            }
            case 98: {
                // 0x805be23
                caml_record_backtrace(3);
                // break -> 0x805be5b
                break;
            }
            case 104: {
                // 0x805bddd
                scanmult();
                // break -> 0x805be5b
                break;
            }
            case 105: {
                // 0x805bdcf
                scanmult();
                // break -> 0x805be5b
                break;
            }
            case 108: {
                // 0x805bdeb
                scanmult();
                // break -> 0x805be5b
                break;
            }
            case 111: {
                // 0x805bdf9
                scanmult();
                // break -> 0x805be5b
                break;
            }
            case 112: {
                // 0x805be31
                g79 = 1;
                // break -> 0x805be5b
                break;
            }
            case 115: {
                // 0x805bdbe
                scanmult();
                // break -> 0x805be5b
                break;
            }
            case 118: {
                // 0x805be15
                scanmult();
                // break -> 0x805be5b
                break;
            }
        }
        // 0x805be5b
        v4++;
        char v5 = *(char *)v4; // 0x805be5b
        while (v5 != 0) {
            // 0x805bdaa
            g124 = v5 - 79;
            switch (v5) {
                case 79: {
                    // 0x805be07
                    scanmult();
                    // break -> 0x805be5b
                    break;
                }
                case 97: {
                    // 0x805be3d
                    scanmult();
                    caml_set_allocation_policy(v1);
                    // break -> 0x805be5b
                    break;
                }
                case 98: {
                    // 0x805be23
                    caml_record_backtrace(3);
                    // break -> 0x805be5b
                    break;
                }
                case 104: {
                    // 0x805bddd
                    scanmult();
                    // break -> 0x805be5b
                    break;
                }
                case 105: {
                    // 0x805bdcf
                    scanmult();
                    // break -> 0x805be5b
                    break;
                }
                case 108: {
                    // 0x805bdeb
                    scanmult();
                    // break -> 0x805be5b
                    break;
                }
                case 111: {
                    // 0x805bdf9
                    scanmult();
                    // break -> 0x805be5b
                    break;
                }
                case 112: {
                    // 0x805be31
                    g79 = 1;
                    // break -> 0x805be5b
                    break;
                }
                case 115: {
                    // 0x805bdbe
                    scanmult();
                    // break -> 0x805be5b
                    break;
                }
                case 118: {
                    // 0x805be15
                    scanmult();
                    // break -> 0x805be5b
                    break;
                }
            }
            // 0x805be5b
            v4++;
            v5 = *(char *)v4;
        }
    }
    goto lab_0x805be66;
  lab_0x805be66:
    // 0x805be66
    caml_init_gc(g15, g14, g13, g12, g11);
    int32_t v6 = 0;
    *(int32_t *)(4 * v6 + (int32_t)&g106) = v6;
    int32_t v7 = v6 + 1; // 0x805beac
    while (v6 != 255) {
        // 0x805bea1
        v6 = v7;
        *(int32_t *)(4 * v6 + (int32_t)&g106) = v6;
        v7 = v6 + 1;
    }
    // 0x805beae
    if (caml_page_table_add(4, &g106, &g107) != 0) {
        // 0x805bee8
        caml_fatal_error("Fatal error: not enough memory for the initial page table");
        // UNREACHABLE
    }
    int32_t v8 = *(int32_t *)0x806dd78; // 0x805bece
    int32_t v9 = 0; // 0x805bee4
    int32_t v10 = v8; // 0x805bee4
    if (v8 != 0) {
        int32_t v11 = *(int32_t *)(8 * v9 + (int32_t)&g6); // 0x805bef4
        while (caml_page_table_add(4, (int32_t *)v10, (int32_t *)v11) == 0) {
            int32_t v12 = v9 + 1; // 0x805bf1b
            int32_t v13 = *(int32_t *)(8 * v12 + (int32_t)&g5); // 0x805bf1e
            v9 = v12;
            v10 = v13;
            if (v13 == 0) {
                goto lab_0x805bf25;
            }
            v11 = *(int32_t *)(8 * v9 + (int32_t)&g6);
        }
        // 0x805bf0f
        caml_fatal_error("Fatal error: not enough memory for the initial page table");
        // UNREACHABLE
    }
  lab_0x805bf25:
    // 0x805bf25
    g103 = g7;
    g105 = g8;
    int32_t v14 = 1; // 0x805bf42
    if (g9 != 0) {
        uint32_t v15 = g9;
        uint32_t v16 = g7;
        uint32_t v17 = g8;
        int32_t v18 = v16 > v15 ? v15 : v16; // 0x805bf5b
        uint32_t v19 = *(int32_t *)(8 * v14 + (int32_t)&g8); // 0x805bf5e
        int32_t v20 = v17 < v19 ? v19 : v17; // 0x805bf63
        int32_t v21 = v14 + 1; // 0x805bf66
        int32_t v22 = *(int32_t *)(8 * v21 + (int32_t)&g7); // 0x805bf69
        v14 = v21;
        while (v22 != 0) {
            // 0x805bf59
            v15 = v22;
            v16 = v18;
            v17 = v20;
            v18 = v16 > v15 ? v15 : v16;
            v19 = *(int32_t *)(8 * v14 + (int32_t)&g8);
            v20 = v17 < v19 ? v19 : v17;
            v21 = v14 + 1;
            v22 = *(int32_t *)(8 * v21 + (int32_t)&g7);
            v14 = v21;
        }
        // 0x805bf70
        g103 = v18;
        g105 = v20;
    }
    // 0x805bf7c
    caml_init_signals();
    caml_debugger_init();
    int32_t v23 = *(int32_t *)a1; // 0x805bf89
    int32_t v24 = caml_executable_name(&g28, 256); // 0x805bfa4
    int32_t v25 = &g28; // 0x805bfb0
    if (v24 != 0) {
        // 0x805bfb2
        v25 = caml_search_exe_in_path(v23 == 0 ? (int32_t)&g1 : v23);
    }
    // 0x805bfbc
    caml_sys_init(v25, a1);
    int32_t v26 = __sigsetjmp({
        (struct {int32_t e0[8]; int32_t e1; struct {int32_t e0[1];} e2;}){
            .e0 = {(int32_t)&g104, 0, 0, 0, 0, 0, 0, 0},
            .e1 = 0,
            .e2 = (struct {int32_t e0[1];}){
                .e0 = {0}
            }
        }    
}, (int32_t)&g125); // 0x805bfda
    if (v26 != 0) {
        // 0x805c011
        return g27;
    }
    int32_t result = caml_start_program(); // 0x805bff7
    if (result % 4 != 2) {
        // 0x805c011
        return result;
    }
    // 0x805c006
    caml_fatal_uncaught_exception(result & -4);
    // UNREACHABLE
}

// Address range: 0x805c02c - 0x805c053
int main(int argc, char ** argv) {
    // 0x805c02c
    caml_main(argc);
    caml_sys_exit(1);
    // UNREACHABLE
}

// Address range: 0x805c060 - 0x805c0ad
int32_t caml_raise(int32_t a1) {
    uint32_t v1 = g29; // 0x805c075
    if (v1 == 0) {
        // 0x805c08e
        caml_fatal_uncaught_exception(a1);
        // UNREACHABLE
    }
    int32_t v2 = g30; // 0x805c07f
    if (v2 != 0 != v2 < v1) {
        // 0x805c0a5
        return caml_raise_exception(a1);
    }
    int32_t v3 = v2; // 0x805c086
    v3 = *(int32_t *)v3;
    g30 = v3;
    while (v3 != 0 == v1 > v3) {
        // 0x805c096
        v3 = *(int32_t *)v3;
        g30 = v3;
    }
    // 0x805c0a5
    return caml_raise_exception(a1);
}

// Address range: 0x805c139 - 0x805c14b
int32_t caml_raise_out_of_memory(void) {
    // 0x805c139
    return caml_raise((int32_t)&g3);
}

// Address range: 0x805c370 - 0x805c497
int32_t caml_do_local_roots(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t result = 0; // 0x805c37e
    if (a2 != 0) {
        int32_t v1 = a2; // 0x805c370
        int32_t v2 = a3; // 0x805c370
        int32_t v3; // 0x805c370
        while (true) {
            uint32_t v4 = v2;
            v3 = v1;
            int32_t v5 = v4 / 8 & g107; // 0x805c3b2
            int32_t v6 = *(int32_t *)(4 * v5 + g32); // 0x805c3ba
            int32_t v7 = v5; // 0x805c3bf
            int32_t v8 = v6; // 0x805c3bf
            if (*(int32_t *)v6 != v4) {
                int32_t v9 = v7 + 1 & g107; // 0x805c3c4
                int32_t v10 = *(int32_t *)(4 * v9 + g32); // 0x805c3c6
                v7 = v9;
                v8 = v10;
                while (*(int32_t *)v10 != v4) {
                    // 0x805c3c1
                    v9 = v7 + 1 & g107;
                    v10 = *(int32_t *)(4 * v9 + g32);
                    v7 = v9;
                    v8 = v10;
                }
            }
            int16_t v11 = *(int16_t *)(v8 + 4); // 0x805c3cd
            int32_t v12; // 0x805c370
            int32_t v13; // 0x805c370
            if (v11 == -1) {
                int32_t v14 = *(int32_t *)(v3 + 8); // 0x805c42d
                v13 = v14;
                v12 = v3 + 12;
                if (v14 == 0) {
                    // break -> 0x805c38e
                    break;
                }
            } else {
                int32_t v15 = v3 + (int32_t)(v11 & -4); // 0x805c41c
                v13 = v15;
                v12 = v15 - 4;
            }
            // 0x805c3a7
            v1 = v13;
            v2 = *(int32_t *)v12;
        }
        // 0x805c38e
        result = *(int32_t *)(v3 + 16);
    }
    // 0x805c38e
    if (a5 == 0) {
        // 0x805c48f
        return result;
    }
    uint32_t v16 = *(int32_t *)(a5 + 4); // 0x805c487
    int32_t v17 = result; // 0x805c48b
    int32_t v18; // 0x805c370
    int32_t v19; // 0x805c370
    int32_t v20; // 0x805c459
    int32_t v21; // 0x805c469
    int32_t v22; // 0x805c474
    int32_t v23; // 0x805c370
    int32_t v24; // 0x805c370
    if (v16 >= 0 == (v16 != 0)) {
        // 0x805c471
        v22 = *(int32_t *)(a5 + 8);
        v23 = a5 + 12;
        v24 = 4 * (v22 > 1 ? v22 : 1) - 4;
        v19 = 0;
        v20 = result;
        if (v22 >= 0 == (v22 != 0)) {
            // 0x805c44a
            v20 = *(int32_t *)(v24 + *(int32_t *)(v23 + 4 * v19));
        }
        // 0x805c469
        v18 = v20;
        v21 = v19 + 1;
        v17 = v18;
        while (v16 > v21) {
            // 0x805c471
            v19 = v21;
            v20 = v18;
            if (v22 >= 0 == (v22 != 0)) {
                // 0x805c44a
                v20 = *(int32_t *)(v24 + *(int32_t *)(v23 + 4 * v19));
            }
            // 0x805c469
            v18 = v20;
            v21 = v19 + 1;
            v17 = v18;
        }
    }
    int32_t result2 = v17;
    int32_t v25 = *(int32_t *)a5; // 0x805c47c
    while (v25 != 0) {
        int32_t v26 = v25;
        int32_t v27 = result2;
        v16 = *(int32_t *)(v26 + 4);
        v17 = v27;
        if (v16 >= 0 == (v16 != 0)) {
            // 0x805c471
            v22 = *(int32_t *)(v26 + 8);
            v23 = v26 + 12;
            v24 = 4 * (v22 > 1 ? v22 : 1) - 4;
            v19 = 0;
            v20 = v27;
            if (v22 >= 0 == (v22 != 0)) {
                // 0x805c44a
                v20 = *(int32_t *)(v24 + *(int32_t *)(v23 + 4 * v19));
            }
            // 0x805c469
            v18 = v20;
            v21 = v19 + 1;
            v17 = v18;
            while (v16 > v21) {
                // 0x805c471
                v19 = v21;
                v20 = v18;
                if (v22 >= 0 == (v22 != 0)) {
                    // 0x805c44a
                    v20 = *(int32_t *)(v24 + *(int32_t *)(v23 + 4 * v19));
                }
                // 0x805c469
                v18 = v20;
                v21 = v19 + 1;
                v17 = v18;
            }
        }
        // 0x805c47c
        result2 = v17;
        v25 = *(int32_t *)v26;
    }
    // 0x805c48f
    return result2;
}

// Address range: 0x805c4c2 - 0x805c4ed
int32_t cons(int32_t a1) {
    // 0x805c4c2
    return caml_stat_alloc(8);
}

// Address range: 0x805c508 - 0x805c53e
int32_t caml_register_frametable(int32_t a1) {
    // 0x805c508
    int32_t v1; // 0x805c508
    g37 = cons(v1);
    int32_t result = 0; // 0x805c528
    if (g32 != 0) {
        // 0x805c52a
        result = caml_stat_free(g32);
        g32 = 0;
    }
    // 0x805c53c
    return result;
}

// Address range: 0x805c53e - 0x805c695
int32_t caml_init_frame_descriptors(void) {
    // 0x805c53e
    if (g38 == 0) {
        int32_t v1 = *(int32_t *)0x806de30; // 0x805c550
        if (v1 != 0) {
            caml_register_frametable(v1);
            int32_t v2 = 1; // 0x805c56b
            int32_t v3 = *(int32_t *)(4 * v2 + (int32_t)&g10); // 0x805c56e
            int32_t v4 = v3; // 0x805c573
            int32_t v5 = v2; // 0x805c573
            while (v3 != 0) {
                // 0x805c563
                caml_register_frametable(v4);
                v2 = v5 + 1;
                v3 = *(int32_t *)(4 * v2 + (int32_t)&g10);
                v4 = v3;
                v5 = v2;
            }
        }
        // 0x805c575
        g38 = 1;
    }
    int32_t v6 = g37; // 0x805c586
    int32_t v7 = 0; // 0x805c586
    int32_t v8; // 0x805c53e
    int32_t v9; // 0x805c53e
    if (g37 == 0) {
        goto lab_0x805c683;
    } else {
        v7 += *(int32_t *)*(int32_t *)v6;
        v6 += 4;
        while (v6 != 0) {
            // 0x805c591
            v7 += *(int32_t *)*(int32_t *)v6;
            v6 += 4;
        }
        int32_t v10 = 2 * v7; // 0x805c59c
        if (v10 < 5) {
            goto lab_0x805c683;
        } else {
            int32_t v11 = 4;
            int32_t v12 = 2 * v11; // 0x805c5ac
            while (v12 < v10) {
                // 0x805c5ac
                v11 = v12;
                v12 = 2 * v11;
            }
            int32_t v13 = caml_stat_alloc(8 * v11); // 0x805c5bc
            g32 = v13;
            v8 = v12;
            if (v12 >= 0 == (v12 != 0)) {
                // 0x805c683
                *(int32_t *)v13 = 0;
                v8 = v12;
                v9 = v12;
                if (v12 > 1) {
                    goto lab_0x805c5d0;
                } else {
                    goto lab_0x805c5e4;
                }
            } else {
                goto lab_0x805c5e4;
            }
        }
    }
  lab_0x805c683:;
    int32_t v14 = caml_stat_alloc(16); // 0x805c674
    g32 = v14;
    *(int32_t *)v14 = 0;
    v9 = 4;
    goto lab_0x805c5d0;
  lab_0x805c5d0:;
    int32_t v15 = 1; // 0x805c53e
    *(int32_t *)(4 * v15 + g32) = 0;
    int32_t v16 = v15 + 1; // 0x805c5dd
    v15 = v16;
    v8 = v9;
    while (v16 != v9) {
        // 0x805c5d0
        *(int32_t *)(4 * v15 + g32) = 0;
        v16 = v15 + 1;
        v15 = v16;
        v8 = v9;
    }
    goto lab_0x805c5e4;
  lab_0x805c5e4:
    // 0x805c5e4
    g107 = v8 - 1;
    if (g37 == 0) {
        // 0x805c68d
        return 0;
    }
    int32_t v17 = *(int32_t *)g37; // 0x805c600
    uint32_t v18 = *(int32_t *)v17; // 0x805c602
    int32_t * v19; // 0x805c53e
    int32_t v20; // 0x805c53e
    int32_t v21; // 0x805c53e
    int32_t v22; // 0x805c61e
    int32_t * v23; // 0x805c53e
    int32_t v24; // 0x805c652
    int32_t v25; // 0x805c631
    int32_t * v26; // 0x805c53e
    int32_t v27; // 0x805c645
    if (v18 >= 1) {
        // 0x805c60b
        v24 = 0;
        v21 = v17 + 4;
        v22 = *(int32_t *)v21 / 8 & g107;
        v23 = (int32_t *)(4 * v22 + g32);
        v20 = v22;
        v19 = v23;
        if (*v23 != 0) {
            v25 = v20 + 1 & g107;
            v26 = (int32_t *)(4 * v25 + g32);
            v20 = v25;
            v19 = v26;
            while (*v26 != 0) {
                // 0x805c62e
                v25 = v20 + 1 & g107;
                v26 = (int32_t *)(4 * v25 + g32);
                v20 = v25;
                v19 = v26;
            }
        }
        // 0x805c63b
        *v19 = v21;
        while (v24 + 1 != v18) {
            // 0x805c613
            v24++;
            // 0x805c65a
            v27 = v21 + 11 + 2 * (int32_t)*(int16_t *)(v21 + 6) & -4;
            v21 = *(char *)(v21 + 4) % 2 != 0 ? v27 + 8 : v27;
            v22 = *(int32_t *)v21 / 8 & g107;
            v23 = (int32_t *)(4 * v22 + g32);
            v20 = v22;
            v19 = v23;
            if (*v23 != 0) {
                v25 = v20 + 1 & g107;
                v26 = (int32_t *)(4 * v25 + g32);
                v20 = v25;
                v19 = v26;
                while (*v26 != 0) {
                    // 0x805c62e
                    v25 = v20 + 1 & g107;
                    v26 = (int32_t *)(4 * v25 + g32);
                    v20 = v25;
                    v19 = v26;
                }
            }
            // 0x805c63b
            *v19 = v21;
        }
    }
    int32_t result = *(int32_t *)(g37 + 4); // 0x805c661
    int32_t v28 = result; // 0x805c669
    while (result != 0) {
        // 0x805c5fd
        v17 = *(int32_t *)v28;
        v18 = *(int32_t *)v17;
        if (v18 >= 1) {
            // 0x805c60b
            v24 = 0;
            v21 = v17 + 4;
            v22 = *(int32_t *)v21 / 8 & g107;
            v23 = (int32_t *)(4 * v22 + g32);
            v20 = v22;
            v19 = v23;
            if (*v23 != 0) {
                v25 = v20 + 1 & g107;
                v26 = (int32_t *)(4 * v25 + g32);
                v20 = v25;
                v19 = v26;
                while (*v26 != 0) {
                    // 0x805c62e
                    v25 = v20 + 1 & g107;
                    v26 = (int32_t *)(4 * v25 + g32);
                    v20 = v25;
                    v19 = v26;
                }
            }
            // 0x805c63b
            *v19 = v21;
            while (v24 + 1 != v18) {
                // 0x805c613
                v24++;
                // 0x805c65a
                v27 = v21 + 11 + 2 * (int32_t)*(int16_t *)(v21 + 6) & -4;
                v21 = *(char *)(v21 + 4) % 2 != 0 ? v27 + 8 : v27;
                v22 = *(int32_t *)v21 / 8 & g107;
                v23 = (int32_t *)(4 * v22 + g32);
                v20 = v22;
                v19 = v23;
                if (*v23 != 0) {
                    v25 = v20 + 1 & g107;
                    v26 = (int32_t *)(4 * v25 + g32);
                    v20 = v25;
                    v19 = v26;
                    while (*v26 != 0) {
                        // 0x805c62e
                        v25 = v20 + 1 & g107;
                        v26 = (int32_t *)(4 * v25 + g32);
                        v20 = v25;
                        v19 = v26;
                    }
                }
                // 0x805c63b
                *v19 = v21;
            }
        }
        // 0x805c65e
        result = *(int32_t *)(v28 + 4);
        v28 = result;
    }
    // 0x805c68d
    return result;
}

// Address range: 0x805c695 - 0x805c7b6
int32_t caml_do_roots(int32_t a1) {
    int32_t v1 = 0; // 0x805c6a6
    if (*(int32_t *)0x806db54 != 0) {
        v1++;
        while (*(int32_t *)(4 * v1 + (int32_t)&g4) != 0) {
            // 0x805c6e1
            v1++;
        }
    }
    int32_t v2 = g35; // 0x805c703
    if (g35 != 0) {
        v2 += 4;
        while (v2 != 0) {
            // 0x805c705
            v2 += 4;
        }
    }
    // 0x805c74a
    if (g32 == 0) {
        // 0x805c753
        caml_init_frame_descriptors();
    }
    // 0x805c758
    caml_do_local_roots(a1, g33, g16, g109, g30);
    caml_scan_global_roots(a1);
    caml_final_do_strong_roots(a1);
    return g31;
}

// Address range: 0x805c7b6 - 0x805c7ca
int32_t caml_darken_all_roots(void) {
    // 0x805c7b6
    return caml_do_roots(0x805e580);
}

// Address range: 0x805c7ca - 0x805ca47
int32_t caml_oldify_local_roots(void) {
    int32_t v1 = g36; // 0x805c7d3
    if (v1 <= g34) {
        int32_t v2 = *(int32_t *)(4 * v1 + (int32_t)&g4); // 0x805c7e8
        if (v2 != 0) {
            int32_t * v3 = (int32_t *)(v2 - 4); // 0x805c848
            uint32_t v4 = *v3; // 0x805c848
            int32_t v5 = v4; // 0x805c859
            int32_t v6 = 0; // 0x805c859
            int32_t v7; // 0x805c7ca
            int32_t v8; // 0x805c7ca
            int32_t v9; // 0x805c7f5
            uint32_t v10; // 0x805c7f8
            int32_t v11; // 0x805c81a
            if (v4 >= 1024) {
                v8 = v5;
                v9 = 4 * v6 + v2;
                v10 = *(int32_t *)v9;
                v7 = v8;
                if (v10 % 2 == 0) {
                    // 0x805c7fe
                    v7 = v8;
                    if (v10 < g67 == v10 > g66) {
                        // 0x805c80e
                        caml_oldify_one(v10, v9);
                        v7 = *v3;
                    }
                }
                // 0x805c81a
                v11 = v6 + 1;
                v6 = v11;
                while (v11 < v7 / 1024) {
                    // 0x805c7f5
                    v8 = v7;
                    v9 = 4 * v6 + v2;
                    v10 = *(int32_t *)v9;
                    v7 = v8;
                    if (v10 % 2 == 0) {
                        // 0x805c7fe
                        v7 = v8;
                        if (v10 < g67 == v10 > g66) {
                            // 0x805c80e
                            caml_oldify_one(v10, v9);
                            v7 = *v3;
                        }
                    }
                    // 0x805c81a
                    v11 = v6 + 1;
                    v6 = v11;
                }
            }
            int32_t v12 = v1 + 1; // 0x805c828
            while (g34 >= v12) {
                int32_t v13 = *(int32_t *)(4 * v12 + (int32_t)&g4); // 0x805c83e
                if (v13 == 0) {
                    // break -> 0x805c85d
                    break;
                }
                int32_t v14 = v13;
                v3 = (int32_t *)(v14 - 4);
                v4 = *v3;
                v5 = v4;
                v6 = 0;
                if (v4 >= 1024) {
                    v8 = v5;
                    v9 = 4 * v6 + v14;
                    v10 = *(int32_t *)v9;
                    v7 = v8;
                    if (v10 % 2 == 0) {
                        // 0x805c7fe
                        v7 = v8;
                        if (v10 < g67 == v10 > g66) {
                            // 0x805c80e
                            caml_oldify_one(v10, v9);
                            v7 = *v3;
                        }
                    }
                    // 0x805c81a
                    v11 = v6 + 1;
                    v6 = v11;
                    while (v11 < v7 / 1024) {
                        // 0x805c7f5
                        v8 = v7;
                        v9 = 4 * v6 + v14;
                        v10 = *(int32_t *)v9;
                        v7 = v8;
                        if (v10 % 2 == 0) {
                            // 0x805c7fe
                            v7 = v8;
                            if (v10 < g67 == v10 > g66) {
                                // 0x805c80e
                                caml_oldify_one(v10, v9);
                                v7 = *v3;
                            }
                        }
                        // 0x805c81a
                        v11 = v6 + 1;
                        v6 = v11;
                    }
                }
                // 0x805c828
                v12++;
            }
        }
    }
    // 0x805c85d
    g36 = g34;
    int32_t v15 = g35; // 0x805c86d
    if (g35 != 0) {
        int32_t v16 = *(int32_t *)v15; // 0x805c872
        int32_t * v17 = (int32_t *)(v16 - 4); // 0x805c877
        uint32_t v18 = *v17; // 0x805c877
        int32_t v19 = v18; // 0x805c87e
        int32_t v20 = 0; // 0x805c87e
        int32_t v21; // 0x805c7ca
        int32_t v22; // 0x805c7ca
        int32_t v23; // 0x805c88a
        uint32_t v24; // 0x805c88d
        int32_t v25; // 0x805c8af
        if (v18 >= 1024) {
            v22 = v19;
            v23 = 4 * v20 + v16;
            v24 = *(int32_t *)v23;
            v21 = v22;
            if (v24 % 2 == 0) {
                // 0x805c893
                v21 = v22;
                if (v24 < g67 == v24 > g66) {
                    // 0x805c8a3
                    caml_oldify_one(v24, v23);
                    v21 = *v17;
                }
            }
            // 0x805c8af
            v25 = v20 + 1;
            v20 = v25;
            while (v25 < v21 / 1024) {
                // 0x805c88a
                v22 = v21;
                v23 = 4 * v20 + v16;
                v24 = *(int32_t *)v23;
                v21 = v22;
                if (v24 % 2 == 0) {
                    // 0x805c893
                    v21 = v22;
                    if (v24 < g67 == v24 > g66) {
                        // 0x805c8a3
                        caml_oldify_one(v24, v23);
                        v21 = *v17;
                    }
                }
                // 0x805c8af
                v25 = v20 + 1;
                v20 = v25;
            }
        }
        // 0x805c8bd
        v15 += 4;
        while (v15 != 0) {
            // 0x805c86f
            v16 = *(int32_t *)v15;
            v17 = (int32_t *)(v16 - 4);
            v18 = *v17;
            v19 = v18;
            v20 = 0;
            if (v18 >= 1024) {
                v22 = v19;
                v23 = 4 * v20 + v16;
                v24 = *(int32_t *)v23;
                v21 = v22;
                if (v24 % 2 == 0) {
                    // 0x805c893
                    v21 = v22;
                    if (v24 < g67 == v24 > g66) {
                        // 0x805c8a3
                        caml_oldify_one(v24, v23);
                        v21 = *v17;
                    }
                }
                // 0x805c8af
                v25 = v20 + 1;
                v20 = v25;
                while (v25 < v21 / 1024) {
                    // 0x805c88a
                    v22 = v21;
                    v23 = 4 * v20 + v16;
                    v24 = *(int32_t *)v23;
                    v21 = v22;
                    if (v24 % 2 == 0) {
                        // 0x805c893
                        v21 = v22;
                        if (v24 < g67 == v24 > g66) {
                            // 0x805c8a3
                            caml_oldify_one(v24, v23);
                            v21 = *v17;
                        }
                    }
                    // 0x805c8af
                    v25 = v20 + 1;
                    v20 = v25;
                }
            }
            // 0x805c8bd
            v15 += 4;
        }
    }
    // 0x805c8ca
    if (g32 == 0) {
        // 0x805c8d3
        caml_init_frame_descriptors();
    }
    // 0x805c8d8
    if (g33 != 0) {
        int32_t v26 = *&g109;
        int32_t v27 = g33;
        uint32_t v28 = *&g16;
        int32_t v29 = v28 / 8 & g107; // 0x805c902
        int32_t v30 = *(int32_t *)(4 * v29 + g32); // 0x805c90a
        int32_t v31 = v29; // 0x805c90f
        int32_t v32 = v30; // 0x805c90f
        int32_t v33; // 0x805c914
        int32_t v34; // 0x805c916
        if (*(int32_t *)v30 != v28) {
            v33 = v31 + 1 & g107;
            v34 = *(int32_t *)(4 * v33 + g32);
            v31 = v33;
            v32 = v34;
            while (*(int32_t *)v34 != v28) {
                // 0x805c911
                v33 = v31 + 1 & g107;
                v34 = *(int32_t *)(4 * v33 + g32);
                v31 = v33;
                v32 = v34;
            }
        }
        int32_t v35 = v32;
        int16_t * v36 = (int16_t *)(v35 + 4); // 0x805c91d
        int16_t v37 = *v36; // 0x805c91d
        int16_t v38; // 0x805c7ca
        int32_t v39; // 0x805c7ca
        int32_t v40; // 0x805c7ca
        int32_t v41; // 0x805c7ca
        int32_t v42; // 0x805c7ca
        int32_t v43; // 0x805c7ca
        uint16_t v44; // 0x805c924
        int32_t v45; // 0x805c97b
        uint16_t v46; // 0x805c92f
        uint32_t v47; // 0x805c92f
        uint32_t v48; // 0x805c944
        while (v37 != -1) {
            // 0x805c924
            v44 = *(int16_t *)(v35 + 6);
            v38 = v37;
            if (v44 != 0) {
                // 0x805c92c
                v43 = v35 + 8;
                v40 = v44;
                v46 = *(int16_t *)v43;
                v47 = (int32_t)v46;
                if (v46 % 2 == 0) {
                    // 0x805c941
                    v41 = v27 + v47;
                } else {
                    // 0x805c937
                    v41 = 4 * v47 / 2 + v26;
                }
                // 0x805c944
                v42 = v41;
                v48 = *(int32_t *)v42;
                if (v48 % 2 == 0) {
                    // 0x805c94a
                    if (v48 < g67 == v48 > g66) {
                        // 0x805c95a
                        caml_oldify_one(v48, v42);
                    }
                }
                // 0x805c966
                v39 = v40 - 1;
                v43 += 2;
                while (v40 >= 2) {
                    // 0x805c92f
                    v40 = v39;
                    v46 = *(int16_t *)v43;
                    v47 = (int32_t)v46;
                    if (v46 % 2 == 0) {
                        // 0x805c941
                        v41 = v27 + v47;
                    } else {
                        // 0x805c937
                        v41 = 4 * v47 / 2 + v26;
                    }
                    // 0x805c944
                    v42 = v41;
                    v48 = *(int32_t *)v42;
                    if (v48 % 2 == 0) {
                        // 0x805c94a
                        if (v48 < g67 == v48 > g66) {
                            // 0x805c95a
                            caml_oldify_one(v48, v42);
                        }
                    }
                    // 0x805c966
                    v39 = v40 - 1;
                    v43 += 2;
                }
                // 0x805c972
                v38 = *v36;
            }
            // 0x805c972
            v45 = v27 + (int32_t)(v38 & -4);
            v27 = v45;
            v28 = *(int32_t *)(v45 - 4);
            v29 = v28 / 8 & g107;
            v30 = *(int32_t *)(4 * v29 + g32);
            v31 = v29;
            v32 = v30;
            if (*(int32_t *)v30 != v28) {
                v33 = v31 + 1 & g107;
                v34 = *(int32_t *)(4 * v33 + g32);
                v31 = v33;
                v32 = v34;
                while (*(int32_t *)v34 != v28) {
                    // 0x805c911
                    v33 = v31 + 1 & g107;
                    v34 = *(int32_t *)(4 * v33 + g32);
                    v31 = v33;
                    v32 = v34;
                }
            }
            // 0x805c91d
            v35 = v32;
            v36 = (int16_t *)(v35 + 4);
            v37 = *v36;
        }
        int32_t v49 = *(int32_t *)(v27 + 8); // 0x805c98f
        while (v49 != 0) {
            // 0x805c8f7
            v26 = *(int32_t *)(v27 + 16);
            int32_t * v50 = (int32_t *)(v27 + 12); // 0x805c7ca
            v27 = v49;
            v28 = *v50;
            v29 = v28 / 8 & g107;
            v30 = *(int32_t *)(4 * v29 + g32);
            v31 = v29;
            v32 = v30;
            if (*(int32_t *)v30 != v28) {
                v33 = v31 + 1 & g107;
                v34 = *(int32_t *)(4 * v33 + g32);
                v31 = v33;
                v32 = v34;
                while (*(int32_t *)v34 != v28) {
                    // 0x805c911
                    v33 = v31 + 1 & g107;
                    v34 = *(int32_t *)(4 * v33 + g32);
                    v31 = v33;
                    v32 = v34;
                }
            }
            // 0x805c91d
            v35 = v32;
            v36 = (int16_t *)(v35 + 4);
            v37 = *v36;
            while (v37 != -1) {
                // 0x805c924
                v44 = *(int16_t *)(v35 + 6);
                v38 = v37;
                if (v44 != 0) {
                    // 0x805c92c
                    v43 = v35 + 8;
                    v40 = v44;
                    v46 = *(int16_t *)v43;
                    v47 = (int32_t)v46;
                    if (v46 % 2 == 0) {
                        // 0x805c941
                        v41 = v27 + v47;
                    } else {
                        // 0x805c937
                        v41 = 4 * v47 / 2 + v26;
                    }
                    // 0x805c944
                    v42 = v41;
                    v48 = *(int32_t *)v42;
                    if (v48 % 2 == 0) {
                        // 0x805c94a
                        if (v48 < g67 == v48 > g66) {
                            // 0x805c95a
                            caml_oldify_one(v48, v42);
                        }
                    }
                    // 0x805c966
                    v39 = v40 - 1;
                    v43 += 2;
                    while (v40 >= 2) {
                        // 0x805c92f
                        v40 = v39;
                        v46 = *(int16_t *)v43;
                        v47 = (int32_t)v46;
                        if (v46 % 2 == 0) {
                            // 0x805c941
                            v41 = v27 + v47;
                        } else {
                            // 0x805c937
                            v41 = 4 * v47 / 2 + v26;
                        }
                        // 0x805c944
                        v42 = v41;
                        v48 = *(int32_t *)v42;
                        if (v48 % 2 == 0) {
                            // 0x805c94a
                            if (v48 < g67 == v48 > g66) {
                                // 0x805c95a
                                caml_oldify_one(v48, v42);
                            }
                        }
                        // 0x805c966
                        v39 = v40 - 1;
                        v43 += 2;
                    }
                    // 0x805c972
                    v38 = *v36;
                }
                // 0x805c972
                v45 = v27 + (int32_t)(v38 & -4);
                v27 = v45;
                v28 = *(int32_t *)(v45 - 4);
                v29 = v28 / 8 & g107;
                v30 = *(int32_t *)(4 * v29 + g32);
                v31 = v29;
                v32 = v30;
                if (*(int32_t *)v30 != v28) {
                    v33 = v31 + 1 & g107;
                    v34 = *(int32_t *)(4 * v33 + g32);
                    v31 = v33;
                    v32 = v34;
                    while (*(int32_t *)v34 != v28) {
                        // 0x805c911
                        v33 = v31 + 1 & g107;
                        v34 = *(int32_t *)(4 * v33 + g32);
                        v31 = v33;
                        v32 = v34;
                    }
                }
                // 0x805c91d
                v35 = v32;
                v36 = (int16_t *)(v35 + 4);
                v37 = *v36;
            }
            // 0x805c989
            v49 = *(int32_t *)(v27 + 8);
        }
    }
    // 0x805c9a7
    if (g30 == 0) {
        // 0x805ca15
        caml_scan_global_young_roots(0x805ea4c);
        caml_final_do_young_roots(0x805ea4c);
        return g31;
    }
    int32_t * v51 = (int32_t *)(g30 + 4); // 0x805ca0d
    int32_t v52 = *v51; // 0x805ca0d
    int32_t v53; // 0x805c7ca
    int32_t v54; // 0x805c7ca
    int32_t v55; // 0x805c7ca
    int32_t v56; // 0x805c7ca
    int32_t v57; // 0x805c7ca
    int32_t v58; // 0x805c9ea
    int32_t v59; // 0x805c7ca
    int32_t v60; // 0x805c9fa
    int32_t v61; // 0x805c7ca
    int32_t * v62; // 0x805c9fa
    int32_t v63; // 0x805c7ca
    int32_t v64; // 0x805c9ef
    int32_t v65; // 0x805c9c1
    uint32_t v66; // 0x805c9c5
    int32_t v67; // 0x805c9e7
    if (v52 >= 0 == (v52 != 0)) {
        // 0x805c9f7
        v62 = (int32_t *)(g30 + 8);
        v63 = g30 + 12;
        v53 = *v62;
        v61 = 0;
        v60 = v53;
        v59 = v53;
        v55 = v59;
        v56 = v60;
        if (v60 >= 0 == (v60 != 0)) {
            // 0x805c9ba
            v67 = 0;
            v57 = v59;
            v65 = 4 * v67 + *(int32_t *)(v63 + 4 * v61);
            v66 = *(int32_t *)v65;
            v54 = v57;
            if (v66 % 2 == 0) {
                // 0x805c9cb
                v54 = v57;
                if (v66 < g67 == v66 > g66) {
                    // 0x805c9db
                    caml_oldify_one(v66, v65);
                    v54 = *v62;
                }
            }
            // 0x805c9e7
            v58 = v54;
            v67++;
            v55 = v58;
            v56 = v58;
            while (v58 > v67) {
                // 0x805c9ba
                v57 = v58;
                v65 = 4 * v67 + *(int32_t *)(v63 + 4 * v61);
                v66 = *(int32_t *)v65;
                v54 = v57;
                if (v66 % 2 == 0) {
                    // 0x805c9cb
                    v54 = v57;
                    if (v66 < g67 == v66 > g66) {
                        // 0x805c9db
                        caml_oldify_one(v66, v65);
                        v54 = *v62;
                    }
                }
                // 0x805c9e7
                v58 = v54;
                v67++;
                v55 = v58;
                v56 = v58;
            }
        }
        // 0x805c9ef
        v64 = v61 + 1;
        while (*v51 > v64) {
            // 0x805c9f7
            v61 = v64;
            v60 = v56;
            v59 = v55;
            v55 = v59;
            v56 = v60;
            if (v60 >= 0 == (v60 != 0)) {
                // 0x805c9ba
                v67 = 0;
                v57 = v59;
                v65 = 4 * v67 + *(int32_t *)(v63 + 4 * v61);
                v66 = *(int32_t *)v65;
                v54 = v57;
                if (v66 % 2 == 0) {
                    // 0x805c9cb
                    v54 = v57;
                    if (v66 < g67 == v66 > g66) {
                        // 0x805c9db
                        caml_oldify_one(v66, v65);
                        v54 = *v62;
                    }
                }
                // 0x805c9e7
                v58 = v54;
                v67++;
                v55 = v58;
                v56 = v58;
                while (v58 > v67) {
                    // 0x805c9ba
                    v57 = v58;
                    v65 = 4 * v67 + *(int32_t *)(v63 + 4 * v61);
                    v66 = *(int32_t *)v65;
                    v54 = v57;
                    if (v66 % 2 == 0) {
                        // 0x805c9cb
                        v54 = v57;
                        if (v66 < g67 == v66 > g66) {
                            // 0x805c9db
                            caml_oldify_one(v66, v65);
                            v54 = *v62;
                        }
                    }
                    // 0x805c9e7
                    v58 = v54;
                    v67++;
                    v55 = v58;
                    v56 = v58;
                }
            }
            // 0x805c9ef
            v64 = v61 + 1;
        }
    }
    int32_t v68 = *(int32_t *)g30; // 0x805ca02
    while (v68 != 0) {
        int32_t v69 = v68;
        v51 = (int32_t *)(v69 + 4);
        v52 = *v51;
        if (v52 >= 0 == (v52 != 0)) {
            // 0x805c9f7
            v62 = (int32_t *)(v69 + 8);
            v63 = v69 + 12;
            v53 = *v62;
            v61 = 0;
            v60 = v53;
            v59 = v53;
            v55 = v59;
            v56 = v60;
            if (v60 >= 0 == (v60 != 0)) {
                // 0x805c9ba
                v67 = 0;
                v57 = v59;
                v65 = 4 * v67 + *(int32_t *)(v63 + 4 * v61);
                v66 = *(int32_t *)v65;
                v54 = v57;
                if (v66 % 2 == 0) {
                    // 0x805c9cb
                    v54 = v57;
                    if (v66 < g67 == v66 > g66) {
                        // 0x805c9db
                        caml_oldify_one(v66, v65);
                        v54 = *v62;
                    }
                }
                // 0x805c9e7
                v58 = v54;
                v67++;
                v55 = v58;
                v56 = v58;
                while (v58 > v67) {
                    // 0x805c9ba
                    v57 = v58;
                    v65 = 4 * v67 + *(int32_t *)(v63 + 4 * v61);
                    v66 = *(int32_t *)v65;
                    v54 = v57;
                    if (v66 % 2 == 0) {
                        // 0x805c9cb
                        v54 = v57;
                        if (v66 < g67 == v66 > g66) {
                            // 0x805c9db
                            caml_oldify_one(v66, v65);
                            v54 = *v62;
                        }
                    }
                    // 0x805c9e7
                    v58 = v54;
                    v67++;
                    v55 = v58;
                    v56 = v58;
                }
            }
            // 0x805c9ef
            v64 = v61 + 1;
            while (*v51 > v64) {
                // 0x805c9f7
                v61 = v64;
                v60 = v56;
                v59 = v55;
                v55 = v59;
                v56 = v60;
                if (v60 >= 0 == (v60 != 0)) {
                    // 0x805c9ba
                    v67 = 0;
                    v57 = v59;
                    v65 = 4 * v67 + *(int32_t *)(v63 + 4 * v61);
                    v66 = *(int32_t *)v65;
                    v54 = v57;
                    if (v66 % 2 == 0) {
                        // 0x805c9cb
                        v54 = v57;
                        if (v66 < g67 == v66 > g66) {
                            // 0x805c9db
                            caml_oldify_one(v66, v65);
                            v54 = *v62;
                        }
                    }
                    // 0x805c9e7
                    v58 = v54;
                    v67++;
                    v55 = v58;
                    v56 = v58;
                    while (v58 > v67) {
                        // 0x805c9ba
                        v57 = v58;
                        v65 = 4 * v67 + *(int32_t *)(v63 + 4 * v61);
                        v66 = *(int32_t *)v65;
                        v54 = v57;
                        if (v66 % 2 == 0) {
                            // 0x805c9cb
                            v54 = v57;
                            if (v66 < g67 == v66 > g66) {
                                // 0x805c9db
                                caml_oldify_one(v66, v65);
                                v54 = *v62;
                            }
                        }
                        // 0x805c9e7
                        v58 = v54;
                        v67++;
                        v55 = v58;
                        v56 = v58;
                    }
                }
                // 0x805c9ef
                v64 = v61 + 1;
            }
        }
        // 0x805ca02
        v68 = *(int32_t *)v69;
    }
    // 0x805ca15
    caml_scan_global_young_roots(0x805ea4c);
    caml_final_do_young_roots(0x805ea4c);
    return g31;
}

// Address range: 0x805ca50 - 0x805ca7c
int32_t caml_iterate_global_roots(void) {
    // 0x805ca50
    int32_t v1; // 0x805ca50
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x805ca5a
    if (v2 == 0) {
        // 0x805ca75
        int32_t result; // 0x805ca50
        return result;
    }
    int32_t v3 = v2;
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x805ca6e
    while (v4 != 0) {
        // 0x805ca61
        v3 = v4;
        v4 = *(int32_t *)(v3 + 4);
    }
    // 0x805ca75
    return *(int32_t *)*(int32_t *)v3;
}

// Address range: 0x805ca7c - 0x805cab0
int32_t caml_scan_global_roots(int32_t a1) {
    // 0x805ca7c
    caml_iterate_global_roots();
    caml_iterate_global_roots();
    return caml_iterate_global_roots();
}

// Address range: 0x805cab0 - 0x805cb97
int32_t caml_insert_global_root(void) {
    // 0x805cab0
    int32_t v1; // 0x805cab0
    uint32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v1 + 72); // 0x805cac0
    int32_t v4 = *v3; // 0x805cac0
    int32_t v5; // 0x805cab0
    int32_t v6; // bp-96, 0x805cab0
    if (v4 < 0) {
        // 0x805cab0
        v5 = v1 + 4;
    } else {
        int32_t v7 = v4;
        int32_t v8 = 4 * v7; // 0x805cad1
        int32_t v9; // 0x805cab0
        int32_t v10 = v9;
        int32_t v11 = v10 + 4;
        int32_t v12 = *(int32_t *)(v11 + v8); // 0x805cad1
        while (v12 != 0) {
            // 0x805cad9
            if (*(int32_t *)v12 >= v2) {
                // break -> 0x805cae1
                break;
            }
            v10 = v12;
            v11 = v10 + 4;
            v12 = *(int32_t *)(v11 + v8);
        }
        // 0x805cae1
        *(int32_t *)(v8 + (int32_t)&v6) = v10;
        int32_t v13 = v7 - 1; // 0x805caea
        v5 = v11;
        while (v7 != 0) {
            // 0x805cad1
            v7 = v13;
            v8 = 4 * v7;
            v11 = v10 + 4;
            v12 = *(int32_t *)(v11 + v8);
            while (v12 != 0) {
                // 0x805cad9
                if (*(int32_t *)v12 >= v2) {
                    // break -> 0x805cae1
                    break;
                }
                v10 = v12;
                v11 = v10 + 4;
                v12 = *(int32_t *)(v11 + v8);
            }
            // 0x805cae1
            *(int32_t *)(v8 + (int32_t)&v6) = v10;
            v13 = v7 - 1;
            v5 = v11;
        }
    }
    int32_t result = *(int32_t *)v5; // 0x805caec
    if (result != 0) {
        // 0x805caf3
        if (*(int32_t *)result == v2) {
            // 0x805cb8f
            return result;
        }
    }
    int32_t v14 = 0x10dcd * (int32_t)g41; // 0x805cafb
    int32_t v15 = v14 + 0x6255; // 0x805cb05
    g41 = v15;
    int32_t v16 = v15; // 0x805cb22
    int32_t v17 = 0; // 0x805cb22
    int32_t v18 = 0; // 0x805cb22
    if (v14 < 0xffff9dab) {
        v17++;
        v16 *= 4;
        v18 = v17;
        while (v16 > 0xbfffffff) {
            // 0x805cb24
            v17++;
            v16 *= 4;
            v18 = v17;
        }
    }
    // 0x805cb3a
    if (v4 < v18) {
        int32_t v19 = v4 + 1; // 0x805cb42
        if (v19 <= v18) {
            int32_t v20 = v19; // 0x805cb49
            while (v20 != v18) {
                // 0x805cb4c
                v20++;
            }
        }
        // 0x805cb56
        *v3 = v18;
    }
    int32_t result2 = caml_stat_alloc(4 * v18 + 8); // 0x805cb66
    int32_t v21 = 0; // 0x805cb76
    int32_t v22 = 4 * v21; // 0x805cb79
    int32_t v23 = *(int32_t *)(v22 + (int32_t)&v6); // 0x805cb79
    int32_t v24 = v22 + 4;
    int32_t * v25 = (int32_t *)(v24 + v23); // 0x805cb7c
    *(int32_t *)(v24 + result2) = *v25;
    *v25 = result2;
    while (v21 != v18) {
        // 0x805cb79
        v21++;
        v22 = 4 * v21;
        v23 = *(int32_t *)(v22 + (int32_t)&v6);
        v24 = v22 + 4;
        v25 = (int32_t *)(v24 + v23);
        *(int32_t *)(v24 + result2) = *v25;
        *v25 = result2;
    }
    // 0x805cb8f
    return result2;
}

// Address range: 0x805cbea - 0x805cbff
int32_t caml_register_global_root(int32_t * a1) {
    // 0x805cbea
    return caml_insert_global_root();
}

// Address range: 0x805cbff - 0x805cc8c
int32_t caml_scan_global_young_roots(int32_t a1) {
    // 0x805cbff
    caml_iterate_global_roots();
    int32_t v1 = caml_iterate_global_roots(); // 0x805cc1c
    int32_t v2 = g39; // 0x805cc29
    int32_t result = v1; // 0x805cc29
    if (g39 != 0) {
        caml_insert_global_root();
        v2 += 4;
        while (v2 != 0) {
            // 0x805cc2b
            caml_insert_global_root();
            v2 += 4;
        }
        // 0x805cc3e
        result = 0;
        if (g39 != 0) {
            int32_t v3 = *(int32_t *)(g39 + 4); // 0x805cc47
            int32_t v4 = v3; // 0x805cc54
            result = caml_stat_free(g39);
            while (v3 != 0) {
                int32_t v5 = v4;
                v3 = *(int32_t *)(v5 + 4);
                v4 = v3;
                result = caml_stat_free(v5);
            }
        }
    }
    int32_t v6 = g40; // 0x805cc5a
    int32_t result2 = 0; // 0x805cc62
    if (v6 < 0) {
        // 0x805cc7c
        g40 = 0;
        return result;
    }
    *(int32_t *)(4 * result2 + (int32_t)&g39) = 0;
    result2++;
    while (result2 <= v6) {
        // 0x805cc6e
        *(int32_t *)(4 * result2 + (int32_t)&g39) = 0;
        result2++;
    }
    // 0x805cc7c
    g40 = 0;
    return result2;
}

// Address range: 0x805cc8c - 0x805cd29
int32_t caml_delete_global_root(int32_t a1) {
    // 0x805cc8c
    int32_t v1; // 0x805cc8c
    uint32_t v2 = v1;
    int32_t * v3 = (int32_t *)(v1 + 72); // 0x805cc99
    int32_t v4 = *v3; // 0x805cc99
    int32_t v5; // 0x805cc8c
    int32_t result; // 0x805cc8c
    int32_t v6; // 0x805cc8c
    int32_t v7; // 0x805cc8c
    int32_t v8; // 0x805cc8c
    int32_t v9; // 0x805cca8
    int32_t v10; // 0x805cca8
    int32_t v11; // 0x805cc8c
    if (v4 < 0) {
        // 0x805cc8c
        v5 = v1 + 4;
        result = v4;
    } else {
        int32_t v12 = v4; // 0x805cca5
        while (true) {
          lab_0x805cca8_2:;
            // 0x805cca8
            int32_t v13; // 0x805cc8c
            v6 = v13;
            v11 = v6 + 4;
            v7 = v12;
            while (true) {
              lab_0x805cca8:
                // 0x805cca8
                v8 = v7;
                v9 = 4 * v8;
                v10 = *(int32_t *)(v9 + v11);
                if (v10 == 0) {
                    goto lab_0x805ccb8;
                } else {
                    // 0x805ccb0
                    v13 = v10;
                    v12 = v8;
                    if (*(int32_t *)v10 >= v2) {
                        goto lab_0x805ccb8;
                    } else {
                        goto lab_0x805cca8_2;
                    }
                }
            }
        }
    }
  lab_0x805ccc3:;
    int32_t v14 = *(int32_t *)v5; // 0x805ccc3
    if (v14 == 0) {
        // 0x805cd21
        return result;
    }
    int32_t result2 = result; // 0x805cccc
    if (*(int32_t *)v14 != v2) {
      lab_0x805cd21:
        // 0x805cd21
        return result2;
    }
    int32_t v15; // bp-96, 0x805cc8c
    if (v4 >= 0) {
        for (int32_t i = 0; i < *v3 + 1; i++) {
            int32_t v16 = 4 * i; // 0x805ccdc
            int32_t v17 = *(int32_t *)(v16 + (int32_t)&v15); // 0x805ccdc
            int32_t v18 = v16 + 4;
            int32_t * v19 = (int32_t *)(v18 + v17); // 0x805ccdf
            if (*v19 == v14) {
                // 0x805cce5
                *v19 = *(int32_t *)(v18 + v14);
            }
        }
    }
    // 0x805ccf5
    caml_stat_free(v14);
    int32_t result3 = *v3; // 0x805ccfd
    if (result3 < 1) {
        // 0x805cd21
        return result3;
    }
    int32_t v20 = v1 + 4; // 0x805cd04
    if (*(int32_t *)(4 * result3 + v20) != 0) {
        // 0x805cd21
        return result3;
    }
    int32_t v21 = result3; // 0x805cd09
    int32_t v22 = v21 - 1; // 0x805cd0b
    while (v21 >= 2) {
        // 0x805cd12
        v21 = v22;
        if (*(int32_t *)(4 * v22 + v20) != 0) {
            // 0x805cd19
            *v3 = v22;
            result2 = v22;
            return result2;
        }
        v22 = v21 - 1;
    }
    // 0x805cd1e
    *v3 = v22;
    // 0x805cd21
    return 0;
  lab_0x805ccb8:
    // 0x805ccb8
    *(int32_t *)(v9 + (int32_t)&v15) = v6;
    v7 = v8 - 1;
    v5 = v11;
    result = v10;
    if (v8 == 0) {
        // break (via goto) -> 0x805ccc3
        goto lab_0x805ccc3;
    }
    goto lab_0x805cca8;
}

// Address range: 0x805ce89 - 0x805ce9e
int32_t caml_remove_global_root(int32_t * a1) {
    // 0x805ce89
    int32_t v1; // 0x805ce89
    return caml_delete_global_root(v1);
}

// Address range: 0x805cef2 - 0x805cf0b
int32_t caml_urge_major_slice(void) {
    // 0x805cef2
    g42 = 1;
    g69 = g67;
    return g67;
}

// Address range: 0x805d210 - 0x805d292
int32_t caml_init_signals(void) {
    int32_t ss = &g44; // bp-24, 0x805d21a
    int32_t act = 0x805d33f; // bp-164, 0x805d22f
    int32_t set; // bp-160, 0x805d210
    sigemptyset((struct _TYPEDEF_sigset_t *)&set);
    g43 = &act;
    int32_t v1 = sigaltstack((struct sigaltstack *)&ss, NULL); // 0x805d268
    int32_t result = v1; // 0x805d26f
    if (v1 == 0) {
        // 0x805d271
        result = sigaction(SIGSEGV, (struct sigaction *)&act, NULL);
    }
    // 0x805d289
    return result;
}

// Address range: 0x805d438 - 0x805d47a
int32_t caml_ext_table_free(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    if (a2 == 0 || *a1 < 1) {
        // 0x805d468
        return caml_stat_free(*(int32_t *)(v1 + 8));
    }
    for (int32_t i = 0; i < *a1; i++) {
        // 0x805d453
        caml_stat_free(*(int32_t *)(*(int32_t *)(v1 + 8) + 4 * i));
    }
    // 0x805d468
    return caml_stat_free(*(int32_t *)(v1 + 8));
}

// Address range: 0x805d47a - 0x805d4ba
int32_t caml_ext_table_add(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x805d484
    int32_t v3 = *v2; // 0x805d484
    int32_t v4 = *a1; // 0x805d487
    int32_t v5; // 0x805d47a
    int32_t result; // 0x805d47a
    if (v4 < v3) {
        // 0x805d47a
        v5 = *(int32_t *)(v1 + 8);
        result = v4;
    } else {
        // 0x805d48b
        *v2 = 2 * v3;
        int32_t * v6 = (int32_t *)(v1 + 8);
        int32_t v7 = caml_stat_resize(*v6, 8 * v3); // 0x805d49e
        *v6 = v7;
        v5 = v7;
        result = *a1;
    }
    // 0x805d4a6
    *(int32_t *)(v5 + 4 * result) = a2;
    *a1 = *a1 + 1;
    return result;
}

// Address range: 0x805d4ba - 0x805d4e4
int32_t caml_ext_table_init(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    *a1 = 0;
    *(int32_t *)(v1 + 4) = a2;
    int32_t result = caml_stat_alloc(4 * a2); // 0x805d4d6
    *(int32_t *)(v1 + 8) = result;
    return result;
}

// Address range: 0x805d4e4 - 0x805d524
int32_t caml_aligned_malloc(int32_t a1, int32_t a2, int32_t * a3) {
    int32_t * mem = malloc(a1 + 0x1000); // 0x805d4f9
    int32_t result = 0; // 0x805d507
    if (mem != NULL) {
        int32_t v1 = (int32_t)mem; // 0x805d4f9
        *a3 = v1;
        result = (a2 + 0x1000 + v1 & -0x1000) - a2;
    }
    // 0x805d51e
    return result;
}

// Address range: 0x805d599 - 0x805d5bf
int32_t caml_fatal_error(char * str) {
    // 0x805d599
    fputs(str, g26);
    exit(2);
    return &g125;
}

// Address range: 0x805d5bf - 0x805d5fe
int32_t caml_gc_message(uint32_t result, char * format, int32_t a3) {
    if (result >= 0) {
        // 0x805d5cc
        if ((g45 & result) == 0) {
            // 0x805d5fc
            return result;
        }
    }
    // 0x805d5d4
    fprintf(g26, format);
    // 0x805d5fc
    return fflush(g26);
}

// Address range: 0x805d600 - 0x805d6d2
int32_t allocate_block(int32_t a1) {
    // 0x805d600
    int32_t v1; // 0x805d600
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(a1 - 4); // 0x805d618
    uint32_t v4 = *v3 / 1024; // 0x805d61a
    if (v4 >= v1 + 1) {
        // 0x805d69c
        g46 = (int32_t)g46 - v1;
        *v3 = 1024 * (v4 - v1) | 512;
        // 0x805d6c0
        return 4 * (v4 - v1) + a1;
    }
    // 0x805d624
    g46 = (int32_t)g46 + -1 - v4;
    *(int32_t *)v2 = *(int32_t *)a1;
    int32_t v5 = (int32_t)g18; // 0x805d632
    *(int32_t *)&g18 = v5 == a1 ? v2 : v5;
    *v3 = 0;
    if (g47 != 1) {
        // 0x805d6c0
        return 4 * (v4 - v1) + a1;
    }
    int32_t v6 = v1 + 1; // 0x805d659
    if (v6 < g48) {
        // 0x805d666
        if (*(int32_t *)(4 * v6 + (int32_t)&g52) == a1) {
            // 0x805d6c0
            return 4 * (v4 - v1) + a1;
        }
    }
    int32_t v7 = g48 - 1; // 0x805d678
    if (v7 != v1) {
        // 0x805d6c0
        return 4 * (v4 - v1) + a1;
    }
    // 0x805d680
    g49 = v2 == (int32_t)&g19 ? 0 : v2;
    g48 = v7;
    // 0x805d6c0
    return 4 * (v4 - v1) + a1;
}

// Address range: 0x805d6d2 - 0x805d6eb
int32_t caml_fl_init_merge(void) {
    // 0x805d6d2
    g55 = 0;
    *(int32_t *)&g18 = (int32_t)&g19;
    int32_t result; // 0x805d6d2
    return result;
}

// Address range: 0x805d6eb - 0x805d760
int32_t truncate_flp(void) {
    // 0x805d6eb
    int32_t v1; // 0x805d6eb
    uint32_t result = v1;
    if (result == (int32_t)&g19) {
        // 0x805d716
        g48 = 0;
        g49 = 0;
        // 0x805d75c
        return result;
    }
    // 0x805d6f7
    if (g48 >= 1) {
        int32_t v2 = g48 - 1; // 0x805d701
        uint32_t v3 = *(int32_t *)*(int32_t *)(4 * v2 + (int32_t)&g52); // 0x805d710
        if (result <= v3) {
            int32_t v4 = v2;
            while (v4 >= 1) {
                int32_t v5 = v4 - 1; // 0x805d732
                int32_t v6 = *(int32_t *)(4 * v5 + (int32_t)&g52); // 0x805d735
                if (result > *(int32_t *)v6) {
                    // 0x805d73c
                    g48 = v4;
                    goto lab_0x805d74a;
                }
                v4 = v5;
            }
            // 0x805d744
            g48 = v4;
        }
    }
    goto lab_0x805d74a;
  lab_0x805d74a:
    // 0x805d74a
    if (result <= g49) {
        // 0x805d752
        g49 = 0;
    }
    // 0x805d75c
    return result;
}

// Address range: 0x805d760 - 0x805d7a4
int32_t caml_fl_reset(void) {
    // 0x805d760
    g19 = 0;
    if (g47 == 0) {
        // 0x805d77d
        g20 = &g19;
        // 0x805d793
        g46 = 0;
        return caml_fl_init_merge();
    }
    if (g47 == 1) {
        // 0x805d789
        truncate_flp();
    }
    // 0x805d793
    g46 = 0;
    return caml_fl_init_merge();
}

// Address range: 0x805d7a4 - 0x805d909
int32_t caml_fl_merge_block(int32_t a1) {
    int32_t v1 = a1 - 4; // 0x805d7b0
    int32_t * v2 = (int32_t *)v1; // 0x805d7b6
    int32_t v3 = *v2; // 0x805d7b6
    int32_t v4 = v3 / 1024;
    g46 = v4 + 1 + (int32_t)g46;
    if (g47 == 1) {
        // 0x805d7e3
        truncate_flp();
    }
    int32_t v5 = v4; // 0x805d7f3
    int32_t v6 = a1; // 0x805d7f3
    int32_t v7 = v3; // 0x805d7f3
    if (v1 == g55) {
        uint32_t v8 = *v2 / 1024 + 1; // 0x805d7fd
        v5 = v4;
        v6 = a1;
        v7 = v3;
        if (v8 < 0x400000) {
            int32_t v9 = 1024 * v8; // 0x805d809
            *(int32_t *)(a1 - 8) = v9;
            g46 = (int32_t)g46 + 1;
            v5 = v8 % 0x400000;
            v6 = v1;
            v7 = v9;
        }
    }
    int32_t v10 = (int32_t)g18; // 0x805d7cc
    int32_t v11 = 4 * v5 + v6; // 0x805d81f
    int32_t v12 = v10; // 0x805d82a
    int32_t result = v11; // 0x805d82a
    int32_t v13 = v7; // 0x805d82a
    if (v10 - 4 == v11) {
        uint32_t v14 = v5 + 1 + g17 / 1024; // 0x805d844
        v12 = v10;
        result = v11;
        v13 = v7;
        if (v14 < 0x400000) {
            int32_t v15 = (int32_t)g18; // 0x805d833
            *g18 = v15;
            int32_t v16 = 1024 * v14 | 512; // 0x805d87c
            *(int32_t *)(v6 - 4) = v16;
            v12 = v15;
            result = (4 * v14 & 0xfffffc) + v6;
            v13 = v16;
        }
    }
    uint32_t v17 = g17 / 1024; // 0x805d898
    int32_t v18 = v6 - 4; // 0x805d8a4
    if (4 * v17 + v10 == v18) {
        uint32_t v19 = v13 / 1024 + 1 + v17; // 0x805d8b1
        if (v19 < 0x3fffff) {
            // 0x805d8bd
            g17 = 1024 * v19 | 512;
            // 0x805d901
            return result;
        }
    }
    if (v13 < 1024) {
        // 0x805d8f4
        g55 = v6;
        g46 = (int32_t)g46 - 1;
    } else {
        // 0x805d8d3
        *(int32_t *)v18 = v13 & -769 | 512;
        *(int32_t *)v6 = v12;
        *g18 = v6;
        *(int32_t *)&g18 = v6;
    }
    // 0x805d901
    return result;
}

// Address range: 0x805d909 - 0x805d9c9
int32_t caml_fl_add_blocks(uint32_t a1) {
    uint32_t v1 = *(int32_t *)(a1 - 4); // 0x805d911
    g46 = v1 / 1024 + 1 + (int32_t)g46;
    if (g50 < a1) {
        // 0x805d931
        *(int32_t *)g50 = a1;
        int32_t result = a1; // 0x805d939
        if (g50 == (int32_t)g18) {
            // 0x805d93b
            result = a1;
            if (g111 > a1) {
                int32_t v2 = *(int32_t *)(a1 + 4); // 0x805d943
                *(int32_t *)&g18 = v2;
                result = v2;
            }
        }
        // 0x805d94b
        if (g47 != 1) {
            // 0x805d9c5
            return result;
        }
        int32_t result2 = g48; // 0x805d95e
        if (g48 <= 999) {
            // 0x805d960
            *(int32_t *)(4 * g48 + (int32_t)&g52) = g50;
            result2 = g48 + 1;
            g48 = result2;
        }
        // 0x805d9c5
        return result2;
    }
    int32_t v3 = g19; // 0x805d971
    int32_t v4 = v3; // 0x805d979
    int32_t v5 = &g19; // 0x805d979
    if (v3 != 0 == v3 < a1) {
        int32_t v6 = *(int32_t *)v3; // 0x805d988
        v4 = v6;
        v5 = v3;
        while (v6 != 0 == v6 < a1) {
            int32_t v7 = v6;
            v6 = *(int32_t *)v7;
            v4 = v6;
            v5 = v7;
        }
    }
    int32_t * v8 = (int32_t *)(a1 + 4); // 0x805d999
    *(int32_t *)*v8 = v4;
    *(int32_t *)v5 = a1;
    if (v5 == (int32_t)g18) {
        // 0x805d9a7
        if (g111 > a1) {
            // 0x805d9af
            *(int32_t *)&g18 = *v8;
        }
    }
    int32_t result3 = a1; // 0x805d9be
    if (g47 == 1) {
        // 0x805d9c0
        result3 = truncate_flp();
    }
    // 0x805d9c5
    return result3;
}

// Address range: 0x805d9c9 - 0x805da14
int32_t caml_make_free_blocks(int32_t a1, int32_t a2, int32_t a3) {
    if (a2 == 0) {
        // 0x805da0c
        int32_t result; // 0x805d9c9
        return result;
    }
    uint32_t v1 = a2;
    int32_t v2 = a1;
    int32_t v3 = v1 < 0x400000 ? v1 : 0x400000; // 0x805d9e7
    int32_t v4 = 1024 * v3 - 1024; // 0x805d9ed
    *(int32_t *)v2 = v4;
    int32_t result2 = v4; // 0x805d9f6
    if (a3 != 0) {
        // 0x805d9f8
        result2 = caml_fl_merge_block(v2 + 4);
    }
    int32_t v5 = v1 - v3; // 0x805da03
    while (v5 != 0) {
        // 0x805da07
        v1 = v5;
        v2 += 4 * v3;
        v3 = v1 < 0x400000 ? v1 : 0x400000;
        v4 = 1024 * v3 - 1024;
        *(int32_t *)v2 = v4;
        result2 = v4;
        if (a3 != 0) {
            // 0x805d9f8
            result2 = caml_fl_merge_block(v2 + 4);
        }
        // 0x805da03
        v5 = v1 - v3;
    }
    // 0x805da0c
    return result2;
}

// Address range: 0x805da14 - 0x805da4c
int32_t caml_set_allocation_policy(int32_t result) {
    if (result == 0) {
        // 0x805da25
        g20 = &g19;
        // 0x805da45
        g47 = result;
        return result;
    }
    if (result == 1) {
        // 0x805da31
        g48 = 0;
        g49 = 0;
    }
    // 0x805da45
    g47 = result;
    return result;
}

// Address range: 0x805da4c - 0x805dec8
int32_t caml_fl_allocate(uint32_t a1) {
    int32_t v1; // 0x805da4c
    int32_t v2; // 0x805da4c
    uint32_t v3; // 0x805da4c
    int32_t v4; // 0x805da4c
    int32_t v5; // 0x805da4c
    int32_t v6; // 0x805da4c
    int32_t v7; // 0x805da4c
    int32_t v8; // 0x805da4c
    int32_t v9; // 0x805da4c
    int32_t v10; // 0x805da4c
    int32_t v11; // bp-4, 0x805da4c
    int32_t v12; // bp-4028, 0x805da4c
    int32_t v13; // 0x805da4c
    int32_t v14; // 0x805dcad
    int32_t v15; // 0x805dcfd
    int32_t * v16; // 0x805dcfd
    int32_t v17; // 0x805dcfd
    int32_t v18; // 0x805dd00
    int32_t v19; // 0x805dcc5
    int32_t v20; // 0x805dccc
    int32_t v21; // 0x805da4c
    int32_t v22; // 0x805dd2b
    uint32_t v23; // 0x805dd30
    int32_t v24; // 0x805ddfe
    int32_t v25; // 0x805dd3e
    // 0x805da4c
    if (g47 == 0) {
        // 0x805daa7
        if (g20 == 0) {
            // 0x805dae8
            g50 = 0;
        } else {
            int32_t v26 = g20; // 0x805dabb
            if (*(int32_t *)(g20 - 4) / 1024 >= a1) {
              lab_0x805dac9:
                // 0x805debb
                return allocate_block(v26);
            }
            int32_t v27 = g20;
            int32_t v28 = *(int32_t *)v27; // 0x805dae2
            while (v28 != 0) {
                // 0x805dabf
                v26 = v28;
                if (*(int32_t *)(v28 - 4) / 1024 >= a1) {
                    return allocate_block(v26);
                }
                v27 = v28;
                v28 = *(int32_t *)v27;
            }
            // 0x805dae8
            g50 = v27;
            if (g20 == (int32_t)&g19) {
                // 0x805debb
                return 0;
            }
        }
        int32_t v29 = g19; // 0x805db0b
        if (*(int32_t *)(g19 - 4) / 1024 >= a1) {
          lab_0x805db19:
            // 0x805debb
            return allocate_block(v29);
        }
        int32_t v30 = g19;
        int32_t v31 = *(int32_t *)v30; // 0x805db32
        while (g20 != v30) {
            // 0x805db0f
            v29 = v31;
            if (*(int32_t *)(v31 - 4) / 1024 >= a1) {
                return allocate_block(v29);
            }
            v30 = v31;
            v31 = *(int32_t *)v30;
        }
        // 0x805debb
        return 0;
    }
    // 0x805da65
    if (g47 != 1) {
        // 0x805debb
        return 0;
    }
    int32_t v32 = g48; // 0x805da6e
    int32_t v33; // 0x805da88
    uint32_t v34; // 0x805da8d
    if (v32 < 1) {
        goto lab_0x805db6b;
    } else {
        // 0x805da82
        v33 = *(int32_t *)g52;
        v34 = *(int32_t *)(v33 - 4) / 1024;
        if (v34 < a1) {
            while (true) {
                // continue -> 0x805db60
            }
        } else {
            goto lab_0x805db4c;
        }
    }
  lab_0x805db4c:;
    int32_t v35 = 0; // 0x805db5b
    int32_t v36 = v34; // 0x805db5b
    int32_t result = allocate_block(v33); // 0x805db5b
    goto lab_0x805dc97;
  lab_0x805db6b:;
    int32_t v37 = &g19; // 0x805db72
    int32_t v38 = 0; // 0x805db72
    if (v32 != 0) {
        int32_t v39 = *(int32_t *)(4 * v32 + (int32_t)&g51); // 0x805db8e
        int32_t v40 = *(int32_t *)v39; // 0x805db95
        int32_t v41 = g49; // 0x805db9d
        v37 = v41 != 0 ? v41 : v40;
        v38 = *(int32_t *)(v40 - 4) / 1024;
    }
    int32_t v42 = v32; // 0x805dc22
    int32_t v43 = v38; // 0x805dc22
    int32_t v44; // 0x805da4c
    if (v32 < 1000) {
        int32_t v45 = v37;
        int32_t v46 = *(int32_t *)v45; // 0x805dbaa
        while (v46 != 0) {
            int32_t v47 = v42;
            uint32_t v48 = *(int32_t *)(v46 - 4) / 1024; // 0x805dbd7
            int32_t v49 = v47; // 0x805dbdc
            int32_t v50 = v43; // 0x805dbdc
            if (v43 < v48) {
                // 0x805dbde
                *(int32_t *)(4 * v47 + (int32_t)&g52) = v45;
                int32_t v51 = g48; // 0x805dbe5
                v49 = v51 + 1;
                g48 = v49;
                v50 = v48;
                if (v48 >= a1) {
                    // 0x805dbf8
                    g49 = v46;
                    v35 = v51;
                    v36 = v48;
                    result = allocate_block(v46);
                    goto lab_0x805dc97;
                }
            }
            // 0x805dc14
            v42 = v49;
            v43 = v50;
            if (v49 >= 1000) {
                // 0x805dc24
                g49 = v46;
                v44 = v46;
                goto lab_0x805dc37;
            }
            v45 = v46;
            v46 = *(int32_t *)v45;
        }
        // 0x805dbb0
        g50 = v45;
        g49 = v45 == (int32_t)&g19 ? 0 : v45;
        // 0x805debb
        return 0;
    }
    // 0x805dc24
    g49 = 0;
    v44 = *(int32_t *)(4 * v32 + (int32_t)&g51);
    goto lab_0x805dc37;
  lab_0x805dc37:;
    int32_t v52 = *(int32_t *)v44; // 0x805dc45
    if (v52 == 0) {
        // 0x805dc87
        g50 = v44;
        // 0x805debb
        return 0;
    }
    uint32_t v53 = *(int32_t *)(v52 - 4) / 1024; // 0x805dc4e
    if (*(int32_t *)(*(int32_t *)g54 - 4) / 1024 > v53) {
        // 0x805dc55
        g49 = v52;
    } else {
        if (v53 >= a1) {
            // break -> 0x805dc61
            break;
        }
    }
    int32_t v54 = *(int32_t *)v52; // 0x805dc79
    // 0x805dc87
    g50 = v52;
    while (v54 != 0) {
        int32_t v55 = v54;
        v53 = *(int32_t *)(v55 - 4) / 1024;
        if (*(int32_t *)(*(int32_t *)g54 - 4) / 1024 > v53) {
            // 0x805dc55
            g49 = v55;
        } else {
            if (v53 >= a1) {
                // break -> 0x805dc61
                break;
            }
        }
        // 0x805dc79
        v54 = *(int32_t *)v55;
        // 0x805dc87
        g50 = v55;
    }
    // 0x805debb
    return 0;
}

// Address range: 0x805ded0 - 0x805deec
int32_t clip_heap_chunk_size(int32_t a1) {
    // 0x805ded0
    int32_t v1; // 0x805ded0
    uint32_t v2 = v1;
    return (v2 > 0x2000 ? v2 : 0x2000) + 4095 & -0x1000;
}

// Address range: 0x805deec - 0x805dfef
int32_t caml_init_major_heap(int32_t a1) {
    // 0x805deec
    int32_t v1; // 0x805deec
    int32_t v2 = clip_heap_chunk_size(v1); // 0x805def5
    g85 = v2;
    g86 = v2;
    int32_t v3 = caml_alloc_for_heap(v2); // 0x805df07
    g114 = v3;
    if (v3 == 0) {
        // 0x805df15
        caml_fatal_error("Fatal error: not enough memory for the initial heap.\n");
        // UNREACHABLE
    }
    // 0x805df21
    *(int32_t *)(v3 - 4) = 0;
    g88 = 1;
    int32_t v4 = g114; // 0x805df32
    if (caml_page_table_add(1, (int32_t *)v4, (int32_t *)(g85 + v4)) != 0) {
        // 0x805df57
        caml_fatal_error("Fatal error: not enough memory for the initial page table.\n");
        // UNREACHABLE
    }
    // 0x805df63
    caml_fl_init_merge();
    caml_make_free_blocks(g114, g85 / 4, 1);
    g115 = 2;
    g60 = 2048;
    int32_t * mem = malloc(0x2000); // 0x805dfa4
    int32_t v5 = (int32_t)mem; // 0x805dfa4
    g57 = v5;
    if (mem == NULL) {
        // 0x805dfb2
        caml_fatal_error("Fatal error: not enough memory for the gray cache.\n");
        // UNREACHABLE
    }
    // 0x805dfbe
    g58 = v5;
    int32_t result = 4 * g60 + v5; // 0x805dfc9
    g59 = result;
    g61 = 1;
    g117 = 0;
    g116 = 0.0;
    return result;
}

// Address range: 0x805dfef - 0x805e017
int32_t caml_round_heap_chunk_size(uint32_t a1) {
    // 0x805dfef
    int32_t v1; // 0x805dfef
    int32_t v2 = clip_heap_chunk_size(v1); // 0x805e003
    int32_t result = v2; // 0x805e00a
    if (v2 < a1) {
        // 0x805e00c
        result = caml_raise_out_of_memory();
    }
    // 0x805e011
    return result;
}

// Address range: 0x805e017 - 0x805e05e
int32_t start_cycle(int32_t a1) {
    // 0x805e017
    caml_gc_message(1, "Starting new major GC cycle\n", 0);
    int32_t result = caml_darken_all_roots(); // 0x805e039
    g115 = 0;
    g110 = 10;
    g62 = 0;
    return result;
}

// Address range: 0x805e05e - 0x805e133
int32_t realloc_gray_vals(int32_t a1) {
    uint32_t v1 = g60; // 0x805e064
    int32_t v2 = g85; // 0x805e06a
    int32_t result = (v2 < 0 ? v2 + 127 : v2) / 128; // 0x805e077
    if (result <= v1) {
        // 0x805e116
        g58 = g57 + 4 * v1 / 2;
        g61 = 0;
        // 0x805e131
        return result;
    }
    // 0x805e082
    caml_gc_message(8, "Growing gray_vals to %luk bytes\n", v1 / 128 % 0x800000);
    int32_t * mem = realloc((int32_t *)g57, 8 * g60); // 0x805e0b4
    int32_t result2; // 0x805e05e
    if (mem != NULL) {
        int32_t v3 = (int32_t)mem; // 0x805e0b4
        g57 = v3;
        int32_t v4 = g60; // 0x805e0f4
        g58 = 4 * v4 + v3;
        g60 = 2 * v4;
        int32_t v5 = 8 * v4 + v3; // 0x805e10c
        g59 = v5;
        result2 = v5;
    } else {
        // 0x805e0bd
        caml_gc_message(8, "No room for growing gray_vals\n", 0);
        g58 = g57;
        g61 = 0;
        result2 = g57;
    }
    // 0x805e131
    return result2;
}

// Address range: 0x805e133 - 0x805e580
int32_t mark_slice(void) {
    // 0x805e133
    int32_t v1; // 0x805e133
    caml_gc_message(64, "Marking %ld words\n", v1);
    int32_t result = caml_gc_message(64, "Subphase = %ld\n", g110); // 0x805e16f
    int32_t v2 = g58; // 0x805e174
    if (v1 < 1) {
        // 0x805e572
        g58 = v2;
        return result;
    }
    int32_t v3; // 0x805e133
    int32_t v4; // 0x805e133
    int32_t * v5; // 0x805e133
    int32_t v6; // 0x805e133
    int32_t * v7; // 0x805e133
    int32_t v8; // 0x805e133
    int32_t v9; // 0x805e133
    int32_t v10; // 0x805e133
    uint32_t v11; // 0x805e133
    int32_t v12; // 0x805e133
    int32_t v13; // 0x805e133
    int32_t result2; // 0x805e133
    int32_t v14; // 0x805e133
    int32_t v15; // 0x805e133
    int32_t v16; // 0x805e133
    int32_t v17; // 0x805e133
    int32_t v18; // 0x805e133
    int32_t v19; // 0x805e133
    int32_t v20; // 0x805e133
    int32_t v21; // 0x805e133
    int32_t v22; // 0x805e133
    int32_t v23; // 0x805e133
    int32_t v24; // 0x805e133
    int32_t v25; // 0x805e133
    int32_t v26; // 0x805e133
    int32_t v27; // 0x805e133
    int32_t v28; // 0x805e133
    int32_t * v29; // 0x805e198
    uint32_t v30; // 0x805e198
    uint32_t v31; // 0x805e1a3
    int32_t v32; // 0x805e133
    int32_t * v33; // 0x805e1c1
    int32_t v34; // 0x805e1c1
    int32_t v35; // 0x805e351
    int32_t v36; // 0x805e335
    int32_t v37; // 0x805e344
    int32_t v38; // 0x805e2f2
    int32_t v39; // 0x805e2c5
    int32_t v40; // 0x805e1de
    int32_t v41; // 0x805e3a3
    int32_t v42; // 0x805e314
    int32_t v43; // 0x805e2e5
    int32_t v44; // 0x805e1ef
    uint32_t v45; // 0x805e1f2
    uint32_t v46; // 0x805e3b3
    uint32_t v47; // 0x805e3b6
    uint32_t v48; // 0x805e1fd
    int32_t v49; // 0x805e133
    int32_t * v50; // 0x805e3d5
    uint32_t v51; // 0x805e3d5
    int32_t v52; // 0x805e3d8
    int32_t * v53; // 0x805e4e9
    int32_t v54; // 0x805e4e9
    int32_t v55; // 0x805e257
    int32_t v56; // 0x805e218
    int32_t v57; // 0x805e4a1
    int32_t v58; // 0x805e50f
    int32_t v59; // 0x805e545
    int32_t v60; // 0x805e55c
    int32_t v61; // 0x805e3fe
    int32_t v62; // 0x805e4f8
    int32_t v63; // 0x805e40f
    uint32_t v64; // 0x805e417
    int32_t v65; // 0x805e2af
    int32_t v66; // 0x805e44d
    int32_t * v67; // 0x805e453
    int32_t v68; // 0x805e460
    char * v69; // 0x805e463
    int32_t v70; // 0x805e133
    int32_t v71; // 0x805e190
    uint32_t v72; // 0x805e438
    int32_t v73; // 0x805e44d
    int32_t * v74; // 0x805e453
    int32_t v75; // 0x805e193
    if (g57 >= v2) {
        // 0x805e2af
        v65 = g62;
        if (v65 == 0) {
            // 0x805e322
            if (g61 != 0) {
                // 0x805e351
                v35 = g110;
                if (v35 == 11) {
                    // 0x805e39e
                    v41 = *(int32_t *)g65;
                    if (v41 == 0) {
                        // 0x805e4ca
                        g110 = 12;
                        g65 = &g90;
                        v25 = v24;
                        v13 = 0;
                        v21 = v2;
                    } else {
                        // 0x805e3b0
                        v46 = *(int32_t *)(v41 - 4);
                        v47 = v46 / 1024;
                        v23 = 1;
                        if (v46 >= 2048) {
                            while (true) {
                                // 0x805e3cf
                                v50 = (int32_t *)(4 * v23 + v41);
                                v51 = *v50;
                                v52 = (int32_t)g24;
                                if (v51 != v52) {
                                    if (v51 % 2 == 0) {
                                        // 0x805e3ee
                                        v61 = *(int32_t *)(4 * v51 / 0x800000 + (int32_t)&g121);
                                        if (*(char *)(v61 + v51 / 0x1000 % 2048) % 2 != 0) {
                                            // 0x805e40f
                                            v63 = v51 - 4;
                                            v19 = v63;
                                            v16 = v52;
                                            if (*(char *)v63 == -6) {
                                                // 0x805e417
                                                v64 = *(int32_t *)v51;
                                                v19 = v63;
                                                v16 = v52;
                                                if (v64 % 2 == 0) {
                                                    // 0x805e43e
                                                    v66 = v64 / 0x1000 % 2048;
                                                    v67 = (int32_t *)(4 * v64 / 0x800000 + (int32_t)&g121);
                                                    v5 = v67;
                                                    v6 = v66;
                                                    v15 = v52;
                                                    v18 = v63;
                                                    v10 = v64;
                                                    v19 = v63;
                                                    v16 = v52;
                                                    if (*(char *)(*v67 + v66) % 8 != 0) {
                                                        while (true) {
                                                            // 0x805e460
                                                            v11 = v10;
                                                            v68 = v11 - 4;
                                                            v69 = (char *)v68;
                                                            v19 = v18;
                                                            v16 = v15;
                                                            switch (*v69) {
                                                                case -6: {
                                                                    goto lab_0x805e490;
                                                                }
                                                                case -10: {
                                                                    goto lab_0x805e490;
                                                                }
                                                                case -3: {
                                                                    goto lab_0x805e490;
                                                                }
                                                                default: {
                                                                    // 0x805e478
                                                                    v8 = v6;
                                                                    v7 = v5;
                                                                    *v50 = v11;
                                                                    v70 = (int32_t)g24;
                                                                    if (v11 == v70) {
                                                                        goto lab_0x805e4a1_3;
                                                                    }
                                                                    if (v11 % 2 != 0) {
                                                                        goto lab_0x805e4a1_3;
                                                                    }
                                                                    // 0x805e423
                                                                    if (*(char *)(*v7 + v8) % 2 == 0) {
                                                                        goto lab_0x805e4a1_3;
                                                                    }
                                                                    // 0x805e430
                                                                    if (*v69 != -6) {
                                                                        // break -> 0x805e490
                                                                        break;
                                                                    }
                                                                    // 0x805e438
                                                                    v72 = *(int32_t *)v11;
                                                                    if (v72 % 2 != 0) {
                                                                        // break -> 0x805e490
                                                                        break;
                                                                    }
                                                                    // 0x805e43e
                                                                    v73 = v72 / 0x1000 % 2048;
                                                                    v74 = (int32_t *)(4 * v72 / 0x800000 + (int32_t)&g121);
                                                                    v5 = v74;
                                                                    v6 = v73;
                                                                    v15 = v70;
                                                                    v18 = v68;
                                                                    v10 = v72;
                                                                    if (*(char *)(*v74 + v73) % 8 == 0) {
                                                                        // break -> 0x805e490
                                                                        break;
                                                                    }
                                                                    goto lab_0x805e460;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            // 0x805e490
                                            if ((*(int32_t *)v19 & 768) == 0) {
                                                // 0x805e498
                                                *v50 = v16;
                                            }
                                        }
                                    }
                                }
                                // 0x805e4a1
                                v57 = v23 + 1;
                                v23 = v57;
                                if (v57 == v47) {
                                    // break -> 0x805e4b4
                                    break;
                                }
                            }
                        }
                        // 0x805e4b4
                        g65 = v41;
                        v49 = -1 - v47;
                        v25 = v24 + v49;
                        v13 = v49;
                        v21 = v2;
                    }
                } else {
                    if (v35 > 11) {
                        if (v35 == 12) {
                            // 0x805e4e3
                            v53 = (int32_t *)g65;
                            v54 = *v53;
                            if (v54 == 0) {
                                // 0x805e509
                                g58 = v2;
                                v58 = caml_final_update();
                                g110 = 13;
                                v25 = v24;
                                v13 = v58;
                                v21 = g58;
                            } else {
                                // 0x805e4ef
                                if ((*(int32_t *)(v54 - 4) & 768) != 0) {
                                    // 0x805e4fe
                                    g65 = v54;
                                    v12 = v54;
                                } else {
                                    // 0x805e4f8
                                    v62 = *(int32_t *)v54;
                                    *v53 = v62;
                                    v12 = v62;
                                }
                                // 0x805e503
                                v25 = v24 - 1;
                                v13 = v12;
                                v21 = v2;
                            }
                        } else {
                            // 0x805e376
                            v25 = v24;
                            v13 = v35;
                            v21 = v2;
                            if (v35 == 13) {
                                // 0x805e526
                                g58 = v2;
                                g111 = g114;
                                caml_fl_init_merge();
                                g115 = 1;
                                v59 = g114;
                                g63 = v59;
                                g111 = v59;
                                g64 = *(int32_t *)(v59 - 8) + v59;
                                v60 = g46;
                                g56 = v60;
                                result2 = v60;
                                v22 = v2;
                                goto lab_0x805e572;
                            }
                        }
                    } else {
                        // 0x805e360
                        v25 = v24;
                        v13 = v35;
                        v21 = v2;
                        if (v35 == 10) {
                            // 0x805e385
                            g110 = 11;
                            g65 = &g90;
                            v25 = v24;
                            v13 = v35;
                            v21 = v2;
                        }
                    }
                }
            } else {
                // 0x805e32b
                g61 = 1;
                v36 = g114;
                g63 = v36;
                g62 = v36;
                v37 = *(int32_t *)(v36 - 8) + v36;
                g64 = v37;
                v25 = v24;
                v13 = v37;
                v21 = v2;
            }
        } else {
            // 0x805e2b8
            if (v65 != g64) {
                // 0x805e2f2
                v38 = *(int32_t *)v65;
                v4 = v38;
                v3 = v65;
                v20 = v2;
                if ((v38 & 768) == 256) {
                    // 0x805e302
                    *(int32_t *)v2 = v65 + 4;
                    v3 = g62;
                    v4 = *(int32_t *)v3;
                    v20 = v2 + 4;
                }
                // 0x805e30a
                v42 = v3 + 4 + 4 * v4 / 1024;
                g62 = v42;
                v25 = v24;
                v13 = v42;
                v21 = v20;
            } else {
                // 0x805e2c0
                v39 = *(int32_t *)(g63 - 4);
                g63 = v39;
                if (v39 != 0) {
                    // 0x805e2e0
                    g62 = v39;
                    v43 = *(int32_t *)(v39 - 8) + v39;
                    g64 = v43;
                    v25 = v24;
                    v13 = v43;
                    v21 = v2;
                } else {
                    // 0x805e2d1
                    g62 = 0;
                    v25 = v24;
                    v13 = v39;
                    v21 = v2;
                }
            }
        }
    } else {
        // 0x805e190
        v71 = v2 - 4;
        v75 = *(int32_t *)v71;
        v29 = (int32_t *)(v75 - 4);
        v30 = *v29;
        *v29 = v30 | 768;
        v31 = v30 / 1024;
        v26 = v71;
        v14 = 0;
        if ((char)v30 <= 250 && v30 >= 1024) {
            while (true) {
                // 0x805e1c1
                v27 = v26;
                v33 = (int32_t *)(4 * v14 + v75);
                v34 = *v33;
                v28 = v27;
                if (v34 % 2 != 0) {
                    goto lab_0x805e293;
                } else {
                    // 0x805e1cc
                    v40 = *(int32_t *)(4 * v34 / 0x800000 + (int32_t)&g121);
                    v28 = v27;
                    if (*(char *)(v40 + v34 / 0x1000 % 2048) % 2 == 0) {
                        goto lab_0x805e293;
                    } else {
                        // 0x805e1ef
                        v44 = *(int32_t *)(v34 - 4);
                        v45 = v44 % 256;
                        if (v45 != 250) {
                            // 0x805e245
                            v9 = v34;
                            v17 = v44;
                            if (v45 == 249) {
                                // 0x805e24d
                                v55 = v34 - 4 * v44 / 1024;
                                v9 = v55;
                                v17 = *(int32_t *)(v55 - 4);
                            }
                            goto lab_0x805e25e;
                        } else {
                            // 0x805e1fd
                            v48 = *(int32_t *)v34;
                            if (v48 % 2 != 0) {
                                goto lab_0x805e23d;
                            } else {
                                // 0x805e207
                                v56 = *(int32_t *)(4 * v48 / 0x800000 + (int32_t)&g121);
                                v9 = v34;
                                v17 = v44;
                                if (*(char *)(v56 + v48 / 0x1000 % 2048) % 8 == 0) {
                                    goto lab_0x805e25e;
                                } else {
                                    // 0x805e225
                                    v9 = v34;
                                    v17 = v44;
                                    switch (*(char *)(v48 - 4)) {
                                        case -6: {
                                            goto lab_0x805e25e;
                                        }
                                        case -10: {
                                            goto lab_0x805e25e;
                                        }
                                        case -3: {
                                            goto lab_0x805e25e;
                                        }
                                        default: {
                                            goto lab_0x805e23d;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // 0x805e2a2
        v32 = -1 - v31;
        v25 = v24 + v32;
        v13 = v32;
        v21 = v71;
    }
    int32_t v76 = v21;
    result2 = v13;
    v22 = v76;
    while (v25 >= 0 == (v25 != 0)) {
        int32_t v77 = v76;
        int32_t v78 = v25;
        if (g57 >= v77) {
            // 0x805e2af
            v65 = g62;
            if (v65 == 0) {
                // 0x805e322
                if (g61 != 0) {
                    // 0x805e351
                    v35 = g110;
                    if (v35 == 11) {
                        // 0x805e39e
                        v41 = *(int32_t *)g65;
                        if (v41 == 0) {
                            // 0x805e4ca
                            g110 = 12;
                            g65 = &g90;
                            v25 = v78;
                            v13 = 0;
                            v21 = v77;
                        } else {
                            // 0x805e3b0
                            v46 = *(int32_t *)(v41 - 4);
                            v47 = v46 / 1024;
                            v23 = 1;
                            if (v46 >= 2048) {
                                while (true) {
                                    // 0x805e3cf
                                    v50 = (int32_t *)(4 * v23 + v41);
                                    v51 = *v50;
                                    v52 = (int32_t)g24;
                                    if (v51 != v52) {
                                        if (v51 % 2 == 0) {
                                            // 0x805e3ee
                                            v61 = *(int32_t *)(4 * v51 / 0x800000 + (int32_t)&g121);
                                            if (*(char *)(v61 + v51 / 0x1000 % 2048) % 2 != 0) {
                                                // 0x805e40f
                                                v63 = v51 - 4;
                                                v19 = v63;
                                                v16 = v52;
                                                if (*(char *)v63 == -6) {
                                                    // 0x805e417
                                                    v64 = *(int32_t *)v51;
                                                    v19 = v63;
                                                    v16 = v52;
                                                    if (v64 % 2 == 0) {
                                                        // 0x805e43e
                                                        v66 = v64 / 0x1000 % 2048;
                                                        v67 = (int32_t *)(4 * v64 / 0x800000 + (int32_t)&g121);
                                                        v5 = v67;
                                                        v6 = v66;
                                                        v15 = v52;
                                                        v18 = v63;
                                                        v10 = v64;
                                                        v19 = v63;
                                                        v16 = v52;
                                                        if (*(char *)(*v67 + v66) % 8 != 0) {
                                                            while (true) {
                                                                // 0x805e460
                                                                v11 = v10;
                                                                v68 = v11 - 4;
                                                                v69 = (char *)v68;
                                                                v19 = v18;
                                                                v16 = v15;
                                                                switch (*v69) {
                                                                    case -6: {
                                                                        goto lab_0x805e490;
                                                                    }
                                                                    case -10: {
                                                                        goto lab_0x805e490;
                                                                    }
                                                                    case -3: {
                                                                        goto lab_0x805e490;
                                                                    }
                                                                    default: {
                                                                        // 0x805e478
                                                                        v8 = v6;
                                                                        v7 = v5;
                                                                        *v50 = v11;
                                                                        v70 = (int32_t)g24;
                                                                        if (v11 == v70) {
                                                                            goto lab_0x805e4a1_3;
                                                                        }
                                                                        if (v11 % 2 != 0) {
                                                                            goto lab_0x805e4a1_3;
                                                                        }
                                                                        // 0x805e423
                                                                        if (*(char *)(*v7 + v8) % 2 == 0) {
                                                                            goto lab_0x805e4a1_3;
                                                                        }
                                                                        // 0x805e430
                                                                        if (*v69 != -6) {
                                                                            // break -> 0x805e490
                                                                            break;
                                                                        }
                                                                        // 0x805e438
                                                                        v72 = *(int32_t *)v11;
                                                                        if (v72 % 2 != 0) {
                                                                            // break -> 0x805e490
                                                                            break;
                                                                        }
                                                                        // 0x805e43e
                                                                        v73 = v72 / 0x1000 % 2048;
                                                                        v74 = (int32_t *)(4 * v72 / 0x800000 + (int32_t)&g121);
                                                                        v5 = v74;
                                                                        v6 = v73;
                                                                        v15 = v70;
                                                                        v18 = v68;
                                                                        v10 = v72;
                                                                        if (*(char *)(*v74 + v73) % 8 == 0) {
                                                                            // break -> 0x805e490
                                                                            break;
                                                                        }
                                                                        goto lab_0x805e460;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                // 0x805e490
                                                if ((*(int32_t *)v19 & 768) == 0) {
                                                    // 0x805e498
                                                    *v50 = v16;
                                                }
                                            }
                                        }
                                    }
                                    // 0x805e4a1
                                    v57 = v23 + 1;
                                    v23 = v57;
                                    if (v57 == v47) {
                                        // break -> 0x805e4b4
                                        break;
                                    }
                                }
                            }
                            // 0x805e4b4
                            g65 = v41;
                            v49 = -1 - v47;
                            v25 = v78 + v49;
                            v13 = v49;
                            v21 = v77;
                        }
                    } else {
                        if (v35 > 11) {
                            if (v35 == 12) {
                                // 0x805e4e3
                                v53 = (int32_t *)g65;
                                v54 = *v53;
                                if (v54 == 0) {
                                    // 0x805e509
                                    g58 = v77;
                                    v58 = caml_final_update();
                                    g110 = 13;
                                    v25 = v78;
                                    v13 = v58;
                                    v21 = g58;
                                } else {
                                    // 0x805e4ef
                                    if ((*(int32_t *)(v54 - 4) & 768) != 0) {
                                        // 0x805e4fe
                                        g65 = v54;
                                        v12 = v54;
                                    } else {
                                        // 0x805e4f8
                                        v62 = *(int32_t *)v54;
                                        *v53 = v62;
                                        v12 = v62;
                                    }
                                    // 0x805e503
                                    v25 = v78 - 1;
                                    v13 = v12;
                                    v21 = v77;
                                }
                            } else {
                                // 0x805e376
                                v25 = v78;
                                v13 = v35;
                                v21 = v77;
                                if (v35 == 13) {
                                    // 0x805e526
                                    g58 = v77;
                                    g111 = g114;
                                    caml_fl_init_merge();
                                    g115 = 1;
                                    v59 = g114;
                                    g63 = v59;
                                    g111 = v59;
                                    g64 = *(int32_t *)(v59 - 8) + v59;
                                    v60 = g46;
                                    g56 = v60;
                                    result2 = v60;
                                    v22 = v77;
                                    goto lab_0x805e572;
                                }
                            }
                        } else {
                            // 0x805e360
                            v25 = v78;
                            v13 = v35;
                            v21 = v77;
                            if (v35 == 10) {
                                // 0x805e385
                                g110 = 11;
                                g65 = &g90;
                                v25 = v78;
                                v13 = v35;
                                v21 = v77;
                            }
                        }
                    }
                } else {
                    // 0x805e32b
                    g61 = 1;
                    v36 = g114;
                    g63 = v36;
                    g62 = v36;
                    v37 = *(int32_t *)(v36 - 8) + v36;
                    g64 = v37;
                    v25 = v78;
                    v13 = v37;
                    v21 = v77;
                }
            } else {
                // 0x805e2b8
                if (v65 != g64) {
                    // 0x805e2f2
                    v38 = *(int32_t *)v65;
                    v4 = v38;
                    v3 = v65;
                    v20 = v77;
                    if ((v38 & 768) == 256) {
                        // 0x805e302
                        *(int32_t *)v77 = v65 + 4;
                        v3 = g62;
                        v4 = *(int32_t *)v3;
                        v20 = v77 + 4;
                    }
                    // 0x805e30a
                    v42 = v3 + 4 + 4 * v4 / 1024;
                    g62 = v42;
                    v25 = v78;
                    v13 = v42;
                    v21 = v20;
                } else {
                    // 0x805e2c0
                    v39 = *(int32_t *)(g63 - 4);
                    g63 = v39;
                    if (v39 != 0) {
                        // 0x805e2e0
                        g62 = v39;
                        v43 = *(int32_t *)(v39 - 8) + v39;
                        g64 = v43;
                        v25 = v78;
                        v13 = v43;
                        v21 = v77;
                    } else {
                        // 0x805e2d1
                        g62 = 0;
                        v25 = v78;
                        v13 = v39;
                        v21 = v77;
                    }
                }
            }
        } else {
            // 0x805e190
            v71 = v77 - 4;
            v75 = *(int32_t *)v71;
            v29 = (int32_t *)(v75 - 4);
            v30 = *v29;
            *v29 = v30 | 768;
            v31 = v30 / 1024;
            v26 = v71;
            v14 = 0;
            if ((char)v30 <= 250 && v30 >= 1024) {
                while (true) {
                    // 0x805e1c1
                    v27 = v26;
                    v33 = (int32_t *)(4 * v14 + v75);
                    v34 = *v33;
                    v28 = v27;
                    if (v34 % 2 != 0) {
                        goto lab_0x805e293;
                    } else {
                        // 0x805e1cc
                        v40 = *(int32_t *)(4 * v34 / 0x800000 + (int32_t)&g121);
                        v28 = v27;
                        if (*(char *)(v40 + v34 / 0x1000 % 2048) % 2 == 0) {
                            goto lab_0x805e293;
                        } else {
                            // 0x805e1ef
                            v44 = *(int32_t *)(v34 - 4);
                            v45 = v44 % 256;
                            if (v45 != 250) {
                                // 0x805e245
                                v9 = v34;
                                v17 = v44;
                                if (v45 == 249) {
                                    // 0x805e24d
                                    v55 = v34 - 4 * v44 / 1024;
                                    v9 = v55;
                                    v17 = *(int32_t *)(v55 - 4);
                                }
                                goto lab_0x805e25e;
                            } else {
                                // 0x805e1fd
                                v48 = *(int32_t *)v34;
                                if (v48 % 2 != 0) {
                                    goto lab_0x805e23d;
                                } else {
                                    // 0x805e207
                                    v56 = *(int32_t *)(4 * v48 / 0x800000 + (int32_t)&g121);
                                    v9 = v34;
                                    v17 = v44;
                                    if (*(char *)(v56 + v48 / 0x1000 % 2048) % 8 == 0) {
                                        goto lab_0x805e25e;
                                    } else {
                                        // 0x805e225
                                        v9 = v34;
                                        v17 = v44;
                                        switch (*(char *)(v48 - 4)) {
                                            case -6: {
                                                goto lab_0x805e25e;
                                            }
                                            case -10: {
                                                goto lab_0x805e25e;
                                            }
                                            case -3: {
                                                goto lab_0x805e25e;
                                            }
                                            default: {
                                                goto lab_0x805e23d;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // 0x805e2a2
            v32 = -1 - v31;
            v25 = v78 + v32;
            v13 = v32;
            v21 = v71;
        }
        // 0x805e568
        v76 = v21;
        result2 = v13;
        v22 = v76;
    }
  lab_0x805e572:
    // 0x805e572
    g58 = v22;
    return result2;
  lab_0x805e293:;
    int32_t v79 = v14 + 1; // 0x805e293
    v14 = v79;
    if (v79 == v31) {
        // break -> 0x805e2a2
        goto lab_0x805e2a2;
    }
    goto lab_0x805e1c1;
  lab_0x805e25e:;
    int32_t v80 = v17;
    v28 = v27;
    if ((v80 & 768) == 0) {
        // 0x805e263
        *(int32_t *)(v9 - 4) = v80 & -769 | 256;
        *(int32_t *)v27 = v9;
        int32_t v81 = v27 + 4; // 0x805e271
        v28 = v81;
        if (v81 >= g59) {
            // 0x805e27f
            g58 = v81;
            realloc_gray_vals(v81);
            v28 = g58;
        }
    }
    goto lab_0x805e293;
  lab_0x805e23d:
    // 0x805e23d
    *v33 = v48;
    v9 = v34;
    v17 = v44;
    goto lab_0x805e25e;
}

// Address range: 0x805e580 - 0x805e610
int32_t caml_darken(uint32_t result, int32_t a2) {
    // 0x805e580
    if (result % 2 != 0) {
        // 0x805e60a
        return result;
    }
    int32_t v1 = *(int32_t *)(4 * result / 0x800000 + (int32_t)&g121); // 0x805e5a0
    if (*(char *)(v1 + result / 0x1000 % 2048) % 2 == 0) {
        // 0x805e60a
        return result;
    }
    uint32_t v2 = *(int32_t *)(result - 4); // 0x805e5ad
    int32_t v3 = v2 % 256; // 0x805e5b0
    int32_t result2 = result; // 0x805e5b9
    int32_t v4 = v3; // 0x805e5b9
    uint32_t v5 = v2; // 0x805e5b9
    if (v3 == 249) {
        // 0x805e5bb
        result2 = result - 4 * v2 / 1024;
        v5 = *(int32_t *)(result2 - 4);
        v4 = v5 % 256;
    }
    // 0x805e5cf
    if ((v5 & 768) != 0) {
        // 0x805e60a
        return result2;
    }
    // 0x805e5d4
    if (v4 >= 251) {
        // 0x805e604
        *(int32_t *)(result2 - 4) = v5 | 768;
        // 0x805e60a
        return result2;
    }
    // 0x805e5dc
    *(int32_t *)(result2 - 4) = v5 & -769 | 256;
    *(int32_t *)g58 = result2;
    int32_t v6 = g58 + 4; // 0x805e5ed
    g58 = v6;
    int32_t result3 = v6; // 0x805e5fb
    if (v6 >= g59) {
        // 0x805e5fd
        int32_t v7; // 0x805e580
        result3 = realloc_gray_vals(v7);
    }
    // 0x805e60a
    return result3;
}

// Address range: 0x805e610 - 0x805e6f1
int32_t sweep_slice(void) {
    // 0x805e610
    int32_t v1; // 0x805e610
    int32_t result = caml_gc_message(64, "Sweeping %ld words\n", v1); // 0x805e635
    if (v1 < 1) {
        // 0x805e6e9
        return result;
    }
    uint32_t v2 = g111; // 0x805e63b
    int32_t result2; // 0x805e610
    int32_t v3; // 0x805e610
    int32_t v4; // 0x805e610
    uint32_t v5; // 0x805e64f
    int32_t v6; // 0x805e656
    int32_t v7; // 0x805e658
    int32_t v8; // 0x805e664
    int32_t v9; // 0x805e6d9
    int32_t v10; // 0x805e692
    int32_t v11; // 0x805e6a9
    int32_t v12; // 0x805e6b5
    int32_t * v13; // 0x805e64b
    uint32_t v14; // 0x805e64b
    if (v2 >= g64) {
        // 0x805e6b0
        v12 = *(int32_t *)(g63 - 4);
        g63 = v12;
        if (v12 == 0) {
            // break -> 0x805e6c1
            break;
        }
        // 0x805e6d4
        g111 = v12;
        v9 = *(int32_t *)(v12 - 8) + v12;
        g64 = v9;
        result2 = v9;
        v4 = v3;
    } else {
        // 0x805e649
        v13 = (int32_t *)v2;
        v14 = *v13;
        v5 = v14 / 1024;
        v6 = v3 + -1 - v5;
        v7 = v2 + 4;
        g111 = 4 * v5 + v7;
        v8 = v14 & 768;
        if (v8 == 0) {
            // 0x805e676
            v10 = caml_fl_merge_block(v7);
            g111 = v10;
            result2 = v10;
            v4 = v6;
        } else {
            if (v8 != 512) {
                // 0x805e6a9
                v11 = v14 & -769;
                *v13 = v11;
                result2 = v11;
                v4 = v6;
            } else {
                // 0x805e69e
                *(int32_t *)&g18 = v7;
                result2 = v14;
                v4 = v6;
            }
        }
    }
    // 0x805e6e1
    while (v4 >= 0 == (v4 != 0)) {
        int32_t v15 = v4;
        v2 = g111;
        if (v2 >= g64) {
            // 0x805e6b0
            v12 = *(int32_t *)(g63 - 4);
            g63 = v12;
            if (v12 == 0) {
                // break -> 0x805e6c1
                break;
            }
            // 0x805e6d4
            g111 = v12;
            v9 = *(int32_t *)(v12 - 8) + v12;
            g64 = v9;
            result2 = v9;
            v4 = v15;
        } else {
            // 0x805e649
            v13 = (int32_t *)v2;
            v14 = *v13;
            v5 = v14 / 1024;
            v6 = v15 + -1 - v5;
            v7 = v2 + 4;
            g111 = 4 * v5 + v7;
            v8 = v14 & 768;
            if (v8 == 0) {
                // 0x805e676
                v10 = caml_fl_merge_block(v7);
                g111 = v10;
                result2 = v10;
                v4 = v6;
            } else {
                if (v8 != 512) {
                    // 0x805e6a9
                    v11 = v14 & -769;
                    *v13 = v11;
                    result2 = v11;
                    v4 = v6;
                } else {
                    // 0x805e69e
                    *(int32_t *)&g18 = v7;
                    result2 = v14;
                    v4 = v6;
                }
            }
        }
    }
    // 0x805e6e9
    return result2;
}

// Address range: 0x805e6f1 - 0x805e768
int32_t caml_finish_major_cycle(void) {
    int32_t v1 = g115; // 0x805e6fe
    if (g115 == 2) {
        // 0x805e700
        int32_t v2; // 0x805e6f1
        start_cycle(v2);
        v1 = g115;
    }
    int32_t v3 = v1; // 0x805e70c
    if (v1 == 0) {
        mark_slice();
        v3 = g115;
        while (g115 == 0) {
            // 0x805e70e
            mark_slice();
            v3 = g115;
        }
    }
    // 0x805e721
    if (v3 == 1) {
        sweep_slice();
        while (g115 == 1) {
            // 0x805e72a
            sweep_slice();
        }
    }
    int32_t result = g117; // 0x805e73d
    g82 = (float80_t)result + (float80_t)g82;
    g117 = 0;
    return result;
}

// Address range: 0x805e768 - 0x805ea3b
int32_t caml_major_collection_slice(int32_t a1) {
    // 0x805e768
    if (g115 == 2) {
        // 0x805e77d
        int32_t v1; // 0x805e768
        start_cycle(v1);
    }
    int32_t v2 = g112; // 0x805e787
    float80_t v3 = v2 + 100; // 0x805e79b
    float80_t v4 = v2; // 0x805e7a9
    int32_t v5 = g113; // 0x805e7e6
    float80_t v6 = 0.0L; // 0x805e7ee
    if (v5 != 0) {
        // 0x805e7f8
        v6 = v3 * (float80_t)(0x100000000 * g119 / 0x100000000) / (float80_t)v5 / v4;
    }
    int32_t v7 = g117; // 0x805e782
    float80_t v8 = 0.5L * 3.0L * (float80_t)v7 * v3 / (float80_t)(g85 / 4) / v4; // 0x805e7dd
    bool v9 = false; // 0x805e825
    bool v10 = false; // 0x805e825
    if (v6 <= v8) {
        v9 = true;
        v10 = false;
        if (v6 >= v8) {
            v9 = v6 != v8;
            v10 = true;
        }
    }
    float80_t v11 = v9 | v10 ? v8 : v6; // 0x805e827
    float80_t v12 = g116; // 0x805e82b
    bool v13 = false; // 0x805e831
    bool v14 = false; // 0x805e831
    if (v11 >= v12) {
        v13 = true;
        v14 = false;
        if (v11 <= v12) {
            v13 = v11 != v12;
            v14 = true;
        }
    }
    float80_t v15 = v13 | v14 ? v11 : v12; // 0x805e833
    caml_gc_message(64, "allocated_words = %lu\n", v7);
    caml_gc_message(64, "extra_heap_resources = %luu\n", (int32_t)(int64_t)(1.0e+6L * (float80_t)g116));
    caml_gc_message(64, "amount of work to do = %luu\n", (int32_t)(int64_t)(1.0e+6L * v15));
    float80_t v16 = v15 * (float80_t)(g85 / 4);
    float80_t v17; // 0x805e768
    if (g115 != 0) {
        // 0x805e924
        v17 = 5.0L * v16 / 3.0L;
    } else {
        // 0x805e8d2
        v17 = 250.0L * v16 / (float80_t)((int32_t)g112 + 100);
    }
    int32_t result = v17;
    caml_gc_message(64, "ordered work = %ld words\n", a1);
    caml_gc_message(64, "computed work = %ld words\n", result);
    if (g115 != 0) {
        // 0x805e9c5
        sweep_slice();
        caml_gc_message(2, "$", 0);
    } else {
        // 0x805e9a0
        mark_slice();
        caml_gc_message(2, "!", 0);
    }
    // 0x805e9e8
    if (g115 == 2) {
        // 0x805e9f1
        caml_compact_heap_maybe();
    }
    // 0x805e9f6
    g82 = (float80_t)g82 + (float80_t)(0x100000000 * g117 / 0x100000000);
    g117 = 0;
    g119 = 0;
    g116 = 0.0;
    return result;
}

// Address range: 0x805ea3c - 0x805ea4c
int32_t clear_table(void) {
    // 0x805ea3c
    int32_t v1; // 0x805ea3c
    int32_t result = v1;
    *(int32_t *)(result + 16) = *(int32_t *)(result + 8);
    return result;
}

// Address range: 0x805ea4c - 0x805ebdb
int32_t caml_oldify_one(uint32_t a1, int32_t a2) {
    int32_t v1 = a2; // 0x805ea5e
    int32_t v2 = a1; // 0x805ea5e
    int32_t v3; // 0x805ea4c
    int32_t result2; // 0x805ea4c
    int32_t v4; // 0x805ea4c
    int32_t result; // 0x805ea4c
    int32_t v5; // 0x805ea4c
    int32_t v6; // 0x805ea4c
    int32_t v7; // 0x805ea4c
    int32_t v8; // 0x805ea4c
    int32_t v9; // 0x805ea4c
    int32_t v10; // 0x805ea4c
    uint32_t v11; // 0x805eae8
    int32_t v12; // 0x805eaf5
    int32_t * v13; // 0x805ea4c
    uint32_t v14; // 0x805eb55
    int32_t v15; // 0x805ea4c
    int32_t * v16; // 0x805ea4c
    if (a1 % 2 == 0) {
        // 0x805ea64
        v6 = a1;
        v8 = a2;
        v1 = a2;
        v2 = a1;
        if (g67 > a1 == g66 < a1) {
            while (true) {
              lab_0x805ea7c_2:
                // 0x805ea7c
                v9 = v8;
                int32_t v17 = v6; // 0x805ea4c
                uint32_t v18; // 0x805ea84
                uint32_t v19; // 0x805ea93
                while (true) {
                  lab_0x805ea7c:
                    // 0x805ea7c
                    v5 = v17;
                    v16 = (int32_t *)(v5 - 4);
                    v18 = *v16;
                    if (v18 == 0) {
                        // break (via goto) -> 0x805ea8a
                        goto lab_0x805ea8a;
                    }
                    // 0x805ea93
                    v19 = v18 % 256;
                    if (v19 < 249) {
                        // break -> 0x805ea9d
                        break;
                    }
                    if (v19 >= 251) {
                        // 0x805eae8
                        v11 = v18 / 1024;
                        v12 = caml_alloc_shr(v11, v19);
                        v10 = 0;
                        if (v18 < 1024) {
                            goto lab_0x805eb1b;
                        } else {
                            goto lab_0x805eb0b;
                        }
                    }
                    if (v19 == 249) {
                        int32_t v20 = 4 * v18 / 1024; // 0x805eb37
                        int32_t v21 = caml_oldify_one(v5 - v20, v9); // 0x805eb47
                        int32_t * v22 = (int32_t *)v9; // 0x805eb4c
                        *v22 = *v22 + v20;
                        result = v21;
                        return result;
                    }
                    // 0x805eb53
                    v13 = (int32_t *)v5;
                    v14 = *v13;
                    v15 = v14 % 2;
                    v1 = v9;
                    result2 = v19;
                    v2 = v14;
                    if (v15 != 0) {
                        goto lab_0x805ebd1_3;
                    }
                    int32_t v23 = *(int32_t *)(4 * v14 / 0x800000 + (int32_t)&g121); // 0x805eb71
                    if (*(char *)(v23 + v14 / 0x1000 % 2048) % 8 == 0) {
                        goto lab_0x805eba9_2;
                    }
                    int32_t v24 = v14 - 4; // 0x805eb7e
                    int32_t v25 = v24; // 0x805eb86
                    if (*(int32_t *)v24 == 0) {
                        // 0x805eb88
                        v25 = *(int32_t *)v14 - 4;
                    }
                    unsigned char v26 = *(char *)v25; // 0x805eb8d
                    switch (v26) {
                        case -6: {
                            goto lab_0x805eba9_2;
                        }
                        case -10: {
                            goto lab_0x805eba9_2;
                        }
                        default: {
                            if (v26 == -3) {
                                goto lab_0x805eba9_2;
                            }
                            // 0x805ea64
                            v17 = v14;
                            if (v14 < g67 != v14 > g66) {
                                // 0x805ea64
                                v1 = v9;
                                result2 = v26;
                                v2 = v14;
                                goto lab_0x805ebd1_3;
                            }
                            goto lab_0x805ea7c;
                        }
                    }
                }
                int32_t v27 = caml_alloc_shr(v18 / 1024, v19); // 0x805eaa9
                *(int32_t *)v9 = v27;
                int32_t * v28 = (int32_t *)v5; // 0x805eab0
                uint32_t v29 = *v28; // 0x805eab0
                *v16 = 0;
                *v28 = v27;
                if (v18 >= 2048) {
                    // 0x805eac2
                    *(int32_t *)v27 = v29;
                    *(int32_t *)(v27 + 4) = g75;
                    g75 = v5;
                    result = v27;
                    return result;
                }
                // 0x805ea9d
                v3 = v29 % 2;
                v4 = v27;
                v7 = v29;
                goto lab_0x805ea5b;
            }
          lab_0x805ea8a:;
            int32_t v30 = *(int32_t *)v5; // 0x805ea8a
            *(int32_t *)v9 = v30;
            result = v30;
          lab_0x805ebd3:
            // 0x805ebd3
            return result;
        }
    }
    goto lab_0x805ebd1_3;
  lab_0x805ebd1_3:
    // 0x805ebd1
    *(int32_t *)v1 = v2;
    // 0x805ebd3
    return result2;
  lab_0x805eba9_2:;
    int32_t v31 = caml_alloc_shr(1, 250); // 0x805ebb8
    *(int32_t *)v9 = v31;
    *v16 = 0;
    *v13 = v31;
    v3 = v15;
    v4 = v31;
    v7 = v14;
    goto lab_0x805ea5b;
  lab_0x805ea5b:;
    int32_t v32 = v7;
    v1 = v4;
    result2 = v4;
    v2 = v32;
    if (v3 != 0) {
        goto lab_0x805ebd1_3;
    }
    // 0x805ea64
    v6 = v32;
    v8 = v4;
    v1 = v4;
    result2 = v4;
    v2 = v32;
    if (v32 < g67 != v32 > g66) {
        goto lab_0x805ebd1_3;
    }
    goto lab_0x805ea7c_2;
  lab_0x805eb1b:
    // 0x805eb1b
    *v16 = 0;
    *(int32_t *)v5 = v12;
    *(int32_t *)v9 = v12;
    result = v12;
    goto lab_0x805ebd3;
  lab_0x805eb0b:;
    int32_t v33 = 4 * v10; // 0x805eb0b
    *(int32_t *)(v33 + v12) = *(int32_t *)(v33 + v5);
    int32_t v34 = v10 + 1; // 0x805eb11
    v10 = v34;
    if (v34 == v11) {
        goto lab_0x805eb1b;
    } else {
        goto lab_0x805eb0b;
    }
}

// Address range: 0x805ebdb - 0x805ec79
int32_t caml_oldify_mopup(void) {
    // 0x805ebdb
    int32_t result; // 0x805ebdb
    if (g75 == 0) {
        // 0x805ec71
        return result;
    }
    int32_t v1; // 0x805ebdb
    int32_t v2; // 0x805ebdb
    int32_t v3; // 0x805ebdb
    int32_t v4; // 0x805ebdb
    int32_t * v5; // 0x805ec17
    while (true) {
        int32_t v6 = g75;
        int32_t v7 = *(int32_t *)v6; // 0x805ebe6
        int32_t v8 = v7 + 4; // 0x805ebe8
        g75 = *(int32_t *)v8;
        uint32_t v9 = *(int32_t *)v7; // 0x805ebf2
        if (v9 % 2 == 0) {
            // 0x805ebf8
            if (v9 < g67 == v9 > g66) {
                // 0x805ec08
                caml_oldify_one(v9, v7);
            }
        }
        // 0x805ec14
        v5 = (int32_t *)(v7 - 4);
        uint32_t v10 = *v5; // 0x805ec17
        v1 = v10 / 1024;
        v4 = 1;
        v2 = v8;
        if (v10 >= 2048) {
            while (true) {
              lab_0x805ec28:
                // 0x805ec28
                v3 = v2;
                uint32_t v11 = *(int32_t *)(4 * v4 + v6); // 0x805ec2b
                if (v11 % 2 != 0) {
                    // 0x805ec50
                    *(int32_t *)v3 = v11;
                    goto lab_0x805ec52;
                } else {
                    // 0x805ec32
                    if (v11 < g67 == v11 > g66) {
                        // 0x805ec42
                        caml_oldify_one(v11, v3);
                        goto lab_0x805ec52;
                    } else {
                        // 0x805ec50
                        *(int32_t *)v3 = v11;
                        goto lab_0x805ec52;
                    }
                }
            }
        }
      lab_0x805ec63:
        // 0x805ec63
        result = v1;
        if (g75 == 0) {
            // break -> 0x805ec71
            break;
        }
    }
    // 0x805ec71
    return result;
  lab_0x805ec52:;
    int32_t v12 = v4 + 1; // 0x805ec52
    uint32_t v13 = *v5 / 1024; // 0x805ec5b
    v1 = v13;
    v4 = v12;
    v2 = v3 + 4;
    if (v13 <= v12) {
        // break -> 0x805ec63
        goto lab_0x805ec63;
    }
    goto lab_0x805ec28;
}

// Address range: 0x805ec79 - 0x805edc3
int32_t caml_empty_minor_heap(void) {
    // 0x805ec79
    if (g68 == g67) {
        // 0x805edb7
        return caml_final_empty_young();
    }
    // 0x805ec92
    g74 = 1;
    caml_gc_message(2, "<", 0);
    caml_oldify_local_roots();
    int32_t v1 = g70; // 0x805ecc9
    if (g70 < g71) {
        int32_t v2 = *(int32_t *)v1; // 0x805ecd0
        caml_oldify_one(*(int32_t *)v2, v2);
        v1 += 4;
        while (g71 > v1) {
            // 0x805ecd0
            v2 = *(int32_t *)v1;
            caml_oldify_one(*(int32_t *)v2, v2);
            v1 += 4;
        }
    }
    // 0x805ece7
    caml_oldify_mopup();
    int32_t v3 = g72; // 0x805ecf7
    if (g72 < g73) {
        int32_t * v4 = (int32_t *)*(int32_t *)v3; // 0x805ed00
        uint32_t v5 = *v4; // 0x805ed00
        if (v5 % 2 == 0) {
            // 0x805ed07
            if (v5 < g67 == v5 > g66) {
                // 0x805ed17
                if (*(int32_t *)(v5 - 4) != 0) {
                    // 0x805ed23
                    *v4 = (int32_t)g24;
                } else {
                    // 0x805ed1d
                    *v4 = *(int32_t *)v5;
                }
            }
        }
        // 0x805ed2b
        v3 += 4;
        while (g73 > v3) {
            // 0x805ecfe
            v4 = (int32_t *)*(int32_t *)v3;
            v5 = *v4;
            if (v5 % 2 == 0) {
                // 0x805ed07
                if (v5 < g67 == v5 > g66) {
                    // 0x805ed17
                    if (*(int32_t *)(v5 - 4) != 0) {
                        // 0x805ed23
                        *v4 = (int32_t)g24;
                    } else {
                        // 0x805ed1d
                        *v4 = *(int32_t *)v5;
                    }
                }
            }
            // 0x805ed2b
            v3 += 4;
        }
    }
    int32_t v6 = g66;
    uint32_t v7 = g68;
    int32_t v8 = v7 < v6 ? v6 : v7; // 0x805ed43
    g80 = (float80_t)g80 + (float80_t)((g67 - v8) / 4);
    g68 = g67;
    g69 = v6;
    clear_table();
    clear_table();
    caml_gc_message(2, ">", 0);
    g74 = 0;
    // 0x805edb7
    return caml_final_empty_young();
}

// Address range: 0x805edc3 - 0x805ee2c
int32_t caml_minor_collection(void) {
    // 0x805edc3
    caml_empty_minor_heap();
    g81 = (float80_t)g81 + (float80_t)0;
    g83++;
    caml_major_collection_slice(0);
    g42 = 0;
    caml_final_do_calls();
    return caml_empty_minor_heap();
}

// Address range: 0x805ee75 - 0x805eec2
int32_t reset_table(void) {
    // 0x805ee75
    int32_t v1; // 0x805ee75
    *(int32_t *)(v1 + 20) = 0;
    *(int32_t *)(v1 + 24) = 0;
    int32_t result = 0; // 0x805ee90
    if (v1 != 0) {
        // 0x805ee92
        result = caml_stat_free(v1);
    }
    // 0x805ee9a
    *(int32_t *)(v1 + 4) = 0;
    *(int32_t *)(v1 + 16) = 0;
    *(int32_t *)(v1 + 8) = 0;
    *(int32_t *)(v1 + 12) = 0;
    *(int32_t *)v1 = 0;
    return result;
}

// Address range: 0x805eec2 - 0x805ef94
int32_t caml_set_minor_heap_size(int32_t a1) {
    // 0x805eec2
    if (g68 != g67) {
        // 0x805eedb
        caml_minor_collection();
    }
    // 0x805eee0
    int32_t v1; // bp-32, 0x805eec2
    int32_t v2 = caml_aligned_malloc(a1, 0, &v1); // 0x805eef2
    int32_t v3 = v2; // 0x805eefb
    if (v2 == 0) {
        // 0x805eefd
        v3 = caml_raise_out_of_memory();
    }
    int32_t v4 = v3 + a1; // 0x805ef02
    if (caml_page_table_add(2, (int32_t *)v3, (int32_t *)v4) != 0) {
        // 0x805ef1d
        caml_raise_out_of_memory();
    }
    int32_t v5 = g66; // 0x805ef22
    if (v5 != 0) {
        // 0x805ef2b
        caml_page_table_remove(2, v5, g67);
        free((int32_t *)g76);
    }
    // 0x805ef52
    g76 = v1;
    g66 = v2;
    g67 = v4;
    g69 = v2;
    g68 = v4;
    g120 = a1;
    reset_table();
    return reset_table();
}

// Address range: 0x805f0f0 - 0x805f114
int32_t caml_page_table_initialize(int32_t a1) {
    int32_t v1 = 0;
    *(int32_t *)(4 * v1 + (int32_t)&g121) = (int32_t)&g77;
    int32_t v2 = v1 + 1; // 0x805f104
    while (v1 != 511) {
        // 0x805f0fd
        v1 = v2;
        *(int32_t *)(4 * v1 + (int32_t)&g121) = (int32_t)&g77;
        v2 = v1 + 1;
    }
    // 0x805f10e
    return v2 & -0x10000;
}

// Address range: 0x805f17e - 0x805f1a1
int32_t caml_stat_resize(int32_t a1, int32_t a2) {
    int32_t * mem = realloc((int32_t *)a1, a2); // 0x805f191
    int32_t result = (int32_t)mem; // 0x805f198
    if (mem == NULL) {
        // 0x805f19a
        result = caml_raise_out_of_memory();
    }
    // 0x805f19f
    return result;
}

// Address range: 0x805f1a1 - 0x805f1b4
int32_t caml_stat_free(int32_t a1) {
    // 0x805f1a1
    free((int32_t *)a1);
    return &g125;
}

// Address range: 0x805f1b4 - 0x805f1ca
int32_t caml_free_for_heap(int32_t a1) {
    // 0x805f1b4
    free((int32_t *)*(int32_t *)(a1 - 16));
    return &g125;
}

// Address range: 0x805f1ca - 0x805f1ef
int32_t caml_stat_alloc(int32_t size) {
    int32_t * mem = malloc(size); // 0x805f1d7
    int32_t result = (int32_t)mem; // 0x805f1de
    if (size != 0 && mem == NULL) {
        // 0x805f1e4
        result = caml_raise_out_of_memory();
    }
    // 0x805f1e9
    return result;
}

// Address range: 0x805f3ab - 0x805f3e7
int32_t caml_alloc_for_heap(int32_t a1) {
    // 0x805f3ab
    int32_t v1; // bp-16, 0x805f3ab
    int32_t v2 = caml_aligned_malloc(a1 + 16, 16, &v1); // 0x805f3ca
    int32_t result = 0; // 0x805f3d1
    if (v2 != 0) {
        // 0x805f3d3
        *(int32_t *)(v2 + 8) = a1;
        *(int32_t *)v2 = v1;
        result = v2 + 16;
    }
    // 0x805f3e1
    return result;
}

// Address range: 0x805f3e7 - 0x805f462
int32_t caml_page_table_modify(void) {
    // 0x805f3e7
    int32_t v1; // 0x805f3e7
    int32_t * v2 = (int32_t *)(4 * v1 / 0x800000 + (int32_t)&g121); // 0x805f402
    int32_t v3 = *v2; // 0x805f402
    int32_t v4 = v3; // 0x805f40d
    if (v3 == (int32_t)&g77) {
        int32_t * mem = calloc(2048, 1); // 0x805f41e
        if (mem == NULL) {
            // 0x805f455
            return -1;
        }
        // 0x805f42e
        v4 = (int32_t)mem;
        *v2 = v4;
    }
    char * v5 = (char *)(v4 + v1 / 0x1000 % 2048); // 0x805f449
    *v5 = *v5 & -1 - (char)v1 | (char)v1;
    // 0x805f455
    return 0;
}

// Address range: 0x805f462 - 0x805f4b7
int32_t caml_page_table_remove(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a2 & -0x1000; // 0x805f471
    uint32_t v2 = a3 - 1 & -0x1000; // 0x805f47d
    if (v1 > v2) {
        // 0x805f4af
        return 0;
    }
    int32_t v3 = v1; // 0x805f485
    int32_t result = -1; // 0x805f497
    while (caml_page_table_modify() == 0) {
        // 0x805f4a0
        v3 += 0x1000;
        result = 0;
        if (v2 < v3) {
            // break -> 0x805f4af
            break;
        }
        result = -1;
    }
    // 0x805f4af
    return result;
}

// Address range: 0x805f4b7 - 0x805f541
int32_t caml_shrink_heap(int32_t a1) {
    // 0x805f4b7
    if (g114 == a1) {
        // 0x805f53a
        int32_t result; // 0x805f4b7
        return result;
    }
    int32_t * v1 = (int32_t *)(a1 - 8); // 0x805f4d2
    int32_t v2 = g85 - *v1; // 0x805f4d2
    g85 = v2;
    caml_gc_message(4, "Shrinking heap to %luk bytes\n", v2 / 1024);
    g88--;
    int32_t v3 = &g114; // 0x805f508
    if (g114 != a1) {
        int32_t v4 = g114 - 4; // 0x805f50a
        int32_t v5 = *(int32_t *)v4; // 0x805f50d
        v3 = v4;
        while (v5 != a1) {
            // 0x805f50a
            v4 = v5 - 4;
            v5 = *(int32_t *)v4;
            v3 = v4;
        }
    }
    // 0x805f514
    *(int32_t *)v3 = *(int32_t *)(a1 - 4);
    caml_page_table_remove(1, a1, *v1 + a1);
    // 0x805f53a
    return caml_free_for_heap(a1);
}

// Address range: 0x805f541 - 0x805f596
int32_t caml_page_table_add(int32_t a1, int32_t * a2, int32_t * a3) {
    int32_t v1 = (int32_t)a2 & -0x1000; // 0x805f550
    uint32_t v2 = (int32_t)a3 - 1 & -0x1000; // 0x805f55c
    if (v1 > v2) {
        // 0x805f58e
        return 0;
    }
    int32_t v3 = v1; // 0x805f564
    int32_t result = -1; // 0x805f576
    while (caml_page_table_modify() == 0) {
        // 0x805f57f
        v3 += 0x1000;
        result = 0;
        if (v2 < v3) {
            // break -> 0x805f58e
            break;
        }
        result = -1;
    }
    // 0x805f58e
    return result;
}

// Address range: 0x805f596 - 0x805f642
int32_t caml_add_to_heap(uint32_t a1) {
    int32_t * v1 = (int32_t *)(a1 - 8); // 0x805f5a9
    caml_gc_message(4, "Growing heap to %luk bytes\n", (*v1 + g85) / 1024);
    if (caml_page_table_add(1, (int32_t *)a1, (int32_t *)(*v1 + a1)) != 0) {
        // 0x805f63b
        return -1;
    }
    int32_t v2 = g114; // 0x805f5eb
    int32_t v3 = v2; // 0x805f5f2
    int32_t v4 = &g114; // 0x805f5f2
    if (v2 != 0 == v2 < a1) {
        int32_t v5 = v2 - 4; // 0x805f5ff
        int32_t v6 = *(int32_t *)v5; // 0x805f602
        v3 = v6;
        v4 = v5;
        while (v6 != 0 == v6 < a1) {
            // 0x805f5ff
            v5 = v6 - 4;
            v6 = *(int32_t *)v5;
            v3 = v6;
            v4 = v5;
        }
    }
    // 0x805f60d
    *(int32_t *)(a1 - 4) = v3;
    *(int32_t *)v4 = a1;
    g88++;
    int32_t v7 = *v1 + g85; // 0x805f61f
    g85 = v7;
    if (v7 > g86) {
        // 0x805f635
        g86 = v7;
    }
    // 0x805f63b
    return 0;
}

// Address range: 0x805f642 - 0x805f7e1
int32_t caml_alloc_shr(uint32_t a1, int32_t a2) {
    if (a1 >= 0x400000) {
        // 0x805f65c
        caml_raise_out_of_memory();
    }
    int32_t v1 = caml_fl_allocate(a1); // 0x805f664
    int32_t v2 = v1; // 0x805f66d
    int32_t v3; // 0x805f642
    int32_t v4; // 0x805f642
    if (v1 != 0) {
        goto lab_0x805f77e;
    } else {
        int32_t v5 = caml_round_heap_chunk_size(4 * (a1 + 1 + (int32_t)(0x100000000 * g112 / 0x100000000 * 0x51eb851f * (int64_t)a1 / 0x2000000000))); // 0x805f690
        int32_t v6 = caml_alloc_for_heap(v5); // 0x805f69a
        if (v6 == 0) {
            // 0x805f6b9
            caml_gc_message(4, "No room for growing heap\n", 0);
            v3 = 0;
            goto lab_0x805f752;
        } else {
            int32_t v7 = v5 / 4 - 1; // 0x805f6aa
            int32_t v8 = v6; // 0x805f6b5
            int32_t v9 = v7; // 0x805f6b5
            int32_t v10 = v5; // 0x805f6b5
            if (v7 >= 0x400000) {
                int32_t v11 = v5; // 0x805f6e4
                *(int32_t *)v6 = -512;
                int32_t v12 = v6 + 0x1000000; // 0x805f6df
                v11 -= 0x1000000;
                int32_t v13 = v6 + 0x1000004; // 0x805f6ea
                *(int32_t *)(v6 + 4) = v13;
                *(int32_t *)(v6 + 8) = v13;
                int32_t v14 = v11 / 4 - 1; // 0x805f6f8
                v8 = v12;
                v9 = v14;
                v10 = v11;
                while (v14 >= 0x400000) {
                    int32_t v15 = v12;
                    *(int32_t *)v15 = -512;
                    v12 = v15 + 0x1000000;
                    v11 -= 0x1000000;
                    v13 = v15 + 0x1000004;
                    *(int32_t *)(v15 + 4) = v13;
                    *(int32_t *)(v6 + 8) = v13;
                    v14 = v11 / 4 - 1;
                    v8 = v12;
                    v9 = v14;
                    v10 = v11;
                }
            }
            // 0x805f705
            if (v10 < 2) {
                // 0x805f723
                *(int32_t *)(v8 + 4) = 0;
                if (v10 == 1) {
                    // 0x805f72f
                    *(int32_t *)v8 = 0;
                }
            } else {
                // 0x805f70a
                *(int32_t *)v8 = 1024 * v9 | 512;
                int32_t v16 = v8 + 4; // 0x805f715
                *(int32_t *)(v6 + 8) = v16;
                *(int32_t *)v16 = 0;
            }
            // 0x805f735
            if (caml_add_to_heap(v6) == 0) {
                int32_t v17 = v6 + 4; // 0x805f74b
                v3 = v17;
                v4 = v17;
                if (v17 != 0) {
                    goto lab_0x805f76c;
                } else {
                    goto lab_0x805f752;
                }
            } else {
                // 0x805f741
                caml_free_for_heap(v6);
                v3 = v6;
                goto lab_0x805f752;
            }
        }
    }
  lab_0x805f77e:
    // 0x805f77e
    if (g115 == 0) {
        // 0x805f794
        *(int32_t *)v2 = a2 + 768 + 1024 * a1;
        goto lab_0x805f7b1;
    } else {
        // 0x805f787
        if (g115 != 1 || v2 < g111) {
            // 0x805f7a7
            *(int32_t *)v2 = 1024 * a1 + a2;
            goto lab_0x805f7b1;
        } else {
            // 0x805f794
            *(int32_t *)v2 = a2 + 768 + 1024 * a1;
            goto lab_0x805f7b1;
        }
    }
  lab_0x805f7b1:;
    int32_t v18 = a1 + 1 + (int32_t)g117; // 0x805f7b6
    g117 = v18;
    if (v18 > g120 / 4) {
        // 0x805f7cc
        caml_urge_major_slice();
    }
    // 0x805f7d1
    return v2 + 4;
  lab_0x805f752:
    // 0x805f752
    if (g74 != 0) {
        // 0x805f75b
        caml_fatal_error("Fatal error: out of memory.\n");
        // UNREACHABLE
    }
    // 0x805f767
    caml_raise_out_of_memory();
    v4 = v3;
    goto lab_0x805f76c;
  lab_0x805f76c:
    // 0x805f76c
    caml_fl_add_blocks(v4);
    v2 = caml_fl_allocate(a1);
    goto lab_0x805f77e;
}

// Address range: 0x8061757 - 0x806175c
int32_t caml_init_ieee_floats(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x8061757
    int32_t result; // 0x8061757
    return result;
}

// Address range: 0x8065f50 - 0x8065f65
int32_t caml_sys_init(int32_t a1, int32_t result) {
    // 0x8065f50
    g122 = a1;
    g78 = result;
    return result;
}

// Address range: 0x8066188 - 0x806619b
int32_t caml_sys_exit(int32_t a1) {
    // 0x8066188
    exit(a1 / 2);
    return &g125;
}

// Address range: 0x8066cf0 - 0x8066cff
int32_t norm_pfree(void) {
    // 0x8066cf0
    int32_t v1; // 0x8066cf0
    int32_t v2 = v1;
    return v2 == 0 ? 1 : v2;
}

// Address range: 0x8066cff - 0x8066d04
int32_t norm_pmax(void) {
    // 0x8066cff
    int32_t result; // 0x8066cff
    return result;
}

// Address range: 0x8066d04 - 0x8066d20
int32_t norm_heapincr(void) {
    // 0x8066d04
    int32_t v1; // 0x8066d04
    uint32_t v2 = v1 + 1023 & -1024; // 0x8066d0c
    return v2 < 2047 ? 2048 : v2;
}

// Address range: 0x8066d20 - 0x8066d3f
int32_t norm_minsize(void) {
    // 0x8066d20
    int32_t v1; // 0x8066d20
    int32_t v2 = v1;
    int32_t v3 = v2 - 4095; // 0x8066d23
    int32_t v4 = v3 == 0 | v3 < 0 != (4094 - v2 & v2) < 0 ? 0x1000 : v2; // 0x8066d2d
    int32_t v5 = v4 - 0x10000000; // 0x8066d30
    return v5 < 0 == (0xfffffff - v4 & v4) < 0 == (v5 != 0) ? 0x10000000 : v4;
}

// Address range: 0x8066d3f - 0x8066e71
int32_t caml_init_gc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    uint32_t v1 = norm_heapincr(); // 0x8066d4d
    int32_t v2 = 4 * v1; // 0x8066d52
    if (caml_page_table_initialize(v2 + 4 * a1) != 0) {
        // 0x8066d68
        caml_fatal_error("OCaml runtime error: cannot initialize page table\n");
        // UNREACHABLE
    }
    // 0x8066d74
    caml_set_minor_heap_size(4 * norm_minsize());
    g118 = 4 * norm_heapincr();
    g112 = norm_pfree();
    g123 = norm_pmax();
    caml_init_major_heap(v2);
    caml_gc_message(32, "Initial minor heap size: %luk bytes\n", g120 / 1024);
    caml_gc_message(32, "Initial major heap size: %luk bytes\n", v1 / 256 % 0x400000);
    caml_gc_message(32, "Initial space overhead: %lu%%\n", (int32_t)g112);
    caml_gc_message(32, "Initial max overhead: %lu%%\n", (int32_t)g123);
    caml_gc_message(32, "Initial heap increment: %luk bytes\n", g118 / 1024);
    return caml_gc_message(32, "Initial allocation policy: %d\n", g47);
}

// Address range: 0x8068548 - 0x806855b
int32_t add_char(void) {
    // 0x8068548
    int32_t v1; // 0x8068548
    uint32_t result = v1;
    if (result < *(int32_t *)(result + 4)) {
        // 0x8068552
        *(char *)result = (char)v1;
        *(int32_t *)result = result + 1;
    }
    // 0x8068559
    return result;
}

// Address range: 0x806855b - 0x80685b2
int32_t add_string(void) {
    int32_t v1 = -1; // 0x8068578
    int32_t v2 = 0; // 0x8068578
    while (v1 != 0) {
        int32_t v3; // 0x806855b
        int32_t v4 = v3;
        v1--;
        bool v5; // 0x806855b
        v3 = v4 + (v5 ? -1 : 1);
        v2 = v1;
        if (*(char *)v4 == 0) {
            // break -> 
            break;
        }
        v2 = 0;
    }
    uint32_t v6 = -2 - v2; // 0x806857c
    int32_t v7; // 0x806855b
    uint32_t v8 = *(int32_t *)(v7 + 4); // 0x8068584
    uint32_t v9 = v8 < v6 ? v8 : v6; // 0x806858c
    int32_t dest_mem = 0; // 0x8068591
    if (v9 >= 1) {
        // 0x8068593
        dest_mem = (int32_t)memmove(NULL, (int32_t *)v7, v9);
    }
    // 0x80685a3
    *(int32_t *)v7 = dest_mem + v9;
    return dest_mem;
}

// Address range: 0x80685b2 - 0x8068759
int32_t caml_format_exception(int32_t a1) {
    // 0x80685b2
    add_string();
    int32_t * v1 = (int32_t *)(a1 - 4);
    uint32_t v2 = *v1; // 0x80685e5
    if (v2 >= 2048) {
        int32_t * v3 = v1; // 0x80685f7
        int32_t v4 = 1; // 0x80685f7
        int32_t v5 = a1; // 0x80685f7
        if ((v2 & -1024) == 2048) {
            uint32_t v6 = *(int32_t *)(a1 + 4); // 0x80685f9
            v3 = v1;
            v4 = 1;
            v5 = a1;
            if (v6 % 2 == 0) {
                int32_t v7 = v6 - 4;
                char v8 = *(char *)v7; // 0x806860e
                v3 = v8 == 0 ? (int32_t *)v7 : v1;
                v4 = v8 != 0;
                v5 = v8 == 0 ? v6 : a1;
            }
        }
        // 0x8068620
        add_char();
        if (v4 < *v3 / 1024) {
            uint32_t v9 = v4; // 0x80686ee
            uint32_t v10 = *(int32_t *)(4 * v9 + v5); // 0x8068672
            int32_t str; // bp-356, 0x80685b2
            if (v10 % 2 == 0) {
                // 0x80686a9
                add_char();
                if (*(char *)(v10 - 4) == -4) {
                    // 0x80686af
                    add_string();
                    add_char();
                }
            } else {
                // 0x806867a
                sprintf((char *)&str, "%ld", v10 / 2);
                add_string();
            }
            // 0x80686ee
            v9++;
            while (*v3 / 1024 > v9) {
                if (v4 < v9) {
                    // 0x806865c
                    add_string();
                }
                v10 = *(int32_t *)(4 * v9 + v5);
                if (v10 % 2 == 0) {
                    // 0x80686a9
                    add_char();
                    if (*(char *)(v10 - 4) == -4) {
                        // 0x80686af
                        add_string();
                        add_char();
                    }
                } else {
                    // 0x806867a
                    sprintf((char *)&str, "%ld", v10 / 2);
                    add_string();
                }
                // 0x80686ee
                v9++;
            }
        }
        // 0x80686fe
        add_char();
    }
    // 0x806870e
    int32_t v11; // bp-284, 0x80685b2
    *(char *)&v11 = 0;
    int32_t v12; // bp-28, 0x80685b2
    int32_t size = (int32_t)&v11 - (int32_t)&v12 + 257; // 0x8068722
    int32_t * mem = malloc(size); // 0x806872b
    if (mem != NULL) {
        // 0x8068736
        memmove(mem, &v11, size);
    }
    // 0x806874c
    return (int32_t)mem;
}

// Address range: 0x8068759 - 0x80687f4
int32_t caml_fatal_uncaught_exception(int32_t a1) {
    int32_t v1 = caml_format_exception(a1); // 0x806876e
    int32_t v2 = g100; // 0x8068775
    g100 = 0;
    int32_t v3 = caml_named_value((int32_t)"Pervasives.do_at_exit"); // 0x8068792
    if (v3 != 0) {
        // 0x806879b
        caml_callback_exn(*(int32_t *)v3, 1);
    }
    // 0x80687ad
    g100 = v2;
    fprintf(g26, "Fatal error: exception %s\n", (char *)v1);
    free(&((struct _IO_FILE *)v1)->e0);
    if (g100 != 0) {
        // 0x80687e3
        caml_print_exception_backtrace();
    }
    // 0x80687e8
    exit(2);
    // UNREACHABLE
}

// Address range: 0x8068800 - 0x8068840
int32_t hash_value_name(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8068800
    int32_t v1; // 0x8068800
    char v2 = v1;
    int32_t v3 = 0; // 0x806880e
    if (v2 == 0) {
        // 0x8068825
        return 0;
    }
    v3 = 19 * v3 + (int32_t)v2;
    int32_t v4; // 0x8068800
    int32_t v5 = v4 + 1; // 0x806881b
    char v6 = *(char *)v5; // 0x806881e
    while (v6 != 0) {
        // 0x8068810
        v3 = 19 * v3 + (int32_t)v6;
        v5++;
        v6 = *(char *)v5;
    }
    // 0x8068825
    return v3 % 13;
}

// Address range: 0x8068840 - 0x8068887
int32_t caml_named_value(int32_t str) {
    // 0x8068840
    int32_t v1; // 0x8068840
    int32_t v2 = hash_value_name(v1, v1, v1); // 0x806884d
    int32_t v3 = *(int32_t *)(4 * v2 + (int32_t)&g89); // 0x8068852
    if (v3 == 0) {
        // 0x8068880
        return 0;
    }
    int32_t v4 = v3; // 0x8068874
    int32_t strcmp_rc = strcmp((char *)str, (char *)(v4 + 8)); // 0x8068867
    int32_t result = v4; // 0x806886e
    while (strcmp_rc != 0) {
        // 0x8068874
        v4 += 4;
        result = 0;
        if (v4 == 0) {
            // break -> 0x8068880
            break;
        }
        strcmp_rc = strcmp((char *)str, (char *)(v4 + 8));
        result = v4;
    }
    // 0x8068880
    return result;
}

// Address range: 0x8069190 - 0x806927f
int32_t invert_pointer_at(void) {
    // 0x8069190
    int32_t v1; // 0x8069190
    uint32_t v2 = v1;
    int32_t result; // 0x8069190
    if (v2 % 4 != 0) {
        // 0x8069272
        return result;
    }
    int32_t v3 = *(int32_t *)(4 * v2 / 0x800000 + (int32_t)&g121); // 0x80691ba
    if (*(char *)(v3 + v2 / 0x1000 % 2048) % 2 == 0) {
        // 0x8069272
        return result;
    }
    int32_t * v4 = (int32_t *)(v2 - 4); // 0x80691ce
    uint32_t v5 = *v4; // 0x80691ce
    switch (v5 % 4) {
        case 1: {
            int32_t v6 = v2 - 4 * v5 / 1024; // 0x80691ff
            int32_t v7 = v6 - 4; // 0x8069203
            int32_t v8 = *(int32_t *)v7; // 0x8069209
            int32_t v9 = v7; // 0x806920e
            int32_t v10 = v8; // 0x806920e
            if (v8 % 4 == 0) {
                int32_t v11 = *(int32_t *)v8; // 0x8069212
                v9 = v8;
                v10 = v11;
                while (v11 % 4 == 0) {
                    int32_t v12 = v11;
                    v11 = *(int32_t *)v12;
                    v9 = v12;
                    v10 = v11;
                }
            }
            // 0x806921c
            if ((v10 & 1020) != 988) {
                // 0x8069244
                *(int32_t *)v2 = 4 * v10 / 1024 + v6 | 1;
                *v4 = v2 | 2;
                int32_t v13 = v5 - 1024 & -1024 | 999; // 0x806925f
                *(int32_t *)v9 = v13;
                result = v13;
            } else {
                // 0x8069226
                *(int32_t *)v2 = v10;
                *v4 = v2 | 2;
                int32_t v14 = v5 - 1024 & -1024 | 999; // 0x8069238
                *(int32_t *)v9 = v14;
                result = v14;
            }
            // 0x8069272
            return result;
        }
        case 2: {
            // 0x806926b
            *(int32_t *)v2 = v5;
            int32_t result2 = v2 | 2; // 0x806926d
            *v4 = result2;
            // 0x8069272
            return result2;
        }
    }
    // 0x80691f1
    *(int32_t *)v2 = v5;
    // 0x8069272
    return result;
}

// Address range: 0x806928c - 0x80692b5
int32_t init_compact_allocate(void) {
    int32_t v1 = g114; // 0x8069296
    if (g114 == 0) {
        int32_t result = 0; // 0x80692a9
        g92 = result;
        return result;
    }
    *(int32_t *)(v1 - 12) = 0;
    v1 -= 4;
    while (v1 != 0) {
        // 0x8069298
        *(int32_t *)(v1 - 12) = 0;
        v1 -= 4;
    }
    // 0x80692a9
    g92 = g114;
    return g114;
}

// Address range: 0x80692b5 - 0x8069330
int32_t compact_allocate(void) {
    // 0x80692b5
    int32_t v1; // 0x80692b5
    uint32_t v2 = v1;
    int32_t v3 = *(int32_t *)(g92 - 12); // 0x80692c7
    int32_t v4 = *(int32_t *)(g92 - 8) - v3;
    int32_t v5 = v4; // 0x80692cd
    int32_t v6 = v3; // 0x80692cd
    int32_t v7 = g92; // 0x80692cd
    if (v4 < 17) {
        int32_t v8 = *(int32_t *)(g92 - 4); // 0x80692cf
        v5 = v4;
        v6 = v3;
        v7 = g92;
        if (*(int32_t *)(v8 - 8) - *(int32_t *)(v8 - 12) < 17) {
            int32_t v9 = v8;
            int32_t v10 = *(int32_t *)(v9 - 4); // 0x80692e6
            while (*(int32_t *)(v10 - 8) - *(int32_t *)(v10 - 12) < 17) {
                // 0x80692e6
                v9 = v10;
                v10 = *(int32_t *)(v9 - 4);
            }
            // 0x80692f7
            g92 = v9;
            int32_t v11 = *(int32_t *)(v9 - 12);
            v5 = *(int32_t *)(v9 - 8) - v11;
            v6 = v11;
            v7 = v9;
        }
    }
    int32_t v12 = v7 - 16; // 0x80692fd
    if (v2 <= v5) {
        // 0x806931e
        *(int32_t *)(v12 + 4) = v6 + v2;
        return v6 + v7;
    }
    int32_t v13 = *(int32_t *)(v12 + 12); // 0x806930c
    int32_t v14 = v13 - 16; // 0x806930f
    int32_t v15 = *(int32_t *)(v13 - 12); // 0x8069312
    int32_t v16 = v15; // 0x806931c
    while (*(int32_t *)(v13 - 8) - v15 < v2) {
        // 0x806930c
        v13 = *(int32_t *)(v14 + 12);
        v14 = v13 - 16;
        v15 = *(int32_t *)(v13 - 12);
        v16 = v15;
    }
    // 0x806931e
    *(int32_t *)(v14 + 4) = v16 + v2;
    return v16 + v13;
}

// Address range: 0x8069330 - 0x80697c5
int32_t caml_compact_heap(void) {
    // 0x8069330
    caml_gc_message(16, "Compacting heap...\n", 0);
    if (g114 != 0) {
        int32_t v1 = g114;
        uint32_t v2 = *(int32_t *)(v1 - 8) + v1; // 0x8069363
        int32_t v3 = v1; // 0x8069368
        int32_t v4; // 0x8069330
        int32_t v5; // 0x8069330
        int32_t v6; // 0x80693a5
        int32_t * v7; // 0x806936a
        uint32_t v8; // 0x806936a
        if (v2 > v1) {
            v7 = (int32_t *)v3;
            v8 = *v7;
            v5 = v8 & -1024;
            if ((v8 & 768) != 512) {
                // 0x8069390
                v4 = v5 | 4 * v8 & 1020 | 3;
            } else {
                // 0x8069381
                v4 = v5 | 1011;
            }
            // 0x80693a5
            *v7 = v4;
            v6 = v3 + 4 + 4 * v8 / 1024;
            v3 = v6;
            while (v2 > v6) {
                // 0x806936a
                v7 = (int32_t *)v3;
                v8 = *v7;
                v5 = v8 & -1024;
                if ((v8 & 768) != 512) {
                    // 0x8069390
                    v4 = v5 | 4 * v8 & 1020 | 3;
                } else {
                    // 0x8069381
                    v4 = v5 | 1011;
                }
                // 0x80693a5
                *v7 = v4;
                v6 = v3 + 4 + 4 * v8 / 1024;
                v3 = v6;
            }
        }
        int32_t v9 = *(int32_t *)(v1 - 4); // 0x80693ad
        while (v9 != 0) {
            // 0x806935e
            v1 = v9;
            v2 = *(int32_t *)(v1 - 8) + v1;
            v3 = v1;
            if (v2 > v1) {
                v7 = (int32_t *)v3;
                v8 = *v7;
                v5 = v8 & -1024;
                if ((v8 & 768) != 512) {
                    // 0x8069390
                    v4 = v5 | 4 * v8 & 1020 | 3;
                } else {
                    // 0x8069381
                    v4 = v5 | 1011;
                }
                // 0x80693a5
                *v7 = v4;
                v6 = v3 + 4 + 4 * v8 / 1024;
                v3 = v6;
                while (v2 > v6) {
                    // 0x806936a
                    v7 = (int32_t *)v3;
                    v8 = *v7;
                    v5 = v8 & -1024;
                    if ((v8 & 768) != 512) {
                        // 0x8069390
                        v4 = v5 | 4 * v8 & 1020 | 3;
                    } else {
                        // 0x8069381
                        v4 = v5 | 1011;
                    }
                    // 0x80693a5
                    *v7 = v4;
                    v6 = v3 + 4 + 4 * v8 / 1024;
                    v3 = v6;
                }
            }
            // 0x80693ad
            v9 = *(int32_t *)(v1 - 4);
        }
    }
    // 0x80693b4
    caml_do_roots(0x806927f);
    caml_final_do_weak_roots(0x806927f);
    int32_t v10 = g114; // 0x80693d3
    if (g114 != 0) {
        int32_t v11 = *(int32_t *)(v10 - 8); // 0x80693e5
        uint32_t v12 = v11 + v10; // 0x80693e5
        int32_t v13 = v10; // 0x80693f0
        int32_t v14; // 0x8069330
        int32_t v15; // 0x8069330
        int32_t v16; // 0x8069330
        int32_t v17; // 0x8069330
        int32_t v18; // 0x8069330
        int32_t v19; // 0x8069330
        uint32_t v20; // 0x8069330
        int32_t v21; // 0x8069330
        int32_t v22; // 0x8069330
        int32_t v23; // 0x80693f9
        int32_t v24; // 0x806940a
        int32_t v25; // 0x8069410
        int32_t v26; // 0x80693ff
        int32_t v27; // 0x806941f
        int32_t v28; // 0x8069476
        int32_t v29; // 0x8069469
        int32_t v30; // 0x806942f
        if (v11 != 0 && v12 >= v10) {
            v22 = v13;
            v23 = *(int32_t *)v22;
            v14 = v23;
            v15 = v23;
            if (v23 % 4 == 0) {
                v26 = *(int32_t *)v14;
                v14 = v26;
                v15 = v26;
                while (v26 % 4 == 0) {
                    // 0x80693ff
                    v26 = *(int32_t *)v14;
                    v14 = v26;
                    v15 = v26;
                }
            }
            // 0x8069405
            v24 = v15 / 1024 + 1;
            v25 = v15 / 4 % 256;
            v18 = v25;
            v19 = v24;
            if (v25 == 249) {
                // 0x806941c
                v27 = *(int32_t *)(4 * v24 + v22);
                v16 = v27;
                v17 = v27;
                if (v27 % 4 != 3) {
                    v30 = *(int32_t *)(v16 & -4);
                    v16 = v30;
                    v17 = v30;
                    while (v30 % 4 != 3) {
                        // 0x806942c
                        v30 = *(int32_t *)(v16 & -4);
                        v16 = v30;
                        v17 = v30;
                    }
                }
                // 0x806943b
                v18 = v17 / 4 % 256;
                v19 = v17 / 1024 + 1;
            }
            // 0x806944b
            v20 = v19;
            if (v18 <= 250 && v20 >= 2) {
                invert_pointer_at();
                v29 = 2;
                v21 = v29;
                while (v29 != v20) {
                    // 0x8069462
                    invert_pointer_at();
                    v29 = v21 + 1;
                    v21 = v29;
                }
            }
            // 0x8069473
            v28 = 4 * v20 + v22;
            while (v12 > v28) {
                // 0x80693f6
                v22 = v28;
                v23 = *(int32_t *)v22;
                v14 = v23;
                v15 = v23;
                if (v23 % 4 == 0) {
                    v26 = *(int32_t *)v14;
                    v14 = v26;
                    v15 = v26;
                    while (v26 % 4 == 0) {
                        // 0x80693ff
                        v26 = *(int32_t *)v14;
                        v14 = v26;
                        v15 = v26;
                    }
                }
                // 0x8069405
                v24 = v15 / 1024 + 1;
                v25 = v15 / 4 % 256;
                v18 = v25;
                v19 = v24;
                if (v25 == 249) {
                    // 0x806941c
                    v27 = *(int32_t *)(4 * v24 + v22);
                    v16 = v27;
                    v17 = v27;
                    if (v27 % 4 != 3) {
                        v30 = *(int32_t *)(v16 & -4);
                        v16 = v30;
                        v17 = v30;
                        while (v30 % 4 != 3) {
                            // 0x806942c
                            v30 = *(int32_t *)(v16 & -4);
                            v16 = v30;
                            v17 = v30;
                        }
                    }
                    // 0x806943b
                    v18 = v17 / 4 % 256;
                    v19 = v17 / 1024 + 1;
                }
                // 0x806944b
                v20 = v19;
                if (v18 <= 250 && v20 >= 2) {
                    invert_pointer_at();
                    v29 = 2;
                    v21 = v29;
                    while (v29 != v20) {
                        // 0x8069462
                        invert_pointer_at();
                        v29 = v21 + 1;
                        v21 = v29;
                    }
                }
                // 0x8069473
                v28 = 4 * v20 + v22;
            }
        }
        // 0x8069485
        v10 -= 4;
        while (v10 != 0) {
            // 0x80693d9
            v11 = *(int32_t *)(v10 - 8);
            v12 = v11 + v10;
            v13 = v10;
            if (v11 != 0 && v12 >= v10) {
                v22 = v13;
                v23 = *(int32_t *)v22;
                v14 = v23;
                v15 = v23;
                if (v23 % 4 == 0) {
                    v26 = *(int32_t *)v14;
                    v14 = v26;
                    v15 = v26;
                    while (v26 % 4 == 0) {
                        // 0x80693ff
                        v26 = *(int32_t *)v14;
                        v14 = v26;
                        v15 = v26;
                    }
                }
                // 0x8069405
                v24 = v15 / 1024 + 1;
                v25 = v15 / 4 % 256;
                v18 = v25;
                v19 = v24;
                if (v25 == 249) {
                    // 0x806941c
                    v27 = *(int32_t *)(4 * v24 + v22);
                    v16 = v27;
                    v17 = v27;
                    if (v27 % 4 != 3) {
                        v30 = *(int32_t *)(v16 & -4);
                        v16 = v30;
                        v17 = v30;
                        while (v30 % 4 != 3) {
                            // 0x806942c
                            v30 = *(int32_t *)(v16 & -4);
                            v16 = v30;
                            v17 = v30;
                        }
                    }
                    // 0x806943b
                    v18 = v17 / 4 % 256;
                    v19 = v17 / 1024 + 1;
                }
                // 0x806944b
                v20 = v19;
                if (v18 <= 250 && v20 >= 2) {
                    invert_pointer_at();
                    v29 = 2;
                    v21 = v29;
                    while (v29 != v20) {
                        // 0x8069462
                        invert_pointer_at();
                        v29 = v21 + 1;
                        v21 = v29;
                    }
                }
                // 0x8069473
                v28 = 4 * v20 + v22;
                while (v12 > v28) {
                    // 0x80693f6
                    v22 = v28;
                    v23 = *(int32_t *)v22;
                    v14 = v23;
                    v15 = v23;
                    if (v23 % 4 == 0) {
                        v26 = *(int32_t *)v14;
                        v14 = v26;
                        v15 = v26;
                        while (v26 % 4 == 0) {
                            // 0x80693ff
                            v26 = *(int32_t *)v14;
                            v14 = v26;
                            v15 = v26;
                        }
                    }
                    // 0x8069405
                    v24 = v15 / 1024 + 1;
                    v25 = v15 / 4 % 256;
                    v18 = v25;
                    v19 = v24;
                    if (v25 == 249) {
                        // 0x806941c
                        v27 = *(int32_t *)(4 * v24 + v22);
                        v16 = v27;
                        v17 = v27;
                        if (v27 % 4 != 3) {
                            v30 = *(int32_t *)(v16 & -4);
                            v16 = v30;
                            v17 = v30;
                            while (v30 % 4 != 3) {
                                // 0x806942c
                                v30 = *(int32_t *)(v16 & -4);
                                v16 = v30;
                                v17 = v30;
                            }
                        }
                        // 0x806943b
                        v18 = v17 / 4 % 256;
                        v19 = v17 / 1024 + 1;
                    }
                    // 0x806944b
                    v20 = v19;
                    if (v18 <= 250 && v20 >= 2) {
                        invert_pointer_at();
                        v29 = 2;
                        v21 = v29;
                        while (v29 != v20) {
                            // 0x8069462
                            invert_pointer_at();
                            v29 = v21 + 1;
                            v21 = v29;
                        }
                    }
                    // 0x8069473
                    v28 = 4 * v20 + v22;
                }
            }
            // 0x8069485
            v10 -= 4;
        }
    }
    int32_t v31 = g90; // 0x806949e
    if (g90 != 0) {
        int32_t v32 = *(int32_t *)(v31 - 4); // 0x80694aa
        int32_t v33 = v32; // 0x80694b3
        int32_t v34 = v32; // 0x80694b3
        int32_t v35; // 0x80694b5
        if (v32 % 4 == 0) {
            v35 = *(int32_t *)v33;
            v33 = v35;
            v34 = v35;
            while (v35 % 4 == 0) {
                // 0x80694b5
                v35 = *(int32_t *)v33;
                v33 = v35;
                v34 = v35;
            }
        }
        uint32_t v36 = v34 / 1024; // 0x80694bf
        int32_t v37 = v31; // 0x80694c5
        int32_t v38; // 0x8069330
        int32_t v39; // 0x8069330
        int32_t v40; // 0x80694e0
        if (v34 >= 2048) {
            v38 = v37 + 4;
            if (*(int32_t *)v38 != (int32_t)g24) {
                // 0x80694d9
                invert_pointer_at();
            }
            // 0x80694e0
            v40 = 2;
            v37 = v38;
            v39 = v40;
            while (v36 > v40) {
                // 0x80694cf
                v38 = v37 + 4;
                if (*(int32_t *)v38 != (int32_t)g24) {
                    // 0x80694d9
                    invert_pointer_at();
                }
                // 0x80694e0
                v40 = v39 + 1;
                v37 = v38;
                v39 = v40;
            }
        }
        // 0x80694ea
        invert_pointer_at();
        v31 = *(int32_t *)v31;
        while (v31 != 0) {
            // 0x80694a7
            v32 = *(int32_t *)(v31 - 4);
            v33 = v32;
            v34 = v32;
            if (v32 % 4 == 0) {
                v35 = *(int32_t *)v33;
                v33 = v35;
                v34 = v35;
                while (v35 % 4 == 0) {
                    // 0x80694b5
                    v35 = *(int32_t *)v33;
                    v33 = v35;
                    v34 = v35;
                }
            }
            // 0x80694bf
            v36 = v34 / 1024;
            v37 = v31;
            if (v34 >= 2048) {
                v38 = v37 + 4;
                if (*(int32_t *)v38 != (int32_t)g24) {
                    // 0x80694d9
                    invert_pointer_at();
                }
                // 0x80694e0
                v40 = 2;
                v37 = v38;
                v39 = v40;
                while (v36 > v40) {
                    // 0x80694cf
                    v38 = v37 + 4;
                    if (*(int32_t *)v38 != (int32_t)g24) {
                        // 0x80694d9
                        invert_pointer_at();
                    }
                    // 0x80694e0
                    v40 = v39 + 1;
                    v37 = v38;
                    v39 = v40;
                }
            }
            // 0x80694ea
            invert_pointer_at();
            v31 = *(int32_t *)v31;
        }
    }
    // 0x8069501
    init_compact_allocate();
    int32_t v41 = g114; // 0x806950e
    int32_t v42; // 0x8069330
    int32_t v43; // 0x8069330
    int32_t v44; // 0x8069330
    int32_t v45; // 0x8069330
    int32_t v46; // 0x8069330
    int32_t v47; // 0x8069330
    int32_t v48; // 0x8069330
    uint32_t v49; // 0x806951d
    int32_t * v50; // 0x8069527
    if (g114 != 0) {
        while (true) {
            int32_t v51 = v41;
            v49 = *(int32_t *)(v51 - 8) + v51;
            v42 = v51;
            if (v49 > v51) {
                while (true) {
                  lab_0x8069527:
                    // 0x8069527
                    v43 = v42;
                    v50 = (int32_t *)v43;
                    uint32_t v52 = *v50; // 0x8069527
                    int32_t v53 = v52; // 0x806952b
                    if (v52 % 4 == 0) {
                        uint32_t v54 = *(int32_t *)v53; // 0x8069549
                        v53 = v54;
                        while (v54 % 4 == 0) {
                            // 0x8069549
                            v54 = *(int32_t *)v53;
                            v53 = v54;
                        }
                        int32_t v55 = v54 / 1024 + 1; // 0x8069554
                        int32_t v56 = v54 / 4 % 256; // 0x806955a
                        v45 = v55;
                        v48 = v56;
                        v47 = 0;
                        v46 = v55;
                        if (v56 != 249) {
                            goto lab_0x80695a4;
                        } else {
                            goto lab_0x8069570;
                        }
                    } else {
                        uint32_t v57 = v52 / 4 % 256; // 0x8069532
                        if (v57 != 249) {
                            // 0x806963e
                            *v50 = v52 & -1024 | v57 | 512;
                            v44 = v43 + 4 + 4 * v52 / 1024;
                            goto lab_0x8069656;
                        } else {
                            // 0x80697ba
                            v45 = v52 / 1024 + 1;
                            goto lab_0x8069570;
                        }
                    }
                }
            }
          lab_0x806965f:
            // 0x806965f
            v41 = *(int32_t *)(v51 - 4);
            if (v41 == 0) {
                // break -> 0x806966d
                break;
            }
        }
    }
    // 0x806966d
    init_compact_allocate();
    if (g114 == 0) {
        // 0x80697b3
        caml_fl_reset();
        // 0x8069788
        g87++;
        return caml_gc_message(16, "done.\n", 0);
    }
    int32_t v58 = g114;
    uint32_t v59 = *(int32_t *)(v58 - 8) + v58; // 0x8069688
    int32_t v60 = v58; // 0x80696c2
    int32_t v61; // 0x8069330
    int32_t * v62; // 0x806968d
    uint32_t v63; // 0x806968d
    int32_t v64; // 0x8069330
    if (v59 > v58) {
        v62 = (int32_t *)v60;
        v63 = *v62;
        v64 = 4 * v63 / 1024 + 4;
        if ((v63 & 768) == 0) {
            // 0x8069694
            memmove((int32_t *)compact_allocate(), v62, v64);
        }
        // 0x80696c0
        v61 = v64 + v60;
        v60 = v61;
        while (v59 > v61) {
            // 0x806968d
            v62 = (int32_t *)v60;
            v63 = *v62;
            v64 = 4 * v63 / 1024 + 4;
            if ((v63 & 768) == 0) {
                // 0x8069694
                memmove((int32_t *)compact_allocate(), v62, v64);
            }
            // 0x80696c0
            v61 = v64 + v60;
            v60 = v61;
        }
    }
    int32_t v65 = *(int32_t *)(v58 - 4); // 0x80696c7
    while (v65 != 0) {
        // 0x8069680
        v58 = v65;
        v59 = *(int32_t *)(v58 - 8) + v58;
        v60 = v58;
        if (v59 > v58) {
            v62 = (int32_t *)v60;
            v63 = *v62;
            v64 = 4 * v63 / 1024 + 4;
            if ((v63 & 768) == 0) {
                // 0x8069694
                memmove((int32_t *)compact_allocate(), v62, v64);
            }
            // 0x80696c0
            v61 = v64 + v60;
            v60 = v61;
            while (v59 > v61) {
                // 0x806968d
                v62 = (int32_t *)v60;
                v63 = *v62;
                v64 = 4 * v63 / 1024 + 4;
                if ((v63 & 768) == 0) {
                    // 0x8069694
                    memmove((int32_t *)compact_allocate(), v62, v64);
                }
                // 0x80696c0
                v61 = v64 + v60;
                v60 = v61;
            }
        }
        // 0x80696c4
        v65 = *(int32_t *)(v58 - 4);
    }
    // 0x80696ce
    if (g114 == 0) {
        // 0x80697b3
        caml_fl_reset();
        // 0x8069788
        g87++;
        return caml_gc_message(16, "done.\n", 0);
    }
    int32_t v66 = 0;
    uint32_t v67 = *(int32_t *)(g114 - 12); // 0x80696e6
    int32_t v68 = v66; // 0x80696eb
    int32_t v69 = v65; // 0x80696eb
    if (v67 != 0) {
        // 0x80696ed
        v68 = v67 / 4 + v66;
        v69 = (*(int32_t *)(g114 - 8) - v67) / 4 + v65;
    }
    int32_t v70 = v69;
    int32_t v71 = v68;
    int32_t v72 = *(int32_t *)(g114 - 4); // 0x8069700
    while (v72 != 0) {
        int32_t v73 = v70;
        int32_t v74 = v72;
        v66 = v71;
        v67 = *(int32_t *)(v74 - 12);
        v68 = v66;
        v69 = v73;
        if (v67 != 0) {
            // 0x80696ed
            v68 = v67 / 4 + v66;
            v69 = (*(int32_t *)(v74 - 8) - v67) / 4 + v73;
        }
        // 0x8069700
        v70 = v69;
        v71 = v68;
        v72 = *(int32_t *)(v74 - 4);
    }
    int32_t v75 = *(int32_t *)(g114 - 4); // 0x8069722
    int32_t v76 = v70; // 0x8069729
    if (*(int32_t *)(g114 - 12) == 0) {
        if ((v71 / 100 + 1) * (int32_t)g112 > v70) {
            // 0x806972f
            v76 = *(int32_t *)(g114 - 8) / 4 + v70;
        } else {
            // 0x8069739
            caml_shrink_heap(g114);
            v76 = v70;
        }
    }
    while (v75 != 0) {
        int32_t v77 = v76;
        int32_t v78 = v75;
        v75 = *(int32_t *)(v78 - 4);
        v76 = v77;
        if (*(int32_t *)(v78 - 12) == 0) {
            if ((v71 / 100 + 1) * (int32_t)g112 > v77) {
                // 0x806972f
                v76 = *(int32_t *)(v78 - 8) / 4 + v77;
            } else {
                // 0x8069739
                caml_shrink_heap(v78);
                v76 = v77;
            }
        }
    }
    // 0x8069749
    caml_fl_reset();
    if (g114 == 0) {
        // 0x8069788
        g87++;
        return caml_gc_message(16, "done.\n", 0);
    }
    uint32_t v79 = *(int32_t *)(g114 - 8); // 0x806975b
    uint32_t v80 = *(int32_t *)(g114 - 12); // 0x806975e
    if (v79 > v80) {
        // 0x8069765
        caml_make_free_blocks(v80 + g114, (v79 - v80) / 4, 1);
    }
    int32_t v81 = *(int32_t *)(g114 - 4); // 0x8069781
    while (v81 != 0) {
        int32_t v82 = v81;
        v79 = *(int32_t *)(v82 - 8);
        v80 = *(int32_t *)(v82 - 12);
        if (v79 > v80) {
            // 0x8069765
            caml_make_free_blocks(v80 + v82, (v79 - v80) / 4, 1);
        }
        // 0x8069781
        v81 = *(int32_t *)(v82 - 4);
    }
    // 0x8069788
    g87++;
    return caml_gc_message(16, "done.\n", 0);
  lab_0x80695a4:;
    int32_t v83 = v47;
    int32_t v84 = compact_allocate(); // 0x80695b0
    uint32_t v85 = *v50; // 0x80695b5
    if (v85 % 4 == 0) {
        int32_t * v86 = (int32_t *)v85; // 0x80695bf
        uint32_t v87 = *v86; // 0x80695bf
        *v86 = v84 + 4;
        while (v87 % 4 == 0) {
            // 0x80695bf
            v86 = (int32_t *)v87;
            v87 = *v86;
            *v86 = v84 + 4;
        }
    }
    // 0x80695cc
    *v50 = 1024 * v46 - 1024 | v48;
    if (v83 != 0 && v83 % 4 != 3) {
        int32_t v88 = v84 + 4;
        int32_t v89 = v83 & -4; // 0x80695f0
        int32_t * v90 = (int32_t *)v89; // 0x80695f3
        int32_t v91 = *v90; // 0x80695f3
        int32_t v92 = v91 % 4;
        uint32_t v93 = v89 - v43;
        int32_t v94 = v92; // 0x80695fd
        int32_t v95 = v91; // 0x80695fd
        int32_t * v96; // 0x806960f
        int32_t v97; // 0x806960f
        int32_t v98; // 0x8069330
        if (v92 == 2) {
            // 0x80695ff
            v96 = (int32_t *)(v91 & -4);
            v97 = *v96;
            *v96 = v88 + (v93 & -4);
            v98 = v97 % 4;
            v94 = v98;
            v95 = v97;
            while (v98 == 2) {
                // 0x806960a
                v96 = (int32_t *)(v97 & -4);
                v97 = *v96;
                *v96 = v88 + (v93 & -4);
                v98 = v97 % 4;
                v94 = v98;
                v95 = v97;
            }
        }
        // 0x806961d
        *v90 = 1024 * v93 / 4 | 249;
        while (v94 != 3) {
            // 0x80695ee
            v89 = v95 & -4;
            v90 = (int32_t *)v89;
            v91 = *v90;
            v92 = v91 % 4;
            v93 = v89 - v43;
            v94 = v92;
            v95 = v91;
            if (v92 == 2) {
                // 0x80695ff
                v96 = (int32_t *)(v91 & -4);
                v97 = *v96;
                *v96 = v88 + (v93 & -4);
                v98 = v97 % 4;
                v94 = v98;
                v95 = v97;
                while (v98 == 2) {
                    // 0x806960a
                    v96 = (int32_t *)(v97 & -4);
                    v97 = *v96;
                    *v96 = v88 + (v93 & -4);
                    v98 = v97 % 4;
                    v94 = v98;
                    v95 = v97;
                }
            }
            // 0x806961d
            *v90 = 1024 * v93 / 4 | 249;
        }
    }
    // 0x8069639
    v44 = 4 * v46 + v43;
    goto lab_0x8069656;
  lab_0x8069570:;
    int32_t v99 = 4 * v45 + v43; // 0x8069570
    int32_t v100 = *(int32_t *)v99; // 0x8069576
    int32_t v101 = v100; // 0x8069580
    int32_t v102 = v100; // 0x8069580
    if (v100 % 4 != 3) {
        int32_t v103 = *(int32_t *)(v101 & -4); // 0x8069585
        v101 = v103;
        v102 = v103;
        while (v103 % 4 != 3) {
            // 0x8069582
            v103 = *(int32_t *)(v101 & -4);
            v101 = v103;
            v102 = v103;
        }
    }
    // 0x8069591
    v48 = v102 / 4 % 256;
    v47 = v99;
    v46 = v102 / 1024 + 1;
    goto lab_0x80695a4;
  lab_0x8069656:
    // 0x8069656
    v42 = v44;
    if (v49 <= v44) {
        // break -> 0x806965f
        goto lab_0x806965f;
    }
    goto lab_0x8069527;
}

// Address range: 0x80697c5 - 0x806999a
int32_t caml_compact_heap_maybe(void) {
    // 0x80697c5
    int32_t result; // 0x80697c5
    if ((int32_t)g123 > 0xf423f || g84 < 3 || g88 < 3) {
        // 0x8069994
        return result;
    }
    int32_t v1 = g56; // 0x80697fc
    float80_t v2 = (int32_t)g46; // 0x806980c
    int3_t v3; // 0x80697c5
    int3_t v4 = v3 - 1; // 0x806980c
    __frontend_reg_store_fpr(v4, v2);
    __frontend_reg_store_fpr(v4, 3.0L * __frontend_reg_load_fpr(v4));
    int3_t v5 = v3 - 2; // 0x8069820
    __frontend_reg_store_fpr(v5, (float80_t)v1);
    __frontend_reg_store_fpr(v5, -2.0L * __frontend_reg_load_fpr(v5));
    __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v5) + __frontend_reg_load_fpr(v4));
    __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
    __frontend_reg_store_fpr(v5, 0.0L);
    if (__frontend_reg_load_fpr(v5) > __frontend_reg_load_fpr(v4)) {
        // 0x8069837
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, v2);
    }
    // 0x8069847
    __frontend_reg_store_fpr(v5, (float80_t)(g85 / 4));
    float80_t v6 = __frontend_reg_load_fpr(v5); // 0x806985e
    __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v4));
    __frontend_reg_store_fpr(v4, v6);
    float80_t v7 = __frontend_reg_load_fpr(v5); // 0x8069860
    float80_t v8 = __frontend_reg_load_fpr(v4); // 0x8069860
    float80_t v9 = __frontend_reg_load_fpr(v5);
    float80_t v10; // 0x80697c5
    if (v7 < v8) {
        int3_t v11 = v3 - 3; // 0x8069873
        __frontend_reg_store_fpr(v11, v9);
        __frontend_reg_store_fpr(v11, 100.0L * __frontend_reg_load_fpr(v11));
        float80_t v12 = __frontend_reg_load_fpr(v11); // 0x806987b
        __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v5));
        __frontend_reg_store_fpr(v5, v12);
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4) - __frontend_reg_load_fpr(v11));
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v5) / __frontend_reg_load_fpr(v4));
        float80_t v13 = __frontend_reg_load_fpr(v4); // 0x8069881
        __frontend_reg_store_fpr(v4, 1.0e+6L);
        __frontend_reg_store_fpr(v5, v13);
        float80_t v14 = __frontend_reg_load_fpr(v5); // 0x806988d
        float80_t v15 = __frontend_reg_load_fpr(v4); // 0x806988d
        bool v16 = false; // 0x806988d
        bool v17 = false; // 0x806988d
        if (v14 <= v15) {
            v16 = true;
            v17 = false;
            if (v14 >= v15) {
                v16 = v14 != v15;
                v17 = true;
            }
        }
        float80_t v18 = v16 | v17 ? __frontend_reg_load_fpr(v5) : __frontend_reg_load_fpr(v4); // 0x806988f
        __frontend_reg_store_fpr(v5, v18);
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v5));
        v10 = __frontend_reg_load_fpr(v4);
    } else {
        // 0x8069864
        __frontend_reg_store_fpr(v5, v9);
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, 1.0e+6L);
        v10 = __frontend_reg_load_fpr(v4);
    }
    // 0x8069896
    caml_gc_message(512, "FL size at phase change = %lu\n", v1);
    __frontend_reg_store_fpr(v4, v10);
    caml_gc_message(512, "Estimated overhead = %lu%%\n", (int32_t)(int64_t)__frontend_reg_load_fpr(v4));
    int32_t v19 = g123; // 0x80698e2
    __frontend_reg_store_fpr(v4, (float80_t)v19);
    __frontend_reg_store_fpr(v5, v10);
    float80_t v20 = __frontend_reg_load_fpr(v5); // 0x80698f8
    float80_t v21 = __frontend_reg_load_fpr(v4); // 0x80698f8
    __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
    result = v19;
    if (v20 >= v21) {
        // 0x8069902
        caml_gc_message(512, "Automatic compaction triggered.\n", 0);
        caml_finish_major_cycle();
        __frontend_reg_store_fpr(v4, (float80_t)(0x100000000 * g46 / 0x100000000));
        __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v5, 100.0L * __frontend_reg_load_fpr(v5));
        int3_t v22 = v3 - 3; // 0x8069951
        __frontend_reg_store_fpr(v22, (float80_t)(g85 / 4));
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v22) - __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v5) / __frontend_reg_load_fpr(v4));
        __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v4));
        caml_gc_message(512, "Measured overhead: %lu%%\n", (int32_t)(int64_t)__frontend_reg_load_fpr(v4));
        result = caml_compact_heap();
    }
    // 0x8069994
    return result;
}

// Address range: 0x80699a0 - 0x8069a49
int32_t caml_final_do_strong_roots(int32_t a1) {
    int32_t v1 = g97; // 0x80699ea
    if (g97 == 0) {
        // 0x8069a41
        return g97;
    }
    int32_t result = g97; // 0x80699ea
    result = *(int32_t *)(v1 + 4) != 0 ? v1 : result;
    v1 = *(int32_t *)v1;
    while (v1 != 0) {
        // 0x8069a31
        result = *(int32_t *)(v1 + 4) != 0 ? v1 : result;
        v1 = *(int32_t *)v1;
    }
    // 0x8069a41
    return result;
}

// Address range: 0x8069a49 - 0x8069a95
int32_t caml_final_do_weak_roots(int32_t a1) {
    // 0x8069a49
    int32_t result; // 0x8069a49
    if (g96 != 0) {
        // 0x8069a68
        result = *(int32_t *)(12 * g96 - 8 + g95);
    }
    // 0x8069a8d
    return result;
}

// Address range: 0x8069a95 - 0x8069af5
int32_t caml_final_do_young_roots(int32_t a1) {
    uint32_t v1 = g96; // 0x8069aa1
    uint32_t v2 = g94; // 0x8069aa7
    int32_t result; // 0x8069a95
    if (v1 < v2) {
        uint32_t v3 = v1 + 1;
        result = *(int32_t *)(12 * (v2 > v3 ? v2 : v3) - 8 + g95);
    }
    // 0x8069aed
    return result;
}

// Address range: 0x8069af5 - 0x8069b04
int32_t caml_final_empty_young(void) {
    // 0x8069af5
    g96 = g94;
    return g94;
}

// Address range: 0x8069c09 - 0x8069ce4
int32_t caml_final_do_calls(void) {
    // 0x8069c09
    if (g93 != 0 || g97 == 0) {
        // 0x8069cde
        int32_t result; // 0x8069c09
        return result;
    }
    // 0x8069c2a
    caml_gc_message(128, "Calling finalisation functions.\n", 0);
    while (g97 != 0) {
        int32_t v1 = g97;
        int32_t * v2 = (int32_t *)(v1 + 4);
        int32_t v3 = *v2; // 0x8069c6f
        while (v3 == 0) {
            int32_t * v4 = (int32_t *)v1; // 0x8069c48
            int32_t v5 = *v4; // 0x8069c48
            free(v4);
            g97 = v5;
            if (v5 == 0) {
                // 0x8069c66
                g98 = 0;
                return caml_gc_message(128, "Done calling finalisation functions.\n", 0);
            }
            v1 = v5;
            v2 = (int32_t *)(v1 + 4);
            v3 = *v2;
        }
        int32_t v6 = v3 - 1; // 0x8069c76
        *v2 = v6;
        int32_t v7 = 12 * v6 + v1; // 0x8069c7f
        int32_t v8 = *(int32_t *)(v7 + 12); // 0x8069c88
        g93 = 1;
        uint32_t v9 = caml_callback_exn(*(int32_t *)(v7 + 8), v8 + *(int32_t *)(v7 + 16)); // 0x8069c9e
        g93 = 0;
        if (v9 % 4 == 2) {
            // 0x8069cb7
            caml_raise(v9 & -4);
            return caml_gc_message(128, "Done calling finalisation functions.\n", 0);
        }
    }
  lab_0x8069cc2:
    // 0x8069cde
    return caml_gc_message(128, "Done calling finalisation functions.\n", 0);
}

// Address range: 0x8069ce4 - 0x8069f13
int32_t caml_final_update(void) {
    int32_t result2 = g96; // 0x8069ced
    int32_t result; // 0x8069ce4
    if (result2 == 0) {
        // 0x8069f0b
        return result;
    }
    int32_t v1 = 0; // 0x8069d06
    int32_t v2 = g95; // 0x8069d06
    int32_t v3 = 0; // 0x8069d06
    int32_t v4 = *(int32_t *)(*(int32_t *)(v2 + 4) - 4); // 0x8069d0e
    v3 += (int32_t)((v4 & 768) == 0);
    v1++;
    v2 += 12;
    while (v1 != result2) {
        // 0x8069d0b
        v4 = *(int32_t *)(*(int32_t *)(v2 + 4) - 4);
        v3 += (int32_t)((v4 & 768) == 0);
        v1++;
        v2 += 12;
    }
    // 0x8069d27
    if (v3 == 0) {
        // 0x8069f0b
        return result2;
    }
    int32_t * mem = malloc(12 * v3 + 20); // 0x8069d3c
    if (mem == NULL) {
        // 0x8069d45
        caml_fatal_error("out of memory");
        // UNREACHABLE
    }
    int32_t result3 = (int32_t)mem; // 0x8069d3c
    *mem = 0;
    int32_t * v5 = (int32_t *)(result3 + 4);
    *v5 = v3;
    int32_t v6 = g98; // 0x8069d5a
    if (v6 != 0) {
        // 0x8069d70
        *(int32_t *)v6 = result3;
    } else {
        // 0x8069d64
        g97 = result3;
    }
    // 0x8069d77
    g98 = result3;
    int32_t v7 = g96; // 0x8069d77
    if (v7 == 0) {
        // 0x8069eeb
        g96 = 0;
        g94 = 0;
        *v5 = 0;
        // 0x8069f0b
        return result3;
    }
    int32_t v8 = 0; // 0x8069dae
    int32_t result4 = 0; // 0x8069dae
    int32_t v9 = 0; // 0x8069dae
    int32_t v10 = g95; // 0x8069dae
    int32_t v11; // 0x8069ce4
    int32_t v12; // 0x8069ce4
    int32_t v13; // 0x8069ce4
    int32_t v14; // 0x8069ce4
    int32_t v15; // 0x8069ce4
    int32_t * v16; // 0x8069ce4
    while (true) {
      lab_0x8069db3:
        // 0x8069db3
        v11 = v10;
        v14 = result4;
        v12 = v8;
        v16 = (int32_t *)(v11 + 4);
        int32_t v17 = *v16; // 0x8069db3
        while (true) {
          lab_0x8069db6:;
            int32_t v18 = v17; // 0x8069db6
            int32_t v19 = v18 - 4; // 0x8069db9
            if ((*(int32_t *)v19 & 768) != 0) {
                // break -> 0x8069e4e
                break;
            }
            // 0x8069dc8
            if (*(char *)v19 != -6) {
                goto lab_0x8069e28_4;
            }
            uint32_t v20 = *(int32_t *)v18; // 0x8069dcd
            if (v20 % 2 != 0) {
                // 0x8069e0e
                *v16 = v20;
                goto lab_0x8069e28_4;
            }
            uint32_t v21 = v20 / 0x1000 % 2048; // 0x8069de0
            int32_t * v22 = (int32_t *)(4 * v20 / 0x800000 + (int32_t)&g121); // 0x8069de9
            if (*(char *)(*v22 + v21) % 8 == 0) {
                goto lab_0x8069e28_4;
            }
            char v23 = *(char *)(v20 - 4); // 0x8069df2
            switch (v23) {
                case -6: {
                    goto lab_0x8069e28_4;
                }
                case -10: {
                    goto lab_0x8069e28_4;
                }
                default: {
                    if (v23 == -3) {
                        goto lab_0x8069e28_4;
                    }
                    // 0x8069ed0
                    *v16 = v20;
                    v17 = v20;
                    if (*(char *)(*v22 + v21) % 2 == 0) {
                        goto lab_0x8069e28_4;
                    }
                    goto lab_0x8069db6;
                }
            }
        }
        int32_t v24 = 12 * v14 + g95;
        *(int32_t *)v24 = *(int32_t *)v11;
        *(int32_t *)(v24 + 4) = *v16;
        *(int32_t *)(v24 + 8) = *(int32_t *)(v11 + 8);
        v13 = v12;
        v15 = v14 + 1;
        goto lab_0x8069e74;
    }
  lab_0x8069e87:
    // 0x8069e87
    g96 = result4;
    g94 = result4;
    *v5 = v8;
    if (v8 == 0) {
        // 0x8069f0b
        return result4;
    }
    int32_t v25 = 0;
    int32_t v26 = v25 + 1; // 0x8069ec7
    int32_t v27 = v26; // 0x8069ecc
    result = caml_darken(*(int32_t *)(g98 + 12 + 12 * v25), 0);
    while (v26 != v8) {
        // 0x8069ea8
        v25 = v27;
        v26 = v25 + 1;
        v27 = v26;
        result = caml_darken(*(int32_t *)(g98 + 12 + 12 * v25), 0);
    }
    // 0x8069f0b
    return result;
  lab_0x8069e28_4:;
    int32_t v28 = 12 * v12 + result3;
    *(int32_t *)(v28 + 8) = *(int32_t *)v11;
    *(int32_t *)(v28 + 12) = *v16;
    *(int32_t *)(v28 + 16) = *(int32_t *)(v11 + 8);
    v13 = v12 + 1;
    v15 = v14;
    goto lab_0x8069e74;
  lab_0x8069e74:
    // 0x8069e74
    result4 = v15;
    v8 = v13;
    v9++;
    v10 = v11 + 12;
    if (v9 == v7) {
        // break -> 0x8069e87
        goto lab_0x8069e87;
    }
    goto lab_0x8069db3;
}

// Address range: 0x8069f97 - 0x8069fbe
int32_t caml_register_custom_operations(char (**a1)[3]) {
    int32_t result = caml_stat_alloc(8); // 0x8069fa4
    *(int32_t *)result = (int32_t)a1;
    *(int32_t *)(result + 4) = g99;
    g99 = result;
    return result;
}

// Address range: 0x8069fbe - 0x8069fea
int32_t caml_init_custom_operations(void) {
    // 0x8069fbe
    caml_register_custom_operations(&g21);
    caml_register_custom_operations(&g23);
    return caml_register_custom_operations(&g22);
}

// Address range: 0x806a0a0 - 0x806a10e
int32_t caml_executable_name(int32_t * buf, int32_t buf_size) {
    int32_t v1 = readlink("/proc/self/exe", (char *)buf, buf_size); // 0x806a0c1
    if (v1 != -1 == v1 < buf_size) {
        // 0x806a0cf
        *(char *)(v1 + (int32_t)buf) = 0;
        int32_t v2; // bp-108, 0x806a0a0
        int32_t v3; // 0x806a0a0
        if ((v3 & 0xf000) == 0x8000 == __xstat64(3, (char *)buf, (struct stat64 *)&v2) == 0) {
            // 0x806a104
            return 0;
        }
    }
    // 0x806a104
    return -1;
}

// Address range: 0x806a10e - 0x806a194
int32_t caml_decompose_path(int32_t * a1, int32_t str2) {
    // 0x806a10e
    if (str2 == 0) {
        // 0x806a18a
        return 0;
    }
    int32_t v1 = -1; // 0x806a132
    int32_t v2 = str2; // 0x806a10e
    int32_t v3 = 0; // 0x806a132
    while (v1 != 0) {
        int32_t v4 = v2;
        v1--;
        bool v5; // 0x806a10e
        v2 = v4 + (v5 ? -1 : 1);
        v3 = v1;
        if (*(char *)v4 == 0) {
            // break -> 
            break;
        }
        v3 = 0;
    }
    int32_t str = caml_stat_alloc(-1 - v3); // 0x806a139
    strcpy((char *)str, (char *)str2);
    char * v6 = (char *)str;
    char v7 = *v6; // 0x806a14e
    char * v8 = v6; // 0x806a153
    int32_t v9 = str; // 0x806a153
    int32_t v10; // 0x806a10e
    int32_t v11; // 0x806a10e
    char v12; // 0x806a162
    char * v13; // 0x806a10e
    if (v7 != 0 == (v7 != 58)) {
        v10 = str + 1;
        v13 = (char *)v10;
        v12 = *v13;
        v11 = v10;
        v8 = v13;
        v9 = v10;
        while (v12 != 0 == (v12 != 58)) {
            // 0x806a160
            v10 = v11 + 1;
            v13 = (char *)v10;
            v12 = *v13;
            v11 = v10;
            v8 = v13;
            v9 = v10;
        }
    }
    // 0x806a171
    caml_ext_table_add(a1, str);
    while (*v8 != 0) {
        // 0x806a182
        *v8 = 0;
        int32_t v14 = v9 + 1; // 0x806a188
        v6 = (char *)v14;
        v7 = *v6;
        v11 = v14;
        v8 = v6;
        v9 = v14;
        if (v7 != 0 == (v7 != 58)) {
            v10 = v11 + 1;
            v13 = (char *)v10;
            v12 = *v13;
            v11 = v10;
            v8 = v13;
            v9 = v10;
            while (v12 != 0 == (v12 != 58)) {
                // 0x806a160
                v10 = v11 + 1;
                v13 = (char *)v10;
                v12 = *v13;
                v11 = v10;
                v8 = v13;
                v9 = v10;
            }
        }
        // 0x806a171
        caml_ext_table_add(a1, v14);
    }
    // 0x806a18a
    return str;
}

// Address range: 0x806a2d8 - 0x806a40f
int32_t caml_search_in_path(int32_t a1, int32_t a2) {
    char * str2 = (char *)a2; // 0x806a2ea
    char v1 = *str2; // 0x806a2ea
    if (v1 == 0) {
        goto lab_0x806a310;
    } else {
        // 0x806a2f1
        if (v1 != 47) {
            int32_t v2 = a2 + 1; // 0x806a306
            char v3 = *(char *)v2; // 0x806a309
            while (v3 != 0) {
                // 0x806a2fb
                if (v3 == 47) {
                    goto lab_0x806a3d8_2;
                }
                v2++;
                v3 = *(char *)v2;
            }
            goto lab_0x806a310;
        } else {
            goto lab_0x806a3d8_2;
        }
    }
  lab_0x806a3d8_2:;
    int32_t v4 = -1; // 0x806a3e5
    int32_t v5 = a2; // 0x806a3e5
    int32_t v6 = 0; // 0x806a3e5
    bool v7; // 0x806a2d8
    while (v4 != 0) {
        int32_t v8 = v5;
        int32_t v9 = v4 - 1; // 0x806a3e5
        v4 = v9;
        v5 = v8 + (v7 ? -1 : 1);
        v6 = v9;
        if (*(char *)v8 == 0) {
            // break -> 
            break;
        }
        v6 = 0;
    }
    int32_t str = caml_stat_alloc(-1 - v6); // 0x806a3ec
    strcpy((char *)str, str2);
    // 0x806a402
    return str;
  lab_0x806a310:;
    int32_t * v10 = (int32_t *)a1; // 0x806a310
    if (*v10 >= 1) {
        int32_t * v11 = (int32_t *)(a1 + 8); // 0x806a329
        int32_t v12 = v7 ? -1 : 1;
        int32_t v13 = 0; // 0x806a3c9
        int32_t v14 = 4 * v13; // 0x806a323
        int32_t v15 = *(int32_t *)(*v11 + v14); // 0x806a339
        int32_t v16 = -1;
        int32_t v17 = 0; // 0x806a339
        int32_t v18; // 0x806a2d8
        int32_t v19; // 0x806a339
        while (v16 != 0) {
            v18 = v15;
            v19 = v16 - 1;
            v15 = v18 + v12;
            v17 = v19;
            if (*(char *)v18 == 0) {
                // break -> 
                break;
            }
            v16 = v19;
            v17 = 0;
        }
        int32_t v20 = a2; // 0x806a347
        int32_t v21 = -1;
        int32_t v22 = 0; // 0x806a347
        int32_t v23; // 0x806a2d8
        int32_t v24; // 0x806a347
        while (v21 != 0) {
            v23 = v20;
            v24 = v21 - 1;
            v20 = v23 + v12;
            v22 = v24;
            if (*(char *)v23 == 0) {
                // break -> 
                break;
            }
            v21 = v24;
            v22 = 0;
        }
        int32_t result = caml_stat_alloc(-1 - v22 + -1 - v17); // 0x806a350
        char * str3 = (char *)result; // 0x806a364
        strcpy(str3, (char *)*(int32_t *)(*v11 + v14));
        int32_t v25 = result; // 0x806a36f
        int32_t v26; // 0x806a2d8
        int32_t v27; // 0x806a2d8
        int32_t v28; // 0x806a2d8
        int32_t v29; // 0x806a2d8
        int32_t v30; // 0x806a37d
        if (*str3 != 0) {
            v27 = -1;
            v28 = 0;
            while (v27 != 0) {
                // 0x806a371
                v29 = v25;
                v30 = v27 - 1;
                v26 = v30;
                v25 = v29 + v12;
                v28 = v30;
                if (*(char *)v29 == 0) {
                    // break -> 
                    break;
                }
                v27 = v26;
                v28 = 0;
            }
            *(int16_t *)(result - 1 + -1 - v28) = 47;
        }
        // 0x806a388
        strcat(str3, str2);
        int32_t v31; // bp-124, 0x806a2d8
        int32_t v32 = __xstat64(3, str3, (struct stat64 *)&v31); // 0x806a3a9
        int32_t v33; // 0x806a2d8
        while ((v33 & 0xf000) == 0x8000 != (v32 == 0)) {
            // 0x806a3c1
            caml_stat_free(result);
            v13++;
            if (*v10 <= v13) {
                goto lab_0x806a3d8_2;
            }
            v14 = 4 * v13;
            v15 = *(int32_t *)(*v11 + v14);
            v16 = -1;
            v17 = 0;
            while (v16 != 0) {
                v18 = v15;
                v19 = v16 - 1;
                v15 = v18 + v12;
                v17 = v19;
                if (*(char *)v18 == 0) {
                    // break -> 
                    break;
                }
                v16 = v19;
                v17 = 0;
            }
            v20 = a2;
            v21 = -1;
            v22 = 0;
            while (v21 != 0) {
                v23 = v20;
                v24 = v21 - 1;
                v20 = v23 + v12;
                v22 = v24;
                if (*(char *)v23 == 0) {
                    // break -> 
                    break;
                }
                v21 = v24;
                v22 = 0;
            }
            result = caml_stat_alloc(-1 - v22 + -1 - v17);
            str3 = (char *)result;
            strcpy(str3, (char *)*(int32_t *)(*v11 + v14));
            v25 = result;
            if (*str3 != 0) {
                v27 = -1;
                v28 = 0;
                while (v27 != 0) {
                    // 0x806a371
                    v29 = v25;
                    v30 = v27 - 1;
                    v26 = v30;
                    v25 = v29 + v12;
                    v28 = v30;
                    if (*(char *)v29 == 0) {
                        // break -> 
                        break;
                    }
                    v27 = v26;
                    v28 = 0;
                }
                *(int16_t *)(result - 1 + -1 - v28) = 47;
            }
            // 0x806a388
            strcat(str3, str2);
            v32 = __xstat64(3, str3, (struct stat64 *)&v31);
        }
        // 0x806a402
        return result;
    }
    goto lab_0x806a3d8_2;
}

// Address range: 0x806a48c - 0x806a500
int32_t caml_search_exe_in_path(int32_t a1) {
    // 0x806a48c
    int32_t v1; // bp-40, 0x806a48c
    caml_ext_table_init(&v1, 8);
    char * env_val = getenv("PATH"); // 0x806a4b5
    int32_t v2 = caml_decompose_path(&v1, (int32_t)env_val); // 0x806a4c1
    int32_t result = caml_search_in_path((int32_t)&v1, a1); // 0x806a4d2
    caml_stat_free(v2);
    caml_ext_table_free(&v1, 0);
    return result;
}

// Address range: 0x806a514 - 0x806a5a7
int32_t extract_location_info(void) {
    // 0x806a514
    int32_t v1; // 0x806a514
    int32_t v2 = v1;
    int32_t result; // 0x806a514
    if (*(char *)(v2 + 4) % 2 != 0) {
        int32_t v3 = v2 + 11 + 2 * (int32_t)*(int16_t *)(v2 + 6) & -4; // 0x806a542
        uint32_t v4 = *(int32_t *)v3; // 0x806a545
        uint32_t v5 = *(int32_t *)(v3 + 4); // 0x806a547
        *(int32_t *)v1 = 1;
        *(int32_t *)(v1 + 4) = (int32_t)(v4 % 4 != 0);
        *(int32_t *)(v1 + 8) = v3 + (v4 & 0x3fffffc);
        *(int32_t *)(v1 + 12) = v5 / 0x1000;
        *(int32_t *)(v1 + 16) = v5 / 16 % 256;
        int32_t v6 = 64 * v5 & 960 | v4 / 0x4000000; // 0x806a593
        *(int32_t *)(v1 + 20) = v6;
        result = v6;
    } else {
        // 0x806a52b
        *(int32_t *)v1 = 0;
        *(int32_t *)(v1 + 4) = 1;
    }
    // 0x806a598
    return result;
}

// Address range: 0x806a728 - 0x806a7b9
int32_t caml_print_exception_backtrace(void) {
    // 0x806a728
    if (g101 < 1) {
        // 0x806a7b1
        int32_t result; // 0x806a728
        return result;
    }
    // 0x806a747
    int32_t v1; // 0x806a728
    int32_t v2 = v1 != 0 ? (int32_t)"Re-raised at" : (int32_t)"Called from";
    int32_t v3 = 0;
    int32_t chars_printed = extract_location_info(); // 0x806a75a
    int32_t v4; // 0x806a728
    char * v5; // 0x806a728
    if (v1 != 0) {
        // 0x806a75c
        v4 = v3 == 0 ? (int32_t)"Raised at" : v2;
        chars_printed = fprintf(g26, "%s file \"%s\", line %d, characters %d-%d\n", (char *)v4, v5, v1, v1, v1);
    }
    int32_t v6 = v3 + 1; // 0x806a7a6
    while (g101 > v6) {
        // 0x806a747
        v3 = v6;
        chars_printed = extract_location_info();
        if (v1 != 0) {
            // 0x806a75c
            v4 = v3 == 0 ? (int32_t)"Raised at" : v2;
            chars_printed = fprintf(g26, "%s file \"%s\", line %d, characters %d-%d\n", (char *)v4, v5, v1, v1, v1);
        }
        // 0x806a7a6
        v6 = v3 + 1;
    }
    // 0x806a7b1
    return chars_printed;
}

// Address range: 0x806a7b9 - 0x806a894
int32_t caml_stash_backtrace(int32_t a1, int32_t a2, int32_t * a3, uint32_t a4) {
    // 0x806a7b9
    if (g25 != a1) {
        // 0x806a7d3
        g101 = 0;
        g25 = a1;
    }
    // 0x806a7e2
    int32_t result; // 0x806a7b9
    if (g102 == 0) {
        int32_t * mem = malloc(0x1000); // 0x806a7f2
        int32_t v1 = (int32_t)mem; // 0x806a7f2
        g102 = v1;
        result = v1;
        if (mem == NULL) {
          lab_0x806a88c:
            // 0x806a88c
            return result;
        }
    }
    // 0x806a804
    if (g32 == 0) {
        // 0x806a80d
        caml_init_frame_descriptors();
    }
    int32_t v2 = (int32_t)a3;
    uint32_t v3 = a2;
    int32_t v4 = g107 & v3 / 8; // 0x806a81d
    int32_t v5 = *(int32_t *)(4 * v4 + g32); // 0x806a825
    result = 0;
    while (v5 != 0) {
        int32_t v6 = v2;
        int32_t v7 = v4; // 0x806a82e
        int32_t v8 = v5; // 0x806a82e
        if (*(int32_t *)v5 != v3) {
            int32_t v9 = v7 + 1 & g107; // 0x806a839
            int32_t v10 = *(int32_t *)(4 * v9 + g32); // 0x806a83b
            result = v10;
            if (v10 == 0) {
                return result;
            }
            // 0x806a832
            v7 = v9;
            v8 = v10;
            while (*(int32_t *)v10 != v3) {
                // 0x806a836
                v9 = v7 + 1 & g107;
                v10 = *(int32_t *)(4 * v9 + g32);
                result = v10;
                if (v10 == 0) {
                    return result;
                }
                // 0x806a832
                v7 = v9;
                v8 = v10;
            }
        }
        int32_t v11 = v8;
        int16_t * v12 = (int16_t *)(v11 + 4); // 0x806a844
        int32_t v13; // 0x806a7b9
        int32_t v14; // 0x806a7b9
        int32_t v15; // 0x806a7b9
        if (*v12 == -1) {
            int32_t v16 = v6 + 8; // 0x806a87b
            int32_t v17 = *(int32_t *)v16; // 0x806a87e
            v13 = v16;
            v14 = v6 + 12;
            v15 = v17;
            result = v16;
            if (v17 == 0) {
                // break -> 0x806a88c
                break;
            }
        } else {
            // 0x806a84b
            result = v11;
            if (g101 > 1023) {
                // break -> 0x806a88c
                break;
            }
            // 0x806a859
            *(int32_t *)(g102 + 4 * g101) = v11;
            g101++;
            int32_t v18 = (int32_t)(*v12 & -4); // 0x806a86f
            int32_t v19 = v6 + v18; // 0x806a874
            v13 = v18;
            v14 = v19 - 4;
            v15 = v19;
        }
        // 0x806a887
        v2 = v15;
        result = v13;
        if (v2 > a4) {
            // break -> 0x806a88c
            break;
        }
        v3 = *(int32_t *)v14;
        v4 = g107 & v3 / 8;
        v5 = *(int32_t *)(4 * v4 + g32);
        result = 0;
    }
    // 0x806a88c
    return result;
}

// Address range: 0x806a894 - 0x806a8db
int32_t caml_record_backtrace(int32_t a1) {
    int32_t v1 = a1 / 2; // 0x806a89d
    if (v1 == g100) {
        // 0x806a8d4
        return 1;
    }
    // 0x806a8a7
    g100 = v1;
    g101 = 0;
    if (a1 < 2) {
        // 0x806a8c8
        caml_remove_global_root(&g25);
    } else {
        // 0x806a8ba
        caml_register_global_root(&g25);
    }
    // 0x806a8d4
    return 1;
}

// Address range: 0x806a8dc - 0x806a8e1
int32_t caml_debugger_init(void) {
    // 0x806a8dc
    int32_t result; // 0x806a8dc
    return result;
}

// Address range: 0x806aa10 - 0x806aa19
int32_t caml_start_program(void) {
    // 0x806aa10
    int32_t result; // 0x806aa10
    return result;
}

// Address range: 0x806aa19 - 0x806aa5e
int32_t function_806aa19(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x806aa19
    int32_t result; // 0x806aa19
    return result;
}

// Address range: 0x806aaa0 - 0x806aae8
int32_t caml_raise_exception(int32_t result) {
    int32_t v1 = g29;
    if ((uint32_t)g100 % 2 == 0) {
        // 0x806aaac
        g29 = *(int32_t *)v1;
        return result;
    }
    // 0x806aabd
    caml_stash_backtrace(result, g16, (int32_t *)g33, v1);
    g29 = *(int32_t *)g29;
    return result;
}

// Address range: 0x806aae8 - 0x806aafb
int32_t caml_callback_exn(int32_t a1, int32_t a2) {
    // 0x806aae8
    int32_t v1; // 0x806aae8
    return function_806aa19(v1, v1, v1, v1);
}

// --------------- Dynamically Linked Functions ---------------

// int __sigsetjmp(struct __jmp_buf_tag env[1], int savemask);
// int __xstat64(int ver, const char * filename, struct stat64 * stat_buf);
// void * calloc(size_t nmemb, size_t size);
// void exit(int status);
// int fflush(FILE * stream);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// int fputs(const char * restrict s, FILE * restrict stream);
// void free(void * ptr);
// char * getenv(const char * name);
// void * malloc(size_t size);
// void * memmove(void * dest, const void * src, size_t n);
// ssize_t readlink(const char * restrict path, char * restrict buf, size_t len);
// void * realloc(void * ptr, size_t size);
// int sigaction(int sig, const struct sigaction * restrict act, struct sigaction * restrict oact);
// int sigaltstack(const struct sigaltstack * restrict ss, struct sigaltstack * restrict oss);
// int sigemptyset(sigset_t * set);
// int sprintf(char * restrict s, const char * restrict format, ...);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// char * strcat(char * restrict dest, const char * restrict src);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.5)
// Detected functions: 105

