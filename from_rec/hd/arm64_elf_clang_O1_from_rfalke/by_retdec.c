//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

void dumpline(char * p, int64_t offset, int32_t cnt);
int32_t hexdump(char * fname);

// ------------------------ Functions -------------------------

// From module:   /mnt/from_rec/./hd/source.c
// Address range: 0x400870 - 0x4009e0
// Line range:    4 - 25
void dumpline(char * p, int64_t offset, int32_t cnt) {
    int64_t v1 = (int64_t)p;
    int64_t str; // bp-168, 0x400870
    int64_t v2 = &str; // 0x4008b4
    sprintf((char *)&str, "%08lX:", (int32_t)offset);
    int32_t v3 = cnt - 16; // 0x4008bc
    int32_t v4 = v3 == 0 | v3 < 0 != (15 - cnt & cnt) < 0 ? cnt : 16; // 0x4008cc
    int64_t v5 = 0; // 0x4008cc
    if (v4 < 1) {
        goto lab_0x400914;
    } else {
        // 0x4008d0
        v5 = v4;
        int64_t v6; // bp-159, 0x400870
        int64_t str2 = &v6; // 0x4008e0
        int64_t v7 = 0; // 0x4008e0
        sprintf((char *)str2, " %02lX", (int32_t)*(char *)(v7 + v1));
        v7++;
        str2 += 3;
        while (v7 != v5) {
            // 0x4008e4
            sprintf((char *)str2, " %02lX", (int32_t)*(char *)(v7 + v1));
            v7++;
            str2 += 3;
        }
        // 0x400904
        if (v4 < 16) {
            goto lab_0x400914;
        } else {
            goto lab_0x40092c;
        }
    }
  lab_0x400914:;
    int32_t len = strlen((char *)&str); // 0x40091c
    int64_t v8 = (16 - v5 & 0xffffffff) + 0xffffffff; // 0x400920
    *(int32_t *)((int64_t)len + v2) = 0x202020;
    int64_t v9 = v8; // 0x400928
    while ((int32_t)v8 != 0) {
        // 0x400918
        len = strlen((char *)&str);
        v8 = (v9 & 0xffffffff) + 0xffffffff;
        *(int32_t *)((int64_t)len + v2) = 0x202020;
        v9 = v8;
    }
    goto lab_0x40092c;
  lab_0x40092c:;
    int64_t v10 = (int64_t)strlen((char *)&str) + v2;
    *(int32_t *)v10 = 0x7c2020;
    int64_t v11 = 0; // 0x400948
    if (v4 >= 1) {
        int64_t v12 = v4;
        int64_t v13 = 0; // 0x400958
        unsigned char v14 = *(char *)(v13 + v1); // 0x40095c
        *(char *)(v13 + v10) = (int32_t)v14 < 127 ? v14 : 46;
        v13++;
        while (v13 != v12) {
            // 0x40095c
            v14 = *(char *)(v13 + v1);
            *(char *)(v13 + v10) = (int32_t)v14 < 127 ? v14 : 46;
            v13++;
        }
        // 0x40097c
        v11 = v12;
        if (v4 >= 16) {
            // 0x4009b0
            *(int16_t *)((v12 & 0xffffffff) + v10) = 124;
            puts((char *)&str);
            return;
        }
    }
    int64_t v15 = v11;
    memset((int64_t *)(v15 + v10), 32, 16 - (int32_t)v15);
    // 0x4009b0
    *(int16_t *)(16 + v10) = 124;
    puts((char *)&str);
}

// From module:   /mnt/from_rec/./hd/source.c
// Address range: 0x4009e0 - 0x400a94
// Line range:    27 - 36
int32_t hexdump(char * fname) {
    // 0x4009e0
    int64_t v1; // 0x4009e0
    uint64_t v2 = v1;
    if ((int32_t)stat() == 0) {
        // 0x400a84
        perror(fname);
        // 0x400a70
        return 1;
    }
    struct _IO_FILE * file = fopen(fname, "rb"); // 0x400a10
    if (file == NULL) {
        // 0x400a84
        perror(fname);
        // 0x400a70
        return 1;
    }
    if (v2 == 0) {
        // 0x400a64
        fclose(file);
        // 0x400a70
        return 0;
    }
    int64_t v3 = 0; // 0x400a58
    int64_t data; // bp-56, 0x4009e0
    int32_t items_read = fread(&data, 1, 16, file); // 0x400a38
    while (items_read != 0) {
        // 0x400a44
        dumpline((char *)&data, v3, items_read);
        v3 += (int64_t)items_read;
        if (v3 >= v2) {
            // break -> 0x400a64
            break;
        }
        items_read = fread(&data, 1, 16, file);
    }
    // 0x400a64
    fclose(file);
    // 0x400a70
    return 0;
}

// From module:   /mnt/from_rec/./hd/source.c
// Address range: 0x400a94 - 0x400ae8
// Line range:    56 - 64
int main(int argc, char ** argv) {
    // 0x400a94
    if (argc < 2) {
        // 0x400ad4
        return 0;
    }
    int32_t result = 0; // 0x400ab4
    int64_t v1 = (int64_t)argv; // 0x400ab4
    v1 += 8;
    result += hexdump((char *)*(int64_t *)v1);
    int64_t v2 = (int64_t)(argc - 1) + 0xffffffff; // 0x400ac4
    int64_t v3 = v2 & 0xffffffff; // 0x400ac8
    while ((int32_t)v2 != 0) {
        // 0x400ab8
        v1 += 8;
        result += hexdump((char *)*(int64_t *)v1);
        v2 = v3 + 0xffffffff;
        v3 = v2 & 0xffffffff;
    }
    // 0x400ad4
    return result;
}

// --------------- Statically Linked Functions ----------------

// int64_t stat(void);

// --------------- Dynamically Linked Functions ---------------

// int __xstat(int ver, const char * filename, struct stat * stat_buf);
// int fclose(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void * memset(void * s, int c, size_t n);
// void perror(const char * s);
// int puts(const char * s);
// int sprintf(char * restrict s, const char * restrict format, ...);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: llvm (3.8.1)
// Detected functions: 3

