// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080484A0: void _init()
void _init()
{
	fn08048980();
}

// 080485A0: void fn080485A0(Stack int32 dwArg00)
void fn080485A0(int32 dwArg00)
{
	__align(fp + 0x04);
	__syscall(0x80);
	int32 edx_9 = dwArg00 * 0x02 * 0x02;
	globals->ptr80499E8 = fp + 0x04 + edx_9 + 0x04;
	word32 esp_34;
	word32 ecx_35;
	word32 ebx_36;
	word32 eax_37;
	word32 edx_38;
	byte SCZO_39;
	word32 ebp_40;
	byte SZO_41;
	byte C_42;
	!__setfpucw();
	word32 esp_45;
	word32 ecx_46;
	word32 ebx_47;
	word32 eax_48;
	word32 edx_49;
	byte SCZO_50;
	word32 ebp_51;
	byte SZO_52;
	byte C_53;
	!__libc_init();
	atexit(&globals->t80489C0);
	_init();
	exit(fn080488E0(dwArg00, fp + 0x04));
}

// 08048620: void fn08048620()
void fn08048620()
{
	word32 * ebx_24 = globals->a80499F8;
	if (globals->a80499F8 != 0x00)
	{
		do
		{
			<anonymous> * eax_25 = *ebx_24;
			word32 esp_26;
			word32 ebp_27;
			struct Eq_79 * ebx_28;
			byte SCZO_29;
			byte Z_30;
			word32 esi_31;
			word32 eax_32;
			eax_25();
			ebx_24 = (word32 *) &ebx_28->dw0004;
		} while (ebx_28->dw0004 != 0x00);
	}
}

// 08048660: void fn08048660(Stack Eq_90 dwArg04, Stack uint32 dwArg08, Stack Eq_92 dwArg0C)
void fn08048660(Eq_90 dwArg04, uint32 dwArg08, Eq_92 dwArg0C)
{
	sprintf(fp - 0x54, "%08lX:", tLoc70);
	size_t dwLoc58_172 = 0x00;
	while (0x10 > dwLoc58_172)
	{
		sprintf(fp - 0x54 + dwLoc58_172 * 0x03 + 0x09, " %02lX", tLoc70);
		dwLoc58_172 = (Eq_106) ((word32) dwLoc58_172 + 0x01);
	}
	while (true)
	{
		dwLoc58_172 = (Eq_106) ((word32) dwLoc58_172 + 0x01);
		if (dwLoc58_172 > 0x0F)
			break;
		strcat(fp - 0x54, "   ");
	}
	Eq_92 eax_51 = strlen(fp - 0x54);
	strcpy(fp - 0x54 + eax_51, 0x080489DA);
	Eq_106 dwLoc58_110 = 0x00;
	while (0x10 > dwLoc58_110)
	{
		byte cl_122;
		word32 eax_113 = eax_51 + dwLoc58_110;
		if (Mem0[dwArg04 + dwLoc58_110:byte] >u 0x1F && Mem0[dwArg04 + dwLoc58_110:byte] <=u 0x7E)
			cl_122 = Mem0[dwArg04 + dwLoc58_110:byte];
		else
			cl_122 = 0x2E;
		Mem126[eax_113 + (fp - 0x54):byte] = cl_122;
		dwLoc58_110 = dwLoc58_110 + 0x01;
	}
	while (dwLoc58_110 <= 0x0F)
	{
		Mem108[eax_51 + dwLoc58_110 + (fp - 0x54):byte] = 0x20;
		dwLoc58_110 = dwLoc58_110 + 0x01;
	}
	strcpy(fp - 0x54 + eax_51 + dwLoc58_110, 134515166);
	printf("%s\n", fp - 0x54);
}

// 080487F0: Register word32 fn080487F0(Stack (ptr char) dwArg04)
word32 fn080487F0(char * dwArg04)
{
	word32 eax_34;
	if (fn08048950(dwArg04, fp - 0x5C) == 0x00)
	{
		perror(dwArg04);
		eax_34 = 0x01;
	}
	else
	{
		FILE * eax_56 = fopen(dwArg04, "rb");
		if (eax_56 == null)
		{
			perror(dwArg04);
			eax_34 = 0x01;
		}
		else
		{
			uint32 dwLoc18_123 = 0x00;
			while (dwLoc48 > dwLoc18_123)
			{
				Eq_92 eax_106 = fread(fp - 0x14, 0x01, 0x10, eax_56);
				if (eax_106 == 0x00)
					break;
				fn08048660(fp - 0x14, dwLoc18_123, eax_106);
				dwLoc18_123 = (word32) eax_106 + dwLoc18_123;
			}
			fclose(eax_56);
			eax_34 = 0x00;
		}
	}
	return eax_34;
}

// 080488E0: Register word32 fn080488E0(Stack int32 dwArg04, Stack (arr (ptr char)) dwArg08)
word32 fn080488E0(int32 dwArg04, char * dwArg08[])
{
	word32 dwLoc0C_14 = 0x00;
	int32 dwLoc08_15 = 0x01;
	while (dwArg04 > dwLoc08_15)
	{
		dwLoc0C_14 = dwLoc0C_14 + fn080487F0(dwArg08[dwLoc08_15]);
		dwLoc08_15 = dwLoc08_15 + 0x01;
	}
	return dwLoc0C_14;
}

// 08048950: Register int32 fn08048950(Stack (ptr char) dwArg04, Stack (ptr Eq_204) dwArg08)
int32 fn08048950(char * dwArg04, stat * dwArg08)
{
	int32 eax_22 = _xstat(0x01, dwArg04, dwArg08);
	return eax_22;
}

// 08048980: void fn08048980()
void fn08048980()
{
	word32 * ebx_24 = &globals->dw80499EC;
	if (globals->dw80499EC != ~0x00)
	{
		do
		{
			<anonymous> * eax_25 = *ebx_24;
			word32 esp_26;
			word32 ebp_27;
			struct Eq_293 * ebx_28;
			byte SCZO_29;
			byte Z_30;
			word32 esi_31;
			word32 eax_32;
			eax_25();
			ebx_24 = (word32 *) &ebx_28->dwFFFFFFFC;
		} while (ebx_28->dwFFFFFFFC != ~0x00);
	}
}

// 080489C0: void _fini()
void _fini()
{
	fn08048620();
}

