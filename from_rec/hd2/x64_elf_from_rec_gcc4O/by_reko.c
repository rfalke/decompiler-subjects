// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b600DC8 = 0x00; // 0000000000600DC8
uint64 dtor_idx.6343 = 0x00; // 0000000000600DD0
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr600B90 = &g_tFFFFFFFF; // 0000000000600B90
// subject_dtors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a600BA0[] = // 0000000000600BA0
	{
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000400A38: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __gmon_start___GOT = null; // 0000000000600D58
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * puts_GOT = &g_t400556; // 0000000000600D78
<anonymous> * fopen_GOT = &g_t400566; // 0000000000600D80
<anonymous> * __libc_start_main_GOT = &g_t400576; // 0000000000600D88
<anonymous> * __xstat_GOT = &g_t400586; // 0000000000600D90
<anonymous> * sprintf_GOT = &g_t400596; // 0000000000600D98
<anonymous> * fread_GOT = &g_t4005A6; // 0000000000600DA0
<anonymous> * fclose_GOT = &g_t4005B6; // 0000000000600DA8
<anonymous> * perror_GOT = &g_t4005C6; // 0000000000600DB0
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000400528: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	call_gmon_start();
	frame_dummy();
	__do_global_ctors_aux();
}

// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw600BB0 = 0x00; // 0000000000600BB0
// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> g_t400556 = <code>; // 0000000000400556
<anonymous> g_t400566 = <code>; // 0000000000400566
<anonymous> g_t400576 = <code>; // 0000000000400576
<anonymous> g_t400586 = <code>; // 0000000000400586
<anonymous> g_t400596 = <code>; // 0000000000400596
<anonymous> g_t4005A6 = <code>; // 00000000004005A6
<anonymous> g_t4005B6 = <code>; // 00000000004005B6
<anonymous> g_t4005C6 = <code>; // 00000000004005C6
// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_str400A4C[] = "%08lX:"; // 0000000000400A4C
char g_str400A53[] = " %02lX"; // 0000000000400A53
char g_str400A5A[] = "rb"; // 0000000000400A5A
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00000000004005D0: void _start(Register (ptr64 Eq_11) rdx, Stack Eq_12 qwArg00)
void _start(void (* rdx)(), Eq_12 qwArg00)
{
	__align((char *) fp + 8);
	__libc_start_main(&g_t400912, qwArg00, (char *) fp + 8, &g_t400970, &g_t400960, rdx, fp);
	__hlt();
}

// 00000000004005FC: void call_gmon_start()
// Called from:
//      _init
void call_gmon_start()
{
	if (__gmon_start__ != 0x00)
		__gmon_start__();
}

// 0000000000400620: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	if (g_b600DC8 == 0x00)
	{
		uint64 rax_16 = dtor_idx.6343;
		while (rax_16 < 0x00)
		{
			uint64 rax_23 = rax_16 + 0x01;
			dtor_idx.6343 = rax_23;
			(*((char *) g_a600BA0 + rax_23 * 0x08))();
			rax_16 = dtor_idx.6343;
		}
		g_b600DC8 = 0x01;
	}
}

// 0000000000400690: void frame_dummy()
// Called from:
//      _init
void frame_dummy()
{
}

// 00000000004006C0: void dumpline(Register int32 edx, Register (ptr64 byte) rdi)
// Called from:
//      hexdump
void dumpline(int32 edx, byte * rdi)
{
	sprintf(fp - 0x88, "%08lX:", 0x00);
	word32 r15d_215 = (word32) rdi;
	int32 r12d_41 = 0x10;
	if (edx <= 0x10)
		r12d_41 = edx;
	Eq_89 ebp_286;
	Eq_90 r12d_254;
	uint64 rbp_109;
	uint64 r12_258;
	word32 ebx_100;
	uint64 r12_115;
	word32 edx_144 = 0x01;
	if (r12d_41 > 0x00)
	{
		int32 r14d_311 = (word32) rdi;
		byte * rbx_50 = rdi;
		word32 ebp_309 = 0x00;
		do
		{
			sprintf(fp - 0x7F + (int64) ebp_309, " %02lX", 0x00);
			++rbx_50;
			ebp_309 += 0x03;
		} while (r12d_41 > (word32) rbx_50 - r14d_311);
		r12_115 = (uint64) r12d_41;
		if (r12d_41 > 0x0F)
		{
			byte * rdi_85 = fp - 0x88;
			word64 rcx_88 = ~0x00;
			while (rcx_88 != 0x00)
			{
				rdi_85 = rdi_480 + 1;
				--rcx_88;
				rdi_480 = rdi_85;
				if (*rdi_480 != 0x00)
					break;
			}
			ebx_100 = (word32) ~rcx_88 - 0x01;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x88)[(int64) ebx_100 /64 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_264) 0x007C2020;
			rbp_109 = (uint64) (ebx_100 + 0x03);
l00000000004007AF:
			ebp_286 = (word32) rbp_109;
			r12d_254 = (word32) r12_115;
			byte * rdi_210 = rdi + 1 + (uint64) ((word32) r12_115 - 0x01);
			byte * rax_211 = rdi;
			uint64 rbx_220 = (uint64) (ebx_100 - r15d_215 + 0x03);
			do
			{
				uint64 rdx_226 = (uint64) *rax_211;
				word32 rdx_32_32_446 = SLICE(rdx_226, word32, 32);
				if ((byte) (word32) rdx_226 >= 0x7F)
					rdx_226 = SEQ(SEQ(rdx_32_32_446, 0x00), 0x2E);
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x88)[(int64) (word32) (rax_211 + rbx_220)].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (byte) rdx_226;
				++rax_211;
				r12_258 = r12_115;
			} while (rax_211 != rdi_210);
			if (r12d_254 > 0x0F)
			{
l0000000000400801:
				Mem292[fp - 0x88 + (r12d_254 + ebp_286):word16] = 0x7C;
				puts(fp - 0x88);
				return;
			}
l00000000004007A9:
			ebp_286 = (word32) rbp_109;
			r12d_254 = (word32) r12_258;
			word32 eax_270 = (word32) (r12_258 + rbp_109);
			do
			{
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x88)[(int64) eax_270].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_207) 0x20;
				r12d_254 = (word64) r12d_254 + 1;
				++eax_270;
			} while (r12d_254 <= 0x0F);
			goto l0000000000400801;
		}
		edx_144 = (word32) r12_115 + 0x01;
	}
	do
	{
		word64 rcx_125 = ~0x00;
		byte * rdi_127 = fp - 0x88;
		while (rcx_125 != 0x00)
		{
			rdi_127 = rdi_481 + 1;
			--rcx_125;
			rdi_481 = rdi_127;
			if (*rdi_481 != 0x00)
				break;
		}
		fp - 0x89 + ~rcx_125 = (word32 *) 0x00202020;
		uint64 rdx_146 = (uint64) (edx_144 + 0x01);
		edx_144 = (word32) rdx_146;
	} while ((word32) rdx_146 <= 0x10);
	byte * rdi_155 = fp - 0x88;
	word64 rcx_158 = ~0x00;
	while (rcx_158 != 0x00)
	{
		rdi_155 = rdi_482 + 1;
		--rcx_158;
		rdi_482 = rdi_155;
		if (*rdi_482 != 0x00)
			break;
	}
	ebx_100 = (word32) ~rcx_158 - 0x01;
	(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x88)[(int64) ebx_100 /64 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_167) 0x007C2020;
	rbp_109 = (uint64) (ebx_100 + 0x03);
	r12_115 = (uint64) r12d_41;
	if (r12d_41 <= 0x00)
	{
		r12_258 = 0x00;
		goto l00000000004007A9;
	}
	goto l00000000004007AF;
}

// 0000000000400853: Register word32 hexdump(Register (ptr64 char) rdi)
// Called from:
//      main
word32 hexdump(char * rdi)
{
	uint64 rax_122;
	if (__xstat(0x01, rdi, fp - 200) != 0x00)
	{
		perror(rdi);
		rax_122 = 0x01;
	}
	else
	{
		FILE * rax_30 = fopen(rdi, "rb");
		if (rax_30 != null)
		{
			uint64 rbp_39;
			for (rbp_39 = 0x00; rbp_39 < qwLoc98; rbp_39 += (int64) eax_52)
			{
				int32 eax_52 = (word32) fread(fp - 0x38, 0x01, 0x10, rax_30);
				if (eax_52 == 0x00)
					break;
				dumpline(eax_52, fp - 0x38);
			}
			fclose(rax_30);
			rax_122 = 0x00;
		}
		else
		{
			perror(rdi);
			rax_122 = 0x01;
		}
	}
	return (word32) rax_122;
}

// 0000000000400912: void main(Register word64 rsi, Register int32 edi)
void main(word64 rsi, int32 edi)
{
	int32 edi = (word32) rdi;
	if (edi > 0x01)
	{
		word64 * rbx_25 = rsi + 0x08;
		int32 ebp_44 = 0x01;
		do
		{
			hexdump(*rbx_25);
			++ebp_44;
			++rbx_25;
		} while (edi > ebp_44);
	}
}

// 0000000000400960: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 0000000000400970: void __libc_csu_init(Register word64 rdx, Register word64 rsi, Register word32 edi)
void __libc_csu_init(word64 rdx, word64 rsi, word32 edi)
{
	_init();
	int64 rbp_19 = 0x00600B8C - 0x00600B8C;
	if (rbp_19 >> 0x03 != 0x00)
	{
		Eq_385 rbx_39 = 0x00;
		do
		{
			((<anonymous> *[]) 0x00600B8C)[rbx_39]();
			rbx_39 = (word64) rbx_39.u1 + 1;
		} while (rbx_39 < rbp_19 >> 0x03);
	}
}

// 0000000000400A00: void __do_global_ctors_aux()
// Called from:
//      _init
void __do_global_ctors_aux()
{
	<anonymous> * rax_12 = g_ptr600B90;
	if (rax_12 != (<anonymous> *) ~0x00)
	{
		word64 * rbx_16 = &g_ptr600B90;
		do
		{
			rax_12();
			rbx_16 -= 0x08;
			rax_12 = *rbx_16;
		} while (rax_12 != (<anonymous> *) ~0x00);
	}
}

