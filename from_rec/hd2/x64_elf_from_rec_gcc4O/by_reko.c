// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b600DC8 = 0x00; // 0000000000600DC8
uint64 dtor_idx.6343 = 0x00; // 0000000000600DD0
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr600B90 = &g_tFFFFFFFF; // 0000000000600B90
// subject_dtors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a600BA0[] = // 0000000000600BA0
	{
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000400A38: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __gmon_start___GOT = null; // 0000000000600D58
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * puts_GOT = &g_t400556; // 0000000000600D78
<anonymous> * fopen_GOT = &g_t400566; // 0000000000600D80
<anonymous> * __libc_start_main_GOT = &g_t400576; // 0000000000600D88
<anonymous> * __xstat_GOT = &g_t400586; // 0000000000600D90
<anonymous> * sprintf_GOT = &g_t400596; // 0000000000600D98
<anonymous> * fread_GOT = &g_t4005A6; // 0000000000600DA0
<anonymous> * fclose_GOT = &g_t4005B6; // 0000000000600DA8
<anonymous> * perror_GOT = &g_t4005C6; // 0000000000600DB0
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000400528: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	call_gmon_start();
	frame_dummy();
	__do_global_ctors_aux();
}

// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw600BB0 = 0x00; // 0000000000600BB0
// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> g_t400556 = <code>; // 0000000000400556
<anonymous> g_t400566 = <code>; // 0000000000400566
<anonymous> g_t400576 = <code>; // 0000000000400576
<anonymous> g_t400586 = <code>; // 0000000000400586
<anonymous> g_t400596 = <code>; // 0000000000400596
<anonymous> g_t4005A6 = <code>; // 00000000004005A6
<anonymous> g_t4005B6 = <code>; // 00000000004005B6
<anonymous> g_t4005C6 = <code>; // 00000000004005C6
// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_str400A5A[] = "rb"; // 0000000000400A5A
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00000000004005D0: void _start(Register (ptr64 Eq_11) rdx, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void _start(void (* rdx)(), word32 dwArg00, char * ptrArg08)
{
	void * fp;
	word64 qwArg00;
	__align_stack<word64>(&ptrArg08);
	__libc_start_main(&g_t400912, (int32) qwArg00, &ptrArg08, &g_t400970, &g_t400960, rdx, fp);
	__halt();
}

// 00000000004005FC: void call_gmon_start()
// Called from:
//      _init
void call_gmon_start()
{
	if (__gmon_start__ != 0x00)
		__gmon_start__();
}

// 0000000000400620: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	if (g_b600DC8 == 0x00)
	{
		uint64 rax_16 = dtor_idx.6343;
		while (rax_16 < 0x00)
		{
			uint64 rax_23 = rax_16 + 0x01;
			dtor_idx.6343 = rax_23;
			(*((char *) g_a600BA0 + rax_23 * 0x08))();
			rax_16 = dtor_idx.6343;
		}
		g_b600DC8 = 0x01;
	}
}

// 0000000000400690: void frame_dummy()
// Called from:
//      _init
void frame_dummy()
{
}

// 00000000004006C0: void dumpline(Register int32 edx, Register word32 esi, Register (ptr64 Eq_73) rdi)
// Called from:
//      hexdump
void dumpline(int32 edx, word32 esi, union Eq_73 * rdi)
{
	ptr64 fp;
	word64 rsi;
	char bLoc88;
	sprintf(&bLoc88, "%08lX:", (uint32) rsi);
	uint32 r15d_175 = (word32) rdi;
	int32 r12d_41 = 0x10;
	if (edx <= 0x10)
		r12d_41 = edx;
	Eq_92 ebp_246;
	Eq_93 r12d_214;
	uint64 rbp_103;
	uint64 r12_218;
	uint32 ebx_145;
	uint64 r12_109;
	word32 edx_128 = 0x01;
	if (r12d_41 > 0x00)
	{
		int32 r14d_271 = (word32) rdi;
		union Eq_73 * rbx_53 = rdi;
		word32 ebp_269 = 0x00;
		do
		{
			sprintf(fp - 0x7F + (int64) ebp_269, " %02lX", (uint32) rbx_53->u0);
			rbx_53 = (union Eq_73 *) ((char *) rbx_53 + 1);
			ebp_269 += 0x03;
		} while (r12d_41 > (word32) rbx_53 - r14d_271);
		r12_109 = (uint64) r12d_41;
		if (r12d_41 > 0x0F)
		{
			ebx_145 = strlen(&bLoc88);
			(&bLoc88)[(int64) ebx_145 /64 4].u0 = 0x007C2020;
			rbp_103 = (uint64) (ebx_145 + 0x03);
			goto l00000000004007AF;
		}
		edx_128 = (word32) r12_109 + 0x01;
	}
	do
	{
		Mem127[fp - 0x89 + (strlen(&bLoc88) - ~0x00):word32] = 0x00202020;
		uint64 rdx_130 = (uint64) (edx_128 + 0x01);
		edx_128 = (word32) rdx_130;
	} while ((word32) rdx_130 <= 0x10);
	ebx_145 = strlen(&bLoc88);
	(&bLoc88)[(int64) ebx_145 /64 4].u0 = 0x007C2020;
	rbp_103 = (uint64) (ebx_145 + 0x03);
	r12_109 = (uint64) r12d_41;
	if (r12d_41 <= 0x00)
	{
		r12_218 = 0x00;
		goto l00000000004007A9;
	}
l00000000004007AF:
	ebp_246 = (word32) rbp_103;
	r12d_214 = (word32) r12_109;
	union Eq_73 * rdi_170 = (char *) rdi + 1 + (uint64) ((word32) r12_109 - 0x01);
	union Eq_73 * rax_171 = rdi;
	uint64 rbx_180 = (uint64) (ebx_145 - r15d_175 + 0x03);
	do
	{
		uint64 rdx_186 = (uint64) rax_171->u0;
		word32 rdx_32_32_369 = SLICE(rdx_186, word32, 32);
		if ((byte) rdx_186 >= 0x7F)
			rdx_186 = SEQ(rdx_32_32_369, 0x00, 0x2E);
		(&bLoc88)[(int64) (word32) (&rax_171->u0 + rbx_180)].u0 = (byte) rdx_186;
		rax_171 = (union Eq_73 *) ((char *) rax_171 + 1);
		r12_218 = r12_109;
	} while (rax_171 != rdi_170);
	if (r12d_214 > 0x0F)
	{
l0000000000400801:
		Mem252[&bLoc88 + (r12d_214 + ebp_246):word16] = 0x7C;
		puts(&bLoc88);
		return;
	}
l00000000004007A9:
	ebp_246 = (word32) rbp_103;
	r12d_214 = (word32) r12_218;
	word32 eax_230 = (word32) (r12_218 + rbp_103);
	do
	{
		(&bLoc88)[(int64) eax_230].u0 = 0x20;
		r12d_214 = (word64) r12d_214 + 1;
		++eax_230;
	} while (r12d_214 <= 0x0F);
	goto l0000000000400801;
}

// 0000000000400853: Register word32 hexdump(Register (ptr64 char) rdi)
// Called from:
//      main
word32 hexdump(char * rdi)
{
	word64 qwLocC8;
	word64 qwLoc38;
	uint64 qwLoc98;
	uint64 rax_133;
	if (__xstat(1, rdi, &qwLocC8) != 0x00)
	{
		perror(rdi);
		rax_133 = 0x01;
	}
	else
	{
		FILE * rax_31 = fopen(rdi, "rb");
		if (rax_31 != null)
		{
			uint64 rbp_41;
			for (rbp_41 = 0x00; rbp_41 < qwLoc98; rbp_41 += (int64) eax_54)
			{
				int32 eax_54 = (word32) fread(&qwLoc38, 0x01, 0x10, rax_31);
				if (eax_54 == 0x00)
					break;
				dumpline(eax_54, (word32) rbp_41, &qwLoc38);
			}
			fclose(rax_31);
			rax_133 = 0x00;
		}
		else
		{
			perror(rdi);
			rax_133 = 0x01;
		}
	}
	return (word32) rax_133;
}

// 0000000000400912: void main(Register word64 rsi, Register int32 edi)
void main(word64 rsi, int32 edi)
{
	word64 rdi;
	int32 edi = (word32) rdi;
	if (edi > 0x01)
	{
		word64 * rbx_25 = rsi + 8;
		int32 ebp_45 = 0x01;
		do
		{
			hexdump(*rbx_25);
			++ebp_45;
			++rbx_25;
		} while (edi > ebp_45);
	}
}

// 0000000000400960: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 0000000000400970: void __libc_csu_init(Register word64 rdx, Register word64 rsi, Register word32 edi)
void __libc_csu_init(word64 rdx, word64 rsi, word32 edi)
{
	_init();
	int64 rbp_19 = (<anonymous> * (*)[]) 0x00600B8C - (<anonymous> * (*)[]) 0x00600B8C;
	if (rbp_19 >> 0x03 != 0x00)
	{
		Eq_352 rbx_42 = 0x00;
		do
		{
			((<anonymous> *[]) 0x00600B8C)[rbx_42]();
			rbx_42 = (word64) rbx_42.u1 + 1;
		} while (rbx_42 < rbp_19 >> 0x03);
	}
}

// 0000000000400A00: void __do_global_ctors_aux()
// Called from:
//      _init
void __do_global_ctors_aux()
{
	<anonymous> * rax_12 = g_ptr600B90;
	if (rax_12 != (<anonymous> *) ~0x00)
	{
		word64 * rbx_16 = &g_ptr600B90;
		do
		{
			rax_12();
			rbx_16 -= 0x08;
			rax_12 = *rbx_16;
		} while (rax_12 != (<anonymous> *) ~0x00);
	}
}

