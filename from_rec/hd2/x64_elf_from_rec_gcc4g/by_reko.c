// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b600F00 = 0x00; // 0000000000600F00
uint64 dtor_idx.6343 = 0x00; // 0000000000600F08
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr600CB0 = &g_tFFFFFFFF; // 0000000000600CB0
// subject_dtors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a600CC0[] = // 0000000000600CC0
	{
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000400B68: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __gmon_start___GOT = null; // 0000000000600E78
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * puts_GOT = &g_t400606; // 0000000000600E98
<anonymous> * fopen_GOT = &g_t400616; // 0000000000600EA0
<anonymous> * __libc_start_main_GOT = &g_t400626; // 0000000000600EA8
<anonymous> * strlen_GOT = &g_t400636; // 0000000000600EB0
<anonymous> * __xstat_GOT = &g_t400646; // 0000000000600EB8
<anonymous> * sprintf_GOT = &g_t400656; // 0000000000600EC0
<anonymous> * strcat_GOT = &g_t400666; // 0000000000600EC8
<anonymous> * memcpy_GOT = &g_t400676; // 0000000000600ED0
<anonymous> * fread_GOT = &g_t400686; // 0000000000600ED8
<anonymous> * fclose_GOT = &g_t400696; // 0000000000600EE0
<anonymous> * perror_GOT = &g_t4006A6; // 0000000000600EE8
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00000000004005D8: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	call_gmon_start();
	frame_dummy();
	__do_global_ctors_aux();
}

// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw600CD0 = 0x00; // 0000000000600CD0
// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> g_t400606 = <code>; // 0000000000400606
<anonymous> g_t400616 = <code>; // 0000000000400616
<anonymous> g_t400626 = <code>; // 0000000000400626
<anonymous> g_t400636 = <code>; // 0000000000400636
<anonymous> g_t400646 = <code>; // 0000000000400646
<anonymous> g_t400656 = <code>; // 0000000000400656
<anonymous> g_t400666 = <code>; // 0000000000400666
<anonymous> g_t400676 = <code>; // 0000000000400676
<anonymous> g_t400686 = <code>; // 0000000000400686
<anonymous> g_t400696 = <code>; // 0000000000400696
<anonymous> g_t4006A6 = <code>; // 00000000004006A6
// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_str400B8A[] = "   "; // 0000000000400B8A
void g_v400B8E = ??void??; // 0000000000400B8E
void g_v400B92 = ??void??; // 0000000000400B92
char g_str400B94[] = "rb"; // 0000000000400B94
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00000000004006B0: void _start(Register (ptr64 Eq_11) rdx, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void _start(void (* rdx)(), word32 dwArg00, char * ptrArg08)
{
	void * fp;
	word64 qwArg00;
	__align_stack<word64>(&ptrArg08);
	__libc_start_main(&g_t400A34, (int32) qwArg00, &ptrArg08, &g_t400A90, &g_t400A80, rdx, fp);
	__halt();
}

// 00000000004006DC: void call_gmon_start()
// Called from:
//      _init
void call_gmon_start()
{
	if (__gmon_start__ != 0x00)
		__gmon_start__();
}

// 0000000000400700: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	if (g_b600F00 == 0x00)
	{
		uint64 rax_16 = dtor_idx.6343;
		while (rax_16 < 0x00)
		{
			uint64 rax_23 = rax_16 + 0x01;
			dtor_idx.6343 = rax_23;
			(*((char *) g_a600CC0 + rax_23 * 0x08))();
			rax_16 = dtor_idx.6343;
		}
		g_b600F00 = 0x01;
	}
}

// 0000000000400770: void frame_dummy()
// Called from:
//      _init
void frame_dummy()
{
}

// 0000000000400794: void dumpline(Register Eq_71 edx, Register word32 esi, Register (ptr64 word64) rdi)
// Called from:
//      hexdump
void dumpline(Eq_71 edx, word32 esi, word64 * rdi)
{
	word64 rsi;
	char bLoc78;
	sprintf(&bLoc78, "%08lX:", (uint32) rsi);
	Eq_71 dwLoc8C_230 = edx;
	if (edx > 0x10)
		dwLoc8C_230.u0 = 0x10;
	Eq_71 dwLoc20_232 = 0x00;
	while (dwLoc20_232 < dwLoc8C_230)
	{
		sprintf(&bLoc78 + ((int64) (dwLoc20_232 *32 0x03) + 9), " %02lX", (uint32) rdi[(int64) dwLoc20_232]);
		dwLoc20_232 = (word32) dwLoc20_232.u0 + 1;
	}
	while (true)
	{
		dwLoc20_232 = (word64) dwLoc20_232 + 1;
		if ((int8) (dwLoc20_232 <= 0x0F) == 0x00)
			break;
		strcat(&bLoc78, "   ");
	}
	Eq_124 eax_98 = (word32) strlen(&bLoc78);
	memcpy(&bLoc78 + (int64) eax_98, &g_v400B8E, 0x04);
	Eq_71 dwLoc20_241 = 0x00;
	while (dwLoc20_241 < dwLoc8C_230)
	{
		byte al_166;
		word32 edx_163 = (word64) dwLoc20_241 + ((word64) eax_98 + 3);
		if (rdi[(int64) dwLoc20_241] > 0x1F && rdi[(int64) dwLoc20_241] <= 0x7E)
			al_166 = (byte) rdi[(int64) dwLoc20_241];
		else
			al_166 = 0x2E;
		(&bLoc78)[(int64) edx_163].u0 = al_166;
		dwLoc20_241 = (word64) dwLoc20_241 + 1;
	}
	while (dwLoc20_241 <= 0x0F)
	{
		(&bLoc78)[(int64) ((word64) dwLoc20_241 + ((word64) eax_98 + 3))].u0 = 0x20;
		dwLoc20_241 = (word64) dwLoc20_241 + 1;
	}
	memcpy(&bLoc78 + ((word64) dwLoc20_241 + ((word64) eax_98 + 3)), &g_v400B92, 0x02);
	puts(&bLoc78);
}

// 0000000000400942: Register word32 hexdump(Register (ptr64 char) rdi)
// Called from:
//      main
word32 hexdump(char * rdi)
{
	word64 qwLocC8;
	word64 qwLoc38;
	up64 qwLoc98;
	uint64 rax_126;
	if (stat(&qwLocC8, rdi) != 0x00)
	{
		perror(rdi);
		rax_126 = 0x01;
	}
	else
	{
		FILE * rax_29 = fopen(rdi, "rb");
		if (rax_29 == null)
		{
			perror(rdi);
			rax_126 = 0x01;
		}
		else
		{
			up64 qwLoc20_101;
			for (qwLoc20_101 = 0x00; qwLoc98 > qwLoc20_101; qwLoc20_101 += (int64) eax_48)
			{
				Eq_71 eax_48 = (word32) fread(&qwLoc38, 0x01, 0x10, rax_29);
				if (eax_48 == 0x00)
					break;
				dumpline(eax_48, (word32) qwLoc20_101, &qwLoc38);
			}
			fclose(rax_29);
			rax_126 = 0x00;
		}
	}
	return (word32) rax_126;
}

// 0000000000400A34: void main(Register (arr (ptr64 char)) rsi, Register int32 edi)
void main(char * rsi[], int32 edi)
{
	word64 rdi;
	int32 edi = (word32) rdi;
	int32 dwLoc10_57;
	for (dwLoc10_57 = 0x01; dwLoc10_57 < edi; ++dwLoc10_57)
		hexdump(rsi[(int64) dwLoc10_57]);
}

// 0000000000400A80: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 0000000000400A90: void __libc_csu_init(Register word64 rdx, Register word64 rsi, Register word32 edi)
void __libc_csu_init(word64 rdx, word64 rsi, word32 edi)
{
	_init();
	int64 rbp_19 = (<anonymous> * (*)[]) 0x00600CAC - (<anonymous> * (*)[]) 0x00600CAC;
	if (rbp_19 >> 0x03 != 0x00)
	{
		Eq_290 rbx_42 = 0x00;
		do
		{
			((<anonymous> *[]) 0x00600CAC)[rbx_42]();
			rbx_42 = (word64) rbx_42.u1 + 1;
		} while (rbx_42 < rbp_19 >> 0x03);
	}
}

// 0000000000400B20: Register int32 stat(Register (ptr64 Eq_206) rsi, Register (ptr64 char) rdi)
// Called from:
//      hexdump
int32 stat(struct stat * rsi, char * rdi)
{
	return __xstat(1, rdi, rsi);
}

// 0000000000400B30: void __do_global_ctors_aux()
// Called from:
//      _init
void __do_global_ctors_aux()
{
	<anonymous> * rax_12 = g_ptr600CB0;
	if (rax_12 != (<anonymous> *) ~0x00)
	{
		word64 * rbx_16 = &g_ptr600CB0;
		do
		{
			rax_12();
			rbx_16 -= 0x08;
			rax_12 = *rbx_16;
		} while (rax_12 != (<anonymous> *) ~0x00);
	}
}

