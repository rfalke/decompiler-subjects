//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _stat64i32 {
    int32_t e0;
    int16_t e1;
    int16_t e2;
    int16_t e3;
    int16_t e4;
    int16_t e5;
    int32_t e6;
    int32_t e7;
    int64_t e8;
    int64_t e9;
    int64_t e10;
};

// ------------------- Function Prototypes --------------------

int32_t _40___security_check_cookie_40_4(void);
int32_t function_401000(int32_t a1, int32_t a2);
int32_t function_401140(void);

// --------------------- Global Variables ---------------------

int32_t g1 = -0x44bf19b2; // 0x403000
int32_t g2;

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x401132
int32_t function_401000(int32_t a1, int32_t a2) {
    // 0x401000
    int32_t str; // bp-84, 0x401000
    int32_t v1; // 0x401000
    sprintf((char *)&str, "%08lX:", v1);
    int32_t v2; // bp-104, 0x401000
    int32_t v3 = &v2; // 0x401031
    int32_t v4 = a2 < 16 ? a2 : 16;
    int32_t v5 = 0; // 0x401042
    if (v4 < 1) {
        goto lab_0x401071;
    } else {
        // 0x401044
        int32_t v6; // bp-75, 0x401000
        int32_t v7 = &v6; // 0x401048
        uint32_t v8 = 0;
        int32_t v9 = *(int32_t *)(v3 + 16); // 0x401050
        *(int32_t *)(v3 - 4) = (int32_t)*(char *)(v9 + v8);
        *(int32_t *)(v3 - 8) = (int32_t)" %02lX";
        *(int32_t *)(v3 - 12) = v7;
        sprintf((char *)&g2, (char *)&g2);
        v5 = v8 + 1;
        v7 += 3;
        while (v5 < v4) {
            // 0x401050
            v8 = v5;
            v9 = *(int32_t *)(v3 + 16);
            *(int32_t *)(v3 - 4) = (int32_t)*(char *)(v9 + v8);
            *(int32_t *)(v3 - 8) = (int32_t)" %02lX";
            *(int32_t *)(v3 - 12) = v7;
            sprintf((char *)&g2, (char *)&g2);
            v5 = v8 + 1;
            v7 += 3;
        }
        // 0x40106c
        if (v8 > 14) {
            goto lab_0x401094;
        } else {
            goto lab_0x401071;
        }
    }
  lab_0x401071:;
    int32_t v10 = 20 + v3; // 0x401085
    int32_t v11 = v10; // 0x40108b
    while (*(char *)v10 != 0) {
        // 0x401085
        v10 = v11 + 1;
        v11 = v10;
    }
    int32_t v12 = 15 - v5; // 0x40108d
    *(int32_t *)v10 = 0x202020;
    int32_t v13 = v12; // 0x401092
    while (v12 != 0) {
        // 0x401080
        v10 = 20 + v3;
        v11 = v10;
        while (*(char *)v10 != 0) {
            // 0x401085
            v10 = v11 + 1;
            v11 = v10;
        }
        // 0x40108d
        v12 = v13 - 1;
        *(int32_t *)v10 = 0x202020;
        v13 = v12;
    }
    goto lab_0x401094;
  lab_0x401094:;
    int32_t v14 = v3 + 20; // 0x401094
    int32_t v15 = v14;
    int32_t v16 = v15 + 1; // 0x4010a5
    while (*(char *)v15 != 0) {
        // 0x4010a0
        v15 = v16;
        v16 = v15 + 1;
    }
    // 0x4010a7
    *(int32_t *)v15 = 0x7c2020;
    int32_t v17 = v15 + 3;
    int32_t v18 = 0; // 0x4010ba
    int32_t * v19; // 0x401000
    int32_t * v20; // 0x401000
    int32_t v21; // 0x401000
    if (v4 < 1) {
        goto lab_0x4010e4;
    } else {
        uint32_t v22 = 0;
        char v23 = *(char *)(*(int32_t *)(v3 + 16) + v22); // 0x4010c4
        *(char *)(v22 + v17) = v23 < 127 ? v23 : 46;
        int32_t v24 = v22 + 1; // 0x4010da
        while (v24 < v4) {
            // 0x4010c0
            v22 = v24;
            v23 = *(char *)(*(int32_t *)(v3 + 16) + v22);
            *(char *)(v22 + v17) = v23 < 127 ? v23 : 46;
            v24 = v22 + 1;
        }
        // 0x4010df
        v18 = v24;
        if (v22 > 14) {
            // 0x4010df
            v20 = (int32_t *)(v3 - 8);
            v19 = (int32_t *)(v3 - 4);
            v21 = v24;
            goto lab_0x401100;
        } else {
            goto lab_0x4010e4;
        }
    }
  lab_0x4010e4:;
    int32_t * v25 = (int32_t *)(v3 - 4);
    *v25 = 16 - v18;
    int32_t * v26 = (int32_t *)(v3 - 8);
    *v26 = 32;
    *(int32_t *)(v3 - 12) = v18 + v17;
    memset(&g2, (int32_t)&g2, (int32_t)&g2);
    v20 = v26;
    v19 = v25;
    v21 = 16;
    goto lab_0x401100;
  lab_0x401100:
    // 0x401100
    *v19 = v14;
    *v20 = (int32_t)"%s\n";
    *(int16_t *)(v21 + v17) = 124;
    printf((char *)&g2);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x401140 - 0x4011fc
int32_t function_401140(void) {
    // 0x401140
    int32_t v1; // 0x401140
    char * str = (char *)v1; // 0x401159
    int32_t v2; // bp-76, 0x401140
    if (_stat64i32(str, (struct _stat64i32 *)&v2) != 0) {
        // 0x401167
        perror(str);
        return _40___security_check_cookie_40_4();
    }
    struct _IO_FILE * file = fopen(str, "rb"); // 0x40118f
    if (file == NULL) {
        // 0x401167
        perror(str);
        return _40___security_check_cookie_40_4();
    }
    int32_t v3 = (int32_t)file; // 0x40118f
    int32_t v4; // bp-92, 0x401140
    int32_t v5 = &v4; // 0x401197
    int32_t * v6 = (int32_t *)(v5 - 4);
    if (v1 == 0) {
        // 0x4011dd
        *v6 = v3;
        fclose((struct _IO_FILE *)&g2);
        return _40___security_check_cookie_40_4();
    }
    int32_t * v7 = (int32_t *)(v5 - 8); // 0x4011b1
    int32_t v8 = v5 + 68; // 0x4011b3
    int32_t v9 = 0; // 0x4011d2
    *v6 = v3;
    *v7 = 16;
    *(int32_t *)(v5 - 12) = 1;
    *(int32_t *)(v5 - 16) = v8;
    int32_t items_read = fread(&g2, (int32_t)&g2, (int32_t)&g2, (struct _IO_FILE *)&g2); // 0x4011ba
    while (items_read != 0) {
        // 0x4011c5
        *v6 = items_read;
        *v7 = v8;
        function_401000((int32_t)&g2, (int32_t)&g2);
        v9 += items_read;
        if (v9 >= *(int32_t *)(v5 + 36)) {
            // break -> 0x4011dd
            break;
        }
        *v6 = v3;
        *v7 = 16;
        *(int32_t *)(v5 - 12) = 1;
        *(int32_t *)(v5 - 16) = v8;
        items_read = fread(&g2, (int32_t)&g2, (int32_t)&g2, (struct _IO_FILE *)&g2);
    }
    // 0x4011dd
    *v6 = v3;
    fclose((struct _IO_FILE *)&g2);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x401200 - 0x40123b
int main(int argc, char ** argv) {
    int32_t v1 = 1; // 0x401214
    if (argc < 2) {
        // 0x401232
        return 0;
    }
    int32_t result = 0; // 0x401214
    v1++;
    result += function_401140();
    while (v1 != argc) {
        // 0x401220
        v1++;
        result += function_401140();
    }
    // 0x401232
    return result;
}

// Address range: 0x40123b - 0x40124a
int32_t _40___security_check_cookie_40_4(void) {
    // 0x40123b
    int32_t result; // 0x40123b
    if (result != g1) {
        // 0x401245
        return ___report_gsfailure();
    }
    // 0x401243
    return result;
}

// --------------- Statically Linked Functions ----------------

// int32_t ___report_gsfailure(void);

// --------------- Dynamically Linked Functions ---------------

// int __cdecl _stat64i32(_In_z_ char const * FileName, _Out_ struct _stat64i32 * Stat);
// int fclose(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void * memset(void * s, int c, size_t n);
// void perror(const char * s);
// int printf(const char * restrict format, ...);
// int sprintf(char * restrict s, const char * restrict format, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (9.0)
// Detected functions: 4

