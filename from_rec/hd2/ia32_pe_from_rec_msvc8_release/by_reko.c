// subject_PE_header.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_656 g_t400000 = // 00400000
	{
		23117,
		232,
	};
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 g_dw403000 = 0xBB40E64E; // 00403000
ui32 g_dw403004 = 1153374641; // 00403004
Eq_4 g_t403018 = 0x00; // 00403018
Eq_449 g_t40301C = // 0040301C
	{
		0
	};
char * (* g_ptr403020)[] = null; // 00403020
word32 g_dw403024 = 0x00; // 00403024
Eq_449 g_t403030 = // 00403030
	{
		0
	};
word32 g_dw403034 = 0x00; // 00403034
word32 g_dw403038 = 0x00; // 00403038
word32 g_dw40303C = 0x00; // 0040303C
Eq_4 g_t403044 = 0x00; // 00403044
Eq_182 g_t403088 = 0; // 00403088
word32 g_dw403090 = 0x00; // 00403090
struct Eq_320 * g_ptr40311C = null; // 0040311C
struct Eq_319 * g_ptr403120 = null; // 00403120
struct Eq_8 * g_ptr403124 = null; // 00403124
struct Eq_9 * g_ptr403128 = null; // 00403128
FILE * g_ptr40312C = null; // 0040312C
Eq_4 g_t403130 = 0x00; // 00403130
Eq_4 g_t403134 = 0x00; // 00403134
Eq_2 g_t403138 = // 00403138
	{
		0
	};
ui32 g_dw40313C = 0x00; // 0040313C
Eq_182 g_t403140 = 0; // 00403140
Eq_3 g_t403144 = // 00403144
	{
		0x00
	};
Eq_4 g_t403148 = 0x00; // 00403148
struct Eq_318 * g_ptr40314C = null; // 0040314C
Eq_348 g_t403150 = // 00403150
	{
		0x00
	};
ptr32 g_ptr403154 = 0x00; // 00403154
struct Eq_317 * g_ptr403158 = null; // 00403158
word32 g_dw403370 = 0x00; // 00403370
Eq_513 g_t403374 = 0; // 00403374
<anonymous> * g_ptr403380 = null; // 00403380
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__GetCurrentProcessId = &g_t2602; // 00402000
<anonymous> * __imp__GetCurrentThreadId = &g_t25EC; // 00402004
<anonymous> * __imp__GetTickCount = &g_t25DC; // 00402008
<anonymous> * __imp__QueryPerformanceCounter = &g_t25C2; // 0040200C
<anonymous> * __imp__IsDebuggerPresent = &g_t25AE; // 00402010
<anonymous> * __imp__SetUnhandledExceptionFilter = &g_t2590; // 00402014
<anonymous> * __imp__UnhandledExceptionFilter = &g_t2574; // 00402018
<anonymous> * __imp__GetCurrentProcess = &g_t2560; // 0040201C
<anonymous> * __imp__TerminateProcess = &g_t254C; // 00402020
<anonymous> * __imp__InterlockedCompareExchange = &g_t252E; // 00402024
<anonymous> * __imp__Sleep = &g_t2526; // 00402028
<anonymous> * __imp__InterlockedExchange = &g_t2510; // 0040202C
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t2618; // 00402030
<anonymous> * __imp___initterm = &g_t23D8; // 00402038
<anonymous> * __imp___initterm_e = &g_t23E4; // 0040203C
<anonymous> * __imp___configthreadlocale = &g_t23F2; // 00402040
<anonymous> * __imp____setusermatherr = &g_t2408; // 00402044
<anonymous> * __imp___adjust_fdiv = &g_t241C; // 00402048
<anonymous> * __imp____p__commode = &g_t242C; // 0040204C
<anonymous> * __imp____p__fmode = &g_t243C; // 00402050
<anonymous> * __imp___encode_pointer = &g_t244A; // 00402054
<anonymous> * __imp____set_app_type = &g_t245C; // 00402058
<anonymous> * __imp____initenv = &g_t23CC; // 0040205C
<anonymous> * __imp__?terminate@@YAXXZ = &g_t2484; // 00402060
<anonymous> * __imp___unlock = &g_t2498; // 00402064
<anonymous> * __imp____dllonexit = &g_t24A2; // 00402068
<anonymous> * __imp___lock = &g_t24B0; // 0040206C
<anonymous> * __imp___onexit = &g_t24B8; // 00402070
<anonymous> * __imp___decode_pointer = &g_t24C2; // 00402074
<anonymous> * __imp___except_handler4_common = &g_t24D4; // 00402078
<anonymous> * __imp___invoke_watson = &g_t24EE; // 0040207C
<anonymous> * __imp___controlfp_s = &g_t2500; // 00402080
<anonymous> * __imp__exit = &g_t23C4; // 00402084
<anonymous> * __imp___XcptFilter = &g_t23B6; // 00402088
<anonymous> * __imp___exit = &g_t23AE; // 0040208C
<anonymous> * __imp___cexit = &g_t23A4; // 00402090
<anonymous> * __imp____getmainargs = &g_t2394; // 00402094
<anonymous> * __imp___amsg_exit = &g_t2386; // 00402098
<anonymous> * __imp___stat64i32 = &g_t236C; // 0040209C
<anonymous> * __imp__fclose = &g_t2362; // 004020A0
<anonymous> * __imp__fread = &g_t235A; // 004020A4
<anonymous> * __imp__fopen = &g_t2352; // 004020A8
<anonymous> * __imp__printf = &g_t2348; // 004020AC
<anonymous> * __imp__perror = &g_t233E; // 004020B0
<anonymous> * __imp___crt_debugger_hook = &g_t246E; // 004020B4
<anonymous> * __imp__sprintf = &g_t2334; // 004020B8
<anonymous> * __imp__memset = &g_t2640; // 004020BC
Eq_560 g_t4020C4 = null; // 004020C4
Eq_561 g_t4020CC = null; // 004020CC
Eq_530 g_t4020D0 = null; // 004020D0
Eq_531 g_t4020DC = null; // 004020DC
char g_str402104[] = "%08lX:"; // 00402104
word32 g_dw402114 = 0x00202020; // 00402114
char g_str402118[] = "%s\n"; // 00402118
char g_str40211C[] = "rb"; // 0040211C
word32 g_dw402270 = 0x2602; // 00402270
word32 g_dw402274 = 0x25EC; // 00402274
word32 g_dw402278 = 9692; // 00402278
word32 g_dw40227C = 9666; // 0040227C
word32 g_dw402280 = 9646; // 00402280
word32 g_dw402284 = 9616; // 00402284
word32 g_dw402288 = 9588; // 00402288
word32 g_dw40228C = 0x2560; // 0040228C
word32 g_dw402290 = 0x254C; // 00402290
word32 g_dw402294 = 0x252E; // 00402294
word32 g_dw402298 = 0x2526; // 00402298
word32 g_dw40229C = 9488; // 0040229C
word32 g_dw4022A0 = 0x2618; // 004022A0
word32 g_dw4022A8 = 0x23D8; // 004022A8
word32 g_dw4022AC = 9188; // 004022AC
word32 g_dw4022B0 = 0x23F2; // 004022B0
word32 g_dw4022B4 = 9224; // 004022B4
word32 g_dw4022B8 = 9244; // 004022B8
word32 g_dw4022BC = 0x242C; // 004022BC
word32 g_dw4022C0 = 0x243C; // 004022C0
word32 g_dw4022C4 = 0x244A; // 004022C4
word32 g_dw4022C8 = 0x245C; // 004022C8
word32 g_dw4022CC = 0x23CC; // 004022CC
word32 g_dw4022D0 = 0x2484; // 004022D0
word32 g_dw4022D4 = 0x2498; // 004022D4
word32 g_dw4022D8 = 0x24A2; // 004022D8
word32 g_dw4022DC = 9392; // 004022DC
word32 g_dw4022E0 = 9400; // 004022E0
word32 g_dw4022E4 = 0x24C2; // 004022E4
word32 g_dw4022E8 = 0x24D4; // 004022E8
word32 g_dw4022EC = 0x24EE; // 004022EC
word32 g_dw4022F0 = 0x2500; // 004022F0
word32 g_dw4022F4 = 0x23C4; // 004022F4
word32 g_dw4022F8 = 0x23B6; // 004022F8
word32 g_dw4022FC = 0x23AE; // 004022FC
word32 g_dw402300 = 0x23A4; // 00402300
word32 g_dw402304 = 0x2394; // 00402304
word32 g_dw402308 = 9094; // 00402308
word32 g_dw40230C = 0x236C; // 0040230C
word32 g_dw402310 = 0x2362; // 00402310
word32 g_dw402314 = 9050; // 00402314
word32 g_dw402318 = 0x2352; // 00402318
word32 g_dw40231C = 0x2348; // 0040231C
word32 g_dw402320 = 0x233E; // 00402320
word32 g_dw402324 = 0x246E; // 00402324
word32 g_dw402328 = 0x2334; // 00402328
word32 g_dw40232C = 9792; // 0040232C
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 fn00401000(Register Eq_3 ecx, Register Eq_4 ebx, Register Eq_3 ebp, Register Eq_4 esi, Register (ptr32 Eq_7) edi, Register (ptr16 Eq_8) es, Register (ptr16 Eq_9) ds, Stack Eq_2 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fn00401140
Eq_2 fn00401000(Eq_3 ecx, Eq_4 ebx, Eq_3 ebp, Eq_4 esi, FILE * edi, struct Eq_8 * es, struct Eq_9 * ds, Eq_2 dwArg04, Eq_4 dwArg08)
{
	Eq_12 fp;
	char bLoc54;
	ui32 eax_7 = g_dw403000 ^ fp - 88;
	sprintf(&bLoc54, "%08lX:", ecx);
	Eq_4 ebp_17 = dwArg08;
	struct Eq_29 * esp_306 = fp - 0x68;
	if (dwArg08 > 0x10)
		ebp_17 = 0x10;
	size_t esi_38 = 0x00;
	if (ebp_17 > 0x00)
	{
		ptr32 edi_46 = fp - 0x4B;
		do
		{
			struct Eq_48 * esp_52 = esp_306 - 4;
			esp_52->dw0000 = (word32) *((word32) esi_38 + esp_306->ptr0010);
			esp_52->dwFFFFFFFC = 0x0040210C;
			esp_52->ptrFFFFFFF8 = edi_46;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			char * stackArg4 = (char *) <invalid>;
			char * stackArg8 = (char *) <invalid>;
			sprintf(stackArg4, stackArg8, 0x00);
			word32 esp_62 = <invalid>;
			esi_38 = (Eq_4) ((word32) esi_38 + 1);
			esp_306 = esp_62 + 0x0C;
			edi_46 += 0x03;
		} while (esi_38 < ebp_17);
		if (esi_38 >= 0x10)
		{
l00401094:
			byte * eax_107 = fp - 84;
			Eq_2 edx_108 = fp - 83;
			do
			{
				eax_107 = eax_415 + 1;
				eax_415 = eax_107;
			} while (*eax_415 != 0x00);
			Eq_122 eax_118 = eax_107 - (fp - 83);
			Mem121[fp - 84 + eax_118:word32] = 0x007C2020;
			Eq_4 esi_123 = 0x00;
			if (ebp_17 > 0x00)
			{
				word32 ecx_134 = fp - 84 + (eax_118 + 0x03);
				do
				{
					Eq_126 al_146;
					edx_108 = dwArg04;
					byte al_139 = Mem136[dwArg04 + esi_123:byte];
					if (al_139 >= 0x20)
					{
						al_146 = al_139;
						if (al_139 > 0x7E)
							goto l004010D2;
					}
					else
					{
l004010D2:
						al_146.u0 = 0x2E;
					}
					Mem154[ecx_134 + esi_123:byte] = al_146;
					++esi_123;
				} while (esi_123 < ebp_17);
				if (esi_123 >= 0x10)
				{
l00401100:
					Mem196[fp - 84 + ((eax_118 + 0x03) + esi_123):word16] = 0x7C;
					fn0040123B(printf("%s\n", fp - 84), eax_7 ^ fp - 88, edx_108, ebx, ebp, esi, edi, es, ds, ebx);
					return edx_108;
				}
			}
			Eq_4 edi_165 = 0x10 - esi_123;
			memset(fp - 84 + ((eax_118 + 0x03) + esi_123), 0x20, edi_165);
			esi_123 += edi_165;
			goto l00401100;
		}
	}
	word32 edx_77 = g_dw402114;
	word32 ecx_80 = 0x10 - esi_38;
	do
	{
		struct Eq_86 * edi_87 = (char *) &esp_306->ptr0010 + 3 + 1;
		do
		{
			edi_87 = edi_414 + 1;
			edi_414 = edi_87;
		} while (edi_414->dw0000 != 0x00);
		edi_87->dw0000 = edx_77;
		--ecx_80;
	} while (ecx_80 != 0x00);
	goto l00401094;
}

// 00401140: Register word32 fn00401140(Register (ptr32 char) ecx, Register Eq_4 ebx, Register Eq_3 ebp, Register Eq_4 esi, Register (ptr32 Eq_7) edi, Register (ptr16 Eq_8) es, Register (ptr16 Eq_9) ds)
// Called from:
//      fn00401200
word32 fn00401140(char * ecx, Eq_4 ebx, Eq_3 ebp, Eq_4 esi, FILE * edi, struct Eq_8 * es, struct Eq_9 * ds)
{
	ptr32 fp;
	Eq_3 dwLoc38;
	ui32 eax_7 = g_dw403000 ^ fp - 0x4C;
	if (stat64i32(ecx, fp - 0x4C) == 0x00)
	{
		FILE * eax_46 = fopen(ecx, "rb");
		if (eax_46 != null)
		{
			Eq_2 edx_123;
			Eq_3 ebp_53 = 0x00;
			if (dwLoc38 > 0x00)
			{
				do
				{
					Eq_4 eax_69 = fread(fp - 0x18, 0x01, 0x10, eax_46);
					if (eax_69 == 0x00)
						break;
					edx_123 = fn00401000(ebp_53, fread, ebp_53, eax_69, eax_46, es, ds, fp - 0x18, eax_69);
					ebp_53 += eax_69;
				} while (ebp_53 < dwLoc38);
			}
			fclose(eax_46);
			return fn0040123B(0x00, eax_7 ^ fp - 0x4C, edx_123, ebx, ebp, esi, edi, es, ds, ebx);
		}
	}
	perror(ecx);
	return fn0040123B(0x01, eax_7 ^ fp - 0x4C, edx_123, ebx, ebp, esi, edi, es, ds, ebx);
}

// 00401200: Register (ptr32 Eq_7) fn00401200(Register (ptr16 Eq_8) es, Register (ptr16 Eq_9) ds, Stack Eq_4 dwArg04, Stack (arr (ptr32 char)) dwArg08)
// Called from:
//      Win32CrtStartup
FILE * fn00401200(struct Eq_8 * es, struct Eq_9 * ds, Eq_4 dwArg04, char * dwArg08[])
{
	ptr32 fp;
	__align_stack<word32>(fp - 4);
	FILE * edi_21 = null;
	size_t esi_22 = 1;
	if (dwArg04 > 1)
	{
		do
		{
			esi_22 = (Eq_4) ((word32) esi_22 + 1);
			edi_21 += fn00401140(dwArg08[esi_22], dwArg04, fp - 4, esi_22, edi_21, es, ds);
		} while (esi_22 < dwArg04);
	}
	return edi_21;
}

// 0040123B: Register Eq_182 fn0040123B(Register Eq_182 eax, Register ui32 ecx, Register Eq_2 edx, Register Eq_4 ebx, Register Eq_3 ebp, Register Eq_4 esi, Register (ptr32 Eq_7) edi, Register (ptr16 Eq_8) es, Register (ptr16 Eq_9) ds, Stack Eq_4 dwArg00)
// Called from:
//      fn00401000
//      fn00401140
Eq_182 fn0040123B(Eq_182 eax, ui32 ecx, Eq_2 edx, Eq_4 ebx, Eq_3 ebp, Eq_4 esi, FILE * edi, struct Eq_8 * es, struct Eq_9 * ds, Eq_4 dwArg00)
{
	ptr32 fp;
	struct Eq_317 * ss;
	struct Eq_318 * cs;
	struct Eq_319 * fs;
	struct Eq_320 * gs;
	byte SCZDOP;
	if (ecx == g_dw403000)
		return eax;
	g_t403140 = eax;
	g_dw40313C = ecx;
	g_t403138.u0 = (int32) edx;
	g_t403134 = ebx;
	g_t403130 = esi;
	g_ptr40312C = edi;
	g_ptr403158 = ss;
	g_ptr40314C = cs;
	g_ptr403128 = ds;
	g_ptr403124 = es;
	g_ptr403120 = fs;
	g_ptr40311C = gs;
	Eq_348 SCZDOP_40 = cond(fp - 0x032C) | SCZDOP;
	g_t403150.u1 = (word32) SCZDOP_40;
	g_t403144.u0 = (uint32) ebp;
	g_t403148 = dwArg00;
	g_ptr403154 = fp + 4;
	g_dw403090 = 0x00010001;
	g_t403044 = g_t403148;
	g_dw403038 = 0xC0000409;
	g_dw40303C = 0x01;
	ui32 eax_56 = g_dw403000;
	ui32 eax_58 = g_dw403004;
	g_t403088 = IsDebuggerPresent();
	crt_debugger_hook(0x01, SCZDOP_40, eax_56, eax_58);
	esp_64->u0 = 0x00;
	SetUnhandledExceptionFilter(esp_64->u1);
	esp_64->u0 = 0x004020FC;
	UnhandledExceptionFilter(esp_64->u0);
	ptr32 esp_79 = (char *) esp_64 + 4;
	if (g_t403088 == 0x00)
	{
		crt_debugger_hook(0x01);
		esp_79 = esp_84 + 4;
	}
	struct Eq_418 * esp_93 = esp_79 - 4;
	esp_93->t0000 = 0xC0000409;
	esp_93->tFFFFFFFC = GetCurrentProcess();
	return TerminateProcess(esp_93->tFFFFFFFC, esp_93->t0000);
}

// 004014EC: Register Eq_449 Win32CrtStartup()
Eq_449 Win32CrtStartup()
{
	ptr32 fp;
	struct Eq_451 * fs;
	word32 ebx;
	word32 esi;
	word32 edi;
	struct Eq_9 * ds;
	struct Eq_8 * es;
	word32 dwLoc0C;
	fn00401968();
	struct Eq_461 * ebp_19 = fn004018BC(ebx, esi, edi, dwLoc0C, 0x10);
	ebp_19->dwFFFFFFFC = 0x00;
	Eq_411 esi_30 = fs->ptr0018->t0004;
	ebp_19->dwFFFFFFE4 = 0x00;
	while (true)
	{
		Eq_411 eax_43 = InterlockedCompareExchange(&g_t403374, esi_30, 0x00);
		if (eax_43 == 0x00)
			break;
		if (eax_43 == esi_30)
		{
			ebp_19->dwFFFFFFE4 = 0x01;
			break;
		}
		Sleep(1000);
	}
	if (g_dw403370 == 0x01)
		_amsg_exit(0x1F);
	struct Eq_501 * esp_225;
	Eq_449 eax_245;
	if (g_dw403370 == 0x00)
	{
		g_dw403370 = 0x01;
		esp_225 = fp - 8;
		if (_initterm_e(&g_t4020D0, &g_t4020DC) != 0x00)
		{
			ebp_19->dwFFFFFFFC = ~0x01;
			eax_245.u0 = 0xFF;
			goto l00401405;
		}
	}
	else
		g_dw403034 = 0x01;
	if (g_dw403370 == 0x01)
	{
		_initterm(&g_t4020C4, &g_t4020CC);
		g_dw403370 = 0x02;
	}
	if (ebp_19->dwFFFFFFE4 == 0x00)
		InterlockedExchange(&g_t403374, 0x00);
	ptr32 esp_126 = fp - 8;
	if (g_ptr403380 != null)
	{
		esp_126 = fp - 8;
		if (fn004017F0(0x00403380) != 0x00)
		{
			word32 edx_166;
			g_ptr403380();
		}
	}
	_initenv->u0 = g_t40301C.u0;
	struct Eq_588 * esp_174 = esp_126 - 4;
	esp_174->t0000.u0 = g_t40301C.u0;
	esp_174->ptrFFFFFFFC = g_ptr403020;
	esp_174->tFFFFFFF8 = g_t403018;
	Eq_449 eax_218 = fn00401200(es, ds, esp_174->tFFFFFFF8, esp_174->ptrFFFFFFFC);
	g_t403030.u0 = (int32) eax_218;
	esp_225 = (struct Eq_501 *) ((char *) &esp_174->t0000 + 4);
	if (g_dw403024 == 0x00)
	{
		esp_174->t0000.u0 = (int32) eax_218;
		exit(esp_174->t0000.u0);
	}
	if (g_dw403034 == 0x00)
		cexit();
	ebp_19->dwFFFFFFFC = ~0x01;
	eax_245.u0 = g_t403030.u0;
l00401405:
	fn00401901(ebp_19, esp_225->dwFFFFFFFC);
	return eax_245;
}

// 00401760: Register uint32 fn00401760(Stack (ptr32 Eq_656) dwArg04)
// Called from:
//      fn004017F0
uint32 fn00401760(struct Eq_656 * dwArg04)
{
	if (dwArg04->w0000 != 23117)
		return 0x00;
	struct Eq_662 * eax_16 = dwArg04 + dwArg04->dw003C / 64;
	if (eax_16->dw0000 != 0x4550)
		return 0x00;
	return (uint32) (int8) (eax_16->w0018 == 0x010B);
}

// 004017A0: Register (ptr32 Eq_680) fn004017A0(Stack (ptr32 Eq_681) dwArg04, Stack uint32 dwArg08)
// Called from:
//      fn004017F0
struct Eq_680 * fn004017A0(struct Eq_681 * dwArg04, uint32 dwArg08)
{
	struct Eq_683 * ecx_12 = dwArg04 + dwArg04->dw003C / 64;
	up32 esi_20 = (word32) ecx_12->w0006;
	up32 edx_21 = 0x00;
	struct Eq_680 * eax_24 = ecx_12 + ((word32) ecx_12->w0014 + 24) / 22;
	if (esi_20 > 0x00)
	{
		do
		{
			uint32 ecx_33 = eax_24->dw000C;
			if (dwArg08 >= ecx_33 && dwArg08 < eax_24->dw0008 + ecx_33)
				return eax_24;
			++edx_21;
			++eax_24;
		} while (edx_21 < esi_20);
	}
	eax_24 = null;
	return eax_24;
}

// 004017F0: Register ui32 fn004017F0(Stack ui32 dwArg04)
// Called from:
//      Win32CrtStartup
ui32 fn004017F0(ui32 dwArg04)
{
	ptr32 fp;
	struct Eq_723 * fs;
	ptr32 eax_17 = fs->ptr0000;
	fs->ptr0000 = fp - 20;
	if (fn00401760(&g_t400000) != 0x00)
	{
		struct Eq_743 * eax_64 = fn004017A0(&g_t400000, dwArg04 - 0x00400000);
		if (eax_64 != null)
		{
			ui32 eax_100 = ~(eax_64->dw0024 >> 0x1F) & 0x01;
			fs->ptr0000 = eax_17;
			return eax_100;
		}
	}
	fs->ptr0000 = eax_17;
	return 0x00;
}

// 004018BC: Register ptr32 fn004018BC(Register word32 ebx, Register word32 esi, Register word32 edi, Stack word32 dwArg00, Stack ui32 dwArg08)
// Called from:
//      Win32CrtStartup
ptr32 fn004018BC(word32 ebx, word32 esi, word32 edi, word32 dwArg00, ui32 dwArg08)
{
	ptr32 fp;
	struct Eq_766 * fs;
	struct Eq_767 * esp_14 = fp - 8 - dwArg08;
	esp_14->dwFFFFFFFC = ebx;
	esp_14->dwFFFFFFF8 = esi;
	esp_14->dwFFFFFFF4 = edi;
	esp_14->dwFFFFFFF0 = g_dw403000 ^ fp + 8;
	esp_14->dwFFFFFFEC = dwArg00;
	fs->ptr0000 = fp - 8;
	return fp + 8;
}

// 00401901: void fn00401901(Register (ptr32 Eq_461) ebp, Stack word32 dwArg00)
// Called from:
//      Win32CrtStartup
void fn00401901(struct Eq_461 * ebp, word32 dwArg00)
{
	struct Eq_796 * fs;
	fs->dw0000 = ebp->dwFFFFFFF0;
	ebp->dw0000 = dwArg00;
}

// 00401968: void fn00401968()
// Called from:
//      Win32CrtStartup
void fn00401968()
{
	Eq_806 tLoc14;
	Eq_807 tLoc0C;
	ui32 eax_11 = g_dw403000;
	tLoc0C.dwLowDateTime = (DWORD) 0x00;
	tLoc0C.dwHighDateTime = (DWORD) 0x00;
	if (eax_11 != 0xBB40E64E && (eax_11 & 0xFFFF0000) != 0x00)
		g_dw403004 = ~eax_11;
	else
	{
		GetSystemTimeAsFileTime(&tLoc0C);
		ui32 esi_48 = tLoc0C.dwHighDateTime ^ tLoc0C.dwLowDateTime ^ GetCurrentProcessId() ^ GetCurrentThreadId() ^ GetTickCount();
		QueryPerformanceCounter(&tLoc14);
		ui32 esi_56 = esi_48 ^ (tLoc14.dw0004 ^ (tLoc14.u).LowPart);
		if (esi_56 == 0xBB40E64E)
			esi_56 = ~0x44BF19B0;
		else if ((esi_56 & 0xFFFF0000) == 0x00)
			esi_56 |= esi_56 << 0x10;
		g_dw403000 = esi_56;
		g_dw403004 = ~esi_56;
	}
}

