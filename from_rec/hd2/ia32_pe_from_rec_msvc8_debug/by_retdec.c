//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _stat64i32 {
    int32_t e0;
    int16_t e1;
    int16_t e2;
    int16_t e3;
    int16_t e4;
    int16_t e5;
    int32_t e6;
    int32_t e7;
    int64_t e8;
    int64_t e9;
    int64_t e10;
};

// ------------------- Function Prototypes --------------------

int32_t _40___security_check_cookie_40_4(void);
int32_t function_411096(void);
int32_t function_4110a0(void);
int32_t function_4110aa(int32_t a1);
int32_t function_4110be(int32_t a1);
int32_t function_4110c3(int32_t a1);
int32_t function_4110c8(void);
int32_t function_411163(int32_t a1);
int32_t function_411168(void);
int32_t function_411410(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4116a0(int32_t a1);
int32_t function_411860(int32_t a1, int32_t * a2);
int32_t function_411970(void);
int32_t function_411990(int32_t a1);
int32_t function_4119c0(int32_t a1);

// --------------------- Global Variables ---------------------

int32_t g1 = 124; // 0x415740
int32_t g2 = -0x44bf19b2; // 0x417000
int32_t g3;

// ------------------------ Functions -------------------------

// Address range: 0x411023 - 0x411028
int32_t _40___security_check_cookie_40_4(void) {
    // 0x411023
    return function_411970();
}

// Address range: 0x411096 - 0x41109b
int32_t function_411096(void) {
    // 0x411096
    return function_4119c0((int32_t)&g3);
}

// Address range: 0x4110a0 - 0x4110a5
int32_t function_4110a0(void) {
    // 0x4110a0
    return ___report_gsfailure();
}

// Address range: 0x4110aa - 0x4110af
int32_t function_4110aa(int32_t a1) {
    // 0x4110aa
    return (int32_t)strcat((char *)&g3, (char *)&g3);
}

// Address range: 0x4110be - 0x4110c3
int32_t function_4110be(int32_t a1) {
    // 0x4110be
    return strlen((char *)&g3);
}

// Address range: 0x4110c3 - 0x4110c8
int32_t function_4110c3(int32_t a1) {
    int32_t result = function_411410((int32_t)&g3, (int32_t)&g3, (int32_t)&g3); // 0x4110c3
    return result;
}

// Address range: 0x4110c8 - 0x4110cd
int32_t function_4110c8(void) {
    // 0x4110c8
    return (int32_t)strcpy((char *)&g3, (char *)&g3);
}

// Address range: 0x411163 - 0x411168
int32_t function_411163(int32_t a1) {
    // 0x411163
    return function_4116a0((int32_t)&g3);
}

// Address range: 0x411168 - 0x41116d
int32_t function_411168(void) {
    // 0x411168
    return function_411990((int32_t)&g3);
}

// Address range: 0x411410 - 0x4115fd
int32_t function_411410(int32_t a1, int32_t a2, int32_t a3) {
    // 0x411410
    int32_t v1; // bp-4, 0x411410
    int32_t v2 = &v1; // 0x411411
    int32_t v3; // bp-316, 0x411410
    __asm_rep_stosd_memset((char *)&v3, -0x33333334, 78);
    int32_t str; // bp-92, 0x411410
    sprintf((char *)&str, "%08lX:", a2);
    int32_t v4; // bp-328, 0x411410
    int32_t v5 = &v4; // 0x41144d
    function_411168();
    uint32_t v6 = a3 < 16 ? a3 : 16;
    int32_t * v7 = (int32_t *)(v5 - 4);
    int32_t v8; // 0x411410
    int32_t * v9; // 0x411410
    int32_t * v10; // 0x411410
    int32_t v11; // 0x411410
    int32_t v12; // 0x411410
    char * v13; // 0x411410
    if (a3 > 0) {
        int32_t * v14 = (int32_t *)(v5 - 8);
        int32_t v15 = 0; // 0x411470
        *v7 = (int32_t)*(char *)(v15 + a1);
        *v14 = (int32_t)" %02lX";
        int32_t v16 = 3 * v15; // 0x411492
        *(int32_t *)(v5 - 12) = v2 - 79 + v16;
        sprintf(NULL, (char *)&g3);
        function_411168();
        v15++;
        char * v17 = (char *)v15;
        char * str2 = v17; // 0x41147c
        while (v6 > v15) {
            // 0x41147e
            *v7 = (int32_t)*(char *)(v15 + a1);
            *v14 = (int32_t)" %02lX";
            v16 = 3 * v15;
            *(int32_t *)(v5 - 12) = v2 - 79 + v16;
            sprintf(str2, (char *)&g3);
            function_411168();
            v15++;
            v17 = (char *)v15;
            str2 = v17;
        }
        // 0x4114ac
        v3 = v17 <= (char *)15;
        v10 = v14;
        v13 = v17;
        v12 = v16;
        if (v17 > (char *)15) {
            // 0x4114ac
            v11 = v16;
            v9 = v14;
            v8 = &str;
            goto lab_0x4114ef;
        } else {
            goto lab_0x4114dc;
        }
    } else {
        // 0x4114ac
        v3 = 1;
        v10 = (int32_t *)(v5 - 8);
        v13 = NULL;
        goto lab_0x4114dc;
    }
  lab_0x4114dc:;
    int32_t v18 = &str;
    char * v19 = (char *)((int32_t)v13 + 1); // 0x4114b5
    *v7 = (int32_t)"   ";
    *v10 = v18;
    function_4110aa(v3);
    v3 = v19 <= (char *)15;
    char * v20 = v19; // 0x4114da
    v11 = v12;
    v9 = v10;
    v8 = v18;
    while (v19 <= (char *)15) {
        // 0x4114dc
        v19 = (char *)((int32_t)v20 + 1);
        *v7 = (int32_t)"   ";
        *v10 = v18;
        function_4110aa(v3);
        v3 = v19 <= (char *)15;
        v20 = v19;
        v11 = v12;
        v9 = v10;
        v8 = v18;
    }
    goto lab_0x4114ef;
  lab_0x4114ef:
    // 0x4114ef
    *v7 = v8;
    int32_t v21 = function_4110be(v3); // 0x4114f3
    *v7 = (int32_t)"  |";
    int32_t v22 = v2 - 88; // 0x411506
    *v9 = v21 + v22;
    function_4110c8();
    int32_t v23 = v21 + 3 + v22;
    char * v24 = NULL; // 0x411534
    int32_t v25 = v11; // 0x411534
    int32_t v26 = 0; // 0x411534
    int32_t v27; // 0x411410
    char * v28; // 0x411410
    if (a3 > 0) {
        int32_t v29 = v26 + a1; // 0x411539
        unsigned char v30 = *(char *)v29; // 0x41153c
        int32_t v31 = v11; // 0x411542
        int32_t v32 = 46; // 0x411542
        if (v30 >= 32) {
            // 0x411544
            v31 = v30 > 126 ? v29 : (int32_t)v30;
            v32 = (int32_t)(v30 > 126 ? 46 : v30);
        }
        int32_t v33 = v31;
        v3 = v32;
        *(char *)(v26 + v23) = (char)v32;
        int32_t v34 = v26 + 1; // 0x411528
        v26 = v34;
        while (v6 > v34) {
            // 0x411536
            v29 = v26 + a1;
            v30 = *(char *)v29;
            v31 = v33;
            v32 = 46;
            if (v30 >= 32) {
                // 0x411544
                v31 = v30 > 126 ? v29 : (int32_t)v30;
                v32 = (int32_t)(v30 > 126 ? 46 : v30);
            }
            // 0x41156d
            v33 = v31;
            v3 = v32;
            *(char *)(v26 + v23) = (char)v32;
            v34 = v26 + 1;
            v26 = v34;
        }
        char * v35 = (char *)v34; // 0x41152b
        v24 = v35;
        v25 = v33;
        v27 = v33;
        v28 = v35;
        if (v35 > (char *)15) {
            goto lab_0x41159b;
        } else {
            goto lab_0x411585;
        }
    } else {
        goto lab_0x411585;
    }
  lab_0x411585:;
    int32_t v36 = (int32_t)v24; // 0x411588
    *(char *)(v23 + v36) = 32;
    char * v37 = (char *)(v36 + 1);
    v27 = v25;
    v28 = v37;
    while (v37 <= (char *)15) {
        // 0x411585
        v36 = (int32_t)v37;
        *(char *)(v23 + v36) = 32;
        v37 = (char *)(v36 + 1);
        v27 = v25;
        v28 = v37;
    }
    goto lab_0x41159b;
  lab_0x41159b:
    // 0x41159b
    *v7 = (int32_t)&g1;
    *v9 = v23 + (int32_t)v28;
    function_4110c8();
    *v7 = v8;
    *v9 = (int32_t)"%s\n";
    printf((char *)&g3);
    int32_t v38 = function_411168(); // 0x4115c9
    *v7 = v27;
    *v9 = v38;
    function_411096();
    _40___security_check_cookie_40_4();
    return function_411168();
}

// Address range: 0x4116a0 - 0x4117db
int32_t function_4116a0(int32_t a1) {
    // 0x4116a0
    int32_t v1; // 0x4116a0
    uint32_t v2 = v1;
    int32_t v3; // bp-316, 0x4116a0
    __asm_rep_stosd_memset((char *)&v3, -0x33333334, 78);
    int32_t v4; // bp-108, 0x4116a0
    int32_t v5 = function_411860(a1, &v4); // 0x4116d0
    char * file_path = (char *)a1;
    int32_t v6; // 0x4116a0
    int32_t v7; // 0x4116a0
    int32_t v8; // bp-28, 0x4116a0
    int32_t v9; // bp-328, 0x4116a0
    if (v5 == 0) {
        // 0x4116fc
        fopen(file_path, "rb");
        int32_t v10 = &v9; // 0x41170d
        int32_t v11 = function_411168(); // 0x411712
        if (v11 != 0) {
            int32_t * v12 = (int32_t *)(v10 - 4);
            if (v2 != 0) {
                int32_t * v13 = (int32_t *)(v10 - 8); // 0x411752
                int32_t * v14 = (int32_t *)(v10 - 12); // 0x411754
                int32_t v15 = &v8; // 0x411759
                int32_t data = 0; // 0x41178c
                *v12 = v11;
                *v13 = 16;
                *v14 = 1;
                *(int32_t *)(v10 - 16) = v15;
                fread((int32_t *)data, (int32_t)&g3, (int32_t)&g3, (struct _IO_FILE *)&g3);
                int32_t v16 = function_411168(); // 0x411765
                while (v16 != 0) {
                    // 0x411775
                    *v12 = v16;
                    *v13 = data;
                    *v14 = v15;
                    function_4110c3(v16);
                    data += v16;
                    if (data >= v2) {
                        // break -> 0x411794
                        break;
                    }
                    *v12 = v11;
                    *v13 = 16;
                    *v14 = 1;
                    *(int32_t *)(v10 - 16) = v15;
                    fread((int32_t *)data, (int32_t)&g3, (int32_t)&g3, (struct _IO_FILE *)&g3);
                    v16 = function_411168();
                }
            }
            // 0x411794
            *v12 = v11;
            fclose((struct _IO_FILE *)&g3);
            function_411168();
            v6 = 0;
            v7 = v10;
        } else {
            // 0x411720
            perror(file_path);
            function_411168();
            v6 = 1;
            v7 = v10;
        }
    } else {
        // 0x4116dc
        perror(file_path);
        function_411168();
        v6 = 1;
        v7 = &v9;
    }
    // 0x4117ac
    *(int32_t *)(v7 - 4) = (int32_t)&v8;
    *(int32_t *)(v7 - 8) = v6;
    function_411096();
    _40___security_check_cookie_40_4();
    return function_411168();
}

// Address range: 0x411860 - 0x4118ac
int32_t function_411860(int32_t a1, int32_t * a2) {
    // 0x411860
    int32_t v1; // bp-196, 0x411860
    __asm_rep_stosd_memset((char *)&v1, -0x33333334, 48);
    _stat64i32((char *)a1, (struct _stat64i32 *)a2);
    function_411168();
    return function_411168();
}

// Address range: 0x4118c0 - 0x411930
int main(int argc, char ** argv) {
    // 0x4118c0
    int32_t v1; // bp-220, 0x4118c0
    __asm_rep_stosd_memset((char *)&v1, -0x33333334, 54);
    if (argc <= 1) {
        // 0x411919
        return function_411168();
    }
    int32_t v2 = 1; // 0x4118f1
    int32_t v3 = 0;
    int32_t v4 = *(int32_t *)(4 * v2 + (int32_t)argv); // 0x411905
    int32_t v5; // bp-232, 0x4118c0
    *(int32_t *)((int32_t)&v5 - 4) = v4;
    v2++;
    int32_t v6 = function_411163(v3) + v3; // 0x4118fd
    while (v2 != argc) {
        // 0x4118ff
        v3 = v6;
        v4 = *(int32_t *)(4 * v2 + (int32_t)argv);
        *(int32_t *)((int32_t)&v5 - 4) = v4;
        v2++;
        v6 = function_411163(v3) + v3;
    }
    // 0x411919
    return function_411168();
}

// Address range: 0x411970 - 0x41197f
int32_t function_411970(void) {
    // 0x411970
    int32_t result; // 0x411970
    if (result != g2) {
        // 0x41197a
        return function_4110a0();
    }
    // 0x411978
    return result;
}

// Address range: 0x411990 - 0x4119b5
int32_t function_411990(int32_t a1) {
    // 0x411990
    int32_t result; // 0x411990
    bool v1; // 0x411990
    if (v1) {
        // 0x411992
        return result;
    }
    // 0x411993
    _3f__RTC_Failure_40__40_YAXPAXH_40_Z((int32_t *)a1, 0);
    return result;
}

// Address range: 0x4119c0 - 0x411a1f
int32_t function_4119c0(int32_t a1) {
    // 0x4119c0
    int32_t result; // 0x4119c0
    int32_t v1; // 0x4119c0
    if (v1 < 1) {
        // 0x411a18
        return result;
    }
    // 0x4119d6
    int32_t v2; // bp-20, 0x4119c0
    int32_t v3 = &v2; // 0x4119c8
    int32_t v4 = 0; // 0x411a0d
    int32_t v5 = 0; // 0x4119c0
    int32_t v6; // 0x4119c0
    int32_t v7; // 0x4119c0
    int32_t v8; // 0x4119c0
    while (true) {
      lab_0x4119d6:
        // 0x4119d6
        v7 = v4;
        v8 = *(int32_t *)(v1 + 4) + v5;
        int32_t v9 = *(int32_t *)v8; // 0x4119d9
        if (*(int32_t *)(v1 - 4 + v9) != -0x33333334) {
            goto lab_0x4119f6;
        } else {
            int32_t v10 = *(int32_t *)(v8 + 4) + v9; // 0x4119eb
            v6 = v10;
            if (*(int32_t *)(v10 + v1) == -0x33333334) {
                goto lab_0x411a0a;
            } else {
                goto lab_0x4119f6;
            }
        }
    }
  lab_0x411a18:
    // 0x411a18
    return result;
  lab_0x4119f6:
    // 0x4119f6
    *(int32_t *)(v3 - 4) = *(int32_t *)(v8 + 8);
    *(int32_t *)(v3 - 8) = a1;
    _3f__RTC_StackFailure_40__40_YAXPAXPBD_40_Z((int32_t *)v7, (char *)&g3);
    v6 = a1;
    goto lab_0x411a0a;
  lab_0x411a0a:
    // 0x411a0a
    v4 = v7 + 1;
    v5 += 12;
    result = v4;
    if (v4 >= v6) {
        // break -> 0x411a18
        goto lab_0x411a18;
    }
    goto lab_0x4119d6;
}

// --------------- Statically Linked Functions ----------------

// int32_t _3f__RTC_Failure_40__40_YAXPAXH_40_Z(int32_t * a1, int32_t a2);
// int32_t _3f__RTC_StackFailure_40__40_YAXPAXPBD_40_Z(int32_t * a1, char * a2);
// int32_t ___report_gsfailure(void);

// --------------- Dynamically Linked Functions ---------------

// int __cdecl _stat64i32(_In_z_ char const * FileName, _Out_ struct _stat64i32 * Stat);
// int fclose(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void perror(const char * s);
// int printf(const char * restrict format, ...);
// int sprintf(char * restrict s, const char * restrict format, ...);
// char * strcat(char * restrict dest, const char * restrict src);
// char * strcpy(char * restrict dest, const char * restrict src);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (9.0)
// Detected functions: 16

