//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t ___inline_strcpy_chk(int64_t a1, char * a2);
int64_t _dumpline(int64_t * a1, int64_t a2, int32_t a3);
int64_t _hexdump(int64_t a1);
int64_t function_100000de4(int64_t * a1, int64_t a2, int64_t a3, char * a4, int64_t a5);
int64_t function_100000dea(void);
int64_t function_100000df0(int64_t * a1, char * a2, int64_t a3);
int64_t function_100000df6(int64_t a1, char * a2, int64_t a3);
int64_t function_100000e20(int64_t a1, int64_t * a2, int32_t a3);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x100001010

// ------------------------ Functions -------------------------

// Address range: 0x100000a2c - 0x100000c70
int64_t _dumpline(int64_t * a1, int64_t a2, int32_t a3) {
    int64_t v1 = (int64_t)a1;
    int64_t v2; // bp-104, 0x100000a2c
    function_100000de4(&v2, 0, 80, "%08lX:", a2);
    int32_t v3 = a3 < 16 ? a3 : 16;
    int32_t v4 = 0; // 0x100000aee
    if (a3 > 0) {
        int64_t v5 = (int64_t)&v2 + 9; // 0x100000abf
        int64_t v6 = 0; // 0x100000a2c
        unsigned char v7 = *(char *)(v6 + v1); // 0x100000aa0
        function_100000de4((int64_t *)(v5 + 3 * v6), 0, -1, " %02lX", (int64_t)v7);
        int64_t v8 = v6 + 1;
        v6 = v8;
        while (v8 < (int64_t)v3) {
            // 0x100000a97
            v7 = *(char *)(v6 + v1);
            function_100000de4((int64_t *)(v5 + 3 * v6), 0, -1, " %02lX", (int64_t)v7);
            v8 = v6 + 1;
            v6 = v8;
        }
        // 0x100000ae5
        v4 = v8;
    }
    int32_t v9 = v4;
    int32_t v10 = v9 - 15; // 0x100000b07
    if (v10 == 0 || v10 < 0 != (14 - v9 & v9) < 0) {
        int32_t v11 = v9;
        int32_t v12 = v11 + 1; // 0x100000b0e
        function_100000df0(&v2, "   ", 80);
        while (v11 == 14 || v11 < 14 != (13 - v11 & v12) < 0) {
            // 0x100000af2
            v11 = v12;
            v12 = v11 + 1;
            function_100000df0(&v2, "   ", 80);
        }
    }
    int32_t v13 = _strlen((char *)&v2); // 0x100000b19
    int64_t v14 = &v2; // 0x100000b54
    ___inline_strcpy_chk((int64_t)v13 + v14, "  |");
    int32_t v15 = v13 + 3; // 0x100000b67
    int64_t v16; // bp-8, 0x100000a2c
    int64_t v17 = (int64_t)&v16 - 96;
    int64_t v18 = 0; // 0x100000bdb
    int64_t v19; // 0x100000a2c
    if (a3 > 0) {
        int64_t v20 = 0; // 0x100000a2c
        unsigned char v21 = *(char *)(v20 + v1); // 0x100000b8b
        char v22 = v21 < 32 ? 46 : v21 < 127 ? v21 : 46;
        *(char *)(v17 + (int64_t)(v15 + (int32_t)v20)) = v22;
        v18 = v20 + 1;
        v20 = v18;
        while (v18 < (int64_t)v3) {
            // 0x100000b74
            v21 = *(char *)(v20 + v1);
            v22 = v21 < 32 ? 46 : v21 < 127 ? v21 : 46;
            *(char *)(v17 + (int64_t)(v15 + (int32_t)v20)) = v22;
            v18 = v20 + 1;
            v20 = v18;
        }
        // 0x100000bef
        v19 = v18;
        if ((int32_t)v18 < 16) {
            goto lab_0x100000bdf;
        } else {
            goto lab_0x100000c2f;
        }
    } else {
        goto lab_0x100000bdf;
    }
  lab_0x100000bdf:;
    int64_t v23 = v18 & 0xffffffff; // 0x100000a2c
    *(char *)(v17 + (int64_t)(v15 + (int32_t)v23)) = 32;
    int64_t v24 = v23 + 1;
    v23 = v24;
    v19 = 16;
    while (v24 != 16) {
        // 0x100000bdf
        *(char *)(v17 + (int64_t)(v15 + (int32_t)v23)) = 32;
        v24 = v23 + 1;
        v23 = v24;
        v19 = 16;
    }
    goto lab_0x100000c2f;
  lab_0x100000c2f:
    // 0x100000c2f
    ___inline_strcpy_chk((int64_t)v15 + v14 + (0x100000000 * v19 >> 32), "|");
    _puts((char *)&v2);
    int64_t result = g1; // 0x100000c67
    if (*(int64_t *)g1 != *(int64_t *)g1) {
        // 0x100000c69
        result = function_100000dea();
    }
    // 0x100000c6e
    return result;
}

// Address range: 0x100000c70 - 0x100000c96
int64_t ___inline_strcpy_chk(int64_t a1, char * a2) {
    // 0x100000c70
    return function_100000df6(a1, a2, -1);
}

// Address range: 0x100000c96 - 0x100000d9d
int64_t _hexdump(int64_t a1) {
    // 0x100000c96
    int64_t v1; // 0x100000c96
    uint64_t v2 = v1;
    int64_t v3; // bp-216, 0x100000c96
    int64_t v4 = function_100000e20(a1, &v3, 0); // 0x100000cc6
    char * v5 = (char *)a1;
    int64_t v6; // 0x100000c96
    if ((int32_t)v4 == 0) {
        struct _IO_FILE * v7 = _fopen(v5, "rb"); // 0x100000cf8
        if (v7 != NULL) {
            int64_t v8 = 0; // 0x100000d6b
            if (v2 != 0) {
                int64_t v9; // bp-40, 0x100000c96
                int32_t v10 = _fread(&v9, 1, 16, v7); // 0x100000d3c
                while (v10 != 0) {
                    // 0x100000d4a
                    _dumpline(&v9, v8, v10);
                    int64_t v11 = v8 + (int64_t)v10; // 0x100000d5f
                    v8 = v11;
                    if (v2 <= v11) {
                        // break -> 0x100000d6d
                        break;
                    }
                    v10 = _fread(&v9, 1, 16, v7);
                }
            }
            // 0x100000d6d
            _fclose(v7);
            v6 = 0;
        } else {
            // 0x100000d08
            _perror(v5);
            v6 = 1;
        }
    } else {
        // 0x100000ccf
        _perror(v5);
        v6 = 1;
    }
    int64_t result = v6; // 0x100000d94
    if (*(int64_t *)g1 != *(int64_t *)g1) {
        // 0x100000d96
        result = function_100000dea();
    }
    // 0x100000d9b
    return result;
}

// Address range: 0x100000d9d - 0x100000de4
int main(int argc, char ** argv) {
    // 0x100000d9d
    if ((int32_t)argc <= 1) {
        // 0x100000ddf
        return 0;
    }
    int64_t v1 = 1;
    int32_t result = 0; // 0x100000dd1
    int64_t v2 = *(int64_t *)(8 * v1 + (int64_t)argv); // 0x100000dc9
    result += (int32_t)_hexdump(v2);
    v1++;
    while (v1 != (argc & 0xffffffff)) {
        // 0x100000dbc
        v2 = *(int64_t *)(8 * v1 + (int64_t)argv);
        result += (int32_t)_hexdump(v2);
        v1++;
    }
    // 0x100000ddf
    return result;
}

// Address range: 0x100000de4 - 0x100000dea
int64_t function_100000de4(int64_t * a1, int64_t a2, int64_t a3, char * a4, int64_t a5) {
    // 0x100000de4
    return ___sprintf_chk();
}

// Address range: 0x100000dea - 0x100000df0
int64_t function_100000dea(void) {
    // 0x100000dea
    return ___stack_chk_fail();
}

// Address range: 0x100000df0 - 0x100000df6
int64_t function_100000df0(int64_t * a1, char * a2, int64_t a3) {
    // 0x100000df0
    return ___strcat_chk();
}

// Address range: 0x100000df6 - 0x100000dfc
int64_t function_100000df6(int64_t a1, char * a2, int64_t a3) {
    // 0x100000df6
    return ___strcpy_chk();
}

// Address range: 0x100000e20 - 0x100000e26
int64_t function_100000e20(int64_t a1, int64_t * a2, int32_t a3) {
    // 0x100000e20
    return _stat_24_INODE64();
}

// --------------- Dynamically Linked Functions ---------------

// int64_t ___sprintf_chk(void);
// int64_t ___stack_chk_fail(void);
// int64_t ___strcat_chk(void);
// int64_t ___strcpy_chk(void);
// int fclose(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void perror(const char * s);
// int puts(const char * s);
// int64_t _stat_24_INODE64(void);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: xcode
// Detected functions: 9

