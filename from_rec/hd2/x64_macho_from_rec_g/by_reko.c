// subject_DATA_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00000001000010A8: void NXArgc(Register (ptr64 byte) rax)
void NXArgc(byte * rax)
{
	byte al_5 = (byte) rax;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	NXArgv(rax);
}

// 00000001000010B0: void NXArgv(Register (ptr64 byte) rax)
// Called from:
//      NXArgc
void NXArgv(byte * rax)
{
	byte al_5 = (byte) rax;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	environ(rax);
}

// 00000001000010B8: void environ(Register (ptr64 byte) rax)
// Called from:
//      NXArgv
void environ(byte * rax)
{
	byte al_5 = (byte) rax;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	__progname(rax);
}

// 00000001000010C0: void __progname(Register (ptr64 byte) rax)
// Called from:
//      environ
void __progname(byte * rax)
{
	byte al_5 = (byte) rax;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
}

// subject_DATA_program_vars.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000100001080: void pvars(Register (ptr64 byte) rax, Register (ptr64 byte) rcx)
void pvars(byte * rax, byte * rcx)
{
	byte al_5 = (byte) rax;
	Eq_316 eax_10 = (word32) rax;
	word56 rax_56_8_23 = SLICE(rax, word56, 8);
	word24 eax_24_8_27 = SLICE(rax, word24, 8);
	*rax += al_5;
	*rax += al_5;
	*rax = (byte) ((word32) eax_10 + *rax);
	*rax += al_5;
	*rax += al_5;
	*rax = (byte) ((word32) eax_10 + *rax);
	*rax += al_5;
	byte * rax_24 = SEQ(rax_56_8_23, 0x10);
	*rax_24 += 0x10;
	*rax_24 = (byte) ((word32) SEQ(eax_24_8_27, 0x10) + *rax_24);
	*rax_24 += 0x10;
	*(byte *) 0x01000010 += 0x10;
	*(byte *) 0x01000020 += 0x20;
	*rcx += 0x20;
	*(byte *) 0x01000020 += 0x20;
}

// subject_TEXT_stub_helper.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000100000E2C: void  stub helpers()
void  stub helpers()
{
	g_ptr1000();
}

// subject_TEXT_symbol_stub1.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000100000DE4: void __sprintf_chk(Register (ptr64 char) rcx, Register Eq_50 rdx, Register uint64 rsi, Register (ptr64 char) rdi)
// Called from:
//      dumpline
void __sprintf_chk(char * rcx, Eq_50 rdx, uint64 rsi, char * rdi)
{
	__sprintf_chk(rdi, (int32) rsi, rdx, rcx, 0x00);
}

// 0000000100000DEA: void __stack_chk_fail()
// Called from:
//      dumpline
//      hexdump
void __stack_chk_fail()
{
	__stack_chk_fail();
}

// 0000000100000DF0: void __strcat_chk()
// Called from:
//      dumpline
void __strcat_chk()
{
	__strcat_chk();
}

// 0000000100000DF6: void __strcpy_chk()
// Called from:
//      dumpline
//      __inline_strcpy_chk
void __strcpy_chk()
{
	__strcpy_chk();
}

// 0000000100000DFC: void exit(Register word32 edi)
// Called from:
//      start
void exit(word32 edi)
{
	word64 rdi;
	exit((int32) rdi);
}

// 0000000100000E02: void fclose(Register (ptr64 Eq_175) rdi)
// Called from:
//      hexdump
void fclose(FILE * rdi)
{
	fclose(rdi);
}

// 0000000100000E08: Register (ptr64 Eq_278) fopen(Register (ptr64 char) rsi, Register (ptr64 char) rdi)
// Called from:
//      hexdump
FILE * fopen(char * rsi, char * rdi)
{
	return fopen(rdi, rsi);
}

// 0000000100000E0E: Register word32 fread(Register (ptr64 Eq_175) rcx, Register Eq_50 rdx, Register Eq_50 rsi, Register (ptr64 word64) rdi)
// Called from:
//      hexdump
word32 fread(FILE * rcx, Eq_50 rdx, Eq_50 rsi, word64 * rdi)
{
	return (word32) fread(rdi, rsi, rdx, rcx);
}

// 0000000100000E14: void perror(Register (ptr64 char) rdi)
// Called from:
//      hexdump
void perror(char * rdi)
{
	perror(rdi);
}

// 0000000100000E1A: void puts(Register (ptr64 char) rdi)
// Called from:
//      dumpline
void puts(char * rdi)
{
	puts(rdi);
}

// 0000000100000E20: void stat$INODE64()
// Called from:
//      hexdump
void stat$INODE64()
{
	stat$INODE64();
}

// 0000000100000E26: Register word32 strlen(Register (ptr64 char) rdi)
// Called from:
//      dumpline
word32 strlen(char * rdi)
{
	return (word32) strlen(rdi);
}

// subject_TEXT_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00000001000009F0: void start(Stack word64 qwArg04)
void start(word64 qwArg04)
{
	ptr64 fp;
	__align_stack<word64>(fp - 4);
	word64 * rcx_19 = (uint64) ((word32) qwArg04 + 0x01 << 0x03) + (fp + 0x0C);
	while (*rcx_19 != 0x00)
		++rcx_19;
	exit(main(fp + 0x0C, (word32) qwArg04));
}

// 0000000100000A2C: void dumpline(Register int32 edx, Register (ptr64 word64) rdi)
// Called from:
//      hexdump
void dumpline(int32 edx, word64 * rdi)
{
	char bLoc68;
	word64 rdx_15 = *__stack_chk_guard;
	__sprintf_chk("%08lX:", 0x50, 0x00, &bLoc68);
	int32 dwLoc8C_267 = edx;
	if (edx > 0x10)
		dwLoc8C_267 = 0x10;
	int32 dwLoc6C_270;
	for (dwLoc6C_270 = 0x00; dwLoc6C_270 < dwLoc8C_267; ++dwLoc6C_270)
		__sprintf_chk(" %02lX", ~0x00, 0x00, &bLoc68 + (int64) (dwLoc6C_270 * 0x03) + 9);
	while (true)
	{
		++dwLoc6C_270;
		if ((int8) (dwLoc6C_270 <= 0x0F) == 0x00)
			break;
		__strcat_chk();
	}
	word32 eax_105 = strlen(&bLoc68);
	__inline_strcpy_chk();
	int32 dwLoc6C_280;
	for (dwLoc6C_280 = 0x00; dwLoc6C_280 < dwLoc8C_267; ++dwLoc6C_280)
	{
		byte bLoc8D_286;
		word32 edx_153 = eax_105 + 0x03 + dwLoc6C_280;
		if (rdi[(int64) dwLoc6C_280] > 0x1F && rdi[(int64) dwLoc6C_280] <= 0x7E)
			bLoc8D_286 = (byte) rdi[(int64) dwLoc6C_280];
		else
			bLoc8D_286 = 0x2E;
		(&bLoc68)[(int64) edx_153].u0 = bLoc8D_286;
	}
	for (; dwLoc6C_280 <= 0x0F; ++dwLoc6C_280)
		(&bLoc68)[(int64) (eax_105 + 0x03 + dwLoc6C_280)].u0 = 0x20;
	__inline_strcpy_chk();
	puts(&bLoc68);
	if ((rdx_15 ^ *__stack_chk_guard) == 0x00)
		return;
	__stack_chk_fail();
}

// 0000000100000C70: void __inline_strcpy_chk()
// Called from:
//      dumpline
void __inline_strcpy_chk()
{
	__strcpy_chk();
}

// 0000000100000C96: Register word32 hexdump(Register (ptr64 char) rdi)
// Called from:
//      main
word32 hexdump(char * rdi)
{
	word64 qwLoc28;
	up64 qwLoc78;
	word32 dwLocE4_107;
	word64 rdx_11 = *__stack_chk_guard;
	stat$INODE64();
	if ((word32) __stack_chk_guard != 0x00)
	{
		perror(rdi);
		dwLocE4_107 = 0x01;
	}
	else
	{
		FILE * rax_28 = fopen("rb", rdi);
		if (rax_28 == null)
		{
			perror(rdi);
			dwLocE4_107 = 0x01;
		}
		else
		{
			up64 qwLoc38_100;
			for (qwLoc38_100 = 0x00; qwLoc78 > qwLoc38_100; qwLoc38_100 += (int64) eax_45)
			{
				int32 eax_45 = fread(rax_28, 0x10, 0x01, &qwLoc28);
				if (eax_45 == 0x00)
					break;
				dumpline(eax_45, &qwLoc28);
			}
			fclose(rax_28);
			dwLocE4_107 = 0x00;
		}
	}
	uint64 rax_84 = (uint64) dwLocE4_107;
	if ((rdx_11 ^ *__stack_chk_guard) == 0x00)
		return (word32) rax_84;
	__stack_chk_fail();
}

// 0000000100000D9D: Register word32 main(Register (arr (ptr64 char)) rsi, Register int32 edi)
// Called from:
//      start
word32 main(char * rsi[], int32 edi)
{
	word64 rdi;
	int32 edi = (word32) rdi;
	word32 dwLoc10_56 = 0x00;
	int32 dwLoc0C_57;
	for (dwLoc0C_57 = 0x01; dwLoc0C_57 < edi; ++dwLoc0C_57)
		dwLoc10_56 += hexdump(rsi[(int64) dwLoc0C_57]);
	return dwLoc10_56;
}

