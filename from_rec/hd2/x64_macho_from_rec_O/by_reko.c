// subject_DATA_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00000001000010A8: void _NXArgc(Register (ptr64 byte) rax)
void _NXArgc(byte * rax)
{
	byte al_5 = (byte) rax;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	_NXArgv(rax);
}

// 00000001000010B0: void _NXArgv(Register (ptr64 byte) rax)
// Called from:
//      _NXArgc
void _NXArgv(byte * rax)
{
	byte al_5 = (byte) rax;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	_environ(rax);
}

// 00000001000010B8: void _environ(Register (ptr64 byte) rax)
// Called from:
//      _NXArgv
void _environ(byte * rax)
{
	byte al_5 = (byte) rax;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	___progname(rax);
}

// 00000001000010C0: void ___progname(Register (ptr64 byte) rax)
// Called from:
//      _environ
void ___progname(byte * rax)
{
	byte al_5 = (byte) rax;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
	*rax += al_5;
}

// subject_DATA_program_vars.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000100001080: void _pvars(Register (ptr64 byte) rax, Register (ptr64 byte) rcx)
void _pvars(byte * rax, byte * rcx)
{
	byte al_5 = (byte) rax;
	Eq_369 eax_10 = (word32) rax;
	word56 rax_56_8_22 = SLICE(rax, word56, 8);
	word24 eax_24_8_26 = SLICE(rax, word24, 8);
	*rax += al_5;
	*rax += al_5;
	*rax = (byte) ((word32) eax_10 + *rax);
	*rax += al_5;
	*rax += al_5;
	*rax = (byte) ((word32) eax_10 + *rax);
	*rax += al_5;
	byte * rax_23 = SEQ(rax_56_8_22, 0x10);
	*rax_23 += 0x10;
	*rax_23 = (byte) ((word32) SEQ(eax_24_8_26, 0x10) + *rax_23);
	*rax_23 += 0x10;
	*(byte *) 0x01000010 += 0x10;
	*(byte *) 0x01000020 += 0x20;
	*rcx += 0x20;
	*(byte *) 0x01000020 += 0x20;
}

// subject_TEXT_stub_helper.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000100000E4A: void  stub helpers()
void  stub helpers()
{
	g_ptr1000();
}

// subject_TEXT_symbol_stub1.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000100000E08: void ___sprintf_chk()
// Called from:
//      _dumpline
void ___sprintf_chk()
{
	___sprintf_chk();
}

// 0000000100000E0E: void ___stack_chk_fail()
// Called from:
//      _dumpline
//      _hexdump
void ___stack_chk_fail()
{
	___stack_chk_fail();
}

// 0000000100000E14: void ___strcat_chk()
// Called from:
//      _dumpline
void ___strcat_chk()
{
	___strcat_chk();
}

// 0000000100000E1A: void _exit()
// Called from:
//      start
void _exit()
{
	_exit();
}

// 0000000100000E20: void _fclose()
// Called from:
//      _hexdump
void _fclose()
{
	_fclose();
}

// 0000000100000E26: void _fopen()
// Called from:
//      _hexdump
void _fopen()
{
	_fopen();
}

// 0000000100000E2C: void _fread()
// Called from:
//      _hexdump
void _fread()
{
	_fread();
}

// 0000000100000E32: void _perror()
// Called from:
//      _hexdump
void _perror()
{
	_perror();
}

// 0000000100000E38: void _puts()
// Called from:
//      _dumpline
void _puts()
{
	_puts();
}

// 0000000100000E3E: void _sprintf()
// Called from:
//      _dumpline
void _sprintf()
{
	_sprintf();
}

// 0000000100000E44: void _stat$INODE64()
// Called from:
//      _hexdump
void _stat$INODE64()
{
	_stat$INODE64();
}

// subject_TEXT_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000100000AB0: void start(Stack Eq_2 qwArg04)
void start(Eq_2 qwArg04)
{
	__align(fp - 4);
	word64 * rcx_19 = (uint64) ((word32) (uint64) ((word32) (uint64) (word32) qwArg04 + 0x01) << 0x03) + (fp + 0x0C);
	while (*rcx_19 != 0x00)
		++rcx_19;
	_main(qwArg04);
	_exit();
	__hlt();
}

// 0000000100000AEC: void _dumpline(Register word32 edx, Register Eq_42 rdi)
// Called from:
//      _hexdump
void _dumpline(word32 edx, Eq_42 rdi)
{
	word64 rdx_29 = *___stack_chk_guard;
	___sprintf_chk();
	int32 ebx_45 = (word32) (uint64) edx;
	int32 r14d_53 = 0x10;
	if (ebx_45 <= 0x10)
		r14d_53 = ebx_45;
	uint64 r8_116;
	int32 edx_236;
	uint64 rdx_222;
	word32 ecx_110;
	word32 ebx_134 = 0x01;
	if (r14d_53 > 0x00)
	{
		int32 r13d_293 = 0x00;
		do
		{
			_sprintf();
			r13d_293 = (word32) (uint64) (r13d_293 + 0x01);
		} while (r13d_293 != r14d_53);
		uint64 r14_124 = (uint64) r14d_53;
		if (r14d_53 > 0x0F)
		{
			byte * rdi_100 = fp - 0x98;
			word64 rcx_104 = ~0x00;
			while (rcx_104 != 0x00)
			{
				rdi_100 = rdi_476 + 1;
				--rcx_104;
				rdi_476 = rdi_100;
				if (*rdi_476 != 0x00)
					break;
			}
			word64 rcx_107 = ~rcx_104;
			ecx_110 = (word32) (rcx_107 - 0x01);
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x98)[(int64) ecx_110 /64 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_235) 0x007C2020;
			r8_116 = (uint64) (word32) (rcx_107 + 0x02);
l0000000100000C0A:
			int32 edi_208 = 0x00;
			Eq_142 rsi_183 = 0x00;
			uint64 rcx_177 = (uint64) (ecx_110 + 0x03);
			do
			{
				word64 rdx_185 = CONVERT(CONVERT(Mem181[rsi_183 + rdi:byte], byte, word32), word32, uint64);
				Eq_186 dl_202 = (byte) rdx_185;
				if ((byte) (uint64) (word32) (rdx_185 - 0x20) >= 0x5F)
					dl_202 = (Eq_186) 0x2E;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x98)[(int64) (word32) (uint64) (word32) ((word64) rsi_183 + rcx_177)].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = dl_202;
				edi_208 = (word32) (uint64) (edi_208 + 0x01);
				rsi_183 = (word64) rsi_183 + 1;
			} while (edi_208 != r14d_53);
			edx_236 = (word32) (uint64) edi_208;
			if (edi_208 > 0x0F)
			{
l0000000100000C99:
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x98 + (int64) ((word32) r8_116) /64 2)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000[(int64) edx_236 /64 2].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_166) 0x7C;
				_puts();
				if ((rdx_29 ^ *___stack_chk_guard) != 0x00)
					___stack_chk_fail();
				return;
			}
			rdx_222 = (uint64) r14d_53;
l0000000100000C04:
			edx_236 = (word32) rdx_222;
			word32 ecx_232 = (word32) (uint64) (word32) (r8_116 + rdx_222);
			do
			{
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x98)[(int64) ecx_232].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_149) 0x20;
				edx_236 = (word32) (uint64) (edx_236 + 0x01);
				ecx_232 = (word32) (uint64) (ecx_232 + 0x01);
			} while (edx_236 <= 0x0F);
			goto l0000000100000C99;
		}
		ebx_134 = (word32) (uint64) (word32) (r14_124 + 0x01);
	}
	do
	{
		___strcat_chk();
		uint64 rbx_136 = (uint64) (ebx_134 + 0x01);
		ebx_134 = (word32) rbx_136;
	} while ((word32) (uint64) (word32) (rbx_136 - 0x01) <= 0x0F);
	byte * rdi_142 = fp - 0x98;
	word64 rcx_144 = ~0x00;
	while (rcx_144 != 0x00)
	{
		rdi_142 = rdi_477 + 1;
		--rcx_144;
		rdi_477 = rdi_142;
		if (*rdi_477 != 0x00)
			break;
	}
	word64 rcx_156 = ~rcx_144;
	ecx_110 = (word32) (rcx_156 - 0x01);
	(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x98)[(int64) ecx_110 /64 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_117) 0x007C2020;
	r8_116 = (uint64) (word32) (rcx_156 + 0x02);
	if (r14d_53 <= 0x00)
	{
		rdx_222 = 0x00;
		goto l0000000100000C04;
	}
	goto l0000000100000C0A;
}

// 0000000100000CD9: Register word32 _hexdump()
// Called from:
//      _main
word32 _hexdump()
{
	uint64 rax_167;
	word64 rdx_23 = *___stack_chk_guard;
	_stat$INODE64();
	word32 eax_122 = (word32) ___stack_chk_guard;
	if (eax_122 != 0x00)
	{
		_perror();
		rax_167 = 0x01;
	}
	else
	{
		_fopen();
		if (___stack_chk_guard != null)
		{
			uint64 r12_45;
			for (r12_45 = 0x00; r12_45 < qwLoc78; r12_45 += rax_81)
			{
				_fread();
				word32 ebx_80 = (word32) (uint64) eax_122;
				if (eax_122 == 0x00)
					break;
				_dumpline((word32) (uint64) eax_122, fp - 0x48);
				int64 rax_81 = (int64) ebx_80;
				eax_122 = (word32) rax_81;
			}
			_fclose();
			rax_167 = 0x00;
		}
		else
		{
			_perror();
			rax_167 = 0x01;
		}
	}
	if ((rdx_23 ^ *___stack_chk_guard) != 0x00)
		___stack_chk_fail();
	return (word32) rax_167;
}

// 0000000100000DBC: void _main(Register Eq_2 edi)
// Called from:
//      start
void _main(Eq_2 edi)
{
	Eq_2 edi = (word32) rdi;
	word32 r14d_77 = (word32) (uint64) edi;
	if (edi > 0x01)
	{
		word32 r12d_47 = 0x01;
		do
		{
			_hexdump();
			r12d_47 = (word32) (uint64) (r12d_47 + 0x01);
		} while (r12d_47 != r14d_77);
	}
}

