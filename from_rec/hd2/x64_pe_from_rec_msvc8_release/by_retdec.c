//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct _EXCEPTION_POINTERS {
    struct _EXCEPTION_RECORD * e0;
    struct _CONTEXT * e1;
};

struct _EXCEPTION_RECORD {
    int32_t e0;
    int32_t e1;
    struct _EXCEPTION_RECORD * e2;
    int64_t * e3;
    int32_t e4;
    int32_t e5[1];
};

struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    int32_t e0;
    int32_t e1;
    int64_t e2;
};

struct _IO_FILE {
    int32_t e0;
};

struct _KNONVOLATILE_CONTEXT_POINTERS {
    int64_t e0;
    int64_t e1;
};

struct _M128A {
    int64_t e0;
    int64_t e1;
};

struct _CONTEXT {
    int64_t e0;
    int64_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    int64_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int16_t e10;
    int16_t e11;
    int16_t e12;
    int16_t e13;
    int32_t e14;
    int64_t e15;
    int64_t e16;
    int64_t e17;
    int64_t e18;
    int64_t e19;
    int64_t e20;
    int64_t e21;
    int64_t e22;
    int64_t e23;
    int64_t e24;
    int64_t e25;
    int64_t e26;
    int64_t e27;
    int64_t e28;
    int64_t e29;
    int64_t e30;
    int64_t e31;
    int64_t e32;
    int64_t e33;
    int64_t e34;
    int64_t e35;
    int64_t e36;
    int64_t e37;
    int64_t e38;
    struct _M128A e39[26];
    int64_t e40;
    int64_t e41;
    int64_t e42;
    int64_t e43;
    int64_t e44;
    int64_t e45;
};

struct _UNWIND_HISTORY_TABLE_ENTRY {
    int64_t e0;
    struct _IMAGE_RUNTIME_FUNCTION_ENTRY * e1;
};

struct _UNWIND_HISTORY_TABLE {
    int32_t e0;
    char e1;
    char e2;
    char e3;
    char e4;
    int64_t e5;
    int64_t e6;
    struct _UNWIND_HISTORY_TABLE_ENTRY e7[1];
};

struct _stat64i32 {
    int32_t e0;
    int16_t e1;
    int16_t e2;
    int16_t e3;
    int16_t e4;
    int16_t e5;
    int32_t e6;
    int32_t e7;
    int64_t e8;
    int64_t e9;
    int64_t e10;
};

// ------------------- Function Prototypes --------------------

void entry_point(void);
int64_t function_140001000(int64_t * a1, int64_t a2, int64_t a3);
int64_t function_140001190(int64_t a1);
int64_t function_140001290(int32_t a1, int64_t a2);
int64_t function_140001388(void);
int64_t function_1400014d0(void);
int64_t function_1400014fd(void);
int64_t function_140001508(void);
int64_t function_140001604(int64_t a1);
int64_t function_140001750(int64_t a1);
void function_1400017ac(int32_t rterrnum);
int64_t function_140001864(void);
int64_t function_1400018ec(void);
int32_t function_1400018f2(int32_t xcptnum, int64_t * pxcptinfoptrs);
int64_t function_140001980(int64_t * a1);
void function_1400019c2(void (**First)(), void (**Last)());
int32_t function_1400019c8(int32_t (**First)(), int32_t (**Last)());
int64_t function_1400019d0(void);
int64_t function_140001a88(int64_t a1);
void function_140001a8e(void);
void function_140001a94(int32_t locknum);
int32_t (*function_140001a9a(int32_t (*func)(), void (***pbegin)(), void (***pend)()))();
void function_140001aa0(int32_t locknum);
int64_t (*function_140001aa6(int32_t HandlerType, int64_t ImageBase, int64_t ControlPc, struct _IMAGE_RUNTIME_FUNCTION_ENTRY * FunctionEntry, struct _CONTEXT * ContextRecord, int64_t ** HandlerData, int64_t * EstablisherFrame, struct _KNONVOLATILE_CONTEXT_POINTERS * ContextPointers))(struct _EXCEPTION_RECORD *, int64_t *, struct _CONTEXT *, int64_t *);
struct _IMAGE_RUNTIME_FUNCTION_ENTRY * function_140001aac(int64_t ControlPc, int64_t * ImageBase, struct _UNWIND_HISTORY_TABLE * HistoryTable);
int64_t function_140001ab4(int64_t a1, int64_t a2, int64_t a3);
int64_t function_140001b18(void);
int64_t * function_140001b36(int64_t * s, int32_t c, int32_t n);
int64_t function_140001b40(int64_t a1, int64_t a2);
int64_t function_140001b5c(void);
int64_t function_140001b80(int64_t a1, int64_t a2);

// --------------------- Global Variables ---------------------

void (**g1)() = NULL; // 0x140002178
void (**g2)() = NULL; // 0x140002188
int32_t (**g3)() = NULL; // 0x140002190
int32_t (**g4)() = NULL; // 0x1400021a8
int64_t g5 = 0x2b992ddfa232; // 0x140003000
int32_t g6 = -2; // 0x140003018
int32_t g7 = 1; // 0x14000301c
int32_t g8 = 0; // 0x140003020
int32_t g9 = 0; // 0x140003024
int64_t g10 = 0; // 0x140003028
int64_t g11 = 0; // 0x140003030
int32_t g12 = 0; // 0x140003040
int32_t g13 = 0; // 0x140003044
int64_t g14 = 0; // 0x140003050
int64_t g15 = 0; // 0x140003054
int32_t g16 = 0; // 0x140003060
int32_t g17 = 0; // 0x1400030e8
struct _CONTEXT * g18 = NULL; // 0x1400030f0
int64_t g19 = 0; // 0x140003170
int64_t g20 = 0; // 0x140003188
int32_t g21 = 0; // 0x1400031e8
int32_t g22 = 0; // 0x1400035c8
int32_t g23 = 0; // 0x1400035cc
int32_t g24 = 0; // 0x1400035d0
int64_t g25 = 0; // 0x1400035d8
int64_t g26 = 0; // 0x1400035e0
int64_t g27 = 0; // 0x1400035e8
int64_t g28 = 0; // 0x1400035f0
int32_t g29;

// ------------------------ Functions -------------------------

// Address range: 0x140001000 - 0x14000118d
int64_t function_140001000(int64_t * a1, int64_t a2, int64_t a3) {
    int64_t v1 = (int64_t)a1;
    int64_t v2; // bp-168, 0x140001000
    int64_t v3 = &v2; // 0x140001012
    int64_t str; // bp-136, 0x140001000
    int64_t v4 = &str; // 0x140001038
    sprintf((char *)&str, "%08lX:", (int32_t)a2);
    int32_t v5 = a3; // 0x140001049
    int32_t v6 = v5 - 16; // 0x140001049
    int64_t v7 = v6 < 0 == (15 - v5 & v5) < 0 == (v6 != 0) ? 16 : a3 & 0xffffffff; // 0x14000104c
    int64_t v8 = 0x100000000 * v7;
    uint64_t v9 = v8 >> 32; // 0x140001059
    int64_t v10 = 0; // 0x14000105e
    int64_t v11; // 0x140001000
    bool v12; // 0x140001000
    if ((int32_t)v7 < 1) {
        goto lab_0x14000109a;
    } else {
        int64_t v13 = 0; // 0x140001066
        int64_t v14 = 0; // 0x140001066
        unsigned char v15 = *(char *)(v13 + v1); // 0x140001070
        sprintf((char *)(v3 + 41 + (0x100000000 * v14 >> 32)), " %02lX", (int32_t)v15);
        v13++;
        v14 = v14 + 3 & 0xffffffff;
        while (v13 != v9) {
            // 0x140001070
            v15 = *(char *)(v13 + v1);
            sprintf((char *)(v3 + 41 + (0x100000000 * v14 >> 32)), " %02lX", (int32_t)v15);
            v13++;
            v14 = v14 + 3 & 0xffffffff;
        }
        // 0x140001095
        v10 = v9 & 0xffffffff;
        if (v8 < 0x1000000000) {
            goto lab_0x14000109a;
        } else {
            // 0x140001095
            v11 = v12 ? -1 : 1;
            goto lab_0x1400010c6;
        }
    }
  lab_0x14000109a:;
    int64_t v16 = v12 ? -1 : 1;
    int64_t v17 = v4;
    int64_t v18 = -1;
    int64_t v19 = v17; // 0x1400010bb
    int64_t v20; // 0x140001000
    int64_t v21; // 0x1400010bb
    while (v18 != 0) {
        v21 = v17 + v16;
        v20 = v18 - 1;
        v19 = v21;
        if (*(char *)v17 == 0) {
            // break -> 
            break;
        }
        v17 = v21;
        v18 = v20;
        v19 = v17;
    }
    int64_t v22 = (16 - v10 & 0xffffffff) - 1; // 0x1400010bd
    *(int32_t *)(v19 - 1) = 0x202020;
    int64_t v23 = v22; // 0x1400010c4
    v11 = v16;
    while (v22 != 0) {
        // 0x1400010b0
        v17 = v4;
        v18 = -1;
        v19 = v17;
        while (v18 != 0) {
            v21 = v17 + v16;
            v20 = v18 - 1;
            v19 = v21;
            if (*(char *)v17 == 0) {
                // break -> 
                break;
            }
            v17 = v21;
            v18 = v20;
            v19 = v17;
        }
        v22 = v23 - 1;
        *(int32_t *)(v19 - 1) = 0x202020;
        v23 = v22;
        v11 = v16;
    }
    goto lab_0x1400010c6;
  lab_0x1400010c6:;
    int64_t v24 = -1; // 0x1400010d1
    int64_t v25 = v4; // 0x1400010d1
    int64_t v26 = 0; // 0x1400010d1
    while (v24 != 0) {
        int64_t v27 = v25;
        int64_t v28 = v24 - 1; // 0x1400010d1
        v24 = v28;
        v25 = v27 + v11;
        v26 = v28;
        if (*(char *)v27 == 0) {
            // break -> 
            break;
        }
        v26 = 0;
    }
    int64_t v29 = -0x200000000 - 0x100000000 * v26;
    int64_t v30 = v3 + 32; // 0x1400010df
    *(int32_t *)((v29 >> 32) + v30) = 0x7c2020;
    int64_t v31 = (v29 + 0x300000000 >> 32) + v30;
    int64_t v32 = 0; // 0x1400010f0
    int64_t v33 = 0; // 0x1400010f0
    int64_t v34 = 0; // 0x1400010f0
    if (v8 >= 0x100000000) {
        char v35 = *(char *)(v32 + v1); // 0x140001100
        *(char *)(v32 + v31) = v35 < 127 ? v35 : 46;
        int64_t v36 = v32 + 1; // 0x140001119
        v32 = v36;
        while (v36 < v9) {
            // 0x140001100
            v35 = *(char *)(v32 + v1);
            *(char *)(v32 + v31) = v35 < 127 ? v35 : 46;
            v36 = v32 + 1;
            v32 = v36;
        }
        int64_t v37 = v8 >> 32;
        v33 = v37;
        v34 = v9 & 0xffffffff;
        if (v8 >= 0x1000000000) {
            // 0x140001142
            *(int16_t *)(v37 + v31) = 124;
            printf("%s\n", &str);
            __security_check_cookie(g5);
            return &g29;
        }
    }
    int64_t v38 = v33;
    int64_t v39 = 16 - v38; // 0x14000112d
    memset((int64_t *)(v38 + v31), (int32_t)v38 & -256 | 32, (int32_t)v39);
    // 0x140001142
    *(int16_t *)((0x100000000 * (v34 + v39) >> 32) + v31) = 124;
    printf("%s\n", &str);
    __security_check_cookie(g5);
    return &g29;
}

// Address range: 0x140001190 - 0x140001283
int64_t function_140001190(int64_t a1) {
    // 0x140001190
    int32_t v1; // 0x140001190
    uint32_t v2 = v1;
    char * str = (char *)a1; // 0x1400011ad
    int64_t v3; // bp-88, 0x140001190
    if (_stat64i32(str, (struct _stat64i32 *)&v3) != 0) {
        // 0x1400011b7
        perror(str);
        __security_check_cookie(g5);
        return &g29;
    }
    struct _IO_FILE * file = fopen(str, "rb"); // 0x1400011ea
    if (file == NULL) {
        // 0x1400011f8
        perror(str);
        // 0x140001268
        __security_check_cookie(g5);
        return &g29;
    }
    int64_t v4 = 0; // 0x14000120c
    if (v2 != 0) {
        int64_t data; // bp-40, 0x140001190
        int32_t items_read = fread(&data, 1, 16, file); // 0x140001231
        while (items_read != 0) {
            int64_t v5 = items_read; // 0x140001231
            function_140001000(&data, v4, v5 & 0xffffffff);
            int64_t v6 = v4 + v5; // 0x14000124d
            v4 = v6 & 0xffffffff;
            if (v2 <= (int32_t)v6) {
                // break -> 0x14000125d
                break;
            }
            items_read = fread(&data, 1, 16, file);
        }
    }
    // 0x14000125d
    fclose(file);
    // 0x140001268
    __security_check_cookie(g5);
    return &g29;
}

// Address range: 0x140001290 - 0x1400012e1
int64_t function_140001290(int32_t a1, int64_t a2) {
    int64_t result = 0; // 0x1400012b4
    if (a1 < 2) {
        // 0x1400012ca
        return 0;
    }
    int64_t v1 = 1;
    int64_t v2 = v1 + 1; // 0x1400012c0
    result = function_140001190(*(int64_t *)(8 * v1 + a2)) + result & 0xffffffff;
    while (v2 != (int64_t)a1) {
        // 0x1400012b6
        v1 = v2;
        v2 = v1 + 1;
        result = function_140001190(*(int64_t *)(8 * v1 + a2)) + result & 0xffffffff;
    }
    // 0x1400012ca
    return result;
}

// Address range: 0x140001388 - 0x1400014d0
int64_t function_140001388(void) {
    int64_t v1 = *(int64_t *)(__readgsqword(48) + 8); // 0x14000139b
    int64_t v2 = g25; // 0x1400013a3
    g25 = v2 == 0 ? v1 : v2;
    int64_t v3 = v2; // 0x1400013ac
    int32_t v4 = 0; // 0x1400013ac
    if (v2 != 0) {
        v4 = 1;
        while (v3 != v1) {
            // 0x1400013bc
            Sleep(1000);
            v3 = g25;
            g25 = v3 == 0 ? v1 : v3;
            v4 = 0;
            if (v3 == 0) {
                // break -> 0x1400013ce
                break;
            }
            v4 = 1;
        }
    }
    int32_t v5 = g24; // 0x1400013ce
    if (v5 != 1) {
        if (v5 != 0) {
            // 0x140001415
            g13 = 1;
        } else {
            // 0x1400013ee
            g24 = 1;
            if (_initterm_e((int32_t (**)())&g3, (int32_t (**)())&g4) != 0) {
                // 0x14000140b
                return function_1400014fd();
            }
        }
    } else {
        // 0x1400013d8
        _amsg_exit(31);
    }
    // 0x14000141b
    if (g24 == 1) {
        // 0x140001425
        _initterm((void (**)())&g1, (void (**)())&g2);
        g24 = 2;
    }
    if (v4 == 0) {
        // 0x140001446
        g25 = 0;
    }
    // 0x14000144f
    if (g28 != 0) {
        // 0x140001459
        function_140001980(&g28);
    }
    // 0x140001478
    *(int64_t *)*(int64_t *)0x1400020b0 = g10;
    int32_t status = function_140001290(g8, g11); // 0x1400014a2
    g12 = status;
    if (g9 == 0) {
        // 0x1400014b1
        exit(status);
        // UNREACHABLE
    }
    // 0x1400014b9
    if (g13 == 0) {
        // 0x1400014c2
        _cexit();
    }
    // 0x1400014ce
    return function_1400014fd();
}

// Address range: 0x1400014d0 - 0x1400014fd
int64_t function_1400014d0(void) {
    // 0x1400014d0
    int64_t v1; // 0x1400014d0
    int32_t status = v1; // 0x1400014d0
    g12 = status;
    if (g9 == 0) {
        // 0x1400014df
        _exit(status);
        // UNREACHABLE
    }
    // 0x1400014e8
    if (g13 != 0) {
        function_1400014fd();
    }
    // 0x1400014f1
    _cexit();
    return g12;
}

// Address range: 0x1400014fd - 0x140001508
int64_t function_1400014fd(void) {
    // 0x1400014fd
    int64_t result; // 0x1400014fd
    return result;
}

// Address range: 0x140001508 - 0x1400015ed
int64_t function_140001508(void) {
    int32_t v1 = 0; // 0x140001518
    int64_t v2; // 0x140001508
    if (*(int16_t *)0x140000000 == 0x5a4d) {
        int64_t v3 = (int64_t)*(int32_t *)0x14000003c; // 0x14000151e
        v1 = 0;
        if (*(int32_t *)(v3 + 0x140000000) != 0x4550) {
            goto lab_0x14000156d;
        } else {
            int16_t v4 = *(int16_t *)(v3 + 0x140000018); // 0x140001537
            if (v4 == 267) {
                // 0x14000155c
                v1 = 0;
                if (*(int32_t *)(v3 + 0x140000074) < 15) {
                    goto lab_0x14000156d;
                } else {
                    // 0x140001564
                    v2 = v3 + 0x1400000e8;
                    goto lab_0x14000156a;
                }
            } else {
                // 0x140001542
                v1 = 0;
                if (v4 != 523) {
                    goto lab_0x14000156d;
                } else {
                    // 0x140001549
                    v1 = 0;
                    if (*(int32_t *)(v3 + 0x140000084) < 15) {
                        goto lab_0x14000156d;
                    } else {
                        // 0x140001554
                        v2 = v3 + 0x1400000f8;
                        goto lab_0x14000156a;
                    }
                }
            }
        }
    } else {
        goto lab_0x14000156d;
    }
  lab_0x14000156d:
    // 0x14000156d
    g9 = v1;
    __set_app_type(1);
    int64_t v5 = (int64_t)_encode_pointer((int64_t *)-1); // 0x140001582
    g26 = v5;
    g27 = v5;
    *(int32_t *)0x264c = g23;
    *(int32_t *)0x2640 = g22;
    _RTC_Initialize();
    function_1400019d0();
    if (g7 == 0) {
        // 0x1400015c7
        __setusermatherr(0x1400019d0);
    }
    // 0x1400015d4
    if (g6 == -1) {
        // 0x1400015dd
        _configthreadlocale(-1);
    }
    // 0x1400015e6
    return 0;
  lab_0x14000156a:
    // 0x14000156a
    v1 = *(int32_t *)v2 != 0;
    goto lab_0x14000156d;
}

// Address range: 0x1400015f0 - 0x140001602
void entry_point(void) {
    // 0x1400015f0
    __security_init_cookie();
    function_140001388();
}

// Address range: 0x140001604 - 0x14000174e
int64_t function_140001604(int64_t a1) {
    int64_t v1 = a1; // 0x140001604
    RtlCaptureContext((struct _CONTEXT *)&g18);
    int64_t v2 = g21; // 0x14000161d
    int64_t v3; // bp-40, 0x140001604
    struct _IMAGE_RUNTIME_FUNCTION_ENTRY * v4 = RtlLookupFunctionEntry(v2, &v3, NULL); // 0x140001636
    int64_t v5; // 0x140001604
    int32_t v6; // 0x140001604
    if (v4 == NULL) {
        // 0x140001689
        int64_t v7; // 0x140001604
        int32_t v8 = v7; // 0x140001691
        g21 = v8;
        g20 = &v1;
        v5 = a1;
        v6 = v8;
    } else {
        // 0x140001648
        int64_t v9; // bp-64, 0x140001604
        int64_t v10; // bp-72, 0x140001604
        RtlVirtualUnwind(0, v3, v2, v4, (struct _CONTEXT *)&g18, (int64_t **)&v10, &v9, NULL);
        v5 = v1;
        v6 = g21;
    }
    // 0x1400016ab
    g16 = v6;
    g19 = v5;
    *(int32_t *)&g14 = -0x3ffffbf7;
    *(int32_t *)&g15 = 1;
    g17 = IsDebuggerPresent();
    function_140001a88(1);
    SetUnhandledExceptionFilter(NULL);
    UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)0x1400021d0);
    if (g17 == 0) {
        // 0x140001728
        function_140001a88(1);
    }
    // 0x140001732
    return TerminateProcess(GetCurrentProcess(), -0x3ffffbf7);
}

// Address range: 0x140001750 - 0x140001791
int64_t function_140001750(int64_t a1) {
    // 0x140001750
    int64_t v1; // 0x140001750
    if ((int32_t)v1 != -0x1f928c9d || *(int32_t *)(a1 + 24) != 4) {
        // 0x14000178a
        return 0;
    }
    int32_t v2 = *(int32_t *)(a1 + 32); // 0x140001765
    if (v2 > 0x19930522 != v2 != 0x1994000) {
        // 0x140001784
        _3f_terminate_40__40_YAXXZ();
        __asm_int3();
    }
    // 0x14000178a
    return 0;
}

// Address range: 0x1400017ac - 0x1400017b2
void function_1400017ac(int32_t rterrnum) {
    // 0x1400017ac
    _amsg_exit(rterrnum);
}

// Address range: 0x140001864 - 0x14000187b
int64_t function_140001864(void) {
    // 0x140001864
    int64_t v1; // 0x140001864
    return _onexit((int32_t (*)())v1) == NULL ? 0xffffffff : 0;
}

// Address range: 0x1400018ec - 0x1400018f2
int64_t function_1400018ec(void) {
    // 0x1400018ec
    return __C_specific_handler();
}

// Address range: 0x1400018f2 - 0x1400018f8
int32_t function_1400018f2(int32_t xcptnum, int64_t * pxcptinfoptrs) {
    // 0x1400018f2
    return _XcptFilter(xcptnum, pxcptinfoptrs);
}

// Address range: 0x140001980 - 0x1400019c1
int64_t function_140001980(int64_t * a1) {
    int64_t result = _ValidateImageBase(0x140000000); // 0x140001991
    if ((int32_t)result == 0) {
        // 0x1400019bc
        return result;
    }
    int64_t v1 = _FindPESection(0x140000000, (int64_t)a1 - 0x140000000); // 0x1400019a3
    int64_t result2 = 0; // 0x1400019ab
    if (v1 != 0) {
        // 0x1400019ad
        result2 = (int64_t)(*(int32_t *)(v1 + 36) >> 31 ^ 1);
    }
    // 0x1400019bc
    return result2;
}

// Address range: 0x1400019c2 - 0x1400019c8
void function_1400019c2(void (**First)(), void (**Last)()) {
    // 0x1400019c2
    _initterm(First, Last);
}

// Address range: 0x1400019c8 - 0x1400019ce
int32_t function_1400019c8(int32_t (**First)(), int32_t (**Last)()) {
    // 0x1400019c8
    return _initterm_e(First, Last);
}

// Address range: 0x1400019d0 - 0x1400019d3
int64_t function_1400019d0(void) {
    // 0x1400019d0
    return 0;
}

// Address range: 0x140001a88 - 0x140001a8e
int64_t function_140001a88(int64_t a1) {
    // 0x140001a88
    return __crt_debugger_hook();
}

// Address range: 0x140001a8e - 0x140001a94
void function_140001a8e(void) {
    // 0x140001a8e
    _3f_terminate_40__40_YAXXZ();
}

// Address range: 0x140001a94 - 0x140001a9a
void function_140001a94(int32_t locknum) {
    // 0x140001a94
    _unlock(locknum);
}

// Address range: 0x140001a9a - 0x140001aa0
int32_t (*function_140001a9a(int32_t (*func)(), void (***pbegin)(), void (***pend)()))() {
    // 0x140001a9a
    return __dllonexit(func, pbegin, pend);
}

// Address range: 0x140001aa0 - 0x140001aa6
void function_140001aa0(int32_t locknum) {
    // 0x140001aa0
    _lock(locknum);
}

// Address range: 0x140001aa6 - 0x140001aac
int64_t (*function_140001aa6(int32_t HandlerType, int64_t ImageBase, int64_t ControlPc, struct _IMAGE_RUNTIME_FUNCTION_ENTRY * FunctionEntry, struct _CONTEXT * ContextRecord, int64_t ** HandlerData, int64_t * EstablisherFrame, struct _KNONVOLATILE_CONTEXT_POINTERS * ContextPointers))(struct _EXCEPTION_RECORD *, int64_t *, struct _CONTEXT *, int64_t *) {
    // 0x140001aa6
    return RtlVirtualUnwind(HandlerType, ImageBase, ControlPc, FunctionEntry, ContextRecord, HandlerData, EstablisherFrame, ContextPointers);
}

// Address range: 0x140001aac - 0x140001ab2
struct _IMAGE_RUNTIME_FUNCTION_ENTRY * function_140001aac(int64_t ControlPc, int64_t * ImageBase, struct _UNWIND_HISTORY_TABLE * HistoryTable) {
    // 0x140001aac
    return RtlLookupFunctionEntry(ControlPc, ImageBase, HistoryTable);
}

// Address range: 0x140001ab4 - 0x140001b17
int64_t function_140001ab4(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = a1; // 0x140001ace
    if ((a3 & 4) != 0) {
        int32_t v2 = *(int32_t *)(a3 + 4); // 0x140001ad4
        v1 = (int64_t)v2 + a1 & (int64_t)-*(int32_t *)(a3 + 8);
    }
    uint32_t v3 = *(int32_t *)(*(int64_t *)(a2 + 16) + 8); // 0x140001aee
    char v4 = *(char *)((int64_t)v3 + 3 + *(int64_t *)(a2 + 8)); // 0x140001af5
    int64_t v5 = a1; // 0x140001af9
    if ((v4 & 15) != 0) {
        // 0x140001afb
        v5 = (int64_t)(v4 & -16) + a1;
    }
    // 0x140001b07
    __security_check_cookie(v5 ^ *(int64_t *)(v1 + (0x100000000 * a3 >> 32 & -8)));
    return &g29;
}

// Address range: 0x140001b18 - 0x140001b35
int64_t function_140001b18(void) {
    // 0x140001b18
    int64_t v1; // 0x140001b18
    int64_t v2 = v1;
    function_140001ab4(v1, v2, *(int64_t *)(v2 + 56));
    return 1;
}

// Address range: 0x140001b36 - 0x140001b3c
int64_t * function_140001b36(int64_t * s, int32_t c, int32_t n) {
    // 0x140001b36
    return memset(s, c, n);
}

// Address range: 0x140001b40 - 0x140001b5c
int64_t function_140001b40(int64_t a1, int64_t a2) {
    // 0x140001b40
    int64_t v1; // 0x140001b40
    return _XcptFilter((int32_t)v1, (int64_t *)a1);
}

// Address range: 0x140001b5c - 0x140001b75
int64_t function_140001b5c(void) {
    // 0x140001b5c
    _unlock(8);
    return &g29;
}

// Address range: 0x140001b80 - 0x140001ba1
int64_t function_140001b80(int64_t a1, int64_t a2) {
    // 0x140001b80
    int64_t v1; // 0x140001b80
    return (int32_t)v1 == -0x3ffffffb;
}

// --------------- Statically Linked Functions ----------------

// void __fastcall __security_check_cookie(_In_ uintptr_t StackCookie);
// void __cdecl __security_init_cookie(void);
// int64_t _FindPESection(int64_t a1, int64_t a2);
// _onexit_t _onexit(_onexit_t Function);
// void __cdecl _RTC_Initialize(void);
// int64_t _ValidateImageBase(int64_t a1);

// --------------- Dynamically Linked Functions ---------------

// void _3f_terminate_40__40_YAXXZ(void);
// int64_t __C_specific_handler(void);
// int64_t __crt_debugger_hook(void);
// _onexit_t __dllonexit(_onexit_t func, _PVFV ** pbegin, _PVFV ** pend);
// void __set_app_type(int at);
// void __setusermatherr(_HANDLE_MATH_ERROR pf);
// void _amsg_exit(int rterrnum);
// void __cdecl _cexit(void);
// int __cdecl _configthreadlocale(_In_ int Flag);
// void * __cdecl _encode_pointer(void * ptr);
// void __cdecl _exit(_In_ int Code);
// void __cdecl _initterm(_In_ _PVFV * First, _In_ _PVFV * Last);
// int __cdecl _initterm_e(_PIFV * First, _In_ _PIFV * Last);
// void __cdecl _lock(int locknum);
// int __cdecl _stat64i32(_In_z_ char const * FileName, _Out_ struct _stat64i32 * Stat);
// void __cdecl _unlock(int locknum);
// int _XcptFilter(unsigned long xcptnum, void * pxcptinfoptrs);
// void exit(int status);
// int fclose(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// HANDLE GetCurrentProcess(VOID);
// BOOL IsDebuggerPresent(VOID);
// void * memset(void * s, int c, size_t n);
// void perror(const char * s);
// int printf(const char * restrict format, ...);
// VOID RtlCaptureContext(_Out_ PCONTEXT ContextRecord);
// PRUNTIME_FUNCTION RtlLookupFunctionEntry(_In_ ULONG64 ControlPc, _Out_ PULONG64 ImageBase, _Inout_opt_ PUNWIND_HISTORY_TABLE HistoryTable);
// PEXCEPTION_ROUTINE RtlVirtualUnwind(_In_ ULONG HandlerType, _In_ ULONG64 ImageBase, _In_ ULONG64 ControlPc, _In_ PRUNTIME_FUNCTION FunctionEntry, _Inout_ PCONTEXT ContextRecord, _Out_ PVOID * HandlerData, _Out_ PULONG64 EstablisherFrame, _Inout_opt_ PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
// LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(_In_opt_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// int sprintf(char * restrict s, const char * restrict format, ...);
// BOOL TerminateProcess(_In_ HANDLE hProcess, _In_ UINT uExitCode);
// LONG UnhandledExceptionFilter(_In_ struct _EXCEPTION_POINTERS * ExceptionInfo);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (9.0)
// Detected functions: 31

