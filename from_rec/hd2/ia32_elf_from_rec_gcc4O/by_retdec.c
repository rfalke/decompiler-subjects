//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int32_t dumpline(int32_t * a1, int32_t a2, int32_t a3);
int32_t hexdump(int32_t a1);

// --------------------- Global Variables ---------------------

int32_t g1;

// ------------------------ Functions -------------------------

// Address range: 0x8048600 - 0x80487af
int32_t dumpline(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2; // bp-4, 0x8048600
    int32_t v3 = &v2; // 0x8048601
    int32_t v4 = __readgsdword(20); // 0x804860f
    int32_t v5; // bp-112, 0x8048600
    __sprintf_chk((char *)&v5, 1, 80, "%08lX:", a2);
    int32_t v6 = a3 < 16 ? a3 : 16;
    int32_t v7 = 1; // 0x8048658
    int32_t v8; // 0x8048600
    bool v9; // 0x8048600
    if (v6 < 1) {
        goto lab_0x80486ac;
    } else {
        // 0x804865a
        int32_t v10; // bp-103, 0x8048600
        int32_t v11 = &v10; // 0x8048666
        int32_t v12 = 0; // 0x8048666
        unsigned char v13 = *(char *)(v12 + v1); // 0x8048668
        __sprintf_chk((char *)v11, 1, -1, " %02lX", (int32_t)v13);
        v12++;
        v11 += 3;
        while (v12 < v6) {
            // 0x8048668
            v13 = *(char *)(v12 + v1);
            __sprintf_chk((char *)v11, 1, -1, " %02lX", (int32_t)v13);
            v12++;
            v11 += 3;
        }
        if (v6 > 15) {
            int32_t v14 = &v5; // 0x8048779
            int32_t v15 = -1; // 0x8048788
            int32_t v16 = v14; // 0x8048788
            int32_t v17 = 0; // 0x8048788
            while (v15 != 0) {
                int32_t v18 = v16;
                v15--;
                v16 = v18 + (v9 ? -1 : 1);
                v17 = v15;
                if (*(char *)v18 == 0) {
                    // break -> 
                    break;
                }
                v17 = 0;
            }
            *(int32_t *)(v14 - 1 + -1 - v17) = 0x7c2020;
            v8 = 1 - v17;
            goto lab_0x8048707;
        } else {
            // 0x80486a9
            v7 = v6 + 1;
            goto lab_0x80486ac;
        }
    }
  lab_0x80486ac:;
    uint32_t v19 = v7;
    __strcat_chk((char *)&v5, "   ", 80);
    int32_t v20 = v19 + 1; // 0x80486d0
    while (v19 < 16) {
        // 0x80486ac
        v19 = v20;
        __strcat_chk((char *)&v5, "   ", 80);
        v20 = v19 + 1;
    }
    int32_t v21 = &v5; // 0x80486d2
    int32_t v22 = -1; // 0x80486e1
    int32_t v23 = v21; // 0x80486e1
    int32_t v24 = 0; // 0x80486e1
    while (v22 != 0) {
        int32_t v25 = v23;
        int32_t v26 = v22 - 1; // 0x80486e1
        v22 = v26;
        v23 = v25 + (v9 ? -1 : 1);
        v24 = v26;
        if (*(char *)v25 == 0) {
            // break -> 
            break;
        }
        v24 = 0;
    }
    *(int32_t *)(v21 - 1 + -1 - v24) = 0x7c2020;
    int32_t v27 = 1 - v24; // 0x80486ed
    v8 = v27;
    int32_t v28; // 0x8048600
    int32_t v29; // 0x8048600
    int32_t v30; // 0x8048600
    if (v6 >= 0 == (v6 != 0)) {
        goto lab_0x8048707;
    } else {
        // .dec_label_pc_80486fc_crit_edge
        v28 = v3 - 108 + v27;
        v30 = v27;
        v29 = 0;
        goto lab_0x80486fc;
    }
  lab_0x8048707:;
    int32_t v31 = v3 - 108 + v8;
    int32_t v32 = 0; // 0x8048713
    int32_t v33 = v31; // 0x8048713
    char v34 = *(char *)(v32 + v1); // 0x8048715
    *(char *)v33 = v34 < 127 ? v34 : 46;
    int32_t v35 = v32 + 1; // 0x8048728
    v32 = v35;
    v33++;
    while (v35 != v6) {
        // 0x8048715
        v34 = *(char *)(v32 + v1);
        *(char *)v33 = v34 < 127 ? v34 : 46;
        v35 = v32 + 1;
        v32 = v35;
        v33++;
    }
    // 0x8048732
    v28 = v31;
    v30 = v8;
    v29 = a3;
    int32_t v36 = v8; // 0x8048735
    if (a3 < 16) {
        goto lab_0x80486fc;
    } else {
        goto lab_0x8048747;
    }
  lab_0x80486fc:;
    int32_t v37 = v29 + v28; // 0x8048705
    *(char *)v37 = 32;
    int32_t v38 = v29 + 1; // 0x804873c
    v37++;
    int32_t v39 = v38; // 0x8048745
    v36 = v30;
    while (v38 < 16) {
        // 0x8048739
        *(char *)v37 = 32;
        v38 = v39 + 1;
        v37++;
        v39 = v38;
        v36 = v30;
    }
    goto lab_0x8048747;
  lab_0x8048747:
    // 0x8048747
    *(int16_t *)((int32_t)&v5 + 16 + v36) = 124;
    __printf_chk(1, "%s\n", &v5);
    int32_t result = 0; // 0x8048775
    if (v4 != __readgsdword(20)) {
        // 0x804879f
        __stack_chk_fail();
        result = &g1;
    }
    // 0x80487a4
    return result;
}

// Address range: 0x80487af - 0x80488a0
int32_t hexdump(int32_t a1) {
    // 0x80487af
    int32_t v1; // 0x80487af
    uint32_t v2 = v1;
    int32_t v3 = __readgsdword(20); // 0x80487be
    char * file_path = (char *)a1; // 0x80487de
    int32_t v4; // 0x80487af
    int32_t v5; // bp-136, 0x80487af
    if (__xstat(3, file_path, (struct stat *)&v5) == 0) {
        struct _IO_FILE * file = fopen(file_path, "rb"); // 0x8048804
        if (file == NULL) {
            // 0x8048823
            perror(file_path);
            v4 = 1;
        } else {
            int32_t v6 = 0; // 0x804881f
            if (v2 != 0) {
                int32_t data; // bp-48, 0x80487af
                int32_t items_read = fread(&data, 1, 16, file); // 0x804884f
                while (items_read != 0) {
                    // 0x804885a
                    dumpline(&data, v6, items_read);
                    int32_t v7 = items_read + v6; // 0x804886a
                    v6 = v7;
                    if (v2 <= v7) {
                        // break -> 0x8048871
                        break;
                    }
                    items_read = fread(&data, 1, 16, file);
                }
            }
            // 0x8048871
            fclose(file);
            v4 = 0;
        }
    } else {
        // 0x80487e7
        perror(file_path);
        v4 = 1;
    }
    int32_t result = v4; // 0x804888e
    if (v3 != __readgsdword(20)) {
        // 0x8048890
        __stack_chk_fail();
        result = &g1;
    }
    // 0x8048895
    return result;
}

// Address range: 0x80488a0 - 0x80488e0
int main(int argc, char ** argv) {
    int32_t v1 = 1; // 0x80488bd
    if (argc < 2) {
        // 0x80488d4
        return 0;
    }
    int32_t result = 0; // 0x80488bd
    result += hexdump(*(int32_t *)(4 * v1 + (int32_t)argv));
    v1++;
    while (v1 != argc) {
        // 0x80488bf
        result += hexdump(*(int32_t *)(4 * v1 + (int32_t)argv));
        v1++;
    }
    // 0x80488d4
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int __printf_chk(int flag, const char * restrict format, ...);
// int __sprintf_chk(char * restrict s, int flag, size_t slen, const char * restrict format, ...);
// void __stack_chk_fail(void);
// char * __strcat_chk(char * restrict s, const char * restrict append, size_t slen);
// int __xstat(int ver, const char * filename, struct stat * stat_buf);
// int fclose(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void perror(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.5.x)
// Detected functions: 3

