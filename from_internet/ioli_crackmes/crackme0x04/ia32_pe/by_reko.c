// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw405000 = 0x00; // 00405000
word32 g_dw405004 = 0x00; // 00405004
word32 g_dw405030 = 0x00; // 00405030
word32 g_dw405040 = 0x00; // 00405040
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

int32 g_dw403000 = -1; // 00403000
word32 g_dw403010 = 0x4000; // 00403010
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw406040 = 0x614C; // 00406040
word32 g_dw406044 = 24920; // 00406044
word32 g_dw406048 = 0x616C; // 00406048
word32 g_dw40604C = 0x617C; // 0040604C
word32 g_dw406050 = 0x6188; // 00406050
word32 g_dw406054 = 24984; // 00406054
word32 g_dw406058 = 0x61B0; // 00406058
word32 g_dw40605C = 25032; // 0040605C
word32 g_dw406060 = 25052; // 00406060
word32 g_dw406064 = 0x61FC; // 00406064
word32 g_dw406068 = 0x6204; // 00406068
word32 g_dw406074 = 25116; // 00406074
word32 g_dw406078 = 0x622C; // 00406078
word32 g_dw40607C = 0x623C; // 0040607C
word32 g_dw406080 = 0x624C; // 00406080
word32 g_dw406084 = 0x6260; // 00406084
word32 g_dw406088 = 0x626C; // 00406088
word32 g_dw40608C = 25208; // 0040608C
word32 g_dw406090 = 0x6280; // 00406090
word32 g_dw406094 = 25228; // 00406094
word32 g_dw406098 = 25240; // 00406098
word32 g_dw40609C = 0x62A0; // 0040609C
word32 g_dw4060A0 = 25260; // 004060A0
word32 g_dw4060A4 = 25268; // 004060A4
word32 g_dw4060A8 = 25276; // 004060A8
word32 g_dw4060AC = 25288; // 004060AC
word32 g_dw4060B0 = 25300; // 004060B0
word32 g_dw4060B4 = 0x62DC; // 004060B4
word32 g_dw4060B8 = 25320; // 004060B8
word32 g_dw4060BC = 25332; // 004060BC
<anonymous> * __imp__AddAtomA = &g_t614C; // 004060C8
<anonymous> * __imp__CreateSemaphoreA = &g_t6158; // 004060CC
<anonymous> * __imp__ExitProcess = &g_t616C; // 004060D0
<anonymous> * __imp__FindAtomA = &g_t617C; // 004060D4
<anonymous> * __imp__GetAtomNameA = &g_t6188; // 004060D8
<anonymous> * __imp__InterlockedDecrement = &g_t6198; // 004060DC
<anonymous> * __imp__InterlockedIncrement = &g_t61B0; // 004060E0
<anonymous> * __imp__ReleaseSemaphore = &g_t61C8; // 004060E4
<anonymous> * __imp__SetUnhandledExceptionFilter = &g_t61DC; // 004060E8
<anonymous> * __imp__Sleep = &g_t61FC; // 004060EC
<anonymous> * __imp__WaitForSingleObject = &g_t6204; // 004060F0
<anonymous> * __imp____getmainargs = &g_t621C; // 004060FC
<anonymous> * __imp____p__environ = &g_t622C; // 00406100
<anonymous> * __imp____p__fmode = &g_t623C; // 00406104
<anonymous> * __imp____set_app_type = &g_t624C; // 00406108
<anonymous> * __imp___assert = &g_t6260; // 0040610C
<anonymous> * __imp___cexit = &g_t626C; // 00406110
<anonymous> * __imp___iob = &g_t6278; // 00406114
<anonymous> * __imp___onexit = &g_t6280; // 00406118
<anonymous> * __imp___setmode = &g_t628C; // 0040611C
<anonymous> * __imp__abort = &g_t6298; // 00406120
<anonymous> * __imp__atexit = &g_t62A0; // 00406124
<anonymous> * __imp__exit = &g_t62AC; // 00406128
<anonymous> * __imp__free = &g_t62B4; // 0040612C
<anonymous> * __imp__malloc = &g_t62BC; // 00406130
<anonymous> * __imp__printf = &g_t62C8; // 00406134
<anonymous> * __imp__scanf = &g_t62D4; // 00406138
<anonymous> * __imp__signal = &g_t62DC; // 0040613C
<anonymous> * __imp__sscanf = &g_t62E8; // 00406140
<anonymous> * __imp__strlen = &g_t62F4; // 00406144
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_str404000[] = "%d"; // 00404000
char g_str404003[] = "Password OK!\n"; // 00404003
char g_str404011[] = "Password Incorrect!\n"; // 00404011
char g_str404026[] = "IOLI Crackme Level 0x04\n"; // 00404026
char g_str40403F[] = "Password: "; // 0040403F
char g_str40404A[] = "%s"; // 0040404A
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

LONG g_t401000(struct _EXCEPTION_POINTERS * ExceptionInfo) = ??/* Unexpected function type (fn LONG ((ptr32 (struct "_EXCEPTION_POINTERS" 0008)))) */ ; // 00401000
// 00401140: void fn00401140()
// Called from:
//      Win32CrtStartup
void fn00401140()
{
	ptr32 fp;
	char ** ptrLoc10;
	SetUnhandledExceptionFilter(&g_t401000);
	fn00401430();
	__getmainargs(&g_dw405004, &g_dw405000, &ptrLoc10, g_dw403000);
	struct Eq_24 * esp_101 = fp - 44;
	word32 eax_28 = g_dw405030;
	if (eax_28 != 0x00)
	{
		g_dw403010 = eax_28;
		ptr32 edx_34 = iob;
		if (iob != 0x00)
		{
			setmode(iob->dw0010, eax_28);
			edx_34 = iob;
		}
		if (edx_34 != ~0x1F)
		{
			setmode(iob->dw0030, g_dw405030);
			edx_34 = iob;
		}
		if (edx_34 != ~0x3F)
			setmode(iob->dw0050, g_dw405030);
	}
	*__p__fmode() = g_dw403010;
	word32 ecx_95 = fn00401400();
	__align_stack<word32>(esp_101);
	esp_101->dw0008 = *__p__environ();
	esp_101->dw0004 = g_dw405000;
	esp_101->dw0000 = g_dw405004;
	Eq_67 eax_109 = fn00401395(ecx_95);
	cexit();
	*esp_120 = (uint32) eax_109;
	ExitProcess(*esp_120);
}

// 00401260: Register Eq_126 Win32CrtStartup()
Eq_126 Win32CrtStartup()
{
	__set_app_type(0x01);
	fn00401140();
}

// 004012A0: void fn004012A0(Stack (ptr32 Eq_135) ptrArg04)
// Called from:
//      Win32CrtStartup
//      fn004014D0
void fn004012A0(void (* ptrArg04)())
{
	atexit(ptrArg04);
}

// 00401310: void fn00401310(Stack (ptr32 char) dwArg04)
// Called from:
//      fn00401395
void fn00401310(char * dwArg04)
{
	char bLoc11;
	int32 dwLoc08;
	word32 dwLoc0C_52 = 0x00;
	Eq_145 dwLoc10_53 = 0x00;
	while (dwLoc10_53 < strlen(dwArg04))
	{
		Mem29[&bLoc11 + 0x00:byte] = Mem16[dwLoc10_53 + dwArg04:byte];
		sscanf(&bLoc11, "%d", &dwLoc08);
		word32 v10_38 = dwLoc0C_52 + dwLoc08;
		dwLoc0C_52 = v10_38;
		if (v10_38 == 0x0F)
		{
			printf("Password OK!\n");
			exit(0x00);
		}
		dwLoc10_53 = (word32) dwLoc10_53.u0 + 1;
	}
	printf("Password Incorrect!\n");
}

// 00401395: Register word32 fn00401395(Register word32 ecx)
// Called from:
//      fn00401140
word32 fn00401395(word32 ecx)
{
	ptr32 fp;
	char bLoc7C;
	<anonymous> * dwLocA0;
	__align_stack<word32>(fp - 0x9C);
	fn00402CD0(0x10, ecx, dwLocA0);
	fn004014D0();
	printf("IOLI Crackme Level 0x04\n");
	printf("Password: ");
	scanf("%s", &bLoc7C);
	fn00401310(&bLoc7C);
	return 0x00;
}

// 00401400: Register (ptr32 Eq_229) fn00401400()
// Called from:
//      fn00401140
struct Eq_229 * fn00401400()
{
	struct Eq_229 * ecx_15;
	for (ecx_15 = (struct Eq_229 *) 0x00404300; ecx_15 < (struct Eq_229 *) 0x00404300; ++ecx_15)
	{
		struct Eq_234 * edx_13 = ecx_15->dw0004;
		edx_13->dw400000 += ecx_15->dw0000;
	}
	return ecx_15;
}

// 00401430: void fn00401430()
// Called from:
//      fn00401140
void fn00401430()
{
	__fninit();
}

Eq_135 g_t401440 = ??/* Unexpected function type (fn void ()) */ ; // 00401440
// 004014D0: void fn004014D0()
// Called from:
//      fn00401395
void fn004014D0()
{
	if (g_dw405040 != 0x00)
		return;
	g_dw405040 = 0x01;
	ui32 eax_24 = g_dw402ED0;
	if (eax_24 == ~0x00)
	{
		eax_24 = 0x00;
		bool v19_85 = g_dw402ED4 != 0x00;
		while (v19_85)
		{
			++eax_24;
			v19_85 = (&g_dw402ED4)[eax_24 * 0x04] != 0x00;
		}
	}
	ui32 ebx_41 = eax_24;
	if (eax_24 != 0x00)
	{
		do
		{
			fn90909090();
			--ebx_41;
		} while (ebx_41 != 0x00);
	}
	fn004012A0(&g_t401440);
}

// 00402CD0: void fn00402CD0(Register uint32 eax, Register word32 ecx, Stack (ptr32 code) dwArg00)
// Called from:
//      fn00401395
void fn00402CD0(uint32 eax, word32 ecx, <anonymous> * dwArg00)
{
	ptr32 fp;
	struct Eq_293 * ecx_13 = fp + 0x04;
	for (; eax >= 0x1000; eax -= 0x1000)
	{
		ecx_13 -= 0x1000;
		ecx_13->dw0000 = ecx_13->dw0000;
	}
	word32 * ecx_14 = ecx_13 - eax;
	*ecx_14 = *ecx_14;
	dwArg00();
}

ui32 g_dw402ED0 = ~0x00; // 00402ED0
word32 g_dw402ED4 = 0x00402EB0; // 00402ED4
