// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw406000 = 0x00; // 00406000
word32 g_dw406004 = 0x00; // 00406004
word32 g_dw406030 = 0x00; // 00406030
word32 g_dw406040 = 0x00; // 00406040
word32 g_dw406050 = 0x00; // 00406050
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

int32 g_dw404000 = -1; // 00404000
word32 g_dw404010 = 0x4000; // 00404010
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw407040 = 29012; // 00407040
word32 g_dw407044 = 0x7160; // 00407044
word32 g_dw407048 = 0x7174; // 00407048
word32 g_dw40704C = 29060; // 0040704C
word32 g_dw407050 = 0x7190; // 00407050
word32 g_dw407054 = 0x71A0; // 00407054
word32 g_dw407058 = 29112; // 00407058
word32 g_dw40705C = 0x71D0; // 0040705C
word32 g_dw407060 = 0x71E4; // 00407060
word32 g_dw407064 = 0x7204; // 00407064
word32 g_dw407068 = 0x720C; // 00407068
word32 g_dw407074 = 29220; // 00407074
word32 g_dw407078 = 29236; // 00407078
word32 g_dw40707C = 29252; // 0040707C
word32 g_dw407080 = 29268; // 00407080
word32 g_dw407084 = 29288; // 00407084
word32 g_dw407088 = 0x7274; // 00407088
word32 g_dw40708C = 0x7280; // 0040708C
word32 g_dw407090 = 0x7288; // 00407090
word32 g_dw407094 = 29332; // 00407094
word32 g_dw407098 = 0x72A0; // 00407098
word32 g_dw40709C = 29352; // 0040709C
word32 g_dw4070A0 = 0x72B4; // 004070A0
word32 g_dw4070A4 = 29372; // 004070A4
word32 g_dw4070A8 = 0x72C4; // 004070A8
word32 g_dw4070AC = 29392; // 004070AC
word32 g_dw4070B0 = 29404; // 004070B0
word32 g_dw4070B4 = 29412; // 004070B4
word32 g_dw4070B8 = 29424; // 004070B8
word32 g_dw4070BC = 0x72FC; // 004070BC
word32 g_dw4070C0 = 0x7308; // 004070C0
<anonymous> * __imp__AddAtomA = &g_t7154; // 004070CC
<anonymous> * __imp__CreateSemaphoreA = &g_t7160; // 004070D0
<anonymous> * __imp__ExitProcess = &g_t7174; // 004070D4
<anonymous> * __imp__FindAtomA = &g_t7184; // 004070D8
<anonymous> * __imp__GetAtomNameA = &g_t7190; // 004070DC
<anonymous> * __imp__InterlockedDecrement = &g_t71A0; // 004070E0
<anonymous> * __imp__InterlockedIncrement = &g_t71B8; // 004070E4
<anonymous> * __imp__ReleaseSemaphore = &g_t71D0; // 004070E8
<anonymous> * __imp__SetUnhandledExceptionFilter = &g_t71E4; // 004070EC
<anonymous> * __imp__Sleep = &g_t7204; // 004070F0
<anonymous> * __imp__WaitForSingleObject = &g_t720C; // 004070F4
<anonymous> * __imp____getmainargs = &g_t7224; // 00407100
<anonymous> * __imp____p__environ = &g_t7234; // 00407104
<anonymous> * __imp____p__fmode = &g_t7244; // 00407108
<anonymous> * __imp____set_app_type = &g_t7254; // 0040710C
<anonymous> * __imp___assert = &g_t7268; // 00407110
<anonymous> * __imp___cexit = &g_t7274; // 00407114
<anonymous> * __imp___iob = &g_t7280; // 00407118
<anonymous> * __imp___onexit = &g_t7288; // 0040711C
<anonymous> * __imp___setmode = &g_t7294; // 00407120
<anonymous> * __imp__abort = &g_t72A0; // 00407124
<anonymous> * __imp__atexit = &g_t72A8; // 00407128
<anonymous> * __imp__exit = &g_t72B4; // 0040712C
<anonymous> * __imp__free = &g_t72BC; // 00407130
<anonymous> * __imp__malloc = &g_t72C4; // 00407134
<anonymous> * __imp__printf = &g_t72D0; // 00407138
<anonymous> * __imp__scanf = &g_t72DC; // 0040713C
<anonymous> * __imp__signal = &g_t72E4; // 00407140
<anonymous> * __imp__sscanf = &g_t72F0; // 00407144
<anonymous> * __imp__strlen = &g_t72FC; // 00407148
<anonymous> * __imp__strncmp = &g_t7308; // 0040714C
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_str405000[] = "LOLO"; // 00405000
char g_str405005[] = "Password Incorrect!\n"; // 00405005
char g_str40501A[] = "%d"; // 0040501A
char g_str40501D[] = "Password OK!\n"; // 0040501D
char g_str40502B[] = "wtf?\n"; // 0040502B
char g_str405031[] = "IOLI Crackme Level 0x08\n"; // 00405031
char g_str40504A[] = "Password: "; // 0040504A
char g_str405055[] = "%s"; // 00405055
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

LONG g_t401000(struct _EXCEPTION_POINTERS * ExceptionInfo) = ??/* Unexpected function type (fn LONG ((ptr32 (struct "_EXCEPTION_POINTERS")))) */ ; // 00401000
// 00401140: void fn00401140()
// Called from:
//      Win32CrtStartup
void fn00401140()
{
	SetUnhandledExceptionFilter(&g_t401000);
	fn00401580();
	__getmainargs(&g_dw406004, &g_dw406000, fp - 0x10, g_dw404000);
	struct Eq_24 * esp_15 = fp - 44;
	word32 eax_28 = g_dw406040;
	if (eax_28 != 0x00)
	{
		g_dw404010 = eax_28;
		ptr32 edx_33 = iob;
		if (iob != 0x00)
		{
			word32 eax_39 = iob->dw0010;
			setmode();
			edx_33 = iob;
		}
		if (edx_33 != ~0x1F)
		{
			esp_15->dw0004 = g_dw406040;
			word32 eax_55 = iob->dw0030;
			esp_15->dw0000 = eax_55;
			setmode();
			edx_33 = iob;
		}
		if (edx_33 != ~0x3F)
		{
			esp_15->dw0004 = g_dw406040;
			word32 eax_74 = iob->dw0050;
			esp_15->dw0000 = eax_74;
			setmode();
		}
	}
	*__p__fmode() = g_dw404010;
	fn00401550();
	__align(esp_15);
	struct Eq_47 * esp_104;
	char * (** eax_105)[];
	word32 ecx_108;
	_p__environ();
	esp_104->ptr0008 = (char * (*)[]) *eax_105;
	esp_104->dw0004 = g_dw406000;
	esp_104->dw0000 = g_dw406004;
	UINT * esp_123;
	cexit();
	*esp_123 = (uint32) fn004014D9(ecx_108, esp_104->ptr0008);
	ExitProcess(*esp_123);
}

// 00401260: Register Eq_144 Win32CrtStartup()
Eq_144 Win32CrtStartup()
{
	__set_app_type(0x01);
	fn00401140();
}

// 004012A0: void fn004012A0(Stack (ptr32 Eq_153) ptrArg04)
// Called from:
//      Win32CrtStartup
//      fn00401620
void fn004012A0(void (* ptrArg04)())
{
	atexit(ptrArg04);
}

// 00401310: Register word32 fn00401310(Stack (arr (ptr32 char)) dwArg08)
// Called from:
//      fn0040139E
//      fn00401415
word32 fn00401310(char * dwArg08[])
{
	ui32 dwLoc08_43 = 0x00;
	do
	{
		word32 dwLoc0C_46;
		if (dwArg08[dwLoc08_71] == null)
		{
			dwLoc0C_46 = 0x00;
			return dwLoc0C_46;
		}
		dwLoc08_43 = dwLoc08_71 + 0x01;
		dwLoc08_71 = dwLoc08_43;
	} while (strncmp(dwArg08[dwLoc08_71], "LOLO", 0x03) != 0x00);
	g_dw406030 = 0x01;
	dwLoc0C_46 = 0x01;
	return dwLoc0C_46;
}

// 00401380: void fn00401380()
// Called from:
//      fn00401415
void fn00401380()
{
	printf("Password Incorrect!\n");
	exit(null);
}

// 0040139E: void fn0040139E(Stack (ptr32 char) dwArg04, Stack (ptr32 (arr (ptr32 char))) dwArg08)
// Called from:
//      fn00401415
void fn0040139E(char * dwArg04, char * (* dwArg08)[])
{
	sscanf(dwArg04, "%d", fp - 0x08);
	if (fn00401310(dwArg08) != 0x00)
	{
		int32 dwLoc0C_65;
		for (dwLoc0C_65 = 0x00; dwLoc0C_65 <= 0x09; ++dwLoc0C_65)
		{
			if ((dwLoc08 & 0x01) == 0x00)
			{
				if (g_dw406030 == 0x01)
					printf("Password OK!\n");
				exit(null);
			}
		}
	}
}

// 00401415: void fn00401415(Register (ptr32 Eq_238) ebp, Stack (ptr32 char) dwArg04, Stack (ptr32 (arr (ptr32 char))) dwArg08)
// Called from:
//      fn004014D9
void fn00401415(struct Eq_238 * ebp, char * dwArg04, char * (* dwArg08)[])
{
	word32 dwLoc0C_78 = 0x00;
	size_t dwLoc10_79 = 0x00;
	while (dwLoc10_79 < strlen(dwArg04))
	{
		sscanf(fp - 0x11, "%d", fp - 0x08);
		word32 v9_53 = dwLoc0C_78 + dwLoc08;
		dwLoc0C_78 = v9_53;
		if (v9_53 == 0x10)
			fn0040139E(dwArg04, dwArg08);
		dwLoc10_79 = (Eq_171) ((word32) dwLoc10_79 + 1);
	}
	fn00401380();
}

// 004014D9: Register word32 fn004014D9(Register word32 ecx, Stack (ptr32 (arr (ptr32 char))) dwArg0C)
// Called from:
//      fn00401140
word32 fn004014D9(word32 ecx, char * (* dwArg0C)[])
{
	__align(fp - 0x9C);
	fn00402E20(0x10, ecx, dwLocA0);
	fn00401620();
	printf("IOLI Crackme Level 0x08\n");
	printf("Password: ");
	scanf("%s", fp - 0x7C);
	fn00401415(fp - 4, fp - 0x7C, dwArg0C);
	return 0x00;
}

// 00401550: void fn00401550()
// Called from:
//      fn00401140
void fn00401550()
{
	struct Eq_356 * ecx_15;
	for (ecx_15 = (struct Eq_356 *) 0x00405310; ecx_15 < (struct Eq_356 *) 0x00405310; ++ecx_15)
	{
		struct Eq_360 * edx_13 = ecx_15->dw0004;
		edx_13->dw400000 += ecx_15->dw0000;
	}
}

// 00401580: void fn00401580()
// Called from:
//      fn00401140
void fn00401580()
{
	__fninit();
}

Eq_153 g_t401590 = ??/* Unexpected function type (fn void ()) */ ; // 00401590
// 00401620: void fn00401620()
// Called from:
//      fn004014D9
void fn00401620()
{
	if (g_dw406050 != 0x00)
		return;
	g_dw406050 = 0x01;
	ui32 eax_23 = g_dw403030;
	if (eax_23 == ~0x00)
	{
		eax_23 = 0x00;
		bool v14_82 = g_dw403034 != 0x00;
		while (v14_82)
		{
			++eax_23;
			v14_82 = (&g_dw403034)[eax_23 * 0x04] != 0x00;
		}
	}
	ui32 ebx_38 = eax_23;
	if (eax_23 != 0x00)
	{
		do
		{
			word32 ecx_56;
			fn90909090();
			--ebx_38;
		} while (ebx_38 != 0x00);
	}
	fn004012A0(&g_t401590);
}

// 00402E20: void fn00402E20(Register uint32 eax, Register word32 ecx, Stack (ptr32 code) dwArg00)
// Called from:
//      fn004014D9
void fn00402E20(uint32 eax, word32 ecx, <anonymous> * dwArg00)
{
	struct Eq_419 * ecx_13 = fp + 0x04;
	for (; eax >= 0x1000; eax -= 0x1000)
	{
		ecx_13 -= 0x1000;
		ecx_13->dw0000 = ecx_13->dw0000;
	}
	word32 * ecx_14 = ecx_13 - eax;
	*ecx_14 = *ecx_14;
	dwArg00();
}

ui32 g_dw403030 = ~0x00; // 00403030
word32 g_dw403034 = 0x00403010; // 00403034
