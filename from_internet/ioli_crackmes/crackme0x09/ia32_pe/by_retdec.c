//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct _EXCEPTION_POINTERS {
    struct _EXCEPTION_RECORD * e0;
    struct _CONTEXT * e1;
};

struct _EXCEPTION_RECORD {
    int32_t e0;
    int32_t e1;
    struct _EXCEPTION_RECORD * e2;
    int32_t * e3;
    int32_t e4;
    int32_t e5[1];
};

struct _M128A {
    int32_t e0;
    int64_t e1;
};

struct _CONTEXT {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int16_t e10;
    int16_t e11;
    int16_t e12;
    int16_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    int32_t e21;
    int32_t e22;
    int32_t e23;
    int32_t e24;
    int32_t e25;
    int32_t e26;
    int32_t e27;
    int32_t e28;
    int32_t e29;
    int32_t e30;
    int32_t e31;
    int32_t e32;
    int32_t e33;
    int32_t e34;
    int32_t e35;
    int32_t e36;
    int32_t e37;
    int32_t e38;
    struct _M128A e39[26];
    int32_t e40;
    int32_t e41;
    int32_t e42;
    int32_t e43;
    int32_t e44;
    int32_t e45;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(void);
int32_t function_401000(int32_t a1);
int32_t function_401140(void);
int32_t function_401280(void);
int32_t function_4012a0(void);
int32_t function_4012b0(void);
int32_t function_4012c0(void);
int32_t function_4012f0(void);
int32_t function_401310(int32_t a1);
int32_t function_401385(void);
int32_t function_4013a3(int32_t str, int32_t a2);
int32_t function_40141a(int32_t * str, int32_t a2);
int32_t function_401490(void);
int32_t function_4014de(int32_t a1);
int32_t function_401550(void);
int32_t function_401580(void);
int32_t function_401590(void);
int32_t function_4015c0(void);
int32_t function_401620(void);
int32_t function_401640(void);
int32_t function_401690(void);
int32_t function_4016e0(void);
int32_t function_401750(int32_t a1, int32_t * a2);
int32_t function_401820(void);
int32_t function_401870(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401900(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4019f0(int32_t * a1, int32_t a2);
int32_t function_401a20(int32_t a1);
int32_t function_401a60(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_401b60(int32_t a1, int32_t a2);
int32_t function_401b90(int32_t a1);
int32_t function_401bc0(int32_t a1);
int32_t function_401d50(int32_t * a1, int32_t a2);
int32_t function_401d60(int32_t result);
int32_t function_401d90(void);
int32_t function_401df0(void);
int32_t function_401e80(int32_t a1, int32_t a2);
int32_t function_401ea0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401f20(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401fb0(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_402040(int32_t a1);
int32_t function_4020b0(void);
int32_t function_4021d0(int32_t a1);
int32_t function_4022d0(int32_t a1);
int32_t function_4023e1(void);
int32_t function_4023f0(void);
int32_t function_402970(uint32_t a1, int32_t a2);
int32_t function_402b50(void);
int32_t function_402b60(void);
int32_t function_402c00(void);
int32_t function_402e20(int32_t result);
void (*function_402e50(int32_t sig, void (*handler)(int32_t)))(int32_t);
int32_t function_402e58(void);
int32_t function_402e68(void);
int32_t function_402e78(void);
int32_t function_402e88(void);
int32_t * function_402ea0(void);
int32_t function_402eb0(int32_t * Argc, char *** Argv, char *** Env, int32_t DoWildCard, int32_t * StartInfo);
int32_t function_402ec0(char * format, ...);
int32_t function_402ed0(char * s);
int32_t function_402ee0(char * s, char * format, ...);
int32_t function_402ef0(char * format, ...);
void function_402f00(int32_t status);
int32_t function_402f10(char * s1, char * s2, int32_t n);
void function_402f20(int32_t * ptr);
int32_t * function_402f30(int32_t size);
void function_402f40(void);
int32_t function_402f50(char * a1, int32_t a2, int32_t a3);
void function_402f60(int32_t uExitCode);
int32_t (*function_402f70(int32_t (*lpTopLevelExceptionFilter)(struct _EXCEPTION_POINTERS *)))(struct _EXCEPTION_POINTERS *);
bool function_402f80(int32_t * hSemaphore, int32_t lReleaseCount, int32_t * lpPreviousCount);
int32_t function_402f90(int32_t * Addend);
int32_t function_402fa0(int32_t * hHandle, int32_t dwMilliseconds);
int32_t * function_402fb0(struct _SECURITY_ATTRIBUTES * lpSemaphoreAttributes, int32_t lInitialCount, int32_t lMaximumCount, char * lpName);
void function_402fc0(int32_t dwMilliseconds);
int32_t function_402fd0(int32_t * Addend);
int32_t function_402fe0(int16_t nAtom, char * lpBuffer, int32_t nSize);
int16_t function_402ff0(char * lpString);
int16_t function_403000(char * lpString);
int32_t function_403008(void);
int32_t function_403020(void);
int32_t function_40303f(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x403010; // 0x403034
int32_t g2 = 0; // 0x403044
int32_t g3 = -1; // 0x404000
int32_t g4 = 0x4000; // 0x404010
int32_t g5 = 0x403040; // 0x404020
int32_t g6 = 0; // 0x404030
int32_t g7 = -1; // 0x404034
int32_t g8 = 0; // 0x404038
int32_t g9 = -1; // 0x40403c
int32_t g10 = 16; // 0x405160
char *** g11 = NULL; // 0x406000
int32_t g12 = 0; // 0x406004
int32_t g13 = 0; // 0x406010
int32_t g14 = 0; // 0x406030
int32_t g15 = 0; // 0x406040
int32_t g16 = 0; // 0x406050
int32_t g17 = 0; // 0x406070
int32_t g18 = 0; // 0x406074
int32_t g19 = 0; // 0x406080
int32_t g20 = 0; // 0x406084
int32_t g21 = 0; // 0x406090
int32_t g22 = 0; // 0x4060a0
int32_t g23 = 0; // 0x4060b0
int32_t g24 = 0; // 0x4060c0
int32_t g25 = 0; // 0x4060d0
int32_t g26;
int32_t g27;

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x40113f
int32_t function_401000(int32_t a1) {
    uint32_t v1 = *(int32_t *)*(int32_t *)a1; // 0x401015
    int32_t v2; // 0x401000
    int32_t sig_handler; // 0x401000
    bool v3; // 0x401000
    if (v1 < 0xc0000092) {
        // 0x40101e
        v2 = 1;
        if (v1 < 0xc000008d) {
            if (v1 == -0x3ffffffb) {
                // 0x4010e4
                sig_handler = 11;
                switch ((int32_t)v4) {
                    case 1: {
                        goto lab_0x401122;
                    }
                    case 0: {
                        return 0;
                    }
                    default: {
                        return -1;
                    }
                }
            } else {
                // 0x401087
                v3 = v1 == -0x3fffffe3;
                goto lab_0x40108c;
            }
        } else {
            goto lab_0x40102a;
        }
    } else {
        // 0x401062
        v2 = 0;
        if (v1 == -0x3fffff6c) {
            goto lab_0x40102a;
        } else {
            if (v1 < 0xc0000095) {
                // 0x40106b
                v2 = 1;
                if (v1 != -0x3fffff6d) {
                    // 0x401054
                    return 0;
                }
                goto lab_0x40102a;
            } else {
                // 0x4010b5
                v3 = v1 == -0x3fffff6a;
                goto lab_0x40108c;
            }
        }
    }
  lab_0x40102a:
    // 0x40102a
    switch ((int32_t)v5) {
        case 1: {
            // 0x4010bc
            signal(SIGFPE, SIG_IGN);
            if (v2 != 0) {
                // 0x4010da
                function_401580();
            }
            // 0x401054
            return -1;
        }
        case 0: {
            return 0;
        }
        default: {
            return -1;
        }
    }
  lab_0x401122:
    // 0x401122
    signal(sig_handler, SIG_IGN);
    // 0x401054
    return -1;
  lab_0x40108c:
    // 0x40108c
    if (!v3) {
        // 0x401054
        return 0;
    }
    // 0x40108e
    sig_handler = 4;
    switch ((int32_t)v6) {
        case 1: {
            goto lab_0x401122;
        }
        case 0: {
            return 0;
        }
        default: {
            return -1;
        }
    }
}

// Address range: 0x401140 - 0x401257
int32_t function_401140(void) {
    // 0x401140
    SetUnhandledExceptionFilter((int32_t (*)(struct _EXCEPTION_POINTERS *))0x401000);
    function_401580();
    int32_t v1 = 0; // bp-12, 0x40115b
    int32_t v2; // bp-16, 0x401140
    __getmainargs(&g12, (char ***)&g11, (char ***)&v2, g3, &v1);
    int32_t v3; // 0x4011c9
    if (g15 == 0) {
        goto lab_0x4011f0;
    } else {
        // 0x401197
        g4 = g15;
        int32_t v4 = *(int32_t *)0x407118; // 0x40119c
        int32_t v5 = v4; // 0x4011a4
        if (v4 != 0) {
            // 0x401237
            _setmode(*(int32_t *)(v4 + 16), g15);
            v5 = *(int32_t *)0x407118;
        }
        // 0x4011aa
        v3 = -32;
        if (v5 == -32) {
            goto lab_0x4011d4;
        } else {
            // 0x4011cf
            _setmode(*(int32_t *)(v5 + 48), g15);
            v3 = *(int32_t *)0x407118;
            if (v3 == -64) {
                goto lab_0x4011f0;
            } else {
                goto lab_0x4011d4;
            }
        }
    }
  lab_0x4011f0:
    // 0x4011f0
    *__p__fmode() = g4;
    function_401550();
    __p__environ();
    int32_t uExitCode = function_4014de(g12); // 0x401222
    _cexit();
    ExitProcess(uExitCode);
    // UNREACHABLE
  lab_0x4011d4:
    // 0x4011d4
    _setmode(*(int32_t *)(v3 + 80), g15);
    goto lab_0x4011f0;
}

// Address range: 0x401260 - 0x401278
int32_t entry_point(void) {
    // 0x401260
    __set_app_type(1);
    function_401140();
    // UNREACHABLE
}

// Address range: 0x401280 - 0x401298
int32_t function_401280(void) {
    // 0x401280
    __set_app_type(2);
    function_401140();
    // UNREACHABLE
}

// Address range: 0x4012a0 - 0x4012ac
int32_t function_4012a0(void) {
    // 0x4012a0
    return atexit((void (*)())&g27);
}

// Address range: 0x4012b0 - 0x4012bc
int32_t function_4012b0(void) {
    // 0x4012b0
    return (int32_t)_onexit((int32_t (*)())&g27);
}

// Address range: 0x4012c0 - 0x4012e2
int32_t function_4012c0(void) {
    // 0x4012c0
    function_402c00();
    return function_4019f0(&g10, (int32_t)&g13);
}

// Address range: 0x4012f0 - 0x401304
int32_t function_4012f0(void) {
    // 0x4012f0
    int32_t v1; // 0x4012f0
    return function_401d50(&g10, v1);
}

// Address range: 0x401310 - 0x401385
int32_t function_401310(int32_t a1) {
    int32_t v1 = 0; // 0x401316
    int32_t str = *(int32_t *)(4 * v1 + a1); // 0x40132a
    while (str != 0) {
        // 0x401330
        v1++;
        if (strncmp((char *)str, "LOLO", 3) == 0) {
            // 0x401361
            g14 = 1;
            return 1;
        }
        str = *(int32_t *)(4 * v1 + a1);
    }
    // 0x401374
    exit(-1);
    // UNREACHABLE
}

// Address range: 0x401385 - 0x4013a3
int32_t function_401385(void) {
    // 0x401385
    printf("Password Incorrect!\n");
    exit(0);
    return &g27;
}

// Address range: 0x4013a3 - 0x40141a
int32_t function_4013a3(int32_t str, int32_t a2) {
    // 0x4013a3
    int32_t v1; // bp-8, 0x4013a3
    sscanf((char *)str, "%d", &v1);
    int32_t result = 0; // 0x4013d7
    if (function_401310(v1) == 0) {
      lab_0x401418_2:
        // 0x401418
        return result;
    }
    int32_t v2 = 0;
    int32_t v3 = 0; // 0x401414
    while (v1 % 2 != 0) {
        uint32_t v4 = v3;
        v3 = v4 + 1;
        v2 = v3;
        if (v4 > 8) {
            // 0x401418
            result = &v2;
            return result;
        }
    }
    // 0x4013f0
    if (g14 == 1) {
        // 0x4013f9
        printf("Password OK!\n");
    }
    // 0x401405
    exit(0);
    // UNREACHABLE
}

// Address range: 0x40141a - 0x401490
int32_t function_40141a(int32_t * str, int32_t a2) {
    int32_t v1 = (int32_t)str;
    int32_t v2 = 0; // 0x40143c
    int32_t v3 = 0; // 0x40143c
    if (strlen((char *)str) == 0) {
        // 0x40148b
        function_401385();
        // UNREACHABLE
    }
    char str2 = *(char *)(v2 + v1); // bp-17, 0x401447
    int32_t v4; // bp-8, 0x40141a
    sscanf(&str2, "%d", &v4);
    v3 += v4;
    if (v3 == 16) {
        // 0x401472
        function_4013a3(v1, a2);
    }
    // 0x401484
    v2++;
    while (v2 < strlen((char *)str)) {
        // 0x40143e
        str2 = *(char *)(v2 + v1);
        sscanf(&str2, "%d", &v4);
        v3 += v4;
        if (v3 == 16) {
            // 0x401472
            function_4013a3(v1, a2);
        }
        // 0x401484
        v2++;
    }
    // 0x40148b
    function_401385();
    // UNREACHABLE
}

// Address range: 0x401490 - 0x4014de
int32_t function_401490(void) {
    // 0x401490
    int32_t v1; // 0x401490
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x401497
    if (function_401310(*v2) == 0) {
        // 0x4014dc
        return 0;
    }
    int32_t result = v1 - 12; // 0x4014a6
    int32_t * v3 = (int32_t *)result; // 0x4014a6
    *v3 = 0;
    int32_t v4 = 0; // 0x4014d8
    while (*v2 % 2 != 0) {
        uint32_t v5 = v4;
        v4 = v5 + 1;
        *v3 = v4;
        if (v5 > 8) {
            // 0x4014dc
            return result;
        }
    }
    // 0x4014bd
    printf("wtf?\n");
    exit(0);
    // UNREACHABLE
}

// Address range: 0x4014de - 0x40154f
int32_t function_4014de(int32_t a1) {
    // 0x4014de
    int32_t v1; // 0x4014de
    function_402e20(v1);
    function_401620();
    printf("IOLI Crackme Level 0x09\n");
    printf("Password: ");
    int32_t v2; // bp-124, 0x4014de
    scanf("%s", &v2);
    function_40141a(&v2, a1);
    return 0;
}

// Address range: 0x401550 - 0x401578
int32_t function_401550(void) {
    // 0x401576
    int32_t result; // 0x401550
    return result;
}

// Address range: 0x401580 - 0x401587
int32_t function_401580(void) {
    // 0x401580
    int32_t result; // 0x401580
    return result;
}

// Address range: 0x401590 - 0x4015b9
int32_t function_401590(void) {
    // 0x401590
    g5 = &g2;
    return &g2;
}

// Address range: 0x4015c0 - 0x401613
int32_t function_4015c0(void) {
    int32_t result = 0; // 0x401605
    result++;
    while (*(int32_t *)(4 * result + (int32_t)&g1) != 0) {
        // 0x401605
        result++;
    }
    // 0x401611
    if (result == 0) {
        // 0x4015ea
        return result;
    }
    int32_t v1 = result; // 0x4015d5
    while (v1 != 1) {
        // 0x4015e0
        v1--;
    }
    // 0x4015ea
    return result;
}

// Address range: 0x401620 - 0x40163d
int32_t function_401620(void) {
    int32_t result = g16; // 0x401621
    if (result != 0) {
        // 0x40162c
        return result;
    }
    // 0x401630
    g16 = 1;
    return function_4015c0();
}

// Address range: 0x401640 - 0x40168d
int32_t function_401640(void) {
    // 0x401640
    int32_t v1; // 0x401640
    uint32_t v2 = v1;
    if ((char)v2 == -1) {
        // 0x401680
        return 0;
    }
    uint32_t v3 = v2 % 8; // 0x40164c
    if (v3 == 2) {
        // 0x401680
        return 2;
    }
    if (v3 <= 2) {
        // 0x401670
        if (v3 == 0) {
            // 0x401680
            return 4;
        }
        // 0x40166a
        abort();
        // UNREACHABLE
    }
    // 0x40165b
    switch (v3) {
        case 3: {
            // 0x401680
            return 4;
        }
        case 4: {
            // 0x401680
            return 8;
        }
    }
    // 0x40166a
    abort();
    // UNREACHABLE
}

// Address range: 0x401690 - 0x4016d7
int32_t function_401690(void) {
    int32_t v1 = 0; // 0x4016a9
    int32_t v2 = 0; // 0x4016a9
    int32_t v3; // 0x401690
    unsigned char v4 = *(char *)v3; // 0x4016b8
    int32_t result = v3 + 1; // 0x4016bb
    v2 |= (int32_t)(v4 % 128) << v1 % 32;
    v1 += 7;
    while (v4 < 0) {
        // 0x4016b0
        v4 = *(char *)result;
        result++;
        v2 |= (int32_t)(v4 % 128) << v1 % 32;
        v1 += 7;
    }
    // 0x4016cc
    int32_t v5; // 0x401690
    *(int32_t *)v5 = v2;
    return result;
}

// Address range: 0x4016e0 - 0x401750
int32_t function_4016e0(void) {
    int32_t v1 = 0; // 0x4016f9
    uint32_t v2 = 0;
    uint32_t v3 = v2 + 7; // 0x401705
    int32_t v4; // 0x4016e0
    unsigned char v5 = *(char *)v4; // 0x401708
    uint32_t v6 = (int32_t)v5; // 0x401708
    int32_t result = v4 + 1; // 0x40170b
    v1 |= v6 % 128 << v2 % 32;
    while (v5 < 0) {
        // 0x401700
        v2 = v3;
        v3 = v2 + 7;
        v5 = *(char *)result;
        v6 = (int32_t)v5;
        result++;
        v1 |= v6 % 128 << v2 % 32;
    }
    int32_t v7 = v1; // 0x401722
    if (v3 <= 31 && (v6 & 64) != 0) {
        // 0x401729
        v7 = v1 | -1 << v3 % 32;
    }
    // 0x401740
    int32_t v8; // 0x4016e0
    *(int32_t *)v8 = v7;
    return result;
}

// Address range: 0x401750 - 0x401819
int32_t function_401750(int32_t a1, int32_t * a2) {
    // 0x401750
    int32_t v1; // 0x401750
    char v2 = v1; // 0x40175c
    if (v2 == 80) {
        int32_t v3 = a1 + 3 & -4; // 0x4017b3
        *a2 = *(int32_t *)v3;
        return v3 + 4;
    }
    int32_t v4 = v1 % 16; // 0x40176e
    g26 = v4;
    int32_t result; // 0x401750
    int32_t v5; // 0x401750
    switch (v4) {
        case 0: {
        }
        case 3: {
        }
        case 11: {
            // 0x401780
            result = a1 + 4;
            v5 = *(int32_t *)a1;
            // break -> 0x401785
            break;
        }
        case 1: {
            // 0x4017e4
            result = function_401690();
            // break -> 0x401785
            break;
        }
        case 2: {
            // 0x4017f5
            result = a1 + 2;
            v5 = (int32_t)*(int16_t *)a1;
            // break -> 0x401785
            break;
        }
        case 4: {
        }
        case 12: {
            // 0x4017d0
            result = a1 + 8;
            v5 = *(int32_t *)a1;
            // break -> 0x401785
            break;
        }
        case 9: {
            // 0x4017fd
            result = function_4016e0();
            // break -> 0x401785
            break;
        }
        case 10: {
            // 0x4017dc
            result = a1 + 2;
            v5 = (int32_t)*(int16_t *)a1;
            // break -> 0x401785
            break;
        }
        default: {
            // 0x4017d7
            abort();
            // UNREACHABLE
        }
    }
    // 0x401785
    if (v5 == 0) {
        // 0x401799
        *a2 = 0;
        return result;
    }
    int32_t v6 = v5 + ((v1 & 112) == 16 ? a1 : v1);
    int32_t v7 = v6; // 0x401797
    if (v2 < 0) {
        // 0x401815
        v7 = *(int32_t *)v6;
    }
    // 0x401799
    *a2 = v7;
    return result;
}

// Address range: 0x401820 - 0x401862
int32_t function_401820(void) {
    // 0x401820
    *(int32_t *)(g24 + 20) = -1;
    int32_t result = (int32_t)CreateSemaphoreA(NULL, 0, 0xffff, NULL); // 0x401852
    *(int32_t *)(g24 + 24) = result;
    return result;
}

// Address range: 0x401870 - 0x4018f5
int32_t function_401870(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = g24 + 28; // 0x401889
    if (g22 == 0 || v1 == 0) {
        // 0x4018a0
        return g22;
    }
    int32_t * v2 = (int32_t *)v1; // 0x401892
    int32_t result = *v2; // 0x401892
    if (result != 0) {
        // 0x4018a0
        return result;
    }
    int32_t result3 = InterlockedIncrement((int32_t *)(g24 + 32)); // 0x4018b0
    if (result3 == 0) {
        int32_t result2 = function_401820(); // 0x4018e7
        *v2 = 1;
        // 0x4018a0
        return result2;
    }
    // 0x4018bc
    if (*v2 != 0) {
        // 0x4018a0
        return result3;
    }
    // 0x4018d0
    int32_t v3; // bp-32, 0x401870
    int32_t v4 = &v3; // 0x401870
    *(int32_t *)v4 = 0;
    Sleep((int32_t)&g27);
    int32_t result4 = *v2; // 0x4018dc
    v4 -= 4;
    while (result4 == 0) {
        // 0x4018d0
        *(int32_t *)v4 = 0;
        Sleep((int32_t)&g27);
        result4 = *v2;
        v4 -= 4;
    }
    // 0x4018a0
    return result4;
}

// Address range: 0x401900 - 0x4019ed
int32_t function_401900(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x401900
    int32_t result; // 0x401900
    if (a1 == 0 || *(int32_t *)a1 == 0) {
        // 0x40191c
        return result;
    }
    // 0x401926
    *(int32_t *)a2 = -1;
    *(int32_t *)(a2 + 4) = a3;
    int32_t v1 = a2 + 16; // 0x401935
    *(int32_t *)v1 = 0;
    *(int32_t *)(a2 + 12) = a1;
    *(int32_t *)(a2 + 8) = a4;
    int16_t * v2 = (int16_t *)v1; // 0x401942
    *v2 = *v2 | 2040;
    int32_t v3; // 0x401900
    function_401870(v3, v3, v3);
    int32_t v4 = g24; // 0x401965
    int32_t v5; // bp-28, 0x401900
    int32_t * v6 = &v5; // 0x401965
    if (g22 != 0) {
        int32_t v7 = g24 + 20; // 0x401962
        v5 = v7;
        int32_t * lpAddend = (int32_t *)v7; // 0x4019ab
        int32_t v8 = InterlockedIncrement(lpAddend); // 0x4019ab
        int32_t v9; // bp-32, 0x401900
        v6 = &v9;
        if (v8 != 0) {
            // 0x4019c5
            v5 = -1;
            int32_t hHandle = *(int32_t *)(g24 + 24); // 0x4019ce
            v9 = hHandle;
            int32_t v10 = WaitForSingleObject((int32_t *)hHandle, -1); // 0x4019d4
            int32_t v11; // bp-40, 0x401900
            v6 = &v11;
            if (v10 != 0) {
                // 0x4019e0
                v11 = v7;
                InterlockedDecrement(lpAddend);
                int32_t v12; // bp-44, 0x401900
                v6 = &v12;
            }
        }
        // 0x4019b7
        v4 = g24;
    }
    int32_t * v13 = (int32_t *)(v4 + 12); // 0x401967
    int32_t result2 = *v13; // 0x401967
    *(int32_t *)(a2 + 20) = result2;
    *v13 = a2;
    if (g22 == 0) {
        // 0x40191c
        return result2;
    }
    // 0x401977
    *v6 = v4 + 20;
    int32_t v14 = InterlockedDecrement(&g27); // 0x40197a
    result = v14;
    if (v14 >= 0) {
        int32_t v15 = (int32_t)v6;
        *(int32_t *)(v15 + 4) = 0;
        *v6 = 1;
        *(int32_t *)(v15 - 4) = *(int32_t *)(v4 + 24);
        result = ReleaseSemaphore(&g27, (int32_t)&g27, &g27);
    }
    // 0x40191c
    return result;
}

// Address range: 0x4019f0 - 0x401a16
int32_t function_4019f0(int32_t * a1, int32_t a2) {
    // 0x4019f0
    return function_401900((int32_t)a1, a2, 0, 0);
}

// Address range: 0x401a20 - 0x401a54
int32_t function_401a20(int32_t a1) {
    int32_t * v1 = (int32_t *)a1; // 0x401a2a
    int32_t result = *v1; // 0x401a2a
    if (result == 0) {
        // 0x401a30
        return result;
    }
    // 0x401a36
    return function_4019f0(v1, (int32_t)malloc(24));
}

// Address range: 0x401a60 - 0x401b5b
int32_t function_401a60(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x401a60
    *(int32_t *)a2 = -1;
    *(int32_t *)(a2 + 4) = a3;
    *(int32_t *)(a2 + 8) = a4;
    int32_t v1 = a2 + 16; // 0x401a80
    *(int32_t *)v1 = 0;
    char * v2 = (char *)v1; // 0x401a87
    *v2 = *v2 | 2;
    *(int32_t *)(a2 + 12) = a1;
    int16_t * v3 = (int16_t *)v1; // 0x401a8e
    *v3 = *v3 | 2040;
    int32_t v4; // 0x401a60
    function_401870(v4, v4, v4);
    if (g22 == 0) {
        int32_t * v5 = (int32_t *)(g24 + 12); // 0x401ab3
        int32_t result = *v5; // 0x401ab3
        *(int32_t *)(a2 + 20) = result;
        *v5 = a2;
        // 0x401ac3
        return result;
    }
    int32_t v6 = g24 + 20; // 0x401aae
    int32_t * lpAddend = (int32_t *)v6; // 0x401ad3
    int32_t v7 = InterlockedIncrement(lpAddend); // 0x401ad3
    int32_t v8; // bp-32, 0x401a60
    int32_t * v9 = &v8; // 0x401add
    if (v7 != 0) {
        int32_t hHandle = *(int32_t *)(g24 + 24); // 0x401b3c
        v8 = hHandle;
        int32_t v10 = WaitForSingleObject((int32_t *)hHandle, -1); // 0x401b42
        int32_t v11; // bp-40, 0x401a60
        v9 = &v11;
        if (v10 != 0) {
            // 0x401b4e
            v11 = v6;
            InterlockedDecrement(lpAddend);
            int32_t v12; // bp-44, 0x401a60
            v9 = &v12;
        }
    }
    int32_t * v13 = (int32_t *)(g24 + 12); // 0x401aeb
    int32_t result2 = *v13; // 0x401aeb
    *(int32_t *)(a2 + 20) = result2;
    *v13 = a2;
    if (g22 == 0) {
        // 0x401ac3
        return result2;
    }
    // 0x401b00
    *v9 = g24 + 20;
    int32_t result3 = InterlockedDecrement(&g27); // 0x401b03
    if (result3 < 0) {
        // 0x401ac3
        return result3;
    }
    int32_t v14 = (int32_t)v9;
    *(int32_t *)(v14 + 4) = 0;
    *v9 = 1;
    *(int32_t *)(v14 - 4) = *(int32_t *)(g24 + 24);
    return ReleaseSemaphore(&g27, (int32_t)&g27, &g27);
}

// Address range: 0x401b60 - 0x401b86
int32_t function_401b60(int32_t a1, int32_t a2) {
    // 0x401b60
    return function_401a60(a1, a2, 0, 0);
}

// Address range: 0x401b90 - 0x401bb3
int32_t function_401b90(int32_t a1) {
    // 0x401b90
    return function_401b60(a1, (int32_t)malloc(24));
}

// Address range: 0x401bc0 - 0x401d43
int32_t function_401bc0(int32_t a1) {
    // 0x401bc0
    if (a1 == 0 || *(int32_t *)a1 == 0) {
        // 0x401bd6
        return 0;
    }
    // 0x401be0
    int32_t v1; // 0x401bc0
    function_401870(v1, v1, v1);
    int32_t v2; // bp-28, 0x401bc0
    int32_t * v3 = &v2; // 0x401bf5
    if (g22 != 0) {
        int32_t v4 = g24 + 20; // 0x401bf2
        v2 = v4;
        int32_t * lpAddend = (int32_t *)v4; // 0x401c66
        int32_t v5 = InterlockedIncrement(lpAddend); // 0x401c66
        int32_t v6; // bp-32, 0x401bc0
        v3 = &v6;
        if (v5 != 0) {
            // 0x401d14
            v2 = -1;
            int32_t hHandle = *(int32_t *)(g24 + 24); // 0x401d1d
            v6 = hHandle;
            int32_t v7 = WaitForSingleObject((int32_t *)hHandle, -1); // 0x401d23
            int32_t v8; // bp-40, 0x401bc0
            v3 = &v8;
            if (v7 != 0) {
                // 0x401d33
                v8 = v4;
                InterlockedDecrement(lpAddend);
                int32_t v9; // bp-44, 0x401bc0
                v3 = &v9;
            }
        }
    }
    int32_t v10 = (int32_t)v3;
    int32_t v11 = *(int32_t *)(g24 + 12); // 0x401bf7
    int32_t v12; // 0x401bc0
    int32_t v13; // 0x401bc0
    if (v11 == 0) {
        goto lab_0x401c15;
    } else {
        // 0x401c00
        if (*(int32_t *)(v11 + 12) == a1) {
            goto lab_0x401c48_2;
        } else {
            int32_t v14 = v11 + 20; // 0x401c0b
            int32_t v15 = *(int32_t *)v14; // 0x401c0b
            while (v15 != 0) {
                // 0x401c00
                v12 = v14;
                v13 = v15;
                if (*(int32_t *)(v15 + 12) == a1) {
                    goto lab_0x401c48_2;
                }
                v14 = v15 + 20;
                v15 = *(int32_t *)v14;
            }
            goto lab_0x401c15;
        }
    }
  lab_0x401c48_2:
    // 0x401c48
    *(int32_t *)v12 = *(int32_t *)(v13 + 20);
    int32_t result = v13; // 0x401c4b
    int32_t v16 = g24; // 0x401c4b
    goto lab_0x401c4d;
  lab_0x401c15:;
    int32_t v17 = g24 + 16; // 0x401c15
    int32_t * v18 = (int32_t *)v17;
    int32_t v19 = *v18;
    int32_t v20 = v19; // 0x401c33
    int32_t * v21 = v18; // 0x401c33
    int32_t v22 = v17; // 0x401c33
    if (v19 == 0) {
      lab_0x401cd2:
        // 0x401cd2
        if (g22 == 0) {
            // 0x401cde
            abort();
            // UNREACHABLE
        }
        // 0x401ce3
        *v3 = g24 + 20;
        if (InterlockedDecrement(&g27) < 0) {
            // 0x401cde
            abort();
            // UNREACHABLE
        }
        // 0x401cf2
        *(int32_t *)(v10 + 4) = 0;
        *v3 = 1;
        *(int32_t *)(v10 - 4) = *(int32_t *)(g24 + 24);
        ReleaseSemaphore(&g27, (int32_t)&g27, &g27);
        abort();
        // UNREACHABLE
    }
    int32_t * v23; // 0x401bc0
    int32_t v24; // 0x401bc0
    while (true) {
        // 0x401c39
        v24 = v20;
        v23 = (int32_t *)(v24 + 12);
        int32_t v25 = *v23;
        if (*(char *)(v24 + 16) % 2 != 0) {
            // 0x401c20
            if (*(int32_t *)v25 == a1) {
                // break -> 0x401cb1
                break;
            }
        } else {
            // 0x401c41
            v12 = v22;
            v13 = v24;
            if (v25 == a1) {
                goto lab_0x401c48_2;
            }
        }
        int32_t v26 = v24 + 20; // 0x401c2b
        int32_t * v27 = (int32_t *)v26;
        int32_t v28 = *v27;
        v20 = v28;
        v21 = v27;
        v22 = v26;
        if (v28 == 0) {
            goto lab_0x401cd2;
        }
    }
    // 0x401cb1
    *v21 = *(int32_t *)(v24 + 20);
    *v3 = *v23;
    free(&g27);
    result = v24;
    v16 = g24;
    goto lab_0x401c4d;
  lab_0x401c4d:
    // 0x401c4d
    if (g22 == 0) {
        // 0x401bd6
        return result;
    }
    // 0x401c81
    *v3 = v16 + 20;
    if (InterlockedDecrement(&g27) >= 0) {
        // 0x401c90
        *(int32_t *)(v10 + 4) = 0;
        *v3 = 1;
        *(int32_t *)(v10 - 4) = *(int32_t *)(v16 + 24);
        ReleaseSemaphore(&g27, (int32_t)&g27, &g27);
    }
    // 0x401bd6
    return result;
}

// Address range: 0x401d50 - 0x401d59
int32_t function_401d50(int32_t * a1, int32_t a2) {
    // 0x401d50
    return function_401bc0((int32_t)&g27);
}

// Address range: 0x401d60 - 0x401d82
int32_t function_401d60(int32_t result) {
    int32_t * v1 = (int32_t *)result; // 0x401d69
    if (*v1 == 0) {
        // 0x401d6f
        return result;
    }
    // 0x401d71
    int32_t v2; // 0x401d60
    free((int32_t *)function_401d50(v1, v2));
    return &g27;
}

// Address range: 0x401d90 - 0x401de6
int32_t function_401d90(void) {
    // 0x401d90
    int32_t v1; // 0x401d90
    if ((char)v1 == -1) {
        // 0x401dd0
        return 0;
    }
    uint32_t v2 = v1 & 112; // 0x401d9c
    if (v2 == 32) {
        // 0x401dd4
        return *(int32_t *)(v1 + 4);
    }
    int32_t result; // 0x401d90
    if (v2 > 32) {
        // 0x401db0
        result = 0;
        switch (v2) {
            case 48: {
                // 0x401dbf
                result = *(int32_t *)(v1 + 8);
                // 0x401dd0
                return result;
            }
            case 80: {
                return result;
            }
            default: {
                // 0x401dba
                abort();
                // UNREACHABLE
            }
        }
    } else {
        // 0x401da6
        result = 0;
        switch (v2) {
            case 0: {
                return result;
            }
            case 16: {
                return result;
            }
            default: {
                // 0x401dba
                abort();
                // UNREACHABLE
            }
        }
    }
}

// Address range: 0x401df0 - 0x401e7b
int32_t function_401df0(void) {
    // 0x401df0
    int32_t v1; // 0x401df0
    char * str = (char *)(v1 + 9); // 0x401dff
    if (*str != 122) {
        // 0x401e05
        return 0;
    }
    // 0x401e0c
    strlen(str);
    function_401690();
    function_4016e0();
    int32_t v2 = function_401690(); // 0x401e3c
    int32_t v3 = v1 + 10; // 0x401e3c
    int32_t v4; // 0x401df0
    while (true) {
        // 0x401e40
        v4 = v2;
        char v5 = *(char *)v3; // 0x401e40
        switch (v5) {
            case 82: {
                // 0x401e05
                return (int32_t)*(char *)v4;
            }
            case 80: {
                // 0x401e53
                int32_t v6; // bp-24, 0x401df0
                v2 = function_401750(v4 + 1, &v6);
                // break -> 0x401e40
                break;
            }
            default: {
                // 0x401e4b
                if (v5 != 76) {
                    // 0x401e05
                    return 0;
                }
                // 0x401e4f
                v2 = v4 + 1;
                // break -> 0x401e40
                break;
            }
        }
        // 0x401e40
        v3++;
    }
    // 0x401e05
    return (int32_t)*(char *)v4;
}

// Address range: 0x401e80 - 0x401e9c
int32_t function_401e80(int32_t a1, int32_t a2) {
    uint32_t v1 = *(int32_t *)(a2 + 8); // 0x401e8b
    uint32_t v2 = *(int32_t *)(a1 + 8); // 0x401e91
    return v2 > v1 ? 1 : (int32_t)(v2 < v1);
}

// Address range: 0x401ea0 - 0x401f18
int32_t function_401ea0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401ea0
    function_401d90();
    int32_t v1; // bp-16, 0x401ea0
    function_401750(a2 + 8, &v1);
    int32_t v2; // bp-20, 0x401ea0
    function_401750(a3 + 8, &v2);
    uint32_t v3 = v2; // 0x401f00
    uint32_t v4 = v1; // 0x401f08
    return v4 > v3 ? 1 : (int32_t)(v4 < v3);
}

// Address range: 0x401f20 - 0x401fae
int32_t function_401f20(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401f20
    function_401df0();
    function_401d90();
    int32_t v1; // bp-20, 0x401f20
    function_401750(a2 + 8, &v1);
    function_401df0();
    function_401d90();
    int32_t v2; // bp-24, 0x401f20
    function_401750(a3 + 8, &v2);
    uint32_t v3 = v2; // 0x401f95
    uint32_t v4 = v1; // 0x401f9d
    return v4 > v3 ? 1 : (int32_t)(v4 < v3);
}

// Address range: 0x401fb0 - 0x402039
int32_t function_401fb0(int32_t a1, int32_t a2, uint32_t a3) {
    int32_t v1 = 2 * a2 | 1; // 0x401fc5
    int32_t result; // 0x401fb0
    if (v1 >= a3) {
        // 0x402010
        return result;
    }
    int32_t v2 = v1; // 0x402007
    int32_t v3 = a2;
    int32_t v4; // 0x401fb0
    while (v4 < 0) {
        int32_t v5 = v3;
        int32_t v6 = v2 + 1; // 0x401fd0
        v3 = v4 >= 0 | v6 >= a3 ? v2 : v6;
        int32_t * v7 = (int32_t *)(4 * v5 + a1); // 0x401ff9
        int32_t * v8 = (int32_t *)(4 * v3 + a1); // 0x401ffc
        int32_t v9 = *v8; // 0x401ffc
        *v7 = v9;
        *v8 = *v7;
        v2 = 2 * v3 | 1;
        result = v9;
        if (v2 >= a3) {
            // break -> 0x402010
            break;
        }
    }
    // 0x402010
    return result;
}

// Address range: 0x402040 - 0x4020af
int32_t function_402040(int32_t a1) {
    uint32_t v1 = *(int32_t *)(a1 + 4); // 0x402052
    int32_t v2 = a1 + 8; // 0x402055
    int32_t v3 = v1 / 2; // 0x40205a
    int32_t result = v3; // 0x402077
    if (v1 >= 2) {
        int32_t v4 = v3 - 1; // 0x402076
        int32_t v5 = function_401fb0(v2, v4, v1); // 0x402071
        v4--;
        result = v5;
        while (v4 >= 0) {
            // 0x402060
            v5 = function_401fb0(v2, v4, v1);
            v4--;
            result = v5;
        }
    }
    int32_t v6 = v1 - 1;
    if (v6 >= 0 != v6 != 0) {
        // 0x4020a7
        return result;
    }
    int32_t * v7 = (int32_t *)v2; // 0x402085
    int32_t v8 = v6;
    int32_t * v9 = (int32_t *)(4 * v8 + v2); // 0x402080
    *v7 = *v9;
    *v9 = *v7;
    int32_t result2 = function_401fb0(v2, 0, v8); // 0x40209e
    v8--;
    while (v8 >= 0 == (v8 != 0)) {
        // 0x402080
        v9 = (int32_t *)(4 * v8 + v2);
        *v7 = *v9;
        *v9 = *v7;
        result2 = function_401fb0(v2, 0, v8);
        v8--;
    }
    // 0x4020a7
    return result2;
}

// Address range: 0x4020b0 - 0x4021c4
int32_t function_4020b0(void) {
    // 0x4020b0
    int32_t v1; // 0x4020b0
    if (v1 == 0) {
        // 0x4021a0
        return 0;
    }
    int32_t v2 = v1 + 16;
    int16_t * v3 = (int16_t *)v2;
    char * v4 = (char *)v2;
    int32_t v5 = 0;
    int32_t v6 = 0;
    int32_t v7; // 0x4020b0
    int32_t v8 = v7 + 4;
    int32_t v9 = *(int32_t *)v8; // 0x4020f2
    int32_t v10 = v5; // 0x4020f7
    int32_t v11 = v6; // 0x4020f7
    int32_t v12; // bp-20, 0x4020b0
    int32_t v13; // 0x4020b0
    int32_t v14; // 0x4020b0
    int32_t v15; // 0x4020b0
    uint32_t v16; // 0x4020b0
    int32_t v17; // 0x4020ff
    uint32_t v18; // 0x40215d
    int32_t v19; // 0x40210a
    uint32_t v20; // 0x40211d
    uint32_t v21; // 0x402129
    int32_t v22; // 0x402181
    if (v9 != 0) {
        // 0x4020f9
        v17 = v7 - v9 + 4;
        v13 = v5;
        if (v17 != v5) {
            // 0x402107
            v19 = function_401df0();
            function_401d90();
            v20 = (int32_t)*v3;
            v21 = v20 / 8 % 256;
            if (v21 == 255) {
                // 0x4021ab
                *v3 = (int16_t)(v20 & 0xf807 | 8 * v19 & 2040);
                v13 = v17;
            } else {
                // 0x402135
                v13 = v17;
                if (v21 != v19) {
                    // 0x40213a
                    *v4 = *v4 | 4;
                    v13 = v17;
                }
            }
        }
        // 0x402140
        v14 = v13;
        function_401750(v7 + 8, &v12);
        v18 = function_401640();
        v15 = -1;
        if (v18 < 4) {
            // 0x402167
            v15 = -1 - (-1 << (8 * v18 & 24));
        }
        // 0x402176
        v16 = v15;
        v10 = v14;
        v11 = v6;
        if ((v12 & v16) != 0) {
            // 0x402181
            v22 = v6 + 1;
            v10 = v14;
            v11 = v22;
            if (v16 > v12) {
                // 0x40218c
                *(int32_t *)v1 = v12;
                v10 = v14;
                v11 = v22;
            }
        }
    }
    int32_t result = v11;
    int32_t v23 = *(int32_t *)v7 + v8; // 0x4020e4
    while (*(int32_t *)v23 != 0) {
        // 0x4020f2
        v5 = v10;
        v6 = result;
        int32_t v24 = v23;
        v8 = v24 + 4;
        v9 = *(int32_t *)v8;
        v10 = v5;
        v11 = v6;
        if (v9 != 0) {
            // 0x4020f9
            v17 = v24 - v9 + 4;
            v13 = v5;
            if (v17 != v5) {
                // 0x402107
                v19 = function_401df0();
                function_401d90();
                v20 = (int32_t)*v3;
                v21 = v20 / 8 % 256;
                if (v21 == 255) {
                    // 0x4021ab
                    *v3 = (int16_t)(v20 & 0xf807 | 8 * v19 & 2040);
                    v13 = v17;
                } else {
                    // 0x402135
                    v13 = v17;
                    if (v21 != v19) {
                        // 0x40213a
                        *v4 = *v4 | 4;
                        v13 = v17;
                    }
                }
            }
            // 0x402140
            v14 = v13;
            function_401750(v24 + 8, &v12);
            v18 = function_401640();
            v15 = -1;
            if (v18 < 4) {
                // 0x402167
                v15 = -1 - (-1 << (8 * v18 & 24));
            }
            // 0x402176
            v16 = v15;
            v10 = v14;
            v11 = v6;
            if ((v12 & v16) != 0) {
                // 0x402181
                v22 = v6 + 1;
                v10 = v14;
                v11 = v22;
                if (v16 > v12) {
                    // 0x40218c
                    *(int32_t *)v1 = v12;
                    v10 = v14;
                    v11 = v22;
                }
            }
        }
        // 0x4020e0
        result = v11;
        v23 = *(int32_t *)v24 + v8;
    }
    // 0x4021a0
    return result;
}

// Address range: 0x4021d0 - 0x4022c6
int32_t function_4021d0(int32_t a1) {
    // 0x4021d0
    int32_t v1; // 0x4021d0
    int32_t v2 = v1 + 16; // 0x4021df
    int32_t result = function_401d90(); // 0x4021fb
    if (*(int32_t *)a1 == 0) {
        // 0x402271
        return result;
    }
    int32_t v3 = 0;
    int32_t v4 = (int32_t)(*(int16_t *)v2 / 8 % 256);
    int32_t v5 = a1 + 4;
    int32_t v6 = *(int32_t *)v5; // 0x402216
    int32_t v7 = v3; // 0x40221b
    int32_t v8 = result; // 0x40221b
    int32_t v9 = v4; // 0x40221b
    int32_t v10; // 0x4021d0
    int32_t v11; // 0x4021d0
    int32_t v12; // 0x4021d0
    int32_t v13; // 0x4021d0
    int32_t v14; // 0x4021d0
    int32_t v15; // bp-20, 0x4021d0
    int32_t v16; // 0x4021d0
    int32_t v17; // 0x4021d0
    int32_t v18; // 0x4021d0
    int32_t v19; // 0x4021d0
    int32_t v20; // 0x4021d0
    int32_t v21; // 0x402228
    int32_t v22; // 0x40222c
    uint32_t v23; // 0x40229e
    int32_t v24; // 0x402237
    int32_t * v25; // 0x402264
    int32_t v26; // 0x402264
    int32_t v27; // 0x4021d0
    if (v6 != 0) {
        // 0x40221d
        v16 = v3;
        v18 = result;
        v10 = v4;
        if ((*(char *)v2 & 4) != 0) {
            // 0x402226
            v21 = a1 - v6;
            v22 = v21 + 4;
            v16 = v3;
            v18 = result;
            v12 = v21;
            v10 = v4;
            if (v22 != v3) {
                // 0x402234
                v24 = function_401df0();
                v16 = v22;
                v18 = function_401d90();
                v10 = v24;
            }
        }
        // 0x402250
        v11 = v10;
        v19 = v18;
        v17 = v16;
        v20 = a1 + 8;
        if (v11 != 0) {
            // 0x402280
            function_401750(v20, &v15);
            v23 = function_401640();
            if (v23 < 4) {
                // 0x4022a8
                v27 = v15 & -1 - (-1 << (8 * v23 & 24));
                v13 = v19;
            } else {
                // 0x4022bc
                v27 = v15;
                v13 = v19;
            }
        } else {
            // 0x402254
            v27 = *(int32_t *)v20;
            v13 = v12;
        }
        // 0x402259
        v14 = v13;
        v7 = v17;
        v8 = v19;
        v9 = v11;
        if (v27 != 0 && v14 != 0) {
            // 0x402264
            v25 = (int32_t *)(v14 + 4);
            v26 = *v25;
            *(int32_t *)(v14 + 8 + 4 * v26) = a1;
            *v25 = v26 + 1;
            v7 = v17;
            v8 = v19;
            v9 = v11;
        }
    }
    int32_t v28 = *(int32_t *)a1 + v5; // 0x40220c
    while (*(int32_t *)v28 != 0) {
        // 0x402216
        v3 = v7;
        int32_t v29 = v8;
        int32_t v30 = v28;
        v4 = v9;
        v5 = v30 + 4;
        v6 = *(int32_t *)v5;
        v7 = v3;
        v8 = v29;
        v9 = v4;
        if (v6 != 0) {
            // 0x40221d
            v16 = v3;
            v18 = v29;
            v10 = v4;
            if ((*(char *)v2 & 4) != 0) {
                // 0x402226
                v21 = v30 - v6;
                v22 = v21 + 4;
                v16 = v3;
                v18 = v29;
                v12 = v21;
                v10 = v4;
                if (v22 != v3) {
                    // 0x402234
                    v24 = function_401df0();
                    v16 = v22;
                    v18 = function_401d90();
                    v10 = v24;
                }
            }
            // 0x402250
            v11 = v10;
            v19 = v18;
            v17 = v16;
            v20 = v30 + 8;
            if (v11 != 0) {
                // 0x402280
                function_401750(v20, &v15);
                v23 = function_401640();
                if (v23 < 4) {
                    // 0x4022a8
                    v27 = v15 & -1 - (-1 << (8 * v23 & 24));
                    v13 = v19;
                } else {
                    // 0x4022bc
                    v27 = v15;
                    v13 = v19;
                }
            } else {
                // 0x402254
                v27 = *(int32_t *)v20;
                v13 = v12;
            }
            // 0x402259
            v14 = v13;
            v7 = v17;
            v8 = v19;
            v9 = v11;
            if (v27 != 0 && v14 != 0) {
                // 0x402264
                v25 = (int32_t *)(v14 + 4);
                v26 = *v25;
                *(int32_t *)(v14 + 8 + 4 * v26) = v30;
                *v25 = v26 + 1;
                v7 = v17;
                v8 = v19;
                v9 = v11;
            }
        }
        // 0x402208
        v28 = *(int32_t *)v30 + v5;
    }
    // 0x402271
    return 0;
}

// Address range: 0x4022d0 - 0x4023e1
int32_t function_4022d0(int32_t a1) {
    // 0x4022d0
    int32_t v1; // 0x4022d0
    int32_t v2 = v1 + 16; // 0x4022de
    function_401d90();
    if (v1 == 0) {
        // 0x4023d2
        return 0;
    }
    int32_t v3 = (int32_t)(*(int16_t *)v2 / 8 % 256); // 0x4022d0
    int32_t v4 = 0; // 0x4022d0
    int32_t v5; // 0x4022d0
    int32_t v6; // 0x4022d0
    int32_t v7; // 0x4022d0
    int32_t v8; // 0x4022d0
    int32_t v9; // 0x4022d0
    int32_t v10; // 0x4023cb
    int32_t v11; // 0x4022d0
    while (true) {
      lab_0x402316:;
        int32_t v12 = v4;
        v8 = v7;
        int32_t v13 = v3;
        v11 = v8 + 4;
        int32_t v14 = *(int32_t *)v11; // 0x402316
        v4 = v12;
        v3 = v13;
        if (v14 == 0) {
            goto lab_0x402304;
        } else {
            int32_t v15 = v12; // 0x402324
            int32_t v16 = v13; // 0x402324
            if ((*(char *)v2 & 4) != 0) {
                int32_t v17 = v8 - v14 + 4; // 0x40232c
                v15 = v12;
                v16 = v13;
                if (v17 != v12) {
                    int32_t v18 = function_401df0(); // 0x402337
                    function_401d90();
                    v15 = v17;
                    v16 = v18;
                }
            }
            // 0x402350
            v5 = v16;
            v9 = v15;
            int32_t v19 = v8 + 8;
            int32_t v20; // bp-20, 0x4022d0
            int32_t v21; // bp-24, 0x4022d0
            if (v5 != 0) {
                int32_t v22 = function_401750(v19, &v20); // 0x402388
                function_401750(v22, &v21);
                uint32_t v23 = function_401640(); // 0x4023a7
                int32_t v24 = -1; // 0x4023af
                if (v23 < 4) {
                    // 0x4023b1
                    v24 = -1 - (-1 << (8 * v23 & 24));
                }
                int32_t v25 = v20; // 0x4023c0
                v4 = v9;
                v3 = v5;
                if ((v25 & v24) == 0) {
                    goto lab_0x402304;
                } else {
                    // 0x4023cb
                    v10 = v21;
                    v6 = v25;
                    goto lab_0x402364;
                }
            } else {
                int32_t v26 = *(int32_t *)v19; // 0x402354
                v20 = v26;
                int32_t v27 = *(int32_t *)(v8 + 12); // 0x40235c
                v21 = v27;
                v4 = v9;
                v3 = v5;
                v10 = v27;
                v6 = v26;
                if (v26 == 0) {
                    goto lab_0x402304;
                } else {
                    goto lab_0x402364;
                }
            }
        }
    }
  lab_0x4023d2_2:;
    // 0x4023d2
    int32_t result; // 0x4022d0
    return result;
  lab_0x402304:;
    int32_t v28 = *(int32_t *)v8 + v11; // 0x402308
    v7 = v28;
    result = 0;
    if (*(int32_t *)v28 == 0) {
        // break -> 0x4023d2
        goto lab_0x4023d2_2;
    }
    goto lab_0x402316;
  lab_0x402364:
    // 0x402364
    v4 = v9;
    v3 = v5;
    result = v8;
    if (a1 - v6 < v10) {
        // break -> 0x4023d2
        goto lab_0x4023d2_2;
    }
    goto lab_0x402304;
}

// Address range: 0x4023e1 - 0x4023e3
int32_t function_4023e1(void) {
    // 0x4023e1
    return function_4023f0();
}

// Address range: 0x4023f0 - 0x40296d
int32_t function_4023f0(void) {
    // 0x4023f0
    int32_t v1; // 0x4023f0
    uint32_t v2 = v1;
    int32_t v3 = v1 + 16; // 0x4023fc
    char * v4 = (char *)v3; // 0x4023fc
    unsigned char v5 = *v4; // 0x4023fc
    int32_t v6 = v5; // 0x4023fc
    int32_t v7 = v6; // 0x402406
    int32_t v8; // 0x4023f0
    int32_t v9; // 0x4023f0
    int32_t * v10; // 0x40240a
    if (v5 % 2 != 0) {
        goto lab_0x402438;
    } else {
        // 0x402408
        v10 = (int32_t *)v3;
        uint32_t v11 = *v10; // 0x40240a
        v9 = v11 / 2048;
        if (v11 < 2048) {
            if ((v6 & 2) == 0) {
                // 0x402717
                v8 = function_4020b0();
                goto lab_0x402556;
            } else {
                int32_t v12 = *(int32_t *)(v1 + 12); // 0x402529
                if (*(int32_t *)v12 == 0) {
                    // 0x402424
                    v7 = (int32_t)*v4;
                    goto lab_0x402438;
                } else {
                    int32_t v13 = v12 + 4; // 0x402542
                    int32_t v14 = function_4020b0(); // 0x40254d
                    int32_t v15 = v14; // 0x402554
                    int32_t v16 = v13; // 0x402554
                    v8 = v14;
                    while (*(int32_t *)v13 != 0) {
                        // 0x402540
                        v13 = v16 + 4;
                        v14 = function_4020b0() + v15;
                        v15 = v14;
                        v16 = v13;
                        v8 = v14;
                    }
                    goto lab_0x402556;
                }
            }
        } else {
            goto lab_0x40258c;
        }
    }
  lab_0x402660:;
    // 0x402660
    int32_t v17; // 0x4023f0
    int32_t v18; // 0x4023f0
    int32_t v19; // 0x4023f0
    *(int32_t *)(v17 + v19) = v18;
    int32_t v20; // 0x4023f0
    int32_t v21 = v20 + 1; // 0x402667
    int32_t v22 = v21; // 0x402671
    int32_t v23; // 0x4023f0
    int32_t v24 = v23 + 8; // 0x402671
    int32_t v25 = v23 + 4; // 0x402671
    int32_t v26 = 0; // 0x402671
    int32_t v27 = 0; // 0x402671
    int32_t v28 = 0; // 0x402671
    if (v21 >= v9) {
        // break -> 0x402840
        goto lab_0x402840;
    }
    goto lab_0x402677;
  lab_0x402677:;
    int32_t v29 = v22; // 0x402677
    int32_t v30 = v24; // 0x402677
    int32_t v31 = v25; // 0x402677
    goto lab_0x40267c;
  lab_0x402438:;
    // 0x402438
    int32_t result; // 0x4023f0
    if (v7 % 2 == 0) {
        if ((v7 & 2) == 0) {
            // 0x4027e5
            return function_4022d0(v2);
        }
        int32_t v36 = *(int32_t *)(v1 + 12); // 0x4024fc
        if (*(int32_t *)v36 == 0) {
            // 0x4024e2
            return 0;
        }
        int32_t v37 = v36; // 0x40251c
        int32_t v38 = function_4022d0(v2); // 0x40250c
        result = v38;
        while (v38 == 0) {
            // 0x402518
            v37 += 4;
            result = 0;
            if (*(int32_t *)v37 == 0) {
                // break -> 0x4024e2
                break;
            }
            v38 = function_4022d0(v2);
            result = v38;
        }
        // 0x4024e2
        return result;
    }
    if ((v7 & 4) == 0) {
        uint16_t v39 = *(int16_t *)v3 / 8 % 256;
        if (v39 != 0) {
            int32_t v40 = *(int32_t *)(v1 + 12); // 0x402734
            function_401d90();
            int32_t v41 = *(int32_t *)(v40 + 4); // 0x40274f
            if (v41 == 0) {
                // 0x4024e2
                return 0;
            }
            int32_t v42 = 0;
            int32_t v43 = (v41 + v42) / 2; // 0x40277e
            int32_t v44; // bp-40, 0x4023f0
            int32_t v45 = function_401750(*(int32_t *)(v40 + 8 + 4 * v43) + 8, &v44); // 0x402794
            int32_t v46; // bp-44, 0x4023f0
            function_401750(v45, &v46);
            int32_t v47 = v42; // 0x4027b3
            int32_t v48 = v43; // 0x4027b3
            if (v2 >= v44) {
                // 0x4027b5
                if (v2 < v46 + v44) {
                    // break -> 0x4024e2
                    break;
                }
                // 0x4027c3
                v47 = v43 + 1;
                v48 = v41;
            }
            int32_t v49 = v48;
            v42 = v47;
            result = 0;
            while (v42 < v49) {
                int32_t v50 = v49;
                v43 = (v50 + v42) / 2;
                int32_t v51 = *(int32_t *)(v40 + 8 + 4 * v43); // 0x402780
                v45 = function_401750(v51 + 8, &v44);
                function_401750(v45, &v46);
                v47 = v42;
                v48 = v43;
                if (v2 >= v44) {
                    // 0x4027b5
                    result = v51;
                    if (v2 < v46 + v44) {
                        // break -> 0x4024e2
                        break;
                    }
                    // 0x4027c3
                    v47 = v43 + 1;
                    v48 = v50;
                }
                // 0x40276a
                v49 = v48;
                v42 = v47;
                result = 0;
            }
        } else {
            int32_t v52 = *(int32_t *)(v1 + 12); // 0x4026e2
            uint32_t v53 = *(int32_t *)(v52 + 4); // 0x4026e7
            if (v53 <= (int32_t)v39) {
                // 0x4024e2
                return 0;
            }
            uint32_t v54 = 0;
            int32_t v55 = v53;
            uint32_t v56 = (v55 + v54) / 2; // 0x4026fc
            int32_t v57 = *(int32_t *)(v52 + 8 + 4 * v56); // 0x4026fe
            uint32_t v58 = *(int32_t *)(v57 + 8); // 0x402702
            while (v2 < v58) {
                // 0x402711
                result = 0;
                if (v54 >= v56) {
                    // break (via goto) -> 0x4024e2
                    goto lab_0x4024e2;
                }
                v55 = v56;
                v56 = (v55 + v54) / 2;
                v57 = *(int32_t *)(v52 + 8 + 4 * v56);
                v58 = *(int32_t *)(v57 + 8);
            }
            // 0x4027d0
            result = v57;
            while (*(int32_t *)(v57 + 12) + v58 <= v2) {
                int32_t v59 = v56 + 1; // 0x4027db
                result = 0;
                if (v59 >= v55) {
                    // break -> 0x4024e2
                    break;
                }
                v54 = v59;
                v56 = (v55 + v54) / 2;
                v57 = *(int32_t *)(v52 + 8 + 4 * v56);
                v58 = *(int32_t *)(v57 + 8);
                while (v2 < v58) {
                    // 0x402711
                    result = 0;
                    if (v54 >= v56) {
                        // break (via goto) -> 0x4024e2
                        goto lab_0x4024e2;
                    }
                    v55 = v56;
                    v56 = (v55 + v54) / 2;
                    v57 = *(int32_t *)(v52 + 8 + 4 * v56);
                    v58 = *(int32_t *)(v57 + 8);
                }
                // 0x4027d0
                result = v57;
            }
        }
        // 0x4024e2
        return result;
    }
    int32_t v60 = *(int32_t *)(v1 + 12); // 0x40244d
    int32_t v61 = *(int32_t *)(v60 + 4); // 0x402457
    if (v61 == 0) {
        // 0x4024e2
        return 0;
    }
    int32_t v62 = 0; // 0x4023f0
    int32_t v63 = (v61 + v62) / 2; // 0x40247b
    function_401df0();
    function_401d90();
    int32_t v64; // bp-32, 0x4023f0
    int32_t v65 = function_401750(*(int32_t *)(v60 + 8 + 4 * v63) + 8, &v64); // 0x4024ae
    int32_t v66; // bp-36, 0x4023f0
    function_401750(v65, &v66);
    int32_t v67 = v62; // 0x4024cf
    int32_t v68 = v63; // 0x4024cf
    if (v2 >= v64) {
        // 0x4026b7
        if (v2 < v66 + v64) {
            // break -> 0x4024e2
            break;
        }
        // 0x4026c5
        v67 = v63 + 1;
        v68 = v61;
    }
    // 0x4024db
    v62 = v67;
    result = 0;
    while (v67 < v68) {
        int32_t v69 = v68;
        v63 = (v69 + v62) / 2;
        int32_t v70 = *(int32_t *)(v60 + 8 + 4 * v63); // 0x40247d
        function_401df0();
        function_401d90();
        v65 = function_401750(v70 + 8, &v64);
        function_401750(v65, &v66);
        v67 = v62;
        v68 = v63;
        if (v2 >= v64) {
            // 0x4026b7
            result = v70;
            if (v2 < v66 + v64) {
                // break -> 0x4024e2
                break;
            }
            // 0x4026c5
            v67 = v63 + 1;
            v68 = v69;
        }
        // 0x4024db
        v62 = v67;
        result = 0;
    }
  lab_0x4024e2:
    // 0x4024e2
    return result;
  lab_0x40258c:;
    int32_t size = 4 * v9 + 8; // 0x40258f
    int32_t * mem = malloc(size); // 0x402599
    if (mem != NULL) {
        int32_t v35 = (int32_t)mem; // 0x402599
        int32_t v71 = v35 + 4; // 0x4025a9
        int32_t * v72 = (int32_t *)v71; // 0x4025a9
        *v72 = 0;
        int32_t * mem2 = malloc(size); // 0x4025b3
        int32_t v34 = (int32_t)mem2; // 0x4025b3
        if (mem2 != NULL) {
            // 0x4025bf
            *(int32_t *)(v34 + 4) = 0;
        }
        int32_t * v73 = (int32_t *)(v1 + 12);
        int32_t v74 = *v73;
        if ((*v4 & 2) == 0) {
            // 0x40293b
            function_4021d0(v74);
        } else {
            int32_t v75 = *(int32_t *)v74; // 0x4025d6
            if (v75 != 0) {
                int32_t v76 = v74 + 4; // 0x4025e2
                function_4021d0(v75);
                int32_t v77 = *(int32_t *)v76; // 0x4025ed
                int32_t v78 = v77; // 0x4025f1
                int32_t v79 = v76; // 0x4025f1
                while (v77 != 0) {
                    // 0x4025dc
                    v76 = v79 + 4;
                    function_4021d0(v78);
                    v77 = *(int32_t *)v76;
                    v78 = v77;
                    v79 = v76;
                }
            }
        }
        // 0x402809
        if (*v72 != v9) {
            // 0x402815
            abort();
            // UNREACHABLE
        }
        if (mem2 == NULL) {
            // 0x402953
            function_402040(v35);
        } else {
            int32_t v80 = 0; // 0x402655
            int32_t v81 = 0; // 0x402655
            if (v9 != 0) {
                int32_t v32 = v35 + 8;
                v19 = v34 + 8;
                v29 = 0;
                v30 = g24 + 36;
                v31 = v35;
                while (true) {
                  lab_0x40267c:
                    // 0x40267c
                    v23 = v31;
                    v18 = v30;
                    v20 = v29;
                    v17 = 4 * v20;
                    if (g24 + 36 == v18) {
                        goto lab_0x402660;
                    } else {
                        // 0x402683
                        if (*(int32_t *)(v17 + v32) >= 0) {
                            goto lab_0x402660;
                        } else {
                            int32_t * v33 = (int32_t *)(v34 - v35 + v18); // 0x4026ab
                            *v33 = 0;
                            v22 = v20;
                            v24 = *v33;
                            v25 = v23;
                            goto lab_0x402677;
                        }
                    }
                }
              lab_0x402840:
                while (true) {
                    int32_t v82 = v27;
                    int32_t v83 = v26;
                    int32_t v84 = 4 * v28; // 0x402843
                    int32_t v85 = *(int32_t *)(v84 + v32);
                    int32_t v86; // 0x4023f0
                    int32_t v87; // 0x4023f0
                    if (*(int32_t *)(v84 + v19) == 0) {
                        // 0x40291c
                        *(int32_t *)(4 * v83 + v19) = v85;
                        v86 = v83 + 1;
                        v87 = v82;
                    } else {
                        // 0x40284f
                        *(int32_t *)(4 * v82 + v32) = v85;
                        v86 = v83;
                        v87 = v82 + 1;
                    }
                    int32_t v88 = v28 + 1;
                    v26 = v86;
                    v27 = v87;
                    v28 = v88;
                    v80 = v86;
                    v81 = v87;
                    if (v88 == v9) {
                        // break -> 0x402861
                        break;
                    }
                }
            }
            // 0x402861
            *v72 = v81;
            int32_t * v89 = (int32_t *)(v34 + 4); // 0x40286d
            *v89 = v80;
            if (*v72 + v80 != v9) {
                // 0x402815
                abort();
                // UNREACHABLE
            }
            // 0x402880
            function_402040(v34);
            int32_t v90 = *v89; // 0x402897
            if (v90 != 0) {
                int32_t v91 = v35 + 8;
                int32_t v92 = *v72; // 0x4028a1
                int32_t v93 = v90 - 1; // 0x4028a7
                int32_t v94 = *(int32_t *)(v34 + 8 + 4 * v93); // 0x4028a8
                int32_t v95 = v92; // 0x4028db
                int32_t v96 = v92; // 0x4028db
                int32_t v97; // 0x4023f0
                int32_t v98; // 0x4028b8
                int32_t v99; // 0x4028d4
                if (v92 != 0) {
                    v97 = v95;
                    v98 = *(int32_t *)(4 * v97 + v71);
                    v96 = v97;
                    while (v98 >= 1) {
                        // 0x4028cd
                        v99 = v97 - 1;
                        *(int32_t *)(4 * (v97 + v93) + v91) = v98;
                        v95 = v99;
                        v96 = v99;
                        if (v99 == 0) {
                            // break -> 0x4028dd
                            break;
                        }
                        v97 = v95;
                        v98 = *(int32_t *)(4 * v97 + v71);
                        v96 = v97;
                    }
                }
                // 0x4028dd
                v92 = v96;
                *(int32_t *)(4 * (v92 + v93) + v91) = v94;
                int32_t v100 = v93; // 0x4028e9
                while (v93 != 0) {
                    // 0x4028a4
                    v93 = v100 - 1;
                    v94 = *(int32_t *)(v34 + 8 + 4 * v93);
                    v95 = v92;
                    v96 = v92;
                    if (v92 != 0) {
                        v97 = v95;
                        v98 = *(int32_t *)(4 * v97 + v71);
                        v96 = v97;
                        while (v98 >= 1) {
                            // 0x4028cd
                            v99 = v97 - 1;
                            *(int32_t *)(4 * (v97 + v93) + v91) = v98;
                            v95 = v99;
                            v96 = v99;
                            if (v99 == 0) {
                                // break -> 0x4028dd
                                break;
                            }
                            v97 = v95;
                            v98 = *(int32_t *)(4 * v97 + v71);
                            v96 = v97;
                        }
                    }
                    // 0x4028dd
                    v92 = v96;
                    *(int32_t *)(4 * (v92 + v93) + v91) = v94;
                    v100 = v93;
                }
                // 0x4028eb
                *v72 = *v72 + *v89;
            }
            // 0x4028fa
            free(mem2);
        }
        // 0x402905
        *mem = *v73;
        *v4 = *v4 | 1;
        *v73 = v35;
    }
    // 0x402424
    v7 = (int32_t)*v4;
    goto lab_0x402438;
  lab_0x402556:;
    uint32_t v101 = *v10 % 2048; // 0x402562
    if (v8 < 0x200000) {
        // 0x402419
        *v10 = v101 | 2048 * v8;
        v9 = v8;
        if (v8 != 0) {
            goto lab_0x40258c;
        } else {
            // 0x402424
            v7 = (int32_t)*v4;
            goto lab_0x402438;
        }
    } else {
        // 0x402578
        *v10 = v101;
        v9 = v8;
        goto lab_0x40258c;
    }
}

// Address range: 0x402970 - 0x402b50
int32_t function_402970(uint32_t a1, int32_t a2) {
    // 0x402970
    int32_t v1; // 0x402970
    function_401870(v1, v1, v1);
    int32_t v2 = g24; // 0x402990
    int32_t v3; // bp-28, 0x402970
    int32_t * v4 = &v3; // 0x402990
    if (g22 != 0) {
        int32_t v5 = g24 + 20; // 0x40298d
        v3 = v5;
        int32_t * lpAddend = (int32_t *)v5; // 0x402a79
        int32_t v6 = InterlockedIncrement(lpAddend); // 0x402a79
        int32_t v7; // bp-32, 0x402970
        v4 = &v7;
        if (v6 != 0) {
            // 0x402b21
            v3 = -1;
            int32_t hHandle = *(int32_t *)(g24 + 24); // 0x402b2a
            v7 = hHandle;
            int32_t v8 = WaitForSingleObject((int32_t *)hHandle, -1); // 0x402b30
            int32_t v9; // bp-40, 0x402970
            v4 = &v9;
            if (v8 != 0) {
                // 0x402b40
                v9 = v5;
                InterlockedDecrement(lpAddend);
                int32_t v10; // bp-44, 0x402970
                v4 = &v10;
            }
        }
        // 0x402a89
        v2 = g24;
    }
    int32_t v11 = (int32_t)v4;
    int32_t v12 = *(int32_t *)(v2 + 16);
    int32_t v13 = v2; // 0x4029b0
    int32_t v14; // 0x402970
    int32_t v15; // 0x402970
    int32_t v16; // 0x402970
    if (v12 != 0) {
        int32_t v17 = v12;
        while (*(int32_t *)v17 > a1) {
            int32_t v18 = *(int32_t *)(v17 + 20);
            v13 = v2;
            if (v18 == 0) {
                goto lab_0x4029c0;
            }
            v17 = v18;
        }
        int32_t v19 = function_4023f0(); // 0x402aec
        v13 = g24;
        v14 = g24;
        v16 = v17;
        v15 = v19;
        if (v19 == 0) {
            goto lab_0x4029c0;
        } else {
            goto lab_0x402a0f_2;
        }
    } else {
        goto lab_0x4029c0;
    }
  lab_0x4029c0:;
    int32_t * v20 = (int32_t *)(v13 + 12); // 0x4029c0
    int32_t v21 = *v20; // 0x4029c0
    int32_t v22 = v21; // 0x4029c5
    int32_t * v23 = v20; // 0x4029c5
    v14 = v13;
    v16 = 0;
    v15 = 0;
    int32_t * v24; // 0x402970
    int32_t v25; // 0x402970
    int32_t v26; // 0x402970
    int32_t v27; // 0x402970
    int32_t result; // 0x402970
    int32_t v28; // 0x402970
    int32_t v29; // 0x402970
    int32_t v30; // 0x402970
    int32_t v31; // 0x402970
    int32_t * v32; // 0x4029c7
    int32_t v33; // 0x4029d2
    if (v21 == 0) {
        goto lab_0x402a0f_2;
    } else {
        while (true) {
          lab_0x4029c7:
            // 0x4029c7
            v25 = v22;
            v32 = (int32_t *)(v25 + 20);
            *v23 = *v32;
            v33 = function_4023f0();
            int32_t * v34 = (int32_t *)(g24 + 16);
            int32_t v35 = *v34; // 0x4029df
            v24 = v34;
            v26 = 0;
            if (v35 == 0) {
                goto lab_0x402a96;
            } else {
                uint32_t v36 = *(int32_t *)v25; // 0x4029ed
                int32_t v37 = v35; // 0x4029f4
                v24 = v34;
                v26 = v35;
                if (*(int32_t *)v35 < v36) {
                    goto lab_0x402a96;
                } else {
                    int32_t * v38 = (int32_t *)(v37 + 20);
                    int32_t v39 = *v38; // 0x4029fd
                    while (v39 != 0) {
                        // 0x4029f0
                        v37 = v39;
                        v24 = v38;
                        v26 = v39;
                        if (*(int32_t *)v39 < v36) {
                            goto lab_0x402a96;
                        }
                        v38 = (int32_t *)(v37 + 20);
                        v39 = *v38;
                    }
                    // 0x402a04
                    *v32 = 0;
                    *v38 = v25;
                    v14 = g24;
                    v16 = v25;
                    v15 = v33;
                    if (v33 != 0) {
                        goto lab_0x402a0f_2;
                    }
                    goto lab_0x4029c0_2;
                }
            }
        }
      lab_0x402aa3:
        // 0x402aa3
        result = v33;
        v29 = v25;
        v31 = v11;
        v27 = g24;
        v30 = v25;
        v28 = v33;
        if (g22 == 0) {
            goto lab_0x402a23;
        } else {
            goto lab_0x402ab3;
        }
    }
  lab_0x402a0f_2:;
    int32_t v40 = v11; // 0x402a19
    int32_t v41 = v16; // 0x402a19
    int32_t v42 = v15; // 0x402a19
    v27 = v14;
    v30 = v16;
    v28 = v15;
    if (g22 != 0) {
        goto lab_0x402ab3;
    } else {
        goto lab_0x402a1f;
    }
  lab_0x402a96:
    // 0x402a96
    *v32 = v26;
    *v24 = v25;
    if (v33 != 0) {
        // break -> 0x402aa3
        goto lab_0x402aa3;
    }
    goto lab_0x4029c0_2;
  lab_0x4029c0_2:;
    int32_t * v43 = (int32_t *)(g24 + 12); // 0x4029c0
    int32_t v44 = *v43; // 0x4029c0
    v22 = v44;
    v23 = v43;
    v14 = g24;
    v16 = 0;
    v15 = 0;
    if (v44 == 0) {
        goto lab_0x402a0f_2;
    }
    goto lab_0x4029c7;
  lab_0x402ab3:
    // 0x402ab3
    *v4 = v27 + 20;
    uint32_t v45 = InterlockedDecrement(&g27); // 0x402ab6
    int32_t v46 = v11 - 4; // 0x402abb
    v40 = v46;
    v41 = v30;
    v42 = v28;
    if (v45 >= 0) {
        // 0x402ac6
        *(int32_t *)(v11 + 4) = 0;
        *v4 = 1;
        *(int32_t *)v46 = *(int32_t *)(v27 + 24);
        ReleaseSemaphore(&g27, (int32_t)&g27, &g27);
        v40 = v11 - 16;
        v41 = v30;
        v42 = v28;
    }
    goto lab_0x402a1f;
  lab_0x402a1f:
    // 0x402a1f
    result = v42;
    v29 = v41;
    v31 = v40;
    if (v42 == 0) {
        // 0x402a6c
        return 0;
    }
    goto lab_0x402a23;
  lab_0x402a23:
    // 0x402a23
    *(int32_t *)a2 = *(int32_t *)(v29 + 4);
    *(int32_t *)(a2 + 4) = *(int32_t *)(v29 + 8);
    if ((*(char *)(v29 + 16) & 4) != 0) {
        // 0x402b0d
        function_401df0();
    }
    // 0x402a47
    function_401d90();
    *(int32_t *)(v31 + 4) = a2 + 8;
    *(int32_t *)v31 = result + 8;
    function_401750((int32_t)&g27, &g27);
    // 0x402a6c
    return result;
}

// Address range: 0x402b50 - 0x402b5e
int32_t function_402b50(void) {
    // 0x402b50
    return g24;
}

// Address range: 0x402b60 - 0x402c00
int32_t function_402b60(void) {
    // 0x402b60
    int32_t lpBuffer; // bp-76, 0x402b60
    int32_t nAtom; // 0x402b60
    int32_t result; // 0x402bed
    if (GetAtomNameA((int16_t)nAtom, (char *)&lpBuffer, 61) == 0) {
        // 0x402bd4
        result = function_402f50("GetAtomNameA (atom, s, sizeof(s)) != 0", (int32_t)"../../gcc-3.4.5-20060117-1/gcc/config/i386/w32-shared-ptr.c", 241);
        return result;
    }
    int32_t v1 = 0;
    int32_t v2 = 31;
    int32_t v3 = 1;
    int32_t result2; // 0x402b60
    int32_t v4; // bp-4, 0x402b60
    int32_t v5; // 0x402b99
    while (*(char *)((int32_t)&v4 - 72 + v2) != 65) {
        // 0x402b97
        v5 = v2 - 1;
        result2 = v1;
        if (v5 < 0) {
            // break (via goto) -> 0x402baa
            goto lab_0x402baa;
        }
        v2 = v5;
        v3 *= 2;
    }
    int32_t v6 = v3 | v1; // 0x402ba3
    int32_t v7 = v2 - 1; // 0x402ba7
    result2 = v6;
    while (v7 >= 0) {
        // 0x402b9c
        v1 = v6;
        v2 = v7;
        v3 *= 2;
        while (*(char *)((int32_t)&v4 - 72 + v2) != 65) {
            // 0x402b97
            v5 = v2 - 1;
            result2 = v1;
            if (v5 < 0) {
                // break (via goto) -> 0x402baa
                goto lab_0x402baa;
            }
            v2 = v5;
            v3 *= 2;
        }
        // 0x402ba3
        v6 = v3 | v1;
        v7 = v2 - 1;
        result2 = v6;
    }
  lab_0x402baa:
    // 0x402baa
    if (*(int32_t *)result2 == 64) {
        // 0x402baf
        return result2;
    }
    // 0x402bb6
    function_402f50("w32_sharedptr->size == sizeof(W32_EH_SHARED)", (int32_t)"../../gcc-3.4.5-20060117-1/gcc/config/i386/w32-shared-ptr.c", 247);
    // 0x402bd4
    result = function_402f50("GetAtomNameA (atom, s, sizeof(s)) != 0", (int32_t)"../../gcc-3.4.5-20060117-1/gcc/config/i386/w32-shared-ptr.c", 241);
    return result;
}

// Address range: 0x402c00 - 0x402e18
int32_t function_402c00(void) {
    // 0x402c00
    if (g24 != 0) {
        // 0x402c16
        int32_t result; // 0x402c00
        return result;
    }
    int32_t lpString = 0x41414141; // bp-92, 0x402c1e
    uint16_t v1 = FindAtomA((char *)&lpString); // 0x402c9e
    int32_t result2; // 0x402c00
    int32_t v2; // 0x402c00
    int32_t v3; // 0x402c00
    if (v1 != 0) {
        goto lab_0x402ddf;
    } else {
        int32_t * mem = malloc(64); // 0x402cbe
        if (mem == NULL) {
            // 0x402e13
            abort();
            // UNREACHABLE
        }
        int32_t v4 = (int32_t)mem; // 0x402cbe
        __asm_rep_stosd_memset((char *)mem, (int32_t)v1, 16);
        int32_t v5 = v4 + 4;
        *(int32_t *)v5 = 0x402f40;
        int32_t v6 = v4 + 8;
        *(int32_t *)v6 = 0x402b50;
        *mem = 64;
        *(int32_t *)(v4 + 20) = g17;
        *(int32_t *)(v4 + 24) = g18;
        *(int32_t *)(v4 + 28) = g6;
        *(int32_t *)(v4 + 32) = g7;
        *(int32_t *)(v4 + 40) = g19;
        *(int32_t *)(v4 + 48) = -1;
        *(int32_t *)(v4 + 44) = g20;
        *(int32_t *)(v4 + 52) = g21;
        *(int32_t *)(v4 + 60) = g9;
        *(int32_t *)(v4 + 56) = g8;
        int32_t v7 = 1; // 0x402d4e
        int32_t v8 = 31;
        char v9 = (v7 & v4) == 0 ? 97 : 65; // 0x402d5d
        int32_t v10; // bp-4, 0x402c00
        *(char *)((int32_t)&v10 - 152 + v8) = v9;
        v7 *= 2;
        int32_t v11 = v8 - 1; // 0x402d67
        while (v8 != 0) {
            // 0x402d50
            v8 = v11;
            v9 = (v7 & v4) == 0 ? 97 : 65;
            *(char *)((int32_t)&v10 - 152 + v8) = v9;
            v7 *= 2;
            v11 = v8 - 1;
        }
        // 0x402d69
        int32_t lpString2; // bp-156, 0x402c00
        if (AddAtomA((char *)&lpString2) != 0) {
            // 0x402e04
            result2 = v6;
            v2 = v5;
            v3 = v4;
            if (function_402b60() == v4) {
                goto lab_0x402de6;
            } else {
                // 0x402dc9
                free(mem);
                FindAtomA((char *)&lpString);
                goto lab_0x402ddf;
            }
        } else {
            // 0x402dc9
            free(mem);
            FindAtomA((char *)&lpString);
            goto lab_0x402ddf;
        }
    }
  lab_0x402ddf:;
    int32_t v12 = function_402b60(); // 0x402ddf
    result2 = v12 + 8;
    v2 = v12 + 4;
    v3 = v12;
    goto lab_0x402de6;
  lab_0x402de6:
    // 0x402de6
    g24 = v3;
    g23 = v2;
    g25 = result2;
    return result2;
}

// Address range: 0x402e20 - 0x402e4d
int32_t function_402e20(int32_t result) {
    // 0x402e20
    return result;
}

// Address range: 0x402e50 - 0x402e56
void (*function_402e50(int32_t sig, void (*handler)(int32_t)))(int32_t) {
    // 0x402e50
    return signal(sig, handler);
}

// Address range: 0x402e58 - 0x402e66
int32_t function_402e58(void) {
    // 0x402e58
    int32_t v1; // 0x402e58
    int32_t v2 = v1;
    *(char *)v2 = 2 * (char)v2;
    int32_t v3; // 0x402e58
    int32_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    int32_t v5 = v3;
    *(char *)v5 = *(char *)&v3 + (char)v5;
    int32_t v6 = v3;
    *(char *)v6 = *(char *)&v3 + (char)v6;
    return _setmode((int32_t)&g27, (int32_t)&g27);
}

// Address range: 0x402e68 - 0x402e76
int32_t function_402e68(void) {
    // 0x402e68
    int32_t v1; // 0x402e68
    int32_t v2 = v1;
    *(char *)v2 = 2 * (char)v2;
    int32_t v3; // 0x402e68
    int32_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    int32_t v5 = v3;
    *(char *)v5 = *(char *)&v3 + (char)v5;
    int32_t v6 = v3;
    *(char *)v6 = *(char *)&v3 + (char)v6;
    return (int32_t)__p__environ();
}

// Address range: 0x402e78 - 0x402e86
int32_t function_402e78(void) {
    // 0x402e78
    int32_t v1; // 0x402e78
    int32_t v2 = v1;
    *(char *)v2 = 2 * (char)v2;
    int32_t v3; // 0x402e78
    int32_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    int32_t v5 = v3;
    *(char *)v5 = *(char *)&v3 + (char)v5;
    int32_t v6 = v3;
    *(char *)v6 = *(char *)&v3 + (char)v6;
    _cexit();
    return &g27;
}

// Address range: 0x402e88 - 0x402e96
int32_t function_402e88(void) {
    // 0x402e88
    int32_t v1; // 0x402e88
    int32_t v2 = v1;
    *(char *)v2 = 2 * (char)v2;
    int32_t v3; // 0x402e88
    int32_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    int32_t v5 = v3;
    *(char *)v5 = *(char *)&v3 + (char)v5;
    int32_t v6 = v3;
    *(char *)v6 = *(char *)&v3 + (char)v6;
    __set_app_type((int32_t)&g27);
    return &g27;
}

// Address range: 0x402ea0 - 0x402ea6
int32_t * function_402ea0(void) {
    // 0x402ea0
    return __p__fmode();
}

// Address range: 0x402eb0 - 0x402eb6
int32_t function_402eb0(int32_t * Argc, char *** Argv, char *** Env, int32_t DoWildCard, int32_t * StartInfo) {
    // 0x402eb0
    return __getmainargs(Argc, Argv, Env, DoWildCard, StartInfo);
}

// Address range: 0x402ec0 - 0x402ec6
int32_t function_402ec0(char * format, ...) {
    // 0x402ec0
    return scanf(format);
}

// Address range: 0x402ed0 - 0x402ed6
int32_t function_402ed0(char * s) {
    // 0x402ed0
    return strlen(s);
}

// Address range: 0x402ee0 - 0x402ee6
int32_t function_402ee0(char * s, char * format, ...) {
    // 0x402ee0
    return sscanf(s, format);
}

// Address range: 0x402ef0 - 0x402ef6
int32_t function_402ef0(char * format, ...) {
    // 0x402ef0
    return printf(format);
}

// Address range: 0x402f00 - 0x402f06
void function_402f00(int32_t status) {
    // 0x402f00
    exit(status);
}

// Address range: 0x402f10 - 0x402f16
int32_t function_402f10(char * s1, char * s2, int32_t n) {
    // 0x402f10
    return strncmp(s1, s2, n);
}

// Address range: 0x402f20 - 0x402f26
void function_402f20(int32_t * ptr) {
    // 0x402f20
    free(ptr);
}

// Address range: 0x402f30 - 0x402f36
int32_t * function_402f30(int32_t size) {
    // 0x402f30
    return malloc(size);
}

// Address range: 0x402f40 - 0x402f46
void function_402f40(void) {
    // 0x402f40
    abort();
}

// Address range: 0x402f50 - 0x402f56
int32_t function_402f50(char * a1, int32_t a2, int32_t a3) {
    // 0x402f50
    return _assert();
}

// Address range: 0x402f60 - 0x402f66
void function_402f60(int32_t uExitCode) {
    // 0x402f60
    ExitProcess(uExitCode);
}

// Address range: 0x402f70 - 0x402f76
int32_t (*function_402f70(int32_t (*lpTopLevelExceptionFilter)(struct _EXCEPTION_POINTERS *)))(struct _EXCEPTION_POINTERS *) {
    // 0x402f70
    return SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);
}

// Address range: 0x402f80 - 0x402f86
bool function_402f80(int32_t * hSemaphore, int32_t lReleaseCount, int32_t * lpPreviousCount) {
    // 0x402f80
    return ReleaseSemaphore(hSemaphore, lReleaseCount, lpPreviousCount);
}

// Address range: 0x402f90 - 0x402f96
int32_t function_402f90(int32_t * Addend) {
    // 0x402f90
    return InterlockedDecrement(Addend);
}

// Address range: 0x402fa0 - 0x402fa6
int32_t function_402fa0(int32_t * hHandle, int32_t dwMilliseconds) {
    // 0x402fa0
    return WaitForSingleObject(hHandle, dwMilliseconds);
}

// Address range: 0x402fb0 - 0x402fb6
int32_t * function_402fb0(struct _SECURITY_ATTRIBUTES * lpSemaphoreAttributes, int32_t lInitialCount, int32_t lMaximumCount, char * lpName) {
    // 0x402fb0
    return CreateSemaphoreA(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
}

// Address range: 0x402fc0 - 0x402fc6
void function_402fc0(int32_t dwMilliseconds) {
    // 0x402fc0
    Sleep(dwMilliseconds);
}

// Address range: 0x402fd0 - 0x402fd6
int32_t function_402fd0(int32_t * Addend) {
    // 0x402fd0
    return InterlockedIncrement(Addend);
}

// Address range: 0x402fe0 - 0x402fe6
int32_t function_402fe0(int16_t nAtom, char * lpBuffer, int32_t nSize) {
    // 0x402fe0
    return GetAtomNameA(nAtom, lpBuffer, nSize);
}

// Address range: 0x402ff0 - 0x402ff6
int16_t function_402ff0(char * lpString) {
    // 0x402ff0
    return AddAtomA(lpString);
}

// Address range: 0x403000 - 0x403006
int16_t function_403000(char * lpString) {
    // 0x403000
    return FindAtomA(lpString);
}

// Address range: 0x403008 - 0x403019
int32_t function_403008(void) {
    // 0x403008
    int32_t v1; // 0x403008
    int32_t v2 = v1;
    *(char *)v2 = 2 * (char)v2;
    int32_t v3; // 0x403008
    int32_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    int32_t v5 = v3;
    *(char *)v5 = *(char *)&v3 + (char)v5;
    int32_t v6 = v3;
    *(char *)v6 = *(char *)&v3 + (char)v6;
    return function_4012c0();
}

// Address range: 0x403020 - 0x403029
int32_t function_403020(void) {
    // 0x403020
    return function_4012f0();
}

// Address range: 0x40303f - 0x403041
int32_t function_40303f(void) {
    // 0x40303f
    int32_t result; // 0x40303f
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int __getmainargs(int * Argc, char *** Argv, char *** Env, int DoWildCard, _startupinfo * StartInfo);
// char *** __cdecl __p__environ(void);
// int * __cdecl __p__fmode(void);
// void __set_app_type(int at);
// int32_t _assert(void);
// void __cdecl _cexit(void);
// _onexit_t _onexit(_onexit_t Function);
// int __cdecl _setmode(_In_ int FileHandle, _In_ int Mode);
// void abort(void);
// ATOM AddAtomA(_In_opt_ LPCSTR lpString);
// int atexit(void(* func)(void));
// HANDLE CreateSemaphoreA(_In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, _In_ LONG lInitialCount, _In_ LONG lMaximumCount, _In_opt_ LPCSTR lpName);
// void exit(int status);
// VOID ExitProcess(_In_ UINT uExitCode);
// ATOM FindAtomA(_In_opt_ LPCSTR lpString);
// void free(void * ptr);
// UINT GetAtomNameA(_In_ ATOM nAtom, LPSTR lpBuffer, _In_ int nSize);
// unsigned InterlockedDecrement(_Inout_ unsigned volatile * Addend);
// unsigned InterlockedIncrement(_Inout_ unsigned volatile * Addend);
// void * malloc(size_t size);
// int printf(const char * restrict format, ...);
// BOOL ReleaseSemaphore(_In_ HANDLE hSemaphore, _In_ LONG lReleaseCount, _Out_opt_ LPLONG lpPreviousCount);
// int scanf(const char * restrict format, ...);
// LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(_In_opt_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// __sighandler_t signal(int sig, __sighandler_t handler);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// DWORD WaitForSingleObject(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: dev-c++ gcc (4.9.9.2)
// Detected functions: 82

