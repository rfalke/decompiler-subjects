// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw405000 = 0x00; // 00405000
word32 g_dw405004 = 0x00; // 00405004
word32 g_dw405030 = 0x00; // 00405030
word32 g_dw405040 = 0x00; // 00405040
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

int32 g_dw403000 = -1; // 00403000
word32 g_dw403010 = 0x4000; // 00403010
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw406040 = 0x6154; // 00406040
word32 g_dw406044 = 0x6160; // 00406044
word32 g_dw406048 = 24948; // 00406048
word32 g_dw40604C = 24964; // 0040604C
word32 g_dw406050 = 0x6190; // 00406050
word32 g_dw406054 = 24992; // 00406054
word32 g_dw406058 = 0x61B8; // 00406058
word32 g_dw40605C = 0x61D0; // 0040605C
word32 g_dw406060 = 25060; // 00406060
word32 g_dw406064 = 0x6204; // 00406064
word32 g_dw406068 = 0x620C; // 00406068
word32 g_dw406074 = 0x6224; // 00406074
word32 g_dw406078 = 0x6234; // 00406078
word32 g_dw40607C = 0x6244; // 0040607C
word32 g_dw406080 = 25172; // 00406080
word32 g_dw406084 = 0x6268; // 00406084
word32 g_dw406088 = 25204; // 00406088
word32 g_dw40608C = 0x6280; // 0040608C
word32 g_dw406090 = 25224; // 00406090
word32 g_dw406094 = 25236; // 00406094
word32 g_dw406098 = 0x62A0; // 00406098
word32 g_dw40609C = 25256; // 0040609C
word32 g_dw4060A0 = 25268; // 004060A0
word32 g_dw4060A4 = 25276; // 004060A4
word32 g_dw4060A8 = 25284; // 004060A8
word32 g_dw4060AC = 0x62D0; // 004060AC
word32 g_dw4060B0 = 0x62DC; // 004060B0
word32 g_dw4060B4 = 0x62E4; // 004060B4
word32 g_dw4060B8 = 0x62F0; // 004060B8
word32 g_dw4060BC = 0x62FC; // 004060BC
word32 g_dw4060C0 = 25352; // 004060C0
<anonymous> * __imp__AddAtomA = &g_t6154; // 004060CC
<anonymous> * __imp__CreateSemaphoreA = &g_t6160; // 004060D0
<anonymous> * __imp__ExitProcess = &g_t6174; // 004060D4
<anonymous> * __imp__FindAtomA = &g_t6184; // 004060D8
<anonymous> * __imp__GetAtomNameA = &g_t6190; // 004060DC
<anonymous> * __imp__InterlockedDecrement = &g_t61A0; // 004060E0
<anonymous> * __imp__InterlockedIncrement = &g_t61B8; // 004060E4
<anonymous> * __imp__ReleaseSemaphore = &g_t61D0; // 004060E8
<anonymous> * __imp__SetUnhandledExceptionFilter = &g_t61E4; // 004060EC
<anonymous> * __imp__Sleep = &g_t6204; // 004060F0
<anonymous> * __imp__WaitForSingleObject = &g_t620C; // 004060F4
<anonymous> * __imp____getmainargs = &g_t6224; // 00406100
<anonymous> * __imp____p__environ = &g_t6234; // 00406104
<anonymous> * __imp____p__fmode = &g_t6244; // 00406108
<anonymous> * __imp____set_app_type = &g_t6254; // 0040610C
<anonymous> * __imp___assert = &g_t6268; // 00406110
<anonymous> * __imp___cexit = &g_t6274; // 00406114
<anonymous> * __imp___iob = &g_t6280; // 00406118
<anonymous> * __imp___onexit = &g_t6288; // 0040611C
<anonymous> * __imp___setmode = &g_t6294; // 00406120
<anonymous> * __imp__abort = &g_t62A0; // 00406124
<anonymous> * __imp__atexit = &g_t62A8; // 00406128
<anonymous> * __imp__exit = &g_t62B4; // 0040612C
<anonymous> * __imp__free = &g_t62BC; // 00406130
<anonymous> * __imp__malloc = &g_t62C4; // 00406134
<anonymous> * __imp__printf = &g_t62D0; // 00406138
<anonymous> * __imp__scanf = &g_t62DC; // 0040613C
<anonymous> * __imp__signal = &g_t62E4; // 00406140
<anonymous> * __imp__sscanf = &g_t62F0; // 00406144
<anonymous> * __imp__strlen = &g_t62FC; // 00406148
<anonymous> * __imp__strncmp = &g_t6308; // 0040614C
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_str404000[] = "LOLO"; // 00404000
char g_str404005[] = "%d"; // 00404005
char g_str404008[] = "Password OK!\n"; // 00404008
char g_str404016[] = "Password Incorrect!\n"; // 00404016
char g_str40402B[] = "IOLI Crackme Level 0x06\n"; // 0040402B
char g_str404044[] = "Password: "; // 00404044
char g_str40404F[] = "%s"; // 0040404F
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

LONG g_t401000(struct _EXCEPTION_POINTERS * ExceptionInfo) = ??/* Unexpected function type (fn LONG ((ptr32 (struct "_EXCEPTION_POINTERS" 0008)))) */ ; // 00401000
// 00401140: void fn00401140()
// Called from:
//      Win32CrtStartup
void fn00401140()
{
	ptr32 fp;
	char ** ptrLoc10;
	SetUnhandledExceptionFilter(&g_t401000);
	fn00401510();
	__getmainargs(&g_dw405004, &g_dw405000, &ptrLoc10, g_dw403000);
	struct Eq_24 * esp_101 = fp - 44;
	word32 eax_28 = g_dw405030;
	if (eax_28 != 0x00)
	{
		g_dw403010 = eax_28;
		ptr32 edx_34 = iob;
		if (iob != 0x00)
		{
			setmode(iob->dw0010, eax_28);
			edx_34 = iob;
		}
		if (edx_34 != ~0x1F)
		{
			setmode(iob->dw0030, g_dw405030);
			edx_34 = iob;
		}
		if (edx_34 != ~0x3F)
			setmode(iob->dw0050, g_dw405030);
	}
	*__p__fmode() = g_dw403010;
	word32 ecx_95 = fn004014E0();
	__align_stack<word32>(esp_101);
	esp_101->ptr0008 = (char * (*)[]) *__p__environ();
	esp_101->dw0004 = g_dw405000;
	esp_101->dw0000 = g_dw405004;
	Eq_67 eax_109 = fn00401463(ecx_95, esp_101->ptr0008);
	cexit();
	*esp_120 = (uint32) eax_109;
	ExitProcess(*esp_120);
}

// 00401260: Register Eq_130 Win32CrtStartup()
Eq_130 Win32CrtStartup()
{
	__set_app_type(0x01);
	fn00401140();
}

// 004012A0: void fn004012A0(Stack (ptr32 Eq_139) ptrArg04)
// Called from:
//      Win32CrtStartup
//      fn004015B0
void fn004012A0(void (* ptrArg04)())
{
	atexit(ptrArg04);
}

// 00401310: Register word32 fn00401310(Stack (arr (ptr32 char)) dwArg08)
// Called from:
//      fn00401376
word32 fn00401310(char * dwArg08[])
{
	ui32 dwLoc08_43 = 0x00;
	do
	{
		word32 dwLoc0C_46;
		if (dwArg08[dwLoc08_74] == null)
		{
			dwLoc0C_46 = 0x00;
			return dwLoc0C_46;
		}
		dwLoc08_43 = dwLoc08_74 + 0x01;
		dwLoc08_74 = dwLoc08_43;
	} while (strncmp(dwArg08[dwLoc08_74], "LOLO", 0x03) != 0x00);
	dwLoc0C_46 = 0x01;
	return dwLoc0C_46;
}

// 00401376: void fn00401376(Stack (ptr32 char) dwArg04, Stack (ptr32 (arr (ptr32 char))) dwArg08)
// Called from:
//      fn004013E4
void fn00401376(char * dwArg04, char * (* dwArg08)[])
{
	int32 dwLoc08;
	sscanf(dwArg04, "%d", &dwLoc08);
	if (fn00401310(dwArg08) != 0x00)
	{
		int32 dwLoc0C_65;
		for (dwLoc0C_65 = 0x00; dwLoc0C_65 <= 0x09; ++dwLoc0C_65)
		{
			if ((dwLoc08 & 0x01) == 0x00)
			{
				printf("Password OK!\n");
				exit(0x00);
			}
		}
	}
}

// 004013E4: void fn004013E4(Stack (ptr32 char) dwArg04, Stack (ptr32 (arr (ptr32 char))) dwArg08)
// Called from:
//      fn00401463
void fn004013E4(char * dwArg04, char * (* dwArg08)[])
{
	char bLoc11;
	int32 dwLoc08;
	word32 dwLoc0C_64 = 0x00;
	Eq_157 dwLoc10_65 = 0x00;
	while (dwLoc10_65 < strlen(dwArg04))
	{
		Mem29[&bLoc11 + 0x00:byte] = Mem16[dwLoc10_65 + dwArg04:byte];
		sscanf(&bLoc11, "%d", &dwLoc08);
		word32 v10_38 = dwLoc0C_64 + dwLoc08;
		dwLoc0C_64 = v10_38;
		if (v10_38 == 0x10)
			fn00401376(dwArg04, dwArg08);
		dwLoc10_65 = (word32) dwLoc10_65.u0 + 1;
	}
	printf("Password Incorrect!\n");
}

// 00401463: Register word32 fn00401463(Register word32 ecx, Stack (ptr32 (arr (ptr32 char))) dwArg0C)
// Called from:
//      fn00401140
word32 fn00401463(word32 ecx, char * (* dwArg0C)[])
{
	ptr32 fp;
	char bLoc7C;
	<anonymous> * dwLocA0;
	__align_stack<word32>(fp - 0x9C);
	fn00402DB0(0x10, ecx, dwLocA0);
	fn004015B0();
	printf("IOLI Crackme Level 0x06\n");
	printf("Password: ");
	scanf("%s", &bLoc7C);
	fn004013E4(&bLoc7C, dwArg0C);
	return 0x00;
}

// 004014E0: Register (ptr32 Eq_293) fn004014E0()
// Called from:
//      fn00401140
struct Eq_293 * fn004014E0()
{
	struct Eq_293 * ecx_15;
	for (ecx_15 = (struct Eq_293 *) 0x00404310; ecx_15 < (struct Eq_293 *) 0x00404310; ++ecx_15)
	{
		struct Eq_298 * edx_13 = ecx_15->dw0004;
		edx_13->dw400000 += ecx_15->dw0000;
	}
	return ecx_15;
}

// 00401510: void fn00401510()
// Called from:
//      fn00401140
void fn00401510()
{
	__fninit();
}

Eq_139 g_t401520 = ??/* Unexpected function type (fn void ()) */ ; // 00401520
// 004015B0: void fn004015B0()
// Called from:
//      fn00401463
void fn004015B0()
{
	if (g_dw405040 != 0x00)
		return;
	g_dw405040 = 0x01;
	ui32 eax_24 = g_dw402FC0;
	if (eax_24 == ~0x00)
	{
		eax_24 = 0x00;
		bool v19_85 = g_dw402FC4 != 0x00;
		while (v19_85)
		{
			++eax_24;
			v19_85 = (&g_dw402FC4)[eax_24 * 0x04] != 0x00;
		}
	}
	ui32 ebx_41 = eax_24;
	if (eax_24 != 0x00)
	{
		do
		{
			fn90909090();
			--ebx_41;
		} while (ebx_41 != 0x00);
	}
	fn004012A0(&g_t401520);
}

// 00402DB0: void fn00402DB0(Register uint32 eax, Register word32 ecx, Stack (ptr32 code) dwArg00)
// Called from:
//      fn00401463
void fn00402DB0(uint32 eax, word32 ecx, <anonymous> * dwArg00)
{
	ptr32 fp;
	struct Eq_357 * ecx_13 = fp + 0x04;
	for (; eax >= 0x1000; eax -= 0x1000)
	{
		ecx_13 -= 0x1000;
		ecx_13->dw0000 = ecx_13->dw0000;
	}
	word32 * ecx_14 = ecx_13 - eax;
	*ecx_14 = *ecx_14;
	dwArg00();
}

ui32 g_dw402FC0 = ~0x00; // 00402FC0
word32 g_dw402FC4 = 0x00402FA0; // 00402FC4
