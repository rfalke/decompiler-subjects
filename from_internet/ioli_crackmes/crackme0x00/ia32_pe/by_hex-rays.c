/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

LONG __stdcall _gnu_exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
void __noreturn __mingw_CRTStartup();
void __noreturn WinMainCRTStartup(); // weak
int __cdecl atexit(void (__cdecl *)());
_onexit_t __cdecl _onexit(_onexit_t Func);
void __do_frame_init();
int __do_frame_fini();
int __cdecl main(int argc, const char **argv, const char **envp);
int _pei386_runtime_relocator();
void __cdecl _fpreset();
void __cdecl __do_global_dtors(); // idb
int __do_global_ctors();
int __main();
// int __usercall size_of_encoded_value@<eax>(char a1@<al>);
// char *__usercall read_uleb128@<eax>(char *a1@<eax>, _DWORD *a2@<edx>);
// char *__usercall read_sleb128@<eax>(char *a1@<eax>, _DWORD *a2@<edx>);
// char *__usercall read_encoded_value_with_base@<eax>(char a1@<al>, int a2@<edx>, char *a3, int *a4);
HANDLE init_object_mutex();
HANDLE init_object_mutex_once();
void __cdecl __register_frame_info_bases(_DWORD *a1, _DWORD *a2, int a3, int a4);
void __cdecl __register_frame_info(_DWORD *a1, _DWORD *a2);
void __cdecl __register_frame(_DWORD *a1);
LONG __cdecl __register_frame_info_table_bases(int a1, _DWORD *a2, int a3, int a4);
LONG __cdecl __register_frame_info_table(int a1, _DWORD *a2);
LONG __cdecl __register_frame_table(int a1);
int __cdecl __deregister_frame_info_bases(_DWORD *a1);
int __cdecl __deregister_frame_info(_DWORD *a1);
void __cdecl __deregister_frame(_DWORD *a1);
// int __usercall base_from_object@<eax>(char a1@<al>, int a2@<edx>);
// int __usercall get_cie_encoding@<eax>(int a1@<eax>);
int __cdecl fde_unencoded_compare(int a1, int a2, int a3);
int __cdecl fde_single_encoding_compare(int a1, int a2, int a3);
int __cdecl fde_mixed_encoding_compare(int a1, int a2, int a3);
// int __usercall frame_downheap@<eax>(int result@<eax>, int (__cdecl *a2)(int, _DWORD, _DWORD)@<edx>, int a3, int a4, int a5);
// unsigned int __usercall frame_heapsort@<eax>(int a1@<eax>, int (__cdecl *a2)(int, _DWORD, _DWORD)@<edx>, int a3);
// int __usercall classify_object_over_fdes@<eax>(int a1@<eax>, char *a2@<edx>);
// int __usercall add_fdes@<eax>(int a1@<eax>, int *a2@<edx>, char *a3);
// int __usercall linear_search_fdes@<eax>(int a1@<eax>, int a2@<edx>, int a3);
// int __usercall search_object@<eax>(int a1@<eax>, unsigned int a2@<edx>);
int __cdecl _Unwind_Find_FDE(unsigned int a1, _DWORD *a2);
int __w32_sharedptr_default_unexpected();
// unsigned int __usercall __w32_sharedptr_get@<eax>(ATOM nAtom@<ax>);
void __w32_sharedptr_initialize();
// int *__cdecl __p__fmode();
// int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// int scanf(const char *const Format, ...);
// int printf(const char *const Format, ...);
// size_t __cdecl strlen(const char *Str);
// void __cdecl free(void *Block);
// void *__cdecl malloc(size_t Size);
// void __cdecl __noreturn abort();
// int __thiscall _assert(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// HANDLE __stdcall CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
// void __stdcall Sleep(DWORD dwMilliseconds);
// LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
// UINT __stdcall GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize);
// ATOM __stdcall AddAtomA(LPCSTR lpString);
// ATOM __stdcall FindAtomA(LPCSTR lpString);
void __reg_frame_ctor();
int __dereg_frame_dtor();
// char ***__cdecl ___p__environ();
// void __cdecl ___set_app_type(_crt_app_type Type);
// void __cdecl __cexit();
// _onexit_t __cdecl __onexit(_onexit_t Func);
// int __cdecl __setmode(int FileHandle, int Mode);
// int __cdecl _atexit(void (__cdecl *)());
// _crt_signal_t __cdecl _signal(int Signal, _crt_signal_t Function);

//-------------------------------------------------------------------------
// Data declarations

int __CTOR_LIST__[] = { -1 }; // weak
int (*off_402E64)() = &__reg_frame_ctor; // weak
int _CRT_glob = -1; // weak
int _fmode = 16384;
int (**p_0)() = &off_402E70; // weak
int dw2_once_1 = 0; // weak
int dword_403034 = -1; // weak
int eh_globals_once_4 = 0; // weak
int dword_40303C = -1; // weak
_DWORD __EH_FRAME_BEGIN__[107] =
{
  16,
  0,
  2080440321,
  67439624,
  392,
  24,
  24,
  4200048,
  66,
  -2079846847,
  67978242,
  230212,
  28,
  52,
  4200128,
  133,
  -2079846847,
  67977730,
  1308918598,
  902,
  28,
  84,
  4200272,
  237,
  -2079846847,
  67977730,
  1225032518,
  902,
  20,
  116,
  4200512,
  38,
  -2079846847,
  67978242,
  24,
  140,
  4200560,
  52,
  -2079846847,
  67977730,
  230212,
  28,
  168,
  4200624,
  251,
  -2079846847,
  67977730,
  -2046524603,
  3,
  20,
  200,
  4200880,
  38,
  -2079846847,
  67978242,
  20,
  224,
  4200928,
  35,
  -2079846847,
  67977730,
  28,
  248,
  4200976,
  387,
  -2079846847,
  67977730,
  -2046459066,
  231172,
  20,
  280,
  4201392,
  34,
  -2079846847,
  67977730,
  28,
  304,
  4201984,
  137,
  -2079846847,
  67977730,
  -2046459066,
  231172,
  28,
  336,
  4202128,
  111,
  -2079846847,
  67977730,
  -2046459066,
  231172,
  28,
  368,
  4203072,
  1405,
  -2079846847,
  67977730,
  -2046459066,
  231172,
  28,
  400,
  4204480,
  480,
  -2079846847,
  67977730,
  1191413569,
  75892099
}; // idb
_DWORD _RUNTIME_PSEUDO_RELOC_LIST_END__[828] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  
}; // idb
char **_argv; // idb
int _argc; // idb
_DWORD obj[8]; // idb
int _CRT_fmode; // idb
int initialized; // weak
int dw2_object_mutex_0; // weak
int dword_405064; // weak
int eh_globals_static_2; // weak
int dword_405074; // weak
int eh_globals_key_3; // weak
int _CRT_MT; // weak
int __w32_sharedptr_terminate; // weak
int __w32_sharedptr; // weak
int __w32_sharedptr_unexpected; // weak
// extern FILE __iob[];


//----- (00401000) --------------------------------------------------------
LONG __stdcall _gnu_exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  int v1; // ebx
  int v2; // esi
  DWORD v3; // eax
  _crt_signal_t v4; // eax
  bool v6; // zf
  _crt_signal_t v7; // eax
  _crt_signal_t v8; // eax

  v1 = 0;
  v2 = 0;
  v3 = ExceptionInfo->ExceptionRecord->ExceptionCode;
  if ( v3 <= 0xC0000091 )
  {
    if ( v3 >= 0xC000008D )
    {
LABEL_3:
      v2 = 1;
      goto LABEL_4;
    }
    if ( v3 == -1073741819 )
    {
      v8 = _signal(11, 0);
      if ( v8 == (_crt_signal_t)1 )
      {
        _signal(11, (_crt_signal_t)1);
      }
      else
      {
        if ( !v8 )
          return v1;
        v8(11);
      }
      return -1;
    }
    v6 = v3 == -1073741795;
LABEL_15:
    if ( !v6 )
      return v1;
    v7 = _signal(4, 0);
    if ( v7 == (_crt_signal_t)1 )
    {
      _signal(4, (_crt_signal_t)1);
    }
    else
    {
      if ( !v7 )
        return v1;
      v7(4);
    }
    return -1;
  }
  if ( v3 == -1073741676 )
  {
LABEL_4:
    v4 = _signal(8, 0);
    if ( v4 == (_crt_signal_t)1 )
    {
      _signal(8, (_crt_signal_t)1);
      if ( v2 )
        _fpreset();
    }
    else
    {
      if ( !v4 )
        return v1;
      v4(8);
    }
    return -1;
  }
  if ( v3 > 0xC0000094 )
  {
    v6 = v3 == -1073741674;
    goto LABEL_15;
  }
  if ( v3 == -1073741677 )
    goto LABEL_3;
  return 0;
}

//----- (00401140) --------------------------------------------------------
void __noreturn __mingw_CRTStartup()
{
  char *v0; // edx
  char ***v1; // eax
  int v2; // ebx
  char v3[4]; // [esp+1Ch] [ebp-Ch] BYREF
  int v4; // [esp+20h] [ebp-8h] BYREF

  SetUnhandledExceptionFilter(_gnu_exception_handler);
  _fpreset();
  v4 = 0;
  __getmainargs(&_argc, &_argv, v3, _CRT_glob, &v4);
  if ( _CRT_fmode )
  {
    _fmode = _CRT_fmode;
    v0 = __iob[0]._ptr;
    if ( __iob[0]._ptr )
    {
      __setmode(__iob[0]._file, _CRT_fmode);
      v0 = __iob[0]._ptr;
    }
    if ( v0 != (char *)-32 )
    {
      __setmode(__iob[1]._file, _CRT_fmode);
      v0 = __iob[0]._ptr;
    }
    if ( v0 != (char *)-64 )
      __setmode(__iob[2]._file, _CRT_fmode);
  }
  *__p__fmode() = _fmode;
  _pei386_runtime_relocator();
  v1 = ___p__environ();
  v2 = main(_argc, (const char **)_argv, (const char **)*v1);
  __cexit();
  ExitProcess(v2);
}
// 402D00: using guessed type int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 403000: using guessed type int _CRT_glob;

//----- (00401280) --------------------------------------------------------
void __noreturn WinMainCRTStartup()
{
  ___set_app_type(_crt_gui_app);
  __mingw_CRTStartup();
}
// 401280: using guessed type void __noreturn WinMainCRTStartup();

//----- (004012A0) --------------------------------------------------------
int __cdecl atexit(void (__cdecl *a1)())
{
  return _atexit(a1);
}

//----- (004012B0) --------------------------------------------------------
_onexit_t __cdecl _onexit(_onexit_t Func)
{
  return __onexit(Func);
}

//----- (004012C0) --------------------------------------------------------
void __do_frame_init()
{
  __w32_sharedptr_initialize();
  __register_frame_info(__EH_FRAME_BEGIN__, obj);
}

//----- (004012F0) --------------------------------------------------------
int __do_frame_fini()
{
  return __deregister_frame_info(__EH_FRAME_BEGIN__);
}

//----- (00401310) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  void *v3; // esp
  char Str1[24]; // [esp+20h] [ebp-18h] BYREF

  v3 = alloca(16);
  __main();
  printf("IOLI Crackme Level 0x00\n");
  printf("Password: ");
  scanf("%s", Str1);
  if ( !strcmp(Str1, "250382") )
    printf("Password OK :)\n");
  else
    printf("Invalid Password!\n");
  return 0;
}

//----- (004013A0) --------------------------------------------------------
int _pei386_runtime_relocator()
{
  int *i; // ecx
  int v1; // edx
  int result; // eax

  for ( i = _RUNTIME_PSEUDO_RELOC_LIST_END__; i < _RUNTIME_PSEUDO_RELOC_LIST_END__; i += 2 )
  {
    v1 = i[1];
    result = *i;
    *(_DWORD *)(v1 + 0x400000) += result;
  }
  return result;
}

//----- (004013D0) --------------------------------------------------------
void __cdecl _fpreset()
{
  __asm { fninit }
}

//----- (004013E0) --------------------------------------------------------
void __cdecl __do_global_dtors()
{
  int (**v0)(); // eax
  int (*v1)(); // edx

  v0 = p_0;
  if ( *p_0 )
  {
    do
    {
      (*v0)();
      v0 = p_0 + 1;
      v1 = p_0[1];
      ++p_0;
    }
    while ( v1 );
  }
}
// 403020: using guessed type int (**p_0)();

//----- (00401410) --------------------------------------------------------
int __do_global_ctors()
{
  int v0; // eax
  int j; // ebx
  bool i; // zf

  v0 = __CTOR_LIST__[0];
  if ( __CTOR_LIST__[0] == -1 )
  {
    v0 = 0;
    for ( i = __reg_frame_ctor == 0; !i; i = *(&off_402E64 + v0) == 0 )
      ++v0;
  }
  for ( j = v0; j; --j )
    ((void (*)(void))__CTOR_LIST__[j])();
  return atexit(__do_global_dtors);
}
// 402E60: using guessed type int __CTOR_LIST__[];
// 402E64: using guessed type int (*off_402E64)();

//----- (00401470) --------------------------------------------------------
int __main()
{
  int result; // eax

  result = initialized;
  if ( !initialized )
  {
    initialized = 1;
    result = __do_global_ctors();
  }
  return result;
}
// 405040: using guessed type int initialized;

//----- (00401490) --------------------------------------------------------
int __usercall size_of_encoded_value@<eax>(char a1@<al>)
{
  int v1; // edx
  int v2; // eax

  v1 = 0;
  if ( a1 == -1 )
    return v1;
  v2 = a1 & 7;
  v1 = 2;
  if ( v2 == 2 )
    return v1;
  if ( v2 <= 2 )
  {
    if ( v2 )
LABEL_6:
      abort();
    return 4;
  }
  v1 = 4;
  if ( v2 == 3 )
    return v1;
  if ( v2 != 4 )
    goto LABEL_6;
  return 8;
}

//----- (004014E0) --------------------------------------------------------
char *__usercall read_uleb128@<eax>(char *a1@<eax>, _DWORD *a2@<edx>)
{
  int v3; // esi
  int v4; // ebx
  char v5; // cl
  char v6; // dl

  v3 = 0;
  v4 = 0;
  do
  {
    v5 = v4;
    v4 += 7;
    v6 = *a1++;
    v3 |= (v6 & 0x7F) << v5;
  }
  while ( v6 < 0 );
  *a2 = v3;
  return a1;
}

//----- (00401530) --------------------------------------------------------
char *__usercall read_sleb128@<eax>(char *a1@<eax>, _DWORD *a2@<edx>)
{
  int v2; // edi
  unsigned int v3; // esi
  char v4; // cl
  char v5; // dl

  v2 = 0;
  v3 = 0;
  do
  {
    v4 = v3;
    v3 += 7;
    v5 = *a1++;
    v2 |= (v5 & 0x7F) << v4;
  }
  while ( v5 < 0 );
  if ( v3 <= 0x1F && (v5 & 0x40) != 0 )
    v2 |= -1 << v3;
  *a2 = v2;
  return a1;
}

//----- (004015A0) --------------------------------------------------------
char *__usercall read_encoded_value_with_base@<eax>(char a1@<al>, int a2@<edx>, char *a3, int *a4)
{
  int v6; // edx
  char *v7; // ecx
  char *result; // eax
  int *v9; // eax
  char *v10; // eax
  char *v11; // eax
  int v12; // [esp+4h] [ebp-14h] BYREF
  int v13; // [esp+8h] [ebp-10h] BYREF

  if ( a1 == 80 )
  {
    v9 = (int *)((unsigned int)(a3 + 3) & 0xFFFFFFFC);
    *a4 = *v9;
    result = (char *)(v9 + 1);
  }
  else
  {
    switch ( a1 & 0xF )
    {
      case 0:
      case 3:
      case 0xB:
        v6 = *(_DWORD *)a3;
        v7 = a3 + 4;
        break;
      case 1:
        v10 = read_uleb128(a3, &v13);
        v6 = v13;
        v7 = v10;
        break;
      case 2:
        v6 = *(unsigned __int16 *)a3;
        v7 = a3 + 2;
        break;
      case 4:
      case 0xC:
        v6 = *(_DWORD *)a3;
        v7 = a3 + 8;
        break;
      case 9:
        v11 = read_sleb128(a3, &v12);
        v6 = v12;
        v7 = v11;
        break;
      case 0xA:
        v6 = *(__int16 *)a3;
        v7 = a3 + 2;
        break;
      default:
        abort();
    }
    if ( v6 )
    {
      if ( (a1 & 0x70) == 16 )
        v6 += (int)a3;
      else
        v6 += a2;
      if ( a1 < 0 )
        v6 = *(_DWORD *)v6;
    }
    *a4 = v6;
    result = v7;
  }
  return result;
}

//----- (00401670) --------------------------------------------------------
HANDLE init_object_mutex()
{
  int v0; // eax
  int v1; // ebx
  HANDLE result; // eax

  v0 = __w32_sharedptr;
  *(_DWORD *)(__w32_sharedptr + 20) = -1;
  v1 = v0 + 20;
  result = CreateSemaphoreA(0, 0, 0xFFFF, 0);
  *(_DWORD *)(v1 + 4) = result;
  return result;
}
// 4050B0: using guessed type int __w32_sharedptr;

//----- (004016C0) --------------------------------------------------------
HANDLE init_object_mutex_once()
{
  HANDLE result; // eax
  int v1; // ebx
  HANDLE *v2; // esi

  result = (HANDLE)_CRT_MT;
  v1 = __w32_sharedptr;
  v2 = (HANDLE *)(__w32_sharedptr + 28);
  if ( _CRT_MT )
  {
    if ( __w32_sharedptr != -28 )
    {
      result = *(HANDLE *)(__w32_sharedptr + 28);
      if ( !result )
      {
        result = (HANDLE)InterlockedIncrement((volatile LONG *)(__w32_sharedptr + 32));
        if ( result )
        {
          if ( !*(_DWORD *)(v1 + 28) )
          {
            do
            {
              Sleep(0);
              result = *v2;
            }
            while ( !*v2 );
          }
        }
        else
        {
          result = init_object_mutex();
          *(_DWORD *)(v1 + 28) = 1;
        }
      }
    }
  }
  return result;
}
// 405090: using guessed type int _CRT_MT;
// 4050B0: using guessed type int __w32_sharedptr;

//----- (00401750) --------------------------------------------------------
void __cdecl __register_frame_info_bases(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // edx
  int lpAddend; // esi
  int v7; // ebx

  if ( a1 && *a1 )
  {
    *a2 = -1;
    a2[1] = a3;
    a2[4] = 0;
    a2[3] = a1;
    a2[2] = a4;
    *((_WORD *)a2 + 8) |= 0x7F8u;
    init_object_mutex_once();
    v4 = _CRT_MT;
    v5 = __w32_sharedptr;
    lpAddend = __w32_sharedptr + 20;
    if ( _CRT_MT )
    {
      if ( InterlockedIncrement((volatile LONG *)(__w32_sharedptr + 20))
        && WaitForSingleObject(*(HANDLE *)(lpAddend + 4), 0xFFFFFFFF) )
      {
        InterlockedDecrement((volatile LONG *)lpAddend);
      }
      v5 = __w32_sharedptr;
      v4 = _CRT_MT;
    }
    a2[5] = *(_DWORD *)(v5 + 12);
    *(_DWORD *)(v5 + 12) = a2;
    v7 = v5 + 20;
    if ( v4 )
    {
      if ( InterlockedDecrement((volatile LONG *)(v5 + 20)) >= 0 )
        ReleaseSemaphore(*(HANDLE *)(v7 + 4), 1, 0);
    }
  }
}
// 405090: using guessed type int _CRT_MT;
// 4050B0: using guessed type int __w32_sharedptr;

//----- (00401840) --------------------------------------------------------
void __cdecl __register_frame_info(_DWORD *a1, _DWORD *a2)
{
  __register_frame_info_bases(a1, a2, 0, 0);
}

//----- (00401870) --------------------------------------------------------
void __cdecl __register_frame(_DWORD *a1)
{
  _DWORD *v1; // eax

  if ( *a1 )
  {
    v1 = malloc(0x18u);
    __register_frame_info(a1, v1);
  }
}

//----- (004018B0) --------------------------------------------------------
LONG __cdecl __register_frame_info_table_bases(int a1, _DWORD *a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // edx
  int v6; // esi
  LONG result; // eax
  int lpAddend; // ebx
  int v9; // edx
  bool v10; // zf

  *a2 = -1;
  a2[1] = a3;
  a2[2] = a4;
  a2[4] = 0;
  *((_BYTE *)a2 + 16) |= 2u;
  a2[3] = a1;
  *((_WORD *)a2 + 8) |= 0x7F8u;
  init_object_mutex_once();
  v4 = _CRT_MT;
  v5 = __w32_sharedptr;
  v6 = __w32_sharedptr + 20;
  if ( !_CRT_MT )
  {
    result = *(_DWORD *)(__w32_sharedptr + 12);
    a2[5] = result;
    *(_DWORD *)(v5 + 12) = a2;
    lpAddend = v5 + 20;
    if ( !v4 )
      return result;
    goto LABEL_6;
  }
  if ( InterlockedIncrement((volatile LONG *)(__w32_sharedptr + 20))
    && WaitForSingleObject(*(HANDLE *)(v6 + 4), 0xFFFFFFFF) )
  {
    InterlockedDecrement((volatile LONG *)v6);
  }
  v9 = __w32_sharedptr;
  result = *(_DWORD *)(__w32_sharedptr + 12);
  v10 = _CRT_MT == 0;
  a2[5] = result;
  *(_DWORD *)(v9 + 12) = a2;
  lpAddend = v9 + 20;
  if ( !v10 )
  {
LABEL_6:
    result = InterlockedDecrement((volatile LONG *)lpAddend);
    if ( result >= 0 )
      result = ReleaseSemaphore(*(HANDLE *)(lpAddend + 4), 1, 0);
  }
  return result;
}
// 405090: using guessed type int _CRT_MT;
// 4050B0: using guessed type int __w32_sharedptr;

//----- (004019B0) --------------------------------------------------------
LONG __cdecl __register_frame_info_table(int a1, _DWORD *a2)
{
  return __register_frame_info_table_bases(a1, a2, 0, 0);
}

//----- (004019E0) --------------------------------------------------------
LONG __cdecl __register_frame_table(int a1)
{
  _DWORD *v1; // eax

  v1 = malloc(0x18u);
  return __register_frame_info_table(a1, v1);
}

//----- (00401A10) --------------------------------------------------------
int __cdecl __deregister_frame_info_bases(_DWORD *a1)
{
  int v2; // esi
  int v3; // edi
  int v4; // ecx
  int v5; // eax
  bool v6; // zf
  int v7; // edx
  int v8; // ebx
  int lpAddend; // esi

  if ( !a1 || !*a1 )
    return 0;
  init_object_mutex_once();
  v2 = __w32_sharedptr;
  v3 = __w32_sharedptr + 20;
  if ( _CRT_MT )
  {
    if ( InterlockedIncrement((volatile LONG *)(__w32_sharedptr + 20))
      && WaitForSingleObject(*(HANDLE *)(v3 + 4), 0xFFFFFFFF) )
    {
      InterlockedDecrement((volatile LONG *)v3);
    }
    v2 = __w32_sharedptr;
  }
  v4 = v2 + 12;
  if ( !*(_DWORD *)(v2 + 12) )
  {
LABEL_8:
    v6 = *(_DWORD *)(v2 + 16) == 0;
    v4 = v2 + 16;
    while ( 1 )
    {
      if ( v6 )
      {
        if ( _CRT_MT && InterlockedDecrement((volatile LONG *)(v2 + 20)) >= 0 )
        {
          ReleaseSemaphore(*(HANDLE *)(v2 + 24), 1, 0);
          abort();
        }
        abort();
      }
      v7 = *(_DWORD *)v4;
      if ( (*(_BYTE *)(*(_DWORD *)v4 + 16) & 1) != 0 )
      {
        if ( **(_DWORD ***)(v7 + 12) == a1 )
        {
          v8 = *(_DWORD *)v4;
          *(_DWORD *)v4 = *(_DWORD *)(v7 + 20);
          free(*(void **)(v8 + 12));
          v2 = __w32_sharedptr;
          goto LABEL_16;
        }
      }
      else if ( *(_DWORD **)(v7 + 12) == a1 )
      {
        v8 = *(_DWORD *)v4;
        goto LABEL_15;
      }
      v4 = v7 + 20;
      v6 = *(_DWORD *)(v7 + 20) == 0;
    }
  }
  while ( 1 )
  {
    v5 = *(_DWORD *)v4;
    if ( *(_DWORD **)(*(_DWORD *)v4 + 12) == a1 )
      break;
    v4 = v5 + 20;
    if ( !*(_DWORD *)(v5 + 20) )
      goto LABEL_8;
  }
  v8 = *(_DWORD *)v4;
LABEL_15:
  *(_DWORD *)v4 = *(_DWORD *)(v8 + 20);
LABEL_16:
  lpAddend = v2 + 20;
  if ( !_CRT_MT || InterlockedDecrement((volatile LONG *)lpAddend) < 0 )
    return v8;
  ReleaseSemaphore(*(HANDLE *)(lpAddend + 4), 1, 0);
  return v8;
}
// 405090: using guessed type int _CRT_MT;
// 4050B0: using guessed type int __w32_sharedptr;

//----- (00401BA0) --------------------------------------------------------
int __cdecl __deregister_frame_info(_DWORD *a1)
{
  return __deregister_frame_info_bases(a1);
}

//----- (00401BB0) --------------------------------------------------------
void __cdecl __deregister_frame(_DWORD *a1)
{
  void *v1; // eax

  if ( *a1 )
  {
    v1 = (void *)__deregister_frame_info(a1);
    free(v1);
  }
}

//----- (00401BE0) --------------------------------------------------------
int __usercall base_from_object@<eax>(char a1@<al>, int a2@<edx>)
{
  int v2; // ecx
  int v3; // eax
  bool v4; // zf

  v2 = 0;
  if ( a1 == -1 )
    return v2;
  v3 = a1 & 0x70;
  if ( v3 == 32 )
    return *(_DWORD *)(a2 + 4);
  if ( v3 > 32 )
  {
    if ( v3 != 48 )
    {
      v4 = v3 == 80;
LABEL_8:
      if ( !v4 )
        abort();
      return 0;
    }
    return *(_DWORD *)(a2 + 8);
  }
  if ( v3 )
  {
    v4 = v3 == 16;
    goto LABEL_8;
  }
  return 0;
}

//----- (00401C40) --------------------------------------------------------
int __usercall get_cie_encoding@<eax>(int a1@<eax>)
{
  const char *Str; // ebx
  int result; // eax
  size_t v4; // eax
  char *v5; // eax
  char *v6; // ebx
  char *v7; // eax
  char *i; // ecx
  char v9; // al
  int v10; // [esp+14h] [ebp-14h] BYREF
  int v11; // [esp+18h] [ebp-10h] BYREF
  _DWORD v12[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Str = (const char *)(a1 + 9);
  result = 0;
  if ( *(_BYTE *)(a1 + 9) == 122 )
  {
    v4 = strlen(Str);
    v5 = read_uleb128((char *)&Str[v4 + 1], v12);
    v6 = (char *)(a1 + 10);
    v7 = read_sleb128(v5, &v11);
    for ( i = read_uleb128(v7 + 1, v12); ; ++i )
    {
      while ( 1 )
      {
        v9 = *v6;
        if ( *v6 == 82 )
          return (unsigned __int8)*i;
        if ( v9 != 80 )
          break;
        ++v6;
        i = read_encoded_value_with_base(*i & 0x7F, 0, i + 1, &v10);
      }
      if ( v9 != 76 )
        break;
      ++v6;
    }
    result = 0;
  }
  return result;
}

//----- (00401CD0) --------------------------------------------------------
int __cdecl fde_unencoded_compare(int a1, int a2, int a3)
{
  int v3; // ecx
  unsigned int v4; // edx

  v3 = 1;
  v4 = *(_DWORD *)(a3 + 8);
  if ( *(_DWORD *)(a2 + 8) <= v4 )
    v3 = -(*(_DWORD *)(a2 + 8) < v4);
  return v3;
}

//----- (00401CF0) --------------------------------------------------------
int __cdecl fde_single_encoding_compare(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // edx
  unsigned int v6; // [esp+8h] [ebp-10h] BYREF
  unsigned int v7[3]; // [esp+Ch] [ebp-Ch] BYREF

  v3 = base_from_object(*(unsigned __int16 *)(a1 + 16) >> 3, a1);
  read_encoded_value_with_base(*(unsigned __int16 *)(a1 + 16) >> 3, v3, (char *)(a2 + 8), (int *)v7);
  read_encoded_value_with_base(*(unsigned __int16 *)(a1 + 16) >> 3, v3, (char *)(a3 + 8), (int *)&v6);
  v4 = 1;
  if ( v7[0] <= v6 )
    v4 = -(v7[0] < v6);
  return v4;
}

//----- (00401D70) --------------------------------------------------------
int __cdecl fde_mixed_encoding_compare(int a1, int a2, int a3)
{
  char v3; // bl
  int v4; // eax
  char v5; // bl
  int v6; // eax
  int v7; // edx
  unsigned int v9; // [esp+14h] [ebp-14h] BYREF
  unsigned int v10[4]; // [esp+18h] [ebp-10h] BYREF

  v3 = get_cie_encoding(a2 - *(_DWORD *)(a2 + 4) + 4);
  v4 = base_from_object(v3, a1);
  read_encoded_value_with_base(v3, v4, (char *)(a2 + 8), (int *)v10);
  v5 = get_cie_encoding(a3 - *(_DWORD *)(a3 + 4) + 4);
  v6 = base_from_object(v5, a1);
  read_encoded_value_with_base(v5, v6, (char *)(a3 + 8), (int *)&v9);
  v7 = 1;
  if ( v10[0] <= v9 )
    v7 = -(v10[0] < v9);
  return v7;
}

//----- (00401E00) --------------------------------------------------------
int __usercall frame_downheap@<eax>(int result@<eax>, int (__cdecl *a2)(int, _DWORD, _DWORD)@<edx>, int a3, int a4, int a5)
{
  int v5; // edi
  int i; // ebx
  int v7; // edx
  int v9; // [esp+18h] [ebp-10h]

  v5 = a4;
  v9 = result;
  for ( i = 2 * a4 + 1; i < a5; i = 2 * i + 1 )
  {
    if ( i + 1 < a5 && a2(v9, *(_DWORD *)(a3 + 4 * i), *(_DWORD *)(a3 + 4 * i + 4)) < 0 )
      ++i;
    result = a2(v9, *(_DWORD *)(a3 + 4 * v5), *(_DWORD *)(a3 + 4 * i));
    if ( result >= 0 )
      break;
    v7 = *(_DWORD *)(a3 + 4 * v5);
    result = *(_DWORD *)(a3 + 4 * i);
    *(_DWORD *)(a3 + 4 * v5) = result;
    v5 = i;
    *(_DWORD *)(a3 + 4 * i) = v7;
  }
  return result;
}

//----- (00401E90) --------------------------------------------------------
unsigned int __usercall frame_heapsort@<eax>(int a1@<eax>, int (__cdecl *a2)(int, _DWORD, _DWORD)@<edx>, int a3)
{
  unsigned int v3; // edi
  int *v4; // esi
  unsigned int result; // eax
  int i; // ebx
  int j; // ebx
  int v8; // edx
  int v9; // [esp+8h] [ebp-20h]

  v3 = *(_DWORD *)(a3 + 4);
  v4 = (int *)(a3 + 8);
  result = v3 >> 1;
  for ( i = v3 >> 1; --i >= 0; result = frame_downheap(a1, a2, (int)v4, i, v3) )
    ;
  for ( j = v3 - 1; j > 0; --j )
  {
    v8 = *v4;
    *v4 = v4[j];
    v4[j] = v8;
    v9 = j;
    result = frame_downheap(a1, a2, (int)v4, 0, v9);
  }
  return result;
}

//----- (00401F00) --------------------------------------------------------
int __usercall classify_object_over_fdes@<eax>(int a1@<eax>, char *a2@<edx>)
{
  char *v3; // esi
  bool v4; // zf
  int v5; // eax
  int v6; // eax
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // eax
  unsigned int v10; // eax
  int v11; // eax
  int v13; // [esp+8h] [ebp-20h]
  int v14; // [esp+Ch] [ebp-1Ch]
  int v15; // [esp+10h] [ebp-18h]
  int v16; // [esp+14h] [ebp-14h]
  unsigned int v17[4]; // [esp+18h] [ebp-10h] BYREF

  v3 = a2;
  v4 = *(_DWORD *)a2 == 0;
  v16 = 0;
  v15 = 0;
  LOBYTE(v14) = 0;
  v13 = 0;
  while ( !v4 )
  {
    v5 = *((_DWORD *)v3 + 1);
    if ( v5 )
    {
      v6 = (int)&v3[-v5 + 4];
      if ( v6 != v16 )
      {
        v16 = v6;
        v14 = get_cie_encoding(v6);
        v7 = base_from_object(v14, a1);
        v8 = *(unsigned __int16 *)(a1 + 16);
        v13 = v7;
        v9 = (unsigned __int8)(v8 >> 3);
        if ( v9 == 255 )
        {
          *(_WORD *)(a1 + 16) = (8 * (unsigned __int8)v14) | v8 & 0xF807;
        }
        else if ( v9 != v14 )
        {
          *(_BYTE *)(a1 + 16) |= 4u;
        }
      }
      read_encoded_value_with_base(v14, v13, v3 + 8, (int *)v17);
      v10 = size_of_encoded_value(v14);
      if ( v10 > 3 )
        v11 = -1;
      else
        v11 = (1 << (8 * v10)) - 1;
      if ( (v17[0] & v11) != 0 )
      {
        ++v15;
        if ( *(_DWORD *)a1 > v17[0] )
          *(_DWORD *)a1 = v17[0];
      }
    }
    v3 += *(_DWORD *)v3 + 4;
    v4 = *(_DWORD *)v3 == 0;
  }
  return v15;
}

//----- (00402020) --------------------------------------------------------
int __usercall add_fdes@<eax>(int a1@<eax>, int *a2@<edx>, char *a3)
{
  char *v3; // esi
  int v4; // eax
  int v5; // edi
  int result; // eax
  bool v7; // zf
  int v8; // eax
  int v9; // eax
  bool v10; // zf
  int v11; // edx
  int v12; // eax
  unsigned int v13; // eax
  int v14; // [esp+8h] [ebp-20h]
  int v15; // [esp+Ch] [ebp-1Ch]
  int v18[4]; // [esp+18h] [ebp-10h] BYREF

  v3 = a3;
  v15 = 0;
  v4 = *(unsigned __int16 *)(a1 + 16) >> 3;
  v5 = (unsigned __int8)v4;
  result = base_from_object(v4, a1);
  v7 = *(_DWORD *)a3 == 0;
  v14 = result;
  while ( !v7 )
  {
    v8 = *((_DWORD *)v3 + 1);
    if ( v8 )
    {
      if ( (*(_BYTE *)(a1 + 16) & 4) != 0 )
      {
        v9 = (int)&v3[-v8 + 4];
        if ( v9 != v15 )
        {
          v15 = v9;
          v5 = get_cie_encoding(v9);
          v14 = base_from_object(v5, a1);
        }
      }
      if ( v5 )
      {
        read_encoded_value_with_base(v5, v14, v3 + 8, v18);
        v13 = size_of_encoded_value(v5);
        if ( v13 > 3 )
          v10 = v18[0] == 0;
        else
          v10 = (((1 << (8 * v13)) - 1) & v18[0]) == 0;
      }
      else
      {
        v10 = *((_DWORD *)v3 + 2) == 0;
      }
      if ( !v10 )
      {
        v11 = *a2;
        if ( *a2 )
        {
          v12 = *(_DWORD *)(v11 + 4);
          *(_DWORD *)(v11 + 4 * v12 + 8) = v3;
          *(_DWORD *)(v11 + 4) = v12 + 1;
        }
      }
    }
    v3 += *(_DWORD *)v3 + 4;
    result = *(_DWORD *)v3;
    v7 = *(_DWORD *)v3 == 0;
  }
  return result;
}

//----- (00402120) --------------------------------------------------------
int __usercall linear_search_fdes@<eax>(int a1@<eax>, int a2@<edx>, int a3)
{
  int v4; // eax
  int v5; // edi
  int v6; // eax
  bool v7; // zf
  int v8; // eax
  int v9; // eax
  int v10; // edx
  unsigned int v11; // ecx
  char *v13; // eax
  unsigned int v14; // eax
  int v15; // eax
  int v16; // [esp+8h] [ebp-20h]
  int v17; // [esp+Ch] [ebp-1Ch]
  unsigned int v19; // [esp+14h] [ebp-14h] BYREF
  int v20[4]; // [esp+18h] [ebp-10h] BYREF

  v17 = 0;
  v4 = *(unsigned __int16 *)(a1 + 16) >> 3;
  v5 = (unsigned __int8)v4;
  v6 = base_from_object(v4, a1);
  v7 = *(_DWORD *)a2 == 0;
  v16 = v6;
  while ( !v7 )
  {
    v8 = *(_DWORD *)(a2 + 4);
    if ( !v8 )
      goto LABEL_2;
    if ( (*(_BYTE *)(a1 + 16) & 4) != 0 )
    {
      v9 = a2 - v8 + 4;
      if ( v9 != v17 )
      {
        v17 = v9;
        v5 = get_cie_encoding(v9);
        v16 = base_from_object(v5, a1);
      }
    }
    if ( v5 )
    {
      v13 = read_encoded_value_with_base(v5, v16, (char *)(a2 + 8), v20);
      read_encoded_value_with_base(v5 & 0xF, 0, v13, (int *)&v19);
      v14 = size_of_encoded_value(v5);
      if ( v14 > 3 )
        v15 = -1;
      else
        v15 = (1 << (8 * v14)) - 1;
      v10 = v20[0];
      if ( (v20[0] & v15) == 0 )
        goto LABEL_2;
      v11 = v19;
    }
    else
    {
      v20[0] = *(_DWORD *)(a2 + 8);
      v10 = v20[0];
      v11 = *(_DWORD *)(a2 + 12);
      v19 = v11;
      if ( !v20[0] )
        goto LABEL_2;
    }
    if ( a3 - v10 < v11 )
      return a2;
LABEL_2:
    a2 += *(_DWORD *)a2 + 4;
    v7 = *(_DWORD *)a2 == 0;
  }
  return 0;
}

//----- (00402240) --------------------------------------------------------
int __usercall search_object@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  char v2; // dl
  int result; // eax
  unsigned int v4; // esi
  int v5; // edi
  char v6; // bl
  int v7; // eax
  char *v8; // eax
  int *k; // ebx
  char **i; // ebx
  char *v11; // edx
  unsigned int v12; // edx
  char *v13; // eax
  _DWORD *v14; // eax
  char **v15; // ebx
  char *j; // eax
  unsigned int v17; // ebx
  int v18; // eax
  char *v19; // edi
  char *v20; // esi
  int v21; // eax
  unsigned int v22; // eax
  unsigned int v23; // edx
  unsigned int v24; // edi
  bool v25; // cf
  unsigned int v26; // ecx
  int v27; // ebx
  unsigned int v28; // eax
  char v29; // bl
  unsigned int v30; // esi
  unsigned int v31; // ebx
  char *v32; // eax
  int v33; // ecx
  int v34; // edx
  unsigned int v35; // ebx
  int v36; // eax
  char *v37; // esi
  int v38; // edi
  int v39; // ebx
  int v40; // eax
  int v41; // edx
  int v42; // ecx
  char *v43; // edx
  _DWORD *Block; // [esp+14h] [ebp-74h]
  _DWORD *Blocka; // [esp+14h] [ebp-74h]
  char *v46; // [esp+18h] [ebp-70h]
  char v47; // [esp+1Ch] [ebp-6Ch]
  char v48; // [esp+20h] [ebp-68h]
  unsigned int v49; // [esp+24h] [ebp-64h]
  int v50; // [esp+28h] [ebp-60h]
  int v51; // [esp+2Ch] [ebp-5Ch]
  int v52; // [esp+30h] [ebp-58h]
  unsigned int v53; // [esp+34h] [ebp-54h]
  unsigned int v54; // [esp+38h] [ebp-50h]
  int v55; // [esp+3Ch] [ebp-4Ch]
  int v56; // [esp+40h] [ebp-48h]
  unsigned int v57; // [esp+44h] [ebp-44h]
  char *v58; // [esp+48h] [ebp-40h]
  int v59; // [esp+4Ch] [ebp-3Ch]
  int (__cdecl *v60)(int, int, int); // [esp+50h] [ebp-38h]
  int v61; // [esp+54h] [ebp-34h]
  int v64; // [esp+60h] [ebp-28h] BYREF
  unsigned int v65; // [esp+64h] [ebp-24h] BYREF
  int v66; // [esp+68h] [ebp-20h] BYREF
  unsigned int v67; // [esp+6Ch] [ebp-1Ch] BYREF
  char *v68; // [esp+70h] [ebp-18h] BYREF
  _DWORD *v69; // [esp+74h] [ebp-14h]

  v2 = *(_BYTE *)(a1 + 16);
  if ( (v2 & 1) != 0 )
    goto LABEL_6;
  v61 = *(_DWORD *)(a1 + 16) >> 11;
  if ( !v61 )
  {
    if ( (v2 & 2) != 0 )
    {
      for ( i = *(char ***)(a1 + 12); *i; v61 += classify_object_over_fdes(a1, v11) )
        v11 = *i++;
    }
    else
    {
      v61 = classify_object_over_fdes(a1, *(char **)(a1 + 12));
    }
    v12 = (v61 << 11) | *(_DWORD *)(a1 + 16) & 0x7FF;
    if ( v12 >> 11 != v61 )
    {
      *(_DWORD *)(a1 + 16) = v12 & 0x7FF;
      if ( !v61 )
        goto LABEL_4;
LABEL_25:
      v13 = (char *)malloc(4 * v61 + 8);
      v68 = v13;
      if ( !v13 )
        goto LABEL_4;
      *((_DWORD *)v13 + 1) = 0;
      v14 = malloc(4 * v61 + 8);
      v69 = v14;
      if ( v14 )
        v14[1] = 0;
      if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
      {
        v15 = *(char ***)(a1 + 12);
        for ( j = *v15; *v15; j = *v15 )
        {
          ++v15;
          add_fdes(a1, (int *)&v68, j);
        }
      }
      else
      {
        add_fdes(a1, (int *)&v68, *(char **)(a1 + 12));
      }
      if ( v68 && *((_DWORD *)v68 + 1) != v61 )
LABEL_63:
        abort();
      v60 = fde_mixed_encoding_compare;
      if ( (*(_BYTE *)(a1 + 16) & 4) == 0 )
      {
        v60 = fde_unencoded_compare;
        if ( (unsigned __int8)(*(unsigned __int16 *)(a1 + 16) >> 3) )
          v60 = fde_single_encoding_compare;
      }
      Block = v69;
      v59 = (int)v69;
      if ( v69 )
      {
        v17 = 0;
        v18 = __w32_sharedptr;
        v46 = v68;
        v19 = v68;
        v58 = v68;
        v20 = (char *)(__w32_sharedptr + 36);
        v57 = *((_DWORD *)v68 + 1);
        if ( v57 )
        {
          while ( 1 )
          {
            if ( (char *)(v18 + 36) == v20 || v60(a1, *(_DWORD *)&v46[4 * v17 + 8], *(_DWORD *)v20) >= 0 )
            {
              Block[v17++ + 2] = v20;
              v20 = v19 + 8;
              v19 += 4;
              if ( v17 >= v57 )
              {
                Block = v69;
                v46 = v68;
                break;
              }
            }
            else
            {
              v21 = v20 - v46;
              v20 = *(char **)((char *)Block + v20 - v46);
              *(_DWORD *)((char *)Block + v21) = 0;
            }
            v18 = __w32_sharedptr;
          }
        }
        v33 = 0;
        v34 = 0;
        v35 = 0;
        while ( v35 < v57 )
        {
          v36 = *(_DWORD *)&v58[4 * v35 + 8];
          if ( *(_DWORD *)(v59 + 4 * v35 + 8) )
          {
            ++v35;
            *(_DWORD *)&v58[4 * v34++ + 8] = v36;
          }
          else
          {
            ++v35;
            *(_DWORD *)(v59 + 4 * v33++ + 8) = v36;
          }
        }
        *((_DWORD *)v58 + 1) = v34;
        *(_DWORD *)(v59 + 4) = v33;
        if ( *((_DWORD *)v46 + 1) + Block[1] != v61 )
          goto LABEL_63;
        frame_heapsort(a1, v60, (int)Block);
        v37 = v68;
        v38 = v69[1];
        Blocka = v69;
        if ( v38 )
        {
          v39 = *((_DWORD *)v68 + 1);
          do
          {
            v56 = Blocka[--v38 + 2];
            while ( v39 && v60(a1, *(_DWORD *)&v37[4 * v39 + 4], v56) > 0 )
            {
              v40 = *(_DWORD *)&v37[4 * v39 + 4];
              v41 = v39 + v38;
              --v39;
              *(_DWORD *)&v37[4 * v41 + 8] = v40;
            }
            *(_DWORD *)&v37[4 * v39 + 8 + 4 * v38] = v56;
          }
          while ( v38 );
          v42 = (int)v69;
          *((_DWORD *)v37 + 1) += Blocka[1];
          Blocka = (_DWORD *)v42;
        }
        free(Blocka);
      }
      else
      {
        frame_heapsort(a1, v60, (int)v68);
      }
      v43 = v68;
      *(_DWORD *)v68 = *(_DWORD *)(a1 + 12);
      *(_BYTE *)(a1 + 16) |= 1u;
      *(_DWORD *)(a1 + 12) = v43;
      goto LABEL_4;
    }
    *(_DWORD *)(a1 + 16) = v12;
  }
  if ( v61 )
    goto LABEL_25;
LABEL_4:
  result = 0;
  if ( *(_DWORD *)a1 > a2 )
    return result;
  v2 = *(_BYTE *)(a1 + 16);
LABEL_6:
  if ( (v2 & 1) != 0 )
  {
    if ( (v2 & 4) != 0 )
    {
      v54 = 0;
      v55 = *(_DWORD *)(a1 + 12);
      v53 = *(_DWORD *)(v55 + 4);
      if ( v53 )
      {
        do
        {
          v4 = (v53 + v54) >> 1;
          v5 = *(_DWORD *)(v55 + 4 * v4 + 8);
          v6 = get_cie_encoding(v5 - *(_DWORD *)(v5 + 4) + 4);
          v7 = base_from_object(v6, a1);
          v8 = read_encoded_value_with_base(v6, v7, (char *)(v5 + 8), (int *)&v67);
          read_encoded_value_with_base(v6 & 0xF, 0, v8, &v66);
          if ( a2 >= v67 )
          {
            if ( a2 < v66 + v67 )
              return v5;
            v54 = v4 + 1;
            v4 = v53;
          }
          else
          {
            v53 = (v53 + v54) >> 1;
          }
        }
        while ( v54 < v4 );
      }
    }
    else
    {
      v22 = (unsigned __int8)(*(unsigned __int16 *)(a1 + 16) >> 3);
      if ( (unsigned __int8)(*(unsigned __int16 *)(a1 + 16) >> 3) )
      {
        v29 = *(unsigned __int16 *)(a1 + 16) >> 3;
        v51 = *(_DWORD *)(a1 + 12);
        v49 = 0;
        v50 = base_from_object(v22, a1);
        v30 = *(_DWORD *)(v51 + 4);
        if ( v30 )
        {
          v48 = v29;
          v47 = v29 & 0xF;
          do
          {
            v31 = (v30 + v49) >> 1;
            v5 = *(_DWORD *)(v51 + 4 * v31 + 8);
            v32 = read_encoded_value_with_base(v48, v50, (char *)(v5 + 8), (int *)&v65);
            read_encoded_value_with_base(v47, 0, v32, &v64);
            if ( a2 < v65 )
            {
              v30 = (v30 + v49) >> 1;
            }
            else
            {
              if ( a2 < v64 + v65 )
                return v5;
              v49 = v31 + 1;
            }
          }
          while ( v49 < v30 );
        }
      }
      else
      {
        v23 = 0;
        v24 = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4);
        v52 = *(_DWORD *)(a1 + 12);
        v25 = v22 < v24;
        while ( v25 )
        {
          v26 = (v23 + v24) >> 1;
          v27 = *(_DWORD *)(v52 + 4 * v26 + 8);
          v28 = *(_DWORD *)(v27 + 8);
          if ( a2 >= v28 )
          {
            if ( *(_DWORD *)(v27 + 12) + v28 > a2 )
              return *(_DWORD *)(v52 + 4 * v26 + 8);
            v23 = v26 + 1;
            v25 = v26 + 1 < v24;
          }
          else
          {
            v24 = (v23 + v24) >> 1;
            v25 = v23 < v26;
          }
        }
      }
    }
  }
  else
  {
    if ( (v2 & 2) == 0 )
      return linear_search_fdes(a1, *(_DWORD *)(a1 + 12), a2);
    for ( k = *(int **)(a1 + 12); *k; ++k )
    {
      result = linear_search_fdes(a1, *k, a2);
      if ( result )
        return result;
    }
  }
  return 0;
}
// 4050B0: using guessed type int __w32_sharedptr;

//----- (004027C0) --------------------------------------------------------
int __cdecl _Unwind_Find_FDE(unsigned int a1, _DWORD *a2)
{
  int v2; // edi
  int v3; // ebx
  int v4; // esi
  int i; // esi
  int v6; // eax
  int *v7; // edx
  _DWORD *v8; // eax
  int lpAddend; // ebx
  char v10; // al
  char v11; // bl
  int v12; // eax

  v2 = 0;
  init_object_mutex_once();
  v3 = __w32_sharedptr;
  v4 = __w32_sharedptr + 20;
  if ( _CRT_MT )
  {
    if ( InterlockedIncrement((volatile LONG *)(__w32_sharedptr + 20))
      && WaitForSingleObject(*(HANDLE *)(v4 + 4), 0xFFFFFFFF) )
    {
      InterlockedDecrement((volatile LONG *)v4);
    }
    v3 = __w32_sharedptr;
  }
  for ( i = *(_DWORD *)(v3 + 16); ; i = *(_DWORD *)(i + 20) )
  {
    if ( !i )
      goto LABEL_6;
    if ( *(_DWORD *)i <= a1 )
      break;
  }
  v2 = search_object(i, a1);
  if ( v2 )
  {
    v3 = __w32_sharedptr;
  }
  else
  {
    v3 = __w32_sharedptr;
LABEL_6:
    while ( 1 )
    {
      i = *(_DWORD *)(v3 + 12);
      if ( !i )
        break;
      *(_DWORD *)(v3 + 12) = *(_DWORD *)(i + 20);
      v6 = search_object(i, a1);
      v3 = __w32_sharedptr;
      v2 = v6;
      v7 = (int *)(__w32_sharedptr + 16);
      if ( *(_DWORD *)(__w32_sharedptr + 16) )
      {
        while ( 1 )
        {
          v8 = (_DWORD *)*v7;
          if ( *(_DWORD *)*v7 < *(_DWORD *)i )
            break;
          v7 = v8 + 5;
          if ( !v8[5] )
          {
            *(_DWORD *)(i + 20) = 0;
            *v7 = i;
            if ( !v2 )
              goto LABEL_6;
            goto LABEL_11;
          }
        }
      }
      else
      {
        v8 = (_DWORD *)*v7;
      }
      *(_DWORD *)(i + 20) = v8;
      *v7 = i;
      if ( v2 )
      {
        lpAddend = v3 + 20;
        if ( !_CRT_MT )
          goto LABEL_12;
        goto LABEL_22;
      }
    }
  }
LABEL_11:
  lpAddend = v3 + 20;
  if ( _CRT_MT )
  {
LABEL_22:
    if ( InterlockedDecrement((volatile LONG *)lpAddend) >= 0 )
      ReleaseSemaphore(*(HANDLE *)(lpAddend + 4), 1, 0);
  }
LABEL_12:
  if ( v2 )
  {
    *a2 = *(_DWORD *)(i + 4);
    a2[1] = *(_DWORD *)(i + 8);
    v10 = *(unsigned __int16 *)(i + 16) >> 3;
    if ( (*(_BYTE *)(i + 16) & 4) != 0 )
      v10 = get_cie_encoding(v2 - *(_DWORD *)(v2 + 4) + 4);
    v11 = v10;
    v12 = base_from_object(v10, i);
    read_encoded_value_with_base(v11, v12, (char *)(v2 + 8), a2 + 2);
  }
  return v2;
}
// 405090: using guessed type int _CRT_MT;
// 4050B0: using guessed type int __w32_sharedptr;

//----- (004029A0) --------------------------------------------------------
int __w32_sharedptr_default_unexpected()
{
  return (*(int (**)(void))(__w32_sharedptr + 4))();
}
// 4050B0: using guessed type int __w32_sharedptr;

//----- (004029B0) --------------------------------------------------------
unsigned int __usercall __w32_sharedptr_get@<eax>(ATOM nAtom@<ax>)
{
  unsigned int v1; // ebx
  UINT v2; // eax
  int v3; // edx
  int v4; // ecx
  CHAR Buffer[68]; // [esp+10h] [ebp-48h] BYREF

  v1 = 0;
  v2 = GetAtomNameA(nAtom, Buffer, 61);
  v3 = 31;
  v4 = 1;
  if ( !v2 )
    _assert(
      "../../gcc-3.4.5-20060117-1/gcc/config/i386/w32-shared-ptr.c",
      "GetAtomNameA (atom, s, sizeof(s)) != 0",
      "../../gcc-3.4.5-20060117-1/gcc/config/i386/w32-shared-ptr.c",
      241);
  do
  {
    while ( Buffer[v3] != 65 )
    {
      v4 *= 2;
      if ( --v3 < 0 )
        goto LABEL_6;
    }
    v1 |= v4;
    v4 *= 2;
    --v3;
  }
  while ( v3 >= 0 );
LABEL_6:
  if ( *(_DWORD *)v1 != 64 )
    _assert(
      v4,
      "w32_sharedptr->size == sizeof(W32_EH_SHARED)",
      "../../gcc-3.4.5-20060117-1/gcc/config/i386/w32-shared-ptr.c",
      247);
  return v1;
}
// 402D80: using guessed type int __thiscall _assert(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00402A50) --------------------------------------------------------
void __w32_sharedptr_initialize()
{
  ATOM v0; // ax
  _DWORD *v1; // eax
  unsigned int v2; // ebx
  int v3; // ecx
  int v4; // eax
  int v5; // edx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v11; // eax
  int v12; // edx
  char v13; // al
  ATOM v14; // ax
  int v15; // edi
  int v16; // edx
  unsigned int v17; // eax
  int v18; // [esp+1Ch] [ebp-9Ch]
  CHAR lpString[32]; // [esp+20h] [ebp-98h] BYREF
  char v20[32]; // [esp+40h] [ebp-78h] BYREF
  CHAR String[88]; // [esp+60h] [ebp-58h] BYREF

  if ( !__w32_sharedptr )
  {
    strcpy(String, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-LIBGCCW32-EH-3-GTHR-MINGW32");
    v0 = FindAtomA(String);
    v18 = v0;
    if ( !v0 )
    {
      v1 = malloc(0x40u);
      v2 = (unsigned int)v1;
      if ( !v1 )
        abort();
      memset32(v1, v18, 0x10u);
      v1[1] = abort;
      v3 = 1;
      v1[2] = __w32_sharedptr_default_unexpected;
      v4 = dw2_object_mutex_0;
      *(_DWORD *)v2 = 64;
      v5 = dword_405064;
      *(_DWORD *)(v2 + 20) = v4;
      v6 = dw2_once_1;
      *(_DWORD *)(v2 + 24) = v5;
      v7 = dword_403034;
      *(_DWORD *)(v2 + 28) = v6;
      v8 = eh_globals_static_2;
      *(_DWORD *)(v2 + 32) = v7;
      v9 = dword_405074;
      *(_DWORD *)(v2 + 40) = v8;
      v10 = eh_globals_key_3;
      *(_DWORD *)(v2 + 48) = -1;
      *(_DWORD *)(v2 + 44) = v9;
      *(_DWORD *)(v2 + 52) = v10;
      v11 = eh_globals_once_4;
      *(_DWORD *)(v2 + 60) = dword_40303C;
      v12 = 31;
      *(_DWORD *)(v2 + 56) = v11;
      do
      {
        v13 = (v3 & v2) == 0 ? 0x20 : 0;
        v3 *= 2;
        lpString[v12--] = v13 + 65;
      }
      while ( v12 >= 0 );
      strcpy(v20, "-LIBGCCW32-EH-3-GTHR-MINGW32");
      v14 = AddAtomA(lpString);
      v15 = v14;
      if ( !v14 || (v17 = __w32_sharedptr_get(v14), v16 = v15, v17 != v2) )
        v16 = 0;
      if ( v16 )
        goto LABEL_11;
      free((void *)v2);
      v0 = FindAtomA(String);
    }
    v2 = __w32_sharedptr_get(v0);
LABEL_11:
    __w32_sharedptr = v2;
    __w32_sharedptr_terminate = v2 + 4;
    __w32_sharedptr_unexpected = v2 + 8;
  }
}
// 403030: using guessed type int dw2_once_1;
// 403034: using guessed type int dword_403034;
// 403038: using guessed type int eh_globals_once_4;
// 40303C: using guessed type int dword_40303C;
// 405060: using guessed type int dw2_object_mutex_0;
// 405064: using guessed type int dword_405064;
// 405070: using guessed type int eh_globals_static_2;
// 405074: using guessed type int dword_405074;
// 405080: using guessed type int eh_globals_key_3;
// 4050A0: using guessed type int __w32_sharedptr_terminate;
// 4050B0: using guessed type int __w32_sharedptr;
// 4050C0: using guessed type int __w32_sharedptr_unexpected;

//----- (00402E40) --------------------------------------------------------
void __reg_frame_ctor()
{
  __do_frame_init();
}

//----- (00402E50) --------------------------------------------------------
int __dereg_frame_dtor()
{
  return __do_frame_fini();
}

// nfuncs=73 queued=45 decompiled=45 lumina nreq=0 worse=0 better=0
// ALL OK, 45 function(s) have been successfully decompiled
