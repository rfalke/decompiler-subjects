/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
void __noreturn sub_401140(); // weak
int __cdecl sub_4012A0(void (__cdecl *a1)());
void sub_4012C0();
int sub_4012F0();
int __cdecl sub_401310(int a1, int a2);
void __noreturn sub_401380();
int *__cdecl sub_40139E(char *Buffer, int a2);
void __cdecl __noreturn sub_401415(char *, int); // idb
void __cdecl __noreturn sub_4014D9(int a1, int a2, int a3);
int _pei386_runtime_relocator();
void sub_401580();
void __cdecl __do_global_dtors(); // idb
int __do_global_ctors();
int sub_401620();
// int __usercall sub_401640@<eax>(char a1@<al>);
// char *__usercall read_uleb128@<eax>(char *a1@<eax>, _DWORD *a2@<edx>);
// char *__usercall read_sleb128@<eax>(char *a1@<eax>, _DWORD *a2@<edx>);
// char *__usercall sub_401750@<eax>(char a1@<al>, int a2@<edx>, char *a3, int *a4);
HANDLE sub_401820();
HANDLE sub_401870();
void __cdecl sub_401900(_DWORD *a1, _DWORD *a2, int a3, int a4);
void __cdecl sub_4019F0(_DWORD *a1, _DWORD *a2);
LONG __cdecl sub_401A60(int a1, _DWORD *a2, int a3, int a4);
LONG __cdecl sub_401B60(int a1, _DWORD *a2);
int __cdecl sub_401BC0(_DWORD *a1);
int __cdecl sub_401D50(_DWORD *a1);
// int __usercall sub_401D90@<eax>(char a1@<al>, int a2@<edx>);
// int __usercall sub_401DF0@<eax>(int a1@<eax>);
int __cdecl sub_401E80(int a1, int a2, int a3);
int __cdecl sub_401EA0(int a1, int a2, int a3);
int __cdecl sub_401F20(int a1, int a2, int a3);
// int __usercall sub_401FB0@<eax>(int result@<eax>, int (__cdecl *a2)(int, _DWORD, _DWORD)@<edx>, int a3, int a4, int a5);
// unsigned int __usercall sub_402040@<eax>(int a1@<eax>, int (__cdecl *a2)(int, _DWORD, _DWORD)@<edx>, int a3);
// int __usercall sub_4020B0@<eax>(int a1@<eax>, char *a2@<edx>);
// int __usercall sub_4021D0@<eax>(int a1@<eax>, int *a2@<edx>, char *a3);
// int __usercall sub_4022D0@<eax>(int a1@<eax>, int a2@<edx>, int a3);
// int __usercall search_object@<eax>(int a1@<eax>, unsigned int a2@<edx>);
int sub_402B50();
// unsigned int __usercall sub_402B60@<eax>(ATOM nAtom@<ax>);
void __w32_sharedptr_initialize();
// int *__cdecl _p__fmode();
// int __cdecl _getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int scanf(const char *const Format, ...);
// size_t __cdecl strlen(const char *Str);
// int sscanf(const char *const Buffer, const char *const Format, ...);
// void __cdecl __noreturn exit(int Code);
// int printf(const char *const Format, ...);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// void __cdecl free(void *Block);
// void *__cdecl malloc(size_t Size);
// void __cdecl __noreturn abort();
// int __thiscall assert(_DWORD, _DWORD, _DWORD, _DWORD); weak
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// HANDLE __stdcall CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
// void __stdcall Sleep(DWORD dwMilliseconds);
// LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
// UINT __stdcall GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize);
// ATOM __stdcall AddAtomA(LPCSTR lpString);
// ATOM __stdcall FindAtomA(LPCSTR lpString);
void sub_403010();
int sub_403020();
// char ***__cdecl _p__environ();
// int __cdecl setmode(int FileHandle, int Mode);
// int __cdecl atexit(void (__cdecl *)());
// _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function);

//-------------------------------------------------------------------------
// Data declarations

int dword_403030[] = { -1 }; // weak
int (*off_403034)() = &sub_403010; // weak
int dword_404000 = -1; // weak
int dword_404010 = 16384; // weak
int (**off_404020)() = &off_403040; // weak
int dword_404030 = 0; // weak
int dword_404034 = -1; // weak
int dword_404038 = 0; // weak
int dword_40403C = -1; // weak
_DWORD dword_405160[108] =
{
  16,
  0,
  2080440321,
  67439624,
  392,
  24,
  24,
  4200480,
  66,
  -2079846847,
  67978242,
  230212,
  28,
  52,
  4200560,
  133,
  -2079846847,
  67977730,
  1308918598,
  902,
  28,
  84,
  4200704,
  237,
  -2079846847,
  67977730,
  1225032518,
  902,
  20,
  116,
  4200944,
  38,
  -2079846847,
  67978242,
  24,
  140,
  4200992,
  52,
  -2079846847,
  67977730,
  230212,
  28,
  168,
  4201056,
  251,
  -2079846847,
  67977730,
  -2046524603,
  3,
  20,
  200,
  4201312,
  38,
  -2079846847,
  67978242,
  20,
  224,
  4201360,
  35,
  -2079846847,
  67977730,
  28,
  248,
  4201408,
  387,
  -2079846847,
  67977730,
  -2046459066,
  231172,
  20,
  280,
  4201824,
  34,
  -2079846847,
  67977730,
  28,
  304,
  4202416,
  137,
  -2079846847,
  67977730,
  -2046459066,
  231172,
  28,
  336,
  4202560,
  111,
  -2079846847,
  67977730,
  -2046459066,
  231172,
  28,
  368,
  4203504,
  1405,
  -2079846847,
  67977730,
  -2046459066,
  231172,
  28,
  400,
  4204912,
  480,
  -2079846847,
  67977730,
  1191413569,
  75892099,
  0
}; // idb
_DWORD dword_405310[828] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  
}; // idb
int dword_406000; // weak
int dword_406004; // weak
_DWORD dword_406010[8]; // idb
int dword_406030; // weak
int Mode; // idb
int dword_406050; // weak
int dword_406070; // weak
int dword_406074; // weak
int dword_406080; // weak
int dword_406084; // weak
int dword_406090; // weak
int dword_4060A0; // weak
int dword_4060B0; // weak
int dword_4060C0; // weak
int dword_4060D0; // weak
// extern FILE iob[];


//----- (00401000) --------------------------------------------------------
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  int v1; // ebx
  int v2; // esi
  DWORD v3; // eax
  _crt_signal_t v4; // eax
  bool v6; // zf
  _crt_signal_t v7; // eax
  _crt_signal_t v8; // eax

  v1 = 0;
  v2 = 0;
  v3 = ExceptionInfo->ExceptionRecord->ExceptionCode;
  if ( v3 <= 0xC0000091 )
  {
    if ( v3 >= 0xC000008D )
    {
LABEL_3:
      v2 = 1;
      goto LABEL_4;
    }
    if ( v3 == -1073741819 )
    {
      v8 = signal(11, 0);
      if ( v8 == (_crt_signal_t)1 )
      {
        signal(11, (_crt_signal_t)1);
      }
      else
      {
        if ( !v8 )
          return v1;
        v8(11);
      }
      return -1;
    }
    v6 = v3 == -1073741795;
LABEL_15:
    if ( !v6 )
      return v1;
    v7 = signal(4, 0);
    if ( v7 == (_crt_signal_t)1 )
    {
      signal(4, (_crt_signal_t)1);
    }
    else
    {
      if ( !v7 )
        return v1;
      v7(4);
    }
    return -1;
  }
  if ( v3 == -1073741676 )
  {
LABEL_4:
    v4 = signal(8, 0);
    if ( v4 == (_crt_signal_t)1 )
    {
      signal(8, (_crt_signal_t)1);
      if ( v2 )
        sub_401580();
    }
    else
    {
      if ( !v4 )
        return v1;
      v4(8);
    }
    return -1;
  }
  if ( v3 > 0xC0000094 )
  {
    v6 = v3 == -1073741674;
    goto LABEL_15;
  }
  if ( v3 == -1073741677 )
    goto LABEL_3;
  return 0;
}

//----- (00401140) --------------------------------------------------------
void __noreturn sub_401140()
{
  char *v0; // edx
  int *v1; // eax
  char v2[4]; // [esp+1Ch] [ebp-Ch] BYREF
  int v3; // [esp+20h] [ebp-8h] BYREF

  SetUnhandledExceptionFilter(TopLevelExceptionFilter);
  sub_401580();
  v3 = 0;
  _getmainargs(&dword_406004, &dword_406000, v2, dword_404000, &v3);
  if ( Mode )
  {
    dword_404010 = Mode;
    v0 = iob[0]._ptr;
    if ( iob[0]._ptr )
    {
      setmode(iob[0]._file, Mode);
      v0 = iob[0]._ptr;
    }
    if ( v0 != (char *)-32 )
    {
      setmode(iob[1]._file, Mode);
      v0 = iob[0]._ptr;
    }
    if ( v0 != (char *)-64 )
      setmode(iob[2]._file, Mode);
  }
  *_p__fmode() = dword_404010;
  _pei386_runtime_relocator();
  v1 = (int *)_p__environ();
  sub_4014D9(dword_406004, dword_406000, *v1);
}
// 401140: using guessed type void __noreturn sub_401140();
// 402EB0: using guessed type int __cdecl _getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 404000: using guessed type int dword_404000;
// 404010: using guessed type int dword_404010;
// 406000: using guessed type int dword_406000;
// 406004: using guessed type int dword_406004;

//----- (004012A0) --------------------------------------------------------
int __cdecl sub_4012A0(void (__cdecl *a1)())
{
  return atexit(a1);
}

//----- (004012C0) --------------------------------------------------------
void sub_4012C0()
{
  __w32_sharedptr_initialize();
  sub_4019F0(dword_405160, dword_406010);
}

//----- (004012F0) --------------------------------------------------------
int sub_4012F0()
{
  return sub_401D50(dword_405160);
}

//----- (00401310) --------------------------------------------------------
int __cdecl sub_401310(int a1, int a2)
{
  int v2; // ecx
  int v5; // [esp+14h] [ebp-4h]

  v5 = 0;
  while ( *(_DWORD *)(4 * v5 + a2) )
  {
    v2 = 4 * v5++;
    if ( !strncmp(*(const char **)(v2 + a2), "LOLO", 3u) )
    {
      dword_406030 = 1;
      return 1;
    }
  }
  return 0;
}
// 406030: using guessed type int dword_406030;

//----- (00401380) --------------------------------------------------------
void __noreturn sub_401380()
{
  printf("Password Incorrect!\n");
  exit(0);
}

//----- (0040139E) --------------------------------------------------------
int *__cdecl sub_40139E(char *Buffer, int a2)
{
  int *result; // eax
  int i; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h] BYREF

  sscanf(Buffer, "%d", &v4);
  result = (int *)sub_401310(v4, a2);
  if ( result )
  {
    for ( i = 0; i <= 9; ++i )
    {
      if ( (v4 & 1) == 0 )
      {
        if ( dword_406030 == 1 )
          printf("Password OK!\n");
        exit(0);
      }
      result = &i;
    }
  }
  return result;
}
// 406030: using guessed type int dword_406030;

//----- (00401415) --------------------------------------------------------
void __cdecl __noreturn sub_401415(char *Str, int a2)
{
  size_t v2; // eax
  char Buffer; // [esp+1Bh] [ebp-Dh] BYREF
  unsigned int i; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h] BYREF

  v5 = 0;
  for ( i = 0; ; ++i )
  {
    v2 = strlen(Str);
    if ( i >= v2 )
      break;
    Buffer = Str[i];
    sscanf(&Buffer, "%d", &v6);
    v5 += v6;
    if ( v5 == 16 )
      sub_40139E(Str, a2);
  }
  sub_401380();
}

//----- (004014D9) --------------------------------------------------------
void __cdecl __noreturn sub_4014D9(int a1, int a2, int a3)
{
  void *v3; // esp
  char v4[120]; // [esp+20h] [ebp-78h] BYREF

  v3 = alloca(16);
  sub_401620();
  printf("IOLI Crackme Level 0x07\n");
  printf("Password: ");
  scanf("%s", v4);
  sub_401415(v4, a3);
}

//----- (00401550) --------------------------------------------------------
int _pei386_runtime_relocator()
{
  int *i; // ecx
  int v1; // edx
  int result; // eax

  for ( i = dword_405310; i < dword_405310; i += 2 )
  {
    v1 = i[1];
    result = *i;
    *(_DWORD *)(v1 + 0x400000) += result;
  }
  return result;
}

//----- (00401580) --------------------------------------------------------
void sub_401580()
{
  __asm { fninit }
}

//----- (00401590) --------------------------------------------------------
void __cdecl __do_global_dtors()
{
  int (**v0)(); // eax
  int (*v1)(); // edx

  v0 = off_404020;
  if ( *off_404020 )
  {
    do
    {
      (*v0)();
      v0 = off_404020 + 1;
      v1 = off_404020[1];
      ++off_404020;
    }
    while ( v1 );
  }
}
// 404020: using guessed type int (**off_404020)();

//----- (004015C0) --------------------------------------------------------
int __do_global_ctors()
{
  int j; // ebx
  int v2; // eax
  bool i; // zf

  v2 = 0;
  for ( i = sub_403010 == 0; !i; i = *(&off_403034 + v2) == 0 )
    ++v2;
  for ( j = v2; j; --j )
    ((void (*)(void))dword_403030[j])();
  return sub_4012A0(__do_global_dtors);
}
// 403030: using guessed type int dword_403030[];
// 403034: using guessed type int (*off_403034)();

//----- (00401620) --------------------------------------------------------
int sub_401620()
{
  int result; // eax

  result = dword_406050;
  if ( !dword_406050 )
  {
    dword_406050 = 1;
    result = __do_global_ctors();
  }
  return result;
}
// 406050: using guessed type int dword_406050;

//----- (00401640) --------------------------------------------------------
int __usercall sub_401640@<eax>(char a1@<al>)
{
  int v1; // edx
  int v2; // eax

  v1 = 0;
  if ( a1 == -1 )
    return v1;
  v2 = a1 & 7;
  v1 = 2;
  if ( v2 == 2 )
    return v1;
  if ( v2 <= 2 )
  {
    if ( v2 )
LABEL_6:
      abort();
    return 4;
  }
  v1 = 4;
  if ( v2 == 3 )
    return v1;
  if ( v2 != 4 )
    goto LABEL_6;
  return 8;
}

//----- (00401690) --------------------------------------------------------
char *__usercall read_uleb128@<eax>(char *a1@<eax>, _DWORD *a2@<edx>)
{
  int v3; // esi
  int v4; // ebx
  char v5; // cl
  char v6; // dl

  v3 = 0;
  v4 = 0;
  do
  {
    v5 = v4;
    v4 += 7;
    v6 = *a1++;
    v3 |= (v6 & 0x7F) << v5;
  }
  while ( v6 < 0 );
  *a2 = v3;
  return a1;
}

//----- (004016E0) --------------------------------------------------------
char *__usercall read_sleb128@<eax>(char *a1@<eax>, _DWORD *a2@<edx>)
{
  int v2; // edi
  unsigned int v3; // esi
  char v4; // cl
  char v5; // dl

  v2 = 0;
  v3 = 0;
  do
  {
    v4 = v3;
    v3 += 7;
    v5 = *a1++;
    v2 |= (v5 & 0x7F) << v4;
  }
  while ( v5 < 0 );
  if ( v3 <= 0x1F && (v5 & 0x40) != 0 )
    v2 |= -1 << v3;
  *a2 = v2;
  return a1;
}

//----- (00401750) --------------------------------------------------------
char *__usercall sub_401750@<eax>(char a1@<al>, int a2@<edx>, char *a3, int *a4)
{
  int v6; // edx
  char *v7; // ecx
  char *result; // eax
  int *v9; // eax
  char *v10; // eax
  char *v11; // eax
  int v12; // [esp+4h] [ebp-14h] BYREF
  int v13; // [esp+8h] [ebp-10h] BYREF

  if ( a1 == 80 )
  {
    v9 = (int *)((unsigned int)(a3 + 3) & 0xFFFFFFFC);
    *a4 = *v9;
    result = (char *)(v9 + 1);
  }
  else
  {
    switch ( a1 & 0xF )
    {
      case 0:
      case 3:
      case 0xB:
        v6 = *(_DWORD *)a3;
        v7 = a3 + 4;
        break;
      case 1:
        v10 = read_uleb128(a3, &v13);
        v6 = v13;
        v7 = v10;
        break;
      case 2:
        v6 = *(unsigned __int16 *)a3;
        v7 = a3 + 2;
        break;
      case 4:
      case 0xC:
        v6 = *(_DWORD *)a3;
        v7 = a3 + 8;
        break;
      case 9:
        v11 = read_sleb128(a3, &v12);
        v6 = v12;
        v7 = v11;
        break;
      case 0xA:
        v6 = *(__int16 *)a3;
        v7 = a3 + 2;
        break;
      default:
        abort();
    }
    if ( v6 )
    {
      if ( (a1 & 0x70) == 16 )
        v6 += (int)a3;
      else
        v6 += a2;
      if ( a1 < 0 )
        v6 = *(_DWORD *)v6;
    }
    *a4 = v6;
    result = v7;
  }
  return result;
}

//----- (00401820) --------------------------------------------------------
HANDLE sub_401820()
{
  int v0; // eax
  int v1; // ebx
  HANDLE result; // eax

  v0 = dword_4060C0;
  *(_DWORD *)(dword_4060C0 + 20) = -1;
  v1 = v0 + 20;
  result = CreateSemaphoreA(0, 0, 0xFFFF, 0);
  *(_DWORD *)(v1 + 4) = result;
  return result;
}
// 4060C0: using guessed type int dword_4060C0;

//----- (00401870) --------------------------------------------------------
HANDLE sub_401870()
{
  HANDLE result; // eax
  int v1; // ebx
  HANDLE *v2; // esi

  result = (HANDLE)dword_4060A0;
  v1 = dword_4060C0;
  v2 = (HANDLE *)(dword_4060C0 + 28);
  if ( dword_4060A0 )
  {
    if ( dword_4060C0 != -28 )
    {
      result = *(HANDLE *)(dword_4060C0 + 28);
      if ( !result )
      {
        result = (HANDLE)InterlockedIncrement((volatile LONG *)(dword_4060C0 + 32));
        if ( result )
        {
          if ( !*(_DWORD *)(v1 + 28) )
          {
            do
            {
              Sleep(0);
              result = *v2;
            }
            while ( !*v2 );
          }
        }
        else
        {
          result = sub_401820();
          *(_DWORD *)(v1 + 28) = 1;
        }
      }
    }
  }
  return result;
}
// 4060A0: using guessed type int dword_4060A0;
// 4060C0: using guessed type int dword_4060C0;

//----- (00401900) --------------------------------------------------------
void __cdecl sub_401900(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // edx
  int lpAddend; // esi
  int v7; // ebx

  if ( a1 && *a1 )
  {
    *a2 = -1;
    a2[1] = a3;
    a2[4] = 0;
    a2[3] = a1;
    a2[2] = a4;
    *((_WORD *)a2 + 8) |= 0x7F8u;
    sub_401870();
    v4 = dword_4060A0;
    v5 = dword_4060C0;
    lpAddend = dword_4060C0 + 20;
    if ( dword_4060A0 )
    {
      if ( InterlockedIncrement((volatile LONG *)(dword_4060C0 + 20))
        && WaitForSingleObject(*(HANDLE *)(lpAddend + 4), 0xFFFFFFFF) )
      {
        InterlockedDecrement((volatile LONG *)lpAddend);
      }
      v5 = dword_4060C0;
      v4 = dword_4060A0;
    }
    a2[5] = *(_DWORD *)(v5 + 12);
    *(_DWORD *)(v5 + 12) = a2;
    v7 = v5 + 20;
    if ( v4 )
    {
      if ( InterlockedDecrement((volatile LONG *)(v5 + 20)) >= 0 )
        ReleaseSemaphore(*(HANDLE *)(v7 + 4), 1, 0);
    }
  }
}
// 4060A0: using guessed type int dword_4060A0;
// 4060C0: using guessed type int dword_4060C0;

//----- (004019F0) --------------------------------------------------------
void __cdecl sub_4019F0(_DWORD *a1, _DWORD *a2)
{
  sub_401900(a1, a2, 0, 0);
}

//----- (00401A60) --------------------------------------------------------
LONG __cdecl sub_401A60(int a1, _DWORD *a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // edx
  int v6; // esi
  LONG result; // eax
  int lpAddend; // ebx
  int v9; // edx
  bool v10; // zf

  *a2 = -1;
  a2[1] = a3;
  a2[2] = a4;
  a2[4] = 0;
  *((_BYTE *)a2 + 16) |= 2u;
  a2[3] = a1;
  *((_WORD *)a2 + 8) |= 0x7F8u;
  sub_401870();
  v4 = dword_4060A0;
  v5 = dword_4060C0;
  v6 = dword_4060C0 + 20;
  if ( !dword_4060A0 )
  {
    result = *(_DWORD *)(dword_4060C0 + 12);
    a2[5] = result;
    *(_DWORD *)(v5 + 12) = a2;
    lpAddend = v5 + 20;
    if ( !v4 )
      return result;
    goto LABEL_6;
  }
  if ( InterlockedIncrement((volatile LONG *)(dword_4060C0 + 20))
    && WaitForSingleObject(*(HANDLE *)(v6 + 4), 0xFFFFFFFF) )
  {
    InterlockedDecrement((volatile LONG *)v6);
  }
  v9 = dword_4060C0;
  result = *(_DWORD *)(dword_4060C0 + 12);
  v10 = dword_4060A0 == 0;
  a2[5] = result;
  *(_DWORD *)(v9 + 12) = a2;
  lpAddend = v9 + 20;
  if ( !v10 )
  {
LABEL_6:
    result = InterlockedDecrement((volatile LONG *)lpAddend);
    if ( result >= 0 )
      result = ReleaseSemaphore(*(HANDLE *)(lpAddend + 4), 1, 0);
  }
  return result;
}
// 4060A0: using guessed type int dword_4060A0;
// 4060C0: using guessed type int dword_4060C0;

//----- (00401B60) --------------------------------------------------------
LONG __cdecl sub_401B60(int a1, _DWORD *a2)
{
  return sub_401A60(a1, a2, 0, 0);
}

//----- (00401BC0) --------------------------------------------------------
int __cdecl sub_401BC0(_DWORD *a1)
{
  int v2; // esi
  int v3; // edi
  int v4; // ecx
  int v5; // eax
  bool v6; // zf
  int v7; // edx
  int v8; // ebx
  int lpAddend; // esi

  if ( !a1 || !*a1 )
    return 0;
  sub_401870();
  v2 = dword_4060C0;
  v3 = dword_4060C0 + 20;
  if ( dword_4060A0 )
  {
    if ( InterlockedIncrement((volatile LONG *)(dword_4060C0 + 20))
      && WaitForSingleObject(*(HANDLE *)(v3 + 4), 0xFFFFFFFF) )
    {
      InterlockedDecrement((volatile LONG *)v3);
    }
    v2 = dword_4060C0;
  }
  v4 = v2 + 12;
  if ( !*(_DWORD *)(v2 + 12) )
  {
LABEL_8:
    v6 = *(_DWORD *)(v2 + 16) == 0;
    v4 = v2 + 16;
    while ( 1 )
    {
      if ( v6 )
      {
        if ( dword_4060A0 && InterlockedDecrement((volatile LONG *)(v2 + 20)) >= 0 )
        {
          ReleaseSemaphore(*(HANDLE *)(v2 + 24), 1, 0);
          abort();
        }
        abort();
      }
      v7 = *(_DWORD *)v4;
      if ( (*(_BYTE *)(*(_DWORD *)v4 + 16) & 1) != 0 )
      {
        if ( **(_DWORD ***)(v7 + 12) == a1 )
        {
          v8 = *(_DWORD *)v4;
          *(_DWORD *)v4 = *(_DWORD *)(v7 + 20);
          free(*(void **)(v8 + 12));
          v2 = dword_4060C0;
          goto LABEL_16;
        }
      }
      else if ( *(_DWORD **)(v7 + 12) == a1 )
      {
        v8 = *(_DWORD *)v4;
        goto LABEL_15;
      }
      v4 = v7 + 20;
      v6 = *(_DWORD *)(v7 + 20) == 0;
    }
  }
  while ( 1 )
  {
    v5 = *(_DWORD *)v4;
    if ( *(_DWORD **)(*(_DWORD *)v4 + 12) == a1 )
      break;
    v4 = v5 + 20;
    if ( !*(_DWORD *)(v5 + 20) )
      goto LABEL_8;
  }
  v8 = *(_DWORD *)v4;
LABEL_15:
  *(_DWORD *)v4 = *(_DWORD *)(v8 + 20);
LABEL_16:
  lpAddend = v2 + 20;
  if ( !dword_4060A0 || InterlockedDecrement((volatile LONG *)lpAddend) < 0 )
    return v8;
  ReleaseSemaphore(*(HANDLE *)(lpAddend + 4), 1, 0);
  return v8;
}
// 4060A0: using guessed type int dword_4060A0;
// 4060C0: using guessed type int dword_4060C0;

//----- (00401D50) --------------------------------------------------------
int __cdecl sub_401D50(_DWORD *a1)
{
  return sub_401BC0(a1);
}

//----- (00401D90) --------------------------------------------------------
int __usercall sub_401D90@<eax>(char a1@<al>, int a2@<edx>)
{
  int v2; // ecx
  int v3; // eax
  bool v4; // zf

  v2 = 0;
  if ( a1 == -1 )
    return v2;
  v3 = a1 & 0x70;
  if ( v3 == 32 )
    return *(_DWORD *)(a2 + 4);
  if ( v3 > 32 )
  {
    if ( v3 != 48 )
    {
      v4 = v3 == 80;
LABEL_8:
      if ( !v4 )
        abort();
      return 0;
    }
    return *(_DWORD *)(a2 + 8);
  }
  if ( v3 )
  {
    v4 = v3 == 16;
    goto LABEL_8;
  }
  return 0;
}

//----- (00401DF0) --------------------------------------------------------
int __usercall sub_401DF0@<eax>(int a1@<eax>)
{
  const char *Str; // ebx
  int result; // eax
  size_t v4; // eax
  char *v5; // eax
  char *v6; // ebx
  char *v7; // eax
  char *i; // ecx
  char v9; // al
  int v10; // [esp+14h] [ebp-14h] BYREF
  int v11; // [esp+18h] [ebp-10h] BYREF
  _DWORD v12[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Str = (const char *)(a1 + 9);
  result = 0;
  if ( *(_BYTE *)(a1 + 9) == 122 )
  {
    v4 = strlen(Str);
    v5 = read_uleb128((char *)&Str[v4 + 1], v12);
    v6 = (char *)(a1 + 10);
    v7 = read_sleb128(v5, &v11);
    for ( i = read_uleb128(v7 + 1, v12); ; ++i )
    {
      while ( 1 )
      {
        v9 = *v6;
        if ( *v6 == 82 )
          return (unsigned __int8)*i;
        if ( v9 != 80 )
          break;
        ++v6;
        i = sub_401750(*i & 0x7F, 0, i + 1, &v10);
      }
      if ( v9 != 76 )
        break;
      ++v6;
    }
    result = 0;
  }
  return result;
}

//----- (00401E80) --------------------------------------------------------
int __cdecl sub_401E80(int a1, int a2, int a3)
{
  int v3; // ecx
  unsigned int v4; // edx

  v3 = 1;
  v4 = *(_DWORD *)(a3 + 8);
  if ( *(_DWORD *)(a2 + 8) <= v4 )
    v3 = -(*(_DWORD *)(a2 + 8) < v4);
  return v3;
}

//----- (00401EA0) --------------------------------------------------------
int __cdecl sub_401EA0(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // edx
  unsigned int v6; // [esp+8h] [ebp-10h] BYREF
  unsigned int v7[3]; // [esp+Ch] [ebp-Ch] BYREF

  v3 = sub_401D90(*(unsigned __int16 *)(a1 + 16) >> 3, a1);
  sub_401750(*(unsigned __int16 *)(a1 + 16) >> 3, v3, (char *)(a2 + 8), (int *)v7);
  sub_401750(*(unsigned __int16 *)(a1 + 16) >> 3, v3, (char *)(a3 + 8), (int *)&v6);
  v4 = 1;
  if ( v7[0] <= v6 )
    v4 = -(v7[0] < v6);
  return v4;
}

//----- (00401F20) --------------------------------------------------------
int __cdecl sub_401F20(int a1, int a2, int a3)
{
  char v3; // bl
  int v4; // eax
  char v5; // bl
  int v6; // eax
  int v7; // edx
  unsigned int v9; // [esp+14h] [ebp-14h] BYREF
  unsigned int v10[4]; // [esp+18h] [ebp-10h] BYREF

  v3 = sub_401DF0(a2 - *(_DWORD *)(a2 + 4) + 4);
  v4 = sub_401D90(v3, a1);
  sub_401750(v3, v4, (char *)(a2 + 8), (int *)v10);
  v5 = sub_401DF0(a3 - *(_DWORD *)(a3 + 4) + 4);
  v6 = sub_401D90(v5, a1);
  sub_401750(v5, v6, (char *)(a3 + 8), (int *)&v9);
  v7 = 1;
  if ( v10[0] <= v9 )
    v7 = -(v10[0] < v9);
  return v7;
}

//----- (00401FB0) --------------------------------------------------------
int __usercall sub_401FB0@<eax>(int result@<eax>, int (__cdecl *a2)(int, _DWORD, _DWORD)@<edx>, int a3, int a4, int a5)
{
  int v5; // edi
  int i; // ebx
  int v7; // edx
  int v9; // [esp+18h] [ebp-10h]

  v5 = a4;
  v9 = result;
  for ( i = 2 * a4 + 1; i < a5; i = 2 * i + 1 )
  {
    if ( i + 1 < a5 && a2(v9, *(_DWORD *)(a3 + 4 * i), *(_DWORD *)(a3 + 4 * i + 4)) < 0 )
      ++i;
    result = a2(v9, *(_DWORD *)(a3 + 4 * v5), *(_DWORD *)(a3 + 4 * i));
    if ( result >= 0 )
      break;
    v7 = *(_DWORD *)(a3 + 4 * v5);
    result = *(_DWORD *)(a3 + 4 * i);
    *(_DWORD *)(a3 + 4 * v5) = result;
    v5 = i;
    *(_DWORD *)(a3 + 4 * i) = v7;
  }
  return result;
}

//----- (00402040) --------------------------------------------------------
unsigned int __usercall sub_402040@<eax>(int a1@<eax>, int (__cdecl *a2)(int, _DWORD, _DWORD)@<edx>, int a3)
{
  unsigned int v3; // edi
  int *v4; // esi
  unsigned int result; // eax
  int i; // ebx
  int j; // ebx
  int v8; // edx
  int v9; // [esp+8h] [ebp-20h]

  v3 = *(_DWORD *)(a3 + 4);
  v4 = (int *)(a3 + 8);
  result = v3 >> 1;
  for ( i = v3 >> 1; --i >= 0; result = sub_401FB0(a1, a2, (int)v4, i, v3) )
    ;
  for ( j = v3 - 1; j > 0; --j )
  {
    v8 = *v4;
    *v4 = v4[j];
    v4[j] = v8;
    v9 = j;
    result = sub_401FB0(a1, a2, (int)v4, 0, v9);
  }
  return result;
}

//----- (004020B0) --------------------------------------------------------
int __usercall sub_4020B0@<eax>(int a1@<eax>, char *a2@<edx>)
{
  char *v3; // esi
  bool v4; // zf
  int v5; // eax
  int v6; // eax
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // eax
  unsigned int v10; // eax
  int v11; // eax
  int v13; // [esp+8h] [ebp-20h]
  int v14; // [esp+Ch] [ebp-1Ch]
  int v15; // [esp+10h] [ebp-18h]
  int v16; // [esp+14h] [ebp-14h]
  unsigned int v17[4]; // [esp+18h] [ebp-10h] BYREF

  v3 = a2;
  v4 = *(_DWORD *)a2 == 0;
  v16 = 0;
  v15 = 0;
  LOBYTE(v14) = 0;
  v13 = 0;
  while ( !v4 )
  {
    v5 = *((_DWORD *)v3 + 1);
    if ( v5 )
    {
      v6 = (int)&v3[-v5 + 4];
      if ( v6 != v16 )
      {
        v16 = v6;
        v14 = sub_401DF0(v6);
        v7 = sub_401D90(v14, a1);
        v8 = *(unsigned __int16 *)(a1 + 16);
        v13 = v7;
        v9 = (unsigned __int8)(v8 >> 3);
        if ( v9 == 255 )
        {
          *(_WORD *)(a1 + 16) = (8 * (unsigned __int8)v14) | v8 & 0xF807;
        }
        else if ( v9 != v14 )
        {
          *(_BYTE *)(a1 + 16) |= 4u;
        }
      }
      sub_401750(v14, v13, v3 + 8, (int *)v17);
      v10 = sub_401640(v14);
      if ( v10 > 3 )
        v11 = -1;
      else
        v11 = (1 << (8 * v10)) - 1;
      if ( (v17[0] & v11) != 0 )
      {
        ++v15;
        if ( *(_DWORD *)a1 > v17[0] )
          *(_DWORD *)a1 = v17[0];
      }
    }
    v3 += *(_DWORD *)v3 + 4;
    v4 = *(_DWORD *)v3 == 0;
  }
  return v15;
}

//----- (004021D0) --------------------------------------------------------
int __usercall sub_4021D0@<eax>(int a1@<eax>, int *a2@<edx>, char *a3)
{
  char *v3; // esi
  int v4; // eax
  int v5; // edi
  int result; // eax
  bool v7; // zf
  int v8; // eax
  int v9; // eax
  bool v10; // zf
  int v11; // edx
  int v12; // eax
  unsigned int v13; // eax
  int v14; // [esp+8h] [ebp-20h]
  int v15; // [esp+Ch] [ebp-1Ch]
  int v18[4]; // [esp+18h] [ebp-10h] BYREF

  v3 = a3;
  v15 = 0;
  v4 = *(unsigned __int16 *)(a1 + 16) >> 3;
  v5 = (unsigned __int8)v4;
  result = sub_401D90(v4, a1);
  v7 = *(_DWORD *)a3 == 0;
  v14 = result;
  while ( !v7 )
  {
    v8 = *((_DWORD *)v3 + 1);
    if ( v8 )
    {
      if ( (*(_BYTE *)(a1 + 16) & 4) != 0 )
      {
        v9 = (int)&v3[-v8 + 4];
        if ( v9 != v15 )
        {
          v15 = v9;
          v5 = sub_401DF0(v9);
          v14 = sub_401D90(v5, a1);
        }
      }
      if ( v5 )
      {
        sub_401750(v5, v14, v3 + 8, v18);
        v13 = sub_401640(v5);
        if ( v13 > 3 )
          v10 = v18[0] == 0;
        else
          v10 = (((1 << (8 * v13)) - 1) & v18[0]) == 0;
      }
      else
      {
        v10 = *((_DWORD *)v3 + 2) == 0;
      }
      if ( !v10 )
      {
        v11 = *a2;
        if ( *a2 )
        {
          v12 = *(_DWORD *)(v11 + 4);
          *(_DWORD *)(v11 + 4 * v12 + 8) = v3;
          *(_DWORD *)(v11 + 4) = v12 + 1;
        }
      }
    }
    v3 += *(_DWORD *)v3 + 4;
    result = *(_DWORD *)v3;
    v7 = *(_DWORD *)v3 == 0;
  }
  return result;
}

//----- (004022D0) --------------------------------------------------------
int __usercall sub_4022D0@<eax>(int a1@<eax>, int a2@<edx>, int a3)
{
  int v4; // eax
  int v5; // edi
  int v6; // eax
  bool v7; // zf
  int v8; // eax
  int v9; // eax
  int v10; // edx
  unsigned int v11; // ecx
  char *v13; // eax
  unsigned int v14; // eax
  int v15; // eax
  int v16; // [esp+8h] [ebp-20h]
  int v17; // [esp+Ch] [ebp-1Ch]
  unsigned int v19; // [esp+14h] [ebp-14h] BYREF
  int v20[4]; // [esp+18h] [ebp-10h] BYREF

  v17 = 0;
  v4 = *(unsigned __int16 *)(a1 + 16) >> 3;
  v5 = (unsigned __int8)v4;
  v6 = sub_401D90(v4, a1);
  v7 = *(_DWORD *)a2 == 0;
  v16 = v6;
  while ( !v7 )
  {
    v8 = *(_DWORD *)(a2 + 4);
    if ( !v8 )
      goto LABEL_2;
    if ( (*(_BYTE *)(a1 + 16) & 4) != 0 )
    {
      v9 = a2 - v8 + 4;
      if ( v9 != v17 )
      {
        v17 = v9;
        v5 = sub_401DF0(v9);
        v16 = sub_401D90(v5, a1);
      }
    }
    if ( v5 )
    {
      v13 = sub_401750(v5, v16, (char *)(a2 + 8), v20);
      sub_401750(v5 & 0xF, 0, v13, (int *)&v19);
      v14 = sub_401640(v5);
      if ( v14 > 3 )
        v15 = -1;
      else
        v15 = (1 << (8 * v14)) - 1;
      v10 = v20[0];
      if ( (v20[0] & v15) == 0 )
        goto LABEL_2;
      v11 = v19;
    }
    else
    {
      v20[0] = *(_DWORD *)(a2 + 8);
      v10 = v20[0];
      v11 = *(_DWORD *)(a2 + 12);
      v19 = v11;
      if ( !v20[0] )
        goto LABEL_2;
    }
    if ( a3 - v10 < v11 )
      return a2;
LABEL_2:
    a2 += *(_DWORD *)a2 + 4;
    v7 = *(_DWORD *)a2 == 0;
  }
  return 0;
}

//----- (004023F0) --------------------------------------------------------
int __usercall search_object@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  char v2; // dl
  int result; // eax
  unsigned int v4; // esi
  int v5; // edi
  char v6; // bl
  int v7; // eax
  char *v8; // eax
  int *k; // ebx
  char **i; // ebx
  char *v11; // edx
  unsigned int v12; // edx
  char *v13; // eax
  _DWORD *v14; // eax
  char **v15; // ebx
  char *j; // eax
  unsigned int v17; // ebx
  int v18; // eax
  char *v19; // edi
  char *v20; // esi
  int v21; // eax
  unsigned int v22; // eax
  unsigned int v23; // edx
  unsigned int v24; // edi
  bool v25; // cf
  unsigned int v26; // ecx
  int v27; // ebx
  unsigned int v28; // eax
  char v29; // bl
  unsigned int v30; // esi
  unsigned int v31; // ebx
  char *v32; // eax
  int v33; // ecx
  int v34; // edx
  unsigned int v35; // ebx
  int v36; // eax
  char *v37; // esi
  int v38; // edi
  int v39; // ebx
  int v40; // eax
  int v41; // edx
  int v42; // ecx
  char *v43; // edx
  _DWORD *Block; // [esp+14h] [ebp-74h]
  _DWORD *Blocka; // [esp+14h] [ebp-74h]
  char *v46; // [esp+18h] [ebp-70h]
  char v47; // [esp+1Ch] [ebp-6Ch]
  char v48; // [esp+20h] [ebp-68h]
  unsigned int v49; // [esp+24h] [ebp-64h]
  int v50; // [esp+28h] [ebp-60h]
  int v51; // [esp+2Ch] [ebp-5Ch]
  int v52; // [esp+30h] [ebp-58h]
  unsigned int v53; // [esp+34h] [ebp-54h]
  unsigned int v54; // [esp+38h] [ebp-50h]
  int v55; // [esp+3Ch] [ebp-4Ch]
  int v56; // [esp+40h] [ebp-48h]
  unsigned int v57; // [esp+44h] [ebp-44h]
  char *v58; // [esp+48h] [ebp-40h]
  int v59; // [esp+4Ch] [ebp-3Ch]
  int (__cdecl *v60)(int, int, int); // [esp+50h] [ebp-38h]
  int v61; // [esp+54h] [ebp-34h]
  int v64; // [esp+60h] [ebp-28h] BYREF
  unsigned int v65; // [esp+64h] [ebp-24h] BYREF
  int v66; // [esp+68h] [ebp-20h] BYREF
  unsigned int v67; // [esp+6Ch] [ebp-1Ch] BYREF
  char *v68; // [esp+70h] [ebp-18h] BYREF
  _DWORD *v69; // [esp+74h] [ebp-14h]

  v2 = *(_BYTE *)(a1 + 16);
  if ( (v2 & 1) != 0 )
    goto LABEL_6;
  v61 = *(_DWORD *)(a1 + 16) >> 11;
  if ( !v61 )
  {
    if ( (v2 & 2) != 0 )
    {
      for ( i = *(char ***)(a1 + 12); *i; v61 += sub_4020B0(a1, v11) )
        v11 = *i++;
    }
    else
    {
      v61 = sub_4020B0(a1, *(char **)(a1 + 12));
    }
    v12 = (v61 << 11) | *(_DWORD *)(a1 + 16) & 0x7FF;
    if ( v12 >> 11 != v61 )
    {
      *(_DWORD *)(a1 + 16) = v12 & 0x7FF;
      if ( !v61 )
        goto LABEL_4;
LABEL_25:
      v13 = (char *)malloc(4 * v61 + 8);
      v68 = v13;
      if ( !v13 )
        goto LABEL_4;
      *((_DWORD *)v13 + 1) = 0;
      v14 = malloc(4 * v61 + 8);
      v69 = v14;
      if ( v14 )
        v14[1] = 0;
      if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
      {
        v15 = *(char ***)(a1 + 12);
        for ( j = *v15; *v15; j = *v15 )
        {
          ++v15;
          sub_4021D0(a1, (int *)&v68, j);
        }
      }
      else
      {
        sub_4021D0(a1, (int *)&v68, *(char **)(a1 + 12));
      }
      if ( v68 && *((_DWORD *)v68 + 1) != v61 )
LABEL_63:
        abort();
      v60 = sub_401F20;
      if ( (*(_BYTE *)(a1 + 16) & 4) == 0 )
      {
        v60 = sub_401E80;
        if ( (unsigned __int8)(*(unsigned __int16 *)(a1 + 16) >> 3) )
          v60 = sub_401EA0;
      }
      Block = v69;
      v59 = (int)v69;
      if ( v69 )
      {
        v17 = 0;
        v18 = dword_4060C0;
        v46 = v68;
        v19 = v68;
        v58 = v68;
        v20 = (char *)(dword_4060C0 + 36);
        v57 = *((_DWORD *)v68 + 1);
        if ( v57 )
        {
          while ( 1 )
          {
            if ( (char *)(v18 + 36) == v20 || v60(a1, *(_DWORD *)&v46[4 * v17 + 8], *(_DWORD *)v20) >= 0 )
            {
              Block[v17++ + 2] = v20;
              v20 = v19 + 8;
              v19 += 4;
              if ( v17 >= v57 )
              {
                Block = v69;
                v46 = v68;
                break;
              }
            }
            else
            {
              v21 = v20 - v46;
              v20 = *(char **)((char *)Block + v20 - v46);
              *(_DWORD *)((char *)Block + v21) = 0;
            }
            v18 = dword_4060C0;
          }
        }
        v33 = 0;
        v34 = 0;
        v35 = 0;
        while ( v35 < v57 )
        {
          v36 = *(_DWORD *)&v58[4 * v35 + 8];
          if ( *(_DWORD *)(v59 + 4 * v35 + 8) )
          {
            ++v35;
            *(_DWORD *)&v58[4 * v34++ + 8] = v36;
          }
          else
          {
            ++v35;
            *(_DWORD *)(v59 + 4 * v33++ + 8) = v36;
          }
        }
        *((_DWORD *)v58 + 1) = v34;
        *(_DWORD *)(v59 + 4) = v33;
        if ( *((_DWORD *)v46 + 1) + Block[1] != v61 )
          goto LABEL_63;
        sub_402040(a1, v60, (int)Block);
        v37 = v68;
        v38 = v69[1];
        Blocka = v69;
        if ( v38 )
        {
          v39 = *((_DWORD *)v68 + 1);
          do
          {
            v56 = Blocka[--v38 + 2];
            while ( v39 && v60(a1, *(_DWORD *)&v37[4 * v39 + 4], v56) > 0 )
            {
              v40 = *(_DWORD *)&v37[4 * v39 + 4];
              v41 = v39 + v38;
              --v39;
              *(_DWORD *)&v37[4 * v41 + 8] = v40;
            }
            *(_DWORD *)&v37[4 * v39 + 8 + 4 * v38] = v56;
          }
          while ( v38 );
          v42 = (int)v69;
          *((_DWORD *)v37 + 1) += Blocka[1];
          Blocka = (_DWORD *)v42;
        }
        free(Blocka);
      }
      else
      {
        sub_402040(a1, v60, (int)v68);
      }
      v43 = v68;
      *(_DWORD *)v68 = *(_DWORD *)(a1 + 12);
      *(_BYTE *)(a1 + 16) |= 1u;
      *(_DWORD *)(a1 + 12) = v43;
      goto LABEL_4;
    }
    *(_DWORD *)(a1 + 16) = v12;
  }
  if ( v61 )
    goto LABEL_25;
LABEL_4:
  result = 0;
  if ( *(_DWORD *)a1 > a2 )
    return result;
  v2 = *(_BYTE *)(a1 + 16);
LABEL_6:
  if ( (v2 & 1) != 0 )
  {
    if ( (v2 & 4) != 0 )
    {
      v54 = 0;
      v55 = *(_DWORD *)(a1 + 12);
      v53 = *(_DWORD *)(v55 + 4);
      if ( v53 )
      {
        do
        {
          v4 = (v53 + v54) >> 1;
          v5 = *(_DWORD *)(v55 + 4 * v4 + 8);
          v6 = sub_401DF0(v5 - *(_DWORD *)(v5 + 4) + 4);
          v7 = sub_401D90(v6, a1);
          v8 = sub_401750(v6, v7, (char *)(v5 + 8), (int *)&v67);
          sub_401750(v6 & 0xF, 0, v8, &v66);
          if ( a2 >= v67 )
          {
            if ( a2 < v66 + v67 )
              return v5;
            v54 = v4 + 1;
            v4 = v53;
          }
          else
          {
            v53 = (v53 + v54) >> 1;
          }
        }
        while ( v54 < v4 );
      }
    }
    else
    {
      v22 = (unsigned __int8)(*(unsigned __int16 *)(a1 + 16) >> 3);
      if ( (unsigned __int8)(*(unsigned __int16 *)(a1 + 16) >> 3) )
      {
        v29 = *(unsigned __int16 *)(a1 + 16) >> 3;
        v51 = *(_DWORD *)(a1 + 12);
        v49 = 0;
        v50 = sub_401D90(v22, a1);
        v30 = *(_DWORD *)(v51 + 4);
        if ( v30 )
        {
          v48 = v29;
          v47 = v29 & 0xF;
          do
          {
            v31 = (v30 + v49) >> 1;
            v5 = *(_DWORD *)(v51 + 4 * v31 + 8);
            v32 = sub_401750(v48, v50, (char *)(v5 + 8), (int *)&v65);
            sub_401750(v47, 0, v32, &v64);
            if ( a2 < v65 )
            {
              v30 = (v30 + v49) >> 1;
            }
            else
            {
              if ( a2 < v64 + v65 )
                return v5;
              v49 = v31 + 1;
            }
          }
          while ( v49 < v30 );
        }
      }
      else
      {
        v23 = 0;
        v24 = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4);
        v52 = *(_DWORD *)(a1 + 12);
        v25 = v22 < v24;
        while ( v25 )
        {
          v26 = (v23 + v24) >> 1;
          v27 = *(_DWORD *)(v52 + 4 * v26 + 8);
          v28 = *(_DWORD *)(v27 + 8);
          if ( a2 >= v28 )
          {
            if ( *(_DWORD *)(v27 + 12) + v28 > a2 )
              return *(_DWORD *)(v52 + 4 * v26 + 8);
            v23 = v26 + 1;
            v25 = v26 + 1 < v24;
          }
          else
          {
            v24 = (v23 + v24) >> 1;
            v25 = v23 < v26;
          }
        }
      }
    }
  }
  else
  {
    if ( (v2 & 2) == 0 )
      return sub_4022D0(a1, *(_DWORD *)(a1 + 12), a2);
    for ( k = *(int **)(a1 + 12); *k; ++k )
    {
      result = sub_4022D0(a1, *k, a2);
      if ( result )
        return result;
    }
  }
  return 0;
}
// 4060C0: using guessed type int dword_4060C0;

//----- (00402B50) --------------------------------------------------------
int sub_402B50()
{
  return (*(int (**)(void))(dword_4060C0 + 4))();
}
// 4060C0: using guessed type int dword_4060C0;

//----- (00402B60) --------------------------------------------------------
unsigned int __usercall sub_402B60@<eax>(ATOM nAtom@<ax>)
{
  unsigned int v1; // ebx
  UINT v2; // eax
  int v3; // edx
  int v4; // ecx
  CHAR Buffer[68]; // [esp+10h] [ebp-48h] BYREF

  v1 = 0;
  v2 = GetAtomNameA(nAtom, Buffer, 61);
  v3 = 31;
  v4 = 1;
  if ( !v2 )
    assert(
      "../../gcc-3.4.5-20060117-1/gcc/config/i386/w32-shared-ptr.c",
      "GetAtomNameA (atom, s, sizeof(s)) != 0",
      "../../gcc-3.4.5-20060117-1/gcc/config/i386/w32-shared-ptr.c",
      241);
  do
  {
    while ( Buffer[v3] != 65 )
    {
      v4 *= 2;
      if ( --v3 < 0 )
        goto LABEL_6;
    }
    v1 |= v4;
    v4 *= 2;
    --v3;
  }
  while ( v3 >= 0 );
LABEL_6:
  if ( *(_DWORD *)v1 != 64 )
    assert(
      v4,
      "w32_sharedptr->size == sizeof(W32_EH_SHARED)",
      "../../gcc-3.4.5-20060117-1/gcc/config/i386/w32-shared-ptr.c",
      247);
  return v1;
}
// 402F50: using guessed type int __thiscall assert(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00402C00) --------------------------------------------------------
void __w32_sharedptr_initialize()
{
  ATOM v0; // ax
  _DWORD *v1; // eax
  unsigned int v2; // ebx
  int v3; // ecx
  int v4; // eax
  int v5; // edx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v11; // eax
  int v12; // edx
  char v13; // al
  ATOM v14; // ax
  int v15; // edi
  int v16; // edx
  unsigned int v17; // eax
  int v18; // [esp+1Ch] [ebp-9Ch]
  CHAR lpString[32]; // [esp+20h] [ebp-98h] BYREF
  char v20[32]; // [esp+40h] [ebp-78h] BYREF
  CHAR String[88]; // [esp+60h] [ebp-58h] BYREF

  if ( !dword_4060C0 )
  {
    strcpy(String, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-LIBGCCW32-EH-3-GTHR-MINGW32");
    v0 = FindAtomA(String);
    v18 = v0;
    if ( !v0 )
    {
      v1 = malloc(0x40u);
      v2 = (unsigned int)v1;
      if ( !v1 )
        abort();
      memset32(v1, v18, 0x10u);
      v1[1] = abort;
      v3 = 1;
      v1[2] = sub_402B50;
      v4 = dword_406070;
      *(_DWORD *)v2 = 64;
      v5 = dword_406074;
      *(_DWORD *)(v2 + 20) = v4;
      v6 = dword_404030;
      *(_DWORD *)(v2 + 24) = v5;
      v7 = dword_404034;
      *(_DWORD *)(v2 + 28) = v6;
      v8 = dword_406080;
      *(_DWORD *)(v2 + 32) = v7;
      v9 = dword_406084;
      *(_DWORD *)(v2 + 40) = v8;
      v10 = dword_406090;
      *(_DWORD *)(v2 + 48) = -1;
      *(_DWORD *)(v2 + 44) = v9;
      *(_DWORD *)(v2 + 52) = v10;
      v11 = dword_404038;
      *(_DWORD *)(v2 + 60) = dword_40403C;
      v12 = 31;
      *(_DWORD *)(v2 + 56) = v11;
      do
      {
        v13 = (v3 & v2) == 0 ? 0x20 : 0;
        v3 *= 2;
        lpString[v12--] = v13 + 65;
      }
      while ( v12 >= 0 );
      strcpy(v20, "-LIBGCCW32-EH-3-GTHR-MINGW32");
      v14 = AddAtomA(lpString);
      v15 = v14;
      if ( !v14 || (v17 = sub_402B60(v14), v16 = v15, v17 != v2) )
        v16 = 0;
      if ( v16 )
        goto LABEL_11;
      free((void *)v2);
      v0 = FindAtomA(String);
    }
    v2 = sub_402B60(v0);
LABEL_11:
    dword_4060C0 = v2;
    dword_4060B0 = v2 + 4;
    dword_4060D0 = v2 + 8;
  }
}
// 404030: using guessed type int dword_404030;
// 404034: using guessed type int dword_404034;
// 404038: using guessed type int dword_404038;
// 40403C: using guessed type int dword_40403C;
// 406070: using guessed type int dword_406070;
// 406074: using guessed type int dword_406074;
// 406080: using guessed type int dword_406080;
// 406084: using guessed type int dword_406084;
// 406090: using guessed type int dword_406090;
// 4060B0: using guessed type int dword_4060B0;
// 4060C0: using guessed type int dword_4060C0;
// 4060D0: using guessed type int dword_4060D0;

//----- (00403010) --------------------------------------------------------
void sub_403010()
{
  sub_4012C0();
}

//----- (00403020) --------------------------------------------------------
int sub_403020()
{
  return sub_4012F0();
}

// nfuncs=68 queued=43 decompiled=43 lumina nreq=0 worse=0 better=0
// ALL OK, 43 function(s) have been successfully decompiled
