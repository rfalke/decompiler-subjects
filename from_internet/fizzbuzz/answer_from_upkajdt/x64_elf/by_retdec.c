//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _Unwind_Exception {
    int32_t e0;
};

struct vtable_4030b0_type {
    int64_t (*e0)(int64_t *);
    int64_t (*e1)(int64_t *);
    int64_t (*e2)(int64_t *);
};

// ------------------------- Classes --------------------------

// std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker*), worker*> > >

// ------------------- Function Prototypes --------------------

int64_t _ZNSt6thread11_State_implINS_8_InvokerISt5tupleIJPFvP6workerES4_EEEEE6_M_runEv(int64_t * result);
int64_t _ZNSt6thread11_State_implINS_8_InvokerISt5tupleIJPFvP6workerES4_EEEEED0Ev(int64_t * result);
int64_t _ZNSt6thread11_State_implINS_8_InvokerISt5tupleIJPFvP6workerES4_EEEEED1Ev(int64_t * result);
void _ZNSt6vectorIP6workerSaIS1_EE17_M_realloc_insertIJS1_EEEvN9__gnu_cxx17__normal_iteratorIPS1_S3_EEDpOT_(int64_t * this, int64_t * result, int64_t a3, int64_t a4);
void _ZNSt6vectorISt6threadSaIS0_EE17_M_realloc_insertIJRFvP6workerERS5_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_(int64_t * a1, int64_t a2, int64_t a3, int64_t * a4, int64_t a5);
int64_t function_401060(int64_t a1);
int64_t function_401120(void);
int64_t function_401150(void);

// --------------------- Global Variables ---------------------

int64_t g2 = 0; // 0x4050e0
struct vtable_4030b0_type g1 = {
    .e0 = _ZNSt6thread11_State_implINS_8_InvokerISt5tupleIJPFvP6workerES4_EEEEED1Ev,
    .e1 = _ZNSt6thread11_State_implINS_8_InvokerISt5tupleIJPFvP6workerES4_EEEEED0Ev,
    .e2 = _ZNSt6thread11_State_implINS_8_InvokerISt5tupleIJPFvP6workerES4_EEEEE6_M_runEv
}; // 0x4030b0

// ------------------------ Functions -------------------------

// Address range: 0x401060 - 0x401066
int64_t function_401060(int64_t a1) {
    // 0x401060
    return __cxa_begin_catch();
}

// Address range: 0x401120 - 0x401126
int64_t function_401120(void) {
    // 0x401120
    return __cxa_rethrow();
}

// Address range: 0x401150 - 0x401156
int64_t function_401150(void) {
    // 0x401150
    return __cxa_end_catch();
}

// Address range: 0x401220 - 0x4014a7
int main(int argc, char ** argv) {
    // 0x401220
    int128_t v1; // 0x401220
    int128_t v2 = v1;
    int64_t v3 = _ZNSt6thread20hardware_concurrencyEv(); // 0x40122e
    int128_t v4 = __asm_pxor(v2, v2); // 0x401233
    int64_t v5 = v3 & 0xffffffff; // 0x401240
    int64_t * v6 = (int64_t *)__asm_movaps(v4); // 0x401243
    int64_t * v7 = v6; // bp-120, 0x401243
    v7 = v6;
    int64_t v8; // 0x401220
    int64_t v9; // bp-88, 0x401220
    if (v5 != 0) {
        int64_t v10 = &v9;
        int64_t v11 = 0; // 0x401220
        int64_t v12; // 0x401220
        while (true) {
            int64_t v13 = v11;
            int64_t v14; // 0x401220
            int64_t v15 = v14;
            int64_t v16 = _Znwm(40); // 0x401273
            *(int64_t *)(v16 + 16) = 0x989680;
            *(int64_t *)(v16 + 24) = _Znam(0x17d78400);
            v9 = v16;
            int64_t v17; // 0x401220
            int64_t v18; // 0x401220
            if (v15 != 0) {
                // 0x401254
                *(int64_t *)v15 = v16;
                int64_t v19 = v13 + 1; // 0x401257
                int64_t v20 = v15 + 8; // 0x40125b
                v18 = v20;
                v17 = v19;
                v12 = v20;
                if (v5 == v19) {
                    // break -> 0x4012bb
                    break;
                }
            } else {
                // 0x4012a0
                int64_t v21; // 0x401220
                _ZNSt6vectorIP6workerSaIS1_EE17_M_realloc_insertIJS1_EEEvN9__gnu_cxx17__normal_iteratorIPS1_S3_EEDpOT_((int64_t *)&v7, NULL, v10, v21);
                int64_t v22 = v13 + 1; // 0x4012b2
                v18 = v15;
                v17 = v22;
                v12 = v15;
                if (v5 == v22) {
                    // break -> 0x4012bb
                    break;
                }
            }
            // 0x401269
            v14 = v18;
            v11 = v17;
        }
        // 0x4012bb
        v8 = v12;
    }
    int64_t v23 = (int64_t)v7;
    int128_t v24 = v4; // 0x4012e4
    int64_t v25 = 0; // 0x4012e4
    int64_t v26; // 0x401220
    int64_t v27; // 0x401220
    int64_t v28; // 0x401220
    int64_t v29; // 0x401220
    int64_t v30; // 0x401220
    int128_t v31; // 0x401220
    while (true) {
      lab_0x4012e8:
        // 0x4012e8
        v29 = v28;
        v26 = v25;
        v30 = v28;
        v31 = v24;
        v27 = v25;
        if (v8 == v23) {
            goto lab_0x401481;
        } else {
            goto lab_0x4012f1;
        }
    }
  lab_0x40149a:
    // 0x40149a
    return _ZSt9terminatev();
  lab_0x401481:;
    int128_t v32 = v31;
    int128_t v33 = __asm_pxor(v32, v32); // 0x401481
    v9 = __asm_movaps(v33);
    int64_t v34 = v30; // 0x401498
    int128_t v35 = v33; // 0x401498
    int64_t v36 = 0; // 0x401498
    int64_t v37 = v27; // 0x401498
    int64_t v38 = 0; // 0x401498
  lab_0x401426:;
    int64_t v39 = v38;
    int64_t v40 = v37;
    int64_t v41 = v36;
    int128_t v42 = v35;
    int64_t v43 = v34;
    int64_t v44 = _ZNSo9_M_insertImEERSoT_((int64_t)&g2); // 0x40142e
    _ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l((int64_t *)v44, "\n", 1);
    int64_t v45 = v39; // 0x40144b
    if (v41 != v39) {
        if (*(int64_t *)v45 != 0) {
            return _ZSt9terminatev();
        }
        int64_t v46 = v45 + 8; // 0x401456
        v45 = v46;
        while (v46 != v41) {
            // 0x401450
            if (*(int64_t *)v45 != 0) {
                return _ZSt9terminatev();
            }
            // 0x401456
            v46 = v45 + 8;
            v45 = v46;
        }
    }
    // 0x40145f
    v28 = v43;
    v24 = v42;
    v25 = v40;
    if (v39 == 0) {
        goto lab_0x4012e8;
    } else {
        // 0x401468
        _ZdlPvm((int64_t *)v39, -v39);
        v29 = v43;
        v26 = v40;
        v30 = v43;
        v31 = v42;
        v27 = v40;
        if (v8 != v23) {
            goto lab_0x4012f1;
        } else {
            goto lab_0x401481;
        }
    }
  lab_0x4012f1:;
    int128_t v47 = __asm_movq(v26); // 0x401300
    int64_t v48 = v26 + 0x989680; // 0x401305
    int64_t v49 = v23 + 8; // 0x40130e
    int128_t v50 = __asm_punpcklqdq(v47, __asm_movq(v48)); // 0x401317
    __asm_movups(*(int128_t *)*(int64_t *)v23, v50);
    int64_t v51 = v48; // 0x401321
    int64_t v52 = v49; // 0x401321
    while (v49 != v8) {
        // 0x401300
        v47 = __asm_movq(v51);
        v48 = v51 + 0x989680;
        v49 = v52 + 8;
        v50 = __asm_punpcklqdq(v47, __asm_movq(v48));
        __asm_movups(*(int128_t *)*(int64_t *)v52, v50);
        v51 = v48;
        v52 = v49;
    }
    int128_t v53 = __asm_pxor(v50, v50); // 0x401323
    v9 = __asm_movaps(v53);
    int64_t v54 = v29; // 0x401341
    int64_t v55 = v23; // 0x401341
    int64_t v56 = 0; // 0x401341
    int64_t v57; // 0x401220
    while (true) {
        int64_t v58 = v56;
        int64_t v59 = v55;
        int64_t v60 = *(int64_t *)v59; // 0x4013ab
        int64_t v61 = v60; // bp-136, 0x4013ae
        int64_t v62; // 0x401220
        int64_t v63; // 0x401220
        if (v58 != 0) {
            // 0x401348
            *(int64_t *)v58 = 0;
            int64_t v64 = _Znwm(24); // 0x401355
            *(int64_t *)v64 = (int64_t)&g1;
            *(int64_t *)(v64 + 8) = v60;
            *(int64_t *)(v64 + 16) = 0x4015e0;
            int64_t v65 = v64; // bp-128, 0x40137a
            _ZNSt6thread15_M_start_threadESt10unique_ptrINS_6_StateESt14default_deleteIS1_EEPFvvE(v58, (void (*)())&v65);
            int64_t v66 = v58 + 8; // 0x401394
            int64_t v67 = v59 + 8; // 0x401398
            v63 = v66;
            v62 = v67;
            v57 = v66;
            if (v8 == v67) {
                // break -> 0x4013dd
                break;
            }
        } else {
            // 0x4013b8
            _ZNSt6vectorISt6threadSaIS0_EE17_M_realloc_insertIJRFvP6workerERS5_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_(&v9, v58, 0x4015e0, &v61, v60);
            int64_t v68 = v59 + 8; // 0x4013cf
            v63 = v54;
            v62 = v68;
            v57 = v54;
            if (v8 == v68) {
                // break -> 0x4013dd
                break;
            }
        }
        // 0x4013a6
        v54 = v63;
        v55 = v62;
        v56 = v63;
    }
    int64_t v69 = v57;
    int64_t v70 = v9; // 0x4013e8
    if (v9 != v69) {
        _ZNSt6thread4joinEv();
        int64_t v71 = v70 + 8; // 0x4013f8
        v70 = v71;
        while (v69 != v71) {
            // 0x4013f0
            _ZNSt6thread4joinEv();
            v71 = v70 + 8;
            v70 = v71;
        }
    }
    int64_t v72 = v23; // 0x401404
    while (true) {
        int64_t v73 = *(int64_t *)v72; // 0x401408
        int64_t buf = *(int64_t *)(v73 + 24); // 0x401414
        write(1, (int64_t *)buf, (int32_t)*(int64_t *)(v73 + 32));
        int64_t v74 = v72 + 8; // 0x40141d
        v72 = v74;
        v34 = v69;
        v35 = v53;
        v36 = v69;
        v37 = 0x989680 * (v8 - 8 - v23) / 8 + 0x989680 + v26;
        v38 = v9;
        if (v8 == v74) {
            goto lab_0x401426;
        }
    }
}

// Address range: 0x401c40 - 0x401c4d
// From class:    std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker*), worker*> > >
// Type:          virtual member function
// Demangled:     std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker*), worker*> > >::_M_run()
int64_t _ZNSt6thread11_State_implINS_8_InvokerISt5tupleIJPFvP6workerES4_EEEEE6_M_runEv(int64_t * result) {
    // 0x401c40
    return *(int64_t *)((int64_t)result + 16);
}

// Address range: 0x401c50 - 0x401c5c
// From class:    std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker*), worker*> > >
// Type:          constructor
// Demangled:     std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker*), worker*> > >::~_State_impl()
int64_t _ZNSt6thread11_State_implINS_8_InvokerISt5tupleIJPFvP6workerES4_EEEEED1Ev(int64_t * result) {
    // 0x401c50
    *result = (int64_t)&g1;
    return _ZNSt6thread6_StateD2Ev();
}

// Address range: 0x401c60 - 0x401c7e
// From class:    std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker*), worker*> > >
// Type:          constructor
// Demangled:     std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker*), worker*> > >::~_State_impl()
int64_t _ZNSt6thread11_State_implINS_8_InvokerISt5tupleIJPFvP6workerES4_EEEEED0Ev(int64_t * result) {
    // 0x401c60
    *result = (int64_t)&g1;
    _ZNSt6thread6_StateD2Ev();
    return _ZdlPvm(result, 24);
}

// Address range: 0x401c80 - 0x401e81
// Demangled:     void std::vector<std::thread, std::allocator<std::thread> >::_M_realloc_insert<void (&)(worker*), worker*&>(__gnu_cxx::__normal_iterator<std::thread*, std::vector<std::thread, std::allocator<std::thread> > >, void (&)(worker*), worker*&)
void _ZNSt6vectorISt6threadSaIS0_EE17_M_realloc_insertIJRFvP6workerERS5_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_(int64_t * a1, int64_t a2, int64_t a3, int64_t * a4, int64_t a5) {
    int64_t v1 = (int64_t)a1;
    int64_t v2 = v1;
    int64_t v3 = *(int64_t *)(v1 + 8); // 0x401c8e
    uint64_t v4 = v3 - v1 >> 3; // 0x401cb3
    int64_t v5; // 0x401c80
    if (v4 == 0xfffffffffffffff) {
        int64_t v6 = _ZSt20__throw_length_errorPKc("vector::_M_realloc_insert"); // 0x401e32
        while (true) {
          lab_0x401e44:
            // 0x401e44
            function_401060(v6);
            if (v5 == 0) {
                goto lab_0x401e5e;
            } else {
                // 0x401e4e
                _ZdlPvm((int64_t *)v5, 0xfffffffffffffff);
                // 0x401e59
                function_401120();
                goto lab_0x401e5e;
            }
        }
    }
    uint64_t v7 = (v4 != 0 ? v4 : 1) + v4; // 0x401cd5
    int64_t v8 = 0x7ffffffffffffff8; // 0x401ce4
    int64_t v9; // 0x401c80
    int64_t v10; // 0x401c80
    if (v7 < v4) {
        goto lab_0x401dfa;
    } else {
        // 0x401cea
        v9 = v7;
        v10 = 0;
        if (v7 != 0) {
            // 0x401e0a
            v8 = 8 * (v7 < 0xfffffffffffffff ? v7 : 0xfffffffffffffff);
            goto lab_0x401dfa;
        } else {
            goto lab_0x401cf6;
        }
    }
  lab_0x401e5e:
    if (v5 == 0) {
        // 0x401e59
        function_401120();
        goto lab_0x401e5e;
    } else {
        int64_t v11 = _ZSt9terminatev(); // 0x401e64
        function_401150();
        _Unwind_Resume((struct _Unwind_Exception *)v11);
        goto lab_0x401e44;
    }
  lab_0x401dfa:;
    int64_t v12 = _Znwm(v8); // 0x401dfd
    v9 = v8;
    v10 = v12;
    goto lab_0x401cf6;
  lab_0x401cf6:;
    int64_t v13 = v10 + a2 - v1; // 0x401cf6
    *(int64_t *)v13 = 0;
    int64_t v14 = _Znwm(24); // 0x401d05
    int64_t v15 = v14; // bp-64, 0x401d14
    *(int64_t *)v14 = (int64_t)&g1;
    *(int64_t *)(v14 + 16) = a3;
    *(int64_t *)(v14 + 8) = (int64_t)a4;
    _ZNSt6thread15_M_start_threadESt10unique_ptrINS_6_StateESt14default_deleteIS1_EEPFvvE(v13, (void (*)())&v15);
    v2 = v15;
    int64_t v16 = v10; // 0x401d5f
    int64_t v17 = v10; // 0x401d5f
    if (v1 != a2) {
        int64_t v18 = v1 + 8; // 0x401d6b
        *(int64_t *)v16 = *(int64_t *)v1;
        int64_t v19 = v18; // 0x401d7a
        v16 += 8;
        v17 = v13;
        while (v18 != a2) {
            // 0x401d68
            v18 = v19 + 8;
            *(int64_t *)v16 = *(int64_t *)v19;
            v19 = v18;
            v16 += 8;
            v17 = v13;
        }
    }
    int64_t v20 = v17 + 8; // 0x401d85
    int64_t v21 = v20; // 0x401d8c
    if (v3 != a2) {
        int64_t v22 = v3 - a2; // 0x401d97
        v21 = v22 + (int64_t)memcpy((int64_t *)v20, (int64_t *)a2, (int32_t)v22);
    }
    int128_t v23 = __asm_punpcklqdq(__asm_movq(v10), __asm_movq(v21)); // 0x401db2
    int64_t * v24 = (int64_t *)(v1 + 16);
    if (a1 == NULL) {
        // 0x401dd3
        __asm_movups(*(int128_t *)&v2, v23);
        *v24 = v10 + v9;
        return;
    }
    int64_t v25 = __asm_movaps(v23); // 0x401dc2
    _ZdlPvm(a1, *v24 - v1);
    // 0x401dd3
    __asm_movups(*(int128_t *)&v2, __asm_movdqa((int128_t)v25));
    *v24 = v10 + v9;
}

// Address range: 0x401e90 - 0x401ff0
// Demangled:     void std::vector<worker*, std::allocator<worker*> >::_M_realloc_insert<worker*>(__gnu_cxx::__normal_iterator<worker**, std::vector<worker*, std::allocator<worker*> > >, worker*&&)
void _ZNSt6vectorIP6workerSaIS1_EE17_M_realloc_insertIJS1_EEEvN9__gnu_cxx17__normal_iteratorIPS1_S3_EEDpOT_(int64_t * this, int64_t * result, int64_t a3, int64_t a4) {
    int64_t v1 = (int64_t)this;
    int64_t v2 = v1;
    int64_t v3 = *(int64_t *)(v1 + 8); // 0x401eab
    uint64_t v4 = v3 - v1 >> 3; // 0x401eb8
    if (v4 == 0xfffffffffffffff) {
        // 0x401fdb
        _ZSt20__throw_length_errorPKc("vector::_M_realloc_insert");
        return;
    }
    int64_t v5 = (int64_t)result;
    uint64_t v6 = (v4 != 0 ? v4 : 1) + v4; // 0x401ed9
    int64_t v7 = v5 - v1; // 0x401ee2
    int64_t v8 = 0x7ffffffffffffff8; // 0x401ee8
    int64_t v9; // 0x401e90
    int64_t v10; // 0x401e90
    int64_t v11; // 0x401e90
    if (v6 < v4) {
        goto lab_0x401fa2;
    } else {
        if (v6 != 0) {
            // 0x401fc0
            v8 = 8 * (v6 < 0xfffffffffffffff ? v6 : 0xfffffffffffffff);
            goto lab_0x401fa2;
        } else {
            // 0x401ef7
            v2 = 0;
            v9 = 0;
            v11 = v7;
            v10 = 0;
            goto lab_0x401efb;
        }
    }
  lab_0x401fa2:;
    int64_t v12 = _Znwm(v8); // 0x401fa9
    v2 = v12;
    v9 = v12;
    v11 = 0x100000000 * v7 >> 32;
    v10 = v12 + v8;
    goto lab_0x401efb;
  lab_0x401efb:;
    int64_t v13 = v11;
    int64_t v14 = v13 + v9;
    int64_t v15 = v14 + 8; // 0x401efe
    int64_t v16 = v3 - v5; // 0x401f03
    int128_t v17 = __asm_movq(v9); // 0x401f06
    int64_t * v18 = (int64_t *)(v1 + 16); // 0x401f0b
    *(int64_t *)v14 = v13;
    int64_t v19 = __asm_movaps(__asm_punpcklqdq(v17, __asm_movq(v15 + v16))); // 0x401f20
    int128_t v20; // 0x401f33
    if (v13 >= 0 == (v13 != 0)) {
        // 0x401f50
        memmove((int64_t *)v2, this, (int32_t)v13);
        if (v16 >= 0 == (v16 != 0)) {
            goto lab_0x401f80;
        } else {
            goto lab_0x401f67;
        }
    } else {
        if (v16 >= 0 == (v16 != 0)) {
            goto lab_0x401f80;
        } else {
            if (this == NULL) {
                // 0x401f33
                v20 = __asm_movdqa((int128_t)(int32_t)v19);
                *v18 = v10;
                __asm_movups(*(int128_t *)&v2, v20);
                return;
            }
            goto lab_0x401f67;
        }
    }
  lab_0x401f80:
    // 0x401f80
    memcpy((int64_t *)v15, result, (int32_t)v16);
    if (this == NULL) {
        // 0x401f33
        v20 = __asm_movdqa((int128_t)(int32_t)v19);
        *v18 = v10;
        __asm_movups(*(int128_t *)&v2, v20);
        return;
    }
    goto lab_0x401f67;
  lab_0x401f67:
    // 0x401f67
    _ZdlPvm(this, *v18 - v1);
    // 0x401f33
    v20 = __asm_movdqa((int128_t)(int32_t)v19);
    *v18 = v10;
    __asm_movups(*(int128_t *)&v2, v20);
}

// --------------- Dynamically Linked Functions ---------------

// int64_t __cxa_begin_catch(void);
// int64_t __cxa_end_catch(void);
// int64_t __cxa_rethrow(void);
// void _Unwind_Resume(struct _Unwind_Exception * object);
// int64_t _ZdlPvm(int64_t * a1, int64_t a2);
// int64_t _Znam(int64_t a1);
// int64_t _ZNSo9_M_insertImEERSoT_(int64_t a1);
// int64_t _ZNSt6thread15_M_start_threadESt10unique_ptrINS_6_StateESt14default_deleteIS1_EEPFvvE(int64_t a1, void (*a2)());
// int64_t _ZNSt6thread20hardware_concurrencyEv(void);
// int64_t _ZNSt6thread4joinEv(void);
// int64_t _ZNSt6thread6_StateD2Ev(void);
// int64_t _Znwm(int64_t a1);
// int64_t _ZSt16__ostream_insertIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_PKS3_l(int64_t * a1, char * a2, int32_t a3);
// int64_t _ZSt20__throw_length_errorPKc(char * a1);
// int64_t _ZSt9terminatev(void);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memmove(void * dest, const void * src, size_t n);
// ssize_t write(int fd, const void * buf, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.1.1)
// Detected functions: 9

