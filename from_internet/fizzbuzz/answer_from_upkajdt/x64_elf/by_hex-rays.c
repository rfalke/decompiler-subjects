/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_401020(); // weak
// _QWORD __fastcall operator new[](unsigned __int64); idb
// void __noreturn std::terminate(void); idb
// ssize_t write(int fd, const void *buf, size_t n);
// void *__fastcall __cxa_begin_catch(void *);
// void __fastcall std::thread::_State::~_State(std::thread::_State *__hidden this); idb
// void __fastcall __noreturn std::__throw_length_error(const char *); idb
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// __int64 __fastcall std::ostream::_M_insert<unsigned long>(_QWORD, _QWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// int __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle);
// __int64 __fastcall std::thread::_M_start_thread(_QWORD, _QWORD, _QWORD); weak
// _QWORD __fastcall operator new(unsigned __int64); idb
// void __fastcall operator delete(void *, unsigned __int64); idb
// __int64 __fastcall std::__ostream_insert<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD); weak
// _QWORD std::thread::hardware_concurrency(std::thread *__hidden this); idb
// void __noreturn __cxa_rethrow(void);
// _QWORD std::ios_base::Init::Init(std::ios_base::Init *__hidden this); idb
// void *memmove(void *dest, const void *src, size_t n);
// _QWORD std::thread::join(std::thread *__hidden this); idb
// void _Unwind_Resume(struct _Unwind_Exception *);
// void __fastcall std::ios_base::Init::~Init(void *); idb
void __fastcall __noreturn main_cold(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, void *, __int64, __int64);
int __cdecl main(int argc, const char **argv, const char **envp);
int GLOBAL__sub_I__Z4taskP6worker();
void __fastcall task(unsigned __int64 *);
__int64 __fastcall std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker *),worker *>>>::_M_run(__int64);
void __fastcall std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker *),worker *>>>::~_State_impl(std::thread::_State *);
void __fastcall std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker *),worker *>>>::~_State_impl(void *);
void __fastcall std::vector<std::thread>::_M_realloc_insert<void (&)(worker *),worker *&>(__int64, __int64 *, __int64, __int64);
void __fastcall std::vector<worker *>::_M_realloc_insert<worker *>(__int64, _BYTE *, __int64 *);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN _dso_handle; // weak
__int64 (__fastcall *off_4030B0)() = &std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker *),worker *>>>::~_State_impl; // weak
__int64 (*qword_405010)(void) = NULL; // weak
_UNKNOWN std::cerr; // weak
_UNKNOWN std::__ioinit; // weak


//----- (0000000000401020) ----------------------------------------------------
__int64 sub_401020()
{
  return qword_405010();
}
// 401020: using guessed type __int64 __fastcall sub_401020();
// 405010: using guessed type __int64 (*qword_405010)(void);

//----- (00000000004011A0) ----------------------------------------------------
void __fastcall __noreturn main_cold(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        void *a10,
        __int64 a11,
        __int64 a12)
{
  struct _Unwind_Exception *v12; // rbx
  void *v13; // rbp

  operator delete(v13, 0x28uLL);
  if ( a10 )
    operator delete(a10, a12 - (_QWORD)a10);
  _Unwind_Resume(v12);
}
// 4011AB: variable 'v13' is possibly undefined
// 4011CA: variable 'v12' is possibly undefined

//----- (0000000000401220) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v4; // r13
  _BYTE *v5; // r12
  __int64 v6; // rbx
  std::thread *v7; // rax
  std::thread *v8; // rbp
  __int64 v9; // rax
  __m128i **v10; // r12
  __m128i **v11; // r13
  unsigned __int64 v12; // r14
  __m128i **v13; // rdx
  unsigned __int64 v14; // rax
  __m128i v15; // xmm0
  __m128i *v16; // rcx
  __int64 *v17; // rbx
  __int64 v18; // rax
  __int64 *v19; // rbp
  _QWORD *v20; // rax
  __int64 v21; // r15
  std::thread *v22; // r15
  std::thread *v23; // rbx
  __m128i **v24; // rbx
  __int64 v25; // rax
  __int64 *v26; // rax
  unsigned __int64 v27; // [rsp+8h] [rbp-90h]
  __int64 v28; // [rsp+10h] [rbp-88h] BYREF
  _QWORD *v29; // [rsp+18h] [rbp-80h] BYREF
  __int128 v30; // [rsp+20h] [rbp-78h] BYREF
  _BYTE *v31; // [rsp+30h] [rbp-68h]
  std::thread *v32[2]; // [rsp+40h] [rbp-58h] BYREF
  __int64 v33; // [rsp+50h] [rbp-48h]

  v3 = std::thread::hardware_concurrency(*(std::thread **)&argc);
  v31 = 0LL;
  v4 = v3;
  v30 = 0LL;
  if ( v3 )
  {
    v5 = 0LL;
    v6 = 0LL;
    while ( 1 )
    {
      v7 = (std::thread *)operator new(0x28uLL);
      *((_QWORD *)v7 + 2) = 10000000LL;
      v8 = v7;
      *((_QWORD *)v7 + 3) = operator new[](0x17D78400uLL);
      v9 = *((_QWORD *)&v30 + 1);
      v32[0] = v8;
      if ( *((_BYTE **)&v30 + 1) == v5 )
      {
        std::vector<worker *>::_M_realloc_insert<worker *>((__int64)&v30, v5, (__int64 *)v32);
        if ( v4 == ++v6 )
          break;
      }
      else
      {
        **((_QWORD **)&v30 + 1) = v8;
        ++v6;
        *((_QWORD *)&v30 + 1) = v9 + 8;
        if ( v4 == v6 )
          break;
      }
      v5 = v31;
    }
  }
  v10 = (__m128i **)*((_QWORD *)&v30 + 1);
  v11 = (__m128i **)v30;
  v12 = 0LL;
  v27 = 10000000 * (((unsigned __int64)(*((_QWORD *)&v30 + 1) - 8LL - v30) >> 3) + 1);
  while ( v10 == v11 )
  {
    while ( 1 )
    {
      v22 = 0LL;
      v19 = 0LL;
      v33 = 0LL;
      *(_OWORD *)v32 = 0LL;
LABEL_22:
      v25 = std::ostream::_M_insert<unsigned long>(&std::cerr, v12);
      std::__ostream_insert<char,std::char_traits<char>>(v25, "\n", 1LL);
      v26 = (__int64 *)v22;
      if ( v19 != (__int64 *)v22 )
      {
        do
        {
          if ( *v26 )
            std::terminate();
          ++v26;
        }
        while ( v26 != v19 );
      }
      if ( !v22 )
        break;
      operator delete(v22, v33 - (_QWORD)v22);
      if ( v10 != v11 )
        goto LABEL_9;
    }
  }
LABEL_9:
  v13 = v11;
  v14 = v12;
  do
  {
    v15 = (__m128i)v14;
    v14 += 10000000LL;
    v16 = *v13++;
    *v16 = _mm_unpacklo_epi64(v15, (__m128i)v14);
  }
  while ( v13 != v10 );
  v12 += v27;
  v17 = (__int64 *)v11;
  v18 = 0LL;
  v33 = 0LL;
  v19 = 0LL;
  *(_OWORD *)v32 = 0LL;
  while ( 1 )
  {
    v21 = *v17;
    v28 = *v17;
    if ( v19 == (__int64 *)v18 )
    {
      std::vector<std::thread>::_M_realloc_insert<void (&)(worker *),worker *&>(
        (__int64)v32,
        v19,
        (__int64)task,
        (__int64)&v28);
      ++v17;
      v19 = (__int64 *)v32[1];
      if ( v10 == (__m128i **)v17 )
        goto LABEL_18;
    }
    else
    {
      *v19 = 0LL;
      v20 = (_QWORD *)operator new(0x18uLL);
      *v20 = &off_4030B0;
      v20[1] = v21;
      v20[2] = task;
      v29 = v20;
      std::thread::_M_start_thread(v19, &v29, pthread_create);
      if ( v29 )
        (*(void (__fastcall **)(_QWORD *))(*v29 + 8LL))(v29);
      ++v19;
      ++v17;
      v32[1] = (std::thread *)v19;
      if ( v10 == (__m128i **)v17 )
      {
LABEL_18:
        v22 = v32[0];
        v23 = v32[0];
        if ( (__int64 *)v32[0] != v19 )
        {
          do
          {
            std::thread::join(v23);
            v23 = (std::thread *)((char *)v23 + 8);
          }
          while ( v19 != (__int64 *)v23 );
        }
        v24 = v11;
        do
        {
          write(1, (const void *)(*v24)[1].m128i_i64[1], (*v24)[2].m128i_u64[0]);
          ++v24;
        }
        while ( v10 != v24 );
        goto LABEL_22;
      }
    }
    v18 = v33;
  }
}
// 401220: variables would overlap: edi.4 and rdi.8
// 4010A0: using guessed type __int64 __fastcall std::ostream::_M_insert<unsigned long>(_QWORD, _QWORD);
// 4010D0: using guessed type __int64 __fastcall std::thread::_M_start_thread(_QWORD, _QWORD, _QWORD);
// 401100: using guessed type __int64 __fastcall std::__ostream_insert<char,std::char_traits<char>>(_QWORD, _QWORD, _QWORD);
// 4030B0: using guessed type __int64 (__fastcall *off_4030B0)();

//----- (00000000004014C0) ----------------------------------------------------
int GLOBAL__sub_I__Z4taskP6worker()
{
  std::ios_base::Init::Init((std::ios_base::Init *)&std::__ioinit);
  return __cxa_atexit(std::ios_base::Init::~Init, &std::__ioinit, &_dso_handle);
}

//----- (00000000004015E0) ----------------------------------------------------
void __fastcall task(unsigned __int64 *a1)
{
  __int64 v1; // rbp
  __int64 v2; // r11
  _DWORD *v3; // rsi
  unsigned __int64 v4; // rcx
  char v6; // di
  __int64 v7; // rbx
  __int64 v8; // rax
  _BYTE *v9; // rax
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // r13
  unsigned __int64 v12; // r14
  unsigned __int64 v13; // r11
  unsigned __int64 v14; // r12
  unsigned __int64 v15; // rdx
  char v16; // r11
  unsigned __int64 v17; // rdx
  char v18; // r12
  unsigned __int64 v19; // rdx
  char v20; // r11
  unsigned __int64 v21; // rdx
  char v22; // r12
  unsigned __int64 v23; // rdx
  char v24; // r11
  unsigned __int64 v25; // rdx
  char v26; // r12
  unsigned __int64 v27; // rdx
  char v28; // r11
  unsigned __int64 v29; // rdx
  char v30; // r12
  unsigned __int64 v31; // rdx
  __int64 v32; // rax
  char *v33; // r12
  __int64 v34; // r14
  char *v35; // r12
  unsigned __int64 v36; // rax
  unsigned __int64 v37; // r15
  signed __int64 v38; // r12
  unsigned int v39; // eax
  unsigned int v40; // eax
  unsigned int v41; // edx
  _DWORD *v42; // r13
  __int64 v43; // rsi
  unsigned __int64 v44; // r14
  signed __int64 v45; // r12
  unsigned int v46; // ebx
  __int64 v47; // r13
  unsigned __int64 v48; // [rsp+0h] [rbp-60h]
  char v49[15]; // [rsp+8h] [rbp-58h] BYREF
  char v50; // [rsp+17h] [rbp-49h]
  __int64 v51; // [rsp+38h] [rbp-28h]

  v3 = (_DWORD *)a1[3];
  v4 = *a1;
  if ( *a1 >= a1[1] )
  {
    a1[4] = 0LL;
  }
  else
  {
    v6 = 0;
    v51 = v1;
    v7 = -100LL;
    while ( 1 )
    {
      while ( 1 )
      {
        v8 = v4 - (v4 / 5 + (((0xCCCCCCCCCCCCCCCDLL * (unsigned __int128)v4) >> 64) & 0xFFFFFFFFFFFFFFFCLL));
        if ( v8 | (v4 - (v4 / 3 + (((0xAAAAAAAAAAAAAAABLL * (unsigned __int128)v4) >> 64) & 0xFFFFFFFFFFFFFFFELL))) )
        {
          if ( v4 == v4 / 3 + (((0xAAAAAAAAAAAAAAABLL * (unsigned __int128)v4) >> 64) & 0xFFFFFFFFFFFFFFFELL) )
          {
            *v3 = 2054842694;
            v9 = v3 + 1;
          }
          else if ( v8 )
          {
            if ( v4 - v7 <= 9 && v6 + (char)v1 <= 9 )
            {
              if ( v2 != 15 )
              {
                v34 = 15 - v2;
                v35 = &v49[v2];
                if ( (unsigned int)(15 - v2) >= 8 )
                {
                  *(_QWORD *)v3 = *(_QWORD *)v35;
                  *(_QWORD *)((char *)v3 + (unsigned int)v34 - 8) = *(_QWORD *)&v35[(unsigned int)v34 - 8];
                  v36 = (unsigned __int64)(v3 + 2) & 0xFFFFFFFFFFFFFFF8LL;
                  v37 = v36;
                  v38 = v35 - ((char *)v3 - v36);
                  v39 = (v34 + (_DWORD)v3 - v36) & 0xFFFFFFF8;
                  if ( v39 >= 8 )
                  {
                    v48 = v4;
                    v40 = v39 & 0xFFFFFFF8;
                    v41 = 0;
                    v42 = v3;
                    do
                    {
                      v43 = v41;
                      v41 += 8;
                      *(_QWORD *)(v37 + v43) = *(_QWORD *)(v38 + v43);
                    }
                    while ( v41 < v40 );
                    v4 = v48;
                    v3 = v42;
                  }
                }
                else if ( (v34 & 4) != 0 )
                {
                  *v3 = *(_DWORD *)v35;
                  *(_DWORD *)((char *)v3 + (unsigned int)v34 - 4) = *(_DWORD *)&v35[(unsigned int)v34 - 4];
                }
                else if ( (_DWORD)v34 )
                {
                  *(_BYTE *)v3 = *v35;
                  if ( (v34 & 2) != 0 )
                    *(_WORD *)((char *)v3 + (unsigned int)v34 - 2) = *(_WORD *)&v35[(unsigned int)v34 - 2];
                }
                v3 = (_DWORD *)((char *)v3 + v34);
              }
              v9 = (char *)v3 + 1;
              *(_BYTE *)v3 = v50 + v6 - v1;
            }
            else
            {
              v10 = v4 / 0xA;
              LODWORD(v1) = v4 % 0xA;
              v50 = v4 % 0xA + 48;
              if ( v4 <= 9 )
              {
                v2 = 15LL;
              }
              else
              {
                v11 = v10 / 0xA;
                v49[14] = v10 % 0xA + 48;
                if ( v4 <= 0x63 )
                {
                  v2 = 14LL;
                }
                else
                {
                  v12 = v11 / 0xA;
                  v49[13] = v11 % 0xA + 48;
                  if ( v4 <= 0x3E7 )
                  {
                    v2 = 13LL;
                  }
                  else
                  {
                    v13 = v12 / 0xA;
                    v49[12] = v12 % 0xA + 48;
                    if ( v4 <= 0x270F )
                    {
                      v2 = 12LL;
                    }
                    else
                    {
                      v14 = v13 / 0xA;
                      v49[11] = v13 % 0xA + 48;
                      if ( v4 <= 0x1869F )
                      {
                        v2 = 11LL;
                      }
                      else
                      {
                        v15 = v13 / 0xA / 0xA;
                        v16 = v15;
                        v49[10] = v14 - 10 * v15 + 48;
                        if ( v4 <= 0xF423F )
                        {
                          v2 = 10LL;
                        }
                        else
                        {
                          v17 = v15 / 0xA;
                          v18 = v17;
                          v49[9] = v16 - 10 * v17 + 48;
                          if ( v4 <= 0x98967F )
                          {
                            v2 = 9LL;
                          }
                          else
                          {
                            v19 = v17 / 0xA;
                            v20 = v19;
                            v49[8] = v18 - 10 * v19 + 48;
                            if ( v4 <= 0x5F5E0FF )
                            {
                              v2 = 8LL;
                            }
                            else
                            {
                              v21 = v19 / 0xA;
                              v22 = v21;
                              v49[7] = v20 - 10 * v21 + 48;
                              if ( v4 <= 0x3B9AC9FF )
                              {
                                v2 = 7LL;
                              }
                              else
                              {
                                v23 = v21 / 0xA;
                                v24 = v23;
                                v49[6] = v22 - 10 * v23 + 48;
                                if ( v4 <= 0x2540BE3FFLL )
                                {
                                  v2 = 6LL;
                                }
                                else
                                {
                                  v25 = v23 / 0xA;
                                  v26 = v25;
                                  v49[5] = v24 - 10 * v25 + 48;
                                  if ( v4 <= 0x174876E7FFLL )
                                  {
                                    v2 = 5LL;
                                  }
                                  else
                                  {
                                    v27 = v25 / 0xA;
                                    v28 = v27;
                                    v49[4] = v26 - 10 * v27 + 48;
                                    if ( v4 <= 0xE8D4A50FFFLL )
                                    {
                                      v2 = 4LL;
                                    }
                                    else
                                    {
                                      v29 = v27 / 0xA;
                                      v30 = v29;
                                      v49[3] = v28 - 10 * v29 + 48;
                                      if ( v10 <= 0xE8D4A50FFFLL )
                                      {
                                        v2 = 3LL;
                                      }
                                      else
                                      {
                                        v31 = v29 / 0xA;
                                        v49[2] = v30 - 10 * v31 + 48;
                                        if ( v11 <= 0xE8D4A50FFFLL )
                                        {
                                          v2 = 2LL;
                                        }
                                        else
                                        {
                                          v49[1] = v31 % 0xA + 48;
                                          if ( v12 <= 0xE8D4A50FFFLL )
                                          {
                                            v2 = 1LL;
                                          }
                                          else
                                          {
                                            v2 = 0LL;
                                            v49[0] = v31 / 0xA % 0xA + 48;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              v32 = 16 - v2;
              if ( (unsigned __int64)(v2 + 1) > 0x10 )
                v32 = 1LL;
              v33 = &v49[v2];
              if ( (unsigned int)v32 >= 8 )
              {
                v44 = (unsigned __int64)(v3 + 2) & 0xFFFFFFFFFFFFFFF8LL;
                *(_QWORD *)v3 = *(_QWORD *)v33;
                *(_QWORD *)((char *)v3 + (unsigned int)v32 - 8) = *(_QWORD *)&v33[(unsigned int)v32 - 8];
                v45 = v33 - ((char *)v3 - v44);
                if ( (((_DWORD)v32 + (_DWORD)v3 - (_DWORD)v44) & 0xFFFFFFF8) >= 8 )
                {
                  v46 = 0;
                  do
                  {
                    v47 = v46;
                    v46 += 8;
                    *(_QWORD *)(v44 + v47) = *(_QWORD *)(v45 + v47);
                  }
                  while ( v46 < (((_DWORD)v32 + (_DWORD)v3 - (_DWORD)v44) & 0xFFFFFFF8) );
                }
              }
              else if ( (v32 & 4) != 0 )
              {
                *v3 = *(_DWORD *)v33;
                *(_DWORD *)((char *)v3 + (unsigned int)v32 - 4) = *(_DWORD *)&v33[(unsigned int)v32 - 4];
              }
              else if ( (_DWORD)v32 )
              {
                *(_BYTE *)v3 = *v33;
                if ( (v32 & 2) != 0 )
                  *(_WORD *)((char *)v3 + (unsigned int)v32 - 2) = *(_WORD *)&v33[(unsigned int)v32 - 2];
              }
              v9 = (char *)v3 + v32;
              v7 = v4;
            }
          }
          else
          {
            *v3 = 2054845762;
            v9 = v3 + 1;
          }
        }
        else
        {
          v9 = v3 + 2;
          *(_QWORD *)v3 = 0x7A7A75427A7A6946LL;
        }
        ++v6;
        *v9 = 10;
        v3 = v9 + 1;
        ++v4;
        if ( v6 == 10 )
          break;
        if ( v4 >= a1[1] )
          goto LABEL_7;
      }
      if ( a1[1] <= v4 )
        break;
      v6 = 0;
    }
LABEL_7:
    a1[4] = (unsigned __int64)v3 - a1[3];
  }
}
// 401612: variable 'v1' is possibly undefined
// 401A24: variable 'v2' is possibly undefined

//----- (0000000000401C40) ----------------------------------------------------
__int64 __fastcall std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker *),worker *>>>::_M_run(
        __int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(a1 + 16))(*(_QWORD *)(a1 + 8));
}

//----- (0000000000401C50) ----------------------------------------------------
void __fastcall std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker *),worker *>>>::~_State_impl(
        std::thread::_State *a1)
{
  *(_QWORD *)a1 = &off_4030B0;
  std::thread::_State::~_State(a1);
}
// 4030B0: using guessed type __int64 (__fastcall *off_4030B0)();

//----- (0000000000401C60) ----------------------------------------------------
void __fastcall std::thread::_State_impl<std::thread::_Invoker<std::tuple<void (*)(worker *),worker *>>>::~_State_impl(
        void *a1)
{
  *(_QWORD *)a1 = &off_4030B0;
  std::thread::_State::~_State((std::thread::_State *)a1);
  operator delete(a1, 0x18uLL);
}
// 4030B0: using guessed type __int64 (__fastcall *off_4030B0)();

//----- (0000000000401C80) ----------------------------------------------------
void __fastcall std::vector<std::thread>::_M_realloc_insert<void (&)(worker *),worker *&>(
        __int64 a1,
        __int64 *a2,
        __int64 a3,
        __int64 a4)
{
  __int64 v4; // rax
  __int64 *v5; // r14
  __int64 v6; // r12
  __int64 v7; // rax
  bool v10; // cf
  unsigned __int64 v11; // r12
  char *v12; // r13
  char *v13; // r15
  _QWORD *v14; // rax
  __int64 *v15; // rdi
  __int64 v16; // rsi
  __int64 v17; // rdx
  __int64 *v18; // rax
  char *v19; // rdx
  char *v20; // rcx
  __int64 v21; // rcx
  char *v22; // rcx
  __m128i v23; // xmm0
  __int64 v24; // rsi
  __int64 v25; // rax
  __m128i v26; // [rsp+0h] [rbp-68h] BYREF
  __int64 v27; // [rsp+10h] [rbp-58h]
  __int64 *v28; // [rsp+18h] [rbp-50h]
  __int64 v29[8]; // [rsp+28h] [rbp-40h] BYREF

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(__int64 **)a1;
  v27 = a3;
  v26.m128i_i64[0] = v4;
  v28 = (__int64 *)a4;
  v6 = (v4 - (__int64)v5) >> 3;
  if ( v6 == 0xFFFFFFFFFFFFFFFLL )
    std::__throw_length_error("vector::_M_realloc_insert");
  v7 = 1LL;
  if ( v6 )
    v7 = v6;
  v10 = __CFADD__(v7, v6);
  v11 = v7 + v6;
  if ( v10 )
  {
    v11 = 0x7FFFFFFFFFFFFFF8LL;
  }
  else
  {
    if ( !v11 )
    {
      v12 = 0LL;
      goto LABEL_7;
    }
    v25 = 0xFFFFFFFFFFFFFFFLL;
    if ( v11 <= 0xFFFFFFFFFFFFFFFLL )
      v25 = v11;
    v11 = 8 * v25;
  }
  v12 = (char *)operator new(v11);
LABEL_7:
  v13 = &v12[(char *)a2 - (char *)v5];
  *(_QWORD *)v13 = 0LL;
  v14 = (_QWORD *)operator new(0x18uLL);
  v15 = v28;
  v16 = v27;
  v29[0] = (__int64)v14;
  *v14 = &off_4030B0;
  v17 = *v15;
  v14[2] = v16;
  v14[1] = v17;
  std::thread::_M_start_thread(v13, v29, pthread_create);
  if ( v29[0] )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v29[0] + 8LL))(v29[0]);
  v18 = v5;
  v19 = v12;
  v20 = v12;
  if ( a2 != v5 )
  {
    do
    {
      v21 = *v18++;
      v19 += 8;
      *((_QWORD *)v19 - 1) = v21;
    }
    while ( v18 != a2 );
    v20 = &v12[(char *)a2 - (char *)v5];
  }
  v22 = v20 + 8;
  if ( a2 != (__int64 *)v26.m128i_i64[0] )
    v22 = (char *)memcpy(v22, a2, v26.m128i_i64[0] - (_QWORD)a2) + v26.m128i_i64[0] - (_QWORD)a2;
  v23 = _mm_unpacklo_epi64((__m128i)(unsigned __int64)v12, (__m128i)(unsigned __int64)v22);
  if ( v5 )
  {
    v24 = *(_QWORD *)(a1 + 16);
    v26 = v23;
    operator delete(v5, v24 - (_QWORD)v5);
    v23 = _mm_load_si128(&v26);
  }
  *(__m128i *)a1 = v23;
  *(_QWORD *)(a1 + 16) = &v12[v11];
}
// 4010D0: using guessed type __int64 __fastcall std::thread::_M_start_thread(_QWORD, _QWORD, _QWORD);
// 4030B0: using guessed type __int64 (__fastcall *off_4030B0)();
// 401C80: using guessed type __int64 var_40[8];

//----- (0000000000401E90) ----------------------------------------------------
void __fastcall std::vector<worker *>::_M_realloc_insert<worker *>(__int64 a1, _BYTE *a2, __int64 *a3)
{
  __int64 v4; // r12
  _BYTE *v5; // r14
  __int64 v6; // rax
  __int64 v7; // rdx
  bool v9; // cf
  unsigned __int64 v10; // rax
  _BYTE *v11; // rdx
  char *v12; // rbx
  unsigned __int64 v13; // rdi
  __int64 v14; // rax
  _BYTE *v15; // r8
  signed __int64 v16; // r12
  __int64 v17; // r15
  __m128i v18; // xmm2
  unsigned __int64 v19; // rbx
  char *v20; // rax
  __m128i v21; // [rsp+0h] [rbp-58h] BYREF
  _BYTE *v22; // [rsp+18h] [rbp-40h]

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_BYTE **)a1;
  v6 = (v4 - *(_QWORD *)a1) >> 3;
  if ( v6 == 0xFFFFFFFFFFFFFFFLL )
    std::__throw_length_error("vector::_M_realloc_insert");
  v7 = 1LL;
  if ( v6 )
    v7 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  v9 = __CFADD__(v7, v6);
  v10 = v7 + v6;
  v11 = (_BYTE *)(a2 - v5);
  if ( v9 )
  {
    v19 = 0x7FFFFFFFFFFFFFF8LL;
  }
  else
  {
    if ( !v10 )
    {
      v12 = 0LL;
      v13 = 0LL;
      goto LABEL_7;
    }
    if ( v10 > 0xFFFFFFFFFFFFFFFLL )
      v10 = 0xFFFFFFFFFFFFFFFLL;
    v19 = 8 * v10;
  }
  v21.m128i_i64[0] = a2 - v5;
  v20 = (char *)operator new(v19);
  v11 = (_BYTE *)(a2 - v5);
  v13 = (unsigned __int64)v20;
  v12 = &v20[v19];
LABEL_7:
  v14 = *a3;
  v15 = &v11[v13 + 8];
  v16 = v4 - (_QWORD)a2;
  v17 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)&v11[v13] = v14;
  v21 = _mm_unpacklo_epi64((__m128i)v13, (__m128i)(unsigned __int64)&v15[v16]);
  if ( (__int64)v11 > 0 )
  {
    v22 = &v11[v13 + 8];
    memmove((void *)v13, v5, (size_t)v11);
    v15 = v22;
    if ( v16 <= 0 )
      goto LABEL_12;
LABEL_13:
    memcpy(v15, a2, v16);
    if ( !v5 )
      goto LABEL_10;
    goto LABEL_12;
  }
  if ( v16 > 0 )
    goto LABEL_13;
  if ( v5 )
LABEL_12:
    operator delete(v5, v17 - (_QWORD)v5);
LABEL_10:
  v18 = _mm_load_si128(&v21);
  *(_QWORD *)(a1 + 16) = v12;
  *(__m128i *)a1 = v18;
}
// 401E90: using guessed type __m128i var_58;

// nfuncs=68 queued=10 decompiled=10 lumina nreq=0 worse=0 better=0
// ALL OK, 10 function(s) have been successfully decompiled
