// subject_bss_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b404060 = 0x00; // 0000000000404060
word64 g_qw404080 = 0x00; // 0000000000404080
struct Eq_272 * g_a404088[] = // 0000000000404088
	{
	};
struct Eq_89 * g_ptr40FC00 = null; // 000000000040FC00
void g_v40FC20 = ??void??; // 000000000040FC20
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401488: void _fini()
void _fini()
{
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __libc_start_main_GOT = null; // 0000000000403FF0
<anonymous> * __gmon_start___GOT = null; // 0000000000403FF8
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * write_GOT = &g_t401036; // 0000000000404018
<anonymous> * omp_get_thread_num_GOT = &g_t401046; // 0000000000404020
<anonymous> * omp_get_num_threads_GOT = &g_t401056; // 0000000000404028
<anonymous> * sprintf_GOT = &g_t401066; // 0000000000404030
<anonymous> * GOMP_parallel_GOT = &g_t401076; // 0000000000404038
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401000: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	if (__gmon_start__ != 0x00)
		__gmon_start__();
}

// subject_init_array.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a403DF0[] = // 0000000000403DF0
	{
	};
// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> g_t401036 = <code>; // 0000000000401036
<anonymous> g_t401046 = <code>; // 0000000000401046
<anonymous> g_t401056 = <code>; // 0000000000401056
<anonymous> g_t401066 = <code>; // 0000000000401066
<anonymous> g_t401076 = <code>; // 0000000000401076
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401080: void main()
void main()
{
	ptr64 fp;
	uint64 r13_11 = 0x01;
	do
	{
		g_qw404080 = 4258848;
		uint64 rbx_23;
		struct Eq_29 * rbp_29 = &g_v40FC20;
		for (rbx_23 = 0x00; rbx_23 != 0x1771; ++rbx_23)
		{
			uint64 rdx_33 = (uint64) (word32) (r13_11 + rbx_23);
			int32 edx_34 = (word32) rdx_33;
			word32 r13d_81 = (word32) r13_11;
			if (edx_34 *s ~0x11111110 <= 0x11111111)
			{
				rbp_29->t0000.u1 = 0x7A7A75427A7A6946;
				rbp_29->w0008 = 0x0A;
				rbp_29 = (struct Eq_29 *) ((char *) &rbp_29->w0008 + 1);
			}
			else if (edx_34 *s ~0x33333332 > 0x33333333)
			{
				if (edx_34 *s ~0x55555554 <= 0x55555555)
				{
					rbp_29->t0000.u2.u2 = 0x7A7A6946;
					rbp_29->w0004 = 0x0A;
					++rbp_29;
				}
				else
					rbp_29 += (int64) sprintf(rbp_29, "%d\n", (int32) rdx_33) /64 5;
			}
			else
			{
				rbp_29->t0000.u2.u2 = 0x7A7A7542;
				rbp_29->w0004 = 0x0A;
				++rbp_29;
			}
			(&g_qw404080)[rbx_23 * 0x08] = rbp_29;
		}
		write(1, &g_v40FC20, g_ptr40FC00 - 4258848);
		r13_11 = (uint64) (r13d_81 + 0x1771);
	} while ((word32) r13_11 != 0x2EE3);
	word32 dwLoc34_234 = 0x00;
	while (true)
	{
		GOMP_parallel(0x00, 0x00401350, 0x00, fp - 0x30, fp - 0x34);
		if (dwLoc34_234 != 0x00)
		{
			struct Eq_89 * rax_129 = g_ptr40FC00;
			struct Eq_131 * rdi_131 = &g_ptr40FC00;
			struct Eq_89 * rdx_133;
			for (rdx_133 = rax_129 + (int64) dwLoc34_234; rax_129 < rdx_133; rdx_133 -= (struct Eq_162 *) 1)
			{
				byte cl_140 = rax_129->b0000;
				if (cl_140 != 0x0A)
				{
					struct Eq_89 * rsi_144 = rdx_133;
					if (cl_140 == 11)
					{
						rax_129->b0000 = 0x0A;
						rdx_133->b0000 = 0x31;
						rdi_131 -= 0x08;
						rdi_131[1] = (struct Eq_131) rdx_133;
						rsi_144 = rdx_133 - (struct Eq_186 *) 0x01;
						cl_140 = rax_129->b0000;
					}
					rsi_144->b0000 = cl_140;
					--rax_129;
					rdx_133 = rsi_144 - (struct Eq_170 *) 1;
					if (rax_129 < rdx_133)
						continue;
					break;
				}
				rdi_131 -= 0x08;
				Mem169[rdi_131 + 8:word64] = rdx_133 + 1;
				--rax_129;
				rdx_133->b0000 = (byte) rax_129[1];
			}
			dwLoc34_234 = 0x00;
		}
		write(1, &g_v40FC20, g_ptr40FC00 - 4258848);
	}
}

// 0000000000401260: void _start(Register (ptr64 Eq_191) rdx, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void _start(void (* rdx)(), word32 dwArg00, char * ptrArg08)
{
	void * fp;
	word64 qwArg00;
	__align_stack<word64>(&ptrArg08);
	__libc_start_main(&g_t401080, (int32) qwArg00, &ptrArg08, &g_t401410, &g_t401480, rdx, fp);
	__halt();
}

// 0000000000401290: void _dl_relocate_static_pie()
void _dl_relocate_static_pie()
{
}

// 00000000004012A0: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
}

// 00000000004012D0: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
}

// 0000000000401310: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	if (g_b404060 != 0x00)
		return;
	deregister_tm_clones();
	g_b404060 = 0x01;
}

// 0000000000401340: void frame_dummy()
// Called from:
//      __libc_csu_init
void frame_dummy()
{
	register_tm_clones();
}

// 0000000000401350: void main._omp_fn.0(Register (ptr64 (ptr64 word32)) rdi)
void main._omp_fn.0(word32 ** rdi)
{
	int32 ebp_39 = (word32) omp_get_num_threads();
	int32 edx_40 = (int32) (6000 % ebp_39);
	int32 esi_42 = (word32) omp_get_thread_num();
	int32 eax_41 = (int32) (6000 /32 ebp_39);
	word64 rdx_189 = SEQ(SLICE(rdx_26, word32, 32), edx_40);
	if (esi_42 < edx_40)
	{
		++eax_41;
		rdx_189 = 0x00;
	}
	int32 esi_62 = esi_42 *s eax_41 + (word32) rdx_189;
	int32 eax_65 = eax_41 + esi_62;
	if (esi_62 < eax_65)
	{
		int64 rsi_114 = (int64) esi_62;
		do
		{
			struct Eq_272 * rdi_71 = *((char *) g_a404088 + rsi_114 * 0x08);
			if (rdi_71->bFFFFFFFE != 122)
			{
				uint64 rdx_79 = (uint64) ((word32) rdi_71->bFFFFFFFB + 0x06);
				ci8 dl_80 = (byte) rdx_79;
				rdi_71->bFFFFFFFB = dl_80;
				struct Eq_285 * rcx_103 = rdi_71 - 5;
				word32 edx_137 = (word32) rdx_79;
				if (dl_80 > 0x39)
				{
					do
					{
						uint64 rdi_87 = (uint64) rcx_103->bFFFFFFFF;
						--rcx_103;
						rcx_103[1] = (struct Eq_285) ((byte) edx_137 - 0x0A);
						uint64 rdx_95 = (uint64) ((word32) rdi_87 + 0x01);
						ci8 dl_96 = (byte) rdx_95;
						rcx_103->b0000 = dl_96;
						edx_137 = (word32) rdx_95;
					} while (dl_96 > 0x39);
				}
				if ((&g_qw404080)[rsi_114 * 0x08] > rcx_103)
				{
					word32 * rdx_109 = *rdi;
					__lock();
					++*rdx_109;
				}
			}
			++rsi_114;
		} while (eax_65 > (word32) rsi_114);
	}
}

// 0000000000401410: void __libc_csu_init(Register word64 rdx, Register word64 rsi, Register word32 edi)
void __libc_csu_init(word64 rdx, word64 rsi, word32 edi)
{
	word64 rdi;
	word32 edi = (word32) rdi;
	_init();
	int64 rbp_31 = 0x00403DF8 - g_a403DF0;
	if (rbp_31 >> 0x03 != 0x00)
	{
		Eq_363 rbx_45 = 0x00;
		do
		{
			(*((char *) g_a403DF0 + rbx_45 * 0x08))();
			rbx_45 = (word64) rbx_45.u1 + 1;
		} while (rbp_31 >> 0x03 != rbx_45);
	}
}

// 0000000000401480: void __libc_csu_fini()
void __libc_csu_fini()
{
}

