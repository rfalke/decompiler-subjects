// subject_bss_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b404060 = 0x00; // 0000000000404060
word64 g_qw404080 = 0x00; // 0000000000404080
struct Eq_258 * g_a404088[] = // 0000000000404088
	{
	};
struct Eq_83 * g_ptr40FC00 = null; // 000000000040FC00
void g_v40FC20 = ??void??; // 000000000040FC20
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401488: void _fini()
void _fini()
{
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __libc_start_main_GOT = null; // 0000000000403FF0
<anonymous> * __gmon_start___GOT = null; // 0000000000403FF8
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * write_GOT = &g_t401036; // 0000000000404018
<anonymous> * omp_get_thread_num_GOT = &g_t401046; // 0000000000404020
<anonymous> * omp_get_num_threads_GOT = &g_t401056; // 0000000000404028
<anonymous> * sprintf_GOT = &g_t401066; // 0000000000404030
<anonymous> * GOMP_parallel_GOT = &g_t401076; // 0000000000404038
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401000: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	if (__gmon_start__ != 0x00)
		__gmon_start__();
}

// subject_init_array.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a403DF0[] = // 0000000000403DF0
	{
	};
// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> g_t401036 = <code>; // 0000000000401036
<anonymous> g_t401046 = <code>; // 0000000000401046
<anonymous> g_t401056 = <code>; // 0000000000401056
<anonymous> g_t401066 = <code>; // 0000000000401066
<anonymous> g_t401076 = <code>; // 0000000000401076
// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_str402010[] = "%d\n"; // 0000000000402010
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401080: void main()
void main()
{
	uint64 r13_11 = 0x01;
	do
	{
		g_qw404080 = 4258848;
		uint64 rbx_23;
		struct Eq_24 * rbp_28 = &g_v40FC20;
		for (rbx_23 = 0x00; rbx_23 != 0x1771; ++rbx_23)
		{
			int32 edx_33 = (word32) (r13_11 + rbx_23);
			word32 r13d_80 = (word32) r13_11;
			if (edx_33 *s ~0x11111110 <= 0x11111111)
			{
				rbp_28->t0000.u1 = 0x7A7A75427A7A6946;
				rbp_28->w0008 = 0x0A;
				rbp_28 = (struct Eq_24 *) ((char *) &rbp_28->w0008 + 1);
			}
			else if (edx_33 *s ~0x33333332 > 0x33333333)
			{
				if (edx_33 *s ~0x55555554 <= 0x55555555)
				{
					rbp_28->t0000 = 0x7A7A6946;
					rbp_28->w0004 = 0x0A;
					++rbp_28;
				}
				else
					rbp_28 += (int64) sprintf(rbp_28, "%d\n", 0x00) /64 5;
			}
			else
			{
				rbp_28->t0000 = 0x7A7A7542;
				rbp_28->w0004 = 0x0A;
				++rbp_28;
			}
			(&g_qw404080)[rbx_23 * 0x08] = rbp_28;
		}
		write(1, &g_v40FC20, g_ptr40FC00 - 4258848);
		r13_11 = (uint64) (r13d_80 + 0x1771);
	} while ((word32) r13_11 != 0x2EE3);
	word32 dwLoc34_230 = 0x00;
	while (true)
	{
		GOMP_parallel();
		if (dwLoc34_230 != 0x00)
		{
			struct Eq_83 * rax_126 = g_ptr40FC00;
			struct Eq_115 * rdi_128 = &g_ptr40FC00;
			struct Eq_83 * rdx_130;
			for (rdx_130 = rax_126 + (int64) dwLoc34_230; rax_126 < rdx_130; rdx_130 -= (struct Eq_146 *) 0x01)
			{
				byte cl_137 = rax_126->b0000;
				if (cl_137 != 0x0A)
				{
					struct Eq_83 * rsi_141 = rdx_130;
					if (cl_137 == 11)
					{
						rax_126->b0000 = 0x0A;
						rdx_130->b0000 = 0x31;
						rdi_128 -= 0x08;
						rdi_128[1] = (struct Eq_115) rdx_130;
						rsi_141 = rdx_130 - (struct Eq_170 *) 0x01;
						cl_137 = rax_126->b0000;
					}
					rsi_141->b0000 = cl_137;
					--rax_126;
					rdx_130 = rsi_141 - (struct Eq_154 *) 0x01;
					if (rax_126 < rdx_130)
						continue;
					break;
				}
				rdi_128 -= 0x08;
				Mem166[rdi_128 + 0x08:word64] = rdx_130 + 0x01;
				--rax_126;
				rdx_130->b0000 = (byte) rax_126[1];
			}
			dwLoc34_230 = 0x00;
		}
		write(1, &g_v40FC20, g_ptr40FC00 - 4258848);
	}
}

// 0000000000401260: void _start(Register (ptr64 Eq_175) rdx, Stack word32 dwArg00)
void _start(void (* rdx)(), word32 dwArg00)
{
	__align((char *) fp + 8);
	__libc_start_main(&g_t401080, (int32) qwArg00, (char *) fp + 8, &g_t401410, &g_t401480, rdx, fp);
	__hlt();
}

// 0000000000401290: void _dl_relocate_static_pie()
void _dl_relocate_static_pie()
{
}

// 00000000004012A0: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
}

// 00000000004012D0: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
}

// 0000000000401310: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	if (g_b404060 != 0x00)
		return;
	deregister_tm_clones();
	g_b404060 = 0x01;
}

// 0000000000401340: void frame_dummy()
// Called from:
//      __libc_csu_init
void frame_dummy()
{
	register_tm_clones();
}

// 0000000000401350: void main._omp_fn.0(Register (ptr64 (ptr64 word32)) rdi)
void main._omp_fn.0(word32 ** rdi)
{
	word64 rdi_14;
	word64 rax_15;
	omp_get_num_threads();
	int32 eax_20 = (word32) rax_15;
	word64 rax_24;
	word64 rdx_26;
	omp_get_thread_num();
	int32 edx_40 = (int32) (6000 % eax_20);
	int32 esi_42 = (word32) rax_24;
	int32 eax_41 = (int32) (6000 /32 eax_20);
	word64 rdx_188 = SEQ(SLICE(rdx_26, word32, 32), edx_40);
	if (esi_42 < edx_40)
	{
		++eax_41;
		rdx_188 = 0x00;
	}
	int32 esi_61 = esi_42 *s eax_41 + (word32) rdx_188;
	int32 eax_64 = eax_41 + esi_61;
	if (esi_61 < eax_64)
	{
		int64 rsi_113 = (int64) esi_61;
		do
		{
			struct Eq_258 * rdi_70 = *((char *) g_a404088 + rsi_113 * 0x08);
			if (rdi_70->bFFFFFFFE != 122)
			{
				uint64 rdx_78 = (uint64) ((word32) rdi_70->bFFFFFFFB + 0x06);
				ci8 dl_79 = (byte) rdx_78;
				rdi_70->bFFFFFFFB = dl_79;
				struct Eq_271 * rcx_102 = rdi_70 - 0x05;
				word32 edx_136 = (word32) rdx_78;
				if (dl_79 > 0x39)
				{
					do
					{
						uint64 rdi_86 = (uint64) rcx_102->bFFFFFFFF;
						--rcx_102;
						rcx_102[1] = (struct Eq_271) ((byte) edx_136 - 0x0A);
						uint64 rdx_94 = (uint64) ((word32) rdi_86 + 0x01);
						ci8 dl_95 = (byte) rdx_94;
						rcx_102->b0000 = dl_95;
						edx_136 = (word32) rdx_94;
					} while (dl_95 > 0x39);
				}
				if ((&g_qw404080)[rsi_113 * 0x08] > rcx_102)
				{
					word32 * rdx_108 = *rdi;
					__lock();
					++*rdx_108;
				}
			}
			++rsi_113;
		} while (eax_64 > (word32) rsi_113);
	}
}

// 0000000000401410: void __libc_csu_init(Register word64 rdx, Register word64 rsi, Register word32 edi)
void __libc_csu_init(word64 rdx, word64 rsi, word32 edi)
{
	word32 edi = (word32) rdi;
	_init();
	int64 rbp_31 = 0x00403DF8 - 0x00403DF0;
	if (rbp_31 >> 0x03 != 0x00)
	{
		Eq_349 rbx_43 = 0x00;
		do
		{
			(*((char *) g_a403DF0 + rbx_43 * 0x08))();
			rbx_43 = (word64) rbx_43.u1 + 1;
		} while (rbp_31 >> 0x03 != rbx_43);
	}
}

// 0000000000401480: void __libc_csu_fini()
void __libc_csu_fini()
{
}

