//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <unistd.h>

// ------------------- Function Prototypes --------------------

int64_t function_401070(int64_t a1, int64_t * a2, int32_t a3, int32_t a4);

// --------------------- Global Variables ---------------------

char * g1; // 0x404080
char * g2; // 0x40fc00
char * g3; // 0x40fc20

// ------------------------ Functions -------------------------

// Address range: 0x401070 - 0x401076
int64_t function_401070(int64_t a1, int64_t * a2, int32_t a3, int32_t a4) {
    // 0x401070
    return GOMP_parallel();
}

// Address range: 0x401080 - 0x40125e
int main(int argc, char ** argv) {
    int64_t v1 = 1; // 0x401096
    g1 = (char *)&g3;
    int64_t str = (int64_t)&g3;
    int64_t v2 = 0;
    int64_t v3 = v2 + v1; // 0x4010f3
    int32_t v4 = v3;
    int64_t v5; // 0x401080
    if (-0x11111111 * v4 < 0x11111112) {
        // 0x401105
        *(int64_t *)str = 0x7a7a75427a7a6946;
        *(int16_t *)(str + 8) = 10;
        v5 = str + 9;
    } else {
        if (-0x33333333 * v4 < 0x33333334) {
            // 0x401140
            *(int32_t *)str = 0x7a7a7542;
            *(int16_t *)(str + 4) = 10;
            v5 = str + 5;
        } else {
            if (-0x55555555 * v4 < 0x55555556) {
                // 0x4010ce
                *(int32_t *)str = 0x7a7a6946;
                *(int16_t *)(str + 4) = 10;
                v5 = str + 5;
            } else {
                // 0x401120
                v5 = str + (int64_t)sprintf((char *)str, "%d\n", v3 & 0xffffffff);
            }
        }
    }
    int64_t v6 = v5;
    *(int64_t *)(8 * v2 + (int64_t)&g1) = v6;
    int64_t v7 = v2 + 1; // 0x4010f1
    while (v2 != 0x1770) {
        // 0x4010f3
        str = v6;
        v2 = v7;
        v3 = v2 + v1;
        v4 = v3;
        if (-0x11111111 * v4 < 0x11111112) {
            // 0x401105
            *(int64_t *)str = 0x7a7a75427a7a6946;
            *(int16_t *)(str + 8) = 10;
            v5 = str + 9;
        } else {
            if (-0x33333333 * v4 < 0x33333334) {
                // 0x401140
                *(int32_t *)str = 0x7a7a7542;
                *(int16_t *)(str + 4) = 10;
                v5 = str + 5;
            } else {
                if (-0x55555555 * v4 < 0x55555556) {
                    // 0x4010ce
                    *(int32_t *)str = 0x7a7a6946;
                    *(int16_t *)(str + 4) = 10;
                    v5 = str + 5;
                } else {
                    // 0x401120
                    v5 = str + (int64_t)sprintf((char *)str, "%d\n", v3 & 0xffffffff);
                }
            }
        }
        // 0x4010df
        v6 = v5;
        *(int64_t *)(8 * v2 + (int64_t)&g1) = v6;
        v7 = v2 + 1;
    }
    int64_t v8 = v1 + 0x1771; // 0x40115a
    write(1, (int64_t *)&g3, (int32_t)(int64_t)g2 - 0x40fc20);
    v1 = v8 & 0xffffffff;
    while ((int32_t)v8 != 0x2ee3) {
        // 0x40109a
        g1 = (char *)&g3;
        str = (int64_t)&g3;
        v2 = 0;
        v3 = v2 + v1;
        v4 = v3;
        if (-0x11111111 * v4 < 0x11111112) {
            // 0x401105
            *(int64_t *)str = 0x7a7a75427a7a6946;
            *(int16_t *)(str + 8) = 10;
            v5 = str + 9;
        } else {
            if (-0x33333333 * v4 < 0x33333334) {
                // 0x401140
                *(int32_t *)str = 0x7a7a7542;
                *(int16_t *)(str + 4) = 10;
                v5 = str + 5;
            } else {
                if (-0x55555555 * v4 < 0x55555556) {
                    // 0x4010ce
                    *(int32_t *)str = 0x7a7a6946;
                    *(int16_t *)(str + 4) = 10;
                    v5 = str + 5;
                } else {
                    // 0x401120
                    v5 = str + (int64_t)sprintf((char *)str, "%d\n", v3 & 0xffffffff);
                }
            }
        }
        // 0x4010df
        v6 = v5;
        *(int64_t *)(8 * v2 + (int64_t)&g1) = v6;
        v7 = v2 + 1;
        while (v2 != 0x1770) {
            // 0x4010f3
            str = v6;
            v2 = v7;
            v3 = v2 + v1;
            v4 = v3;
            if (-0x11111111 * v4 < 0x11111112) {
                // 0x401105
                *(int64_t *)str = 0x7a7a75427a7a6946;
                *(int16_t *)(str + 8) = 10;
                v5 = str + 9;
            } else {
                if (-0x33333333 * v4 < 0x33333334) {
                    // 0x401140
                    *(int32_t *)str = 0x7a7a7542;
                    *(int16_t *)(str + 4) = 10;
                    v5 = str + 5;
                } else {
                    if (-0x55555555 * v4 < 0x55555556) {
                        // 0x4010ce
                        *(int32_t *)str = 0x7a7a6946;
                        *(int16_t *)(str + 4) = 10;
                        v5 = str + 5;
                    } else {
                        // 0x401120
                        v5 = str + (int64_t)sprintf((char *)str, "%d\n", v3 & 0xffffffff);
                    }
                }
            }
            // 0x4010df
            v6 = v5;
            *(int64_t *)(8 * v2 + (int64_t)&g1) = v6;
            v7 = v2 + 1;
        }
        // 0x401153
        v8 = v1 + 0x1771;
        write(1, (int64_t *)&g3, (int32_t)(int64_t)g2 - 0x40fc20);
        v1 = v8 & 0xffffffff;
    }
    int32_t v9 = 0; // bp-52, 0x401184
    while (true) {
        int64_t v10 = &v9; // bp-48, 0x4011cb
        function_401070(0x401350, &v10, 0, 0);
        if (v9 != 0) {
            int64_t v11 = (int64_t)g2; // 0x4011dd
            int64_t v12 = v11 + (int64_t)v9; // 0x4011ee
            int64_t v13 = v11; // 0x4011f4
            int64_t v14 = v12; // 0x4011f4
            int64_t v15 = (int64_t)&g2; // 0x4011f4
            if (v12 > v11) {
                while (true) {
                    int64_t v16 = v15;
                    int64_t v17 = v14;
                    int64_t v18 = v13;
                    char * v19 = (char *)v18; // 0x40122a
                    char v20 = *v19; // 0x40122a
                    int64_t v21; // 0x401080
                    int64_t v22; // 0x401080
                    int64_t v23; // 0x401080
                    if (v20 != 10) {
                        char v24 = v20; // 0x401206
                        int64_t v25 = v17; // 0x401206
                        int64_t v26 = v16; // 0x401206
                        if (v20 == 11) {
                            // 0x401208
                            *v19 = 10;
                            *(char *)v17 = 49;
                            *(int64_t *)v16 = v17;
                            v24 = *v19;
                            v25 = v17 - 1;
                            v26 = v16 - 8;
                        }
                        int64_t v27 = v18 - 1; // 0x40121c
                        int64_t v28 = v25 - 1; // 0x40121f
                        *(char *)v25 = v24;
                        v21 = v27;
                        v23 = v28;
                        v22 = v26;
                        if (v27 >= v28) {
                            // break -> 0x401253
                            break;
                        }
                    } else {
                        int64_t v29 = v18 - 1; // 0x401239
                        *(int64_t *)v16 = v17 + 1;
                        int64_t v30 = v17 - 1; // 0x401248
                        *(char *)v17 = *v19;
                        v21 = v29;
                        v23 = v30;
                        v22 = v16 - 8;
                        if (v29 >= v30) {
                            // break -> 0x401253
                            break;
                        }
                    }
                    // 0x40122a
                    v13 = v21;
                    v14 = v23;
                    v15 = v22;
                }
            }
            // 0x401253
            v9 = 0;
        }
        // 0x4011a0
        write(1, (int64_t *)&g3, (int32_t)(int64_t)g2 - 0x40fc20);
    }
}

// --------------- Dynamically Linked Functions ---------------

// int64_t GOMP_parallel(void);
// int sprintf(char * restrict s, const char * restrict format, ...);
// ssize_t write(int fd, const void * buf, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.1.1)
// Detected functions: 2

