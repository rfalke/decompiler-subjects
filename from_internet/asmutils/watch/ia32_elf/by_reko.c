// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Stack (ptr32 Eq_2) dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack (ptr32 Eq_2) dwArg10)
void fn0804804C(struct Eq_2 * dwArg08, struct Eq_2 * dwArg0C, struct Eq_2 * dwArg10)
{
	ptr32 fp;
	struct Eq_6 * esp_197;
	if (dwArg08 != null)
	{
		word32 ebp_213;
		ptr32 esp_60;
		sys_write(0x01, "\x1B[2Jwatch [args] exec_name exec_args - exec a program periodically, showing output\nfullscreen. By default, the prog. is run every 2 sec; use -n or --interval=\nto specify a different interval.\nExecve failed ...", 0x04);
		ptr32 esp_185 = fp + 0x0C;
		struct Eq_2 * ebx_45 = dwArg08;
		if (dwArg08->t0000.u1 != 28205)
		{
			if (dwArg08->t0000 != 0x6E692D2D)
			{
				ebp_213 = 0x02;
				esp_60 = fp + 0x0C;
			}
			else
			{
				struct Eq_2 * esi_64 = dwArg08;
				do
				{
					Eq_218 al_68 = esi_64->t0000.u0;
					++esi_64;
					if (al_68 == 0x00)
						goto l08048110;
				} while (al_68 != 0x3D);
				ebp_213 = fn0804812B(esi_64);
				ebx_45 = dwArg0C;
				esp_60 = fp + 16;
			}
		}
		else
		{
			ebp_213 = fn0804812B(dwArg0C);
			ebx_45 = dwArg10;
			esp_60 = fp + 20;
		}
		struct Eq_55 * esp_93 = esp_60 - 4;
		esp_93->ptr0000 = ebx_45;
		struct Eq_55 * esi_101 = esp_93;
		do
		{
			esi_101 = (struct Eq_55 *) ((char *) &esi_226->ptr0000 + 4);
			esi_226 = esi_101;
		} while (esi_226->ptr0000 != null);
		esp_93->ptrFFFFFFFC = ebx_45;
		esp_93->ptrFFFFFFF8 = esp_93;
		esp_93->ptrFFFFFFF4 = esi_101;
		while (true)
		{
			struct Eq_75 * esp_116 = esp_60 - 16;
			char ** edx_118 = esp_116->ptr0000;
			char ** ecx_120 = esp_116->ptr0004;
			char * ebx_122 = esp_116->ptr0008;
			esp_116->ptr0008 = (char *) 0x02;
			if (sys_fork() == 0x00)
				break;
			esp_116->ptr0008 = ebx_122;
			esp_116->ptr0004 = ecx_120;
			esp_116->ptr0000 = edx_118;
			esp_116->tFFFFFFFC = 114;
			sys_wait4(~0x00, null, 0x00, null);
			esp_116->tFFFFFFFC = 0x00;
			esp_116->dwFFFFFFF8 = ebp_213;
			esp_116->dwFFFFFFF4 = 0x00;
			esp_116->dwFFFFFFF0 = 0x00;
			sys_nanosleep(esp_116 - 8, esp_116 - 16);
			esp_116->tFFFFFFFC = 0x04;
			Eq_13 edx_170 = esp_116->tFFFFFFFC;
			esp_116->tFFFFFFFC = 0x01;
			Eq_13 ebx_175 = esp_116->tFFFFFFFC;
			esp_116->tFFFFFFFC = 0x04;
			sys_write(ebx_175, "\x1B[2Jwatch [args] exec_name exec_args - exec a program periodically, showing output\nfullscreen. By default, the prog. is run every 2 sec; use -n or --interval=\nto specify a different interval.\nExecve failed ...", edx_170);
		}
		esp_116->ptr0008 = (char *) 11;
		sys_execve(ebx_122, ecx_120, edx_118);
		esp_185 = (char *) &esp_116->ptr0008 + 4;
l08048110:
		uint32 * esp_190 = esp_185 - 4;
		*esp_190 = 0x01;
		uint32 ebx_192 = *esp_190;
		*esp_190 = 0x04;
		sys_write(ebx_192, "Execve failed ...", 0x12);
		esp_197 = (struct Eq_6 *) (esp_190 + 1);
	}
	else
	{
		sys_write(0x01, "watch [args] exec_name exec_args - exec a program periodically, showing output\nfullscreen. By default, the prog. is run every 2 sec; use -n or --interval=\nto specify a different interval.\nExecve failed ...", 188);
		esp_197 = fp + 0x0C;
	}
	esp_197->dwFFFFFFFC = 0x01;
	sys_exit(0xFF);
}

// 0804812B: Register Eq_237 fn0804812B(Register (ptr32 Eq_2) esi)
// Called from:
//      fn0804804C
Eq_237 fn0804812B(struct Eq_2 * esi)
{
	Eq_237 ebp_18 = 0x00;
	while (true)
	{
		byte al_11 = esi->t0000.u0;
		++esi;
		if (al_11 == 0x00)
			break;
		ebp_18 = ebp_18 *s 0x0A + (uint32) (al_11 - 0x30);
	}
	return ebp_18;
}

char g_str804813E[] = "\x1B[2Jwatch [args] exec_name exec_args - exec a program periodically, showing output\nfullscreen. By default, the prog. is run every 2 sec; use -n or --interval=\nto specify a different interval.\nExecve failed ..."; // 0804813E
char g_str8048142[] = "watch [args] exec_name exec_args - exec a program periodically, showing output\nfullscreen. By default, the prog. is run every 2 sec; use -n or --interval=\nto specify a different interval.\nExecve failed ..."; // 08048142
char g_str80481FE[] = "Execve failed ..."; // 080481FE
