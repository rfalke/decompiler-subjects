//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2);
int32_t function_80482f3(void);
int32_t function_80483e9(void);
int32_t function_8048440(void);
int32_t function_804846a(void);

// --------------------- Global Variables ---------------------

int32_t g2 = -0x2ece26cf; // 0x80482b6
char * g3; // 0x80484e4
int32_t g4 = 0; // 0x80484e8
int32_t g5 = 0; // 0x80484ec
int32_t g6 = 0; // 0x80484f0
int32_t g7 = 0; // 0x80484f4
int32_t g8 = 0; // 0x80484f8
int32_t g9 = 0; // 0x80484fc
char * g10; // 0x8048500
int32_t g11 = 0; // 0x8048538
uint32_t g12 = 0; // 0x804853c
char * g13; // 0x8048b80
char * g14; // 0x8050bc0
int32_t * g1 = &g2; // 0x8048126

// ------------------------ Functions -------------------------

// Address range: 0x804804c - 0x80482f3
int32_t entry_point(int32_t a1, int32_t a2) {
    // 0x804804c
    function_80483e9();
    int32_t v1; // 0x804804c
    int32_t v2 = &v1; // 0x8048057
    int32_t v3 = v2; // 0x8048058
    if (a1 != 1) {
        int32_t v4; // 0x804804c
        if (v4 == 0) {
            // 0x8048121
            v1 = 1;
            __asm_int(128);
            *(char *)9 = *(char *)9 + 18;
            abort();
            // UNREACHABLE
        }
        // 0x8048063
        g14 = (char *)v4;
        v1 = 5;
        __asm_int(128);
        v3 = v2 + 4;
    }
    // 0x8048079
    while (true) {
        // 0x8048079
        *(int32_t *)(v3 - 4) = 3;
        __asm_int(128);
        function_8048440();
    }
}

// Address range: 0x80482f3 - 0x80483e9
int32_t function_80482f3(void) {
    // 0x80482f3
    int32_t v1; // bp-72, 0x80482f3
    int32_t v2 = &v1; // 0x8048300
    __asm_rep_movsd_memcpy((char *)&v1, (char *)&g3, 5);
    __asm_rep_movsd_memcpy((char *)(v2 + 20), (char *)&g3, 5);
    int32_t * v3 = (int32_t *)(v2 - 4);
    int32_t * v4 = (int32_t *)(v2 - 8); // 0x8048316
    int32_t v5; // bp-32, 0x80482f3
    int32_t v6 = &v5;
    *v3 = 2;
    *v4 = 16;
    int32_t * v7 = (int32_t *)(v6 - 40);
    int32_t * v8 = (int32_t *)(v6 - 24);
    int32_t * v9 = (int32_t *)(v6 - 32);
    int32_t * v10 = (int32_t *)(v6 - 28); // 0x8048340
    int32_t * v11 = (int32_t *)(v6 - 36);
    *v4 = 16;
    *v7 = *v8 + *v7;
    uint32_t v12 = *v9; // 0x804832e
    *v9 = v12 / 0x400000 | 1024 * v12;
    *v8 = *v10 + *v8;
    uint32_t v13 = *v11; // 0x8048346
    *v11 = v13 / 0x400000 | 1024 * v13;
    *v10 = *v9 + *v10;
    uint32_t v14 = *v7; // 0x804835e
    *v7 = v14 / 0x400000 | 1024 * v14;
    *v9 = *v11 + *v9;
    uint32_t v15 = *v8; // 0x8048376
    *v8 = v15 / 0x400000 | 1024 * v15;
    *v11 = *v7 + *v11;
    uint32_t v16 = *v10; // 0x804838e
    int32_t v17 = v16 / 0x400000 | 1024 * v16; // 0x804838e
    *v10 = v17;
    int32_t v18 = *v4 - 1; // 0x8048393
    while (v18 != 0) {
        // 0x8048319
        *v4 = v18;
        *v7 = *v8 + *v7;
        v12 = *v9;
        *v9 = v12 / 0x400000 | 1024 * v12;
        *v8 = *v10 + *v8;
        v13 = *v11;
        *v11 = v13 / 0x400000 | 1024 * v13;
        *v10 = *v9 + *v10;
        v14 = *v7;
        *v7 = v14 / 0x400000 | 1024 * v14;
        *v9 = *v11 + *v9;
        v15 = *v8;
        *v8 = v15 / 0x400000 | 1024 * v15;
        *v11 = *v7 + *v11;
        v16 = *v10;
        v17 = v16 / 0x400000 | 1024 * v16;
        *v10 = v17;
        v18 = *v4 - 1;
    }
    int32_t v19 = *v3 - 1; // 0x8048399
    int32_t v20 = v6 + 20; // 0x804839a
    while (v19 != 0) {
        // 0x8048315
        v6 = v20;
        *v3 = v19;
        *v4 = 16;
        v7 = (int32_t *)(v6 - 40);
        v8 = (int32_t *)(v6 - 24);
        v9 = (int32_t *)(v6 - 32);
        v10 = (int32_t *)(v6 - 28);
        v11 = (int32_t *)(v6 - 36);
        *v4 = 16;
        *v7 = *v8 + *v7;
        v12 = *v9;
        *v9 = v12 / 0x400000 | 1024 * v12;
        *v8 = *v10 + *v8;
        v13 = *v11;
        *v11 = v13 / 0x400000 | 1024 * v13;
        *v10 = *v9 + *v10;
        v14 = *v7;
        *v7 = v14 / 0x400000 | 1024 * v14;
        *v9 = *v11 + *v9;
        v15 = *v8;
        *v8 = v15 / 0x400000 | 1024 * v15;
        *v11 = *v7 + *v11;
        v16 = *v10;
        v17 = v16 / 0x400000 | 1024 * v16;
        *v10 = v17;
        v18 = *v4 - 1;
        while (v18 != 0) {
            // 0x8048319
            *v4 = v18;
            *v7 = *v8 + *v7;
            v12 = *v9;
            *v9 = v12 / 0x400000 | 1024 * v12;
            *v8 = *v10 + *v8;
            v13 = *v11;
            *v11 = v13 / 0x400000 | 1024 * v13;
            *v10 = *v9 + *v10;
            v14 = *v7;
            *v7 = v14 / 0x400000 | 1024 * v14;
            *v9 = *v11 + *v9;
            v15 = *v8;
            *v8 = v15 / 0x400000 | 1024 * v15;
            *v11 = *v7 + *v11;
            v16 = *v10;
            v17 = v16 / 0x400000 | 1024 * v16;
            *v10 = v17;
            v18 = *v4 - 1;
        }
        // 0x8048395
        v19 = *v3 - 1;
        v20 = v6 + 20;
    }
    // 0x80483a0
    *v3 = *(int32_t *)(v6 - 52) + v17 + g4;
    g4 = *(int32_t *)(v6 - 48) + *v8 + g5;
    g5 = *(int32_t *)(v6 - 44) + *v7 + g6;
    g6 = *(int32_t *)(v6 - 60) + *v11 + g7;
    g7 = *(int32_t *)(v6 - 56) + *v9 + (int32_t)g3;
    *(int32_t *)&g3 = *v3;
    return *(int32_t *)(v2 + 68);
}

// Address range: 0x80483e9 - 0x8048440
int32_t function_80483e9(void) {
    // 0x80483e9
    *(int32_t *)&g3 = 0x67452301;
    *(int32_t *)((int32_t)&g3 + 4) = -0x10325477;
    *(int32_t *)((int32_t)&g3 + 8) = -0x67452302;
    *(int32_t *)((int32_t)&g3 + 12) = 0x10325476;
    *(int32_t *)((int32_t)&g3 + 16) = -0x3c2d1e10;
    *(int32_t *)((int32_t)&g3 + 20) = 0;
    *(int32_t *)((int32_t)&g3 + 24) = 0;
    __asm_rep_stosd_memset((char *)((int32_t)&g3 + 28), 0, 16);
    int32_t v1; // bp-32, 0x80483e9
    int32_t v2 = &v1; // 0x804841e
    int32_t * v3 = (int32_t *)(v2 - 4); // 0x804841f
    int32_t v4 = (int32_t)&g3 + 92; // 0x804841e
    int32_t v5 = (int32_t)&g1;
    *v3 = 10;
    *(int32_t *)(v2 - 8) = 16;
    int32_t v6 = 16; // 0x804842a
    int32_t v7 = v5 + 8; // 0x804842a
    int32_t v8 = v7 + 2; // 0x804842b
    *(int32_t *)v4 = *(int32_t *)v5;
    *(int32_t *)(v4 + 4) = *(int32_t *)(v5 + 4);
    *(int16_t *)(v4 + 8) = *(int16_t *)v7;
    v4 += 10;
    v6--;
    v7 = v8;
    while (v6 != 0) {
        // 0x804842b
        v8 = v7 + 2;
        *(int32_t *)v4 = *(int32_t *)v5;
        *(int32_t *)(v4 + 4) = *(int32_t *)(v5 + 4);
        *(int16_t *)(v4 + 8) = *(int16_t *)v7;
        v4 += 10;
        v6--;
        v7 = v8;
    }
    int32_t v9 = *v3 - 1; // 0x804843c
    while (v9 != 0) {
        // 0x804841f
        v5 = v8;
        *v3 = v9;
        *(int32_t *)(v2 - 8) = 16;
        v6 = 16;
        v7 = v5 + 8;
        v8 = v7 + 2;
        *(int32_t *)v4 = *(int32_t *)v5;
        *(int32_t *)(v4 + 4) = *(int32_t *)(v5 + 4);
        *(int16_t *)(v4 + 8) = *(int16_t *)v7;
        v4 += 10;
        v6--;
        v7 = v8;
        while (v6 != 0) {
            // 0x804842b
            v8 = v7 + 2;
            *(int32_t *)v4 = *(int32_t *)v5;
            *(int32_t *)(v4 + 4) = *(int32_t *)(v5 + 4);
            *(int16_t *)(v4 + 8) = *(int16_t *)v7;
            v4 += 10;
            v6--;
            v7 = v8;
        }
        // 0x804843b
        v9 = *v3 - 1;
    }
    // 0x804843e
    return *(int32_t *)(v2 + 28);
}

// Address range: 0x8048440 - 0x804846a
int32_t function_8048440(void) {
    // 0x8048440
    int32_t result; // 0x8048440
    uint32_t v1 = result;
    int32_t v2 = v1 / 64; // 0x8048448
    if (v1 >= 64) {
        function_80482f3();
        v2--;
        while (v2 != 0) {
            // 0x804844a
            function_80482f3();
            v2--;
        }
    }
    int32_t v3 = g8 + v1; // 0x804845d
    if (v3 < g8) {
        // 0x8048463
        g9++;
    }
    // 0x8048466
    g8 = v3;
    return result;
}

// Address range: 0x804846a - 0x80484e4
int32_t function_804846a(void) {
    // 0x804846a
    __asm_rep_movsb_memcpy((char *)&g10, (char *)&g13, g8 % 64);
    int32_t v1 = 8 * g8; // 0x8048497
    int32_t * v2 = (int32_t *)((g8 & 60) + (int32_t)&g10); // 0x80484a7
    *v2 = 1 << (v1 & 24 | 7) ^ *v2;
    if ((g8 & 56) == 56) {
        // 0x80484b2
        function_80482f3();
        __asm_rep_stosd_memset((char *)&g10, 0, 16);
    }
    // 0x80484c0
    g11 = v1;
    g12 = g9 / 0x20000000;
    function_80482f3();
    int32_t result; // 0x804846a
    __asm_rep_movsd_memcpy((char *)result, (char *)&g3, 5);
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: elfcrypt (1.0)
// Detected functions: 5

