// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048092: void fn08048092()
void fn08048092()
{
	struct Eq_2 * esp_121 = fp;
l08048092:
	struct Eq_4 * esp_6 = esp_121 + 1;
	union Eq_37 * ebx_9 = esp_6->ptr0004;
	struct Eq_2 * esp_10 = &esp_6->ptr0008;
	union Eq_37 * ebx_11 = ebx_9;
	if (ebx_9 != null)
	{
		if (*ebx_9 == 26925)
		{
			byte * ebx_17 = esp_6->ptr0008;
			esp_10 = (struct Eq_2 *) &esp_6->ptr000C;
			if (ebx_17 == null)
				goto l0804808A;
			g_t804880D = fn08048374(ebx_17);
			union Eq_37 * ebx_32 = esp_6->ptr000C;
			esp_10 = (struct Eq_2 *) ((char *) &esp_6->ptr000C + 4);
			ebx_11 = ebx_32;
			if (ebx_32 == null)
				goto l0804808A;
		}
		struct Eq_40 * esp_39 = esp_10 - 4;
		esp_39->dw0000 = 0x02;
		esp_39->dw0000 = 0x05;
		int32 eax_45 = esp_39->dw0000;
		__syscall(0x80);
		esp_10 = (struct Eq_2 *) &esp_39->ptr0004;
		if (eax_45 < 0x00)
			goto l0804808A;
		Eq_72 eax_101;
		g_dw8048809 = eax_45;
		g_ptr8048805 = ebx_11;
		byte * ebx_54 = esp_39->ptr0004;
		if (ebx_54 != null)
		{
			eax_101 = fn08048374(ebx_54);
			goto l080480D9;
		}
		esp_39->ptr0004 = (byte *) 0x36;
		__syscall(0x80);
		Eq_72 eax_67 = g_t8048811;
		byte * eax_69 = eax_67 << 0x09;
		if (eax_67 << 0x09 == 0x00)
		{
			esp_39->ptr0004 = (byte *) 0x02;
			esp_39->ptr0004 = (byte *) 0x13;
			eax_69 = esp_39->ptr0004;
			__syscall(0x80);
		}
		++esp_10;
		if (eax_69 >= (byte *) 0x1800)
		{
			esp_10->dwFFFFFFFC = eax_69 >> 0x0A;
			esp_10->dwFFFFFFF8 = 0x13;
			__syscall(0x80);
			eax_101 = esp_10->dwFFFFFFFC;
l080480D9:
			esp_10 = fp;
			if (eax_101 >= 0x06)
			{
				g_t8048811 = eax_101;
				__syscall(0x80);
				g_w8048837 = 0x0400;
				g_w804883F = 0x01;
				g_w804883D = 5007;
				g_dw8048839 = 0x10081C00;
				Eq_72 eax_137 = g_t804880D;
				Eq_72 eax_138 = eax_137;
				if (eax_137 == 0x00)
				{
					Eq_72 eax_142 = g_t8048811;
					g_w804882F = (word16) eax_142;
					eax_138.u1 = (uint32) ((uint64) eax_142 /u 0x03);
				}
				ui32 eax_156 = (word32) eax_138.u1 + 31;
				g_t804880D = eax_156 & 0xFFE0;
				g_w804882D = (word16) eax_156 & ~0x1F;
				uint32 eax_173 = (uint32) ((uint64) ((eax_156 & 0xFFE0) + 0x2000) /u 0x2000);
				g_w8048831 = (word16) eax_173;
				g_dw8048815 = eax_173 << 0x0A;
				word32 eax_182 = g_t8048811 - ((eax_156 & 0xFFE0) >> 0x05);
				uint32 eax_189 = SEQ(SLICE(eax_182 - 0x02, word16, 16), (word16) eax_182 - 0x02 - g_w8048831);
				Eq_72 eax_201 = (uint32) (SEQ(SLICE(eax_189 *64 0x1FFF, word32, 32), eax_189 * 0x1FFF + 0x01) /u 0x2001);
				g_t804881D = eax_201;
				uint32 ebx_204 = eax_189 - eax_201;
				g_w8048833 = (word16) ebx_204;
				g_dw8048819 = ebx_204 << 0x0A;
				g_ptr8048821 = &g_b8048C2D;
				g_ptr8048825 = g_dw8048815 + 134515757;
				union Eq_37 * esi_216 = g_ptr8048805;
				do
				{
					esi_216 = (union Eq_37 *) ((char *) esi_557 + 1);
					esi_557 = esi_216;
				} while (*esi_557 != 0x00);
				__syscall(0x80);
				g_w80487F5 = 0x203A;
				fn0804838B(g_t804880D, &g_b80487F7);
				__syscall(0x80);
				__syscall(0x80);
				fn0804838B(g_t804881D, &g_w80487F5);
				__syscall(0x80);
				__syscall(0x80);
				byte * edi_308 = g_ptr8048821;
				*edi_308 = 0x03;
				byte * ebx_311 = edi_308 + g_dw8048815;
				word32 edi_314 = edi_308 + (Mem309[0x0804880D<p32>:word32] >>u 0x03);
				*edi_314 = ~0x01;
				byte * edi_318 = edi_314 + 1;
				do
				{
					*edi_318 = ~0x00;
					++edi_318;
				} while (edi_318 < ebx_311);
				Eq_292 eax_340 = (uint32) (g_w8048831 + 0x02 + g_w8048833) + (g_t804880D >> 0x05);
				g_t8048829 = eax_340;
				g_w8048835 = (word16) eax_340;
				byte * edi_344 = g_ptr8048825;
				*edi_344 = 0x03;
				uint64 edx_eax_353 = (uint64) ((word32) g_t804881D + 1);
				byte * edi_359 = edi_344 + (uint32) (edx_eax_353 /u 0x08);
				word32 * ebx_358 = edi_344 + g_dw8048819;
				*edi_359 |= ~((0x01 << (byte) (edx_eax_353 % 0x08)) - 0x01);
				word32 * edi_369 = edi_359 + 1;
				do
				{
					*edi_369 = ~0x00;
					++edi_369;
				} while (edi_369 <= ebx_358);
				__syscall(0x80);
				__syscall(0x80);
				word32 edx_404 = g_dw8048815 + g_dw8048819;
				byte * ecx_405 = g_ptr8048821;
				__syscall(0x80);
				struct Eq_376 * ecx_414 = ecx_405 + edx_404;
				ecx_414->w0000 = 16877;
				__syscall(0x80);
				ecx_414->w0002 = 0x18;
				ecx_414->dw0004 = 0x40;
				__syscall(0x80);
				ecx_414->dw0008 = 0x0D;
				__syscall(0x80);
				ecx_414->b000C = 0x2F;
				ecx_414->b000D = 0x02;
				ecx_414->t000E = g_t8048829;
				uint32 esi_462 = g_t804880D >> 0x05;
				do
				{
					__syscall(0x80);
					--esi_462;
				} while (esi_462 != 0x00);
				__syscall(0x80);
				__syscall(0x80);
			}
			goto l0804808A;
		}
	}
l0804808A:
	word32 * esp_114 = esp_10 - 4;
	*esp_114 = 0x01;
	*esp_114 = 0x01;
	__syscall(0x80);
	esp_121 = (struct Eq_2 *) (esp_114 + 1);
	goto l08048092;
}

// 08048374: Register uint32 fn08048374(Register (ptr32 byte) ebx)
// Called from:
//      fn08048092
uint32 fn08048374(byte * ebx)
{
	byte * esi_13 = ebx;
	uint32 eax_10 = 0x00;
	while (true)
	{
		ci8 bl_15 = *esi_13;
		++esi_13;
		uint32 ebx_25 = (uint32) (bl_15 - 0x30);
		if (bl_15 < 0x30)
			break;
		eax_10 = eax_10 * 0x0A + ebx_25;
	}
	return eax_10;
}

// 0804838B: void fn0804838B(Register Eq_72 eax, Register (ptr32 byte) edi)
// Called from:
//      fn08048092
void fn0804838B(Eq_72 eax, byte * edi)
{
	word32 ecx_17 = 0x00;
	word32 * esp_19 = fp;
	do
	{
		uint64 edx_eax_12 = (uint64) eax;
		esp_19 -= 4;
		*esp_19 = (uint32) (edx_eax_12 % 0x0A);
		Eq_72 eax_16 = (uint32) (edx_eax_12 /u 0x0A);
		++ecx_17;
		eax = eax_16;
	} while (eax_16 != 0x00);
	do
	{
		*edi = 0x3A;
		++edi;
		--ecx_17;
	} while (ecx_17 != 0x00);
}

word16 g_w80487F5 = 0x00; // 080487F5
byte g_b80487F7 = 0x00; // 080487F7
union Eq_37 * g_ptr8048805 = null; // 08048805
int32 g_dw8048809 = 0; // 08048809
Eq_72 g_t804880D = // 0804880D
	{
		0
	};
Eq_72 g_t8048811 = // 08048811
	{
		0
	};
ui32 g_dw8048815 = 0x00; // 08048815
ui32 g_dw8048819 = 0x00; // 08048819
Eq_72 g_t804881D = // 0804881D
	{
		0
	};
byte * g_ptr8048821 = null; // 08048821
byte * g_ptr8048825 = null; // 08048825
Eq_292 g_t8048829 = // 08048829
	{
		0x00
	};
cui16 g_w804882D = 0x00; // 0804882D
word16 g_w804882F = 0x00; // 0804882F
word16 g_w8048831 = 0x00; // 08048831
word16 g_w8048833 = 0x00; // 08048833
word16 g_w8048835 = 0x00; // 08048835
word16 g_w8048837 = 0x00; // 08048837
word32 g_dw8048839 = 0x00; // 08048839
word16 g_w804883D = 0x00; // 0804883D
word16 g_w804883F = 0x00; // 0804883F
byte g_b8048C2D = 0x00; // 08048C2D
