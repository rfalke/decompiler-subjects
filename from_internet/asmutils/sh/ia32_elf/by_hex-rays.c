/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn start(); // weak
// char __usercall sub_80481C8@<al>(const char *@<edi>);
// int __usercall sub_8048212@<eax>(int@<ebp>);
// void __usercall sub_804823D(const char *a1@<edi>);
// void __usercall sub_804824A(const char *@<edi>, const char *@<esi>);
int sub_8048266();
int sub_80482AB();
char sub_80482C6();
char *sub_80482EA();
// char __usercall sub_804874F@<al>(char *@<eax>);
// int __usercall sub_80488D8@<eax>(int@<edx>, int@<ebp>);
// void __usercall sub_8048AF2(int a1@<eax>, _BYTE *a2@<edi>, int a3@<esi>);
// char __usercall sub_8048B1B@<al>(_BYTE *@<edi>, char *@<esi>);
// int __usercall sub_8048B38@<eax>(const void *@<eax>, int *@<edi>);
int sub_8048B8C();
// int __usercall sub_8048DD5@<eax>(int@<ebx>);
// void __usercall sub_8048DF5(const char *a1@<eax>);
// const void *__usercall sub_8048E06@<eax>(size_t len@<ecx>, const void *result@<eax>);
// const char *__usercall sub_8048E1C@<eax>(const char *@<eax>);
void sub_8048FEA();
void sub_8049100();
void sub_804911E();
// char *__usercall sub_8049129@<eax>(char a1@<cf>, int a2@<eax>, char a3@<dh>, _BYTE *a4@<ecx>, unsigned int a5@<ebx>, int a6@<esi>);

//-------------------------------------------------------------------------
// Data declarations

char aAsmutilsShell[16] = "asmutils shell\n"; // weak
char asc_8049264[3] = "$ "; // weak
char asc_804926A[3] = "+ "; // weak
char asc_804926D[3] = "> "; // weak
char aYouSayStopAndI[30] = "\nYou say STOP and I say go..."; // weak
char aLogout[8] = "logout\n"; // weak
char aCanTOpenScript[19] = "can't open script\n"; // weak
char aStoppedId[13] = "Stopped id: "; // weak
char aChildIs0xdeadI[28] = "Child is 0xDEAD. I'm sorry\n"; // weak
char *off_8049394 = "exit"; // weak
__int16 word_80494FA = 23323; // weak
char a11p[12] = "\x1B[1@]\b\x1B[1P\a"; // weak
struct sigaction act; // idb
__int16 word_804959A; // weak
__int16 word_804A59A; // weak
int dword_805B59C[]; // weak
char *argv; // idb
int dword_805B5A4[]; // weak
const char *envp; // idb
int dword_805D668; // weak
mode_t mode; // idb
int dword_805D670; // weak
int dword_805D674; // weak
int dword_805D678; // weak
int dword_805D67C; // idb
int old_fd; // idb
int filedes; // idb
int dword_805D688; // weak
struct stat buf; // idb
char byte_805D6F3; // weak
char byte_805D6F4[2]; // weak
int dword_805D6F6; // weak
int dword_805D6FA; // weak
int dword_805D6FE; // weak
char dword_805D702[]; // idb
int dword_805D706; // weak
struct dirent dirp; // idb
const char *path; // idb
char byte_805D90F[]; // weak
__int16 word_805DA0E; // weak
char byte_805DB0D; // weak
__int16 word_805DB0E; // weak
char byte_805DB22; // weak
char byte_805DB23; // weak
pid_t pid; // idb
int dword_805DB28; // weak
int status; // idb
int fd; // idb
int dword_805DB58; // weak


//----- (0804804C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start()
{
  mode_t v0; // edx
  int v1; // eax
  int v2; // eax
  int v3; // eax
  struct sigaction *v4; // edx
  const struct sigaction *v5; // ecx
  int v6; // eax
  struct sigaction *v7; // edx
  const struct sigaction *v8; // ecx
  int v9; // eax
  struct sigaction *v10; // edx
  const struct sigaction *v11; // ecx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  const char *i; // eax
  char **v16; // ecx
  __int16 *v17; // edi
  int v18; // edx
  int v19; // eax
  char *v20; // edx
  int v21; // eax
  const char *v22; // [esp-8h] [ebp-8h]
  char *v23; // [esp-4h] [ebp-4h] BYREF

  *(_DWORD *)dword_805D702 = 12078;
  sub_80481C8(v22);
  sub_8048212((int)v23);
  if ( v23 )
  {
    v1 = sys_open(v23, 0, v0);
    if ( !v1 )
    {
      sub_8048E1C(aCanTOpenScript);
      v2 = sys_exit(2);
    }
    fd = v1;
    dword_805B59C[0] = (int)asc_804926A;
  }
  else
  {
    byte_805DB23 = 1;
    sub_8048DF5(aAsmutilsShell);
    fd = 0;
    sub_8048266();
    v3 = sys_sigaction(22, &act, 0);
    v6 = sys_sigaction(21, v5, v4);
    v9 = sys_sigaction(2, v8, v7);
    act.sa_handler = (__sighandler_t)sub_8049100;
    v12 = sys_sigaction(20, v11, v10);
    __asm { int     80h; LINUX - sys_getpid }
    dword_805DB58 = 20;
    v13 = sys_setpgid(20, 0);
    v14 = sys_ioctl(2, 21520);
    __asm { int     80h; LINUX - sys_getuid }
    dword_805B59C[0] = (int)asc_8049264;
  }
  dword_805D668 = 0;
  mode = 0;
  dword_805D670 = 0;
  dword_805D674 = 0;
  dword_805D678 = 0;
  while ( 1 )
  {
LABEL_7:
    for ( i = (const char *)dword_805B59C[0]; ; i = asc_804926D )
    {
      sub_8048DF5(i);
      if ( !sub_80482EA() )
        goto LABEL_7;
      v16 = (char **)dword_805D6FA;
      if ( !dword_805D6FA )
      {
        v23 = 0;
        dword_805D6FA = (int)&v23;
        v16 = &v23;
      }
      dword_805D6F6 = (int)++*v16;
      v17 = (__int16 *)sys_brk(0);
      v19 = sys_brk((char *)v17 + v18);
      qmemcpy(v17, &word_804959A, (unsigned int)v20);
      v20[(_DWORD)v17 - 1] = 0;
      LOBYTE(v21) = sub_804874F(v20);
      if ( !v21 )
        goto LABEL_7;
      if ( v21 >= 0 )
        break;
    }
    sub_8048B8C();
  }
}
// 804805E: positive sp value C has been found
// 8048058: variable 'v22' is possibly undefined
// 8048070: variable 'v0' is possibly undefined
// 80480DE: variable 'v5' is possibly undefined
// 80480DE: variable 'v4' is possibly undefined
// 80480EC: variable 'v8' is possibly undefined
// 80480EC: variable 'v7' is possibly undefined
// 80480FA: variable 'v11' is possibly undefined
// 80480FA: variable 'v10' is possibly undefined
// 8048199: variable 'v18' is possibly undefined
// 80481A7: variable 'v20' is possibly undefined
// 80481B5: variable 'v21' is possibly undefined
// 804804C: using guessed type void __noreturn start();
// 804959A: using guessed type __int16 word_804959A;
// 805B59C: using guessed type int dword_805B59C[];
// 805D668: using guessed type int dword_805D668;
// 805D670: using guessed type int dword_805D670;
// 805D674: using guessed type int dword_805D674;
// 805D678: using guessed type int dword_805D678;
// 805D6F6: using guessed type int dword_805D6F6;
// 805D6FA: using guessed type int dword_805D6FA;
// 805DB23: using guessed type char byte_805DB23;
// 805DB58: using guessed type int dword_805DB58;

//----- (080481C8) --------------------------------------------------------
char __usercall sub_80481C8@<al>(const char *a1@<edi>)
{
  const char *v1; // ebx
  const char *v2; // esi
  int v3; // ecx
  int v4; // eax
  _DWORD *v5; // edx
  _BYTE *v6; // edi
  char v7; // al
  _BYTE *v8; // edi
  char result; // al

  envp = (const char *)sys_brk(0);
  dword_805D706 = 1;
  v1 = envp;
  v2 = a1;
  sub_804823D(a1);
  v4 = sys_brk((void *)&v1[v3 + 8]);
  *v5 = 1279608915;
  v5[1] = 539114828;
  v6 = (char *)v5 + 7;
  do
  {
    v7 = *v2++;
    *v6++ = v7;
  }
  while ( v7 );
  v8 = v6 - 1;
  *v8 = 34;
  result = 0;
  v8[1] = 0;
  return result;
}
// 80481E8: variable 'v3' is possibly undefined
// 80481F4: variable 'v5' is possibly undefined
// 805D706: using guessed type int dword_805D706;

//----- (08048212) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall sub_8048212@<eax>(int a1@<ebp>)
{
  int v1; // edx
  int (*v3)(void); // [esp-8h] [ebp-8h]
  const char *v4; // [esp-4h] [ebp-4h]

  if ( a1 )
  {
    while ( v4 )
      ;
    v4 = 0;
  }
  do
  {
    if ( !v4 )
      break;
    v1 = dword_805D706;
    (&envp)[dword_805D706] = v4;
    dword_805D706 = v1 + 1;
  }
  while ( v1 != 49 );
  return v3();
}
// 8048218: positive sp value 8 has been found
// 8048212: could not find valid save-restore pair for ebx
// 804821A: variable 'v4' is possibly undefined
// 804823B: variable 'v3' is possibly undefined
// 805D706: using guessed type int dword_805D706;

//----- (0804823D) --------------------------------------------------------
void __usercall sub_804823D(const char *a1@<edi>)
{
  strlen(a1);
}

//----- (0804824A) --------------------------------------------------------
void __usercall sub_804824A(const char *a1@<edi>, const char *a2@<esi>)
{
  unsigned int v2; // edx
  unsigned int v3; // ecx

  sub_804823D(a1);
  sub_804823D(a2);
  if ( v3 < v2 )
    v3 = v2;
  memcmp(a2, a1, v3);
}
// 804825C: variable 'v3' is possibly undefined
// 804825C: variable 'v2' is possibly undefined

//----- (08048266) --------------------------------------------------------
int sub_8048266()
{
  int v0; // eax
  int result; // eax
  int tv_nsec; // [esp-4h] [ebp-4h]

  if ( !fd )
  {
    dword_805D6FE = 537403400;
    v0 = sys_ioctl(0, 21505);
    tv_nsec = buf.st_ctim.tv_nsec;
    result = sys_ioctl(0, 21506);
    buf.st_ctim.tv_nsec = tv_nsec;
  }
  return result;
}
// 805D6FE: using guessed type int dword_805D6FE;

//----- (080482AB) --------------------------------------------------------
int sub_80482AB()
{
  int result; // eax

  if ( !fd )
    return sys_ioctl(0, 21506);
  return result;
}

//----- (080482C6) --------------------------------------------------------
char sub_80482C6()
{
  int v0; // ecx
  int v2; // eax

  if ( sys_read(fd, &byte_805D6F3, 1u) <= 0 )
  {
    sub_80482AB();
    sub_8048DF5(aLogout);
    v2 = sys_exit(status);
  }
  return *(_BYTE *)v0;
}
// 80482E7: variable 'v0' is possibly undefined
// 805D6F3: using guessed type char byte_805D6F3;

//----- (080482EA) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char *sub_80482EA()
{
  __int16 *v0; // edi
  char v1; // al
  __int16 v2; // ax
  char v3; // t0
  char *result; // eax
  char v5; // al
  int v6; // eax
  _WORD *v7; // ecx
  const char *v8; // esi
  unsigned int v9; // ecx
  size_t v10; // ebp
  const char *v11; // edx
  const char *v12; // edi
  char *v13; // eax
  char *v14; // ebx
  char *v15; // edx
  char v16; // al
  char v17; // bp
  struct dirent *v18; // ecx
  char *v19; // eax
  int i; // edx
  struct dirent *v21; // ecx
  int v22; // eax
  struct dirent *v23; // [esp-8h] [ebp-14h]
  __int16 *v24; // [esp+4h] [ebp-8h]
  __int16 *v25; // [esp+4h] [ebp-8h]
  __int16 *v26; // [esp+4h] [ebp-8h]

  v0 = &word_804959A;
  word_804959A = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v1 = sub_80482C6();
          if ( v1 != 9 )
            break;
          v26 = v0;
          v12 = (const char *)&word_804959A;
          byte_805D90F[0] = 0;
          byte_805DB0D = 0;
          path = (const char *)&word_804959A;
          sub_804823D((const char *)&word_804959A);
          v14 = dword_805D702;
          v11 = 0;
          while ( --v12 != v13 )
          {
            if ( *v12 == 47 && !v11 )
              v11 = v12;
            if ( *v12 == 32 )
            {
              v14 = (char *)++v12;
              if ( v11 )
                goto LABEL_57;
              break;
            }
          }
          if ( *v13 == 47 )
          {
            if ( !v11 )
              v11 = v13;
            v14 = v13;
          }
          else if ( *v13 != 46 || !v11 )
          {
            v14 = dword_805D702;
            path = v12;
            goto LABEL_58;
          }
LABEL_57:
          path = v11 + 1;
LABEL_58:
          if ( sys_newstat(v14, &buf) < 0 || (buf.__pad1 & 0x4000) != 0 )
          {
            v16 = *v15;
            *v15 = 0;
            v17 = v16;
            while ( 1 )
            {
              if ( v14 == v15 )
                v14 = &dword_805D702[1];
              if ( sys_open(v14, 0x10000, (mode_t)v15) >= 0 )
              {
                *v15 = v17;
                while ( 1 )
                {
                  v18 = &dirp;
                  __asm { int     80h; LINUX - sys_getdents }
                  v19 = &dirp.d_name[130];
                  for ( i = 0; ; i = v23->d_reclen )
                  {
                    v21 = (struct dirent *)((char *)v18 + i);
                    if ( v19 <= (char *)v21 )
                      break;
                    v23 = v21;
                    sub_804824A((const char *)&v21->d_type, path);
                    v18 = v23;
                  }
                }
              }
              v14 = dword_805D702;
            }
          }
          sub_8048E06(1u, &a11p[10]);
          v0 = v26;
        }
        if ( v1 != 27 )
          break;
        v6 = sys_read(fd, byte_805D6F4, 2u);
        switch ( *v7 )
        {
          case 0x445B:
            if ( v0 == &word_804959A )
              goto LABEL_36;
            v0 = (__int16 *)((char *)v0 - 1);
            sub_8048E06(1u, &dword_805D6FE);
            break;
          case 0x435B:
            if ( !*(_BYTE *)v0 )
              goto LABEL_36;
            sub_8048E06(1u, v0);
            v0 = (__int16 *)((char *)v0 + 1);
            break;
          case 0x415B:
            if ( !dword_805D6F6 )
              goto LABEL_36;
            --dword_805D6F6;
LABEL_39:
            if ( !dword_805D6FA )
              goto LABEL_36;
            if ( (unsigned int)dword_805D6F6 < *(_DWORD *)dword_805D6FA )
            {
              v8 = *(const char **)(dword_805D6FA - 4 * (dword_805D6F6 + 1));
              sub_804823D(v8);
              v10 = --v9 - 1;
              qmemcpy(&word_804959A, v8, v9);
              v0 = (__int16 *)((char *)&word_804959A + v9 - 1);
              sub_8048E06(5u, &word_80494FA);
              sub_8048DF5((const char *)dword_805B59C[0]);
              sub_8048E06(v10, &word_804959A);
            }
            else
            {
              --dword_805D6F6;
LABEL_36:
              sub_8048E06(1u, &a11p[10]);
            }
            break;
          case 0x425B:
            ++dword_805D6F6;
            goto LABEL_39;
        }
      }
      if ( v1 != 8 && v1 != 127 )
        break;
      if ( v0 == &word_804959A )
        goto LABEL_36;
      if ( *(_BYTE *)v0 )
      {
        v25 = v0;
        do
        {
          v5 = *(_BYTE *)v0;
          v0 = (__int16 *)((char *)v0 + 1);
          *((_BYTE *)v0 - 2) = v5;
        }
        while ( v5 );
        sub_8048E06(5u, &a11p[5]);
        v0 = (__int16 *)((char *)v25 - 1);
        BYTE1(dword_805D6FE) = *((_BYTE *)v25 - 1);
        sub_8048E06(2u, (char *)&dword_805D6FE + 1);
      }
      else
      {
        v0 = (__int16 *)((char *)v0 - 1);
        *(_BYTE *)v0 = 0;
        BYTE1(dword_805D6FE) = 32;
        sub_8048E06(3u, &dword_805D6FE);
      }
    }
    if ( v1 == 4 )
    {
      sub_80482AB();
      sub_8048DF5(aLogout);
      v22 = sys_exit(status);
    }
    if ( v1 == 12 )
    {
      sub_804911E();
      JUMPOUT(0x8048155);
    }
    sub_8048E06(1u, &byte_805D6F3);
    LOBYTE(v2) = byte_805D6F3;
    if ( byte_805D6F3 == 10 )
      break;
    HIBYTE(v2) = 0;
    if ( *(_BYTE *)v0 )
    {
      v24 = v0;
      do
      {
        v3 = v2;
        LOBYTE(v2) = *(_BYTE *)v0;
        *(_BYTE *)v0 = v3;
        v0 = (__int16 *)((char *)v0 + 1);
      }
      while ( (_BYTE)v2 );
      *(_BYTE *)v0 = 0;
      v0 = (__int16 *)((char *)v24 + 1);
      sub_8048E06(4u, a11p);
      sub_8048E06(1u, (char *)v24 + 1);
      sub_8048E06(1u, &dword_805D6FE);
    }
    else
    {
      *v0 = v2;
      v0 = (__int16 *)((char *)v0 + 1);
    }
  }
  while ( *(_BYTE *)v0 )
    v0 = (__int16 *)((char *)v0 + 1);
  *v0 = 10;
  result = (char *)v0 - 134518169;
  if ( v0 == &word_804959A )
    return 0;
  return result;
}
// 8048676: positive sp value 4 has been found
// 80483A0: control flows out of bounds to 8048155
// 80485F1: conditional instruction was optimized away because %var_C.4==0
// 8048416: variable 'v7' is possibly undefined
// 80484AA: variable 'v9' is possibly undefined
// 804850B: variable 'v13' is possibly undefined
// 804857F: variable 'v15' is possibly undefined
// 80485D1: variable 'v19' is possibly undefined
// 80494FA: using guessed type __int16 word_80494FA;
// 804959A: using guessed type __int16 word_804959A;
// 805B59C: using guessed type int dword_805B59C[];
// 805D6F3: using guessed type char byte_805D6F3;
// 805D6F6: using guessed type int dword_805D6F6;
// 805D6FA: using guessed type int dword_805D6FA;
// 805D6FE: using guessed type int dword_805D6FE;
// 805DB0D: using guessed type char byte_805DB0D;

//----- (0804874F) --------------------------------------------------------
char __usercall sub_804874F@<al>(char *a1@<eax>)
{
  char *v1; // esi
  int v2; // ebx
  char *v3; // ecx
  mode_t v4; // edx
  int v5; // ebp
  char *v6; // edi
  int v7; // ecx
  _DWORD *v8; // edi
  char **v9; // esi
  int v10; // ecx
  int v11; // edx
  char *v12; // esi
  bool v13; // zf
  char v14; // al
  int v15; // eax
  unsigned int v16; // ebx
  char *v17; // esi
  int v18; // edi
  char v19; // al
  unsigned int v20; // ecx
  char *v21; // esi
  char *v22; // esi
  const void *v23; // esi
  char *v24; // edi
  char *v25; // ecx
  int v26; // ebp
  __int16 *v27; // edi
  char *v28; // ebx
  _BYTE *v29; // edi
  struct dirent *v30; // ecx
  char *v31; // eax
  int d_reclen; // edx
  struct dirent *v33; // ecx
  char *p_d_type; // edi
  char *v35; // edi
  char *v36; // eax
  char *v37; // edx
  char *v38; // edi
  char *v39; // esi
  char v40; // al
  struct dirent *v42; // [esp-8h] [ebp-30h]
  char *v43; // [esp-4h] [ebp-2Ch]
  char *v44; // [esp+0h] [ebp-28h]
  char *v45; // [esp+8h] [ebp-20h]
  _DWORD *v46; // [esp+10h] [ebp-18h]
  char *v47; // [esp+10h] [ebp-18h]
  char **v48; // [esp+14h] [ebp-14h]
  int v49; // [esp+14h] [ebp-14h]
  char *v50; // [esp+18h] [ebp-10h]
  char *v51; // [esp+18h] [ebp-10h]
  mode_t v52; // [esp+1Ch] [ebp-Ch]
  char *v53; // [esp+1Ch] [ebp-Ch]
  int v54; // [esp+1Ch] [ebp-Ch]
  char *v55; // [esp+20h] [ebp-8h]
  char *v56; // [esp+20h] [ebp-8h]
  char *v57; // [esp+20h] [ebp-8h]
  char *v58; // [esp+24h] [ebp-4h]
  char *v59; // [esp+24h] [ebp-4h]
  char *v60; // [esp+24h] [ebp-4h]
  char *v61; // [esp+24h] [ebp-4h]

LABEL_1:
  v1 = (char *)&word_804959A + dword_805D674;
  v2 = dword_805D668;
  v3 = a1;
  v4 = mode;
  v5 = dword_805D678;
  v6 = (char *)&word_804A59A + dword_805D670;
  while ( 1 )
  {
    LOBYTE(a1) = *v1++;
    if ( !(_BYTE)a1 )
      break;
    if ( (v2 & 1) != 0 )
      goto LABEL_17;
    switch ( (_BYTE)a1 )
    {
      case 0x23:
        goto LABEL_33;
      case 0x24:
        v58 = v6;
        v55 = v3;
        v52 = v4;
        v50 = v1;
        v8 = v1;
        v9 = (char **)&envp;
        v10 = *v8;
        v11 = *v8;
        while ( 1 )
        {
          a1 = *v9++;
          if ( !a1 )
            break;
          if ( *a1 == (_BYTE)v11 )
          {
            v48 = v9;
            v46 = v8;
            v12 = a1;
            do
            {
              if ( !v10 )
                break;
              v13 = *v12++ == *(_BYTE *)v8;
              v8 = (_DWORD *)((char *)v8 + 1);
              --v10;
            }
            while ( v13 );
            if ( *((_BYTE *)v8 - 1) <= 0x20u )
            {
              (&argv)[v5++] = v12;
              v1 = (char *)v8;
              v4 = v52 + 1;
              goto LABEL_58;
            }
            v8 = v46;
            v9 = v48;
          }
        }
        v1 = v50;
        do
          v14 = *v1++;
        while ( v14 && v14 > 32 );
        v4 = v52;
LABEL_58:
        v3 = v55;
        v6 = v58;
        break;
      case 9:
        goto LABEL_32;
      case 0xA:
        goto LABEL_33;
      case 0x20:
        goto LABEL_32;
      case 0x3E:
        goto LABEL_39;
      case 0x3C:
        return (char)a1;
      case 0x3F:
      case 0x2A:
        goto LABEL_60;
      default:
        if ( (_BYTE)a1 == 124 && *v1 != 124 && *(v1 - 2) != 124 )
        {
LABEL_59:
          v59 = v3;
          *v6 = 0;
          sub_80488D8(v4, v5);
          dword_805D674 = v1 - (char *)&word_804959A;
          v15 = sys_pipe(&filedes);
          old_fd = dword_805D688;
          byte_805DB22 = 1;
          sub_8048B8C();
          dword_805D67C = filedes;
          a1 = v59;
          goto LABEL_1;
        }
        (&argv)[v5++] = v6;
        ++v4;
        v2 |= 1u;
LABEL_17:
        if ( (_BYTE)a1 == 34 )
        {
          v2 ^= 2u;
LABEL_32:
          if ( !--v3 )
            goto LABEL_33;
        }
        else
        {
          if ( (v2 & 2) != 0 )
            goto LABEL_31;
          switch ( (_BYTE)a1 )
          {
            case 9:
              goto LABEL_30;
            case 0xA:
              goto LABEL_33;
            case 0x3E:
LABEL_39:
              LOBYTE(a1) = v2;
              return (char)a1;
            case 0x3C:
              return (char)a1;
          }
          if ( (_BYTE)a1 != 63 && (_BYTE)a1 != 42 )
          {
            if ( (_BYTE)a1 == 124 && *v1 != 124 && *(v1 - 2) != 124 )
              goto LABEL_59;
            if ( (_BYTE)a1 == 32 )
            {
LABEL_30:
              a1 = 0;
              v2 &= ~1u;
            }
LABEL_31:
            *v6++ = (char)a1;
            goto LABEL_32;
          }
LABEL_60:
          byte_805D90F[0] = 0;
          if ( (v2 & 1) != 0 )
          {
            v16 = v2 & 0xFFFFFFFE;
            v60 = a1;
            v56 = v3;
            v53 = v1;
            v51 = v6;
            v17 = v6;
            v18 = dword_805B59C[v5];
            while ( v17 != (char *)v18 )
            {
              v19 = *v17++;
              if ( v19 == 47 )
              {
                v20 = (unsigned int)&v17[-v18 + 1];
                v21 = (char *)dword_805B59C[v5];
                qmemcpy(byte_805D90F, v21, v20);
                v22 = &v21[v20];
                byte_805D90F[v20] = 0;
                goto LABEL_66;
              }
            }
            v22 = v17 - 1;
LABEL_66:
            v23 = v22 + 1;
            qmemcpy(&word_805DA0E, v23, v51 - (_BYTE *)v23);
            v24 = (char *)&word_805DA0E + v51 - (_BYTE *)v23;
            (&argv)[v5] = v24;
            *v24 = 0;
            v1 = v53;
            v25 = v56;
            a1 = v60;
            --v4;
            v26 = v5 - 1;
            v57 = (&argv)[v26];
            v54 = v26;
            v49 = v16;
            v47 = v25;
            v45 = v60;
            v27 = (__int16 *)dword_805B5A4[v26];
            v28 = byte_805D90F;
            if ( !byte_805D90F[0] )
              v28 = dword_805D702;
          }
          else
          {
            v57 = v6;
            v54 = v5;
            v49 = v2;
            v47 = v3;
            v45 = a1;
            v27 = &word_805DA0E;
            v28 = dword_805D702;
          }
          *(_BYTE *)v27 = (_BYTE)a1;
          v29 = (char *)v27 + 1;
          v44 = a1;
          while ( 1 )
          {
            LOBYTE(a1) = *v1++;
            if ( (_BYTE)a1 == 10 || (_BYTE)a1 == 9 || (_BYTE)a1 == 32 )
              break;
            *v29++ = (_BYTE)a1;
            --v57;
          }
          v61 = a1;
          *v29 = 0;
          if ( sys_open(v28, 0x10000, v4) >= 0 )
          {
            while ( 1 )
            {
              v30 = &dirp;
              __asm { int     80h; LINUX - sys_getdents }
              v31 = &dirp.d_name[130];
              d_reclen = 0;
              while ( 1 )
              {
                v33 = (struct dirent *)((char *)v30 + d_reclen);
                if ( v31 <= (char *)v33 )
                  break;
                v42 = v33;
                p_d_type = (char *)&v33->d_type;
                sub_804824A((const char *)&v33->d_type, (const char *)&word_805DA0E);
                v35 = p_d_type - 1;
                v30 = v42;
                v43 = v36;
                if ( *((_BYTE *)&word_805DA0E - 1) == (_BYTE)v44 )
                {
                  sub_8048AF2((int)v44, v35, (int)&word_805DA0E - 1);
                  if ( v13 )
                  {
                    v38 = v45;
                    ++v54;
                    (&argv)[(_DWORD)v47++] = v45;
                    v39 = v37;
                    do
                    {
                      v40 = *v39++;
                      *v38++ = v40;
                    }
                    while ( v40 );
                    v45 = v38;
                  }
                }
                d_reclen = v30->d_reclen;
                v31 = v43;
              }
            }
          }
          a1 = v45;
          v4 = (mode_t)(v1 - 1);
          v3 = v47;
          v2 = v49;
          v5 = v54;
          v6 = v57;
          v1 = v61;
        }
        break;
    }
  }
LABEL_33:
  if ( (v2 & 2) != 0 )
  {
    dword_805D674 = 0;
    LOBYTE(a1) = -1;
    dword_805D668 = v2;
    mode = v4;
    dword_805D670 = v6 - (char *)&word_804A59A;
    dword_805D678 = v5;
  }
  else
  {
    *v6 = 0;
    if ( (v2 & 0x10) != 0 )
    {
      --v5;
      if ( (v2 & 0x20) != 0 )
        v7 = 33857;
      else
        v7 = 33345;
      old_fd = sys_open((&argv)[v5], v7, 0x1A4u);
    }
    else if ( (v2 & 8) != 0 )
    {
      dword_805D67C = sys_open((&argv)[--v5], 0x8000, v4 - 1);
    }
    LOBYTE(a1) = sub_80488D8(v4, v5);
  }
  return (char)a1;
}
// 8048877: variable 'v4' is possibly undefined
// 8048A91: variable 'v30' is possibly undefined
// 8048AAE: variable 'v36' is possibly undefined
// 8048ABC: variable 'v13' is possibly undefined
// 8048AD2: variable 'v37' is possibly undefined
// 804959A: using guessed type __int16 word_804959A;
// 804A59A: using guessed type __int16 word_804A59A;
// 805B59C: using guessed type int dword_805B59C[];
// 805B5A4: using guessed type int dword_805B5A4[];
// 805D668: using guessed type int dword_805D668;
// 805D670: using guessed type int dword_805D670;
// 805D674: using guessed type int dword_805D674;
// 805D678: using guessed type int dword_805D678;
// 805D688: using guessed type int dword_805D688;
// 805DA0E: using guessed type __int16 word_805DA0E;
// 805DB22: using guessed type char byte_805DB22;

//----- (080488D8) --------------------------------------------------------
int __usercall sub_80488D8@<eax>(int a1@<edx>, int a2@<ebp>)
{
  (&argv)[a2] = 0;
  dword_805D668 = 0;
  mode = 0;
  dword_805D670 = 0;
  dword_805D674 = 0;
  dword_805D678 = 0;
  return a1;
}
// 805D668: using guessed type int dword_805D668;
// 805D670: using guessed type int dword_805D670;
// 805D674: using guessed type int dword_805D674;
// 805D678: using guessed type int dword_805D678;

//----- (08048AF2) --------------------------------------------------------
void __usercall sub_8048AF2(int a1@<eax>, _BYTE *a2@<edi>, int a3@<esi>)
{
  char *i; // esi
  char v4; // zf

  for ( i = (char *)(a3 + 1); ; ++i )
  {
    while ( (_BYTE)a1 == 42 )
    {
      sub_8048B1B(a2, i);
      if ( !v4 )
        return;
LABEL_10:
      LOBYTE(a1) = *i++;
      ++a2;
    }
    if ( (_BYTE)a1 != 63 )
      break;
    ++a2;
    LOBYTE(a1) = *i;
  }
  BYTE1(a1) = *a2;
  if ( a1 && BYTE1(a1) == (_BYTE)a1 )
    goto LABEL_10;
}
// 8048AFE: variable 'v4' is possibly undefined
// 8048B0E: variable 'a1' is possibly undefined

//----- (08048B1B) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char __usercall sub_8048B1B@<al>(_BYTE *a1@<edi>, char *a2@<esi>)
{
  char result; // al
  char v3; // [esp-4h] [ebp-4h]

  do
  {
    result = *a2++;
    if ( !result )
      return v3;
  }
  while ( result == 42 );
  while ( result != *a1 )
  {
    if ( !*a1 )
      return v3;
    ++a1;
  }
  return result;
}
// 8048B37: positive sp value C has been found
// 8048B36: variable 'v3' is possibly undefined

//----- (08048B38) --------------------------------------------------------
int __usercall sub_8048B38@<eax>(const void *a1@<eax>, int *a2@<edi>)
{
  int v2; // eax
  __int16 v3; // ax
  int result; // eax

  if ( (_BYTE)status == 127 )
  {
    v2 = sub_8048DD5(0);
    if ( !a2 )
      __asm { int     3; - software interrupt to invoke the debugger }
    *a2 = v2;
    a2 = (int *)((char *)a2 - (unsigned int)&dword_805DB28);
    HIBYTE(v3) = 10;
    LOBYTE(v3) = ((unsigned int)a2 >> 2) + 48;
    word_805DB0E = v3;
    sub_8048DF5(aStoppedId);
    a1 = sub_8048E06(2u, &word_805DB0E);
  }
  result = sub_8048DD5((int)a1);
  if ( a2 )
  {
    result = 0;
    *a2 = 0;
  }
  return result;
}
// 805DB0E: using guessed type __int16 word_805DB0E;
// 805DB28: using guessed type int dword_805DB28;

//----- (08048B8C) --------------------------------------------------------
int sub_8048B8C()
{
  char **i; // ebx
  int *v1; // edi
  int v2; // ecx
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  const void *v7; // eax
  int v8; // eax
  __int16 v9; // ax
  int v10; // eax
  int v11; // eax

  for ( i = &off_8049394; ; i += 3 )
  {
    v1 = (int *)argv;
    if ( !*i )
      break;
    sub_804824A(argv, *i);
    if ( !v2 )
    {
      if ( i[2] )
        return ((int (*)(void))i[1])();
      break;
    }
  }
  sub_80482AB();
  __asm { int     80h; LINUX - sys_fork }
  pid = 2;
  v4 = old_fd;
  if ( dword_805D67C )
    v5 = sys_close(dword_805D67C);
  if ( v4 != 1 && v4 )
    v6 = sys_close(v4);
  dword_805D67C = 0;
  old_fd = 0;
  if ( byte_805DB22 )
    goto LABEL_18;
  while ( 1 )
  {
    do
      v7 = (const void *)sys_wait4(-1, &status, 2, 0);
    while ( (int)v7 < 0 );
    if ( (const void *)pid == v7 )
      break;
    sub_8048B38(v7, v1);
  }
  pid = 0;
  if ( byte_805DB23 )
  {
    if ( (_BYTE)status == 127 )
    {
LABEL_18:
      v8 = sub_8048DD5(0);
      if ( !v1 )
        __asm { int     3; - software interrupt to invoke the debugger }
      *v1 = v8;
      LOBYTE(v9) = ((unsigned int)((char *)v1 - (char *)&dword_805DB28) >> 2) + 48;
      HIBYTE(v9) = 10;
      word_805DB0E = v9;
      if ( !byte_805DB22 )
      {
        sub_8048DF5(aStoppedId);
        sub_8048E06(2u, &word_805DB0E);
      }
    }
  }
  sub_80482AB();
  __asm { int     80h; LINUX - sys_getpid }
  dword_805DB58 = 20;
  v10 = sys_setpgid(20, 0);
  v11 = sys_ioctl(2, 21520);
  byte_805DB22 = 0;
  return sub_8048266();
}
// 8048BA4: variable 'v2' is possibly undefined
// 8048CF1: variable 'v4' is possibly undefined
// 8049394: using guessed type char *off_8049394;
// 805DB0E: using guessed type __int16 word_805DB0E;
// 805DB22: using guessed type char byte_805DB22;
// 805DB23: using guessed type char byte_805DB23;
// 805DB28: using guessed type int dword_805DB28;
// 805DB58: using guessed type int dword_805DB58;

//----- (08048DD5) --------------------------------------------------------
int __usercall sub_8048DD5@<eax>(int a1@<ebx>)
{
  int *v1; // esi
  int result; // eax

  v1 = &dword_805DB28;
  do
  {
    if ( v1 >= &status )
      break;
    result = *v1++;
  }
  while ( result != a1 );
  return result;
}
// 805DB28: using guessed type int dword_805DB28;

//----- (08048DF5) --------------------------------------------------------
void __usercall sub_8048DF5(const char *a1@<eax>)
{
  int v1; // ecx
  const void *v2; // eax

  sub_804823D(a1);
  sub_8048E06(v1 - 2, v2);
}
// 8048DFE: variable 'v1' is possibly undefined
// 8048DFF: variable 'v2' is possibly undefined

//----- (08048E06) --------------------------------------------------------
const void *__usercall sub_8048E06@<eax>(size_t len@<ecx>, const void *result@<eax>)
{
  if ( byte_805DB23 )
    return (const void *)sys_write(1, result, len);
  return result;
}
// 805DB23: using guessed type char byte_805DB23;

//----- (08048E1C) --------------------------------------------------------
const char *__usercall sub_8048E1C@<eax>(const char *a1@<eax>)
{
  int v1; // ecx
  const void *v2; // eax
  int v3; // eax

  sub_804823D(a1);
  v3 = sys_write(2, v2, v1 - 2);
  return a1;
}
// 8048E30: variable 'v2' is possibly undefined
// 8048E26: variable 'v1' is possibly undefined

//----- (08048FEA) --------------------------------------------------------
void sub_8048FEA()
{
  sub_8048DF5(aChildIs0xdeadI);
}

//----- (08049100) --------------------------------------------------------
void sub_8049100()
{
  int v0; // eax

  if ( pid )
    v0 = sys_kill(pid, 19);
  else
    sub_8048DF5(aYouSayStopAndI);
}

//----- (0804911E) --------------------------------------------------------
void sub_804911E()
{
  sub_8048DF5((const char *)sub_8049129);
}

//----- (08049129) --------------------------------------------------------
char *__usercall sub_8049129@<eax>(
        char a1@<cf>,
        int a2@<eax>,
        char a3@<dh>,
        _BYTE *a4@<ecx>,
        unsigned int a5@<ebx>,
        int a6@<esi>)
{
  int v6; // ebx
  char *result; // eax
  char **i; // edx
  int v9; // ecx
  int v10; // [esp-4h] [ebp-4h]

  v6 = (__PAIR64__(a5 - (a1 + *(_DWORD *)(a5 + 72)), a5)
      - __PAIR64__(*(_DWORD *)(a5 - (a1 + *(_DWORD *)(a5 + 72)) + 74), (unsigned int)a1 + *(_DWORD *)(a5 + 72))) >> 32;
  *(_BYTE *)(v6 + 95790109) += (_BYTE)a4;
  *a4 |= a3;
  *(_BYTE *)(a6 - 127) = 0;
  result = (char *)(a2 - 1712288878 + 1);
  for ( i = &off_8049394; *i; i += 3 )
  {
    if ( i[2] != (char *)-1 )
    {
      if ( !v6 || (v10 = (int)result, sub_804824A((const char *)v6, *i), result = (char *)v10, !v9) )
        i[2] = result;
    }
  }
  return result;
}
// 804917A: variable 'v9' is possibly undefined
// 804917C: variable 'i' is possibly undefined
// 8049394: using guessed type char *off_8049394;

// nfuncs=23 queued=23 decompiled=23 lumina nreq=0 worse=0 better=0
// ALL OK, 23 function(s) have been successfully decompiled
