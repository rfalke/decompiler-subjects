// subject_seg08048000_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Stack (ptr32 byte) dwArg04, Stack (ptr32 code) dwArg08)
void fn0804804C(byte * dwArg04, <anonymous> * dwArg08)
{
	g_dw805D702 = 0x2F2E;
	fn080481C8(dwArg04);
	word32 ebp_22 = fn08048212(dwArg08, dwArg08);
	if (ebp_22 != 0x00)
	{
		__syscall(0x80);
		g_dw805DB54 = 0x05;
		g_ptr805B59C = &g_b804926A;
	}
	else
	{
		g_b805DB23 = 0x01;
		fn08048DF5(&g_b8049254);
		g_dw805DB54 = ebp_22;
		fn08048266();
		g_dw804950E = 0x01;
		__syscall(0x80);
		g_dw804950E = 0x01;
		__syscall(0x80);
		g_dw804950E = 0x080490E2;
		__syscall(0x80);
		g_dw804950E = 0x08049100;
		__syscall(0x80);
		__syscall(0x80);
		g_dw805DB58 = 0x14;
		__syscall(0x80);
		__syscall(0x80);
		__syscall(0x80);
		g_ptr805B59C = &g_b8049264;
	}
	g_dw805D668 = 0x00;
	g_dw805D66C = 0x00;
	g_ptr805D670 = 0x00;
	g_ptr805D674 = 0x00;
	g_dw805D678 = 0x00;
	fn08048155();
}

// 08048155: Register (ptr32 byte) fn08048155()
// Called from:
//      fn0804804C
//      fn08048161
//      fn080482EA
byte * fn08048155()
{
	return fn08048161(eax);
}

// 08048161: Register (ptr32 byte) fn08048161(Register (ptr32 byte) eax)
// Called from:
//      fn0804804C
//      fn08048155
byte * fn08048161(byte * eax)
{
	struct Eq_108 * esp_2 = fp;
	while (true)
	{
		fn08048DF5(eax);
		ui32 eax_12 = fn080482EA();
		struct Eq_108 * esp_10 = esp_2;
		if (eax_12 == 0x00)
			break;
		up32 * ecx_33 = g_ptr805D6FA;
		up32 * ecx_34 = ecx_33;
		if (ecx_33 == null)
		{
			esp_2->dwFFFFFFFC = 0x00;
			g_ptr805D6FA = esp_2 - 4;
			esp_10 = esp_2 - 4;
			ecx_34 = esp_2 - 4;
		}
		++*ecx_34;
		g_dw805D6F6 = *ecx_34;
		struct Eq_108 * esp_50 = esp_10 - 4;
		esp_50->ptr0000 = (struct Eq_143 *) 0x2D;
		struct Eq_143 * eax_52 = esp_50->ptr0000;
		__syscall(0x80);
		esp_50->ptr0000 = eax_52;
		esp_50->dwFFFFFFFC = 0x2D;
		__syscall(0x80);
		struct Eq_143 * edi_129 = eax_52;
		esp_2 = esp_50;
		byte * esi_124 = g_a804959A;
		ui32 ecx_130;
		for (ecx_130 = eax_12; ecx_130 != 0x00; --ecx_130)
		{
			edi_129->b0000 = *esi_124;
			++esi_124;
			++edi_129;
		}
		edi_129->bFFFFFFFF = 0x00;
		int32 eax_77 = fn0804874F(eax_12);
		if (eax_77 == 0x00)
			return fn08048155();
		if (eax_77 >= 0x00)
		{
			fn08048B8C();
			return fn08048155();
		}
		eax = &g_b804926D;
	}
	return fn08048155();
}

// 080481C8: void fn080481C8(Register (ptr32 byte) edi)
// Called from:
//      fn0804804C
void fn080481C8(byte * edi)
{
	__syscall(0x80);
	g_dw805D5A0 = 0x2D;
	g_dw805D706 = 0x01;
	word32 edi_71;
	fn0804823D(edi, out edi_71);
	__syscall(0x80);
	*(word32 *) 0x2D = 0x4C454853;
	*(word32 *) 0x31 = 0x20223D4C;
	byte * esi_17 = edi;
	struct Eq_239 * edi_36 = (struct Eq_239 *) 0x34;
	do
	{
		byte al_40 = *esi_17;
		edi_36->b0000 = al_40;
		++esi_17;
		++edi_36;
	} while (al_40 != 0x00);
	edi_36->bFFFFFFFF = 0x22;
	edi_36->b0000 = 0x00;
}

// 08048212: Register (ptr32 code) fn08048212(Register (ptr32 code) ebp, Stack (ptr32 code) dwArg00)
// Called from:
//      fn0804804C
<anonymous> * fn08048212(<anonymous> * ebp, <anonymous> * dwArg00)
{
	struct Eq_262 * esp_11 = fp + 4;
	if (ebp != null)
	{
		do
		{
			word32 eax_13 = esp_11->dw0000;
			++esp_11;
		} while (eax_13 != 0x00);
		esp_11->dwFFFFFFFC = eax_13;
		esp_11 -= 4;
	}
	do
	{
		word32 eax_23 = esp_11->dw0000;
		++esp_11;
		if (eax_23 == 0x00)
			break;
		ui32 edx_29 = g_dw805D706;
		(&g_dw805D5A0)[edx_29 * 0x04] = eax_23;
		g_dw805D706 = edx_29 + 0x01;
	} while (edx_29 != 0x31);
	<anonymous> * ebp_44;
	dwArg00();
	return ebp_44;
}

// 0804823D: Register word32 fn0804823D(Register (ptr32 byte) edi, Register out (ptr32 byte) ediOut)
// Called from:
//      fn080481C8
//      fn0804824A
//      fn080482EA
//      fn08048B8C
//      fn08048DF5
//      fn08048E1C
word32 fn0804823D(byte * edi, byte & ediOut)
{
	word32 ecx_12 = ~0x00;
	while (ecx_12 != 0x00)
	{
		++edi;
		--ecx_12;
		if (*edi != 0x00)
			break;
	}
	ediOut = edi;
	return -ecx_12;
}

// 0804824A: Register up32 fn0804824A(Register (ptr32 byte) esi, Register (ptr32 byte) edi, Register out (ptr32 byte) esiOut, Register out (ptr32 byte) ediOut)
// Called from:
//      fn080482EA
//      fn0804874F
//      fn08048B8C
up32 fn0804824A(byte * esi, byte * edi, byte & esiOut, byte & ediOut)
{
	word32 edi_81;
	up32 ecx_9 = fn0804823D(edi, out edi_81);
	word32 edi_82;
	up32 ecx_19 = fn0804823D(esi, out edi_82);
	if (ecx_19 < ecx_9)
		ecx_19 = ecx_9;
	byte * edi_31 = edi;
	while (ecx_19 != 0x00)
	{
		++esi;
		++edi_31;
		--ecx_19;
		if (*esi == *edi_31)
			break;
	}
	esiOut = esi;
	ediOut = edi_31;
	return ecx_19;
}

// 08048266: void fn08048266()
// Called from:
//      fn0804804C
//      fn08048B8C
void fn08048266()
{
	if (g_dw805DB54 == 0x00)
	{
		g_dw805D6FE = 0x20082008;
		__syscall(0x80);
		ui32 eax_13 = g_dw805D6D8;
		g_dw805D6D8 = eax_13 & ~0x0A;
		__syscall(0x80);
		g_dw805D6D8 = eax_13;
	}
}

// 080482AB: void fn080482AB()
// Called from:
//      fn080482C6
//      fn08048B8C
void fn080482AB()
{
	if (g_dw805DB54 == 0x00)
		__syscall(0x80);
}

// 080482C6: Register byte fn080482C6()
// Called from:
//      fn080482EA
byte fn080482C6()
{
	__syscall(0x80);
	return g_b805D6F3;
}

// 080482EA: Register (ptr32 byte) fn080482EA()
// Called from:
//      fn08048161
byte * fn080482EA()
{
}

// 0804874F: Register ui32 fn0804874F(Register ui32 eax)
// Called from:
//      fn08048161
ui32 fn0804874F(ui32 eax)
{
l0804874F:
	word24 eax_24_8_204 = SLICE(eax, word24, 8);
	struct Eq_697 * esi_105 = g_ptr805D674 + 0x0804959A;
	ui32 ebx_154 = g_dw805D668;
	ui32 ecx_114 = eax;
	word32 edx_110 = g_dw805D66C;
	ui32 ebp_104 = g_dw805D678;
	byte * edi_116 = g_ptr805D670 + 0x0804A59A;
	while (true)
	{
		Eq_727 al_16 = esi_105->t0000;
		++esi_105;
		if (al_16 == 0x00)
			break;
		ui32 eax_957;
		word32 eax_203;
		if ((ebx_154 & 0x01) != 0x00)
		{
l080487FA:
			if (al_16 == 0x22)
			{
				ebx_154 = ebx_154 ^ 0x02;
				goto l08048851;
			}
			if ((ebx_154 & 0x02) == 0x00)
			{
				if (al_16 == 0x09)
				{
l0804884B:
					al_16.u0 = 0x00;
					eax_24_8_204 = 0x00;
					ebx_154 &= ~0x01;
					goto l08048850;
				}
				if (al_16 == 0x0A)
					break;
				if (al_16 == 0x3E)
					return ebx_154;
				eax_957 = SEQ(eax_24_8_204, al_16);
				if (al_16 == 0x3C)
					return eax_957;
				eax_203 = SEQ(eax_24_8_204, al_16);
				if (al_16 == 0x3F)
				{
l080489B6:
					ui32 dwLoc18_814;
					byte * dwLoc20_816;
					byte * edi_241;
					g_a805D90F[0] = 0x00;
					if ((ebx_154 & 0x01) != 0x00)
					{
						byte * esi_255 = edi_116;
						byte * edi_256 = *((char *) &g_ptr805B59C + ebp_104 * 0x04);
						do
						{
							byte * esi_261;
							if (esi_1015 == edi_256)
							{
								esi_261 = esi_1015 - 0x01;
								goto l080489F4;
							}
							esi_255 = esi_1015 - 1;
							esi_1015 = esi_255;
						} while (*esi_1015 != 0x2F);
						ptr32 ecx_272;
						esi_261 = edi_256;
						byte * edi_275 = g_a805D90F;
						for (ecx_272 = esi_255 - edi_256 + 0x01; ecx_272 != 0x00; --ecx_272)
						{
							*edi_275 = *esi_261;
							++esi_261;
							++edi_275;
						}
						*edi_275 = 0x00;
l080489F4:
						byte * esi_286 = esi_261 + 1;
						byte * edi_287 = g_a805DA0E;
						int32 ecx_296;
						for (ecx_296 = edi_116 - esi_286; ecx_296 != 0x00; --ecx_296)
						{
							*edi_287 = *esi_286;
							++esi_286;
							++edi_287;
						}
						*((char *) &g_ptr805B5A0 + ebp_104 * 0x04) = (byte **) edi_287;
						*edi_287 = 0x00;
						ui32 ebp_315 = ebp_104 - 0x01;
						dwLoc18_814 = ebp_315;
						dwLoc20_816 = (byte *) *((char *) &g_ptr805B5A0 + ebp_315 * 0x04);
						edi_241 = (byte *) *((char *) g_a805B5A4 + ebp_315 * 0x04);
					}
					else
					{
						dwLoc18_814 = ebp_104;
						dwLoc20_816 = edi_116;
						edi_241 = g_a805DA0E;
					}
					byte al_343 = (byte) eax_203;
					*edi_241 = al_343;
					struct Eq_697 * esi_356 = esi_105;
					byte * edi_348 = edi_241 + 1;
					while (true)
					{
						byte al_358 = esi_356->t0000;
						++esi_356;
						if (al_358 == 0x0A || (al_358 == 0x09 || al_358 == 0x20))
							break;
						*edi_348 = al_358;
						++edi_348;
					}
					*edi_348 = 0x00;
					__syscall(0x80);
					while (true)
					{
						__syscall(0x80);
						struct Eq_1010 * ecx_396 = &g_t805D70A;
						word32 edx_431 = 0x00;
						while (true)
						{
							struct Eq_1010 * ecx_436 = ecx_396 + edx_431 / 0x0A;
							if (ecx_436 >= &g_t805D797)
								break;
							word32 edi_454;
							struct Eq_1015 * esi_455;
							fn0804824A(g_a805DA0E, &ecx_436->w0008 + 1, out esi_455, out edi_454);
							ecx_396 = ecx_436;
							if (esi_455->bFFFFFFFF == al_343 && !fn08048AF2(eax_203, esi_455 - 0x01, edi_454 - 0x01))
							{
								*((char *) &g_ptr805B5A0 + dwLoc18_814 * 0x04) = (byte **) dwLoc20_816;
								byte * edi_480 = dwLoc20_816;
								++dwLoc18_814;
								byte * esi_488 = &ecx_436->w0008 + 1;
								do
								{
									byte al_491 = *esi_488;
									*edi_480 = al_491;
									++esi_488;
									++edi_480;
								} while (al_491 != 0x00);
								dwLoc20_816 = edi_480;
							}
							edx_431 = (word32) ecx_436->w0008;
						}
					}
				}
				eax_203 = SEQ(eax_24_8_204, al_16);
				if (al_16 == 0x2A)
					goto l080489B6;
				if (al_16 == 0x7C && (esi_105->t0000 != 0x7C && esi_105->bFFFFFFFE != 0x7C))
				{
l0804896F:
					*edi_116 = 0x00;
					fn080488D8(ebp_104);
					g_ptr805D674 = esi_105 - 0x0804959A;
					__syscall(0x80);
					g_dw805D680 = g_dw805D688;
					g_b805DB22 = 0x01;
					fn08048B8C();
					g_dw805D67C = g_dw805D684;
					eax = ecx_114;
					goto l0804874F;
				}
				if (al_16 == 0x20)
					goto l0804884B;
			}
l08048850:
			*edi_116 = (byte) al_16;
			++edi_116;
l08048851:
			--ecx_114;
			if (ecx_114 == 0x00)
				break;
			continue;
		}
		if (al_16 == 0x23)
			break;
		if (al_16 != 0x24)
		{
			if (al_16 == 0x09)
				goto l08048851;
			if (al_16 == 0x0A)
				break;
			if (al_16 == 0x20)
				goto l08048851;
			if (al_16 == 0x3E)
				return ebx_154;
			eax_957 = SEQ(eax_24_8_204, al_16);
			if (al_16 == 0x3C)
				return eax_957;
			eax_203 = SEQ(eax_24_8_204, al_16);
			if (al_16 == 0x3F)
				goto l080489B6;
			eax_203 = SEQ(eax_24_8_204, al_16);
			if (al_16 == 0x2A)
				goto l080489B6;
			if (al_16 == 0x7C && (esi_105->t0000 != 0x7C && esi_105->bFFFFFFFE != 0x7C))
				goto l0804896F;
			*((char *) &g_ptr805B5A0 + ebp_104 * 0x04) = (byte **) edi_116;
			++ebp_104;
			++edx_110;
			ebx_154 |= 0x01;
			goto l080487FA;
		}
		word32 ecx_43 = esi_105->t0000;
		word32 * esi_120 = &g_dw805D5A0;
		byte dl_738 = (byte) ecx_43;
		do
		{
			byte * eax_47 = *esi_120;
			struct Eq_697 * edi_1014 = esi_105;
			++esi_120;
			eax_24_8_204 = SLICE(eax_47, word24, 8);
			if (eax_47 == null)
			{
				do
				{
					Eq_1155 al_58 = esi_105->t0000;
					++esi_105;
				} while (al_58 != 0x00 && al_58 > 0x20);
				goto l08048968;
			}
			if (*eax_47 != dl_738)
				continue;
			byte * esi_1013 = eax_47;
			while (ecx_43 != 0x00)
			{
				++esi_1013;
				++edi_1014;
				--ecx_43;
				if (*esi_1013 == edi_1014->t0000)
					break;
			}
		} while (edi_1014->bFFFFFFFF > 0x20);
		*((char *) &g_ptr805B5A0 + ebp_104 * 0x04) = (byte **) esi_1013;
		++ebp_104;
		esi_105 = edi_1014;
		++edx_110;
l08048968:
	}
	if ((ebx_154 & 0x02) != 0x00)
	{
		g_ptr805D674 = 0x00;
		g_dw805D668 = ebx_154;
		g_dw805D66C = edx_110;
		g_ptr805D670 = edi_116 - 0x0804A59A;
		g_dw805D678 = ebp_104;
		return ~0x00;
	}
	else
	{
		*edi_116 = 0x00;
		if ((ebx_154 & 0x10) != 0x00)
		{
			ui32 ebp_663 = ebp_104 - 0x01;
			__syscall(0x80);
			g_dw805D680 = 0x05;
			return fn080488D8(ebp_663);
		}
		else
		{
			if ((ebx_154 & 0x08) == 0x00)
				return fn080488D8(ebp_104);
			__syscall(0x80);
			g_dw805D67C = 0x05;
			ui32 ebp_698 = ebp_104 - 0x01;
			return fn080488D8(ebp_698);
		}
	}
}

// 080488D8: Register word32 fn080488D8(Register ui32 ebp)
// Called from:
//      fn0804874F
word32 fn080488D8(ui32 ebp)
{
	*((char *) &g_ptr805B5A0 + ebp * 0x04) = 0x00;
	g_dw805D668 = 0x00;
	g_dw805D66C = 0x00;
	g_ptr805D670 = 0x00;
	g_ptr805D674 = 0x00;
	g_dw805D678 = 0x00;
	return edx;
}

// 08048AF2: FlagGroup bool fn08048AF2(Register word32 eax, Register ptr32 esi, Register (ptr32 byte) edi)
// Called from:
//      fn0804874F
bool fn08048AF2(word32 eax, ptr32 esi, byte * edi)
{
	byte al_12 = (byte) eax;
	word16 eax_16_16_20 = SLICE(eax, word16, 16);
	byte * esi_10 = esi + 0x01;
	while (true)
	{
l08048AF5:
		bool Z_25;
		if (al_12 == 0x2A)
			break;
		if (al_12 != 0x3F)
		{
			byte ah_19 = *edi;
			word32 eax_21 = SEQ(eax_16_16_20, ah_19, al_12);
			Z_25 = SLICE(cond(eax_21), bool, 2);
			if (eax_21 == 0x00)
				return Z_25;
			Z_25 = SLICE(cond(ah_19 - al_12), bool, 2);
			if (ah_19 != al_12)
				return Z_25;
			goto l08048B17;
		}
		++edi;
		al_12 = *esi_10;
		++esi_10;
	}
	word32 eax_35;
	Z_25 = fn08048B1B(esi_10, edi, out eax_35, out esi_10);
	eax_16_16_20 = SLICE(eax_35, word16, 16);
	if (!Z_25)
		return Z_25;
l08048B17:
	al_12 = *esi_10;
	++esi_10;
	++edi;
	goto l08048AF5;
}

// 08048B1B: FlagGroup bool fn08048B1B(Register (ptr32 byte) esi, Register (ptr32 byte) edi, Register out ptr32 eaxOut, Register out ptr32 esiOut)
// Called from:
//      fn08048AF2
bool fn08048B1B(byte * esi, byte * edi, ptr32 & eaxOut, ptr32 & esiOut)
{
	do
	{
		byte al_5 = *esi;
		++esi;
		bool Z_10 = SLICE(cond(al_5), bool, 2);
		if (al_5 == 0x00)
		{
l08048B34:
			eaxOut = dwArg08;
			esiOut = <invalid>;
			return Z_10;
		}
	} while (al_5 == 0x2A);
	while (true)
	{
		byte ah_15 = *edi;
		bool Z_18 = SLICE(cond(al_5 - ah_15), bool, 2);
		ptr32 eax_60 = SEQ(eax_16_16, ah_15, al_5);
		if (al_5 == ah_15)
			break;
		if (ah_15 == 0x00)
		{
			Z_10 = SLICE(cond(ah_15 + 0x01), bool, 2);
			goto l08048B34;
		}
		++edi;
	}
	eaxOut = eax_60;
	esiOut = <invalid>;
	return Z_18;
}

// 08048B38: void fn08048B38(Register word32 eax)
// Called from:
//      fn08048B8C
void fn08048B38(word32 eax)
{
	if (g_b805DB50 == 0x7F)
	{
		word32 * edi_9 = fn08048DD5(0x00);
		if (edi_9 == null)
			__syscall(0x03);
		*edi_9 = eax;
		g_w805DB0E = SEQ(0x0A, (byte) (edi_9 - &g_dw805DB28 >> 0x02) + 0x30);
		fn08048DF5(&g_b80492EE);
		eax = fn08048E06();
	}
	word32 * edi_53 = fn08048DD5(eax);
	if (edi_53 != null)
		*edi_53 = 0x00;
}

// 08048B8C: void fn08048B8C()
// Called from:
//      fn08048161
//      fn0804874F
void fn08048B8C()
{
fn08048B8C_entry:
	def Mem0
	ebx_3 = &g_t8049394
	goto l08048B91
l08048B8C:
l08048B91:
	ebx_6 = PHI((ebx_3, l08048B8C), (ebx_385, l08048BA6))
	edi_5 = g_ptr805B5A0
	esi_7 = ebx_6->ptr0000
	branch esi_7 == null l08048BB5
l08048B9D:
	ecx_11 = fn0804824A(esi_7, edi_5, out esi_486, out edi_487)
	branch ecx_11 == 0x00 l08048BAB
l08048BA6:
	ebx_385 = &ebx_6->dw0008 + 1
	goto l08048B91
l08048BAB:
	eax_22 = ebx_6->dw0008
	branch eax_22 == 0x00 l08048BB5
l08048BB2:
	ebx_6->ptr0004()
	return
l08048BB5:
	fn080482AB()
	eax_38 = 0x02
	__syscall(0x80)
	eax_228 = eax_38
	g_dw805DB24 = eax_228
	ebx_230 = g_dw805D67C
	ecx_231 = g_dw805D680
	branch ebx_230 == 0x00 l08048CEE
	goto l08048CE9
l08048CD4:
l08048CE9:
	__syscall(0x80)
l08048CEE:
	branch ecx_231 == 0x01 l08048CFE
l08048CF3:
	branch ecx_231 == 0x00 l08048CFE
l08048CF7:
	__syscall(0x80)
l08048CFE:
	g_dw805D67C = 0x00
	g_dw805D680 = 0x00
	eax_257 = g_dw805DB24
	branch g_b805DB22 != 0x00 l08048D5B
	goto l08048D5B
l08048D52:
	branch g_b805DB50 != 0x7F l08048D9F
l08048D5B:
	eax_295 = PHI((eax_257, l08048CFE), (eax_270, l08048D52))
	edi_285 = fn08048DD5(0x00)
	branch edi_285 != null l08048D68
l08048D66:
	__syscall(0x03)
l08048D68:
	*edi_285 = eax_295
	eax_300 = edi_285 - &g_dw805DB28 >> 0x02
	al_301 = (byte) eax_300
	ax_304 = SEQ(0x0A, al_301 + 0x30)
	g_w805DB0E = ax_304
	branch g_b805DB22 != 0x00 l08048D9F
l08048D88:
	fn08048DF5(&g_b80492EE)
	fn08048E06()
l08048D9F:
	fn080482AB()
	__syscall(0x80)
	g_dw805DB58 = 0x14
	__syscall(0x80)
	__syscall(0x80)
	g_b805DB22 = 0x00
	fn08048266()
	return
l08048DD0_thunk_fn08048266:
fn08048B8C_exit:
}

// 08048DD5: Register word32 fn08048DD5(Register word32 ebx)
// Called from:
//      fn08048B38
//      fn08048B8C
word32 fn08048DD5(word32 ebx)
{
	word32 * esi_10 = &g_dw805DB28;
	do
	{
		word32 edi_13;
		if (esi_51 >= &g_b805DB50)
		{
			edi_13 = 0x00;
			return edi_13;
		}
		esi_10 = esi_51 + 1;
		esi_51 = esi_10;
	} while (*esi_51 != ebx);
	edi_13 = esi_10 - 0x04;
	return edi_13;
}

// 08048DF5: void fn08048DF5(Register (ptr32 byte) eax)
// Called from:
//      fn0804804C
//      fn080482C6
//      fn080482EA
//      fn08048B38
//      fn08048B8C
//      fn0804911E
void fn08048DF5(byte * eax)
{
	word32 edi_69;
	fn0804823D(eax, out edi_69);
	fn08048E06();
}

// 08048E06: Register word32 fn08048E06()
// Called from:
//      fn080482EA
//      fn08048B38
//      fn08048B8C
//      fn08048DF5
word32 fn08048E06()
{
	if (g_b805DB23 != 0x00)
	{
		__syscall(0x80);
		eax = 0x04;
	}
	return eax;
}

// 08048E1C: void fn08048E1C(Register (ptr32 byte) eax)
// Called from:
//      fn0804804C
//      fn080482C6
//      fn08048B8C
void fn08048E1C(byte * eax)
{
	word32 edi_74;
	fn0804823D(eax, out edi_74);
	__syscall(0x80);
}

// 08048EE4: Register word32 fn08048EE4()
// Called from:
//      fn080482C6
//      fn080482EA
word32 fn08048EE4()
{
	fn080482AB();
	fn08048DF5(&g_b80492D3);
	__syscall(0x80);
	__syscall(0x80);
	return 0x0C;
}

// 0804911E: void fn0804911E()
// Called from:
//      fn080482EA
void fn0804911E()
{
	fn08048DF5(&g_b8049129);
}

byte g_b8049129 = 0x1B; // 08049129
byte g_b8049254 = 0x61; // 08049254
byte g_b8049264 = 0x24; // 08049264
byte g_b804926A = 0x2B; // 0804926A
byte g_b804926D = 0x3E; // 0804926D
byte g_b80492D3 = 0x6C; // 080492D3
byte g_b80492EE = 0x53; // 080492EE
Eq_1319 g_t8049394 = // 08049394
	{
		&g_b8049474,
		fn08048EE4,
		0x01,
	};
byte g_b8049474 = 101; // 08049474
word32 g_dw804950E = 0x00; // 0804950E
Eq_386 g_a804959A[] = // 0804959A
	{
	};
// subject_seg08048000_0001.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte * g_ptr805B59C = null; // 0805B59C
byte * g_ptr805B5A0 = null; // 0805B5A0
byte * g_a805B5A4[] = // 0805B5A4
	{
	};
word32 g_dw805D5A0 = 0x00; // 0805D5A0
ui32 g_dw805D668 = 0x00; // 0805D668
word32 g_dw805D66C = 0x00; // 0805D66C
ptr32 g_ptr805D670 = 0x00; // 0805D670
ptr32 g_ptr805D674 = 0x00; // 0805D674
ui32 g_dw805D678 = 0x00; // 0805D678
word32 g_dw805D67C = 0x00; // 0805D67C
word32 g_dw805D680 = 0x00; // 0805D680
word32 g_dw805D684 = 0x00; // 0805D684
word32 g_dw805D688 = 0x00; // 0805D688
word16 g_w805D694 = 0x00; // 0805D694
ui32 g_dw805D6D8 = 0x00; // 0805D6D8
byte g_b805D6F3 = 0x00; // 0805D6F3
word16 g_w805D6F4 = 0x00; // 0805D6F4
up32 g_dw805D6F6 = 0x00; // 0805D6F6
up32 * g_ptr805D6FA = null; // 0805D6FA
word32 g_dw805D6FE = 0x00; // 0805D6FE
byte g_b805D6FF = 0x00; // 0805D6FF
word32 g_dw805D702 = 0x00; // 0805D702
ui32 g_dw805D706 = 0x00; // 0805D706
Eq_1010 g_t805D70A = // 0805D70A
	{
		0x00,
	};
Eq_1010 g_t805D797 = // 0805D797
	{
		0x00,
	};
byte * g_ptr805D90A = null; // 0805D90A
byte g_a805D90F[] = // 0805D90F
	{
	};
byte g_a805DA0E[] = // 0805DA0E
	{
	};
byte g_b805DB0D = 0x00; // 0805DB0D
word16 g_w805DB0E = 0x00; // 0805DB0E
byte g_b805DB22 = 0x00; // 0805DB22
byte g_b805DB23 = 0x00; // 0805DB23
word32 g_dw805DB24 = 0x00; // 0805DB24
word32 g_dw805DB28 = 0x00; // 0805DB28
byte g_b805DB50 = 0x00; // 0805DB50
word32 g_dw805DB54 = 0x00; // 0805DB54
word32 g_dw805DB58 = 0x00; // 0805DB58
