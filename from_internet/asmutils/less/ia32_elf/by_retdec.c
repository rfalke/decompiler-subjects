//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2, int32_t a3);
int32_t function_80480a4(void);
int32_t function_80480cc(void);
int32_t function_8048289(void);
int32_t function_80482d0(void);
int32_t function_804831e(void);
int32_t function_804836c(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 113; // 0x804804c
int32_t g2 = -0x46a5fe96; // 0x80480a4
int32_t g3 = 0; // 0x80483a9
char * g4; // 0x80483ad
int16_t * g5 = NULL; // 0x80483fd
int16_t g6 = 0; // 0x80483ff
int32_t g7 = 0; // 0x8048435
int32_t g8 = 0; // 0x804844d
int32_t g9 = 0; // 0x8048451
int32_t g10 = 0; // 0x8048455
int32_t g11 = 0; // 0x8048459
char * g12; // 0x804845d

// ------------------------ Functions -------------------------

// Address range: 0x80480a4 - 0x80480b5
int32_t function_80480a4(void) {
    // 0x80480a4
    __asm_int(128);
    return 4;
}

// Address range: 0x80480cc - 0x80480d3
int32_t function_80480cc(void) {
    // 0x80480cc
    __asm_int(128);
    return 1;
}

// Address range: 0x80480d3 - 0x8048228
int32_t entry_point(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a3;
    int32_t * v2 = &v1; // 0x80480d6
    if (a1 != 1) {
        // 0x80480d8
        v1 = 5;
        __asm_int(128);
        g3 = 5;
        int32_t v3; // bp+12, 0x80480d3
        v2 = &v3;
    }
    int32_t * v4 = (int32_t *)((int32_t)v2 - 4); // 0x8048101
    *v4 = 54;
    __asm_int(128);
    function_80480cc();
    *v4 = 54;
    __asm_int(128);
    *(int32_t *)&g5 = 0x500018;
    *v4 = 54;
    __asm_int(128);
    *v4 = 54;
    __asm_int(128);
    g7 &= -12;
    *v4 = 54;
    __asm_int(128);
    function_8048289();
    function_80482d0();
    while (true) {
      lab_0x804816b:
        // 0x804816b
        *v4 = 4;
        __asm_int(128);
        function_804831e();
        *v4 = 4;
        __asm_int(128);
        function_804836c();
        *v4 = 6;
        *(char *)&g4 = 47;
        function_804836c();
        *v4 = 4;
        __asm_int(128);
        *v4 = 4;
        __asm_int(128);
        while (true) {
          lab_0x80481d5:
            // 0x80481d5
            g8 = 0;
            *v4 = 3;
            __asm_int(128);
            int32_t v5 = &g1; // 0x80481eb
            while (true) {
              lab_0x80481f0:;
                int32_t v6 = v5;
                if (g8 == *(int32_t *)v6) {
                    goto lab_0x804816b;
                } else {
                    int32_t v7 = v6 + 8; // 0x80481f4
                    v5 = v7;
                    if (v7 == (int32_t)&g2) {
                        goto lab_0x80481d5;
                    } else {
                        goto lab_0x80481f0;
                    }
                }
            }
        }
    }
}

// Address range: 0x8048289 - 0x80482d0
int32_t function_8048289(void) {
    int32_t v1 = 0x804a45d; // bp-36, 0x804828f
    int32_t v2 = &v1; // 0x804828f
    int32_t * v3 = (int32_t *)(v2 - 4); // 0x804829f
    int32_t * v4 = (int32_t *)(v2 - 8);
    int32_t v5 = 0x804a45d; // 0x804828f
    *v3 = 3;
    __asm_int(128);
    *v3 = 3;
    *v4 = 3;
    *(int32_t *)(v2 - 12) = 45;
    __asm_int(128);
    int32_t v6 = *v4; // 0x80482ba
    __asm_rep_movsb_memcpy((char *)v5, (char *)&g12, v6);
    v5 += v6;
    while (*v3 == 0x2000) {
        // 0x8048290
        *v3 = 3;
        __asm_int(128);
        *v3 = 3;
        *v4 = 3;
        *(int32_t *)(v2 - 12) = 45;
        __asm_int(128);
        v6 = *v4;
        __asm_rep_movsb_memcpy((char *)v5, (char *)&g12, v6);
        v5 += v6;
    }
    // 0x80482c5
    g9 = v5;
    *(int32_t *)v5 = v1;
    return *(int32_t *)(v2 + 32);
}

// Address range: 0x80482d0 - 0x804831e
int32_t function_80482d0(void) {
    // 0x80482d0
    int32_t v1; // bp-32, 0x80482d0
    int32_t v2 = &v1; // 0x80482d0
    int32_t v3 = g9 - 0x804a45d; // 0x80482e3
    int32_t v4 = 0; // 0x80482e3
    int32_t v5 = g9; // 0x80482e3
    int32_t v6 = 0x804a45d; // 0x80482e3
    int32_t v7 = g9; // 0x80482e3
    int32_t v8; // 0x80482d0
    int32_t v9; // 0x80482d0
    int32_t v10; // 0x80482d0
    while (true) {
      lab_0x80482e5:
        // 0x80482e5
        v9 = v7;
        v8 = v5;
        char v11 = *(char *)v6; // 0x80482e5
        v6++;
        if (v11 == 10) {
            goto lab_0x80482fb;
        } else {
            int32_t v12 = v4;
            int32_t v13 = (v11 != 9 ? v12 : v12 | 7) + 1; // 0x80482f1
            v10 = v13;
            v5 = v8;
            v7 = v9;
            if (g6 > (int16_t)v13) {
                goto lab_0x804831a;
            } else {
                goto lab_0x80482fb;
            }
        }
    }
  lab_0x804831c:
    // 0x804831c
    return *(int32_t *)(v2 + 28);
  lab_0x80482fb:;
    int32_t v14 = v8 + 4; // 0x80482fb
    int32_t v15 = v9; // 0x8048300
    if (v9 <= v14) {
        // 0x8048302
        *(int32_t *)(v2 - 4) = 45;
        __asm_int(128);
        v15 = v9 + 1024;
    }
    // 0x804830f
    *(int32_t *)v14 = v6;
    g10++;
    v10 = 0;
    v5 = v14;
    v7 = v15;
    goto lab_0x804831a;
  lab_0x804831a:
    // 0x804831a
    v3--;
    v4 = v10;
    if (v3 == 0) {
        // break -> 0x804831c
        goto lab_0x804831c;
    }
    goto lab_0x80482e5;
}

// Address range: 0x804831e - 0x804836c
int32_t function_804831e(void) {
    int32_t v1 = g10 - g11; // 0x804832f
    int32_t v2 = 4 * g11; // 0x8048333
    int32_t v3 = (int32_t)*(int16_t *)&g5; // 0x8048338
    int32_t v4; // 0x804831e
    int32_t * v5 = (int32_t *)(v4 - 4); // 0x8048345
    int32_t * v6 = (int32_t *)(v4 - 8); // 0x8048346
    int32_t * v7 = (int32_t *)(v4 - 12); // 0x804834d
    int32_t v8 = v2 + g9; // 0x804834a
    *v5 = v1 > v3 ? v3 : v1;
    *v6 = v2;
    v8 += 4;
    *v7 = *(int32_t *)v8;
    *(int32_t *)(v4 - 16) = 4;
    __asm_int(128);
    int32_t result = 4; // 0x804835d
    if (*(char *)(*v7 - 1) != 10) {
        // 0x804835f
        result = function_80480a4();
    }
    int32_t v9 = *v5 - 1; // 0x8048369
    while (v9 != 0) {
        // 0x8048345
        *v5 = v9;
        v8 += 4;
        *v7 = *(int32_t *)v8;
        *(int32_t *)(v4 - 16) = 4;
        __asm_int(128);
        result = 4;
        if (*(char *)(*v7 - 1) != 10) {
            // 0x804835f
            result = function_80480a4();
        }
        // 0x8048364
        v9 = *v5 - 1;
    }
    // 0x804836b
    return result;
}

// Address range: 0x804836c - 0x8048394
int32_t function_804836c(void) {
    int64_t v1 = 10; // bp-4, 0x804836c
    int32_t v2; // 0x804836c
    int32_t v3; // 0x804836c
    int32_t v4; // 0x804836c
    if (v4 != 0) {
        // 0x804837e
        int32_t v5; // 0x804836c
        int32_t v6 = &v5; // 0x8048385
        int32_t v7 = 0; // 0x8048386
        int32_t v8; // 0x804836c
        uint32_t v9 = v8;
        v6 -= 4;
        *(int32_t *)v6 = v9 % 10 | 48;
        v7++;
        v8 = v9 / 10;
        v2 = v7;
        v3 = v6;
        while (v9 >= 10) {
            // 0x804837e
            v9 = v8;
            v6 -= 4;
            *(int32_t *)v6 = v9 % 10 | 48;
            v7++;
            v8 = v9 / 10;
            v2 = v7;
            v3 = v6;
        }
    } else {
        // 0x8048375
        v1 = 48;
        v2 = 1;
        v3 = &v1;
    }
    int32_t v10 = v2; // 0x8048389
    int32_t v11 = v3;
    int32_t result = *(int32_t *)v11; // 0x804838b
    int32_t v12; // 0x804836c
    *(char *)v12 = (char)result;
    v10--;
    int32_t v13 = v11 + 4; // 0x804838d
    bool v14; // 0x804836c
    v12 += (v14 ? -1 : 1);
    while (v10 != 0) {
        // 0x804838b
        v11 = v13;
        result = *(int32_t *)v11;
        *(char *)v12 = (char)result;
        v10--;
        v13 = v11 + 4;
        v12 += (v14 ? -1 : 1);
    }
    // 0x804838f
    *(int32_t *)(v11 + 24) = v2;
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.7.2)
// Detected functions: 7

