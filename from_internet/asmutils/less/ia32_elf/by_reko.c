// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_408 g_a804804C[12] = // 0804804C
	{
		
		{
			113,
			&g_t80480B5,
		},
		
		{
			0x51,
			&g_t80480B5,
		},
		
		{
			0x00415B1B,
			&g_t8048228,
		},
		
		{
			4348699,
			&g_t8048232,
		},
		
		{
			0x0A,
			&g_t8048232,
		},
		
		{
			0x20,
			&g_t8048240,
		},
		
		{
			2117491483,
			&g_t8048240,
		},
		
		{
			2117425947,
			&g_t8048268,
		},
		
		{
			0x62,
			&g_t8048268,
		},
		
		{
			2117360411,
			&g_t8048279,
		},
		
		{
			2117163803,
			&g_t8048285,
		},
		
		{
			0xB95A016A,
			&g_t8048394,
		},
	};
// 080480A4: void fn080480A4()
// Called from:
//      fn0804831E
void fn080480A4()
{
	__syscall(0x80);
}

<anonymous> g_t80480B5 = <code>; // 080480B5
// 080480D3: void fn080480D3()
void fn080480D3()
{
	struct Eq_7 * esp_2 = fp;
	while (true)
	{
		struct Eq_9 * esp_6 = &esp_2->dw0000 + 1;
		ptr32 esp_10 = &esp_6->dw0004;
		if (esp_2->dw0000 != 0x01)
		{
			esp_6->dw0004 = 0x05;
			int32 eax_17 = esp_6->dw0004;
			__syscall(0x80);
			g_dw80483A9 = eax_17;
			esp_10 = &esp_6->dw0004 + 1;
			if (eax_17 < 0x00)
			{
				esp_6->dw0004 = 0x01;
				esp_6->dw0004 = 0x01;
				__syscall(0x80);
				esp_10 = &esp_6->dw0004 + 1;
			}
		}
		int32 * esp_36 = esp_10 - 4;
		*esp_36 = 0x36;
		int32 eax_38 = *esp_36;
		__syscall(0x80);
		if (eax_38 < 0x00)
			break;
		*esp_36 = 0x01;
		__syscall(0x80);
		esp_2 = (struct Eq_7 *) (esp_36 + 1);
	}
	*esp_36 = 0x01;
	*esp_36 = 0x36;
	int32 eax_58 = *esp_36;
	__syscall(0x80);
	--g_t80483FD;
	if (eax_58 != 0x00)
		g_t80483FD.u1 = 0x00500018;
	*esp_36 = 0x02;
	*esp_36 = 0x36;
	__syscall(0x80);
	*esp_36 = 0x02;
	*esp_36 = 0x36;
	__syscall(0x80);
	g_dw8048435 &= ~0x0B;
	*esp_36 = 0x02;
	*esp_36 = 0x36;
	__syscall(0x80);
	fn08048289();
	fn080482D0();
	ptr32 esp_110 = esp_36 + 1;
l0804816B:
	word32 * esp_111 = esp_110 - 4;
	*esp_111 = 0x01;
	*esp_111 = 0x04;
	__syscall(0x80);
	fn0804831E();
	*esp_111 = 0x01;
	*esp_111 = 0x04;
	__syscall(0x80);
	byte * edi_143;
	*esp_111 = fn0804836C(g_dw8048459, &g_b80483AD, out edi_143) + 0x01;
	*edi_143 = 0x2F;
	word32 edi_230;
	fn0804836C(g_dw8048455, edi_143 + 1, out edi_230);
	*esp_111 = 0x01;
	*esp_111 = 0x04;
	__syscall(0x80);
	*esp_111 = 0x01;
	*esp_111 = 0x04;
	__syscall(0x80);
	while (true)
	{
		g_dw804844D = 0x00;
		word32 * esp_193 = esp_110 - 4;
		*esp_193 = 0x04;
		*esp_193 = 0x02;
		*esp_193 = 0x03;
		__syscall(0x80);
		word32 eax_205 = g_dw804844D;
		struct Eq_150 * ebx_206 = g_a804804C;
		do
		{
			if (eax_205 == ebx_206->dw0000)
			{
				int32 ecx_218;
				int32 edx_220;
				ebx_206->ptr0004();
				g_dw8048459 = ecx_218;
				g_dw8048455 = edx_220;
				goto l0804816B;
			}
			++ebx_206;
		} while (ebx_206 != &g_t80480A4);
	}
}

<anonymous> g_t8048228 = <code>; // 08048228
<anonymous> g_t8048232 = <code>; // 08048232
<anonymous> g_t8048240 = <code>; // 08048240
<anonymous> g_t8048268 = <code>; // 08048268
<anonymous> g_t8048279 = <code>; // 08048279
<anonymous> g_t8048285 = <code>; // 08048285
// 08048289: void fn08048289()
// Called from:
//      fn080480D3
void fn08048289()
{
}

// 080482D0: void fn080482D0()
// Called from:
//      fn080480D3
void fn080482D0()
{
	byte ** ebp_109 = g_ptr8048451;
	byte * esi_28 = (byte *) 0x0804A45D;
	word32 ecx_31 = ebp_109 - 0x0804A45D;
	ui32 edx_108 = 0x00;
	byte ** edi_110 = ebp_109;
	do
	{
		byte al_38 = *esi_28;
		++esi_28;
		if (al_38 != 0x0A)
		{
			if (al_38 == 0x09)
				edx_108 |= 0x07;
			++edx_108;
			if ((word16) edx_108 >= g_w80483FF)
				goto l080482FB;
		}
		else
		{
l080482FB:
			ebp_109 = (byte **) ((char *) ebp_109 + 4);
			if (edi_110 <= ebp_109)
			{
				__syscall(0x80);
				edi_110 = (byte **) ((char *) edi_110 + 0x0400);
			}
			*ebp_109 = (byte **) esi_28;
			++g_dw8048455;
			edx_108 = 0x00;
		}
		--ecx_31;
	} while (ecx_31 != 0x00);
}

// 0804831E: void fn0804831E()
// Called from:
//      fn080480D3
void fn0804831E()
{
	int32 edx_5 = g_dw8048459;
	int32 eax_7 = g_dw8048455 - edx_5;
	int32 ecx_14 = eax_7;
	struct Eq_328 * ebp_10 = (char *) g_ptr8048451 + (edx_5 << 0x02);
	int32 ebx_11 = (word32) g_t80483FD;
	if (eax_7 > ebx_11)
		ecx_14 = ebx_11;
	do
	{
		struct Eq_339 * edx_24 = ebp_10[1];
		__syscall(0x80);
		if (edx_24->bFFFFFFFF != 0x0A)
			fn080480A4();
		++ebp_10;
		ecx_14 = ecx_68 - 0x01;
		ecx_68 = ecx_14;
	} while (ecx_68 != 0x01);
}

// 0804836C: Register word32 fn0804836C(Register int32 eax, Register (ptr32 byte) edi, Register out (ptr32 byte) ediOut)
// Called from:
//      fn080480D3
word32 fn0804836C(int32 eax, byte * edi, byte & ediOut)
{
	word32 dwLoc04_57 = 0x0A;
	word32 * esp_25 = fp;
	word32 ecx_30 = 0x00;
	if (eax == 0x00)
	{
		dwLoc04_57 = 0x30;
		ecx_30 = 0x01;
	}
	else
	{
		while (eax != 0x00)
		{
			Eq_375 edx_eax_17 = (uint64) eax;
			int32 edx_20 = (int32) (edx_eax_17 % 0x0A);
			esp_25 -= 4;
			*esp_25 = SEQ(SLICE(edx_20, word24, 8), (byte) edx_20 | 0x30);
			eax = (int32) (edx_eax_17 /32 0x0A);
			++ecx_30;
		}
	}
	ecx_47 = ecx_30;
	do
	{
		word32 ecx_47;
		*edi = (byte) dwLoc04_57;
		++edi;
		--ecx_47;
	} while (ecx_47 != 0x00);
	ediOut = edi;
	return ecx_30;
}

<anonymous> g_t8048394 = <code>; // 08048394
int32 g_dw80483A9 = 0; // 080483A9
byte g_b80483AD = 0x00; // 080483AD
Eq_90 g_t80483FD = // 080483FD
	{
		0x00
	};
ci16 g_w80483FF = 0x00; // 080483FF
ui32 g_dw8048435 = 0x00; // 08048435
word32 g_dw804844D = 0x00; // 0804844D
byte ** g_ptr8048451 = null; // 08048451
int32 g_dw8048455 = 0; // 08048455
int32 g_dw8048459 = 0; // 08048459
