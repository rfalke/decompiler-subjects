// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_519 g_a804804C[12] = // 0804804C
	{
		
		{
			113,
			&g_t80480B5,
		},
		
		{
			0x51,
			&g_t80480B5,
		},
		
		{
			0x00415B1B,
			&g_t8048228,
		},
		
		{
			4348699,
			&g_t8048232,
		},
		
		{
			0x0A,
			&g_t8048232,
		},
		
		{
			0x20,
			&g_t8048240,
		},
		
		{
			2117491483,
			&g_t8048240,
		},
		
		{
			2117425947,
			&g_t8048268,
		},
		
		{
			0x62,
			&g_t8048268,
		},
		
		{
			2117360411,
			&g_t8048279,
		},
		
		{
			2117163803,
			&g_t8048285,
		},
		
		{
			0xB95A016A,
			&g_t8048394,
		},
	};
// 080480A4: void fn080480A4()
// Called from:
//      fn0804831E
void fn080480A4()
{
	sys_write(0x01, &g_b8048394, 0x01);
}

<anonymous> g_t80480B5 = <code>; // 080480B5
// 080480D3: void fn080480D3(Register Eq_11 edx, Stack word32 dwArg00, Stack (ptr32 char) dwArg08)
void fn080480D3(Eq_11 edx, word32 dwArg00, char * dwArg08)
{
	ptr32 fp;
	ptr32 esp_10 = fp + 8;
	if (dwArg00 != 0x01)
	{
		Eq_20 eax_20 = sys_open(dwArg08, 0x00, edx);
		g_t80483A9.u0 = (int32) eax_20;
		esp_10 = fp + 0x0C;
		if (eax_20 < 0x00)
			sys_exit(0x01);
	}
	Eq_20 ebx_29 = g_t80483A9.u0;
	uint32 * esp_31 = esp_10 - 4;
	*esp_31 = 0x36;
	if (sys_ioctl(ebx_29, 0x5401, 0x08048405) >= 0x00)
	{
		*esp_31 = 0x01;
		sys_exit(0x00);
	}
	else
	{
		*esp_31 = 0x01;
		uint32 ebx_53 = *esp_31;
		*esp_31 = 0x36;
		int32 eax_59 = sys_ioctl(ebx_53, 21523, 134513661);
		g_t80483FD.u0 = (word16) (g_t80483FD.u0 - 0x01);
		if (eax_59 != 0x00)
			g_t80483FD.u1 = 0x00500018;
		*esp_31 = 0x02;
		uint32 ebx_73 = *esp_31;
		*esp_31 = 0x36;
		sys_ioctl(ebx_73, 0x5401, 0x08048405);
		*esp_31 = 0x02;
		uint32 ebx_83 = *esp_31;
		*esp_31 = 0x36;
		sys_ioctl(ebx_83, 0x5401, 0x08048429);
		g_dw8048435 &= ~0x0B;
		*esp_31 = 0x02;
		uint32 ebx_99 = *esp_31;
		*esp_31 = 0x36;
		sys_ioctl(ebx_99, 0x5402, 0x08048429);
		fn08048289();
		fn080482D0();
l0804816B:
		uint32 * esp_120 = esp_10 - 4;
		*esp_120 = 0x01;
		uint32 ebx_122 = *esp_120;
		*esp_120 = 0x04;
		sys_write(ebx_122, &g_b8048395, 0x08);
		fn0804831E();
		*esp_120 = 0x01;
		uint32 ebx_142 = *esp_120;
		*esp_120 = 0x04;
		sys_write(ebx_142, &g_b804839E, 0x05);
		byte * edi_154;
		*esp_120 = fn0804836C(g_dw8048459, &g_b80483AD, out edi_154) + 0x01;
		*edi_154 = 0x2F;
		word32 edi_263;
		Eq_6 edx_180 = fn0804836C(g_dw8048455, edi_154 + 1, out edi_263) + *esp_120;
		*esp_120 = 0x01;
		uint32 ebx_185 = *esp_120;
		*esp_120 = 0x04;
		sys_write(ebx_185, &g_b80483AD, edx_180);
		*esp_120 = 0x01;
		uint32 ebx_196 = *esp_120;
		*esp_120 = 0x04;
		sys_write(ebx_196, &g_b80483A3, 0x06);
		while (true)
		{
			g_dw804844D = 0x00;
			size_t * esp_210 = esp_10 - 4;
			*esp_210 = (uint32) 0x04;
			Eq_6 edx_212 = *esp_210;
			*esp_210 = (uint32) 0x02;
			Eq_6 ebx_216 = *esp_210;
			*esp_210 = (uint32) 0x03;
			sys_read(ebx_216, &g_dw804844D, edx_212);
			word32 eax_223 = g_dw804844D;
			struct Eq_172 * ebx_224 = g_a804804C;
			do
			{
				if (eax_223 == ebx_224->dw0000)
				{
					int32 ecx_235;
					int32 edx_237;
					ebx_224->ptr0004();
					g_dw8048459 = ecx_235;
					g_dw8048455 = edx_237;
					goto l0804816B;
				}
				++ebx_224;
			} while (ebx_224 != &g_t80480A4);
		}
	}
}

<anonymous> g_t8048228 = <code>; // 08048228
<anonymous> g_t8048232 = <code>; // 08048232
<anonymous> g_t8048240 = <code>; // 08048240
<anonymous> g_t8048268 = <code>; // 08048268
<anonymous> g_t8048279 = <code>; // 08048279
<anonymous> g_t8048285 = <code>; // 08048285
// 08048289: void fn08048289()
// Called from:
//      fn080480D3
void fn08048289()
{
	byte ** ebp_28 = (byte **) 0x0804A45D;
	do
	{
		Eq_352 eax_44 = sys_read(g_t80483A9.u0, &g_t804845D, 0x2000);
		if (eax_44 == 0x00)
			break;
		sys_brk(eax_44 + ebp_28);
		memcpy(ebp_28, &g_t804845D, eax_44);
		ebp_28 += eax_44;
	} while (eax_44 == 0x2000);
	g_ptr8048451 = ebp_28;
	*ebp_28 = (byte **) (byte *) 0x0804A45D;
}

// 080482D0: void fn080482D0()
// Called from:
//      fn080480D3
void fn080482D0()
{
	byte ** ebp_114 = g_ptr8048451;
	byte * esi_29 = (byte *) 0x0804A45D;
	word32 ecx_32 = ebp_114 - 0x0804A45D;
	ui32 edx_113 = 0x00;
	byte ** edi_115 = ebp_114;
	do
	{
		byte al_40 = *esi_29;
		++esi_29;
		if (al_40 != 0x0A)
		{
			if (al_40 == 0x09)
				edx_113 |= 0x07;
			++edx_113;
			if ((word16) edx_113 >= g_w80483FF)
				goto l080482FB;
		}
		else
		{
l080482FB:
			ebp_114 = (byte **) ((char *) ebp_114 + 4);
			if (edi_115 <= ebp_114)
			{
				edi_115 = (byte **) ((char *) edi_115 + 0x0400);
				sys_brk(edi_115);
			}
			*ebp_114 = (byte **) esi_29;
			++g_dw8048455;
			edx_113 = 0x00;
		}
		--ecx_32;
	} while (ecx_32 != 0x00);
}

// 0804831E: void fn0804831E()
// Called from:
//      fn080480D3
void fn0804831E()
{
	int32 edx_6 = g_dw8048459;
	int32 eax_8 = g_dw8048455 - edx_6;
	int32 ecx_15 = eax_8;
	struct Eq_431 * ebp_11 = (char *) g_ptr8048451 + (edx_6 << 0x02);
	int32 ebx_12 = (word32) g_t80483FD.u0;
	if (eax_8 > ebx_12)
		ecx_15 = ebx_12;
	do
	{
		char * ecx_24 = ebp_11->dw0000;
		struct Eq_445 * edx_25 = ebp_11[1];
		sys_write(0x01, ecx_24, edx_25 - ecx_24);
		if (edx_25->bFFFFFFFF != 0x0A)
			fn080480A4();
		++ebp_11;
		ecx_15 = ecx_72 - 0x01;
		ecx_72 = ecx_15;
	} while (ecx_72 != 0x01);
}

// 0804836C: Register word32 fn0804836C(Register int32 eax, Register (ptr32 byte) edi, Register out (ptr32 byte) ediOut)
// Called from:
//      fn080480D3
word32 fn0804836C(int32 eax, byte * edi, byte & ediOut)
{
	word32 * fp;
	word32 dwLoc04_60 = 0x0A;
	word32 * esp_28 = fp;
	word32 ecx_33 = 0x00;
	if (eax == 0x00)
	{
		dwLoc04_60 = 0x30;
		ecx_33 = 0x01;
	}
	else
	{
		while (eax != 0x00)
		{
			Eq_486 edx_eax_20 = (uint64) eax;
			int32 edx_23 = (int32) (edx_eax_20 % 0x0A);
			esp_28 -= 4;
			*esp_28 = SEQ(SLICE(edx_23, word24, 8), (byte) edx_23 | 0x30);
			eax = (int32) (edx_eax_20 /32 0x0A);
			++ecx_33;
		}
	}
	ecx_50 = ecx_33;
	do
	{
		word32 ecx_50;
		*edi = (byte) dwLoc04_60;
		++edi;
		--ecx_50;
	} while (ecx_50 != 0x00);
	ediOut = edi;
	return ecx_33;
}

char g_b8048394 = '\n'; // 08048394
char g_b8048395 = '\x1B'; // 08048395
char g_b804839E = '\x1B'; // 0804839E
char g_b80483A3 = ']'; // 080483A3
Eq_20 g_t80483A9 = // 080483A9
	{
		0
	};
byte g_b80483AD = 0x00; // 080483AD
Eq_89 g_t80483FD = // 080483FD
	{
		0x00
	};
ci16 g_w80483FF = 0x00; // 080483FF
ui32 g_dw8048435 = 0x00; // 08048435
word32 g_dw804844D = 0x00; // 0804844D
byte ** g_ptr8048451 = null; // 08048451
int32 g_dw8048455 = 0; // 08048455
int32 g_dw8048459 = 0; // 08048459
Eq_358 g_t804845D = // 0804845D;
