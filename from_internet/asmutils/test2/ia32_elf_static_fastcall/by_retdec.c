//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int32_t __get_GOT(int32_t a1);
int32_t __system_call(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t _fastcall(int32_t a1, int32_t a2, int32_t a3);
int32_t getenv(int32_t a1);
int32_t itoa_printB(void);
int32_t memcpy(int32_t a1, int32_t a2, int32_t a3);
int32_t memset(int32_t a1, int32_t a2, int32_t a3);
int32_t printf(char * a1);
int32_t read(void);
int32_t sprintf(int32_t a1, int32_t a2);
int32_t strtol(int32_t a1, int32_t a2, int32_t a3);
int32_t write(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x804c010
int32_t g2;

// ------------------------ Functions -------------------------

// From module:   /home/hawk/mess/2022/04/asmutils/lib/test2.c
// Address range: 0x8049000 - 0x8049233
// Line range:    18 - 66
int main() {
    char tmp[10]; // bp-60, 0x8049000
    // 0x8049000
    int32_t v1; // 0x8049000
    _fastcall(v1, v1, v1);
    printf("\n\tprintf() test\nhex: %x, octal: %o, decimal: %d\n");
    printf("\n\tstrtol() test\nInput some decimal number: ");
    int32_t v2 = read(); // 0x8049057
    memcpy((int32_t)&g2, (int32_t)&g2, (int32_t)&g2);
    strtol((int32_t)&tmp - 1 + v2, (int32_t)&g2, (int32_t)&g2);
    printf("You have entered %d\n");
    printf("\n\tmemset() test\n");
    int32_t v3; // bp-80, 0x8049000
    int32_t v4 = &v3; // 0x80490a9
    memset((int32_t)&g2, (int32_t)&g2, (int32_t)&g2);
    int32_t * v5 = (int32_t *)(v4 - 12);
    int32_t * v6 = (int32_t *)(v4 - 16);
    for (int32_t i = 9; i > 0; i--) {
        // 0x80490d0
        memset(i, (int32_t)&g2, (int32_t)&g2);
        *v5 = strtol((int32_t)&g2, (int32_t)&g2, (int32_t)&g2);
        *v6 = (int32_t)"%d ";
        printf((char *)&g2);
    }
    // 0x804910d
    *v6 = (int32_t)"\n\n\tvariable test\n";
    printf(NULL);
    write();
    *v5 = g1;
    *v6 = (int32_t)"errno: %d\n";
    printf((char *)&g2);
    *v6 = (int32_t)"\n\tenvironment test\nPress ENTER to print envrionment\n";
    printf((char *)&g2);
    read();
    int32_t v7 = *(int32_t *)v1; // 0x80491a8
    int32_t v8 = 0; // 0x80491ac
    int32_t v9 = 0; // 0x80491ac
    if (v7 != 0) {
        *v5 = v7;
        *v6 = (int32_t)"%s\n";
        printf((char *)v8);
        v8++;
        int32_t v10 = *(int32_t *)(4 * v8 + v1); // 0x80491a8
        v9 = v8;
        while (v10 != 0) {
            // 0x8049174
            *v5 = v10;
            *v6 = (int32_t)"%s\n";
            printf((char *)v8);
            v8++;
            v10 = *(int32_t *)(4 * v8 + v1);
            v9 = v8;
        }
    }
    // 0x80491ae
    *v5 = getenv(v9);
    *v6 = (int32_t)"\n\tgetenv(\"HOME\") test\n%s\n";
    printf((char *)&g2);
    if (v1 < 2) {
        // 0x8049215
        *v6 = (int32_t)"\n\tall tests done\n";
        printf((char *)&g2);
        return 0;
    }
    // 0x80491e8
    *v6 = (int32_t)"\n\targuments test\n";
    printf((char *)&g2);
    int32_t v11 = 0; // 0x804920a
    *v5 = *(int32_t *)(4 * v11 + v1);
    *v6 = (int32_t)"%s\n";
    printf(NULL);
    v11++;
    char * v12 = (char *)v11; // 0x8049213
    while (v11 != v1) {
        // 0x80491e8
        *v5 = *(int32_t *)(4 * v11 + v1);
        *v6 = (int32_t)"%s\n";
        printf(v12);
        v11++;
        v12 = (char *)v11;
    }
    // 0x8049215
    *v6 = (int32_t)"\n\tall tests done\n";
    printf((char *)&g2);
    return 0;
}

// Address range: 0x804928f - 0x8049293
int32_t __get_GOT(int32_t a1) {
    // 0x804928f
    int32_t result; // 0x804928f
    return result;
}

// Address range: 0x8049293 - 0x8049317
int32_t __system_call(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x8049293
    char * v1; // 0x8049293
    if (*v1 >= 1) {
        // 0x80492a3
        int32_t v2; // 0x8049293
        __get_GOT(v2);
    }
    // 0x80492e5
    __asm_int(128);
    return (int32_t)*(char *)((int32_t)v1 + 1);
}

// Address range: 0x8049325 - 0x804932c
int32_t read(void) {
    int32_t v1 = __system_call((int32_t)&g2, (int32_t)&g2, (int32_t)&g2, (int32_t)&g2, (int32_t)&g2, (int32_t)&g2); // 0x8049325
    int32_t v2; // 0x8049325
    return v1 + v2;
}

// Address range: 0x804932c - 0x8049331
int32_t write(void) {
    int32_t result = __system_call((int32_t)&g2, (int32_t)&g2, (int32_t)&g2, (int32_t)&g2, (int32_t)&g2, (int32_t)&g2); // 0x804932c
    return result;
}

// Address range: 0x80493fa - 0x8049410
int32_t _fastcall(int32_t a1, int32_t a2, int32_t a3) {
    // 0x80493fa
    int32_t v1; // 0x80493fa
    int32_t result = __get_GOT(v1); // 0x80493fb
    *(int32_t *)*(int32_t *)(v1 + 0x2bfc) = result;
    return result;
}

// Address range: 0x8049410 - 0x8049443
int32_t memset(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8049410
    int32_t result; // 0x8049410
    int32_t v1 = __get_GOT(result); // 0x8049415
    char v2 = *(char *)*(int32_t *)(result + 0x2be2); // 0x8049426
    int32_t v3 = v2 != 0 ? v1 : a2;
    int32_t v4 = v2 != 0 ? result : a3;
    int32_t v5 = v2 != 0 ? result : a1;
    __asm_rep_stosb_memset((char *)v5, (char)v3, v4);
    return result;
}

// Address range: 0x8049443 - 0x8049471
int32_t memcpy(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8049443
    int32_t result; // 0x8049443
    __get_GOT(result);
    char v1 = *(char *)*(int32_t *)(result + 0x2bae); // 0x804945a
    int32_t v2 = v1 != 0 ? result : a3;
    int32_t v3 = v1 != 0 ? result : a2;
    int32_t v4 = v1 != 0 ? result : a1;
    __asm_rep_movsb_memcpy((char *)v4, (char *)v3, v2);
    return result;
}

// Address range: 0x80494a6 - 0x8049501
int32_t getenv(int32_t a1) {
    // 0x80494a6
    int32_t v1; // 0x80494a6
    __get_GOT(v1);
    int32_t v2 = *(char *)*(int32_t *)(v1 + 0x2b4d) != 0 ? v1 : a1;
    __get_GOT((int32_t)&g2);
    int32_t v3 = *(int32_t *)*(int32_t *)(v1 + 0x2b2a); // 0x80494d6
    int32_t v4 = -1; // 0x80494e0
    int32_t v5 = v2; // 0x80494e0
    int32_t v6 = 0; // 0x80494e0
    while (v4 != 0) {
        int32_t v7 = v5;
        v4--;
        v5 = v7 + 1;
        v6 = v4;
        if (*(char *)v7 == 0) {
            // break -> 
            break;
        }
        v6 = 0;
    }
    int32_t v8 = *(int32_t *)v3; // 0x80494eb
    if (v8 == 0) {
        // 0x80494fb
        return 0;
    }
    int32_t v9 = -2 - v6; // 0x80494e4
    int32_t v10 = v3; // 0x80494f5
    int32_t v11 = v9; // 0x80494f1
    int32_t v12; // 0x80494a6
    int32_t result; // 0x80494a6
    int32_t v13; // 0x80494a6
    int32_t v14; // 0x80494f1
    if (v9 != 0) {
        v13 = v2;
        v12 = v8;
        while (*(char *)v13 == *(char *)v12) {
            // 0x80494f1
            v14 = v11 - 1;
            v11 = v14;
            if (v14 == 0) {
                // 0x80494fa
                result = v12 + 2;
                return result;
            }
            v13++;
            v12++;
        }
    }
    // 0x80494f5
    v10 += 4;
    int32_t v15 = *(int32_t *)v10; // 0x80494eb
    result = 0;
    while (v15 != 0) {
        int32_t v16 = v15; // 0x80494f1
        v11 = v9;
        if (v9 != 0) {
            v13 = v2;
            v12 = v16;
            while (*(char *)v13 == *(char *)v12) {
                // 0x80494f1
                v14 = v11 - 1;
                v11 = v14;
                if (v14 == 0) {
                    // 0x80494fa
                    result = v12 + 2;
                    return result;
                }
                v13++;
                v12++;
            }
        }
        // 0x80494f5
        v10 += 4;
        v15 = *(int32_t *)v10;
        result = 0;
    }
  lab_0x80494fb:
    // 0x80494fb
    return result;
}

// Address range: 0x804955d - 0x804957b
int32_t itoa_printB(void) {
    // 0x804955d
    int32_t v1; // 0x804955d
    int32_t v2 = v1 % v1;
    int32_t v3 = v2; // 0x8049563
    int32_t result = 1; // 0x8049563
    if (v1 <= v1) {
        // 0x8049565
        v3 = 0x1000000 * v2 >> 24;
        result = itoa_printB();
    }
    int32_t v4 = v3 + 48; // 0x804956c
    int32_t v5 = (char)v4 < 58 ? v4 : v3 + 87;
    *(char *)v1 = (char)v5;
    return result;
}

// Address range: 0x804957b - 0x80495f0
int32_t sprintf(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // bp-36, 0x8049588
    int32_t v2 = &v1; // 0x8049588
    int32_t * v3 = (int32_t *)(v2 - 4);
    int32_t * v4 = (int32_t *)(v2 - 12);
    int32_t * v5 = (int32_t *)(v2 - 24);
    int32_t * v6 = (int32_t *)(v2 - 28);
    int32_t * v7 = (int32_t *)(v2 - 32);
    int32_t v8; // bp+12, 0x804957b
    int32_t v9 = &v8; // 0x8049589
    int32_t v10 = a2; // 0x8049589
    int32_t v11 = a1; // 0x8049589
    char v12; // 0x804957b
    int32_t v13; // 0x804957b
    int32_t v14; // 0x804957b
    int32_t v15; // 0x804957b
    int32_t v16; // 0x804957b
    int32_t v17; // 0x804957b
    int32_t v18; // 0x804957b
    int32_t v19; // 0x804957b
    int32_t v20; // 0x804957b
    int32_t v21; // 0x804957b
    int32_t v22; // 0x804957b
    int32_t v23; // 0x804958a
    int32_t v24; // 0x8049598
    while (true) {
      lab_0x804958a_2:
        // 0x804958a
        v16 = v15;
        v21 = v9;
        int32_t v25 = v13;
        int32_t v26 = v10;
        int32_t v27 = v11; // 0x804957b
        int32_t v28; // 0x804957b
        int32_t v29; // 0x8049596
        int32_t v30; // 0x8049598
        while (true) {
            // 0x804958a
            v19 = v27;
            int32_t v31 = v25; // 0x804957b
            int32_t v32 = v26; // 0x804957b
            int32_t v33; // 0x804957b
            int32_t v34; // 0x804957b
            unsigned char v35; // 0x804958a
            int32_t v36; // 0x804958a
            while (true) {
              lab_0x804958a:;
                int32_t v37 = v32;
                v35 = *(char *)v37;
                v23 = v31 & -256;
                v36 = v37 + 1;
                switch (v35) {
                    case 0: {
                        goto lab_0x80495e3;
                    }
                    case 37: {
                        // 0x8049596
                        v29 = *(int32_t *)v21;
                        unsigned char v38 = *(char *)v36; // 0x8049598
                        v30 = v23 | (int32_t)v38;
                        v24 = v37 + 2;
                        *v3 = 10;
                        v28 = 10;
                        if (v38 == 100) {
                            // break (via goto) -> 0x80495cb
                            goto lab_0x80495cb_3;
                        }
                        // 0x80495a0
                        *v3 = 16;
                        v28 = 16;
                        if (v38 == 120) {
                            // break (via goto) -> 0x80495cb
                            goto lab_0x80495cb_3;
                        }
                        // 0x80495a7
                        *v3 = 8;
                        v28 = 8;
                        if (v38 == 111) {
                            // break (via goto) -> 0x80495cb
                            goto lab_0x80495cb_3;
                        }
                        // 0x80495ae
                        *v3 = 2;
                        v33 = v30;
                        v34 = v24;
                        v28 = 2;
                        switch (v38) {
                            case 98: {
                                goto lab_0x80495cb_3;
                            }
                            case 99: {
                                goto lab_0x8049593_2;
                            }
                            default: {
                                // 0x80495b9
                                v31 = v30;
                                v32 = v24;
                                if (v38 == 115) {
                                    // 0x80495bd
                                    v14 = v30;
                                    v22 = v21;
                                    v17 = v16;
                                    v10 = v24;
                                    v11 = v19;
                                    if (v29 == 0) {
                                        goto lab_0x80495de;
                                    } else {
                                        char v39 = *(char *)v29; // 0x80495c1
                                        v12 = v39;
                                        v20 = v19;
                                        v18 = v29;
                                        v14 = v23;
                                        v22 = v21;
                                        v17 = v16;
                                        v10 = v24;
                                        v11 = v19;
                                        if (v39 == 0) {
                                            goto lab_0x80495de;
                                        } else {
                                            goto lab_0x80495c7;
                                        }
                                    }
                                }
                                goto lab_0x804958a;
                            }
                        }
                    }
                    default: {
                        goto lab_0x8049593;
                    }
                }
            }
          lab_0x8049593:
            // 0x8049593
            v33 = v23 | (int32_t)v35;
            v34 = v36;
          lab_0x8049593_2:
            // 0x8049593
            v26 = v34;
            v25 = v33;
            *(char *)v19 = (char)v25;
            v27 = v19 + 1;
        }
      lab_0x80495cb_3:
        // 0x80495cb
        *v3 = v30;
        *(int32_t *)(v2 - 8) = v28;
        *v4 = v21;
        *(int32_t *)(v2 - 16) = v29;
        *(int32_t *)(v2 - 20) = v2;
        *v5 = v16;
        *v6 = v24;
        *v7 = v19;
        itoa_printB();
        *(char *)v19 = 0;
        int32_t v40 = *v7;
        int32_t v41 = v40 + 1; // 0x80495db
        v14 = *v3;
        v22 = *v4;
        v17 = *v5;
        v10 = *v6;
        v11 = v40;
        while (*(char *)v40 != 0) {
            // 0x80495d7
            v40 = v41;
            v41 = v40 + 1;
            v14 = *v3;
            v22 = *v4;
            v17 = *v5;
            v10 = *v6;
            v11 = v40;
        }
        goto lab_0x80495de;
    }
  lab_0x80495e3:
    // 0x80495e3
    *(char *)v19 = 0;
    int32_t result = v19 - v1; // 0x80495e9
    *(int32_t *)(v2 + 32) = result;
    return result;
  lab_0x80495de:
    // 0x80495de
    v13 = v14;
    v9 = v22 + 4;
    v15 = v17;
    goto lab_0x804958a_2;
  lab_0x80495c7:
    // 0x80495c7
    *(char *)v20 = v12;
    int32_t v42 = v20 + 1; // 0x80495c7
    int32_t v43 = v18 + 1; // 0x80495c8
    char v44 = *(char *)v43; // 0x80495c1
    v12 = v44;
    v20 = v42;
    v18 = v43;
    v14 = v23;
    v22 = v21;
    v17 = v16;
    v10 = v24;
    v11 = v42;
    if (v44 == 0) {
        goto lab_0x80495de;
    } else {
        goto lab_0x80495c7;
    }
}

// Address range: 0x80495f0 - 0x8049634
int32_t printf(char * a1) {
    // 0x80495f0
    int32_t result; // 0x80495f0
    sprintf(result, result);
    __asm_int(128);
    return result;
}

// Address range: 0x804967a - 0x80496eb
int32_t strtol(int32_t a1, int32_t a2, int32_t a3) {
    // 0x804967a
    int32_t v1; // 0x804967a
    __get_GOT(v1);
    char v2 = *(char *)*(int32_t *)(v1 + 0x2974); // 0x8049694
    int32_t v3 = v2 != 0 ? v1 : a3;
    int32_t v4 = v2 != 0 ? v1 : a1; // 0x80496af
    while (*(char *)v4 == 32) {
        // 0x80496b1
        v4++;
    }
    int16_t v5 = *(int16_t *)v4; // 0x80496b9
    int32_t result = 0; // 0x80496df
    int32_t v6 = 0;
    int32_t v7 = v5 != 0x7830 ? v4 : v4 + 2; // 0x80496e1
    unsigned char v8 = *(char *)v7; // 0x80496c6
    while (v8 >= 48) {
        int32_t v9 = v6 & -256; // 0x80496c6
        unsigned char v10 = v8 - 48; // 0x80496c8
        int32_t v11 = v9 | (int32_t)v10; // 0x80496c8
        int32_t v12 = v11; // 0x80496d0
        if (v10 >= 10) {
            uint32_t v13 = v11 + 249; // 0x80496d2
            v12 = v13 % 256 | v9;
            if ((char)v13 >= 36) {
                // 0x80496da
                v12 = v9 | (int32_t)(v8 - 87);
            }
        }
        // 0x80496dd
        v6 = v12;
        result = v6 + result * (v5 != 0x7830 ? v3 != 0 ? v3 : 10 : 16);
        v7++;
        if (v7 == (v2 != 0 ? v1 : a2)) {
            // break -> 0x80496e6
            break;
        }
        v8 = *(char *)v7;
    }
    // 0x80496e6
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.2.1)
// Detected functions: 13

