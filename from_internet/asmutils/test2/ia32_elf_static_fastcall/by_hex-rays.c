/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl main(int argc, const char **argv, const char **envp);
void _get_GOT();
// int __usercall _system_call@<eax>(int@<ebx>);
// void __usercall close(int@<ebx>, _DWORD *@<esi>);
// void __usercall read(int@<ebx>);
// void __usercall lseek(int@<ebx>);
// void __usercall chmod(int@<ebx>);
// void __usercall pipe(int@<ebx>, int@<ebp>);
// void __usercall link(int@<ebx>);
// void __usercall __noreturn unlink(int@<ebx>, _DWORD *@<edi>, int@<ebp>);
// void __usercall __noreturn mkdir(int@<ebx>, _DWORD *@<edi>, int@<ebp>);
// void __usercall __noreturn rmdir(int@<ebx>, int@<ebp>);
// void __usercall __noreturn exit(int@<ebx>);
// void __usercall fork(int@<ebx>);
// void __usercall execve(int@<ebx>);
// void __usercall ioctl(int@<ebx>);
// void __usercall alarm(int@<ebx>);
// void __usercall signal(int@<ebx>);
// void __usercall wait4(int@<ebx>);
// void __usercall __noreturn getuid(int@<ebx>, _BYTE *edi0@<edi>, int _4, int, char);
// void __usercall __noreturn getgid(int ebx0@<ebx>, _BYTE *edi0@<edi>, int, int, char);
void __cdecl __noreturn _start_main(int, int, char);
// int __usercall fastcall@<eax>(int result@<eax>);
// void *__usercall memset@<eax>(void *@<eax>, char@<dl>, unsigned int@<ecx>, void *, char, unsigned int);
// void *__usercall memcpy@<eax>(void *result@<eax>, const void *@<edx>, unsigned int@<ecx>, void *, const void *, unsigned int);
// int __usercall memcmp@<eax>(unsigned int@<ecx>, const void *@<edi>, const void *@<esi>, const void *, const void *, unsigned int);
// const char *__usercall getenv@<eax>(const char *result@<eax>, const char *);
// int __usercall strlen@<eax>(int@<eax>, int);
// void __usercall itoa(unsigned int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>, unsigned int a4, char *a5, unsigned int a6);
// int __usercall itoa_printB@<eax>(unsigned int@<eax>, unsigned int@<ecx>, char *@<edi>);
// void __usercall sprintf(int a1@<eax>, char *a2, _BYTE *a3, char a4);
int printf(const char *, ...); // weak
// int __usercall strtol@<eax>(_BYTE *@<eax>, _BYTE *@<edx>, int@<ecx>, _BYTE *, _BYTE *, int);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN write; // weak
_DWORD edata; // weak
int errno; // weak
_UNKNOWN _cc; // weak


//----- (08049000) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  unsigned int v4; // edx
  const void *v5; // ecx
  int v6; // ebx
  unsigned int v7; // eax
  int v8; // eax
  int v9; // eax
  const char *v10; // eax
  void *v12; // [esp+0h] [ebp-38h]
  _BYTE *v13; // [esp+0h] [ebp-38h]
  void *v14; // [esp+0h] [ebp-38h]
  void *v15; // [esp+0h] [ebp-38h]
  _BYTE *v16; // [esp+0h] [ebp-38h]
  const void *v17; // [esp+4h] [ebp-34h]
  _BYTE *v18; // [esp+4h] [ebp-34h]
  char v19; // [esp+4h] [ebp-34h]
  int v20; // [esp+4h] [ebp-34h]
  _BYTE *v21; // [esp+4h] [ebp-34h]
  unsigned int v22; // [esp+8h] [ebp-30h]
  int v23; // [esp+8h] [ebp-30h]
  unsigned int v24; // [esp+8h] [ebp-30h]
  unsigned int v25; // [esp+8h] [ebp-30h]
  int v26; // [esp+8h] [ebp-30h]
  int v27; // [esp+Ch] [ebp-2Ch]
  char *v28; // [esp+10h] [ebp-28h] BYREF
  char v29[5]; // [esp+14h] [ebp-24h] BYREF
  _BYTE v30[3]; // [esp+19h] [ebp-1Fh] BYREF
  char v31[10]; // [esp+1Eh] [ebp-1Ah] BYREF
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  v27 = v3;
  v22 = v4;
  v17 = v5;
  fastcall(3);
  printf("\n\tprintf() test\nhex: %x, octal: %o, decimal: %d\n", 16, 8, 10);
  printf("\n\tstrtol() test\nInput some decimal number: ");
  read(v6);
  i = v7;
  memcpy(v29, v31, v7, v12, v17, v22);
  v28 = &v29[i - 1];
  v8 = strtol(v29, &v28, 10, v13, v18, v23);
  printf("You have entered %d\n", v8);
  printf("\n\tmemset() test\n");
  memset(v29, 0, 0xAu, v14, v19, v24);
  v28 = v30;
  for ( i = 9; i > 0; --i )
  {
    memset(v29, i + 48, 5u, v15, v20, v25);
    v9 = strtol(v29, &v28, 10, v16, v21, v26);
    printf("%d ", v9);
  }
  printf("\n\n\tvariable test\n");
  ((void (__fastcall *)(_DWORD, _DWORD))write)(0, 0);
  printf("errno: %d\n", errno);
  printf("\n\tenvironment test\nPress ENTER to print envrionment\n");
  read(v6);
  for ( i = 0; *(_DWORD *)(4 * i + v20); ++i )
    printf("%s\n", *(const char **)(4 * i + v20));
  v10 = getenv("HOME", (const char *)v15);
  printf("\n\tgetenv(\"HOME\") test\n%s\n", v10);
  if ( v27 > 1 )
  {
    printf("\n\targuments test\n");
    for ( j = 0; j < v27; ++j )
      printf("%s\n", *(const char **)(4 * j + v25));
  }
  printf("\n\tall tests done\n");
  return 0;
}
// 8049012: variable 'v3' is possibly undefined
// 8049015: variable 'v4' is possibly undefined
// 8049018: variable 'v5' is possibly undefined
// 8049057: variable 'v6' is possibly undefined
// 804905C: variable 'v7' is possibly undefined
// 8049068: variable 'v12' is possibly undefined
// 8049086: variable 'v13' is possibly undefined
// 8049086: variable 'v18' is possibly undefined
// 8049086: variable 'v23' is possibly undefined
// 80490B9: variable 'v14' is possibly undefined
// 80490B9: variable 'v19' is possibly undefined
// 80490B9: variable 'v24' is possibly undefined
// 80490DE: variable 'v15' is possibly undefined
// 80490DE: variable 'v20' is possibly undefined
// 80490DE: variable 'v25' is possibly undefined
// 80490EE: variable 'v16' is possibly undefined
// 80490EE: variable 'v21' is possibly undefined
// 80490EE: variable 'v26' is possibly undefined
// 80495F0: using guessed type int printf(const char *, ...);
// 804C010: using guessed type int errno;
// 8049000: using guessed type char var_1A[10];
// 8049000: using guessed type _BYTE var_24[5];

//----- (0804928F) --------------------------------------------------------
void _get_GOT()
{
  ;
}

//----- (08049293) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall _system_call@<eax>(int a1@<ebx>)
{
  int result; // eax

  result = *(unsigned __int8 *)(*(_DWORD *)a1 + 1);
  __asm { int     80h; LINUX - }
  return result;
}
// 8049316: positive sp value 4 has been found
// 8049293: could not find valid save-restore pair for ebx
// 8049293: could not find valid save-restore pair for esi

//----- (0804931E) --------------------------------------------------------
void __usercall close(int a1@<ebx>, _DWORD *a2@<esi>)
{
  *a2 += _system_call(a1);
  read(a1);
}

//----- (08049325) --------------------------------------------------------
void __usercall read(int a1@<ebx>)
{
  _system_call(a1);
  JUMPOUT(0x804932C);
}
// 804932A: control flows out of bounds to 804932C

//----- (08049333) --------------------------------------------------------
void __usercall lseek(int a1@<ebx>)
{
  _system_call(a1);
  chmod(a1);
}

//----- (0804933A) --------------------------------------------------------
void __usercall chmod(int a1@<ebx>)
{
  _system_call(a1);
  JUMPOUT(0x8049341);
}
// 804933F: control flows out of bounds to 8049341

//----- (08049348) --------------------------------------------------------
void __usercall pipe(int a1@<ebx>, int a2@<ebp>)
{
  _DWORD *v2; // edx

  _system_call(a1);
  *v2 += a2;
  link(a1);
}
// 804934D: variable 'v2' is possibly undefined

//----- (0804934F) --------------------------------------------------------
void __usercall link(int a1@<ebx>)
{
  _system_call(a1);
  JUMPOUT(0x8049356);
}
// 8049354: control flows out of bounds to 8049356

//----- (0804935D) --------------------------------------------------------
void __usercall __noreturn unlink(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<ebp>)
{
  _DWORD *v3; // edx
  int v4; // ecx

  _system_call(a1);
  *v3 += v4;
  mkdir(a1, a2, a3);
}
// 8049362: variable 'v4' is possibly undefined
// 8049362: variable 'v3' is possibly undefined

//----- (08049364) --------------------------------------------------------
void __usercall __noreturn mkdir(int a1@<ebx>, _DWORD *a2@<edi>, int a3@<ebp>)
{
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  _system_call(a1);
  *a2 += &retaddr;
  rmdir(a1, a3);
}

//----- (0804936B) --------------------------------------------------------
void __usercall __noreturn rmdir(int a1@<ebx>, int a2@<ebp>)
{
  _DWORD *v2; // eax

  v2 = (_DWORD *)_system_call(a1);
  *v2 += a2;
  exit(a1);
}

//----- (08049372) --------------------------------------------------------
void __usercall __noreturn exit(int a1@<ebx>)
{
  int v1; // eax
  _DWORD *v2; // ecx

  v1 = _system_call(a1);
  *v2 += v1;
  fork(a1);
}
// 8049377: variable 'v2' is possibly undefined

//----- (08049379) --------------------------------------------------------
void __usercall fork(int a1@<ebx>)
{
  char v1; // al
  _BYTE *v2; // edx

  v1 = _system_call(a1);
  *v2 += v1;
  execve(a1);
}
// 804937E: variable 'v2' is possibly undefined

//----- (08049380) --------------------------------------------------------
void __usercall execve(int a1@<ebx>)
{
  _system_call(a1);
  JUMPOUT(0x8049387);
}
// 8049385: control flows out of bounds to 8049387

//----- (0804938E) --------------------------------------------------------
void __usercall ioctl(int a1@<ebx>)
{
  _system_call(a1);
  alarm(a1);
}

//----- (08049395) --------------------------------------------------------
void __usercall alarm(int a1@<ebx>)
{
  _system_call(a1);
  *(_DWORD *)a1 += a1;
  JUMPOUT(0x804939C);
}
// 804939A: control flows out of bounds to 804939C

//----- (080493AA) --------------------------------------------------------
void __usercall signal(int a1@<ebx>)
{
  _system_call(a1);
  wait4(a1);
}

//----- (080493B1) --------------------------------------------------------
void __usercall wait4(int a1@<ebx>)
{
  _system_call(a1);
  JUMPOUT(0x80493B8);
}
// 80493B6: control flows out of bounds to 80493B8

//----- (080493C6) --------------------------------------------------------
void __usercall __noreturn getuid(int ebx0@<ebx>, _BYTE *edi0@<edi>, int _4, int a4, char a5)
{
  _BYTE *v5; // eax

  v5 = (_BYTE *)_system_call(ebx0);
  *v5 += ebx0;
  getgid(ebx0, edi0, _4, a4, a5);
}

//----- (080493CD) --------------------------------------------------------
void __usercall __noreturn getgid(int ebx0@<ebx>, _BYTE *edi0@<edi>, int a3, int a4, char a5)
{
  char v5; // ch

  _system_call(ebx0);
  *edi0 += v5;
  _start_main(a3, a4, a5);
}
// 80493D2: variable 'v5' is possibly undefined

//----- (080493D4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __cdecl __noreturn _start_main(int a1, int a2, char a3)
{
  void (__cdecl *v3)(); // [esp-8h] [ebp-8h]
  int v4; // [esp-4h] [ebp-4h]

  edata = &a1 + v4;
  v3();
  exit((int)&edata);
}
// 80493D6: positive sp value 8 has been found
// 80493D6: variable 'v4' is possibly undefined
// 80493F2: variable 'v3' is possibly undefined
// 804C00C: using guessed type _DWORD edata;

//----- (080493FA) --------------------------------------------------------
int __usercall fastcall@<eax>(int result@<eax>)
{
  _cc = result;
  return result;
}

//----- (08049410) --------------------------------------------------------
void *__usercall memset@<eax>(void *a1@<eax>, char a2@<dl>, unsigned int a3@<ecx>, void *a4, char a5, unsigned int a6)
{
  void *v7; // edx

  v7 = a1;
  if ( !_cc )
  {
    v7 = a4;
    a2 = a5;
    a3 = a6;
  }
  memset(v7, a2, a3);
  return a1;
}

//----- (08049443) --------------------------------------------------------
void *__usercall memcpy@<eax>(
        void *result@<eax>,
        const void *a2@<edx>,
        unsigned int a3@<ecx>,
        void *a4,
        const void *a5,
        unsigned int a6)
{
  void *v6; // edi

  v6 = result;
  if ( !_cc )
  {
    v6 = a4;
    a2 = a5;
    a3 = a6;
  }
  qmemcpy(v6, a2, a3);
  return result;
}
// 8049443: could not find valid save-restore pair for ebx

//----- (08049471) --------------------------------------------------------
int __usercall memcmp@<eax>(
        unsigned int a1@<ecx>,
        const void *a2@<edi>,
        const void *a3@<esi>,
        const void *a4,
        const void *a5,
        unsigned int a6)
{
  int result; // eax

  if ( !_cc )
  {
    a3 = a4;
    a2 = a5;
    a1 = a6;
  }
  if ( memcmp(a3, a2, a1) )
    return 1;
  return result;
}

//----- (080494A6) --------------------------------------------------------
const char *__usercall getenv@<eax>(const char *result@<eax>, const char *a2)
{
  const char *v2; // edi
  const void **v3; // ebx
  const char *v4; // edx
  unsigned int v5; // kr04_4

  v2 = result;
  if ( !_cc )
    v2 = a2;
  v3 = (const void **)edata;
  v4 = v2;
  v5 = strlen(v2) + 1;
  while ( *v3 && memcmp(v4, *v3, v5 - 1) )
    ++v3;
  return result;
}
// 80494A6: could not find valid save-restore pair for ebx
// 80494A6: could not find valid save-restore pair for esi
// 804C00C: using guessed type _DWORD edata;

//----- (08049501) --------------------------------------------------------
int __usercall strlen@<eax>(int a1@<eax>, int a2)
{
  int v2; // edx
  int v3; // eax

  if ( !_cc )
    a1 = a2;
  v2 = a1;
  v3 = 0;
  while ( *(_BYTE *)(v2 + v3++) != 0 )
    ;
  return v3 - 1;
}

//----- (0804952C) --------------------------------------------------------
void __usercall itoa(
        unsigned int a1@<eax>,
        char *a2@<edx>,
        unsigned int a3@<ecx>,
        unsigned int a4,
        char *a5,
        unsigned int a6)
{
  if ( !_cc )
  {
    a1 = a4;
    a2 = a5;
    a3 = a6;
  }
  itoa_printB(a1, a3, a2);
  *a2 = 0;
}
// 804952C: could not find valid save-restore pair for ebx

//----- (0804955D) --------------------------------------------------------
int __usercall itoa_printB@<eax>(unsigned int a1@<eax>, unsigned int a2@<ecx>, char *a3@<edi>)
{
  int result; // eax
  char v4; // dl
  unsigned int v5; // et2
  char v6; // dl
  char v7; // [esp-4h] [ebp-4h]

  v5 = a1 % a2;
  result = a1 / a2;
  v4 = v5;
  if ( result )
  {
    v7 = v4;
    result = itoa_printB(result, a2, a3);
    v4 = v7;
  }
  v6 = v4 + 48;
  if ( v6 > 57 )
    v6 += 39;
  *a3 = v6;
  return result;
}

//----- (0804957B) --------------------------------------------------------
void __usercall sprintf(int a1@<eax>, char *a2, _BYTE *a3, char a4)
{
  char *v4; // edx
  char *v7; // ebx
  unsigned int v8; // ecx
  int v10; // [esp-40h] [ebp-44h]
  char *v11; // [esp-3Ch] [ebp-40h]

  v4 = &a4;
  while ( 1 )
  {
    LOBYTE(a1) = *a3++;
    if ( !(_BYTE)a1 )
      break;
    if ( (_BYTE)a1 != 37 )
      goto sprintf_store;
    v7 = *(char **)v4;
    LOBYTE(a1) = *a3++;
    v8 = 10;
    if ( (_BYTE)a1 == 100 || (v8 = 16, (_BYTE)a1 == 120) || (v8 = 8, (_BYTE)a1 == 111) || (v8 = 2, (_BYTE)a1 == 98) )
    {
      v11 = v4;
      v10 = a1;
      itoa_printB((unsigned int)v7, v8, a2);
      *a2 = 0;
      a1 = v10;
      v4 = v11;
      while ( *a2++ != 0 )
        ;
      --a2;
      goto sprintf_allok;
    }
    if ( (_BYTE)a1 == 99 )
    {
sprintf_store:
      *a2++ = a1;
    }
    else if ( (_BYTE)a1 == 115 )
    {
      if ( v7 )
      {
        while ( *v7 )
          *a2++ = *v7++;
      }
sprintf_allok:
      v4 += 4;
    }
  }
  *a2 = 0;
}
// 804957B: could not find valid save-restore pair for esi

//----- (080495F0) --------------------------------------------------------
#error "804960B: call analysis failed (funcsize=20)"

//----- (0804967A) --------------------------------------------------------
int __usercall strtol@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>, _BYTE *a4, _BYTE *a5, int a6)
{
  int result; // eax
  int v9; // ebx

  if ( !_cc )
  {
    a1 = a4;
    a2 = a5;
    a3 = a6;
  }
  if ( !a3 )
    a3 = 10;
  result = 0;
  v9 = 0;
  while ( *a1 == 32 )
    ++a1;
  if ( *(_WORD *)a1 == 30768 )
  {
    a3 = 16;
    a1 += 2;
  }
  do
  {
    LOBYTE(v9) = *a1 - 48;
    if ( *a1 < 0x30u )
      break;
    if ( (unsigned __int8)v9 > 9u )
    {
      LOBYTE(v9) = *a1 - 55;
      if ( (unsigned __int8)v9 > 0x23u )
        LOBYTE(v9) = *a1 - 87;
    }
    result = v9 + a3 * result;
    ++a1;
  }
  while ( a1 != a2 );
  return result;
}

// nfuncs=34 queued=33 decompiled=33 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 33 function(s)"
