// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Register (ptr32 byte) esi, Stack up32 dwArg00, Stack (ptr32 byte) dwArg08)
void fn0804804C(byte * esi, up32 dwArg00, byte * dwArg08)
{
	if (dwArg00 >= 0x03)
	{
		esi = dwArg08;
		struct Eq_12 * esp_11 = fp + 0x0C;
		if (fn08048073(dwArg08) != ~0x00)
		{
			while (true)
			{
				struct Eq_12 * esp_23 = esp_11 + 1;
				if (esp_11->dw0000 == 0x00)
					break;
				esp_23->dwFFFFFFFC = 0x0F;
				__syscall(0x80);
				esp_11 = esp_23;
			}
		}
	}
	__syscall(0x80);
	fn08048073(esi);
}

// 08048073: Register uipr32 fn08048073(Register (ptr32 byte) esi)
// Called from:
//      fn0804804C
uipr32 fn08048073(byte * esi)
{
	byte * edx_18 = esi;
	uipr32 eax_115 = 0x00;
	while (true)
	{
		word16 eax_16_16_64 = SLICE(eax_115, word16, 16);
		uint16 ax_62 = (word16) eax_115;
		word16 edx_16_16_73 = SLICE(edx_18, word16, 16);
		cu8 cl_29 = *esi;
		uipr32 eax_105 = eax_115;
		if (cl_29 == 0x00)
			break;
		if (cl_29 < 0x30)
			goto l0804809D;
		uint32 ecx_68 = (uint32) (cl_29 - 0x30);
		if (cl_29 > 55)
			goto l0804809D;
		eax_115 = SEQ(eax_16_16_64, ax_62 * 0x08) + ecx_68;
		++esi;
		edx_18 = SEQ(edx_16_16_73, SLICE(ax_62 *32 0x08, word16, 16));
	}
	if (edx_18 == esi)
	{
l0804809D:
		eax_105 = ~0x00;
	}
	return eax_105;
}

