//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2);
int32_t function_804804c(void);

// --------------------- Global Variables ---------------------

char g1[7] = "00.raw"; // 0x80482f2
int32_t g2 = 0; // 0x80482f9
char g3 = 0; // 0x8048c29
char * g4; // 0x8048c2a
char g5 = 0; // 0x8048c2b
char g6 = 0; // 0x8048c2c
char g7 = 0; // 0x8048c2d

// ------------------------ Functions -------------------------

// Address range: 0x804804c - 0x804806c
int32_t function_804804c(void) {
    // 0x804804c
    int32_t v1; // 0x804804c
    uint32_t v2 = v1;
    unsigned char v3 = (char)v2;
    uint32_t v4 = v2 % 256; // 0x804804d
    if (v3 == 0) {
        // 0x804806b
        return v1 & -256 | v4;
    }
    int32_t v5 = v1 & -0x10000; // 0x8048051
    bool v6; // 0x804804c
    unsigned char v7 = *(char *)((v6 ? -1 : 1) + v2); // 0x8048053
    uint32_t v8 = 256 * v4 + 0xd000 & 0xff00 | v5; // 0x8048053
    if (v3 < 48) {
        // 0x804806b
        return v8 | (int32_t)v7;
    }
    char v9 = v7 - 48;
    int32_t v10 = v9; // 0x8048059
    int32_t result = v8 | v10; // 0x8048059
    if (v7 < 48) {
        // 0x804806b
        return result;
    }
    uint32_t v11 = v8 / 256; // 0x804805d
    if ((char)v11 > 9 || v9 > 9) {
        // 0x804806b
        return result;
    }
    // 0x8048066
    return (10 * v11 + v10) % 256 | v5;
}

// Address range: 0x804806c - 0x80482f9
int32_t entry_point(int32_t a1, int32_t a2) {
    // 0x804806c
    bool v1; // 0x804806c
    int32_t v2 = v1 ? -1 : 1;
    int32_t v3; // 0x804806c
    int32_t v4 = &v3; // 0x804806e
    int32_t * v5; // 0x804806c
    int32_t v6; // 0x804806c
    int32_t v7; // 0x804806c
    int32_t v8; // 0x804806c
    int32_t * v9; // 0x804806c
    int32_t * v10; // 0x804806c
    int32_t v11; // 0x804806c
    int32_t * v12; // 0x804806c
    int32_t v13; // 0x804806c
    int32_t v14; // 0x804806c
    int32_t v15; // 0x804806c
    int32_t v16; // 0x804806c
    int32_t v17; // 0x804806c
    while (true) {
        int32_t * v18 = (int32_t *)v4;
        int32_t v19 = *v18; // 0x8048073
        int32_t v20 = v4 + 4; // 0x8048073
        v7 = v20;
        v8 = v19;
        v9 = v18;
        v5 = v18;
        v6 = v20;
        if (v19 == 0) {
            // break -> 0x80480ed
            break;
        }
        int32_t v21; // 0x8048086
        while (true) {
          lab_0x8048078:
            // 0x8048078
            v17 = v4;
            v12 = v9;
            v4 = v7;
            int32_t v22 = v8 + v2; // 0x8048078
            v14 = v22;
            int32_t v23; // 0x804806c
            switch (*(char *)v23) {
                case 45: {
                    // 0x8048086
                    v21 = v22 + v2;
                    v14 = v21;
                    switch (*(char *)v22) {
                        case 115: {
                            // 0x8048094
                            if (*(char *)v21 != 0) {
                                // 0x804829b
                                v14 = v21 + v2;
                                goto lab_0x804829b_4;
                            }
                            // 0x804809d
                            g7 = *(char *)0x8048c2d + 1;
                            goto lab_0x8048073;
                        }
                        case 116: {
                            goto lab_0x80480a5;
                        }
                        default: {
                            goto lab_0x804829b_4;
                        }
                    }
                }
                case 47: {
                    goto lab_0x8048073;
                }
                default: {
                    goto lab_0x804829b_4;
                }
            }
        }
      lab_0x80480a5:;
        char v24 = *(char *)0x8048c2c + 1; // 0x80480a5
        g6 = v24;
        uint32_t v25 = function_804804c(); // 0x80480ab
        v14 = v21;
        if (v24 == 0) {
            goto lab_0x804829b_4;
        }
        unsigned char v26 = *(char *)v21; // 0x80480b8
        int32_t v27 = v21 + v2; // 0x80480b8
        v14 = v27;
        if (v26 != 45) {
            goto lab_0x804829b_4;
        }
        int32_t v28 = function_804804c(); // 0x80480c1
        v14 = v27;
        if (v26 < 46) {
            goto lab_0x804829b_4;
        }
        // 0x80480cc
        int32_t v29; // 0x804806c
        int32_t v30 = v25 % 256 | v29 & -256; // 0x80480b6
        v16 = v17;
        v10 = v12;
        v11 = v4;
        v13 = v30;
        v15 = v27;
        if (v30 > v28) {
            goto lab_0x80482ab;
        }
        int32_t v31 = 256 * v28 & 0xff00 | v30 & -0xff01; // 0x80480d4
        *(int16_t *)&g4 = (int16_t)v31;
        v29 = v31;
        if (*(char *)v27 != 0) {
            // 0x804829b
            v14 = v27 + v2;
            goto lab_0x804829b_4;
        }
    }
  lab_0x80480ed:;
    int32_t v32 = v6;
    int32_t v33 = v4;
    *v5 = 5;
    __asm_int(128);
    *v5 = 54;
    __asm_int(128);
    *v5 = 0;
    int32_t * v34 = (int32_t *)(v33 - 4);
    *v34 = 54;
    __asm_int(128);
    uint32_t v35 = *v5; // 0x8048159
    char v36; // 0x804806c
    int32_t v37; // 0x804806c
    char v38; // 0x804806c
    char v39; // 0x804806c
    int32_t v40; // 0x804806c
    if (g6 == 0) {
        char v41 = v35; // 0x804816f
        *(char *)&g4 = v41;
        v37 = v35 / 256;
        v38 = v41;
        goto lab_0x8048171;
    } else {
        char v42 = *(char *)&g4; // 0x8048160
        v16 = v33;
        v10 = v5;
        v11 = v32;
        v40 = 0x5305;
        v13 = v33;
        v15 = 0;
        if (v35 > (int32_t)v42) {
            goto lab_0x80482ab;
        } else {
            int32_t v43 = v35 / 256;
            if (v43 < (int32_t)*(char *)((int32_t)&g4 + 1)) {
                goto lab_0x8048171;
            } else {
                // 0x8048168
                v36 = v43;
                v39 = v42;
                goto lab_0x8048174;
            }
        }
    }
  lab_0x804829b_4:
    // 0x804829b
    *v12 = 4;
    __asm_int(128);
    v16 = v17;
    v10 = v12;
    v11 = v4;
    v40 = (int32_t)"$ cda2raw [[-s] [-txx-yy]] [/dev/cdrom]\ntrack00.raw";
    v13 = 40;
    v15 = v14;
    goto lab_0x80482ab;
  lab_0x80482ab:
    // 0x80482ab
    *v10 = 1;
    __asm_int(128);
    int32_t * v44 = (int32_t *)v16; // 0x80482b1
    int32_t v45 = v16; // 0x80482b1
    int32_t v46 = v11; // 0x80482b1
    int32_t v47 = v40; // 0x80482b1
    int32_t v48 = v13; // 0x80482b1
    int32_t v49 = v15; // 0x80482b1
    int32_t v50; // 0x804806c
    int32_t * v51 = (int32_t *)v50; // 0x80482b1
    goto lab_0x80482b3;
  lab_0x8048073:;
    int32_t * v55 = (int32_t *)v4;
    int32_t v56 = *v55; // 0x8048073
    int32_t v57 = v4 + 4; // 0x8048073
    v7 = v57;
    v8 = v56;
    v9 = v55;
    v5 = v55;
    v6 = v57;
    if (v56 == 0) {
        // break (via goto) -> 0x80480ed
        goto lab_0x80480ed;
    }
    goto lab_0x8048078;
  lab_0x8048171:;
    char v58 = v37;
    g5 = v58;
    v36 = v58;
    v39 = v38;
    goto lab_0x8048174;
  lab_0x8048174:
    // 0x8048174
    g3 = v36;
    char v59 = v39; // 0x8048180
    if (g7 != 0) {
      lab_0x8048182:;
        unsigned char v60 = v59; // 0x8048185
        uint32_t v61 = (256 * (int32_t)(v60 / 10) | (int32_t)(v60 % 10)) + 0x3030; // 0x804818c
        *(int16_t *)&g1 = (int16_t)(v61 / 256 % 256 | 256 * v61 & 0x3f00);
    }
    int32_t * v62 = (int32_t *)v33;
    *v62 = 5;
    __asm_int(128);
    int32_t v63 = v33 - 8; // 0x80481bc
    int32_t * v64 = (int32_t *)v63; // 0x80481bc
    int32_t * v65 = (int32_t *)(v33 - 12); // 0x80481c6
    int32_t * v66 = (int32_t *)(v33 - 16);
    int32_t * v67 = (int32_t *)(v33 - 24);
    int32_t * v68 = (int32_t *)(v33 - 36);
    int32_t * v69 = (int32_t *)(v33 - 40);
    *v62 = 0;
    *v34 = 0;
    *v64 = (int32_t)*(char *)&g4 | 0x20000;
    *v65 = 54;
    __asm_int(128);
    int32_t v70 = 0x5306; // 0x80481d8
    int32_t v71 = v63; // 0x80481d8
    int32_t v72; // 0x804806c
    int32_t v73; // 0x80481e8
    uint32_t v74; // 0x804824c
    uint32_t v75; // 0x804824f
    int32_t v76; // 0x804824f
    int32_t v77; // 0x8048268
    uint32_t v78; // 0x8048257
    int32_t v79; // 0x8048257
    if ((*v64 & 0x4000) == 0) {
        // 0x80481de
        v73 = (int32_t)(*(char *)&g4 + 1) | 0x20000;
        *v65 = 0;
        *v66 = 0;
        *(int32_t *)(v33 - 20) = v73 > (int32_t)g3 ? 0x200aa : v73;
        *v67 = 54;
        __asm_int(128);
        *v67 = (int32_t)&g2;
        *(int32_t *)(v33 - 28) = 1;
        *(int32_t *)(v33 - 32) = 2;
        *v68 = *v34;
        *v69 = 54;
        __asm_int(128);
        *v69 = 4;
        __asm_int(128);
        v74 = llvm_bswap_i32(*v68) / 256;
        v75 = v74 + 1;
        v76 = v75 % 256 | v74 & 0xffff00;
        v72 = v76;
        if ((char)v75 >= 75) {
            // 0x8048255
            v78 = v76 + 256 & 0xff00;
            v79 = v78 | v74 & 0xff0000;
            v72 = v79;
            if ((char)(v78 / 256) >= 60) {
                // 0x804825e
                v72 = v79 + 0x10000 & 0x1ff0000;
            }
        }
        // 0x8048265
        v77 = llvm_bswap_i32(256 * v72);
        *v34 = v77;
        v70 = *v67;
        v71 = 2352;
        while (*v66 != v77) {
            // 0x804820f
            *v67 = (int32_t)&g2;
            *(int32_t *)(v33 - 28) = 1;
            *(int32_t *)(v33 - 32) = 2;
            *v68 = *v34;
            *v69 = 54;
            __asm_int(128);
            *v69 = 4;
            __asm_int(128);
            v74 = llvm_bswap_i32(*v68) / 256;
            v75 = v74 + 1;
            v76 = v75 % 256 | v74 & 0xffff00;
            v72 = v76;
            if ((char)v75 >= 75) {
                // 0x8048255
                v78 = v76 + 256 & 0xff00;
                v79 = v78 | v74 & 0xff0000;
                v72 = v79;
                if ((char)(v78 / 256) >= 60) {
                    // 0x804825e
                    v72 = v79 + 0x10000 & 0x1ff0000;
                }
            }
            // 0x8048265
            v77 = llvm_bswap_i32(256 * v72);
            *v34 = v77;
            v70 = *v67;
            v71 = 2352;
        }
    }
    char v80 = *(char *)&g4 + 1; // 0x8048286
    *(char *)&g4 = v80;
    v44 = v62;
    v45 = v33;
    v46 = v32;
    v47 = v70;
    v48 = v71;
    v49 = (int32_t)"track00.raw";
    v51 = (int32_t *)5;
    while (g5 >= v80) {
        // 0x804828c
        v59 = v80;
        char v81 = v80; // 0x8048290
        if (g7 != 0) {
            goto lab_0x8048182;
        }
        *v62 = 0;
        *v34 = 0;
        *v64 = (int32_t)v81 | 0x20000;
        *v65 = 54;
        __asm_int(128);
        v70 = 0x5306;
        v71 = v63;
        if ((*v64 & 0x4000) == 0) {
            // 0x80481de
            v73 = (int32_t)(*(char *)&g4 + 1) | 0x20000;
            *v65 = 0;
            *v66 = 0;
            *(int32_t *)(v33 - 20) = v73 > (int32_t)g3 ? 0x200aa : v73;
            *v67 = 54;
            __asm_int(128);
            *v67 = (int32_t)&g2;
            *(int32_t *)(v33 - 28) = 1;
            *(int32_t *)(v33 - 32) = 2;
            *v68 = *v34;
            *v69 = 54;
            __asm_int(128);
            *v69 = 4;
            __asm_int(128);
            v74 = llvm_bswap_i32(*v68) / 256;
            v75 = v74 + 1;
            v76 = v75 % 256 | v74 & 0xffff00;
            v72 = v76;
            if ((char)v75 >= 75) {
                // 0x8048255
                v78 = v76 + 256 & 0xff00;
                v79 = v78 | v74 & 0xff0000;
                v72 = v79;
                if ((char)(v78 / 256) >= 60) {
                    // 0x804825e
                    v72 = v79 + 0x10000 & 0x1ff0000;
                }
            }
            // 0x8048265
            v77 = llvm_bswap_i32(256 * v72);
            *v34 = v77;
            v70 = *v67;
            v71 = 2352;
            while (*v66 != v77) {
                // 0x804820f
                *v67 = (int32_t)&g2;
                *(int32_t *)(v33 - 28) = 1;
                *(int32_t *)(v33 - 32) = 2;
                *v68 = *v34;
                *v69 = 54;
                __asm_int(128);
                *v69 = 4;
                __asm_int(128);
                v74 = llvm_bswap_i32(*v68) / 256;
                v75 = v74 + 1;
                v76 = v75 % 256 | v74 & 0xffff00;
                v72 = v76;
                if ((char)v75 >= 75) {
                    // 0x8048255
                    v78 = v76 + 256 & 0xff00;
                    v79 = v78 | v74 & 0xff0000;
                    v72 = v79;
                    if ((char)(v78 / 256) >= 60) {
                        // 0x804825e
                        v72 = v79 + 0x10000 & 0x1ff0000;
                    }
                }
                // 0x8048265
                v77 = llvm_bswap_i32(256 * v72);
                *v34 = v77;
                v70 = *v67;
                v71 = 2352;
            }
        }
        // 0x804827b
        v80 = *(char *)&g4 + 1;
        *(char *)&g4 = v80;
        v44 = v62;
        v45 = v33;
        v46 = v32;
        v47 = v70;
        v48 = v71;
        v49 = (int32_t)"track00.raw";
        v51 = (int32_t *)5;
    }
    goto lab_0x80482b3;
  lab_0x80482b3:
    // 0x80482b3
    *v44 = 1;
    __asm_int(128);
    int16_t v52 = v46; // 0x80482bf
    __asm_arpl(*(int16_t *)(v48 + 111 + 2 * v49), v52);
    *v51 = __asm_insd((int16_t)v48);
    __asm_arpl(*(int16_t *)(v47 + 50), v52);
    if (*(char *)1 == 0) {
        // 0x8048356
        return 0x77672a1a;
    }
    int16_t v53 = *(int16_t *)(*(int32_t *)(v45 + 20) + 48); // 0x80482f0
    __asm_arpl(v53, (int16_t)*(int32_t *)(v45 + 12));
    char * v54 = (char *)*(int32_t *)(v45 + 8); // 0x80482f3
    *v54 = *v54 ^ (char)(*(int32_t *)(v45 + 28) / 256);
    return *(int32_t *)(v45 + 32);
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: upx (3.xx)
// Detected functions: 2

