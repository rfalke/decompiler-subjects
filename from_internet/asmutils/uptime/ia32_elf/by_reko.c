// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: Register (ptr32 byte) fn0804804C(Register int32 eax, Register (ptr32 byte) edi)
// Called from:
//      fn0804806E
//      fn08048092
byte * fn0804804C(int32 eax, byte * edi)
{
	Eq_4 edx_eax_9 = (uint64) eax;
	int32 eax_12 = (int32) (edx_eax_9 /32 0x0A);
	int32 edx_11 = (int32) (edx_eax_9 % 0x0A);
	byte al_17 = (byte) eax_12;
	if (eax_12 != 0x00)
	{
		*edi = al_17 + 0x30;
		++edi;
	}
	*edi = (byte) edx_11 + 0x30;
	return edi + 1;
}

// 0804805F: FlagGroup bool fn0804805F(Register int32 eax, Register (ptr32 Eq_35) edi, Register out ptr32 ediOut)
// Called from:
//      fn0804806E
//      fn08048092
bool fn0804805F(int32 eax, struct Eq_35 * edi, ptr32 & ediOut)
{
	Eq_37 edx_eax_9 = (uint64) eax;
	byte al_13 = (byte) (edx_eax_9 /32 0x0A);
	edi->b0000 = al_13 + 0x30;
	edi->b0001 = (byte) (edx_eax_9 % 0x0A) + 0x30;
	ediOut = &edi->b0001 + 1;
	return SLICE(cond(al_13 + 0x30), bool, 2);
}

// 0804806E: FlagGroup bool fn0804806E(Register uint32 eax, Register (ptr32 byte) edi, Register out ptr32 ediOut)
// Called from:
//      fn08048092
bool fn0804806E(uint32 eax, byte * edi, ptr32 & ediOut)
{
	Eq_65 eax_5 = (eax >> 0x05) + 0x0A;
	struct Eq_70 * edi_13 = fn0804804C(eax_5 >> 11, edi);
	edi_13->t0000.u0 = 0x2E;
	ptr32 edi_30;
	bool Z_34 = fn0804805F((eax_5 & 0x07FF) *s 100 >> 11, (char *) &edi_13->t0000 + 1, out edi_30);
	ediOut = edi_30;
	return Z_34;
}

// 08048092: void fn08048092(Stack word32 dwArg00)
void fn08048092(word32 dwArg00)
{
	__syscall(0x80);
	g_b804821A = 0x20;
	Eq_103 edx_eax_29 = (uint64) (int32) ((uint64) (int32) ((uint64) dwArg00 % 31536000) % 0x00015180);
	word32 ebp_12 = 0x00;
	int32 edx_31 = (int32) (edx_eax_29 % 0x0E10);
	int32 eax_32 = (int32) (edx_eax_29 /32 0x0E10);
	if (eax_32 > 0x0C)
	{
		eax_32 -= 0x0C;
		ebp_12 = 0x01;
	}
	struct Eq_70 * edi_47 = fn0804804C(eax_32, &g_b804821B);
	edi_47->t0000.u0 = 0x3A;
	struct Eq_133 * edi_70;
	fn0804805F((int32) ((uint64) edx_31 /32 0x3C), (char *) &edi_47->t0000 + 1, out edi_70);
	word16 ax_80 = 0x6D61;
	if (ebp_12 != 0x00)
		ax_80 = 0x6D70;
	edi_70->w0000 = ax_80;
	edi_70->dw0002 = 0x70752020;
	edi_70->w0006 = 0x2020;
	__syscall(0x80);
	Eq_164 edx_eax_109 = (uint64) (int32) ((uint64) dwArg00 % 31536000);
	byte * edi_132 = &edi_70->w0006 + 1;
	int32 edx_111 = (int32) (edx_eax_109 % 0x00015180);
	int32 eax_112 = (int32) (edx_eax_109 /32 0x00015180);
	if (eax_112 != 0x00)
	{
		struct Eq_70 * edi_121 = fn0804804C(eax_112, &edi_70->w0006 + 1);
		edi_121->t0000.u1 = 0x79616420;
		edi_121->dw0004 = 0x20202C73;
		edi_132 = (byte *) (&edi_121->dw0004 + 1);
	}
	Eq_184 edx_eax_139 = (uint64) edx_111;
	struct Eq_70 * edi_149 = fn0804804C((int32) (edx_eax_139 /32 0x0E10), edi_132);
	edi_149->t0000.u0 = 0x3A;
	word16 * edi_172;
	fn0804805F((int32) ((uint64) (int32) (edx_eax_139 % 0x0E10) /32 0x3C), (char *) &edi_149->t0000 + 1, out edi_172);
	*edi_172 = 0x202C;
	__syscall(0x80);
	g_dw804826A = 0x05;
	while (true)
		__syscall(0x80);
}

byte g_b804821A = 0x00; // 0804821A
byte g_b804821B = 0x00; // 0804821B
word32 g_dw804826A = 0x00; // 0804826A
