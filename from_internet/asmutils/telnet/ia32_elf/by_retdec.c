//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1);
int32_t function_804829f(void);
int32_t function_80482c1(void);
int32_t function_80482f3(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x8048305
int32_t g2 = 0; // 0x8048309
int16_t g3 = 0; // 0x804830b
int32_t g4 = 0; // 0x804830d
int32_t g5 = 0; // 0x8048311
int16_t g6 = 0; // 0x8048313
int32_t g7 = 0; // 0x8048315
int32_t g8 = 0; // 0x8048318
int32_t g9 = 0; // 0x8048331
char * g10; // 0x8048349

// ------------------------ Functions -------------------------

// Address range: 0x804809d - 0x804829f
int32_t entry_point(int32_t a1) {
    // 0x804809d
    function_80482c1();
    int32_t v1; // 0x804809d
    int32_t v2 = &v1; // 0x80480a2
    if (a1 == 1) {
        // 0x80480a6
        __asm_int(128);
        function_80482f3();
        int32_t * v3 = (int32_t *)(v2 - 4); // 0x80480d8
        *v3 = 6;
        __asm_int(128);
        *v3 = 1;
        __asm_int(128);
    }
    int32_t v4 = v2 + 8; // 0x80480e5
    function_804829f();
    int32_t * v5 = (int32_t *)v4; // 0x80480f0
    int32_t v6 = *v5; // 0x80480f0
    char v7 = 23; // 0x80480f5
    bool v8; // 0x804809d
    if (v6 != 0) {
        unsigned char v9 = *(char *)v6; // 0x80480fb
        char v10 = v9 - 48; // 0x80480fc
        v7 = 0;
        if (v9 > 47 == v10 < 10) {
            int32_t v11 = v6; // 0x80480fb
            v11 += (v8 ? -1 : 1);
            int32_t v12 = v10; // 0x8048107
            unsigned char v13 = *(char *)v11; // 0x80480fb
            char v14 = v13 - 48; // 0x80480fc
            int32_t v15 = v12; // 0x80480fe
            while (v13 > 47 == v14 < 10) {
                // 0x8048104
                v11 += (v8 ? -1 : 1);
                v12 = 10 * v15 + (int32_t)v14;
                v13 = *(char *)v11;
                v14 = v13 - 48;
                v15 = v12;
            }
            // 0x804810b
            v7 = v12;
        }
    }
    // 0x804810b
    g7 = 2;
    *(char *)&g8 = v7;
    *v5 = 0;
    int32_t * v16 = (int32_t *)(v2 + 4); // 0x8048116
    *v16 = 1;
    v1 = 2;
    int32_t * v17 = (int32_t *)(v2 - 4); // 0x804811c
    *v17 = 102;
    __asm_int(128);
    *v5 = 16;
    *v16 = 4;
    v1 = v4;
    *v17 = 1;
    int32_t * v18 = (int32_t *)(v2 - 8); // 0x804813a
    *v18 = 0;
    int32_t * v19 = (int32_t *)(v2 - 12); // 0x804813c
    *v19 = 102;
    int32_t * v20 = (int32_t *)(v2 - 16); // 0x804813f
    *v20 = 102;
    __asm_int(128);
    *v5 = 16;
    *v16 = (int32_t)&g7;
    v1 = 102;
    *v17 = 102;
    __asm_int(128);
    *v5 = 1;
    *v16 = 4;
    v1 = v4;
    *v17 = 10;
    *v18 = 1;
    *v19 = 102;
    *v20 = 102;
    __asm_int(128);
    *v5 = 4;
    __asm_int(128);
    int32_t v21 = v8 ? -1 : 1;
    while (true) {
        // 0x8048198
        g1 = 102;
        *(int16_t *)&g2 = 3;
        g4 = 0;
        *(int16_t *)&g5 = 3;
        *v5 = 2;
        __asm_int(128);
        if (g3 % 4 != 0) {
            // 0x8048203
            *v5 = 3;
            __asm_int(128);
            if (*(char *)&g10 == -1) {
                int32_t v22 = (int32_t)&g10; // 0x804823c
                if ((int32_t)&g10 == (int32_t)&g10 + 3) {
                  lab_0x8048262:
                    // 0x8048262
                    *v5 = 4;
                    __asm_int(128);
                } else {
                    int32_t v23 = v22 + v21; // 0x804823e
                    while (*(char *)v22 == -1) {
                        char v24 = *(char *)v23; // 0x8048243
                        int32_t v25 = v23 + v21; // 0x8048243
                        int32_t v26; // 0x804809d
                        switch (v24) {
                            case -2: {
                            }
                            case -5: {
                            }
                            case -4: {
                                // 0x8048239
                                v26 = v25 + v21;
                                // break -> 0x804823a
                                break;
                            }
                            default: {
                                // 0x8048250
                                v26 = v25;
                                if (v24 == -3) {
                                    int32_t v27 = v25 + v21; // 0x8048254
                                    *(char *)(v27 - 2) = *(char *)v25 != 8 ? -4 : -5;
                                    v26 = v27;
                                }
                                // break -> 0x804823a
                                break;
                            }
                        }
                        // 0x804823a
                        v22 = v26;
                        if (v26 == (int32_t)&g10 + 3) {
                            goto lab_0x8048262;
                        }
                        v23 = v22 + v21;
                    }
                    // 0x8048273
                    *v5 = v23;
                    *v16 = 3;
                    v1 = v23 - (int32_t)&g10;
                    *v17 = 4;
                    __asm_int(128);
                    *v5 = 4;
                    __asm_int(128);
                }
            } else {
                // 0x8048228
                *v5 = 4;
                __asm_int(128);
            }
        } else {
            // 0x80481d6
            if (g6 % 4 != 0) {
                // 0x80481e3
                *v5 = 3;
                __asm_int(128);
                *v5 = 4;
                __asm_int(128);
            }
        }
    }
}

// Address range: 0x804829f - 0x80482c1
int32_t function_804829f(void) {
    int32_t v1 = 0; // 0x80482a3
    int32_t result = 0; // 0x80482a3
    for (int32_t i = 0; i < 4; i++) {
        // 0x80482a5
        int32_t v2; // 0x804829f
        unsigned char v3 = *(char *)(v1 + v2); // 0x80482a7
        int32_t v4 = v1 + 1; // 0x80482aa
        int32_t v5 = result & -256 | (int32_t)(v3 - 48); // 0x80482ab
        int32_t v6 = v5; // 0x80482ad
        int32_t v7 = v4; // 0x80482ad
        int32_t v8 = 0; // 0x80482ad
        v1 = v4;
        int32_t v9 = v5; // 0x80482ad
        if (v3 >= 48) {
            int32_t v10 = v6; // 0x80482b2
            unsigned char v11 = *(char *)(v7 + v2); // 0x80482a7
            int32_t v12 = v7 + 1; // 0x80482aa
            int32_t v13 = v6 & -256 | (int32_t)(v11 - 48); // 0x80482ab
            v6 = v13;
            v7 = v12;
            int32_t v14 = v10; // 0x80482ad
            v8 = v10;
            v1 = v12;
            v9 = v13;
            while (v11 >= 48) {
                // 0x80482af
                v10 = 10 * v14 + v6;
                v11 = *(char *)(v7 + v2);
                v12 = v7 + 1;
                v13 = v6 & -256 | (int32_t)(v11 - 48);
                v6 = v13;
                v7 = v12;
                v14 = v10;
                v8 = v10;
                v1 = v12;
                v9 = v13;
            }
        }
        // 0x80482b6
        result = v9;
        *(char *)(v2 + 4 + i) = (char)v8;
    }
    // 0x80482c0
    return result;
}

// Address range: 0x80482c1 - 0x80482f3
int32_t function_80482c1(void) {
    // 0x80482c1
    __asm_int(128);
    int32_t v1 = g9; // 0x80482d2
    g9 = v1 & -11;
    __asm_int(128);
    g9 = v1;
    return 54;
}

// Address range: 0x80482f3 - 0x8048305
int32_t function_80482f3(void) {
    // 0x80482f3
    __asm_int(128);
    return 54;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: elfcrypt (1.0)
// Detected functions: 4

