// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804809D: void fn0804809D(Stack word32 dwArg00)
void fn0804809D(word32 dwArg00)
{
	int32 eax_133;
	struct Eq_4 * esp_141;
	fn080482C1();
	ptr32 esp_13 = fp + 4;
	if (dwArg00 == 0x01)
	{
		__syscall(0x80);
		esp_141 = fp + 4;
		eax_133 = 0x00;
l080480B8:
		if (eax_133 != 0x00 && eax_133 == ~0x6E)
		{
			word32 * esp_41 = esp_141 - 4;
			*esp_41 = 22;
			*esp_41 = 0x01;
			*esp_41 = 0x04;
			__syscall(0x80);
		}
		fn080482F3();
		word32 * esp_66 = esp_141 - 4;
		*esp_66 = 0x06;
		__syscall(0x80);
		*esp_66 = 0x01;
		__syscall(0x80);
		esp_13 = esp_66 + 1;
	}
	struct Eq_14 * esp_80 = esp_13 + 4;
	fn0804829F(esp_80->ptr0000, 0x08048315);
	byte * esi_92 = esp_80->ptr0004;
	byte bl_115 = 0x17;
	byte * esi_103 = esi_92;
	if (esi_92 != null)
	{
		Eq_119 ebx_367 = 0x00;
		while (true)
		{
			bl_115 = (byte) ebx_367;
			cu8 al_105 = *esi_103;
			++esi_103;
			if (al_105 < 0x30)
				break;
			uint32 eax_366 = (uint32) (al_105 - 0x30);
			if (al_105 > 0x39)
				break;
			ebx_367 = ebx_367 *s 0x0A + eax_366;
		}
	}
	g_dw8048315 = 0x02;
	g_b8048318 = bl_115;
	esp_80->ptr0004 = null;
	esp_80->ptr0000 = 0x01;
	esp_80->dwFFFFFFFC = 0x02;
	esp_80->dwFFFFFFF8 = 0x01;
	esp_80->dwFFFFFFF8 = 0x66;
	eax_133 = esp_80->dwFFFFFFF8;
	__syscall(0x80);
	bool v28_388 = eax_133 < 0x00;
	do
	{
		esp_141 = esp_13 + 0x0C;
		if (v28_388)
			goto l080480B8;
		esp_141->dwFFFFFFFC = 0x10;
		esp_141->dwFFFFFFF8 = 0x04;
		esp_141->dwFFFFFFF4 = esp_141 - 4;
		esp_141->dwFFFFFFF0 = 0x01;
		esp_141->dwFFFFFFEC = 0x00;
		esp_141->dwFFFFFFE8 = eax_399;
		esp_141->dwFFFFFFE4 = 0x0E;
		esp_141->dwFFFFFFE4 = 0x66;
		int32 eax_162 = esp_141->dwFFFFFFE4;
		__syscall(0x80);
		v28_388 = eax_162 < 0x00;
		eax_133 = esp_141->dwFFFFFFFC;
		eax_399 = eax_133;
		if (eax_162 < 0x00)
			continue;
		esp_141->dwFFFFFFFC = 0x10;
		esp_141->dwFFFFFFF8 = 0x08048315;
		esp_141->dwFFFFFFF4 = eax_399;
		esp_141->dwFFFFFFF0 = 0x03;
		esp_141->dwFFFFFFF0 = 0x66;
		eax_133 = esp_141->dwFFFFFFF0;
		__syscall(0x80);
		v28_388 = eax_133 < 0x00;
		eax_400 = eax_133;
		if (eax_133 < 0x00)
			continue;
		esp_141->dwFFFFFFFC = 0x01;
		esp_141->dwFFFFFFF8 = 0x04;
		esp_141->dwFFFFFFF4 = esp_141 - 4;
		esp_141->dwFFFFFFF0 = 0x0A;
		esp_141->dwFFFFFFEC = 0x01;
		esp_141->dwFFFFFFE8 = eax_399;
		esp_141->dwFFFFFFE4 = 0x0E;
		esp_141->dwFFFFFFE4 = 0x66;
		int32 eax_209 = esp_141->dwFFFFFFE4;
		__syscall(0x80);
		v28_388 = eax_209 < 0x00;
		eax_133 = esp_141->dwFFFFFFFC;
		eax_401 = eax_133;
	} while (eax_209 < 0x00);
	esp_141->dwFFFFFFFC = 0x01;
	esp_141->dwFFFFFFFC = 0x04;
	__syscall(0x80);
	while (true)
	{
l08048198:
		while (true)
		{
			g_dw8048305 = eax_399;
			g_w8048309 = 0x03;
			g_dw804830D = 0x00;
			g_w8048311 = 0x03;
			esp_141->dwFFFFFFFC = 0x02;
			__syscall(0x80);
			if ((g_w804830B & 0x03) != 0x00)
				break;
			if ((g_w8048313 & 0x03) != 0x00)
			{
				esp_141->dwFFFFFFFC = 0x03;
				__syscall(0x80);
				esp_141->dwFFFFFFFC = 0x04;
				__syscall(0x80);
			}
		}
		esp_141->dwFFFFFFFC = 0x03;
		int32 eax_252 = esp_141->dwFFFFFFFC;
		__syscall(0x80);
		struct Eq_287 * esi_245 = &g_b8048349;
		eax_133 = eax_252;
		if (eax_252 == 0x00)
			break;
		if (g_b8048349 != ~0x00)
		{
			esp_141->dwFFFFFFFC = 0x01;
			esp_141->dwFFFFFFFC = 0x04;
			__syscall(0x80);
		}
		else
		{
			while (esi_245 != eax_252 + 0x08048349)
			{
				struct Eq_360 * esi_277 = &esi_245->b0000 + 1;
				if (esi_245->b0000 != ~0x00)
				{
					esp_141->dwFFFFFFFC = esi_277;
					esp_141->dwFFFFFFF8 = eax_252;
					esp_141->dwFFFFFFF4 = esi_277 - 0x08048349;
					esp_141->dwFFFFFFF0 = 0x04;
					__syscall(0x80);
					esp_141->dwFFFFFFFC = 0x01;
					esp_141->dwFFFFFFFC = 0x04;
					__syscall(0x80);
					goto l08048198;
				}
				byte al_310 = esi_277->b0000;
				esi_245 = (struct Eq_287 *) &esi_277->b0001;
				if (al_310 != ~0x01 && (al_310 != ~0x04 && al_310 != 252))
				{
					if (al_310 == ~0x02)
					{
						esi_245 = (struct Eq_287 *) (&esi_277->b0001 + 1);
						byte al_327 = 252;
						if (esi_277->b0001 == 0x08)
							al_327 = ~0x04;
						esi_277->b0000 = al_327;
					}
				}
				else
					esi_245 = (struct Eq_287 *) (&esi_277->b0001 + 1);
			}
			esp_141->dwFFFFFFFC = 0x04;
			__syscall(0x80);
		}
	}
	goto l080480B8;
}

// 0804829F: void fn0804829F(Register ptr32 esi, Register ptr32 edi)
// Called from:
//      fn0804809D
void fn0804829F(ptr32 esi, ptr32 edi)
{
	int32 edx_12 = 0x00;
	int32 ecx_23;
	for (ecx_23 = 0x00; ecx_23 != 0x04; ++ecx_23)
	{
		int32 ebx_31 = 0x00;
		while (true)
		{
			cu8 al_14 = esi + edx_12;
			byte bl_19 = (byte) ebx_31;
			++edx_12;
			uint32 eax_30 = (uint32) (al_14 - 0x30);
			if (al_14 < 0x30)
				break;
			ebx_31 = ebx_31 *s 0x0A + eax_30;
		}
		edi + 0x04 + ecx_23 = (byte *) bl_19;
	}
}

// 080482C1: void fn080482C1()
// Called from:
//      fn0804809D
void fn080482C1()
{
	__syscall(0x80);
	ui32 eax_9 = g_dw8048331;
	g_dw8048331 = eax_9 & ~0x0A;
	__syscall(0x80);
	g_dw8048331 = eax_9;
}

// 080482F3: void fn080482F3()
// Called from:
//      fn0804809D
void fn080482F3()
{
	__syscall(0x80);
}

int32 g_dw8048305 = 0; // 08048305
word16 g_w8048309 = 0x00; // 08048309
cui16 g_w804830B = 0x00; // 0804830B
word32 g_dw804830D = 0x00; // 0804830D
word16 g_w8048311 = 0x00; // 08048311
cui16 g_w8048313 = 0x00; // 08048313
word32 g_dw8048315 = 0x00; // 08048315
byte g_b8048318 = 0x00; // 08048318
ui32 g_dw8048331 = 0x00; // 08048331
byte g_b8048349 = 0x00; // 08048349
