// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048054: void fn08048054()
void fn08048054()
{
	struct Eq_2 * esp_2 = fp;
	while (true)
	{
		struct Eq_4 * esp_18 = &esp_2->dw0000 + 1;
		if (esp_2->dw0000 == 0x02)
		{
			cu8 * ebx_11 = esp_18->dw0004;
			esp_18->dw0004 = 0x05;
			int32 eax_17 = esp_18->dw0004;
			__syscall(0x80);
			++esp_18;
			if (eax_17 >= 0x00)
			{
				esp_18->dw0004 = eax_17;
				cu8 * edx_38 = ebx_11;
				do
				{
					edx_38 = edx_293 + 1;
					edx_293 = edx_38;
				} while (*edx_293 >= 0x01);
				esp_18->dw0000 = 0x01;
				esp_18->dw0000 = 0x04;
				__syscall(0x80);
				word32 ebx_59 = esp_18->dw0004;
				esp_18->dw0004 = 0x36;
				__syscall(0x80);
				esp_18->dw0004 = ebx_59;
				esp_18->dw0000 = 0x01;
				esp_18->dw0000 = 0x04;
				__syscall(0x80);
				fn080481A6();
				esp_18->dw0000 = 0x01;
				esp_18->dw0000 = 0x01;
				esp_18->dw0000 = 0x04;
				__syscall(0x80);
				word32 ebx_98 = esp_18->dw0004;
				esp_18->dw0004 = 0x03;
				__syscall(0x80);
				g_dw80484EC = ebx_98;
				ptr32 esp_106 = esp_18 + 1;
				struct Eq_126 * edi_108 = &g_t80486CE;
				ui32 edx_109 = 0x00;
				do
				{
					struct Eq_130 * esp_113 = esp_106 - 4;
					esp_113->dw0000 = edx_109;
					esp_113->ptrFFFFFFFC = edi_108;
					fn080481EB(edx_109, edi_108);
					struct Eq_144 * esp_125 = (struct Eq_144 *) <invalid>;
					ui32 edi_130 = esp_125->dw0000;
					struct Eq_126 * edx_132 = esp_125->ptr0004;
					esp_106 = &esp_125->dw0008;
					edi_108 = edi_130 + 0x10;
					edx_109 = SEQ(SLICE(edx_132, word24, 8), (byte) edx_132 + 0x01);
				} while (edi_130 != 134514430);
				ui32 ebp_141 = edx_109;
				ui32 eax_142 = g_dw80484F0;
				if (eax_142 != 0x00)
				{
					g_dw80484F4 = eax_142;
					esp_125->ptr0004 = __shld(0x00, eax_142, 0x09);
					esp_125->dw0000 = eax_142 << 0x09;
					struct Eq_144 * esp_155 = esp_125;
					do
					{
						__syscall(0x80);
						word32 * esp_160 = &esp_155->ptr0004;
						*esp_160 = 0x03;
						__syscall(0x80);
						esp_155 = (struct Eq_144 *) (esp_160 + 1);
						ui32 edx_177 = ebp_141;
						struct Eq_126 * edi_178 = &g_t80486CE;
						ui32 esi_179 = 0x00;
						do
						{
							if (edi_178->b0004 != 0x05 && (edi_178->b0004 != 0x0F && edi_178->b0004 != 133))
							{
								if (edi_178->b0004 != 0x00)
								{
									struct Eq_249 * esp_213 = esp_155 - 4;
									esp_213->dw0000 = edx_177;
									esp_213->ptrFFFFFFFC = edi_178;
									esp_213->dwFFFFFFF8 = esi_179;
									fn080481EB(edx_177, edi_178);
									struct Eq_144 * esp_226 = (struct Eq_144 *) <invalid>;
									word32 edx_235 = esp_226->dw0008;
									edx_177 = SEQ(SLICE(edx_235, word24, 8), (byte) edx_235 + 0x01);
									esi_179 = esp_226->dw0000;
									edi_178 = esp_226->ptr0004;
									esp_155 = &esp_226->dw0008 + 1;
									ebp_141 = edx_177;
								}
							}
							else
							{
								Eq_196 ecx_edx_283 = edi_178->dw0008 + g_dw80484F0;
								ui32 edx_197 = (word32) ecx_edx_283;
								g_dw80484F4 = edx_197;
								struct Eq_208 * esp_207 = esp_155 - 4;
								esp_207->ptr0000 = __shld(SLICE(ecx_edx_283, word32, 32), edx_197, 0x09);
								esp_207->dwFFFFFFFC = edx_197 << 0x09;
								++esi_179;
								edx_177 = edx_197 << 0x09;
								esp_155 = esp_207 - 4;
							}
							++edi_178;
						} while (edi_178 != &g_w804870E);
					} while (esi_179 != 0x00);
				}
				__syscall(0x80);
				__syscall(0x80);
				fn080481A6();
				return;
			}
		}
		word32 * esp_26 = esp_18 - 4;
		*esp_26 = 0x01;
		__syscall(0x80);
		esp_2 = (struct Eq_2 *) (esp_26 + 1);
	}
}

// 080481A6: void fn080481A6()
// Called from:
//      fn08048054
void fn080481A6()
{
	fn080483DF((word32) g_w80484FA);
	__syscall(0x80);
	fn080483DF((word32) g_b80484F8);
	__syscall(0x80);
	fn080483DF((word32) g_b80484F9);
}

// 080481EB: void fn080481EB(Register ui32 edx, Register (ptr32 Eq_126) edi)
// Called from:
//      fn08048054
void fn080481EB(ui32 edx, struct Eq_126 * edi)
{
	if (g_w804870E == 0x55AA || g_w804870E == 0xAA55)
	{
		__syscall(0x80);
		fn080483DF(edx + 0x01);
		if (edi->b0004 == 0x06)
			return;
		if (edi->b0004 == 11 || edi->b0004 == 0x0C)
			return;
		if (edi->b0004 == 0xA5 || edi->b0004 == 166)
			return;
		if (edi->b0004 == 0x82)
			return;
		if (edi->b0004 == 131)
			return;
		if (edi->b0004 == 0x00)
			return;
		if (edi->b0004 != 0x05 && (edi->b0004 != 0x0F && edi->b0004 != 133))
			return;
		g_dw80484F0 = edi->dw0008;
	}
	else
	{
		__syscall(0x80);
		__syscall(0x80);
	}
}

// 080483DF: void fn080483DF(Register uint32 eax)
// Called from:
//      fn080481A6
//      fn080481EB
void fn080483DF(uint32 eax)
{
	fn080483FF(eax, 0x08048500);
	__syscall(0x80);
}

// 080483FF: Register word32 fn080483FF(Register uint32 eax, Register word32 edi)
// Called from:
//      fn080483DF
word32 fn080483FF(uint32 eax, word32 edi)
{
fn080483FF_entry:
	word32 * esp_18 = fp - 4
	goto l08048404
l080483FF:
l08048404:
	uint64 edx_eax_11 = (uint64) eax
	uint32 edx_14 = (uint32) (edx_eax_11 % 0x0A)
	esp_18 = esp_18 - 4
	*esp_18 = SEQ(SLICE(edx_14, word24, 8), (byte) edx_14 | 0x30)
	eax = (uint32) (edx_eax_11 /u 0x0A)
	branch eax != 0x00 l08048404
	goto l08048404
}

word32 g_dw80484EC = 0x00; // 080484EC
ui32 g_dw80484F0 = 0x00; // 080484F0
ui32 g_dw80484F4 = 0x00; // 080484F4
byte g_b80484F8 = 0x00; // 080484F8
byte g_b80484F9 = 0x00; // 080484F9
word16 g_w80484FA = 0x00; // 080484FA
Eq_126 g_t80486CE = // 080486CE
	{
		0x00,
		0x00,
	};
word16 g_w804870E = 0x00; // 0804870E
