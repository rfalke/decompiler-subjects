//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2, int32_t a3);
int32_t function_804804d(void);
int32_t function_80481a6(void);
int32_t function_80481eb(void);
int32_t function_80483df(void);
int32_t function_80483ff(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x80484ec
int32_t g2 = 0; // 0x80484f0
int32_t g3 = 0; // 0x80484f4
int32_t g4 = 0; // 0x80486ce
int16_t g5 = 0; // 0x804870e

// ------------------------ Functions -------------------------

// Address range: 0x804804d - 0x8048054
int32_t function_804804d(void) {
    // 0x804804d
    __asm_int(128);
    return 1;
}

// Address range: 0x8048054 - 0x80481a6
int32_t entry_point(int32_t a1, int32_t a2, int32_t a3) {
    if (a1 != 2) {
        function_804804d();
    }
    // 0x804805a
    __asm_int(128);
    int32_t v1 = a3; // 0x804806c
    while (*(char *)v1 != 0) {
        // 0x804806e
        v1++;
    }
    // 0x8048074
    __asm_int(128);
    __asm_int(128);
    __asm_int(128);
    function_80481a6();
    __asm_int(128);
    int32_t v2; // bp+12, 0x8048054
    int32_t v3 = &v2; // 0x80480c3
    __asm_int(128);
    g1 = 5;
    int32_t * v4 = (int32_t *)(v3 - 4);
    int32_t v5 = v3 - 8; // 0x80480d4
    int32_t * v6 = (int32_t *)v5;
    *v4 = 0;
    *v6 = (int32_t)&g4;
    function_80481eb();
    int32_t v7 = *v4; // 0x80480db
    int32_t v8 = (v7 + 1) % 256 | v7 & -256; // 0x80480dc
    int32_t v9 = *v6 + 16; // 0x80480de
    while (v9 != (int32_t)&g5) {
        // 0x80480d3
        *v4 = v8;
        *v6 = v9;
        function_80481eb();
        v7 = *v4;
        v8 = (v7 + 1) % 256 | v7 & -256;
        v9 = *v6 + 16;
    }
    int32_t * v10 = v4; // 0x80480f2
    int32_t v11; // 0x8048054
    int32_t v12; // 0x8048054
    int32_t v13; // 0x8048054
    int32_t v14; // 0x8048054
    int32_t v15; // 0x8048054
    int32_t v16; // 0x8048054
    int32_t v17; // 0x8048054
    int32_t v18; // 0x8048054
    int32_t v19; // 0x8048054
    int32_t v20; // 0x8048054
    int32_t v21; // 0x8048054
    int32_t v22; // 0x8048054
    int32_t v23; // 0x8048054
    int32_t v24; // 0x8048054
    int32_t v25; // 0x8048054
    int32_t v26; // 0x8048054
    int32_t v27; // 0x8048054
    if (g2 != 0) {
        // 0x80480f8
        g3 = g2;
        *v4 = g2 / 0x800000;
        *v6 = 512 * g2;
        int32_t v28 = v5; // 0x8048109
        int32_t v29 = v8; // 0x8048109
        while (true) {
            // 0x804810a
            __asm_int(128);
            *(int32_t *)(v28 + 4) = 3;
            __asm_int(128);
            v18 = v29;
            v24 = v28 + 8;
            v11 = v29;
            v20 = 0;
            v15 = &g4;
            while (true) {
              lab_0x804813c:
                // 0x804813c
                v16 = v15;
                v21 = v20;
                v12 = v11;
                v25 = v24;
                int32_t v30 = v18;
                v19 = v30;
                v26 = v25;
                v13 = v12;
                v22 = v21;
                v17 = v16;
                switch (*(char *)(v16 + 4)) {
                    case 5: {
                        goto lab_0x8048174;
                    }
                    case 15: {
                        goto lab_0x8048174;
                    }
                    case -123: {
                        goto lab_0x8048174;
                    }
                    case 0: {
                        goto lab_0x8048163;
                    }
                    default: {
                        int32_t * v31 = (int32_t *)(v25 - 4); // 0x8048154
                        *v31 = v30;
                        int32_t * v32 = (int32_t *)(v25 - 8); // 0x8048155
                        *v32 = v16;
                        int32_t * v33 = (int32_t *)(v25 - 12); // 0x8048156
                        *v33 = v21;
                        function_80481eb();
                        int32_t v34 = *v31; // 0x804815e
                        int32_t v35 = (v34 + 1) % 256 | v34 & -256; // 0x804815f
                        v19 = v35;
                        v26 = v25;
                        v13 = v35;
                        v22 = *v33;
                        v17 = *v32;
                        goto lab_0x8048163;
                    }
                }
            }
          lab_0x804816e:
            // 0x804816e
            v28 = v27;
            v29 = v14;
            if (v23 == 0) {
                // break -> 0x8048194
                break;
            }
        }
        // 0x8048194
        v10 = (int32_t *)(v27 - 4);
    }
    // 0x8048194
    *v10 = 6;
    __asm_int(128);
    *v10 = 1;
    __asm_int(128);
    return 1;
  lab_0x8048174:;
    uint32_t v36 = *(int32_t *)(v16 + 8); // 0x8048177
    uint32_t v37 = g2 + v36; // 0x804817a
    g3 = v37;
    int32_t v38 = 512 * v37; // 0x804818d
    *(int32_t *)(v25 - 4) = 512 * (int32_t)(v37 < v36) | v37 / 0x800000;
    int32_t v39 = v25 - 8; // 0x8048191
    *(int32_t *)v39 = v38;
    v19 = v38;
    v26 = v39;
    v13 = v12;
    v22 = v21 + 1;
    v17 = v16;
    goto lab_0x8048163;
  lab_0x8048163:
    // 0x8048163
    v23 = v22;
    v14 = v13;
    v27 = v26;
    int32_t v40 = v17 + 16; // 0x8048163
    v18 = v19;
    v24 = v27;
    v11 = v14;
    v20 = v23;
    v15 = v40;
    if (v40 == (int32_t)&g5) {
        // break -> 0x804816e
        goto lab_0x804816e;
    }
    goto lab_0x804813c;
}

// Address range: 0x80481a6 - 0x80481eb
int32_t function_80481a6(void) {
    // 0x80481a6
    function_80483df();
    __asm_int(128);
    function_80483df();
    __asm_int(128);
    return function_80483df();
}

// Address range: 0x80481eb - 0x80482e2
int32_t function_80481eb(void) {
    // 0x80481eb
    __asm_int(128);
    int32_t v1; // 0x80481eb
    int32_t result; // 0x8048236
    char v2; // 0x8048240
    switch (g5) {
        case -0x55ab: {
        }
        case 0x55aa: {
            // 0x804821d
            result = function_80483df();
            v2 = *(char *)(v1 + 4);
            if (v2 == 6) {
                // 0x8048246
                return result;
            }
            // break -> 0x8048251
            break;
        }
        default: {
            // 0x8048201
            __asm_int(128);
            return 1;
        }
    }
    if (v2 == 0 || (v2 || 1) == -125) {
        // 0x8048246
        return result;
    }
    switch (v2) {
        case -123: {
        }
        case 15: {
        }
        case 5: {
            int32_t result2 = *(int32_t *)(v1 + 8); // 0x80482cf
            g2 = result2;
            return result2;
        }
    }
    // 0x8048246
    return result;
}

// Address range: 0x80483df - 0x80483ff
int32_t function_80483df(void) {
    // 0x80483df
    function_80483ff();
    __asm_int(128);
    return 4;
}

// Address range: 0x80483ff - 0x8048417
int32_t function_80483ff(void) {
    int64_t v1 = 0; // bp-4, 0x8048402
    int32_t v2 = &v1;
    int32_t v3; // 0x80483ff
    uint32_t v4 = v3;
    int32_t v5 = v4 % 10 | 48; // 0x8048408
    int32_t v6 = v2 - 4; // 0x804840b
    *(int32_t *)v6 = v5;
    v3 = v4 / 10;
    while (v4 >= 10) {
        // 0x8048404
        v2 = v6;
        v4 = v3;
        v5 = v4 % 10 | 48;
        v6 = v2 - 4;
        *(int32_t *)v6 = v5;
        v3 = v4 / 10;
    }
    // 0x8048410
    int32_t v7; // 0x80483ff
    *(char *)v7 = (char)v5;
    int32_t v8 = v2; // 0x80483ff
    int32_t v9; // 0x80483ff
    bool v10; // 0x80483ff
    int32_t v11 = v9 + (v10 ? -1 : 1); // 0x8048411
    int32_t result = *(int32_t *)v8;
    char v12 = result; // 0x8048411
    *(char *)v11 = v12;
    v8 += 4;
    v9 = v11;
    while (v12 != 0) {
        // 0x8048410
        v11 = v9 + (v10 ? -1 : 1);
        result = *(int32_t *)v8;
        v12 = result;
        *(char *)v11 = v12;
        v8 += 4;
        v9 = v11;
    }
    // 0x8048416
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: upx (3.xx)
// Detected functions: 6

