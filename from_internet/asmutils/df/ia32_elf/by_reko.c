// subject_seg08048000_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

uint32 g_dw804804C = 0x0400; // 0804804C
// 080481BB: void fn080481BB(Register cu8 dl, Stack (ptr32 Eq_3) dwArg08)
void fn080481BB(cu8 dl, struct Eq_3 * dwArg08)
{
	if (dwArg08 != null && dwArg08->w0000 == 0x2D2D)
	{
		if (dwArg08->dw0002 == 0x706C6568)
			dl = ~0x29;
		else
		{
			if (dwArg08->dw0002 != 0x73726576)
				goto l0804847F;
			dl = 0x13;
		}
		__syscall(0x80);
	}
	else
	{
		__syscall(0x80);
		__syscall(0x80);
		__syscall(0x80);
		byte * esi_36 = &g_b8048559;
		dl = 0x00;
		word32 ecx_383 = 0x03;
		do
		{
			byte al_49 = 0x20;
			byte * edi_50 = g_a804851C;
			do
			{
				if (ecx_554 == 0x00)
					goto l0804847F;
				*edi_50 = *esi_36;
				ecx_383 = ecx_554 - 0x01;
				++esi_36;
				++edi_50;
				ecx_554 = ecx_383;
			} while (*esi_36 != 0x20);
			*edi_50 = 0x00;
			byte * esi_68 = esi_36 + 1;
			word32 ecx_69 = ecx_554 - 0x02;
			byte * edi_71 = g_a804853A;
			do
			{
				if (ecx_555 == 0x00)
				{
					__syscall(0x80);
					al_49 = 0x01;
				}
				*edi_71 = *esi_68;
				ecx_69 = ecx_555 - 0x01;
				++esi_68;
				++edi_71;
				ecx_555 = ecx_69;
			} while (al_49 != *esi_68);
			*edi_71 = 0x00;
			__syscall(0x80);
			struct Eq_113 * edx_112 = fn080484B9(0x0804851C);
			__syscall(0x80);
			fn08048491((uint32) (g_dw80484D9 *64 g_t80484DD /u g_dw804804C), &g_w8048511);
			fn080484C9((uint32) (0x1E - g_t804851B - (byte) edx_112), g_a804851C);
			__syscall(0x80);
			__syscall(0x80);
			fn08048491((uint32) (g_dw80484D9 *64 (g_t80484DD - g_dw80484E1) /u g_dw804804C), &g_w8048511);
			fn080484C9((uint32) (0x0A - g_t804851B), g_a804851C);
			__syscall(0x80);
			__syscall(0x80);
			fn08048491((uint32) (g_dw80484D9 *64 g_dw80484E5 /u g_dw804804C), &g_w8048511);
			fn080484C9((uint32) (0x0A - g_t804851B), g_a804851C);
			__syscall(0x80);
			__syscall(0x80);
			word32 dwArg08_455 = ecx_555 - 0x01;
			Eq_129 eax_266 = g_t80484DD;
			if (eax_266 == 0x00)
			{
				g_t804851B.u0 = 0x01;
				g_w8048511 = 0x202D;
			}
			else
			{
				uint32 eax_271 = eax_266 - g_dw80484E5;
				uint32 eax_281 = (uint32) (eax_271 *64 100 /u g_t80484DD);
				if ((uint32) (eax_271 *64 100 % g_t80484DD) >= g_t80484DD >> 0x01)
					++eax_281;
				fn08048491(eax_281, &g_w8048511);
				((word32) g_t804851B + 0x08048511)->u0 = 0x25;
			}
			fn080484C9((uint32) (0x04 - g_t804851B), g_a804851C);
			__syscall(0x80);
			__syscall(0x80);
			__syscall(0x80);
			struct Eq_113 * edx_350 = fn080484B9(0x0804853A);
			edx_350->b804853A = 0x0A;
			__syscall(0x80);
			dl = (byte) edx_350 + 0x01;
			byte * edi_366 = esi_68;
			word32 ecx_368 = dwArg08_455;
			while (ecx_368 != 0x00)
			{
				++edi_366;
				--ecx_368;
				if (*edi_366 != 0x0A)
					break;
			}
			esi_36 = edi_366;
			ecx_383 = ecx_368;
		} while (ecx_368 != 0x00);
	}
l0804847F:
	__syscall(0x80);
	if (dl < 0x0A)
		;
}

// 08048484: Register cu8 fn08048484(Register cu8 dl)
// Called from:
//      fn08048491
cu8 fn08048484(cu8 dl)
{
	if (dl < 0x0A)
		return dl | 0x30;
	return dl + 55;
}

// 08048491: void fn08048491(Register uint32 eax, Register (ptr32 byte) edi)
// Called from:
//      fn080481BB
void fn08048491(uint32 eax, byte * edi)
{
	word32 * esp_30 = fp - 32;
	Eq_143 esi_31 = 0x00;
	do
	{
		uint64 edx_eax_36 = (uint64) eax;
		uint32 edx_39 = (uint32) (edx_eax_36 % 0x0A);
		esp_30 -= 4;
		*esp_30 = SEQ(SLICE(edx_39, word24, 8), fn08048484((byte) edx_39));
		eax = (uint32) (edx_eax_36 /u 0x0A);
		esi_31 = (word32) esi_31 + 1;
	} while (eax != 0x00);
	g_t804851B = esi_31;
	do
	{
		*edi = 0x0A;
		++edi;
		--esi_31;
	} while (esi_31 != 0x00);
}

// 080484B9: Register ptr32 fn080484B9(Register ui32 edi)
// Called from:
//      fn080481BB
ptr32 fn080484B9(ui32 edi)
{
	byte * edi_10 = edi - 0x01;
	do
		++edi_10;
	while (*edi_10 != 0x00);
	return edi_10 - edi;
}

// 080484C9: void fn080484C9(Register uint32 ecx, Register (ptr32 byte) edi)
// Called from:
//      fn080481BB
void fn080484C9(uint32 ecx, byte * edi)
{
	for (; ecx != 0x00; --ecx)
	{
		*edi = 0x20;
		++edi;
	}
}

uint32 g_dw80484D9 = 0x00; // 080484D9
Eq_129 g_t80484DD = // 080484DD
	{
		0
	};
uint32 g_dw80484E1 = 0x00; // 080484E1
uint32 g_dw80484E5 = 0x00; // 080484E5
word16 g_w8048511 = 0x00; // 08048511
Eq_143 g_t804851B = // 0804851B
	{
		0x00
	};
byte g_a804851C[] = // 0804851C
	{
	};
byte g_a804853A[] = // 0804853A
	{
	};
byte g_b8048559 = 0x00; // 08048559
