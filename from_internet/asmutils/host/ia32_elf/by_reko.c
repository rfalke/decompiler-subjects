// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804809F: void fn0804809F(Stack word32 dwArg00)
void fn0804809F(word32 dwArg00)
{
	int32 eax_115;
	struct Eq_4 * esp_106 = fp + 4;
	byte * ebx_102 = dwArg00 - 0x01;
	if (dwArg00 == 0x01)
	{
l080480A3:
		word32 * esp_10 = esp_106 - 4;
		*esp_10 = 0x2F;
		*esp_10 = 0x01;
		*esp_10 = 0x04;
		__syscall(0x80);
		esp_106 = (struct Eq_4 *) (esp_10 + 1);
		eax_115 = 0x00;
l080480B5:
		if (eax_115 != 0x00 && eax_115 == ~0x6E)
		{
			word32 * esp_34 = esp_106 - 4;
			*esp_34 = 0x24;
			*esp_34 = 0x01;
			*esp_34 = 0x04;
			__syscall(0x80);
		}
		word32 * esp_51 = esp_106 - 4;
		*esp_51 = 0x06;
		__syscall(0x80);
		*esp_51 = 0x01;
		__syscall(0x80);
		ebx_102 = null;
		esp_106 = (struct Eq_4 *) (esp_51 + 1);
	}
	g_t80483D4.u0 = 60000;
	struct Eq_15 * esp_65 = esp_106 + 1;
	byte * eax_100 = esp_65->ptr0000;
	esp_106 = (struct Eq_4 *) &esp_65->ptr0004;
	if (*eax_100 != 0x2D)
	{
l08048110:
		g_ptr80483CC = eax_100;
		if (ebx_102 != (byte *) 0x01)
		{
			g_ptr80483D0 = esp_106->dw0000;
			++esp_106;
		}
		ptr32 esi_110 = g_ptr80483D0;
		ptr32 esi_111 = esi_110;
		if (esi_110 != 0x00)
		{
l08048133:
			fn080482AB();
			fn08048289(esi_111, 0x0804860C);
			g_dw804860C = 0x02;
			g_b804860F = 0x35;
			struct Eq_162 * esp_147 = esp_106 - 4;
			esp_147->dw0000 = 0x00;
			esp_147->dwFFFFFFFC = 0x02;
			esp_147->dwFFFFFFF8 = 0x02;
			esp_147->dwFFFFFFF4 = 0x01;
			esp_147->dwFFFFFFF4 = 0x66;
			eax_115 = esp_147->dwFFFFFFF4;
			__syscall(0x80);
			bool v45_406 = eax_115 < 0x00;
			do
			{
				if (v45_406)
					goto l080480B5;
				struct Eq_204 * esp_169 = esp_106 - 4;
				esp_169->dw0000 = 0x10;
				esp_169->dwFFFFFFFC = 0x04;
				esp_169->ptrFFFFFFF8 = esp_169;
				esp_169->dwFFFFFFF4 = 0x01;
				esp_169->dwFFFFFFF0 = 0x00;
				esp_169->dwFFFFFFEC = eax_412;
				esp_169->dwFFFFFFE8 = 0x0E;
				esp_169->dwFFFFFFE8 = 0x66;
				int32 eax_189 = esp_169->dwFFFFFFE8;
				__syscall(0x80);
				v45_406 = eax_189 < 0x00;
				eax_115 = esp_169->dw0000;
				eax_412 = eax_115;
				if (eax_189 < 0x00)
					continue;
				esp_106->dwFFFFFFFC = 0x10;
				esp_106->dwFFFFFFF8 = 0x0804860C;
				esp_106->dwFFFFFFF4 = eax_412;
				esp_106->dwFFFFFFF0 = 0x03;
				esp_106->dwFFFFFFF0 = 0x66;
				eax_115 = esp_106->dwFFFFFFF0;
				__syscall(0x80);
				v45_406 = eax_115 < 0x00;
				eax_413 = eax_115;
				if (eax_115 < 0x00)
					continue;
				esp_106->dwFFFFFFFC = 0x01;
				esp_106->dwFFFFFFF8 = 0x04;
				esp_106->dwFFFFFFF4 = esp_106 - 4;
				esp_106->dwFFFFFFF0 = 0x0A;
				esp_106->dwFFFFFFEC = 0x01;
				esp_106->dwFFFFFFE8 = eax_412;
				esp_106->dwFFFFFFE4 = 0x0E;
				esp_106->dwFFFFFFE4 = 0x66;
				int32 eax_236 = esp_106->dwFFFFFFE4;
				__syscall(0x80);
				v45_406 = eax_236 < 0x00;
				eax_115 = esp_106->dwFFFFFFFC;
				eax_414 = eax_115;
			} while (eax_236 < 0x00);
			esp_106->dwFFFFFFFC = 0x01;
			esp_106->dwFFFFFFF8 = 0x36;
			int32 eax_251 = esp_106->dwFFFFFFF8;
			__syscall(0x80);
			eax_115 = esp_106->dwFFFFFFFC;
			if (eax_251 >= 0x00)
			{
				esp_106->dwFFFFFFFC = 0x04;
				__syscall(0x80);
				g_dw8048604 = eax_412;
				g_w8048608 = 0x03;
				esp_106->dwFFFFFFFC = 0x01;
				__syscall(0x80);
				eax_115 = 0xA8;
				if ((g_w804860A & 0x03) != 0x00)
				{
					esp_106->dwFFFFFFFC = 0x03;
					int32 eax_290 = esp_106->dwFFFFFFFC;
					__syscall(0x80);
					struct Eq_385 * esi_283 = &g_w80483F6;
					eax_115 = eax_290;
					word16 eax_16_16_380 = SLICE(eax_290, word16, 16);
					if (eax_290 != 0x00)
					{
						word16 ax_296 = g_w80483FC;
						byte al_297 = (byte) ax_296;
						uint24 eax_24_8_379 = SEQ(eax_16_16_380, al_297);
						if (SEQ(al_297, SLICE(ax_296, byte, 8)) != 0x00)
						{
							byte * esi_307 = &g_b8048404;
							do
							{
								esi_307 = esi_415 + 1;
								esi_415 = esi_307;
							} while (*esi_415 != 0x00);
							esi_283 = (struct Eq_385 *) (esi_307 + 4);
						}
						while (true)
						{
							do
							{
								esi_283 = esi_416 + 1;
								esi_416 = esi_283;
							} while (esi_416->b0000 != 0x00);
							do
							{
								byte al_328 = esi_283->b0000;
								++esi_283;
							} while (al_328 == 0x00);
							if (al_328 == 0x01)
								break;
							eax_115 = SEQ(eax_24_8_379, al_328);
							if (al_328 != 0x05)
								goto l08048284;
							word16 ax_357 = esi_283[6];
							uint8 al_358 = (byte) ax_357;
							esi_283 = esi_283 + 6 + SEQ(0x00, al_358, SLICE(ax_357, byte, 8)) + 2;
							eax_24_8_379 = (uint24) al_358;
						}
						byte al_337 = esi_283[7];
						eax_115 = SEQ(eax_24_8_379, al_337);
						if (al_337 == 0x04)
							eax_115 = fn0804830A(esi_283[8]);
					}
l08048284:
				}
			}
			goto l080480B5;
		}
		ptr32 esi_118;
		eax_115 = fn0804835A(out esi_118);
		esi_111 = esi_118;
		if (esi_118 != 0x00)
			goto l08048133;
		goto l080480B5;
	}
	byte * ebx_71 = ebx_102 - 0x02;
	if (ebx_71 > null)
	{
		byte * esi_74 = esp_65->ptr0004;
		esp_65->ptr0004 = ebx_71;
		Eq_12 ebx_373 = 0x00;
		while (true)
		{
			cu8 al_84 = *esi_74;
			++esi_74;
			if (al_84 < 0x30)
				break;
			uint32 eax_372 = (uint32) (al_84 - 0x30);
			if (al_84 > 0x39)
				break;
			ebx_373 = ebx_373 *s 0x0A + eax_372;
		}
		g_t80483D4 = ebx_373;
		ebx_102 = esp_65->ptr0004;
		eax_100 = esp_65->ptr0008;
		esp_106 = (struct Eq_4 *) ((char *) &esp_65->ptr0008 + 4);
		goto l08048110;
	}
	goto l080480A3;
}

// 08048289: void fn08048289(Register ptr32 esi, Register ptr32 edi)
// Called from:
//      fn0804809F
void fn08048289(ptr32 esi, ptr32 edi)
{
	int32 edx_12 = 0x00;
	int32 ecx_23;
	for (ecx_23 = 0x00; ecx_23 != 0x04; ++ecx_23)
	{
		int32 ebx_31 = 0x00;
		while (true)
		{
			cu8 al_14 = esi + edx_12;
			byte bl_19 = (byte) ebx_31;
			++edx_12;
			uint32 eax_30 = (uint32) (al_14 - 0x30);
			if (al_14 < 0x30)
				break;
			ebx_31 = ebx_31 *s 0x0A + eax_30;
		}
		edi + 0x04 + ecx_23 = (byte *) bl_19;
	}
}

// 080482AB: void fn080482AB()
// Called from:
//      fn0804809F
void fn080482AB()
{
	byte * esi_108 = g_ptr80483CC;
	byte * dwLoc24_124 = &g_b8048404;
	byte * edi_100 = &g_b8048405;
l080482B9:
	uip32 ecx_146 = 0x00;
	while (true)
	{
		byte cl_63 = (byte) ecx_146;
		byte al_38 = *esi_108;
		++esi_108;
		if (al_38 == 0x00)
			break;
		if (al_38 == 0x2E)
		{
			*dwLoc24_124 = cl_63;
			dwLoc24_124 = edi_100;
			++edi_100;
			goto l080482B9;
		}
		*edi_100 = al_38;
		++edi_100;
		ecx_146 = SEQ(SLICE(ecx_146 + 0x01, word24, 8), cl_63 + 0x01);
	}
	*edi_100 = 0x00;
	struct Eq_503 * edi_48 = edi_100 + 1;
	edi_48->w0000 = 0x0100;
	edi_48->w0002 = 0x0100;
	*dwLoc24_124 = cl_63;
	g_w80483F6 = SEQ((byte) edi_48 - 244, SLICE(edi_48 - 0x080483F4, byte, 8));
	g_w80483F8 = 19794;
	g_w80483FC = 0x0100;
	g_w80483FA = 0x01;
}

// 0804830A: Register word32 fn0804830A(Register word32 eax)
// Called from:
//      fn0804809F
word32 fn0804830A(word32 eax)
{
	word32 eax_13 = __ror<word32,byte>(eax, 0x10);
	fn0804832D(SEQ(SLICE(eax_13, word16, 16), (byte) eax_13, SLICE(eax_13, byte, 8)), &g_b80483EC);
	__syscall(0x80);
	return 0x04;
}

// 0804832D: void fn0804832D(Register uint32 eax, Register (ptr32 byte) edi)
// Called from:
//      fn0804830A
void fn0804832D(uint32 eax, byte * edi)
{
	*edi = 0x0A;
	byte * edi_11 = edi - 0x01;
	do
	{
		byte * edi_14 = fn08048348((byte) eax, edi_11);
		*edi_14 = 0x2E;
		uint32 eax_28 = SEQ(SLICE(eax, word24, 8), 0x2E);
		edi_11 = edi_14 - 1;
		eax = eax_28 >> 0x08;
	} while (eax_28 >> 0x08 != 0x00);
	*edi_14 = 0x20;
}

// 08048348: Register (ptr32 byte) fn08048348(Register uint8 al, Register (ptr32 byte) edi)
// Called from:
//      fn0804832D
byte * fn08048348(uint8 al, byte * edi)
{
	do
	{
		uint16 ax_6 = (uint16) al;
		*edi = (uint8) (ax_6 % 0x0A) + 0x30;
		uint8 al_10 = (uint8) (ax_6 /u 0x0A);
		++edi;
		al = al_10;
	} while (al_10 != 0x00);
	return edi;
}

// 0804835A: Register uint32 fn0804835A(Register out ptr32 esiOut)
// Called from:
//      fn0804809F
uint32 fn0804835A(ptr32 & esiOut)
{
	__syscall(0x80);
	__syscall(0x80);
	__syscall(0x80);
	struct Eq_647 * esi_26 = &g_t804861C;
	do
	{
		do
		{
			do
			{
				byte al_29 = esi_26->b0000;
				esi_26 = &esi_26->b0000 + 1;
			} while (al_29 != 110 || esi_26->b0000 != 0x73656D61);
			esi_26 = (struct Eq_647 *) &esi_26->dw0004;
		} while (esi_26->dw0004 != 0x65767265);
		++esi_26;
	} while (esi_26[1] != 114);
	cu8 * esi_48 = &esi_26->b0008 + 1;
	do
	{
		esi_48 = esi_118 + 1;
		esi_118 = esi_48;
	} while (*esi_118 <= 0x20);
	struct Eq_687 * esi_56 = esi_48 - 0x01;
	do
	{
		cu8 al_64 = esi_56->b0000;
		++esi_56;
		uint32 eax_83 = (uint32) al_64;
	} while (al_64 >= 0x2E);
	esi_56->bFFFFFFFF = 0x00;
	esiOut = esi_48 - 0x01;
	return eax_83;
}

byte * g_ptr80483CC = null; // 080483CC
ptr32 g_ptr80483D0 = 0x00; // 080483D0
Eq_12 g_t80483D4 = // 080483D4
	{
		0
	};
byte g_b80483EC = 0x00; // 080483EC
word16 g_w80483F6 = 0x00; // 080483F6
word16 g_w80483F8 = 0x00; // 080483F8
word16 g_w80483FA = 0x00; // 080483FA
word16 g_w80483FC = 0x00; // 080483FC
byte g_b8048404 = 0x00; // 08048404
byte g_b8048405 = 0x00; // 08048405
int32 g_dw8048604 = 0; // 08048604
word16 g_w8048608 = 0x00; // 08048608
cui16 g_w804860A = 0x00; // 0804860A
word32 g_dw804860C = 0x00; // 0804860C
byte g_b804860F = 0x00; // 0804860F
Eq_647 g_t804861C = // 0804861C
	{
		0x00,
		0x00,
		0x00,
	};
