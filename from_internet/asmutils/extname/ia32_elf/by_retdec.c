//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2, int32_t a3, int32_t a4);

// --------------------- Global Variables ---------------------

char * g1; // 0x80480d7

// ------------------------ Functions -------------------------

// Address range: 0x804804c - 0x80480d7
int32_t entry_point(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4;
    int32_t v2 = a2;
    int32_t v3 = a1 - 2; // 0x804804e
    if (v3 < 0) {
        // 0x80480d2
        *(int32_t *)((int32_t)&v2 - 4) = 1;
        __asm_int(128);
        return 1;
    }
    char * v4 = (char *)a3;
    unsigned char v5 = *v4; // 0x8048055
    char * v6 = v4; // 0x8048058
    bool v7 = v5 < 45; // 0x8048058
    v2 = v3;
    if (v5 == 45) {
        // 0x8048073
        v2 = v3;
        __asm_int(128);
        v6 = (char *)&g1;
        v7 = false;
    }
    bool v8 = v7; // 0x8048078
    char v9 = 46; // 0x8048078
    int32_t * v10 = &v1; // 0x8048078
    if (v2 >= 1) {
        uint32_t v11 = *(int32_t *)v1; // 0x804807b
        unsigned char v12 = (char)(v11 / 256); // 0x804807d
        unsigned char v13 = (char)v11; // 0x804807d
        v8 = !((v12 < v13 | v12 != v13));
        v9 = (v12 == v13 ? v11 : 256 * v11) / 256;
        int32_t v14; // bp+16, 0x804804c
        v10 = &v14;
    }
    int32_t v15 = -1; // 0x804808f
    int32_t v16 = (int32_t)v6;
    int32_t v17 = 0; // 0x804808f
    int32_t v18 = v16; // 0x804808f
    while (v15 != 0) {
        int32_t v19 = v16 + 1; // 0x804808f
        v15--;
        v17 = v15;
        v18 = v19;
        if (*(char *)v16 == 0) {
            // break -> .lr.ph15
            break;
        }
        v16 = v19;
        v17 = 0;
        v18 = v16;
    }
    int32_t v20 = -1 - v17;
    int32_t v21 = v18 - 1;
    int32_t v22 = v21 - 1; // 0x804809a
    int32_t v23 = 1; // 0x804809a
    while (*(char *)v21 != 47) {
        int32_t v24 = v20 - 1; // 0x804809a
        v23 = 0;
        if (v24 == 0) {
            // break -> 0x804809f
            break;
        }
        v20 = v24;
        v21 = v22;
        v22 = v21 - 1;
        v23 = 1;
    }
    int32_t v25 = 1 - v20 + -2 - v17; // 0x804809f
    int32_t v26 = v25 + v22 + v23; // 0x80480a9
    int32_t v27 = v25 - 1; // 0x80480aa
    int32_t v28 = v25; // 0x80480ab
    bool v29 = v27 == 0; // 0x80480ab
    int32_t v30 = 0; // 0x80480ab
    int32_t v31 = v26; // 0x80480ab
    int32_t v32; // 0x804804c
    if (v25 != 0) {
        int32_t v33 = v26;
        int32_t v34 = v33 - 1; // 0x80480ab
        v28--;
        v29 = true;
        v30 = v28;
        v31 = v34;
        while (*(char *)v33 != v9) {
            // .lr.ph
            v32 = v34;
            if (v28 == 0) {
                goto lab_0x80480b2;
            }
            v33 = v34;
            v34 = v33 - 1;
            v28--;
            v29 = true;
            v30 = v28;
            v31 = v34;
        }
    }
    // ._crit_edge
    v32 = v31;
    v25 = v30;
    if (v29) {
        goto lab_0x80480b2;
    } else {
        goto lab_0x80480b2;
    }
  lab_0x80480af:
    // 0x80480af
    goto lab_0x80480b2;
  lab_0x80480b2:;
    int32_t v35 = v32;
    v32 = v35;
    if (v25 != 0) {
        int32_t v36 = v8 ? 2 : 1; // 0x80480ba
        *(char *)(v36 + (int32_t)!v8 + v27 + v35 - v25) = 10;
        int32_t * v37 = (int32_t *)((int32_t)v10 - 4);
        *v37 = 4;
        __asm_int(128);
        // 0x80480d2
        *v37 = 1;
        __asm_int(128);
        return 1;
    }
    goto lab_0x80480af;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: elfcrypt (1.0)
// Detected functions: 1

