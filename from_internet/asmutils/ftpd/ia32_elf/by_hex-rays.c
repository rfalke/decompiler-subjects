/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn start(); // weak
// int __usercall sub_8048358@<eax>(int@<ebp>);
// char __usercall sub_8048AB6@<al>(int@<ebx>, unsigned __int8 *@<esi>);
// unsigned int __usercall sub_8048ACC@<eax>(unsigned int result@<eax>, int@<edx>, int@<ecx>, _BYTE *@<edi>);
// int __usercall sub_8048AF6@<eax>(unsigned __int8 *@<esi>);
// int __usercall sub_8048B0C@<eax>(int@<eax>, int@<edi>);
char sub_8048B5D();
void sub_8048B78();
void sub_8048B7F();
_DWORD sub_8048B88(); // weak
// void __usercall sub_8048B8E(int a1@<ecx>, int a2@<ebp>);
// char __usercall sub_8048BBF@<al>(char *@<esi>);
// char __usercall sub_8048BC5@<al>(char *@<esi>);
// int __usercall sub_8048BD4@<eax>(_BYTE *@<esi>);
// int __usercall sub_8048C29@<eax>(_BYTE *@<esi>);
int __fastcall sub_8048CA2(int, mode_t);
// void __usercall sub_8048CF0(_BYTE *@<edi>, _BYTE *@<esi>);
// void __usercall sub_8048D0C(_BYTE *@<edi>);

//-------------------------------------------------------------------------
// Data declarations

char byte_804805F = '\x15'; // weak
int dword_8048BD0 = 4607813; // weak
struct stat buf; // idb
char byte_8048D79; // weak
char byte_8048E79; // weak
char byte_8048F78[2]; // weak
char *filename; // idb
char byte_8048FAC; // weak
char addr[8192]; // idb
int dword_804AFAD; // weak
_UNKNOWN ufds; // weak
__int16 word_804B3B1; // weak
__int16 word_804B3B3; // weak
int dword_804B3B5; // weak
__int16 word_804B3B9; // weak
__int16 word_804B3BB; // weak


//----- (0804822F) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start()
{
  unsigned __int8 *v0; // esi
  int v1; // eax
  int i; // ebx
  unsigned __int8 v3; // al
  bool v4; // cf
  char v5; // t0
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  unsigned int v11; // [esp-1Ah] [ebp-1Ah]
  char *v12; // [esp-12h] [ebp-12h]
  unsigned __int8 *v13; // [esp-Eh] [ebp-Eh]

  if ( v11 >= 3 )
  {
    filename = v12;
    v0 = v13;
    __asm { int     80h; LINUX - sys_signal }
    v1 = 0;
    for ( i = 0; ; i = v1 + 10 * i )
    {
      v3 = *v0++;
      v4 = v3 < 0x30u;
      LOBYTE(v1) = v3 - 48;
      if ( v4 )
        break;
    }
    v5 = BYTE1(i);
    BYTE1(i) = i;
    LOBYTE(i) = v5;
    v6 = i << 16;
    LOBYTE(v6) = 2;
    *(_DWORD *)byte_8048F78 = v6;
    *(_DWORD *)&byte_8048F78[4] = 0;
    v7 = sys_close(1);
    v8 = sys_close(0);
    v9 = sys_close(2);
    __asm
    {
      int     80h; LINUX - sys_socket
      int     80h; LINUX - sys_setsockopt
    }
  }
  v10 = sys_exit(1);
}
// 8048914: positive sp value 1A has been found
// 8048233: variable 'v11' is possibly undefined
// 804823A: variable 'v12' is possibly undefined
// 8048240: variable 'v13' is possibly undefined
// 804822F: using guessed type void __noreturn start();
// 8048B88: using guessed type _DWORD sub_8048B88();
// 8048E79: using guessed type char byte_8048E79;
// 8048F90: using guessed type int dword_8048F90;
// 8048FAC: using guessed type char byte_8048FAC;

//----- (08048358) --------------------------------------------------------
int __usercall sub_8048358@<eax>(int a1@<ebp>)
{
  int v1; // ecx
  int result; // eax
  int v3; // eax

  ufds = a1;
  dword_804B3B5 = *(unsigned int *)((char *)&buf.__unused4 + 1);
  v1 = 1;
  if ( *(unsigned int *)((char *)&buf.__unused4 + 1) )
    v1 = 2;
  word_804B3B1 = 3;
  word_804B3B9 = 3;
  __asm { int     80h; LINUX - sys_poll }
  if ( v1 != 1 && (word_804B3BB & 3) != 0 )
  {
    byte_8048E79 = 16;
    __asm { int     80h; LINUX - sys_accept }
    v3 = sys_close(*(int *)((char *)&buf.__unused4 + 1));
    result = 0;
    *(unsigned int *)((char *)&buf.__unused4 + 1) = 0;
  }
  else if ( (word_804B3B3 & 3) != 0 )
  {
    if ( sys_read(a1, &dword_804AFAD, 0x400u) - 1 < 0 )
      JUMPOUT(0x80482BE);
    return dword_804AFAD;
  }
  else
  {
    return 0;
  }
  return result;
}
// 80483F0: control flows out of bounds to 80482BE
// 8048E79: using guessed type char byte_8048E79;
// 804AFAD: using guessed type int dword_804AFAD;
// 804B3B1: using guessed type __int16 word_804B3B1;
// 804B3B3: using guessed type __int16 word_804B3B3;
// 804B3B5: using guessed type int dword_804B3B5;
// 804B3B9: using guessed type __int16 word_804B3B9;
// 804B3BB: using guessed type __int16 word_804B3BB;

//----- (08048AB6) --------------------------------------------------------
char __usercall sub_8048AB6@<al>(int a1@<ebx>, unsigned __int8 *a2@<esi>)
{
  bool v2; // cf
  int v3; // eax
  char v4; // dh

  while ( 1 )
  {
    v3 = *a2++;
    v2 = (unsigned __int8)v3 < 0x30u;
    LOBYTE(v3) = v3 - 48;
    if ( v2 )
      break;
    v4 = BYTE1(a1);
    LOWORD(a1) = 10 * (unsigned __int8)a1;
    BYTE1(a1) |= v4;
    a1 += v3;
  }
  return v3;
}

//----- (08048ACC) --------------------------------------------------------
unsigned int __usercall sub_8048ACC@<eax>(unsigned int result@<eax>, int a2@<edx>, int a3@<ecx>, _BYTE *a4@<edi>)
{
  if ( result )
  {
    sub_8048ACC(result / 0xA, result % 0xA, a3, a4);
    goto LABEL_5;
  }
  if ( !a2 )
  {
LABEL_5:
    result = a2 + 48;
    *a4 = a2 + 48;
  }
  return result;
}
// 8048AED: variable 'a2' is possibly undefined

//----- (08048AF6) --------------------------------------------------------
int __usercall sub_8048AF6@<eax>(unsigned __int8 *a1@<esi>)
{
  int v1; // eax
  int i; // ebx
  unsigned __int8 v3; // al
  bool v4; // cf

  v1 = 0;
  for ( i = 0; ; i = v1 + 10 * i )
  {
    v3 = *a1++;
    v4 = v3 < 0x30u;
    LOBYTE(v1) = v3 - 48;
    if ( v4 )
      break;
  }
  return i;
}

//----- (08048B0C) --------------------------------------------------------
int __usercall sub_8048B0C@<eax>(int a1@<eax>, int a2@<edi>)
{
  char *v3; // edi
  int v4; // ecx
  char *v5; // esi
  bool v6; // zf
  char *v7; // edi
  int v9; // eax
  char *v10; // edi
  int v11; // ecx
  int v12; // eax
  int v13; // [esp-24h] [ebp-24h]

  v3 = addr;
  v4 = a1;
  while ( 1 )
  {
    v5 = v3;
    do
    {
      if ( !v4 )
        break;
      v6 = *v3++ == 10;
      --v4;
    }
    while ( !v6 );
    v7 = (char *)(v3 - v5);
    if ( v5[(_DWORD)v7 - 1] != 10 )
      break;
    v9 = 1;
    v13 = v4;
    if ( byte_8048FAC == 2 )
      v9 = 2;
    v10 = &v7[-v9];
    sub_8048B78();
    sub_8048B8E(v11, a2);
    v4 = v13;
    if ( !v13 )
      return a1;
    v3 = &v10[v12 + (_DWORD)v5];
  }
  sub_8048B78();
  return a1;
}
// 8048B0C: could not find valid save-restore pair for edi
// 8048B4C: variable 'v11' is possibly undefined
// 8048B57: variable 'v12' is possibly undefined
// 8048FAC: using guessed type char byte_8048FAC;

//----- (08048B5D) --------------------------------------------------------
char sub_8048B5D()
{
  int v0; // ecx
  int *v1; // edi
  bool v2; // zf
  char result; // al

  v0 = 1024;
  v1 = &dword_804AFAD;
  do
  {
    if ( !v0 )
      break;
    v2 = *(_BYTE *)v1 == 32;
    v1 = (int *)((char *)v1 + 1);
    --v0;
  }
  while ( !v2 );
  result = 13;
  do
  {
    if ( !v0 )
      break;
    v2 = *(_BYTE *)v1 == 13;
    v1 = (int *)((char *)v1 + 1);
    --v0;
  }
  while ( !v2 );
  *((_BYTE *)v1 - 1) = 0;
  return result;
}
// 8048B5D: could not find valid save-restore pair for esi
// 804AFAD: using guessed type int dword_804AFAD;

//----- (08048B78) --------------------------------------------------------
void sub_8048B78()
{
  JUMPOUT(0x8048BA1);
}
// 8048B7D: control flows out of bounds to 8048BA1

//----- (08048B7F) --------------------------------------------------------
void sub_8048B7F()
{
  ++byte_8048D79;
  JUMPOUT(0x8048BA1);
}
// 8048B86: control flows out of bounds to 8048BA1
// 8048D79: using guessed type char byte_8048D79;

//----- (08048B8E) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall sub_8048B8E(int a1@<ecx>, int a2@<ebp>)
{
  int v2; // eax
  char *v3; // esi
  char *v4; // edx
  int v5; // eax

  v2 = 0;
  v3 = &byte_804805F;
  v4 = &byte_804805F;
  do
  {
    LOBYTE(v2) = *v3++;
    v4 += v2;
    --a1;
  }
  while ( a1 );
  v5 = sys_write(a2, v4, (unsigned __int8)*v3);
  if ( !--byte_8048D79 )
    JUMPOUT(0x8048345);
  ++byte_8048D79;
}
// 8048BBA: positive sp value 8 has been found
// 8048BBA: control flows out of bounds to 8048345
// 804805F: using guessed type char byte_804805F;
// 8048D79: using guessed type char byte_8048D79;

//----- (08048BBF) --------------------------------------------------------
char __usercall sub_8048BBF@<al>(char *a1@<esi>)
{
  char result; // al

  do
    result = *a1++;
  while ( result != 10 );
  return result;
}

//----- (08048BC5) --------------------------------------------------------
char __usercall sub_8048BC5@<al>(char *a1@<esi>)
{
  char result; // al

  do
  {
    do
      result = *a1++;
    while ( result == 32 );
  }
  while ( result == 9 );
  return result;
}

//----- (08048BD4) --------------------------------------------------------
int __usercall sub_8048BD4@<eax>(_BYTE *a1@<esi>)
{
  char *i; // esi
  int v3; // ecx
  int v4; // ecx

  for ( i = (char *)buf.st_mtim.tv_sec; ; sub_8048BBF(i) )
  {
    if ( sub_8048BC5(i) != 59 )
    {
      sub_8048CF0(&dword_8048BD0, i);
      if ( !v3 )
      {
        buf.st_mtim.tv_nsec = 0;
        return 19;
      }
      sub_8048CF0(a1, i);
      if ( !v4 )
        break;
    }
  }
  buf.st_mtim.tv_nsec = (int)i;
  return 19;
}
// 8048BF6: variable 'v3' is possibly undefined
// 8048C01: variable 'v4' is possibly undefined
// 8048BD0: using guessed type int dword_8048BD0;

//----- (08048C29) --------------------------------------------------------
int __usercall sub_8048C29@<eax>(_BYTE *a1@<esi>)
{
  _BYTE *tv_nsec; // esi
  int v3; // ecx
  char *v5; // esi
  char *v6; // esi
  unsigned __int8 v7; // al
  const char *v8; // [esp-4h] [ebp-8h]

  LOBYTE(buf.st_ctim.tv_sec) = 0;
  tv_nsec = (_BYTE *)buf.st_mtim.tv_nsec;
  if ( !buf.st_mtim.tv_nsec )
    return 20;
  sub_8048BC5((char *)buf.st_mtim.tv_nsec);
  if ( *tv_nsec != 42 )
  {
    sub_8048CF0(a1, tv_nsec);
    if ( v3 )
      return 20;
  }
  v5 = tv_nsec + 1;
  sub_8048BC5(v5);
  *(__time_t *)((char *)&buf.st_ctim.tv_sec + 1) = sub_8048AF6((unsigned __int8 *)v5);
  v6 = v5 + 1;
  sub_8048BC5(v6);
  v8 = v6;
  do
    v7 = *v6++;
  while ( v7 >= 0x21u );
  *(v6 - 1) = 0;
  if ( sys_chdir(v8) < 0 || sys_chroot(v8) < 0 )
    return 20;
  LOBYTE(buf.st_ctim.tv_sec) = 1;
  return 7;
}
// 8048C50: variable 'v3' is possibly undefined

//----- (08048CA2) --------------------------------------------------------
int __fastcall sub_8048CA2(int a1, mode_t a2)
{
  int v2; // eax
  int v3; // ebx
  int v4; // eax

  v2 = sys_open(filename, 0, a2);
  if ( v2 < 0 )
    JUMPOUT(0x80482BE);
  v3 = v2;
  v4 = sys_newfstat(v2, &buf);
  __asm { int     80h; LINUX - sys_mmap2 }
  buf.st_mtim.tv_sec = 192;
  return sys_close(v3);
}
// 8048CB1: control flows out of bounds to 80482BE
// 8048CA2: could not find valid save-restore pair for ebx

//----- (08048CF0) --------------------------------------------------------
void __usercall sub_8048CF0(_BYTE *a1@<edi>, _BYTE *a2@<esi>)
{
  unsigned int v2; // edx
  unsigned int v3; // ecx

  sub_8048D0C(a1);
  sub_8048D0C(a2);
  if ( v3 < v2 )
    v3 = v2;
  memcmp(a2, a1, v3);
}
// 8048D02: variable 'v3' is possibly undefined
// 8048D02: variable 'v2' is possibly undefined

//----- (08048D0C) --------------------------------------------------------
void __usercall sub_8048D0C(_BYTE *a1@<edi>)
{
  int v1; // ecx

  v1 = 0;
  do
    ++v1;
  while ( *a1++ >= 0x21u );
}

// nfuncs=18 queued=17 decompiled=17 lumina nreq=0 worse=0 better=0
// ALL OK, 17 function(s) have been successfully decompiled
