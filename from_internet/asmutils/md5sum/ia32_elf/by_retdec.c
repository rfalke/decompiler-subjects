//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2);
int32_t function_80482b3(void);
int32_t function_804831c(void);
int32_t function_80483b8(void);
int32_t function_804841f(void);

// --------------------- Global Variables ---------------------

int32_t g2 = -0x2c0826df; // 0x80482e2
int32_t g3 = 0; // 0x8048483
int32_t g4 = 0; // 0x8048487
int32_t g5 = 0; // 0x804848b
int32_t g6 = 0; // 0x804848f
int32_t g7 = 0; // 0x8048493
int32_t g8 = 0; // 0x8048497
char * g9; // 0x804849b
int32_t g10 = 0; // 0x80484d3
int32_t g11 = 0; // 0x80484d7
char * g12; // 0x804a50f
int32_t * g1 = &g2; // 0x8048123

// ------------------------ Functions -------------------------

// Address range: 0x804804c - 0x8048123
int32_t entry_point(int32_t a1, int32_t a2) {
    // 0x804804c
    function_80482b3();
    int32_t v1; // 0x804804c
    int32_t v2 = &v1; // 0x8048057
    int32_t v3 = v2; // 0x8048058
    if (a1 != 1) {
        int32_t v4; // 0x804804c
        int32_t v5; // 0x804804c
        if (v5 == 0) {
            // 0x804805f
            v1 = 1;
            __asm_int(128);
            v4 = 0;
        }
        // 0x8048066
        g12 = (char *)v4;
        v1 = 5;
        __asm_int(128);
        v3 = v2 + 4;
    }
    // 0x804807c
    while (true) {
        // 0x804807c
        *(int32_t *)(v3 - 4) = 3;
        __asm_int(128);
        function_80483b8();
    }
}

// Address range: 0x80482b3 - 0x80482e2
int32_t function_80482b3(void) {
    // 0x80482b3
    g3 = 0x67452301;
    *(int32_t *)((int32_t)&g3 + 4) = -0x10325477;
    *(int32_t *)((int32_t)&g3 + 8) = -0x67452302;
    *(int32_t *)((int32_t)&g3 + 12) = 0x10325476;
    *(int32_t *)((int32_t)&g3 + 16) = 0;
    *(int32_t *)((int32_t)&g3 + 20) = 0;
    __asm_rep_stosd_memset((char *)&g9, 0, 16);
    int32_t result; // 0x80482b3
    return result;
}

// Address range: 0x804831c - 0x80483b8
int32_t function_804831c(void) {
    int32_t v1 = *(int32_t *)((int32_t)&g3 + 4); // 0x804832c
    int32_t v2 = *(int32_t *)((int32_t)&g3 + 8); // 0x8048330
    int32_t v3 = *(int32_t *)((int32_t)&g3 + 12); // 0x8048334
    int32_t v4; // bp-52, 0x804831c
    int32_t v5 = &v4; // 0x804833f
    int32_t * v6 = (int32_t *)(v5 - 4); // 0x8048340
    int32_t v7 = (int32_t)&g1; // 0x804833f
    *v6 = 4;
    v4 = *(int32_t *)v7;
    *(int32_t *)(v5 - 8) = 1;
    int32_t v8 = *v6 - 1; // 0x8048395
    v7 += 4;
    while (v8 != 0) {
        // 0x8048340
        *v6 = v8;
        v4 = *(int32_t *)v7;
        *(int32_t *)(v5 - 8) = 1;
        v8 = *v6 - 1;
        v7 += 4;
    }
    // 0x8048397
    g3 *= 2;
    g4 += v1;
    g5 += v2;
    g6 += v3;
    return *(int32_t *)(v5 + 48);
}

// Address range: 0x80483b8 - 0x804841f
int32_t function_80483b8(void) {
    uint32_t v1 = g7; // 0x80483be
    int32_t v2; // 0x80483b8
    int32_t v3 = v1 + 8 * v2; // 0x80483c0
    g7 = v3;
    int32_t v4 = g8;
    int32_t v5 = v4; // 0x80483c7
    if (v3 < v1) {
        // 0x80483c9
        v5 = v4 + 1;
        g8 = v5;
    }
    // 0x80483cc
    int32_t v6; // bp-32, 0x80483b8
    int32_t v7 = &v6; // 0x80483b8
    g8 = v5 + v2 / 0x20000000;
    uint32_t v8 = v1 / 8 % 64; // 0x80483d8
    int32_t v9; // 0x80483b8
    int32_t v10; // 0x80483b8
    int32_t v11; // 0x80483b8
    if (v8 == 0) {
        goto lab_0x80483fe;
    } else {
        int32_t v12 = v8 + (int32_t)&g7 + 8; // 0x80483dd
        int32_t v13 = 64 - v8; // 0x80483e4
        v10 = v12;
        if (v2 < v13) {
            goto lab_0x804841b;
        } else {
            // 0x80483ec
            __asm_rep_movsb_memcpy((char *)v12, (char *)v2, v13);
            function_804831c();
            v9 = v2 - v13;
            v11 = (int32_t)&g7 + 72;
            goto lab_0x80483fe;
        }
    }
  lab_0x80483fe:;
    int32_t v14 = v9; // 0x8048406
    int32_t v15 = v11; // 0x8048406
    v10 = (int32_t)&g9;
    if (v9 >= 64) {
        int32_t * v16 = (int32_t *)(v7 - 4); // 0x8048408
        int32_t * v17 = (int32_t *)(v7 - 8); // 0x8048409
        int32_t v18 = (int32_t)&g9; // 0x804840f
        *v16 = v9;
        *v17 = v18;
        *(int32_t *)(v7 - 12) = 16;
        __asm_rep_movsd_memcpy((char *)v18, (char *)v11, 16);
        int32_t v19 = v18 + 64; // 0x804840d
        v18 = *v17;
        function_804831c();
        int32_t v20 = *v16 - 64; // 0x8048416
        v14 = v20;
        v15 = v19;
        v10 = v18;
        while (v20 >= 64) {
            // 0x8048408
            *v16 = v20;
            *v17 = v18;
            *(int32_t *)(v7 - 12) = 16;
            __asm_rep_movsd_memcpy((char *)v18, (char *)v19, 16);
            v19 = v18 + 64;
            v18 = *v17;
            function_804831c();
            v20 = *v16 - 64;
            v14 = v20;
            v15 = v19;
            v10 = v18;
        }
    }
    goto lab_0x804841b;
  lab_0x804841b:
    // 0x804841b
    __asm_rep_movsb_memcpy((char *)v10, (char *)v15, v14);
    return *(int32_t *)(v7 + 28);
}

// Address range: 0x804841f - 0x8048483
int32_t function_804841f(void) {
    uint32_t v1 = g7 / 8 % 64; // 0x804842b
    *(char *)(v1 + (int32_t)&g7 + 8) = -128;
    uint32_t v2 = v1 ^ 63; // 0x8048438
    int32_t v3 = v1 + (int32_t)&g7 + 9; // 0x804843c
    if (v2 < 8) {
        // 0x8048445
        __asm_rep_stosb_memset((char *)v3, 0, v2);
        int32_t v4 = function_804831c(); // 0x804844e
        __asm_rep_stosd_memset((char *)&g9, v4, 14);
    } else {
        // 0x804845a
        __asm_rep_stosb_memset((char *)v3, 0, v2 - 8);
    }
    // 0x8048461
    g10 = g7;
    g11 = *(int32_t *)((int32_t)&g7 + 4);
    function_804831c();
    int32_t result; // 0x804841f
    __asm_rep_movsd_memcpy((char *)result, (char *)((int32_t)&g7 - 16), 4);
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: elfcrypt (1.0)
// Detected functions: 5

