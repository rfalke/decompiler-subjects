// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Register Eq_2 edx, Stack word32 dwArg00)
void fn0804804C(Eq_2 edx, word32 dwArg00)
{
	ptr32 fp;
	char * ebx_18;
	Eq_2 eax_30;
	struct Eq_7 * esp_14 = fp + 8;
	Eq_2 ebx_201 = 0x00;
	if (dwArg00 == 0x01)
	{
l08048064:
		word32 ebp_187 = 0x00;
		do
		{
			struct Eq_48 * esp_45 = esp_14 - 4;
			esp_45->t0000.u0 = 0x33;
			struct Eq_63 * edi_217 = g_a80480F0;
			Eq_2 ecx_218;
			for (ecx_218 = esp_45->t0000.u0; ecx_218 != 0x00; --ecx_218)
			{
				edi_217->b0000 = 0x20;
				++edi_217;
			}
			esp_45->t0000.u0 = 0x10;
			edx.u0 = esp_45->t0000.u0;
			esp_45->t0000.u0 = 0x03;
			Eq_2 eax_63 = sys_read(ebx_201, edi_217, edx);
			esp_14 = (struct Eq_7 *) ((char *) &esp_45->t0000 + 4);
			eax_30 = eax_63;
			if (eax_63 < 0x00)
				goto l080480D0;
			if (eax_63 == 0x00)
				break;
			esp_45->t0000.u0 = (size_t) eax_63;
			esp_45->ptrFFFFFFFC = edi_217;
			esp_45->tFFFFFFF8.u0 = (size_t) edx;
			esp_45->tFFFFFFF4.u0 = (size_t) ebx_201;
			esp_45->ptrFFFFFFF0 = (char *) &esp_45->t0000 + 4;
			esp_45->dwFFFFFFEC = ebp_187;
			esp_45->dwFFFFFFE8 = 0x080480F0;
			esp_45->ptrFFFFFFE4 = edi_217;
			esp_45->dwFFFFFFE0 = ebp_187;
			byte * edi_118;
			ptr32 ecx_117 = fn080480D8(ebp_187, 0x080480D8, g_a80480F0, out edi_118);
			struct Eq_138 * esp_119 = (struct Eq_138 *) <invalid>;
			word32 edx_132;
			<anonymous> * ecx_131;
			(*((word32) ecx_117 + 2))();
			*edi_118 = 0x3A;
			struct Eq_63 * esi_109 = edi_217;
			Eq_2 ebp_112 = eax_63;
			do
			{
				char al_143 = esi_109->b0000;
				++esi_109;
				if (al_143 == 0x7F || al_143 < 0x20)
					esi_109->bFFFFFFFF = 0x2E;
				word32 edx_162;
				ecx_131();
				--ebp_112;
			} while (ebp_112 != 0x00);
			esi_109->b0000 = 0x0A;
			Eq_2 eax_185 = esp_119->t0020.u0;
			char * esi_174 = esp_119->ptr0008;
			ebp_187 = (word32) eax_185 + esp_119->dw000C;
			esp_119->t0020.u0 = esp_119->t0014.u0;
			esp_119->dw001C = 0x01;
			uint32 ebx_194 = esp_119->dw001C;
			esp_119->dw001C = 0x04;
			int32 eax_200 = sys_write(ebx_194, esi_174, (word32) eax_185 + 52);
			edx = (word32) eax_185 + 52;
			ebx_201.u0 = esp_119->t0020.u0;
			esp_14 = (struct Eq_7 *) ((char *) &esp_119->t0020 + 4);
		} while (eax_200 > 0x00);
		word32 * esp_209 = esp_14 - 4;
		*esp_209 = 0x06;
		sys_close(ebx_201);
		esp_14 = (struct Eq_7 *) (esp_209 + 1);
		goto l08048053;
	}
	else
	{
l08048053:
		char * ebx_16 = esp_14->dw0000;
		++esp_14;
		ebx_18 = ebx_16;
		if (ebx_16 != null)
		{
			esp_14->dwFFFFFFFC = 0x05;
			Eq_2 eax_29 = sys_open(ebx_16, 0x00, edx);
			eax_30 = eax_29;
			if (eax_29 >= 0x00)
			{
				ebx_201 = eax_29;
				goto l08048064;
			}
l080480D0:
			ebx_18 = -eax_30;
		}
		esp_14->dwFFFFFFFC = 0x01;
		sys_exit(ebx_18);
	}
}

// 080480D8: Register word32 fn080480D8(Register word32 eax, Register word32 ecx, Register (ptr32 byte) edi, Register out ptr32 ediOut)
// Called from:
//      fn0804804C
word32 fn080480D8(word32 eax, word32 ecx, byte * edi, ptr32 & ediOut)
{
	byte * edi_19;
	cu8 ah_17 = fn080480E4(SLICE(__aam((byte) __rol<word32,byte>(eax, 0x08)), byte, 8), edi, out edi_19);
	ptr32 edi_26;
	fn080480E4(ah_17, edi_19, out edi_26);
	ediOut = edi_26;
	return ecx + 0x01;
}

// 080480E4: Register cu8 fn080480E4(Register cu8 ah, Register (ptr32 byte) edi, Register out ptr32 ediOut)
// Called from:
//      fn080480D8
cu8 fn080480E4(cu8 ah, byte * edi, ptr32 & ediOut)
{
	cu8 al;
	cu8 al_11 = ah;
	if (ah > 0x09)
		al_11 = ah + 0x07;
	*edi = al_11 + 0x30;
	ediOut = edi + 1;
	return al;
}

byte g_a80480F0[] = // 080480F0
	{
	};
