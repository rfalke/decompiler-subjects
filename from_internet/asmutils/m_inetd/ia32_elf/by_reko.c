// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Register word32 ebp, Stack int32 dwArg00, Stack (ptr32 byte) dwArg08, Stack (ptr32 byte) dwArg0C)
void fn0804804C(word32 ebp, int32 dwArg00, byte * dwArg08, byte * dwArg0C)
{
	byte al_11 = (byte) dwArg00;
	if (dwArg00 >= 0x05)
	{
		g_b80492A1 = al_11;
		g_dw8049299 = 134517361;
	}
	g_dw8049291 = fn08048236(dwArg08);
	fn08048236(dwArg0C);
	__syscall(0x80);
	__syscall(0x80);
}

// 0804821E: Register uint32 fn0804821E(Register uint32 eax, Register (ptr32 byte) edi, Register out (ptr32 byte) ediOut)
// Called from:
//      fn0804804C
uint32 fn0804821E(uint32 eax, byte * edi, byte & ediOut)
{
	word32 * esp_17 = fp;
	word32 ecx_22 = 0x00;
	do
	{
		uint64 edx_eax_10 = (uint64) eax;
		uint32 edx_13 = (uint32) (edx_eax_10 % 0x0A);
		esp_17 -= 4;
		*esp_17 = SEQ(SLICE(edx_13, word24, 8), (byte) edx_13 + 0x30);
		eax = (uint32) (edx_eax_10 /u 0x0A);
		++ecx_22;
	} while (eax != 0x00);
	do
	{
		*edi = (byte) dwLoc04;
		++edi;
		--ecx_22;
	} while (ecx_22 != 0x00);
	ediOut = edi;
	return dwLoc04;
}

// 08048236: Register uint32 fn08048236(Register (ptr32 byte) ebp)
// Called from:
//      fn0804804C
uint32 fn08048236(byte * ebp)
{
	uint32 eax_21 = 0x00;
	while (true)
	{
		char bl_13 = *ebp;
		++ebp;
		if (bl_13 < 0x30)
			break;
		uint32 ebx_25 = (uint32) (bl_13 - 0x30);
		if (bl_13 > 0x39)
			return eax_21;
		eax_21 = eax_21 * 0x0A + ebx_25;
	}
	return eax_21;
}

// 08048252: void fn08048252(Register byte al, Register (ptr32 byte) edi)
// Called from:
//      fn08048253
void fn08048252(byte al, byte * edi)
{
	*edi = al;
	fn08048253(esi);
}

// 08048253: void fn08048253(Register (ptr32 byte) esi)
// Called from:
//      fn0804804C
//      fn08048252
void fn08048253(byte * esi)
{
	if (*esi == 0x00)
		return;
	fn08048252(al, edi);
}

word32 g_dw8049291 = 0x00; // 08049291
word32 g_dw8049299 = 0x00; // 08049299
byte g_b80492A1 = 0x00; // 080492A1
