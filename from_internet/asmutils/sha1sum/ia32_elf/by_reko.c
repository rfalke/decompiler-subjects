// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C()
void fn0804804C()
{
	fn08048172();
	struct Eq_5 * esp_15 = fp + 8;
	while (true)
	{
		do
		{
			byte * ebx_18 = esp_15->dw0000;
			struct Eq_5 * esp_19 = esp_15 + 1;
			if (ebx_18 == null)
			{
				esp_19->ptrFFFFFFFC = (struct Eq_12 *) 0x01;
				__syscall(0x80);
			}
			g_ptr80482F3 = ebx_18;
			esp_19->ptrFFFFFFFC = (struct Eq_12 *) 0x05;
			struct Eq_12 * eax_33 = esp_19->ptrFFFFFFFC;
			__syscall(0x80);
			esp_15 = esp_19;
		} while (eax_33 < null);
		while (true)
		{
			fn08048283();
			esp_19->ptrFFFFFFFC = (struct Eq_12 *) 0x40;
			esp_19->ptrFFFFFFFC = (struct Eq_12 *) 0x03;
			struct Eq_12 * eax_56 = esp_19->ptrFFFFFFFC;
			__syscall(0x80);
			esp_15 = esp_19;
			if (eax_56 < null)
				break;
			up32 ecx_61;
			struct Eq_12 * eax_64 = fn080482B3(eax_56, out ecx_61);
			if (ecx_61 < 0x40)
			{
				ui32 edx_72 = g_dw804830F;
				g_dw804835F = __shld(g_dw804830B, edx_72, 0x03);
				g_ptr8048363 = edx_72 << 0x03;
				fn0804819A();
				esp_19->ptrFFFFFFFC = (struct Eq_12 *) 0x05;
				word32 * esi_83 = g_a80482F7;
				struct Eq_12 * ecx_107 = esp_19->ptrFFFFFFFC;
				struct Eq_5 * esp_106 = esp_19;
				do
				{
					word32 eax_90 = *esi_83;
					esp_106->ptrFFFFFFFC = ecx_107;
					fn08048109(eax_90);
					struct Eq_119 * esp_100 = (struct Eq_119 *) <invalid>;
					byte * ecx_105 = esp_100->ptr0000;
					++esi_83;
					esp_106 = (struct Eq_5 *) &esp_100->ptr0004;
					ecx_107 = ecx_105 - 0x01;
				} while (ecx_105 != (byte *) 0x01);
				esp_100->ptr0000 = (byte *) 0x20;
				fn0804812A(esp_100->ptr0000);
				esp_100->ptr0004 = (byte *) 0x20;
				fn0804812A(esp_100->ptr0004);
				fn08048172();
				byte * esi_132 = g_ptr80482F3;
				esp_100->ptr0008 = esi_132;
				do
				{
					esi_132 = esi_178 + 1;
					esi_178 = esi_132;
				} while (*esi_178 != 0x00);
				esp_100->ptr0008 = (byte *) 0x01;
				esp_100->ptr0008 = (byte *) 0x04;
				__syscall(0x80);
				esp_100->ptr0008 = (byte *) 0x0A;
				fn0804812A(esp_100->ptr0008);
				esp_15 = (struct Eq_5 *) ((char *) &esp_100->ptr0008 + 8);
				break;
			}
			word32 ecx_177;
			fn080482B3(eax_64, out ecx_177);
		}
	}
}

// 08048109: void fn08048109(Register word32 eax)
// Called from:
//      fn0804804C
void fn08048109(word32 eax)
{
	struct Eq_119 * edx_15 = (uint32) ((uint64) eax % 0x10);
	fn08048119(edx_15);
}

// 0804810F: void fn0804810F(Register word32 eax, Register ui32 ecx, Register word32 ebx)
// Called from:
//      fn08048119
void fn0804810F(word32 eax, ui32 ecx, word32 ebx)
{
	struct Eq_119 * edx_8 = (uint32) ((uint64) eax % ecx);
	if (ebx == 0x01)
		fn0804811E(edx_8);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		struct Eq_119 * stackArg0 = (struct Eq_119 *) <invalid>;
		fn08048119(stackArg0);
	}
}

// 08048119: void fn08048119(Stack (ptr32 Eq_119) dwArg00)
// Called from:
//      fn08048109
//      fn0804810F
void fn08048119(struct Eq_119 * dwArg00)
{
	fn0804810F(eax, ecx, ebx);
	fn0804811E(dwArg00);
}

// 0804811E: void fn0804811E(Stack (ptr32 Eq_119) dwArg00)
// Called from:
//      fn08048109
//      fn0804810F
//      fn08048119
void fn0804811E(struct Eq_119 * dwArg00)
{
	if (dwArg00 <= (struct Eq_119 *) 0x09)
		fn0804812A((char *) &dwArg00->ptr0008 + 40);
	else
		fn0804812A((char *) &dwArg00->ptr0008 + 79);
}

// 0804812A: void fn0804812A(Register (ptr32 byte) edx)
// Called from:
//      fn0804804C
//      fn0804811E
void fn0804812A(byte * edx)
{
	g_ptr8048363 = edx;
	__syscall(0x80);
}

// 08048141: Register word32 fn08048141(Register (ptr32 Eq_238) edi, Register out ptr32 edxOut, Register out Eq_240 ebxOut)
// Called from:
//      fn0804814B
//      fn08048157
//      fn08048161
word32 fn08048141(struct Eq_238 * edi, ptr32 & edxOut, union Eq_240 & ebxOut)
{
	Eq_240 ebx_5 = edi->tFFFFFFF0;
	word32 ecx_6 = edi->dwFFFFFFF4;
	edxOut = edi->ptrFFFFFFF8;
	ebxOut = ebx_5;
	return ecx_6;
}

// 0804814B: Register ui32 fn0804814B(Register (ptr32 Eq_238) edi)
// Called from:
//      fn0804819A
ui32 fn0804814B(struct Eq_238 * edi)
{
	ui32 ebx_4;
	word32 edx_6;
	return edx_6 ^ ebx_4 & (fn08048141(edi, out edx_6, out ebx_4) ^ edx_6);
}

// 08048157: Register ui32 fn08048157(Register (ptr32 Eq_238) edi)
// Called from:
//      fn0804819A
ui32 fn08048157(struct Eq_238 * edi)
{
	word32 ebx_4;
	word32 edx_6;
	return edx_6 ^ fn08048141(edi, out edx_6, out ebx_4) ^ ebx_4;
}

// 08048161: Register ui32 fn08048161(Register (ptr32 Eq_238) edi)
// Called from:
//      fn0804819A
ui32 fn08048161(struct Eq_238 * edi)
{
	ui32 ebx_4;
	ui32 edx_6;
	ui32 ecx_5 = fn08048141(edi, out edx_6, out ebx_4);
	return edx_6 & (ebx_4 | ecx_5) | ecx_5 & edi->tFFFFFFF0;
}

// 08048172: void fn08048172()
// Called from:
//      fn0804804C
void fn08048172()
{
	g_a80482F7[0] = 0x67452301;
	g_dw80482FB = 4023233417;
	g_dw80482FF = 2562383102;
	g_dw8048303 = 271733878;
	g_dw8048307 = 3285377520;
	g_dw804830B = 0x00;
	g_dw804830F = 0x00;
}

// 0804819A: void fn0804819A()
// Called from:
//      fn0804804C
//      fn080482B3
void fn0804819A()
{
	word32 * edi_187 = g_a8048313;
	word32 * esi_184 = g_a80482F7;
	word32 ecx_191;
	for (ecx_191 = 0x05; ecx_191 != 0x00; --ecx_191)
	{
		*edi_187 = *esi_184;
		++esi_184;
		++edi_187;
	}
	uint32 ebx_150 = 0x00;
	do
	{
		ui32 ecx_40 = ebx_240 & 0x0F;
		if (ebx_240 >= 0x10)
			g_a8048327[ecx_40 * 0x04] = __rol<word32,byte>(g_a8048327[((ebx_240 & 0x0F) + 0x0D & 0x0F) * 0x04] ^ g_a8048327[(ecx_40 + 0x08 & 0x0F) * 0x04] ^ g_a8048327[(ecx_40 + 0x02 & 0x0F) * 0x04] ^ g_a8048327[ecx_40 * 0x04], 0x01);
		word32 edx_101;
		word32 eax_106;
		word32 eax_74 = __rol<word32,byte>(g_a8048313[0], 0x05) + g_dw8048323 + g_a8048327[ecx_40 * 0x04];
		if (ebx_240 >= 0x3C)
		{
			eax_106 = eax_74 + 0xCA62C1D6;
			edx_101 = fn08048157(g_a8048327);
		}
		else if (ebx_240 >= 0x28)
		{
			eax_106 = eax_74 + 2400959708;
			edx_101 = fn08048161(g_a8048327);
		}
		else if (ebx_240 >= 0x14)
		{
			eax_106 = eax_74 + 1859775393;
			edx_101 = fn08048157(g_a8048327);
		}
		else
		{
			eax_106 = eax_74 + 0x5A827999;
			edx_101 = fn0804814B(g_a8048327);
		}
		g_dw8048323 = g_dw804831F;
		g_dw804831F = g_dw804831B;
		g_dw804831B = __rol<word32,byte>(g_dw8048317, 0x1E);
		g_dw8048317 = g_a8048313[0];
		g_a8048313[0] = eax_106 + edx_101;
		ebx_150 = ebx_240 + 0x01;
		ebx_240 = ebx_150;
	} while (ebx_240 < 0x4F);
	g_a80482F7[0] += g_a8048313[0];
	g_dw80482FB += g_dw8048317;
	g_dw80482FF += g_dw804831B;
	g_dw8048303 += g_dw804831F;
	g_dw8048307 += g_dw8048323;
}

// 08048283: Register word32 fn08048283()
// Called from:
//      fn0804804C
//      fn080482B3
word32 fn08048283()
{
	word32 * edi_13 = g_a8048367;
	word32 ecx_11;
	for (ecx_11 = 0x10; ecx_11 != 0x00; --ecx_11)
	{
		*edi_13 = 0x00;
		++edi_13;
	}
	return 0x00;
}

// 08048290: Register (ptr32 word32) fn08048290()
// Called from:
//      fn0804829F
//      fn080482B3
word32 * fn08048290()
{
	word32 * edi_20 = g_a8048327;
	word32 ecx_12;
	for (ecx_12 = 0x10; ecx_12 != 0x00; --ecx_12)
	{
		*edi_20 = 0x00;
		++edi_20;
	}
	return edi_20;
}

// 0804829F: Register (ptr32 word32) fn0804829F(Register (ptr32 word32) esi)
// Called from:
//      fn080482B3
word32 * fn0804829F(word32 * esi)
{
	word32 * edi_23 = fn08048290() - 0x40;
	word32 ecx_13;
	for (ecx_13 = 0x10; ecx_13 != 0x00; --ecx_13)
	{
		*edi_23 = __bswap(*esi);
		++esi;
		++edi_23;
	}
	return esi;
}

// 080482B3: Register (ptr32 Eq_12) fn080482B3(Register (ptr32 Eq_12) eax, Register out (ptr32 Eq_12) ecxOut)
// Called from:
//      fn0804804C
struct Eq_12 * fn080482B3(struct Eq_12 * eax, struct Eq_12 & ecxOut)
{
	g_dw804830F = eax + g_dw804830F / 0x08048368;
	eax->b8048367 = 0x80;
	word32 * esi_13 = g_a8048367;
	eax_21 = eax;
	do
	{
		struct Eq_12 * eax_21;
		esi_13 = fn0804829F(esi_13);
		if (eax_21 < (struct Eq_12 *) 0x40)
		{
			if (eax_21 < (struct Eq_12 *) 0x38)
				goto l080482F1;
			fn0804819A();
			break;
		}
		fn0804819A();
		eax_21 -= 0x40;
	} while (eax_21 != null);
	eax_21 = fn08048283();
	fn08048290();
l080482F1:
	ecxOut = eax;
	return eax_21;
}

byte * g_ptr80482F3 = null; // 080482F3
word32 g_a80482F7[] = // 080482F7
	{
	};
word32 g_dw80482FB = 0x00; // 080482FB
word32 g_dw80482FF = 0x00; // 080482FF
word32 g_dw8048303 = 0x00; // 08048303
word32 g_dw8048307 = 0x00; // 08048307
word32 g_dw804830B = 0x00; // 0804830B
ui32 g_dw804830F = 0x00; // 0804830F
ui32 g_a8048313[] = // 08048313
	{
	};
ui32 g_dw8048317 = 0x00; // 08048317
word32 g_dw804831B = 0x00; // 0804831B
word32 g_dw804831F = 0x00; // 0804831F
word32 g_dw8048323 = 0x00; // 08048323
word32 g_a8048327[] = // 08048327
	{
	};
word32 g_dw804835F = 0x00; // 0804835F
byte * g_ptr8048363 = null; // 08048363
word32 g_a8048367[] = // 08048367
	{
	};
