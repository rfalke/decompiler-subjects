// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Register uint24 ebx_24_8)
void fn0804804C(uint24 ebx_24_8)
{
	ptr32 fp;
	struct Eq_4 * esp_148 = fp + 8;
	byte ah_259 = 0x00;
	byte al_256 = 0x00;
	while (true)
	{
		int32 ebx_195;
		struct Eq_14 * ebp_17 = esp_148->dw0000;
		++esp_148;
		if (ebp_17 == null || ebp_17 == null)
			break;
		switch (ebp_17->b0000)
		{
		case 0x732D:
		case 25645:
			++al_256;
			continue;
		default:
			g_b804824D = ah_259;
			g_b804824E = al_256;
			struct Eq_33 * ebx_124 = null;
			byte bl_261 = 0x00;
			if (al_256 != 0x00)
			{
				do
				{
					ebx_265 = SEQ(ebx_24_8_264, bl_126 + 0x01);
					ebx_124->b8048251 = al_256;
					byte bl_126 = (byte) ebx_124;
					word24 ebx_24_8_264 = SLICE(ebx_124, word24, 8);
					ebx_124 = ebx_265;
				} while (bl_126 != ~0x00);
				esp_148->dwFFFFFFFC = 0x08048351;
				byte bh_277;
				word32 eax_135 = fn08048172(ebp_17, g_a8048351, out bh_277);
				byte * esi_147 = esp_148->dwFFFFFFFC;
				word32 eax_151 = eax_135;
				bool v44_272 = eax_135 == 0x00;
				while (!v44_272)
				{
					g_a8048251[(uint32) *esi_147] = 0x00;
					--eax_151;
					++esi_147;
					v44_272 = eax_151 == 0x00;
				}
			}
			else
			{
				do
				{
					g_a8048251[(uint32) bl_261] = bl_261;
					++bl_261;
				} while (bl_261 != 0x00);
				byte bh_61;
				word32 eax_55 = fn08048172(ebp_17, g_a8048351, out bh_61);
				struct Eq_14 * ebp_68 = esp_148->dw0000;
				esp_148->dw0000 = eax_55;
				ebx_24_8 = (uint24) bh_61;
				if (ebp_68 == null)
					break;
				byte bh_84;
				word32 eax_78 = fn08048172(ebp_68, g_a8048451, out bh_84);
				++esp_148;
				ebx_24_8 = (uint24) bh_84;
				if (esp_148->dw0000 != eax_78)
					break;
				word32 eax_119 = eax_78;
				if (eax_78 != 0x00)
				{
					byte * esi_103 = g_a8048351;
					byte * edi_104 = g_a8048451;
					do
					{
						g_a8048251[(uint32) *esi_103] = *edi_104;
						++esi_103;
						++edi_104;
						--eax_119;
					} while (eax_119 != 0x00);
				}
			}
			uint32 * esp_163 = esp_148 - 4;
			*esp_163 = 0x01;
			uint32 ebp_165 = *esp_163;
			while (true)
			{
				size_t * esp_168 = esp_148 - 4;
				*esp_168 = (uint32) 0x01;
				Eq_202 edx_170 = *esp_168;
				*esp_168 = (uint32) 0x03;
				esp_148 = (struct Eq_4 *) (esp_168 + 1);
				if (sys_read(0x00, &g_b8048250, edx_170) == 0x00)
					break;
				byte al_217;
				if (g_b804824E == 0x00)
					al_217 = g_a8048251[(uint32) g_b8048250];
				else
				{
					byte bl_208 = g_b8048250;
					if (g_a8048251[(uint32) bl_208] == 0x00)
						continue;
					al_217 = bl_208;
				}
				if (g_b804824D == 0x00 || al_217 != g_b804824F)
				{
					g_b804824F = al_217;
					*esp_168 = (uint32) 0x01;
					Eq_202 edx_233 = *esp_168;
					*esp_168 = (uint32) 0x04;
					sys_write(ebp_165, &g_b804824F, edx_233);
				}
			}
			ebx_195 = 0x00;
			goto l0804816D;
		}
		++ah_259;
	}
	ebx_195 = SEQ(ebx_24_8, 0x01);
l0804816D:
	esp_148->dwFFFFFFFC = 0x01;
	sys_exit(ebx_195);
}

// 08048172: Register word32 fn08048172(Register (ptr32 Eq_14) ebp, Register (ptr32 byte) esi, Register out Eq_87 bhOut)
// Called from:
//      fn0804804C
word32 fn08048172(struct Eq_14 * ebp, byte * esi, union Eq_87 & bhOut)
{
	Eq_87 bh;
	word32 eax_19 = 0x00;
	byte * edi_12 = &g_b8048550;
	word32 ecx_160 = 0x0101;
	while (true)
	{
		Eq_265 dl_15 = ebp->b0000;
		++edi_12;
		ebp = &ebp->b0000 + 1;
		++eax_19;
		--ecx_160;
		if (ecx_160 == 0x00 || dl_15 == 0x00)
			break;
		if (dl_15 == 0x5C)
		{
			ebp = &ebp->b0000 + 1;
			if (dl_15 == 0x00)
				break;
			byte dh_109;
			if (dl_15 != 110)
			{
				if (dl_15 != 114)
				{
					if (dl_15 != 116)
					{
						if (dl_15 != 0x62)
						{
							if (dl_15 != 0x61)
							{
								byte dl_122;
								if (!fn0804823D(dl_15, out dl_122))
								{
									dh_109 = dl_122;
									byte dl_129;
									if (!fn0804823A(&ebp->b0000 + 1, out dl_129))
									{
										ebp = &ebp->b0000 + 2;
										dh_109 = dl_122 << 0x03 | dl_129;
										byte dl_140;
										if (!fn0804823A(&ebp->b0000 + 2, out dl_140))
										{
											++ebp;
											dh_109 = dh_109 << 0x03 | dl_140;
										}
									}
								}
								else
									dh_109 = dl_122;
							}
							else
								dh_109 = 0x07;
						}
						else
							dh_109 = 0x08;
					}
					else
						dh_109 = 0x09;
				}
				else
					dh_109 = 0x0D;
			}
			else
				dh_109 = 0x0A;
			*edi_12 = dh_109;
			continue;
		}
		*edi_12 = (byte) dl_15;
	}
	struct Eq_258 * edi_162 = &g_t8048551;
	word32 ecx_100 = eax_19;
	word32 eax_103 = 0x00;
	word24 edx_24_8_173 = 0x01;
	do
	{
		word32 edx_177;
		byte dl_53 = edi_162->b0000;
		++edi_162;
		if (dl_53 == 0x5B && edi_162[1] == 0x2D)
		{
			edx_177 = SEQ(edx_24_8_173, dl_53);
			if (edi_162[3] != 0x5D)
				goto l0804822F;
			Eq_87 bl_76 = edi_162->b0000;
			bh = edi_162[2];
			edi_162 += 4;
			if (bl_76 > bh)
			{
				bh = bl_76;
				bl_76 = bh;
			}
			do
			{
				*esi = (byte) bl_76;
				++eax_103;
				++esi;
				--edx_177;
				if (edx_177 == 0x00)
					goto l08048238;
				bl_76 = (byte) bl_76.u0 + 1;
			} while (bl_76 <= bh);
		}
		else
		{
l0804822F:
			*esi = dl_53;
			word32 edx_67 = SEQ(edx_24_8_173, dl_53);
			word24 edx_24_8_176 = SLICE(edx_67 - 0x01, word24, 8);
			if (edx_67 == 0x01)
				break;
			++eax_103;
			++esi;
			edx_177 = SEQ(edx_24_8_176, dl_53 - 0x01);
		}
		edx_24_8_173 = SLICE(edx_177, word24, 8);
		--ecx_100;
	} while (ecx_100 != 0x00);
l08048238:
	bhOut = bh;
	return eax_103 - 0x01;
}

// 0804823A: FlagGroup bool fn0804823A(Register (ptr32 Eq_265) ebp, Register out Eq_361 dlOut)
// Called from:
//      fn08048172
bool fn0804823A(union Eq_265 * ebp, union Eq_361 & dlOut)
{
	Eq_265 dl_6 = ebp->u0;
	Eq_361 dl_7;
	bool C_9 = fn0804823D(dl_6, out dl_7);
	dlOut = dl_7;
	return C_9;
}

// 0804823D: FlagGroup bool fn0804823D(Register Eq_265 dl, Register out Eq_265 dlOut)
// Called from:
//      fn08048172
//      fn0804823A
bool fn0804823D(Eq_265 dl, union Eq_265 & dlOut)
{
	if (dl < 0x30 || dl > 55)
	{
		dlOut = dl;
		return true;
	}
	else
	{
		dlOut = dl - 0x30;
		return SLICE(cond(dl - 0x30), bool, 1);
	}
}

byte g_b804824D = 0x00; // 0804824D
byte g_b804824E = 0x00; // 0804824E
byte g_b804824F = 0x00; // 0804824F
byte g_b8048250 = 0x00; // 08048250
byte g_a8048251[] = // 08048251
	{
	};
byte g_a8048351[] = // 08048351
	{
	};
byte g_a8048451[] = // 08048451
	{
	};
byte g_b8048550 = 0x00; // 08048550
Eq_258 g_t8048551 = // 08048551
	{
		0x00,
		0x00,
		0x00,
		0x00,
	};
