//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2);
int32_t function_80480f8(void);
int32_t function_804817c(void);
int32_t function_8048264(void);
int32_t function_8048281(void);
int32_t function_80482f0(void);
int32_t function_804835d(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x80483bb
int32_t g2 = 0; // 0x80483bf
int32_t g3 = 0; // 0x80483c7
char * g4; // 0x80483cb
char g5 = 0; // 0x804881c

// ------------------------ Functions -------------------------

// Address range: 0x804804c - 0x80480f8
int32_t entry_point(int32_t a1, int32_t a2) {
    int32_t v1 = a2 - 1;
    int32_t v2 = v1 + 1; // 0x804804f
    while (*(char *)v2 != 0) {
        // 0x804804f
        v1 = v2;
        v2 = v1 + 1;
    }
    // 0x8048055
    if (*(char *)(v1 - 1) == 120) {
        // 0x804805b
        *(char *)0x804881c = 2;
    }
    int32_t v3 = a1 - 1; // 0x8048062
    int32_t v4 = v3; // 0x8048063
    int32_t v5; // 0x804804c
    int32_t v6 = &v5; // 0x8048063
    if (v3 != 0) {
        int32_t * v7 = (int32_t *)v6; // 0x8048065
        switch (*(int16_t *)*v7) {
            case 0x6f2d: {
                // 0x804808d
                g5 = 0;
                // break -> 0x8048062
                break;
            }
            case 0x632d: {
                // 0x8048096
                g5 = 1;
                // break -> 0x8048062
                break;
            }
            case 0x782d: {
                // 0x804809f
                g5 = 2;
                // break -> 0x8048062
                break;
            }
            default: {
                // 0x804807b
                *v7 = 5;
                __asm_int(128);
                g1 = 5;
                // break -> 0x8048062
                break;
            }
        }
        // 0x8048062
        v4--;
        v6 += 4;
        while (v4 != 0) {
            // 0x8048065
            v7 = (int32_t *)v6;
            switch (*(int16_t *)*v7) {
                case 0x6f2d: {
                    // 0x804808d
                    g5 = 0;
                    // break -> 0x8048062
                    break;
                }
                case 0x632d: {
                    // 0x8048096
                    g5 = 1;
                    // break -> 0x8048062
                    break;
                }
                case 0x782d: {
                    // 0x804809f
                    g5 = 2;
                    // break -> 0x8048062
                    break;
                }
                default: {
                    // 0x804807b
                    *v7 = 5;
                    __asm_int(128);
                    g1 = 5;
                    // break -> 0x8048062
                    break;
                }
            }
            // 0x8048062
            v4--;
            v6 += 4;
        }
    }
    // 0x80480a8
    if (g5 == 1) {
        while (true) {
            // 0x80480b1
            function_80480f8();
            function_804817c();
        }
    }
    if (g5 != 0) {
        while (true) {
            // 0x80480d2
            function_80480f8();
            function_80482f0();
        }
    }
    while (true) {
        // 0x80480c6
        function_80480f8();
        function_8048281();
    }
}

// Address range: 0x80480f8 - 0x8048175
int32_t function_80480f8(void) {
    // 0x80480f8
    __asm_int(128);
    g3 = 3;
    return 3;
}

// Address range: 0x804817c - 0x8048264
int32_t function_804817c(void) {
    // 0x804817c
    int32_t v1; // 0x804817c
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x8048185
    int32_t v3 = 0; // 0x804817c
    int32_t v4; // 0x804817c
    int32_t v5; // 0x804817c
    while (true) {
      lab_0x804817e:;
        int32_t v6 = g2 + v3; // 0x8048183
        *v2 = v6;
        int32_t v7 = v6; // 0x8048188
        if (v6 % 16 == 0) {
            // 0x804818a
            v7 = function_8048264();
            *v2 = v7;
        }
        // 0x8048193
        v4 = v7;
        v5 = v3;
        while (true) {
          lab_0x8048194:;
            unsigned char v8 = *(char *)(v5 + (int32_t)&g4); // 0x8048194
            int32_t v9 = v8; // 0x8048194
            if (v8 < 32) {
                switch (v8) {
                    case 10: {
                        goto lab_0x80481be;
                    }
                    case 9: {
                        goto lab_0x80481be;
                    }
                    case 0: {
                        goto lab_0x80481be;
                    }
                    case 12: {
                        goto lab_0x80481be;
                    }
                    case 8: {
                        goto lab_0x80481be;
                    }
                    default: {
                        // 0x8048208
                        *v2 = v9;
                        goto lab_0x80481be;
                    }
                }
            } else {
                if (v8 == 127) {
                    // 0x8048208
                    *v2 = v9;
                    goto lab_0x80481be;
                } else {
                    // 0x80481a2
                    *v2 = v4 & -256 | v9;
                    goto lab_0x80481be;
                }
            }
        }
    }
  lab_0x80481de:;
    // 0x80481de
    int32_t v10; // 0x80481be
    int32_t result = g2 + v10; // 0x80481e3
    g2 = result;
    return result;
  lab_0x80481be:
    // 0x80481be
    v10 = v5 + 1;
    if (v10 == g3) {
        // break (via goto) -> 0x80481de
        goto lab_0x80481de;
    }
    // 0x80481c7
    v3 = v10;
    v4 = v10 & -241;
    v5 = v10;
    if (v10 % 16 != 0) {
        goto lab_0x8048194;
    } else {
        goto lab_0x804817e;
    }
}

// Address range: 0x8048264 - 0x8048281
int32_t function_8048264(void) {
    // 0x8048264
    int32_t v1; // 0x8048264
    if ((char)v1 < 3) {
        // 0x804827a
        int32_t v2; // 0x8048264
        return v2 & -256 | 32;
    }
    int32_t v3; // 0x8048264
    uint32_t v4 = v3 + 253;
    v3 = v4 % 256;
    while ((char)v4 >= 3) {
        // 0x804826b
        v4 = v3 + 253;
        v3 = v4 % 256;
    }
    // 0x804827a
    return (v1 >> v4 % 32 & -249 | 48) & -256 | 32;
}

// Address range: 0x8048281 - 0x80482f0
int32_t function_8048281(void) {
    // 0x8048281
    *(char *)&g4 = 0;
    int32_t v1; // 0x8048281
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x8048297
    int32_t v3 = 0; // 0x804828e
    int32_t v4; // 0x8048281
    int32_t v5; // 0x80482b7
    while (true) {
      lab_0x8048290:;
        uint32_t v6 = v3 + g2; // 0x8048295
        *v2 = v6;
        if (v6 % 16 == 0) {
            // 0x804829c
            *v2 = function_8048264();
        }
        int32_t v7 = v3; // 0x80482a5
        while (true) {
          lab_0x80482a6:
            // 0x80482a6
            v4 = v7;
            function_8048264();
            v5 = v4 + 2;
            if (v5 >= g3) {
                // break (via goto) -> 0x80482cf
                goto lab_0x80482cf;
            }
            // 0x80482c0
            v3 = v5;
            v7 = v5;
            if ((g2 + v5) % 16 == 0) {
                goto lab_0x8048290;
            } else {
                goto lab_0x80482a6;
            }
        }
    }
  lab_0x80482cf:
    // 0x80482cf
    g2 += (g3 % 2 == 0 ? v5 : v4 + 1);
    return 10;
}

// Address range: 0x80482f0 - 0x804835d
int32_t function_80482f0(void) {
    // 0x80482f0
    *(char *)&g4 = 0;
    int32_t v1; // 0x80482f0
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x8048306
    int32_t v3 = 0; // 0x80482fd
    int32_t v4; // 0x80482f0
    int32_t v5; // 0x8048324
    while (true) {
      lab_0x80482ff:;
        uint32_t v6 = v3 + g2; // 0x8048304
        *v2 = v6;
        if (v6 % 16 == 0) {
            // 0x804830b
            *v2 = function_804835d();
        }
        int32_t v7 = v3; // 0x8048314
        while (true) {
          lab_0x8048315:
            // 0x8048315
            v4 = v7;
            function_804835d();
            v5 = v4 + 2;
            if (v5 >= g3) {
                // break (via goto) -> 0x804833c
                goto lab_0x804833c;
            }
            // 0x804832d
            v3 = v5;
            v7 = v5;
            if ((g2 + v5) % 16 == 0) {
                goto lab_0x80482ff;
            } else {
                goto lab_0x8048315;
            }
        }
    }
  lab_0x804833c:
    // 0x804833c
    g2 += (g3 % 2 == 0 ? v5 : v4 + 1);
    return 10;
}

// Address range: 0x804835d - 0x8048381
int32_t function_804835d(void) {
    int32_t v1; // 0x804835d
    uint32_t v2 = v1 + 252; // 0x804835f
    int32_t v3; // 0x804835d
    int32_t v4 = v3 & -256; // 0x8048369
    v1 = v2 % 256;
    while ((char)v2 != 0) {
        // 0x804835f
        v2 = v1 + 252;
        v4 &= -256;
        v1 = v2 % 256;
    }
    // 0x804837a
    return v4 | 32;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 7

