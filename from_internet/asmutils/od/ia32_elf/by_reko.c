// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Stack word32 dwArg00, Stack word32 dwArg04)
void fn0804804C(word32 dwArg00, word32 dwArg04)
{
	word32 ebp_18 = dwArg00;
	struct Eq_5 * esp_7 = fp + 8;
	struct Eq_9 * ebx_10 = dwArg04 - 0x01;
	do
		++ebx_10;
	while (ebx_10->b0000 != 0x00);
	if (ebx_10->bFFFFFFFE == 0x78)
		g_b804881C = 0x02;
	while (true)
	{
		--ebp_18;
		if (ebp_18 == 0x00)
			break;
		word16 * ebx_79 = esp_7->dw0000;
		++esp_7;
		if (*ebx_79 != 0x6F2D)
		{
			if (*ebx_79 == 0x632D)
			{
				g_b804881C = 0x01;
				continue;
			}
			if (*ebx_79 == 0x782D)
			{
				g_b804881C = 0x02;
				continue;
			}
			esp_7->dwFFFFFFFC = 0x05;
			int32 eax_93 = esp_7->dwFFFFFFFC;
			__syscall(0x80);
			if (eax_93 < 0x00)
			{
				fn080480DE();
				return;
			}
			else
			{
				g_dw80483BB = eax_93;
				continue;
			}
		}
		g_b804881C = 0x00;
	}
	if (g_b804881C != 0x01)
	{
		if (g_b804881C != 0x00)
		{
			while (true)
			{
				fn080480F8();
				fn080482F0();
			}
		}
		else
		{
			while (true)
			{
				fn080480F8();
				fn08048281();
			}
		}
	}
	else
	{
		while (true)
		{
			fn080480F8();
			fn0804817C();
		}
	}
}

// 080480DE: void fn080480DE()
// Called from:
//      fn0804804C
//      fn080480F8
//      fn0804810F
void fn080480DE()
{
	__syscall(0x80);
	__syscall(0x80);
	fn080480F8();
}

// 080480F8: void fn080480F8()
// Called from:
//      fn0804804C
//      fn080480DE
void fn080480F8()
{
	__syscall(0x80);
	byte cl_25;
	fn0804810F(out cl_25);
}

// 0804810F: Register (ptr32 Eq_122) fn0804810F(Register out Eq_119 clOut)
// Called from:
//      fn080480F8
//      fn08048138
struct Eq_122 * fn0804810F(union Eq_119 & clOut)
{
	if (S)
	{
		fn080480DE();
		return;
	}
	else
	{
		fn08048111(eax);
		return;
	}
}

// 08048111: void fn08048111(Register (ptr32 Eq_122) eax)
// Called from:
//      fn080480F8
//      fn0804810F
void fn08048111(struct Eq_122 * eax)
{
	if (Z)
	{
		if (g_b804881C == 0x02)
		{
			uint32 eax_18 = fn0804835D(eax_18, 0x20);
		}
		else
		{
			uint32 eax_10 = fn08048264(eax_10, 0x15);
		}
		byte cl_71;
		word32 esi_72;
		fn08048138(0x01, out cl_71, out esi_72);
		__syscall(0x80);
		fn0804817E(null);
	}
	else
		g_ptr80483C7 = eax;
}

// 08048138: Register word32 fn08048138(Register byte al, Register out Eq_156 clOut, Register out Eq_156 esiOut)
// Called from:
//      fn08048111
//      fn08048264
//      fn08048281
//      fn080482F0
//      fn0804835D
word32 fn08048138(byte al, union Eq_156 & clOut, union Eq_156 & esiOut)
{
	byte al = (byte) eax;
	struct Eq_172 * ebx_4 = g_ptr80483C3;
	ebx_4->b80487CC = al;
	g_ptr80483C3 = (struct Eq_172 *) ((char *) ebx_4 + 1);
	if (al == 0x0A)
	{
		__syscall(0x80);
		g_ptr80483C3 = null;
		clOut.u2 = <invalid>;
		esiOut.u2 = <invalid>;
		return 0x00;
	}
	else
	{
		clOut.u2 = <invalid>;
		esiOut.u2 = <invalid>;
		return eax;
	}
}

// 0804817C: void fn0804817C()
// Called from:
//      fn0804804C
void fn0804817C()
{
	fn0804817E(null);
}

// 0804817E: void fn0804817E(Register (ptr32 Eq_122) edi)
// Called from:
//      fn08048111
//      fn0804817C
void fn0804817E(struct Eq_122 * edi)
{
	do
	{
		if (((word32) g_t80483BF + (byte) edi & 0x0F) == 0x00)
			fn08048264(eax, cl);
		do
		{
			ci8 al_26 = edi[134513611];
			if (al_26 >= 0x20)
			{
				if (al_26 > 0x7E)
					goto l08048208;
				word32 esi_160;
				byte cl_159;
				fn08048138(al, out cl_159, out esi_160);
				byte cl_161;
				word32 esi_162;
				fn08048138(al, out cl_161, out esi_162);
				word32 esi_164;
				byte cl_163;
				fn08048138(al, out cl_163, out esi_164);
				byte cl_165;
				word32 esi_166;
				fn08048138(al, out cl_165, out esi_166);
			}
			else if (al_26 != 0x0A && (al_26 != 0x09 && (al_26 != 0x0A && (al_26 != 0x00 && (al_26 != 0x0C && al_26 != 0x08)))))
			{
l08048208:
				byte cl_169;
				word32 esi_170;
				fn08048138(al, out cl_169, out esi_170);
				byte cl_171;
				word32 esi_172;
				fn08048138(al, out cl_171, out esi_172);
				byte cl_173;
				word32 esi_174;
				fn08048138(al, out cl_173, out esi_174);
			}
			else
			{
				byte ah_52;
				for (ah_52 = 0x04; ah_52 != 0x00; --ah_52)
				{
					byte cl_175;
					word32 esi_176;
					fn08048138(al, out cl_175, out esi_176);
				}
			}
			++edi;
		} while (edi != g_ptr80483C7 && ((byte) edi & 0x0F) != 0x00);
		byte cl_167;
		word32 esi_168;
		fn08048138(al, out cl_167, out esi_168);
	} while (edi != g_ptr80483C7);
	Mem121[0x080483BF<p32>:word32] = Mem103[0x080483BF<p32>:word32] + edi;
}

// 08048264: Register uint32 fn08048264(Register uint32 eax, Register byte cl)
// Called from:
//      fn08048111
//      fn08048281
uint32 fn08048264(uint32 eax, byte cl)
{
	uint32 esi_18 = eax;
	while (true)
	{
		cu8 cl_6 = cl - 0x03;
		if (cl_6 < 0x00)
			break;
		uint32 eax_20 = esi_18 >> cl_6;
		fn08048138(((byte) eax_20 & 0x07) + 0x30, out cl, out esi_18);
	}
	byte cl_41;
	word32 esi_42;
	return fn08048138(0x20, out cl_41, out esi_42);
}

// 08048281: void fn08048281()
// Called from:
//      fn0804804C
void fn08048281()
{
	g_ptr80483C7[134513611] = (struct Eq_122) 0x00;
	struct Eq_336 * edi_11 = null;
	while (true)
	{
		word32 eax_12 = Mem9[0x080483BF<p32>:word32] + edi_11;
		if (((byte) eax_12 & 0x0F) == 0x00)
			fn08048264(eax_12, 0x15);
		do
		{
			fn08048264((uint32) edi_11[134513611], 0x12);
			struct Eq_336 * edi_53 = edi_11 + 1;
			edi_11 = edi_53 + 0x01;
			if (edi_53 + 0x01 >= Mem34[0x080483C7<p32>:word32])
			{
				if ((g_ptr80483C7 & 0x01) != 0x00)
					edi_11 = edi_53;
				Mem67[0x080483BF<p32>:word32] = Mem34[0x080483BF<p32>:word32] + edi_11;
				byte cl_107;
				word32 esi_108;
				fn08048138(0x0A, out cl_107, out esi_108);
				return;
			}
		} while ((edi_53 + 0x01 + Mem34[0x080483BF<p32>:word32] & 0x0F) != 0x00);
		byte cl_105;
		word32 esi_106;
		fn08048138(0x0A, out cl_105, out esi_106);
	}
}

// 080482F0: void fn080482F0()
// Called from:
//      fn0804804C
void fn080482F0()
{
	g_ptr80483C7[134513611] = (struct Eq_122) 0x00;
	struct Eq_405 * edi_11 = null;
	while (true)
	{
		word32 eax_12 = Mem9[0x080483BF<p32>:word32] + edi_11;
		uint32 dwLoc04_101 = eax_12;
		if (((byte) eax_12 & 0x0F) == 0x00)
			dwLoc04_101 = fn0804835D(eax_12, 0x20);
		word16 eax_16_16_100 = SLICE(dwLoc04_101, word16, 16);
		do
		{
			fn0804835D(SEQ(eax_16_16_100, edi_11[134513611]), 0x10);
			struct Eq_405 * edi_52 = edi_11 + 1;
			edi_11 = edi_52 + 0x01;
			if (edi_52 + 0x01 >= Mem35[0x080483C7<p32>:word32])
			{
				if ((g_ptr80483C7 & 0x01) != 0x00)
					edi_11 = edi_52;
				Mem66[0x080483BF<p32>:word32] = Mem35[0x080483BF<p32>:word32] + edi_11;
				byte cl_108;
				word32 esi_109;
				fn08048138(0x0A, out cl_108, out esi_109);
				return;
			}
			eax_16_16_100 = 0x00;
		} while ((edi_52 + 0x01 + Mem35[0x080483BF<p32>:word32] & 0x0F) != 0x00);
		byte cl_106;
		word32 esi_107;
		fn08048138(0x0A, out cl_106, out esi_107);
	}
}

// 0804835D: Register uint32 fn0804835D(Register uint32 eax, Register byte cl)
// Called from:
//      fn08048111
//      fn080482F0
uint32 fn0804835D(uint32 eax, byte cl)
{
	uint32 esi_19 = eax;
	do
	{
		byte cl_21;
		fn08048138((esi_19 >> cl - 0x04 & 0x0F)->b8048381, out cl_21, out esi_19);
		cl = cl_21;
	} while (cl_21 != 0x00);
	byte cl_46;
	word32 esi_47;
	return fn08048138(0x20, out cl_46, out esi_47);
}

int32 g_dw80483BB = 0; // 080483BB
Eq_196 g_t80483BF = // 080483BF
	{
		0x00
	};
struct Eq_172 * g_ptr80483C3 = null; // 080483C3
struct Eq_122 * g_ptr80483C7 = null; // 080483C7
byte g_b804881C = 0x00; // 0804881C
