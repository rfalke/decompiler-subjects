// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: FlagGroup bool fn0804804C(Register Eq_3 edx, Register (ptr32 char) ebx, Register word32 edi, Register out Eq_6 eaxOut)
// Called from:
//      fn0804807E
bool fn0804804C(Eq_3 edx, char * ebx, word32 edi, union Eq_6 & eaxOut)
{
	Eq_6 eax_11 = sys_open(ebx, 0x00, edx);
	Eq_6 eax_12 = eax_11;
	bool S_103 = (bool) cond(eax_11);
	if (eax_11 >= 0x00)
	{
		sys_fstat(eax_11, edi + 116);
		Eq_6 eax_59 = sys_mmap2();
		eax_12 = eax_59;
		S_103 = (bool) cond(eax_59);
	}
	eaxOut = eax_12;
	return S_103;
}

// 0804807E: void fn0804807E()
void fn0804807E()
{
	ptr32 fp;
	sys_gettimeofday(&g_dw80485E0, null);
	byte * ecx_16 = &g_b8048386;
	struct Eq_44 * esp_20 = fp + 8;
	while (true)
	{
		byte * esi_23 = esp_20->dw0000;
		++esp_20;
		if (esi_23 == null)
			break;
		byte al_561 = *esi_23;
		byte * esi_562 = esi_23 + 1;
		switch (al_561)
		{
		case 0x2B:
			ecx_16 = esi_23 + 1;
			break;
		case 0x3D:
			int32 edx_587 = 0x00;
			word32 eax_589 = 0x00;
			do
			{
				word24 eax_24_8_629 = SLICE(eax_589, word24, 8);
				edx_587 = eax_589 + edx_587 * 0x0A;
				cu8 al_593 = *esi_562;
				++esi_562;
				if (al_593 < 0x30)
					break;
				eax_589 = SEQ(eax_24_8_629, al_593 - 0x30);
			} while (al_593 < 0x3A);
			g_dw80485E0 = edx_587;
			break;
		case 0x2D:
			while (true)
			{
				byte al_571 = *esi_562;
				++esi_562;
				if (al_571 == 0x00)
					break;
				if (al_571 == 117)
					g_t8048632.u1 = 0x00435455;
			}
			break;
		}
	}
	g_ptr804863C = ecx_16;
	g_dw8048640 = 0x08048434;
	esp_20->dwFFFFFFFC = 0x10;
	uint32 ecx_42 = esp_20->dwFFFFFFFC;
	memcpy(&g_b8048654, &g_t80483E0, ecx_42);
	struct Eq_44 * esp_43 = esp_20;
	struct Eq_69 * edi_47 = ecx_42 + 0x08048654;
	do
	{
		struct Eq_98 * esi_50 = esp_43->dw0000;
		++esp_43;
		if (esi_50 == null)
			goto l08048118;
		if (esi_50->dw0000 != 0x474E414C)
			continue;
		byte * esi_62 = &esi_50->b0004 + 1;
	} while (esi_50->b0004 != 0x3D);
	do
	{
		byte al_67 = *esi_62;
		edi_47->b0000 = al_67;
		++esi_62;
		++edi_47;
	} while (al_67 != 0x00);
	edi_47->dwFFFFFFFF = g_dw80483EF;
	edi_47[3] = (struct Eq_69) g_dw80483F3;
	edi_47[7] = (struct Eq_69) al_67;
	word32 eax_96;
	if (!fn0804804C(134514144, &g_b8048654, 134514144, out eax_96))
		g_dw8048640 = eax_96;
l08048118:
	int32 edx_105 = 0x00;
	if (g_t8048632.u1 == 0x00)
	{
		struct Eq_160 * eax_112;
		if (!fn0804804C(0x00, &g_b8048415, 134514144, out eax_112))
		{
			int32 ebx_119 = __bswap<word32>(eax_112->dw0020);
			int32 esi_121 = __bswap<word32>(eax_112->dw0024);
			int32 ecx_123 = ebx_119;
			do
				--ecx_123;
			while (ecx_123 != 0x00 && __bswap<word32>((eax_112->a002C)[ecx_123]) > g_dw80485E0);
			ptr32 eax_140 = eax_112->a002C + ebx_119;
			ui32 ecx_143 = (word32) *((word32) eax_140 + ecx_123);
			Eq_773 eax_144[] = eax_140 + ebx_119;
			edx_105 = __bswap<word32>(eax_144[ecx_143].dw0000);
			g_dw8048628 = edx_105;
			g_t8048632.u0 = (int64) (real64) (&(eax_144 + esi_121)->dw0000)[(word32) eax_144[ecx_143].b0005];
		}
	}
	byte al_165 = 0x2B;
	int32 edx_167 = edx_105;
	if (edx_105 < 0x00)
	{
		al_165 = 0x2D;
		edx_167 = -edx_105;
	}
	g_b804862C = al_165;
	Eq_256 edx_eax_183 = (int64) edx_167;
	word32 edx_184 = SLICE(edx_eax_183, word32, 32);
	Eq_260 edx_eax_189 = (int64) (uint32) (edx_eax_183 /u (edx_184 + 60));
	uint32 eax_194 = (uint32) (edx_eax_189 /u (edx_184 + 60));
	uint32 edx_193 = (uint32) (edx_eax_189 % (edx_184 + 60));
	g_dw804862D = __bswap<word32>((SEQ(SLICE(eax_194, word16, 16), __aam((byte) eax_194)) << 0x10) + 0x30303030 + SEQ(SLICE(edx_193, word16, 16), __aam((byte) edx_193)));
	esp_43->dwFFFFFFFC = 0x04;
	word32 ecx_210 = 1969;
	word32 esi_219 = esp_43->dwFFFFFFFC;
	int32 eax_222 = g_dw80485E0 + g_dw8048628;
	if (eax_222 < 0x00)
	{
		eax_222 += 31536000;
		ecx_210 = 0x07B0;
		--esi_219;
	}
	esp_43->dwFFFFFFFC = esi_219;
	Eq_319 edx_eax_235 = (int64) eax_222;
	word32 edx_236 = SLICE(edx_eax_235, word32, 32);
	g_dw80485E4 = (uint32) (edx_eax_235 % (edx_236 + 60));
	Eq_329 edx_eax_244 = (int64) (uint32) (edx_eax_235 /u (edx_236 + 60));
	g_dw80485E8 = (uint32) (edx_eax_244 % (edx_236 + 60));
	word24 ebx_24_8_256 = SLICE(edx_236 + 60, word24, 8);
	Eq_342 edx_eax_252 = (int64) (uint32) (edx_eax_244 /u (edx_236 + 60));
	uint32 ebx_257 = SEQ(ebx_24_8_256, 0x18);
	uint32 edx_258 = (uint32) (edx_eax_252 % ebx_257);
	g_dw80485EC = edx_258;
	g_b80485F8 = (int8) (edx_258 >= 0x0C);
	word16 ebx_16_16_621 = SLICE(ebx_24_8_256, word16, 8);
	uint32 eax_259 = (uint32) (edx_eax_252 /u ebx_257);
	uint32 edx_261 = edx_258 - 0x0C;
	if (edx_258 <= 0x0C)
	{
		do
			edx_261 += 0x0C;
		while (edx_261 == 0x00);
	}
	g_dw80485F4 = edx_261;
	esp_43->dwFFFFFFF8 = eax_259;
	uint32 ebx_290 = SEQ(ebx_24_8_256, 0x07);
	Eq_394 edx_291 = (uint32) ((int64) (eax_259 + esi_219) % ebx_290);
	g_t80485FC.u1 = (uint32) edx_291;
	word32 eax_298;
	__cmpxchg<word32>(edx_291, ebx_290, 0x00, out eax_298);
	g_t8048600.u1 = (uint32) edx_291;
	int32 eax_301 = esp_43->dwFFFFFFF8;
	word24 ebx_24_8_311 = SEQ(ebx_16_16_621, 0x01);
	do
	{
		++ecx_210;
		cu8 cl_306 = (byte) ecx_210;
		word32 ebx_312 = SEQ(ebx_24_8_311, 110);
		if ((cl_306 & 0x03) != 0x00)
			--ebx_312;
		ebx_24_8_311 = SLICE(ebx_312, word24, 8);
		eax_301 -= ebx_312;
	} while (eax_301 >= 0x00);
	g_dw80485F0 = ecx_210;
	int32 eax_321 = eax_301 + ebx_312;
	byte ch_326 = 0x14;
	cu8 cl_327 = cl_306 - 0xD0;
	if (cl_306 < 0xD0)
	{
		ch_326 = 0x13;
		cl_327 = cl_306 + 0x94;
	}
	g_b8048624 = cl_327;
	g_b8048620 = ch_326;
	int64 edx_eax_346 = (int64) eax_321;
	word32 ebx_341 = ebx_312 + ~0x3FC44280;
	word32 ecx_342 = 0x00;
	word24 edx_24_8_348 = SLICE(edx_eax_346, word24, 40);
	int32 eax_356 = (word32) edx_eax_346;
	do
	{
		word32 edx_351 = __shld<word32>(SEQ(edx_24_8_348, 0x07), ebx_341, 0x02);
		edx_24_8_348 = SLICE(edx_351, word24, 8);
		ebx_341 = __ror<word32,byte>(ebx_341, 0x02);
		++ecx_342;
		eax_356 -= edx_351;
	} while (eax_356 >= 0x00);
	g_dw8048604 = eax_356 + edx_351 + 0x01;
	g_dw8048608 = ecx_342;
	word32 ebx_376 = esp_43->dwFFFFFFFC;
	word24 ebx_24_8_386 = SLICE(ebx_376, word24, 8);
	uint32 ebx_387 = SEQ(ebx_24_8_386, 0x07);
	Eq_394 edx_388 = (uint32) ((int64) (esp_43->dwFFFFFFF8 - eax_321 + ebx_376) % ebx_387);
	word32 eax_392;
	__cmpxchg<word32>(edx_388, ebx_387, 0x00, out eax_392);
	g_dw804860C = (uint32) ((int64) ((word32) edx_388.u1 + eax_321) /u ebx_387);
	uint32 ecx_404 = edx_388 - 0x01;
	word24 ecx_24_8_410 = SLICE(edx_388 - 0x01, word24, 8);
	if (edx_388 == 0x01)
	{
		ecx_404 = SEQ(ecx_24_8_410, 0x07);
		ebx_387 = SEQ(ebx_24_8_386, 0x07);
	}
	word32 eax_452;
	Eq_535 edx_eax_413 = (int64) (eax_321 + ecx_404);
	uint32 eax_420 = (uint32) (edx_eax_413 /u ebx_387);
	g_dw8048610 = eax_420;
	word32 ebx_424 = g_dw80485F0;
	uint32 ecx_428 = ecx_404 - 0x04;
	byte bl_426 = (byte) ebx_424;
	word24 eax_24_8_451 = SLICE(eax_420, word24, 8);
	byte al_432 = (byte) eax_420 + (byte) (ecx_428 < 0x00);
	cu8 dl_427 = bl_426 & 0x03;
	word32 edx_446 = SEQ(SLICE((uint32) (edx_eax_413 % ebx_387), word24, 8), bl_426 & 0x03);
	word32 eax_635 = SEQ(eax_24_8_451, al_432);
	if (al_432 != 0x00)
	{
l08048274:
		word24 eax_24_8_481 = SLICE(eax_635, word24, 8);
		eax_452 = eax_635;
		if ((byte) eax_635 == 0x35 && ((byte) eax_321 - 0x68) - (byte) (dl_427 < 0x01) > g_t80485FC.u0)
		{
			++ebx_424;
			eax_452 = SEQ(eax_24_8_481, 0x01);
		}
		goto l08048288;
	}
	--ebx_424;
	eax_452 = SEQ(eax_24_8_451, 0x34);
	if (ecx_428 == 0x00)
	{
l08048273:
		eax_635 = SEQ(SLICE(eax_452 + 0x01, word24, 8), 0x35);
		goto l08048274;
	}
	else
	{
		if (ecx_428 == 0x01)
		{
			dl_427 = (bl_426 & 0x03) - 0x01;
			if (edx_446 == 0x01)
				goto l08048273;
		}
l08048288:
		g_dw8048614 = eax_452;
		g_dw8048618 = ebx_424;
		g_dw804861C = eax_321 + 0x01;
		byte * esi_501 = g_ptr804863C;
		esp_43->dwFFFFFFFC = 0x08048654;
		fn080482C2(134514144, &g_b80483BB, esi_501);
		g_b8048654 = 0x0A;
		char * ecx_533 = esp_43->dwFFFFFFFC;
		esp_43->dwFFFFFFFC = 0x01;
		uint32 ebx_539 = esp_43->dwFFFFFFFC;
		esp_43->dwFFFFFFFC = 0x04;
		int32 ebx_546 = 0x00;
		int32 eax_548 = -sys_write(ebx_539, ecx_533, 0x08048655 - ecx_533);
		if (eax_548 >= 0x00)
			ebx_546 = eax_548;
		esp_43->dwFFFFFFFC = 0x01;
		sys_exit(ebx_546);
	}
}

// 080482BD: void fn080482BD(Register (ptr32 byte) edi)
// Called from:
//      fn080482C2
void fn080482BD(byte * edi)
{
	byte al;
	*edi = 0x25;
	fn080482C1(al, edi + 1);
}

// 080482C1: Register byte fn080482C1(Register byte al, Register (ptr32 byte) edi)
// Called from:
//      fn080482BD
//      fn080482C2
byte fn080482C1(byte al, byte * edi)
{
	word32 ebx;
	byte * ebp;
	byte * esi;
	*edi = al;
	fn080482C2(ebx, ebp, esi);
	return <invalid>;
}

// 080482C2: void fn080482C2(Register word32 ebx, Register (ptr32 byte) ebp, Register (ptr32 byte) esi)
// Called from:
//      fn0804807E
//      fn080482C1
void fn080482C2(word32 ebx, byte * ebp, byte * esi)
{
	byte * edi;
	while (true)
	{
		byte al_6 = *esi;
		byte * esi_7 = esi + 1;
		if (al_6 == 0x00)
			break;
		if (al_6 != 0x25)
		{
			word24 eax_24_8_128 = SLICE((uint32) fn080482C1((byte) eax_24_8_128, edi), word24, 8);
			return;
		}
		bool v20_87 = *esi_7 != 0x00;
		if (*esi_7 == 0x00)
		{
			word24 eax_24_8_129 = SLICE((uint32) fn080482C1((byte) eax_24_8_129, edi), word24, 8);
			return;
		}
		byte al_27 = *esi_7;
		byte * edi_33 = ebp;
		int32 ecx_36 = 0x25;
		while (ecx_36 != 0x00)
		{
			v20_87 = al_27 != *edi_131;
			edi_33 = edi_131 + 1;
			--ecx_36;
			edi_131 = edi_33;
			if (al_27 != *edi_131)
				break;
		}
		word24 ecx_24_8_74 = SLICE(ecx_36, word24, 8);
		if (v20_87)
		{
			fn080482BD(edi);
			return;
		}
		int32 ecx_75 = SEQ(ecx_24_8_74, *((word32) (ebp - 116) + ecx_36));
		(ebp + 0x0069)[ecx_75]();
		esi = esi_7 + 1;
	}
}

byte g_b8048386 = 0x25; // 08048386
byte g_b80483BB = 0x25; // 080483BB
Eq_63 g_t80483E0 = // 080483E0;
word32 g_dw80483EF = 1598245935; // 080483EF
word32 g_dw80483F3 = 0x454D4954; // 080483F3
char g_b8048415 = '/'; // 08048415
int32 g_dw80485E0 = 0; // 080485E0
uint32 g_dw80485E4 = 0x00; // 080485E4
uint32 g_dw80485E8 = 0x00; // 080485E8
uint32 g_dw80485EC = 0x00; // 080485EC
word32 g_dw80485F0 = 0x00; // 080485F0
uint32 g_dw80485F4 = 0x00; // 080485F4
int8 g_b80485F8 = 0; // 080485F8
Eq_394 g_t80485FC = // 080485FC
	{
		0x00
	};
Eq_394 g_t8048600 = // 08048600
	{
		0x00
	};
int32 g_dw8048604 = 0; // 08048604
word32 g_dw8048608 = 0x00; // 08048608
uint32 g_dw804860C = 0x00; // 0804860C
uint32 g_dw8048610 = 0x00; // 08048610
word32 g_dw8048614 = 0x00; // 08048614
word32 g_dw8048618 = 0x00; // 08048618
int32 g_dw804861C = 0; // 0804861C
byte g_b8048620 = 0x00; // 08048620
cu8 g_b8048624 = 0x00; // 08048624
int32 g_dw8048628 = 0; // 08048628
byte g_b804862C = 0x00; // 0804862C
int32 g_dw804862D = 0; // 0804862D
Eq_95 g_t8048632 = // 08048632
	{
		0
	};
byte * g_ptr804863C = null; // 0804863C
word32 g_dw8048640 = 0x00; // 08048640
byte g_b8048654 = 0x00; // 08048654
