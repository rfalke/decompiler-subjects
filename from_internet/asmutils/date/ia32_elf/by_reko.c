// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: FlagGroup bool fn0804804C(Register out ptr32 eaxOut)
// Called from:
//      fn0804807E
bool fn0804804C(ptr32 & eaxOut)
{
	__syscall(0x80);
	__syscall(0x80);
	__syscall(0x80);
}

// 0804807E: void fn0804807E(Register (ptr8 Eq_15) Top)
void fn0804807E(struct Eq_15 * Top)
{
	__syscall(0x80);
	byte * ecx_13 = &g_b8048386;
	struct Eq_21 * esp_17 = fp + 8;
	while (true)
	{
		byte * esi_20 = esp_17->dw0000;
		++esp_17;
		if (esi_20 == null)
			break;
		byte al_567 = *esi_20;
		byte * esi_568 = esi_20 + 1;
		if (al_567 == 0x2B)
			ecx_13 = esi_20 + 1;
		else if (al_567 == 0x3D)
		{
			int32 edx_591 = 0x00;
			word32 eax_593 = 0x00;
			do
			{
				word24 eax_24_8_636 = SLICE(eax_593, word24, 8);
				edx_591 = eax_593 + edx_591 * 0x0A;
				cu8 al_597 = *esi_568;
				++esi_568;
				if (al_597 < 0x30)
					break;
				eax_593 = SEQ(eax_24_8_636, al_597 - 0x30);
			} while (al_597 < 0x3A);
			g_dw80485E0 = edx_591;
		}
		else if (al_567 == 0x2D)
		{
			while (true)
			{
				byte al_577 = *esi_568;
				++esi_568;
				if (al_577 == 0x00)
					break;
				if (al_577 == 117)
					g_t8048632.u1 = 0x00435455;
			}
		}
	}
	g_ptr804863C = ecx_13;
	g_dw8048640 = 0x08048434;
	esp_17->dwFFFFFFFC = 0x10;
	struct Eq_34 * edi_33 = &g_t8048654;
	byte * esi_35 = g_a80483E0;
	word32 ecx_38;
	struct Eq_21 * esp_39 = esp_17;
	for (ecx_38 = esp_17->dwFFFFFFFC; ecx_38 != 0x00; --ecx_38)
	{
		edi_33->b0000 = *esi_35;
		++esi_35;
		++edi_33;
	}
	do
	{
		struct Eq_63 * esi_43 = esp_39->dw0000;
		++esp_39;
		if (esi_43 == null)
			goto l08048118;
		if (esi_43->dw0000 != 0x474E414C)
			continue;
		byte * esi_54 = &esi_43->b0004 + 1;
	} while (esi_43->b0004 != 0x3D);
	do
	{
		byte al_59 = *esi_54;
		edi_33->b0000 = al_59;
		++esi_54;
		++edi_33;
	} while (al_59 != 0x00);
	edi_33->dwFFFFFFFF = g_dw80483EF;
	edi_33[3] = (struct Eq_34) g_dw80483F3;
	edi_33[7] = (struct Eq_34) al_59;
	word32 eax_88;
	if (!fn0804804C(out eax_88))
		g_dw8048640 = eax_88;
l08048118:
	int32 edx_141 = 0x00;
	if (g_t8048632 == 0x00)
	{
		struct Eq_167 * eax_104;
		if (!fn0804804C(out eax_104))
		{
			int32 ebx_112 = __bswap(eax_104->dw0020);
			int32 esi_114 = __bswap(eax_104->dw0024);
			int32 ecx_116 = ebx_112;
			do
				--ecx_116;
			while (ecx_116 != 0x00 && __bswap((eax_104->a002C)[ecx_116]) > g_dw80485E0);
			ptr32 eax_133 = eax_104->a002C + ebx_112;
			ui32 ecx_136 = (word32) (eax_133 + ecx_116);
			Eq_796 eax_137[] = eax_133 + ebx_112;
			edx_141 = __bswap(eax_137[ecx_136].dw0000);
			g_dw8048628 = edx_141;
			Top->rFFFFFFFF = (real64) (&(eax_137 + esi_114)->dw0000)[(word32) eax_137[ecx_136].b0005];
			g_t8048632.u0 = (int64) Top->rFFFFFFFF;
		}
	}
	byte al_158 = 0x2B;
	int32 edx_160 = edx_141;
	if (edx_141 < 0x00)
	{
		al_158 = 0x2D;
		edx_160 = -edx_141;
	}
	g_b804862C = al_158;
	Eq_241 edx_eax_175 = (int64) edx_160;
	word32 edx_176 = SLICE(edx_eax_175, word32, 32);
	Eq_245 edx_eax_181 = (int64) (uint32) (edx_eax_175 /u (edx_176 + 0x3C));
	uint32 eax_186 = (uint32) (edx_eax_181 /u (edx_176 + 0x3C));
	uint32 edx_185 = (uint32) (edx_eax_181 % (edx_176 + 0x3C));
	g_dw804862D = __bswap((SEQ(SLICE(eax_186, word16, 16), __aam((byte) eax_186)) << 0x10) + 0x30303030 + SEQ(SLICE(edx_185, word16, 16), __aam((byte) edx_185)));
	esp_39->dwFFFFFFFC = 0x04;
	word32 ecx_202 = 1969;
	word32 esi_211 = esp_39->dwFFFFFFFC;
	int32 eax_214 = g_dw80485E0 + g_dw8048628;
	if (eax_214 < 0x00)
	{
		eax_214 += 31536000;
		ecx_202 = 0x07B0;
		--esi_211;
	}
	esp_39->dwFFFFFFFC = esi_211;
	Eq_316 edx_eax_227 = (int64) eax_214;
	word32 edx_228 = SLICE(edx_eax_227, word32, 32);
	g_dw80485E4 = (uint32) (edx_eax_227 % (edx_228 + 0x3C));
	Eq_326 edx_eax_236 = (int64) (uint32) (edx_eax_227 /u (edx_228 + 0x3C));
	g_dw80485E8 = (uint32) (edx_eax_236 % (edx_228 + 0x3C));
	word24 ebx_24_8_248 = SLICE(edx_228 + 0x3C, word24, 8);
	Eq_339 edx_eax_244 = (int64) (uint32) (edx_eax_236 /u (edx_228 + 0x3C));
	uint32 ebx_249 = SEQ(ebx_24_8_248, 0x18);
	uint32 edx_250 = (uint32) (edx_eax_244 % ebx_249);
	g_dw80485EC = edx_250;
	g_b80485F8 = (int8) (edx_250 >= 0x0C);
	word16 ebx_16_16_628 = SLICE(ebx_24_8_248, word16, 8);
	uint32 eax_251 = (uint32) (edx_eax_244 /u ebx_249);
	uint32 edx_253 = edx_250 - 0x0C;
	if (edx_250 <= 0x0C)
	{
		do
			edx_253 += 0x0C;
		while (edx_253 == 0x00);
	}
	g_dw80485F4 = edx_253;
	esp_39->dwFFFFFFF8 = eax_251;
	uint32 ebx_282 = SEQ(ebx_24_8_248, 0x07);
	Eq_378 edx_283 = (uint32) ((int64) (eax_251 + esi_211) % ebx_282);
	g_t80485FC = edx_283;
	word32 eax_289;
	__cmpxchg(edx_283, ebx_282, 0x00, out eax_289);
	g_t8048600 = edx_283;
	int32 eax_292 = esp_39->dwFFFFFFF8;
	word24 ebx_24_8_301 = SEQ(ebx_16_16_628, 0x01);
	do
	{
		++ecx_202;
		cu8 cl_297 = (byte) ecx_202;
		word32 ebx_302 = SEQ(ebx_24_8_301, 110);
		if ((cl_297 & 0x03) != 0x00)
			--ebx_302;
		ebx_24_8_301 = SLICE(ebx_302, word24, 8);
		eax_292 -= ebx_302;
	} while (eax_292 >= 0x00);
	g_dw80485F0 = ecx_202;
	int32 eax_311 = eax_292 + ebx_302;
	byte ch_316 = 0x14;
	cu8 cl_317 = cl_297 - 0xD0;
	if (cl_297 < 0xD0)
	{
		ch_316 = 0x13;
		cl_317 = cl_297 + 0x94;
	}
	g_b8048624 = cl_317;
	g_b8048620 = ch_316;
	int64 edx_eax_335 = (int64) eax_311;
	word32 ebx_331 = ebx_302 + ~0x3FC44280;
	word32 ecx_332 = 0x00;
	word24 edx_24_8_337 = SLICE(edx_eax_335, word24, 40);
	int32 eax_345 = (word32) edx_eax_335;
	do
	{
		word32 edx_340 = __shld(SEQ(edx_24_8_337, 0x07), ebx_331, 0x02);
		edx_24_8_337 = SLICE(edx_340, word24, 8);
		ebx_331 = __ror<word32,byte>(ebx_331, 0x02);
		++ecx_332;
		eax_345 -= edx_340;
	} while (eax_345 >= 0x00);
	g_dw8048604 = eax_345 + edx_340 + 0x01;
	g_dw8048608 = ecx_332;
	word32 ebx_365 = esp_39->dwFFFFFFFC;
	word24 ebx_24_8_375 = SLICE(ebx_365, word24, 8);
	uint32 ebx_376 = SEQ(ebx_24_8_375, 0x07);
	Eq_378 edx_377 = (uint32) ((int64) (esp_39->dwFFFFFFF8 - eax_311 + ebx_365) % ebx_376);
	word32 eax_381;
	__cmpxchg(edx_377, ebx_376, 0x00, out eax_381);
	g_dw804860C = (uint32) ((int64) ((word32) edx_377.u1 + eax_311) /u ebx_376);
	uint32 ecx_393 = edx_377 - 0x01;
	word24 ecx_24_8_399 = SLICE(edx_377 - 0x01, word24, 8);
	if (edx_377 == 0x01)
	{
		ecx_393 = SEQ(ecx_24_8_399, 0x07);
		ebx_376 = SEQ(ebx_24_8_375, 0x07);
	}
	word32 eax_440;
	Eq_519 edx_eax_402 = (int64) (eax_311 + ecx_393);
	uint32 eax_409 = (uint32) (edx_eax_402 /u ebx_376);
	g_dw8048610 = eax_409;
	word32 ebx_413 = g_dw80485F0;
	byte bl_415 = (byte) ebx_413;
	word24 eax_24_8_439 = SLICE(eax_409, word24, 8);
	byte al_421 = SLICE(SEQ((byte) eax_409, ecx_393) - 0x04, byte, 32);
	cu8 dl_416 = bl_415 & 0x03;
	uint32 ecx_417 = ecx_393 - 0x04;
	word32 edx_434 = SEQ(SLICE((uint32) (edx_eax_402 % ebx_376), word24, 8), bl_415 & 0x03);
	word32 eax_659 = SEQ(eax_24_8_439, al_421);
	if (al_421 != 0x00)
	{
l08048274:
		word24 eax_24_8_469 = SLICE(eax_659, word24, 8);
		eax_440 = eax_659;
		if ((byte) eax_659 == 0x35 && ((byte) eax_311 - 0x68) - (byte) (dl_416 < 0x01) > g_t80485FC)
		{
			++ebx_413;
			eax_440 = SEQ(eax_24_8_469, 0x01);
		}
		goto l08048288;
	}
	--ebx_413;
	eax_440 = SEQ(eax_24_8_439, 0x34);
	if (ecx_417 == 0x00)
	{
l08048273:
		eax_659 = SEQ(SLICE(eax_440 + 0x01, word24, 8), 0x35);
		goto l08048274;
	}
	else
	{
		if (ecx_417 == 0x01)
		{
			dl_416 = (bl_415 & 0x03) - 0x01;
			if (edx_434 == 0x01)
				goto l08048273;
		}
l08048288:
		g_dw8048614 = eax_440;
		g_dw8048618 = ebx_413;
		g_dw804861C = eax_311 + 0x01;
		byte * esi_489 = g_ptr804863C;
		esp_39->dwFFFFFFFC = 0x08048654;
		byte * edi_514;
		word32 esi_513 = fn080482C2(134514144, &g_b80483BB, esi_489, out edi_514);
		*edi_514 = 0x0A;
		esp_39->dwFFFFFFFC = 0x01;
		esp_39->dwFFFFFFFC = 0x04;
		word32 eax_532 = esp_39->dwFFFFFFFC;
		__syscall(0x80);
		int32 ebx_534 = 0x00;
		int32 eax_536 = -eax_532;
		if (eax_536 >= 0x00)
			ebx_534 = eax_536;
		esp_39->dwFFFFFFFC = 0x01;
		__syscall(0x80);
		word32 edi_662;
		fn080482C2(ebx_534, &g_b80483BB, esi_513 + 0x080483BB, out edi_662);
	}
}

// 080482BD: Register word32 fn080482BD(Register (ptr32 byte) edi, Register out ptr32 ediOut)
// Called from:
//      fn080482C2
word32 fn080482BD(byte * edi, ptr32 & ediOut)
{
	*edi = 0x25;
	ptr32 edi_8;
	word32 esi_16;
	fn080482C1(al, edi + 1, out esi_16, out edi_8);
	ediOut = edi_8;
	return <invalid>;
}

// 080482C1: Register byte fn080482C1(Register byte al, Register (ptr32 byte) edi, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      fn080482BD
//      fn080482C2
byte fn080482C1(byte al, byte * edi, ptr32 & esiOut, ptr32 & ediOut)
{
	*edi = al;
	ptr32 edi_9;
	fn080482C2(ebx, ebp, esi, out edi_9);
	esiOut = <invalid>;
	ediOut = edi_9;
	return <invalid>;
}

// 080482C2: Register (ptr32 byte) fn080482C2(Register int32 ebx, Register (ptr32 byte) ebp, Register (ptr32 byte) esi, Register out (ptr32 byte) ediOut)
// Called from:
//      fn0804807E
//      fn080482C1
byte * fn080482C2(int32 ebx, byte * ebp, byte * esi, byte & ediOut)
{
	while (true)
	{
		int32 ebx_92;
		byte * ebp_90;
		byte * edi_89;
		byte al_5 = *esi;
		byte * esi_6 = esi + 1;
		if (al_5 == 0x00)
			break;
		if (al_5 != 0x25)
		{
			byte * esi_16;
			byte * edi_17;
			word24 eax_24_8_140 = SLICE((uint32) fn080482C1((byte) eax_24_8_140, edi_17, out esi_16, out edi_17), word24, 8);
			ediOut = edi_17;
			return esi_16;
		}
		bool v17_102 = *esi_6 != 0x00;
		if (*esi_6 == 0x00)
		{
			byte * esi_27;
			byte * edi_28;
			word24 eax_24_8_142 = SLICE((uint32) fn080482C1((byte) eax_24_8_142, edi_28, out esi_27, out edi_28), word24, 8);
			ediOut = edi_28;
			return esi_27;
		}
		byte al_34 = *esi_6;
		byte * edi_40 = ebp;
		int32 ecx_43 = 0x25;
		while (ecx_43 != 0x00)
		{
			v17_102 = al_34 != *edi_152;
			edi_40 = edi_152 + 1;
			--ecx_43;
			edi_152 = edi_40;
			if (al_34 != *edi_152)
				break;
		}
		word24 ecx_24_8_84 = SLICE(ecx_43, word24, 8);
		if (v17_102)
		{
			byte * edi_63;
			byte * esi_62 = fn080482BD(edi_63, out edi_63);
			ediOut = edi_63;
			return esi_62;
		}
		word32 esi_81 = (word32) (ebp - 0x24 + ecx_43);
		int32 ecx_85 = SEQ(ecx_24_8_84, (ebp - 116)[ecx_43]);
		byte ** esp_86;
		(ebp + 0x0069)[ecx_85]();
		esi = (byte *) *esp_86;
		edi = edi_89;
		ebp = ebp_90;
		ebx = ebx_92;
	}
	ediOut = edi;
	return esi_6;
}

byte g_b8048386 = 0x25; // 08048386
byte g_b80483BB = 0x25; // 080483BB
byte g_a80483E0[] = // 080483E0
	{
	};
word32 g_dw80483EF = 1598245935; // 080483EF
word32 g_dw80483F3 = 0x454D4954; // 080483F3
int32 g_dw80485E0 = 0; // 080485E0
uint32 g_dw80485E4 = 0x00; // 080485E4
uint32 g_dw80485E8 = 0x00; // 080485E8
uint32 g_dw80485EC = 0x00; // 080485EC
word32 g_dw80485F0 = 0x00; // 080485F0
uint32 g_dw80485F4 = 0x00; // 080485F4
int8 g_b80485F8 = 0; // 080485F8
Eq_378 g_t80485FC = // 080485FC
	{
		0x00
	};
Eq_378 g_t8048600 = // 08048600
	{
		0x00
	};
int32 g_dw8048604 = 0; // 08048604
word32 g_dw8048608 = 0x00; // 08048608
uint32 g_dw804860C = 0x00; // 0804860C
uint32 g_dw8048610 = 0x00; // 08048610
word32 g_dw8048614 = 0x00; // 08048614
word32 g_dw8048618 = 0x00; // 08048618
int32 g_dw804861C = 0; // 0804861C
byte g_b8048620 = 0x00; // 08048620
cu8 g_b8048624 = 0x00; // 08048624
int32 g_dw8048628 = 0; // 08048628
byte g_b804862C = 0x00; // 0804862C
int32 g_dw804862D = 0; // 0804862D
Eq_88 g_t8048632 = // 08048632
	{
		0
	};
byte * g_ptr804863C = null; // 0804863C
word32 g_dw8048640 = 0x00; // 08048640
Eq_34 g_t8048654 = // 08048654
	{
		0x00,
		0x00,
		0x00,
		0x00,
	};
