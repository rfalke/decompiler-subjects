// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Register word32 esi)
void fn0804804C(word32 esi)
{
	__syscall(0x80);
	__syscall(0x80);
	__syscall(0x80);
	__syscall(0x80);
	__syscall(0x80);
	*(byte *) 0x08048161 = 0x0A;
	__syscall(0x80);
	__syscall(0x80);
	byte * edi_194 = (byte *) 0x08048161;
	word32 ecx_115 = 0x13;
	while (true)
	{
		while (ecx_115 != 0x00)
		{
			++edi_194;
			--ecx_115;
			if (*edi_194 != 0x3A)
				break;
		}
		while (ecx_115 != 0x00)
		{
			++edi_194;
			--ecx_115;
			if (*edi_194 != 0x3A)
				break;
		}
		edi_250 = edi_194;
		do
		{
			byte * edi_250;
			if (ecx_115 == 0x00)
				break;
			++edi_250;
			--ecx_115;
		} while (*edi_250 == 0x3A);
		edi_194 = edi_250 - 0x01;
		*edi_194 = 0x00;
		if (fn08048120(edi_194) == 0x18)
			break;
		while (ecx_115 != 0x00)
		{
			++edi_194;
			--ecx_115;
			if (*edi_194 != 0x0A)
				break;
		}
	}
	byte * edi_114 = edi_194;
	while (ecx_115 != 0x00)
	{
		--edi_114;
		--ecx_115;
		if (*edi_114 != 0x0A)
			break;
	}
	ptr32 edi_124 = edi_114 + 1;
	struct Eq_94 * edi_125 = edi_124 + 0x01;
	while (ecx_115 != 0x00)
	{
		++edi_125;
		--ecx_115;
		if (edi_125->b0000 != 0x3A)
			break;
	}
	edi_125->wFFFFFFFF = 0x0A;
	fn0804813C(edi_124 + 0x01);
	__syscall(0x80);
}

// 08048120: Register Eq_131 fn08048120(Register (ptr32 byte) esi)
// Called from:
//      fn0804804C
Eq_131 fn08048120(byte * esi)
{
	Eq_131 eax_27 = 0x00;
	while (true)
	{
		byte bl_33 = *esi;
		if (bl_33 == 0x00)
			break;
		eax_27 = eax_27 *s 0x0A + (uint32) (bl_33 & ~0x30);
		++esi;
	}
	return eax_27;
}

// 0804813C: void fn0804813C(Register (ptr32 byte) esi)
// Called from:
//      fn0804804C
void fn0804813C(byte * esi)
{
	byte * edi_30 = esi;
	uip32 ecx_34 = 200;
	while (ecx_34 != 0x00)
	{
		edi_30 = edi_99 + 1;
		--ecx_34;
		edi_99 = edi_30;
		if (*edi_99 != 0x00)
			return;
	}
}

