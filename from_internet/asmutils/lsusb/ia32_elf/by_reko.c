// subject_seg08048000_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Register word32 esi)
void fn0804804C(word32 esi)
{
	__syscall(0x80);
	__syscall(0x80);
	__syscall(0x80);
	fn080482DF(&g_b8048316);
	fn0804809D(0x03, &g_b804839B);
}

// 0804809D: void fn0804809D(Register word32 ecx, Register (ptr32 byte) esi)
// Called from:
//      fn0804804C
void fn0804809D(word32 ecx, byte * esi)
{
	byte * dwLoc08_470 = esi;
	word32 dwLoc0C_471 = ecx;
	up32 dwLoc10_472 = 0x00;
	while (true)
	{
		word32 ecx_16 = dwLoc0C_471;
		if (dwLoc0C_471 == 0x00)
			break;
		byte * esi_23 = dwLoc08_470;
		byte * edi_24 = g_a808839B;
		do
		{
			byte al_27 = *esi_23;
			*edi_24 = al_27;
			++esi_23;
			++edi_24;
			if (al_27 == 0x0A)
				break;
			--ecx_16;
		} while (ecx_16 != 0x00);
		*edi_24 = 0x00;
		dwLoc08_470 = esi_23;
		dwLoc0C_471 = ecx_16;
		if (fn080482CF(0x08, esi_23, &g_b8048379) == 0x00)
		{
			dwLoc10_472 = 0x01;
			struct Eq_72 * esi_275 = esi_23 + 8;
			do
			{
				esi_275 = esi_590 + 1;
				esi_590 = esi_275;
			} while (esi_590->b0000 != 0x20);
			esi_275->bFFFFFFFF = 0x00;
			fn080482DF(esi_23 + 8);
			fn080482DF(&g_b8048389);
			struct Eq_93 * esi_310 = esi_23 + 31;
			do
			{
				esi_310 = esi_591 + 1;
				esi_591 = esi_310;
			} while (esi_591->b0000 != 0x20);
			esi_310->bFFFFFFFF = 0x00;
			fn080482DF(esi_23 + 31);
			fn080482DF(&g_b8048389);
			struct Eq_115 * esi_345 = esi_23 + 46;
			do
			{
				esi_345 = esi_592 + 1;
				esi_592 = esi_345;
			} while (esi_592->b0000 == 0x20);
			do
			{
				esi_345 = esi_593 + 1;
				esi_593 = esi_345;
			} while (esi_593->b0000 != 0x20);
			esi_345->bFFFFFFFF = 0x00;
			fn080482DF(esi_23 + 46);
			fn080482DF(&g_b8048390);
			struct Eq_145 * esi_387 = esi_23 + 54;
			do
			{
				esi_387 = esi_594 + 1;
				esi_594 = esi_387;
			} while (esi_594->b0000 != 0x20);
			esi_387->bFFFFFFFF = 0x00;
			int32 ecx_413 = 0x04 - fn080482DF(esi_23 + 54);
			if (ecx_413 > 0x00)
			{
				do
				{
					fn080482DF(&g_b804838B);
					--ecx_413;
				} while (ecx_413 != 0x00);
			}
			fn080482DF(&g_b8048398);
			fn080482DF(&g_b8048392);
			fn080482DF(&g_b804838B);
		}
		else if (fn080482CF(0x09, esi_23, &g_b8048370) == 0x00)
		{
			struct Eq_193 * esi_225 = esi_23 + 9;
			do
			{
				esi_225 = esi_589 + 1;
				esi_589 = esi_225;
			} while (esi_589->b0000 != 0x20);
			esi_225->bFFFFFFFF = 0x00;
			if (dwLoc10_472 <= 0x00)
			{
				word32 ecx_240;
				for (ecx_240 = 0x12; ecx_240 != 0x00; --ecx_240)
					fn080482DF(&g_b804838B);
			}
			fn080482DF(esi_23 + 9);
			fn080482DF(&g_b804838B);
		}
		else if (fn080482CF(0x11, esi_23, &g_b8048349) == 0x00)
		{
			struct Eq_231 * esi_184 = esi_23 + 0x0011;
			do
			{
				esi_184 = esi_588 + 1;
				esi_588 = esi_184;
			} while (esi_588->b0000 != 0x0A);
			esi_184->bFFFFFFFF = 0x00;
			fn080482DF(&g_b8048390);
			fn080482DF(esi_23 + 0x0011);
			esi_184->bFFFFFFFF = 0x0A;
			fn080482DF(&g_b8048392);
		}
		else if (fn080482CF(0x0C, esi_23, &g_b804835A) == 0x00)
		{
			struct Eq_265 * esi_159 = esi_23 + 0x0C;
			do
			{
				esi_159 = esi_587 + 1;
				esi_587 = esi_159;
			} while (esi_587->b0000 != 0x0A);
			esi_159->bFFFFFFFF = 0x00;
			fn080482DF(esi_23 + 0x0C);
			esi_159->bFFFFFFFF = 0x0A;
		}
		else if (fn080482CF(0x0A, esi_23, &g_b8048366) == 0x00)
		{
			struct Eq_287 * esi_107 = esi_23 + 62;
			do
			{
				esi_107 = esi_586 + 1;
				esi_586 = esi_107;
			} while (esi_586->b0000 != 0x0A);
			esi_107->bFFFFFFFF = 0x00;
			fn080482DF(&g_b8048394);
			fn080482DF(esi_23 + 62);
			esi_107->bFFFFFFFF = 0x0A;
			fn080482DF(&g_b8048396);
			fn080482DF(&g_b8048387);
		}
	}
}

// 080482CF: Register word32 fn080482CF(Register word32 ecx, Register (ptr32 byte) esi, Register (ptr32 byte) edi)
// Called from:
//      fn0804809D
word32 fn080482CF(word32 ecx, byte * esi, byte * edi)
{
	word32 eax_28 = 0x00;
	bool v11_41 = true;
	while (ecx != 0x00)
	{
		v11_41 = *esi_73 == *edi_74;
		esi = esi_73 + 1;
		edi = edi_74 + 1;
		--ecx;
		esi_73 = esi;
		edi_74 = edi;
		if (*esi_73 == *edi_74)
			break;
	}
	if (!v11_41)
		eax_28 = 0x01;
	return eax_28;
}

// 080482DF: Register word32 fn080482DF(Register (ptr32 byte) esi)
// Called from:
//      fn0804804C
//      fn0804809D
word32 fn080482DF(byte * esi)
{
	if (esi != null)
	{
		word32 ecx_12 = 0x00;
		while (true)
		{
			++esi;
			if (*esi == 0x00)
				break;
			++ecx_12;
		}
		__syscall(0x80);
		eax = ecx_12;
	}
	return eax;
}

byte g_b8048316 = 66; // 08048316
byte g_b8048349 = 0x53; // 08048349
byte g_b804835A = 0x53; // 0804835A
byte g_b8048366 = 0x49; // 08048366
byte g_b8048370 = 0x44; // 08048370
byte g_b8048379 = 0x54; // 08048379
byte g_b8048387 = 0x0A; // 08048387
byte g_b8048389 = 0x2E; // 08048389
byte g_b804838B = 0x20; // 0804838B
byte g_b8048390 = 0x5B; // 08048390
byte g_b8048392 = 0x5D; // 08048392
byte g_b8048394 = 0x7B; // 08048394
byte g_b8048396 = 0x7D; // 08048396
byte g_b8048398 = 77; // 08048398
byte g_b804839B = 0x00; // 0804839B
// subject_seg08048000_0004.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_a808839B[] = // 0808839B
	{
	};
