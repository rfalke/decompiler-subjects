// subject_seg08048000_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Register Eq_2 edx)
void fn0804804C(Eq_2 edx)
{
	Eq_3 eax_16 = sys_open(&g_b8048300, 0x00, edx);
	if (eax_16 >= 0x00)
	{
		eax_16 = sys_read(eax_16, &g_b804839B, 0x00040000);
		if (eax_16 != 0x00)
		{
			sys_close(eax_16);
			eax_16 = fn080482DF(&g_b8048316);
			fn0804809D(eax_16, &g_b804839B);
		}
	}
	sys_exit(eax_16);
}

// 0804809D: void fn0804809D(Register Eq_3 ecx, Register (ptr32 byte) esi)
// Called from:
//      fn0804804C
void fn0804809D(Eq_3 ecx, byte * esi)
{
	byte * dwLoc08_500 = esi;
	Eq_3 dwLoc0C_501 = ecx;
	up32 dwLoc10_502 = 0x00;
	while (true)
	{
		Eq_3 ecx_17 = dwLoc0C_501;
		if (dwLoc0C_501 == 0x00)
			break;
		byte * esi_25 = dwLoc08_500;
		byte * edi_26 = g_a808839B;
		do
		{
			byte al_29 = *esi_25;
			*edi_26 = al_29;
			++esi_25;
			++edi_26;
			if (al_29 == 0x0A)
				break;
			--ecx_17;
		} while (ecx_17 != 0x00);
		*edi_26 = 0x00;
		dwLoc08_500 = esi_25;
		dwLoc0C_501 = ecx_17;
		if (fn080482CF(0x08, esi_25, &g_t8048379) == 0x00)
		{
			dwLoc10_502 = 0x01;
			struct Eq_89 * esi_294 = esi_25 + 8;
			do
			{
				esi_294 = esi_636 + 1;
				esi_636 = esi_294;
			} while (esi_636->b0000 != 0x20);
			esi_294->bFFFFFFFF = 0x00;
			fn080482DF(esi_25 + 8);
			fn080482DF(&g_b8048389);
			struct Eq_110 * esi_331 = esi_25 + 31;
			do
			{
				esi_331 = esi_637 + 1;
				esi_637 = esi_331;
			} while (esi_637->b0000 != 0x20);
			esi_331->bFFFFFFFF = 0x00;
			fn080482DF(esi_25 + 31);
			fn080482DF(&g_b8048389);
			struct Eq_132 * esi_368 = esi_25 + 46;
			do
			{
				esi_368 = esi_638 + 1;
				esi_638 = esi_368;
			} while (esi_638->b0000 == 0x20);
			do
			{
				esi_368 = esi_639 + 1;
				esi_639 = esi_368;
			} while (esi_639->b0000 != 0x20);
			esi_368->bFFFFFFFF = 0x00;
			fn080482DF(esi_25 + 46);
			fn080482DF(&g_b8048390);
			struct Eq_162 * esi_412 = esi_25 + 54;
			do
			{
				esi_412 = esi_640 + 1;
				esi_640 = esi_412;
			} while (esi_640->b0000 != 0x20);
			esi_412->bFFFFFFFF = 0x00;
			int32 ecx_439 = 0x04 - fn080482DF(esi_25 + 54);
			if (ecx_439 > 0x00)
			{
				do
				{
					fn080482DF(&g_b804838B);
					--ecx_439;
				} while (ecx_439 != 0x00);
			}
			fn080482DF(&g_b8048398);
			fn080482DF(&g_b8048392);
			fn080482DF(&g_b804838B);
		}
		else if (fn080482CF(0x09, esi_25, &g_t8048370) == 0x00)
		{
			struct Eq_210 * esi_241 = esi_25 + 9;
			do
			{
				esi_241 = esi_635 + 1;
				esi_635 = esi_241;
			} while (esi_635->b0000 != 0x20);
			esi_241->bFFFFFFFF = 0x00;
			if (dwLoc10_502 <= 0x00)
			{
				word32 ecx_256;
				for (ecx_256 = 0x12; ecx_256 != 0x00; --ecx_256)
					fn080482DF(&g_b804838B);
			}
			fn080482DF(esi_25 + 9);
			fn080482DF(&g_b804838B);
		}
		else if (fn080482CF(0x11, esi_25, &g_t8048349) == 0x00)
		{
			struct Eq_248 * esi_197 = esi_25 + 0x0011;
			do
			{
				esi_197 = esi_634 + 1;
				esi_634 = esi_197;
			} while (esi_634->b0000 != 0x0A);
			esi_197->bFFFFFFFF = 0x00;
			fn080482DF(&g_b8048390);
			fn080482DF(esi_25 + 0x0011);
			esi_197->bFFFFFFFF = 0x0A;
			fn080482DF(&g_b8048392);
		}
		else if (fn080482CF(0x0C, esi_25, &g_t804835A) == 0x00)
		{
			struct Eq_282 * esi_171 = esi_25 + 0x0C;
			do
			{
				esi_171 = esi_633 + 1;
				esi_633 = esi_171;
			} while (esi_633->b0000 != 0x0A);
			esi_171->bFFFFFFFF = 0x00;
			fn080482DF(esi_25 + 0x0C);
			esi_171->bFFFFFFFF = 0x0A;
		}
		else if (fn080482CF(0x0A, esi_25, &g_t8048366) == 0x00)
		{
			struct Eq_304 * esi_115 = esi_25 + 62;
			do
			{
				esi_115 = esi_632 + 1;
				esi_632 = esi_115;
			} while (esi_632->b0000 != 0x0A);
			esi_115->bFFFFFFFF = 0x00;
			fn080482DF(&g_b8048394);
			fn080482DF(esi_25 + 62);
			esi_115->bFFFFFFFF = 0x0A;
			fn080482DF(&g_b8048396);
			fn080482DF(&g_b8048387);
		}
	}
}

// 080482CF: Register ui32 fn080482CF(Register uint32 ecx, Register (ptr32 byte) esi, Register (ptr32 Eq_59) edi)
// Called from:
//      fn0804809D
ui32 fn080482CF(uint32 ecx, byte * esi, <unknown>* edi)
{
	ui32 eax_10 = 0x00;
	Eq_338 cmpResult_12 = memcmp(esi, edi, ecx);
	if (cmpResult_12 != 0x00)
		eax_10 = 0x00 - (word32) (cmpResult_12 < 0x00) | 0x01;
	return eax_10;
}

// 080482DF: Register Eq_22 fn080482DF(Register (ptr32 char) esi)
// Called from:
//      fn0804804C
//      fn0804809D
Eq_22 fn080482DF(char * esi)
{
	Eq_22 eax;
	if (esi != null)
	{
		size_t ecx_14 = 0x00;
		esi_18 = esi;
		while (true)
		{
			char * esi_18;
			++esi_18;
			if (*esi_18 == 0x00)
				break;
			ecx_14 = (Eq_22) ((word32) ecx_14 + 1);
		}
		sys_write(0x01, esi, ecx_14);
		eax = ecx_14;
	}
	return eax;
}

char g_b8048300 = '/'; // 08048300
char g_b8048316 = 'B'; // 08048316
Eq_59 g_t8048349 = // 08048349;
Eq_59 g_t804835A = // 0804835A;
Eq_59 g_t8048366 = // 08048366;
Eq_59 g_t8048370 = // 08048370;
Eq_59 g_t8048379 = // 08048379;
char g_b8048387 = '\n'; // 08048387
char g_b8048389 = '.'; // 08048389
char g_b804838B = ' '; // 0804838B
char g_b8048390 = '['; // 08048390
char g_b8048392 = ']'; // 08048392
char g_b8048394 = '{'; // 08048394
char g_b8048396 = '}'; // 08048396
char g_b8048398 = 'M'; // 08048398
char g_b804839B = '\0'; // 0804839B
// subject_seg08048000_0004.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_a808839B[] = // 0808839B
	{
	};
