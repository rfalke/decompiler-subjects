// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_43 g_t804804C = // 0804804C
	{
		
		{
			0x007D
		},
		0x1F,
	};
// 0804922A: void fn0804922A(Register (ptr32 Eq_2) esi, Stack word32 dwArg00, Stack uint32 dwArg04)
void fn0804922A(union Eq_2 * esi, word32 dwArg00, uint32 dwArg04)
{
	int32 ebx_58 = dwArg00 - 0x01;
	if (dwArg00 == 0x01)
		fn08049250(&g_t804804C, esi, dwArg04);
	else
	{
		union Eq_2 * esi_24 = fp + 0x08;
		uint32 dwArg00_75 = 0x00;
		do
		{
			byte bArg00_77 = (byte) dwArg00_75;
			word24 nArg01_79 = SLICE(dwArg00_75, word24, 8);
			word32 * eax_29 = *esi_24;
			esi_24 = (union Eq_2 *) ((char *) esi_24 + 4);
			if (eax_29 == null)
			{
				fn08049250(&g_t804804C, esi_24, dwArg00_75);
				return;
			}
			--ebx_58;
			dwArg00_75 = SEQ(nArg01_79, bArg00_77 | SLICE((uint32) fn080492F1(eax_29, 0x0804804C), byte, 8));
		} while (ebx_58 >= 0x00);
		fn08049250(&g_t804804C, esi_24, dwArg00_75);
	}
}

// 08049250: Register word32 fn08049250(Register (ptr32 Eq_43) ebp, Register (ptr32 Eq_2) esi, Stack uint32 dwArg00)
// Called from:
//      fn0804922A
//      fn08049319
word32 fn08049250(struct Eq_43 * ebp, union Eq_2 * esi, uint32 dwArg00)
{
	do
	{
		word32 ebp_9;
		fn080492A1(0x00, ebp, esi, out ebp_9);
		union Eq_2 * ecx_19 = ebp_9 + 0x1187;
		while (true)
		{
			struct Eq_68 * esi_27;
			fn080492D9(ecx_19, out esi_27);
			__syscall(0x80);
			union Eq_2 * esi_40 = esi_27->ptrFFFFFFF8;
			Eq_58 ecx_46 = fn08049319(esi_40, out ebp);
			esi = esi_40;
			dwArg00 = (char *) &ebp->dw1148 + 0x00D6;
			if (dwArg00 >> 0x01 >= 0x00)
				break;
			ecx_19 = (union Eq_2 *) (ebp + 1);
		}
	} while (dwArg00 >> 0x02 < 0x00);
	if (dwArg00 >> 0x03 >= 0x00)
	{
		word32 ebp_117;
		return fn080492A1(ecx_46, ebp, esi_40, out ebp_117);
	}
	else
	{
		word32 edx_81 = ebp->dw1148;
		word32 ebp_119;
		return fn080492AD(eax, edx_81 + 0x01, esi_40, out ebp_119);
	}
}

// 080492A1: Register word32 fn080492A1(Register Eq_58 eax, Register (ptr32 Eq_43) ebp, Register (ptr32 Eq_2) esi, Register out ptr32 ebpOut)
// Called from:
//      fn0804922A
//      fn08049250
word32 fn080492A1(Eq_58 eax, struct Eq_43 * ebp, union Eq_2 * esi, ptr32 & ebpOut)
{
	Eq_58 edx_6 = ebp->t0E40;
	ptr32 ebp_10;
	word32 ecx_12 = fn080492AD(eax, edx_6, esi, out ebp_10);
	ebpOut = ebp_10;
	return ecx_12;
}

// 080492AD: Register word32 fn080492AD(Register Eq_58 eax, Register Eq_58 edx, Register (ptr32 Eq_2) esi, Register out ptr32 ebpOut)
// Called from:
//      fn08049250
//      fn080492A1
word32 fn080492AD(Eq_58 eax, Eq_58 edx, union Eq_2 * esi, ptr32 & ebpOut)
{
	if (eax >= 0x00)
	{
		ptr32 ebp_41;
		word32 ecx_43 = fn080492B3(eax, edx, esi, out ebp_41);
		ebpOut = ebp_41;
		return ecx_43;
	}
	else
	{
		ptr32 ebp_52;
		word32 ecx_54 = fn080492B1(eax, edx, esi, out ebp_52);
		ebpOut = ebp_52;
		return ecx_54;
	}
}

// 080492B1: Register word32 fn080492B1(Register Eq_58 eax, Register Eq_58 edx, Register (ptr32 Eq_2) esi, Register out ptr32 ebpOut)
// Called from:
//      fn080492A1
//      fn080492AD
word32 fn080492B1(Eq_58 eax, Eq_58 edx, union Eq_2 * esi, ptr32 & ebpOut)
{
	Eq_58 eax_5 = -eax;
	ptr32 ebp_11;
	word32 ecx_13 = fn080492B3(eax_5, edx, esi, out ebp_11);
	ebpOut = ebp_11;
	return ecx_13;
}

// 080492B3: Register word32 fn080492B3(Register Eq_58 eax, Register Eq_58 edx, Register (ptr32 Eq_2) esi, Register out ptr32 ebpOut)
// Called from:
//      fn080492A1
//      fn080492AD
word32 fn080492B3(Eq_58 eax, Eq_58 edx, union Eq_2 * esi, ptr32 & ebpOut)
{
	if (eax >= edx)
	{
		word32 esi_84;
		fn080492D9(esi, out esi_84);
	}
	ptr32 ebp_63;
	word32 edx_85;
	word32 esi_86;
	word32 ecx_65 = fn080492E5(out edx_85, out ebp_63, out esi_86);
	ebpOut = ebp_63;
	return ecx_65;
}

// 080492D9: Register word32 fn080492D9(Register (ptr32 Eq_2) ecx, Register out ptr32 esiOut)
// Called from:
//      fn0804922A
//      fn080492A1
word32 fn080492D9(union Eq_2 * ecx, ptr32 & esiOut)
{
	byte * edx_27 = ecx - 0x01;
	do
		++edx_27;
	while (*edx_27 != 0x00);
	word32 edx_42;
	ptr32 esi_43;
	word32 ebp_58;
	fn080492E5(out edx_42, out ebp_58, out esi_43);
	esiOut = esi_43;
	return edx_42;
}

// 080492E5: Register word32 fn080492E5(Register out ptr32 edxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut)
// Called from:
//      fn080492A1
//      fn080492D9
word32 fn080492E5(ptr32 & edxOut, ptr32 & ebpOut, ptr32 & esiOut)
{
	if (SZO)
	{
		edxOut = dwArg14;
		ebpOut = dwArg08;
		esiOut = dwArg04;
		return dwArg18;
	}
	else
	{
		ptr32 ebp_37;
		ptr32 edx_41;
		ptr32 esi_42;
		word32 ecx_39 = fn080492E7(out edx_41, out ebp_37, out esi_42);
		edxOut = edx_41;
		ebpOut = ebp_37;
		esiOut = esi_42;
		return ecx_39;
	}
}

// 080492E7: Register word32 fn080492E7(Register out ptr32 edxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut)
// Called from:
//      fn080492D9
//      fn080492E5
word32 fn080492E7(ptr32 & edxOut, ptr32 & ebpOut, ptr32 & esiOut)
{
	__syscall(0x80);
	edxOut = dwArg14;
	ebpOut = dwArg08;
	esiOut = dwArg04;
	return dwArg18;
}

// 080492F1: Register byte fn080492F1(Register (ptr32 word32) eax, Register ptr32 ebp)
// Called from:
//      fn0804922A
byte fn080492F1(word32 * eax, ptr32 ebp)
{
	word32 ebx_10 = *eax;
	word16 bx_65 = (word16) ebx_10;
	byte dh_38 = 0x00;
	uint8 dl_40 = 0x08;
	word16 * esi_16 = ebp + 0x114C;
	do
	{
		word32 * esi_20 = esi_16 + 1;
		word16 ax_19 = *esi_16;
		word32 eax_24 = *esi_20;
		esi_16 = (word16 *) (esi_20 + 1);
		word32 edx_100 = SEQ(0x00, dh_38, dl_40);
		if (eax_24 == 0x00)
			return SLICE(edx_100, byte, 8);
		if (bx_65 == ax_19 || ebx_10 == eax_24)
			dh_38 |= dl_40;
		dl_40 >>= 0x01;
		edx_100 = SEQ(0x00, dh_38, dl_40);
	} while (dl_40 != 0x00);
	return SLICE(edx_100, byte, 8);
}

// 08049319: Register uint32 fn08049319(Register (ptr32 Eq_2) esi, Register out ptr32 ebpOut)
// Called from:
//      fn08049250
uint32 fn08049319(union Eq_2 * esi, ptr32 & ebpOut)
{
	uint32 eax_5 = *esi;
	char al_13 = (byte) eax_5;
	byte ah_20 = SLICE(eax_5, byte, 8);
	uint32 ecx_6 = 0x00;
	if (al_13 == 0x2D)
	{
		esi = (union Eq_2 *) ((char *) esi + 1);
		al_13 = (byte) (eax_5 >> 0x08);
		ah_20 = SLICE(eax_5 >> 0x08, byte, 8);
	}
	if (al_13 == 0x30)
	{
		uint32 ebx_100 = 0x00;
		Eq_299 ch_41 = 0x08;
		byte cl_101 = 0x03;
		if (ah_20 == 0x78)
		{
			esi = (union Eq_2 *) ((char *) esi + 2);
			ch_41.u0 = 0x10;
			cl_101 = 0x04;
		}
		while (true)
		{
			Eq_319 al_31 = *esi;
			esi = (union Eq_2 *) ((char *) esi + 1);
			Eq_299 al_33 = al_31 - 0x30;
			if (al_31 < 0x30)
				break;
			if (al_31 >= 0x3A)
			{
				al_33 = al_31 - 55;
				if (al_31 < 55)
					break;
				if (al_31 - 55 < ch_41)
					goto l08049374;
				al_33 = al_31 - 0x57;
			}
			if (al_33 >= ch_41)
				break;
l08049374:
			ui32 ebx_56 = ebx_100 << cl_101;
			ebx_100 = SEQ(SLICE(ebx_56, word24, 8), (byte) ebx_56 | al_33);
		}
		ebpOut = <invalid>;
		return ebx_100;
	}
	else if (al_13 < 0x30 || al_13 > 0x39)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		uint32 stackArg0 = <invalid>;
		uint32 ecx_73 = fn08049250(ebp, esi, stackArg0);
		ebpOut = <invalid>;
		return ecx_73;
	}
	else
	{
		while (true)
		{
			Eq_310 al_79 = *esi;
			esi = (union Eq_2 *) ((char *) esi + 1);
			if (al_79 < 0x30)
				break;
			uint32 eax_89 = (uint32) (al_79 - 0x30);
			if (al_79 >= 0x3A)
				break;
			ecx_6 = eax_89 + ecx_6 * 0x0A;
		}
		ebpOut = <invalid>;
		return ecx_6;
	}
}

