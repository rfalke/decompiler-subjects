//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2);
int32_t function_80492a1(void);
int32_t function_80492ad(void);
int32_t function_80492d9(void);
int32_t function_80492e5(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t result);
int32_t function_80492f1(void);
int32_t function_8049319(void);

// ------------------------ Functions -------------------------

// Address range: 0x804922a - 0x80492a1
int32_t entry_point(int32_t a1, int32_t a2) {
    int32_t v1 = a2;
    int32_t v2 = a2 - 1; // 0x8049237
    int32_t v3; // 0x804922a
    int32_t v4 = &v3; // 0x8049238
    int32_t * v5; // 0x804922a
    int32_t v6; // 0x804922a
    int32_t v7; // 0x804922a
    int32_t v8; // 0x804922a
    if (v2 == 0) {
        goto lab_0x8049250;
    } else {
        // 0x804923a
        v1 = 0;
        int32_t v9 = &v1; // 0x804923e
        int32_t v10 = v2; // 0x804923e
        int32_t v11; // bp+12, 0x804922a
        int32_t v12 = &v11; // 0x804923e
        bool v13; // 0x804922a
        int32_t v14 = v12 + (v13 ? -4 : 4); // 0x8049240
        while (*(int32_t *)v12 != 0) {
            // 0x8049245
            function_80492f1();
            int32_t v15; // 0x804922a
            v1 = 0x1000000 * (v1 | (uint32_t)v15 / 256) / 0x1000000;
            v10--;
            v12 = v14;
            v4 = v9;
            v6 = v14;
            if (v10 < 0) {
                goto lab_0x8049250;
            }
            v14 = v12 + (v13 ? -4 : 4);
        }
        // 0x8049271
        v5 = (int32_t *)(v9 - 4);
        v8 = v9;
        v7 = v14;
        goto lab_0x8049271;
    }
  lab_0x8049250:
    // 0x8049250
    function_80492a1();
    int32_t v16 = v4; // 0x804925d
    int32_t v17 = v6; // 0x804925d
    goto lab_0x8049265;
  lab_0x8049265:
    // 0x8049265
    function_80492d9();
    int32_t * v18 = (int32_t *)(v16 - 4);
    *v18 = 1;
    __asm_int(128);
    v5 = v18;
    v8 = v16;
    v7 = v17;
    goto lab_0x8049271;
  lab_0x8049271:;
    int32_t v19 = v8;
    *v5 = *(int32_t *)(v7 - 8);
    function_8049319();
    int32_t v20 = *v5; // 0x804927a
    int32_t * v21 = (int32_t *)v19; // 0x8049283
    uint32_t v22 = *v21; // 0x8049283
    *v21 = a1 + 59;
    v16 = v19;
    v17 = v20;
    if (v22 % 2 == 0) {
        // 0x804928a
        v4 = v19;
        v6 = v20;
        if ((v22 & 2) == 0) {
            if ((v22 & 4) == 0) {
                function_80492a1();
            }
            // 0x8049292
            return function_80492ad();
        }
        goto lab_0x8049250;
    } else {
        goto lab_0x8049265;
    }
}

// Address range: 0x80492a1 - 0x80492ad
int32_t function_80492a1(void) {
    // 0x80492a1
    int32_t result; // 0x80492a1
    return result;
}

// Address range: 0x80492ad - 0x80492d3
int32_t function_80492ad(void) {
    // 0x80492ad
    int32_t v1; // 0x80492ad
    int32_t v2 = v1;
    int32_t v3 = v1;
    int32_t v4 = v3 >= 0 ? v3 : -v3;
    if (v4 >= v1) {
        // 0x80492b7
        function_80492d9();
    }
    int32_t v5 = v2 + (int32_t)*(int16_t *)(v2 - 2 + 2 * v4); // 0x80492c7
    int16_t v6 = *(int16_t *)v5; // 0x80492c9
    int32_t v7; // 0x80492ad
    return function_80492e5(v1, v1, v1, &v7, v1, (int32_t)v6 - 1, v5 + 3);
}

// Address range: 0x80492d9 - 0x80492e5
int32_t function_80492d9(void) {
    // 0x80492d9
    int32_t result; // 0x80492d9
    int32_t v1 = result - 1; // 0x80492da
    while (*(char *)(v1 + 1) != 0) {
        // 0x80492dd
        v1++;
    }
    // 0x80492e3
    return result;
}

// Address range: 0x80492e5 - 0x80492f1
int32_t function_80492e5(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t result) {
    // 0x80492e5
    bool v1; // 0x80492e5
    if (!v1 && true) {
        // 0x80492e7
        __asm_int(128);
    }
    // 0x80492ef
    return result;
}

// Address range: 0x80492f1 - 0x8049319
int32_t function_80492f1(void) {
    char v1 = 8; // 0x80492f8
    int32_t v2; // 0x80492f1
    bool v3; // 0x80492f1
    int32_t v4 = v2 + 0x114c + (v3 ? -2 : 2); // 0x80492fe
    int32_t result = *(int32_t *)v4; // 0x8049302
    while (result != 0) {
        unsigned char v5 = v1;
        v1 = v5 / 2;
        if (v5 < 2) {
            // break -> 0x8049316
            break;
        }
        v4 = v4 + (v3 ? -4 : 4) + (v3 ? -2 : 2);
        result = *(int32_t *)v4;
    }
    // 0x8049316
    return result;
}

// Address range: 0x8049319 - 0x804937a
int32_t function_8049319(void) {
    // 0x8049319
    int32_t v1; // 0x8049319
    uint32_t v2 = v1;
    int32_t result2 = (char)v2 != 45 ? v2 : v2 / 256;
    int32_t v3 = v2 + (int32_t)((char)v2 == 45);
    unsigned char v4 = (char)result2; // 0x8049325
    char v5 = v4 - 48; // 0x8049325
    int32_t v6; // 0x8049319
    char v7; // 0x8049319
    int32_t v8; // 0x8049319
    char v9; // 0x8049319
    int32_t v10; // 0x8049319
    int32_t v11; // 0x8049319
    int32_t v12; // 0x8049319
    unsigned char v13; // 0x8049319
    if (v5 == 0) {
        int32_t v14 = (result2 & 0xff00) != 0x7800 ? v3 : v3 + 2;
        unsigned char v15 = *(char *)v14; // 0x804935a
        int32_t v16 = result2 & -256; // 0x804935a
        char v17 = v15 - 48; // 0x804935b
        int32_t result = v16 | (int32_t)v17; // 0x804935b
        if (v15 < 48) {
            // 0x804933a
            return result;
        }
        // 0x8049362
        v13 = (result2 & 0xff00) != 0x7800 ? 8 : 16;
        v6 = result;
        v7 = v17;
        v12 = v14;
        v8 = v16;
        v9 = v15;
        while (true) {
          lab_0x8049362:
            // 0x8049362
            v10 = v6;
            if (v7 < 10) {
                goto lab_0x8049370;
            } else {
                char v18 = v9;
                int32_t v19 = v8;
                v11 = v19;
                if (v18 - 55 < v13) {
                    goto lab_0x8049374;
                } else {
                    // 0x804936e
                    v10 = v19 | (int32_t)(v18 - 87);
                    goto lab_0x8049370;
                }
            }
        }
    }
    // 0x8049329
    if (v4 < 58 != v5 > -1) {
        // 0x804933a
        return result2;
    }
    unsigned char v20 = *(char *)v3; // 0x8049331
    unsigned char v21 = v20 - 48; // 0x8049332
    int32_t result3 = v21; // 0x8049332
    if (v20 > 47 != v21 < 10) {
        // 0x804933a
        return result3;
    }
    int32_t v22 = result3; // 0x8049332
    int32_t v23 = v3; // 0x8049331
    bool v24; // 0x8049319
    v23 += (v24 ? -1 : 1);
    unsigned char v25 = *(char *)v23; // 0x8049331
    unsigned char v26 = v25 - 48; // 0x8049332
    v22 = v22 & -256 | (int32_t)v26;
    int32_t result4 = v22; // 0x8049334
    while (v25 > 47 == v26 < 10) {
        // 0x8049340
        v23 += (v24 ? -1 : 1);
        v25 = *(char *)v23;
        v26 = v25 - 48;
        v22 = v22 & -256 | (int32_t)v26;
        result4 = v22;
    }
  lab_0x804933a_2:
    // 0x804933a
    return result4;
  lab_0x8049370:
    // 0x8049370
    result4 = v10;
    v11 = v10;
    if (v13 <= (char)v10) {
        return result4;
    }
    goto lab_0x8049374;
  lab_0x8049374:;
    int32_t v27 = v12 + (v24 ? -1 : 1);
    unsigned char v28 = *(char *)v27; // 0x804935a
    int32_t v29 = v11 & -256; // 0x804935a
    char v30 = v28 - 48; // 0x804935b
    int32_t v31 = v29 | (int32_t)v30; // 0x804935b
    result4 = v31;
    v6 = v31;
    v7 = v30;
    v12 = v27;
    v8 = v29;
    v9 = v28;
    if (v28 < 48) {
        // break -> 0x804933a
        goto lab_0x804933a_2;
    }
    goto lab_0x8049362;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: elfcrypt (1.0)
// Detected functions: 7

