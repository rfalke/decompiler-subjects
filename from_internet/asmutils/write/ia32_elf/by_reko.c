// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048066: void fn08048066(Stack int32 dwArg00, Stack (ptr32 byte) dwArg08, Stack (ptr32 Eq_4) dwArg0C)
void fn08048066(int32 dwArg00, byte * dwArg08, <unknown>* dwArg0C)
{
	ptr32 fp;
	if (dwArg00 > 0x03 || dwArg00 == 0x01)
	{
		sys_write(0x01, &g_b80481ED, 0x1C);
		sys_exit(0x01);
	}
	else
	{
		word32 * esi_32 = fp + 8 + dwArg00 * 0x04;
		do
		{
			struct Eq_38 * eax_35 = *esi_32;
			++esi_32;
			if (eax_35 == null)
				goto l08048090;
		} while (eax_35->dw0000 != 0x52455355 || eax_35->b0004 != 0x3D);
		g_ptr8048274 = (byte *) (&eax_35->b0004 + 1);
l08048090:
		g_ptr8048270 = dwArg0C;
		byte * edi_55 = dwArg08;
		ptr32 esp_113 = fp + 0x0C;
		word32 ecx_60 = 0x20;
		while (ecx_60 != 0x00)
		{
			edi_55 = edi_318 + 1;
			--ecx_60;
			edi_318 = edi_55;
			if (*edi_318 != 0x00)
				break;
		}
		Eq_12 edx_126;
		char * ecx_125;
		Eq_62 ebx_123;
		ptr32 esp_124;
		uint32 ecx_78 = 0x20 - ecx_60 - 1;
		if (ecx_78 != 0x00)
		{
			g_t8048278.u0 = (int32) sys_open(&g_b8048243, 0x00, 0x00);
			sys_chdir(&g_b8048251);
			do
			{
				esp_113 = fp + 8;
				if (sys_read(g_t8048278.u0, &g_b8048280, 0x0180) == 0x00)
					goto l080481D4;
				memcmp(dwArg08, &g_t80482AC, ecx_78);
				if (ecx_78 != __find_first_difference__(dwArg08, &g_t80482AC))
					continue;
				<unknown>* esi_141 = g_ptr8048270;
				if (esi_141 != null)
				{
					memcmp(esi_141, &g_b8048288, 0x06);
					if (__find_first_difference__(esi_141, &g_b8048288) != 0x06)
						continue;
				}
				Eq_62 eax_170 = sys_open(&g_b8048288, 0x01, 0x0180);
				if (eax_170 > 0x00)
				{
					g_t804827C.u0 = (int32) eax_170;
					byte * edi_174 = &g_b8048400;
					byte * esi_175 = g_a804825A;
					word32 ecx_176;
					for (ecx_176 = 0x0D; ecx_176 != 0x00; --ecx_176)
					{
						*edi_174 = *esi_175;
						++esi_175;
						++edi_174;
					}
					byte * esi_179 = g_ptr8048274;
					byte * esi_180 = esi_179;
					if (esi_179 != null)
					{
						do
						{
							byte al_187 = *esi_180;
							*edi_174 = al_187;
							++esi_180;
							++edi_174;
						} while (al_187 != 0x00);
						*edi_174 = 0x0A;
						sys_write(g_t804827C.u0, &g_b8048400, edi_174 - 0x08048400);
					}
					sys_write(g_t804827C.u0, &g_b8048267, 0x09);
					while (true)
					{
						Eq_12 eax_233 = sys_read(0x00, &g_b8048400, 0x0100);
						esp_124 = fp + 8;
						ebx_123.u0 = g_t804827C.u0;
						if (eax_233 == 0x00)
							break;
						sys_write(ebx_123, &g_b8048400, eax_233);
					}
					ecx_125 = &g_b8048256;
					edx_126.u0 = 0x04;
					goto l080481E1;
				}
			} while (g_ptr8048270 == null);
			ebx_123.u0 = 0x02;
			esp_124 = fp + 8;
			ecx_125 = &g_b8048231;
			edx_126.u0 = 0x12;
		}
		else
		{
l080481D4:
			union Eq_62 * esp_121 = esp_113 - 4;
			esp_121->u0 = 0x02;
			ebx_123.u0 = esp_121->u0;
			esp_124 = (char *) esp_121 + 4;
			ecx_125 = &g_b8048209;
			edx_126.u0 = 0x28;
		}
l080481E1:
		word32 * esp_268 = esp_124 - 4;
		*esp_268 = 0x04;
		sys_write(ebx_123, ecx_125, edx_126);
		*esp_268 = 0x01;
		sys_exit(0x00);
	}
}

char g_b80481ED = 'U'; // 080481ED
char g_b8048209 = 'U'; // 08048209
char g_b8048231 = 'P'; // 08048231
char g_b8048243 = '/'; // 08048243
char g_b8048251 = '/'; // 08048251
char g_b8048256 = 'E'; // 08048256
byte g_a804825A[] = // 0804825A
	{
	};
char g_b8048267 = '\x1B'; // 08048267
<unknown> * g_ptr8048270 = null; // 08048270
byte * g_ptr8048274 = null; // 08048274
Eq_105 g_t8048278 = // 08048278
	{
		0
	};
Eq_62 g_t804827C = // 0804827C
	{
		0
	};
char g_b8048280 = '\0'; // 08048280
char g_b8048288 = '\0'; // 08048288
Eq_116 g_t80482AC = // 080482AC;
byte g_b8048400 = 0x00; // 08048400
