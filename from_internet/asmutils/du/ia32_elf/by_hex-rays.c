/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall __noreturn start(int@<eax>, unsigned int@<ebp>);
// int __usercall sub_8048102@<eax>(_BYTE *@<edi>);
void __fastcall sub_804825F(int, int);
void __fastcall sub_8048298(int);
// unsigned int __usercall sub_804829F@<eax>(unsigned int result@<eax>);
int __fastcall sub_80482C1(_BYTE *);

//-------------------------------------------------------------------------
// Data declarations

int dword_80482DD = 134515520; // weak
int dword_80482E1 = 134515520; // weak
char byte_80482E5; // weak
char byte_80482E6; // weak
char byte_80482E7; // weak
char byte_80482E8; // weak
char byte_80482E9; // weak
struct stat buf; // idb


//----- (0804804C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, unsigned int a2@<ebp>)
{
  _BYTE *v2; // esi
  const void *v3; // ecx
  int v4; // eax
  int v5; // eax
  char *v6; // esi
  char *v7; // edi
  char v8; // al
  char v9; // sf
  _BYTE *v10; // ecx
  _BYTE *v11; // [esp-8h] [ebp-8h]
  char *v12; // [esp-4h] [ebp-4h]

LABEL_1:
  if ( v11 )
  {
    LOBYTE(a1) = *v11;
    v2 = v11 + 1;
    if ( *v11 == 45 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  LOBYTE(a1) = *v2++;
                  if ( (_BYTE)a1 != 97 )
                    break;
                  ++byte_80482E6;
                }
                if ( (_BYTE)a1 != 115 )
                  break;
                ++byte_80482E7;
              }
              if ( (_BYTE)a1 != 116 )
                break;
              ++byte_80482E5;
            }
            if ( (_BYTE)a1 != 107 )
              break;
            ++byte_80482E8;
          }
          if ( (_BYTE)a1 != 100 )
            break;
          ++byte_80482E9;
        }
        if ( (_BYTE)a1 == 45 )
          break;
        if ( !(_BYTE)a1 )
          goto LABEL_1;
      }
    }
    else
    {
      a2 = 0;
    }
    while ( 1 )
    {
      v6 = v12;
      if ( !v12 )
        break;
      v7 = (char *)&buf.st_ctim.tv_nsec + 3;
      do
      {
        v8 = *v6++;
        *v7++ = v8;
      }
      while ( v8 );
      a1 = sub_8048102(v7 - 1);
      if ( !v9 )
      {
        a2 += a1;
        if ( !byte_80482E5 )
        {
          sub_804829F(a1);
          a1 = sub_80482C1(v10);
        }
      }
    }
  }
  if ( byte_80482E5 )
  {
    sub_804829F(a1);
    sub_804829F(a2);
    BYTE2(buf.st_ctim.tv_nsec) = 10;
    v4 = sys_write(1, v3, (char *)&buf.st_ctim.tv_nsec + 2 - (_BYTE *)v3 + 1);
  }
  v5 = sys_exit(0);
}
// 804809F: positive sp value 10 has been found
// 8048051: variable 'v11' is possibly undefined
// 80480C6: variable 'v3' is possibly undefined
// 80480D3: variable 'v12' is possibly undefined
// 80480E9: variable 'v9' is possibly undefined
// 80480FB: variable 'v10' is possibly undefined
// 80482E5: using guessed type char byte_80482E5;
// 80482E6: using guessed type char byte_80482E6;
// 80482E7: using guessed type char byte_80482E7;
// 80482E8: using guessed type char byte_80482E8;
// 80482E9: using guessed type char byte_80482E9;

//----- (08048102) --------------------------------------------------------
int __usercall sub_8048102@<eax>(_BYTE *a1@<edi>)
{
  int result; // eax
  char v2; // zf
  mode_t v3; // edx
  __uid_t st_uid; // ebx
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rt2
  int v7; // ebp
  int v8; // ecx
  int v9; // ebx
  _BYTE *v10; // edi
  int v11; // ecx
  int v12; // ecx
  int v13; // eax
  char *v14; // esi
  char v15; // al
  int v16; // eax
  char v17; // sf
  _BYTE *v18; // ecx
  unsigned int v19; // edx
  _BYTE *v20; // [esp-20h] [ebp-20h]
  int v21; // [esp-1Ch] [ebp-1Ch]
  unsigned int v22; // [esp-14h] [ebp-14h]
  int v23; // [esp-10h] [ebp-10h]

  result = sys_newlstat((const char *)&buf.st_ctim.tv_nsec + 3, &buf);
  if ( result >= 0 )
  {
    if ( (byte_80482E9 & 1) == 0 || (result = (buf.st_nlink + 511) / 0x200, v3 = (buf.st_nlink + 511) % 0x200, !v2) )
    {
      result = ((unsigned __int64)buf.st_gid << 9) / (buf.st_uid >> 2);
      v3 = ((unsigned __int64)buf.st_gid << 9) % (buf.st_uid >> 2);
    }
    if ( byte_80482E8 && result )
    {
      st_uid = 2048;
      if ( (byte_80482E9 & 1) == 0 )
        st_uid = buf.st_uid;
      v5 = st_uid * (unsigned __int64)(unsigned int)result;
      v6 = v5 % 0x1000;
      result = v5 / 0x1000;
      v3 = v6;
      if ( (_DWORD)v6 )
        ++result;
    }
    if ( (unsigned __int8)byte_80482E7 < 2u && (buf.__pad1 & 0xF000) == 0x4000 )
    {
      v7 = result;
      v9 = sys_open((char *)&buf.st_ctim.tv_nsec + 3, 0, v3);
      result = v7;
      if ( v9 >= 0 )
      {
        *a1 = 47;
        v10 = a1 + 1;
        sub_804825F(v8, 0x2000);
        v23 = v11;
        while ( 1 )
        {
          v12 = v23;
          v13 = 141;
          __asm { int     80h; LINUX - sys_getdents }
          do
          {
            v22 = v13;
            v21 = v12;
            v20 = v10;
            v14 = (char *)(v12 + 10);
            if ( *(_BYTE *)(v12 + 10) && *(_WORD *)v14 != 46 && (*(_WORD *)v14 != 11822 || *(_BYTE *)(v12 + 12)) )
            {
              do
              {
                v15 = *v14++;
                *v10++ = v15;
              }
              while ( v15 );
              v16 = sub_8048102(v10 - 1);
              if ( !v17 )
              {
                v7 += v16;
                if ( !byte_80482E5 && (byte_80482E6 || v16 >= 0 && v9 == 0x4000) )
                {
                  sub_804829F(v16);
                  sub_80482C1(v18);
                }
              }
            }
            v10 = v20;
            v19 = *(unsigned __int16 *)(v21 + 8);
            if ( !*(_WORD *)(v21 + 8) )
              break;
            v12 = v19 + v21;
            v13 = v22 - v19;
          }
          while ( v22 >= v19 );
        }
      }
    }
  }
  return result;
}
// 8048102: could not find valid save-restore pair for edi
// 8048135: variable 'v2' is possibly undefined
// 80481C6: variable 'v8' is possibly undefined
// 80481CB: variable 'v11' is possibly undefined
// 8048209: variable 'v17' is possibly undefined
// 8048230: variable 'v18' is possibly undefined
// 80482E5: using guessed type char byte_80482E5;
// 80482E6: using guessed type char byte_80482E6;
// 80482E7: using guessed type char byte_80482E7;
// 80482E8: using guessed type char byte_80482E8;
// 80482E9: using guessed type char byte_80482E9;

//----- (0804825F) --------------------------------------------------------
void __fastcall sub_804825F(int a1, int a2)
{
  char *v2; // ecx
  int v3; // eax

  v2 = (char *)(a2 + dword_80482DD);
  if ( a2 + dword_80482DD > (unsigned int)dword_80482E1 )
  {
    if ( sys_brk(v2) < 0 )
      v3 = sys_exit(1);
    dword_80482E1 = (int)v2;
  }
  dword_80482DD = (int)v2;
  *((_DWORD *)v2 - 1) = v2;
  *(_DWORD *)&v2[-a2] = &v2[-a2];
}
// 804827C: variable 'v2' is possibly undefined
// 804828B: variable 'a2' is possibly undefined
// 80482DD: using guessed type int dword_80482DD;
// 80482E1: using guessed type int dword_80482E1;

//----- (08048298) --------------------------------------------------------
void __fastcall sub_8048298(int a1)
{
  dword_80482DD = a1;
}
// 80482DD: using guessed type int dword_80482DD;

//----- (0804829F) --------------------------------------------------------
unsigned int __usercall sub_804829F@<eax>(unsigned int result@<eax>)
{
  _BYTE *v1; // edi

  BYTE2(buf.st_ctim.tv_nsec) = 9;
  v1 = (_BYTE *)(&buf + 77);
  do
  {
    *v1++ = result % 0xA + 48;
    result /= 0xAu;
  }
  while ( result );
  return result;
}

//----- (080482C1) --------------------------------------------------------
int __fastcall sub_80482C1(_BYTE *a1)
{
  _BYTE *v1; // edi
  size_t v2; // edx
  _BYTE *v4; // edi
  int result; // eax

  v1 = a1;
  v2 = 0;
  do
    ++v2;
  while ( *v1++ != 0 );
  v4 = v1 - 1;
  *v4 = 10;
  result = sys_write(1, a1, v2);
  *v4 = 0;
  return result;
}

// nfuncs=6 queued=6 decompiled=6 lumina nreq=0 worse=0 better=0
// ALL OK, 6 function(s) have been successfully decompiled
