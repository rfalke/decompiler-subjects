//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8048194(void);
int32_t function_8048205(void);
int32_t function_8048227(void);
int32_t function_8048233(void);
int32_t function_80484fd(void);
int32_t function_8048514(void);
int32_t function_8048522(void);
int32_t function_8048529(void);
int32_t function_804865e(void);
int32_t function_8048660(void);

// --------------------- Global Variables ---------------------

int16_t * g1 = NULL; // 0x8048867
int32_t g2 = 0; // 0x804886b
int16_t * g3 = NULL; // 0x804886f
int32_t g4 = 0; // 0x8048873
int16_t g5 = 0; // 0x804897b
char * g6; // 0x80489b3
int32_t g7 = 0; // 0x8048ab3
char * g8; // 0x8048ab7
int32_t g9 = 0; // 0x8048b1b
int32_t g10 = 0; // 0x8048b33
char * g11; // 0x8048b4b
char * g12; // 0x8048b53
int32_t g13 = 0; // 0x8048b54
int32_t g14 = 0; // 0x8048bb8
char g15 = 0; // 0x8048bbe
int32_t g16;

// ------------------------ Functions -------------------------

// Address range: 0x804804c - 0x80484fd
int32_t entry_point(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x804804c
    __asm_int(128);
    g3 = NULL;
    __asm_int(128);
    int32_t v1; // 0x804804c
    int32_t v2; // 0x804804c
    int32_t v3; // 0x804804c
    int32_t v4; // bp+16, 0x804804c
    if (a3 == 0) {
        // 0x804807f
        __asm_int(128);
        __asm_int(128);
        goto lab_0x8048098;
    } else {
        // 0x8048066
        switch (*(int16_t *)a3) {
            case 0x742d: {
                goto lab_0x8048098;
            }
            case 0x782d: {
                // 0x80480ac
                function_8048205();
                __asm_int(128);
                __asm_int(128);
                __asm_int(128);
                int32_t v5 = &v4; // 0x80480ce
                g7 = v5;
                function_8048233();
                function_8048227();
                v3 = v5;
                goto lab_0x80480e0;
            }
            case 0x632d: {
                int32_t v6 = &v4; // 0x8048491
                v3 = v6;
                if (a4 != 0) {
                    int16_t * v7 = (int16_t *)1; // 0x80484a1
                    int32_t v8; // 0x804804c
                    if (*(int16_t *)a4 != 45) {
                        // 0x80484a3
                        __asm_int(128);
                        v8 = v4;
                        v7 = (int16_t *)5;
                    }
                    // 0x80484ba
                    g1 = v7;
                    int32_t v9 = v6 + 4; // 0x80484bf
                    int32_t * v10 = &v4; // 0x80484c2
                    int32_t v11 = v9; // 0x80484c2
                    int32_t v12; // 0x804804c
                    if (v8 != 0) {
                        function_8048522();
                        function_8048529();
                        int32_t * v13 = (int32_t *)v9;
                        int32_t v14 = v9 + 4; // 0x80484bf
                        int32_t v15 = v14; // 0x80484c2
                        v12 = &g4;
                        v10 = v13;
                        v11 = v14;
                        while (*v13 != 0) {
                            // 0x80484c4
                            function_8048522();
                            function_8048529();
                            v13 = (int32_t *)v15;
                            v14 = v15 + 4;
                            v15 = v14;
                            v12 = &g4;
                            v10 = v13;
                            v11 = v14;
                        }
                    }
                    // 0x80484d5
                    function_8048514();
                    *v10 = 4;
                    __asm_int(128);
                    *v10 = 4;
                    __asm_int(128);
                    function_8048227();
                    v3 = v11;
                    v2 = 0;
                    v1 = v12;
                }
                goto lab_0x80480e0;
            }
            default: {
                // 0x804807f
                __asm_int(128);
                __asm_int(128);
                goto lab_0x8048098;
            }
        }
    }
  lab_0x8048106:;
    // 0x8048106
    int32_t v16; // 0x804804c
    int32_t v17 = v16 + 1; // 0x8048106
    int32_t v18; // 0x804804c
    int32_t v19 = v18; // 0x8048109
    int32_t v20; // 0x80480f8
    int32_t v21 = v20; // 0x8048109
    v16 = v17;
    int32_t result = v18; // 0x8048109
    if (v17 >= v1) {
        return result;
    }
    goto lab_0x80480ed;
  lab_0x8048098:
    // 0x8048098
    function_8048205();
    function_8048194();
    function_8048227();
    v3 = &v4;
    goto lab_0x80480e0;
  lab_0x80480e0:;
    int32_t * v27 = (int32_t *)(v3 - 4); // 0x80480e0
    *v27 = 1;
    __asm_int(128);
    *v27 = v2;
    int32_t * v26 = (int32_t *)(v3 - 8); // 0x80480ea
    *v26 = 8;
    v19 = 0;
    v21 = 0;
    v16 = v2;
    while (true) {
      lab_0x80480ed:;
        int32_t v22 = v19;
        unsigned char v23 = *(char *)v16; // 0x80480ed
        int32_t v24 = v21 & -256; // 0x80480ed
        v18 = v22;
        v20 = v24;
        result = v22;
        switch (v23) {
            case 0: {
                goto lab_0x8048116_2;
            }
            case 32: {
                goto lab_0x8048106;
            }
            default: {
                unsigned char v25 = v23 - 48;
                if (v23 > 47 != v25 < 8) {
                    // 0x804810d
                    *v26 = 1;
                    __asm_int(128);
                    result = 1;
                    goto lab_0x8048116_2;
                }
                // 0x8048102
                v20 = v24 | (int32_t)v25;
                v18 = v20 + 8 * v22;
                goto lab_0x8048106;
            }
        }
    }
  lab_0x8048116_2:
    // 0x8048116
    return result;
}

// Address range: 0x8048194 - 0x8048205
int32_t function_8048194(void) {
    // 0x8048194
    __asm_int(128);
    if (g14 != 0x61747375) {
        function_8048194();
    }
    // 0x80481b8
    int32_t v1; // 0x8048194
    int32_t * v2 = (int32_t *)((int32_t)&v1 - 4); // 0x80481d2
    int32_t v3 = (int32_t)&g6; // 0x80481bf
    int32_t v4 = 0; // 0x8048194
    int32_t v5 = v4 + v3; // 0x80481c4
    v4++;
    while (*(char *)v5 != 0) {
        // 0x80481c4
        v5 = v4 + v3;
        v4++;
    }
    // 0x80481cb
    *(int16_t *)v5 = 10;
    *v2 = 4;
    __asm_int(128);
    while (*(char *)&g12 < 51) {
        // 0x80481eb
        *v2 = 4;
        __asm_int(128);
        *(char *)&g12 = 0;
        v3 = &g13;
        v4 = 0;
        v5 = v4 + v3;
        v4++;
        while (*(char *)v5 != 0) {
            // 0x80481c4
            v5 = v4 + v3;
            v4++;
        }
        // 0x80481cb
        *(int16_t *)v5 = 10;
        *v2 = 4;
        __asm_int(128);
    }
    // 0x80481e9
    return function_8048194();
}

// Address range: 0x8048205 - 0x8048227
int32_t function_8048205(void) {
    int32_t result = 0; // 0x804820b
    int32_t v1; // 0x8048205
    if ((int16_t)v1 != 45) {
        // 0x804820d
        __asm_int(128);
        result = 5;
    }
    // 0x8048221
    g1 = (int16_t *)result;
    return result;
}

// Address range: 0x8048227 - 0x8048233
int32_t function_8048227(void) {
    // 0x8048227
    __asm_int(128);
    return 6;
}

// Address range: 0x8048233 - 0x804846f
int32_t function_8048233(void) {
    // 0x8048233
    int32_t v1; // 0x8048233
    int32_t * v2 = (int32_t *)(v1 - 4);
    uint32_t v3 = 512;
    *v2 = 3;
    __asm_int(128);
    int32_t v4 = v3 - 3; // 0x8048257
    while (v3 >= 3 && v4 != 0) {
        // 0x8048242
        v3 = v4;
        *v2 = 3;
        __asm_int(128);
        v4 = v3 - 3;
    }
    // 0x804825b
    if (g15 != 32 || g14 != 0x61747375) {
        // 0x8048266
        return 0;
    }
    int32_t v5 = *(int32_t *)g7; // 0x8048284
    if (v5 != 0) {
        int32_t v6 = (int32_t)&g6; // 0x8048233
        int32_t v7 = v5; // 0x8048233
        char v8 = *(char *)v6; // 0x804829a
        char v9 = *(char *)v7; // 0x804829b
        while (v8 == v9) {
            // 0x80482a2
            bool v10; // 0x8048233
            v6 += (v10 ? -1 : 1);
            v7++;
            if ((v9 || v8) == 0) {
                goto lab_0x80482a6;
            }
            v8 = *(char *)v6;
            v9 = *(char *)v7;
        }
        uint32_t v11 = g10 + 511; // 0x8048307
        if (v11 < 512) {
            // 0x8048329
            return function_8048233();
        }
        int32_t v12 = v11 / 512; // 0x8048310
        *v2 = 3;
        __asm_int(128);
        while (v12 != 1) {
            // 0x8048321
            v12--;
            *v2 = 3;
            __asm_int(128);
        }
        // 0x8048329
        return function_8048233();
    }
  lab_0x80482a6:;
    unsigned char v13 = *(char *)&g12; // 0x80482a8
    int32_t v14 = v13; // 0x80482ad
    if (v13 == 0) {
        // 0x80482b9
        g16 = v14;
        goto lab_0x80483cf;
    } else {
        int32_t result = v14; // 0x80482b3
        if (v13 >= 56) {
            // 0x8048266
            return result;
        }
        int32_t v15 = v13 - 48; // 0x80482b5
        g16 = v15;
        result = v15;
        switch (v13) {
            case 48: {
                goto lab_0x80483cf;
            }
            case 49: {
                // 0x8048348
                *v2 = 9;
                __asm_int(128);
                return 9;
            }
            case 50: {
                // 0x804835d
                *v2 = 83;
                __asm_int(128);
                return 83;
            }
            case 51: {
                // 0x80483af
                g9 |= 0x2000;
                *v2 = 14;
                __asm_int(128);
                return 14;
            }
            case 52: {
                // 0x80483af
                g9 |= 0x6000;
                *v2 = 14;
                __asm_int(128);
                return 14;
            }
            case 53: {
                goto lab_0x8048330;
            }
            case 54: {
                // 0x8048372
                g9 |= 0x1000;
                *v2 = 14;
                __asm_int(128);
                return 14;
            }
            case 55: {
                // 0x804832e
                __asm_int(3);
              lab_0x8048330:
                // 0x8048330
                *v2 = 39;
                __asm_int(128);
                return 0;
            }
            default: {
                return result;
            }
        }
    }
  lab_0x80483cf:
    // 0x80483cf
    *v2 = 5;
    __asm_int(128);
    g2 = 5;
    int32_t v16 = g10; // 0x8048402
    while (v16 != 0) {
        uint32_t v17 = 512;
        *v2 = 3;
        __asm_int(128);
        int32_t v18 = v17 - 3; // 0x8048419
        while (v17 >= 3 && v18 != 0) {
            // 0x8048408
            v17 = v18;
            *v2 = 3;
            __asm_int(128);
            v18 = v17 - 3;
        }
        int32_t v19 = v16 - 512; // 0x8048421
        *v2 = 4;
        __asm_int(128);
        v16 = v19;
        if (v19 < 0) {
            // break -> 0x8048449
            break;
        }
    }
    // 0x8048449
    *v2 = 6;
    __asm_int(128);
    return 6;
}

// Address range: 0x80484fd - 0x8048514
int32_t function_80484fd(void) {
    int32_t v1 = 0; // bp-4, 0x80484fd
    int32_t v2; // 0x80484fd
    int32_t v3 = v2 - 1; // 0x8048502
    int32_t v4 = &v1;
    int32_t v5; // 0x80484fd
    int32_t v6 = v5 % 8 | 48; // 0x8048507
    int32_t v7 = v4 - 4; // 0x804850a
    *(int32_t *)v7 = v6;
    v3--;
    v5 /= 8;
    while (v3 != 0) {
        // 0x8048503
        v4 = v7;
        v6 = v5 % 8 | 48;
        v7 = v4 - 4;
        *(int32_t *)v7 = v6;
        v3--;
        v5 /= 8;
    }
    // 0x804850d
    *(char *)v2 = (char)v6;
    int32_t v8 = v4; // 0x80484fd
    int32_t v9; // 0x80484fd
    bool v10; // 0x80484fd
    int32_t v11 = v9 + (v10 ? -1 : 1); // 0x804850e
    int32_t result = *(int32_t *)v8;
    *(char *)v11 = (char)result;
    v8 += 4;
    v9 = v11;
    while (result != 0) {
        // 0x804850d
        v11 = v9 + (v10 ? -1 : 1);
        result = *(int32_t *)v8;
        *(char *)v11 = (char)result;
        v8 += 4;
        v9 = v11;
    }
    // 0x8048513
    return result;
}

// Address range: 0x8048514 - 0x8048522
int32_t function_8048514(void) {
    // 0x8048514
    __asm_rep_stosd_memset((char *)&g8, 0, 128);
    return 0;
}

// Address range: 0x8048522 - 0x8048529
int32_t function_8048522(void) {
    // 0x8048522
    int32_t v1; // 0x8048522
    char v2 = v1;
    *(char *)v1 = v2;
    int32_t result = v1 & -256 | v1 % 256; // 0x8048526
    if (v2 != 0) {
        result = function_8048522();
    }
    // 0x8048528
    return result;
}

// Address range: 0x8048529 - 0x80486ff
int32_t function_8048529(void) {
    // 0x8048529
    __asm_int(128);
    function_8048514();
    function_80484fd();
    function_80484fd();
    function_80484fd();
    function_80484fd();
    *(int32_t *)((int32_t)&g9 + 121) = 0x61747375;
    *(int32_t *)((int32_t)&g9 + 125) = 0x202072;
    uint32_t v1 = (function_8048522() & -0x10000 | (int32_t)g5) / 0x1000; // 0x80485a5
    char v2 = 52; // 0x8048529
    switch ((char)v1) {
        case 10: {
            // 0x80485d5
            function_804865e();
            *(char *)&g12 = 50;
            __asm_int(128);
            // break -> 0x8048622
            break;
        }
        case 8: {
            // 0x8048670
            function_8048660();
            *(char *)&g12 = 48;
            __asm_int(128);
            // break -> 0x8048622
            break;
        }
        case 4: {
            // 0x80486f7
            *(char *)&g12 = 53;
            // break -> 0x8048622
            break;
        }
        case 2: {
            // 0x80485f6
            v2 = 51;
        }
        case 6: {
            // 0x80485f9
            *(char *)&g12 = v2;
            function_804865e();
            function_80484fd();
            function_80484fd();
            // break -> 0x8048622
            break;
        }
        default: {
            int32_t result = v1 - 1; // 0x80485c4
            if (result != 0) {
                // 0x804865d
                return result;
            }
            // 0x80485cb
            function_804865e();
            *(char *)&g12 = 54;
            // break -> 0x8048622
            break;
        }
    }
    // 0x8048622
    int32_t v3; // 0x8048529
    int32_t v4 = &v3; // 0x8048569
    int32_t * v5 = (int32_t *)(v4 - 4); // 0x804862c
    *v5 = (int32_t)&g11;
    *(int32_t *)(v4 - 8) = 8;
    __asm_rep_stosb_memset((char *)&g11, 32, 8);
    function_80484fd();
    *v5 = 4;
    __asm_int(128);
    // 0x804865d
    return 4;
}

// Address range: 0x804865e - 0x8048660
int32_t function_804865e(void) {
    // 0x804865e
    return 0;
}

// Address range: 0x8048660 - 0x8048670
int32_t function_8048660(void) {
    // 0x8048660
    return function_80484fd();
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: elfcrypt (1.0)
// Detected functions: 11

