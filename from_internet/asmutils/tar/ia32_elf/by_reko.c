// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Register word32 ebp, Register (ptr32 byte) esi, Register (ptr32 byte) edi, Register (ptr8 real64) Top, Stack (ptr32 word16) dwArg08, Stack (ptr32 word16) dwArg0C)
void fn0804804C(word32 ebp, byte * esi, byte * edi, real64 * Top, word16 * dwArg08, word16 * dwArg0C)
{
	__syscall(0x80);
	g_dw804886F = 0x00;
	__syscall(0x80);
	if (dwArg08 != null)
	{
		if (*dwArg08 == 0x742D)
		{
l08048098:
			fn08048205(dwArg0C);
			fn08048194();
			fn08048227();
			fn080480E0(esi, edi);
			return;
		}
		if (*dwArg08 == 0x782D)
		{
			fn08048205(dwArg0C);
			__syscall(0x80);
			__syscall(0x80);
			__syscall(0x80);
			g_ptr8048AB3 = fp + 16;
			byte * edi_63;
			byte * esi_66 = fn08048233(ebp, esi, edi, Top, 0x17, out edi_63);
			fn08048227();
			fn080480E0(esi_66, edi_63);
			return;
		}
		if (*dwArg08 == 0x632D)
		{
			fn08048493(edi, Top);
			return;
		}
	}
	__syscall(0x80);
	__syscall(0x80);
	goto l08048098;
}

// 080480E0: void fn080480E0(Register (ptr32 byte) esi, Register (ptr32 byte) edi)
// Called from:
//      fn0804804C
//      fn080484DC
void fn080480E0(byte * esi, byte * edi)
{
	__syscall(0x80);
	fn080480E5(esi, edi);
}

// 080480E5: Register uint32 fn080480E5(Register (ptr32 byte) esi, Register (ptr32 byte) edi)
// Called from:
//      fn080480E0
//      fn08048118
uint32 fn080480E5(byte * esi, byte * edi)
{
	uint32 eax_36 = 0x00;
	do
	{
		cu8 cl_16 = *esi;
		if (cl_16 == 0x00)
			return eax_36;
		if (cl_16 != 0x20)
		{
			if (cl_16 < 0x30)
			{
l0804810D:
				__syscall(0x80);
				eax_36 = 0x01;
				return eax_36;
			}
			uint32 ecx_43 = (uint32) (cl_16 - 0x30);
			if (cl_16 > 55)
				goto l0804810D;
			eax_36 = eax_36 * 0x08 + ecx_43;
		}
		++esi;
	} while (esi < edi);
	return eax_36;
}

// 08048118: Register word32 fn08048118(Register out ptr32 ediOut)
// Called from:
//      fn08048233
word32 fn08048118(ptr32 & ediOut)
{
	g_dw8048B33 = fn080480E5(&g_dw8048B33, &g_b8048B3F);
	g_dw8048B1B = fn080480E5(&g_dw8048B1B, &g_dw8048B23);
	g_dw8048B23 = fn080480E5(&g_dw8048B23, &g_dw8048B2B);
	g_dw8048B2B = fn080480E5(&g_dw8048B2B, &g_dw8048B33);
	ediOut = 0x08048B33;
	return 0x08048B2B;
}

// 0804816C: void fn0804816C()
// Called from:
//      fn08048194
//      fn08048233
void fn0804816C()
{
	byte * edi_27 = g_a80489B3;
	byte * esi_28 = g_a8048C10;
	uip32 ecx_43 = 0x9C;
	do
	{
		byte al_35 = *esi_28;
		*edi_27 = al_35;
		--ecx_43;
		++esi_28;
		++edi_27;
		word24 ecx_24_8_84 = SLICE(ecx_43, word24, 8);
	} while (al_35 != 0x00 && ecx_43 != 0x00);
	byte * edi_46 = edi_27 - 0x01;
	byte * esi_48 = g_a8048AB7;
	word32 ecx_60 = SEQ(ecx_24_8_84, 100);
	do
	{
		byte al_52 = *esi_48;
		*edi_46 = al_52;
		++esi_48;
		++edi_46;
		--ecx_60;
	} while (al_52 != 0x00 && ecx_60 != 0x00);
	*edi_46 = 0x00;
}

// 08048194: void fn08048194()
// Called from:
//      fn0804804C
void fn08048194()
{
	while (true)
	{
		__syscall(0x80);
		if (g_dw8048BB8 == 0x61747375)
		{
			fn0804816C();
			int32 edx_23 = 0x00;
			ptr32 ecx_26 = 134515123;
			while (true)
			{
				do
				{
					edx_23 = edx_77 + 0x01;
					edx_77 = edx_23;
				} while (ecx_26 + edx_77 >= 0x01);
				ecx_26 - 0x01 + edx_23 = (word16 *) 0x0A;
				__syscall(0x80);
				if (g_b8048B53 != 0x32 && g_b8048B53 != 0x31)
					break;
				__syscall(0x80);
				g_b8048B53 = 0x00;
				edx_23 = 0x00;
				ecx_26 = 0x08048B54;
			}
		}
	}
}

// 08048205: void fn08048205(Register (ptr32 word16) ebx)
// Called from:
//      fn0804804C
void fn08048205(word16 * ebx)
{
	word32 eax_11 = 0x00;
	if (*ebx != 0x2D)
	{
		__syscall(0x80);
		eax_11 = 0x05;
	}
	g_dw8048867 = eax_11;
}

// 08048227: void fn08048227()
// Called from:
//      fn0804804C
//      fn080484DC
void fn08048227()
{
	__syscall(0x80);
}

// 08048233: Register (ptr32 byte) fn08048233(Register word32 ebp, Register (ptr32 byte) esi, Register (ptr32 byte) edi, Register (ptr8 real64) Top, Stack word32 dwArg00, Register out (ptr32 byte) ediOut)
// Called from:
//      fn0804804C
byte * fn08048233(word32 ebp, byte * esi, byte * edi, real64 * Top, word32 dwArg00, byte & ediOut)
{
	while (true)
	{
		up32 edx_238;
		for (edx_238 = 0x0200; edx_238 > 0x00; edx_238 -= 0x03)
			__syscall(0x80);
		if (g_b8048BBE != 0x20)
			break;
		if (g_dw8048BB8 != 0x61747375)
		{
l080482F9:
			ediOut = edi;
			return esi;
		}
		fn0804816C();
		byte ** ebp_88 = g_ptr8048AB3;
		byte * edi_89 = *ebp_88;
		edi = edi_89;
		if (edi_89 != null)
		{
			byte * edi_95 = *ebp_88;
			esi = g_a80489B3;
			edi = edi_95;
			if (edi_95 == null)
			{
l080482FC:
				esi = fn08048118(out edi);
				uint32 ebp_124;
				for (ebp_124 = g_dw8048B33 + 0x01FF >> 0x09; ebp_124 != 0x00; --ebp_124)
					__syscall(0x80);
				continue;
			}
			do
			{
				byte al_104 = *esi;
				++esi;
				byte cl_107 = *edi;
				++edi;
				if (al_104 != cl_107)
					goto l080482FC;
			} while ((al_104 | cl_107) != 0x00);
		}
		cu8 al_148 = g_b8048B53;
		uint32 eax_158 = (uint32) al_148;
		if (al_148 != 0x00)
		{
			if (al_148 > 55)
				goto l080482F9;
			eax_158 = (uint32) (al_148 - 0x30);
			if (al_148 >= 0x30)
				goto l080482B9;
			goto l080482F9;
		}
l080482B9:
		struct Eq_347 * esp_169;
		int32 eax_173;
		word32 ebp_175;
		(*((char *) g_a804846F + eax_158 * 0x04))();
		if (eax_173 < 0x00)
			goto l080482F9;
		esp_169->dwFFFFFFFC = 0x10;
		__syscall(0x80);
		if (g_b8048B53 != 0x32)
		{
			esp_169->dwFFFFFFFC = 0x0F;
			__syscall(0x80);
		}
	}
	ediOut = edi;
	return esi;
}

<anonymous> * g_a804846F[] = // 0804846F
	{
	};
// 08048493: void fn08048493(Register (ptr32 byte) edi, Register (ptr8 real64) Top)
// Called from:
//      fn0804804C
//      fn08048233
void fn08048493(byte * edi, real64 * Top)
{
	*edi = (byte) (int32) trunc(*Top);
}

// 080484DC: void fn080484DC(Register (ptr32 byte) esi, Register (ptr32 byte) edi)
// Called from:
//      fn08048233
//      fn08048493
void fn080484DC(byte * esi, byte * edi)
{
	__syscall(0x80);
	__syscall(0x80);
	fn08048227();
	fn080480E0(esi, edi);
}

// 080484FD: Register uint32 fn080484FD(Register uint32 eax, Register word32 ecx, Register word32 edi, Register out ptr32 ecxOut, Register out ptr32 ediOut)
// Called from:
//      fn08048529
//      fn08048622
//      fn0804865E
//      fn08048660
uint32 fn080484FD(uint32 eax, word32 ecx, word32 edi, ptr32 & ecxOut, ptr32 & ediOut)
{
fn080484FD_entry:
	word32 * esp_22 = fp - 4
	word32 ecx_10 = ecx - 0x01
	goto l08048503
l080484FD:
l08048503:
	uint64 edx_eax_14 = (uint64) eax
	uint32 edx_17 = (uint32) (edx_eax_14 % 0x08)
	esp_22 = esp_22 - 4
	*esp_22 = SEQ(SLICE(edx_17, word24, 8), (byte) edx_17 + 0x30)
	eax = (uint32) (edx_eax_14 /u 0x08)
	ecx_10 = ecx_10 - 0x01
	branch ecx_10 != 0x00 l08048503
	goto l08048503
}

// 08048514: Register word32 fn08048514(Register out (ptr32 word32) ediOut)
// Called from:
//      fn08048493
//      fn08048529
word32 fn08048514(word32 & ediOut)
{
	word32 * edi_11 = g_a8048AB7;
	uip32 ecx_14;
	for (ecx_14 = 0x80; ecx_14 != 0x00; --ecx_14)
	{
		*edi_11 = 0x00;
		++edi_11;
	}
	ediOut = edi_11;
	return 0x00;
}

// 08048522: Register (ptr32 byte) fn08048522(Register (ptr32 byte) esi, Register (ptr32 byte) edi)
// Called from:
//      fn0804804C
//      fn08048529
byte * fn08048522(byte * esi, byte * edi)
{
	do
	{
		byte al_5 = *esi;
		*edi = al_5;
		++esi;
		++edi;
	} while (al_5 != 0x00);
	return edi;
}

// 08048529: Register word32 fn08048529(Register word32 ebp, Register Eq_414 gs, Stack word32 dwArg03, Stack word32 dwArg07, Stack word32 dwArg0B, Stack word32 dwArg0F, Register out Eq_414 gsOut)
// Called from:
//      fn0804804C
//      fn08048529
word32 fn08048529(word32 ebp, Eq_414 gs, word32 dwArg03, word32 dwArg07, word32 dwArg0B, word32 dwArg0F, union Eq_414 & gsOut)
{
	__syscall(0x80);
	gsOut = gs;
	return ebp;
}

// 08048622: Register (ptr32 byte) fn08048622()
// Called from:
//      fn08048529
byte * fn08048622()
{
	uint32 edx_25 = 0x00;
	byte * edi_62 = g_a8048B4B;
	word32 ecx_13;
	for (ecx_13 = 0x08; ecx_13 != 0x00; --ecx_13)
	{
		*edi_62 = 0x20;
		++edi_62;
	}
	byte * esi_16 = g_a8048AB7;
	word32 ecx_30 = 0x0200;
	do
	{
		--ecx_30;
		++esi_16;
		edx_25 += (uint32) *esi_16;
		word24 ecx_24_8_40 = SLICE(ecx_30, word24, 8);
	} while (ecx_30 != 0x00);
	word32 ecx_85;
	word32 edi_86;
	fn080484FD(edx_25, SEQ(ecx_24_8_40, 0x07), 134515531, out ecx_85, out edi_86);
	__syscall(0x80);
	return esi_16;
}

// 0804865E: void fn0804865E()
// Called from:
//      fn08048529
void fn0804865E()
{
	word32 ecx_17;
	word32 edi_18;
	fn080484FD(0x00, 11, 0x08048B33, out ecx_17, out edi_18);
}

// 08048660: void fn08048660(Register uint32 eax)
// Called from:
//      fn08048529
void fn08048660(uint32 eax)
{
	word32 ecx_15;
	word32 edi_16;
	fn080484FD(eax, 11, 0x08048B33, out ecx_15, out edi_16);
}

// 08048788: void fn08048788(Register word32 ebp, Register word32 esi, Register (ptr16 Eq_583) gs, Stack word32 dwArg03, Stack word32 dwArg0B, Stack word32 dwArg0F, Stack word32 dwArg13, Stack word32 dwArg17)
// Called from:
//      fn08048529
void fn08048788(word32 ebp, word32 esi, struct Eq_583 * gs, word32 dwArg03, word32 dwArg0B, word32 dwArg0F, word32 dwArg13, word32 dwArg17)
{
	struct Eq_589 * ecx_4 = g_ptr8048EAF;
	struct Eq_589 * ecx_20 = ecx_4;
	if (ecx_4 != null)
		g_ptr8048EAF = ecx_4->ptr0000;
	else
		ecx_20 = fn080487C3(0x0404, ebp, esi, gs, dwArg03, (word16) dwArg0B, (byte) dwArg0F, dwArg13, dwArg17);
	ecx_20->dw0400 = 0x00;
}

// 080487B2: void fn080487B2(Register (ptr32 Eq_619) ecx)
// Called from:
//      fn08048529
void fn080487B2(struct Eq_619 * ecx)
{
	ecx->ptrFFFFFFFC = g_ptr8048EAF;
	g_ptr8048EAF = ecx - 0x04;
}

// 080487C3: Register word32 fn080487C3(Register word32 ecx, Register word32 ebp, Register word32 esi, Register (ptr16 Eq_583) gs, Stack word32 dwArg07, Stack word16 wArg0F, Stack byte bArg13, Stack word32 dwArg17, Stack word32 dwArg1B)
// Called from:
//      fn08048788
word32 fn080487C3(word32 ecx, word32 ebp, word32 esi, struct Eq_583 * gs, word32 dwArg07, word16 wArg0F, byte bArg13, word32 dwArg17, word32 dwArg1B)
{
	word32 ebx_6 = g_dw80487FE + ecx;
	__syscall(0x80);
	word32 eax_1862 = g_dw80487FE;
	g_dw80487FE = ebx_6;
	return eax_1862;
}

word32 g_dw80487FE = 0x08048EB3; // 080487FE
word32 g_dw8048867 = 0x00; // 08048867
word32 g_dw804886F = 0x00; // 0804886F
byte g_b8048873 = 0x00; // 08048873
byte g_a80489B3[] = // 080489B3
	{
	};
byte ** g_ptr8048AB3 = null; // 08048AB3
Eq_646 g_a8048AB7[] = // 08048AB7
	{
	};
word32 g_dw8048B1B = 0x00; // 08048B1B
word32 g_dw8048B23 = 0x00; // 08048B23
word32 g_dw8048B2B = 0x00; // 08048B2B
word32 g_dw8048B33 = 0x00; // 08048B33
byte g_b8048B3F = 0x00; // 08048B3F
byte g_a8048B4B[] = // 08048B4B
	{
	};
cu8 g_b8048B53 = 0x00; // 08048B53
word32 g_dw8048BB8 = 0x00; // 08048BB8
byte g_b8048BBE = 0x00; // 08048BBE
byte g_a8048C10[] = // 08048C10
	{
	};
struct Eq_589 * g_ptr8048EAF = null; // 08048EAF
