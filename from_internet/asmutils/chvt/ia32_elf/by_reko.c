// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Register (ptr32 byte) esi)
// Called from:
//      fn0804808E
void fn0804804C(byte * esi)
{
	while (true)
	{
		cu8 cl_13 = *esi;
		if (cl_13 < 0x30 || cl_13 > 0x39)
			break;
		++esi;
	}
}

// 08048068: FlagGroup byte fn08048068()
// Called from:
//      fn0804808E
byte fn08048068()
{
	__syscall(0x80);
	__syscall(0x80);
	return <invalid>;
}

// 08048086: void fn08048086()
// Called from:
//      fn08048068
//      fn0804808E
void fn08048086()
{
	__syscall(0x80);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	byte * stackArg0 = (byte *) <invalid>;
	fn0804808E(stackArg0);
}

// 0804808E: void fn0804808E(Stack (ptr32 byte) dwArg00)
// Called from:
//      fn08048068
void fn0804808E(byte * dwArg00)
{
	if (!SLICE(fn08048068(), bool, 2) && SLICE(fn08048068(), bool, 2))
	{
		fn08048086();
		return;
	}
	word32 edi_125 = dwLoc08;
	struct Eq_38 * esi_34 = dwLoc04;
	word32 * esp_119 = fp;
	do
	{
		esi_34 = esi_161 + 1;
		esi_161 = esi_34;
	} while (esi_161->b0000 != 0x00);
	if (esi_34->dwFFFFFFFB == 0x74766863)
	{
		if (dwLoc08 != 0x02)
		{
			fn08048086();
			return;
		}
		esp_119 = fp + 1;
		if (dwArg00 != null)
		{
			fn0804804C(dwArg00);
			__syscall(0x80);
			__syscall(0x80);
			esp_119 = fp + 1;
		}
l080480DF:
		word32 * esp_83 = esp_119 - 4;
		*esp_83 = 0x01;
		__syscall(0x80);
		esp_119 = esp_83 + 1;
	}
	word32 edi_91 = edi_125 - 0x01;
	if (edi_91 == 0x00)
	{
l080480F5:
		word32 * esp_121 = esp_119 - 4;
		*esp_121 = 0x36;
		__syscall(0x80);
		esp_119 = esp_121 + 1;
		goto l080480EB;
	}
l080480EB:
	edi_125 = edi_91;
	byte * esi_96 = *esp_119;
	++esp_119;
	if (esi_96 != null)
	{
		fn0804804C(esi_96);
		goto l080480F5;
	}
	goto l080480DF;
}

