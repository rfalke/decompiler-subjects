//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(void);
int32_t function_8048132(void);
int32_t function_804815a(void);
int32_t function_8048176(void);
int32_t function_8048188(void);
int32_t function_8048196(void);
int32_t function_80481a3(void);

// --------------------- Global Variables ---------------------

char * g1 = "\x01\a\x03\x18\x02"; // 0x80481e6
int32_t g2 = 0; // 0x80486ec

// ------------------------ Functions -------------------------

// Address range: 0x804804c - 0x8048132
int32_t entry_point(void) {
    // 0x804804c
    function_8048176();
    int32_t v1; // 0x804804c
    int32_t v2 = &v1; // 0x804805f
    __asm_int(128);
    int32_t * v3 = (int32_t *)(v2 - 8);
    int32_t * v4 = (int32_t *)(v2 - 12);
    int32_t * v5 = (int32_t *)(v2 - 16);
    int32_t * v6 = (int32_t *)(v2 - 24);
    int32_t * v7 = (int32_t *)(v2 - 28);
    int32_t * v8 = (int32_t *)(v2 - 32);
    int32_t * v9 = (int32_t *)(v2 - 36);
    int32_t v10 = 5; // 0x804806a
    while (true) {
      lab_0x804806c:
        // 0x804806c
        __asm_int(128);
        int32_t v11 = 141; // 0x804808d
        int32_t v12 = 141; // 0x804808d
        int32_t v13 = 0x1000; // 0x804808d
        int32_t v14 = &g2; // 0x804808d
        int32_t v15 = v10; // 0x804808d
        int32_t v16; // 0x804804c
        int32_t v17 = v16; // 0x804808d
        int32_t v18; // 0x804804c
        int32_t v19 = v18; // 0x804808d
        while (true) {
          lab_0x804808f:;
            int32_t v20 = v14;
            *(int32_t *)(v2 - 4) = v11;
            *v3 = v12;
            *v4 = v13;
            *v5 = v20;
            *(int32_t *)(v2 - 20) = v2;
            *v6 = v15;
            *v7 = v17;
            *v8 = v19;
            if (function_804815a() == 0) {
                // 0x80480a0
                *v9 = v20 + 10;
                function_8048196();
                function_80481a3();
                function_80481a3();
                *v9 = 5;
                __asm_int(128);
                *v9 = 3;
                __asm_int(128);
                *v9 = 6;
                __asm_int(128);
                function_8048132();
                function_8048176();
            }
            // 0x80480f7
            v19 = *v8;
            v17 = *v7;
            v15 = *v6;
            int32_t v21 = *v5; // 0x80480f7
            v13 = *v4;
            v11 = (int32_t)*(int16_t *)(v21 + 8);
            v12 = *v3 - v11;
            v10 = v15;
            v16 = v17;
            v18 = v19;
            v14 = v21 + v11;
            if (v12 == 0) {
                goto lab_0x804806c;
            } else {
                goto lab_0x804808f;
            }
        }
    }
}

// Address range: 0x8048132 - 0x804815a
int32_t function_8048132(void) {
    // 0x8048132
    int32_t result; // 0x8048132
    char v1 = *(char *)result; // 0x8048135
    bool v2; // 0x8048132
    int32_t v3 = v2 ? -1 : 1; // 0x8048135
    if (v1 != 0) {
        int32_t v4; // 0x8048132
        int32_t v5 = v4 + v3;
        if (v1 == 32) {
            // 0x804813e
            *(char *)(v5 - 1) = 0;
        }
        char v6 = *(char *)v5; // 0x8048135
        v4 = v5;
        while (v6 != 0) {
            // 0x804813a
            v5 = v4 + v3;
            if (v6 == 32) {
                // 0x804813e
                *(char *)(v5 - 1) = 0;
            }
            // 0x8048135
            v6 = *(char *)v5;
            v4 = v5;
        }
    }
    int32_t v7 = (int32_t)&g1;
    while (*(char *)v7 != 0) {
        // 0x8048149
        v7 += v3;
    }
    // 0x8048158
    return result;
}

// Address range: 0x804815a - 0x8048176
int32_t function_804815a(void) {
    int32_t v1 = 0; // 0x804815b
    int32_t v2; // 0x804815a
    unsigned char v3 = *(char *)v2; // 0x804815d
    v1 = v1 & -256 | (int32_t)v3;
    int32_t v4 = v1; // 0x8048160
    while (v3 != 0) {
        if (v3 < 48) {
            // 0x8048166
            v4 = v1 + 256 & 0xff00 | v1 & -0xff01;
            goto lab_0x8048170;
        }
        // 0x804816a
        bool v5; // 0x804815a
        v2 += (v5 ? -1 : 1);
        if (v3 >= 58) {
            // 0x804816e
            v4 = v1 + 256 & 0xff00 | v1 & -0xff01;
            goto lab_0x8048170;
        }
        v3 = *(char *)v2;
        v1 = v1 & -256 | (int32_t)v3;
        v4 = v1;
    }
  lab_0x8048170:;
    uint32_t v6 = v4;
    return v6 / 256 % 256 | v6 & -0x10000;
}

// Address range: 0x8048176 - 0x8048188
int32_t function_8048176(void) {
    // 0x8048176
    function_8048188();
    __asm_int(128);
    int32_t result; // 0x8048176
    return result;
}

// Address range: 0x8048188 - 0x8048196
int32_t function_8048188(void) {
    // 0x8048188
    int32_t v1; // 0x8048188
    while (*(char *)v1 != 0) {
        // 0x804818d
        bool v2; // 0x8048188
        v1 += (v2 ? -1 : 1);
    }
    // 0x8048193
    int32_t result; // 0x8048188
    return result;
}

// Address range: 0x8048196 - 0x80481a3
int32_t function_8048196(void) {
    // 0x8048196
    function_8048188();
    int32_t result; // 0x8048196
    __asm_rep_movsb_memcpy((char *)result, (char *)result, result + 1);
    return result;
}

// Address range: 0x80481a3 - 0x80481bb
int32_t function_80481a3(void) {
    // 0x80481a3
    int32_t result; // 0x80481a3
    int32_t v1 = result;
    function_8048188();
    function_8048188();
    __asm_rep_movsb_memcpy((char *)(v1 + result), (char *)result, v1 + 1);
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: upx (3.xx)
// Detected functions: 7

