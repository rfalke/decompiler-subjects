// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048283: void fn08048283(Stack up32 dwArg00, Stack (ptr32 Eq_3) dwArg08)
void fn08048283(up32 dwArg00, struct Eq_3 * dwArg08)
{
	ptr32 esp_109;
	ptr32 esp_102;
	ptr32 esp_11 = fp + 4;
	if (dwArg00 >= 0x03)
	{
		esp_11 = fp + 0x0C;
		if (dwArg08->b0000 == 0x2D)
		{
			if (dwArg08->b0001 == 0x48)
				++g_b8049615;
			if (dwArg08->b0001 == 0x53)
				++g_b8049616;
			if (dwArg08->b0001 == 0x50)
				++g_b8049617;
			if (dwArg08->b0001 == 0x41)
			{
				++g_b8049617;
				++g_b8049616;
				++g_b8049615;
			}
			__syscall(0x80);
			g_dw8049618 = 0x05;
			__syscall(0x80);
			esp_109 = fp + 0x0C;
			if (g_dw804984B == 0x464C457F)
			{
l08048327:
				struct Eq_70 * esp_111 = esp_109 - 4;
				esp_111->dw0000 = 0x0A;
				esp_111->dw0000 = 0x01;
				esp_111->dw0000 = 0x04;
				__syscall(0x80);
				byte * ecx_123 = esp_111->ptr0004;
				do
					++ecx_123;
				while (*ecx_123 != 0x00);
				esp_111->ptr0004 = (byte *) 0x04;
				__syscall(0x80);
				esp_111->ptr0004 = (byte *) 0x01;
				esp_111->ptr0004 = (byte *) 0x04;
				__syscall(0x80);
				if (g_b8049615 != 0x00)
					fn080487FB();
				if (g_b8049616 != 0x00)
					fn08048580();
				if (g_b8049617 != 0x00)
					fn0804838D();
				esp_111->ptr0004 = (byte *) 0x06;
				__syscall(0x80);
				esp_102 = (char *) &esp_111->ptr0004 + 4;
				goto l08048320;
			}
			__syscall(0x80);
			__syscall(0x80);
			esp_102 = fp + 16;
l08048320:
			word32 * esp_106 = esp_102 - 4;
			*esp_106 = 0x01;
			__syscall(0x80);
			esp_109 = esp_106 + 1;
			goto l08048327;
		}
	}
	word32 * esp_99 = esp_11 - 4;
	*esp_99 = 0x04;
	__syscall(0x80);
	esp_102 = esp_99 + 1;
	goto l08048320;
}

// 0804838D: void fn0804838D()
// Called from:
//      fn08048283
void fn0804838D()
{
	word16 ax_5 = g_w8049877;
	uint32 eax_11 = (uint32) ax_5;
	if (ax_5 != 0x00)
	{
		g_t8049D23 = fn08048D11(eax_11, 0x0A, &g_b804981F);
		g_t8049D23 = fn08048D11(g_dw8049867, 0x10, &g_b8049846);
		__syscall(0x80);
		__syscall(0x80);
		__syscall(0x80);
		__syscall(0x80);
		word32 ecx_140 = 0x00;
		do
		{
			__syscall(0x80);
			fn08048445();
			ecx_140 = ecx_226 + 0x01;
			ecx_226 = ecx_140;
		} while ((word16) ecx_226 + 0x01 != g_w8049877);
	}
	else
		__syscall(0x80);
}

// 08048445: void fn08048445()
// Called from:
//      fn0804838D
void fn08048445()
{
	byte * edi_234 = g_a80498C7;
	word32 ecx_237;
	for (ecx_237 = 0x50; ecx_237 != 0x00; --ecx_237)
	{
		*edi_234 = 0x20;
		++edi_234;
	}
	struct Eq_258 * ebp_38 = null;
	word32 eax_41 = g_dw80498A7;
	do
	{
		if (eax_41 == ebp_38->dw8049557)
		{
			byte * esi_166 = &ebp_38->dw8049557 + 1;
			word32 ecx_232;
			byte * edi_228 = g_a80498C9;
			for (ecx_232 = 0x0F; ecx_232 != 0x00; --ecx_232)
			{
				*edi_228 = *esi_166;
				++esi_166;
				++edi_228;
			}
			break;
		}
		++ebp_38;
	} while (ebp_38 != (struct Eq_258 *) 0xBE);
	g_w80498D8 = 0x7830;
	fn08048D34(g_dw80498AB, 0x06, &g_b80498DA);
	g_w80498E1 = 0x7830;
	fn08048D34(g_dw80498AF, 0x08, &g_b80498E3);
	g_w80498EC = 0x7830;
	fn08048D34(g_dw80498B3, 0x08, &g_b80498EE);
	g_w80498F7 = 0x7830;
	fn08048D34(g_dw80498B7, 0x05, &g_b80498F9);
	g_w80498FF = 0x7830;
	fn08048D34(g_dw80498BB, 0x05, &g_b8049901);
	ui32 eax_104 = g_dw80498BF;
	if ((eax_104 & 0x04) != 0x00)
		g_b8049907 = 0x52;
	if ((eax_104 & 0x02) != 0x00)
		g_b8049908 = 0x57;
	if ((eax_104 & 0x01) != 0x00)
		g_b8049909 = 88;
	g_w804990B = 0x7830;
	g_t8049D23 = fn08048D11(g_dw80498C3, 0x10, &g_b804990D);
	g_b8049917 = 0x0A;
	__syscall(0x80);
}

// 08048580: void fn08048580()
// Called from:
//      fn08048283
void fn08048580()
{
	word16 ax_5 = g_w804987B;
	uint32 eax_11 = (uint32) ax_5;
	if (ax_5 != 0x00)
	{
		g_t8049D23 = fn08048D11(eax_11, 0x0A, &g_b80497E6);
		g_t8049D23 = fn08048D11(g_dw804986B, 0x10, &g_b804980F);
		__syscall(0x80);
		__syscall(0x80);
		__syscall(0x80);
		__syscall(0x80);
		__syscall(0x80);
		__syscall(0x80);
		__syscall(0x80);
		__syscall(0x80);
		uint32 ecx_171 = 0x00;
		do
		{
			__syscall(0x80);
			fn08048689(ecx_262);
			ecx_171 = ecx_262 + 0x01;
			ecx_262 = ecx_171;
		} while ((word16) ecx_262 + 0x01 != g_w804987B);
	}
	else
		__syscall(0x80);
}

// 08048689: void fn08048689(Register uint32 ecx)
// Called from:
//      fn08048580
void fn08048689(uint32 ecx)
{
	cu8 cl_28 = (byte) ecx;
	byte * edi_27 = &g_b804973C;
	if (cl_28 <= 0x09)
		edi_27 = &g_b804973D;
	g_t8049D23 = fn08048D11(ecx, 0x0A, edi_27);
	byte * edi_469 = g_a804973F;
	word32 ecx_472;
	for (ecx_472 = 0x4A; ecx_472 != 0x00; --ecx_472)
	{
		*edi_469 = 0x20;
		++edi_469;
	}
	byte * esi_101 = g_dw804987F + 0x08049918;
	struct Eq_479 * edi_102 = g_a8049740;
	do
	{
		byte al_100 = *esi_101;
		edi_102->b0000 = al_100;
		++esi_101;
		++edi_102;
	} while (al_100 != 0x00);
	edi_102->bFFFFFFFF = 0x20;
	struct Eq_508 * ebp_118 = null;
	word32 eax_121 = g_dw8049883;
	do
	{
		if (eax_121 == ebp_118->dw80493B3)
		{
			byte * esi_131 = &ebp_118->dw80493B3 + 1;
			word32 ecx_133;
			byte * edi_134 = g_a8049752;
			for (ecx_133 = 0x11; ecx_133 != 0x00; --ecx_133)
			{
				*edi_134 = *esi_131;
				++esi_131;
				++edi_134;
			}
			break;
		}
		++ebp_118;
	} while (ebp_118 != (struct Eq_508 *) 0x01A4);
	fn08048D34(g_dw804988B, 0x08, &g_b8049762);
	fn08048D34(g_dw804988F, 0x06, &g_b804976B);
	fn08048D34(g_dw8049893, 0x06, &g_b8049772);
	uint32 eax_164 = g_dw80498A3;
	byte * edi_163 = &g_b8049779;
	if ((byte) eax_164 <= 0x0F)
	{
		g_b8049779 = 0x30;
		edi_163 = &g_b804977A;
	}
	g_t8049D23 = fn08048D11(eax_164, 0x10, edi_163);
	ui32 eax_234 = g_dw8049887;
	if ((eax_234 & 0x01) != 0x00)
		g_b804977C = 0x57;
	if ((eax_234 & 0x02) != 0x00)
		g_b804977D = 0x41;
	if ((eax_234 & 0x04) != 0x00)
		g_b804977E = 88;
	uint32 eax_257 = g_dw8049897;
	byte * edi_253 = &g_b8049780;
	if ((byte) eax_257 <= 0x09)
		edi_253 = &g_b8049781;
	g_t8049D23 = fn08048D11(eax_257, 0x0A, edi_253);
	uint32 eax_333 = g_dw804989B;
	byte * edi_332 = &g_b8049784;
	if ((byte) eax_333 <= 0x0F)
		edi_332 = &g_b8049785;
	g_t8049D23 = fn08048D11(eax_333, 0x10, edi_332);
	g_t8049D23 = fn08048D11(g_dw804989F, 0x0A, &g_b8049787);
	__syscall(0x80);
}

// 080487FB: void fn080487FB()
// Called from:
//      fn08048283
void fn080487FB()
{
	__syscall(0x80);
	__syscall(0x80);
	cu8 * ebp_124 = &g_dw804984B;
	do
	{
		cu8 al_53 = *ebp_1545;
		byte * edi_50 = g_a8049D18;
		uint32 eax_65 = (uint32) al_53;
		if (al_53 <= 0x09)
		{
			g_a8049D18[0] = 0x30;
			edi_50 = &g_b8049D19;
		}
		g_t8049D23 = fn08048D11(eax_65, 0x10, edi_50);
		g_b8049D1A = 0x20;
		__syscall(0x80);
		ebp_124 = ebp_1545 + 1;
		ebp_1545 = ebp_124;
	} while (ebp_1545 != (cu8 *) 4160448452);
	__syscall(0x80);
	__syscall(0x80);
	byte al_147 = g_b804984F;
	if (al_147 != 0x01)
	{
		uint32 eax_159 = (uint32) al_147;
		if (al_147 != 0x02)
			g_t8049D23 = fn08048D11(eax_159, 0x10, &g_b804961B);
	}
	__syscall(0x80);
	__syscall(0x80);
	byte al_219 = g_b8049850;
	if (al_219 != 0x01)
	{
		uint32 eax_231 = (uint32) al_219;
		if (al_219 != 0x02)
			g_t8049D23 = fn08048D11(eax_231, 0x10, &g_b8049640);
	}
	__syscall(0x80);
	__syscall(0x80);
	cup16 ax_295 = g_w804985B;
	struct Eq_729 * ebp_299 = g_a8048D79;
	do
	{
		if (ax_295 == ebp_299->w0000)
			goto l080489AC;
		++ebp_299;
	} while (ebp_299 != (struct Eq_729 *) 4160451438);
	uint32 eax_318 = (uint32) ax_295;
	if (ax_295 >= 0xFF00)
	{
		eax_318 = (uint32) ax_295;
		if (ax_295 <= ~0x00)
		{
			g_t8049D23 = fn08048D11(eax_318, 0x10, &g_b804968A);
l080489AC:
			__syscall(0x80);
			__syscall(0x80);
			word16 ax_449 = g_w804985D;
			struct Eq_744 * ebp_452 = g_a8048E60;
			do
			{
				uint32 eax_468 = (uint32) ax_449;
				if (ax_449 == ebp_452->w0000)
					goto l08048A0D;
				++ebp_452;
			} while (ebp_452 != (struct Eq_744 *) ~0x08048C1F);
			g_t8049D23 = fn08048D11(eax_468, 0x10, &g_b80496A6);
l08048A0D:
			__syscall(0x80);
			__syscall(0x80);
			uint32 eax_542 = g_dw804985F;
			if (eax_542 != 0x00 && eax_542 != 0x01)
				g_t8049D23 = fn08048D11(eax_542, 0x10, &g_b80496C4);
			__syscall(0x80);
			__syscall(0x80);
			g_t8049D23 = fn08048D11(g_dw8049863, 0x10, &g_b80496DD);
			__syscall(0x80);
			__syscall(0x80);
			fn08048D00();
			g_t8049D23 = fn08048D11(g_dw8049867, 0x0A, g_a8049D18);
			fn08048CC6();
			__syscall(0x80);
			fn08048D00();
			g_t8049D23 = fn08048D11(g_dw804986B, 0x0A, g_a8049D18);
			fn08048CC6();
			__syscall(0x80);
			fn08048D00();
			g_t8049D23 = fn08048D11(g_dw804986F, 0x10, g_a8049D18);
			g_t8049D23.u0 = 0x0A;
			__syscall(0x80);
			__syscall(0x80);
			word16 ax_868 = g_w8049873;
			fn08048D00();
			g_t8049D23 = fn08048D11((uint32) ax_868, 0x0A, g_a8049D18);
			fn08048CE3();
			__syscall(0x80);
			word16 ax_934 = g_w8049875;
			fn08048D00();
			g_t8049D23 = fn08048D11((uint32) ax_934, 0x0A, g_a8049D18);
			fn08048CE3();
			__syscall(0x80);
			word16 ax_1000 = g_w8049877;
			fn08048D00();
			g_t8049D23 = fn08048D11((uint32) ax_1000, 0x0A, g_a8049D18);
			g_t8049D23.u0 = 0x0A;
			__syscall(0x80);
			__syscall(0x80);
			word16 ax_1068 = g_w8049879;
			fn08048D00();
			g_t8049D23 = fn08048D11((uint32) ax_1068, 0x0A, g_a8049D18);
			fn08048CE3();
			__syscall(0x80);
			word16 ax_1134 = g_w804987B;
			fn08048D00();
			g_t8049D23 = fn08048D11((uint32) ax_1134, 0x0A, g_a8049D18);
			g_t8049D23.u0 = 0x0A;
			__syscall(0x80);
			__syscall(0x80);
			word16 ax_1202 = g_w804987D;
			fn08048D00();
			g_t8049D23 = fn08048D11((uint32) ax_1202, 0x0A, g_a8049D18);
			g_t8049D23.u0 = 0x0A;
			__syscall(0x80);
			return;
		}
	}
	g_t8049D23 = fn08048D11(eax_318, 0x10, &g_b8049668);
	goto l080489AC;
}

// 08048CC6: void fn08048CC6()
// Called from:
//      fn080487FB
void fn08048CC6()
{
	__syscall(0x80);
	__syscall(0x80);
}

// 08048CE3: void fn08048CE3()
// Called from:
//      fn080487FB
void fn08048CE3()
{
	__syscall(0x80);
	__syscall(0x80);
}

// 08048D00: void fn08048D00()
// Called from:
//      fn080487FB
void fn08048D00()
{
	byte * edi_27 = g_a8049D18;
	word32 ecx_31;
	for (ecx_31 = 11; ecx_31 != 0x00; --ecx_31)
	{
		*edi_27 = 0x00;
		++edi_27;
	}
}

// 08048D11: Register word32 fn08048D11(Register uint32 eax, Register uint32 ecx, Register (ptr32 byte) edi)
// Called from:
//      fn0804838D
//      fn08048445
//      fn08048580
//      fn08048689
//      fn080487FB
//      fn08048D34
word32 fn08048D11(uint32 eax, uint32 ecx, byte * edi)
{
	word32 * esp_2 = fp;
	word32 ebx_29 = 0x00;
	do
	{
		word32 edx_23;
		uint64 edx_eax_8 = (uint64) eax;
		uint32 edx_11 = (uint32) (edx_eax_8 % ecx);
		cu8 dl_13 = (byte) edx_11;
		word24 edx_24_8_24 = SLICE(edx_11, word24, 8);
		eax = (uint32) (edx_eax_8 /u ecx);
		if (dl_13 >= 0x0A)
			edx_23 = SEQ(edx_24_8_24, dl_13 + 55);
		else
			edx_23 = SEQ(edx_24_8_24, dl_13 + 0x30);
		esp_2 -= 4;
		*esp_2 = edx_23;
		++ebx_29;
	} while (eax != 0x00);
	ebx_44 = ebx_29;
	do
	{
		word32 ebx_44;
		*edi = (byte) dwLoc04;
		++edi;
		--ebx_44;
	} while (ebx_44 != 0x00);
	return ebx_29;
}

// 08048D34: void fn08048D34(Register uint32 eax, Register word32 ebx, Register (ptr32 byte) edi)
// Called from:
//      fn08048445
//      fn08048689
void fn08048D34(uint32 eax, word32 ebx, byte * edi)
{
	g_t8049D23 = fn08048D11(eax, 0x10, edi);
	byte * edi_101 = edi;
	if (g_t8049D23 < 0x08)
	{
		word32 ecx_75 = ebx - g_t8049D23;
		word32 ecx_102 = ecx_75;
		if (ecx_75 != 0x00)
		{
			do
			{
				*edi_101 = 0x30;
				++edi_101;
				--ecx_102;
			} while (ecx_102 != 0x00);
		}
		g_t8049D23 = fn08048D11(eax, 0x10, edi + ecx_75);
	}
}

Eq_1108 g_a8048D79[8] = // 08048D79
	{
		
		{
			0x00,
		},
		
		{
			0x01,
		},
		
		{
			0x02,
		},
		
		{
			0x03,
		},
		
		{
			0x04,
		},
		
		{
			0xFF00,
		},
		
		{
			~0x00,
		},
		
		{
			0x00,
		},
	};
Eq_1110 g_a8048E60[19] = // 08048E60
	{
		
		{
			0x00,
		},
		
		{
			0x01,
		},
		
		{
			0x02,
		},
		
		{
			0x03,
		},
		
		{
			0x04,
		},
		
		{
			0x05,
		},
		
		{
			0x06,
		},
		
		{
			0x07,
		},
		
		{
			0x08,
		},
		
		{
			0x0A,
		},
		
		{
			0x0F,
		},
		
		{
			0x12,
		},
		
		{
			0x14,
		},
		
		{
			0x2A,
		},
		
		{
			0x2B,
		},
		
		{
			0x32,
		},
		
		{
			0x9026,
		},
		
		{
			0xA390,
		},
		
		{
			0x2820,
		},
	};
Eq_1106 g_a80493B3[21] = // 080493B3
	{
		
		{
			0x00,
		},
		
		{
			0x01,
		},
		
		{
			0x02,
		},
		
		{
			0x03,
		},
		
		{
			0x04,
		},
		
		{
			0x05,
		},
		
		{
			0x06,
		},
		
		{
			0x07,
		},
		
		{
			0x08,
		},
		
		{
			0x09,
		},
		
		{
			0x0A,
		},
		
		{
			11,
		},
		
		{
			0x70000000,
		},
		
		{
			0x7FFFFFFF,
		},
		
		{
			0x80000000,
		},
		
		{
			~0x00,
		},
		
		{
			0x70000000,
		},
		
		{
			0x70000002,
		},
		
		{
			0x70000003,
		},
		
		{
			0x70000004,
		},
		
		{
			0x00,
		},
	};
Eq_1096 g_a8049557[11] = // 08049557
	{
		
		{
			0x00,
		},
		
		{
			0x01,
		},
		
		{
			0x02,
		},
		
		{
			0x03,
		},
		
		{
			0x04,
		},
		
		{
			0x05,
		},
		
		{
			0x06,
		},
		
		{
			0x70000000,
		},
		
		{
			0x7FFFFFFF,
		},
		
		{
			0x70000000,
		},
		
		{
			0x01000000,
		},
	};
byte g_b8049615 = 0x00; // 08049615
byte g_b8049616 = 0x00; // 08049616
byte g_b8049617 = 0x00; // 08049617
word32 g_dw8049618 = 544747521; // 08049618
byte g_b804961B = 0x20; // 0804961B
byte g_b8049640 = 0x20; // 08049640
byte g_b8049668 = 0x20; // 08049668
byte g_b804968A = 0x20; // 0804968A
byte g_b80496A6 = 0x20; // 080496A6
byte g_b80496C4 = 0x20; // 080496C4
byte g_b80496DD = 0x20; // 080496DD
byte g_b804973C = 0x20; // 0804973C
byte g_b804973D = 0x20; // 0804973D
byte g_a804973F[] = // 0804973F
	{
	};
byte g_a8049740[] = // 08049740
	{
	};
byte g_a8049752[] = // 08049752
	{
	};
byte g_b8049762 = 0x20; // 08049762
byte g_b804976B = 0x20; // 0804976B
byte g_b8049772 = 0x20; // 08049772
byte g_b8049779 = 0x20; // 08049779
byte g_b804977A = 0x20; // 0804977A
byte g_b804977C = 0x20; // 0804977C
byte g_b804977D = 0x20; // 0804977D
byte g_b804977E = 0x20; // 0804977E
byte g_b8049780 = 0x20; // 08049780
byte g_b8049781 = 0x20; // 08049781
byte g_b8049784 = 0x20; // 08049784
byte g_b8049785 = 0x20; // 08049785
byte g_b8049787 = 0x20; // 08049787
byte g_b80497E6 = 0x20; // 080497E6
byte g_b804980F = 0x20; // 0804980F
byte g_b804981F = 0x20; // 0804981F
byte g_b8049846 = 0x20; // 08049846
word32 g_dw804984B = 0x00; // 0804984B
byte g_b804984F = 0x00; // 0804984F
byte g_b8049850 = 0x00; // 08049850
cup16 g_w804985B = 0x00; // 0804985B
word16 g_w804985D = 0x00; // 0804985D
uint32 g_dw804985F = 0x00; // 0804985F
uint32 g_dw8049863 = 0x00; // 08049863
uint32 g_dw8049867 = 0x00; // 08049867
uint32 g_dw804986B = 0x00; // 0804986B
uint32 g_dw804986F = 0x00; // 0804986F
word16 g_w8049873 = 0x00; // 08049873
word16 g_w8049875 = 0x00; // 08049875
word16 g_w8049877 = 0x00; // 08049877
word16 g_w8049879 = 0x00; // 08049879
word16 g_w804987B = 0x00; // 0804987B
word16 g_w804987D = 0x00; // 0804987D
word32 g_dw804987F = 0x00; // 0804987F
word32 g_dw8049883 = 0x00; // 08049883
ui32 g_dw8049887 = 0x00; // 08049887
uint32 g_dw804988B = 0x00; // 0804988B
uint32 g_dw804988F = 0x00; // 0804988F
uint32 g_dw8049893 = 0x00; // 08049893
uint32 g_dw8049897 = 0x00; // 08049897
uint32 g_dw804989B = 0x00; // 0804989B
uint32 g_dw804989F = 0x00; // 0804989F
uint32 g_dw80498A3 = 0x00; // 080498A3
word32 g_dw80498A7 = 0x00; // 080498A7
uint32 g_dw80498AB = 0x00; // 080498AB
uint32 g_dw80498AF = 0x00; // 080498AF
uint32 g_dw80498B3 = 0x00; // 080498B3
uint32 g_dw80498B7 = 0x00; // 080498B7
uint32 g_dw80498BB = 0x00; // 080498BB
ui32 g_dw80498BF = 0x00; // 080498BF
uint32 g_dw80498C3 = 0x00; // 080498C3
byte g_a80498C7[] = // 080498C7
	{
	};
byte g_a80498C9[] = // 080498C9
	{
	};
word16 g_w80498D8 = 0x00; // 080498D8
byte g_b80498DA = 0x00; // 080498DA
word16 g_w80498E1 = 0x00; // 080498E1
byte g_b80498E3 = 0x00; // 080498E3
word16 g_w80498EC = 0x00; // 080498EC
byte g_b80498EE = 0x00; // 080498EE
word16 g_w80498F7 = 0x00; // 080498F7
byte g_b80498F9 = 0x00; // 080498F9
word16 g_w80498FF = 0x00; // 080498FF
byte g_b8049901 = 0x00; // 08049901
byte g_b8049907 = 0x00; // 08049907
byte g_b8049908 = 0x00; // 08049908
byte g_b8049909 = 0x00; // 08049909
word16 g_w804990B = 0x00; // 0804990B
byte g_b804990D = 0x00; // 0804990D
byte g_b8049917 = 0x00; // 08049917
byte g_a8049D18[] = // 08049D18
	{
	};
byte g_b8049D19 = 0x00; // 08049D19
byte g_b8049D1A = 0x00; // 08049D1A
Eq_211 g_t8049D23 = // 08049D23
	{
		0x00
	};
