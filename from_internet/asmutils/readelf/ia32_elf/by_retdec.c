//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_804838d(void);
int32_t function_8048445(void);
int32_t function_8048580(void);
int32_t function_8048689(void);
int32_t function_80487fb(void);
int32_t function_8048cc6(void);
int32_t function_8048ce3(void);
int32_t function_8048d00(void);
int32_t function_8048d11(void);
int32_t function_8048d34(void);

// --------------------- Global Variables ---------------------

int16_t * g1 = (int16_t *)0x54450000; // 0x8048d79
int16_t * g2 = (int16_t *)0x4d450000; // 0x8048e60
int32_t g3 = 0; // 0x80493b3
char * g4 = "SHT_NULL         \x01"; // 0x80493b7
int32_t g5 = 0; // 0x8049557
char * g6 = "PT_NULL        \x01"; // 0x804955b
char g7 = 0; // 0x8049615
char g8 = 0; // 0x8049616
char g9 = 0; // 0x8049617
int32_t g10 = 0x20783001; // 0x8049618
char * g11; // 0x804984b
char g12 = 0; // 0x804984f
char g13 = 0; // 0x8049850
int16_t g14 = 0; // 0x804985b
int16_t g15 = 0; // 0x804985d
int32_t g16 = 0; // 0x804985f
int16_t g17 = 0; // 0x8049877
int16_t g18 = 0; // 0x804987b
int32_t g19 = 0; // 0x8049883
int32_t g20 = 0; // 0x8049887
char g21 = 0; // 0x80498a3
int32_t g22 = 0; // 0x80498a7
int32_t g23 = 0; // 0x80498bf
char * g24; // 0x80498c7
char * g25; // 0x80498c9
int32_t g26 = 0; // 0x80498d8
int32_t g27 = 0; // 0x80498e1
int32_t g28 = 0; // 0x80498ec
int32_t g29 = 0; // 0x80498f7
int32_t g30 = 0; // 0x80498ff
char * g31; // 0x8049907
char * g32; // 0x8049908
char * g33; // 0x8049909
int32_t g34 = 0; // 0x804990b
int32_t g35 = 0; // 0x8049917
char * g36; // 0x8049918
char * g37; // 0x8049d18
int32_t g38 = 0; // 0x8049d19
int32_t g39 = 0; // 0x8049d1a
char g40 = 0; // 0x8049d23

// ------------------------ Functions -------------------------

// Address range: 0x8048283 - 0x804838d
int32_t entry_point(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4;
    int32_t v2 = a2;
    int32_t v3 = &v2; // 0x8048287
    int32_t * v4; // 0x8048283
    int32_t v5; // 0x8048283
    int32_t v6; // 0x8048283
    if (a1 >= 3) {
        // 0x804829d
        v3 = &v1;
        if (*(char *)a3 != 45) {
            goto lab_0x8048289;
        } else {
            char * v7 = (char *)(a3 + 1); // 0x80482a4
            char v8 = *v7; // 0x80482a4
            char v9 = v8; // 0x80482a8
            if (v8 == 72) {
                // 0x80482aa
                g7++;
                v9 = *v7;
            }
            char v10 = v9; // 0x80482b4
            if (v9 == 83) {
                // 0x80482b6
                g8++;
                v10 = *v7;
            }
            char v11 = v10; // 0x80482c0
            if (v10 == 80) {
                // 0x80482c2
                g9++;
                v11 = *v7;
            }
            // 0x80482c8
            if (v11 == 65) {
                // 0x80482ce
                g9++;
                g8++;
                g7++;
            }
            // 0x80482e0
            __asm_int(128);
            g10 = 5;
            __asm_int(128);
            if (g11 == (char *)0x464c457f) {
                // 0x80482e0
                v4 = (int32_t *)(v3 - 4);
                v6 = v3;
                goto lab_0x8048327;
            } else {
                // 0x804830a
                v1 = 6;
                __asm_int(128);
                v1 = 4;
                __asm_int(128);
                int32_t v12; // bp+16, 0x8048283
                v5 = &v12;
                goto lab_0x8048320;
            }
        }
    } else {
        goto lab_0x8048289;
    }
  lab_0x8048289:
    // 0x8048289
    *(int32_t *)(v3 - 4) = 4;
    __asm_int(128);
    v5 = v3;
    goto lab_0x8048320;
  lab_0x8048320:;
    int32_t * v13 = (int32_t *)(v5 - 4);
    *v13 = 1;
    __asm_int(128);
    v4 = v13;
    v6 = v5;
    goto lab_0x8048327;
  lab_0x8048327:
    // 0x8048327
    *v4 = 4;
    __asm_int(128);
    int32_t * v14 = (int32_t *)v6; // 0x8048337
    int32_t v15 = *v14 + 1; // 0x804833a
    int32_t v16 = v15; // 0x804833e
    while (*(char *)v15 != 0) {
        // 0x804833a
        v15 = v16 + 1;
        v16 = v15;
    }
    // 0x8048340
    *v14 = 4;
    __asm_int(128);
    *v14 = 4;
    __asm_int(128);
    if (g7 != 0) {
        // 0x804835f
        function_80487fb();
    }
    // 0x8048364
    if (g8 != 0) {
        // 0x804836d
        function_8048580();
    }
    // 0x8048372
    if (g9 != 0) {
        // 0x804837b
        function_804838d();
    }
    // 0x8048380
    *v14 = 6;
    __asm_int(128);
    v5 = v6 + 4;
    goto lab_0x8048320;
}

// Address range: 0x804838d - 0x8048445
int32_t function_804838d(void) {
    // 0x804838d
    if (g17 == 0) {
        // 0x804839b
        __asm_int(128);
        return 4;
    }
    // 0x80483ac
    function_8048d11();
    function_8048d11();
    int32_t v1; // 0x804838d
    g40 = v1;
    __asm_int(128);
    __asm_int(128);
    __asm_int(128);
    int32_t v2; // 0x804838d
    int32_t v3 = &v2; // 0x8048419
    __asm_int(128);
    int32_t * v4 = (int32_t *)(v3 - 4); // 0x804841e
    *v4 = 0;
    *(int32_t *)(v3 - 8) = 3;
    __asm_int(128);
    int32_t result = function_8048445(); // 0x8048435
    int32_t v5 = *v4 + 1; // 0x804843a
    while (g17 != (int16_t)v5) {
        // 0x804841e
        *v4 = v5;
        *(int32_t *)(v3 - 8) = 3;
        __asm_int(128);
        result = function_8048445();
        v5 = *v4 + 1;
    }
    // 0x8048444
    return result;
}

// Address range: 0x8048445 - 0x8048580
int32_t function_8048445(void) {
    // 0x8048445
    __asm_rep_stosb_memset((char *)&g24, 32, 80);
    int32_t v1 = 0;
    while (g22 != *(int32_t *)(v1 + (int32_t)&g5)) {
        // 0x804847b
        if (v1 == 171) {
            goto lab_0x8048486;
        }
        v1 += 19;
    }
    // 0x8048466
    __asm_rep_movsb_memcpy((char *)&g25, (char *)(v1 + (int32_t)&g6), 15);
    bool v2; // 0x8048445
    int32_t v3 = v2 ? (int32_t)&g25 - 15 : (int32_t)&g25 + 15; // 0x8048477
    int32_t v4 = v3; // 0x8048479
  lab_0x8048486:
    // 0x8048486
    *(int16_t *)&g26 = 0x7830;
    function_8048d34();
    *(int16_t *)&g27 = 0x7830;
    function_8048d34();
    *(int16_t *)&g28 = 0x7830;
    function_8048d34();
    *(int16_t *)&g29 = 0x7830;
    function_8048d34();
    *(int16_t *)&g30 = 0x7830;
    function_8048d34();
    if ((g23 & 4) != 0) {
        // 0x8048529
        *(char *)&g31 = 82;
    }
    if ((g23 & 2) != 0) {
        // 0x8048534
        *(char *)&g32 = 87;
    }
    if (g23 % 2 != 0) {
        // 0x804853f
        *(char *)&g33 = 88;
    }
    // 0x8048542
    *(int16_t *)&g34 = 0x7830;
    function_8048d11();
    g40 = v4;
    *(char *)&g35 = 10;
    __asm_int(128);
    int32_t result; // 0x8048445
    return result;
}

// Address range: 0x8048580 - 0x8048689
int32_t function_8048580(void) {
    // 0x8048580
    if (g18 == 0) {
        // 0x804858e
        __asm_int(128);
        return 4;
    }
    // 0x804859f
    function_8048d11();
    int32_t v1; // 0x8048580
    char v2 = v1; // 0x80485af
    g40 = v2;
    function_8048d11();
    g40 = v2;
    __asm_int(128);
    __asm_int(128);
    __asm_int(128);
    __asm_int(128);
    __asm_int(128);
    __asm_int(128);
    __asm_int(128);
    int32_t v3; // 0x8048580
    int32_t v4 = &v3; // 0x804865d
    __asm_int(128);
    int32_t * v5 = (int32_t *)(v4 - 4); // 0x8048662
    *v5 = 0;
    *(int32_t *)(v4 - 8) = 3;
    __asm_int(128);
    int32_t result = function_8048689(); // 0x8048679
    int32_t v6 = *v5 + 1; // 0x804867e
    while (g18 != (int16_t)v6) {
        // 0x8048662
        *v5 = v6;
        *(int32_t *)(v4 - 8) = 3;
        __asm_int(128);
        result = function_8048689();
        v6 = *v5 + 1;
    }
    // 0x8048688
    return result;
}

// Address range: 0x8048689 - 0x80487fb
int32_t function_8048689(void) {
    // 0x8048689
    function_8048d11();
    int32_t result; // 0x8048689
    g40 = result;
    __asm_rep_stosb_memset("                                                                          \n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align       \n\nThere are    section headers, starting at offset 0x     \nThere are    program headers, starting at offset      ", 32, 74);
    bool v1; // 0x8048689
    int32_t v2 = v1 ? -1 : 1; // 0x80486cb
    int32_t v3 = (int32_t)&g36; // 0x80486c6
    int32_t v4 = (int32_t)"                                                                         \n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align       \n\nThere are    section headers, starting at offset 0x     \nThere are    program headers, starting at offset      "; // 0x80486c6
    char v5 = *(char *)v3; // 0x80486cb
    v3 += v2;
    *(char *)v4 = v5;
    v4 += v2;
    while (v5 != 0) {
        // 0x80486cb
        v5 = *(char *)v3;
        v3 += v2;
        *(char *)v4 = v5;
        v4 += v2;
    }
    // 0x80486d1
    *(char *)(v4 - 1) = 32;
    int32_t v6 = 0;
    while (g19 != *(int32_t *)(v6 + (int32_t)&g3)) {
        // 0x80486fa
        if (v6 == 399) {
            goto lab_0x8048705;
        }
        v6 += 21;
    }
    // 0x80486e5
    __asm_rep_movsb_memcpy("                                                       \n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align       \n\nThere are    section headers, starting at offset 0x     \nThere are    program headers, starting at offset      ", (char *)(v6 + (int32_t)&g4), 17);
    int32_t v7 = v1 ? (int32_t)"                                                       \n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align       \n\nThere are    section headers, starting at offset 0x     \nThere are    program headers, starting at offset      " - 17 : (int32_t)"                                                       \n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align       \n\nThere are    section headers, starting at offset 0x     \nThere are    program headers, starting at offset      " + 17; // 0x80486f6
    v3 = v7;
  lab_0x8048705:
    // 0x8048705
    function_8048d34();
    function_8048d34();
    function_8048d34();
    if (g21 < 16) {
        // 0x804874b
        *"                \n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align       \n\nThere are    section headers, starting at offset 0x     \nThere are    program headers, starting at offset      " = 48;
    }
    // 0x804874f
    function_8048d11();
    char v8 = v3; // 0x804875a
    g40 = v8;
    if (g20 % 2 != 0) {
        // 0x8048772
        *"             \n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align       \n\nThere are    section headers, starting at offset 0x     \nThere are    program headers, starting at offset      " = 87;
    }
    if ((g20 & 2) != 0) {
        // 0x804877d
        *"            \n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align       \n\nThere are    section headers, starting at offset 0x     \nThere are    program headers, starting at offset      " = 65;
    }
    if ((g20 & 4) != 0) {
        // 0x8048788
        *"           \n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align       \n\nThere are    section headers, starting at offset 0x     \nThere are    program headers, starting at offset      " = 88;
    }
    // 0x804878b
    function_8048d11();
    g40 = v8;
    function_8048d11();
    g40 = v8;
    function_8048d11();
    g40 = v8;
    __asm_int(128);
    return result;
}

// Address range: 0x80487fb - 0x8048cc6
int32_t function_80487fb(void) {
    int32_t v1 = 4; // bp-36, 0x8048804
    __asm_int(128);
    v1 = 4;
    __asm_int(128);
    int32_t v2 = &v1; // 0x8048816
    int32_t * v3 = (int32_t *)(v2 - 4);
    int32_t * v4 = (int32_t *)(v2 - 8);
    int32_t * v5 = (int32_t *)(v2 - 12);
    int32_t * v6 = (int32_t *)(v2 - 16);
    int32_t * v7 = (int32_t *)(v2 - 20);
    int32_t * v8 = (int32_t *)(v2 - 24);
    int32_t * v9 = (int32_t *)(v2 - 28);
    int32_t * v10 = (int32_t *)(v2 - 32);
    int32_t v11 = 0; // 0x8048817
    unsigned char v12 = *(char *)(v11 + (int32_t)&g11); // 0x8048820
    int32_t v13 = (int32_t)&g37; // 0x8048828
    if (v12 < 10) {
        // 0x804882a
        *(char *)&g37 = 48;
        v13 = &g38;
    }
    // 0x8048832
    *v3 = (int32_t)v12;
    *v4 = (int32_t)"  Magic:     Class:                             ELFCLASS32 (32-bit object)\nELFCLASS64 (64-bit object)\n  Data:                              ELFDATA2LSB (2 complement, little endian)\nELFDATA2MSB (2 complement, big endian)\n  Type:                                Machine:                             Version:                           EV_CURRENT (Current version)\nEV_NONE (Invalid version)\n  Entry point address:                 Start of program headers:            Start of section headers:            Flags:                             0x  Size of this header:                 Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
    *v5 = 11;
    int32_t v14; // 0x80487fb
    *v6 = v14;
    *v7 = v2;
    *v8 = v11;
    int32_t v15; // 0x80487fb
    *v9 = v15;
    *v10 = v13;
    function_8048d11();
    g40 = v15;
    int32_t v16 = *v10; // 0x8048843
    int32_t v17 = *v9; // 0x8048843
    int32_t v18 = *v8; // 0x8048843
    int32_t v19 = *v6; // 0x8048843
    *(char *)&g39 = 32;
    *v3 = 4;
    __asm_int(128);
    int32_t v20 = (int32_t)&g37; // 0x804885e
    int32_t v21 = &g40; // 0x804885e
    v11 = v18 + 1;
    while (v18 != 15) {
        // 0x8048819
        v12 = *(char *)(v11 + (int32_t)&g11);
        v13 = (int32_t)&g37;
        if (v12 < 10) {
            // 0x804882a
            *(char *)&g37 = 48;
            v13 = &g38;
        }
        // 0x8048832
        *v3 = (int32_t)v12;
        *v4 = v20;
        *v5 = v21;
        *v6 = v19;
        *v7 = v2;
        *v8 = v11;
        *v9 = v17;
        *v10 = v13;
        function_8048d11();
        g40 = v17;
        v16 = *v10;
        v17 = *v9;
        v18 = *v8;
        v19 = *v6;
        *(char *)&g39 = 32;
        *v3 = 4;
        __asm_int(128);
        v20 = (int32_t)&g37;
        v21 = &g40;
        v11 = v18 + 1;
    }
    int32_t v22 = v1; // 0x8048860
    v1 = 4;
    __asm_int(128);
    v1 = 4;
    int32_t v23 = v2 + 4; // 0x8048878
    __asm_int(128);
    int32_t v24 = v19; // 0x80488a0
    int32_t v25 = v22; // 0x80488a0
    int32_t v26 = v17; // 0x80488a0
    int32_t v27 = v16; // 0x80488a0
    if (g12 >= 3) {
        // 0x804888a
        v1 = g12;
        *v3 = (int32_t)"  Class:                             ELFCLASS32 (32-bit object)\nELFCLASS64 (64-bit object)\n  Data:                              ELFDATA2LSB (2 complement, little endian)\nELFDATA2MSB (2 complement, big endian)\n  Type:                                Machine:                             Version:                           EV_CURRENT (Current version)\nEV_NONE (Invalid version)\n  Entry point address:                 Start of program headers:            Start of section headers:            Flags:                             0x  Size of this header:                 Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
        *v4 = 37;
        *v5 = v19;
        *v6 = v23;
        *v7 = v22;
        *v8 = v17;
        *v9 = v16;
        function_8048d11();
        g40 = v17;
        v27 = *v9;
        v26 = *v8;
        v25 = *v7;
        v24 = *v5;
    }
    // 0x80488c3
    v1 = 4;
    __asm_int(128);
    v1 = 4;
    __asm_int(128);
    int32_t v28 = v24; // 0x80488fa
    int32_t v29 = v25; // 0x80488fa
    int32_t v30 = v26; // 0x80488fa
    int32_t v31 = v27; // 0x80488fa
    if (g13 >= 3) {
        // 0x80488e4
        v1 = g13;
        *v3 = (int32_t)"  Data:                              ELFDATA2LSB (2 complement, little endian)\nELFDATA2MSB (2 complement, big endian)\n  Type:                                Machine:                             Version:                           EV_CURRENT (Current version)\nEV_NONE (Invalid version)\n  Entry point address:                 Start of program headers:            Start of section headers:            Flags:                             0x  Size of this header:                 Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
        *v4 = 37;
        *v5 = v24;
        *v6 = v23;
        *v7 = v25;
        *v8 = v26;
        *v9 = v27;
        function_8048d11();
        g40 = v26;
        v31 = *v9;
        v30 = *v8;
        v29 = *v7;
        v28 = *v5;
    }
    // 0x804891d
    v1 = 4;
    __asm_int(128);
    v1 = 4;
    __asm_int(128);
    v1 = v29;
    int32_t v32 = 0;
    int32_t v33 = v29; // 0x8048941
    int32_t v34 = v28; // 0x8048941
    int32_t v35 = v30; // 0x8048941
    int32_t v36 = v31; // 0x8048941
    while (*(int16_t *)(v32 + (int32_t)&g1) != g14) {
        int32_t v37 = v32 + 33; // 0x8048951
        if (v32 == 198) {
            // 0x804895c
            *v3 = (int32_t)g14;
            *v4 = (int32_t)"  Type:                                Machine:                             Version:                           EV_CURRENT (Current version)\nEV_NONE (Invalid version)\n  Entry point address:                 Start of program headers:            Start of section headers:            Flags:                             0x  Size of this header:                 Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
            *v5 = 37;
            *v6 = v28;
            *v7 = v2;
            *v8 = v37;
            *v9 = v30;
            *v10 = v31;
            function_8048d11();
            g40 = v30;
            v36 = *v10;
            v35 = *v9;
            v34 = *v6;
            v33 = v1;
            goto lab_0x80489ac;
        }
        v32 = v37;
        v33 = v29;
        v34 = v28;
        v35 = v30;
        v36 = v31;
    }
    goto lab_0x80489ac;
  lab_0x80489ac:
    // 0x80489ac
    v1 = 4;
    __asm_int(128);
    v1 = 4;
    __asm_int(128);
    v1 = v33;
    int32_t v38 = 0;
    int32_t v39 = v33; // 0x80489d1
    int32_t v40 = v34; // 0x80489d1
    int32_t v41 = v35; // 0x80489d1
    int32_t v42 = v36; // 0x80489d1
    while (*(int16_t *)(v38 + (int32_t)&g2) != g15) {
        int32_t v43 = v38 + 32; // 0x80489e1
        if (v38 == 544) {
            // 0x80489ec
            *v3 = (int32_t)g15;
            *v4 = (int32_t)"  Machine:                             Version:                           EV_CURRENT (Current version)\nEV_NONE (Invalid version)\n  Entry point address:                 Start of program headers:            Start of section headers:            Flags:                             0x  Size of this header:                 Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
            *v5 = 37;
            *v6 = v34;
            *v7 = v2;
            *v8 = v43;
            *v9 = v35;
            *v10 = v36;
            function_8048d11();
            g40 = v35;
            v42 = *v10;
            v41 = *v9;
            v40 = *v6;
            v39 = v1;
            goto lab_0x8048a0d;
        }
        v38 = v43;
        v39 = v33;
        v40 = v34;
        v41 = v35;
        v42 = v36;
    }
    goto lab_0x8048a0d;
  lab_0x8048a0d:
    // 0x8048a0d
    v1 = 4;
    __asm_int(128);
    v1 = 4;
    __asm_int(128);
    int32_t v44 = v40; // 0x8048a28
    int32_t v45 = v39; // 0x8048a28
    int32_t v46 = v41; // 0x8048a28
    int32_t v47 = v42; // 0x8048a28
    if (g16 >= 2) {
        // 0x8048a2f
        v1 = g16;
        *v3 = (int32_t)"  Version:                           EV_CURRENT (Current version)\nEV_NONE (Invalid version)\n  Entry point address:                 Start of program headers:            Start of section headers:            Flags:                             0x  Size of this header:                 Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
        *v4 = 37;
        *v5 = v40;
        *v6 = v23;
        *v7 = v39;
        *v8 = v41;
        *v9 = v42;
        function_8048d11();
        g40 = v41;
        v44 = *v5;
        v45 = *v7;
        v46 = *v8;
        v47 = *v9;
    }
    // 0x8048a68
    v1 = 4;
    __asm_int(128);
    v1 = 4;
    __asm_int(128);
    v1 = 4;
    *v3 = (int32_t)"  Entry point address:                 Start of program headers:            Start of section headers:            Flags:                             0x  Size of this header:                 Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
    *v4 = 37;
    *v5 = v44;
    *v6 = v23;
    *v7 = v45;
    *v8 = v46;
    *v9 = v47;
    function_8048d11();
    g40 = v46;
    int32_t v48 = *v8; // 0x8048a95
    v1 = 4;
    __asm_int(128);
    v1 = 4;
    __asm_int(128);
    v1 = function_8048d00();
    *v3 = (int32_t)"  Start of program headers:            Start of section headers:            Flags:                             0x  Size of this header:                 Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
    *v4 = 37;
    *v6 = v23;
    *v8 = v48;
    function_8048d11();
    g40 = v48;
    int32_t v49 = *v8; // 0x8048ad0
    function_8048cc6();
    v1 = 4;
    __asm_int(128);
    v1 = function_8048d00();
    *v3 = (int32_t)"  Start of section headers:            Flags:                             0x  Size of this header:                 Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
    *v4 = 37;
    *v6 = v23;
    *v8 = v49;
    function_8048d11();
    g40 = v49;
    function_8048cc6();
    v1 = 4;
    __asm_int(128);
    v1 = function_8048d00();
    *v3 = (int32_t)"  Flags:                             0x  Size of this header:                 Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
    *v4 = 39;
    *v6 = v23;
    function_8048d11();
    int32_t v50 = *v8; // 0x8048b36
    g40 = 10;
    v1 = 4;
    __asm_int(128);
    v1 = 4;
    __asm_int(128);
    v1 = function_8048d00();
    *v3 = (int32_t)"  Size of this header:                 Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
    *v4 = 37;
    *v6 = v23;
    *v8 = v50;
    function_8048d11();
    g40 = v50;
    int32_t v51 = *v8; // 0x8048b7d
    function_8048ce3();
    v1 = 4;
    __asm_int(128);
    v1 = function_8048d00();
    *v3 = (int32_t)"  Size of program headers:             Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
    *v4 = 37;
    *v6 = v23;
    *v8 = v51;
    function_8048d11();
    g40 = v51;
    function_8048ce3();
    v1 = 4;
    __asm_int(128);
    v1 = function_8048d00();
    *v3 = (int32_t)"  Number of program headers:           Size of section headers:             Number of section headers:           Section header string table index: \n";
    *v4 = 37;
    *v6 = v23;
    function_8048d11();
    int32_t v52 = *v8; // 0x8048be9
    g40 = 10;
    v1 = 4;
    __asm_int(128);
    v1 = 4;
    __asm_int(128);
    v1 = function_8048d00();
    *v3 = (int32_t)"  Size of section headers:             Number of section headers:           Section header string table index: \n";
    *v4 = 37;
    *v6 = v23;
    *v8 = v52;
    function_8048d11();
    g40 = v52;
    function_8048ce3();
    v1 = 4;
    __asm_int(128);
    v1 = function_8048d00();
    *v3 = (int32_t)"  Number of section headers:           Section header string table index: \n";
    *v4 = 37;
    *v6 = v23;
    function_8048d11();
    g40 = 10;
    v1 = 4;
    __asm_int(128);
    v1 = 4;
    __asm_int(128);
    v1 = function_8048d00();
    *v3 = (int32_t)"  Section header string table index: \n";
    *v4 = 37;
    *v6 = v23;
    function_8048d11();
    g40 = 10;
    v1 = 4;
    __asm_int(128);
    return *(int32_t *)(v2 + 32);
}

// Address range: 0x8048cc6 - 0x8048ce3
int32_t function_8048cc6(void) {
    // 0x8048cc6
    __asm_int(128);
    __asm_int(128);
    return 4;
}

// Address range: 0x8048ce3 - 0x8048d00
int32_t function_8048ce3(void) {
    // 0x8048ce3
    __asm_int(128);
    __asm_int(128);
    return 4;
}

// Address range: 0x8048d00 - 0x8048d11
int32_t function_8048d00(void) {
    // 0x8048d00
    __asm_rep_stosb_memset((char *)&g37, 0, 11);
    int32_t result; // 0x8048d00
    return result;
}

// Address range: 0x8048d11 - 0x8048d34
int32_t function_8048d11(void) {
    // 0x8048d11
    int32_t v1; // 0x8048d11
    int32_t v2 = v1;
    int32_t v3 = 0;
    int32_t v4; // 0x8048d11
    uint32_t v5 = v4;
    int32_t v6; // 0x8048d11
    uint32_t v7 = v5 % v6;
    int32_t v8; // 0x8048d11
    if ((char)v7 < 10) {
        // 0x8048d21
        v8 = (v7 + 48) % 256 | v7 & -256;
    } else {
        // 0x8048d1c
        v8 = (v7 + 55) % 256 | v7 & -256;
    }
    int32_t result = v8;
    int32_t v9 = v2 - 4; // 0x8048d24
    *(int32_t *)v9 = result;
    v4 = v5 / v6;
    int32_t v10 = v3 + 1; // 0x8048d28
    while (v6 <= v5) {
        // 0x8048d13
        v2 = v9;
        v3 = v10;
        v5 = v4;
        v7 = v5 % v6;
        if ((char)v7 < 10) {
            // 0x8048d21
            v8 = (v7 + 48) % 256 | v7 & -256;
        } else {
            // 0x8048d1c
            v8 = (v7 + 55) % 256 | v7 & -256;
        }
        // 0x8048d24
        result = v8;
        v9 = v2 - 4;
        *(int32_t *)v9 = result;
        v4 = v5 / v6;
        v10 = v3 + 1;
    }
    // 0x8048d2c
    *(char *)v6 = (char)result;
    int32_t v11 = v3; // 0x8048d31
    if (v3 == 0) {
        // 0x8048d33
        return result;
    }
    int32_t v12 = v2; // 0x8048d31
    int32_t v13; // 0x8048d11
    bool v14; // 0x8048d11
    int32_t v15 = v13 + (v14 ? -1 : 1); // 0x8048d2d
    int32_t result2 = *(int32_t *)v12;
    *(char *)v15 = (char)result2;
    v11--;
    v12 += 4;
    v13 = v15;
    while (v11 != 0) {
        // 0x8048d2c
        v15 = v13 + (v14 ? -1 : 1);
        result2 = *(int32_t *)v12;
        *(char *)v15 = (char)result2;
        v11--;
        v12 += 4;
        v13 = v15;
    }
    // 0x8048d33
    return result2;
}

// Address range: 0x8048d34 - 0x8048d79
int32_t function_8048d34(void) {
    // 0x8048d34
    function_8048d11();
    int32_t result; // 0x8048d34
    char v1 = result; // 0x8048d40
    g40 = v1;
    if (v1 >= 8) {
        // 0x8048d77
        return result;
    }
    int32_t v2 = result - (0x1000000 * result >> 24); // 0x8048d52
    if (v2 != 0) {
        int32_t v3 = v2; // 0x8048d60
        int32_t v4; // 0x8048d34
        *(char *)v4 = 48;
        v3--;
        bool v5; // 0x8048d34
        v4 += (v5 ? -1 : 1);
        while (v3 != 0) {
            // 0x8048d5f
            *(char *)v4 = 48;
            v3--;
            v4 += (v5 ? -1 : 1);
        }
    }
    // 0x8048d63
    function_8048d11();
    g40 = v1;
    // 0x8048d77
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gc
// Detected functions: 11

