// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C()
void fn0804804C()
{
	ptr32 fp;
	g_dw8048440 = 0x080534AC;
	g_b8048457 = (byte) sys_ioctl(0x01, 0x5401, 0x0804845B);
	union Eq_18 * ebp_4 = &g_t804845B;
	word32 * esp_26 = fp + 8;
	while (true)
	{
		struct Eq_23 * esi_29 = *esp_26;
		++esp_26;
		struct Eq_23 * esi_137 = esi_29;
		if (esi_29 == null)
			break;
		if (Mem28[esi_29 + 0x00:byte] != 0x2D)
			goto l080480A3;
		byte * esi_100 = esi_29 + 1;
		if (Mem28[esi_29 + 0x00:byte] == Mem28[esi_29 + 1:byte])
		{
			struct Eq_23 * esi_42 = *esp_26;
			++esp_26;
			esi_137 = esi_42;
			if (esi_42 == null)
				break;
			goto l080480A3;
		}
		while (true)
		{
			byte al_102 = *esi_100;
			++esi_100;
			if (al_102 == 0x00)
				break;
			byte * edi_109 = &g_b80483E8;
			struct Eq_75 * ecx_111 = (struct Eq_75 *) 0x0C;
			while (ecx_111 != null)
			{
				edi_109 = edi_144 + 1;
				--ecx_111;
				edi_144 = edi_109;
				if (al_102 != *edi_144)
					break;
			}
			ecx_111[0x0804844C] = (struct Eq_75) al_102;
			if (al_102 == 0x43)
				g_dw8048456 = 0x00;
		}
	}
	struct Eq_23 * esp_50 = esp_26 - 4;
	Mem51[esp_50 + 0x00:word32] = 0x2E;
	esp_50->dwFFFFFFFC = 0x00;
	esi_137 = esp_50;
l080480A3:
	do
	{
		ebp_4 = fn080480C7(ebp_4, esi_137);
		struct Eq_101 * esp_68 = (struct Eq_101 *) <invalid>;
		struct Eq_23 * esi_77 = esp_68->ptr0004;
		esi_137 = esi_77;
	} while (esi_77 != null);
	ebp_4->u2.tFFFFFFFD.u0 = 0x3A;
	fn08048395(ebp_4, &g_t80534AC);
	int32 ebx_94 = ebp_4->u2.dwFFFFFFED;
	esp_68->ptr0004 = (struct Eq_23 *) 0x01;
	sys_exit(ebx_94);
}

// 080480C7: Register (ptr32 Eq_18) fn080480C7(Register (ptr32 Eq_18) ebp, Register (ptr32 Eq_23) esi)
// Called from:
//      fn0804804C
//      fn08048395
union Eq_18 * fn080480C7(union Eq_18 * ebp, struct Eq_23 * esi)
{
	ptr32 fp;
	ebp->u0 = 0x0A;
	word32 edi_14 = ebp + 1;
	do
	{
		byte al_12 = Mem11[esi + 0x00:byte];
		*edi_14 = al_12;
		++esi;
		++edi_14;
	} while (al_12 != 0x00);
	word32 edi_31 = edi_14 - (ebp + 1);
	char * ebx_37;
	int32 ecx_38;
	Eq_157 edx_39;
	byte al_409;
	fn0804827F(ebp + 1, ebp, ebp + 1, edi_31 - 0x01, out al_409, out ecx_38, out edx_39, out ebx_37);
	struct Eq_101 * eax_36 = (struct Eq_101 *) <invalid>;
	word32 esi_172 = ebp + 1;
	Eq_152 edi_134 = edi_31 - 0x01;
	bool Z_42 = <invalid>;
	bool C_41 = <invalid>;
	byte al_63 = (byte) eax_36;
	if (C_41)
	{
		fn080480F2(ebp, ebp + 1);
		return ebp;
	}
	else if (Z_42)
	{
		fn0804810A(ebp, ebp + 1, edi_31 - 0x01);
		return ebp;
	}
	else if (al_63 != (ebp->u2).bFFFFFFF2)
	{
		fn0804810A(ebp, ebp + 1, edi_31 - 0x01);
		return ebp;
	}
	else if (edx_39 == 0x00)
	{
		Eq_194 eax_86 = sys_open(ebx_37, ecx_38, edx_39);
		Eq_194 eax_162 = eax_86;
		if (eax_86 >= 0x00)
		{
			Eq_109 eax_94 = ebp->u2.tFFFFFFFD.u1;
			Eq_212 al_95 = (byte) eax_94;
			byte ah_104 = SLICE(eax_94, byte, 8);
			word16 eax_16_16_110 = SLICE(eax_94, word16, 16);
			if (al_95 != 0x00)
			{
				ebp->u2.tFFFFFFFE.u0 = (byte) al_95;
				Mem112[ebp + 1 + (edi_31 - 0x01):word32] = SEQ(eax_16_16_110, 0x0A, al_95);
				word32 ecx_102 = ebp + 1;
				Eq_240 edx_103 = (word32) edi_31.u0 + 1;
				if (ah_104 != 0x00)
				{
					ecx_102 = ebp;
					edx_103 = (word32) edi_31.u0 + 2;
				}
				sys_write(0x01, ecx_102, edx_103);
			}
			Mem133[ebp + 1 + (edi_31 - 0x01):byte] = 0x2F;
			edi_134 = edi_31;
			Eq_194 ebx_137 = eax_86;
			ptr32 esp_138 = fp - 4;
			while (true)
			{
				Eq_194 eax_148 = sys_getdents(ebx_137, &g_t80514AC, 0x2000);
				ptr32 ecx_139 = 134550700;
				int32 edx_147 = 0x2000;
				Eq_194 eax_149 = eax_148;
				if (eax_148 <= 0x00)
					break;
				do
				{
					struct Eq_295 * esp_192 = esp_138 - 4;
					esp_192->t0000.u0 = (int32) eax_149;
					esp_192->ptrFFFFFFFC = ecx_139;
					esp_192->dwFFFFFFF8 = edx_147;
					esp_192->tFFFFFFF4.u0 = (int32) ebx_137;
					esp_192->ptrFFFFFFF0 = esp_138;
					esp_192->ptrFFFFFFEC = ebp;
					esp_192->ptrFFFFFFE8 = esi_172;
					esp_192->tFFFFFFE4.u0 = (int32) edi_134;
					struct Eq_23 * esi_219 = ecx_139 + 0x0A;
					esp_192->ptrFFFFFFE0 = esi_219;
					word32 edx_229 = SLICE((int64) eax_149, word32, 32);
					word32 edi_216 = edi_134 + esi_172;
					do
					{
						byte al_224 = Mem223[esi_219 + 0x00:byte];
						*edi_216 = al_224;
						++esi_219;
						++edi_216;
						++edx_229;
					} while (al_224 != 0x00);
					struct Eq_23 * edi_236 = edx_229 - 1;
					struct Eq_23 * esi_238 = esp_192->ptrFFFFFFE0;
					struct Eq_358 * esp_239 = esp_192 - 28;
					if (Mem227[esi_238 + 0x00:byte] != 0x2E || al_224 != (ebp->u2).bFFFFFFF3)
					{
						struct Eq_366 * ebx_251;
						byte al_414;
						word32 ecx_415;
						word32 edx_416;
						fn0804827F(esi_172, ebp, esi_238, edx_229 - 1, out al_414, out ecx_415, out edx_416, out ebx_251);
						struct Eq_101 * eax_250 = (struct Eq_101 *) <invalid>;
						bool Z_256 = <invalid>;
						bool C_255 = <invalid>;
						byte al_258 = (byte) eax_250;
						if (C_255)
							goto l08048347;
						if (!Z_256 && al_258 != (ebp->u2).bFFFFFFF6)
						{
							esp_192->ptrFFFFFFE0 = esi_238;
							struct Eq_433 * esp_263 = esp_192 - 32;
							if (Mem264[esi_238 + 0x00:byte] == 0x2E)
							{
								Eq_26 al_269 = esi_238[1];
								if (al_269 == 0x2E)
									al_269 = esi_238[2];
								if (al_269 != 0x00)
									goto l08048338;
							}
							else
							{
l08048338:
								esp_192->dwFFFFFFDC = edx_229 - 1;
								fn080480F2(ebp, ebx_251);
								edi_236 = esp_192->ptrFFFFFFE0;
								esp_263 = esp_192 - 0x1C;
							}
							esi_238 = esp_263->dw0000;
							esp_239 = (struct Eq_358 *) (&esp_263->dw0000 + 1);
						}
						fn0804810A(ebp, esi_238, edi_236);
						esp_239 = &esp_239->dw0000 + 1;
					}
l08048347:
					struct Eq_386 * esp_330 = &esp_239->dw0000 + 1;
					struct Eq_389 * ecx_340 = esp_330->ptr0014;
					edx_147 = (word32) ecx_340->w0008;
					edi_134 = esp_239->dw0000;
					esi_172 = esp_330->ptr0000;
					ebp = esp_330->ptr0004;
					ebx_137.u0 = esp_330->t000C.u0;
					esp_138 = &esp_330->dw0018 + 1;
					ecx_139 = ecx_340 + edx_147 / 0x0A;
					eax_149 = esp_330->dw0018 - edx_147;
				} while (eax_149 > 0x00);
			}
			struct Eq_277 * esp_155 = esp_138 - 4;
			esp_155->t0000.u0 = (int32) eax_148;
			esp_155->dwFFFFFFFC = 0x06;
			sys_close(ebx_137);
			eax_162.u0 = esp_155->t0000.u0;
		}
		int32 eax_166 = -eax_162;
		if (eax_162 != 0x00)
		{
			byte al_410;
			word32 ecx_411;
			word32 edx_412;
			word32 ebx_413;
			fn08048261(eax_166, ebp, esi_172, edi_134, out al_410, out ecx_411, out edx_412, out ebx_413);
			return ebp;
		}
		else
		{
			fn080482A0(ebp);
			return ebp;
		}
	}
	else
	{
		fn080480F2(ebp, ebp + 1);
		return ebp;
	}
}

// 080480F2: void fn080480F2(Register (ptr32 Eq_18) ebp, Register (ptr32 Eq_366) esi)
// Called from:
//      fn080480C7
void fn080480F2(union Eq_18 * ebp, struct Eq_366 * esi)
{
	struct Eq_23 * edi_11 = ebp->u2.ptrFFFFFFE5;
	do
	{
		byte al_9 = Mem8[esi + 0x00:byte];
		Mem12[edi_11 + 0x00:byte] = al_9;
		++esi;
		++edi_11;
	} while (al_9 != 0x00);
	ebp->u2.ptrFFFFFFE5 = edi_11;
	sys_brk(edi_11 + 0x00001000);
}

// 0804810A: void fn0804810A(Register (ptr32 Eq_18) ebp, Register (ptr32 Eq_23) esi, Register (ptr32 Eq_23) edi)
// Called from:
//      fn080480C7
void fn0804810A(union Eq_18 * ebp, struct Eq_23 * esi, struct Eq_23 * edi)
{
	int64 edx_eax_17 = (int64) edi;
	byte * edi_15 = &g_b804946C;
	byte dh_18 = SLICE(edx_eax_17, byte, 40);
	word24 edx_24_8_24 = SLICE(edx_eax_17, word24, 40);
	word24 eax_24_8_69 = SLICE(edx_eax_17, word24, 8);
	if (dh_18 != (ebp->u2).bFFFFFFF7)
	{
		Eq_543 eax_22 = ebp->u2.tFFFFFFA9.u0;
		fn080483B9(eax_22, SEQ(edx_24_8_24, 0x08), &g_b804946C);
		g_b804946C = 0x20;
		eax_24_8_69 = SLICE(eax_22, word24, 8);
		edi_15 = &g_b804946D;
	}
	word24 edx_24_8_45 = SLICE(edx_eax_17, word24, 40);
	if (dh_18 != (ebp->u2).bFFFFFFF9)
	{
		uint32 eax_39 = ebp->u2.dwFFFFFFC1;
		fn080483B9(eax_39 >> 0x01, SEQ(edx_24_8_45, 0x04), edi_15);
		*edi_15 = 0x20;
		eax_24_8_69 = SLICE(eax_39 >> 0x01, word24, 8);
		++edi_15;
	}
	word16 eax_16_16_268 = SLICE(eax_24_8_69, word16, 8);
	if (dh_18 != (ebp->u2).bFFFFFFFB)
	{
		ui32 edx_61 = ebp->u2.dwFFFFFFAD;
		bcu8 dh_62 = SLICE(edx_61, byte, 8);
		*edi_15 = g_a80483DF[(uint32) (dh_62 >> 0x04)];
		byte dl_444 = (byte) edx_61;
		struct __kernel_old_timeval * edi_128 = edi_15 + 1;
		ui8 dh_102 = __rcr<byte,byte>(dh_62, 0x01, SLICE(cond(dh_62 >> 0x04), bool, 1));
		bool v87_464 = (dh_62 & 0x02) != 0x00;
		uint32 ecx_137 = 292;
		while (true)
		{
			byte cl_91 = (byte) ecx_137;
			byte al_108 = 0x07;
			if (!v87_464)
				al_108 = cl_91 & 0x07;
			if ((cl_91 & 0x01) != 0x00)
			{
				dh_102 <<= 0x01;
				if ((dh_102 & 0x08) != 0x00)
					al_108 = (al_108 + cl_91 & 0x1F) + 0x01;
			}
			edi_128->b0000 = g_a80483DB[(uint32) al_108];
			ecx_137 >>= 0x01;
			++edi_128;
			bool C_446 = SLICE(cond(ecx_137), bool, 1);
			if (ecx_137 == 0x00)
				break;
			dl_444 = __rcl<byte,byte>(dl_444, 0x01, C_446);
			v87_464 = (dl_444 & 0x80) != 0x00;
		}
		uint32 ebx_140 = ecx_137 + 3;
		do
		{
			g_t80483B9();
			--ebx_140;
		} while (ebx_140 != 0x00);
		if ((dh_62 >> 0x04 & ~0x04) == 0x02)
			g_t80483B9();
		struct timezone * eax_195;
		g_t80483B9();
		sys_gettimeofday(edi_128, eax_195);
		word24 ecx_24_8_461 = SLICE(eax_195, word24, 8);
		Eq_792 eax_208 = edi_128->b0000 - ((ebp->u2).tFFFFFFCD).u1;
		struct Eq_800 * ebx_210 = &g_t80483F6;
		do
		{
			--ebx_210;
			int64 edx_eax_212 = (int64) eax_208;
			int32 ecx_218 = SEQ(ecx_24_8_461, ebx_210[4]);
			if (ecx_218 == 0x00)
				break;
			Eq_792 eax_228 = (int32) (edx_eax_212 /32 ecx_218);
			eax_208 = eax_228;
		} while (eax_228 != 0x00);
		word32 eax_248;
		g_t80483B9();
		edi_128->b0000 = (byte) ebx_210[(uint32) (byte) eax_248];
		edi_128[1] = (struct __kernel_old_timeval) 0x20;
		eax_16_16_268 = SLICE(eax_248, word16, 16);
		edi_15 = (byte *) (edi_128 + 2);
	}
	union Eq_212 * edi_274;
	word32 esi_275 = fn08048354(eax_16_16_268, edi, ebp, esi, edi_15, out edi_274);
	uint32 eax_280 = ebp->u2.dwFFFFFFAB;
	byte ah_285 = SLICE(eax_280 >> 0x1D, byte, 8);
	if ((byte) (eax_280 >> 0x1D) == 0x05 && ah_285 != (ebp->u2).bFFFFFFFB)
	{
		edi_274->u1 = 0x203E2D20;
		struct Eq_23 * ecx_313 = ebp->u2.ptrFFFFFFE5;
		fn08048354(SLICE(esi_275, word16, 16), sys_readlink(ebp + 1, ecx_313, 0x1000), ebp, ecx_313, edi_274 + 4, out edi_274);
	}
	else if (ah_285 != (ebp->u2).bFFFFFFFA)
	{
		Eq_212 al_297 = (eax_280 >> 0x1D)->t80483D5.u0;
		if (al_297 != 0x2A || (*((char *) ebp - 83) & 0x49) != 0x00)
		{
			edi_274->u0 = (byte) al_297;
			++edi_274;
		}
	}
	Eq_212 al_339 = 0x0A;
	if (ebp->u2.bFFFFFFFC == 0x00)
	{
		uint32 ecx_352 = (edi_274 - &g_b804946C >> 0x03) + 0x01;
		cu8 dl_355 = ebp->u2.bFFFFFFFF + (byte) ecx_352;
		if (dl_355 > 0x0A)
		{
			fn080482A0(ebp);
			dl_355 = (byte) ecx_352;
		}
		al_339.u0 = 0x09;
		if (dl_355 >= 0x09)
		{
			al_339.u0 = 0x0A;
			dl_355 = 0x00;
		}
		if ((dl_355 & 0x01) != 0x00)
		{
			edi_274->u0 = (byte) al_339;
			++edi_274;
			++dl_355;
		}
		ebp->u2.bFFFFFFFF = dl_355;
	}
	edi_274->u0 = (byte) al_339;
	ebp->u2.tFFFFFFFE.u0 = (byte) al_339;
	sys_write(0x01, &g_b804946C, edi_274 - 0x0804946B);
}

// 08048261: FlagGroup byte fn08048261(Register int32 eax, Register (ptr32 Eq_18) ebp, Register (ptr32 Eq_23) esi, Register Eq_152 edi, Register out Eq_165 alOut, Register out (ptr32 Eq_23) ecxOut, Register out ptr32 edxOut, Register out ptr32 ebxOut)
// Called from:
//      fn080480C7
//      fn0804827F
byte fn08048261(int32 eax, union Eq_18 * ebp, struct Eq_23 * esi, Eq_152 edi, union Eq_165 & alOut, struct Eq_23 & ecxOut, ptr32 & edxOut, ptr32 & ebxOut)
{
	ebp->u2.dwFFFFFFED = eax;
	fn080482A0(ebp);
	Mem17[edi + esi:word32] = 0x0A3F3F20;
	sys_write(0x02, esi, (word32) edi.u1 + 4);
	alOut.u1 = <invalid>;
	ecxOut = esi;
	edxOut = (word32) edi.u1 + 4;
	ebxOut = 0x02;
	return <invalid>;
}

// 0804827F: FlagGroup byte fn0804827F(Register (ptr32 Eq_23) ebx, Register (ptr32 Eq_18) ebp, Register (ptr32 Eq_23) esi, Register Eq_152 edi, Register out Eq_165 alOut, Register out Eq_166 ecxOut, Register out ptr32 edxOut, Register out (ptr32 Eq_23) ebxOut)
// Called from:
//      fn080480C7
byte fn0804827F(struct Eq_23 * ebx, union Eq_18 * ebp, struct Eq_23 * esi, Eq_152 edi, union Eq_165 & alOut, union Eq_166 & ecxOut, ptr32 & edxOut, struct Eq_23 & ebxOut)
{
	ptr32 edx;
	int32 eax_11 = sys_lstat(ebx, ebp - 91);
	int32 eax_13 = -eax_11;
	if (Test(ULT,eax_11 != 0x00))
	{
		struct Eq_23 * ebx_18;
		Eq_166 ecx_19;
		ptr32 edx_20;
		byte al_49;
		fn08048261(eax_13, ebp, esi, edi, out al_49, out ecx_19, out edx_20, out ebx_18);
		alOut.u1 = <invalid>;
		ecxOut = ecx_19;
		edxOut = edx_20;
		ebxOut = ebx_18;
		return <invalid>;
	}
	else
	{
		Eq_166 ecx_27 = ebp->u2.dwFFFFFFAB >> 0x1C & ~0x04;
		alOut.u1 = <invalid>;
		ecxOut = ecx_27;
		edxOut = edx;
		ebxOut = ebx;
		return <invalid>;
	}
}

// 080482A0: FlagGroup bool fn080482A0(Register (ptr32 Eq_18) ebp)
// Called from:
//      fn080480C7
//      fn0804810A
//      fn08048261
//      fn08048395
bool fn080482A0(union Eq_18 * ebp)
{
	bool Z_10 = SLICE(cond(0x00 - (ebp->u2).bFFFFFFFF), bool, 2);
	if (ebp->u2.bFFFFFFFF != 0x00)
	{
		ebp->u2.bFFFFFFFF = 0x00;
		sys_write(0x01, ebp, 0x01);
	}
	return Z_10;
}

// 08048354: Register (ptr32 Eq_23) fn08048354(Register word16 eax_16_16, Register (ptr32 Eq_23) ecx, Register (ptr32 Eq_18) ebp, Register (ptr32 Eq_23) esi, Register (ptr32 byte) edi, Register out (ptr32 byte) ediOut)
// Called from:
//      fn0804810A
struct Eq_23 * fn08048354(word16 eax_16_16, struct Eq_23 * ecx, union Eq_18 * ebp, struct Eq_23 * esi, byte * edi, byte & ediOut)
{
	byte ah;
	word32 edx_6 = ebp->u2.dwFFFFFFF4;
	byte dl_88 = (byte) edx_6;
	byte dh_92 = SLICE(edx_6, byte, 8);
	do
	{
		byte al_9 = Mem8[esi + 0x00:byte];
		++esi;
		word32 eax_123 = SEQ(eax_16_16, ah, al_9);
		if (dl_88 == 0x00)
		{
			word24 eax_24_8_36 = SEQ(eax_16_16, 0x5C);
			word32 eax_129 = SEQ(eax_16_16, 0x5C, al_9);
			if (al_9 != 0x5C)
			{
				eax_129 = SEQ(eax_16_16, 0x5C, al_9);
				if (al_9 == 0x22)
					goto l08048385;
				word32 eax_34 = SEQ(eax_24_8_36, al_9);
				if (al_9 <= 0x7E)
				{
					eax_34 = SEQ(eax_24_8_36, al_9);
					eax_123 = SEQ(eax_16_16, 0x5C, al_9);
					if (al_9 < 0x20)
						goto l0804836E;
					goto l08048390;
				}
l0804836E:
				if (dh_92 != 0x00)
				{
					word32 eax_40 = __ror<word32,byte>(eax_34, 0x08);
					*edi = (byte) eax_40;
					uint32 eax_50 = __rol<word32,byte>(SEQ(SLICE(eax_40, word24, 8), 0x0C), 0x02);
					byte * edi_45 = edi + 1;
					*edi_45 = (byte) eax_50;
					word16 ax_56 = __aam((byte) (eax_50 >> 0x1A));
					edi = edi_45 + 1;
					eax_129 = SEQ(SLICE(eax_50 >> 0x1A, word16, 16), SLICE(ax_56 + 0x3030, byte, 8), (byte) ax_56 + 0x30);
					goto l08048385;
				}
				eax_123 = SEQ(SLICE(eax_34, word24, 8), 0x3F);
			}
			else
			{
l08048385:
				byte ah_65 = SLICE(eax_129, byte, 8);
				eax_123 = eax_129;
				if (dh_92 != 0x00)
				{
					*edi = ah_65;
					++edi;
					eax_123 = eax_129;
				}
			}
		}
l08048390:
		*edi = (byte) eax_123;
		ah = SLICE(eax_123, byte, 8);
		eax_16_16 = SLICE(eax_123, word16, 16);
		++edi;
		--ecx;
	} while (ecx != null);
	ediOut = edi;
	return esi;
}

// 08048395: void fn08048395(Register (ptr32 Eq_18) ebp, Register (ptr32 Eq_23) esi)
// Called from:
//      fn0804804C
//      fn08048395
void fn08048395(union Eq_18 * ebp, struct Eq_23 * esi)
{
	struct Eq_23 * dwLoc08;
	fn080482A0(ebp);
	struct Eq_23 * edx_14 = ebp->u2.ptrFFFFFFE5;
	while (esi < edx_14)
	{
		ebp = fn080480C7(ebp, esi);
		fn08048395(ebp, edx_14);
		ebp->u2.ptrFFFFFFE5 = edx_14;
		esi = dwLoc08;
	}
}

// 080483B9: void fn080483B9(Register Eq_543 eax, Register word32 edx, Register (ptr32 byte) edi)
// Called from:
//      fn0804810A
void fn080483B9(Eq_543 eax, word32 edx, byte * edi)
{
	word32 ecx_10 = edx;
	while (true)
	{
		word24 ecx_24_8_49 = SLICE(ecx_10, word24, 8);
		if (ecx_10 == 0x00)
			break;
		*edi = 0x20;
		++edi;
		--ecx_10;
	}
	Eq_543 eax_15 = eax;
	int32 ecx_50 = SEQ(ecx_24_8_49, 0x0A);
	do
	{
		int64 edx_eax_22 = (int64) eax_15;
		--edi;
		*edi = (byte) (edx_eax_22 % ecx_50) + 0x30;
		Eq_543 eax_28 = (int32) (edx_eax_22 /32 ecx_50);
		eax_15 = eax_28;
	} while (eax_28 != 0x00);
}

byte g_a80483DB[] = // 080483DB
	{
	};
byte g_a80483DF[] = // 080483DF
	{
	};
byte g_b80483E8 = 0x31; // 080483E8
Eq_800 g_t80483F6 = // 080483F6
	{
		
		{
		},
		0x00,
	};
word32 g_dw8048440 = 0x00; // 08048440
word32 g_dw8048456 = 0x00; // 08048456
byte g_b8048457 = 0x00; // 08048457
Eq_18 g_t804845B = // 0804845B
	{
		'\0'
	};
byte g_b804946C = 0x00; // 0804946C
byte g_b804946D = 0x00; // 0804946D
Eq_488 g_t80514AC = // 080514AC
	{
	};
Eq_23 g_t80534AC = // 080534AC
	{
		0x00,
		
		{
		},
		
		{
			0x00
		},
		
		{
			0x00
		},
	};
