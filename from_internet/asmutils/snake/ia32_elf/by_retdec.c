//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef long double float80_t;

// ------------------- Function Prototypes --------------------

int32_t entry_point(void);
int32_t function_804804c(void);
int32_t function_8048083(void);
int32_t function_80480a5(void);
int32_t function_80480ba(void);
int32_t unknown_fb9f0a67(void);
int32_t unknown_ffd8ba05(void);

// --------------------- Global Variables ---------------------

int32_t g1 = -0x79bf423d; // 0x80480d9
int32_t g2 = 0x49484745; // 0x8048457
float32_t g3 = 0.5f; // 0x80485df
float32_t g4 = 3.25962901e-9f; // 0x80485e3
int32_t g5 = 0; // 0x8048604
int32_t g6 = 0; // 0x8048620
int32_t g7 = 0; // 0x8048628
int32_t g8 = 0; // 0x804862c
int32_t g9 = 0; // 0x8048640
char g10 = 0; // 0x8048644
char g11 = 0; // 0x8048648
char g12 = 0; // 0x804864c
int32_t g13 = 0; // 0x8048650
char g14 = 0; // 0x8048654
char g15 = 0; // 0x8048658
int32_t g16 = 0; // 0x804865c
int64_t g17 = 0; // 0x8048660
char * g18; // 0x8048668
char g19 = 0; // 0x8048669
char g20 = 0; // 0x804866a
char * g21; // 0x804866c
char * g22; // 0x8048dbc
int32_t g23 = 0; // 0x8049635
int32_t g24 = 0; // 0x8049a35
int32_t g25 = 0; // 0x804b775

// ------------------------ Functions -------------------------

// Address range: 0x804804c - 0x8048083
int32_t function_804804c(void) {
    // 0x804804c
    int32_t v1; // 0x804804c
    *(char *)v1 = 0;
    int32_t v2; // 0x804804c
    int32_t v3 = v2; // 0x8048052
    g25 |= 1;
    *(int32_t *)(v1 - 36) = 0;
    *(int32_t *)(v1 - 32) = 0;
    __asm_int(128);
    v2 = v3;
    __asm_int(128);
    *(char *)v3 = 113;
    return (int32_t)*(char *)&v2;
}

// Address range: 0x8048083 - 0x80480a5
int32_t function_8048083(void) {
    // 0x8048083
    int32_t v1; // 0x8048083
    uint16_t v2 = (int16_t)v1; // 0x8048085
    uint32_t v3 = (int32_t)(256 * (v2 % 78)); // 0x8048085
    int32_t v4 = v1 & -0x10000 | (int32_t)(v2 / 78 % 256) | v3; // 0x8048085
    int32_t v5 = v4 + 1; // 0x8048088
    unsigned char v6 = (char)v5; // 0x8048089
    int32_t v7 = llvm_bswap_i32(v5 & -0x10000 | (int32_t)(v6 % 10) | 256 * (int32_t)(v6 / 10)); // 0x804808b
    *(int32_t *)v1 = v7 + 0x30305b1b;
    int32_t v8 = (v4 & -0x8100 | v3 / 256) + 1; // 0x8048096
    unsigned char v9 = (char)v8; // 0x8048097
    int32_t result = llvm_bswap_i32(v8 & -0x10000 | (int32_t)(v9 % 10) | 256 * (int32_t)(v9 / 10)) / 256 + 0x4830303b; // 0x804809e
    bool v10; // 0x8048083
    *(int32_t *)((v10 ? -4 : 4) + v1) = result;
    return result;
}

// Address range: 0x80480a5 - 0x80480ba
int32_t function_80480a5(void) {
    // 0x80480a5
    int32_t v1; // 0x80480a5
    *(char *)(v1 + 44 + v1) = (char)v1;
    function_8048083();
    unsigned char v2 = *(char *)(v1 % 256 + (int32_t)" xqmxxltqjqvkuwn"); // 0x80480b7
    *(char *)v1 = v2;
    return v1 & -256 | (int32_t)v2;
}

// Address range: 0x80480ba - 0x80480da
int32_t function_80480ba(void) {
    // 0x80480ba
    int32_t v1; // 0x80480ba
    *(int32_t *)v1 = 0x34325b1b;
    bool v2; // 0x80480ba
    *(int32_t *)((v2 ? -4 : 4) + v1) = 0xf48303b;
    __asm_int(128);
    return 4;
}

// Address range: 0x80480da - 0x80485df
int32_t entry_point(void) {
    // 0x80480da
    __asm_int(128);
    int32_t v1 = g5; // 0x80480ee
    g5 = v1 & -11;
    __asm_int(128);
    g5 = v1;
    g8 = &g1;
    __asm_int(128);
    g6 = 0x30d40;
    g7 = 0x30d40;
    __asm_int(128);
    *(char *)&g21 = 6;
    bool v2; // 0x80480da
    char * v3 = v2 ? (char *)((int32_t)&g21 - 1) : (char *)((int32_t)&g21 + 1); // 0x804813b
    __asm_rep_stosb_memset(v3, 10, 76);
    char * v4 = v2 ? (char *)((int32_t)&g21 - 77) : (char *)((int32_t)&g21 + 77); // 0x804813f
    *v4 = 12;
    char * v5 = v2 ? (char *)((int32_t)&g21 - 78) : (char *)((int32_t)&g21 + 78); // 0x8048144
    *v5 = 5;
    char * v6 = v2 ? (char *)((int32_t)&g21 - 3) : (char *)((int32_t)&g21 + 155); // 0x8048148
    *v6 = 5;
    char * v7 = v2 ? (char *)((int32_t)&g21 - 4) : (char *)((int32_t)&g21 + 156); // 0x804814d
    __asm_rep_movsb_memcpy(v7, v5, 1638);
    int32_t v8 = v2 ? (int32_t)&g21 - 1642 : (int32_t)&g21 + 1794; // 0x804814d
    *(char *)v8 = 3;
    char * v9 = v2 ? (char *)((int32_t)&g21 - 1643) : (char *)((int32_t)&g21 + 1795); // 0x8048156
    __asm_rep_stosb_memset(v9, 10, 76);
    char * v10 = v2 ? (char *)((int32_t)&g21 - 1719) : (char *)((int32_t)&g21 + 1871); // 0x8048158
    *v10 = 9;
    g23 = 975;
    *(char *)((int32_t)&g9 + 1019) = 10;
    g13 = 975;
    int32_t v11; // 0x80480da
    int32_t v12 = &v11; // 0x8048177
    __asm_int(128);
    g10 = llvm_ctpop_i8((char)g17 + 78) % 2 == 0 ? 8 : 2;
    g19 = 12;
    int32_t v13 = v2 ? -4 : 4;
    int32_t v14 = v12 - 4;
    int32_t * v15 = (int32_t *)v14;
    int32_t v16 = v2 ? -1 : 1;
    char v17 = 12; // 0x8048185
    int32_t v18 = v8; // 0x8048185
    int32_t v19 = (int32_t)&g22; // 0x8048185
    char v20; // 0x80480da
    int32_t v21; // 0x80480da
    int32_t v22; // 0x80480da
    int32_t v23; // 0x80480da
    int32_t v24; // 0x80480da
    int32_t v25; // 0x80480da
    int32_t v26; // 0x80480da
    int32_t v27; // 0x80480da
    int32_t v28; // 0x80480da
    int32_t v29; // 0x8048293
    while (true) {
      lab_0x8048189_2:;
        int32_t v30 = v19;
        unsigned char v31 = v17; // 0x804818c
        int32_t v32; // 0x80480da
        if (v31 == 0) {
            int32_t v33 = function_804804c(); // 0x80481a4
            v32 = v33;
            if ((char)v33 == 27) {
                int32_t v34 = function_804804c(); // 0x80481ae
                char v35 = v34; // 0x80481b3
                v32 = v34;
                if (v35 != 91 != v35 != 79) {
                    int32_t v36 = function_804804c(); // 0x80481bc
                    char v37 = v36; // 0x80481c1
                    v32 = v36;
                    if (v37 != 67 != v37 != 68) {
                        int32_t v38 = (v36 + 42) % 256; // 0x80481c9
                        g18 = (char *)v38;
                        v32 = v38;
                    }
                }
            }
        } else {
            char v39 = g20; // 0x8048195
            if (v39 != 0) {
                // 0x804819a
                g20 = 0;
            }
            // 0x804819d
            g19 = v39;
            *(char *)&g18 = v31;
            v32 = v31;
        }
        char v40 = v32; // 0x80481d1
        v28 = v18;
        v21 = v30;
        if (v40 == 113) {
            // break -> 0x804843d
            break;
        }
        if (v40 != 12) {
            int32_t v41 = g16; // 0x8048213
            int32_t v42 = v41 - 1; // 0x8048213
            g16 = v42;
            if (v42 < 0) {
                // 0x8048218
                g16 = v41;
                function_80480a5();
                g15++;
            }
            int32_t v43 = *(int32_t *)(4 * (int32_t)g14 + (int32_t)&g23); // 0x804822c
            uint32_t v44 = (int32_t)g10; // 0x8048233
            int32_t v45 = (v44 % 2 == 0 ? v43 : v43 - 78) + (int32_t)((v44 & 2) != 0); // 0x804823f
            int32_t v46 = ((v44 & 4) == 0 ? v45 : v45 + 78) - (int32_t)((v44 & 8) != 0); // 0x804824b
            int32_t v47 = g13 - v46; // 0x8048251
            if ((v47 >= 0 ? v47 : -v47) < 2) {
                int32_t v48 = g11; // 0x804828a
                g16 = 2 * (g16 + v48);
                v29 = g9 + v48;
                g9 = v29;
                v25 = v46;
                v22 = v30;
                goto lab_0x8048296;
            } else {
                char v49 = g12 - 1; // 0x804825a
                g12 = v49;
                v27 = v46;
                v24 = v30;
                if (v49 != 0) {
                    goto lab_0x8048374;
                } else {
                    char v50 = g11 - 1; // 0x804825f
                    g11 = v50;
                    v20 = 0;
                    v26 = v46;
                    v23 = v30;
                    if (v50 == 0) {
                        goto lab_0x80482bb;
                    } else {
                        // 0x8048264
                        g12 = 42;
                        function_8048083();
                        *(int32_t *)v30 = 0x6d375b1b;
                        int32_t v51 = v30 + v13; // 0x8048275
                        *(int32_t *)v51 = (int32_t)(g11 + 48) | 0x5b1b2000;
                        int32_t v52 = v51 + v13; // 0x804827e
                        *(int32_t *)v52 = 0xf6d3732;
                        v27 = v46;
                        v24 = v52 + v13;
                        goto lab_0x8048374;
                    }
                }
            }
        } else {
            // 0x80481dd
            *(int32_t *)v30 = 0x1b485b1b;
            int32_t v53 = v30 + v13; // 0x80481e2
            *(int32_t *)v53 = 0xe0e4a5b;
            *v15 = 24;
            int32_t v54 = 0x4e18; // 0x80481f4
            int32_t v55 = (int32_t)&g21; // 0x80481f4
            int32_t v56 = v53 + v13; // 0x80481f4
            unsigned char v57 = *(char *)v55; // 0x80481f6
            int32_t v58 = v55 + v16; // 0x80481f6
            char v59 = *(char *)((int32_t)v57 + (int32_t)" xqmxxltqjqvkuwn"); // 0x80481f7
            *(char *)v56 = v59;
            int32_t v60 = v56 + v16; // 0x80481f8
            unsigned char v61 = (char)(v54 / 256) - 1; // 0x80481f9
            int32_t v62 = 256 * (int32_t)v61 | v54 & -0xff01; // 0x80481f9
            v54 = v62;
            v55 = v58;
            v56 = v60;
            while (v61 != 0) {
                // 0x80481f6
                v57 = *(char *)v55;
                v58 = v55 + v16;
                v59 = *(char *)((int32_t)v57 + (int32_t)" xqmxxltqjqvkuwn");
                *(char *)v56 = v59;
                v60 = v56 + v16;
                v61 = (char)(v54 / 256) - 1;
                v62 = 256 * (int32_t)v61 | v54 & -0xff01;
                v54 = v62;
                v55 = v58;
                v56 = v60;
            }
            int32_t v63 = v62 - 1; // 0x80481fd
            char * v64 = (char *)v60;
            while (v63 != 0) {
                // 0x8048200
                *v64 = 10;
                v54 = v63 & -0xff01 | 0x4e00;
                v56 = v60 + v16;
                v57 = *(char *)v58;
                v58 += v16;
                v59 = *(char *)((int32_t)v57 + (int32_t)" xqmxxltqjqvkuwn");
                *(char *)v56 = v59;
                v60 = v56 + v16;
                v61 = (char)(v54 / 256) - 1;
                v62 = 256 * (int32_t)v61 | v54 & -0xff01;
                v54 = v62;
                v55 = v58;
                v56 = v60;
                while (v61 != 0) {
                    // 0x80481f6
                    v57 = *(char *)v55;
                    v58 = v55 + v16;
                    v59 = *(char *)((int32_t)v57 + (int32_t)" xqmxxltqjqvkuwn");
                    *(char *)v56 = v59;
                    v60 = v56 + v16;
                    v61 = (char)(v54 / 256) - 1;
                    v62 = 256 * (int32_t)v61 | v54 & -0xff01;
                    v54 = v62;
                    v55 = v58;
                    v56 = v60;
                }
                // 0x80481fd
                v63 = v62 - 1;
                v64 = (char *)v60;
            }
            // 0x8048205
            *v64 = 15;
            v29 = g9;
            v25 = v58;
            v22 = v60 + v16;
            goto lab_0x8048296;
        }
    }
    goto lab_0x804843d;
  lab_0x8048414:;
    // 0x8048414
    int32_t v96; // 0x80480da
    *(int32_t *)v96 = 0x315b1b0f;
    bool v93; // 0x80480da
    int32_t v111 = v93 ? -4 : 4; // 0x8048424
    int32_t v112 = v96 + v111; // 0x8048424
    int32_t v95; // 0x80480da
    int32_t v113 = *(int32_t *)v95; // 0x8048425
    int32_t v110 = v111 - 1; // 0x8048425
    int32_t v114 = v110 + v95; // 0x8048426
    v28 = v114;
    v21 = v112;
    int32_t v108; // 0x80480da
    int32_t v101; // 0x80480da
    int32_t v103; // 0x80480da
    if ((char)v113 == 0) {
        goto lab_0x804843d;
    } else {
        // 0x804842b
        v108 = v114;
        v101 = v113;
        v103 = v112;
        goto lab_0x804842b_2;
    }
  lab_0x8048296:;
    int32_t v115 = 0x373b3a5b;
    uint16_t v116 = (int16_t)v29; // 0x80482a0
    uint16_t v117 = 256 * (v116 % 10);
    *v15 = v29 & -0x10000 | (int32_t)(v116 / 10 % 256) | (int32_t)v117;
    *(char *)v22 = 27;
    int32_t v118 = v22 + v16; // 0x80482a5
    int32_t v119 = v115 + 0xff00 & 0xff00 | v115 & -0xff01; // 0x80482a7
    *(int32_t *)v118 = v119;
    int32_t v120 = v118 + v13; // 0x80482a9
    *(char *)v120 = 57;
    int32_t v121 = v120 + v16; // 0x80482ad
    *(int16_t *)v121 = (v117 | 57) + 0x300f;
    int32_t v122 = v121 + (v2 ? -2 : 2); // 0x80482b2
    int32_t v123 = *v15 & -0xff01; // 0x80482b5
    int32_t v124 = v123; // 0x80482b9
    int32_t v125 = v122; // 0x80482b9
    while (v123 != 0) {
        // 0x80482a0
        v115 = v119;
        v116 = (int16_t)v124;
        v117 = 256 * (v116 % 10);
        *v15 = v124 & -0x10000 | (int32_t)(v116 / 10 % 256) | (int32_t)v117;
        *(char *)v125 = 27;
        v118 = v125 + v16;
        v119 = v115 + 0xff00 & 0xff00 | v115 & -0xff01;
        *(int32_t *)v118 = v119;
        v120 = v118 + v13;
        *(char *)v120 = 57;
        v121 = v120 + v16;
        *(int16_t *)v121 = (v117 | 57) + 0x300f;
        v122 = v121 + (v2 ? -2 : 2);
        v123 = *v15 & -0xff01;
        v124 = v123;
        v125 = v122;
    }
    // 0x80482bb
    v20 = g11;
    v26 = v25;
    v23 = v122;
    goto lab_0x80482bb;
  lab_0x8048374:
    // 0x8048374
    *(char *)v24 = 14;
    int32_t v97 = v24 + v16; // 0x8048376
    unsigned char v150 = g10; // 0x8048377
    uint32_t v151 = 256 * (int32_t)((16 * v150 | v150) / 4) & 3840; // 0x8048384
    char v152 = *(char *)(v27 + (int32_t)&g9 + 44); // 0x8048387
    int32_t v94; // 0x80483e9
    if (v152 != 0) {
        char v153 = v152 & (char)(v151 / 256); // 0x80483db
        unsigned char v154 = llvm_ctpop_i8(v153); // 0x80483db
        *v15 = 0x4000 * (int32_t)(bool)v2 | 1024 * (int32_t)v2 | 512 * (int32_t)v2 | 256 * (int32_t)v2 | 64 * (int32_t)(v153 == 0) | 4 * (int32_t)(v154 % 2 == 0) | 2;
        function_80480a5();
        v94 = *v15;
        if ((v94 & 64) == 0) {
            char v155 = g15; // 0x80483ee
            int32_t v156 = *(int32_t *)(4 * (int32_t)v155 + (int32_t)&g23); // 0x80483f1
            v93 = (v94 & 1024) != 0;
            v95 = (int32_t)&g2 + 135;
            v96 = v97;
            int32_t v157; // 0x80480da
            if (v157 == v156) {
                goto lab_0x8048414;
            } else {
                goto lab_0x80483fa;
            }
        } else {
            goto lab_0x80483fa;
        }
    }
    int32_t v158 = v150; // 0x8048377
    char v159 = g14 + 1; // 0x804838f
    g14 = v159;
    *(int32_t *)(4 * (int32_t)v159 + (int32_t)&g23) = v27;
    uint32_t v149 = 16 * v158 & 240 | v158; // 0x8048384
    int32_t v160 = v149 | v151; // 0x80483a1
    char v161 = *(char *)&g18; // 0x80483a3
    int32_t v162 = v160; // 0x80480da
    int32_t v148; // 0x80480da
    switch (v161) {
        case 52: {
            // 0x80483bb
            v148 = v162 / 2 % 128;
            goto lab_0x80483bd;
        }
        case 54: {
            goto lab_0x80483b8;
        }
        default: {
            char v163 = v161 | 32;
            v162 = v160;
            if (v163 == 110) {
                // 0x80483bb
                v148 = v162 / 2 % 128;
                goto lab_0x80483bd;
            } else {
                // 0x80483b4
                v148 = v160;
                if (v163 != 109) {
                    goto lab_0x80483bd;
                } else {
                    goto lab_0x80483b8;
                }
            }
        }
    }
  lab_0x80482bb:;
    int32_t v126 = v23;
    int32_t v127 = v26;
    int32_t v128 = v20; // 0x80482c5
    int32_t v129 = v126; // 0x80482c5
    if (*(char *)&g18 != 12) {
        // 0x80482cb
        function_8048083();
        *(char *)v126 = 32;
        int32_t v130 = v126 + v16; // 0x80482d3
        *(char *)v130 = 32;
        int32_t v131 = v130 + v16; // 0x80482d4
        *(char *)v131 = 32;
        char * v132 = (char *)(v127 + (int32_t)&g9 + 44); // 0x80482d6
        *v132 = *v132 ^ 32;
        int32_t v133 = 1794; // 0x80482dc
        int32_t v134 = 0; // 0x80482dc
        *(int32_t *)(4 * v134 + (int32_t)&g24) = v133;
        uint32_t v135 = *(int32_t *)(v133 + (int32_t)&g9 + 42); // 0x80482e8
        int32_t v136 = v134 + (int32_t)(v135 < 256); // 0x80482f0
        int32_t v137 = v133 - 1; // 0x80482f3
        v133 = v137;
        v134 = v136;
        while (v137 != 0) {
            // 0x80482e1
            *(int32_t *)(4 * v134 + (int32_t)&g24) = v133;
            v135 = *(int32_t *)(v133 + (int32_t)&g9 + 42);
            v136 = v134 + (int32_t)(v135 < 256);
            v137 = v133 - 1;
            v133 = v137;
            v134 = v136;
        }
        int32_t v138 = v131 + v16; // 0x80482d5
        *v132 = *v132 ^ 32;
        v95 = (int32_t)&g2 + 101;
        v96 = v138;
        if (v136 == 0) {
            goto lab_0x8048414;
        }
        // 0x8048304
        *v15 = v136;
        uint32_t v139 = (-0x7c736326 * (int32_t)g17 + 0x6072) / 2; // 0x804831f
        g17 = v139;
        int32_t v140 = (float80_t)v136 * (float80_t)g4 * (float80_t)v139 - (float80_t)g3; // 0x804832d
        *v15 = v140;
        uint64_t v141 = 0x100000000 * (int64_t)(v140 >> 31) | (int64_t)v140; // 0x8048334
        uint64_t v142 = (int64_t)(v137 & -256 | 7); // 0x8048334
        int32_t v143 = *(int32_t *)(4 * (int32_t)(v141 / v142) + (int32_t)&g24); // 0x8048336
        g13 = v143;
        int32_t v144 = (int32_t)(v141 % v142) + 3; // 0x8048340
        g11 = v144;
        g12 = 42;
        v128 = v144;
        v129 = v138;
    }
    // 0x804834a
    function_8048083();
    *(int32_t *)v129 = 0x6d375b1b;
    int32_t v145 = v129 + v13; // 0x8048355
    *(int32_t *)v145 = 256 * v128 + 0x3000 & 0xff00 | 0x1b200020;
    int32_t v146 = v145 + v13; // 0x804835d
    *(int32_t *)v146 = 0x6d37325b;
    int32_t v147 = v146 + v13; // 0x8048363
    v27 = v127;
    v24 = v147;
    if (*(char *)&g18 != 12) {
        goto lab_0x8048374;
    } else {
        // 0x804836a
        function_80480ba();
        v18 = v127;
        v19 = v147;
        goto lab_0x8048189;
    }
  lab_0x80483b8:
    // 0x80483bb
    v148 = v149 / 4 / 2 % 128;
    goto lab_0x80483bd;
  lab_0x80483bd:
    // 0x80483bd
    g10 = (char)v148 % 16;
    function_80480a5();
    function_80480ba();
    *v15 = 29;
    __asm_int(128);
    v18 = v27;
    v19 = v97;
    goto lab_0x8048189;
  lab_0x8048189:
    // 0x8048189
    v17 = g19;
    goto lab_0x8048189_2;
  lab_0x804843d:;
    uint32_t v65 = v21;
    function_80480ba();
    *v15 = 54;
    __asm_int(128);
    *v15 = 1;
    __asm_int(128);
    *v15 = 54;
    *(int32_t *)(v12 - 8) = v14;
    int32_t * v66 = (int32_t *)(v12 - 12); // 0x8048460
    *v66 = (int32_t)&g9 + 1;
    *(int32_t *)(v12 - 16) = v65;
    *(char *)0x5422 = *(char *)0x5422 & (char)(v65 / 256);
    int32_t v67 = __asm_bound(*(int64_t *)(*v66 + 100)); // 0x8048467
    unsigned char v68 = (char)v65; // 0x804846a
    bool v69; // 0x80480da
    int32_t v70; // 0x80480da
    if ((v68 & 14) > 9) {
        v69 = true;
        v70 = ((v68 > 153 ? 102 : 6) + v65) % 256 | v65 & -256;
    } else {
        v69 = false;
        v70 = (v68 > 153 ? v65 + 96 : v65) % 256 | v65 & -256;
    }
    int32_t v71 = v28 - 1; // 0x804845c
    int32_t v72 = v70;
    int32_t * v73 = (int32_t *)(v67 - 4); // 0x804846d
    *v73 = 0x2c6c6b69;
    int32_t v74 = __asm_insd((int16_t)((int32_t)&g9 - 73)); // 0x8048473
    *(int32_t *)v65 = v74;
    char v75 = *(char *)v71; // 0x8048474
    __asm_outsb((int16_t)((int32_t)&g9 - 73), v75);
    unsigned char v76 = (char)v72; // 0x8048475
    bool v77 = v68 > 153 | v76 > 153;
    int32_t v78; // 0x80480da
    if (v69 || (v76 & 14) > 9) {
        v78 = ((v77 ? 154 : 250) + v72) % 256 | v72 & -256;
    } else {
        uint32_t v79 = v77 ? v72 + 160 : v72; // 0x8048475
        v78 = v79 % 256 | v72 & -256;
    }
    int32_t v80 = *(int32_t *)v71; // 0x8048476
    __asm_outsd((int16_t)((int32_t)&g9 - 73), v80);
    char * v81 = (char *)(v78 + 49); // 0x8048477
    *v81 = *v81 ^ (char)((int32_t)&g9 - 73 >> 8);
    char * v82 = (char *)(v78 + 0x72310ac9); // 0x80484b1
    *v82 = *v82 + (char)((int32_t)&g9 - 73 >> 8);
    int32_t v83 = *(int32_t *)((int32_t)&g9 - 73); // 0x80484bd
    *(int32_t *)((int32_t)&g9 - 73) = v83 - 0x5401;
    int32_t v84 = unknown_ffd8ba05(); // 0x80484ca
    uint32_t v85 = *v73; // 0x80484d1
    int32_t v86 = v67 + 4; // 0x80484d4
    int32_t v87 = 256 * (int32_t)*(char *)((int32_t)&g9 + 5); // 0x80484d8
    *(char *)(v87 | (int32_t)&g9 - 73 & -0xff01) = (char)(v85 / 256);
    if ((v86 & 0xae8b000) == 0) {
        uint32_t v88 = __asm_int3(); // 0x8048553
        *(char *)(*(int32_t *)v67 + v86) = (char)(v88 / 256);
        int32_t v89 = v87 | (int32_t)&g9 - 73 & -0x10000 | 66; // 0x8048557
        int32_t * v90 = (int32_t *)(v67 + 3); // 0x804855e
        __asm_out(52, v88);
        __asm_in((int16_t)v89);
        __asm_sti();
        int32_t v91 = v28 - 2; // 0x8048579
        *v90 = 0x342b22c2;
        __asm_int(208);
        *(int32_t *)v91 = v91;
        int32_t result = unknown_fb9f0a67(); // 0x804858b
        __asm_out(100, result);
        *v73 = v89;
        *(int32_t *)(v67 - 8) = *v90 - 1;
        return result;
    }
    uint32_t v92 = (v84 & 14) > 9 ? v84 + 6 : v84; // 0x80484e5
    return v92 % 16 | v84 & -0x10000 | 256 * (int32_t)((v84 & 14) > 9) + v84 & 0xff00;
  lab_0x80483fa:
    // 0x80483fa
    v93 = (v94 & 1024) != 0;
    v95 = (int32_t)&g2 + 51;
    v96 = v97;
    switch (g9) {
        case 0: {
            goto lab_0x8048414;
        }
        case 100: {
            // 0x8048414
            v93 = (v94 & 1024) != 0;
            v95 = (int32_t)&g2 + 209;
            v96 = v97;
            goto lab_0x8048414;
        }
        default: {
            int32_t v98 = g16 < 16 ? (int32_t)&g2 + 91 : (int32_t)&g2 + 172;
            v93 = (v94 & 1024) != 0;
            v95 = v98;
            v96 = v97;
            goto lab_0x8048414;
        }
    }
  lab_0x804842b_2:;
    char v99 = 4; // 0x804842d
    int32_t v100 = v101; // 0x804842d
    int32_t v102 = v103; // 0x804842d
    goto lab_0x804842e;
  lab_0x804842e:;
    char v104 = *(char *)(v100 % 64 + (int32_t)&g2); // 0x8048432
    *(char *)v102 = v104;
    int32_t v105 = v102 + (v93 ? -1 : 1); // 0x8048433
    char v106 = v99 - 1; // 0x8048437
    v99 = v106;
    v100 /= 64;
    v102 = v105;
    if (v106 != 0) {
        goto lab_0x804842e;
    } else {
        int32_t v107 = *(int32_t *)v108; // 0x8048425
        int32_t v109 = v108 + v110; // 0x8048426
        v108 = v109;
        v101 = v107;
        v103 = v105;
        v28 = v109;
        v21 = v105;
        if ((char)v107 == 0) {
            goto lab_0x804843d;
        } else {
            goto lab_0x804842b_2;
        }
    }
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.7.2)
// Detected functions: 5

