// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_26 g_t804804C = // 0804804C
	{
		0x00,
		0x61,
	};
// 08048097: void fn08048097(Register uip32 edx, Register word32 ebp, Register word32 edi, Stack (ptr32 Eq_5) dwArg00, Stack (ptr32 Eq_5) dwArg04)
void fn08048097(uip32 edx, word32 ebp, word32 edi, struct Eq_5 * dwArg00, struct Eq_5 * dwArg04)
{
	struct Eq_5 * esi_11 = dwArg04;
	do
	{
		esi_11 = esi_344 + 1;
		esi_344 = esi_11;
	} while (esi_344->b0000 != 0x00);
	struct Eq_5 * dwArg00_312;
	g_ptr80483BF = &g_t8048165;
	uip32 edx_340 = edx;
	dwArg00_312 = dwArg00;
	if (esi_11->wFFFFFFFD != 0x6D6E)
	{
		g_ptr80483BF = &g_t8048274;
		__syscall(0x80);
		dwArg04 = dwArg00;
		dwArg00_312 = (struct Eq_5 *) 0x04;
		edx_340 = 0x32;
	}
	struct Eq_26 * ebx_122;
	word32 edi_110;
	word32 ebp_109;
	g_t80483AF = dwArg00 - 0x01;
	struct Eq_33 * esp_116 = fp + 8;
	uip32 edx_107 = edx_340;
	if (dwArg00 == (struct Eq_5 *) 0x01)
	{
		ebx_122 = &g_t804804C;
l080480E0:
		g_ptr80483B3 = ebx_122;
		int32 * esp_45 = esp_116 - 4;
		*esp_45 = 0x05;
		int32 eax_47 = *esp_45;
		__syscall(0x80);
		if (eax_47 >= 0x00)
		{
			g_dw80483B7 = eax_47;
			*esp_45 = 0x02;
			*esp_45 = 0x13;
			__syscall(0x80);
			*esp_45 = 0x02;
			*esp_45 = 0x01;
			__syscall(0x80);
			g_ptr80483BB = (struct Eq_112 *) 0xC0;
			struct Eq_33 * esp_103;
			g_ptr80483BF();
			esp_103->dwFFFFFFFC = 0x06;
			__syscall(0x80);
			word24 edx_24_8_139 = SLICE(edx_107, word24, 8);
			byte dl_290 = (byte) edx_107;
			esp_116 = esp_103;
			ebp = ebp_109;
			edi = edi_110;
		}
		else
		{
			*esp_45 = 0x01;
			*esp_45 = 0x04;
			__syscall(0x80);
			fn0804822F(0x00);
			++g_dw80483C3;
			esp_116 = (struct Eq_33 *) (esp_45 + 1);
			edx_107 = 0x00;
		}
	}
	struct Eq_26 * ebx_120 = esp_116->dw0000;
	word24 edx_24_8_134 = SLICE(edx_107, word24, 8);
	++esp_116;
	ebx_122 = ebx_120;
	if (ebx_120 == null)
	{
		esp_116->dwFFFFFFFC = 0x01;
		struct Eq_149 * eax_129 = esp_116->dwFFFFFFFC;
		__syscall(0x80);
		uip32 edx_141 = edx_107;
		if (g_t80483AF >= 0x02)
		{
			fn08048260();
			edx_141 = SEQ(edx_24_8_134, 0x3A);
			fn0804822F(0x3A);
		}
		struct Eq_149 * esi_147 = eax_129;
		word32 ecx_149 = (word32) eax_129->w0030;
		struct Eq_167 * eax_151 = eax_129 + eax_129->dw0020 / 50 - 0x28;
		while (true)
		{
			++eax_151;
			--ecx_149;
			if (ecx_149 == 0x00)
				break;
			if (eax_151->b0004 == 0x02)
			{
				esp_116->dwFFFFFFFC = eax_151;
				esp_116->dwFFFFFFF8 = ecx_149;
				g_ptr80483C7 = eax_151;
				uint32 ecx_172 = (eax_151->dw0014 >> 0x04) + 0x01;
				struct Eq_208 * ebx_174 = g_ptr80483BB + eax_151->dw0010 / 36 - 0x10;
				while (true)
				{
					--ecx_172;
					if (ecx_172 == 0x00)
						break;
					++ebx_174;
					if (ebx_174->dw0000 != 0x00)
					{
						esp_116->dwFFFFFFF4 = eax_151;
						esp_116->dwFFFFFFF0 = ecx_172;
						esp_116->dwFFFFFFEC = edx_141;
						esp_116->dwFFFFFFE8 = ebx_174;
						esp_116->dwFFFFFFE4 = esp_116 - 8;
						esp_116->dwFFFFFFE0 = ebp;
						esp_116->dwFFFFFFDC = esi_147;
						esp_116->dwFFFFFFD8 = edi;
						struct Eq_112 * eax_214 = g_ptr80483BB;
						word32 esi_221 = Mem211[eax_214 + Mem211[eax_214 + 0x20:word32] + Mem211[eax_151 + 0x18:word32] *s 0x28 + 0x10:word32] + Mem211[0x080483BB<p32>:word32] + Mem211[ebx_174 + 0x00:word32];
						word32 edi_226;
						byte * edi_236 = edi_226 + (fn08048211(ebx_174->dw0004, 0x080483DB, out edi_226) + 0x08) + 0x01;
						byte al_238 = 0x20;
						do
						{
							*edi_236 = al_238;
							byte al_244 = *esi_221;
							++edi_236;
							++esi_221;
							al_238 = al_244;
						} while (al_244 != 0x00);
						*edi_236 = 0x0A;
						esp_116->dwFFFFFFD4 = 0x01;
						esp_116->dwFFFFFFD4 = 0x04;
						__syscall(0x80);
						edi = esp_116->dwFFFFFFD8;
						esi_147 = esp_116->dwFFFFFFDC;
						ebp = esp_116->dwFFFFFFE0;
						ebx_174 = esp_116->dwFFFFFFE8;
						edx_141 = esp_116->dwFFFFFFEC;
						ecx_172 = esp_116->dwFFFFFFF0;
						eax_151 = esp_116->dwFFFFFFF4;
					}
				}
				ecx_149 = esp_116->dwFFFFFFF8;
				eax_151 = esp_116->dwFFFFFFFC;
			}
		}
		return;
	}
	goto l080480E0;
}

<anonymous> g_t8048165 = <code>; // 08048165
// 08048211: Register word32 fn08048211(Register uint32 ecx, Register word32 edi, Register out (ptr32 byte) ediOut)
// Called from:
//      fn08048097
word32 fn08048211(uint32 ecx, word32 edi, byte & ediOut)
{
	byte * edi_18 = edi + 0x07;
	word32 edx_27;
	uint32 ecx_41 = ecx;
	for (edx_27 = 0x08; edx_27 != 0x00; --edx_27)
	{
		byte cl_8 = (byte) ecx_41;
		byte al_11 = (cl_8 & 0x0F) + 0x30;
		if ((cl_8 & 0x0F) > 0x09)
			al_11 = (cl_8 & 0x0F) + 0x57;
		*edi_18 = al_11;
		++edi_18;
		ecx_41 >>= 0x04;
	}
	ediOut = edi_18;
	return edx_27;
}

// 0804822F: void fn0804822F(Register byte dl)
// Called from:
//      fn08048097
void fn0804822F(byte dl)
{
	byte dl_46 = (byte) edx;
	struct Eq_26 * edi_130 = g_ptr80483B3;
	word32 ecx_32 = ~0x00;
	while (ecx_32 != 0x00)
	{
		++edi_130;
		--ecx_32;
		if (edi_130->b0000 != 0x00)
			break;
	}
	if (dl_46 != 0x00)
		edi_130->bFFFFFFFF = dl_46;
	__syscall(0x80);
	edi_130->bFFFFFFFF = 0x00;
	fn08048260();
}

// 08048260: void fn08048260()
// Called from:
//      fn08048097
//      fn0804822F
void fn08048260()
{
	__syscall(0x80);
}

<anonymous> g_t8048274 = <code>; // 08048274
Eq_30 g_t80483AF = // 080483AF
	{
		0x00
	};
struct Eq_26 * g_ptr80483B3 = null; // 080483B3
int32 g_dw80483B7 = 0; // 080483B7
struct Eq_112 * g_ptr80483BB = null; // 080483BB
<anonymous> * g_ptr80483BF = null; // 080483BF
word32 g_dw80483C3 = 0x00; // 080483C3
struct Eq_167 * g_ptr80483C7 = null; // 080483C7
