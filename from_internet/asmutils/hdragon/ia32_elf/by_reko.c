// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: Register word32 fn0804804C(Register byte al, Register word32 edx, Register (ptr32 Eq_4) esi, Register Eq_5 edi)
// Called from:
//      fn0804804C
//      fn08048098
word32 fn0804804C(byte al, word32 edx, struct Eq_4 * esi, Eq_5 edi)
{
	word32 eax;
	if (edx != 0x00)
	{
		word32 edx_78 = fn0804804C(0x01, edx - 0x01, esi, edi);
		esi->dw0000 = (ui32) ((byte) (byte) eax + esi->dw0000);
		esi->dw0000 &= 0x03;
		fn0804804C(~0x00, edx_78, esi, edi);
	}
	else
	{
		ui32 eax_35 = esi->dw0000;
		byte al_37 = (byte) eax_35;
		word16 eax_16_16_51 = SLICE(eax_35, word16, 16);
		if (al_37 != 0x00)
		{
			if (al_37 != 0x02)
			{
				if (al_37 != 0x01)
					eax_35 = ~0x00;
			}
			else
				eax_35 = SEQ(eax_16_16_51, 0x0280);
		}
		else
			eax_35 = ~0x027F;
		int32 eax_55 = eax_35 + esi->dw0004;
		*((word32) edi.u1 + eax_55) = 0x0E;
		esi->dw0004 = eax_55;
		uipr32 ecx_117;
		for (ecx_117 = 0xFFFF; ecx_117 != 0x00; --ecx_117)
			;
	}
	return <invalid>;
}

// 08048098: void fn08048098(Register Eq_70 edx)
void fn08048098(Eq_70 edx)
{
	Eq_71 tLoc0C;
	Eq_72 ebx_8 = 0x080480FB;
	Eq_72 eax_14 = sys_open("/dev/fb0", 0x02, edx);
	if (eax_14 >= 0x00)
	{
		tLoc0C.dw0004 = 0x01;
		tLoc0C.dw0004 = 0x02;
		byte * eax_34 = sys_mmap2();
		if (eax_34 >= null)
		{
			tLoc0C.ptr0004 = eax_34;
			byte * edi_100 = eax_34;
			word32 ecx_101;
			for (ecx_101 = 0x0004B000; ecx_101 != 0x00; --ecx_101)
			{
				*edi_100 = 0x00;
				++edi_100;
			}
			Eq_5 edi_51 = tLoc0C.t0004.u0;
			tLoc0C.dw0004 = 205120;
			tLoc0C.dw0000 = 0x00;
			fn0804804C(0x01, 0x10, &tLoc0C, edi_51);
			tLoc0C.dw0004 = 0x5B;
			sys_munmap(edi_51, 0x0004B000);
		}
		sys_close(eax_14);
		ebx_8 = eax_14;
	}
	sys_exit(ebx_8);
}

char g_str80480FB[] = "/dev/fb0"; // 080480FB
