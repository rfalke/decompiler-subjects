//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(uint32_t a1);
int32_t function_80480d7(void);
int32_t function_804816b(int32_t a1, int32_t a2);
int32_t function_804825f(void);
int32_t function_8048273(void);
int32_t function_804828e(void);
int32_t function_80482b5(void);
int32_t function_80482c1(void);
int32_t function_80482ce(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x67617355; // 0x804804c
int32_t g2 = 0; // 0x80482e6
char g3 = 0; // 0x80482ea

// ------------------------ Functions -------------------------

// Address range: 0x8048067 - 0x80480d7
int32_t entry_point(uint32_t a1) {
    // 0x8048067
    int32_t v1; // 0x8048067
    int32_t v2 = &v1; // 0x8048067
    int32_t v3 = a1; // 0x804806b
    int32_t v4 = v2; // 0x804806b
    int32_t v5; // 0x8048067
    if (a1 >= 3) {
        goto lab_0x8048084;
    } else {
        // 0x804806d
        __asm_int(128);
        v3 = &g1;
        v5 = v2;
        goto lab_0x804807d;
    }
  lab_0x8048084:;
    int32_t v6 = v4;
    int32_t v7 = v3;
    int32_t v8 = v6 + 4; // 0x8048084
    int32_t * v9 = (int32_t *)v8;
    int32_t * v10; // 0x8048067
    int32_t v11; // 0x8048067
    int32_t v12; // 0x8048067
    if (*(int16_t *)*v9 != 0x722d) {
        // 0x8048097
        v10 = v9;
        v11 = v7 - 1;
        v12 = v8;
    } else {
        int32_t v13 = v6 + 8; // 0x8048086
        g3++;
        v10 = (int32_t *)v13;
        v11 = v7 - 2;
        v12 = v13;
    }
    int32_t v14 = v11 - 1; // 0x8048098
    int32_t * v15 = (int32_t *)(4 * v14 + v12); // 0x804809b
    *v15 = 0;
    g2 = *v15;
    int32_t v16 = *v10; // 0x80480a3
    int32_t v17 = v12 + 4; // 0x80480a3
    v3 = v14;
    v5 = v17;
    int32_t v18 = v17; // 0x80480a6
    int32_t v19 = v16; // 0x80480a6
    int32_t * v20 = v10; // 0x80480a6
    if (v16 != 0) {
        function_804828e();
        *v20 = v19;
        function_80480d7();
        int32_t * v21 = (int32_t *)v18; // 0x80480a3
        int32_t v22 = *v21; // 0x80480a3
        int32_t v23 = v18 + 4; // 0x80480a3
        v3 = v14;
        v5 = v23;
        v18 = v23;
        v19 = v22;
        v20 = v21;
        while (v22 != 0) {
            // 0x80480c8
            function_804828e();
            *v20 = v19;
            function_80480d7();
            v21 = (int32_t *)v18;
            v22 = *v21;
            v23 = v18 + 4;
            v3 = v14;
            v5 = v23;
            v18 = v23;
            v19 = v22;
            v20 = v21;
        }
    }
    goto lab_0x804807d;
  lab_0x804807d:
    // 0x804807d
    v4 = v5;
    *(int32_t *)(v4 - 4) = 1;
    __asm_int(128);
    goto lab_0x8048084;
}

// Address range: 0x80480d7 - 0x804816b
int32_t function_80480d7(void) {
    // 0x80480d7
    __asm_int(128);
    function_804828e();
    int32_t v1; // bp-32, 0x80480d7
    int32_t v2 = &v1; // 0x8048113
    __asm_int(128);
    __asm_int(128);
    int32_t * v3 = (int32_t *)(v2 - 4); // 0x804813b
    *v3 = 3;
    __asm_int(128);
    *v3 = 4;
    __asm_int(128);
    *v3 = 6;
    __asm_int(128);
    *v3 = 6;
    __asm_int(128);
    return *(int32_t *)(v2 + 28);
}

// Address range: 0x804816b - 0x804825f
int32_t function_804816b(int32_t a1, int32_t a2) {
    // 0x804816b
    return function_804828e();
}

// Address range: 0x804825f - 0x8048273
int32_t function_804825f(void) {
    // 0x804825f
    function_80482c1();
    function_8048273();
    function_80482ce();
    int32_t result; // 0x804825f
    return result;
}

// Address range: 0x8048273 - 0x804828e
int32_t function_8048273(void) {
    int32_t v1 = function_80482b5(); // 0x8048277
    int32_t v2; // 0x8048273
    int32_t v3 = 2 * v2;
    if (*(char *)(v3 - 1) != 47) {
        // 0x8048286
        *(int16_t *)v3 = 47;
    }
    // 0x804828b
    return v1 & -0x10000 | 47;
}

// Address range: 0x804828e - 0x80482b5
int32_t function_804828e(void) {
    // 0x804828e
    __asm_int(128);
    int32_t result; // 0x804828e
    return result;
}

// Address range: 0x80482b5 - 0x80482c1
int32_t function_80482b5(void) {
    // 0x80482b5
    int32_t result; // 0x80482b5
    int32_t v1 = result - 1; // 0x80482b7
    while (*(char *)(v1 + 1) != 0) {
        // 0x80482b8
        v1++;
    }
    // 0x80482be
    return result;
}

// Address range: 0x80482c1 - 0x80482ce
int32_t function_80482c1(void) {
    // 0x80482c1
    function_80482b5();
    int32_t result; // 0x80482c1
    __asm_rep_movsb_memcpy((char *)result, (char *)result, result + 1);
    return result;
}

// Address range: 0x80482ce - 0x80482e6
int32_t function_80482ce(void) {
    // 0x80482ce
    int32_t result; // 0x80482ce
    int32_t v1 = result;
    function_80482b5();
    function_80482b5();
    __asm_rep_movsb_memcpy((char *)(v1 + result), (char *)result, v1 + 1);
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: free pascal (2.6.0)
// Detected functions: 9

