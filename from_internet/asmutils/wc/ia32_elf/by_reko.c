// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Register (ptr32 word32) ecx, Register (ptr32 word32) edi, Stack word32 dwArg00)
void fn0804804C(word32 * ecx, word32 * edi, word32 dwArg00)
{
	struct Eq_5 * esp_10;
	if (dwArg00 == 0x01)
		esp_10 = fp + 8;
	else
	{
		esp_10 = fp + 8;
l08048054:
		word32 * ebx_91 = esp_10->dw0000;
		++esp_10;
		if (ebx_91 != null)
		{
			word16 * esi_105 = g_a80481B4;
			edi = g_a80481BD;
			uint8 dl_111 = 0x04;
			ecx = (word32 *) 0x03;
			do
			{
				++esi_105;
				if (*ebx_91 == *esi_105)
				{
					g_b80481BA |= dl_111;
					goto l08048054;
				}
				*edi = 0x00;
				dl_111 >>= 0x01;
				++edi;
				--ecx;
			} while (ecx != null);
			if (*ebx_91 != 0x2D)
			{
				g_b80481CA = 0x01;
				esp_10->dwFFFFFFFC = 0x05;
				int32 eax_138 = esp_10->dwFFFFFFFC;
				__syscall(0x80);
				edi = ebx_91;
				ecx = null;
				if (eax_138 < 0x00)
					goto l0804816A;
l080480AB:
				while (true)
				{
					struct Eq_54 * esp_21 = esp_10 - 4;
					esp_21->ptr0000 = (word32 *) 0x03;
					word32 * eax_23 = esp_21->ptr0000;
					__syscall(0x80);
					ecx = (word32 *) g_a80481DB;
					if (eax_23 < null)
						break;
					if (eax_23 == null)
					{
						esp_21->ptr0000 = edi;
						byte bl_35 = g_b80481BA;
						uint8 dl_37 = 0x04;
						word32 * esi_38 = g_a80481BD;
						uip32 ecx_236 = 0x03;
						do
						{
							esp_21->dwFFFFFFFC = ecx_236;
							uint32 eax_44 = *esi_38;
							++esi_38;
							if (bl_35 == 0x00 || (bl_35 & dl_37) != 0x00)
							{
								fn08048194(eax_44, &g_b80481CB);
								fn08048172(&g_b80481CB);
								edi = (word32 *) &g_b80481CB;
							}
							uip32 ecx_73 = esp_21->dwFFFFFFFC;
							dl_37 >>= 0x01;
							ecx_236 = ecx_73 - 0x01;
						} while (ecx_73 != 0x01);
						word32 * ecx_76 = esp_21->ptr0000;
						esp_10 = (struct Eq_5 *) ((char *) &esp_21->ptr0000 + 4);
						if (g_b80481C9 != 0x01)
							fn08048172(ecx_76);
						fn08048172(&g_dw80481BB);
						ecx = &g_dw80481BB;
						goto l08048054;
					}
					byte * esi_164 = g_a80481DB;
					word32 * ecx_165 = eax_23;
					byte ah_184 = 0x00;
					do
					{
						byte al_172 = *esi_164;
						++g_dw80481C5;
						++esi_164;
						if (al_172 != 0x20 && (al_172 != 0x09 && al_172 != 0x0A))
							ah_184 = 0x01;
						else if (ah_184 != 0x00)
						{
							++g_dw80481C1;
							ah_184 = 0x00;
						}
						if (al_172 == 0x0A)
							++g_a80481BD[0];
						--ecx_165;
					} while (ecx_165 != null);
				}
l0804816D:
				__syscall(0x80);
				fn08048172(ecx);
				return;
			}
		}
		else
		{
			if (g_b80481CA != 0x00)
				goto l0804816D;
			g_b80481CA = 0x01;
		}
	}
	g_b80481C9 = 0x01;
	goto l080480AB;
}

// 08048172: void fn08048172(Register (ptr32 word32) ecx)
// Called from:
//      fn0804804C
void fn08048172(word32 * ecx)
{
	fn08048184(ecx);
	__syscall(0x80);
}

// 08048184: void fn08048184(Register (ptr32 word32) esi)
// Called from:
//      fn08048172
void fn08048184(word32 * esi)
{
	do
	{
		esi = (word32 *) ((char *) esi_34 + 1);
		esi_34 = esi;
	} while (*esi_34 != 0x00);
}

// 08048194: void fn08048194(Register uint32 eax, Register (ptr32 byte) edi)
// Called from:
//      fn0804804C
void fn08048194(uint32 eax, byte * edi)
{
	word32 * esp_24 = fp - 32;
	word32 ecx_27 = 0x00;
	do
	{
		uint64 edx_eax_34 = (uint64) eax;
		uint32 edx_37 = (uint32) (edx_eax_34 % 0x0A);
		esp_24 -= 4;
		*esp_24 = SEQ(SLICE(edx_37, word24, 8), (byte) edx_37 + 0x30);
		eax = (uint32) (edx_eax_34 /u 0x0A);
		++ecx_27;
	} while (eax != 0x00);
	do
	{
		*edi = (byte) dwLoc24;
		++edi;
		--ecx_27;
	} while (ecx_27 != 0x00);
	*edi = (byte) 0x09;
}

Eq_187 g_a80481B4[] = // 080481B4
	{
	};
byte g_b80481BA = 0x00; // 080481BA
word32 g_dw80481BB = 0x0A; // 080481BB
word32 g_a80481BD[] = // 080481BD
	{
	};
word32 g_dw80481C1 = 0x00; // 080481C1
word32 g_dw80481C5 = 0x00; // 080481C5
byte g_b80481C9 = 0x00; // 080481C9
byte g_b80481CA = 0x00; // 080481CA
byte g_b80481CB = 0x00; // 080481CB
byte g_a80481DB[] = // 080481DB
	{
	};
