//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(void);
int32_t function_8048160(void);
int32_t function_80481fe(void);
int32_t function_80482a7(void);
int32_t function_80482c6(void);
int32_t function_80482f0(void);
int32_t function_804830a(void);
int32_t function_8048318(void);
int32_t function_8048326(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);

// --------------------- Global Variables ---------------------

int16_t g1 = 0; // 0x804833f
int32_t g2 = 0; // 0x8048343
int32_t g3 = 0; // 0x8048347
char g4 = 0; // 0x804834b
char * g5; // 0x804834f
int32_t g6 = 0; // 0x805bbcf
int32_t g7 = 0; // 0x805bbd3
int32_t g8 = 0; // 0x805bbdb
int32_t g9 = 0; // 0x805bbe5
int32_t g10 = 0; // 0x805bbe6

// ------------------------ Functions -------------------------

// Address range: 0x80480dd - 0x8048160
int32_t entry_point(void) {
    // 0x80480dd
    function_80481fe();
    function_804830a();
    __asm_rep_stosw_memset((char *)&g5, 0x1bb0, g2);
    function_8048160();
    function_8048318();
    int32_t v1; // 0x80480dd
    int32_t * v2 = (int32_t *)(v1 - 4);
    *v2 = 3;
    __asm_int(128);
    while (g4 != 27 == (g4 != 13)) {
        // 0x804811f
        *v2 = 3;
        __asm_int(128);
    }
    // 0x804813f
    function_8048318();
    function_80482a7();
    *v2 = 1;
    __asm_int(128);
    return 1;
}

// Address range: 0x8048160 - 0x80481e8
int32_t function_8048160(void) {
    // 0x8048160
    function_80482f0();
    int32_t v1; // 0x8048160
    __asm_rep_stosw_memset((char *)v1, 475, 64);
    bool v2; // 0x8048160
    int32_t v3 = v2 ? -128 : 128; // 0x8048171
    int32_t v4; // 0x8048160
    int32_t v5 = &v4; // 0x8048176
    int32_t * v6 = (int32_t *)(v5 - 4);
    int32_t v7 = v2 ? -2 : 2;
    int32_t v8 = v2 ? -1 : 1;
    int32_t v9 = v8 + 1;
    int32_t v10 = v3 + v1; // 0x8048176
    *v6 = 10;
    function_80482f0();
    *(int16_t *)v10 = 221;
    int32_t v11 = v10 + v7; // 0x8048187
    *(int32_t *)(v5 - 8) = 62;
    __asm_rep_stosw_memset((char *)v11, 32, 62);
    int32_t v12 = v11 + (v2 ? -124 : 124); // 0x804818e
    *(int16_t *)v12 = 222;
    int32_t v13 = v12 + (v7 | 1); // 0x8048197
    *(char *)v13 = 3;
    int32_t v14 = v13 + v9; // 0x8048199
    *(char *)v14 = 3;
    v10 = v14 + v8;
    int32_t v15 = *v6 - 1; // 0x804819c
    while (v15 != 0) {
        // 0x8048177
        *v6 = v15;
        function_80482f0();
        *(int16_t *)v10 = 221;
        v11 = v10 + v7;
        *(int32_t *)(v5 - 8) = 62;
        __asm_rep_stosw_memset((char *)v11, 32, 62);
        v12 = v11 + (v2 ? -124 : 124);
        *(int16_t *)v12 = 222;
        v13 = v12 + (v7 | 1);
        *(char *)v13 = 3;
        v14 = v13 + v9;
        *(char *)v14 = 3;
        v10 = v14 + v8;
        v15 = *v6 - 1;
    }
    // 0x804819e
    function_80482f0();
    *v6 = 64;
    __asm_rep_stosw_memset((char *)v10, 475, 64);
    int32_t v16 = v10 + (v3 | 1); // 0x80481b4
    *(char *)v16 = 3;
    int32_t v17 = v16 + v9; // 0x80481b6
    *(char *)v17 = 3;
    int32_t v18 = function_80482f0(); // 0x80481bd
    *v6 = 64;
    int32_t v19 = v17; // 0x80481c4
    for (int32_t i = 64; i > 0; i--) {
        // 0x80481c5
        v19 += v9;
        *(char *)v19 = (char)v18;
    }
    // 0x80481c9
    function_80482c6();
    function_80482c6();
    return function_80482c6();
}

// Address range: 0x80481fe - 0x80482a7
int32_t function_80481fe(void) {
    // 0x80481fe
    __asm_int(128);
    g3 = 5;
    __asm_int(128);
    uint16_t v1 = g1; // 0x8048224
    g2 = v1 / 256 * (v1 % 256);
    __asm_int(128);
    __asm_int(128);
    __asm_int(128);
    g8 &= -12;
    g7 |= 5;
    g6 &= -1329;
    *(char *)&g9 = 0;
    *(char *)&g10 = 1;
    __asm_int(128);
    int32_t result; // 0x80481fe
    return result;
}

// Address range: 0x80482a7 - 0x80482c6
int32_t function_80482a7(void) {
    // 0x80482a7
    __asm_int(128);
    __asm_int(128);
    int32_t result; // 0x80482a7
    return result;
}

// Address range: 0x80482c6 - 0x80482f0
int32_t function_80482c6(void) {
    // 0x80482c6
    int32_t v1; // bp-32, 0x80482c6
    int32_t v2 = &v1; // 0x80482c6
    bool v3; // 0x80482c6
    int32_t v4 = v3 ? -1 : 1; // 0x80482cb
    int32_t * v5 = (int32_t *)(v2 - 4);
    int32_t v6; // 0x80482c6
    int32_t v7; // 0x80482c6
    int32_t v8; // 0x80482c6
    int32_t v9; // 0x80482c6
    int32_t v10; // 0x80482cb
    while (true) {
        // 0x80482cb
        v8 = 1792;
        int32_t v11; // 0x80482c6
        v9 = v11;
        while (true) {
          lab_0x80482cb_2:;
            int32_t v12 = v8;
            unsigned char v13 = *(char *)v9; // 0x80482cb
            v10 = v9 + v4;
            switch (v13) {
                case 0: {
                    return *(int32_t *)(v2 + 28);
                }
                case 1: {
                    int32_t v14 = (int32_t)*(char *)v10; // 0x80482e5
                    v7 = v12 & -0x10000 | v14 | 256 * v14;
                    v6 = v4;
                    goto lab_0x80482cb;
                }
                default: {
                    int32_t v15 = v12 & -256 | (int32_t)v13; // 0x80482cc
                    if (v13 != 2) {
                        // break -> 0x80482ea
                        break;
                    }
                    // 0x80482d8
                    *v5 = v15;
                    function_80482f0();
                    v7 = *v5;
                    v6 = v3 ? -2 : 2;
                    goto lab_0x80482cb;
                }
            }
        }
    }
  lab_0x80482ee:
    // 0x80482ee
    return *(int32_t *)(v2 + 28);
  lab_0x80482cb:
    // 0x80482cb
    v8 = v7;
    v9 = v6 + v10;
    goto lab_0x80482cb_2;
}

// Address range: 0x80482f0 - 0x804830a
int32_t function_80482f0(void) {
    // 0x80482f0
    int32_t result; // 0x80482f0
    return result;
}

// Address range: 0x804830a - 0x8048318
int32_t function_804830a(void) {
    // 0x804830a
    int32_t v1; // 0x804830a
    int32_t result; // 0x804830a
    function_8048326(result, result, result, &v1, result, result, result, result);
    __asm_int(128);
    return result;
}

// Address range: 0x8048318 - 0x8048326
int32_t function_8048318(void) {
    // 0x8048318
    int32_t v1; // 0x8048318
    int32_t result; // 0x8048318
    function_8048326(result, result, result, &v1, result, result, result, result);
    __asm_int(128);
    return result;
}

// Address range: 0x8048326 - 0x804833f
int32_t function_8048326(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x8048326
    return function_80482f0();
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: elfcrypt (1.0)
// Detected functions: 9

