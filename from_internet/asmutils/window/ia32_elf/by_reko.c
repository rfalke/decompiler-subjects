// subject_seg08048000_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_190 g_t804804C = // 0804804C
	{
		
		{
			0x02
		},
	};
Eq_190 g_t804807C = // 0804807C
	{
		
		{
			0x02
		},
	};
Eq_190 g_t80480BF = // 080480BF
	{
		
		{
			0x02
		},
	};
// 080480DD: void fn080480DD(Register Eq_2 edx)
void fn080480DD(Eq_2 edx)
{
	fn080481FE(edx);
	ui32 edx_11 = g_dw8048343;
	fn0804830A(0x00, edx_11);
	ui32 ecx_19;
	word16 * edi_20 = g_a804834F;
	for (ecx_19 = edx_11; ecx_19 != 0x00; --ecx_19)
	{
		*edi_20 = 0x1BB0;
		++edi_20;
	}
	fn08048160();
	fn08048318(0x00, g_dw8048343);
	do
	{
		do
		{
			int32 eax_49 = sys_read(0x00, &g_b804834B, 0x01);
			word24 eax_24_8_72 = SLICE(eax_49, word24, 8);
		} while (eax_49 < 0x00);
		byte al_54 = g_b804834B;
		int32 eax_71 = SEQ(eax_24_8_72, al_54);
		if (al_54 == 0x1B)
			break;
		eax_71 = SEQ(eax_24_8_72, al_54);
	} while (al_54 != 0x0D);
	fn08048318(0x00, g_dw8048343);
	fn080482A7();
	fn08048159(eax_71);
}

// 08048159: void fn08048159(Register int32 eax)
// Called from:
//      fn080480DD
//      fn080481FE
void fn08048159(int32 eax)
{
	sys_exit(eax);
}

// 08048160: void fn08048160()
// Called from:
//      fn080480DD
void fn08048160()
{
	word16 * edi_128 = fn080482F0(0x0201);
	word32 ecx_13;
	for (ecx_13 = 0x40; ecx_13 != 0x00; --ecx_13)
	{
		*edi_128 = 0x01DB;
		++edi_128;
	}
	word32 ecx_20 = 0x020B;
	do
	{
		word16 * edi_29 = fn080482F0(ecx_149 + 0x00);
		*edi_29 = 0xDD;
		word16 * edi_125 = edi_29 + 1;
		word32 ecx_126;
		for (ecx_126 = 0x3E; ecx_126 != 0x00; --ecx_126)
		{
			*edi_125 = 0x20;
			++edi_125;
		}
		*edi_125 = 222;
		struct Eq_103 * edi_48 = edi_125 + 1;
		edi_48->b0001 = 0x03;
		edi_48->b0003 = 0x03;
		ecx_20 = ecx_149 - 0x01;
		ecx_149 = ecx_20;
	} while (ecx_149 != ~0x01FF);
	word16 * edi_120 = fn080482F0(0x020C);
	word32 ecx_121;
	for (ecx_121 = 0x40; ecx_121 != 0x00; --ecx_121)
	{
		*edi_120 = 0x01DB;
		++edi_120;
	}
	struct Eq_148 * edi_76 = (char *) edi_120 + 1;
	edi_76->b0000 = 0x03;
	edi_76->b0002 = 0x03;
	word16 * edi_100 = fn080482F0(0x040D);
	word32 ecx_101;
	for (ecx_101 = 0x40; ecx_101 != 0x00; --ecx_101)
	{
		byte * edi_96 = (char *) edi_100 + 1;
		*edi_96 = 0x03;
		edi_100 = (word16 *) (edi_96 + 1);
	}
	fn080482C6(&g_t804804C, edi_96 + 1);
	fn080482C6(&g_t804807C, edi_96 + 1);
	fn080482C6(&g_t80480BF, edi_96 + 1);
}

char g_b80481E8 = 'C'; // 080481E8
char g_b80481F3 = '/'; // 080481F3
// 080481FE: void fn080481FE(Register Eq_2 edx)
// Called from:
//      fn080480DD
void fn080481FE(Eq_2 edx)
{
	Eq_203 eax_37 = sys_open(&g_b80481F3, 0x02, edx);
	g_t8048347.u0 = (int32) eax_37;
	if (eax_37 < 0x00)
	{
		int32 eax_53 = sys_write(0x00, &g_b80481E8, 22);
		fn08048159(eax_53);
	}
	else
	{
		sys_read(eax_37, &g_w804833F, 0x04);
		word32 eax_65 = (word32) g_w804833F;
		g_dw8048343 = SEQ(SLICE(eax_65, word16, 16), SLICE(eax_65, byte, 8) *16 (byte) eax_65);
		sys_fcntl(0x00, 0x04, 0x0800);
		sys_ioctl(0x00, 0x5401, 0x0805BBF3);
		sys_ioctl(0x00, 0x5401, 0x0805BBCF);
		g_dw805BBDB &= ~0x0B;
		g_dw805BBD3 |= 0x05;
		g_dw805BBCF &= ~0x0530;
		g_b805BBE5 = 0x00;
		g_b805BBE6 = 0x01;
		sys_ioctl(0x00, 0x5402, 0x0805BBCF);
	}
}

// 080482A7: void fn080482A7()
// Called from:
//      fn080480DD
void fn080482A7()
{
	sys_ioctl(0x00, 0x5402, 0x0805BBF3);
	sys_close(g_t8048347.u0);
}

// 080482C6: void fn080482C6(Register (ptr32 Eq_190) esi, Register (ptr32 word16) edi)
// Called from:
//      fn08048160
void fn080482C6(struct Eq_190 * esi, word16 * edi)
{
	byte ah_32 = 0x07;
	while (true)
	{
		Eq_319 al_35 = esi->t0000.u0;
		++esi;
		if (al_35 == 0x00)
			break;
		if (al_35 != 0x01)
		{
			word16 ax_66 = SEQ(ah_32, al_35);
			if (al_35 == 0x02)
			{
				esi += 2;
				edi = fn080482F0((uint32) esi->t0000.u1);
			}
			else
			{
				*edi = ax_66;
				++edi;
			}
		}
		else
		{
			++esi;
			ah_32 = esi->t0000.u0;
		}
	}
}

// 080482F0: Register ui32 fn080482F0(Register uint32 ecx)
// Called from:
//      fn08048160
//      fn080482C6
//      fn08048326
ui32 fn080482F0(uint32 ecx)
{
	byte ch_14 = SLICE(ecx, byte, 8);
	return (SEQ(SLICE(ecx, word16, 16), g_b8048340 *16 (byte) ecx) + (word32) ch_14 << 0x01) + 0x0804834F;
}

// 0804830A: void fn0804830A(Register uint32 ecx, Register ui32 edx)
// Called from:
//      fn080480DD
void fn0804830A(uint32 ecx, ui32 edx)
{
	uint32 ebx_28;
	Eq_44 edx_31;
	Eq_368 esi_32;
	sys_pread64(ebx_28, fn08048326(ecx, edx, out edx_31, out ebx_28, out esi_32), edx_31, esi_32);
}

// 08048318: void fn08048318(Register uint32 ecx, Register ui32 edx)
// Called from:
//      fn080480DD
void fn08048318(uint32 ecx, ui32 edx)
{
	uint32 ebx_28;
	Eq_44 edx_31;
	Eq_368 esi_32;
	sys_pwrite64(ebx_28, fn08048326(ecx, edx, out edx_31, out ebx_28, out esi_32), edx_31, esi_32);
}

// 08048326: Register uint32 fn08048326(Register uint32 ecx, Register ui32 edx, Register out Eq_379 edxOut, Register out Eq_203 ebxOut, Register out ptr32 esiOut)
// Called from:
//      fn0804830A
//      fn08048318
uint32 fn08048326(uint32 ecx, ui32 edx, union Eq_379 & edxOut, union Eq_203 & ebxOut, ptr32 & esiOut)
{
	uint32 ebx;
	ptr32 esi_12 = fn080482F0(ecx) - 0x0804834B;
	Eq_203 ebx_19 = g_t8048347.u0;
	edxOut = edx << 0x01;
	ebxOut = ebx_19;
	esiOut = esi_12;
	return ebx;
}

word16 g_w804833F = 0x00; // 0804833F
bu8 g_b8048340 = 0x00; // 08048340
ui32 g_dw8048343 = 0x00; // 08048343
Eq_203 g_t8048347 = // 08048347
	{
		0
	};
byte g_b804834B = 0x00; // 0804834B
word16 g_a804834F[] = // 0804834F
	{
	};
// subject_seg08048000_0001.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 g_dw805BBCF = 0x00; // 0805BBCF
ui32 g_dw805BBD3 = 0x00; // 0805BBD3
ui32 g_dw805BBDB = 0x00; // 0805BBDB
byte g_b805BBE5 = 0x00; // 0805BBE5
byte g_b805BBE6 = 0x00; // 0805BBE6
