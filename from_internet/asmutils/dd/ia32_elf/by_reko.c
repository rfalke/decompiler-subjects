// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_b804804C = 'u'; // 0804804C
char g_b8048079 = 'I'; // 08048079
// 08048082: void fn08048082(Stack word32 dwArg00, Stack (ptr32 Eq_3) dwArg08)
void fn08048082(word32 dwArg00, struct Eq_3 * dwArg08)
{
	if (dwArg00 != 0x01)
	{
		g_b804836C = 0x02;
		if (dwArg08 == null)
		{
			sys_brk(g_t804836B.u0 + 0x0804838B);
			if (sys__llseek() < 0x00)
			{
				while (true)
				{
					int32 v20_58 = g_dw804836F - 0x01;
					g_dw804836F = v20_58;
					if (v20_58 < 0x00)
						break;
					Eq_15 edx_226 = g_t804836B.u0;
					do
					{
						Eq_124 eax_235 = sys_read(0x08048383, g_a804838B, edx_226);
						if (eax_235 <= 0x00)
							fn08048153();
						edx_226 -= eax_235;
					} while (edx_226 != 0x00);
				}
			}
			sys__llseek();
			char * edi_153 = null;
			word32 esi_130 = g_dw8048367;
			do
			{
				char * ecx_102 = g_a804838B;
				Eq_15 edx_103 = g_t804836B.u0;
				do
				{
					int32 eax_96 = sys_read(0x00, ecx_102, edx_103);
					if (eax_96 == 0x00)
						goto l08048245;
					if (eax_96 < 0x00)
						fn08048153();
					ecx_102 += eax_96;
					edx_103 -= eax_96;
				} while (edx_103 > 0x00);
				++g_dw8048377;
				fn080482A7(ecx_102);
				ecx_102 = (char *) g_a804838B;
				edx_103 = ecx_102 - 0x0804838B;
				if (sys_write(0x01, g_a804838B, ecx_102 - 0x0804838B) != ecx_102 - 0x0804838B)
					fn08048153();
				++g_dw804837B;
				--esi_130;
			} while (esi_130 != 0x00);
l08048245:
			if (edx_103 != g_t804836B.u0)
			{
				++g_b804837F;
				++g_b8048380;
				if (g_b8048381 == 0x01)
				{
					edi_153 = ecx_102;
					Eq_15 ecx_154;
					for (ecx_154 = edx_103; ecx_154 != 0x00; --ecx_154)
					{
						*edi_153 = 0x00;
						++edi_153;
					}
					--g_b8048380;
					++g_dw804837B;
					ecx_102 = edi_153;
				}
				fn080482A7(ecx_102);
				sys_write(0x01, g_a804838B, ecx_102 - 0x0804838B);
			}
			sys_close(edi_153);
			sys_close(0x01);
			fn080482C8();
			sys_exit(0x00);
		}
		else if (dwArg08->b0000 == 0x666F)
		{
			if (sys_open(fn08048149(dwArg08), 32833, 0x01A4) >= 0x00)
				return;
			fn08048153();
		}
		else if (dwArg08->b0000 == 0x6669)
			fn08048116(0x8000, 0x01, dwArg08);
		else
		{
			word32 * edx_294 = &g_dw8048367;
			if (dwArg08->b0000 != 1853189987)
			{
				edx_294 = (word32 *) &g_t804836B;
				if (dwArg08->b0000 != 0x7362)
				{
					edx_294 = &g_dw804836F;
					if (dwArg08->b0000 != 0x70696B73)
					{
						edx_294 = &g_dw8048373;
						if (dwArg08->b0000 != 0x6B656573)
						{
							if (dwArg08->b0000 != 0x766E6F63)
								return;
							if (dwArg08[5] == 0x636E7973)
							{
								g_b8048381 = 0x01;
								return;
							}
							else
							{
								if (dwArg08[5] != 0x62617773)
									return;
								g_b8048382 = 0x01;
								return;
							}
						}
					}
				}
			}
			*edx_294 = fn0804832F(fn08048149(dwArg08));
		}
	}
	else
	{
		sys_write(0x01, &g_b804804C, 0x2D);
		sys_exit(0x00);
	}
}

// 08048116: void fn08048116(Register int32 ecx, Register Eq_47 edx, Register (ptr32 Eq_3) esi)
// Called from:
//      fn08048082
void fn08048116(int32 ecx, Eq_47 edx, struct Eq_3 * esi)
{
	if (sys_open(fn08048149(esi), ecx, edx) >= 0x00)
		return;
	fn08048153();
}

// 08048149: Register (ptr32 Eq_3) fn08048149(Register (ptr32 Eq_3) esi)
// Called from:
//      fn08048082
//      fn08048116
struct Eq_3 * fn08048149(struct Eq_3 * esi)
{
	do
	{
		byte al_6 = esi->b0000;
		++esi;
		if (al_6 == 0x00)
			fn0804816A();
	} while (al_6 != 0x3D);
	return esi;
}

// 08048153: void fn08048153()
// Called from:
//      fn08048082
//      fn08048116
void fn08048153()
{
	sys_write(0x02, &g_b8048079, 0x09);
	fn080482C8();
	fn0804816A();
}

// 0804816A: void fn0804816A()
// Called from:
//      fn08048082
//      fn08048149
//      fn0804832F
void fn0804816A()
{
	sys_exit(0x01);
}

// 080482A7: void fn080482A7(Register (ptr32 char) ecx)
// Called from:
//      fn08048082
void fn080482A7(char * ecx)
{
	if ((g_b8048382 & 0x01) != 0x00)
	{
		word16 * esi_33 = g_a804838B;
		word16 * edi_34 = g_a804838B;
		word32 ecx_36 = ecx - g_a804838B;
		if (ecx != g_a804838B)
		{
			do
			{
				word16 ax_43 = *esi_33;
				*edi_34 = SEQ((byte) ax_43, SLICE(ax_43, byte, 8));
				++esi_33;
				++edi_34;
				--ecx_36;
			} while (ecx_36 != 0x00);
		}
	}
}

// 080482C8: void fn080482C8()
// Called from:
//      fn08048082
void fn080482C8()
{
	struct Eq_354 * edi_11 = fn08048318(g_dw8048377, g_a804838B);
	edi_11->dw0000 = SEQ(0x00, g_b804837F, 0x00) + 0x0020302B;
	edi_11->dw0004 = 170684009;
	struct Eq_354 * edi_33 = fn08048318(g_dw804837B, &edi_11->dw0004 + 1);
	edi_33->dw0000 = SEQ(0x00, g_b8048380, 0x00) + 0x0020302B;
	edi_33->dw0004 = 175404399;
	sys_write(0x02, g_a804838B, edi_33 - 0x08048383);
}

// 08048318: Register (ptr32 byte) fn08048318(Register uint32 eax, Register (ptr32 byte) edi)
// Called from:
//      fn080482C8
byte * fn08048318(uint32 eax, byte * edi)
{
	word32 * fp;
	word32 * esp_21 = fp;
	word32 ecx_26 = 0x00;
	do
	{
		uint64 edx_eax_14 = (uint64) eax;
		uint32 edx_17 = (uint32) (edx_eax_14 % 0x0A);
		esp_21 -= 4;
		*esp_21 = SEQ(SLICE(edx_17, word24, 8), (byte) edx_17 + 0x30);
		uint32 eax_18 = (uint32) (edx_eax_14 /u 0x0A);
		++ecx_26;
		eax = eax_18;
	} while (eax_18 != 0x00);
	do
	{
		*edi = 0x0A;
		++edi;
		--ecx_26;
	} while (ecx_26 != 0x00);
	return edi;
}

// 0804832F: Register Eq_442 fn0804832F(Register (ptr32 char) esi)
// Called from:
//      fn08048082
Eq_442 fn0804832F(char * esi)
{
	Eq_442 ebx_28 = 0x00;
	while (true)
	{
		cu8 al_11 = *esi;
		++esi;
		if (al_11 == 0x00)
			break;
		if (al_11 > 0x39)
		{
			if (al_11 != 0x77)
			{
				if (al_11 != 0x62)
				{
					if (al_11 != 0x6B)
					{
						if (al_11 != 0x6D)
							fn0804816A();
						ebx_28 <<= 0x0A;
					}
					ebx_28 <<= 0x01;
				}
				ebx_28 <<= 0x08;
			}
			ebx_28 <<= 0x01;
			return ebx_28;
		}
		ebx_28 = ebx_28 *s 0x0A + (uint32) (al_11 - 0x30);
	}
	return ebx_28;
}

word32 g_dw8048367 = 0x00; // 08048367
Eq_15 g_t804836B = // 0804836B
	{
		0x00
	};
byte g_b804836C = 0x00; // 0804836C
int32 g_dw804836F = 0; // 0804836F
word32 g_dw8048373 = 0x00; // 08048373
uint32 g_dw8048377 = 0x00; // 08048377
uint32 g_dw804837B = 0x00; // 0804837B
byte g_b804837F = 0x00; // 0804837F
byte g_b8048380 = 0x00; // 08048380
byte g_b8048381 = 0x00; // 08048381
byte g_b8048382 = 0x00; // 08048382
word16 g_a804838B[] = // 0804838B
	{
	};
