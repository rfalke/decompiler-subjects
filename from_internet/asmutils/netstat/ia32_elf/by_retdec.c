//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2);
int32_t function_8048364(void);
int32_t function_80483e9(void);
int32_t function_8048412(void);
int32_t function_804845b(void);
int32_t function_80484b0(void);
int32_t function_8048553(void);
int32_t function_8048568(void);
int32_t function_80485b8(void);

// --------------------- Global Variables ---------------------

char * g1 = "tcp   udp   raw   unix  Active Internet connectionsActive UNIX domain sockets (only servers)\n (w/o servers)\n (servers and established)\nProto Local Address           Foreign Address         State       \nProto RefCnt Flags       Type       State         I-Node Path                  \n            ESTABLISHED SYN_SENT    SYN_RECV    FIN_WAIT1   FIN_WAIT2   TIME_WAIT   CLOSE       CLOSE_WAIT  LAST_ACK    LISTEN      CLOSING     FREE          LISTENING     CONNECTING    CONNECTED     DISCONNECTING ACC W N STREAM     DGRAM      RAW        RDM        SEQPACKET  [Kt [[\t\xdbt\x1a\x80;-u\xf6\x43\x80;-t\a\xe8\x96"; // 0x8048085
char * g2 = "udp   raw   unix  Active Internet connectionsActive UNIX domain sockets (only servers)\n (w/o servers)\n (servers and established)\nProto Local Address           Foreign Address         State       \nProto RefCnt Flags       Type       State         I-Node Path                  \n            ESTABLISHED SYN_SENT    SYN_RECV    FIN_WAIT1   FIN_WAIT2   TIME_WAIT   CLOSE       CLOSE_WAIT  LAST_ACK    LISTEN      CLOSING     FREE          LISTENING     CONNECTING    CONNECTED     DISCONNECTING ACC W N STREAM     DGRAM      RAW        RDM        SEQPACKET  [Kt [[\t\xdbt\x1a\x80;-u\xf6\x43\x80;-t\a\xe8\x96"; // 0x804808b
char * g3 = "raw   unix  Active Internet connectionsActive UNIX domain sockets (only servers)\n (w/o servers)\n (servers and established)\nProto Local Address           Foreign Address         State       \nProto RefCnt Flags       Type       State         I-Node Path                  \n            ESTABLISHED SYN_SENT    SYN_RECV    FIN_WAIT1   FIN_WAIT2   TIME_WAIT   CLOSE       CLOSE_WAIT  LAST_ACK    LISTEN      CLOSING     FREE          LISTENING     CONNECTING    CONNECTED     DISCONNECTING ACC W N STREAM     DGRAM      RAW        RDM        SEQPACKET  [Kt [[\t\xdbt\x1a\x80;-u\xf6\x43\x80;-t\a\xe8\x96"; // 0x8048091
char * g4 = "unix  Active Internet connectionsActive UNIX domain sockets (only servers)\n (w/o servers)\n (servers and established)\nProto Local Address           Foreign Address         State       \nProto RefCnt Flags       Type       State         I-Node Path                  \n            ESTABLISHED SYN_SENT    SYN_RECV    FIN_WAIT1   FIN_WAIT2   TIME_WAIT   CLOSE       CLOSE_WAIT  LAST_ACK    LISTEN      CLOSING     FREE          LISTENING     CONNECTING    CONNECTED     DISCONNECTING ACC W N STREAM     DGRAM      RAW        RDM        SEQPACKET  [Kt [[\t\xdbt\x1a\x80;-u\xf6\x43\x80;-t\a\xe8\x96"; // 0x8048097
char g5 = 0; // 0x8048910
char g6 = 0; // 0x8048912
char g7 = 0; // 0x8048913
char g8 = 0; // 0x8048914
char g9 = 0; // 0x8048915
char g10 = 0; // 0x8048916
char g11 = 0; // 0x8048917
char g12 = 0; // 0x8048918
char g13 = 0; // 0x8048919
char g14 = 0; // 0x804891a
char g15 = 0; // 0x804891b
char * g16; // 0x804991c
char * g17; // 0x8049aca
char * g18; // 0x8049b0d
char g19 = 0; // 0x8049b5d
char g20 = 0; // 0x8049b62
int32_t g21 = 0; // 0x8049b63

// ------------------------ Functions -------------------------

// Address range: 0x80482b4 - 0x8048364
int32_t entry_point(int32_t a1, int32_t a2) {
    int32_t v1 = a2;
    int32_t v2 = &v1; // 0x80482b6
    if (a1 != 1) {
        // 0x80482b8
        int32_t v3; // 0x80482b4
        int32_t v4 = (int32_t)&v3 + 4; // 0x80482b9
        v2 = v4;
        int32_t v5; // 0x80482b4
        if (v5 != 0) {
            int32_t v6; // 0x80482b4
            if (*(char *)v6 == 45) {
                // 0x80482c3
                if (*(char *)(v6 + 1) == 45) {
                    // 0x80482d0
                    function_80483e9();
                } else {
                    // 0x80482c9
                    function_8048364();
                }
            }
            int32_t v7 = *(int32_t *)v4; // 0x80482b9
            int32_t v8 = v4 + 4; // 0x80482b9
            int32_t v9 = v8; // 0x80482bc
            v2 = v8;
            while (v7 != 0) {
                int32_t v10 = v7;
                if (*(char *)v10 == 45) {
                    // 0x80482c3
                    if (*(char *)(v10 + 1) == 45) {
                        // 0x80482d0
                        function_80483e9();
                    } else {
                        // 0x80482c9
                        function_8048364();
                    }
                }
                // 0x80482b9
                v7 = *(int32_t *)v9;
                v8 = v9 + 4;
                v9 = v8;
                v2 = v8;
            }
        }
    }
    // 0x80482d8
    function_8048412();
    if (g10 != 0) {
        // 0x80482e6
        function_804845b();
        *(int32_t *)(v2 - 4) = 4;
        __asm_int(128);
        function_80484b0();
    }
    // 0x804830c
    if (g9 == 0) {
        // 0x804835f
        *(int32_t *)(v2 - 4) = 1;
        __asm_int(128);
        return 1;
    }
    // 0x8048315
    function_804845b();
    int32_t * v11 = (int32_t *)(v2 - 4);
    *v11 = 4;
    __asm_int(128);
    if (g9 != 0) {
        // 0x804833f
        __asm_rep_movsb_memcpy((char *)&g18, (char *)&g4, 6);
        function_8048553();
    }
    // 0x804835f
    *v11 = 1;
    __asm_int(128);
    return 1;
}

// Address range: 0x8048364 - 0x80483e9
int32_t function_8048364(void) {
    int32_t v1 = 6; // 0x8048369
    int32_t result; // 0x8048364
    int32_t v2 = result - 1; // 0x8048369
    v2++;
    char * v3 = (char *)v2; // 0x804836b
    char v4 = *v3; // 0x804836b
    while (v4 != 0) {
        char v5 = v4; // 0x8048373
        if (v4 == 97) {
            // 0x8048375
            g8++;
            g6 = 10;
            g7++;
            v5 = *v3;
        }
        char v6 = v5; // 0x804838b
        if (result == 0 == v5 == 108) {
            // 0x8048398
            g6 = 10;
            g7 = 0;
            v6 = *v3;
        }
        char v7 = v6; // 0x80483a9
        if (v6 == 116) {
            // 0x80483ab
            g12++;
            g15++;
            v7 = *v3;
        }
        char v8 = v7; // 0x80483ba
        if (v7 == 117) {
            // 0x80483bc
            g13++;
            g15++;
            v8 = *v3;
        }
        char v9 = v8; // 0x80483cb
        if (v8 == 119) {
            // 0x80483cd
            g14++;
            g15++;
            v9 = *v3;
        }
        // 0x80483d9
        if (v9 == 112) {
            // 0x80483de
            g5++;
        }
        // 0x80483e4
        v1--;
        if (v1 == 0) {
            // break -> 0x80483e6
            break;
        }
        v2++;
        v3 = (char *)v2;
        v4 = *v3;
    }
    // 0x80483e6
    return result;
}

// Address range: 0x80483e9 - 0x8048412
int32_t function_80483e9(void) {
    // 0x80483e9
    int32_t result; // 0x80483e9
    if (result == 0x78696e75) {
        // 0x80483f1
        g9++;
        g11++;
    }
    if (result == 0x74656e69) {
        // 0x8048405
        g10++;
        g11++;
    }
    // 0x8048411
    return result;
}

// Address range: 0x8048412 - 0x804845b
int32_t function_8048412(void) {
    // 0x8048412
    if (g15 == 0) {
        // 0x804841b
        g12++;
        g13++;
        g14++;
    }
    // 0x804842d
    if (g8 == 0) {
        // 0x8048436
        if (g6 == 0) {
            // 0x804843f
            g7++;
        }
    }
    // 0x8048445
    if (g11 == 0) {
        // 0x804844e
        g9++;
        g10++;
    }
    // 0x804845a
    int32_t result; // 0x8048412
    return result;
}

// Address range: 0x804845b - 0x80484b0
int32_t function_804845b(void) {
    // 0x804845b
    __asm_int(128);
    __asm_int(128);
    return 4;
}

// Address range: 0x80484b0 - 0x804852c
int32_t function_80484b0(void) {
    // 0x80484b0
    int32_t v1; // 0x80484b0
    if (g12 != 0) {
        // 0x80484b9
        __asm_rep_movsb_memcpy((char *)&g17, (char *)&g1, 6);
        v1 = function_8048553();
    }
    int32_t v2 = v1; // 0x80484e0
    if (g13 != 0) {
        // 0x80484e2
        __asm_rep_movsb_memcpy((char *)&g17, (char *)&g2, 6);
        v2 = function_8048553();
    }
    int32_t result = v2; // 0x8048509
    if (g14 != 0) {
        // 0x804850b
        __asm_rep_movsb_memcpy((char *)&g17, (char *)&g3, 6);
        result = function_8048553();
    }
    // 0x804852b
    return result;
}

// Address range: 0x8048553 - 0x8048568
int32_t function_8048553(void) {
    // 0x8048553
    __asm_int(128);
    function_8048568();
    int32_t result; // 0x8048553
    return result;
}

// Address range: 0x8048568 - 0x80485b8
int32_t function_8048568(void) {
    // 0x8048568
    __asm_rep_stosb_memset((char *)&g16, 32, 256);
    int32_t v1 = (int32_t)&g16; // 0x804857a
    int32_t v2; // 0x8048568
    *(int32_t *)((int32_t)&v2 - 4) = 3;
    __asm_int(128);
    while (*(char *)v1 != 10) {
        // 0x804857f
        bool v3; // 0x8048568
        v1 += (v3 ? -1 : 1);
        *(int32_t *)((int32_t)&v2 - 4) = 3;
        __asm_int(128);
    }
    // 0x8048596
    if (g16 == (char *)0x6c732020) {
        function_8048568();
    }
    // 0x80485a2
    if (g16 == (char *)0x206d754e) {
        function_8048568();
    }
    // 0x80485ae
    function_80485b8();
    return function_8048568();
}

// Address range: 0x80485b8 - 0x8048639
int32_t function_80485b8(void) {
    // 0x80485b8
    if (g19 == 10) {
        goto lab_0x80485f3;
    } else {
        // 0x80485c2
        if (g18 != (char *)0x78696e75) {
            if (g19 != 0) {
                goto lab_0x80485fe;
            } else {
                goto lab_0x80485f3;
            }
        } else {
            if (g19 != 1) {
                goto lab_0x80485fe;
            } else {
                // 0x80485d7
                if ((g21 & 0x10000) == 0) {
                    goto lab_0x80485fe;
                } else {
                    goto lab_0x80485f3;
                }
            }
        }
    }
  lab_0x80485f3:;
    // 0x80485f3
    int32_t result; // 0x80485b8
    if (g6 == 0) {
        // 0x8048637
        return result;
    }
    goto lab_0x8048607;
  lab_0x8048607:
    // 0x8048607
    if (g20 < 2) {
        // 0x804862f
        __asm_int(128);
    }
    // 0x8048637
    return result;
  lab_0x80485fe:
    // 0x80485fe
    if (g7 == 0) {
        // 0x8048637
        return result;
    }
    goto lab_0x8048607;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 9

