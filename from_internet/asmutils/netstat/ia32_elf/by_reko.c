// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_4 g_t8048076 = // 08048076
	{
		0x2F,
		0x70,
	};
byte g_a8048085[] = // 08048085
	{
	};
byte g_a804808B[] = // 0804808B
	{
	};
byte g_a8048091[] = // 08048091
	{
	};
byte g_a8048097[] = // 08048097
	{
	};
byte g_b804819F = 0x20; // 0804819F
// 080482B4: void fn080482B4(Register word32 eax, Stack word32 dwArg00)
void fn080482B4(word32 eax, word32 dwArg00)
{
	struct Eq_4 * ebx_15 = dwArg00 - 0x01;
	if (dwArg00 != 0x01)
	{
		word32 * esp_10 = fp + 8;
		while (true)
		{
			struct Eq_4 * ebx_13 = *esp_10;
			++esp_10;
			ebx_15 = ebx_13;
			if (ebx_13 == null)
				break;
			if (ebx_13->b0000 == 0x2D)
			{
				if (ebx_13->b0001 != 0x2D)
					fn08048364(eax, &ebx_13->b0001);
				else
					fn080483E9(&ebx_13->b0001 + 1);
			}
		}
	}
	fn08048412();
	if (g_b8048916 != 0x00)
	{
		fn0804845B();
		__syscall(0x80);
		ebx_15 = fn080484B0();
	}
	if (g_b8048915 != 0x00)
	{
		fn0804845B();
		__syscall(0x80);
		ebx_15 = (struct Eq_4 *) 0x01;
		if (g_b8048915 != 0x00)
		{
			word32 ecx_112;
			byte * esi_105 = g_a8048097;
			byte * edi_108 = g_a8049B0D;
			for (ecx_112 = 0x06; ecx_112 != 0x00; --ecx_112)
			{
				*edi_108 = *esi_105;
				++esi_105;
				++edi_108;
			}
			fn08048553();
			ebx_15 = &g_t8048076;
		}
	}
	__syscall(0x80);
	fn08048364(0x01, ebx_15);
}

// 08048364: void fn08048364(Register word32 eax, Register (ptr32 Eq_4) ebx)
// Called from:
//      fn080482B4
void fn08048364(word32 eax, struct Eq_4 * ebx)
{
	word32 ecx_11;
	byte * ebx_14 = ebx - 0x01;
	for (ecx_11 = 0x06; ecx_11 != 0x00; --ecx_11)
	{
		++ebx_14;
		if (*ebx_14 == 0x00)
			return;
		if (*ebx_14 == 0x61)
		{
			++g_b8048914;
			g_b8048912 = 0x0A;
			++g_b8048913;
		}
		if (*ebx_14 == 0x6C && eax == 0x00)
		{
			g_b8048912 = 0x0A;
			g_b8048913 = 0x00;
		}
		if (*ebx_14 == 116)
		{
			++g_b8048918;
			++g_b804891B;
		}
		if (*ebx_14 == 117)
		{
			++g_b8048919;
			++g_b804891B;
		}
		if (*ebx_14 == 0x77)
		{
			++g_b804891A;
			++g_b804891B;
		}
		if (*ebx_14 == 0x70)
			++g_b8048910;
	}
}

// 080483E9: void fn080483E9(Register (ptr32 word32) ebx)
// Called from:
//      fn080482B4
void fn080483E9(word32 * ebx)
{
	if (*ebx == 2020175477)
	{
		++g_b8048915;
		++g_b8048917;
	}
	if (*ebx == 0x74656E69)
	{
		++g_b8048916;
		++g_b8048917;
	}
}

// 08048412: void fn08048412()
// Called from:
//      fn080482B4
void fn08048412()
{
	if (g_b804891B == 0x00)
	{
		++g_b8048918;
		++g_b8048919;
		++g_b804891A;
	}
	if (g_b8048914 == 0x00 && g_b8048912 == 0x00)
		++g_b8048913;
	if (g_b8048917 == 0x00)
	{
		++g_b8048915;
		++g_b8048916;
	}
}

// 0804845B: void fn0804845B()
// Called from:
//      fn080482B4
void fn0804845B()
{
	__syscall(0x80);
	if (g_b8048914 != 0x00)
		__syscall(0x80);
	else if (g_b8048913 != 0x00)
		__syscall(0x80);
	else
		__syscall(0x80);
}

// 080484B0: Register word32 fn080484B0()
// Called from:
//      fn080482B4
word32 fn080484B0()
{
	if (g_b8048918 != 0x00)
	{
		word32 ecx_6;
		byte * esi_59 = g_a8048085;
		byte * edi_61 = g_a8049ACA;
		for (ecx_6 = 0x06; ecx_6 != 0x00; --ecx_6)
		{
			*edi_61 = *esi_59;
			++esi_59;
			++edi_61;
		}
		fn08048553();
		ebx = 0x0804804C;
	}
	if (g_b8048919 != 0x00)
	{
		word32 ecx_20;
		byte * esi_21 = g_a804808B;
		byte * edi_22 = g_a8049ACA;
		for (ecx_20 = 0x06; ecx_20 != 0x00; --ecx_20)
		{
			*edi_22 = *esi_21;
			++esi_21;
			++edi_22;
		}
		fn08048553();
		ebx = 0x0804805A;
	}
	if (g_b804891A != 0x00)
	{
		word32 ecx_34;
		byte * esi_35 = g_a8048091;
		byte * edi_36 = g_a8049ACA;
		for (ecx_34 = 0x06; ecx_34 != 0x00; --ecx_34)
		{
			*edi_36 = *esi_35;
			++esi_35;
			++edi_36;
		}
		fn08048553();
		ebx = 0x08048068;
	}
	return ebx;
}

// 08048553: void fn08048553()
// Called from:
//      fn080482B4
//      fn080484B0
void fn08048553()
{
	__syscall(0x80);
	fn08048568();
}

// 08048568: void fn08048568()
// Called from:
//      fn08048553
void fn08048568()
{
	while (true)
	{
		byte * edi_33 = g_a804991C;
		word32 ecx_101;
		for (ecx_101 = 0x0100; ecx_101 != 0x00; --ecx_101)
		{
			*edi_33 = 0x20;
			++edi_33;
		}
		byte * esi_52 = g_a804991C;
		do
		{
			__syscall(0x80);
			++esi_52;
		} while ((uint32) *esi_52 != 0x0A);
		if (g_a804991C[0] != 1819484192 && g_a804991C[0] != 544044366)
		{
			fn08048639(0x01);
			fn080485B8();
		}
	}
}

// 080485B8: void fn080485B8()
// Called from:
//      fn08048568
void fn080485B8()
{
	if (g_t8049B5D == 0x0A)
	{
l080485F3:
		if (g_b8048912 == 0x00)
			return;
		goto l08048607;
	}
	else
	{
		if (g_a8049B0D[0] == 2020175477)
		{
			if (g_t8049B5D == 0x01 && (g_dw8049B63 & 0x00010000) != 0x00)
				goto l080485F3;
		}
		else if (g_t8049B5D == 0x00)
			goto l080485F3;
		if (g_b8048913 == 0x00)
			return;
l08048607:
		if (g_b8049B62 == 0x00 || g_b8049B62 == 0x01)
			__syscall(0x80);
	}
}

// 08048639: void fn08048639(Register ui32 edx)
// Called from:
//      fn08048568
void fn08048639(ui32 edx)
{
	g_b8049B62 = 0x00;
	word32 ecx_136;
	byte * edi_135 = g_a8049AD0;
	for (ecx_136 = 0x3C; ecx_136 != 0x00; --ecx_136)
	{
		*edi_135 = 0x20;
		++edi_135;
	}
	*edi_135 = 0x0A;
	byte * edi_45 = fn080488A8(edx, &g_w8049922, g_a8049AD0);
	*edi_45 = 0x3A;
	word32 esi_57 = fn08048884(edx, (char *) &g_w8049922 + 1, edi_45 + 1);
	byte * edi_65 = fn080488A8(edx, esi_57 + 0x01, &g_b8049AE8);
	*edi_65 = 0x3A;
	word32 esi_195;
	Eq_453 eax_84 = fn080487F8(edx, fn08048884(edx, esi_57 + 0x02, edi_65 + 1) + 0x01, out esi_195);
	g_t8049B5D = eax_84;
	Eq_453 ecx_100 = eax_84;
	byte * esi_126 = &g_b804819F;
	if (eax_84 == 0x07 && g_a8049ACA[0] == 0x20706475)
		g_t8049B5D.u0 = 0x00;
	else
	{
		do
		{
			esi_126 += 0x0C;
			--ecx_100;
		} while (ecx_100 != 0x00);
	}
	byte * edi_106 = g_a8049B00;
	word32 ecx_107;
	for (ecx_107 = 0x0C; ecx_107 != 0x00; --ecx_107)
	{
		*edi_106 = *esi_126;
		++esi_126;
		++edi_106;
	}
}

// 080487F8: Register word32 fn080487F8(Register ui32 edx, Register (ptr32 word16) esi, Register out ptr32 esiOut)
// Called from:
//      fn08048639
//      fn0804886C
//      fn080488C4
word32 fn080487F8(ui32 edx, word16 * esi, ptr32 & esiOut)
{
	uint32 eax_22 = (uint32) *esi;
	word32 ecx_19 = 0x02;
	Eq_610 ebx_24 = eax_22 & 0xFF;
	while (true)
	{
		int32 ebx_32;
		if (ebx_24 <= 0x39)
			ebx_32 = ebx_24 - 0x30;
		else if (ebx_24 <= 0x5A)
			ebx_32 = ebx_24 - 55;
		else
			ebx_32 = ebx_24 - 0x57;
		--ecx_19;
		if (ecx_19 == 0x00)
			break;
		uint32 eax_63 = eax_22 & 0xFF00;
		edx = ebx_32 << 0x04;
		eax_22 = eax_63 >> 0x08;
		ebx_24 = eax_63 >> 0x08;
	}
	esiOut = esi + 1;
	return edx + ebx_32;
}

// 08048842: Register uint32 fn08048842(Register uint32 eax, Register uint32 edx, Register (ptr32 byte) edi, Register out (ptr32 byte) ediOut)
// Called from:
//      fn08048842
//      fn08048884
//      fn080488EC
uint32 fn08048842(uint32 eax, uint32 edx, byte * edi, byte & ediOut)
{
	uint32 edx_30;
	if (eax == 0x00)
	{
		edx_30 = edx;
		if (edx != 0x00)
			goto l08048867;
	}
	else
	{
		uint64 edx_eax_21 = (uint64) eax;
		edx_30 = fn08048842((uint32) (edx_eax_21 /u 0x0A), (uint32) (edx_eax_21 % 0x0A), edi, out edi);
	}
	*edi = (byte) edx_30 + 0x30;
	++edi;
l08048867:
	ediOut = edi;
	return <invalid>;
}

// 0804886C: Register ui32 fn0804886C(Register ui32 edx, Register (ptr32 word16) esi, Register out ptr32 esiOut)
// Called from:
//      fn08048884
ui32 fn0804886C(ui32 edx, word16 * esi, ptr32 & esiOut)
{
	word16 * esi_11;
	Eq_453 eax_10 = fn080487F8(edx, esi, out esi_11);
	ptr32 esi_20;
	ui32 eax_27 = (word32) fn080487F8(eax_10 << 0x08, esi_11, out esi_20) + (eax_10 << 0x08);
	esiOut = esi_20;
	return eax_27;
}

// 08048884: Register (ptr32 word16) fn08048884(Register ui32 edx, Register (ptr32 word16) esi, Register (ptr32 byte) edi)
// Called from:
//      fn08048639
word16 * fn08048884(ui32 edx, word16 * esi, byte * edi)
{
	word16 * esi_11;
	word32 edi_31;
	fn08048842(fn0804886C(edx, esi, out esi_11), 0x00, edi, out edi_31);
	return esi_11;
}

// 080488A8: Register (ptr32 byte) fn080488A8(Register ui32 edx, Register (ptr32 word16) esi, Register (ptr32 byte) edi)
// Called from:
//      fn08048639
byte * fn080488A8(ui32 edx, word16 * esi, byte * edi)
{
	g_dw8049B5E = fn080488C4(edx, esi);
	return fn080488EC(&g_dw8049B5E, edi);
}

// 080488C4: Register ui32 fn080488C4(Register ui32 edx, Register (ptr32 word16) esi)
// Called from:
//      fn080488A8
ui32 fn080488C4(ui32 edx, word16 * esi)
{
	word16 * esi_6;
	Eq_453 eax_5 = fn080487F8(edx, esi, out esi_6);
	word16 * esi_15;
	ui32 edx_21 = (eax_5 << 0x18) + (fn080487F8(eax_5 << 0x18, esi_6, out esi_15) << 0x10);
	word16 * esi_24;
	ui32 edx_30 = edx_21 + (fn080487F8(edx_21, esi_15, out esi_24) << 0x08);
	word32 esi_45;
	return (word32) fn080487F8(edx_30, esi_24, out esi_45) + edx_30;
}

// 080488EC: Register (ptr32 byte) fn080488EC(Register (ptr32 byte) esi, Register (ptr32 byte) edi)
// Called from:
//      fn080488A8
byte * fn080488EC(byte * esi, byte * edi)
{
	word32 ecx_17 = 0x04;
	while (true)
	{
		byte * edi_32;
		fn08048842((uint32) *esi, 0x00, edi, out edi_32);
		++esi;
		--ecx_17;
		if (ecx_17 == 0x00)
			break;
		*edi_32 = 0x2E;
		edi = edi_32 + 1;
	}
	return edi_32;
}

byte g_b8048910 = 0x00; // 08048910
byte g_b8048912 = 0x00; // 08048912
byte g_b8048913 = 0x00; // 08048913
byte g_b8048914 = 0x00; // 08048914
byte g_b8048915 = 0x00; // 08048915
byte g_b8048916 = 0x00; // 08048916
byte g_b8048917 = 0x00; // 08048917
byte g_b8048918 = 0x00; // 08048918
byte g_b8048919 = 0x00; // 08048919
byte g_b804891A = 0x00; // 0804891A
byte g_b804891B = 0x00; // 0804891B
Eq_434 g_a804991C[] = // 0804991C
	{
	};
word16 g_w8049922 = 0x00; // 08049922
Eq_578 g_a8049ACA[] = // 08049ACA
	{
	};
byte g_a8049AD0[] = // 08049AD0
	{
	};
byte g_b8049AE8 = 0x00; // 08049AE8
byte g_a8049B00[] = // 08049B00
	{
	};
Eq_461 g_a8049B0D[] = // 08049B0D
	{
	};
Eq_453 g_t8049B5D = // 08049B5D
	{
		0x00
	};
word32 g_dw8049B5E = 0x00; // 08049B5E
byte g_b8049B62 = 0x00; // 08049B62
ui32 g_dw8049B63 = 0x00; // 08049B63
