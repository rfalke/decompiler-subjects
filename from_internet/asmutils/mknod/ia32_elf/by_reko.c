// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Stack (ptr32 Eq_2) dwArg04, Stack (ptr32 Eq_3) dwArg08, Stack (ptr32 byte) dwArg0C)
void fn0804804C(struct Eq_2 * dwArg04, struct Eq_3 * dwArg08, byte * dwArg0C)
{
	ptr32 fp;
	ui32 esi_11 = sys_umask(0x00) ^ 0x01B6;
	struct Eq_2 * ebx_17 = dwArg04;
	do
		++ebx_17;
	while (ebx_17->b0000 != 0x00);
	int32 ebx_215;
	struct Eq_23 * esp_205;
	struct Eq_24 * esp_104;
	Eq_25 edx_185;
	Eq_26 ecx_140;
	struct Eq_3 * ebx_206;
	if (ebx_17->bFFFFFFFF == 111)
	{
		esp_104 = fp + 0x0C;
		ebx_206 = dwArg08;
		if (dwArg08 == null)
			goto l080480CD;
		if (dwArg08->b0000 == 0x6D2D)
		{
			byte * ebx_38 = dwArg08 + 2;
			if (dwArg08[2] == 0x00)
			{
				esp_104 = fp + 16;
				ebx_38 = dwArg0C;
				if (dwArg0C == null)
					goto l080480CD;
			}
			esi_11 = fn0804814F(ebx_38);
			struct Eq_3 * ebx_59 = esp_104->ptr0000;
			esp_104 = (struct Eq_24 *) &esp_104->ptr0004;
			ebx_206 = ebx_59;
			if (ebx_59 == null)
				goto l080480CD;
		}
l080480EF:
		edx_185.u0 = 0x00;
		ecx_140 = esi_11 | 0x1000;
		goto l08048117;
	}
	else
	{
		esp_104 = fp + 0x0C;
		ebx_206 = dwArg08;
		if (dwArg08 == null)
			goto l080480CD;
		if (dwArg08->b0000 == 0x6D2D)
		{
			byte * ebx_76 = dwArg08 + 2;
			if (dwArg08[2] == 0x00)
			{
				esp_104 = fp + 16;
				ebx_76 = dwArg0C;
				if (dwArg0C == null)
					goto l080480CD;
			}
			esi_11 = fn0804814F(ebx_76);
			struct Eq_3 * ebx_97 = esp_104->ptr0000;
			esp_104 = (struct Eq_24 *) &esp_104->ptr0004;
			ebx_206 = ebx_97;
			if (ebx_97 == null)
				goto l080480CD;
		}
		struct Eq_3 * ebp_106 = esp_104->ptr0000;
		esp_104 = (struct Eq_24 *) &esp_104->ptr0004;
		if (ebp_106 == null)
			goto l080480CD;
		ui32 ecx_129;
		if (ebp_106->b0000 != 0x62)
		{
			if (ebp_106->b0000 != 99 && ebp_106->b0000 != 117)
			{
				if (ebp_106->b0000 != 0x70)
					goto l080480CD;
				goto l080480EF;
			}
			ecx_129 = 0x2000;
		}
		else
			ecx_129 = 0x6000;
		ecx_140 = ecx_129 | esi_11;
		struct Eq_3 * ebp_145 = esp_104->ptr0000;
		esp_104 = (struct Eq_24 *) &esp_104->ptr0004;
		if (ebp_145 != null)
		{
			int32 eax_152 = fn08048167(ebp_145);
			struct Eq_3 * ebp_168 = esp_104->ptr0004;
			esp_104 = (struct Eq_24 *) ((char *) &esp_104->ptr0004 + 4);
			if (ebp_168 != null)
			{
				esp_104->ptr0004 = eax_152 << 0x08;
				esp_104 = (struct Eq_24 *) ((char *) &esp_104->ptr0004 + 4);
				edx_185 = esp_104->ptr0004 + fn08048167(ebp_168);
l08048117:
				word32 * esp_202 = esp_104 - 4;
				*esp_202 = 0x0E;
				esp_205 = (struct Eq_23 *) (esp_202 + 1);
				ebx_215 = sys_mknod(ebx_206, ecx_140, edx_185);
l0804811D:
				esp_205->dwFFFFFFFC = 0x01;
				sys_exit(ebx_215);
			}
		}
l080480CD:
		uint32 * esp_220 = esp_104 - 4;
		*esp_220 = 0x02;
		uint32 ebx_222 = *esp_220;
		*esp_220 = 0x04;
		sys_write(ebx_222, "Usage: mknod [-m mode] NAME TYPE MAJOR MINOR\n1\xC01\xF6\xB1\x03\x8A\x03C,0x\n<\b}\x06\xD3\xE6\t\xC6\xEB\xEF\xC3SQR1\xC01\xDB\x8A]", 0x2D);
		esp_205 = (struct Eq_23 *) (esp_220 + 1);
		ebx_215 = SEQ(SLICE(ebx_222, word24, 8), 0x01);
		goto l0804811D;
	}
}

char g_str8048122[] = "Usage: mknod [-m mode] NAME TYPE MAJOR MINOR\n1\xC01\xF6\xB1\x03\x8A\x03C,0x\n<\b}\x06\xD3\xE6\t\xC6\xEB\xEF\xC3SQR1\xC01\xDB\x8A]"; // 08048122
// 0804814F: Register ui32 fn0804814F(Register (ptr32 byte) ebx)
// Called from:
//      fn0804804C
ui32 fn0804814F(byte * ebx)
{
	ui32 esi_19 = 0x00;
	while (true)
	{
		ci8 al_12 = *ebx;
		++ebx;
		if (al_12 < 0x30)
			break;
		uint32 eax_23 = (uint32) (al_12 - 0x30);
		if (al_12 >= 0x38)
			return esi_19;
		esi_19 = esi_19 << 0x03 | eax_23;
	}
	return esi_19;
}

// 08048167: Register uint32 fn08048167(Register (ptr32 Eq_3) ebp)
// Called from:
//      fn0804804C
uint32 fn08048167(struct Eq_3 * ebp)
{
	uint32 eax_13 = 0x00;
	while (true)
	{
		ci8 bl_20 = ebp->b0000;
		++ebp;
		if (bl_20 < 0x30)
			break;
		uint32 ebx_45 = (uint32) (bl_20 - 0x30);
		if (bl_20 > 0x39)
			return eax_13;
		eax_13 = eax_13 * 0x0A + ebx_45;
	}
	return eax_13;
}

