// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Register (ptr32 Eq_2) ebx)
void fn0804804C(struct Eq_2 * ebx)
{
	g_b8048337 = 0x09;
	while (true)
	{
		struct Eq_2 ** esp_129;
		word32 eax_136;
		struct Eq_2 ** esp_12 = fp - 4;
		struct Eq_2 * ebp_124 = dwLoc08;
		if (dwLoc08 == null)
			break;
		if (dwLoc08->b0000 == 0x632D)
		{
			struct Eq_2 * ebp_19 = dwLoc08 + 2;
			if (dwLoc08[2] == 0x00)
			{
				ebp_19 = dwLoc04;
				if (dwLoc04 == null)
				{
					fn08048242();
					return;
				}
			}
			byte * ebp_33;
			ebx = fn08048298(ebp_19, out ebp_33);
			g_ptr8048439 = ebx;
			g_dw804843D = 0x01;
			if (*ebp_33 != 0x2D)
				continue;
			word32 ebp_375;
			int32 ebx_56 = fn08048298(ebp_33 + 1, out ebp_375) - g_ptr8048439;
			if (ebx_56 < 0x00)
			{
				fn08048242();
				return;
			}
			else
			{
				g_dw804843D = ebx_56 + 0x01;
				ebx = ebx_56 + 0x01;
				continue;
			}
		}
		if (dwLoc08->b0000 != 31277)
		{
			if (dwLoc08->b0000 != 25645)
			{
				if (dwLoc08->b0000 != 0x662D)
				{
					if (dwLoc08->b0000 == 0x2D2D)
					{
						esp_12 = fp;
						ebp_124 = dwLoc04;
						if (dwLoc04 == null)
							break;
					}
					esp_129 = fp;
					if (ebp_124->b0000 == 0x2D)
						goto l08048146;
					__syscall(0x80);
					ebx = ebp_124;
					eax_136 = 0x05;
					esp_129 = fp;
					goto l08048162;
				}
				g_b8048336 = 0x01;
				struct Eq_2 * ebp_101 = dwLoc08 + 2;
				if (dwLoc08[2] == 0x00)
				{
					ebp_101 = dwLoc04;
					if (dwLoc04 == null)
					{
						fn08048242();
						return;
					}
				}
				do
				{
					byte * ebp_105;
					ebx = fn08048298(ebp_101, out ebp_105);
					if (ebx <= (struct Eq_2 *) 0xFF)
						ebx[0x08048339] = (struct Eq_2) 0x01;
					ebp_101 = (struct Eq_2 *) (ebp_105 + 1);
				} while (*ebp_105 == 44);
				continue;
			}
			struct Eq_2 * ebp_68 = dwLoc08 + 2;
			if (dwLoc08[2] == 0x00)
			{
				ebp_68 = dwLoc04;
				if (dwLoc04 == null)
				{
					fn08048242();
					return;
				}
			}
			g_b8048337 = fn080482BC(ebp_68);
			continue;
		}
		g_b8048338 = 0x01;
	}
	esp_129 = esp_12 - 4;
	*esp_129 = (struct Eq_2 **) ebp_124;
l08048146:
	eax_136 = 0x00;
l08048162:
	g_dw8048441 = eax_136;
	byte * ebp_152 = &g_b8048C45;
	struct Eq_2 * edx_161 = ebx;
	while (true)
	{
l0804816E:
		struct Eq_2 * esi_163 = g_ptr8048439;
		if (esi_163 != null)
		{
			word32 esi_168 = esi_163 - (struct Eq_2 *) 0x01;
			if (esi_163 != (struct Eq_2 *) 0x01)
			{
				g_b8048335 = 0x00;
				do
				{
					if ((byte) fn08048246(edx_161, ebx, ebp_152, out edx_161, out ebx) == 0x0A)
						goto l0804816E;
					--esi_168;
				} while (esi_168 != 0x00);
			}
		}
		g_b8048335 = 0x00;
		struct Eq_92 * esi_193 = (struct Eq_92 *) 0x01;
		int32 edi_195 = g_dw804843D;
		do
		{
			word32 eax_199 = fn08048246(edx_161, ebx, ebp_152, out edx_161, out ebx);
			byte al_207 = (byte) eax_199;
			if (al_207 == 0x0A)
				goto l08048214;
			if (g_b8048336 != 0x00)
			{
				if (al_207 != g_b8048337)
				{
					if (esi_193 > (struct Eq_92 *) 0xFF)
						break;
					if (esi_193[0x08048339] == 0x00)
						goto l080481EA;
					if (g_b8048335 == 0x01)
					{
						word32 * esp_229 = esp_129 - 4;
						*esp_229 = eax_199;
						ebp_152 = fn08048275(g_b8048337, ebp_152);
						eax_199 = *esp_229;
					}
					goto l080481DE;
				}
				++esi_193;
				if (g_b8048338 != 0x01 && g_b8048335 == 0x02)
					g_b8048335 = 0x01;
			}
			else
			{
l080481DE:
				g_b8048335 = 0x02;
				ebp_152 = fn08048275((byte) eax_199, ebp_152);
			}
l080481EA:
			--edi_195;
		} while (edi_195 != 0x00);
		do
			eax_199 = fn08048246(edx_161, ebx, ebp_152, out edx_161, out ebx);
		while ((byte) eax_199 != 0x0A);
l08048214:
		ebp_152 = fn08048275((byte) eax_199, ebp_152);
	}
}

// 0804821E: Register word32 fn0804821E(Register (ptr32 byte) ebp, Register out ptr32 edxOut, Register out ptr32 ebxOut)
// Called from:
//      fn08048246
word32 fn0804821E(byte * ebp, ptr32 & edxOut, ptr32 & ebxOut)
{
	if (ebp != &g_b8048C45)
		__syscall(0x80);
	ptr32 ebx_27 = SEQ(g_n8048442, 0x00);
	word32 eax_23 = fn0804823D();
	edxOut = ebp - &g_b8048C45;
	ebxOut = ebx_27;
	return eax_23;
}

// 0804823D: Register word32 fn0804823D()
// Called from:
//      fn0804821E
//      fn08048242
word32 fn0804823D()
{
	__syscall(0x80);
	return fn08048242();
}

// 08048242: Register word32 fn08048242()
// Called from:
//      fn0804804C
//      fn0804823D
//      fn08048246
word32 fn08048242()
{
	fn0804823D();
	return <invalid>;
}

// 08048246: Register word32 fn08048246(Register (ptr32 Eq_2) edx, Register (ptr32 Eq_2) ebx, Register (ptr32 byte) ebp, Register out (ptr32 Eq_2) edxOut, Register out (ptr32 word16) ebxOut)
// Called from:
//      fn0804804C
word32 fn08048246(struct Eq_2 * edx, struct Eq_2 * ebx, byte * ebp, struct Eq_2 & edxOut, word16 & ebxOut)
{
	if (ebx >= edx)
	{
		__syscall(0x80);
		if (Test(ULT,false))
		{
			word16 * ebx_19;
			struct Eq_2 * edx_20;
			word32 eax_18 = fn0804821E(ebp, out edx_20, out ebx_19);
			edxOut = edx_20;
			ebxOut = ebx_19;
			return eax_18;
		}
		ebx = &g_t8048445;
		eax_24_8 = 0x08;
		edx = &g_t8048448;
	}
	word32 eax_53 = SEQ(eax_24_8, ebx->b0000);
	edxOut = edx;
	ebxOut = (word16 *) (ebx + 1);
	return eax_53;
}

// 08048275: Register (ptr32 byte) fn08048275(Register byte al, Register (ptr32 byte) ebp)
// Called from:
//      fn0804804C
byte * fn08048275(byte al, byte * ebp)
{
	byte al = (byte) eax;
	*ebp = al;
	if (ebp == &g_b8049444)
		__syscall(0x80);
	return ebp + 1;
}

// 08048298: Register uint32 fn08048298(Register (ptr32 Eq_2) ebp, Register out (ptr32 Eq_2) ebpOut)
// Called from:
//      fn0804804C
uint32 fn08048298(struct Eq_2 * ebp, struct Eq_2 & ebpOut)
{
	uint32 eax_19 = 0x00;
	while (true)
	{
		char cl_9 = ebp->b0000;
		if (cl_9 < 0x30)
			break;
		uint32 ecx_27 = (uint32) (cl_9 - 0x30);
		if (cl_9 > 0x39)
			break;
		++ebp;
		eax_19 = g_dw80482B8 * eax_19 + ecx_27;
	}
	ebpOut = ebp;
	return eax_19;
}

uint32 g_dw80482B8 = 0x0A; // 080482B8
// 080482BC: Register int8 fn080482BC(Register (ptr32 Eq_2) ebp)
// Called from:
//      fn0804804C
int8 fn080482BC(struct Eq_2 * ebp)
{
	int8 al_5 = ebp->b0000;
	if (al_5 != 0x5C)
		return al_5;
	al_5 = (int8) ebp[1];
	if (al_5 == 0x61)
		return 0x07;
	if (al_5 == 0x62)
		return 0x08;
	if (al_5 == 116)
		return 0x09;
	if (al_5 == 114)
		return 0x0D;
	if (al_5 == 110)
		return 0x0A;
	if (al_5 >= 0x30 && al_5 <= 55)
	{
		int8 ah_31 = al_5 - 0x30;
		char al_33 = ebp[2];
		if (al_33 >= 0x30 && al_33 <= 55)
		{
			ah_31 = al_5 - 0x30 << 0x03 ^ al_33 - 0x30;
			char al_42 = ebp[3];
			if (al_42 >= 0x30 && al_42 <= 55)
				ah_31 = ah_31 << 0x03 ^ al_42 - 0x30;
		}
		al_5 = ah_31;
	}
	return al_5;
}

byte g_b8048335 = 0x00; // 08048335
byte g_b8048336 = 0x00; // 08048336
byte g_b8048337 = 0x00; // 08048337
byte g_b8048338 = 0x00; // 08048338
struct Eq_2 * g_ptr8048439 = null; // 08048439
int32 g_dw804843D = 0; // 0804843D
word32 g_dw8048441 = 0x00; // 08048441
word24 g_n8048442 = 0x00; // 08048442
Eq_2 g_t8048445 = // 08048445
	{
		0x00,
		0,
		'\0',
		'\0',
		?? /* Can't read address 1009077E */ ,
	};
Eq_2 g_t8048448 = // 08048448
	{
		0x00,
		0,
		'\0',
		'\0',
		?? /* Can't read address 10090781 */ ,
	};
byte g_b8048C45 = 0x00; // 08048C45
byte g_b8049444 = 0x00; // 08049444
