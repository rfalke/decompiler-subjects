/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall __noreturn start(mode_t@<edx>, int@<ebx>);
// char __usercall sub_8048246@<al>(int@<edx>, char *@<ebx>);
// int __usercall sub_8048275@<eax>(int result@<eax>, char *@<ebp>);
// int __usercall sub_8048298@<eax>(int@<ebx>, _BYTE *@<ebp>);
// char __usercall sub_80482BC@<al>(char *@<ebp>);

//-------------------------------------------------------------------------
// Data declarations

int dword_80482B8 = 10; // weak
char byte_8048335; // weak
char byte_8048336; // weak
char byte_8048337; // weak
char byte_8048338; // weak
char byte_8048339[]; // weak
int dword_8048439; // weak
int dword_804843D; // weak
int fd; // idb
char byte_8048445[3]; // weak
char byte_8048C45[3]; // weak
char byte_8049444; // weak


//----- (0804804C) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(mode_t a1@<edx>, int a2@<ebx>)
{
  char *v2; // ebp
  _BYTE *v3; // ebp
  char *v4; // ebp
  _BYTE *v5; // ebp
  int v6; // eax
  int v7; // edx
  int v8; // esi
  int v9; // esi
  int v10; // edi
  int v11; // eax
  int v12; // eax
  char *v13; // [esp-8h] [ebp-8h]
  int v14; // [esp-8h] [ebp-8h]
  _BYTE *v15; // [esp-4h] [ebp-4h]

  byte_8048337 = 9;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v2 = v13;
          if ( !v13 )
            goto LABEL_25;
          if ( *(_WORD *)v13 != 25389 )
            break;
          v3 = v13 + 2;
          if ( !v13[2] )
          {
            v3 = v15;
            if ( !v15 )
              goto LABEL_50;
          }
          sub_8048298(a2, v3);
          dword_8048439 = a2;
          dword_804843D = 1;
          if ( *v3 == 45 )
          {
            sub_8048298(a2, v3 + 1);
            a2 -= dword_8048439;
            if ( a2 < 0 )
              goto LABEL_50;
            dword_804843D = ++a2;
          }
        }
        if ( *(_WORD *)v13 != 31277 )
          break;
        byte_8048338 = 1;
      }
      if ( *(_WORD *)v13 != 25645 )
        break;
      v4 = v13 + 2;
      if ( !v13[2] )
      {
        v4 = v15;
        if ( !v15 )
          goto LABEL_50;
      }
      byte_8048337 = sub_80482BC(v4);
    }
    if ( *(_WORD *)v13 != 26157 )
      break;
    byte_8048336 = 1;
    v5 = v13 + 2;
    if ( !v13[2] )
    {
      v5 = v15;
      if ( !v15 )
        goto LABEL_50;
    }
    do
    {
      sub_8048298(a2, v5);
      if ( a2 <= 255 )
        byte_8048339[a2] = 1;
      ++v5;
    }
    while ( *(v5 - 1) == 44 );
  }
  if ( *(_WORD *)v13 == 11565 && (v2 = v15) == 0 || *(_WORD *)v2 == 45 )
  {
LABEL_25:
    v6 = 0;
  }
  else
  {
    a2 = (int)v2;
    v6 = sys_open(v2, 0, a1);
    if ( v6 < 0 )
    {
LABEL_50:
      LOBYTE(a2) = 1;
      v12 = sys_exit(a2);
    }
  }
  fd = v6;
  v7 = a2;
LABEL_29:
  if ( dword_8048439 )
  {
    v8 = dword_8048439 - 1;
    if ( dword_8048439 != 1 )
    {
      byte_8048335 = 0;
      do
      {
        if ( sub_8048246(v7, (char *)a2) == 10 )
          goto LABEL_29;
        --v8;
      }
      while ( v8 );
    }
  }
  byte_8048335 = 0;
  v9 = 1;
  v10 = dword_804843D;
  while ( 1 )
  {
    LOBYTE(v11) = sub_8048246(v7, (char *)a2);
    if ( (_BYTE)v11 == 10 )
      goto LABEL_49;
    if ( byte_8048336 )
    {
      if ( (_BYTE)v11 == byte_8048337 )
      {
        ++v9;
        if ( byte_8048338 != 1 && byte_8048335 == 2 )
          byte_8048335 = 1;
        goto LABEL_43;
      }
      if ( v9 > 255 )
        goto LABEL_48;
      if ( !byte_8048339[v9] )
        goto LABEL_43;
      if ( byte_8048335 == 1 )
      {
        v14 = v11;
        LOBYTE(v11) = byte_8048337;
        sub_8048275(v11, byte_8048C45);
        v11 = v14;
      }
    }
    byte_8048335 = 2;
    sub_8048275(v11, byte_8048C45);
LABEL_43:
    if ( !--v10 )
    {
      do
LABEL_48:
        LOBYTE(v11) = sub_8048246(v7, (char *)a2);
      while ( (_BYTE)v11 != 10 );
LABEL_49:
      sub_8048275(v11, byte_8048C45);
      goto LABEL_29;
    }
  }
}
// 80480A6: positive sp value 10 has been found
// 8048055: variable 'v13' is possibly undefined
// 80480A5: variable 'v15' is possibly undefined
// 8048158: variable 'a1' is possibly undefined
// 8048182: variable 'v7' is possibly undefined
// 80481D2: variable 'v11' is possibly undefined
// 8048335: using guessed type char byte_8048335;
// 8048336: using guessed type char byte_8048336;
// 8048337: using guessed type char byte_8048337;
// 8048338: using guessed type char byte_8048338;
// 8048439: using guessed type int dword_8048439;
// 804843D: using guessed type int dword_804843D;

//----- (08048246) --------------------------------------------------------
char __usercall sub_8048246@<al>(int a1@<edx>, char *a2@<ebx>)
{
  if ( (int)a2 >= a1 )
  {
    if ( !sys_read(fd, byte_8048445, 0x800u) )
      JUMPOUT(0x804821E);
    a2 = byte_8048445;
  }
  return *a2;
}
// 8048263: control flows out of bounds to 804821E

//----- (08048275) --------------------------------------------------------
int __usercall sub_8048275@<eax>(int result@<eax>, char *a2@<ebp>)
{
  *a2 = result;
  if ( a2 == &byte_8049444 )
    return sys_write(1, byte_8048C45, 0x800u);
  return result;
}
// 8049444: using guessed type char byte_8049444;

//----- (08048298) --------------------------------------------------------
int __usercall sub_8048298@<eax>(int a1@<ebx>, _BYTE *a2@<ebp>)
{
  int v2; // eax
  int i; // ecx

  v2 = 0;
  for ( i = 0; ; v2 = i + dword_80482B8 * v2 )
  {
    LOBYTE(i) = *a2 - 48;
    if ( *a2 < 0x30u || (char)i > 9 )
      break;
    ++a2;
  }
  return a1;
}
// 80482B8: using guessed type int dword_80482B8;

//----- (080482BC) --------------------------------------------------------
char __usercall sub_80482BC@<al>(char *a1@<ebp>)
{
  char result; // al
  char *v2; // ebp
  char v3; // ah
  _BYTE *v4; // ebp
  char v5; // al
  _BYTE *v6; // ebp
  char v7; // al

  result = *a1;
  v2 = a1 + 1;
  if ( result == 92 )
  {
    result = *v2;
    if ( *v2 == 97 )
    {
      return 7;
    }
    else
    {
      switch ( result )
      {
        case 'b':
          return 8;
        case 't':
          return 9;
        case 'r':
          return 13;
        case 'n':
          return 10;
        default:
          if ( result >= 48 && result <= 55 )
          {
            v3 = result - 48;
            v4 = v2 + 1;
            v5 = *v4 - 48;
            if ( *v4 >= 0x30u && v5 <= 7 )
            {
              v6 = v4 + 1;
              v3 = v5 ^ (8 * v3);
              v7 = *v6 - 48;
              if ( *v6 >= 0x30u && v7 <= 7 )
                return v7 ^ (8 * v3);
            }
            return v3;
          }
          break;
      }
    }
  }
  return result;
}

// nfuncs=5 queued=5 decompiled=5 lumina nreq=0 worse=0 better=0
// ALL OK, 5 function(s) have been successfully decompiled
