// subject_seg08048000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Stack word32 dwArg00, Stack (ptr32 Eq_3) dwArg08, Stack (ptr32 Eq_4) dwArg0C)
void fn0804804C(word32 dwArg00, struct Eq_3 * dwArg08, struct Eq_4 * dwArg0C)
{
	byte * ecx_111;
	g_t804818F.u2 = 0x0A;
	struct Eq_4 * esi_19 = &g_t804804D;
	word32 * esp_104 = fp + 4;
	if (dwArg00 != 0x01)
	{
		esp_104 = fp + 0x0C;
		if (dwArg08->b0000 != 0x2D)
		{
l0804808D:
			int32 * esp_50 = esp_104 - 4;
			*esp_50 = 0x05;
			int32 eax_52 = *esp_50;
			__syscall(0x80);
			ecx_111 = null;
			esp_104 = esp_50 + 1;
			if (eax_52 < 0x00)
				goto l08048111;
			goto l0804809E;
		}
		esi_19 = (struct Eq_4 *) &dwArg08->b0001;
		if (dwArg08->b0001 == 110)
		{
			esi_19 = dwArg0C;
			esp_104 = fp + 16;
		}
		Eq_6 ebx_221 = 0x00;
		while (true)
		{
			char al_30 = esi_19->b0000;
			++esi_19;
			if (al_30 < 0x30)
				break;
			uint32 eax_220 = (uint32) (al_30 - 0x30);
			if (al_30 > 0x39)
				break;
			ebx_221 = ebx_221 *s 0x0A + eax_220;
		}
		g_t804818F = ebx_221;
		++esp_104;
		if (*esp_104 != 0x00)
			goto l0804808D;
	}
l0804809E:
	word32 * esp_64 = esp_104 - 4;
	*esp_64 = 0x6C;
	__syscall(0x80);
	if ((g_dw805419B & 0x8000) != 0x00 && g_dw80541A7 > 0x4000)
	{
		*esp_64 = 0x13;
		__syscall(0x80);
	}
	ecx_111 = &g_b8048193;
	if (esi_19->bFFFFFFFF != 99)
	{
		do
		{
			struct Eq_89 * esp_146 = esp_104 - 4;
			esp_146->dw0000 = 0x03;
			int32 eax_148 = esp_146->dw0000;
			__syscall(0x80);
			esp_104 = (word32 *) (&esp_146->dw0000 + 1);
			if (eax_148 < 0x00)
				goto l08048111;
			if (eax_148 == 0x00)
				goto l08048116;
			ecx_111 += eax_148;
		} while (ecx_111 <= &g_b8050193);
		esp_146->dw0000 = 0x080480DA;
		esp_146->ptrFFFFFFFC = ecx_111;
		fn08048107(ecx_111 - 0x0804C193, &g_b804C193, &g_b8048193, esp_146->ptrFFFFFFFC);
		return;
	}
	ecx_111 = &g_b8048193;
	while (true)
	{
		int32 * esp_101 = esp_104 - 4;
		*esp_101 = 0x03;
		int32 eax_103 = *esp_101;
		__syscall(0x80);
		esp_104 = esp_101 + 1;
		if (eax_103 < 0x00)
			break;
		if (eax_103 == 0x00)
		{
			ecx_111 -= g_t804818F;
			if (ecx_111 < &g_b8048193)
				ecx_111 = &g_b8048193;
			*esp_101 = 0x01;
			*esp_101 = 0x04;
			__syscall(0x80);
			esp_104 = esp_101 + 1;
			break;
		}
		ecx_111 += eax_103;
		if (ecx_111 >= &g_b8050193)
			ecx_111 = fn080480FA(ecx_111);
	}
l08048111:
	while (true)
	{
l08048111:
		word32 * esp_193 = esp_104 - 4;
		*esp_193 = 0x01;
		__syscall(0x80);
		esp_104 = esp_193 + 1;
l08048116:
		if (ecx_111 != &g_b8048193)
		{
			word32 ebx_160 = (word32) g_t804818F + 1;
			--ecx_111;
			while (true)
			{
				--ebx_160;
				if (ebx_160 == 0x00)
					break;
				do
				{
					--ecx_111;
					if (ecx_111 == &g_b8048193)
						goto l0804813C;
				} while (*ecx_111 != 0x0A);
			}
			++ecx_111;
l0804813C:
			word32 * esp_183 = esp_104 - 4;
			*esp_183 = 0x01;
			*esp_183 = 0x04;
			__syscall(0x80);
			esp_104 = esp_183 + 1;
		}
	}
}

Eq_4 g_t804804D = // 0804804D
	{
		~0x41,
		77,
	};
// 080480FA: Register (ptr32 byte) fn080480FA(Register (ptr32 byte) ecx)
// Called from:
//      fn0804804C
byte * fn080480FA(byte * ecx)
{
	return fn08048107(ecx - 0x0804C193, &g_b804C193, &g_b8048193, ecx);
}

// 08048107: Register ptr32 fn08048107(Register ptr32 ecx, Register (ptr32 byte) esi, Register (ptr32 byte) edi, Stack (ptr32 byte) dwArg00)
// Called from:
//      fn0804804C
//      fn080480FA
ptr32 fn08048107(ptr32 ecx, byte * esi, byte * edi, byte * dwArg00)
{
	for (; ecx != 0x00; --ecx)
	{
		*edi = *esi;
		++esi;
		++edi;
	}
	return dwArg00 - 0x4000;
}

Eq_6 g_t804818F = // 0804818F
	{
		0
	};
byte g_b8048193 = 0x00; // 08048193
byte g_b804C193 = 0x00; // 0804C193
byte g_b8050193 = 0x00; // 08050193
ui32 g_dw805419B = 0x00; // 0805419B
up32 g_dw80541A7 = 0x00; // 080541A7
