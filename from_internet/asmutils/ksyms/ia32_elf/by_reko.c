// subject_seg08048000_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804804C: void fn0804804C(Stack ci8 bArg00, Stack (ptr32 word16) dwArg08, Stack (ptr32 byte) dwArg0C)
void fn0804804C(ci8 bArg00, word16 * dwArg08, byte * dwArg0C)
{
	if (bArg00 >= 0x02)
	{
		if (*dwArg08 == 22061)
		{
			fn0804824A(&g_b804826B);
			goto l080480E8;
		}
		if (*dwArg08 != 26669)
			fn0804824A(&g_b8048281);
		if (*dwArg08 == 0x6F2D)
		{
			if (bArg00 < 0x03)
				fn080480F1(null);
			else
				fn080480F1(dwArg0C);
			goto l080480E8;
		}
	}
	__syscall(0x80);
	word32 ecx_44 = g_dw80A82CE;
	byte * esi_45 = &g_b80482CA;
	do
	{
		fn080480F1(esi_45);
		do
		{
			esi_45 = esi_154 + 1;
			esi_154 = esi_45;
		} while (*esi_154 != 0x00);
		--ecx_44;
	} while (ecx_44 != 0x00);
	if (*dwArg08 == 24877)
		fn080480F1(null);
l080480E8:
}

// 080480F1: void fn080480F1(Register (ptr32 byte) esi)
// Called from:
//      fn0804804C
void fn080480F1(byte * esi)
{
	__syscall(0x80);
	word32 ecx_173 = g_dw80A82CA;
	struct Eq_79 * dwLoc0C_259 = g_a80882CA;
	do
	{
		fn08048214(dwLoc0C_259->dw0000, 0x10, &g_t80682CA);
		__syscall(0x80);
		fn0804824A(&g_b80482C3);
		word32 eax_93 = fn0804824A(dwLoc0C_259->dw0004 + 0x080882CA);
		if (esi != null)
		{
			up32 ecx_105 = 0x20 - eax_93;
			if (ecx_105 > 0x00)
			{
				do
				{
					fn0804824A(&g_b80482C1);
					--ecx_105;
				} while (ecx_105 != 0x00);
			}
			fn0804824A(&g_b80482C3);
			fn0804824A(&g_b80482C6);
			fn0804824A(esi);
			fn0804824A(&g_b80482C8);
		}
		fn0804824A(&g_b80482BF);
		++dwLoc0C_259;
		--ecx_173;
	} while (ecx_173 != 0x01);
}

// 08048214: void fn08048214(Register uint32 eax, Register uint32 ecx, Register (ptr32 Eq_118) edi)
// Called from:
//      fn080480F1
void fn08048214(uint32 eax, uint32 ecx, struct Eq_118 * edi)
{
	byte cl_20 = (byte) ecx;
	struct Eq_118 * edi_9 = fn0804822C(eax, ecx, edi);
	edi_9->b0000 = 0x09;
	if (cl_20 == 0x10 && (byte) edi - ((byte) edi_9 + 0x01) > ~0x06)
		edi_9->b0001 = 0x09;
}

// 0804822C: Register (ptr32 Eq_118) fn0804822C(Register uint32 eax, Register uint32 ecx, Register (ptr32 Eq_118) edi)
// Called from:
//      fn08048214
//      fn0804822C
struct Eq_118 * fn0804822C(uint32 eax, uint32 ecx, struct Eq_118 * edi)
{
	uint64 edx_eax_5 = (uint64) eax;
	uint32 edx_8 = (uint32) (edx_eax_5 % ecx);
	byte dl_23 = (byte) edx_8;
	uint32 eax_9 = (uint32) (edx_eax_5 /u ecx);
	if (eax_9 != 0x00)
	{
		edi = fn0804822C(eax_9, ecx, edi);
		dl_23 = (byte) edx_8;
	}
	ci8 dl_26 = dl_23 + 0x30;
	if (dl_26 > 0x39)
		dl_26 += 0x27;
	edi->b0000 = dl_26;
	return &edi->b0001;
}

// 0804824A: Register word32 fn0804824A(Register (ptr32 byte) esi)
// Called from:
//      fn0804804C
//      fn080480F1
word32 fn0804824A(byte * esi)
{
	if (esi != null)
	{
		word32 ecx_12 = 0x00;
		while (true)
		{
			++esi;
			if (*esi == 0x00)
				break;
			++ecx_12;
		}
		__syscall(0x80);
		eax = ecx_12;
	}
	return eax;
}

byte g_b804826B = 0x68; // 0804826B
byte g_b8048281 = 0x41; // 08048281
byte g_b80482BF = 0x0A; // 080482BF
byte g_b80482C1 = 0x20; // 080482C1
byte g_b80482C3 = 0x20; // 080482C3
byte g_b80482C6 = 0x5B; // 080482C6
byte g_b80482C8 = 0x5D; // 080482C8
byte g_b80482CA = 0x00; // 080482CA
// subject_seg08048000_0002.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_118 g_t80682CA = // 080682CA
	{
		0x00,
		0x00,
	};
// subject_seg08048000_0004.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_210 g_a80882CA[] = // 080882CA
	{
	};
// subject_seg08048000_0006.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw80A82CA = 0x00; // 080A82CA
word32 g_dw80A82CE = 0x00; // 080A82CE
