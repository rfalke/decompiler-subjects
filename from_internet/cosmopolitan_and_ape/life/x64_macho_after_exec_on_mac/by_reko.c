// subject_DATA_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_5 g_t403000 = // 0000000000403000
	{
		~0x30
	};
word64 g_qw403008 = 0x200000003; // 0000000000403008
uint64 g_a403018[3] = // 0000000000403018
	{
		0x01,
		0x4800000019,
		0x455A454741505F5F,
	};
word64 g_qw403030 = 20306; // 0000000000403030
struct Eq_8 * g_ptr403040 = &g_t200000; // 0000000000403040
ui32 g_dw40335C = 0x5C305C30; // 000000000040335C
// subject_DATA_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr402008 = null; // 0000000000402008
<anonymous> * g_a402010[] = // 0000000000402010
	{
	};
// subject_TEXT_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401245: void fn0000000000401245(Stack word32 dwArg00)
void fn0000000000401245(word32 dwArg00)
{
	ptr64 rsp_106 = fp;
	g_t403000.u0 = 0x08;
	struct Eq_8 * r13_5 = fp + 0x08;
	<anonymous> * r14_6 = fp + 0x18;
	word64 * rdi_10 = g_a402010;
	uint64 rcx_113;
	for (rcx_113 = 0x08; rcx_113 != 0x00; --rcx_113)
	{
		*rdi_10 = 0x00401214;
		++rdi_10;
	}
	uint64 rcx_24 = 0xFFFFFFFF;
	word64 * rdi_128 = fp + 0x18;
	while (rcx_24 != 0x00)
	{
		++rdi_128;
		--rcx_24;
		if (*rdi_128 != 0x00)
			break;
	}
	__align(fp);
	fn0000000000401297(rdi_128);
	g_dw40335C |= 0x01;
	<anonymous> ** rax_107 = &g_ptr402008;
	<anonymous> ** rcx_103 = &g_ptr402008;
	while (rcx_103 != rax_107)
	{
		struct Eq_70 * rsp_85 = rsp_106 - 8;
		rsp_85->ptr0000 = rax_107;
		rsp_85->ptrFFFFFFF8 = rcx_103;
		struct Eq_79 * rsp_89;
		(*rax_107)();
		rcx_103 = rsp_89->ptr0000;
		rsp_106 = &rsp_89->qw0008 + 1;
		rax_107 = rsp_89->qw0008 + 0x08;
	}
	fn000000000040139B(r14_6, fn000000000040134D(), r13_5);
}

// 0000000000401297: void fn0000000000401297(Register (ptr64 word64) r15)
// Called from:
//      fn0000000000401245
void fn0000000000401297(word64 * r15)
{
	byte * rsi_105;
	Eq_5 qwLoc20_184;
	if ((g_t403000 & 0x08) == 0x00)
	{
		if ((g_t403000 & 0x20) == 0x00)
		{
			if ((g_t403000 & 0x04) == 0x00)
			{
				if (*r15 != 0x00)
				{
					rsi_105 = &g_b401EED;
					qwLoc20_184.u1 = 0x01;
				}
				else
				{
					rsi_105 = &g_b401EF1;
					qwLoc20_184.u1 = 0x2A00000010;
				}
			}
			else
			{
				rsi_105 = &g_b401EF5;
				qwLoc20_184.u1 = 0x2200000004;
			}
		}
		else
		{
			rsi_105 = &g_b401EE9;
			qwLoc20_184.u1 = 0x3000000020;
		}
	}
	else
	{
		rsi_105 = &g_b401EF8;
		qwLoc20_184.u1 = 0x4500000008;
	}
	g_t403000 = qwLoc20_184;
	g_qw403008 = 0x00803885;
	word64 * rdi_148 = g_a403018;
	uint64 rax_138 = 0x00803885;
	while (true)
	{
		word56 rax_56_8_163 = SLICE(rax_138, word56, 8);
		if (rdi_148 >= &g_qw403030)
			break;
		uint64 rdx_101 = 0x00;
		Eq_140 ecx_225 = 0x00;
		do
		{
			ecx_225.u0 = (uint64) ((word64) ecx_225 + 7);
			ci8 al_107 = *rsi_105;
			++rsi_105;
			byte cl_132 = (byte) ecx_225;
			rdx_101 |= (uint64) ((word32) SEQ(rax_56_8_163, al_107) & 0x7F) << (byte) ecx_225;
		} while (al_107 < 0x00);
		if ((al_107 & 0x40) != 0x00)
			rdx_101 |= ~0x00 << cl_132;
		rax_138 = rdx_101;
		if (*rdi_148 != 0x00)
			rax_138 = *rdi_148;
		*rdi_148 = rax_138;
		++rdi_148;
	}
}

// 000000000040134D: Register word32 fn000000000040134D()
// Called from:
//      fn0000000000401245
word32 fn000000000040134D()
{
	return 0x2A;
}

// 000000000040139B: void fn000000000040139B(Register (ptr64 code) rdx, Register word32 edi, Register (ptr64 Eq_8) r13)
// Called from:
//      fn0000000000401245
void fn000000000040139B(<anonymous> * rdx, word32 edi, struct Eq_8 * r13)
{
	fn0000000000401907(rdx, 0x00, r13);
	fn0000000000401AA1((byte) edi);
}

// 0000000000401907: void fn0000000000401907(Register (ptr64 code) rdx, Register uint64 rdi, Register (ptr64 Eq_8) r13)
// Called from:
//      fn000000000040139B
void fn0000000000401907(<anonymous> * rdx, uint64 rdi, struct Eq_8 * r13)
{
	ptr64 rbp_133 = fp - 8;
	uint64 r12_135 = rdi;
	struct Eq_8 ** rbx_137 = &g_ptr403040;
	while (true)
	{
l000000000040191B:
		struct Eq_8 * rdi_24 = *rbx_137;
		if (rdi_24 == null)
			break;
l0000000000401928:
		uint64 rax_102 = (uint64) rdi_24->dw0000;
		do
		{
			word32 eax_88 = (word32) rax_102;
			if (rax_102 == 0x00)
			{
				r13 = rdi_24->ptr0008;
				if (r12_135 != 0x00)
				{
					if (r13 == null)
						return;
					rdi_24 = r13;
					goto l0000000000401928;
				}
				else
				{
					if (r13 != null && 0x00 != 0x00)
					{
						word64 rsi_80;
						word64 rcx_82;
						word64 r8_83;
						fn0000000000000000();
					}
					*rbx_137 = (struct Eq_8 **) r13;
					goto l000000000040191B;
				}
			}
			word32 ecx_89 = __bsf(eax_88);
			rdx = (uint64) ~(0x01 << (byte) ecx_89);
			Eq_225 rcx_98 = (uint64) ecx_89;
			ui32 edx_114 = (word32) rdx;
			rax_102 &= rdx;
			if (r12_135 != 0x00 && ((rdi_24->a0020))[rcx_98].qw0000 != r12_135)
				continue;
			rdi_24->dw0000 &= edx_114;
			struct Eq_240 * rcx_118 = rdi_24 + (rcx_98 *s 0x18) /64 32;
			rdx = rcx_118->ptr0010;
		} while (rdx == null);
		word64 rsi_139;
		word64 rcx_141;
		word64 r8_142;
		rdx();
	}
}

// 0000000000401AA1: void fn0000000000401AA1(Register byte dil)
// Called from:
//      fn000000000040139B
void fn0000000000401AA1(byte dil)
{
	g_dw40335C |= 0x04;
	if ((g_t403000 & 0x04) == 0x00)
	{
		__syscall();
		__cli();
		__lidt(g_n401AD2);
		__hlt();
	}
	else
	{
		while (true)
			g_a402010[0]();
	}
}

word48 g_n401AD2 = ;
byte g_b401EE9 = 0x0C; // 0000000000401EE9
byte g_b401EED = 0x0C; // 0000000000401EED
byte g_b401EF1 = 0x0C; // 0000000000401EF1
byte g_b401EF5 = 0x0E; // 0000000000401EF5
byte g_b401EF8 = 0x0C; // 0000000000401EF8
