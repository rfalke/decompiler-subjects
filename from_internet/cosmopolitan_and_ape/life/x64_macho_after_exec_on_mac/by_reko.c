// subject_DATA_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_4 g_t403000 = // 0000000000403000
	{
		~0x30
	};
word64 g_qw403008 = 0x200000003; // 0000000000403008
uint64 g_a403018[3] = // 0000000000403018
	{
		0x01,
		0x4800000019,
		0x455A454741505F5F,
	};
word64 g_qw403030 = 20306; // 0000000000403030
struct Eq_190 * g_ptr403040 = &g_t200000; // 0000000000403040
ui32 g_dw40335C = 0x5C305C30; // 000000000040335C
// subject_DATA_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr402008 = null; // 0000000000402008
<anonymous> * g_a402010[] = // 0000000000402010
	{
	};
// subject_TEXT_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401245: void fn0000000000401245()
void fn0000000000401245()
{
	ptr64 fp;
	ptr64 rsp_104 = fp;
	g_t403000.u0 = 0x08;
	word64 * rdi_10 = g_a402010;
	uint64 rcx_111;
	for (rcx_111 = 0x08; rcx_111 != 0x00; --rcx_111)
	{
		*rdi_10 = 0x00401214;
		++rdi_10;
	}
	uint64 rcx_24 = 0xFFFFFFFF;
	word64 * rdi_122 = fp + 24;
	while (rcx_24 != 0x00)
	{
		++rdi_122;
		--rcx_24;
		if (*rdi_122 != 0x00)
			break;
	}
	__align_stack<word64>(fp);
	fn0000000000401297(rdi_122);
	g_dw40335C |= 0x01;
	<anonymous> ** rax_105 = &g_ptr402008;
	<anonymous> ** rcx_101 = &g_ptr402008;
	while (rcx_101 != rax_105)
	{
		struct Eq_61 * rsp_89 = rsp_104 - 8;
		rsp_89->ptr0000 = rax_105;
		rsp_89->ptrFFFFFFF8 = rcx_101;
		struct Eq_70 * rsp_93;
		(*rax_105)();
		rcx_101 = rsp_93->ptr0000;
		rsp_104 = &rsp_93->qw0008 + 1;
		rax_105 = rsp_93->qw0008 + 0x08;
	}
	fn000000000040139B(fn000000000040134D());
}

// 0000000000401297: void fn0000000000401297(Register (ptr64 word64) r15)
// Called from:
//      fn0000000000401245
void fn0000000000401297(word64 * r15)
{
	byte * rsi_110;
	Eq_4 qwLoc20_192;
	if ((g_t403000.u0 & 0x08) == 0x00)
	{
		if ((g_t403000.u0 & 0x20) == 0x00)
		{
			if ((g_t403000.u0 & 0x04) == 0x00)
			{
				if (*r15 != 0x00)
				{
					rsi_110 = &g_b401EED;
					qwLoc20_192.u1 = 0x01;
				}
				else
				{
					rsi_110 = &g_b401EF1;
					qwLoc20_192.u1 = 0x2A00000010;
				}
			}
			else
			{
				rsi_110 = &g_b401EF5;
				qwLoc20_192.u1 = 0x2200000004;
			}
		}
		else
		{
			rsi_110 = &g_b401EE9;
			qwLoc20_192.u1 = 0x3000000020;
		}
	}
	else
	{
		rsi_110 = &g_b401EF8;
		qwLoc20_192.u1 = 0x4500000008;
	}
	g_t403000.u1 = (word64) qwLoc20_192;
	g_qw403008 = 0x00803885;
	word64 * rdi_156 = g_a403018;
	uint64 rax_146 = 0x00803885;
	while (true)
	{
		word56 rax_56_8_171 = SLICE(rax_146, word56, 8);
		if (rdi_156 >= &g_qw403030)
			break;
		uint64 rdx_105 = 0x00;
		Eq_131 ecx_241 = 0x00;
		do
		{
			ecx_241.u0 = (uint64) ((word64) ecx_241 + 7);
			ci8 al_112 = *rsi_110;
			++rsi_110;
			byte cl_139 = (byte) ecx_241;
			rdx_105 |= (uint64) ((word32) SEQ(rax_56_8_171, al_112) & 0x7F) << (byte) ecx_241;
		} while (al_112 < 0x00);
		if ((al_112 & 0x40) != 0x00)
			rdx_105 |= ~0x00 << cl_139;
		rax_146 = rdx_105;
		if (*rdi_156 != 0x00)
			rax_146 = *rdi_156;
		*rdi_156 = rax_146;
		++rdi_156;
	}
}

// 000000000040134D: Register word32 fn000000000040134D()
// Called from:
//      fn0000000000401245
word32 fn000000000040134D()
{
	return 0x2A;
}

// 000000000040139B: void fn000000000040139B(Register word32 edi)
// Called from:
//      fn0000000000401245
void fn000000000040139B(word32 edi)
{
	fn0000000000401907(0x00);
	fn0000000000401AA1((byte) edi);
}

// 0000000000401907: void fn0000000000401907(Register uint64 rdi)
// Called from:
//      fn000000000040139B
void fn0000000000401907(uint64 rdi)
{
	while (true)
	{
l000000000040191B:
		struct Eq_190 * rdi_24 = g_ptr403040;
		if (rdi_24 == null)
			break;
l0000000000401928:
		uint64 rax_104 = (uint64) rdi_24->dw0000;
		do
		{
			word32 eax_90 = (word32) rax_104;
			if (rax_104 == 0x00)
			{
				struct Eq_190 * r13_46 = rdi_24->ptr0008;
				if (rdi != 0x00)
				{
					if (r13_46 == null)
						return;
					rdi_24 = r13_46;
					goto l0000000000401928;
				}
				else
				{
					if (r13_46 != null && null != 0x00)
						fn0000000000000000();
					g_ptr403040 = r13_46;
					goto l000000000040191B;
				}
			}
			word32 ecx_91 = __bsf<word32>(eax_90);
			uint64 rdx_103 = (uint64) ~(0x01 << (byte) ecx_91);
			Eq_209 rcx_100 = (uint64) ecx_91;
			ui32 edx_117 = (word32) rdx_103;
			rax_104 &= rdx_103;
			if (rdi != 0x00 && ((rdi_24->a0020))[rcx_100].qw0000 != rdi)
				continue;
			rdi_24->dw0000 &= edx_117;
			struct Eq_224 * rcx_121 = rdi_24 + (rcx_100 *s 0x18) /64 32;
			<anonymous> * rdx_122 = rcx_121->ptr0010;
		} while (rdx_122 == null);
		word64 rsi_139;
		word64 rcx_141;
		word64 r8_142;
		rdx_122();
	}
}

// 0000000000401AA1: void fn0000000000401AA1(Register byte dil)
// Called from:
//      fn000000000040139B
void fn0000000000401AA1(byte dil)
{
	g_dw40335C |= 0x04;
	if ((g_t403000.u0 & 0x04) == 0x00)
	{
		__syscall();
		__cli();
		__lidt<word48>(g_n401AD2);
		__halt();
	}
	else
	{
		while (true)
			g_a402010[0]();
	}
}

word48 g_n401AD2 = ;
byte g_b401EE9 = 0x0C; // 0000000000401EE9
byte g_b401EED = 0x0C; // 0000000000401EED
byte g_b401EF1 = 0x0C; // 0000000000401EF1
byte g_b401EF5 = 0x0E; // 0000000000401EF5
byte g_b401EF8 = 0x0C; // 0000000000401EF8
