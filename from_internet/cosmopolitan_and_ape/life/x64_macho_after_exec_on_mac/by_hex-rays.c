/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __fastcall sub_400675(unsigned __int8 a1, unsigned __int16 a2);
__int64 __fastcall sub_400748(int, int);
__int64 __fastcall sub_4010FB(unsigned __int64, int, __int64, __int64 *);
__int64 sub_401214();
char *__fastcall sub_401297();
__int64 sub_40134D();
__int64 __fastcall sub_401601(unsigned __int16 **);
unsigned __int64 __fastcall sub_40162C(__int64, unsigned int);
__int64 __fastcall sub_40165C(unsigned __int16 *, unsigned __int64, __int64, __int64, unsigned __int64);
__int64 __fastcall sub_401907(__int64, __int64, __int64);
__int64 __fastcall sub_40199D(); // weak
__int64 __fastcall sub_4019FA(__int64, _DWORD *);
__int64 __fastcall sub_401A09(__int64);
__int64 __fastcall sub_401A3C(__int64, _DWORD *);
void __fastcall __noreturn sub_401AA1(__int64, __int64, __int64);
void __fastcall sub_401EF8(__int64 a1, __int64 a2, __int64 a3, __int64 a4);

//-------------------------------------------------------------------------
// Data declarations

char byte_401AD2[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char byte_401AF7[2] = { '\x01', '\xC0' }; // weak
char byte_401EE9[4] = { '\f', '\xCE', '\0', '\x01' }; // weak
char byte_401EED[3] = { '\f', '&', '\xE7' }; // weak
char byte_401EF1[4] = { '\f', '\xCE', '\0', '\x01' }; // weak
char byte_401EF5[3] = { '\x0E', '\x01', '\x7F' }; // weak
__int64 (__fastcall *qword_402010)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x1DE8LL; // weak
int dword_403000; // weak
int dword_403018; // weak
int dword_403020; // weak
int dword_403030[4]; // weak
__int64 qword_403040; // weak
int dword_403358; // weak
int dword_40335C; // weak


//----- (0000000000400675) ----------------------------------------------------
void __fastcall sub_400675(unsigned __int8 a1, unsigned __int16 a2)
{
  unsigned __int8 v2; // al

  while ( 1 )
  {
    v2 = __inbyte(a2 + 5);
    if ( (v2 & 0x20) != 0 )
      break;
    _mm_pause();
  }
  __outbyte(a2, a1);
}

//----- (0000000000400748) ----------------------------------------------------
__int64 __fastcall sub_400748(int a1, int a2)
{
  qmemcpy((void *)(a1 & 0xFFFF8000), (const void *)(unsigned int)(a1 - a2), a1 - a2 - (a1 & 0xFFFF8000));
  return (unsigned int)(a1 - a2);
}

//----- (00000000004010FB) ----------------------------------------------------
__int64 __fastcall sub_4010FB(unsigned __int64 a1, int a2, __int64 a3, __int64 *a4)
{
  char i; // cl
  __int64 v6; // rax
  __int64 *v8; // rdx
  __int64 v9; // rax

  for ( i = 39; ; i -= 9 )
  {
    --a2;
    v6 = (a1 >> i) & 0x1FF;
    if ( a2 == -1 )
      break;
    v8 = (__int64 *)(a3 + 8 * v6);
    if ( !*v8 )
    {
      v9 = *a4 - 4096;
      *a4 = v9;
      *v8 = v9 | 3;
    }
    a3 = *v8 & 0x3FFFFFFFFF000LL;
  }
  return a3 + 8 * v6;
}

//----- (0000000000401214) ----------------------------------------------------
__int64 sub_401214()
{
  return 0LL;
}

//----- (0000000000401245) ----------------------------------------------------
#error "401245: function frame is wrong (funcsize=0)"

//----- (0000000000401297) ----------------------------------------------------
char *__fastcall sub_401297()
{
  _QWORD *v0; // r15
  char *v1; // rsi
  char *result; // rax
  char **i; // rdi
  char v4; // cl
  unsigned __int64 v5; // rdx
  char v6; // al
  unsigned __int64 v7; // r8
  __int64 v8; // [rsp-18h] [rbp-20h]
  __int64 v9; // [rsp-10h] [rbp-18h]

  if ( (dword_403000 & 8) != 0 )
  {
    v9 = 69LL;
    v8 = 8LL;
    v1 = (char *)sub_401EF8;
  }
  else if ( (dword_403000 & 0x20) != 0 )
  {
    v9 = 48LL;
    v8 = 32LL;
    v1 = byte_401EE9;
  }
  else if ( (dword_403000 & 4) != 0 )
  {
    v9 = 34LL;
    v8 = 4LL;
    v1 = byte_401EF5;
  }
  else if ( *v0 )
  {
    v9 = 0LL;
    v8 = 1LL;
    v1 = byte_401EED;
  }
  else
  {
    v9 = 42LL;
    v8 = 16LL;
    v1 = byte_401EF1;
  }
  *(_QWORD *)&dword_403000 = v8;
  result = (char *)sub_40199D + v9;
  *((_QWORD *)&dword_403000 + 1) = (char *)sub_40199D + v9;
  for ( i = (char **)&dword_403018; i < (char **)dword_403030; ++i )
  {
    v4 = 0;
    v5 = 0LL;
    do
    {
      v6 = *v1++;
      v7 = (unsigned __int64)(v6 & 0x7F) << v4;
      v4 += 7;
      v5 |= v7;
    }
    while ( v6 < 0 );
    if ( (v6 & 0x40) != 0 )
      v5 |= -1LL << v4;
    result = (char *)v5;
    if ( *i )
      result = *i;
    *i = result;
  }
  return result;
}
// 4012B6: variable 'v0' is possibly undefined
// 40199D: using guessed type __int64 __fastcall sub_40199D();
// 403000: using guessed type int dword_403000;
// 403018: using guessed type int dword_403018;
// 403030: using guessed type int dword_403030[4];

//----- (000000000040134D) ----------------------------------------------------
__int64 sub_40134D()
{
  return 42LL;
}

//----- (0000000000401601) ----------------------------------------------------
__int64 __fastcall sub_401601(unsigned __int16 **a1)
{
  unsigned __int16 **v1; // rdx
  unsigned __int16 *v2; // rdi
  int v3; // eax
  unsigned int v4; // eax
  __int64 result; // rax

  v1 = a1;
  v2 = *a1;
  v3 = *v2;
  if ( (unsigned __int16)v3 > 0xD7FFu )
  {
    v4 = sub_4019FA((__int64)v2, (_DWORD *)v1 + 6);
  }
  else
  {
    *((_DWORD *)v1 + 6) = v3;
    v4 = 1;
  }
  result = 2LL * v4;
  *v1 = (unsigned __int16 *)((char *)*v1 + result);
  return result;
}
// 401628: variable 'v1' is possibly undefined

//----- (000000000040162C) ----------------------------------------------------
unsigned __int64 __fastcall sub_40162C(__int64 a1, unsigned int a2)
{
  __int64 v2; // rdx
  unsigned __int64 v3; // r8
  unsigned __int64 result; // rax
  _BYTE *v5; // rcx

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 16);
  result = (int)a2;
  if ( a2 > 0x7F )
    result = sub_401A09(a2);
  do
  {
    v5 = *(_BYTE **)(v2 + 8);
    if ( v3 <= (unsigned __int64)v5 )
      break;
    *(_QWORD *)(v2 + 8) = v5 + 1;
    *v5 = result;
    result >>= 8;
  }
  while ( result );
  return result;
}
// 401642: variable 'v2' is possibly undefined
// 401649: variable 'v3' is possibly undefined

//----- (000000000040165C) ----------------------------------------------------
__int64 __fastcall sub_40165C(unsigned __int16 *a1, unsigned __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5)
{
  __int64 v5; // r15
  unsigned __int64 v6; // rbx
  unsigned __int16 **v7; // r9
  __int64 v8; // r11
  unsigned __int64 v9; // r11
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // rax
  bool v13; // r14
  unsigned __int64 v14; // r12
  __int64 v15; // r10
  __int64 v16; // r10
  unsigned __int64 v17; // rax
  __int64 v18; // r10
  bool v19; // cf
  unsigned __int64 v20; // r14
  unsigned __int64 v21; // r10
  unsigned __int64 v22; // r12
  unsigned __int16 **v23; // r9
  unsigned __int64 v25; // [rsp+8h] [rbp-68h]
  unsigned __int16 *v28; // [rsp+20h] [rbp-50h] BYREF
  unsigned __int64 v29; // [rsp+28h] [rbp-48h]
  unsigned __int64 v30; // [rsp+30h] [rbp-40h]
  unsigned int v31; // [rsp+38h] [rbp-38h]

  v5 = 0x100002600LL;
  v6 = 0LL;
  v28 = a1;
  v29 = a2;
  v30 = a2 + a3;
  sub_401601(&v28);
LABEL_2:
  if ( v31 )
  {
    while ( 1 )
    {
      if ( !v31 )
        goto LABEL_7;
      if ( v31 > 0x20 || !_bittest64(&v5, v31) )
        break;
      sub_401601(v7);
    }
    if ( ++v6 < a5 )
    {
      v12 = v29;
      if ( v29 >= v30 )
        v12 = 0LL;
      *(_QWORD *)(a4 + 8 * v6 - 8) = v12;
    }
    v13 = 0;
    while ( 1 )
    {
      if ( !v31 )
      {
LABEL_45:
        sub_40162C((__int64)v7, 0);
        goto LABEL_2;
      }
      if ( v13 || v31 > 0x20 )
      {
        if ( v31 != 34 && v31 != 92 )
          goto LABEL_44;
        v14 = 0LL;
        while ( v31 == 92 )
        {
          ++v14;
          sub_401601(v7);
        }
        v15 = 0LL;
        while ( v31 == 34 )
        {
          sub_401601(v7);
          v15 = v16 + 1;
        }
        v17 = v14;
        if ( v15 )
        {
          while ( v17 > 1 )
          {
            v25 = v17;
            sub_40162C((__int64)v7, 0x5Cu);
            v17 = v25 - 2;
          }
          if ( (v14 & 1) == 0 || (sub_40162C((__int64)v7, 0x22u), (v15 = v18 - 1) != 0) )
          {
            v19 = !v13;
            v20 = 3LL;
            v21 = v15 - v19;
            v22 = v21 + 1;
            while ( v22 >= v20 )
            {
              v20 += 3LL;
              sub_40162C((__int64)v7, 0x22u);
            }
            v13 = v21 % 3 == 0;
          }
        }
        else
        {
          while ( --v14 != -1LL )
            sub_40162C((__int64)v7, 0x5Cu);
        }
      }
      else
      {
        if ( _bittest64(&v5, v31) )
          goto LABEL_45;
LABEL_44:
        sub_40162C((__int64)v7, v31);
        sub_401601(v23);
      }
    }
  }
LABEL_7:
  sub_40162C((__int64)v7, 0);
  if ( v8 )
  {
    v9 = v8 - 1;
    v10 = v29 - a2;
    if ( v29 - a2 > v9 )
      v10 = v9;
    *(_BYTE *)(a2 + v10) = 0;
  }
  if ( a5 )
  {
    v11 = a5 - 1;
    if ( a5 - 1 > v6 )
      v11 = v6;
    *(_QWORD *)(a4 + 8 * v11) = 0LL;
  }
  return (unsigned int)v6;
}
// 4016BE: variable 'v7' is possibly undefined
// 4016D2: variable 'v8' is possibly undefined
// 40178F: variable 'v16' is possibly undefined
// 4017E8: variable 'v18' is possibly undefined
// 4017FB: variable 'v15' is possibly undefined
// 401825: variable 'v21' is possibly undefined
// 40183F: variable 'v23' is possibly undefined

//----- (0000000000401907) ----------------------------------------------------
__int64 __fastcall sub_401907(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int *v4; // rdi
  __int64 v5; // rax
  int v6; // ecx
  __int64 v7; // rdx
  unsigned int *v8; // rcx
  void (__fastcall *v9)(_QWORD, __int64); // rdx

LABEL_1:
  while ( 1 )
  {
    v4 = (unsigned int *)qword_403040;
    if ( !qword_403040 )
      return a3;
    while ( 1 )
    {
      v5 = *v4;
      while ( v5 )
      {
        _BitScanForward((unsigned int *)&v6, v5);
        v7 = (unsigned int)~(1 << v6);
        v5 &= v7;
        if ( !a1 || *(_QWORD *)&v4[6 * v6 + 8] == a1 )
        {
          *v4 &= v7;
          v8 = &v4[6 * v6];
          v9 = (void (__fastcall *)(_QWORD, __int64))*((_QWORD *)v8 + 2);
          if ( v9 )
          {
            v9(*((_QWORD *)v8 + 3), 1LL);
            goto LABEL_1;
          }
        }
      }
      if ( !a1 )
        break;
      if ( !*((_QWORD *)v4 + 1) )
        return a3;
      v4 = (unsigned int *)*((_QWORD *)v4 + 1);
    }
    qword_403040 = *((_QWORD *)v4 + 1);
  }
}
// 403040: using guessed type __int64 qword_403040;

//----- (000000000040199D) ----------------------------------------------------
__int64 __fastcall sub_40199D()
{
  __int16 v0; // ax
  __int64 result; // rax

  result = (unsigned int)v0;
  if ( (int)result < 0 )
  {
    dword_403358 = dword_403020;
    return -1LL;
  }
  else
  {
    __asm { syscall; Low latency system call }
  }
  return result;
}
// 4019AF: conditional instruction was optimized away because rax.8<80000000u
// 40199D: variable 'v0' is possibly undefined
// 40199D: using guessed type __int64 __fastcall sub_40199D();
// 403020: using guessed type int dword_403020;
// 403358: using guessed type int dword_403358;

//----- (00000000004019FA) ----------------------------------------------------
__int64 __fastcall sub_4019FA(__int64 a1, _DWORD *a2)
{
  return sub_401A3C(a1, a2);
}

//----- (0000000000401A09) ----------------------------------------------------
__int64 __fastcall sub_401A09(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  int v3; // ecx
  char v4; // dl

  a1 = (unsigned int)a1;
  v1 = 0LL;
  if ( (unsigned int)a1 > 0x7F )
  {
    _BitScanReverse((unsigned int *)&v2, a1);
    v3 = *(_DWORD *)&byte_401AF7[2 * v2 - 14];
    do
    {
      v4 = a1;
      a1 = (unsigned int)a1 >> 6;
      LOBYTE(v1) = v4 & 0x3F | v1 | 0x80;
      v1 <<= 8;
      LOBYTE(v3) = v3 - 1;
    }
    while ( (_BYTE)v3 );
    LOBYTE(v1) = BYTE1(v3) | v1;
  }
  return a1 | v1;
}
// 401A1C: variable 'v2' is possibly undefined

//----- (0000000000401A3C) ----------------------------------------------------
__int64 __fastcall sub_401A3C(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // rdx
  int v4; // ebx
  int v5; // edx
  int v6; // eax

  LODWORD(result) = 0;
  do
  {
    v3 = (unsigned int)result;
    v4 = result;
    result = (unsigned int)(result + 1);
    v5 = *(unsigned __int16 *)(a1 + 2 * v3);
  }
  while ( (v5 & 0xFC00) == 0xDC00 );
  if ( (v5 & 0xFC00) == 0xD800 )
  {
    v6 = *(unsigned __int16 *)(a1 + 2 * result);
    if ( (v6 & 0xFC00) == 0xDC00 )
    {
      *a2 = (v5 << 10) + v6 - 56613888;
      return (unsigned int)(v4 + 2);
    }
    else
    {
      *a2 = 65533;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    *a2 = v5;
  }
  return result;
}

//----- (0000000000401AA1) ----------------------------------------------------
void __fastcall __noreturn sub_401AA1(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rcx

  dword_40335C |= 4u;
  if ( (dword_403000 & 4) != 0 )
  {
    for ( i = (unsigned __int8)a1; ; qword_402010(a1, a2, a3, i) )
      ;
  }
  __asm { syscall; Low latency system call }
  _disable();
  __lidt(byte_401AD2);
  __halt();
}
// 401AB5: variable 'a3' is possibly undefined
// 401AB5: variable 'i' is possibly undefined
// 402010: using guessed type __int64 (__fastcall *qword_402010)(_QWORD, _QWORD, _QWORD, _QWORD);
// 403000: using guessed type int dword_403000;
// 40335C: using guessed type int dword_40335C;

//----- (0000000000401EF8) ----------------------------------------------------
void __fastcall sub_401EF8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v4; // al

  *(_BYTE *)(a4 + 1712357504) += v4 | 0xCE;
  JUMPOUT(0x402000LL);
}
// 401FF9: control flows out of bounds to 402000
// 401EF8: variable 'v4' is possibly undefined

// nfuncs=17 queued=17 decompiled=17 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 17 function(s)"
