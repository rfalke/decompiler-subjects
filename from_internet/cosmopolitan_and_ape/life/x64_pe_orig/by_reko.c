// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a402008[] = // 0000000000402008
	{
	};
<anonymous> * __imp__ExitProcess = &g_t1DE8; // 0000000000402010
<anonymous> * __imp__FreeEnvironmentStringsW = &g_t1DF6; // 0000000000402018
<anonymous> * __imp__GetCommandLineW = &g_t1E10; // 0000000000402020
<anonymous> * __imp__GetEnvironmentStringsW = &g_t1E22; // 0000000000402028
<anonymous> * __imp__GetStdHandle = &g_t1E3C; // 0000000000402030
<anonymous> * __imp__SetDefaultDllDirectories = &g_t1E4C; // 0000000000402038
<anonymous> * __imp__WriteFile = &g_t1E68; // 0000000000402040
Eq_4 g_t403000 = // 0000000000403000
	{
		0x00
	};
word64 g_qw403008 = 0x00; // 0000000000403008
uint64 g_a403018[3] = // 0000000000403018
	{
		0x00,
		0x00,
		0x00,
	};
word64 g_qw403030 = 0x00; // 0000000000403030
struct Eq_646 * g_ptr403040 = null; // 0000000000403040
ui32 g_dw40335C = 0x00; // 000000000040335C
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401297: void fn0000000000401297(Register (ptr64 word64) r15)
// Called from:
//      Win32CrtStartup
void fn0000000000401297(word64 * r15)
{
	byte * rsi_110;
	Eq_4 qwLoc20_192;
	if ((g_t403000.u1 & 0x08) == 0x00)
	{
		if ((g_t403000.u1 & 0x20) == 0x00)
		{
			if ((g_t403000.u1 & 0x04) == 0x00)
			{
				if (*r15 != 0x00)
				{
					rsi_110 = &g_b401EED;
					qwLoc20_192.u2 = 0x01;
				}
				else
				{
					rsi_110 = &g_b401EF1;
					qwLoc20_192.u2 = 0x2A00000010;
				}
			}
			else
			{
				rsi_110 = &g_b401EF5;
				qwLoc20_192.u2 = 0x2200000004;
			}
		}
		else
		{
			rsi_110 = &g_b401EE9;
			qwLoc20_192.u2 = 0x3000000020;
		}
	}
	else
	{
		rsi_110 = &g_b401EF8;
		qwLoc20_192.u2 = 0x4500000008;
	}
	g_t403000.u2 = (word64) qwLoc20_192;
	g_qw403008 = 0x00803885;
	word64 * rdi_156 = g_a403018;
	uint64 rax_146 = 0x00803885;
	while (true)
	{
		word56 rax_56_8_171 = SLICE(rax_146, word56, 8);
		if (rdi_156 >= &g_qw403030)
			break;
		uint64 rdx_105 = 0x00;
		Eq_49 ecx_241 = 0x00;
		do
		{
			ecx_241.u0 = (uint64) ((word64) ecx_241 + 7);
			ci8 al_112 = *rsi_110;
			++rsi_110;
			byte cl_139 = (byte) ecx_241;
			rdx_105 |= (uint64) ((word32) SEQ(rax_56_8_171, al_112) & 0x7F) << (byte) ecx_241;
		} while (al_112 < 0x00);
		if ((al_112 & 0x40) != 0x00)
			rdx_105 |= ~0x00 << cl_139;
		rax_146 = rdx_105;
		if (*rdi_156 != 0x00)
			rax_146 = *rdi_156;
		*rdi_156 = rax_146;
		++rdi_156;
	}
}

// 000000000040134D: Register word32 fn000000000040134D()
// Called from:
//      Win32CrtStartup
word32 fn000000000040134D()
{
	return 0x2A;
}

// 000000000040139B: void fn000000000040139B(Register word32 edi)
// Called from:
//      Win32CrtStartup
void fn000000000040139B(word32 edi)
{
	fn0000000000401907(0x00);
	fn0000000000401AA1((byte) edi);
}

// 00000000004013C5: Register Eq_109 Win32CrtStartup()
Eq_109 Win32CrtStartup()
{
	ptr64 fp;
	Eq_111 tLocE048;
	Eq_109 tLoc8038;
	word32 dwLocE078;
	word32 dwLocE060;
	word64 qwLocD038;
	up32 dwLocE04C;
	tLocE048 = (Eq_111) 0x00;
	if ((word32) KernelBase.dll!SetDefaultDllDirectories(0x0800, 0x0800, 0x00) != 0x00)
	{
		g_t403000.u0 = 0x04;
		word64 rax_53 = SEQ(dwLocE078, GetCommandLineW());
		Eq_139 rax_65 = SEQ(dwLocE078, GetEnvironmentStringsW());
		fn000000000040165C(fp - 53304, 0x3FFF, fp - 0x0000C037, rax_53, 0x0200);
		uint64 rax_365 = 0x00;
		while (true)
		{
			byte * rcx_93 = qwLocD038 + rax_365;
			byte dl_94 = *rcx_93;
			if (dl_94 == 0x00)
				break;
			if (dl_94 == 0x5C)
				*rcx_93 = 0x2F;
			++rax_365;
		}
		word32 eax_116;
		uint64 rax_101 = (uint64) *rax_65.u1;
		up32 eax_112 = (word32) rax_101;
		if ((word16) rax_101 <= 55295)
		{
			dwLocE04C = eax_112;
			eax_116 = 0x01;
		}
		else
			eax_116 = fn00000000004019FA(fp - 0x0000E04C, rax_65);
		union Eq_146 * rcx_122 = &tLoc8038;
		uint64 r8_127 = 0x00;
		Eq_139 rdx_129 = rax_65.u0 + (uint64) eax_116;
		while (dwLocE04C != 0x00)
		{
			++r8_127;
			if (r8_127 <= 0x01FF)
			{
				union Eq_146 * rax_262 = null;
				if (rcx_122 < fp - 58)
					rax_262 = rcx_122;
				(fp - 0x0000E040)[r8_127] = rax_262;
			}
			do
			{
				Eq_234 rax_275 = (int64) dwLocE04C_551;
				if (dwLocE04C_551 > 0x7F)
					rax_275 = fn0000000000401A09(rcx_122, dwLocE04C_551);
				do
				{
					byte al_292 = (byte) rax_550;
					if (rcx_122 >= fp - 58)
						break;
					rcx_122 = (union Eq_146 *) ((char *) rcx_122 + 1);
					rcx_122->u1.bFFFFFFFF = al_292;
					rax_275 = rax_550 >> 0x08;
					rax_550 = rax_275;
				} while (rax_550 >> 0x08 != 0x00);
				word32 eax_324;
				uint64 rax_305 = (uint64) *rdx_129.u1;
				up32 eax_318 = (word32) rax_305;
				if ((word16) rax_305 <= 55295)
				{
					dwLocE04C = eax_318;
					eax_324 = 0x01;
				}
				else
					eax_324 = fn00000000004019FA(fp - 0x0000E04C, rdx_129);
				rdx_129.u0 += (uint64) eax_324;
				dwLocE04C_551 = dwLocE04C;
			} while (dwLocE04C_551 != 0x00);
			Eq_319 rax_347 = rcx_122 - &tLoc8038;
			if (rax_347 > 0x7FFD)
				rax_347.u1 = 0x7FFD;
			Mem360[&tLoc8038 + rax_347:byte] = 0x00;
		}
		if (rcx_122 < fp - 58)
		{
			*rcx_122 = (union Eq_146 *) 0x00;
			rcx_122 = (union Eq_146 *) ((char *) rcx_122 + 1);
		}
		Eq_248 rcx_153 = rcx_122 - &tLoc8038;
		if (rcx_153 > 0x7FFE)
			rcx_153.u1 = 0x7FFE;
		if (r8_127 > 0x01FF)
			r8_127 = 0x01FF;
		Mem174[&tLoc8038 + rcx_153:byte] = 0x00;
		(fp - 57400)[r8_127] = 0x00;
		FreeEnvironmentStringsW(rax_65);
		__align_stack<word64>(fp - 0xE074);
		fn0000000000401297(&tLocE048);
		g_dw40335C |= 0x01;
		<anonymous> ** rax_217 = g_a402008;
		while (rax_217 != g_a402008)
		{
			(*rax_217)();
			rax_217 = (<anonymous> **) ((char *) rax_217 + 8);
		}
		fn000000000040139B(fn000000000040134D());
	}
	else
	{
		WriteFile(GetStdHandle(~0x0B), &g_v401AE1, 0x06, &tLoc8038, SEQ(dwLocE060, 0x00));
		ExitProcess(0x01);
	}
}

// 0000000000401601: void fn0000000000401601(Register (ptr64 Eq_361) rdi)
// Called from:
//      fn000000000040165C
void fn0000000000401601(struct Eq_361 * rdi)
{
	word32 eax_22;
	Eq_139 rdi_6 = rdi->t0000.u0;
	uint64 rax_8 = (uint64) *rdi_6.u1;
	word32 eax_18 = (word32) rax_8;
	if ((word16) rax_8 <= 55295)
	{
		rdi->dw0018 = eax_18;
		eax_22 = 0x01;
	}
	else
		eax_22 = fn00000000004019FA(&rdi->dw0018, rdi_6);
	rdi->t0000.u0 = (word16 (*)[]) (rdi->t0000.u0 + (uint64) eax_22);
}

// 000000000040162C: Register (ptr64 Eq_146) fn000000000040162C(Register (ptr64 Eq_146) rcx, Register up32 esi, Register (ptr64 Eq_397) rdi)
// Called from:
//      fn000000000040165C
union Eq_146 * fn000000000040162C(union Eq_146 * rcx, up32 esi, struct Eq_397 * rdi)
{
	word64 rsi;
	up32 esi = (word32) rsi;
	union Eq_146 * r8_10 = rdi->ptr0010;
	Eq_234 rax_11 = (int64) esi;
	if (esi > 0x7F)
		rax_11 = fn0000000000401A09(rcx, esi);
	do
	{
		byte al_29 = (byte) rax_69;
		union Eq_146 * rcx_23 = rdi->ptr0008;
		if (r8_10 <= rcx_23)
			return rcx_23;
		rdi->ptr0008 = (union Eq_146 *) ((char *) rcx_23 + 1);
		*rcx_23 = (union Eq_146 *) al_29;
		rax_11 = rax_69 >> 0x08;
		rax_69 = rax_11;
	} while (rax_69 >> 0x08 != 0x00);
	return rcx_23;
}

// 000000000040165C: void fn000000000040165C(Register (ptr64 Eq_146) rcx, Register uint64 rdx, Register ptr64 rsi, Register word64 rdi, Register uint64 r8)
// Called from:
//      Win32CrtStartup
void fn000000000040165C(union Eq_146 * rcx, uint64 rdx, ptr64 rsi, word64 rdi, uint64 r8)
{
	Eq_431 tLoc58;
	tLoc58.qw0000 = rdi;
	tLoc58.ptr0008 = rsi;
	tLoc58.qw0010 = rsi + rdx;
	fn0000000000401601(&tLoc58);
	uint64 rbx_118 = 0x00;
	rcx_245 = rcx;
l00000000004016A3:
	union Eq_146 * rcx_245;
	if (tLoc58.dw0018 != 0x00)
	{
		while (true)
		{
			uint64 rax_57 = (uint64) tLoc58.dw0018;
			up32 eax_58 = (word32) rax_57;
			if (eax_58 == 0x00)
				break;
			if (eax_58 > 0x20 || __bt<word64>(0x100002600, rax_57))
			{
				++rbx_118;
				if (rbx_118 < r8)
				{
					uint64 rax_163 = tLoc58.qw0008;
					if (rax_163 >= tLoc58.qw0010)
						rax_163 = 0x00;
					(rcx - 8)[rbx_118] = rax_163;
				}
				Eq_498 r14b_193 = 0x00;
				while (true)
				{
					uint64 rsi_187 = (uint64) tLoc58.dw0018;
					up32 esi_188 = (word32) rsi_187;
					if (esi_188 == 0x00)
						break;
					if (r14b_193 == 0x00 && esi_188 <= 0x20)
					{
						if (!__bt<word64>(0x100002600, rsi_187))
							break;
					}
					else if (esi_188 == 0x22 || esi_188 == 0x5C)
					{
						uint64 r12_206 = 0x00;
						while (true)
						{
							byte r12b_508 = (byte) r12_206;
							if (tLoc58.dw0018 != 0x5C)
								break;
							fn0000000000401601(&tLoc58);
							++r12_206;
						}
						uint64 r10_216 = 0x00;
						while (tLoc58.dw0018 == 0x22)
						{
							fn0000000000401601(&tLoc58);
							++r10_216;
						}
						uint64 rax_230 = r12_206;
						if (r10_216 != 0x00)
						{
							for (; rax_230 > 0x01; rax_230 -= 0x02)
								rcx_245 = fn000000000040162C(rcx_245, 0x5C, &tLoc58);
							if ((r12b_508 & 0x01) != 0x00)
							{
								rcx_245 = fn000000000040162C(rcx_245, 0x22, &tLoc58);
								--r10_216;
								if (r10_216 == 0x00)
									continue;
							}
							uint64 r14_264;
							uint64 r10_267 = r10_216 - (word64) (r14b_193 < 0x01);
							for (r14_264 = 0x03; r10_267 + 1 >= r14_264; r14_264 += 0x03)
								rcx_245 = fn000000000040162C(rcx_245, 0x22, &tLoc58);
							rcx_245 = (union Eq_146 *) 0x03;
							r14b_193.u0 = (int8) ((uint64) ((uint128) r10_267 % 0x03) == 0x00);
							continue;
						}
						else
						{
							while (true)
							{
								--r12_206;
								if (r12_206 == ~0x00)
									break;
								rcx_245 = fn000000000040162C(rcx_245, 0x5C, &tLoc58);
							}
							continue;
						}
					}
					rcx_245 = fn000000000040162C(rcx_245, (word32) rsi_187, &tLoc58);
					fn0000000000401601(&tLoc58);
				}
				rcx_245 = fn000000000040162C(rcx_245, 0x00, &tLoc58);
				goto l00000000004016A3;
			}
			fn0000000000401601(&tLoc58);
		}
	}
	fn000000000040162C(rcx_245, 0x00, &tLoc58);
	if (rdx != 0x00)
	{
		Eq_485 rax_100 = tLoc58.qw0008 - rsi;
		if (rax_100 > rdx - 0x01)
			rax_100 = rdx - 0x01;
		*((word64) rax_100 + rsi) = 0x00;
	}
	if (r8 != 0x00)
	{
		uint64 r8_114 = r8 - 0x01;
		if (r8 - 0x01 > rbx_118)
			r8_114 = rbx_118;
		*((char *) rcx + r8_114 * 0x08) = 0x00;
	}
}

// 0000000000401907: void fn0000000000401907(Register uint64 rdi)
// Called from:
//      fn000000000040139B
void fn0000000000401907(uint64 rdi)
{
	while (true)
	{
l000000000040191B:
		struct Eq_646 * rdi_24 = g_ptr403040;
		if (rdi_24 == null)
			break;
l0000000000401928:
		uint64 rax_101 = (uint64) rdi_24->dw0000;
		do
		{
			word32 eax_87 = (word32) rax_101;
			if (rax_101 == 0x00)
			{
				struct Eq_646 * r13_46 = rdi_24->ptr0008;
				if (rdi != 0x00)
				{
					if (r13_46 == null)
						return;
					rdi_24 = r13_46;
					goto l0000000000401928;
				}
				else
				{
					if (r13_46 != null && null != 0x00)
						fn0000000000000000();
					g_ptr403040 = r13_46;
					goto l000000000040191B;
				}
			}
			word32 ecx_88 = __bsf<word32>(eax_87);
			uint64 rdx_100 = (uint64) ~(0x01 << (byte) ecx_88);
			Eq_665 rcx_97 = (uint64) ecx_88;
			ui32 edx_114 = (word32) rdx_100;
			rax_101 &= rdx_100;
			if (rdi != 0x00 && ((rdi_24->a0020))[rcx_97].qw0000 != rdi)
				continue;
			rdi_24->dw0000 &= edx_114;
			<anonymous> * rdx_119 = *((char *) &(rdi_24 + (rcx_97 *s 0x18) /64 32)->ptr0008 + 8);
		} while (rdx_119 == null);
		word64 rcx_135;
		word64 r8_136;
		rdx_119();
	}
}

// 00000000004019FA: Register word32 fn00000000004019FA(Register (ptr64 ui32) rsi, Register Eq_139 rdi)
// Called from:
//      Win32CrtStartup
//      fn0000000000401601
word32 fn00000000004019FA(ui32 * rsi, Eq_139 rdi)
{
	ptr64 fp;
	__align_stack<word64>(fp - 8);
	return fn0000000000401A3C(rsi, rdi);
}

// 0000000000401A09: Register ui64 fn0000000000401A09(Register (ptr64 Eq_146) rcx, Register up32 edi)
// Called from:
//      Win32CrtStartup
//      fn000000000040162C
ui64 fn0000000000401A09(union Eq_146 * rcx, up32 edi)
{
	ui32 rcx_32_32_21 = SLICE(rcx, word32, 32);
	uint64 rdi_11 = (uint64) edi;
	uint32 edi_14 = (word32) rdi_11;
	uint64 rax_13 = 0x00;
	ui8 al_32 = 0x00;
	Eq_741 rax_56_8_35 = 0x00;
	if (edi_14 > 0x7F)
	{
		uint64 rcx_24 = (uint64) g_a401AE9[SEQ(rcx_32_32_21, __bsr<word32>(edi_14))];
		byte ch_45 = SLICE(rcx_24, byte, 8);
		byte cl_39 = (byte) rcx_24;
		do
		{
			byte al_34 = al_32 | 0x80 | (byte) edi_14 & 0x3F;
			rdi_11 = (uint64) (edi_14 >> 0x06);
			Eq_741 rax_36 = SEQ(rax_56_8_35, al_34);
			edi_14 = (word32) rdi_11;
			al_32 = al_34 << 0x08;
			rax_56_8_35 = rax_36;
			--cl_39;
		} while (cl_39 != 0x00);
		rax_13 = SEQ(rax_36, al_34 << 0x08 | ch_45);
	}
	return rax_13 | rdi_11;
}

// 0000000000401A3C: Register word32 fn0000000000401A3C(Register (ptr64 ui32) rsi, Register Eq_139 rdi)
// Called from:
//      fn00000000004019FA
word32 fn0000000000401A3C(ui32 * rsi, Eq_139 rdi)
{
	word32 eax_28 = 0x00;
	do
	{
		uint64 rax_116 = (uint64) (eax_28 + 0x01);
		ui32 edx_39 = (word32) rdi.u1[(uint64) eax_28 * 0x02];
		uint64 rbx_32 = (uint64) eax_28;
		eax_28 = (word32) rax_116;
		cui16 cx_42 = (word16) edx_39;
	} while ((cx_42 & 0xFC00) == 0xDC00);
	if ((cx_42 & 0xFC00) != 0xD800)
		*rsi = edx_39;
	else
	{
		uint64 rax_49 = (uint64) rdi.u1[rax_116 * 0x02];
		if (((word16) rax_49 & 0xFC00) != 0xDC00)
		{
			*rsi = 0xFFFD;
			rax_116 = 0xFFFFFFFF;
		}
		else
		{
			*rsi = (edx_39 << 0x0A) - 56613888 + (word32) rax_49;
			rax_116 = (uint64) ((word32) rbx_32 + 0x02);
		}
	}
	return (word32) rax_116;
}

// 0000000000401AA1: void fn0000000000401AA1(Register byte dil)
// Called from:
//      fn000000000040139B
void fn0000000000401AA1(byte dil)
{
	g_dw40335C |= 0x04;
	if ((g_t403000.u1 & 0x04) == 0x00)
	{
		__syscall();
		__cli();
		__lidt<word48>(g_n401AD2);
		__halt();
	}
	else
		ExitProcess((UINT) dil);
}

word48 g_n401AD2 = ;
void g_v401AE1 = ??void??; // 0000000000401AE1
Eq_894 g_a401AE9[] = // 0000000000401AE9
	{
	};
word64 g_qw401EA0 = 7656; // 0000000000401EA0
word64 g_qw401EA8 = 7670; // 0000000000401EA8
word64 g_qw401EB0 = 0x1E10; // 0000000000401EB0
word64 g_qw401EB8 = 0x1E22; // 0000000000401EB8
word64 g_qw401EC0 = 7740; // 0000000000401EC0
word64 g_qw401EC8 = 7756; // 0000000000401EC8
word64 g_qw401ED0 = 7784; // 0000000000401ED0
byte g_b401EE9 = 0x0C; // 0000000000401EE9
byte g_b401EED = 0x0C; // 0000000000401EED
byte g_b401EF1 = 0x0C; // 0000000000401EF1
byte g_b401EF5 = 0x0E; // 0000000000401EF5
byte g_b401EF8 = 0x0C; // 0000000000401EF8
