/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn sub_401000();
__int64 __fastcall sub_401158(__int64 *, __int64);
__int64 __fastcall sub_4011FE(__int64, __int64 *, __int64, __int64);
__int64 sub_40126D();
void sub_4012F0();
__int64 sub_4014CE();
__int64 __fastcall sub_4014E0(__int64);
void sub_4015CB();
HANDLE sub_40161F();
__int64 sub_401674();
__int64 sub_401711();
void __fastcall sub_40173E();
__int64 __fastcall sub_40186F(int, __int64);
char __fastcall sub_40189D();
void __fastcall __noreturn sub_4018AE(__int64, __int64);
__int64 sub_4018C7();
__int64 sub_4018D7();
__int64 sub_4018E7();
__int64 sub_4018F7();
__int64 sub_401907();
void __noreturn start();
__int64 __fastcall sub_401B52();
unsigned __int64 __fastcall sub_401B7D();
__int64 __fastcall sub_401BAD(__int64, __int64);
__int64 __fastcall sub_401DBA(__int64, __int64);
__int64 __fastcall sub_401E5C();
BOOL __fastcall sub_401E81();
HANDLE __fastcall sub_401E9A(DWORD dwMaximumSizeHigh, DWORD flProtect, DWORD dwMaximumSizeLow, LPCWSTR lpName);
DWORD __fastcall sub_401EB0();
DWORD sub_401EC9();
LPVOID __fastcall sub_401EDF(DWORD, DWORD, SIZE_T, void *);
BOOL __fastcall sub_401EF5();
__int64 sub_401F47();
__int64 __fastcall sub_401F82();
__int64 __fastcall sub_401FE7();
__int64 sub_4020AB();
__int64 __fastcall sub_4020B3();
_BOOL8 __fastcall sub_4020D4();
__int64 __fastcall sub_4020DE();
__int64 __fastcall sub_4020EC(__int64);
__int64 __fastcall sub_4021BE();
__int64 sub_40228B();
__int64 sub_402296(void); // weak
__int64 sub_40229C(void); // weak
__int64 __fastcall sub_4022A2(_QWORD, _QWORD); // weak
__int64 __fastcall sub_4022A8(__int64, __int64);
__int64 __fastcall sub_4022EF();
_BOOL8 __fastcall sub_4025AC();
__int64 __fastcall sub_4026E8(__int64, unsigned __int64);
unsigned __int64 __fastcall sub_402B64();
void __fastcall sub_403AE8();
void __fastcall sub_403FED();
__int64 *__fastcall sub_404049(__int64, unsigned __int64);
__int64 *__fastcall sub_4043D8();
void sub_404491();
__int64 sub_404518();
__int64 __fastcall sub_40452C(__int64);
__int64 __fastcall sub_404540(__int64, __int64);
__int64 __fastcall sub_4045D5(__int64, __int64);
char __fastcall sub_40466A(__int64, unsigned __int64);
_BOOL8 __fastcall sub_4047B0(__int64);
__int64 sub_40481D();
__int64 __fastcall sub_404843(char, __int64, int);
__int64 sub_404ABB();
__int64 __fastcall sub_404AC1(__int64);
__int64 __fastcall sub_404C04(__int64, int);
__int64 sub_404C24();
__int64 __fastcall sub_404C31();
bool __fastcall sub_404C6C();
__int64 __fastcall sub_404C87();
__int64 sub_404DB0();
__int64 sub_404DC0();
__int64 sub_404DD0();
__int64 sub_404DE0();
__int64 __fastcall sub_404DF0(); // weak
__int64 sub_404E4D();
__int64 __fastcall sub_404E5C();
__int64 __fastcall sub_404E8F();
void __fastcall sub_404F70(__int64, unsigned __int64);
void __fastcall sub_404F84(__int64, unsigned __int64 _RDX);
void __fastcall sub_405092(__int64, __int64);
void __fastcall sub_4050B2(__int64, unsigned __int64);
void __fastcall sub_4050CC(__int64 a1, unsigned __int64 _RDX, __int64 a3, double _XMM3_8);
__int64 __fastcall sub_40517E(__int64, unsigned __int64);
__int64 __fastcall sub_4051E0(__int64, unsigned int);
void __fastcall __noreturn sub_405211();
__int64 __fastcall sub_40524A();
__int64 sub_4052D6();

//-------------------------------------------------------------------------
// Data declarations

char byte_405242[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
char byte_405347[2] = { '\x01', 'À' }; // weak
__int64 (__fastcall *off_406008)() = &sub_4014E0; // weak
_UNKNOWN unk_406010; // weak
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HANDLE (__stdcall *CreateFileMappingNumaW)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern BOOL (__stdcall *FlushFileBuffers)(HANDLE hFile);
// extern BOOL (__stdcall *FreeEnvironmentStringsW)(LPWCH penv);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern LPWCH (__stdcall *GetEnvironmentStringsW)();
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern DWORD (__stdcall *GetLastError)();
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern LPVOID (__stdcall *MapViewOfFileExNuma)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred);
// extern BOOL (__stdcall *SetDefaultDllDirectories)(DWORD DirectoryFlags);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
__int64 qword_440000; // weak
char byte_44003D; // weak
int dword_440668; // weak
__int64 (*qword_440670)(void); // weak
int dword_4406A8; // weak
__int64 qword_4406B8; // weak
int dword_4406C0; // weak
int dword_4406F8; // weak
int dword_440700; // weak
int dword_440708; // weak
__int64 qword_440710; // weak
__int64 qword_440728; // weak
int dword_440730; // weak
__int64 qword_440798; // weak
__int64 qword_442038; // weak
__int64 qword_442040; // weak
__int64 qword_442048; // weak
__int64 qword_442050; // weak
int dword_4420A0; // weak
int dword_4420A4; // weak
__int64 qword_4420A8[]; // weak
__int64 qword_4420B0; // weak
__int64 qword_4420B8; // weak
__int64 qword_4420C0; // weak
__int64 qword_4420C8; // weak
__int64 qword_4420D0; // weak
__int64 qword_4420D8; // weak
__int64 qword_4420E0; // weak
_UNKNOWN unk_4420E8; // weak
_QWORD qword_4420F8[62]; // weak
_UNKNOWN unk_4422E8; // weak
__int64 qword_4422F8[32]; // weak
__int64 qword_4423F8; // weak
__int64 qword_442400; // weak
__int64 qword_442408; // weak
int dword_442410; // weak
__int64 qword_442418; // weak
__int64 qword_442420; // weak
__int64 qword_442428; // weak
int dword_442430; // weak
__int64 qword_442460; // weak
__int64 qword_442468; // weak
__int64 qword_442470; // weak
__int64 qword_442478; // weak
__int64 qword_442480; // weak
int dword_442488; // weak
__int64 qword_4424A0; // weak
_UNKNOWN unk_4424A8; // weak
__int64 qword_4427C0[]; // weak
int dword_4427C8[]; // weak
int dword_4427CC[599]; // weak
__int64 qword_443128[303]; // weak
_UNKNOWN unk_443AA0; // weak
__int64 qword_443AB0; // weak
struct _SYSTEM_INFO SystemInfo; // idb
int dword_443C70; // weak
int dword_443C74; // weak


//----- (0000000000401000) ----------------------------------------------------
void __noreturn sub_401000()
{
  dword_443C74 |= 2u;
  if ( (dword_440668 & 4) == 0 )
  {
    __asm
    {
      syscall; Low latency system call
      syscall; Low latency system call
      syscall; Low latency system call
    }
  }
  sub_405211();
}
// 440668: using guessed type int dword_440668;
// 443C74: using guessed type int dword_443C74;

//----- (0000000000401158) ----------------------------------------------------
__int64 __fastcall sub_401158(__int64 *a1, __int64 a2)
{
  unsigned __int64 v2; // rdi
  int v3; // esi
  char i; // cl
  __int64 v6; // rax
  __int64 *v8; // rdx
  __int64 v9; // rax

  for ( i = 39; ; i -= 9 )
  {
    --v3;
    v6 = (v2 >> i) & 0x1FF;
    if ( v3 == -1 )
      break;
    v8 = (__int64 *)(a2 + 8 * v6);
    if ( !*v8 )
    {
      v9 = *a1 - 4096;
      *a1 = v9;
      *v8 = v9 | 3;
    }
    a2 = *v8 & 0x3FFFFFFFFF000i64;
  }
  return a2 + 8 * v6;
}
// 40116D: variable 'v3' is possibly undefined
// 40116F: variable 'v2' is possibly undefined

//----- (00000000004011FE) ----------------------------------------------------
__int64 __fastcall sub_4011FE(__int64 a1, __int64 *a2, __int64 a3, __int64 a4)
{
  unsigned int v4; // er10
  unsigned int v5; // er11
  __int64 v6; // rbx
  __int64 v7; // r13
  __int64 *v8; // r8
  int v9; // er12
  int v10; // er14
  __int64 v11; // rax
  unsigned int v12; // ecx
  __int64 *v13; // rsi
  __int64 *v14; // rdi
  __int64 i; // rcx
  __int64 result; // rax

  do
  {
    v6 = *a2;
    v7 = a2[1];
    v8 = a2;
    v9 = *((_DWORD *)a2 + 4);
    v10 = *((_DWORD *)a2 + 5);
    LODWORD(v11) = v5;
    while ( 1 )
    {
      v12 = v11;
      v11 = (unsigned int)(v11 - 1);
      if ( v6 == *(v8 - 3) )
        break;
      v13 = v8 - 3;
      v14 = v8;
      v8 -= 3;
      for ( i = 6i64; i; --i )
      {
        *(_DWORD *)v14 = *(_DWORD *)v13;
        v13 = (__int64 *)((char *)v13 + 4);
        v14 = (__int64 *)((char *)v14 + 4);
      }
      if ( !(_DWORD)v11 )
        goto LABEL_9;
    }
    v11 = v12;
LABEL_9:
    ++v5;
    a2 += 3;
    result = a4 + 24 * v11;
    *(_QWORD *)result = v6;
    *(_QWORD *)(result + 8) = v7;
    *(_DWORD *)(result + 16) = v9;
    *(_DWORD *)(result + 20) = v10;
  }
  while ( v5 < v4 );
  return result;
}
// 40121B: variable 'v5' is possibly undefined
// 401262: variable 'v4' is possibly undefined

//----- (000000000040126D) ----------------------------------------------------
__int64 sub_40126D()
{
  return 0i64;
}

//----- (00000000004012F0) ----------------------------------------------------
void sub_4012F0()
{
  __int64 *i; // rdi
  _DWORD *v6; // rdi

  qword_440000 = __rdtsc();
  i = &qword_440000 + 1;
  _RAX = 0i64;
  while ( 1 )
  {
    __asm { cpuid }
    *(_DWORD *)i = _RAX;
    v6 = (_DWORD *)i + 1;
    *v6++ = _RBX;
    *v6++ = _RCX;
    *v6 = _RDX;
    for ( i = (__int64 *)(v6 + 1); ; i += 2 )
    {
      _RAX = 1i64;
      if ( *((_BYTE *)&qword_440000 + 8) )
        break;
    }
  }
}
// 4012F0: could not find valid save-restore pair for rbx
// 4012F0: could not find valid save-restore pair for rsi
// 40132B: conditional instruction was optimized away because %0x10.4==1
// 440000: using guessed type __int64 qword_440000;
// 440668: using guessed type int dword_440668;
// 440798: using guessed type __int64 qword_440798;
// 442038: using guessed type __int64 qword_442038;

//----- (00000000004014CE) ----------------------------------------------------
__int64 sub_4014CE()
{
  sub_401F47();
  return 0i64;
}

//----- (00000000004014E0) ----------------------------------------------------
__int64 __fastcall sub_4014E0(__int64 a1)
{
  _BYTE *v1; // r12
  _BYTE *v2; // r13
  __int64 v3; // r12
  __int64 v4; // rbx
  _QWORD *v5; // rdx
  _QWORD *savedregs; // [rsp+8h] [rbp+0h] BYREF

  v1 = (_BYTE *)qword_442038;
  if ( (dword_440668 & 4) != 0 || (unsigned int)sub_401674() )
    *v1 = 1;
  savedregs = &savedregs;
  v2 = v1;
  if ( !qword_442050 )
  {
    qword_442050 = 4464728i64;
    qword_442048 = 8i64;
    sub_404540(a1, 0i64);
  }
  v3 = qword_442040;
  v4 = qword_442040 - 1;
  while ( v4 != -1 )
  {
    v5 = (_QWORD *)(qword_442050 + 8 * v4--);
    if ( !*(_QWORD *)(qword_442050 + 8 * v4 + 8) )
    {
      *v5 = v2;
      return 0i64;
    }
  }
  if ( qword_442040 + 1 < (unsigned __int64)qword_442048 || sub_40466A(1i64, 8ui64) )
  {
    LODWORD(v4) = v3;
    *(_QWORD *)(qword_442050 + 8 * v3) = v2;
    qword_442040 = v3 + 1;
  }
  return (unsigned int)v4;
}
// 40154A: variable 'a1' is possibly undefined
// 440668: using guessed type int dword_440668;
// 442038: using guessed type __int64 qword_442038;
// 442040: using guessed type __int64 qword_442040;
// 442048: using guessed type __int64 qword_442048;
// 442050: using guessed type __int64 qword_442050;

//----- (00000000004015CB) ----------------------------------------------------
void sub_4015CB()
{
  sub_404491();
}
// 4015CD: ignored the value written to the shadow area of the succeeding call

//----- (000000000040161F) ----------------------------------------------------
HANDLE sub_40161F()
{
  HANDLE result; // rax

  unk_443AA0 = 3i64;
  *((_QWORD *)&unk_443AA0 + 2) = (char *)&unk_443AA0 + 24;
  *((_QWORD *)&unk_443AA0 + 1) = 16i64;
  *((_DWORD *)&unk_443AA0 + 10) = 1;
  *((_DWORD *)&unk_443AA0 + 16) = 1;
  *((_DWORD *)&unk_443AA0 + 22) = 1;
  *((_QWORD *)&unk_443AA0 + 3) = GetStdHandle(0xFFFFFFF6);
  *((_QWORD *)&unk_443AA0 + 6) = GetStdHandle(0xFFFFFFF5);
  result = GetStdHandle(0xFFFFFFF4);
  *((_QWORD *)&unk_443AA0 + 9) = result;
  return result;
}

//----- (0000000000401674) ----------------------------------------------------
__int64 sub_401674()
{
  unsigned int v0; // er13
  int v1; // ebx
  __int16 v4; // [rsp+28h] [rbp-E8h]

  v0 = dword_440668 & 4;
  if ( (dword_440668 & 4) != 0 )
  {
    v0 = 0;
    if ( sub_404C6C() )
      return sub_401EB0() == 2;
  }
  else
  {
    v1 = dword_443C70;
    if ( (unsigned int)sub_401711() != -1 )
      return (v4 & 0xF000) == 0x2000;
    dword_443C70 = v1;
  }
  return v0;
}
// 4016C6: ignored the value written to the shadow area of the succeeding call
// 4016AD: variable 'v4' is possibly undefined
// 440668: using guessed type int dword_440668;
// 443AB0: using guessed type __int64 qword_443AB0;
// 443C70: using guessed type int dword_443C70;

//----- (0000000000401711) ----------------------------------------------------
__int64 sub_401711()
{
  __int64 result; // rax
  unsigned int v1; // [rsp+Ch] [rbp-14h]

  result = sub_404DB0();
  if ( (_DWORD)result != -1 )
  {
    sub_40173E();
    return v1;
  }
  return result;
}
// 40172B: ignored the value written to the shadow area of the succeeding call
// 401733: variable 'v1' is possibly undefined

//----- (000000000040173E) ----------------------------------------------------
void __fastcall sub_40173E()
{
  int *v0; // rdi
  __int64 v1; // r14
  int v2; // er13
  __int64 v3; // r10
  __int64 v4; // r15
  __int64 v5; // r12
  __int64 v6; // r11
  __int64 v7; // r8
  __int64 v8; // rbx
  __int64 v9; // r9
  __int64 v10; // rsi
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rax
  __int64 v14; // r11
  __int64 v15; // rbx
  __int64 v16; // r10
  __int64 v17; // r12
  int v18; // er14
  __int64 v19; // r13
  __int64 v20; // r15

  if ( v0 )
  {
    if ( (dword_440668 & 8) != 0 )
    {
      v1 = *((unsigned __int16 *)v0 + 3);
      v2 = *((unsigned __int16 *)v0 + 2);
      v3 = v0[28];
      v4 = *v0;
      v5 = *((_QWORD *)v0 + 2);
      v6 = *((_QWORD *)v0 + 12);
      v7 = *((_QWORD *)v0 + 5);
      *((_QWORD *)v0 + 5) = v0[6];
      v8 = *((_QWORD *)v0 + 13);
      v9 = *((_QWORD *)v0 + 4);
      v10 = *((_QWORD *)v0 + 6);
      v11 = *((_QWORD *)v0 + 7);
      v12 = *((_QWORD *)v0 + 8);
      v13 = *((_QWORD *)v0 + 9);
      *(_QWORD *)v0 = v4;
      *((_QWORD *)v0 + 2) = v1;
      v0[6] = v2;
      *(_QWORD *)(v0 + 7) = v5;
      *((_QWORD *)v0 + 6) = v6;
      *((_QWORD *)v0 + 7) = v3;
      *((_QWORD *)v0 + 8) = v8;
    }
    else
    {
      if ( (dword_440668 & 0x20) != 0 )
      {
        v14 = v0[32];
        v15 = *((_QWORD *)v0 + 14);
        v16 = *((_QWORD *)v0 + 15);
        v9 = *((_QWORD *)v0 + 6);
        v7 = *((_QWORD *)v0 + 7);
        v10 = *((_QWORD *)v0 + 8);
        v11 = *((_QWORD *)v0 + 9);
        v12 = *((_QWORD *)v0 + 10);
        v13 = *((_QWORD *)v0 + 11);
        v0[6] = *((unsigned __int16 *)v0 + 12);
      }
      else
      {
        if ( (dword_440668 & 0x10) == 0 )
          return;
        v17 = v0[7];
        v18 = *v0;
        v19 = *(_QWORD *)(v0 + 5);
        v14 = v0[24];
        v15 = *((_QWORD *)v0 + 10);
        v16 = *((_QWORD *)v0 + 11);
        v10 = *((_QWORD *)v0 + 6);
        *(_QWORD *)v0 = v0[1];
        v20 = (unsigned int)v0[4];
        v11 = *((_QWORD *)v0 + 7);
        v12 = *((_QWORD *)v0 + 8);
        v13 = *((_QWORD *)v0 + 9);
        v9 = *((_QWORD *)v0 + 4);
        v7 = *((_QWORD *)v0 + 5);
        v0[6] = v18;
        *((_QWORD *)v0 + 2) = v20;
        *(_QWORD *)(v0 + 7) = v19;
        *((_QWORD *)v0 + 5) = v17;
      }
      *((_QWORD *)v0 + 6) = v15;
      *((_QWORD *)v0 + 7) = v14;
      *((_QWORD *)v0 + 8) = v16;
    }
    *((_QWORD *)v0 + 9) = v9;
    *((_QWORD *)v0 + 10) = v7;
    *((_QWORD *)v0 + 11) = v10;
    *((_QWORD *)v0 + 12) = v11;
    *((_QWORD *)v0 + 13) = v12;
    *((_QWORD *)v0 + 14) = v13;
  }
}
// 401741: variable 'v0' is possibly undefined
// 440668: using guessed type int dword_440668;

//----- (000000000040186F) ----------------------------------------------------
__int64 __fastcall sub_40186F(int a1, __int64 a2)
{
  char v2; // zf
  _QWORD *v3; // rdi
  unsigned __int8 *v4; // rsi
  __int64 v5; // rax

  do
  {
    v5 = *v4++;
    *v3++ = a2 + v5;
    --a1;
  }
  while ( a1 );
  *v3 = a2 + v4[(unsigned __int8)((2 * !v2) | ((byte_44003D & 2) != 0))];
  return *(_QWORD *)v4;
}
// 401878: variable 'v4' is possibly undefined
// 40187C: variable 'v3' is possibly undefined
// 40186F: variable 'v2' is possibly undefined
// 44003D: using guessed type char byte_44003D;

//----- (000000000040189D) ----------------------------------------------------
char __fastcall sub_40189D()
{
  _BYTE *v0; // rdi
  char *v1; // rsi
  __int64 v2; // rcx
  char v3; // al
  char *v4; // rsi
  char result; // al

  v2 = 0i64;
  while ( 1 )
  {
    v3 = *v1;
    v4 = v1 + 1;
    LOBYTE(v2) = v3;
    result = *v4;
    v1 = v4 + 1;
    if ( !v2 )
      break;
    do
    {
      *v0++ = result;
      v2 = (unsigned int)(v2 - 1);
    }
    while ( (_DWORD)v2 );
  }
  return result;
}
// 40189F: variable 'v1' is possibly undefined
// 4018A5: variable 'v0' is possibly undefined

//----- (00000000004018AE) ----------------------------------------------------
void __fastcall __noreturn sub_4018AE(__int64 a1, __int64 a2)
{
  sub_4045D5(a1, a2);
  sub_405211();
}
// 4018B9: ignored the value written to the shadow area of the succeeding call

//----- (00000000004018C7) ----------------------------------------------------
__int64 sub_4018C7()
{
  dword_443C70 = dword_4406A8;
  return -1i64;
}
// 4406A8: using guessed type int dword_4406A8;
// 443C70: using guessed type int dword_443C70;

//----- (00000000004018D7) ----------------------------------------------------
__int64 sub_4018D7()
{
  dword_443C70 = dword_4406C0;
  return -1i64;
}
// 4406C0: using guessed type int dword_4406C0;
// 443C70: using guessed type int dword_443C70;

//----- (00000000004018E7) ----------------------------------------------------
__int64 sub_4018E7()
{
  dword_443C70 = dword_4406F8;
  return -1i64;
}
// 4406F8: using guessed type int dword_4406F8;
// 443C70: using guessed type int dword_443C70;

//----- (00000000004018F7) ----------------------------------------------------
__int64 sub_4018F7()
{
  dword_443C70 = dword_440700;
  return -1i64;
}
// 440700: using guessed type int dword_440700;
// 443C70: using guessed type int dword_443C70;

//----- (0000000000401907) ----------------------------------------------------
__int64 sub_401907()
{
  dword_443C70 = dword_440708;
  return -1i64;
}
// 440708: using guessed type int dword_440708;
// 443C70: using guessed type int dword_443C70;

//----- (0000000000401918) ----------------------------------------------------
void __noreturn start()
{
  void (**v0)(void); // rax
  void (**v1)(void); // rcx
  __int64 v2; // rdx
  __int64 v3; // rcx
  HANDLE StdHandle; // rax
  LPWCH EnvironmentStringsW; // r13
  __int64 i; // rax
  unsigned int v7; // eax
  DWORD *v8; // rcx
  char *v9; // r10
  unsigned __int64 v10; // r8
  WCHAR *v11; // rdx
  DWORD *v12; // r11
  __int64 v13; // rax
  unsigned int v14; // er9
  unsigned __int64 v15; // rax
  unsigned int v16; // eax
  __int64 v17; // rax
  unsigned __int64 v18; // rcx
  void (**v19)(void); // [rsp-10h] [rbp-E080h]
  __int64 v20; // [rsp-8h] [rbp-E078h]
  unsigned int v21; // [rsp+2Ch] [rbp-E044h]
  __int64 v22[513]; // [rsp+38h] [rbp-E038h]
  __int64 v23[512]; // [rsp+1040h] [rbp-D030h] BYREF
  DWORD NumberOfBytesWritten[8191]; // [rsp+6040h] [rbp-8030h] BYREF
  char v25; // [rsp+E03Eh] [rbp-32h] BYREF

  v22[0] = 0i64;
  if ( !SetDefaultDllDirectories(0x800u) )
  {
    StdHandle = GetStdHandle(0xFFFFFFF4);
    WriteFile(StdHandle, "nodll\n", 6u, NumberOfBytesWritten, 0i64);
    ExitProcess(1u);
  }
  dword_440668 = 4;
  GetCommandLineW();
  EnvironmentStringsW = GetEnvironmentStringsW();
  sub_401BAD((__int64)v23, 0x3FFFi64);
  for ( i = 0i64; *(_BYTE *)(i + v23[0]); ++i )
  {
    if ( *(_BYTE *)(i + v23[0]) == 92 )
      *(_BYTE *)(i + v23[0]) = 47;
  }
  if ( *EnvironmentStringsW > 0xD7FFu )
  {
    v7 = sub_404E4D();
  }
  else
  {
    v21 = *EnvironmentStringsW;
    v7 = 1;
  }
  v8 = NumberOfBytesWritten;
  v9 = &v25;
  v10 = 0i64;
  v11 = &EnvironmentStringsW[v7];
  v12 = NumberOfBytesWritten;
  while ( v21 )
  {
    if ( ++v10 <= 0x1FF )
    {
      v13 = 0i64;
      if ( v8 < (DWORD *)v9 )
        v13 = (__int64)v8;
      v22[v10] = v13;
    }
    do
    {
      v14 = v21;
      v15 = (int)v21;
      if ( v21 > 0x7F )
        v15 = sub_404E5C();
      do
      {
        if ( v8 >= (DWORD *)v9 )
          break;
        v8 = (DWORD *)((char *)v8 + 1);
        *((_BYTE *)v8 - 1) = v15;
        v15 >>= 8;
      }
      while ( v15 );
      if ( *v11 > 0xD7FFu )
      {
        v16 = sub_404E4D();
      }
      else
      {
        v21 = *v11;
        v16 = 1;
      }
      v11 += v16;
    }
    while ( v14 );
    v17 = (char *)v8 - (char *)v12;
    if ( (unsigned __int64)((char *)v8 - (char *)v12) > 0x7FFD )
      v17 = 32765i64;
    *((_BYTE *)NumberOfBytesWritten + v17) = 0;
  }
  if ( v8 < (DWORD *)v9 )
  {
    *(_BYTE *)v8 = 0;
    v8 = (DWORD *)((char *)v8 + 1);
  }
  v18 = (char *)v8 - (char *)v12;
  if ( v18 > 0x7FFE )
    v18 = 32766i64;
  if ( v10 > 0x1FF )
    v10 = 511i64;
  *((_BYTE *)NumberOfBytesWritten + v18) = 0;
  v22[v10 + 1] = 0i64;
  FreeEnvironmentStringsW(EnvironmentStringsW);
  sub_4012F0();
  dword_443C74 |= 1u;
  v0 = (void (**)(void))&off_406008;
  v1 = (void (**)(void))&unk_406010;
  while ( v1 != v0 )
  {
    (*v0)();
    v1 = v19;
    v0 = (void (**)(void))(v20 + 8);
  }
  sub_4014CE();
  sub_4018AE(v3, v2);
}
// 4015FE: ignored the value written to the shadow area of the succeeding call
// 4015FD: ignored the value written to the shadow area of the succeeding call
// 401A54: variable 'v21' is possibly undefined
// 401A5A: variable 'v10' is possibly undefined
// 401A6C: variable 'v8' is possibly undefined
// 401A6C: variable 'v9' is possibly undefined
// 401AA1: variable 'v11' is possibly undefined
// 401ACA: variable 'v14' is possibly undefined
// 401ACF: variable 'v12' is possibly undefined
// 401601: variable 'v19' is possibly undefined
// 401603: variable 'v20' is possibly undefined
// 40161A: variable 'v3' is possibly undefined
// 40161A: variable 'v2' is possibly undefined
// 406008: using guessed type __int64 (__fastcall *off_406008)();
// 440668: using guessed type int dword_440668;
// 443C74: using guessed type int dword_443C74;
// 401918: using guessed type __int64 var_D030[512];

//----- (0000000000401B52) ----------------------------------------------------
__int64 __fastcall sub_401B52()
{
  unsigned __int16 **v0; // rdi
  _QWORD *v1; // rdx
  int v2; // eax
  unsigned int v3; // eax
  __int64 result; // rax

  v1 = v0;
  v2 = **v0;
  if ( (unsigned __int16)v2 > 0xD7FFu )
  {
    v3 = sub_404E4D();
  }
  else
  {
    *((_DWORD *)v0 + 6) = v2;
    v3 = 1;
  }
  result = 2i64 * v3;
  *v1 += result;
  return result;
}
// 401B52: variable 'v0' is possibly undefined
// 401B79: variable 'v1' is possibly undefined

//----- (0000000000401B7D) ----------------------------------------------------
unsigned __int64 __fastcall sub_401B7D()
{
  __int64 v0; // rdi
  unsigned int v1; // esi
  __int64 v2; // rdx
  unsigned __int64 v3; // r8
  unsigned __int64 result; // rax
  _BYTE *v5; // rcx

  v2 = v0;
  v3 = *(_QWORD *)(v0 + 16);
  result = (int)v1;
  if ( v1 > 0x7F )
    result = sub_404E5C();
  do
  {
    v5 = *(_BYTE **)(v2 + 8);
    if ( v3 <= (unsigned __int64)v5 )
      break;
    *(_QWORD *)(v2 + 8) = v5 + 1;
    *v5 = result;
    result >>= 8;
  }
  while ( result );
  return result;
}
// 401B7D: variable 'v0' is possibly undefined
// 401B89: variable 'v1' is possibly undefined
// 401B93: variable 'v2' is possibly undefined
// 401B9A: variable 'v3' is possibly undefined

//----- (0000000000401BAD) ----------------------------------------------------
__int64 __fastcall sub_401BAD(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 v3; // r15
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // r10
  __int64 v6; // r10
  __int64 v7; // r11
  unsigned __int64 v8; // r11
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // r10
  unsigned __int64 v11; // rax
  __int64 v12; // r12
  __int64 v14; // [rsp+8h] [rbp-58h]
  __int64 v15; // [rsp+8h] [rbp-58h]
  unsigned __int64 v16; // [rsp+18h] [rbp-48h]
  __int64 v17; // [rsp+18h] [rbp-48h]
  unsigned __int64 v18; // [rsp+20h] [rbp-40h]
  unsigned int v19; // [rsp+28h] [rbp-38h]

  v3 = 0x100002600i64;
  v4 = 0i64;
  v18 = v2 + a2;
  sub_401B52();
LABEL_2:
  if ( v19 )
  {
    while ( v19 <= 0x20 && _bittest64(&v3, v19) )
      sub_401B52();
    if ( ++v4 < v5 )
    {
      v11 = v16;
      if ( v16 >= v18 )
        v11 = 0i64;
      *(_QWORD *)(v14 + 8 * v4 - 8) = v11;
    }
    while ( 1 )
    {
      if ( v19 > 0x20 )
      {
        if ( v19 == 34 || v19 == 92 )
        {
          v12 = 0i64;
          while ( v19 == 92 )
          {
            ++v12;
            sub_401B52();
          }
          while ( 1 )
            sub_401B52();
        }
      }
      else if ( _bittest64(&v3, v19) )
      {
        sub_401B7D();
        goto LABEL_2;
      }
      sub_401B7D();
      sub_401B52();
    }
  }
  sub_401B7D();
  if ( v7 )
  {
    v8 = v7 - 1;
    v9 = v17 - v2;
    if ( v17 - v2 > v8 )
      v9 = v8;
    *(_BYTE *)(v2 + v9) = 0;
  }
  if ( v6 )
  {
    v10 = v6 - 1;
    if ( v10 > v4 )
      v10 = v4;
    *(_QWORD *)(v15 + 8 * v10) = 0i64;
  }
  return (unsigned int)v4;
}
// 401BE3: ignored the value written to the shadow area of the succeeding call
// 401BDF: ignored the value written to the shadow area of the succeeding call
// 401BD7: ignored the value written to the shadow area of the succeeding call
// 401D0E: ignored the value written to the shadow area of the succeeding call
// 401BFB: conditional instruction was optimized away because %var_38.4!=0
// 401C83: conditional instruction was optimized away because %var_38.4!=0
// 401C8C: conditional instruction was optimized away because r14.1==0
// 401CCE: conditional instruction was optimized away because %var_38.4==22
// 401BE7: variable 'v2' is possibly undefined
// 401BF4: variable 'v19' is possibly undefined
// 401C21: variable 'v7' is possibly undefined
// 401C2A: variable 'v17' is possibly undefined
// 401C3D: variable 'v6' is possibly undefined
// 401C51: variable 'v15' is possibly undefined
// 401C64: variable 'v5' is possibly undefined
// 401C66: variable 'v16' is possibly undefined
// 401C76: variable 'v14' is possibly undefined

//----- (0000000000401DBA) ----------------------------------------------------
__int64 __fastcall sub_401DBA(__int64 a1, __int64 a2)
{
  HANDLE *v2; // rdi
  __int64 v3; // rsi
  __int64 i; // r12
  struct _OVERLAPPED *v6; // rax
  DWORD v7; // er8
  const void *v8; // rdx
  __int64 j; // rax
  DWORD NumberOfBytesWritten; // [rsp+Ch] [rbp-44h] BYREF

  for ( i = v3; a2 && !*(_QWORD *)(i + 8); i += 16i64 )
    --a2;
  v6 = (struct _OVERLAPPED *)sub_401E5C();
  if ( a2 )
  {
    v7 = *(_DWORD *)(i + 8);
    v8 = *(const void **)i;
  }
  else
  {
    v7 = 0;
    v8 = 0i64;
  }
  if ( !WriteFile(*v2, v8, v7, &NumberOfBytesWritten, v6) )
    return sub_4052D6();
  if ( !NumberOfBytesWritten )
  {
    for ( j = 0i64; a2 != j; ++j )
      ;
  }
  FlushFileBuffers(*v2);
  return NumberOfBytesWritten;
}
// 401DC8: variable 'v3' is possibly undefined
// 401E0C: variable 'v2' is possibly undefined

//----- (0000000000401E5C) ----------------------------------------------------
__int64 __fastcall sub_401E5C()
{
  __int64 v0; // rdi
  __int64 v1; // rsi
  __int64 v2; // rdx
  __int64 v3; // r8
  __int64 v4; // rcx
  _DWORD *v5; // rdi

  v2 = v0;
  v3 = v1;
  if ( v0 == -1 )
    return 0i64;
  v4 = 8i64;
  v5 = (_DWORD *)v1;
  while ( v4 )
  {
    *v5++ = 0;
    --v4;
  }
  *(_QWORD *)(v1 + 16) = v2;
  return v3;
}
// 401E60: variable 'v0' is possibly undefined
// 401E63: variable 'v1' is possibly undefined

//----- (0000000000401E81) ----------------------------------------------------
BOOL __fastcall sub_401E81()
{
  void *v0; // rdi

  return CloseHandle(v0);
}
// 401E92: variable 'v0' is possibly undefined

//----- (0000000000401E9A) ----------------------------------------------------
HANDLE __fastcall sub_401E9A(DWORD dwMaximumSizeHigh, DWORD flProtect, DWORD dwMaximumSizeLow, LPCWSTR lpName)
{
  void *v4; // rdi
  struct _SECURITY_ATTRIBUTES *v5; // rsi
  DWORD nndPreferred; // [rsp+10h] [rbp+10h]

  return CreateFileMappingNumaW(v4, v5, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
}
// 401F3A: variable 'v4' is possibly undefined
// 401F3A: variable 'v5' is possibly undefined

//----- (0000000000401EB0) ----------------------------------------------------
DWORD __fastcall sub_401EB0()
{
  void *v0; // rdi

  return GetFileType(v0);
}
// 401EC1: variable 'v0' is possibly undefined

//----- (0000000000401EC9) ----------------------------------------------------
DWORD sub_401EC9()
{
  return GetLastError();
}

//----- (0000000000401EDF) ----------------------------------------------------
LPVOID __fastcall sub_401EDF(DWORD a1, DWORD a2, SIZE_T a3, void *a4)
{
  void *v4; // rdi
  DWORD v5; // esi
  DWORD v7; // [rsp+10h] [rbp+10h]

  return MapViewOfFileExNuma(v4, v5, a2, a1, a3, a4, v7);
}
// 401F3A: variable 'v4' is possibly undefined
// 401F3A: variable 'v5' is possibly undefined

//----- (0000000000401EF5) ----------------------------------------------------
BOOL __fastcall sub_401EF5()
{
  const void *v0; // rdi

  return UnmapViewOfFile(v0);
}
// 401F06: variable 'v0' is possibly undefined

//----- (0000000000401F47) ----------------------------------------------------
__int64 sub_401F47()
{
  int v0; // eax
  int v2; // ebx

  v0 = sub_401FE7();
  if ( v0 == -1 )
    return 0xFFFFFFFFi64;
  v2 = v0;
  if ( (unsigned int)sub_401F82() == -1 )
    return 0xFFFFFFFFi64;
  else
    return (unsigned int)(v2 + 1);
}
// 442038: using guessed type __int64 qword_442038;

//----- (0000000000401F82) ----------------------------------------------------
__int64 __fastcall sub_401F82()
{
  int v0; // edi
  __int64 v1; // rsi
  int v2; // eax
  int v3; // edx
  __int64 (*v4)(void); // rcx

  if ( v0 == -1 )
    return sub_4020AB();
  *(_BYTE *)(*(_QWORD *)(v1 + 24) + *(unsigned int *)(v1 + 20)) = v0;
  v2 = (*(_DWORD *)(v1 + 32) - 1) & (*(_DWORD *)(v1 + 20) + 1);
  v3 = *(_DWORD *)(v1 + 16);
  *(_DWORD *)(v1 + 20) = v2;
  if ( v2 != v3 && *(_BYTE *)v1 != 2 && (*(_BYTE *)v1 != 1 || (_BYTE)v0 != 10) )
    return (unsigned __int8)v0;
  v4 = *(__int64 (**)(void))(v1 + 48);
  if ( v4 )
    return v4();
  if ( v2 == v3 )
    return sub_4020AB();
  else
    return (unsigned __int8)v0;
}
// 401F8C: variable 'v0' is possibly undefined
// 401F91: variable 'v1' is possibly undefined

//----- (0000000000401FE7) ----------------------------------------------------
__int64 __fastcall sub_401FE7()
{
  char *v0; // rdi
  __int64 v1; // rsi
  int v2; // er14
  char *v3; // r13
  char v4; // dl
  int v5; // eax
  int v6; // ecx
  __int64 (*v7)(void); // rdx
  unsigned int v8; // eax
  unsigned int v9; // er12
  int v10; // eax

  v2 = 0;
  v3 = v0;
  do
  {
    while ( 1 )
    {
      v4 = *v3;
      if ( !*v3 )
        return (unsigned int)(v2 + 1);
      ++v3;
      *(_BYTE *)(*(_QWORD *)(v1 + 24) + *(unsigned int *)(v1 + 20)) = v4;
      v5 = (*(_DWORD *)(v1 + 32) - 1) & (*(_DWORD *)(v1 + 20) + 1);
      v6 = *(_DWORD *)(v1 + 16);
      *(_DWORD *)(v1 + 20) = v5;
      if ( v5 == v6 || *(_BYTE *)v1 == 2 || *(_BYTE *)v1 == 1 && v4 == 10 )
      {
        v7 = *(__int64 (**)(void))(v1 + 48);
        if ( v7 )
        {
          v8 = v7();
        }
        else
        {
          if ( v5 != v6 )
            goto LABEL_15;
          v8 = sub_4020AB();
        }
        v9 = v8;
        if ( v8 == -1 )
          break;
      }
LABEL_15:
      ++v2;
    }
  }
  while ( (int)sub_4020DE() == qword_4406B8 );
  if ( sub_4020D4() )
  {
    v10 = qword_440710;
    *(_DWORD *)(v1 + 8) = qword_440710;
    dword_443C70 = v10;
  }
  return v9;
}
// 401FF2: variable 'v0' is possibly undefined
// 40200A: variable 'v1' is possibly undefined
// 4406B8: using guessed type __int64 qword_4406B8;
// 440710: using guessed type __int64 qword_440710;
// 443C70: using guessed type int dword_443C70;

//----- (00000000004020AB) ----------------------------------------------------
__int64 sub_4020AB()
{
  return sub_4020B3();
}

//----- (00000000004020B3) ----------------------------------------------------
__int64 __fastcall sub_4020B3()
{
  __int64 v0; // rdi
  int v1; // esi
  int v2; // eax

  if ( !v1 )
    v1 = -1;
  v2 = *(_DWORD *)(v0 + 8);
  if ( v2 <= 0 )
    v2 = v1;
  *(_DWORD *)(v0 + 8) = v2;
  if ( v1 > 0 )
    dword_443C70 = v1;
  return -1i64;
}
// 4020B5: variable 'v1' is possibly undefined
// 4020BA: variable 'v0' is possibly undefined
// 443C70: using guessed type int dword_443C70;

//----- (00000000004020D4) ----------------------------------------------------
_BOOL8 __fastcall sub_4020D4()
{
  __int64 v0; // rdi

  return *(_DWORD *)(v0 + 8) == -1;
}
// 4020D6: variable 'v0' is possibly undefined

//----- (00000000004020DE) ----------------------------------------------------
__int64 __fastcall sub_4020DE()
{
  __int64 v0; // rdi
  __int64 result; // rax

  result = 0i64;
  if ( *(int *)(v0 + 8) >= 0 )
    return *(unsigned int *)(v0 + 8);
  return result;
}
// 4020DE: variable 'v0' is possibly undefined

//----- (00000000004020EC) ----------------------------------------------------
__int64 __fastcall sub_4020EC(__int64 a1)
{
  _DWORD *v1; // rdi
  unsigned int v2; // er12
  __int64 i; // r13
  int v4; // eax
  int v5; // eax
  _DWORD *v7; // [rsp+8h] [rbp-18h]

  if ( v1 )
  {
    v2 = 0;
    if ( v1[3] != -1 && (v1[1] & (unsigned int)qword_440798) != 0 )
    {
      v2 = v1[2];
      if ( v2 )
      {
        if ( v2 == -1 )
          return 0;
        else
          return (unsigned int)sub_4020B3();
      }
      else
      {
        while ( v1[4] != v1[5] )
        {
          v5 = sub_4021BE();
          if ( v5 == -1 )
            return (unsigned int)-1;
          v1 = v7;
          v2 += v5;
        }
      }
    }
  }
  else
  {
    v2 = 0;
    for ( i = qword_442040 - 1; i != -1; --i )
    {
      if ( *(_QWORD *)(qword_442050 + 8 * i) )
      {
        v4 = sub_4020EC(a1);
        if ( v4 == -1 )
          return (unsigned int)-1;
        v2 += v4;
      }
    }
  }
  return v2;
}
// 40215F: ignored the value written to the shadow area of the succeeding call
// 4020FB: variable 'v1' is possibly undefined
// 402121: variable 'a1' is possibly undefined
// 40216D: variable 'v7' is possibly undefined
// 440798: using guessed type __int64 qword_440798;
// 442040: using guessed type __int64 qword_442040;
// 442050: using guessed type __int64 qword_442050;

//----- (00000000004021BE) ----------------------------------------------------
__int64 __fastcall sub_4021BE()
{
  _DWORD *v0; // rdi
  unsigned int v1; // esi
  unsigned int v2; // ebx
  unsigned int v3; // ebx
  __int64 v4; // rax

  v1 = v0[4];
  v2 = v0[5];
  if ( v1 >= v2 )
    v2 = v0[8];
  v3 = v2 - v1;
  v4 = sub_404C87();
  if ( v4 == -1 )
    return sub_40228B();
  v0[4] = (v0[8] - 1) & (v0[4] + v4);
  return v3;
}
// 4021C8: variable 'v0' is possibly undefined

//----- (000000000040228B) ----------------------------------------------------
__int64 sub_40228B()
{
  return sub_4020B3();
}
// 443C70: using guessed type int dword_443C70;

//----- (00000000004022A8) ----------------------------------------------------
__int64 __fastcall sub_4022A8(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rax
  __int64 result; // rax

  v4 = v3 & 0xF;
  if ( (v3 & 0xF) != 0 )
    v4 = -((_DWORD)v3 + 16) & 0xF;
  v2[5] = v3 + v4;
  v2[2] = a2 - v4;
  *(_QWORD *)(v3 + v4 + 8) = (a2 - v4) | 1;
  result = qword_442480;
  *(_QWORD *)(v3 + a2 + 8) = 80i64;
  v2[6] = result;
  return result;
}
// 4022AF: variable 'v3' is possibly undefined
// 4022CA: variable 'v2' is possibly undefined
// 442480: using guessed type __int64 qword_442480;

//----- (00000000004022EF) ----------------------------------------------------
__int64 __fastcall sub_4022EF()
{
  __int64 v0; // rdi
  __int64 v1; // r14
  __int64 v2; // r12
  __int64 *v3; // rax
  int v4; // er13
  __int64 v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // rcx
  _QWORD *v10; // rax
  __int64 v11; // rsi
  __int64 v12; // rdx
  _QWORD *v13; // rdx
  _QWORD *v14; // r9
  __int64 v15; // rdx
  __int64 v16; // rdx
  __int64 v17; // rdx
  unsigned __int64 v18; // rdx
  unsigned int v19; // eax
  int v20; // edx
  __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v27; // [rsp+8h] [rbp-38h]

  v1 = 0i64;
  v2 = v0;
  v3 = *(__int64 **)(v0 + 904);
  if ( v3 )
  {
    if ( (v3[3] & 1) != 0 )
    {
      v4 = v3[3] & 8;
      if ( !v4 )
      {
        v5 = *v3;
        v6 = *v3 & 0xF;
        if ( (*v3 & 0xF) != 0 )
          v6 = -(*(_DWORD *)v3 + 16) & 0xF;
        v7 = v5 + v6;
        v1 = 0i64;
        if ( (*(_QWORD *)(v5 + v6 + 8) & 3i64) == 1 )
        {
          v1 = v3[1];
          v8 = *(_QWORD *)(v5 + v6 + 8) & 0xFFFFFFFFFFFFFFF8ui64;
          v9 = v7 + v8;
          if ( v7 + v8 < v5 + v1 - 80 )
            goto LABEL_48;
          if ( *(_QWORD *)(v2 + 32) == v7 )
          {
            *(_QWORD *)(v2 + 32) = 0i64;
            *(_QWORD *)(v2 + 8) = 0i64;
            goto LABEL_32;
          }
          v10 = *(_QWORD **)(v7 + 24);
          v11 = *(_QWORD *)(v7 + 48);
          if ( v10 != (_QWORD *)v7 )
          {
            v12 = *(_QWORD *)(v7 + 16);
            *(_QWORD *)(v12 + 24) = v10;
            v10[2] = v12;
            goto LABEL_19;
          }
          v10 = (_QWORD *)v10[5];
          v9 = v7 + 40;
          if ( !v10 )
          {
            v10 = *(_QWORD **)(v7 + 32);
            if ( !v10 )
              goto LABEL_19;
            v9 = v7 + 32;
          }
          v13 = v10;
          do
          {
            do
            {
              v14 = (_QWORD *)v9;
              v10 = v13;
              v9 = (__int64)(v13 + 5);
              v13 = (_QWORD *)v13[5];
            }
            while ( v13 );
            v13 = (_QWORD *)v10[4];
            v9 = (__int64)(v10 + 4);
          }
          while ( v13 );
          *v14 = 0i64;
LABEL_19:
          if ( v11 )
          {
            v9 = *(unsigned int *)(v7 + 56);
            v15 = v2 + 8 * v9;
            if ( *(_QWORD *)(v15 + 600) == v7 )
            {
              *(_QWORD *)(v15 + 600) = v10;
              if ( !v10 )
              {
                *(_DWORD *)(v2 + 4) &= __ROL4__(-2, v9);
                goto LABEL_32;
              }
            }
            else
            {
              if ( *(_QWORD *)(v11 + 32) == v7 )
                *(_QWORD *)(v11 + 32) = v10;
              else
                *(_QWORD *)(v11 + 40) = v10;
              if ( !v10 )
                goto LABEL_32;
            }
            v16 = *(_QWORD *)(v7 + 32);
            v10[6] = v11;
            if ( v16 )
            {
              v10[4] = v16;
              *(_QWORD *)(v16 + 48) = v10;
            }
            v17 = *(_QWORD *)(v7 + 40);
            if ( v17 )
            {
              v10[5] = v17;
              *(_QWORD *)(v17 + 48) = v10;
            }
          }
LABEL_32:
          if ( !(unsigned int)sub_40452C(v9) )
          {
            *(_QWORD *)(v2 + 856) -= v1;
            *(_QWORD *)(v2 + 904) = v27;
            goto LABEL_49;
          }
          v18 = v8 >> 8;
          v19 = v8 >> 8;
          if ( v19 )
          {
            v19 = 31;
            if ( (unsigned int)v18 <= 0xFFFF )
            {
              _BitScanReverse((unsigned int *)&v18, v18);
              v19 = ((v8 >> (38 - ((unsigned __int8)v18 ^ 0x1Fu))) & 1) + 2 * (31 - (v18 ^ 0x1F));
            }
          }
          v20 = *(_DWORD *)(v2 + 4);
          *(_DWORD *)(v7 + 56) = v19;
          *(_QWORD *)(v7 + 40) = 0i64;
          *(_QWORD *)(v7 + 32) = 0i64;
          if ( ((1 << v19) & v20) != 0 )
          {
            v21 = *(_QWORD *)(v2 + 8i64 * v19 + 600);
            if ( v19 != 31 )
              LOBYTE(v4) = 57 - (v19 >> 1);
            v22 = v8 << v4;
            while ( (*(_QWORD *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8ui64) != v8 )
            {
              v23 = v22;
              v22 *= 2i64;
              v24 = (v23 >> 63) + 4;
              if ( !*(_QWORD *)(v21 + 8 * v24) )
              {
                *(_QWORD *)(v21 + 8 * v24) = v7;
                *(_QWORD *)(v7 + 48) = v21;
                goto LABEL_46;
              }
              v21 = *(_QWORD *)(v21 + 8 * v24);
            }
            v25 = *(_QWORD *)(v21 + 16);
            *(_QWORD *)(v25 + 24) = v7;
            *(_QWORD *)(v21 + 16) = v7;
            *(_QWORD *)(v7 + 16) = v25;
            *(_QWORD *)(v7 + 24) = v21;
            *(_QWORD *)(v7 + 48) = 0i64;
          }
          else
          {
            *(_DWORD *)(v2 + 4) = (1 << v19) | v20;
            *(_QWORD *)(v2 + 8i64 * v19 + 600) = v7;
            *(_QWORD *)(v7 + 48) = v2 + 8i64 * v19 + 600;
LABEL_46:
            *(_QWORD *)(v7 + 24) = v7;
            *(_QWORD *)(v7 + 16) = v7;
          }
LABEL_48:
          v1 = 0i64;
        }
      }
    }
  }
LABEL_49:
  *(_QWORD *)(v2 + 56) = 128i64;
  return v1;
}
// 40246F: ignored the value written to the shadow area of the succeeding call
// 4022FE: variable 'v0' is possibly undefined
// 402488: variable 'v27' is possibly undefined

//----- (00000000004025AC) ----------------------------------------------------
_BOOL8 __fastcall sub_4025AC()
{
  _QWORD *v0; // rdi
  unsigned __int64 v1; // rsi
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // rax
  _QWORD *v4; // r12
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rbx
  _QWORD *v8; // rcx
  unsigned __int64 *v9; // r13
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // r9
  int v12; // eax
  __int64 v13; // rcx
  __int64 v14; // rdx

  if ( v1 > 0xFFFFFFFFFFFFFF7Fui64 || (v3 = v0[5], v4 = v0, !v3) )
  {
LABEL_2:
    v2 = 0i64;
    return v2 != 0;
  }
  v5 = v0[2];
  v6 = v1 + 80;
  if ( v5 > v6 )
  {
    v8 = v0 + 111;
    v9 = v0 + 111;
    while ( 1 )
    {
      v10 = *v9;
      if ( v3 >= *v9 )
      {
        v11 = v9[1];
        if ( v3 < v10 + v11 )
          break;
      }
      v9 = (unsigned __int64 *)v9[2];
      if ( !v9 )
        BUG();
    }
    v12 = *((_DWORD *)v9 + 6);
    if ( (v12 & 8) == 0 && (v12 & 1) != 0 )
    {
      v7 = qword_442470 * ((v5 + qword_442470 - 1 - v6) / qword_442470 - 1);
      if ( v7 <= v11 )
      {
        while ( v10 > (unsigned __int64)v8 || v10 + v11 <= (unsigned __int64)v8 )
        {
          v8 = (_QWORD *)v8[2];
          if ( !v8 )
          {
            if ( sub_404ABB() == -1 && (unsigned int)sub_40452C(v13) )
              break;
            if ( v7 )
            {
              v9[1] -= v7;
              v14 = v4[2];
              v4[107] -= v7;
              sub_4022A8(v13, v14 - v7);
            }
            goto LABEL_21;
          }
        }
      }
    }
  }
  v7 = 0i64;
LABEL_21:
  v2 = sub_4022EF() + v7;
  if ( !v2 )
  {
    if ( v4[2] > v4[6] )
    {
      v4[6] = -1i64;
      return v2 != 0;
    }
    goto LABEL_2;
  }
  return v2 != 0;
}
// 4025BE: variable 'v1' is possibly undefined
// 4025C7: variable 'v0' is possibly undefined
// 40267E: variable 'v13' is possibly undefined
// 442470: using guessed type __int64 qword_442470;

//----- (00000000004026E8) ----------------------------------------------------
__int64 __fastcall sub_4026E8(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rbx
  __int64 v5; // rdi
  __int64 result; // rax
  __int64 v7; // rsi
  unsigned __int64 v8; // r8
  __int64 v9; // r12
  unsigned __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r8
  __int64 v13; // rcx
  _QWORD *v14; // r9
  __int64 v15; // rcx
  _QWORD *v16; // r10
  __int64 v17; // rcx
  __int64 v18; // r9
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r10
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // r8
  _QWORD *v26; // rax
  _QWORD *v27; // rsi
  __int64 v28; // r8
  __int64 v29; // rcx
  _QWORD *v30; // r9
  _QWORD *v31; // rcx
  _QWORD *v32; // r11
  __int64 v33; // rcx
  __int64 v34; // r9
  __int64 v35; // rcx
  __int64 v36; // rcx
  unsigned __int64 v37; // rcx
  __int64 v38; // rdx
  unsigned __int64 v39; // rsi
  unsigned int v40; // eax
  int v41; // esi
  int v42; // ecx
  __int64 v43; // r8
  char v44; // cl
  __int64 v45; // rsi
  unsigned __int64 v46; // rcx
  unsigned __int64 v47; // rax

  v4 = v2;
  v5 = v3;
  result = *(_QWORD *)(v3 + 8);
  v7 = a2 + v3;
  if ( (result & 1) != 0 )
    goto LABEL_34;
  v8 = *(_QWORD *)v5;
  v5 -= *(_QWORD *)v5;
  if ( (result & 3) == 0 )
  {
    v9 = v8 + a2 + 32;
    result = sub_40452C(a1);
    if ( !(_DWORD)result )
      *(_QWORD *)(v4 + 856) -= v9;
    return result;
  }
  a2 += v8;
  if ( *(_QWORD *)(v4 + 32) == v5 )
  {
    result = *(_QWORD *)(v7 + 8);
    if ( (result & 3) == 3 )
    {
      *(_QWORD *)(v4 + 8) = a2;
      *(_QWORD *)(v7 + 8) = result & 0xFFFFFFFFFFFFFFFEui64;
      result = a2 | 1;
      *(_QWORD *)(v5 + 8) = a2 | 1;
      *(_QWORD *)v7 = a2;
      return result;
    }
    goto LABEL_34;
  }
  result = *(_QWORD *)(v5 + 24);
  v10 = v8 >> 3;
  if ( v8 <= 0xFF )
  {
    v11 = *(_QWORD *)(v5 + 16);
    if ( v11 == result )
    {
      result = (unsigned int)__ROL4__(-2, v10);
      *(_DWORD *)v4 &= result;
    }
    else
    {
      *(_QWORD *)(v11 + 24) = result;
      *(_QWORD *)(result + 16) = v11;
    }
    goto LABEL_34;
  }
  v12 = *(_QWORD *)(v5 + 48);
  if ( v5 == result )
  {
    result = *(_QWORD *)(v5 + 40);
    v14 = (_QWORD *)(v5 + 40);
    if ( !result )
    {
      result = *(_QWORD *)(v5 + 32);
      if ( !result )
        goto LABEL_19;
      v14 = (_QWORD *)(v5 + 32);
    }
    v15 = result;
    do
    {
      do
      {
        v16 = v14;
        result = v15;
        v14 = (_QWORD *)(v15 + 40);
        v15 = *(_QWORD *)(v15 + 40);
      }
      while ( v15 );
      v15 = *(_QWORD *)(result + 32);
      v14 = (_QWORD *)(result + 32);
    }
    while ( v15 );
    *v16 = 0i64;
    goto LABEL_19;
  }
  v13 = *(_QWORD *)(v5 + 16);
  *(_QWORD *)(v13 + 24) = result;
  *(_QWORD *)(result + 16) = v13;
LABEL_19:
  if ( !v12 )
    goto LABEL_34;
  v17 = *(unsigned int *)(v5 + 56);
  v18 = v4 + 8 * v17;
  if ( *(_QWORD *)(v18 + 600) == v5 )
  {
    *(_QWORD *)(v18 + 600) = result;
    if ( !result )
    {
      result = (unsigned int)__ROL4__(-2, v17);
      *(_DWORD *)(v4 + 4) &= result;
      goto LABEL_34;
    }
  }
  else
  {
    if ( *(_QWORD *)(v12 + 32) == v5 )
      *(_QWORD *)(v12 + 32) = result;
    else
      *(_QWORD *)(v12 + 40) = result;
    if ( !result )
      goto LABEL_34;
  }
  v19 = *(_QWORD *)(v5 + 32);
  *(_QWORD *)(result + 48) = v12;
  if ( v19 )
  {
    *(_QWORD *)(result + 32) = v19;
    *(_QWORD *)(v19 + 48) = result;
  }
  v20 = *(_QWORD *)(v5 + 40);
  if ( v20 )
  {
    *(_QWORD *)(result + 40) = v20;
    *(_QWORD *)(v20 + 48) = result;
  }
LABEL_34:
  v21 = *(_QWORD *)(v7 + 8);
  if ( (v21 & 2) == 0 )
  {
    v22 = *(_QWORD *)(v4 + 32);
    if ( *(_QWORD *)(v4 + 40) == v7 )
    {
      v23 = *(_QWORD *)(v4 + 16) + a2;
      *(_QWORD *)(v4 + 40) = v5;
      *(_QWORD *)(v4 + 16) = v23;
      *(_QWORD *)(v5 + 8) = v23 | 1;
      if ( v5 == v22 )
      {
        *(_QWORD *)(v4 + 32) = 0i64;
        *(_QWORD *)(v4 + 8) = 0i64;
      }
      return result;
    }
    if ( v7 == v22 )
    {
      v24 = *(_QWORD *)(v4 + 8) + a2;
      *(_QWORD *)(v4 + 32) = v5;
      *(_QWORD *)(v4 + 8) = v24;
      result = v24 | 1;
      *(_QWORD *)(v5 + 8) = v24 | 1;
      *(_QWORD *)(v5 + v24) = v24;
      return result;
    }
    v25 = v21 & 0xFFFFFFFFFFFFFFF8ui64;
    v26 = *(_QWORD **)(v7 + 24);
    a2 += v25;
    if ( v25 <= 0xF8 )
    {
      v27 = *(_QWORD **)(v7 + 16);
      if ( v27 == v26 )
      {
        *(_DWORD *)v4 &= __ROL4__(-2, v25 >> 3);
      }
      else
      {
        v27[3] = v26;
        v26[2] = v27;
      }
      goto LABEL_66;
    }
    v28 = *(_QWORD *)(v7 + 48);
    if ( (_QWORD *)v7 != v26 )
    {
      v29 = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(v29 + 24) = v26;
      v26[2] = v29;
      goto LABEL_53;
    }
    v26 = *(_QWORD **)(v7 + 40);
    v30 = (_QWORD *)(v7 + 40);
    if ( !v26 )
    {
      v26 = *(_QWORD **)(v7 + 32);
      if ( !v26 )
        goto LABEL_53;
      v30 = (_QWORD *)(v7 + 32);
    }
    v31 = v26;
    do
    {
      do
      {
        v32 = v30;
        v26 = v31;
        v30 = v31 + 5;
        v31 = (_QWORD *)v31[5];
      }
      while ( v31 );
      v31 = (_QWORD *)v26[4];
      v30 = v26 + 4;
    }
    while ( v31 );
    *v32 = 0i64;
LABEL_53:
    if ( !v28 )
      goto LABEL_66;
    v33 = *(unsigned int *)(v7 + 56);
    v34 = v4 + 8 * v33;
    if ( *(_QWORD *)(v34 + 600) == v7 )
    {
      *(_QWORD *)(v34 + 600) = v26;
      if ( !v26 )
      {
        *(_DWORD *)(v4 + 4) &= __ROL4__(-2, v33);
        goto LABEL_66;
      }
    }
    else
    {
      if ( *(_QWORD *)(v28 + 32) == v7 )
        *(_QWORD *)(v28 + 32) = v26;
      else
        *(_QWORD *)(v28 + 40) = v26;
      if ( !v26 )
        goto LABEL_66;
    }
    v35 = *(_QWORD *)(v7 + 32);
    v26[6] = v28;
    if ( v35 )
    {
      v26[4] = v35;
      *(_QWORD *)(v35 + 48) = v26;
    }
    v36 = *(_QWORD *)(v7 + 40);
    if ( v36 )
    {
      v26[5] = v36;
      *(_QWORD *)(v36 + 48) = v26;
    }
LABEL_66:
    result = a2 | 1;
    *(_QWORD *)(v5 + 8) = a2 | 1;
    *(_QWORD *)(v5 + a2) = a2;
    if ( v5 == v22 )
    {
      *(_QWORD *)(v4 + 8) = a2;
      return result;
    }
    goto LABEL_69;
  }
  *(_QWORD *)(v7 + 8) = v21 & 0xFFFFFFFFFFFFFFFEui64;
  *(_QWORD *)(v5 + 8) = a2 | 1;
  *(_QWORD *)(v5 + a2) = a2;
LABEL_69:
  v37 = a2 >> 3;
  if ( a2 > 0xFF )
  {
    v39 = a2 >> 8;
    v40 = a2 >> 8;
    if ( v40 )
    {
      v40 = 31;
      if ( (unsigned int)v39 <= 0xFFFF )
      {
        _BitScanReverse((unsigned int *)&v39, v39);
        v40 = ((a2 >> (38 - ((unsigned __int8)v39 ^ 0x1Fu))) & 1) + 2 * (31 - (v39 ^ 0x1F));
      }
    }
    v41 = *(_DWORD *)(v4 + 4);
    *(_DWORD *)(v5 + 56) = v40;
    *(_QWORD *)(v5 + 40) = 0i64;
    v42 = 1 << v40;
    *(_QWORD *)(v5 + 32) = 0i64;
    v43 = v40;
    if ( ((1 << v40) & v41) != 0 )
    {
      v44 = 0;
      v45 = *(_QWORD *)(v4 + 8i64 * v40 + 600);
      if ( v40 != 31 )
        v44 = 57 - (v40 >> 1);
      v46 = a2 << v44;
      while ( (*(_QWORD *)(v45 + 8) & 0xFFFFFFFFFFFFFFF8ui64) != a2 )
      {
        v47 = v46;
        v46 *= 2i64;
        result = (v47 >> 63) + 4;
        if ( !*(_QWORD *)(v45 + 8 * result) )
        {
          *(_QWORD *)(v45 + 8 * result) = v5;
          *(_QWORD *)(v5 + 48) = v45;
          goto LABEL_86;
        }
        v45 = *(_QWORD *)(v45 + 8 * result);
      }
      result = *(_QWORD *)(v45 + 16);
      *(_QWORD *)(result + 24) = v5;
      *(_QWORD *)(v45 + 16) = v5;
      *(_QWORD *)(v5 + 16) = result;
      *(_QWORD *)(v5 + 24) = v45;
      *(_QWORD *)(v5 + 48) = 0i64;
    }
    else
    {
      result = v4 + 8i64 * v40 + 600;
      *(_DWORD *)(v4 + 4) = v42 | v41;
      *(_QWORD *)(v4 + 8 * v43 + 600) = v5;
      *(_QWORD *)(v5 + 48) = result;
LABEL_86:
      *(_QWORD *)(v5 + 24) = v5;
      *(_QWORD *)(v5 + 16) = v5;
    }
  }
  else
  {
    result = v4 + 8i64 * (unsigned int)(2 * v37) + 72;
    if ( ((1 << v37) & *(_DWORD *)v4) != 0 )
    {
      v38 = *(_QWORD *)(v4 + 8i64 * (unsigned int)(2 * v37) + 88);
    }
    else
    {
      *(_DWORD *)v4 |= 1 << v37;
      v38 = v4 + 8i64 * (unsigned int)(2 * v37) + 72;
    }
    *(_QWORD *)(v4 + 8i64 * (unsigned int)(2 * v37) + 88) = v5;
    *(_QWORD *)(v38 + 24) = v5;
    *(_QWORD *)(v5 + 16) = v38;
    *(_QWORD *)(v5 + 24) = result;
  }
  return result;
}
// 4026EF: variable 'v2' is possibly undefined
// 4026F2: variable 'v3' is possibly undefined

//----- (0000000000402B64) ----------------------------------------------------
unsigned __int64 __fastcall sub_402B64()
{
  unsigned __int64 v0; // rdi
  unsigned __int64 v1; // rbx
  int v2; // esi
  unsigned __int64 v3; // rcx
  unsigned int v4; // eax
  int v5; // ecx
  __int64 v6; // rdi
  __int128 v7; // rax
  __int64 v8; // r8
  unsigned __int64 v9; // r9
  int v10; // eax
  int v11; // ecx
  __int64 v12; // rdi
  __int64 v13; // r10
  __int64 v14; // r11
  __int64 v15; // rsi
  unsigned __int64 v16; // rcx
  __int64 v17; // rbx
  __int64 v18; // rdx
  int v19; // er11
  __int64 v20; // rcx
  int v21; // edi
  unsigned int v22; // eax
  __int64 v23; // rcx
  unsigned __int64 v24; // r8
  __int64 v25; // r10
  unsigned __int64 v26; // r12
  __int64 v27; // rcx
  __int64 v28; // r11
  __int64 v29; // rcx
  _QWORD *v30; // r13
  __int64 v31; // r11
  __int64 v32; // rcx
  __int64 v33; // rcx
  __int64 v34; // r10
  __int64 v35; // rdx
  unsigned __int64 v36; // rcx
  int v37; // er9
  __int64 v38; // rdi
  __int64 v39; // rcx
  unsigned __int64 v40; // rbx
  int v41; // edi
  unsigned __int64 v42; // rax
  unsigned __int64 v43; // r9
  unsigned int v44; // esi
  char v45; // cl
  __int64 v46; // r11
  __int64 v47; // r10
  unsigned __int64 i; // rcx
  unsigned __int64 v49; // rdx
  unsigned int v50; // eax
  __int64 v51; // rcx
  __int64 v52; // rsi
  unsigned __int64 v53; // r10
  __int64 v54; // rcx
  __int64 v55; // r8
  __int64 v56; // rcx
  _QWORD *v57; // r11
  __int64 v58; // r8
  __int64 v59; // rcx
  __int64 v60; // rcx
  __int64 v61; // r8
  unsigned __int64 v62; // rcx
  int v63; // edi
  __int64 v64; // rdx
  __int64 v65; // rcx
  unsigned __int64 v66; // rsi
  unsigned int v67; // edx
  int v68; // esi
  char v69; // cl
  __int64 v70; // rsi
  unsigned __int64 v71; // rcx
  unsigned __int64 v72; // rdx
  __int64 v73; // rdx
  __int64 v74; // rdx
  unsigned __int64 v75; // rcx
  unsigned __int64 *v76; // rsi
  __int64 v77; // rdx
  unsigned __int64 v78; // r12
  unsigned __int64 v79; // r12
  unsigned __int64 v80; // r12
  __int64 v81; // rcx
  unsigned __int64 v82; // r9
  __int64 v83; // rax
  __int64 v84; // r10
  _QWORD *v85; // rax
  __int64 v86; // rdx
  __int64 v87; // rax
  __int64 *v88; // rcx
  char v89; // r11
  __int64 v90; // rcx
  __int64 v91; // rdx
  __int64 v92; // rax
  unsigned __int64 v93; // r8
  __int64 v94; // r8
  unsigned __int64 v95; // rdi
  _QWORD *v96; // rsi
  unsigned __int64 v97; // rbx
  unsigned __int64 v98; // rcx
  _QWORD *v99; // rdi
  __int64 v100; // rdi
  __int64 v101; // rcx
  _QWORD *v102; // r10
  _QWORD *v103; // rcx
  _QWORD *v104; // r12
  __int64 v105; // r10
  int v106; // ecx
  __int64 v107; // rcx
  __int64 v108; // rcx
  unsigned __int64 v109; // rcx
  int v110; // edi
  __int64 v111; // rdx
  __int64 v112; // rcx
  unsigned __int64 v113; // rsi
  unsigned int v114; // edx
  int v115; // esi
  __int64 v116; // rsi
  unsigned __int64 v117; // rcx
  unsigned __int64 v118; // rdx
  __int64 v119; // rdx
  __int64 v120; // rdx
  unsigned __int64 v122; // r13
  __int64 v123; // r9
  __int64 v124; // r10
  _QWORD *v125; // r11
  _DWORD *v126; // rdi
  __int64 *v127; // rsi
  __int64 j; // rcx
  _QWORD *v129; // rax
  unsigned __int64 v130; // rsi
  unsigned __int64 v131; // rcx
  __int64 v132; // rdx
  unsigned __int64 v133; // rdx
  unsigned int v134; // eax
  int v135; // edx
  char v136; // cl
  __int64 v137; // rdx
  unsigned __int64 v138; // rcx
  unsigned __int64 v139; // rax
  __int64 v140; // rax
  __int64 v141; // rax

  if ( v0 <= 0xE0 )
  {
    v1 = 32i64;
    if ( v0 > 0xE )
      v1 = (v0 + 31) & 0xFFFFFFFFFFFFFFF0ui64;
    v2 = dword_4420A0;
    v3 = v1 >> 3;
    v4 = (unsigned int)dword_4420A0 >> (v1 >> 3);
    if ( (v4 & 3) != 0 )
    {
      v5 = ((v4 & 1) == 0) + (_DWORD)v3;
      v6 = 8i64 * (unsigned int)(2 * v5) + 4464872;
      *(_QWORD *)&v7 = qword_4420F8[2 * v5];
      v8 = *(_QWORD *)(v7 + 16);
      if ( v6 == v8 )
      {
        dword_4420A0 &= ~(1 << v5);
      }
      else
      {
        *(_QWORD *)(v8 + 24) = v6;
        qword_4420F8[2 * v5] = v8;
      }
      *(_QWORD *)(v7 + 8) = (8 * v5) | 3u;
      *(_QWORD *)(v7 + (unsigned int)(8 * v5) + 8) |= 1ui64;
      return v7 + 16;
    }
    v9 = qword_4420A8[0];
    if ( qword_4420A8[0] < v1 )
    {
      if ( v4 )
      {
        v10 = ((2 * (1 << v3)) | (-2 * (1 << v3))) & (v4 << v3);
        _BitScanForward((unsigned int *)&v3, -v10 & v10);
        v12 = (unsigned int)(8 * v11);
        v13 = 8i64 * (unsigned int)(2 * v11) + 4464872;
        *(_QWORD *)&v7 = qword_4420F8[2 * v11];
        v14 = *(_QWORD *)(v7 + 16);
        if ( v13 == v14 )
        {
          dword_4420A0 &= ~(1 << v3);
        }
        else
        {
          *(_QWORD *)(v14 + 24) = v13;
          qword_4420F8[(unsigned int)(2 * v3)] = v14;
        }
        *((_QWORD *)&v7 + 1) = v7 + v12;
        v15 = v12 - v1;
        if ( v12 - v1 > 0x1F )
        {
          v16 = v1;
          v17 = v7 + v1;
          *(_QWORD *)(v7 + 8) = v16 | 3;
          *(_QWORD *)(v17 + 8) = v15 | 1;
          **((_QWORD **)&v7 + 1) = v15;
          if ( v9 )
          {
            v18 = qword_4420C0;
            v19 = 1 << (v9 >> 3);
            if ( (v19 & dword_4420A0) != 0 )
            {
              v20 = qword_4420F8[2 * (unsigned int)(v9 >> 3)];
            }
            else
            {
              v20 = 16i64 * (unsigned int)(v9 >> 3) + 4464872;
              dword_4420A0 |= v19;
            }
            qword_4420F8[2 * (unsigned int)(v9 >> 3)] = qword_4420C0;
            *(_QWORD *)(v20 + 24) = v18;
            *(_QWORD *)(v18 + 16) = v20;
            *(_QWORD *)(v18 + 24) = 16i64 * (unsigned int)(v9 >> 3) + 4464872;
          }
          qword_4420A8[0] = v15;
          qword_4420C0 = v17;
        }
        else
        {
          *(_QWORD *)(v7 + 8) = (8 * (_DWORD)v3) | 3u;
          *(_QWORD *)(*((_QWORD *)&v7 + 1) + 8i64) |= 1ui64;
        }
        return v7 + 16;
      }
      v21 = dword_4420A4;
      if ( dword_4420A4 )
      {
        _BitScanForward(&v22, dword_4420A4 & -dword_4420A4);
        *(_QWORD *)&v7 = qword_4422F8[v22];
        v23 = v7;
        v24 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8ui64) - v1;
        while ( 1 )
        {
          *((_QWORD *)&v7 + 1) = *(_QWORD *)(v23 + 32);
          if ( !*((_QWORD *)&v7 + 1) )
          {
            *((_QWORD *)&v7 + 1) = *(_QWORD *)(v23 + 40);
            if ( !*((_QWORD *)&v7 + 1) )
              break;
          }
          if ( (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8i64) & 0xFFFFFFFFFFFFFFF8ui64) - v1 < v24 )
          {
            v24 = (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8i64) & 0xFFFFFFFFFFFFFFF8ui64) - v1;
            *(_QWORD *)&v7 = *((_QWORD *)&v7 + 1);
          }
          v23 = *((_QWORD *)&v7 + 1);
        }
        *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 24);
        v25 = *(_QWORD *)(v7 + 48);
        v26 = v1 + v24;
        if ( *((_QWORD *)&v7 + 1) != (_QWORD)v7 )
        {
          v27 = *(_QWORD *)(v7 + 16);
          *(_QWORD *)(v27 + 24) = *((_QWORD *)&v7 + 1);
          *(_QWORD *)(*((_QWORD *)&v7 + 1) + 16i64) = v27;
          goto LABEL_38;
        }
        *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
        v28 = v7 + 40;
        if ( !*((_QWORD *)&v7 + 1) )
        {
          *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 32);
          if ( !*((_QWORD *)&v7 + 1) )
            goto LABEL_38;
          v28 = v7 + 32;
        }
        v29 = *((_QWORD *)&v7 + 1);
        do
        {
          do
          {
            v30 = (_QWORD *)v28;
            *((_QWORD *)&v7 + 1) = v29;
            v28 = v29 + 40;
            v29 = *(_QWORD *)(v29 + 40);
          }
          while ( v29 );
          v29 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32i64);
          v28 = *((_QWORD *)&v7 + 1) + 32i64;
        }
        while ( v29 );
        *v30 = 0i64;
LABEL_38:
        if ( v25 )
        {
          v31 = *(unsigned int *)(v7 + 56);
          if ( qword_4422F8[v31] == (_QWORD)v7 )
          {
            qword_4420A8[v31 + 74] = *((_QWORD *)&v7 + 1);
            if ( *((_QWORD *)&v7 + 1) )
            {
LABEL_41:
              v32 = *(_QWORD *)(v7 + 32);
              *(_QWORD *)(*((_QWORD *)&v7 + 1) + 48i64) = v25;
              if ( v32 )
              {
                *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32i64) = v32;
                *(_QWORD *)(v32 + 48) = *((_QWORD *)&v7 + 1);
              }
              v33 = *(_QWORD *)(v7 + 40);
              if ( v33 )
              {
                *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40i64) = v33;
                *(_QWORD *)(v33 + 48) = *((_QWORD *)&v7 + 1);
              }
              goto LABEL_51;
            }
            dword_4420A4 = v21 & ~(1 << v31);
          }
          else
          {
            if ( *(_QWORD *)(v25 + 32) == (_QWORD)v7 )
              *(_QWORD *)(v25 + 32) = *((_QWORD *)&v7 + 1);
            else
              *(_QWORD *)(v25 + 40) = *((_QWORD *)&v7 + 1);
            if ( *((_QWORD *)&v7 + 1) )
              goto LABEL_41;
          }
        }
LABEL_51:
        if ( v24 > 0x1F )
        {
          v34 = v7 + v1;
          *(_QWORD *)(v7 + 8) = v1 | 3;
          *(_QWORD *)(v34 + 8) = v24 | 1;
          *(_QWORD *)(v34 + v24) = v24;
          if ( v9 )
          {
            v35 = qword_4420C0;
            v36 = v9 >> 3;
            v37 = 1 << (v9 >> 3);
            v38 = 8i64 * (unsigned int)(2 * v36) + 4464872;
            if ( (v37 & v2) != 0 )
            {
              v39 = qword_4420F8[(unsigned int)(2 * v36)];
            }
            else
            {
              v39 = 8i64 * (unsigned int)(2 * v36) + 4464872;
              dword_4420A0 = v37 | v2;
            }
            *(_QWORD *)(v38 + 16) = qword_4420C0;
            *(_QWORD *)(v39 + 24) = v35;
            *(_QWORD *)(v35 + 16) = v39;
            *(_QWORD *)(v35 + 24) = v38;
          }
          qword_4420A8[0] = v24;
          qword_4420C0 = v7 + v1;
        }
        else
        {
          *(_QWORD *)(v7 + 8) = v26 | 3;
          *(_QWORD *)(v7 + v26 + 8) |= 1ui64;
        }
        return v7 + 16;
      }
    }
    goto LABEL_133;
  }
  if ( v0 > 0xFFFFFFFFFFFFFF7Fui64 )
  {
    v1 = -1i64;
    goto LABEL_133;
  }
  v40 = v0 + 31;
  v41 = dword_4420A4;
  v1 = v40 & 0xFFFFFFFFFFFFFFF0ui64;
  if ( !dword_4420A4 )
    goto LABEL_133;
  v42 = v1 >> 8;
  v43 = -(__int64)v1;
  v44 = v1 >> 8;
  if ( v44 )
  {
    v44 = 31;
    if ( (unsigned int)v42 <= 0xFFFF )
    {
      _BitScanReverse((unsigned int *)&v42, v42);
      v44 = ((v1 >> (38 - ((unsigned __int8)v42 ^ 0x1Fu))) & 1) + 2 * (31 - (v42 ^ 0x1F));
    }
  }
  v7 = (unsigned __int64)qword_4422F8[v44];
  if ( (_QWORD)v7 )
  {
    v45 = 0;
    if ( v44 != 31 )
      v45 = 57 - (v44 >> 1);
    v46 = 0i64;
    v47 = 0i64;
    for ( i = v1 << v45; ; i *= 2i64 )
    {
      v49 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8ui64) - v1;
      if ( v49 < v43 )
      {
        if ( !v49 )
        {
          *((_QWORD *)&v7 + 1) = v7;
          v43 = 0i64;
          goto LABEL_78;
        }
        v43 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8ui64) - v1;
        v47 = v7;
      }
      *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
      *(_QWORD *)&v7 = *(_QWORD *)(v7 + 8 * ((i >> 63) + 4));
      if ( !*((_QWORD *)&v7 + 1) || *((_QWORD *)&v7 + 1) == (_QWORD)v7 )
        *((_QWORD *)&v7 + 1) = v46;
      if ( !(_QWORD)v7 )
        break;
      v46 = *((_QWORD *)&v7 + 1);
    }
    *(_QWORD *)&v7 = v47;
  }
LABEL_78:
  if ( v7 == 0 )
  {
    if ( (dword_4420A4 & (-2 << v44)) == 0 )
      goto LABEL_133;
    _BitScanForward(&v50, dword_4420A4 & (-2 << v44) & -(dword_4420A4 & (-2 << v44)));
    *((_QWORD *)&v7 + 1) = qword_4422F8[v50];
    *(_QWORD *)&v7 = 0i64;
  }
  while ( *((_QWORD *)&v7 + 1) )
  {
    if ( (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8i64) & 0xFFFFFFFFFFFFFFF8ui64) - v1 < v43 )
    {
      v43 = (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8i64) & 0xFFFFFFFFFFFFFFF8ui64) - v1;
      *(_QWORD *)&v7 = *((_QWORD *)&v7 + 1);
    }
    v51 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32i64);
    if ( !v51 )
      v51 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40i64);
    *((_QWORD *)&v7 + 1) = v51;
  }
  if ( (_QWORD)v7 && v43 < qword_4420A8[0] - v1 )
  {
    *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 24);
    v52 = *(_QWORD *)(v7 + 48);
    v53 = v1 + v43;
    if ( *((_QWORD *)&v7 + 1) != (_QWORD)v7 )
    {
      v54 = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(v54 + 24) = *((_QWORD *)&v7 + 1);
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 16i64) = v54;
      goto LABEL_98;
    }
    *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
    v55 = v7 + 40;
    if ( !*((_QWORD *)&v7 + 1) )
    {
      *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 32);
      if ( !*((_QWORD *)&v7 + 1) )
        goto LABEL_98;
      v55 = v7 + 32;
    }
    v56 = *((_QWORD *)&v7 + 1);
    do
    {
      do
      {
        v57 = (_QWORD *)v55;
        *((_QWORD *)&v7 + 1) = v56;
        v55 = v56 + 40;
        v56 = *(_QWORD *)(v56 + 40);
      }
      while ( v56 );
      v56 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32i64);
      v55 = *((_QWORD *)&v7 + 1) + 32i64;
    }
    while ( v56 );
    *v57 = 0i64;
LABEL_98:
    if ( !v52 )
      goto LABEL_111;
    v58 = *(unsigned int *)(v7 + 56);
    if ( qword_4422F8[v58] == (_QWORD)v7 )
    {
      qword_4420A8[v58 + 74] = *((_QWORD *)&v7 + 1);
      if ( !*((_QWORD *)&v7 + 1) )
      {
        dword_4420A4 = v41 & ~(1 << v58);
        goto LABEL_111;
      }
    }
    else
    {
      if ( *(_QWORD *)(v52 + 32) == (_QWORD)v7 )
        *(_QWORD *)(v52 + 32) = *((_QWORD *)&v7 + 1);
      else
        *(_QWORD *)(v52 + 40) = *((_QWORD *)&v7 + 1);
      if ( !*((_QWORD *)&v7 + 1) )
        goto LABEL_111;
    }
    v59 = *(_QWORD *)(v7 + 32);
    *(_QWORD *)(*((_QWORD *)&v7 + 1) + 48i64) = v52;
    if ( v59 )
    {
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32i64) = v59;
      *(_QWORD *)(v59 + 48) = *((_QWORD *)&v7 + 1);
    }
    v60 = *(_QWORD *)(v7 + 40);
    if ( v60 )
    {
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40i64) = v60;
      *(_QWORD *)(v60 + 48) = *((_QWORD *)&v7 + 1);
    }
LABEL_111:
    if ( v43 > 0x1F )
    {
      v61 = v7 + v1;
      v62 = v43 >> 3;
      *(_QWORD *)(v7 + 8) = v1 | 3;
      *(_QWORD *)(v61 + 8) = v43 | 1;
      *(_QWORD *)(v61 + v43) = v43;
      if ( v43 > 0xFF )
      {
        v66 = v43 >> 8;
        v67 = v43 >> 8;
        if ( v67 )
        {
          v67 = 31;
          if ( (unsigned int)v66 <= 0xFFFF )
          {
            _BitScanReverse((unsigned int *)&v66, v66);
            v67 = ((v43 >> (38 - ((unsigned __int8)v66 ^ 0x1Fu))) & 1) + 2 * (31 - (v66 ^ 0x1F));
          }
        }
        v68 = dword_4420A4;
        *(_DWORD *)(v61 + 56) = v67;
        *(_QWORD *)(v61 + 40) = 0i64;
        *(_QWORD *)(v61 + 32) = 0i64;
        if ( ((1 << v67) & v68) != 0 )
        {
          v69 = 0;
          v70 = qword_4422F8[v67];
          if ( v67 != 31 )
            v69 = 57 - (v67 >> 1);
          v71 = v43 << v69;
          while ( v43 != (*(_QWORD *)(v70 + 8) & 0xFFFFFFFFFFFFFFF8ui64) )
          {
            v72 = v71;
            v71 *= 2i64;
            v73 = (v72 >> 63) + 4;
            if ( !*(_QWORD *)(v70 + 8 * v73) )
            {
              *(_QWORD *)(v70 + 8 * v73) = v61;
              *(_QWORD *)(v61 + 48) = v70;
              goto LABEL_130;
            }
            v70 = *(_QWORD *)(v70 + 8 * v73);
          }
          v74 = *(_QWORD *)(v70 + 16);
          *(_QWORD *)(v74 + 24) = v61;
          *(_QWORD *)(v70 + 16) = v61;
          *(_QWORD *)(v61 + 16) = v74;
          *(_QWORD *)(v61 + 24) = v70;
          *(_QWORD *)(v61 + 48) = 0i64;
        }
        else
        {
          qword_4422F8[v67] = v61;
          dword_4420A4 = (1 << v67) | v68;
          *(_QWORD *)(v61 + 48) = 8i64 * v67 + 4465400;
LABEL_130:
          *(_QWORD *)(v61 + 24) = v61;
          *(_QWORD *)(v61 + 16) = v61;
        }
      }
      else
      {
        v63 = 1 << v62;
        v64 = 8i64 * (unsigned int)(2 * v62) + 4464872;
        if ( ((1 << v62) & dword_4420A0) != 0 )
        {
          v65 = qword_4420F8[(unsigned int)(2 * v62)];
        }
        else
        {
          v65 = 8i64 * (unsigned int)(2 * v62) + 4464872;
          dword_4420A0 |= v63;
        }
        *(_QWORD *)(v64 + 16) = v61;
        *(_QWORD *)(v65 + 24) = v61;
        *(_QWORD *)(v61 + 16) = v65;
        *(_QWORD *)(v61 + 24) = v64;
      }
    }
    else
    {
      *(_QWORD *)(v7 + 8) = v53 | 3;
      *(_QWORD *)(v7 + v53 + 8) |= 1ui64;
    }
    return v7 + 16;
  }
LABEL_133:
  if ( qword_4420A8[0] >= v1 )
  {
    *(_QWORD *)&v7 = qword_4420C0;
    v75 = qword_4420A8[0] - v1;
    v76 = (unsigned __int64 *)(qword_4420C0 + qword_4420A8[0]);
    if ( qword_4420A8[0] - v1 <= 0x1F )
    {
      *((_QWORD *)&v7 + 1) = qword_4420A8[0] | 3;
      qword_4420A8[0] = 0i64;
      qword_4420C0 = 0i64;
      *(_QWORD *)(v7 + 8) = *((_QWORD *)&v7 + 1);
      v76[1] |= 1ui64;
      return v7 + 16;
    }
    qword_4420A8[0] -= v1;
    qword_4420C0 += v1;
    *(_QWORD *)(qword_4420C0 + 8) = v75 | 1;
    *v76 = v75;
LABEL_262:
    *(_QWORD *)(v7 + 8) = v1 | 3;
    return v7 + 16;
  }
  if ( qword_4420B0 > v1 )
  {
    *((_QWORD *)&v7 + 1) = qword_4420B0 - v1;
LABEL_261:
    *(_QWORD *)&v7 = qword_4420C8;
    qword_4420B0 = *((_QWORD *)&v7 + 1);
    qword_4420C8 += v1;
    *(_QWORD *)(qword_4420C8 + 8) = *((_QWORD *)&v7 + 1) | 1i64;
    goto LABEL_262;
  }
  v77 = -qword_442470;
  if ( (dword_442410 & 1) != 0 && v1 >= qword_442478 )
  {
    if ( qword_4420B0 )
    {
      v78 = v77 & (v1 + qword_442470 + 62);
      if ( (!qword_442408 || qword_4423F8 < qword_4423F8 + v78 && qword_442408 >= qword_4423F8 + v78) && v1 < v78 )
      {
        *(_QWORD *)&v7 = sub_404518();
        *(_QWORD *)v7 = 0i64;
        *(_QWORD *)(v7 + 8) = v78 - 32;
        *((_QWORD *)&v7 + 1) = qword_4420B8;
        *(_QWORD *)(v7 + v78 - 24) = 11i64;
        *(_QWORD *)(v7 + v78 - 16) = 0i64;
        if ( !*((_QWORD *)&v7 + 1) || (unsigned __int64)v7 < *((_QWORD *)&v7 + 1) )
          qword_4420B8 = v7;
        v79 = qword_4423F8 + v78;
        qword_4423F8 = v79;
        if ( v79 > qword_442400 )
          qword_442400 = v79;
        return v7 + 16;
      }
    }
  }
  v80 = v77 & (v1 + qword_442470 + 95);
  if ( v1 < v80 && (!qword_442408 || qword_4423F8 < v80 + qword_4423F8 && qword_442408 >= v80 + qword_4423F8) )
  {
    v82 = sub_404518();
    v83 = v80 + qword_4423F8;
    qword_4423F8 += v80;
    if ( qword_4423F8 > (unsigned __int64)qword_442400 )
      qword_442400 = v83;
    v84 = qword_4420C8;
    if ( !qword_4420C8 )
    {
      if ( !qword_4420B8 || v82 < qword_4420B8 )
        qword_4420B8 = v82;
      qword_442418 = v82;
      qword_442420 = v80;
      dword_442430 = 1;
      qword_4420D8 = 128i64;
      qword_4420E0 = qword_442460;
      v85 = &unk_4420E8;
      do
      {
        v85[3] = v85;
        v85[2] = v85;
        v85 += 2;
      }
      while ( &unk_4422E8 != (_UNKNOWN *)v85 );
      v86 = v80 - 80;
      goto LABEL_170;
    }
    v87 = qword_442418;
    if ( v82 == qword_442418 + qword_442420 )
    {
      v81 = (unsigned int)dword_442430;
      if ( (dword_442430 & 8) == 0 )
      {
        LOBYTE(v81) = dword_442430 & 1;
        if ( (dword_442430 & 1) != 0 && qword_4420C8 >= (unsigned __int64)qword_442418 && v82 > qword_4420C8 )
        {
          qword_442420 += v80;
          v86 = v80 + qword_4420B0;
LABEL_170:
          sub_4022A8(v81, v86);
LABEL_259:
          if ( v1 < qword_4420B0 )
          {
            *((_QWORD *)&v7 + 1) = qword_4420B0 - v1;
            goto LABEL_261;
          }
          sub_4018E7();
          return 0i64;
        }
      }
    }
    if ( v82 < qword_4420B8 )
      qword_4420B8 = v82;
    v88 = &qword_442418;
    if ( qword_442418 != v82 + v80 || (v89 = dword_442430 & 8, (dword_442430 & 8) != 0) || (dword_442430 & 1) == 0 )
    {
      while ( 1 )
      {
        if ( qword_4420C8 >= (unsigned __int64)*v88 )
        {
          v122 = v88[1] + *v88;
          if ( qword_4420C8 < v122 )
            break;
        }
        v88 = (__int64 *)v88[2];
        if ( !v88 )
          BUG();
      }
      sub_4022A8((__int64)v88, v80 - 80);
      v125[1] = 51i64;
      v126 = v125 + 2;
      v127 = &qword_442418;
      for ( j = 8i64; j; --j )
      {
        *v126 = *(_DWORD *)v127;
        v127 = (__int64 *)((char *)v127 + 4);
        ++v126;
      }
      qword_442428 = (__int64)(v125 + 2);
      v129 = v125 + 7;
      qword_442418 = v123;
      qword_442420 = v80;
      dword_442430 = 1;
      do
        *v129++ = 11i64;
      while ( v122 > (unsigned __int64)v129 );
      if ( (_QWORD *)v124 != v125 )
      {
        v125[1] &= ~1ui64;
        v130 = (unsigned __int64)v125 - v124;
        v131 = ((unsigned __int64)v125 - v124) >> 3;
        *(_QWORD *)(v124 + 8) = ((unsigned __int64)v125 - v124) | 1;
        *v125 = (char *)v125 - v124;
        if ( (unsigned __int64)v125 - v124 > 0xFF )
        {
          v133 = v130 >> 8;
          v134 = v130 >> 8;
          if ( v134 )
          {
            v134 = 31;
            if ( (unsigned int)v133 <= 0xFFFF )
            {
              _BitScanReverse((unsigned int *)&v133, v133);
              v134 = ((v130 >> (38 - ((unsigned __int8)v133 ^ 0x1Fu))) & 1) + 2 * (31 - (v133 ^ 0x1F));
            }
          }
          v135 = dword_4420A4;
          *(_DWORD *)(v124 + 56) = v134;
          *(_QWORD *)(v124 + 40) = 0i64;
          *(_QWORD *)(v124 + 32) = 0i64;
          if ( ((1 << v134) & v135) != 0 )
          {
            v136 = 0;
            v137 = qword_4422F8[v134];
            if ( v134 != 31 )
              v136 = 57 - (v134 >> 1);
            v138 = v130 << v136;
            while ( v130 != (*(_QWORD *)(v137 + 8) & 0xFFFFFFFFFFFFFFF8ui64) )
            {
              v139 = v138;
              v138 *= 2i64;
              v140 = (v139 >> 63) + 4;
              if ( !*(_QWORD *)(v137 + 8 * v140) )
              {
                *(_QWORD *)(v137 + 8 * v140) = v124;
                *(_QWORD *)(v124 + 48) = v137;
                goto LABEL_257;
              }
              v137 = *(_QWORD *)(v137 + 8 * v140);
            }
            v141 = *(_QWORD *)(v137 + 16);
            *(_QWORD *)(v141 + 24) = v124;
            *(_QWORD *)(v137 + 16) = v124;
            *(_QWORD *)(v124 + 16) = v141;
            *(_QWORD *)(v124 + 24) = v137;
            *(_QWORD *)(v124 + 48) = 0i64;
          }
          else
          {
            qword_4422F8[v134] = v124;
            dword_4420A4 = (1 << v134) | v135;
            *(_QWORD *)(v124 + 48) = 8i64 * v134 + 4465400;
LABEL_257:
            *(_QWORD *)(v124 + 24) = v124;
            *(_QWORD *)(v124 + 16) = v124;
          }
        }
        else
        {
          if ( ((1 << v131) & dword_4420A0) != 0 )
          {
            v132 = qword_4420F8[(unsigned int)(2 * v131)];
          }
          else
          {
            dword_4420A0 |= 1 << v131;
            v132 = 8i64 * (unsigned int)(2 * v131) + 4464872;
          }
          qword_4420F8[(unsigned int)(2 * v131)] = v124;
          *(_QWORD *)(v132 + 24) = v124;
          *(_QWORD *)(v124 + 16) = v132;
          *(_QWORD *)(v124 + 24) = 8i64 * (unsigned int)(2 * v131) + 4464872;
        }
      }
      goto LABEL_259;
    }
    qword_442418 = v82;
    v90 = v87 & 0xF;
    qword_442420 += v80;
    if ( (v87 & 0xF) != 0 )
      v90 = -(char)(v87 + 16) & 0xF;
    v91 = v87 + v90;
    v92 = v82 + v1;
    v93 = v91 - v82 - v1;
    *(_QWORD *)(v82 + 8) = v1 | 3;
    if ( v84 == v91 )
    {
      qword_4420C8 = v82 + v1;
      qword_4420B0 += v93;
      *(_QWORD *)(v92 + 8) = qword_4420B0 | 1;
      return v82 + 16;
    }
    if ( v91 == qword_4420C0 )
    {
      v94 = qword_4420A8[0] + v93;
      qword_4420C0 = v82 + v1;
      qword_4420A8[0] = v94;
      *(_QWORD *)(v92 + 8) = v94 | 1;
      *(_QWORD *)(v92 + v94) = v94;
      return v82 + 16;
    }
    v95 = *(_QWORD *)(v91 + 8);
    if ( (v95 & 3) != 1 )
    {
LABEL_210:
      *(_QWORD *)(v91 + 8) &= ~1ui64;
      v109 = v93 >> 3;
      *(_QWORD *)(v92 + 8) = v93 | 1;
      *(_QWORD *)(v92 + v93) = v93;
      if ( v93 > 0xFF )
      {
        v113 = v93 >> 8;
        v114 = v93 >> 8;
        if ( v114 )
        {
          v114 = 31;
          if ( (unsigned int)v113 <= 0xFFFF )
          {
            _BitScanReverse((unsigned int *)&v113, v113);
            v114 = ((v93 >> (38 - ((unsigned __int8)v113 ^ 0x1Fu))) & 1) + 2 * (31 - (v113 ^ 0x1F));
          }
        }
        v115 = dword_4420A4;
        *(_DWORD *)(v92 + 56) = v114;
        *(_QWORD *)(v92 + 40) = 0i64;
        *(_QWORD *)(v92 + 32) = 0i64;
        if ( ((1 << v114) & v115) != 0 )
        {
          v116 = qword_4422F8[v114];
          if ( v114 != 31 )
            v89 = 57 - (v114 >> 1);
          v117 = v93 << v89;
          while ( v93 != (*(_QWORD *)(v116 + 8) & 0xFFFFFFFFFFFFFFF8ui64) )
          {
            v118 = v117;
            v117 *= 2i64;
            v119 = (v118 >> 63) + 4;
            if ( !*(_QWORD *)(v116 + 8 * v119) )
            {
              *(_QWORD *)(v116 + 8 * v119) = v92;
              *(_QWORD *)(v92 + 48) = v116;
              goto LABEL_227;
            }
            v116 = *(_QWORD *)(v116 + 8 * v119);
          }
          v120 = *(_QWORD *)(v116 + 16);
          *(_QWORD *)(v120 + 24) = v92;
          *(_QWORD *)(v116 + 16) = v92;
          *(_QWORD *)(v92 + 16) = v120;
          *(_QWORD *)(v92 + 24) = v116;
          *(_QWORD *)(v92 + 48) = 0i64;
        }
        else
        {
          qword_4422F8[v114] = v92;
          dword_4420A4 = (1 << v114) | v115;
          *(_QWORD *)(v92 + 48) = 8i64 * v114 + 4465400;
LABEL_227:
          *(_QWORD *)(v92 + 24) = v92;
          *(_QWORD *)(v92 + 16) = v92;
        }
      }
      else
      {
        v110 = 1 << v109;
        v111 = 8i64 * (unsigned int)(2 * v109) + 4464872;
        if ( ((1 << v109) & dword_4420A0) != 0 )
        {
          v112 = qword_4420F8[(unsigned int)(2 * v109)];
        }
        else
        {
          v112 = 8i64 * (unsigned int)(2 * v109) + 4464872;
          dword_4420A0 |= v110;
        }
        *(_QWORD *)(v111 + 16) = v92;
        *(_QWORD *)(v112 + 24) = v92;
        *(_QWORD *)(v92 + 16) = v112;
        *(_QWORD *)(v92 + 24) = v111;
      }
      return v82 + 16;
    }
    v96 = *(_QWORD **)(v91 + 24);
    v97 = v95 & 0xFFFFFFFFFFFFFFF8ui64;
    v98 = v95 >> 3;
    if ( v95 <= 0xFF )
    {
      v99 = *(_QWORD **)(v91 + 16);
      if ( v99 == v96 )
      {
        dword_4420A0 &= __ROL4__(-2, v98);
      }
      else
      {
        v99[3] = v96;
        v96[2] = v99;
      }
      goto LABEL_209;
    }
    v100 = *(_QWORD *)(v91 + 48);
    if ( (_QWORD *)v91 != v96 )
    {
      v101 = *(_QWORD *)(v91 + 16);
      *(_QWORD *)(v101 + 24) = v96;
      v96[2] = v101;
      goto LABEL_196;
    }
    v96 = *(_QWORD **)(v91 + 40);
    v102 = (_QWORD *)(v91 + 40);
    if ( !v96 )
    {
      v96 = *(_QWORD **)(v91 + 32);
      if ( !v96 )
        goto LABEL_196;
      v102 = (_QWORD *)(v91 + 32);
    }
    v103 = v96;
    do
    {
      do
      {
        v104 = v102;
        v96 = v103;
        v102 = v103 + 5;
        v103 = (_QWORD *)v103[5];
      }
      while ( v103 );
      v103 = (_QWORD *)v96[4];
      v102 = v96 + 4;
    }
    while ( v103 );
    *v104 = 0i64;
LABEL_196:
    if ( v100 )
    {
      v105 = *(unsigned int *)(v91 + 56);
      v106 = *(_DWORD *)(v91 + 56);
      if ( v91 != qword_4422F8[v105] )
      {
        if ( v91 == *(_QWORD *)(v100 + 32) )
          *(_QWORD *)(v100 + 32) = v96;
        else
          *(_QWORD *)(v100 + 40) = v96;
        if ( !v96 )
          goto LABEL_209;
LABEL_199:
        v107 = *(_QWORD *)(v91 + 32);
        v96[6] = v100;
        if ( v107 )
        {
          v96[4] = v107;
          *(_QWORD *)(v107 + 48) = v96;
        }
        v108 = *(_QWORD *)(v91 + 40);
        if ( v108 )
        {
          v96[5] = v108;
          *(_QWORD *)(v108 + 48) = v96;
        }
        goto LABEL_209;
      }
      qword_4420A8[v105 + 74] = (__int64)v96;
      if ( v96 )
        goto LABEL_199;
      dword_4420A4 &= __ROL4__(-2, v106);
    }
LABEL_209:
    v91 += v97;
    v93 += v97;
    goto LABEL_210;
  }
  return 0i64;
}
// 402B75: variable 'v0' is possibly undefined
// 40350C: variable 'v81' is possibly undefined
// 4038E3: variable 'v125' is possibly undefined
// 403906: variable 'v123' is possibly undefined
// 403931: variable 'v124' is possibly undefined
// 4420A0: using guessed type int dword_4420A0;
// 4420A4: using guessed type int dword_4420A4;
// 4420A8: using guessed type __int64 qword_4420A8[];
// 4420B0: using guessed type __int64 qword_4420B0;
// 4420B8: using guessed type __int64 qword_4420B8;
// 4420C0: using guessed type __int64 qword_4420C0;
// 4420C8: using guessed type __int64 qword_4420C8;
// 4420D8: using guessed type __int64 qword_4420D8;
// 4420E0: using guessed type __int64 qword_4420E0;
// 4420F8: using guessed type _QWORD qword_4420F8[62];
// 4422F8: using guessed type __int64 qword_4422F8[32];
// 4423F8: using guessed type __int64 qword_4423F8;
// 442400: using guessed type __int64 qword_442400;
// 442408: using guessed type __int64 qword_442408;
// 442410: using guessed type int dword_442410;
// 442418: using guessed type __int64 qword_442418;
// 442420: using guessed type __int64 qword_442420;
// 442428: using guessed type __int64 qword_442428;
// 442430: using guessed type int dword_442430;
// 442460: using guessed type __int64 qword_442460;
// 442470: using guessed type __int64 qword_442470;
// 442478: using guessed type __int64 qword_442478;

//----- (0000000000403AE8) ----------------------------------------------------
void __fastcall sub_403AE8()
{
  __int64 v0; // rdi
  __int64 v1; // rdx
  __int64 v2; // rdi
  __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // r8
  __int64 v7; // rbx
  _QWORD *v8; // rdx
  unsigned __int64 v9; // rcx
  _QWORD *v10; // r8
  __int64 v11; // r8
  __int64 v12; // rcx
  _QWORD *v13; // r9
  _QWORD *v14; // rcx
  _QWORD *v15; // r10
  __int64 v16; // r9
  int v17; // ecx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // r8
  __int64 v22; // r10
  unsigned __int64 v23; // rax
  __int64 v24; // rax
  unsigned __int64 v25; // r8
  _QWORD *v26; // rdx
  _QWORD *v27; // rsi
  __int64 v28; // r8
  __int64 v29; // rcx
  _QWORD *v30; // r9
  _QWORD *v31; // rcx
  _QWORD *v32; // r11
  __int64 v33; // r9
  int v34; // ecx
  __int64 v35; // rcx
  __int64 v36; // rcx
  unsigned __int64 v37; // rcx
  __int64 v38; // rdx
  unsigned __int64 v39; // rsi
  unsigned int v40; // edx
  int v41; // esi
  char v42; // cl
  __int64 v43; // rsi
  unsigned __int64 v44; // rcx
  unsigned __int64 v45; // rdx
  __int64 v46; // rdx
  __int64 v47; // rax

  if ( !v0 )
    return;
  v1 = v0;
  v2 = v0 - 16;
  v3 = *(_QWORD *)(v1 - 8);
  v4 = v3 & 0xFFFFFFFFFFFFFFF8ui64;
  v5 = v2 + (v3 & 0xFFFFFFFFFFFFFFF8ui64);
  if ( (v3 & 1) != 0 )
    goto LABEL_35;
  v6 = *(_QWORD *)(v1 - 16);
  v2 -= v6;
  LOBYTE(v3) = v3 & 3;
  if ( !(_BYTE)v3 )
  {
    v7 = v4 + v6 + 32;
    if ( !(unsigned int)sub_40452C(v3) )
      qword_4423F8 -= v7;
    return;
  }
  v4 += v6;
  if ( qword_4420C0 == v2 )
  {
    v20 = *(_QWORD *)(v5 + 8);
    if ( (v20 & 3) == 3 )
    {
      qword_4420A8[0] = v4;
      *(_QWORD *)(v5 + 8) = v20 & 0xFFFFFFFFFFFFFFFEui64;
      *(_QWORD *)(v2 + 8) = v4 | 1;
      *(_QWORD *)v5 = v4;
      return;
    }
    goto LABEL_35;
  }
  v8 = *(_QWORD **)(v2 + 24);
  v9 = v6 >> 3;
  if ( v6 <= 0xFF )
  {
    v10 = *(_QWORD **)(v2 + 16);
    if ( v10 == v8 )
    {
      dword_4420A0 &= __ROL4__(-2, v9);
    }
    else
    {
      v10[3] = v8;
      v8[2] = v10;
    }
    goto LABEL_35;
  }
  v11 = *(_QWORD *)(v2 + 48);
  if ( (_QWORD *)v2 == v8 )
  {
    v8 = *(_QWORD **)(v2 + 40);
    v13 = (_QWORD *)(v2 + 40);
    if ( !v8 )
    {
      v8 = *(_QWORD **)(v2 + 32);
      if ( !v8 )
        goto LABEL_20;
      v13 = (_QWORD *)(v2 + 32);
    }
    v14 = v8;
    do
    {
      do
      {
        v15 = v13;
        v8 = v14;
        v13 = v14 + 5;
        v14 = (_QWORD *)v14[5];
      }
      while ( v14 );
      v14 = (_QWORD *)v8[4];
      v13 = v8 + 4;
    }
    while ( v14 );
    *v15 = 0i64;
    goto LABEL_20;
  }
  v12 = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(v12 + 24) = v8;
  v8[2] = v12;
LABEL_20:
  if ( !v11 )
    goto LABEL_35;
  v16 = *(unsigned int *)(v2 + 56);
  v17 = *(_DWORD *)(v2 + 56);
  if ( qword_4422F8[v16] == v2 )
  {
    qword_4420A8[v16 + 74] = (__int64)v8;
    if ( !v8 )
    {
      dword_4420A4 &= __ROL4__(-2, v17);
      goto LABEL_35;
    }
  }
  else
  {
    if ( *(_QWORD *)(v11 + 32) == v2 )
      *(_QWORD *)(v11 + 32) = v8;
    else
      *(_QWORD *)(v11 + 40) = v8;
    if ( !v8 )
      goto LABEL_35;
  }
  v18 = *(_QWORD *)(v2 + 32);
  v8[6] = v11;
  if ( v18 )
  {
    v8[4] = v18;
    *(_QWORD *)(v18 + 48) = v8;
  }
  v19 = *(_QWORD *)(v2 + 40);
  if ( v19 )
  {
    v8[5] = v19;
    *(_QWORD *)(v19 + 48) = v8;
  }
LABEL_35:
  v21 = *(_QWORD *)(v5 + 8);
  if ( (v21 & 2) == 0 )
  {
    v22 = qword_4420C0;
    if ( qword_4420C8 == v5 )
    {
      v23 = qword_4420B0 + v4;
      qword_4420C8 = v2;
      qword_4420B0 = v23;
      *(_QWORD *)(v2 + 8) = v23 | 1;
      if ( v2 == v22 )
      {
        qword_4420C0 = 0i64;
        qword_4420A8[0] = 0i64;
      }
      if ( v23 > qword_4420D0 )
        sub_4025AC();
      return;
    }
    if ( v5 == qword_4420C0 )
    {
      v24 = qword_4420A8[0] + v4;
      qword_4420C0 = v2;
      qword_4420A8[0] = v24;
      *(_QWORD *)(v2 + 8) = v24 | 1;
      *(_QWORD *)(v2 + v24) = v24;
      return;
    }
    v25 = v21 & 0xFFFFFFFFFFFFFFF8ui64;
    v26 = *(_QWORD **)(v5 + 24);
    v4 += v25;
    if ( v25 <= 0xF8 )
    {
      v27 = *(_QWORD **)(v5 + 16);
      if ( v27 == v26 )
      {
        dword_4420A0 &= __ROL4__(-2, v25 >> 3);
      }
      else
      {
        v27[3] = v26;
        v26[2] = v27;
      }
      goto LABEL_69;
    }
    v28 = *(_QWORD *)(v5 + 48);
    if ( (_QWORD *)v5 != v26 )
    {
      v29 = *(_QWORD *)(v5 + 16);
      *(_QWORD *)(v29 + 24) = v26;
      v26[2] = v29;
      goto LABEL_56;
    }
    v26 = *(_QWORD **)(v5 + 40);
    v30 = (_QWORD *)(v5 + 40);
    if ( !v26 )
    {
      v26 = *(_QWORD **)(v5 + 32);
      if ( !v26 )
        goto LABEL_56;
      v30 = (_QWORD *)(v5 + 32);
    }
    v31 = v26;
    do
    {
      do
      {
        v32 = v30;
        v26 = v31;
        v30 = v31 + 5;
        v31 = (_QWORD *)v31[5];
      }
      while ( v31 );
      v31 = (_QWORD *)v26[4];
      v30 = v26 + 4;
    }
    while ( v31 );
    *v32 = 0i64;
LABEL_56:
    if ( !v28 )
      goto LABEL_69;
    v33 = *(unsigned int *)(v5 + 56);
    v34 = *(_DWORD *)(v5 + 56);
    if ( qword_4422F8[v33] == v5 )
    {
      qword_4420A8[v33 + 74] = (__int64)v26;
      if ( !v26 )
      {
        dword_4420A4 &= __ROL4__(-2, v34);
        goto LABEL_69;
      }
    }
    else
    {
      if ( *(_QWORD *)(v28 + 32) == v5 )
        *(_QWORD *)(v28 + 32) = v26;
      else
        *(_QWORD *)(v28 + 40) = v26;
      if ( !v26 )
        goto LABEL_69;
    }
    v35 = *(_QWORD *)(v5 + 32);
    v26[6] = v28;
    if ( v35 )
    {
      v26[4] = v35;
      *(_QWORD *)(v35 + 48) = v26;
    }
    v36 = *(_QWORD *)(v5 + 40);
    if ( v36 )
    {
      v26[5] = v36;
      *(_QWORD *)(v36 + 48) = v26;
    }
LABEL_69:
    *(_QWORD *)(v2 + 8) = v4 | 1;
    *(_QWORD *)(v2 + v4) = v4;
    if ( v2 == v22 )
    {
      qword_4420A8[0] = v4;
      return;
    }
    goto LABEL_72;
  }
  *(_QWORD *)(v5 + 8) = v21 & 0xFFFFFFFFFFFFFFFEui64;
  *(_QWORD *)(v2 + 8) = v4 | 1;
  *(_QWORD *)(v2 + v4) = v4;
LABEL_72:
  v37 = v4 >> 3;
  if ( v4 > 0xFF )
  {
    v39 = v4 >> 8;
    v40 = v4 >> 8;
    if ( v40 )
    {
      v40 = 31;
      if ( (unsigned int)v39 <= 0xFFFF )
      {
        _BitScanReverse((unsigned int *)&v39, v39);
        v40 = ((v4 >> (38 - ((unsigned __int8)v39 ^ 0x1Fu))) & 1) + 2 * (31 - (v39 ^ 0x1F));
      }
    }
    v41 = dword_4420A4;
    *(_DWORD *)(v2 + 56) = v40;
    *(_QWORD *)(v2 + 40) = 0i64;
    *(_QWORD *)(v2 + 32) = 0i64;
    if ( ((1 << v40) & v41) != 0 )
    {
      v42 = 0;
      v43 = qword_4422F8[v40];
      if ( v40 != 31 )
        v42 = 57 - (v40 >> 1);
      v44 = v4 << v42;
      while ( (*(_QWORD *)(v43 + 8) & 0xFFFFFFFFFFFFFFF8ui64) != v4 )
      {
        v45 = v44;
        v44 *= 2i64;
        v46 = (v45 >> 63) + 4;
        if ( !*(_QWORD *)(v43 + 8 * v46) )
        {
          *(_QWORD *)(v43 + 8 * v46) = v2;
          *(_QWORD *)(v2 + 48) = v43;
          goto LABEL_89;
        }
        v43 = *(_QWORD *)(v43 + 8 * v46);
      }
      v47 = *(_QWORD *)(v43 + 16);
      *(_QWORD *)(v47 + 24) = v2;
      *(_QWORD *)(v43 + 16) = v2;
      *(_QWORD *)(v2 + 16) = v47;
      *(_QWORD *)(v2 + 24) = v43;
      *(_QWORD *)(v2 + 48) = 0i64;
    }
    else
    {
      qword_4422F8[v40] = v2;
      dword_4420A4 = (1 << v40) | v41;
      *(_QWORD *)(v2 + 48) = 8i64 * v40 + 4465400;
LABEL_89:
      *(_QWORD *)(v2 + 24) = v2;
      *(_QWORD *)(v2 + 16) = v2;
    }
    if ( !--qword_4420D8 )
      sub_4022EF();
  }
  else
  {
    if ( ((1 << v37) & dword_4420A0) != 0 )
    {
      v38 = qword_4420F8[(unsigned int)(2 * v37)];
    }
    else
    {
      dword_4420A0 |= 1 << v37;
      v38 = 8i64 * (unsigned int)(2 * v37) + 4464872;
    }
    qword_4420F8[(unsigned int)(2 * v37)] = v2;
    *(_QWORD *)(v38 + 24) = v2;
    *(_QWORD *)(v2 + 16) = v38;
    *(_QWORD *)(v2 + 24) = 8i64 * (unsigned int)(2 * v37) + 4464872;
  }
}
// 403AEB: variable 'v0' is possibly undefined
// 4420A0: using guessed type int dword_4420A0;
// 4420A4: using guessed type int dword_4420A4;
// 4420A8: using guessed type __int64 qword_4420A8[];
// 4420B0: using guessed type __int64 qword_4420B0;
// 4420C0: using guessed type __int64 qword_4420C0;
// 4420C8: using guessed type __int64 qword_4420C8;
// 4420D0: using guessed type __int64 qword_4420D0;
// 4420D8: using guessed type __int64 qword_4420D8;
// 4420F8: using guessed type _QWORD qword_4420F8[62];
// 4422F8: using guessed type __int64 qword_4422F8[32];
// 4423F8: using guessed type __int64 qword_4423F8;

//----- (0000000000403FED) ----------------------------------------------------
void __fastcall sub_403FED()
{
  unsigned __int64 v0; // rdi
  __int64 v1; // rsi
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // rax
  __int64 v4; // rcx

  v2 = 0i64;
  if ( v0 )
  {
    v2 = v1 * v0;
    if ( ((v1 | v0) & 0xFFFFFFFFFFFF0000ui64) != 0 && v1 != v2 / v0 )
      v2 = -1i64;
  }
  v3 = sub_402B64();
  if ( v3 )
  {
    if ( (*(_BYTE *)(v3 - 8) & 3) != 0 )
      sub_4050B2(v4, v2);
  }
}
// 403FF8: variable 'v0' is possibly undefined
// 404000: variable 'v1' is possibly undefined
// 404040: variable 'v4' is possibly undefined

//----- (0000000000404049) ----------------------------------------------------
__int64 *__fastcall sub_404049(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  __int64 *v3; // rsi
  __int64 *v4; // r13
  __int64 v5; // r12
  __int64 v7; // rsi
  unsigned __int64 v8; // rdx
  __int64 v9; // r14
  __int64 v10; // rbx
  __int64 v11; // r15
  unsigned __int64 v12; // rax
  __int64 v13; // rdx
  bool v14; // cf
  unsigned __int64 v15; // rbx
  bool v16; // cc
  char *v17; // r9
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // rdx
  unsigned __int64 v20; // rcx
  __int64 v21; // rsi
  unsigned __int64 *v22; // rax
  unsigned __int64 v23; // r8
  __int64 v24; // r10
  unsigned __int64 v25; // r10
  unsigned __int64 v26; // r8
  char *v27; // rax
  unsigned __int64 v28; // r11
  char *v29; // rdx
  __int64 v30; // r10
  __int64 v31; // rdx
  char *v32; // rdx
  _QWORD *v33; // rbx
  __int64 v34; // rdx
  __int64 v35; // rdx
  __int64 v36; // rdx
  __int64 v37; // rsi
  char *v38; // rax

  v4 = v3;
  v5 = v2;
  v7 = v3[1];
  v8 = v7 & 0xFFFFFFFFFFFFFFF8ui64;
  if ( (v7 & 3) != 0 )
  {
    v17 = (char *)v4 + v8;
    if ( v8 >= a2 )
    {
      v18 = v8 - a2;
      if ( v18 <= 0x1F )
        return v4;
      v4[1] = v7 & 1 | a2 | 2;
      *(__int64 *)((char *)v4 + a2 + 8) = v18 | 3;
      *((_QWORD *)v17 + 1) |= 1ui64;
LABEL_53:
      sub_4026E8(a1, v18);
      return v4;
    }
    if ( *(char **)(v5 + 40) == v17 )
    {
      v19 = *(_QWORD *)(v5 + 16) + v8;
      if ( v19 > a2 )
      {
        v4[1] = a2 | v7 & 1 | 2;
        *(__int64 *)((char *)v4 + a2 + 8) = (v19 - a2) | 1;
        *(_QWORD *)(v5 + 40) = (char *)v4 + a2;
        *(_QWORD *)(v5 + 16) = v19 - a2;
        return v4;
      }
      return 0i64;
    }
    if ( *(char **)(v5 + 32) == v17 )
    {
      v20 = v8 + *(_QWORD *)(v5 + 8);
      if ( v20 < a2 )
        return 0i64;
      v21 = v7 & 1;
      v22 = (unsigned __int64 *)((char *)v4 + v20);
      v23 = v20 - a2;
      if ( v20 - a2 <= 0x1F )
      {
        v4[1] = v21 | v20 | 2;
        v22[1] |= 1ui64;
        *(_QWORD *)(v5 + 8) = 0i64;
        *(_QWORD *)(v5 + 32) = 0i64;
      }
      else
      {
        v4[1] = a2 | v21 | 2;
        *(__int64 *)((char *)v4 + a2 + 8) = v23 | 1;
        *v22 = v23;
        v22[1] &= ~1ui64;
        *(_QWORD *)(v5 + 8) = v23;
        *(_QWORD *)(v5 + 32) = (char *)v4 + a2;
      }
      return v4;
    }
    v24 = *((_QWORD *)v17 + 1);
    if ( (v24 & 2) != 0 )
      return 0i64;
    v25 = v24 & 0xFFFFFFFFFFFFFFF8ui64;
    v26 = v8 + v25;
    if ( v8 + v25 < a2 )
      return 0i64;
    v27 = (char *)*((_QWORD *)v17 + 3);
    v28 = v26 - a2;
    a1 = v25 >> 3;
    if ( v25 <= 0xF8 )
    {
      v29 = (char *)*((_QWORD *)v17 + 2);
      if ( v29 == v27 )
      {
        *(_DWORD *)v5 &= __ROL4__(-2, a1);
      }
      else
      {
        *((_QWORD *)v29 + 3) = v27;
        *((_QWORD *)v27 + 2) = v29;
      }
      goto LABEL_50;
    }
    v30 = *((_QWORD *)v17 + 6);
    if ( v17 != v27 )
    {
      v31 = *((_QWORD *)v17 + 2);
      *(_QWORD *)(v31 + 24) = v27;
      *((_QWORD *)v27 + 2) = v31;
      goto LABEL_37;
    }
    v27 = (char *)*((_QWORD *)v17 + 5);
    a1 = (__int64)(v17 + 40);
    if ( !v27 )
    {
      v27 = (char *)*((_QWORD *)v17 + 4);
      if ( !v27 )
        goto LABEL_37;
      a1 = (__int64)(v17 + 32);
    }
    v32 = v27;
    do
    {
      do
      {
        v33 = (_QWORD *)a1;
        v27 = v32;
        a1 = (__int64)(v32 + 40);
        v32 = (char *)*((_QWORD *)v32 + 5);
      }
      while ( v32 );
      v32 = (char *)*((_QWORD *)v27 + 4);
      a1 = (__int64)(v27 + 32);
    }
    while ( v32 );
    *v33 = 0i64;
LABEL_37:
    if ( v30 )
    {
      a1 = *((unsigned int *)v17 + 14);
      v34 = v5 + 8 * a1;
      if ( *(char **)(v34 + 600) != v17 )
      {
        if ( *(char **)(v30 + 32) == v17 )
          *(_QWORD *)(v30 + 32) = v27;
        else
          *(_QWORD *)(v30 + 40) = v27;
        if ( !v27 )
          goto LABEL_50;
LABEL_40:
        v35 = *((_QWORD *)v17 + 4);
        *((_QWORD *)v27 + 6) = v30;
        if ( v35 )
        {
          *((_QWORD *)v27 + 4) = v35;
          *(_QWORD *)(v35 + 48) = v27;
        }
        v36 = *((_QWORD *)v17 + 5);
        if ( v36 )
        {
          *((_QWORD *)v27 + 5) = v36;
          *(_QWORD *)(v36 + 48) = v27;
        }
        goto LABEL_50;
      }
      *(_QWORD *)(v34 + 600) = v27;
      if ( v27 )
        goto LABEL_40;
      *(_DWORD *)(v5 + 4) &= __ROL4__(-2, a1);
    }
LABEL_50:
    v37 = v7 & 1;
    v38 = (char *)v4 + v26;
    if ( v28 <= 0x1F )
    {
      v4[1] = v26 | v37 | 2;
      *((_QWORD *)v38 + 1) |= 1ui64;
      return v4;
    }
    v4[1] = a2 | v37 | 2;
    *(__int64 *)((char *)v4 + a2 + 8) = v28 | 3;
    *((_QWORD *)v38 + 1) |= 1ui64;
    v18 = v26 - a2;
    goto LABEL_53;
  }
  if ( a2 <= 0xFF )
    return 0i64;
  if ( v8 < a2 + 8 || v8 - a2 > 2 * qword_442470 )
  {
    v9 = *v4;
    v10 = -qword_442470 & (qword_442470 + a2 + 62);
    v11 = v8 + *v4 + 32;
    v12 = sub_404ABB();
    if ( v12 == -1i64 )
      return 0i64;
    v4 = (__int64 *)(v12 + v9);
    v13 = v10 - v9;
    v14 = v12 < *(_QWORD *)(v5 + 24);
    v4[1] = v10 - v9 - 32;
    *(__int64 *)((char *)v4 + v13 - 24) = 11i64;
    *(__int64 *)((char *)v4 + v13 - 16) = 0i64;
    if ( v14 )
      *(_QWORD *)(v5 + 24) = v12;
    v15 = *(_QWORD *)(v5 + 856) + v10 - v11;
    v16 = v15 <= *(_QWORD *)(v5 + 864);
    *(_QWORD *)(v5 + 856) = v15;
    if ( !v16 )
      *(_QWORD *)(v5 + 864) = v15;
  }
  return v4;
}
// 404053: variable 'v3' is possibly undefined
// 404058: variable 'v2' is possibly undefined
// 442470: using guessed type __int64 qword_442470;

//----- (00000000004043D8) ----------------------------------------------------
__int64 *__fastcall sub_4043D8()
{
  __int64 v0; // rdi
  unsigned __int64 v1; // rsi
  __int64 *result; // rax
  unsigned __int64 v3; // rdx
  __int64 *v4; // rax
  __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  __int64 v7; // [rsp+8h] [rbp-18h]

  if ( !v0 )
    return (__int64 *)sub_402B64();
  if ( v1 > 0xFFFFFFFFFFFFFF7Fui64 )
  {
    sub_4018E7();
    return 0i64;
  }
  if ( !v1 )
  {
    sub_403AE8();
    return 0i64;
  }
  v3 = 32i64;
  if ( v1 > 0xE )
    v3 = (v1 + 31) & 0xFFFFFFFFFFFFFFF0ui64;
  v4 = sub_404049(1i64, v3);
  if ( v4 )
    return v4 + 2;
  result = (__int64 *)sub_402B64();
  if ( result )
  {
    v6 = (*(_QWORD *)(v0 - 8) & 0xFFFFFFFFFFFFFFF8ui64) - 16;
    if ( v6 > v1 )
      v6 = v1;
    sub_404F70(v5, v6);
    sub_403AE8();
    return (__int64 *)v7;
  }
  return result;
}
// 4043EA: variable 'v0' is possibly undefined
// 404403: variable 'v1' is possibly undefined
// 404478: variable 'v5' is possibly undefined
// 404485: variable 'v7' is possibly undefined

//----- (0000000000404491) ----------------------------------------------------
void sub_404491()
{
  DWORD dwAllocationGranularity; // eax

  if ( !qword_442460 )
  {
    dwAllocationGranularity = 0x10000;
    if ( SystemInfo.dwAllocationGranularity >= 0x10000 )
      dwAllocationGranularity = SystemInfo.dwAllocationGranularity;
    if ( (dwAllocationGranularity & (dwAllocationGranularity - 1)) != 0 )
      sub_401000();
    qword_442470 = dwAllocationGranularity;
    qword_442468 = 4096i64;
    qword_442478 = 0x40000i64;
    qword_442480 = 10485760i64;
    dword_442488 = 5;
    dword_442410 = 5;
    qword_442460 = qword_440000 & 0xFFFFFFFFFFFFFFF0ui64 | 8;
  }
}
// 4044BC: ignored the value written to the shadow area of the succeeding call
// 440000: using guessed type __int64 qword_440000;
// 442410: using guessed type int dword_442410;
// 442460: using guessed type __int64 qword_442460;
// 442468: using guessed type __int64 qword_442468;
// 442470: using guessed type __int64 qword_442470;
// 442478: using guessed type __int64 qword_442478;
// 442480: using guessed type __int64 qword_442480;
// 442488: using guessed type int dword_442488;

//----- (0000000000404518) ----------------------------------------------------
__int64 sub_404518()
{
  return sub_40481D();
}
// 40451D: ignored the value written to the shadow area of the succeeding call

//----- (000000000040452C) ----------------------------------------------------
__int64 __fastcall sub_40452C(__int64 a1)
{
  return sub_404AC1(a1);
}
// 404531: ignored the value written to the shadow area of the succeeding call

//----- (0000000000404540) ----------------------------------------------------
__int64 __fastcall sub_404540(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  _DWORD *v5; // rbx
  __int64 v6; // rax
  __int64 result; // rax
  unsigned int v8; // eax
  _QWORD *v9; // rbx

  v5 = (_DWORD *)qword_4424A0;
  if ( !qword_4424A0 )
  {
    qword_4424A0 = 4465832i64;
    v5 = &unk_4424A8;
  }
  if ( *v5 == -1 )
  {
    if ( !sub_402296 )
      return sub_4018E7();
    v6 = sub_402296();
    if ( !v6 )
      return sub_4018E7();
    *(_QWORD *)(v6 + 8) = v5;
    qword_4424A0 = v6;
    v5 = (_DWORD *)v6;
  }
  _BitScanReverse(&v8, ~*v5);
  *v5 |= 1 << v8;
  v9 = &v5[6 * v8];
  result = 0i64;
  v9[2] = v2;
  v9[3] = v3;
  v9[4] = a2;
  return result;
}
// 4045C0: variable 'v2' is possibly undefined
// 4045C4: variable 'v3' is possibly undefined
// 402296: using guessed type __int64 sub_402296(void);
// 4424A0: using guessed type __int64 qword_4424A0;

//----- (00000000004045D5) ----------------------------------------------------
__int64 __fastcall sub_4045D5(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // r12
  unsigned int *v4; // rdi
  __int64 v5; // rax
  int v6; // ecx
  __int64 v7; // rdx
  void (*v8)(void); // rdx
  __int64 v9; // r13
  __int64 v11; // [rsp-8h] [rbp-20h]

  v3 = v2;
  v11 = a2;
LABEL_2:
  while ( 1 )
  {
    v4 = (unsigned int *)qword_4424A0;
    if ( !qword_4424A0 )
      return v11;
    while ( 1 )
    {
      v5 = *v4;
      while ( v5 )
      {
        _BitScanForward((unsigned int *)&v6, v5);
        v7 = (unsigned int)~(1 << v6);
        v5 &= v7;
        if ( !v3 || *(_QWORD *)&v4[6 * v6 + 8] == v3 )
        {
          *v4 &= v7;
          v8 = *(void (**)(void))&v4[6 * v6 + 4];
          if ( v8 )
          {
            v8();
            goto LABEL_2;
          }
        }
      }
      v9 = *((_QWORD *)v4 + 1);
      if ( !v3 )
        break;
      if ( !v9 )
        return v11;
      v4 = (unsigned int *)*((_QWORD *)v4 + 1);
    }
    if ( v9 && sub_40229C )
      sub_40229C();
    qword_4424A0 = v9;
  }
}
// 4045DD: variable 'v2' is possibly undefined
// 404662: variable 'v11' is possibly undefined
// 40229C: using guessed type __int64 sub_40229C(void);
// 4424A0: using guessed type __int64 qword_4424A0;

//----- (000000000040466A) ----------------------------------------------------
char __fastcall sub_40466A(__int64 a1, unsigned __int64 a2)
{
  _QWORD *v2; // rdi
  _QWORD *v3; // rsi
  __int64 v4; // r15
  _QWORD *v6; // r13
  _QWORD *v7; // r12
  __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // r14
  __int64 v16; // rcx
  unsigned __int64 v17; // r8
  __int64 v18; // rcx
  __int64 v19; // rax
  unsigned __int64 v21; // [rsp+0h] [rbp-40h]
  __int64 v22; // [rsp+8h] [rbp-38h]

  v4 = 0i64;
  v6 = v2;
  v7 = v3;
  sub_4047B0(a1);
  if ( sub_4047B0(v9) )
    v4 = *v2;
  v11 = *v3;
  if ( *v6 )
  {
    v12 = v11 + (v11 >> 1);
  }
  else
  {
    v12 = 4i64;
    v10 = 0x1F % a2;
    if ( 0x1F / a2 >= 4 )
      v12 = 0x1F / a2;
  }
  if ( v11 )
  {
    v13 = v11 * a2;
    if ( ((v11 | a2) & 0xFFFFFFFFFFFF0000ui64) != 0 )
    {
      v10 = v13 % v11;
      if ( a2 != v13 / v11 )
        goto LABEL_22;
    }
  }
  v14 = v12 + a1 + 1;
  if ( v12 + a1 == -1i64 )
  {
    v15 = 0i64;
    goto LABEL_15;
  }
  v15 = v14 * a2;
  if ( ((v14 | a2) & 0xFFFFFFFFFFFF0000ui64) != 0 )
  {
    v10 = v15 % v14;
    if ( a2 != v15 / v14 )
    {
LABEL_22:
      sub_401907();
      return 0;
    }
  }
LABEL_15:
  if ( !sub_4022A2 || !sub_4022A2(v14, v10) )
  {
    sub_4018E7();
    return 0;
  }
  v16 = v22;
  v17 = v21;
  if ( !v4 )
  {
    if ( *v6 )
      sub_404F70(v22, v21);
  }
  sub_4050B2(v16, v15 - v17);
  *v7 = v18;
  *v6 = v19;
  return 1;
}
// 40467A: variable 'v2' is possibly undefined
// 40467F: variable 'v3' is possibly undefined
// 404696: variable 'v9' is possibly undefined
// 40474E: variable 'v10' is possibly undefined
// 404758: variable 'v22' is possibly undefined
// 40475C: variable 'v21' is possibly undefined
// 404782: variable 'v16' is possibly undefined
// 40477F: variable 'v17' is possibly undefined
// 404787: variable 'v18' is possibly undefined
// 40478B: variable 'v19' is possibly undefined
// 4022A2: using guessed type __int64 __fastcall sub_4022A2(_QWORD, _QWORD);

//----- (00000000004047B0) ----------------------------------------------------
_BOOL8 __fastcall sub_4047B0(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rbx
  __int64 v3; // rdx
  _BOOL8 result; // rax
  bool v5; // al

  if ( (unsigned __int64)(v1 - 0x600000000000i64) <= 0xFFFFFFFFFFFi64 )
    return 0i64;
  v2 = v1 >> 16;
  v3 = sub_404C04(a1, qword_4427C0[0]);
  result = 0i64;
  if ( v3 )
  {
    v5 = 1;
    if ( LODWORD(qword_4427C0[v3]) != (_DWORD)v2 )
      return dword_4427CC[2 * v3 - 2] == (_DWORD)v2;
    return v5;
  }
  return result;
}
// 4047DC: ignored the value written to the shadow area of the succeeding call
// 4047D4: ignored the value written to the shadow area of the succeeding call
// 4047CB: ignored the value written to the shadow area of the succeeding call
// 4047B0: could not find valid save-restore pair for rbx
// 4047B0: could not find valid save-restore pair for rbp
// 4047C3: variable 'v1' is possibly undefined
// 4427C0: using guessed type __int64 qword_4427C0[];
// 4427CC: using guessed type int dword_4427CC[599];

//----- (000000000040481D) ----------------------------------------------------
__int64 sub_40481D()
{
  return sub_404843(dword_440730 | qword_440728 | 2, 3i64, -1);
}
// 440728: using guessed type __int64 qword_440728;
// 440730: using guessed type int dword_440730;

//----- (0000000000404843) ----------------------------------------------------
__int64 __fastcall sub_404843(char a1, __int64 a2, int a3)
{
  __int64 v3; // rdi
  SIZE_T v4; // rsi
  __int64 v5; // r15
  SIZE_T v7; // rbx
  int v8; // er14
  __int64 v9; // rcx
  __int64 v10; // rax
  int v11; // esi
  __int64 v12; // rdi
  __int64 v13; // r12
  __int64 v14; // rax
  __int64 v15; // rcx
  DWORD v16; // eax
  __int64 v17; // r14
  __int64 v18; // r13
  unsigned __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // rcx
  __int64 v23; // [rsp-8h] [rbp-48h]
  DWORD v24; // [rsp+0h] [rbp-40h]
  DWORD v25; // [rsp+4h] [rbp-3Ch]
  DWORD dwMaximumSizeLow; // [rsp+8h] [rbp-38h]

  v5 = v3;
  v7 = v4;
  v8 = dword_440668 & 4;
  if ( (dword_440668 & 4) == 0 || a3 == -1 )
  {
    v7 = v4 + 0xFFFF;
    LOWORD(v7) = 0;
  }
  v9 = a1 & 0x10;
  if ( (a1 & 0x10) == 0 )
  {
    if ( !v3 )
    {
      v10 = qword_4427C0[0];
      v5 = 0x200000000000i64;
      if ( qword_4427C0[0] )
      {
        do
        {
          --v10;
          v11 = dword_4427CC[2 * v10];
          v12 = v11 + 1;
          if ( v12 + (v7 >> 16) <= 0x30000000 && v11 > 536870910 )
          {
            v5 = v12 << 16;
            goto LABEL_12;
          }
        }
        while ( v10 );
        v5 = (__int64)(HIDWORD(qword_4427C0[qword_4427C0[0]]) + 1) << 16;
      }
    }
LABEL_12:
    LOWORD(v5) = 0;
  }
  if ( qword_4427C0[0] == 300 )
    return sub_4018E7();
  if ( (_DWORD)v9 )
    sub_40452C(v9);
  else
    sub_404C04(v5 >> 16, qword_4427C0[0]);
  if ( v8 )
  {
    v16 = sub_40524A();
    v17 = (__int64)sub_401E9A(HIDWORD(v7), v16, dwMaximumSizeLow, 0i64);
    if ( v17 )
    {
      sub_404C31();
      v13 = (__int64)sub_401EDF(v24, v25, v7, (void *)v5);
      v15 = v23;
      if ( v13 )
        goto LABEL_25;
      sub_401E81();
    }
    v14 = sub_4052D6();
  }
  else
  {
    v14 = sub_404C24();
  }
  v13 = v14;
  v17 = -1i64;
LABEL_25:
  if ( v13 != -1 )
  {
    v18 = v13 >> 16;
    v19 = sub_404C04(v15, qword_4427C0[0]);
    if ( qword_4427C0[0] > v19 )
    {
      sub_405092(8 * (v19 + 2), 8 * (qword_4427C0[0] - v19));
      sub_405092(v21, 8 * (qword_4427C0[0] - v20));
    }
    ++qword_4427C0[0];
    dword_4427C8[2 * v19] = v18;
    qword_443128[v19] = v17;
    dword_4427CC[2 * v19] = ((v7 + 0xFFFF) >> 16) + v18 - 1;
  }
  return v13;
}
// 404973: ignored the value written to the shadow area of the succeeding call
// 4049AA: ignored the value written to the shadow area of the succeeding call
// 40499E: ignored the value written to the shadow area of the succeeding call
// 4049D7: ignored the value written to the shadow area of the succeeding call
// 4049CD: ignored the value written to the shadow area of the succeeding call
// 404849: variable 'v3' is possibly undefined
// 404859: variable 'v4' is possibly undefined
// 4049AC: variable 'dwMaximumSizeLow' is possibly undefined
// 4049E0: variable 'v24' is possibly undefined
// 4049E0: variable 'v25' is possibly undefined
// 4049EC: variable 'v23' is possibly undefined
// 404A23: variable 'v15' is possibly undefined
// 404A76: variable 'v21' is possibly undefined
// 404A6F: variable 'v20' is possibly undefined
// 404A89: variable 'v19' is possibly undefined
// 440668: using guessed type int dword_440668;
// 4427C0: using guessed type __int64 qword_4427C0[];
// 4427C8: using guessed type int dword_4427C8[];
// 4427CC: using guessed type int dword_4427CC[599];
// 443128: using guessed type __int64 qword_443128[303];
// 443AB0: using guessed type __int64 qword_443AB0;

//----- (0000000000404ABB) ----------------------------------------------------
// attributes: thunk
__int64 sub_404ABB()
{
  return sub_4018F7();
}

//----- (0000000000404AC1) ----------------------------------------------------
__int64 __fastcall sub_404AC1(__int64 a1)
{
  __int64 v1; // rdi
  __int64 v2; // rsi
  unsigned int v3; // er13
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // rbx
  __int64 v7; // rcx

  if ( (unsigned __int64)(v1 - 1) <= 0xFFFFFFFFFFFFFFFDui64 && v2 )
  {
    v3 = 0;
    v4 = sub_404C04(a1, qword_4427C0[0]);
    v5 = v4;
    while ( v4 )
    {
      v6 = v4 - 1;
      if ( (int)(v1 >> 16) > dword_4427CC[2 * v4 - 2] )
        break;
      if ( (dword_440668 & 4) != 0 )
      {
        if ( !sub_401EF5() )
          v3 = -1;
        if ( !sub_401E81() )
          v3 = -1;
      }
      else
      {
        v3 |= sub_404DD0();
      }
      v4 = v6;
    }
    if ( v4 < v5 )
    {
      if ( qword_4427C0[0] > v5 )
      {
        sub_405092(8 * (v4 + 1), 8 * (qword_4427C0[0] - v5));
        sub_405092(v7, 8 * (qword_4427C0[0] - v5));
      }
      qword_4427C0[0] = qword_4427C0[0] + v4 - v5;
    }
  }
  else
  {
    return 0;
  }
  return v3;
}
// 404AC2: variable 'v1' is possibly undefined
// 404AE0: variable 'v2' is possibly undefined
// 404BDA: variable 'v7' is possibly undefined
// 404BDF: variable 'v4' is possibly undefined
// 440668: using guessed type int dword_440668;
// 4427C0: using guessed type __int64 qword_4427C0[];
// 4427CC: using guessed type int dword_4427CC[599];

//----- (0000000000404C04) ----------------------------------------------------
__int64 __fastcall sub_404C04(__int64 a1, int a2)
{
  int v2; // edi
  __int64 v3; // rsi
  __int64 result; // rax
  int v5; // ecx

  LODWORD(result) = 0;
  while ( a2 > (int)result )
  {
    v5 = (a2 + (int)result) >> 1;
    if ( *(_DWORD *)(v3 + 8i64 * v5) > v2 )
      a2 = (a2 + (int)result) >> 1;
    else
      LODWORD(result) = v5 + 1;
  }
  return (int)result;
}
// 404C12: variable 'v3' is possibly undefined
// 404C16: variable 'v2' is possibly undefined

//----- (0000000000404C24) ----------------------------------------------------
__int64 sub_404C24()
{
  return sub_404DC0();
}
// 404C28: ignored the value written to the shadow area of the succeeding call

//----- (0000000000404C31) ----------------------------------------------------
__int64 __fastcall sub_404C31()
{
  char v0; // di
  int v1; // esi

  return (8 * v0) & 0x20 | (4 * v0) & 4 | (32 * v1) & 0x80000000 | (v1 >> 2) & 0x20000000 | v0 & 2 | (v1 >> 1) & 1;
}
// 404C5E: variable 'v0' is possibly undefined
// 404C41: variable 'v1' is possibly undefined

//----- (0000000000404C6C) ----------------------------------------------------
bool __fastcall sub_404C6C()
{
  int v0; // edi
  int v1; // esi
  bool result; // al

  result = 0;
  if ( v0 )
    return *(_DWORD *)(qword_443AB0 + 24i64 * v0 + 16) == v1;
  return result;
}
// 404C70: variable 'v0' is possibly undefined
// 404C83: variable 'v1' is possibly undefined
// 443AB0: using guessed type __int64 qword_443AB0;

//----- (0000000000404C87) ----------------------------------------------------
__int64 __fastcall sub_404C87()
{
  int v0; // edi

  if ( v0 == -1 )
    return (int)sub_4018D7();
  if ( sub_404C6C() )
    return MEMORY[0](-1i64, 1i64);
  if ( (dword_440668 & 4) == 0 )
    return sub_404DE0();
  if ( sub_404C6C() )
    return MEMORY[0](0i64, 1i64, 0i64, 0i64);
  if ( sub_404C6C() || sub_404C6C() )
    return sub_401DBA(-1i64, 1i64);
  return sub_4018C7();
}
// 404D8F: ignored the value written to the shadow area of the succeeding call
// 404D84: ignored the value written to the shadow area of the succeeding call
// 404D2D: ignored the value written to the shadow area of the succeeding call
// 404D25: ignored the value written to the shadow area of the succeeding call
// 404C9C: variable 'v0' is possibly undefined
// 440668: using guessed type int dword_440668;
// 443AB0: using guessed type __int64 qword_443AB0;

//----- (0000000000404DB0) ----------------------------------------------------
__int64 sub_404DB0()
{
  return qword_440670();
}
// 440670: using guessed type __int64 (*qword_440670)(void);

//----- (0000000000404DC0) ----------------------------------------------------
__int64 sub_404DC0()
{
  return qword_440670();
}
// 440670: using guessed type __int64 (*qword_440670)(void);

//----- (0000000000404DD0) ----------------------------------------------------
__int64 sub_404DD0()
{
  return qword_440670();
}
// 440670: using guessed type __int64 (*qword_440670)(void);

//----- (0000000000404DE0) ----------------------------------------------------
__int64 sub_404DE0()
{
  return qword_440670();
}
// 440670: using guessed type __int64 (*qword_440670)(void);

//----- (0000000000404DF0) ----------------------------------------------------
__int64 __fastcall sub_404DF0()
{
  __int16 v0; // ax
  __int64 result; // rax

  result = (unsigned int)v0;
  if ( (int)result < 0 )
  {
    dword_443C70 = dword_440700;
    return -1i64;
  }
  else
  {
    __asm { syscall; Low latency system call }
  }
  return result;
}
// 404E02: conditional instruction was optimized away because rax.8<80000000u
// 404DF0: variable 'v0' is possibly undefined
// 404DF0: using guessed type __int64 __fastcall sub_404DF0();
// 440700: using guessed type int dword_440700;
// 443C70: using guessed type int dword_443C70;

//----- (0000000000404E4D) ----------------------------------------------------
__int64 sub_404E4D()
{
  return sub_404E8F();
}

//----- (0000000000404E5C) ----------------------------------------------------
__int64 __fastcall sub_404E5C()
{
  __int64 v0; // rdi
  __int64 v1; // rax
  __int64 v2; // rcx
  int v3; // ecx
  char v4; // dl

  v0 = (unsigned int)v0;
  v1 = 0i64;
  if ( (unsigned int)v0 > 0x7F )
  {
    _BitScanReverse((unsigned int *)&v2, v0);
    v3 = *(_DWORD *)&byte_405347[2 * v2 - 14];
    do
    {
      v4 = v0;
      v0 = (unsigned int)v0 >> 6;
      LOBYTE(v1) = v4 & 0x3F | v1 | 0x80;
      v1 <<= 8;
      LOBYTE(v3) = v3 - 1;
    }
    while ( (_BYTE)v3 );
    LOBYTE(v1) = BYTE1(v3) | v1;
  }
  return v0 | v1;
}
// 404E5E: variable 'v0' is possibly undefined
// 404E6F: variable 'v2' is possibly undefined

//----- (0000000000404E8F) ----------------------------------------------------
__int64 __fastcall sub_404E8F()
{
  __int64 v0; // rdi
  _DWORD *v1; // rsi
  __int64 result; // rax
  __int64 v3; // rdx
  int v4; // ebx
  int v5; // edx
  int v6; // eax

  LODWORD(result) = 0;
  do
  {
    v3 = (unsigned int)result;
    v4 = result;
    result = (unsigned int)(result + 1);
    v5 = *(unsigned __int16 *)(v0 + 2 * v3);
  }
  while ( (v5 & 0xFC00) == 0xDC00 );
  if ( (v5 & 0xFC00) == 0xD800 )
  {
    v6 = *(unsigned __int16 *)(v0 + 2 * result);
    if ( (v6 & 0xFC00) == 0xDC00 )
    {
      *v1 = (v5 << 10) + v6 - 56613888;
      return (unsigned int)(v4 + 2);
    }
    else
    {
      *v1 = 65533;
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    *v1 = v5;
  }
  return result;
}
// 404EA0: variable 'v0' is possibly undefined
// 404EB9: variable 'v1' is possibly undefined

//----- (0000000000404F70) ----------------------------------------------------
void __fastcall sub_404F70(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rcx

  v2 = 32i64;
  if ( a2 < 0x20 )
    v2 = a2;
  __asm { jmp     qword_440448[rcx*8] }
}
// 404F7D: unbalanced stack, ignored a potential tail call

//----- (0000000000404F84) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_404F84(__int64 a1, unsigned __int64 _RDX)
{
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdi
  __int8 *v10; // rsi
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx

  if ( _RDX >= 0x400 )
  {
    if ( _RDX > 0x400000 )
    {
      *_RDI = _mm_loadu_si128(_RSI);
      v8 = ((unsigned __int64)&_RDI[1] & 0xFFFFFFFFFFFFFFF0ui64) - (_QWORD)_RDI;
      v9 = (unsigned __int64)&_RDI[1] & 0xFFFFFFFFFFFFFFF0ui64;
      v10 = &_RSI->m128i_i8[v8];
      v11 = _RDX - v8;
      v12 = 16i64;
      do
      {
        v12 += 16i64;
        _mm_stream_si128((__m128i *)(v9 + v12 - 32), _mm_loadu_si128((const __m128i *)&v10[v12 - 32]));
      }
      while ( v11 > v12 );
      _mm_sfence();
      *(__m128i *)(v9 + v11 - 16) = _mm_loadu_si128((const __m128i *)&v10[v11 - 16]);
    }
    else
    {
      qmemcpy(_RDI, _RSI, _RDX);
    }
  }
  else
  {
    _RCX = 32i64;
    do
    {
      _RCX += 32i64;
      __asm
      {
        vmovdqu ymm3, ymmword ptr [rsi+rcx-40h]
        vmovdqu ymmword ptr [rdi+rcx-40h], ymm3
      }
    }
    while ( _RDX > _RCX );
    __asm
    {
      vmovdqu ymm3, ymmword ptr [rsi+rdx-20h]
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm3
      vpxor   ymm3, ymm3, ymm3
    }
  }
}
// 405009: positive sp value 8 has been found
// 405039: variable '_RDI' is possibly undefined
// 405039: variable '_RSI' is possibly undefined

//----- (0000000000405092) ----------------------------------------------------
void __fastcall sub_405092(__int64 a1, __int64 a2)
{
  _BYTE *v2; // rdi
  _BYTE *v3; // rsi
  __int64 v4; // rcx

  v4 = a2;
  if ( v2 >= v3 )
  {
    v2 = &v2[a2 - 1];
    v3 = &v3[a2 - 1];
  }
  while ( v4 )
  {
    *v2-- = *v3--;
    --v4;
  }
}
// 40509B: variable 'v2' is possibly undefined
// 40509B: variable 'v3' is possibly undefined

//----- (00000000004050B2) ----------------------------------------------------
void __fastcall sub_4050B2(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rcx

  v2 = 32i64;
  if ( a2 < 0x20 )
    v2 = a2;
  __asm { jmp     qword ptr [rbx+rcx*8] }
}
// 4050C9: unbalanced stack, ignored a potential tail call

//----- (00000000004050CC) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_4050CC(__int64 a1, unsigned __int64 _RDX, __int64 a3, double _XMM3_8)
{
  char v5; // si

  if ( _RDX >= 0x400 )
  {
    memset(_RDI, v5, _RDX);
  }
  else
  {
    __asm { vpbroadcastb ymm3, xmm3 }
    _RCX = 32i64;
    do
    {
      _RCX += 32i64;
      __asm { vmovdqu ymmword ptr [rdi+rcx-40h], ymm3 }
    }
    while ( _RDX > _RCX );
    __asm
    {
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm3
      vxorps  ymm3, ymm3, ymm3
    }
  }
}
// 405133: positive sp value 10 has been found
// 4050CC: could not find valid save-restore pair for rbx
// 4050CC: inconsistent variable size for 'xmm3_8.8(_XMM3_8)'

//----- (000000000040517E) ----------------------------------------------------
__int64 __fastcall sub_40517E(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // r8
  __int64 v5; // rcx
  __int64 v6; // rax
  __int64 result; // rax

  if ( v2 != v3 && a2 )
  {
    v4 = (a2 >> 4) + 1;
    v5 = -16i64;
    do
    {
      v5 += 16i64;
      if ( !--v4 )
        goto LABEL_7;
      LODWORD(v6) = _mm_movemask_epi8(
                      _mm_cmpeq_epi8(
                        _mm_loadu_si128((const __m128i *)(v2 + v5)),
                        _mm_loadu_si128((const __m128i *)(v3 + v5))))
                  - 0xFFFF;
    }
    while ( !(_DWORD)v6 );
    _BitScanForward((unsigned int *)&v6, v6);
    v5 += v6;
LABEL_7:
    while ( a2 != v5 )
    {
      ++v5;
      result = *(unsigned __int8 *)(v2 + v5 - 1) - (unsigned int)*(unsigned __int8 *)(v3 + v5 - 1);
      if ( (_DWORD)result )
        return result;
    }
  }
  return 0i64;
}
// 405181: variable 'v2' is possibly undefined
// 405181: variable 'v3' is possibly undefined
// 4051C0: variable 'v6' is possibly undefined

//----- (00000000004051E0) ----------------------------------------------------
__int64 __fastcall sub_4051E0(__int64 a1, unsigned int a2)
{
  __int64 v2; // rdi
  __int64 v3; // rsi
  __int64 result; // rax
  int v5; // ebx
  __int64 v6; // rcx

  result = 0i64;
  v5 = 0;
  v6 = 0i64;
  if ( a2 && v3 != v2 )
  {
    while ( (unsigned int)v6 < a2 )
    {
      LODWORD(result) = *(unsigned __int8 *)(v2 + v6);
      v5 = *(unsigned __int8 *)(v3 + v6);
      if ( !(_BYTE)result || (_BYTE)result != (_BYTE)v5 )
        break;
      v6 = (unsigned int)(v6 + 1);
    }
    return (unsigned int)(result - v5);
  }
  return result;
}
// 4051EF: variable 'v3' is possibly undefined
// 4051EF: variable 'v2' is possibly undefined

//----- (0000000000405211) ----------------------------------------------------
void __fastcall __noreturn sub_405211()
{
  unsigned __int8 v0; // di

  dword_443C74 |= 4u;
  if ( (dword_440668 & 4) != 0 )
    ExitProcess(v0);
  __asm { syscall; Low latency system call }
  _disable();
  __lidt(byte_405242);
  __halt();
}
// 405221: variable 'v0' is possibly undefined
// 440668: using guessed type int dword_440668;
// 443C74: using guessed type int dword_443C74;

//----- (000000000040524A) ----------------------------------------------------
__int64 __fastcall sub_40524A()
{
  int v0; // edi
  int v1; // esi
  int v2; // edx

  if ( (v0 & 7) == 7 )
  {
    v2 = 64;
    if ( (v1 & 1) == 0 && qword_440728 != (qword_440728 & v1) )
      v2 = 128;
  }
  else if ( (v0 & 3) == 3 )
  {
    v2 = 4;
    if ( (v1 & 1) == 0 )
      v2 = 4 * (qword_440728 != (qword_440728 & v1)) + 4;
  }
  else
  {
    v2 = 32;
    if ( (v0 & 5) != 5 )
    {
      v2 = 16;
      if ( (v0 & 4) == 0 )
        v2 = (v0 & 1) + 1;
    }
  }
  return v2 | (v0 | v1) & 0xDD000000;
}
// 40524E: variable 'v0' is possibly undefined
// 405256: variable 'v1' is possibly undefined
// 440728: using guessed type __int64 qword_440728;

//----- (00000000004052D6) ----------------------------------------------------
__int64 sub_4052D6()
{
  if ( (dword_440668 & 4) == 0 )
    return sub_4018F7();
  dword_443C70 = sub_401EC9();
  return -1i64;
}
// 4052DF: ignored the value written to the shadow area of the succeeding call
// 440668: using guessed type int dword_440668;
// 443C70: using guessed type int dword_443C70;

// nfuncs=88 queued=85 decompiled=85 lumina nreq=0 worse=0 better=0
// ALL OK, 85 function(s) have been successfully decompiled
