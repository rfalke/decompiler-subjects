// subject_DATA_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui64 g_qw440000 = 0x1000007FEEDFACF; // 0000000000440000
cu8 g_b440008 = 0x03; // 0000000000440008
byte g_b44003D = 0x00; // 000000000044003D
<anonymous> * g_a440448[] = // 0000000000440448
	{
	};
<anonymous> * g_a440550[] = // 0000000000440550
	{
	};
byte g_b440668 = ~0x13; // 0000000000440668
<anonymous> * g_ptr440670 = &g_tE57501E9; // 0000000000440670
<anonymous> * g_ptr440678 = &g_tC283F289; // 0000000000440678
<anonymous> * g_ptr440680 = &g_t475E020; // 0000000000440680
<anonymous> * g_ptr440688 = &g_tF289F889; // 0000000000440688
uint64 g_a440698[33] = // 0000000000440698
	{
		0x74033CF889C08E00,
		6341185919624491010,
		0x20B500B001B410CD,
		0x3B010B410CD00B1,
		0xC03110CD00B300B7,
		~0x137C1A76AA3CA2A4,
		0xE789E689F9899610,
		1075051898191448490,
		17476776312147586134,
		0x8953E58955F2295E,
		0xE68000E280FA89D1,
		0xB70FD680A0C28080,
		0x772974FA39A0B300,
		953657510692957202,
		0xE983AA07B0AA1274,
		14077509133253768449,
		3554176327318494977,
		16639493128419276754,
		13281359982555713872,
		0xEE85808EB0000,
		0x8E85804EB0000,
		14333647379828230025,
		9223619980913398519,
		2977425990546325733,
		203194936232441,
		9896030541708461854,
		0x15CDDB315300B8E5,
		1474172748895951474,
		0x3115CDDB315301B8,
		122532907499205083,
		0x550AE1E815CD03B1,
		0x179E8001DE8E589,
		0x7AE82000BE1000BF,
	};
int64 g_qw4406B8 = -0x3FCEEF32FF4CFF49; // 00000000004406B8
int32 g_dw4406F8 = 0x39A0B300; // 00000000004406F8
int32 g_dw440708 = -1331031436; // 0000000000440708
int32 g_dw440710 = -0x76178AFF; // 0000000000440710
word32 g_dw440798 = 0xBE1000BF; // 0000000000440798
word64 g_qw4407A0 = 0xECE800C7E8097200; // 00000000004407A0
struct Eq_653 g_t442000 = // 0000000000442000
	{
		0xD2,
		-0x74B7EBBD,
		4282980427,
		18122949,
		0x8B20738B,
		&g_a4E8D1443,
		0x104B8BC8,
		&g_tA7402FE,
	};
word32 g_dw442004 = 0x8B000000; // 0000000000442004
Eq_577 g_t44200C = // 000000000044200C
	{
		77837477545056331
	};
ptr64 g_ptr442018 = 2432225270779679811; // 0000000000442018
word32 g_dw442020 = 0x104B8BC8; // 0000000000442020
ptr64 g_ptr442030 = 8489001898646700798; // 0000000000442030
struct Eq_653 * g_ptr442038 = &g_tAFA805A; // 0000000000442038
up64 g_qw442040 = 0x480774D285483053; // 0000000000442040
up64 g_qw442048 = 14427577088254926729; // 0000000000442048
struct Eq_705 * g_ptr442050 = &g_t89484175; // 0000000000442050
Eq_705 g_t442058 = // 0000000000442058
	{
		&g_tF8830000,
		
		{
		},
	};
word32 g_dw442410 = 1211200768; // 0000000000442410
ui64 g_qw442460 = 0x285089480874D285; // 0000000000442460
word64 g_qw442468 = 0x4CF6894C30428948; // 0000000000442468
uint64 g_qw442470 = 35961371641225; // 0000000000442470
word64 g_qw442478 = 14431093739939545221; // 0000000000442478
word64 g_qw442480 = 3677107792205; // 0000000000442480
word32 g_dw442488 = 612665677; // 0000000000442488
struct Eq_1517 * g_ptr4424A0 = &g_tFA812B74; // 00000000004424A0
Eq_1517 g_t4424A8 = // 00000000004424A8
	{
		0x1FB8,
		&g_t26B9D2BD,
		
		{
		},
	};
word32 g_dw4427C0 = 0x4820488D; // 00000000004427C0
Eq_1916 g_a4427C8[] = // 00000000004427C8
	{
	};
Eq_1914 g_a4427CC[] = // 00000000004427CC
	{
	};
word64 g_qw443AA0 = 0x483273D339480003; // 0000000000443AA0
word64 g_qw443AA8 = 280937339336317481; // 0000000000443AA8
Eq_1902 (* g_ptr443AB0)[] = &g_a15894800; // 0000000000443AB0
word64 g_qw443AB8 = 0x180C8D4801CA8348; // 0000000000443AB8
word32 g_dw443AC8 = 0x48085189; // 0000000000443AC8
word64 g_qw443AD0 = 0xEB10C08348085889; // 0000000000443AD0
word32 g_dw443AE0 = 0x5C415B5A; // 0000000000443AE0
word64 g_qw443AE8 = 0x4FB840FFF8548; // 0000000000443AE8
word32 g_dw443AF8 = 0xE58948F0; // 0000000000443AF8
up32 g_dw443C68 = 0xD1894808; // 0000000000443C68
int32 g_dw443C70 = 1963194755; // 0000000000443C70
ui32 g_dw443C74 = 0xE2834822; // 0000000000443C74
// subject_DATA_data_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr406008 = fn00000000004014E0; // 0000000000406008
<anonymous> * g_ptr406010 = null; // 0000000000406010
uint64 g_a406018[] = // 0000000000406018
	{
	};
<anonymous> * g_ptr406038 = &g_t56E8; // 0000000000406038
<anonymous> * g_ptr406070 = &g_t578E; // 0000000000406070
<anonymous> * g_ptr406080 = &g_t57AC; // 0000000000406080
<anonymous> * g_ptr406088 = &g_t57BC; // 0000000000406088
// subject_TEXT_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401000: void fn0000000000401000(Register (ptr64 Eq_2) rbp)
// Called from:
//      fn0000000000404491
void fn0000000000401000(struct Eq_2 * rbp)
{
}

// 0000000000401158: Register word64 fn0000000000401158(Register (ptr64 ui64) rcx, Register ui64 rdx, Register word32 esi, Register uint64 rdi)
// Called from:
//      fn0000000000401000
word64 fn0000000000401158(ui64 * rcx, ui64 rdx, word32 esi, uint64 rdi)
{
	Eq_146 ecx_71 = 0x27;
	while (true)
	{
		--esi;
		uint64 rax_17 = (uint64) ((word32) (rdi >> (byte) ecx_71) & 0x01FF);
		if (esi == ~0x00)
			break;
		ui64 * rdx_22 = rdx + rax_17 * 0x08;
		if (*rdx_22 == 0x00)
		{
			ui64 rax_27 = *rcx;
			*rcx = rax_27 - 0x1000;
			*rdx_22 = rax_27 - 0x1000 | 0x03;
		}
		ecx_71.u0 = (uint64) (ecx_71 - 0x09);
		rdx = *rdx_22 & 0x3FFFFFFFFF000;
	}
	return rdx + rax_17 * 0x08;
}

// 000000000040129E: void fn000000000040129E(Stack Eq_194 tArg08)
void fn000000000040129E(Eq_194 tArg08)
{
	ptr64 fp;
	g_b440668 = 0x08;
	word64 * rdi_10 = g_a406018;
	uint64 rcx_132;
	for (rcx_132 = 0x14; rcx_132 != 0x00; --rcx_132)
	{
		*rdi_10 = 4199021;
		++rdi_10;
	}
	uint64 rcx_24 = 0xFFFFFFFF;
	Eq_204 rdi_141 = fp + 24;
	while (rcx_24 != 0x00)
	{
		rdi_141.u1 = (word64) rdi_141 + 8;
		--rcx_24;
		if (*rdi_141.u1 != 0x00)
			break;
	}
	__align_stack<word64>(fp);
	fn00000000004012F0(0x00400000, &tArg08, rdi_141);
	g_dw443C74 |= 0x01;
	ptr64 rsp_108 = <invalid>;
	<anonymous> ** rax_126 = &g_ptr406008;
	<anonymous> ** rcx_122 = &g_ptr406010;
	while (rcx_122 != rax_126)
	{
		struct Eq_255 * rsp_109 = rsp_108 - 8;
		rsp_109->ptr0000 = rax_126;
		rsp_109->ptrFFFFFFF8 = rcx_122;
		struct Eq_264 * rsp_113;
		(*rax_126)();
		rcx_122 = rsp_113->ptr0000;
		rsp_108 = &rsp_113->qw0008 + 1;
		rax_126 = rsp_113->qw0008 + 0x08;
	}
	fn00000000004018AE(fn00000000004014CE());
}

// 00000000004012F0: void fn00000000004012F0(Register word32 ebx, Register (ptr64 word64) r13, Register Eq_204 r15)
// Called from:
//      fn000000000040129E
void fn00000000004012F0(word32 ebx, word64 * r13, Eq_204 r15)
{
	ptr64 fp;
	word64 rbx;
	word32 ebx_419 = (word32) rbx;
	ui64 edx_eax_11 = __rdtsc();
	g_qw440000 = edx_eax_11;
	byte * rsi_10 = g_a4058F0;
	word32 edx_17 = (word32) edx_eax_11;
	struct Eq_293 * rdi_101 = &g_b440008;
	struct Eq_295 * rsp_36 = fp - 44;
	word32 eax_41 = 0x00;
l000000000040131D:
	__cpuid(eax_41, 0x00, &eax_41, &ebx_419, &0x00, &edx_17);
	rdi_101->dw0000 = eax_41;
	struct Eq_328 * rdi_56 = &rdi_101->dw0000 + 1;
	rdi_56->dw0000 = ebx_419;
	rdi_56->dw0004 = 0x00;
	rdi_56->dw0008 = edx_17;
	ebx_419 = eax_41;
	edx_17 = 0x00;
	rdi_101 = (struct Eq_293 *) (&rdi_56->dw0008 + 1);
	while (true)
	{
		word64 rax_74 = rsp_36->qw0000;
		eax_41 = (word32) rax_74;
		cu8 al_412 = (byte) rax_74;
		++rsp_36;
		if (eax_41 == 0x00)
			break;
		if (al_412 <= g_b440008)
			goto l000000000040131D;
		rdi_101 += 2;
	}
	word64 rbx_81 = rsp_36->qw0000;
	byte ch_109;
	for (ch_109 = 0x11; ch_109 != 0x00; --ch_109)
	{
		byte * rsi_91 = rsi_10 + 1;
		byte cl_104 = *rsi_10;
		rsi_10 = rsi_91 + 1;
		uint64 rax_96 = (uint64) *rsi_91;
		do
		{
			rdi_101->dw0000 = (word32) (rax_96 + 0x00404F07);
			++rdi_101;
			--cl_104;
		} while (cl_104 != 0x00);
	}
	byte * rsi_220;
	rdi_101->dw0000 = (word32) r15;
	struct Eq_389 * rdi_131;
	byte * rsi_132;
	Eq_391 rbx_129 = fn000000000040161F(rbx_81, fp - 8, rsi_91 + 7, rdi_101 + 1, out rsi_132, out rdi_131);
	struct Eq_409 * rsi_139 = fn000000000040189D(rsi_132, rdi_131);
	rdi_131->b0000 = (byte) ~0x00;
	rdi_131[8] = (struct Eq_389) ~0x00;
	rdi_131[16] = (struct Eq_389) 4215166;
	rsp_36->dw0004 = 0x20;
	word64 * rdi_170;
	struct Eq_409 * rsi_171 = fn000000000040186F(rsp_36->dw0004, 0x00404F84, rsi_139, rdi_131 + 24, out rdi_170);
	rsp_36[1] = (struct Eq_295) 0x20;
	struct Eq_452 * rdi_190;
	struct Eq_409 * rsi_191 = fn000000000040186F(rsp_36[1], 0x004050CC, rsi_171, rdi_170, out rdi_190);
	rdi_190->qw0000 = *r13;
	rdi_190->qw0008 = 0x004051E0;
	rsp_36[1] = (struct Eq_295) rbx_129;
	rsp_36->qw0000 = rsi_191;
	if ((rdi_190->t0010.u0 & 0x08) == 0x00)
	{
		if ((rdi_190->t0010.u0 & 0x20) == 0x00)
		{
			if ((rdi_190->t0010.u0 & 0x04) == 0x00)
			{
				if (*r15.u1 != 0x00)
				{
					rsp_36->dwFFFFFFFC = 0x00;
					rsp_36->dwFFFFFFF8 = 0x01;
					rsi_220 = &g_b4059B6;
				}
				else
				{
					rsp_36->dwFFFFFFFC = 0x2A;
					rsp_36->dwFFFFFFF8 = 0x10;
					rsi_220 = &g_b4059E1;
				}
			}
			else
			{
				rsp_36->dwFFFFFFFC = 0x22;
				rsp_36->dwFFFFFFF8 = 0x04;
				rsi_220 = &g_b405A0D;
			}
		}
		else
		{
			rsp_36->dwFFFFFFFC = 0x30;
			rsp_36->dwFFFFFFF8 = 0x20;
			rsi_220 = &g_b405989;
		}
	}
	else
	{
		rsp_36->dwFFFFFFFC = 0x45;
		rsp_36->dwFFFFFFF8 = 0x08;
		rsi_220 = &g_b405A52;
	}
	rdi_190->t0010.u1 = rsp_36->qw0000;
	word32 * rsp_260 = rsp_36 + 1;
	word64 rax_264 = *rsp_260;
	rdi_190->qw0018 = rax_264 + 0x00404DF0;
	*rsp_260 = (word32) (&rdi_190->qw0018 + 1);
	word56 rax_56_8_444 = SLICE(rax_264 + 0x00404DF0, word56, 8);
	word64 * rdi_272;
	for (rdi_272 = g_a440698; rdi_272 < &g_qw4407A0; ++rdi_272)
	{
		uint64 rdx_360 = 0x00;
		Eq_604 ecx_477 = 0x00;
		do
		{
			ecx_477.u0 = (uint64) ((word64) ecx_477 + 7);
			ci8 al_367 = *rsi_220;
			++rsi_220;
			byte cl_394 = (byte) ecx_477;
			rdx_360 |= (uint64) ((word32) SEQ(rax_56_8_444, al_367) & 0x7F) << (byte) ecx_477;
		} while (al_367 < 0x00);
		if ((al_367 & 0x40) != 0x00)
			rdx_360 |= ~0x00 << cl_394;
		uint64 rax_401 = rdx_360;
		if (*rdi_272 != 0x00)
			rax_401 = *rdi_272;
		*rdi_272 = rax_401;
		rax_56_8_444 = SLICE(rax_401, word56, 8);
	}
	struct Eq_573 * rsp_300;
	struct Eq_574 * rdi_301;
	g_ptr406088();
	rsp_300->t001C.u1 = 0x01;
	g_t44200C.u0 = rsp_300->t001C.u0;
	g_dw442004 = g_dw440798;
	g_ptr442018 = 0x00441000;
	g_dw442020 = 0x1000;
	ptr64 rdx_323 = 0x00402250;
	if ((g_b440668 & 0x02) == 0x00)
		rdx_323 = 4202942;
	g_ptr442030 = rdx_323;
	g_ptr442038 = (struct Eq_653 *) &g_t442000;
	rdi_301->qw0000 = 0x00403FED;
	fn00000000004015CB();
	rdi_301->qw0008 = 0x00403AE8;
	rdi_301->qw0010 = 0x004043D8;
}

// 00000000004014CE: Register word32 fn00000000004014CE()
// Called from:
//      fn000000000040129E
word32 fn00000000004014CE()
{
	fn0000000000401F47(&g_b405301);
	return 0x00;
}

// 00000000004014E0: void fn00000000004014E0(Register word32 ebx)
// Called from:
//      fn000000000040129E
void fn00000000004014E0(word32 ebx)
{
	word64 rbx;
	struct Eq_653 * r12_13 = g_ptr442038;
	if ((g_b440668 & 0x04) != 0x00 || fn0000000000401674((uint64) r12_13->dw000C) != 0x00)
		r12_13->b0000 = 0x01;
	word32 dwLoc28_195 = (word32) rbx;
	if (g_ptr442050 == null)
	{
		g_ptr442050 = &g_t442058;
		g_qw442048 = SEQ(dwLoc28_195, 0x08);
		fn0000000000404540(0x00, 0x00, 0x004020EC);
	}
	up64 r12_100 = g_qw442040;
	struct Eq_705 * rax_101 = g_ptr442050;
	ui64 rbx_102 = r12_100 - 1;
	do
	{
		if (rbx_102 == ~0x00)
		{
			if (r12_100 + 1 < g_qw442048 || fn000000000040466A(0x01, 0x08, &g_qw442048, &g_ptr442050) != 0x00)
			{
				g_ptr442050->ptr0000 = r12_13;
				g_qw442040 = r12_100 + 1;
			}
			return;
		}
		struct Eq_653 ** rdx_151 = rax_101 + rbx_102;
		--rbx_102;
	} while (rax_101->a0008[rbx_102] != 0x00);
	*rdx_151 = (struct Eq_653 **) r12_13;
}

// 00000000004015CB: Register word64 fn00000000004015CB()
// Called from:
//      fn00000000004012F0
word64 fn00000000004015CB()
{
	return fn0000000000404491();
}

// 000000000040161F: Register word64 fn000000000040161F(Register word64 rbx, Register ptr64 rbp, Register ptr64 rsi, Register ptr64 rdi, Register out ptr64 rsiOut, Register out ptr64 rdiOut)
// Called from:
//      fn000000000040129E
//      fn00000000004012F0
word64 fn000000000040161F(word64 rbx, ptr64 rbp, ptr64 rsi, ptr64 rdi, ptr64 & rsiOut, ptr64 & rdiOut)
{
	word32 dwLoc44;
	word32 dwLoc40;
	word32 dwLoc3C;
	word32 dwLoc20;
	<anonymous> * rbp_24 = g_ptr406080;
	g_qw443AA0 = SEQ(dwLoc44, 0x03);
	g_ptr443AB0 = (Eq_1902 (*)[]) &g_qw443AB8;
	g_qw443AA8 = SEQ(dwLoc40, 0x10);
	g_dw443AC8 = 0x01;
	g_dw443AE0 = 0x01;
	g_dw443AF8 = 0x01;
	word64 qwLoc40_96 = SEQ(dwLoc3C, 0x01);
	struct Eq_806 * rsp_42;
	word64 rdi_44;
	word64 rsi_45;
	word64 rax_46;
	rbp_24();
	rsp_42->tFFFFFFFC.u1 = ~0x0A;
	Eq_810 rcx_50 = rsp_42->tFFFFFFFC.u0;
	g_qw443AB8 = rax_46;
	struct Eq_820 * rsp_53;
	word64 rdi_55;
	word64 rsi_56;
	word64 rax_57;
	rbp_24();
	rsp_53->tFFFFFFFC.u1 = ~0x0B;
	Eq_824 rcx_61 = rsp_53->tFFFFFFFC.u0;
	g_qw443AD0 = rax_57;
	word64 rax_68;
	rbp_24();
	g_qw443AE8 = rax_68;
	rsiOut = SEQ((word32) rsi, SLICE(rbx, word32, 32));
	rdiOut = SEQ((word32) rdi, SLICE(rsi, word32, 32));
	return SEQ((word32) rbx, dwLoc20);
}

// 0000000000401674: Register Eq_845 fn0000000000401674(Register uint64 rdi)
// Called from:
//      fn00000000004014E0
Eq_845 fn0000000000401674(uint64 rdi)
{
	ptr64 fp;
	ui32 dwLocF0;
	word32 edi = (word32) rdi;
	bool v37_123;
	Eq_845 r13d_109 = g_b440668 & 0x04;
	if (r13d_109 == 0x00)
	{
		int32 ebx_90 = g_dw443C70;
		if (fn0000000000401711(fp - 264) == ~0x00)
		{
			g_dw443C70 = ebx_90;
			return r13d_109;
		}
		v37_123 = (dwLocF0 & 0xF000) == 0x2000;
	}
	else
	{
		uint64 rax_40 = (uint64) fn0000000000404C6C(0x01, (word32) rdi);
		r13d_109.u1 = 0x00;
		word32 eax_66 = (word32) rax_40;
		if ((byte) rax_40 == 0x00)
			return r13d_109;
		fn0000000000401EB0(g_ptr443AB0[(int64) edi].qw0000);
		v37_123 = eax_66 == 0x02;
	}
	r13d_109.u1 = (word32) v37_123;
	return r13d_109;
}

// 0000000000401711: Register word32 fn0000000000401711(Register (ptr64 Eq_877) rsi)
// Called from:
//      fn0000000000401674
word32 fn0000000000401711(struct Eq_877 * rsi)
{
	uint64 rax_14 = (uint64) fn0000000000404DB0();
	word32 eax_15 = (word32) rax_14;
	if (eax_15 != ~0x00)
	{
		fn000000000040173E(rsi);
		rax_14 = (uint64) eax_15;
	}
	return (word32) rax_14;
}

// 000000000040173E: void fn000000000040173E(Register (ptr64 Eq_877) rdi)
// Called from:
//      fn0000000000401711
void fn000000000040173E(struct Eq_877 * rdi)
{
	if (rdi == null)
		return;
	Eq_919 rax_100;
	Eq_919 rdx_122;
	Eq_919 rcx_119;
	Eq_919 rsi_116;
	Eq_919 r8_113;
	Eq_919 r9_109;
	byte al_17 = g_b440668;
	if ((al_17 & 0x08) != 0x00)
	{
		Eq_938 r14_86 = (uint64) rdi->w0006;
		Eq_943 r13d_103 = (word32) rdi->t0004.u0;
		Eq_919 r10_89 = (int64) rdi->t0070.u1;
		Eq_943 r15_90 = (int64) rdi->t0000.u2;
		Eq_938 r12_91 = rdi->t0010.u0;
		Eq_919 r11_92 = rdi->t0060.u0;
		r8_113.u0 = rdi->t0028.u0;
		rdi->t0028.u0 = (int64) rdi->t0018.u2;
		Eq_919 rbx_95 = rdi->t0068.u0;
		r9_109.u0 = rdi->t0020.u0;
		rsi_116.u0 = rdi->t0030.u0;
		rcx_119.u0 = rdi->t0038.u0;
		rdx_122.u0 = rdi->t0040.u0;
		rax_100.u0 = rdi->t0048.u0;
		rdi->t0000.u0 = (int64) r15_90;
		rdi->t0010.u0 = (uint64) r14_86;
		rdi->t0018.u2 = (word32) r13d_103;
		rdi->t001C.u0 = (uint64) r12_91;
		rdi->t0030.u0 = (int64) r11_92;
		rdi->t0038.u0 = (int64) r10_89;
		rdi->t0040.u0 = (int64) rbx_95;
	}
	else
	{
		Eq_919 r10_49;
		Eq_919 r11_47;
		Eq_919 rbx_48;
		if ((al_17 & 0x20) != 0x00)
		{
			r11_47.u0 = (int64) rdi->dw0080;
			rbx_48.u0 = rdi->t0070.u0;
			r10_49.u0 = rdi->t0078.u0;
			r9_109.u0 = rdi->t0030.u0;
			r8_113.u0 = rdi->t0038.u0;
			rsi_116.u0 = rdi->t0040.u0;
			rcx_119.u0 = rdi->t0048.u0;
			rdx_122.u0 = rdi->t0050.u0;
			rax_100.u0 = rdi->t0058.u0;
			rdi->t0018.u2 = (word32) rdi->t0018.u1;
		}
		else
		{
			if ((al_17 & 0x10) == 0x00)
				return;
			Eq_919 r12_43 = (int64) rdi->t001C.u1;
			Eq_943 r14d_59 = rdi->t0000.u2;
			Eq_938 r13_46 = rdi->t0014.u0;
			r11_47.u0 = (int64) rdi->t0060.u1;
			rbx_48.u0 = rdi->t0050.u0;
			r10_49.u0 = rdi->t0058.u0;
			rsi_116.u0 = rdi->t0030.u0;
			rdi->t0000.u0 = (int64) rdi->t0004.u1;
			Eq_938 r15_53 = (uint64) rdi->t0010.u1;
			rcx_119.u0 = rdi->t0038.u0;
			rdx_122.u0 = rdi->t0040.u0;
			rax_100.u0 = rdi->t0048.u0;
			r9_109.u0 = rdi->t0020.u0;
			r8_113.u0 = rdi->t0028.u0;
			rdi->t0018.u2 = (word32) r14d_59;
			rdi->t0010.u0 = (uint64) r15_53;
			rdi->t001C.u0 = (uint64) r13_46;
			rdi->t0028.u0 = (int64) r12_43;
		}
		rdi->t0030.u0 = (int64) rbx_48;
		rdi->t0038.u0 = (int64) r11_47;
		rdi->t0040.u0 = (int64) r10_49;
	}
	rdi->t0048.u0 = (int64) r9_109;
	rdi->t0050.u0 = (int64) r8_113;
	rdi->t0058.u0 = (int64) rsi_116;
	rdi->t0060.u0 = (int64) rcx_119;
	rdi->t0068.u0 = (int64) rdx_122;
	rdi->t0070.u0 = (int64) rax_100;
}

// 000000000040186F: Register (ptr64 Eq_409) fn000000000040186F(Register word32 ecx, Register uint64 rdx, Register (ptr64 Eq_409) rsi, Register (ptr64 word64) rdi, Register out ptr64 rdiOut)
// Called from:
//      fn00000000004012F0
struct Eq_409 * fn000000000040186F(word32 ecx, uint64 rdx, struct Eq_409 * rsi, word64 * rdi, ptr64 & rdiOut)
{
	bool Z;
	int8 r8b_4 = (int8) Z;
	do
	{
		*rdi = (uint64) rsi->t0000 + rdx;
		++rsi;
		++rdi;
		--ecx;
	} while (ecx != 0x00);
	*rdi = (uint64) rsi[(uint64) ((int8) ((g_b44003D & 0x02) != 0x00) | r8b_4 << 0x01)] + rdx;
	rdiOut = rdi + 1;
	return rsi + 8;
}

// 000000000040189D: Register (ptr64 byte) fn000000000040189D(Register (ptr64 byte) rsi, Register (ptr64 Eq_389) rdi)
// Called from:
//      fn00000000004012F0
byte * fn000000000040189D(byte * rsi, struct Eq_389 * rdi)
{
	word56 rcx_56_8_18 = 0x00;
	while (true)
	{
		byte * rsi_12 = rsi + 1;
		byte al_11 = *rsi;
		byte al_16 = *rsi_12;
		rsi = rsi_12 + 1;
		word32 ecx_24 = SEQ((word24) rcx_56_8_18, al_11);
		if (SEQ(rcx_56_8_18, al_11) == 0x00)
			break;
		do
		{
			rdi->b0000 = al_16;
			uint64 rcx_26 = (uint64) (ecx_24 - 0x01);
			++rdi;
			ecx_24 = (word32) rcx_26;
			rcx_56_8_18 = SLICE(rcx_26, word56, 8);
		} while (ecx_24 != 0x00);
	}
	return rsi_12 + 1;
}

// 00000000004018AE: void fn00000000004018AE(Register word32 edi)
// Called from:
//      fn000000000040129E
void fn00000000004018AE(word32 edi)
{
	fn00000000004045D5(0x00);
	fn0000000000405211((byte) edi);
}

// 00000000004018E7: void fn00000000004018E7()
// Called from:
//      fn0000000000404540
//      fn000000000040466A
void fn00000000004018E7()
{
	g_dw443C70 = g_dw4406F8;
}

// 0000000000401907: void fn0000000000401907()
// Called from:
//      fn000000000040466A
void fn0000000000401907()
{
	g_dw443C70 = g_dw440708;
}

// 0000000000401EB0: void fn0000000000401EB0(Register word64 rdi)
// Called from:
//      fn0000000000401674
void fn0000000000401EB0(word64 rdi)
{
	g_ptr406070();
}

// 0000000000401F47: void fn0000000000401F47(Register (ptr64 byte) rdi)
// Called from:
//      fn00000000004014CE
void fn0000000000401F47(byte * rdi)
{
	struct Eq_653 * r12_10 = g_ptr442038;
	if (fn0000000000401FE7(r12_10, rdi) == ~0x00 || fn0000000000401F82(r12_10, 0x0A) == ~0x00)
		;
}

// 0000000000401F82: Register word32 fn0000000000401F82(Register (ptr64 Eq_653) rsi, Register word32 edi)
// Called from:
//      fn0000000000401F47
word32 fn0000000000401F82(struct Eq_653 * rsi, word32 edi)
{
	byte dil_15 = (byte) edi;
	uint64 rax_119;
	if (edi != ~0x00)
	{
		rsi->ptr0018[(uint64) rsi->dw0014] = dil_15;
		uint64 rsi_20 = (uint64) rsi->dw0020;
		ui32 eax_32 = rsi->dw0014 + 0x01 & (word32) rsi_20 - 0x01;
		ui32 edx_34 = rsi->dw0010;
		rsi->dw0014 = eax_32;
		if (eax_32 != edx_34)
		{
			byte cl_37 = rsi->b0000;
			if (cl_37 != 0x02 && (cl_37 != 0x01 || dil_15 != 0x0A))
				goto l0000000000401FD7;
		}
		<anonymous> * rcx_47 = rsi->ptr0030;
		if (rcx_47 != null)
		{
			word64 rax_86;
			word64 rdx_87;
			word64 rcx_88;
			rcx_47();
			return (word32) rax_86;
		}
		if (eax_32 != edx_34)
		{
l0000000000401FD7:
			rax_119 = (uint64) dil_15;
			return (word32) rax_119;
		}
	}
	rax_119 = (uint64) fn00000000004020AB(rsi);
	return (word32) rax_119;
}

// 0000000000401FE7: Register word32 fn0000000000401FE7(Register (ptr64 Eq_653) rsi, Register (ptr64 byte) rdi)
// Called from:
//      fn0000000000401F47
word32 fn0000000000401FE7(struct Eq_653 * rsi, byte * rdi)
{
	uint64 r14_11 = 0x00;
	byte * r13_20 = rdi;
	while (true)
	{
		word32 r12d_158;
		word32 r14d_120 = (word32) r14_11;
		byte dl_31 = *r13_20;
		if (dl_31 == 0x00)
			break;
		rsi->ptr0018[(uint64) rsi->dw0014] = dl_31;
		uint64 rsi_101 = (uint64) rsi->dw0020;
		ui32 eax_60 = rsi->dw0014 + 0x01 & (word32) rsi_101 - 0x01;
		ui32 ecx_62 = rsi->dw0010;
		rsi->dw0014 = eax_60;
		++r13_20;
		word56 rsi_56_8_100 = SLICE(rsi_101, word56, 8);
		if (eax_60 != ecx_62)
		{
			byte sil_65 = rsi->b0000;
			rsi_101 = SEQ(rsi_56_8_100, sil_65);
			if (sil_65 == 0x02)
				goto l000000000040203E;
			rsi_101 = SEQ(rsi_56_8_100, sil_65 - 0x01);
			if (sil_65 == 0x01 && dl_31 == 0x0A)
				goto l000000000040203E;
			goto l0000000000402093;
		}
l000000000040203E:
		word32 eax_112;
		<anonymous> * rdx_75 = rsi->ptr0030;
		if (rdx_75 != null)
		{
			word64 rdx_108;
			word64 rax_109;
			word64 rcx_110;
			rdx_75();
			eax_112 = (word32) rax_109;
			word56 rdx_56_8_209 = SLICE(rdx_108, word56, 8);
			goto l000000000040205A;
		}
		if (eax_60 == ecx_62)
		{
			eax_112 = fn00000000004020AB(rsi);
l000000000040205A:
			r12d_158 = eax_112;
			if (eax_112 == ~0x00)
			{
				if ((int64) fn00000000004020DE(rsi) == g_qw4406B8)
					continue;
				if (fn00000000004020D4(rsi) != 0x00)
				{
					int32 eax_150 = g_dw440710;
					rsi->dw0008 = eax_150;
					g_dw443C70 = eax_150;
				}
				return r12d_158;
			}
		}
l0000000000402093:
		r14_11 = (uint64) (r14d_120 + 0x01);
	}
	r12d_158 = (word32) r14_11 + 0x01;
	return r12d_158;
}

// 00000000004020AB: Register word32 fn00000000004020AB(Register (ptr64 Eq_653) rdi)
// Called from:
//      fn0000000000401F82
//      fn0000000000401FE7
word32 fn00000000004020AB(struct Eq_653 * rdi)
{
	int32 eax_26 = rdi->dw0008;
	if (eax_26 <= 0x00)
		eax_26 = ~0x00;
	rdi->dw0008 = eax_26;
	return ~0x00;
}

// 00000000004020D4: Register word32 fn00000000004020D4(Register (ptr64 Eq_653) rdi)
// Called from:
//      fn0000000000401FE7
word32 fn00000000004020D4(struct Eq_653 * rdi)
{
	return (word32) (rdi->dw0008 == ~0x00);
}

// 00000000004020DE: Register word32 fn00000000004020DE(Register (ptr64 Eq_653) rdi)
// Called from:
//      fn0000000000401FE7
word32 fn00000000004020DE(struct Eq_653 * rdi)
{
	uint64 rax_14 = 0x00;
	if (rdi->dw0008 >= 0x00)
		rax_14 = (uint64) rdi->dw0008;
	return (word32) rax_14;
}

// 0000000000402296: void fn0000000000402296()
// Called from:
//      fn0000000000404540
void fn0000000000402296()
{
	g_ptr440678();
}

// 000000000040229C: void fn000000000040229C()
// Called from:
//      fn00000000004045D5
void fn000000000040229C()
{
	g_ptr440680();
}

struct Eq_1517 * g_ptr40229E = &g_t3E3DE; // 000000000040229E
// 00000000004022A2: void fn00000000004022A2()
// Called from:
//      fn000000000040466A
void fn00000000004022A2()
{
	g_ptr440688();
}

// 0000000000404491: Register ptr64 fn0000000000404491()
// Called from:
//      fn00000000004015CB
ptr64 fn0000000000404491()
{
	ptr64 fp;
	ptr64 rbp;
	if (g_qw442460 == 0x00)
	{
		up32 eax_10 = 0x00010000;
		if (g_dw443C68 >= 0x00010000)
			eax_10 = g_dw443C68;
		uint64 rax_14 = (uint64) eax_10;
		if ((rax_14 - 1 & rax_14) != 0x00)
		{
			fn0000000000401000(fp - 8);
			rbp = fp - 8;
		}
		g_qw442470 = rax_14;
		ui64 rax_28 = g_qw440000;
		g_qw442468 = 0x1000;
		g_qw442478 = 0x00040000;
		g_qw442480 = 0x00A00000;
		g_dw442488 = 0x05;
		g_dw442410 = 0x05;
		g_qw442460 = rax_28 & ~0x07 | 0x08;
	}
	return rbp;
}

// 0000000000404540: void fn0000000000404540(Register uint64 rdx, Register uint64 rsi, Register uint64 rdi)
// Called from:
//      fn00000000004014E0
void fn0000000000404540(uint64 rdx, uint64 rsi, uint64 rdi)
{
	struct Eq_1517 * rbx_25 = g_ptr4424A0;
	if (rbx_25 == null)
	{
		g_ptr4424A0 = &g_t4424A8;
		rbx_25 = &g_t4424A8;
	}
	if (rbx_25->dw0000 == ~0x00)
	{
		fn0000000000402296();
		g_ptr40229E = rbx_25;
		g_ptr4424A0 = &g_t402296;
		rbx_25 = &g_t402296;
	}
	ui32 edx_60 = rbx_25->dw0000;
	word32 eax_67 = __bsr<word32>(~edx_60);
	ui32 edx_68;
	__bts<word32>(edx_60, eax_67, out edx_68);
	rbx_25->dw0000 = edx_68;
	struct Eq_1551 * rbx_74 = rbx_25 + ((uint64) eax_67 *s 0x18) /64 32;
	rbx_74->qw0010 = rdi;
	rbx_74->qw0018 = rsi;
	rbx_74->qw0020 = rdx;
}

// 00000000004045D5: void fn00000000004045D5(Register uint64 rdi)
// Called from:
//      fn00000000004018AE
void fn00000000004045D5(uint64 rdi)
{
	while (true)
	{
		struct Eq_1517 * rdi_24 = g_ptr4424A0;
		if (rdi_24 == null)
			break;
l00000000004045F3:
		uint64 rax_32 = (uint64) rdi_24->dw0000;
		do
		{
			word32 eax_77 = (word32) rax_32;
			if (rax_32 == 0x00)
			{
				struct Eq_1517 * r13_44 = rdi_24->ptr0008;
				if (rdi != 0x00)
				{
					if (r13_44 == null)
						return;
					rdi_24 = r13_44;
					goto l00000000004045F3;
				}
				else
					fn000000000040229C();
			}
			word32 ecx_78 = __bsf<word32>(eax_77);
			uint64 rdx_90 = (uint64) ~(0x01 << (byte) ecx_78);
			Eq_1597 rcx_87 = (uint64) ecx_78;
			ui32 edx_104 = (word32) rdx_90;
			rax_32 &= rdx_90;
			if (rdi != 0x00 && ((rdi_24->a0020))[rcx_87].qw0000 != rdi)
				continue;
			rdi_24->dw0000 &= edx_104;
			struct Eq_1611 * rcx_108 = rdi_24 + (rcx_87 *s 0x18) /64 32;
			<anonymous> * rdx_109 = rcx_108->ptr0010;
		} while (rdx_109 == null);
		word64 rcx_136;
		word64 rsi_137;
		rdx_109();
	}
}

// 000000000040466A: Register byte fn000000000040466A(Register uint64 rcx, Register Eq_756 rdx, Register (ptr64 Eq_1660) rsi, Register (ptr64 Eq_1645) rdi)
// Called from:
//      fn00000000004014E0
byte fn000000000040466A(uint64 rcx, Eq_756 rdx, union Eq_1660 * rsi, union Eq_1645 * rdi)
{
	fn00000000004047B0(rdi->u0);
	Eq_1645 r15_11 = 0x00;
	if (fn00000000004047B0(rdi->u0) != 0x00)
		r15_11.u0 = rdi->u0;
	uint64 rsi_118;
	Eq_1660 rdi_68 = rsi->u0;
	if (rdi->u0 != 0x00)
		rsi_118 = (word64) rdi_68 + (rdi_68 >> 0x01);
	else
	{
		rsi_118 = 0x04;
		uint64 rax_80 = (uint64) (1F /u rdx);
		if (rax_80 >= 0x04)
			rsi_118 = rax_80;
	}
	uint64 rax_186;
	Eq_1683 r8_102;
	if (rdi_68 != 0x00)
	{
		r8_102 = rdx *s rdi_68;
		if (((rdx | rdi_68) & -0x00010000) != 0x00 && rdx != (uint64) ((uint128) r8_102 /u rdi_68))
			goto l000000000040479A;
	}
	else
		r8_102.u1 = 0x00;
	Eq_1693 r14_128;
	Eq_1694 rcx_122 = rsi_118 + 1 + rcx;
	if (rcx_122 != 0x00)
	{
		r14_128 = rdx *s rcx_122;
		if (((rdx | rcx_122) & -0x00010000) != 0x00 && rdx != (uint64) ((uint128) r14_128 /u rcx_122))
		{
l000000000040479A:
			fn0000000000401907();
			rax_186 = 0x00;
			return (byte) rax_186;
		}
	}
	else
		r14_128.u1 = 0x00;
	fn00000000004022A2();
	if (r15_11 == 0x00 && rdi->u0 != 0x00)
		fn0000000000404F70(r8_102);
	word32 esi_387;
	rsi->u0 = (int64) fn00000000004050B2(r14_128 - r8_102, 0x00, out esi_387);
	rdi->u0 = (int64) 0x004022A2;
	rax_186 = 0x00402201;
	return (byte) rax_186;
}

// 00000000004047B0: Register byte fn00000000004047B0(Register Eq_1645 rdi)
// Called from:
//      fn000000000040466A
byte fn00000000004047B0(Eq_1645 rdi)
{
	if (rdi <= 0x6FFFFFFFFFFF)
		return 0x00;
	int32 ebx_33 = (word32) (rdi >> 0x10);
	ui64 rax_37 = fn0000000000404C04(g_dw4427C0, g_a4427C8, ebx_33);
	uint64 rax_105 = 0x00;
	if (rax_37 != 0x00)
	{
		uint32 eax_62 = 0x01;
		if ((&g_dw4427C0)[rax_37 * 0x08] != ebx_33)
			eax_62 = (uint32) (int8) (g_a4427CC[rax_37 - 1] == ebx_33);
		rax_105 = (uint64) (eax_62 & 0x01);
	}
	return (byte) rax_105;
}

// 0000000000404C04: Register int64 fn0000000000404C04(Register word32 edx, Register (arr Eq_1916) rsi, Register int32 edi)
// Called from:
//      fn00000000004047B0
int64 fn0000000000404C04(word32 edx, Eq_1916 rsi[], int32 edi)
{
	uint64 rdx;
	uint64 rdx_31 = rdx;
	uint64 rax_33 = 0x00;
	while (true)
	{
		int32 eax_10 = (word32) rax_33;
		int32 edx_9 = (word32) rdx_31;
		if (edx_9 <= eax_10)
			break;
		uint64 rcx_22 = (uint64) (edx_9 + eax_10 >> 0x01);
		word32 ecx_23 = (word32) rcx_22;
		if (rsi[(int64) ecx_23].dw0000 <= edi)
			rax_33 = (uint64) ((word32) rcx_22 + 0x01);
		else
			rdx_31 = (uint64) ecx_23;
	}
	return (int64) eax_10;
}

// 0000000000404C6C: Register word32 fn0000000000404C6C(Register word32 esi, Register word32 edi)
// Called from:
//      fn0000000000401674
word32 fn0000000000404C6C(word32 esi, word32 edi)
{
	word64 rdi;
	word32 edi = (word32) rdi;
	uint64 rax_24 = 0x00;
	if (edi != 0x00)
		rax_24 = (uint64) (int8) ((&(g_ptr443AB0 + (int64) edi)->qw0000)[2] == esi);
	return (word32) rax_24;
}

// 0000000000404DB0: Register word32 fn0000000000404DB0()
// Called from:
//      fn0000000000401711
word32 fn0000000000404DB0()
{
	word64 rax_6;
	g_ptr440670();
	return (word32) rax_6;
}

// 0000000000404F70: void fn0000000000404F70(Register Eq_1683 rdx)
// Called from:
//      fn000000000040466A
void fn0000000000404F70(Eq_1683 rdx)
{
	Eq_1683 rcx_11 = 0x20;
	if (rdx < 0x20)
		rcx_11 = rdx;
	(*((char *) g_a440448 + rcx_11 * 0x08))();
}

// 00000000004050B2: Register word64 fn00000000004050B2(Register Eq_1726 rdx, Register word32 esi, Register out Eq_1728 esiOut)
// Called from:
//      fn000000000040466A
word64 fn00000000004050B2(Eq_1726 rdx, word32 esi, union Eq_1728 & esiOut)
{
	Eq_1726 rcx_12 = 0x20;
	if (rdx < 0x20)
		rcx_12 = rdx;
	word64 rcx_25;
	Eq_1728 esi_26;
	(*((char *) g_a440550 + rcx_12 * 0x08))();
	esiOut = esi_26;
	return rcx_25;
}

// 0000000000405211: void fn0000000000405211(Register byte dil)
// Called from:
//      fn0000000000401000
//      fn00000000004018AE
void fn0000000000405211(byte dil)
{
	g_dw443C74 |= 0x04;
	if ((g_b440668 & 0x04) == 0x00)
	{
		__syscall();
		__cli();
		__lidt<word48>(g_n405242);
		__halt();
	}
	else
	{
		while (true)
			g_ptr406038();
	}
}

word48 g_n405242 = ;
byte g_b405301 = 0x68; // 0000000000405301
byte g_a4058F0[] = // 00000000004058F0
	{
	};
byte g_b405989 = 0x9C; // 0000000000405989
byte g_b4059B6 = 0x9C; // 00000000004059B6
byte g_b4059E1 = 0x9C; // 00000000004059E1
byte g_b405A0D = 0x9C; // 0000000000405A0D
byte g_b405A52 = 0x7E; // 0000000000405A52
