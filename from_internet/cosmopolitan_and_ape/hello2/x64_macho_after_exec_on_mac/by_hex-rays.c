/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __fastcall sub_400675(unsigned __int8 a1, unsigned __int16 a2);
__int64 __fastcall sub_400748(int, int);
void __fastcall __noreturn sub_401000(__int64, __int64, __int64);
__int64 __fastcall sub_401158(unsigned __int64, int, __int64, __int64 *);
void sub_4012F0();
__int64 sub_4014CE();
void __fastcall sub_4015CB(__int64, __int64);
__int64 __fastcall sub_40161F(__int64, __int64, __int64);
__int64 __fastcall sub_401674(__int64);
__int64 __fastcall sub_401711(__int64, int *);
void __fastcall sub_40173E(int *);
__int64 __fastcall sub_40186F(_QWORD *, unsigned __int8 *, __int64, int);
char __fastcall sub_40189D(_BYTE *, char *);
void __fastcall __noreturn sub_4018AE(unsigned int, __int64, __int64);
__int64 sub_4018C7();
__int64 sub_4018D7();
__int64 sub_4018E7();
__int64 sub_4018F7();
__int64 sub_401907();
__int64 __fastcall sub_401B52(unsigned __int16 **);
unsigned __int64 __fastcall sub_401B7D(__int64, unsigned int);
__int64 __fastcall sub_401BAD(unsigned __int16 *, unsigned __int64, __int64, __int64);
__int64 __fastcall sub_401DBA(_QWORD *, __int64 *, __int64, __int64);
__int64 __fastcall sub_401E5C(__int64, __int64);
__int64 __fastcall sub_401E81(__int64, __int64, __int64);
__int64 __fastcall sub_401E9A(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_401EB0(__int64, __int64, __int64);
__int64 sub_401EC9();
__int64 __fastcall sub_401EDF(__int64, __int64, __int64, __int64);
__int64 __fastcall sub_401EF5(__int64, __int64, __int64);
__int64 __fastcall sub_401F47(char *);
__int64 __fastcall sub_401F82(int, __int64);
__int64 __fastcall sub_401FE7(char *, __int64);
__int64 __fastcall sub_4020AB(__int64);
_BOOL8 __fastcall sub_4020D4(__int64);
__int64 __fastcall sub_4020DE(__int64);
__int64 __fastcall sub_4020EC(_DWORD *);
void __fastcall sub_4021BE(__int64);
void sub_40228B();
__int64 __fastcall sub_402296(_QWORD, _QWORD); // weak
__int64 sub_40229C(void); // weak
__int64 __fastcall sub_4022A2(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_4022A8(_QWORD *, __int64, __int64);
__int64 __fastcall sub_4022EF(__int64);
_BOOL8 __fastcall sub_4025AC(_QWORD *, unsigned __int64);
__int64 __fastcall sub_4026E8(__int64, __int64, unsigned __int64);
unsigned __int64 __fastcall sub_402B64(unsigned __int64);
void __fastcall sub_403AE8(__int64);
void __fastcall sub_403FED(unsigned __int64, __int64);
__int64 *__fastcall sub_404049(__int64, __int64 *, unsigned __int64);
__int64 *__fastcall sub_4043D8(__int64 a1, unsigned __int64 a2);
void __fastcall sub_404491(__int64, __int64);
__int64 __fastcall sub_404518(__int64);
__int64 __fastcall sub_40452C(__int64, __int64);
__int64 __fastcall sub_404540(__int64, __int64, __int64);
__int64 __fastcall sub_4045D5(__int64, __int64, __int64);
char __fastcall sub_40466A(__int64 *, unsigned __int64 *, unsigned __int64, __int64);
_BOOL8 __fastcall sub_4047B0(__int64);
__int64 __fastcall sub_40481D(__int64);
__int64 sub_404ABB();
__int64 __fastcall sub_404AC1(__int64, __int64);
__int64 __fastcall sub_404C04(int, __int64, int);
__int64 sub_404C24();
__int64 __fastcall sub_404C31(char, int);
bool __fastcall sub_404C6C(int, int);
__int64 __fastcall sub_404C87(int, __int64, __int64);
__int64 sub_404DB0();
__int64 sub_404DC0();
__int64 sub_404DD0();
__int64 sub_404DE0();
__int64 __fastcall sub_404DF0(); // weak
__int64 __fastcall sub_404E4D(__int64, _DWORD *);
__int64 __fastcall sub_404E5C(__int64);
__int64 __fastcall sub_404E8F(__int64, _DWORD *);
void __fastcall sub_404F70(__int64, __int64, unsigned __int64);
void __fastcall sub_404F84(__m128i *_RDI, const __m128i *_RSI, unsigned __int64 _RDX);
void __fastcall sub_405092(_BYTE *, _BYTE *, __int64);
void __fastcall sub_4050B2(__int64, __int64, unsigned __int64);
void __fastcall sub_4050CC(void *_RDI, char a2, unsigned __int64 _RDX, double a4, double a5, double a6, __m128 _XMM3);
__int64 __fastcall sub_4051E0(__int64, __int64, unsigned int);
void __fastcall __noreturn sub_405211(__int64, __int64, __int64);
__int64 __fastcall sub_40524A(int, int);
__int64 sub_4052D6();

//-------------------------------------------------------------------------
// Data declarations

int dword_400000 = -17958193; // weak
_UNKNOWN loc_4020B3; // weak
char byte_405242[6] = { '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
__int64 qword_405320[2] = { 24LL, 0LL }; // weak
char byte_405347[2] = { '\x01', '\xC0' }; // weak
__int64 (__fastcall *qword_406018)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x56A0LL; // weak
__int64 (__fastcall *qword_406020)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x56AELL; // weak
__int64 (__fastcall *qword_406038)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x56E8LL; // weak
__int64 (__fastcall *qword_406040)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x56F6LL; // weak
__int64 (__fastcall *qword_406070)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x578ELL; // weak
__int64 (*qword_406078)(void) = (__int64 (*)(void))0x579CLL; // weak
__int64 qword_406080 = 22444LL; // weak
__int64 (__fastcall *qword_406090)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x57CCLL; // weak
__int64 (__fastcall *qword_4060A0)(_QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))0x57FELL; // weak
__int64 (__fastcall *qword_4060A8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))0x5810LL; // weak
__int64 qword_440000; // weak
char byte_44003D; // weak
int dword_440668; // weak
__int64 (*qword_440670)(void); // weak
int dword_4406A8; // weak
__int64 qword_4406B8; // weak
int dword_4406C0; // weak
int dword_4406F8; // weak
int dword_440700; // weak
int dword_440708; // weak
__int64 qword_440710; // weak
__int64 qword_440728; // weak
int dword_440730; // weak
__int64 qword_440798; // weak
__int64 qword_442038; // weak
__int64 qword_442040; // weak
__int64 qword_442050; // weak
int dword_4420A0; // weak
int dword_4420A4; // weak
__int64 qword_4420A8[]; // weak
__int64 qword_4420B0; // weak
__int64 qword_4420B8; // weak
__int64 qword_4420C0; // weak
__int64 qword_4420C8; // weak
__int64 qword_4420D0; // weak
__int64 qword_4420D8; // weak
__int64 qword_4420E0; // weak
_UNKNOWN unk_4420E8; // weak
_UNKNOWN unk_4422E8; // weak
__int64 qword_4422F8[32]; // weak
__int64 qword_4423F8; // weak
__int64 qword_442400; // weak
__int64 qword_442408; // weak
int dword_442410; // weak
__int64 qword_442418; // weak
__int64 qword_442420; // weak
__int64 qword_442428; // weak
int dword_442430; // weak
__int64 qword_442460; // weak
__int64 qword_442468; // weak
__int64 qword_442470; // weak
__int64 qword_442478; // weak
__int64 qword_442480; // weak
int dword_442488; // weak
__int64 qword_4424A0; // weak
_UNKNOWN unk_4424A8; // weak
_UNKNOWN unk_4427B8; // weak
__int64 qword_4427C0[]; // weak
int dword_4427C8[]; // weak
int dword_4427CC[595]; // weak
_BYTE byte_443118[8]; // weak
_BYTE byte_443120[8]; // weak
__int64 qword_443128[303]; // weak
_UNKNOWN unk_443AA0; // weak
__int64 qword_443AB0; // weak
int dword_443C68; // weak
int dword_443C70; // weak
int dword_443C74; // weak


//----- (0000000000400675) ----------------------------------------------------
void __fastcall sub_400675(unsigned __int8 a1, unsigned __int16 a2)
{
  unsigned __int8 v2; // al

  while ( 1 )
  {
    v2 = __inbyte(a2 + 5);
    if ( (v2 & 0x20) != 0 )
      break;
    _mm_pause();
  }
  __outbyte(a2, a1);
}

//----- (0000000000400748) ----------------------------------------------------
__int64 __fastcall sub_400748(int a1, int a2)
{
  qmemcpy((void *)(a1 & 0xFFFF8000), (const void *)(unsigned int)(a1 - a2), a1 - a2 - (a1 & 0xFFFF8000));
  return (unsigned int)(a1 - a2);
}

//----- (0000000000401000) ----------------------------------------------------
void __fastcall __noreturn sub_401000(__int64 a1, __int64 a2, __int64 a3)
{
  dword_443C74 |= 2u;
  if ( (dword_440668 & 4) == 0 )
  {
    a3 = 0LL;
    __asm
    {
      syscall; Low latency system call
      syscall; Low latency system call
    }
    a2 = 6LL;
    __asm { syscall; Low latency system call }
  }
  sub_405211(134LL, a2, a3);
}
// 440668: using guessed type int dword_440668;
// 443C74: using guessed type int dword_443C74;

//----- (0000000000401158) ----------------------------------------------------
__int64 __fastcall sub_401158(unsigned __int64 a1, int a2, __int64 a3, __int64 *a4)
{
  char i; // cl
  __int64 v6; // rax
  __int64 *v8; // rdx
  __int64 v9; // rax

  for ( i = 39; ; i -= 9 )
  {
    --a2;
    v6 = (a1 >> i) & 0x1FF;
    if ( a2 == -1 )
      break;
    v8 = (__int64 *)(a3 + 8 * v6);
    if ( !*v8 )
    {
      v9 = *a4 - 4096;
      *a4 = v9;
      *v8 = v9 | 3;
    }
    a3 = *v8 & 0x3FFFFFFFFF000LL;
  }
  return a3 + 8 * v6;
}

//----- (000000000040129E) ----------------------------------------------------
#error "40129E: function frame is wrong (funcsize=0)"

//----- (00000000004012F0) ----------------------------------------------------
void sub_4012F0()
{
  __int64 *i; // rdi
  _DWORD *v6; // rdi

  qword_440000 = __rdtsc();
  i = &qword_440000 + 1;
  _RAX = 0LL;
  while ( 1 )
  {
    __asm { cpuid }
    *(_DWORD *)i = _RAX;
    v6 = (_DWORD *)i + 1;
    *v6++ = _RBX;
    *v6++ = _RCX;
    *v6 = _RDX;
    for ( i = (__int64 *)(v6 + 1); ; i += 2 )
    {
      _RAX = 1LL;
      if ( *((_BYTE *)&qword_440000 + 8) )
        break;
    }
  }
}
// 4012F0: could not find valid save-restore pair for rbx
// 40132B: conditional instruction was optimized away because %0x10.4==1
// 406088: using guessed type __int64 (__fastcall *qword_406088)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 440000: using guessed type __int64 qword_440000;
// 440668: using guessed type int dword_440668;
// 442038: using guessed type __int64 qword_442038;

//----- (00000000004014CE) ----------------------------------------------------
__int64 sub_4014CE()
{
  sub_401F47("hello world");
  return 0LL;
}

//----- (00000000004015CB) ----------------------------------------------------
void __fastcall sub_4015CB(__int64 a1, __int64 a2)
{
  sub_404491(a1, a2);
}

//----- (000000000040161F) ----------------------------------------------------
__int64 __fastcall sub_40161F(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v3)(__int64, __int64, __int64, __int64); // rbp
  __int64 v4; // rdx
  __int64 v5; // rdx
  __int64 result; // rax

  v3 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))qword_406080;
  unk_443AA0 = 3LL;
  *((_QWORD *)&unk_443AA0 + 2) = (char *)&unk_443AA0 + 24;
  *((_QWORD *)&unk_443AA0 + 1) = 16LL;
  *((_DWORD *)&unk_443AA0 + 10) = 1;
  *((_DWORD *)&unk_443AA0 + 16) = 1;
  *((_DWORD *)&unk_443AA0 + 22) = 1;
  *((_QWORD *)&unk_443AA0 + 3) = v3(a1, a2, a3, -10LL);
  *((_QWORD *)&unk_443AA0 + 6) = v3(a1, a2, v4, -11LL);
  result = v3(a1, a2, v5, -12LL);
  *((_QWORD *)&unk_443AA0 + 9) = result;
  return result;
}
// 40165C: variable 'v4' is possibly undefined
// 401665: variable 'v5' is possibly undefined
// 406080: using guessed type __int64 qword_406080;

//----- (0000000000401674) ----------------------------------------------------
__int64 __fastcall sub_401674(__int64 a1)
{
  unsigned int v1; // er13
  int v2; // ebx
  __int64 v4; // rdx
  int v6[6]; // [rsp+10h] [rbp-100h] BYREF
  int v7; // [rsp+28h] [rbp-E8h]

  v1 = dword_440668 & 4;
  if ( (dword_440668 & 4) != 0 )
  {
    v1 = 0;
    if ( sub_404C6C(a1, 1) )
      return (unsigned int)sub_401EB0(*(_QWORD *)(qword_443AB0 + 24LL * (int)a1), 1LL, v4) == 2;
  }
  else
  {
    v2 = dword_443C70;
    if ( (unsigned int)sub_401711(a1, v6) != -1 )
      return (v7 & 0xF000) == 0x2000;
    dword_443C70 = v2;
  }
  return v1;
}
// 4016F0: variable 'v4' is possibly undefined
// 440668: using guessed type int dword_440668;
// 443AB0: using guessed type __int64 qword_443AB0;
// 443C70: using guessed type int dword_443C70;
// 401674: using guessed type int var_100[6];

//----- (0000000000401711) ----------------------------------------------------
__int64 __fastcall sub_401711(__int64 a1, int *a2)
{
  __int64 result; // rax
  unsigned int v3; // [rsp+Ch] [rbp-14h]

  result = sub_404DB0();
  if ( (_DWORD)result != -1 )
  {
    v3 = result;
    sub_40173E(a2);
    return v3;
  }
  return result;
}

//----- (000000000040173E) ----------------------------------------------------
void __fastcall sub_40173E(int *a1)
{
  __int64 v1; // r14
  int v2; // er13
  __int64 v3; // r10
  __int64 v4; // r15
  __int64 v5; // r12
  __int64 v6; // r11
  __int64 v7; // r8
  __int64 v8; // rbx
  __int64 v9; // r9
  __int64 v10; // rsi
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rax
  __int64 v14; // r11
  __int64 v15; // rbx
  __int64 v16; // r10
  __int64 v17; // r12
  int v18; // er14
  __int64 v19; // r13
  __int64 v20; // r15

  if ( a1 )
  {
    if ( (dword_440668 & 8) != 0 )
    {
      v1 = *((unsigned __int16 *)a1 + 3);
      v2 = *((unsigned __int16 *)a1 + 2);
      v3 = a1[28];
      v4 = *a1;
      v5 = *((_QWORD *)a1 + 2);
      v6 = *((_QWORD *)a1 + 12);
      v7 = *((_QWORD *)a1 + 5);
      *((_QWORD *)a1 + 5) = a1[6];
      v8 = *((_QWORD *)a1 + 13);
      v9 = *((_QWORD *)a1 + 4);
      v10 = *((_QWORD *)a1 + 6);
      v11 = *((_QWORD *)a1 + 7);
      v12 = *((_QWORD *)a1 + 8);
      v13 = *((_QWORD *)a1 + 9);
      *(_QWORD *)a1 = v4;
      *((_QWORD *)a1 + 2) = v1;
      a1[6] = v2;
      *(_QWORD *)(a1 + 7) = v5;
      *((_QWORD *)a1 + 6) = v6;
      *((_QWORD *)a1 + 7) = v3;
      *((_QWORD *)a1 + 8) = v8;
    }
    else
    {
      if ( (dword_440668 & 0x20) != 0 )
      {
        v14 = a1[32];
        v15 = *((_QWORD *)a1 + 14);
        v16 = *((_QWORD *)a1 + 15);
        v9 = *((_QWORD *)a1 + 6);
        v7 = *((_QWORD *)a1 + 7);
        v10 = *((_QWORD *)a1 + 8);
        v11 = *((_QWORD *)a1 + 9);
        v12 = *((_QWORD *)a1 + 10);
        v13 = *((_QWORD *)a1 + 11);
        a1[6] = *((unsigned __int16 *)a1 + 12);
      }
      else
      {
        if ( (dword_440668 & 0x10) == 0 )
          return;
        v17 = a1[7];
        v18 = *a1;
        v19 = *(_QWORD *)(a1 + 5);
        v14 = a1[24];
        v15 = *((_QWORD *)a1 + 10);
        v16 = *((_QWORD *)a1 + 11);
        v10 = *((_QWORD *)a1 + 6);
        *(_QWORD *)a1 = a1[1];
        v20 = (unsigned int)a1[4];
        v11 = *((_QWORD *)a1 + 7);
        v12 = *((_QWORD *)a1 + 8);
        v13 = *((_QWORD *)a1 + 9);
        v9 = *((_QWORD *)a1 + 4);
        v7 = *((_QWORD *)a1 + 5);
        a1[6] = v18;
        *((_QWORD *)a1 + 2) = v20;
        *(_QWORD *)(a1 + 7) = v19;
        *((_QWORD *)a1 + 5) = v17;
      }
      *((_QWORD *)a1 + 6) = v15;
      *((_QWORD *)a1 + 7) = v14;
      *((_QWORD *)a1 + 8) = v16;
    }
    *((_QWORD *)a1 + 9) = v9;
    *((_QWORD *)a1 + 10) = v7;
    *((_QWORD *)a1 + 11) = v10;
    *((_QWORD *)a1 + 12) = v11;
    *((_QWORD *)a1 + 13) = v12;
    *((_QWORD *)a1 + 14) = v13;
  }
}
// 440668: using guessed type int dword_440668;

//----- (000000000040186F) ----------------------------------------------------
__int64 __fastcall sub_40186F(_QWORD *a1, unsigned __int8 *a2, __int64 a3, int a4)
{
  char v4; // zf
  __int64 v5; // rax

  do
  {
    v5 = *a2++;
    *a1++ = a3 + v5;
    --a4;
  }
  while ( a4 );
  *a1 = a3 + a2[(unsigned __int8)((2 * !v4) | ((byte_44003D & 2) != 0))];
  return *(_QWORD *)a2;
}
// 40186F: variable 'v4' is possibly undefined
// 44003D: using guessed type char byte_44003D;

//----- (000000000040189D) ----------------------------------------------------
char __fastcall sub_40189D(_BYTE *a1, char *a2)
{
  __int64 v2; // rcx
  char v3; // al
  char *v4; // rsi
  char result; // al

  v2 = 0LL;
  while ( 1 )
  {
    v3 = *a2;
    v4 = a2 + 1;
    LOBYTE(v2) = v3;
    result = *v4;
    a2 = v4 + 1;
    if ( !v2 )
      break;
    do
    {
      *a1++ = result;
      v2 = (unsigned int)(v2 - 1);
    }
    while ( (_DWORD)v2 );
  }
  return result;
}

//----- (00000000004018AE) ----------------------------------------------------
void __fastcall __noreturn sub_4018AE(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx

  sub_4045D5(0LL, a2, a3);
  sub_405211(a1, a2, v3);
}
// 4018C2: variable 'v3' is possibly undefined

//----- (00000000004018C7) ----------------------------------------------------
__int64 sub_4018C7()
{
  dword_443C70 = dword_4406A8;
  return -1LL;
}
// 4406A8: using guessed type int dword_4406A8;
// 443C70: using guessed type int dword_443C70;

//----- (00000000004018D7) ----------------------------------------------------
__int64 sub_4018D7()
{
  dword_443C70 = dword_4406C0;
  return -1LL;
}
// 4406C0: using guessed type int dword_4406C0;
// 443C70: using guessed type int dword_443C70;

//----- (00000000004018E7) ----------------------------------------------------
__int64 sub_4018E7()
{
  dword_443C70 = dword_4406F8;
  return -1LL;
}
// 4406F8: using guessed type int dword_4406F8;
// 443C70: using guessed type int dword_443C70;

//----- (00000000004018F7) ----------------------------------------------------
__int64 sub_4018F7()
{
  dword_443C70 = dword_440700;
  return -1LL;
}
// 440700: using guessed type int dword_440700;
// 443C70: using guessed type int dword_443C70;

//----- (0000000000401907) ----------------------------------------------------
__int64 sub_401907()
{
  dword_443C70 = dword_440708;
  return -1LL;
}
// 440708: using guessed type int dword_440708;
// 443C70: using guessed type int dword_443C70;

//----- (0000000000401B52) ----------------------------------------------------
__int64 __fastcall sub_401B52(unsigned __int16 **a1)
{
  unsigned __int16 **v1; // rdx
  unsigned __int16 *v2; // rdi
  int v3; // eax
  unsigned int v4; // eax
  __int64 result; // rax

  v1 = a1;
  v2 = *a1;
  v3 = *v2;
  if ( (unsigned __int16)v3 > 0xD7FFu )
  {
    v4 = sub_404E4D((__int64)v2, (_DWORD *)v1 + 6);
  }
  else
  {
    *((_DWORD *)v1 + 6) = v3;
    v4 = 1;
  }
  result = 2LL * v4;
  *v1 = (unsigned __int16 *)((char *)*v1 + result);
  return result;
}
// 401B79: variable 'v1' is possibly undefined

//----- (0000000000401B7D) ----------------------------------------------------
unsigned __int64 __fastcall sub_401B7D(__int64 a1, unsigned int a2)
{
  __int64 v2; // rdx
  unsigned __int64 v3; // r8
  unsigned __int64 result; // rax
  _BYTE *v5; // rcx

  v2 = a1;
  v3 = *(_QWORD *)(a1 + 16);
  result = (int)a2;
  if ( a2 > 0x7F )
    result = sub_404E5C(a2);
  do
  {
    v5 = *(_BYTE **)(v2 + 8);
    if ( v3 <= (unsigned __int64)v5 )
      break;
    *(_QWORD *)(v2 + 8) = v5 + 1;
    *v5 = result;
    result >>= 8;
  }
  while ( result );
  return result;
}
// 401B93: variable 'v2' is possibly undefined
// 401B9A: variable 'v3' is possibly undefined

//----- (0000000000401BAD) ----------------------------------------------------
__int64 __fastcall sub_401BAD(unsigned __int16 *a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // r10
  __int64 v7; // r10
  __int64 v8; // r11
  unsigned __int64 v9; // r11
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // r10
  unsigned __int64 v12; // rax
  bool v13; // r14
  unsigned __int64 v14; // r12
  __int64 v15; // r9
  __int64 v16; // r9
  unsigned __int64 v17; // rax
  __int64 v18; // r9
  bool v19; // cf
  unsigned __int64 v20; // r14
  unsigned __int64 v21; // r9
  unsigned __int64 v22; // r12
  unsigned __int64 v24; // [rsp+0h] [rbp-60h]
  unsigned __int16 *v26; // [rsp+10h] [rbp-50h] BYREF
  unsigned __int64 v27; // [rsp+18h] [rbp-48h]
  unsigned __int64 v28; // [rsp+20h] [rbp-40h]
  unsigned int v29; // [rsp+28h] [rbp-38h]

  v4 = 0x100002600LL;
  v5 = 0LL;
  v26 = a1;
  v27 = a2;
  v28 = a2 + a3;
  sub_401B52(&v26);
LABEL_2:
  if ( v29 )
  {
    while ( 1 )
    {
      if ( !v29 )
        goto LABEL_7;
      if ( v29 > 0x20 || !_bittest64(&v4, v29) )
        break;
      sub_401B52(&v26);
    }
    if ( ++v5 < v6 )
    {
      v12 = v27;
      if ( v27 >= v28 )
        v12 = 0LL;
      *(_QWORD *)(a4 + 8 * v5 - 8) = v12;
    }
    v13 = 0;
    while ( 1 )
    {
      if ( !v29 )
      {
LABEL_45:
        sub_401B7D((__int64)&v26, 0);
        goto LABEL_2;
      }
      if ( v13 || v29 > 0x20 )
      {
        if ( v29 != 34 && v29 != 92 )
          goto LABEL_44;
        v14 = 0LL;
        while ( v29 == 92 )
        {
          ++v14;
          sub_401B52(&v26);
        }
        v15 = 0LL;
        while ( v29 == 34 )
        {
          sub_401B52(&v26);
          v15 = v16 + 1;
        }
        v17 = v14;
        if ( v15 )
        {
          while ( v17 > 1 )
          {
            v24 = v17;
            sub_401B7D((__int64)&v26, 0x5Cu);
            v17 = v24 - 2;
          }
          if ( (v14 & 1) == 0 || (sub_401B7D((__int64)&v26, 0x22u), (v15 = v18 - 1) != 0) )
          {
            v19 = !v13;
            v20 = 3LL;
            v21 = v15 - v19;
            v22 = v21 + 1;
            while ( v22 >= v20 )
            {
              v20 += 3LL;
              sub_401B7D((__int64)&v26, 0x22u);
            }
            v13 = v21 % 3 == 0;
          }
        }
        else
        {
          while ( --v14 != -1LL )
            sub_401B7D((__int64)&v26, 0x5Cu);
        }
      }
      else
      {
        if ( _bittest64(&v4, v29) )
          goto LABEL_45;
LABEL_44:
        sub_401B7D((__int64)&v26, v29);
        sub_401B52(&v26);
      }
    }
  }
LABEL_7:
  sub_401B7D((__int64)&v26, 0);
  if ( v8 )
  {
    v9 = v8 - 1;
    v10 = v27 - a2;
    if ( v27 - a2 > v9 )
      v10 = v9;
    *(_BYTE *)(a2 + v10) = 0;
  }
  if ( v7 )
  {
    v11 = v7 - 1;
    if ( v11 > v5 )
      v11 = v5;
    *(_QWORD *)(a4 + 8 * v11) = 0LL;
  }
  return (unsigned int)v5;
}
// 401C21: variable 'v8' is possibly undefined
// 401C3D: variable 'v7' is possibly undefined
// 401C64: variable 'v6' is possibly undefined
// 401CD9: variable 'v16' is possibly undefined
// 401D35: variable 'v18' is possibly undefined
// 401D48: variable 'v15' is possibly undefined
// 401D73: variable 'v21' is possibly undefined

//----- (0000000000401DBA) ----------------------------------------------------
__int64 __fastcall sub_401DBA(_QWORD *a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 v8; // r8
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 i; // rax
  unsigned int v13; // [rsp+Ch] [rbp-44h] BYREF
  char v14[64]; // [rsp+10h] [rbp-40h] BYREF

  while ( a3 && !a2[1] )
  {
    a2 += 2;
    --a3;
  }
  sub_401E5C(a4, (__int64)v14);
  if ( a3 )
  {
    v8 = *((unsigned int *)a2 + 2);
    v9 = *a2;
  }
  else
  {
    v8 = 0LL;
    v9 = 0LL;
  }
  if ( !(unsigned int)qword_4060A8(a4, v14, v9, *a1, v8, &v13) )
    return sub_4052D6();
  if ( !v13 )
  {
    for ( i = 0LL; a3 != i; ++i )
      ;
  }
  qword_406040(a4, v14, v10, *a1);
  return v13;
}
// 401E3D: variable 'v10' is possibly undefined
// 406040: using guessed type __int64 (__fastcall *qword_406040)(_QWORD, _QWORD, _QWORD, _QWORD);
// 4060A8: using guessed type __int64 (__fastcall *qword_4060A8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000401E5C) ----------------------------------------------------
__int64 __fastcall sub_401E5C(__int64 a1, __int64 a2)
{
  __int64 v3; // r8
  __int64 v4; // rcx
  _DWORD *v5; // rdi

  v3 = a2;
  if ( a1 == -1 )
    return 0LL;
  v4 = 8LL;
  v5 = (_DWORD *)a2;
  while ( v4 )
  {
    *v5++ = 0;
    --v4;
  }
  *(_QWORD *)(a2 + 16) = a1;
  return v3;
}

//----- (0000000000401E81) ----------------------------------------------------
__int64 __fastcall sub_401E81(__int64 a1, __int64 a2, __int64 a3)
{
  return qword_406018(a1, a2, a3, a1);
}
// 406018: using guessed type __int64 (__fastcall *qword_406018)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000401E9A) ----------------------------------------------------
__int64 __fastcall sub_401E9A(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_406020(a1, a2, a2, a1, a3, a4);
}
// 406020: using guessed type __int64 (__fastcall *qword_406020)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000401EB0) ----------------------------------------------------
__int64 __fastcall sub_401EB0(__int64 a1, __int64 a2, __int64 a3)
{
  return qword_406070(a1, a2, a3, a1);
}
// 406070: using guessed type __int64 (__fastcall *qword_406070)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000401EC9) ----------------------------------------------------
__int64 sub_401EC9()
{
  return qword_406078();
}
// 406078: using guessed type __int64 (*qword_406078)(void);

//----- (0000000000401EDF) ----------------------------------------------------
__int64 __fastcall sub_401EDF(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return qword_406090(a1, a2, a2, a1, a3, a4);
}
// 406090: using guessed type __int64 (__fastcall *qword_406090)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000401EF5) ----------------------------------------------------
__int64 __fastcall sub_401EF5(__int64 a1, __int64 a2, __int64 a3)
{
  return qword_4060A0(a1, a2, a3, a1);
}
// 4060A0: using guessed type __int64 (__fastcall *qword_4060A0)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000401F47) ----------------------------------------------------
__int64 __fastcall sub_401F47(char *a1)
{
  __int64 v1; // r12
  int v2; // eax
  int v4; // ebx

  v1 = qword_442038;
  v2 = sub_401FE7(a1, qword_442038);
  if ( v2 == -1 )
    return 0xFFFFFFFFLL;
  v4 = v2;
  if ( (unsigned int)sub_401F82(10, v1) == -1 )
    return 0xFFFFFFFFLL;
  else
    return (unsigned int)(v4 + 1);
}
// 442038: using guessed type __int64 qword_442038;

//----- (0000000000401F82) ----------------------------------------------------
__int64 __fastcall sub_401F82(int a1, __int64 a2)
{
  int v2; // eax
  int v3; // edx
  __int64 (__fastcall *v4)(__int64); // rcx

  if ( a1 == -1 )
    return sub_4020AB(a2);
  *(_BYTE *)(*(_QWORD *)(a2 + 24) + *(unsigned int *)(a2 + 20)) = a1;
  v2 = (*(_DWORD *)(a2 + 32) - 1) & (*(_DWORD *)(a2 + 20) + 1);
  v3 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 20) = v2;
  if ( v2 != v3 && *(_BYTE *)a2 != 2 && (*(_BYTE *)a2 != 1 || (_BYTE)a1 != 10) )
    return (unsigned __int8)a1;
  v4 = *(__int64 (__fastcall **)(__int64))(a2 + 48);
  if ( v4 )
    return v4(a2);
  if ( v2 == v3 )
    return sub_4020AB(a2);
  else
    return (unsigned __int8)a1;
}

//----- (0000000000401FE7) ----------------------------------------------------
__int64 __fastcall sub_401FE7(char *a1, __int64 a2)
{
  int v2; // er14
  char v4; // dl
  int v5; // eax
  int v6; // ecx
  __int64 (__fastcall *v7)(__int64); // rdx
  unsigned int v8; // eax
  unsigned int v9; // er12
  int v10; // eax

  v2 = 0;
  do
  {
    while ( 1 )
    {
      v4 = *a1;
      if ( !*a1 )
        return (unsigned int)(v2 + 1);
      ++a1;
      *(_BYTE *)(*(_QWORD *)(a2 + 24) + *(unsigned int *)(a2 + 20)) = v4;
      v5 = (*(_DWORD *)(a2 + 32) - 1) & (*(_DWORD *)(a2 + 20) + 1);
      v6 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 20) = v5;
      if ( v5 == v6 || *(_BYTE *)a2 == 2 || *(_BYTE *)a2 == 1 && v4 == 10 )
      {
        v7 = *(__int64 (__fastcall **)(__int64))(a2 + 48);
        if ( v7 )
        {
          v8 = v7(a2);
        }
        else
        {
          if ( v5 != v6 )
            goto LABEL_15;
          v8 = sub_4020AB(a2);
        }
        v9 = v8;
        if ( v8 == -1 )
          break;
      }
LABEL_15:
      ++v2;
    }
  }
  while ( (int)sub_4020DE(a2) == qword_4406B8 );
  if ( sub_4020D4(a2) )
  {
    v10 = qword_440710;
    *(_DWORD *)(a2 + 8) = qword_440710;
    dword_443C70 = v10;
  }
  return v9;
}
// 4406B8: using guessed type __int64 qword_4406B8;
// 440710: using guessed type __int64 qword_440710;
// 443C70: using guessed type int dword_443C70;

//----- (00000000004020AB) ----------------------------------------------------
__int64 __fastcall sub_4020AB(__int64 a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 <= 0 )
    v1 = -1;
  *(_DWORD *)(a1 + 8) = v1;
  return -1LL;
}
// 443C70: using guessed type int dword_443C70;

//----- (00000000004020D4) ----------------------------------------------------
_BOOL8 __fastcall sub_4020D4(__int64 a1)
{
  return *(_DWORD *)(a1 + 8) == -1;
}

//----- (00000000004020DE) ----------------------------------------------------
__int64 __fastcall sub_4020DE(__int64 a1)
{
  __int64 result; // rax

  result = 0LL;
  if ( *(int *)(a1 + 8) >= 0 )
    return *(unsigned int *)(a1 + 8);
  return result;
}

//----- (00000000004020EC) ----------------------------------------------------
__int64 __fastcall sub_4020EC(_DWORD *a1)
{
  unsigned int v1; // er12
  __int64 i; // r13
  _DWORD *v3; // rdi
  int v4; // eax
  int v5; // eax

  if ( a1 )
  {
    v1 = 0;
    if ( a1[3] != -1 && (a1[1] & (unsigned int)qword_440798) != 0 )
    {
      v1 = a1[2];
      if ( v1 )
      {
        if ( v1 == -1 )
          return 0;
        else
          return (unsigned int)((__int64 (__fastcall *)(_DWORD *, _QWORD))loc_4020B3)(a1, v1);
      }
      else
      {
        while ( a1[4] != a1[5] )
        {
          sub_4021BE((__int64)a1);
          if ( v5 == -1 )
            return (unsigned int)-1;
          v1 += v5;
        }
      }
    }
  }
  else
  {
    v1 = 0;
    for ( i = qword_442040 - 1; i != -1; --i )
    {
      v3 = *(_DWORD **)(qword_442050 + 8 * i);
      if ( v3 )
      {
        v4 = sub_4020EC(v3);
        if ( v4 == -1 )
          return (unsigned int)-1;
        v1 += v4;
      }
    }
  }
  return v1;
}
// 40216B: variable 'v5' is possibly undefined
// 440798: using guessed type __int64 qword_440798;
// 442040: using guessed type __int64 qword_442040;
// 442050: using guessed type __int64 qword_442050;

//----- (00000000004021BE) ----------------------------------------------------
void __fastcall sub_4021BE(__int64 a1)
{
  __int64 v1; // rsi
  unsigned int v2; // ebx
  __int64 v3; // rax

  v1 = *(unsigned int *)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 20);
  if ( (unsigned int)v1 >= v2 )
    v2 = *(_DWORD *)(a1 + 32);
  v3 = sub_404C87(*(_DWORD *)(a1 + 12), *(_QWORD *)(a1 + 24) + v1, v2 - (unsigned int)v1);
  if ( v3 == -1 )
    sub_40228B();
  else
    *(_DWORD *)(a1 + 16) = (*(_DWORD *)(a1 + 32) - 1) & (*(_DWORD *)(a1 + 16) + v3);
}

//----- (000000000040228B) ----------------------------------------------------
void sub_40228B()
{
  JUMPOUT(0x4020B3LL);
}
// 402291: control flows out of bounds to 4020B3
// 443C70: using guessed type int dword_443C70;

//----- (00000000004022A8) ----------------------------------------------------
__int64 __fastcall sub_4022A8(_QWORD *a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 result; // rax

  v3 = a2 & 0xF;
  if ( (a2 & 0xF) != 0 )
    v3 = -((_DWORD)a2 + 16) & 0xF;
  a1[5] = a2 + v3;
  a1[2] = a3 - v3;
  *(_QWORD *)(a2 + v3 + 8) = (a3 - v3) | 1;
  result = qword_442480;
  *(_QWORD *)(a2 + a3 + 8) = 80LL;
  a1[6] = result;
  return result;
}
// 442480: using guessed type __int64 qword_442480;

//----- (00000000004022EF) ----------------------------------------------------
__int64 __fastcall sub_4022EF(__int64 a1)
{
  __int64 v1; // r14
  __int64 v3; // rax
  int v4; // er13
  __int64 v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rbx
  unsigned __int64 v8; // r15
  __int64 v9; // r8
  _QWORD *v10; // rax
  __int64 v11; // rsi
  __int64 v12; // rdx
  _QWORD *v13; // rcx
  _QWORD *v14; // rdx
  _QWORD *v15; // r9
  __int64 v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rdx
  __int64 v19; // rdx
  unsigned __int64 v20; // rdx
  unsigned int v21; // eax
  int v22; // edx
  __int64 v23; // rdx
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v29; // [rsp+8h] [rbp-38h]

  v1 = 0LL;
  v3 = *(_QWORD *)(a1 + 904);
  if ( v3 )
  {
    if ( (*(_DWORD *)(v3 + 24) & 1) != 0 )
    {
      v4 = *(_DWORD *)(v3 + 24) & 8;
      if ( !v4 )
      {
        v5 = *(_QWORD *)v3;
        v6 = *(_QWORD *)v3 & 0xFLL;
        if ( (*(_QWORD *)v3 & 0xF) != 0 )
          v6 = -(*(_DWORD *)v3 + 16) & 0xF;
        v7 = v5 + v6;
        v1 = 0LL;
        if ( (*(_QWORD *)(v5 + v6 + 8) & 3LL) == 1 )
        {
          v1 = *(_QWORD *)(v3 + 8);
          v8 = *(_QWORD *)(v5 + v6 + 8) & 0xFFFFFFFFFFFFFFF8LL;
          if ( v7 + v8 < v5 + v1 - 80 )
            goto LABEL_48;
          v9 = *(_QWORD *)(v3 + 16);
          if ( *(_QWORD *)(a1 + 32) == v7 )
          {
            *(_QWORD *)(a1 + 32) = 0LL;
            *(_QWORD *)(a1 + 8) = 0LL;
            goto LABEL_32;
          }
          v10 = *(_QWORD **)(v7 + 24);
          v11 = *(_QWORD *)(v7 + 48);
          if ( v10 != (_QWORD *)v7 )
          {
            v12 = *(_QWORD *)(v7 + 16);
            *(_QWORD *)(v12 + 24) = v10;
            v10[2] = v12;
            goto LABEL_19;
          }
          v10 = (_QWORD *)v10[5];
          v13 = (_QWORD *)(v7 + 40);
          if ( !v10 )
          {
            v10 = *(_QWORD **)(v7 + 32);
            if ( !v10 )
              goto LABEL_19;
            v13 = (_QWORD *)(v7 + 32);
          }
          v14 = v10;
          do
          {
            do
            {
              v15 = v13;
              v10 = v14;
              v13 = v14 + 5;
              v14 = (_QWORD *)v14[5];
            }
            while ( v14 );
            v14 = (_QWORD *)v10[4];
            v13 = v10 + 4;
          }
          while ( v14 );
          *v15 = 0LL;
LABEL_19:
          if ( v11 )
          {
            v16 = *(unsigned int *)(v7 + 56);
            v17 = a1 + 8 * v16;
            if ( *(_QWORD *)(v17 + 600) == v7 )
            {
              *(_QWORD *)(v17 + 600) = v10;
              if ( !v10 )
              {
                *(_DWORD *)(a1 + 4) &= __ROL4__(-2, v16);
                goto LABEL_32;
              }
            }
            else
            {
              if ( *(_QWORD *)(v11 + 32) == v7 )
                *(_QWORD *)(v11 + 32) = v10;
              else
                *(_QWORD *)(v11 + 40) = v10;
              if ( !v10 )
                goto LABEL_32;
            }
            v18 = *(_QWORD *)(v7 + 32);
            v10[6] = v11;
            if ( v18 )
            {
              v10[4] = v18;
              *(_QWORD *)(v18 + 48) = v10;
            }
            v19 = *(_QWORD *)(v7 + 40);
            if ( v19 )
            {
              v10[5] = v19;
              *(_QWORD *)(v19 + 48) = v10;
            }
          }
LABEL_32:
          v29 = v9;
          if ( !(unsigned int)sub_40452C(v5, v1) )
          {
            *(_QWORD *)(a1 + 856) -= v1;
            *(_QWORD *)(a1 + 904) = v29;
            goto LABEL_49;
          }
          v20 = v8 >> 8;
          v21 = v8 >> 8;
          if ( v21 )
          {
            v21 = 31;
            if ( (unsigned int)v20 <= 0xFFFF )
            {
              _BitScanReverse((unsigned int *)&v20, v20);
              v21 = ((v8 >> (38 - ((unsigned __int8)v20 ^ 0x1Fu))) & 1) + 2 * (31 - (v20 ^ 0x1F));
            }
          }
          v22 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)(v7 + 56) = v21;
          *(_QWORD *)(v7 + 40) = 0LL;
          *(_QWORD *)(v7 + 32) = 0LL;
          if ( ((1 << v21) & v22) != 0 )
          {
            v23 = *(_QWORD *)(a1 + 8LL * v21 + 600);
            if ( v21 != 31 )
              LOBYTE(v4) = 57 - (v21 >> 1);
            v24 = v8 << v4;
            while ( (*(_QWORD *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8LL) != v8 )
            {
              v25 = v24;
              v24 *= 2LL;
              v26 = (v25 >> 63) + 4;
              if ( !*(_QWORD *)(v23 + 8 * v26) )
              {
                *(_QWORD *)(v23 + 8 * v26) = v7;
                *(_QWORD *)(v7 + 48) = v23;
                goto LABEL_46;
              }
              v23 = *(_QWORD *)(v23 + 8 * v26);
            }
            v27 = *(_QWORD *)(v23 + 16);
            *(_QWORD *)(v27 + 24) = v7;
            *(_QWORD *)(v23 + 16) = v7;
            *(_QWORD *)(v7 + 16) = v27;
            *(_QWORD *)(v7 + 24) = v23;
            *(_QWORD *)(v7 + 48) = 0LL;
          }
          else
          {
            *(_DWORD *)(a1 + 4) = (1 << v21) | v22;
            *(_QWORD *)(a1 + 8LL * v21 + 600) = v7;
            *(_QWORD *)(v7 + 48) = a1 + 8LL * v21 + 600;
LABEL_46:
            *(_QWORD *)(v7 + 24) = v7;
            *(_QWORD *)(v7 + 16) = v7;
          }
LABEL_48:
          v1 = 0LL;
        }
      }
    }
  }
LABEL_49:
  *(_QWORD *)(a1 + 56) = 128LL;
  return v1;
}

//----- (00000000004025AC) ----------------------------------------------------
_BOOL8 __fastcall sub_4025AC(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // rax
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rbx
  _QWORD *v8; // rcx
  unsigned __int64 *v9; // r13
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // r9
  int v12; // eax
  unsigned __int64 v13; // r14
  __int64 v14; // rdx

  if ( a2 > 0xFFFFFFFFFFFFFF7FLL || (v3 = a1[5]) == 0 )
  {
LABEL_2:
    v2 = 0LL;
    return v2 != 0;
  }
  v5 = a1[2];
  v6 = a2 + 80;
  if ( v5 > v6 )
  {
    v8 = a1 + 111;
    v9 = a1 + 111;
    while ( 1 )
    {
      v10 = *v9;
      if ( v3 >= *v9 )
      {
        v11 = v9[1];
        if ( v3 < v10 + v11 )
          break;
      }
      v9 = (unsigned __int64 *)v9[2];
      if ( !v9 )
        BUG();
    }
    v12 = *((_DWORD *)v9 + 6);
    if ( (v12 & 8) == 0 && (v12 & 1) != 0 )
    {
      v7 = qword_442470 * ((v5 + qword_442470 - 1 - v6) / qword_442470 - 1);
      if ( v7 <= v11 )
      {
        while ( v10 > (unsigned __int64)v8 || v10 + v11 <= (unsigned __int64)v8 )
        {
          v8 = (_QWORD *)v8[2];
          if ( !v8 )
          {
            v13 = v11 - v7;
            if ( sub_404ABB() == -1 && (unsigned int)sub_40452C(v13 + *v9, v7) )
              break;
            if ( v7 )
            {
              v9[1] -= v7;
              v14 = a1[2];
              a1[107] -= v7;
              sub_4022A8(a1, a1[5], v14 - v7);
            }
            goto LABEL_21;
          }
        }
      }
    }
  }
  v7 = 0LL;
LABEL_21:
  v2 = sub_4022EF((__int64)a1) + v7;
  if ( !v2 )
  {
    if ( a1[2] > a1[6] )
    {
      a1[6] = -1LL;
      return v2 != 0;
    }
    goto LABEL_2;
  }
  return v2 != 0;
}
// 442470: using guessed type __int64 qword_442470;

//----- (00000000004026E8) ----------------------------------------------------
__int64 __fastcall sub_4026E8(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v4; // rdi
  __int64 result; // rax
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // r8
  __int64 v8; // r12
  unsigned __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r8
  __int64 v12; // rcx
  _QWORD *v13; // r9
  __int64 v14; // rcx
  _QWORD *v15; // r10
  __int64 v16; // rcx
  __int64 v17; // r9
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r10
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // r8
  _QWORD *v25; // rax
  _QWORD *v26; // rsi
  __int64 v27; // r8
  __int64 v28; // rcx
  _QWORD *v29; // r9
  _QWORD *v30; // rcx
  _QWORD *v31; // r11
  __int64 v32; // rcx
  __int64 v33; // r9
  __int64 v34; // rcx
  __int64 v35; // rcx
  unsigned __int64 v36; // rcx
  __int64 v37; // rdx
  unsigned __int64 v38; // rsi
  unsigned int v39; // eax
  int v40; // esi
  int v41; // ecx
  __int64 v42; // r8
  char v43; // cl
  __int64 v44; // rsi
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // rax

  v4 = a2;
  result = *(_QWORD *)(a2 + 8);
  v6 = a3 + a2;
  if ( (result & 1) != 0 )
    goto LABEL_34;
  v7 = *(_QWORD *)v4;
  v4 -= *(_QWORD *)v4;
  if ( (result & 3) == 0 )
  {
    v8 = v7 + a3 + 32;
    result = sub_40452C(v4, v8);
    if ( !(_DWORD)result )
      *(_QWORD *)(a1 + 856) -= v8;
    return result;
  }
  a3 += v7;
  if ( *(_QWORD *)(a1 + 32) == v4 )
  {
    result = *(_QWORD *)(v6 + 8);
    if ( (result & 3) == 3 )
    {
      *(_QWORD *)(a1 + 8) = a3;
      *(_QWORD *)(v6 + 8) = result & 0xFFFFFFFFFFFFFFFELL;
      result = a3 | 1;
      *(_QWORD *)(v4 + 8) = a3 | 1;
      *(_QWORD *)v6 = a3;
      return result;
    }
    goto LABEL_34;
  }
  result = *(_QWORD *)(v4 + 24);
  v9 = v7 >> 3;
  if ( v7 <= 0xFF )
  {
    v10 = *(_QWORD *)(v4 + 16);
    if ( v10 == result )
    {
      result = (unsigned int)__ROL4__(-2, v9);
      *(_DWORD *)a1 &= result;
    }
    else
    {
      *(_QWORD *)(v10 + 24) = result;
      *(_QWORD *)(result + 16) = v10;
    }
    goto LABEL_34;
  }
  v11 = *(_QWORD *)(v4 + 48);
  if ( v4 == result )
  {
    result = *(_QWORD *)(v4 + 40);
    v13 = (_QWORD *)(v4 + 40);
    if ( !result )
    {
      result = *(_QWORD *)(v4 + 32);
      if ( !result )
        goto LABEL_19;
      v13 = (_QWORD *)(v4 + 32);
    }
    v14 = result;
    do
    {
      do
      {
        v15 = v13;
        result = v14;
        v13 = (_QWORD *)(v14 + 40);
        v14 = *(_QWORD *)(v14 + 40);
      }
      while ( v14 );
      v14 = *(_QWORD *)(result + 32);
      v13 = (_QWORD *)(result + 32);
    }
    while ( v14 );
    *v15 = 0LL;
    goto LABEL_19;
  }
  v12 = *(_QWORD *)(v4 + 16);
  *(_QWORD *)(v12 + 24) = result;
  *(_QWORD *)(result + 16) = v12;
LABEL_19:
  if ( !v11 )
    goto LABEL_34;
  v16 = *(unsigned int *)(v4 + 56);
  v17 = a1 + 8 * v16;
  if ( *(_QWORD *)(v17 + 600) == v4 )
  {
    *(_QWORD *)(v17 + 600) = result;
    if ( !result )
    {
      result = (unsigned int)__ROL4__(-2, v16);
      *(_DWORD *)(a1 + 4) &= result;
      goto LABEL_34;
    }
  }
  else
  {
    if ( *(_QWORD *)(v11 + 32) == v4 )
      *(_QWORD *)(v11 + 32) = result;
    else
      *(_QWORD *)(v11 + 40) = result;
    if ( !result )
      goto LABEL_34;
  }
  v18 = *(_QWORD *)(v4 + 32);
  *(_QWORD *)(result + 48) = v11;
  if ( v18 )
  {
    *(_QWORD *)(result + 32) = v18;
    *(_QWORD *)(v18 + 48) = result;
  }
  v19 = *(_QWORD *)(v4 + 40);
  if ( v19 )
  {
    *(_QWORD *)(result + 40) = v19;
    *(_QWORD *)(v19 + 48) = result;
  }
LABEL_34:
  v20 = *(_QWORD *)(v6 + 8);
  if ( (v20 & 2) == 0 )
  {
    v21 = *(_QWORD *)(a1 + 32);
    if ( *(_QWORD *)(a1 + 40) == v6 )
    {
      v22 = *(_QWORD *)(a1 + 16) + a3;
      *(_QWORD *)(a1 + 40) = v4;
      *(_QWORD *)(a1 + 16) = v22;
      *(_QWORD *)(v4 + 8) = v22 | 1;
      if ( v4 == v21 )
      {
        *(_QWORD *)(a1 + 32) = 0LL;
        *(_QWORD *)(a1 + 8) = 0LL;
      }
      return result;
    }
    if ( v6 == v21 )
    {
      v23 = *(_QWORD *)(a1 + 8) + a3;
      *(_QWORD *)(a1 + 32) = v4;
      *(_QWORD *)(a1 + 8) = v23;
      result = v23 | 1;
      *(_QWORD *)(v4 + 8) = v23 | 1;
      *(_QWORD *)(v4 + v23) = v23;
      return result;
    }
    v24 = v20 & 0xFFFFFFFFFFFFFFF8LL;
    v25 = *(_QWORD **)(v6 + 24);
    a3 += v24;
    if ( v24 <= 0xF8 )
    {
      v26 = *(_QWORD **)(v6 + 16);
      if ( v26 == v25 )
      {
        *(_DWORD *)a1 &= __ROL4__(-2, v24 >> 3);
      }
      else
      {
        v26[3] = v25;
        v25[2] = v26;
      }
      goto LABEL_66;
    }
    v27 = *(_QWORD *)(v6 + 48);
    if ( (_QWORD *)v6 != v25 )
    {
      v28 = *(_QWORD *)(v6 + 16);
      *(_QWORD *)(v28 + 24) = v25;
      v25[2] = v28;
      goto LABEL_53;
    }
    v25 = *(_QWORD **)(v6 + 40);
    v29 = (_QWORD *)(v6 + 40);
    if ( !v25 )
    {
      v25 = *(_QWORD **)(v6 + 32);
      if ( !v25 )
        goto LABEL_53;
      v29 = (_QWORD *)(v6 + 32);
    }
    v30 = v25;
    do
    {
      do
      {
        v31 = v29;
        v25 = v30;
        v29 = v30 + 5;
        v30 = (_QWORD *)v30[5];
      }
      while ( v30 );
      v30 = (_QWORD *)v25[4];
      v29 = v25 + 4;
    }
    while ( v30 );
    *v31 = 0LL;
LABEL_53:
    if ( !v27 )
      goto LABEL_66;
    v32 = *(unsigned int *)(v6 + 56);
    v33 = a1 + 8 * v32;
    if ( *(_QWORD *)(v33 + 600) == v6 )
    {
      *(_QWORD *)(v33 + 600) = v25;
      if ( !v25 )
      {
        *(_DWORD *)(a1 + 4) &= __ROL4__(-2, v32);
        goto LABEL_66;
      }
    }
    else
    {
      if ( *(_QWORD *)(v27 + 32) == v6 )
        *(_QWORD *)(v27 + 32) = v25;
      else
        *(_QWORD *)(v27 + 40) = v25;
      if ( !v25 )
        goto LABEL_66;
    }
    v34 = *(_QWORD *)(v6 + 32);
    v25[6] = v27;
    if ( v34 )
    {
      v25[4] = v34;
      *(_QWORD *)(v34 + 48) = v25;
    }
    v35 = *(_QWORD *)(v6 + 40);
    if ( v35 )
    {
      v25[5] = v35;
      *(_QWORD *)(v35 + 48) = v25;
    }
LABEL_66:
    result = a3 | 1;
    *(_QWORD *)(v4 + 8) = a3 | 1;
    *(_QWORD *)(v4 + a3) = a3;
    if ( v4 == v21 )
    {
      *(_QWORD *)(a1 + 8) = a3;
      return result;
    }
    goto LABEL_69;
  }
  *(_QWORD *)(v6 + 8) = v20 & 0xFFFFFFFFFFFFFFFELL;
  *(_QWORD *)(v4 + 8) = a3 | 1;
  *(_QWORD *)(v4 + a3) = a3;
LABEL_69:
  v36 = a3 >> 3;
  if ( a3 > 0xFF )
  {
    v38 = a3 >> 8;
    v39 = a3 >> 8;
    if ( v39 )
    {
      v39 = 31;
      if ( (unsigned int)v38 <= 0xFFFF )
      {
        _BitScanReverse((unsigned int *)&v38, v38);
        v39 = ((a3 >> (38 - ((unsigned __int8)v38 ^ 0x1Fu))) & 1) + 2 * (31 - (v38 ^ 0x1F));
      }
    }
    v40 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(v4 + 56) = v39;
    *(_QWORD *)(v4 + 40) = 0LL;
    v41 = 1 << v39;
    *(_QWORD *)(v4 + 32) = 0LL;
    v42 = v39;
    if ( ((1 << v39) & v40) != 0 )
    {
      v43 = 0;
      v44 = *(_QWORD *)(a1 + 8LL * v39 + 600);
      if ( v39 != 31 )
        v43 = 57 - (v39 >> 1);
      v45 = a3 << v43;
      while ( (*(_QWORD *)(v44 + 8) & 0xFFFFFFFFFFFFFFF8LL) != a3 )
      {
        v46 = v45;
        v45 *= 2LL;
        result = (v46 >> 63) + 4;
        if ( !*(_QWORD *)(v44 + 8 * result) )
        {
          *(_QWORD *)(v44 + 8 * result) = v4;
          *(_QWORD *)(v4 + 48) = v44;
          goto LABEL_86;
        }
        v44 = *(_QWORD *)(v44 + 8 * result);
      }
      result = *(_QWORD *)(v44 + 16);
      *(_QWORD *)(result + 24) = v4;
      *(_QWORD *)(v44 + 16) = v4;
      *(_QWORD *)(v4 + 16) = result;
      *(_QWORD *)(v4 + 24) = v44;
      *(_QWORD *)(v4 + 48) = 0LL;
    }
    else
    {
      result = a1 + 8LL * v39 + 600;
      *(_DWORD *)(a1 + 4) = v41 | v40;
      *(_QWORD *)(a1 + 8 * v42 + 600) = v4;
      *(_QWORD *)(v4 + 48) = result;
LABEL_86:
      *(_QWORD *)(v4 + 24) = v4;
      *(_QWORD *)(v4 + 16) = v4;
    }
  }
  else
  {
    result = a1 + 8LL * (unsigned int)(2 * v36) + 72;
    if ( ((1 << v36) & *(_DWORD *)a1) != 0 )
    {
      v37 = *(_QWORD *)(a1 + 8LL * (unsigned int)(2 * v36) + 88);
    }
    else
    {
      *(_DWORD *)a1 |= 1 << v36;
      v37 = a1 + 8LL * (unsigned int)(2 * v36) + 72;
    }
    *(_QWORD *)(a1 + 8LL * (unsigned int)(2 * v36) + 88) = v4;
    *(_QWORD *)(v37 + 24) = v4;
    *(_QWORD *)(v4 + 16) = v37;
    *(_QWORD *)(v4 + 24) = result;
  }
  return result;
}

//----- (0000000000402B64) ----------------------------------------------------
unsigned __int64 __fastcall sub_402B64(unsigned __int64 a1)
{
  unsigned __int64 v1; // rbx
  int v2; // esi
  unsigned __int64 v3; // rcx
  unsigned int v4; // eax
  int v5; // ecx
  char *v6; // rdi
  __int128 v7; // rax
  __int64 v8; // r8
  unsigned __int64 v9; // r9
  int v10; // eax
  int v11; // ecx
  __int64 v12; // rdi
  char *v13; // r10
  __int64 v14; // r11
  __int64 v15; // rsi
  unsigned __int64 v16; // rcx
  __int64 v17; // rbx
  __int64 v18; // rdx
  int v19; // er11
  char *v20; // r8
  char *v21; // rcx
  int v22; // edi
  unsigned int v23; // eax
  __int64 v24; // rcx
  unsigned __int64 v25; // r8
  __int64 v26; // r10
  unsigned __int64 v27; // r12
  __int64 v28; // rcx
  __int64 v29; // r11
  __int64 v30; // rcx
  _QWORD *v31; // r13
  __int64 v32; // r11
  __int64 v33; // rcx
  __int64 v34; // rcx
  __int64 v35; // r10
  __int64 v36; // rdx
  unsigned __int64 v37; // rcx
  int v38; // er9
  char *v39; // rdi
  char *v40; // rcx
  unsigned __int64 v41; // rbx
  int v42; // edi
  unsigned __int64 v43; // rax
  unsigned __int64 v44; // r9
  unsigned int v45; // esi
  char v46; // cl
  __int64 v47; // r11
  __int64 v48; // r10
  unsigned __int64 i; // rcx
  unsigned __int64 v50; // rdx
  unsigned int v51; // eax
  __int64 v52; // rcx
  __int64 v53; // rsi
  unsigned __int64 v54; // r10
  __int64 v55; // rcx
  __int64 v56; // r8
  __int64 v57; // rcx
  _QWORD *v58; // r11
  __int64 v59; // r8
  __int64 v60; // rcx
  __int64 v61; // rcx
  __int64 v62; // r8
  unsigned __int64 v63; // rcx
  int v64; // edi
  char *v65; // rdx
  char *v66; // rcx
  unsigned __int64 v67; // rsi
  unsigned int v68; // edx
  int v69; // esi
  char v70; // cl
  __int64 v71; // rsi
  unsigned __int64 v72; // rcx
  unsigned __int64 v73; // rdx
  __int64 v74; // rdx
  __int64 v75; // rdx
  unsigned __int64 v76; // rcx
  unsigned __int64 *v77; // rsi
  __int64 v78; // rdx
  unsigned __int64 v79; // r12
  unsigned __int64 v80; // r12
  unsigned __int64 v81; // r12
  unsigned __int64 v82; // r9
  __int64 v83; // rax
  __int64 v84; // r10
  _QWORD *v85; // rax
  __int64 v86; // rdx
  __int64 v87; // rsi
  __int64 v88; // rax
  __int64 *v89; // rcx
  char v90; // r11
  __int64 v91; // rcx
  __int64 v92; // rdx
  __int64 v93; // rax
  unsigned __int64 v94; // r8
  __int64 v95; // r8
  unsigned __int64 v96; // rdi
  _QWORD *v97; // rsi
  unsigned __int64 v98; // rbx
  unsigned __int64 v99; // rcx
  _QWORD *v100; // rdi
  __int64 v101; // rdi
  __int64 v102; // rcx
  _QWORD *v103; // r10
  _QWORD *v104; // rcx
  _QWORD *v105; // r12
  __int64 v106; // r10
  int v107; // ecx
  __int64 v108; // rcx
  __int64 v109; // rcx
  unsigned __int64 v110; // rcx
  int v111; // edi
  char *v112; // rdx
  char *v113; // rcx
  unsigned __int64 v114; // rsi
  unsigned int v115; // edx
  int v116; // esi
  __int64 v117; // rsi
  unsigned __int64 v118; // rcx
  unsigned __int64 v119; // rdx
  __int64 v120; // rdx
  __int64 v121; // rdx
  unsigned __int64 v123; // r13
  __int64 v124; // r9
  __int64 v125; // r10
  _QWORD *v126; // r11
  _DWORD *v127; // rdi
  __int64 *v128; // rsi
  __int64 j; // rcx
  _QWORD *v130; // rax
  unsigned __int64 v131; // rsi
  unsigned __int64 v132; // rcx
  char *v133; // rax
  char *v134; // rdx
  unsigned __int64 v135; // rdx
  unsigned int v136; // eax
  int v137; // edx
  char v138; // cl
  __int64 v139; // rdx
  unsigned __int64 v140; // rcx
  unsigned __int64 v141; // rax
  __int64 v142; // rax
  __int64 v143; // rax

  if ( a1 <= 0xE0 )
  {
    v1 = 32LL;
    if ( a1 > 0xE )
      v1 = (a1 + 31) & 0xFFFFFFFFFFFFFFF0LL;
    v2 = dword_4420A0;
    v3 = v1 >> 3;
    v4 = (unsigned int)dword_4420A0 >> (v1 >> 3);
    if ( (v4 & 3) != 0 )
    {
      v5 = ((v4 & 1) == 0) + (_DWORD)v3;
      v6 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v5);
      *(_QWORD *)&v7 = *((_QWORD *)v6 + 2);
      v8 = *(_QWORD *)(v7 + 16);
      if ( v6 == (char *)v8 )
      {
        dword_4420A0 &= ~(1 << v5);
      }
      else
      {
        *(_QWORD *)(v8 + 24) = v6;
        *((_QWORD *)v6 + 2) = v8;
      }
      *(_QWORD *)(v7 + 8) = (8 * v5) | 3u;
      *(_QWORD *)(v7 + (unsigned int)(8 * v5) + 8) |= 1uLL;
      return v7 + 16;
    }
    v9 = qword_4420A8[0];
    if ( qword_4420A8[0] < v1 )
    {
      if ( v4 )
      {
        v10 = ((2 * (1 << v3)) | (-2 * (1 << v3))) & (v4 << v3);
        _BitScanForward((unsigned int *)&v3, -v10 & v10);
        v12 = (unsigned int)(8 * v11);
        v13 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v11);
        *(_QWORD *)&v7 = *((_QWORD *)v13 + 2);
        v14 = *(_QWORD *)(v7 + 16);
        if ( v13 == (char *)v14 )
        {
          dword_4420A0 &= ~(1 << v3);
        }
        else
        {
          *(_QWORD *)(v14 + 24) = v13;
          *((_QWORD *)v13 + 2) = v14;
        }
        *((_QWORD *)&v7 + 1) = v7 + v12;
        v15 = v12 - v1;
        if ( v12 - v1 > 0x1F )
        {
          v16 = v1;
          v17 = v7 + v1;
          *(_QWORD *)(v7 + 8) = v16 | 3;
          *(_QWORD *)(v17 + 8) = v15 | 1;
          **((_QWORD **)&v7 + 1) = v15;
          if ( v9 )
          {
            v18 = qword_4420C0;
            v19 = 1 << (v9 >> 3);
            v20 = (char *)&unk_4420E8 + 16 * (unsigned int)(v9 >> 3);
            if ( (v19 & dword_4420A0) != 0 )
            {
              v21 = (char *)*((_QWORD *)v20 + 2);
            }
            else
            {
              v21 = (char *)&unk_4420E8 + 16 * (unsigned int)(v9 >> 3);
              dword_4420A0 |= v19;
            }
            *((_QWORD *)v20 + 2) = qword_4420C0;
            *((_QWORD *)v21 + 3) = v18;
            *(_QWORD *)(v18 + 16) = v21;
            *(_QWORD *)(v18 + 24) = v20;
          }
          qword_4420A8[0] = v15;
          qword_4420C0 = v17;
        }
        else
        {
          *(_QWORD *)(v7 + 8) = (8 * (_DWORD)v3) | 3u;
          *(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) |= 1uLL;
        }
        return v7 + 16;
      }
      v22 = dword_4420A4;
      if ( dword_4420A4 )
      {
        _BitScanForward(&v23, dword_4420A4 & -dword_4420A4);
        *(_QWORD *)&v7 = qword_4422F8[v23];
        v24 = v7;
        v25 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8LL) - v1;
        while ( 1 )
        {
          *((_QWORD *)&v7 + 1) = *(_QWORD *)(v24 + 32);
          if ( !*((_QWORD *)&v7 + 1) )
          {
            *((_QWORD *)&v7 + 1) = *(_QWORD *)(v24 + 40);
            if ( !*((_QWORD *)&v7 + 1) )
              break;
          }
          if ( (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1 < v25 )
          {
            v25 = (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1;
            *(_QWORD *)&v7 = *((_QWORD *)&v7 + 1);
          }
          v24 = *((_QWORD *)&v7 + 1);
        }
        *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 24);
        v26 = *(_QWORD *)(v7 + 48);
        v27 = v1 + v25;
        if ( *((_QWORD *)&v7 + 1) != (_QWORD)v7 )
        {
          v28 = *(_QWORD *)(v7 + 16);
          *(_QWORD *)(v28 + 24) = *((_QWORD *)&v7 + 1);
          *(_QWORD *)(*((_QWORD *)&v7 + 1) + 16LL) = v28;
          goto LABEL_38;
        }
        *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
        v29 = v7 + 40;
        if ( !*((_QWORD *)&v7 + 1) )
        {
          *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 32);
          if ( !*((_QWORD *)&v7 + 1) )
            goto LABEL_38;
          v29 = v7 + 32;
        }
        v30 = *((_QWORD *)&v7 + 1);
        do
        {
          do
          {
            v31 = (_QWORD *)v29;
            *((_QWORD *)&v7 + 1) = v30;
            v29 = v30 + 40;
            v30 = *(_QWORD *)(v30 + 40);
          }
          while ( v30 );
          v30 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL);
          v29 = *((_QWORD *)&v7 + 1) + 32LL;
        }
        while ( v30 );
        *v31 = 0LL;
LABEL_38:
        if ( v26 )
        {
          v32 = *(unsigned int *)(v7 + 56);
          if ( qword_4422F8[v32] == (_QWORD)v7 )
          {
            qword_4420A8[v32 + 74] = *((_QWORD *)&v7 + 1);
            if ( *((_QWORD *)&v7 + 1) )
            {
LABEL_41:
              v33 = *(_QWORD *)(v7 + 32);
              *(_QWORD *)(*((_QWORD *)&v7 + 1) + 48LL) = v26;
              if ( v33 )
              {
                *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL) = v33;
                *(_QWORD *)(v33 + 48) = *((_QWORD *)&v7 + 1);
              }
              v34 = *(_QWORD *)(v7 + 40);
              if ( v34 )
              {
                *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40LL) = v34;
                *(_QWORD *)(v34 + 48) = *((_QWORD *)&v7 + 1);
              }
              goto LABEL_51;
            }
            dword_4420A4 = v22 & ~(1 << v32);
          }
          else
          {
            if ( *(_QWORD *)(v26 + 32) == (_QWORD)v7 )
              *(_QWORD *)(v26 + 32) = *((_QWORD *)&v7 + 1);
            else
              *(_QWORD *)(v26 + 40) = *((_QWORD *)&v7 + 1);
            if ( *((_QWORD *)&v7 + 1) )
              goto LABEL_41;
          }
        }
LABEL_51:
        if ( v25 > 0x1F )
        {
          v35 = v7 + v1;
          *(_QWORD *)(v7 + 8) = v1 | 3;
          *(_QWORD *)(v35 + 8) = v25 | 1;
          *(_QWORD *)(v35 + v25) = v25;
          if ( v9 )
          {
            v36 = qword_4420C0;
            v37 = v9 >> 3;
            v38 = 1 << (v9 >> 3);
            v39 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v37);
            if ( (v38 & v2) != 0 )
            {
              v40 = (char *)*((_QWORD *)v39 + 2);
            }
            else
            {
              v40 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v37);
              dword_4420A0 = v38 | v2;
            }
            *((_QWORD *)v39 + 2) = qword_4420C0;
            *((_QWORD *)v40 + 3) = v36;
            *(_QWORD *)(v36 + 16) = v40;
            *(_QWORD *)(v36 + 24) = v39;
          }
          qword_4420A8[0] = v25;
          qword_4420C0 = v7 + v1;
        }
        else
        {
          *(_QWORD *)(v7 + 8) = v27 | 3;
          *(_QWORD *)(v7 + v27 + 8) |= 1uLL;
        }
        return v7 + 16;
      }
    }
    goto LABEL_133;
  }
  if ( a1 > 0xFFFFFFFFFFFFFF7FLL )
  {
    v1 = -1LL;
    goto LABEL_133;
  }
  v41 = a1 + 31;
  v42 = dword_4420A4;
  v1 = v41 & 0xFFFFFFFFFFFFFFF0LL;
  if ( !dword_4420A4 )
    goto LABEL_133;
  v43 = v1 >> 8;
  v44 = -(__int64)v1;
  v45 = v1 >> 8;
  if ( v45 )
  {
    v45 = 31;
    if ( (unsigned int)v43 <= 0xFFFF )
    {
      _BitScanReverse((unsigned int *)&v43, v43);
      v45 = ((v1 >> (38 - ((unsigned __int8)v43 ^ 0x1Fu))) & 1) + 2 * (31 - (v43 ^ 0x1F));
    }
  }
  v7 = (unsigned __int64)qword_4422F8[v45];
  if ( (_QWORD)v7 )
  {
    v46 = 0;
    if ( v45 != 31 )
      v46 = 57 - (v45 >> 1);
    v47 = 0LL;
    v48 = 0LL;
    for ( i = v1 << v46; ; i *= 2LL )
    {
      v50 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8LL) - v1;
      if ( v50 < v44 )
      {
        if ( !v50 )
        {
          *((_QWORD *)&v7 + 1) = v7;
          v44 = 0LL;
          goto LABEL_78;
        }
        v44 = (*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8LL) - v1;
        v48 = v7;
      }
      *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
      *(_QWORD *)&v7 = *(_QWORD *)(v7 + 8 * ((i >> 63) + 4));
      if ( !*((_QWORD *)&v7 + 1) || *((_QWORD *)&v7 + 1) == (_QWORD)v7 )
        *((_QWORD *)&v7 + 1) = v47;
      if ( !(_QWORD)v7 )
        break;
      v47 = *((_QWORD *)&v7 + 1);
    }
    *(_QWORD *)&v7 = v48;
  }
LABEL_78:
  if ( v7 == 0 )
  {
    if ( (dword_4420A4 & (-2 << v45)) == 0 )
      goto LABEL_133;
    _BitScanForward(&v51, dword_4420A4 & (-2 << v45) & -(dword_4420A4 & (-2 << v45)));
    *((_QWORD *)&v7 + 1) = qword_4422F8[v51];
    *(_QWORD *)&v7 = 0LL;
  }
  while ( *((_QWORD *)&v7 + 1) )
  {
    if ( (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1 < v44 )
    {
      v44 = (*(_QWORD *)(*((_QWORD *)&v7 + 1) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) - v1;
      *(_QWORD *)&v7 = *((_QWORD *)&v7 + 1);
    }
    v52 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL);
    if ( !v52 )
      v52 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40LL);
    *((_QWORD *)&v7 + 1) = v52;
  }
  if ( (_QWORD)v7 && v44 < qword_4420A8[0] - v1 )
  {
    *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 24);
    v53 = *(_QWORD *)(v7 + 48);
    v54 = v1 + v44;
    if ( *((_QWORD *)&v7 + 1) != (_QWORD)v7 )
    {
      v55 = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(v55 + 24) = *((_QWORD *)&v7 + 1);
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 16LL) = v55;
      goto LABEL_98;
    }
    *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 40);
    v56 = v7 + 40;
    if ( !*((_QWORD *)&v7 + 1) )
    {
      *((_QWORD *)&v7 + 1) = *(_QWORD *)(v7 + 32);
      if ( !*((_QWORD *)&v7 + 1) )
        goto LABEL_98;
      v56 = v7 + 32;
    }
    v57 = *((_QWORD *)&v7 + 1);
    do
    {
      do
      {
        v58 = (_QWORD *)v56;
        *((_QWORD *)&v7 + 1) = v57;
        v56 = v57 + 40;
        v57 = *(_QWORD *)(v57 + 40);
      }
      while ( v57 );
      v57 = *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL);
      v56 = *((_QWORD *)&v7 + 1) + 32LL;
    }
    while ( v57 );
    *v58 = 0LL;
LABEL_98:
    if ( !v53 )
      goto LABEL_111;
    v59 = *(unsigned int *)(v7 + 56);
    if ( qword_4422F8[v59] == (_QWORD)v7 )
    {
      qword_4420A8[v59 + 74] = *((_QWORD *)&v7 + 1);
      if ( !*((_QWORD *)&v7 + 1) )
      {
        dword_4420A4 = v42 & ~(1 << v59);
        goto LABEL_111;
      }
    }
    else
    {
      if ( *(_QWORD *)(v53 + 32) == (_QWORD)v7 )
        *(_QWORD *)(v53 + 32) = *((_QWORD *)&v7 + 1);
      else
        *(_QWORD *)(v53 + 40) = *((_QWORD *)&v7 + 1);
      if ( !*((_QWORD *)&v7 + 1) )
        goto LABEL_111;
    }
    v60 = *(_QWORD *)(v7 + 32);
    *(_QWORD *)(*((_QWORD *)&v7 + 1) + 48LL) = v53;
    if ( v60 )
    {
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 32LL) = v60;
      *(_QWORD *)(v60 + 48) = *((_QWORD *)&v7 + 1);
    }
    v61 = *(_QWORD *)(v7 + 40);
    if ( v61 )
    {
      *(_QWORD *)(*((_QWORD *)&v7 + 1) + 40LL) = v61;
      *(_QWORD *)(v61 + 48) = *((_QWORD *)&v7 + 1);
    }
LABEL_111:
    if ( v44 > 0x1F )
    {
      v62 = v7 + v1;
      v63 = v44 >> 3;
      *(_QWORD *)(v7 + 8) = v1 | 3;
      *(_QWORD *)(v62 + 8) = v44 | 1;
      *(_QWORD *)(v62 + v44) = v44;
      if ( v44 > 0xFF )
      {
        v67 = v44 >> 8;
        v68 = v44 >> 8;
        if ( v68 )
        {
          v68 = 31;
          if ( (unsigned int)v67 <= 0xFFFF )
          {
            _BitScanReverse((unsigned int *)&v67, v67);
            v68 = ((v44 >> (38 - ((unsigned __int8)v67 ^ 0x1Fu))) & 1) + 2 * (31 - (v67 ^ 0x1F));
          }
        }
        v69 = dword_4420A4;
        *(_DWORD *)(v62 + 56) = v68;
        *(_QWORD *)(v62 + 40) = 0LL;
        *(_QWORD *)(v62 + 32) = 0LL;
        if ( ((1 << v68) & v69) != 0 )
        {
          v70 = 0;
          v71 = qword_4422F8[v68];
          if ( v68 != 31 )
            v70 = 57 - (v68 >> 1);
          v72 = v44 << v70;
          while ( v44 != (*(_QWORD *)(v71 + 8) & 0xFFFFFFFFFFFFFFF8LL) )
          {
            v73 = v72;
            v72 *= 2LL;
            v74 = (v73 >> 63) + 4;
            if ( !*(_QWORD *)(v71 + 8 * v74) )
            {
              *(_QWORD *)(v71 + 8 * v74) = v62;
              *(_QWORD *)(v62 + 48) = v71;
              goto LABEL_130;
            }
            v71 = *(_QWORD *)(v71 + 8 * v74);
          }
          v75 = *(_QWORD *)(v71 + 16);
          *(_QWORD *)(v75 + 24) = v62;
          *(_QWORD *)(v71 + 16) = v62;
          *(_QWORD *)(v62 + 16) = v75;
          *(_QWORD *)(v62 + 24) = v71;
          *(_QWORD *)(v62 + 48) = 0LL;
        }
        else
        {
          qword_4422F8[v68] = v62;
          dword_4420A4 = (1 << v68) | v69;
          *(_QWORD *)(v62 + 48) = &qword_4422F8[v68];
LABEL_130:
          *(_QWORD *)(v62 + 24) = v62;
          *(_QWORD *)(v62 + 16) = v62;
        }
      }
      else
      {
        v64 = 1 << v63;
        v65 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v63);
        if ( ((1 << v63) & dword_4420A0) != 0 )
        {
          v66 = (char *)*((_QWORD *)v65 + 2);
        }
        else
        {
          v66 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v63);
          dword_4420A0 |= v64;
        }
        *((_QWORD *)v65 + 2) = v62;
        *((_QWORD *)v66 + 3) = v62;
        *(_QWORD *)(v62 + 16) = v66;
        *(_QWORD *)(v62 + 24) = v65;
      }
    }
    else
    {
      *(_QWORD *)(v7 + 8) = v54 | 3;
      *(_QWORD *)(v7 + v54 + 8) |= 1uLL;
    }
    return v7 + 16;
  }
LABEL_133:
  if ( qword_4420A8[0] >= v1 )
  {
    *(_QWORD *)&v7 = qword_4420C0;
    v76 = qword_4420A8[0] - v1;
    v77 = (unsigned __int64 *)(qword_4420C0 + qword_4420A8[0]);
    if ( qword_4420A8[0] - v1 <= 0x1F )
    {
      *((_QWORD *)&v7 + 1) = qword_4420A8[0] | 3;
      qword_4420A8[0] = 0LL;
      qword_4420C0 = 0LL;
      *(_QWORD *)(v7 + 8) = *((_QWORD *)&v7 + 1);
      v77[1] |= 1uLL;
      return v7 + 16;
    }
    qword_4420A8[0] -= v1;
    qword_4420C0 += v1;
    *(_QWORD *)(qword_4420C0 + 8) = v76 | 1;
    *v77 = v76;
LABEL_262:
    *(_QWORD *)(v7 + 8) = v1 | 3;
    return v7 + 16;
  }
  if ( qword_4420B0 > v1 )
  {
    *((_QWORD *)&v7 + 1) = qword_4420B0 - v1;
LABEL_261:
    *(_QWORD *)&v7 = qword_4420C8;
    qword_4420B0 = *((_QWORD *)&v7 + 1);
    qword_4420C8 += v1;
    *(_QWORD *)(qword_4420C8 + 8) = *((_QWORD *)&v7 + 1) | 1LL;
    goto LABEL_262;
  }
  v78 = -qword_442470;
  if ( (dword_442410 & 1) != 0 && v1 >= qword_442478 )
  {
    if ( qword_4420B0 )
    {
      v79 = v78 & (v1 + qword_442470 + 62);
      if ( (!qword_442408 || qword_4423F8 < qword_4423F8 + v79 && qword_442408 >= qword_4423F8 + v79) && v1 < v79 )
      {
        *(_QWORD *)&v7 = sub_404518(v78 & (v1 + qword_442470 + 62));
        *(_QWORD *)v7 = 0LL;
        *(_QWORD *)(v7 + 8) = v79 - 32;
        *((_QWORD *)&v7 + 1) = qword_4420B8;
        *(_QWORD *)(v7 + v79 - 24) = 11LL;
        *(_QWORD *)(v7 + v79 - 16) = 0LL;
        if ( !*((_QWORD *)&v7 + 1) || (unsigned __int64)v7 < *((_QWORD *)&v7 + 1) )
          qword_4420B8 = v7;
        v80 = qword_4423F8 + v79;
        qword_4423F8 = v80;
        if ( v80 > qword_442400 )
          qword_442400 = v80;
        return v7 + 16;
      }
    }
  }
  v81 = v78 & (v1 + qword_442470 + 95);
  if ( v1 < v81 && (!qword_442408 || qword_4423F8 < v81 + qword_4423F8 && qword_442408 >= v81 + qword_4423F8) )
  {
    v82 = sub_404518(v81);
    v83 = v81 + qword_4423F8;
    qword_4423F8 += v81;
    if ( qword_4423F8 > (unsigned __int64)qword_442400 )
      qword_442400 = v83;
    v84 = qword_4420C8;
    if ( !qword_4420C8 )
    {
      if ( !qword_4420B8 || v82 < qword_4420B8 )
        qword_4420B8 = v82;
      qword_442418 = v82;
      qword_442420 = v81;
      dword_442430 = 1;
      qword_4420D8 = 128LL;
      qword_4420E0 = qword_442460;
      v85 = &unk_4420E8;
      do
      {
        v85[3] = v85;
        v85[2] = v85;
        v85 += 2;
      }
      while ( &unk_4422E8 != (_UNKNOWN *)v85 );
      v86 = v81 - 80;
      v87 = v82;
      goto LABEL_170;
    }
    v88 = qword_442418;
    if ( v82 == qword_442418 + qword_442420
      && (dword_442430 & 8) == 0
      && (dword_442430 & 1) != 0
      && qword_4420C8 >= (unsigned __int64)qword_442418
      && v82 > qword_4420C8 )
    {
      v87 = qword_4420C8;
      qword_442420 += v81;
      v86 = v81 + qword_4420B0;
LABEL_170:
      sub_4022A8(&dword_4420A0, v87, v86);
LABEL_259:
      if ( v1 < qword_4420B0 )
      {
        *((_QWORD *)&v7 + 1) = qword_4420B0 - v1;
        goto LABEL_261;
      }
      sub_4018E7();
      return 0LL;
    }
    if ( v82 < qword_4420B8 )
      qword_4420B8 = v82;
    v89 = &qword_442418;
    if ( qword_442418 != v82 + v81 || (v90 = dword_442430 & 8, (dword_442430 & 8) != 0) || (dword_442430 & 1) == 0 )
    {
      while ( 1 )
      {
        if ( qword_4420C8 >= (unsigned __int64)*v89 )
        {
          v123 = v89[1] + *v89;
          if ( qword_4420C8 < v123 )
            break;
        }
        v89 = (__int64 *)v89[2];
        if ( !v89 )
          BUG();
      }
      sub_4022A8(&dword_4420A0, v82, v81 - 80);
      v126[1] = 51LL;
      v127 = v126 + 2;
      v128 = &qword_442418;
      for ( j = 8LL; j; --j )
      {
        *v127 = *(_DWORD *)v128;
        v128 = (__int64 *)((char *)v128 + 4);
        ++v127;
      }
      qword_442428 = (__int64)(v126 + 2);
      v130 = v126 + 7;
      qword_442418 = v124;
      qword_442420 = v81;
      dword_442430 = 1;
      do
        *v130++ = 11LL;
      while ( v123 > (unsigned __int64)v130 );
      if ( (_QWORD *)v125 != v126 )
      {
        v126[1] &= ~1uLL;
        v131 = (unsigned __int64)v126 - v125;
        v132 = ((unsigned __int64)v126 - v125) >> 3;
        *(_QWORD *)(v125 + 8) = ((unsigned __int64)v126 - v125) | 1;
        *v126 = (char *)v126 - v125;
        if ( (unsigned __int64)v126 - v125 > 0xFF )
        {
          v135 = v131 >> 8;
          v136 = v131 >> 8;
          if ( v136 )
          {
            v136 = 31;
            if ( (unsigned int)v135 <= 0xFFFF )
            {
              _BitScanReverse((unsigned int *)&v135, v135);
              v136 = ((v131 >> (38 - ((unsigned __int8)v135 ^ 0x1Fu))) & 1) + 2 * (31 - (v135 ^ 0x1F));
            }
          }
          v137 = dword_4420A4;
          *(_DWORD *)(v125 + 56) = v136;
          *(_QWORD *)(v125 + 40) = 0LL;
          *(_QWORD *)(v125 + 32) = 0LL;
          if ( ((1 << v136) & v137) != 0 )
          {
            v138 = 0;
            v139 = qword_4422F8[v136];
            if ( v136 != 31 )
              v138 = 57 - (v136 >> 1);
            v140 = v131 << v138;
            while ( v131 != (*(_QWORD *)(v139 + 8) & 0xFFFFFFFFFFFFFFF8LL) )
            {
              v141 = v140;
              v140 *= 2LL;
              v142 = (v141 >> 63) + 4;
              if ( !*(_QWORD *)(v139 + 8 * v142) )
              {
                *(_QWORD *)(v139 + 8 * v142) = v125;
                *(_QWORD *)(v125 + 48) = v139;
                goto LABEL_257;
              }
              v139 = *(_QWORD *)(v139 + 8 * v142);
            }
            v143 = *(_QWORD *)(v139 + 16);
            *(_QWORD *)(v143 + 24) = v125;
            *(_QWORD *)(v139 + 16) = v125;
            *(_QWORD *)(v125 + 16) = v143;
            *(_QWORD *)(v125 + 24) = v139;
            *(_QWORD *)(v125 + 48) = 0LL;
          }
          else
          {
            qword_4422F8[v136] = v125;
            dword_4420A4 = (1 << v136) | v137;
            *(_QWORD *)(v125 + 48) = &qword_4422F8[v136];
LABEL_257:
            *(_QWORD *)(v125 + 24) = v125;
            *(_QWORD *)(v125 + 16) = v125;
          }
        }
        else
        {
          v133 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v132);
          if ( ((1 << v132) & dword_4420A0) != 0 )
          {
            v134 = (char *)*((_QWORD *)v133 + 2);
          }
          else
          {
            dword_4420A0 |= 1 << v132;
            v134 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v132);
          }
          *((_QWORD *)v133 + 2) = v125;
          *((_QWORD *)v134 + 3) = v125;
          *(_QWORD *)(v125 + 16) = v134;
          *(_QWORD *)(v125 + 24) = v133;
        }
      }
      goto LABEL_259;
    }
    qword_442418 = v82;
    v91 = v88 & 0xF;
    qword_442420 += v81;
    if ( (v88 & 0xF) != 0 )
      v91 = -(char)(v88 + 16) & 0xF;
    v92 = v88 + v91;
    v93 = v82 + v1;
    v94 = v92 - v82 - v1;
    *(_QWORD *)(v82 + 8) = v1 | 3;
    if ( v84 == v92 )
    {
      qword_4420C8 = v82 + v1;
      qword_4420B0 += v94;
      *(_QWORD *)(v93 + 8) = qword_4420B0 | 1;
      return v82 + 16;
    }
    if ( v92 == qword_4420C0 )
    {
      v95 = qword_4420A8[0] + v94;
      qword_4420C0 = v82 + v1;
      qword_4420A8[0] = v95;
      *(_QWORD *)(v93 + 8) = v95 | 1;
      *(_QWORD *)(v93 + v95) = v95;
      return v82 + 16;
    }
    v96 = *(_QWORD *)(v92 + 8);
    if ( (v96 & 3) != 1 )
    {
LABEL_210:
      *(_QWORD *)(v92 + 8) &= ~1uLL;
      v110 = v94 >> 3;
      *(_QWORD *)(v93 + 8) = v94 | 1;
      *(_QWORD *)(v93 + v94) = v94;
      if ( v94 > 0xFF )
      {
        v114 = v94 >> 8;
        v115 = v94 >> 8;
        if ( v115 )
        {
          v115 = 31;
          if ( (unsigned int)v114 <= 0xFFFF )
          {
            _BitScanReverse((unsigned int *)&v114, v114);
            v115 = ((v94 >> (38 - ((unsigned __int8)v114 ^ 0x1Fu))) & 1) + 2 * (31 - (v114 ^ 0x1F));
          }
        }
        v116 = dword_4420A4;
        *(_DWORD *)(v93 + 56) = v115;
        *(_QWORD *)(v93 + 40) = 0LL;
        *(_QWORD *)(v93 + 32) = 0LL;
        if ( ((1 << v115) & v116) != 0 )
        {
          v117 = qword_4422F8[v115];
          if ( v115 != 31 )
            v90 = 57 - (v115 >> 1);
          v118 = v94 << v90;
          while ( v94 != (*(_QWORD *)(v117 + 8) & 0xFFFFFFFFFFFFFFF8LL) )
          {
            v119 = v118;
            v118 *= 2LL;
            v120 = (v119 >> 63) + 4;
            if ( !*(_QWORD *)(v117 + 8 * v120) )
            {
              *(_QWORD *)(v117 + 8 * v120) = v93;
              *(_QWORD *)(v93 + 48) = v117;
              goto LABEL_227;
            }
            v117 = *(_QWORD *)(v117 + 8 * v120);
          }
          v121 = *(_QWORD *)(v117 + 16);
          *(_QWORD *)(v121 + 24) = v93;
          *(_QWORD *)(v117 + 16) = v93;
          *(_QWORD *)(v93 + 16) = v121;
          *(_QWORD *)(v93 + 24) = v117;
          *(_QWORD *)(v93 + 48) = 0LL;
        }
        else
        {
          qword_4422F8[v115] = v93;
          dword_4420A4 = (1 << v115) | v116;
          *(_QWORD *)(v93 + 48) = &qword_4422F8[v115];
LABEL_227:
          *(_QWORD *)(v93 + 24) = v93;
          *(_QWORD *)(v93 + 16) = v93;
        }
      }
      else
      {
        v111 = 1 << v110;
        v112 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v110);
        if ( ((1 << v110) & dword_4420A0) != 0 )
        {
          v113 = (char *)*((_QWORD *)v112 + 2);
        }
        else
        {
          v113 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v110);
          dword_4420A0 |= v111;
        }
        *((_QWORD *)v112 + 2) = v93;
        *((_QWORD *)v113 + 3) = v93;
        *(_QWORD *)(v93 + 16) = v113;
        *(_QWORD *)(v93 + 24) = v112;
      }
      return v82 + 16;
    }
    v97 = *(_QWORD **)(v92 + 24);
    v98 = v96 & 0xFFFFFFFFFFFFFFF8LL;
    v99 = v96 >> 3;
    if ( v96 <= 0xFF )
    {
      v100 = *(_QWORD **)(v92 + 16);
      if ( v100 == v97 )
      {
        dword_4420A0 &= __ROL4__(-2, v99);
      }
      else
      {
        v100[3] = v97;
        v97[2] = v100;
      }
      goto LABEL_209;
    }
    v101 = *(_QWORD *)(v92 + 48);
    if ( (_QWORD *)v92 != v97 )
    {
      v102 = *(_QWORD *)(v92 + 16);
      *(_QWORD *)(v102 + 24) = v97;
      v97[2] = v102;
      goto LABEL_196;
    }
    v97 = *(_QWORD **)(v92 + 40);
    v103 = (_QWORD *)(v92 + 40);
    if ( !v97 )
    {
      v97 = *(_QWORD **)(v92 + 32);
      if ( !v97 )
        goto LABEL_196;
      v103 = (_QWORD *)(v92 + 32);
    }
    v104 = v97;
    do
    {
      do
      {
        v105 = v103;
        v97 = v104;
        v103 = v104 + 5;
        v104 = (_QWORD *)v104[5];
      }
      while ( v104 );
      v104 = (_QWORD *)v97[4];
      v103 = v97 + 4;
    }
    while ( v104 );
    *v105 = 0LL;
LABEL_196:
    if ( v101 )
    {
      v106 = *(unsigned int *)(v92 + 56);
      v107 = *(_DWORD *)(v92 + 56);
      if ( v92 != qword_4422F8[v106] )
      {
        if ( v92 == *(_QWORD *)(v101 + 32) )
          *(_QWORD *)(v101 + 32) = v97;
        else
          *(_QWORD *)(v101 + 40) = v97;
        if ( !v97 )
          goto LABEL_209;
LABEL_199:
        v108 = *(_QWORD *)(v92 + 32);
        v97[6] = v101;
        if ( v108 )
        {
          v97[4] = v108;
          *(_QWORD *)(v108 + 48) = v97;
        }
        v109 = *(_QWORD *)(v92 + 40);
        if ( v109 )
        {
          v97[5] = v109;
          *(_QWORD *)(v109 + 48) = v97;
        }
        goto LABEL_209;
      }
      qword_4420A8[v106 + 74] = (__int64)v97;
      if ( v97 )
        goto LABEL_199;
      dword_4420A4 &= __ROL4__(-2, v107);
    }
LABEL_209:
    v92 += v98;
    v94 += v98;
    goto LABEL_210;
  }
  return 0LL;
}
// 4038E3: variable 'v126' is possibly undefined
// 403906: variable 'v124' is possibly undefined
// 403931: variable 'v125' is possibly undefined
// 4420A0: using guessed type int dword_4420A0;
// 4420A4: using guessed type int dword_4420A4;
// 4420A8: using guessed type __int64 qword_4420A8[];
// 4420B0: using guessed type __int64 qword_4420B0;
// 4420B8: using guessed type __int64 qword_4420B8;
// 4420C0: using guessed type __int64 qword_4420C0;
// 4420C8: using guessed type __int64 qword_4420C8;
// 4420D8: using guessed type __int64 qword_4420D8;
// 4420E0: using guessed type __int64 qword_4420E0;
// 4422F8: using guessed type __int64 qword_4422F8[32];
// 4423F8: using guessed type __int64 qword_4423F8;
// 442400: using guessed type __int64 qword_442400;
// 442408: using guessed type __int64 qword_442408;
// 442410: using guessed type int dword_442410;
// 442418: using guessed type __int64 qword_442418;
// 442420: using guessed type __int64 qword_442420;
// 442428: using guessed type __int64 qword_442428;
// 442430: using guessed type int dword_442430;
// 442460: using guessed type __int64 qword_442460;
// 442470: using guessed type __int64 qword_442470;
// 442478: using guessed type __int64 qword_442478;

//----- (0000000000403AE8) ----------------------------------------------------
void __fastcall sub_403AE8(__int64 a1)
{
  __int64 v2; // rdi
  __int64 v3; // rcx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // r8
  __int64 v7; // rbx
  _QWORD *v8; // rdx
  unsigned __int64 v9; // rcx
  _QWORD *v10; // r8
  __int64 v11; // r8
  __int64 v12; // rcx
  _QWORD *v13; // r9
  _QWORD *v14; // rcx
  _QWORD *v15; // r10
  __int64 v16; // r9
  int v17; // ecx
  __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 v21; // r8
  __int64 v22; // r10
  unsigned __int64 v23; // rax
  __int64 v24; // rax
  unsigned __int64 v25; // r8
  _QWORD *v26; // rdx
  _QWORD *v27; // rsi
  __int64 v28; // r8
  __int64 v29; // rcx
  _QWORD *v30; // r9
  _QWORD *v31; // rcx
  _QWORD *v32; // r11
  __int64 v33; // r9
  int v34; // ecx
  __int64 v35; // rcx
  __int64 v36; // rcx
  unsigned __int64 v37; // rcx
  char *v38; // rax
  char *v39; // rdx
  unsigned __int64 v40; // rsi
  unsigned int v41; // edx
  int v42; // esi
  char v43; // cl
  __int64 v44; // rsi
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // rdx
  __int64 v47; // rdx
  __int64 v48; // rax

  if ( !a1 )
    return;
  v2 = a1 - 16;
  v3 = *(_QWORD *)(a1 - 8);
  v4 = v3 & 0xFFFFFFFFFFFFFFF8LL;
  v5 = v2 + (v3 & 0xFFFFFFFFFFFFFFF8LL);
  if ( (v3 & 1) != 0 )
    goto LABEL_35;
  v6 = *(_QWORD *)(a1 - 16);
  v2 -= v6;
  if ( (v3 & 3) == 0 )
  {
    v7 = v4 + v6 + 32;
    if ( !(unsigned int)sub_40452C(v2, v7) )
      qword_4423F8 -= v7;
    return;
  }
  v4 += v6;
  if ( qword_4420C0 == v2 )
  {
    v20 = *(_QWORD *)(v5 + 8);
    if ( (v20 & 3) == 3 )
    {
      qword_4420A8[0] = v4;
      *(_QWORD *)(v5 + 8) = v20 & 0xFFFFFFFFFFFFFFFELL;
      *(_QWORD *)(v2 + 8) = v4 | 1;
      *(_QWORD *)v5 = v4;
      return;
    }
    goto LABEL_35;
  }
  v8 = *(_QWORD **)(v2 + 24);
  v9 = v6 >> 3;
  if ( v6 <= 0xFF )
  {
    v10 = *(_QWORD **)(v2 + 16);
    if ( v10 == v8 )
    {
      dword_4420A0 &= __ROL4__(-2, v9);
    }
    else
    {
      v10[3] = v8;
      v8[2] = v10;
    }
    goto LABEL_35;
  }
  v11 = *(_QWORD *)(v2 + 48);
  if ( (_QWORD *)v2 == v8 )
  {
    v8 = *(_QWORD **)(v2 + 40);
    v13 = (_QWORD *)(v2 + 40);
    if ( !v8 )
    {
      v8 = *(_QWORD **)(v2 + 32);
      if ( !v8 )
        goto LABEL_20;
      v13 = (_QWORD *)(v2 + 32);
    }
    v14 = v8;
    do
    {
      do
      {
        v15 = v13;
        v8 = v14;
        v13 = v14 + 5;
        v14 = (_QWORD *)v14[5];
      }
      while ( v14 );
      v14 = (_QWORD *)v8[4];
      v13 = v8 + 4;
    }
    while ( v14 );
    *v15 = 0LL;
    goto LABEL_20;
  }
  v12 = *(_QWORD *)(v2 + 16);
  *(_QWORD *)(v12 + 24) = v8;
  v8[2] = v12;
LABEL_20:
  if ( !v11 )
    goto LABEL_35;
  v16 = *(unsigned int *)(v2 + 56);
  v17 = *(_DWORD *)(v2 + 56);
  if ( qword_4422F8[v16] == v2 )
  {
    qword_4420A8[v16 + 74] = (__int64)v8;
    if ( !v8 )
    {
      dword_4420A4 &= __ROL4__(-2, v17);
      goto LABEL_35;
    }
  }
  else
  {
    if ( *(_QWORD *)(v11 + 32) == v2 )
      *(_QWORD *)(v11 + 32) = v8;
    else
      *(_QWORD *)(v11 + 40) = v8;
    if ( !v8 )
      goto LABEL_35;
  }
  v18 = *(_QWORD *)(v2 + 32);
  v8[6] = v11;
  if ( v18 )
  {
    v8[4] = v18;
    *(_QWORD *)(v18 + 48) = v8;
  }
  v19 = *(_QWORD *)(v2 + 40);
  if ( v19 )
  {
    v8[5] = v19;
    *(_QWORD *)(v19 + 48) = v8;
  }
LABEL_35:
  v21 = *(_QWORD *)(v5 + 8);
  if ( (v21 & 2) == 0 )
  {
    v22 = qword_4420C0;
    if ( qword_4420C8 == v5 )
    {
      v23 = qword_4420B0 + v4;
      qword_4420C8 = v2;
      qword_4420B0 = v23;
      *(_QWORD *)(v2 + 8) = v23 | 1;
      if ( v2 == v22 )
      {
        qword_4420C0 = 0LL;
        qword_4420A8[0] = 0LL;
      }
      if ( v23 > qword_4420D0 )
        sub_4025AC(&dword_4420A0, 0LL);
      return;
    }
    if ( v5 == qword_4420C0 )
    {
      v24 = qword_4420A8[0] + v4;
      qword_4420C0 = v2;
      qword_4420A8[0] = v24;
      *(_QWORD *)(v2 + 8) = v24 | 1;
      *(_QWORD *)(v2 + v24) = v24;
      return;
    }
    v25 = v21 & 0xFFFFFFFFFFFFFFF8LL;
    v26 = *(_QWORD **)(v5 + 24);
    v4 += v25;
    if ( v25 <= 0xF8 )
    {
      v27 = *(_QWORD **)(v5 + 16);
      if ( v27 == v26 )
      {
        dword_4420A0 &= __ROL4__(-2, v25 >> 3);
      }
      else
      {
        v27[3] = v26;
        v26[2] = v27;
      }
      goto LABEL_69;
    }
    v28 = *(_QWORD *)(v5 + 48);
    if ( (_QWORD *)v5 != v26 )
    {
      v29 = *(_QWORD *)(v5 + 16);
      *(_QWORD *)(v29 + 24) = v26;
      v26[2] = v29;
      goto LABEL_56;
    }
    v26 = *(_QWORD **)(v5 + 40);
    v30 = (_QWORD *)(v5 + 40);
    if ( !v26 )
    {
      v26 = *(_QWORD **)(v5 + 32);
      if ( !v26 )
        goto LABEL_56;
      v30 = (_QWORD *)(v5 + 32);
    }
    v31 = v26;
    do
    {
      do
      {
        v32 = v30;
        v26 = v31;
        v30 = v31 + 5;
        v31 = (_QWORD *)v31[5];
      }
      while ( v31 );
      v31 = (_QWORD *)v26[4];
      v30 = v26 + 4;
    }
    while ( v31 );
    *v32 = 0LL;
LABEL_56:
    if ( !v28 )
      goto LABEL_69;
    v33 = *(unsigned int *)(v5 + 56);
    v34 = *(_DWORD *)(v5 + 56);
    if ( qword_4422F8[v33] == v5 )
    {
      qword_4420A8[v33 + 74] = (__int64)v26;
      if ( !v26 )
      {
        dword_4420A4 &= __ROL4__(-2, v34);
        goto LABEL_69;
      }
    }
    else
    {
      if ( *(_QWORD *)(v28 + 32) == v5 )
        *(_QWORD *)(v28 + 32) = v26;
      else
        *(_QWORD *)(v28 + 40) = v26;
      if ( !v26 )
        goto LABEL_69;
    }
    v35 = *(_QWORD *)(v5 + 32);
    v26[6] = v28;
    if ( v35 )
    {
      v26[4] = v35;
      *(_QWORD *)(v35 + 48) = v26;
    }
    v36 = *(_QWORD *)(v5 + 40);
    if ( v36 )
    {
      v26[5] = v36;
      *(_QWORD *)(v36 + 48) = v26;
    }
LABEL_69:
    *(_QWORD *)(v2 + 8) = v4 | 1;
    *(_QWORD *)(v2 + v4) = v4;
    if ( v2 == v22 )
    {
      qword_4420A8[0] = v4;
      return;
    }
    goto LABEL_72;
  }
  *(_QWORD *)(v5 + 8) = v21 & 0xFFFFFFFFFFFFFFFELL;
  *(_QWORD *)(v2 + 8) = v4 | 1;
  *(_QWORD *)(v2 + v4) = v4;
LABEL_72:
  v37 = v4 >> 3;
  if ( v4 > 0xFF )
  {
    v40 = v4 >> 8;
    v41 = v4 >> 8;
    if ( v41 )
    {
      v41 = 31;
      if ( (unsigned int)v40 <= 0xFFFF )
      {
        _BitScanReverse((unsigned int *)&v40, v40);
        v41 = ((v4 >> (38 - ((unsigned __int8)v40 ^ 0x1Fu))) & 1) + 2 * (31 - (v40 ^ 0x1F));
      }
    }
    v42 = dword_4420A4;
    *(_DWORD *)(v2 + 56) = v41;
    *(_QWORD *)(v2 + 40) = 0LL;
    *(_QWORD *)(v2 + 32) = 0LL;
    if ( ((1 << v41) & v42) != 0 )
    {
      v43 = 0;
      v44 = qword_4422F8[v41];
      if ( v41 != 31 )
        v43 = 57 - (v41 >> 1);
      v45 = v4 << v43;
      while ( (*(_QWORD *)(v44 + 8) & 0xFFFFFFFFFFFFFFF8LL) != v4 )
      {
        v46 = v45;
        v45 *= 2LL;
        v47 = (v46 >> 63) + 4;
        if ( !*(_QWORD *)(v44 + 8 * v47) )
        {
          *(_QWORD *)(v44 + 8 * v47) = v2;
          *(_QWORD *)(v2 + 48) = v44;
          goto LABEL_89;
        }
        v44 = *(_QWORD *)(v44 + 8 * v47);
      }
      v48 = *(_QWORD *)(v44 + 16);
      *(_QWORD *)(v48 + 24) = v2;
      *(_QWORD *)(v44 + 16) = v2;
      *(_QWORD *)(v2 + 16) = v48;
      *(_QWORD *)(v2 + 24) = v44;
      *(_QWORD *)(v2 + 48) = 0LL;
    }
    else
    {
      qword_4422F8[v41] = v2;
      dword_4420A4 = (1 << v41) | v42;
      *(_QWORD *)(v2 + 48) = &qword_4422F8[v41];
LABEL_89:
      *(_QWORD *)(v2 + 24) = v2;
      *(_QWORD *)(v2 + 16) = v2;
    }
    if ( !--qword_4420D8 )
      sub_4022EF((__int64)&dword_4420A0);
  }
  else
  {
    v38 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v37);
    if ( ((1 << v37) & dword_4420A0) != 0 )
    {
      v39 = (char *)*((_QWORD *)v38 + 2);
    }
    else
    {
      dword_4420A0 |= 1 << v37;
      v39 = (char *)&unk_4420E8 + 8 * (unsigned int)(2 * v37);
    }
    *((_QWORD *)v38 + 2) = v2;
    *((_QWORD *)v39 + 3) = v2;
    *(_QWORD *)(v2 + 16) = v39;
    *(_QWORD *)(v2 + 24) = v38;
  }
}
// 4420A0: using guessed type int dword_4420A0;
// 4420A4: using guessed type int dword_4420A4;
// 4420A8: using guessed type __int64 qword_4420A8[];
// 4420B0: using guessed type __int64 qword_4420B0;
// 4420C0: using guessed type __int64 qword_4420C0;
// 4420C8: using guessed type __int64 qword_4420C8;
// 4420D0: using guessed type __int64 qword_4420D0;
// 4420D8: using guessed type __int64 qword_4420D8;
// 4422F8: using guessed type __int64 qword_4422F8[32];
// 4423F8: using guessed type __int64 qword_4423F8;

//----- (0000000000403FED) ----------------------------------------------------
void __fastcall sub_403FED(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rax

  v2 = 0LL;
  if ( a1 )
  {
    v2 = a2 * a1;
    if ( ((a2 | a1) & 0xFFFFFFFFFFFF0000LL) != 0 && a2 != v2 / a1 )
      v2 = -1LL;
  }
  v3 = sub_402B64(v2);
  if ( v3 )
  {
    if ( (*(_BYTE *)(v3 - 8) & 3) != 0 )
      sub_4050B2(v3, 0LL, v2);
  }
}

//----- (0000000000404049) ----------------------------------------------------
__int64 *__fastcall sub_404049(__int64 a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 *v3; // r13
  __int64 v6; // rsi
  unsigned __int64 v7; // rdx
  __int64 v8; // r14
  __int64 v9; // rbx
  __int64 v10; // r15
  unsigned __int64 v11; // rax
  __int64 v12; // rdx
  bool v13; // cf
  unsigned __int64 v14; // rbx
  bool v15; // cc
  char *v16; // r9
  unsigned __int64 v17; // rdx
  char *v18; // r8
  __int64 v19; // rdi
  __int64 v20; // rsi
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  __int64 v23; // rsi
  unsigned __int64 *v24; // rax
  unsigned __int64 v25; // r8
  __int64 v26; // r10
  unsigned __int64 v27; // r10
  unsigned __int64 v28; // r8
  char *v29; // rax
  unsigned __int64 v30; // r11
  char *v31; // rdx
  __int64 v32; // r10
  __int64 v33; // rdx
  _QWORD *v34; // rcx
  char *v35; // rdx
  _QWORD *v36; // rbx
  __int64 v37; // rcx
  __int64 v38; // rdx
  __int64 v39; // rdx
  __int64 v40; // rdx
  __int64 v41; // rsi
  char *v42; // rax
  __int64 v43; // rdx

  v3 = a2;
  v6 = a2[1];
  v7 = v6 & 0xFFFFFFFFFFFFFFF8LL;
  if ( (v6 & 3) != 0 )
  {
    v16 = (char *)v3 + v7;
    if ( v7 >= a3 )
    {
      v17 = v7 - a3;
      if ( v17 <= 0x1F )
        return v3;
      v18 = (char *)v3 + a3;
      v19 = v6 & 1 | a3 | 2;
      v20 = (__int64)v18;
      v3[1] = v19;
      *((_QWORD *)v18 + 1) = v17 | 3;
      *((_QWORD *)v16 + 1) |= 1uLL;
LABEL_53:
      sub_4026E8(a1, v20, v17);
      return v3;
    }
    if ( *(char **)(a1 + 40) == v16 )
    {
      v21 = *(_QWORD *)(a1 + 16) + v7;
      if ( v21 > a3 )
      {
        v3[1] = a3 | v6 & 1 | 2;
        *(__int64 *)((char *)v3 + a3 + 8) = (v21 - a3) | 1;
        *(_QWORD *)(a1 + 40) = (char *)v3 + a3;
        *(_QWORD *)(a1 + 16) = v21 - a3;
        return v3;
      }
      return 0LL;
    }
    if ( *(char **)(a1 + 32) == v16 )
    {
      v22 = v7 + *(_QWORD *)(a1 + 8);
      if ( v22 < a3 )
        return 0LL;
      v23 = v6 & 1;
      v24 = (unsigned __int64 *)((char *)v3 + v22);
      v25 = v22 - a3;
      if ( v22 - a3 <= 0x1F )
      {
        v3[1] = v23 | v22 | 2;
        v24[1] |= 1uLL;
        *(_QWORD *)(a1 + 8) = 0LL;
        *(_QWORD *)(a1 + 32) = 0LL;
      }
      else
      {
        v3[1] = a3 | v23 | 2;
        *(__int64 *)((char *)v3 + a3 + 8) = v25 | 1;
        *v24 = v25;
        v24[1] &= ~1uLL;
        *(_QWORD *)(a1 + 8) = v25;
        *(_QWORD *)(a1 + 32) = (char *)v3 + a3;
      }
      return v3;
    }
    v26 = *((_QWORD *)v16 + 1);
    if ( (v26 & 2) != 0 )
      return 0LL;
    v27 = v26 & 0xFFFFFFFFFFFFFFF8LL;
    v28 = v7 + v27;
    if ( v7 + v27 < a3 )
      return 0LL;
    v29 = (char *)*((_QWORD *)v16 + 3);
    v30 = v28 - a3;
    if ( v27 <= 0xF8 )
    {
      v31 = (char *)*((_QWORD *)v16 + 2);
      if ( v31 == v29 )
      {
        *(_DWORD *)a1 &= __ROL4__(-2, v27 >> 3);
      }
      else
      {
        *((_QWORD *)v31 + 3) = v29;
        *((_QWORD *)v29 + 2) = v31;
      }
      goto LABEL_50;
    }
    v32 = *((_QWORD *)v16 + 6);
    if ( v16 != v29 )
    {
      v33 = *((_QWORD *)v16 + 2);
      *(_QWORD *)(v33 + 24) = v29;
      *((_QWORD *)v29 + 2) = v33;
      goto LABEL_37;
    }
    v29 = (char *)*((_QWORD *)v16 + 5);
    v34 = v16 + 40;
    if ( !v29 )
    {
      v29 = (char *)*((_QWORD *)v16 + 4);
      if ( !v29 )
        goto LABEL_37;
      v34 = v16 + 32;
    }
    v35 = v29;
    do
    {
      do
      {
        v36 = v34;
        v29 = v35;
        v34 = v35 + 40;
        v35 = (char *)*((_QWORD *)v35 + 5);
      }
      while ( v35 );
      v35 = (char *)*((_QWORD *)v29 + 4);
      v34 = v29 + 32;
    }
    while ( v35 );
    *v36 = 0LL;
LABEL_37:
    if ( v32 )
    {
      v37 = *((unsigned int *)v16 + 14);
      v38 = a1 + 8 * v37;
      if ( *(char **)(v38 + 600) != v16 )
      {
        if ( *(char **)(v32 + 32) == v16 )
          *(_QWORD *)(v32 + 32) = v29;
        else
          *(_QWORD *)(v32 + 40) = v29;
        if ( !v29 )
          goto LABEL_50;
LABEL_40:
        v39 = *((_QWORD *)v16 + 4);
        *((_QWORD *)v29 + 6) = v32;
        if ( v39 )
        {
          *((_QWORD *)v29 + 4) = v39;
          *(_QWORD *)(v39 + 48) = v29;
        }
        v40 = *((_QWORD *)v16 + 5);
        if ( v40 )
        {
          *((_QWORD *)v29 + 5) = v40;
          *(_QWORD *)(v40 + 48) = v29;
        }
        goto LABEL_50;
      }
      *(_QWORD *)(v38 + 600) = v29;
      if ( v29 )
        goto LABEL_40;
      *(_DWORD *)(a1 + 4) &= __ROL4__(-2, v37);
    }
LABEL_50:
    v41 = v6 & 1;
    v42 = (char *)v3 + v28;
    v43 = v41;
    if ( v30 <= 0x1F )
    {
      v3[1] = v28 | v41 | 2;
      *((_QWORD *)v42 + 1) |= 1uLL;
      return v3;
    }
    v20 = (__int64)v3 + a3;
    v3[1] = a3 | v43 | 2;
    *(__int64 *)((char *)v3 + a3 + 8) = v30 | 3;
    *((_QWORD *)v42 + 1) |= 1uLL;
    v17 = v28 - a3;
    goto LABEL_53;
  }
  if ( a3 <= 0xFF )
    return 0LL;
  if ( v7 < a3 + 8 || v7 - a3 > 2 * qword_442470 )
  {
    v8 = *v3;
    v9 = -qword_442470 & (qword_442470 + a3 + 62);
    v10 = v7 + *v3 + 32;
    v11 = sub_404ABB();
    if ( v11 == -1LL )
      return 0LL;
    v3 = (__int64 *)(v11 + v8);
    v12 = v9 - v8;
    v13 = v11 < *(_QWORD *)(a1 + 24);
    v3[1] = v9 - v8 - 32;
    *(__int64 *)((char *)v3 + v12 - 24) = 11LL;
    *(__int64 *)((char *)v3 + v12 - 16) = 0LL;
    if ( v13 )
      *(_QWORD *)(a1 + 24) = v11;
    v14 = *(_QWORD *)(a1 + 856) + v9 - v10;
    v15 = v14 <= *(_QWORD *)(a1 + 864);
    *(_QWORD *)(a1 + 856) = v14;
    if ( !v15 )
      *(_QWORD *)(a1 + 864) = v14;
  }
  return v3;
}
// 442470: using guessed type __int64 qword_442470;

//----- (00000000004043D8) ----------------------------------------------------
__int64 *__fastcall sub_4043D8(__int64 a1, unsigned __int64 a2)
{
  __int64 *result; // rax
  unsigned __int64 v3; // rdx
  __int64 *v4; // rax
  unsigned __int64 v5; // rdx
  __int64 v6; // [rsp+8h] [rbp-18h]

  if ( !a1 )
    return (__int64 *)sub_402B64(a2);
  if ( a2 > 0xFFFFFFFFFFFFFF7FLL )
  {
    sub_4018E7();
    return 0LL;
  }
  if ( !a2 )
  {
    sub_403AE8(a1);
    return 0LL;
  }
  v3 = 32LL;
  if ( a2 > 0xE )
    v3 = (a2 + 31) & 0xFFFFFFFFFFFFFFF0LL;
  v4 = sub_404049((__int64)&dword_4420A0, (__int64 *)(a1 - 16), v3);
  if ( v4 )
    return v4 + 2;
  result = (__int64 *)sub_402B64(a2);
  if ( result )
  {
    v6 = (__int64)result;
    v5 = (*(_QWORD *)(a1 - 8) & 0xFFFFFFFFFFFFFFF8LL) - 16;
    if ( v5 > a2 )
      v5 = a2;
    sub_404F70((__int64)result, a1, v5);
    sub_403AE8(a1);
    return (__int64 *)v6;
  }
  return result;
}
// 4420A0: using guessed type int dword_4420A0;

//----- (0000000000404491) ----------------------------------------------------
void __fastcall sub_404491(__int64 a1, __int64 a2)
{
  unsigned int v2; // eax
  __int64 v3; // rdx

  if ( !qword_442460 )
  {
    v2 = 0x10000;
    if ( (unsigned int)dword_443C68 >= 0x10000 )
      v2 = dword_443C68;
    v3 = v2 - 1LL;
    if ( (v2 & (unsigned int)v3) != 0 )
      sub_401000(a1, a2, v3);
    qword_442470 = v2;
    qword_442468 = 4096LL;
    qword_442478 = 0x40000LL;
    qword_442480 = 10485760LL;
    dword_442488 = 5;
    dword_442410 = 5;
    qword_442460 = qword_440000 & 0xFFFFFFFFFFFFFFF0LL | 8;
  }
}
// 440000: using guessed type __int64 qword_440000;
// 442410: using guessed type int dword_442410;
// 442460: using guessed type __int64 qword_442460;
// 442468: using guessed type __int64 qword_442468;
// 442470: using guessed type __int64 qword_442470;
// 442478: using guessed type __int64 qword_442478;
// 442480: using guessed type __int64 qword_442480;
// 442488: using guessed type int dword_442488;
// 443C68: using guessed type int dword_443C68;

//----- (0000000000404518) ----------------------------------------------------
__int64 __fastcall sub_404518(__int64 a1)
{
  return sub_40481D(a1);
}

//----- (000000000040452C) ----------------------------------------------------
__int64 __fastcall sub_40452C(__int64 a1, __int64 a2)
{
  return sub_404AC1(a1, a2);
}

//----- (0000000000404540) ----------------------------------------------------
__int64 __fastcall sub_404540(__int64 a1, __int64 a2, __int64 a3)
{
  _DWORD *v4; // rbx
  __int64 v5; // rax
  __int64 result; // rax
  unsigned int v7; // eax
  _QWORD *v8; // rbx

  v4 = (_DWORD *)qword_4424A0;
  if ( !qword_4424A0 )
  {
    qword_4424A0 = (__int64)&unk_4424A8;
    v4 = &unk_4424A8;
  }
  if ( *v4 == -1 )
  {
    if ( !sub_402296 )
      return sub_4018E7();
    v5 = sub_402296(1LL, 784LL);
    if ( !v5 )
      return sub_4018E7();
    *(_QWORD *)(v5 + 8) = v4;
    qword_4424A0 = v5;
    v4 = (_DWORD *)v5;
  }
  _BitScanReverse(&v7, ~*v4);
  *v4 |= 1 << v7;
  v8 = &v4[6 * v7];
  result = 0LL;
  v8[2] = a1;
  v8[3] = a2;
  v8[4] = a3;
  return result;
}
// 402296: using guessed type __int64 __fastcall sub_402296(_QWORD, _QWORD);
// 4424A0: using guessed type __int64 qword_4424A0;

//----- (00000000004045D5) ----------------------------------------------------
__int64 __fastcall sub_4045D5(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned int *v4; // rdi
  __int64 v5; // rax
  int v6; // ecx
  __int64 v7; // rdx
  unsigned int *v8; // rcx
  void (__fastcall *v9)(_QWORD); // rdx
  __int64 v10; // r13

LABEL_1:
  while ( 1 )
  {
    v4 = (unsigned int *)qword_4424A0;
    if ( !qword_4424A0 )
      return a3;
    while ( 1 )
    {
      v5 = *v4;
      while ( v5 )
      {
        _BitScanForward((unsigned int *)&v6, v5);
        v7 = (unsigned int)~(1 << v6);
        v5 &= v7;
        if ( !a1 || *(_QWORD *)&v4[6 * v6 + 8] == a1 )
        {
          *v4 &= v7;
          v8 = &v4[6 * v6];
          v9 = (void (__fastcall *)(_QWORD))*((_QWORD *)v8 + 2);
          if ( v9 )
          {
            v9(*((_QWORD *)v8 + 3));
            goto LABEL_1;
          }
        }
      }
      v10 = *((_QWORD *)v4 + 1);
      if ( !a1 )
        break;
      if ( !v10 )
        return a3;
      v4 = (unsigned int *)*((_QWORD *)v4 + 1);
    }
    if ( v10 && sub_40229C )
      sub_40229C();
    qword_4424A0 = v10;
  }
}
// 40229C: using guessed type __int64 sub_40229C(void);
// 4424A0: using guessed type __int64 qword_4424A0;

//----- (000000000040466A) ----------------------------------------------------
char __fastcall sub_40466A(__int64 *a1, unsigned __int64 *a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v4; // r15
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // r14
  __int64 v15; // rax
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // rcx
  __int64 v18; // rax
  unsigned __int64 v20; // [rsp+0h] [rbp-40h]

  v4 = 0LL;
  sub_4047B0(*a1);
  if ( sub_4047B0(*a1) )
    v4 = *a1;
  v10 = *a2;
  if ( *a1 )
  {
    v11 = v10 + (v10 >> 1);
  }
  else
  {
    v11 = 4LL;
    v9 = 0x1F % a3;
    if ( 0x1F / a3 >= 4 )
      v11 = 0x1F / a3;
  }
  if ( v10 )
  {
    v12 = v10 * a3;
    if ( ((v10 | a3) & 0xFFFFFFFFFFFF0000LL) != 0 )
    {
      v9 = v12 % v10;
      if ( a3 != v12 / v10 )
        goto LABEL_24;
    }
  }
  else
  {
    v12 = 0LL;
  }
  v13 = v11 + a4 + 1;
  if ( v11 + a4 == -1LL )
  {
    v14 = 0LL;
    goto LABEL_17;
  }
  v14 = v13 * a3;
  if ( ((v13 | a3) & 0xFFFFFFFFFFFF0000LL) != 0 )
  {
    v9 = v14 % v13;
    if ( a3 != v14 / v13 )
    {
LABEL_24:
      sub_401907();
      return 0;
    }
  }
LABEL_17:
  v20 = v12;
  if ( !sub_4022A2 || (v15 = sub_4022A2(v4, (v14 + 31) & 0xFFFFFFFFFFFFFFE0LL, v9)) == 0 )
  {
    sub_4018E7();
    return 0;
  }
  v16 = v20;
  if ( !v4 )
  {
    if ( *a1 )
      sub_404F70(v15, *a1, v20);
  }
  sub_4050B2(v15 + v16, 0LL, v14 - v16);
  *a2 = v17;
  *a1 = v18;
  return 1;
}
// 40474E: variable 'v9' is possibly undefined
// 404779: variable 'v15' is possibly undefined
// 404779: variable 'v16' is possibly undefined
// 404787: variable 'v17' is possibly undefined
// 40478B: variable 'v18' is possibly undefined
// 4022A2: using guessed type __int64 __fastcall sub_4022A2(_QWORD, _QWORD, _QWORD);

//----- (00000000004047B0) ----------------------------------------------------
_BOOL8 __fastcall sub_4047B0(__int64 a1)
{
  __int64 v1; // rbx
  __int64 v2; // rdx
  _BOOL8 result; // rax
  bool v4; // al

  if ( (unsigned __int64)(a1 - 0x600000000000LL) <= 0xFFFFFFFFFFFLL )
    return 0LL;
  v1 = a1 >> 16;
  v2 = sub_404C04(a1 >> 16, (__int64)dword_4427C8, qword_4427C0[0]);
  result = 0LL;
  if ( v2 )
  {
    v4 = 1;
    if ( LODWORD(qword_4427C0[v2]) != (_DWORD)v1 )
      return dword_4427CC[2 * v2 - 2] == (_DWORD)v1;
    return v4;
  }
  return result;
}
// 4427C0: using guessed type __int64 qword_4427C0[];
// 4427C8: using guessed type int dword_4427C8[];
// 4427CC: using guessed type int dword_4427CC[595];

//----- (000000000040481D) ----------------------------------------------------
__int64 __fastcall sub_40481D(__int64 a1)
{
  __int64 v1; // r15
  int v2; // er13
  int v3; // er14
  unsigned __int64 v4; // rbx
  __int64 v5; // rax
  int v6; // esi
  __int64 v7; // rdi
  __int64 v8; // r12
  int v9; // er13
  __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // r14
  __int64 v13; // rsi
  __int64 v14; // r13
  unsigned __int64 v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rax

  v1 = 0LL;
  v2 = dword_440730 | qword_440728 | 2;
  v3 = dword_440668 & 4;
  v4 = a1 + 0xFFFF;
  LOWORD(v4) = 0;
  if ( (((unsigned __int8)dword_440730 | (unsigned __int8)qword_440728) & 0x10) == 0 )
  {
    v5 = qword_4427C0[0];
    v1 = 0x200000000000LL;
    if ( qword_4427C0[0] )
    {
      do
      {
        --v5;
        v6 = dword_4427CC[2 * v5];
        v7 = v6 + 1;
        if ( v7 + (v4 >> 16) <= 0x30000000 && v6 > 536870910 )
        {
          v1 = v7 << 16;
          goto LABEL_8;
        }
      }
      while ( v5 );
      v1 = (__int64)(HIDWORD(qword_4427C0[qword_4427C0[0]]) + 1) << 16;
    }
LABEL_8:
    LOWORD(v1) = 0;
  }
  if ( qword_4427C0[0] == 300 )
    return sub_4018E7();
  if ( (((unsigned __int8)dword_440730 | (unsigned __int8)qword_440728) & 0x10) != 0 )
    sub_40452C(v1, v4);
  else
    sub_404C04(((v4 + 0xFFFF) >> 16) + (v1 >> 16) - 1, (__int64)dword_4427C8, qword_4427C0[0]);
  v9 = v2 | 0x10;
  if ( v3 )
  {
    v11 = (unsigned int)sub_40524A(3, v9);
    v12 = sub_401E9A(-1LL, (__int64)qword_405320, v11, HIDWORD(v4));
    if ( v12 )
    {
      v13 = (unsigned int)sub_404C31(3, v9);
      v8 = sub_401EDF(v12, v13, 0LL, 0LL);
      if ( v8 )
        goto LABEL_21;
      sub_401E81(v12, v13, -1LL);
    }
    v10 = sub_4052D6();
  }
  else
  {
    v10 = sub_404C24();
  }
  v8 = v10;
  v12 = -1LL;
LABEL_21:
  if ( v8 != -1 )
  {
    v14 = v8 >> 16;
    v15 = sub_404C04(v8 >> 16, (__int64)dword_4427C8, qword_4427C0[0]);
    if ( qword_4427C0[0] > v15 )
    {
      sub_405092(&qword_4427C0[v15 + 2], (_BYTE *)&unk_4427B8 + 8 * v15 + 16, 8 * (qword_4427C0[0] - v15));
      sub_405092(&byte_443120[v16], &byte_443118[v16], 8 * (qword_4427C0[0] - v17));
    }
    ++qword_4427C0[0];
    dword_4427C8[2 * v15] = v14;
    qword_443128[v15] = v12;
    dword_4427CC[2 * v15] = ((v4 + 0xFFFF) >> 16) + v14 - 1;
  }
  return v8;
}
// 404878: conditional instruction was optimized away because er12.4==FFFFFFFF
// 404896: conditional instruction was optimized away because rdi.8==0
// 40498D: conditional instruction was optimized away because er12.4==FFFFFFFF
// 404A61: variable 'v16' is possibly undefined
// 404A6F: variable 'v17' is possibly undefined
// 404A89: variable 'v15' is possibly undefined
// 405320: using guessed type __int64 qword_405320[2];
// 440668: using guessed type int dword_440668;
// 440728: using guessed type __int64 qword_440728;
// 440730: using guessed type int dword_440730;
// 4427C0: using guessed type __int64 qword_4427C0[];
// 4427C8: using guessed type int dword_4427C8[];
// 4427CC: using guessed type int dword_4427CC[595];
// 443118: using guessed type _BYTE byte_443118[8];
// 443120: using guessed type _BYTE byte_443120[8];
// 443128: using guessed type __int64 qword_443128[303];
// 443AB0: using guessed type __int64 qword_443AB0;

//----- (0000000000404ABB) ----------------------------------------------------
// attributes: thunk
__int64 sub_404ABB()
{
  return sub_4018F7();
}

//----- (0000000000404AC1) ----------------------------------------------------
__int64 __fastcall sub_404AC1(__int64 a1, __int64 a2)
{
  int v2; // er12
  unsigned int v3; // er13
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // r14
  unsigned __int64 v6; // rbx
  __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8

  if ( (unsigned __int64)(a1 - 1) <= 0xFFFFFFFFFFFFFFFDLL && a2 )
  {
    v2 = a1 >> 16;
    v3 = 0;
    v4 = sub_404C04(
           v2 + (unsigned int)((unsigned __int64)(a2 + 0xFFFF) >> 16) - 1,
           (__int64)dword_4427C8,
           qword_4427C0[0]);
    v5 = v4;
    while ( v4 )
    {
      v6 = v4 - 1;
      v7 = (unsigned int)dword_4427CC[2 * v4 - 2];
      if ( v2 > (int)v7 )
        break;
      if ( (dword_440668 & 4) != 0 )
      {
        v8 = (unsigned int)dword_4427C8[2 * v4 - 2];
        if ( !(unsigned int)sub_401EF5((__int64)(int)v8 << 16, v7, v8) )
          v3 = -1;
        if ( !(unsigned int)sub_401E81(qword_443128[v6], v7, v9) )
          v3 = -1;
      }
      else
      {
        v3 |= sub_404DD0();
      }
      v4 = v6;
    }
    if ( v4 < v5 )
    {
      if ( qword_4427C0[0] > v5 )
      {
        sub_405092(&qword_4427C0[v4 + 1], &qword_4427C0[v5 + 1], 8 * (qword_4427C0[0] - v5));
        sub_405092(&byte_443120[v10], &byte_443120[v11], 8 * (qword_4427C0[0] - v5));
      }
      qword_4427C0[0] = qword_4427C0[0] + v4 - v5;
    }
  }
  else
  {
    return 0;
  }
  return v3;
}
// 404B6B: variable 'v9' is possibly undefined
// 404BC5: variable 'v10' is possibly undefined
// 404BCC: variable 'v11' is possibly undefined
// 404BDF: variable 'v4' is possibly undefined
// 440668: using guessed type int dword_440668;
// 4427C0: using guessed type __int64 qword_4427C0[];
// 4427C8: using guessed type int dword_4427C8[];
// 4427CC: using guessed type int dword_4427CC[595];
// 443120: using guessed type _BYTE byte_443120[8];
// 443128: using guessed type __int64 qword_443128[303];

//----- (0000000000404C04) ----------------------------------------------------
__int64 __fastcall sub_404C04(int a1, __int64 a2, int a3)
{
  __int64 result; // rax
  int v4; // ecx

  LODWORD(result) = 0;
  while ( a3 > (int)result )
  {
    v4 = (a3 + (int)result) >> 1;
    if ( *(_DWORD *)(a2 + 8LL * v4) > a1 )
      a3 = (a3 + (int)result) >> 1;
    else
      LODWORD(result) = v4 + 1;
  }
  return (int)result;
}

//----- (0000000000404C24) ----------------------------------------------------
__int64 sub_404C24()
{
  return sub_404DC0();
}

//----- (0000000000404C31) ----------------------------------------------------
__int64 __fastcall sub_404C31(char a1, int a2)
{
  return (8 * a1) & 0x20 | (4 * a1) & 4 | (32 * a2) & 0x80000000 | (a2 >> 2) & 0x20000000 | a1 & 2 | (a2 >> 1) & 1;
}

//----- (0000000000404C6C) ----------------------------------------------------
bool __fastcall sub_404C6C(int a1, int a2)
{
  bool result; // al

  result = 0;
  if ( a1 )
    return *(_DWORD *)(qword_443AB0 + 24LL * a1 + 16) == a2;
  return result;
}
// 443AB0: using guessed type __int64 qword_443AB0;

//----- (0000000000404C87) ----------------------------------------------------
__int64 __fastcall sub_404C87(int a1, __int64 a2, __int64 a3)
{
  __int64 v5; // [rsp+0h] [rbp-30h] BYREF
  __int64 v6; // [rsp+8h] [rbp-28h]

  if ( a1 == -1 )
    return (int)sub_4018D7();
  if ( sub_404C6C(a1, 5) )
  {
    v5 = a2;
    v6 = a3;
    return MEMORY[0](*(_QWORD *)(qword_443AB0 + 24LL * a1), &v5, 1LL, -1LL);
  }
  else if ( (dword_440668 & 4) != 0 )
  {
    if ( sub_404C6C(a1, 2) )
    {
      v5 = a2;
      v6 = a3;
      return MEMORY[0](qword_443AB0 + 24LL * a1, &v5, 1LL, 0LL, 0LL, 0LL);
    }
    else if ( sub_404C6C(a1, 1) || sub_404C6C(a1, 4) )
    {
      v5 = a2;
      v6 = a3;
      return sub_401DBA((_QWORD *)(qword_443AB0 + 24LL * a1), &v5, 1LL, -1LL);
    }
    else
    {
      return sub_4018C7();
    }
  }
  else
  {
    return sub_404DE0();
  }
}
// 440668: using guessed type int dword_440668;
// 443AB0: using guessed type __int64 qword_443AB0;

//----- (0000000000404DB0) ----------------------------------------------------
__int64 sub_404DB0()
{
  return qword_440670();
}
// 440670: using guessed type __int64 (*qword_440670)(void);

//----- (0000000000404DC0) ----------------------------------------------------
__int64 sub_404DC0()
{
  return qword_440670();
}
// 440670: using guessed type __int64 (*qword_440670)(void);

//----- (0000000000404DD0) ----------------------------------------------------
__int64 sub_404DD0()
{
  return qword_440670();
}
// 440670: using guessed type __int64 (*qword_440670)(void);

//----- (0000000000404DE0) ----------------------------------------------------
__int64 sub_404DE0()
{
  return qword_440670();
}
// 440670: using guessed type __int64 (*qword_440670)(void);

//----- (0000000000404DF0) ----------------------------------------------------
__int64 __fastcall sub_404DF0()
{
  __int16 v0; // ax
  __int64 result; // rax

  result = (unsigned int)v0;
  if ( (int)result < 0 )
  {
    dword_443C70 = dword_440700;
    return -1LL;
  }
  else
  {
    __asm { syscall; Low latency system call }
  }
  return result;
}
// 404E02: conditional instruction was optimized away because rax.8<80000000u
// 404DF0: variable 'v0' is possibly undefined
// 404DF0: using guessed type __int64 __fastcall sub_404DF0();
// 440700: using guessed type int dword_440700;
// 443C70: using guessed type int dword_443C70;

//----- (0000000000404E4D) ----------------------------------------------------
__int64 __fastcall sub_404E4D(__int64 a1, _DWORD *a2)
{
  return sub_404E8F(a1, a2);
}

//----- (0000000000404E5C) ----------------------------------------------------
__int64 __fastcall sub_404E5C(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rcx
  int v3; // ecx
  char v4; // dl

  a1 = (unsigned int)a1;
  v1 = 0LL;
  if ( (unsigned int)a1 > 0x7F )
  {
    _BitScanReverse((unsigned int *)&v2, a1);
    v3 = *(_DWORD *)&byte_405347[2 * v2 - 14];
    do
    {
      v4 = a1;
      a1 = (unsigned int)a1 >> 6;
      LOBYTE(v1) = v4 & 0x3F | v1 | 0x80;
      v1 <<= 8;
      LOBYTE(v3) = v3 - 1;
    }
    while ( (_BYTE)v3 );
    LOBYTE(v1) = BYTE1(v3) | v1;
  }
  return a1 | v1;
}
// 404E6F: variable 'v2' is possibly undefined

//----- (0000000000404E8F) ----------------------------------------------------
__int64 __fastcall sub_404E8F(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax
  __int64 v3; // rdx
  int v4; // ebx
  int v5; // edx
  int v6; // eax

  LODWORD(result) = 0;
  do
  {
    v3 = (unsigned int)result;
    v4 = result;
    result = (unsigned int)(result + 1);
    v5 = *(unsigned __int16 *)(a1 + 2 * v3);
  }
  while ( (v5 & 0xFC00) == 0xDC00 );
  if ( (v5 & 0xFC00) == 0xD800 )
  {
    v6 = *(unsigned __int16 *)(a1 + 2 * result);
    if ( (v6 & 0xFC00) == 0xDC00 )
    {
      *a2 = (v5 << 10) + v6 - 56613888;
      return (unsigned int)(v4 + 2);
    }
    else
    {
      *a2 = 65533;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    *a2 = v5;
  }
  return result;
}

//----- (0000000000404F70) ----------------------------------------------------
void __fastcall sub_404F70(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rcx

  v3 = 32LL;
  if ( a3 < 0x20 )
    v3 = a3;
  __asm { jmp     ds:qword_440448[rcx*8] }
}
// 404F7D: unbalanced stack, ignored a potential tail call

//----- (0000000000404F84) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_404F84(__m128i *_RDI, const __m128i *_RSI, unsigned __int64 _RDX)
{
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdi
  __int8 *v9; // rsi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rcx

  if ( _RDX >= 0x400 )
  {
    if ( _RDX > (unsigned __int64)&dword_400000 )
    {
      *_RDI = _mm_loadu_si128(_RSI);
      v7 = ((unsigned __int64)&_RDI[1] & 0xFFFFFFFFFFFFFFF0LL) - (_QWORD)_RDI;
      v8 = (unsigned __int64)&_RDI[1] & 0xFFFFFFFFFFFFFFF0LL;
      v9 = &_RSI->i8[v7];
      v10 = _RDX - v7;
      v11 = 16LL;
      do
      {
        v11 += 16LL;
        _mm_stream_si128((__m128i *)(v8 + v11 - 32), _mm_loadu_si128((const __m128i *)&v9[v11 - 32]));
      }
      while ( v10 > v11 );
      _mm_sfence();
      *(__m128i *)(v8 + v10 - 16) = _mm_loadu_si128((const __m128i *)&v9[v10 - 16]);
    }
    else
    {
      qmemcpy(_RDI, _RSI, _RDX);
    }
  }
  else
  {
    _RCX = 32LL;
    do
    {
      _RCX += 32LL;
      __asm
      {
        vmovdqu ymm3, ymmword ptr [rsi+rcx-40h]
        vmovdqu ymmword ptr [rdi+rcx-40h], ymm3
      }
    }
    while ( _RDX > _RCX );
    __asm
    {
      vmovdqu ymm3, ymmword ptr [rsi+rdx-20h]
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm3
      vpxor   ymm3, ymm3, ymm3
    }
  }
}
// 405009: positive sp value 8 has been found
// 400000: using guessed type int dword_400000;

//----- (0000000000405092) ----------------------------------------------------
void __fastcall sub_405092(_BYTE *a1, _BYTE *a2, __int64 a3)
{
  __int64 v3; // rcx

  v3 = a3;
  if ( a1 >= a2 )
  {
    a1 = &a1[a3 - 1];
    a2 = &a2[a3 - 1];
  }
  while ( v3 )
  {
    *a1-- = *a2--;
    --v3;
  }
}

//----- (00000000004050B2) ----------------------------------------------------
void __fastcall sub_4050B2(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rcx

  v3 = 32LL;
  if ( a3 < 0x20 )
    v3 = a3;
  __asm { jmp     qword ptr [rbx+rcx*8] }
}
// 4050C9: unbalanced stack, ignored a potential tail call

//----- (00000000004050CC) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_4050CC(void *_RDI, char a2, unsigned __int64 _RDX, double a4, double a5, double a6, __m128 _XMM3)
{
  if ( _RDX >= 0x400 )
  {
    memset(_RDI, a2, _RDX);
  }
  else
  {
    __asm { vpbroadcastb ymm3, xmm3 }
    _RCX = 32LL;
    do
    {
      _RCX += 32LL;
      __asm { vmovdqu ymmword ptr [rdi+rcx-40h], ymm3 }
    }
    while ( _RDX > _RCX );
    __asm
    {
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm3
      vxorps  ymm3, ymm3, ymm3
    }
  }
}
// 405133: positive sp value 10 has been found
// 4050CC: could not find valid save-restore pair for rbx

//----- (00000000004051E0) ----------------------------------------------------
__int64 __fastcall sub_4051E0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 result; // rax
  int v4; // ebx
  __int64 v5; // rcx

  result = 0LL;
  v4 = 0;
  v5 = 0LL;
  if ( a3 && a2 != a1 )
  {
    while ( (unsigned int)v5 < a3 )
    {
      LODWORD(result) = *(unsigned __int8 *)(a1 + v5);
      v4 = *(unsigned __int8 *)(a2 + v5);
      if ( !(_BYTE)result || (_BYTE)result != (_BYTE)v4 )
        break;
      v5 = (unsigned int)(v5 + 1);
    }
    return (unsigned int)(result - v4);
  }
  return result;
}

//----- (0000000000405211) ----------------------------------------------------
void __fastcall __noreturn sub_405211(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 i; // rcx

  dword_443C74 |= 4u;
  if ( (dword_440668 & 4) != 0 )
  {
    for ( i = (unsigned __int8)a1; ; qword_406038(a1, a2, a3, i) )
      ;
  }
  __asm { syscall; Low latency system call }
  _disable();
  __lidt(byte_405242);
  __halt();
}
// 405225: variable 'a3' is possibly undefined
// 405225: variable 'i' is possibly undefined
// 406038: using guessed type __int64 (__fastcall *qword_406038)(_QWORD, _QWORD, _QWORD, _QWORD);
// 440668: using guessed type int dword_440668;
// 443C74: using guessed type int dword_443C74;

//----- (000000000040524A) ----------------------------------------------------
__int64 __fastcall sub_40524A(int a1, int a2)
{
  int v2; // edx

  if ( (a1 & 7) == 7 )
  {
    v2 = 64;
    if ( (a2 & 1) == 0 && qword_440728 != (qword_440728 & a2) )
      v2 = 128;
  }
  else if ( (a1 & 3) == 3 )
  {
    v2 = 4;
    if ( (a2 & 1) == 0 )
      v2 = 4 * (qword_440728 != (qword_440728 & a2)) + 4;
  }
  else
  {
    v2 = 32;
    if ( (a1 & 5) != 5 )
    {
      v2 = 16;
      if ( (a1 & 4) == 0 )
        v2 = (a1 & 1) + 1;
    }
  }
  return v2 | (a1 | a2) & 0xDD000000;
}
// 440728: using guessed type __int64 qword_440728;

//----- (00000000004052D6) ----------------------------------------------------
__int64 sub_4052D6()
{
  if ( (dword_440668 & 4) == 0 )
    return sub_4018F7();
  dword_443C70 = sub_401EC9();
  return -1LL;
}
// 440668: using guessed type int dword_440668;
// 443C70: using guessed type int dword_443C70;

// nfuncs=84 queued=81 decompiled=81 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 81 function(s)"
